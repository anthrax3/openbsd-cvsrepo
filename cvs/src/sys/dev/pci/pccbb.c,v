head	1.96;
access;
symbols
	OPENBSD_6_1_BASE:1.96
	OPENBSD_6_0:1.96.0.6
	OPENBSD_6_0_BASE:1.96
	OPENBSD_5_9:1.96.0.2
	OPENBSD_5_9_BASE:1.96
	OPENBSD_5_8:1.95.0.4
	OPENBSD_5_8_BASE:1.95
	OPENBSD_5_7:1.92.0.6
	OPENBSD_5_7_BASE:1.92
	OPENBSD_5_6:1.92.0.4
	OPENBSD_5_6_BASE:1.92
	OPENBSD_5_5:1.91.0.4
	OPENBSD_5_5_BASE:1.91
	OPENBSD_5_4:1.89.0.4
	OPENBSD_5_4_BASE:1.89
	OPENBSD_5_3:1.89.0.2
	OPENBSD_5_3_BASE:1.89
	OPENBSD_5_2:1.87.0.8
	OPENBSD_5_2_BASE:1.87
	OPENBSD_5_1_BASE:1.87
	OPENBSD_5_1:1.87.0.6
	OPENBSD_5_0:1.87.0.4
	OPENBSD_5_0_BASE:1.87
	OPENBSD_4_9:1.87.0.2
	OPENBSD_4_9_BASE:1.87
	OPENBSD_4_8:1.76.0.2
	OPENBSD_4_8_BASE:1.76
	OPENBSD_4_7:1.70.0.2
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.64.0.4
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.63.0.2
	OPENBSD_4_5_BASE:1.63
	OPENBSD_4_4:1.61.0.2
	OPENBSD_4_4_BASE:1.61
	OPENBSD_4_3:1.59.0.2
	OPENBSD_4_3_BASE:1.59
	OPENBSD_4_2:1.47.0.4
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.31.0.4
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	UBC_SYNC_B:1.31
	UBC:1.26.0.4
	UBC_BASE:1.26
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	SMP:1.18.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.96
date	2015.09.11.09.15.44;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	GIBfOLJ2hE3523sJ;

1.95
date	2015.07.20.15.44.43;	author kettenis;	state Exp;
branches;
next	1.94;
commitid	63JwyFyYCIcwkL1w;

1.94
date	2015.07.19.05.37.38;	author bcook;	state Exp;
branches;
next	1.93;
commitid	RSXzBmOxfT0e4vWL;

1.93
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.92;
commitid	p4LJxGKbi0BU2cG6;

1.92
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.91;
commitid	OBNa5kfxQ2UXoiIw;

1.91
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2013.10.30.08.47.20;	author mpi;	state Exp;
branches;
next	1.89;

1.89
date	2012.10.18.21.40.49;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2010.12.08.20.22.49;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.85;

1.85
date	2010.09.08.17.56.16;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2010.09.08.17.54.37;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2010.09.08.17.53.55;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2010.09.06.18.34.34;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2010.09.03.21.45.11;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2010.08.31.17.41.46;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2010.08.27.04.09.20;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2010.08.25.21.37.59;	author kettenis;	state Exp;
branches;
next	1.76;

1.76
date	2010.06.30.19.46.30;	author blambert;	state Exp;
branches;
next	1.75;

1.75
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.74;

1.74
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.73;

1.73
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.72;

1.72
date	2010.03.23.11.44.00;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.13.09.10.33;	author jsg;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.11.04.31.40;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.28.15.54.52;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2009.07.25.11.27.26;	author kettenis;	state Exp;
branches;
next	1.66;

1.66
date	2009.07.21.20.59.45;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2009.07.20.23.40.43;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.03.04.32.10;	author jsg;	state Exp;
branches;
next	1.63;

1.63
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.62;

1.62
date	2008.09.25.17.54.01;	author chl;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.20.18.58.07;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.22.19.23.04;	author mk;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.20.13.59.27;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.19.21.34.10;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.14.20.55.08;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.09.17.25.24;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.30.13.43.35;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.30.08.12.00;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.26.15.35.15;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.25.22.35.21;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.25.18.59.12;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.25.18.57.50;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.25.12.18.34;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.23.19.46.16;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2006.10.12.16.35.51;	author grange;	state Exp;
branches;
next	1.46;

1.46
date	2006.06.21.11.27.03;	author fkr;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.14.08.36.31;	author fkr;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.02.23.29.05;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.11.09.58.34;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.11.04.07.28;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.26.14.31.26;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.23.11.39.37;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.05.21.32.28;	author tdeval;	state Exp;
branches;
next	1.38;

1.38
date	2005.10.02.18.20.00;	author fgsch;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.16.02.20.23;	author fgsch;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.03.23.08.22;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2005.01.27.17.03.23;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.14.21.54.18;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.23.20.52.23;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.25.21.53.45;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.23.17.53.25;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.30.13.23.32;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.24.18.21.42;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.25.10.13.30;	author art;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	2001.08.22.16.33.11;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.19.15.25.44;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.19.15.11.26;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.20.23.12.11;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.12.15.40.32;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.16.12.51.49;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.01.02.19.46;	author mickey;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.02.01.03.38.08;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.27.04.44.20;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.22.18.53.57;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.21.02.37.07;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.06.17.08.27;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.29.22.57.16;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.29.21.31.27;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.29.21.25.18;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.29.21.18.14;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.09.17.31.04;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.24.23.10.48;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.25.00.04.59;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.06.19.49.10;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.06.06.03.01;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.14.57.39;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.20.21.15.23;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.08.05.50.51;	author aaron;	state Exp;
branches;
next	;

1.18.2.1
date	2001.05.14.22.25.52;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2001.07.04.10.42.44;	author niklas;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.18.2.5;

1.18.2.5
date	2002.03.28.15.35.58;	author niklas;	state Exp;
branches;
next	1.18.2.6;

1.18.2.6
date	2003.03.28.00.38.23;	author niklas;	state Exp;
branches;
next	1.18.2.7;

1.18.2.7
date	2004.02.19.10.56.28;	author niklas;	state Exp;
branches;
next	;

1.26.4.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.26.4.3;

1.26.4.3
date	2002.10.29.00.33.29;	author art;	state Exp;
branches;
next	;


desc
@@


1.96
log
@fairly simple size for free()
@
text
@/*	$OpenBSD: pccbb.c,v 1.95 2015/07/20 15:44:43 kettenis Exp $	*/
/*	$NetBSD: pccbb.c,v 1.96 2004/03/28 09:49:31 nakayama Exp $	*/

/*
 * Copyright (c) 1998, 1999 and 2000
 *      HAYAKAWA Koichi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
#define CBB_DEBUG
#define SHOW_REGS
#define PCCBB_PCMCIA_POLL
*/

/*
#define CB_PCMCIA_POLL
#define CB_PCMCIA_POLL_ONLY
#define LEVEL2
*/

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/evcount.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/task.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/pccbbreg.h>

#include <dev/cardbus/cardslotvar.h>

#include <dev/cardbus/cardbusvar.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>

#include <dev/ic/i82365reg.h>
#include <dev/ic/i82365var.h>
#include <dev/pci/pccbbvar.h>

#ifndef __NetBSD_Version__
struct cfdriver cbb_cd = {
	NULL, "cbb", DV_DULL
};
#endif

#if defined CBB_DEBUG
#define DPRINTF(x) printf x
#else
#define DPRINTF(x)
#endif

int	pcicbbmatch(struct device *, void *, void *);
void	pccbbattach(struct device *, struct device *, void *);
int	pccbbactivate(struct device *, int);
int	pccbbintr(void *);
void	pccbb_shutdown(void *);
void	pci113x_insert(void *);
int	pccbbintr_function(struct pccbb_softc *);

int	pccbb_checksockstat(struct pccbb_softc *);
int	pccbb_detect_card(struct pccbb_softc *);

void	pccbb_pcmcia_write(struct pcic_handle *, int, int);
u_int8_t pccbb_pcmcia_read(struct pcic_handle *, int);
#define Pcic_read(ph, reg) ((ph)->ph_read((ph), (reg)))
#define Pcic_write(ph, reg, val) ((ph)->ph_write((ph), (reg), (val)))

int	cb_reset(struct pccbb_softc *);
int	cb_detect_voltage(struct pccbb_softc *);
int	cbbprint(void *, const char *);

int	cb_chipset(u_int32_t, int *);
void	pccbb_pcmcia_attach_setup(struct pccbb_softc *,
    struct pcmciabus_attach_args *);
#if 0
void	pccbb_pcmcia_attach_card(struct pcic_handle *);
void	pccbb_pcmcia_detach_card(struct pcic_handle *, int);
void	pccbb_pcmcia_deactivate_card(struct pcic_handle *);
#endif

int	pccbb_ctrl(cardbus_chipset_tag_t, int);
int	pccbb_power(cardbus_chipset_tag_t, int);
int	pccbb_cardenable(struct pccbb_softc * sc, int function);
void   *pccbb_intr_establish(struct pccbb_softc *, int irq, int level,
    int (*ih) (void *), void *sc, const char *);
void	pccbb_intr_disestablish(struct pccbb_softc *, void *ih);

void   *pccbb_cb_intr_establish(cardbus_chipset_tag_t, int irq, int level,
    int (*ih) (void *), void *sc, const char *);
void	pccbb_cb_intr_disestablish(cardbus_chipset_tag_t ct, void *ih);

void	pccbb_legacy_disable(struct pccbb_softc *sc);
void	pccbb_chipinit(struct pccbb_softc *);

int	pccbb_pcmcia_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
    struct pcmcia_mem_handle *);
void	pccbb_pcmcia_mem_free(pcmcia_chipset_handle_t,
    struct pcmcia_mem_handle *);
int	pccbb_pcmcia_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t,
    bus_size_t, struct pcmcia_mem_handle *, bus_size_t *, int *);
void	pccbb_pcmcia_mem_unmap(pcmcia_chipset_handle_t, int);
int	pccbb_pcmcia_io_alloc(pcmcia_chipset_handle_t, bus_addr_t,
    bus_size_t, bus_size_t, struct pcmcia_io_handle *);
void	pccbb_pcmcia_io_free(pcmcia_chipset_handle_t,
    struct pcmcia_io_handle *);
int	pccbb_pcmcia_io_map(pcmcia_chipset_handle_t, int, bus_addr_t,
    bus_size_t, struct pcmcia_io_handle *, int *);
void	pccbb_pcmcia_io_unmap(pcmcia_chipset_handle_t, int);
void   *pccbb_pcmcia_intr_establish(pcmcia_chipset_handle_t,
    struct pcmcia_function *, int, int (*)(void *), void *, char *);
void	pccbb_pcmcia_intr_disestablish(pcmcia_chipset_handle_t, void *);
const char *pccbb_pcmcia_intr_string(pcmcia_chipset_handle_t, void *);
void	pccbb_pcmcia_socket_enable(pcmcia_chipset_handle_t);
void	pccbb_pcmcia_socket_disable(pcmcia_chipset_handle_t);
int	pccbb_pcmcia_card_detect(pcmcia_chipset_handle_t pch);

void	pccbb_pcmcia_do_io_map(struct pcic_handle *, int);
void	pccbb_pcmcia_wait_ready(struct pcic_handle *);
void	pccbb_pcmcia_do_mem_map(struct pcic_handle *, int);

/* bus-space allocation and deallocation functions */
int	pccbb_rbus_cb_space_alloc(cardbus_chipset_tag_t, rbus_tag_t,
    bus_addr_t addr, bus_size_t size, bus_addr_t mask, bus_size_t align,
    int flags, bus_addr_t * addrp, bus_space_handle_t * bshp);
int	pccbb_rbus_cb_space_free(cardbus_chipset_tag_t, rbus_tag_t,
    bus_space_handle_t, bus_size_t);

int	pccbb_open_win(struct pccbb_softc *, bus_space_tag_t,
    bus_addr_t, bus_size_t, bus_space_handle_t, int flags);
int	pccbb_close_win(struct pccbb_softc *, bus_space_tag_t,
    bus_space_handle_t, bus_size_t);
int	pccbb_winlist_insert(struct pccbb_win_chain_head *, bus_addr_t,
    bus_size_t, bus_space_handle_t, int);
int	pccbb_winlist_delete(struct pccbb_win_chain_head *,
    bus_space_handle_t, bus_size_t);
void	pccbb_winset(bus_addr_t align, struct pccbb_softc *,
    bus_space_tag_t);
void	pccbb_winlist_show(struct pccbb_win_chain *);

/* for config_defer */
void	pccbb_pci_callback(struct device *);

#if defined SHOW_REGS
void	cb_show_regs(pci_chipset_tag_t, pcitag_t, bus_space_tag_t,
    bus_space_handle_t memh);
#endif

struct cfattach cbb_pci_ca = {
	sizeof(struct pccbb_softc), pcicbbmatch, pccbbattach, NULL,
	pccbbactivate
};

static struct pcmcia_chip_functions pccbb_pcmcia_funcs = {
	pccbb_pcmcia_mem_alloc,
	pccbb_pcmcia_mem_free,
	pccbb_pcmcia_mem_map,
	pccbb_pcmcia_mem_unmap,
	pccbb_pcmcia_io_alloc,
	pccbb_pcmcia_io_free,
	pccbb_pcmcia_io_map,
	pccbb_pcmcia_io_unmap,
	pccbb_pcmcia_intr_establish,
	pccbb_pcmcia_intr_disestablish,
	pccbb_pcmcia_intr_string,
	pccbb_pcmcia_socket_enable,
	pccbb_pcmcia_socket_disable,
	pccbb_pcmcia_card_detect
};

static struct cardbus_functions pccbb_funcs = {
	pccbb_rbus_cb_space_alloc,
	pccbb_rbus_cb_space_free,
	pccbb_cb_intr_establish,
	pccbb_cb_intr_disestablish,
	pccbb_ctrl,
	pccbb_power,
};

/*
 * delay_ms() is wait in milliseconds.  It should be used instead
 * of delay() if you want to wait more than 1 ms.
 */
static inline void
delay_ms(int millis, void *param)
{
	if (cold)
		delay(millis * 1000);
	else
		tsleep(param, PWAIT, "pccbb", MAX(2, hz * millis / 1000));
}

int
pcicbbmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_CARDBUS &&
	    PCI_INTERFACE(pa->pa_class) == 0) {
		return 1;
	}

	return 0;
}

#define MAKEID(vendor, prod) (((vendor) << PCI_VENDOR_SHIFT) \
				| ((prod) << PCI_PRODUCT_SHIFT))

struct yenta_chipinfo {
	pcireg_t yc_id;		       /* vendor tag | product tag */
	int yc_chiptype;
	int yc_flags;
} yc_chipsets[] = {
	/* Texas Instruments chips */
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1130), CB_TI113X,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1131), CB_TI113X,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1250), CB_TI125X,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1220), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1221), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1225), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251), CB_TI125X,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251B), CB_TI125X,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1211), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1410), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1420), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1450), CB_TI125X,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1451), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1510), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI7XX1), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},

	/* Ricoh chips */
	{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C475), CB_RX5C47X,
	    PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C476), CB_RX5C47X,
	    PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C477), CB_RX5C47X,
	    PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C478), CB_RX5C47X,
	    PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C465), CB_RX5C46X,
	    PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C466), CB_RX5C46X,
	    PCCBB_PCMCIA_MEM_32},

	/* Toshiba products */
	{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95),
	    CB_TOPIC95, PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95B),
	    CB_TOPIC95B, PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC97),
	    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC100),
	    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},

	/* Cirrus Logic products */
	{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6832),
	    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6833),
	    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},

	/* older O2Micro bridges */
	{ MAKEID(PCI_VENDOR_O2MICRO, PCI_PRODUCT_O2MICRO_OZ6729),
	    CB_OLDO2MICRO, PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_O2MICRO, PCI_PRODUCT_O2MICRO_OZ6730),
	    CB_OLDO2MICRO, PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_O2MICRO, PCI_PRODUCT_O2MICRO_OZ6872), /* 68[71]2 */
	    CB_OLDO2MICRO, PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_O2MICRO, PCI_PRODUCT_O2MICRO_OZ6832),
	    CB_OLDO2MICRO, PCCBB_PCMCIA_MEM_32},
	{ MAKEID(PCI_VENDOR_O2MICRO, PCI_PRODUCT_O2MICRO_OZ6836),
	    CB_OLDO2MICRO, PCCBB_PCMCIA_MEM_32},

	/* sentinel, or Generic chip */
	{ 0 /* null id */ , CB_UNKNOWN, PCCBB_PCMCIA_MEM_32},
};

int
cb_chipset(pci_id, flagp)
	u_int32_t pci_id;
	int *flagp;
{
	struct yenta_chipinfo *yc;

	/* Loop over except the last default entry. */
	for (yc = yc_chipsets; yc < yc_chipsets +
	    sizeof(yc_chipsets) / sizeof(yc_chipsets[0]) - 1; yc++)
		if (pci_id == yc->yc_id)
			break;

	if (flagp != NULL)
		*flagp = yc->yc_flags;

	return (yc->yc_chiptype);
}

void
pccbb_shutdown(void *arg)
{
	struct pccbb_softc *sc = arg;
	pcireg_t command;

	DPRINTF(("%s: shutdown\n", sc->sc_dev.dv_xname));

	/* turn off power */
	pccbb_power((cardbus_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);

	bus_space_write_4(sc->sc_base_memt, sc->sc_base_memh, CB_SOCKET_MASK,
	    0);

	command = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);

	command &= ~(PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE);
	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, command);
}

void
pccbbattach(struct device *parent, struct device *self, void *aux)
{
	struct pccbb_softc *sc = (void *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	u_long busnum;
	int flags;

	pccbb_attach_hook(parent, self, pa);

	sc->sc_chipset = cb_chipset(pa->pa_id, &flags);
	sc->sc_id = pa->pa_id;

#ifdef CBB_DEBUG
	printf(" (chipflags %x)", flags);
#endif

	TAILQ_INIT(&sc->sc_memwindow);
	TAILQ_INIT(&sc->sc_iowindow);

	sc->sc_rbus_iot = rbus_pccbb_parent_io(self, pa);
	sc->sc_rbus_memt = rbus_pccbb_parent_mem(self, pa);

	/*
	 * MAP socket registers and ExCA registers on memory-space
	 */
	if (pci_mapreg_map(pa, PCI_SOCKBASE, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_base_memt, &sc->sc_base_memh, NULL, NULL, 0)) {
		printf("can't map registers\n");
		return;
	}

	sc->sc_busnum = pci_conf_read(pc, pa->pa_tag, PCI_BUSNUM);

#if defined CBB_DEBUG
	{
		static char *intrname[5] = { "NON", "A", "B", "C", "D" };
		printf(": intrpin %s, line %d\n",
		    intrname[pa->pa_intrpin], pa->pa_intrline);
	}
#endif

	/* setup softc */
	sc->sc_pc = pc;
	sc->sc_iot = pa->pa_iot;
	sc->sc_memt = pa->pa_memt;
	sc->sc_dmat = pa->pa_dmat;
	sc->sc_tag = pa->pa_tag;
	sc->sc_function = pa->pa_function;
	sc->sc_intrtag = pa->pa_intrtag;
	sc->sc_intrpin = pa->pa_intrpin;

	sc->sc_pcmcia_flags = flags;   /* set PCMCIA facility */

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	/* must do this after intr is mapped and established */
	sc->sc_intrline = pci_intr_line(pc, ih);

	/*
	 * XXX pccbbintr should be called under the priority lower
	 * than any other hard interrupts.
	 */
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, pccbbintr, sc,
	    sc->sc_dev.dv_xname);

	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL) {
			printf(" at %s", intrstr);
		}
		printf("\n");
		return;
	}
	printf(": %s", intrstr);

	/*
	 * When the bus number isn't configured, try to allocate one
	 * ourselves.
	 */
	if ((sc->sc_busnum & 0x00ffff00) == 0 && pa->pa_busex &&
	    extent_alloc(pa->pa_busex, 1, 1, 0, 0, EX_NOWAIT, &busnum) == 0) {
		sc->sc_busnum |= (busnum << 8);
		sc->sc_busnum |= (busnum << 16);
		pci_conf_write(pc, pa->pa_tag, PCI_BUSNUM, sc->sc_busnum);
	}

	/*
	 * When the bus number still isn't set correctly, give up
	 * using 32-bit CardBus mode.
	 */
	if (((sc->sc_busnum >> 8) & 0xff) == 0) {
		printf(", CardBus support disabled");
		sc->sc_pcmcia_flags |= PCCBB_PCMCIA_16BITONLY;
	}

	printf("\n");

	/* Disable legacy register mapping. */
	pccbb_legacy_disable(sc);

	timeout_set(&sc->sc_ins_tmo, pci113x_insert, sc);
	config_defer(self, pccbb_pci_callback);
}

/*
 * void pccbb_pci_callback(struct device *self)
 *
 *   The actual attach routine: get memory space for YENTA register
 *   space, setup YENTA register and route interrupt.
 *
 *   This function should be deferred because this device may obtain
 *   memory space dynamically.  This function must avoid obtaining
 *   memory area which has already kept for another device.  Also,
 *   this function MUST be done before ISA attach process because this
 *   function kills pcic compatible port used by ISA pcic.
 */
void
pccbb_pci_callback(struct device *self)
{
	struct pccbb_softc *sc = (void *)self;
	pci_chipset_tag_t pc = sc->sc_pc;
	bus_space_tag_t base_memt;
	bus_space_handle_t base_memh;
	u_int32_t maskreg;
	struct cbslot_attach_args cba;
	struct pcmciabus_attach_args paa;
	struct cardslot_attach_args caa;
	struct cardslot_softc *csc;
	u_int32_t sockstat;

	base_memt = sc->sc_base_memt;  /* socket regs memory tag */
	base_memh = sc->sc_base_memh;  /* socket regs memory handle */

	/* bus bridge initialization */
	pccbb_chipinit(sc);

	/* clear data structure for child device interrupt handlers */
	sc->sc_pil = NULL;
	sc->sc_pil_intr_enable = 1;

	sockstat = bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);
	if ((sockstat & CB_SOCKET_STAT_CD) == 0)
		sc->sc_flags |= CBB_CARDEXIST;

	/*
	 * attach cardbus
	 */
	if (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {
		pcireg_t busreg = pci_conf_read(pc, sc->sc_tag, PCI_BUSNUM);
		pcireg_t bhlc = pci_conf_read(pc, sc->sc_tag, PCI_BHLC_REG);

		/* initialize cbslot_attach */
		cba.cba_busname = "cardbus";
		cba.cba_iot = sc->sc_iot;
		cba.cba_memt = sc->sc_memt;
		cba.cba_dmat = sc->sc_dmat;
		cba.cba_bus = (busreg >> 8) & 0x0ff;
		cba.cba_cc = (void *)sc;
		cba.cba_pc = sc->sc_pc;
		cba.cba_cf = &pccbb_funcs;
		cba.cba_intrline = sc->sc_intrline;

		cba.cba_rbus_iot = sc->sc_rbus_iot;
		cba.cba_rbus_memt = sc->sc_rbus_memt;

		cba.cba_cacheline = PCI_CACHELINE(bhlc);
		cba.cba_lattimer = PCI_CB_LATENCY(busreg);

#if defined CBB_DEBUG
		printf("%s: cacheline 0x%x lattimer 0x%x\n",
		    sc->sc_dev.dv_xname, cba.cba_cacheline, cba.cba_lattimer);
		printf("%s: bhlc 0x%x lscp 0x%x\n", sc->sc_dev.dv_xname, bhlc,
		    busreg);
#endif
#if defined SHOW_REGS
		cb_show_regs(sc->sc_pc, sc->sc_tag, sc->sc_base_memt,
		    sc->sc_base_memh);
#endif
	}

	pccbb_pcmcia_attach_setup(sc, &paa);
	caa.caa_cb_attach = NULL;
	if (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {
		caa.caa_cb_attach = &cba;
	}
	caa.caa_16_attach = &paa;
	caa.caa_ph = &sc->sc_pcmcia_h;

	if (NULL != (csc = (void *)config_found(self, &caa, cbbprint))) {
		DPRINTF(("pccbbattach: found cardslot\n"));
		sc->sc_csc = csc;
	}

	sc->sc_ints_on = 1;

	/* CSC Interrupt: Card detect interrupt on */
	maskreg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);
	maskreg |= CB_SOCKET_MASK_CD;  /* Card detect intr is turned on. */
	bus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, maskreg);
	/* reset interrupt */
	bus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT,
	    bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT));

	return;
}

void
pccbb_legacy_disable(struct pccbb_softc *sc)
{
	pcireg_t reg;

	switch (sc->sc_chipset) {
	case CB_RX5C46X:
		/*
		 * The legacy pcic io-port on Ricoh RX5C46X CardBus bridges
		 * cannot be disabled by substituting 0 into PCI_LEGACY
		 * register.  Ricoh CardBus bridges have special bits on Bridge
		 * control reg (addr 0x3e on PCI config space).
		 */
		reg = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR);
		reg &= ~(CB_BCRI_RL_3E0_ENA | CB_BCRI_RL_3E2_ENA);
		pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, reg);
		break;

	default:
		pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_LEGACY, 0x0);
		break;
	}
}

/*
 * void pccbb_chipinit(struct pccbb_softc *sc)
 *
 *   This function initialize YENTA chip registers listed below:
 *     1) PCI command reg,
 *     2) PCI and CardBus latency timer,
 *     3) route PCI interrupt,
 *     4) close all memory and io windows.
 */
void
pccbb_chipinit(struct pccbb_softc *sc)
{
	pci_chipset_tag_t pc = sc->sc_pc;
	pcitag_t tag = sc->sc_tag;
	pcireg_t reg;

	/* Power on the controller if the BIOS didn't */
	pci_set_powerstate(pc, tag, PCI_PMCSR_STATE_D0);

	/*
	 * Set PCI command reg.
	 * Some laptop's BIOSes (i.e. TICO) do not enable CardBus chip.
	 */
	reg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	/* I believe it is harmless. */
	reg |= (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, reg);

	/*
	 * Set CardBus latency timer.
	 */
	reg = pci_conf_read(pc, tag, PCI_CB_LSCP_REG);
	if (PCI_CB_LATENCY(reg) < 0x20) {
		reg &= ~(PCI_CB_LATENCY_MASK << PCI_CB_LATENCY_SHIFT);
		reg |= (0x20 << PCI_CB_LATENCY_SHIFT);
		pci_conf_write(pc, tag, PCI_CB_LSCP_REG, reg);
	}
	DPRINTF(("CardBus latency timer 0x%x (%x)\n",
	    PCI_CB_LATENCY(reg), pci_conf_read(pc, tag, PCI_CB_LSCP_REG)));

	/*
	 * Set PCI latency timer.
	 */
	reg = pci_conf_read(pc, tag, PCI_BHLC_REG);
	if (PCI_LATTIMER(reg) < 0x10) {
		reg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
		reg |= (0x10 << PCI_LATTIMER_SHIFT);
		pci_conf_write(pc, tag, PCI_BHLC_REG, reg);
	}
	DPRINTF(("PCI latency timer 0x%x (%x)\n",
	    PCI_LATTIMER(reg), pci_conf_read(pc, tag, PCI_BHLC_REG)));

	/* Route functional interrupts to PCI. */
	reg = pci_conf_read(pc, tag, PCI_BCR_INTR);
	reg |= CB_BCR_INTR_IREQ_ENABLE;		/* disable PCI Intr */
	reg |= CB_BCR_WRITE_POST_ENABLE;	/* enable write post */
	reg |= CB_BCR_RESET_ENABLE;		/* assert reset */
	pci_conf_write(pc, tag, PCI_BCR_INTR, reg);

	switch (sc->sc_chipset) {
	case CB_TI113X:
		reg = pci_conf_read(pc, tag, PCI_CBCTRL);
		/* This bit is shared, but may read as 0 on some chips, so set
		   it explicitly on both functions. */
		reg |= PCI113X_CBCTRL_PCI_IRQ_ENA;
		/* CSC intr enable */
		reg |= PCI113X_CBCTRL_PCI_CSC;
		/* functional intr prohibit | prohibit ISA routing */
		reg &= ~(PCI113X_CBCTRL_PCI_INTR | PCI113X_CBCTRL_INT_MASK);
		pci_conf_write(pc, tag, PCI_CBCTRL, reg);
		break;

	case CB_TI12XX:
		/*
		 * Some TI 12xx (and [14][45]xx) based pci cards
		 * sometimes have issues with the MFUNC register not
		 * being initialized due to a bad EEPROM on board.
		 * Laptops that this matters on have this register
		 * properly initialized.
		 *
		 * The TI125X parts have a different register.
		 */
		reg = pci_conf_read(pc, tag, PCI12XX_MFUNC);
		if (reg == PCI12XX_MFUNC_DEFAULT) {
			reg &= ~PCI12XX_MFUNC_PIN0;
			reg |= PCI12XX_MFUNC_PIN0_INTA;
			if ((pci_conf_read(pc, tag, PCI_SYSCTRL) &
			     PCI12XX_SYSCTRL_INTRTIE) == 0) {
				reg &= ~PCI12XX_MFUNC_PIN1;
				reg |= PCI12XX_MFUNC_PIN1_INTB;
			}
			pci_conf_write(pc, tag, PCI12XX_MFUNC, reg);
		}
		/* FALLTHROUGH */

	case CB_TI125X:
		/*
		 * Disable zoom video.  Some machines initialize this
		 * improperly and experience has shown that this helps
		 * prevent strange behavior.
		 */
		pci_conf_write(pc, tag, PCI12XX_MMCTRL, 0);

		reg = pci_conf_read(pc, tag, PCI_SYSCTRL);
		reg |= PCI12XX_SYSCTRL_VCCPROT;
		pci_conf_write(pc, tag, PCI_SYSCTRL, reg);
		reg = pci_conf_read(pc, tag, PCI_CBCTRL);
		reg |= PCI12XX_CBCTRL_CSC;
		pci_conf_write(pc, tag, PCI_CBCTRL, reg);
		break;

	case CB_TOPIC95B:
		reg = pci_conf_read(pc, tag, TOPIC_SOCKET_CTRL);
		reg |= TOPIC_SOCKET_CTRL_SCR_IRQSEL;
		pci_conf_write(pc, tag, TOPIC_SOCKET_CTRL, reg);

		reg = pci_conf_read(pc, tag, TOPIC_SLOT_CTRL);
		DPRINTF(("%s: topic slot ctrl reg 0x%x -> ",
		    sc->sc_dev.dv_xname, reg));
		reg |= (TOPIC_SLOT_CTRL_SLOTON | TOPIC_SLOT_CTRL_SLOTEN |
		    TOPIC_SLOT_CTRL_ID_LOCK | TOPIC_SLOT_CTRL_CARDBUS);
		reg &= ~TOPIC_SLOT_CTRL_SWDETECT;
		DPRINTF(("0x%x\n", reg));
		pci_conf_write(pc, tag, TOPIC_SLOT_CTRL, reg);
		break;

	case CB_TOPIC97:
		reg = pci_conf_read(pc, tag, TOPIC_SLOT_CTRL);
		DPRINTF(("%s: topic slot ctrl reg 0x%x -> ",
		    sc->sc_dev.dv_xname, reg));
		reg |= (TOPIC_SLOT_CTRL_SLOTON | TOPIC_SLOT_CTRL_SLOTEN |
		    TOPIC_SLOT_CTRL_ID_LOCK | TOPIC_SLOT_CTRL_CARDBUS);
		reg &= ~TOPIC_SLOT_CTRL_SWDETECT;
		reg |= TOPIC97_SLOT_CTRL_PCIINT;
		reg &= ~(TOPIC97_SLOT_CTRL_STSIRQP | TOPIC97_SLOT_CTRL_IRQP);
		DPRINTF(("0x%x\n", reg));
		pci_conf_write(pc, tag, TOPIC_SLOT_CTRL, reg);

		/* make sure to assert LV card support bits */
		bus_space_write_1(sc->sc_base_memt, sc->sc_base_memh,
		    0x800 + 0x3e, bus_space_read_1(sc->sc_base_memt,
		    sc->sc_base_memh, 0x800 + 0x3e) | 0x03);
		break;

	case CB_OLDO2MICRO:
		/*
		 * older bridges have problems with both read prefetch and
		 * write bursting depending on the combination of the chipset,
		 * bridge and the cardbus card. so disable them to be on the
		 * safe side. One example is O2Micro 6812 with Atheros AR5012
		 * chipsets
		 */
		DPRINTF(("%s: old O2Micro bridge found\n",
		    sc->sc_dev.dv_xname, reg));
		reg = pci_conf_read(pc, tag, O2MICRO_RESERVED1);
		pci_conf_write(pc, tag, O2MICRO_RESERVED1, reg &
		    ~(O2MICRO_RES_READ_PREFETCH | O2MICRO_RES_WRITE_BURST));
		reg = pci_conf_read(pc, tag, O2MICRO_RESERVED2);
		pci_conf_write(pc, tag, O2MICRO_RESERVED2, reg &
		    ~(O2MICRO_RES_READ_PREFETCH | O2MICRO_RES_WRITE_BURST));
		break;
	}

	/* Close all memory and I/O windows. */
	pci_conf_write(pc, tag, PCI_CB_MEMBASE0, 0xffffffff);
	pci_conf_write(pc, tag, PCI_CB_MEMLIMIT0, 0);
	pci_conf_write(pc, tag, PCI_CB_MEMBASE1, 0xffffffff);
	pci_conf_write(pc, tag, PCI_CB_MEMLIMIT1, 0);
	pci_conf_write(pc, tag, PCI_CB_IOBASE0, 0xffffffff);
	pci_conf_write(pc, tag, PCI_CB_IOLIMIT0, 0);
	pci_conf_write(pc, tag, PCI_CB_IOBASE1, 0xffffffff);
	pci_conf_write(pc, tag, PCI_CB_IOLIMIT1, 0);

	/* reset 16-bit pcmcia bus */
	bus_space_write_1(sc->sc_base_memt, sc->sc_base_memh,
	    0x800 + PCIC_INTR,
	    bus_space_read_1(sc->sc_base_memt, sc->sc_base_memh,
		0x800 + PCIC_INTR) & ~PCIC_INTR_RESET);

	/* turn off power */
	pccbb_power((cardbus_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
}




/*
 * void pccbb_pcmcia_attach_setup(struct pccbb_softc *sc,
 *					 struct pcmciabus_attach_args *paa)
 *
 *   This function attaches 16-bit PCcard bus.
 */
void
pccbb_pcmcia_attach_setup(struct pccbb_softc *sc,
    struct pcmciabus_attach_args *paa)
{
	struct pcic_handle *ph = &sc->sc_pcmcia_h;
	rbus_tag_t rb;

	/* initialize pcmcia part in pccbb_softc */
	ph->ph_parent = (struct device *)sc;
	ph->sock = sc->sc_function;
	ph->flags = 0;
	ph->shutdown = 0;
	ph->ih_irq = sc->sc_intrline;
	ph->ph_bus_t = sc->sc_base_memt;
	ph->ph_bus_h = sc->sc_base_memh;
	ph->ph_read = pccbb_pcmcia_read;
	ph->ph_write = pccbb_pcmcia_write;
	sc->sc_pct = &pccbb_pcmcia_funcs;

	/*
	 * We need to do a few things here:
	 * 1) Disable routing of CSC and functional interrupts to ISA IRQs by
	 *    setting the IRQ numbers to 0.
	 * 2) Set bit 4 of PCIC_INTR, which is needed on some chips to enable
	 *    routing of CSC interrupts (e.g. card removal) to PCI while in
	 *    PCMCIA mode.  We just leave this set all the time.
	 * 3) Enable card insertion/removal interrupts in case the chip also
	 *    needs that while in PCMCIA mode.
	 * 4) Clear any pending CSC interrupt.
	 */
	Pcic_write(ph, PCIC_INTR, PCIC_INTR_ENABLE | PCIC_INTR_RESET);
	if (sc->sc_chipset == CB_TI113X) {
		Pcic_write(ph, PCIC_CSC_INTR, 0);
	} else {
		Pcic_write(ph, PCIC_CSC_INTR, PCIC_CSC_INTR_CD_ENABLE);
		Pcic_read(ph, PCIC_CSC);
	}

	/* initialize pcmcia bus attachment */
	paa->paa_busname = "pcmcia";
	paa->pct = sc->sc_pct;
	paa->pch = ph;
	paa->iobase = 0;	       /* I don't use them */
	paa->iosize = 0;
	rb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;
	paa->iobase = rb->rb_start + rb->rb_offset;
	paa->iosize = rb->rb_end - rb->rb_start;

	return;
}

#if 0
void
pccbb_pcmcia_attach_card(struct pcic_handle *ph)
{
	if (ph->flags & PCIC_FLAG_CARDP) {
		panic("pccbb_pcmcia_attach_card: already attached");
	}

	/* call the MI attach function */
	pcmcia_card_attach(ph->pcmcia);

	ph->flags |= PCIC_FLAG_CARDP;
}

void
pccbb_pcmcia_detach_card(struct pcic_handle *ph, int flags)
{
	if (!(ph->flags & PCIC_FLAG_CARDP)) {
		panic("pccbb_pcmcia_detach_card: already detached");
	}

	ph->flags &= ~PCIC_FLAG_CARDP;

	/* call the MI detach function */
	pcmcia_card_detach(ph->pcmcia, flags);
}
#endif

int
pccbb_checksockstat(struct pccbb_softc *sc)
{
	u_int32_t sockstate;

	sockstate = bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,
	    CB_SOCKET_STAT);

	if ((sockstate & CB_SOCKET_STAT_CD) != 0) {
		/* A card should be removed. */
		if (sc->sc_flags & CBB_CARDEXIST) {
			DPRINTF(("%s: card removed, 0x%08x\n",
			    sc->sc_dev.dv_xname, sockstate));
			sc->sc_flags &= ~CBB_CARDEXIST;
			if (sc->sc_csc->sc_status & CARDSLOT_STATUS_CARD_16) {
#if 0
				struct pcic_handle *ph =
				    &sc->sc_pcmcia_h;

				pcmcia_card_deactivate(ph->pcmcia);
				pccbb_pcmcia_socket_disable(ph);
				pccbb_pcmcia_detach_card(ph,
				    DETACH_FORCE);
#endif
				cardslot_event_throw(sc->sc_csc,
				    CARDSLOT_EVENT_REMOVAL_16);
			} else if (sc->sc_csc->sc_status &
			    CARDSLOT_STATUS_CARD_CB) {
				/* Cardbus intr removed */
				cardslot_event_throw(sc->sc_csc,
				    CARDSLOT_EVENT_REMOVAL_CB);
			}
		}
		return (1);
	} else if ((sockstate & CB_SOCKET_STAT_CD) == 0 &&
	    (sc->sc_flags & CBB_CARDEXIST) == 0) {
		timeout_add_msec(&sc->sc_ins_tmo, 100);
		sc->sc_flags |= CBB_INSERTING;
		return (1);
	}
	return (0);
}

/*
 * int pccbbintr(arg)
 *    void *arg;
 *   This routine handles the interrupt from Yenta PCI-CardBus bridge
 *   itself.
 */
int
pccbbintr(void *arg)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)arg;
	u_int32_t sockevent;
	struct pcic_handle *ph = &sc->sc_pcmcia_h;

	if (!sc->sc_ints_on)
		return 0;

	sockevent = bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,
	    CB_SOCKET_EVENT);
	bus_space_write_4(sc->sc_base_memt, sc->sc_base_memh,
	    CB_SOCKET_EVENT, sockevent);
	Pcic_read(ph, PCIC_CSC);

	if (sockevent & CB_SOCKET_EVENT_CD) {
		if (pccbb_checksockstat(sc))
			return (1);
	}

	if (sc->sc_pil_intr_enable)
		return pccbbintr_function(sc);
	return (0);
}

/*
 * int pccbbintr_function(struct pccbb_softc *sc)
 *
 *    This function calls each interrupt handler registered at the
 *    bridge.  The interrupt handlers are called in registered order.
 */
int
pccbbintr_function(struct pccbb_softc *sc)
{
	int retval = 0, val;
	struct pccbb_intrhand_list *pil;
	int s, splchanged;

	for (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {
		/*
		 * XXX priority change.  gross.  I use if-else
		 * sentences instead of switch-case sentences in order
		 * to avoid duplicate case value error.  More than one
		 * IPL_XXX may use the same value.  It depends on the
		 * implementation.
		 */
		splchanged = 1;
#if 0
		if (pil->pil_level == IPL_SERIAL) {
			s = splserial();
		} else if (pil->pil_level == IPL_HIGH) {
#endif
		if (pil->pil_level == IPL_HIGH) {
			s = splhigh();
		} else if (pil->pil_level == IPL_CLOCK) {
			s = splclock();
		} else if (pil->pil_level == IPL_AUDIO) {
			s = splaudio();
		} else if (pil->pil_level == IPL_VM) {
			s = splvm();
		} else if (pil->pil_level == IPL_TTY) {
			s = spltty();
#if 0
		} else if (pil->pil_level == IPL_SOFTSERIAL) {
			s = splsoftserial();
#endif
		} else if (pil->pil_level == IPL_NET) {
			s = splnet();
		} else {
			splchanged = 0;
			/* XXX: ih lower than IPL_BIO runs w/ IPL_BIO. */
		}

		val = (*pil->pil_func)(pil->pil_arg);
		if (val != 0)
			pil->pil_count.ec_count++;

		if (splchanged != 0) {
			splx(s);
		}

		if (retval == 0 || val != 0)
			retval = val;
	}

	return retval;
}

void
pci113x_insert(void *arg)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)arg;
	u_int32_t sockevent, sockstate;

	sockevent = bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,
	    CB_SOCKET_EVENT);
	sockstate = bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,
	    CB_SOCKET_STAT);

	if (0 == (sockstate & CB_SOCKET_STAT_CD)) {	/* card exist */
		DPRINTF(("%s: 0x%08x", sc->sc_dev.dv_xname, sockevent));
		DPRINTF((" card inserted, 0x%08x\n", sockstate));
		sc->sc_flags |= CBB_CARDEXIST;
		/* call pccard interrupt handler here */
		if (sockstate & CB_SOCKET_STAT_16BIT) {
			/* 16-bit card found */
/*      pccbb_pcmcia_attach_card(&sc->sc_pcmcia_h); */
			cardslot_event_throw(sc->sc_csc,
			    CARDSLOT_EVENT_INSERTION_16);
		} else if (sockstate & CB_SOCKET_STAT_CB) {
			/* cardbus card found */
/*      cardbus_attach_card(sc->sc_csc); */
			cardslot_event_throw(sc->sc_csc,
			    CARDSLOT_EVENT_INSERTION_CB);
		} else {
			/* who are you? */
		}
	} else {
		timeout_add_msec(&sc->sc_ins_tmo, 100);
	}
}

#define PCCBB_PCMCIA_OFFSET 0x800
u_int8_t
pccbb_pcmcia_read(struct pcic_handle *ph, int reg)
{
	bus_space_barrier(ph->ph_bus_t, ph->ph_bus_h,
	    PCCBB_PCMCIA_OFFSET + reg, 1, BUS_SPACE_BARRIER_READ);

	return bus_space_read_1(ph->ph_bus_t, ph->ph_bus_h,
	    PCCBB_PCMCIA_OFFSET + reg);
}

void
pccbb_pcmcia_write(struct pcic_handle *ph, int reg, int val)
{
	bus_space_barrier(ph->ph_bus_t, ph->ph_bus_h,
	    PCCBB_PCMCIA_OFFSET + reg, 1, BUS_SPACE_BARRIER_WRITE);

	bus_space_write_1(ph->ph_bus_t, ph->ph_bus_h, PCCBB_PCMCIA_OFFSET + reg,
	    val);
}

/*
 * int pccbb_ctrl(cardbus_chipset_tag_t, int)
 */
int
pccbb_ctrl(cardbus_chipset_tag_t ct, int command)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;

	switch (command) {
	case CARDBUS_CD:
		if (2 == pccbb_detect_card(sc)) {
			int retval = 0;
			int status = cb_detect_voltage(sc);
			if (PCCARD_VCC_5V & status) {
				retval |= CARDBUS_5V_CARD;
			}
			if (PCCARD_VCC_3V & status) {
				retval |= CARDBUS_3V_CARD;
			}
			if (PCCARD_VCC_XV & status) {
				retval |= CARDBUS_XV_CARD;
			}
			if (PCCARD_VCC_YV & status) {
				retval |= CARDBUS_YV_CARD;
			}
			return retval;
		} else {
			return 0;
		}
		break;
	case CARDBUS_RESET:
		return cb_reset(sc);
		break;
	case CARDBUS_IO_ENABLE:       /* fallthrough */
	case CARDBUS_IO_DISABLE:      /* fallthrough */
	case CARDBUS_MEM_ENABLE:      /* fallthrough */
	case CARDBUS_MEM_DISABLE:     /* fallthrough */
	case CARDBUS_BM_ENABLE:       /* fallthrough */
	case CARDBUS_BM_DISABLE:      /* fallthrough */
		return pccbb_cardenable(sc, command);
		break;
	}

	return 0;
}

/*
 * int pccbb_power(cardbus_chipset_tag_t, int)
 *   This function returns true when it succeeds and returns false when
 *   it fails.
 */
int
pccbb_power(cardbus_chipset_tag_t ct, int command)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;

	u_int32_t status, sock_ctrl;
	bus_space_tag_t memt = sc->sc_base_memt;
	bus_space_handle_t memh = sc->sc_base_memh;

	DPRINTF(("pccbb_power: %s and %s [%x]\n",
	    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_UC ? "CARDBUS_VCC_UC" :
	    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_5V ? "CARDBUS_VCC_5V" :
	    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_3V ? "CARDBUS_VCC_3V" :
	    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_XV ? "CARDBUS_VCC_XV" :
	    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_YV ? "CARDBUS_VCC_YV" :
	    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_0V ? "CARDBUS_VCC_0V" :
	    "UNKNOWN",
	    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_UC ? "CARDBUS_VPP_UC" :
	    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_12V ? "CARDBUS_VPP_12V" :
	    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_VCC ? "CARDBUS_VPP_VCC" :
	    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_0V ? "CARDBUS_VPP_0V" :
	    "UNKNOWN", command));

	status = bus_space_read_4(memt, memh, CB_SOCKET_STAT);
	sock_ctrl = bus_space_read_4(memt, memh, CB_SOCKET_CTRL);

	switch (command & CARDBUS_VCCMASK) {
	case CARDBUS_VCC_UC:
		break;
	case CARDBUS_VCC_5V:
		if (CB_SOCKET_STAT_5VCARD & status) {	/* check 5 V card */
			sock_ctrl &= ~CB_SOCKET_CTRL_VCCMASK;
			sock_ctrl |= CB_SOCKET_CTRL_VCC_5V;
		} else {
			printf("%s: BAD voltage request: no 5 V card\n",
			    sc->sc_dev.dv_xname);
		}
		break;
	case CARDBUS_VCC_3V:
		if (CB_SOCKET_STAT_3VCARD & status) {
			sock_ctrl &= ~CB_SOCKET_CTRL_VCCMASK;
			sock_ctrl |= CB_SOCKET_CTRL_VCC_3V;
		} else {
			printf("%s: BAD voltage request: no 3.3 V card\n",
			    sc->sc_dev.dv_xname);
		}
		break;
	case CARDBUS_VCC_0V:
		sock_ctrl &= ~CB_SOCKET_CTRL_VCCMASK;
		break;
	default:
		return 0;	       /* power NEVER changed */
		break;
	}

	switch (command & CARDBUS_VPPMASK) {
	case CARDBUS_VPP_UC:
		break;
	case CARDBUS_VPP_0V:
		sock_ctrl &= ~CB_SOCKET_CTRL_VPPMASK;
		break;
	case CARDBUS_VPP_VCC:
		sock_ctrl &= ~CB_SOCKET_CTRL_VPPMASK;
		sock_ctrl |= ((sock_ctrl >> 4) & 0x07);
		break;
	case CARDBUS_VPP_12V:
		sock_ctrl &= ~CB_SOCKET_CTRL_VPPMASK;
		sock_ctrl |= CB_SOCKET_CTRL_VPP_12V;
		break;
	}

#if 0
	DPRINTF(("sock_ctrl: %x\n", sock_ctrl));
#endif
	bus_space_write_4(memt, memh, CB_SOCKET_CTRL, sock_ctrl);
	status = bus_space_read_4(memt, memh, CB_SOCKET_STAT);

	if (status & CB_SOCKET_STAT_BADVCC) {	/* bad Vcc request */
		printf
		    ("%s: bad Vcc request. sock_ctrl 0x%x, sock_status 0x%x\n",
		    sc->sc_dev.dv_xname, sock_ctrl, status);
		DPRINTF(("pccbb_power: %s and %s [%x]\n",
		    (command & CARDBUS_VCCMASK) ==
		    CARDBUS_VCC_UC ? "CARDBUS_VCC_UC" : (command &
		    CARDBUS_VCCMASK) ==
		    CARDBUS_VCC_5V ? "CARDBUS_VCC_5V" : (command &
		    CARDBUS_VCCMASK) ==
		    CARDBUS_VCC_3V ? "CARDBUS_VCC_3V" : (command &
		    CARDBUS_VCCMASK) ==
		    CARDBUS_VCC_XV ? "CARDBUS_VCC_XV" : (command &
		    CARDBUS_VCCMASK) ==
		    CARDBUS_VCC_YV ? "CARDBUS_VCC_YV" : (command &
		    CARDBUS_VCCMASK) ==
		    CARDBUS_VCC_0V ? "CARDBUS_VCC_0V" : "UNKNOWN",
		    (command & CARDBUS_VPPMASK) ==
		    CARDBUS_VPP_UC ? "CARDBUS_VPP_UC" : (command &
		    CARDBUS_VPPMASK) ==
		    CARDBUS_VPP_12V ? "CARDBUS_VPP_12V" : (command &
		    CARDBUS_VPPMASK) ==
		    CARDBUS_VPP_VCC ? "CARDBUS_VPP_VCC" : (command &
		    CARDBUS_VPPMASK) ==
		    CARDBUS_VPP_0V ? "CARDBUS_VPP_0V" : "UNKNOWN", command));
#if 0
		if (command == (CARDBUS_VCC_0V | CARDBUS_VPP_0V)) {
			u_int32_t force =
			    bus_space_read_4(memt, memh, CB_SOCKET_FORCE);
			/* Reset Bad Vcc request */
			force &= ~CB_SOCKET_FORCE_BADVCC;
			bus_space_write_4(memt, memh, CB_SOCKET_FORCE, force);
			printf("new status 0x%x\n", bus_space_read_4(memt, memh,
			    CB_SOCKET_STAT));
			return 1;
		}
#endif
		return 0;
	}

	/*
	 * XXX delay 300 ms: though the standard defines that the Vcc set-up
	 * time is 20 ms, some PC-Card bridge requires longer duration.
	 */
	delay(300 * 1000);

	return 1;		       /* power changed correctly */
}

#if defined CB_PCMCIA_POLL
struct cb_poll_str {
	void *arg;
	int (*func)(void *);
	int level;
	pccard_chipset_tag_t ct;
	int count;
};

static struct cb_poll_str cb_poll[10];
static int cb_poll_n = 0;
static struct timeout cb_poll_timeout;

void cb_pcmcia_poll(void *arg);

void
cb_pcmcia_poll(void *arg)
{
	struct cb_poll_str *poll = arg;
	struct cbb_pcmcia_softc *psc = (void *)poll->ct->v;
	struct pccbb_softc *sc = psc->cpc_parent;
	int s;
	u_int32_t spsr;		       /* socket present-state reg */

	timeout_set(&cb_poll_timeout, cb_pcmcia_poll, arg);
	timeout_add(&cb_poll_timeout, hz / 10);
	switch (poll->level) {
	case IPL_NET:
		s = splnet();
		break;
	case IPL_BIO:
		s = splbio();
		break;
	case IPL_TTY:		       /* fallthrough */
	default:
		s = spltty();
		break;
	}

	spsr =
	    bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,
	    CB_SOCKET_STAT);

#if defined CB_PCMCIA_POLL_ONLY && defined LEVEL2
	if (!(spsr & 0x40)) {	       /* CINT low */
#else
	if (1) {
#endif
		if ((*poll->func) (poll->arg) == 1) {
			++poll->count;
			printf("intr: reported from poller, 0x%x\n", spsr);
#if defined LEVEL2
		} else {
			printf("intr: miss! 0x%x\n", spsr);
#endif
		}
	}
	splx(s);
}
#endif /* defined CB_PCMCIA_POLL */

/*
 * int pccbb_detect_card(struct pccbb_softc *sc)
 *   return value:  0 if no card exists.
 *                  1 if 16-bit card exists.
 *                  2 if cardbus card exists.
 */
int
pccbb_detect_card(struct pccbb_softc *sc)
{
	bus_space_handle_t base_memh = sc->sc_base_memh;
	bus_space_tag_t base_memt = sc->sc_base_memt;
	u_int32_t sockstat =
	    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);
	int retval = 0;

	/*
	 * The SCM Microsystems TI1225-based PCI-CardBus dock card that
	 * ships with some Lucent WaveLAN cards has only one physical slot
	 * but OpenBSD probes two. The phantom card in the second slot can
	 * be ignored by punting on unsupported voltages.
	 */
	if (sockstat & CB_SOCKET_STAT_XVCARD)
		return 0;

	/* CD1 and CD2 asserted */
	if (0x00 == (sockstat & CB_SOCKET_STAT_CD)) {
		/* card must be present */
		if (!(CB_SOCKET_STAT_NOTCARD & sockstat)) {
			/* NOTACARD DEASSERTED */
			if (CB_SOCKET_STAT_CB & sockstat) {
				/* CardBus mode */
				retval = 2;
			} else if (CB_SOCKET_STAT_16BIT & sockstat) {
				/* 16-bit mode */
				retval = 1;
			}
		}
	}
	return retval;
}

/*
 * int cb_reset(struct pccbb_softc *sc)
 *   This function resets CardBus card.
 */
int
cb_reset(struct pccbb_softc *sc)
{
	/*
	 * Reset Assert at least 20 ms
	 * Some machines request longer duration.
	 */
	int reset_duration = (sc->sc_chipset == CB_RX5C47X ? 400 : 50);
	u_int32_t bcr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR);

	/* Reset bit Assert (bit 6 at 0x3E) */
	bcr |= CB_BCR_RESET_ENABLE;
	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);
	delay_ms(reset_duration, sc);

	if (CBB_CARDEXIST & sc->sc_flags) {	/* A card exists.  Reset it! */
		/* Reset bit Deassert (bit 6 at 0x3E) */
		bcr &= ~CB_BCR_RESET_ENABLE;
		pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);
		delay_ms(reset_duration, sc);
	}
	/* No card found on the slot. Keep Reset. */
	return 1;
}

/*
 * int cb_detect_voltage(struct pccbb_softc *sc)
 *  This function detect card Voltage.
 */
int
cb_detect_voltage(struct pccbb_softc *sc)
{
	u_int32_t psr;		       /* socket present-state reg */
	bus_space_tag_t iot = sc->sc_base_memt;
	bus_space_handle_t ioh = sc->sc_base_memh;
	int vol = PCCARD_VCC_UKN;      /* set 0 */

	psr = bus_space_read_4(iot, ioh, CB_SOCKET_STAT);

	if (0x400u & psr) {
		vol |= PCCARD_VCC_5V;
	}
	if (0x800u & psr) {
		vol |= PCCARD_VCC_3V;
	}

	return vol;
}

int
cbbprint(void *aux, const char *pcic)
{
/*
  struct cbslot_attach_args *cba = aux;

  if (cba->cba_slot >= 0) {
    printf(" slot %d", cba->cba_slot);
  }
*/
	return UNCONF;
}

/*
 * int pccbb_cardenable(struct pccbb_softc *sc, int function)
 *   This function enables and disables the card
 */
int
pccbb_cardenable(struct pccbb_softc *sc, int function)
{
	u_int32_t command =
	    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);

	DPRINTF(("pccbb_cardenable:"));
	switch (function) {
	case CARDBUS_IO_ENABLE:
		command |= PCI_COMMAND_IO_ENABLE;
		break;
	case CARDBUS_IO_DISABLE:
		command &= ~PCI_COMMAND_IO_ENABLE;
		break;
	case CARDBUS_MEM_ENABLE:
		command |= PCI_COMMAND_MEM_ENABLE;
		break;
	case CARDBUS_MEM_DISABLE:
		command &= ~PCI_COMMAND_MEM_ENABLE;
		break;
	case CARDBUS_BM_ENABLE:
		command |= PCI_COMMAND_MASTER_ENABLE;
		break;
	case CARDBUS_BM_DISABLE:
		command &= ~PCI_COMMAND_MASTER_ENABLE;
		break;
	default:
		return 0;
	}

	pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, command);
	DPRINTF((" command reg 0x%x\n", command));
	return 1;
}

/*
 * void *pccbb_cb_intr_establish(cardbus_chipset_tag_t ct,
 *					int irq,
 *					int level,
 *					int (* func)(void *),
 *					void *arg,
 *					const char *name)
 *
 *   This function registers an interrupt handler at the bridge, in
 *   order not to call the interrupt handlers of child devices when
 *   a card-deletion interrupt occurs.
 *
 *   The arguments irq is not used because pccbb selects intr vector.
 */
void *
pccbb_cb_intr_establish(cardbus_chipset_tag_t ct, int irq, int level,
    int (*func)(void *), void *arg, const char *name)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;

	return pccbb_intr_establish(sc, irq, level, func, arg, name);
}


/*
 * void *pccbb_cb_intr_disestablish(cardbus_chipset_tag_t ct,
 *					   void *ih)
 *
 *   This function removes an interrupt handler pointed by ih.
 */
void
pccbb_cb_intr_disestablish(cardbus_chipset_tag_t ct, void *ih)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;

	pccbb_intr_disestablish(sc, ih);
}


/*
 * void *pccbb_intr_establish(struct pccbb_softc *sc,
 *				     int irq,
 *				     int level,
 *				     int (* func)(void *),
 *				     void *arg,
 *				     const char *name)
 *
 *   This function registers an interrupt handler at the bridge, in
 *   order not to call the interrupt handlers of child devices when
 *   a card-deletion interrupt occurs.
 *
 *   The arguments irq and level are not used.
 */
void *
pccbb_intr_establish(struct pccbb_softc *sc, int irq, int level,
    int (*func)(void *), void *arg, const char *name)
{
	struct pccbb_intrhand_list *pil, *newpil;
	pcireg_t reg;

	DPRINTF(("pccbb_intr_establish start. %p\n", sc->sc_pil));

	if (sc->sc_pil == NULL) {
		/* initialize bridge intr routing */
		reg = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR);
		reg &= ~CB_BCR_INTR_IREQ_ENABLE;
		pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, reg);

		switch (sc->sc_chipset) {
		case CB_TI113X:
			reg = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CBCTRL);
			/* functional intr enabled */
			reg |= PCI113X_CBCTRL_PCI_INTR;
			pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_CBCTRL, reg);
			break;
		default:
			break;
		}
	}

	/*
	 * Allocate a room for interrupt handler structure.
	 */
	newpil = (struct pccbb_intrhand_list *)
		malloc(sizeof(struct pccbb_intrhand_list), M_DEVBUF, M_WAITOK);

	newpil->pil_func = func;
	newpil->pil_arg = arg;
	newpil->pil_level = level;
	evcount_attach(&newpil->pil_count, name, &sc->sc_intrline);
	newpil->pil_next = NULL;

	if (sc->sc_pil == NULL) {
		sc->sc_pil = newpil;
	} else {
		for (pil = sc->sc_pil; pil->pil_next != NULL;
		    pil = pil->pil_next);
		pil->pil_next = newpil;
	}

	DPRINTF(("pccbb_intr_establish add pil. %p\n", sc->sc_pil));

	return newpil;
}

/*
 * void *pccbb_intr_disestablish(struct pccbb_softc *sc,
 *					void *ih)
 *
 *   This function removes an interrupt handler pointed by ih.
 */
void
pccbb_intr_disestablish(struct pccbb_softc *sc, void *ih)
{
	struct pccbb_intrhand_list *pil, **pil_prev;
	pcireg_t reg;

	DPRINTF(("pccbb_intr_disestablish start. %p\n", sc->sc_pil));

	pil_prev = &sc->sc_pil;

	for (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {
		if (pil == ih) {
			evcount_detach(&pil->pil_count);
			*pil_prev = pil->pil_next;
			free(pil, M_DEVBUF, sizeof *pil);
			DPRINTF(("pccbb_intr_disestablish frees one pil\n"));
			break;
		}
		pil_prev = &pil->pil_next;
	}

	if (sc->sc_pil == NULL) {
		/* No interrupt handlers */

		DPRINTF(("pccbb_intr_disestablish: no interrupt handler\n"));

		/* stop routing PCI intr */
		reg = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR);
		reg |= CB_BCR_INTR_IREQ_ENABLE;
		pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, reg);

		switch (sc->sc_chipset) {
		case CB_TI113X:
			reg = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CBCTRL);
			/* functional intr disabled */
			reg &= ~PCI113X_CBCTRL_PCI_INTR;
			pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_CBCTRL, reg);
			break;
		default:
			break;
		}
	}
}

#if defined SHOW_REGS
void
cb_show_regs(pci_chipset_tag_t pc, pcitag_t tag, bus_space_tag_t memt,
    bus_space_handle_t memh)
{
	int i;
	printf("PCI config regs:");
	for (i = 0; i < 0x50; i += 4) {
		if (i % 16 == 0) {
			printf("\n 0x%02x:", i);
		}
		printf(" %08x", pci_conf_read(pc, tag, i));
	}
	for (i = 0x80; i < 0xb0; i += 4) {
		if (i % 16 == 0) {
			printf("\n 0x%02x:", i);
		}
		printf(" %08x", pci_conf_read(pc, tag, i));
	}

	if (memh == 0) {
		printf("\n");
		return;
	}

	printf("\nsocket regs:");
	for (i = 0; i <= 0x10; i += 0x04) {
		printf(" %08x", bus_space_read_4(memt, memh, i));
	}
	printf("\nExCA regs:");
	for (i = 0; i < 0x08; ++i) {
		printf(" %02x", bus_space_read_1(memt, memh, 0x800 + i));
	}
	printf("\n");
	return;
}
#endif

/*
 * int pccbb_pcmcia_io_alloc(pcmcia_chipset_handle_t pch,
 *                                  bus_addr_t start, bus_size_t size,
 *                                  bus_size_t align,
 *                                  struct pcmcia_io_handle *pcihp
 *
 * This function only allocates I/O region for pccard. This function
 * never maps the allocated region to pccard I/O area.
 *
 * XXX: The interface of this function is not very good, I believe.
 */
int
pccbb_pcmcia_io_alloc(pcmcia_chipset_handle_t pch, bus_addr_t start,
    bus_size_t size, bus_size_t align, struct pcmcia_io_handle *pcihp)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	bus_addr_t ioaddr;
	int flags = 0;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_addr_t mask;
	rbus_tag_t rb;

	if (align == 0) {
		align = size;	       /* XXX: funny??? */
	}

	if (start != 0) {
		/* XXX: assume all card decode lower 10 bits by its hardware */
		mask = 0x3ff;
		/* enforce to use only masked address */
		start &= mask;
	} else {
		/*
		 * calculate mask:
		 *  1. get the most significant bit of size (call it msb).
		 *  2. compare msb with the value of size.
		 *  3. if size is larger, shift msb left once.
		 *  4. obtain mask value to decrement msb.
		 */
		bus_size_t size_tmp = size;
		int shifts = 0;

		while (size_tmp) {
			++shifts;
			size_tmp >>= 1;
		}
		mask = (1 << shifts);
		if (mask < size) {
			mask <<= 1;
		}
		mask--;
	}

	/*
	 * Allocate some arbitrary I/O space.
	 */

	iot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;

	rb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;
	if (rbus_space_alloc(rb, start, size, mask, align, 0, &ioaddr, &ioh)) {
		return 1;
	}

	pcihp->iot = iot;
	pcihp->ioh = ioh;
	pcihp->addr = ioaddr;
	pcihp->size = size;
	pcihp->flags = flags;

	return 0;
}

/*
 * int pccbb_pcmcia_io_free(pcmcia_chipset_handle_t pch,
 *                                 struct pcmcia_io_handle *pcihp)
 *
 * This function only frees I/O region for pccard.
 *
 * XXX: The interface of this function is not very good, I believe.
 */
void
pccbb_pcmcia_io_free(pcmcia_chipset_handle_t pch,
    struct pcmcia_io_handle *pcihp)
{
	bus_space_handle_t ioh = pcihp->ioh;
	bus_size_t size = pcihp->size;

	struct pccbb_softc *sc =
	    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;
	rbus_tag_t rb = sc->sc_rbus_iot;

	rbus_space_free(rb, ioh, size, NULL);
}

/*
 * int pccbb_pcmcia_io_map(pcmcia_chipset_handle_t pch, int width,
 *                                bus_addr_t offset, bus_size_t size,
 *                                struct pcmcia_io_handle *pcihp,
 *                                int *windowp)
 *
 * This function maps the allocated I/O region to pccard. This function
 * never allocates any I/O region for pccard I/O area.  I don't
 * understand why the original authors of pcmciabus separated alloc and
 * map.  I believe the two must be unite.
 *
 * XXX: no wait timing control?
 */
int
pccbb_pcmcia_io_map(pcmcia_chipset_handle_t pch, int width, bus_addr_t offset,
    bus_size_t size, struct pcmcia_io_handle *pcihp, int *windowp)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	bus_addr_t ioaddr = pcihp->addr + offset;
	int i, win;
#if defined CBB_DEBUG
	static char *width_names[] = { "dynamic", "io8", "io16" };
#endif

	/* Sanity check I/O handle. */

	if (((struct pccbb_softc *)ph->ph_parent)->sc_iot != pcihp->iot) {
		panic("pccbb_pcmcia_io_map iot is bogus");
	}

	/* XXX Sanity check offset/size. */

	win = -1;
	for (i = 0; i < PCIC_IO_WINS; i++) {
		if ((ph->ioalloc & (1 << i)) == 0) {
			win = i;
			ph->ioalloc |= (1 << i);
			break;
		}
	}

	if (win == -1) {
		return 1;
	}

	*windowp = win;

	/* XXX this is pretty gross */

	DPRINTF(("pccbb_pcmcia_io_map window %d %s port %lx+%lx\n",
	    win, width_names[width], (u_long) ioaddr, (u_long) size));

	/* XXX wtf is this doing here? */

#if 0
	printf(" port 0x%lx", (u_long) ioaddr);
	if (size > 1) {
		printf("-0x%lx", (u_long) ioaddr + (u_long) size - 1);
	}
#endif

	ph->io[win].addr = ioaddr;
	ph->io[win].size = size;
	ph->io[win].width = width;

	/* actual dirty register-value changing in the function below. */
	pccbb_pcmcia_do_io_map(ph, win);

	return 0;
}

/*
 * void pccbb_pcmcia_do_io_map(struct pcic_handle *h, int win)
 *
 * This function changes register-value to map I/O region for pccard.
 */
void
pccbb_pcmcia_do_io_map(struct pcic_handle *ph, int win)
{
	static u_int8_t pcic_iowidth[3] = {
		PCIC_IOCTL_IO0_IOCS16SRC_CARD,
		PCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |
		    PCIC_IOCTL_IO0_DATASIZE_8BIT,
		PCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |
		    PCIC_IOCTL_IO0_DATASIZE_16BIT,
	};

#define PCIC_SIA_START_LOW 0
#define PCIC_SIA_START_HIGH 1
#define PCIC_SIA_STOP_LOW 2
#define PCIC_SIA_STOP_HIGH 3

	int regbase_win = 0x8 + win * 0x04;
	u_int8_t ioctl, enable;

	DPRINTF(
	    ("pccbb_pcmcia_do_io_map win %d addr 0x%lx size 0x%lx width %d\n",
	    win, (long)ph->io[win].addr, (long)ph->io[win].size,
	    ph->io[win].width * 8));

	Pcic_write(ph, regbase_win + PCIC_SIA_START_LOW,
	    ph->io[win].addr & 0xff);
	Pcic_write(ph, regbase_win + PCIC_SIA_START_HIGH,
	    (ph->io[win].addr >> 8) & 0xff);

	Pcic_write(ph, regbase_win + PCIC_SIA_STOP_LOW,
	    (ph->io[win].addr + ph->io[win].size - 1) & 0xff);
	Pcic_write(ph, regbase_win + PCIC_SIA_STOP_HIGH,
	    ((ph->io[win].addr + ph->io[win].size - 1) >> 8) & 0xff);

	ioctl = Pcic_read(ph, PCIC_IOCTL);
	enable = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);
	switch (win) {
	case 0:
		ioctl &= ~(PCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |
		    PCIC_IOCTL_IO0_IOCS16SRC_MASK |
		    PCIC_IOCTL_IO0_DATASIZE_MASK);
		ioctl |= pcic_iowidth[ph->io[win].width];
		enable |= PCIC_ADDRWIN_ENABLE_IO0;
		break;
	case 1:
		ioctl &= ~(PCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |
		    PCIC_IOCTL_IO1_IOCS16SRC_MASK |
		    PCIC_IOCTL_IO1_DATASIZE_MASK);
		ioctl |= (pcic_iowidth[ph->io[win].width] << 4);
		enable |= PCIC_ADDRWIN_ENABLE_IO1;
		break;
	}
	Pcic_write(ph, PCIC_IOCTL, ioctl);
	Pcic_write(ph, PCIC_ADDRWIN_ENABLE, enable);
#if defined CBB_DEBUG
	{
		u_int8_t start_low =
		    Pcic_read(ph, regbase_win + PCIC_SIA_START_LOW);
		u_int8_t start_high =
		    Pcic_read(ph, regbase_win + PCIC_SIA_START_HIGH);
		u_int8_t stop_low =
		    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_LOW);
		u_int8_t stop_high =
		    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_HIGH);
		printf
		    (" start %02x %02x, stop %02x %02x, ioctl %02x enable %02x\n",
		    start_low, start_high, stop_low, stop_high, ioctl, enable);
	}
#endif
}

/*
 * void pccbb_pcmcia_io_unmap(pcmcia_chipset_handle_t *h, int win)
 *
 * This function unmaps I/O region.  No return value.
 */
void
pccbb_pcmcia_io_unmap(pcmcia_chipset_handle_t pch, int win)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	int reg;

	if (win >= PCIC_IO_WINS || win < 0) {
		panic("pccbb_pcmcia_io_unmap: window out of range");
	}

	reg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);
	switch (win) {
	case 0:
		reg &= ~PCIC_ADDRWIN_ENABLE_IO0;
		break;
	case 1:
		reg &= ~PCIC_ADDRWIN_ENABLE_IO1;
		break;
	}
	Pcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);

	ph->ioalloc &= ~(1 << win);
}

/*
 * void pccbb_pcmcia_wait_ready(struct pcic_handle *ph)
 *
 * This function enables the card.  All information is stored in
 * the first argument, pcmcia_chipset_handle_t.
 */
void
pccbb_pcmcia_wait_ready(struct pcic_handle *ph)
{
	int i;

	DPRINTF(("pccbb_pcmcia_wait_ready: status 0x%02x\n",
	    Pcic_read(ph, PCIC_IF_STATUS)));

	for (i = 0; i < 10000; i++) {
		if (Pcic_read(ph, PCIC_IF_STATUS) & PCIC_IF_STATUS_READY) {
			return;
		}
		delay(500);
#ifdef CBB_DEBUG
		if ((i > 5000) && (i % 100 == 99))
			printf(".");
#endif
	}

#ifdef DIAGNOSTIC
	printf("pcic_wait_ready: ready never happened, status = %02x\n",
	    Pcic_read(ph, PCIC_IF_STATUS));
#endif
}

/*
 * void pccbb_pcmcia_socket_enable(pcmcia_chipset_handle_t pch)
 *
 * This function enables the card.  All information is stored in
 * the first argument, pcmcia_chipset_handle_t.
 */
void
pccbb_pcmcia_socket_enable(pcmcia_chipset_handle_t pch)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	struct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;
	int cardtype, win;
	u_int8_t power, intr;
	pcireg_t spsr;
	int voltage;

	/* this bit is mostly stolen from pcic_attach_card */

	DPRINTF(("pccbb_pcmcia_socket_enable: "));

	/* get card Vcc info */

	spsr =
	    bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,
	    CB_SOCKET_STAT);
	if (spsr & CB_SOCKET_STAT_5VCARD) {
		DPRINTF(("5V card\n"));
		voltage = CARDBUS_VCC_5V | CARDBUS_VPP_VCC;
	} else if (spsr & CB_SOCKET_STAT_3VCARD) {
		DPRINTF(("3V card\n"));
		voltage = CARDBUS_VCC_3V | CARDBUS_VPP_VCC;
	} else {
		DPRINTF(("?V card, 0x%x\n", spsr));	/* XXX */
		return;
	}

	/* disable socket i/o: negate output enable bit */

	power = 0;
	Pcic_write(ph, PCIC_PWRCTL, power);

	/* power down the socket to reset it, clear the card reset pin */

	pccbb_power((cardbus_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);

	/*
	 * wait 200ms until power fails (Tpf).  Then, wait 100ms since
	 * we are changing Vcc (Toff).
	 */
	/* delay(300*1000); too much */

	/* assert reset bit */
	intr = Pcic_read(ph, PCIC_INTR);
	intr &= ~(PCIC_INTR_RESET | PCIC_INTR_CARDTYPE_MASK);
	Pcic_write(ph, PCIC_INTR, intr);

	/* Power up the socket. */
	power = Pcic_read(ph, PCIC_PWRCTL);
	Pcic_write(ph, PCIC_PWRCTL, (power & ~PCIC_PWRCTL_OE));
	pccbb_power((cardbus_chipset_tag_t)sc, voltage);

	/* Now output enable */
	power = Pcic_read(ph, PCIC_PWRCTL);
	Pcic_write(ph, PCIC_PWRCTL, power | PCIC_PWRCTL_OE);

	/*
	 * hold RESET at least 10us.
	 */
	delay(10);
	delay(2 * 1000);	       /* XXX: TI1130 requires it. */
	delay(20 * 1000);	       /* XXX: TI1130 requires it. */

	/* clear the reset flag */

	intr |= PCIC_INTR_RESET;
	Pcic_write(ph, PCIC_INTR, intr);

	/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */

	delay(20000);

	/* wait for the chip to finish initializing */

	pccbb_pcmcia_wait_ready(ph);

	/* zero out the address windows */

	Pcic_write(ph, PCIC_ADDRWIN_ENABLE, 0);

	/* set the card type */

	cardtype = pcmcia_card_gettype(ph->pcmcia);

	intr |= ((cardtype == PCMCIA_IFTYPE_IO) ?
	    PCIC_INTR_CARDTYPE_IO : PCIC_INTR_CARDTYPE_MEM);
	Pcic_write(ph, PCIC_INTR, intr);

	DPRINTF(("%s: pccbb_pcmcia_socket_enable %02x cardtype %s %02x\n",
	    ph->ph_parent->dv_xname, ph->sock,
	    ((cardtype == PCMCIA_IFTYPE_IO) ? "io" : "mem"), intr));

	/* reinstall all the memory and io mappings */

	for (win = 0; win < PCIC_MEM_WINS; ++win) {
		if (ph->memalloc & (1 << win)) {
			pccbb_pcmcia_do_mem_map(ph, win);
		}
	}

	for (win = 0; win < PCIC_IO_WINS; ++win) {
		if (ph->ioalloc & (1 << win)) {
			pccbb_pcmcia_do_io_map(ph, win);
		}
	}
}

/*
 * void pccbb_pcmcia_socket_disable(pcmcia_chipset_handle_t *ph)
 *
 * This function disables the card.  All information is stored in
 * the first argument, pcmcia_chipset_handle_t.
 */
void
pccbb_pcmcia_socket_disable(pcmcia_chipset_handle_t pch)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	struct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;
	u_int8_t power, intr;

	DPRINTF(("pccbb_pcmcia_socket_disable\n"));

	/* reset signal asserting... */

	intr = Pcic_read(ph, PCIC_INTR);
	intr &= ~(PCIC_INTR_CARDTYPE_MASK);
	Pcic_write(ph, PCIC_INTR, intr);
	delay(2 * 1000);

	/* power down the socket */
	power = Pcic_read(ph, PCIC_PWRCTL);
	power &= ~PCIC_PWRCTL_OE;
	Pcic_write(ph, PCIC_PWRCTL, power);
	pccbb_power((cardbus_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
	/*
	 * wait 300ms until power fails (Tpf).
	 */
	delay(300 * 1000);
}

/*
 * int pccbb_pcmcia_card_detect(pcmcia_chipset_handle_t *ph)
 *
 * This function detects whether a card is in the slot or not.
 * If a card is inserted, return 1.  Otherwise, return 0.
 */
int
pccbb_pcmcia_card_detect(pcmcia_chipset_handle_t pch)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	struct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;

	DPRINTF(("pccbb_pcmcia_card_detect\n"));
	return pccbb_detect_card(sc) == 1 ? 1 : 0;
}

/*
 * int pccbb_pcmcia_mem_alloc(pcmcia_chipset_handle_t pch,
 *                                   bus_size_t size,
 *                                   struct pcmcia_mem_handle *pcmhp)
 *
 * This function only allocates memory region for pccard. This
 * function never maps the allocated region to pccard memory area.
 *
 * XXX: Why the argument of start address is not in?
 */
int
pccbb_pcmcia_mem_alloc(pcmcia_chipset_handle_t pch, bus_size_t size,
    struct pcmcia_mem_handle *pcmhp)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	bus_space_handle_t memh;
	bus_addr_t addr;
	bus_size_t sizepg;
	struct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;
	rbus_tag_t rb;

	/* out of sc->memh, allocate as many pages as necessary */

	/* convert size to PCIC pages */
	/*
	 * This is not enough; when the requested region is on the page
	 * boundaries, this may calculate wrong result.
	 */
	sizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;
#if 0
	if (sizepg > PCIC_MAX_MEM_PAGES) {
		return 1;
	}
#endif

	if (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {
		return 1;
	}

	addr = 0;		       /* XXX gcc -Wuninitialized */

	rb = sc->sc_rbus_memt;
	if (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,
	    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,
	    &addr, &memh)) {
		return 1;
	}

	DPRINTF(
	    ("pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\n",
	    addr, size, sizepg * PCIC_MEM_PAGESIZE));

	pcmhp->memt = sc->sc_memt;
	pcmhp->memh = memh;
	pcmhp->addr = addr;
	pcmhp->size = size;
	pcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;
	/* What is mhandle?  I feel it is very dirty and it must go trush. */
	pcmhp->mhandle = 0;
	/* No offset???  Funny. */

	return 0;
}

/*
 * void pccbb_pcmcia_mem_free(pcmcia_chipset_handle_t pch,
 *                                   struct pcmcia_mem_handle *pcmhp)
 *
 * This function release the memory space allocated by the function
 * pccbb_pcmcia_mem_alloc().
 */
void
pccbb_pcmcia_mem_free(pcmcia_chipset_handle_t pch,
    struct pcmcia_mem_handle *pcmhp)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	struct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;

	rbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);
}

/*
 * void pccbb_pcmcia_do_mem_map(struct pcic_handle *ph, int win)
 *
 * This function release the memory space allocated by the function
 * pccbb_pcmcia_mem_alloc().
 */
void
pccbb_pcmcia_do_mem_map(struct pcic_handle *ph, int win)
{
	int regbase_win;
	bus_addr_t phys_addr;
	bus_addr_t phys_end;

#define PCIC_SMM_START_LOW 0
#define PCIC_SMM_START_HIGH 1
#define PCIC_SMM_STOP_LOW 2
#define PCIC_SMM_STOP_HIGH 3
#define PCIC_CMA_LOW 4
#define PCIC_CMA_HIGH 5

	u_int8_t start_low, start_high = 0;
	u_int8_t stop_low, stop_high;
	u_int8_t off_low, off_high;
	u_int8_t mem_window;
	int reg;

	regbase_win = 0x10 + win * 0x08;

	phys_addr = ph->mem[win].addr;
	phys_end = phys_addr + ph->mem[win].size;

	DPRINTF(("pccbb_pcmcia_do_mem_map: start 0x%lx end 0x%lx off 0x%lx\n",
	    phys_addr, phys_end, ph->mem[win].offset));

#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT
#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)
#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)

	/* bit 19:12 */
	start_low = (phys_addr >> PCIC_MEMREG_LSB_SHIFT) & 0xff;
	/* bit 23:20 and bit 7 on */
	start_high = ((phys_addr >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)
	    | PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT; /* bit 7 on */
	/* bit 31:24, for 32-bit address */
	mem_window = (phys_addr >> PCIC_MEMREG_WIN_SHIFT) & 0xff;

	Pcic_write(ph, regbase_win + PCIC_SMM_START_LOW, start_low);
	Pcic_write(ph, regbase_win + PCIC_SMM_START_HIGH, start_high);

	if (((struct pccbb_softc *)ph->
	    ph_parent)->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {
		Pcic_write(ph, 0x40 + win, mem_window);
	}

	stop_low = (phys_end >> PCIC_MEMREG_LSB_SHIFT) & 0xff;
	stop_high = ((phys_end >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)
	    | PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2;	/* wait 2 cycles */
	/* XXX Geee, WAIT2!! Crazy!!  I must rewrite this routine. */

	Pcic_write(ph, regbase_win + PCIC_SMM_STOP_LOW, stop_low);
	Pcic_write(ph, regbase_win + PCIC_SMM_STOP_HIGH, stop_high);

	off_low = (ph->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff;
	off_high = ((ph->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8))
	    & PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK)
	    | ((ph->mem[win].kind == PCMCIA_MEM_ATTR) ?
	    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0);

	Pcic_write(ph, regbase_win + PCIC_CMA_LOW, off_low);
	Pcic_write(ph, regbase_win + PCIC_CMA_HIGH, off_high);

	reg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);
	reg |= ((1 << win) | PCIC_ADDRWIN_ENABLE_MEMCS16);
	Pcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);

#if defined CBB_DEBUG
	{
		int r1, r2, r3, r4, r5, r6, r7 = 0;

		r1 = Pcic_read(ph, regbase_win + PCIC_SMM_START_LOW);
		r2 = Pcic_read(ph, regbase_win + PCIC_SMM_START_HIGH);
		r3 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_LOW);
		r4 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_HIGH);
		r5 = Pcic_read(ph, regbase_win + PCIC_CMA_LOW);
		r6 = Pcic_read(ph, regbase_win + PCIC_CMA_HIGH);
		if (((struct pccbb_softc *)(ph->
		    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {
			r7 = Pcic_read(ph, 0x40 + win);
		}

		DPRINTF(("pccbb_pcmcia_do_mem_map window %d: %02x%02x %02x%02x "
		    "%02x%02x", win, r1, r2, r3, r4, r5, r6));
		if (((struct pccbb_softc *)(ph->
		    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {
			DPRINTF((" %02x", r7));
		}
		DPRINTF(("\n"));
	}
#endif
}

/*
 * int pccbb_pcmcia_mem_map(pcmcia_chipset_handle_t pch, int kind,
 *                                 bus_addr_t card_addr, bus_size_t size,
 *                                 struct pcmcia_mem_handle *pcmhp,
 *                                 bus_size_t *offsetp, int *windowp)
 *
 * This function maps memory space allocated by the function
 * pccbb_pcmcia_mem_alloc().
 */
int
pccbb_pcmcia_mem_map(pcmcia_chipset_handle_t pch, int kind,
    bus_addr_t card_addr, bus_size_t size, struct pcmcia_mem_handle *pcmhp,
    bus_size_t *offsetp, int *windowp)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	bus_addr_t busaddr;
	long card_offset;
	int win;

	for (win = 0; win < PCIC_MEM_WINS; ++win) {
		if ((ph->memalloc & (1 << win)) == 0) {
			ph->memalloc |= (1 << win);
			break;
		}
	}

	if (win == PCIC_MEM_WINS) {
		return 1;
	}

	*windowp = win;

	/* XXX this is pretty gross */

	if (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {
		panic("pccbb_pcmcia_mem_map memt is bogus");
	}

	busaddr = pcmhp->addr;

	/*
	 * compute the address offset to the pcmcia address space for the
	 * pcic.  this is intentionally signed.  The masks and shifts below
	 * will cause TRT to happen in the pcic registers.  Deal with making
	 * sure the address is aligned, and return the alignment offset.
	 */

	*offsetp = card_addr % PCIC_MEM_PAGESIZE;
	card_addr -= *offsetp;

	DPRINTF(("pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr "
	    "%lx\n", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,
	    (u_long) card_addr));

	/*
	 * include the offset in the size, and decrement size by one, since
	 * the hw wants start/stop
	 */
	size += *offsetp - 1;

	card_offset = (((long)card_addr) - ((long)busaddr));

	ph->mem[win].addr = busaddr;
	ph->mem[win].size = size;
	ph->mem[win].offset = card_offset;
	ph->mem[win].kind = kind;

	pccbb_pcmcia_do_mem_map(ph, win);

	return 0;
}

/*
 * int pccbb_pcmcia_mem_unmap(pcmcia_chipset_handle_t pch,
 *                                   int window)
 *
 * This function unmaps memory space which mapped by the function
 * pccbb_pcmcia_mem_map().
 */
void
pccbb_pcmcia_mem_unmap(pcmcia_chipset_handle_t pch, int window)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	int reg;

	if (window >= PCIC_MEM_WINS) {
		panic("pccbb_pcmcia_mem_unmap: window out of range");
	}

	reg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);
	reg &= ~(1 << window);
	Pcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);

	ph->memalloc &= ~(1 << window);
}

#if defined PCCBB_PCMCIA_POLL
struct pccbb_poll_str {
	void *arg;
	int (*func)(void *);
	int level;
	struct pcic_handle *ph;
	int count;
	int num;
};

static struct pccbb_poll_str pccbb_poll[10];
static int pccbb_poll_n = 0;
static struct timeout pccbb_poll_timeout;

void pccbb_pcmcia_poll(void *arg);

void
pccbb_pcmcia_poll(void *arg)
{
	struct pccbb_poll_str *poll = arg;
	struct pcic_handle *ph = poll->ph;
	struct pccbb_softc *sc = ph->sc;
	int s;
	u_int32_t spsr;		       /* socket present-state reg */

	timeout_set(&pccbb_poll_timeout, pccbb_pcmcia_poll, arg);
	timeout_add_sec(&pccbb_poll_timeout, 2);
	switch (poll->level) {
	case IPL_NET:
		s = splnet();
		break;
	case IPL_BIO:
		s = splbio();
		break;
	case IPL_TTY:		       /* fallthrough */
	default:
		s = spltty();
		break;
	}

	spsr =
	    bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,
	    CB_SOCKET_STAT);

#if defined PCCBB_PCMCIA_POLL_ONLY && defined LEVEL2
	if (!(spsr & 0x40))	       /* CINT low */
#else
	if (1)
#endif
	{
		if ((*poll->func) (poll->arg) > 0) {
			++poll->count;
	/* printf("intr: reported from poller, 0x%x\n", spsr); */
#if defined LEVEL2
		} else {
			printf("intr: miss! 0x%x\n", spsr);
#endif
		}
	}
	splx(s);
}
#endif /* defined CB_PCMCIA_POLL */

/*
 * void *pccbb_pcmcia_intr_establish(pcmcia_chipset_handle_t pch,
 *                                          struct pcmcia_function *pf,
 *                                          int ipl,
 *                                          int (*func)(void *),
 *                                          void *arg);
 *
 * This function enables PC-Card interrupt.  PCCBB uses PCI interrupt line.
 */
void *
pccbb_pcmcia_intr_establish(pcmcia_chipset_handle_t pch,
    struct pcmcia_function *pf, int ipl, int (*func)(void *), void *arg,
    char *xname)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	struct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;

	if (!(pf->cfe->flags & PCMCIA_CFE_IRQLEVEL)) {
		/* what should I do? */
		if ((pf->cfe->flags & PCMCIA_CFE_IRQLEVEL)) {
			DPRINTF(
			    ("%s does not provide edge nor pulse interrupt\n",
			    sc->sc_dev.dv_xname));
			return NULL;
		}
		/*
		 * XXX Noooooo!  The interrupt flag must set properly!!
		 * dumb pcmcia driver!!
		 */
	}

	return pccbb_intr_establish(sc, -1, ipl, func, arg, xname);
}

/*
 * void pccbb_pcmcia_intr_disestablish(pcmcia_chipset_handle_t pch,
 *                                            void *ih)
 *
 * This function disables PC-Card interrupt.
 */
void
pccbb_pcmcia_intr_disestablish(pcmcia_chipset_handle_t pch, void *ih)
{
	struct pcic_handle *ph = (struct pcic_handle *)pch;
	struct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;

	pccbb_intr_disestablish(sc, ih);
}

const char *
pccbb_pcmcia_intr_string(pcmcia_chipset_handle_t pch, void *ih)
{
	if (ih == NULL)
		return "couldn't establish interrupt";
	else
		return "";	/* card shares interrupt of the bridge */
}

/*
 * int
 * pccbb_rbus_cb_space_alloc(cardbus_chipset_tag_t ct, rbus_tag_t rb,
 *			    bus_addr_t addr, bus_size_t size,
 *			    bus_addr_t mask, bus_size_t align,
 *			    int flags, bus_addr_t *addrp;
 *			    bus_space_handle_t *bshp)
 *
 *   This function allocates a portion of memory or io space for
 *   clients.  This function is called from CardBus card drivers.
 */
int
pccbb_rbus_cb_space_alloc(cardbus_chipset_tag_t ct, rbus_tag_t rb,
    bus_addr_t addr, bus_size_t size, bus_addr_t mask, bus_size_t align,
    int flags, bus_addr_t *addrp, bus_space_handle_t *bshp)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;

	DPRINTF(
	    ("pccbb_rbus_cb_space_alloc: adr %lx, size %lx, mask %lx, align %lx\n",
	    addr, size, mask, align));

	align = max(align, 4);
	mask = max(mask, (4 - 1));
	if (rb->rb_bt == sc->sc_memt) {
		align = max(align, 0x1000);
		mask = max(mask, (0x1000 - 1));
	}

	if (rb->rb_bt == sc->sc_iot) {
		/* XXX: hack for avoiding ISA image */
		if (mask < 0x0100) {
			mask = 0x3ff;
			addr = 0x300;
		}
	}

	if (rbus_space_alloc(rb, addr, size, mask, align, flags, addrp, bshp)) {
		printf("%s: <rbus> no bus space\n", sc->sc_dev.dv_xname);
		return 1;
	}

	pccbb_open_win(sc, rb->rb_bt, *addrp, size, *bshp, 0);

	return 0;
}

/*
 * int
 * pccbb_rbus_cb_space_free(cardbus_chipset_tag_t *ct, rbus_tag_t rb,
 *			   bus_space_handle_t *bshp, bus_size_t size);
 *
 *   This function is called from CardBus card drivers.
 */
int
pccbb_rbus_cb_space_free(cardbus_chipset_tag_t ct, rbus_tag_t rb,
    bus_space_handle_t bsh, bus_size_t size)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;
	bus_space_tag_t bt = rb->rb_bt;

	pccbb_close_win(sc, bt, bsh, size);

	if (bt == sc->sc_memt) {
	} else if (bt == sc->sc_iot) {
	} else {
		return 1;
		/* XXX: panic here? */
	}

	return rbus_space_free(rb, bsh, size, NULL);
}

int
pccbb_open_win(struct pccbb_softc *sc, bus_space_tag_t bst, bus_addr_t addr,
    bus_size_t size, bus_space_handle_t bsh, int flags)
{
	struct pccbb_win_chain_head *head;
	bus_addr_t align;

	head = &sc->sc_iowindow;
	align = 0x04;
	if (sc->sc_memt == bst) {
		head = &sc->sc_memwindow;
		align = 0x1000;
		DPRINTF(("using memory window, %x %x %x\n\n",
		    sc->sc_iot, sc->sc_memt, bst));
	}

	if (pccbb_winlist_insert(head, addr, size, bsh, flags)) {
		printf("%s: pccbb_open_win: %s winlist insert failed\n",
		    sc->sc_dev.dv_xname,
		    (head == &sc->sc_memwindow) ? "mem" : "io");
	}
	pccbb_winset(align, sc, bst);

	return 0;
}

int
pccbb_close_win(struct pccbb_softc *sc, bus_space_tag_t bst,
    bus_space_handle_t bsh, bus_size_t size)
{
	struct pccbb_win_chain_head *head;
	bus_addr_t align;

	head = &sc->sc_iowindow;
	align = 0x04;
	if (sc->sc_memt == bst) {
		head = &sc->sc_memwindow;
		align = 0x1000;
	}

	if (pccbb_winlist_delete(head, bsh, size)) {
		printf("%s: pccbb_close_win: %s winlist delete failed\n",
		    sc->sc_dev.dv_xname,
		    (head == &sc->sc_memwindow) ? "mem" : "io");
	}
	pccbb_winset(align, sc, bst);

	return 0;
}

int
pccbb_winlist_insert(struct pccbb_win_chain_head *head, bus_addr_t start,
    bus_size_t size, bus_space_handle_t bsh, int flags)
{
	struct pccbb_win_chain *chainp, *elem;

	if ((elem = malloc(sizeof(struct pccbb_win_chain), M_DEVBUF,
	    M_NOWAIT)) == NULL)
		return (1);		/* fail */

	elem->wc_start = start;
	elem->wc_end = start + (size - 1);
	elem->wc_handle = bsh;
	elem->wc_flags = flags;

	for (chainp = TAILQ_FIRST(head); chainp != NULL;
	    chainp = TAILQ_NEXT(chainp, wc_list)) {
		if (chainp->wc_end < start)
			continue;
		TAILQ_INSERT_AFTER(head, chainp, elem, wc_list);
		return (0);
	}

	TAILQ_INSERT_TAIL(head, elem, wc_list);
	return (0);
}

int
pccbb_winlist_delete(struct pccbb_win_chain_head *head, bus_space_handle_t bsh,
    bus_size_t size)
{
	struct pccbb_win_chain *chainp;

	for (chainp = TAILQ_FIRST(head); chainp != NULL;
	     chainp = TAILQ_NEXT(chainp, wc_list)) {
		if (memcmp(&chainp->wc_handle, &bsh, sizeof(bsh)))
			continue;
		if ((chainp->wc_end - chainp->wc_start) != (size - 1)) {
			printf("pccbb_winlist_delete: window 0x%lx size "
			    "inconsistent: 0x%lx, 0x%lx\n",
			    chainp->wc_start,
			    chainp->wc_end - chainp->wc_start,
			    size - 1);
			return 1;
		}

		TAILQ_REMOVE(head, chainp, wc_list);
		free(chainp, M_DEVBUF, sizeof *chainp);

		return 0;
	}

	return 1;	       /* fail: no candidate to remove */
}

void
pccbb_winset(bus_addr_t align, struct pccbb_softc *sc, bus_space_tag_t bst)
{
	pci_chipset_tag_t pc;
	pcitag_t tag;
	bus_addr_t mask = ~(align - 1);
	struct {
		pcireg_t win_start;
		pcireg_t win_limit;
		int win_flags;
	} win[2];
	struct pccbb_win_chain *chainp;
	int offs;

	win[0].win_start = win[1].win_start = 0xffffffff;
	win[0].win_limit = win[1].win_limit = 0;
	win[0].win_flags = win[1].win_flags = 0;

	chainp = TAILQ_FIRST(&sc->sc_iowindow);
	offs = PCI_CB_IOBASE0;
	if (sc->sc_memt == bst) {
		chainp = TAILQ_FIRST(&sc->sc_memwindow);
		offs = PCI_CB_MEMBASE0;
	}

	if (chainp != NULL) {
		win[0].win_start = chainp->wc_start & mask;
		win[0].win_limit = chainp->wc_end & mask;
		win[0].win_flags = chainp->wc_flags;
		chainp = TAILQ_NEXT(chainp, wc_list);
	}

	for (; chainp != NULL; chainp = TAILQ_NEXT(chainp, wc_list)) {
		if (win[1].win_start == 0xffffffff) {
			/* window 1 is not used */
			if ((win[0].win_flags == chainp->wc_flags) &&
			    (win[0].win_limit + align >=
			    (chainp->wc_start & mask))) {
				/* concatenate */
				win[0].win_limit = chainp->wc_end & mask;
			} else {
				/* make new window */
				win[1].win_start = chainp->wc_start & mask;
				win[1].win_limit = chainp->wc_end & mask;
				win[1].win_flags = chainp->wc_flags;
			}
			continue;
		}

		/* Both windows are engaged. */
		if (win[0].win_flags == win[1].win_flags) {
			/* same flags */
			if (win[0].win_flags == chainp->wc_flags) {
				if (win[1].win_start - (win[0].win_limit +
				    align) <
				    (chainp->wc_start & mask) -
				    ((chainp->wc_end & mask) + align)) {
					/*
					 * merge window 0 and 1, and set win1
					 * to chainp
					 */
					win[0].win_limit = win[1].win_limit;
					win[1].win_start =
					    chainp->wc_start & mask;
					win[1].win_limit =
					    chainp->wc_end & mask;
				} else {
					win[1].win_limit =
					    chainp->wc_end & mask;
				}
			} else {
				/* different flags */

				/* concatenate win0 and win1 */
				win[0].win_limit = win[1].win_limit;
				/* allocate win[1] to new space */
				win[1].win_start = chainp->wc_start & mask;
				win[1].win_limit = chainp->wc_end & mask;
				win[1].win_flags = chainp->wc_flags;
			}
		} else {
			/* the flags of win[0] and win[1] are different */
			if (win[0].win_flags == chainp->wc_flags) {
				win[0].win_limit = chainp->wc_end & mask;
				/*
				 * XXX this creates overlapping windows, so
				 * what should the poor bridge do if one is
				 * cachable, and the other is not?
				 */
				printf("%s: overlapping windows\n",
				    sc->sc_dev.dv_xname);
			} else {
				win[1].win_limit = chainp->wc_end & mask;
			}
		}
	}

	pc = sc->sc_pc;
	tag = sc->sc_tag;
	pci_conf_write(pc, tag, offs, win[0].win_start);
	pci_conf_write(pc, tag, offs + 4, win[0].win_limit);
	pci_conf_write(pc, tag, offs + 8, win[1].win_start);
	pci_conf_write(pc, tag, offs + 12, win[1].win_limit);
	DPRINTF(("--pccbb_winset: win0 [%x, %lx), win1 [%x, %lx)\n",
	    pci_conf_read(pc, tag, offs),
	    pci_conf_read(pc, tag, offs + 4) + align,
	    pci_conf_read(pc, tag, offs + 8),
	    pci_conf_read(pc, tag, offs + 12) + align));

	if (bst == sc->sc_memt) {
		pcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);

		bcr &= ~(CB_BCR_PREFETCH_MEMWIN0 | CB_BCR_PREFETCH_MEMWIN1);
		if (win[0].win_flags & PCCBB_MEM_CACHABLE)
			bcr |= CB_BCR_PREFETCH_MEMWIN0;
		if (win[1].win_flags & PCCBB_MEM_CACHABLE)
			bcr |= CB_BCR_PREFETCH_MEMWIN1;
		pci_conf_write(pc, tag, PCI_BCR_INTR, bcr);
	}
}

int
pccbbactivate(struct device *self, int act)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)self;
	pci_chipset_tag_t pc = sc->sc_pc;
	pcitag_t tag = sc->sc_tag;
	pcireg_t csr;
	u_int32_t reg;
	bus_space_tag_t base_memt = sc->sc_base_memt;	/* socket regs memory */
	bus_space_handle_t base_memh = sc->sc_base_memh;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);

		sc->sc_pil_intr_enable = 0;

		/* Save registers that may get lost. */
		sc->sc_csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		sc->sc_bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		sc->sc_int = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);

		sc->sc_sockbase = pci_conf_read(pc, tag, PCI_SOCKBASE);
		sc->sc_busnum = pci_conf_read(pc, tag, PCI_BUSNUM);

		sc->sc_membase[0] = pci_conf_read(pc, tag, PCI_CB_MEMBASE0);
		sc->sc_memlimit[0] = pci_conf_read(pc, tag, PCI_CB_MEMLIMIT0);
		sc->sc_membase[1] = pci_conf_read(pc, tag, PCI_CB_MEMBASE1);
		sc->sc_memlimit[1] = pci_conf_read(pc, tag, PCI_CB_MEMLIMIT1);
		sc->sc_iobase[0] = pci_conf_read(pc, tag, PCI_CB_IOBASE0);
		sc->sc_iolimit[0] = pci_conf_read(pc, tag, PCI_CB_IOLIMIT0);
		sc->sc_iobase[1] = pci_conf_read(pc, tag, PCI_CB_IOBASE1);
		sc->sc_iolimit[1] = pci_conf_read(pc, tag, PCI_CB_IOLIMIT1);
		break;
	case DVACT_RESUME:
		/* Restore the registers saved above. */
		pci_conf_write(pc, tag, PCI_BHLC_REG, sc->sc_bhlcr);
		pci_conf_write(pc, tag, PCI_INTERRUPT_REG, sc->sc_int);

		pci_conf_write(pc, tag, PCI_SOCKBASE, sc->sc_sockbase);
		pci_conf_write(pc, tag, PCI_BUSNUM, sc->sc_busnum);

		pci_conf_write(pc, tag, PCI_CB_MEMBASE0, sc->sc_membase[0]);
		pci_conf_write(pc, tag, PCI_CB_MEMLIMIT0, sc->sc_memlimit[0]);
		pci_conf_write(pc, tag, PCI_CB_MEMBASE1, sc->sc_membase[1]);
		pci_conf_write(pc, tag, PCI_CB_MEMLIMIT1, sc->sc_memlimit[1]);
		pci_conf_write(pc, tag, PCI_CB_IOBASE0, sc->sc_iobase[0]);
		pci_conf_write(pc, tag, PCI_CB_IOLIMIT0, sc->sc_iolimit[0]);
		pci_conf_write(pc, tag, PCI_CB_IOBASE1, sc->sc_iobase[1]);
		pci_conf_write(pc, tag, PCI_CB_IOLIMIT1, sc->sc_iolimit[1]);

		/* Disable legacy register mapping. */
		pccbb_legacy_disable(sc);

		/*
		 * Restore command register last to avoid exposing
		 * uninitialised windows.
		 */
		csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
		    (csr & 0xffff0000) | (sc->sc_csr & 0x0000ffff));

		/* CSC Interrupt: Card detect interrupt on */
		reg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);
		/* Card detect intr is turned on. */
		reg |= CB_SOCKET_MASK_CD;
		bus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, reg);

		/* reset interrupt */
		reg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT);
		bus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT, reg);

		/* re-check all cards */
		pccbb_checksockstat(sc);

		/*
		 * XXX Because the cardslot stuff is so obfuscated with threads,
		 * here we are activating children which may have been
		 * ejected while we were asleep.  This needs to be solved.
		 */
		rv = config_activate_children(self, act);

		sc->sc_pil_intr_enable = 1;
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		pccbb_shutdown(self);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}
@


1.95
log
@Try to assign a secondary bus number if the BIOS left the CardBus bridge
unconfigured.

ok miod@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.94 2015/07/19 05:37:38 bcook Exp $	*/
d1579 1
a1579 1
			free(pil, M_DEVBUF, 0);
d2684 1
a2684 1
		free(chainp, M_DEVBUF, 0);
@


1.94
log
@simplify a triple-deep ternary operation.

ok beck@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.93 2015/03/14 03:38:48 jsg Exp $	*/
d375 1
d451 13
a463 2
	 * When bus number isn't set correctly, give up using 32-bit CardBus
	 * mode.
@


1.93
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.92 2014/07/12 18:48:52 tedu Exp $	*/
d996 2
a997 2
		retval = retval == 1 ? 1 :
		    retval == 0 ? val : val != 0 ? val : retval;
@


1.92
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.91 2013/12/06 21:03:04 deraadt Exp $	*/
a44 1
#include <sys/errno.h>
@


1.91
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.90 2013/10/30 08:47:20 mpi Exp $	*/
d1568 1
a1568 1
			free(pil, M_DEVBUF);
d2673 1
a2673 1
		free(chainp, M_DEVBUF);
@


1.90
log
@Replace workqs with tasks.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.89 2012/10/18 21:40:49 deraadt Exp $	*/
a2814 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
a2836 4
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		pccbb_shutdown(self);
		break;
d2886 7
@


1.89
log
@Use pci_set_powerstate() unconditionally for all chip variants, rather
than a kludged together chunk of code for just one chip, which happens
to be entirely wrong.  We need to watch for regressions on cardbus, though.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.88 2012/10/08 21:47:50 deraadt Exp $	*/
d51 1
@


1.88
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.87 2010/12/08 20:22:49 miod Exp $	*/
d609 3
a735 6

		/* Power on the controller if the BIOS didn't */
		reg = pci_conf_read(pc, tag, TOPIC100_PMCSR);
		if ((reg & TOPIC100_PMCSR_MASK) != TOPIC100_PMCSR_D0)
			pci_conf_write(pc, tag, TOPIC100_PMCSR,
			    (reg & ~TOPIC100_PMCSR_MASK) | TOPIC100_PMCSR_D0);
@


1.87
log
@Fix compilation with option CBB_DEBUG; noticed by Dave Anderson on misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.86 2010/09/20 06:33:48 matthew Exp $	*/
a459 2
	shutdownhook_establish(pccbb_shutdown, sc);

d2841 4
@


1.86
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.85 2010/09/08 17:56:16 deraadt Exp $	*/
d881 2
a882 3
			DPRINTF(("%s: 0x%08x", sc->sc_dev.dv_xname,
			    sockevent));
			DPRINTF((" card removed, 0x%08x\n", sockstate));
@


1.85
log
@Document that the resume case is waking children which may have been
ejected, and that this needs to be solved.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.84 2010/09/08 17:54:37 deraadt Exp $	*/
d1537 1
a1537 2
	evcount_attach(&newpil->pil_count, name, &sc->sc_intrline,
	    &evcount_intr);
@


1.84
log
@Split out the guts of pccbbintr() so that we can call it carefully at
resume time.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.82 2010/09/07 16:21:45 deraadt Exp $	*/
d2887 5
@


1.83
log
@During suspend, do not call children's interrupt handlers after we have
told them to suspend.  In some drivers, this "wakes" them up.
ok kettenis
@
text
@d92 1
d870 44
d924 1
a924 3
	u_int32_t sockevent, sockstate;
	bus_space_tag_t memt = sc->sc_base_memt;
	bus_space_handle_t memh = sc->sc_base_memh;
d930 4
a933 2
	sockevent = bus_space_read_4(memt, memh, CB_SOCKET_EVENT);
	bus_space_write_4(memt, memh, CB_SOCKET_EVENT, sockevent);
a935 9
	if (sockevent == 0) {
		/* This intr is not for me: it may be for my child devices. */
		if (sc->sc_pil_intr_enable) {
			return pccbbintr_function(sc);
		} else {
			return 0;
		}
	}

d937 2
a938 39
		sockstate = bus_space_read_4(memt, memh, CB_SOCKET_STAT);
		if ((sockstate & CB_SOCKET_STAT_CD) != 0) {
			/* A card should be removed. */
			if (sc->sc_flags & CBB_CARDEXIST) {
				DPRINTF(("%s: 0x%08x", sc->sc_dev.dv_xname,
				    sockevent));
				DPRINTF((" card removed, 0x%08x\n", sockstate));
				sc->sc_flags &= ~CBB_CARDEXIST;
				if (sc->sc_csc->sc_status &
				    CARDSLOT_STATUS_CARD_16) {
#if 0
					struct pcic_handle *ph =
					    &sc->sc_pcmcia_h;

					pcmcia_card_deactivate(ph->pcmcia);
					pccbb_pcmcia_socket_disable(ph);
					pccbb_pcmcia_detach_card(ph,
					    DETACH_FORCE);
#endif
					cardslot_event_throw(sc->sc_csc,
					    CARDSLOT_EVENT_REMOVAL_16);
				} else if (sc->sc_csc->sc_status &
				    CARDSLOT_STATUS_CARD_CB) {
					/* Cardbus intr removed */
					cardslot_event_throw(sc->sc_csc,
					    CARDSLOT_EVENT_REMOVAL_CB);
				}
			}
		} else if ((sockstate & CB_SOCKET_STAT_CD) == 0 &&
		    /*
		     * The pccbbintr may called from powerdown hook when
		     * the system resumed, to detect the card
		     * insertion/removal during suspension.
		     */
		    (sc->sc_flags & CBB_CARDEXIST) == 0) {
			timeout_add_msec(&sc->sc_ins_tmo, 100);
			sc->sc_flags |= CBB_INSERTING;
		}
		return (1);
d941 2
a2826 2
		DPRINTF(("%s: power: why %d stopping intr\n",
		    sc->sc_dev.dv_xname, why));
d2884 2
a2885 6
		/*
		 * check for card insertion or removal during suspend period.
		 * XXX: the code can't cope with card swap (remove then
		 * insert).  how can we detect such situation?
		 */
		(void)pccbbintr(sc);
a2889 2
		DPRINTF(("%s: power: RESUME enabling intr\n",
		    sc->sc_dev.dv_xname));
@


1.82
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.81 2010/09/06 18:34:34 kettenis Exp $	*/
a2827 3
		if (sc->sc_pil_intr_enable) {
			(void)pccbbintr_function(sc);
		}
@


1.81
log
@Save and restore pci config space registers common to all PCI-CardBus
bridges when we do suspend and resume.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.80 2010/09/03 21:45:11 kettenis Exp $	*/
a150 1
void	pccbb_powerhook(int, void *);
a503 2
	powerhook_establish(pccbb_powerhook, sc);

a2902 6
}

void
pccbb_powerhook(int why, void *arg)
{
	pccbbactivate(arg, why);
@


1.80
log
@Some cleanup in preparation for suspend/resume improvements.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.79 2010/08/31 17:41:46 deraadt Exp $	*/
d123 1
a372 1
	pcireg_t reg;
a400 1
	sc->sc_sockbase = pci_conf_read(pc, pa->pa_tag, PCI_SOCKBASE);
d463 1
a463 17
	switch (sc->sc_chipset) {
	case CB_RX5C46X:
		/*
		 * The legacy pcic io-port on Ricoh RX5C46X CardBus bridges
		 * cannot be disabled by substituting 0 into PCI_LEGACY
		 * register.  Ricoh CardBus bridges have special bits on Bridge
		 * control reg (addr 0x3e on PCI config space).
		 */
		reg = pci_conf_read(pc, pa->pa_tag, PCI_BCR_INTR);
		reg &= ~(CB_BCRI_RL_3E0_ENA | CB_BCRI_RL_3E2_ENA);
		pci_conf_write(pc, pa->pa_tag, PCI_BCR_INTR, reg);
		break;

	default:
		pci_conf_write(pc, pa->pa_tag, PCI_LEGACY, 0x0);
		break;
	}
d573 24
d2814 3
d2835 17
d2854 26
a2879 4
		pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_SOCKBASE,
		    sc->sc_sockbase);
		pci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BUSNUM,
		    sc->sc_busnum);
@


1.79
log
@convert the powerhook to an activate function.  That activate function
does not truly work yet many machines because it does not do enough; it is
a total fluke if it works for you.  (kettenis is, I think, working on
improving it)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.78 2010/08/27 04:09:20 deraadt Exp $	*/
d372 1
a372 1
	pcireg_t busreg, reg, sock_base;
a374 1
	bus_addr_t sockbase;
a393 2
	 * When no valid address is set on socket base registers (on pci
	 * config space), get it not polite way.
a394 2
	sock_base = pci_conf_read(pc, pa->pa_tag, PCI_SOCKBASE);

d396 1
a396 1
	    &sc->sc_base_memt, &sc->sc_base_memh, &sockbase, NULL, 0)) {
d401 2
a402 1
	busreg = pci_conf_read(pc, pa->pa_tag, PCI_BUSNUM);
a418 2
	sc->sc_sockbase = sock_base;
	sc->sc_busnum = busreg;
d454 1
a454 1
	if (((busreg >> 8) & 0xff) == 0) {
a1636 7
#if 0
int
pccbb_new_pcmcia_io_alloc(pcmcia_chipset_handle_t pch,
    bus_addr_t start, bus_size_t size, bus_size_t align, bus_addr_t mask,
    int speed, int flags,
    bus_space_handle_t * iohp)
#endif
a2104 6
#if 0
int
pccbb_new_pcmcia_mem_alloc(pcmcia_chipset_handle_t pch,
    bus_addr_t start, bus_size_t size, bus_size_t align, int speed, int flags,
    bus_space_tag_t * memtp bus_space_handle_t * memhp)
#endif
@


1.78
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.77 2010/08/25 21:37:59 kettenis Exp $	*/
d86 1
d181 1
a181 1
	config_activate_children
d2822 2
a2823 2
void
pccbb_powerhook(int why, void *arg)
d2825 1
a2825 1
	struct pccbb_softc *sc = arg;
d2829 1
d2831 6
a2836 1
	DPRINTF(("%s: power: why %d\n", sc->sc_dev.dv_xname, why));
a2837 1
	if (why == PWR_SUSPEND) {
d2844 6
a2850 13
		/* ToDo: deactivate or suspend child devices */

	}

	if (why == PWR_RESUME) {
		if (pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_SOCKBASE) == 0)
			/* BIOS did not recover this register */
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PCI_SOCKBASE, sc->sc_sockbase);
		if (pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_BUSNUM) == 0)
			/* BIOS did not recover this register */
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    PCI_BUSNUM, sc->sc_busnum);
d2856 1
d2868 2
d2873 4
d2878 4
a2881 2
		/* ToDo: activate or wakeup child devices */
	}
@


1.77
log
@Make CardBus ral(4) suspend and resume properly on machines that keep the
CardBus bridge powered up during suspend.  Step zero on the long road
towards fully suspending CardBus on all machines.

ok deraadt@@, damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.76 2010/06/30 19:46:30 blambert Exp $	*/
d2831 1
a2831 1
	if (why == PWR_SUSPEND || why == PWR_STANDBY) {
@


1.76
log
@timeout_add -> timeout_add_msec

"I agree that hz / 10 is 1/10 of a second, which is 100 milliseconds" krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.75 2010/04/08 00:23:53 tedu Exp $	*/
d179 2
a180 1
	sizeof(struct pccbb_softc), pcicbbmatch, pccbbattach
@


1.75
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.74 2010/03/27 21:40:13 jsg Exp $	*/
d936 1
a936 1
			timeout_add(&sc->sc_ins_tmo, hz / 10);
d1038 1
a1038 1
		timeout_add(&sc->sc_ins_tmo, hz / 10);
@


1.74
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.73 2010/03/27 20:04:03 jsg Exp $	*/
a50 1
#include <sys/proc.h>
@


1.73
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.72 2010/03/23 11:44:00 krw Exp $	*/
a122 5
pcitag_t pccbb_make_tag(cardbus_chipset_tag_t, int, int, int);
void	pccbb_free_tag(cardbus_chipset_tag_t, pcitag_t);
pcireg_t pccbb_conf_read(cardbus_chipset_tag_t, pcitag_t, int);
void	pccbb_conf_write(cardbus_chipset_tag_t, pcitag_t, int,
    pcireg_t);
a206 4
	pccbb_make_tag,
	pccbb_free_tag,
	pccbb_conf_read,
	pccbb_conf_write,
d547 1
a1640 48

/*
 * pcitag_t pccbb_make_tag(cardbus_chipset_tag_t cc,
 *                                    int busno, int devno, int function)
 *   This is the function to make a tag to access config space of
 *  a CardBus Card.  It works same as pci_conf_read.
 */
pcitag_t
pccbb_make_tag(cardbus_chipset_tag_t cc, int busno, int devno, int function)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)cc;

	return pci_make_tag(sc->sc_pc, busno, devno, function);
}

void
pccbb_free_tag(cardbus_chipset_tag_t cc, pcitag_t tag)
{
}

/*
 * pcireg_t pccbb_conf_read(cardbus_chipset_tag_t cc,
 *                                     pcitag_t tag, int offset)
 *   This is the function to read the config space of a CardBus Card.
 *  It works same as pci_conf_read.
 */
pcireg_t
pccbb_conf_read(cardbus_chipset_tag_t cc, pcitag_t tag, int offset)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)cc;

	return pci_conf_read(sc->sc_pc, tag, offset);
}

/*
 * void pccbb_conf_write(cardbus_chipset_tag_t cc, pcitag_t tag,
 *                              int offs, pcireg_t val)
 *   This is the function to write the config space of a CardBus Card.
 *  It works same as pci_conf_write.
 */
void
pccbb_conf_write(cardbus_chipset_tag_t cc, pcitag_t tag, int reg,
    pcireg_t val)
{
	struct pccbb_softc *sc = (struct pccbb_softc *)cc;

	pci_conf_write(sc->sc_pc, tag, reg, val);
}
@


1.72
log
@macppc seems to need a couple more casts before it will compile a
kernel after the cardbus rectification.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.71 2010/03/22 22:28:27 jsg Exp $	*/
d112 2
a113 2
int	pccbb_ctrl(pci_chipset_tag_t, int);
int	pccbb_power(pci_chipset_tag_t, int);
d119 1
a119 1
void   *pccbb_cb_intr_establish(pci_chipset_tag_t, int irq, int level,
d121 1
a121 1
void	pccbb_cb_intr_disestablish(pci_chipset_tag_t ct, void *ih);
d123 4
a126 4
pcitag_t pccbb_make_tag(pci_chipset_tag_t, int, int, int);
void	pccbb_free_tag(pci_chipset_tag_t, pcitag_t);
pcireg_t pccbb_conf_read(pci_chipset_tag_t, pcitag_t, int);
void	pccbb_conf_write(pci_chipset_tag_t, pcitag_t, int,
d158 1
a158 1
int	pccbb_rbus_cb_space_alloc(pci_chipset_tag_t, rbus_tag_t,
d161 1
a161 1
int	pccbb_rbus_cb_space_free(pci_chipset_tag_t, rbus_tag_t,
d362 1
a362 1
	pccbb_power((pci_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
d787 1
a787 1
	pccbb_power((pci_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
d1073 1
a1073 1
 * int pccbb_ctrl(pci_chipset_tag_t, int)
d1076 1
a1076 1
pccbb_ctrl(pci_chipset_tag_t ct, int command)
d1119 1
a1119 1
 * int pccbb_power(pci_chipset_tag_t, int)
d1124 1
a1124 1
pccbb_power(pci_chipset_tag_t ct, int command)
d1457 1
a1457 1
 * void *pccbb_cb_intr_establish(pci_chipset_tag_t ct,
d1471 1
a1471 1
pccbb_cb_intr_establish(pci_chipset_tag_t ct, int irq, int level,
d1481 1
a1481 1
 * void *pccbb_cb_intr_disestablish(pci_chipset_tag_t ct,
d1487 1
a1487 1
pccbb_cb_intr_disestablish(pci_chipset_tag_t ct, void *ih)
d1651 1
a1651 1
 * pcitag_t pccbb_make_tag(pci_chipset_tag_t cc,
d1657 1
a1657 1
pccbb_make_tag(pci_chipset_tag_t cc, int busno, int devno, int function)
d1665 1
a1665 1
pccbb_free_tag(pci_chipset_tag_t cc, pcitag_t tag)
d1670 1
a1670 1
 * pcireg_t pccbb_conf_read(pci_chipset_tag_t cc,
d1676 1
a1676 1
pccbb_conf_read(pci_chipset_tag_t cc, pcitag_t tag, int offset)
d1684 1
a1684 1
 * void pccbb_conf_write(pci_chipset_tag_t cc, pcitag_t tag,
d1690 1
a1690 1
pccbb_conf_write(pci_chipset_tag_t cc, pcitag_t tag, int reg,
d2051 1
a2051 1
	pccbb_power((pci_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
d2067 1
a2067 1
	pccbb_power((pci_chipset_tag_t)sc, voltage);
d2150 1
a2150 1
	pccbb_power((pci_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
d2580 1
a2580 1
 * pccbb_rbus_cb_space_alloc(pci_chipset_tag_t ct, rbus_tag_t rb,
d2590 1
a2590 1
pccbb_rbus_cb_space_alloc(pci_chipset_tag_t ct, rbus_tag_t rb,
d2627 1
a2627 1
 * pccbb_rbus_cb_space_free(pci_chipset_tag_t *ct, rbus_tag_t rb,
d2633 1
a2633 1
pccbb_rbus_cb_space_free(pci_chipset_tag_t ct, rbus_tag_t rb,
@


1.71
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.70 2010/01/13 09:10:33 jsg Exp $	*/
d2051 1
a2051 1
	pccbb_power(sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
d2067 1
a2067 1
	pccbb_power(sc, voltage);
d2150 1
a2150 1
	pccbb_power(sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
@


1.70
log
@As per NetBSD move HAYAKAWA Koichi's licenses to two clause.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.69 2010/01/11 04:31:40 kettenis Exp $	*/
d112 2
a113 2
int	pccbb_ctrl(cardbus_chipset_tag_t, int);
int	pccbb_power(cardbus_chipset_tag_t, int);
d119 1
a119 1
void   *pccbb_cb_intr_establish(cardbus_chipset_tag_t, int irq, int level,
d121 1
a121 1
void	pccbb_cb_intr_disestablish(cardbus_chipset_tag_t ct, void *ih);
d123 5
a127 5
cardbustag_t pccbb_make_tag(cardbus_chipset_tag_t, int, int, int);
void	pccbb_free_tag(cardbus_chipset_tag_t, cardbustag_t);
cardbusreg_t pccbb_conf_read(cardbus_chipset_tag_t, cardbustag_t, int);
void	pccbb_conf_write(cardbus_chipset_tag_t, cardbustag_t, int,
    cardbusreg_t);
d158 1
a158 1
int	pccbb_rbus_cb_space_alloc(cardbus_chipset_tag_t, rbus_tag_t,
d161 1
a161 1
int	pccbb_rbus_cb_space_free(cardbus_chipset_tag_t, rbus_tag_t,
d362 1
a362 1
	pccbb_power((cardbus_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
d787 1
a787 1
	pccbb_power((cardbus_chipset_tag_t)sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
d1073 1
a1073 1
 * int pccbb_ctrl(cardbus_chipset_tag_t, int)
d1076 1
a1076 1
pccbb_ctrl(cardbus_chipset_tag_t ct, int command)
d1119 1
a1119 1
 * int pccbb_power(cardbus_chipset_tag_t, int)
d1124 1
a1124 1
pccbb_power(cardbus_chipset_tag_t ct, int command)
d1457 1
a1457 1
 * void *pccbb_cb_intr_establish(cardbus_chipset_tag_t ct,
d1471 1
a1471 1
pccbb_cb_intr_establish(cardbus_chipset_tag_t ct, int irq, int level,
d1481 1
a1481 1
 * void *pccbb_cb_intr_disestablish(cardbus_chipset_tag_t ct,
d1487 1
a1487 1
pccbb_cb_intr_disestablish(cardbus_chipset_tag_t ct, void *ih)
d1651 1
a1651 1
 * cardbustag_t pccbb_make_tag(cardbus_chipset_tag_t cc,
d1656 2
a1657 2
cardbustag_t
pccbb_make_tag(cardbus_chipset_tag_t cc, int busno, int devno, int function)
d1665 1
a1665 1
pccbb_free_tag(cardbus_chipset_tag_t cc, cardbustag_t tag)
d1670 2
a1671 2
 * cardbusreg_t pccbb_conf_read(cardbus_chipset_tag_t cc,
 *                                     cardbustag_t tag, int offset)
d1675 2
a1676 2
cardbusreg_t
pccbb_conf_read(cardbus_chipset_tag_t cc, cardbustag_t tag, int offset)
d1684 2
a1685 2
 * void pccbb_conf_write(cardbus_chipset_tag_t cc, cardbustag_t tag,
 *                              int offs, cardbusreg_t val)
d1690 2
a1691 2
pccbb_conf_write(cardbus_chipset_tag_t cc, cardbustag_t tag, int reg,
    cardbusreg_t val)
d2580 1
a2580 1
 * pccbb_rbus_cb_space_alloc(cardbus_chipset_tag_t ct, rbus_tag_t rb,
d2590 1
a2590 1
pccbb_rbus_cb_space_alloc(cardbus_chipset_tag_t ct, rbus_tag_t rb,
d2627 1
a2627 1
 * pccbb_rbus_cb_space_free(cardbus_chipset_tag_t *ct, rbus_tag_t rb,
d2633 1
a2633 1
pccbb_rbus_cb_space_free(cardbus_chipset_tag_t ct, rbus_tag_t rb,
d2763 2
a2764 2
		cardbusreg_t win_start;
		cardbusreg_t win_limit;
@


1.69
log
@When mapping CarBus memory BARs, enforce a minimum alignment of 0x1000.  This
is the granularity of the windows provided by the CardBus bridge.  A smaller
alignment may result in those windows covering address space used by other
PCI devices in the machines.  Fixes CardBus xl(4) n naddy's X40.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.68 2009/08/28 15:54:52 kettenis Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by HAYAKAWA Koichi.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.68
log
@Writing 0 to the PCI_LEGACY register *is* the proper way to disable the
legacy register mapping.  So remove comments and #ifdef 0'ed code that
questions this.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.67 2009/07/25 11:27:26 kettenis Exp $	*/
d2605 5
a2609 2
	if (align == 0) {
		align = size;
d2612 1
a2612 8
	if (rb->rb_bt == sc->sc_memt) {
		if (align < 16) {
			return 1;
		}
	} else if (rb->rb_bt == sc->sc_iot) {
		if (align < 4) {
			return 1;
		}
a2617 7

	} else {
		DPRINTF(
		    ("pccbb_rbus_cb_space_alloc: Bus space tag %x is NOT used.\n",
		    rb->rb_bt));
		return 1;
		/* XXX: panic here? */
@


1.67
log
@Stop using rbus to set up the socket BAR if it has been left unitialized
by the firmware; our PCI code takes care of this now.  Also eliminate
support for I/O socket BARs.  There is no evidence they actually exist.
Clean up some unused structure members while there.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.66 2009/07/21 20:59:45 miod Exp $	*/
a484 4
#if 0
	/* The RX5C47X-series requires writes to the PCI_LEGACY register. */
	case CB_RX5C47X:
#endif
a496 1
		/* XXX I don't know proper way to kill legacy I/O. */
@


1.66
log
@Use the symbolic constants for the window registers in pci configuration
space in pccbb_winset(), instead of their bare values. Saves time for grep
users. While there, a few grammar and typo fixes in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.65 2009/07/20 23:40:43 miod Exp $	*/
a365 4
	/* Nothing for us to do if we didn't map any registers. */
	if ((sc->sc_flags & CBB_MEMHMAPPED) == 0)
		return;

a405 2
	sc->sc_flags &= ~CBB_MEMHMAPPED;

d413 4
a416 27
	if (PCI_MAPREG_MEM_ADDR(sock_base) >= 0x100000 &&
	    PCI_MAPREG_MEM_ADDR(sock_base) != 0xfffffff0) {
		/* The address must be valid. */
		if (pci_mapreg_map(pa, PCI_SOCKBASE, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->sc_base_memt, &sc->sc_base_memh, &sockbase, NULL, 0))
		    {
			printf("%s: can't map socket base address 0x%x\n",
			    sc->sc_dev.dv_xname, sock_base);
			/*
			 * I think it's funny: socket base registers must be
			 * mapped on memory space, but ...
			 */
			if (pci_mapreg_map(pa, PCI_SOCKBASE,
			    PCI_MAPREG_TYPE_IO, 0, &sc->sc_base_memt,
			    &sc->sc_base_memh, &sockbase, NULL, 0)) {
				printf("%s: can't map socket base address"
				    " 0x%lx: io mode\n", sc->sc_dev.dv_xname,
				    sockbase);
				/* give up... allocate reg space via rbus. */
				pci_conf_write(pc, pa->pa_tag, PCI_SOCKBASE, 0);
			} else
				sc->sc_flags |= CBB_MEMHMAPPED;
		} else {
			DPRINTF(("%s: socket base address 0x%lx\n",
			    sc->sc_dev.dv_xname, sockbase));
			sc->sc_flags |= CBB_MEMHMAPPED;
		}
a418 3
	sc->sc_mem_start = 0;	       /* XXX */
	sc->sc_mem_end = 0xffffffff;   /* XXX */

a420 2
	/* pccbb_machdep.c end */

d484 1
a484 1
	case CB_RX5C46X:	       /* fallthrough */
a529 1
	bus_addr_t sockbase;
a534 16

	if (!(sc->sc_flags & CBB_MEMHMAPPED)) {
		/* The socket registers aren't mapped correctly. */
		if (rbus_space_alloc(sc->sc_rbus_memt, 0, 0x1000, 0x0fff,
		    (sc->sc_chipset == CB_RX5C47X
		    || sc->sc_chipset == CB_TI113X) ? 0x10000 : 0x1000,
		    0, &sockbase, &sc->sc_base_memh)) {
			return;
		}
		sc->sc_base_memt = sc->sc_memt;
		pci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);
		DPRINTF(("%s: CardBus register address 0x%lx -> 0x%x\n",
		    sc->sc_dev.dv_xname, sockbase, pci_conf_read(pc, sc->sc_tag,
		    PCI_SOCKBASE)));
		sc->sc_flags |= CBB_MEMHMAPPED;
	}
@


1.65
log
@Pass a pci_chipset_tag_t to pci_intr_line(), to eventually allow the
logic to be chipset dependent; no functional change yet.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.64 2009/06/03 04:32:10 jsg Exp $	*/
d1031 3
a1033 3
		 * sentense instead of switch-case sentense because of
		 * avoiding duplicate case value error.  More than one
		 * IPL_XXX use same value.  It depends on
d2847 1
a2847 1
	offs = 0x2c;
d2850 1
a2850 1
		offs = 0x1c;
d2909 1
a2909 1
			/* the flags of win[0] and win[1] is different */
d2972 1
a2972 1
		if (pci_conf_read (sc->sc_pc, sc->sc_tag, PCI_SOCKBASE) == 0)
d2974 3
a2976 3
			pci_conf_write (sc->sc_pc, sc->sc_tag,
					PCI_SOCKBASE, sc->sc_sockbase);
		if (pci_conf_read (sc->sc_pc, sc->sc_tag, PCI_BUSNUM) == 0)
d2978 2
a2979 2
			pci_conf_write (sc->sc_pc, sc->sc_tag,
					PCI_BUSNUM, sc->sc_busnum);
@


1.64
log
@ansi function decls, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.63 2008/10/15 19:12:18 blambert Exp $	*/
d484 1
a484 1
	sc->sc_intrline = pci_intr_line(ih);
@


1.63
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.62 2008/09/25 17:54:01 chl Exp $	*/
d384 1
a384 4
pccbbattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d557 1
a557 2
pccbb_pci_callback(self)
	struct device *self;
d674 1
a674 2
pccbb_chipinit(sc)
	struct pccbb_softc *sc;
d861 2
a862 3
pccbb_pcmcia_attach_setup(sc, paa)
	struct pccbb_softc *sc;
	struct pcmciabus_attach_args *paa;
d913 1
a913 2
pccbb_pcmcia_attach_card(ph)
	struct pcic_handle *ph;
d926 1
a926 3
pccbb_pcmcia_detach_card(ph, flags)
	struct pcic_handle *ph;
	int flags;
d946 1
a946 2
pccbbintr(arg)
	void *arg;
d1022 1
a1022 2
pccbbintr_function(sc)
	struct pccbb_softc *sc;
d1079 1
a1079 2
pci113x_insert(arg)
	void *arg;
d1114 1
a1114 3
pccbb_pcmcia_read(ph, reg)
	struct pcic_handle *ph;
	int reg;
d1124 1
a1124 4
pccbb_pcmcia_write(ph, reg, val)
	struct pcic_handle *ph;
	int reg;
	u_int8_t val;
d1137 1
a1137 3
pccbb_ctrl(ct, command)
	cardbus_chipset_tag_t ct;
	int command;
d1185 1
a1185 3
pccbb_power(ct, command)
	cardbus_chipset_tag_t ct;
	int command;
d1326 1
a1326 2
cb_pcmcia_poll(arg)
	void *arg;
d1378 1
a1378 2
pccbb_detect_card(sc)
	struct pccbb_softc *sc;
d1417 1
a1417 2
cb_reset(sc)
	struct pccbb_softc *sc;
d1446 1
a1446 2
cb_detect_voltage(sc)
	struct pccbb_softc *sc;
d1466 1
a1466 3
cbbprint(aux, pcic)
	void *aux;
	const char *pcic;
d1483 1
a1483 3
pccbb_cardenable(sc, function)
	struct pccbb_softc *sc;
	int function;
d1532 2
a1533 6
pccbb_cb_intr_establish(ct, irq, level, func, arg, name)
	cardbus_chipset_tag_t ct;
	int irq, level;
	int (*func)(void *);
	void *arg;
	const char *name;
d1548 1
a1548 3
pccbb_cb_intr_disestablish(ct, ih)
	cardbus_chipset_tag_t ct;
	void *ih;
d1571 2
a1572 6
pccbb_intr_establish(sc, irq, level, func, arg, name)
	struct pccbb_softc *sc;
	int irq, level;
	int (*func)(void *);
	void *arg;
	const char *name;
d1630 1
a1630 3
pccbb_intr_disestablish(sc, ih)
	struct pccbb_softc *sc;
	void *ih;
d1675 2
a1676 5
cb_show_regs(pc, tag, memt, memh)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	bus_space_tag_t memt;
	bus_space_handle_t memh;
d1718 1
a1718 3
pccbb_make_tag(cc, busno, devno, function)
	cardbus_chipset_tag_t cc;
	int busno, devno, function;
d1726 1
a1726 3
pccbb_free_tag(cc, tag)
	cardbus_chipset_tag_t cc;
	cardbustag_t tag;
d1737 1
a1737 4
pccbb_conf_read(cc, tag, offset)
	cardbus_chipset_tag_t cc;
	cardbustag_t tag;
	int offset;		       /* register offset */
d1751 2
a1752 5
pccbb_conf_write(cc, tag, reg, val)
	cardbus_chipset_tag_t cc;
	cardbustag_t tag;
	int reg;		       /* register offset */
	cardbusreg_t val;
d1778 2
a1779 6
pccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)
	pcmcia_chipset_handle_t pch;
	bus_addr_t start;	       /* start address */
	bus_size_t size;
	bus_size_t align;
	struct pcmcia_io_handle *pcihp;
d1849 2
a1850 3
pccbb_pcmcia_io_free(pch, pcihp)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_io_handle *pcihp;
d1876 2
a1877 7
pccbb_pcmcia_io_map(pch, width, offset, size, pcihp, windowp)
	pcmcia_chipset_handle_t pch;
	int width;
	bus_addr_t offset;
	bus_size_t size;
	struct pcmcia_io_handle *pcihp;
	int *windowp;
d1939 1
a1939 3
pccbb_pcmcia_do_io_map(ph, win)
	struct pcic_handle *ph;
	int win;
d2015 1
a2015 3
pccbb_pcmcia_io_unmap(pch, win)
	pcmcia_chipset_handle_t pch;
	int win;
d2045 1
a2045 2
pccbb_pcmcia_wait_ready(ph)
	struct pcic_handle *ph;
d2076 1
a2076 2
pccbb_pcmcia_socket_enable(pch)
	pcmcia_chipset_handle_t pch;
d2192 1
a2192 2
pccbb_pcmcia_socket_disable(pch)
	pcmcia_chipset_handle_t pch;
d2225 1
a2225 2
pccbb_pcmcia_card_detect(pch)
	pcmcia_chipset_handle_t pch;
d2251 2
a2252 4
pccbb_pcmcia_mem_alloc(pch, size, pcmhp)
	pcmcia_chipset_handle_t pch;
	bus_size_t size;
	struct pcmcia_mem_handle *pcmhp;
d2312 2
a2313 3
pccbb_pcmcia_mem_free(pch, pcmhp)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_mem_handle *pcmhp;
d2328 1
a2328 3
pccbb_pcmcia_do_mem_map(ph, win)
	struct pcic_handle *ph;
	int win;
d2432 3
a2434 8
pccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)
	pcmcia_chipset_handle_t pch;
	int kind;
	bus_addr_t card_addr;
	bus_size_t size;
	struct pcmcia_mem_handle *pcmhp;
	bus_size_t *offsetp;
	int *windowp;
d2502 1
a2502 3
pccbb_pcmcia_mem_unmap(pch, window)
	pcmcia_chipset_handle_t pch;
	int window;
d2535 1
a2535 2
pccbb_pcmcia_poll(arg)
	void *arg;
d2591 3
a2593 7
pccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg, xname)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_function *pf;
	int ipl;
	int (*func)(void *);
	void *arg;
	char *xname;
d2622 1
a2622 3
pccbb_pcmcia_intr_disestablish(pch, ih)
	pcmcia_chipset_handle_t pch;
	void *ih;
d2631 1
a2631 3
pccbb_pcmcia_intr_string(pch, ih)
	pcmcia_chipset_handle_t pch;
	void *ih;
d2651 3
a2653 10
pccbb_rbus_cb_space_alloc(ct, rb, addr, size, mask, align, flags, addrp, bshp)
	cardbus_chipset_tag_t ct;
	rbus_tag_t rb;
	bus_addr_t addr;
	bus_size_t size;
	bus_addr_t mask;
	bus_size_t align;
	int flags;
	bus_addr_t *addrp;
	bus_space_handle_t *bshp;
d2705 2
a2706 5
pccbb_rbus_cb_space_free(ct, rb, bsh, size)
	cardbus_chipset_tag_t ct;
	rbus_tag_t rb;
	bus_space_handle_t bsh;
	bus_size_t size;
d2724 2
a2725 7
pccbb_open_win(sc, bst, addr, size, bsh, flags)
	struct pccbb_softc *sc;
	bus_space_tag_t bst;
	bus_addr_t addr;
	bus_size_t size;
	bus_space_handle_t bsh;
	int flags;
d2750 2
a2751 5
pccbb_close_win(sc, bst, bsh, size)
	struct pccbb_softc *sc;
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	bus_size_t size;
d2774 2
a2775 6
pccbb_winlist_insert(head, start, size, bsh, flags)
	struct pccbb_win_chain_head *head;
	bus_addr_t start;
	bus_size_t size;
	bus_space_handle_t bsh;
	int flags;
d2801 2
a2802 4
pccbb_winlist_delete(head, bsh, size)
	struct pccbb_win_chain_head *head;
	bus_space_handle_t bsh;
	bus_size_t size;
d2829 1
a2829 4
pccbb_winset(align, sc, bst)
	bus_addr_t align;
	struct pccbb_softc *sc;
	bus_space_tag_t bst;
d2950 1
a2950 3
pccbb_powerhook(why, arg)
	int why;
	void *arg;
@


1.62
log
@remove dead store.

Found by LLVM/Clang Static Analyzer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.61 2008/07/20 18:58:07 kettenis Exp $	*/
d2629 1
a2629 1
	timeout_add(&pccbb_poll_timeout, hz * 2);
@


1.61
log
@On TI cardbus bridges, enable PCI interrupt routing if the device has not
been initialized by the firmware.  This was probably the intention of the
origional code, however, it used the wrong default value for the register
in question.

Add TI PCI1510 to the list of 12XX-compatible bridges.

"be brave" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.60 2008/05/22 19:23:04 mk Exp $	*/
a1866 1
		mask = 1;
@


1.60
log
@More timeout(9) usage cleaned up.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.59 2007/12/20 13:59:27 kettenis Exp $	*/
d288 2
d750 1
a750 1
		if (reg == 0) {
@


1.59
log
@Get rid of __HAVE_PCCBB_ATTACH_HOOK.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.58 2007/12/19 21:34:10 kettenis Exp $	*/
a1013 3
			if (sc->sc_flags & CBB_INSERTING) {
				timeout_del(&sc->sc_ins_tmo);
			}
@


1.58
log
@If the CardBus bus number is left unconfigured, only attach pcmcia(4).

ok jsing@@, fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.57 2007/12/14 20:55:08 kettenis Exp $	*/
a395 1
#ifdef __HAVE_PCCBB_ATTACH_HOOK
a396 1
#endif
@


1.57
log
@Revert previous commit; something is still wrong, and I can't figure out what
fast enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.55 2007/11/30 13:43:35 deraadt Exp $	*/
a453 4
	/*
	 * When bus number isn't set correctly, give up using 32-bit CardBus
	 * mode.
	 */
a454 6
#if notyet
	if (((busreg >> 8) & 0xff) == 0) {
		printf(": CardBus support disabled because of unconfigured bus number\n");
		flags |= PCCBB_PCMCIA_16BITONLY;
	}
#endif
d461 1
a461 1
		printf(": intrpin %s, intrtag %d\n",
d504 12
a515 1
	printf(": %s\n", intrstr);
@


1.56
log
@Un-#ifdef code, such that we don't attach cardbus if the bus nuber is
unconfigured.

Tested by a few; ok deraadt@@ (a while back).
@
text
@d459 1
d464 1
@


1.55
log
@skip the bad mapping checks for now, sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.54 2007/11/30 08:12:00 miod Exp $	*/
a458 1
#if notyet
a462 1
#endif
@


1.54
log
@Skip the sanity test introduced in r1.50 on TI devices, as it gets triggered
with valid devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.53 2007/11/26 15:35:15 deraadt Exp $	*/
a591 15

	/* check for dead device? */
	switch (PCI_VENDOR(sc->sc_id)) {
	case PCI_VENDOR_TI:
		break;
	default:
		if (bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT) ==
		    0xffffffff && bus_space_read_4(base_memt, base_memh,
		    CB_SOCKET_MASK) == 0xffffffff) {
			printf("%s: controller is missing\n",
			    sc->sc_dev.dv_xname);
			return;
		}
		break;
	}
@


1.53
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.52 2007/11/25 22:35:21 deraadt Exp $	*/
d401 1
d594 12
a605 4
	if (bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT) == 0xffffffff &&
	    bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK) == 0xffffffff) {
		printf("%s: controller is missing\n", sc->sc_dev.dv_xname);
		return;
@


1.52
log
@missing line from previous commit; return 1 for interrupts we do handle
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.51 2007/11/25 18:59:12 deraadt Exp $	*/
d56 1
d223 13
d987 1
a987 1
		if (CB_SOCKET_STAT_CD == (sockstate & CB_SOCKET_STAT_CD)) {
d1014 1
a1014 1
		} else if (0x00 == (sockstate & CB_SOCKET_STAT_CD) &&
d1455 1
a1455 2
	int reset_duration =
	    (sc->sc_chipset == CB_RX5C47X ? 400 * 1000 : 40 * 1000);
d1461 1
a1461 1
	delay(reset_duration);
d1467 1
a1467 1
		delay(reset_duration);
d2180 1
a2180 1
		printf("?V card, 0x%x\n", spsr);	/* XXX */
d2204 1
a2204 1
	/* power up the socket and output enable */
d2206 1
a2206 2
	power |= PCIC_PWRCTL_OE;
	Pcic_write(ph, PCIC_PWRCTL, power);
d2208 4
@


1.51
log
@Interrupt handlers which do nothing should return 0 (or -1 if they are not
sure)
ok kettenis jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.50 2007/11/25 18:57:50 deraadt Exp $	*/
d1013 1
@


1.50
log
@If some rather important registers read as 0xffffffff then the device
is probably not there and we should not attach cardbus.  Viao TZ-series
with a Ricoh cardbus+ofw+MMC/SD/MS/.. chip
ok kettenis jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.49 2007/11/25 12:18:34 deraadt Exp $	*/
d1015 1
a1015 1
	return (1);
@


1.49
log
@remove an ugly nested block
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.48 2007/11/23 19:46:16 kettenis Exp $	*/
d575 10
a586 3

	base_memt = sc->sc_base_memt;  /* socket regs memory tag */
	base_memh = sc->sc_base_memh;  /* socket regs memory handle */
@


1.48
log
@Don't do anything in the shutdownhook if the registers aren't mapped.

ok deraadt@@, fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.47 2006/10/12 16:35:51 grange Exp $	*/
d557 1
d587 3
a589 7
	{
		u_int32_t sockstat =
		    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);
		if (0 == (sockstat & CB_SOCKET_STAT_CD)) {
			sc->sc_flags |= CBB_CARDEXIST;
		}
	}
@


1.47
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.46 2006/06/21 11:27:03 fkr Exp $	*/
d349 4
@


1.46
log
@removal of '#ifdef rbus ... #else ...' directives, we use rbus in all
cases anyways, so we might as well remove code (the !rbus case) thats been
dead throughout the last years and just use the rbus code without ifdefs.

brad, miod "I am all for this diff"
ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.45 2006/06/14 08:36:31 fkr Exp $	*/
d51 1
d120 1
a120 1
    int (*ih) (void *), void *sc);
d124 1
a124 1
    int (*ih) (void *), void *sc);
d1060 2
d1537 2
a1538 1
 *					void *arg)
d1547 1
a1547 1
pccbb_cb_intr_establish(ct, irq, level, func, arg)
d1552 1
d1556 1
a1556 1
	return pccbb_intr_establish(sc, irq, level, func, arg);
d1582 2
a1583 1
 *				     void *arg)
d1592 1
a1592 1
pccbb_intr_establish(sc, irq, level, func, arg)
d1597 1
d1631 2
d1668 1
d2685 1
a2685 1
	return pccbb_intr_establish(sc, -1, ipl, func, arg);
@


1.45
log
@remove redundant commented debug define
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.44 2006/04/02 23:29:05 brad Exp $	*/
a117 6
#if !rbus
int	pccbb_io_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t);
int	pccbb_io_close(cardbus_chipset_tag_t, int);
int	pccbb_mem_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t);
int	pccbb_mem_close(cardbus_chipset_tag_t, int);
#endif /* !rbus */
a160 2
#if rbus

a166 4
#endif /* rbus */

#if rbus

a178 2
#endif /* rbus */

a207 1
#if rbus
a219 15
#else
static struct cardbus_functions pccbb_funcs = {
	pccbb_ctrl,
	pccbb_power,
	pccbb_mem_open,
	pccbb_mem_close,
	pccbb_io_open,
	pccbb_io_close,
	pccbb_cb_intr_establish,
	pccbb_cb_intr_disestablish,
	pccbb_make_tag,
	pccbb_conf_read,
	pccbb_conf_write,
};
#endif
a389 1
#if rbus
a391 1
#endif /* rbus */
a554 1
#if rbus
a565 15
#else
		sc->sc_base_memt = sc->sc_memt;
#if !defined CBB_PCI_BASE
#define CBB_PCI_BASE 0x20000000
#endif
		if (bus_space_alloc(sc->sc_base_memt, CBB_PCI_BASE, 0xffffffff,
		    0x1000, 0x1000, 0, 0, &sockbase, &sc->sc_base_memh)) {
			/* cannot allocate memory space */
			return;
		}
		pci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);
		DPRINTF(("%s: CardBus register address 0x%x -> 0x%x\n",
		    sc->sc_dev.dv_xname, sock_base, pci_conf_read(pc,
		    sc->sc_tag, PCI_SOCKBASE)));
#endif
a605 1
#if rbus
a607 1
#endif
a852 1
#if rbus
a853 1
#endif
a891 1
#if rbus
a894 1
#endif
a1528 115
#if !rbus
/*
 * int pccbb_io_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t)
 */
int
pccbb_io_open(ct, win, start, end)
	cardbus_chipset_tag_t ct;
	int win;
	u_int32_t start, end;
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;
	int basereg;
	int limitreg;

	if ((win < 0) || (win > 2)) {
#if defined DIAGNOSTIC
		printf("cardbus_io_open: window out of range %d\n", win);
#endif
		return 0;
	}

	basereg = win * 8 + 0x2c;
	limitreg = win * 8 + 0x30;

	DPRINTF(("pccbb_io_open: 0x%x[0x%x] - 0x%x[0x%x]\n",
	    start, basereg, end, limitreg));

	pci_conf_write(sc->sc_pc, sc->sc_tag, basereg, start);
	pci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, end);
	return 1;
}

/*
 * int pccbb_io_close(cardbus_chipset_tag_t, int)
 */
int
pccbb_io_close(ct, win)
	cardbus_chipset_tag_t ct;
	int win;
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;
	int basereg;
	int limitreg;

	if ((win < 0) || (win > 2)) {
#if defined DIAGNOSTIC
		printf("cardbus_io_close: window out of range %d\n", win);
#endif
		return 0;
	}

	basereg = win * 8 + 0x2c;
	limitreg = win * 8 + 0x30;

	pci_conf_write(sc->sc_pc, sc->sc_tag, basereg, 0);
	pci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, 0);
	return 1;
}

/*
 * int pccbb_mem_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t)
 */
int
pccbb_mem_open(ct, win, start, end)
	cardbus_chipset_tag_t ct;
	int win;
	u_int32_t start, end;
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;
	int basereg;
	int limitreg;

	if ((win < 0) || (win > 2)) {
#if defined DIAGNOSTIC
		printf("cardbus_mem_open: window out of range %d\n", win);
#endif
		return 0;
	}

	basereg = win * 8 + 0x1c;
	limitreg = win * 8 + 0x20;

	pci_conf_write(sc->sc_pc, sc->sc_tag, basereg, start);
	pci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, end);
	return 1;
}

/*
 * int pccbb_mem_close(cardbus_chipset_tag_t, int)
 */
int
pccbb_mem_close(ct, win)
	cardbus_chipset_tag_t ct;
	int win;
{
	struct pccbb_softc *sc = (struct pccbb_softc *)ct;
	int basereg;
	int limitreg;

	if ((win < 0) || (win > 2)) {
#if defined DIAGNOSTIC
		printf("cardbus_mem_close: window out of range %d\n", win);
#endif
		return 0;
	}

	basereg = win * 8 + 0x1c;
	limitreg = win * 8 + 0x20;

	pci_conf_write(sc->sc_pc, sc->sc_tag, basereg, 0);
	pci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, 0);
	return 1;
}
#endif

a1820 1
#if rbus
d1822 1
a1822 1
#endif
a1860 1
#if rbus
a1864 20
#else
	if (start) {
		ioaddr = start;
		if (bus_space_map(iot, start, size, 0, &ioh)) {
			return 1;
		}
		DPRINTF(("pccbb_pcmcia_io_alloc map port 0x%lx+0x%lx\n",
		    (u_long) ioaddr, (u_long) size));
	} else {
		flags |= PCMCIA_IO_ALLOCATED;
		if (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,
		    0x800,	/* ph->sc->sc_iobase + ph->sc->sc_iosize */
		    size, align, 0, 0, &ioaddr, &ioh)) {
			/* No room be able to be get. */
			return 1;
		}
		DPRINTF(("pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\n",
		    (u_long) ioaddr, (u_long) size));
	}
#endif
a1887 3
#if !rbus
	bus_space_tag_t iot = pcihp->iot;
#endif
a1890 1
#if rbus
a1895 6
#else
	if (pcihp->flags & PCMCIA_IO_ALLOCATED)
		bus_space_free(iot, ioh, size);
	else
		bus_space_unmap(iot, ioh, size);
#endif
a2306 1
#if rbus
a2307 1
#endif
a2328 1
#if rbus
a2334 9
#else
	if (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,
	    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,
	    0, /* boundary */
	    0,	/* flags */
	    &addr, &memh)) {
		return 1;
	}
#endif
a2363 1
#if rbus
a2367 3
#else
	bus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);
#endif
a2705 1
#if rbus
a2798 3
#endif /* rbus */

#if rbus
a3041 2

#endif /* rbus */
@


1.44
log
@- add pccbb_attach_hook in pccbbattach for MD initializations.
- omit arithmetics to bus_space_handle_t.
- remove use of IST_LEVEL; not defined on sparc64 and unused.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.43 2006/03/11 09:58:34 brad Exp $	*/
a38 1
/* #define CBB_DEBUG */
@


1.43
log
@splvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.42 2006/03/11 04:07:28 brad Exp $	*/
d408 4
d426 1
a426 1
	sc->sc_base_memh = 0;
a453 1
				sc->sc_base_memh = 0;
d455 2
a456 1
			}
d460 1
a558 3



d586 1
a586 1
	if (0 == sc->sc_base_memh) {
d615 1
a700 4




d2893 1
a2893 1
	return pccbb_intr_establish(sc, IST_LEVEL, ipl, func, arg);
d3121 1
a3121 1
		if (chainp->wc_handle != bsh)
@


1.42
log
@remove splimp handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.41 2005/11/26 14:31:26 krw Exp $	*/
d1099 2
@


1.41
log
@Add some missing 'break;'s in auich and auixp that lint spotted. While
here, use FALLTHRU or FALLTHROUGH to make lint even happier.

ok marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.40 2005/11/23 11:39:37 mickey Exp $	*/
a1098 4
#ifdef IPL_IMP
		} else if (pil->pil_level == IPL_IMP) {
			s = splimp();
#endif
@


1.40
log
@use proper bus_size_t for register offsets and not bus_addr_t; uwe@@ miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.39 2005/10/05 21:32:28 tdeval Exp $	*/
d794 1
a794 1
		/* fallthrough */
@


1.39
log
@Support the CardBus part of TI's PCI7XX1 controllers.
ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.38 2005/10/02 18:20:00 fgsch Exp $	*/
d145 1
a145 1
    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *);
d2698 1
a2698 1
 *                                 bus_addr_t *offsetp, int *windowp)
d2710 1
a2710 1
	bus_addr_t *offsetp;
@


1.38
log
@add special handling for some o2micro devices, so by instance atheros works.
adapted from similar linux change by
Aristeu Sergio Rozanski Filho <aris at cathedrallabs dot org>
via Leonardo Chiquitto Filho <leonardo at iken dot com dot br>.
test compiled by pedro@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.37 2005/09/16 02:20:23 fgsch Exp $	*/
d303 2
@


1.37
log
@spelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.36 2005/08/03 23:08:22 fgsch Exp $	*/
d335 12
d848 18
d2012 1
a2012 1
		bus_size_t size_tmp = size;	
@


1.36
log
@enforce 10-bit width for i/o addresses when start address is assigned by
the driver and calcule address line mask when is not.  from haya@@netbsd.org.
tested by several ppl.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.35 2005/01/27 17:03:23 millert Exp $ */
d495 1
a495 1
	 * than any other hard interrputs.
d581 1
a581 1
		DPRINTF(("%s: CardBus resister address 0x%lx -> 0x%x\n",
d595 1
a595 1
		DPRINTF(("%s: CardBus resister address 0x%x -> 0x%x\n",
@


1.35
log
@Add pcmcia_intr_string() to format the intr string for pcmcia attach
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.34 2004/07/14 21:54:18 mickey Exp $ */
d1961 1
d1969 28
d2005 1
a2005 2
	/* XXX: I assume all card decode lower 10 bits by its hardware */
	if (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {
d2014 1
a2014 1
		DPRINTF(("pccbb_pcmcia_io_alloc map port %lx+%lx\n",
@


1.34
log
@tweaks for ti12xx bridges; from freebsd via rees@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.33 2003/12/23 20:52:23 mickey Exp $ */
d156 2
a157 2
void	pccbb_pcmcia_intr_disestablish(pcmcia_chipset_handle_t,
    void *);
d217 1
d2854 11
@


1.33
log
@do not panic if there is no IPL_IMP
@
text
@d1 2
a2 2
/*	$OpenBSD: pccbb.c,v 1.32 2003/06/25 21:53:45 mickey Exp $ */
/*	$NetBSD: pccbb.c,v 1.42 2000/06/16 23:41:35 cgd Exp $	*/
d281 1
a281 1
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1250), CB_TI12XX,
d289 1
a289 1
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251), CB_TI12XX,
d291 1
a291 1
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251B), CB_TI12XX,
d299 1
a299 1
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1450), CB_TI12XX,
d755 39
@


1.32
log
@add topic97b support; from netbsd and tested by Pedro la Peu <pedro@@am-gen.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.31 2002/07/23 17:53:25 drahn Exp $ */
d1027 1
d1030 1
@


1.31
log
@Cardbus/pcmcia support for macppc. parts borrowed from NetBSD, and other
portions of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.30 2002/03/14 03:16:06 millert Exp $ */
d771 24
@


1.30
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.29 2002/03/14 01:26:59 millert Exp $ */
d403 2
a404 2
	sc->sc_rbus_iot = rbus_pccbb_parent_io(pa);
	sc->sc_rbus_memt = rbus_pccbb_parent_mem(pa);
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.28 2002/01/30 13:23:32 fgsch Exp $ */
d125 2
a126 2
void   *pccbb_intr_establish __P((struct pccbb_softc *, int irq, int level,
    int (*ih) (void *), void *sc));
d129 2
a130 2
void   *pccbb_cb_intr_establish __P((cardbus_chipset_tag_t, int irq, int level,
    int (*ih) (void *), void *sc));
d154 2
a155 2
void   *pccbb_pcmcia_intr_establish __P((pcmcia_chipset_handle_t,
    struct pcmcia_function *, int, int (*)(void *), void *, char *));
@


1.28
log
@TI 1410 PCI-CardBus support.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.27 2001/12/24 18:21:42 mickey Exp $ */
d89 6
a94 6
int	pcicbbmatch __P((struct device *, void *, void *));
void	pccbbattach __P((struct device *, struct device *, void *));
int	pccbbintr __P((void *));
void	pccbb_shutdown __P((void *));
void	pci113x_insert __P((void *));
int	pccbbintr_function __P((struct pccbb_softc *));
d96 1
a96 1
int	pccbb_detect_card __P((struct pccbb_softc *));
d98 2
a99 2
void	pccbb_pcmcia_write __P((struct pcic_handle *, int, int));
u_int8_t pccbb_pcmcia_read __P((struct pcic_handle *, int));
d103 7
a109 7
int	cb_reset __P((struct pccbb_softc *));
int	cb_detect_voltage __P((struct pccbb_softc *));
int	cbbprint __P((void *, const char *));

int	cb_chipset __P((u_int32_t, int *));
void	pccbb_pcmcia_attach_setup __P((struct pccbb_softc *,
    struct pcmciabus_attach_args *));
d111 3
a113 3
void	pccbb_pcmcia_attach_card __P((struct pcic_handle *));
void	pccbb_pcmcia_detach_card __P((struct pcic_handle *, int));
void	pccbb_pcmcia_deactivate_card __P((struct pcic_handle *));
d116 3
a118 3
int	pccbb_ctrl __P((cardbus_chipset_tag_t, int));
int	pccbb_power __P((cardbus_chipset_tag_t, int));
int	pccbb_cardenable __P((struct pccbb_softc * sc, int function));
d120 4
a123 4
int	pccbb_io_open __P((cardbus_chipset_tag_t, int, u_int32_t, u_int32_t));
int	pccbb_io_close __P((cardbus_chipset_tag_t, int));
int	pccbb_mem_open __P((cardbus_chipset_tag_t, int, u_int32_t, u_int32_t));
int	pccbb_mem_close __P((cardbus_chipset_tag_t, int));
d127 1
a127 1
void	pccbb_intr_disestablish __P((struct pccbb_softc *, void *ih));
d131 1
a131 1
void	pccbb_cb_intr_disestablish __P((cardbus_chipset_tag_t ct, void *ih));
d133 21
a153 21
cardbustag_t pccbb_make_tag __P((cardbus_chipset_tag_t, int, int, int));
void	pccbb_free_tag __P((cardbus_chipset_tag_t, cardbustag_t));
cardbusreg_t pccbb_conf_read __P((cardbus_chipset_tag_t, cardbustag_t, int));
void	pccbb_conf_write __P((cardbus_chipset_tag_t, cardbustag_t, int,
    cardbusreg_t));
void	pccbb_chipinit __P((struct pccbb_softc *));

int	pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,
    struct pcmcia_mem_handle *));
void	pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,
    struct pcmcia_mem_handle *));
int	pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,
    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));
void	pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));
int	pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,
    bus_size_t, bus_size_t, struct pcmcia_io_handle *));
void	pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,
    struct pcmcia_io_handle *));
int	pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,
    bus_size_t, struct pcmcia_io_handle *, int *));
void	pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));
d156 10
a165 10
void	pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,
    void *));
void	pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));
void	pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));
int	pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));

void	pccbb_pcmcia_do_io_map __P((struct pcic_handle *, int));
void	pccbb_pcmcia_wait_ready __P((struct pcic_handle *));
void	pccbb_pcmcia_do_mem_map __P((struct pcic_handle *, int));
void	pccbb_powerhook __P((int, void *));
d170 1
a170 1
int	pccbb_rbus_cb_space_alloc __P((cardbus_chipset_tag_t, rbus_tag_t,
d172 3
a174 3
    int flags, bus_addr_t * addrp, bus_space_handle_t * bshp));
int	pccbb_rbus_cb_space_free __P((cardbus_chipset_tag_t, rbus_tag_t,
    bus_space_handle_t, bus_size_t));
d180 10
a189 10
int	pccbb_open_win __P((struct pccbb_softc *, bus_space_tag_t,
    bus_addr_t, bus_size_t, bus_space_handle_t, int flags));
int	pccbb_close_win __P((struct pccbb_softc *, bus_space_tag_t,
    bus_space_handle_t, bus_size_t));
int	pccbb_winlist_insert __P((struct pccbb_win_chain_head *, bus_addr_t,
    bus_size_t, bus_space_handle_t, int));
int	pccbb_winlist_delete __P((struct pccbb_win_chain_head *,
    bus_space_handle_t, bus_size_t));
void	pccbb_winset __P((bus_addr_t align, struct pccbb_softc *,
    bus_space_tag_t));
d195 1
a195 1
void	pccbb_pci_callback __P((struct device *));
d198 2
a199 2
void	cb_show_regs __P((pci_chipset_tag_t, pcitag_t, bus_space_tag_t,
    bus_space_handle_t memh));
d1276 1
a1276 1
	int (*func) __P((void *));
d1286 1
a1286 1
void cb_pcmcia_poll __P((void *arg));
d1608 1
a1608 1
 *					int (* func) __P((void *)),
d1621 1
a1621 1
	int (*func) __P((void *));
d1651 1
a1651 1
 *				     int (* func) __P((void *)),
d1664 1
a1664 1
	int (*func) __P((void *));
d2674 1
a2674 1
	int (*func) __P((void *));
d2685 1
a2685 1
void pccbb_pcmcia_poll __P((void *arg));
d2749 1
a2749 1
	int (*func) __P((void *));
@


1.27
log
@fix a // comment and kill a few trailing spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.26 2001/08/25 10:13:30 art Exp $ */
d294 2
@


1.26
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.25 2001/08/22 16:33:11 aaron Exp $ */
d269 1
a269 1
                              | ((prod) << PCI_PRODUCT_SHIFT))
d407 1
a407 1
	/* 
d435 1
a435 1
		 	}
d445 1
a445 1
	/* 
d452 1
a452 1
    		printf(": CardBus support disabled because of unconfigured bus number\n");
d516 1
a516 1
		/* 
d618 2
a619 2
	/* 
	 * attach cardbus 
d702 1
a702 1
	/* 
d712 1
a712 1
	/* 
d724 1
a724 1
	/* 
d980 1
a980 1
 
d1383 2
a1384 2
	/* 
	 * Reset Assert at least 20 ms 
d1688 1
a1688 1
	/* 
d1900 1
a1900 1
	/* 
d2238 1
a2238 1
	/* 
d2248 1
a2248 1
 
d2255 1
a2255 1
	/* 
d2334 1
a2334 1
	/* 
d2391 1
a2391 1
	/* 
d2611 1
a2611 1
	/* 
d2625 1
a2625 1
	/* 
d2722 1
a2722 1
//      printf("intr: reported from poller, 0x%x\n", spsr);
d2762 1
a2762 1
		/* 
@


1.26.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.28 2002/01/30 13:23:32 fgsch Exp $ */
d269 1
a269 1
				| ((prod) << PCI_PRODUCT_SHIFT))
a294 2
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1410), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
d407 1
a407 1
	/*
d435 1
a435 1
			}
d445 1
a445 1
	/*
d452 1
a452 1
		printf(": CardBus support disabled because of unconfigured bus number\n");
d516 1
a516 1
		/*
d618 2
a619 2
	/*
	 * attach cardbus
d702 1
a702 1
	/*
d712 1
a712 1
	/*
d724 1
a724 1
	/*
d980 1
a980 1

d1383 2
a1384 2
	/*
	 * Reset Assert at least 20 ms
d1688 1
a1688 1
	/*
d1900 1
a1900 1
	/*
d2238 1
a2238 1
	/*
d2248 1
a2248 1

d2255 1
a2255 1
	/*
d2334 1
a2334 1
	/*
d2391 1
a2391 1
	/*
d2611 1
a2611 1
	/*
d2625 1
a2625 1
	/*
d2722 1
a2722 1
	/* printf("intr: reported from poller, 0x%x\n", spsr); */
d2762 1
a2762 1
		/*
@


1.26.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.26.4.1 2002/01/31 22:55:35 niklas Exp $ */
d89 6
a94 6
int	pcicbbmatch(struct device *, void *, void *);
void	pccbbattach(struct device *, struct device *, void *);
int	pccbbintr(void *);
void	pccbb_shutdown(void *);
void	pci113x_insert(void *);
int	pccbbintr_function(struct pccbb_softc *);
d96 1
a96 1
int	pccbb_detect_card(struct pccbb_softc *);
d98 2
a99 2
void	pccbb_pcmcia_write(struct pcic_handle *, int, int);
u_int8_t pccbb_pcmcia_read(struct pcic_handle *, int);
d103 7
a109 7
int	cb_reset(struct pccbb_softc *);
int	cb_detect_voltage(struct pccbb_softc *);
int	cbbprint(void *, const char *);

int	cb_chipset(u_int32_t, int *);
void	pccbb_pcmcia_attach_setup(struct pccbb_softc *,
    struct pcmciabus_attach_args *);
d111 3
a113 3
void	pccbb_pcmcia_attach_card(struct pcic_handle *);
void	pccbb_pcmcia_detach_card(struct pcic_handle *, int);
void	pccbb_pcmcia_deactivate_card(struct pcic_handle *);
d116 3
a118 3
int	pccbb_ctrl(cardbus_chipset_tag_t, int);
int	pccbb_power(cardbus_chipset_tag_t, int);
int	pccbb_cardenable(struct pccbb_softc * sc, int function);
d120 4
a123 4
int	pccbb_io_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t);
int	pccbb_io_close(cardbus_chipset_tag_t, int);
int	pccbb_mem_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t);
int	pccbb_mem_close(cardbus_chipset_tag_t, int);
d125 41
a165 41
void   *pccbb_intr_establish(struct pccbb_softc *, int irq, int level,
    int (*ih) (void *), void *sc);
void	pccbb_intr_disestablish(struct pccbb_softc *, void *ih);

void   *pccbb_cb_intr_establish(cardbus_chipset_tag_t, int irq, int level,
    int (*ih) (void *), void *sc);
void	pccbb_cb_intr_disestablish(cardbus_chipset_tag_t ct, void *ih);

cardbustag_t pccbb_make_tag(cardbus_chipset_tag_t, int, int, int);
void	pccbb_free_tag(cardbus_chipset_tag_t, cardbustag_t);
cardbusreg_t pccbb_conf_read(cardbus_chipset_tag_t, cardbustag_t, int);
void	pccbb_conf_write(cardbus_chipset_tag_t, cardbustag_t, int,
    cardbusreg_t);
void	pccbb_chipinit(struct pccbb_softc *);

int	pccbb_pcmcia_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
    struct pcmcia_mem_handle *);
void	pccbb_pcmcia_mem_free(pcmcia_chipset_handle_t,
    struct pcmcia_mem_handle *);
int	pccbb_pcmcia_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t,
    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *);
void	pccbb_pcmcia_mem_unmap(pcmcia_chipset_handle_t, int);
int	pccbb_pcmcia_io_alloc(pcmcia_chipset_handle_t, bus_addr_t,
    bus_size_t, bus_size_t, struct pcmcia_io_handle *);
void	pccbb_pcmcia_io_free(pcmcia_chipset_handle_t,
    struct pcmcia_io_handle *);
int	pccbb_pcmcia_io_map(pcmcia_chipset_handle_t, int, bus_addr_t,
    bus_size_t, struct pcmcia_io_handle *, int *);
void	pccbb_pcmcia_io_unmap(pcmcia_chipset_handle_t, int);
void   *pccbb_pcmcia_intr_establish(pcmcia_chipset_handle_t,
    struct pcmcia_function *, int, int (*)(void *), void *, char *);
void	pccbb_pcmcia_intr_disestablish(pcmcia_chipset_handle_t,
    void *);
void	pccbb_pcmcia_socket_enable(pcmcia_chipset_handle_t);
void	pccbb_pcmcia_socket_disable(pcmcia_chipset_handle_t);
int	pccbb_pcmcia_card_detect(pcmcia_chipset_handle_t pch);

void	pccbb_pcmcia_do_io_map(struct pcic_handle *, int);
void	pccbb_pcmcia_wait_ready(struct pcic_handle *);
void	pccbb_pcmcia_do_mem_map(struct pcic_handle *, int);
void	pccbb_powerhook(int, void *);
d170 1
a170 1
int	pccbb_rbus_cb_space_alloc(cardbus_chipset_tag_t, rbus_tag_t,
d172 3
a174 3
    int flags, bus_addr_t * addrp, bus_space_handle_t * bshp);
int	pccbb_rbus_cb_space_free(cardbus_chipset_tag_t, rbus_tag_t,
    bus_space_handle_t, bus_size_t);
d180 10
a189 10
int	pccbb_open_win(struct pccbb_softc *, bus_space_tag_t,
    bus_addr_t, bus_size_t, bus_space_handle_t, int flags);
int	pccbb_close_win(struct pccbb_softc *, bus_space_tag_t,
    bus_space_handle_t, bus_size_t);
int	pccbb_winlist_insert(struct pccbb_win_chain_head *, bus_addr_t,
    bus_size_t, bus_space_handle_t, int);
int	pccbb_winlist_delete(struct pccbb_win_chain_head *,
    bus_space_handle_t, bus_size_t);
void	pccbb_winset(bus_addr_t align, struct pccbb_softc *,
    bus_space_tag_t);
d195 1
a195 1
void	pccbb_pci_callback(struct device *);
d198 2
a199 2
void	cb_show_regs(pci_chipset_tag_t, pcitag_t, bus_space_tag_t,
    bus_space_handle_t memh);
d1276 1
a1276 1
	int (*func)(void *);
d1286 1
a1286 1
void cb_pcmcia_poll(void *arg);
d1608 1
a1608 1
 *					int (* func)(void *),
d1621 1
a1621 1
	int (*func)(void *);
d1651 1
a1651 1
 *				     int (* func)(void *),
d1664 1
a1664 1
	int (*func)(void *);
d2674 1
a2674 1
	int (*func)(void *);
d2685 1
a2685 1
void pccbb_pcmcia_poll(void *arg);
d2749 1
a2749 1
	int (*func)(void *);
@


1.26.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.26.4.2 2002/06/11 03:42:26 art Exp $ */
d403 2
a404 2
	sc->sc_rbus_iot = rbus_pccbb_parent_io(self, pa);
	sc->sc_rbus_memt = rbus_pccbb_parent_mem(self, pa);
@


1.25
log
@Initialize auto variable (win[{0,1}].win_flags). Also, if PCCBB_MEM_CACHABLE
isn't set, clear the prefetchable bits in the bridge control register. These
fixes from NetBSD. Now OpenBSD won't hang when it tries to read the CIS from
an ADMtek-based card through a Ricoh-based PCI-CardBus bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.24 2001/08/19 15:25:44 mickey Exp $ */
d482 1
a482 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.24
log
@fetch sc_intline from pci_intr_line(ih) to accomodate for
the line being possibly resolved in pci_intr_map().
found and tested by jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.23 2001/08/19 15:11:26 miod Exp $ */
d3023 3
a3025 4
	win[0].win_start = 0xffffffff;
	win[0].win_limit = 0;
	win[1].win_start = 0xffffffff;
	win[1].win_limit = 0;
d3119 4
a3122 2
		if (win[0].win_flags & PCCBB_MEM_CACHABLE) {
			pcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);
d3124 1
a3124 4
			pci_conf_write(pc, tag, PCI_BCR_INTR, bcr);
		}
		if (win[1].win_flags & PCCBB_MEM_CACHABLE) {
			pcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);
d3126 1
a3126 2
			pci_conf_write(pc, tag, PCI_BCR_INTR, bcr);
		}
@


1.23
log
@...and convert this one as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.22 2001/08/17 21:52:16 deraadt Exp $ */
a475 2

	sc->sc_intrline = pa->pa_intrline;
d482 2
a483 2
	if (pci_intr_map(pc, sc->sc_intrtag, sc->sc_intrpin,
	    sc->sc_intrline, &ih)) {
d488 2
@


1.22
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.21 2001/06/20 23:12:11 niklas Exp $ */
d1283 1
d1297 2
a1298 1
	timeout(cb_pcmcia_poll, arg, hz / 10);
d2682 1
d2696 2
a2697 1
	timeout(pccbb_pcmcia_poll, arg, hz * 2);
@


1.21
log
@Comment spelling fix, and remove static regardless of
CBB_DEBUG setting
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.20 2001/06/12 15:40:32 niklas Exp $ */
d155 1
a155 1
    struct pcmcia_function *, int, int (*)(void *), void *));
d2740 1
a2740 1
pccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)
d2746 1
@


1.20
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.19 2001/05/16 12:51:49 ho Exp $ */
a84 1
#define STATIC
a86 1
#define STATIC static
d988 1
a988 1
		 * implimentation.
d1284 1
a1284 1
STATIC void cb_pcmcia_poll __P((void *arg));
d2681 1
a2681 1
STATIC void pccbb_pcmcia_poll __P((void *arg));
@


1.19
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.18 2001/05/01 02:19:46 mickey Exp $ */
d420 2
a421 1
		    &sc->sc_base_memt, &sc->sc_base_memh, &sockbase, NULL)) {
d428 3
a430 3
			if (pci_mapreg_map(pa, PCI_SOCKBASE, PCI_MAPREG_TYPE_IO,
			    0, &sc->sc_base_memt, &sc->sc_base_memh, &sockbase,
			    NULL)) {
d1286 1
a1286 1
static void cb_pcmcia_poll __P((void *arg));
d2683 1
a2683 1
static void pccbb_pcmcia_poll __P((void *arg));
@


1.18
log
@restore socket base addr and bus number on resume; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.17 2001/02/01 03:38:08 aaron Exp $ */
d1691 2
a1692 5
	if (NULL == (newpil =
	    (struct pccbb_intrhand_list *)malloc(sizeof(struct
	    pccbb_intrhand_list), M_DEVBUF, M_WAITOK))) {
		return NULL;
	}
@


1.18.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d475 2
d3159 8
@


1.18.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.18.2.1 2001/05/14 22:25:52 niklas Exp $ */
d85 1
d88 1
d420 1
a420 2
		    &sc->sc_base_memt, &sc->sc_base_memh, &sockbase, NULL, 0))
		    {
d427 3
a429 3
			if (pci_mapreg_map(pa, PCI_SOCKBASE,
			    PCI_MAPREG_TYPE_IO, 0, &sc->sc_base_memt,
			    &sc->sc_base_memh, &sockbase, NULL, 0)) {
a474 2
	sc->sc_sockbase = sock_base;
	sc->sc_busnum = busreg;
d987 1
a987 1
		 * implementation.
d1283 1
a1283 1
void cb_pcmcia_poll __P((void *arg));
d1689 5
a1693 2
	newpil = (struct pccbb_intrhand_list *)
		malloc(sizeof(struct pccbb_intrhand_list), M_DEVBUF, M_WAITOK);
d2683 1
a2683 1
void pccbb_pcmcia_poll __P((void *arg));
a3156 8
		if (pci_conf_read (sc->sc_pc, sc->sc_tag, PCI_SOCKBASE) == 0)
			/* BIOS did not recover this register */
			pci_conf_write (sc->sc_pc, sc->sc_tag,
					PCI_SOCKBASE, sc->sc_sockbase);
		if (pci_conf_read (sc->sc_pc, sc->sc_tag, PCI_BUSNUM) == 0)
			/* BIOS did not recover this register */
			pci_conf_write (sc->sc_pc, sc->sc_tag,
					PCI_BUSNUM, sc->sc_busnum);
@


1.18.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.18.2.2 2001/07/04 10:42:44 niklas Exp $ */
d155 1
a155 1
    struct pcmcia_function *, int, int (*)(void *), void *, char *));
d476 2
d484 2
a485 1
	if (pci_intr_map(pa, &ih)) {
a489 2
	/* must do this after intr is mapped and established */
	sc->sc_intrline = pci_intr_line(ih);
a1282 1
static struct timeout cb_poll_timeout;
d1296 1
a1296 2
	timeout_set(&cb_poll_timeout, cb_pcmcia_poll, arg);
	timeout_add(&cb_poll_timeout, hz / 10);
a2679 1
static struct timeout pccbb_poll_timeout;
d2693 1
a2693 2
	timeout_set(&pccbb_poll_timeout, pccbb_pcmcia_poll, arg);
	timeout_add(&pccbb_poll_timeout, hz * 2);
d2740 1
a2740 1
pccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg, xname)
a2745 1
	char *xname;
d3018 4
a3021 3
	win[0].win_start = win[1].win_start = 0xffffffff;
	win[0].win_limit = win[1].win_limit = 0;
	win[0].win_flags = win[1].win_flags = 0;
d3115 2
a3116 4
		pcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);

		bcr &= ~(CB_BCR_PREFETCH_MEMWIN0 | CB_BCR_PREFETCH_MEMWIN1);
		if (win[0].win_flags & PCCBB_MEM_CACHABLE)
d3118 4
a3121 1
		if (win[1].win_flags & PCCBB_MEM_CACHABLE)
d3123 2
a3124 1
		pci_conf_write(pc, tag, PCI_BCR_INTR, bcr);
@


1.18.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d269 1
a269 1
				| ((prod) << PCI_PRODUCT_SHIFT))
a294 2
	{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1410), CB_TI12XX,
	    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},
d407 1
a407 1
	/*
d435 1
a435 1
			}
d445 1
a445 1
	/*
d452 1
a452 1
		printf(": CardBus support disabled because of unconfigured bus number\n");
d516 1
a516 1
		/*
d618 2
a619 2
	/*
	 * attach cardbus
d702 1
a702 1
	/*
d712 1
a712 1
	/*
d724 1
a724 1
	/*
d980 1
a980 1

d1383 2
a1384 2
	/*
	 * Reset Assert at least 20 ms
d1688 1
a1688 1
	/*
d1900 1
a1900 1
	/*
d2238 1
a2238 1
	/*
d2248 1
a2248 1

d2255 1
a2255 1
	/*
d2334 1
a2334 1
	/*
d2391 1
a2391 1
	/*
d2611 1
a2611 1
	/*
d2625 1
a2625 1
	/*
d2722 1
a2722 1
	/* printf("intr: reported from poller, 0x%x\n", spsr); */
d2762 1
a2762 1
		/*
@


1.18.2.5
log
@Merge in -current from roughly a week ago
@
text
@d89 6
a94 6
int	pcicbbmatch(struct device *, void *, void *);
void	pccbbattach(struct device *, struct device *, void *);
int	pccbbintr(void *);
void	pccbb_shutdown(void *);
void	pci113x_insert(void *);
int	pccbbintr_function(struct pccbb_softc *);
d96 1
a96 1
int	pccbb_detect_card(struct pccbb_softc *);
d98 2
a99 2
void	pccbb_pcmcia_write(struct pcic_handle *, int, int);
u_int8_t pccbb_pcmcia_read(struct pcic_handle *, int);
d103 7
a109 7
int	cb_reset(struct pccbb_softc *);
int	cb_detect_voltage(struct pccbb_softc *);
int	cbbprint(void *, const char *);

int	cb_chipset(u_int32_t, int *);
void	pccbb_pcmcia_attach_setup(struct pccbb_softc *,
    struct pcmciabus_attach_args *);
d111 3
a113 3
void	pccbb_pcmcia_attach_card(struct pcic_handle *);
void	pccbb_pcmcia_detach_card(struct pcic_handle *, int);
void	pccbb_pcmcia_deactivate_card(struct pcic_handle *);
d116 3
a118 3
int	pccbb_ctrl(cardbus_chipset_tag_t, int);
int	pccbb_power(cardbus_chipset_tag_t, int);
int	pccbb_cardenable(struct pccbb_softc * sc, int function);
d120 4
a123 4
int	pccbb_io_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t);
int	pccbb_io_close(cardbus_chipset_tag_t, int);
int	pccbb_mem_open(cardbus_chipset_tag_t, int, u_int32_t, u_int32_t);
int	pccbb_mem_close(cardbus_chipset_tag_t, int);
d125 41
a165 41
void   *pccbb_intr_establish(struct pccbb_softc *, int irq, int level,
    int (*ih) (void *), void *sc);
void	pccbb_intr_disestablish(struct pccbb_softc *, void *ih);

void   *pccbb_cb_intr_establish(cardbus_chipset_tag_t, int irq, int level,
    int (*ih) (void *), void *sc);
void	pccbb_cb_intr_disestablish(cardbus_chipset_tag_t ct, void *ih);

cardbustag_t pccbb_make_tag(cardbus_chipset_tag_t, int, int, int);
void	pccbb_free_tag(cardbus_chipset_tag_t, cardbustag_t);
cardbusreg_t pccbb_conf_read(cardbus_chipset_tag_t, cardbustag_t, int);
void	pccbb_conf_write(cardbus_chipset_tag_t, cardbustag_t, int,
    cardbusreg_t);
void	pccbb_chipinit(struct pccbb_softc *);

int	pccbb_pcmcia_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
    struct pcmcia_mem_handle *);
void	pccbb_pcmcia_mem_free(pcmcia_chipset_handle_t,
    struct pcmcia_mem_handle *);
int	pccbb_pcmcia_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t,
    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *);
void	pccbb_pcmcia_mem_unmap(pcmcia_chipset_handle_t, int);
int	pccbb_pcmcia_io_alloc(pcmcia_chipset_handle_t, bus_addr_t,
    bus_size_t, bus_size_t, struct pcmcia_io_handle *);
void	pccbb_pcmcia_io_free(pcmcia_chipset_handle_t,
    struct pcmcia_io_handle *);
int	pccbb_pcmcia_io_map(pcmcia_chipset_handle_t, int, bus_addr_t,
    bus_size_t, struct pcmcia_io_handle *, int *);
void	pccbb_pcmcia_io_unmap(pcmcia_chipset_handle_t, int);
void   *pccbb_pcmcia_intr_establish(pcmcia_chipset_handle_t,
    struct pcmcia_function *, int, int (*)(void *), void *, char *);
void	pccbb_pcmcia_intr_disestablish(pcmcia_chipset_handle_t,
    void *);
void	pccbb_pcmcia_socket_enable(pcmcia_chipset_handle_t);
void	pccbb_pcmcia_socket_disable(pcmcia_chipset_handle_t);
int	pccbb_pcmcia_card_detect(pcmcia_chipset_handle_t pch);

void	pccbb_pcmcia_do_io_map(struct pcic_handle *, int);
void	pccbb_pcmcia_wait_ready(struct pcic_handle *);
void	pccbb_pcmcia_do_mem_map(struct pcic_handle *, int);
void	pccbb_powerhook(int, void *);
d170 1
a170 1
int	pccbb_rbus_cb_space_alloc(cardbus_chipset_tag_t, rbus_tag_t,
d172 3
a174 3
    int flags, bus_addr_t * addrp, bus_space_handle_t * bshp);
int	pccbb_rbus_cb_space_free(cardbus_chipset_tag_t, rbus_tag_t,
    bus_space_handle_t, bus_size_t);
d180 10
a189 10
int	pccbb_open_win(struct pccbb_softc *, bus_space_tag_t,
    bus_addr_t, bus_size_t, bus_space_handle_t, int flags);
int	pccbb_close_win(struct pccbb_softc *, bus_space_tag_t,
    bus_space_handle_t, bus_size_t);
int	pccbb_winlist_insert(struct pccbb_win_chain_head *, bus_addr_t,
    bus_size_t, bus_space_handle_t, int);
int	pccbb_winlist_delete(struct pccbb_win_chain_head *,
    bus_space_handle_t, bus_size_t);
void	pccbb_winset(bus_addr_t align, struct pccbb_softc *,
    bus_space_tag_t);
d195 1
a195 1
void	pccbb_pci_callback(struct device *);
d198 2
a199 2
void	cb_show_regs(pci_chipset_tag_t, pcitag_t, bus_space_tag_t,
    bus_space_handle_t memh);
d1276 1
a1276 1
	int (*func)(void *);
d1286 1
a1286 1
void cb_pcmcia_poll(void *arg);
d1608 1
a1608 1
 *					int (* func)(void *),
d1621 1
a1621 1
	int (*func)(void *);
d1651 1
a1651 1
 *				     int (* func)(void *),
d1664 1
a1664 1
	int (*func)(void *);
d2674 1
a2674 1
	int (*func)(void *);
d2685 1
a2685 1
void pccbb_pcmcia_poll(void *arg);
d2749 1
a2749 1
	int (*func)(void *);
@


1.18.2.6
log
@Sync the SMP branch with 3.3
@
text
@d403 2
a404 2
	sc->sc_rbus_iot = rbus_pccbb_parent_io(self, pa);
	sc->sc_rbus_memt = rbus_pccbb_parent_mem(self, pa);
@


1.18.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a771 24

	case CB_TOPIC97:
		reg = pci_conf_read(pc, tag, TOPIC_SLOT_CTRL);
		DPRINTF(("%s: topic slot ctrl reg 0x%x -> ",
		    sc->sc_dev.dv_xname, reg));
		reg |= (TOPIC_SLOT_CTRL_SLOTON | TOPIC_SLOT_CTRL_SLOTEN |
		    TOPIC_SLOT_CTRL_ID_LOCK | TOPIC_SLOT_CTRL_CARDBUS);
		reg &= ~TOPIC_SLOT_CTRL_SWDETECT;
		reg |= TOPIC97_SLOT_CTRL_PCIINT;
		reg &= ~(TOPIC97_SLOT_CTRL_STSIRQP | TOPIC97_SLOT_CTRL_IRQP);
		DPRINTF(("0x%x\n", reg));
		pci_conf_write(pc, tag, TOPIC_SLOT_CTRL, reg);

		/* make sure to assert LV card support bits */
		bus_space_write_1(sc->sc_base_memt, sc->sc_base_memh,
		    0x800 + 0x3e, bus_space_read_1(sc->sc_base_memt,
		    sc->sc_base_memh, 0x800 + 0x3e) | 0x03);

		/* Power on the controller if the BIOS didn't */
		reg = pci_conf_read(pc, tag, TOPIC100_PMCSR);
		if ((reg & TOPIC100_PMCSR_MASK) != TOPIC100_PMCSR_D0)
			pci_conf_write(pc, tag, TOPIC100_PMCSR,
			    (reg & ~TOPIC100_PMCSR_MASK) | TOPIC100_PMCSR_D0);
		break;
a1002 1
#ifdef IPL_IMP
a1004 1
#endif
@


1.17
log
@Do not attempt to attach cards that have unsupported (i.e., non-5, non-3)
voltages. Fixes the problem with those silly SCM Microsystems PCI-CardBus
dock boards that are often shipped with Lucent WaveLAN cards. Thanks to
drahn@@openbsd.org for testing and dave@@arbor.net for originally reporting
the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.16 2001/01/27 04:44:20 mickey Exp $ */
d475 2
d3159 8
@


1.16
log
@introduce and use a flag indicating that interrupts are
enabled for this cbb. essentially this means that cbb
driver has completed it's initialization and is
ready to treat interrupts. this was exposed by
ccb's sharing their interrupt and pccbbintr() being called
for cbb which has not completed attachment due
to interrupt sharing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.15 2001/01/22 18:53:57 deraadt Exp $ */
d1346 9
@


1.15
log
@repair printing
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.14 2001/01/21 02:37:07 mickey Exp $ */
d668 2
d903 3
@


1.14
log
@map and establish interrupt earlier in the attach routine,
instead of middle of the thread. behaviour remains the same.
since interrupts are disabled in the controller until proper
time this is safe to do this way.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.13 2000/12/06 17:08:27 aaron Exp $ */
d505 1
a505 1
	printf(" %s\n", intrstr);
@


1.13
log
@BUG FIX: change enable sequence for 16-bit pcmcia cards.  This change
provides better (not perfect) reset sequence.  The most significant
change is asserting output enable reg before power up.  Stop routing
interrupt during reset.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.12 2000/11/29 22:57:16 aaron Exp $ */
d388 2
a445 12
	printf("\n");

	/* 
	 * When interrupt isn't routed correctly, give up probing cbb and do
	 * not kill pcic-compatible port.
	 */
	if ((0 == pa->pa_intrline) || (255 == pa->pa_intrline)) {
    		printf("%s: NOT USED because of unconfigured interrupt\n",
		    sc->sc_dev.dv_xname);
		return;
	}

d453 1
a453 2
    		printf("%s: CardBus support disabled because of unconfigured bus number\n",
		    sc->sc_dev.dv_xname);
d463 1
a463 1
		printf("%s: intrpin %s, intrtag %d\n", sc->sc_dev.dv_xname,
d482 25
a560 2
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
a606 26

	/* Map and establish the interrupt. */
	if (pci_intr_map(pc, sc->sc_intrtag, sc->sc_intrpin,
	    sc->sc_intrline, &ih)) {
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
		return;
	}
	intrstr = pci_intr_string(pc, ih);

	/*
	 * XXX pccbbintr should be called under the priority lower
	 * than any other hard interrputs.
	 */
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, pccbbintr, sc,
	    sc->sc_dev.dv_xname);

	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
		if (intrstr != NULL) {
			printf(" at %s", intrstr);
		}
		printf("\n");
		return;
	}
	printf("%s: %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.12
log
@Bugfix: reset 16-bit pcmcia in chip initialisation sequence; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.11 2000/11/29 21:31:27 aaron Exp $ */
d750 1
a750 1
	reg &= ~CB_BCR_INTR_IREQ_ENABLE;	/* use PCI Intr */
d1079 3
d1092 3
a1230 7
	delay(20 * 1000);	       /* wait 20 ms: Vcc setup time */
	/*
	 * XXX delay 200 ms: though the standard defines that the Vcc set-up
	 * time is 20 ms, some PC-Card bridge requires longer duration.
	 */
	delay(200 * 1000);

d1270 7
d1664 1
d1670 3
d1676 5
a1680 10
			{
				pcireg_t cbctrl =
				    pci_conf_read(sc->sc_pc, sc->sc_tag,
				    PCI_CBCTRL);
				/* functional intr enabled */
				cbctrl |= PCI113X_CBCTRL_PCI_INTR;
				pci_conf_write(sc->sc_pc, sc->sc_tag,
				    PCI_CBCTRL, cbctrl);
				break;
			}
d1725 1
d1746 5
d1753 5
a1757 10
			{
				pcireg_t cbctrl =
				    pci_conf_read(sc->sc_pc, sc->sc_tag,
				    PCI_CBCTRL);
				/* functional intr disabled */
				cbctrl &= ~PCI113X_CBCTRL_PCI_INTR;
				pci_conf_write(sc->sc_pc, sc->sc_tag,
				    PCI_CBCTRL, cbctrl);
				break;
			}
a2229 5
	/* assert reset bit */
	intr = Pcic_read(ph, PCIC_INTR);
	intr &= ~(PCIC_INTR_RESET | PCIC_INTR_CARDTYPE_MASK);
	Pcic_write(ph, PCIC_INTR, intr);

d2232 1
a2232 2
	power = Pcic_read(ph, PCIC_PWRCTL);
	power &= ~PCIC_PWRCTL_OE;
d2245 6
a2250 12
	/* power up the socket */
	pccbb_power(sc, voltage);

	/* 
	 * wait 100ms until power raise (Tpr) and 20ms to become
	 * stable (Tsu(Vcc)).
	 *
	 * some machines require some more time to be settled
	 * (another 200ms is added here).
	 */
	/* delay((100 + 20 + 200)*1000); too much */

d2254 1
@


1.11
log
@Correct PCI interrupt setup routine for Texas Instruments PCI113X CardBus
bridges so that hot insertion and removal works; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.10 2000/11/29 21:25:18 aaron Exp $ */
d752 1
d793 9
@


1.10
log
@Clarify that the RX5C57X requires write to the PCI_LEGACY to disable and
not PCI_BCR_INTR; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.9 2000/11/29 21:18:14 aaron Exp $ */
d762 2
a763 2
		/* functional intr prohibit */
		reg &= ~PCI113X_CBCTRL_PCI_INTR;
d837 6
a842 2
	Pcic_write(ph, PCIC_CSC_INTR, PCIC_CSC_INTR_CD_ENABLE);
	Pcic_read(ph, PCIC_CSC);
@


1.9
log
@Power down PC cards at shutdown time; from NetBSD. I'm also reverting my own
fix for this (rev 1.7) as this is the better way to do it. This fixes the
problem seen with reboot while an xl(4) CardBus card is in a slot on my Toshiba
Tecra 550CDT (so it should fix the same problem espie@@ has seen on a different
model Toshiba laptop).
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.8 2000/10/09 17:31:04 aaron Exp $ */
d499 1
d503 4
a506 4
		 * The legacy pcic io-port on Ricoh CardBus bridges cannot be
		 * disabled by substituting 0 into PCI_LEGACY register.  Ricoh
		 * CardBus bridges have special bits on Bridge control reg (addr
		 * 0x3e on PCI config space).
@


1.8
log
@Defer most of the attach process as recommended in the comments; mickey@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.7 2000/09/24 23:10:48 aaron Exp $ */
d364 4
a375 5

	if (sc->sc_chipset == CB_TOPIC95B) {
		pci_conf_write(sc->sc_pc, sc->sc_tag, TOPIC_SOCKET_CTRL, 0);
		pci_conf_write(sc->sc_pc, sc->sc_tag, TOPIC_SLOT_CTRL, 0);
	}
@


1.7
log
@For the Toshiba TOPIC95B CardBus controller, we must clear the socket and slot
control registers at shutdown else we hang. Fixes it on my laptop, should help
out espie@@ on his Toshiba system too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.6 2000/07/25 00:04:59 mickey Exp $ */
d388 1
a388 1
	pcireg_t sock_base, busreg;
d445 2
d452 1
a452 1
    		printf("\n%s: NOT USED because of unconfigured interrupt\n",
d496 23
a519 1
#if 0
a520 2
#endif
	pccbb_pci_callback(self);
d620 1
a620 1
	printf(": %s\n", intrstr);
d703 2
a704 3
 *     3) disable legacy (PCIC-compatible) io,
 *     4) route PCI interrupt,
 *     5) close all memory and io windows.
a746 23

	/* Disable legacy register mapping. */
	switch (sc->sc_chipset) {
	case CB_RX5C46X:	       /* fallthrough */
#if 0
	case CB_RX5C47X:
#endif
		/* 
		 * The legacy pcic io-port on Ricoh CardBus bridges cannot be
		 * disabled by substituting 0 into PCI_LEGACY register.  Ricoh
		 * CardBus bridges have special bits on Bridge control reg (addr
		 * 0x3e on PCI config space).
		 */
		reg = pci_conf_read(pc, tag, PCI_BCR_INTR);
		reg &= ~(CB_BCRI_RL_3E0_ENA | CB_BCRI_RL_3E2_ENA);
		pci_conf_write(pc, tag, PCI_BCR_INTR, reg);
		break;

	default:
		/* XXX I don't know proper way to kill legacy I/O. */
		pci_conf_write(pc, tag, PCI_LEGACY, 0x0);
		break;
	}
@


1.6
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.5 2000/07/06 19:49:10 aaron Exp $ */
d373 4
@


1.5
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.4 2000/07/06 06:03:01 aaron Exp $ */
d490 1
d950 1
a950 1
				untimeout(pci113x_insert, sc);
d952 1
a952 1
			timeout(pci113x_insert, sc, hz / 10);
d1053 1
a1053 1
		timeout(pci113x_insert, sc, hz / 10);
@


1.4
log
@Reorder irq enabling and vector setup; makes Ricoh-based PCI-CardBus bridges
behave more nicely. Also remove statics. From niklas@@
@
text
@d1 2
a2 2
/*	$OpenBSD: pccbb.c,v 1.3 2000/04/26 14:57:39 aaron Exp $ */
/*	$NetBSD: pccbb.c,v 1.37 2000/03/23 07:01:40 thorpej Exp $	*/
d348 1
a348 1
		if (pci_id != yc->yc_id)
d565 4
d576 5
d905 5
a909 1
		return (pccbbintr_function(sc));
d971 42
a1013 2
	for (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {
		val = (*pil->pil_func) (pil->pil_arg);
d1366 2
a1367 1
	bcr |= (0x40 << 16);	       /* Reset bit Assert (bit 6 at 0x3E) */
d1372 2
a1373 1
		bcr &= ~(0x40 << 16);  /* Reset bit Deassert (bit 6 at 0x3E) */
d1588 1
a1588 1
 *   The arguments irq and level are not used.
d1675 1
d3132 12
d3160 6
@


1.3
log
@Remove one of my completely incomprehensible debugging printf's.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.2 2000/04/20 21:15:23 aaron Exp $ */
d91 6
a96 5
int pcicbbmatch __P((struct device *, void *, void *));
void pccbbattach __P((struct device *, struct device *, void *));
int pccbbintr __P((void *));
static void pci113x_insert __P((void *));
static int pccbbintr_function __P((struct pccbb_softc *));
d98 1
a98 1
static int pccbb_detect_card __P((struct pccbb_softc *));
d100 2
a101 2
static void pccbb_pcmcia_write __P((struct pcic_handle *, int, int));
static u_int8_t pccbb_pcmcia_read __P((struct pcic_handle *, int));
d105 3
a107 3
STATIC int cb_reset __P((struct pccbb_softc *));
STATIC int cb_detect_voltage __P((struct pccbb_softc *));
STATIC int cbbprint __P((void *, const char *));
d109 2
a110 2
static int cb_chipset __P((u_int32_t, int *));
STATIC void pccbb_pcmcia_attach_setup __P((struct pccbb_softc *,
d113 3
a115 3
STATIC void pccbb_pcmcia_attach_card __P((struct pcic_handle *));
STATIC void pccbb_pcmcia_detach_card __P((struct pcic_handle *, int));
STATIC void pccbb_pcmcia_deactivate_card __P((struct pcic_handle *));
d118 3
a120 3
STATIC int pccbb_ctrl __P((cardbus_chipset_tag_t, int));
STATIC int pccbb_power __P((cardbus_chipset_tag_t, int));
STATIC int pccbb_cardenable __P((struct pccbb_softc * sc, int function));
d122 4
a125 6
static int pccbb_io_open __P((cardbus_chipset_tag_t, int, u_int32_t,
    u_int32_t));
static int pccbb_io_close __P((cardbus_chipset_tag_t, int));
static int pccbb_mem_open __P((cardbus_chipset_tag_t, int, u_int32_t,
    u_int32_t));
static int pccbb_mem_close __P((cardbus_chipset_tag_t, int));
d127 12
a138 13
static void *pccbb_intr_establish __P((struct pccbb_softc *, int irq,
    int level, int (*ih) (void *), void *sc));
static void pccbb_intr_disestablish __P((struct pccbb_softc *, void *ih));

static void *pccbb_cb_intr_establish __P((cardbus_chipset_tag_t, int irq,
    int level, int (*ih) (void *), void *sc));
static void pccbb_cb_intr_disestablish __P((cardbus_chipset_tag_t ct, void *ih));

static cardbustag_t pccbb_make_tag __P((cardbus_chipset_tag_t, int, int, int));
static void pccbb_free_tag __P((cardbus_chipset_tag_t, cardbustag_t));
static cardbusreg_t pccbb_conf_read __P((cardbus_chipset_tag_t, cardbustag_t,
    int));
static void pccbb_conf_write __P((cardbus_chipset_tag_t, cardbustag_t, int,
d140 1
a140 1
static void pccbb_chipinit __P((struct pccbb_softc *));
d142 1
a142 1
STATIC int pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,
d144 1
a144 1
STATIC void pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,
d146 1
a146 1
STATIC int pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,
d148 2
a149 2
STATIC void pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));
STATIC int pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,
d151 1
a151 1
STATIC void pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,
d153 1
a153 1
STATIC int pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,
d155 2
a156 2
STATIC void pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));
STATIC void *pccbb_pcmcia_intr_establish __P((pcmcia_chipset_handle_t,
d158 1
a158 1
STATIC void pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,
d160 8
a167 8
STATIC void pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));
STATIC void pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));
STATIC int pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));

static void pccbb_pcmcia_do_io_map __P((struct pcic_handle *, int));
static void pccbb_pcmcia_wait_ready __P((struct pcic_handle *));
static void pccbb_pcmcia_do_mem_map __P((struct pcic_handle *, int));
static void pccbb_powerhook __P((int, void *));
d172 1
a172 1
static int pccbb_rbus_cb_space_alloc __P((cardbus_chipset_tag_t, rbus_tag_t,
d175 1
a175 1
static int pccbb_rbus_cb_space_free __P((cardbus_chipset_tag_t, rbus_tag_t,
d182 1
a182 1
static int pccbb_open_win __P((struct pccbb_softc *, bus_space_tag_t,
d184 1
a184 1
static int pccbb_close_win __P((struct pccbb_softc *, bus_space_tag_t,
d186 1
a186 1
static int pccbb_winlist_insert __P((struct pccbb_win_chain_head *, bus_addr_t,
d188 1
a188 1
static int pccbb_winlist_delete __P((struct pccbb_win_chain_head *,
d190 1
a190 1
static void pccbb_winset __P((bus_addr_t align, struct pccbb_softc *,
d192 1
a192 1
void pccbb_winlist_show(struct pccbb_win_chain *);
d197 1
a197 1
static void pccbb_pci_callback __P((struct device *));
d200 2
a201 2
static void cb_show_regs __P((pci_chipset_tag_t pc, pcitag_t tag,
    bus_space_tag_t memt, bus_space_handle_t memh));
d338 1
a338 1
static int
d357 1
a357 1
static void
d500 1
a500 1
 * static void pccbb_pci_callback(struct device *self)
d511 1
a511 1
static void
a564 8
	/* CSC Interrupt: Card detect interrupt on */
	maskreg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);
	maskreg |= CB_SOCKET_MASK_CD;  /* Card detect intr is turned on. */
	bus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, maskreg);
	/* reset interrupt */
	bus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT,
	    bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT));

d576 2
a577 1
		printf("%s: couldn't establish interrupt", sc->sc_dev.dv_xname);
d584 1
a585 1
	printf(": %s\n", intrstr);
d646 8
d662 1
a662 1
 * static void pccbb_chipinit(struct pccbb_softc *sc)
d671 1
a671 1
static void
d786 1
a786 1
 * STATIC void pccbb_pcmcia_attach_setup(struct pccbb_softc *sc,
d791 1
a791 1
STATIC void
d844 1
a844 1
STATIC void
d858 1
a858 1
STATIC void
d947 1
a947 1
 * static int pccbbintr_function(struct pccbb_softc *sc)
d952 1
a952 1
static int
d968 1
a968 1
static void
d1004 1
a1004 1
static u_int8_t
d1013 1
a1013 1
static void
d1024 1
a1024 1
 * STATIC int pccbb_ctrl(cardbus_chipset_tag_t, int)
d1026 1
a1026 1
STATIC int
d1072 1
a1072 1
 * STATIC int pccbb_power(cardbus_chipset_tag_t, int)
d1076 1
a1076 1
STATIC int
d1218 1
a1218 1
static void
d1265 1
a1265 1
 * static int pccbb_detect_card(struct pccbb_softc *sc)
d1270 1
a1270 1
static int
d1298 1
a1298 1
 * STATIC int cb_reset(struct pccbb_softc *sc)
d1301 1
a1301 1
STATIC int
d1327 1
a1327 1
 * STATIC int cb_detect_voltage(struct pccbb_softc *sc)
d1330 1
a1330 1
STATIC int
d1351 1
a1351 1
STATIC int
d1367 1
a1367 1
 * STATIC int pccbb_cardenable(struct pccbb_softc *sc, int function)
d1370 1
a1370 1
STATIC int
d1411 1
a1411 1
static int
d1442 1
a1442 1
static int
d1469 1
a1469 1
static int
d1497 1
a1497 1
static int
d1523 1
a1523 1
 * static void *pccbb_cb_intr_establish(cardbus_chipset_tag_t ct,
d1535 1
a1535 1
static void *
d1549 1
a1549 1
 * static void *pccbb_cb_intr_disestablish(cardbus_chipset_tag_t ct,
d1554 1
a1554 1
static void
d1566 1
a1566 1
 * static void *pccbb_intr_establish(struct pccbb_softc *sc,
d1578 1
a1578 1
static void *
d1636 1
a1636 1
 * static void *pccbb_intr_disestablish(struct pccbb_softc *sc,
d1641 1
a1641 1
static void
d1686 1
a1686 1
static void
d1727 1
a1727 1
 * static cardbustag_t pccbb_make_tag(cardbus_chipset_tag_t cc,
d1732 1
a1732 1
static cardbustag_t
d1742 1
a1742 1
static void
d1750 1
a1750 1
 * static cardbusreg_t pccbb_conf_read(cardbus_chipset_tag_t cc,
d1755 1
a1755 1
static cardbusreg_t
d1767 1
a1767 1
 * static void pccbb_conf_write(cardbus_chipset_tag_t cc, cardbustag_t tag,
d1772 1
a1772 1
static void
d1785 1
a1785 1
STATIC int
d1792 1
a1792 1
 * STATIC int pccbb_pcmcia_io_alloc(pcmcia_chipset_handle_t pch,
d1802 1
a1802 1
STATIC int
d1865 1
a1865 1
 * STATIC int pccbb_pcmcia_io_free(pcmcia_chipset_handle_t pch,
d1898 1
a1898 1
 * STATIC int pccbb_pcmcia_io_map(pcmcia_chipset_handle_t pch, int width,
d1974 1
a1974 1
 * STATIC void pccbb_pcmcia_do_io_map(struct pcic_handle *h, int win)
d1978 1
a1978 1
static void
d2052 1
a2052 1
 * STATIC void pccbb_pcmcia_io_unmap(pcmcia_chipset_handle_t *h, int win)
d2056 1
a2056 1
STATIC void
d2083 1
a2083 1
 * static void pccbb_pcmcia_wait_ready(struct pcic_handle *ph)
d2088 1
a2088 1
static void
d2115 1
a2115 1
 * STATIC void pccbb_pcmcia_socket_enable(pcmcia_chipset_handle_t pch)
d2120 1
a2120 1
STATIC void
d2240 1
a2240 1
 * STATIC void pccbb_pcmcia_socket_disable(pcmcia_chipset_handle_t *ph)
d2245 1
a2245 1
STATIC void
d2274 1
a2274 1
 * STATIC int pccbb_pcmcia_card_detect(pcmcia_chipset_handle_t *ph)
d2279 1
a2279 1
STATIC int
d2291 1
a2291 1
STATIC int
d2297 1
a2297 1
 * STATIC int pccbb_pcmcia_mem_alloc(pcmcia_chipset_handle_t pch,
d2306 1
a2306 1
STATIC int
d2375 1
a2375 1
 * STATIC void pccbb_pcmcia_mem_free(pcmcia_chipset_handle_t pch,
d2381 1
a2381 1
STATIC void
d2397 1
a2397 1
 * STATIC void pccbb_pcmcia_do_mem_map(struct pcic_handle *ph, int win)
d2402 1
a2402 1
STATIC void
d2500 1
a2500 1
 * STATIC int pccbb_pcmcia_mem_map(pcmcia_chipset_handle_t pch, int kind,
d2508 1
a2508 1
STATIC int
d2577 1
a2577 1
 * STATIC int pccbb_pcmcia_mem_unmap(pcmcia_chipset_handle_t pch,
d2583 1
a2583 1
STATIC void
d2617 1
a2617 1
static void
d2665 1
a2665 1
 * STATIC void *pccbb_pcmcia_intr_establish(pcmcia_chipset_handle_t pch,
d2673 1
a2673 1
STATIC void *
d2702 1
a2702 1
 * STATIC void pccbb_pcmcia_intr_disestablish(pcmcia_chipset_handle_t pch,
d2707 1
a2707 1
STATIC void
d2720 1
a2720 1
 * static int
d2730 1
a2730 1
static int
d2785 1
a2785 1
 * static int
d2791 1
a2791 1
static int
d2816 1
a2816 1
static int
d2847 1
a2847 1
static int
d2874 1
a2874 1
static int
d2905 1
a2905 1
static int
d2935 1
a2935 1
static void
d3064 1
a3064 1
static void
@


1.2
log
@Fix function prototype so it compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccbb.c,v 1.1 2000/04/08 05:50:51 aaron Exp $ */
a430 1
				printf("***** HOI!\n");
@


1.1
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d99 1
a99 1
static void pccbb_pcmcia_write __P((struct pcic_handle *, int, u_int8_t));
a2425 5
	int kind = ph->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;
	int mem8 =
	    (ph->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8
	    || (kind == PCMCIA_MEM_ATTR);

d2442 1
a2442 1
	    |(mem8 ? 0 : PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT);
d2465 1
a2465 1
	    | ((kind == PCMCIA_MEM_ATTR) ?
@

