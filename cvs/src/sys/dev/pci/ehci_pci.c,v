head	1.30;
access;
symbols
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.27.0.8
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.6
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.30
date	2016.07.20.09.48.06;	author mpi;	state Exp;
branches;
next	1.29;
commitid	Hguddd2oJVbTACZE;

1.29
date	2015.11.09.10.01.17;	author mpi;	state Exp;
branches;
next	1.28;
commitid	3KwSCM1U7UXVjep9;

1.28
date	2015.11.02.14.55.41;	author mpi;	state Exp;
branches;
next	1.27;
commitid	vJlf2yHM5thwrjmA;

1.27
date	2014.05.16.18.17.03;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2012.10.20.19.13.25;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.26.00.37.34;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.20.20.34.19;	author mk;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.08.04.19.24;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.29.22.14.57;	author mlarkin;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.24.03.18.58;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.23.19.42.02;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.25.01.01.44;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.09.19.03.54;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.20.00.52.26;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.25.04.17.00;	author pascoe;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.10.07.54.43;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.30.03.43.04;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.11.08.09.32;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.07.11.12.04;	author pascoe;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.29.01.52.27;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.30.01.25.17;	author tedu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.05.24.22.52.52;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.23.03.23.00;	author deraadt;	state Exp;
branches;
next	;

1.3.2.1
date	2004.06.05.23.12.49;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.30
log
@ATI controllers seem to need the same workaround as VIA controllers.

This should hopefully help people reporting errors with SB700.

From FreeBSD, ok kettenis@@, krw@@
@
text
@/*	$OpenBSD: ehci_pci.c,v 1.29 2015/11/09 10:01:17 mpi Exp $ */
/*	$NetBSD: ehci_pci.c,v 1.15 2004/04/23 21:13:06 itojun Exp $	*/

/*
 * Copyright (c) 2001, 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/queue.h>

#include <machine/bus.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#include <dev/usb/ehcireg.h>
#include <dev/usb/ehcivar.h>

#ifdef EHCI_DEBUG
#define DPRINTF(x)	if (ehcidebug) printf x
extern int ehcidebug;
#else
#define DPRINTF(x)
#endif

struct ehci_pci_softc {
	struct ehci_softc	sc;
	pci_chipset_tag_t	sc_pc;
	pcitag_t		sc_tag;
	void 			*sc_ih;		/* interrupt vectoring */
};

int ehci_sb700_match(struct pci_attach_args *pa);

#define EHCI_SBx00_WORKAROUND_REG	0x50
#define EHCI_SBx00_WORKAROUND_ENABLE	(1 << 3)
#define EHCI_VT6202_WORKAROUND_REG	0x48

int	ehci_pci_match(struct device *, void *, void *);
void	ehci_pci_attach(struct device *, struct device *, void *);
int	ehci_pci_detach(struct device *, int);
int	ehci_pci_activate(struct device *, int);
#if 0
void	ehci_pci_givecontroller(struct ehci_pci_softc *);
#endif
void	ehci_pci_takecontroller(struct ehci_pci_softc *, int);

struct cfattach ehci_pci_ca = {
	sizeof(struct ehci_pci_softc), ehci_pci_match, ehci_pci_attach,
	ehci_pci_detach, ehci_pci_activate
};

int
ehci_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_SERIALBUS &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_SERIALBUS_USB &&
	    PCI_INTERFACE(pa->pa_class) == PCI_INTERFACE_EHCI)
		return (1);
 
	return (0);
}

void
ehci_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct ehci_pci_softc *sc = (struct ehci_pci_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	char const *intrstr;
	pci_intr_handle_t ih;
	const char *vendor;
	char *devname = sc->sc.sc_bus.bdev.dv_xname;
	usbd_status r;
	int s;

	/* Map I/O registers */
	if (pci_mapreg_map(pa, PCI_CBMEM, PCI_MAPREG_TYPE_MEM, 0,
			   &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size, 0)) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_pc = pc;
	sc->sc_tag = tag;
	sc->sc.sc_bus.dmatag = pa->pa_dmat;

	/* Disable interrupts, so we don't get any spurious ones. */
	s = splhardusb();
	sc->sc.sc_offs = EREAD1(&sc->sc, EHCI_CAPLENGTH);
	DPRINTF(("%s: offs=%d\n", devname, sc->sc.sc_offs));
	EOWRITE2(&sc->sc, EHCI_USBINTR, 0);

	/* Handle quirks */
	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_ATI:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ATI_SB600_EHCI ||
		    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ATI_SB700_EHCI &&
		     pci_find_device(NULL, ehci_sb700_match))) {
			pcireg_t value;

			/* apply the ATI SB600/SB700 workaround */
			value = pci_conf_read(sc->sc_pc, sc->sc_tag,
			    EHCI_SBx00_WORKAROUND_REG);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    EHCI_SBx00_WORKAROUND_REG, value |
			    EHCI_SBx00_WORKAROUND_ENABLE);
		}
		break;

	case PCI_VENDOR_VIATECH:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT6202 &&
		    (PCI_REVISION(pa->pa_class) & 0xf0) == 0x60) {
			pcireg_t value;

			/*
			 * The VT6202 defaults to a 1 usec EHCI sleep time
			 * which hogs the PCI bus *badly*. Setting bit 5 of
			 * the register makes that sleep time use the conventional
			 * 10 usec.
			 */
			value = pci_conf_read(sc->sc_pc, sc->sc_tag,
			    EHCI_VT6202_WORKAROUND_REG);
			pci_conf_write(sc->sc_pc, sc->sc_tag,
			    EHCI_VT6202_WORKAROUND_REG, value | 0x20000000);
		}
		break;
	}

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto unmap_ret;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB | IPL_MPSAFE,
	    ehci_intr, sc, devname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto unmap_ret;
	}
	printf(": %s\n", intrstr);

	switch(pci_conf_read(pc, tag, PCI_USBREV) & PCI_USBREV_MASK) {
	case PCI_USBREV_PRE_1_0:
	case PCI_USBREV_1_0:
	case PCI_USBREV_1_1:
		sc->sc.sc_bus.usbrev = USBREV_UNKNOWN;
		printf("%s: pre-2.0 USB rev\n", devname);
		goto disestablish_ret;
	case PCI_USBREV_2_0:
		sc->sc.sc_bus.usbrev = USBREV_2_0;
		break;
	default:
		sc->sc.sc_bus.usbrev = USBREV_UNKNOWN;
		break;
	}

	/* Figure out vendor for root hub descriptor. */
	vendor = pci_findvendor(pa->pa_id);
	sc->sc.sc_id_vendor = PCI_VENDOR(pa->pa_id);
	if (vendor)
		strlcpy(sc->sc.sc_vendor, vendor, sizeof(sc->sc.sc_vendor));
	else
		snprintf(sc->sc.sc_vendor, sizeof(sc->sc.sc_vendor),
		    "vendor 0x%04x", PCI_VENDOR(pa->pa_id));

	/* Enable workaround for dropped interrupts as required */
	switch (sc->sc.sc_id_vendor) {
	case PCI_VENDOR_ATI:
	case PCI_VENDOR_VIATECH:
		sc->sc.sc_flags |= EHCIF_DROPPED_INTR_WORKAROUND;
		break;
	default:
		break;
	}

	ehci_pci_takecontroller(sc, 0);
	r = ehci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf("%s: init failed, error=%d\n", devname, r);
		goto disestablish_ret;
	}

	/* Attach usb device. */
	config_found(self, &sc->sc.sc_bus, usbctlprint);
	splx(s);
	return;

disestablish_ret:
	pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
unmap_ret:
	bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
	splx(s);
}

int
ehci_pci_activate(struct device *self, int act)
{
	struct ehci_pci_softc *sc = (struct ehci_pci_softc *)self;
	int rv;

	switch (act) {
	case DVACT_RESUME:
		ehci_pci_takecontroller(sc, 1);
		break;
	}

	rv = ehci_activate(self, act);

#if 0
	switch (act) {
	case DVACT_POWERDOWN:
		ehci_pci_givecontroller(sc);
		break;
	}
#endif
	return (rv);
}

int
ehci_pci_detach(struct device *self, int flags)
{
	struct ehci_pci_softc *sc = (struct ehci_pci_softc *)self;
	int rv;

	rv = ehci_detach(self, flags);
	if (rv)
		return (rv);
	if (sc->sc_ih != NULL) {
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
		sc->sc_ih = NULL;
	}
	if (sc->sc.sc_size) {
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		sc->sc.sc_size = 0;
	}
	return (0);
}

#if 0
void
ehci_pci_givecontroller(struct ehci_pci_softc *sc)
{
	u_int32_t cparams, eec, legsup;
	int eecp;

	cparams = EREAD4(&sc->sc, EHCI_HCCPARAMS);
	for (eecp = EHCI_HCC_EECP(cparams); eecp != 0;
	    eecp = EHCI_EECP_NEXT(eec)) {
		eec = pci_conf_read(sc->sc_pc, sc->sc_tag, eecp);
		if (EHCI_EECP_ID(eec) != EHCI_EC_LEGSUP)
			continue;
		legsup = eec;
		pci_conf_write(sc->sc_pc, sc->sc_tag, eecp,
		    legsup & ~EHCI_LEGSUP_OSOWNED);
	}
}
#endif

void
ehci_pci_takecontroller(struct ehci_pci_softc *sc, int silent)
{
	u_int32_t cparams, eec, legsup;
	int eecp, i;

	cparams = EREAD4(&sc->sc, EHCI_HCCPARAMS);
	/* Synchronise with the BIOS if it owns the controller. */
	for (eecp = EHCI_HCC_EECP(cparams); eecp != 0;
	    eecp = EHCI_EECP_NEXT(eec)) {
		eec = pci_conf_read(sc->sc_pc, sc->sc_tag, eecp);
		if (EHCI_EECP_ID(eec) != EHCI_EC_LEGSUP)
			continue;
		legsup = eec;
		if (legsup & EHCI_LEGSUP_BIOSOWNED) {
			pci_conf_write(sc->sc_pc, sc->sc_tag, eecp,
			    legsup | EHCI_LEGSUP_OSOWNED);
			DPRINTF(("%s: waiting for BIOS to give up control\n",
			    sc->sc.sc_bus.bdev.dv_xname));
			for (i = 0; i < 5000; i++) {
				legsup = pci_conf_read(sc->sc_pc, sc->sc_tag,
				    eecp);
				if ((legsup & EHCI_LEGSUP_BIOSOWNED) == 0)
					break;
				DELAY(1000);
			}
			if (silent == 0 && (legsup & EHCI_LEGSUP_BIOSOWNED))
				printf("%s: timed out waiting for BIOS\n",
				    sc->sc.sc_bus.bdev.dv_xname);
		}
	}
}

int
ehci_sb700_match(struct pci_attach_args *pa)
{
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ATI &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ATI_SBX00_SMB &&
	    (PCI_REVISION(pa->pa_class) == 0x3a ||
	     PCI_REVISION(pa->pa_class) == 0x3b))
		return (1);

	return (0);
}
@


1.29
log
@Run config_found() under splusb.

Fix a NULL dereference reported by jsg@@ in case a Root Port Hub interrupt
is handled before the soft-interrupt has been established.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.28 2015/11/02 14:55:41 mpi Exp $ */
d210 3
a212 1
	if (sc->sc.sc_id_vendor == PCI_VENDOR_VIATECH)
d214 4
@


1.28
log
@Delay root hub interrupt processing to the soft-interrupt path in order
to mark ehci_intr() as IPL_MPSAFE.

Earlier version tested by ratchov@@, ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.27 2014/05/16 18:17:03 mpi Exp $ */
a219 2
	splx(s);

d222 1
@


1.27
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.26 2013/04/15 09:23:01 mglocker Exp $ */
d174 2
a175 1
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, ehci_intr, sc, devname);
d208 1
a208 1
	
@


1.26
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.25 2012/10/20 19:13:25 deraadt Exp $ */
d222 1
a222 3
	sc->sc.sc_child = config_found((void *)sc, &sc->sc.sc_bus,
				       usbctlprint);

a237 4
	/* ehci_pci_attach previously failed in some way */
	if (sc->sc.sc_child == NULL)
		return (0);

d262 1
a262 1
	rv = ehci_detach(&sc->sc, flags);
@


1.25
log
@driver xxactivate() functins are run even if a driver xxattach() has
"failed"; no indication is given up to the autoconf framework since
xxattach() returns void.  Until this situation is improved, there are
a handful of drivers which must use driver-specific checks in xxactivate()
to see if the xxattach() function succeeded or failed.
Add such a check here.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.24 2012/10/08 21:47:50 deraadt Exp $ */
d62 1
a62 1
	ehci_softc_t		sc;
@


1.24
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.23 2011/04/26 00:37:34 deraadt Exp $ */
d239 4
@


1.23
log
@typo; found in an old tree..
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.22 2010/10/20 20:34:19 mk Exp $ */
d78 1
d80 1
a81 1
void	ehci_pci_shutdown(void *);
a218 1
	sc->sc.sc_shutdownhook = shutdownhook_establish(ehci_pci_shutdown, sc);
d238 1
a239 1
	/* On resume, take ownership from the BIOS */
d246 10
a255 1
	return ehci_activate(self, act);
d278 1
a278 1
#if 0	/* not used */
a328 12
}

void
ehci_pci_shutdown(void *v)
{
	struct ehci_pci_softc *sc = (struct ehci_pci_softc *)v;

	ehci_shutdown(&sc->sc);
#if 0
	/* best not to do this anymore; BIOS SMM spins? */
	ehci_pci_givecontroller(sc);
#endif
@


1.22
log
@Disestablish interrupts if attachment fails.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.21 2010/08/08 04:19:24 deraadt Exp $ */
d315 1
a315 1
			if (silent == 00 && (legsup & EHCI_LEGSUP_BIOSOWNED))
@


1.21
log
@silence BIOS takeover failure messages on unsuspends
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.20 2010/06/29 22:14:57 mlarkin Exp $ */
d189 1
a189 1
		goto unmap_ret;
d215 1
a215 1
		goto unmap_ret;
d227 2
@


1.20
log
@

Add some missing UHCI and EHCI register restores on resume. Fixes at least
one broken UHCI on resume.

Tested by myself, kettenis, phessler, jsg, pirofti. Doesn't help all
machines, but no worse than before on any of them.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.19 2010/04/08 00:23:53 tedu Exp $ */
d79 1
a79 1
void	ehci_pci_takecontroller(struct ehci_pci_softc *);
d211 1
a211 1
	ehci_pci_takecontroller(sc);
d240 1
a240 1
		ehci_pci_takecontroller(sc);
d288 1
a288 1
ehci_pci_takecontroller(struct ehci_pci_softc *sc)
d313 1
a313 1
			if (legsup & EHCI_LEGSUP_BIOSOWNED)
@


1.19
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.18 2009/07/24 03:18:58 deraadt Exp $ */
d77 1
d84 1
a84 1
	ehci_pci_detach, ehci_activate
d230 15
@


1.18
log
@silent VIA VT6202 workaround; from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.17 2009/07/23 19:42:02 deraadt Exp $ */
d38 1
a38 1
#include <sys/proc.h>
@


1.17
log
@VIA VT6202 defaults to a bus-hoggingly aggressive sleep time, so retune it
to a more reasonable default.  speeds up the armish machines in particular
(perhaps because their pci bus is so slow), and has no downside when tested
on other machines.
from linux originally, via brad, ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.16 2009/06/25 01:01:44 deraadt Exp $ */
a159 2
			if ((value & 0x20000000) == 0)
				printf(", applying VIA VT6202 workaround");
@


1.16
log
@Workaround a stupid problem ATI SB600 revisions and ATI SB700 south
bridge revisions A12 and  A13.  We really don't know what it does,
but then noone else does.
From NetBSD and Linux, via brad
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.15 2009/03/29 21:53:52 sthen Exp $ */
d72 1
d131 35
a165 12
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ATI &&
	    ((PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ATI_SB600_EHCI ||
	      (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ATI_SB700_EHCI &&
	       pci_find_device(NULL, ehci_sb700_match))))) {
		pcireg_t value;

		/* apply the ATI SB600/SB700 workaround */
		value = pci_conf_read(sc->sc_pc, sc->sc_tag,
		    EHCI_SBx00_WORKAROUND_REG);
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    EHCI_SBx00_WORKAROUND_REG, value |
		    EHCI_SBx00_WORKAROUND_ENABLE);
@


1.15
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.14 2008/06/26 05:42:17 ray Exp $ */
d68 5
a84 1

d129 15
d292 12
@


1.14
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.13 2008/04/09 19:03:54 deraadt Exp $ */
d111 1
a111 1
		printf(": can't map memory space\n");
@


1.13
log
@from freebsd; tested in snaps for weeks
 date: 2008/03/12 20:57:17;  author: jhb;  state: Exp;  lines: +4 -1
Relax the BIOS/OS sempahore handoff code to workaround different hard
hangs (one at boot, one at shutdown) in recent machines.  First, only try
to take ownership of the EHCI controller if the BIOS currently owns the
controller.  On a HP DL160 G5, the machine hangs when we try to take
ownership.  Second, don't bother trying to give up ownership of the
controller during shutdown.  It's not strictly required and a Dell DCS S29
hangs on shutdown after the config write.

Both of these changes match the behavior of the Linux EHCI driver.  I also
think both of these hangs are caused by bugs in the BIOS' SMM handler
causing it to get stuck in an infinite loop in SMM.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.12 2007/06/10 14:49:01 mbalmer Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.12
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.11 2007/05/20 00:52:26 jsg Exp $ */
d217 1
d235 1
a250 2
		pci_conf_write(sc->sc_pc, sc->sc_tag, eecp,
		    legsup | EHCI_LEGSUP_OSOWNED);
d252 2
d276 2
d279 1
@


1.11
log
@Convert ehci and ucom to rwlock.
Kill the usb specific lockmgr wrapper as nothing uses it now.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.10 2006/08/25 04:17:00 pascoe Exp $ */
d253 1
a253 1
			    USBDEVNAME(sc->sc.sc_bus.bdev)));
d263 1
a263 1
				    USBDEVNAME(sc->sc.sc_bus.bdev));
@


1.10
log
@Disable interrupts during the attach of UHCI and EHCI controllers.  If
we do not, a shared interrupt which arrives while we are initialising
the host controller may cause a NULL pointer dereference.

tested joris, ok! dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.9 2006/07/10 07:54:43 dlg Exp $ */
d43 1
@


1.9
log
@remove ifdef __OtherBSD__. no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.8 2005/12/30 03:43:04 dlg Exp $ */
d112 1
d126 1
d134 1
a134 2
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		return;
d143 1
a143 2
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		return;
d153 1
a153 2
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		return;
d179 1
a179 2
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		return;
d183 1
d188 6
@


1.8
log
@device_ptr_t -> struct device *

i hate typedefs
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.7 2005/08/09 04:10:11 mickey Exp $ */
a39 5
#include <sys/cdefs.h>
#if defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: ehci_pci.c,v 1.15 2004/04/23 21:13:06 itojun Exp $");
#endif

a111 8

#if defined(__NetBSD__)
	char devinfo[256];

	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo, sizeof(devinfo));
	printf(": %s (rev. 0x%02x)\n", devinfo,
	    PCI_REVISION(pa->pa_class));
#endif
@


1.7
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.6 2005/04/11 08:09:32 dlg Exp $ */
d81 1
a81 1
int	ehci_pci_detach(device_ptr_t, int);
d205 1
a205 1
ehci_pci_detach(device_ptr_t self, int flags)
@


1.6
log
@get rid of the lines on ehci attach that show the version and the companion
controllers. remove the insane amount of support code needed just for the
printing of the companion controllers while here.

zap it deraadt@@ sure pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.5 2005/03/07 11:12:04 pascoe Exp $ */
a113 1
	pcireg_t csr;
a135 5

	/* Enable the device. */
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
		       csr | PCI_COMMAND_MASTER_ENABLE);
@


1.5
log
@Add a workaround for VIA EHCI controllers which, under load, signal qTD
completion before they have performed writeback from the overlay qTD.

This condition would exhibit itself as a umass stall that never recovers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.4 2004/12/29 01:52:27 dlg Exp $ */
a55 1
#include <dev/pci/usb_pci.h>
a117 2
	int ncomp;
	struct usb_pci *up;
a193 16

	/*
	 * Find companion controllers.  According to the spec they always
	 * have lower function numbers so they should be enumerated already.
	 */
	ncomp = 0;
	TAILQ_FOREACH(up, &ehci_pci_alldevs, next) {
		if (up->bus == pa->pa_bus && up->device == pa->pa_device) {
			DPRINTF(("ehci_pci_attach: companion %s\n",
				 USBDEVNAME(up->usb->bdev)));
			sc->sc.sc_comps[ncomp++] = up->usb;
			if (ncomp >= EHCI_COMPANION_MAX)
				break;
		}
	}
	sc->sc.sc_ncomp = ncomp;
@


1.4
log
@from freebsd: ehci.c 1.13, ehci_pci.c 1.13, ehcireg.h 1.5, ehcivar.h 1.3
log message:
Attempt to follow the correct procedure for synchronising with the
system BIOS to disable legacy device emulation as per the "EHCI
Extended Capability: Pre-OS to OS Handoff Synchronisation" section
of the EHCI spec. BIOSes that implement legacy emulation using SMIs
are supposed to disable the emulation when this procedure is performed.

tested on various archs by jsg@@ and me
ok pascoe@@, looks sane jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci_pci.c,v 1.3 2004/05/30 01:25:17 tedu Exp $ */
d54 1
d194 4
@


1.3
log
@rcsids
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a71 4
int	ehci_pci_match(struct device *, void *, void *);
void	ehci_pci_attach(struct device *, struct device *, void *);
int	ehci_pci_detach(device_ptr_t, int);

d79 7
d209 1
d217 2
d242 60
@


1.3.2.1
log
@Merge with the trunk
@
text
@@


1.2
log
@do not bother w/ void pci_devinfo() calls and free resources on failures
@
text
@d1 1
@


1.1
log
@ehci support; hacked into working shape by jonathon@@gateway.zenbu.net
@
text
@a112 1
	char devinfo[256];
d117 3
a120 1
#if defined(__NetBSD__)
d149 1
d159 1
d170 1
d208 1
@

