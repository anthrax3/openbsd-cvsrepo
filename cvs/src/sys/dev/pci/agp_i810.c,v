head	1.93;
access;
symbols
	OPENBSD_6_2:1.93.0.4
	OPENBSD_6_2_BASE:1.93
	OPENBSD_6_1:1.93.0.8
	OPENBSD_6_1_BASE:1.93
	OPENBSD_6_0:1.93.0.6
	OPENBSD_6_0_BASE:1.93
	OPENBSD_5_9:1.93.0.2
	OPENBSD_5_9_BASE:1.93
	OPENBSD_5_8:1.89.0.6
	OPENBSD_5_8_BASE:1.89
	OPENBSD_5_7:1.89.0.4
	OPENBSD_5_7_BASE:1.89
	OPENBSD_5_6:1.87.0.4
	OPENBSD_5_6_BASE:1.87
	OPENBSD_5_5:1.82.0.4
	OPENBSD_5_5_BASE:1.82
	OPENBSD_5_4:1.78.0.2
	OPENBSD_5_4_BASE:1.78
	OPENBSD_5_3:1.71.0.2
	OPENBSD_5_3_BASE:1.71
	OPENBSD_5_2:1.70.0.4
	OPENBSD_5_2_BASE:1.70
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.2
	OPENBSD_5_0:1.69.0.4
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.69.0.2
	OPENBSD_4_9_BASE:1.69
	OPENBSD_4_8:1.67.0.2
	OPENBSD_4_8_BASE:1.67
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.57.0.4
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	SMP:1.5.0.4
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	UBC:1.3.0.4
	UBC_SYNC_B:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.93
date	2015.12.19.16.07.20;	author kettenis;	state Exp;
branches;
next	1.92;
commitid	NDhUxvYB3Eg6RqfI;

1.92
date	2015.10.29.07.47.03;	author kettenis;	state Exp;
branches;
next	1.91;
commitid	QDyL8dFxcUx9R2yh;

1.91
date	2015.10.09.13.22.54;	author kettenis;	state Exp;
branches;
next	1.90;
commitid	XcvcfgXNpC36lmcb;

1.90
date	2015.09.09.19.47.11;	author deraadt;	state Exp;
branches;
next	1.89;
commitid	oiL5hLU4dw0Ni62e;

1.89
date	2014.11.06.05.48.42;	author jsg;	state Exp;
branches;
next	1.88;
commitid	xwqnjiedsVXzBXqo;

1.88
date	2014.09.06.06.00.54;	author jsg;	state Exp;
branches;
next	1.87;
commitid	XcHJcf2IgrjkQyBR;

1.87
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.86;
commitid	OBNa5kfxQ2UXoiIw;

1.86
date	2014.05.12.19.29.16;	author kettenis;	state Exp;
branches;
next	1.85;

1.85
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.84;

1.84
date	2014.03.17.22.01.56;	author kettenis;	state Exp;
branches;
next	1.83;

1.83
date	2014.03.11.14.29.07;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2014.02.20.22.18.22;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2014.02.05.11.52.49;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2013.12.09.19.52.11;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2013.11.19.19.14.09;	author kettenis;	state Exp;
branches;
next	1.78;

1.78
date	2013.06.06.16.14.26;	author jsg;	state Exp;
branches;
next	1.77;

1.77
date	2013.05.15.10.24.36;	author jsg;	state Exp;
branches;
next	1.76;

1.76
date	2013.05.15.08.16.09;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2013.04.05.22.26.41;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2013.03.18.12.02.56;	author jsg;	state Exp;
branches;
next	1.73;

1.73
date	2013.03.18.11.20.11;	author jsg;	state Exp;
branches;
next	1.72;

1.72
date	2013.03.18.11.14.44;	author jsg;	state Exp;
branches;
next	1.71;

1.71
date	2012.09.25.10.19.46;	author jsg;	state Exp;
branches;
next	1.70;

1.70
date	2011.09.14.10.26.16;	author oga;	state Exp;
branches;
next	1.69;

1.69
date	2010.09.06.15.00.50;	author oga;	state Exp;
branches;
next	1.68;

1.68
date	2010.08.31.19.20.55;	author oga;	state Exp;
branches;
next	1.67;

1.67
date	2010.08.06.13.09.52;	author oga;	state Exp;
branches;
next	1.66;

1.66
date	2010.07.27.21.56.11;	author todd;	state Exp;
branches;
next	1.65;

1.65
date	2010.07.02.02.33.57;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2010.06.30.09.17.04;	author oga;	state Exp;
branches;
next	1.63;

1.63
date	2010.05.12.16.20.00;	author oga;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.09.19.40.37;	author oga;	state Exp;
branches;
next	1.61;

1.61
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2010.04.07.20.40.18;	author oga;	state Exp;
branches;
next	1.59;

1.59
date	2010.03.03.10.19.34;	author oga;	state Exp;
branches;
next	1.58;

1.58
date	2009.11.11.19.35.34;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.06.11.11.10;	author oga;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.06.10.56.30;	author oga;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.06.06.02.44;	author oga;	state Exp;
branches;
next	1.54;

1.54
date	2009.05.24.02.06.15;	author oga;	state Exp;
branches;
next	1.53;

1.53
date	2009.05.24.01.40.58;	author oga;	state Exp;
branches;
next	1.52;

1.52
date	2009.05.10.16.57.44;	author oga;	state Exp;
branches;
next	1.51;

1.51
date	2009.05.10.15.28.45;	author oga;	state Exp;
branches;
next	1.50;

1.50
date	2009.05.10.14.44.42;	author oga;	state Exp;
branches;
next	1.49;

1.49
date	2009.04.29.22.03.09;	author oga;	state Exp;
branches;
next	1.48;

1.48
date	2009.04.20.01.28.45;	author oga;	state Exp;
branches;
next	1.47;

1.47
date	2009.04.15.03.09.20;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.17.18.41.32;	author oga;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.03.13.07.15;	author kevlo;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.24.05.42.58;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.23.22.01.38;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.26.21.15.53;	author mikeb;	state Exp;
branches;
next	1.40;

1.40
date	2008.07.12.17.31.06;	author oga;	state Exp;
branches;
next	1.39;

1.39
date	2008.07.07.07.54.48;	author bernd;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.25.18.54.06;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.11.17.21.46;	author matthieu;	state Exp;
branches;
next	1.36;

1.36
date	2008.05.16.19.47.54;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2008.05.06.19.19.02;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2008.03.23.19.54.47;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2008.03.23.08.36.41;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.04.00.23.26;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2007.12.19.11.25.16;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.10.21.54.51;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2007.12.10.21.51.01;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.09.18.21.14;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2007.12.09.00.09.22;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.07.17.35.22;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.06.22.49.39;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.02.14.44.20;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.28.16.25.58;	author chl;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.26.15.35.15;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.26.10.35.42;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.26.00.04.38;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.06.23.50.54;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.04.19.40.25;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.30.19.14.55;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.15.08.27.19;	author dim;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.16.19.40.43;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.11.21.15.21;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.03.19.24.42;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.13.22.59.02;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.22.18.33.03;	author sturm;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.20.19.30.40;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.20.19.23.06;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.19.20.06.28;	author millert;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2003.02.13.20.07.33;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.25.23.31.04;	author fgsch;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2002.07.15.13.23.48;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.05.19.22.17.59;	author tedu;	state Exp;
branches;
next	;

1.5.4.1
date	2004.02.19.10.56.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.93
log
@Remove code that has been unused ever since we removed the agp ioctl interface.

ok mpi@@
@
text
@/*	$OpenBSD: agp_i810.c,v 1.92 2015/10/29 07:47:03 kettenis Exp $	*/

/*-
 * Copyright (c) 2000 Doug Rabson
 * Copyright (c) 2000 Ruslan Ermilov
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include "acpi.h"
#include "drm.h"
#include "vga.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/rwlock.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>
#include <dev/pci/drm/i915/i915_drv.h>

#include <machine/bus.h>

#define READ1(off)	bus_space_read_1(isc->map->bst, isc->map->bsh, off)
#define READ4(off)	bus_space_read_4(isc->map->bst, isc->map->bsh, off)
#define WRITE4(off,v)	bus_space_write_4(isc->map->bst, isc->map->bsh, off, v)

/*
 * Intel IGP gtt bits.
 */
/* PTE is enabled */
#define	INTEL_ENABLED	0x1
/* I810/I815 only, memory is in dcache */
#define	INTEL_LOCAL	0x2
/* Memory is snooped, must not be accessed through gtt from the cpu. */
#define	INTEL_COHERENT	0x6	

enum {
	CHIP_NONE	= 0,	/* not integrated graphics */
	CHIP_I810	= 1,	/* i810/i815 */
	CHIP_I830	= 2,	/* i830/i845 */
	CHIP_I855	= 3,	/* i852GM/i855GM/i865G */
	CHIP_I915	= 4,	/* i915G/i915GM */
	CHIP_I965	= 5,	/* i965/i965GM */
	CHIP_G33	= 6,	/* G33/Q33/Q35 */
	CHIP_G4X	= 7,	/* G4X */
	CHIP_PINEVIEW	= 8,	/* Pineview/Pineview M */
	CHIP_IRONLAKE	= 9,	/* Clarkdale/Arrandale */
};

struct agp_i810_softc {
	struct device		 dev;
	bus_dma_segment_t	 scrib_seg;
	struct agp_softc	*agpdev;
	struct agp_gatt		*gatt;
	struct vga_pci_bar	*map;
	bus_space_tag_t		 gtt_bst;
	bus_space_handle_t	 gtt_bsh;
	bus_size_t		 gtt_size;
	bus_dmamap_t		 scrib_dmamap;
	bus_addr_t		 isc_apaddr;
	bus_size_t		 isc_apsize;	/* current aperture size */
	int			 chiptype;	/* i810-like or i830 */
	u_int32_t		 dcache_size;	/* i810 only */
	u_int32_t		 stolen;	/* number of i830/845 gtt
						   entries for stolen memory */
};

void	agp_i810_attach(struct device *, struct device *, void *);
int	agp_i810_activate(struct device *, int);
void	agp_i810_configure(struct agp_i810_softc *);
int	agp_i810_probe(struct device *, void *, void *);
int	agp_i810_get_chiptype(struct pci_attach_args *);
void	agp_i810_bind_page(void *, bus_size_t, paddr_t, int);
void	agp_i810_unbind_page(void *, bus_size_t);
void	agp_i810_flush_tlb(void *);
int	agp_i810_enable(void *, u_int32_t mode);
void	intagp_write_gtt(struct agp_i810_softc *, bus_size_t, paddr_t);
int	intagp_gmch_match(struct pci_attach_args *);

extern void	intagp_dma_sync(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);

struct cfattach intagp_ca = {
	sizeof(struct agp_i810_softc), agp_i810_probe, agp_i810_attach,
	NULL, agp_i810_activate,
};

struct cfdriver intagp_cd = {
	NULL, "intagp", DV_DULL
};

struct agp_methods agp_i810_methods = {
	agp_i810_bind_page,
	agp_i810_unbind_page,
	agp_i810_flush_tlb,
	agp_i810_enable,
};

int
agp_i810_get_chiptype(struct pci_attach_args *pa)
{
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_INTEL_82810_IGD:
	case PCI_PRODUCT_INTEL_82810_DC100_IGD:
	case PCI_PRODUCT_INTEL_82810E_IGD:
	case PCI_PRODUCT_INTEL_82815_IGD:
		return (CHIP_I810);
		break;
	case PCI_PRODUCT_INTEL_82830M_IGD:
	case PCI_PRODUCT_INTEL_82845G_IGD:
		return (CHIP_I830);
		break;
	case PCI_PRODUCT_INTEL_82854_IGD:
	case PCI_PRODUCT_INTEL_82855GM_IGD:
	case PCI_PRODUCT_INTEL_82865G_IGD:
		return (CHIP_I855);
		break;
	case PCI_PRODUCT_INTEL_E7221_IGD:
	case PCI_PRODUCT_INTEL_82915G_IGD_1:
	case PCI_PRODUCT_INTEL_82915G_IGD_2:
	case PCI_PRODUCT_INTEL_82915GM_IGD_1:
	case PCI_PRODUCT_INTEL_82915GM_IGD_2:
	case PCI_PRODUCT_INTEL_82945G_IGD_1:
	case PCI_PRODUCT_INTEL_82945G_IGD_2:
	case PCI_PRODUCT_INTEL_82945GM_IGD_1:
	case PCI_PRODUCT_INTEL_82945GM_IGD_2:
	case PCI_PRODUCT_INTEL_82945GME_IGD_1:
		return (CHIP_I915);
		break;
	case PCI_PRODUCT_INTEL_82946GZ_IGD_1:
	case PCI_PRODUCT_INTEL_82946GZ_IGD_2:
	case PCI_PRODUCT_INTEL_82Q965_IGD_1:
	case PCI_PRODUCT_INTEL_82Q965_IGD_2:
	case PCI_PRODUCT_INTEL_82G965_IGD_1:
	case PCI_PRODUCT_INTEL_82G965_IGD_2:
	case PCI_PRODUCT_INTEL_82GM965_IGD_1:
	case PCI_PRODUCT_INTEL_82GM965_IGD_2:
	case PCI_PRODUCT_INTEL_82GME965_IGD_1:
	case PCI_PRODUCT_INTEL_82GME965_IGD_2:
	case PCI_PRODUCT_INTEL_82G35_IGD_1:
	case PCI_PRODUCT_INTEL_82G35_IGD_2:
		return (CHIP_I965);
		break;
	case PCI_PRODUCT_INTEL_82G33_IGD_1:
	case PCI_PRODUCT_INTEL_82G33_IGD_2:
	case PCI_PRODUCT_INTEL_82Q35_IGD_1:
	case PCI_PRODUCT_INTEL_82Q35_IGD_2:
	case PCI_PRODUCT_INTEL_82Q33_IGD_1:
	case PCI_PRODUCT_INTEL_82Q33_IGD_2:
		return (CHIP_G33);
		break;
	case PCI_PRODUCT_INTEL_82GM45_IGD_1:
	case PCI_PRODUCT_INTEL_4SERIES_IGD:
	case PCI_PRODUCT_INTEL_82Q45_IGD_1:
	case PCI_PRODUCT_INTEL_82G45_IGD_1:
	case PCI_PRODUCT_INTEL_82G41_IGD_1:
	case PCI_PRODUCT_INTEL_82B43_IGD_1:
	case PCI_PRODUCT_INTEL_82B43_IGD_2:
		return (CHIP_G4X);
		break;
	case PCI_PRODUCT_INTEL_PINEVIEW_IGC_1:
	case PCI_PRODUCT_INTEL_PINEVIEW_M_IGC_1:
		return (CHIP_PINEVIEW);
		break;
	case PCI_PRODUCT_INTEL_CLARKDALE_IGD:
	case PCI_PRODUCT_INTEL_ARRANDALE_IGD:
		return (CHIP_IRONLAKE);
		break;
	}
	
	return (CHIP_NONE);
}

/*
 * We're intel IGD, bus 0 function 0 dev 0 should be the GMCH, so it should
 * be Intel
 */
int
intagp_gmch_match(struct pci_attach_args *pa)
{
	if (pa->pa_bus == 0 && pa->pa_device == 0 && pa->pa_function == 0 &&
	    PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_HOST)
		return (1);
	return (0);
}

int
agp_i810_probe(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args	*pa = aux;

	if (PCI_CLASS(pa->pa_class) != PCI_CLASS_DISPLAY ||
	    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_DISPLAY_VGA)
		return (0);

	return (agp_i810_get_chiptype(pa) != CHIP_NONE);
}

void
agp_i810_attach(struct device *parent, struct device *self, void *aux)
{
	struct agp_i810_softc		*isc = (struct agp_i810_softc *)self;
	struct agp_gatt 		*gatt;
	struct pci_attach_args		*pa = aux, bpa;
	struct inteldrm_softc		*psc = (struct inteldrm_softc *)parent;
	bus_addr_t			 mmaddr, gmaddr, tmp;
	bus_size_t			 gtt_off = 0;
	pcireg_t			 memtype, reg;
	u_int32_t			 stolen;
	u_int16_t			 gcc1;

	isc->chiptype = agp_i810_get_chiptype(pa);

	switch (isc->chiptype) {
	case CHIP_I915:
	case CHIP_G33:
	case CHIP_PINEVIEW:
		gmaddr = AGP_I915_GMADR;
		mmaddr = AGP_I915_MMADR;
		memtype = PCI_MAPREG_TYPE_MEM;
		break;
	case CHIP_I965:
	case CHIP_G4X:
	case CHIP_IRONLAKE:
		gmaddr = AGP_I965_GMADR;
		mmaddr = AGP_I965_MMADR;
		memtype = PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT;
		if (isc->chiptype == CHIP_I965)
			gtt_off = AGP_I965_GTT;
		else
			gtt_off = AGP_G4X_GTT;
		break;
	default:
		gmaddr = AGP_APBASE;
		mmaddr = AGP_I810_MMADR;
		memtype = PCI_MAPREG_TYPE_MEM;
		gtt_off = AGP_I810_GTT;
		break;
	}

	if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, gmaddr, memtype,
	    &isc->isc_apaddr, &isc->isc_apsize, NULL) != 0) {
		printf("can't get aperture info\n");
		return;
	}

	isc->map = psc->regs;

	if (isc->chiptype == CHIP_I915 || isc->chiptype == CHIP_G33 ||
	    isc->chiptype == CHIP_PINEVIEW) {
		if (pci_mapreg_map(pa, AGP_I915_GTTADR, memtype,
		    BUS_SPACE_MAP_LINEAR, &isc->gtt_bst, &isc->gtt_bsh,
		    NULL, &isc->gtt_size, 0)) {
			printf("can't map gatt registers\n");
			goto out;
		}
	} else if (gtt_off >= isc->map->size) {
		isc->gtt_bst = isc->map->bst;
		isc->gtt_size = (isc->isc_apsize >> AGP_PAGE_SHIFT) * 4;
		if (bus_space_map(isc->gtt_bst, isc->map->base + gtt_off,
		    isc->gtt_size, BUS_SPACE_MAP_LINEAR, &isc->gtt_bsh)) {
			printf("can't map gatt registers\n");
			isc->gtt_size = 0;
			goto out;
		}
	} else {
		isc->gtt_bst = isc->map->bst;
		if (bus_space_subregion(isc->map->bst, isc->map->bsh, gtt_off,
		    (isc->isc_apsize >> AGP_PAGE_SHIFT) * 4, &isc->gtt_bsh)) {
			printf("can't map gatt registers\n");
			goto out;
		}
	}

	gatt = malloc(sizeof(*gatt), M_AGP, M_NOWAIT | M_ZERO);
	if (gatt == NULL) {
		printf("can't alloc gatt\n");
		goto out;
	}
	isc->gatt = gatt;

	gatt->ag_entries = isc->isc_apsize >> AGP_PAGE_SHIFT;

	/*
	 * Find the GMCH, some of the registers we need to read for
	 * configuration purposes are on there. it's always at
	 * 0/0/0 (bus/dev/func).
	 */
	if (pci_find_device(&bpa, intagp_gmch_match) == 0) {
		printf("can't find GMCH\n");
		goto out;
	}

	switch (isc->chiptype) {
	case CHIP_I810:
		/* Some i810s have on-chip memory called dcache */
		if (READ1(AGP_I810_DRT) & AGP_I810_DRT_POPULATED)
			isc->dcache_size = 4 * 1024 * 1024;
		else
			isc->dcache_size = 0;

		/* According to the specs the gatt on the i810 must be 64k */
		if (agp_alloc_dmamem(pa->pa_dmat, 64 * 1024, &gatt->ag_dmamap,
		    &gatt->ag_physical, &gatt->ag_dmaseg) != 0) {
			goto out;
		}
		gatt->ag_size = gatt->ag_entries * sizeof(u_int32_t);

		if (bus_dmamem_map(pa->pa_dmat, &gatt->ag_dmaseg, 1, 64 * 1024,
		    (caddr_t *)&gatt->ag_virtual, BUS_DMA_NOWAIT) != 0)
			goto out;
		break;

	case CHIP_I830:
		/* The i830 automatically initializes the 128k gatt on boot. */

		reg = pci_conf_read(bpa.pa_pc, bpa.pa_tag, AGP_I830_GCC0);
		gcc1 = (u_int16_t)(reg >> 16);
		switch (gcc1 & AGP_I830_GCC1_GMS) {
		case AGP_I830_GCC1_GMS_STOLEN_512:
			isc->stolen = (512 - 132) * 1024 / 4096;
			break;
		case AGP_I830_GCC1_GMS_STOLEN_1024:
			isc->stolen = (1024 - 132) * 1024 / 4096;
			break;
		case AGP_I830_GCC1_GMS_STOLEN_8192:
			isc->stolen = (8192 - 132) * 1024 / 4096;
			break;
		default:
			isc->stolen = 0;
			printf("unknown memory configuration, disabling\n");
			goto out;
		}
#ifdef DEBUG
		if (isc->stolen > 0) {
			printf(": detected %dk stolen memory",
			    isc->stolen * 4);
		} else
			printf(": no preallocated video memory\n");
#endif

		/* XXX */
		isc->stolen = 0;

		/* GATT address is already in there, make sure it's enabled */
		gatt->ag_physical = READ4(AGP_I810_PGTBL_CTL) & ~1;
		break;

	case CHIP_I855:
		/* FALLTHROUGH */
	case CHIP_I915:
		/* FALLTHROUGH */
	case CHIP_I965: 
		/* FALLTHROUGH */
	case CHIP_G33:
		/* FALLTHROUGH */
	case CHIP_G4X:
	case CHIP_PINEVIEW:
	case CHIP_IRONLAKE:

		/* Stolen memory is set up at the beginning of the aperture by
		 * the BIOS, consisting of the GATT followed by 4kb for the
		 * BIOS display.
		 */

		reg = pci_conf_read(bpa.pa_pc, bpa.pa_tag, AGP_I855_GCC1);
		gcc1 = (u_int16_t)(reg >> 16);
                switch (isc->chiptype) {
		case CHIP_I855:
		/* The 855GM automatically initializes the 128k gatt on boot. */
			stolen = 128 + 4;
			break;
                case CHIP_I915:
		/* The 915G automatically initializes the 256k gatt on boot. */
			stolen = 256 + 4;
			break;
		case CHIP_I965:
			switch (READ4(AGP_I810_PGTBL_CTL) &
			    AGP_I810_PGTBL_SIZE_MASK) {
			case AGP_I810_PGTBL_SIZE_512KB:
				stolen = 512 + 4;
				break;
			case AGP_I810_PGTBL_SIZE_256KB:
				stolen = 256 + 4;
				break;
			case AGP_I810_PGTBL_SIZE_128KB:
			default:
				stolen = 128 + 4;
				break;
			}
			break;
		case CHIP_G33:
			switch (gcc1 & AGP_G33_PGTBL_SIZE_MASK) {
			case AGP_G33_PGTBL_SIZE_2M:
				stolen = 2048 + 4;
				break;
			case AGP_G33_PGTBL_SIZE_1M:
			default:
				stolen = 1024 + 4;
				break;
			}
			break;
		case CHIP_G4X:
		case CHIP_PINEVIEW:
		case CHIP_IRONLAKE:
			/*
			 * GTT stolen is separate from graphics stolen on
			 * 4 series hardware. so ignore it in stolen gtt entries
			 * counting. However, 4Kb of stolen memory isn't mapped
			 * to the GTT.
			 */
			stolen = 4;
			break;
		default:
			printf("bad chiptype\n");
			goto out;
		}

		switch (gcc1 & AGP_I855_GCC1_GMS) {
		case AGP_I855_GCC1_GMS_STOLEN_1M:
			isc->stolen = (1024 - stolen) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_4M:
			isc->stolen = (4096 - stolen) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_8M:
			isc->stolen = (8192 - stolen) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_16M:
			isc->stolen = (16384 - stolen) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_32M:
			isc->stolen = (32768 - stolen) * 1024 / 4096;
			break;
		case AGP_I915_GCC1_GMS_STOLEN_48M:
			isc->stolen = (49152 - stolen) * 1024 / 4096;
			break;
		case AGP_I915_GCC1_GMS_STOLEN_64M:
			isc->stolen = (65536 - stolen) * 1024 / 4096;
			break;
		case AGP_G33_GCC1_GMS_STOLEN_128M:
			isc->stolen = (131072 - stolen) * 1024 / 4096;
			break;
		case AGP_G33_GCC1_GMS_STOLEN_256M:
			isc->stolen = (262144 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_GMCH_GMS_STOLEN_96M:
			isc->stolen = (98304 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_GMCH_GMS_STOLEN_160M:
			isc->stolen = (163840 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_GMCH_GMS_STOLEN_224M:
			isc->stolen = (229376 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_GMCH_GMS_STOLEN_352M:
			isc->stolen = (360448 - stolen) * 1024 / 4096;
			break;
		default:
			isc->stolen = 0;
			printf("unknown memory configuration, disabling\n");
			goto out;
		}
#ifdef DEBUG
		if (isc->stolen > 0) {
			printf(": detected %dk stolen memory",
			    isc->stolen * 4);
		} else
			printf(": no preallocated video memory\n");
#endif

		/* XXX */
		isc->stolen = 0;

		/* GATT address is already in there, make sure it's enabled */
		gatt->ag_physical = READ4(AGP_I810_PGTBL_CTL) & ~1;
		break;

	default:
		printf(": unknown initialisation\n");
		return;
	}
	/* Intel recommends that you have a fake page bound to the gtt always */
	if (agp_alloc_dmamem(pa->pa_dmat, AGP_PAGE_SIZE, &isc->scrib_dmamap,
	    &tmp, &isc->scrib_seg) != 0) {
		printf(": can't get scribble page\n");
		return;
	}
	agp_i810_configure(isc);

	isc->agpdev = (struct agp_softc *)agp_attach_bus(pa, &agp_i810_methods,
	    isc->isc_apaddr, isc->isc_apsize, &isc->dev);
	isc->agpdev->sc_stolen_entries = isc->stolen;
	return;
out:

	if (isc->gatt) {
		if (isc->gatt->ag_size != 0)
			agp_free_dmamem(pa->pa_dmat, isc->gatt->ag_size,
			    isc->gatt->ag_dmamap, &isc->gatt->ag_dmaseg);
		free(isc->gatt, M_AGP, sizeof (*isc->gatt));
	}
	if (isc->gtt_size != 0)
		bus_space_unmap(isc->gtt_bst, isc->gtt_bsh, isc->gtt_size);
}

int
agp_i810_activate(struct device *arg, int act)
{
	struct agp_i810_softc *isc = (struct agp_i810_softc *)arg;

	/*
	 * Anything kept in agp over a suspend/resume cycle (and thus by X
	 * over a vt switch cycle) is undefined upon resume.
	 */
	switch (act) {
	case DVACT_RESUME:
		agp_i810_configure(isc);
		break;
	}

	return (0);
}

void
agp_i810_configure(struct agp_i810_softc *isc)
{
	bus_addr_t	tmp;

	tmp = isc->isc_apaddr;
	if (isc->chiptype == CHIP_I810) {
		tmp += isc->dcache_size;
	} else {  
		tmp += isc->stolen << AGP_PAGE_SHIFT;
	}

	agp_flush_cache();
	/* Install the GATT. */
	WRITE4(AGP_I810_PGTBL_CTL, isc->gatt->ag_physical | 1);

	/* initialise all gtt entries to point to scribble page */
	for (; tmp < (isc->isc_apaddr + isc->isc_apsize);
	    tmp += AGP_PAGE_SIZE)
		agp_i810_unbind_page(isc, tmp);
	/* XXX we'll need to restore the GTT contents when we go kms */

	/*
	 * Make sure the chipset can see everything.
	 */
	agp_flush_cache();
}

void
agp_i810_bind_page(void *sc, bus_addr_t offset, paddr_t physical, int flags)
{
	struct agp_i810_softc *isc = sc;

	/*
	 * COHERENT mappings mean set the snoop bit. this should never be
	 * accessed by the gpu through the gtt.
	 */
	if (flags & BUS_DMA_COHERENT)
		physical |= INTEL_COHERENT;

	intagp_write_gtt(isc, offset - isc->isc_apaddr, physical);
}

void
agp_i810_unbind_page(void *sc, bus_size_t offset)
{
	struct agp_i810_softc *isc = sc;

	intagp_write_gtt(isc, offset - isc->isc_apaddr,
	    isc->scrib_dmamap->dm_segs[0].ds_addr);
}

/*
 * Writing via memory mapped registers already flushes all TLBs.
 */
void
agp_i810_flush_tlb(void *sc)
{
}

int
agp_i810_enable(void *sc, u_int32_t mode)
{
	return (0);
}

void
intagp_write_gtt(struct agp_i810_softc *isc, bus_size_t off, paddr_t v)
{
	u_int32_t	pte = 0;
	bus_size_t	wroff;

	if (isc->chiptype != CHIP_I810 &&
	    (off >> AGP_PAGE_SHIFT) < isc->stolen) {
		printf("intagp: binding into stolen memory! (0x%lx)\n",
			(off >> AGP_PAGE_SHIFT));
	}

	if (v != 0) {
		pte = v | INTEL_ENABLED;
		/* 965+ can do 36-bit addressing, add in the extra bits */
		switch (isc->chiptype) {
		case CHIP_I965:
		case CHIP_G4X:
		case CHIP_PINEVIEW:
		case CHIP_G33:
		case CHIP_IRONLAKE:
			pte |= (v & 0x0000000f00000000ULL) >> 28;
			break;
		}
	}

	wroff = (off >> AGP_PAGE_SHIFT) * 4;
	bus_space_write_4(isc->gtt_bst, isc->gtt_bsh, wroff, pte);
}
@


1.92
log
@Make inteldrm(4) attach to pci(4) instead of vga(4) just like radeondrm(4).
This is needed for machines where Intel graphics isn't the primary graphics
device and on systems with UEFI firmware that put the device in non-VGA mode.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.91 2015/10/09 13:22:54 kettenis Exp $	*/
a103 4
struct agp_memory * agp_i810_alloc_memory(void *, int, vsize_t);
int	agp_i810_free_memory(void *, struct agp_memory *);
int	agp_i810_bind_memory(void *, struct agp_memory *, bus_size_t);
int	agp_i810_unbind_memory(void *, struct agp_memory *);
a123 4
	agp_i810_alloc_memory,
	agp_i810_free_memory,
	agp_i810_bind_memory,
	agp_i810_unbind_memory,
a616 162
	return (0);
}

struct agp_memory *
agp_i810_alloc_memory(void *softc, int type, vsize_t size)
{
	struct agp_i810_softc	*isc = softc;
	struct agp_softc	*sc = isc->agpdev;
	struct agp_memory	*mem;
	int			 error;

	if ((size & (AGP_PAGE_SIZE - 1)) != 0)
		return (NULL);

	if (sc->sc_allocated + size > sc->sc_maxmem)
		return (NULL);

	if (type == 1) {
		/*
		 * Mapping local DRAM into GATT.
		 */
		if (isc->chiptype != CHIP_I810 || size != isc->dcache_size)
			return (NULL);
	} else if (type == 2) {
		/*
		 * Bogus mapping of 1 or 4 pages for the hardware cursor.
		 */
		if (size != AGP_PAGE_SIZE && size != 4 * AGP_PAGE_SIZE) {
#ifdef DEBUG
			printf("agp: trying to map %lu for hw cursor\n", size);
#endif
			return (NULL);
		}
	}

	mem = malloc(sizeof *mem, M_AGP, M_WAITOK | M_ZERO);
	mem->am_id = sc->sc_nextid++;
	mem->am_size = size;
	mem->am_type = type;

	if (type == 2) {
		/*
		 * Allocate and wire down the pages now so that we can
		 * get their physical address.
		 */
		if ((mem->am_dmaseg = malloc(sizeof (*mem->am_dmaseg), M_AGP,
		    M_WAITOK | M_CANFAIL)) == NULL) {
			free(mem, M_AGP, sizeof *mem);
			return (NULL);
		}

		if ((error = agp_alloc_dmamem(sc->sc_dmat, size,
		    &mem->am_dmamap, &mem->am_physical, mem->am_dmaseg)) != 0) {
			free(mem->am_dmaseg, M_AGP, sizeof (*mem->am_dmaseg));
			free(mem, M_AGP, sizeof *mem);
			printf("agp: agp_alloc_dmamem(%d)\n", error);
			return (NULL);
		}
	} else if (type != 1) {
		if ((error = bus_dmamap_create(sc->sc_dmat, size,
		    size / PAGE_SIZE + 1, size, 0, BUS_DMA_NOWAIT,
		    &mem->am_dmamap)) != 0) {
			free(mem, M_AGP, sizeof *mem);
			printf("agp: bus_dmamap_create(%d)\n", error);
			return (NULL);
		}
	}

	TAILQ_INSERT_TAIL(&sc->sc_memory, mem, am_link);
	sc->sc_allocated += size;

	return (mem);
}

int
agp_i810_free_memory(void *softc, struct agp_memory *mem)
{
	struct agp_i810_softc	*isc = softc;
	struct agp_softc	*sc = isc->agpdev;

	if (mem->am_is_bound)
		return (EBUSY);

	if (mem->am_type == 2) {
		agp_free_dmamem(sc->sc_dmat, mem->am_size, mem->am_dmamap,
		    mem->am_dmaseg);
		free(mem->am_dmaseg, M_AGP, sizeof (*mem->am_dmaseg));
	} else if (mem->am_type != 1) {
		bus_dmamap_destroy(sc->sc_dmat, mem->am_dmamap);
	}

	sc->sc_allocated -= mem->am_size;
	TAILQ_REMOVE(&sc->sc_memory, mem, am_link);
	free(mem, M_AGP, sizeof *mem);
	return (0);
}

int
agp_i810_bind_memory(void *sc, struct agp_memory *mem, bus_size_t offset)
{
	struct agp_i810_softc	*isc = sc;
	u_int32_t 		 i;

	if (mem->am_is_bound != 0)
		return (EINVAL);

	if (isc->chiptype != CHIP_I810 && (offset >> AGP_PAGE_SHIFT) <
	    isc->stolen) {
#ifdef DEBUG
		printf("agp: trying to bind into stolen memory\n");
#endif
		return (EINVAL);
	}

	if (mem->am_type == 2) {
		for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE)
			agp_i810_bind_page(isc, isc->isc_apaddr + offset + i,
			    mem->am_physical + i, 0);
		mem->am_offset = offset;
		mem->am_is_bound = 1;
		return (0);
	}

	if (mem->am_type != 1)
		return (agp_generic_bind_memory(isc->agpdev, mem, offset));

	if (isc->chiptype != CHIP_I810)
		return (EINVAL);

	for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE)
		intagp_write_gtt(isc, i, i | INTEL_ENABLED | INTEL_LOCAL);
	mem->am_is_bound = 1;
	return (0);
}

int
agp_i810_unbind_memory(void *sc, struct agp_memory *mem)
{
	struct agp_i810_softc	*isc = sc;
	u_int32_t		 i;

	if (mem->am_is_bound == 0)
		return (EINVAL);

	if (mem->am_type == 2) {
		for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE)
			agp_i810_unbind_page(isc, isc->isc_apaddr +
			    mem->am_offset + i);
		mem->am_offset = 0;
		mem->am_is_bound = 0;
		return (0);
	}

	if (mem->am_type != 1)
		return (agp_generic_unbind_memory(isc->agpdev, mem));

	if (isc->chiptype != CHIP_I810)
		return (EINVAL);

	for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE)
		intagp_write_gtt(isc, i, 0);
	mem->am_is_bound = 0;
@


1.91
log
@Remove evil hack.  I've never seen the printf fire, and xenocara no longer
contains any code that can manipulate the affected register directly.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.90 2015/09/09 19:47:11 deraadt Exp $	*/
d46 1
a46 5
#include <dev/ic/mc6845reg.h>
#include <dev/ic/pcdisplayvar.h>
#include <dev/ic/vgareg.h>
#include <dev/ic/vgavar.h>
#include <dev/pci/vga_pcivar.h>
d83 3
a85 1
	struct vga_pci_bar	*gtt_map;
d242 1
a242 1
	struct vga_pci_softc		*vga = (struct vga_pci_softc *)parent;
d244 1
d265 4
d274 1
d284 1
a284 5
	isc->map = vga_pci_bar_map(vga, mmaddr, 0, BUS_SPACE_MAP_LINEAR);
	if (isc->map == NULL) {
		printf("can't map mmadr registers\n");
		return;
	}
d288 19
a306 3
		isc->gtt_map = vga_pci_bar_map(vga, AGP_I915_GTTADR, 0,
		    BUS_SPACE_MAP_LINEAR);
		if (isc->gtt_map == NULL) {
d540 2
a541 4
	if (isc->gtt_map != NULL)
		vga_pci_bar_unmap(isc->gtt_map);
	if (isc->map != NULL)
		vga_pci_bar_unmap(isc->map);
d794 1
a794 1
	bus_size_t	baseoff, wroff;
d817 1
a817 21

	switch(isc->chiptype) {
	case CHIP_I915:
		/* FALLTHROUGH */
	case CHIP_G33:
	case CHIP_PINEVIEW:
		bus_space_write_4(isc->gtt_map->bst, isc->gtt_map->bsh,
		    wroff, pte);
		return;
	case CHIP_I965:
		baseoff = AGP_I965_GTT;
		break;
	case CHIP_G4X:
	case CHIP_IRONLAKE:
		baseoff = AGP_G4X_GTT;
		break;
	default:
		baseoff = AGP_I810_GTT;
		break;
	}
	bus_space_write_4(isc->map->bst, isc->map->bsh, baseoff + wroff, pte);
@


1.90
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.89 2014/11/06 05:48:42 jsg Exp $	*/
d712 1
a712 1
	u_int32_t 		 regval, i;
a722 14
	}

	/*
	 * XXX evil hack: the PGTBL_CTL appearently gets overwritten by the
	 * X server for mysterious reasons which leads to crashes if we write
	 * to the GTT through the MMIO window.
	 * Until the issue is solved, simply restore it.
	 */
	regval = READ4(AGP_I810_PGTBL_CTL);
	if (regval != (isc->gatt->ag_physical | 1)) {
		printf("agp_i810_bind_memory: PGTBL_CTL is 0x%x - fixing\n",
		    regval);
		WRITE4(AGP_I810_PGTBL_CTL, isc->gatt->ag_physical |
		    INTEL_ENABLED);
@


1.89
log
@Add the required includes for the conditional parts of
struct vga_pci_softc in vga_pcivar.h

Original diff from guenther@@ changed to incorporate feedback
from kettenis@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.88 2014/09/06 06:00:54 jsg Exp $	*/
d522 1
a522 1
		free(isc->gatt, M_AGP, 0);
d658 1
a658 1
			free(mem, M_AGP, 0);
d664 2
a665 2
			free(mem->am_dmaseg, M_AGP, 0);
			free(mem, M_AGP, 0);
d673 1
a673 1
			free(mem, M_AGP, 0);
d697 1
a697 1
		free(mem->am_dmaseg, M_AGP, 0);
d704 1
a704 1
	free(mem, M_AGP, 0);
@


1.88
log
@Match q33 devices.  Previously only inteldrm matched on q33,
which would lead to a panic.
Problem reported by karlis.mikelsons at lf.lv.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.87 2014/07/12 18:48:51 tedu Exp $	*/
d31 4
d46 4
@


1.87
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.86 2014/05/12 19:29:16 kettenis Exp $	*/
d177 2
@


1.86
log
@Move GTT management for Sandy Bridge and up into inteldrm(4).  This makes
it possible to use the non-mappable part of the GTT, prepares the way for
using the PPGTT and reduces the diffs with Linux.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.85 2014/03/26 14:41:41 mpi Exp $	*/
d512 1
a512 1
		free(isc->gatt, M_AGP);
d648 1
a648 1
			free(mem, M_AGP);
d654 2
a655 2
			free(mem->am_dmaseg, M_AGP);
			free(mem, M_AGP);
d663 1
a663 1
			free(mem, M_AGP);
d687 1
a687 1
		free(mem->am_dmaseg, M_AGP);
d694 1
a694 1
	free(mem, M_AGP);
@


1.85
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.84 2014/03/17 22:01:56 kettenis Exp $	*/
a59 5
#define GEN6_PTE_UNCACHED		(1 << 1)
#define HSW_PTE_UNCACHED		(0)
#define GEN6_PTE_CACHE_LLC		(2 << 1)
#define GEN6_PTE_CACHE_LLC_MLC		(3 << 1)

a70 3
	CHIP_SANDYBRIDGE=10,	/* Sandybridge */
	CHIP_IVYBRIDGE	=11,	/* Ivybridge */
	CHIP_HASWELL	=12,	/* Haswell */
a195 78
	case PCI_PRODUCT_INTEL_CORE2G_GT1:
	case PCI_PRODUCT_INTEL_CORE2G_M_GT1:
	case PCI_PRODUCT_INTEL_CORE2G_S_GT:
	case PCI_PRODUCT_INTEL_CORE2G_GT2:
	case PCI_PRODUCT_INTEL_CORE2G_M_GT2:
	case PCI_PRODUCT_INTEL_CORE2G_GT2_PLUS:
	case PCI_PRODUCT_INTEL_CORE2G_M_GT2_PLUS:
		return (CHIP_SANDYBRIDGE);
		break;
	case PCI_PRODUCT_INTEL_CORE3G_D_GT1:
	case PCI_PRODUCT_INTEL_CORE3G_M_GT1:
	case PCI_PRODUCT_INTEL_CORE3G_S_GT1:
	case PCI_PRODUCT_INTEL_CORE3G_D_GT2:
	case PCI_PRODUCT_INTEL_CORE3G_M_GT2:
	case PCI_PRODUCT_INTEL_CORE3G_S_GT2:
		return (CHIP_IVYBRIDGE);
	case PCI_PRODUCT_INTEL_CORE4G_D_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_D_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_D_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_S_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_S_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_S_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_M_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_M_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_M_GT2_2:
	case PCI_PRODUCT_INTEL_CORE4G_R_GT1_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_GT2_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_GT3_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_GT1_2:
	case PCI_PRODUCT_INTEL_CORE4G_R_GT2_2:
	case PCI_PRODUCT_INTEL_CORE4G_R_GT3_2:
	case PCI_PRODUCT_INTEL_CORE4G_D_SDV_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_D_SDV_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_D_SDV_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_S_SDV_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_S_SDV_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_S_SDV_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_M_SDV_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_M_SDV_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_M_SDV_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_R_SDV_GT1_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_SDV_GT2_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_SDV_GT3_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_SDV_GT1_2:
	case PCI_PRODUCT_INTEL_CORE4G_R_SDV_GT2_2:
	case PCI_PRODUCT_INTEL_CORE4G_R_SDV_GT3_2:
	case PCI_PRODUCT_INTEL_CORE4G_D_ULT_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_D_ULT_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_D_ULT_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_S_ULT_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_S_ULT_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_S_ULT_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_M_ULT_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_M_ULT_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_M_ULT_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_R_ULT_GT1_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_ULT_GT2_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_ULT_GT3_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_ULT_GT1_2:
	case PCI_PRODUCT_INTEL_CORE4G_R_ULT_GT2_2:
	case PCI_PRODUCT_INTEL_CORE4G_R_ULT_GT3_2:
	case PCI_PRODUCT_INTEL_CORE4G_D_CRW_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_D_CRW_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_D_CRW_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_S_CRW_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_S_CRW_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_S_CRW_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_M_CRW_GT1:
	case PCI_PRODUCT_INTEL_CORE4G_M_CRW_GT2:
	case PCI_PRODUCT_INTEL_CORE4G_M_CRW_GT3:
	case PCI_PRODUCT_INTEL_CORE4G_R_CRW_GT1_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_CRW_GT2_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_CRW_GT3_1:
	case PCI_PRODUCT_INTEL_CORE4G_R_CRW_GT1_2:
	case PCI_PRODUCT_INTEL_CORE4G_R_CRW_GT2_2:
	case PCI_PRODUCT_INTEL_CORE4G_R_CRW_GT3_2:
		return (CHIP_HASWELL);
		break;
a252 3
	case CHIP_SANDYBRIDGE:
	case CHIP_IVYBRIDGE:
	case CHIP_HASWELL:
a489 13
	case CHIP_SANDYBRIDGE:
	case CHIP_IVYBRIDGE:
	case CHIP_HASWELL:
		/*
		 * Even though stolen memory exists on these machines,
		 * it isn't necessarily mapped into the aperture.
		 */
		isc->stolen = 0;

		/* GATT address is already in there, make sure it's enabled */
		gatt->ag_physical = READ4(AGP_I810_PGTBL_CTL) & ~1;
		break;

d570 1
d575 2
a576 24
	switch (isc->chiptype) {
	case CHIP_SANDYBRIDGE:
	case CHIP_IVYBRIDGE:
		if (flags & BUS_DMA_GTT_NOCACHE)
			physical |= GEN6_PTE_UNCACHED;
		if (flags & BUS_DMA_GTT_CACHE_LLC)
			physical |= GEN6_PTE_CACHE_LLC;
		if (flags & BUS_DMA_GTT_CACHE_LLC_MLC)
			physical |= GEN6_PTE_CACHE_LLC_MLC;
		break;
	case CHIP_HASWELL:
		if (flags & BUS_DMA_GTT_NOCACHE)
			physical |= HSW_PTE_UNCACHED;
		if (flags & BUS_DMA_GTT_CACHE_LLC)
			physical |= GEN6_PTE_CACHE_LLC;
		/* Haswell doesn't set L3 this way */
		if (flags & BUS_DMA_GTT_CACHE_LLC_MLC)
			physical |= GEN6_PTE_CACHE_LLC;
		break;
	default:
		if (flags & BUS_DMA_COHERENT)
			physical |= INTEL_COHERENT;
		break;
	}
a802 6
		/* gen6+ can do 40 bit addressing */
		case CHIP_SANDYBRIDGE:
		case CHIP_IVYBRIDGE:
		case CHIP_HASWELL:
			pte |= (v & 0x000000ff00000000ULL) >> 28;
			break;
a820 3
	case CHIP_SANDYBRIDGE:
	case CHIP_IVYBRIDGE:
	case CHIP_HASWELL:
@


1.84
log
@The AGP ioctl interface is gone; remove the header file as well.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.83 2014/03/11 14:29:07 kettenis Exp $	*/
a33 2
#include <sys/kernel.h>
#include <sys/lock.h>
d35 1
a35 1
#include <sys/conf.h>
@


1.83
log
@Don't bitch about binding into stolen memory on older hardware either.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.82 2014/02/20 22:18:22 kettenis Exp $	*/
a37 1
#include <sys/agpio.h>
@


1.82
log
@Remove some code that has no effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.81 2014/02/05 11:52:49 kettenis Exp $	*/
d444 3
@


1.81
log
@We're never going to detach the host bridge on our machines.

spotted by deraadt@@ during n2k14
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.80 2013/12/09 19:52:11 kettenis Exp $	*/
a625 31
	bus_space_tag_t bst = isc->map->bst;
	bus_space_handle_t bsh = isc->map->bsh;
	bus_size_t offset;

	if (isc->chiptype == CHIP_I915 ||
	    isc->chiptype == CHIP_G33 ||
	    isc->chiptype == CHIP_PINEVIEW) {
		bst = isc->gtt_map->bst;
		bsh = isc->gtt_map->bsh;
	}

	switch(isc->chiptype) {
	case CHIP_I915:
	case CHIP_G33:
	case CHIP_PINEVIEW:
		offset = 0;
		break;
	case CHIP_I965:
		offset = AGP_I965_GTT;
		break;
	case CHIP_G4X:
	case CHIP_IRONLAKE:
	case CHIP_SANDYBRIDGE:
	case CHIP_IVYBRIDGE:
	case CHIP_HASWELL:
		offset = AGP_G4X_GTT;
		break;
	default:
		offset = AGP_I810_GTT;
		break;
	}
d639 1
@


1.80
log
@Remove MD intagp(4) code that is unused now that inteldrm(4) manages the GTT
all by itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.79 2013/11/19 19:14:09 kettenis Exp $	*/
a696 33

#if 0
int
agp_i810_detach(struct agp_softc *sc)
{
	int error;
	struct agp_i810_softc *isc = sc->sc_chipc;

	error = agp_generic_detach(sc);
	if (error)
		return (error);

	/* Clear the GATT base. */
	if (sc->chiptype == CHIP_I810) {
		WRITE4(AGP_I810_PGTBL_CTL, 0);
	} else {
		unsigned int pgtblctl;
		pgtblctl = READ4(AGP_I810_PGTBL_CTL);
		pgtblctl &= ~1;
		WRITE4(AGP_I810_PGTBL_CTL, pgtblctl);
	}

	if (sc->chiptype == CHIP_I810) {
		bus_dmamem_unmap(pa->pa_dmat, isc->gatt->ag_virtual,
		    gatt->ag_size);
		agp_free_dmamem(sc->sc_dmat, gatt->ag_size, gatt->ag_dmamap,
		    &gatt->ag_dmaseg);
	}
	free(sc->gatt, M_AGP);

	return (0);
}
#endif
@


1.79
log
@Move the GTT management into the inteldrm driver.  It is really obvious now
that this is necessary as on some hardware we need guard pages between
regions that have different cache attributes.  Even if this appears to cause
regressions on some hardware, this change is a necessary (but not sufficient)
step to fix the cache coherency problems on the affected hardware.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.78 2013/06/06 16:14:26 jsg Exp $	*/
a131 1
	intagp_dma_sync,
@


1.78
log
@Add the remaining support code for 4th gen Intel Core/Haswell graphics
and match the same pci devices Linux does.  Untested for lack of
hardware but should work.  Note that 3D/OpenGL won't work until
we update to a newer version of Mesa, which can't happen until
the Radeon KMS work is ready.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.77 2013/05/15 10:24:36 jsg Exp $	*/
d572 3
@


1.77
log
@sync the list of pre haswell intel video devices with linux
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.76 2013/05/15 08:16:09 kettenis Exp $	*/
d64 1
d81 1
d224 61
d345 1
d579 1
d648 1
d747 9
d990 1
d1013 1
@


1.76
log
@Add support for Intel E7221 integrated graphics.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.75 2013/04/05 22:26:41 kettenis Exp $	*/
d152 1
d190 1
d194 2
d208 1
@


1.75
log
@Even though Sandy Bridge and Ivy Bridge have stolen memory, substracting it
from the GTT aperture doesn't make a lot of sense.  On some machines the
amount of stolen memory is the same size of even larger than the aperture!
So pretend that there is no stolen memory on these systems for now.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.74 2013/03/18 12:02:56 jsg Exp $	*/
d156 1
@


1.74
log
@Indirectly pass the cache level down to agp by abusing spare bus_dma bits.
Currently only used on gen6+, everything else keeps the old semantics.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.73 2013/03/18 11:20:11 jsg Exp $	*/
d509 3
a511 4

		/* Stolen memory is set up at the beginning of the aperture by
		 * the BIOS, consisting of the GATT followed by 4kb for the
		 * BIOS display.
d513 1
a513 68

		gcc1 = (u_int16_t)pci_conf_read(bpa.pa_pc, bpa.pa_tag,
		    AGP_INTEL_SNB_GMCH_CTRL);

		stolen = 4;

		switch (gcc1 & AGP_INTEL_SNB_GMCH_GMS_STOLEN_MASK) {
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_32M:
			isc->stolen = (32768 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_64M:
			isc->stolen = (65536 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_96M:
			isc->stolen = (98304 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_128M:
			isc->stolen = (131072 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_160M:
			isc->stolen = (163840 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_192M:
			isc->stolen = (196608 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_224M:
			isc->stolen = (229376 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_256M:
			isc->stolen = (262144 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_288M:
			isc->stolen = (294912 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_320M:
			isc->stolen = (327680 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_352M:
			isc->stolen = (360448 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_384M:
			isc->stolen = (393216 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_416M:
			isc->stolen = (425984 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_448M:
			isc->stolen = (458752 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_480M:
			isc->stolen = (491520 - stolen) * 1024 / 4096;
			break;
		case AGP_INTEL_SNB_GMCH_GMS_STOLEN_512M:
			isc->stolen = (524288 - stolen) * 1024 / 4096;
			break;
		default:
			isc->stolen = 0;
			printf("unknown memory configuration, disabling\n");
			goto out;
		}

#ifdef DEBUG
		if (isc->stolen > 0) {
			printf(": detected %dk stolen memory",
			    isc->stolen * 4);
		} else
			printf(": no preallocated video memory\n");
#endif
@


1.73
log
@gen6+ can do 40 bit addressing
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.72 2013/03/18 11:14:44 jsg Exp $	*/
d63 4
d733 15
a747 2
	if (flags & BUS_DMA_COHERENT)
		physical |= INTEL_COHERENT;
@


1.72
log
@stash the number of stolen entries in the agp struct
will be used in a future commit
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.71 2012/09/25 10:19:46 jsg Exp $	*/
d949 6
a954 7
		if (isc->chiptype == CHIP_I965 ||
		    isc->chiptype == CHIP_G4X ||
		    isc->chiptype == CHIP_PINEVIEW ||
		    isc->chiptype == CHIP_G33 ||
		    isc->chiptype == CHIP_IRONLAKE ||
		    isc->chiptype == CHIP_SANDYBRIDGE ||
		    isc->chiptype == CHIP_IVYBRIDGE) {
d956 6
@


1.71
log
@Add minimal support for gen7/ivy bridge in inteldrm.
Like gen6/sandy bridge this is enough to manage memory but
does not attempt to setup the rings.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.70 2011/09/14 10:26:16 oga Exp $	*/
d597 1
@


1.70
log
@Initial kernel support for sandybridge intel chipsets in intagp and inteldrm.

Far from perfect. Extra (almost essential) features like the extra
ringbuffers are not yet supported (I have half a diff), but this and the
appropriate ddx patches allow modesetting and basic shadow acceleration.

Initial work by jcs@@, a few cleanups and bugfixes by me.

Tested by many on all appropriate chipsets. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.69 2010/09/06 15:00:50 oga Exp $	*/
d75 1
d205 8
d214 1
d271 1
d504 1
d639 1
d953 2
a954 1
		    isc->chiptype == CHIP_SANDYBRIDGE) {
d975 1
@


1.69
log
@Rev 1.67 of intagp (agp_i810.c) was added to deal with the problem
where stuff was bound for a software fallback while we were vt switched,
so we couldn't assume that the aperture was clear.

Turns out that the 855 at least does not like this (the !stolen bits of
the bar at least are write-only), and this caused a gpu lockup on any
suspend that used that activate handler.

So this diff fixes it in a more complete way:

Firstly revert 1.67 of agp_i810.c, secondly add a DVACT_QUIESCE handler
to inteldrm, and in it we do three things:

1) set a flag that causes any ioctl or pagefault to sleep until the flag
is cleared so that we don't end up with something doing the following
(for example:)
- bind object
- do another blocking operation in the same ioctl/fault
< suspend happens here, followed by resume>
- wake up assuming that the object is still bound and continue along our
merry way

2) Wait for all current entrypoints to finish (so that 1) is actually
effective we need to first quiesce our callers before we continue).

3) unbind everything that is in the gtt

On resume we clear the quiet flag, and everything can continue as
expected.

Behaves as expected for me on: 855 (x40 in acpi mode), gm965 (x61s) and
arrandale (x201) over multiple suspend cycles. Also tested by several on
tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.68 2010/08/31 19:20:55 oga Exp $	*/
d74 1
d187 1
d191 1
d196 8
d260 1
d492 79
d626 1
d928 2
a929 1
		printf("intagp: binding into stolen memory!\n");
d939 2
a940 1
		    isc->chiptype == CHIP_IRONLAKE) {
d960 1
@


1.68
log
@remove argnames from prototype.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.67 2010/08/06 13:09:52 oga Exp $	*/
a82 1
	u_int32_t		*gtt_backup;	/* saved gtt for suspend */
a300 8
	/*
	 * Backup array to save gtt contents on suspend since we may lose
	 * BAR contents. Most agp drivers do not have this problem since the
	 * GTT ptes are in dma memory.
	 */
	isc->gtt_backup = malloc(sizeof(*isc->gtt_backup) *
	    (isc->isc_apsize / 4096), M_AGP, M_NOWAIT | M_ZERO); 

d542 4
a546 13
	case DVACT_SUSPEND:
		/*
		 * most agp-like drivers have the GTT ptes in dma memory, so
		 * just need the setup to be repeated on resume.
		 * in this case the gtt is held in a BAR, and thus we should
		 * restore the data on resume to make sure that we
		 * don't lose any state that we are depending on.
		 */
		if (isc->gtt_backup != NULL) {
			bus_space_read_region_4(bst, bsh, offset,
			    isc->gtt_backup, isc->isc_apsize / 4096);
		}
		break;
a548 4
		if (isc->gtt_backup != NULL) {
			bus_space_write_region_4(bst, bsh, offset,
			    isc->gtt_backup, isc->isc_apsize / 4096);
		}
@


1.67
log
@Previous code to handle suspend/resume for intagp assumed that
everything was unbound before we go down.

Due to software fallbacks from the vt-switched X this is not strictly
true, so save/restore the gtt (which is stored in a BAR and thus
volatile).

i915 and i945 still have some (unrelated) coruption on dzen2 on resume
which I am looking for still (theory: fence registers), but this helps a
LOT of machines.

``commit''  deraadt@@. tested by many (and in snaps the last few days.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.66 2010/07/27 21:56:11 todd Exp $	*/
d94 1
a94 1
int	agp_i810_activate(struct device *arg, int act);
@


1.66
log
@spacing; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.65 2010/07/02 02:33:57 tedu Exp $	*/
d83 1
d302 8
d522 28
d552 13
d567 4
@


1.65
log
@braces define scope, not indentation.  found hunting uninit bugs. ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.64 2010/06/30 09:17:04 oga Exp $	*/
d514 1
a514 1
	switch(act) {
@


1.64
log
@add support for ironlake (clarkdale and arrandale, i.e. core i3 and core
i5 internal graphics) to intagp.

While technically this acts like a g4X here, add our own flag because I
anticipate crazy errata and practically costs nothing.

Including other diffs this was tested on two different x201's, a t510
and a t410, worked on all.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.63 2010/05/12 16:20:00 oga Exp $	*/
d497 1
a497 1
	if (isc->gatt)
d499 2
a500 2
			agp_free_dmamem(pa->pa_dmat, gatt->ag_size,
			    gatt->ag_dmamap, &gatt->ag_dmaseg);
d502 1
@


1.63
log
@Add Pineview M to intagp and inteldrm.

Tested (and initial tweaked diff) from Erik Mugele; thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.62 2010/05/09 19:40:37 oga Exp $	*/
d72 2
a73 1
	CHIP_PINEVIEW	= 8	/* Pineview/Pineview M */
d189 3
d248 1
d363 1
d409 1
a585 1

d801 5
d809 5
a813 2
		if (isc->chiptype == CHIP_I965 || isc->chiptype == CHIP_G4X ||
		    isc->chiptype == CHIP_PINEVIEW || isc->chiptype == CHIP_G33)
d815 1
d832 1
@


1.62
log
@Support Pineview IGD in intagp.

Tested by Jan Stary, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.61 2010/04/08 00:23:53 tedu Exp $	*/
d186 1
@


1.61
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.60 2010/04/07 20:40:18 oga Exp $	*/
d71 2
a72 1
	CHIP_G4X	= 7	/* G4X */
d185 2
d236 1
d266 2
a267 1
	if (isc->chiptype == CHIP_I915 || isc->chiptype == CHIP_G33) {
d356 1
d401 1
d797 2
a798 1
		if (isc->chiptype == CHIP_I965 || isc->chiptype == CHIP_G4X)
d808 1
@


1.60
log
@Make intagp restore pgtbl_ctl and the scratch page to the gtt on resume.

When we move more towards kms we'll need to save/restore what is bound
to the aperture, but right now this is not needed (since we always
unbind everything before we go down anyway).

"can not hurt" deraadt@@. tested by halex, deraadt and maybe some others.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.59 2010/03/03 10:19:34 oga Exp $	*/
a35 1
#include <sys/proc.h>
@


1.59
log
@Attach intagp on the G41 also.

tested by eric@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.58 2009/11/11 19:35:34 deraadt Exp $	*/
d92 2
d111 2
a112 1
	sizeof(struct agp_i810_softc), agp_i810_probe, agp_i810_attach
a469 4
	agp_flush_cache();
	/* Install the GATT. */
	WRITE4(AGP_I810_PGTBL_CTL, gatt->ag_physical | 1);

d476 36
d519 4
d527 1
a532 15

	isc->agpdev = (struct agp_softc *)agp_attach_bus(pa, &agp_i810_methods,
	    isc->isc_apaddr, isc->isc_apsize, &isc->dev);
	return;
out:

	if (isc->gatt)
		if (isc->gatt->ag_size != 0)
			agp_free_dmamem(pa->pa_dmat, gatt->ag_size,
			    gatt->ag_dmamap, &gatt->ag_dmaseg);
		free(isc->gatt, M_AGP);
	if (isc->gtt_map != NULL)
		vga_pci_bar_unmap(isc->gtt_map);
	if (isc->map != NULL)
		vga_pci_bar_unmap(isc->map);
@


1.58
log
@memory leaks found by parfait; ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.57 2009/06/06 11:11:10 oga Exp $	*/
d180 1
@


1.57
log
@unfuck the rest of the way. when we bind the scribble pages to the
aperture, skip over dcache on i810 chipsets and stolen memory on later
chips.

I didn't notice this before because I mostly used this code with GEM
code, which doesn't use the stolen memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.56 2009/06/06 10:56:30 oga Exp $	*/
d623 2
a624 1
		    M_WAITOK | M_CANFAIL)) == NULL)
d626 1
d630 1
@


1.56
log
@unfuck slightly, offset was wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.55 2009/06/06 06:02:44 oga Exp $	*/
d476 6
d484 1
a484 1
	for (tmp = isc->isc_apaddr; tmp < (isc->isc_apaddr + isc->isc_apsize);
@


1.55
log
@add an interface to agp to create a bus_dma_tag over a range of the
aperture, which will take your memory, bind it to agp, and return you the
aperture address. It's essentially the same as iommu on amd64 in the way it
works.

This will be used by the upcoming (works but is slow and will not be
enabled at first) drm memory management code for intel igp chipsets.

Right now the sync function for intagp is really slow (doing a wbinvd()
on every sync), this is in the process of getting fixed, but the size of
the diffs in my trees was getting silly.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.54 2009/05/24 02:06:15 oga Exp $	*/
d698 1
a698 1
			agp_i810_bind_page(isc, offset + i,
d728 2
a729 1
			agp_i810_unbind_page(isc, mem->am_offset + i);
@


1.54
log
@If flags to bind_page include BUS_DMA_COHERENT, set the snooped bit on
the pte.

This is currently unused, but will be used soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.53 2009/05/24 01:40:58 oga Exp $	*/
d77 1
d82 1
d105 3
d120 1
d220 1
a220 1
	bus_addr_t			 mmaddr, gmaddr;
d470 12
d556 2
a557 1
	intagp_write_gtt(isc, offset - isc->isc_apaddr, 0);
d698 2
a699 1
			intagp_write_gtt(isc, offset + i, mem->am_physical + i);
d728 1
a728 1
			intagp_write_gtt(isc, mem->am_offset + i, 0);
@


1.53
log
@Instead of using magic numbers, define the bits that we set in gtt ptes
and use those defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.52 2009/05/10 16:57:44 oga Exp $	*/
d522 7
@


1.52
log
@Change agp attach (again) so that the driver passes in the aperture size.

While the aperture size may change during attach, it never changes after
the end of the subdriver attach function, so getting this value with a
function is a waste of time. shrinks things slightly and makes the code
clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.51 2009/05/10 15:28:45 oga Exp $	*/
d54 10
d666 2
a667 1
		WRITE4(AGP_I810_PGTBL_CTL, isc->gatt->ag_physical | 1);
d685 1
a685 1
		intagp_write_gtt(isc, i, i | 3);
d726 1
a726 1
		pte = v | 1;
@


1.51
log
@In preparation for using agp as a bus_dma backend for drm, convert the bind_page
and unbind_page callbacks from

int bind_page(void *, off_t, bus_addr_t)

to

void bind_page(void *, bus_addr_t, paddr_t, int)

We can make these function void by making sure that the agp code sanity
checks properly (it already mostly did), so by definition these
functions may not fail.  The flags field is currently unused (intagp at
least will have a use for it soon).

Been in my tree for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.50 2009/05/10 14:44:42 oga Exp $	*/
d72 1
a72 1
	bus_size_t		 aperture;	/* current aperture size */
a81 1
bus_size_t agp_i810_get_aperture(void *);
a101 1
	agp_i810_get_aperture,
d232 2
a233 2
	    &isc->isc_apaddr, &isc->aperture, NULL) != 0) {
		printf("can't get aperture size\n");
d259 1
a259 1
	gatt->ag_entries = isc->aperture >> AGP_PAGE_SHIFT;
d460 1
a460 1
	    isc->isc_apaddr, &isc->dev);
a506 8

bus_size_t
agp_i810_get_aperture(void *sc)
{
	struct agp_i810_softc	*isc = sc;

	return (isc->aperture);
}
@


1.50
log
@change agp driver attach so that the driver passes in the base address
of its aperture, instead of the BAR and memory type. This is a little
larger, but allows the driver to know it's aperture address. Needed for
some future stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.49 2009/04/29 22:03:09 oga Exp $	*/
d83 2
a84 2
int	agp_i810_bind_page(void *, off_t, bus_addr_t);
int	agp_i810_unbind_page(void *, off_t);
d89 1
a89 1
int	agp_i810_bind_memory(void *, struct agp_memory *, off_t);
d91 1
a91 1
void	intagp_write_gtt(struct agp_i810_softc *, bus_size_t, u_int32_t);
d518 2
a519 2
int
agp_i810_bind_page(void *sc, off_t offset, bus_addr_t physical)
d523 1
a523 19
	if (offset < 0 || offset >= (isc->gatt->ag_entries << AGP_PAGE_SHIFT)) {
#ifdef DEBUG
		printf("agp: failed: offset 0x%08x, shift %d, entries %d\n",
		    (int)offset, AGP_PAGE_SHIFT, isc->gatt->ag_entries);
#endif
		return (EINVAL);
	}

	if (isc->chiptype != CHIP_I810) {
		if ((offset >> AGP_PAGE_SHIFT) < isc->stolen) {
#ifdef DEBUG
			printf("agp: trying to bind into stolen memory\n");
#endif
			return (EINVAL);
		}
	}

	intagp_write_gtt(isc, offset, physical);
	return (0);
d526 2
a527 2
int
agp_i810_unbind_page(void *sc, off_t offset)
d531 1
a531 14
	if (offset < 0 || offset >= (isc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	if (isc->chiptype != CHIP_I810 ) {
		if ((offset >> AGP_PAGE_SHIFT) < isc->stolen) {
#ifdef DEBUG
			printf("agp: trying to unbind from stolen memory\n");
#endif
			return (EINVAL);
		}
	}

	intagp_write_gtt(isc, offset, 0);
	return (0);
d640 1
a640 1
agp_i810_bind_memory(void *sc, struct agp_memory *mem, off_t offset)
d647 9
d719 1
a719 1
intagp_write_gtt(struct agp_i810_softc *isc, bus_size_t off, u_int32_t v)
@


1.49
log
@Apply the cleanup stick.

make write_gatt actually readable, and a tad smaller. Don't use macros when we
can just call the damned function. coalesce a few bits of code.

as a bonus this actually fixes a bus in the i810/815 dcache case since we got
the offset wrong (confirmed by looking at the datasheet).
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.48 2009/04/20 01:28:45 oga Exp $	*/
d71 2
a73 1
	bus_size_t		 aperture;	/* current aperture size */
d234 1
a234 1
	    NULL, &isc->aperture, NULL) != 0) {
d462 1
a462 1
	    gmaddr, memtype, &isc->dev);
@


1.48
log
@Don't map all agp memory we allocate.

If we're just going to be making it available to userland (the X
server), just use load_raw and make sure it's zeroed with BUS_DMA_ZERO.
Should save $AMOUNT_BOUND_TO_GART kva. Most kernel users also write
through the gart, so no mapping there either.

tested by sthen and todd a while back.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.47 2009/04/15 03:09:20 oga Exp $	*/
a53 3
#define WRITEGTT(off,v)	bus_space_write_4(isc->gtt_map->bst, isc->gtt_map->bsh, off, v)
#define WRITE_GATT(off,v)	agp_i810_write_gatt(isc, off, v)

d90 1
a90 1
void	agp_i810_write_gatt(struct agp_i810_softc *, bus_size_t, u_int32_t);
d206 3
a208 1
	pcireg_t			 memtype;
d272 2
a273 1
	if (isc->chiptype == CHIP_I810) {
d290 1
d292 1
a292 4
		agp_flush_cache();
		/* Install the GATT. */
		WRITE4(AGP_I810_PGTBL_CTL, gatt->ag_physical | 1);
	} else if (isc->chiptype == CHIP_I830) {
a293 3
		pcireg_t reg;
		u_int32_t pgtblctl;
		u_int16_t gcc1;
d321 2
a322 3
		pgtblctl = READ4(AGP_I810_PGTBL_CTL);
		pgtblctl |= 1;
		WRITE4(AGP_I810_PGTBL_CTL, pgtblctl);
d324 9
a332 7
		gatt->ag_physical = pgtblctl & ~1;
	} else if (isc->chiptype == CHIP_I855 || isc->chiptype == CHIP_I915 ||
		   isc->chiptype == CHIP_I965 || isc->chiptype == CHIP_G33 ||
		   isc->chiptype == CHIP_G4X) {
		pcireg_t reg;
		u_int32_t pgtblctl, stolen;
		u_int16_t gcc1;
d444 2
a445 3
		pgtblctl = READ4(AGP_I810_PGTBL_CTL);
		pgtblctl |= 1;
		WRITE4(AGP_I810_PGTBL_CTL, pgtblctl);
d447 3
a449 1
		gatt->ag_physical = pgtblctl & ~1;
d451 3
d539 1
a539 1
	WRITE_GATT(offset, physical);
d560 1
a560 1
	WRITE_GATT(offset, 0);
d596 1
a596 3
		if (isc->chiptype != CHIP_I810 )
			return (NULL);
		if (size != isc->dcache_size)
d691 2
a692 3
		for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE) {
			WRITE_GATT(offset + i, (mem->am_physical + i));
		}
d705 1
a705 2
		WRITE4(AGP_I810_GTT +
		    (u_int32_t)(offset >> AGP_PAGE_SHIFT) * 4, i | 3);
d720 2
a721 3
		for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE) {
			WRITE_GATT(mem->am_offset + i, 0);
		}
d734 1
a734 1
		WRITE4(AGP_I810_GTT + (i >> AGP_PAGE_SHIFT) * 4, 0);
d740 1
a740 1
agp_i810_write_gatt(struct agp_i810_softc *isc, bus_size_t off, u_int32_t v)
d742 9
a750 1
	u_int32_t d;
d752 1
a752 1
	d = v | 1;
d754 18
a771 10
	if (isc->chiptype == CHIP_I915 || isc->chiptype == CHIP_G33)
		WRITEGTT((u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, v ? d : 0);
	else if (isc->chiptype == CHIP_I965 || isc->chiptype == CHIP_G4X) {
		d |= (v & 0x0000000f00000000ULL) >> 28;
		WRITE4((isc->chiptype == CHIP_I965 ? AGP_I965_GTT : AGP_G4X_GTT)
		    + (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4,
		    v ? d : 0);
	} else
		WRITE4(AGP_I810_GTT + (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4,
		    v ? d : 0);
@


1.47
log
@Add a bit of sanity-checking paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.46 2009/02/17 18:41:32 oga Exp $	*/
d254 1
a254 1
	gatt = malloc(sizeof(*gatt), M_AGP, M_NOWAIT);
a273 1
		int dummyseg;
d281 2
a282 3
		if (agp_alloc_dmamem(pa->pa_dmat, 64 * 1024,
		    0, &gatt->ag_dmamap, (caddr_t *)&gatt->ag_virtual,
		    &gatt->ag_physical, &gatt->ag_dmaseg, 1, &dummyseg) != 0) {
d285 1
d287 3
a289 2
		gatt->ag_size = gatt->ag_entries * sizeof(u_int32_t);
		memset(gatt->ag_virtual, 0, gatt->ag_size);
d464 1
d466 3
d498 2
d501 1
a501 1
		    (void *)gatt->ag_virtual, &gatt->ag_dmaseg, 1);
d622 6
a627 6
		mem->am_dmaseg = malloc(sizeof *mem->am_dmaseg, M_AGP,
		    M_WAITOK);
		if ((error = agp_alloc_dmamem(sc->sc_dmat, size, 0,
		    &mem->am_dmamap, &mem->am_virtual, &mem->am_physical,
		    mem->am_dmaseg, 1, &mem->am_nseg)) != 0) {
			free(mem->am_dmaseg, M_AGP);
a631 1
		memset(mem->am_virtual, 0, size);
d659 1
a659 1
		    mem->am_virtual, mem->am_dmaseg, mem->am_nseg);
@


1.46
log
@Don't leak the dmamap on freeing memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.45 2009/01/03 13:07:15 kevlo Exp $	*/
d672 2
d714 3
@


1.45
log
@Attach agp(4) to the Intel 946GZ integrated video.
Tested on Asus P5B-MX motherboard.

ok kettenis@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.44 2008/12/24 05:42:58 oga Exp $	*/
d656 2
@


1.44
log
@Fix support for earlier i8XX chipsets (specifically the 830 and 840).

Earlier changes meant that we were reading the wrong register, on the
graphics card instead of the gmch (bus 0, device 0, function 0. it's the
memory controller on all boards with intel chipsets).  Later chipsets
have a ``mirror'' register on the graphics card device, explaining why
this didn't manifest on all chipsets. For simplicity, always find and
read the register from the GMCH. While i'm here, fixup unaligned
configuration space access (0x50 vs 0x52)

Tested by several.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.43 2008/12/23 22:01:38 oga Exp $	*/
d145 2
@


1.43
log
@intagp support for Intel 4-series (e.g. GM45) chipsets.

Tested by several x200 owners.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.42 2008/11/09 15:11:19 oga Exp $	*/
d94 1
d172 15
d204 1
a204 1
	struct pci_attach_args		*pa = aux;
d261 10
d298 1
a298 1
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AGP_I830_GCC1);
d341 1
a341 1
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AGP_I855_GCC1);
a436 1

a443 1

@


1.42
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.41 2008/09/26 21:15:53 mikeb Exp $	*/
d64 2
a65 1
	CHIP_G33	= 6	/* G33/Q33/Q35 */
d162 5
d203 1
d293 2
a294 1
		}
d304 2
a305 1
		   isc->chiptype == CHIP_I965 || isc->chiptype == CHIP_G33) {
d352 9
d394 12
d411 1
d416 2
a417 1
		}
d420 1
d715 1
a715 1
	else if (isc->chiptype == CHIP_I965) {
d717 2
a718 1
		WRITE4(AGP_I965_GTT + (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4,
@


1.41
log
@Attach agp(4) to the Intel Q35 integrated video.
Tested on ASUS P5E-VM DO motherboard.

ok oga
@
text
@d1 1
a1 2
/*	$OpenBSD: agp_i810.c,v 1.40 2008/07/12 17:31:06 oga Exp $	*/
/*	$NetBSD: agp_i810.c,v 1.15 2003/01/31 00:07:39 thorpej Exp $	*/
a28 1
 *	$FreeBSD: src/sys/pci/agp_i810.c,v 1.4 2001/07/05 21:28:47 jhb Exp $
a30 1

d50 3
a52 5
#include "agp_intel.h"

#define READ1(off)	bus_space_read_1(isc->bst, isc->bsh, off)
#define READ4(off)	bus_space_read_4(isc->bst, isc->bsh, off)
#define WRITE4(off,v)	bus_space_write_4(isc->bst, isc->bsh, off, v)
d54 1
a54 1
#define WRITEGTT(off,v)	bus_space_write_4(isc->gtt_bst, isc->gtt_bsh, off, v)
a56 1

d58 7
a64 6
	CHIP_I810	= 0,	/* i810/i815 */
	CHIP_I830	= 1,	/* i830/i845 */
	CHIP_I855	= 2,	/* i852GM/i855GM/i865G */
	CHIP_I915	= 3,	/* i915G/i915GM */
	CHIP_I965	= 4,	/* i965/i965GM */
	CHIP_G33	= 5	/* G33/Q33/Q35 */
d68 10
a77 13
	u_int32_t	initial_aperture;/* aperture size at startup */
	struct agp_gatt
			*gatt;
	int		chiptype;	/* i810-like or i830 */
	u_int32_t	dcache_size;	/* i810 only */
	u_int32_t	stolen;		/* number of i830/845 gtt entries
					   for stolen memory */
	bus_space_tag_t	bst;		/* bus_space tag */
	bus_space_handle_t bsh;		/* bus_space handle */
	bus_size_t	bsz;			/* bus_space size */
	bus_space_tag_t	gtt_bst;	/* GATT bus_space tag */
	bus_space_handle_t gtt_bsh;	/* GATT bus_space handle */
	struct pci_attach_args vga_pa;
d80 12
a91 11
int	agp_i810_vgamatch(struct pci_attach_args *);
int	agp_i810_set_aperture(struct agp_softc *, u_int32_t);
int	agp_i810_bind_page(struct agp_softc *, off_t, bus_addr_t);
int	agp_i810_unbind_page(struct agp_softc *, off_t);
void	agp_i810_flush_tlb(struct agp_softc *);
int	agp_i810_enable(struct agp_softc *, u_int32_t mode);
struct agp_memory * agp_i810_alloc_memory(struct agp_softc *, int, vsize_t);
int	agp_i810_free_memory(struct agp_softc *, struct agp_memory *);
int	agp_i810_bind_memory(struct agp_softc *, struct agp_memory *,
	    off_t);
int	agp_i810_unbind_memory(struct agp_softc *, struct agp_memory *);
d94 8
d103 1
a103 2
	agp_generic_get_aperture,
	agp_i810_set_aperture,
a113 1
/* XXXthorpej -- duplicated code (see arch/i386/pci/pchb.c) */
d115 1
a115 1
agp_i810_vgamatch(struct pci_attach_args *pa)
a116 5

	if (PCI_CLASS(pa->pa_class) != PCI_CLASS_DISPLAY ||
	    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_DISPLAY_VGA)
		return (0);

d122 1
a122 76
	case PCI_PRODUCT_INTEL_82830M_IGD:
	case PCI_PRODUCT_INTEL_82845G_IGD:
	case PCI_PRODUCT_INTEL_82855GM_IGD:
	case PCI_PRODUCT_INTEL_82865G_IGD:
	case PCI_PRODUCT_INTEL_82915G_IGD_1:
	case PCI_PRODUCT_INTEL_82915G_IGD_2:
	case PCI_PRODUCT_INTEL_82915GM_IGD_1:
	case PCI_PRODUCT_INTEL_82915GM_IGD_2:
	case PCI_PRODUCT_INTEL_82945G_IGD_1:
	case PCI_PRODUCT_INTEL_82945G_IGD_2:
	case PCI_PRODUCT_INTEL_82945GM_IGD_1:
	case PCI_PRODUCT_INTEL_82945GM_IGD_2:
	case PCI_PRODUCT_INTEL_82945GME_IGD_1:
	case PCI_PRODUCT_INTEL_82G965_IGD_1:
	case PCI_PRODUCT_INTEL_82G965_IGD_2:
	case PCI_PRODUCT_INTEL_82Q965_IGD_1:
	case PCI_PRODUCT_INTEL_82Q965_IGD_2:
	case PCI_PRODUCT_INTEL_82GM965_IGD_1:
	case PCI_PRODUCT_INTEL_82GM965_IGD_2:
	case PCI_PRODUCT_INTEL_82GME965_IGD_1:
	case PCI_PRODUCT_INTEL_82GME965_IGD_2:
	case PCI_PRODUCT_INTEL_82G33_IGD_1:
	case PCI_PRODUCT_INTEL_82G33_IGD_2:
	case PCI_PRODUCT_INTEL_82G35_IGD_1:
	case PCI_PRODUCT_INTEL_82G35_IGD_2:
	case PCI_PRODUCT_INTEL_82Q35_IGD_1:
	case PCI_PRODUCT_INTEL_82Q35_IGD_2:
		return (1);
	}

	return (0);
}

int
agp_i810_attach(struct agp_softc *sc, struct pci_attach_args *pa)
{
	struct agp_i810_softc *isc;
	struct agp_gatt *gatt;
	bus_addr_t mmaddr, gmaddr;
	struct vga_pci_bar *map;
	int error;
	u_int memtype = 0;

	isc = malloc(sizeof *isc, M_AGP, M_NOWAIT | M_ZERO);
	if (isc == NULL) {
		printf("can't allocate chipset-specific softc\n");
		return (ENOMEM);
	}
	sc->sc_chipc = isc;
	sc->sc_methods = &agp_i810_methods;

	if (pci_find_device(&isc->vga_pa, agp_i810_vgamatch) == 0) {
#if NAGP_INTEL > 0

		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_INTEL_82815_HB:
		case PCI_PRODUCT_INTEL_82845G_HB:
		case PCI_PRODUCT_INTEL_82865G_HB:
			return (agp_intel_attach(sc, pa));
		}
#endif
		printf("no integrated graphics\n");
		free(isc, M_AGP);
		return (ENOENT);
	}

	/* XXXfvdl */
	sc->sc_dmat = isc->vga_pa.pa_dmat;
	sc->sc_memt = isc->vga_pa.pa_memt;

	switch (PCI_PRODUCT(isc->vga_pa.pa_id)) {
	case PCI_PRODUCT_INTEL_82810_IGD:
	case PCI_PRODUCT_INTEL_82810_DC100_IGD:
	case PCI_PRODUCT_INTEL_82810E_IGD:
	case PCI_PRODUCT_INTEL_82815_IGD:
		isc->chiptype = CHIP_I810;
d126 1
a126 1
		isc->chiptype = CHIP_I830;
d130 1
a130 1
		isc->chiptype = CHIP_I855;
d141 1
a141 1
		isc->chiptype = CHIP_I915;
d153 1
a153 1
		isc->chiptype = CHIP_I965;
d159 1
a159 1
		isc->chiptype = CHIP_G33;
d162 26
d208 4
a211 5
	error = agp_map_aperture(&isc->vga_pa, sc, gmaddr, memtype);
	if (error != 0) {
		printf("can't map aperture\n");
		free(isc, M_AGP);
		return (error);
d214 2
a215 3
	map = vga_pci_bar_map(sc->vga_softc, mmaddr, 0,
	    BUS_SPACE_MAP_LINEAR);
	if (map == NULL) {
d217 1
a217 2
		agp_generic_detach(sc);
		return (error);
a218 3
	isc->bst = map->bst;
	isc->bsh = map->bsh;
	isc->bsz = map->size;
d221 3
a223 3
		map = vga_pci_bar_map(sc->vga_softc, AGP_I915_GTTADR,
		    0, BUS_SPACE_MAP_LINEAR);
		if (map == NULL) {
d225 1
a225 2
			agp_generic_detach(sc);
			return (error);
a226 2
		isc->gtt_bst = map->bst;
		isc->gtt_bsh =  map->bsh;
d229 4
a232 6
	isc->initial_aperture = AGP_GET_APERTURE(sc);

	gatt = malloc(sizeof(struct agp_gatt), M_AGP, M_NOWAIT);
	if (!gatt) {
 		agp_generic_detach(sc);
 		return (ENOMEM);
d236 1
a236 1
	gatt->ag_entries = AGP_GET_APERTURE(sc) >> AGP_PAGE_SHIFT;
d247 1
a247 1
		if (agp_alloc_dmamem(sc->sc_dmat, 64 * 1024,
d250 1
a250 3
			free(gatt, M_AGP);
			agp_generic_detach(sc);
			return (ENOMEM);
d265 1
a265 1
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I830_GCC1);
d280 1
a280 2
			agp_generic_detach(sc);
			return (EINVAL);
d306 1
a306 1
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I855_GCC1);
d345 1
a345 2
			agp_generic_detach(sc);
			return (EINVAL);
d379 1
a379 2
			agp_generic_detach(sc);
			return (EINVAL);
d401 10
a410 1
	return (0);
a433 3
	/* Put the aperture back the way it started. */
	AGP_SET_APERTURE(sc, isc->initial_aperture);

d444 2
a445 2
int
agp_i810_set_aperture(struct agp_softc *sc, u_int32_t aperture)
d447 1
a447 3
	struct agp_i810_softc *isc = sc->sc_chipc;
	pcireg_t reg;
	u_int16_t gcc1, miscc;
d449 1
a449 49
	switch (isc->chiptype) {
	case CHIP_I810:
		/*
		 * Double check for sanity.
		 */
		if (aperture != (32 * 1024 * 1024) &&
		    aperture != (64 * 1024 * 1024)) {
			printf("agp: bad aperture size %d\n", aperture);
			return (EINVAL);
		}

		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I810_SMRAM);
		miscc = (u_int16_t)(reg >> 16);
		miscc &= ~AGP_I810_MISCC_WINSIZE;
		if (aperture == 32 * 1024 * 1024)
			miscc |= AGP_I810_MISCC_WINSIZE_32;
		else
			miscc |= AGP_I810_MISCC_WINSIZE_64;

		reg &= 0x0000ffff;
		reg |= ((pcireg_t)miscc) << 16;
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_I810_SMRAM, reg);
		break;
	case CHIP_I830:
		if (aperture != (64 * 1024 * 1024) &&
		    aperture != (128 * 1024 * 1024)) {
			printf("agp: bad aperture size %d\n", aperture);
			return (EINVAL);
		}
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I830_GCC0);
		gcc1 = (u_int16_t)(reg >> 16);
		gcc1 &= ~AGP_I830_GCC1_GMASIZE;
		if (aperture == 64 * 1024 * 1024)
			gcc1 |= AGP_I830_GCC1_GMASIZE_64;
		else
			gcc1 |= AGP_I830_GCC1_GMASIZE_128;

		reg &= 0x0000ffff;
		reg |= ((pcireg_t)gcc1) << 16;
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_I830_GCC0, reg);
		break;
	case CHIP_I855:
	case CHIP_I915:
	case CHIP_I965:
	case CHIP_G33:
		return agp_generic_set_aperture(sc, aperture);
	}

	return (0);
d453 1
a453 1
agp_i810_bind_page(struct agp_softc *sc, off_t offset, bus_addr_t physical)
d455 1
a455 1
	struct agp_i810_softc *isc = sc->sc_chipc;
d460 1
a460 2
		    (int)offset, AGP_PAGE_SHIFT,
		    isc->gatt->ag_entries);
d479 1
a479 1
agp_i810_unbind_page(struct agp_softc *sc, off_t offset)
d481 1
a481 1
	struct agp_i810_softc *isc = sc->sc_chipc;
d503 1
a503 1
agp_i810_flush_tlb(struct agp_softc *sc)
d508 1
a508 1
agp_i810_enable(struct agp_softc *sc, u_int32_t mode)
d514 1
a514 1
agp_i810_alloc_memory(struct agp_softc *sc, int type, vsize_t size)
d516 4
a519 3
	struct agp_i810_softc *isc = sc->sc_chipc;
	struct agp_memory *mem;
	int error;
d522 1
a522 1
		return (0);
d585 1
a585 1
agp_i810_free_memory(struct agp_softc *sc, struct agp_memory *mem)
d587 3
d606 1
a606 2
agp_i810_bind_memory(struct agp_softc *sc, struct agp_memory *mem,
		     off_t offset)
d608 2
a609 2
	struct agp_i810_softc *isc = sc->sc_chipc;
	u_int32_t regval, i;
d617 1
a617 2

	regval = bus_space_read_4(isc->bst, isc->bsh, AGP_I810_PGTBL_CTL);
a618 1
#if DEBUG
d621 1
a621 3
#endif
		bus_space_write_4(isc->bst, isc->bsh, AGP_I810_PGTBL_CTL,
		    isc->gatt->ag_physical | 1);
d634 1
a634 1
		return (agp_generic_bind_memory(sc, mem, offset));
d647 1
a647 1
agp_i810_unbind_memory(struct agp_softc *sc, struct agp_memory *mem)
d649 2
a650 2
	struct agp_i810_softc *isc = sc->sc_chipc;
	u_int32_t i;
d662 1
a662 1
		return (agp_generic_unbind_memory(sc, mem));
d684 2
a685 2
		WRITE4(AGP_I965_GTT +
		    (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, v ? d : 0);
d687 2
a688 2
		WRITE4(AGP_I810_GTT +
		    (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, v ? d : 0);
@


1.40
log
@Right now agp_generic_enable() is wrong. It has been since 2006. It
assumes that the display device and the agp bridge are the same device.
In almost all cases this is incorrect.

In order to correctly enable the agp device with the correct mode, we
need to set the AGP_COMMAND register on both the display and the bridge
with the right bits. Since agp is currently attaching at vga(4), due to
the problems with the intel integrated graphics (a problem that I still
need to solve, to be honest), for now just provide both pci_attach_args
to the agp init, and get what we need from there to do the enable.

This fixes the "agp bug" which i have been known to rant about, a lot.
So agp radeons now work with dri without needing to be forced to pci
mode.

This wasn't detected before, since the only non-drm consumer of agp is
the intel X driver, the i810 agp driver has its own enable function.

tested by many. ok kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.39 2008/07/07 07:54:48 bernd Exp $	*/
d153 2
d238 2
@


1.39
log
@Add AGP and hostbridge support for the Intel 82945GME chipset.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.38 2008/06/25 18:54:06 oga Exp $	*/
d194 1
@


1.38
log
@Support the Intel G35 which apparently works similarly to the 965.

Initial information, half the diff, and testing from Andrew Lutomirski,
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.37 2008/06/11 17:21:46 matthieu Exp $	*/
d140 1
d218 1
@


1.37
log
@Move a debug printf into #ifdef DEBUG. ok todd@@, millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.36 2008/05/16 19:47:54 reyk Exp $	*/
d150 2
d227 2
@


1.36
log
@add Intel GME965

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.34 2008/03/23 19:54:47 oga Exp $	*/
d644 1
d646 1
@


1.35
log
@currently agp_i810 needs to map the same BAR as inteldrm, this obviously
fails.

In order to allow this, implement an API so that drm and agp can share
mappings for the BARs. Now it works as it should.

tested by many.
ok kettenis, miod said he'd look at it when it's in tree.
@
text
@d146 2
d223 2
@


1.34
log
@Sometimes the registers claiming the aperture size on 9XX chipsets lie.

So instead, use the size of the aperture BAR to determine the aperture
size for agp_i810, and don't let the 855 and above have the aperture
set. Next to nothing uses it anyway so no harm.

introduce generic_{get,set} aperture which has this behaviour so other
drivers may use it if useful.

Change inspired by what freebsd did after i noticed my aperture size was
wrong.

Tested by many, ok kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.33 2008/03/23 08:36:41 damien Exp $	*/
d160 1
d255 3
a257 7
	if (isc->chiptype == CHIP_I965) 
		memtype = pci_mapreg_type(isc->vga_pa.pa_pc,
		    isc->vga_pa.pa_tag, mmaddr);

	error = pci_mapreg_map(&isc->vga_pa, mmaddr, memtype, 0,
	    &isc->bst, &isc->bsh, NULL, &isc->bsz, 0);
	if (error != 0) {
d262 3
d267 3
a269 3
		error = pci_mapreg_map(&isc->vga_pa, AGP_I915_GTTADR, memtype,
		    0, &isc->gtt_bst, &isc->gtt_bsh, NULL, NULL, 0);
		if (error != 0) {
d274 2
@


1.33
log
@Add AGP support for the Intel G33 chipset.
Tested on i386 with a Gigabyte G33M-DS2R motherboard (Intel GMA 3100).
Based on NetBSD code.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.32 2008/01/04 00:23:26 kettenis Exp $	*/
a88 1
u_int32_t agp_i810_get_aperture(struct agp_softc *);
d102 1
a102 1
	agp_i810_get_aperture,
a491 48
u_int32_t
agp_i810_get_aperture(struct agp_softc *sc)
{
	struct agp_i810_softc *isc = sc->sc_chipc;
	pcireg_t reg;

	if (isc->chiptype == CHIP_I810) {
		u_int16_t miscc;

		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I810_SMRAM);
		miscc = (u_int16_t)(reg >> 16);
		if ((miscc & AGP_I810_MISCC_WINSIZE) ==
		    AGP_I810_MISCC_WINSIZE_32)
			return (32 * 1024 * 1024);
		else
			return (64 * 1024 * 1024);
	} else if (isc->chiptype == CHIP_I830) {
		u_int16_t gcc1;

		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I830_GCC0);
		gcc1 = (u_int16_t)(reg >> 16);
		if ((gcc1 & AGP_I830_GCC1_GMASIZE) == AGP_I830_GCC1_GMASIZE_64)
			return (64 * 1024 * 1024);
		else
			return (128 * 1024 * 1024);
	} else if (isc->chiptype == CHIP_I915 || isc->chiptype == CHIP_G33) {
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I915_MSAC);
		if ((reg & AGP_I915_MSAC_GMASIZE) == AGP_I915_MSAC_GMASIZE_128) {
			return (128 * 1024 * 1024);
		} else {
			return (256 * 1024 * 1024);
		}
	} else if (isc->chiptype == CHIP_I965) {
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I965_MSAC);
		switch (reg & AGP_I965_MSAC_GMASIZE) {
		case AGP_I965_MSAC_GMASIZE_128:
			return (128 * 1024 * 1024);
		case AGP_I965_MSAC_GMASIZE_256:
			return (256 * 1024 * 1024);
		case AGP_I965_MSAC_GMASIZE_512:
			return (512 * 1024 * 1024);
		}
	}

	/* CHIP_I855 */
	return (128 * 1024 * 1024);
}

d497 1
d499 2
a500 3
	if (isc->chiptype == CHIP_I810) {
		u_int16_t miscc;

d521 2
a522 3
	} else if (isc->chiptype == CHIP_I830) {
		u_int16_t gcc1;

d539 6
a544 36
	} else if (isc->chiptype == CHIP_I915) {
		if (aperture != (128 * 1024 * 1024) &&
		    aperture != (256 * 1024 * 1024)) {
			printf("agp: bad aperture size %d\n", aperture);
			return (EINVAL);
		}
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I915_MSAC);
		reg &= ~AGP_I915_MSAC_GMASIZE;
		if (aperture == (128 * 1024 * 1024))
			reg |= AGP_I915_MSAC_GMASIZE_128;
		else
			reg |= AGP_I915_MSAC_GMASIZE_256;
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_I915_MSAC, reg);
	} else if (isc->chiptype == CHIP_I965) {
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I965_MSAC);
		reg &= ~AGP_I965_MSAC_GMASIZE;
		switch (aperture) {
		case (128 * 1024 * 1024):
			reg |= AGP_I965_MSAC_GMASIZE_128;
			break;
		case (256 * 1024 * 1024):
			reg |= AGP_I965_MSAC_GMASIZE_256;
			break;
		case (512 * 1024 * 1024):
			reg |= AGP_I965_MSAC_GMASIZE_512;
			break;
		default:
			printf("agp: bad aperture size %d\n", aperture);
			return (EINVAL);
		}
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_I965_MSAC, reg);
	} else {	/* CHIP_I855, CHIP_G33 */
		if (aperture != (128 * 1024 * 1024)) {
			printf("agp: bad aperture size %d\n", aperture);
			return (EINVAL);
		}
@


1.32
log
@Clean up Intel host bridge PCI IDs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.31 2007/12/19 11:25:16 oga Exp $	*/
d68 2
a69 1
	CHIP_I965	= 4	/* i965/i965GM */
d147 2
d223 4
d231 1
d267 1
a267 1
	if (isc->chiptype == CHIP_I915) {
d349 1
a349 1
		   isc->chiptype == CHIP_I965) {
d355 1
a355 1
                 * the BIOS, consisting of the GATT followed by 4kb for the
d357 4
a360 1
                 */
d385 11
d400 1
a400 1
               }
a401 2
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I855_GCC1);
		gcc1 = (u_int16_t)(reg >> 16);
d518 1
a518 1
	} else if (isc->chiptype == CHIP_I915) {
d620 1
a620 1
	} else {	/* CHIP_I855 */
d858 1
a858 1
	if (isc->chiptype == CHIP_I915)
@


1.31
log
@Fix the issue with some intel 965 host busses. Though the docs claim that the
mmaddr BAR is alway 64-bit, they lie. one some bridges it's not.

Fix this by  checking which type of memory it is before trying to map.

Advice and ok kettenis@@, Tested by myself and Matthew L. Shobe
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.30 2007/12/10 21:54:51 oga Exp $	*/
d124 5
a128 5
	case PCI_PRODUCT_INTEL_82810_GC:
	case PCI_PRODUCT_INTEL_82810_DC100_GC:
	case PCI_PRODUCT_INTEL_82810E_GC:
	case PCI_PRODUCT_INTEL_82815_FULL_GRAPH:
	case PCI_PRODUCT_INTEL_82830MP_IV:
d130 6
a135 4
	case PCI_PRODUCT_INTEL_82852GM_AGP:
	case PCI_PRODUCT_INTEL_82865_IGD:
	case PCI_PRODUCT_INTEL_82915G_IGD:
	case PCI_PRODUCT_INTEL_82915GM_IGD:
d137 9
a145 8
	case PCI_PRODUCT_INTEL_82945GM_IGD:
	case PCI_PRODUCT_INTEL_82945GM_IGD_S:
	case PCI_PRODUCT_INTEL_82Q963_IGD_1:
	case PCI_PRODUCT_INTEL_82Q963_IGD_2:
	case PCI_PRODUCT_INTEL_82965_IGD_1:
	case PCI_PRODUCT_INTEL_82965_IGD_2:
	case PCI_PRODUCT_INTEL_82965GM_IGD_1:
	case PCI_PRODUCT_INTEL_82965GM_IGD_2:
d173 3
a175 4
		case PCI_PRODUCT_INTEL_82840_HB:
		case PCI_PRODUCT_INTEL_82865_IO_1:
		case PCI_PRODUCT_INTEL_82845G:
		case PCI_PRODUCT_INTEL_82815_FULL_HUB:
d188 4
a191 4
	case PCI_PRODUCT_INTEL_82810_GC:
	case PCI_PRODUCT_INTEL_82810_DC100_GC:
	case PCI_PRODUCT_INTEL_82810E_GC:
	case PCI_PRODUCT_INTEL_82815_FULL_GRAPH:
d194 1
a194 1
	case PCI_PRODUCT_INTEL_82830MP_IV:
d198 2
a199 2
	case PCI_PRODUCT_INTEL_82852GM_AGP:
	case PCI_PRODUCT_INTEL_82865_IGD:
d202 4
a205 2
	case PCI_PRODUCT_INTEL_82915G_IV:
	case PCI_PRODUCT_INTEL_82915GM_IGD:
d207 3
a209 2
	case PCI_PRODUCT_INTEL_82945GM_IGD:
	case PCI_PRODUCT_INTEL_82945GM_IGD_S:
d212 6
a217 6
	case PCI_PRODUCT_INTEL_82965_IGD_1:
	case PCI_PRODUCT_INTEL_82965_IGD_2:
	case PCI_PRODUCT_INTEL_82Q963_IGD_1:	
	case PCI_PRODUCT_INTEL_82Q963_IGD_2:
	case PCI_PRODUCT_INTEL_82965GM_IGD_1:
	case PCI_PRODUCT_INTEL_82965GM_IGD_2:
@


1.30
log
@Kill a check for malloc fail. The malloc call uses M_WAITOK and thus
should not be able to fail.

ok kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.29 2007/12/10 21:51:01 oga Exp $	*/
d241 4
@


1.29
log
@Make the "can't find VGA config space" error sound less scary. This
happens sometimes on intel PCI-E chipsets where integrated graphics
have been disabled.

ok kettenis, deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.28 2007/12/09 18:21:14 kettenis Exp $	*/
a694 2
	if (mem == NULL)
		return (NULL);
@


1.28
log
@Restore "evil hack" that we had before the recent agp(4) changes.  Solves
X display corruption.

People should know better than just importing the latest random crap from
NetBSD or FreeBSD.  That's worse than doing a "commit and run".
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.27 2007/12/09 00:09:22 oga Exp $	*/
d177 1
a177 1
		printf("can't find internal VGA device config space\n");
@


1.27
log
@sturm@@ let me know that the workaround in here breaks things on bge somehow.

Revert it for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.26 2007/12/07 17:35:22 oga Exp $	*/
a764 1
#if 0
a773 2
#endif 
	regval = 0;
@


1.26
log
@KNF, no binary change.

Looked over by a few people.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.25 2007/12/06 22:49:39 oga Exp $	*/
a154 1
	bus_size_t mmaddrsize;
a241 2
	pci_mapreg_info(isc->vga_pa.pa_pc, isc->vga_pa.pa_tag,
	    mmaddr, memtype, NULL, &mmaddrsize, NULL);
a425 6

	/*
	 * another device (the drm) may need to access this area.
	 * we don't need to access it again so unmap.
	 */
	 bus_space_unmap(isc->bst, isc->bsh, mmaddrsize);
@


1.25
log
@Destatic functions in the agp subsystem.

KNF coming shortly.

ok marco, jsg and mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.24 2007/12/02 14:44:20 oga Exp $	*/
d72 6
a77 5
	u_int32_t initial_aperture;	/* aperture size at startup */
	struct agp_gatt *gatt;
	int chiptype;			/* i810-like or i830 */
	u_int32_t dcache_size;		/* i810 only */
	u_int32_t stolen;		/* number of i830/845 gtt entries
d79 1
a79 1
	bus_space_tag_t bst;		/* bus_space tag */
d81 2
a82 2
	bus_size_t bsz;			/* bus_space size */
	bus_space_tag_t gtt_bst;	/* GATT bus_space tag */
d94 1
a94 2
struct agp_memory *
	agp_i810_alloc_memory(struct agp_softc *, int, vsize_t);
@


1.24
log
@Put back some of the handling for writes to the GATT on intel
agp bridges. This got lost in the merge before.

Tested by Peter Hessler on amd64.  ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.23 2007/11/28 23:37:34 oga Exp $	*/
d440 1
a440 1
static int
@


1.23
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.22 2007/11/28 16:25:58 chl Exp $	*/
d58 3
a60 16
#define WRITEGTT(off,v)							\
	do {								\
		if (isc->chiptype == CHIP_I915) {			\
			bus_space_write_4(isc->gtt_bst, isc->gtt_bsh,	\
			    (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4,	\
			    (v) ? ((v)|1) : 0);				\
		} else if (isc->chiptype == CHIP_I965) {		\
			WRITE4(AGP_I965_GTT +				\
			    (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4,	\
			    (v) ? ((v) | 1) : 0);			\
		} else {						\
			WRITE4(AGP_I810_GTT +				\
			    (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4,	\
			    (v) ? ((v) | 1) : 0);			\
		}							\
	} while (0)
d99 1
d633 1
a633 1
	WRITEGTT(offset, physical);
d654 1
a654 1
	WRITEGTT(offset, 0);
d789 1
a789 1
			WRITEGTT(offset + i, (mem->am_physical + i));
d803 2
a804 1
		WRITEGTT(offset, i);
d817 1
a817 1
			WRITEGTT(mem->am_offset + i, 0);
d831 1
a831 1
		WRITEGTT(i,0);
d834 18
@


1.22
log
@do not check malloc return value against NULL, as M_WAITOK is used

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.21 2007/11/26 15:35:15 deraadt Exp $	*/
d167 1
d255 2
d441 6
@


1.21
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.20 2007/11/26 10:35:42 reyk Exp $	*/
a719 4
		if (mem->am_dmaseg == NULL) {
			free(mem, M_AGP);
			return (NULL);
		}
@


1.20
log
@fix new agp code on amd64
- internal intel graphics semi-agp chipsets need special handling in pchb.c
- re-add the i965GM device
- use the correct major device id for /dev/agp0 on amd64 (not the i386 one)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.19 2007/11/26 00:04:38 oga Exp $	*/
d172 1
a172 1
		printf(": can't allocate chipset-specific softc\n");
d189 1
a189 1
		printf(": can't find internal VGA device config space\n");
d249 1
a249 1
		printf(": can't map aperture\n");
d257 1
a257 1
		printf(": can't map mmadr registers\n");
d266 1
a266 1
			printf(": can't map gatt registers\n");
d326 1
a326 2
			printf(
			    ": unknown memory configuration, disabling\n");
d378 1
a378 1
			printf(": bad chiptype\n");
d415 1
a415 2
			printf(
			    ": unknown memory configuration, disabling\n");
@


1.19
log
@Fix hardware cursor mapping.

ok matthieu.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.18 2007/11/25 17:11:12 oga Exp $	*/
d153 2
d224 1
@


1.18
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.17 2007/10/06 23:50:54 krw Exp $	*/
d794 3
a796 1
		WRITEGTT(offset, mem->am_physical);
d821 3
a823 1
		WRITEGTT(mem->am_offset, 0);
@


1.17
log
@Simpliest memset(,0,) -> M_ZERO changes. One (caddr *) cast removal,
otherwise just adding M_ZERO to malloc() and removing the immediately
adjacent memset(,0,).
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.16 2007/09/17 01:33:33 krw Exp $	*/
d53 2
d58 16
a73 1
#define WRITEGTT(off,v)	bus_space_write_4(isc->gtt_bst, isc->gtt_bsh, off, v)
a74 1
#define WRITE_GATT(off, v)	agp_i810_write_gatt(isc, off, v)
d85 1
d96 1
a96 1
	struct pci_attach_args bridge_pa;
d99 7
a105 6
u_int32_t agp_i810_get_aperture(struct vga_pci_softc *);
int	agp_i810_set_aperture(struct vga_pci_softc *, u_int32_t);
int	agp_i810_bind_page(struct vga_pci_softc *, off_t, bus_addr_t);
int	agp_i810_unbind_page(struct vga_pci_softc *, off_t);
void	agp_i810_flush_tlb(struct vga_pci_softc *);
int	agp_i810_enable(struct vga_pci_softc *, u_int32_t mode);
d107 3
a109 3
	agp_i810_alloc_memory(struct vga_pci_softc *, int, vsize_t);
int	agp_i810_free_memory(struct vga_pci_softc *, struct agp_memory *);
int	agp_i810_bind_memory(struct vga_pci_softc *, struct agp_memory *,
d111 1
a111 2
int	agp_i810_unbind_memory(struct vga_pci_softc *, struct agp_memory *);
void	agp_i810_write_gatt(struct agp_i810_softc *, bus_size_t, u_int32_t);
d126 1
d128 33
a160 2
agp_i810_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa,
		struct pci_attach_args *pchb_pa)
d168 1
a168 1
	isc = malloc(sizeof *isc, M_DEVBUF, M_NOWAIT | M_ZERO);
a174 1
	memcpy(&isc->bridge_pa, pchb_pa, sizeof *pchb_pa);
d176 20
a195 1
	switch (PCI_PRODUCT(pa->pa_id)) {
d214 1
d218 3
d230 1
d235 1
a235 1
		memtype = PCI_MAPREG_MEM_TYPE_64BIT;
d240 1
d244 1
a244 1
	error = agp_map_aperture(sc, gmaddr, memtype);
d247 1
a247 1
		free(isc, M_DEVBUF);
d251 1
a251 1
	error = pci_mapreg_map(pa, mmaddr, memtype, 0,
d255 1
d260 1
a260 1
		error = pci_mapreg_map(pa, AGP_I915_GTTADR, memtype,
d269 3
a271 1
	gatt = malloc(sizeof(struct agp_gatt), M_DEVBUF, M_NOWAIT);
d292 1
a292 1
			free(gatt, M_DEVBUF);
d309 1
a309 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I830_GCC1);
d341 2
a342 2
	} else if (isc->chiptype == CHIP_I915) {
		/* The 915G automatically initializes the 256k gatt on boot. */
d344 1
a344 1
		u_int32_t pgtblctl;
d347 8
a354 6
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I855_GCC1);
		gcc1 = (u_int16_t)(reg >> 16);
		switch (gcc1 & AGP_I855_GCC1_GMS) {
		case AGP_I855_GCC1_GMS_STOLEN_1M:
			isc->stolen = (1024 - 260) * 1024 / 4096;
d356 3
a358 11
		case AGP_I855_GCC1_GMS_STOLEN_4M:
			isc->stolen = (4096 - 260) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_8M:
			isc->stolen = (8192 - 260) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_16M:
			isc->stolen = (16384 - 260) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_32M:
			isc->stolen = (32768 - 260) * 1024 / 4096;
d360 14
a373 5
		case AGP_I915_GCC1_GMS_STOLEN_48M:
			isc->stolen = (49152 - 260) * 1024 / 4096;
			break;
		case AGP_I915_GCC1_GMS_STOLEN_64M:
			isc->stolen = (65536 - 260) * 1024 / 4096;
d376 1
a376 3
			isc->stolen = 0;
			printf(
			    ": unknown memory configuration, disabling\n");
d379 1
a379 33
		}
#ifdef DEBUG
		if (isc->stolen > 0) {
			printf(": detected %dk stolen memory",
			    isc->stolen * 4);
		}
#endif

		/* GATT address is already in there, make sure it's enabled */
		pgtblctl = READ4(AGP_I810_PGTBL_CTL);
		pgtblctl |= 1;
		WRITE4(AGP_I810_PGTBL_CTL, pgtblctl);

		gatt->ag_physical = pgtblctl & ~1;
	} else if (isc->chiptype == CHIP_I965) {
		pcireg_t reg;
		u_int32_t pgtblctl;
		u_int16_t gcc1;
		u_int32_t gttsize;

		switch (READ4(AGP_I810_PGTBL_CTL) &
		    AGP_I810_PGTBL_SIZE_MASK) {
		case AGP_I810_PGTBL_SIZE_512KB:
			gttsize = 512 + 4;
			break;
		case AGP_I810_PGTBL_SIZE_256KB:
			gttsize = 256 + 4;
			break;
		case AGP_I810_PGTBL_SIZE_128KB:
		default:
			gttsize = 128 + 4;
			break;
		}
d381 1
a381 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I855_GCC1);
d385 1
a385 1
			isc->stolen = (1024 - gttsize) * 1024 / 4096;
d388 1
a388 1
			isc->stolen = (4096 - gttsize) * 1024 / 4096;
d391 1
a391 1
			isc->stolen = (8192 - gttsize) * 1024 / 4096;
d394 1
a394 1
			isc->stolen = (16384 - gttsize) * 1024 / 4096;
d397 1
a397 1
			isc->stolen = (32768 - gttsize) * 1024 / 4096;
d400 1
a400 1
			isc->stolen = (49152 - gttsize) * 1024 / 4096;
d403 1
a403 1
			isc->stolen = (65536 - gttsize) * 1024 / 4096;
d406 1
a406 1
			isc->stolen = (131072 - gttsize) * 1024 / 4096;
d409 1
a409 46
			isc->stolen = (262144 - gttsize) * 1024 / 4096;
			break;
		default:
			isc->stolen = 0;
			printf(": unknown memory configuration 0x%x, "
			    "disabling\n", reg);
			agp_generic_detach(sc);
			return (EINVAL);
		}
#ifdef DEBUG
		if (isc->stolen > 0) {
			printf(": detected %dk stolen memory",
			    isc->stolen * 4);
		}
#endif

		/* GATT address is already in there, make sure it's enabled */
		pgtblctl = READ4(AGP_I810_PGTBL_CTL);
		pgtblctl |= 1;
		WRITE4(AGP_I810_PGTBL_CTL, pgtblctl);

		gatt->ag_physical = pgtblctl & ~1;
	} else {	/* CHIP_I855 */
		/* The 855GM automatically initializes the 128k gatt on boot. */
		pcireg_t reg;
		u_int32_t pgtblctl;
		u_int16_t gcc1;

		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I855_GCC1);
		gcc1 = (u_int16_t)(reg >> 16);
		switch (gcc1 & AGP_I855_GCC1_GMS) {
		case AGP_I855_GCC1_GMS_STOLEN_1M:
			isc->stolen = (1024 - 132) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_4M:
			isc->stolen = (4096 - 132) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_8M:
			isc->stolen = (8192 - 132) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_16M:
			isc->stolen = (16384 - 132) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_32M:
			isc->stolen = (32768 - 132) * 1024 / 4096;
d441 34
d476 1
a476 1
agp_i810_get_aperture(struct vga_pci_softc *sc)
d484 1
a484 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I810_SMRAM);
d494 1
a494 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I830_GCC0);
d501 1
a501 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I915_MSAC);
d508 1
a508 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I965_MSAC);
d524 1
a524 1
agp_i810_set_aperture(struct vga_pci_softc *sc, u_int32_t aperture)
d541 1
a541 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I810_SMRAM);
d551 1
a551 2
		pci_conf_write(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I810_SMRAM, reg);
d560 1
a560 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I830_GCC0);
d570 1
a570 2
		pci_conf_write(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I830_GCC0, reg);
d577 1
a577 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I915_MSAC);
d583 1
a583 2
		pci_conf_write(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I915_MSAC, reg);
d585 1
a585 2
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I965_MSAC);
d601 1
a601 2
		pci_conf_write(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I965_MSAC, reg);
d613 1
a613 1
agp_i810_bind_page(struct vga_pci_softc *sc, off_t offset, bus_addr_t physical)
d635 1
a635 1
	WRITE_GATT(offset, physical);
d640 1
a640 1
agp_i810_unbind_page(struct vga_pci_softc *sc, off_t offset)
d656 1
a656 1
	WRITE_GATT(offset, 0);
d664 1
a664 1
agp_i810_flush_tlb(struct vga_pci_softc *sc)
d669 1
a669 1
agp_i810_enable(struct vga_pci_softc *sc, u_int32_t mode)
d675 1
a675 1
agp_i810_alloc_memory(struct vga_pci_softc *sc, int type, vsize_t size)
d682 4
a685 1
		return 0;
d705 3
a707 1
	mem = malloc(sizeof *mem, M_DEVBUF, M_WAITOK | M_ZERO);
d717 1
a717 1
		mem->am_dmaseg = malloc(sizeof *mem->am_dmaseg, M_DEVBUF,
d720 1
a720 1
			free(mem, M_DEVBUF);
d726 2
a727 2
			free(mem->am_dmaseg, M_DEVBUF);
			free(mem, M_DEVBUF);
d731 1
d736 1
a736 1
			free(mem, M_DEVBUF);
d749 1
a749 1
agp_i810_free_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
d757 1
a757 1
		free(mem->am_dmaseg, M_DEVBUF);
d762 1
a762 1
	free(mem, M_DEVBUF);
d767 1
a767 1
agp_i810_bind_memory(struct vga_pci_softc *sc, struct agp_memory *mem,
d779 2
d790 2
d794 1
a794 3
		for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE) {
			WRITE_GATT(offset + i, mem->am_physical + i);
		}
d806 2
a807 4
	for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE) {
		WRITE4(AGP_I810_GTT +
		    (u_int32_t)(offset >> AGP_PAGE_SHIFT) * 4, i | 3);
	}
d813 1
a813 1
agp_i810_unbind_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
d819 1
a819 3
		for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE) {
			WRITE_GATT(mem->am_offset + i, 0);
		}
d832 1
a832 1
		WRITE4(AGP_I810_GTT + (i >> AGP_PAGE_SHIFT) * 4, 0);
a834 19
}

void
agp_i810_write_gatt(struct agp_i810_softc *isc, bus_size_t off, u_int32_t v)
{
	u_int32_t d;


	d = v | 1;

	if (isc->chiptype == CHIP_I915)
		WRITEGTT((u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, v ? d : 0);
	else if (isc->chiptype == CHIP_I965) {
		d |= (v & 0x0000000f00000000ULL) >> 28;
		WRITE4(AGP_I965_GTT +
		    (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, v ? d : 0);
	} else
		WRITE4(AGP_I810_GTT +
		    (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, v ? d : 0);
@


1.16
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.15 2007/08/04 19:40:25 reyk Exp $	*/
d119 1
a119 1
	isc = malloc(sizeof *isc, M_DEVBUF, M_NOWAIT);
a123 1
	memset(isc, 0, sizeof *isc);
@


1.15
log
@Add AGP support for the intel i965 chipset, this also extends the
internal AGP API to work with 64bit PCI-Express memory and
non-standard AGP aperture bases.

tested by many
ok matthieu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.14 2006/12/30 19:14:55 miod Exp $	*/
d683 1
a683 2
	mem = malloc(sizeof *mem, M_DEVBUF, M_WAITOK);
	bzero(mem, sizeof *mem);
@


1.14
log
@In agp_i810_alloc_memory(), do not check for sc_maxmem limit reached, as the
caller has already done this.
Test matthieu@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.13 2006/05/15 08:27:19 dim Exp $	*/
d58 9
a66 14
#define CHIP_I810 0	/* i810/i815 */
#define CHIP_I830 1	/* i830/i845 */
#define CHIP_I855 2	/* i852GM/i855GM/i865G */
#define CHIP_I915 3	/* i915G/i915GM */

#define WRITE_GATT(off,v)						   \
	do {								   \
		if (isc->chiptype == CHIP_I915)				   \
			WRITEGTT((u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, \
			    v);						   \
		else							   \
			WRITE4(AGP_I810_GTT +				   \
			    (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, v);  \
	} while (0)
d76 1
d94 1
d115 1
d117 1
a128 6
	if ((error = agp_map_aperture(sc))) {
		printf(": can't map aperture\n");
		free(isc, M_DEVBUF);
		return (error);
	}

d150 4
d156 25
a180 3
	error = pci_mapreg_map(pa,
	    (isc->chiptype == CHIP_I915) ? AGP_I915_MMADR : AGP_I810_MMADR,
	    PCI_MAPREG_TYPE_MEM, 0, &isc->bst, &isc->bsh, NULL, NULL, 0);
d187 1
a187 1
		error = pci_mapreg_map(pa, AGP_I915_GTTADR, PCI_MAPREG_TYPE_MEM,
d318 71
d479 11
a489 2
	} else {	/* CHIP_I855 */
		return (128 * 1024 * 1024);
d491 3
d563 20
d616 1
a616 1
	WRITE_GATT(offset, physical | 1);
d767 1
a767 1
			WRITE_GATT(offset + i, (mem->am_physical + i) | 1);
d813 19
@


1.13
log
@Add AGP support for Intel 945G/GM chipsets.  The 945GM (mobile) variant
also needs a X.org update, which will go in later.

Tested by a bunch of people; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.12 2006/02/16 19:40:43 matthieu Exp $	*/
a540 3
		return 0;

	if (sc->sc_allocated + size > sc->sc_maxmem)
@


1.12
log
@Patch from Dimitry Andric to fix the allocation of 4 pages of gart
memory for hardware cursor. Tested by many, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.11 2006/02/11 21:15:21 matthieu Exp $	*/
d153 2
@


1.11
log
@New version of i915 supprotm  adapted from freebsd by Dimitry Andric, with
one tweak suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.10 2006/02/03 19:24:42 millert Exp $	*/
d554 1
a554 1
		 * Bogus mapping of a single page for the hardware cursor.
d556 2
a557 1
		if (size != AGP_PAGE_SIZE)
d559 1
d570 2
a571 2
		 * Allocate and wire down the page now so that we can
		 * get its physical address.
d645 3
a647 1
		WRITE_GATT(offset, mem->am_physical | 1);
d674 3
a676 1
		WRITE_GATT(mem->am_offset, 0);
@


1.10
log
@Back out i915 changes; they broke some i810-based machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.9 2006/01/13 22:59:02 deraadt Exp $	*/
d56 1
d61 11
d81 2
d151 4
d157 2
a158 1
	error = pci_mapreg_map(pa, AGP_I810_MMADR,
d165 10
d246 51
d379 8
d444 15
d492 1
a492 2
	WRITE4(AGP_I810_GTT + (u_int32_t)(offset >> AGP_PAGE_SHIFT) * 4,
	    physical | 1);
d513 1
a513 1
	WRITE4(AGP_I810_GTT + (u_int32_t)(offset >> AGP_PAGE_SHIFT) * 4, 0);
d643 1
a643 2
		WRITE4(AGP_I810_GTT + (u_int32_t)(offset >> AGP_PAGE_SHIFT) * 4,
		    mem->am_physical | 1);
d670 1
a670 2
		WRITE4(AGP_I810_GTT +
		    (u_int32_t)(mem->am_offset >> AGP_PAGE_SHIFT) * 4, 0);
@


1.9
log
@support i915.  adapted from freebsd by Dimitry Andric.  does not break
at least i810 on x40, but made x41 work.  ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.8 2005/03/22 18:33:03 sturm Exp $	*/
a55 1
#define WRITEGTT(off,v)	bus_space_write_4(isc->gtt_bst, isc->gtt_bsh, off, v)
a59 11
#define CHIP_I915 3	/* i915G/i915GM */

#define WRITE_GATT(off,v)						   \
	do {								   \
		if (isc->chiptype == CHIP_I915)				   \
			WRITEGTT((u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, \
			    v);						   \
		else							   \
			WRITE4(AGP_I810_GTT +				   \
			    (u_int32_t)((off) >> AGP_PAGE_SHIFT) * 4, v);  \
	} while (0)
a68 2
	bus_space_tag_t gtt_bst;	/* GATT bus_space tag */
	bus_space_handle_t gtt_bsh;	/* GATT bus_space handle */
a136 4
	case PCI_PRODUCT_INTEL_82915G_IV:
	case PCI_PRODUCT_INTEL_82915GM_IGD:
		isc->chiptype = CHIP_I915;
		break;
d139 1
a139 2
	error = pci_mapreg_map(pa,
	    (isc->chiptype == CHIP_I915) ? AGP_I915_MMADR : AGP_I810_MMADR,
a142 1
		agp_generic_detach(sc);
a145 10
	if (isc->chiptype == CHIP_I915) {
		error = pci_mapreg_map(pa, AGP_I915_GTTADR, PCI_MAPREG_TYPE_MEM,
		    0, &isc->gtt_bst, &isc->gtt_bsh, NULL, NULL, 0);
		if (error != 0) {
			printf(": can't map gatt registers\n");
			agp_generic_detach(sc);
			return (error);
		}
	}

d217 1
a217 1
	} else if (isc->chiptype == CHIP_I855 || isc->chiptype == CHIP_I915) {
a218 1
		u_int32_t stolen;
a222 5
		if (isc->chiptype == CHIP_I855)
			stolen = 132;
		else
			stolen = 260;

d228 1
a228 1
			isc->stolen = (1024 - stolen) * 1024 / 4096;
d231 1
a231 1
			isc->stolen = (4096 - stolen) * 1024 / 4096;
d234 1
a234 1
			isc->stolen = (8192 - stolen) * 1024 / 4096;
d237 1
a237 1
			isc->stolen = (16384 - stolen) * 1024 / 4096;
d240 1
a240 7
			isc->stolen = (32768 - stolen) * 1024 / 4096;
			break;
		case AGP_I915_GCC1_GMS_STOLEN_48M:
			isc->stolen = (49152 - stolen) * 1024 / 4096;
			break;
		case AGP_I915_GCC1_GMS_STOLEN_64M:
			isc->stolen = (65536 - stolen) * 1024 / 4096;
d299 1
a299 1
	} else if (isc->chiptype == CHIP_I855) {
a300 8
	} else if (isc->chiptype == CHIP_I915) {
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I915_MSAC);
		if ((reg & AGP_I915_MSAC_GMASIZE) == AGP_I915_MSAC_GMASIZE_128) {
			return (128 * 1024 * 1024);
		} else {
			return (256 * 1024 * 1024);
		}
a301 2

	return 0;
d356 1
a356 1
	} else if (isc->chiptype == CHIP_I855) {
a360 15
	} else if (isc->chiptype == CHIP_I915) {
		if (aperture != (128 * 1024 * 1024) &&
		    aperture != (256 * 1024 * 1024)) {
			printf("agp: bad aperture size %d\n", aperture);
			return (EINVAL);
		}
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I915_MSAC);
		reg &= ~AGP_I915_MSAC_GMASIZE;
		if (aperture == (128 * 1024 * 1024))
			reg |= AGP_I915_MSAC_GMASIZE_128;
		else
			reg |= AGP_I915_MSAC_GMASIZE_256;
		pci_conf_write(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I915_MSAC, reg);
d389 2
a390 1
	WRITE_GATT(offset, physical | 1);
d411 1
a411 1
	WRITE_GATT(offset, 0);
d452 1
a452 1
		 * Bogus mapping of 1 or 4 pages for the hardware cursor.
d454 1
a454 2
		if (size != AGP_PAGE_SIZE && size != 4 * AGP_PAGE_SIZE) {
			printf("agp: trying to map %lu for hw cursor\n", size);
a455 1
		}
d541 2
a542 1
		WRITE_GATT(offset, mem->am_physical | 1);
d569 2
a570 1
		WRITE_GATT(mem->am_offset, 0);
@


1.8
log
@fix merge misses
tested by millert, mbalmer and me; ok grange, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.7 2004/01/20 19:30:40 grange Exp $	*/
d56 1
d61 11
d81 2
d151 4
d157 2
a158 1
	error = pci_mapreg_map(pa, AGP_I810_MMADR,
d162 1
d166 10
d247 1
a247 1
	} else {	/* CHIP_I855 */
d249 1
d254 5
d264 1
a264 1
			isc->stolen = (1024 - 132) * 1024 / 4096;
d267 1
a267 1
			isc->stolen = (4096 - 132) * 1024 / 4096;
d270 1
a270 1
			isc->stolen = (8192 - 132) * 1024 / 4096;
d273 1
a273 1
			isc->stolen = (16384 - 132) * 1024 / 4096;
d276 7
a282 1
			isc->stolen = (32768 - 132) * 1024 / 4096;
d341 1
a341 1
	} else {	/* CHIP_I855 */
d343 8
d352 2
d408 1
a408 1
	} else {	/* CHIP_I855 */
d413 15
d456 1
a456 2
	WRITE4(AGP_I810_GTT + (u_int32_t)(offset >> AGP_PAGE_SHIFT) * 4,
	    physical | 1);
d477 1
a477 1
	WRITE4(AGP_I810_GTT + (u_int32_t)(offset >> AGP_PAGE_SHIFT) * 4, 0);
d518 1
a518 1
		 * Bogus mapping of a single page for the hardware cursor.
d520 2
a521 1
		if (size != AGP_PAGE_SIZE)
d523 1
d609 1
a609 2
		WRITE4(AGP_I810_GTT + (u_int32_t)(offset >> AGP_PAGE_SHIFT) * 4,
		    mem->am_physical | 1);
d636 1
a636 2
		WRITE4(AGP_I810_GTT +
		    (u_int32_t)(mem->am_offset >> AGP_PAGE_SHIFT) * 4, 0);
@


1.7
log
@Support for i852/855/865 AGP; from NetBSD via Michael van der
Westhuizen <michael@@skanky.homeunix.net> with little tweaks.

Tested by millert@@ todd@@ jmc@@ andreas@@ and jcs@@'s friend
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.6 2004/01/20 19:23:06 grange Exp $	*/
d551 1
a551 1
	if (isc->chiptype == CHIP_I830)
d579 1
a579 1
	if (isc->chiptype == CHIP_I830)
@


1.6
log
@Correct checks for non-i810 chip; from FreeBSD.

test and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.5 2003/03/19 20:06:28 millert Exp $	*/
d59 1
d133 4
d178 1
a178 1
	} else {
d217 45
d289 1
a289 1
	} else {		/* I830 */
d299 2
d335 1
a335 1
	} else {		/* I830 */
d356 5
d436 6
d446 1
a446 1
		if (isc->chiptype == CHIP_I830 )
d471 4
@


1.5
log
@Add i830 support from NetBSD via patch in kernel/3150.
Verified to not break i81[05] and tested on two i830s.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.4 2003/02/13 20:07:33 mickey Exp $	*/
d323 1
a323 1
	if (isc->chiptype == CHIP_I810) {
d345 1
a345 1
	if (isc->chiptype == CHIP_I830 ) {
@


1.5.4.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a58 1
#define CHIP_I855 2	/* i852GM/i855GM/i865G */
a131 4
	case PCI_PRODUCT_INTEL_82852GM_AGP:
	case PCI_PRODUCT_INTEL_82865_IGD:
		isc->chiptype = CHIP_I855;
		break;
d173 1
a173 1
	} else if (isc->chiptype == CHIP_I830) {
a211 45
	} else {	/* CHIP_I855 */
		/* The 855GM automatically initializes the 128k gatt on boot. */
		pcireg_t reg;
		u_int32_t pgtblctl;
		u_int16_t gcc1;

		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I855_GCC1);
		gcc1 = (u_int16_t)(reg >> 16);
		switch (gcc1 & AGP_I855_GCC1_GMS) {
		case AGP_I855_GCC1_GMS_STOLEN_1M:
			isc->stolen = (1024 - 132) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_4M:
			isc->stolen = (4096 - 132) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_8M:
			isc->stolen = (8192 - 132) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_16M:
			isc->stolen = (16384 - 132) * 1024 / 4096;
			break;
		case AGP_I855_GCC1_GMS_STOLEN_32M:
			isc->stolen = (32768 - 132) * 1024 / 4096;
			break;
		default:
			isc->stolen = 0;
			printf(
			    ": unknown memory configuration, disabling\n");
			agp_generic_detach(sc);
			return (EINVAL);
		}
#ifdef DEBUG
		if (isc->stolen > 0) {
			printf(": detected %dk stolen memory",
			    isc->stolen * 4);
		}
#endif

		/* GATT address is already in there, make sure it's enabled */
		pgtblctl = READ4(AGP_I810_PGTBL_CTL);
		pgtblctl |= 1;
		WRITE4(AGP_I810_PGTBL_CTL, pgtblctl);

		gatt->ag_physical = pgtblctl & ~1;
d239 1
a239 1
	} else if (isc->chiptype == CHIP_I830) {
a248 2
	} else {	/* CHIP_I855 */
		return (128 * 1024 * 1024);
d283 1
a283 1
	} else if (isc->chiptype == CHIP_I830) {
a303 5
	} else {	/* CHIP_I855 */
		if (aperture != (128 * 1024 * 1024)) {
			printf("agp: bad aperture size %d\n", aperture);
			return (EINVAL);
		}
d323 1
a323 1
	if (isc->chiptype != CHIP_I810) {
d345 1
a345 1
	if (isc->chiptype != CHIP_I810 ) {
a378 6
	if ((size & (AGP_PAGE_SIZE - 1)) != 0)
		return 0;

	if (sc->sc_allocated + size > sc->sc_maxmem)
		return 0;

d383 1
a383 1
		if (isc->chiptype != CHIP_I810 )
a407 4
		if (mem->am_dmaseg == NULL) {
			free(mem, M_DEVBUF);
			return (NULL);
		}
@


1.4
log
@proper free order; from sturm@@
@
text
@d1 2
a2 2
/*	$OpenBSD: agp_i810.c,v 1.3 2002/07/25 23:31:04 fgsch Exp $	*/
/*	$NetBSD: agp_i810.c,v 1.8 2001/09/20 20:00:16 fvdl Exp $	*/
a48 1

d54 1
d57 3
a60 1
	u_int32_t initial_aperture;	   /* aperture size at startup */
d62 7
a68 3
	u_int32_t dcache_size;
	bus_space_tag_t bst;		    /* bus_space tag */
	bus_space_handle_t bsh;		    /* bus_space handle */
a96 1

d98 1
a98 1
agp_i810_attach(struct vga_pci_softc* sc, struct pci_attach_args *pa,
d113 1
a113 1
	sc->sc_dmat = pa->pa_dmat;	/* XXX fvdl */
d121 13
d141 6
a146 1
	isc->initial_aperture = AGP_GET_APERTURE(sc);
d148 1
a148 9
	if (READ1(AGP_I810_DRT) & AGP_I810_DRT_POPULATED)
		isc->dcache_size = 4 * 1024 * 1024;
	else
		isc->dcache_size = 0;

	for (;;) {
		gatt = agp_alloc_gatt(sc);
		if (gatt)
			break;
d150 13
a162 5
		/*
		 * Probably contigmalloc failure. Try reducing the
		 * aperture so that the gatt size reduces.
		 */
		if (AGP_SET_APERTURE(sc, AGP_GET_APERTURE(sc) / 2)) {
d166 46
a212 4
	isc->gatt = gatt;

	/* Install the GATT. */
	WRITE4(AGP_I810_PGTBL_CTL, gatt->ag_physical | 1);
d225 2
a226 1
	u_int16_t miscc;
d228 22
a249 5
	miscc = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I810_SMRAM) >> 16;
	if ((miscc & AGP_I810_MISCC_WINSIZE) == AGP_I810_MISCC_WINSIZE_32)
		return (32 * 1024 * 1024);
	else
		return (64 * 1024 * 1024);
d255 14
a268 1
	pcireg_t reg, miscc;
d270 34
a303 6
	/*
	 * Double check for sanity.
	 */
	if (aperture != 32 * 1024 * 1024 && aperture != 64 * 1024 * 1024) {
		printf("AGP: bad aperture size %d\n", aperture);
		return (EINVAL);
a305 12
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I810_SMRAM);
	miscc = reg >> 16;
	miscc &= ~AGP_I810_MISCC_WINSIZE;
	if (aperture == 32 * 1024 * 1024)
		miscc |= AGP_I810_MISCC_WINSIZE_32;
	else
		miscc |= AGP_I810_MISCC_WINSIZE_64;

	reg &= 0x0000ffff;
	reg |= (miscc << 16);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_I810_SMRAM, miscc);

d310 1
a310 1
agp_i810_bind_page(struct vga_pci_softc *sc, off_t offset, bus_addr_t pa)
d314 6
a319 1
	if (offset < 0 || offset >= (isc->gatt->ag_entries << AGP_PAGE_SHIFT))
d321 10
d333 1
a333 2
	    pa | 1);

d345 9
d383 2
d400 1
a400 1
	
d402 4
a407 1

d437 1
a437 1
	
d465 1
a465 1
#if 0
d482 1
a482 1
		return agp_generic_bind_memory(sc, mem, offset);
d484 4
a487 1
	for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE)
d490 2
a491 1

d512 3
d517 1
a517 1

@


1.3
log
@- some KNF.
- comment out debugging printf for i810.
- remove checks for failure if malloc is used with M_WAITOK.

mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.2 2002/07/15 13:23:48 mickey Exp $	*/
d271 1
a272 1
			free(mem->am_dmaseg, M_DEVBUF);
@


1.3.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: agp_i810.c,v 1.15 2003/01/31 00:07:39 thorpej Exp $	*/
d49 1
a54 1
#define READ4(off)	bus_space_read_4(isc->bst, isc->bsh, off)
a56 3
#define CHIP_I810 0	/* i810/i815 */
#define CHIP_I830 1	/* i830/i845 */

d58 1
d60 3
a62 7
	int chiptype;			/* i810-like or i830 */
	u_int32_t dcache_size;		/* i810 only */
	u_int32_t stolen;		/* number of i830/845 gtt entries
					   for stolen memory */
	bus_space_tag_t bst;		/* bus_space tag */
	bus_space_handle_t bsh;		/* bus_space handle */
	struct pci_attach_args bridge_pa;
d91 1
d93 1
a93 1
agp_i810_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa,
d108 1
a108 1
	memcpy(&isc->bridge_pa, pchb_pa, sizeof *pchb_pa);
a115 13
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_INTEL_82810_GC:
	case PCI_PRODUCT_INTEL_82810_DC100_GC:
	case PCI_PRODUCT_INTEL_82810E_GC:
	case PCI_PRODUCT_INTEL_82815_FULL_GRAPH:
		isc->chiptype = CHIP_I810;
		break;
	case PCI_PRODUCT_INTEL_82830MP_IV:
	case PCI_PRODUCT_INTEL_82845G_IGD:
		isc->chiptype = CHIP_I830;
		break;
	}

d123 1
a123 6
	gatt = malloc(sizeof(struct agp_gatt), M_DEVBUF, M_NOWAIT);
	if (!gatt) {
 		agp_generic_detach(sc);
 		return (ENOMEM);
	}
	isc->gatt = gatt;
d125 9
a133 1
	gatt->ag_entries = AGP_GET_APERTURE(sc) >> AGP_PAGE_SHIFT;
d135 5
a139 13
	if (isc->chiptype == CHIP_I810) {
		int dummyseg;
		/* Some i810s have on-chip memory called dcache */
		if (READ1(AGP_I810_DRT) & AGP_I810_DRT_POPULATED)
			isc->dcache_size = 4 * 1024 * 1024;
		else
			isc->dcache_size = 0;

		/* According to the specs the gatt on the i810 must be 64k */
		if (agp_alloc_dmamem(sc->sc_dmat, 64 * 1024,
		    0, &gatt->ag_dmamap, (caddr_t *)&gatt->ag_virtual,
		    &gatt->ag_physical, &gatt->ag_dmaseg, 1, &dummyseg) != 0) {
			free(gatt, M_DEVBUF);
d143 2
d146 2
a147 46
		gatt->ag_size = gatt->ag_entries * sizeof(u_int32_t);
		memset(gatt->ag_virtual, 0, gatt->ag_size);

		agp_flush_cache();
		/* Install the GATT. */
		WRITE4(AGP_I810_PGTBL_CTL, gatt->ag_physical | 1);
	} else {
		/* The i830 automatically initializes the 128k gatt on boot. */
		pcireg_t reg;
		u_int32_t pgtblctl;
		u_int16_t gcc1;

		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I830_GCC1);
		gcc1 = (u_int16_t)(reg >> 16);
		switch (gcc1 & AGP_I830_GCC1_GMS) {
		case AGP_I830_GCC1_GMS_STOLEN_512:
			isc->stolen = (512 - 132) * 1024 / 4096;
			break;
		case AGP_I830_GCC1_GMS_STOLEN_1024:
			isc->stolen = (1024 - 132) * 1024 / 4096;
			break;
		case AGP_I830_GCC1_GMS_STOLEN_8192:
			isc->stolen = (8192 - 132) * 1024 / 4096;
			break;
		default:
			isc->stolen = 0;
			printf(
			    ": unknown memory configuration, disabling\n");
			agp_generic_detach(sc);
			return (EINVAL);
		}
#ifdef DEBUG
		if (isc->stolen > 0) {
			printf(": detected %dk stolen memory",
			    isc->stolen * 4);
		}
#endif

		/* GATT address is already in there, make sure it's enabled */
		pgtblctl = READ4(AGP_I810_PGTBL_CTL);
		pgtblctl |= 1;
		WRITE4(AGP_I810_PGTBL_CTL, pgtblctl);

		gatt->ag_physical = pgtblctl & ~1;
	}
d160 1
a160 5
	struct agp_i810_softc *isc = sc->sc_chipc;
	pcireg_t reg;

	if (isc->chiptype == CHIP_I810) {
		u_int16_t miscc;
d162 5
a166 19
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I810_SMRAM);
		miscc = (u_int16_t)(reg >> 16);
		if ((miscc & AGP_I810_MISCC_WINSIZE) ==
		    AGP_I810_MISCC_WINSIZE_32)
			return (32 * 1024 * 1024);
		else
			return (64 * 1024 * 1024);
	} else {		/* I830 */
		u_int16_t gcc1;

		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I830_GCC0);
		gcc1 = (u_int16_t)(reg >> 16);
		if ((gcc1 & AGP_I830_GCC1_GMASIZE) == AGP_I830_GCC1_GMASIZE_64)
			return (64 * 1024 * 1024);
		else
			return (128 * 1024 * 1024);
	}
d172 1
a172 2
	struct agp_i810_softc *isc = sc->sc_chipc;
	pcireg_t reg;
d174 7
a180 2
	if (isc->chiptype == CHIP_I810) {
		u_int16_t miscc;
d182 11
a192 44
		/*
		 * Double check for sanity.
		 */
		if (aperture != (32 * 1024 * 1024) &&
		    aperture != (64 * 1024 * 1024)) {
			printf("agp: bad aperture size %d\n", aperture);
			return (EINVAL);
		}

		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I810_SMRAM);
		miscc = (u_int16_t)(reg >> 16);
		miscc &= ~AGP_I810_MISCC_WINSIZE;
		if (aperture == 32 * 1024 * 1024)
			miscc |= AGP_I810_MISCC_WINSIZE_32;
		else
			miscc |= AGP_I810_MISCC_WINSIZE_64;

		reg &= 0x0000ffff;
		reg |= ((pcireg_t)miscc) << 16;
		pci_conf_write(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I810_SMRAM, reg);
	} else {		/* I830 */
		u_int16_t gcc1;

		if (aperture != (64 * 1024 * 1024) &&
		    aperture != (128 * 1024 * 1024)) {
			printf("agp: bad aperture size %d\n", aperture);
			return (EINVAL);
		}
		reg = pci_conf_read(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I830_GCC0);
		gcc1 = (u_int16_t)(reg >> 16);
		gcc1 &= ~AGP_I830_GCC1_GMASIZE;
		if (aperture == 64 * 1024 * 1024)
			gcc1 |= AGP_I830_GCC1_GMASIZE_64;
		else
			gcc1 |= AGP_I830_GCC1_GMASIZE_128;

		reg &= 0x0000ffff;
		reg |= ((pcireg_t)gcc1) << 16;
		pci_conf_write(isc->bridge_pa.pa_pc,
		    isc->bridge_pa.pa_tag, AGP_I830_GCC0, reg);
	}
d198 1
a198 1
agp_i810_bind_page(struct vga_pci_softc *sc, off_t offset, bus_addr_t physical)
d202 1
a202 6
	if (offset < 0 || offset >= (isc->gatt->ag_entries << AGP_PAGE_SHIFT)) {
#ifdef DEBUG
		printf("agp: failed: offset 0x%08x, shift %d, entries %d\n",
		    (int)offset, AGP_PAGE_SHIFT,
		    isc->gatt->ag_entries);
#endif
a203 1
	}
d205 2
a206 8
	if (isc->chiptype == CHIP_I810) {
		if ((offset >> AGP_PAGE_SHIFT) < isc->stolen) {
#ifdef DEBUG
			printf("agp: trying to bind into stolen memory\n");
#endif
			return (EINVAL);
		}
	}
a207 2
	WRITE4(AGP_I810_GTT + (u_int32_t)(offset >> AGP_PAGE_SHIFT) * 4,
	    physical | 1);
a218 9
	if (isc->chiptype == CHIP_I830 ) {
		if ((offset >> AGP_PAGE_SHIFT) < isc->stolen) {
#ifdef DEBUG
			printf("agp: trying to unbind from stolen memory\n");
#endif
			return (EINVAL);
		}
	}

a247 2
		if (isc->chiptype == CHIP_I830 )
			return (NULL);
d263 1
a263 1

a264 4
		/*
		 * Allocate and wire down the page now so that we can
		 * get its physical address.
		 */
d267 1
d271 1
a272 1
			free(mem, M_DEVBUF);
d297 1
a297 1

d325 1
a325 1
#if DEBUG
d342 1
a342 1
		return (agp_generic_bind_memory(sc, mem, offset));
d344 1
a344 4
	if (isc->chiptype == CHIP_I830)
		return (EINVAL);

	for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE) {
d347 1
a347 2
	}
	mem->am_is_bound = 1;
a367 3
	if (isc->chiptype == CHIP_I830)
		return (EINVAL);

d370 1
a370 1
	mem->am_is_bound = 0;
@


1.2
log
@remove a bunch of debugging printfs and disable agp_debug; prompted by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_i810.c,v 1.1 2002/07/12 20:17:03 mickey Exp $	*/
d66 11
a76 9
int agp_i810_set_aperture(struct vga_pci_softc *, u_int32_t);
int agp_i810_bind_page(struct vga_pci_softc *, off_t, bus_addr_t);
int agp_i810_unbind_page(struct vga_pci_softc *, off_t);
void agp_i810_flush_tlb(struct vga_pci_softc *);
int agp_i810_enable(struct vga_pci_softc *, u_int32_t mode);
struct agp_memory *agp_i810_alloc_memory(struct vga_pci_softc *, int, vsize_t);
int agp_i810_free_memory(struct vga_pci_softc *, struct agp_memory *);
int agp_i810_bind_memory(struct vga_pci_softc *, struct agp_memory *, off_t);
int agp_i810_unbind_memory(struct vga_pci_softc *, struct agp_memory *);
d93 2
a94 1
agp_i810_attach(struct vga_pci_softc* sc, struct pci_attach_args *pa, struct pci_attach_args *pchb_pa)
d103 1
a103 1
		return ENOMEM;
d113 1
a113 1
		return error;
d120 1
a120 1
		return error;
d141 1
a141 1
			return ENOMEM;
d154 1
a154 1
	return 0;
d164 1
a164 1
		return 32 * 1024 * 1024;
d166 1
a166 1
		return 64 * 1024 * 1024;
d179 1
a179 1
		return EINVAL;
d194 1
a194 1
	return 0;
d203 1
a203 1
		return EINVAL;
d208 1
a208 1
	return 0;
d217 1
a217 1
		return EINVAL;
d220 1
a220 1
	return 0;
d234 1
a234 2

	return 0;
d249 1
a249 1
			return NULL;
d255 1
a255 1
			return NULL;
d258 1
a258 2
	if ((mem = malloc(sizeof *mem, M_DEVBUF, M_WAITOK)) == NULL)
		return NULL;
d265 3
a267 6
		mem->am_dmaseg = malloc(sizeof *mem->am_dmaseg, M_DEVBUF, M_WAITOK);
		if (mem->am_dmaseg == NULL) {
			free(mem, M_DEVBUF);
printf("agp: no memory for the segments\n");
			return NULL;
		}
d273 2
a274 2
printf("agp: agp_alloc_dmamem(%d)\n", error);
			return NULL;
d277 3
a279 2
		if ((error = bus_dmamap_create(sc->sc_dmat, size, size / PAGE_SIZE + 1,
		    size, 0, BUS_DMA_NOWAIT, &mem->am_dmamap)) != 0) {
d281 2
a282 2
printf("agp: bus_dmamap_create(%d)\n", error);
			return NULL;
d289 1
a289 1
	return mem;
d296 1
a296 1
		return EBUSY;
d307 1
a307 1
	return 0;
d325 1
d327 2
a328 1
		       regval);
d330 1
a330 1
				  isc->gatt->ag_physical | 1);
d335 1
a335 1
		       mem->am_physical | 1);
d338 1
a338 1
		return 0;
d348 1
a348 1
	return 0;
d362 1
a362 1
		return 0;
d366 1
a366 1
		return agp_generic_unbind_memory(sc, mem);
d371 1
a371 1
	return 0;
@


1.1
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a246 1
{ printf("agp: size(%d) != isc->dcache_size(%d)\n", size, isc->dcache_size);
a247 1
}
a252 1
{ printf("agp: size(%d) != AGP_PAGE_SIZE(%d)\n", size, AGP_PAGE_SIZE);
a253 1
}
@

