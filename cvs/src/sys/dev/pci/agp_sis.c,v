head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.10
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.12
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.6
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.15.0.18
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.14
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.12
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.10
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.24
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.22
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.20
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.18
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.16
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.14
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.12
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.10
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	SMP:1.2.0.8
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	UBC:1.2.0.4
	UBC_SYNC_B:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.18
date	2014.05.27.12.40.00;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.16;

1.16
date	2014.03.17.22.01.56;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2010.08.07.18.09.09;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.10.16.57.44;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.10.15.28.45;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.10.14.44.42;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.09.22.54.01;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.09.22.47.54;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.07.17.35.22;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.06.22.49.39;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.26.15.35.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.04.19.40.25;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.25.23.31.04;	author fgsch;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	;

1.2.4.1
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@We're never going to detach agp(4), so remove the #ifdef'ed out code like we
already did for intagp(4).
@
text
@/*	$OpenBSD: agp_sis.c,v 1.17 2014/03/26 14:41:41 mpi Exp $	*/
/*	$NetBSD: agp_sis.c,v 1.2 2001/09/15 00:25:00 thorpej Exp $	*/

/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agp_sis.c,v 1.3 2001/07/05 21:28:47 jhb Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/rwlock.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/vga_pcivar.h>
#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>

#include <machine/bus.h>

struct agp_sis_softc {
	struct device		 dev;
	struct agp_softc	*agpdev;
	struct agp_gatt		*gatt;
	pci_chipset_tag_t	 ssc_pc;
	pcitag_t		 ssc_tag;
	bus_addr_t		 ssc_apaddr;
	bus_size_t		 ssc_apsize;
	pcireg_t		 ssc_winctrl; /* saved over suspend/resume */
};

void	agp_sis_attach(struct device *, struct device *, void *);
int	agp_sis_activate(struct device *, int);
void	agp_sis_save(struct agp_sis_softc *);
void	agp_sis_restore(struct agp_sis_softc *);
int	agp_sis_probe(struct device *, void *, void *);
bus_size_t agp_sis_get_aperture(void *);
int	agp_sis_set_aperture(void *, bus_size_t);
void	agp_sis_bind_page(void *, bus_addr_t, paddr_t, int);
void	agp_sis_unbind_page(void *, bus_addr_t);
void	agp_sis_flush_tlb(void *);

struct cfattach sisagp_ca = {
	sizeof(struct agp_sis_softc), agp_sis_probe, agp_sis_attach,
	NULL, agp_sis_activate
};

struct cfdriver sisagp_cd = {
	NULL, "sisagp", DV_DULL
};

const struct agp_methods agp_sis_methods = {
	agp_sis_bind_page,
	agp_sis_unbind_page,
	agp_sis_flush_tlb,
};

int
agp_sis_probe(struct device *parent, void *match, void *aux)
{
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;

	/* Must be a pchb, don't attach to iommu-style agp devs */
	if (agpbus_probe(aa) == 1 && PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SIS &&
	   PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_SIS_755 &&
	   PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_SIS_760)
		return (1);
	return (0);
}


void
agp_sis_attach(struct device *parent, struct device *self, void *aux)
{
	struct agp_sis_softc	*ssc = (struct agp_sis_softc *)self;
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;
	struct agp_gatt		*gatt;
	pcireg_t		 reg;

	if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, AGP_APBASE,
	    PCI_MAPREG_TYPE_MEM, &ssc->ssc_apaddr, NULL, NULL) != 0) {
		printf(": can't get aperture info\n");
		return;
	}

	ssc->ssc_pc = pa->pa_pc;
	ssc->ssc_tag = pa->pa_tag;
	ssc->ssc_apsize = agp_sis_get_aperture(ssc);

	for (;;) {
		gatt = agp_alloc_gatt(pa->pa_dmat, ssc->ssc_apsize);
		if (gatt != NULL)
			break;

		/*
		 * Probably failed to alloc congigious memory. Try reducing the
		 * aperture so that the gatt size reduces.
		 */
		ssc->ssc_apsize /= 2;
		if (agp_sis_set_aperture(ssc, ssc->ssc_apsize)) {
			printf("can't set aperture size\n");
			return;
		}
	}
	ssc->gatt = gatt;

	/* Install the gatt. */
	pci_conf_write(ssc->ssc_pc, ssc->ssc_tag, AGP_SIS_ATTBASE,
	    gatt->ag_physical);
	
	/* Enable the aperture and auto-tlb-inval */
	reg = pci_conf_read(ssc->ssc_pc, ssc->ssc_tag, AGP_SIS_WINCTRL);
	reg |= (0x05 << 24) | 3;
	pci_conf_write(ssc->ssc_pc, ssc->ssc_tag, AGP_SIS_WINCTRL, reg);

	ssc->agpdev = (struct agp_softc *)agp_attach_bus(pa, &agp_sis_methods,
	    ssc->ssc_apaddr, ssc->ssc_apsize, &ssc->dev);
	return;
}

int
agp_sis_activate(struct device *arg, int act)
{
	struct agp_sis_softc *ssc = (struct agp_sis_softc *)arg;

	switch (act) {
	case DVACT_SUSPEND:
		agp_sis_save(ssc);
		break;
	case DVACT_RESUME:
		agp_sis_restore(ssc);
		break;
	}

	return (0);
}

void
agp_sis_save(struct agp_sis_softc *ssc)
{
	ssc->ssc_winctrl = pci_conf_read(ssc->ssc_pc, ssc->ssc_tag,
	    AGP_SIS_WINCTRL);
}

void
agp_sis_restore(struct agp_sis_softc *ssc)
{
	/* Install the gatt. */
	pci_conf_write(ssc->ssc_pc, ssc->ssc_tag, AGP_SIS_ATTBASE,
	    ssc->gatt->ag_physical);
	
	/*
	 * Enable the aperture, reset the aperture size and enable and
	 * auto-tlb-inval.
	 */
	pci_conf_write(ssc->ssc_pc, ssc->ssc_tag, AGP_SIS_WINCTRL,
	    ssc->ssc_winctrl);
}

bus_size_t
agp_sis_get_aperture(void *sc)
{
	struct agp_sis_softc	*ssc = sc;
	int			 gws;

	/*
	 * The aperture size is equal to 4M<<gws.
	 */
	gws = (pci_conf_read(ssc->ssc_pc, ssc->ssc_tag,
	    AGP_SIS_WINCTRL)&0x70) >> 4;
	return ((4 * 1024 * 1024) << gws);
}

int
agp_sis_set_aperture(void *sc, bus_size_t aperture)
{
	struct agp_sis_softc	*ssc = sc;
	int gws;
	pcireg_t reg;

	/*
	 * Check for a power of two and make sure its within the
	 * programmable range.
	 */
	if (aperture & (aperture - 1)
	    || aperture < 4*1024*1024
	    || aperture > 256*1024*1024)
		return (EINVAL);

	gws = ffs(aperture / 4*1024*1024) - 1;

	reg = pci_conf_read(ssc->ssc_pc, ssc->ssc_tag, AGP_SIS_WINCTRL);	
	reg &= ~0x00000070;
	reg |= gws << 4;
	pci_conf_write(ssc->ssc_pc, ssc->ssc_tag, AGP_SIS_WINCTRL, reg);

	return (0);
}

void
agp_sis_bind_page(void *sc, bus_addr_t offset, paddr_t physical, int flags)
{
	struct agp_sis_softc	*ssc = sc;

	ssc->gatt->ag_virtual[(offset - ssc->ssc_apaddr) >> AGP_PAGE_SHIFT] =
	    physical;
}

void
agp_sis_unbind_page(void *sc, bus_addr_t offset)
{
	struct agp_sis_softc	*ssc = sc;

	ssc->gatt->ag_virtual[(offset - ssc->ssc_apaddr) >> AGP_PAGE_SHIFT] = 0;
}

void
agp_sis_flush_tlb(void *sc)
{
	struct agp_sis_softc	*ssc = sc;
	pcireg_t		 reg;

	reg = pci_conf_read(ssc->ssc_pc, ssc->ssc_tag, AGP_SIS_TLBFLUSH);
	reg &= 0xffffff00;
	reg |= 0x02;
	pci_conf_write(ssc->ssc_pc, ssc->ssc_tag, AGP_SIS_TLBFLUSH, reg);
}
@


1.17
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.16 2014/03/17 22:01:56 kettenis Exp $	*/
a147 25

#if 0
int
agp_sis_detach(struct agp_softc *sc)
{
	struct agp_sis_softc *ssc = sc->sc_chipc;
	pcireg_t reg;
	int error;

	error = agp_generic_detach(sc);
	if (error)
		return (error);

	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_SIS_WINCTRL);
	reg &= ~3;
	reg &= 0x00ffffff;
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_SIS_WINCTRL, reg);

	/* Put the aperture back the way it started. */
	AGP_SET_APERTURE(sc, ssc->initial_aperture);

	agp_free_gatt(sc, ssc->gatt);
	return (0);
}
#endif
@


1.16
log
@The AGP ioctl interface is gone; remove the header file as well.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.15 2010/08/07 18:09:09 oga Exp $	*/
a34 3
#include <sys/kernel.h>
#include <sys/lock.h>
#include <sys/conf.h>
d36 1
@


1.15
log
@Suspend/resume handler for sisagp save/restoring the gtt window/size and
tlb enable states before we go down and whacking them back in on
bringup.

``commit'' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.14 2010/04/08 00:23:53 tedu Exp $	*/
a38 1
#include <sys/agpio.h>
@


1.14
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.13 2009/05/10 16:57:44 oga Exp $	*/
d58 1
d62 3
d73 2
a74 1
        sizeof(struct agp_sis_softc), agp_sis_probe, agp_sis_attach
d176 39
@


1.13
log
@Change agp attach (again) so that the driver passes in the aperture size.

While the aperture size may change during attach, it never changes after
the end of the subdriver attach function, so getting this value with a
function is a waste of time. shrinks things slightly and makes the code
clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.12 2009/05/10 15:28:45 oga Exp $	*/
a36 1
#include <sys/proc.h>
@


1.12
log
@In preparation for using agp as a bus_dma backend for drm, convert the bind_page
and unbind_page callbacks from

int bind_page(void *, off_t, bus_addr_t)

to

void bind_page(void *, bus_addr_t, paddr_t, int)

We can make these function void by making sure that the agp code sanity
checks properly (it already mostly did), so by definition these
functions may not fail.  The flags field is currently unused (intagp at
least will have a use for it soon).

Been in my tree for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.11 2009/05/10 14:44:42 oga Exp $	*/
d58 1
a58 1
	bus_size_t		 initial_aperture;
a77 1
	agp_sis_get_aperture,
d115 1
a115 1
	ssc->initial_aperture = agp_sis_get_aperture(ssc);
d118 1
a118 2
		bus_size_t size = agp_sis_get_aperture(ssc);
		gatt = agp_alloc_gatt(pa->pa_dmat, size);
d126 2
a127 1
		if (agp_sis_set_aperture(ssc, size / 2)) {
d144 1
a144 1
	    ssc->ssc_apaddr, &ssc->dev);
@


1.11
log
@change agp driver attach so that the driver passes in the base address
of its aperture, instead of the BAR and memory type. This is a little
larger, but allows the driver to know it's aperture address. Needed for
some future stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.10 2008/11/09 22:54:01 oga Exp $	*/
d65 2
a66 2
int	agp_sis_bind_page(void *, off_t, bus_addr_t);
int	agp_sis_unbind_page(void *, off_t);
d214 2
a215 2
int
agp_sis_bind_page(void *sc, off_t offset, bus_addr_t physical)
d219 2
a220 5
	if (offset < 0 || offset >= (ssc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	ssc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = physical;
	return (0);
d223 2
a224 2
int
agp_sis_unbind_page(void *sc, off_t offset)
d228 1
a228 5
	if (offset < 0 || offset >= (ssc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	ssc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = 0;
	return (0);
@


1.10
log
@correct device name.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.9 2008/11/09 22:47:54 oga Exp $	*/
d57 1
d108 6
d145 1
a145 1
	    AGP_APBASE, PCI_MAPREG_TYPE_MEM, &ssc->dev);
@


1.9
log
@Don't attach to the agp bridges on amd64 machines. They have a different
interface (which is currently used by iommu(4) on amd64). I have a
driver for that interface, but it would currently conflict with iommu
and as such has not been commited.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.8 2008/11/09 15:11:19 oga Exp $	*/
d73 1
a73 1
	NULL, "intelagp", DV_DULL
@


1.8
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.7 2007/12/07 17:35:22 oga Exp $	*/
d89 4
a92 2
	/* Must be a pchb */
	if (agpbus_probe(aa) == 1 && PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SIS)
@


1.7
log
@KNF, no binary change.

Looked over by a few people.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.6 2007/12/06 22:49:39 oga Exp $	*/
a31 1

d44 1
d52 18
a69 2
	u_int32_t	initial_aperture; /* aperture size at startup */
	struct agp_gatt *gatt;
d72 3
a74 5
u_int32_t agp_sis_get_aperture(struct agp_softc *);
int	agp_sis_set_aperture(struct agp_softc *, u_int32_t);
int	agp_sis_bind_page(struct agp_softc *, off_t, bus_addr_t);
int	agp_sis_unbind_page(struct agp_softc *, off_t);
void	agp_sis_flush_tlb(struct agp_softc *);
d76 1
a76 1
struct agp_methods agp_sis_methods = {
a77 1
	agp_sis_set_aperture,
a80 5
	agp_generic_enable,
	agp_generic_alloc_memory,
	agp_generic_free_memory,
	agp_generic_bind_memory,
	agp_generic_unbind_memory,
a82 1

d84 1
a84 1
agp_sis_attach(struct agp_softc *sc, struct pci_attach_args *pa)
d86 2
a87 3
	struct agp_sis_softc *ssc;
	struct agp_gatt *gatt;
	pcireg_t reg;
d89 5
a93 7
	ssc = malloc(sizeof *ssc, M_AGP, M_NOWAIT);
	if (ssc == NULL) {
		printf("can't allocate chipset-specific softc\n");
		return (ENOMEM);
	}
	sc->sc_methods = &agp_sis_methods;
	sc->sc_chipc = ssc;
a94 5
	if (agp_map_aperture(pa, sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
		printf("can't map aperture\n");
		free(ssc, M_AGP);
		return (ENXIO);
	}
d96 12
a107 1
	ssc->initial_aperture = AGP_GET_APERTURE(sc);
d110 3
a112 2
		gatt = agp_alloc_gatt(sc);
		if (gatt)
d116 1
a116 1
		 * Probably contigmalloc failure. Try reducing the
d119 3
a121 4
		if (AGP_SET_APERTURE(sc, AGP_GET_APERTURE(sc) / 2)) {
			agp_generic_detach(sc);
			printf("failed to set aperture\n");
			return (ENOMEM);
d127 1
a127 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_SIS_ATTBASE,
d131 1
a131 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_SIS_WINCTRL);
d133 1
a133 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_SIS_WINCTRL, reg);
d135 3
a137 1
	return (0);
d165 2
a166 2
u_int32_t
agp_sis_get_aperture(struct agp_softc *sc)
d168 2
a169 1
	int gws;
d174 1
a174 1
	gws = (pci_conf_read(sc->sc_pc, sc->sc_pcitag,
d180 1
a180 1
agp_sis_set_aperture(struct agp_softc *sc, u_int32_t aperture)
d182 1
d197 1
a197 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_SIS_WINCTRL);	
d200 1
a200 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_SIS_WINCTRL, reg);
d206 1
a206 1
agp_sis_bind_page(struct agp_softc *sc, off_t offset, bus_addr_t physical)
d208 1
a208 1
	struct agp_sis_softc *ssc = sc->sc_chipc;
d218 1
a218 1
agp_sis_unbind_page(struct agp_softc *sc, off_t offset)
d220 1
a220 1
	struct agp_sis_softc *ssc = sc->sc_chipc;
d230 1
a230 1
agp_sis_flush_tlb(struct agp_softc *sc)
d232 2
a233 1
	pcireg_t reg;
d235 1
a235 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_SIS_TLBFLUSH);
d238 1
a238 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_SIS_TLBFLUSH, reg);
@


1.6
log
@Destatic functions in the agp subsystem.

KNF coming shortly.

ok marco, jsg and mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.5 2007/11/26 15:35:15 deraadt Exp $	*/
d57 4
a60 4
int agp_sis_set_aperture(struct agp_softc *, u_int32_t);
int agp_sis_bind_page(struct agp_softc *, off_t, bus_addr_t);
int agp_sis_unbind_page(struct agp_softc *, off_t);
void agp_sis_flush_tlb(struct agp_softc *);
@


1.5
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.4 2007/11/25 17:11:12 oga Exp $	*/
d56 5
a60 5
static u_int32_t agp_sis_get_aperture(struct agp_softc *);
static int agp_sis_set_aperture(struct agp_softc *, u_int32_t);
static int agp_sis_bind_page(struct agp_softc *, off_t, bus_addr_t);
static int agp_sis_unbind_page(struct agp_softc *, off_t);
static void agp_sis_flush_tlb(struct agp_softc *);
d129 1
a129 1
static int
d153 1
a153 1
static u_int32_t
d166 1
a166 1
static int
d191 1
a191 1
static int
d203 1
a203 1
static int
d215 1
a215 1
static void
@


1.4
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.3 2007/08/04 19:40:25 reyk Exp $	*/
d85 1
a85 1
		printf(": can't allocate chipset-specific softc\n");
d92 1
a92 1
		printf(": can't map aperture\n");
d110 1
a110 1
			printf(": failed to set aperture\n");
@


1.3
log
@Add AGP support for the intel i965 chipset, this also extends the
internal AGP API to work with 64bit PCI-Express memory and
non-standard AGP aperture bases.

tested by many
ok matthieu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.2 2002/07/25 23:31:04 fgsch Exp $	*/
d56 5
a60 5
static u_int32_t agp_sis_get_aperture(struct vga_pci_softc *);
static int agp_sis_set_aperture(struct vga_pci_softc *, u_int32_t);
static int agp_sis_bind_page(struct vga_pci_softc *, off_t, bus_addr_t);
static int agp_sis_unbind_page(struct vga_pci_softc *, off_t);
static void agp_sis_flush_tlb(struct vga_pci_softc *);
d77 1
a77 2
agp_sis_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa,
	       struct pci_attach_args *pchb_pa)
d83 1
a83 1
	ssc = malloc(sizeof *ssc, M_DEVBUF, M_NOWAIT);
d91 1
a91 1
	if (agp_map_aperture(sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
d93 1
a93 1
		free(ssc, M_DEVBUF);
d130 1
a130 1
agp_sis_detach(struct vga_pci_softc *sc)
d154 1
a154 1
agp_sis_get_aperture(struct vga_pci_softc *sc)
d167 1
a167 1
agp_sis_set_aperture(struct vga_pci_softc *sc, u_int32_t aperture)
d192 1
a192 1
agp_sis_bind_page(struct vga_pci_softc *sc, off_t offset, bus_addr_t physical)
d204 1
a204 1
agp_sis_unbind_page(struct vga_pci_softc *sc, off_t offset)
d216 1
a216 1
agp_sis_flush_tlb(struct vga_pci_softc *sc)
@


1.2
log
@- some KNF.
- comment out debugging printf for i810.
- remove checks for failure if malloc is used with M_WAITOK.

mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_sis.c,v 1.1 2002/07/12 20:17:03 mickey Exp $	*/
d92 1
a92 1
	if (agp_map_aperture(sc) != 0) {
@


1.2.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 2
a78 1
agp_sis_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *pchb_pa)
d87 1
a87 1
		return ENOMEM;
d95 1
a95 1
		return ENXIO;
d112 1
a112 1
			return ENOMEM;
d126 1
a126 1
	return 0;
d139 1
a139 1
		return error;
d150 1
a150 1
	return 0;
d162 3
a164 2
	gws = (pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_SIS_WINCTRL)&0x70) >> 4;
	return (4*1024*1024) << gws;
d180 1
a180 1
		return EINVAL;
d189 1
a189 1
	return 0;
d198 1
a198 1
		return EINVAL;
d201 1
a201 1
	return 0;
d210 1
a210 1
		return EINVAL;
d213 1
a213 1
	return 0;
a225 1

@

