head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.20
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.18
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.16
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.14
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.8
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.6
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.12
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.10
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.8
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.9.0.10
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.2.0.8
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.18;
commitid	5gdEnqVoJuTuwdTu;

1.18
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.10.00.27.56;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.30.11.41.00;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.09.21.19.48;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.13.14.15.33;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.13.12.11.03;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.20.22.42.29;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.22.15.30.36;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.29.21.54.00;	author mickey;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.23.01.44.30;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.10.18.09.46;	author millert;	state Exp;
branches
	1.2.8.1;
next	1.1;

1.1
date	2000.04.10.13.55.01;	author millert;	state Exp;
branches;
next	;

1.2.8.1
date	2001.05.14.22.25.43;	author niklas;	state Exp;
branches;
next	1.2.8.2;

1.2.8.2
date	2001.07.04.10.42.09;	author niklas;	state Exp;
branches;
next	1.2.8.3;

1.2.8.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.2.8.4;

1.2.8.4
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.2.8.5;

1.2.8.5
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_an_pci.c,v 1.18 2011/04/03 15:36:02 jasper Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/an/if_an_pci.c,v 1.1 2000/01/14 20:40:56 wpaul Exp $
 */

/*
 * This is a PCI shim for the Aironet PC4500/4800 wireless network
 * driver. Aironet makes PCMCIA, ISA and PCI versions of these devices,
 * which all have basically the same interface. The ISA and PCI cards
 * are actually bridge adapters with PCMCIA cards inserted into them,
 * however they appear as normal PCI or ISA devices to the host.
 *
 * All we do here is handle the PCI match and attach and set up an
 * interrupt handler entry point. The PCI version of the card uses
 * a PLX 9050 PCI to "dumb bus" bridge chip, which provides us with
 * multiple PCI address space mappings. The primary mapping at PCI
 * register 0x14 is for the PLX chip itself, *NOT* the Aironet card.
 * The I/O address of the Aironet is actually at register 0x18, which
 * is the local bus mapping register for bus space 0. There are also
 * registers for additional register spaces at registers 0x1C and
 * 0x20, but these are unused in the Aironet devices. To find out
 * more, you need a datasheet for the 9050 from PLX, but you have
 * to go through their sales office to get it. Bleh.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_radiotap.h>
#include <net80211/ieee80211_var.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/anreg.h>
#include <dev/ic/anvar.h>

#define AN_PCI_PLX_LOIO		0x14	/* PLX chip iobase */
#define AN_PCI_LOIO		0x18	/* Aironet iobase */

int an_pci_match(struct device *, void *, void *);
void an_pci_attach(struct device *, struct device *, void *);

struct cfattach an_pci_ca = {
	sizeof (struct an_softc), an_pci_match, an_pci_attach
};

const struct pci_matchid an_pci_devices[] = {
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PCI352 },
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PC4500 },
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PC4800 },
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PC4800_1 },
};

int
an_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, an_pci_devices,
	    nitems(an_pci_devices)));
}

void
an_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct an_softc *sc = (struct an_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
	bus_space_handle_t ioh;
	bus_space_tag_t iot = pa->pa_iot;
	pci_chipset_tag_t pc = pa->pa_pc;
	const char *intrstr;

	/* Map the I/O ports. */
	if (pci_mapreg_map(pa, AN_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, NULL, NULL, 0) != 0) {
		printf(": can't map i/o space\n");
		return;
	}
	sc->sc_iot = iot;
	sc->sc_ioh = ioh;

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf("\n%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, an_intr, sc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("\n%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s", intrstr);

	sc->sc_enabled = 1;

	an_attach(sc);
}
@


1.18
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.17 2009/03/29 21:53:52 sthen Exp $	*/
a64 1
#include <net/if_dl.h>
@


1.17
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.16 2006/03/10 00:27:56 jsg Exp $	*/
d105 1
a105 1
	    sizeof(an_pci_devices)/sizeof(an_pci_devices[0])));
@


1.16
log
@ansi. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.15 2006/01/30 11:41:00 jsg Exp $	*/
d122 1
a122 1
		printf(": can't map I/O space\n");
@


1.15
log
@Add basic radiotap support.  Modelled somewhat after
ral and NetBSD wi radiotap.
"looks ok" damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.14 2006/01/09 21:19:48 jsg Exp $	*/
d102 1
a102 4
an_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d109 1
a109 4
an_pci_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
@


1.14
log
@Move an(4) to a driver based on the NetBSD one.
This brings net80211 support and support for newer hardware.
In addition ancontrol is no longer needed.

This driver does not yet work on big endian archs like the previous
one did.

"do it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.13 2005/09/13 14:15:33 mickey Exp $	*/
d71 1
@


1.13
log
@only include what is needed (tree.h) and not the whole metric assload of unrelated crap (mbuf.h)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.12 2005/09/13 12:11:03 reyk Exp $	*/
d80 1
a81 1
#include <dev/ic/anreg.h>
d130 2
a131 2
	sc->an_btag = iot;
	sc->an_bhandle = ioh;
d150 2
@


1.12
log
@replace the node hash table with a red-black tree. this fixes some
bugs in the node table (like duplicate nodes in hostap mode), we get
rid of possible hash collisions, and it simplifies the code.

tested by many, ok damien@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.11 2005/08/09 04:10:11 mickey Exp $	*/
d62 1
a62 1
#include <sys/mbuf.h>
@


1.11
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.10 2005/06/20 22:42:29 jsg Exp $	*/
d62 1
@


1.10
log
@Replace arpcom in the softc with ieee80211com in preparation for
further net80211 changes. ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.9 2002/11/19 18:40:17 jason Exp $	*/
a120 1
	pcireg_t csr;
a130 5

	/* Enable the card. */
	csr = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_MASTER_ENABLE);
@


1.9
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.8 2002/05/22 15:30:36 mickey Exp $	*/
d69 2
@


1.8
log
@another 4800 weirdo from cisco; from condor@@vcable.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.7 2002/03/14 01:26:58 millert Exp $	*/
d90 7
d103 2
a104 10
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_AIRONET &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PCI352 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PC4500 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PC4800 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PC4800_1))
		return(1);

	return(0);
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.6 2001/09/29 21:54:00 mickey Exp $	*/
d101 2
a102 1
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PC4800))
@


1.6
log
@if_media support, from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.5 2001/08/25 10:13:29 art Exp $	*/
d83 2
a84 2
int an_pci_match	__P((struct device *, void *, void *));
void an_pci_attach	__P((struct device *, struct device *, void *));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.6 2001/09/29 21:54:00 mickey Exp $	*/
d83 2
a84 2
int an_pci_match(struct device *, void *, void *);
void an_pci_attach(struct device *, struct device *, void *);
d101 1
a101 2
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PC4800 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PC4800_1))
@


1.6.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a89 7
const struct pci_matchid an_pci_devices[] = {
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PCI352 },
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PC4500 },
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PC4800 },
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PC4800_1 },
};

d96 10
a105 2
	return (pci_matchbyid((struct pci_attach_args *)aux, an_pci_devices,
	    sizeof(an_pci_devices)/sizeof(an_pci_devices[0])));
@


1.5
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.4 2001/06/23 01:44:30 mickey Exp $	*/
d65 1
@


1.4
log
@enable attaching on pci35x models, seems to work ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.3 2001/06/12 15:40:31 niklas Exp $	*/
d136 1
a136 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.3
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.2 2000/04/10 18:09:46 millert Exp $	*/
d98 2
a99 1
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PC4500 ||
@


1.2
log
@Use pci_mapreg_map() instead of pci_io_find() and pci_mapreg_map()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.1 2000/04/10 13:55:01 millert Exp $	*/
d122 1
a122 1
	    &iot, &ioh, NULL, NULL) != 0) {
@


1.2.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.2 2000/04/10 18:09:46 millert Exp $	*/
@


1.2.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.2.8.1 2001/05/14 22:25:43 niklas Exp $	*/
d98 1
a98 2
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PCI352 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AIRONET_PC4500 ||
d122 1
a122 1
	    &iot, &ioh, NULL, NULL, 0) != 0) {
@


1.2.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pci.c,v 1.2.8.2 2001/07/04 10:42:09 niklas Exp $	*/
a64 1
#include <net/if_media.h>
d136 2
a137 1
	if (pci_intr_map(pa, &ih)) {
@


1.2.8.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 2
a84 2
int an_pci_match(struct device *, void *, void *);
void an_pci_attach(struct device *, struct device *, void *);
@


1.2.8.5
log
@Sync the SMP branch with 3.3
@
text
@a89 7
const struct pci_matchid an_pci_devices[] = {
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PCI352 },
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PC4500 },
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PC4800 },
	{ PCI_VENDOR_AIRONET, PCI_PRODUCT_AIRONET_PC4800_1 },
};

d96 9
a104 2
	return (pci_matchbyid((struct pci_attach_args *)aux, an_pci_devices,
	    sizeof(an_pci_devices)/sizeof(an_pci_devices[0])));
@


1.1
log
@Aironet PCI shim; all the real meat is in sys/ic/an.c.
Based on the FreeBSD if_an_pci.c but really the only things that
remain the same are the informative comments at the top.  I retained
Bill Paul's Copyright since it seems silly to add my own copyright
to what is simply boilerplate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_pci.c,v 1.12 1999/08/10 08:10:35 deraadt Exp $	*/
a113 2
	bus_addr_t iobase;
	bus_size_t iosize;
d120 3
a122 6
	/* Map the I/O ports (note that non-standard location). */
	if (pci_io_find(pc, pa->pa_tag, AN_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find I/O base\n");
		return;
	}
	if (bus_space_map(iot, iobase, iosize, 0, &ioh)) {
a125 1

@

