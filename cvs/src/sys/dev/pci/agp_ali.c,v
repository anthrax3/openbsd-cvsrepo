head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.12
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.6
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.12.0.18
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.14
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.12
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.10
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.24
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.22
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.20
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.18
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.16
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.14
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.12
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.10
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	SMP:1.2.0.8
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	UBC:1.2.0.4
	UBC_SYNC_B:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.15
date	2014.05.27.12.40.00;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.13;

1.13
date	2014.03.17.22.01.56;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.07.18.15.38;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.10.16.57.44;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.10.15.28.45;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.10.14.44.42;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.09.22.47.54;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.26.15.35.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.04.19.40.25;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.25.23.31.04;	author fgsch;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	;

1.2.4.1
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@We're never going to detach agp(4), so remove the #ifdef'ed out code like we
already did for intagp(4).
@
text
@/*	$OpenBSD: agp_ali.c,v 1.14 2014/03/26 14:41:41 mpi Exp $	*/
/*	$NetBSD: agp_ali.c,v 1.2 2001/09/15 00:25:00 thorpej Exp $	*/


/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agp_ali.c,v 1.3 2001/07/05 21:28:46 jhb Exp $
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/rwlock.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/vga_pcivar.h>
#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>

#include <machine/bus.h>

struct agp_ali_softc {
	struct device		 dev;
	struct agp_softc	*agpdev;
	struct agp_gatt		*gatt;
	pci_chipset_tag_t	 asc_pc;
	pcitag_t		 asc_tag;
	bus_addr_t		 asc_apaddr;
	bus_size_t		 asc_apsize;
	pcireg_t		 asc_attbase;
	pcireg_t		 asc_tlbctrl;
};

void	agp_ali_attach(struct device *, struct device *, void *);
int	agp_ali_activate(struct device *, int);
void	agp_ali_save(struct agp_ali_softc *);
void	agp_ali_restore(struct agp_ali_softc *);
int	agp_ali_probe(struct device *, void *, void *);
bus_size_t agp_ali_get_aperture(void *);
int	agp_ali_set_aperture(void *sc, bus_size_t);
void	agp_ali_bind_page(void *, bus_addr_t, paddr_t, int);
void	agp_ali_unbind_page(void *, bus_addr_t);
void	agp_ali_flush_tlb(void *);

struct cfattach aliagp_ca = {
	sizeof(struct agp_ali_softc), agp_ali_probe, agp_ali_attach,
	NULL, agp_ali_activate
};

struct cfdriver aliagp_cd = {
	NULL, "aliagp", DV_DULL
};

const struct agp_methods agp_ali_methods = {
	agp_ali_bind_page,
	agp_ali_unbind_page,
	agp_ali_flush_tlb,
};

int
agp_ali_probe(struct device *parent, void *match, void *aux)
{
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;

	/* Must be a pchb, don't attach to iommu-style agp devs */
	if (agpbus_probe(aa) == 1 && PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALI &&
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_ALI_M1689)
		return (1);
	return (0);
}

void 
agp_ali_attach(struct device *parent, struct device *self, void *aux)
{
	struct agp_ali_softc	*asc = (struct agp_ali_softc *)self;
	struct agp_gatt		*gatt;
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;
	pcireg_t		 reg;

	asc->asc_tag = pa->pa_tag;
	asc->asc_pc = pa->pa_pc;
	asc->asc_apsize = agp_ali_get_aperture(asc);

	if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, AGP_APBASE,
	    PCI_MAPREG_TYPE_MEM, &asc->asc_apaddr, NULL, NULL) != 0) {
		printf(": can't get aperture info\n");
		return;
	}

	for (;;) {
		gatt = agp_alloc_gatt(pa->pa_dmat, asc->asc_apsize);
		if (gatt != NULL)
			break;
		/*
		 * almost certainly error allocating contigious dma memory
		 * so reduce aperture so that the gatt size reduces.
		 */
		asc->asc_apsize /= 2;
		if (agp_ali_set_aperture(asc, asc->asc_apsize)) {
			printf("failed to set aperture\n");
			return;
		}
	}
	asc->gatt = gatt;

	/* Install the gatt. */
	reg = pci_conf_read(asc->asc_pc, asc->asc_tag, AGP_ALI_ATTBASE);
	reg = (reg & 0xff) | gatt->ag_physical;
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_ALI_ATTBASE, reg);
	
	/* Enable the TLB. */
	reg = pci_conf_read(asc->asc_pc, asc->asc_tag, AGP_ALI_TLBCTRL);
	reg = (reg & ~0xff) | 0x10;
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_ALI_TLBCTRL, reg);

	asc->agpdev = (struct agp_softc *)agp_attach_bus(pa, &agp_ali_methods,
	    asc->asc_apaddr, asc->asc_apsize, &asc->dev);
	return;
}

int
agp_ali_activate(struct device *arg, int act)
{
	struct agp_ali_softc *asc = (struct agp_ali_softc *)arg;

	switch (act) {
	case DVACT_SUSPEND:
		agp_ali_save(asc);
		break;
	case DVACT_RESUME:
		agp_ali_restore(asc);
		break;
	}

	return (0);
}

void
agp_ali_save(struct agp_ali_softc *asc)
{
	asc->asc_attbase = pci_conf_read(asc->asc_pc, asc->asc_tag,
	    AGP_ALI_ATTBASE);
	asc->asc_tlbctrl = pci_conf_read(asc->asc_pc, asc->asc_tag,
	    AGP_ALI_TLBCTRL);
}

void
agp_ali_restore(struct agp_ali_softc *asc)
{

	/* Install the gatt and aperture size. */
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_ALI_ATTBASE,
	    asc->asc_attbase);
	
	/* Enable the TLB. */
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_ALI_TLBCTRL,
	    asc->asc_tlbctrl);
}

#define M 1024*1024

static const u_int32_t agp_ali_table[] = {
	0,			/* 0 - invalid */
	1,			/* 1 - invalid */
	2,			/* 2 - invalid */
	4*M,			/* 3 - invalid */
	8*M,			/* 4 - invalid */
	0,			/* 5 - invalid */
	16*M,			/* 6 - invalid */
	32*M,			/* 7 - invalid */
	64*M,			/* 8 - invalid */
	128*M,			/* 9 - invalid */
	256*M,			/* 10 - invalid */
};
#define agp_ali_table_size (sizeof(agp_ali_table) / sizeof(agp_ali_table[0]))

bus_size_t
agp_ali_get_aperture(void *sc)
{
	struct agp_ali_softc	*asc = sc;
	int			 i;

	/*
	 * The aperture size is derived from the low bits of attbase.
	 * I'm not sure this is correct..
	 */
	i = (int)pci_conf_read(asc->asc_pc, asc->asc_tag,
	    AGP_ALI_ATTBASE) & 0xff;
	if (i >= agp_ali_table_size)
		return (0);
	return (agp_ali_table[i]);
}

int
agp_ali_set_aperture(void *sc, bus_size_t aperture)
{
	struct agp_ali_softc	*asc = sc;
	int			 i;
	pcireg_t		 reg;

	for (i = 0; i < agp_ali_table_size; i++)
		if (agp_ali_table[i] == aperture)
			break;
	if (i == agp_ali_table_size)
		return (EINVAL);

	reg = pci_conf_read(asc->asc_pc, asc->asc_tag, AGP_ALI_ATTBASE);
	reg &= ~0xff;
	reg |= i;
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_ALI_ATTBASE, reg);
	return (0);
}

void
agp_ali_bind_page(void *sc, bus_addr_t offset, paddr_t physical, int flags)
{
	struct agp_ali_softc *asc = sc;

	asc->gatt->ag_virtual[(offset - asc->asc_apaddr) >> AGP_PAGE_SHIFT] =
	    physical;
}

void
agp_ali_unbind_page(void *sc, bus_size_t offset)
{
	struct agp_ali_softc *asc = sc;

	asc->gatt->ag_virtual[(offset - asc->asc_apaddr) >> AGP_PAGE_SHIFT] = 0;
}

void
agp_ali_flush_tlb(void *sc)
{
	struct agp_ali_softc	*asc = sc;
	pcireg_t		reg;

	reg = pci_conf_read(asc->asc_pc, asc->asc_tag, AGP_ALI_TLBCTRL);
	reg &= ~0xff;
	reg |= 0x90;
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_ALI_TLBCTRL, reg);
	reg &= ~0xff;
	reg |= 0x10;
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_ALI_TLBCTRL, reg);
}

@


1.14
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.13 2014/03/17 22:01:56 kettenis Exp $	*/
a147 29

#if 0
int
agp_ali_detach(struct agp_softc *sc)
{
	int error;
	pcireg_t reg;
	struct agp_ali_softc *asc = sc->sc_chipc;

	error = agp_generic_detach(sc);
	if (error)
		return (error);

	/* Disable the TLB.. */
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_ALI_TLBCTRL);
	reg &= ~0xff;
	reg |= 0x90;
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_ALI_TLBCTRL, reg);

	/* Put the aperture back the way it started. */
	AGP_SET_APERTURE(sc, asc->initial_aperture);
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_ALI_ATTBASE);
	reg &= 0xff;
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_ALI_ATTBASE, reg);

	agp_free_gatt(sc, asc->gatt);
	return (0);
}
#endif
@


1.13
log
@The AGP ioctl interface is gone; remove the header file as well.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.12 2010/08/07 18:15:38 oga Exp $	*/
a33 1
#include <sys/kernel.h>
a35 1
#include <sys/conf.h>
d37 1
a37 1
#include <sys/lock.h>
@


1.12
log
@save/restore functions for aliagp.

Very similar to other agp suspend functions.

ok kettenis@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.11 2010/04/08 00:23:53 tedu Exp $	*/
a39 1
#include <sys/agpio.h>
@


1.11
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.10 2009/05/10 16:57:44 oga Exp $	*/
d59 2
d64 3
d75 2
a76 1
        sizeof(struct agp_ali_softc), agp_ali_probe, agp_ali_attach
d180 39
@


1.10
log
@Change agp attach (again) so that the driver passes in the aperture size.

While the aperture size may change during attach, it never changes after
the end of the subdriver attach function, so getting this value with a
function is a waste of time. shrinks things slightly and makes the code
clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.9 2009/05/10 15:28:45 oga Exp $	*/
a36 1
#include <sys/proc.h>
@


1.9
log
@In preparation for using agp as a bus_dma backend for drm, convert the bind_page
and unbind_page callbacks from

int bind_page(void *, off_t, bus_addr_t)

to

void bind_page(void *, bus_addr_t, paddr_t, int)

We can make these function void by making sure that the agp code sanity
checks properly (it already mostly did), so by definition these
functions may not fail.  The flags field is currently unused (intagp at
least will have a use for it soon).

Been in my tree for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.8 2009/05/10 14:44:42 oga Exp $	*/
d59 1
a59 1
	bus_size_t		 initial_aperture;
a78 1
	agp_ali_get_aperture,
d108 1
a108 1
	asc->initial_aperture = agp_ali_get_aperture(asc);
d117 1
a117 2
		bus_size_t size = agp_ali_get_aperture(asc);
		gatt = agp_alloc_gatt(pa->pa_dmat, size);
d124 2
a125 1
		if (agp_ali_set_aperture(asc, size / 2)) {
d143 1
a143 1
	    asc->asc_apaddr, &asc->dev);
@


1.8
log
@change agp driver attach so that the driver passes in the base address
of its aperture, instead of the BAR and memory type. This is a little
larger, but allows the driver to know it's aperture address. Needed for
some future stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.7 2008/11/09 22:47:54 oga Exp $	*/
d66 2
a67 2
int	agp_ali_bind_page(void *, off_t, bus_addr_t);
int	agp_ali_unbind_page(void *, off_t);
d231 2
a232 2
int
agp_ali_bind_page(void *sc, off_t offset, bus_addr_t physical)
d236 2
a237 5
	if (offset < 0 || offset >= (asc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	asc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = physical;
	return (0);
d240 2
a241 2
int
agp_ali_unbind_page(void *sc, off_t offset)
d245 1
a245 5
	if (offset < 0 || offset >= (asc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	asc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = 0;
	return (0);
@


1.7
log
@Don't attach to the agp bridges on amd64 machines. They have a different
interface (which is currently used by iommu(4) on amd64). I have a
driver for that interface, but it would currently conflict with iommu
and as such has not been commited.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.6 2008/11/09 15:11:19 oga Exp $	*/
d58 1
d111 6
d144 1
a144 1
	    AGP_APBASE, PCI_MAPREG_TYPE_MEM, &asc->dev);
@


1.6
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.5 2007/11/26 15:35:15 deraadt Exp $	*/
d90 3
a92 2
	/* Must be a pchb */
	if (agpbus_probe(aa) == 1 && PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALI)
@


1.5
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.4 2007/11/25 17:11:12 oga Exp $	*/
a32 2


d45 1
d53 18
a70 2
	u_int32_t	initial_aperture; /* aperture size at startup */
	struct agp_gatt *gatt;
d73 3
a75 5
u_int32_t agp_ali_get_aperture(struct agp_softc *);
int	agp_ali_set_aperture(struct agp_softc *sc, u_int32_t);
int	agp_ali_bind_page(struct agp_softc *, off_t, bus_addr_t);
int	agp_ali_unbind_page(struct agp_softc *, off_t);
void	agp_ali_flush_tlb(struct agp_softc *);
d77 1
a77 1
struct agp_methods agp_ali_methods = {
a78 1
	agp_ali_set_aperture,
a81 5
	agp_generic_enable,
	agp_generic_alloc_memory,
	agp_generic_free_memory,
	agp_generic_bind_memory,
	agp_generic_unbind_memory,
d84 2
a85 2
int 
agp_ali_attach(struct agp_softc *sc, struct pci_attach_args *pa)
d87 2
a88 3
	struct agp_ali_softc *asc;
	struct agp_gatt *gatt;
	pcireg_t reg;
d90 5
a94 7
	asc = malloc(sizeof *asc, M_AGP, M_NOWAIT);
	if (asc == NULL) {
		printf("failed to allocate softc\n");
		return (ENOMEM);
	}
	sc->sc_chipc = asc;
	sc->sc_methods = &agp_ali_methods;
d96 12
a107 7
	if (agp_map_aperture(pa, sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
		printf("failed to map aperture\n");
		free(asc, M_AGP);
		return (ENXIO);
	}

	asc->initial_aperture = agp_ali_get_aperture(sc);
d110 2
a111 1
		gatt = agp_alloc_gatt(sc);
a113 1

d115 2
a116 2
		 * Probably contigmalloc failure. Try reducing the
		 * aperture so that the gatt size reduces.
d118 1
a118 2
		if (AGP_SET_APERTURE(sc, AGP_GET_APERTURE(sc) / 2)) {
			agp_generic_detach(sc);
d120 1
a120 1
			return (ENOMEM);
d126 1
a126 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_ALI_ATTBASE);
d128 1
a128 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_ALI_ATTBASE, reg);
d131 1
a131 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_ALI_TLBCTRL);
d133 1
a133 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_ALI_TLBCTRL, reg);
d135 3
a137 1
	return (0);
d186 2
a187 2
u_int32_t
agp_ali_get_aperture(struct agp_softc *sc)
d189 2
a190 1
	int i;
d196 1
a196 1
	i = (int)pci_conf_read(sc->sc_pc, sc->sc_pcitag,
d204 1
a204 1
agp_ali_set_aperture(struct agp_softc *sc, u_int32_t aperture)
d206 3
a208 2
	int i;
	pcireg_t reg;
d216 1
a216 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_ALI_ATTBASE);
d219 1
a219 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_ALI_ATTBASE, reg);
d224 1
a224 1
agp_ali_bind_page(struct agp_softc *sc, off_t offset, bus_addr_t physical)
d226 1
a226 1
	struct agp_ali_softc *asc = sc->sc_chipc;
d236 1
a236 1
agp_ali_unbind_page(struct agp_softc *sc, off_t offset)
d238 1
a238 1
	struct agp_ali_softc *asc = sc->sc_chipc;
d248 1
a248 1
agp_ali_flush_tlb(struct agp_softc *sc)
d250 2
a251 1
	pcireg_t reg;
d253 1
a253 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_ALI_TLBCTRL);
d256 1
a256 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_ALI_TLBCTRL, reg);
d259 1
a259 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_ALI_TLBCTRL, reg);
@


1.4
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.3 2007/08/04 19:40:25 reyk Exp $	*/
d86 1
a86 1
		printf(": failed to allocate softc\n");
d93 1
a93 1
		printf(": failed to map aperture\n");
d111 1
a111 1
			printf(": failed to set aperture\n");
@


1.3
log
@Add AGP support for the intel i965 chipset, this also extends the
internal AGP API to work with 64bit PCI-Express memory and
non-standard AGP aperture bases.

tested by many
ok matthieu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.2 2002/07/25 23:31:04 fgsch Exp $	*/
d58 5
a62 5
u_int32_t agp_ali_get_aperture(struct vga_pci_softc *);
int	agp_ali_set_aperture(struct vga_pci_softc *sc, u_int32_t);
int	agp_ali_bind_page(struct vga_pci_softc *, off_t, bus_addr_t);
int	agp_ali_unbind_page(struct vga_pci_softc *, off_t);
void	agp_ali_flush_tlb(struct vga_pci_softc *);
d78 1
a78 2
agp_ali_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa,
	       struct pci_attach_args *pchb_pa)
d84 1
a84 1
	asc = malloc(sizeof *asc, M_DEVBUF, M_NOWAIT);
d92 1
a92 1
	if (agp_map_aperture(sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
d94 1
a94 1
		free(asc, M_DEVBUF);
d132 1
a132 1
agp_ali_detach(struct vga_pci_softc *sc)
d177 1
a177 1
agp_ali_get_aperture(struct vga_pci_softc *sc)
d193 1
a193 1
agp_ali_set_aperture(struct vga_pci_softc *sc, u_int32_t aperture)
d202 1
a202 1
		return EINVAL;
d212 1
a212 1
agp_ali_bind_page(struct vga_pci_softc *sc, off_t offset, bus_addr_t physical)
d224 1
a224 1
agp_ali_unbind_page(struct vga_pci_softc *sc, off_t offset)
d236 1
a236 1
agp_ali_flush_tlb(struct vga_pci_softc *sc)
@


1.2
log
@- some KNF.
- comment out debugging printf for i810.
- remove checks for failure if malloc is used with M_WAITOK.

mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_ali.c,v 1.1 2002/07/12 20:17:03 mickey Exp $	*/
d93 1
a93 1
	if (agp_map_aperture(sc) != 0) {
@


1.2.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 4
a62 4
int agp_ali_set_aperture(struct vga_pci_softc *sc, u_int32_t);
int agp_ali_bind_page(struct vga_pci_softc *, off_t, bus_addr_t);
int agp_ali_unbind_page(struct vga_pci_softc *, off_t);
void agp_ali_flush_tlb(struct vga_pci_softc *);
d78 2
a79 1
agp_ali_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *pchb_pa)
d88 1
a88 1
		return ENOMEM;
d96 1
a96 1
		return ENXIO;
d113 1
a113 1
			return ENOMEM;
d128 1
a128 1
	return 0;
d141 1
a141 1
		return error;
d156 1
a156 1
	return 0;
d186 2
a187 1
	i = (int)pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_ALI_ATTBASE) & 0xff;
d189 2
a190 2
		return 0;
	return agp_ali_table[i];
d209 1
a209 1
	return 0;
d218 1
a218 1
		return EINVAL;
d221 1
a221 1
	return 0;
d230 1
a230 1
		return EINVAL;
d233 1
a233 1
	return 0;
@

