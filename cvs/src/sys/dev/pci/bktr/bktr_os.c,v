head	1.32;
access;
symbols
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.10
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.8
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.31.0.10
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.8
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.6
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.16
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.14
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.12
	OPENBSD_5_0:1.30.0.10
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.8
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.6
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.13
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.32
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.31;
commitid	p4LJxGKbi0BU2cG6;

1.31
date	2013.07.01.07.18.23;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.29.21.53.53;	author sthen;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.25.00.36.10;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.26.09.28.34;	author martynas;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.18.07.31.14;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.11.08.10.22;	author robert;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.05.23.52.58;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.15.20.38.41;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.05.15.16.26;	author robert;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.02.15.01.32;	author robert;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.21.18.16.41;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.29.12.24.57;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.24.21.56.41;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.24.21.45.36;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.04.14.47.28;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.15.06.30.35;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.05.01.24.53;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.13.16.25.36;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.06.20.57.47;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.06.16.29.37;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.03.16.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.23.18.41.07;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.04.04.59.29;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.12.15.40.33;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.16.07.15.41;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.28.03.27.09;	author fgsch;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2001.11.05.22.53.18;	author miod;	state Exp;
branches;
next	;

1.1.4.1
date	2001.05.14.22.26.03;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.07.04.10.43.17;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2002.03.30.08.22.04;	author niklas;	state Exp;
branches;
next	1.1.4.7;

1.1.4.7
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.1.4.8;

1.1.4.8
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	1.1.4.9;

1.1.4.9
date	2004.06.05.23.12.55;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.01.31.22.55.37;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.05.19.22.19.37;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: bktr_os.c,v 1.31 2013/07/01 07:18:23 brad Exp $	*/
/* $FreeBSD: src/sys/dev/bktr/bktr_os.c,v 1.20 2000/10/20 08:16:53 roger Exp $ */

/*
 * This is part of the Driver for Video Capture Cards (Frame grabbers)
 * and TV Tuner cards using the Brooktree Bt848, Bt848A, Bt849A, Bt878, Bt879
 * chipset.
 * Copyright Roger Hardiman and Amancio Hasty.
 *
 * bktr_os : This has all the Operating System dependant code,
 *             probe/attach and open/close/ioctl/read/mmap
 *             memory allocation
 *             PCI bus interfacing
 *             
 *
 */

/*
 * 1. Redistributions of source code must retain the 
 * Copyright (c) 1997 Amancio Hasty, 1999 Roger Hardiman
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Amancio Hasty and
 *      Roger Hardiman
 * 4. The name of the author may not be used to endorse or promote products 
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define FIFO_RISC_DISABLED      0
#define ALL_INTS_DISABLED       0

#include "radio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/selinfo.h>
#include <sys/vnode.h>
#if NRADIO > 0
#include <sys/radioio.h>
#include <dev/radio_if.h>
#endif

#include <uvm/uvm_extern.h>

#include <sys/device.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#ifdef BKTR_DEBUG
int bktr_debug = 1;
#define DPR(x)	(bktr_debug ? printf x : 0)
#else
#define DPR(x)
#endif

#include <dev/ic/bt8xx.h>	/* OpenBSD location for .h files */
#include <dev/pci/bktr/bktr_reg.h>
#include <dev/pci/bktr/bktr_tuner.h>
#include <dev/pci/bktr/bktr_audio.h>
#include <dev/pci/bktr/bktr_core.h>
#include <dev/pci/bktr/bktr_os.h>

#define IPL_VIDEO       IPL_BIO         /* XXX */

static	int		bktr_intr(void *arg) { return common_bktr_intr(arg); }

#define bktr_open       bktropen
#define bktr_close      bktrclose
#define bktr_read       bktrread
#define bktr_write      bktrwrite
#define bktr_ioctl      bktrioctl
#define bktr_mmap       bktrmmap

int	bktr_open(dev_t, int, int, struct proc *);
int	bktr_close(dev_t, int, int, struct proc *);
int	bktr_read(dev_t, struct uio *, int);
int	bktr_write(dev_t, struct uio *, int);
int	bktr_ioctl(dev_t, ioctl_cmd_t, caddr_t, int, struct proc *);
paddr_t	bktr_mmap(dev_t, off_t, int);

static int      bktr_probe(struct device *, void *, void *);
static void     bktr_attach(struct device *, struct device *, void *);

struct cfattach bktr_ca = {
        sizeof(struct bktr_softc), bktr_probe, bktr_attach
};

struct cfdriver bktr_cd = {
        NULL, "bktr", DV_DULL
};

#if NRADIO > 0
/* for radio(4) */
int	bktr_get_info(void *, struct radio_info *);
int	bktr_set_info(void *, struct radio_info *);

struct radio_hw_if bktr_hw_if = {
	NULL,	/* open */
	NULL,	/* close */
	bktr_get_info,
	bktr_set_info,
	NULL	/* search */
};
#endif

int
bktr_probe(parent, match, aux)
	struct device *parent;
        void *match;
        void *aux;
{
        struct pci_attach_args *pa = aux;

        if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_BROOKTREE &&
            (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROOKTREE_BT848 ||
             PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROOKTREE_BT849 ||
             PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROOKTREE_BT878 ||
             PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROOKTREE_BT879))
                return 1;

        return 0;
}


/*
 * the attach routine.
 */
static void
bktr_attach(struct device *parent, struct device *self, void *aux)
{
	bktr_ptr_t	bktr;
	u_int		latency;
	u_int		fun;
	unsigned int	rev;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
	const char *intrstr;
	int retval;
	int unit;

	bktr = (bktr_ptr_t)self;
	unit = bktr->bktr_dev.dv_unit;
        bktr->dmat = pa->pa_dmat;

	/* Enable Back-to-Back
	   XXX: check if all old DMA is stopped first (e.g. after warm
	   boot) */
	fun = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	DPR((" fun=%b", fun, PCI_COMMAND_STATUS_BITS));
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    fun | PCI_COMMAND_BACKTOBACK_ENABLE);

	/*
	 * map memory
	 */
	retval = pci_mapreg_map(pa, PCI_MAPREG_START, PCI_MAPREG_TYPE_MEM |
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &bktr->memt, &bktr->memh, NULL,
	    &bktr->obmemsz, 0);
	DPR(("pci_mapreg_map: memt %lx, memh %lx, size %x\n",
	     bktr->memt, bktr->memh, bktr->obmemsz));
	if (retval) {
		printf("%s: can't map mem space\n", bktr_name(bktr));
		return;
	}

	/*
	 * Disable the brooktree device
	 */
	OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);
	OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);
	
	/*
	 * map interrupt
	 */
	if (pci_intr_map(pa, &ih)) {
		printf("%s: can't map interrupt\n",
		       bktr_name(bktr));
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	bktr->ih = pci_intr_establish(pa->pa_pc, ih, IPL_VIDEO,
	    bktr_intr, bktr, bktr->bktr_dev.dv_xname);
	if (bktr->ih == NULL) {
		printf("%s: can't establish interrupt",
		       bktr_name(bktr));
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	if (intrstr != NULL)
		printf(": %s\n", intrstr);
	
/*
 * PCI latency timer.  32 is a good value for 4 bus mastering slots, if
 * you have more than four, then 16 would probably be a better value.
 */
#ifndef BROOKTREE_DEF_LATENCY_VALUE
#define BROOKTREE_DEF_LATENCY_VALUE	0x10
#endif
	latency = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_LATENCY_TIMER);
	latency = (latency >> 8) & 0xff;

	if (!latency) {
		if (bootverbose) {
			printf("%s: PCI bus latency was 0 changing to %d",
			       bktr_name(bktr), BROOKTREE_DEF_LATENCY_VALUE);
		}
		latency = BROOKTREE_DEF_LATENCY_VALUE;
		pci_conf_write(pa->pa_pc, pa->pa_tag, 
			       PCI_LATENCY_TIMER, latency<<8);
	}


	/* read the pci id and determine the card type */
	fun = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ID_REG);
        rev = PCI_REVISION(pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG));

	common_bktr_attach(bktr, unit, fun, rev);

#if NRADIO > 0
	if (bktr->card.tuner->pllControl[3] != 0x00)
		radio_attach_mi(&bktr_hw_if, bktr, &bktr->bktr_dev);
#endif
}


/*
 * Special Memory Allocation
 */
vaddr_t
get_bktr_mem(bktr, dmapp, size)
        bktr_ptr_t bktr;
        bus_dmamap_t *dmapp;
        unsigned int size;
{
        bus_dma_tag_t dmat = bktr->dmat;
        bus_dma_segment_t seg;
        bus_size_t align;
        int rseg;
        caddr_t kva;

        /*
         * Allocate a DMA area
         */
        align = 1 << 24;
        if (bus_dmamem_alloc(dmat, size, align, 0, &seg, 1,
                             &rseg, BUS_DMA_NOWAIT)) {
                align = PAGE_SIZE;
                if (bus_dmamem_alloc(dmat, size, align, 0, &seg, 1,
                                     &rseg, BUS_DMA_NOWAIT)) {
                        printf("%s: Unable to dmamem_alloc of %d bytes\n",
			       bktr_name(bktr), size);
                        return 0;
                }
        }
        if (bus_dmamem_map(dmat, &seg, rseg, size,
                           &kva, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
                printf("%s: Unable to dmamem_map of %d bytes\n",
                        bktr_name(bktr), size);
                bus_dmamem_free(dmat, &seg, rseg);
                return 0;
        }
        /*
         * Create and locd the DMA map for the DMA area
         */
        if (bus_dmamap_create(dmat, size, 1, size, 0, BUS_DMA_NOWAIT, dmapp)) {
                printf("%s: Unable to dmamap_create of %d bytes\n",
                        bktr_name(bktr), size);
                bus_dmamem_unmap(dmat, kva, size);
                bus_dmamem_free(dmat, &seg, rseg);
                return 0;
        }
        if (bus_dmamap_load(dmat, *dmapp, kva, size, NULL, BUS_DMA_NOWAIT)) {
                printf("%s: Unable to dmamap_load of %d bytes\n",
                        bktr_name(bktr), size);
                bus_dmamem_unmap(dmat, kva, size);
                bus_dmamem_free(dmat, &seg, rseg);
                bus_dmamap_destroy(dmat, *dmapp);
                return 0;
        }
        return (vaddr_t)kva;
}

void
free_bktr_mem(bktr, dmap, kva)
        bktr_ptr_t bktr;
        bus_dmamap_t dmap;
        vaddr_t kva;
{
        bus_dma_tag_t dmat = bktr->dmat;

        bus_dmamem_unmap(dmat, (caddr_t)kva, dmap->dm_mapsize);
        bus_dmamem_free(dmat, dmap->dm_segs, 1);
        bus_dmamap_destroy(dmat, dmap);
}


/*---------------------------------------------------------
**
**	BrookTree 848 character device driver routines
**
**---------------------------------------------------------
*/


#define VIDEO_DEV	0x00
#define TUNER_DEV	0x01
#define VBI_DEV		0x02

#define UNIT(x)         (minor((x) & 0x0f))
#define FUNCTION(x)     (minor((x >> 4) & 0x0f))

/*
 * 
 */
int
bktr_open(dev_t dev, int flags, int fmt, struct proc *p)
{
	bktr_ptr_t	bktr;
	int		unit;

	unit = UNIT(dev);

	/* unit out of range */
	if ((unit >= bktr_cd.cd_ndevs) || (bktr_cd.cd_devs[unit] == NULL))
		return(ENXIO);

	bktr = bktr_cd.cd_devs[unit];

	if (!(bktr->flags & METEOR_INITIALIZED)) /* device not found */
		return(ENXIO);	

	switch (FUNCTION(dev)) {
	case VIDEO_DEV:
		return(video_open(bktr));
	case TUNER_DEV:
		return(tuner_open(bktr));
	case VBI_DEV:
		return(vbi_open(bktr));
	}

	return(ENXIO);
}


/*
 * 
 */
int
bktr_close(dev_t dev, int flags, int fmt, struct proc *p)
{
	bktr_ptr_t	bktr;
	int		unit;

	unit = UNIT(dev);

	bktr = bktr_cd.cd_devs[unit];

	switch (FUNCTION(dev)) {
	case VIDEO_DEV:
		return(video_close(bktr));
	case TUNER_DEV:
		return(tuner_close(bktr));
	case VBI_DEV:
		return(vbi_close(bktr));
	}

	return(ENXIO);
}

/*
 * 
 */
int
bktr_read(dev_t dev, struct uio *uio, int ioflag)
{
	bktr_ptr_t	bktr;
	int		unit;
	
	unit = UNIT(dev);

	bktr = bktr_cd.cd_devs[unit];

	switch (FUNCTION(dev)) {
	case VIDEO_DEV:
		return(video_read(bktr, unit, dev, uio));
	case VBI_DEV:
		return(vbi_read(bktr, uio, ioflag));
	}

        return(ENXIO);
}


/*
 * 
 */
int
bktr_write(dev_t dev, struct uio *uio, int ioflag)
{
	/* operation not supported */
	return(EOPNOTSUPP);
}

/*
 * 
 */
int
bktr_ioctl(dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr)
{
	bktr_ptr_t	bktr;
	int		unit;

	unit = UNIT(dev);

	bktr = bktr_cd.cd_devs[unit];

	if (bktr->bigbuf == 0)	/* no frame buffer allocated (ioctl failed) */
		return(ENOMEM);

	switch (FUNCTION(dev)) {
	case VIDEO_DEV:
		return(video_ioctl(bktr, unit, cmd, arg, pr));
	case TUNER_DEV:
		return(tuner_ioctl(bktr, unit, cmd, arg, pr));
	}

	return(ENXIO);
}

/*
 * 
 */
paddr_t
bktr_mmap(dev_t dev, off_t offset, int nprot)
{
	int		unit;
	bktr_ptr_t	bktr;

	unit = UNIT(dev);

	if (FUNCTION(dev) > 0)	/* only allow mmap on /dev/bktr[n] */
		return(-1);

	bktr = bktr_cd.cd_devs[unit];

	if (offset < 0)
		return(-1);

	if (offset >= bktr->alloc_pages * PAGE_SIZE)
		return(-1);

	return (bus_dmamem_mmap(bktr->dmat, bktr->dm_mem->dm_segs, 1,
				offset, nprot, BUS_DMA_WAITOK));
}

#if NRADIO > 0
int
bktr_set_info(void *v, struct radio_info *ri)
{
	struct bktr_softc *sc = v;
	struct TVTUNER *tv = &sc->tuner;
	u_int32_t freq;
	u_int32_t chan;

	if (ri->mute) {
		/* mute the audio stream by switching the mux */
		set_audio(sc, AUDIO_MUTE);
	} else {
		/* unmute the audio stream */
		set_audio(sc, AUDIO_UNMUTE);
		init_audio_devices(sc);
	}

	set_audio(sc, AUDIO_INTERN);	/* use internal audio */
	temp_mute(sc, TRUE);

	if (ri->tuner_mode == RADIO_TUNER_MODE_TV) {
		if (ri->chan) {
			if (ri->chan < MIN_TV_CHAN)
				ri->chan = MIN_TV_CHAN;
			if (ri->chan > MAX_TV_CHAN)
				ri->chan = MAX_TV_CHAN;

			chan = ri->chan;
			ri->chan = tv_channel(sc, chan);
			tv->tuner_mode = BT848_TUNER_MODE_TV;
		} else {
			ri->chan = tv->channel;
		}
	} else {
		if (ri->freq) {
			if (ri->freq < MIN_FM_FREQ)
				ri->freq = MIN_FM_FREQ;
			if (ri->freq > MAX_FM_FREQ)
				ri->freq = MAX_FM_FREQ;

			freq = ri->freq / 10;
			ri->freq = tv_freq(sc, freq, FM_RADIO_FREQUENCY) * 10;
			tv->tuner_mode = BT848_TUNER_MODE_RADIO;
		} else {
			ri->freq = tv->frequency;
		}
	}

	if (ri->chnlset >= CHNLSET_MIN && ri->chnlset <= CHNLSET_MAX)
		tv->chnlset = ri->chnlset;
	else
		tv->chnlset = DEFAULT_CHNLSET;
	
	temp_mute(sc, FALSE);

	return (0);
}

int
bktr_get_info(void *v, struct radio_info *ri)
{
	struct bktr_softc *sc = v;
	struct TVTUNER *tv = &sc->tuner;
	int status;

	status = get_tuner_status(sc);

#define	STATUSBIT_STEREO	0x10
	ri->mute = (int)sc->audio_mute_state ? 1 : 0;
	ri->caps = RADIO_CAPS_DETECT_STEREO | RADIO_CAPS_HW_AFC;
	ri->info = (status & STATUSBIT_STEREO) ? RADIO_INFO_STEREO : 0;

	/* not yet supported */
	ri->volume = ri->rfreq = ri->lock = 0;

	switch (tv->tuner_mode) {
	case BT848_TUNER_MODE_TV:
		ri->tuner_mode = RADIO_TUNER_MODE_TV;
		ri->freq = tv->frequency * 1000 / 16;
		break;
	case BT848_TUNER_MODE_RADIO:
		ri->tuner_mode = RADIO_TUNER_MODE_RADIO;
		ri->freq = tv->frequency * 10;
		break;
	}

	/*
	 * The field ri->stereo is used to forcible switch to
	 * mono/stereo, not as an indicator of received signal quality.
	 * The ri->info is for that purpose.
	 */
	ri->stereo = 1; /* Can't switch to mono, always stereo */
	
	ri->chan = tv->channel;
	ri->chnlset = tv->chnlset;

	return (0);
}
#endif /* NRADIO */
@


1.31
log
@Remove vaddr_t casts in bktr_mmap().

Pointed out by LLVM.

bktr_os.c:478:22: error: comparison of unsigned expression < 0 is always false

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.30 2009/03/29 21:53:53 sthen Exp $	*/
a87 1
#include <dev/pci/bktr/bktr_card.h>
@


1.30
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.29 2008/05/25 00:36:10 brad Exp $	*/
d478 1
a478 1
	if ((vaddr_t)offset < 0)
d481 1
a481 1
	if ((vaddr_t)offset >= bktr->alloc_pages * PAGE_SIZE)
d485 1
a485 1
				(vaddr_t)offset, nprot, BUS_DMA_WAITOK));
@


1.29
log
@Remove redundant enabling of memory space and bus master which
pci_mapreg_map() deals with.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.28 2007/11/26 09:28:34 martynas Exp $	*/
d192 1
a192 1
		printf("%s: couldn't map memory\n", bktr_name(bktr));
d206 1
a206 1
		printf("%s: couldn't map interrupt\n",
d214 1
a214 1
		printf("%s: couldn't establish interrupt",
@


1.28
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.27 2007/06/18 07:31:14 jakemsr Exp $	*/
d175 1
a175 1
	/* Enabled Bus Master
d181 1
a181 2
	    fun | PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE |
	    PCI_COMMAND_BACKTOBACK_ENABLE);
@


1.27
log
@remove newline in dmesg that slipped in in last commit

go ahead robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.26 2007/06/11 08:10:22 robert Exp $	*/
d362 1
a362 1
	if (!(bktr->flags & METEOR_INITALIZED)) /* device not found */
@


1.26
log
@remove all FreeBSD/NetBSD specific code because we will
never use them and the code is much more readable now

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.25 2007/02/11 20:29:22 miod Exp $	*/
a182 2

	printf("\n");
@


1.25
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.24 2006/02/05 23:52:58 jakemsr Exp $	*/
a50 5

#ifdef __FreeBSD__
#include "bktr.h"
#endif /* __FreeBSD__ */

a53 77

/*******************/
/* *** FreeBSD *** */
/*******************/
#ifdef __FreeBSD__

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/selinfo.h>
#include <sys/vnode.h>

#include <vm/vm.h>
#include <vm/pmap.h>
#include <vm/vm_extern.h>

#if (__FreeBSD_version >=400000) || (NSMBUS > 0)
#include <sys/bus.h>		/* used by smbus and newbus */
#endif

#if (__FreeBSD_version >=300000)
#include <machine/bus_memio.h>	/* used by bus space */
#include <machine/bus.h>	/* used by bus space and newbus */
#include <sys/bus.h>
#endif

#if (__FreeBSD_version >=400000)
#include <sys/rman.h>		/* used by newbus */
#include <machine/resource.h>	/* used by newbus */
#endif

#if (__FreeBSD_version < 500000)
#include <machine/clock.h>              /* for DELAY */
#endif

#include <pci/pcivar.h>
#include <pci/pcireg.h>

#include <sys/sysctl.h>
int bt848_card = -1; 
int bt848_tuner = -1;
int bt848_reverse_mute = -1; 
int bt848_format = -1;
int bt848_slow_msp_audio = -1;

SYSCTL_NODE(_hw, OID_AUTO, bt848, CTLFLAG_RW, 0, "Bt848 Driver mgmt");
SYSCTL_INT(_hw_bt848, OID_AUTO, card, CTLFLAG_RW, &bt848_card, -1, "");
SYSCTL_INT(_hw_bt848, OID_AUTO, tuner, CTLFLAG_RW, &bt848_tuner, -1, "");
SYSCTL_INT(_hw_bt848, OID_AUTO, reverse_mute, CTLFLAG_RW, &bt848_reverse_mute, -1, "");
SYSCTL_INT(_hw_bt848, OID_AUTO, format, CTLFLAG_RW, &bt848_format, -1, "");
SYSCTL_INT(_hw_bt848, OID_AUTO, slow_msp_audio, CTLFLAG_RW, &bt848_slow_msp_audio, -1, "");

#if (__FreeBSD__ == 2)
#define PCIR_REVID     PCI_CLASS_REG
#endif

#endif /* end freebsd section */



/****************/
/* *** BSDI *** */
/****************/
#ifdef __bsdi__
#endif /* __bsdi__ */


/**************************/
/* *** OpenBSD/NetBSD *** */
/**************************/
#if defined(__NetBSD__) || defined(__OpenBSD__)

a83 1
#endif /* __NetBSD__ || __OpenBSD__ */
d85 1
a85 3

#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <dev/ic/bt8xx.h>	/* NetBSD location for .h files */
a91 648
#else					/* Traditional location for .h files */
#include <machine/ioctl_meteor.h>
#include <machine/ioctl_bt848.h>	/* extensions to ioctl_meteor.h */
#include <dev/bktr/bktr_reg.h>
#include <dev/bktr/bktr_tuner.h>
#include <dev/bktr/bktr_card.h>
#include <dev/bktr/bktr_audio.h>
#include <dev/bktr/bktr_core.h>
#include <dev/bktr/bktr_os.h>
#if defined(BKTR_USE_FREEBSD_SMBUS)
#include <dev/bktr/bktr_i2c.h>
#endif
#endif



/****************************/
/* *** FreeBSD 4.x code *** */
/****************************/
#if (__FreeBSD_version >= 400000)

static int	bktr_probe( device_t dev );
static int	bktr_attach( device_t dev );
static int	bktr_detach( device_t dev );
static int	bktr_shutdown( device_t dev );
static void	bktr_intr(void *arg) { common_bktr_intr(arg); }

static device_method_t bktr_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,         bktr_probe),
	DEVMETHOD(device_attach,        bktr_attach),
	DEVMETHOD(device_detach,        bktr_detach),
	DEVMETHOD(device_shutdown,      bktr_shutdown),

	{ 0, 0 }
};

static driver_t bktr_driver = {
	"bktr",
	bktr_methods,
	sizeof(struct bktr_softc),
};

static devclass_t bktr_devclass;

static	d_open_t	bktr_open;
static	d_close_t	bktr_close;
static	d_read_t	bktr_read;
static	d_write_t	bktr_write;
static	d_ioctl_t	bktr_ioctl;
static	d_mmap_t	bktr_mmap;
static	d_poll_t	bktr_poll;

#define CDEV_MAJOR 92 
static struct cdevsw bktr_cdevsw = {
	/* open */	bktr_open,
	/* close */	bktr_close,
	/* read */	bktr_read,
	/* write */	bktr_write,
	/* ioctl */	bktr_ioctl,
	/* poll */	bktr_poll,
	/* mmap */	bktr_mmap,
	/* strategy */	nostrategy,
	/* name */	"bktr",
	/* maj */	CDEV_MAJOR,
	/* dump */	nodump,
	/* psize */	nopsize,
	/* flags */	0,
	/* bmaj */	-1
};

DRIVER_MODULE(bktr, pci, bktr_driver, bktr_devclass, 0, 0);
#if (__FreeBSD_version > 410000)
MODULE_DEPEND(bktr, bktr_mem, 1,1,1);
MODULE_VERSION(bktr, 1);
#endif


/*
 * the boot time probe routine.
 */
static int
bktr_probe( device_t dev )
{
	unsigned int type = pci_get_devid(dev);
        unsigned int rev  = pci_get_revid(dev);

	if (PCI_VENDOR(type) == PCI_VENDOR_BROOKTREE)
	{
		switch (PCI_PRODUCT(type)) {
		case PCI_PRODUCT_BROOKTREE_BT848:
			if (rev == 0x12)
				device_set_desc(dev, "BrookTree 848A");
			else
				device_set_desc(dev, "BrookTree 848");
			return 0;
		case PCI_PRODUCT_BROOKTREE_BT849:
			device_set_desc(dev, "BrookTree 849A");
			return 0;
		case PCI_PRODUCT_BROOKTREE_BT878:
			device_set_desc(dev, "BrookTree 878");
			return 0;
		case PCI_PRODUCT_BROOKTREE_BT879:
			device_set_desc(dev, "BrookTree 879");
			return 0;
		}
	}

        return ENXIO;
}


/*
 * the attach routine.
 */
static int
bktr_attach( device_t dev )
{
	u_int		latency;
	u_int		fun;
	u_int		val;
	unsigned int	rev;
	unsigned int	unit;
	int		error = 0;
#ifdef BROOKTREE_IRQ
	u_int		old_irq, new_irq;
#endif 

        struct bktr_softc *bktr = device_get_softc(dev);

	unit = device_get_unit(dev);

	/* build the device name for bktr_name() */
	snprintf(bktr->bktr_xname, sizeof(bktr->bktr_xname), "bktr%d",unit);

	/*
	 * Enable bus mastering and Memory Mapped device
	 */
	val = pci_read_config(dev, PCIR_COMMAND, 4);
	val |= (PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);
	pci_write_config(dev, PCIR_COMMAND, val, 4);

	/*
	 * Map control/status registers.
	 */
	bktr->mem_rid = PCIR_MAPS;
	bktr->res_mem = bus_alloc_resource(dev, SYS_RES_MEMORY, &bktr->mem_rid,
					0, ~0, 1, RF_ACTIVE);


	if (!bktr->res_mem) {
		device_printf(dev, "could not map memory\n");
		error = ENXIO;
		goto fail;
	}
	bktr->memt = rman_get_bustag(bktr->res_mem);
	bktr->memh = rman_get_bushandle(bktr->res_mem);


	/*
	 * Disable the brooktree device
	 */
	OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);
	OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);


#ifdef BROOKTREE_IRQ		/* from the configuration file */
	old_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);
	pci_conf_write(tag, PCI_INTERRUPT_REG, BROOKTREE_IRQ);
	new_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);
	printf("bktr%d: attach: irq changed from %d to %d\n",
		unit, (old_irq & 0xff), (new_irq & 0xff));
#endif 

	/*
	 * Allocate our interrupt.
	 */
	bktr->irq_rid = 0;
	bktr->res_irq = bus_alloc_resource(dev, SYS_RES_IRQ, &bktr->irq_rid,
				0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);
	if (bktr->res_irq == NULL) {
		device_printf(dev, "could not map interrupt\n");
		error = ENXIO;
		goto fail;
	}

	error = bus_setup_intr(dev, bktr->res_irq, INTR_TYPE_TTY,
                               bktr_intr, bktr, &bktr->res_ih);
	if (error) {
		device_printf(dev, "could not setup irq\n");
		goto fail;

	}


	/* Update the Device Control Register */
	/* on Bt878 and Bt879 cards           */
	fun = pci_read_config( dev, 0x40, 2);
        fun = fun | 1;	/* Enable writes to the sub-system vendor ID */

#if defined( BKTR_430_FX_MODE )
	if (bootverbose) printf("Using 430 FX chipset compatibility mode\n");
        fun = fun | 2;	/* Enable Intel 430 FX compatibility mode */
#endif

#if defined( BKTR_SIS_VIA_MODE )
	if (bootverbose) printf("Using SiS/VIA chipset compatibility mode\n");
        fun = fun | 4;	/* Enable SiS/VIA compatibility mode (usefull for
                           OPTi chipset motherboards too */
#endif
	pci_write_config(dev, 0x40, fun, 2);


	/* XXX call bt848_i2c dependent attach() routine */
#if defined(BKTR_USE_FREEBSD_SMBUS)
	if (bt848_i2c_attach(unit, bktr, &bktr->i2c_sc))
		printf("bktr%d: i2c_attach: can't attach\n", unit);
#endif


/*
 * PCI latency timer.  32 is a good value for 4 bus mastering slots, if
 * you have more than four, then 16 would probably be a better value.
 */
#ifndef BROOKTREE_DEF_LATENCY_VALUE
#define BROOKTREE_DEF_LATENCY_VALUE	10
#endif
	latency = pci_read_config(dev, PCI_LATENCY_TIMER, 4);
	latency = (latency >> 8) & 0xff;
	if ( bootverbose ) {
		if (latency)
			printf("brooktree%d: PCI bus latency is", unit);
		else
			printf("brooktree%d: PCI bus latency was 0 changing to",
				unit);
	}
	if ( !latency ) {
		latency = BROOKTREE_DEF_LATENCY_VALUE;
		pci_write_config(dev, PCI_LATENCY_TIMER, latency<<8, 4);
	}
	if ( bootverbose ) {
		printf(" %d.\n", (int) latency);
	}

	/* read the pci device id and revision id */
	fun = pci_get_devid(dev);
        rev = pci_get_revid(dev);

	/* call the common attach code */
	common_bktr_attach( bktr, unit, fun, rev );

	/* make the device entries */
	bktr->bktrdev = make_dev(&bktr_cdevsw, unit,    
				0, 0, 0444, "bktr%d",  unit);
	bktr->tunerdev= make_dev(&bktr_cdevsw, unit+16,
				0, 0, 0444, "tuner%d", unit);
	bktr->vbidev  = make_dev(&bktr_cdevsw, unit+32,
				0, 0, 0444, "vbi%d"  , unit);


	/* if this is unit 0 (/dev/bktr0, /dev/tuner0, /dev/vbi0) then make */
	/* alias entries to /dev/bktr /dev/tuner and /dev/vbi */
#if (__FreeBSD_version >=500000)
	if (unit == 0) {
		bktr->bktrdev_alias = make_dev_alias(bktr->bktrdev,  "bktr");
		bktr->tunerdev_alias= make_dev_alias(bktr->tunerdev, "tuner");
		bktr->vbidev_alias  = make_dev_alias(bktr->vbidev,   "vbi");
	}
#endif

	return 0;

fail:
	if (bktr->res_irq)
		bus_release_resource(dev, SYS_RES_IRQ, bktr->irq_rid, bktr->res_irq);
	if (bktr->res_mem)
		bus_release_resource(dev, SYS_RES_IRQ, bktr->mem_rid, bktr->res_mem);
	return error;

}

/*
 * the detach routine.
 */
static int
bktr_detach( device_t dev )
{
	unsigned int	unit;

	struct bktr_softc *bktr = device_get_softc(dev);

	unit = device_get_unit(dev);

	/* Disable the brooktree device */
	OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);
	OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);

	/* Note: We do not free memory for RISC programs, grab buffer, vbi buffers */
	/* The memory is retained by the bktr_mem module so we can unload and */
	/* then reload the main bktr driver module */

	/* Unregister the /dev/bktrN, tunerN and vbiN devices */
	destroy_dev(bktr->vbidev);
	destroy_dev(bktr->tunerdev);
	destroy_dev(bktr->bktrdev);

	/* If this is unit 0, then destroy the alias entries too */
#if (__FreeBSD_version >=500000)
	if (unit == 0) {
	    destroy_dev(bktr->vbidev_alias);
	    destroy_dev(bktr->tunerdev_alias);
	    destroy_dev(bktr->bktrdev_alias);
	}
#endif

	/*
	 * Deallocate resources.
	 */
	bus_teardown_intr(dev, bktr->res_irq, bktr->res_ih);
	bus_release_resource(dev, SYS_RES_IRQ, bktr->irq_rid, bktr->res_irq);
	bus_release_resource(dev, SYS_RES_MEMORY, bktr->mem_rid, bktr->res_mem);
	 
	return 0;
}

/*
 * the shutdown routine.
 */
static int
bktr_shutdown( device_t dev )
{
	struct bktr_softc *bktr = device_get_softc(dev);

	/* Disable the brooktree device */
	OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);
	OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);

	return 0;
}


/*
 * Special Memory Allocation
 */
vm_offset_t
get_bktr_mem( int unit, unsigned size )
{
	vm_offset_t	addr = 0;

	addr = vm_page_alloc_contig(size, 0, 0xffffffff, 1<<24);
	if (addr == 0)
		addr = vm_page_alloc_contig(size, 0, 0xffffffff, PAGE_SIZE);
	if (addr == 0) {
		printf("bktr%d: Unable to allocate %d bytes of memory.\n",
			unit, size);
	}

	return( addr );
}


/*---------------------------------------------------------
**
**	BrookTree 848 character device driver routines
**
**---------------------------------------------------------
*/

#define VIDEO_DEV	0x00
#define TUNER_DEV	0x01
#define VBI_DEV		0x02

#define UNIT(x)		((x) & 0x0f)
#define FUNCTION(x)	(x >> 4)

/*
 * 
 */
static int
bktr_open( dev_t dev, int flags, int fmt, struct proc *p )
{
	bktr_ptr_t	bktr;
	int		unit;
	int		result;

	unit = UNIT( minor(dev) );

	/* Get the device data */
	bktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);
	if (bktr == NULL) {
		/* the device is no longer valid/functioning */
		return (ENXIO);
	}

	if (!(bktr->flags & METEOR_INITALIZED)) /* device not found */
		return( ENXIO );	

	/* Record that the device is now busy */
	device_busy(devclass_get_device(bktr_devclass, unit)); 


	if (bt848_card != -1) {
	  if ((bt848_card >> 8   == unit ) &&
	     ( (bt848_card & 0xff) < Bt848_MAX_CARD )) {
	    if ( bktr->bt848_card != (bt848_card & 0xff) ) {
	      bktr->bt848_card = (bt848_card & 0xff);
	      probeCard(bktr, FALSE, unit);
	    }
	  }
	}

	if (bt848_tuner != -1) {
	  if ((bt848_tuner >> 8   == unit ) &&
	     ( (bt848_tuner & 0xff) < Bt848_MAX_TUNER )) {
	    if ( bktr->bt848_tuner != (bt848_tuner & 0xff) ) {
	      bktr->bt848_tuner = (bt848_tuner & 0xff);
	      probeCard(bktr, FALSE, unit);
	    }
	  }
	}

	if (bt848_reverse_mute != -1) {
	  if ((bt848_reverse_mute >> 8)   == unit ) {
	    bktr->reverse_mute = bt848_reverse_mute & 0xff;
	  }
	}

	if (bt848_slow_msp_audio != -1) {
	  if ((bt848_slow_msp_audio >> 8) == unit ) {
	      bktr->slow_msp_audio = (bt848_slow_msp_audio & 0xff);
	  }
	}

	switch ( FUNCTION( minor(dev) ) ) {
	case VIDEO_DEV:
		result = video_open( bktr );
		break;
	case TUNER_DEV:
		result = tuner_open( bktr );
		break;
	case VBI_DEV:
		result = vbi_open( bktr );
		break;
	default:
		result = ENXIO;
		break;
	}

	/* If there was an error opening the device, undo the busy status */
	if (result != 0)
		device_unbusy(devclass_get_device(bktr_devclass, unit)); 
	return( result );
}


/*
 * 
 */
static int
bktr_close( dev_t dev, int flags, int fmt, struct proc *p )
{
	bktr_ptr_t	bktr;
	int		unit;
	int		result;

	unit = UNIT( minor(dev) );

	/* Get the device data */
	bktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);
	if (bktr == NULL) {
		/* the device is no longer valid/functioning */
		return (ENXIO);
	}

	switch ( FUNCTION( minor(dev) ) ) {
	case VIDEO_DEV:
		result = video_close( bktr );
		break;
	case TUNER_DEV:
		result = tuner_close( bktr );
		break;
	case VBI_DEV:
		result = vbi_close( bktr );
		break;
	default:
		return (ENXIO);
		break;
	}

	device_unbusy(devclass_get_device(bktr_devclass, unit)); 
	return( result );
}


/*
 * 
 */
static int
bktr_read( dev_t dev, struct uio *uio, int ioflag )
{
	bktr_ptr_t	bktr;
	int		unit;
	
	unit = UNIT(minor(dev));

	/* Get the device data */
	bktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);
	if (bktr == NULL) {
		/* the device is no longer valid/functioning */
		return (ENXIO);
	}

	switch ( FUNCTION( minor(dev) ) ) {
	case VIDEO_DEV:
		return( video_read( bktr, unit, dev, uio ) );
	case VBI_DEV:
		return( vbi_read( bktr, uio, ioflag ) );
	}
        return( ENXIO );
}


/*
 * 
 */
static int
bktr_write( dev_t dev, struct uio *uio, int ioflag )
{
	return( EINVAL ); /* XXX or ENXIO ? */
}


/*
 * 
 */
static int
bktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )
{
	bktr_ptr_t	bktr;
	int		unit;

	unit = UNIT(minor(dev));

	/* Get the device data */
	bktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);
	if (bktr == NULL) {
		/* the device is no longer valid/functioning */
		return (ENXIO);
	}

	if (bktr->bigbuf == 0)	/* no frame buffer allocated (ioctl failed) */
		return( ENOMEM );

	switch ( FUNCTION( minor(dev) ) ) {
	case VIDEO_DEV:
		return( video_ioctl( bktr, unit, cmd, arg, pr ) );
	case TUNER_DEV:
		return( tuner_ioctl( bktr, unit, cmd, arg, pr ) );
	}

	return( ENXIO );
}


/*
 * 
 */
static int
bktr_mmap( dev_t dev, vm_offset_t offset, int nprot )
{
	int		unit;
	bktr_ptr_t	bktr;

	unit = UNIT(minor(dev));

	if (FUNCTION(minor(dev)) > 0)	/* only allow mmap on /dev/bktr[n] */
		return( -1 );

	/* Get the device data */
	bktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);
	if (bktr == NULL) {
		/* the device is no longer valid/functioning */
		return (ENXIO);
	}

	if (nprot & PROT_EXEC)
		return( -1 );

	if (offset < 0)
		return( -1 );

	if (offset >= bktr->alloc_pages * PAGE_SIZE)
		return( -1 );

	return( atop(vtophys(bktr->bigbuf) + offset) );
}

static int
bktr_poll( dev_t dev, int events, struct proc *p)
{
	int		unit;
	bktr_ptr_t	bktr;
	int revents = 0; 
	DECLARE_INTR_MASK(s);

	unit = UNIT(minor(dev));

	/* Get the device data */
	bktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);
	if (bktr == NULL) {
		/* the device is no longer valid/functioning */
		return (ENXIO);
	}

	DISABLE_INTR(s);

	if (events & (POLLIN | POLLRDNORM)) {

		switch ( FUNCTION( minor(dev) ) ) {
		case VBI_DEV:
			if(bktr->vbisize == 0)
				selrecord(p, &bktr->vbi_select);
			else
				revents |= events & (POLLIN | POLLRDNORM);
			break;
		}
	}

	ENABLE_INTR(s);

	return (revents);
}

#endif		/* FreeBSD 4.x specific kernel interface routines */


/*****************/
/* *** BSDI  *** */
/*****************/

#if defined(__bsdi__)
#endif		/* __bsdi__ BSDI specific kernel interface routines */


/*****************************/
/* *** OpenBSD / NetBSD  *** */
/*****************************/
#if defined(__NetBSD__) || defined(__OpenBSD__)
a103 1
#ifdef __OpenBSD__
a109 1
#endif
a110 1
#if defined(__OpenBSD__)
a111 6
#else
vm_offset_t vm_page_alloc_contig(vm_offset_t, vm_offset_t,
                                 vm_offset_t, vm_offset_t);

static int      bktr_probe(struct device *, struct cfdata *, void *);
#endif
a117 3
#if defined(__NetBSD__)
extern struct cfdriver bktr_cd;
#else
a120 1
#endif
a138 1
#if defined(__OpenBSD__)
a139 3
#else
        struct cfdata *match;
#endif
a183 1
#ifndef __OpenBSD__
a184 1
#endif
a213 1
#ifdef __OpenBSD__
a215 4
#else
	bktr->ih = pci_intr_establish(pa->pa_pc, ih, IPL_VIDEO,
	    bktr_intr, bktr);
#endif
a224 4
#ifdef __NetBSD__
		printf("%s: interrupting at %s\n", bktr_name(bktr),
		       intrstr);
#else
a225 1
#endif
a590 2

#endif /* __NetBSD__ || __OpenBSD__ */
@


1.24
log
@improve support for TV tuning via radio(4) by:
- adding a TV or radio mode flag to struct radio_info for radio(4)
  and a similar flag to struct TUNER for bktr(4) to make tuning
  mode explicit
- reporting the proper frequency when in TV mode
- documenting the mode flag and cleaning up some grammar

OK mickey@@, robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.23 2006/01/15 20:38:41 jakemsr Exp $	*/
a54 4

#ifndef __OpenBSD__
#include "opt_bktr.h"		/* include any kernel config options */
#endif
@


1.23
log
@as of rev 1.16 of bktr_core.c, bktr(4) enables the audio muxes at
attach, and doesn't disable them ever.

this removes the enabling/disabling of the audio muxes in the radio(4)
interface for bktr(4) as well.

OK robert@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.22 2005/12/05 15:16:26 robert Exp $	*/
d1275 16
a1290 5
	if (ri->chan) {
		if (ri->chan < MIN_TV_CHAN)
			ri->chan = MIN_TV_CHAN;
		if (ri->chan > MAX_TV_CHAN)
			ri->chan = MAX_TV_CHAN;
d1292 12
a1303 4
		if (ri->freq < MIN_FM_FREQ)
			ri->freq = MIN_FM_FREQ;
		if (ri->freq > MAX_FM_FREQ)
			ri->freq = MAX_FM_FREQ;
a1305 3
	freq = ri->freq / 10;
	chan = ri->chan;

a1310 13
	set_audio(sc, AUDIO_INTERN);	/* use internal audio */
	temp_mute(sc, TRUE);
	
	/* 
	 * We only need to set the frequency if we are using
	 * FM Radio. If the channel is > 0 then call tv_channel(),
	 * which will set the correct TV frequency.
	 */
	if (!ri->chan)
		ri->freq = tv_freq(sc, freq, FM_RADIO_FREQUENCY) * 10;
	else
		ri->chan = tv_channel(sc, chan);

a1327 1
	ri->freq = tv->frequency * 10;
d1332 11
@


1.22
log
@Add support to tune the channel and the channel sets via radio(4).

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.21 2005/12/02 15:01:32 robert Exp $	*/
a1268 4

		/* disable drivers on the GPIO port that controls the MUXes */
		OUTL(sc, BKTR_GPIO_OUT_EN, INL(sc, BKTR_GPIO_OUT_EN) &
		~sc->card.gpio_mux_bits);
a1269 4
		/* enable drivers on the GPIO port that controls the MUXes */
		OUTL(sc, BKTR_GPIO_OUT_EN, INL(sc, BKTR_GPIO_OUT_EN) |
		sc->card.gpio_mux_bits);

@


1.21
log
@Check if the given FM frequency is between 87.5Mhz and 108Mhz.
If the given value is too small default to 87.5Mhz, if it is
too high default to 108Mhz.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.20 2005/11/21 18:16:41 millert Exp $	*/
d1262 1
d1264 1
d1283 11
a1293 4
	if (ri->freq < MIN_FM_FREQ)
		ri->freq = MIN_FM_FREQ;
	if (ri->freq > MAX_FM_FREQ)
		ri->freq = MAX_FM_FREQ;
d1296 7
d1305 11
a1315 1
	ri->freq = tv_freq(sc, freq, FM_RADIO_FREQUENCY) * 10;
d1345 3
@


1.20
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.19 2004/06/29 12:24:57 mickey Exp $	*/
d1280 5
@


1.19
log
@do not use u_long for 32bit data; found by Jacob Meuser
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.18 2004/05/24 21:56:41 mickey Exp $	*/
d77 1
a77 1
#include <sys/select.h>
d150 1
a150 1
#include <sys/select.h>
@


1.18
log
@missing statics for freebsd; from freebsd via jakemsr@@jakemsr.com
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.17 2004/05/24 21:45:36 mickey Exp $	*/
d299 3
a301 3
	u_long		latency;
	u_long		fun;
	u_long		val;
d306 1
a306 1
	u_long		old_irq, new_irq;
d916 2
a917 2
	u_long		latency;
	u_long		fun;
@


1.17
log
@remove freebsd 2 and 3 support, from freebsd via jakemsr@@jakemsr.com
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.16 2003/07/04 14:47:28 mickey Exp $	*/
d559 1
a559 1
int
d639 1
a639 1
int
d678 1
a678 1
int
d706 1
a706 1
int
d716 1
a716 1
int
d748 1
a748 1
int
d778 2
a779 1
int bktr_poll( dev_t dev, int events, struct proc *p)
@


1.16
log
@no need for an BKTR_DEBUG always
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.15 2003/01/15 06:30:35 art Exp $	*/
a813 463

/**********************************/
/* *** FreeBSD 2.2.x and 3.x  *** */
/**********************************/

#if ((__FreeBSD__ == 2) || (__FreeBSD__ == 3))

static bktr_reg_t brooktree[ NBKTR ];

static const char      *bktr_probe( pcici_t tag, pcidi_t type );
static void		bktr_attach( pcici_t tag, int unit );
static void		bktr_intr(void *arg) { common_bktr_intr(arg); }

static u_long	bktr_count;

static struct	pci_device bktr_device = {
	"bktr",
	bktr_probe,
	bktr_attach,
	&bktr_count
};

DATA_SET (pcidevice_set, bktr_device);

static	d_open_t	bktr_open;
static	d_close_t	bktr_close;
static	d_read_t	bktr_read;
static	d_write_t	bktr_write;
static	d_ioctl_t	bktr_ioctl;
static	d_mmap_t	bktr_mmap;
static	d_poll_t	bktr_poll;

#define CDEV_MAJOR 92 
static struct cdevsw bktr_cdevsw = 
{
	bktr_open,	bktr_close,	bktr_read,	bktr_write,
	bktr_ioctl,	nostop,		nullreset,	nodevtotty,
	bktr_poll,	bktr_mmap,	NULL,		"bktr",
	NULL,		-1
};

static int bktr_devsw_installed;

static void
bktr_drvinit( void *unused )
{
	dev_t dev;

	if ( ! bktr_devsw_installed ) {
		dev = makedev(CDEV_MAJOR, 0);
		cdevsw_add(&dev,&bktr_cdevsw, NULL);
		bktr_devsw_installed = 1;
	}
}

SYSINIT(bktrdev,SI_SUB_DRIVERS,SI_ORDER_MIDDLE+CDEV_MAJOR,bktr_drvinit,NULL)

/*
 * the boot time probe routine.
 */
static const char *
bktr_probe( pcici_t tag, pcidi_t type )
{
        unsigned int rev = pci_conf_read( tag, PCIR_REVID) & 0x000000ff;

	if (PCI_VENDOR(type) == PCI_VENDOR_BROOKTREE)
	{
		switch (PCI_PRODUCT(type)) {
		case PCI_PRODUCT_BROOKTREE_BT848:
			if (rev == 0x12) return("BrookTree 848A");
			else             return("BrookTree 848");
		case PCI_PRODUCT_BROOKTREE_BT849:
			return("BrookTree 849A");
		case PCI_PRODUCT_BROOKTREE_BT878:
			return("BrookTree 878");
		case PCI_PRODUCT_BROOKTREE_BT879:
			return("BrookTree 879");
		}
	};

	return ((char *)0);
}

/*
 * the attach routine.
 */
static	void
bktr_attach( pcici_t tag, int unit )
{
	bktr_ptr_t	bktr;
	u_long		latency;
	u_long		fun;
	unsigned int	rev;
	unsigned long	base;
#ifdef BROOKTREE_IRQ
	u_long		old_irq, new_irq;
#endif 

	bktr = &brooktree[unit];

	if (unit >= NBKTR) {
		printf("brooktree%d: attach: only %d units configured.\n",
		        unit, NBKTR);
		printf("brooktree%d: attach: invalid unit number.\n", unit);
		return;
	}

	/* build the device name for bktr_name() */
	snprintf(bktr->bktr_xname, sizeof(bktr->bktr_xname), "bktr%d",unit);

	/* Enable Memory Mapping */
	fun = pci_conf_read(tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(tag, PCI_COMMAND_STATUS_REG, fun | 2);

	/* Enable Bus Mastering */
	fun = pci_conf_read(tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(tag, PCI_COMMAND_STATUS_REG, fun | 4);

	bktr->tag = tag;


	/*
	 * Map control/status registers
	 */
	pci_map_mem( tag, PCI_MAP_REG_START, (vm_offset_t *) &base,
		     &bktr->phys_base );
#if (__FreeBSD_version >= 300000)
	bktr->memt = I386_BUS_SPACE_MEM; /* XXX should use proper bus space */
	bktr->memh = (bus_space_handle_t)base; /* XXX functions here */
#endif

	/*
	 * Disable the brooktree device
	 */
	OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);
	OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);

#ifdef BROOKTREE_IRQ		/* from the configuration file */
	old_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);
	pci_conf_write(tag, PCI_INTERRUPT_REG, BROOKTREE_IRQ);
	new_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);
	printf("bktr%d: attach: irq changed from %d to %d\n",
		unit, (old_irq & 0xff), (new_irq & 0xff));
#endif 

	/*
	 * setup the interrupt handling routine
	 */
	pci_map_int(tag, bktr_intr, (void *) bktr, &tty_imask);


	/* Update the Device Control Register */
	/* on Bt878 and Bt879 cards */
	fun = pci_conf_read(tag, 0x40);
        fun = fun | 1;	/* Enable writes to the sub-system vendor ID */

#if defined( BKTR_430_FX_MODE )
	if (bootverbose) printf("Using 430 FX chipset compatibility mode\n");
        fun = fun | 2;	/* Enable Intel 430 FX compatibility mode */
#endif

#if defined( BKTR_SIS_VIA_MODE )
	if (bootverbose) printf("Using SiS/VIA chipset compatibility mode\n");
        fun = fun | 4;	/* Enable SiS/VIA compatibility mode (usefull for
                           OPTi chipset motherboards too */
#endif
	pci_conf_write(tag, 0x40, fun);


	/* XXX call bt848_i2c dependent attach() routine */
#if defined(BKTR_USE_FREEBSD_SMBUS)
	if (bt848_i2c_attach(unit, bktr, &bktr->i2c_sc))
		printf("bktr%d: i2c_attach: can't attach\n", unit);
#endif


/*
 * PCI latency timer.  32 is a good value for 4 bus mastering slots, if
 * you have more than four, then 16 would probably be a better value.
 */
#ifndef BROOKTREE_DEF_LATENCY_VALUE
#define BROOKTREE_DEF_LATENCY_VALUE	10
#endif
	latency = pci_conf_read(tag, PCI_LATENCY_TIMER);
	latency = (latency >> 8) & 0xff;
	if ( bootverbose ) {
		if (latency)
			printf("brooktree%d: PCI bus latency is", unit);
		else
			printf("brooktree%d: PCI bus latency was 0 changing to",
				unit);
	}
	if ( !latency ) {
		latency = BROOKTREE_DEF_LATENCY_VALUE;
		pci_conf_write(tag, PCI_LATENCY_TIMER,	latency<<8);
	}
	if ( bootverbose ) {
		printf(" %d.\n", (int) latency);
	}


	/* read the pci device id and revision id */
	fun = pci_conf_read(tag, PCI_ID_REG);
        rev = pci_conf_read(tag, PCIR_REVID) & 0x000000ff;

	/* call the common attach code */
	common_bktr_attach( bktr, unit, fun, rev );

}


/*
 * Special Memory Allocation
 */
vm_offset_t
get_bktr_mem( int unit, unsigned size )
{
	vm_offset_t	addr = 0;

	addr = vm_page_alloc_contig(size, 0x100000, 0xffffffff, 1<<24);
	if (addr == 0)
		addr = vm_page_alloc_contig(size, 0x100000, 0xffffffff,
								PAGE_SIZE);
	if (addr == 0) {
		printf("bktr%d: Unable to allocate %d bytes of memory.\n",
			unit, size);
	}

	return( addr );
}

/*---------------------------------------------------------
**
**	BrookTree 848 character device driver routines
**
**---------------------------------------------------------
*/


#define VIDEO_DEV	0x00
#define TUNER_DEV	0x01
#define VBI_DEV		0x02

#define UNIT(x)		((x) & 0x0f)
#define FUNCTION(x)	((x >> 4) & 0x0f)


/*
 * 
 */
int
bktr_open( dev_t dev, int flags, int fmt, struct proc *p )
{
	bktr_ptr_t	bktr;
	int		unit;

	unit = UNIT( minor(dev) );
	if (unit >= NBKTR)			/* unit out of range */
		return( ENXIO );

	bktr = &(brooktree[ unit ]);

	if (!(bktr->flags & METEOR_INITALIZED)) /* device not found */
		return( ENXIO );	


	if (bt848_card != -1) {
	  if ((bt848_card >> 8   == unit ) &&
	     ( (bt848_card & 0xff) < Bt848_MAX_CARD )) {
	    if ( bktr->bt848_card != (bt848_card & 0xff) ) {
	      bktr->bt848_card = (bt848_card & 0xff);
	      probeCard(bktr, FALSE, unit);
	    }
	  }
	}

	if (bt848_tuner != -1) {
	  if ((bt848_tuner >> 8   == unit ) &&
	     ( (bt848_tuner & 0xff) < Bt848_MAX_TUNER )) {
	    if ( bktr->bt848_tuner != (bt848_tuner & 0xff) ) {
	      bktr->bt848_tuner = (bt848_tuner & 0xff);
	      probeCard(bktr, FALSE, unit);
	    }
	  }
	}

	if (bt848_reverse_mute != -1) {
	  if ((bt848_reverse_mute >> 8)   == unit ) {
	    bktr->reverse_mute = bt848_reverse_mute & 0xff;
	  }
	}

	if (bt848_slow_msp_audio != -1) {
	  if ((bt848_slow_msp_audio >> 8) == unit ) {
	      bktr->slow_msp_audio = (bt848_slow_msp_audio & 0xff);
	  }
	}

	switch ( FUNCTION( minor(dev) ) ) {
	case VIDEO_DEV:
		return( video_open( bktr ) );
	case TUNER_DEV:
		return( tuner_open( bktr ) );
	case VBI_DEV:
		return( vbi_open( bktr ) );
	}
	return( ENXIO );
}


/*
 * 
 */
int
bktr_close( dev_t dev, int flags, int fmt, struct proc *p )
{
	bktr_ptr_t	bktr;
	int		unit;

	unit = UNIT( minor(dev) );
	if (unit >= NBKTR)			/* unit out of range */
		return( ENXIO );

	bktr = &(brooktree[ unit ]);

	switch ( FUNCTION( minor(dev) ) ) {
	case VIDEO_DEV:
		return( video_close( bktr ) );
	case TUNER_DEV:
		return( tuner_close( bktr ) );
	case VBI_DEV:
		return( vbi_close( bktr ) );
	}

	return( ENXIO );
}

/*
 * 
 */
int
bktr_read( dev_t dev, struct uio *uio, int ioflag )
{
	bktr_ptr_t	bktr;
	int		unit;
	
	unit = UNIT(minor(dev));
	if (unit >= NBKTR)	/* unit out of range */
		return( ENXIO );

	bktr = &(brooktree[unit]);

	switch ( FUNCTION( minor(dev) ) ) {
	case VIDEO_DEV:
		return( video_read( bktr, unit, dev, uio ) );
	case VBI_DEV:
		return( vbi_read( bktr, uio, ioflag ) );
	}
        return( ENXIO );
}


/*
 * 
 */
int
bktr_write( dev_t dev, struct uio *uio, int ioflag )
{
	return( EINVAL ); /* XXX or ENXIO ? */
}

/*
 * 
 */
int
bktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )
{
	bktr_ptr_t	bktr;
	int		unit;

	unit = UNIT(minor(dev));
	if (unit >= NBKTR)	/* unit out of range */
		return( ENXIO );

	bktr = &(brooktree[ unit ]);

	if (bktr->bigbuf == 0)	/* no frame buffer allocated (ioctl failed) */
		return( ENOMEM );

	switch ( FUNCTION( minor(dev) ) ) {
	case VIDEO_DEV:
		return( video_ioctl( bktr, unit, cmd, arg, pr ) );
	case TUNER_DEV:
		return( tuner_ioctl( bktr, unit, cmd, arg, pr ) );
	}

	return( ENXIO );
}

/*
 * bktr_mmap.
 * Note: 2.2.5/2.2.6/2.2.7/3.0 users must manually
 * edit the line below and change  "vm_offset_t" to "int"
 */
int bktr_mmap( dev_t dev, vm_offset_t offset, int nprot )

{
	int		unit;
	bktr_ptr_t	bktr;

	unit = UNIT(minor(dev));

	if (unit >= NBKTR || FUNCTION(minor(dev)) > 0)
		return( -1 );

	bktr = &(brooktree[ unit ]);

	if (nprot & PROT_EXEC)
		return( -1 );

	if (offset < 0)
		return( -1 );

	if (offset >= bktr->alloc_pages * PAGE_SIZE)
		return( -1 );

	return( i386_btop(vtophys(bktr->bigbuf) + offset) );
}

int bktr_poll( dev_t dev, int events, struct proc *p)
{
	int		unit;
	bktr_ptr_t	bktr;
	int revents = 0; 

	unit = UNIT(minor(dev));

	if (unit >= NBKTR)
		return( -1 );

	bktr = &(brooktree[ unit ]);

	disable_intr();

	if (events & (POLLIN | POLLRDNORM)) {

		switch ( FUNCTION( minor(dev) ) ) {
		case VBI_DEV:
			if(bktr->vbisize == 0)
				selrecord(p, &bktr->vbi_select);
			else
				revents |= events & (POLLIN | POLLRDNORM);
			break;
		}
	}

	enable_intr();

	return (revents);
}


#endif		/* FreeBSD 2.2.x and 3.x specific kernel interface routines */
@


1.15
log
@Get rid of vm_offset_t in bktr.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.14 2003/01/05 01:24:53 mickey Exp $	*/
a163 1
#define BKTR_DEBUG
@


1.14
log
@endianess-free, works on macppc now, except for the fb endianess
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.13 2002/07/13 16:25:36 mickey Exp $	*/
d1313 3
a1318 3
#if defined(__OpenBSD__)
static int      bktr_probe(struct device *, void *, void *);
#else
d1493 1
a1493 1
vm_offset_t
d1544 1
a1544 1
        return (vm_offset_t)kva;
d1551 1
a1551 1
        vm_offset_t kva;
@


1.13
log
@pci_intr_establish() is a macros on some archs and ifdef w/in the macro args does not work
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.12 2002/06/06 20:57:47 aaron Exp $	*/
d166 1
a166 1
int bktr_debug = 0;
d288 1
a288 1
	};
d1392 9
d1408 5
a1412 7
	retval = pci_mapreg_map(pa, PCI_MAPREG_START,
				PCI_MAPREG_TYPE_MEM
				| PCI_MAPREG_MEM_TYPE_32BIT, 0,
				&bktr->memt, &bktr->memh, NULL,
				&bktr->obmemsz, 0);
	DPR(("pci_mapreg_map: memt %x, memh %x, size %x\n",
	     bktr->memt, (u_int)bktr->memh, (u_int)bktr->obmemsz));
d1461 1
a1461 1
#define BROOKTREE_DEF_LATENCY_VALUE	10
a1476 7
	/* Enabled Bus Master
	   XXX: check if all old DMA is stopped first (e.g. after warm
	   boot) */
	fun = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		       fun | PCI_COMMAND_MASTER_ENABLE);

d1479 1
a1479 1
        rev = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0x000000ff;
@


1.12
log
@compatibilty -> compatibility
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.11 2002/06/06 16:29:37 mickey Exp $	*/
d1426 4
d1431 1
a1431 3
				      bktr_intr, bktr
#ifdef __OpenBSD__
				      , bktr->bktr_dev.dv_xname
a1432 1
	);
@


1.11
log
@fix stereo handling on bktr, remove dead code from fms (now that radio does attachment properly; from jumbo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.10 2002/03/14 03:16:07 millert Exp $	*/
d383 1
a383 1
	if (bootverbose) printf("Using 430 FX chipset compatibilty mode\n");
d388 1
a388 1
	if (bootverbose) printf("Using SiS/VIA chipset compatibilty mode\n");
d972 1
a972 1
	if (bootverbose) printf("Using 430 FX chipset compatibilty mode\n");
d977 1
a977 1
	if (bootverbose) printf("Using SiS/VIA chipset compatibilty mode\n");
@


1.10
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.9 2002/03/14 01:27:00 millert Exp $	*/
a1762 1
	ri->stereo = (status & STATUSBIT_STEREO) ? 1 : 0;
d1769 7
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.8 2002/01/23 18:41:07 mickey Exp $	*/
d824 1
a824 1
static const char*	bktr_probe( pcici_t tag, pcidi_t type );
d875 1
a875 1
static const char*
d963 1
a963 1
	pci_map_int(tag, bktr_intr, (void*) bktr, &tty_imask);
@


1.8
log
@allow attaching radio on bktr; from netbsd w/ fixes from Vladimir Popov <jumbo@@narod.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.7 2001/11/06 19:53:19 miod Exp $	*/
d1305 6
a1310 6
int	bktr_open __P((dev_t, int, int, struct proc *));
int	bktr_close __P((dev_t, int, int, struct proc *));
int	bktr_read __P((dev_t, struct uio *, int));
int	bktr_write __P((dev_t, struct uio *, int));
int	bktr_ioctl __P((dev_t, ioctl_cmd_t, caddr_t, int, struct proc *));
paddr_t	bktr_mmap __P((dev_t, off_t, int));
d1317 1
a1317 1
static int      bktr_probe __P((struct device *, void *, void *));
d1319 1
a1319 1
static int      bktr_probe __P((struct device *, struct cfdata *, void *));
d1321 1
a1321 1
static void     bktr_attach __P((struct device *, struct device *, void *));
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.6 2001/09/11 20:05:25 miod Exp $	*/
d140 2
d152 4
d1335 14
d1481 5
d1718 56
@


1.7.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.8 2002/01/23 18:41:07 mickey Exp $	*/
a139 2
#include "radio.h"

a149 4
#if NRADIO > 0
#include <sys/radioio.h>
#include <dev/radio_if.h>
#endif
a1328 14
#if NRADIO > 0
/* for radio(4) */
int	bktr_get_info(void *, struct radio_info *);
int	bktr_set_info(void *, struct radio_info *);

struct radio_hw_if bktr_hw_if = {
	NULL,	/* open */
	NULL,	/* close */
	bktr_get_info,
	bktr_set_info,
	NULL	/* search */
};
#endif

a1460 5

#if NRADIO > 0
	if (bktr->card.tuner->pllControl[3] != 0x00)
		radio_attach_mi(&bktr_hw_if, bktr, &bktr->bktr_dev);
#endif
a1692 56

#if NRADIO > 0
int
bktr_set_info(void *v, struct radio_info *ri)
{
	struct bktr_softc *sc = v;
	u_int32_t freq;

	if (ri->mute) {
		/* mute the audio stream by switching the mux */
		set_audio(sc, AUDIO_MUTE);

		/* disable drivers on the GPIO port that controls the MUXes */
		OUTL(sc, BKTR_GPIO_OUT_EN, INL(sc, BKTR_GPIO_OUT_EN) &
		~sc->card.gpio_mux_bits);
	} else {
		/* enable drivers on the GPIO port that controls the MUXes */
		OUTL(sc, BKTR_GPIO_OUT_EN, INL(sc, BKTR_GPIO_OUT_EN) |
		sc->card.gpio_mux_bits);

		/* unmute the audio stream */
		set_audio(sc, AUDIO_UNMUTE);
		init_audio_devices(sc);
	}

	freq = ri->freq / 10;
	set_audio(sc, AUDIO_INTERN);	/* use internal audio */
	temp_mute(sc, TRUE);
	ri->freq = tv_freq(sc, freq, FM_RADIO_FREQUENCY) * 10;
	temp_mute(sc, FALSE);

	return (0);
}

int
bktr_get_info(void *v, struct radio_info *ri)
{
	struct bktr_softc *sc = v;
	struct TVTUNER *tv = &sc->tuner;
	int status;

	status = get_tuner_status(sc);

#define	STATUSBIT_STEREO	0x10
	ri->mute = (int)sc->audio_mute_state ? 1 : 0;
	ri->stereo = (status & STATUSBIT_STEREO) ? 1 : 0;
	ri->caps = RADIO_CAPS_DETECT_STEREO | RADIO_CAPS_HW_AFC;
	ri->freq = tv->frequency * 10;
	ri->info = (status & STATUSBIT_STEREO) ? RADIO_INFO_STEREO : 0;

	/* not yet supported */
	ri->volume = ri->rfreq = ri->lock = 0;

	return (0);
}
#endif /* NRADIO */
@


1.7.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.7.2.1 2002/01/31 22:55:37 niklas Exp $	*/
d383 1
a383 1
	if (bootverbose) printf("Using 430 FX chipset compatibility mode\n");
d388 1
a388 1
	if (bootverbose) printf("Using SiS/VIA chipset compatibility mode\n");
d824 1
a824 1
static const char      *bktr_probe( pcici_t tag, pcidi_t type );
d875 1
a875 1
static const char *
d963 1
a963 1
	pci_map_int(tag, bktr_intr, (void *) bktr, &tty_imask);
d972 1
a972 1
	if (bootverbose) printf("Using 430 FX chipset compatibility mode\n");
d977 1
a977 1
	if (bootverbose) printf("Using SiS/VIA chipset compatibility mode\n");
d1305 6
a1310 6
int	bktr_open(dev_t, int, int, struct proc *);
int	bktr_close(dev_t, int, int, struct proc *);
int	bktr_read(dev_t, struct uio *, int);
int	bktr_write(dev_t, struct uio *, int);
int	bktr_ioctl(dev_t, ioctl_cmd_t, caddr_t, int, struct proc *);
paddr_t	bktr_mmap(dev_t, off_t, int);
d1317 1
a1317 1
static int      bktr_probe(struct device *, void *, void *);
d1319 1
a1319 1
static int      bktr_probe(struct device *, struct cfdata *, void *);
d1321 1
a1321 1
static void     bktr_attach(struct device *, struct device *, void *);
d1763 1
a1769 7

	/*
	 * The field ri->stereo is used to forcible switch to
	 * mono/stereo, not as an indicator of received signal quality.
	 * The ri->info is for that purpose.
	 */
	ri->stereo = 1; /* Can't switch to mono, always stereo */
@


1.7.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.7.2.2 2002/06/11 03:42:27 art Exp $	*/
d1426 2
d1429 1
a1429 5
	bktr->ih = pci_intr_establish(pa->pa_pc, ih, IPL_VIDEO,
	    bktr_intr, bktr, bktr->bktr_dev.dv_xname);
#else
	bktr->ih = pci_intr_establish(pa->pa_pc, ih, IPL_VIDEO,
	    bktr_intr, bktr);
d1431 1
@


1.7.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 1
a166 1
int bktr_debug = 1;
d288 1
a288 1
	}
d1313 3
a1318 3
vm_offset_t vm_page_alloc_contig(vm_offset_t, vm_offset_t,
                                 vm_offset_t, vm_offset_t);

a1391 9
	/* Enabled Bus Master
	   XXX: check if all old DMA is stopped first (e.g. after warm
	   boot) */
	fun = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	DPR((" fun=%b", fun, PCI_COMMAND_STATUS_BITS));
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    fun | PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE |
	    PCI_COMMAND_BACKTOBACK_ENABLE);

d1399 7
a1405 5
	retval = pci_mapreg_map(pa, PCI_MAPREG_START, PCI_MAPREG_TYPE_MEM |
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &bktr->memt, &bktr->memh, NULL,
	    &bktr->obmemsz, 0);
	DPR(("pci_mapreg_map: memt %lx, memh %lx, size %x\n",
	     bktr->memt, bktr->memh, bktr->obmemsz));
d1454 1
a1454 1
#define BROOKTREE_DEF_LATENCY_VALUE	0x10
d1470 7
d1479 1
a1479 1
        rev = PCI_REVISION(pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG));
d1493 1
a1493 1
vaddr_t
d1544 1
a1544 1
        return (vaddr_t)kva;
d1551 1
a1551 1
        vaddr_t kva;
@


1.6
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.5 2001/08/25 10:13:30 art Exp $	*/
d151 1
a151 1
#include <vm/vm.h>
@


1.5
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.4 2001/07/04 04:59:29 csapuntz Exp $	*/
a80 1
#include <vm/vm_kern.h>
@


1.4
log
@

Off-by-one error in out-of-range test in bktr_open
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.3 2001/06/12 15:40:33 niklas Exp $	*/
d1401 1
a1401 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &ih)) {
@


1.3
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.2 2001/05/16 07:15:41 fgsch Exp $	*/
d1564 1
a1564 1
	if ((unit > bktr_cd.cd_ndevs) || (bktr_cd.cd_devs[unit] == NULL))
@


1.2
log
@use dma_mapsize now that's available.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.1 2001/03/28 03:27:09 fgsch Exp $	*/
d1384 1
a1384 1
				&bktr->obmemsz);
@


1.1
log
@Latest bktr driver from FreeBSD; thanks to Andres Gunnarsson
<andreas@@crt.se> for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1501 3
#ifdef __OpenBSD__
        bktr->dm_mapsize = size;
#endif
a1530 1
#ifdef __NetBSD__ 
a1531 3
#else
        bus_dmamem_unmap(dmat, (caddr_t)kva, bktr->dm_mapsize);
#endif
@


1.1.2.1
log
@Pull in patch from 3.0 (from cszapuntz@@):
Off-by-one error in out-of-range test in bktr_open
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.1 2001/03/28 03:27:09 fgsch Exp $	*/
d1571 1
a1571 1
	if ((unit >= bktr_cd.cd_ndevs) || (bktr_cd.cd_devs[unit] == NULL))
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.1 2001/03/28 03:27:09 fgsch Exp $	*/
@


1.1.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.1.4.1 2001/05/14 22:26:03 niklas Exp $	*/
d1384 1
a1384 1
				&bktr->obmemsz, 0);
d1502 3
d1534 1
d1536 3
@


1.1.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_os.c,v 1.1.4.2 2001/07/04 10:43:17 niklas Exp $	*/
d81 1
d1401 2
a1402 1
	if (pci_intr_map(pa, &ih)) {
d1564 1
a1564 1
	if ((unit >= bktr_cd.cd_ndevs) || (bktr_cd.cd_devs[unit] == NULL))
@


1.1.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d151 1
a151 1
#include <uvm/uvm_extern.h>
@


1.1.4.5
log
@Merge in trunk
@
text
@a139 2
#include "radio.h"

a149 4
#if NRADIO > 0
#include <sys/radioio.h>
#include <dev/radio_if.h>
#endif
a1328 14
#if NRADIO > 0
/* for radio(4) */
int	bktr_get_info(void *, struct radio_info *);
int	bktr_set_info(void *, struct radio_info *);

struct radio_hw_if bktr_hw_if = {
	NULL,	/* open */
	NULL,	/* close */
	bktr_get_info,
	bktr_set_info,
	NULL	/* search */
};
#endif

a1460 5

#if NRADIO > 0
	if (bktr->card.tuner->pllControl[3] != 0x00)
		radio_attach_mi(&bktr_hw_if, bktr, &bktr->bktr_dev);
#endif
a1692 56

#if NRADIO > 0
int
bktr_set_info(void *v, struct radio_info *ri)
{
	struct bktr_softc *sc = v;
	u_int32_t freq;

	if (ri->mute) {
		/* mute the audio stream by switching the mux */
		set_audio(sc, AUDIO_MUTE);

		/* disable drivers on the GPIO port that controls the MUXes */
		OUTL(sc, BKTR_GPIO_OUT_EN, INL(sc, BKTR_GPIO_OUT_EN) &
		~sc->card.gpio_mux_bits);
	} else {
		/* enable drivers on the GPIO port that controls the MUXes */
		OUTL(sc, BKTR_GPIO_OUT_EN, INL(sc, BKTR_GPIO_OUT_EN) |
		sc->card.gpio_mux_bits);

		/* unmute the audio stream */
		set_audio(sc, AUDIO_UNMUTE);
		init_audio_devices(sc);
	}

	freq = ri->freq / 10;
	set_audio(sc, AUDIO_INTERN);	/* use internal audio */
	temp_mute(sc, TRUE);
	ri->freq = tv_freq(sc, freq, FM_RADIO_FREQUENCY) * 10;
	temp_mute(sc, FALSE);

	return (0);
}

int
bktr_get_info(void *v, struct radio_info *ri)
{
	struct bktr_softc *sc = v;
	struct TVTUNER *tv = &sc->tuner;
	int status;

	status = get_tuner_status(sc);

#define	STATUSBIT_STEREO	0x10
	ri->mute = (int)sc->audio_mute_state ? 1 : 0;
	ri->stereo = (status & STATUSBIT_STEREO) ? 1 : 0;
	ri->caps = RADIO_CAPS_DETECT_STEREO | RADIO_CAPS_HW_AFC;
	ri->freq = tv->frequency * 10;
	ri->info = (status & STATUSBIT_STEREO) ? RADIO_INFO_STEREO : 0;

	/* not yet supported */
	ri->volume = ri->rfreq = ri->lock = 0;

	return (0);
}
#endif /* NRADIO */
@


1.1.4.6
log
@merge stuff cvs missed
@
text
@d824 1
a824 1
static const char      *bktr_probe( pcici_t tag, pcidi_t type );
d875 1
a875 1
static const char *
d963 1
a963 1
	pci_map_int(tag, bktr_intr, (void *) bktr, &tty_imask);
d1305 6
a1310 6
int	bktr_open(dev_t, int, int, struct proc *);
int	bktr_close(dev_t, int, int, struct proc *);
int	bktr_read(dev_t, struct uio *, int);
int	bktr_write(dev_t, struct uio *, int);
int	bktr_ioctl(dev_t, ioctl_cmd_t, caddr_t, int, struct proc *);
paddr_t	bktr_mmap(dev_t, off_t, int);
d1317 1
a1317 1
static int      bktr_probe(struct device *, void *, void *);
d1319 1
a1319 1
static int      bktr_probe(struct device *, struct cfdata *, void *);
d1321 1
a1321 1
static void     bktr_attach(struct device *, struct device *, void *);
@


1.1.4.7
log
@Sync the SMP branch with 3.3
@
text
@d166 1
a166 1
int bktr_debug = 1;
d288 1
a288 1
	}
d383 1
a383 1
	if (bootverbose) printf("Using 430 FX chipset compatibility mode\n");
d388 1
a388 1
	if (bootverbose) printf("Using SiS/VIA chipset compatibility mode\n");
d972 1
a972 1
	if (bootverbose) printf("Using 430 FX chipset compatibility mode\n");
d977 1
a977 1
	if (bootverbose) printf("Using SiS/VIA chipset compatibility mode\n");
d1313 3
a1318 3
vm_offset_t vm_page_alloc_contig(vm_offset_t, vm_offset_t,
                                 vm_offset_t, vm_offset_t);

a1391 9
	/* Enabled Bus Master
	   XXX: check if all old DMA is stopped first (e.g. after warm
	   boot) */
	fun = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	DPR((" fun=%b", fun, PCI_COMMAND_STATUS_BITS));
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    fun | PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE |
	    PCI_COMMAND_BACKTOBACK_ENABLE);

d1399 7
a1405 5
	retval = pci_mapreg_map(pa, PCI_MAPREG_START, PCI_MAPREG_TYPE_MEM |
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &bktr->memt, &bktr->memh, NULL,
	    &bktr->obmemsz, 0);
	DPR(("pci_mapreg_map: memt %lx, memh %lx, size %x\n",
	     bktr->memt, bktr->memh, bktr->obmemsz));
d1426 2
d1429 1
a1429 5
	bktr->ih = pci_intr_establish(pa->pa_pc, ih, IPL_VIDEO,
	    bktr_intr, bktr, bktr->bktr_dev.dv_xname);
#else
	bktr->ih = pci_intr_establish(pa->pa_pc, ih, IPL_VIDEO,
	    bktr_intr, bktr);
d1431 1
d1453 1
a1453 1
#define BROOKTREE_DEF_LATENCY_VALUE	0x10
d1469 7
d1478 1
a1478 1
        rev = PCI_REVISION(pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG));
d1492 1
a1492 1
vaddr_t
d1543 1
a1543 1
        return (vaddr_t)kva;
d1550 1
a1550 1
        vaddr_t kva;
d1763 1
a1769 7

	/*
	 * The field ri->stereo is used to forcible switch to
	 * mono/stereo, not as an indicator of received signal quality.
	 * The ri->info is for that purpose.
	 */
	ri->stereo = 1; /* Can't switch to mono, always stereo */
@


1.1.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d164 1
@


1.1.4.9
log
@Merge with the trunk
@
text
@d559 1
a559 1
static int
d639 1
a639 1
static int
d678 1
a678 1
static int
d706 1
a706 1
static int
d716 1
a716 1
static int
d748 1
a748 1
static int
d778 1
a778 2
static int
bktr_poll( dev_t dev, int events, struct proc *p)
d814 463
@


