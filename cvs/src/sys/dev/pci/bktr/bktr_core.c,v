head	1.38;
access;
symbols
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.4
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.26.0.10
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.6
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.4
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.11.0.6
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.4
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.2
	UBC_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.38
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.37;
commitid	kCz5QgxnxRMKOzNf;

1.37
date	2016.02.15.19.21.46;	author stefan;	state Exp;
branches;
next	1.36;
commitid	xXL97Bqjbiiy66ZJ;

1.36
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.35;
commitid	p4LJxGKbi0BU2cG6;

1.35
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.34;
commitid	C5iGb36LQxjM60Q3;

1.34
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.33;
commitid	P6Av4XGqOi3rFasL;

1.33
date	2014.05.04.20.09.15;	author sf;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.26.20.33.18;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.04.07.27.36;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2013.07.05.02.37.30;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.06.00.00.16;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.31.06.40.17;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.26.09.28.34;	author martynas;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.15.10.10.37;	author martin;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.25.23.11.52;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.11.08.10.22;	author robert;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.24.16.01.21;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.20.18.14.17;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.15.14.33.29;	author robert;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.23.14.57.48;	author robert;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.22.12.26.32;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.19.17.43.33;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.14.12.25.31;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.29.12.24.57;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.24.21.59.28;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.12.00.28.54;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.11.19.20.28;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.21.19.55.13;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.15.06.30.35;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.05.02.05.58;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.05.01.24.53;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.30.23.18.38;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.09.22.19.44.37;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.28.03.27.09;	author fgsch;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.26.02;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.03.30.08.22.04;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.06.05.23.12.54;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.05.19.22.19.37;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@/*	$OpenBSD: bktr_core.c,v 1.37 2016/02/15 19:21:46 stefan Exp $	*/
/* $FreeBSD: src/sys/dev/bktr/bktr_core.c,v 1.114 2000/10/31 13:09:56 roger Exp $ */

/*
 * This is part of the Driver for Video Capture Cards (Frame grabbers)
 * and TV Tuner cards using the Brooktree Bt848, Bt848A, Bt849A, Bt878, Bt879
 * chipset.
 * Copyright Roger Hardiman and Amancio Hasty.
 *
 * bktr_core : This deals with the Bt848/849/878/879 PCI Frame Grabber,
 *               Handles all the open, close, ioctl and read userland calls.
 *               Sets the Bt848 registers and generates RISC pograms.
 *               Controls the i2c bus and GPIO interface.
 *               Contains the interface to the kernel.
 *               (eg probe/attach and open/close/ioctl)
 *
 */

 /*
   The Brooktree BT848 Driver driver is based upon Mark Tinguely and
   Jim Lowe's driver for the Matrox Meteor PCI card . The
   Philips SAA 7116 and SAA 7196 are very different chipsets than
   the BT848.

   The original copyright notice by Mark and Jim is included mostly
   to honor their fantastic work in the Matrox Meteor driver!

 */

/*
 * 1. Redistributions of source code must retain the
 * Copyright (c) 1997 Amancio Hasty, 1999 Roger Hardiman
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Amancio Hasty and
 *      Roger Hardiman
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */




/*
 * 1. Redistributions of source code must retain the
 * Copyright (c) 1995 Mark Tinguely and Jim Lowe
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mark Tinguely and Jim Lowe
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>

#include <uvm/uvm_extern.h>

#include <dev/rndvar.h>
#include <dev/ic/bt8xx.h>
#include <dev/pci/bktr/bktr_reg.h>
#include <dev/pci/bktr/bktr_tuner.h>
#include <dev/pci/bktr/bktr_card.h>
#include <dev/pci/bktr/bktr_audio.h>
#include <dev/pci/bktr/bktr_core.h>
#include <dev/pci/bktr/bktr_os.h>

typedef int intrmask_t;

static int bt848_format = -1;

const char *
bktr_name(bktr_ptr_t bktr)
{
        return (bktr->bktr_dev.dv_xname);
}


typedef u_char bool_t;

#define BKTRPRI (PZERO+8)|PCATCH
#define VBIPRI  (PZERO-4)|PCATCH


/*
 * memory allocated for DMA programs
 */
#define DMA_PROG_ALLOC		(8 * PAGE_SIZE)

/* When to split a dma transfer , the bt848 has timing as well as
   dma transfer size limitations so that we have to split dma
   transfers into two dma requests
   */
#define DMA_BT848_SPLIT 319*2

/*
 * Allocate enough memory for:
 *	768x576 RGB 16 or YUV (16 storage bits/pixel) = 884736 = 216 pages
 *
 * You may override this using the options "BROOKTREE_ALLOC_PAGES=value"
 * in your  kernel configuration file.
 */

#ifndef BROOKTREE_ALLOC_PAGES
#define BROOKTREE_ALLOC_PAGES	217*4
#endif
#define BROOKTREE_ALLOC		(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)

/* Definitions for VBI capture.
 * There are 16 VBI lines in a PAL video field (32 in a frame),
 * and we take 2044 samples from each line (placed in a 2048 byte buffer
 * for alignment).
 * VBI lines are held in a circular buffer before being read by a
 * user program from /dev/vbi.
 */

#define MAX_VBI_LINES	      16   /* Maximum for all vidoe formats */
#define VBI_LINE_SIZE         2048 /* Store upto 2048 bytes per line */
#define VBI_BUFFER_ITEMS      20   /* Number of frames we buffer */
#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)
#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)


/*  Defines for fields  */
#define ODD_F  0x01
#define EVEN_F 0x02


/*
 * Parameters describing size of transmitted image.
 */

static const struct format_params format_params[] = {
/* # define BT848_IFORM_F_AUTO             (0x0) - don't matter. */
  { 525, 26, 480,  910, 135, 754, 640,  780, 30, 0x68, 0x5d, BT848_IFORM_X_AUTO,
    12,  1600 },
/* # define BT848_IFORM_F_NTSCM            (0x1) */
  { 525, 26, 480,  910, 135, 754, 640,  780, 30, 0x68, 0x5d, BT848_IFORM_X_XT0,
    12, 1600 },
/* # define BT848_IFORM_F_NTSCJ            (0x2) */
  { 525, 22, 480,  910, 135, 754, 640,  780, 30, 0x68, 0x5d, BT848_IFORM_X_XT0,
    12, 1600 },
/* # define BT848_IFORM_F_PALBDGHI         (0x3) */
  { 625, 32, 576, 1135, 186, 924, 768,  944, 25, 0x7f, 0x72, BT848_IFORM_X_XT1,
    16,  2044 },
/* # define BT848_IFORM_F_PALM             (0x4) */
  { 525, 22, 480,  910, 135, 754, 640,  780, 30, 0x68, 0x5d, BT848_IFORM_X_XT0,
    12, 1600 },
/* # define BT848_IFORM_F_PALN             (0x5) */
  { 625, 32, 576, 1135, 186, 924, 768,  944, 25, 0x7f, 0x72, BT848_IFORM_X_XT1,
    16, 2044 },
/* # define BT848_IFORM_F_SECAM            (0x6) */
  { 625, 32, 576, 1135, 186, 924, 768,  944, 25, 0x7f, 0xa0, BT848_IFORM_X_XT1,
    16, 2044 },
/* # define BT848_IFORM_F_RSVD             (0x7) - ???? */
  { 625, 32, 576, 1135, 186, 924, 768,  944, 25, 0x7f, 0x72, BT848_IFORM_X_XT0,
    16, 2044 },
};

/*
 * Table of supported Pixel Formats
 */

static const struct meteor_pixfmt_internal {
	struct meteor_pixfmt public;
	u_int                color_fmt;
} pixfmt_table[] = {

{ { 0, METEOR_PIXTYPE_RGB, 2, {   0x7c00,  0x03e0,  0x001f }, 0,0 }, 0x33 },
{ { 0, METEOR_PIXTYPE_RGB, 2, {   0x7c00,  0x03e0,  0x001f }, 1,0 }, 0x33 },

{ { 0, METEOR_PIXTYPE_RGB, 2, {   0xf800,  0x07e0,  0x001f }, 0,0 }, 0x22 },
{ { 0, METEOR_PIXTYPE_RGB, 2, {   0xf800,  0x07e0,  0x001f }, 1,0 }, 0x22 },

{ { 0, METEOR_PIXTYPE_RGB, 3, { 0xff0000,0x00ff00,0x0000ff }, 1,0 }, 0x11 },

{ { 0, METEOR_PIXTYPE_RGB, 4, { 0xff0000,0x00ff00,0x0000ff }, 0,0 }, 0x00 },
{ { 0, METEOR_PIXTYPE_RGB, 4, { 0xff0000,0x00ff00,0x0000ff }, 0,1 }, 0x00 },
{ { 0, METEOR_PIXTYPE_RGB, 4, { 0xff0000,0x00ff00,0x0000ff }, 1,0 }, 0x00 },
{ { 0, METEOR_PIXTYPE_RGB, 4, { 0xff0000,0x00ff00,0x0000ff }, 1,1 }, 0x00 },
{ { 0, METEOR_PIXTYPE_YUV, 2, { 0xff0000,0x00ff00,0x0000ff }, 1,1 }, 0x88 },
{ { 0, METEOR_PIXTYPE_YUV_PACKED, 2, { 0xff0000,0x00ff00,0x0000ff }, 0,1 }, 0x44 },
{ { 0, METEOR_PIXTYPE_YUV_12, 2, { 0xff0000,0x00ff00,0x0000ff }, 1,1 }, 0x88 },

};
#define PIXFMT_TABLE_SIZE ( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )

/*
 * Table of Meteor-supported Pixel Formats (for SETGEO compatibility)
 */

/*  FIXME:  Also add YUV_422 and YUV_PACKED as well  */
static const struct {
	u_int	meteor_format;
	struct meteor_pixfmt public;
} meteor_pixfmt_table[] = {
    { METEOR_GEO_YUV_12,
      { 0, METEOR_PIXTYPE_YUV_12, 2, { 0xff0000,0x00ff00,0x0000ff }, 1,1 }
    },

      /* FIXME: Should byte swap flag be on for this one; negative in drvr? */
    { METEOR_GEO_YUV_422,
      { 0, METEOR_PIXTYPE_YUV, 2, { 0xff0000,0x00ff00,0x0000ff }, 1,1 }
    },
    { METEOR_GEO_YUV_PACKED,
      { 0, METEOR_PIXTYPE_YUV_PACKED, 2, { 0xff0000,0x00ff00,0x0000ff }, 0,1 }
    },
    { METEOR_GEO_RGB16,
      { 0, METEOR_PIXTYPE_RGB, 2, {   0x7c00,   0x03e0,   0x001f }, 0, 0 }
    },
    { METEOR_GEO_RGB24,
      { 0, METEOR_PIXTYPE_RGB, 4, { 0xff0000, 0x00ff00, 0x0000ff }, 0, 0 }
    },

};
#define METEOR_PIXFMT_TABLE_SIZE ( sizeof(meteor_pixfmt_table) / \
				   sizeof(meteor_pixfmt_table[0]) )


#define BSWAP (BT848_COLOR_CTL_BSWAP_ODD | BT848_COLOR_CTL_BSWAP_EVEN)
#define WSWAP (BT848_COLOR_CTL_WSWAP_ODD | BT848_COLOR_CTL_WSWAP_EVEN)



/* sync detect threshold */
#if 0
#define SYNC_LEVEL		(BT848_ADC_RESERVED |	\
				 BT848_ADC_CRUSH)	/* threshold ~125 mV */
#else
#define SYNC_LEVEL		(BT848_ADC_RESERVED |	\
				 BT848_ADC_SYNC_T)	/* threshold ~75 mV */
#endif




/* debug utility for holding previous INT_STAT contents */
#undef STATUS_SUM
#if defined( STATUS_SUM )
static u_int	status_sum = 0;
#endif

/*
 * defines to make certain bit-fiddles understandable
 */
#define FIFO_ENABLED		BT848_DMA_CTL_FIFO_EN
#define RISC_ENABLED		BT848_DMA_CTL_RISC_EN
#define FIFO_RISC_ENABLED	(BT848_DMA_CTL_FIFO_EN | BT848_DMA_CTL_RISC_EN)
#define FIFO_RISC_DISABLED	0

#define ALL_INTS_DISABLED	0
#define ALL_INTS_CLEARED	0xffffffff
#define CAPTURE_OFF		0

#define BIT_SEVEN_HIGH		(1<<7)
#define BIT_EIGHT_HIGH		(1<<8)

#define I2C_BITS		(BT848_INT_RACK | BT848_INT_I2CDONE)
#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)



static int		oformat_meteor_to_bt( u_int format );

static u_int		pixfmt_swap_flags( int pixfmt );

/*
 * bt848 RISC programming routines.
 */
#ifdef BT848_DUMP
static int	dump_bt848( bktr_ptr_t bktr );
#endif

static void	yuvpack_prog( bktr_ptr_t bktr, char i_flag, int cols,
			      int rows,  int interlace );
static void	yuv422_prog( bktr_ptr_t bktr, char i_flag, int cols,
			     int rows, int interlace );
static void	yuv12_prog( bktr_ptr_t bktr, char i_flag, int cols,
			     int rows, int interlace );
static void	rgb_prog( bktr_ptr_t bktr, char i_flag, int cols,
			  int rows, int interlace );
static void	rgb_vbi_prog( bktr_ptr_t bktr, char i_flag, int cols,
			  int rows, int interlace );
static void	build_dma_prog( bktr_ptr_t bktr, char i_flag );

static bool_t   getline(bktr_reg_t *, int);
static bool_t   notclipped(bktr_reg_t * , int , int);
static bool_t   split(bktr_reg_t *, u_int **, int, u_int, int, u_int * , int);

static void	start_capture( bktr_ptr_t bktr, unsigned type );
static void	set_fps( bktr_ptr_t bktr, u_short fps );



/*
 * Remote Control Functions
 */
static void	remote_read(bktr_ptr_t bktr, struct bktr_remote *remote);


/*
 * ioctls common to both video & tuner.
 */
int	bktr_common_ioctl( bktr_ptr_t bktr, ioctl_cmd_t cmd, caddr_t arg );


/*
 * i2c primitives for low level control of i2c bus. Added for MSP34xx control
 */
static void     i2c_start( bktr_ptr_t bktr);
static void     i2c_stop( bktr_ptr_t bktr);
static int      i2c_write_byte( bktr_ptr_t bktr, unsigned char data);
static int      i2c_read_byte( bktr_ptr_t bktr, unsigned char *data, int last );

/*
 * the common attach code, used by all OS versions.
 */
void
common_bktr_attach( bktr_ptr_t bktr, int unit, u_int pci_id, u_int rev )
{
	vaddr_t	buf = 0;

/***************************************/
/* *** OS Specific memory routines *** */
/***************************************/
        /* allocate space for dma program */
        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);
        bktr->odd_dma_prog = get_bktr_mem(bktr, &bktr->dm_oprog,
	    DMA_PROG_ALLOC);

	/* allocate space for the VBI buffer */
	bktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);
	bktr->vbibuffer = get_bktr_mem(bktr, &bktr->dm_vbibuffer,
	    VBI_BUFFER_SIZE);

        /* allocate space for pixel buffer */
        if (BROOKTREE_ALLOC)
                buf = get_bktr_mem(bktr, &bktr->dm_mem, BROOKTREE_ALLOC);
        else
                buf = 0;

	if ( bootverbose ) {
		printf("%s: buffer size %d, addr 0x%lx\n",
			bktr_name(bktr), BROOKTREE_ALLOC,
			bktr->dm_prog->dm_segs->ds_addr);
	}

	if (buf != 0) {
		bktr->bigbuf = buf;
		bktr->alloc_pages = BROOKTREE_ALLOC_PAGES;
		bzero((void *)bktr->bigbuf, BROOKTREE_ALLOC);
	} else {
		bktr->alloc_pages = 0;
	}

	bktr->flags = METEOR_INITIALIZED | METEOR_AUTOMODE |
		      METEOR_DEV0 | METEOR_RGB16;
	bktr->dma_prog_loaded = FALSE;
	bktr->cols = 640;
	bktr->rows = 480;
	bktr->frames = 1;		/* one frame */
	bktr->format = METEOR_GEO_RGB16;
	bktr->pixfmt = oformat_meteor_to_bt( bktr->format );
	bktr->pixfmt_compat = TRUE;

	bktr->vbiinsert = 0;
	bktr->vbistart = 0;
	bktr->vbisize = 0;
	bktr->vbiflags = 0;

	/* using the pci device id and revision id */
	/* and determine the card type            */
	if (PCI_VENDOR(pci_id) == PCI_VENDOR_BROOKTREE) {
		switch (PCI_PRODUCT(pci_id)) {
		case PCI_PRODUCT_BROOKTREE_BT848:
			if (rev == 0x12)
				bktr->id = BROOKTREE_848A;
			else
				bktr->id = BROOKTREE_848;
			break;
		case PCI_PRODUCT_BROOKTREE_BT849:
			bktr->id = BROOKTREE_849A;
			break;
		case PCI_PRODUCT_BROOKTREE_BT878:
			bktr->id = BROOKTREE_878;
			break;
		case PCI_PRODUCT_BROOKTREE_BT879:
			bktr->id = BROOKTREE_879;
			break;
		}
	}

	bktr->clr_on_start = FALSE;

	/* defaults for the tuner section of the card */
	bktr->tflags = TUNER_INITIALIZED;
	bktr->tuner.frequency = 0;
	bktr->tuner.channel = 0;
	bktr->tuner.chnlset = DEFAULT_CHNLSET;
	bktr->tuner.afc = 0;
	bktr->tuner.radio_mode = 0;
	bktr->audio_mux_select = 0;
	bktr->audio_mute_state = FALSE;
	bktr->bt848_card = -1;
	bktr->bt848_tuner = -1;
	bktr->reverse_mute = -1;
	bktr->slow_msp_audio = 0;
	bktr->msp_use_mono_source = 0;
        bktr->msp_source_selected = -1;
	bktr->audio_mux_present = 1;

	probeCard(bktr, TRUE, unit);

	/* enable drivers on the GPIO port that control the MUXes */
	OUTL(bktr, BKTR_GPIO_OUT_EN, INL(bktr, BKTR_GPIO_OUT_EN) | bktr->card.gpio_mux_bits);

	/* mute the audio stream */
	set_audio( bktr, AUDIO_MUTE );

	/* Initialise any MSP34xx or TDA98xx audio chips */
	init_audio_devices(bktr);

}


/* Copy the vbi lines from 'vbidata' into the circular buffer, 'vbibuffer'.
 * The circular buffer holds 'n' fixed size data blocks.
 * vbisize   is the number of bytes in the circular buffer
 * vbiread   is the point we reading data out of the circular buffer
 * vbiinsert is the point we insert data into the circular buffer
 */
static void
vbidecode(bktr_ptr_t bktr)
{
        unsigned char *dest;
	unsigned int *seq_dest;

	/* Check if there is room in the buffer to insert the data. */
	if (bktr->vbisize + VBI_DATA_SIZE > VBI_BUFFER_SIZE) return;

	/* Copy the VBI data into the next free slot in the buffer. */
	/* 'dest' is the point in vbibuffer where we want to insert new data */
        dest = (unsigned char *)bktr->vbibuffer + bktr->vbiinsert;
        memcpy(dest, (unsigned char *)bktr->vbidata, VBI_DATA_SIZE);

	/* Write the VBI sequence number to the end of the vbi data */
	/* This is used by the AleVT teletext program */
	seq_dest = (unsigned int *)((unsigned char *)bktr->vbibuffer
			+ bktr->vbiinsert
			+ (VBI_DATA_SIZE - sizeof(bktr->vbi_sequence_number)));
	*seq_dest = bktr->vbi_sequence_number;

	/* And increase the VBI sequence number */
	/* This can wrap around */
	bktr->vbi_sequence_number++;

	/* Increment the vbiinsert pointer */
	/* This can wrap around */
	bktr->vbiinsert += VBI_DATA_SIZE;
	bktr->vbiinsert = (bktr->vbiinsert % VBI_BUFFER_SIZE);

	/* And increase the amount of vbi data in the buffer */
	bktr->vbisize = bktr->vbisize + VBI_DATA_SIZE;
}


/*
 * the common interrupt handler.
 * Returns a 0 or 1 depending on whether the interrupt has handled.
 * In the OS specific section, bktr_intr() is defined which calls this
 * common interrupt handler.
 */
int
common_bktr_intr( void *arg )
{
	bktr_ptr_t	bktr = (bktr_ptr_t) arg;
	u_int	bktr_status;
	u_char	dstatus;
	u_int	field;
	u_int	w_field;
	u_int	req_field;

	/*
	 * check to see if any interrupts are unmasked on this device.  If
	 * none are, then we likely got here by way of being on a PCI shared
	 * interrupt dispatch list.
	 */
	if (INL(bktr, BKTR_INT_MASK) == ALL_INTS_DISABLED)
		return 0;	/* bail out now, before we do something we
				   shouldn't */

	if (!(bktr->flags & METEOR_OPEN)) {
		OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);
		OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);
		/* return; ?? */
	}

	/* record and clear the INTerrupt status bits */
	bktr_status = INL(bktr, BKTR_INT_STAT);
	OUTL(bktr, BKTR_INT_STAT, bktr_status & ~I2C_BITS);	/* don't touch i2c */

	/* record and clear the device status register */
	dstatus = INB(bktr, BKTR_DSTATUS);
	OUTB(bktr, BKTR_DSTATUS, 0x00);

#if defined( STATUS_SUM )
	/* add any new device status or INTerrupt status bits */
	status_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));
	status_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);
#endif /* STATUS_SUM */
	/* printf( "%s: STATUS %x %x %x \n", bktr_name(bktr),
		dstatus, bktr_status, INL(bktr, BKTR_RISC_COUNT) );
	*/


	/* if risc was disabled re-start process again */
	/* if there was one of the following errors re-start again */
	if ( !(bktr_status & BT848_INT_RISC_EN) ||
	     ((bktr_status &(/* BT848_INT_FBUS   | */
			     /* BT848_INT_FTRGT  | */
			     /* BT848_INT_FDSR   | */
			      BT848_INT_PPERR  |
			      BT848_INT_RIPERR | BT848_INT_PABORT |
			      BT848_INT_OCERR  | BT848_INT_SCERR) ) != 0)
		|| ((INB(bktr, BKTR_TDEC) == 0) && (bktr_status & TDEC_BITS)) ) {

		u_short	tdec_save = INB(bktr, BKTR_TDEC);

		OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);
		OUTB(bktr, BKTR_CAP_CTL, CAPTURE_OFF);

		OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);

		/*  Reset temporal decimation counter  */
		OUTB(bktr, BKTR_TDEC, 0);
		OUTB(bktr, BKTR_TDEC, tdec_save);

		/*  Reset to no-fields captured state  */
		if (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {
			switch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {
			case METEOR_ONLY_ODD_FIELDS:
				bktr->flags |= METEOR_WANT_ODD;
				break;
			case METEOR_ONLY_EVEN_FIELDS:
				bktr->flags |= METEOR_WANT_EVEN;
				break;
			default:
				bktr->flags |= METEOR_WANT_MASK;
				break;
			}
		}

		OUTL(bktr, BKTR_RISC_STRT_ADD, bktr->dm_prog->dm_segs->ds_addr);
		OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_ENABLED);
		OUTW(bktr, BKTR_GPIO_DMA_CTL, bktr->capcontrol);

		OUTL(bktr, BKTR_INT_MASK, BT848_INT_MYSTERYBIT |
				    BT848_INT_RISCI      |
				    BT848_INT_VSYNC      |
				    BT848_INT_FMTCHG);

		OUTB(bktr, BKTR_CAP_CTL, bktr->bktr_cap_ctl);

		add_video_randomness(tdec_save);

		return 1;
	}

	/* If this is not a RISC program interrupt, return */
	if (!(bktr_status & BT848_INT_RISCI))
		return 0;

/**
	printf( "%s: intr status %x %x %x\n", bktr_name(bktr),
		bktr_status, dstatus, INL(bktr, BKTR_RISC_COUNT) );
 */

	add_video_randomness(INL(bktr, BKTR_RISC_COUNT));

	/*
	 * Disable future interrupts if a capture mode is not selected.
	 * This can happen when we are in the process of closing or
	 * changing capture modes, otherwise it shouldn't happen.
	 */
	if (!(bktr->flags & METEOR_CAP_MASK))
		OUTB(bktr, BKTR_CAP_CTL, CAPTURE_OFF);

	/* Determine which field generated this interrupt */
	field = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;

	/*
	 * Process the VBI data if it is being captured. We do this once
	 * both Odd and Even VBI data is captured. Therefore we do this
	 * in the Even field interrupt handler.
	 */
	if ((bktr->vbiflags & (VBI_CAPTURE|VBI_OPEN)) ==
	    (VBI_CAPTURE|VBI_OPEN) && (field == EVEN_F)) {
		/* Put VBI data into circular buffer */
		vbidecode(bktr);

		/* If someone is blocked on reading from /dev/vbi, wake them */
		if (bktr->vbi_read_blocked) {
			bktr->vbi_read_blocked = FALSE;
			wakeup(VBI_SLEEP);
		}

		/* If someone has a select() on /dev/vbi, inform them */
#ifndef __OpenBSD__
		if (bktr->vbi_select.si_pid) {
			selwakeup(&bktr->vbi_select);
		}
#else
		selwakeup(&bktr->vbi_select);
#endif
	}


	/*
	 *  Register the completed field
	 *    (For dual-field mode, require fields from the same frame)
	 */
	switch ( bktr->flags & METEOR_WANT_MASK ) {
		case METEOR_WANT_ODD  : w_field = ODD_F         ;  break;
		case METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;
		default               : w_field = (ODD_F|EVEN_F);  break;
	}
	switch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {
		case METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;
		case METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;
		default                      : req_field = (ODD_F|EVEN_F);
			                       break;
	}

	if (( field == EVEN_F ) && ( w_field == EVEN_F ))
		bktr->flags &= ~METEOR_WANT_EVEN;
	else if (( field == ODD_F ) && ( req_field == ODD_F ) &&
		 ( w_field == ODD_F ))
		bktr->flags &= ~METEOR_WANT_ODD;
	else if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&
		 ( w_field == (ODD_F|EVEN_F) ))
		bktr->flags &= ~METEOR_WANT_ODD;
	else if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&
		 ( w_field == ODD_F )) {
		bktr->flags &= ~METEOR_WANT_ODD;
		bktr->flags |=  METEOR_WANT_EVEN;
	}
	else {
		/*  We're out of sync.  Start over.  */
		if (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {
			switch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {
			case METEOR_ONLY_ODD_FIELDS:
				bktr->flags |= METEOR_WANT_ODD;
				break;
			case METEOR_ONLY_EVEN_FIELDS:
				bktr->flags |= METEOR_WANT_EVEN;
				break;
			default:
				bktr->flags |= METEOR_WANT_MASK;
				break;
			}
		}
		return 1;
	}

	/*
	 * If we have a complete frame.
	 */
	if (!(bktr->flags & METEOR_WANT_MASK)) {
		bktr->frames_captured++;
		/*
		 * post the completion time.
		 */
		if (bktr->flags & METEOR_WANT_TS) {
			struct timeval *ts;

			if ((u_int) bktr->alloc_pages * PAGE_SIZE
			   <= (bktr->frame_size + sizeof(struct timeval))) {
				ts =(struct timeval *)bktr->bigbuf +
				  bktr->frame_size;
				/* doesn't work in synch mode except
				 *  for first frame */
				/* XXX */
				microtime(ts);
			}
		}


		/*
		 * Wake up the user in single capture mode.
		 */
		if (bktr->flags & METEOR_SINGLE) {

			/* stop dma */
			OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);

			/* disable risc, leave fifo running */
			OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_ENABLED);
			wakeup(BKTR_SLEEP);
		}

		/*
		 * If the user requested to be notified via signal,
		 * let them know the frame is complete.
		 */

		if (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))
			psignal( bktr->proc,
				 bktr->signal&(~METEOR_SIG_MODE_MASK) );

		/*
		 * Reset the want flags if in continuous or
		 * synchronous capture mode.
		 */
/*
* XXX NOTE (Luigi):
* currently we only support 3 capture modes: odd only, even only,
* odd+even interlaced (odd field first). A fourth mode (non interlaced,
* either even OR odd) could provide 60 (50 for PAL) pictures per
* second, but it would require this routine to toggle the desired frame
* each time, and one more different DMA program for the Bt848.
* As a consequence, this fourth mode is currently unsupported.
*/

		if (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {
			switch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {
			case METEOR_ONLY_ODD_FIELDS:
				bktr->flags |= METEOR_WANT_ODD;
				break;
			case METEOR_ONLY_EVEN_FIELDS:
				bktr->flags |= METEOR_WANT_EVEN;
				break;
			default:
				bktr->flags |= METEOR_WANT_MASK;
				break;
			}
		}
	}

	return 1;
}




/*
 *
 */
extern int bt848_format; /* used to set the default format, PAL or NTSC */
int
video_open( bktr_ptr_t bktr )
{
	int frame_rate, video_format=0;

	if (bktr->flags & METEOR_OPEN)		/* device is busy */
		return( EBUSY );

	bktr->flags |= METEOR_OPEN;

#ifdef BT848_DUMP
	dump_bt848( bt848 );
#endif

        bktr->clr_on_start = FALSE;

	OUTB(bktr, BKTR_DSTATUS, 0x00);			/* clear device status reg. */

	OUTB(bktr, BKTR_ADC, SYNC_LEVEL);

#if BKTR_SYSTEM_DEFAULT == BROOKTREE_PAL
	video_format = 0;
#else
	video_format = 1;
#endif

	if (bt848_format == 0 )
	  video_format = 0;

	if (bt848_format == 1 )
	  video_format = 1;

	if (video_format == 1 ) {
	  OUTB(bktr, BKTR_IFORM, BT848_IFORM_F_NTSCM);
	  bktr->format_params = BT848_IFORM_F_NTSCM;

	} else {
	  OUTB(bktr, BKTR_IFORM, BT848_IFORM_F_PALBDGHI);
	  bktr->format_params = BT848_IFORM_F_PALBDGHI;

	}

	OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) |
	    format_params[bktr->format_params].iform_xtsel);

	/* work around for new Hauppauge 878 cards */
	if ((bktr->card.card_id == CARD_HAUPPAUGE) &&
	    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )
		OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | BT848_IFORM_M_MUX3);
	else
		OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | BT848_IFORM_M_MUX1);

	OUTB(bktr, BKTR_ADELAY, format_params[bktr->format_params].adelay);
	OUTB(bktr, BKTR_BDELAY, format_params[bktr->format_params].bdelay);
	frame_rate    = format_params[bktr->format_params].frame_rate;

	/* enable PLL mode using 28MHz crystal for PAL/SECAM users */
	if (bktr->xtal_pll_mode == BT848_USE_PLL) {
		OUTB(bktr, BKTR_TGCTRL, 0);
		OUTB(bktr, BKTR_PLL_F_LO, 0xf9);
		OUTB(bktr, BKTR_PLL_F_HI, 0xdc);
		OUTB(bktr, BKTR_PLL_F_XCI, 0x8e);
	}

	bktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;

	bktr->max_clip_node = 0;

	OUTB(bktr, BKTR_COLOR_CTL,
	    BT848_COLOR_CTL_GAMMA | BT848_COLOR_CTL_RGB_DED);

	OUTB(bktr, BKTR_E_HSCALE_LO, 170);
	OUTB(bktr, BKTR_O_HSCALE_LO, 170);

	OUTB(bktr, BKTR_E_DELAY_LO, 0x72);
	OUTB(bktr, BKTR_O_DELAY_LO, 0x72);
	OUTB(bktr, BKTR_E_SCLOOP, 0);
	OUTB(bktr, BKTR_O_SCLOOP, 0);

	OUTB(bktr, BKTR_VBI_PACK_SIZE, 0);
	OUTB(bktr, BKTR_VBI_PACK_DEL, 0);

	bktr->fifo_errors = 0;
	bktr->dma_errors = 0;
	bktr->frames_captured = 0;
	bktr->even_fields_captured = 0;
	bktr->odd_fields_captured = 0;
	bktr->proc = NULL;
	set_fps(bktr, frame_rate);
	bktr->video.addr = 0;
	bktr->video.width = 0;
	bktr->video.banksize = 0;
	bktr->video.ramsize = 0;
	bktr->pixfmt_compat = TRUE;
	bktr->format = METEOR_GEO_RGB16;
	bktr->pixfmt = oformat_meteor_to_bt( bktr->format );

	bktr->capture_area_enabled = FALSE;

	/* if you take this out triton-based mobos will operate unreliably */
	OUTL(bktr, BKTR_INT_MASK, BT848_INT_MYSTERYBIT);

	return( 0 );
}

int
vbi_open( bktr_ptr_t bktr )
{
	if (bktr->vbiflags & VBI_OPEN)		/* device is busy */
		return( EBUSY );

	bktr->vbiflags |= VBI_OPEN;

	/* reset the VBI circular buffer pointers and clear the buffers */
	bktr->vbiinsert = 0;
	bktr->vbistart = 0;
	bktr->vbisize = 0;
	bktr->vbi_sequence_number = 0;
	bktr->vbi_read_blocked = FALSE;

	bzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);
	bzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);

	return( 0 );
}

/*
 *
 */
int
tuner_open( bktr_ptr_t bktr )
{
	if ( !(bktr->tflags & TUNER_INITIALIZED) )	/* device not found */
		return( ENXIO );

	if ( bktr->tflags & TUNER_OPEN )		/* already open */
		return( 0 );

	bktr->tflags |= TUNER_OPEN;

	return( 0 );
}




/*
 *
 */
int
video_close( bktr_ptr_t bktr )
{
	bktr->flags &= ~(METEOR_OPEN     |
			 METEOR_SINGLE   |
			 METEOR_CAP_MASK |
			 METEOR_WANT_MASK);

	OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);
	OUTB(bktr, BKTR_CAP_CTL, CAPTURE_OFF);

	bktr->dma_prog_loaded = FALSE;
	OUTB(bktr, BKTR_TDEC, 0);
	OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);

/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */
	OUTL(bktr, BKTR_SRESET, 0xf);
	OUTL(bktr, BKTR_INT_STAT, ALL_INTS_CLEARED);

	return( 0 );
}


/*
 * tuner close handle,
 *  place holder for tuner specific operations on a close.
 */
int
tuner_close( bktr_ptr_t bktr )
{
	bktr->tflags &= ~TUNER_OPEN;

	return( 0 );
}

int
vbi_close( bktr_ptr_t bktr )
{

	bktr->vbiflags &= ~VBI_OPEN;

	return( 0 );
}

/*
 *
 */
int
video_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)
{
        int             status;
        size_t          count;


	if (bktr->bigbuf == 0)	/* no frame buffer allocated (ioctl failed) */
		return( ENOMEM );

	if (bktr->flags & METEOR_CAP_MASK)
		return( EIO );	/* already capturing */

        OUTB(bktr, BKTR_CAP_CTL, bktr->bktr_cap_ctl);


	count = bktr->rows * bktr->cols *
		pixfmt_table[ bktr->pixfmt ].public.Bpp;

	if (uio->uio_resid < count)
		return( EINVAL );

	bktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);

	/* capture one frame */
	start_capture(bktr, METEOR_SINGLE);
	/* wait for capture to complete */
	OUTL(bktr, BKTR_INT_STAT, ALL_INTS_CLEARED);
	OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_ENABLED);
	OUTW(bktr, BKTR_GPIO_DMA_CTL, bktr->capcontrol);
	OUTL(bktr, BKTR_INT_MASK, BT848_INT_MYSTERYBIT |
                            BT848_INT_RISCI      |
                            BT848_INT_VSYNC      |
                            BT848_INT_FMTCHG);


	status = tsleep(BKTR_SLEEP, BKTRPRI, "captur", 0);
	if (!status)		/* successful capture */
		status = uiomove((caddr_t)bktr->bigbuf, count, uio);
	else
		printf ("%s: read: tsleep error %d\n",
			bktr_name(bktr), status);

	bktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);

	return( status );
}

/*
 * Read VBI data from the vbi circular buffer
 * The buffer holds vbi data blocks which are the same size
 * vbiinsert is the position we will insert the next item into the buffer
 * vbistart is the actual position in the buffer we want to read from
 * vbisize is the exact number of bytes in the buffer left to read
 */
int
vbi_read(bktr_ptr_t bktr, struct uio *uio, int ioflag)
{
	size_t          readsize, readsize2;
	int             status;


	while(bktr->vbisize == 0) {
		if (ioflag & IO_NDELAY) {
			return EWOULDBLOCK;
		}

		bktr->vbi_read_blocked = TRUE;
		if ((status = tsleep(VBI_SLEEP, VBIPRI, "vbi", 0))) {
			return status;
		}
	}

	/* Now we have some data to give to the user */

	/* We cannot read more bytes than there are in
	 * the circular buffer
	 */
	readsize = ulmin(uio->uio_resid, bktr->vbisize);

	/* Check if we can read this number of bytes without having
	 * to wrap around the circular buffer */
	if (readsize >= VBI_BUFFER_SIZE - bktr->vbistart) {
		/* We need to wrap around */

		readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;
		status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);
		if (status == 0)
			status = uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);
	} else {
		/* We do not need to wrap around */
		status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);
	}

	/* Update the number of bytes left to read */
	bktr->vbisize -= readsize;

	/* Update vbistart */
	bktr->vbistart += readsize;
	bktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */

	return( status );

}



/*
 * video ioctls
 */
int
video_ioctl( bktr_ptr_t bktr, int unit, ioctl_cmd_t cmd, caddr_t arg, struct proc* pr )
{
	volatile u_char		c_temp;
	unsigned int		temp;
	unsigned int		temp_iform;
	unsigned int		error;
	struct meteor_geomet	*geo;
	struct meteor_counts	*counts;
	struct meteor_video	*video;
	struct bktr_capture_area *cap_area;
	vaddr_t			buf;
	int                     i;
	char                    char_temp;

	switch ( cmd ) {

	case BT848SCLIP: /* set clip region */
	    bktr->max_clip_node = 0;
	    memcpy(&bktr->clip_list, arg, sizeof(bktr->clip_list));

	    for (i = 0; i < BT848_MAX_CLIP_NODE; i++) {
		if (bktr->clip_list[i].y_min ==  0 &&
		    bktr->clip_list[i].y_max == 0)
		    break;
	    }
	    bktr->max_clip_node = i;

	    /* make sure that the list contains a valid clip secquence */
	    /* the clip rectangles should be sorted by x then by y as the
               second order sort key */

	    /* clip rectangle list is terminated by y_min and y_max set to 0 */

	    /* to disable clipping set  y_min and y_max to 0 in the first
               clip rectangle . The first clip rectangle is clip_list[0].
             */

	    if (bktr->max_clip_node == 0 &&
		(bktr->clip_list[0].y_min != 0 &&
		 bktr->clip_list[0].y_max != 0)) {
		return EINVAL;
	    }

	    for (i = 0; i < BT848_MAX_CLIP_NODE - 1 ; i++) {
		if (bktr->clip_list[i].y_min == 0 &&
		    bktr->clip_list[i].y_max == 0) {
		    break;
		}
		if ( bktr->clip_list[i+1].y_min != 0 &&
		     bktr->clip_list[i+1].y_max != 0 &&
		     bktr->clip_list[i].x_min > bktr->clip_list[i+1].x_min ) {

		    bktr->max_clip_node = 0;
		    return (EINVAL);

		 }

		if (bktr->clip_list[i].x_min >= bktr->clip_list[i].x_max ||
		    bktr->clip_list[i].y_min >= bktr->clip_list[i].y_max ||
		    bktr->clip_list[i].x_min < 0 ||
		    bktr->clip_list[i].x_max < 0 ||
		    bktr->clip_list[i].y_min < 0 ||
		    bktr->clip_list[i].y_max < 0 ) {
		    bktr->max_clip_node = 0;
		    return (EINVAL);
		}
	    }

	    bktr->dma_prog_loaded = FALSE;

	    break;

	case METEORSTATUS:	/* get Bt848 status */
		c_temp = INB(bktr, BKTR_DSTATUS);
		temp = 0;
		if (!(c_temp & 0x40)) temp |= METEOR_STATUS_HCLK;
		if (!(c_temp & 0x10)) temp |= METEOR_STATUS_FIDT;
		*(u_short *)arg = temp;
		break;

	case BT848SFMT:		/* set input format */
		temp = *(unsigned int *)arg & BT848_IFORM_FORMAT;
		temp_iform = INB(bktr, BKTR_IFORM);
		temp_iform &= ~BT848_IFORM_FORMAT;
		temp_iform &= ~BT848_IFORM_XTSEL;
		OUTB(bktr, BKTR_IFORM, (temp_iform | temp | format_params[temp].iform_xtsel));
		switch( temp ) {
		case BT848_IFORM_F_AUTO:
			bktr->flags = (bktr->flags & ~METEOR_FORM_MASK) |
			METEOR_AUTOMODE;
			break;

		case BT848_IFORM_F_NTSCM:
		case BT848_IFORM_F_NTSCJ:
			bktr->flags = (bktr->flags & ~METEOR_FORM_MASK) |
				METEOR_NTSC;
			OUTB(bktr, BKTR_ADELAY, format_params[temp].adelay);
			OUTB(bktr, BKTR_BDELAY, format_params[temp].bdelay);
			bktr->format_params = temp;
			break;

		case BT848_IFORM_F_PALBDGHI:
		case BT848_IFORM_F_PALN:
		case BT848_IFORM_F_SECAM:
		case BT848_IFORM_F_RSVD:
		case BT848_IFORM_F_PALM:
			bktr->flags = (bktr->flags & ~METEOR_FORM_MASK) |
				METEOR_PAL;
			OUTB(bktr, BKTR_ADELAY, format_params[temp].adelay);
			OUTB(bktr, BKTR_BDELAY, format_params[temp].bdelay);
			bktr->format_params = temp;
			break;

		}
		bktr->dma_prog_loaded = FALSE;
		break;

	case METEORSFMT:	/* set input format */
		temp_iform = INB(bktr, BKTR_IFORM);
		temp_iform &= ~BT848_IFORM_FORMAT;
		temp_iform &= ~BT848_IFORM_XTSEL;
		switch(*(unsigned int *)arg & METEOR_FORM_MASK ) {
		case 0:		/* default */
		case METEOR_FMT_NTSC:
			bktr->flags = (bktr->flags & ~METEOR_FORM_MASK) |
				METEOR_NTSC;
			OUTB(bktr, BKTR_IFORM, temp_iform | BT848_IFORM_F_NTSCM |
		                         format_params[BT848_IFORM_F_NTSCM].iform_xtsel);
			OUTB(bktr, BKTR_ADELAY, format_params[BT848_IFORM_F_NTSCM].adelay);
			OUTB(bktr, BKTR_BDELAY, format_params[BT848_IFORM_F_NTSCM].bdelay);
			bktr->format_params = BT848_IFORM_F_NTSCM;
			break;

		case METEOR_FMT_PAL:
			bktr->flags = (bktr->flags & ~METEOR_FORM_MASK) |
				METEOR_PAL;
			OUTB(bktr, BKTR_IFORM, temp_iform | BT848_IFORM_F_PALBDGHI |
		                         format_params[BT848_IFORM_F_PALBDGHI].iform_xtsel);
			OUTB(bktr, BKTR_ADELAY, format_params[BT848_IFORM_F_PALBDGHI].adelay);
			OUTB(bktr, BKTR_BDELAY, format_params[BT848_IFORM_F_PALBDGHI].bdelay);
			bktr->format_params = BT848_IFORM_F_PALBDGHI;
			break;

		case METEOR_FMT_AUTOMODE:
			bktr->flags = (bktr->flags & ~METEOR_FORM_MASK) |
				METEOR_AUTOMODE;
			OUTB(bktr, BKTR_IFORM, temp_iform | BT848_IFORM_F_AUTO |
		                         format_params[BT848_IFORM_F_AUTO].iform_xtsel);
			break;

		default:
			return( EINVAL );
		}
		bktr->dma_prog_loaded = FALSE;
		break;

	case METEORGFMT:	/* get input format */
		*(u_int *)arg = bktr->flags & METEOR_FORM_MASK;
		break;


	case BT848GFMT:		/* get input format */
	        *(u_int *)arg = INB(bktr, BKTR_IFORM) & BT848_IFORM_FORMAT;
		break;

	case METEORSCOUNT:	/* (re)set error counts */
		counts = (struct meteor_counts *) arg;
		bktr->fifo_errors = counts->fifo_errors;
		bktr->dma_errors = counts->dma_errors;
		bktr->frames_captured = counts->frames_captured;
		bktr->even_fields_captured = counts->even_fields_captured;
		bktr->odd_fields_captured = counts->odd_fields_captured;
		break;

	case METEORGCOUNT:	/* get error counts */
		counts = (struct meteor_counts *) arg;
		counts->fifo_errors = bktr->fifo_errors;
		counts->dma_errors = bktr->dma_errors;
		counts->frames_captured = bktr->frames_captured;
		counts->even_fields_captured = bktr->even_fields_captured;
		counts->odd_fields_captured = bktr->odd_fields_captured;
		break;

	case METEORGVIDEO:
		video = (struct meteor_video *)arg;
		video->addr = bktr->video.addr;
		video->width = bktr->video.width;
		video->banksize = bktr->video.banksize;
		video->ramsize = bktr->video.ramsize;
		break;

	case METEORSVIDEO:
		video = (struct meteor_video *)arg;
		bktr->video.addr = video->addr;
		bktr->video.width = video->width;
		bktr->video.banksize = video->banksize;
		bktr->video.ramsize = video->ramsize;
		break;

	case METEORSFPS:
		set_fps(bktr, *(u_short *)arg);
		break;

	case METEORGFPS:
		*(u_short *)arg = bktr->fps;
		break;

	case METEORSHUE:	/* set hue */
		OUTB(bktr, BKTR_HUE, (*(u_char *) arg) & 0xff);
		break;

	case METEORGHUE:	/* get hue */
		*(u_char *)arg = INB(bktr, BKTR_HUE);
		break;

	case METEORSBRIG:	/* set brightness */
	        char_temp =    ( *(u_char *)arg & 0xff) - 128;
		OUTB(bktr, BKTR_BRIGHT, char_temp);

		break;

	case METEORGBRIG:	/* get brightness */
		*(u_char *)arg = INB(bktr, BKTR_BRIGHT) + 128;
		break;

	case METEORSCSAT:	/* set chroma saturation */
		temp = (int)*(u_char *)arg;

		OUTB(bktr, BKTR_SAT_U_LO, (temp << 1) & 0xff);
		OUTB(bktr, BKTR_SAT_V_LO, (temp << 1) & 0xff);
		OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL)
		                     & ~(BT848_E_CONTROL_SAT_U_MSB
					 | BT848_E_CONTROL_SAT_V_MSB));
		OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL)
		                     & ~(BT848_O_CONTROL_SAT_U_MSB |
					 BT848_O_CONTROL_SAT_V_MSB));

		if ( temp & BIT_SEVEN_HIGH ) {
		        OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL)
			                     | (BT848_E_CONTROL_SAT_U_MSB
						| BT848_E_CONTROL_SAT_V_MSB));
			OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL)
			                     | (BT848_O_CONTROL_SAT_U_MSB
						| BT848_O_CONTROL_SAT_V_MSB));
		}
		break;

	case METEORGCSAT:	/* get chroma saturation */
		temp = (INB(bktr, BKTR_SAT_V_LO) >> 1) & 0xff;
		if ( INB(bktr, BKTR_E_CONTROL) & BT848_E_CONTROL_SAT_V_MSB )
			temp |= BIT_SEVEN_HIGH;
		*(u_char *)arg = (u_char)temp;
		break;

	case METEORSCONT:	/* set contrast */
		temp = (int)*(u_char *)arg & 0xff;
		temp <<= 1;
		OUTB(bktr, BKTR_CONTRAST_LO, temp & 0xff);
		OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) & ~BT848_E_CONTROL_CON_MSB);
		OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL) & ~BT848_O_CONTROL_CON_MSB);
		OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) |
			(((temp & 0x100) >> 6 ) & BT848_E_CONTROL_CON_MSB));
		OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL) |
			(((temp & 0x100) >> 6 ) & BT848_O_CONTROL_CON_MSB));
		break;

	case METEORGCONT:	/* get contrast */
		temp = (int)INB(bktr, BKTR_CONTRAST_LO) & 0xff;
		temp |= ((int)INB(bktr, BKTR_O_CONTROL) & 0x04) << 6;
		*(u_char *)arg = (u_char)((temp >> 1) & 0xff);
		break;

	case BT848SCBUF:	/* set Clear-Buffer-on-start flag */
		bktr->clr_on_start = (*(int *)arg != 0);
		break;

	case BT848GCBUF:	/* get Clear-Buffer-on-start flag */
		*(int *)arg = (int) bktr->clr_on_start;
		break;

	case METEORSSIGNAL:
		if(*(int *)arg == 0 || *(int *)arg >= NSIG) {
			return( EINVAL );
			break;
		}
		bktr->signal = *(int *) arg;
		bktr->proc = pr;
		break;

	case METEORGSIGNAL:
		*(int *)arg = bktr->signal;
		break;

	case METEORCAPTUR:
		temp = bktr->flags;
		switch (*(int *) arg) {
		case METEOR_CAP_SINGLE:

			if (bktr->bigbuf==0)	/* no frame buffer allocated */
				return( ENOMEM );
			/* already capturing */
			if (temp & METEOR_CAP_MASK)
				return( EIO );



			start_capture(bktr, METEOR_SINGLE);

			/* wait for capture to complete */
			OUTL(bktr, BKTR_INT_STAT, ALL_INTS_CLEARED);
			OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_ENABLED);
			OUTW(bktr, BKTR_GPIO_DMA_CTL, bktr->capcontrol);

			OUTL(bktr, BKTR_INT_MASK, BT848_INT_MYSTERYBIT |
					    BT848_INT_RISCI      |
					    BT848_INT_VSYNC      |
					    BT848_INT_FMTCHG);

			OUTB(bktr, BKTR_CAP_CTL, bktr->bktr_cap_ctl);
			error = tsleep(BKTR_SLEEP, BKTRPRI, "captur", hz);
			if (error && (error != ERESTART)) {
				/*  Here if we didn't get complete frame  */
#ifdef DIAGNOSTIC
				printf( "%s: ioctl: tsleep error %d %x\n",
					bktr_name(bktr), error,
					INL(bktr, BKTR_RISC_COUNT));
#endif

				/* stop dma */
				OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);

				/* disable risc, leave fifo running */
				OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_ENABLED);
			}

			bktr->flags &= ~(METEOR_SINGLE|METEOR_WANT_MASK);
			/* FIXME: should we set bt848->int_stat ??? */
			break;

		case METEOR_CAP_CONTINOUS:
			if (bktr->bigbuf == 0)	/* no frame buffer allocated */
				return (ENOMEM);
			/* already capturing */
			if (temp & METEOR_CAP_MASK)
			    return( EIO );


			start_capture(bktr, METEOR_CONTIN);

			/* Clear the interrupt status register */
			OUTL(bktr, BKTR_INT_STAT, INL(bktr, BKTR_INT_STAT));

			OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_ENABLED);
			OUTW(bktr, BKTR_GPIO_DMA_CTL, bktr->capcontrol);
			OUTB(bktr, BKTR_CAP_CTL, bktr->bktr_cap_ctl);

			OUTL(bktr, BKTR_INT_MASK, BT848_INT_MYSTERYBIT |
					    BT848_INT_RISCI      |
			                    BT848_INT_VSYNC      |
					    BT848_INT_FMTCHG);
#ifdef BT848_DUMP
			dump_bt848( bt848 );
#endif
			break;

		case METEOR_CAP_STOP_CONT:
			if (bktr->flags & METEOR_CONTIN) {
				/* turn off capture */
				OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);
				OUTB(bktr, BKTR_CAP_CTL, CAPTURE_OFF);
				OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);
				bktr->flags &=
					~(METEOR_CONTIN | METEOR_WANT_MASK);

			}
		}
		break;

	case METEORSETGEO:
		/* can't change parameters while capturing */
		if (bktr->flags & METEOR_CAP_MASK)
			return( EBUSY );


		geo = (struct meteor_geomet *) arg;

		error = 0;
		/* Either even or odd, if even & odd, then these a zero */
		if ((geo->oformat & METEOR_GEO_ODD_ONLY) &&
			(geo->oformat & METEOR_GEO_EVEN_ONLY)) {
			printf( "%s: ioctl: Geometry odd or even only.\n",
				bktr_name(bktr));
			return( EINVAL );
		}

		/* set/clear even/odd flags */
		if (geo->oformat & METEOR_GEO_ODD_ONLY)
			bktr->flags |= METEOR_ONLY_ODD_FIELDS;
		else
			bktr->flags &= ~METEOR_ONLY_ODD_FIELDS;
		if (geo->oformat & METEOR_GEO_EVEN_ONLY)
			bktr->flags |= METEOR_ONLY_EVEN_FIELDS;
		else
			bktr->flags &= ~METEOR_ONLY_EVEN_FIELDS;

		if (geo->columns <= 0) {
			printf(
			"%s: ioctl: %d: columns must be greater than zero.\n",
				bktr_name(bktr), geo->columns);
			error = EINVAL;
		}
		else if ((geo->columns & 0x3fe) != geo->columns) {
			printf(
			"%s: ioctl: %d: columns too large or not even.\n",
				bktr_name(bktr), geo->columns);
			error = EINVAL;
		}

		if (geo->rows <= 0) {
			printf(
			"%s: ioctl: %d: rows must be greater than zero.\n",
				bktr_name(bktr), geo->rows);
			error = EINVAL;
		}
		else if (((geo->rows & 0x7fe) != geo->rows) ||
			((geo->oformat & METEOR_GEO_FIELD_MASK) &&
				((geo->rows & 0x3fe) != geo->rows)) ) {
			printf(
			"%s: ioctl: %d: rows too large or not even.\n",
				bktr_name(bktr), geo->rows);
			error = EINVAL;
		}

		if (geo->frames > 32) {
			printf("%s: ioctl: too many frames.\n",
			       bktr_name(bktr));

			error = EINVAL;
		}

		if (error)
			return( error );

		bktr->dma_prog_loaded = FALSE;
		OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);

		OUTL(bktr, BKTR_INT_MASK, ALL_INTS_DISABLED);

		if ((temp=(geo->rows * geo->columns * geo->frames * 2))) {
			if (geo->oformat & METEOR_GEO_RGB24) temp = temp * 2;

			/* meteor_mem structure for SYNC Capture */
			if (geo->frames > 1) temp += PAGE_SIZE;

			temp = atop(round_page(temp));
			if ((int) temp > bktr->alloc_pages
			    && bktr->video.addr == 0) {

/*****************************/
/* *** OS Dependant code *** */
/*****************************/
                                bus_dmamap_t dmamap;

                                buf = get_bktr_mem(bktr, &dmamap,
                                                   temp * PAGE_SIZE);
                                if (buf != 0) {
                                        free_bktr_mem(bktr, bktr->dm_mem,
                                                      bktr->bigbuf);
                                        bktr->dm_mem = dmamap;
					bktr->bigbuf = buf;
					bktr->alloc_pages = temp;
					if (bootverbose)
						printf("%s: ioctl: "
						    "Allocating %d bytes\n",
						    bktr_name(bktr),
						    temp * PAGE_SIZE);
				} else
					error = ENOMEM;
			}
		}

		if (error)
			return error;

		bktr->rows = geo->rows;
		bktr->cols = geo->columns;
		bktr->frames = geo->frames;

		/*  Pixel format (if in meteor pixfmt compatibility mode)  */
		if ( bktr->pixfmt_compat ) {
			bktr->format = METEOR_GEO_YUV_422;
			switch (geo->oformat & METEOR_GEO_OUTPUT_MASK) {
			case 0:			/* default */
			case METEOR_GEO_RGB16:
				    bktr->format = METEOR_GEO_RGB16;
				    break;
			case METEOR_GEO_RGB24:
				    bktr->format = METEOR_GEO_RGB24;
				    break;
			case METEOR_GEO_YUV_422:
				    bktr->format = METEOR_GEO_YUV_422;
                                    if (geo->oformat & METEOR_GEO_YUV_12)
					bktr->format = METEOR_GEO_YUV_12;
				    break;
			case METEOR_GEO_YUV_PACKED:
				    bktr->format = METEOR_GEO_YUV_PACKED;
				    break;
			}
			bktr->pixfmt = oformat_meteor_to_bt( bktr->format );
		}

		if (bktr->flags & METEOR_CAP_MASK) {

			if (bktr->flags & (METEOR_CONTIN|METEOR_SYNCAP)) {
				switch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {
				case METEOR_ONLY_ODD_FIELDS:
					bktr->flags |= METEOR_WANT_ODD;
					break;
				case METEOR_ONLY_EVEN_FIELDS:
					bktr->flags |= METEOR_WANT_EVEN;
					break;
				default:
					bktr->flags |= METEOR_WANT_MASK;
					break;
				}

				start_capture(bktr, METEOR_CONTIN);
				OUTL(bktr, BKTR_INT_STAT, INL(bktr, BKTR_INT_STAT));
				OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_ENABLED);
				OUTW(bktr, BKTR_GPIO_DMA_CTL, bktr->capcontrol);
				OUTL(bktr, BKTR_INT_MASK, BT848_INT_MYSTERYBIT |
						    BT848_INT_VSYNC      |
						    BT848_INT_FMTCHG);
			}
		}
		break;
	/* end of METEORSETGEO */

	/* FIXME. The Capture Area currently has the following restrictions:
	GENERAL
	 y_offset may need to be even in interlaced modes
	RGB24 - Interlaced mode
	 x_size must be greater than or equal to 1.666*METEORSETGEO width (cols)
	 y_size must be greater than or equal to METEORSETGEO height (rows)
	RGB24 - Even Only (or Odd Only) mode
	 x_size must be greater than or equal to 1.666*METEORSETGEO width (cols)
	 y_size must be greater than or equal to 2*METEORSETGEO height (rows)
	YUV12 - Interlaced mode
	 x_size must be greater than or equal to METEORSETGEO width (cols)
	 y_size must be greater than or equal to METEORSETGEO height (rows)
	YUV12 - Even Only (or Odd Only) mode
	 x_size must be greater than or equal to METEORSETGEO width (cols)
	 y_size must be greater than or equal to 2*METEORSETGEO height (rows)
	*/

	case BT848_SCAPAREA: /* set capture area of each video frame */
		/* can't change parameters while capturing */
		if (bktr->flags & METEOR_CAP_MASK)
			return( EBUSY );

		cap_area = (struct bktr_capture_area *) arg;
		bktr->capture_area_x_offset = cap_area->x_offset;
		bktr->capture_area_y_offset = cap_area->y_offset;
		bktr->capture_area_x_size   = cap_area->x_size;
		bktr->capture_area_y_size   = cap_area->y_size;
		bktr->capture_area_enabled  = TRUE;

		bktr->dma_prog_loaded = FALSE;
		break;

	case BT848_GCAPAREA: /* get capture area of each video frame */
		cap_area = (struct bktr_capture_area *) arg;
		if (bktr->capture_area_enabled == FALSE) {
			cap_area->x_offset = 0;
			cap_area->y_offset = 0;
			cap_area->x_size   = format_params[
				bktr->format_params].scaled_hactive;
			cap_area->y_size   = format_params[
				bktr->format_params].vactive;
		} else {
			cap_area->x_offset = bktr->capture_area_x_offset;
			cap_area->y_offset = bktr->capture_area_y_offset;
			cap_area->x_size   = bktr->capture_area_x_size;
			cap_area->y_size   = bktr->capture_area_y_size;
		}
		break;

	default:
		return bktr_common_ioctl( bktr, cmd, arg );
	}

	return( 0 );
}

/*
 * tuner ioctls
 */
int
tuner_ioctl( bktr_ptr_t bktr, int unit, ioctl_cmd_t cmd, caddr_t arg, struct proc* pr )
{
	int		tmp_int;
	unsigned int	temp, temp1;
	int		offset;
	int		count;
	u_char		*buf;
	u_int		par;
	u_char		write;
	int		i2c_addr;
	int		i2c_port;
	u_int		data;

	switch ( cmd ) {

	case REMOTE_GETKEY:
		/* Read the last key pressed by the Remote Control */
		if (bktr->remote_control == 0) return (EINVAL);
		remote_read(bktr, (struct bktr_remote *)arg);
		break;

#if defined(TUNER_AFC)
	case TVTUNER_SETAFC:
		bktr->tuner.afc = (*(int *)arg != 0);
		break;

	case TVTUNER_GETAFC:
		*(int *)arg = bktr->tuner.afc;
		/* XXX Perhaps use another bit to indicate AFC success? */
		break;
#endif /* TUNER_AFC */

	case TVTUNER_SETCHNL:
		temp_mute( bktr, TRUE );
		tmp_int = tv_channel( bktr, (int)*(unsigned int *)arg );
		if ( tmp_int < 0 ) {
			temp_mute( bktr, FALSE );
			return( EINVAL );
		}
		*(unsigned int *)arg = tmp_int;

		/* after every channel change, we must restart the MSP34xx */
		/* audio chip to reselect NICAM STEREO or MONO audio */
		if ( bktr->card.msp3400c )
		  msp_autodetect( bktr );

		/* after every channel change, we must restart the DPL35xx */
		if ( bktr->card.dpl3518a )
		  dpl_autodetect( bktr );

		temp_mute( bktr, FALSE );
		break;

	case TVTUNER_GETCHNL:
		*(unsigned int *)arg = bktr->tuner.channel;
		break;

	case TVTUNER_SETTYPE:
		temp = *(unsigned int *)arg;
		if ( (temp < CHNLSET_MIN) || (temp > CHNLSET_MAX) )
			return( EINVAL );
		bktr->tuner.chnlset = temp;
		break;

	case TVTUNER_GETTYPE:
		*(unsigned int *)arg = bktr->tuner.chnlset;
		break;

	case TVTUNER_GETSTATUS:
		temp = get_tuner_status( bktr );
		*(unsigned int *)arg = temp & 0xff;
		break;

	case TVTUNER_SETFREQ:
		temp_mute( bktr, TRUE );
		tmp_int = tv_freq( bktr, (int)*(unsigned int *)arg, TV_FREQUENCY);
		temp_mute( bktr, FALSE );
		if ( tmp_int < 0 ) {
			temp_mute( bktr, FALSE );
			return( EINVAL );
		}
		*(unsigned int *)arg = tmp_int;

		/* after every channel change, we must restart the MSP34xx */
		/* audio chip to reselect NICAM STEREO or MONO audio */
		if ( bktr->card.msp3400c )
		  msp_autodetect( bktr );

		/* after every channel change, we must restart the DPL35xx */
		if ( bktr->card.dpl3518a )
		  dpl_autodetect( bktr );

		temp_mute( bktr, FALSE );
		break;

	case TVTUNER_GETFREQ:
		*(unsigned int *)arg = bktr->tuner.frequency;
		break;

	case TVTUNER_GETCHNLSET:
		return tuner_getchnlset((struct bktr_chnlset *)arg);

	case BT848_SAUDIO:	/* set audio channel */
		if ( set_audio( bktr, *(int *)arg ) < 0 )
			return( EIO );
		break;

	/* hue is a 2's compliment number, -90' to +89.3' in 0.7' steps */
	case BT848_SHUE:	/* set hue */
		OUTB(bktr, BKTR_HUE, (u_char)(*(int *)arg & 0xff));
		break;

	case BT848_GHUE:	/* get hue */
		*(int *)arg = (signed char)(INB(bktr, BKTR_HUE) & 0xff);
		break;

	/* brightness is a 2's compliment #, -50 to +%49.6% in 0.39% steps */
	case BT848_SBRIG:	/* set brightness */
		OUTB(bktr, BKTR_BRIGHT, (u_char)(*(int *)arg & 0xff));
		break;

	case BT848_GBRIG:	/* get brightness */
		*(int *)arg = (signed char)(INB(bktr, BKTR_BRIGHT) & 0xff);
		break;

	/*  */
	case BT848_SCSAT:	/* set chroma saturation */
		tmp_int = *(int *)arg;

		temp = INB(bktr, BKTR_E_CONTROL);
		temp1 = INB(bktr, BKTR_O_CONTROL);
		if ( tmp_int & BIT_EIGHT_HIGH ) {
			temp |= (BT848_E_CONTROL_SAT_U_MSB |
				 BT848_E_CONTROL_SAT_V_MSB);
			temp1 |= (BT848_O_CONTROL_SAT_U_MSB |
				  BT848_O_CONTROL_SAT_V_MSB);
		}
		else {
			temp &= ~(BT848_E_CONTROL_SAT_U_MSB |
				  BT848_E_CONTROL_SAT_V_MSB);
			temp1 &= ~(BT848_O_CONTROL_SAT_U_MSB |
				   BT848_O_CONTROL_SAT_V_MSB);
		}

		OUTB(bktr, BKTR_SAT_U_LO, (u_char)(tmp_int & 0xff));
		OUTB(bktr, BKTR_SAT_V_LO, (u_char)(tmp_int & 0xff));
		OUTB(bktr, BKTR_E_CONTROL, temp);
		OUTB(bktr, BKTR_O_CONTROL, temp1);
		break;

	case BT848_GCSAT:	/* get chroma saturation */
		tmp_int = (int)(INB(bktr, BKTR_SAT_V_LO) & 0xff);
		if ( INB(bktr, BKTR_E_CONTROL) & BT848_E_CONTROL_SAT_V_MSB )
			tmp_int |= BIT_EIGHT_HIGH;
		*(int *)arg = tmp_int;
		break;

	/*  */
	case BT848_SVSAT:	/* set chroma V saturation */
		tmp_int = *(int *)arg;

		temp = INB(bktr, BKTR_E_CONTROL);
		temp1 = INB(bktr, BKTR_O_CONTROL);
		if ( tmp_int & BIT_EIGHT_HIGH) {
			temp |= BT848_E_CONTROL_SAT_V_MSB;
			temp1 |= BT848_O_CONTROL_SAT_V_MSB;
		}
		else {
			temp &= ~BT848_E_CONTROL_SAT_V_MSB;
			temp1 &= ~BT848_O_CONTROL_SAT_V_MSB;
		}

		OUTB(bktr, BKTR_SAT_V_LO, (u_char)(tmp_int & 0xff));
		OUTB(bktr, BKTR_E_CONTROL, temp);
		OUTB(bktr, BKTR_O_CONTROL, temp1);
		break;

	case BT848_GVSAT:	/* get chroma V saturation */
		tmp_int = (int)INB(bktr, BKTR_SAT_V_LO) & 0xff;
		if ( INB(bktr, BKTR_E_CONTROL) & BT848_E_CONTROL_SAT_V_MSB )
			tmp_int |= BIT_EIGHT_HIGH;
		*(int *)arg = tmp_int;
		break;

	/*  */
	case BT848_SUSAT:	/* set chroma U saturation */
		tmp_int = *(int *)arg;

		temp = INB(bktr, BKTR_E_CONTROL);
		temp1 = INB(bktr, BKTR_O_CONTROL);
		if ( tmp_int & BIT_EIGHT_HIGH ) {
			temp |= BT848_E_CONTROL_SAT_U_MSB;
			temp1 |= BT848_O_CONTROL_SAT_U_MSB;
		}
		else {
			temp &= ~BT848_E_CONTROL_SAT_U_MSB;
			temp1 &= ~BT848_O_CONTROL_SAT_U_MSB;
		}

		OUTB(bktr, BKTR_SAT_U_LO, (u_char)(tmp_int & 0xff));
		OUTB(bktr, BKTR_E_CONTROL, temp);
		OUTB(bktr, BKTR_O_CONTROL, temp1);
		break;

	case BT848_GUSAT:	/* get chroma U saturation */
		tmp_int = (int)INB(bktr, BKTR_SAT_U_LO) & 0xff;
		if ( INB(bktr, BKTR_E_CONTROL) & BT848_E_CONTROL_SAT_U_MSB )
			tmp_int |= BIT_EIGHT_HIGH;
		*(int *)arg = tmp_int;
		break;

/* lr 970528 luma notch etc - 3 high bits of e_control/o_control */

	case BT848_SLNOTCH:	/* set luma notch */
		tmp_int = (*(int *)arg & 0x7) << 5 ;
		OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) & ~0xe0);
		OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL) & ~0xe0);
		OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) | tmp_int);
		OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL) | tmp_int);
		break;

	case BT848_GLNOTCH:	/* get luma notch */
		*(int *)arg = (int) ( (INB(bktr, BKTR_E_CONTROL) & 0xe0) >> 5) ;
		break;


	/*  */
	case BT848_SCONT:	/* set contrast */
		tmp_int = *(int *)arg;

		temp = INB(bktr, BKTR_E_CONTROL);
		temp1 = INB(bktr, BKTR_O_CONTROL);
		if ( tmp_int & BIT_EIGHT_HIGH ) {
			temp |= BT848_E_CONTROL_CON_MSB;
			temp1 |= BT848_O_CONTROL_CON_MSB;
		}
		else {
			temp &= ~BT848_E_CONTROL_CON_MSB;
			temp1 &= ~BT848_O_CONTROL_CON_MSB;
		}

		OUTB(bktr, BKTR_CONTRAST_LO, (u_char)(tmp_int & 0xff));
		OUTB(bktr, BKTR_E_CONTROL, temp);
		OUTB(bktr, BKTR_O_CONTROL, temp1);
		break;

	case BT848_GCONT:	/* get contrast */
		tmp_int = (int)INB(bktr, BKTR_CONTRAST_LO) & 0xff;
		if ( INB(bktr, BKTR_E_CONTROL) & BT848_E_CONTROL_CON_MSB )
			tmp_int |= BIT_EIGHT_HIGH;
		*(int *)arg = tmp_int;
		break;

		/*  FIXME:  SCBARS and CCBARS require a valid int *        */
		/*    argument to succeed, but its not used; consider      */
		/*    using the arg to store the on/off state so           */
		/*    there's only one ioctl() needed to turn cbars on/off */
	case BT848_SCBARS:	/* set colorbar output */
		OUTB(bktr, BKTR_COLOR_CTL, INB(bktr, BKTR_COLOR_CTL) | BT848_COLOR_CTL_COLOR_BARS);
		break;

	case BT848_CCBARS:	/* clear colorbar output */
		OUTB(bktr, BKTR_COLOR_CTL, INB(bktr, BKTR_COLOR_CTL) & ~(BT848_COLOR_CTL_COLOR_BARS));
		break;

	case BT848_GAUDIO:	/* get audio channel */
		temp = bktr->audio_mux_select;
		if ( bktr->audio_mute_state == TRUE )
			temp |= AUDIO_MUTE;
		*(int *)arg = temp;
		break;

	case BT848_SBTSC:	/* set audio channel */
		if ( set_BTSC( bktr, *(int *)arg ) < 0 )
			return( EIO );
		break;

	case BT848_WEEPROM:	/* write eeprom */
		offset = (((struct eeProm *)arg)->offset);
		count = (((struct eeProm *)arg)->count);
		buf = &(((struct eeProm *)arg)->bytes[ 0 ]);
		if ( writeEEProm( bktr, offset, count, buf ) < 0 )
			return( EIO );
		break;

	case BT848_REEPROM:	/* read eeprom */
		offset = (((struct eeProm *)arg)->offset);
		count = (((struct eeProm *)arg)->count);
		buf = &(((struct eeProm *)arg)->bytes[ 0 ]);
		if ( readEEProm( bktr, offset, count, buf ) < 0 )
			return( EIO );
		break;

	case BT848_SIGNATURE:
		offset = (((struct eeProm *)arg)->offset);
		count = (((struct eeProm *)arg)->count);
		buf = &(((struct eeProm *)arg)->bytes[ 0 ]);
		if ( signCard( bktr, offset, count, buf ) < 0 )
			return( EIO );
		break;

        /* Ioctl's for direct gpio access */
#ifdef BKTR_GPIO_ACCESS
        case BT848_GPIO_GET_EN:
                *(int *)arg = INL(bktr, BKTR_GPIO_OUT_EN);
                break;

        case BT848_GPIO_SET_EN:
                OUTL(bktr, BKTR_GPIO_OUT_EN, *(int *)arg);
                break;

        case BT848_GPIO_GET_DATA:
                *(int *)arg = INL(bktr, BKTR_GPIO_DATA);
                break;

        case BT848_GPIO_SET_DATA:
                OUTL(bktr, BKTR_GPIO_DATA, *(int *)arg);
                break;
#endif /* BKTR_GPIO_ACCESS */

	/* Ioctl's for running the tuner device in radio mode		*/

	case RADIO_GETMODE:
            *(unsigned char *)arg = bktr->tuner.radio_mode;
	    break;

	case RADIO_SETMODE:
            bktr->tuner.radio_mode = *(unsigned char *)arg;
            break;

	case RADIO_GETFREQ:
            *(unsigned long *)arg = bktr->tuner.frequency;
            break;

	case RADIO_SETFREQ:
	    /* The argument to this ioctl is NOT freq*16. It is
	    ** freq*100.
	    */

            temp=(int)*(unsigned long *)arg;

#ifdef BKTR_RADIO_DEBUG
	    printf("%s: arg=%d temp=%d\n", bktr_name(bktr),
		   (int)*(unsigned long *)arg, temp);
#endif

#ifndef BKTR_RADIO_NOFREQCHECK
	    /* According to the spec. sheet the band: 87.5MHz-108MHz	*/
	    /* is supported.						*/
	    if(temp<8750 || temp>10800) {
	      printf("%s: Radio frequency out of range\n", bktr_name(bktr));
	      return(EINVAL);
	      }
#endif
	    temp_mute( bktr, TRUE );
	    tmp_int = tv_freq( bktr, temp, FM_RADIO_FREQUENCY );
	    temp_mute( bktr, FALSE );
#ifdef BKTR_RADIO_DEBUG
  if(tmp_int)
    printf("%s: tv_freq returned: %d\n", bktr_name(bktr), tmp_int);
#endif
	    if ( tmp_int < 0 )
		    return( EINVAL );
	    *(unsigned long *)arg = tmp_int;
	    break;

	/* Luigi's I2CWR ioctl */
	case BT848_I2CWR:
		par = *(u_int *)arg;
		write = (par >> 24) & 0xff ;
		i2c_addr = (par >> 16) & 0xff ;
		i2c_port = (par >> 8) & 0xff ;
		data = (par) & 0xff ;

		if (write) {
			i2cWrite( bktr, i2c_addr, i2c_port, data);
		} else {
			data = i2cRead( bktr, i2c_addr);
		}
		*(u_int *)arg = (par & 0xffffff00) | ( data & 0xff );
		break;


#ifdef BT848_MSP_READ
	/* I2C ioctls to allow userland access to the MSP chip */
	case BT848_MSP_READ:
		{
		struct bktr_msp_control *msp;
		msp = (struct bktr_msp_control *) arg;
		msp->data = msp_dpl_read(bktr, bktr->msp_addr,
		                         msp->function, msp->address);
		break;
		}

	case BT848_MSP_WRITE:
		{
		struct bktr_msp_control *msp;
		msp = (struct bktr_msp_control *) arg;
		msp_dpl_write(bktr, bktr->msp_addr, msp->function,
		             msp->address, msp->data );
		break;
		}

	case BT848_MSP_RESET:
		msp_dpl_reset(bktr, bktr->msp_addr);
		break;
#endif

	default:
		return bktr_common_ioctl( bktr, cmd, arg );
	}

	return( 0 );
}


/*
 * common ioctls
 */
int
bktr_common_ioctl( bktr_ptr_t bktr, ioctl_cmd_t cmd, caddr_t arg )
{
	int                           pixfmt;
	struct meteor_pixfmt          *pf_pub;

#if defined( STATUS_SUM )
	unsigned int                  temp;
#endif

	switch (cmd) {

	case METEORSINPUT:	/* set input device */
		/*Bt848 has 3 MUX Inputs. Bt848A/849A/878/879 has 4 MUX Inputs*/
		/* On the original bt848 boards, */
		/*   Tuner is MUX0, RCA is MUX1, S-Video is MUX2 */
		/* On the Hauppauge bt878 boards, */
		/*   Tuner is MUX0, RCA is MUX3 */
		/* Unfortunatly Meteor driver codes DEV_RCA as DEV_0, so we */
		/* stick with this system in our Meteor Emulation */

		switch(*(unsigned int *)arg & METEOR_DEV_MASK) {

		/* this is the RCA video input */
		case 0:		/* default */
		case METEOR_INPUT_DEV0:
		  /* METEOR_INPUT_DEV_RCA: */
		        bktr->flags = (bktr->flags & ~METEOR_DEV_MASK)
			  | METEOR_DEV0;
			OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM)
			                 & ~BT848_IFORM_MUXSEL);

			/* work around for new Hauppauge 878 cards */
			if ((bktr->card.card_id == CARD_HAUPPAUGE) &&
				(bktr->id==BROOKTREE_878 ||
				 bktr->id==BROOKTREE_879) )
				OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | BT848_IFORM_M_MUX3);
			else
				OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | BT848_IFORM_M_MUX1);

			OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) & ~BT848_E_CONTROL_COMP);
			OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL) & ~BT848_O_CONTROL_COMP);
			set_audio( bktr, AUDIO_EXTERN );
			break;

		/* this is the tuner input */
		case METEOR_INPUT_DEV1:
			bktr->flags = (bktr->flags & ~METEOR_DEV_MASK)
				| METEOR_DEV1;
			OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) & ~BT848_IFORM_MUXSEL);
			OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | BT848_IFORM_M_MUX0);
			OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) & ~BT848_E_CONTROL_COMP);
			OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL) & ~BT848_O_CONTROL_COMP);
			set_audio( bktr, AUDIO_TUNER );
			break;

		/* this is the S-VHS input, but with a composite camera */
		case METEOR_INPUT_DEV2:
			bktr->flags = (bktr->flags & ~METEOR_DEV_MASK)
				| METEOR_DEV2;
			OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) & ~BT848_IFORM_MUXSEL);
			OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | BT848_IFORM_M_MUX2);
			OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) & ~BT848_E_CONTROL_COMP);
			OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_E_CONTROL) & ~BT848_O_CONTROL_COMP);
			set_audio( bktr, AUDIO_EXTERN );
			break;

		/* this is the S-VHS input */
		case METEOR_INPUT_DEV_SVIDEO:
			bktr->flags = (bktr->flags & ~METEOR_DEV_MASK)
				| METEOR_DEV_SVIDEO;
			OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) & ~BT848_IFORM_MUXSEL);
			OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | BT848_IFORM_M_MUX2);
			OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) | BT848_E_CONTROL_COMP);
			OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL) | BT848_O_CONTROL_COMP);
			set_audio( bktr, AUDIO_EXTERN );
			break;

		case METEOR_INPUT_DEV3:
		  if ((bktr->id == BROOKTREE_848A) ||
		      (bktr->id == BROOKTREE_849A) ||
		      (bktr->id == BROOKTREE_878) ||
		      (bktr->id == BROOKTREE_879) ) {
			bktr->flags = (bktr->flags & ~METEOR_DEV_MASK)
				| METEOR_DEV3;
			OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) & ~BT848_IFORM_MUXSEL);

			/* work around for new Hauppauge 878 cards */
			if ((bktr->card.card_id == CARD_HAUPPAUGE) &&
				(bktr->id==BROOKTREE_878 ||
				 bktr->id==BROOKTREE_879) )
				OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | BT848_IFORM_M_MUX1);
			else
				OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | BT848_IFORM_M_MUX3);

			OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) & ~BT848_E_CONTROL_COMP);
			OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL) & ~BT848_O_CONTROL_COMP);
			set_audio( bktr, AUDIO_EXTERN );

			break;
		  }

		default:
			return( EINVAL );
		}
		break;

	case METEORGINPUT:	/* get input device */
		*(u_int *)arg = bktr->flags & METEOR_DEV_MASK;
		break;

	case METEORSACTPIXFMT:
		if (( *(int *)arg < 0 ) ||
		    ( *(int *)arg >= PIXFMT_TABLE_SIZE ))
			return( EINVAL );

		bktr->pixfmt          = *(int *)arg;
		OUTB(bktr, BKTR_COLOR_CTL, (INB(bktr, BKTR_COLOR_CTL) & 0xf0)
		     | pixfmt_swap_flags( bktr->pixfmt ));
		bktr->pixfmt_compat   = FALSE;
		break;

	case METEORGACTPIXFMT:
		*(int *)arg = bktr->pixfmt;
		break;

	case METEORGSUPPIXFMT :
		pf_pub = (struct meteor_pixfmt *)arg;
		pixfmt = pf_pub->index;

		if (( pixfmt < 0 ) || ( pixfmt >= PIXFMT_TABLE_SIZE ))
			return( EINVAL );

		memcpy( pf_pub, &pixfmt_table[ pixfmt ].public,
			sizeof( *pf_pub ) );

		/*  Patch in our format index  */
		pf_pub->index       = pixfmt;
		break;

#if defined( STATUS_SUM )
	case BT848_GSTATUS:	/* reap status */
		{
                DECLARE_INTR_MASK(s);
		DISABLE_INTR(s);
		temp = status_sum;
		status_sum = 0;
		ENABLE_INTR(s);
		*(u_int *)arg = temp;
		break;
		}
#endif /* STATUS_SUM */

	default:
		return( ENOTTY );
	}

	return( 0 );
}




/******************************************************************************
 * bt848 RISC programming routines:
 */


/*
 *
 */
#ifdef BT848_DEBUG
static int
dump_bt848( bktr_ptr_t bktr )
{
	int	r[60]={
			   4,    8, 0xc, 0x8c, 0x10, 0x90, 0x14, 0x94,
			0x18, 0x98, 0x1c, 0x9c, 0x20, 0xa0, 0x24, 0xa4,
			0x28, 0x2c, 0xac, 0x30, 0x34, 0x38, 0x3c, 0x40,
			0xc0, 0x48, 0x4c, 0xcc, 0x50, 0xd0, 0xd4, 0x60,
			0x64, 0x68, 0x6c, 0xec, 0xd8, 0xdc, 0xe0, 0xe4,
			0,	 0,    0,    0
		   };
	int	i;

	for (i = 0; i < 40; i+=4) {
		printf("%s: Reg:value : \t%x:%x \t%x:%x \t %x:%x \t %x:%x\n",
		       bktr_name(bktr),
		       r[i], INL(bktr, r[i]),
		       r[i+1], INL(bktr, r[i+1]),
		       r[i+2], INL(bktr, r[i+2]),
		       r[i+3], INL(bktr, r[i+3]));
	}

	printf("%s: INT STAT %x \n", bktr_name(bktr),
	       INL(bktr, BKTR_INT_STAT));
	printf("%s: Reg INT_MASK %x \n", bktr_name(bktr),
	       INL(bktr, BKTR_INT_MASK));
	printf("%s: Reg GPIO_DMA_CTL %x \n", bktr_name(bktr),
	       INW(bktr, BKTR_GPIO_DMA_CTL));

	return( 0 );
}

#endif

/*
 * build write instruction
 */
#define BKTR_FM1      0x6	/* packed data to follow */
#define BKTR_FM3      0xe	/* planar data to follow */
#define BKTR_VRE      0x4	/* Marks the end of the even field */
#define BKTR_VRO      0xC	/* Marks the end of the odd field */
#define BKTR_PXV      0x0	/* valid word (never used) */
#define BKTR_EOL      0x1	/* last dword, 4 bytes */
#define BKTR_SOL      0x2	/* first dword */

#define OP_WRITE      (0x1 << 28)
#define OP_SKIP       (0x2 << 28)
#define OP_WRITEC     (0x5 << 28)
#define OP_JUMP	      (0x7 << 28)
#define OP_SYNC	      (0x8 << 28)
#define OP_WRITE123   (0x9 << 28)
#define OP_WRITES123  (0xb << 28)
#define OP_SOL	      (1 << 27)		/* first instr for scanline */
#define OP_EOL	      (1 << 26)

#define BKTR_RESYNC   (1 << 15)
#define BKTR_GEN_IRQ  (1 << 24)

/*
 * The RISC status bits can be set/cleared in the RISC programs
 * and tested in the Interrupt Handler
 */
#define BKTR_SET_RISC_STATUS_BIT0 (1 << 16)
#define BKTR_SET_RISC_STATUS_BIT1 (1 << 17)
#define BKTR_SET_RISC_STATUS_BIT2 (1 << 18)
#define BKTR_SET_RISC_STATUS_BIT3 (1 << 19)

#define BKTR_CLEAR_RISC_STATUS_BIT0 (1 << 20)
#define BKTR_CLEAR_RISC_STATUS_BIT1 (1 << 21)
#define BKTR_CLEAR_RISC_STATUS_BIT2 (1 << 22)
#define BKTR_CLEAR_RISC_STATUS_BIT3 (1 << 23)

#define BKTR_TEST_RISC_STATUS_BIT0 (1U << 28)
#define BKTR_TEST_RISC_STATUS_BIT1 (1U << 29)
#define BKTR_TEST_RISC_STATUS_BIT2 (1U << 30)
#define BKTR_TEST_RISC_STATUS_BIT3 (1U << 31)

static bool_t
notclipped (bktr_reg_t * bktr, int x, int width) {
    int i;
    bktr_clip_t * clip_node;
    bktr->clip_start = -1;
    bktr->last_y = 0;
    bktr->y = 0;
    bktr->y2 = width;
    bktr->line_length = width;
    bktr->yclip = -1;
    bktr->yclip2 = -1;
    bktr->current_col = 0;

    if (bktr->max_clip_node == 0 ) return TRUE;
    clip_node = (bktr_clip_t *) &bktr->clip_list[0];


    for (i = 0; i < bktr->max_clip_node; i++ ) {
	clip_node = (bktr_clip_t *) &bktr->clip_list[i];
	if (x >= clip_node->x_min && x <= clip_node->x_max  ) {
	    bktr->clip_start = i;
	    return FALSE;
	}
    }

    return TRUE;
}

static bool_t
getline(bktr_reg_t *bktr, int x ) {
    int i, j;
    bktr_clip_t * clip_node ;

    if (bktr->line_length == 0 ||
	bktr->current_col >= bktr->line_length) return FALSE;

    bktr->y = min(bktr->last_y, bktr->line_length);
    bktr->y2 = bktr->line_length;

    bktr->yclip = bktr->yclip2 = -1;
    for (i = bktr->clip_start; i < bktr->max_clip_node; i++ ) {
	clip_node = (bktr_clip_t *) &bktr->clip_list[i];
	if (x >= clip_node->x_min && x <= clip_node->x_max) {
	    if (bktr->last_y <= clip_node->y_min) {
		bktr->y =      min(bktr->last_y, bktr->line_length);
		bktr->y2 =     min(clip_node->y_min, bktr->line_length);
		bktr->yclip =  min(clip_node->y_min, bktr->line_length);
		bktr->yclip2 = min(clip_node->y_max, bktr->line_length);
		bktr->last_y = bktr->yclip2;
		bktr->clip_start = i;

		for (j = i+1; j  < bktr->max_clip_node; j++ ) {
		    clip_node = (bktr_clip_t *) &bktr->clip_list[j];
		    if (x >= clip_node->x_min && x <= clip_node->x_max) {
			if (bktr->last_y >= clip_node->y_min) {
			    bktr->yclip2 = min(clip_node->y_max, bktr->line_length);
			    bktr->last_y = bktr->yclip2;
			    bktr->clip_start = j;
			}
		    } else break  ;
		}
		return TRUE;
	    }
	}
    }

    if (bktr->current_col <= bktr->line_length) {
	bktr->current_col = bktr->line_length;
	return TRUE;
    }
    return FALSE;
}

static bool_t
split(bktr_reg_t *bktr, u_int **dma_prog, int width, u_int operation,
    int pixel_width, u_int *target_buffer, int cols)
{

 u_int flag, flag2;
 const struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;
 u_int  skip, start_skip;

  /*  For RGB24, we need to align the component in FIFO Byte Lane 0         */
  /*    to the 1st byte in the mem dword containing our start addr.         */
  /*    BTW, we know this pixfmt's 1st byte is Blue; thus the start addr    */
  /*     must be Blue.                                                      */
  start_skip = 0;
  if (( pf->type == METEOR_PIXTYPE_RGB ) && ( pf->Bpp == 3 ))
	  switch ((*target_buffer) % 4) {
	  case 2 : start_skip = 4 ; break;
	  case 1 : start_skip = 8 ; break;
	  }

 if ((width * pixel_width) < DMA_BT848_SPLIT ) {
     if (  width == cols) {
	 flag = OP_SOL | OP_EOL;
       } else if (bktr->current_col == 0 ) {
	    flag  = OP_SOL;
       } else if (bktr->current_col == cols) {
	    flag = OP_EOL;
       } else flag = 0;

     skip = 0;
     if (( flag & OP_SOL ) && ( start_skip > 0 )) {
	     *(*dma_prog)++ = htole32(OP_SKIP | OP_SOL | start_skip);
	     flag &= ~OP_SOL;
	     skip = start_skip;
     }

     *(*dma_prog)++ = htole32(operation | flag  | (width * pixel_width - skip));
     if (operation != OP_SKIP )
	 *(*dma_prog)++ = htole32(*target_buffer);

     *target_buffer += width * pixel_width;
     bktr->current_col += width;

 } else {

	if (bktr->current_col == 0 && width == cols) {
	    flag = OP_SOL ;
	    flag2 = OP_EOL;
        } else if (bktr->current_col == 0 ) {
	    flag = OP_SOL;
	    flag2 = 0;
	} else if (bktr->current_col >= cols)  {
	    flag =  0;
	    flag2 = OP_EOL;
	} else {
	    flag =  0;
	    flag2 = 0;
	}

	skip = 0;
	if (( flag & OP_SOL ) && ( start_skip > 0 )) {
		*(*dma_prog)++ = htole32(OP_SKIP | OP_SOL | start_skip);
		flag &= ~OP_SOL;
		skip = start_skip;
	}

	*(*dma_prog)++ = htole32(operation | flag |
	      (width * pixel_width / 2 - skip));
	if (operation != OP_SKIP )
	      *(*dma_prog)++ = htole32(*target_buffer);
	*target_buffer += width * pixel_width / 2;

	if ( operation == OP_WRITE )
		operation = OP_WRITEC;
	*(*dma_prog)++ = htole32(operation | flag2 |
	    (width * pixel_width / 2));
	*target_buffer += width * pixel_width / 2;
	bktr->current_col += width;

    }

    return TRUE;
}


/*
 * Generate the RISC instructions to capture both VBI and video images
 */
static void
rgb_vbi_prog(bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )
{
	int		i;
	u_int		target_buffer, buffer, target, width;
	u_int		pitch;
	u_int		*dma_prog;	/* DMA prog is an array of
					   32 bit RISC instructions */
	u_int		*loop_point;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
	u_int		Bpp = pf_int->public.Bpp;
	unsigned int	vbisamples;     /* VBI samples per line */
	unsigned int	vbilines;       /* VBI lines per field */
	unsigned int	num_dwords;     /* DWORDS per line */

	vbisamples = format_params[bktr->format_params].vbi_num_samples;
	vbilines   = format_params[bktr->format_params].vbi_num_lines;
	num_dwords = vbisamples/4;

	OUTB(bktr, BKTR_COLOR_FMT, pf_int->color_fmt);
	OUTB(bktr, BKTR_ADC, SYNC_LEVEL);
	OUTB(bktr, BKTR_VBI_PACK_SIZE, ((num_dwords)) & 0xff);
	OUTB(bktr, BKTR_VBI_PACK_DEL, ((num_dwords)>> 8) & 0x01); /* no hdelay    */
							    /* no ext frame */

	OUTB(bktr, BKTR_OFORM, 0x00);

	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) & ~0x80); /* clear Ycomb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) & ~0x80);

	/* disable gamma correction removal */
	OUTB(bktr, BKTR_COLOR_CTL, INB(bktr, BKTR_COLOR_CTL) | BT848_COLOR_CTL_GAMMA);

	if (cols > 385 ) {
	    OUTB(bktr, BKTR_E_VTC, 0);
	    OUTB(bktr, BKTR_O_VTC, 0);
	} else {
	    OUTB(bktr, BKTR_E_VTC, 1);
	    OUTB(bktr, BKTR_O_VTC, 1);
	}
	bktr->capcontrol = 3 << 2 |  3;

	dma_prog = (u_int *) bktr->dma_prog;

	/* Construct Write */

	if (bktr->video.addr) {
		target_buffer = bktr->video.addr;
		pitch = bktr->video.width;
	}
	else {
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
		pitch = cols*Bpp;
	}

	buffer = target_buffer;

	/* Wait for the VRE sync marking the end of the Even and
	 * the start of the Odd field. Resync here.
	 */
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC |BKTR_VRE);
	*dma_prog++ = htole32(0);

	loop_point = dma_prog;

	/* store the VBI data */
	/* look for sync with packed data */
	*dma_prog++ = htole32(OP_SYNC | BKTR_FM1);
	*dma_prog++ = htole32(0);
	for(i = 0; i < vbilines; i++) {
		*dma_prog++ = htole32(OP_WRITE | OP_SOL | OP_EOL | vbisamples);
		*dma_prog++ = htole32(bktr->dm_vbidata->dm_segs->ds_addr +
					(i * VBI_LINE_SIZE));
	}

	if ( (i_flag == 2/*Odd*/) || (i_flag==3) /*interlaced*/ ) {
		/* store the Odd field video image */
		/* look for sync with packed data */
		*dma_prog++ = htole32(OP_SYNC  | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		width = cols;
		for (i = 0; i < (rows/interlace); i++) {
		    target = target_buffer;
		    if ( notclipped(bktr, i, width)) {
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, &target, cols);

		    } else {
			while(getline(bktr, i)) {
			    if (bktr->y != bktr->y2 ) {
				split(bktr, &dma_prog, bktr->y2 - bktr->y,
				    OP_WRITE, Bpp, &target, cols);
			    }
			    if (bktr->yclip != bktr->yclip2 ) {
				split(bktr, &dma_prog, bktr->yclip2 -
				    bktr->yclip, OP_SKIP, Bpp, &target, cols);
			    }
			}
		    }

		    target_buffer += interlace * pitch;
		}

	} /* end if */

	/* Grab the Even field */
	/* Look for the VRO, end of Odd field, marker */
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
	*dma_prog++ = htole32(0);  /* NULL WORD */

	/* store the VBI data */
	/* look for sync with packed data */
	*dma_prog++ = htole32(OP_SYNC | BKTR_FM1);
	*dma_prog++ = htole32(0);
	for(i = 0; i < vbilines; i++) {
		*dma_prog++ = htole32(OP_WRITE | OP_SOL | OP_EOL | vbisamples);
		*dma_prog++ = htole32(bktr->dm_vbidata->dm_segs->ds_addr +
				((i+MAX_VBI_LINES) * VBI_LINE_SIZE));
	}

	/* store the video image */
	if (i_flag == 1) /*Even Only*/
	        target_buffer = buffer;
	if (i_flag == 3) /*interlaced*/
	        target_buffer = buffer+pitch;


	if ((i_flag == 1) /*Even Only*/ || (i_flag==3) /*interlaced*/) {
		/* look for sync with packed data */
		*dma_prog++ = htole32(OP_SYNC | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		width = cols;
		for (i = 0; i < (rows/interlace); i++) {
		    target = target_buffer;
		    if ( notclipped(bktr, i, width)) {
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, &target,  cols);
		    } else {
			while(getline(bktr, i)) {
			    if (bktr->y != bktr->y2 ) {
				split(bktr, &dma_prog, bktr->y2 - bktr->y,
				    OP_WRITE, Bpp, &target, cols);
			    }
			    if (bktr->yclip != bktr->yclip2 ) {
				split(bktr, &dma_prog, bktr->yclip2 -
				    bktr->yclip, OP_SKIP, Bpp, &target, cols);
			    }
			}
		    }

		    target_buffer += interlace * pitch;
		}
	}

	/* Look for end of 'Even Field' */
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */

	*dma_prog++ = htole32(OP_JUMP);
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr +
	    ((char *)loop_point - (char *)bktr->dma_prog));
	*dma_prog++ = htole32(0);  /* NULL WORD */

}

static void
rgb_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )
{
	int		i;
	u_int		target_buffer, buffer, target,width;
	u_int		pitch;
	u_int		*dma_prog;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
	u_int                   Bpp = pf_int->public.Bpp;

	OUTB(bktr, BKTR_COLOR_FMT, pf_int->color_fmt);
	OUTB(bktr, BKTR_VBI_PACK_SIZE, 0);
	OUTB(bktr, BKTR_VBI_PACK_DEL, 0);
	OUTB(bktr, BKTR_ADC, SYNC_LEVEL);

	OUTB(bktr, BKTR_OFORM, 0x00);

	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) & ~0x80); /* clear Ycomb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) & ~0x80);

	/* disable gamma correction removal */
	OUTB(bktr, BKTR_COLOR_CTL, INB(bktr, BKTR_COLOR_CTL) | BT848_COLOR_CTL_GAMMA);

	if (cols > 385 ) {
	    OUTB(bktr, BKTR_E_VTC, 0);
	    OUTB(bktr, BKTR_O_VTC, 0);
	} else {
	    OUTB(bktr, BKTR_E_VTC, 1);
	    OUTB(bktr, BKTR_O_VTC, 1);
	}
	bktr->capcontrol = 3 << 2 |  3;

	dma_prog = (u_int *)bktr->dma_prog;

	/* Construct Write */

	if (bktr->video.addr) {
		target_buffer = (u_int) bktr->video.addr;
		pitch = bktr->video.width;
	}
	else {
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
		pitch = cols*Bpp;
	}

	buffer = target_buffer;

	/* construct sync : for video packet format */
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);

	/* sync, mode indicator packed data */
	*dma_prog++ = htole32(0);  /* NULL WORD */
	width = cols;
	for (i = 0; i < (rows/interlace); i++) {
	    target = target_buffer;
	    if ( notclipped(bktr, i, width)) {
		split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
		    Bpp, &target,  cols);

	    } else {
		while(getline(bktr, i)) {
		    if (bktr->y != bktr->y2 ) {
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, &target, cols);
		    }
		    if (bktr->yclip != bktr->yclip2 ) {
			split(bktr, &dma_prog, bktr->yclip2 - bktr->yclip,
			      OP_SKIP, Bpp, &target,  cols);
		    }
		}
	    }

	    target_buffer += interlace * pitch;
	}

	switch (i_flag) {
	case 1:
		/* sync vre */
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
		return;

	case 2:
		/* sync vro */
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE);
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
		return;

	case 3:
		/* sync vro */
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
		break;
	}

	if (interlace == 2) {

	        target_buffer = buffer + pitch;

		dma_prog = (u_int *) bktr->odd_dma_prog;

		/* sync vre IRQ bit */
		*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
                width = cols;
		for (i = 0; i < (rows/interlace); i++) {
		    target = target_buffer;
		    if ( notclipped(bktr, i, width)) {
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			    Bpp, &target,  cols);
		    } else {
			while(getline(bktr, i)) {
			    if (bktr->y != bktr->y2 ) {
				split(bktr, &dma_prog, bktr->y2 - bktr->y,
				    OP_WRITE, Bpp, &target, cols);
			    }
			    if (bktr->yclip != bktr->yclip2 ) {
				split(bktr, &dma_prog, bktr->yclip2 -
				    bktr->yclip, OP_SKIP, Bpp, &target, cols);
			    }
			}
		    }

		    target_buffer += interlace * pitch;
		}
	}

	/* sync vre IRQ bit */
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
	*dma_prog++ = htole32(0);  /* NULL WORD */
}


/*
 *
 */
static void
yuvpack_prog( bktr_ptr_t bktr, char i_flag,
	      int cols, int rows, int interlace )
{
	int			i;
	volatile unsigned int	inst;
	volatile unsigned int	inst3;
	volatile u_int		target_buffer, buffer;
	volatile u_int		*dma_prog;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
	int			b;

	OUTB(bktr, BKTR_COLOR_FMT, pf_int->color_fmt);

	OUTB(bktr, BKTR_E_SCLOOP, INB(bktr, BKTR_E_SCLOOP) | BT848_E_SCLOOP_CAGC); /* enable chroma comb */
	OUTB(bktr, BKTR_O_SCLOOP, INB(bktr, BKTR_O_SCLOOP) | BT848_O_SCLOOP_CAGC);

	OUTB(bktr, BKTR_COLOR_CTL, INB(bktr, BKTR_COLOR_CTL) | BT848_COLOR_CTL_RGB_DED | BT848_COLOR_CTL_GAMMA);
	OUTB(bktr, BKTR_ADC, SYNC_LEVEL);

	bktr->capcontrol =   1 << 6 | 1 << 4 | 1 << 2 | 3;
	bktr->capcontrol = 3 << 2 |  3;

	dma_prog = (u_int *) bktr->dma_prog;

	/* Construct Write */

	/* write , sol, eol */
	inst = OP_WRITE	 | OP_SOL | (cols);
	/* write , sol, eol */
	inst3 = OP_WRITE | OP_EOL | (cols);

	if (bktr->video.addr)
		target_buffer = bktr->video.addr;
	else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;

	buffer = target_buffer;

	/* contruct sync : for video packet format */
	/* sync, mode indicator packed data */
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);
	*dma_prog++ = htole32(0);  /* NULL WORD */

	b = cols;

	for (i = 0; i < (rows/interlace); i++) {
		*dma_prog++ = htole32(inst);
		*dma_prog++ = htole32(target_buffer);
		*dma_prog++ = htole32(inst3);
		*dma_prog++ = htole32(target_buffer + b);
		target_buffer += interlace*(cols * 2);
	}

	switch (i_flag) {
	case 1:
		/* sync vre */
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
		return;

	case 2:
		/* sync vro */
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
		return;

	case 3:
		/* sync vro */
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
		break;
	}

	if (interlace == 2) {

		target_buffer =	buffer + cols*2;

		dma_prog = (u_int * ) bktr->odd_dma_prog;

		/* sync vre */
		*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */

		for (i = 0; i < (rows/interlace) ; i++) {
			*dma_prog++ = htole32(inst);
			*dma_prog++ = htole32(target_buffer);
			*dma_prog++ = htole32(inst3);
			*dma_prog++ = htole32(target_buffer + b);
			target_buffer += interlace * ( cols*2);
		}
	}

	/* sync vro IRQ bit */
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);

	*dma_prog++ = htole32(OP_JUMP);
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
	*dma_prog++ = htole32(0);  /* NULL WORD */
}


/*
 *
 */
static void
yuv422_prog(bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace)
{
	int		i;
	u_int		inst;
	u_int		target_buffer, t1, buffer;
	u_int		*dma_prog;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];

	OUTB(bktr, BKTR_COLOR_FMT, pf_int->color_fmt);

	dma_prog = (u_int *) bktr->dma_prog;

	bktr->capcontrol =   1 << 6 | 1 << 4 |	3;

	OUTB(bktr, BKTR_ADC, SYNC_LEVEL);
	OUTB(bktr, BKTR_OFORM, 0x00);

	OUTB(bktr, BKTR_E_CONTROL, INB(bktr, BKTR_E_CONTROL) | BT848_E_CONTROL_LDEC); /* disable luma decimation */
	OUTB(bktr, BKTR_O_CONTROL, INB(bktr, BKTR_O_CONTROL) | BT848_O_CONTROL_LDEC);

	OUTB(bktr, BKTR_E_SCLOOP, INB(bktr, BKTR_E_SCLOOP) | BT848_E_SCLOOP_CAGC);	/* chroma agc enable */
	OUTB(bktr, BKTR_O_SCLOOP, INB(bktr, BKTR_O_SCLOOP) | BT848_O_SCLOOP_CAGC);

	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) & ~0x80); /* clear Ycomb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) & ~0x80);
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);

	/* disable gamma correction removal */
	OUTB(bktr, BKTR_COLOR_CTL, INB(bktr, BKTR_COLOR_CTL) | BT848_COLOR_CTL_GAMMA);

	/* Construct Write */
	inst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols);
	if (bktr->video.addr)
		target_buffer = (u_int) bktr->video.addr;
	else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;

	buffer = target_buffer;

	t1 = buffer;

	/* contruct sync : for video packet format */
	/*     sync, mode indicator packed data*/
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM3);
	*dma_prog++ = htole32(0);  /* NULL WORD */

	for (i = 0; i < (rows/interlace ) ; i++) {
		*dma_prog++ = htole32(inst);
		*dma_prog++ = htole32(cols/2 | cols/2 << 16);
		*dma_prog++ = htole32(target_buffer);
		*dma_prog++ = htole32(t1 + (cols*rows) + i*cols/2 * interlace);
		*dma_prog++ = htole32(t1 + (cols*rows) + (cols*rows/2) +
		    i*cols/2 * interlace);
		target_buffer += interlace*cols;
	}

	switch (i_flag) {
	case 1:
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE);  /*sync vre*/
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
		return;

	case 2:
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO);  /*sync vre*/
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
		return;

	case 3:
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
		break;
	}

	if (interlace == 2) {

		dma_prog = (u_int * ) bktr->odd_dma_prog;

		target_buffer  = (u_int) buffer + cols;
		t1 = buffer + cols/2;
		*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM3);
		*dma_prog++ = htole32(0);  /* NULL WORD */

		for (i = 0; i < (rows/interlace )  ; i++) {
			*dma_prog++ = htole32(inst);
			*dma_prog++ = htole32(cols/2 | cols/2 << 16);
			*dma_prog++ = htole32(target_buffer);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    i*cols/2 * interlace);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    (cols*rows/2) + i*cols/2 * interlace);
			target_buffer += interlace*cols;
		}
	}

	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
	*dma_prog++ = htole32(0);  /* NULL WORD */
}


/*
 *
 */
static void
yuv12_prog( bktr_ptr_t bktr, char i_flag,
	     int cols, int rows, int interlace ){

	int		i;
	u_int		inst;
	u_int		inst1;
	u_int		target_buffer, t1, buffer;
	u_int		*dma_prog;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];

	OUTB(bktr, BKTR_COLOR_FMT, pf_int->color_fmt);

	dma_prog = (u_int *) bktr->dma_prog;

	bktr->capcontrol =   1 << 6 | 1 << 4 |	3;

	OUTB(bktr, BKTR_ADC, SYNC_LEVEL);
	OUTB(bktr, BKTR_OFORM, 0x0);

	/* Construct Write */
	inst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols);
	inst1  = OP_WRITES123  | OP_SOL | OP_EOL |  (cols);
	if (bktr->video.addr)
		target_buffer = (u_int) bktr->video.addr;
	else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;

	buffer = target_buffer;
	t1 = buffer;

	/* sync, mode indicator packed data*/
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM3);
	*dma_prog++ = htole32(0);  /* NULL WORD */

	for (i = 0; i < (rows/interlace )/2 ; i++) {
		*dma_prog++ = htole32(inst);
		*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
		*dma_prog++ = htole32(target_buffer);
		*dma_prog++ = htole32(t1 + (cols*rows) + i*cols/2 * interlace);
		*dma_prog++ = htole32(t1 + (cols*rows) + (cols*rows/4) +
		    i*cols/2 * interlace);
		target_buffer += interlace*cols;
		*dma_prog++ = htole32(inst1);
		*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
		*dma_prog++ = htole32(target_buffer);
		target_buffer += interlace*cols;

	}

	switch (i_flag) {
	case 1:
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE);  /*sync vre*/
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
		return;

	case 2:
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO);  /*sync vro*/
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
		return;

	case 3:
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
		break;
	}

	if (interlace == 2) {

		dma_prog = (u_int *)bktr->odd_dma_prog;

		target_buffer  = (u_int) buffer + cols;
		t1 = buffer + cols/2;
		*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM3);
		*dma_prog++ = htole32(0);  /* NULL WORD */

		for (i = 0; i < ((rows/interlace )/2 ) ; i++) {
			*dma_prog++ = htole32(inst);
			*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
			*dma_prog++ = htole32(target_buffer);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    i*cols/2 * interlace);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    (cols*rows/4) + i*cols/2 * interlace);
			target_buffer += interlace*cols;
			*dma_prog++ = htole32(inst1);
			*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
			*dma_prog++ = htole32(target_buffer);
			target_buffer += interlace*cols;
		}
	}

	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
	*dma_prog++ = htole32(0);  /* NULL WORD */
}


/*
 *
 */
static void
build_dma_prog( bktr_ptr_t bktr, char i_flag )
{
	int			rows, cols,  interlace;
	int			tmp_int;
	unsigned int		temp;
	const struct format_params *fp;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];


	fp = &format_params[bktr->format_params];

	OUTL(bktr, BKTR_INT_MASK,  ALL_INTS_DISABLED);

	/* disable FIFO & RISC, leave other bits alone */
	OUTW(bktr, BKTR_GPIO_DMA_CTL, INW(bktr, BKTR_GPIO_DMA_CTL) & ~FIFO_RISC_ENABLED);

	/* set video parameters */
	if (bktr->capture_area_enabled)
	  temp = ((quad_t ) fp->htotal* (quad_t) bktr->capture_area_x_size * 4096
		  / fp->scaled_htotal / bktr->cols) -  4096;
	else
	  temp = ((quad_t ) fp->htotal* (quad_t) fp->scaled_hactive * 4096
		  / fp->scaled_htotal / bktr->cols) -  4096;

	/* printf("%s: HSCALE value is %d\n", bktr_name(bktr), temp); */
	OUTB(bktr, BKTR_E_HSCALE_LO, temp & 0xff);
	OUTB(bktr, BKTR_O_HSCALE_LO, temp & 0xff);
	OUTB(bktr, BKTR_E_HSCALE_HI, (temp >> 8) & 0xff);
	OUTB(bktr, BKTR_O_HSCALE_HI, (temp >> 8) & 0xff);

	/* horizontal active */
	temp = bktr->cols;
	/* printf("%s: HACTIVE value is %d\n", bktr_name(bktr), temp); */
	OUTB(bktr, BKTR_E_HACTIVE_LO, temp & 0xff);
	OUTB(bktr, BKTR_O_HACTIVE_LO, temp & 0xff);
	OUTB(bktr, BKTR_E_CROP, INB(bktr, BKTR_E_CROP) & ~0x3);
	OUTB(bktr, BKTR_O_CROP, INB(bktr, BKTR_O_CROP) & ~0x3);
	OUTB(bktr, BKTR_E_CROP, INB(bktr, BKTR_E_CROP) | ((temp >> 8) & 0x3));
	OUTB(bktr, BKTR_O_CROP, INB(bktr, BKTR_O_CROP) | ((temp >> 8) & 0x3));

	/* horizontal delay */
	if (bktr->capture_area_enabled)
	  temp = ( (fp->hdelay* fp->scaled_hactive + bktr->capture_area_x_offset* fp->scaled_htotal)
		 * bktr->cols) / (bktr->capture_area_x_size * fp->hactive);
	else
	  temp = (fp->hdelay * bktr->cols) / fp->hactive;

	temp = temp & 0x3fe;

	/* printf("%s: HDELAY value is %d\n", bktr_name(bktr), temp); */
	OUTB(bktr, BKTR_E_DELAY_LO, temp & 0xff);
	OUTB(bktr, BKTR_O_DELAY_LO, temp & 0xff);
	OUTB(bktr, BKTR_E_CROP, INB(bktr, BKTR_E_CROP) & ~0xc);
	OUTB(bktr, BKTR_O_CROP, INB(bktr, BKTR_O_CROP) & ~0xc);
	OUTB(bktr, BKTR_E_CROP, INB(bktr, BKTR_E_CROP) | ((temp >> 6) & 0xc));
	OUTB(bktr, BKTR_O_CROP, INB(bktr, BKTR_O_CROP) | ((temp >> 6) & 0xc));

	/* vertical scale */

	if (bktr->capture_area_enabled) {
	  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||
	      bktr->flags & METEOR_ONLY_EVEN_FIELDS)
	    tmp_int = 65536 -
	    (((bktr->capture_area_y_size  * 256 + (bktr->rows/2)) / bktr->rows) - 512);
	  else {
	    tmp_int = 65536 -
	    (((bktr->capture_area_y_size * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);
	  }
	} else {
	  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||
	      bktr->flags & METEOR_ONLY_EVEN_FIELDS)
	    tmp_int = 65536 -
	    (((fp->vactive  * 256 + (bktr->rows/2)) / bktr->rows) - 512);
	  else {
	    tmp_int = 65536  -
	    (((fp->vactive * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);
	  }
	}

	tmp_int &= 0x1fff;
	/* printf("%s: VSCALE value is %d\n", bktr_name(bktr), tmp_int); */
	OUTB(bktr, BKTR_E_VSCALE_LO, tmp_int & 0xff);
	OUTB(bktr, BKTR_O_VSCALE_LO, tmp_int & 0xff);
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) & ~0x1f);
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) & ~0x1f);
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | ((tmp_int >> 8) & 0x1f));
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | ((tmp_int >> 8) & 0x1f));


	/* vertical active */
	if (bktr->capture_area_enabled)
	  temp = bktr->capture_area_y_size;
	else
	  temp = fp->vactive;
	/* printf("%s: VACTIVE is %d\n", bktr_name(bktr), temp); */
	OUTB(bktr, BKTR_E_CROP, INB(bktr, BKTR_E_CROP) & ~0x30);
	OUTB(bktr, BKTR_E_CROP, INB(bktr, BKTR_E_CROP) | ((temp >> 4) & 0x30));
	OUTB(bktr, BKTR_E_VACTIVE_LO, temp & 0xff);
	OUTB(bktr, BKTR_O_CROP, INB(bktr, BKTR_O_CROP) & ~0x30);
	OUTB(bktr, BKTR_O_CROP, INB(bktr, BKTR_O_CROP) | ((temp >> 4) & 0x30));
	OUTB(bktr, BKTR_O_VACTIVE_LO, temp & 0xff);

	/* vertical delay */
	if (bktr->capture_area_enabled)
	  temp = fp->vdelay + (bktr->capture_area_y_offset);
	else
	  temp = fp->vdelay;
	/* printf("%s: VDELAY is %d\n", bktr_name(bktr), temp); */
	OUTB(bktr, BKTR_E_CROP, INB(bktr, BKTR_E_CROP) & ~0xC0);
	OUTB(bktr, BKTR_E_CROP, INB(bktr, BKTR_E_CROP) | ((temp >> 2) & 0xC0));
	OUTB(bktr, BKTR_E_VDELAY_LO, temp & 0xff);
	OUTB(bktr, BKTR_O_CROP, INB(bktr, BKTR_O_CROP) & ~0xC0);
	OUTB(bktr, BKTR_O_CROP, INB(bktr, BKTR_O_CROP) | ((temp >> 2) & 0xC0));
	OUTB(bktr, BKTR_O_VDELAY_LO, temp & 0xff);

	/* end of video params */

	if ((bktr->xtal_pll_mode == BT848_USE_PLL)
	   && (fp->iform_xtsel==BT848_IFORM_X_XT1)) {
		OUTB(bktr, BKTR_TGCTRL, BT848_TGCTRL_TGCKI_PLL); /* Select PLL mode */
	} else {
		OUTB(bktr, BKTR_TGCTRL, BT848_TGCTRL_TGCKI_XTAL); /* Select Normal xtal 0/xtal 1 mode */
	}

	/* capture control */
	switch (i_flag) {
	case 1:
	        bktr->bktr_cap_ctl =
		    (BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_EVEN);
		OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) & ~0x20);
		OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) & ~0x20);
		interlace = 1;
		break;
	 case 2:
	        bktr->bktr_cap_ctl =
			(BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_ODD);
		OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) & ~0x20);
		OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) & ~0x20);
		interlace = 1;
		break;
	 default:
	        bktr->bktr_cap_ctl =
			(BT848_CAP_CTL_DITH_FRAME |
			 BT848_CAP_CTL_EVEN | BT848_CAP_CTL_ODD);
		OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x20);
		OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x20);
		interlace = 2;
		break;
	}

	OUTL(bktr, BKTR_RISC_STRT_ADD, bktr->dm_prog->dm_segs->ds_addr);

	rows = bktr->rows;
	cols = bktr->cols;

	bktr->vbiflags &= ~VBI_CAPTURE;	/* default - no vbi capture */

	/* RGB Grabs. If /dev/vbi is already open, or we are a PAL/SECAM */
	/* user, then use the rgb_vbi RISC program. */
	/* Otherwise, use the normal rgb RISC program */
	if (pf_int->public.type == METEOR_PIXTYPE_RGB) {
		if ( (bktr->vbiflags & VBI_OPEN)
		   ||(bktr->format_params == BT848_IFORM_F_PALBDGHI)
		   ||(bktr->format_params == BT848_IFORM_F_SECAM)
                   ){
			bktr->bktr_cap_ctl |=
		                BT848_CAP_CTL_VBI_EVEN | BT848_CAP_CTL_VBI_ODD;
			bktr->vbiflags |= VBI_CAPTURE;
			rgb_vbi_prog(bktr, i_flag, cols, rows, interlace);
			return;
		} else {
			rgb_prog(bktr, i_flag, cols, rows, interlace);
			return;
		}
	}

	if ( pf_int->public.type  == METEOR_PIXTYPE_YUV ) {
		yuv422_prog(bktr, i_flag, cols, rows, interlace);
		OUTB(bktr, BKTR_COLOR_CTL, (INB(bktr, BKTR_COLOR_CTL) & 0xf0)
		     | pixfmt_swap_flags( bktr->pixfmt ));
		return;
	}

	if ( pf_int->public.type  == METEOR_PIXTYPE_YUV_PACKED ) {
		yuvpack_prog(bktr, i_flag, cols, rows, interlace);
		OUTB(bktr, BKTR_COLOR_CTL, (INB(bktr, BKTR_COLOR_CTL) & 0xf0)
		     | pixfmt_swap_flags( bktr->pixfmt ));
		return;
	}

	if ( pf_int->public.type  == METEOR_PIXTYPE_YUV_12 ) {
		yuv12_prog(bktr, i_flag, cols, rows, interlace);
		OUTB(bktr, BKTR_COLOR_CTL, (INB(bktr, BKTR_COLOR_CTL) & 0xf0)
		     | pixfmt_swap_flags( bktr->pixfmt ));
		return;
	}
	return;
}


/******************************************************************************
 * video & video capture specific routines:
 */


/*
 *
 */
static void
start_capture( bktr_ptr_t bktr, unsigned type )
{
	u_char			i_flag;
	const struct format_params   *fp;

	fp = &format_params[bktr->format_params];

	/*  If requested, clear out capture buf first  */
	if (bktr->clr_on_start && (bktr->video.addr == 0)) {
		bzero((caddr_t)bktr->bigbuf,
		      (size_t)bktr->rows * bktr->cols * bktr->frames *
			pixfmt_table[ bktr->pixfmt ].public.Bpp);
	}

	OUTB(bktr, BKTR_DSTATUS,  0);
	OUTL(bktr, BKTR_INT_STAT, INL(bktr, BKTR_INT_STAT));

	bktr->flags |= type;
	bktr->flags &= ~METEOR_WANT_MASK;
	switch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {
	case METEOR_ONLY_EVEN_FIELDS:
		bktr->flags |= METEOR_WANT_EVEN;
		i_flag = 1;
		break;
	case METEOR_ONLY_ODD_FIELDS:
		bktr->flags |= METEOR_WANT_ODD;
		i_flag = 2;
		break;
	default:
		bktr->flags |= METEOR_WANT_MASK;
		i_flag = 3;
		break;
	}

	/*  TDEC is only valid for continuous captures  */
	if ( type == METEOR_SINGLE ) {
		u_short	fps_save = bktr->fps;

		set_fps(bktr, fp->frame_rate);
		bktr->fps = fps_save;
	}
	else
		set_fps(bktr, bktr->fps);

	if (bktr->dma_prog_loaded == FALSE) {
		build_dma_prog(bktr, i_flag);
		bktr->dma_prog_loaded = TRUE;
	}


	OUTL(bktr, BKTR_RISC_STRT_ADD, bktr->dm_prog->dm_segs->ds_addr);
}


/*
 *
 */
static void
set_fps( bktr_ptr_t bktr, u_short fps )
{
	const struct format_params	*fp;
	int i_flag;

	fp = &format_params[bktr->format_params];

	switch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {
	case METEOR_ONLY_EVEN_FIELDS:
		bktr->flags |= METEOR_WANT_EVEN;
		i_flag = 1;
		break;
	case METEOR_ONLY_ODD_FIELDS:
		bktr->flags |= METEOR_WANT_ODD;
		i_flag = 1;
		break;
	default:
		bktr->flags |= METEOR_WANT_MASK;
		i_flag = 2;
		break;
	}

	OUTW(bktr, BKTR_GPIO_DMA_CTL, FIFO_RISC_DISABLED);
	OUTL(bktr, BKTR_INT_STAT, ALL_INTS_CLEARED);

	bktr->fps = fps;
	OUTB(bktr, BKTR_TDEC, 0);

	if (fps < fp->frame_rate)
		OUTB(bktr, BKTR_TDEC, i_flag*(fp->frame_rate - fps) & 0x3f);
	else
		OUTB(bktr, BKTR_TDEC, 0);
	return;

}





/*
 * Given a pixfmt index, compute the bt848 swap_flags necessary to
 *   achieve the specified swapping.
 * Note that without bt swapping, 2Bpp and 3Bpp modes are written
 *   byte-swapped, and 4Bpp modes are byte and word swapped (see Table 6
 *   and read R->L).
 * Note also that for 3Bpp, we may additionally need to do some creative
 *   SKIPing to align the FIFO bytelines with the target buffer (see split()).
 * This is abstracted here: e.g. no swaps = RGBA; byte & short swap = ABGR
 *   as one would expect.
 */

static u_int pixfmt_swap_flags( int pixfmt )
{
	const struct meteor_pixfmt *pf = &pixfmt_table[ pixfmt ].public;
	u_int		      swapf = 0;
	int swap_bytes, swap_shorts;

#if BYTE_ORDER == LITTLE_ENDIAN
	swap_bytes = pf->swap_bytes;
	swap_shorts = pf->swap_shorts;
#else
	swap_bytes = !pf->swap_bytes;
	swap_shorts = !pf->swap_shorts;
#endif

	switch ( pf->Bpp ) {
	case 2:
		swapf = swap_bytes ? 0 : BSWAP;
		break;

	case 3: /* no swaps supported for 3bpp - makes no sense w/ bt848 */
		break;

	case 4:
		swapf = swap_bytes ? 0 : BSWAP;
		swapf |= swap_shorts ? 0 : WSWAP;
		break;
	}
	return swapf;
}



/*
 * Converts meteor-defined pixel formats (e.g. METEOR_GEO_RGB16) into
 *   our pixfmt_table indices.
 */

static int oformat_meteor_to_bt( u_int format )
{
	int    i;
        const struct meteor_pixfmt *pf1, *pf2;

	/*  Find format in compatibility table  */
	for ( i = 0; i < METEOR_PIXFMT_TABLE_SIZE; i++ )
		if ( meteor_pixfmt_table[i].meteor_format == format )
			break;

	if ( i >= METEOR_PIXFMT_TABLE_SIZE )
		return -1;
	pf1 = &meteor_pixfmt_table[i].public;

	/*  Match it with an entry in master pixel format table  */
	for ( i = 0; i < PIXFMT_TABLE_SIZE; i++ ) {
		pf2 = &pixfmt_table[i].public;

		if (( pf1->type        == pf2->type        ) &&
		    ( pf1->Bpp         == pf2->Bpp         ) &&
		    !bcmp( pf1->masks, pf2->masks, sizeof( pf1->masks )) &&
		    ( pf1->swap_bytes  == pf2->swap_bytes  ) &&
		    ( pf1->swap_shorts == pf2->swap_shorts ))
			break;
	}
	if ( i >= PIXFMT_TABLE_SIZE )
		return -1;

	return i;
}

/******************************************************************************
 * i2c primitives:
 */

/* */
#define I2CBITTIME		(0x5)	/* 5 * 0.48uS */
#define I2CBITTIME_878		(0x8)
#define I2C_READ		0x01
#define I2C_COMMAND		((I2CBITTIME << 4) |		\
				 BT848_DATA_CTL_I2CSCL |	\
				 BT848_DATA_CTL_I2CSDA)

#define I2C_COMMAND_878		((I2CBITTIME_878 << 4) |	\
				 BT848_DATA_CTL_I2CSCL |	\
				 BT848_DATA_CTL_I2CSDA)

/*
 * Program the i2c bus directly
 */
int
i2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )
{
	u_int		x;
	u_int		data;

	/* clear status bits */
	OUTL(bktr, BKTR_INT_STAT, BT848_INT_RACK | BT848_INT_I2CDONE);

	/* build the command datum */
	if (bktr->id == BROOKTREE_848  ||
	    bktr->id == BROOKTREE_848A ||
	    bktr->id == BROOKTREE_849A) {
	  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;
	} else {
	  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;
	}
	if ( byte2 != -1 ) {
		data |= ((byte2 & 0xff) << 8);
		data |= BT848_DATA_CTL_I2CW3B;
	}

	/* write the address and data */
	OUTL(bktr, BKTR_I2C_DATA_CTL, data);

	/* wait for completion */
	for ( x = 0x7fffffff; x; --x ) {	/* safety valve */
		if ( INL(bktr, BKTR_INT_STAT) & BT848_INT_I2CDONE )
			break;
	}

	/* check for ACK */
	if ( !x || !(INL(bktr, BKTR_INT_STAT) & BT848_INT_RACK) )
		return( -1 );

	/* return OK */
	return( 0 );
}


/*
 *
 */
int
i2cRead( bktr_ptr_t bktr, int addr )
{
	u_int32_t x, stat;

	/* clear status bits */
	OUTL(bktr, BKTR_INT_STAT, BT848_INT_RACK | BT848_INT_I2CDONE);

	/* write the READ address */
	/* The Bt878 and Bt879  differed on the treatment of i2c commands */

	if (bktr->id == BROOKTREE_848  ||
	    bktr->id == BROOKTREE_848A ||
	    bktr->id == BROOKTREE_849A)
		OUTL(bktr, BKTR_I2C_DATA_CTL, ((addr & 0xff) << 24) | I2C_COMMAND);
	else
		OUTL(bktr, BKTR_I2C_DATA_CTL, ((addr & 0xff) << 24) | I2C_COMMAND_878);

	/* wait for completion */
	for (x = 5000; x--; DELAY(1))	/* 5 msec, safety valve */
		if ((stat = INL(bktr, BKTR_INT_STAT)) & BT848_INT_I2CDONE)
			break;

	/* check for ACK */
	if ((stat & (I2C_BITS)) != (I2C_BITS))
		return (-1);

	/* it was a read */
	x = INL(bktr, BKTR_I2C_DATA_CTL);
	return ((x >> 8) & 0xff);
}

/* The MSP34xx Audio chip require i2c bus writes of up to 5 bytes which the */
/* bt848 automated i2c bus controller cannot handle */
/* Therefore we need low level control of the i2c bus hardware */
/* Idea for the following functions are from elsewhere in this driver and */
/* from the Linux BTTV i2c driver by Gerd Knorr <kraxel@@cs.tu-berlin.de> */

#define BITD    40
static void i2c_start( bktr_ptr_t bktr) {
        OUTL(bktr, BKTR_I2C_DATA_CTL, 1); DELAY( BITD ); /* release data */
        OUTL(bktr, BKTR_I2C_DATA_CTL, 3); DELAY( BITD ); /* release clock */
        OUTL(bktr, BKTR_I2C_DATA_CTL, 2); DELAY( BITD ); /* lower data */
        OUTL(bktr, BKTR_I2C_DATA_CTL, 0); DELAY( BITD ); /* lower clock */
}

static void i2c_stop( bktr_ptr_t bktr) {
        OUTL(bktr, BKTR_I2C_DATA_CTL, 0); DELAY( BITD ); /* lower clock & data */
        OUTL(bktr, BKTR_I2C_DATA_CTL, 2); DELAY( BITD ); /* release clock */
        OUTL(bktr, BKTR_I2C_DATA_CTL, 3); DELAY( BITD ); /* release data */
}

static int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {
        int x;
        int status;

        /* write out the byte */
        for ( x = 7; x >= 0; --x ) {
                if ( data & (1<<x) ) {
			OUTL(bktr, BKTR_I2C_DATA_CTL, 1);
                        DELAY( BITD );          /* assert HI data */
			OUTL(bktr, BKTR_I2C_DATA_CTL, 3);
                        DELAY( BITD );          /* strobe clock */
			OUTL(bktr, BKTR_I2C_DATA_CTL, 1);
                        DELAY( BITD );          /* release clock */
                }
                else {
			OUTL(bktr, BKTR_I2C_DATA_CTL, 0);
                        DELAY( BITD );          /* assert LO data */
			OUTL(bktr, BKTR_I2C_DATA_CTL, 2);
                        DELAY( BITD );          /* strobe clock */
			OUTL(bktr, BKTR_I2C_DATA_CTL, 0);
                        DELAY( BITD );          /* release clock */
                }
        }

        /* look for an ACK */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 1); DELAY( BITD ); /* float data */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 3); DELAY( BITD ); /* strobe clock */
        status = INL(bktr, BKTR_I2C_DATA_CTL) & 1;       /* read the ACK bit */
        OUTL(bktr, BKTR_I2C_DATA_CTL, 1); DELAY( BITD ); /* release clock */

        return( status );
}

static int i2c_read_byte( bktr_ptr_t bktr, unsigned char *data, int last ) {
        int x;
        int bit;
        int byte = 0;

        /* read in the byte */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 1);
        DELAY( BITD );                          /* float data */
        for ( x = 7; x >= 0; --x ) {
		OUTL(bktr, BKTR_I2C_DATA_CTL, 3);
                DELAY( BITD );                  /* strobe clock */
                bit = INL(bktr, BKTR_I2C_DATA_CTL) & 1;  /* read the data bit */
                if ( bit ) byte |= (1<<x);
		OUTL(bktr, BKTR_I2C_DATA_CTL, 1);
                DELAY( BITD );                  /* release clock */
        }
        /* After reading the byte, send an ACK */
        /* (unless that was the last byte, for which we send a NAK */
        if (last) { /* send NAK - same a writing a 1 */
		OUTL(bktr, BKTR_I2C_DATA_CTL, 1);
                DELAY( BITD );                  /* set data bit */
		OUTL(bktr, BKTR_I2C_DATA_CTL, 3);
                DELAY( BITD );                  /* strobe clock */
		OUTL(bktr, BKTR_I2C_DATA_CTL, 1);
                DELAY( BITD );                  /* release clock */
        } else { /* send ACK - same as writing a 0 */
		OUTL(bktr, BKTR_I2C_DATA_CTL, 0);
                DELAY( BITD );                  /* set data bit */
		OUTL(bktr, BKTR_I2C_DATA_CTL, 2);
                DELAY( BITD );                  /* strobe clock */
		OUTL(bktr, BKTR_I2C_DATA_CTL, 0);
                DELAY( BITD );                  /* release clock */
        }

        *data=byte;
	return 0;
}
#undef BITD

/* Write to the MSP or DPL registers */
void msp_dpl_write( bktr_ptr_t bktr, int i2c_addr, unsigned char dev, unsigned int addr,
		    unsigned int data){
	unsigned int msp_w_addr = i2c_addr;
	unsigned char addr_l, addr_h, data_h, data_l ;
	addr_h = (addr >>8) & 0xff;
	addr_l = addr & 0xff;
	data_h = (data >>8) & 0xff;
	data_l = data & 0xff;

	i2c_start(bktr);
	i2c_write_byte(bktr, msp_w_addr);
	i2c_write_byte(bktr, dev);
	i2c_write_byte(bktr, addr_h);
	i2c_write_byte(bktr, addr_l);
	i2c_write_byte(bktr, data_h);
	i2c_write_byte(bktr, data_l);
	i2c_stop(bktr);
}

/* Read from the MSP or DPL registers */
unsigned int msp_dpl_read(bktr_ptr_t bktr, int i2c_addr, unsigned char dev, unsigned int addr){
	unsigned int data;
	unsigned char addr_l, addr_h, data_1, data_2, dev_r ;
	addr_h = (addr >>8) & 0xff;
	addr_l = addr & 0xff;
	dev_r = dev+1;

	i2c_start(bktr);
	i2c_write_byte(bktr,i2c_addr);
	i2c_write_byte(bktr,dev_r);
	i2c_write_byte(bktr,addr_h);
	i2c_write_byte(bktr,addr_l);

	i2c_start(bktr);
	i2c_write_byte(bktr,i2c_addr+1);
	i2c_read_byte(bktr,&data_1, 0);
	i2c_read_byte(bktr,&data_2, 1);
	i2c_stop(bktr);
	data = (data_1<<8) | data_2;
	return data;
}

/* Reset the MSP or DPL chip */
/* The user can block the reset (which is handy if you initialise the
 * MSP audio in another operating system first (eg in Windows)
 */
void msp_dpl_reset( bktr_ptr_t bktr, int i2c_addr ) {

#ifndef BKTR_NO_MSP_RESET
	/* put into reset mode */
	i2c_start(bktr);
	i2c_write_byte(bktr, i2c_addr);
	i2c_write_byte(bktr, 0x00);
	i2c_write_byte(bktr, 0x80);
	i2c_write_byte(bktr, 0x00);
	i2c_stop(bktr);

	/* put back to operational mode */
	i2c_start(bktr);
	i2c_write_byte(bktr, i2c_addr);
	i2c_write_byte(bktr, 0x00);
	i2c_write_byte(bktr, 0x00);
	i2c_write_byte(bktr, 0x00);
	i2c_stop(bktr);
#endif
	return;

}

static void remote_read(bktr_ptr_t bktr, struct bktr_remote *remote) {

	/* XXX errors ignored */
	i2c_start(bktr);
	i2c_write_byte(bktr,bktr->remote_control_addr);
	i2c_read_byte(bktr,&(remote->data[0]), 0);
	i2c_read_byte(bktr,&(remote->data[1]), 0);
	i2c_read_byte(bktr,&(remote->data[2]), 0);
	i2c_stop(bktr);

	return;
}

#if defined( I2C_SOFTWARE_PROBE )

/*
 * we are keeping this around for any parts that we need to probe
 * but that CANNOT be probed via an i2c read.
 * this is necessary because the hardware i2c mechanism
 * cannot be programmed for 1 byte writes.
 * currently there are no known i2c parts that we need to probe
 * and that cannot be safely read.
 */
static int	i2cProbe( bktr_ptr_t bktr, int addr );
#define BITD		40
#define EXTRA_START

/*
 * probe for an I2C device at addr.
 */
static int
i2cProbe( bktr_ptr_t bktr, int addr )
{
	int		x, status;

	/* the START */
#if defined( EXTRA_START )
	OUTL(bktr, BKTR_I2C_DATA_CTL, 1); DELAY( BITD );	/* release data */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 3); DELAY( BITD );	/* release clock */
#endif /* EXTRA_START */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 2); DELAY( BITD );	/* lower data */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 0); DELAY( BITD );	/* lower clock */

	/* write addr */
	for ( x = 7; x >= 0; --x ) {
		if ( addr & (1<<x) ) {
			OUTL(bktr, BKTR_I2C_DATA_CTL, 1);
			DELAY( BITD );		/* assert HI data */
			OUTL(bktr, BKTR_I2C_DATA_CTL, 3);
			DELAY( BITD );		/* strobe clock */
			OUTL(bktr, BKTR_I2C_DATA_CTL, 1);
			DELAY( BITD );		/* release clock */
		}
		else {
			OUTL(bktr, BKTR_I2C_DATA_CTL, 0);
			DELAY( BITD );		/* assert LO data */
			OUTL(bktr, BKTR_I2C_DATA_CTL, 2);
			DELAY( BITD );		/* strobe clock */
			OUTL(bktr, BKTR_I2C_DATA_CTL, 0);
			DELAY( BITD );		/* release clock */
		}
	}

	/* look for an ACK */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 1); DELAY( BITD );	/* float data */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 3); DELAY( BITD );	/* strobe clock */
	status = INL(bktr, BKTR_I2C_DATA_CTL) & 1;	/* read the ACK bit */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 1); DELAY( BITD );	/* release clock */

	/* the STOP */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 0); DELAY( BITD );	/* lower clock & data */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 2); DELAY( BITD );	/* release clock */
	OUTL(bktr, BKTR_I2C_DATA_CTL, 3); DELAY( BITD );	/* release data */

	return( status );
}
#undef EXTRA_START
#undef BITD

#endif /* I2C_SOFTWARE_PROBE */
@


1.37
log
@Convert to uiomove. From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.36 2015/03/14 03:38:49 jsg Exp $	*/
d883 1
a883 1
	bktr->proc = (struct proc *)0;
@


1.36
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.35 2015/02/10 21:56:09 miod Exp $	*/
d996 1
a996 1
        int             count;
d1011 1
a1011 1
	if ((int) uio->uio_iov->iov_len < count)
d1030 1
a1030 1
		status = uiomovei((caddr_t)bktr->bigbuf, count, uio);
d1050 1
a1050 1
	int             readsize, readsize2;
d1070 1
a1070 3
	readsize = (int)uio->uio_iov->iov_len;

	if (readsize > bktr->vbisize) readsize = bktr->vbisize;
d1074 1
a1074 1
	if((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {
d1078 1
a1078 1
		status = uiomovei((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);
d1080 1
a1080 1
			status = uiomovei((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);
d1083 1
a1083 1
		status = uiomovei((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);
@


1.35
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.34 2014/12/16 18:30:03 tedu Exp $	*/
a102 1
#include <sys/stdint.h>		/* uintptr_t */
@


1.34
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.33 2014/05/04 20:09:15 sf Exp $	*/
d1031 1
a1031 1
		status = uiomove((caddr_t)bktr->bigbuf, count, uio);
d1081 1
a1081 1
		status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);
d1083 1
a1083 1
			status = uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);
d1086 1
a1086 1
		status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);
@


1.33
log
@format string fixes for bus_addr_t and bus_size_t

bus_addr_t and bus_size_t are u_long everywhere

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.32 2013/11/26 20:33:18 deraadt Exp $	*/
d104 2
@


1.32
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.31 2013/10/04 07:27:36 brad Exp $	*/
d389 1
a389 1
		printf("%s: buffer size %d, addr 0x%x\n",
@


1.31
log
@Fix tuner ioctl TVTUNER_SETFREQ after rev 1.30.

Pointed out by Pedro
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.30 2013/07/05 02:37:30 brad Exp $	*/
d2365 4
a2368 4
#define BKTR_TEST_RISC_STATUS_BIT0 (1 << 28)
#define BKTR_TEST_RISC_STATUS_BIT1 (1 << 29)
#define BKTR_TEST_RISC_STATUS_BIT2 (1 << 30)
#define BKTR_TEST_RISC_STATUS_BIT3 (1 << 31)
@


1.30
log
@Use tmp_int to be able to pass back the -1 upon error and check for it properly
but the value passed forward throughout the ioctl handler otherwise is an
unsigned value.

Pointed out by LLVM.

bktr_core.c:1737:13: error: comparison of unsigned expression < 0 is always false
bktr_core.c:1779:13: error: comparison of unsigned expression < 0 is always false
bktr_core.c:2063:16: error: comparison of unsigned expression < 0 is always false

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.29 2010/08/06 00:00:16 miod Exp $	*/
d1783 1
a1783 1
		*(unsigned int *)arg = temp;
@


1.29
log
@don't return (potential errno) + (potential errno), instead only perform
the second errno-capable function if the first one didn't fail.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.28 2009/11/09 17:53:39 nicm Exp $	*/
d1736 2
a1737 2
		temp = tv_channel( bktr, (int)*(unsigned int *)arg );
		if ( temp < 0 ) {
d1741 1
a1741 1
		*(unsigned int *)arg = temp;
d1777 1
a1777 1
		temp = tv_freq( bktr, (int)*(unsigned int *)arg, TV_FREQUENCY);
d1779 1
a1779 1
		if ( temp < 0 ) {
d2057 1
a2057 1
	    temp = tv_freq( bktr, temp, FM_RADIO_FREQUENCY );
d2060 2
a2061 2
  if(temp)
    printf("%s: tv_freq returned: %d\n", bktr_name(bktr), temp);
d2063 1
a2063 1
	    if ( temp < 0 )
d2065 1
a2065 1
	    *(unsigned long *)arg = temp;
@


1.28
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.27 2009/10/31 06:40:17 deraadt Exp $	*/
d1080 2
a1081 1
		status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);
@


1.27
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.26 2007/11/26 09:28:34 martynas Exp $	*/
d656 2
d659 1
a659 1
		if (bktr->vbi_select.si_selpid) {
a660 3
			selwakeup(&bktr->vbi_select);
			KNOTE(&bktr->vbi_select.si_note, 0);
		}
@


1.26
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.25 2007/09/15 10:10:37 martin Exp $	*/
d660 1
@


1.25
log
@replace ctob and btoc with ptoa and atop respectively

help and ok miod@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.24 2007/07/25 23:11:52 art Exp $	*/
d402 1
a402 1
	bktr->flags = METEOR_INITALIZED | METEOR_AUTOMODE |
d442 1
a442 1
	bktr->tflags = TUNER_INITALIZED;
d927 1
a927 1
	if ( !(bktr->tflags & TUNER_INITALIZED) )	/* device not found */
@


1.24
log
@Back out the tracking of procs in struct selinfo. There's one serious
bug in the code, but as soon as I try to fix it, it seems to trigger
some other bugs. Instead of trying to figure out what's going on
while everyone suffers, it's better to back out and figure out
the bugs outside the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.23 2007/06/11 08:10:22 robert Exp $	*/
d1557 1
a1557 1
			temp = btoc(temp);
@


1.23
log
@remove all FreeBSD/NetBSD specific code because we will
never use them and the code is much more readable now

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.22 2007/03/24 16:01:21 art Exp $	*/
d654 7
a660 1
		selwakeup(&bktr->vbi_select);
@


1.22
log
@Kill the horrible hack of storing the pid in struct selinfo.

Instead, keep the proc pointer in it and put the selinfo on a list
in struct proc in selrecord. Then clean up the list when leaving
sys_select and sys_poll.

miod@@ ok, testing by many, including Bobs spamd boxes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.21 2007/02/11 20:29:22 miod Exp $	*/
a97 89
#ifdef __FreeBSD__
#include "bktr.h"
#endif /* __FreeBSD__ */

#if (                                                            \
       (defined(__FreeBSD__) && (NBKTR > 0))                     \
    || (defined(__bsdi__))                                       \
    || (defined(__OpenBSD__))                                    \
    || (defined(__NetBSD__))                                     \
    )


/*******************/
/* *** FreeBSD *** */
/*******************/
#ifdef __FreeBSD__

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <vm/pmap.h>
#include <vm/vm_extern.h>

#if (__FreeBSD_version >=400000) || (NSMBUS > 0)
#include <sys/bus.h>		/* used by smbus and newbus */
#endif

#if (__FreeBSD_version < 500000)
#include <machine/clock.h>              /* for DELAY */
#endif

#include <pci/pcivar.h>

#if (__FreeBSD_version >=300000)
#include <machine/bus_memio.h>	/* for bus space */
#include <machine/bus.h>
#include <sys/bus.h>
#endif

#include <machine/ioctl_meteor.h>
#include <machine/ioctl_bt848.h>	/* extensions to ioctl_meteor.h */
#include <dev/bktr/bktr_reg.h>
#include <dev/bktr/bktr_tuner.h>
#include <dev/bktr/bktr_card.h>
#include <dev/bktr/bktr_audio.h>
#include <dev/bktr/bktr_os.h>
#include <dev/bktr/bktr_core.h>
#if defined(BKTR_FREEBSD_MODULE)
#include <dev/bktr/bktr_mem.h>
#endif

#if defined(BKTR_USE_FREEBSD_SMBUS)
#include <dev/bktr/bktr_i2c.h>
#include <dev/smbus/smbconf.h>
#include <dev/iicbus/iiconf.h>
#include "smbus_if.h"
#include "iicbus_if.h"
#endif

const char *
bktr_name(bktr_ptr_t bktr)
{
  return bktr->bktr_xname;
}


#if (__FreeBSD__ == 2)
typedef unsigned int uintptr_t;
#endif
#endif  /* __FreeBSD__ */


/****************/
/* *** BSDI *** */
/****************/
#ifdef __bsdi__
#endif /* __bsdi__ */


/**************************/
/* *** OpenBSD/NetBSD *** */
/**************************/
#if defined(__NetBSD__) || defined(__OpenBSD__)

a104 5
#ifdef __NetBSD__
#include <uvm/uvm_extern.h>
#endif

#ifdef __OpenBSD__
a105 3
typedef int intrmask_t;
#endif

d114 2
a123 3
#endif /* __NetBSD__ || __OpenBSD__ */


a352 1
#if !defined(BKTR_USE_FREEBSD_SMBUS)
a359 3
#endif


a371 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a386 45
#endif

#if defined(__FreeBSD__) || defined(__bsdi__)
	int		need_to_allocate_memory = 1;

/* If this is a module, check if there is any currently saved contiguous memory */
#if defined(BKTR_FREEBSD_MODULE)
	if (bktr_has_stored_addresses(unit) == 1) {
		/* recover the addresses */
		bktr->dma_prog     = bktr_retrieve_address(unit, BKTR_MEM_DMA_PROG);
		bktr->odd_dma_prog = bktr_retrieve_address(unit, BKTR_MEM_ODD_DMA_PROG);
		bktr->vbidata      = bktr_retrieve_address(unit, BKTR_MEM_VBIDATA);
		bktr->vbibuffer    = bktr_retrieve_address(unit, BKTR_MEM_VBIBUFFER);
		buf                = bktr_retrieve_address(unit, BKTR_MEM_BUF);
		need_to_allocate_memory = 0;
	}
#endif

	if (need_to_allocate_memory == 1) {
		/* allocate space for dma program */
		bktr->dma_prog     = get_bktr_mem(unit, DMA_PROG_ALLOC);
		bktr->odd_dma_prog = get_bktr_mem(unit, DMA_PROG_ALLOC);

		/* allocte space for the VBI buffer */
		bktr->vbidata  = get_bktr_mem(unit, VBI_DATA_SIZE);
		bktr->vbibuffer = get_bktr_mem(unit, VBI_BUFFER_SIZE);

		/* allocate space for pixel buffer */
		if ( BROOKTREE_ALLOC )
			buf = get_bktr_mem(unit, BROOKTREE_ALLOC);
		else
			buf = 0;
	}
#endif	/* FreeBSD or BSDi */


/* If this is a module, save the current contiguous memory */
#if defined(BKTR_FREEBSD_MODULE)
bktr_store_address(unit, BKTR_MEM_DMA_PROG,     bktr->dma_prog);
bktr_store_address(unit, BKTR_MEM_ODD_DMA_PROG, bktr->odd_dma_prog);
bktr_store_address(unit, BKTR_MEM_VBIDATA,      bktr->vbidata);
bktr_store_address(unit, BKTR_MEM_VBIBUFFER,    bktr->vbibuffer);
bktr_store_address(unit, BKTR_MEM_BUF,          buf);
#endif

a390 3
#ifdef __FreeBSD__
			vtophys(buf));
#else
a391 1
#endif
a598 3
#ifdef __FreeBSD__
		OUTL(bktr, BKTR_RISC_STRT_ADD, vtophys(bktr->dma_prog));
#else
a599 1
#endif
a609 1
#ifdef __OpenBSD__
d611 1
a611 1
#endif
a623 1
#ifdef __OpenBSD__
a624 1
#endif
a1557 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1565 8

#else
                                buf = get_bktr_mem(unit, temp*PAGE_SIZE);
                                if (buf != 0) {
                                        kmem_free(kernel_map, bktr->bigbuf,
                                          (bktr->alloc_pages * PAGE_SIZE));
#endif

a2576 3
#ifdef __FreeBSD__
		target_buffer = (u_int) vtophys(bktr->bigbuf);
#else
a2577 1
#endif
a2596 4
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys((caddr_t)bktr->vbidata +
					(i * VBI_LINE_SIZE));
#else
a2598 1
#endif
a2641 4
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys((caddr_t)bktr->vbidata +
				((i+MAX_VBI_LINES) * VBI_LINE_SIZE));
#else
a2643 1
#endif
a2684 3
#ifdef __FreeBSD__
	*dma_prog++ = (u_int )vtophys(loop_point) ;
#else
a2686 1
#endif
a2733 3
#ifdef __FreeBSD__
		target_buffer = (u_int) vtophys(bktr->bigbuf);
#else
a2734 1
#endif
a2774 3
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a2775 1
#endif
a2783 3
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a2784 1
#endif
d2791 1
a2792 3
#ifdef __FreeBSD__
		*dma_prog = (u_int) vtophys(bktr->odd_dma_prog);
#else
a2793 1
#endif
a2832 3
#ifdef __FreeBSD__
	*dma_prog++ = (u_ong ) vtophys(bktr->dma_prog) ;
#else
a2833 1
#endif
a2875 3
#ifdef __FreeBSD__
		target_buffer = vtophys(bktr->bigbuf);
#else
a2876 1
#endif
a2899 1

a2900 3
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a2901 1
#endif
a2908 3
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a2909 1
#endif
a2916 3
#ifdef __FreeBSD__
		*dma_prog = (u_int) vtophys(bktr->odd_dma_prog);
#else
a2917 1
#endif
a2943 3
#ifdef __FreeBSD__
	*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a2944 1
#endif
a2946 3
#ifdef __FreeBSD__
	*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a2947 1
#endif
a2991 3
#ifdef __FreeBSD__
		target_buffer = (u_int) vtophys(bktr->bigbuf);
#else
a2992 1
#endif
a3018 3
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a3019 1
#endif
a3026 3
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a3027 1
#endif
a3034 3
#ifdef __FreeBSD__
		*dma_prog = (u_int) vtophys(bktr->odd_dma_prog);
#else
a3035 1
#endif
a3062 3
#ifdef __FreeBSD__
	*dma_prog++ = (u_int) vtophys(bktr->dma_prog) ;
#else
a3063 1
#endif
a3096 3
#ifdef __FreeBSD__
		target_buffer = (u_int) vtophys(bktr->bigbuf);
#else
a3097 1
#endif
a3126 3
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a3127 1
#endif
a3134 3
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
a3135 1
#endif
a3141 3
#ifdef __FreeBSD__
		*dma_prog = (u_int) vtophys(bktr->odd_dma_prog);
#else
a3142 1
#endif
a3173 3
#ifdef __FreeBSD__
	*dma_prog++ = (u_int )vtophys(bktr->dma_prog);
#else
a3174 1
#endif
a3332 3
#ifdef __FreeBSD__
	OUTL(bktr, BKTR_RISC_STRT_ADD, vtophys(bktr->dma_prog));
#else
a3333 1
#endif
a3441 3
#ifdef __FreeBSD__
	OUTL(bktr, BKTR_RISC_STRT_ADD, vtophys(bktr->dma_prog));
#else
a3442 1
#endif
a3585 149
/* Select between old i2c code and new iicbus / smbus code */
#if defined(BKTR_USE_FREEBSD_SMBUS)

/*
 * The hardware interface is actually SMB commands
 */
int
i2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )
{
	char cmd;

	if (bktr->id == BROOKTREE_848  ||
	    bktr->id == BROOKTREE_848A ||
	    bktr->id == BROOKTREE_849A)
		cmd = I2C_COMMAND;
	else
		cmd = I2C_COMMAND_878;

	if (byte2 != -1) {
		if (smbus_writew(bktr->i2c_sc.smbus, addr, cmd,
			(short)(((byte2 & 0xff) << 8) | (byte1 & 0xff))))
			return (-1);
	} else {
		if (smbus_writeb(bktr->i2c_sc.smbus, addr, cmd,
			(char)(byte1 & 0xff)))
			return (-1);
	}

	/* return OK */
	return( 0 );
}

int
i2cRead( bktr_ptr_t bktr, int addr )
{
	char result;
	char cmd;

	if (bktr->id == BROOKTREE_848  ||
	    bktr->id == BROOKTREE_848A ||
	    bktr->id == BROOKTREE_849A)
		cmd = I2C_COMMAND;
	else
		cmd = I2C_COMMAND_878;

	if (smbus_readb(bktr->i2c_sc.smbus, addr, cmd, &result))
		return (-1);

	return ((int)((unsigned char)result));
}

#define IICBUS(bktr) ((bktr)->i2c_sc.iicbus)

/* The MSP34xx and DPL35xx Audio chip require i2c bus writes of up */
/* to 5 bytes which the bt848 automated i2c bus controller cannot handle */
/* Therefore we need low level control of the i2c bus hardware */

/* Write to the MSP or DPL registers */
void
msp_dpl_write(bktr_ptr_t bktr, int i2c_addr,  unsigned char dev, unsigned int addr, unsigned int data)
{
	unsigned char addr_l, addr_h, data_h, data_l ;

	addr_h = (addr >>8) & 0xff;
	addr_l = addr & 0xff;
	data_h = (data >>8) & 0xff;
	data_l = data & 0xff;

	iicbus_start(IICBUS(bktr), i2c_addr, 0 /* no timeout? */);

	iicbus_write_byte(IICBUS(bktr), dev, 0);
	iicbus_write_byte(IICBUS(bktr), addr_h, 0);
	iicbus_write_byte(IICBUS(bktr), addr_l, 0);
	iicbus_write_byte(IICBUS(bktr), data_h, 0);
	iicbus_write_byte(IICBUS(bktr), data_l, 0);

	iicbus_stop(IICBUS(bktr));

	return;
}

/* Read from the MSP or DPL registers */
unsigned int
msp_dpl_read(bktr_ptr_t bktr, int i2c_addr, unsigned char dev, unsigned int addr)
{
	unsigned int data;
	unsigned char addr_l, addr_h, dev_r;
	int read;
	u_char data_read[2];

	addr_h = (addr >>8) & 0xff;
	addr_l = addr & 0xff;
	dev_r = dev+1;

	/* XXX errors ignored */
	iicbus_start(IICBUS(bktr), i2c_addr, 0 /* no timeout? */);

	iicbus_write_byte(IICBUS(bktr), dev_r, 0);
	iicbus_write_byte(IICBUS(bktr), addr_h, 0);
	iicbus_write_byte(IICBUS(bktr), addr_l, 0);

	iicbus_repeated_start(IICBUS(bktr), i2c_addr +1, 0 /* no timeout? */);
	iicbus_read(IICBUS(bktr), data_read, 2, &read, IIC_LAST_READ, 0);
	iicbus_stop(IICBUS(bktr));

	data = (data_read[0]<<8) | data_read[1];

	return (data);
}

/* Reset the MSP or DPL chip */
/* The user can block the reset (which is handy if you initialise the
 * MSP and/or DPL audio in another operating system first (eg in Windows)
 */
void
msp_dpl_reset( bktr_ptr_t bktr, int i2c_addr )
{

#ifndef BKTR_NO_MSP_RESET
	/* put into reset mode */
	iicbus_start(IICBUS(bktr), i2c_addr, 0 /* no timeout? */);
	iicbus_write_byte(IICBUS(bktr), 0x00, 0);
	iicbus_write_byte(IICBUS(bktr), 0x80, 0);
	iicbus_write_byte(IICBUS(bktr), 0x00, 0);
	iicbus_stop(IICBUS(bktr));

	/* put back to operational mode */
	iicbus_start(IICBUS(bktr), i2c_addr, 0 /* no timeout? */);
	iicbus_write_byte(IICBUS(bktr), 0x00, 0);
	iicbus_write_byte(IICBUS(bktr), 0x00, 0);
	iicbus_write_byte(IICBUS(bktr), 0x00, 0);
	iicbus_stop(IICBUS(bktr));
#endif
	return;
}

static void remote_read(bktr_ptr_t bktr, struct bktr_remote *remote) {
	int read;

	/* XXX errors ignored */
	iicbus_start(IICBUS(bktr), bktr->remote_control_addr, 0 /* no timeout? */);
	iicbus_read(IICBUS(bktr),  remote->data, 3, &read, IIC_LAST_READ, 0);
	iicbus_stop(IICBUS(bktr));

	return;
}

#else /* defined(BKTR_USE_FREEBSD_SMBUS) */

a3838 3
#endif /* defined(BKTR_USE_FREEBSD_SMBUS) */


a3905 5


#define ABSENT		(-1)

#endif /* FreeBSD, BSDI, NetBSD, OpenBSD */
@


1.21
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.20 2006/12/29 13:04:37 pedro Exp $	*/
d813 1
a813 7
#ifndef __OpenBSD__
		if (bktr->vbi_select.si_pid) {
#else
		if (bktr->vbi_select.si_selpid) {
#endif
			selwakeup(&bktr->vbi_select);
		}
@


1.20
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.19 2006/01/20 18:14:17 millert Exp $	*/
a96 4

#ifndef __OpenBSD__
#include "opt_bktr.h"		/* Include any kernel config options */
#endif
@


1.19
log
@Include sys/stdint.h instead of defining uintptr_t ourselves.
OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.18 2005/11/15 14:33:29 robert Exp $	*/
d2881 1
a2881 1
	    ((void *)loop_point - (void *)bktr->dma_prog));
@


1.18
log
@Undefine STATUS_SUM, because it is not needed, and it makes
bktr(4) work on alpha.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.17 2005/06/23 14:57:48 robert Exp $	*/
d196 1
d204 1
a206 6
#ifdef __OpenBSD__
typedef unsigned long uintptr_t;
typedef int intrmask_t;
#else
#include <sys/inttypes.h>		/* uintptr_t */
#endif
@


1.17
log
@Use proper type for 32 bit entity. s/long/int
This is needed for bktr(4) to work on sparc64.

testing and ok by mickey and Jacob Meuser <jakemsr@@jakemsr.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.16 2005/06/22 12:26:32 mickey Exp $	*/
d390 2
a391 1
#define STATUS_SUM
d393 1
d2299 1
a2299 2
        int                           pixfmt;
	unsigned int	              temp;
d2301 4
@


1.16
log
@apparently i got the last one reversed; from jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.15 2005/05/19 17:43:33 mickey Exp $	*/
d1349 1
a1349 1
		temp = *(unsigned long *)arg & BT848_IFORM_FORMAT;
d1389 1
a1389 1
		switch(*(unsigned long *)arg & METEOR_FORM_MASK ) {
d1909 1
a1909 1
		temp = tv_channel( bktr, (int)*(unsigned long *)arg );
d1914 1
a1914 1
		*(unsigned long *)arg = temp;
d1929 1
a1929 1
		*(unsigned long *)arg = bktr->tuner.channel;
d1933 1
a1933 1
		temp = *(unsigned long *)arg;
d1940 1
a1940 1
		*(unsigned long *)arg = bktr->tuner.chnlset;
d1945 1
a1945 1
		*(unsigned long *)arg = temp & 0xff;
d1950 1
a1950 1
		temp = tv_freq( bktr, (int)*(unsigned long *)arg, TV_FREQUENCY);
d1956 1
a1956 1
		*(unsigned long *)arg = temp;
d1971 1
a1971 1
		*(unsigned long *)arg = bktr->tuner.frequency;
d2312 1
a2312 1
		switch(*(unsigned long *)arg & METEOR_DEV_MASK) {
@


1.15
log
@no need for BKTR_NO_OPEN_RESET option now that all tuners sw has been fixed; from jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.14 2005/04/14 12:25:31 mickey Exp $	*/
d618 6
d626 1
a1099 16
	bktr->tuner.frequency = 0;
	bktr->tuner.channel = 0;
	bktr->tuner.chnlset = DEFAULT_CHNLSET;
	bktr->tuner.afc = 0;
	bktr->tuner.radio_mode = 0;

	/* enable drivers on the GPIO port that control the MUXes */
	OUTL(bktr, BKTR_GPIO_OUT_EN,
	    INL(bktr, BKTR_GPIO_OUT_EN) | bktr->card.gpio_mux_bits);

	/* unmute the audio stream */
	set_audio( bktr, AUDIO_UNMUTE );

	/* Initialise any audio chips, eg MSP34xx or TDA98xx */
	init_audio_devices( bktr );

a1139 7

	/* mute the audio by switching the mux */
	set_audio( bktr, AUDIO_MUTE );

	/* disable drivers on the GPIO port that control the MUXes */
	OUTL(bktr, BKTR_GPIO_OUT_EN,
	    INL(bktr, BKTR_GPIO_OUT_EN) & ~bktr->card.gpio_mux_bits);
@


1.14
log
@do not reset tuner and audio settings on open/close; from jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.13 2004/06/29 12:24:57 mickey Exp $	*/
a619 9

#ifdef BKTR_NO_OPEN_RESET
	/* enable drivers on the GPIO port that control the MUXes */
	OUTL(bktr, BKTR_GPIO_OUT_EN, INL(bktr, BKTR_GPIO_OUT_EN) | bktr->card.gpio_mux_bits);

	/* mute the audio stream */
	set_audio( bktr, AUDIO_MUTE );
#endif

d995 2
a996 1
	OUTB(bktr, BKTR_IFORM, INB(bktr, BKTR_IFORM) | format_params[bktr->format_params].iform_xtsel);
d1021 2
a1022 1
	OUTB(bktr, BKTR_COLOR_CTL, BT848_COLOR_CTL_GAMMA | BT848_COLOR_CTL_RGB_DED);
d1052 3
a1054 3
	OUTL(bktr, BKTR_INT_MASK, BT848_INT_MYSTERYBIT);	/* if you take this out triton
                                                   based motherboards will
						   operate unreliably */
a1092 1
#ifndef BKTR_NO_OPEN_RESET
d1100 2
a1101 1
	OUTL(bktr, BKTR_GPIO_OUT_EN, INL(bktr, BKTR_GPIO_OUT_EN) | bktr->card.gpio_mux_bits);
a1107 1
#endif
a1149 1
#ifndef BKTR_NO_OPEN_RESET
d1154 2
a1155 2
	OUTL(bktr, BKTR_GPIO_OUT_EN, INL(bktr, BKTR_GPIO_OUT_EN) & ~bktr->card.gpio_mux_bits);
#endif
@


1.13
log
@do not use u_long for 32bit data; found by Jacob Meuser
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.12 2004/05/24 21:59:28 mickey Exp $	*/
d620 9
d1099 2
d1115 1
d1158 1
d1164 1
@


1.12
log
@cummulative update from freebsd an netbsd:
PCI_VENROD_PINNACLE -> PCI_VENDOR_PINNACLE_ALT;
correct brightness ioctl; missing htole32s;
fix "set chroma comb" command in yuv422_prog();
use defines instead of magic numbers; fix statics and comments.
from jakemsr@@jakemsr.com
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.11 2003/03/12 00:28:54 mickey Exp $	*/
d346 1
a346 1
	u_long               meteor_format;
d391 1
a391 1
static u_long	status_sum = 0;
d413 1
a413 1
static int		oformat_meteor_to_bt( u_long format );
d473 1
a473 1
common_bktr_attach( bktr_ptr_t bktr, int unit, u_long pci_id, u_int rev )
d1436 1
a1436 1
		*(u_long *)arg = bktr->flags & METEOR_FORM_MASK;
d1441 1
a1441 1
	        *(u_long *)arg = INB(bktr, BKTR_IFORM) & BT848_IFORM_FORMAT;
d1893 5
a1897 5
	u_long          par;
	u_char          write;
	int             i2c_addr;
	int             i2c_port;
	u_long          data;
d2254 1
a2254 1
		par = *(u_long *)arg;
d2265 1
a2265 1
		*(u_long *)arg = (par & 0xffffff00) | ( data & 0xff );
d2410 1
a2410 1
		*(u_long *)arg = bktr->flags & METEOR_DEV_MASK;
d2629 1
a2629 1
 u_long flag, flag2;
d2840 1
a2840 1
		*dma_prog++ = (u_long) vtophys((caddr_t)bktr->vbidata +
d2936 1
a2936 1
		target_buffer = (u_long) bktr->video.addr;
d2941 1
a2941 1
		target_buffer = (u_long) vtophys(bktr->bigbuf);
d2986 1
a2986 1
		*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
d2999 1
a2999 1
		*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
d3011 1
a3011 1
		*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);
d3055 1
a3055 1
	*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;
d3073 2
a3074 2
	volatile u_long		target_buffer, buffer;
	volatile  u_long	*dma_prog;
d3089 1
a3089 1
	dma_prog = (u_long *) bktr->dma_prog;
d3099 1
a3099 1
		target_buffer = (u_long) bktr->video.addr;
d3102 1
a3102 1
		target_buffer = (u_long) vtophys(bktr->bigbuf);
d3132 1
a3132 1
		*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
d3144 1
a3144 1
		*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
d3156 1
a3156 1
		*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);
d3165 1
a3165 1
		target_buffer =	 (u_long) buffer + cols*2;
d3167 1
a3167 1
		dma_prog = (u_long * ) bktr->odd_dma_prog;
d3187 1
a3187 1
	*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
d3194 1
a3194 1
	*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
d3365 1
a3365 1
		target_buffer = (u_long) bktr->video.addr;
d3368 1
a3368 1
		target_buffer = (u_long) vtophys(bktr->bigbuf);
d3436 1
a3436 1
		target_buffer  = (u_long) buffer + cols;
d3837 1
a3837 1
static int oformat_meteor_to_bt( u_long format )
d4039 2
a4040 2
	u_long		x;
	u_long		data;
@


1.11
log
@a missing htole32 and a pasto; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.10 2003/02/11 19:20:28 mickey Exp $	*/
d454 1
a454 1
static int	common_ioctl( bktr_ptr_t bktr, ioctl_cmd_t cmd, caddr_t arg );
d1501 1
a1501 1
		*(u_char *)arg = INB(bktr, BKTR_BRIGHT);
d1628 1
a1628 1
			/* Clear the interrypt status register */
d1876 1
a1876 1
		return common_ioctl( bktr, cmd, arg );
d2295 1
a2295 1
		return common_ioctl( bktr, cmd, arg );
d2306 1
a2306 1
common_ioctl( bktr_ptr_t bktr, ioctl_cmd_t cmd, caddr_t arg )
d2493 1
a2493 1
		       r[i+3], INL(bktr, r[i+3]]));
d2551 2
a2552 1
bool_t notclipped (bktr_reg_t * bktr, int x, int width) {
d2579 2
a2580 1
bool_t getline(bktr_reg_t *bktr, int x ) {
d2838 1
a2838 1
		*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;
d2950 1
a2950 1
	/* contruct sync : for video packet format */
d3111 1
a3111 1
	*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM1);
d3127 1
a3127 1
		*dma_prog++ = htole32(OP_SYNC  | 1 << 24 | BKTR_VRE);
d3140 1
a3140 1
		*dma_prog++ = htole32(OP_SYNC  | 1 << 24 | BKTR_VRO);
d3152 1
a3152 1
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRO);
d3170 1
a3170 1
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 |  1 << 15 | BKTR_FM1);
d3183 1
a3183 1
	*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRE);
d3231 2
a3232 2
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | ~0x40); /* set chroma comb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | ~0x40);
d3254 1
a3254 1
	*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
d3269 1
a3269 1
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRE);  /*sync vre*/
d3281 1
a3281 1
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRO);  /*sync vre*/
d3293 1
a3293 1
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRO);
d3311 1
a3311 1
		*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
d3326 1
a3326 1
	*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRE);
d3377 1
a3377 1
	*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
d3397 1
a3397 1
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRE);  /*sync vre*/
d3409 1
a3409 1
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRO);  /*sync vro*/
d3421 1
a3421 1
		*dma_prog++ = htole32(OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRO);
d3438 1
a3438 1
		*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
d3457 1
a3457 1
	*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRE);
@


1.10
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.9 2003/01/21 19:55:13 mickey Exp $	*/
d2841 2
a2842 2
		*dma_prog++ = bktr->dm_vbidata->dm_segs->ds_addr +
				((i+MAX_VBI_LINES) * VBI_LINE_SIZE);
d2941 1
a2941 1
		*dma_prog++ = htole32(bktr->dm_mem->dm_segs->ds_addr);
@


1.9
log
@fix cut and paste piece in dma programming, caused jumpieness in animation; good diagnose by Kamil Andrusz <wizz@@mniam.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.8 2003/01/15 06:30:35 art Exp $	*/
d1008 1
a1008 1
	/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */
@


1.8
log
@Get rid of vm_offset_t in bktr.
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.7 2003/01/05 02:05:58 mickey Exp $	*/
d2889 1
a2889 1
	    ((void *)loop_point - (void *)dma_prog));
@


1.7
log
@proper endianess handling in 16 and 32 bit video modes, 24 bit is not supported by the card
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.6 2003/01/05 01:24:53 mickey Exp $	*/
d475 1
a475 1
	vm_offset_t	buf = 0;
d1289 1
a1289 1
	vm_offset_t		buf;
@


1.6
log
@endianess-free, works on macppc now, except for the fb endianess
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.5 2002/04/30 23:18:38 mickey Exp $	*/
d3802 9
d3813 3
a3815 2
	case 2 : swapf = ( pf->swap_bytes ? 0 : BSWAP );
		 break;
d3817 2
a3818 2
	case 3 : /* no swaps supported for 3bpp - makes no sense w/ bt848 */
		 break;
d3820 4
a3823 5
	case 4 : if ( pf->swap_bytes )
			swapf = pf->swap_shorts ? 0 : WSWAP;
		 else
			swapf = pf->swap_shorts ? BSWAP : (BSWAP | WSWAP);
		 break;
@


1.5
log
@constify a few structs
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.4 2002/03/14 03:16:06 millert Exp $	*/
d21 1
a21 1
   Jim Lowe's driver for the Matrox Meteor PCI card . The 
d31 1
a31 1
 * 1. Redistributions of source code must retain the 
d47 1
a47 1
 * 4. The name of the author may not be used to endorse or promote products 
d67 1
a67 1
 * 1. Redistributions of source code must retain the 
d82 1
a82 1
 * 4. The name of the author may not be used to endorse or promote products 
d199 1
a199 3
#else
#include <uvm/uvm_extern.h>			/* for vtophys */
#include <uvm/uvm_pmap.h>			/* for vtophys */
d201 1
d244 1
a244 1
   transfers into two dma requests 
d248 1
a248 1
/* 
d313 1
a313 1
 * Table of supported Pixel Formats 
d437 2
a438 3
static bool_t   notclipped(bktr_reg_t * , int , int);     
static bool_t   split(bktr_reg_t *, volatile u_long **, int, u_long, int, 
		      volatile u_char ** , int  );
d472 1
a472 1
void 
d482 1
a482 2
        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog,
				      DMA_PROG_ALLOC);
d484 1
a484 1
					  DMA_PROG_ALLOC);
d487 1
a487 2
	bktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata,
				      VBI_DATA_SIZE);
d489 1
a489 1
				       VBI_BUFFER_SIZE);
d492 1
a492 1
        if ( BROOKTREE_ALLOC )
d544 6
a549 1
			bktr_name(bktr), BROOKTREE_ALLOC, vtophys(buf));
d552 1
a552 1
	if ( buf != 0 ) {
d555 1
a555 1
		bzero((caddr_t) bktr->bigbuf, BROOKTREE_ALLOC);
a558 1
		
a569 1

a574 1
 
d577 1
a577 2
	if (PCI_VENDOR(pci_id) == PCI_VENDOR_BROOKTREE)
	{
d595 1
a595 1
	};
d616 1
a616 1
	probeCard( bktr, TRUE, unit );
d619 1
a619 2
	init_audio_devices( bktr );

d624 4
a627 4
 * The circular buffer holds 'n' fixed size data blocks. 
 * vbisize   is the number of bytes in the circular buffer 
 * vbiread   is the point we reading data out of the circular buffer 
 * vbiinsert is the point we insert data into the circular buffer 
d629 3
a631 1
static void vbidecode(bktr_ptr_t bktr) {
a653 1

a660 1

d670 1
a670 1
int 
d672 7
a678 9
{ 
	bktr_ptr_t		bktr;
	u_long			bktr_status;
	u_char			dstatus;
	u_long                  field;
	u_long                  w_field;
	u_long                  req_field;

	bktr = (bktr_ptr_t) arg;
d686 1
a686 1
	  	return 0;	/* bail out now, before we do something we
d721 2
a722 2
			      BT848_INT_OCERR  | BT848_INT_SCERR) ) != 0) 
		|| ((INB(bktr, BKTR_TDEC) == 0) && (bktr_status & TDEC_BITS)) ) { 
d734 1
a734 1
		
d750 1
d752 3
d786 1
a786 1
	 * This can happen when we are in the process of closing or 
a791 1

a794 1

d800 2
a801 3
	if (  (bktr->vbiflags & VBI_CAPTURE)
	    &&(bktr->vbiflags & VBI_OPEN)
            &&(field==EVEN_F)) {
d803 1
a803 1
               	vbidecode(bktr);
d808 1
a808 1
          	     	wakeup(VBI_SLEEP);
a818 2


d834 1
a834 1
		default                      : req_field = (ODD_F|EVEN_F);  
d875 1
a875 1
		 * post the completion time. 
d879 1
a879 1
			
d890 1
a890 1
	
d950 1
a950 1
 * 
d979 1
a979 1
	if (bt848_format == 0 ) 
d982 1
a982 1
	if (bt848_format == 1 ) 
d1051 1
a1051 1
                                                   based motherboards will 
d1078 1
a1078 1
 * 
d1084 1
a1084 1
		return( ENXIO );	
d1104 1
a1104 1
	
d1112 1
a1112 1
 * 
d1183 1
a1183 1
	count = bktr->rows * bktr->cols * 
d1220 1
a1220 1
 * vbisize is the exact number of bytes in the buffer left to read 
d1241 1
a1241 1
			
d1255 1
a1255 1
               	status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);
d1316 2
a1317 4
             
                
	    if (bktr->max_clip_node == 0 && 
		(bktr->clip_list[0].y_min != 0 && 
d1339 1
a1339 1
		    bktr->clip_list[i].x_max < 0 || 
d1393 1
a1393 1
		bktr->dma_prog_loaded = FALSE;		
d1405 1
a1405 1
			OUTB(bktr, BKTR_IFORM, temp_iform | BT848_IFORM_F_NTSCM | 
d1432 1
a1432 1
		bktr->dma_prog_loaded = FALSE;		
d1443 1
a1443 1
 
d1497 1
a1497 1
		
d1593 1
a1593 1
			     		    BT848_INT_RISCI      |
d1619 2
a1620 2
			if (bktr->bigbuf==0)	/* no frame buffer allocated */
				return( ENOMEM );
d1643 1
a1643 1
		
d1755 1
a1755 1
#endif                                          
d1760 5
a1764 5
						printf(
				"%s: ioctl: Allocating %d bytes\n",
							bktr_name(bktr), temp*PAGE_SIZE);
				}
				else
d1789 1
a1789 1
                                    if (geo->oformat & METEOR_GEO_YUV_12) 
d1854 1
a1854 1
 
d1857 1
a1857 1
   
d1907 1
a1907 1
#if defined( TUNER_AFC )
d2216 1
a2216 1
 	case RADIO_GETFREQ:
d2252 1
a2252 1
	/* Luigi's I2CWR ioctl */ 
d2259 2
a2260 2
 
		if (write) { 
d2402 1
a2402 1
		  }	
d2423 1
a2423 1
	
d2435 1
a2435 1
		memcpy( pf_pub, &pixfmt_table[ pixfmt ].public, 
d2471 1
a2471 1
 * 
d2473 1
a2473 1
#ifdef BT848_DEBUG 
d2478 1
a2478 1
			   4,    8, 0xc, 0x8c, 0x10, 0x90, 0x14, 0x94, 
d2489 1
a2489 1
		       bktr_name(bktr), 
d2497 1
a2497 1
	       INL(bktr, BKTR_INT_STAT)); 
d2562 1
a2562 1
    
d2573 2
a2574 2
    }	
    
d2576 1
a2576 1
}	
d2581 2
a2582 2
    
    if (bktr->line_length == 0 || 
d2599 1
a2599 1
		
d2607 1
a2607 1
			}	
d2609 1
a2609 1
		}	
d2611 1
a2611 1
	    }	
d2621 5
a2625 4
    
static bool_t split(bktr_reg_t * bktr, volatile u_long **dma_prog, int width ,
		    u_long operation, int pixel_width,
		    volatile u_char ** target_buffer, int cols ) {
d2637 1
a2637 1
	  switch ( ((uintptr_t) (volatile void *) *target_buffer) % 4 ) {
d2649 1
a2649 1
       } else flag = 0;	
d2653 1
a2653 1
	     *(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;
d2658 3
a2660 3
     *(*dma_prog)++ = operation | flag  | (width * pixel_width - skip);
     if (operation != OP_SKIP ) 
	 *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer;
d2683 1
a2683 1
		*(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;
d2688 5
a2692 5
	*(*dma_prog)++ = operation  | flag |
	      (width * pixel_width / 2 - skip);
	if (operation != OP_SKIP ) 
	      *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer ;
	*target_buffer +=  (width * pixel_width / 2) ;
d2696 4
a2699 4
	*(*dma_prog)++ = operation | flag2 |
	    (width * pixel_width / 2);
	*target_buffer +=  (width * pixel_width / 2) ;
	  bktr->current_col += width;
d2702 2
a2703 1
 return TRUE;
d2711 1
a2711 1
rgb_vbi_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )
d2713 6
a2718 6
	int			i;
	volatile u_long		target_buffer, buffer, target,width;
	volatile u_long		pitch;
	volatile u_long		*dma_prog;	/* DMA prog is an array of 
						32 bit RISC instructions */
	volatile u_long		*loop_point;
d2720 4
a2723 4
	u_int                   Bpp = pf_int->public.Bpp;
	unsigned int            vbisamples;     /* VBI samples per line */
	unsigned int            vbilines;       /* VBI lines per field */
	unsigned int            num_dwords;     /* DWORDS per line */
d2737 2
a2738 2
 	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
 	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);
d2742 2
a2743 2
 	/* disable gamma correction removal */
 	OUTB(bktr, BKTR_COLOR_CTL, INB(bktr, BKTR_COLOR_CTL) | BT848_COLOR_CTL_GAMMA);
d2754 1
a2754 1
	dma_prog = (u_long *) bktr->dma_prog;
d2759 1
a2759 1
		target_buffer = (u_long) bktr->video.addr;
d2763 5
a2767 1
		target_buffer = (u_long) vtophys(bktr->bigbuf);
d2776 2
a2777 2
	*dma_prog++ = OP_SYNC | BKTR_RESYNC |BKTR_VRE;
	*dma_prog++ = 0;
d2783 2
a2784 2
	*dma_prog++ = OP_SYNC | BKTR_FM1;
	*dma_prog++ = 0;
d2786 6
a2791 2
		*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;
		*dma_prog++ = (u_long) vtophys((caddr_t)bktr->vbidata +
d2793 1
d2796 1
a2796 1
	if ( (i_flag == 2/*Odd*/) || (i_flag==3) /*interlaced*/ ) { 
d2799 2
a2800 2
		*dma_prog++ = OP_SYNC  | BKTR_FM1;
		*dma_prog++ = 0;  /* NULL WORD */
d2805 3
a2807 4
			split(bktr, (volatile u_long **) &dma_prog,
			      bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, (volatile u_char **) &target,  cols);
	
d2811 2
a2812 3
				split(bktr, (volatile u_long **) &dma_prog,
				      bktr->y2 - bktr->y, OP_WRITE,
				      Bpp, (volatile u_char **) &target, cols);
d2815 2
a2816 4
				split(bktr,(volatile u_long **) &dma_prog,
				      bktr->yclip2 - bktr->yclip,
				      OP_SKIP,
				      Bpp, (volatile u_char **) &target,  cols);
a2818 1
			
d2820 1
a2820 1
	
a2821 1
	
d2828 2
a2829 2
	*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;
	*dma_prog++ = 0;  /* NULL WORD */
d2833 2
a2834 2
	*dma_prog++ = OP_SYNC | BKTR_FM1;
	*dma_prog++ = 0;
d2837 1
d2840 4
d2855 2
a2856 2
		*dma_prog++ = OP_SYNC | BKTR_FM1;
		*dma_prog++ = 0;  /* NULL WORD */
d2861 2
a2862 3
			split(bktr, (volatile u_long **) &dma_prog,
			      bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, (volatile u_char **) &target,  cols);
d2866 3
a2868 5
				split(bktr, (volatile u_long **) &dma_prog,
				      bktr->y2 - bktr->y, OP_WRITE,
				      Bpp, (volatile u_char **) &target,
				      cols);
			    }	
d2870 4
a2873 7
				split(bktr, (volatile u_long **) &dma_prog,
				      bktr->yclip2 - bktr->yclip, OP_SKIP,
				      Bpp, (volatile u_char **)  &target,  cols);
			    }	

			}	

a2876 1

d2881 2
a2882 2
	*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;
	*dma_prog++ = 0;  /* NULL WORD */
d2884 8
a2891 3
	*dma_prog++ = OP_JUMP ;
	*dma_prog++ = (u_long ) vtophys(loop_point) ;
	*dma_prog++ = 0;  /* NULL WORD */
a2894 3



d2898 4
a2901 4
	int			i;
	volatile u_long		target_buffer, buffer, target,width;
	volatile u_long		pitch;
	volatile  u_long	*dma_prog;
d2912 2
a2913 2
 	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
 	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);
d2917 1
a2917 1
 	/* disable gamma correction removal */
d2929 1
a2929 1
	dma_prog = (u_long *) bktr->dma_prog;
d2938 1
d2940 3
d2949 1
a2949 1
	*dma_prog++ = OP_SYNC  | BKTR_RESYNC | BKTR_FM1;
d2952 1
a2952 1
	*dma_prog++ = 0;  /* NULL WORD */
d2957 2
a2958 3
		split(bktr, (volatile u_long **) &dma_prog,
		      bktr->y2 - bktr->y, OP_WRITE,
		      Bpp, (volatile u_char **) &target,  cols);
d2963 2
a2964 3
			split(bktr, (volatile u_long **) &dma_prog,
			      bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, (volatile u_char **) &target, cols);
d2967 2
a2968 4
			split(bktr,(volatile u_long **) &dma_prog,
			      bktr->yclip2 - bktr->yclip,
			      OP_SKIP,
			      Bpp, (volatile u_char **) &target,  cols);
a2970 1

a2973 1

d2979 2
a2980 2
		*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO;
		*dma_prog++ = 0;  /* NULL WORD */
d2982 2
a2983 1
		*dma_prog++ = OP_JUMP;
d2985 3
d2992 2
a2993 2
		*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE;
		*dma_prog++ = 0;  /* NULL WORD */
d2995 2
a2996 1
		*dma_prog++ = OP_JUMP;
d2998 3
d3005 4
a3008 3
		*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;
		*dma_prog++ = 0;  /* NULL WORD */
		*dma_prog++ = OP_JUMP; ;
d3010 3
d3018 1
a3018 1
	        target_buffer = buffer + pitch; 
d3020 1
a3020 1
		dma_prog = (u_long *) bktr->odd_dma_prog;
d3023 2
a3024 2
		*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;
		*dma_prog++ = 0;  /* NULL WORD */
d3029 2
a3030 3
			split(bktr, (volatile u_long **) &dma_prog,
			      bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, (volatile u_char **) &target,  cols);
d3034 3
a3036 5
				split(bktr, (volatile u_long **) &dma_prog,
				      bktr->y2 - bktr->y, OP_WRITE,
				      Bpp, (volatile u_char **) &target,
				      cols);
			    }	
d3038 4
a3041 7
				split(bktr, (volatile u_long **) &dma_prog,
				      bktr->yclip2 - bktr->yclip, OP_SKIP,
				      Bpp, (volatile u_char **)  &target,  cols);
			    }	

			}	

a3044 1

d3049 4
a3052 3
	*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;
	*dma_prog++ = 0;  /* NULL WORD */
	*dma_prog++ = OP_JUMP ;
d3054 4
a3057 1
	*dma_prog++ = 0;  /* NULL WORD */
d3062 1
a3062 1
 * 
d3090 1
a3090 1
    
d3099 1
d3101 3
d3109 2
a3110 2
	*dma_prog++ = OP_SYNC | 1 << 15 | BKTR_FM1;
	*dma_prog++ = 0;  /* NULL WORD */
d3115 4
a3118 4
		*dma_prog++ = inst;
		*dma_prog++ = target_buffer;
		*dma_prog++ = inst3;
		*dma_prog++ = target_buffer + b; 
d3125 2
a3126 2
		*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;
		*dma_prog++ = 0;  /* NULL WORD */
d3128 2
a3129 1
		*dma_prog++ = OP_JUMP;
d3131 3
d3138 4
a3141 3
		*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;
		*dma_prog++ = 0;  /* NULL WORD */
		*dma_prog++ = OP_JUMP;
d3143 3
d3150 4
a3153 3
		*dma_prog++ = OP_SYNC	 | 1 << 24 | 1 << 15 | BKTR_VRO;
		*dma_prog++ = 0;  /* NULL WORD */
		*dma_prog++ = OP_JUMP  ;
d3155 3
d3168 2
a3169 2
		*dma_prog++ = OP_SYNC | 1 << 24 |  1 << 15 | BKTR_FM1;
		*dma_prog++ = 0;  /* NULL WORD */
d3172 4
a3175 4
			*dma_prog++ = inst;
			*dma_prog++ = target_buffer;
			*dma_prog++ = inst3;
			*dma_prog++ = target_buffer + b;
d3181 4
a3184 3
	*dma_prog++ = OP_SYNC   |  1 << 24  | 1 << 15 |  BKTR_VRE;
	*dma_prog++ = 0;  /* NULL WORD */
	*dma_prog++ = OP_JUMP ;
d3186 3
d3190 2
a3191 1
	*dma_prog++ = OP_JUMP;
d3193 4
a3196 1
	*dma_prog++ = 0;  /* NULL WORD */
d3201 1
a3201 1
 * 
d3204 6
a3209 7
yuv422_prog( bktr_ptr_t bktr, char i_flag,
	     int cols, int rows, int interlace ){

	int			i;
	volatile unsigned int	inst;
	volatile u_long		target_buffer, t1, buffer;
	volatile u_long		*dma_prog;
d3214 1
a3214 1
	dma_prog = (u_long *) bktr->dma_prog;
d3236 1
a3236 1
	inst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); 
d3238 1
a3238 1
		target_buffer = (u_long) bktr->video.addr;
d3240 6
a3245 2
		target_buffer = (u_long) vtophys(bktr->bigbuf);
    
d3251 3
a3253 2
	*dma_prog++ = OP_SYNC  | 1 << 15 |	BKTR_FM3; /*sync, mode indicator packed data*/
	*dma_prog++ = 0;  /* NULL WORD */
d3256 6
a3261 5
		*dma_prog++ = inst;
		*dma_prog++ = cols/2 | cols/2 << 16;
		*dma_prog++ = target_buffer;
		*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;
		*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;
d3267 2
a3268 2
		*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/
		*dma_prog++ = 0;  /* NULL WORD */
d3270 6
a3275 2
		*dma_prog++ = OP_JUMP ;
		*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
d3279 2
a3280 2
		*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vre*/
		*dma_prog++ = 0;  /* NULL WORD */
d3282 6
a3287 2
		*dma_prog++ = OP_JUMP;
		*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
d3291 2
a3292 2
		*dma_prog++ = OP_SYNC	| 1 << 24 |  1 << 15 |   BKTR_VRO; 
		*dma_prog++ = 0;  /* NULL WORD */
d3294 6
a3299 2
		*dma_prog++ = OP_JUMP  ;
		*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);
d3305 1
a3305 1
		dma_prog = (u_long * ) bktr->odd_dma_prog;
d3307 1
a3307 1
		target_buffer  = (u_long) buffer + cols;
d3309 2
a3310 2
		*dma_prog++ = OP_SYNC	|   1 << 15 | BKTR_FM3; 
		*dma_prog++ = 0;  /* NULL WORD */
d3313 7
a3319 5
			*dma_prog++ = inst;
			*dma_prog++ = cols/2 | cols/2 << 16;
			*dma_prog++ = target_buffer;
			*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;
			*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;
d3323 10
a3332 6
    
	*dma_prog++ = OP_SYNC  | 1 << 24 | 1 << 15 |   BKTR_VRE; 
	*dma_prog++ = 0;  /* NULL WORD */
	*dma_prog++ = OP_JUMP ;
	*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;
	*dma_prog++ = 0;  /* NULL WORD */
d3337 1
a3337 1
 * 
d3343 5
a3347 5
	int			i;
	volatile unsigned int	inst;
	volatile unsigned int	inst1;
	volatile u_long		target_buffer, t1, buffer;
	volatile u_long		*dma_prog;
d3352 1
a3352 1
	dma_prog = (u_long *) bktr->dma_prog;
d3358 1
a3358 1
 
d3360 11
a3370 7
 	inst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); 
 	inst1  = OP_WRITES123  | OP_SOL | OP_EOL |  (cols); 
 	if (bktr->video.addr)
 		target_buffer = (u_long) bktr->video.addr;
 	else
 		target_buffer = (u_long) vtophys(bktr->bigbuf);
     
d3372 33
a3404 23
 	t1 = buffer;
 
 	*dma_prog++ = OP_SYNC  | 1 << 15 |	BKTR_FM3; /*sync, mode indicator packed data*/
 	*dma_prog++ = 0;  /* NULL WORD */
 	       
 	for (i = 0; i < (rows/interlace )/2 ; i++) {
		*dma_prog++ = inst;
 		*dma_prog++ = cols/2 | (cols/2 << 16);
 		*dma_prog++ = target_buffer;
 		*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;
 		*dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;
 		target_buffer += interlace*cols;
 		*dma_prog++ = inst1;
 		*dma_prog++ = cols/2 | (cols/2 << 16);
 		*dma_prog++ = target_buffer;
 		target_buffer += interlace*cols;
 
 	}
 
 	switch (i_flag) {
 	case 1:
 		*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/
 		*dma_prog++ = 0;  /* NULL WORD */
d3406 3
a3408 3
		*dma_prog++ = OP_JUMP;
		*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
 		return;
d3410 7
a3416 3
 	case 2:
 		*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vro*/
 		*dma_prog++ = 0;  /* NULL WORD */
d3418 9
a3426 9
		*dma_prog++ = OP_JUMP;
		*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
 		return;
 
 	case 3:
 		*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRO;
		*dma_prog++ = 0;  /* NULL WORD */
		*dma_prog++ = OP_JUMP ;
		*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);
d3432 1
a3432 1
		dma_prog = (u_long * ) bktr->odd_dma_prog;
d3436 2
a3437 2
		*dma_prog++ = OP_SYNC   | 1 << 15 | BKTR_FM3; 
		*dma_prog++ = 0;  /* NULL WORD */
d3440 24
a3463 21
		    *dma_prog++ = inst;
		    *dma_prog++ = cols/2 | (cols/2 << 16);
         	    *dma_prog++ = target_buffer;
		    *dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;
		    *dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;
		    target_buffer += interlace*cols;
		    *dma_prog++ = inst1;
		    *dma_prog++ = cols/2 | (cols/2 << 16);
		    *dma_prog++ = target_buffer;
		    target_buffer += interlace*cols;

		}	

	
	}
    
	*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRE;
	*dma_prog++ = 0;  /* NULL WORD */
	*dma_prog++ = OP_JUMP;
	*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);
	*dma_prog++ = 0;  /* NULL WORD */
a3464 1
  
d3468 1
a3468 1
 * 
d3475 1
a3475 1
	unsigned int		temp;	
d3478 1
a3478 1
	
d3500 1
a3500 1
 
d3510 1
a3510 1
 
d3572 1
a3572 1
 
d3598 1
a3598 1
	        bktr->bktr_cap_ctl = 
d3605 1
a3605 1
 	        bktr->bktr_cap_ctl =
d3612 1
a3612 1
 	        bktr->bktr_cap_ctl = 
d3621 1
d3623 3
d3681 1
a3681 1
 * 
d3693 1
a3693 1
		bzero((caddr_t)bktr->bigbuf, 
a3731 1
	
d3733 2
d3736 3
a3738 1

d3743 1
a3743 1
 * 
d3786 2
a3787 2
/* 
 * Given a pixfmt index, compute the bt848 swap_flags necessary to 
d3789 4
a3792 4
 * Note that without bt swapping, 2Bpp and 3Bpp modes are written 
 *   byte-swapped, and 4Bpp modes are byte and word swapped (see Table 6 
 *   and read R->L).  
 * Note also that for 3Bpp, we may additionally need to do some creative 
d3809 1
a3809 1
		 
d3821 1
a3821 1
/* 
d3848 1
a3848 1
		    ( pf1->swap_shorts == pf2->swap_shorts )) 
d3862 2
a3863 2
#define I2CBITTIME		(0x5<<4)	/* 5 * 0.48uS */
#define I2CBITTIME_878              (1 << 7)
d3865 1
a3865 1
#define I2C_COMMAND		(I2CBITTIME |			\
d3869 1
a3869 1
#define I2C_COMMAND_878		(I2CBITTIME_878 |			\
d4066 1
a4066 1
 * 
d4071 1
a4071 1
	u_long		x;
d4078 1
a4078 1
	   
d4081 1
a4081 1
	    bktr->id == BROOKTREE_849A) {
d4083 1
a4083 1
	} else {
a4084 1
	}
d4087 2
a4088 2
	for ( x = 0x7fffffff; x; --x ) {	/* safety valve */
		if ( INL(bktr, BKTR_INT_STAT) & BT848_INT_I2CDONE )
a4089 1
	}
d4092 2
a4093 2
	if ( !x || !(INL(bktr, BKTR_INT_STAT) & BT848_INT_RACK) )
		return( -1 );
d4096 2
a4097 1
	return( (INL(bktr, BKTR_I2C_DATA_CTL) >> 8) & 0xff );
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.3 2001/11/06 19:53:19 miod Exp $	*/
d286 1
a286 1
static struct format_params format_params[] = {
d317 1
a317 1
static struct meteor_pixfmt_internal {
d346 1
a346 1
static struct {
d2636 1
a2636 1
 struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;
d2726 1
a2726 1
        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d2906 1
a2906 1
        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3070 1
a3070 1
        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3184 1
a3184 1
        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3298 1
a3298 1
        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3406 2
a3407 2
	struct format_params	*fp;
        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3613 1
a3613 1
	struct format_params   *fp;
d3671 1
a3671 1
	struct format_params	*fp;
d3723 1
a3723 1
	struct meteor_pixfmt *pf = &pixfmt_table[ pixfmt ].public;
d3752 1
a3752 1
        struct meteor_pixfmt *pf1, *pf2;
@


1.3
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.2 2001/09/22 19:44:37 mickey Exp $	*/
d643 1
a643 1
        memcpy(dest, (unsigned char*)bktr->vbidata, VBI_DATA_SIZE);
d1369 1
a1369 1
		temp = *(unsigned long*)arg & BT848_IFORM_FORMAT;
d1998 1
a1998 1
		if ( set_audio( bktr, *(int*)arg ) < 0 )
d2004 1
a2004 1
		OUTB(bktr, BKTR_HUE, (u_char)(*(int*)arg & 0xff));
d2008 1
a2008 1
		*(int*)arg = (signed char)(INB(bktr, BKTR_HUE) & 0xff);
d2022 1
a2022 1
		tmp_int = *(int*)arg;
d2049 1
a2049 1
		*(int*)arg = tmp_int;
d2054 1
a2054 1
		tmp_int = *(int*)arg;
d2076 1
a2076 1
		*(int*)arg = tmp_int;
d2081 1
a2081 1
		tmp_int = *(int*)arg;
d2103 1
a2103 1
		*(int*)arg = tmp_int;
d2123 1
a2123 1
		tmp_int = *(int*)arg;
d2145 1
a2145 1
		*(int*)arg = tmp_int;
d2164 1
a2164 1
		*(int*)arg = temp;
d2168 1
a2168 1
		if ( set_BTSC( bktr, *(int*)arg ) < 0 )
d2199 1
a2199 1
                *(int*)arg = INL(bktr, BKTR_GPIO_OUT_EN);
d2203 1
a2203 1
                OUTL(bktr, BKTR_GPIO_OUT_EN, *(int*)arg);
d2207 1
a2207 1
                *(int*)arg = INL(bktr, BKTR_GPIO_DATA);
d2211 1
a2211 1
                OUTL(bktr, BKTR_GPIO_DATA, *(int*)arg);
d2459 1
a2459 1
		*(u_int*)arg = temp;
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.3 2001/11/06 19:53:19 miod Exp $	*/
d286 1
a286 1
static const struct format_params format_params[] = {
d317 1
a317 1
static const struct meteor_pixfmt_internal {
d346 1
a346 1
static const struct {
d643 1
a643 1
        memcpy(dest, (unsigned char *)bktr->vbidata, VBI_DATA_SIZE);
d1369 1
a1369 1
		temp = *(unsigned long *)arg & BT848_IFORM_FORMAT;
d1998 1
a1998 1
		if ( set_audio( bktr, *(int *)arg ) < 0 )
d2004 1
a2004 1
		OUTB(bktr, BKTR_HUE, (u_char)(*(int *)arg & 0xff));
d2008 1
a2008 1
		*(int *)arg = (signed char)(INB(bktr, BKTR_HUE) & 0xff);
d2022 1
a2022 1
		tmp_int = *(int *)arg;
d2049 1
a2049 1
		*(int *)arg = tmp_int;
d2054 1
a2054 1
		tmp_int = *(int *)arg;
d2076 1
a2076 1
		*(int *)arg = tmp_int;
d2081 1
a2081 1
		tmp_int = *(int *)arg;
d2103 1
a2103 1
		*(int *)arg = tmp_int;
d2123 1
a2123 1
		tmp_int = *(int *)arg;
d2145 1
a2145 1
		*(int *)arg = tmp_int;
d2164 1
a2164 1
		*(int *)arg = temp;
d2168 1
a2168 1
		if ( set_BTSC( bktr, *(int *)arg ) < 0 )
d2199 1
a2199 1
                *(int *)arg = INL(bktr, BKTR_GPIO_OUT_EN);
d2203 1
a2203 1
                OUTL(bktr, BKTR_GPIO_OUT_EN, *(int *)arg);
d2207 1
a2207 1
                *(int *)arg = INL(bktr, BKTR_GPIO_DATA);
d2211 1
a2211 1
                OUTL(bktr, BKTR_GPIO_DATA, *(int *)arg);
d2459 1
a2459 1
		*(u_int *)arg = temp;
d2636 1
a2636 1
 const struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;
d2726 1
a2726 1
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d2906 1
a2906 1
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3070 1
a3070 1
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3184 1
a3184 1
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3298 1
a3298 1
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3406 2
a3407 2
	const struct format_params *fp;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3613 1
a3613 1
	const struct format_params   *fp;
d3671 1
a3671 1
	const struct format_params	*fp;
d3723 1
a3723 1
	const struct meteor_pixfmt *pf = &pixfmt_table[ pixfmt ].public;
d3752 1
a3752 1
        const struct meteor_pixfmt *pf1, *pf2;
@


1.3.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d21 1
a21 1
   Jim Lowe's driver for the Matrox Meteor PCI card . The
d31 1
a31 1
 * 1. Redistributions of source code must retain the
d47 1
a47 1
 * 4. The name of the author may not be used to endorse or promote products
d67 1
a67 1
 * 1. Redistributions of source code must retain the
d82 1
a82 1
 * 4. The name of the author may not be used to endorse or promote products
d199 3
a201 1
#endif
a202 1
#ifdef __OpenBSD__
d245 1
a245 1
   transfers into two dma requests
d249 1
a249 1
/*
d314 1
a314 1
 * Table of supported Pixel Formats
d438 3
a440 2
static bool_t   notclipped(bktr_reg_t * , int , int);
static bool_t   split(bktr_reg_t *, u_int **, int, u_int, int, u_int * , int);
d474 1
a474 1
void
d477 1
a477 1
	vaddr_t	buf = 0;
d484 2
a485 1
        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);
d487 1
a487 1
	    DMA_PROG_ALLOC);
d490 2
a491 1
	bktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);
d493 1
a493 1
	    VBI_BUFFER_SIZE);
d496 1
a496 1
        if (BROOKTREE_ALLOC)
d548 1
a548 6
			bktr_name(bktr), BROOKTREE_ALLOC,
#ifdef __FreeBSD__
			vtophys(buf));
#else
			bktr->dm_prog->dm_segs->ds_addr);
#endif
d551 1
a551 1
	if (buf != 0) {
d554 1
a554 1
		bzero((void *)bktr->bigbuf, BROOKTREE_ALLOC);
d558 1
d570 1
d576 1
d579 2
a580 1
	if (PCI_VENDOR(pci_id) == PCI_VENDOR_BROOKTREE) {
d598 1
a598 1
	}
d619 1
a619 1
	probeCard(bktr, TRUE, unit);
d622 2
a623 1
	init_audio_devices(bktr);
d628 4
a631 4
 * The circular buffer holds 'n' fixed size data blocks.
 * vbisize   is the number of bytes in the circular buffer
 * vbiread   is the point we reading data out of the circular buffer
 * vbiinsert is the point we insert data into the circular buffer
d633 1
a633 3
static void
vbidecode(bktr_ptr_t bktr)
{
d656 1
d664 1
d674 1
a674 1
int
d676 9
a684 7
{
	bktr_ptr_t	bktr = (bktr_ptr_t) arg;
	u_int	bktr_status;
	u_char	dstatus;
	u_int	field;
	u_int	w_field;
	u_int	req_field;
d692 1
a692 1
		return 0;	/* bail out now, before we do something we
d727 2
a728 2
			      BT848_INT_OCERR  | BT848_INT_SCERR) ) != 0)
		|| ((INB(bktr, BKTR_TDEC) == 0) && (bktr_status & TDEC_BITS)) ) {
d740 1
a740 1

a755 1
#ifdef __FreeBSD__
a756 3
#else
		OUTL(bktr, BKTR_RISC_STRT_ADD, bktr->dm_prog->dm_segs->ds_addr);
#endif
d788 1
a788 1
	 * This can happen when we are in the process of closing or
d794 1
d798 1
d804 3
a806 2
	if ((bktr->vbiflags & (VBI_CAPTURE|VBI_OPEN)) ==
	    (VBI_CAPTURE|VBI_OPEN) && (field == EVEN_F)) {
d808 1
a808 1
		vbidecode(bktr);
d813 1
a813 1
			wakeup(VBI_SLEEP);
d824 2
d841 1
a841 1
		default                      : req_field = (ODD_F|EVEN_F);
d882 1
a882 1
		 * post the completion time.
d886 1
a886 1

d897 1
a897 1

d957 1
a957 1
 *
d986 1
a986 1
	if (bt848_format == 0 )
d989 1
a989 1
	if (bt848_format == 1 )
d1015 1
a1015 1
	/* enable PLL mode using 28MHz crystal for PAL/SECAM users */
d1058 1
a1058 1
                                                   based motherboards will
d1085 1
a1085 1
 *
d1091 1
a1091 1
		return( ENXIO );
d1111 1
a1111 1

d1119 1
a1119 1
 *
d1190 1
a1190 1
	count = bktr->rows * bktr->cols *
d1227 1
a1227 1
 * vbisize is the exact number of bytes in the buffer left to read
d1248 1
a1248 1

d1262 1
a1262 1
		status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);
d1296 1
a1296 1
	vaddr_t			buf;
d1323 4
a1326 2
	    if (bktr->max_clip_node == 0 &&
		(bktr->clip_list[0].y_min != 0 &&
d1348 1
a1348 1
		    bktr->clip_list[i].x_max < 0 ||
d1402 1
a1402 1
		bktr->dma_prog_loaded = FALSE;
d1414 1
a1414 1
			OUTB(bktr, BKTR_IFORM, temp_iform | BT848_IFORM_F_NTSCM |
d1441 1
a1441 1
		bktr->dma_prog_loaded = FALSE;
d1452 1
a1452 1

d1506 1
a1506 1

d1602 1
a1602 1
					    BT848_INT_RISCI      |
d1628 2
a1629 2
			if (bktr->bigbuf == 0)	/* no frame buffer allocated */
				return (ENOMEM);
d1652 1
a1652 1

d1764 1
a1764 1
#endif
d1769 5
a1773 5
						printf("%s: ioctl: "
						    "Allocating %d bytes\n",
						    bktr_name(bktr),
						    temp * PAGE_SIZE);
				} else
d1798 1
a1798 1
                                    if (geo->oformat & METEOR_GEO_YUV_12)
d1863 1
a1863 1

d1866 1
a1866 1

d1916 1
a1916 1
#if defined(TUNER_AFC)
d2225 1
a2225 1
	case RADIO_GETFREQ:
d2261 1
a2261 1
	/* Luigi's I2CWR ioctl */
d2268 2
a2269 2

		if (write) {
d2411 1
a2411 1
		  }
d2432 1
a2432 1

d2444 1
a2444 1
		memcpy( pf_pub, &pixfmt_table[ pixfmt ].public,
d2480 1
a2480 1
 *
d2482 1
a2482 1
#ifdef BT848_DEBUG
d2487 1
a2487 1
			   4,    8, 0xc, 0x8c, 0x10, 0x90, 0x14, 0x94,
d2498 1
a2498 1
		       bktr_name(bktr),
d2506 1
a2506 1
	       INL(bktr, BKTR_INT_STAT));
d2571 1
a2571 1

d2582 2
a2583 2
    }

d2585 1
a2585 1
}
d2590 2
a2591 2

    if (bktr->line_length == 0 ||
d2608 1
a2608 1

d2616 1
a2616 1
			}
d2618 1
a2618 1
		}
d2620 1
a2620 1
	    }
d2630 4
a2633 5

static bool_t
split(bktr_reg_t *bktr, u_int **dma_prog, int width, u_int operation,
    int pixel_width, u_int *target_buffer, int cols)
{
d2645 1
a2645 1
	  switch ((*target_buffer) % 4) {
d2657 1
a2657 1
       } else flag = 0;
d2661 1
a2661 1
	     *(*dma_prog)++ = htole32(OP_SKIP | OP_SOL | start_skip);
d2666 3
a2668 3
     *(*dma_prog)++ = htole32(operation | flag  | (width * pixel_width - skip));
     if (operation != OP_SKIP )
	 *(*dma_prog)++ = htole32(*target_buffer);
d2691 1
a2691 1
		*(*dma_prog)++ = htole32(OP_SKIP | OP_SOL | start_skip);
d2696 5
a2700 5
	*(*dma_prog)++ = htole32(operation | flag |
	      (width * pixel_width / 2 - skip));
	if (operation != OP_SKIP )
	      *(*dma_prog)++ = htole32(*target_buffer);
	*target_buffer += width * pixel_width / 2;
d2704 4
a2707 4
	*(*dma_prog)++ = htole32(operation | flag2 |
	    (width * pixel_width / 2));
	*target_buffer += width * pixel_width / 2;
	bktr->current_col += width;
d2710 1
a2710 2

    return TRUE;
d2718 1
a2718 1
rgb_vbi_prog(bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )
d2720 6
a2725 6
	int		i;
	u_int		target_buffer, buffer, target, width;
	u_int		pitch;
	u_int		*dma_prog;	/* DMA prog is an array of
					   32 bit RISC instructions */
	u_int		*loop_point;
d2727 4
a2730 4
	u_int		Bpp = pf_int->public.Bpp;
	unsigned int	vbisamples;     /* VBI samples per line */
	unsigned int	vbilines;       /* VBI lines per field */
	unsigned int	num_dwords;     /* DWORDS per line */
d2744 2
a2745 2
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);
d2749 2
a2750 2
	/* disable gamma correction removal */
	OUTB(bktr, BKTR_COLOR_CTL, INB(bktr, BKTR_COLOR_CTL) | BT848_COLOR_CTL_GAMMA);
d2761 1
a2761 1
	dma_prog = (u_int *) bktr->dma_prog;
d2766 1
a2766 1
		target_buffer = bktr->video.addr;
d2770 1
a2770 5
#ifdef __FreeBSD__
		target_buffer = (u_int) vtophys(bktr->bigbuf);
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif
d2779 2
a2780 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC |BKTR_VRE);
	*dma_prog++ = htole32(0);
d2786 2
a2787 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_FM1);
	*dma_prog++ = htole32(0);
d2789 2
a2790 3
		*dma_prog++ = htole32(OP_WRITE | OP_SOL | OP_EOL | vbisamples);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys((caddr_t)bktr->vbidata +
a2791 4
#else
		*dma_prog++ = htole32(bktr->dm_vbidata->dm_segs->ds_addr +
					(i * VBI_LINE_SIZE));
#endif
d2794 1
a2794 1
	if ( (i_flag == 2/*Odd*/) || (i_flag==3) /*interlaced*/ ) {
d2797 2
a2798 2
		*dma_prog++ = htole32(OP_SYNC  | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d2803 4
a2806 3
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, &target, cols);

d2810 3
a2812 2
				split(bktr, &dma_prog, bktr->y2 - bktr->y,
				    OP_WRITE, Bpp, &target, cols);
d2815 4
a2818 2
				split(bktr, &dma_prog, bktr->yclip2 -
				    bktr->yclip, OP_SKIP, Bpp, &target, cols);
d2821 1
d2823 1
a2823 1

d2825 1
d2832 2
a2833 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
	*dma_prog++ = htole32(0);  /* NULL WORD */
d2837 2
a2838 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_FM1);
	*dma_prog++ = htole32(0);
a2840 1
#ifdef __FreeBSD__
a2842 4
#else
		*dma_prog++ = htole32(bktr->dm_vbidata->dm_segs->ds_addr +
				((i+MAX_VBI_LINES) * VBI_LINE_SIZE));
#endif
d2854 2
a2855 2
		*dma_prog++ = htole32(OP_SYNC | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d2860 3
a2862 2
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, &target,  cols);
d2866 5
a2870 3
				split(bktr, &dma_prog, bktr->y2 - bktr->y,
				    OP_WRITE, Bpp, &target, cols);
			    }
d2872 7
a2878 4
				split(bktr, &dma_prog, bktr->yclip2 -
				    bktr->yclip, OP_SKIP, Bpp, &target, cols);
			    }
			}
d2882 1
d2887 2
a2888 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
d2890 3
a2892 8
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
	*dma_prog++ = (u_int )vtophys(loop_point) ;
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr +
	    ((void *)loop_point - (void *)bktr->dma_prog));
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d2896 3
d2902 4
a2905 4
	int		i;
	u_int		target_buffer, buffer, target,width;
	u_int		pitch;
	u_int		*dma_prog;
d2916 2
a2917 2
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);
d2921 1
a2921 1
	/* disable gamma correction removal */
d2933 1
a2933 1
	dma_prog = (u_int *)bktr->dma_prog;
a2941 1
#ifdef __FreeBSD__
a2942 3
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif
d2949 1
a2949 1
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);
d2952 1
a2952 1
	*dma_prog++ = htole32(0);  /* NULL WORD */
d2957 3
a2959 2
		split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
		    Bpp, &target,  cols);
d2964 3
a2966 2
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, &target, cols);
d2969 4
a2972 2
			split(bktr, &dma_prog, bktr->yclip2 - bktr->yclip,
			      OP_SKIP, Bpp, &target,  cols);
d2975 1
d2979 1
d2985 2
a2986 2
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d2988 1
a2988 2
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a2989 3
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d2994 2
a2995 2
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d2997 1
a2997 2
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a2998 3
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3003 3
a3005 4
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3006 3
#else
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
#endif
d3012 1
a3012 1
	        target_buffer = buffer + pitch;
d3014 1
a3014 1
		dma_prog = (u_int *) bktr->odd_dma_prog;
d3017 2
a3018 2
		*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3023 3
a3025 2
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			    Bpp, &target,  cols);
d3029 5
a3033 3
				split(bktr, &dma_prog, bktr->y2 - bktr->y,
				    OP_WRITE, Bpp, &target, cols);
			    }
d3035 7
a3041 4
				split(bktr, &dma_prog, bktr->yclip2 -
				    bktr->yclip, OP_SKIP, Bpp, &target, cols);
			    }
			}
d3045 1
d3050 3
a3052 4
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
d3054 1
a3054 4
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3059 1
a3059 1
 *
d3087 1
a3087 1

a3095 1
#ifdef __FreeBSD__
a3096 3
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif
d3102 2
a3103 2
	*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM1);
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3108 4
a3111 4
		*dma_prog++ = htole32(inst);
		*dma_prog++ = htole32(target_buffer);
		*dma_prog++ = htole32(inst3);
		*dma_prog++ = htole32(target_buffer + b);
d3118 2
a3119 2
		*dma_prog++ = htole32(OP_SYNC  | 1 << 24 | BKTR_VRE);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3121 1
a3121 2
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3122 3
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3127 3
a3129 4
		*dma_prog++ = htole32(OP_SYNC  | 1 << 24 | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3130 3
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3135 3
a3137 4
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3138 3
#else
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
#endif
d3149 2
a3150 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 |  1 << 15 | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3153 4
a3156 4
			*dma_prog++ = htole32(inst);
			*dma_prog++ = htole32(target_buffer);
			*dma_prog++ = htole32(inst3);
			*dma_prog++ = htole32(target_buffer + b);
d3162 3
a3164 4
	*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3165 3
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3167 1
a3167 2
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
d3169 1
a3169 4
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3174 1
a3174 1
 *
d3177 7
a3183 6
yuv422_prog(bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace)
{
	int		i;
	u_int		inst;
	u_int		target_buffer, t1, buffer;
	u_int		*dma_prog;
d3188 1
a3188 1
	dma_prog = (u_int *) bktr->dma_prog;
d3210 1
a3210 1
	inst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols);
d3212 1
a3212 1
		target_buffer = (u_int) bktr->video.addr;
d3214 2
a3215 6
#ifdef __FreeBSD__
		target_buffer = (u_int) vtophys(bktr->bigbuf);
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif

d3221 2
a3222 3
	/*     sync, mode indicator packed data*/
	*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3225 5
a3229 6
		*dma_prog++ = htole32(inst);
		*dma_prog++ = htole32(cols/2 | cols/2 << 16);
		*dma_prog++ = htole32(target_buffer);
		*dma_prog++ = htole32(t1 + (cols*rows) + i*cols/2 * interlace);
		*dma_prog++ = htole32(t1 + (cols*rows) + (cols*rows/2) +
		    i*cols/2 * interlace);
d3235 2
a3236 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRE);  /*sync vre*/
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3238 2
a3239 6
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3243 2
a3244 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRO);  /*sync vre*/
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3246 2
a3247 6
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3251 2
a3252 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3254 2
a3255 6
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog = (u_int) vtophys(bktr->odd_dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
#endif
d3261 1
a3261 1
		dma_prog = (u_int * ) bktr->odd_dma_prog;
d3263 1
a3263 1
		target_buffer  = (u_int) buffer + cols;
d3265 2
a3266 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3269 5
a3273 7
			*dma_prog++ = htole32(inst);
			*dma_prog++ = htole32(cols/2 | cols/2 << 16);
			*dma_prog++ = htole32(target_buffer);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    i*cols/2 * interlace);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    (cols*rows/2) + i*cols/2 * interlace);
d3277 6
a3282 10

	*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
	*dma_prog++ = (u_int) vtophys(bktr->dma_prog) ;
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3287 1
a3287 1
 *
d3293 5
a3297 5
	int		i;
	u_int		inst;
	u_int		inst1;
	u_int		target_buffer, t1, buffer;
	u_int		*dma_prog;
d3302 1
a3302 1
	dma_prog = (u_int *) bktr->dma_prog;
d3308 1
a3308 1

d3310 7
a3316 11
	inst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols);
	inst1  = OP_WRITES123  | OP_SOL | OP_EOL |  (cols);
	if (bktr->video.addr)
		target_buffer = (u_long) bktr->video.addr;
	else
#ifdef __FreeBSD__
		target_buffer = (u_long) vtophys(bktr->bigbuf);
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif

d3318 23
a3340 1
	t1 = buffer;
d3342 3
a3344 16
	/* sync, mode indicator packed data*/
	*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
	*dma_prog++ = htole32(0);  /* NULL WORD */

	for (i = 0; i < (rows/interlace )/2 ; i++) {
		*dma_prog++ = htole32(inst);
		*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
		*dma_prog++ = htole32(target_buffer);
		*dma_prog++ = htole32(t1 + (cols*rows) + i*cols/2 * interlace);
		*dma_prog++ = htole32(t1 + (cols*rows) + (cols*rows/4) +
		    i*cols/2 * interlace);
		target_buffer += interlace*cols;
		*dma_prog++ = htole32(inst1);
		*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
		*dma_prog++ = htole32(target_buffer);
		target_buffer += interlace*cols;
d3346 3
a3348 1
	}
d3350 9
a3358 34
	switch (i_flag) {
	case 1:
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRE);  /*sync vre*/
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
		return;

	case 2:
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRO);  /*sync vro*/
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
		return;

	case 3:
		*dma_prog++ = htole32(OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog = (u_int) vtophys(bktr->odd_dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
#endif
d3364 1
a3364 1
		dma_prog = (u_int *)bktr->odd_dma_prog;
d3368 2
a3369 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3372 21
a3392 24
			*dma_prog++ = htole32(inst);
			*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
			*dma_prog++ = htole32(target_buffer);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    i*cols/2 * interlace);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    (cols*rows/4) + i*cols/2 * interlace);
			target_buffer += interlace*cols;
			*dma_prog++ = htole32(inst1);
			*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
			*dma_prog++ = htole32(target_buffer);
			target_buffer += interlace*cols;
		}
	}

	*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
	*dma_prog++ = (u_int )vtophys(bktr->dma_prog);
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3394 1
d3398 1
a3398 1
 *
d3405 1
a3405 1
	unsigned int		temp;
d3408 1
a3408 1

d3430 1
a3430 1

d3440 1
a3440 1

d3502 1
a3502 1

d3528 1
a3528 1
	        bktr->bktr_cap_ctl =
d3535 1
a3535 1
	        bktr->bktr_cap_ctl =
d3542 1
a3542 1
	        bktr->bktr_cap_ctl =
a3550 1
#ifdef __FreeBSD__
a3551 3
#else
	OUTL(bktr, BKTR_RISC_STRT_ADD, bktr->dm_prog->dm_segs->ds_addr);
#endif
d3607 1
a3607 1
 *
d3619 1
a3619 1
		bzero((caddr_t)bktr->bigbuf,
d3658 1
d3660 1
a3661 5
#ifdef __FreeBSD__
	OUTL(bktr, BKTR_RISC_STRT_ADD, vtophys(bktr->dma_prog));
#else
	OUTL(bktr, BKTR_RISC_STRT_ADD, bktr->dm_prog->dm_segs->ds_addr);
#endif
d3666 1
a3666 1
 *
d3709 2
a3710 2
/*
 * Given a pixfmt index, compute the bt848 swap_flags necessary to
d3712 4
a3715 4
 * Note that without bt swapping, 2Bpp and 3Bpp modes are written
 *   byte-swapped, and 4Bpp modes are byte and word swapped (see Table 6
 *   and read R->L).
 * Note also that for 3Bpp, we may additionally need to do some creative
a3724 9
	int swap_bytes, swap_shorts;

#if BYTE_ORDER == LITTLE_ENDIAN
	swap_bytes = pf->swap_bytes;
	swap_shorts = pf->swap_shorts;
#else
	swap_bytes = !pf->swap_bytes;
	swap_shorts = !pf->swap_shorts;
#endif
d3727 2
a3728 6
	case 2:
		swapf = swap_bytes ? 0 : BSWAP;
		break;

	case 3: /* no swaps supported for 3bpp - makes no sense w/ bt848 */
		break;
d3730 8
a3737 4
	case 4:
		swapf = swap_bytes ? 0 : BSWAP;
		swapf |= swap_shorts ? 0 : WSWAP;
		break;
d3744 1
a3744 1
/*
d3771 1
a3771 1
		    ( pf1->swap_shorts == pf2->swap_shorts ))
d3785 2
a3786 2
#define I2CBITTIME		(0x5)	/* 5 * 0.48uS */
#define I2CBITTIME_878		(0x8)
d3788 1
a3788 1
#define I2C_COMMAND		((I2CBITTIME << 4) |		\
d3792 1
a3792 1
#define I2C_COMMAND_878		((I2CBITTIME_878 << 4) |	\
d3989 1
a3989 1
 *
d3994 1
a3994 1
	u_int32_t x, stat;
d4001 1
a4001 1

d4004 1
a4004 1
	    bktr->id == BROOKTREE_849A)
d4006 1
a4006 1
	else
d4008 1
d4011 2
a4012 2
	for (x = 5000; x--; DELAY(1))	/* 5 msec, safety valve */
		if ((stat = INL(bktr, BKTR_INT_STAT)) & BT848_INT_I2CDONE)
d4014 1
d4017 2
a4018 2
	if ((stat & (I2C_BITS)) != (I2C_BITS))
		return (-1);
d4021 1
a4021 2
	x = INL(bktr, BKTR_I2C_DATA_CTL);
	return ((x >> 8) & 0xff);
@


1.2
log
@supply some entropy from here
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.1 2001/03/28 03:27:09 fgsch Exp $	*/
d200 2
a201 2
#include <vm/vm.h>			/* for vtophys */
#include <vm/pmap.h>			/* for vtophys */
@


1.1
log
@Latest bktr driver from FreeBSD; thanks to Andres Gunnarsson
<andreas@@crt.se> for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d202 2
d766 4
d782 3
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.1 2001/03/28 03:27:09 fgsch Exp $	*/
@


1.1.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bktr_core.c,v 1.1.4.1 2001/05/14 22:26:02 niklas Exp $	*/
a201 2

#include <dev/rndvar.h>
a763 4

#ifdef __OpenBSD__
		add_video_randomness(tdec_save);
#endif
a775 3
#ifdef __OpenBSD__
	add_video_randomness(INL(bktr, BKTR_RISC_COUNT));
#endif
@


1.1.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d200 2
a201 2
#include <uvm/uvm_extern.h>			/* for vtophys */
#include <uvm/uvm_pmap.h>			/* for vtophys */
@


1.1.4.4
log
@merge stuff cvs missed
@
text
@d643 1
a643 1
        memcpy(dest, (unsigned char *)bktr->vbidata, VBI_DATA_SIZE);
d1369 1
a1369 1
		temp = *(unsigned long *)arg & BT848_IFORM_FORMAT;
d1998 1
a1998 1
		if ( set_audio( bktr, *(int *)arg ) < 0 )
d2004 1
a2004 1
		OUTB(bktr, BKTR_HUE, (u_char)(*(int *)arg & 0xff));
d2008 1
a2008 1
		*(int *)arg = (signed char)(INB(bktr, BKTR_HUE) & 0xff);
d2022 1
a2022 1
		tmp_int = *(int *)arg;
d2049 1
a2049 1
		*(int *)arg = tmp_int;
d2054 1
a2054 1
		tmp_int = *(int *)arg;
d2076 1
a2076 1
		*(int *)arg = tmp_int;
d2081 1
a2081 1
		tmp_int = *(int *)arg;
d2103 1
a2103 1
		*(int *)arg = tmp_int;
d2123 1
a2123 1
		tmp_int = *(int *)arg;
d2145 1
a2145 1
		*(int *)arg = tmp_int;
d2164 1
a2164 1
		*(int *)arg = temp;
d2168 1
a2168 1
		if ( set_BTSC( bktr, *(int *)arg ) < 0 )
d2199 1
a2199 1
                *(int *)arg = INL(bktr, BKTR_GPIO_OUT_EN);
d2203 1
a2203 1
                OUTL(bktr, BKTR_GPIO_OUT_EN, *(int *)arg);
d2207 1
a2207 1
                *(int *)arg = INL(bktr, BKTR_GPIO_DATA);
d2211 1
a2211 1
                OUTL(bktr, BKTR_GPIO_DATA, *(int *)arg);
d2459 1
a2459 1
		*(u_int *)arg = temp;
@


1.1.4.5
log
@Sync the SMP branch with 3.3
@
text
@d21 1
a21 1
   Jim Lowe's driver for the Matrox Meteor PCI card . The
d31 1
a31 1
 * 1. Redistributions of source code must retain the
d47 1
a47 1
 * 4. The name of the author may not be used to endorse or promote products
d67 1
a67 1
 * 1. Redistributions of source code must retain the
d82 1
a82 1
 * 4. The name of the author may not be used to endorse or promote products
d199 3
a201 1
#endif
a202 1
#ifdef __OpenBSD__
d245 1
a245 1
   transfers into two dma requests
d249 1
a249 1
/*
d286 1
a286 1
static const struct format_params format_params[] = {
d314 1
a314 1
 * Table of supported Pixel Formats
d317 1
a317 1
static const struct meteor_pixfmt_internal {
d346 1
a346 1
static const struct {
d438 3
a440 2
static bool_t   notclipped(bktr_reg_t * , int , int);
static bool_t   split(bktr_reg_t *, u_int **, int, u_int, int, u_int * , int);
d474 1
a474 1
void
d477 1
a477 1
	vaddr_t	buf = 0;
d484 2
a485 1
        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);
d487 1
a487 1
	    DMA_PROG_ALLOC);
d490 2
a491 1
	bktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);
d493 1
a493 1
	    VBI_BUFFER_SIZE);
d496 1
a496 1
        if (BROOKTREE_ALLOC)
d548 1
a548 6
			bktr_name(bktr), BROOKTREE_ALLOC,
#ifdef __FreeBSD__
			vtophys(buf));
#else
			bktr->dm_prog->dm_segs->ds_addr);
#endif
d551 1
a551 1
	if (buf != 0) {
d554 1
a554 1
		bzero((void *)bktr->bigbuf, BROOKTREE_ALLOC);
d558 1
d570 1
d576 1
d579 2
a580 1
	if (PCI_VENDOR(pci_id) == PCI_VENDOR_BROOKTREE) {
d598 1
a598 1
	}
d619 1
a619 1
	probeCard(bktr, TRUE, unit);
d622 2
a623 1
	init_audio_devices(bktr);
d628 4
a631 4
 * The circular buffer holds 'n' fixed size data blocks.
 * vbisize   is the number of bytes in the circular buffer
 * vbiread   is the point we reading data out of the circular buffer
 * vbiinsert is the point we insert data into the circular buffer
d633 1
a633 3
static void
vbidecode(bktr_ptr_t bktr)
{
d656 1
d664 1
d674 1
a674 1
int
d676 9
a684 7
{
	bktr_ptr_t	bktr = (bktr_ptr_t) arg;
	u_int	bktr_status;
	u_char	dstatus;
	u_int	field;
	u_int	w_field;
	u_int	req_field;
d692 1
a692 1
		return 0;	/* bail out now, before we do something we
d727 2
a728 2
			      BT848_INT_OCERR  | BT848_INT_SCERR) ) != 0)
		|| ((INB(bktr, BKTR_TDEC) == 0) && (bktr_status & TDEC_BITS)) ) {
d740 1
a740 1

a755 1
#ifdef __FreeBSD__
a756 3
#else
		OUTL(bktr, BKTR_RISC_STRT_ADD, bktr->dm_prog->dm_segs->ds_addr);
#endif
d788 1
a788 1
	 * This can happen when we are in the process of closing or
d794 1
d798 1
d804 3
a806 2
	if ((bktr->vbiflags & (VBI_CAPTURE|VBI_OPEN)) ==
	    (VBI_CAPTURE|VBI_OPEN) && (field == EVEN_F)) {
d808 1
a808 1
		vbidecode(bktr);
d813 1
a813 1
			wakeup(VBI_SLEEP);
d824 2
d841 1
a841 1
		default                      : req_field = (ODD_F|EVEN_F);
d882 1
a882 1
		 * post the completion time.
d886 1
a886 1

d897 1
a897 1

d957 1
a957 1
 *
d986 1
a986 1
	if (bt848_format == 0 )
d989 1
a989 1
	if (bt848_format == 1 )
d1015 1
a1015 1
	/* enable PLL mode using 28MHz crystal for PAL/SECAM users */
d1058 1
a1058 1
                                                   based motherboards will
d1085 1
a1085 1
 *
d1091 1
a1091 1
		return( ENXIO );
d1111 1
a1111 1

d1119 1
a1119 1
 *
d1190 1
a1190 1
	count = bktr->rows * bktr->cols *
d1227 1
a1227 1
 * vbisize is the exact number of bytes in the buffer left to read
d1248 1
a1248 1

d1262 1
a1262 1
		status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);
d1296 1
a1296 1
	vaddr_t			buf;
d1323 4
a1326 2
	    if (bktr->max_clip_node == 0 &&
		(bktr->clip_list[0].y_min != 0 &&
d1348 1
a1348 1
		    bktr->clip_list[i].x_max < 0 ||
d1402 1
a1402 1
		bktr->dma_prog_loaded = FALSE;
d1414 1
a1414 1
			OUTB(bktr, BKTR_IFORM, temp_iform | BT848_IFORM_F_NTSCM |
d1441 1
a1441 1
		bktr->dma_prog_loaded = FALSE;
d1452 1
a1452 1

d1506 1
a1506 1

d1602 1
a1602 1
					    BT848_INT_RISCI      |
d1628 2
a1629 2
			if (bktr->bigbuf == 0)	/* no frame buffer allocated */
				return (ENOMEM);
d1652 1
a1652 1

d1764 1
a1764 1
#endif
d1769 5
a1773 5
						printf("%s: ioctl: "
						    "Allocating %d bytes\n",
						    bktr_name(bktr),
						    temp * PAGE_SIZE);
				} else
d1798 1
a1798 1
                                    if (geo->oformat & METEOR_GEO_YUV_12)
d1863 1
a1863 1

d1866 1
a1866 1

d1916 1
a1916 1
#if defined(TUNER_AFC)
d2225 1
a2225 1
	case RADIO_GETFREQ:
d2261 1
a2261 1
	/* Luigi's I2CWR ioctl */
d2268 2
a2269 2

		if (write) {
d2411 1
a2411 1
		  }
d2432 1
a2432 1

d2444 1
a2444 1
		memcpy( pf_pub, &pixfmt_table[ pixfmt ].public,
d2480 1
a2480 1
 *
d2482 1
a2482 1
#ifdef BT848_DEBUG
d2487 1
a2487 1
			   4,    8, 0xc, 0x8c, 0x10, 0x90, 0x14, 0x94,
d2498 1
a2498 1
		       bktr_name(bktr),
d2506 1
a2506 1
	       INL(bktr, BKTR_INT_STAT));
d2571 1
a2571 1

d2582 2
a2583 2
    }

d2585 1
a2585 1
}
d2590 2
a2591 2

    if (bktr->line_length == 0 ||
d2608 1
a2608 1

d2616 1
a2616 1
			}
d2618 1
a2618 1
		}
d2620 1
a2620 1
	    }
d2630 4
a2633 5

static bool_t
split(bktr_reg_t *bktr, u_int **dma_prog, int width, u_int operation,
    int pixel_width, u_int *target_buffer, int cols)
{
d2636 1
a2636 1
 const struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;
d2645 1
a2645 1
	  switch ((*target_buffer) % 4) {
d2657 1
a2657 1
       } else flag = 0;
d2661 1
a2661 1
	     *(*dma_prog)++ = htole32(OP_SKIP | OP_SOL | start_skip);
d2666 3
a2668 3
     *(*dma_prog)++ = htole32(operation | flag  | (width * pixel_width - skip));
     if (operation != OP_SKIP )
	 *(*dma_prog)++ = htole32(*target_buffer);
d2691 1
a2691 1
		*(*dma_prog)++ = htole32(OP_SKIP | OP_SOL | start_skip);
d2696 5
a2700 5
	*(*dma_prog)++ = htole32(operation | flag |
	      (width * pixel_width / 2 - skip));
	if (operation != OP_SKIP )
	      *(*dma_prog)++ = htole32(*target_buffer);
	*target_buffer += width * pixel_width / 2;
d2704 4
a2707 4
	*(*dma_prog)++ = htole32(operation | flag2 |
	    (width * pixel_width / 2));
	*target_buffer += width * pixel_width / 2;
	bktr->current_col += width;
d2710 1
a2710 2

    return TRUE;
d2718 1
a2718 1
rgb_vbi_prog(bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )
d2720 11
a2730 11
	int		i;
	u_int		target_buffer, buffer, target, width;
	u_int		pitch;
	u_int		*dma_prog;	/* DMA prog is an array of
					   32 bit RISC instructions */
	u_int		*loop_point;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
	u_int		Bpp = pf_int->public.Bpp;
	unsigned int	vbisamples;     /* VBI samples per line */
	unsigned int	vbilines;       /* VBI lines per field */
	unsigned int	num_dwords;     /* DWORDS per line */
d2744 2
a2745 2
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);
d2749 2
a2750 2
	/* disable gamma correction removal */
	OUTB(bktr, BKTR_COLOR_CTL, INB(bktr, BKTR_COLOR_CTL) | BT848_COLOR_CTL_GAMMA);
d2761 1
a2761 1
	dma_prog = (u_int *) bktr->dma_prog;
d2766 1
a2766 1
		target_buffer = bktr->video.addr;
d2770 1
a2770 5
#ifdef __FreeBSD__
		target_buffer = (u_int) vtophys(bktr->bigbuf);
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif
d2779 2
a2780 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC |BKTR_VRE);
	*dma_prog++ = htole32(0);
d2786 2
a2787 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_FM1);
	*dma_prog++ = htole32(0);
d2789 2
a2790 3
		*dma_prog++ = htole32(OP_WRITE | OP_SOL | OP_EOL | vbisamples);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys((caddr_t)bktr->vbidata +
a2791 4
#else
		*dma_prog++ = htole32(bktr->dm_vbidata->dm_segs->ds_addr +
					(i * VBI_LINE_SIZE));
#endif
d2794 1
a2794 1
	if ( (i_flag == 2/*Odd*/) || (i_flag==3) /*interlaced*/ ) {
d2797 2
a2798 2
		*dma_prog++ = htole32(OP_SYNC  | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d2803 4
a2806 3
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, &target, cols);

d2810 3
a2812 2
				split(bktr, &dma_prog, bktr->y2 - bktr->y,
				    OP_WRITE, Bpp, &target, cols);
d2815 4
a2818 2
				split(bktr, &dma_prog, bktr->yclip2 -
				    bktr->yclip, OP_SKIP, Bpp, &target, cols);
d2821 1
d2823 1
a2823 1

d2825 1
d2832 2
a2833 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
	*dma_prog++ = htole32(0);  /* NULL WORD */
d2837 2
a2838 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_FM1);
	*dma_prog++ = htole32(0);
a2840 1
#ifdef __FreeBSD__
a2842 4
#else
		*dma_prog++ = htole32(bktr->dm_vbidata->dm_segs->ds_addr +
				((i+MAX_VBI_LINES) * VBI_LINE_SIZE));
#endif
d2854 2
a2855 2
		*dma_prog++ = htole32(OP_SYNC | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d2860 3
a2862 2
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, &target,  cols);
d2866 5
a2870 3
				split(bktr, &dma_prog, bktr->y2 - bktr->y,
				    OP_WRITE, Bpp, &target, cols);
			    }
d2872 7
a2878 4
				split(bktr, &dma_prog, bktr->yclip2 -
				    bktr->yclip, OP_SKIP, Bpp, &target, cols);
			    }
			}
d2882 1
d2887 2
a2888 2
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
d2890 3
a2892 8
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
	*dma_prog++ = (u_int )vtophys(loop_point) ;
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr +
	    ((void *)loop_point - (void *)bktr->dma_prog));
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d2896 3
d2902 5
a2906 5
	int		i;
	u_int		target_buffer, buffer, target,width;
	u_int		pitch;
	u_int		*dma_prog;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d2916 2
a2917 2
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);
d2921 1
a2921 1
	/* disable gamma correction removal */
d2933 1
a2933 1
	dma_prog = (u_int *)bktr->dma_prog;
a2941 1
#ifdef __FreeBSD__
a2942 3
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif
d2949 1
a2949 1
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);
d2952 1
a2952 1
	*dma_prog++ = htole32(0);  /* NULL WORD */
d2957 3
a2959 2
		split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
		    Bpp, &target,  cols);
d2964 3
a2966 2
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			      Bpp, &target, cols);
d2969 4
a2972 2
			split(bktr, &dma_prog, bktr->yclip2 - bktr->yclip,
			      OP_SKIP, Bpp, &target,  cols);
d2975 1
d2979 1
d2985 2
a2986 2
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d2988 1
a2988 2
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a2989 3
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d2994 2
a2995 2
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d2997 1
a2997 2
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a2998 3
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3003 3
a3005 4
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3006 3
#else
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
#endif
d3012 1
a3012 1
	        target_buffer = buffer + pitch;
d3014 1
a3014 1
		dma_prog = (u_int *) bktr->odd_dma_prog;
d3017 2
a3018 2
		*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3023 3
a3025 2
			split(bktr, &dma_prog, bktr->y2 - bktr->y, OP_WRITE,
			    Bpp, &target,  cols);
d3029 5
a3033 3
				split(bktr, &dma_prog, bktr->y2 - bktr->y,
				    OP_WRITE, Bpp, &target, cols);
			    }
d3035 7
a3041 4
				split(bktr, &dma_prog, bktr->yclip2 -
				    bktr->yclip, OP_SKIP, Bpp, &target, cols);
			    }
			}
d3045 1
d3050 3
a3052 4
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
d3054 1
a3054 4
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3059 1
a3059 1
 *
d3070 1
a3070 1
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3087 1
a3087 1

a3095 1
#ifdef __FreeBSD__
a3096 3
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif
d3102 2
a3103 2
	*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM1);
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3108 4
a3111 4
		*dma_prog++ = htole32(inst);
		*dma_prog++ = htole32(target_buffer);
		*dma_prog++ = htole32(inst3);
		*dma_prog++ = htole32(target_buffer + b);
d3118 2
a3119 2
		*dma_prog++ = htole32(OP_SYNC  | 1 << 24 | BKTR_VRE);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3121 1
a3121 2
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3122 3
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3127 3
a3129 4
		*dma_prog++ = htole32(OP_SYNC  | 1 << 24 | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3130 3
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3135 3
a3137 4
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3138 3
#else
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
#endif
d3149 2
a3150 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 |  1 << 15 | BKTR_FM1);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3153 4
a3156 4
			*dma_prog++ = htole32(inst);
			*dma_prog++ = htole32(target_buffer);
			*dma_prog++ = htole32(inst3);
			*dma_prog++ = htole32(target_buffer + b);
d3162 3
a3164 4
	*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
a3165 3
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3167 1
a3167 2
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
d3169 1
a3169 4
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3174 1
a3174 1
 *
d3177 8
a3184 7
yuv422_prog(bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace)
{
	int		i;
	u_int		inst;
	u_int		target_buffer, t1, buffer;
	u_int		*dma_prog;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3188 1
a3188 1
	dma_prog = (u_int *) bktr->dma_prog;
d3210 1
a3210 1
	inst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols);
d3212 1
a3212 1
		target_buffer = (u_int) bktr->video.addr;
d3214 2
a3215 6
#ifdef __FreeBSD__
		target_buffer = (u_int) vtophys(bktr->bigbuf);
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif

d3221 2
a3222 3
	/*     sync, mode indicator packed data*/
	*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3225 5
a3229 6
		*dma_prog++ = htole32(inst);
		*dma_prog++ = htole32(cols/2 | cols/2 << 16);
		*dma_prog++ = htole32(target_buffer);
		*dma_prog++ = htole32(t1 + (cols*rows) + i*cols/2 * interlace);
		*dma_prog++ = htole32(t1 + (cols*rows) + (cols*rows/2) +
		    i*cols/2 * interlace);
d3235 2
a3236 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRE);  /*sync vre*/
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3238 2
a3239 6
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3243 2
a3244 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRO);  /*sync vre*/
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3246 2
a3247 6
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
d3251 2
a3252 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3254 2
a3255 6
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog = (u_int) vtophys(bktr->odd_dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
#endif
d3261 1
a3261 1
		dma_prog = (u_int * ) bktr->odd_dma_prog;
d3263 1
a3263 1
		target_buffer  = (u_int) buffer + cols;
d3265 2
a3266 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3269 5
a3273 7
			*dma_prog++ = htole32(inst);
			*dma_prog++ = htole32(cols/2 | cols/2 << 16);
			*dma_prog++ = htole32(target_buffer);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    i*cols/2 * interlace);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    (cols*rows/2) + i*cols/2 * interlace);
d3277 6
a3282 10

	*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
	*dma_prog++ = (u_int) vtophys(bktr->dma_prog) ;
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3287 1
a3287 1
 *
d3293 6
a3298 6
	int		i;
	u_int		inst;
	u_int		inst1;
	u_int		target_buffer, t1, buffer;
	u_int		*dma_prog;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];
d3302 1
a3302 1
	dma_prog = (u_int *) bktr->dma_prog;
d3308 1
a3308 1

d3310 7
a3316 11
	inst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols);
	inst1  = OP_WRITES123  | OP_SOL | OP_EOL |  (cols);
	if (bktr->video.addr)
		target_buffer = (u_long) bktr->video.addr;
	else
#ifdef __FreeBSD__
		target_buffer = (u_long) vtophys(bktr->bigbuf);
#else
		target_buffer = bktr->dm_mem->dm_segs->ds_addr;
#endif

d3318 23
a3340 1
	t1 = buffer;
d3342 3
a3344 16
	/* sync, mode indicator packed data*/
	*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
	*dma_prog++ = htole32(0);  /* NULL WORD */

	for (i = 0; i < (rows/interlace )/2 ; i++) {
		*dma_prog++ = htole32(inst);
		*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
		*dma_prog++ = htole32(target_buffer);
		*dma_prog++ = htole32(t1 + (cols*rows) + i*cols/2 * interlace);
		*dma_prog++ = htole32(t1 + (cols*rows) + (cols*rows/4) +
		    i*cols/2 * interlace);
		target_buffer += interlace*cols;
		*dma_prog++ = htole32(inst1);
		*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
		*dma_prog++ = htole32(target_buffer);
		target_buffer += interlace*cols;
d3346 3
a3348 1
	}
d3350 9
a3358 34
	switch (i_flag) {
	case 1:
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRE);  /*sync vre*/
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
		return;

	case 2:
		*dma_prog++ = htole32(OP_SYNC | 1 << 24 | BKTR_VRO);  /*sync vro*/
		*dma_prog++ = htole32(0);  /* NULL WORD */

		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog++ = (u_int) vtophys(bktr->dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
		return;

	case 3:
		*dma_prog++ = htole32(OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRO);
		*dma_prog++ = htole32(0);  /* NULL WORD */
		*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
		*dma_prog = (u_int) vtophys(bktr->odd_dma_prog);
#else
		*dma_prog++ = htole32(bktr->dm_oprog->dm_segs->ds_addr);
#endif
d3364 1
a3364 1
		dma_prog = (u_int *)bktr->odd_dma_prog;
d3368 2
a3369 2
		*dma_prog++ = htole32(OP_SYNC | 1 << 15 | BKTR_FM3);
		*dma_prog++ = htole32(0);  /* NULL WORD */
d3372 21
a3392 24
			*dma_prog++ = htole32(inst);
			*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
			*dma_prog++ = htole32(target_buffer);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    i*cols/2 * interlace);
			*dma_prog++ = htole32(t1 + (cols*rows) +
			    (cols*rows/4) + i*cols/2 * interlace);
			target_buffer += interlace*cols;
			*dma_prog++ = htole32(inst1);
			*dma_prog++ = htole32(cols/2 | (cols/2 << 16));
			*dma_prog++ = htole32(target_buffer);
			target_buffer += interlace*cols;
		}
	}

	*dma_prog++ = htole32(OP_SYNC | 1 << 24 | 1 << 15 | BKTR_VRE);
	*dma_prog++ = htole32(0);  /* NULL WORD */
	*dma_prog++ = htole32(OP_JUMP);
#ifdef __FreeBSD__
	*dma_prog++ = (u_int )vtophys(bktr->dma_prog);
#else
	*dma_prog++ = htole32(bktr->dm_prog->dm_segs->ds_addr);
#endif
	*dma_prog++ = htole32(0);  /* NULL WORD */
d3394 1
d3398 1
a3398 1
 *
d3405 4
a3408 4
	unsigned int		temp;
	const struct format_params *fp;
        const struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];

d3430 1
a3430 1

d3440 1
a3440 1

d3502 1
a3502 1

d3528 1
a3528 1
	        bktr->bktr_cap_ctl =
d3535 1
a3535 1
	        bktr->bktr_cap_ctl =
d3542 1
a3542 1
	        bktr->bktr_cap_ctl =
a3550 1
#ifdef __FreeBSD__
a3551 3
#else
	OUTL(bktr, BKTR_RISC_STRT_ADD, bktr->dm_prog->dm_segs->ds_addr);
#endif
d3607 1
a3607 1
 *
d3613 1
a3613 1
	const struct format_params   *fp;
d3619 1
a3619 1
		bzero((caddr_t)bktr->bigbuf,
d3658 1
d3660 1
a3661 5
#ifdef __FreeBSD__
	OUTL(bktr, BKTR_RISC_STRT_ADD, vtophys(bktr->dma_prog));
#else
	OUTL(bktr, BKTR_RISC_STRT_ADD, bktr->dm_prog->dm_segs->ds_addr);
#endif
d3666 1
a3666 1
 *
d3671 1
a3671 1
	const struct format_params	*fp;
d3709 2
a3710 2
/*
 * Given a pixfmt index, compute the bt848 swap_flags necessary to
d3712 4
a3715 4
 * Note that without bt swapping, 2Bpp and 3Bpp modes are written
 *   byte-swapped, and 4Bpp modes are byte and word swapped (see Table 6
 *   and read R->L).
 * Note also that for 3Bpp, we may additionally need to do some creative
d3723 1
a3723 1
	const struct meteor_pixfmt *pf = &pixfmt_table[ pixfmt ].public;
a3724 9
	int swap_bytes, swap_shorts;

#if BYTE_ORDER == LITTLE_ENDIAN
	swap_bytes = pf->swap_bytes;
	swap_shorts = pf->swap_shorts;
#else
	swap_bytes = !pf->swap_bytes;
	swap_shorts = !pf->swap_shorts;
#endif
d3727 2
a3728 6
	case 2:
		swapf = swap_bytes ? 0 : BSWAP;
		break;

	case 3: /* no swaps supported for 3bpp - makes no sense w/ bt848 */
		break;
d3730 8
a3737 4
	case 4:
		swapf = swap_bytes ? 0 : BSWAP;
		swapf |= swap_shorts ? 0 : WSWAP;
		break;
d3744 1
a3744 1
/*
d3752 1
a3752 1
        const struct meteor_pixfmt *pf1, *pf2;
d3771 1
a3771 1
		    ( pf1->swap_shorts == pf2->swap_shorts ))
d3785 2
a3786 2
#define I2CBITTIME		(0x5)	/* 5 * 0.48uS */
#define I2CBITTIME_878		(0x8)
d3788 1
a3788 1
#define I2C_COMMAND		((I2CBITTIME << 4) |		\
d3792 1
a3792 1
#define I2C_COMMAND_878		((I2CBITTIME_878 << 4) |	\
d3989 1
a3989 1
 *
d3994 1
a3994 1
	u_int32_t x, stat;
d4001 1
a4001 1

d4004 1
a4004 1
	    bktr->id == BROOKTREE_849A)
d4006 1
a4006 1
	else
d4008 1
d4011 2
a4012 2
	for (x = 5000; x--; DELAY(1))	/* 5 msec, safety valve */
		if ((stat = INL(bktr, BKTR_INT_STAT)) & BT848_INT_I2CDONE)
d4014 1
d4017 2
a4018 2
	if ((stat & (I2C_BITS)) != (I2C_BITS))
		return (-1);
d4021 1
a4021 2
	x = INL(bktr, BKTR_I2C_DATA_CTL);
	return ((x >> 8) & 0xff);
@


1.1.4.6
log
@Merge with the trunk
@
text
@d454 1
a454 1
int	bktr_common_ioctl( bktr_ptr_t bktr, ioctl_cmd_t cmd, caddr_t arg );
d1501 1
a1501 1
		*(u_char *)arg = INB(bktr, BKTR_BRIGHT) + 128;
d1628 1
a1628 1
			/* Clear the interrupt status register */
d1876 1
a1876 1
		return bktr_common_ioctl( bktr, cmd, arg );
d2295 1
a2295 1
		return bktr_common_ioctl( bktr, cmd, arg );
d2306 1
a2306 1
bktr_common_ioctl( bktr_ptr_t bktr, ioctl_cmd_t cmd, caddr_t arg )
d2493 1
a2493 1
		       r[i+3], INL(bktr, r[i+3]));
d2551 1
a2551 2
static bool_t
notclipped (bktr_reg_t * bktr, int x, int width) {
d2578 1
a2578 2
static bool_t
getline(bktr_reg_t *bktr, int x ) {
d2836 1
a2836 1
		*dma_prog++ = htole32(OP_WRITE | OP_SOL | OP_EOL | vbisamples);
d2948 1
a2948 1
	/* construct sync : for video packet format */
d3109 1
a3109 1
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);
d3125 1
a3125 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE);
d3138 1
a3138 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO);
d3150 1
a3150 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
d3168 1
a3168 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM1);
d3181 1
a3181 1
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
d3229 2
a3230 2
	OUTB(bktr, BKTR_E_VSCALE_HI, INB(bktr, BKTR_E_VSCALE_HI) | 0x40); /* set chroma comb */
	OUTB(bktr, BKTR_O_VSCALE_HI, INB(bktr, BKTR_O_VSCALE_HI) | 0x40);
d3252 1
a3252 1
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM3);
d3267 1
a3267 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE);  /*sync vre*/
d3279 1
a3279 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO);  /*sync vre*/
d3291 1
a3291 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
d3309 1
a3309 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM3);
d3324 1
a3324 1
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
d3375 1
a3375 1
	*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM3);
d3395 1
a3395 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE);  /*sync vre*/
d3407 1
a3407 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO);  /*sync vro*/
d3419 1
a3419 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO);
d3436 1
a3436 1
		*dma_prog++ = htole32(OP_SYNC | BKTR_RESYNC | BKTR_FM3);
d3455 1
a3455 1
	*dma_prog++ = htole32(OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE);
@


