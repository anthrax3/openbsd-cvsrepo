head	1.42;
access;
symbols
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.39.0.8
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.36.0.6
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.31.0.4
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.2
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.4
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.9
	UBC:1.4.0.2
	UBC_BASE:1.4
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.42
date	2016.12.20.15.45.29;	author ratchov;	state Exp;
branches;
next	1.41;
commitid	dDW2VmDmW7exz02w;

1.41
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.40;
commitid	qGgYgJTgEFuAoGj4;

1.40
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.39;
commitid	pi1a9KN0itEngOc4;

1.39
date	2015.06.10.20.14.02;	author ratchov;	state Exp;
branches;
next	1.38;
commitid	UnoP4o9bPuQHqz4F;

1.38
date	2015.06.10.20.02.42;	author ratchov;	state Exp;
branches;
next	1.37;
commitid	LcEwQU5SiQmyMxKI;

1.37
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.36;
commitid	RaOGL5SyOGOZylwx;

1.36
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.35;
commitid	OBNa5kfxQ2UXoiIw;

1.35
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2012.03.30.08.18.19;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.21.02.53.14;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.27.18.50.56;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.26.00.36.03;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.25.21.27.15;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.07.22.41.33;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.22.18.12.24;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.16.21.57.23;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.14.12.42.16;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.09.01.52.14;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.29.04.59.59;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.04.19.55.19;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.26.22.14.50;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.05.10.00.18;	author deraadt;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.12.01.16.43.32;	author mickey;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.11.26.18.10.52;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.26.16.38.38;	author mickey;	state Exp;
branches;
next	;

1.3.2.1
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.05.13.19.35.04;	author ho;	state Exp;
branches;
next	;

1.4.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2003.05.19.22.17.59;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Simplify the activate() functions of auglx(4), autri(4), and
auvia(4). From Michael W.  Bombardieri <mb at ii.net>. Thanks.
@
text
@/*	$OpenBSD: autri.c,v 1.41 2016/09/19 06:46:44 ratchov Exp $	*/

/*
 * Copyright (c) 2001 SOMEYA Yoshihiko and KUROSAWA Takahiro.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Trident 4DWAVE-DX/NX, SiS 7018, ALi M5451 Sound Driver
 *
 * The register information is taken from the ALSA driver.
 *
 * Documentation links:
 * - ftp://ftp.alsa-project.org/pub/manuals/trident/
 */

#include "midi.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/fcntl.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>
#include <dev/ic/ac97.h>
#include <dev/ic/mpuvar.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/autrireg.h>
#include <dev/pci/autrivar.h>

#ifdef AUDIO_DEBUG
# define DPRINTF(x)	if (autridebug) printf x
# define DPRINTFN(n,x)	if (autridebug > (n)) printf x
int autridebug = 0;
#else
# define DPRINTF(x)
# define DPRINTFN(n,x)
#endif

int	autri_match(struct device *, void *, void *);
void	autri_attach(struct device *, struct device *, void *);
int	autri_activate(struct device *, int);
int	autri_intr(void *);

#define DMAADDR(p) ((p)->map->dm_segs[0].ds_addr)
#define KERNADDR(p) ((void *)((p)->addr))

int autri_allocmem(struct autri_softc *, size_t, size_t, struct autri_dma *);
int autri_freemem(struct autri_softc *, struct autri_dma *);

#define TWRITE1(sc, r, x) bus_space_write_1((sc)->memt, (sc)->memh, (r), (x))
#define TWRITE2(sc, r, x) bus_space_write_2((sc)->memt, (sc)->memh, (r), (x))
#define TWRITE4(sc, r, x) bus_space_write_4((sc)->memt, (sc)->memh, (r), (x))
#define TREAD1(sc, r) bus_space_read_1((sc)->memt, (sc)->memh, (r))
#define TREAD2(sc, r) bus_space_read_2((sc)->memt, (sc)->memh, (r))
#define TREAD4(sc, r) bus_space_read_4((sc)->memt, (sc)->memh, (r))

static __inline void autri_reg_set_1(struct autri_softc *, int, uint8_t);
static __inline void autri_reg_clear_1(struct autri_softc *, int, uint8_t);
static __inline void autri_reg_set_4(struct autri_softc *, int, uint32_t);
static __inline void autri_reg_clear_4(struct autri_softc *, int, uint32_t);

int	autri_attach_codec(void *sc, struct ac97_codec_if *);
int	autri_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	autri_write_codec(void *sc, u_int8_t a, u_int16_t d);
void	autri_reset_codec(void *sc);
enum ac97_host_flags	autri_flags_codec(void *);

int  autri_init(void *sc);
struct autri_dma *autri_find_dma(struct autri_softc *, void *);
void autri_setup_channel(struct autri_softc *sc,int mode,
				    struct audio_params *param);
void autri_enable_interrupt(struct autri_softc *sc, int ch);
void autri_disable_interrupt(struct autri_softc *sc, int ch);
void autri_startch(struct autri_softc *sc, int ch, int ch_intr);
void autri_stopch(struct autri_softc *sc, int ch, int ch_intr);
void autri_enable_loop_interrupt(void *sc);
#if 0
void autri_disable_loop_interrupt(void *sc);
#endif

struct cfdriver autri_cd = {
	NULL, "autri", DV_DULL
};

struct cfattach autri_ca = {
	sizeof(struct autri_softc), autri_match, autri_attach, NULL,
	autri_activate
};

int	autri_open(void *, int);
void	autri_close(void *);
int	autri_set_params(void *, int, int, struct audio_params *,
	    struct audio_params *);
int	autri_round_blocksize(void *, int);
int	autri_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	autri_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	autri_halt_output(void *);
int	autri_halt_input(void *);
int	autri_mixer_set_port(void *, mixer_ctrl_t *);
int	autri_mixer_get_port(void *, mixer_ctrl_t *);
void   *autri_malloc(void *, int, size_t, int, int);
void	autri_free(void *, void *, int);
int	autri_get_props(void *);
int	autri_query_devinfo(void *addr, mixer_devinfo_t *dip);

int	autri_get_portnum_by_name(struct autri_softc *, char *, char *, char *);

struct audio_hw_if autri_hw_if = {
	autri_open,
	autri_close,
	autri_set_params,
	autri_round_blocksize,
	NULL,			/* commit_settings */
	NULL,			/* init_output */
	NULL,			/* init_input */
	NULL,			/* start_output */
	NULL,			/* start_input */
	autri_halt_output,
	autri_halt_input,
	NULL,			/* speaker_ctl */
	NULL,			/* setfd */
	autri_mixer_set_port,
	autri_mixer_get_port,
	autri_query_devinfo,
	autri_malloc,
	autri_free,
	NULL,
	autri_get_props,
	autri_trigger_output,
	autri_trigger_input
};

#if NMIDI > 0
void	autri_midi_close(void *);
void	autri_midi_getinfo(void *, struct midi_info *);
int	autri_midi_open(void *, int, void (*)(void *, int),
			   void (*)(void *), void *);
int	autri_midi_output(void *, int);

struct midi_hw_if autri_midi_hw_if = {
	autri_midi_open,
	autri_midi_close,
	autri_midi_output,
	NULL,			/* flush */
	autri_midi_getinfo,
	NULL,			/* ioctl */
};
#endif

/*
 * register set/clear bit
 */
static __inline void
autri_reg_set_1(struct autri_softc *sc, int no, uint8_t mask)
{
	bus_space_write_1(sc->memt, sc->memh, no,
	    (bus_space_read_1(sc->memt, sc->memh, no) | mask));
}

static __inline void
autri_reg_clear_1(struct autri_softc *sc, int no, uint8_t mask)
{
	bus_space_write_1(sc->memt, sc->memh, no,
	    (bus_space_read_1(sc->memt, sc->memh, no) & ~mask));
}

static __inline void
autri_reg_set_4(struct autri_softc *sc, int no, uint32_t mask)
{
	bus_space_write_4(sc->memt, sc->memh, no,
	    (bus_space_read_4(sc->memt, sc->memh, no) | mask));
}

static __inline void
autri_reg_clear_4(struct autri_softc *sc, int no, uint32_t mask)
{
	bus_space_write_4(sc->memt, sc->memh, no,
	    (bus_space_read_4(sc->memt, sc->memh, no) & ~mask));
}

/*
 * AC97 codec
 */
int
autri_attach_codec(void *sc_, struct ac97_codec_if *codec_if)
{
	struct autri_codec_softc *sc = sc_;

	DPRINTF(("autri_attach_codec()\n"));

	sc->codec_if = codec_if;
	return 0;
}

int
autri_read_codec(void *sc_, u_int8_t index, u_int16_t *data)
{
	struct autri_codec_softc *codec = sc_;
	struct autri_softc *sc = codec->sc;
	u_int32_t status, addr, cmd, busy;
	u_int16_t count;

	/*DPRINTF(("sc->sc->type : 0x%X",sc->sc->type));*/

	switch (sc->sc_devid) {
	case AUTRI_DEVICE_ID_4DWAVE_DX:
		addr = AUTRI_DX_ACR1;
		cmd  = AUTRI_DX_ACR1_CMD_READ;
		busy = AUTRI_DX_ACR1_BUSY_READ;
		break;
	case AUTRI_DEVICE_ID_4DWAVE_NX:
		addr = AUTRI_NX_ACR2;
		cmd  = AUTRI_NX_ACR2_CMD_READ;
		busy = AUTRI_NX_ACR2_BUSY_READ | AUTRI_NX_ACR2_RECV_WAIT;
		break;
	case AUTRI_DEVICE_ID_SIS_7018:
		addr = AUTRI_SIS_ACRD;
		cmd  = AUTRI_SIS_ACRD_CMD_READ;
		busy = AUTRI_SIS_ACRD_BUSY_READ | AUTRI_SIS_ACRD_AUDIO_BUSY;
		break;
	case AUTRI_DEVICE_ID_ALI_M5451:
		if (sc->sc_revision > 0x01)
			addr = AUTRI_ALI_ACWR;
		else
			addr = AUTRI_ALI_ACRD;
		cmd  = AUTRI_ALI_ACRD_CMD_READ;
		busy = AUTRI_ALI_ACRD_BUSY_READ;
		break;
	default:
		printf("%s: autri_read_codec : unknown device\n",
		    sc->sc_dev.dv_xname);
		return -1;
	}

	/* wait for 'Ready to Read' */
	for (count=0; count < 0xffff; count++) {
		if ((TREAD4(sc, addr) & busy) == 0)
			break;
		DELAY(1);
	}

	if (count == 0xffff) {
		printf("%s: Codec timeout. Busy reading AC97 codec.\n",
		    sc->sc_dev.dv_xname);
		return -1;
	}

	/* send Read Command to AC97 */
	TWRITE4(sc, addr, (index & 0x7f) | cmd);

	/* wait for 'Returned data is available' */
	for (count=0; count < 0xffff; count++) {
		status = TREAD4(sc, addr);
		if ((status & busy) == 0)
			break;
		DELAY(1);
	}

	if (count == 0xffff) {
		printf("%s: Codec timeout. Busy reading AC97 codec.\n",
		    sc->sc_dev.dv_xname);
		return -1;
	}

	*data =  (status >> 16) & 0x0000ffff;
	/*DPRINTF(("autri_read_codec(0x%X) return 0x%X\n",reg,*data));*/
	return 0;
}

int
autri_write_codec(void *sc_, u_int8_t index, u_int16_t data)
{
	struct autri_codec_softc *codec = sc_;
	struct autri_softc *sc = codec->sc;
	u_int32_t addr, cmd, busy;
	u_int16_t count;

	/*DPRINTF(("autri_write_codec(0x%X,0x%X)\n",index,data));*/

	switch (sc->sc_devid) {
	case AUTRI_DEVICE_ID_4DWAVE_DX:
		addr = AUTRI_DX_ACR0;
		cmd  = AUTRI_DX_ACR0_CMD_WRITE;
		busy = AUTRI_DX_ACR0_BUSY_WRITE;
		break;
	case AUTRI_DEVICE_ID_4DWAVE_NX:
		addr = AUTRI_NX_ACR1;
		cmd  = AUTRI_NX_ACR1_CMD_WRITE;
		busy = AUTRI_NX_ACR1_BUSY_WRITE;
		break;
	case AUTRI_DEVICE_ID_SIS_7018:
		addr = AUTRI_SIS_ACWR;
		cmd  = AUTRI_SIS_ACWR_CMD_WRITE;
		busy = AUTRI_SIS_ACWR_BUSY_WRITE | AUTRI_SIS_ACWR_AUDIO_BUSY;
		break;
	case AUTRI_DEVICE_ID_ALI_M5451:
		addr = AUTRI_ALI_ACWR;
		cmd  = AUTRI_ALI_ACWR_CMD_WRITE;
		if (sc->sc_revision > 0x01)
			cmd  |= 0x0100;
		busy = AUTRI_ALI_ACWR_BUSY_WRITE;
		break;
	default:
		printf("%s: autri_write_codec : unknown device.\n",
		    sc->sc_dev.dv_xname);
		return -1;
	}

	/* wait for 'Ready to Write' */
	for (count=0; count < 0xffff; count++) {
		if ((TREAD4(sc, addr) & busy) == 0)
			break;
		DELAY(1);
	}

	if (count == 0xffff) {
		printf("%s: Codec timeout. Busy writing AC97 codec\n",
		    sc->sc_dev.dv_xname);
		return -1;
	}

	/* send Write Command to AC97 */
	TWRITE4(sc, addr, (data << 16) | (index & 0x7f) | cmd);

	return 0;
}

void
autri_reset_codec(void *sc_)
{
	struct autri_codec_softc *codec = sc_;
	struct autri_softc *sc = codec->sc;
	u_int32_t reg, ready;
	int addr, count = 200;

	DPRINTF(("autri_reset_codec(codec=%p,sc=%p)\n",codec,sc));
	DPRINTF(("sc->sc_devid=%X\n",sc->sc_devid));

	switch (sc->sc_devid) {
	case AUTRI_DEVICE_ID_4DWAVE_DX:
		/* warm reset AC97 codec */
		autri_reg_set_4(sc, AUTRI_DX_ACR2, 1);
		delay(100);
		/* release reset */
		autri_reg_clear_4(sc, AUTRI_DX_ACR2, 1);
		delay(100);

		addr = AUTRI_DX_ACR2;
		ready = AUTRI_DX_ACR2_CODEC_READY;
		break;
	case AUTRI_DEVICE_ID_4DWAVE_NX:
		/* warm reset AC97 codec */
		autri_reg_set_4(sc, AUTRI_NX_ACR0, 1);
		delay(100);
		/* release reset */
		autri_reg_clear_4(sc, AUTRI_NX_ACR0, 1);
		delay(100);

		addr = AUTRI_NX_ACR0;
		ready = AUTRI_NX_ACR0_CODEC_READY;
		break;
	case AUTRI_DEVICE_ID_SIS_7018:
		/* warm reset AC97 codec */
		autri_reg_set_4(sc, AUTRI_SIS_SCTRL, 2);
		delay(1000);
		/* release reset (warm & cold) */
		autri_reg_clear_4(sc, AUTRI_SIS_SCTRL, 3);
		delay(2000);

		addr = AUTRI_SIS_SCTRL;
		ready = AUTRI_SIS_SCTRL_CODEC_READY;
		break;
	case AUTRI_DEVICE_ID_ALI_M5451:
		/* warm reset AC97 codec */
		autri_reg_set_4(sc, AUTRI_ALI_SCTRL, 1);
		delay(100);
		/* release reset (warm & cold) */
		autri_reg_clear_4(sc, AUTRI_ALI_SCTRL, 3);
		delay(100);

		addr = AUTRI_ALI_SCTRL;
		ready = AUTRI_ALI_SCTRL_CODEC_READY;
		break;
	}

	/* wait for 'Codec Ready' */
	while (count--) {
		reg = TREAD4(sc, addr);
		if (reg & ready)
			break;
		delay(1000);
	}

	if (count == 0)
		printf("%s: Codec timeout. AC97 is not ready for operation.\n",
		    sc->sc_dev.dv_xname);
}

enum ac97_host_flags
autri_flags_codec(void *v)
{
	struct autri_codec_softc *sc = v;

	return (sc->flags);
}

/*
 *
 */
const struct pci_matchid autri_devices[] = {
	{ PCI_VENDOR_TRIDENT, PCI_PRODUCT_TRIDENT_4DWAVE_NX },
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_7018 },
	{ PCI_VENDOR_ALI, PCI_PRODUCT_ALI_M5451 }
};

int
autri_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_TRIDENT &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TRIDENT_4DWAVE_DX) {
		/*
		 * IBM makes a pcn network card and improperly
		 * sets the vendor and product ID's.  Avoid matching.
		 */
		if (PCI_CLASS(pa->pa_class) == PCI_CLASS_NETWORK)
			return (0);
		else
			return (1);
	}

	return (pci_matchbyid((struct pci_attach_args *)aux, autri_devices,
	    nitems(autri_devices)));
}

void
autri_attach(struct device *parent, struct device *self, void *aux)
{
	struct autri_softc *sc = (struct autri_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	struct autri_codec_softc *codec;
	bus_size_t iosize;
	pci_intr_handle_t ih;
	char const *intrstr;
	mixer_ctrl_t ctl;
	int i, r;

	sc->sc_devid = pa->pa_id;
	sc->sc_class = pa->pa_class;
	sc->sc_revision = PCI_REVISION(pa->pa_class);

	/* map register to memory */
	if (pci_mapreg_map(pa, AUTRI_PCI_MEMORY_BASE,
	    PCI_MAPREG_TYPE_MEM, 0, &sc->memt, &sc->memh, NULL, &iosize, 0)) {
		printf("%s: can't map mem space\n", sc->sc_dev.dv_xname);
		return;
	}

	/* map and establish the interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
		bus_space_unmap(sc->memt, sc->memh, iosize);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    autri_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->memt, sc->memh, iosize);
		return;
	}
	printf(": %s\n", intrstr);

	sc->sc_dmatag = pa->pa_dmat;
	sc->sc_pc = pc;
	sc->sc_pt = pa->pa_tag;

	/* initialize the device */
	autri_init(sc);

	/* attach AC97 codec */
	codec = &sc->sc_codec;
	memcpy(&codec->sc_dev, &sc->sc_dev, sizeof(codec->sc_dev));
	codec->sc = sc;

	codec->host_if.arg = codec;
	codec->host_if.attach = autri_attach_codec;
	codec->host_if.reset = autri_reset_codec;
	codec->host_if.read = autri_read_codec;
	codec->host_if.write = autri_write_codec;
	codec->host_if.flags = autri_flags_codec;
	codec->flags = AC97_HOST_DONT_READ | AC97_HOST_SWAPPED_CHANNELS;
	if (sc->sc_dev.dv_cfdata->cf_flags & 0x0001)
		codec->flags &= ~AC97_HOST_SWAPPED_CHANNELS;

	if ((r = ac97_attach(&codec->host_if)) != 0) {
		printf("%s: can't attach codec (error 0x%X)\n",
		    sc->sc_dev.dv_xname, r);
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->memt, sc->memh, iosize);
		return;
	}

	/* disable mutes */
	for (i = 0; i < 4; i++) {
		static struct {
			char *class, *device;
		} d[] = {
			{ AudioCoutputs, AudioNmaster},
			{ AudioCinputs, AudioNdac},
			{ AudioCinputs, AudioNcd},
			{ AudioCrecord, AudioNvolume},
		};

		ctl.type = AUDIO_MIXER_ENUM;
		ctl.un.ord = 0;

#if 0
		ctl.dev = sc->sc_codec.codec_if->vtbl->get_portnum_by_name(sc->sc_codec.codec_if,
		    d[i].class, d[i].device, AudioNmute);
#endif
		ctl.dev = autri_get_portnum_by_name(sc,d[i].class,
						   d[i].device, AudioNmute);
		autri_mixer_set_port(sc, &ctl);
	}

	/* set a reasonable default volume */
	ctl.type = AUDIO_MIXER_VALUE;
	ctl.un.value.num_channels = 2;
	ctl.un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
	ctl.un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 127;

	ctl.dev = autri_get_portnum_by_name(sc,AudioCoutputs,AudioNmaster,NULL);
	autri_mixer_set_port(sc, &ctl);

	audio_attach_mi(&autri_hw_if, sc, &sc->sc_dev);

#if NMIDI > 0
	midi_attach_mi(&autri_midi_hw_if, sc, &sc->sc_dev);
#endif
}

int
autri_activate(struct device *self, int act)
{
	struct autri_softc *sc = (struct autri_softc *)self;

	if (act == DVACT_RESUME) {
		autri_init(sc);
		ac97_resume(&sc->sc_codec.host_if, sc->sc_codec.codec_if);
	}
	return (config_activate_children(self, act));
}

int
autri_init(void *sc_)
{
	struct autri_softc *sc = sc_;
	pcireg_t reg;

	pci_chipset_tag_t pc = sc->sc_pc;
	pcitag_t pt = sc->sc_pt;

	DPRINTF(("in autri_init()\n"));
	DPRINTFN(5,("pci_conf_read(0x40) : 0x%X\n",pci_conf_read(pc,pt,0x40)));
	DPRINTFN(5,("pci_conf_read(0x44) : 0x%X\n",pci_conf_read(pc,pt,0x44)));

	switch (sc->sc_devid) {
	case AUTRI_DEVICE_ID_4DWAVE_DX:
		/* disable Legacy Control */
		pci_conf_write(pc, pt, AUTRI_PCI_DDMA_CFG,0);
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg & 0xffff0000);
		delay(100);
		/* audio engine reset */
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg | 0x00040000);
		delay(100);
		/* release reset */
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg & ~0x00040000);
		delay(100);
		/* DAC on */
		autri_reg_set_4(sc,AUTRI_DX_ACR2,0x02);
		break;
	case AUTRI_DEVICE_ID_4DWAVE_NX:
		/* disable Legacy Control */
		pci_conf_write(pc, pt, AUTRI_PCI_DDMA_CFG,0);
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg & 0xffff0000);
		delay(100);
		/* audio engine reset */
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg | 0x00010000);
		delay(100);
		/* release reset */
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg & ~0x00010000);
		delay(100);
		/* DAC on */
		autri_reg_set_4(sc,AUTRI_NX_ACR0,0x02);
		break;
	case AUTRI_DEVICE_ID_SIS_7018:
		/* disable Legacy Control */
		pci_conf_write(pc, pt, AUTRI_PCI_DDMA_CFG,0);
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg & 0xffff0000);
		delay(100);
		/* reset Digital Controller */
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg | 0x000c0000);
		delay(100);
		/* release reset */
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg & ~0x00040000);
		delay(100);
		/* disable AC97 GPIO interrupt */
		TWRITE1(sc, AUTRI_SIS_ACGPIO, 0);
		/* enable 64 channel mode */
		autri_reg_set_4(sc, AUTRI_LFO_GC_CIR, BANK_B_EN);
		break;
	case AUTRI_DEVICE_ID_ALI_M5451:
		/* disable Legacy Control */
		pci_conf_write(pc, pt, AUTRI_PCI_DDMA_CFG,0);
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg & 0xffff0000);
		delay(100);
		/* reset Digital Controller */
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg | 0x000c0000);
		delay(100);
		/* release reset */
		reg = pci_conf_read(pc, pt, AUTRI_PCI_LEGACY_IOBASE);
		pci_conf_write(pc, pt, AUTRI_PCI_LEGACY_IOBASE, reg & ~0x00040000);
		delay(100);
		/* enable PCM input */
		autri_reg_set_4(sc, AUTRI_ALI_GCONTROL, AUTRI_ALI_GCONTROL_PCM_IN);
		break;
	}

	if (sc->sc_devid == AUTRI_DEVICE_ID_ALI_M5451) {
		sc->sc_play.ch      = 0;
		sc->sc_play.ch_intr = 1;
		sc->sc_rec.ch       = 2;
		sc->sc_rec.ch_intr  = 3;
	} else {
		sc->sc_play.ch      = 0x20;
		sc->sc_play.ch_intr = 0x21;
		sc->sc_rec.ch       = 0x22;
		sc->sc_rec.ch_intr  = 0x23;
	}

	/* clear channel status */
	TWRITE4(sc, AUTRI_STOP_A, 0xffffffff);
	TWRITE4(sc, AUTRI_STOP_B, 0xffffffff);

	/* disable channel interrupt */
	TWRITE4(sc, AUTRI_AINTEN_A, 0);
	TWRITE4(sc, AUTRI_AINTEN_B, 0);

#if 0
	/* TLB */
	if (sc->sc_devid == AUTRI_DEVICE_ID_4DWAVE_NX) {
		TWRITE4(sc,AUTRI_NX_TLBC,0);
	}
#endif

	autri_enable_loop_interrupt(sc);

	DPRINTF(("out autri_init()\n"));
	return 0;
}

void
autri_enable_loop_interrupt(void *sc_)
{
	struct autri_softc *sc = sc_;
	u_int32_t reg;

	/*reg = (ENDLP_IE | MIDLP_IE);*/
	reg = ENDLP_IE;
#if 0
	if (sc->sc_devid == AUTRI_DEVICE_ID_SIS_7018)
		reg |= BANK_B_EN;
#endif
	autri_reg_set_4(sc,AUTRI_LFO_GC_CIR,reg);
}

#if 0
void
autri_disable_loop_interrupt(void *sc_)
{
	struct autri_softc *sc = sc_;
	u_int32_t reg;

	reg = (ENDLP_IE | MIDLP_IE);
	autri_reg_clear_4(sc,AUTRI_LFO_GC_CIR,reg);
}
#endif

int
autri_intr(void *p)
{
	struct autri_softc *sc = p;
	u_int32_t intsrc;
	u_int32_t mask, active[2];
	int ch, endch;
/*
	u_int32_t reg;
	u_int32_t cso,eso;
*/

	mtx_enter(&audio_lock);
	intsrc = TREAD4(sc,AUTRI_MISCINT);
	if ((intsrc & (ADDRESS_IRQ|MPU401_IRQ)) == 0) {
		mtx_leave(&audio_lock);
		return 0;
	}

	if (intsrc & ADDRESS_IRQ) {

		active[0] = TREAD4(sc,AUTRI_AIN_A);
		active[1] = TREAD4(sc,AUTRI_AIN_B);

		if (sc->sc_devid == AUTRI_DEVICE_ID_ALI_M5451) {
			endch = 32;
		} else {
			endch = 64;
		}

		for (ch=0; ch<endch; ch++) {
			mask = 1 << (ch & 0x1f);
			if (active[(ch & 0x20) ? 1 : 0] & mask) {

				/* clear interrupt */
				TWRITE4(sc, (ch & 0x20) ? AUTRI_AIN_B : AUTRI_AIN_A, mask);
				/* disable interrupt */
				autri_reg_clear_4(sc,(ch & 0x20) ? AUTRI_AINTEN_B : AUTRI_AINTEN_A, mask);
#if 0
				reg = TREAD4(sc,AUTRI_LFO_GC_CIR) & ~0x0000003f;
				TWRITE4(sc,AUTRI_LFO_GC_CIR, reg | ch);

				if (sc->sc_devid == AUTRI_DEVICE_ID_4DWAVE_NX) {
				  cso = TREAD4(sc, 0xe0) & 0x00ffffff;
				  eso = TREAD4(sc, 0xe8) & 0x00ffffff;
				} else {
				  cso = (TREAD4(sc, 0xe0) >> 16) & 0x0000ffff;
				  eso = (TREAD4(sc, 0xe8) >> 16) & 0x0000ffff;
				}
				/*printf("cso=%d, eso=%d\n",cso,eso);*/
#endif
				if (ch == sc->sc_play.ch_intr) {
					if (sc->sc_play.intr)
						sc->sc_play.intr(sc->sc_play.intr_arg);
				}

				if (ch == sc->sc_rec.ch_intr) {
					if (sc->sc_rec.intr)
						sc->sc_rec.intr(sc->sc_rec.intr_arg);
				}

				/* enable interrupt */
				autri_reg_set_4(sc, (ch & 0x20) ? AUTRI_AINTEN_B : AUTRI_AINTEN_A, mask);
			}
		}
	}

	if (intsrc & MPU401_IRQ) {
		/* XXX */
	}

	autri_reg_set_4(sc,AUTRI_MISCINT,
		ST_TARGET_REACHED | MIXER_OVERFLOW | MIXER_UNDERFLOW);
	mtx_leave(&audio_lock);
	return 1;
}

/*
 *
 */

int
autri_allocmem(struct autri_softc *sc, size_t size, size_t align,
    struct autri_dma *p)
{
	int error;

	p->size = size;
	error = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,
	    p->segs, nitems(p->segs), &p->nsegs, BUS_DMA_NOWAIT);
	if (error)
		return (error);

	error = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size,
	    &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (error)
		goto free;

	error = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,
	    0, BUS_DMA_NOWAIT, &p->map);
	if (error)
		goto unmap;

	error = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL,
	    BUS_DMA_NOWAIT);
	if (error)
		goto destroy;
	return (0);

destroy:
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
unmap:
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
free:
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return (error);
}

int
autri_freemem(struct autri_softc *sc, struct autri_dma *p)
{
	bus_dmamap_unload(sc->sc_dmatag, p->map);
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return 0;
}

int
autri_open(void *addr, int flags)
{
	DPRINTF(("autri_open()\n"));
	DPRINTFN(5,("MISCINT    : 0x%08X\n",
	    TREAD4((struct autri_softc *)addr, AUTRI_MISCINT)));
	DPRINTFN(5,("LFO_GC_CIR : 0x%08X\n",
	    TREAD4((struct autri_softc *)addr, AUTRI_LFO_GC_CIR)));
	return 0;
}

void
autri_close(void *addr)
{
	DPRINTF(("autri_close()\n"));
}

int
autri_set_params(void *addr, int setmode, int usemode, struct audio_params *play,
    struct audio_params *rec)
{
	struct audio_params *p;
	int mode;

	for (mode = AUMODE_RECORD; mode != -1;
	    mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;
		p = mode == AUMODE_PLAY ? play : rec;
		p->sample_rate = 48000;
		if (p->precision != 8)
			p->precision = 16;
		if (p->channels != 1)
			p->channels = 2;
		p->encoding = p->precision == 16 ?
		    AUDIO_ENCODING_SLINEAR_LE : AUDIO_ENCODING_ULINEAR_LE;
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
	}

	return 0;
}

int
autri_round_blocksize(void *addr, int block)
{
	return ((block + 3) & -4);
}

int
autri_halt_output(void *addr)
{
	struct autri_softc *sc = addr;

	DPRINTF(("autri_halt_output()\n"));
	mtx_enter(&audio_lock);
	sc->sc_play.intr = NULL;
	autri_stopch(sc, sc->sc_play.ch, sc->sc_play.ch_intr);
	autri_disable_interrupt(sc, sc->sc_play.ch_intr);
	mtx_leave(&audio_lock);
	return 0;
}

int
autri_halt_input(void *addr)
{
	struct autri_softc *sc = addr;

	DPRINTF(("autri_halt_input()\n"));
	mtx_enter(&audio_lock);
	sc->sc_rec.intr = NULL;
	autri_stopch(sc, sc->sc_rec.ch, sc->sc_rec.ch_intr);
	autri_disable_interrupt(sc, sc->sc_rec.ch_intr);
	mtx_leave(&audio_lock);
	return 0;
}

int
autri_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct autri_softc *sc = addr;

	return (sc->sc_codec.codec_if->vtbl->mixer_set_port(
	    sc->sc_codec.codec_if, cp));
}

int
autri_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct autri_softc *sc = addr;

	return (sc->sc_codec.codec_if->vtbl->mixer_get_port(
	    sc->sc_codec.codec_if, cp));
}

int
autri_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct autri_softc *sc = addr;

	return (sc->sc_codec.codec_if->vtbl->query_devinfo(
	    sc->sc_codec.codec_if, dip));
}

int
autri_get_portnum_by_name(struct autri_softc *sc, char *class, char *device,
    char *qualifier)
{
	return (sc->sc_codec.codec_if->vtbl->get_portnum_by_name(
	    sc->sc_codec.codec_if, class, device, qualifier));
}

void *
autri_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct autri_softc *sc = addr;
	struct autri_dma *p;
	int error;

	p = malloc(sizeof(*p), pool, flags);
	if (!p)
		return NULL;

#if 0
	error = autri_allocmem(sc, size, 16, p);
#endif
	error = autri_allocmem(sc, size, 0x10000, p);
	if (error) {
		free(p, pool, 0);
		return NULL;
	}

	p->next = sc->sc_dmas;
	sc->sc_dmas = p;
	return KERNADDR(p);
}

void
autri_free(void *addr, void *ptr, int pool)
{
	struct autri_softc *sc = addr;
	struct autri_dma **pp, *p;

	for (pp = &sc->sc_dmas; (p = *pp) != NULL; pp = &p->next) {
		if (KERNADDR(p) == ptr) {
			autri_freemem(sc, p);
			*pp = p->next;
			free(p, pool, 0);
			return;
		}
	}
}

struct autri_dma *
autri_find_dma(struct autri_softc *sc, void *addr)
{
	struct autri_dma *p;

	for (p = sc->sc_dmas; p && KERNADDR(p) != addr; p = p->next)
		;

	return p;
}

int
autri_get_props(void *addr)
{
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT |
		AUDIO_PROP_FULLDUPLEX);
}

void
autri_setup_channel(struct autri_softc *sc, int mode, struct audio_params *param)
{
	int i, ch, channel;
	u_int32_t reg, cr[5];
	u_int32_t cso, eso;
	u_int32_t delta, dch[2], ctrl;
	u_int32_t alpha_fms, fm_vol, attribute;

	u_int32_t dmaaddr, dmalen;
	int factor, rvol, cvol;
	struct autri_chstatus *chst;

	ctrl = AUTRI_CTRL_LOOPMODE;
	switch (param->encoding) {
	case AUDIO_ENCODING_SLINEAR_BE:
	case AUDIO_ENCODING_SLINEAR_LE:
		ctrl |= AUTRI_CTRL_SIGNED;
		break;
	}

	factor = 0;
	if (param->precision == 16) {
		ctrl |= AUTRI_CTRL_16BIT;
		factor++;
	}

	if (param->channels == 2) {
		ctrl |= AUTRI_CTRL_STEREO;
		factor++;
	}

	delta = (u_int32_t)param->sample_rate;
	if (delta < 4000)
		delta = 4000;
	if (delta > 48000)
		delta = 48000;

	attribute = 0;

	dch[1] = ((delta << 12) / 48000) & 0x0000ffff;
	if (mode == AUMODE_PLAY) {
		chst = &sc->sc_play;
		dch[0] = ((delta << 12) / 48000) & 0x0000ffff;
		ctrl |= AUTRI_CTRL_WAVEVOL;
/*
		if (sc->sc_devid == AUTRI_DEVICE_ID_ALI_M5451)
			ctrl |= 0x80000000;
*/
	} else {
		chst = &sc->sc_rec;
		dch[0] = ((48000 << 12) / delta) & 0x0000ffff;
		if (sc->sc_devid == AUTRI_DEVICE_ID_SIS_7018) {
			ctrl |= AUTRI_CTRL_MUTE_SIS;
			attribute = AUTRI_ATTR_PCMREC_SIS;
			if (delta != 48000)
				attribute |= AUTRI_ATTR_ENASRC_SIS;
		}
		ctrl |= AUTRI_CTRL_MUTE;
	}

	dmaaddr = DMAADDR(chst->dma);
	cso = alpha_fms = 0;
	rvol = cvol = 0x7f;
	fm_vol = 0x0 | ((rvol & 0x7f) << 7) | (cvol & 0x7f);

	for (ch=0; ch<2; ch++) {

		if (ch == 0)
			dmalen = (chst->length >> factor);
		else {
			/* channel for interrupt */
			dmalen = (chst->blksize >> factor);
			if (sc->sc_devid == AUTRI_DEVICE_ID_SIS_7018)
				ctrl |= AUTRI_CTRL_MUTE_SIS;
			else
				ctrl |= AUTRI_CTRL_MUTE;
			attribute = 0;
		}

		eso = dmalen - 1;

		switch (sc->sc_devid) {
		case AUTRI_DEVICE_ID_4DWAVE_DX:
			cr[0] = (cso << 16) | (alpha_fms & 0x0000ffff);
			cr[1] = dmaaddr;
			cr[2] = (eso << 16) | (dch[ch] & 0x0000ffff);
			cr[3] = fm_vol;
			cr[4] = ctrl;
			break;
		case AUTRI_DEVICE_ID_4DWAVE_NX:
			cr[0] = (dch[ch] << 24) | (cso & 0x00ffffff);
			cr[1] = dmaaddr;
			cr[2] = ((dch[ch] << 16) & 0xff000000) | (eso & 0x00ffffff);
			cr[3] = (alpha_fms << 16) | (fm_vol & 0x0000ffff);
			cr[4] = ctrl;
			break;
		case AUTRI_DEVICE_ID_SIS_7018:
			cr[0] = (cso << 16) | (alpha_fms & 0x0000ffff);
			cr[1] = dmaaddr;
			cr[2] = (eso << 16) | (dch[ch] & 0x0000ffff);
			cr[3] = attribute;
			cr[4] = ctrl;
			break;
		case AUTRI_DEVICE_ID_ALI_M5451:
			cr[0] = (cso << 16) | (alpha_fms & 0x0000ffff);
			cr[1] = dmaaddr;
			cr[2] = (eso << 16) | (dch[ch] & 0x0000ffff);
			cr[3] = 0;
			cr[4] = ctrl;
			break;
		}

		/* write channel data */
		channel = (ch == 0) ? chst->ch : chst->ch_intr;

		reg = TREAD4(sc,AUTRI_LFO_GC_CIR) & ~0x0000003f;
		TWRITE4(sc,AUTRI_LFO_GC_CIR, reg | channel);

		for (i=0; i<5; i++) {
			TWRITE4(sc, AUTRI_ARAM_CR + i*sizeof(cr[0]), cr[i]);
			DPRINTFN(5,("cr[%d] : 0x%08X\n", i, cr[i]));
		}

		/* Bank A only */
		if (channel < 0x20) {
			TWRITE4(sc, AUTRI_EBUF1, AUTRI_EMOD_STILL);
			TWRITE4(sc, AUTRI_EBUF2, AUTRI_EMOD_STILL);
		}
	}

}

int
autri_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct autri_softc *sc = addr;
	struct autri_dma *p;

	DPRINTFN(5,("autri_trigger_output: sc=%p start=%p end=%p "
	    "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));

	sc->sc_play.intr = intr;
	sc->sc_play.intr_arg = arg;
	sc->sc_play.offset = 0;
	sc->sc_play.blksize = blksize;
	sc->sc_play.length = (char *)end - (char *)start;

	p = autri_find_dma(sc, start);
	if (!p) {
		printf("autri_trigger_output: bad addr %p\n", start);
		return (EINVAL);
	}

	sc->sc_play.dma = p;

	/* */
	mtx_enter(&audio_lock);
	autri_setup_channel(sc, AUMODE_PLAY, param);

	/* volume set to no attenuation */
	TWRITE4(sc, AUTRI_MUSICVOL_WAVEVOL, 0);

	/* enable interrupt */
	autri_enable_interrupt(sc, sc->sc_play.ch_intr);

	/* start channel */
	autri_startch(sc, sc->sc_play.ch, sc->sc_play.ch_intr);
	mtx_leave(&audio_lock);
	return 0;
}

int
autri_trigger_input(void *addr, void *start, void *end, int blksize, void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct autri_softc *sc = addr;
	struct autri_dma *p;

	DPRINTFN(5,("autri_trigger_input: sc=%p start=%p end=%p "
	    "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));

	sc->sc_rec.intr = intr;
	sc->sc_rec.intr_arg = arg;
	sc->sc_rec.offset = 0;
	sc->sc_rec.blksize = blksize;
	sc->sc_rec.length = (char *)end - (char *)start;

	/* */
	p = autri_find_dma(sc, start);
	if (!p) {
		printf("autri_trigger_input: bad addr %p\n", start);
		return (EINVAL);
	}

	sc->sc_rec.dma = p;
	mtx_enter(&audio_lock);

	/* */
	if (sc->sc_devid == AUTRI_DEVICE_ID_4DWAVE_NX) {
		autri_reg_set_4(sc, AUTRI_NX_ACR0, AUTRI_NX_ACR0_PSB_CAPTURE);
		TWRITE1(sc, AUTRI_NX_RCI3, AUTRI_NX_RCI3_ENABLE | sc->sc_rec.ch);
	}

#if 0
	/* 4DWAVE only allows capturing at a 48KHz rate */
	if (sc->sc_devid == AUTRI_DEVICE_ID_4DWAVE_DX ||
	    sc->sc_devid == AUTRI_DEVICE_ID_4DWAVE_NX)
		param->sample_rate = 48000;
#endif

	autri_setup_channel(sc, AUMODE_RECORD, param);

	/* enable interrupt */
	autri_enable_interrupt(sc, sc->sc_rec.ch_intr);

	/* start channel */
	autri_startch(sc, sc->sc_rec.ch, sc->sc_rec.ch_intr);
	mtx_leave(&audio_lock);
	return 0;
}

#if 0
int
autri_halt(struct autri_softc *sc)
{
	DPRINTF(("autri_halt().\n"));
	/*autri_stopch(sc);*/
	autri_disable_interrupt(sc, sc->sc_play.channel);
	autri_disable_interrupt(sc, sc->sc_rec.channel);
	return 0;
}
#endif

void
autri_enable_interrupt(struct autri_softc *sc, int ch)
{
	int reg;

	reg = (ch & 0x20) ? AUTRI_AINTEN_B : AUTRI_AINTEN_A;
	ch &= 0x1f;

	autri_reg_set_4(sc, reg, 1 << ch);
}

void
autri_disable_interrupt(struct autri_softc *sc, int ch)
{
	int reg;

	reg = (ch & 0x20) ? AUTRI_AINTEN_B : AUTRI_AINTEN_A;
	ch &= 0x1f;

	autri_reg_clear_4(sc, reg, 1 << ch);
}

void
autri_startch(struct autri_softc *sc, int ch, int ch_intr)
{
	int reg;
	u_int32_t chmask;

	reg = (ch & 0x20) ? AUTRI_START_B : AUTRI_START_A;
	ch &= 0x1f;
	chmask = (1 << ch) | (1 << ch_intr);

	autri_reg_set_4(sc, reg, chmask);
}

void
autri_stopch(struct autri_softc *sc, int ch, int ch_intr)
{
	int reg;
	u_int32_t chmask;

	reg = (ch & 0x20) ? AUTRI_STOP_B : AUTRI_STOP_A;
	ch &= 0x1f;
	chmask = (1 << ch) | (1 << ch_intr);

	autri_reg_set_4(sc, reg, chmask);
}

#if NMIDI > 0
int
autri_midi_open(void *addr, int flags, void (*iintr)(void *, int),
    void (*ointr)(void *), void *arg)
{
	struct autri_softc *sc = addr;

	DPRINTF(("autri_midi_open()\n"));

	DPRINTFN(5,("MPUR1 : 0x%02X\n",TREAD1(sc,AUTRI_MPUR1)));
	DPRINTFN(5,("MPUR2 : 0x%02X\n",TREAD1(sc,AUTRI_MPUR2)));

	sc->sc_iintr = iintr;
	sc->sc_ointr = ointr;
	sc->sc_arg = arg;

	if (flags & FREAD)
		autri_reg_clear_1(sc, AUTRI_MPUR2, AUTRI_MIDIIN_ENABLE_INTR);

	if (flags & FWRITE)
		autri_reg_set_1(sc, AUTRI_MPUR2, AUTRI_MIDIOUT_CONNECT);

	return (0);
}

void
autri_midi_close(void *addr)
{
	struct autri_softc *sc = addr;

	DPRINTF(("autri_midi_close()\n"));

	tsleep(sc, PWAIT, "autri", hz/10); /* give uart a chance to drain */

	sc->sc_iintr = NULL;
	sc->sc_ointr = NULL;
}

int
autri_midi_output(void *addr, int d)
{
	struct autri_softc *sc = addr;

	if ((TREAD1(sc, AUTRI_MPUR1) & AUTRI_MIDIOUT_READY) != 0) {
		TWRITE1(sc, AUTRI_MPUR0, d);
		return 0;
	}
	return 1;
}

void
autri_midi_getinfo(void *addr, struct midi_info *mi)
{
	mi->name = "4DWAVE MIDI UART";
	mi->props = MIDI_PROP_CAN_INPUT;
}

#endif
@


1.41
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.40 2016/09/14 06:12:19 ratchov Exp $	*/
a587 1
	int rv = 0;
d589 1
a589 2
	switch (act) {
	case DVACT_RESUME:
a591 5
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
d593 1
a593 1
	return (rv);
@


1.40
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.38 2015/06/10 20:02:42 ratchov Exp $	*/
a132 1
int	autri_getdev(void *, struct audio_device *);
a154 1
	autri_getdev,
a950 31
	return 0;
}

int
autri_getdev(void *addr, struct audio_device *retp)
{
	struct autri_softc *sc = addr;

	DPRINTF(("autri_getdev().\n"));

	strncpy(retp->name, "Trident 4DWAVE", sizeof(retp->name));
	snprintf(retp->version, sizeof(retp->version), "0x%02x",
	    PCI_REVISION(sc->sc_class));

	switch (sc->sc_devid) {
	case AUTRI_DEVICE_ID_4DWAVE_DX:
		strncpy(retp->config, "4DWAVE-DX", sizeof(retp->config));
		break;
	case AUTRI_DEVICE_ID_4DWAVE_NX:
		strncpy(retp->config, "4DWAVE-NX", sizeof(retp->config));
		break;
	case AUTRI_DEVICE_ID_SIS_7018:
		strncpy(retp->config, "SiS 7018", sizeof(retp->config));
		break;
	case AUTRI_DEVICE_ID_ALI_M5451:
		strncpy(retp->config, "ALi M5451", sizeof(retp->config));
		break;
	default:
		strncpy(retp->config, "unknown", sizeof(retp->config));
	}

@


1.39
log
@Don't claim the autri(4) driver supports big-ending, signed 8-bit,
or unsigned 16-bit samples. Fixes sound on big endian machines.
@
text
@a123 1
int	autri_query_encoding(void *, struct audio_encoding *);
a137 1
paddr_t	autri_mappage(void *, void *, off_t, int);
a145 2
	NULL,			/* drain */
	autri_query_encoding,
a163 1
	autri_mappage,
d166 1
a166 2
	autri_trigger_input,
	NULL
a896 25
autri_query_encoding(void *addr, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return 0;
}

int
a1071 17
}

paddr_t
autri_mappage(void *addr, void *mem, off_t off, int prot)
{
	struct autri_softc *sc = addr;
	struct autri_dma *p;

	if (off < 0)
		return (-1);

	p = autri_find_dma(sc, mem);
	if (!p)
		return (-1);

	return (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs,
	    off, prot, BUS_DMA_WAITOK));
@


1.38
log
@Use first 4 channels of the board. The previous channel setting
caused DMA on the wrong memory location during recording.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.37 2015/05/11 06:46:21 ratchov Exp $	*/
a912 6
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 2:
a917 6
	case 3:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
a937 1

d939 2
a940 5
		if (p->sample_rate < 4000)
			p->sample_rate = 4000;
		if (p->sample_rate > 48000)
			p->sample_rate = 48000;
		if (p->precision > 16)
d942 1
a942 1
		if (p->channels > 2)
d944 2
a945 12
		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_BE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 16)
				return EINVAL;
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_LE:
			break;
		default:
			return (EINVAL);
		}
@


1.37
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.36 2014/07/12 18:48:51 tedu Exp $	*/
d700 2
a701 2
		sc->sc_rec.ch       = 31;
		sc->sc_rec.ch_intr  = 2;
@


1.36
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.35 2013/12/06 21:03:03 deraadt Exp $	*/
a52 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a912 12
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
d918 1
a918 1
	case 4:
d924 1
a924 1
	case 5:
a929 12
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a959 2
		p->factor = 1;
		p->sw_code = 0;
d963 2
a964 2
			if (p->precision == 16)
				p->sw_code = swap_bytes;
a967 14
			break;
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY)
				p->sw_code = mulaw_to_ulinear8;
			else
				p->sw_code = ulinear8_to_mulaw;

			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY)
				p->sw_code = alaw_to_ulinear8;
			else
				p->sw_code = ulinear8_to_alaw;

@


1.35
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.34 2013/11/15 16:46:27 brad Exp $	*/
d1137 1
a1137 1
		free(p, pool);
d1156 1
a1156 1
			free(p, pool);
@


1.34
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.33 2013/05/24 07:58:46 ratchov Exp $	*/
a600 5
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		break;
d606 2
a607 1
	case DVACT_DEACTIVATE:
@


1.33
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.32 2013/05/15 08:29:24 ratchov Exp $	*/
d198 1
a198 4
autri_reg_set_1(sc, no, mask)
	struct autri_softc *sc;
	int no;
	uint8_t mask;
d205 1
a205 4
autri_reg_clear_1(sc, no, mask)
	struct autri_softc *sc;
	int no;
	uint8_t mask;
d212 1
a212 4
autri_reg_set_4(sc, no, mask)
	struct autri_softc *sc;
	int no;
	uint32_t mask;
d219 1
a219 4
autri_reg_clear_4(sc, no, mask)
	struct autri_softc *sc;
	int no;
	uint32_t mask;
d229 1
a229 3
autri_attach_codec(sc_, codec_if)
	void *sc_;
	struct ac97_codec_if *codec_if;
d240 1
a240 4
autri_read_codec(sc_, index, data)
	void *sc_;
	u_int8_t index;
	u_int16_t *data;
d315 1
a315 4
autri_write_codec(sc_, index, data)
	void *sc_;
	u_int8_t index;
	u_int16_t data;
d373 1
a373 2
autri_reset_codec(sc_)
	void *sc_;
d461 1
a461 4
autri_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d482 1
a482 4
autri_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d618 1
a618 2
autri_init(sc_)
	void *sc_;
d737 1
a737 2
autri_enable_loop_interrupt(sc_)
	void *sc_;
d753 1
a753 2
autri_disable_loop_interrupt(sc_)
	void *sc_;
d764 1
a764 2
autri_intr(p)
	void *p;
d845 2
a846 5
autri_allocmem(sc, size, align, p)
	struct autri_softc *sc;
	size_t size;
	size_t align;
	struct autri_dma *p;
d882 1
a882 3
autri_freemem(sc, p)
	struct autri_softc *sc;
	struct autri_dma *p;
d892 1
a892 3
autri_open(addr, flags)
	void *addr;
	int flags;
d903 1
a903 2
autri_close(addr)
	void *addr;
d909 1
a909 3
autri_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d970 2
a971 4
autri_set_params(addr, setmode, usemode, play, rec)
	void *addr;
	int setmode, usemode;
	struct audio_params *play, *rec;
d1026 1
a1026 3
autri_round_blocksize(addr, block)
	void *addr;
	int block;
d1032 1
a1032 2
autri_halt_output(addr)
	void *addr;
d1046 1
a1046 2
autri_halt_input(addr)
	void *addr;
d1060 1
a1060 3
autri_getdev(addr, retp)
	void *addr;
	struct audio_device *retp;
d1091 1
a1091 3
autri_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1100 1
a1100 3
autri_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1109 1
a1109 3
autri_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d1118 2
a1119 3
autri_get_portnum_by_name(sc, class, device, qualifier)
	struct autri_softc *sc;
	char *class, *device, *qualifier;
d1126 1
a1126 5
autri_malloc(addr, direction, size, pool, flags)
	void *addr;
	int direction;
	size_t size;
	int pool, flags;
d1151 1
a1151 4
autri_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
d1167 1
a1167 3
autri_find_dma(sc, addr)
	struct autri_softc *sc;
	void *addr;
d1178 1
a1178 5
autri_mappage(addr, mem, off, prot)
	void *addr;
	void *mem;
	off_t off;
	int prot;
d1195 1
a1195 2
autri_get_props(addr)
	void *addr;
d1202 1
a1202 4
autri_setup_channel(sc, mode, param)
	struct autri_softc *sc;
	int mode;
	struct audio_params *param;
d1335 2
a1336 7
autri_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1375 1
a1375 7
autri_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1425 1
a1425 2
autri_halt(sc)
	struct autri_softc *sc;
d1436 1
a1436 3
autri_enable_interrupt(sc, ch)
	struct autri_softc *sc;
	int ch;
d1447 1
a1447 3
autri_disable_interrupt(sc, ch)
	struct autri_softc *sc;
	int ch;
d1458 1
a1458 3
autri_startch(sc, ch, ch_intr)
	struct autri_softc *sc;
	int ch, ch_intr;
d1471 1
a1471 3
autri_stopch(sc, ch, ch_intr)
	struct autri_softc *sc;
	int ch, ch_intr;
d1485 2
a1486 4
autri_midi_open(void *addr, int flags,
	void (*iintr)(void *, int),
	void (*ointr)(void *),
	void *arg)
@


1.32
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.31 2012/03/30 08:18:19 ratchov Exp $	*/
d539 2
a540 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, autri_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.31
log
@If the MIDI UART is not ready for output, don't spin at IPL_CLOCK;
just return and make the midi(4) driver retry later. UART buffers
are large enough for this, except eap(4) which uses interrupts for
output.
help from and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.30 2011/07/03 15:47:16 matthew Exp $	*/
d806 1
d808 2
a809 1
	if ((intsrc & (ADDRESS_IRQ|MPU401_IRQ)) == 0)
d811 1
d867 1
a867 1

d1083 1
a1083 1

d1087 1
a1087 1

d1098 1
a1098 1

d1102 1
a1102 1

d1437 1
d1448 1
a1448 1

d1481 1
d1503 1
a1503 1

@


1.30
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.29 2011/04/03 15:36:02 jasper Exp $	*/
a1614 1
	int x;
d1616 3
a1618 6
	for (x = 0; x != MIDI_BUSY_WAIT; x++) {
		if ((TREAD1(sc, AUTRI_MPUR1) & AUTRI_MIDIOUT_READY) == 0) {
			TWRITE1(sc, AUTRI_MPUR0, d);
			return (0);
		}
		delay(MIDI_BUSY_DELAY);
d1620 1
a1620 1
	return (EIO);
@


1.29
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.28 2010/09/21 02:53:14 jakemsr Exp $	*/
a627 2
	case DVACT_ACTIVATE:
		break;
@


1.28
log
@audio(4) and ac97(4) style suspend/resume
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.27 2010/09/07 16:21:44 deraadt Exp $	*/
d502 1
a502 1
	    sizeof(autri_devices)/sizeof(autri_devices[0])));
d885 1
a885 2
	    p->segs, sizeof(p->segs)/sizeof(p->segs[0]),
	    &p->nsegs, BUS_DMA_NOWAIT);
@


1.27
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.26 2010/08/27 18:50:56 deraadt Exp $	*/
d625 1
d628 5
d637 4
a640 2
		/*autri_reset_codec(&sc->sc_codec);*/
		(sc->sc_codec.codec_if->vtbl->restore_ports)(sc->sc_codec.codec_if);
d643 1
a643 1
	return 0;
@


1.26
log
@Since the changes in neo(4) work, it is very likely that the exact same
mechnical changes work in these drivers too.  Testing can occur after
this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.25 2010/07/15 03:43:11 jakemsr Exp $	*/
a101 1
void autri_powerhook(int why,void *addr);
a618 2

	powerhook_establish(autri_powerhook, sc);
a635 6
}

void
autri_powerhook(int why,void *addr)
{
	autri_activate(addr, why);
@


1.25
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.24 2010/04/08 00:23:53 tedu Exp $	*/
d75 1
d121 2
a122 1
	sizeof(struct autri_softc), autri_match, autri_attach
a620 1
	sc->sc_old_power = PWR_RESUME;
d624 2
a625 2
void
autri_powerhook(int why,void *addr)
d627 1
a627 1
	struct autri_softc *sc = addr;
d629 4
a632 2
	if (why == PWR_RESUME && sc->sc_old_power == PWR_SUSPEND) {
		DPRINTF(("PWR_RESUME\n"));
d636 1
d638 7
a644 1
	sc->sc_old_power = why;
@


1.24
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.23 2009/03/29 21:53:52 sthen Exp $	*/
d995 2
d1052 2
@


1.23
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.22 2008/10/25 22:30:43 jakemsr Exp $	*/
a44 1
#include <sys/proc.h>
@


1.22
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.21 2008/04/21 00:32:42 jakemsr Exp $	*/
d528 1
a528 1
		printf("%s: can't map memory space\n", sc->sc_dev.dv_xname);
@


1.21
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.20 2007/05/26 00:36:03 krw Exp $	*/
d1015 8
a1022 6

		if (p->sample_rate < 4000 || p->sample_rate > 48000 ||
		    (p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return (EINVAL);

@


1.20
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.19 2007/05/25 21:27:15 krw Exp $	*/
d174 1
@


1.19
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.18 2006/04/07 22:41:33 jsg Exp $	*/
d311 1
a311 1
	/* wait for 'Returned data is avalable' */
@


1.18
log
@Add optional flush method to MIDI hardware interface.
Allow umidi(4) to send multiple events in a single USB transfer.
This greatly improves the number of interrupts umidi is able to generate.

From Alexandre Ratchov.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.17 2006/02/22 18:12:24 brad Exp $	*/
d818 1
a818 1
				/* clear interupt */
d820 1
a820 1
				/* disable interupt */
@


1.17
log
@IBM makes a pcn card that shows up as:
Trident Microsystems 4DWAVE DX (ethernet network, revision 0x25)
Unfortunately, this is an autri sound card.  Special case the match routines
for both drivers so if_pcn properly picks it up and autri does not.

From NetBSD

ok mickey@@, tested by martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.16 2005/08/09 04:10:10 mickey Exp $	*/
d187 1
@


1.16
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.15 2005/04/16 21:57:23 mickey Exp $	*/
a473 1
	{ PCI_VENDOR_TRIDENT, PCI_PRODUCT_TRIDENT_4DWAVE_DX },
d476 1
a476 1
	{ PCI_VENDOR_ALI, PCI_PRODUCT_ALI_M5451 },
d485 14
@


1.15
log
@do not provide round_buffer if not needed unless explained why in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.14 2005/04/14 12:42:16 mickey Exp $	*/
a504 1
	u_int32_t reg;
a540 5
	/* enable the device */
	reg = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	reg |= (PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE);
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, reg);

d628 1
a628 1
	u_int32_t reg;
@


1.14
log
@make sure round_blocksize does not produce 0 after alignment
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.13 2003/04/27 11:22:53 ho Exp $	*/
a140 1
size_t	autri_round_buffersize(void *, int, size_t);
d169 1
a169 1
	autri_round_buffersize,
a1216 9
}

size_t
autri_round_buffersize(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
{
	return size;
@


1.13
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.12 2003/03/09 01:52:14 tedu Exp $	*/
d1051 1
a1051 1
	return (block & -4);
@


1.12
log
@flag stereo channels as reversed.  those rare people without swapped stereo
can use config -e to set flags to 0x0001.

ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.11 2002/11/29 04:59:59 fgsch Exp $	*/
d938 1
a938 1
		strcpy(fp->name, AudioEulinear);
d944 1
a944 1
		strcpy(fp->name, AudioEmulaw);
d950 1
a950 1
		strcpy(fp->name, AudioEalaw);
d956 1
a956 1
		strcpy(fp->name, AudioEslinear);
d962 1
a962 1
		strcpy(fp->name, AudioEslinear_le);
d968 1
a968 1
		strcpy(fp->name, AudioEulinear_le);
d974 1
a974 1
		strcpy(fp->name, AudioEslinear_be);
d980 1
a980 1
		strcpy(fp->name, AudioEulinear_be);
@


1.11
log
@- Fix playback problem on SiS7018.
- mute the volume for interrupt channel.
- add some improvements for device initialization.
- Fix recording problem on SiS7018.

From NetBSD via Gabriel Gonzalez.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.9 2002/10/04 19:55:19 mickey Exp $	*/
d466 3
a468 1
	return (AC97_HOST_DONT_READ);
d562 3
@


1.10
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d428 2
a429 2
		autri_reg_set_4(sc, AUTRI_SIS_SCTRL, 1);
		delay(100);
d432 1
a432 1
		delay(100);
d1294 2
d1300 1
a1300 2
		if (sc->sc_devid != AUTRI_DEVICE_ID_SIS_7018)
			ctrl |= AUTRI_CTRL_WAVEVOL;
d1308 6
a1320 1
	attribute = 0;
d1329 5
a1333 1
			ctrl |= AUTRI_CTRL_MUTE;
d1357 1
a1357 1
			cr[3] = (attribute << 16) | (fm_vol & 0x0000ffff);
@


1.9
log
@do not read the codec regs, it seems to shutter the sound; from grendel@@zeitbombe.org, reported and tested by rayl@@spamcop.net
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.8 2002/09/26 22:14:50 mickey Exp $	*/
d472 6
d485 2
a486 25
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_TRIDENT:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_TRIDENT_4DWAVE_DX:
		case PCI_PRODUCT_TRIDENT_4DWAVE_NX:
			return 1;
		}
		break;
	case PCI_VENDOR_SIS:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_SIS_7018:
			return 1;
		}
		break;
	case PCI_VENDOR_ALI:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ALI_M5451:
			return 1;
		}
		break;
	}

	return 0;
@


1.8
log
@time-bind the codec r/w loops, still does not solve problems on transmeta; tested by jason@@ on sparc64; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.7 2002/03/14 03:16:06 millert Exp $	*/
d100 1
d463 6
d576 1
@


1.7
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.6 2002/03/14 01:26:58 millert Exp $	*/
d295 1
a295 1
	for (count=0; count<0xffff; count++) {
d298 1
d311 1
a311 1
	for (count=0; count<0xffff; count++) {
d315 1
d372 1
a372 1
	for (count=0; count<0xffff; count++) {
d375 1
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.5 2002/01/20 19:56:53 ericj Exp $	*/
d126 2
a127 1
int	autri_set_params(void *, int, int, struct audio_params *, struct audio_params *);
d129 4
a132 6
int	autri_trigger_output
    __P((void *, void *, void *, int, void (*)(void *), void *,
    struct audio_params *));
int	autri_trigger_input
    __P((void *, void *, void *, int, void (*)(void *), void *,
    struct audio_params *));
d138 1
a138 1
void*	autri_malloc(void *, int, size_t, int, int);
@


1.5
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.4 2001/12/05 10:00:18 deraadt Exp $	*/
d74 3
a76 3
int	autri_match __P((struct device *, void *, void *));
void	autri_attach __P((struct device *, struct device *, void *));
int	autri_intr __P((void *));
d81 2
a82 3
int autri_allocmem
    __P((struct autri_softc *, size_t, size_t, struct autri_dma *));
int autri_freemem __P((struct autri_softc *, struct autri_dma *));
d91 9
a99 12
static __inline void autri_reg_set_1 __P((struct autri_softc *, int, uint8_t));
static __inline void autri_reg_clear_1
    __P((struct autri_softc *, int, uint8_t));
static __inline void autri_reg_set_4
    __P((struct autri_softc *, int, uint32_t));
static __inline void autri_reg_clear_4
    __P((struct autri_softc *, int, uint32_t));

int	autri_attach_codec __P((void *sc, struct ac97_codec_if *));
int	autri_read_codec __P((void *sc, u_int8_t a, u_int16_t *d));
int	autri_write_codec __P((void *sc, u_int8_t a, u_int16_t d));
void	autri_reset_codec __P((void *sc));
d102 9
a110 9
int  autri_init __P((void *sc));
struct autri_dma *autri_find_dma __P((struct autri_softc *, void *));
void autri_setup_channel __P((struct autri_softc *sc,int mode,
				    struct audio_params *param));
void autri_enable_interrupt __P((struct autri_softc *sc, int ch));
void autri_disable_interrupt __P((struct autri_softc *sc, int ch));
void autri_startch __P((struct autri_softc *sc, int ch, int ch_intr));
void autri_stopch __P((struct autri_softc *sc, int ch, int ch_intr));
void autri_enable_loop_interrupt __P((void *sc));
d112 1
a112 1
void autri_disable_loop_interrupt __P((void *sc));
d123 5
a127 6
int	autri_open __P((void *, int));
void	autri_close __P((void *));
int	autri_query_encoding __P((void *, struct audio_encoding *));
int	autri_set_params
    __P((void *, int, int, struct audio_params *, struct audio_params *));
int	autri_round_blocksize __P((void *, int));
d134 11
a144 11
int	autri_halt_output __P((void *));
int	autri_halt_input __P((void *));
int	autri_getdev __P((void *, struct audio_device *));
int	autri_mixer_set_port __P((void *, mixer_ctrl_t *));
int	autri_mixer_get_port __P((void *, mixer_ctrl_t *));
void*	autri_malloc __P((void *, int, size_t, int, int));
void	autri_free __P((void *, void *, int));
size_t	autri_round_buffersize __P((void *, int, size_t));
paddr_t	autri_mappage __P((void *, void *, off_t, int));
int	autri_get_props __P((void *));
int	autri_query_devinfo __P((void *addr, mixer_devinfo_t *dip));
d146 1
a146 2
int	autri_get_portnum_by_name
    __P((struct autri_softc *, char *, char *, char *));
d1391 1
a1391 1
	void (*intr) __P((void *));
d1435 1
a1435 1
	void (*intr) __P((void *));
@


1.4
log
@choose one AC97 name and stick with it a bit more often
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.3 2001/12/01 16:43:32 mickey Exp $	*/
d174 1
a174 1
	NULL,
d176 1
a176 1
	NULL,
a180 2
	autri_malloc,
	autri_round_buffersize,
@


1.4.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.5 2002/01/20 19:56:53 ericj Exp $	*/
d174 1
a174 1
	autri_malloc,
d176 1
a176 1
	autri_round_buffersize,
d181 2
@


1.4.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.4.2.1 2002/01/31 22:55:34 niklas Exp $	*/
d74 3
a76 3
int	autri_match(struct device *, void *, void *);
void	autri_attach(struct device *, struct device *, void *);
int	autri_intr(void *);
d81 3
a83 2
int autri_allocmem(struct autri_softc *, size_t, size_t, struct autri_dma *);
int autri_freemem(struct autri_softc *, struct autri_dma *);
d92 12
a103 9
static __inline void autri_reg_set_1(struct autri_softc *, int, uint8_t);
static __inline void autri_reg_clear_1(struct autri_softc *, int, uint8_t);
static __inline void autri_reg_set_4(struct autri_softc *, int, uint32_t);
static __inline void autri_reg_clear_4(struct autri_softc *, int, uint32_t);

int	autri_attach_codec(void *sc, struct ac97_codec_if *);
int	autri_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	autri_write_codec(void *sc, u_int8_t a, u_int16_t d);
void	autri_reset_codec(void *sc);
d106 9
a114 9
int  autri_init(void *sc);
struct autri_dma *autri_find_dma(struct autri_softc *, void *);
void autri_setup_channel(struct autri_softc *sc,int mode,
				    struct audio_params *param);
void autri_enable_interrupt(struct autri_softc *sc, int ch);
void autri_disable_interrupt(struct autri_softc *sc, int ch);
void autri_startch(struct autri_softc *sc, int ch, int ch_intr);
void autri_stopch(struct autri_softc *sc, int ch, int ch_intr);
void autri_enable_loop_interrupt(void *sc);
d116 1
a116 1
void autri_disable_loop_interrupt(void *sc);
d127 23
a149 21
int	autri_open(void *, int);
void	autri_close(void *);
int	autri_query_encoding(void *, struct audio_encoding *);
int	autri_set_params(void *, int, int, struct audio_params *,
	    struct audio_params *);
int	autri_round_blocksize(void *, int);
int	autri_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	autri_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	autri_halt_output(void *);
int	autri_halt_input(void *);
int	autri_getdev(void *, struct audio_device *);
int	autri_mixer_set_port(void *, mixer_ctrl_t *);
int	autri_mixer_get_port(void *, mixer_ctrl_t *);
void   *autri_malloc(void *, int, size_t, int, int);
void	autri_free(void *, void *, int);
size_t	autri_round_buffersize(void *, int, size_t);
paddr_t	autri_mappage(void *, void *, off_t, int);
int	autri_get_props(void *);
int	autri_query_devinfo(void *addr, mixer_devinfo_t *dip);
d151 2
a152 1
int	autri_get_portnum_by_name(struct autri_softc *, char *, char *, char *);
d1397 1
a1397 1
	void (*intr)(void *);
d1441 1
a1441 1
	void (*intr)(void *);
@


1.4.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.4.2.2 2002/06/11 03:42:24 art Exp $	*/
a99 1
enum ac97_host_flags	autri_flags_codec(void *);
d295 1
a295 1
	for (count=0; count < 0xffff; count++) {
a297 1
		DELAY(1);
d310 1
a310 1
	for (count=0; count < 0xffff; count++) {
a313 1
		DELAY(1);
d370 1
a370 1
	for (count=0; count < 0xffff; count++) {
a372 1
		DELAY(1);
a458 6
enum ac97_host_flags
autri_flags_codec(void *v)
{
	return (AC97_HOST_DONT_READ);
}

a565 1
	codec->host_if.flags = autri_flags_codec;
@


1.4.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d428 2
a429 2
		autri_reg_set_4(sc, AUTRI_SIS_SCTRL, 2);
		delay(1000);
d432 1
a432 1
		delay(2000);
d466 1
a466 3
	struct autri_codec_softc *sc = v;

	return (sc->flags);
a471 6
const struct pci_matchid autri_devices[] = {
	{ PCI_VENDOR_TRIDENT, PCI_PRODUCT_TRIDENT_4DWAVE_DX },
	{ PCI_VENDOR_TRIDENT, PCI_PRODUCT_TRIDENT_4DWAVE_NX },
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_7018 },
	{ PCI_VENDOR_ALI, PCI_PRODUCT_ALI_M5451 },
};
d479 25
a503 2
	return (pci_matchbyid((struct pci_attach_args *)aux, autri_devices,
	    sizeof(autri_devices)/sizeof(autri_devices[0])));
a576 3
	codec->flags = AC97_HOST_DONT_READ | AC97_HOST_SWAPPED_CHANNELS;
	if (sc->sc_dev.dv_cfdata->cf_flags & 0x0001)
		codec->flags &= ~AC97_HOST_SWAPPED_CHANNELS;
d950 1
a950 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d956 1
a956 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d962 1
a962 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d968 1
a968 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d974 1
a974 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d980 1
a980 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d986 1
a986 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d992 1
a992 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
a1310 2
	attribute = 0;

d1315 2
a1316 1
		ctrl |= AUTRI_CTRL_WAVEVOL;
a1323 6
		if (sc->sc_devid == AUTRI_DEVICE_ID_SIS_7018) {
			ctrl |= AUTRI_CTRL_MUTE_SIS;
			attribute = AUTRI_ATTR_PCMREC_SIS;
			if (delta != 48000)
				attribute |= AUTRI_ATTR_ENASRC_SIS;
		}
d1331 1
d1340 1
a1340 5
			if (sc->sc_devid == AUTRI_DEVICE_ID_SIS_7018)
				ctrl |= AUTRI_CTRL_MUTE_SIS;
			else
				ctrl |= AUTRI_CTRL_MUTE;
			attribute = 0;
d1364 1
a1364 1
			cr[3] = attribute;
@


1.3
log
@recover ugly irq print, cleanup on failure to attach
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.2 2001/11/26 18:10:52 mickey Exp $	*/
d245 1
a245 1
 * AC'97 codec
d310 1
a310 1
		printf("%s: Codec timeout. Busy reading AC'97 codec.\n",
d315 1
a315 1
	/* send Read Command to AC'97 */
d326 1
a326 1
		printf("%s: Codec timeout. Busy reading AC'97 codec.\n",
d385 1
a385 1
		printf("%s: Codec timeout. Busy writing AC'97 codec\n",
d390 1
a390 1
	/* send Write Command to AC'97 */
d410 1
a410 1
		/* warm reset AC'97 codec */
d421 1
a421 1
		/* warm reset AC'97 codec */
d432 1
a432 1
		/* warm reset AC'97 codec */
d443 1
a443 1
		/* warm reset AC'97 codec */
d464 1
a464 1
		printf("%s: Codec timeout. AC'97 is not ready for operation.\n",
d565 1
a565 1
	/* attach AC'97 codec */
@


1.3.2.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.2.2
log
@Merge in trunk
@
text
@d174 1
a174 1
	autri_malloc,
d176 1
a176 1
	autri_round_buffersize,
d181 2
d245 1
a245 1
 * AC97 codec
d310 1
a310 1
		printf("%s: Codec timeout. Busy reading AC97 codec.\n",
d315 1
a315 1
	/* send Read Command to AC97 */
d326 1
a326 1
		printf("%s: Codec timeout. Busy reading AC97 codec.\n",
d385 1
a385 1
		printf("%s: Codec timeout. Busy writing AC97 codec\n",
d390 1
a390 1
	/* send Write Command to AC97 */
d410 1
a410 1
		/* warm reset AC97 codec */
d421 1
a421 1
		/* warm reset AC97 codec */
d432 1
a432 1
		/* warm reset AC97 codec */
d443 1
a443 1
		/* warm reset AC97 codec */
d464 1
a464 1
		printf("%s: Codec timeout. AC97 is not ready for operation.\n",
d565 1
a565 1
	/* attach AC97 codec */
@


1.3.2.3
log
@Merge in -current from roughly a week ago
@
text
@d74 3
a76 3
int	autri_match(struct device *, void *, void *);
void	autri_attach(struct device *, struct device *, void *);
int	autri_intr(void *);
d81 3
a83 2
int autri_allocmem(struct autri_softc *, size_t, size_t, struct autri_dma *);
int autri_freemem(struct autri_softc *, struct autri_dma *);
d92 12
a103 9
static __inline void autri_reg_set_1(struct autri_softc *, int, uint8_t);
static __inline void autri_reg_clear_1(struct autri_softc *, int, uint8_t);
static __inline void autri_reg_set_4(struct autri_softc *, int, uint32_t);
static __inline void autri_reg_clear_4(struct autri_softc *, int, uint32_t);

int	autri_attach_codec(void *sc, struct ac97_codec_if *);
int	autri_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	autri_write_codec(void *sc, u_int8_t a, u_int16_t d);
void	autri_reset_codec(void *sc);
d106 9
a114 9
int  autri_init(void *sc);
struct autri_dma *autri_find_dma(struct autri_softc *, void *);
void autri_setup_channel(struct autri_softc *sc,int mode,
				    struct audio_params *param);
void autri_enable_interrupt(struct autri_softc *sc, int ch);
void autri_disable_interrupt(struct autri_softc *sc, int ch);
void autri_startch(struct autri_softc *sc, int ch, int ch_intr);
void autri_stopch(struct autri_softc *sc, int ch, int ch_intr);
void autri_enable_loop_interrupt(void *sc);
d116 1
a116 1
void autri_disable_loop_interrupt(void *sc);
d127 23
a149 21
int	autri_open(void *, int);
void	autri_close(void *);
int	autri_query_encoding(void *, struct audio_encoding *);
int	autri_set_params(void *, int, int, struct audio_params *,
	    struct audio_params *);
int	autri_round_blocksize(void *, int);
int	autri_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	autri_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	autri_halt_output(void *);
int	autri_halt_input(void *);
int	autri_getdev(void *, struct audio_device *);
int	autri_mixer_set_port(void *, mixer_ctrl_t *);
int	autri_mixer_get_port(void *, mixer_ctrl_t *);
void   *autri_malloc(void *, int, size_t, int, int);
void	autri_free(void *, void *, int);
size_t	autri_round_buffersize(void *, int, size_t);
paddr_t	autri_mappage(void *, void *, off_t, int);
int	autri_get_props(void *);
int	autri_query_devinfo(void *addr, mixer_devinfo_t *dip);
d151 2
a152 1
int	autri_get_portnum_by_name(struct autri_softc *, char *, char *, char *);
d1397 1
a1397 1
	void (*intr)(void *);
d1441 1
a1441 1
	void (*intr)(void *);
@


1.3.2.4
log
@Sync the SMP branch with 3.3
@
text
@a99 1
enum ac97_host_flags	autri_flags_codec(void *);
d295 1
a295 1
	for (count=0; count < 0xffff; count++) {
a297 1
		DELAY(1);
d310 1
a310 1
	for (count=0; count < 0xffff; count++) {
a313 1
		DELAY(1);
d370 1
a370 1
	for (count=0; count < 0xffff; count++) {
a372 1
		DELAY(1);
d424 2
a425 2
		autri_reg_set_4(sc, AUTRI_SIS_SCTRL, 2);
		delay(1000);
d428 1
a428 1
		delay(2000);
a458 8
enum ac97_host_flags
autri_flags_codec(void *v)
{
	struct autri_codec_softc *sc = v;

	return (sc->flags);
}

a461 6
const struct pci_matchid autri_devices[] = {
	{ PCI_VENDOR_TRIDENT, PCI_PRODUCT_TRIDENT_4DWAVE_DX },
	{ PCI_VENDOR_TRIDENT, PCI_PRODUCT_TRIDENT_4DWAVE_NX },
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_7018 },
	{ PCI_VENDOR_ALI, PCI_PRODUCT_ALI_M5451 },
};
d469 25
a493 2
	return (pci_matchbyid((struct pci_attach_args *)aux, autri_devices,
	    sizeof(autri_devices)/sizeof(autri_devices[0])));
a565 4
	codec->host_if.flags = autri_flags_codec;
	codec->flags = AC97_HOST_DONT_READ | AC97_HOST_SWAPPED_CHANNELS;
	if (sc->sc_dev.dv_cfdata->cf_flags & 0x0001)
		codec->flags &= ~AC97_HOST_SWAPPED_CHANNELS;
a1299 2
	attribute = 0;

d1304 2
a1305 1
		ctrl |= AUTRI_CTRL_WAVEVOL;
a1312 6
		if (sc->sc_devid == AUTRI_DEVICE_ID_SIS_7018) {
			ctrl |= AUTRI_CTRL_MUTE_SIS;
			attribute = AUTRI_ATTR_PCMREC_SIS;
			if (delta != 48000)
				attribute |= AUTRI_ATTR_ENASRC_SIS;
		}
d1320 1
d1329 1
a1329 5
			if (sc->sc_devid == AUTRI_DEVICE_ID_SIS_7018)
				ctrl |= AUTRI_CTRL_MUTE_SIS;
			else
				ctrl |= AUTRI_CTRL_MUTE;
			attribute = 0;
d1353 1
a1353 1
			cr[3] = attribute;
@


1.3.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.3.2.4 2003/03/28 00:38:20 niklas Exp $	*/
d938 1
a938 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d944 1
a944 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d950 1
a950 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d956 1
a956 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d962 1
a962 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d968 1
a968 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d974 1
a974 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d980 1
a980 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.2
log
@remove static on functions.
from netbsd:
Don't use a static variable in the power hook.  It doesn't work with more
than one device.
@
text
@d1 1
a1 1
/*	$OpenBSD: autri.c,v 1.1 2001/11/26 16:38:38 mickey Exp $	*/
d515 1
a524 1
	printf("\n");
d528 1
a528 1
	    PCI_MAPREG_TYPE_MEM, 0, &sc->memt, &sc->memh, NULL, NULL, 0)) {
d536 1
d548 1
d551 1
a551 1
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
d579 2
@


1.1
log
@Trident 4DWAVE-DX/NX, SiS 7018, ALi M5451 Sound Driver; from SOMEYA Yoshihiko and KUROSAWA Takahiro; tested by Matt Behrens <matt@@zigg.com>
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d105 4
a108 4
static void autri_powerhook(int why,void *addr);
static int  autri_init __P((void *sc));
static struct autri_dma *autri_find_dma __P((struct autri_softc *, void *));
static void autri_setup_channel __P((struct autri_softc *sc,int mode,
d110 5
a114 5
static void autri_enable_interrupt __P((struct autri_softc *sc, int ch));
static void autri_disable_interrupt __P((struct autri_softc *sc, int ch));
static void autri_startch __P((struct autri_softc *sc, int ch, int ch_intr));
static void autri_stopch __P((struct autri_softc *sc, int ch, int ch_intr));
static void autri_enable_loop_interrupt __P((void *sc));
d116 1
a116 1
static void autri_disable_loop_interrupt __P((void *sc));
d154 1
a154 1
static struct audio_hw_if autri_hw_if = {
d618 1
d622 1
a622 1
static void
a624 1
	static int old = PWR_RESUME;
d627 1
a627 1
	if (why == PWR_RESUME && old == PWR_SUSPEND) {
d633 1
a633 1
	old = why;
d756 1
a756 1
static void
d773 1
a773 1
static void
d1213 1
a1213 1
static struct autri_dma *
d1264 1
a1264 1
static void
d1489 1
a1489 1
static int
d1501 1
a1501 1
static void
d1514 1
a1514 1
static void
d1527 1
a1527 1
static void
d1542 1
a1542 1
static void
@

