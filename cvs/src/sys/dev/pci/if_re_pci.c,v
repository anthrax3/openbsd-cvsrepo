head	1.50;
access;
symbols
	OPENBSD_6_1:1.50.0.8
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.6
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.37.0.4
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.34.0.6
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.4
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.1.0.2
	OPENBSD_3_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.50
date	2015.12.28.05.49.15;	author jmatthew;	state Exp;
branches;
next	1.49;
commitid	3iekWyKLzVgfNIj7;

1.49
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.48;
commitid	5gdEnqVoJuTuwdTu;

1.48
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.47;
commitid	p4LJxGKbi0BU2cG6;

1.47
date	2015.03.08.01.54.04;	author tobiasu;	state Exp;
branches;
next	1.46;
commitid	id3E1oxJP4q7yqir;

1.46
date	2015.02.19.04.58.34;	author dlg;	state Exp;
branches;
next	1.45;
commitid	GSWXECXQW0LeGFmq;

1.45
date	2015.01.26.09.58.47;	author brad;	state Exp;
branches;
next	1.44;
commitid	AppNYocFYbD7Hqgj;

1.44
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.43;
commitid	yM2VFFhpDTeFQlve;

1.43
date	2014.10.24.23.30.05;	author brad;	state Exp;
branches;
next	1.42;
commitid	iT3Zt8uqLKeewmiI;

1.42
date	2014.09.06.04.46.58;	author brad;	state Exp;
branches;
next	1.41;
commitid	NjpaYKN1EE5jORe8;

1.41
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.40;
commitid	TGHgrLxu6sxZoiFt;

1.40
date	2013.11.18.22.21.27;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2013.08.07.01.06.36;	author bluhm;	state Exp;
branches;
next	1.38;

1.38
date	2013.08.03.15.44.32;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.16.04.42.44;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2012.09.26.16.32.22;	author rfreeman;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.09.19.34.42;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2011.05.29.22.13.10;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2011.03.13.15.35.20;	author stsp;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.27.21.56.11;	author todd;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.27.20.53.39;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.26.00.12.31;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.24.17.40.43;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.10.20.29.52;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.22.19.26.07;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.12.00.54.49;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.05.22.32.11;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.20.00.34.39;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.17.05.29.25;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.28.20.04.02;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.06.20.10.58;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.16.12.30.08;	author tom;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.06.01.01.21;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.01.21.48.08;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.30.16.51.30;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.27.07.09.49;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.24.02.36.15;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.17.18.00.43;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.09.00.59.33;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.07.01.14.26;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.23.00.41.50;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.16.02.32.39;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.27.17.43.25;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.27.16.26.05;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.22.11.47.26;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.15.23.39.19;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.01.08.11;	author pvalchev;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Rework re_start and re_txeof to only check the producer/consumer ring
positions when deciding how much work to do, and to adjust rl_tx_free with
atomic operations; split the flag that indicates whether we're using
timer based interrupts or not out into a separate field so it can be
changed from interrupt context without needing a lock; take the kernel
lock when calling re_init and re_start from interrupt context; add an
interrupt barrier in re_stop; and finally mark the interrupt handler
as mpsafe.

started by Jim Smith a while ago, mostly finished up at n2k15
tested by dlg@@, chris@@ and Dimitris Papastamos on various hardware
ok dlg@@
@
text
@/*	$OpenBSD: if_re_pci.c,v 1.49 2015/11/24 17:11:39 mpi Exp $	*/

/*
 * Copyright (c) 2005 Peter Valchev <pvalchev@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * PCI front-end for the Realtek 8169
 */

#include <sys/param.h>
#include <sys/endian.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/rtl81x9reg.h>
#include <dev/ic/revar.h>

struct re_pci_softc {
	/* General */
	struct rl_softc sc_rl;

	/* PCI-specific data */
	void *sc_ih;
	pci_chipset_tag_t sc_pc;
	pcitag_t sc_pcitag;

	bus_size_t sc_iosize;
};

const struct pci_matchid re_pci_devices[] = {
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CGLAPCIGT },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DGE528T },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DGE530T_C1 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8101E },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8168 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8169 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8169SC },
	{ PCI_VENDOR_TTTECH, PCI_PRODUCT_TTTECH_MC322 },
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_USR997902 }
};

#define RE_LINKSYS_EG1032_SUBID 0x00241737

int	re_pci_probe(struct device *, void *, void *);
void	re_pci_attach(struct device *, struct device *, void *);
int	re_pci_detach(struct device *, int);
int	re_pci_activate(struct device *, int);

/*
 * PCI autoconfig definitions
 */
struct cfattach re_pci_ca = {
	sizeof(struct re_pci_softc),
	re_pci_probe,
	re_pci_attach,
	re_pci_detach,
	re_pci_activate
};

/*
 * Probe for a Realtek 8169/8110 chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
re_pci_probe(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcireg_t subid;

	subid = pci_conf_read(pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

	/* C+ mode 8139's */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8139 &&
	    PCI_REVISION(pa->pa_class) == 0x20)
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_LINKSYS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_LINKSYS_EG1032 &&
	    subid == RE_LINKSYS_EG1032_SUBID)
		return (1);

	return (pci_matchbyid((struct pci_attach_args *)aux, re_pci_devices,
	    nitems(re_pci_devices)));
}

/*
 * PCI-specific attach routine
 */
void
re_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct re_pci_softc	*psc = (struct re_pci_softc *)self;
	struct rl_softc		*sc = &psc->sc_rl;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	const char		*intrstr = NULL;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

#ifndef SMALL_KERNEL
	/* Enable power management for wake on lan. */
	pci_conf_write(pc, pa->pa_tag, RL_PCI_PMCSR, RL_PME_EN);
#endif

	/*
	 * Map control/status registers.
	 */
	if (pci_mapreg_map(pa, RL_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->rl_btag, &sc->rl_bhandle, NULL, &psc->sc_iosize, 0)) {
		if (pci_mapreg_map(pa, RL_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
		    &sc->rl_btag, &sc->rl_bhandle, NULL, &psc->sc_iosize, 0)) {
			printf(": can't map mem or i/o space\n");
			return;
		}
	}

	/* Allocate interrupt */
	if (pci_intr_map_msi(pa, &ih) == 0)
		sc->rl_flags |= RL_FLAG_MSI;
	else if (pci_intr_map(pa, &ih) != 0) {
		printf(": couldn't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	psc->sc_ih = pci_intr_establish(pc, ih, IPL_NET | IPL_MPSAFE, re_intr,
	    sc, sc->sc_dev.dv_xname);
	if (psc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		return;
	}

	sc->sc_dmat = pa->pa_dmat;
	psc->sc_pc = pc;

	/*
	 * PCI Express check.
	 */
	if (pci_get_capability(pc, pa->pa_tag, PCI_CAP_PCIEXPRESS,
	    NULL, NULL))
		sc->rl_flags |= RL_FLAG_PCIE;

	if (!(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8139)) {
		u_int8_t	cfg;

		CSR_WRITE_1(sc, RL_EECMD, RL_EE_MODE);
		cfg = CSR_READ_1(sc, RL_CFG2);
		if (sc->rl_flags & RL_FLAG_MSI) {
			cfg |= RL_CFG2_MSI;
			CSR_WRITE_1(sc, RL_CFG2, cfg);
		} else {
			if ((cfg & RL_CFG2_MSI) != 0) {
				cfg &= ~RL_CFG2_MSI;
				CSR_WRITE_1(sc, RL_CFG2, cfg);
			}
		}
		CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);
	}

	sc->sc_product = PCI_PRODUCT(pa->pa_id);

	/* Call bus-independent attach routine */
	if (re_attach(sc, intrstr)) {
		pci_intr_disestablish(pc, psc->sc_ih);
		bus_space_unmap(sc->rl_btag, sc->rl_bhandle, psc->sc_iosize);
	}
}

int
re_pci_detach(struct device *self, int flags)
{
	struct re_pci_softc	*psc = (struct re_pci_softc *)self;
	struct rl_softc		*sc = &psc->sc_rl;
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;

	/* Remove timeout handler */
	timeout_del(&sc->timer_handle);

	/* Detach PHY */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete media stuff */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);
	ether_ifdetach(ifp);
	if_detach(ifp);

	/* Disable interrupts */
	if (psc->sc_ih != NULL)
		pci_intr_disestablish(psc->sc_pc, psc->sc_ih);

	/* Free pci resources */
	bus_space_unmap(sc->rl_btag, sc->rl_bhandle, psc->sc_iosize);

	return (0);
}

int
re_pci_activate(struct device *self, int act)
{
	struct re_pci_softc	*psc = (struct re_pci_softc *)self;
	struct rl_softc		*sc = &psc->sc_rl;
	struct ifnet 		*ifp = &sc->sc_arpcom.ac_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			re_stop(ifp);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP)
			re_init(ifp);
		break;
	}

	return (0);
}
@


1.49
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.48 2015/03/14 03:38:48 jsg Exp $	*/
d159 2
a160 2
	psc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, re_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.48
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.47 2015/03/08 01:54:04 tobiasu Exp $	*/
a34 1
#include <net/if_dl.h>
@


1.47
log
@Revert patch responsible for locking up machines with
"Realtek 8168" rev 0x01: RTL8168 2 (0x3800).
You will never guess who commited it without OK ;)

ok deraadt



revision 1.45
date: 2015/01/26 09:58:47;  author: brad;  state: Exp;  lines: +22 -2;  commitid: AppNYocFYbD7Hqgj;
Set PCIe max read request size to 2K to help with TX performance.

From FreeBSD

Tested with 8168C, 8168D and 8168G.

revision 1.46
date: 2015/02/19 04:58:34;  author: dlg;  state: Exp;  lines: +2 -2;  commitid: GSWXECXQW0LeGFmq;
when reading the max packet size in the pcie device config and
status register, correctly mask things so we're left with the mps
field instead of everything but the mps field.

tested by bcallah@@ and jim smith
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.44 2014/12/22 02:28:52 tedu Exp $	*/
a40 1
#include <dev/mii/mii.h>
@


1.46
log
@when reading the max packet size in the pcie device config and
status register, correctly mask things so we're left with the mps
field instead of everything but the mps field.

tested by bcallah@@ and jim smith
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.45 2015/01/26 09:58:47 brad Exp $	*/
a132 2
	pcireg_t		reg;
	int			rrs;
d177 1
a177 18
	    &sc->rl_expcap, NULL)) {
		if (!(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK &&
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8101E)) {
			/* Set PCIe maximum read request size to 2048. */
			reg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    sc->rl_expcap + PCI_PCIE_DCSR);
			reg &= PCI_PCIE_DCSR_MPS;
			reg >>= 12;
			rrs = (1 << (reg + 7));
			if (rrs < 2048) {
				reg = pci_conf_read(pa->pa_pc, pa->pa_tag,
				    sc->rl_expcap + PCI_PCIE_DCSR);
				reg = (reg & ~PCI_PCIE_DCSR_MPS) |
				    (fls(2048) - 8) << 12;
				pci_conf_write(pa->pa_pc, pa->pa_tag,
				    sc->rl_expcap + PCI_PCIE_DCSR, reg);
			}
		}
a178 1
	}
@


1.45
log
@Set PCIe max read request size to 2K to help with TX performance.

From FreeBSD

Tested with 8168C, 8168D and 8168G.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.44 2014/12/22 02:28:52 tedu Exp $	*/
d185 1
a185 1
			reg = (reg & ~PCI_PCIE_DCSR_MPS);
@


1.44
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.43 2014/10/24 23:30:05 brad Exp $	*/
d133 2
d179 18
a196 1
	    NULL, NULL))
d198 1
@


1.43
log
@Always put controller into known state before device intialization.

From FreeBSD

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.42 2014/09/06 04:46:58 brad Exp $	*/
a37 1
#ifdef INET
a39 1
#endif
@


1.42
log
@Various changes to the re(4) feature flags..

Changed RL_FLAG_MACLDPS to RL_FLAG_MACRESET.
Removed RL_FLAG_INVMAR and RL_FLAG_NOJUMBO.
Added RL_FLAG_FASTETHER, RL_FLAG_CMDSTOP_WAIT_TXQ, RL_FLAG_JUMBOV2, RL_FLAG_WOL_MANLINK,
      RL_FLAG_WAIT_TXPOLL, RL_FLAG_WOLRXENB.

Also set in the softc the maximum MTU for the various generations of chips.

Input from and Ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.41 2014/07/22 13:12:11 mpi Exp $	*/
a250 1
		re_reset(sc);
@


1.41
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.40 2013/11/18 22:21:27 brad Exp $	*/
d199 2
@


1.40
log
@Enable MSI on the remaining chipsets.

ok naddy@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.39 2013/08/07 01:06:36 bluhm Exp $	*/
a39 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.39
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.38 2013/08/03 15:44:32 kettenis Exp $	*/
a137 5
	/* Only enable MSI on RT810xE for now. */
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_REALTEK ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_REALTEK_RT8101E)
		pa->pa_flags &= ~PCI_FLAGS_MSI_ENABLED;

d158 3
a160 1
	if (pci_intr_map_msi(pa, &ih) != 0 && pci_intr_map(pa, &ih) != 0) {
d183 18
@


1.38
log
@Enable MSI on RT810xE.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.37 2013/01/16 04:42:44 brad Exp $	*/
a40 1
#include <netinet/in_var.h>
@


1.37
log
@Sort the PCI ids.

ok dtucker@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.36 2012/10/18 21:44:21 deraadt Exp $	*/
d139 5
d164 1
a164 1
	if (pci_intr_map(pa, &ih)) {
@


1.36
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.35 2012/09/26 16:32:22 rfreeman Exp $	*/
d69 3
d76 2
a77 5
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CGLAPCIGT },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DGE528T },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DGE530T_C1 },
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_USR997902 },
	{ PCI_VENDOR_TTTECH, PCI_PRODUCT_TTTECH_MC322 }
@


1.35
log
@add D-Link DGE-530T to re(4), update re(4) manpage
tested on i386, ok brad@@ sthen@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.34 2011/06/09 19:34:42 kettenis Exp $	*/
a137 1
	pcireg_t		command;
d139 1
a139 26
	/*
	 * Handle power management nonsense.
	 */

	command = pci_conf_read(pc, pa->pa_tag, RL_PCI_CAPID) & 0x000000FF;

	if (command == 0x01) {
		u_int32_t		iobase, membase, irq;

		/* Save important PCI config data. */
		iobase = pci_conf_read(pc, pa->pa_tag,  RL_PCI_LOIO);
		membase = pci_conf_read(pc, pa->pa_tag, RL_PCI_LOMEM);
		irq = pci_conf_read(pc, pa->pa_tag, RL_PCI_INTLINE);

#if 0
		/* Reset the power state. */
		printf(": chip is in D%d power mode "
		    "-- setting to D0", command & RL_PSTATE_MASK);
#endif
		command &= 0xFFFFFFFC;

		/* Restore PCI config data. */
		pci_conf_write(pc, pa->pa_tag, RL_PCI_LOIO, iobase);
		pci_conf_write(pc, pa->pa_tag, RL_PCI_LOMEM, membase);
		pci_conf_write(pc, pa->pa_tag, RL_PCI_INTLINE, irq);
	}
@


1.34
log
@Backout MSI change.  People are seeing watchdog timeouts, which must be caused
by missed interrupts.  Commits to the FreeBSD driver suggest that the hardware
has issues.  Having MSI for this driver isn't terribly important anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.33 2011/05/29 22:13:10 kettenis Exp $	*/
d75 1
@


1.33
log
@Add MSI support.

ok dlg@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.32 2011/04/03 15:36:02 jasper Exp $	*/
d184 1
a184 1
	if (pci_intr_map_msi(pa, &ih) && pci_intr_map(pa, &ih)) {
@


1.32
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.31 2011/03/13 15:35:20 stsp Exp $	*/
d184 1
a184 1
	if (pci_intr_map(pa, &ih)) {
@


1.31
log
@Wake On LAN support for re(4).
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.30 2010/09/07 16:21:45 deraadt Exp $	*/
d122 1
a122 1
	    sizeof(re_pci_devices)/sizeof(re_pci_devices[0])));
@


1.30
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.29 2010/07/27 21:56:11 todd Exp $	*/
d165 5
@


1.29
log
@spacing; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.28 2010/07/27 20:53:39 kettenis Exp $	*/
a227 4

	/* No more hooks */
	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);
@


1.28
log
@Make sure we stop DMA before we suspend.  Remove unused argument to re_stop()
to avoid the dilemma what meaningless value to pass.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.27 2009/11/26 00:12:31 kettenis Exp $	*/
d250 1
a250 1
	switch(act) {
@


1.27
log
@Only re-initialise interfaces on suspend if they were IFF_RUNNING.

ok deraadt@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.26 2009/11/24 17:40:43 kettenis Exp $	*/
d252 2
d257 1
a257 1
		if (ifp->if_flags & IFF_RUNNING)
@


1.26
log
@Reset the chip an re-initialise the interface after reset.  Resetting the
PHY doesn't seem to be necessary on re(4) so don't descend further for now.

Based on a diff from mlarkin@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.25 2009/08/10 20:29:52 deraadt Exp $	*/
d255 2
a256 1
		re_init(ifp);
@


1.25
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.24 2009/01/22 19:26:07 kettenis Exp $	*/
d84 1
d93 2
a94 1
	re_pci_detach
d239 19
@


1.24
log
@Make re(4) at pci(4) detachable.

ok jsg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.23 2008/10/12 00:54:49 brad Exp $	*/
a227 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
@


1.23
log
@If re_attach() fails at any point make sure to disestablish various
resources setup by the bus front ends, especially the shutdown hook.
Found while testing some other changes with a CardBus adapter and
re_attach() was failing early before the interface pointer was
assigned. Then the system was rebooted, the shutdown hook was called
and *boom* in re_stop().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.22 2008/10/05 22:32:11 brad Exp $	*/
d64 2
d83 1
d91 2
a92 1
	re_pci_attach
a134 1
	bus_size_t		iosize;
d168 1
a168 1
	    &sc->rl_btag, &sc->rl_bhandle, NULL, &iosize, 0)) {
d170 1
a170 1
		    &sc->rl_btag, &sc->rl_bhandle, NULL, &iosize, 0)) {
d192 1
d204 1
a204 1
		bus_space_unmap(sc->rl_btag, sc->rl_bhandle, iosize);
d206 35
@


1.22
log
@Detect if the adapter is a PCIe adapter and set the RL_FLAG_PCIE flag
if so.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.21 2008/04/20 00:34:39 brad Exp $	*/
d198 4
a201 1
	re_attach(sc, intrstr);
@


1.21
log
@Remove unused flags.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.20 2008/02/17 05:29:25 brad Exp $	*/
d189 7
@


1.20
log
@Simplify the hw revision handling by removing the use of the
rl_type softc field and only relying on the sc_hwrev softc
field thoughout the driver.

Tested by a number of users from tech@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.19 2006/11/28 20:04:02 brad Exp $	*/
a188 2

	sc->sc_flags |= RL_ENABLED;
@


1.19
log
@move printing of the interrupt string into re_attach().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.18 2006/11/06 20:10:58 deraadt Exp $	*/
d189 1
a190 11

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK) {
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8139)
			sc->rl_type = RL_8139CPLUS;
		else
			sc->rl_type = RL_8169;
	} else if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_TTTECH &&
		   PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TTTECH_MC322)
		sc->rl_type = RL_8139CPLUS;
	else
		sc->rl_type = RL_8169;
@


1.18
log
@noone needs to know about the D0 state change; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.17 2006/10/16 12:30:08 tom Exp $	*/
a186 1
	printf(": %s", intrstr);
d203 1
a203 1
	re_attach(sc);
@


1.17
log
@Fix some "is is"s.  ok otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.16 2006/08/06 01:01:21 brad Exp $	*/
d148 1
d152 1
@


1.16
log
@fix message printing when resetting the power state.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.15 2006/07/01 21:48:08 brad Exp $	*/
d149 1
a149 1
		printf(": chip is is in D%d power mode "
@


1.15
log
@(fxp/re)_attach_common -> (fxp/re)_attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.14 2006/06/30 16:51:30 deraadt Exp $	*/
d149 2
a150 3
		printf("%s: chip is is in D%d power mode "
		    "-- setting to D0\n", sc->sc_dev.dv_xname,
		    command & RL_PSTATE_MASK);
@


1.14
log
@do not bother playing tag with the PCI_COMMAND_STATUS_REG
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.13 2006/06/27 07:09:49 brad Exp $	*/
d203 1
a203 1
	re_attach_common(sc);
@


1.13
log
@add new RealTek PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.12 2006/06/24 02:36:15 brad Exp $	*/
d163 2
a164 14
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

	if ((command & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE)) == 0) {
		printf(": neither i/o nor mem enabled\n");
		return;
	}

	if (command & PCI_COMMAND_MEM_ENABLE) {
		if (pci_mapreg_map(pa, RL_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->rl_btag, &sc->rl_bhandle, NULL, &iosize, 0)) {
			printf(": can't map mem space\n");
			return;
		}
	} else {
d167 1
a167 1
			printf(": can't map i/o space\n");
@


1.12
log
@de-register, ANSI functions and a little cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.11 2006/06/17 18:00:43 brad Exp $	*/
d67 1
d70 1
@


1.11
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.10 2006/06/09 00:59:33 brad Exp $	*/
d77 2
a78 2
int re_pci_probe(struct device *, void *, void *);
void re_pci_attach(struct device *, struct device *, void *);
@


1.10
log
@identify 8139's in C+ mode with RL_8139CPLUS instead of RL_8139; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.9 2006/06/07 01:14:26 brad Exp $	*/
d31 1
@


1.9
log
@rename the Realtek RT8111B entry to RT8168.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.8 2006/05/23 00:41:50 brad Exp $	*/
d202 1
a202 1
			sc->rl_type = RL_8139;
d207 1
a207 1
		sc->rl_type = RL_8139;
@


1.8
log
@according to the Linux 8139cp driver the TTTech MC322 adapter uses
the 8139C+ chipset, so attach with re(4) instead of rl(4).

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.7 2006/05/16 02:32:39 brad Exp $	*/
d66 1
a66 1
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8111B },
@


1.7
log
@attach 8139's capable of C+ mode to the re(4) driver, instead of the rl(4)
driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.6 2006/03/27 17:43:25 brad Exp $	*/
d70 2
a71 1
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_USR997902 }
d200 7
a206 1
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8139)
@


1.6
log
@revert a small part of the last commit that wasn't supposed to go in.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.5 2006/03/27 16:26:05 brad Exp $	*/
d100 6
d198 5
a202 1
	sc->rl_type = RL_8169;
@


1.5
log
@add the Realtek RT8111B PCI Express Gigabit MAC.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.4 2005/08/09 04:10:12 mickey Exp $	*/
d192 1
a192 6

	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8139 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TTTECH_MC322)
		sc->rl_type = RL_8139CPLUS;
	else
		sc->rl_type = RL_8169;
@


1.4
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.3 2005/07/22 11:47:26 brad Exp $	*/
d66 1
d70 1
a70 1
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_USR997902 },
a123 1
#ifndef BURN_BRIDGES
a148 1
#endif
d192 6
a197 1
	sc->rl_type = RL_8169;
@


1.3
log
@add Linksys EG1032 rev 3
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.2 2005/06/15 23:39:19 brad Exp $	*/
a153 4
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.2
log
@add D-Link DGE-528T and US Robotics USR997902

From: NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_pci.c,v 1.1 2005/01/14 01:08:11 pvalchev Exp $	*/
d72 2
d93 11
@


1.1
log
@split re(4) into bus-independent code (ic/re.c) and PCI front-end
(pci/if_re_pci.c) for soon-to-come cardbus support; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re.c,v 1.14 2004/12/11 06:27:49 pvalchev Exp $	*/
d68 2
@

