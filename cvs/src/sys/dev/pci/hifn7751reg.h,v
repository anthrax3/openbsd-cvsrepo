head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.14
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.12
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.10
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.4
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.45.0.38
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.36
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.45.0.32
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.30
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.28
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.26
	OPENBSD_5_0:1.45.0.24
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.22
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.20
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.16
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.18
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.14
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.12
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.10
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.8
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.45.0.6
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.45.0.4
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.44.0.8
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.44.0.6
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.44.0.4
	OPENBSD_3_6_BASE:1.44
	SMP_SYNC_A:1.44
	SMP_SYNC_B:1.44
	OPENBSD_3_5:1.44.0.2
	OPENBSD_3_5_BASE:1.44
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	UBC_SYNC_A:1.42
	OPENBSD_3_3:1.42.0.2
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.39.0.2
	OPENBSD_3_2_BASE:1.39
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	UBC_SYNC_B:1.39
	UBC:1.31.0.2
	UBC_BASE:1.31
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.3;
locks; strict;
comment	@ * @;


1.46
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.45;
commitid	LS2TNeCue5R9L67C;

1.45
date	2005.09.06.18.27.54;	author jolan;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.09.03.47.20;	author jason;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.02.15.58.41;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.19.19.59.14;	author jason;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.17.16.48.22;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.15.23.39.13;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.25.15.27.20;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.23.19.25.09;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.23.17.53.46;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.21.19.08.26;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.23.15.59.12;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2002.01.09.01.53.39;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.08.23.17.24;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.04.18.31.42;	author jason;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.08.27.18.54.56;	author jason;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.08.08.03.11.47;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.08.18.05.42;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.27.03.33.53;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.26.03.43.25;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.25.22.03.08;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.23.20.20.33;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.23.19.50.47;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.23.00.25.38;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.22.23.53.52;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.22.19.02.43;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.13.23.39.54;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.08.22.09.51;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.12.21.30.34;	author jason;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.10.26.00.41.26;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.21.13.34.58;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.11.13.49.34;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.10.18.40.47;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.05.16.34.07;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.04.20.10.27;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.29.22.39.39;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.29.20.54.59;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.17.20.31.31;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.16.20.33.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.15.14.55.52;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.10.08.45.00;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.12.15.00.30.45;	author jason;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.02.24.06.09.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.02.21.00.05.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.02.19.02.52.20;	author deraadt;	state Exp;
branches;
next	;

1.4.2.1
date	2000.03.24.09.09.17;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.05.14.22.25.42;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.07.04.10.42.07;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.4.2.9;

1.4.2.9
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2001.12.01.00.31.55;	author miod;	state Exp;
branches;
next	;

1.30.2.1
date	2001.11.13.17.23.54;	author jason;	state Exp;
branches;
next	;

1.31.2.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@/*	$OpenBSD: hifn7751reg.h,v 1.45 2005/09/06 18:27:54 jolan Exp $	*/

/*
 * Invertex AEON / Hifn 7751 driver
 * Copyright (c) 1999 Invertex Inc. All rights reserved.
 * Copyright (c) 1999 Theo de Raadt
 * Copyright (c) 2000-2001 Network Security Technologies, Inc.
 *			http://www.netsec.net
 *
 * Please send any comments, feedback, bug-fixes, or feature requests to
 * software@@invertex.com.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */
#ifndef __HIFN_H__
#define	__HIFN_H__

#include <sys/endian.h>

/*
 * Some PCI configuration space offset defines.  The names were made
 * identical to the names used by the Linux kernel.
 */
#define	HIFN_BAR0		(PCI_MAPREG_START + 0)	/* PUC register map */
#define	HIFN_BAR1		(PCI_MAPREG_START + 4)	/* DMA register map */
#define	HIFN_RETRY_TIMEOUT	0x41
#define	HIFN_TRDY_TIMEOUT	0x40

/*
 * The values below should multiple of 4 -- and be large enough to handle
 * any command the driver implements.
 *
 * MAX_COMMAND = base command + mac command + encrypt command +
 *			mac-key + rc4-key
 * MAX_RESULT  = base result + comp result + mac result + mac + encrypt result
 *			
 *
 */
#define	HIFN_MAX_COMMAND	(8 + 8 + 8 + 64 + 260)
#define	HIFN_MAX_RESULT		(8 + 4 + 4 + 20 + 4)

/*
 * hifn_desc_t
 *
 * Holds an individual descriptor for any of the rings.
 */
struct hifn_desc {
	volatile u_int32_t l;		/* length and status bits */
	volatile u_int32_t p;
};

/*
 * Masks for the "length" field of struct hifn_desc.
 */
#define	HIFN_D_LENGTH		0x0000ffff	/* length bit mask */
#define	HIFN_D_MASKDONEIRQ	0x02000000	/* mask the done interrupt */
#define	HIFN_D_DESTOVER		0x04000000	/* destination overflow */
#define	HIFN_D_OVER		0x08000000	/* overflow */
#define	HIFN_D_LAST		0x20000000	/* last descriptor in chain */
#define	HIFN_D_JUMP		0x40000000	/* jump descriptor */
#define	HIFN_D_VALID		0x80000000	/* valid bit */

/*
 * Processing Unit Registers (offset from BASEREG0)
 */
#define	HIFN_0_PUDATA		0x00	/* Processing Unit Data */
#define	HIFN_0_PUCTRL		0x04	/* Processing Unit Control */
#define	HIFN_0_PUISR		0x08	/* Processing Unit Interrupt Status */
#define	HIFN_0_PUCNFG		0x0c	/* Processing Unit Configuration */
#define	HIFN_0_PUIER		0x10	/* Processing Unit Interrupt Enable */
#define	HIFN_0_PUSTAT		0x14	/* Processing Unit Status/Chip ID */
#define	HIFN_0_FIFOSTAT		0x18	/* FIFO Status */
#define	HIFN_0_FIFOCNFG		0x1c	/* FIFO Configuration */
#define	HIFN_0_SPACESIZE	0x20	/* Register space size */

/* Processing Unit Control Register (HIFN_0_PUCTRL) */
#define	HIFN_PUCTRL_CLRSRCFIFO	0x0010	/* clear source fifo */
#define	HIFN_PUCTRL_STOP	0x0008	/* stop pu */
#define	HIFN_PUCTRL_LOCKRAM	0x0004	/* lock ram */
#define	HIFN_PUCTRL_DMAENA	0x0002	/* enable dma */
#define	HIFN_PUCTRL_RESET	0x0001	/* Reset processing unit */

/* Processing Unit Interrupt Status Register (HIFN_0_PUISR) */
#define	HIFN_PUISR_CMDINVAL	0x8000	/* Invalid command interrupt */
#define	HIFN_PUISR_DATAERR	0x4000	/* Data error interrupt */
#define	HIFN_PUISR_SRCFIFO	0x2000	/* Source FIFO ready interrupt */
#define	HIFN_PUISR_DSTFIFO	0x1000	/* Destination FIFO ready interrupt */
#define	HIFN_PUISR_DSTOVER	0x0200	/* Destination overrun interrupt */
#define	HIFN_PUISR_SRCCMD	0x0080	/* Source command interrupt */
#define	HIFN_PUISR_SRCCTX	0x0040	/* Source context interrupt */
#define	HIFN_PUISR_SRCDATA	0x0020	/* Source data interrupt */
#define	HIFN_PUISR_DSTDATA	0x0010	/* Destination data interrupt */
#define	HIFN_PUISR_DSTRESULT	0x0004	/* Destination result interrupt */

/* Processing Unit Configuration Register (HIFN_0_PUCNFG) */
#define	HIFN_PUCNFG_DRAMMASK	0xe000	/* DRAM size mask */
#define	HIFN_PUCNFG_DSZ_256K	0x0000	/* 256k dram */
#define	HIFN_PUCNFG_DSZ_512K	0x2000	/* 512k dram */
#define	HIFN_PUCNFG_DSZ_1M	0x4000	/* 1m dram */
#define	HIFN_PUCNFG_DSZ_2M	0x6000	/* 2m dram */
#define	HIFN_PUCNFG_DSZ_4M	0x8000	/* 4m dram */
#define	HIFN_PUCNFG_DSZ_8M	0xa000	/* 8m dram */
#define	HIFN_PUNCFG_DSZ_16M	0xc000	/* 16m dram */
#define	HIFN_PUCNFG_DSZ_32M	0xe000	/* 32m dram */
#define	HIFN_PUCNFG_DRAMREFRESH	0x1800	/* DRAM refresh rate mask */
#define	HIFN_PUCNFG_DRFR_512	0x0000	/* 512 divisor of ECLK */
#define	HIFN_PUCNFG_DRFR_256	0x0800	/* 256 divisor of ECLK */
#define	HIFN_PUCNFG_DRFR_128	0x1000	/* 128 divisor of ECLK */
#define	HIFN_PUCNFG_TCALLPHASES	0x0200	/* your guess is as good as mine... */
#define	HIFN_PUCNFG_TCDRVTOTEM	0x0100	/* your guess is as good as mine... */
#define	HIFN_PUCNFG_BIGENDIAN	0x0080	/* DMA big endian mode */
#define	HIFN_PUCNFG_BUS32	0x0040	/* Bus width 32bits */
#define	HIFN_PUCNFG_BUS16	0x0000	/* Bus width 16 bits */
#define	HIFN_PUCNFG_CHIPID	0x0020	/* Allow chipid from PUSTAT */
#define	HIFN_PUCNFG_DRAM	0x0010	/* Context RAM is DRAM */
#define	HIFN_PUCNFG_SRAM	0x0000	/* Context RAM is SRAM */
#define	HIFN_PUCNFG_COMPSING	0x0004	/* Enable single compression context */
#define	HIFN_PUCNFG_ENCCNFG	0x0002	/* Encryption configuration */

/* Processing Unit Interrupt Enable Register (HIFN_0_PUIER) */
#define	HIFN_PUIER_CMDINVAL	0x8000	/* Invalid command interrupt */
#define	HIFN_PUIER_DATAERR	0x4000	/* Data error interrupt */
#define	HIFN_PUIER_SRCFIFO	0x2000	/* Source FIFO ready interrupt */
#define	HIFN_PUIER_DSTFIFO	0x1000	/* Destination FIFO ready interrupt */
#define	HIFN_PUIER_DSTOVER	0x0200	/* Destination overrun interrupt */
#define	HIFN_PUIER_SRCCMD	0x0080	/* Source command interrupt */
#define	HIFN_PUIER_SRCCTX	0x0040	/* Source context interrupt */
#define	HIFN_PUIER_SRCDATA	0x0020	/* Source data interrupt */
#define	HIFN_PUIER_DSTDATA	0x0010	/* Destination data interrupt */
#define	HIFN_PUIER_DSTRESULT	0x0004	/* Destination result interrupt */

/* Processing Unit Status Register/Chip ID (HIFN_0_PUSTAT) */
#define	HIFN_PUSTAT_CMDINVAL	0x8000	/* Invalid command interrupt */
#define	HIFN_PUSTAT_DATAERR	0x4000	/* Data error interrupt */
#define	HIFN_PUSTAT_SRCFIFO	0x2000	/* Source FIFO ready interrupt */
#define	HIFN_PUSTAT_DSTFIFO	0x1000	/* Destination FIFO ready interrupt */
#define	HIFN_PUSTAT_DSTOVER	0x0200	/* Destination overrun interrupt */
#define	HIFN_PUSTAT_SRCCMD	0x0080	/* Source command interrupt */
#define	HIFN_PUSTAT_SRCCTX	0x0040	/* Source context interrupt */
#define	HIFN_PUSTAT_SRCDATA	0x0020	/* Source data interrupt */
#define	HIFN_PUSTAT_DSTDATA	0x0010	/* Destination data interrupt */
#define	HIFN_PUSTAT_DSTRESULT	0x0004	/* Destination result interrupt */
#define	HIFN_PUSTAT_CHIPREV	0x00ff	/* Chip revision mask */
#define	HIFN_PUSTAT_CHIPENA	0xff00	/* Chip enabled mask */
#define	HIFN_PUSTAT_ENA_2	0x1100	/* Level 2 enabled */
#define	HIFN_PUSTAT_ENA_1	0x1000	/* Level 1 enabled */
#define	HIFN_PUSTAT_ENA_0	0x3000	/* Level 0 enabled */
#define	HIFN_PUSTAT_REV_2	0x0020	/* 7751 PT6/2 */
#define	HIFN_PUSTAT_REV_3	0x0030	/* 7751 PT6/3 */

/* FIFO Status Register (HIFN_0_FIFOSTAT) */
#define	HIFN_FIFOSTAT_SRC	0x7f00	/* Source FIFO available */
#define	HIFN_FIFOSTAT_DST	0x007f	/* Destination FIFO available */

/* FIFO Configuration Register (HIFN_0_FIFOCNFG) */
#define	HIFN_FIFOCNFG_THRESHOLD	0x0400	/* must be written as 1 */

/*
 * DMA Interface Registers (offset from BASEREG1)
 */
#define	HIFN_1_DMA_CRAR		0x0c	/* DMA Command Ring Address */
#define	HIFN_1_DMA_SRAR		0x1c	/* DMA Source Ring Address */
#define	HIFN_1_DMA_RRAR		0x2c	/* DMA Result Ring Address */
#define	HIFN_1_DMA_DRAR		0x3c	/* DMA Destination Ring Address */
#define	HIFN_1_DMA_CSR		0x40	/* DMA Status and Control */
#define	HIFN_1_DMA_IER		0x44	/* DMA Interrupt Enable */
#define	HIFN_1_DMA_CNFG		0x48	/* DMA Configuration */
#define	HIFN_1_PLL		0x4c	/* 795x: PLL config */
#define	HIFN_1_7811_RNGENA	0x60	/* 7811: rng enable */
#define	HIFN_1_7811_RNGCFG	0x64	/* 7811: rng config */
#define	HIFN_1_7811_RNGDAT	0x68	/* 7811: rng data */
#define	HIFN_1_7811_RNGSTS	0x6c	/* 7811: rng status */
#define	HIFN_1_7811_MIPSRST	0x94	/* 7811: MIPS reset */
#define	HIFN_1_REVID		0x98	/* Revision ID */
#define	HIFN_1_UNLOCK_SECRET1	0xf4
#define	HIFN_1_UNLOCK_SECRET2	0xfc
#define	HIFN_1_PUB_RESET	0x204	/* Public/RNG Reset */
#define	HIFN_1_PUB_BASE		0x300	/* Public Base Address */
#define	HIFN_1_PUB_OPLEN	0x304	/* Public Operand Length */
#define	HIFN_1_PUB_OP		0x308	/* Public Operand */
#define	HIFN_1_PUB_STATUS	0x30c	/* Public Status */
#define	HIFN_1_PUB_IEN		0x310	/* Public Interrupt enable */
#define	HIFN_1_RNG_CONFIG	0x314	/* RNG config */
#define	HIFN_1_RNG_DATA		0x318	/* RNG data */
#define	HIFN_1_PUB_MEM		0x400	/* start of Public key memory */
#define	HIFN_1_PUB_MEMEND	0xbff	/* end of Public key memory */

/* DMA Status and Control Register (HIFN_1_DMA_CSR) */
#define	HIFN_DMACSR_D_CTRLMASK	0xc0000000	/* Destinition Ring Control */
#define	HIFN_DMACSR_D_CTRL_NOP	0x00000000	/* Dest. Control: no-op */
#define	HIFN_DMACSR_D_CTRL_DIS	0x40000000	/* Dest. Control: disable */
#define	HIFN_DMACSR_D_CTRL_ENA	0x80000000	/* Dest. Control: enable */
#define	HIFN_DMACSR_D_ABORT	0x20000000	/* Destinition Ring PCIAbort */
#define	HIFN_DMACSR_D_DONE	0x10000000	/* Destinition Ring Done */
#define	HIFN_DMACSR_D_LAST	0x08000000	/* Destinition Ring Last */
#define	HIFN_DMACSR_D_WAIT	0x04000000	/* Destinition Ring Waiting */
#define	HIFN_DMACSR_D_OVER	0x02000000	/* Destinition Ring Overflow */
#define	HIFN_DMACSR_R_CTRL	0x00c00000	/* Result Ring Control */
#define	HIFN_DMACSR_R_CTRL_NOP	0x00000000	/* Result Control: no-op */
#define	HIFN_DMACSR_R_CTRL_DIS	0x00400000	/* Result Control: disable */
#define	HIFN_DMACSR_R_CTRL_ENA	0x00800000	/* Result Control: enable */
#define	HIFN_DMACSR_R_ABORT	0x00200000	/* Result Ring PCI Abort */
#define	HIFN_DMACSR_R_DONE	0x00100000	/* Result Ring Done */
#define	HIFN_DMACSR_R_LAST	0x00080000	/* Result Ring Last */
#define	HIFN_DMACSR_R_WAIT	0x00040000	/* Result Ring Waiting */
#define	HIFN_DMACSR_R_OVER	0x00020000	/* Result Ring Overflow */
#define	HIFN_DMACSR_S_CTRL	0x0000c000	/* Source Ring Control */
#define	HIFN_DMACSR_S_CTRL_NOP	0x00000000	/* Source Control: no-op */
#define	HIFN_DMACSR_S_CTRL_DIS	0x00004000	/* Source Control: disable */
#define	HIFN_DMACSR_S_CTRL_ENA	0x00008000	/* Source Control: enable */
#define	HIFN_DMACSR_S_ABORT	0x00002000	/* Source Ring PCI Abort */
#define	HIFN_DMACSR_S_DONE	0x00001000	/* Source Ring Done */
#define	HIFN_DMACSR_S_LAST	0x00000800	/* Source Ring Last */
#define	HIFN_DMACSR_S_WAIT	0x00000400	/* Source Ring Waiting */
#define	HIFN_DMACSR_ILLW	0x00000200	/* Illegal write (7811 only) */
#define	HIFN_DMACSR_ILLR	0x00000100	/* Illegal read (7811 only) */
#define	HIFN_DMACSR_C_CTRL	0x000000c0	/* Command Ring Control */
#define	HIFN_DMACSR_C_CTRL_NOP	0x00000000	/* Command Control: no-op */
#define	HIFN_DMACSR_C_CTRL_DIS	0x00000040	/* Command Control: disable */
#define	HIFN_DMACSR_C_CTRL_ENA	0x00000080	/* Command Control: enable */
#define	HIFN_DMACSR_C_ABORT	0x00000020	/* Command Ring PCI Abort */
#define	HIFN_DMACSR_C_DONE	0x00000010	/* Command Ring Done */
#define	HIFN_DMACSR_C_LAST	0x00000008	/* Command Ring Last */
#define	HIFN_DMACSR_C_WAIT	0x00000004	/* Command Ring Waiting */
#define	HIFN_DMACSR_PUBDONE	0x00000002	/* Public op done (7951 only) */
#define	HIFN_DMACSR_ENGINE	0x00000001	/* Command Ring Engine IRQ */

/* DMA Interrupt Enable Register (HIFN_1_DMA_IER) */
#define	HIFN_DMAIER_D_ABORT	0x20000000	/* Destination Ring PCIAbort */
#define	HIFN_DMAIER_D_DONE	0x10000000	/* Destination Ring Done */
#define	HIFN_DMAIER_D_LAST	0x08000000	/* Destination Ring Last */
#define	HIFN_DMAIER_D_WAIT	0x04000000	/* Destination Ring Waiting */
#define	HIFN_DMAIER_D_OVER	0x02000000	/* Destination Ring Overflow */
#define	HIFN_DMAIER_R_ABORT	0x00200000	/* Result Ring PCI Abort */
#define	HIFN_DMAIER_R_DONE	0x00100000	/* Result Ring Done */
#define	HIFN_DMAIER_R_LAST	0x00080000	/* Result Ring Last */
#define	HIFN_DMAIER_R_WAIT	0x00040000	/* Result Ring Waiting */
#define	HIFN_DMAIER_R_OVER	0x00020000	/* Result Ring Overflow */
#define	HIFN_DMAIER_S_ABORT	0x00002000	/* Source Ring PCI Abort */
#define	HIFN_DMAIER_S_DONE	0x00001000	/* Source Ring Done */
#define	HIFN_DMAIER_S_LAST	0x00000800	/* Source Ring Last */
#define	HIFN_DMAIER_S_WAIT	0x00000400	/* Source Ring Waiting */
#define	HIFN_DMAIER_ILLW	0x00000200	/* Illegal write (7811 only) */
#define	HIFN_DMAIER_ILLR	0x00000100	/* Illegal read (7811 only) */
#define	HIFN_DMAIER_C_ABORT	0x00000020	/* Command Ring PCI Abort */
#define	HIFN_DMAIER_C_DONE	0x00000010	/* Command Ring Done */
#define	HIFN_DMAIER_C_LAST	0x00000008	/* Command Ring Last */
#define	HIFN_DMAIER_C_WAIT	0x00000004	/* Command Ring Waiting */
#define	HIFN_DMAIER_PUBDONE	0x00000002	/* public op done (7951 only) */
#define	HIFN_DMAIER_ENGINE	0x00000001	/* Engine IRQ */

/* DMA Configuration Register (HIFN_1_DMA_CNFG) */
#define	HIFN_DMACNFG_BIGENDIAN	0x10000000	/* big endian mode */
#define	HIFN_DMACNFG_POLLFREQ	0x00ff0000	/* Poll frequency mask */
#define	HIFN_DMACNFG_UNLOCK	0x00000800
#define	HIFN_DMACNFG_POLLINVAL	0x00000700	/* Invalid Poll Scalar */
#define	HIFN_DMACNFG_LAST	0x00000010	/* Host control LAST bit */
#define	HIFN_DMACNFG_MODE	0x00000004	/* DMA mode */
#define	HIFN_DMACNFG_DMARESET	0x00000002	/* DMA Reset # */
#define	HIFN_DMACNFG_MSTRESET	0x00000001	/* Master Reset # */

/* 7811 RNG Enable Register (HIFN_1_7811_RNGENA) */
#define	HIFN_7811_RNGENA_ENA	0x00000001	/* enable RNG */

/* 7811 RNG Config Register (HIFN_1_7811_RNGCFG) */
#define	HIFN_7811_RNGCFG_PRE1	0x00000f00	/* first prescalar */
#define	HIFN_7811_RNGCFG_OPRE	0x00000080	/* output prescalar */
#define	HIFN_7811_RNGCFG_DEFL	0x00000f80	/* 2 words/ 1/100 sec */

/* 7811 RNG Status Register (HIFN_1_7811_RNGSTS) */
#define	HIFN_7811_RNGSTS_RDY	0x00004000	/* two numbers in FIFO */
#define	HIFN_7811_RNGSTS_UFL	0x00001000	/* rng underflow */

/* 7811 MIPS Reset Register (HIFN_1_7811_MIPSRST) */
#define	HIFN_MIPSRST_BAR2SIZE	0xffff0000	/* sdram size */
#define	HIFN_MIPSRST_GPRAMINIT	0x00008000	/* gpram can be accessed */
#define	HIFN_MIPSRST_CRAMINIT	0x00004000	/* ctxram can be accessed */
#define	HIFN_MIPSRST_LED2	0x00000400	/* external LED2 */
#define	HIFN_MIPSRST_LED1	0x00000200	/* external LED1 */
#define	HIFN_MIPSRST_LED0	0x00000100	/* external LED0 */
#define	HIFN_MIPSRST_MIPSDIS	0x00000004	/* disable MIPS */
#define	HIFN_MIPSRST_MIPSRST	0x00000002	/* warm reset MIPS */
#define	HIFN_MIPSRST_MIPSCOLD	0x00000001	/* cold reset MIPS */

/* PLL config register (HIFN_1_PLL) */
#define	HIFN_PLL_7956		0x00001d18	/* 7956 PLL config value */

/* Revision ID */
#define	HIFN_REVID_7811_PB3_2	0x00000002	/* 7811PB3/2 */

/* Public key reset register (HIFN_1_PUB_RESET) */
#define	HIFN_PUBRST_RESET	0x00000001	/* reset public/rng unit */

/* Public base address register (HIFN_1_PUB_BASE) */
#define	HIFN_PUBBASE_ADDR	0x00003fff	/* base address */

/* Public operand length register (HIFN_1_PUB_OPLEN) */
#define	HIFN_PUBOPLEN_MOD_M	0x0000007f	/* modulus length mask */
#define	HIFN_PUBOPLEN_MOD_S	0		/* modulus length shift */
#define	HIFN_PUBOPLEN_EXP_M	0x0003ff80	/* exponent length mask */
#define	HIFN_PUBOPLEN_EXP_S	7		/* exponent length shift */
#define	HIFN_PUBOPLEN_RED_M	0x003c0000	/* reducend length mask */
#define	HIFN_PUBOPLEN_RED_S	18		/* reducend length shift */

/* Public operation register (HIFN_1_PUB_OP) */
#define	HIFN_PUBOP_AOFFSET_M	0x0000007f	/* A offset mask */
#define	HIFN_PUBOP_AOFFSET_S	0		/* A offset shift */
#define	HIFN_PUBOP_BOFFSET_M	0x00000f80	/* B offset mask */
#define	HIFN_PUBOP_BOFFSET_S	7		/* B offset shift */
#define	HIFN_PUBOP_MOFFSET_M	0x0003f000	/* M offset mask */
#define	HIFN_PUBOP_MOFFSET_S	12		/* M offset shift */
#define	HIFN_PUBOP_OP_MASK	0x003c0000	/* Opcode: */
#define	HIFN_PUBOP_OP_NOP	0x00000000	/*  NOP */
#define	HIFN_PUBOP_OP_ADD	0x00040000	/*  ADD */
#define	HIFN_PUBOP_OP_ADDC	0x00080000	/*  ADD w/carry */
#define	HIFN_PUBOP_OP_SUB	0x000c0000	/*  SUB */
#define	HIFN_PUBOP_OP_SUBC	0x00100000	/*  SUB w/carry */
#define	HIFN_PUBOP_OP_MODADD	0x00140000	/*  Modular ADD */
#define	HIFN_PUBOP_OP_MODSUB	0x00180000	/*  Modular SUB */
#define	HIFN_PUBOP_OP_INCA	0x001c0000	/*  INC A */
#define	HIFN_PUBOP_OP_DECA	0x00200000	/*  DEC A */
#define	HIFN_PUBOP_OP_MULT	0x00240000	/*  MULT */
#define	HIFN_PUBOP_OP_MODMULT	0x00280000	/*  Modular MULT */
#define	HIFN_PUBOP_OP_MODRED	0x002c0000	/*  Modular RED */
#define	HIFN_PUBOP_OP_MODEXP	0x00300000	/*  Modular EXP */

/* Public status register (HIFN_1_PUB_STATUS) */
#define	HIFN_PUBSTS_DONE	0x00000001	/* operation done */
#define	HIFN_PUBSTS_CARRY	0x00000002	/* carry */

/* Public interrupt enable register (HIFN_1_PUB_IEN) */
#define	HIFN_PUBIEN_DONE	0x00000001	/* operation done interrupt */

/* Random number generator config register (HIFN_1_RNG_CONFIG) */
#define	HIFN_RNGCFG_ENA		0x00000001	/* enable rng */

/*********************************************************************
 * Structs for board commands 
 *
 *********************************************************************/

/*
 * Structure to help build up the command data structure.
 */
struct hifn_base_command {
	volatile u_int16_t masks;
	volatile u_int16_t session_num;
	volatile u_int16_t total_source_count;
	volatile u_int16_t total_dest_count;
};

#define	HIFN_BASE_CMD_COMP		0x0100	/* enable compression engine */
#define	HIFN_BASE_CMD_PAD		0x0200	/* enable padding engine */
#define	HIFN_BASE_CMD_MAC		0x0400	/* enable MAC engine */
#define	HIFN_BASE_CMD_CRYPT		0x0800	/* enable crypt engine */
#define	HIFN_BASE_CMD_DECODE		0x2000
#define	HIFN_BASE_CMD_SRCLEN_M		0xc000
#define	HIFN_BASE_CMD_SRCLEN_S		14
#define	HIFN_BASE_CMD_DSTLEN_M		0x3000
#define	HIFN_BASE_CMD_DSTLEN_S		12
#define	HIFN_BASE_CMD_LENMASK_HI	0x30000
#define	HIFN_BASE_CMD_LENMASK_LO	0x0ffff

/*
 * Structure to help build up the command data structure.
 */
struct hifn_crypt_command {
	volatile u_int16_t masks;
	volatile u_int16_t header_skip;
	volatile u_int16_t source_count;
	volatile u_int16_t reserved;
};

#define	HIFN_CRYPT_CMD_ALG_MASK		0x0003		/* algorithm: */
#define	HIFN_CRYPT_CMD_ALG_DES		0x0000		/*   DES */
#define	HIFN_CRYPT_CMD_ALG_3DES		0x0001		/*   3DES */
#define	HIFN_CRYPT_CMD_ALG_RC4		0x0002		/*   RC4 */
#define	HIFN_CRYPT_CMD_ALG_AES		0x0003		/*   AES */
#define	HIFN_CRYPT_CMD_MODE_MASK	0x0018		/* Encrypt mode: */
#define	HIFN_CRYPT_CMD_MODE_ECB		0x0000		/*   ECB */
#define	HIFN_CRYPT_CMD_MODE_CBC		0x0008		/*   CBC */
#define	HIFN_CRYPT_CMD_MODE_CFB		0x0010		/*   CFB */
#define	HIFN_CRYPT_CMD_MODE_OFB		0x0018		/*   OFB */
#define	HIFN_CRYPT_CMD_CLR_CTX		0x0040		/* clear context */
#define	HIFN_CRYPT_CMD_KSZ_MASK		0x0600		/* AES key size: */
#define	HIFN_CRYPT_CMD_KSZ_128		0x0000		/*  128 bit */
#define	HIFN_CRYPT_CMD_KSZ_192		0x0200		/*  192 bit */
#define	HIFN_CRYPT_CMD_KSZ_256		0x0400		/*  256 bit */
#define	HIFN_CRYPT_CMD_NEW_KEY		0x0800		/* expect new key */
#define	HIFN_CRYPT_CMD_NEW_IV		0x1000		/* expect new iv */
#define	HIFN_CRYPT_CMD_SRCLEN_M		0xc000
#define	HIFN_CRYPT_CMD_SRCLEN_S		14

/*
 * Structure to help build up the command data structure.
 */
struct hifn_mac_command {
	volatile u_int16_t masks;
	volatile u_int16_t header_skip;
	volatile u_int16_t source_count;
	volatile u_int16_t reserved;
};

#define	HIFN_MAC_CMD_ALG_MASK		0x0001
#define	HIFN_MAC_CMD_ALG_SHA1		0x0000
#define	HIFN_MAC_CMD_ALG_MD5		0x0001
#define	HIFN_MAC_CMD_MODE_MASK		0x000c
#define	HIFN_MAC_CMD_MODE_HMAC		0x0000
#define	HIFN_MAC_CMD_MODE_SSL_MAC	0x0004
#define	HIFN_MAC_CMD_MODE_HASH		0x0008
#define	HIFN_MAC_CMD_MODE_FULL		0x0004
#define	HIFN_MAC_CMD_TRUNC		0x0010
#define	HIFN_MAC_CMD_RESULT		0x0020
#define	HIFN_MAC_CMD_APPEND		0x0040
#define	HIFN_MAC_CMD_SRCLEN_M		0xc000
#define	HIFN_MAC_CMD_SRCLEN_S		14

/*
 * MAC POS IPsec initiates authentication after encryption on encodes
 * and before decryption on decodes.
 */
#define	HIFN_MAC_CMD_POS_IPSEC		0x0200
#define	HIFN_MAC_CMD_NEW_KEY		0x0800

struct hifn_comp_command {
	volatile u_int16_t masks;
	volatile u_int16_t header_skip;
	volatile u_int16_t source_count;
	volatile u_int16_t reserved;
};

#define	HIFN_COMP_CMD_SRCLEN_M		0xc000
#define	HIFN_COMP_CMD_SRCLEN_S		14
#define	HIFN_COMP_CMD_ONE		0x0100	/* must be one */
#define	HIFN_COMP_CMD_CLEARHIST		0x0010	/* clear history */
#define	HIFN_COMP_CMD_UPDATEHIST	0x0008	/* update history */
#define	HIFN_COMP_CMD_LZS_STRIP0	0x0004	/* LZS: strip zero */
#define	HIFN_COMP_CMD_MPPC_RESTART	0x0004	/* MPPC: restart */
#define	HIFN_COMP_CMD_ALG_MASK		0x0001	/* compression mode: */
#define	HIFN_COMP_CMD_ALG_MPPC		0x0001	/*   MPPC */
#define	HIFN_COMP_CMD_ALG_LZS		0x0000	/*   LZS */

struct hifn_base_result {
	volatile u_int16_t flags;
	volatile u_int16_t session;
	volatile u_int16_t src_cnt;		/* 15:0 of source count */
	volatile u_int16_t dst_cnt;		/* 15:0 of dest count */
};

#define	HIFN_BASE_RES_DSTOVERRUN	0x0200	/* destination overrun */
#define	HIFN_BASE_RES_SRCLEN_M		0xc000	/* 17:16 of source count */
#define	HIFN_BASE_RES_SRCLEN_S		14
#define	HIFN_BASE_RES_DSTLEN_M		0x3000	/* 17:16 of dest count */
#define	HIFN_BASE_RES_DSTLEN_S		12

struct hifn_comp_result {
	volatile u_int16_t flags;
	volatile u_int16_t crc;
};

#define	HIFN_COMP_RES_LCB_M		0xff00	/* longitudinal check byte */
#define	HIFN_COMP_RES_LCB_S		8
#define	HIFN_COMP_RES_RESTART		0x0004	/* MPPC: restart */
#define	HIFN_COMP_RES_ENDMARKER		0x0002	/* LZS: end marker seen */
#define	HIFN_COMP_RES_SRC_NOTZERO	0x0001	/* source expired */

struct hifn_mac_result {
	volatile u_int16_t flags;
	volatile u_int16_t reserved;
	/* followed by 0, 6, 8, or 10 u_int16_t's of the MAC, then crypt */
};

#define	HIFN_MAC_RES_MISCOMPARE		0x0002	/* compare failed */
#define	HIFN_MAC_RES_SRC_NOTZERO	0x0001	/* source expired */

struct hifn_crypt_result {
	volatile u_int16_t flags;
	volatile u_int16_t reserved;
};

#define	HIFN_CRYPT_RES_SRC_NOTZERO	0x0001	/* source expired */

/*
 * The poll frequency and poll scalar defines are unshifted values used
 * to set fields in the DMA Configuration Register.
 */
#ifndef HIFN_POLL_FREQUENCY
#define	HIFN_POLL_FREQUENCY	0x1
#endif

#ifndef HIFN_POLL_SCALAR
#define	HIFN_POLL_SCALAR	0x0
#endif

#define	HIFN_MAX_SEGLEN 	0xffff		/* maximum dma segment len */
#define	HIFN_MAX_DMALEN		0x3ffff		/* maximum dma length */
#endif /* __HIFN_H__ */
@


1.45
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.44 2003/10/09 03:47:20 jason Exp $	*/
d44 1
a44 1
#include <machine/endian.h>
@


1.44
log
@- from freebsd: 795[56] AES support
- don't bother with the master/mmio enable stuff (it's done in pci.c for us)
based on suggestion from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.43 2003/06/02 15:58:41 deraadt Exp $	*/
d327 1
a327 1
#define	HIFN_PUBOPLEN_EXP_S	7		/* exponent lenght shift */
@


1.43
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.42 2003/02/19 19:59:14 jason Exp $	*/
d194 1
d311 3
d404 2
a405 1
#define	HIFN_CRYPT_CMD_MODE_MASK	0x0018		/* DES mode: */
d411 4
a416 1

@


1.42
log
@- Bump size of MAX_RESULT by 4 to include compression result
- add defines for compression
- add bit/structure defintions for the result structures
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.41 2003/02/17 16:48:22 jason Exp $	*/
a23 1
 *
@


1.41
log
@whitespace, typos, and compression structure defns
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.40 2003/02/15 23:39:13 jason Exp $	*/
d62 1
a62 1
 * MAX_RESULT  = base result + mac result + mac + encrypt result
d67 1
a67 1
#define	HIFN_MAX_RESULT		(8 + 4 + 20 + 4)
d375 4
a378 2
#define	HIFN_BASE_CMD_MAC		0x0400
#define	HIFN_BASE_CMD_CRYPT		0x0800
d461 40
@


1.40
log
@kill the remaining typedefs (These are about the last trace of Invertex
save for the copyright message).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.39 2002/07/25 15:27:20 jason Exp $	*/
d441 18
@


1.39
log
@house cleaning, also fix a couple of incorrect bit definitions in the
(currently unused) pk engine
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.38 2002/07/23 19:25:09 jason Exp $	*/
d74 1
a74 1
typedef struct hifn_desc {
d77 1
a77 1
} hifn_desc_t;
d368 1
a368 1
typedef struct hifn_base_command {
d373 1
a373 1
} hifn_base_command_t;
d388 1
a388 1
typedef struct hifn_crypt_command {
d393 1
a393 1
} hifn_crypt_command_t;
d414 1
a414 1
typedef struct hifn_mac_command {
d419 1
a419 1
} hifn_mac_command_t;
@


1.38
log
@from reading sam@@errno.com's code:
- TRDY and RETRY register definitions were backwards
- move TRDY/RETRY setup into its own function
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.37 2002/07/23 17:53:46 jason Exp $	*/
a89 1

d201 2
a202 1

d208 1
a208 1
#define	HIFN_1_PUB_IEN		0x310	/* Public Interrupt nable */
d317 11
d329 6
a334 3
#define	HIFN_PUBOP_AOFFSET	0x0000003e	/* A offset */
#define	HIFN_PUBOP_BOFFSET	0x00000fc0	/* B offset */
#define	HIFN_PUBOP_MOFFSET	0x0003f000	/* M offset */
d347 2
a348 7
#define	HIFN_PUBOP_OP_MODRED	0x002c0000	/*  Modular Red */
#define	HIFN_PUBOP_OP_MODEXP	0x00300000	/*  Modular Exp */

/* Public operand length register (HIFN_1_PUB_OPLEN) */
#define	HIFN_PUBOPLEN_MODLEN	0x0000007f
#define	HIFN_PUBOPLEN_EXPLEN	0x0003ff80
#define	HIFN_PUBOPLEN_REDLEN	0x003c0000
a358 7

/*
 * Register offsets in register set 1
 */

#define	HIFN_UNLOCK_SECRET1	0xf4
#define	HIFN_UNLOCK_SECRET2	0xfc
@


1.37
log
@Don't use a magic constant
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.36 2002/07/21 19:08:26 jason Exp $	*/
d53 2
a54 2
#define	HIFN_RETRY_TIMEOUT	0x40
#define	HIFN_TRDY_TIMEOUT	0x41
@


1.36
log
@Deal with the fact that one of the 7811 revisions cannot correctly handle
burst writes (bridges may coalesce sequential writes into a burst) by
inserting a read (I know, icky!) in between sequential writes.  Thanks
to sam@@errno.com, GTGI, and Hifn for helping track this one down.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.35 2002/04/08 17:49:42 jason Exp $	*/
d310 3
@


1.35
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.34 2002/01/23 15:59:12 jason Exp $	*/
a353 5

#define	WRITE_REG_1(sc,reg,val)	\
    bus_space_write_4((sc)->sc_st1, (sc)->sc_sh1, reg, val)
#define	READ_REG_1(sc,reg) \
    bus_space_read_4((sc)->sc_st1, (sc)->sc_sh1, reg)
@


1.34
log
@Add defn for MIPS reset register and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.33 2002/01/09 01:53:39 jason Exp $	*/
d36 5
@


1.33
log
@o There's no such thing as a source overrun, remove the definition
o enable illegal read/write interrupts on 7811 (mainly for debugging)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.32 2002/01/08 23:17:24 jason Exp $	*/
d195 1
d294 11
@


1.32
log
@Add support for the Hifn 7811 (Thanks to GTGI for donating the card).
While here, avoid resetting the card so often during the ram probe [speeds up autoconf and simplifies the driver a bit].
Also, add a missing argument to a debugging printf() (no longer ever called because the abort timers are disabled =)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.31 2001/11/04 18:31:42 jason Exp $	*/
d235 2
a236 1
#define	HIFN_DMACSR_S_OVER	0x00000200	/* Source Ring Overflow */
d246 1
a246 1
#define	HIFN_DMACSR_C_EIRQ	0x00000001	/* Command Ring Engine IRQ */
d263 2
a264 1
#define	HIFN_DMAIER_S_OVER	0x00000200	/* Source Ring Overflow */
d269 1
a269 1
#define	HIFN_DMAIER_PUBDONE	0x00000002	/* public op done (7951 only */
@


1.31
log
@7751 has two registers in config space (0x40 - RETRY_TIMEOUT and 0x41,
TRDY_TIMEOUT).  These registers must be initialized to zero to disable
these timers or 7751 will get PCI aborts on its descriptor rings on
certain chipsets.  These timers were removed because they were unneeded
in the 7951.  I'm not sure how I missed this in the datasheet, but there
it is plain as day on page 24.  Thanks go to Hifn for pointing this out.

Upshot: PCI abort problem on 7751 appears to be solved.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.30 2001/08/27 18:54:56 jason Exp $	*/
d191 4
d279 12
@


1.31.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.34 2002/01/23 15:59:12 jason Exp $	*/
a190 5
#define	HIFN_1_7811_RNGENA	0x60	/* 7811: rng enable */
#define	HIFN_1_7811_RNGCFG	0x64	/* 7811: rng config */
#define	HIFN_1_7811_RNGDAT	0x68	/* 7811: rng data */
#define	HIFN_1_7811_RNGSTS	0x6c	/* 7811: rng status */
#define	HIFN_1_7811_MIPSRST	0x94	/* 7811: MIPS reset */
d231 1
a231 2
#define	HIFN_DMACSR_ILLW	0x00000200	/* Illegal write (7811 only) */
#define	HIFN_DMACSR_ILLR	0x00000100	/* Illegal read (7811 only) */
d241 1
a241 1
#define	HIFN_DMACSR_ENGINE	0x00000001	/* Command Ring Engine IRQ */
d258 1
a258 2
#define	HIFN_DMAIER_ILLW	0x00000200	/* Illegal write (7811 only) */
#define	HIFN_DMAIER_ILLR	0x00000100	/* Illegal read (7811 only) */
d263 1
a263 1
#define	HIFN_DMAIER_PUBDONE	0x00000002	/* public op done (7951 only) */
a274 23

/* 7811 RNG Enable Register (HIFN_1_7811_RNGENA) */
#define	HIFN_7811_RNGENA_ENA	0x00000001	/* enable RNG */

/* 7811 RNG Config Register (HIFN_1_7811_RNGCFG) */
#define	HIFN_7811_RNGCFG_PRE1	0x00000f00	/* first prescalar */
#define	HIFN_7811_RNGCFG_OPRE	0x00000080	/* output prescalar */
#define	HIFN_7811_RNGCFG_DEFL	0x00000f80	/* 2 words/ 1/100 sec */

/* 7811 RNG Status Register (HIFN_1_7811_RNGSTS) */
#define	HIFN_7811_RNGSTS_RDY	0x00004000	/* two numbers in FIFO */
#define	HIFN_7811_RNGSTS_UFL	0x00001000	/* rng underflow */

/* 7811 MIPS Reset Register (HIFN_1_7811_MIPSRST) */
#define	HIFN_MIPSRST_BAR2SIZE	0xffff0000	/* sdram size */
#define	HIFN_MIPSRST_GPRAMINIT	0x00008000	/* gpram can be accessed */
#define	HIFN_MIPSRST_CRAMINIT	0x00004000	/* ctxram can be accessed */
#define	HIFN_MIPSRST_LED2	0x00000400	/* external LED2 */
#define	HIFN_MIPSRST_LED1	0x00000200	/* external LED1 */
#define	HIFN_MIPSRST_LED0	0x00000100	/* external LED0 */
#define	HIFN_MIPSRST_MIPSDIS	0x00000004	/* disable MIPS */
#define	HIFN_MIPSRST_MIPSRST	0x00000002	/* warm reset MIPS */
#define	HIFN_MIPSRST_MIPSCOLD	0x00000001	/* cold reset MIPS */
@


1.31.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.31.2.1 2002/01/31 22:55:35 niklas Exp $	*/
a35 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
@


1.31.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.31.2.2 2002/06/11 03:42:25 art Exp $	*/
d53 2
a54 2
#define	HIFN_RETRY_TIMEOUT	0x41
#define	HIFN_TRDY_TIMEOUT	0x40
d90 1
d202 1
a202 2
#define	HIFN_1_UNLOCK_SECRET1	0xf4
#define	HIFN_1_UNLOCK_SECRET2	0xfc
d208 1
a208 1
#define	HIFN_1_PUB_IEN		0x310	/* Public Interrupt enable */
a310 3
/* Revision ID */
#define	HIFN_REVID_7811_PB3_2	0x00000002	/* 7811PB3/2 */

a313 11
/* Public base address register (HIFN_1_PUB_BASE) */
#define	HIFN_PUBBASE_ADDR	0x00003fff	/* base address */

/* Public operand length register (HIFN_1_PUB_OPLEN) */
#define	HIFN_PUBOPLEN_MOD_M	0x0000007f	/* modulus length mask */
#define	HIFN_PUBOPLEN_MOD_S	0		/* modulus length shift */
#define	HIFN_PUBOPLEN_EXP_M	0x0003ff80	/* exponent length mask */
#define	HIFN_PUBOPLEN_EXP_S	7		/* exponent lenght shift */
#define	HIFN_PUBOPLEN_RED_M	0x003c0000	/* reducend length mask */
#define	HIFN_PUBOPLEN_RED_S	18		/* reducend length shift */

d315 3
a317 6
#define	HIFN_PUBOP_AOFFSET_M	0x0000007f	/* A offset mask */
#define	HIFN_PUBOP_AOFFSET_S	0		/* A offset shift */
#define	HIFN_PUBOP_BOFFSET_M	0x00000f80	/* B offset mask */
#define	HIFN_PUBOP_BOFFSET_S	7		/* B offset shift */
#define	HIFN_PUBOP_MOFFSET_M	0x0003f000	/* M offset mask */
#define	HIFN_PUBOP_MOFFSET_S	12		/* M offset shift */
d330 7
a336 2
#define	HIFN_PUBOP_OP_MODRED	0x002c0000	/*  Modular RED */
#define	HIFN_PUBOP_OP_MODEXP	0x00300000	/*  Modular EXP */
d347 12
@


1.31.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
a62 1
 * MAX_RESULT  = base result + comp result + mac result + mac + encrypt result
d67 1
a67 1
#define	HIFN_MAX_RESULT		(8 + 4 + 4 + 20 + 4)
d74 1
a74 1
struct hifn_desc {
d77 1
a77 1
};
d368 1
a368 1
struct hifn_base_command {
d373 1
a373 1
};
d375 2
a376 4
#define	HIFN_BASE_CMD_COMP		0x0100	/* enable compression engine */
#define	HIFN_BASE_CMD_PAD		0x0200	/* enable padding engine */
#define	HIFN_BASE_CMD_MAC		0x0400	/* enable MAC engine */
#define	HIFN_BASE_CMD_CRYPT		0x0800	/* enable crypt engine */
d388 1
a388 1
struct hifn_crypt_command {
d393 1
a393 1
};
d414 1
a414 1
struct hifn_mac_command {
d419 1
a419 1
};
a440 58

struct hifn_comp_command {
	volatile u_int16_t masks;
	volatile u_int16_t header_skip;
	volatile u_int16_t source_count;
	volatile u_int16_t reserved;
};

#define	HIFN_COMP_CMD_SRCLEN_M		0xc000
#define	HIFN_COMP_CMD_SRCLEN_S		14
#define	HIFN_COMP_CMD_ONE		0x0100	/* must be one */
#define	HIFN_COMP_CMD_CLEARHIST		0x0010	/* clear history */
#define	HIFN_COMP_CMD_UPDATEHIST	0x0008	/* update history */
#define	HIFN_COMP_CMD_LZS_STRIP0	0x0004	/* LZS: strip zero */
#define	HIFN_COMP_CMD_MPPC_RESTART	0x0004	/* MPPC: restart */
#define	HIFN_COMP_CMD_ALG_MASK		0x0001	/* compression mode: */
#define	HIFN_COMP_CMD_ALG_MPPC		0x0001	/*   MPPC */
#define	HIFN_COMP_CMD_ALG_LZS		0x0000	/*   LZS */

struct hifn_base_result {
	volatile u_int16_t flags;
	volatile u_int16_t session;
	volatile u_int16_t src_cnt;		/* 15:0 of source count */
	volatile u_int16_t dst_cnt;		/* 15:0 of dest count */
};

#define	HIFN_BASE_RES_DSTOVERRUN	0x0200	/* destination overrun */
#define	HIFN_BASE_RES_SRCLEN_M		0xc000	/* 17:16 of source count */
#define	HIFN_BASE_RES_SRCLEN_S		14
#define	HIFN_BASE_RES_DSTLEN_M		0x3000	/* 17:16 of dest count */
#define	HIFN_BASE_RES_DSTLEN_S		12

struct hifn_comp_result {
	volatile u_int16_t flags;
	volatile u_int16_t crc;
};

#define	HIFN_COMP_RES_LCB_M		0xff00	/* longitudinal check byte */
#define	HIFN_COMP_RES_LCB_S		8
#define	HIFN_COMP_RES_RESTART		0x0004	/* MPPC: restart */
#define	HIFN_COMP_RES_ENDMARKER		0x0002	/* LZS: end marker seen */
#define	HIFN_COMP_RES_SRC_NOTZERO	0x0001	/* source expired */

struct hifn_mac_result {
	volatile u_int16_t flags;
	volatile u_int16_t reserved;
	/* followed by 0, 6, 8, or 10 u_int16_t's of the MAC, then crypt */
};

#define	HIFN_MAC_RES_MISCOMPARE		0x0002	/* compare failed */
#define	HIFN_MAC_RES_SRC_NOTZERO	0x0001	/* source expired */

struct hifn_crypt_result {
	volatile u_int16_t flags;
	volatile u_int16_t reserved;
};

#define	HIFN_CRYPT_RES_SRC_NOTZERO	0x0001	/* source expired */
@


1.30
log
@initial support for non-HMAC md5/sha1 (work by ben@@ and myself)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.29 2001/08/08 03:11:47 jason Exp $	*/
d38 1
a38 1
#define __HIFN_H__
d46 4
a49 2
#define HIFN_BAR0		(PCI_MAPREG_START + 0)	/* PUC register map */
#define HIFN_BAR1		(PCI_MAPREG_START + 4)	/* DMA register map */
@


1.30.2.1
log
@Pull in patch from current:
7751 has two registers in config space (0x40 - RETRY_TIMEOUT and 0x41,
TRDY_TIMEOUT).  These registers must be initialized to zero to disable
these timers or 7751 will get PCI aborts on its descriptor rings on
certain chipsets.  These timers were removed because they were unneeded
in the 7951.  I'm not sure how I missed this in the datasheet, but there
it is plain as day on page 24.  Thanks go to Hifn for pointing this out.

Upshot: PCI abort problem on 7751 appears to be solved.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.30 2001/08/27 18:54:56 jason Exp $	*/
d38 1
a38 1
#define	__HIFN_H__
d46 2
a47 4
#define	HIFN_BAR0		(PCI_MAPREG_START + 0)	/* PUC register map */
#define	HIFN_BAR1		(PCI_MAPREG_START + 4)	/* DMA register map */
#define	HIFN_RETRY_TIMEOUT	0x40
#define	HIFN_TRDY_TIMEOUT	0x41
@


1.29
log
@Initial support for RC4 operations (This probably won't work yet as
the caller of *_process() doesn't seem to initialize crd_klen correctly;
it has a zero value... still debugging...).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.28 2001/07/08 18:05:42 brad Exp $	*/
d387 1
a387 1
#define	HIFN_MAC_CMD_MODE_MASK		0x0004
d389 2
@


1.28
log
@Hifn has changed its company name, make the name consistent throughout
the tree. Hi/fn, Hi/Fn and HiFn -> Hifn.
--
Ok'd by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.27 2001/06/27 03:33:53 angelos Exp $	*/
d54 1
a54 1
 *			mac-key + des-iv + 3des-key
d59 1
a59 1
#define	HIFN_MAX_COMMAND	(8 + 8 + 8 + 64 + 8 + 24)
@


1.27
log
@"IPsec" capitalization (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.26 2001/06/26 03:43:25 jason Exp $	*/
d4 1
a4 1
 * Invertex AEON / Hi/fn 7751 driver
@


1.26
log
@move bus access to var where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.25 2001/06/25 22:03:08 jason Exp $	*/
d397 1
a397 1
 * MAC POS IPSec initiates authentication after encryption on encodes
@


1.25
log
@bits are -wrong- in documentation... this is a recurring theme, do chip
makers -read- their docs?
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.24 2001/06/23 20:20:33 jason Exp $	*/
a309 5

#define	WRITE_REG_0(sc,reg,val) \
    bus_space_write_4((sc)->sc_st0, (sc)->sc_sh0, reg, val)
#define	READ_REG_0(sc,reg) \
    bus_space_read_4((sc)->sc_st0, (sc)->sc_sh0, reg)
@


1.24
log
@add some infrastructure for the public engine
require reworking interrupt enable and status checking as well as
a bit of initialization
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.23 2001/06/23 19:50:47 jason Exp $	*/
d196 1
a196 1
#define	HIFN_1_PUB_IEN		0x310	/* Public Interrupt Enable */
d278 2
a279 2
#define	HIFN_PUBOP_AOFFSET	0x0000007e	/* A offset */
#define	HIFN_PUBOP_BOFFSET	0x00000f80	/* B offset */
d295 5
@


1.23
log
@more 7951 specific bits and definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.22 2001/06/23 00:25:38 jason Exp $	*/
d238 1
@


1.22
log
@- put hw defines in *reg, software defines in *var, etc
- clean up pub/rng initialization call
- attempt to remove more intertex vestiges
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.21 2001/06/22 23:53:52 jason Exp $	*/
d260 1
d275 26
@


1.21
log
@Fix lotsa bugs:
- Hi/Fn length fields in command structures are 18 bits (feature!), but
descriptor lengths are 16 bits.
- define dmamap maximum lengths correctly (2^18 for total length, 2^16
for segments).
- Make the defines more consistent, and add other modes
- split source_count in command descriptors into a 16 bit length, and 16bit reserved part
upshot: blocks as large as 2^18 - 8 work now for userland crypto
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.20 2001/06/22 19:02:43 jason Exp $	*/
d7 1
a7 1
 * Copyright (c) 2000 Network Security Technologies, Inc.
a49 8
 *  Some configurable values for the driver
 */
#define HIFN_D_CMD_RSIZE	24
#define HIFN_D_SRC_RSIZE	80
#define HIFN_D_DST_RSIZE	80
#define HIFN_D_RES_RSIZE	24

/*
d59 2
a60 2
#define HIFN_MAX_COMMAND	(8 + 8 + 8 + 64 + 8 + 24)
#define HIFN_MAX_RESULT		(8 + 4 + 20 + 4)
d75 1
a75 1
#define HIFN_D_LENGTH		0x0000ffff	/* length bit mask */
a82 60
/*
 * Data structure to hold all 4 rings and any other ring related data.
 */
struct hifn_dma {
	/*
	 *  Descriptor rings.  We add +1 to the size to accomidate the
	 *  jump descriptor.
	 */
	struct hifn_desc	cmdr[HIFN_D_CMD_RSIZE+1];
	struct hifn_desc	srcr[HIFN_D_SRC_RSIZE+1];
	struct hifn_desc	dstr[HIFN_D_DST_RSIZE+1];
	struct hifn_desc	resr[HIFN_D_RES_RSIZE+1];

	struct hifn_command	*hifn_commands[HIFN_D_RES_RSIZE];

	u_char	command_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_COMMAND];
	u_char	result_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_RESULT];

	u_int64_t	test_src, test_dst;

	/*
	 *  Our current positions for insertion and removal from the desriptor
	 *  rings. 
	 */
	int		cmdi, srci, dsti, resi;
	volatile int	cmdu, srcu, dstu, resu;
	int		cmdk, srck, dstk, resk;
};

struct hifn_session {
	int hs_flags;
	u_int8_t hs_iv[HIFN_IV_LENGTH];
};

/*
 * Holds data specific to a single HIFN board.
 */
struct hifn_softc {
	struct device	sc_dv;		/* generic device */
	void *		sc_ih;		/* interrupt handler cookie */
	u_int32_t	sc_dmaier;
	u_int32_t	sc_drammodel;	/* 1=dram, 0=sram */

	bus_space_handle_t	sc_sh0, sc_sh1;
	bus_space_tag_t		sc_st0, sc_st1;
	bus_dma_tag_t		sc_dmat;

	struct hifn_dma *sc_dma;
	bus_dmamap_t sc_dmamap;
	int32_t sc_cid;
	int sc_maxses;
	int sc_ramsize;
	int sc_flags;
#define HIFN_HAS_RNG		1
#define HIFN_HAS_PUBLIC		2
	struct timeout sc_rngto;
	int sc_rngfirst;
	int sc_rnghz;
	struct hifn_session sc_sessions[2048];
};
d191 10
a200 10
#define HIFN_1_PUB_RESET	0x204	/* Public/RNG Reset */
#define HIFN_1_PUB_BASE		0x300	/* Public Base Address */
#define HIFN_1_PUB_OPLEN	0x304	/* Public Operand Length */
#define HIFN_1_PUB_OP		0x308	/* Public Operand */
#define HIFN_1_PUB_STATUS	0x30c	/* Public Status */
#define HIFN_1_PUB_IEN		0x310	/* Public Interrupt Enable */
#define HIFN_1_RNG_CONFIG	0x314	/* RNG config */
#define HIFN_1_RNG_DATA		0x318	/* RNG data */
#define HIFN_1_PUB_MEM		0x400	/* start of Public key memory */
#define HIFN_1_PUB_MEMEND	0xbff	/* end of Public key memory */
d278 1
a278 1
#define WRITE_REG_0(sc,reg,val) \
d280 1
a280 1
#define READ_REG_0(sc,reg) \
d290 1
a290 1
#define WRITE_REG_1(sc,reg,val)	\
d292 1
a292 1
#define READ_REG_1(sc,reg) \
d372 2
a373 2
#define HIFN_MAC_CMD_POS_IPSEC		(0x2 << 8)
#define HIFN_MAC_CMD_NEW_KEY		(0x1 << 11)
d380 1
a380 1
#define HIFN_POLL_FREQUENCY	0x1
d384 1
a384 1
#define HIFN_POLL_SCALAR	0x0
@


1.20
log
@Add support for RNG on 7951; many thanks to Soren Kristensen
<soren@@soekris.com> for donating the cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.19 2001/05/13 23:39:54 jason Exp $	*/
d378 9
a386 3
#define HIFN_BASE_CMD_MAC		(0x1 << 10)
#define HIFN_BASE_CMD_CRYPT		(0x1 << 11)
#define HIFN_BASE_CMD_DECODE		(0x1 << 13)
d394 2
a395 1
	volatile u_int32_t source_count;
d398 15
a412 6
#define HIFN_CRYPT_CMD_ALG_MASK		(0x3 << 0)
#define HIFN_CRYPT_CMD_ALG_DES		(0x0 << 0)
#define HIFN_CRYPT_CMD_ALG_3DES		(0x1 << 0)
#define HIFN_CRYPT_CMD_MODE_CBC		(0x1 << 3)
#define HIFN_CRYPT_CMD_NEW_KEY		(0x1 << 11)
#define HIFN_CRYPT_CMD_NEW_IV		(0x1 << 12)
d420 2
a421 1
	volatile u_int32_t source_count;
d424 12
a435 6
#define HIFN_MAC_CMD_ALG_MD5		(0x1 << 0)
#define HIFN_MAC_CMD_ALG_SHA1		(0x0 << 0)
#define HIFN_MAC_CMD_MODE_HMAC		(0x0 << 2)
#define HIFN_MAC_CMD_TRUNC		(0x1 << 4)
#define HIFN_MAC_CMD_RESULT		(0x1 << 5)
#define HIFN_MAC_CMD_APPEND		(0x1 << 6)
d455 2
a456 2
#define HIFN_MAX_SEGLEN 0xfffc

@


1.19
log
@First try at bus_dma(9)-ifying hifn7751 driver... advantages:
- vtophys is dead
- now builds on alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.18 2001/05/08 22:09:51 deraadt Exp $	*/
d146 3
d339 6
@


1.18
log
@document registers off BAR1 found on the 7951
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.17 2000/12/12 21:30:34 jason Exp $	*/
d109 2
d139 1
d422 2
@


1.17
log
@remove some dead stuff and correct spelling in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.16 2000/10/26 00:41:26 jason Exp $	*/
d140 3
d252 11
@


1.17.2.1
log
@Errata #18:
Hifn 7751 based cards may stop working on certain motherboards due to
DMA errors.
Fix (jason):
7751 has two registers in config space (0x40 - RETRY_TIMEOUT and 0x41,
TRDY_TIMEOUT).  These registers must be initialized to zero to disable
these timers or 7751 will get PCI aborts on its descriptor rings on
certain chipsets.  These timers were removed because they were unneeded
in the 7951.  I'm not sure how I missed this in the datasheet, but there
it is plain as day on page 24.  Thanks go to Hifn for pointing this out.

Upshot: PCI abort problem on 7751 appears to be solved.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.17 2000/12/12 21:30:34 jason Exp $	*/
d38 1
a38 1
#define	__HIFN_H__
d46 2
a47 4
#define	HIFN_BAR0		(PCI_MAPREG_START + 0)	/* PUC register map */
#define	HIFN_BAR1		(PCI_MAPREG_START + 4)	/* DMA register map */
#define	HIFN_RETRY_TIMEOUT	0x40
#define	HIFN_TRDY_TIMEOUT	0x41
a140 2
	pci_chipset_tag_t sc_pci_pc;
	pcitag_t sc_pci_tag;
@


1.16
log
@shadow the dmaier to avoid an additional pci read in the interrupt path
if mastering isn't enabled, scream
document netsec rev A workaround
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.15 2000/09/21 13:34:58 jason Exp $	*/
a91 7
 * hifn_callback_t 
 *
 * Type for callback function when dest data is ready.
 */
typedef void (*hifn_callback_t)(hifn_command_t *);

/*
d243 1
a243 1
#define	HIFN_1_DMA_RRAR		0x2c	/* DMA Resultt Ring Address */
@


1.15
log
@use volatile's on all structures shared between cpu and hifn
kill hifn_command_buf_data_t (unnecessary for a long time now)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.14 2000/04/11 13:49:34 jason Exp $	*/
d136 1
@


1.14
log
@define the rest of the descriptor bits
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.13 2000/04/10 18:40:47 jason Exp $	*/
d352 4
a355 4
	u_int16_t masks;
	u_int16_t session_num;
	u_int16_t total_source_count;
	u_int16_t total_dest_count;
d366 3
a368 3
	u_int16_t masks;
	u_int16_t header_skip;
	u_int32_t source_count;
d382 3
a384 3
	u_int16_t masks;
	u_int16_t header_skip;
	u_int32_t source_count;
a398 14

/*
 * Structure with all fields necessary to write the command buffer.
 * We build it up while interrupts are on, then use it to write out
 * the command buffer quickly while interrupts are off.
 */
typedef struct hifn_command_buf_data {
	hifn_base_command_t base_cmd;
	hifn_mac_command_t mac_cmd;
	hifn_crypt_command_t crypt_cmd;
	const u_int8_t *mac;
	const u_int8_t *ck;
	const u_int8_t *iv;
} hifn_command_buf_data_t;
@


1.13
log
@- Add back code from the original aeon driver to handle missed interrupts by
enabling interrupts when the command queue has more than one entry.
- fix comment on hifn_newsession to reflect reality
- allocate session structure in softc
- compute a random IV when a session is created and try to chain from a
software kept IV for subsequent packets
- add handling of CRD_F_EXPLICIT
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.12 2000/04/05 16:34:07 jason Exp $	*/
d83 7
a89 4
#define HIFN_D_MASKDONEIRQ	(0x1 << 25)
#define HIFN_D_LAST		(0x1 << 29)
#define HIFN_D_JUMP		(0x1 << 30)
#define HIFN_D_VALID		(0x1 << 31)
@


1.12
log
@maintain state about keys, upload them to context ram once (and avoid the
300 clock penalty on key upload)
XXX hifn_freesession should probably zot the keys from context ram but
XXX does not yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.11 2000/04/04 20:10:27 jason Exp $	*/
d122 5
d143 1
a143 1
	u_int8_t *sc_sessions;
@


1.11
log
@make the comment and definition of HIFN_MAX_COMMAND more readable
define HIFN_MAC_CMD_RESULT bit (append MAC to result buffer)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.10 2000/03/29 22:39:39 jason Exp $	*/
d138 1
@


1.10
log
@- update copyrights
- remove all ability to block (no more tsleep/wakeup)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.9 2000/03/29 20:54:59 jason Exp $	*/
d62 1
a62 1
 *			mac-key des-iv + 3des-key
d67 1
a67 1
#define HIFN_MAX_COMMAND	(8 + 8 + 8 + 8 + 64 + 24)
d382 1
@


1.9
log
@Long over due checkpoint:
o register the hifn as handling DES and 3DES (no md5 or sha1 yet) depending
	on whether the board is unlocked (none, half, or full)
o Fix many KNF nits
o print the amount of memory correctly and don't print the number of sessions
o set command and result buffer sizes correctly
o reclaim the descriptor rings so new commands and buffers can be added
o remove some bogus checks on the command buffer
o add new variables mac_process_len and crypt_process_len to hifn_command_t
o fix calculation in hifn_mbuf to generate the pa/len array for src/dst
o simplify the code for setting up the jump descriptor
o rework the hifn_intr routine to interrupt at IPL_IMP and simplify it's
	results processing
o more to come...
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.8 2000/03/17 20:31:31 jason Exp $	*/
d6 3
@


1.8
log
@Fix some space->\t
Attempt to figure out how much context ram is on the board (known to work
with sram boards).
From the amount of ram & other configuration, figure out how many sessions
are available for storage.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.7 2000/03/16 20:33:48 deraadt Exp $	*/
d43 2
a44 2
#define  HIFN_BAR0		(PCI_MAPREG_START + 0)	/* PUC register map */
#define  HIFN_BAR1		(PCI_MAPREG_START + 4)	/* DMA register map */
a48 3
#define HIFN_D_RSIZE	24
#define HIFN_MAX_DEVICES	4

d57 6
d64 2
a65 2
#define HIFN_MAX_COMMAND	120
#define HIFN_MAX_RESULT		16
d100 4
a103 4
	struct hifn_desc	cmdr[HIFN_D_RSIZE+1];
	struct hifn_desc	srcr[HIFN_D_RSIZE+1];
	struct hifn_desc	dstr[HIFN_D_RSIZE+1];
	struct hifn_desc	resr[HIFN_D_RSIZE+1];
d105 1
a105 1
	struct hifn_command	*hifn_commands[HIFN_D_RSIZE];
d107 2
a108 2
	u_char	command_bufs[HIFN_D_RSIZE][HIFN_MAX_COMMAND];
	u_char	result_bufs[HIFN_D_RSIZE][HIFN_MAX_RESULT];
d116 1
a116 3

	u_int32_t wakeup_rpos;
	volatile u_int32_t slots_in_use;
d346 3
a348 3
#define HIFN_BASE_CMD_MAC    (0x1 << 10)
#define HIFN_BASE_CMD_CRYPT  (0x1 << 11)
#define HIFN_BASE_CMD_DECODE (0x1 << 13)
d354 1
a354 1
	u_int16_t masks;               
d359 6
a364 6
#define HIFN_CRYPT_CMD_ALG_MASK  (0x3 << 0)
#define HIFN_CRYPT_CMD_ALG_DES   (0x0 << 0)
#define HIFN_CRYPT_CMD_ALG_3DES  (0x1 << 0)
#define HIFN_CRYPT_CMD_MODE_CBC  (0x1 << 3)
#define HIFN_CRYPT_CMD_NEW_KEY   (0x1 << 11)
#define HIFN_CRYPT_CMD_NEW_IV    (0x1 << 12)
d370 1
a370 1
	u_int16_t masks;  
d375 5
a379 5
#define HIFN_MAC_CMD_ALG_MD5    (0x1 << 0)
#define HIFN_MAC_CMD_ALG_SHA1   (0x0 << 0)
#define HIFN_MAC_CMD_MODE_HMAC  (0x0 << 2)
#define HIFN_MAC_CMD_TRUNC      (0x1 << 4)
#define HIFN_MAC_CMD_APPEND     (0x1 << 6)
d384 2
a385 2
#define HIFN_MAC_CMD_POS_IPSEC  (0x2 << 8)
#define HIFN_MAC_CMD_NEW_KEY    (0x1 << 11)
d406 1
a406 1
#define HIFN_POLL_FREQUENCY  0x1
d410 1
a410 1
#define HIFN_POLL_SCALAR    0x0
@


1.7
log
@move aeon to hifn7751
@
text
@d1 1
a1 1
/*	$OpenBSD: aeonreg.h,v 1.6 2000/03/15 14:55:52 jason Exp $	*/
d131 3
@


1.6
log
@Bring in bit definitions from the datasheet and allow shared interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: aeonreg.h,v 1.5 2000/03/10 08:45:00 mickey Exp $	*/
d4 1
a4 1
 * Invertex AEON driver
d34 2
a35 2
#ifndef __AEON_H__
#define __AEON_H__
d43 2
a44 2
#define  AEON_BAR0		(PCI_MAPREG_START + 0)	/* PUC register map */
#define  AEON_BAR1		(PCI_MAPREG_START + 4)	/* DMA register map */
d49 2
a50 2
#define AEON_D_RSIZE	24
#define AEON_MAX_DEVICES	4
d52 4
a55 4
#define AEON_D_CMD_RSIZE	24
#define AEON_D_SRC_RSIZE	80
#define AEON_D_DST_RSIZE	80
#define AEON_D_RES_RSIZE	24
d61 2
a62 2
#define AEON_MAX_COMMAND	120
#define AEON_MAX_RESULT		16
d65 1
a65 1
 * aeon_desc_t
d69 1
a69 1
typedef struct aeon_desc {
d72 1
a72 1
} aeon_desc_t;
d75 1
a75 1
 * Masks for the "length" field of struct aeon_desc.
d77 4
a80 4
#define AEON_D_MASKDONEIRQ	(0x1 << 25)
#define AEON_D_LAST		(0x1 << 29)
#define AEON_D_JUMP		(0x1 << 30)
#define AEON_D_VALID		(0x1 << 31)
d83 1
a83 1
 * aeon_callback_t 
d87 1
a87 1
typedef void (*aeon_callback_t)(aeon_command_t *);
d92 1
a92 1
struct aeon_dma {
d97 4
a100 4
	struct aeon_desc	cmdr[AEON_D_RSIZE+1];
	struct aeon_desc	srcr[AEON_D_RSIZE+1];
	struct aeon_desc	dstr[AEON_D_RSIZE+1];
	struct aeon_desc	resr[AEON_D_RSIZE+1];
d102 1
a102 1
	struct aeon_command	*aeon_commands[AEON_D_RSIZE];
d104 2
a105 2
	u_char	command_bufs[AEON_D_RSIZE][AEON_MAX_COMMAND];
	u_char	result_bufs[AEON_D_RSIZE][AEON_MAX_RESULT];
d119 1
a119 1
 * Holds data specific to a single AEON board.
d121 1
a121 1
struct aeon_softc {
d130 1
a130 1
	struct aeon_dma *sc_dma;
d136 88
a223 88
#define	AEON_0_PUDATA		0x00	/* Processing Unit Data */
#define	AEON_0_PUCTRL		0x04	/* Processing Unit Control */
#define	AEON_0_PUISR		0x08	/* Processing Unit Interrupt Status */
#define	AEON_0_PUCNFG		0x0c	/* Processing Unit Configuration */
#define	AEON_0_PUIER		0x10	/* Processing Unit Interrupt Enable */
#define	AEON_0_PUSTAT		0x14	/* Processing Unit Status/Chip ID */
#define	AEON_0_FIFOSTAT		0x18	/* FIFO Status */
#define	AEON_0_FIFOCNFG		0x1c	/* FIFO Configuration */
#define	AEON_0_SPACESIZE	0x20	/* Register space size */

/* Processing Unit Control Register (AEON_0_PUCTRL) */
#define	AEON_PUCTRL_CLRSRCFIFO	0x0010	/* clear source fifo */
#define	AEON_PUCTRL_STOP	0x0008	/* stop pu */
#define	AEON_PUCTRL_LOCKRAM	0x0004	/* lock ram */
#define	AEON_PUCTRL_DMAENA	0x0002	/* enable dma */
#define	AEON_PUCTRL_RESET	0x0001	/* Reset processing unit */

/* Processing Unit Interrupt Status Register (AEON_0_PUISR) */
#define	AEON_PUISR_CMDINVAL	0x8000	/* Invalid command interrupt */
#define	AEON_PUISR_DATAERR	0x4000	/* Data error interrupt */
#define	AEON_PUISR_SRCFIFO	0x2000	/* Source FIFO ready interrupt */
#define	AEON_PUISR_DSTFIFO	0x1000	/* Destination FIFO ready interrupt */
#define	AEON_PUISR_DSTOVER	0x0200	/* Destination overrun interrupt */
#define	AEON_PUISR_SRCCMD	0x0080	/* Source command interrupt */
#define	AEON_PUISR_SRCCTX	0x0040	/* Source context interrupt */
#define	AEON_PUISR_SRCDATA	0x0020	/* Source data interrupt */
#define	AEON_PUISR_DSTDATA	0x0010	/* Destination data interrupt */
#define	AEON_PUISR_DSTRESULT	0x0004	/* Destination result interrupt */

/* Processing Unit Configuration Register (AEON_0_PUCNFG) */
#define	AEON_PUCNFG_DRAMMASK	0xe000	/* DRAM size mask */
#define	AEON_PUCNFG_DSZ_256K	0x0000	/* 256k dram */
#define	AEON_PUCNFG_DSZ_512K	0x2000	/* 512k dram */
#define	AEON_PUCNFG_DSZ_1M	0x4000	/* 1m dram */
#define	AEON_PUCNFG_DSZ_2M	0x6000	/* 2m dram */
#define	AEON_PUCNFG_DSZ_4M	0x8000	/* 4m dram */
#define	AEON_PUCNFG_DSZ_8M	0xa000	/* 8m dram */
#define	AEON_PUNCFG_DSZ_16M	0xc000	/* 16m dram */
#define	AEON_PUCNFG_DSZ_32M	0xe000	/* 32m dram */
#define	AEON_PUCNFG_DRAMREFRESH	0x1800	/* DRAM refresh rate mask */
#define	AEON_PUCNFG_DRFR_512	0x0000	/* 512 divisor of ECLK */
#define	AEON_PUCNFG_DRFR_256	0x0800	/* 256 divisor of ECLK */
#define	AEON_PUCNFG_DRFR_128	0x1000	/* 128 divisor of ECLK */
#define	AEON_PUCNFG_TCALLPHASES	0x0200	/* your guess is as good as mine... */
#define	AEON_PUCNFG_TCDRVTOTEM	0x0100	/* your guess is as good as mine... */
#define	AEON_PUCNFG_BIGENDIAN	0x0080	/* DMA big endian mode */
#define	AEON_PUCNFG_BUS32	0x0040	/* Bus width 32bits */
#define	AEON_PUCNFG_BUS16	0x0000	/* Bus width 16 bits */
#define	AEON_PUCNFG_CHIPID	0x0020	/* Allow chipid from PUSTAT */
#define	AEON_PUCNFG_DRAM	0x0010	/* Context RAM is DRAM */
#define	AEON_PUCNFG_SRAM	0x0000	/* Context RAM is SRAM */
#define	AEON_PUCNFG_COMPSING	0x0004	/* Enable single compression context */
#define	AEON_PUCNFG_ENCCNFG	0x0002	/* Encryption configuration */

/* Processing Unit Interrupt Enable Register (AEON_0_PUIER) */
#define	AEON_PUIER_CMDINVAL	0x8000	/* Invalid command interrupt */
#define	AEON_PUIER_DATAERR	0x4000	/* Data error interrupt */
#define	AEON_PUIER_SRCFIFO	0x2000	/* Source FIFO ready interrupt */
#define	AEON_PUIER_DSTFIFO	0x1000	/* Destination FIFO ready interrupt */
#define	AEON_PUIER_DSTOVER	0x0200	/* Destination overrun interrupt */
#define	AEON_PUIER_SRCCMD	0x0080	/* Source command interrupt */
#define	AEON_PUIER_SRCCTX	0x0040	/* Source context interrupt */
#define	AEON_PUIER_SRCDATA	0x0020	/* Source data interrupt */
#define	AEON_PUIER_DSTDATA	0x0010	/* Destination data interrupt */
#define	AEON_PUIER_DSTRESULT	0x0004	/* Destination result interrupt */

/* Processing Unit Status Register/Chip ID (AEON_0_PUSTAT) */
#define	AEON_PUSTAT_CMDINVAL	0x8000	/* Invalid command interrupt */
#define	AEON_PUSTAT_DATAERR	0x4000	/* Data error interrupt */
#define	AEON_PUSTAT_SRCFIFO	0x2000	/* Source FIFO ready interrupt */
#define	AEON_PUSTAT_DSTFIFO	0x1000	/* Destination FIFO ready interrupt */
#define	AEON_PUSTAT_DSTOVER	0x0200	/* Destination overrun interrupt */
#define	AEON_PUSTAT_SRCCMD	0x0080	/* Source command interrupt */
#define	AEON_PUSTAT_SRCCTX	0x0040	/* Source context interrupt */
#define	AEON_PUSTAT_SRCDATA	0x0020	/* Source data interrupt */
#define	AEON_PUSTAT_DSTDATA	0x0010	/* Destination data interrupt */
#define	AEON_PUSTAT_DSTRESULT	0x0004	/* Destination result interrupt */
#define	AEON_PUSTAT_CHIPREV	0x00ff	/* Chip revision mask */
#define	AEON_PUSTAT_CHIPENA	0xff00	/* Chip enabled mask */
#define	AEON_PUSTAT_ENA_2	0x1100	/* Level 2 enabled */
#define	AEON_PUSTAT_ENA_1	0x1000	/* Level 1 enabled */
#define	AEON_PUSTAT_ENA_0	0x3000	/* Level 0 enabled */
#define	AEON_PUSTAT_REV_2	0x0020	/* 7751 PT6/2 */
#define	AEON_PUSTAT_REV_3	0x0030	/* 7751 PT6/3 */

/* FIFO Status Register (AEON_0_FIFOSTAT) */
#define	AEON_FIFOSTAT_SRC	0x7f00	/* Source FIFO available */
#define	AEON_FIFOSTAT_DST	0x007f	/* Destination FIFO available */
d225 2
a226 2
/* FIFO Configuration Register (AEON_0_FIFOCNFG) */
#define	AEON_FIFOCNFG_THRESHOLD	0x0400	/* must be written as 1 */
d231 78
a308 78
#define	AEON_1_DMA_CRAR		0x0c	/* DMA Command Ring Address */
#define	AEON_1_DMA_SRAR		0x1c	/* DMA Source Ring Address */
#define	AEON_1_DMA_RRAR		0x2c	/* DMA Resultt Ring Address */
#define	AEON_1_DMA_DRAR		0x3c	/* DMA Destination Ring Address */
#define	AEON_1_DMA_CSR		0x40	/* DMA Status and Control */
#define	AEON_1_DMA_IER		0x44	/* DMA Interrupt Enable */
#define	AEON_1_DMA_CNFG		0x48	/* DMA Configuration */
#define	AEON_1_REVID		0x98	/* Revision ID */

/* DMA Status and Control Register (AEON_1_DMA_CSR) */
#define	AEON_DMACSR_D_CTRLMASK	0xc0000000	/* Destinition Ring Control */
#define	AEON_DMACSR_D_CTRL_NOP	0x00000000	/* Dest. Control: no-op */
#define	AEON_DMACSR_D_CTRL_DIS	0x40000000	/* Dest. Control: disable */
#define	AEON_DMACSR_D_CTRL_ENA	0x80000000	/* Dest. Control: enable */
#define	AEON_DMACSR_D_ABORT	0x20000000	/* Destinition Ring PCIAbort */
#define	AEON_DMACSR_D_DONE	0x10000000	/* Destinition Ring Done */
#define	AEON_DMACSR_D_LAST	0x08000000	/* Destinition Ring Last */
#define	AEON_DMACSR_D_WAIT	0x04000000	/* Destinition Ring Waiting */
#define	AEON_DMACSR_D_OVER	0x02000000	/* Destinition Ring Overflow */
#define	AEON_DMACSR_R_CTRL	0x00c00000	/* Result Ring Control */
#define	AEON_DMACSR_R_CTRL_NOP	0x00000000	/* Result Control: no-op */
#define	AEON_DMACSR_R_CTRL_DIS	0x00400000	/* Result Control: disable */
#define	AEON_DMACSR_R_CTRL_ENA	0x00800000	/* Result Control: enable */
#define	AEON_DMACSR_R_ABORT	0x00200000	/* Result Ring PCI Abort */
#define	AEON_DMACSR_R_DONE	0x00100000	/* Result Ring Done */
#define	AEON_DMACSR_R_LAST	0x00080000	/* Result Ring Last */
#define	AEON_DMACSR_R_WAIT	0x00040000	/* Result Ring Waiting */
#define	AEON_DMACSR_R_OVER	0x00020000	/* Result Ring Overflow */
#define	AEON_DMACSR_S_CTRL	0x0000c000	/* Source Ring Control */
#define	AEON_DMACSR_S_CTRL_NOP	0x00000000	/* Source Control: no-op */
#define	AEON_DMACSR_S_CTRL_DIS	0x00004000	/* Source Control: disable */
#define	AEON_DMACSR_S_CTRL_ENA	0x00008000	/* Source Control: enable */
#define	AEON_DMACSR_S_ABORT	0x00002000	/* Source Ring PCI Abort */
#define	AEON_DMACSR_S_DONE	0x00001000	/* Source Ring Done */
#define	AEON_DMACSR_S_LAST	0x00000800	/* Source Ring Last */
#define	AEON_DMACSR_S_WAIT	0x00000400	/* Source Ring Waiting */
#define	AEON_DMACSR_S_OVER	0x00000200	/* Source Ring Overflow */
#define	AEON_DMACSR_C_CTRL	0x000000c0	/* Command Ring Control */
#define	AEON_DMACSR_C_CTRL_NOP	0x00000000	/* Command Control: no-op */
#define	AEON_DMACSR_C_CTRL_DIS	0x00000040	/* Command Control: disable */
#define	AEON_DMACSR_C_CTRL_ENA	0x00000080	/* Command Control: enable */
#define	AEON_DMACSR_C_ABORT	0x00000020	/* Command Ring PCI Abort */
#define	AEON_DMACSR_C_DONE	0x00000010	/* Command Ring Done */
#define	AEON_DMACSR_C_LAST	0x00000008	/* Command Ring Last */
#define	AEON_DMACSR_C_WAIT	0x00000004	/* Command Ring Waiting */
#define	AEON_DMACSR_C_EIRQ	0x00000001	/* Command Ring Engine IRQ */

/* DMA Interrupt Enable Register (AEON_1_DMA_IER) */
#define	AEON_DMAIER_D_ABORT	0x20000000	/* Destination Ring PCIAbort */
#define	AEON_DMAIER_D_DONE	0x10000000	/* Destination Ring Done */
#define	AEON_DMAIER_D_LAST	0x08000000	/* Destination Ring Last */
#define	AEON_DMAIER_D_WAIT	0x04000000	/* Destination Ring Waiting */
#define	AEON_DMAIER_D_OVER	0x02000000	/* Destination Ring Overflow */
#define	AEON_DMAIER_R_ABORT	0x00200000	/* Result Ring PCI Abort */
#define	AEON_DMAIER_R_DONE	0x00100000	/* Result Ring Done */
#define	AEON_DMAIER_R_LAST	0x00080000	/* Result Ring Last */
#define	AEON_DMAIER_R_WAIT	0x00040000	/* Result Ring Waiting */
#define	AEON_DMAIER_R_OVER	0x00020000	/* Result Ring Overflow */
#define	AEON_DMAIER_S_ABORT	0x00002000	/* Source Ring PCI Abort */
#define	AEON_DMAIER_S_DONE	0x00001000	/* Source Ring Done */
#define	AEON_DMAIER_S_LAST	0x00000800	/* Source Ring Last */
#define	AEON_DMAIER_S_WAIT	0x00000400	/* Source Ring Waiting */
#define	AEON_DMAIER_S_OVER	0x00000200	/* Source Ring Overflow */
#define	AEON_DMAIER_C_ABORT	0x00000020	/* Command Ring PCI Abort */
#define	AEON_DMAIER_C_DONE	0x00000010	/* Command Ring Done */
#define	AEON_DMAIER_C_LAST	0x00000008	/* Command Ring Last */
#define	AEON_DMAIER_C_WAIT	0x00000004	/* Command Ring Waiting */
#define	AEON_DMAIER_ENGINE	0x00000001	/* Engine IRQ */

/* DMA Configuration Register (AEON_1_DMA_CNFG) */
#define	AEON_DMACNFG_BIGENDIAN	0x10000000	/* big endian mode */
#define	AEON_DMACNFG_POLLFREQ	0x00ff0000	/* Poll frequency mask */
#define	AEON_DMACNFG_UNLOCK	0x00000800
#define	AEON_DMACNFG_POLLINVAL	0x00000700	/* Invalid Poll Scalar */
#define	AEON_DMACNFG_LAST	0x00000010	/* Host control LAST bit */
#define	AEON_DMACNFG_MODE	0x00000004	/* DMA mode */
#define	AEON_DMACNFG_DMARESET	0x00000002	/* DMA Reset # */
#define	AEON_DMACNFG_MSTRESET	0x00000001	/* Master Reset # */
d319 2
a320 2
#define	AEON_UNLOCK_SECRET1	0xf4
#define	AEON_UNLOCK_SECRET2	0xfc
d335 1
a335 1
typedef struct aeon_base_command {
d340 1
a340 1
} aeon_base_command_t;
d342 3
a344 3
#define AEON_BASE_CMD_MAC    (0x1 << 10)
#define AEON_BASE_CMD_CRYPT  (0x1 << 11)
#define AEON_BASE_CMD_DECODE (0x1 << 13)
d349 1
a349 1
typedef struct aeon_crypt_command {
d353 1
a353 1
} aeon_crypt_command_t;
d355 6
a360 6
#define AEON_CRYPT_CMD_ALG_MASK  (0x3 << 0)
#define AEON_CRYPT_CMD_ALG_DES   (0x0 << 0)
#define AEON_CRYPT_CMD_ALG_3DES  (0x1 << 0)
#define AEON_CRYPT_CMD_MODE_CBC  (0x1 << 3)
#define AEON_CRYPT_CMD_NEW_KEY   (0x1 << 11)
#define AEON_CRYPT_CMD_NEW_IV    (0x1 << 12)
d365 1
a365 1
typedef struct aeon_mac_command {
d369 1
a369 1
} aeon_mac_command_t;
d371 5
a375 5
#define AEON_MAC_CMD_ALG_MD5    (0x1 << 0)
#define AEON_MAC_CMD_ALG_SHA1   (0x0 << 0)
#define AEON_MAC_CMD_MODE_HMAC  (0x0 << 2)
#define AEON_MAC_CMD_TRUNC      (0x1 << 4)
#define AEON_MAC_CMD_APPEND     (0x1 << 6)
d380 2
a381 2
#define AEON_MAC_CMD_POS_IPSEC  (0x2 << 8)
#define AEON_MAC_CMD_NEW_KEY    (0x1 << 11)
d388 4
a391 4
typedef struct aeon_command_buf_data {
	aeon_base_command_t base_cmd;
	aeon_mac_command_t mac_cmd;
	aeon_crypt_command_t crypt_cmd;
d395 1
a395 1
} aeon_command_buf_data_t;
d401 2
a402 2
#ifndef AEON_POLL_FREQUENCY
#define AEON_POLL_FREQUENCY  0x1
d405 2
a406 2
#ifndef AEON_POLL_SCALAR
#define AEON_POLL_SCALAR    0x0
d409 1
a409 1
#endif /* __AEON_H__ */
@


1.5
log
@unlock cryptography functions on Hi/fn 7751 cryptography card.  Based on reverse engineering of an unlock binary provided by Invertex, for their AEON card, which uses the chip
@
text
@d1 1
a1 1
/*	$OpenBSD: aeonreg.h,v 1.4 1999/12/15 00:30:45 jason Exp $	*/
d43 2
a44 2
#define  PCI_BASE_ADDRESS_0	0x10	/* 32 bits */
#define  PCI_BASE_ADDRESS_1	0x14	/* 32 bits */
d134 1
a134 1
 * Register offsets in register set 0
d136 173
a308 6
#define AEON_INIT_1			0x04
#define AEON_RAM_CONFIG			0x0c
#define AEON_EXPAND			0x08
#define AEON_CRYPTLEVEL		0x14
#define AEON_INIT_3			0x10
#define AEON_INIT_2			0x1c
a317 12
#define AEON_CMDR_ADDR		0x0c
#define AEON_SRCR_ADDR		0x1c
#define AEON_RESR_ADDR		0x2c
#define AEON_DSTR_ADDR		0x3c
#define	AEON_STATUS		0x40
#define	AEON_IRQEN		0x44

#define	AEON_DMA_CFG			0x48
#define AEON_DMA_CFG_NOBOARDRESET	0x00000001
#define AEON_DMA_CFG_NODMARESET		0x00000002
#define AEON_DMA_CFG_NEED		0x00000004
#define AEON_DMA_CFG_HOSTLAST		0x00000010
a326 59
/*
 * Initial register values
 */

/*
 *  Status Register
 *  
 *  The value below enables polling on all 4 descriptor rings and
 *  writes a "1" to every status bit in the register.  (Writing "1"
 *  clears the bit.)
 */
#define AEON_INIT_STATUS_REG		((1<<31)|(1<<23)|(1<<15)|(1<<7))

/*
 *  Interrupt Enable Register 
 *
 *  Initial value sets all interrupts to off except the "mask done"
 *  interrupt of the the result descriptor ring.
 */
#define	AEON_INIT_INTERRUPT_ENABLE_REG	(AEON_INTR_ON_RESULT_DONE)

/*
 *  DMA Configuration Register
 *  
 *  Initial value sets the polling scalar and frequency, and puts
 *  the host (not the AEON board) in charge of "last" bits in the
 *  dest data and result descriptor rings.
 */
#define	AEON_INIT_DMA_CONFIG_REG					   \
    (AEON_DMA_CFG_NOBOARDRESET | AEON_DMA_CFG_NODMARESET | \
    AEON_DMA_CFG_NEED | \
    AEON_DMA_CFG_HOSTLAST |		/* host controls last bit in all rings */  \
    (AEON_POLL_SCALAR << 8) |		/* setting poll scalar value */		   \
    (AEON_POLL_FREQUENCY << 16))	/* setting poll frequency value */

/*
 *  RAM Configuration Register
 *
 *  Initial value sets the ecryption context size to 128 bytes (if using
 *  RC4 bump it to 512, but you'll decrease the number of available
 *  sessions).  We don't configure multiple compression histories -- since
 *  IPSec doesn't use them.
 *
 *  NOTE:  Use the AEON_RAM_CONFIG_INIT() macro instead of the
 *  variable, since DRAM/SRAM detection is not determined staticly.
 */
#define AEON_INIT_RAM_CONFIG_REG				\
  ((0x0 << 1) |		/* RAM Encrypt: 0 for 128 bytes, 1 for 512 bytes */  \
   (0x1 << 2) |		/* RAM Comp cfg: 1 for single compression history */ \
   0x4B40)		/* Setting fixed bits required by the register */

/*
 *  Expand Register
 *
 *  The only bit in this register is the expand bit at position 9.  It's
 *  cleared by writing a 1 to it.
 */
#define AEON_INIT_EXPAND_REG 	(0x1 << 9)

a395 6

/*
 * Values for the interrupt enable register
 */
#define AEON_INTR_ON_RESULT_DONE     (1 << 20)
#define AEON_INTR_ON_COMMAND_WAITING  (1 << 2)
@


1.4
log
@nuke *vm_alloc_page_contig, use bus_dma
@
text
@d1 1
a1 1
/*	$OpenBSD: aeonreg.h,v 1.3 1999/02/24 06:09:45 deraadt Exp $	*/
d163 3
@


1.4.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Invertex AEON / Hi/fn 7751 driver
d34 2
a35 2
#ifndef __HIFN_H__
#define __HIFN_H__
d43 2
a44 2
#define  HIFN_BAR0		(PCI_MAPREG_START + 0)	/* PUC register map */
#define  HIFN_BAR1		(PCI_MAPREG_START + 4)	/* DMA register map */
d49 2
a50 2
#define HIFN_D_RSIZE	24
#define HIFN_MAX_DEVICES	4
d52 4
a55 4
#define HIFN_D_CMD_RSIZE	24
#define HIFN_D_SRC_RSIZE	80
#define HIFN_D_DST_RSIZE	80
#define HIFN_D_RES_RSIZE	24
d61 2
a62 2
#define HIFN_MAX_COMMAND	120
#define HIFN_MAX_RESULT		16
d65 1
a65 1
 * hifn_desc_t
d69 1
a69 1
typedef struct hifn_desc {
d72 1
a72 1
} hifn_desc_t;
d75 1
a75 1
 * Masks for the "length" field of struct hifn_desc.
d77 4
a80 4
#define HIFN_D_MASKDONEIRQ	(0x1 << 25)
#define HIFN_D_LAST		(0x1 << 29)
#define HIFN_D_JUMP		(0x1 << 30)
#define HIFN_D_VALID		(0x1 << 31)
d83 1
a83 1
 * hifn_callback_t 
d87 1
a87 1
typedef void (*hifn_callback_t)(hifn_command_t *);
d92 1
a92 1
struct hifn_dma {
d97 4
a100 4
	struct hifn_desc	cmdr[HIFN_D_RSIZE+1];
	struct hifn_desc	srcr[HIFN_D_RSIZE+1];
	struct hifn_desc	dstr[HIFN_D_RSIZE+1];
	struct hifn_desc	resr[HIFN_D_RSIZE+1];
d102 1
a102 1
	struct hifn_command	*hifn_commands[HIFN_D_RSIZE];
d104 2
a105 2
	u_char	command_bufs[HIFN_D_RSIZE][HIFN_MAX_COMMAND];
	u_char	result_bufs[HIFN_D_RSIZE][HIFN_MAX_RESULT];
d119 1
a119 1
 * Holds data specific to a single HIFN board.
d121 1
a121 1
struct hifn_softc {
d130 1
a130 4
	struct hifn_dma *sc_dma;
	int32_t sc_cid;
	int sc_maxses;
	int sc_ramsize;
d134 1
a134 1
 * Processing Unit Registers (offset from BASEREG0)
d136 6
a141 173
#define	HIFN_0_PUDATA		0x00	/* Processing Unit Data */
#define	HIFN_0_PUCTRL		0x04	/* Processing Unit Control */
#define	HIFN_0_PUISR		0x08	/* Processing Unit Interrupt Status */
#define	HIFN_0_PUCNFG		0x0c	/* Processing Unit Configuration */
#define	HIFN_0_PUIER		0x10	/* Processing Unit Interrupt Enable */
#define	HIFN_0_PUSTAT		0x14	/* Processing Unit Status/Chip ID */
#define	HIFN_0_FIFOSTAT		0x18	/* FIFO Status */
#define	HIFN_0_FIFOCNFG		0x1c	/* FIFO Configuration */
#define	HIFN_0_SPACESIZE	0x20	/* Register space size */

/* Processing Unit Control Register (HIFN_0_PUCTRL) */
#define	HIFN_PUCTRL_CLRSRCFIFO	0x0010	/* clear source fifo */
#define	HIFN_PUCTRL_STOP	0x0008	/* stop pu */
#define	HIFN_PUCTRL_LOCKRAM	0x0004	/* lock ram */
#define	HIFN_PUCTRL_DMAENA	0x0002	/* enable dma */
#define	HIFN_PUCTRL_RESET	0x0001	/* Reset processing unit */

/* Processing Unit Interrupt Status Register (HIFN_0_PUISR) */
#define	HIFN_PUISR_CMDINVAL	0x8000	/* Invalid command interrupt */
#define	HIFN_PUISR_DATAERR	0x4000	/* Data error interrupt */
#define	HIFN_PUISR_SRCFIFO	0x2000	/* Source FIFO ready interrupt */
#define	HIFN_PUISR_DSTFIFO	0x1000	/* Destination FIFO ready interrupt */
#define	HIFN_PUISR_DSTOVER	0x0200	/* Destination overrun interrupt */
#define	HIFN_PUISR_SRCCMD	0x0080	/* Source command interrupt */
#define	HIFN_PUISR_SRCCTX	0x0040	/* Source context interrupt */
#define	HIFN_PUISR_SRCDATA	0x0020	/* Source data interrupt */
#define	HIFN_PUISR_DSTDATA	0x0010	/* Destination data interrupt */
#define	HIFN_PUISR_DSTRESULT	0x0004	/* Destination result interrupt */

/* Processing Unit Configuration Register (HIFN_0_PUCNFG) */
#define	HIFN_PUCNFG_DRAMMASK	0xe000	/* DRAM size mask */
#define	HIFN_PUCNFG_DSZ_256K	0x0000	/* 256k dram */
#define	HIFN_PUCNFG_DSZ_512K	0x2000	/* 512k dram */
#define	HIFN_PUCNFG_DSZ_1M	0x4000	/* 1m dram */
#define	HIFN_PUCNFG_DSZ_2M	0x6000	/* 2m dram */
#define	HIFN_PUCNFG_DSZ_4M	0x8000	/* 4m dram */
#define	HIFN_PUCNFG_DSZ_8M	0xa000	/* 8m dram */
#define	HIFN_PUNCFG_DSZ_16M	0xc000	/* 16m dram */
#define	HIFN_PUCNFG_DSZ_32M	0xe000	/* 32m dram */
#define	HIFN_PUCNFG_DRAMREFRESH	0x1800	/* DRAM refresh rate mask */
#define	HIFN_PUCNFG_DRFR_512	0x0000	/* 512 divisor of ECLK */
#define	HIFN_PUCNFG_DRFR_256	0x0800	/* 256 divisor of ECLK */
#define	HIFN_PUCNFG_DRFR_128	0x1000	/* 128 divisor of ECLK */
#define	HIFN_PUCNFG_TCALLPHASES	0x0200	/* your guess is as good as mine... */
#define	HIFN_PUCNFG_TCDRVTOTEM	0x0100	/* your guess is as good as mine... */
#define	HIFN_PUCNFG_BIGENDIAN	0x0080	/* DMA big endian mode */
#define	HIFN_PUCNFG_BUS32	0x0040	/* Bus width 32bits */
#define	HIFN_PUCNFG_BUS16	0x0000	/* Bus width 16 bits */
#define	HIFN_PUCNFG_CHIPID	0x0020	/* Allow chipid from PUSTAT */
#define	HIFN_PUCNFG_DRAM	0x0010	/* Context RAM is DRAM */
#define	HIFN_PUCNFG_SRAM	0x0000	/* Context RAM is SRAM */
#define	HIFN_PUCNFG_COMPSING	0x0004	/* Enable single compression context */
#define	HIFN_PUCNFG_ENCCNFG	0x0002	/* Encryption configuration */

/* Processing Unit Interrupt Enable Register (HIFN_0_PUIER) */
#define	HIFN_PUIER_CMDINVAL	0x8000	/* Invalid command interrupt */
#define	HIFN_PUIER_DATAERR	0x4000	/* Data error interrupt */
#define	HIFN_PUIER_SRCFIFO	0x2000	/* Source FIFO ready interrupt */
#define	HIFN_PUIER_DSTFIFO	0x1000	/* Destination FIFO ready interrupt */
#define	HIFN_PUIER_DSTOVER	0x0200	/* Destination overrun interrupt */
#define	HIFN_PUIER_SRCCMD	0x0080	/* Source command interrupt */
#define	HIFN_PUIER_SRCCTX	0x0040	/* Source context interrupt */
#define	HIFN_PUIER_SRCDATA	0x0020	/* Source data interrupt */
#define	HIFN_PUIER_DSTDATA	0x0010	/* Destination data interrupt */
#define	HIFN_PUIER_DSTRESULT	0x0004	/* Destination result interrupt */

/* Processing Unit Status Register/Chip ID (HIFN_0_PUSTAT) */
#define	HIFN_PUSTAT_CMDINVAL	0x8000	/* Invalid command interrupt */
#define	HIFN_PUSTAT_DATAERR	0x4000	/* Data error interrupt */
#define	HIFN_PUSTAT_SRCFIFO	0x2000	/* Source FIFO ready interrupt */
#define	HIFN_PUSTAT_DSTFIFO	0x1000	/* Destination FIFO ready interrupt */
#define	HIFN_PUSTAT_DSTOVER	0x0200	/* Destination overrun interrupt */
#define	HIFN_PUSTAT_SRCCMD	0x0080	/* Source command interrupt */
#define	HIFN_PUSTAT_SRCCTX	0x0040	/* Source context interrupt */
#define	HIFN_PUSTAT_SRCDATA	0x0020	/* Source data interrupt */
#define	HIFN_PUSTAT_DSTDATA	0x0010	/* Destination data interrupt */
#define	HIFN_PUSTAT_DSTRESULT	0x0004	/* Destination result interrupt */
#define	HIFN_PUSTAT_CHIPREV	0x00ff	/* Chip revision mask */
#define	HIFN_PUSTAT_CHIPENA	0xff00	/* Chip enabled mask */
#define	HIFN_PUSTAT_ENA_2	0x1100	/* Level 2 enabled */
#define	HIFN_PUSTAT_ENA_1	0x1000	/* Level 1 enabled */
#define	HIFN_PUSTAT_ENA_0	0x3000	/* Level 0 enabled */
#define	HIFN_PUSTAT_REV_2	0x0020	/* 7751 PT6/2 */
#define	HIFN_PUSTAT_REV_3	0x0030	/* 7751 PT6/3 */

/* FIFO Status Register (HIFN_0_FIFOSTAT) */
#define	HIFN_FIFOSTAT_SRC	0x7f00	/* Source FIFO available */
#define	HIFN_FIFOSTAT_DST	0x007f	/* Destination FIFO available */

/* FIFO Configuration Register (HIFN_0_FIFOCNFG) */
#define	HIFN_FIFOCNFG_THRESHOLD	0x0400	/* must be written as 1 */

/*
 * DMA Interface Registers (offset from BASEREG1)
 */
#define	HIFN_1_DMA_CRAR		0x0c	/* DMA Command Ring Address */
#define	HIFN_1_DMA_SRAR		0x1c	/* DMA Source Ring Address */
#define	HIFN_1_DMA_RRAR		0x2c	/* DMA Resultt Ring Address */
#define	HIFN_1_DMA_DRAR		0x3c	/* DMA Destination Ring Address */
#define	HIFN_1_DMA_CSR		0x40	/* DMA Status and Control */
#define	HIFN_1_DMA_IER		0x44	/* DMA Interrupt Enable */
#define	HIFN_1_DMA_CNFG		0x48	/* DMA Configuration */
#define	HIFN_1_REVID		0x98	/* Revision ID */

/* DMA Status and Control Register (HIFN_1_DMA_CSR) */
#define	HIFN_DMACSR_D_CTRLMASK	0xc0000000	/* Destinition Ring Control */
#define	HIFN_DMACSR_D_CTRL_NOP	0x00000000	/* Dest. Control: no-op */
#define	HIFN_DMACSR_D_CTRL_DIS	0x40000000	/* Dest. Control: disable */
#define	HIFN_DMACSR_D_CTRL_ENA	0x80000000	/* Dest. Control: enable */
#define	HIFN_DMACSR_D_ABORT	0x20000000	/* Destinition Ring PCIAbort */
#define	HIFN_DMACSR_D_DONE	0x10000000	/* Destinition Ring Done */
#define	HIFN_DMACSR_D_LAST	0x08000000	/* Destinition Ring Last */
#define	HIFN_DMACSR_D_WAIT	0x04000000	/* Destinition Ring Waiting */
#define	HIFN_DMACSR_D_OVER	0x02000000	/* Destinition Ring Overflow */
#define	HIFN_DMACSR_R_CTRL	0x00c00000	/* Result Ring Control */
#define	HIFN_DMACSR_R_CTRL_NOP	0x00000000	/* Result Control: no-op */
#define	HIFN_DMACSR_R_CTRL_DIS	0x00400000	/* Result Control: disable */
#define	HIFN_DMACSR_R_CTRL_ENA	0x00800000	/* Result Control: enable */
#define	HIFN_DMACSR_R_ABORT	0x00200000	/* Result Ring PCI Abort */
#define	HIFN_DMACSR_R_DONE	0x00100000	/* Result Ring Done */
#define	HIFN_DMACSR_R_LAST	0x00080000	/* Result Ring Last */
#define	HIFN_DMACSR_R_WAIT	0x00040000	/* Result Ring Waiting */
#define	HIFN_DMACSR_R_OVER	0x00020000	/* Result Ring Overflow */
#define	HIFN_DMACSR_S_CTRL	0x0000c000	/* Source Ring Control */
#define	HIFN_DMACSR_S_CTRL_NOP	0x00000000	/* Source Control: no-op */
#define	HIFN_DMACSR_S_CTRL_DIS	0x00004000	/* Source Control: disable */
#define	HIFN_DMACSR_S_CTRL_ENA	0x00008000	/* Source Control: enable */
#define	HIFN_DMACSR_S_ABORT	0x00002000	/* Source Ring PCI Abort */
#define	HIFN_DMACSR_S_DONE	0x00001000	/* Source Ring Done */
#define	HIFN_DMACSR_S_LAST	0x00000800	/* Source Ring Last */
#define	HIFN_DMACSR_S_WAIT	0x00000400	/* Source Ring Waiting */
#define	HIFN_DMACSR_S_OVER	0x00000200	/* Source Ring Overflow */
#define	HIFN_DMACSR_C_CTRL	0x000000c0	/* Command Ring Control */
#define	HIFN_DMACSR_C_CTRL_NOP	0x00000000	/* Command Control: no-op */
#define	HIFN_DMACSR_C_CTRL_DIS	0x00000040	/* Command Control: disable */
#define	HIFN_DMACSR_C_CTRL_ENA	0x00000080	/* Command Control: enable */
#define	HIFN_DMACSR_C_ABORT	0x00000020	/* Command Ring PCI Abort */
#define	HIFN_DMACSR_C_DONE	0x00000010	/* Command Ring Done */
#define	HIFN_DMACSR_C_LAST	0x00000008	/* Command Ring Last */
#define	HIFN_DMACSR_C_WAIT	0x00000004	/* Command Ring Waiting */
#define	HIFN_DMACSR_C_EIRQ	0x00000001	/* Command Ring Engine IRQ */

/* DMA Interrupt Enable Register (HIFN_1_DMA_IER) */
#define	HIFN_DMAIER_D_ABORT	0x20000000	/* Destination Ring PCIAbort */
#define	HIFN_DMAIER_D_DONE	0x10000000	/* Destination Ring Done */
#define	HIFN_DMAIER_D_LAST	0x08000000	/* Destination Ring Last */
#define	HIFN_DMAIER_D_WAIT	0x04000000	/* Destination Ring Waiting */
#define	HIFN_DMAIER_D_OVER	0x02000000	/* Destination Ring Overflow */
#define	HIFN_DMAIER_R_ABORT	0x00200000	/* Result Ring PCI Abort */
#define	HIFN_DMAIER_R_DONE	0x00100000	/* Result Ring Done */
#define	HIFN_DMAIER_R_LAST	0x00080000	/* Result Ring Last */
#define	HIFN_DMAIER_R_WAIT	0x00040000	/* Result Ring Waiting */
#define	HIFN_DMAIER_R_OVER	0x00020000	/* Result Ring Overflow */
#define	HIFN_DMAIER_S_ABORT	0x00002000	/* Source Ring PCI Abort */
#define	HIFN_DMAIER_S_DONE	0x00001000	/* Source Ring Done */
#define	HIFN_DMAIER_S_LAST	0x00000800	/* Source Ring Last */
#define	HIFN_DMAIER_S_WAIT	0x00000400	/* Source Ring Waiting */
#define	HIFN_DMAIER_S_OVER	0x00000200	/* Source Ring Overflow */
#define	HIFN_DMAIER_C_ABORT	0x00000020	/* Command Ring PCI Abort */
#define	HIFN_DMAIER_C_DONE	0x00000010	/* Command Ring Done */
#define	HIFN_DMAIER_C_LAST	0x00000008	/* Command Ring Last */
#define	HIFN_DMAIER_C_WAIT	0x00000004	/* Command Ring Waiting */
#define	HIFN_DMAIER_ENGINE	0x00000001	/* Engine IRQ */

/* DMA Configuration Register (HIFN_1_DMA_CNFG) */
#define	HIFN_DMACNFG_BIGENDIAN	0x10000000	/* big endian mode */
#define	HIFN_DMACNFG_POLLFREQ	0x00ff0000	/* Poll frequency mask */
#define	HIFN_DMACNFG_UNLOCK	0x00000800
#define	HIFN_DMACNFG_POLLINVAL	0x00000700	/* Invalid Poll Scalar */
#define	HIFN_DMACNFG_LAST	0x00000010	/* Host control LAST bit */
#define	HIFN_DMACNFG_MODE	0x00000004	/* DMA mode */
#define	HIFN_DMACNFG_DMARESET	0x00000002	/* DMA Reset # */
#define	HIFN_DMACNFG_MSTRESET	0x00000001	/* Master Reset # */
d151 12
a162 3

#define	HIFN_UNLOCK_SECRET1	0xf4
#define	HIFN_UNLOCK_SECRET2	0xfc
d169 59
d236 1
a236 1
typedef struct hifn_base_command {
d241 1
a241 1
} hifn_base_command_t;
d243 3
a245 3
#define HIFN_BASE_CMD_MAC    (0x1 << 10)
#define HIFN_BASE_CMD_CRYPT  (0x1 << 11)
#define HIFN_BASE_CMD_DECODE (0x1 << 13)
d250 1
a250 1
typedef struct hifn_crypt_command {
d254 1
a254 1
} hifn_crypt_command_t;
d256 6
a261 6
#define HIFN_CRYPT_CMD_ALG_MASK  (0x3 << 0)
#define HIFN_CRYPT_CMD_ALG_DES   (0x0 << 0)
#define HIFN_CRYPT_CMD_ALG_3DES  (0x1 << 0)
#define HIFN_CRYPT_CMD_MODE_CBC  (0x1 << 3)
#define HIFN_CRYPT_CMD_NEW_KEY   (0x1 << 11)
#define HIFN_CRYPT_CMD_NEW_IV    (0x1 << 12)
d266 1
a266 1
typedef struct hifn_mac_command {
d270 1
a270 1
} hifn_mac_command_t;
d272 5
a276 5
#define HIFN_MAC_CMD_ALG_MD5    (0x1 << 0)
#define HIFN_MAC_CMD_ALG_SHA1   (0x0 << 0)
#define HIFN_MAC_CMD_MODE_HMAC  (0x0 << 2)
#define HIFN_MAC_CMD_TRUNC      (0x1 << 4)
#define HIFN_MAC_CMD_APPEND     (0x1 << 6)
d281 2
a282 2
#define HIFN_MAC_CMD_POS_IPSEC  (0x2 << 8)
#define HIFN_MAC_CMD_NEW_KEY    (0x1 << 11)
d289 4
a292 4
typedef struct hifn_command_buf_data {
	hifn_base_command_t base_cmd;
	hifn_mac_command_t mac_cmd;
	hifn_crypt_command_t crypt_cmd;
d296 7
a302 1
} hifn_command_buf_data_t;
d308 2
a309 2
#ifndef HIFN_POLL_FREQUENCY
#define HIFN_POLL_FREQUENCY  0x1
d312 2
a313 2
#ifndef HIFN_POLL_SCALAR
#define HIFN_POLL_SCALAR    0x0
d316 1
a316 1
#endif /* __HIFN_H__ */
@


1.4.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.17 2000/12/12 21:30:34 jason Exp $	*/
a5 3
 * Copyright (c) 1999 Theo de Raadt
 * Copyright (c) 2000 Network Security Technologies, Inc.
 *			http://www.netsec.net
d43 2
a44 2
#define HIFN_BAR0		(PCI_MAPREG_START + 0)	/* PUC register map */
#define HIFN_BAR1		(PCI_MAPREG_START + 4)	/* DMA register map */
d49 3
a59 6
 *
 * MAX_COMMAND = base command + mac command + encrypt command +
 *			mac-key + des-iv + 3des-key
 * MAX_RESULT  = base result + mac result + mac + encrypt result
 *			
 *
d61 2
a62 2
#define HIFN_MAX_COMMAND	(8 + 8 + 8 + 64 + 8 + 24)
#define HIFN_MAX_RESULT		(8 + 4 + 20 + 4)
d77 11
a87 7
#define HIFN_D_LENGTH		0x0000ffff	/* length bit mask */
#define	HIFN_D_MASKDONEIRQ	0x02000000	/* mask the done interrupt */
#define	HIFN_D_DESTOVER		0x04000000	/* destination overflow */
#define	HIFN_D_OVER		0x08000000	/* overflow */
#define	HIFN_D_LAST		0x20000000	/* last descriptor in chain */
#define	HIFN_D_JUMP		0x40000000	/* jump descriptor */
#define	HIFN_D_VALID		0x80000000	/* valid bit */
d97 4
a100 4
	struct hifn_desc	cmdr[HIFN_D_CMD_RSIZE+1];
	struct hifn_desc	srcr[HIFN_D_SRC_RSIZE+1];
	struct hifn_desc	dstr[HIFN_D_DST_RSIZE+1];
	struct hifn_desc	resr[HIFN_D_RES_RSIZE+1];
d102 1
a102 1
	struct hifn_command	*hifn_commands[HIFN_D_RES_RSIZE];
d104 2
a105 2
	u_char	command_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_COMMAND];
	u_char	result_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_RESULT];
a112 2
	int		cmdk, srck, dstk, resk;
};
d114 2
a115 3
struct hifn_session {
	int hs_flags;
	u_int8_t hs_iv[HIFN_IV_LENGTH];
a123 1
	u_int32_t	sc_dmaier;
a133 1
	struct hifn_session sc_sessions[2048];
d236 1
a236 1
#define	HIFN_1_DMA_RRAR		0x2c	/* DMA Result Ring Address */
d339 4
a342 4
	volatile u_int16_t masks;
	volatile u_int16_t session_num;
	volatile u_int16_t total_source_count;
	volatile u_int16_t total_dest_count;
d345 3
a347 3
#define HIFN_BASE_CMD_MAC		(0x1 << 10)
#define HIFN_BASE_CMD_CRYPT		(0x1 << 11)
#define HIFN_BASE_CMD_DECODE		(0x1 << 13)
d353 3
a355 3
	volatile u_int16_t masks;
	volatile u_int16_t header_skip;
	volatile u_int32_t source_count;
d358 6
a363 6
#define HIFN_CRYPT_CMD_ALG_MASK		(0x3 << 0)
#define HIFN_CRYPT_CMD_ALG_DES		(0x0 << 0)
#define HIFN_CRYPT_CMD_ALG_3DES		(0x1 << 0)
#define HIFN_CRYPT_CMD_MODE_CBC		(0x1 << 3)
#define HIFN_CRYPT_CMD_NEW_KEY		(0x1 << 11)
#define HIFN_CRYPT_CMD_NEW_IV		(0x1 << 12)
d369 3
a371 3
	volatile u_int16_t masks;
	volatile u_int16_t header_skip;
	volatile u_int32_t source_count;
d374 5
a378 6
#define HIFN_MAC_CMD_ALG_MD5		(0x1 << 0)
#define HIFN_MAC_CMD_ALG_SHA1		(0x0 << 0)
#define HIFN_MAC_CMD_MODE_HMAC		(0x0 << 2)
#define HIFN_MAC_CMD_TRUNC		(0x1 << 4)
#define HIFN_MAC_CMD_RESULT		(0x1 << 5)
#define HIFN_MAC_CMD_APPEND		(0x1 << 6)
d383 16
a398 2
#define HIFN_MAC_CMD_POS_IPSEC		(0x2 << 8)
#define HIFN_MAC_CMD_NEW_KEY		(0x1 << 11)
d405 1
a405 1
#define HIFN_POLL_FREQUENCY	0x1
d409 1
a409 1
#define HIFN_POLL_SCALAR	0x0
@


1.4.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.4.2.2 2001/05/14 22:25:42 niklas Exp $	*/
d7 1
a7 1
 * Copyright (c) 2000-2001 Network Security Technologies, Inc.
d50 8
d67 2
a68 2
#define	HIFN_MAX_COMMAND	(8 + 8 + 8 + 64 + 8 + 24)
#define	HIFN_MAX_RESULT		(8 + 4 + 20 + 4)
d83 1
a83 1
#define	HIFN_D_LENGTH		0x0000ffff	/* length bit mask */
d91 51
a249 11
#define	HIFN_1_PUB_RESET	0x204	/* Public/RNG Reset */
#define	HIFN_1_PUB_BASE		0x300	/* Public Base Address */
#define	HIFN_1_PUB_OPLEN	0x304	/* Public Operand Length */
#define	HIFN_1_PUB_OP		0x308	/* Public Operand */
#define	HIFN_1_PUB_STATUS	0x30c	/* Public Status */
#define	HIFN_1_PUB_IEN		0x310	/* Public Interrupt nable */
#define	HIFN_1_RNG_CONFIG	0x314	/* RNG config */
#define	HIFN_1_RNG_DATA		0x318	/* RNG data */
#define	HIFN_1_PUB_MEM		0x400	/* start of Public key memory */
#define	HIFN_1_PUB_MEMEND	0xbff	/* end of Public key memory */

a285 1
#define	HIFN_DMACSR_PUBDONE	0x00000002	/* Public op done (7951 only) */
a307 1
#define	HIFN_DMAIER_PUBDONE	0x00000002	/* public op done (7951 only */
d320 4
a323 36
/* Public key reset register (HIFN_1_PUB_RESET) */
#define	HIFN_PUBRST_RESET	0x00000001	/* reset public/rng unit */

/* Public operation register (HIFN_1_PUB_OP) */
#define	HIFN_PUBOP_AOFFSET	0x0000003e	/* A offset */
#define	HIFN_PUBOP_BOFFSET	0x00000fc0	/* B offset */
#define	HIFN_PUBOP_MOFFSET	0x0003f000	/* M offset */
#define	HIFN_PUBOP_OP_MASK	0x003c0000	/* Opcode: */
#define	HIFN_PUBOP_OP_NOP	0x00000000	/*  NOP */
#define	HIFN_PUBOP_OP_ADD	0x00040000	/*  ADD */
#define	HIFN_PUBOP_OP_ADDC	0x00080000	/*  ADD w/carry */
#define	HIFN_PUBOP_OP_SUB	0x000c0000	/*  SUB */
#define	HIFN_PUBOP_OP_SUBC	0x00100000	/*  SUB w/carry */
#define	HIFN_PUBOP_OP_MODADD	0x00140000	/*  Modular ADD */
#define	HIFN_PUBOP_OP_MODSUB	0x00180000	/*  Modular SUB */
#define	HIFN_PUBOP_OP_INCA	0x001c0000	/*  INC A */
#define	HIFN_PUBOP_OP_DECA	0x00200000	/*  DEC A */
#define	HIFN_PUBOP_OP_MULT	0x00240000	/*  MULT */
#define	HIFN_PUBOP_OP_MODMULT	0x00280000	/*  Modular MULT */
#define	HIFN_PUBOP_OP_MODRED	0x002c0000	/*  Modular Red */
#define	HIFN_PUBOP_OP_MODEXP	0x00300000	/*  Modular Exp */

/* Public operand length register (HIFN_1_PUB_OPLEN) */
#define	HIFN_PUBOPLEN_MODLEN	0x0000007f
#define	HIFN_PUBOPLEN_EXPLEN	0x0003ff80
#define	HIFN_PUBOPLEN_REDLEN	0x003c0000

/* Public status register (HIFN_1_PUB_STATUS) */
#define	HIFN_PUBSTS_DONE	0x00000001	/* operation done */
#define	HIFN_PUBSTS_CARRY	0x00000002	/* carry */

/* Public interrupt enable register (HIFN_1_PUB_IEN) */
#define	HIFN_PUBIEN_DONE	0x00000001	/* operation done interrupt */

/* Random number generator config register (HIFN_1_RNG_CONFIG) */
#define	HIFN_RNGCFG_ENA		0x00000001	/* enable rng */
d332 1
a332 1
#define	WRITE_REG_1(sc,reg,val)	\
d334 1
a334 1
#define	READ_REG_1(sc,reg) \
d352 3
a354 9
#define	HIFN_BASE_CMD_MAC		0x0400
#define	HIFN_BASE_CMD_CRYPT		0x0800
#define	HIFN_BASE_CMD_DECODE		0x2000
#define	HIFN_BASE_CMD_SRCLEN_M		0xc000
#define	HIFN_BASE_CMD_SRCLEN_S		14
#define	HIFN_BASE_CMD_DSTLEN_M		0x3000
#define	HIFN_BASE_CMD_DSTLEN_S		12
#define	HIFN_BASE_CMD_LENMASK_HI	0x30000
#define	HIFN_BASE_CMD_LENMASK_LO	0x0ffff
d362 1
a362 2
	volatile u_int16_t source_count;
	volatile u_int16_t reserved;
d365 6
a370 15
#define	HIFN_CRYPT_CMD_ALG_MASK		0x0003		/* algorithm: */
#define	HIFN_CRYPT_CMD_ALG_DES		0x0000		/*   DES */
#define	HIFN_CRYPT_CMD_ALG_3DES		0x0001		/*   3DES */
#define	HIFN_CRYPT_CMD_ALG_RC4		0x0002		/*   RC4 */
#define	HIFN_CRYPT_CMD_MODE_MASK	0x0018		/* DES mode: */
#define	HIFN_CRYPT_CMD_MODE_ECB		0x0000		/*   ECB */
#define	HIFN_CRYPT_CMD_MODE_CBC		0x0008		/*   CBC */
#define	HIFN_CRYPT_CMD_MODE_CFB		0x0010		/*   CFB */
#define	HIFN_CRYPT_CMD_MODE_OFB		0x0018		/*   OFB */
#define	HIFN_CRYPT_CMD_CLR_CTX		0x0040		/* clear context */
#define	HIFN_CRYPT_CMD_NEW_KEY		0x0800		/* expect new key */
#define	HIFN_CRYPT_CMD_NEW_IV		0x1000		/* expect new iv */

#define	HIFN_CRYPT_CMD_SRCLEN_M		0xc000
#define	HIFN_CRYPT_CMD_SRCLEN_S		14
d378 1
a378 2
	volatile u_int16_t source_count;
	volatile u_int16_t reserved;
d381 6
a386 12
#define	HIFN_MAC_CMD_ALG_MASK		0x0001
#define	HIFN_MAC_CMD_ALG_SHA1		0x0000
#define	HIFN_MAC_CMD_ALG_MD5		0x0001
#define	HIFN_MAC_CMD_MODE_MASK		0x0004
#define	HIFN_MAC_CMD_MODE_HMAC		0x0000
#define	HIFN_MAC_CMD_MODE_FULL		0x0004
#define	HIFN_MAC_CMD_TRUNC		0x0010
#define	HIFN_MAC_CMD_RESULT		0x0020
#define	HIFN_MAC_CMD_APPEND		0x0040
#define	HIFN_MAC_CMD_SRCLEN_M		0xc000
#define	HIFN_MAC_CMD_SRCLEN_S		14

d388 1
a388 1
 * MAC POS IPsec initiates authentication after encryption on encodes
d391 2
a392 2
#define	HIFN_MAC_CMD_POS_IPSEC		0x0200
#define	HIFN_MAC_CMD_NEW_KEY		0x0800
d399 1
a399 1
#define	HIFN_POLL_FREQUENCY	0x1
d403 1
a403 1
#define	HIFN_POLL_SCALAR	0x0
a405 2
#define	HIFN_MAX_SEGLEN 	0xffff		/* maximum dma segment len */
#define	HIFN_MAX_DMALEN		0x3ffff		/* maximum dma length */
@


1.4.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.4.2.3 2001/07/04 10:42:07 niklas Exp $	*/
d4 1
a4 1
 * Invertex AEON / Hifn 7751 driver
d54 1
a54 1
 *			mac-key + rc4-key
d59 1
a59 1
#define	HIFN_MAX_COMMAND	(8 + 8 + 8 + 64 + 260)
d387 1
a387 1
#define	HIFN_MAC_CMD_MODE_MASK		0x000c
a388 2
#define	HIFN_MAC_CMD_MODE_SSL_MAC	0x0004
#define	HIFN_MAC_CMD_MODE_HASH		0x0008
@


1.4.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
#define	__HIFN_H__
d46 2
a47 4
#define	HIFN_BAR0		(PCI_MAPREG_START + 0)	/* PUC register map */
#define	HIFN_BAR1		(PCI_MAPREG_START + 4)	/* DMA register map */
#define	HIFN_RETRY_TIMEOUT	0x40
#define	HIFN_TRDY_TIMEOUT	0x41
@


1.4.2.6
log
@Merge in trunk
@
text
@a190 5
#define	HIFN_1_7811_RNGENA	0x60	/* 7811: rng enable */
#define	HIFN_1_7811_RNGCFG	0x64	/* 7811: rng config */
#define	HIFN_1_7811_RNGDAT	0x68	/* 7811: rng data */
#define	HIFN_1_7811_RNGSTS	0x6c	/* 7811: rng status */
#define	HIFN_1_7811_MIPSRST	0x94	/* 7811: MIPS reset */
d231 1
a231 2
#define	HIFN_DMACSR_ILLW	0x00000200	/* Illegal write (7811 only) */
#define	HIFN_DMACSR_ILLR	0x00000100	/* Illegal read (7811 only) */
d241 1
a241 1
#define	HIFN_DMACSR_ENGINE	0x00000001	/* Command Ring Engine IRQ */
d258 1
a258 2
#define	HIFN_DMAIER_ILLW	0x00000200	/* Illegal write (7811 only) */
#define	HIFN_DMAIER_ILLR	0x00000100	/* Illegal read (7811 only) */
d263 1
a263 1
#define	HIFN_DMAIER_PUBDONE	0x00000002	/* public op done (7951 only) */
a274 23

/* 7811 RNG Enable Register (HIFN_1_7811_RNGENA) */
#define	HIFN_7811_RNGENA_ENA	0x00000001	/* enable RNG */

/* 7811 RNG Config Register (HIFN_1_7811_RNGCFG) */
#define	HIFN_7811_RNGCFG_PRE1	0x00000f00	/* first prescalar */
#define	HIFN_7811_RNGCFG_OPRE	0x00000080	/* output prescalar */
#define	HIFN_7811_RNGCFG_DEFL	0x00000f80	/* 2 words/ 1/100 sec */

/* 7811 RNG Status Register (HIFN_1_7811_RNGSTS) */
#define	HIFN_7811_RNGSTS_RDY	0x00004000	/* two numbers in FIFO */
#define	HIFN_7811_RNGSTS_UFL	0x00001000	/* rng underflow */

/* 7811 MIPS Reset Register (HIFN_1_7811_MIPSRST) */
#define	HIFN_MIPSRST_BAR2SIZE	0xffff0000	/* sdram size */
#define	HIFN_MIPSRST_GPRAMINIT	0x00008000	/* gpram can be accessed */
#define	HIFN_MIPSRST_CRAMINIT	0x00004000	/* ctxram can be accessed */
#define	HIFN_MIPSRST_LED2	0x00000400	/* external LED2 */
#define	HIFN_MIPSRST_LED1	0x00000200	/* external LED1 */
#define	HIFN_MIPSRST_LED0	0x00000100	/* external LED0 */
#define	HIFN_MIPSRST_MIPSDIS	0x00000004	/* disable MIPS */
#define	HIFN_MIPSRST_MIPSRST	0x00000002	/* warm reset MIPS */
#define	HIFN_MIPSRST_MIPSCOLD	0x00000001	/* cold reset MIPS */
@


1.4.2.7
log
@Sync the SMP branch with 3.3
@
text
@a35 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d48 2
a49 2
#define	HIFN_RETRY_TIMEOUT	0x41
#define	HIFN_TRDY_TIMEOUT	0x40
d57 1
a57 1
 * MAX_RESULT  = base result + comp result + mac result + mac + encrypt result
d62 1
a62 1
#define	HIFN_MAX_RESULT		(8 + 4 + 4 + 20 + 4)
d69 1
a69 1
struct hifn_desc {
d72 1
a72 1
};
d85 1
d197 1
a197 2
#define	HIFN_1_UNLOCK_SECRET1	0xf4
#define	HIFN_1_UNLOCK_SECRET2	0xfc
d203 1
a203 1
#define	HIFN_1_PUB_IEN		0x310	/* Public Interrupt enable */
a305 3
/* Revision ID */
#define	HIFN_REVID_7811_PB3_2	0x00000002	/* 7811PB3/2 */

a308 11
/* Public base address register (HIFN_1_PUB_BASE) */
#define	HIFN_PUBBASE_ADDR	0x00003fff	/* base address */

/* Public operand length register (HIFN_1_PUB_OPLEN) */
#define	HIFN_PUBOPLEN_MOD_M	0x0000007f	/* modulus length mask */
#define	HIFN_PUBOPLEN_MOD_S	0		/* modulus length shift */
#define	HIFN_PUBOPLEN_EXP_M	0x0003ff80	/* exponent length mask */
#define	HIFN_PUBOPLEN_EXP_S	7		/* exponent lenght shift */
#define	HIFN_PUBOPLEN_RED_M	0x003c0000	/* reducend length mask */
#define	HIFN_PUBOPLEN_RED_S	18		/* reducend length shift */

d310 3
a312 6
#define	HIFN_PUBOP_AOFFSET_M	0x0000007f	/* A offset mask */
#define	HIFN_PUBOP_AOFFSET_S	0		/* A offset shift */
#define	HIFN_PUBOP_BOFFSET_M	0x00000f80	/* B offset mask */
#define	HIFN_PUBOP_BOFFSET_S	7		/* B offset shift */
#define	HIFN_PUBOP_MOFFSET_M	0x0003f000	/* M offset mask */
#define	HIFN_PUBOP_MOFFSET_S	12		/* M offset shift */
d325 7
a331 2
#define	HIFN_PUBOP_OP_MODRED	0x002c0000	/*  Modular RED */
#define	HIFN_PUBOP_OP_MODEXP	0x00300000	/*  Modular EXP */
d343 12
d363 1
a363 1
struct hifn_base_command {
d368 1
a368 1
};
d370 2
a371 4
#define	HIFN_BASE_CMD_COMP		0x0100	/* enable compression engine */
#define	HIFN_BASE_CMD_PAD		0x0200	/* enable padding engine */
#define	HIFN_BASE_CMD_MAC		0x0400	/* enable MAC engine */
#define	HIFN_BASE_CMD_CRYPT		0x0800	/* enable crypt engine */
d383 1
a383 1
struct hifn_crypt_command {
d388 1
a388 1
};
d409 1
a409 1
struct hifn_mac_command {
d414 1
a414 1
};
a435 58

struct hifn_comp_command {
	volatile u_int16_t masks;
	volatile u_int16_t header_skip;
	volatile u_int16_t source_count;
	volatile u_int16_t reserved;
};

#define	HIFN_COMP_CMD_SRCLEN_M		0xc000
#define	HIFN_COMP_CMD_SRCLEN_S		14
#define	HIFN_COMP_CMD_ONE		0x0100	/* must be one */
#define	HIFN_COMP_CMD_CLEARHIST		0x0010	/* clear history */
#define	HIFN_COMP_CMD_UPDATEHIST	0x0008	/* update history */
#define	HIFN_COMP_CMD_LZS_STRIP0	0x0004	/* LZS: strip zero */
#define	HIFN_COMP_CMD_MPPC_RESTART	0x0004	/* MPPC: restart */
#define	HIFN_COMP_CMD_ALG_MASK		0x0001	/* compression mode: */
#define	HIFN_COMP_CMD_ALG_MPPC		0x0001	/*   MPPC */
#define	HIFN_COMP_CMD_ALG_LZS		0x0000	/*   LZS */

struct hifn_base_result {
	volatile u_int16_t flags;
	volatile u_int16_t session;
	volatile u_int16_t src_cnt;		/* 15:0 of source count */
	volatile u_int16_t dst_cnt;		/* 15:0 of dest count */
};

#define	HIFN_BASE_RES_DSTOVERRUN	0x0200	/* destination overrun */
#define	HIFN_BASE_RES_SRCLEN_M		0xc000	/* 17:16 of source count */
#define	HIFN_BASE_RES_SRCLEN_S		14
#define	HIFN_BASE_RES_DSTLEN_M		0x3000	/* 17:16 of dest count */
#define	HIFN_BASE_RES_DSTLEN_S		12

struct hifn_comp_result {
	volatile u_int16_t flags;
	volatile u_int16_t crc;
};

#define	HIFN_COMP_RES_LCB_M		0xff00	/* longitudinal check byte */
#define	HIFN_COMP_RES_LCB_S		8
#define	HIFN_COMP_RES_RESTART		0x0004	/* MPPC: restart */
#define	HIFN_COMP_RES_ENDMARKER		0x0002	/* LZS: end marker seen */
#define	HIFN_COMP_RES_SRC_NOTZERO	0x0001	/* source expired */

struct hifn_mac_result {
	volatile u_int16_t flags;
	volatile u_int16_t reserved;
	/* followed by 0, 6, 8, or 10 u_int16_t's of the MAC, then crypt */
};

#define	HIFN_MAC_RES_MISCOMPARE		0x0002	/* compare failed */
#define	HIFN_MAC_RES_SRC_NOTZERO	0x0001	/* source expired */

struct hifn_crypt_result {
	volatile u_int16_t flags;
	volatile u_int16_t reserved;
};

#define	HIFN_CRYPT_RES_SRC_NOTZERO	0x0001	/* source expired */
@


1.4.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751reg.h,v 1.4.2.7 2003/03/28 00:38:21 niklas Exp $	*/
d24 1
@


1.4.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a193 1
#define	HIFN_1_PLL		0x4c	/* 795x: PLL config */
a309 3
/* PLL config register (HIFN_1_PLL) */
#define	HIFN_PLL_7956		0x00001d18	/* 7956 PLL config value */

d400 1
a400 2
#define	HIFN_CRYPT_CMD_ALG_AES		0x0003		/*   AES */
#define	HIFN_CRYPT_CMD_MODE_MASK	0x0018		/* Encrypt mode: */
a405 4
#define	HIFN_CRYPT_CMD_KSZ_MASK		0x0600		/* AES key size: */
#define	HIFN_CRYPT_CMD_KSZ_128		0x0000		/*  128 bit */
#define	HIFN_CRYPT_CMD_KSZ_192		0x0200		/*  192 bit */
#define	HIFN_CRYPT_CMD_KSZ_256		0x0400		/*  256 bit */
d408 1
@


1.3
log
@handle scatter-gather, seperate src/dst mbuf, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: aeonreg.h,v 1.2 1999/02/21 00:05:14 deraadt Exp $	*/
d128 1
@


1.2
log
@use src/dst descriptor chaining out of an mbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: aeonreg.h,v 1.1 1999/02/19 02:52:20 deraadt Exp $	*/
d51 5
@


1.1
log
@invertex aeon driver base
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 2
a50 2
#define AEON_DESCRIPT_RING_SIZE  24
#define AEON_MAX_DEVICES          4
d56 2
a57 2
#define AEON_MAX_COMMAND_LENGTH 120
#define AEON_MAX_RESULT_LENGTH   16
d60 1
a60 1
 * aeon_descriptor_t
d64 4
a67 4
typedef struct aeon_descriptor {
	volatile u_int32_t length;  /* length and status bits */
	volatile u_int32_t pointer;
} aeon_descriptor_t;
d70 6
a75 6
 * Masks for the "length" field of struct aeon_descriptor.
 */
#define AEON_DESCRIPT_MASK_DONE_IRQ (0x1 << 25)
#define AEON_DESCRIPT_LAST          (0x1 << 29)
#define AEON_DESCRIPT_JUMP          (0x1 << 30)
#define AEON_DESCRIPT_VALID         (0x1 << 31)
d92 4
a95 4
	struct aeon_descriptor	command_ring[AEON_DESCRIPT_RING_SIZE + 1];
	struct aeon_descriptor	source_ring[AEON_DESCRIPT_RING_SIZE + 1];
	struct aeon_descriptor	dest_ring[AEON_DESCRIPT_RING_SIZE + 1];
	struct aeon_descriptor	result_ring[AEON_DESCRIPT_RING_SIZE + 1];
d97 1
a97 1
	aeon_command_t	*aeon_commands[AEON_DESCRIPT_RING_SIZE ];
d99 2
a100 2
	u_char	command_bufs[AEON_DESCRIPT_RING_SIZE][AEON_MAX_COMMAND_LENGTH];
	u_char	result_bufs[AEON_DESCRIPT_RING_SIZE][AEON_MAX_RESULT_LENGTH];
d106 4
a109 2
	u_int32_t ring_pos;
	u_int32_t wakeup_ring_pos;
d119 1
a119 1
	u_int32_t is_dram_model;	/* 1=dram, 0=sram */
d121 2
a122 7
	/* Register set 0 */
	bus_space_handle_t	sc_sh0;
	bus_space_tag_t		sc_st0;

	/* Register set 1 */
	bus_space_handle_t	sc_sh1;
	bus_space_tag_t		sc_st1;
d133 1
a133 1
#define AEON_ENCRYPTION_LEVEL		0x14
d145 6
a150 6
#define AEON_COMMAND_RING_ADDR		0x0c
#define AEON_SOURCE_RING_ADDR		0x1c
#define AEON_RESULT_RING_ADDR		0x2c
#define AEON_DEST_RING_ADDR		0x3c
#define	AEON_STATUS			0x40
#define	AEON_INTERRUPT_ENABLE		0x44
d287 3
a289 3
	const u_int8_t *mac_key;
	const u_int8_t *crypt_key;
	const u_int8_t *initial_vector;
@

