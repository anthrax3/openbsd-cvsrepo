head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.34
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.32
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.20
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.28
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.26
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.24
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.22
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.18
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.16
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.14
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.12
	OPENBSD_5_0:1.30.0.10
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.8
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.6
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.28.0.24
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.22
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.20
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.18
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.16
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.14
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.12
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.10
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.8
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.6
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.27.0.4
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.27
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	SMP:1.11.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7;
locks; strict;
comment	@ * @;


1.30
date	2009.03.27.13.31.30;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.25.12.17.30;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.04.16.02.41;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.11.22.40.31;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.03.18.56.50;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.08.20.00.18;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.08.19.41.29;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.08.23.05.28;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.06.20.53.05;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.26.05.06.03;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.26.04.24.17;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.24.21.44.11;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.23.22.16.05;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.19.21.15.37;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.14.00.29.25;	author jason;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.06.29.21.52.42;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.30.02.26.14;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.22.22.53.39;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.13.01.20.02;	author jason;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.02.02.01.00.07;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.29.04.01.44;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.29.00.39.20;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.13.22.06.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.13.22.03.09;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.11.19.38.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.18.03.37.22;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.12.19.50.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.03.13.14.39;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.18.01.25.19;	author jason;	state Exp;
branches;
next	;

1.11.2.1
date	2001.05.14.22.26.00;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.07.04.10.43.13;	author niklas;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.12.05.00.43.31;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2003.06.07.11.02.31;	author ho;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.36;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Add support for the BCM5825 and the next-generation BCM5860, 5861,
5862 Broadcom CryptoNetX IPSec/SSL Security Processors.  The 5825 is a
faster version of the already supported 5823, and the even faster 586x
series is a bit different and needed some more changes.  The RNG
engine on the 586x is not supported yet but I hope to fix it soon...

ubsec0 at pci4 dev 0 function 0 "Broadcom 5862" rev 0x01: 3DES MD5 SHA1 AES PK, apic 10 int 10 (irq 11)

tested by phessler@@ and me
ok deraadt@@
@
text
@/*	$OpenBSD: ubsecreg.h,v 1.27 2002/09/11 22:40:31 jason Exp $	*/

/*
 * Copyright (c) 2000 Theo de Raadt
 * Copyright (c) 2001 Patrik Lindergren (patrik@@ipunplugged.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

/*
 * Register definitions for 5601 BlueSteel Networks Ubiquitous Broadband
 * Security "uBSec" chip.  Definitions from revision 2.8 of the product
 * datasheet.
 */

#define BS_BAR			0x10	/* DMA base address register */
#define	BS_TRDY_TIMEOUT		0x40	/* TRDY timeout */
#define	BS_RETRY_TIMEOUT	0x41	/* DMA retry timeout */

#define	UBS_PCI_RTY_SHIFT			8
#define	UBS_PCI_RTY_MASK			0xff
#define	UBS_PCI_RTY(misc) \
    (((misc) >> UBS_PCI_RTY_SHIFT) & UBS_PCI_RTY_MASK)

#define	UBS_PCI_TOUT_SHIFT			0
#define	UBS_PCI_TOUT_MASK			0xff
#define	UBS_PCI_TOUT(misc) \
    (((misc) >> PCI_TOUT_SHIFT) & PCI_TOUT_MASK)

/*
 * DMA Control & Status Registers (offset from BS_BAR)
 */
#define BS_MCR1		0x0000	/* DMA Master Command Record 1 */
#define BS_CTRL		0x0004	/* DMA Control */
#define BS_STAT		0x0008	/* DMA Status */
#define BS_ERR		0x000c	/* DMA Error Address */
#define BS_MCR2		0x0010	/* DMA Master Command Record 2 */
#define BS_MCR3		0x0014	/* 5827+, DMA Master Command Record 3 */
#define BS_MCR4		0x001c	/* 5827+, DMA Master Command Record 4 */
#define BS_CFG		0x0700	/* 5827+, Configuration Register */
#define BS_INT		0x0f00	/* 5827+, Interrupt Register */

/* BS_CTRL - DMA Control */
#define	BS_CTRL_RESET		0x80000000	/* hardware reset, 5805/5820 */
#define	BS_CTRL_MCR2INT		0x40000000	/* enable intr MCR for MCR2 */
#define	BS_CTRL_MCR1INT		0x20000000	/* enable intr MCR for MCR1 */
#define	BS_CTRL_OFM		0x10000000	/* Output fragment mode */
#define	BS_CTRL_BE32		0x08000000	/* big-endian, 32bit bytes */
#define	BS_CTRL_BE64		0x04000000	/* big-endian, 64bit bytes */
#define	BS_CTRL_DMAERR		0x02000000	/* enable intr DMA error */
#define	BS_CTRL_RNG_M		0x01800000	/* RNG mode */
#define	BS_CTRL_RNG_1		0x00000000	/* 1bit rn/one slow clock */
#define	BS_CTRL_RNG_4		0x00800000	/* 1bit rn/four slow clocks */
#define	BS_CTRL_RNG_8		0x01000000	/* 1bit rn/eight slow clocks */
#define	BS_CTRL_RNG_16		0x01800000	/* 1bit rn/16 slow clocks */
#define	BS_CTRL_SWNORM		0x00400000	/* 582[01], sw normalization */
#define BS_CTRL_MCR3INT		0x00400000	/* 5827+, intr for MCR3 */
#define BS_CTRL_MCR4INT		0x00200000	/* 5827+, intr for MCR4 */
#define BS_CTRL_BSIZE240	0x000f0000	/* 5827+, burst size 240 */
#define	BS_CTRL_FRAG_M		0x0000ffff	/* output fragment size mask */
#define	BS_CTRL_LITTLE_ENDIAN	(BS_CTRL_BE32 | BS_CTRL_BE64)

/* BS_STAT - DMA Status */
#define	BS_STAT_MCR_BUSY	0x80000000	/* MCR is busy */
#define	BS_STAT_MCR1_FULL	0x40000000	/* MCR1 is full */
#define	BS_STAT_MCR1_DONE	0x20000000	/* MCR1 is done */
#define	BS_STAT_DMAERR		0x10000000	/* DMA error */
#define	BS_STAT_MCR2_FULL	0x08000000	/* MCR2 is full */
#define	BS_STAT_MCR2_DONE	0x04000000	/* MCR2 is done */
#define	BS_STAT_MCR1_ALLEMPTY	0x02000000	/* 5821, MCR1 is empty */
#define	BS_STAT_MCR2_ALLEMPTY	0x01000000	/* 5821, MCR2 is empty */
#define	BS_STAT_MCR3_ALLEMPTY	0x00800000	/* 5827+, MCR3 is empty */
#define	BS_STAT_MCR4_ALLEMPTY	0x00400000	/* 5827+, MCR4 is empty */
#define	BS_STAT_MCR3_FULL	0x00080000	/* 5827+, MCR3 is full */
#define	BS_STAT_MCR3_DONE	0x00040000	/* 5827+, MCR3 is done */
#define	BS_STAT_MCR4_FULL	0x00020000	/* 5827+, MCR4 is full */
#define	BS_STAT_MCR4_DONE	0x00010000	/* 5827+, MCR4 is done */

/* BS_ERR - DMA Error Address */
#define	BS_ERR_ADDR		0xfffffffc	/* error address mask */
#define	BS_ERR_READ		0x00000002	/* fault was on read */

/* BS_CFG */
#define BS_CFG_RNG		0x00000001	/* 5827+, enable RNG */

/* BS_INT */
#define BS_INT_DMAINT		0x80000000	/* 5827+, enable DMA intr */

/* DES/3DES */
struct ubsec_pktctx {
	u_int32_t	pc_deskey[6];		/* 3DES key */
	u_int32_t	pc_hminner[5];		/* hmac inner state */
	u_int32_t	pc_hmouter[5];		/* hmac outer state */
	u_int32_t	pc_iv[2];		/* [3]DES iv */
	u_int16_t	pc_flags;		/* flags, below */
	u_int16_t	pc_offset;		/* crypto offset */
};
#define	UBS_PKTCTX_ENC_3DES	0x8000		/* use 3des */
#define	UBS_PKTCTX_ENC_NONE	0x0000		/* no encryption */
#define	UBS_PKTCTX_INBOUND	0x4000		/* inbound packet */
#define	UBS_PKTCTX_AUTH		0x3000		/* authentication mask */
#define	UBS_PKTCTX_AUTH_NONE	0x0000		/* no authentication */
#define	UBS_PKTCTX_AUTH_MD5	0x1000		/* use hmac-md5 */
#define	UBS_PKTCTX_AUTH_SHA1	0x2000		/* use hmac-sha1 */

/* "Long" cryptographic operations on newer chipsets */
#define	UBS_PKTCTX_TYPE_IPSEC_3DES	0x0000
#define	UBS_PKTCTX_TYPE_IPSEC_AES	0x0040

struct ubsec_pktctx_hdr {
	volatile u_int16_t	ph_len;		/* length of ctx struct */
	volatile u_int16_t	ph_type;	/* context type, 0 */
	volatile u_int16_t	ph_flags;	/* flags, same as above */
	volatile u_int16_t	ph_offset;	/* crypto/auth offset */
};

/* Long version of DES/3DES */
struct ubsec_pktctx_3des {
	struct ubsec_pktctx_hdr	pc_hdr;		/* Common header */
	volatile u_int32_t	pc_deskey[6];	/* 3DES key */
	volatile u_int32_t	pc_iv[2];	/* [3]DES iv */
	volatile u_int32_t	pc_hminner[5];	/* hmac inner state */
	volatile u_int32_t	pc_hmouter[5];	/* hmac outer state */
};

/* AES uses different structures for each supported key size */
struct ubsec_pktctx_aes128 {
	struct ubsec_pktctx_hdr	pc_hdr;		/* Common header */
	volatile u_int32_t	pc_aeskey[4];	/* AES128 key */
	volatile u_int32_t	pc_iv[4];	/* AES iv/ucv */
	volatile u_int32_t	pc_hminner[5];	/* hmac inner state */
	volatile u_int32_t	pc_hmouter[5];	/* hmac outer state */
};

struct ubsec_pktctx_aes192 {
	struct ubsec_pktctx_hdr	pc_hdr;		/* Common header */
	volatile u_int32_t	pc_aeskey[6];	/* AES192 key */
	volatile u_int32_t	pc_iv[4];	/* AES iv/icv */
	volatile u_int32_t	pc_hminner[5];	/* hmac inner state */
	volatile u_int32_t	pc_hmouter[5];	/* hmac outer state */
};

struct ubsec_pktctx_aes256 {
	struct ubsec_pktctx_hdr	pc_hdr;		/* Common header */
	volatile u_int32_t	pc_aeskey[8];	/* AES256 key */
	volatile u_int32_t	pc_iv[4];	/* AES iv/icv */
	volatile u_int32_t	pc_hminner[5];	/* hmac inner state */
	volatile u_int32_t	pc_hmouter[5];	/* hmac outer state */
};
#define UBS_PKTCTX_ENC_AES	0x8000		/* use aes */
#define UBS_PKTCTX_MODE_CBC	0x0000		/* Cipher Block Chaining mode */
#define UBS_PKTCTX_MODE_CTR	0x0400		/* Counter mode */
#define UBS_PKTCTX_KEYSIZE_128	0x0000		/* AES128 */
#define UBS_PKTCTX_KEYSIZE_192	0x0100		/* AES192 */
#define UBS_PKTCTX_KEYSIZE_256	0x0200		/* AES256 */

struct ubsec_pktbuf {
	volatile u_int32_t	pb_addr;	/* address of buffer start */
	volatile u_int32_t	pb_next;	/* pointer to next pktbuf */
	volatile u_int32_t	pb_len;		/* packet length */
};
#define	UBS_PKTBUF_LEN		0x0000ffff	/* length mask */

struct ubsec_mcr {
	volatile u_int16_t	mcr_pkts;	/* #pkts in this mcr */
	volatile u_int16_t	mcr_flags;	/* mcr flags (below) */
	volatile u_int32_t	mcr_cmdctxp;	/* command ctx pointer */
	struct ubsec_pktbuf	mcr_ipktbuf;	/* input chain header */
	volatile u_int16_t	mcr_reserved;
	volatile u_int16_t	mcr_pktlen;
	struct ubsec_pktbuf	mcr_opktbuf;	/* output chain header */
};

struct ubsec_mcr_add {
	volatile u_int32_t	mcr_cmdctxp;	/* command ctx pointer */
	struct ubsec_pktbuf	mcr_ipktbuf;	/* input chain header */
	volatile u_int16_t	mcr_reserved;
	volatile u_int16_t	mcr_pktlen;
	struct ubsec_pktbuf	mcr_opktbuf;	/* output chain header */
};

#define	UBS_MCR_DONE		0x0001		/* mcr has been processed */
#define	UBS_MCR_ERROR		0x0002		/* error in processing */
#define	UBS_MCR_ERRORCODE	0xff00		/* error type */

struct ubsec_ctx_keyop {
	volatile u_int16_t	ctx_len;	/* command length */
	volatile u_int16_t	ctx_op;		/* operation code */
	volatile u_int8_t	ctx_pad[60];	/* padding */
};
#define	UBS_CTXOP_DHPKGEN	0x01		/* dh public key generation */
#define	UBS_CTXOP_DHSSGEN	0x02		/* dh shared secret gen. */
#define	UBS_CTXOP_RSAPUB	0x03		/* rsa public key op */
#define	UBS_CTXOP_RSAPRIV	0x04		/* rsa private key op */
#define	UBS_CTXOP_DSASIGN	0x05		/* dsa signing op */
#define	UBS_CTXOP_DSAVRFY	0x06		/* dsa verification */
#define	UBS_CTXOP_RNGBYPASS	0x41		/* rng direct test mode */
#define	UBS_CTXOP_RNGSHA1	0x42		/* rng sha1 test mode */
#define	UBS_CTXOP_MODADD	0x43		/* modular addition */
#define	UBS_CTXOP_MODSUB	0x44		/* modular subtraction */
#define	UBS_CTXOP_MODMUL	0x45		/* modular multiplication */
#define	UBS_CTXOP_MODRED	0x46		/* modular reduction */
#define	UBS_CTXOP_MODEXP	0x47		/* modular exponentiation */
#define	UBS_CTXOP_MODINV	0x48		/* modular inverse */

struct ubsec_ctx_rngbypass {
	volatile u_int16_t	rbp_len;	/* command length, 64 */
	volatile u_int16_t	rbp_op;		/* rng bypass, 0x41 */
	volatile u_int8_t	rbp_pad[60];	/* padding */
};

/* modexp: C = (M ^ E) mod N */
struct ubsec_ctx_modexp {
	volatile u_int16_t	me_len;		/* command length */
	volatile u_int16_t	me_op;		/* modexp, 0x47 */
	volatile u_int16_t	me_E_len;	/* E (bits) */
	volatile u_int16_t	me_N_len;	/* N (bits) */
	u_int8_t		me_N[2048/8];	/* N */
};

struct ubsec_ctx_rsapriv {
	volatile u_int16_t	rpr_len;	/* command length */
	volatile u_int16_t	rpr_op;		/* rsaprivate, 0x04 */
	volatile u_int16_t	rpr_q_len;	/* q (bits) */
	volatile u_int16_t	rpr_p_len;	/* p (bits) */
	u_int8_t		rpr_buf[5 * 1024 / 8];	/* parameters: */
						/* p, q, dp, dq, pinv */
};
@


1.29
log
@add support for AES-CBC with the BCM5823 (or newer, but we don't support newer
variants yet).

ok deraadt@@ dlg@@
@
text
@d57 9
a65 5
#define	BS_MCR1		0x00	/* DMA Master Command Record 1 */
#define	BS_CTRL		0x04	/* DMA Control */
#define	BS_STAT		0x08	/* DMA Status */
#define	BS_ERR		0x0c	/* DMA Error Address */
#define	BS_MCR2		0x10	/* DMA Master Command Record 2 */
d81 3
d88 1
a88 1
#define	BS_STAT_MCR1_BUSY	0x80000000	/* MCR1 is busy */
d96 6
d106 6
@


1.28
log
@nuke term 3 based on terms file
@
text
@d94 1
d111 14
a124 5
struct ubsec_pktctx_long {
	volatile u_int16_t	pc_len;		/* length of ctx struct */
	volatile u_int16_t	pc_type;	/* context type, 0 */
	volatile u_int16_t	pc_flags;	/* flags, same as above */
	volatile u_int16_t	pc_offset;	/* crypto/auth offset */
d130 31
a160 1
#define	UBS_PKTCTX_TYPE_IPSEC	0x0000
@


1.27
log
@- On reset, disable hardware normalization for 582x and make sure the chip is in little endian mode.
- since sw normalization is now the only option, simplify normalization handling
- remove some leftover #if 0 code
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.26 2002/09/03 18:56:50 jason Exp $	*/
a15 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.26
log
@tyops
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.25 2002/07/08 20:00:18 jason Exp $	*/
d80 1
d185 1
a185 1
	u_int8_t		me_N[1024/8];	/* N */
@


1.25
log
@Another missing bit (appears to make the 582x series work like the 580x series
as far as key setups go).
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.24 2002/07/08 19:41:29 jason Exp $	*/
d73 1
a73 1
#define	BS_CTRL_RNG_M		0x01800000	/* RND mode */
d78 1
a78 1
#define	BN_CTRL_SWNORM		0x00400000	/* 582[01], sw normalization */
@


1.24
log
@5821 has two additional bits that must be ack'd (note they don't have
corresponding enable bits... they are always on... dain bramage).
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.23 2002/05/08 23:05:28 jason Exp $	*/
d78 1
d88 2
a89 2
#define	BS_STAT_MCR1_ALLEMPTY	0x02000000	/* MCR1 is completely empty */
#define	BS_STAT_MCR2_ALLEMPTY	0x01000000	/* MCR2 is completely empty */
@


1.23
log
@- Go ahead and register to handle CRK_MOD_EXP_CRT ops
- completely (almost) revamp kprocess_rsapriv to match what the chip expects
- add and use a function to compute the significant bits of a given number
(this will be necessary for normalization)
[Still doesn't reproduce the broadcom or provos test data, but it's closer...]
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.22 2002/05/06 20:53:05 jason Exp $	*/
d87 2
@


1.22
log
@basic infrastructure for handling RSA with CRT parameters.  Just need to
figure out how p, q, dp, dq, and pinv fit into the context.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.21 2002/04/26 05:06:03 jason Exp $	*/
d189 1
a189 1
	volatile u_int8_t	rpr_buf[(5 * 512) / 8];	/* parameters: */
@


1.21
log
@1024 bit max
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.20 2002/04/26 04:24:17 jason Exp $	*/
d182 9
@


1.20
log
@register as supporting modular exponentiation
still contains much debugging code and isn't quite done, but its a start
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.19 2002/04/24 21:44:11 jason Exp $	*/
d181 1
a181 1
	u_int8_t	me_N[2048/8];	/* N */
@


1.19
log
@whoops, missed two fields in modexp structure (kinda important ones =)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.18 2002/04/23 22:16:05 jason Exp $	*/
d181 1
a181 1
	volatile u_int8_t	me_N[2048/8];	/* N */
@


1.18
log
@modexp context structure
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.17 2002/04/08 17:49:42 jason Exp $	*/
d175 1
d179 3
a181 1
	volatile u_int8_t	me_N[2048/8];	/* N of C = M^E mod N */
@


1.17
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.16 2002/01/19 21:15:37 jason Exp $	*/
d173 6
@


1.16
log
@From Patrik Lindergren (patrik@@ipunplugged.com):
* make the driver big-endian aware
* handling for DMA errors
* move some allocations to attach
From me:
whitespace clean up and vtophys removal (almost works on sparc64)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.15 2001/11/14 00:29:25 jason Exp $	*/
d29 5
@


1.15
log
@Define the TRDY timeout and RETRY timeout registers (not used... yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.14 2001/06/29 21:52:42 jason Exp $	*/
d5 1
d40 10
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.16 2002/01/19 21:15:37 jason Exp $	*/
a4 1
 * Copyright (c) 2001 Patrik Lindergren (patrik@@ipunplugged.com)
a38 10

#define	UBS_PCI_RTY_SHIFT			8
#define	UBS_PCI_RTY_MASK			0xff
#define	UBS_PCI_RTY(misc) \
    (((misc) >> UBS_PCI_RTY_SHIFT) & UBS_PCI_RTY_MASK)

#define	UBS_PCI_TOUT_SHIFT			0
#define	UBS_PCI_TOUT_MASK			0xff
#define	UBS_PCI_TOUT(misc) \
    (((misc) >> PCI_TOUT_SHIFT) & PCI_TOUT_MASK)
@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.15.2.1 2002/01/31 22:55:36 niklas Exp $	*/
a28 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a167 18
};

/* modexp: C = (M ^ E) mod N */
struct ubsec_ctx_modexp {
	volatile u_int16_t	me_len;		/* command length */
	volatile u_int16_t	me_op;		/* modexp, 0x47 */
	volatile u_int16_t	me_E_len;	/* E (bits) */
	volatile u_int16_t	me_N_len;	/* N (bits) */
	u_int8_t		me_N[1024/8];	/* N */
};

struct ubsec_ctx_rsapriv {
	volatile u_int16_t	rpr_len;	/* command length */
	volatile u_int16_t	rpr_op;		/* rsaprivate, 0x04 */
	volatile u_int16_t	rpr_q_len;	/* q (bits) */
	volatile u_int16_t	rpr_p_len;	/* p (bits) */
	u_int8_t		rpr_buf[5 * 1024 / 8];	/* parameters: */
						/* p, q, dp, dq, pinv */
@


1.15.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.15.2.2 2002/06/11 03:42:27 art Exp $	*/
d73 1
a73 1
#define	BS_CTRL_RNG_M		0x01800000	/* RNG mode */
a77 1
#define	BS_CTRL_SWNORM		0x00400000	/* 582[01], sw normalization */
a78 1
#define	BS_CTRL_LITTLE_ENDIAN	(BS_CTRL_BE32 | BS_CTRL_BE64)
a86 2
#define	BS_STAT_MCR1_ALLEMPTY	0x02000000	/* 5821, MCR1 is empty */
#define	BS_STAT_MCR2_ALLEMPTY	0x01000000	/* 5821, MCR2 is empty */
d181 1
a181 1
	u_int8_t		me_N[2048/8];	/* N */
@


1.14
log
@move definitions around a bit and define a few more constants
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.13 2001/05/30 02:26:14 jason Exp $	*/
d36 3
a38 1
#define BS_BAR		0x10	/* DMA and status base address register */
@


1.13
log
@Un-bus_dma(9) mcr1 context and mcr operations (causes problems under load).
Reimplement mcr2 bus_dma handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.12 2001/05/22 22:53:39 jason Exp $	*/
a72 5

#define	UBSEC_CARD(sid)		(((sid) & 0xf0000000) >> 28)
#define	UBSEC_SESSION(sid)	( (sid) & 0x0fffffff)
#define	UBSEC_SID(crd, sesn)	(((crd) << 28) | ((sesn) & 0x0fffffff))
#define	MAX_SCATTER		64
@


1.12
log
@- Don't poll the rng more than 100 times a second
- bus_dmaify mcr2 operations (rng)
- start bus_dma of mcr1 operations (context; mcr and pktbufs to go)
... more to come ...
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.11 2001/05/13 01:20:02 jason Exp $	*/
a85 2
	u_int32_t	pc_paddr;
	u_int8_t	pad[16];
@


1.11
log
@Initial support for Broadcom 5820, which is very much like the 5805 except
that the packet context structure for ipsec has changed (added two fields
and, annoyingly, rearranged several of them).  The MCR2 operations (only
RNG is used at this point) are supported, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.10 2001/02/02 01:00:07 jason Exp $	*/
d138 1
a138 1
struct ubsec_keyctx {
d158 1
a158 1
struct ubsec_rngbypass_ctx {
a161 7
};

#define UBS_RNGBUFSZ		16
struct ubsec_rng {
	struct ubsec_mcr		rng_mcr;
	struct ubsec_rngbypass_ctx	rng_ctx;
	volatile u_int32_t		rng_buf[UBS_RNGBUFSZ];
@


1.11.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d48 1
d96 12
@


1.11.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.11.2.1 2001/05/14 22:26:00 niklas Exp $	*/
a47 1
#define	BS_CTRL_RESET		0x80000000	/* hardware reset, 5805/5820 */
d73 5
d85 2
a95 12
struct ubsec_pktctx_long {
	volatile u_int16_t	pc_len;		/* length of ctx struct */
	volatile u_int16_t	pc_type;	/* context type, 0 */
	volatile u_int16_t	pc_flags;	/* flags, same as above */
	volatile u_int16_t	pc_offset;	/* crypto/auth offset */
	volatile u_int32_t	pc_deskey[6];	/* 3DES key */
	volatile u_int32_t	pc_iv[2];	/* [3]DES iv */
	volatile u_int32_t	pc_hminner[5];	/* hmac inner state */
	volatile u_int32_t	pc_hmouter[5];	/* hmac outer state */
};
#define	UBS_PKTCTX_TYPE_IPSEC	0x0000

d125 1
a125 1
struct ubsec_ctx_keyop {
d145 1
a145 1
struct ubsec_ctx_rngbypass {
d149 7
@


1.11.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 3
#define BS_BAR			0x10	/* DMA base address register */
#define	BS_TRDY_TIMEOUT		0x40	/* TRDY timeout */
#define	BS_RETRY_TIMEOUT	0x41	/* DMA retry timeout */
@


1.11.2.4
log
@Merge in trunk
@
text
@a4 1
 * Copyright (c) 2001 Patrik Lindergren (patrik@@ipunplugged.com)
a38 10

#define	UBS_PCI_RTY_SHIFT			8
#define	UBS_PCI_RTY_MASK			0xff
#define	UBS_PCI_RTY(misc) \
    (((misc) >> UBS_PCI_RTY_SHIFT) & UBS_PCI_RTY_MASK)

#define	UBS_PCI_TOUT_SHIFT			0
#define	UBS_PCI_TOUT_MASK			0xff
#define	UBS_PCI_TOUT(misc) \
    (((misc) >> PCI_TOUT_SHIFT) & PCI_TOUT_MASK)
@


1.11.2.5
log
@Sync the SMP branch with 3.3
@
text
@a28 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d68 1
a68 1
#define	BS_CTRL_RNG_M		0x01800000	/* RNG mode */
a72 1
#define	BS_CTRL_SWNORM		0x00400000	/* 582[01], sw normalization */
a73 1
#define	BS_CTRL_LITTLE_ENDIAN	(BS_CTRL_BE32 | BS_CTRL_BE64)
a81 2
#define	BS_STAT_MCR1_ALLEMPTY	0x02000000	/* 5821, MCR1 is empty */
#define	BS_STAT_MCR2_ALLEMPTY	0x01000000	/* 5821, MCR2 is empty */
a167 18
};

/* modexp: C = (M ^ E) mod N */
struct ubsec_ctx_modexp {
	volatile u_int16_t	me_len;		/* command length */
	volatile u_int16_t	me_op;		/* modexp, 0x47 */
	volatile u_int16_t	me_E_len;	/* E (bits) */
	volatile u_int16_t	me_N_len;	/* N (bits) */
	u_int8_t		me_N[2048/8];	/* N */
};

struct ubsec_ctx_rsapriv {
	volatile u_int16_t	rpr_len;	/* command length */
	volatile u_int16_t	rpr_op;		/* rsaprivate, 0x04 */
	volatile u_int16_t	rpr_q_len;	/* q (bits) */
	volatile u_int16_t	rpr_p_len;	/* p (bits) */
	u_int8_t		rpr_buf[5 * 1024 / 8];	/* parameters: */
						/* p, q, dp, dq, pinv */
@


1.11.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.11.2.5 2003/03/28 00:38:25 niklas Exp $	*/
d16 2
@


1.10
log
@The read/write indication bit in DMAERR reg is bit 1, not bit 0
also, add a mask for the address portion of DMAERR and use it
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.9 2001/01/29 04:01:44 jason Exp $	*/
d48 1
d96 12
@


1.9
log
@grab rng stuff more often (now 6400bytes/sec)
document the other mcr2 operations
and fix a printf (luckily it's never been called =)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.8 2001/01/29 00:39:20 jason Exp $	*/
d70 2
a71 1
#define	BS_ERR_READ		0x00000001	/* fault was on read */
@


1.8
log
@- add infrastructure for dealing with the key generator (MCR2)
- add support for the onboard rng using that structure
- add a interrupt status mask (differs for 5501 and 5601)
- reorganize slightly to take into account that MCR1 isn't the only reason
  for interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.7 2000/08/13 22:06:48 deraadt Exp $	*/
d129 14
a142 1
#define	UBS_CTXOP_RNGBYPASS	0x41
@


1.7
log
@fix session code
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.5 2000/08/11 19:38:15 deraadt Exp $	*/
d123 20
@


1.6
log
@not completely working session code from jason
@
text
@d74 1
a74 1
#define	UBSEC_SID(crd,ses)	(((crd) << 28) | ((ses) & 0x0fffffff))
@


1.5
log
@move mcr out of q; and write prelim mcr aggregation code, which does not yet
work for some reason or another, so it is currently disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.4 2000/06/18 03:37:22 jason Exp $	*/
d73 2
a74 1
#define	UBSEC_SID(crd,ses)	(((crd) << 28) | ((ses) & 0x7ff))
@


1.4
log
@Use the same field data types as the reference code and adjust offsets
appropriately.
Byte swap key/iv fields because they are given to us as "network order",
but the chip operates as little endian.
coffset is in WORDS not bytes
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.3 2000/06/12 19:50:35 deraadt Exp $	*/
d110 9
@


1.3
log
@ESP 3des now works, after squishing 4 bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.2 2000/06/03 13:14:39 jason Exp $	*/
d74 1
a74 1
#define	MAX_SCATTER		10
d77 8
a84 5
	u_int8_t	pc_deskey[24];		/* 3DES key */
	u_int8_t	pc_hminner[20];		/* hmac inner state */
	u_int8_t	pc_hmouter[20];		/* hmac outer state */
	u_int8_t	pc_iv[8];		/* 3DES iv */
	u_int32_t	pc_flags;
d86 7
a92 8
#define	UBS_PKTCTX_COFFSET	0xffff0000	/* cryto to mac offset */
#define	UBS_PKTCTX_ENC_3DES	0x00008000	/* use 3des */
#define	UBS_PKTCTX_ENC_NONE	0x00000000	/* no encryption */
#define	UBS_PKTCTX_INBOUND	0x00004000	/* inbound packet */
#define	UBS_PKTCTX_AUTH		0x00003000	/* authentication mask */
#define	UBS_PKTCTX_AUTH_NONE	0x00000000	/* no authentication */
#define	UBS_PKTCTX_AUTH_MD5	0x00001000	/* use hmac-md5 */
#define	UBS_PKTCTX_AUTH_SHA1	0x00002000	/* use hmac-sha1 */
@


1.2
log
@Move everything to where is supposed to be (reg definitions, etc).
Add some of the skip logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecreg.h,v 1.1 2000/05/18 01:25:19 jason Exp $	*/
d93 3
a95 3
	u_int32_t	pb_addr;		/* address of buffer start */
	u_int32_t	pb_next;		/* pointer to next pktbuf */
	u_int32_t	pb_len;
d100 3
a102 3
	u_int32_t		mcr_flags;	/* flags/packet count */

	u_int32_t		mcr_cmdctxp;	/* command ctx pointer */
d104 2
d108 3
a110 24
#define	UBS_MCR_PACKETS		0x0000ffff	/* packets in this mcr */
#define	UBS_MCR_DONE		0x00010000	/* mcr has been processed */
#define	UBS_MCR_ERROR		0x00020000	/* error in processing */
#define	UBS_MCR_ERRORCODE	0xff000000	/* error type */

struct ubsec_q {
	SIMPLEQ_ENTRY(ubsec_q)		q_next;
	struct ubsec_softc		*q_sc;
	struct cryptop			*q_crp;
	struct ubsec_mcr		q_mcr;
	struct ubsec_pktctx		q_ctx;

	struct mbuf *		      	q_src_m;
	long				q_src_packp[MAX_SCATTER];
	int				q_src_packl[MAX_SCATTER];
	int				q_src_npa, q_src_l;
	struct ubsec_pktbuf		q_srcpkt[MAX_SCATTER-1];

	struct mbuf *			q_dst_m;
	long				q_dst_packp[MAX_SCATTER];
	int				q_dst_packl[MAX_SCATTER];
	int				q_dst_npa, q_dst_l;
	struct ubsec_pktbuf		q_dstpkt[MAX_SCATTER-1];
};
@


1.1
log
@work in progress: driver for BlueSteel (Broadcom) 5[56]01 crypto accelerator
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 5
a34 1
#define UB_MCR			0x00		/* MCR */
d36 1
a36 21
#define UB_DMACTRL		0x04		/* DMA control */
#define UB_DMAC_MCR2IEN		0x40000000	/* Enable MCR2 completion interrupt */
#define UB_DMAC_MCRIEN		0x20000000	/* Enable MCR completion interrupt */
#define UB_DMAC_FRAGMODE	0x10000000
#define UB_DMAC_LE32		0x08000000
#define UB_DMAC_LE64		0x04000000
#define UB_DMAC_DMAERR		0x02000000

#define UB_DMASTAT		0x08
#define UB_DMAS_MCRBUSY		0x80000000
#define UB_DMAS_MCRFULL		0x40000000
#define UB_DMAS_MCRDONE		0x20000000
#define UB_DMAS_DMAERR		0x10000000
#define UB_DMAS_MCR2FULL	0x08000000
#define UB_DMAS_MCR2DONE	0x04000000

#define UB_DMAADDR		0x0c
#define UB_DMAA_ADDMASK		0xfffffffc
#define UB_DMAA_READ		0x00000002

#define UB_MCR2			0x10		/* MCR2 */
d38 92
@

