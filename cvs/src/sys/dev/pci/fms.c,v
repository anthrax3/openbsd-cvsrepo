head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.2
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.27.0.8
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.6
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.12
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.10
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.6
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.17.0.12
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.10
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.8
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.13
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SMP:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.30
date	2016.12.20.15.31.00;	author ratchov;	state Exp;
branches;
next	1.29;
commitid	j7wMTlqoVHnPc9Fa;

1.29
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.28;
commitid	qGgYgJTgEFuAoGj4;

1.28
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.27;
commitid	pi1a9KN0itEngOc4;

1.27
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.26;
commitid	RaOGL5SyOGOZylwx;

1.26
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.25;
commitid	OBNa5kfxQ2UXoiIw;

1.25
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.04.00.50.36;	author jakemsr;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.29.02.10.01;	author jakemsr;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.16.21.57.23;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.14.12.42.16;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.13.18.26.12;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.29.14.30.21;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.29.14.23.30;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.28.04.19.53;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.06.16.37.43;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.14.18.04.07;	author aaron;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.07.20.21.45.19;	author deraadt;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.22.25.41;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.07.04.10.42.04;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.2.6.6;

1.2.6.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.2.6.7;

1.2.6.7
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.2.6.8;

1.2.6.8
date	2003.05.13.19.35.05;	author ho;	state Exp;
branches;
next	;

1.5.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Set free(9) size argument. From Michael W. Bombardieri <mb at ii.net>.
Thanks.
@
text
@/*	$OpenBSD: fms.c,v 1.29 2016/09/19 06:46:44 ratchov Exp $ */
/*	$NetBSD: fms.c,v 1.5.4.1 2000/06/30 16:27:50 simonb Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Witold J. Wnuk.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Forte Media FM801 Audio Device Driver
 */

#include "radio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/audioio.h>

#include <machine/bus.h>
#include <machine/cpu.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <dev/audio_if.h>
#include <dev/ic/ac97.h>
#if 0
#include <dev/ic/mpuvar.h>
#endif

#include <dev/pci/fmsreg.h>
#include <dev/pci/fmsvar.h>


struct fms_dma {
	struct fms_dma *next;
	caddr_t addr;
	size_t size;
	bus_dmamap_t map;
	bus_dma_segment_t seg;
};



int	fms_match(struct device *, void *, void *);
void	fms_attach(struct device *, struct device *, void *);
int	fms_intr(void *);

int	fms_open(void *, int);
void	fms_close(void *);
int	fms_set_params(void *, int, int, struct audio_params *, 
			    struct audio_params *);
int	fms_round_blocksize(void *, int);
int	fms_halt_output(void *);
int	fms_halt_input(void *);
int	fms_set_port(void *, mixer_ctrl_t *);
int	fms_get_port(void *, mixer_ctrl_t *);
int	fms_query_devinfo(void *, mixer_devinfo_t *);
void	*fms_malloc(void *, int, size_t, int, int);
void	fms_free(void *, void *, int);
int	fms_get_props(void *);
int	fms_trigger_output(void *, void *, void *, int, void (*)(void *),
			   void *, struct audio_params *);
int	fms_trigger_input(void *, void *, void *, int, void (*)(void *),
			  void *, struct audio_params *);

struct  cfdriver fms_cd = {
	NULL, "fms", DV_DULL
};

struct cfattach fms_ca = {
	sizeof (struct fms_softc), fms_match, fms_attach
};

struct audio_hw_if fms_hw_if = {
	fms_open,
	fms_close,
	fms_set_params,
	fms_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	fms_halt_output,
	fms_halt_input,
	NULL,
	NULL,
	fms_set_port,
	fms_get_port,
	fms_query_devinfo,
	fms_malloc,
	fms_free,
	NULL,
	fms_get_props,
	fms_trigger_output,
	fms_trigger_input
};

int	fms_attach_codec(void *, struct ac97_codec_if *);
int	fms_read_codec(void *, u_int8_t, u_int16_t *);
int	fms_write_codec(void *, u_int8_t, u_int16_t);
void	fms_reset_codec(void *);

int	fms_allocmem(struct fms_softc *, size_t, size_t,
			  struct fms_dma *);
int	fms_freemem(struct fms_softc *, struct fms_dma *);

int
fms_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_FORTEMEDIA &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_FORTEMEDIA_FM801)
		return (1);
	return (0);
}

void
fms_attach(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	struct fms_softc *sc = (struct fms_softc *) self;
	struct audio_attach_args aa;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t pt = pa->pa_tag;
	pci_intr_handle_t ih;
	bus_size_t iosize;
	const char *intrstr;
	u_int16_t k1;
	int i;
	
	if (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
	
	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh, 0x30, 2,
	    &sc->sc_mpu_ioh)) {
		printf(": can't get mpu subregion handle\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}

	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh, 0x68, 4,
	    &sc->sc_opl_ioh)) {
		printf(": can't get opl subregion handle\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}
	
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    fms_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}
	
	printf(": %s\n", intrstr);

	sc->sc_dmat = pa->pa_dmat;

	/* Disable legacy audio (SBPro compatibility) */
	pci_conf_write(pc, pt, 0x40, 0);
	
	/* Reset codec and AC'97 */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_CODEC_CTL, 0x0020);
	delay(2);		/* > 1us according to AC'97 documentation */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_CODEC_CTL, 0x0000);
	delay(1);		/* > 168.2ns according to AC'97 documentation */
	
	/* Set up volume */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_PCM_VOLUME, 0x0808);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_FM_VOLUME, 0x0808);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_I2S_VOLUME, 0x0808);
	
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_RECORD_SOURCE, 0x0000);
	
	/* Unmask playback, record and mpu interrupts, mask the rest */
	k1 = bus_space_read_2(sc->sc_iot, sc->sc_ioh, FM_INTMASK);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_INTMASK, 
	    (k1 & ~(FM_INTMASK_PLAY | FM_INTMASK_REC | FM_INTMASK_MPU)) |
	     FM_INTMASK_VOL);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_INTSTATUS, 
	    FM_INTSTATUS_PLAY | FM_INTSTATUS_REC | FM_INTSTATUS_MPU | 
	    FM_INTSTATUS_VOL);

#if NRADIO > 0
	fmsradio_attach(sc);
#endif /* NRADIO > 0 */
	
	sc->host_if.arg = sc;
	sc->host_if.attach = fms_attach_codec;
	sc->host_if.read = fms_read_codec;
	sc->host_if.write = fms_write_codec;
	sc->host_if.reset = fms_reset_codec;

	if (ac97_attach(&sc->host_if) != 0)
		return;
	
	/* Turn mute off */
	for (i = 0; i < 3; i++) {
		static struct {
			char *class, *device;
		} d[] = {
			{ AudioCoutputs, AudioNmaster },
			{ AudioCinputs, AudioNdac },
			{ AudioCrecord, AudioNvolume }
		};
		struct mixer_ctrl ctl;
		
		ctl.type = AUDIO_MIXER_ENUM;
		ctl.un.ord = 0;
		ctl.dev = sc->codec_if->vtbl->get_portnum_by_name(sc->codec_if,
			d[i].class, d[i].device, AudioNmute);
		fms_set_port(sc, &ctl);
	}

	audio_attach_mi(&fms_hw_if, sc, &sc->sc_dev);

	aa.type = AUDIODEV_TYPE_OPL;
	aa.hwif = NULL;
	aa.hdl = NULL;
	config_found(&sc->sc_dev, &aa, audioprint);

	aa.type = AUDIODEV_TYPE_MPU;
	aa.hwif = NULL;
	aa.hdl = NULL;
	sc->sc_mpu_dev = config_found(&sc->sc_dev, &aa, audioprint);
}

/*
 * Each AC-link frame takes 20.8us, data should be ready in next frame,
 * we allow more than two.
 */
#define TIMO 50
int
fms_read_codec(void *addr, u_int8_t reg, u_int16_t *val)
{
	struct fms_softc *sc = addr;
	int i;

	/* Poll until codec is ready */
	for (i = 0; i < TIMO && bus_space_read_2(sc->sc_iot, sc->sc_ioh, 
		 FM_CODEC_CMD) & FM_CODEC_CMD_BUSY; i++)
		delay(1);
	if (i >= TIMO) {
		printf("fms: codec busy\n");
		return 1;
	}

	/* Write register index, read access */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_CODEC_CMD, 
			  reg | FM_CODEC_CMD_READ);
	
	/* Poll until we have valid data */
	for (i = 0; i < TIMO && !(bus_space_read_2(sc->sc_iot, sc->sc_ioh, 
		 FM_CODEC_CMD) & FM_CODEC_CMD_VALID); i++)
		delay(1);
	if (i >= TIMO) {
		printf("fms: no data from codec\n");
		return 1;
	}
	
	/* Read data */
	*val = bus_space_read_2(sc->sc_iot, sc->sc_ioh, FM_CODEC_DATA);
	return 0;
}

int
fms_write_codec(void *addr, u_int8_t reg, u_int16_t val)
{
	struct fms_softc *sc = addr;
	int i;
	
	/* Poll until codec is ready */
	for (i = 0; i < TIMO && bus_space_read_2(sc->sc_iot, sc->sc_ioh, 
		 FM_CODEC_CMD) & FM_CODEC_CMD_BUSY; i++)
		delay(1);
	if (i >= TIMO) {
		printf("fms: codec busy\n");
		return 1;
	}

	/* Write data */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_CODEC_DATA, val);
	/* Write index register, write access */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_CODEC_CMD, reg);
	return 0;
}
#undef TIMO

int
fms_attach_codec(void *addr, struct ac97_codec_if *cif)
{
	struct fms_softc *sc = addr;

	sc->codec_if = cif;
	return 0;
}

/* Cold Reset */
void
fms_reset_codec(void *addr)
{
	struct fms_softc *sc = addr;
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_CODEC_CTL, 0x0020);
	delay(2);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_CODEC_CTL, 0x0000);
	delay(1);
}

int
fms_intr(void *arg)
{
	struct fms_softc *sc = arg;
	u_int16_t istat;
	
	mtx_enter(&audio_lock);
	istat = bus_space_read_2(sc->sc_iot, sc->sc_ioh, FM_INTSTATUS);

	if (istat & FM_INTSTATUS_PLAY) {
		if ((sc->sc_play_nextblk += sc->sc_play_blksize) >= 
		     sc->sc_play_end)
			sc->sc_play_nextblk = sc->sc_play_start;

		bus_space_write_4(sc->sc_iot, sc->sc_ioh, 
		    sc->sc_play_flip++ & 1 ? 
		    FM_PLAY_DMABUF2 : FM_PLAY_DMABUF1, sc->sc_play_nextblk);

		if (sc->sc_pintr)
			sc->sc_pintr(sc->sc_parg);
		else
			printf("unexpected play intr\n");
	}

	if (istat & FM_INTSTATUS_REC) {
		if ((sc->sc_rec_nextblk += sc->sc_rec_blksize) >= 
		     sc->sc_rec_end)
			sc->sc_rec_nextblk = sc->sc_rec_start;

		bus_space_write_4(sc->sc_iot, sc->sc_ioh, 
		    sc->sc_rec_flip++ & 1 ? 
		    FM_REC_DMABUF2 : FM_REC_DMABUF1, sc->sc_rec_nextblk);

		if (sc->sc_rintr)
			sc->sc_rintr(sc->sc_rarg);
		else
			printf("unexpected rec intr\n");
	}
	
#if 0
	if (istat & FM_INTSTATUS_MPU)
		mpu_intr(sc->sc_mpu_dev);
#endif

	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_INTSTATUS, 
			  istat & (FM_INTSTATUS_PLAY | FM_INTSTATUS_REC));
	mtx_leave(&audio_lock);
	return 1;
}

int
fms_open(void *addr, int flags)
{
	/* UNUSED struct fms_softc *sc = addr;*/

	return 0;
}

void
fms_close(void *addr)
{
	/* UNUSED struct fms_softc *sc = addr;*/
}

/*
 * Range below -limit- is set to -rate-
 * What a pity FM801 does not have 24000
 * 24000 -> 22050 sounds rather poor
 */
struct {
	int limit;
	int rate;
} fms_rates[11] = {
	{  6600,  5500 },
	{  8750,  8000 },
	{ 10250,  9600 },
	{ 13200, 11025 },
	{ 17500, 16000 },
	{ 20500, 19200 },
	{ 26500, 22050 },
	{ 35000, 32000 },
	{ 41000, 38400 },
	{ 46000, 44100 },
	{ 48000, 48000 },
	/* anything above -> 48000 */
};

int
fms_set_params(void *addr, int setmode, int usemode, struct audio_params *play,
    struct audio_params *rec)
{
	struct fms_softc *sc = addr;
	int i;

	if (setmode & AUMODE_PLAY) {
		switch(play->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			if (play->precision != 16)
				return EINVAL;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (play->precision != 8)
				return EINVAL;
			break;
		default:
			return EINVAL;
		}
		play->bps = AUDIO_BPS(play->precision);
		play->msb = 1;

		for (i = 0; i < 10 && play->sample_rate > fms_rates[i].limit;
		     i++)
			;
		play->sample_rate = fms_rates[i].rate;
		sc->sc_play_reg = (play->channels == 2 ? FM_PLAY_STEREO : 0) |
		    (play->precision == 16 ? FM_PLAY_16BIT : 0) |
		    (i << 8);
	}

	if (setmode & AUMODE_RECORD) {

		switch(rec->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			if (rec->precision != 16)
				return EINVAL;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (rec->precision != 8)
				return EINVAL;
			break;
		default:
			return EINVAL;
		}
		rec->bps = AUDIO_BPS(rec->precision);
		rec->msb = 1;

		for (i = 0; i < 10 && rec->sample_rate > fms_rates[i].limit; 
		     i++)
			;
		rec->sample_rate = fms_rates[i].rate;
		sc->sc_rec_reg = 
		    (rec->channels == 2 ? FM_REC_STEREO : 0) | 
		    (rec->precision == 16 ? FM_REC_16BIT : 0) |
		    (i << 8);
	}
	
	return 0;
}

int
fms_round_blocksize(void *addr, int blk)
{
	return (blk + 0xf) & ~0xf;
}

int
fms_halt_output(void *addr)
{
	struct fms_softc *sc = addr;
	u_int16_t k1;

	mtx_enter(&audio_lock);
	k1 = bus_space_read_2(sc->sc_iot, sc->sc_ioh, FM_PLAY_CTL);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_PLAY_CTL, 
			  (k1 & ~(FM_PLAY_STOPNOW | FM_PLAY_START)) | 
			  FM_PLAY_BUF1_LAST | FM_PLAY_BUF2_LAST);
	mtx_leave(&audio_lock);
	return 0;
}

int
fms_halt_input(void *addr)
{
	struct fms_softc *sc = addr;
	u_int16_t k1;

	mtx_enter(&audio_lock);
	k1 = bus_space_read_2(sc->sc_iot, sc->sc_ioh, FM_REC_CTL);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_REC_CTL, 
			  (k1 & ~(FM_REC_STOPNOW | FM_REC_START)) |
			  FM_REC_BUF1_LAST | FM_REC_BUF2_LAST);
	mtx_leave(&audio_lock);
	return 0;
}

int
fms_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct fms_softc *sc = addr;

	return (sc->codec_if->vtbl->mixer_set_port(sc->codec_if, cp));
}

int
fms_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct fms_softc *sc = addr;
	
	return (sc->codec_if->vtbl->mixer_get_port(sc->codec_if, cp));
}

void *
fms_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct fms_softc *sc = addr;
	struct fms_dma *p;
	int error;
	int rseg;
	
	p = malloc(sizeof(*p), pool, flags);
	if (!p)
		return 0;
	
	p->size = size;
	if ((error = bus_dmamem_alloc(sc->sc_dmat, size, NBPG, 0, &p->seg, 1, 
				      &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to allocate dma, error = %d\n", 
		       sc->sc_dev.dv_xname, error);
		goto fail_alloc;
	}
	
	if ((error = bus_dmamem_map(sc->sc_dmat, &p->seg, rseg, size, &p->addr,
				    BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map dma, error = %d\n", 
		       sc->sc_dev.dv_xname, error);
		goto fail_map;
	}
	
	if ((error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0, 
				       BUS_DMA_NOWAIT, &p->map)) != 0) {
		printf("%s: unable to create dma map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		goto fail_create;
	}
	
	if ((error = bus_dmamap_load(sc->sc_dmat, p->map, p->addr, size, NULL,
				     BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load dma map, error = %d\n",
		       sc->sc_dev.dv_xname, error);
		goto fail_load;
	}
	
	p->next = sc->sc_dmas;
	sc->sc_dmas = p;

	return p->addr;


fail_load:
	bus_dmamap_destroy(sc->sc_dmat, p->map);
fail_create:
	bus_dmamem_unmap(sc->sc_dmat, p->addr, size);
fail_map:
	bus_dmamem_free(sc->sc_dmat, &p->seg, 1);
fail_alloc:
	free(p, pool, sizeof(*p));
	return 0;
}

void
fms_free(void *addr, void *ptr, int pool)
{
	struct fms_softc *sc = addr;
	struct fms_dma **pp, *p;

	for (pp = &(sc->sc_dmas); (p = *pp) != NULL; pp = &p->next)
		if (p->addr == ptr) {
			bus_dmamap_unload(sc->sc_dmat, p->map);
			bus_dmamap_destroy(sc->sc_dmat, p->map);
			bus_dmamem_unmap(sc->sc_dmat, p->addr, p->size);
			bus_dmamem_free(sc->sc_dmat, &p->seg, 1);
			
			*pp = p->next;
			free(p, pool, sizeof(*p));
			return;
		}

	panic("fms_free: trying to free unallocated memory");
}

int
fms_get_props(void *addr)
{
	return AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | 
	       AUDIO_PROP_FULLDUPLEX;
}

int
fms_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct fms_softc *sc = addr;

	return (sc->codec_if->vtbl->query_devinfo(sc->codec_if, dip));
}

int
fms_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct fms_softc *sc = addr;
	struct fms_dma *p;
	
	sc->sc_pintr = intr;
	sc->sc_parg = arg;
	
	for (p = sc->sc_dmas; p && p->addr != start; p = p->next)
		;
	
	if (!p)
		panic("fms_trigger_output: request with bad start "
		      "address (%p)", start);

	sc->sc_play_start = p->map->dm_segs[0].ds_addr;
	sc->sc_play_end = sc->sc_play_start + ((char *)end - (char *)start);
	sc->sc_play_blksize = blksize;
	sc->sc_play_nextblk = sc->sc_play_start + sc->sc_play_blksize;	
	sc->sc_play_flip = 0;
	mtx_enter(&audio_lock);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_PLAY_DMALEN, blksize - 1);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, FM_PLAY_DMABUF1, 
			  sc->sc_play_start);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, FM_PLAY_DMABUF2, 
			  sc->sc_play_nextblk);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_PLAY_CTL, 
			  FM_PLAY_START | FM_PLAY_STOPNOW | sc->sc_play_reg);
	mtx_leave(&audio_lock);
	return 0;
}


int
fms_trigger_input(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct fms_softc *sc = addr;
	struct fms_dma *p;
	
	sc->sc_rintr = intr;
	sc->sc_rarg = arg;
	
	for (p = sc->sc_dmas; p && p->addr != start; p = p->next)
		;
	
	if (!p)
		panic("fms_trigger_input: request with bad start "
		      "address (%p)", start);

	sc->sc_rec_start = p->map->dm_segs[0].ds_addr;
	sc->sc_rec_end = sc->sc_rec_start + ((char *)end - (char *)start);
	sc->sc_rec_blksize = blksize;
	sc->sc_rec_nextblk = sc->sc_rec_start + sc->sc_rec_blksize;	
	sc->sc_rec_flip = 0;
	mtx_enter(&audio_lock);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_REC_DMALEN, blksize - 1);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, FM_REC_DMABUF1, 
			  sc->sc_rec_start);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, FM_REC_DMABUF2, 
			  sc->sc_rec_nextblk);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, FM_REC_CTL, 
			  FM_REC_START | FM_REC_STOPNOW | sc->sc_rec_reg);
	mtx_leave(&audio_lock);
	return 0;
}
@


1.29
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.28 2016/09/14 06:12:19 ratchov Exp $ */
d610 1
a610 1
	free(p, pool, 0);
d628 1
a628 1
			free(p, pool, 0);
@


1.28
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.26 2014/07/12 18:48:51 tedu Exp $ */
a82 1
int	fms_getdev(void *, struct audio_device *);
a101 7
struct audio_device fms_device = {
	"Forte Media 801",
	"1.0",
	"fms"
};


a114 1
	fms_getdev,
a536 7
	return 0;
}

int
fms_getdev(void *addr, struct audio_device *retp)
{
	*retp = fms_device;
@


1.27
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@a77 1
int	fms_query_encoding(void *, struct audio_encoding *);
a79 1
void	fms_get_default_params(void *, int, struct audio_params *);
a88 1
paddr_t	fms_mappage(void *, void *, off_t, int);
a112 2
	NULL,
	fms_query_encoding,
a130 1
	fms_mappage,
d133 1
a133 2
	fms_trigger_input,
	fms_get_default_params
a425 32
int
fms_query_encoding(void *addr, struct audio_encoding *fp)
{

	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	default:
		return EINVAL;
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return 0;
}

void
fms_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
}

a648 18
}

paddr_t
fms_mappage(void *addr, void *mem, off_t off, int prot)
{
	struct fms_softc *sc = addr;
	struct fms_dma *p;
	
	if (off < 0)
		return -1;
	
	for (p = sc->sc_dmas; p && p->addr != mem; p = p->next)
		;
	if (!p)
		return -1;
	
	return bus_dmamem_mmap(sc->sc_dmat, &p->seg, 1, off, prot, 
			       BUS_DMA_WAITOK);
@


1.26
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.25 2013/11/15 16:46:27 brad Exp $ */
a52 3
#include <dev/mulaw.h>
#include <dev/auconv.h>

a438 6
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 1:
d444 1
a444 1
	case 2:
a449 30
	case 3:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 5:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a495 2
		play->factor = 1;
		play->sw_code = 0;
a496 4
		case AUDIO_ENCODING_ULAW:
			play->factor = 2;
			play->sw_code = mulaw_to_slinear16_le;
			break;
d498 2
a499 2
			if (play->precision == 8)
				play->sw_code = change_sign8;
a501 13
			if (play->precision == 16)
				play->sw_code = change_sign16_le;
			break;
		case AUDIO_ENCODING_ALAW:
			play->factor = 2;
			play->sw_code = alaw_to_slinear16_le;
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (play->precision == 16)
				play->sw_code = swap_bytes;
			else
				play->sw_code = change_sign8;
			break;
d503 2
a504 2
			if (play->precision == 16)
				play->sw_code = change_sign16_swap_bytes_le;
d517 1
a517 1
		    (play->precision * play->factor == 16 ? FM_PLAY_16BIT : 0) |
a522 2
		rec->factor = 1;
		rec->sw_code = 0;
a523 3
		case AUDIO_ENCODING_ULAW:
			rec->sw_code = ulinear8_to_mulaw;
			break;
d525 2
a526 2
			if (rec->precision == 8)
				rec->sw_code = change_sign8;
a528 12
			if (rec->precision == 16)
				rec->sw_code = change_sign16_le;
			break;
		case AUDIO_ENCODING_ALAW:
			rec->sw_code = ulinear8_to_alaw;
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (rec->precision == 16)
				rec->sw_code = swap_bytes;
			else
				rec->sw_code = change_sign8;
			break;
d530 2
a531 2
			if (rec->precision == 16)
				rec->sw_code = swap_bytes_change_sign16_le;
d545 1
a545 1
		    (rec->precision * rec->factor == 16 ? FM_REC_16BIT : 0) |
@


1.25
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.24 2013/05/24 07:58:46 ratchov Exp $ */
d740 1
a740 1
	free(p, pool);
d758 1
a758 1
			free(p, pool);
@


1.24
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.23 2013/05/15 08:29:24 ratchov Exp $ */
d156 1
a156 4
fms_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d167 1
a167 4
fms_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d297 1
a297 4
fms_read_codec(addr, reg, val)
	void *addr;
	u_int8_t reg;
	u_int16_t *val;
d330 1
a330 4
fms_write_codec(addr, reg, val)
	void *addr;
	u_int8_t reg;
	u_int16_t val;
d353 1
a353 3
fms_attach_codec(addr, cif)
	void *addr;
	struct ac97_codec_if *cif;
d363 1
a363 2
fms_reset_codec(addr)
	void *addr;
d373 1
a373 2
fms_intr(arg)
	void *arg;
d423 1
a423 3
fms_open(addr, flags)
	void *addr;
	int flags;	
d426 1
a426 1
	
d431 1
a431 2
fms_close(addr)
	void *addr;
d437 1
a437 3
fms_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d528 2
a529 4
fms_set_params(addr, setmode, usemode, play, rec)
	void *addr;
	int setmode, usemode;
	struct audio_params *play, *rec;
d628 1
a628 3
fms_round_blocksize(addr, blk)
	void *addr;
	int blk;
d634 1
a634 2
fms_halt_output(addr)
	void *addr;
d649 1
a649 2
fms_halt_input(addr)
	void *addr;
d664 1
a664 3
fms_getdev(addr, retp)
	void *addr;
	struct audio_device *retp;
d671 1
a671 3
fms_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d679 1
a679 3
fms_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d687 1
a687 5
fms_malloc(addr, direction, size, pool, flags)
	void *addr;
	int direction;
	size_t size;
	int pool, flags;
d745 1
a745 4
fms_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
d766 1
a766 5
fms_mappage(addr, mem, off, prot)
	void *addr;
	void *mem;
	off_t off;
	int prot;
d784 1
a784 2
fms_get_props(addr)
	void *addr;
d791 1
a791 3
fms_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d799 2
a800 7
fms_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d834 2
a835 7
fms_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
a865 2


@


1.23
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.22 2010/07/15 03:43:11 jakemsr Exp $ */
d213 2
a214 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, fms_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.22
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.21 2010/04/04 00:50:36 jakemsr Exp $ */
d394 1
d434 1
a434 1
	
d664 2
a665 1
	
d670 1
a670 1
	
d680 2
a681 1
	
d686 1
a686 1
	
d872 1
d880 1
d912 1
d920 1
@


1.21
log
@configure conversion for the correct direction.  I guess no one has
ever tried recording big endian samples with fms.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.20 2008/06/26 05:42:17 ray Exp $ */
d466 1
a466 1
		return 0; 
d472 1
a472 1
		return 0;
d478 1
a478 1
		return 0;
d484 1
a484 1
		return 0;
d490 1
a490 1
		return 0;
d496 1
a496 1
		return 0;
d502 1
a502 1
		return 0;
d508 1
a508 1
		return 0;
d512 4
d589 3
d633 3
@


1.20
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.19 2008/05/29 02:10:01 jakemsr Exp $ */
d614 2
a615 2
			if (play->precision == 16)
				play->sw_code = swap_bytes;
d617 1
a617 1
				play->sw_code = change_sign8;
d620 2
a621 2
			if (play->precision == 16)
				play->sw_code = swap_bytes_change_sign16_le;
@


1.19
log
@use ac97 default parameters for these ac97 based drivers.

this makes the emulation expansion factor 1 by default since there's no
emulation.  previously the factor was 2 because these drivers emulate
8-bit ulaw playback with 16-bit linear encodings.  having a factor
other than 1 by default creates block size and hiwat/lowat issues
with applications that set the block size and hiwat before other
parameters.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.18 2008/04/21 00:32:43 jakemsr Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.18
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.17 2005/04/16 21:57:23 mickey Exp $ */
d91 1
d150 1
a150 1
	NULL
d519 6
@


1.17
log
@do not provide round_buffer if not needed unless explained why in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.16 2005/04/14 12:42:16 mickey Exp $ */
d148 2
a149 1
	fms_trigger_input
@


1.16
log
@make sure round_blocksize does not produce 0 after alignment
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.15 2003/04/27 11:22:53 ho Exp $ */
a99 1
size_t	fms_round_buffersize(void *, int, size_t);
d144 1
a144 1
	fms_round_buffersize,
a788 9
}

size_t
fms_round_buffersize(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
{
	return size;
@


1.15
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.14 2002/11/19 18:40:17 jason Exp $ */
d644 1
a644 1
	return blk & ~0xf;
@


1.14
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.13 2002/10/13 18:26:12 krw Exp $ */
d468 1
a468 1
		strcpy(fp->name, AudioEmulaw);
d474 1
a474 1
		strcpy(fp->name, AudioEslinear_le);
d480 1
a480 1
		strcpy(fp->name, AudioEulinear);
d486 1
a486 1
		strcpy(fp->name, AudioEalaw);
d492 1
a492 1
		strcpy(fp->name, AudioEulinear_le);
d498 1
a498 1
		strcpy(fp->name, AudioEslinear);
d504 1
a504 1
		strcpy(fp->name, AudioEulinear_be);
d510 1
a510 1
		strcpy(fp->name, AudioEslinear_be);
@


1.13
log
@Remove more '\n's from panic() statements.  From Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.12 2002/05/29 14:30:21 mickey Exp $ */
d169 4
a172 6
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_FORTEMEDIA)
		return 0;
	if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_FORTEMEDIA_FM801)
		return 0;
	
	return 1;
@


1.12
log
@there is no need to store ioaddr/iosize into the softc
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.11 2002/05/29 14:23:30 mickey Exp $ */
d863 1
a863 1
		      "address (%p)\n", start);
d901 1
a901 1
		      "address (%p)\n", start);
@


1.11
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.10 2002/05/28 04:19:53 mickey Exp $ */
d189 1
d195 1
a195 1
	    &sc->sc_ioh, &sc->sc_ioaddr, &sc->sc_iosize, 0)) {
d203 1
a203 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_iosize);
d210 1
a210 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_iosize);
d216 1
a216 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_iosize);
d228 1
a228 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_iosize);
@


1.10
log
@fix the fms attachment printfs and move out the radio parts to the fmsradio.c; from jumbo@@ and some fixes from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.9 2002/05/06 16:37:43 mickey Exp $ */
d202 1
a202 1
		bus_space_unmap(sc->sc_ioh, sc->sc_ioaddr, sc->sc_iosize);
d209 1
a209 1
		bus_space_unmap(sc->sc_ioh, sc->sc_ioaddr, sc->sc_iosize);
d215 1
a215 1
		bus_space_unmap(sc->sc_ioh, sc->sc_ioaddr, sc->sc_iosize);
d227 1
a227 1
		bus_space_unmap(sc->sc_ioh, sc->sc_ioaddr, sc->sc_iosize);
@


1.9
log
@tuner driver for the fms cards.
attach radio at the fms(4), instead of a separate device,
which would never work out fine.
from Vladimir Popov <jumbo@@narod.ru>
rework the radio config stuff (radio at radiobus, instead of radio at radio),
allowing to tag source files in the files.* files w/ radio attribute.
from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.8 2002/03/14 03:16:06 millert Exp $ */
a63 5
#if NRADIO > 0
#include <sys/radioio.h>
#include <dev/radio_if.h>
#include <dev/pci/fmsradio.h>
#endif /* NRADIO > 0 */
a151 11
#if NRADIO > 0
struct radio_hw_if fmsradio_hw_if = {
	NULL,	/* open */
	NULL,	/* close */
	fmsradio_get_info,
	fmsradio_set_info,
	fmsradio_search
};
#endif /* NRADIO > 0 */


a185 1
	const char *intrstr = NULL;
d189 2
d193 5
a197 1
	u_int16_t k1;
d199 13
a211 1
	printf(": Forte Media FM-801\n");
d214 2
a215 1
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d223 1
a223 1
		printf("%s: couldn't establish interrupt",sc->sc_dev.dv_xname);
d227 1
d231 2
a233 16
	
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
	
	if (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot,
			   &sc->sc_ioh, &sc->sc_ioaddr, &sc->sc_iosize, 0)) {
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
		return;
	}
	
	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh, 0x30, 2, 
				&sc->sc_mpu_ioh))
		panic("fms_attach: can't get mpu subregion handle");

	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh, 0x68, 4,
				&sc->sc_opl_ioh))
		panic("fms_attach: can't get opl subregion handle");
d261 1
a261 8
	sc->radio.tea.iot = sc->sc_iot;
	sc->radio.tea.ioh = sc->sc_ioh;
	sc->radio.tea.offset = FM_IO_CTL;
	sc->radio.tea.flags = sc->sc_dev.dv_cfdata->cf_flags;

	fmsradio_attach(&sc->radio, sc->sc_dev.dv_xname);
	/* /dev/radio will attach anyway */
	radio_attach_mi(&fmsradio_hw_if, sc, &sc->sc_dev);
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.7 2002/03/14 01:26:58 millert Exp $ */
d44 2
d64 5
d73 1
d157 11
a176 63
#define FM_PCM_VOLUME		0x00
#define FM_FM_VOLUME		0x02
#define FM_I2S_VOLUME		0x04
#define FM_RECORD_SOURCE	0x06

#define FM_PLAY_CTL		0x08
#define  FM_PLAY_RATE_MASK		0x0f00
#define  FM_PLAY_BUF1_LAST		0x0001
#define  FM_PLAY_BUF2_LAST		0x0002
#define  FM_PLAY_START			0x0020
#define  FM_PLAY_PAUSE			0x0040
#define  FM_PLAY_STOPNOW		0x0080
#define  FM_PLAY_16BIT			0x4000
#define  FM_PLAY_STEREO			0x8000

#define FM_PLAY_DMALEN		0x0a
#define FM_PLAY_DMABUF1		0x0c
#define FM_PLAY_DMABUF2		0x10


#define FM_REC_CTL		0x14
#define  FM_REC_RATE_MASK		0x0f00
#define  FM_REC_BUF1_LAST		0x0001
#define  FM_REC_BUF2_LAST		0x0002
#define  FM_REC_START			0x0020
#define  FM_REC_PAUSE			0x0040
#define  FM_REC_STOPNOW			0x0080
#define  FM_REC_16BIT			0x4000
#define  FM_REC_STEREO			0x8000


#define FM_REC_DMALEN		0x16
#define FM_REC_DMABUF1		0x18
#define FM_REC_DMABUF2		0x1c

#define FM_CODEC_CTL		0x22
#define FM_VOLUME		0x26
#define  FM_VOLUME_MUTE			0x8000

#define FM_CODEC_CMD		0x2a
#define  FM_CODEC_CMD_READ		0x0080
#define  FM_CODEC_CMD_VALID		0x0100
#define  FM_CODEC_CMD_BUSY		0x0200

#define FM_CODEC_DATA		0x2c

#define FM_IO_CTL		0x52
#define FM_CARD_CTL		0x54

#define FM_INTMASK		0x56
#define  FM_INTMASK_PLAY		0x0001
#define  FM_INTMASK_REC			0x0002
#define  FM_INTMASK_VOL			0x0040
#define  FM_INTMASK_MPU			0x0080

#define FM_INTSTATUS		0x5a
#define  FM_INTSTATUS_PLAY		0x0100
#define  FM_INTSTATUS_REC		0x0200
#define  FM_INTSTATUS_VOL		0x4000
#define  FM_INTSTATUS_MPU		0x8000



d270 11
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.6 2002/01/20 19:56:53 ericj Exp $ */
d100 4
a103 4
int	fms_trigger_output __P((void *, void *, void *, int, void (*)(void *),
				void *, struct audio_params *));
int	fms_trigger_input __P((void *, void *, void *, int, void (*)(void *),
			       void *, struct audio_params *));
@


1.6
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.5 2001/10/31 11:00:24 art Exp $ */
d79 21
a99 21
int	fms_match __P((struct device *, void *, void *));
void	fms_attach __P((struct device *, struct device *, void *));
int	fms_intr __P((void *));

int	fms_open __P((void *, int));
void	fms_close __P((void *));
int	fms_query_encoding __P((void *, struct audio_encoding *));
int	fms_set_params __P((void *, int, int, struct audio_params *, 
			    struct audio_params *));
int	fms_round_blocksize __P((void *, int));
int	fms_halt_output __P((void *));
int	fms_halt_input __P((void *));
int	fms_getdev __P((void *, struct audio_device *));
int	fms_set_port __P((void *, mixer_ctrl_t *));
int	fms_get_port __P((void *, mixer_ctrl_t *));
int	fms_query_devinfo __P((void *, mixer_devinfo_t *));
void	*fms_malloc __P((void *, int, size_t, int, int));
void	fms_free __P((void *, void *, int));
size_t	fms_round_buffersize __P((void *, int, size_t));
paddr_t	fms_mappage __P((void *, void *, off_t, int));
int	fms_get_props __P((void *));
d149 8
a156 8
int	fms_attach_codec __P((void *, struct ac97_codec_if *));
int	fms_read_codec __P((void *, u_int8_t, u_int16_t *));
int	fms_write_codec __P((void *, u_int8_t, u_int16_t));
void	fms_reset_codec __P((void *));

int	fms_allocmem __P((struct fms_softc *, size_t, size_t,
			  struct fms_dma *));
int	fms_freemem __P((struct fms_softc *, struct fms_dma *));
d898 1
a898 1
	void (*intr) __P((void *));
d936 1
a936 1
	void (*intr) __P((void *));
@


1.5
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.4 2001/08/25 10:13:29 art Exp $ */
d140 1
a140 1
	NULL,
d142 1
a142 1
	NULL,
d146 1
a146 3
	fms_trigger_input,
	fms_malloc,
	fms_round_buffersize,
@


1.5.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.6 2002/01/20 19:56:53 ericj Exp $ */
d140 1
a140 1
	fms_malloc,
d142 1
a142 1
	fms_round_buffersize,
d146 3
a148 1
	fms_trigger_input
@


1.5.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.5.2.1 2002/01/31 22:55:34 niklas Exp $ */
a43 2
#include "radio.h"

a65 1
#include <dev/pci/fmsreg.h>
d79 25
a103 25
int	fms_match(struct device *, void *, void *);
void	fms_attach(struct device *, struct device *, void *);
int	fms_intr(void *);

int	fms_open(void *, int);
void	fms_close(void *);
int	fms_query_encoding(void *, struct audio_encoding *);
int	fms_set_params(void *, int, int, struct audio_params *, 
			    struct audio_params *);
int	fms_round_blocksize(void *, int);
int	fms_halt_output(void *);
int	fms_halt_input(void *);
int	fms_getdev(void *, struct audio_device *);
int	fms_set_port(void *, mixer_ctrl_t *);
int	fms_get_port(void *, mixer_ctrl_t *);
int	fms_query_devinfo(void *, mixer_devinfo_t *);
void	*fms_malloc(void *, int, size_t, int, int);
void	fms_free(void *, void *, int);
size_t	fms_round_buffersize(void *, int, size_t);
paddr_t	fms_mappage(void *, void *, off_t, int);
int	fms_get_props(void *);
int	fms_trigger_output(void *, void *, void *, int, void (*)(void *),
			   void *, struct audio_params *);
int	fms_trigger_input(void *, void *, void *, int, void (*)(void *),
			  void *, struct audio_params *);
d149 71
a219 8
int	fms_attach_codec(void *, struct ac97_codec_if *);
int	fms_read_codec(void *, u_int8_t, u_int16_t *);
int	fms_write_codec(void *, u_int8_t, u_int16_t);
void	fms_reset_codec(void *);

int	fms_allocmem(struct fms_softc *, size_t, size_t,
			  struct fms_dma *);
int	fms_freemem(struct fms_softc *, struct fms_dma *);
d246 1
a249 3
	bus_size_t iosize;
	const char *intrstr;
	u_int16_t k1;
d252 1
a252 5
	if (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
d254 1
a254 13
	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh, 0x30, 2,
	    &sc->sc_mpu_ioh)) {
		printf(": can't get mpu subregion handle\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}

	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh, 0x68, 4,
	    &sc->sc_opl_ioh)) {
		printf(": can't get opl subregion handle\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}
d257 1
a257 2
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
d265 1
a265 1
		printf(": couldn't establish interrupt");
a268 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
d272 13
a284 1
	printf(": %s\n", intrstr);
d286 3
a288 1
	sc->sc_dmat = pa->pa_dmat;
a313 4

#if NRADIO > 0
	fmsradio_attach(sc);
#endif /* NRADIO > 0 */
d898 1
a898 1
	void (*intr)(void *);
d936 1
a936 1
	void (*intr)(void *);
@


1.5.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.5.2.2 2002/06/11 03:42:24 art Exp $ */
d863 1
a863 1
		      "address (%p)", start);
d901 1
a901 1
		      "address (%p)", start);
@


1.5.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d169 6
a174 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_FORTEMEDIA &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_FORTEMEDIA_FM801)
		return (1);
	return (0);
d470 1
a470 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d476 1
a476 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d482 1
a482 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d488 1
a488 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d494 1
a494 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d500 1
a500 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d506 1
a506 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d512 1
a512 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
@


1.4
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.3 2001/06/12 15:40:30 niklas Exp $ */
d98 1
a98 1
int	fms_mappage __P((void *, void *, int, int));
d855 1
a855 1
int
d859 1
a859 1
	int off;
@


1.3
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.2 2000/10/14 18:04:07 aaron Exp $ */
d258 1
a258 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
			 &ih)) {
@


1.2
log
@Add $OpenBSD$ tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d280 1
a280 1
			   &sc->sc_ioh, &sc->sc_ioaddr, &sc->sc_iosize)) {
@


1.2.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.2 2000/10/14 18:04:07 aaron Exp $ */
@


1.2.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.2.6.1 2001/05/14 22:25:41 niklas Exp $ */
d280 1
a280 1
			   &sc->sc_ioh, &sc->sc_ioaddr, &sc->sc_iosize, 0)) {
@


1.2.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.2.6.2 2001/07/04 10:42:04 niklas Exp $ */
d258 2
a259 1
	if (pci_intr_map(pa, &ih)) {
@


1.2.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d98 1
a98 1
paddr_t	fms_mappage __P((void *, void *, off_t, int));
d855 1
a855 1
paddr_t
d859 1
a859 1
	off_t off;
@


1.2.6.5
log
@Merge in trunk
@
text
@d140 1
a140 1
	fms_malloc,
d142 1
a142 1
	fms_round_buffersize,
d146 3
a148 1
	fms_trigger_input
@


1.2.6.6
log
@Merge in -current from roughly a week ago
@
text
@d79 25
a103 25
int	fms_match(struct device *, void *, void *);
void	fms_attach(struct device *, struct device *, void *);
int	fms_intr(void *);

int	fms_open(void *, int);
void	fms_close(void *);
int	fms_query_encoding(void *, struct audio_encoding *);
int	fms_set_params(void *, int, int, struct audio_params *, 
			    struct audio_params *);
int	fms_round_blocksize(void *, int);
int	fms_halt_output(void *);
int	fms_halt_input(void *);
int	fms_getdev(void *, struct audio_device *);
int	fms_set_port(void *, mixer_ctrl_t *);
int	fms_get_port(void *, mixer_ctrl_t *);
int	fms_query_devinfo(void *, mixer_devinfo_t *);
void	*fms_malloc(void *, int, size_t, int, int);
void	fms_free(void *, void *, int);
size_t	fms_round_buffersize(void *, int, size_t);
paddr_t	fms_mappage(void *, void *, off_t, int);
int	fms_get_props(void *);
int	fms_trigger_output(void *, void *, void *, int, void (*)(void *),
			   void *, struct audio_params *);
int	fms_trigger_input(void *, void *, void *, int, void (*)(void *),
			  void *, struct audio_params *);
d149 8
a156 8
int	fms_attach_codec(void *, struct ac97_codec_if *);
int	fms_read_codec(void *, u_int8_t, u_int16_t *);
int	fms_write_codec(void *, u_int8_t, u_int16_t);
void	fms_reset_codec(void *);

int	fms_allocmem(struct fms_softc *, size_t, size_t,
			  struct fms_dma *);
int	fms_freemem(struct fms_softc *, struct fms_dma *);
d898 1
a898 1
	void (*intr)(void *);
d936 1
a936 1
	void (*intr)(void *);
@


1.2.6.7
log
@Sync the SMP branch with 3.3
@
text
@a43 2
#include "radio.h"

a65 1
#include <dev/pci/fmsreg.h>
d158 63
d229 6
a234 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_FORTEMEDIA &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_FORTEMEDIA_FM801)
		return (1);
	return (0);
d246 1
a249 3
	bus_size_t iosize;
	const char *intrstr;
	u_int16_t k1;
d252 1
a252 5
	if (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
d254 1
a254 13
	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh, 0x30, 2,
	    &sc->sc_mpu_ioh)) {
		printf(": can't get mpu subregion handle\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}

	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh, 0x68, 4,
	    &sc->sc_opl_ioh)) {
		printf(": can't get opl subregion handle\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}
d257 1
a257 2
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
d265 1
a265 1
		printf(": couldn't establish interrupt");
a268 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
d272 13
a284 1
	printf(": %s\n", intrstr);
d286 3
a288 1
	sc->sc_dmat = pa->pa_dmat;
a313 4

#if NRADIO > 0
	fmsradio_attach(sc);
#endif /* NRADIO > 0 */
d913 1
a913 1
		      "address (%p)", start);
d951 1
a951 1
		      "address (%p)", start);
@


1.2.6.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: fms.c,v 1.2.6.7 2003/03/28 00:38:21 niklas Exp $ */
d468 1
a468 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d474 1
a474 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d480 1
a480 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d486 1
a486 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d492 1
a492 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d498 1
a498 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d504 1
a504 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d510 1
a510 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
@


1.1
log
@new auvia and fms drivers from netbsd (testing requests sent out, since i cannot find any of these devices)
@
text
@d1 1
@

