head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.28
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.26
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.24
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.12
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.20
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.18
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.16
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.14
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.10
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.28
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.26
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.22
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.24
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.20
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.18
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.16
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.16
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.12
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.13.17.30.27;	author pvalchev;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.15.21.30.25;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.14.15.00.03;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.25.10.13.29;	author art;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.08.20.04.41.39;	author smart;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.29.00.16.32;	author smart;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.10.11.12.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.08.12.18.33.25;	author niklas;	state Exp;
branches
	1.4.12.1;
next	1.3;

1.3
date	96.11.28.23.28.02;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.11.12.20.30.49;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.07.27.07.20.07;	author deraadt;	state Exp;
branches;
next	;

1.4.12.1
date	2001.05.14.22.25.39;	author niklas;	state Exp;
branches;
next	1.4.12.2;

1.4.12.2
date	2001.07.04.10.41.59;	author niklas;	state Exp;
branches;
next	1.4.12.3;

1.4.12.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.4.12.4;

1.4.12.4
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.4.12.5;

1.4.12.5
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.4.12.6;

1.4.12.6
date	2004.06.13.22.12.45;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@/*	$OpenBSD: cy_pci.c,v 1.13 2004/06/13 17:30:27 pvalchev Exp $	*/
/*
 * Copyright (c) 1996 Timo Rossi.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * cy_pci.c
 *
 * Driver for Cyclades Cyclom-8/16/32 multiport serial cards
 * (currently not tested with Cyclom-32 cards)
 *
 * Timo Rossi, 1996
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/cd1400reg.h>
#include <dev/ic/cyreg.h>

int cy_pci_match(struct device *, void *, void *);
void cy_pci_attach(struct device *, struct device *, void *);

struct cy_pci_softc {
	struct cy_softc 	sc_cy;		/* real softc */

	bus_space_tag_t		sc_iot;		/* PLX i/o tag */
	bus_space_handle_t	sc_ioh;		/* PLX i/o handle */
};

struct cfattach cy_pci_ca = {
	sizeof(struct cy_pci_softc), cy_pci_match, cy_pci_attach
};

#define CY_PLX_9050_ICS_IENABLE		0x040
#define CY_PLX_9050_ICS_LOCAL_IENABLE	0x001
#define CY_PLX_9050_ICS_LOCAL_IPOLARITY	0x002
#define CY_PLX_9060_ICS_IENABLE		0x100
#define CY_PLX_9060_ICS_LOCAL_IENABLE	0x800

const struct pci_matchid cy_pci_devices[] = {
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOMY_1 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOMY_2 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM4Y_1 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM4Y_2 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM8Y_1 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM8Y_2 },
};

int
cy_pci_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	return (pci_matchbyid((struct pci_attach_args *)aux, cy_pci_devices,
	    nitems(cy_pci_devices)));
}

void
cy_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct cy_pci_softc *psc = (struct cy_pci_softc *)self;
	struct cy_softc *sc = (struct cy_softc *)self;
	struct pci_attach_args *pa = aux;
	const char *intrstr = NULL;
	pci_intr_handle_t ih;
	pcireg_t memtype;
	int plx_ver;

	sc->sc_bustype = CY_BUSTYPE_PCI;

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_CYCLADES_CYCLOMY_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_1:
		memtype = PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT_1M;
		break;
	case PCI_PRODUCT_CYCLADES_CYCLOMY_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_2:
		memtype = PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT;
		break;
	}

	if (pci_mapreg_map(pa, 0x14, PCI_MAPREG_TYPE_IO, 0,
	    &psc->sc_iot, &psc->sc_ioh, NULL, NULL, 0) != 0) {
		printf(": unable to map PLX registers\n");
		return;
	}

	if (pci_mapreg_map(pa, 0x18, memtype, 0, &sc->sc_memt,
	    &sc->sc_memh, NULL, NULL, 0) != 0) {
                printf(": couldn't map device registers\n");
                return;
        }

	if ((sc->sc_nr_cd1400s = cy_probe_common(sc->sc_memt, sc->sc_memh,
	    CY_BUSTYPE_PCI)) == 0) {
		printf(": PCI Cyclom card with no CD1400s\n");
		return;
	}

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": couldn't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_TTY, cy_intr,
	    sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s", intrstr);

	cy_attach(parent, self);

	/* Get PLX version */
	plx_ver = bus_space_read_1(sc->sc_memt, sc->sc_memh, CY_PLX_VER) & 0x0f;

	/* Enable PCI card interrupts */
	switch (plx_ver) {
	case CY_PLX_9050:
		bus_space_write_2(psc->sc_iot, psc->sc_ioh, CY_PCI_INTENA_9050,
		    CY_PLX_9050_ICS_IENABLE | CY_PLX_9050_ICS_LOCAL_IENABLE |
		    CY_PLX_9050_ICS_LOCAL_IPOLARITY);
		break;

	case CY_PLX_9060:
	case CY_PLX_9080:
	default:
		bus_space_write_2(psc->sc_iot, psc->sc_ioh, CY_PCI_INTENA,
		    bus_space_read_2(psc->sc_iot, psc->sc_ioh,
		    CY_PCI_INTENA) | CY_PLX_9060_ICS_IENABLE | 
		    CY_PLX_9060_ICS_LOCAL_IENABLE);
	}
}
@


1.13
log
@cy_attach improvements; ok art
- don't panic if you can't setup interrupts, just quit attach
- cleanup printf's, show a better error message
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.12 2002/11/19 18:40:17 jason Exp $	*/
d88 1
a88 1
	    sizeof(cy_pci_devices)/sizeof(cy_pci_devices[0])));
@


1.12
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.11 2002/09/15 21:30:25 art Exp $	*/
d99 1
d121 1
a121 2
		printf("%s: unable to map PLX registers\n",
		    sc->sc_dev.dv_xname);
d127 1
a127 2
                printf("%s: couldn't map device registers\n",
		    sc->sc_dev.dv_xname);
d133 1
a133 2
		printf("%s: PCI Cyclom card with no CD1400s\n",
		    sc->sc_dev.dv_xname);
d137 4
a140 2
	if (pci_intr_map(pa, &ih) != 0)
		panic("%s: couldn't map PCI interrupt", sc->sc_dev.dv_xname);
d142 1
d145 8
a152 2
	if (sc->sc_ih == NULL)
		panic("%s: couldn't establish interrupt", sc->sc_dev.dv_xname);
@


1.11
log
@Add a license from the author Timo Rossi <trossi@@co.jyu.fi>
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.10 2002/09/14 15:00:03 art Exp $	*/
d73 9
d87 2
a88 22
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_CYCLADES)
		return (0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_CYCLADES_CYCLOMY_1:
	case PCI_PRODUCT_CYCLADES_CYCLOMY_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_2:
		break;
	default:
		return (0);
	}

#ifdef CY_DEBUG
	printf("cy: Found Cyclades PCI device, id = 0x%x\n", pa->pa_id);
#endif

	return (1);
@


1.10
log
@Various fixes and cleanups in the cy driver.
Finally my "Cyclades Cyclom-8Y" works correctly.

Cleanups:
 - no more stupid arrays, we have softc structs, use them.
 - no more global poll timeout that walks an array, timeouts are now cheap,
   one poll per softc.
 - sc_dev.dv_xname is the correct thing to print in diagnostic printfs.
 - don't have bus-specific code in the generic attach for @@#%$! sake, it
   took 20 seconds to fix (I suspect that the workaround took much more
   time to write).
 - spltty, not splhigh.
 - use pci_mapreg_map, not pci_{io,mem}_find + bus_space_map.
 - use defines, not magic constants in a few places.
 - KNF in a few places (much more work needed).
Now the interesting parts:
 - when handling the interrupt, don't just ignore it when the tty is not
   open. Read and discard the data. If we don't read it, the card will
   interrupt again and again and again and ... (inspired by NetBSD).
 - actually enable interrupts on PLX9050
 - From FreeBSD: "Work around a PLX9050 bug that causes system lockup in
   certain systems"

deraadt@@ ok
@
text
@d1 29
a29 1
/*	$OpenBSD: cy_pci.c,v 1.9 2002/03/14 01:26:58 millert Exp $	*/
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.8 2001/08/25 10:13:29 art Exp $	*/
d28 7
d36 1
a36 1
	sizeof(struct cy_softc), cy_pci_match, cy_pci_attach
d39 6
d79 1
d83 1
a83 8
	bus_space_tag_t memt;
	bus_space_handle_t memh;
	bus_addr_t memaddr;
	bus_size_t memsize;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_addr_t iobase;
	bus_size_t iosize;
a84 1
	int cacheable;
d86 1
a86 2
        memt = pa->pa_memt;
        iot = pa->pa_iot;
d88 12
a99 6
        if (pci_mem_find(pa->pa_pc, pa->pa_tag, 0x18,
            &memaddr, &memsize, &cacheable) != 0) {
                printf("%s: can't find PCI card memory",
		    sc->sc_dev.dv_xname);
                return;
        }
d101 3
a103 3
        /* map the memory (non-cacheable) */
        if (bus_space_map(memt, memaddr, memsize, 0, &memh) != 0) {
                printf("%s: couldn't map PCI memory region\n",
d105 2
a106 2
                return;
        }
d108 3
a110 4
        /* the PCI Cyclom IO space is only used for enabling interrupts */
        if (pci_io_find(pa->pa_pc, pa->pa_tag, 0x14, &iobase, &iosize) != 0) {
                bus_space_unmap(memt, memh, memsize);
                printf("%s: couldn't find PCI io region\n",
d115 3
a117 3
        if (bus_space_map(iot, iobase, iosize, 0, &ioh) != 0) {
                bus_space_unmap(memt, memh, memsize);
                printf("%s: couldn't map PCI io region\n",
d119 2
a120 16
                return;
        }

#ifdef CY_DEBUG
        printf("%s: pci mapped mem 0x%lx (size %d), io 0x%x (size %d)\n",
            sc->sc_dev.dv_xname, memaddr, memsize, iobase, iosize);
#endif

        if (cy_probe_common(sc->sc_dev.dv_unit, memt, memh,
	    CY_BUSTYPE_PCI) == 0) {
                bus_space_unmap(memt, memh, memsize);
                bus_space_unmap(iot, ioh, iosize);
                printf("%s: PCI Cyclom card with no CD1400s!?\n",
		    sc->sc_dev.dv_xname);
                return;
        }
a121 21
	cy_attach(parent, self, aux);

        /* Get PLX version */
	memt = pa->pa_memt;
	iot = pa->pa_iot;
        plx_ver = bus_space_read_1(memt, memh, CY_PLX_VER) & 0x0f;

        /* Enable PCI card interrupts */
        switch (plx_ver) {
        case CY_PLX_9050:
                bus_space_write_2(iot, ioh, CY_PCI_INTENA_9050,
                bus_space_read_2(iot, ioh, CY_PCI_INTENA_9050) | 0x40);
                break;
        case CY_PLX_9060:
        case CY_PLX_9080:
        default:
                bus_space_write_2(iot, ioh, CY_PCI_INTENA,
                bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900);
        }
 
	/* Enable PCI card interrupts */
d127 7
d135 16
a150 2
        if (sc->sc_ih == NULL)
                panic("%s: couldn't establish interrupt", sc->sc_dev.dv_xname);
@


1.8
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.7 2001/08/20 04:41:39 smart Exp $	*/
d25 2
a26 2
int cy_pci_match __P((struct device *, void *, void *));
void cy_pci_attach __P((struct device *, struct device *, void *));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.8 2001/08/25 10:13:29 art Exp $	*/
d25 2
a26 2
int cy_pci_match(struct device *, void *, void *);
void cy_pci_attach(struct device *, struct device *, void *);
@


1.8.4.2
log
@sync to -current
@
text
@d1 1
a1 29
/*	$OpenBSD$	*/
/*
 * Copyright (c) 1996 Timo Rossi.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
a27 7
struct cy_pci_softc {
	struct cy_softc 	sc_cy;		/* real softc */

	bus_space_tag_t		sc_iot;		/* PLX i/o tag */
	bus_space_handle_t	sc_ioh;		/* PLX i/o handle */
};

d29 1
a29 1
	sizeof(struct cy_pci_softc), cy_pci_match, cy_pci_attach
a31 6
#define CY_PLX_9050_ICS_IENABLE		0x040
#define CY_PLX_9050_ICS_LOCAL_IENABLE	0x001
#define CY_PLX_9050_ICS_LOCAL_IPOLARITY	0x002
#define CY_PLX_9060_ICS_IENABLE		0x100
#define CY_PLX_9060_ICS_LOCAL_IENABLE	0x800

a65 1
	struct cy_pci_softc *psc = (struct cy_pci_softc *)self;
d69 8
a76 1
	pcireg_t memtype;
d78 4
d83 6
a88 1
	sc->sc_bustype = CY_BUSTYPE_PCI;
d90 6
a95 12
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_CYCLADES_CYCLOMY_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_1:
		memtype = PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT_1M;
		break;
	case PCI_PRODUCT_CYCLADES_CYCLOMY_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_2:
		memtype = PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT;
		break;
	}
d97 4
a100 3
	if (pci_mapreg_map(pa, 0x14, PCI_MAPREG_TYPE_IO, 0,
	    &psc->sc_iot, &psc->sc_ioh, NULL, NULL, 0) != 0) {
		printf("%s: unable to map PLX registers\n",
d102 2
a103 2
		return;
	}
d105 3
a107 3
	if (pci_mapreg_map(pa, 0x18, memtype, 0, &sc->sc_memt,
	    &sc->sc_memh, NULL, NULL, 0) != 0) {
                printf("%s: couldn't map device registers\n",
d112 10
a121 3
	if ((sc->sc_nr_cd1400s = cy_probe_common(sc->sc_memt, sc->sc_memh,
	    CY_BUSTYPE_PCI)) == 0) {
		printf("%s: PCI Cyclom card with no CD1400s\n",
d123 4
a126 2
		return;
	}
d128 19
a151 7
	if (sc->sc_ih == NULL)
		panic("%s: couldn't establish interrupt", sc->sc_dev.dv_xname);

	cy_attach(parent, self);

	/* Get PLX version */
	plx_ver = bus_space_read_1(sc->sc_memt, sc->sc_memh, CY_PLX_VER) & 0x0f;
d153 2
a154 16
	/* Enable PCI card interrupts */
	switch (plx_ver) {
	case CY_PLX_9050:
		bus_space_write_2(psc->sc_iot, psc->sc_ioh, CY_PCI_INTENA_9050,
		    CY_PLX_9050_ICS_IENABLE | CY_PLX_9050_ICS_LOCAL_IENABLE |
		    CY_PLX_9050_ICS_LOCAL_IPOLARITY);
		break;

	case CY_PLX_9060:
	case CY_PLX_9080:
	default:
		bus_space_write_2(psc->sc_iot, psc->sc_ioh, CY_PCI_INTENA,
		    bus_space_read_2(psc->sc_iot, psc->sc_ioh,
		    CY_PCI_INTENA) | CY_PLX_9060_ICS_IENABLE | 
		    CY_PLX_9060_ICS_LOCAL_IENABLE);
	}
@


1.8.4.3
log
@sync
@
text
@a72 9
const struct pci_matchid cy_pci_devices[] = {
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOMY_1 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOMY_2 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM4Y_1 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM4Y_2 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM8Y_1 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM8Y_2 },
};

d78 22
a99 2
	return (pci_matchbyid((struct pci_attach_args *)aux, cy_pci_devices,
	    sizeof(cy_pci_devices)/sizeof(cy_pci_devices[0])));
@


1.7
log
@Allow driver to recognize Cyclades 4Y and 8Y cards.

Not finished yet, but cleaned up and moved around code for
better organization.  Inspired by NetBSD and other PCI drivers.

From my dmesg:
     cy1 at pci0 dev 10 function 0 "Cyclades Cyclom-8Y" rev 0x01
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.6 2001/06/29 00:16:32 smart Exp $	*/
d147 1
a147 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih) != 0)
@


1.6
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.5 2000/12/10 11:12:07 deraadt Exp $	*/
d4 1
a4 1
 * cy.c
a9 15
 *
 * Supports both ISA and PCI Cyclom cards
 *
 * Uses CD1400 automatic CTS flow control, and
 * if CY_HW_RTS is defined, uses CD1400 automatic input flow control.
 * This requires a special cable that exchanges the RTS and DTR lines.
 *
 * Lots of debug output can be enabled by defining CY_DEBUG
 * Some debugging counters (number of receive/transmit interrupts etc.)
 * can be enabled by defining CY_DEBUG1
 *
 * This version uses the bus_mem/io_??() stuff
 *
 * NOT TESTED !!!
 *
a11 4
#undef CY_DEBUG
#undef CY_DEBUG1

#include <sys/types.h>
d13 1
a13 9
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/fcntl.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/conf.h>
#include <sys/user.h>
#include <sys/ioctl.h>
#include <sys/select.h>
d15 1
a15 2
#include <sys/malloc.h>
#include <sys/systm.h>
d17 1
d25 2
a26 10
/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))

int cy_probe_pci __P((struct device *, void *, void *));
int cy_probe_common __P((int card, bus_space_tag_t,
			 bus_space_handle_t, int bustype));

void cyattach __P((struct device *, struct device *, void *));
d29 1
a29 1
	sizeof(struct cy_softc), cy_probe_pci, cyattach
a31 3
/*
 * PCI probe
 */
d33 1
a33 1
cy_probe_pci(parent, match, aux)
a36 1
	int card = ((struct device *)match)->dv_unit;
d38 31
d77 1
a78 1
	int plx_ver;
d80 31
a110 4
	if (!(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CYCLADES &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_1 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_2)))
		return (0);
d113 2
a114 1
	printf("cy: Found Cyclades PCI device, id = 0x%x\n", pa->pa_id);
d117 12
d131 1
d133 17
a149 29
	if (pci_mem_find(pa->pa_pc, pa->pa_tag, 0x18,
	    &memaddr, &memsize, &cacheable) != 0) {
		printf("cy%d: can't find PCI card memory", card);
		return (0);
	}

	/* map the memory (non-cacheable) */
	if (bus_space_map(memt, memaddr, memsize, 0, &memh) != 0) {
		printf("cy%d: couldn't map PCI memory region\n", card);
		return (0);
	}

	/* the PCI Cyclom IO space is only used for enabling interrupts */
	if (pci_io_find(pa->pa_pc, pa->pa_tag, 0x14, &iobase, &iosize) != 0) {
		bus_space_unmap(memt, memh, memsize);
		printf("cy%d: couldn't find PCI io region\n", card);
		return (0);
	}

	if (bus_space_map(iot, iobase, iosize, 0, &ioh) != 0) {
		bus_space_unmap(memt, memh, memsize);
		printf("cy%d: couldn't map PCI io region\n", card);
		return (0); 
	}

#ifdef CY_DEBUG
	printf("cy%d: pci mapped mem 0x%lx (size %d), io 0x%x (size %d)\n",
	    card, memaddr, memsize, iobase, iosize);
#endif
d151 2
a152 6
	if (cy_probe_common(card, memt, memh, CY_BUSTYPE_PCI) == 0) {
		bus_space_unmap(memt, memh, memsize);
		bus_space_unmap(iot, ioh, iosize);
		printf("cy%d: PCI Cyclom card with no CD1400s!?\n", card);
		return (0);
	}
d154 2
a155 16
	/* Get PLX version */
	plx_ver = bus_space_read_1(memt, memh, CY_PLX_VER) & 0x0f;

	/* Enable PCI card interrupts */
	switch (plx_ver) {
	case CY_PLX_9050:
		bus_space_write_2(iot, ioh, CY_PCI_INTENA_9050,
		bus_space_read_2(iot, ioh, CY_PCI_INTENA_9050) | 0x40);
		break;                      
	case CY_PLX_9060:
	case CY_PLX_9080:
	default:
		bus_space_write_2(iot, ioh, CY_PCI_INTENA,
		bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900);
	}
	return (1);
@


1.5
log
@support newer cy cards; elektrosatan@@voltagenoir.org, pr#1479
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.4 1997/08/12 18:33:25 niklas Exp $	*/
d64 1
a64 1
  sizeof(struct cy_softc), cy_probe_pci, cyattach
d72 2
a73 2
     struct device *parent;
     void *match, *aux;
d75 17
a91 17
  int card = ((struct device *)match)->dv_unit;
  struct pci_attach_args *pa = aux;
  bus_space_tag_t memt;
  bus_space_handle_t memh;
  bus_addr_t memaddr;
  bus_size_t memsize;
  bus_space_tag_t iot;
  bus_space_handle_t ioh;
  bus_addr_t iobase;
  bus_size_t iosize;
  int cacheable;
  int plx_ver;

  if(!(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CYCLADES &&
       (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_1 ||
	PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_2)))
    return 0;
d94 1
a94 1
  printf("cy: Found Cyclades PCI device, id = 0x%x\n", pa->pa_id);
d97 2
a98 2
  memt = pa->pa_memt;
  iot = pa->pa_iot;
d100 24
a123 24
  if(pci_mem_find(pa->pa_pc, pa->pa_tag, 0x18,
		  &memaddr, &memsize, &cacheable) != 0) {
    printf("cy%d: can't find PCI card memory", card);
    return 0;
  }

  /* map the memory (non-cacheable) */
  if(bus_space_map(memt, memaddr, memsize, 0, &memh) != 0) {
    printf("cy%d: couldn't map PCI memory region\n", card);
    return 0;
  }

  /* the PCI Cyclom IO space is only used for enabling interrupts */
  if(pci_io_find(pa->pa_pc, pa->pa_tag, 0x14, &iobase, &iosize) != 0) {
    bus_space_unmap(memt, memh, memsize);
    printf("cy%d: couldn't find PCI io region\n", card);
    return 0;
  }

  if(bus_space_map(iot, iobase, iosize, 0, &ioh) != 0) {
    bus_space_unmap(memt, memh, memsize);
    printf("cy%d: couldn't map PCI io region\n", card);
    return 0; 
  }
d126 2
a127 2
  printf("cy%d: pci mapped mem 0x%lx (size %d), io 0x%x (size %d)\n",
	 card, memaddr, memsize, iobase, iosize);
d130 23
a152 23
  if(cy_probe_common(card, memt, memh, CY_BUSTYPE_PCI) == 0) {
    bus_space_unmap(memt, memh, memsize);
    bus_space_unmap(iot, ioh, iosize);
    printf("cy%d: PCI Cyclom card with no CD1400s!?\n", card);
    return 0;
  }

  /* Get PLX version */
  plx_ver = bus_space_read_1(memt, memh, CY_PLX_VER) & 0x0f;

  /* Enable PCI card interrupts */
  switch (plx_ver) {
  case CY_PLX_9050:
          bus_space_write_2(iot, ioh, CY_PCI_INTENA_9050,
              bus_space_read_2(iot, ioh, CY_PCI_INTENA_9050) | 0x40);
          break;                      
  case CY_PLX_9060:
  case CY_PLX_9080:
  default:
          bus_space_write_2(iot, ioh, CY_PCI_INTENA,
              bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900);
  }
  return 1;
@


1.4
log
@Removed unused vars. Added missing arg to bus_space_map.
Reported by Berndt Josef Wulf <wulf@@ping.net.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.3 1996/11/28 23:28:02 niklas Exp $	*/
d86 1
d137 3
d141 11
a151 3
  bus_space_write_2(iot, ioh, CY_PCI_INTENA,
      bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900);

@


1.4.12.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.5 2000/12/10 11:12:07 deraadt Exp $	*/
a85 1
  int plx_ver;
d136 3
a138 2
  /* Get PLX version */
  plx_ver = bus_space_read_1(memt, memh, CY_PLX_VER) & 0x0f;
a139 12
  /* Enable PCI card interrupts */
  switch (plx_ver) {
  case CY_PLX_9050:
          bus_space_write_2(iot, ioh, CY_PCI_INTENA_9050,
              bus_space_read_2(iot, ioh, CY_PCI_INTENA_9050) | 0x40);
          break;                      
  case CY_PLX_9060:
  case CY_PLX_9080:
  default:
          bus_space_write_2(iot, ioh, CY_PCI_INTENA,
              bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900);
  }
@


1.4.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.4.12.1 2001/05/14 22:25:39 niklas Exp $	*/
d64 1
a64 1
	sizeof(struct cy_softc), cy_probe_pci, cyattach
d72 2
a73 2
	struct device *parent;
	void *match, *aux;
d75 17
a91 17
	int card = ((struct device *)match)->dv_unit;
	struct pci_attach_args *pa = aux;
	bus_space_tag_t memt;
	bus_space_handle_t memh;
	bus_addr_t memaddr;
	bus_size_t memsize;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_addr_t iobase;
	bus_size_t iosize;
	int cacheable;
	int plx_ver;

	if (!(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CYCLADES &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_1 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CYCLADES_CYCLOMY_2)))
		return (0);
d94 1
a94 1
	printf("cy: Found Cyclades PCI device, id = 0x%x\n", pa->pa_id);
d97 2
a98 2
	memt = pa->pa_memt;
	iot = pa->pa_iot;
d100 24
a123 24
	if (pci_mem_find(pa->pa_pc, pa->pa_tag, 0x18,
	    &memaddr, &memsize, &cacheable) != 0) {
		printf("cy%d: can't find PCI card memory", card);
		return (0);
	}

	/* map the memory (non-cacheable) */
	if (bus_space_map(memt, memaddr, memsize, 0, &memh) != 0) {
		printf("cy%d: couldn't map PCI memory region\n", card);
		return (0);
	}

	/* the PCI Cyclom IO space is only used for enabling interrupts */
	if (pci_io_find(pa->pa_pc, pa->pa_tag, 0x14, &iobase, &iosize) != 0) {
		bus_space_unmap(memt, memh, memsize);
		printf("cy%d: couldn't find PCI io region\n", card);
		return (0);
	}

	if (bus_space_map(iot, iobase, iosize, 0, &ioh) != 0) {
		bus_space_unmap(memt, memh, memsize);
		printf("cy%d: couldn't map PCI io region\n", card);
		return (0); 
	}
d126 2
a127 2
	printf("cy%d: pci mapped mem 0x%lx (size %d), io 0x%x (size %d)\n",
	    card, memaddr, memsize, iobase, iosize);
d130 23
a152 23
	if (cy_probe_common(card, memt, memh, CY_BUSTYPE_PCI) == 0) {
		bus_space_unmap(memt, memh, memsize);
		bus_space_unmap(iot, ioh, iosize);
		printf("cy%d: PCI Cyclom card with no CD1400s!?\n", card);
		return (0);
	}

	/* Get PLX version */
	plx_ver = bus_space_read_1(memt, memh, CY_PLX_VER) & 0x0f;

	/* Enable PCI card interrupts */
	switch (plx_ver) {
	case CY_PLX_9050:
		bus_space_write_2(iot, ioh, CY_PCI_INTENA_9050,
		bus_space_read_2(iot, ioh, CY_PCI_INTENA_9050) | 0x40);
		break;                      
	case CY_PLX_9060:
	case CY_PLX_9080:
	default:
		bus_space_write_2(iot, ioh, CY_PCI_INTENA,
		bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900);
	}
	return (1);
@


1.4.12.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.4.12.2 2001/07/04 10:41:59 niklas Exp $	*/
d4 1
a4 1
 * cy_pci.c
d10 15
d27 4
d32 11
a43 2
#include <sys/device.h>

a44 1

d52 10
a61 2
int cy_pci_match __P((struct device *, void *, void *));
void cy_pci_attach __P((struct device *, struct device *, void *));
d64 1
a64 1
	sizeof(struct cy_softc), cy_pci_match, cy_pci_attach
d67 3
d71 1
a71 1
cy_pci_match(parent, match, aux)
d75 1
a76 31

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_CYCLADES)
		return (0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_CYCLADES_CYCLOMY_1:
	case PCI_PRODUCT_CYCLADES_CYCLOMY_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_2:
		break;
	default:
		return (0);
	}

#ifdef CY_DEBUG
	printf("cy: Found Cyclades PCI device, id = 0x%x\n", pa->pa_id);
#endif

	return (1);
}

void
cy_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct cy_softc *sc = (struct cy_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
d85 1
a86 1
	int cacheable;
d88 4
a91 31
        memt = pa->pa_memt;
        iot = pa->pa_iot;

        if (pci_mem_find(pa->pa_pc, pa->pa_tag, 0x18,
            &memaddr, &memsize, &cacheable) != 0) {
                printf("%s: can't find PCI card memory",
		    sc->sc_dev.dv_xname);
                return;
        }

        /* map the memory (non-cacheable) */
        if (bus_space_map(memt, memaddr, memsize, 0, &memh) != 0) {
                printf("%s: couldn't map PCI memory region\n",
		    sc->sc_dev.dv_xname);
                return;
        }

        /* the PCI Cyclom IO space is only used for enabling interrupts */
        if (pci_io_find(pa->pa_pc, pa->pa_tag, 0x14, &iobase, &iosize) != 0) {
                bus_space_unmap(memt, memh, memsize);
                printf("%s: couldn't find PCI io region\n",
		    sc->sc_dev.dv_xname);
                return;
        }

        if (bus_space_map(iot, iobase, iosize, 0, &ioh) != 0) {
                bus_space_unmap(memt, memh, memsize);
                printf("%s: couldn't map PCI io region\n",
		    sc->sc_dev.dv_xname);
                return;
        }
d94 1
a94 2
        printf("%s: pci mapped mem 0x%lx (size %d), io 0x%x (size %d)\n",
            sc->sc_dev.dv_xname, memaddr, memsize, iobase, iosize);
d97 21
a117 8
        if (cy_probe_common(sc->sc_dev.dv_unit, memt, memh,
	    CY_BUSTYPE_PCI) == 0) {
                bus_space_unmap(memt, memh, memsize);
                bus_space_unmap(iot, ioh, iosize);
                printf("%s: PCI Cyclom card with no CD1400s!?\n",
		    sc->sc_dev.dv_xname);
                return;
        }
d119 5
a123 1
	cy_attach(parent, self, aux);
d125 4
a128 4
        /* Get PLX version */
	memt = pa->pa_memt;
	iot = pa->pa_iot;
        plx_ver = bus_space_read_1(memt, memh, CY_PLX_VER) & 0x0f;
d130 6
a135 16
        /* Enable PCI card interrupts */
        switch (plx_ver) {
        case CY_PLX_9050:
                bus_space_write_2(iot, ioh, CY_PCI_INTENA_9050,
                bus_space_read_2(iot, ioh, CY_PCI_INTENA_9050) | 0x40);
                break;
        case CY_PLX_9060:
        case CY_PLX_9080:
        default:
                bus_space_write_2(iot, ioh, CY_PCI_INTENA,
                bus_space_read_2(iot, ioh, CY_PCI_INTENA) | 0x900);
        }
 
	/* Enable PCI card interrupts */
	if (pci_intr_map(pa, &ih) != 0)
		panic("%s: couldn't map PCI interrupt", sc->sc_dev.dv_xname);
d137 2
a138 2
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_TTY, cy_intr,
	    sc, sc->sc_dev.dv_xname);
d140 13
a152 2
        if (sc->sc_ih == NULL)
                panic("%s: couldn't establish interrupt", sc->sc_dev.dv_xname);
@


1.4.12.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d25 2
a26 2
int cy_pci_match(struct device *, void *, void *);
void cy_pci_attach(struct device *, struct device *, void *);
@


1.4.12.5
log
@Sync the SMP branch with 3.3
@
text
@a1 28
/*
 * Copyright (c) 1996 Timo Rossi.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
a27 7
struct cy_pci_softc {
	struct cy_softc 	sc_cy;		/* real softc */

	bus_space_tag_t		sc_iot;		/* PLX i/o tag */
	bus_space_handle_t	sc_ioh;		/* PLX i/o handle */
};

d29 1
a29 16
	sizeof(struct cy_pci_softc), cy_pci_match, cy_pci_attach
};

#define CY_PLX_9050_ICS_IENABLE		0x040
#define CY_PLX_9050_ICS_LOCAL_IENABLE	0x001
#define CY_PLX_9050_ICS_LOCAL_IPOLARITY	0x002
#define CY_PLX_9060_ICS_IENABLE		0x100
#define CY_PLX_9060_ICS_LOCAL_IENABLE	0x800

const struct pci_matchid cy_pci_devices[] = {
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOMY_1 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOMY_2 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM4Y_1 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM4Y_2 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM8Y_1 },
	{ PCI_VENDOR_CYCLADES, PCI_PRODUCT_CYCLADES_CYCLOM8Y_2 },
d37 22
a58 2
	return (pci_matchbyid((struct pci_attach_args *)aux, cy_pci_devices,
	    sizeof(cy_pci_devices)/sizeof(cy_pci_devices[0])));
a65 1
	struct cy_pci_softc *psc = (struct cy_pci_softc *)self;
d69 8
a76 1
	pcireg_t memtype;
d78 1
d80 2
a81 1
	sc->sc_bustype = CY_BUSTYPE_PCI;
d83 13
a95 12
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_CYCLADES_CYCLOMY_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_1:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_1:
		memtype = PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT_1M;
		break;
	case PCI_PRODUCT_CYCLADES_CYCLOMY_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM4Y_2:
	case PCI_PRODUCT_CYCLADES_CYCLOM8Y_2:
		memtype = PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT;
		break;
	}
d97 4
a100 3
	if (pci_mapreg_map(pa, 0x14, PCI_MAPREG_TYPE_IO, 0,
	    &psc->sc_iot, &psc->sc_ioh, NULL, NULL, 0) != 0) {
		printf("%s: unable to map PLX registers\n",
d102 2
a103 2
		return;
	}
d105 3
a107 3
	if (pci_mapreg_map(pa, 0x18, memtype, 0, &sc->sc_memt,
	    &sc->sc_memh, NULL, NULL, 0) != 0) {
                printf("%s: couldn't map device registers\n",
d112 10
a121 3
	if ((sc->sc_nr_cd1400s = cy_probe_common(sc->sc_memt, sc->sc_memh,
	    CY_BUSTYPE_PCI)) == 0) {
		printf("%s: PCI Cyclom card with no CD1400s\n",
d123 4
a126 2
		return;
	}
d128 19
a151 2
	if (sc->sc_ih == NULL)
		panic("%s: couldn't establish interrupt", sc->sc_dev.dv_xname);
d153 2
a154 21
	cy_attach(parent, self);

	/* Get PLX version */
	plx_ver = bus_space_read_1(sc->sc_memt, sc->sc_memh, CY_PLX_VER) & 0x0f;

	/* Enable PCI card interrupts */
	switch (plx_ver) {
	case CY_PLX_9050:
		bus_space_write_2(psc->sc_iot, psc->sc_ioh, CY_PCI_INTENA_9050,
		    CY_PLX_9050_ICS_IENABLE | CY_PLX_9050_ICS_LOCAL_IENABLE |
		    CY_PLX_9050_ICS_LOCAL_IPOLARITY);
		break;

	case CY_PLX_9060:
	case CY_PLX_9080:
	default:
		bus_space_write_2(psc->sc_iot, psc->sc_ioh, CY_PCI_INTENA,
		    bus_space_read_2(psc->sc_iot, psc->sc_ioh,
		    CY_PCI_INTENA) | CY_PLX_9060_ICS_IENABLE | 
		    CY_PLX_9060_ICS_LOCAL_IENABLE);
	}
@


1.4.12.6
log
@Make the branch reflect the trunk at the debranch instant
@
text
@a98 1
	const char *intrstr = NULL;
d120 2
a121 1
		printf(": unable to map PLX registers\n");
d127 2
a128 1
                printf(": couldn't map device registers\n");
d134 2
a135 1
		printf(": PCI Cyclom card with no CD1400s\n");
d139 2
a140 4
	if (pci_intr_map(pa, &ih) != 0) {
		printf(": couldn't map interrupt\n");
		return;
	}
a141 1
	intrstr = pci_intr_string(pa->pa_pc, ih);
d144 2
a145 8
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s", intrstr);
@


1.3
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.2 1996/11/12 20:30:49 niklas Exp $	*/
a74 1
  vm_offset_t v_addr, p_addr;
d118 1
a118 1
  if(bus_space_map(iot, iobase, iosize, &ioh) != 0) {
@


1.2
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: cy_pci.c,v 1.1 1996/07/27 07:20:07 deraadt Exp $	*/
d44 1
a44 1
#include <machine/bus.old.h>
d58 2
a59 2
int cy_probe_common __P((int card, bus_chipset_tag_t,
			 bus_mem_handle_t, int bustype));
d78 8
a85 7
  bus_chipset_tag_t bc;
  bus_mem_handle_t memh;
  bus_mem_addr_t memaddr;
  bus_mem_size_t memsize;
  bus_io_handle_t ioh;
  bus_io_addr_t iobase;
  bus_io_size_t iosize;
d97 2
a98 1
  bc = pa->pa_bc;
d107 1
a107 1
  if(bus_mem_map(bc, memaddr, memsize, 0, &memh) != 0) {
d114 1
a114 1
    bus_mem_unmap(bc, memh, memsize);
d119 2
a120 2
  if(bus_io_map(bc, iobase, iosize, &ioh) != 0) {
    bus_mem_unmap(bc, memh, memsize);
d130 3
a132 3
  if(cy_probe_common(card, bc, memh, CY_BUSTYPE_PCI) == 0) {
    bus_mem_unmap(bc, memh, memsize);
    bus_io_unmap(bc, ioh, iosize);
d138 2
a139 2
  bus_io_write_2(bc, ioh, CY_PCI_INTENA,
		 bus_io_read_2(bc, ioh, CY_PCI_INTENA) | 0x900);
@


1.1
log
@split cy driver up
@
text
@d1 1
a1 1
/*	$OpenBSD: cy.c,v 1.4 1996/06/23 13:11:05 deraadt Exp $	*/
d44 1
a44 1
#include <machine/bus.h>
@
