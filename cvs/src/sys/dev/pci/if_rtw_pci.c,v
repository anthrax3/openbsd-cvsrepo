head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.8
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.4
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.10
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.8
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.6
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.7.0.8
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.20
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.19;
commitid	5gdEnqVoJuTuwdTu;

1.19
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.18;
commitid	yM2VFFhpDTeFQlve;

1.18
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.17;
commitid	LS2TNeCue5R9L67C;

1.17
date	2012.12.05.23.20.20;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2010.08.29.16.47.00;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.26.20.40.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.02.01.11.32;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.22.23.00.45;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.22.03.16.35;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.05.11.09.08;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.29.02.58.31;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.15.03.42.57;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.09.10.51.25;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.31.00.16.15;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.29.01.02.30;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.20
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_rtw_pci.c,v 1.19 2014/12/22 02:28:52 tedu Exp $	*/
/*	$NetBSD: if_rtw_pci.c,v 1.1 2004/09/26 02:33:36 dyoung Exp $	*/

/*-
 * Copyright (c) 1998, 1999, 2000, 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center; Charles M. Hannum; and David Young.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI bus front-end for the Realtek RTL8180L 802.11 MAC/BBP chip.
 *
 * Derived from the ADMtek ADM8211 PCI bus front-end.
 *
 * Derived from the ``Tulip'' PCI bus front-end.
 */

#include <sys/param.h>
#include <sys/systm.h> 
#include <sys/mbuf.h>   
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/endian.h>
 
#include <net/if.h>
#include <net/if_media.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_radiotap.h>
#include <net80211/ieee80211_var.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/ic/rtwreg.h>
#include <dev/ic/sa2400reg.h>
#include <dev/ic/rtwvar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

int rtw_pci_enable(struct rtw_softc *);
void rtw_pci_disable(struct rtw_softc *);
int rtw_pci_detach(struct device *, int);

/*
 * PCI configuration space registers used by the RTL8180L.
 */
#define	RTW_PCI_IOBA		0x10	/* i/o mapped base */
#define	RTW_PCI_MMBA		0x14	/* memory mapped base */

struct rtw_pci_softc {
	struct rtw_softc	psc_rtw;	/* real RTL8180L softc */

	pci_intr_handle_t	psc_ih;		/* interrupt handle */
	void			*psc_intrcookie;

	pci_chipset_tag_t	psc_pc;		/* our PCI chipset */
	pcitag_t		psc_pcitag;	/* our PCI tag */
	bus_size_t		psc_mapsize;
};

int	rtw_pci_match(struct device *, void *, void *);
void	rtw_pci_attach(struct device *, struct device *, void *);

struct cfattach rtw_pci_ca = {
	sizeof (struct rtw_pci_softc), rtw_pci_match, rtw_pci_attach,
	    rtw_pci_detach, rtw_activate
};

const struct pci_matchid rtw_pci_products[] = {
	{ PCI_VENDOR_REALTEK,	PCI_PRODUCT_REALTEK_RT8180 },
#ifdef RTW_DEBUG
	{ PCI_VENDOR_REALTEK,	PCI_PRODUCT_REALTEK_RT8185 },
	{ PCI_VENDOR_BELKIN2,	PCI_PRODUCT_BELKIN2_F5D7010 },
#endif
	{ PCI_VENDOR_BELKIN2,	PCI_PRODUCT_BELKIN2_F5D6001 },
	{ PCI_VENDOR_BELKIN2,	PCI_PRODUCT_BELKIN2_F5D6020V3 },
	{ PCI_VENDOR_DLINK,	PCI_PRODUCT_DLINK_DWL610 },
};

int
rtw_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, rtw_pci_products,
	    nitems(rtw_pci_products)));
}

int
rtw_pci_enable(struct rtw_softc *sc)
{
	struct rtw_pci_softc *psc = (void *)sc;

	/* Establish the interrupt. */
	psc->psc_intrcookie = pci_intr_establish(psc->psc_pc, psc->psc_ih,
	    IPL_NET, rtw_intr, sc, sc->sc_dev.dv_xname);
	if (psc->psc_intrcookie == NULL) {
		printf("%s: unable to establish interrupt\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}

	return (0);
}

void
rtw_pci_disable(struct rtw_softc *sc)
{
	struct rtw_pci_softc *psc = (void *)sc;

	/* Unhook the interrupt handler. */
	pci_intr_disestablish(psc->psc_pc, psc->psc_intrcookie);
	psc->psc_intrcookie = NULL;
}

void
rtw_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct rtw_pci_softc *psc = (void *) self;
	struct rtw_softc *sc = &psc->psc_rtw;
	struct rtw_regs *regs = &sc->sc_regs;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	const char *intrstr = NULL;
	bus_space_tag_t iot, memt;
	bus_space_handle_t ioh, memh;
	bus_size_t iosize, memsize;
	int ioh_valid, memh_valid;

	psc->psc_pc = pa->pa_pc;
	psc->psc_pcitag = pa->pa_tag;

	/*
	 * No power management hooks.
	 * XXX Maybe we should add some!
	 */
	sc->sc_flags |= RTW_F_ENABLED;

	/*
	 * Get revision info, and set some chip-specific variables.
	 */
	sc->sc_rev = PCI_REVISION(pa->pa_class);

	pci_set_powerstate(pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map the device.
	 */
	ioh_valid = (pci_mapreg_map(pa, RTW_PCI_IOBA,
	    PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, NULL, &iosize, 0) == 0);
	memh_valid = (pci_mapreg_map(pa, RTW_PCI_MMBA,
	    PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &memt, &memh, NULL, &memsize, 0) == 0);

	if (memh_valid) {
		regs->r_bt = memt;
		regs->r_bh = memh;
		psc->psc_mapsize = memsize;
	} else if (ioh_valid) {
		regs->r_bt = iot;
		regs->r_bh = ioh;
		psc->psc_mapsize = iosize;
	} else {
		printf(": unable to map device registers\n");
		return;
	}

	sc->sc_dmat = pa->pa_dmat;

	/*
	 * Map and establish our interrupt.
	 */
	if (pci_intr_map(pa, &psc->psc_ih)) {
		printf(": unable to map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, psc->psc_ih); 
	psc->psc_intrcookie = pci_intr_establish(pc, psc->psc_ih, IPL_NET,
	    rtw_intr, sc, sc->sc_dev.dv_xname);
	if (psc->psc_intrcookie == NULL) {
		printf(": unable to establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}

	printf(": %s\n", intrstr);

	sc->sc_enable = rtw_pci_enable;
	sc->sc_disable = rtw_pci_disable;

	/*
	 * Finish off the attach.
	 */
	rtw_attach(sc);
}

int
rtw_pci_detach(struct device *self, int flags)
{
	struct rtw_pci_softc *psc = (void *)self;
	struct rtw_softc *sc = &psc->psc_rtw;
	struct rtw_regs *regs = &sc->sc_regs;
	int rv;

	rv = rtw_detach(sc);
	if (rv)
		return (rv);
	if (psc->psc_intrcookie != NULL)
		pci_intr_disestablish(psc->psc_pc, psc->psc_intrcookie);
	bus_space_unmap(regs->r_bt, regs->r_bh, psc->psc_mapsize);

	return (0);
}
@


1.19
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.18 2014/12/19 22:44:58 guenther Exp $	*/
a53 1
#include <net/if_dl.h>
@


1.18
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.17 2012/12/05 23:20:20 deraadt Exp $	*/
a55 1
#ifdef INET
a57 1
#endif
@


1.17
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.16 2012/10/18 21:44:21 deraadt Exp $	*/
d51 1
a51 2

#include <machine/endian.h>
@


1.16
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.15 2011/04/03 15:36:02 jasper Exp $	*/
a41 1
#include <sys/cdefs.h>
@


1.15
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.14 2010/08/29 16:47:00 deraadt Exp $	*/
a163 1
	int state;
d179 1
a179 20
	/*
	 * Check to see if the device is in power-save mode, and
	 * being it out if necessary.
	 *
	 * XXX This code comes almost verbatim from if_tlp_pci.c. I do
	 * not understand it. Tulip clears the "sleep mode" bit in the
	 * CFDA register, first.  There is an equivalent (?) register at the
	 * same place in the ADM8211, but the docs do not assign its bits
	 * any meanings. -dcy
	 */
	state = pci_set_powerstate(pc, pa->pa_tag, PCI_PMCSR_STATE_D0);
	if (state == PCI_PMCSR_STATE_D3) {
		/*
		 * The card has lost all configuration data in
		 * this state, so punt.
		 */
		printf(": unable to wake up from power state D3, "
		    "reboot required.\n");
		return;
	}
@


1.14
log
@Massage the powerhook functions into activate functions, and then call
them from the powerhook.  Fix a few quibbles about the things done for
the IFF_RUNNING and IFF_UP cases
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.13 2009/06/26 20:40:12 deraadt Exp $	*/
d121 1
a121 1
	    sizeof(rtw_pci_products)/sizeof(rtw_pci_products[0])));
@


1.13
log
@Two pci'd that come from cardbus, in case anyone ever needs them...
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.12 2009/06/02 01:11:32 jsg Exp $	*/
d103 1
a103 1
	    rtw_pci_detach
@


1.12
log
@Make rtw at pci detachable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.11 2008/06/26 05:42:17 ray Exp $	*/
d110 1
d113 1
@


1.11
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.10 2007/10/22 23:00:45 fgsch Exp $	*/
d79 1
d95 1
d102 2
a103 1
	sizeof (struct rtw_pci_softc), rtw_pci_match, rtw_pci_attach
d160 1
d204 1
a204 1
	    &iot, &ioh, NULL, NULL, 0) == 0);
d207 1
a207 1
	    &memt, &memh, NULL, NULL, 0) == 0);
d212 1
d216 1
d251 18
@


1.10
log
@only output on situations where power state is D3. unify the message in
such cases. ok brad@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.9 2007/10/22 03:16:35 fgsch Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.9
log
@Use pci_set_powerstate(), shrinking the code and unifying the different
versions. ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.8 2007/09/05 11:09:08 jsg Exp $	*/
d192 8
a199 12
	if (state != PCI_PMCSR_STATE_D0) {
		if (state == PCI_PMCSR_STATE_D3) {
			/*
			 * The card has lost all configuration data in
			 * this state, so punt.
			 */
			printf(": unable to wake up from power state D3, "
			    "reboot required.\n");
			return;
		} else {
			printf(": waking up from power state D%d\n", state);
		}
@


1.8
log
@Only match on RTL8185 if RTW_DEBUG is set, support for the RTL8185
was never finished due to a lack of information on the radios.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.7 2005/09/08 12:44:55 jsg Exp $	*/
d165 1
a165 2
	pcireg_t reg;
	int pmreg;
d191 3
a193 12
	if (pci_get_capability(pc, pa->pa_tag, PCI_CAP_PWRMGMT, &pmreg, 0)) {
		reg = pci_conf_read(pc, pa->pa_tag, pmreg + PCI_PMCSR);
		switch (reg & PCI_PMCSR_STATE_MASK) {
		case PCI_PMCSR_STATE_D1:
		case PCI_PMCSR_STATE_D2:
			printf(": waking up from power state D%d\n",
			    reg & PCI_PMCSR_STATE_MASK);
			pci_conf_write(pc, pa->pa_tag, pmreg + PCI_PMCSR,
			    (reg & ~PCI_PMCSR_STATE_MASK) |
			    PCI_PMCSR_STATE_D0);
			break;
		case PCI_PMCSR_STATE_D3:
d199 1
a199 4
			       "reboot required.\n");
			pci_conf_write(pc, pa->pa_tag, pmreg + PCI_PMCSR,
			    (reg & ~PCI_PMCSR_STATE_MASK) |
			    PCI_PMCSR_STATE_D0);
d201 2
@


1.7
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.6 2005/08/09 04:10:12 mickey Exp $	*/
d111 2
d114 1
a114 1
	{ PCI_VENDOR_REALTEK,	PCI_PRODUCT_REALTEK_RT8180 },
@


1.6
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.5 2005/05/29 02:58:31 reyk Exp $	*/
a69 1
#include <net80211/ieee80211_compat.h>
@


1.5
log
@add the RTL8185 (not working yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.4 2005/04/15 03:42:57 jsg Exp $	*/
a237 7

	/*
	 * Make sure bus mastering is enabled.
	 */
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG) |
	    PCI_COMMAND_MASTER_ENABLE);
@


1.4
log
@Simplify matching logic using pci_matchbyid() and correct some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.3 2005/02/09 10:51:25 mcbride Exp $	*/
d112 4
a115 3
	{ PCI_VENDOR_REALTEK,		PCI_PRODUCT_REALTEK_RT8180 },
	{ PCI_VENDOR_BELKIN2,		PCI_PRODUCT_BELKIN2_F5D6001 },
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DWL610 },
@


1.3
log
@Attach to the D-Link DWL-510.

ok dlg@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.2 2004/12/31 00:16:15 jsg Exp $	*/
d42 1
a42 1
 * PCI bus front-end for the Realtek RTL8180 802.11 MAC/BBP chip.
a84 1
const struct rtw_pci_product * rtw_pci_lookup(const struct pci_attach_args *);
d89 1
a89 1
 * PCI configuration space registers used by the ADM8211.
d95 1
a95 1
	struct rtw_softc	psc_rtw;	/* real ADM8211 softc */
d111 1
a111 4
const struct rtw_pci_product {
	u_int32_t	app_vendor;	/* PCI vendor ID */
	u_int32_t	app_product;	/* PCI product ID */
} rtw_pci_products[] = {
a114 2

	{ 0,				0 },
a116 15
const struct rtw_pci_product *
rtw_pci_lookup(const struct pci_attach_args *pa)
{
	const struct rtw_pci_product *app;

	for (app = rtw_pci_products;
	     app->app_vendor != 0 && app->app_product != 0;
	     app++) {
		if (PCI_VENDOR(pa->pa_id) == app->app_vendor &&
		    PCI_PRODUCT(pa->pa_id) == app->app_product)
			return (app);
	}
	return (NULL);
}

d120 2
a121 6
	struct pci_attach_args *pa = aux;

	if (rtw_pci_lookup(pa) != NULL)
		return (1);

	return (0);
a162 1
	const struct rtw_pci_product *app;
a167 6

	app = rtw_pci_lookup(pa);
	if (app == NULL) {
		printf("\n");
		panic("rtw_pci_attach: impossible");
	}
@


1.2
log
@Move the cfdriver struct to rtw.c where it belongs so cardbus rtw
can be enabled seperately from pci rtw. From fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_pci.c,v 1.1 2004/12/29 01:02:30 jsg Exp $	*/
d118 1
@


1.1
log
@Driver for Realtek 802.11 devices from NetBSD.
Not yet working.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a109 3
};
struct cfdriver rtw_cd = {
    0, "rtw", DV_IFNET
@

