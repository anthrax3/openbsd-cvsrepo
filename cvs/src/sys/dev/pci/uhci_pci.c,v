head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.14
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.12
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.8
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.6
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.6
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.31.0.10
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.8
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.6
	OPENBSD_5_0:1.31.0.4
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.6
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.33
date	2014.05.16.18.17.03;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.31;

1.31
date	2010.12.14.16.13.16;	author jakemsr;	state Exp;
branches;
next	1.30;

1.30
date	2010.10.20.20.34.19;	author mk;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.29.22.14.57;	author mlarkin;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.08.00.23.54;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.30.04.59.34;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.22.05.53.36;	author pascoe;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.18.20.14.51;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.18.06.08.24;	author pascoe;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.25.04.17.00;	author pascoe;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.30.03.43.04;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.09.04.10.13;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.11.08.09.32;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.31.04.22.32;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.24.22.52.52;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.23.03.23.00;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.11.02.21.28;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.08.13.19.08;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.25.10.13.30;	author art;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.06.12.19.11.59;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.12.15.40.33;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.21.02.42.49;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.04.13.21.59;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.27.00.55.59;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.26.21.47.30;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	99.11.07.21.30.18;	author fgsch;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.09.27.18.07.59;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.21.54.40;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.08.09.26;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.32.29;	author fgsch;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.00;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.07.04.10.43.14;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2004.06.05.23.12.54;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.33
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.
@
text
@/*	$OpenBSD: uhci_pci.c,v 1.32 2013/04/15 09:23:01 mglocker Exp $	*/
/*	$NetBSD: uhci_pci.c,v 1.24 2002/10/02 16:51:58 thorpej Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/queue.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#include <dev/usb/uhcireg.h>
#include <dev/usb/uhcivar.h>

int	uhci_pci_match(struct device *, void *, void *);
void	uhci_pci_attach(struct device *, struct device *, void *);
void	uhci_pci_attach_deferred(struct device *);
int	uhci_pci_detach(struct device *, int);
int	uhci_pci_activate(struct device *, int);

struct uhci_pci_softc {
	struct uhci_softc	sc;
	pci_chipset_tag_t	sc_pc;
	pcitag_t		sc_tag;
	void 			*sc_ih;		/* interrupt vectoring */
};

struct cfattach uhci_pci_ca = {
	sizeof(struct uhci_pci_softc), uhci_pci_match, uhci_pci_attach,
	uhci_pci_detach, uhci_pci_activate
};

int
uhci_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_SERIALBUS &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_SERIALBUS_USB &&
	    PCI_INTERFACE(pa->pa_class) == PCI_INTERFACE_UHCI)
		return (1);
 
	return (0);
}

int
uhci_pci_activate(struct device *self, int act)
{
	struct uhci_pci_softc *sc = (struct uhci_pci_softc *)self;

	/* On resume, set legacy support attribute and enable intrs */
	switch (act) {
	case DVACT_RESUME:
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    PCI_LEGSUP, PCI_LEGSUP_USBPIRQDEN);
		bus_space_barrier(sc->sc.iot, sc->sc.ioh, 0, sc->sc.sc_size,
		    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);
		bus_space_write_2(sc->sc.iot, sc->sc.ioh, UHCI_INTR, 0);
		break;
	}

	return uhci_activate(self, act);
}

void
uhci_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct uhci_pci_softc *sc = (struct uhci_pci_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	char const *intrstr;
	pci_intr_handle_t ih;
	const char *vendor;
	char *devname = sc->sc.sc_bus.bdev.dv_xname;
	int s;

	/* Map I/O registers */
	if (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
		    &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size, 0)) {
		printf(": can't map i/o space\n");
		return;
	}


	/* Disable interrupts, so we don't get any spurious ones. */
	s = splhardusb();
	bus_space_write_2(sc->sc.iot, sc->sc.ioh, UHCI_INTR, 0);

	sc->sc_pc = pc;
	sc->sc_tag = tag;
	sc->sc.sc_bus.dmatag = pa->pa_dmat;

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto unmap_ret;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, uhci_intr, sc,
				       devname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto unmap_ret;
	}
	printf(": %s\n", intrstr);

	/* Set LEGSUP register to its default value. */
	pci_conf_write(pc, tag, PCI_LEGSUP, PCI_LEGSUP_USBPIRQDEN);

	switch(pci_conf_read(pc, tag, PCI_USBREV) & PCI_USBREV_MASK) {
	case PCI_USBREV_PRE_1_0:
		sc->sc.sc_bus.usbrev = USBREV_PRE_1_0;
		break;
	case PCI_USBREV_1_0:
		sc->sc.sc_bus.usbrev = USBREV_1_0;
		break;
	case PCI_USBREV_1_1:
		sc->sc.sc_bus.usbrev = USBREV_1_1;
		break;
	default:
		sc->sc.sc_bus.usbrev = USBREV_UNKNOWN;
		break;
	}

	uhci_run(&sc->sc, 0);			/* stop the controller */
						/* disable interrupts */
	bus_space_barrier(sc->sc.iot, sc->sc.ioh, 0, sc->sc.sc_size,
	    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);
	bus_space_write_2(sc->sc.iot, sc->sc.ioh, UHCI_INTR, 0);

	/* Figure out vendor for root hub descriptor. */
	vendor = pci_findvendor(pa->pa_id);
	sc->sc.sc_id_vendor = PCI_VENDOR(pa->pa_id);
	if (vendor)
		strlcpy(sc->sc.sc_vendor, vendor, sizeof (sc->sc.sc_vendor));
	else
		snprintf(sc->sc.sc_vendor, sizeof (sc->sc.sc_vendor),
			"vendor 0x%04x", PCI_VENDOR(pa->pa_id));

	config_defer(self, uhci_pci_attach_deferred);
	
	/* Ignore interrupts for now */
	sc->sc.sc_bus.dying = 1;

	splx(s);

	return;

unmap_ret:
	bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
	splx(s);
}

void
uhci_pci_attach_deferred(struct device *self)
{
	struct uhci_pci_softc *sc = (struct uhci_pci_softc *)self;
	char *devname = sc->sc.sc_bus.bdev.dv_xname;
	usbd_status r;
	int s;

	s = splhardusb();
	
	sc->sc.sc_bus.dying = 0;
	r = uhci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf("%s: init failed, error=%d\n", devname, r);
		goto unmap_ret;
	}
	splx(s);

	/* Attach usb device. */
	config_found(self, &sc->sc.sc_bus, usbctlprint);
	return;

unmap_ret:
	bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
	pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
	splx(s);
}

int
uhci_pci_detach(struct device *self, int flags)
{
	struct uhci_pci_softc *sc = (struct uhci_pci_softc *)self;
	int rv;

	rv = uhci_detach(self, flags);
	if (rv)
		return (rv);
	if (sc->sc_ih != NULL) {
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
		sc->sc_ih = NULL;
	}
	if (sc->sc.sc_size) {
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		sc->sc.sc_size = 0;
	}

	return (0);
}
@


1.32
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.31 2010/12/14 16:13:16 jakemsr Exp $	*/
d215 1
a215 3
	sc->sc.sc_child = config_found((void *)sc, &sc->sc.sc_bus,
				       usbctlprint);

d230 1
a230 1
	rv = uhci_detach(&sc->sc, flags);
@


1.31
log
@use the dying flag in struct usbd_bus instead of a private dying flag
in *hci_softc

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.30 2010/10/20 20:34:19 mk Exp $	*/
d60 1
a60 1
	uhci_softc_t		sc;
@


1.30
log
@Disestablish interrupts if attachment fails.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.29 2010/06/29 22:14:57 mlarkin Exp $	*/
d185 1
a185 1
	sc->sc.sc_dying = 1;
d206 1
a206 1
	sc->sc.sc_dying = 0;
@


1.29
log
@

Add some missing UHCI and EHCI register restores on resume. Fixes at least
one broken UHCI on resume.

Tested by myself, kettenis, phessler, jsg, pirofti. Doesn't help all
machines, but no worse than before on any of them.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.28 2010/04/08 00:23:54 tedu Exp $	*/
d222 1
@


1.28
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.27 2008/06/26 05:42:17 ray Exp $	*/
d57 1
d68 1
a68 1
	uhci_pci_detach, uhci_activate
d82 19
@


1.27
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.26 2008/05/30 04:59:34 brad Exp $	*/
d38 1
a38 1
#include <sys/proc.h>
@


1.26
log
@Remove unused NetBSD code for dmesg printing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.25 2007/03/22 05:53:36 pascoe Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.25
log
@Perform legacy emulation handover for USB1 companion controllers immediately
but defer the remainder of their initialisation until after the other devices
on their PCI bus have attached.  This ensures that any USB2 controller has also
completed its initialisation before we start to initialise the USB1 parts.

This minimises the chance that a nasty SMM implementation will trash the USB1
controller's config when it performs legacy emulation handover of the USB2 part.

This time without accidentally leaving the OHCI controller shutdown, and with
some cosmetic fixes.

ok dlg@@, OHCI tests mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.24 2007/03/18 20:14:51 mglocker Exp $	*/
a101 7

#if defined(__NetBSD__)
	char devinfo[256];

	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)", devinfo, PCI_REVISION(pa->pa_class));
#endif
@


1.24
log
@Backout pascoe@@'s last USB change because it page faults at attachment
time.

Chris; Get your shiz fixed and tested for the next time.  We have
better todo then wasting our time by backing out untested stuff.

OK deraadt, OK ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.22 2006/08/25 04:17:00 pascoe Exp $	*/
d62 1
a100 1
	usbd_status r;
d175 24
d200 1
@


1.23
log
@Perform legacy emulation handover for USB1 companion controllers immediately
but defer the remainder of their initialisation until after the other devices
on their PCI bus have attached.  This ensures that any USB2 controller has also
completed its initialisation before we start to initialise the USB1 parts.

This minimises the chance that a nasty SMM implementation will trash the USB1
controller's config when it performs legacy emulation handover of the USB2 part.
@
text
@a61 1
void	uhci_pci_attach_deferred(struct device *);
d100 1
a174 24

	config_defer(self, uhci_pci_attach_deferred);
	
	/* Ignore interrupts for now */
	sc->sc.sc_dying = 1;

	splx(s);

	return;

unmap_ret:
	bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
	splx(s);
}

void
uhci_pci_attach_deferred(struct device *self)
{
	struct uhci_pci_softc *sc = (struct uhci_pci_softc *)self;
	char *devname = sc->sc.sc_bus.bdev.dv_xname;
	usbd_status r;
	int s;

	s = splhardusb();
a175 1
	sc->sc.sc_dying = 0;
@


1.22
log
@Disable interrupts during the attach of UHCI and EHCI controllers.  If
we do not, a shared interrupt which arrives while we are initialising
the host controller may cause a NULL pointer dereference.

tested joris, ok! dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.21 2005/12/30 03:43:04 dlg Exp $	*/
d62 1
a100 1
	usbd_status r;
d175 24
d200 1
@


1.21
log
@device_ptr_t -> struct device *

i hate typedefs
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.20 2005/08/09 04:10:13 mickey Exp $	*/
d101 1
d117 1
d119 1
d129 1
a129 2
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		return;
d139 1
a139 2
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		return;
d179 1
a179 2
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		return;
d181 1
d186 6
@


1.20
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.19 2005/04/11 08:09:32 dlg Exp $	*/
d62 1
a62 1
int	uhci_pci_detach(device_ptr_t, int);
d188 1
a188 1
uhci_pci_detach(device_ptr_t self, int flags)
@


1.19
log
@get rid of the lines on ehci attach that show the version and the companion
controllers. remove the insane amount of support code needed just for the
printing of the companion controllers while here.

zap it deraadt@@ sure pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.18 2004/12/31 04:22:32 dlg Exp $	*/
a97 1
	pcireg_t csr;
a121 5

	/* Enable the device. */
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
		       csr | PCI_COMMAND_MASTER_ENABLE);
@


1.18
log
@strncpy -> strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.17 2004/05/24 22:52:52 mickey Exp $	*/
a50 1
#include <dev/pci/usb_pci.h>
a65 1
	struct usb_pci		sc_pci;
a187 1
	usb_pci_add(&sc->sc_pci, pa, &sc->sc.sc_bus);
a209 1
	usb_pci_rem(&sc->sc_pci);
@


1.17
log
@do not bother w/ void pci_devinfo() calls and free resources on failures
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.16 2004/05/23 03:23:00 deraadt Exp $	*/
d178 1
a178 2
		strncpy(sc->sc.sc_vendor, vendor,
			sizeof(sc->sc.sc_vendor) - 1);
d180 1
a180 1
		snprintf(sc->sc.sc_vendor, sizeof sc->sc.sc_vendor,
@


1.16
log
@ehci support; hacked into working shape by jonathon@@gateway.zenbu.net
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.15 2003/08/11 02:21:28 mickey Exp $	*/
d134 1
d145 1
d187 1
@


1.15
log
@cleanup dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.14 2003/07/08 13:19:08 nate Exp $	*/
d51 1
d67 1
d188 1
d211 1
@


1.14
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.13 2002/03/14 01:27:00 millert Exp $	*/
d113 1
a113 1
		printf("%s: can't map i/o space\n", devname);
d131 1
a131 1
		printf("%s: couldn't map interrupt\n", devname);
d138 1
a138 1
		printf(": couldn't establish interrupt", devname);
d144 1
a144 1
	printf(": interrupting at %s\n", intrstr);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci_pci.c,v 1.12 2001/08/25 10:13:30 art Exp $	*/
/*	$NetBSD: uhci_pci.c,v 1.14 2000/01/25 11:26:06 augustss Exp $	*/
d67 1
d77 1
a77 3
uhci_pci_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d90 1
a90 4
uhci_pci_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d95 1
d98 3
a100 1
	pcireg_t csr, legsup;
d103 6
d112 2
a113 2
	    &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size, 0)) {
		printf(": can't map i/o space\n");
d121 1
d125 2
a126 2
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
d129 14
a142 5
	/* Verify that the PIRQD enable bit is set, some BIOS's don't do that*/
	legsup = pci_conf_read(pc, pa->pa_tag, PCI_LEGSUP);
	if (!(legsup & PCI_LEGSUP_USBPIRQDEN)) {
		legsup = PCI_LEGSUP_USBPIRQDEN;
		pci_conf_write(pc, pa->pa_tag, PCI_LEGSUP, legsup);
d144 4
d149 1
a149 1
	switch(pci_conf_read(pc, pa->pa_tag, PCI_USBREV) & PCI_USBREV_MASK) {
d170 10
a179 17
	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, uhci_intr, sc,
	    sc->sc.sc_bus.bdev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

d182 1
a182 1
		printf(": init failed, error=%d\n", r);
d188 1
a188 1
	    usbctlprint);
d192 1
a192 3
uhci_pci_detach(self, flags)
	device_ptr_t self;
	int flags;
d208 1
@


1.12
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.11 2001/06/12 19:11:59 mickey Exp $	*/
d60 3
a62 3
int	uhci_pci_match __P((struct device *, void *, void *));
void	uhci_pci_attach __P((struct device *, struct device *, void *));
int	uhci_pci_detach __P((device_ptr_t, int));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.12 2001/08/25 10:13:30 art Exp $	*/
d60 3
a62 3
int	uhci_pci_match(struct device *, void *, void *);
void	uhci_pci_attach(struct device *, struct device *, void *);
int	uhci_pci_detach(device_ptr_t, int);
@


1.11
log
@interrupts cannot happen before
*hci cannot receive interrupts before it has been initialized.
this was changed to accomodate the pcibios strategy change back
in pre-2.9 times since *hci_init enables interrupts at it's end
and thus unmapped pci interrupt hangs the machine in the
endless loop trying to deliver it (and no hci handler to ack it).
this new way we disable interrupts by hands before we map 'em
on pci and thus ensure that they will not crash an uninitialized
*hci which, in turn, will run right after the interrupt map/establish
and by the time it enables *hci interrupts all gonna be just fine.
please allow us to end this stretched remark for cvs
is getting a power outage in less than 20 minutes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.10 2001/06/12 15:40:33 niklas Exp $	*/
d152 1
a152 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.10
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.9 2001/01/21 02:42:49 mickey Exp $	*/
d145 5
a149 5
	r = uhci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf(": init failed, error=%d\n", r);
		return;
	}
d168 6
@


1.9
log
@map and establish interrupts _after_ chip was initialized
and driver has allocated it's internal data structures.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.8 2000/07/04 13:21:59 fgsch Exp $	*/
d107 1
a107 1
			   &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size)) {
@


1.8
log
@sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.7 2000/03/27 00:55:59 aaron Exp $	*/
a122 18
	/* Map and establish the interrupt. */
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, uhci_intr, sc,
	    sc->sc.sc_bus.bdev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

d151 18
d171 1
a171 1
				       usbctlprint);
@


1.7
log
@Need a newline now.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.6 2000/03/26 21:47:30 aaron Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
a66 1
	bus_size_t		sc_size;
d107 1
a107 1
			   &sc->sc.iot, &sc->sc.ioh, NULL, NULL)) {
d165 1
a165 2
		printf("%s: init failed, error=%d\n", 
		       sc->sc.sc_bus.bdev.dv_xname, r);
d185 1
a185 1
	if (sc->sc_ih) {
d187 1
a187 1
		sc->sc_ih = 0;
d189 3
a191 3
	if (sc->sc_size) {
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc_size);
		sc->sc_size = 0;
@


1.6
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.5 1999/11/07 21:30:18 fgsch Exp $	*/
d140 1
a140 1
	printf(": %s", intrstr);
@


1.5
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci_pci.c,v 1.4 1999/09/27 18:07:59 fgsch Exp $	*/
/*	$NetBSD: uhci_pci.c,v 1.7 1999/05/20 09:52:35 augustss Exp $	*/
d102 1
a102 2
	pcireg_t csr;
	char *typestr;
d142 7
d151 1
a151 1
		typestr = "pre 1.0";
d154 4
a157 1
		typestr = "1.0";
d160 1
a160 1
		typestr = "unknown";
a162 1
	printf(" version %s\n", typestr);
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci_pci.c,v 1.9 2001/01/21 02:42:49 mickey Exp $	*/
/*	$NetBSD: uhci_pci.c,v 1.14 2000/01/25 11:26:06 augustss Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d67 1
d102 2
a103 1
	pcireg_t csr, legsup;
d109 1
a109 1
			   &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size)) {
a124 28
	/* Verify that the PIRQD enable bit is set, some BIOS's don't do that*/
	legsup = pci_conf_read(pc, pa->pa_tag, PCI_LEGSUP);
	if (!(legsup & PCI_LEGSUP_USBPIRQDEN)) {
		legsup = PCI_LEGSUP_USBPIRQDEN;
		pci_conf_write(pc, pa->pa_tag, PCI_LEGSUP, legsup);
	}

	switch(pci_conf_read(pc, pa->pa_tag, PCI_USBREV) & PCI_USBREV_MASK) {
	case PCI_USBREV_PRE_1_0:
		sc->sc.sc_bus.usbrev = USBREV_PRE_1_0;
		break;
	case PCI_USBREV_1_0:
		sc->sc.sc_bus.usbrev = USBREV_1_0;
		break;
	case PCI_USBREV_1_1:
		sc->sc.sc_bus.usbrev = USBREV_1_1;
		break;
	default:
		sc->sc.sc_bus.usbrev = USBREV_UNKNOWN;
		break;
	}

	r = uhci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf(": init failed, error=%d\n", r);
		return;
	}

d141 21
a161 1
	printf(": %s\n", intrstr);
d165 1
a165 1
	    usbctlprint);
d179 1
a179 1
	if (sc->sc_ih != NULL) {
d181 1
a181 1
		sc->sc_ih = NULL;
d183 3
a185 3
	if (sc->sc.sc_size) {
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		sc->sc.sc_size = 0;
@


1.5.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.5.2.1 2001/05/14 22:26:00 niklas Exp $	*/
d107 1
a107 1
	    &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size, 0)) {
d145 5
a149 5
	uhci_run(&sc->sc, 0);			/* stop the controller */
						/* disable interrupts */
	bus_space_barrier(sc->sc.iot, sc->sc.ioh, 0, sc->sc.sc_size,
	    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);
	bus_space_write_2(sc->sc.iot, sc->sc.ioh, UHCI_INTR, 0);
a167 6

	r = uhci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf(": init failed, error=%d\n", r);
		return;
	}
@


1.5.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.5.2.2 2001/07/04 10:43:14 niklas Exp $	*/
d152 2
a153 1
	if (pci_intr_map(pa, &ih)) {
@


1.5.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 3
a62 3
int	uhci_pci_match(struct device *, void *, void *);
void	uhci_pci_attach(struct device *, struct device *, void *);
int	uhci_pci_detach(device_ptr_t, int);
@


1.5.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: uhci_pci.c,v 1.24 2002/10/02 16:51:58 thorpej Exp $	*/
a66 1
	pcitag_t		sc_tag;
d76 3
a78 1
uhci_pci_match(struct device *parent, void *match, void *aux)
d91 4
a94 1
uhci_pci_attach(struct device *parent, struct device *self, void *aux)
a98 1
	pcitag_t tag = pa->pa_tag;
d101 1
a101 3
	pcireg_t csr;
	const char *vendor;
	char *devname = sc->sc.sc_bus.bdev.dv_xname;
a103 6
#if defined(__NetBSD__)
	char devinfo[256];

	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)", devinfo, PCI_REVISION(pa->pa_class));
#endif
d107 1
a107 1
		    &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size, 0)) {
a115 1
	sc->sc_tag = tag;
d119 2
a120 2
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
d123 5
a127 4
	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
a128 11
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, uhci_intr, sc,
				       devname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);
d130 1
a130 4
	/* Set LEGSUP register to its default value. */
	pci_conf_write(pc, tag, PCI_LEGSUP, PCI_LEGSUP_USBPIRQDEN);

	switch(pci_conf_read(pc, tag, PCI_USBREV) & PCI_USBREV_MASK) {
d151 17
a167 10
	/* Figure out vendor for root hub descriptor. */
	vendor = pci_findvendor(pa->pa_id);
	sc->sc.sc_id_vendor = PCI_VENDOR(pa->pa_id);
	if (vendor)
		strncpy(sc->sc.sc_vendor, vendor,
			sizeof(sc->sc.sc_vendor) - 1);
	else
		snprintf(sc->sc.sc_vendor, sizeof sc->sc.sc_vendor,
			"vendor 0x%04x", PCI_VENDOR(pa->pa_id));
	
d170 1
a170 1
		printf("%s: init failed, error=%d\n", devname, r);
d176 1
a176 1
				       usbctlprint);
d180 3
a182 1
uhci_pci_detach(device_ptr_t self, int flags)
a197 1

@


1.5.2.6
log
@Merge with the trunk
@
text
@a50 1
#include <dev/pci/usb_pci.h>
a65 1
	struct usb_pci		sc_pci;
a131 1
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
a141 1
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
a182 1
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
a185 1
	usb_pci_add(&sc->sc_pci, pa, &sc->sc.sc_bus);
a207 1
	usb_pci_rem(&sc->sc_pci);
@


1.4
log
@Disable ints. later; NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.3 1999/08/23 21:54:40 fgsch Exp $	*/
d62 8
d72 2
a73 2
	sizeof(uhci_softc_t), uhci_pci_match, uhci_pci_attach,
	uhci_detach, uhci_activate
d86 1
a86 1
		return 1;
d88 1
a88 1
	return 0;
d97 1
a97 1
	uhci_softc_t *sc = (uhci_softc_t *)self;
d109 1
a109 1
			   &sc->iot, &sc->ioh, NULL, NULL)) {
d114 2
a115 2
	/* Disable interrupts, so we don't can any spurious ones. */
	bus_space_write_2(sc->iot, sc->ioh, UHCI_INTR, 0);
d117 2
a118 1
	sc->sc_bus.dmatag = pa->pa_dmat;
d133 1
a133 1
	    sc->sc_bus.bdev.dv_xname);
d156 1
a156 1
	r = uhci_init(sc);
d159 1
a159 1
		       sc->sc_bus.bdev.dv_xname, r);
d164 24
a187 1
	sc->sc_child = config_found((void *)sc, &sc->sc_bus, usbctlprint);
@


1.3
log
@Disable interrupts early; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.2 1999/08/13 08:09:26 fgsch Exp $	*/
d64 2
a65 1
	sizeof(uhci_softc_t), uhci_pci_match, uhci_pci_attach
a97 2
	/* Disable interrupts, so we don't can any spurious ones. */
	bus_space_write_2(sc->iot, sc->ioh, UHCI_INTR, 0);
d106 4
a109 1
	sc->sc_dmatag = pa->pa_dmat;
a121 1

d155 1
a155 1
	config_found((void *)sc, &sc->sc_bus, usbctlprint);
@


1.2
log
@Remove unncessary printfs as well as NetBSD ifdefs.
Make dmesg output shorter.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_pci.c,v 1.1 1999/08/13 05:32:29 fgsch Exp $	*/
d96 3
@


1.1
log
@USB controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a59 3
#if defined(__NetBSD__)
int	uhci_pci_match __P((struct device *, struct cfdata *, void *));
#else
a60 1
#endif
d70 1
a70 6
#if defined(__NetBSD__)
	struct cfdata *match;
#else
	void *match;
#endif
	void *aux;
a93 3
#if defined(__NetBSD__)
	char *typestr, *vendor;
#else
a94 2
#endif
	char devinfo[256];
a96 3
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)\n", devinfo, PCI_REVISION(pa->pa_class));

d100 1
a100 1
		printf("%s: can't map i/o space\n", sc->sc_bus.bdev.dv_xname);
d114 1
a114 2
		printf("%s: couldn't map interrupt\n", 
		       sc->sc_bus.bdev.dv_xname);
d117 1
a118 3
#if defined(__NetBSD__)
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, uhci_intr, sc);
#else
a120 1
#endif
d122 1
a122 2
		printf("%s: couldn't establish interrupt",
		    sc->sc_bus.bdev.dv_xname);
d128 1
a128 1
	printf("%s: interrupting at %s\n", sc->sc_bus.bdev.dv_xname, intrstr);
d141 1
a141 1
	printf("%s: USB version %s\n", sc->sc_bus.bdev.dv_xname, typestr);
a142 10
#if defined(__NetBSD__)
	/* Figure out vendor for root hub descriptor. */
	vendor = pci_findvendor(pa->pa_id);
	sc->sc_id_vendor = PCI_VENDOR(pa->pa_id);
	if (vendor)
		strncpy(sc->sc_vendor, vendor, sizeof(sc->sc_vendor) - 1);
	else
		sprintf(sc->sc_vendor, "vendor 0x%04x", PCI_VENDOR(pa->pa_id));
#endif
	
@

