head	1.65;
access;
symbols
	OPENBSD_6_1:1.65.0.4
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.64.0.6
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.62.0.22
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.62.0.20
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.62.0.18
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.62.0.16
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.62.0.12
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.62.0.10
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.62.0.8
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.6
	OPENBSD_5_0:1.62.0.4
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.62.0.2
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.52.0.4
	OPENBSD_4_6_BASE:1.52
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9;
locks; strict;
comment	@ * @;


1.65
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.64;
commitid	pi1a9KN0itEngOc4;

1.64
date	2015.08.24.04.50.40;	author jsg;	state Exp;
branches;
next	1.63;
commitid	Sr7poarBLtMxMzMH;

1.63
date	2015.08.20.06.44.06;	author mlarkin;	state Exp;
branches;
next	1.62;
commitid	HJo9XRP85Bi32SU1;

1.62
date	2010.09.10.15.11.23;	author jakemsr;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.07.20.48.56;	author jakemsr;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.27.21.47.07;	author jakemsr;	state Exp;
branches;
next	1.59;

1.59
date	2010.03.21.15.02.31;	author jakemsr;	state Exp;
branches;
next	1.58;

1.58
date	2009.12.22.08.48.14;	author jakemsr;	state Exp;
branches;
next	1.57;

1.57
date	2009.11.24.10.00.39;	author jakemsr;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.11.06.45.46;	author jakemsr;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.11.00.07.06;	author jakemsr;	state Exp;
branches;
next	1.54;

1.54
date	2009.09.09.02.22.21;	author jakemsr;	state Exp;
branches;
next	1.53;

1.53
date	2009.09.09.00.26.57;	author jakemsr;	state Exp;
branches;
next	1.52;

1.52
date	2009.06.09.05.16.42;	author jakemsr;	state Exp;
branches;
next	1.51;

1.51
date	2009.06.09.05.05.48;	author jakemsr;	state Exp;
branches;
next	1.50;

1.50
date	2009.05.31.03.22.05;	author jakemsr;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.31.02.57.51;	author jakemsr;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.29.21.16.37;	author jakemsr;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.29.17.54.08;	author jakemsr;	state Exp;
branches;
next	1.46;

1.46
date	2009.05.29.02.38.01;	author jakemsr;	state Exp;
branches;
next	1.45;

1.45
date	2009.05.12.09.32.28;	author jakemsr;	state Exp;
branches;
next	1.44;

1.44
date	2009.05.01.02.55.16;	author jakemsr;	state Exp;
branches;
next	1.43;

1.43
date	2009.04.24.16.05.06;	author jakemsr;	state Exp;
branches;
next	1.42;

1.42
date	2009.04.24.16.02.17;	author jakemsr;	state Exp;
branches;
next	1.41;

1.41
date	2009.04.24.15.31.18;	author jakemsr;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.05.09.46.26;	author jakemsr;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.05.08.19.31;	author jakemsr;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.05.07.55.34;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.03.19.17.45;	author jakemsr;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.02.22.32.25;	author jakemsr;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.02.20.37.57;	author jakemsr;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.02.20.18.18;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.02.00.39.25;	author jakemsr;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.02.00.25.33;	author jakemsr;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.31.13.13.39;	author jakemsr;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.31.11.54.55;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.23.04.12.19;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.22.00.03.08;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.21.20.21.24;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.30.08.36.57;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2008.11.28.21.45.49;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.28.21.33.26;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.28.04.03.37;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.27.23.30.58;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.19.03.44.14;	author jakemsr;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.05.03.20.35;	author jakemsr;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.04.20.55.43;	author jakemsr;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.04.07.58.43;	author jakemsr;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.16.19.16.58;	author jakemsr;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.16.02.13.12;	author jakemsr;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.10.03.39.21;	author deanna;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.10.05.39.07;	author deanna;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.10.05.34.21;	author deanna;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.23.02.03.42;	author deanna;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.02.17.01.22;	author deanna;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.23.23.26.20;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.16.06.00.46;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.14.19.34.52;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.11.23.34.35;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.08.04.18.43;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.08.04.11.31;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.08.03.53.57;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.08.03.52.37;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.26.15.53.08;	author jason;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@/*	$OpenBSD: azalia.h,v 1.63 2015/08/20 06:44:06 mlarkin Exp $	*/
/*	$NetBSD: azalia.h,v 1.6 2006/01/16 14:15:26 kent Exp $	*/

/*-
 * Copyright (c) 2005 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by TAMURA Kent
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/audioio.h>

/* ----------------------------------------------------------------
 * High Definition Audio constant values
 * ---------------------------------------------------------------- */

/* High Definition Audio registers */
#define HDA_GCAP	0x000	/* 2 */
#define		HDA_GCAP_OSS(x)	((x & 0xf000) >> 12)
#define		HDA_GCAP_ISS(x)	((x & 0x0f00) >> 8)
#define		HDA_GCAP_BSS(x)	((x & 0x00f8) >> 3)
#define		HDA_GCAP_NSDO_MASK	0x0006
#define		HDA_GCAP_NSDO_1		0x0000
#define		HDA_GCAP_NSDO_2		0x0002
#define		HDA_GCAP_NSDO_4		0x0004
#define		HDA_GCAP_NSDO_RESERVED	0x0006
#define		HDA_GCAP_64OK	0x0001
#define HDA_VMIN	0x002	/* 1 */
#define HDA_VMAJ	0x003	/* 1 */
#define HDA_OUTPAY	0x004	/* 2 */
#define HDA_INPAY	0x006	/* 2 */
#define HDA_GCTL	0x008	/* 4 */
#define		HDA_GCTL_UNSOL	0x00000100
#define		HDA_GCTL_FCNTRL	0x00000002
#define		HDA_GCTL_CRST	0x00000001
#define HDA_WAKEEN	0x00c	/* 2 */
#define		HDA_WAKEEN_SDIWEN	0x7fff
#define HDA_STATESTS	0x00e	/* 2 */
#define		HDA_STATESTS_SDIWAKE	0x7fff
#define HDA_GSTS	0x010	/* 2 */
#define		HDA_GSTS_FSTS		0x0002
#define HDA_OUTSTRMPAY	0x018	/* 2 */
#define HDA_INSTRMPAY	0x01a	/* 2 */
#define HDA_INTCTL	0x020	/* 4 */
#define		HDA_INTCTL_GIE	0x80000000
#define		HDA_INTCTL_CIE	0x40000000
#define		HDA_INTCTL_SIE	0x3fffffff
#define HDA_INTSTS	0x024	/* 4 */
#define		HDA_INTSTS_GIS	0x80000000
#define		HDA_INTSTS_CIS	0x40000000
#define		HDA_INTSTS_SIS	0x3fffffff
#define HDA_WALCLK	0x030	/* 4 */
#define HDA_SSYNC	0x034	/* 4 */
#define		HDA_SSYNC_SSYNC	0x3fffffff
#define HDA_CORBLBASE	0x040	/* 4 */
#define HDA_CORBUBASE	0x044	/* 4 */
#define HDA_CORBWP	0x048	/* 2 */
#define		HDA_CORBWP_CORBWP	0x00ff
#define HDA_CORBRP	0x04a	/* 2 */
#define		HDA_CORBRP_CORBRPRST	0x8000
#define		HDA_CORBRP_CORBRP	0x00ff
#define HDA_CORBCTL	0x04c	/* 1 */
#define		HDA_CORBCTL_CORBRUN	0x02
#define		HDA_CORBCTL_CMEIE	0x01
#define HDA_CORBSTS	0x04d	/* 1 */
#define		HDA_CORBSTS_CMEI	0x01
#define HDA_CORBSIZE	0x04e	/* 1 */
#define		HDA_CORBSIZE_CORBSZCAP_MASK	0xf0
#define		HDA_CORBSIZE_CORBSZCAP_2	0x10
#define		HDA_CORBSIZE_CORBSZCAP_16	0x20
#define		HDA_CORBSIZE_CORBSZCAP_256	0x40
#define		HDA_CORBSIZE_CORBSIZE_MASK	0x03
#define		HDA_CORBSIZE_CORBSIZE_2		0x00
#define		HDA_CORBSIZE_CORBSIZE_16	0x01
#define		HDA_CORBSIZE_CORBSIZE_256	0x02
#define HDA_RIRBLBASE	0x050	/* 4 */
#define HDA_RIRBUBASE	0x054	/* 4 */
#define HDA_RIRBWP	0x058	/* 2 */
#define		HDA_RIRBWP_RIRBWPRST	0x8000
#define		HDA_RIRBWP_RIRBWP	0x00ff
#define HDA_RINTCNT	0x05a	/* 2 */
#define		HDA_RINTCNT_RINTCNT	0x00ff
#define HDA_RIRBCTL	0x05c	/* 1 */
#define		HDA_RIRBCTL_RIRBOIC	0x04
#define		HDA_RIRBCTL_RIRBDMAEN	0x02
#define		HDA_RIRBCTL_RINTCTL	0x01
#define HDA_RIRBSTS	0x05d	/* 1 */
#define		HDA_RIRBSTS_RIRBOIS	0x04
#define		HDA_RIRBSTS_RINTFL	0x01
#define HDA_RIRBSIZE	0x05e	/* 1 */
#define		HDA_RIRBSIZE_RIRBSZCAP_MASK	0xf0
#define		HDA_RIRBSIZE_RIRBSZCAP_2	0x10
#define		HDA_RIRBSIZE_RIRBSZCAP_16	0x20
#define		HDA_RIRBSIZE_RIRBSZCAP_256	0x40
#define		HDA_RIRBSIZE_RIRBSIZE_MASK	0x03
#define		HDA_RIRBSIZE_RIRBSIZE_2		0x00
#define		HDA_RIRBSIZE_RIRBSIZE_16	0x01
#define		HDA_RIRBSIZE_RIRBSIZE_256	0x02
#define HDA_IC		0x060	/* 4 */
#define HDA_IR		0x064	/* 4 */
#define HDA_IRS		0x068	/* 2 */
#define		HDA_IRS_IRRADD		0x00f0
#define		HDA_IRS_IRRUNSOL	0x0008
#define		HDA_IRS_IRV		0x0002
#define		HDA_IRS_ICB		0x0001
#define HDA_DPLBASE	0x070	/* 4 */
#define		HDA_DPLBASE_DPLBASE	0xffffff80
#define		HDA_DPLBASE_ENABLE	0x00000001
#define HDA_DPUBASE	0x074

#define HDA_SD_BASE	0x080
#define		HDA_SD_CTL	0x00 /* 2 */
#define			HDA_SD_CTL_DEIE	0x0010
#define			HDA_SD_CTL_FEIE	0x0008
#define			HDA_SD_CTL_IOCE	0x0004
#define			HDA_SD_CTL_RUN	0x0002
#define			HDA_SD_CTL_SRST	0x0001
#define		HDA_SD_CTL2	0x02 /* 1 */
#define			HDA_SD_CTL2_STRM	0xf0
#define			HDA_SD_CTL2_STRM_SHIFT	4
#define			HDA_SD_CTL2_DIR		0x08
#define			HDA_SD_CTL2_TP		0x04
#define			HDA_SD_CTL2_STRIPE	0x03
#define		HDA_SD_STS	0x03 /* 1 */
#define			HDA_SD_STS_FIFORDY	0x20
#define			HDA_SD_STS_DESE		0x10
#define			HDA_SD_STS_FIFOE	0x08
#define			HDA_SD_STS_BCIS		0x04
#define		HDA_SD_LPIB	0x04 /* 4 */
#define		HDA_SD_CBL	0x08 /* 4 */
#define		HDA_SD_LVI	0x0c /* 2 */
#define			HDA_SD_LVI_LVI	0x00ff
#define		HDA_SD_FIFOW	0x0e /* 2 */
#define		HDA_SD_FIFOS	0x10 /* 2 */
#define		HDA_SD_FMT	0x12 /* 2 */
#define			HDA_SD_FMT_BASE	0x4000
#define			HDA_SD_FMT_BASE_48	0x0000
#define			HDA_SD_FMT_BASE_44	0x4000
#define			HDA_SD_FMT_MULT	0x3800
#define			HDA_SD_FMT_MULT_X1	0x0000
#define			HDA_SD_FMT_MULT_X2	0x0800
#define			HDA_SD_FMT_MULT_X3	0x1000
#define			HDA_SD_FMT_MULT_X4	0x1800
#define			HDA_SD_FMT_DIV	0x0700
#define			HDA_SD_FMT_DIV_BY1	0x0000
#define			HDA_SD_FMT_DIV_BY2	0x0100
#define			HDA_SD_FMT_DIV_BY3	0x0200
#define			HDA_SD_FMT_DIV_BY4	0x0300
#define			HDA_SD_FMT_DIV_BY5	0x0400
#define			HDA_SD_FMT_DIV_BY6	0x0500
#define			HDA_SD_FMT_DIV_BY7	0x0600
#define			HDA_SD_FMT_DIV_BY8	0x0700
#define			HDA_SD_FMT_BITS	0x0070
#define			HDA_SD_FMT_BITS_8_16	0x0000
#define			HDA_SD_FMT_BITS_16_16	0x0010
#define			HDA_SD_FMT_BITS_20_32	0x0020
#define			HDA_SD_FMT_BITS_24_32	0x0030
#define			HDA_SD_FMT_BITS_32_32	0x0040
#define			HDA_SD_FMT_CHAN	0x000f
#define		HDA_SD_BDPL	0x18 /* 4 */
#define		HDA_SD_BDPU	0x1c /* 4 */
#define		HDA_SD_SIZE	0x20

/* CORB commands */
#define CORB_GET_PARAMETER		0xf00
#define		COP_VENDOR_ID			0x00
#define			COP_VID_VENDOR(x)	(x >> 16)
#define			COP_VID_DEVICE(x)	(x & 0xffff)
#define		COP_REVISION_ID			0x02
#define			COP_RID_MAJ(x)		((x >> 20) & 0x0f)
#define			COP_RID_MIN(x)		((x >> 16) & 0x0f)
#define			COP_RID_REVISION(x)	((x >> 8) & 0xff)
#define			COP_RID_STEPPING(x)	(x & 0xff)
#define		COP_SUBORDINATE_NODE_COUNT	0x04
#define			COP_START_NID(x)	((x & 0x00ff0000) >> 16)
#define			COP_NSUBNODES(x)	(x & 0x000000ff)
#define		COP_FUNCTION_GROUP_TYPE		0x05
#define			COP_FTYPE(x)		(x & 0x000000ff)
#define			COP_FTYPE_RESERVED	0x01
#define			COP_FTYPE_AUDIO		0x01
#define			COP_FTYPE_MODEM		0x02
#define		COP_AUDIO_FUNCTION_GROUP_CAPABILITY	0x08
#define		COP_AUDIO_WIDGET_CAP	0x09
#define			COP_AWCAP_TYPE(x)	((x >> 20) & 0xf)
#define			COP_AWTYPE_AUDIO_OUTPUT		0x0
#define			COP_AWTYPE_AUDIO_INPUT		0x1
#define			COP_AWTYPE_AUDIO_MIXER		0x2
#define			COP_AWTYPE_AUDIO_SELECTOR	0x3
#define			COP_AWTYPE_PIN_COMPLEX		0x4
#define			COP_AWTYPE_POWER		0x5
#define			COP_AWTYPE_VOLUME_KNOB		0x6
#define			COP_AWTYPE_BEEP_GENERATOR	0x7
#define			COP_AWTYPE_VENDOR_DEFINED	0xf
#define			COP_AWCAP_STEREO	0x001
#define			COP_AWCAP_INAMP		0x002
#define			COP_AWCAP_OUTAMP	0x004
#define			COP_AWCAP_AMPOV		0x008
#define			COP_AWCAP_FORMATOV	0x010
#define			COP_AWCAP_STRIPE	0x020
#define			COP_AWCAP_PROC		0x040
#define			COP_AWCAP_UNSOL		0x080
#define			COP_AWCAP_CONNLIST	0x100
#define			COP_AWCAP_DIGITAL	0x200
#define			COP_AWCAP_POWER		0x400
#define			COP_AWCAP_LRSWAP	0x800
#define			COP_AWCAP_DELAY(x)	((x >> 16) & 0xf)
#define		COP_PCM				0x0a
#define			COP_PCM_B32	0x00100000
#define			COP_PCM_B24	0x00080000
#define			COP_PCM_B20	0x00040000
#define			COP_PCM_B16	0x00020000
#define			COP_PCM_B8	0x00010000
#define			COP_PCM_R3840	0x00000800
#define			COP_PCM_R1920	0x00000400
#define			COP_PCM_R1764	0x00000200
#define			COP_PCM_R960	0x00000100
#define			COP_PCM_R882	0x00000080
#define			COP_PCM_R480	0x00000040
#define			COP_PCM_R441	0x00000020
#define			COP_PCM_R320	0x00000010
#define			COP_PCM_R220	0x00000008
#define			COP_PCM_R160	0x00000004
#define			COP_PCM_R110	0x00000002
#define			COP_PCM_R80	0x00000001
#define		COP_STREAM_FORMATS		0x0b
#define			COP_STREAM_FORMAT_PCM		0x00000001
#define			COP_STREAM_FORMAT_FLOAT32	0x00000002
#define			COP_STREAM_FORMAT_AC3		0x00000003
#define		COP_PINCAP		0x0c
#define			COP_PINCAP_IMPEDANCE	0x00000001
#define			COP_PINCAP_TRIGGER	0x00000002
#define			COP_PINCAP_PRESENCE	0x00000004
#define			COP_PINCAP_HEADPHONE	0x00000008
#define			COP_PINCAP_OUTPUT	0x00000010
#define			COP_PINCAP_INPUT	0x00000020
#define			COP_PINCAP_BALANCE	0x00000040
#define			COP_PINCAP_HDMI		0x00000080
#define			COP_PINCAP_VREF(x)	((x >> 8) & 0xff)
#define			COP_PINCAP_EAPD		0x00010000
#define		COP_INPUT_AMPCAP	0x0d
#define			COP_AMPCAP_OFFSET(x)	(x & 0x0000007f)
#define			COP_AMPCAP_NUMSTEPS(x)	((x >> 8) & 0x7f)
#define			COP_AMPCAP_STEPSIZE(x)	((x >> 16) & 0x7f)
#define			COP_AMPCAP_CTLOFF(x)	((x >> 24) & 0x7f)
#define			COP_AMPCAP_MUTE		0x80000000
#define		COP_CONNECTION_LIST_LENGTH	0x0e
#define			COP_CLL_LONG		0x00000080
#define			COP_CLL_LENGTH(x)	(x & 0x0000007f)
#define		COP_SUPPORTED_POWER_STATES	0x0f
#define		COP_PROCESSING_CAPABILITIES	0x10
#define		COP_GPIO_COUNT			0x11
#define			COP_GPIO_GPIOS(x)	(x & 0xff)
#define			COP_GPIO_GPOS(x)	((x >> 8) & 0xff)
#define			COP_GPIO_GPIS(x)	((x >> 16) & 0xff)
#define			COP_GPIO_UNSOL		0x40000000
#define			COP_GPIO_WAKE		0x80000000
#define		COP_OUTPUT_AMPCAP		0x12
#define		COP_VOLUME_KNOB_CAPABILITIES	0x13
#define			COP_VKCAP_DELTA		0x00000080
#define			COP_VKCAP_NUMSTEPS(x)	(x & 0x7f)
#define CORB_GET_CONNECTION_SELECT_CONTROL	0xf01
#define		CORB_CSC_INDEX(x)		(x & 0xff)
#define CORB_SET_CONNECTION_SELECT_CONTROL	0x701
#define CORB_GET_CONNECTION_LIST_ENTRY	0xf02
#define CORB_GET_PROCESSING_STATE	0xf03
#define CORB_SET_PROCESSING_STATE	0x703
#define CORB_GET_COEFFICIENT_INDEX	0xd00
#define CORB_SET_COEFFICIENT_INDEX	0x500
#define CORB_GET_PROCESSING_COEFFICIENT	0xc00
#define CORB_SET_PROCESSING_COEFFICIENT	0x400
#define CORB_GET_AMPLIFIER_GAIN_MUTE	0xb00
#define		CORB_GAGM_INPUT		0x0000
#define		CORB_GAGM_OUTPUT	0x8000
#define		CORB_GAGM_RIGHT		0x0000
#define		CORB_GAGM_LEFT		0x2000
#define		CORB_GAGM_MUTE		0x00000080
#define		CORB_GAGM_GAIN(x)	(x & 0x0000007f)
#define CORB_SET_AMPLIFIER_GAIN_MUTE	0x300
#define		CORB_AGM_GAIN_MASK	0x007f
#define		CORB_AGM_MUTE		0x0080
#define		CORB_AGM_INDEX_SHIFT	8
#define		CORB_AGM_RIGHT		0x1000
#define		CORB_AGM_LEFT		0x2000
#define		CORB_AGM_INPUT		0x4000
#define		CORB_AGM_OUTPUT		0x8000
#define CORB_GET_CONVERTER_FORMAT	0xa00
#define CORB_SET_CONVERTER_FORMAT	0x200
#define CORB_GET_DIGITAL_CONTROL	0xf0d
#define CORB_SET_DIGITAL_CONTROL_L	0x70d
#define CORB_SET_DIGITAL_CONTROL_H	0x70e
#define		CORB_DCC_DIGEN		0x01
#define		CORB_DCC_V		0x02
#define		CORB_DCC_VCFG		0x04
#define		CORB_DCC_PRE		0x08
#define		CORB_DCC_COPY		0x10
#define		CORB_DCC_NAUDIO		0x20
#define		CORB_DCC_PRO		0x40
#define		CORB_DCC_L		0x80
#define		CORB_DCC_CC(x)		((x >> 8) & 0x7f)
#define CORB_GET_POWER_STATE		0xf05
#define CORB_SET_POWER_STATE		0x705
#define		CORB_PS_D0		0x0
#define		CORB_PS_D1		0x1
#define		CORB_PS_D2		0x2
#define		CORB_PS_D3		0x3
#define CORB_GET_CONVERTER_STREAM_CHANNEL	0xf06
#define CORB_SET_CONVERTER_STREAM_CHANNEL	0x706
#define CORB_GET_INPUT_CONVERTER_SDI_SELECT	0xf04
#define CORB_SET_INPUT_CONVERTER_SDI_SELECT	0x704
#define CORB_GET_PIN_WIDGET_CONTROL	0xf07
#define CORB_SET_PIN_WIDGET_CONTROL	0x707
#define		CORB_PWC_HEADPHONE	0x80
#define		CORB_PWC_OUTPUT		0x40
#define		CORB_PWC_INPUT		0x20
#define		CORB_PWC_VREF_MASK	0x07
#define		CORB_PWC_VREF_HIZ	0x00
#define		CORB_PWC_VREF_50	0x01
#define		CORB_PWC_VREF_GND	0x02
#define		CORB_PWC_VREF_80	0x04
#define		CORB_PWC_VREF_100	0x05
#define CORB_GET_UNSOLICITED_RESPONSE	0xf08
#define CORB_SET_UNSOLICITED_RESPONSE	0x708
#define		CORB_UNSOL_ENABLE	0x80
#define		CORB_UNSOL_TAG(x)	(x & 0x3f)
#define CORB_GET_PIN_SENSE		0xf09
#define		CORB_PS_PRESENCE	0x80000000
#define		CORB_PS_IMPEDANCE(x)	(x & 0x7fffffff)
#define CORB_EXECUTE_PIN_SENSE		0x709
#define		CORB_PS_RIGHT		0x1
#define CORB_GET_EAPD_BTL_ENABLE	0xf0c
#define CORB_SET_EAPD_BTL_ENABLE	0x70c
#define		CORB_EAPD_BTL		0x01
#define		CORB_EAPD_EAPD		0x02
#define		CORB_EAPD_LRSWAP	0x04
#define CORB_GET_GPI_DATA		0xf10
#define CORB_SET_GPI_DATA		0x710
#define CORB_GET_GPI_WAKE_ENABLE_MASK	0xf11
#define CORB_SET_GPI_WAKE_ENABLE_MASK	0x711
#define CORB_GET_GPI_UNSOLICITED_ENABLE_MASK	0xf12
#define CORB_SET_GPI_UNSOLICITED_ENABLE_MASK	0x712
#define CORB_GET_GPI_STICKY_MASK	0xf13
#define CORB_SET_GPI_STICKY_MASK	0x713
#define CORB_GET_GPO_DATA		0xf14
#define CORB_SET_GPO_DATA		0x714
#define CORB_GET_GPIO_DATA		0xf15
#define CORB_SET_GPIO_DATA		0x715
#define CORB_GET_GPIO_ENABLE_MASK	0xf16
#define CORB_SET_GPIO_ENABLE_MASK	0x716
#define CORB_GET_GPIO_DIRECTION		0xf17
#define CORB_SET_GPIO_DIRECTION		0x717
#define CORB_GET_GPIO_WAKE_ENABLE_MASK	0xf18
#define CORB_SET_GPIO_WAKE_ENABLE_MASK	0x718
#define CORB_GET_GPIO_UNSOLICITED_ENABLE_MASK	0xf19
#define CORB_SET_GPIO_UNSOLICITED_ENABLE_MASK	0x719
#define CORB_GET_GPIO_STICKY_MASK	0xf1a
#define CORB_SET_GPIO_STICKY_MASK	0x71a
#define CORB_GET_GPIO_POLARITY		0xfe7
#define CORB_SET_GPIO_POLARITY		0x7e7
#define CORB_GET_BEEP_GENERATION	0xf0a
#define CORB_SET_BEEP_GENERATION	0x70a
#define CORB_GET_VOLUME_KNOB		0xf0f
#define CORB_SET_VOLUME_KNOB		0x70f
#define		CORB_VKNOB_DIRECT	0x80
#define		CORB_VKNOB_VOLUME(x)	(x & 0x7f)
#define CORB_GET_SUBSYSTEM_ID		0xf20
#define CORB_SET_SUBSYSTEM_ID_1		0x720
#define CORB_SET_SUBSYSTEM_ID_2		0x721
#define CORB_SET_SUBSYSTEM_ID_3		0x722
#define CORB_SET_SUBSYSTEM_ID_4		0x723
#define CORB_GET_CONFIGURATION_DEFAULT	0xf1c
#define CORB_SET_CONFIGURATION_DEFAULT_1	0x71c
#define CORB_SET_CONFIGURATION_DEFAULT_2	0x71d
#define CORB_SET_CONFIGURATION_DEFAULT_3	0x71e
#define CORB_SET_CONFIGURATION_DEFAULT_4	0x71f
#define		CORB_CD_SEQUENCE(x)	(x & 0x0000000f)
#define		CORB_CD_SEQUENCE_MAX	0x0f
#define		CORB_CD_ASSOCIATION(x)	((x >> 4) & 0xf)
#define		CORB_CD_ASSOCIATION_MAX	0x0f
#define		CORB_CD_MISC_MASK	0x00000f00
#define		CORB_CD_MISC(x)		((x >> 8) & 0xf)
#define			CORB_CD_PRESENCEOV	0x1
#define		CORB_CD_COLOR(x)	((x >> 12) & 0xf)
#define			CORB_CD_COLOR_UNKNOWN	0x0
#define			CORB_CD_BLACK	0x1
#define			CORB_CD_GRAY	0x2
#define			CORB_CD_BLUE	0x3
#define			CORB_CD_GREEN	0x4
#define			CORB_CD_RED	0x5
#define			CORB_CD_ORANGE	0x6
#define			CORB_CD_YELLOW	0x7
#define			CORB_CD_PURPLE	0x8
#define			CORB_CD_PINK	0x9
#define			CORB_CD_WHITE	0xe
#define			CORB_CD_COLOR_OTHER	0xf
#define		CORB_CD_CONNECTION_OFFSET	16
#define		CORB_CD_CONNECTION_BITS		0xf
#define		CORB_CD_CONNECTION_MASK	(CORB_CD_CONNECTION_BITS << CORB_CD_CONNECTION_OFFSET)
#define		CORB_CD_CONNECTION(x) ((x >> CORB_CD_CONNECTION_OFFSET) & CORB_CD_CONNECTION_BITS)
#define			CORB_CD_CONN_UNKNOWN	0x0
#define			CORB_CD_18		0x1
#define			CORB_CD_14		0x2
#define			CORB_CD_ATAPI		0x3
#define			CORB_CD_RCA		0x4
#define			CORB_CD_OPTICAL		0x5
#define			CORB_CD_OTHER_DIG	0x6
#define			CORB_CD_OTHER_ANALOG	0x7
#define			CORB_CD_DIN		0x8
#define			CORB_CD_XLF		0x9
#define			CORB_CD_RJ11		0xa
#define			CORB_CD_CONN_COMB	0xb
#define			CORB_CD_CONN_OTHER	0xf
#define		CORB_CD_DEVICE_OFFSET		20
#define		CORB_CD_DEVICE_BITS		0xf
#define		CORB_CD_DEVICE_MASK (CORB_CD_DEVICE_BITS << CORB_CD_DEVICE_OFFSET)
#define		CORB_CD_DEVICE(x) ((x >> CORB_CD_DEVICE_OFFSET) & CORB_CD_DEVICE_BITS)
#define			CORB_CD_LINEOUT		0x0
#define			CORB_CD_SPEAKER		0x1
#define			CORB_CD_HEADPHONE	0x2
#define			CORB_CD_CD		0x3
#define			CORB_CD_SPDIFOUT	0x4
#define			CORB_CD_DIGITALOUT	0x5
#define			CORB_CD_MODEMLINE	0x6
#define			CORB_CD_MODEMHANDSET	0x7
#define			CORB_CD_LINEIN		0x8
#define			CORB_CD_AUX		0x9
#define			CORB_CD_MICIN		0xa
#define			CORB_CD_TELEPHONY	0xb
#define			CORB_CD_SPDIFIN		0xc
#define			CORB_CD_DIGITALIN	0xd
#define			CORB_CD_BEEP		0xe
#define			CORB_CD_DEVICE_OTHER	0xf
#define		CORB_CD_LOCATION_MASK	0x3f000000
#define		CORB_CD_LOC_GEO(x)	((x >> 24) & 0xf)
#define			CORB_CD_LOC_GEO_NA	0x0
#define			CORB_CD_REAR		0x1
#define			CORB_CD_FRONT		0x2
#define			CORB_CD_LEFT		0x3
#define			CORB_CD_RIGHT		0x4
#define			CORB_CD_TOP		0x5
#define			CORB_CD_BOTTOM		0x6
#define			CORB_CD_LOC_SPEC0	0x7
#define			CORB_CD_LOC_SPEC1	0x8
#define			CORB_CD_LOC_SPEC2	0x9
#define		CORB_CD_LOC_CHASS(x)	((x >> 28) & 0x3)
#define			CORB_CD_EXTERNAL	0x0
#define			CORB_CD_INTERNAL	0x1
#define			CORB_CD_SEPARATE	0x2
#define			CORB_CD_LOC_OTHER	0x3
#define		CORB_CD_PORT_OFFSET		30
#define		CORB_CD_PORT_BITS		0x3
#define		CORB_CD_PORT_MASK (CORB_CD_PORT_BITS << CORB_CD_PORT_OFFSET)
#define		CORB_CD_PORT(x)	((x >> CORB_CD_PORT_OFFSET) & CORB_CD_PORT_BITS)
#define			CORB_CD_JACK		0x0
#define			CORB_CD_NONE		0x1
#define			CORB_CD_FIXED		0x2
#define			CORB_CD_BOTH		0x3
#define CORB_GET_STRIPE_CONTROL		0xf24
#define CORB_SET_STRIPE_CONTROL		0x720	/* XXX typo in the spec? */
#define CORB_EXECUTE_FUNCTION_RESET	0x7ff

#define CORB_NID_ROOT		0
#define HDA_MAX_CHANNELS	16
#define HDA_MAX_SENSE_PINS	16
#define HDA_MAX_CODECS		15

#define AZ_MAX_VOL_SLAVES	16
#define AZ_TAG_SPKR		0x01
#define AZ_TAG_PLAYVOL		0x02

#define AZ_CLASS_INPUT	0
#define AZ_CLASS_OUTPUT	1
#define AZ_CLASS_RECORD	2

#define AZ_QRK_NONE		0x00000000
#define AZ_QRK_GPIO_MASK	0x00000fff
#define AZ_QRK_GPIO_UNMUTE_0	0x00000001
#define AZ_QRK_GPIO_UNMUTE_1	0x00000002
#define AZ_QRK_GPIO_UNMUTE_2	0x00000004
#define AZ_QRK_GPIO_UNMUTE_3	0x00000008
#define AZ_QRK_GPIO_UNMUTE_4	0x00000010
#define AZ_QRK_GPIO_UNMUTE_5	0x00000020
#define AZ_QRK_GPIO_UNMUTE_6	0x00000040
#define AZ_QRK_GPIO_UNMUTE_7	0x00000080
#define AZ_QRK_GPIO_POL_0	0x00000100
#define AZ_QRK_WID_MASK		0x000ff000
#define AZ_QRK_WID_CDIN_1C	0x00001000
#define AZ_QRK_WID_BEEP_1D	0x00002000
#define AZ_QRK_WID_OVREF50	0x00004000
#define AZ_QRK_WID_AD1981_OAMP	0x00008000
#define AZ_QRK_WID_TPDOCK1	0x00010000
#define AZ_QRK_WID_TPDOCK2	0x00020000
#define AZ_QRK_WID_TPDOCK3	0x00040000

/* memory-mapped types */
typedef struct {
	uint32_t low;
	uint32_t high;
	uint32_t length;
	uint32_t flags;
#define	BDLIST_ENTRY_IOC	0x00000001
} __packed bdlist_entry_t;
#define HDA_BDL_MAX	256

typedef struct {
	uint32_t position;
	uint32_t reserved;
} __packed dmaposition_t;

typedef uint32_t corb_entry_t;
typedef struct {
	uint32_t resp;
	uint32_t resp_ex;
#define RIRB_UNSOL_TAG(resp)   ((resp) >> 26)
#define RIRB_RESP_UNSOL                (1 << 4)
#define RIRB_RESP_CODEC(ex)    ((ex) & 0xf)
} __packed rirb_entry_t;


/* #define AZALIA_DEBUG */
#ifdef AZALIA_DEBUG
# define DPRINTF(x)	do { printf x; } while (0/*CONSTCOND*/)
#else
# define DPRINTF(x)	do {} while (0/*CONSTCOND*/)
#endif
#define PTR_UPPER32(x)	((uint64_t)(x) >> 32)

typedef int nid_t;

typedef struct {
	nid_t nid;
	int enable;
	uint32_t widgetcap;
	int type;		/* = bit20-24 of widgetcap */
	nid_t parent;
	int mixer_class;
	int nconnections;
	nid_t *connections;
	int selected;
	uint32_t inamp_cap;
	uint32_t outamp_cap;
	char name[MAX_AUDIO_DEV_LEN];
	union {
		struct {	/* for AUDIO_INPUT/OUTPUT */
			uint32_t encodings;
			uint32_t bits_rates;
		} audio;
		struct {	/* for PIN */
			uint32_t cap;
			uint32_t config;
			int sequence;
			int association;
			int color;
			int device;
		} pin;
		struct {	/* for VOLUME_KNOB */
			uint32_t cap;
		} volume;
	} d;
} widget_t;
#define	WIDGET_CHANNELS(w)	((w)->widgetcap & COP_AWCAP_STEREO ? 2 : 1)

typedef struct {
	mixer_devinfo_t devinfo;
	nid_t nid;		/* target NID; 0 is invalid. */
	int target;		/* 0-15: inamp index, 0x100: outamp, ... */
#define IS_MI_TARGET_INAMP(x)	((x) <= 15)
#define MI_TARGET_INAMP(x)	(x)
#define MI_TARGET_OUTAMP	0x100
#define MI_TARGET_CONNLIST	0x101
#define MI_TARGET_PINDIR	0x102 /* for bidirectional pin */
#define MI_TARGET_PINBOOST	0x103 /* for headphone pin */
#define MI_TARGET_DAC		0x104
#define MI_TARGET_ADC		0x105
#define MI_TARGET_VOLUME	0x106
#define MI_TARGET_SPDIF		0x107
#define MI_TARGET_SPDIF_CC	0x108
#define MI_TARGET_EAPD		0x109
#define MI_TARGET_MUTESET	0x10a
#define MI_TARGET_PINSENSE	0x10b
#define MI_TARGET_SENSESET	0x10c
#define MI_TARGET_PLAYVOL	0x10d
#define MI_TARGET_RECVOL	0x10e
#define MI_TARGET_MIXERSET	0x10f
	union {
		int ord;
		int mask;
		mixer_level_t value;
	} saved;
} mixer_item_t;

#define VALID_WIDGET_NID(nid, codec)	(nid == (codec)->audiofunc || \
					 (nid >= (codec)->wstart &&   \
					  nid < (codec)->wend))

typedef struct {
	int nconv;
	nid_t conv[HDA_MAX_CHANNELS];
} convgroup_t;
typedef struct {
	int cur;
	int ngroups;
	convgroup_t groups[2];
} convgroupset_t;

typedef struct {
	int master;
	int vol_l;
	int vol_r;
	int mute;
	int hw_step;
	int hw_nsteps;
	nid_t slaves[AZ_MAX_VOL_SLAVES];
	int nslaves;
	int mask;
	int cur;
} volgroup_t;

struct io_pin {
	nid_t nid;		/* NID of pin */
	nid_t conv;		/* NID of default converter */
	int prio;		/* assoc/seq/dir "priority" */
};

typedef struct codec_t {
	struct azalia_t *az;
	uint32_t vid;		/* codec vendor/device ID */
	uint32_t subid;		/* PCI subvendor/device ID */
	const char *name;
	int address;
	int nfunctions;
	nid_t audiofunc;	/* NID of an audio function node */
	nid_t wstart;		/* start NID of audio widgets */
	nid_t wend;		/* the last NID of audio widgets + 1 */
	widget_t *w;		/* widgets in the audio function.
				 * w[0] to w[wstart-1] are unused. */
#define FOR_EACH_WIDGET(this, i)	for (i = (this)->wstart; i < (this)->wend; i++)

	int codec_type;
#define AZ_CODEC_TYPE_ANALOG	0
#define AZ_CODEC_TYPE_DIGITAL	1
#define AZ_CODEC_TYPE_HDMI	2

	int qrks;

	convgroupset_t dacs;
	convgroupset_t adcs;
	int running;

	int nmixers, maxmixers;
	mixer_item_t *mixers;

	struct audio_format *formats;
	int nformats;

	struct io_pin *ipins;
	int nipins;
	struct io_pin *ipins_d;
	int nipins_d;
	struct io_pin *opins;
	int nopins;
	struct io_pin *opins_d;
	int nopins_d;

	nid_t a_dacs[HDA_MAX_CHANNELS], a_dacs_d[HDA_MAX_CHANNELS];
	int na_dacs, na_dacs_d;
	nid_t a_adcs[HDA_MAX_CHANNELS], a_adcs_d[HDA_MAX_CHANNELS];
	int na_adcs, na_adcs_d;

	nid_t mic;		/* fixed (internal) mic */
	nid_t mic_adc;
	nid_t speaker;		/* fixed (internal) speaker */
	nid_t speaker2;		/* 2nd fixed (internal) speaker */
	nid_t spkr_dac;		/* default DAC for speaker and speaker2 */
	nid_t input_mixer;
	nid_t fhp;		/* front headphone jack */
	nid_t fhp_dac;
	int nout_jacks;		/* number of default output jacks */

	int spkr_muted;
	int spkr_muters;
	int spkr_mute_method;
#define	AZ_SPKR_MUTE_NONE	0
#define	AZ_SPKR_MUTE_SPKR_MUTE	1
#define	AZ_SPKR_MUTE_SPKR_DIR	2
#define	AZ_SPKR_MUTE_DAC_MUTE	3

	volgroup_t playvols;
	volgroup_t recvols;

	nid_t sense_pins[HDA_MAX_SENSE_PINS];
	int nsense_pins;
} codec_t;

int	azalia_codec_init_vtbl(codec_t *);
int	azalia_codec_construct_format(codec_t *, int, int);
int	azalia_widget_enabled(const codec_t *, nid_t);
int	azalia_codec_gpio_quirks(codec_t *);
int	azalia_codec_widget_quirks(codec_t *, nid_t);
int	azalia_codec_fnode(codec_t *, nid_t, int, int);

int	azalia_init_dacgroup(codec_t *);
int	azalia_mixer_init(codec_t *);
int	azalia_mixer_delete(codec_t *);
int	azalia_unsol_event(codec_t *, int);
int	azalia_comresp(const codec_t *, nid_t, uint32_t, uint32_t, uint32_t *);
int	azalia_mixer_get(const codec_t *, nid_t, int, mixer_ctrl_t *);
int	azalia_mixer_set(codec_t *, nid_t, int, const mixer_ctrl_t *);

int	azalia_codec_enable_unsol(codec_t *);
@


1.64
log
@Audio on the T400/T410/T510/T420/T520/X220/X220t docks needs a quirk
for the pin configuration as well.

From Dmitry Alenichev.  ok mlarkin@@
@
text
@a676 2
	struct audio_encoding *encs;
	int nencs;
@


1.63
log
@
Enable audio on Thinkpad docks. Help from jsg@@ for the *40 / *50 series
docks.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.62 2010/09/10 15:11:23 jakemsr Exp $	*/
d515 1
@


1.62
log
@if the speaker is muted because headphones are plugged in, don't
unmute the speaker when the master volume control is unmuted
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.61 2010/08/07 20:48:56 jakemsr Exp $	*/
d513 2
@


1.61
log
@restore unsolicited responses from volume knob widgets
tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.60 2010/06/27 21:47:07 jakemsr Exp $	*/
d701 1
@


1.60
log
@don't probe "volume knobs" on resume.  probably not needed and
is currently breaking resume.
ok pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.59 2010/03/21 15:02:31 jakemsr Exp $	*/
d730 1
a730 1
int	azalia_codec_enable_unsol(codec_t *, int);
@


1.59
log
@deal with the possibility of two internal speaker pins, like on
macbooks that have a "normal" pair of stereo speakers as well
as subwoofer(s).  problem reported and fix tested by Ted Roby.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.58 2009/12/22 08:48:14 jakemsr Exp $	*/
d730 1
a730 1
int	azalia_codec_enable_unsol(codec_t *);
@


1.58
log
@treat the front headphone jack more like a built-in speaker.  make it's
default DAC receive the first playback stereo channel pair if the DAC
wouldn't otherwise be used and allow the jack's output volume to be
controlled by outputs.master by default.  this was already mostly
implemented for codecs with 3 or more dacs, but front headphone jacks
are also common on 2 dac codecs as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.57 2009/11/24 10:00:39 jakemsr Exp $	*/
d694 2
a695 1
	nid_t spkr_dac;
@


1.57
log
@implement suspend and resume
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.56 2009/10/11 06:45:46 jakemsr Exp $	*/
d696 1
@


1.56
log
@* define a constant for the specification defined maximum number of
codecs a controller can support
* dynamically allocate memory for the array of codec structures
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.55 2009/10/11 00:07:06 jakemsr Exp $	*/
d604 5
@


1.55
log
@this driver doesn't yet support HDMI codecs enough for them to be
usable.  detach the driver if the device is only capable of HDMI.
this keeps an unusable device from being /dev/audio0 (thus
/dev/audio by default), while /dev/audio1 is fully functional.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.54 2009/09/09 02:22:21 jakemsr Exp $	*/
d487 1
@


1.54
log
@move code to enable widget unsolicited event generation into it's
own function
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.53 2009/09/09 00:26:57 jakemsr Exp $	*/
d260 1
d651 5
@


1.53
log
@azalia.h:
* remove irrelevant comment
* this driver uses at most 2 converter groups per group set, don't
allocate more than needed
* remove unused members from codec_t
azalia.c:
* macros for register values
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.52 2009/06/09 05:16:42 jakemsr Exp $	*/
d715 2
@


1.52
log
@AD1981HD output amps are weird.  they report 63 volume steps but the
first 30 do nothing.  perhaps there are other codecs with such
amps?  (ab)use some reserved bits in the amplifier capabilities
parameter to store the first volume step that actually changes the
volume.  problem reported and patch tested by LEVAI Daniel.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.51 2009/06/09 05:05:48 jakemsr Exp $	*/
d610 1
a610 1
	nid_t conv[HDA_MAX_CHANNELS]; /* front, surround, clfe, side, ... */
d615 1
a615 1
	convgroup_t groups[32];
a637 2
	int (*comresp)(const struct codec_t *, nid_t, uint32_t, uint32_t, uint32_t *);

a698 3

	uint32_t *extra;
	u_int rate;
@


1.51
log
@quirks for MacBookPro3,1 inspired by FreeBSD's snd_hda.  problem
reported and patch tested by Bryan Chapman.  according to FreeBSD,
this might be needed for other MacBookPro models but no one else has
told me their MacBookPro doesn't work.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.50 2009/05/31 03:22:05 jakemsr Exp $	*/
d266 1
d510 1
@


1.50
log
@zap _generic from the names of several functions.  there are no
more non-generic versions, and there never will be again.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.49 2009/05/31 02:57:51 jakemsr Exp $	*/
d508 1
@


1.49
log
@- all codecs now use the same functions, always.  call the functions
directly instead of through pointers in the codec_t.
- fold azalia_generic_{g,s}et_port into azalia_{g,s}et_port since both
are small and partly duplicated eachother.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.48 2009/05/29 21:16:37 jakemsr Exp $	*/
d715 2
a716 2
int	azalia_generic_mixer_get(const codec_t *, nid_t, int, mixer_ctrl_t *);
int	azalia_generic_mixer_set(codec_t *, nid_t, int, const mixer_ctrl_t *);
@


1.48
log
@register all GPIO and widget "quirks" in a bitmask instead of using
macros and codec->init_widget.  now there is only only place to look
to see what special handling a specific codec will get.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.47 2009/05/29 17:54:08 jakemsr Exp $	*/
a635 6
	int (*init_dacgroup)(struct codec_t *);
	int (*mixer_init)(struct codec_t *);
	int (*mixer_delete)(struct codec_t *);
	int (*set_port)(struct codec_t *, mixer_ctrl_t *);
	int (*get_port)(struct codec_t *, mixer_ctrl_t *);
	int (*unsol_event)(struct codec_t *, int);
d709 8
@


1.47
log
@- if a codec is capable of multichannel playback, try to connect
the output jacks to different DACs.
- multichannel codecs often have a front headphone jack that is
intended to be used separately from the multichannel jacks.  if a front
headphone jack exists, try to connect it to a DAC not used by the
multichannel jacks.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.46 2009/05/29 02:38:01 jakemsr Exp $	*/
d494 15
a636 1
	int (*init_widget)(const struct codec_t *, widget_t *, nid_t);
d656 2
d713 1
@


1.46
log
@- when a widget will be considered part of a different widget, record
the node id of the "parent" widget
- initialize widgets' mixer_class ealier
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.45 2009/05/12 09:32:28 jakemsr Exp $	*/
d673 2
@


1.45
log
@- try to identify a "main input mixer"
- don't unmute input from a built-in mic on the main input mixer
intended to stop possible feedback loops between buit-in speakers
and built-in mics.  built-in mics also tend to capture machine
noise, especially fans.  actual recording should not be affected.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.44 2009/05/01 02:55:16 jakemsr Exp $	*/
d534 1
@


1.44
log
@allow jack sensing to mute the DAC the speaker is connected to by
default, as long is the first output pin is not also connected to
that DAC.  cleanup a bit now that there are multiple muting methods.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.43 2009/04/24 16:05:06 jakemsr Exp $	*/
d671 1
@


1.43
log
@drop _generic from azalia_generic_codec_fnode().  there will not
be a non-generic version.  move the prototype to azalia.h so it
can also be used in azalia.c in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.42 2009/04/24 16:02:17 jakemsr Exp $	*/
d673 5
@


1.42
log
@create lists of analog and digital input and output pins.  store
the pin nids, the default converter the pin connects to and the
pin's priority.  priority is based on the pin's default direction
and the association and sequence numbers from the vendor.  according
to the hda spec, lower association/priority means higher priority.
sort the list in order of highest to lowest priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.41 2009/04/24 15:31:18 jakemsr Exp $	*/
d688 1
@


1.41
log
@after all widgets have been initialized, loop through all widgets
and do some further initialization and information gathering:
- disable mixer and selector widgets that don't have any enabled
  connections
- create lists of analog and digital input and output converters
- find the internal/fixed connection microphone and speaker, and
  which converters they are connected to by default
- create a list of jack sensing capable pins

some of this was already being done in other places, but moved here
for simplification/better organization
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.40 2009/01/05 09:46:26 jakemsr Exp $	*/
d612 6
d652 9
@


1.40
log
@expand the _dir controls for output pins to also be able to select
VRef level and be sure to turn VRef off when not set for input.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.39 2009/01/05 08:19:31 jakemsr Exp $	*/
d642 1
a642 1
	struct audio_format* formats;
d644 1
a644 1
	struct audio_encoding* encs;
d647 10
a656 4
	int headphones;
	int hp_dac;
	int speaker;
	int spkr_dac;
a657 1
	int mic;
@


1.39
log
@remove now unused macros
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.38 2009/01/05 07:55:34 jakemsr Exp $	*/
d336 1
@


1.38
log
@use AUDIO_MIXER_SET instead of AUDIO_MIXER_ENUM to display mixers
that don't have selectable inputs.  all connections are active, always.
showing all connections in the set rather than just one makes a lot
more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.37 2009/01/03 19:17:45 jakemsr Exp $	*/
a285 6
#define		CORB_CLE_LONG_0(x)	(x & 0x0000ffff)
#define		CORB_CLE_LONG_1(x)	((x & 0xffff0000) >> 16)
#define		CORB_CLE_SHORT_0(x)	(x & 0xff)
#define		CORB_CLE_SHORT_1(x)	((x >> 8) & 0xff)
#define		CORB_CLE_SHORT_2(x)	((x >> 16) & 0xff)
#define		CORB_CLE_SHORT_3(x)	((x >> 24) & 0xff)
@


1.37
log
@- configure volume knob widgets for indirect mode, which means they no
longer direcly affect other widgets
- if an unsolicited response is received from a volume knob widget,
adjust outputs.master according to the measured change in level of the
volume knob widget
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.36 2009/01/02 22:32:25 jakemsr Exp $	*/
d587 1
@


1.36
log
@- get rid of the function that was mostly just a wrapper for the old
function for creating "master" volume control.
- apply gpio quirks separately from and prior to configuring the mixer.
gpio manipulation can cause noise on output channels.  configuring
gpio before amps are unmuted in the mixer configuration is a good
thing.

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.35 2009/01/02 20:37:57 jakemsr Exp $	*/
d493 1
d608 2
@


1.35
log
@add macros for setting/getting GPIO polarity instead of using
magic numbers

from Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.34 2009/01/02 20:18:18 jakemsr Exp $	*/
a664 1

d668 1
@


1.34
log
@this is what I really wanted with r1.100 of azalia.c - fixed mics
are not really useful as output devices and fixed speakers are not
really useful as input devices
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.33 2009/01/02 00:39:25 jakemsr Exp $	*/
d383 2
@


1.33
log
@now that some devices will get output from/to two different sources/
outputs by default it's nice to have a way to control multiple sources/
outputs with a single control setting.

so here's an implementation of "master" controls that uses selectable
control lists, because the biggest problem is figuring out what should
be "master".

outputs.master.slaves is the current set of output mixer controls
that settings for outputs.master and outputs.master will be applied
to.  record.volume.slaves works similarly for recording inputs.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.32 2009/01/02 00:25:33 jakemsr Exp $	*/
d647 1
a648 1
	int hp_dac;
d651 1
@


1.32
log
@- store information about relevant volume controls along both
recording and playback paths.
- select a subset of controls that are relevant in a default
configuration for each path.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.31 2008/12/31 13:13:39 jakemsr Exp $	*/
d582 2
@


1.31
log
@reimplement jack sense/speaker auto muting using unsolicited responses.
jacks which can mute speaker output are chosen with the new mixer item
'outputs.spkr_muters'.  e.g.

$ mixerctl -v outputs.spkr_muters
outputs.spkr_muters=hp,mic,line-in  { hp mic line-in }

if a jack is present in any listed "muter" plug, AND that plug is
configured for output (e.g. outputs.hp_dir=output) the speaker will
be muted.  the list of muters is selectable, selecting none turns of
muting altogether.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.30 2008/12/31 11:54:55 jakemsr Exp $	*/
d489 1
d598 11
d649 3
@


1.30
log
@builtin speakers and headphone jacks have an interesting relationship.
keep track of some information about them, such as the DAC they are
connected to by default.  this will be used soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.29 2008/12/23 04:12:19 jakemsr Exp $	*/
d489 2
d580 1
@


1.29
log
@a) a widget's nid is always it's index in the codec's widget list.
b) members of the widget connection list may be invalid.
so,
- change azalia_nid_to_index to azalia_widget_enabled, and have it only
check that the given nid is valid, and that the corresponding widget
is enabled.
- use azalia_widget_enabled every time members of the connection list
are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.28 2008/12/22 00:03:08 jakemsr Exp $	*/
d628 6
@


1.28
log
@- expand/add macros for pin configuration manipulation
- use "beep" as pin device 0xe
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.27 2008/12/21 20:21:24 jakemsr Exp $	*/
d639 1
@


1.27
log
@add mixer_class member to struct widget_t, and define the mixer
classes in azalia.h instead of azalia_codec.c.  this will allow
the mixer class to be determined outside of azalia_generic_mixer_init.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.26 2008/11/30 08:36:57 jakemsr Exp $	*/
d419 4
a422 2
#define		CORB_CD_CONNECTION_MASK	0x000f0000
#define		CORB_CD_CONNECTION(x)	((x >> 16) & 0xf)
d436 4
a439 1
#define		CORB_CD_DEVICE(x)	((x >> 20) & 0xf)
d454 1
d473 4
a476 2
#define		CORB_CD_PORT_MASK	0xc0000000
#define		CORB_CD_PORT(x)		((x >> 30) & 0x3)
@


1.26
log
@- AZ_MAX_SENSE_PINS -> HDA_MAX_SENSE_PINS
- MI_TARGET_* are enumerated in hex

from Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.25 2008/11/28 21:45:49 jakemsr Exp $	*/
d481 4
d525 1
@


1.25
log
@AZ_TARGET_PINSENSE -> MI_TARGET_PINSENSE

reminder from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.24 2008/11/28 21:33:26 jakemsr Exp $	*/
d479 1
a479 1
#define AZ_MAX_SENSE_PINS	8
d563 2
a564 2
#define MI_TARGET_MUTESET	0x110
#define MI_TARGET_PINSENSE	0x111
d616 1
a616 1
	nid_t sense_pins[AZ_MAX_SENSE_PINS];
@


1.24
log
@check the jack detect override bit before creating jack sense mixer
items.  BIOSes can set the jack detect override bit to tell us that
the jack detection circuirty isn't actually attached.

should remove the _sense controls that never change.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.23 2008/11/28 04:03:37 jakemsr Exp $	*/
d564 1
a564 1
#define AZ_TARGET_PINSENSE	0xf00
@


1.23
log
@
- use switch() instead of multiple if else
- put selectors that feed ADCs into the record class like we do for
mixers
- use azalia_nid_to_index more
- shrink mixer items list by condensing mutes for multiple input
sources into a single _source control of type AUDIO_MIXER_SET.
for example,

record.mix6_mic_mute=off
record.mix6_mic2_mute=off
record.mix6_line_mute=off
record.mix6_hp_mute=off
record.mix6_spkr_mute=off
record.mix6_mix_mute=off

is now represented as

record.mix6_source=mic,mic2,line,hp,spkr,mix

to mute all sources but the mic just do

record.mix6_source=mic

reduces mixer items by about 25% on my machine.  also shortens the
longest names.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.22 2008/11/27 23:30:58 jakemsr Exp $	*/
d404 2
@


1.22
log
@
widget initialization cleanup:
* configure widgets all in one place
* add a flag on the widget_t to let us know if the widget is not
connected; shaves a lot of connection checking code
* be sure not to add power widgets as connectable sources/sinks
* configure unconnected pins as output pins.  should help some
MacBooks and be benign to other devices.

the last change has been tested by several as a separate diff.  no
real functional changes otherwise.

from Alexey Suslikov.  thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.21 2008/11/19 03:44:14 jakemsr Exp $	*/
d561 1
@


1.21
log
@
the jack sense automatic muting code has many problems, including
being the cause of PR5982.  unfortunately, there's no easy and clean
solution to automatic muting.  we can't always rely on the codec
giving us the right information.  people have different preferences
as to what should be muted and what shouldn't.  etc, etc.

so instead, just make the sense state of jacks that support sensing
available through the mixer interface.  this allows for any possible
user configuration and supports all pins that have sense capabilities,
not just headpones.  codecs that use the generic mixer configuration
(which is the plan for all codecs) and have sensing capable pins will
now get a few more read-only mixer items, such as:

outputs.hp_sense=plugged
outputs.mic_sense=unplugged
outputs.line_sense=unplugged

hopefully what they mean is self-explanatory.

based on much discussion with ratchov@@ and Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.20 2008/11/05 03:20:35 jakemsr Exp $	*/
d516 1
a566 9

#define PIN_STATUS(wid, conn)						\
	do {								\
		if ((wid)->type != COP_AWTYPE_PIN_COMPLEX)		\
			(conn) = 0;					\
		else							\
			(conn) =					\
			    ((wid)->d.pin.config & CORB_CD_PORT_MASK) >> 30; \
	} while (0)
@


1.20
log
@remove unused macros, partly from Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.19 2008/11/04 20:55:43 jakemsr Exp $	*/
d477 1
d560 1
d620 3
@


1.19
log
@implement azalia_create_encodings, which scans through the supported
formats and creates an array of unique encodings.  use the array in
azalia_query_encoding.

in other words, no more duplicate encodings in `audioctl encodings`.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.18 2008/11/04 07:58:43 jakemsr Exp $	*/
a509 1
#define FLAGBUFLEN	256
@


1.18
log
@
volume scaling/setting cleanup:

* MAX_VOLUME_255 has been defined for ages.  remove this define
and the code that was only being used when this wasn't defined.
* remove azalia_generic_mixer_{max,validate_value} since they
are pointless.
* when setting both stereo channels to the same level, just set
the right channel level to the left channel level instead of
calculating both separately.

from Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.17 2008/10/16 19:16:58 jakemsr Exp $	*/
d617 2
a618 1
	struct audio_encoding_set *encodings;
@


1.17
log
@
Add S/PDIF support. From NetBSD.

Clean up a little while here.

from Alexey Suslikov, thanks

tested by several as part of a larger diff, thanks also
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.16 2008/10/16 02:13:12 jakemsr Exp $	*/
a510 1
#define MAX_VOLUME_255	1
@


1.16
log
@
Some pins are not connected and dead-end.  This diff removes such pins
from conection and mixer lists.  It also removes knobs connected to
power widgets.

from NetBSD via Alexey Suslikov, thanks

tested by several, thanks also
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.15 2008/06/26 05:42:17 ray Exp $	*/
d315 12
a326 3
#define CORB_GET_DIGITAL_CONVERTER_CONTROL	0xf0d
#define CORB_SET_DIGITAL_CONVERTER_CONTROL_L	0x70d
#define CORB_SET_DIGITAL_CONVERTER_CONTROL_H	0x70e
d558 3
a560 1
#define MI_TARGET_EAPD		0x107
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.14 2007/10/10 03:39:21 deanna Exp $	*/
d555 9
@


1.14
log
@Rework the debug dmesg to perform a more complete codec dump.

Tested by jmc, ckuethe, kettenis and jakemsr.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.13 2007/09/10 05:39:07 deanna Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@If 44.1kHz sample rate isn't supported, use 48kHz instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.12 2007/09/10 05:34:21 deanna Exp $	*/
d280 5
d416 14
d447 16
d464 5
@


1.12
log
@Add command verbs, a mixer target and mixer controls for EAPD control.
Some codecs, like the AD1984 found in x60s, need this in order for the
speakers to work.

New mixer items with names *.eapd will show up for codecs that need it
and that are using the generic functions.

From kent@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.11 2007/07/23 02:03:42 deanna Exp $	*/
d568 1
@


1.11
log
@We will never make a mixer item out of the pin control operation, so
move it out of azalia_generic_mixer_set into its own function,
azalia_generic_mixer_pinctrl.  From kent@@netbsd.

In azalia_stac9200_mixer_init, let the unsolicited event handler make
the initial headphone vs speaker choice.  Removes some duplicate code.

These changes only affect STAC9200.  Tested by krw@@ on a Latitude
D620.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.10 2007/05/02 17:01:22 deanna Exp $	*/
d351 3
d516 1
@


1.10
log
@- Add support for handling unsolicited events (based on NetBSD).

- The STAC9200 codec was mistakenly referred to as STAC9220.  Change
this to STAC9200 and add a link to the datasheet.

- Add a new target, MI_TARGET_PINCTRL, to azalia_generic_mixer_set()
that allows us to turn pins on and off.

- Add an unsolicited event handler for STAC9200 that will toggle the
headphone and speaker pins.  This means the speaker will now mute and
unmute based on headphone presence.

- Spelling: PRESENSE -> PRESENCE

Tested by ajacoutot@@, tedu@@ and krw@@, ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.9 2006/06/23 23:26:20 brad Exp $	*/
d510 3
a512 4
#define MI_TARGET_PINCTRL	0x104 /* for enabling/disabling pins */
#define MI_TARGET_DAC		0x105
#define MI_TARGET_ADC		0x106
#define MI_TARGET_VOLUME	0x107
@


1.9
log
@add some constant macros for unsolicited response and jack sense.

From kent NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.8 2006/06/16 06:00:46 brad Exp $	*/
d63 1
a63 1
#define		HDA_GCTL_UNSOL	0x00000080
d345 1
a345 1
#define		CORB_PS_PRESENSE	0x80000000
d452 3
a454 1
#define RIRB_UNSOLICITED_RESPONSE	(1 << 4)
d510 4
a513 3
#define MI_TARGET_DAC		0x104
#define MI_TARGET_ADC		0x105
#define MI_TARGET_VOLUME	0x106
d538 1
d563 2
@


1.8
log
@* support for multi-channel (>=3) recording with ALC880, ALC882, or STAC9221
* azalia_codec_init_vtbl()
  recognize the name of AD1983
* azalia_generic_codec_find_dac()
  check validity of a node in a connection list
* introduce MIXER_DELTA, and simplify the code with it
* codec-specific mixer initialization for STAC9220

From kent NetBSD

Tested by a few end-users.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.7 2006/06/14 19:34:52 brad Exp $	*/
d342 2
d345 2
d348 1
@


1.7
log
@* move mixer functions from azalia.c to azalia_codec.c, and
rename them like azalia_mixer_foo() to azalia_generic_mixer_foo()

* enable codec-specific code to hook any mixer operations such
as creating mixer items, or special handling for a specific
item.

* provide a custom mixer table specific to ALC260
* provide a custom mixer table specific to Fujitsu LOOX

From kent NetBSD

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.6 2006/05/11 23:34:35 brad Exp $	*/
d514 1
a514 1
	nid_t conv[HDA_MAX_CHANNELS];
d516 5
d544 2
a545 6
	int ndacgroups;
	convgroup_t dacgroups[32];
	int cur_dac;		/* currently selected DAC group index */
	int nadcs;
	nid_t adcs[32];
	int cur_adc;		/* currently selected ADC index */
d558 1
a558 1
int	azalia_codec_construct_format(codec_t *);
@


1.6
log
@use the PCI multimedia subclass type HD audio define from pcireg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.5 2006/05/08 04:18:43 brad Exp $	*/
d521 4
d527 2
d545 1
d556 2
a557 1
int	azalia_codec_init_vtbl(codec_t *, uint32_t);
@


1.5
log
@sync NetBSD RCS ids
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.h,v 1.4 2006/05/08 04:11:31 brad Exp $	*/
a426 3


#define PCI_SUBCLASS_HDAUDIO	0x03
@


1.4
log
@Don't crash when a connection list has invalid NIDs.

From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: azalia.h,v 1.3 2006/05/08 03:53:57 brad Exp $	*/
/*	$NetBSD: azalia.h,v 1.3 2005/09/29 04:14:03 kent Exp $	*/
@


1.3
log
@OpenBSD RCS ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d510 4
@


1.2
log
@- make this compile with AZALIA_DEBUG
- introduce WIDGET_CHANNELS macro

From NetBSD
@
text
@d1 1
@


1.1
log
@not quite working driver for azalia audio (this is essentially AC97 for > 2005)
Just as brain damaged and ill specified.  From NetBSD.
@
text
@d493 1
@

