head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.6
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.10
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.8
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.16
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.14
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.12
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.10
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.14
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.12
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.10
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2015.10.29.07.47.03;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	QDyL8dFxcUx9R2yh;

1.19
date	2015.08.20.04.41.46;	author mlarkin;	state Exp;
branches;
next	1.18;
commitid	eoSwLmCZ9T7CGJzs;

1.18
date	2014.07.22.04.42.51;	author jsg;	state Exp;
branches;
next	1.17;
commitid	EtAKn2rlAqe8IYXn;

1.17
date	2013.08.12.04.11.52;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.18.10.12.40;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2012.08.22.20.58.30;	author mpi;	state Exp;
branches;
next	1.14;

1.14
date	2010.08.08.17.21.07;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.06.04.38.18;	author pirofti;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.06.00.35.00;	author pirofti;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.12.00.54.38;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.06.19.19.02;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.03.10.09.03;	author martin;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.27.18.04.28;	author gwk;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.16.21.32.34;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.15.20.17.38;	author aaron;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	97.11.06.12.26.56;	author niklas;	state Exp;
branches
	1.2.10.1;
next	1.1;

1.1
date	97.01.24.19.58.02;	author niklas;	state Exp;
branches;
next	;

1.2.10.1
date	2001.05.14.22.26.01;	author niklas;	state Exp;
branches;
next	1.2.10.2;

1.2.10.2
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.2.10.3;

1.2.10.3
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Make inteldrm(4) attach to pci(4) instead of vga(4) just like radeondrm(4).
This is needed for machines where Intel graphics isn't the primary graphics
device and on systems with UEFI firmware that put the device in non-VGA mode.

ok jsg@@
@
text
@/* $OpenBSD: vga_pcivar.h,v 1.19 2015/08/20 04:41:46 mlarkin Exp $ */
/* $NetBSD: vga_pcivar.h,v 1.1 1998/03/22 15:16:19 drochner Exp $ */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#ifndef _PCI_VGA_PCIVAR_H_
#define _PCI_VGA_PCIVAR_H_

#define	DEVICE_IS_VGA_PCI(class)					\
	    (((PCI_CLASS(class) == PCI_CLASS_DISPLAY &&			\
	      PCI_SUBCLASS(class) == PCI_SUBCLASS_DISPLAY_VGA) ||	\
	     (PCI_CLASS(class) == PCI_CLASS_PREHISTORIC &&		\
	      PCI_SUBCLASS(class) == PCI_SUBCLASS_PREHISTORIC_VGA)) ? 1 : 0)

#define VGA_PCI_MAX_BARS 6

struct vga_pci_bar {
	int		addr;
	u_int		mapped;
	pcireg_t	maptype;
	bus_addr_t	base;
	bus_size_t	size;
	bus_size_t	maxsize;
	bus_space_tag_t	bst;
	bus_space_handle_t bsh;
	int		flags;
	void		*vaddr;
};
	
struct vga_pci_softc {
	struct device sc_dev;
	struct vga_config *sc_vc;
	int sc_type;

	struct pci_attach_args pa;
#if NACPI > 0
	struct reg_vgats sc_save_ts;
	struct reg_mc6845 sc_save_crtc;
	struct reg_vgaattr sc_save_atc;
	struct reg_vgagdc sc_save_gdc;
#endif
#ifdef X86EMU
	struct vga_post *sc_posth;
#endif
#ifdef VESAFB
	int sc_width;
	int sc_height;
	int sc_depth;
	int sc_linebytes;
	u_int32_t sc_base;
	int sc_mode;			/* WSDISPLAY_MODE_EMUL or _DUMBFB */
	int sc_textmode;		/* original VESA text mode */
	int sc_gfxmode;			/* VESA graphics mode */
	u_char sc_cmap_red[256];	/* saved color map */
	u_char sc_cmap_green[256];
	u_char sc_cmap_blue[256];
#endif
};

int	vga_pci_cnattach(bus_space_tag_t, bus_space_tag_t,
	    pci_chipset_tag_t, int, int, int);
int	vga_aperture_needed(struct pci_attach_args *);

#endif /* _PCI_VGA_PCIVAR_H_ */
@


1.19
log
@
remove unused vesafb code, had been commented out and not compiled in for
7 years (for some parts, 9 years), and was only ever referenced in i386
anyway.

ok jsg@@, matthieu@@, armani@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.18 2014/07/22 04:42:51 jsg Exp $ */
a60 1
	struct vga_pci_bar *bars[VGA_PCI_MAX_BARS];
a86 5
void	vga_pci_bar_init(struct vga_pci_softc *, struct pci_attach_args *);
struct	vga_pci_bar *vga_pci_bar_info(struct vga_pci_softc *, int);
struct	vga_pci_bar *vga_pci_bar_map(struct vga_pci_softc *, int,
	    bus_size_t, int);
void	vga_pci_bar_unmap(struct vga_pci_bar*);
a87 4

#if NDRM > 0
int	vga_drmsubmatch(struct device *, void *, void *);
#endif
@


1.18
log
@The aperture needed test should be in vgafb as well as vga@@pci.
Problem noticed/fix tested by sebastia@@ on macppc.
sparc64 problems in earlier diff pointed out by deraadt@@
'looks good' kettenis@@ 'commit' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.17 2013/08/12 04:11:52 jsg Exp $ */
a96 7
#endif

#ifdef VESAFB
int	vesafb_find_mode(struct vga_pci_softc *, int, int, int);
void	vesafb_set_mode(struct vga_pci_softc *, int);
int	vesafb_get_mode(struct vga_pci_softc *);
int	vesafb_get_supported_depth(struct vga_pci_softc *);
@


1.17
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.16 2013/03/18 10:12:40 kettenis Exp $ */
d93 1
@


1.16
log
@Provide a way for *drm(4) to prevent the VGA text console wsdisplay(4) instance
from attaching after it has taken over control of the VGA hardware.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.15 2012/08/22 20:58:30 mpi Exp $ */
d95 1
a95 1
int	drmsubmatch(struct device *, void *, void *);
@


1.15
log
@Split out the bar functions required to attach drm(4) to share them
with macppc's vgafb(4) and maybe later on sparc64 drivers too.

suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.14 2010/08/08 17:21:07 miod Exp $ */
d58 1
a82 1

@


1.14
log
@Try to save the vga hardware state around suspend, and also redisplay the
textmode video memory contents if we had to POST the vga bios.
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.13 2009/06/06 04:38:18 pirofti Exp $ */
d88 1
d93 4
@


1.13
log
@Remove the last VGA_POST defines with X86EMU. Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.12 2009/06/06 00:35:00 pirofti Exp $ */
d57 1
d61 6
d94 4
a97 4
int vesafb_find_mode(struct vga_pci_softc *, int, int, int);
void vesafb_set_mode(struct vga_pci_softc *, int);
int vesafb_get_mode(struct vga_pci_softc *);
int vesafb_get_supported_depth(struct vga_pci_softc *);
@


1.12
log
@Add vga bios repost support. Fetched from the NetBSD tree mostly.

Tested on multiple i386 and it works, amd64 works also with a few
exceptions that will get fixed.

The initial effort of importing was done by oga@@, thanks!

Lots of testing and debugging by mlarkin@@ and me.
Okay deraadt@@, oga@@, mlarkin@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.11 2008/06/12 00:54:38 oga Exp $ */
d60 1
a60 1
#ifdef VGA_POST
@


1.11
log
@Bump max BARs up to 6. Needed for nouveau.

ok marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.10 2008/05/06 19:19:02 oga Exp $ */
d60 3
@


1.10
log
@currently agp_i810 needs to map the same BAR as inteldrm, this obviously
fails.

In order to allow this, implement an API so that drm and agp can share
mappings for the BARs. Now it works as it should.

tested by many.
ok kettenis, miod said he'd look at it when it's in tree.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.9 2007/11/25 17:11:12 oga Exp $ */
d40 1
a40 1
#define VGA_PCI_MAX_BARS 4
@


1.9
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.8 2007/11/03 10:09:03 martin Exp $ */
d40 1
d42 13
d58 2
a59 3
#if 0
	struct vga_config *sc_vc;	/* VGA configuration */
#endif
d76 6
a81 2
int vga_pci_cnattach(bus_space_tag_t, bus_space_tag_t,
			  pci_chipset_tag_t, int, int, int);
@


1.8
log
@use DEVICE_IS_VGA_PCI in vga_pci_match()

ok brad@@ fgsch@@ also tested by oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.7 2006/11/27 18:04:28 gwk Exp $ */
a39 23
enum agp_acquire_state {
	AGP_ACQUIRE_FREE,
	AGP_ACQUIRE_USER,
	AGP_ACQUIRE_KERNEL
};

/*
 * Data structure to describe an AGP memory allocation.
 */
TAILQ_HEAD(agp_memory_list, agp_memory);
struct agp_memory {
	TAILQ_ENTRY(agp_memory) am_link;	/* wiring for the tailq */
	int		am_id;			/* unique id for block */
	vsize_t		am_size;		/* number of bytes allocated */
	int		am_type;		/* chipset specific type */
	off_t		am_offset;		/* page offset if bound */
	int		am_is_bound;		/* non-zero if bound */
	bus_addr_t	am_physical;
	caddr_t		am_virtual;
	bus_dmamap_t	am_dmamap;
	int		am_nseg;
	bus_dma_segment_t *am_dmaseg;
};
a60 33
#ifdef PCIAGP
	/* agp stuff */
	bus_space_tag_t sc_bt, sc_memt;
	bus_space_handle_t sc_bh;
	bus_addr_t sc_apaddr;
	bus_size_t sc_apsize;
	bus_dma_tag_t sc_dmat;
	struct lock sc_lock;		/* lock for access to GATT */
	pcitag_t sc_pcitag;		/* PCI tag, in case we need it. */
	pcireg_t sc_id;
	pci_chipset_tag_t sc_pc;

	struct agp_methods *sc_methods;
	void	*sc_chipc;		/* chipset-dependent state */

	int sc_opened;
	int sc_capoff;			
	int sc_apflags;
	int sc_nextid;	/* next memory block id */

	u_int32_t		sc_maxmem;	/* allocation upper bound */
	u_int32_t		sc_allocated;	/* amount allocated */
	enum agp_acquire_state	sc_state;
	struct agp_memory_list	sc_memory;	/* list of allocated memory */
#endif
};

#ifdef PCIAGP
struct agp_product {
	int	ap_vendor;
	int	ap_product;
	int	(*ap_attach)(struct vga_pci_softc *,
		     struct pci_attach_args *, struct pci_attach_args *);
a61 7
/* MD-defined */
extern const struct agp_product agp_products[];

void agp_attach(struct device *, struct device *, void *);
paddr_t agp_mmap(void *, off_t, int);
int agp_ioctl(void *, u_long, caddr_t, int, struct proc *);
#endif /* PCIAGP */
@


1.7
log
@commit vesabios for matthieu@@
ok deraadt, "slap it in" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.6 2006/03/16 21:32:34 matthieu Exp $ */
d34 1
a34 1
#define	DEVICE_IS_VGA_PCI(class, id)					\
@


1.6
log
@Move the agpgart handling code to a separate file.
Ansify some remaining function declarations in vga_pci.c.
ok miod@@, dim@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.5 2002/07/12 20:17:03 mickey Exp $ */
d70 14
d128 7
@


1.5
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.4 2002/03/14 01:27:00 millert Exp $ */
d70 1
a70 1

d94 1
d97 1
d106 5
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.3 2000/11/15 20:17:38 aaron Exp $ */
d31 3
d40 65
d107 2
@


1.3
log
@Updated VGA driver; from NetBSD. Needed for wscons on i386 and alpha. These
files could probably be updated even a bit further (they are from mid-summer).

In addition, I've added support for console scrollback, somewhat inspired by
Linux's vgacon driver. Basically, instead of allocating our own buffer and
doing lots of copies, we take advantage of Video RAM and just modify the VGA
display origin register as appropriate. This approach has a few advantages:
simple to implement, no wasted KVM, it's fast, and after a boot you can now
scroll back all the way to the BIOS messages (assuming your msgbuf is of a
typical length :). Disadvantages are that the VRAM buffer is relatively
small (only 32k) and we do not support raster devices through this method.
(thanks to mickey@@ for pointing this out).

The code for this is fairly unobtrusive, so should we come up with a better
approach to console scrollback at a later time (i.e., even more platform
independent) it should be easy to revert this.

We're one step further in porting nice features of PCVT over to wscons.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d37 2
a38 2
int vga_pci_cnattach __P((bus_space_tag_t, bus_space_tag_t,
			  pci_chipset_tag_t, int, int, int));
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.3 2000/11/15 20:17:38 aaron Exp $ */
d37 2
a38 2
int vga_pci_cnattach(bus_space_tag_t, bus_space_tag_t,
			  pci_chipset_tag_t, int, int, int);
@


1.3.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pcivar.h,v 1.3.6.1 2002/06/11 03:42:27 art Exp $ */
a30 3
#ifndef _PCI_VGA_PCIVAR_H_
#define _PCI_VGA_PCIVAR_H_

a36 65
enum agp_acquire_state {
	AGP_ACQUIRE_FREE,
	AGP_ACQUIRE_USER,
	AGP_ACQUIRE_KERNEL
};

/*
 * Data structure to describe an AGP memory allocation.
 */
TAILQ_HEAD(agp_memory_list, agp_memory);
struct agp_memory {
	TAILQ_ENTRY(agp_memory) am_link;	/* wiring for the tailq */
	int		am_id;			/* unique id for block */
	vsize_t		am_size;		/* number of bytes allocated */
	int		am_type;		/* chipset specific type */
	off_t		am_offset;		/* page offset if bound */
	int		am_is_bound;		/* non-zero if bound */
	bus_addr_t	am_physical;
	caddr_t		am_virtual;
	bus_dmamap_t	am_dmamap;
	int		am_nseg;
	bus_dma_segment_t *am_dmaseg;
};

struct vga_pci_softc {
	struct device sc_dev;

#if 0
	struct vga_config *sc_vc;	/* VGA configuration */
#endif

	/* agp stuff */
	bus_space_tag_t sc_bt, sc_memt;
	bus_space_handle_t sc_bh;
	bus_addr_t sc_apaddr;
	bus_size_t sc_apsize;
	bus_dma_tag_t sc_dmat;
	struct lock sc_lock;		/* lock for access to GATT */
	pcitag_t sc_pcitag;		/* PCI tag, in case we need it. */
	pcireg_t sc_id;
	pci_chipset_tag_t sc_pc;

	struct agp_methods *sc_methods;
	void	*sc_chipc;		/* chipset-dependent state */

	int sc_opened;
	int sc_capoff;			
	int sc_apflags;
	int sc_nextid;	/* next memory block id */

	u_int32_t		sc_maxmem;	/* allocation upper bound */
	u_int32_t		sc_allocated;	/* amount allocated */
	enum agp_acquire_state	sc_state;
	struct agp_memory_list	sc_memory;	/* list of allocated memory */
};

struct agp_product {
	int	ap_vendor;
	int	ap_product;
	int	(*ap_attach)(struct vga_pci_softc *,
		     struct pci_attach_args *, struct pci_attach_args *);
};
/* MD-defined */
extern const struct agp_product agp_products[];

a38 2

#endif /* _PCI_VGA_PCIVAR_H_ */
@


1.2
log
@Add some missing things for the MI vga driver.  Move wscons to an MI place as
well.  $OpenBSD$ tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: vga_pcivar.h,v 1.1 1996/11/19 04:38:36 cgd Exp $	*/
/*	$NetBSD: vga_pcivar.h,v 1.1 1996/11/19 04:38:36 cgd Exp $	*/
d37 2
a38 2
void    vga_pci_console __P((bus_space_tag_t, bus_space_tag_t,
	    pci_chipset_tag_t, int, int, int));
@


1.2.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/* $OpenBSD: vga_pcivar.h,v 1.3 2000/11/15 20:17:38 aaron Exp $ */
/* $NetBSD: vga_pcivar.h,v 1.1 1998/03/22 15:16:19 drochner Exp $ */
d37 2
a38 2
int vga_pci_cnattach __P((bus_space_tag_t, bus_space_tag_t,
			  pci_chipset_tag_t, int, int, int));
@


1.2.10.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d37 2
a38 2
int vga_pci_cnattach(bus_space_tag_t, bus_space_tag_t,
			  pci_chipset_tag_t, int, int, int);
@


1.2.10.3
log
@Sync the SMP branch with 3.3
@
text
@a30 3
#ifndef _PCI_VGA_PCIVAR_H_
#define _PCI_VGA_PCIVAR_H_

a36 65
enum agp_acquire_state {
	AGP_ACQUIRE_FREE,
	AGP_ACQUIRE_USER,
	AGP_ACQUIRE_KERNEL
};

/*
 * Data structure to describe an AGP memory allocation.
 */
TAILQ_HEAD(agp_memory_list, agp_memory);
struct agp_memory {
	TAILQ_ENTRY(agp_memory) am_link;	/* wiring for the tailq */
	int		am_id;			/* unique id for block */
	vsize_t		am_size;		/* number of bytes allocated */
	int		am_type;		/* chipset specific type */
	off_t		am_offset;		/* page offset if bound */
	int		am_is_bound;		/* non-zero if bound */
	bus_addr_t	am_physical;
	caddr_t		am_virtual;
	bus_dmamap_t	am_dmamap;
	int		am_nseg;
	bus_dma_segment_t *am_dmaseg;
};

struct vga_pci_softc {
	struct device sc_dev;

#if 0
	struct vga_config *sc_vc;	/* VGA configuration */
#endif

	/* agp stuff */
	bus_space_tag_t sc_bt, sc_memt;
	bus_space_handle_t sc_bh;
	bus_addr_t sc_apaddr;
	bus_size_t sc_apsize;
	bus_dma_tag_t sc_dmat;
	struct lock sc_lock;		/* lock for access to GATT */
	pcitag_t sc_pcitag;		/* PCI tag, in case we need it. */
	pcireg_t sc_id;
	pci_chipset_tag_t sc_pc;

	struct agp_methods *sc_methods;
	void	*sc_chipc;		/* chipset-dependent state */

	int sc_opened;
	int sc_capoff;			
	int sc_apflags;
	int sc_nextid;	/* next memory block id */

	u_int32_t		sc_maxmem;	/* allocation upper bound */
	u_int32_t		sc_allocated;	/* amount allocated */
	enum agp_acquire_state	sc_state;
	struct agp_memory_list	sc_memory;	/* list of allocated memory */
};

struct agp_product {
	int	ap_vendor;
	int	ap_product;
	int	(*ap_attach)(struct vga_pci_softc *,
		     struct pci_attach_args *, struct pci_attach_args *);
};
/* MD-defined */
extern const struct agp_product agp_products[];

a38 2

#endif /* _PCI_VGA_PCIVAR_H_ */
@


1.1
log
@Sync with NetBSD 961207
@
text
@d1 1
@
