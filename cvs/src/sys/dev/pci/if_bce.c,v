head	1.52;
access;
symbols
	OPENBSD_6_1:1.52.0.2
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.42.0.4
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.35.0.10
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.8
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.6
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.4
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.6
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.4
	OPENBSD_3_5:1.1.0.2
	OPENBSD_3_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.52
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.51;
commitid	VyLWTsbepAOk7VQM;

1.51
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.50;
commitid	8YSL8ByWzGeIGBiJ;

1.50
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.49;
commitid	B0kwmVGiD5DVx4kv;

1.49
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.48;
commitid	5gdEnqVoJuTuwdTu;

1.48
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.47;
commitid	eYnPulzvLjDImPCa;

1.47
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.46;
commitid	hPF95ClMUQfeqQDX;

1.46
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.45;
commitid	MVWrtktB46JRxFWT;

1.45
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.44;
commitid	aiRvgNOa4qke9vft;

1.44
date	2015.04.08.10.07.47;	author mpi;	state Exp;
branches;
next	1.43;
commitid	hnmA6leYzflFI0c3;

1.43
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.42;
commitid	p4LJxGKbi0BU2cG6;

1.42
date	2015.01.27.00.59.39;	author brad;	state Exp;
branches;
next	1.41;
commitid	Bg8mpaQRX3jBbJrv;

1.41
date	2015.01.24.15.15.50;	author kettenis;	state Exp;
branches;
next	1.40;
commitid	KlO7tMyXiBEaRsmg;

1.40
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.39;
commitid	yM2VFFhpDTeFQlve;

1.39
date	2014.12.08.16.21.38;	author brad;	state Exp;
branches;
next	1.38;
commitid	w9QE8tapcBijEaP3;

1.38
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.37;
commitid	TGHgrLxu6sxZoiFt;

1.37
date	2013.08.21.05.21.43;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2013.08.07.01.06.33;	author bluhm;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.03.14.29.08;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.03.12.27.00;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.02.11.18.26;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.27.21.40.40;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.27.21.35.51;	author todd;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.23.08.49.27;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.14.04.12.57;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.02.06.49.59;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.21.10.30.10;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.05.12.10.57;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.24.10.04.58;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.07.23.59.58;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.07.22.11.05;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.07.13.40.36;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.08.01.32.00;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.25.22.41.44;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.24.00.57.49;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.06.20.09.28;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.03.07.47.23;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.23.22.59.01;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.04.02.32.18;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.02.02.20.41;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.10.10.14.47;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.01.21.11.50;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.13.23.24.30;	author andreas;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2004.06.05.23.12.49;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.52
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/* $OpenBSD: if_bce.c,v 1.51 2016/04/13 10:34:32 mpi Exp $ */
/* $NetBSD: if_bce.c,v 1.3 2003/09/29 01:53:02 mrg Exp $	 */

/*
 * Copyright (c) 2003 Clifford Wright. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Broadcom BCM440x 10/100 ethernet (broadcom.com)
 * SiliconBackplane is technology from Sonics, Inc.(sonicsinc.com)
 *
 * Cliff Wright cliff@@snipe444.org
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/pci/if_bcereg.h>

#include <uvm/uvm.h>

/* ring descriptor */
struct bce_dma_slot {
	u_int32_t ctrl;
	u_int32_t addr;
};
#define CTRL_BC_MASK	0x1fff	/* buffer byte count */
#define CTRL_EOT	0x10000000	/* end of descriptor table */
#define CTRL_IOC	0x20000000	/* interrupt on completion */
#define CTRL_EOF	0x40000000	/* end of frame */
#define CTRL_SOF	0x80000000	/* start of frame */

#define BCE_RXBUF_LEN	(MCLBYTES - 4)

/* Packet status is returned in a pre-packet header */
struct rx_pph {
	u_int16_t len;
	u_int16_t flags;
	u_int16_t pad[12];
};

#define	BCE_PREPKT_HEADER_SIZE		30

/* packet status flags bits */
#define RXF_NO				0x8	/* odd number of nibbles */
#define RXF_RXER			0x4	/* receive symbol error */
#define RXF_CRC				0x2	/* crc error */
#define RXF_OV				0x1	/* fifo overflow */

/* number of descriptors used in a ring */
#define BCE_NRXDESC		64
#define BCE_NTXDESC		64

#define BCE_TIMEOUT		100	/* # 10us for mii read/write */

struct bce_softc {
	struct device		bce_dev;
	bus_space_tag_t		bce_btag;
	bus_space_handle_t	bce_bhandle;
	bus_dma_tag_t		bce_dmatag;
	struct arpcom		bce_ac;		/* interface info */
	void			*bce_intrhand;
	struct pci_attach_args	bce_pa;
	struct mii_data		bce_mii;
	u_int32_t		bce_phy;	/* eeprom indicated phy */
	struct bce_dma_slot	*bce_rx_ring;	/* receive ring */
	struct bce_dma_slot	*bce_tx_ring;	/* transmit ring */
	caddr_t			bce_data;
	bus_dmamap_t		bce_ring_map;
	bus_dmamap_t		bce_rxdata_map;
	bus_dmamap_t		bce_txdata_map;
	u_int32_t		bce_intmask;	/* current intr mask */
	u_int32_t		bce_rxin;	/* last rx descriptor seen */
	u_int32_t		bce_txin;	/* last tx descriptor seen */
	int			bce_txsfree;	/* no. tx slots available */
	int			bce_txsnext;	/* next available tx slot */
	struct timeout		bce_timeout;
};

int	bce_probe(struct device *, void *, void *);
void	bce_attach(struct device *, struct device *, void *);
int	bce_activate(struct device *, int);
int	bce_ioctl(struct ifnet *, u_long, caddr_t);
void	bce_start(struct ifnet *);
void	bce_watchdog(struct ifnet *);
int	bce_intr(void *);
void	bce_rxintr(struct bce_softc *);
void	bce_txintr(struct bce_softc *);
int	bce_init(struct ifnet *);
void	bce_add_mac(struct bce_softc *, u_int8_t *, unsigned long);
void	bce_add_rxbuf(struct bce_softc *, int);
void	bce_stop(struct ifnet *);
void	bce_reset(struct bce_softc *);
void	bce_iff(struct ifnet *);
int	bce_mii_read(struct device *, int, int);
void	bce_mii_write(struct device *, int, int, int);
void	bce_statchg(struct device *);
int	bce_mediachange(struct ifnet *);
void	bce_mediastatus(struct ifnet *, struct ifmediareq *);
void	bce_tick(void *);

#ifdef BCE_DEBUG
#define DPRINTF(x)	do {		\
	if (bcedebug)			\
		printf x;		\
} while (/* CONSTCOND */ 0)
#define DPRINTFN(n,x)	do {		\
	if (bcedebug >= (n))		\
		printf x;		\
} while (/* CONSTCOND */ 0)
int	bcedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct cfattach bce_ca = {
	sizeof(struct bce_softc), bce_probe, bce_attach, NULL, bce_activate
};
struct cfdriver bce_cd = {
	NULL, "bce", DV_IFNET
};

const struct pci_matchid bce_devices[] = {
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4401 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4401B0 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4401B1 }
};

int
bce_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, bce_devices,
	    nitems(bce_devices)));
}

void
bce_attach(struct device *parent, struct device *self, void *aux)
{
	struct bce_softc *sc = (struct bce_softc *) self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	caddr_t kva;
	bus_dma_segment_t seg;
	int rseg;
	struct ifnet *ifp;
	pcireg_t memtype;
	bus_addr_t memaddr;
	bus_size_t memsize;
	int pmreg;
	pcireg_t pmode;
	int error;

	sc->bce_pa = *pa;
	sc->bce_dmatag = pa->pa_dmat;

	/*
	 * Map control/status registers.
	 */
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, BCE_PCI_BAR0);
	if (pci_mapreg_map(pa, BCE_PCI_BAR0, memtype, 0, &sc->bce_btag,
	    &sc->bce_bhandle, &memaddr, &memsize, 0)) {
		printf(": unable to find mem space\n");
		return;
	}

	/* Get it out of power save mode if needed. */
	if (pci_get_capability(pc, pa->pa_tag, PCI_CAP_PWRMGMT, &pmreg, 0)) {
		pmode = pci_conf_read(pc, pa->pa_tag, pmreg + 4) & 0x3;
		if (pmode == 3) {
			/*
			 * The card has lost all configuration data in
			 * this state, so punt.
			 */
			printf(": unable to wake up from power state D3\n");
			return;
		}
		if (pmode != 0) {
			printf(": waking up from power state D%d\n",
			    pmode);
			pci_conf_write(pc, pa->pa_tag, pmreg + 4, 0);
		}
	}

	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(pc, ih);
	sc->bce_intrhand = pci_intr_establish(pc, ih, IPL_NET, bce_intr, sc,
	    self->dv_xname);
	if (sc->bce_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}

	/* reset the chip */
	bce_reset(sc);

	/* Create the data DMA region and maps. */
	if ((sc->bce_data = (caddr_t)uvm_km_kmemalloc_pla(kernel_map,
	    uvm.kernel_object, (BCE_NTXDESC + BCE_NRXDESC) * MCLBYTES, 0,
	    UVM_KMF_NOWAIT, 0, (paddr_t)(0x40000000 - 1), 0, 0, 1)) == NULL) {
		printf(": unable to alloc space for ring");
		return;
	}

	/* create a dma map for the RX ring */
	if ((error = bus_dmamap_create(sc->bce_dmatag, BCE_NRXDESC * MCLBYTES,
	    1, BCE_NRXDESC * MCLBYTES, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
	    &sc->bce_rxdata_map))) {
		printf(": unable to create ring DMA map, error = %d\n", error);
		uvm_km_free(kernel_map, (vaddr_t)sc->bce_data,
		    (BCE_NTXDESC + BCE_NRXDESC) * MCLBYTES);
		return;
	}

	/* connect the ring space to the dma map */
	if (bus_dmamap_load(sc->bce_dmatag, sc->bce_rxdata_map, sc->bce_data,
	    BCE_NRXDESC * MCLBYTES, NULL, BUS_DMA_READ | BUS_DMA_NOWAIT)) {
		printf(": unable to load rx ring DMA map\n");
		uvm_km_free(kernel_map, (vaddr_t)sc->bce_data,
		    (BCE_NTXDESC + BCE_NRXDESC) * MCLBYTES);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_rxdata_map);
		return;
	}

	/* create a dma map for the TX ring */
	if ((error = bus_dmamap_create(sc->bce_dmatag, BCE_NTXDESC * MCLBYTES,
	    1, BCE_NTXDESC * MCLBYTES, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
	    &sc->bce_txdata_map))) {
		printf(": unable to create ring DMA map, error = %d\n", error);
		uvm_km_free(kernel_map, (vaddr_t)sc->bce_data,
		    (BCE_NTXDESC + BCE_NRXDESC) * MCLBYTES);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_rxdata_map);
		return;
	}

	/* connect the ring space to the dma map */
	if (bus_dmamap_load(sc->bce_dmatag, sc->bce_txdata_map,
	    sc->bce_data + BCE_NRXDESC * MCLBYTES,
	    BCE_NTXDESC * MCLBYTES, NULL, BUS_DMA_WRITE | BUS_DMA_NOWAIT)) {
		printf(": unable to load tx ring DMA map\n");
		uvm_km_free(kernel_map, (vaddr_t)sc->bce_data,
		    (BCE_NTXDESC + BCE_NRXDESC) * MCLBYTES);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_rxdata_map);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_txdata_map);
		return;
	}


	/*
	 * Allocate DMA-safe memory for ring descriptors.
	 * The receive, and transmit rings can not share the same
	 * 4k space, however both are allocated at once here.
	 */
	/*
	 * XXX PAGE_SIZE is wasteful; we only need 1KB + 1KB, but
	 * due to the limition above. ??
	 */
	if ((error = bus_dmamem_alloc_range(sc->bce_dmatag, 2 * PAGE_SIZE,
	    PAGE_SIZE, 2 * PAGE_SIZE, &seg, 1, &rseg, BUS_DMA_NOWAIT,
	    (bus_addr_t)0, (bus_addr_t)0x3fffffff))) {
		printf(": unable to alloc space for ring descriptors, "
		    "error = %d\n", error);
		uvm_km_free(kernel_map, (vaddr_t)sc->bce_data,
		    (BCE_NTXDESC + BCE_NRXDESC) * MCLBYTES);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_rxdata_map);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_txdata_map);
		return;
	}

	/* map ring space to kernel */
	if ((error = bus_dmamem_map(sc->bce_dmatag, &seg, rseg,
	    2 * PAGE_SIZE, &kva, BUS_DMA_NOWAIT))) {
		printf(": unable to map DMA buffers, error = %d\n", error);
		uvm_km_free(kernel_map, (vaddr_t)sc->bce_data,
		    (BCE_NTXDESC + BCE_NRXDESC) * MCLBYTES);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_rxdata_map);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_txdata_map);
		bus_dmamem_free(sc->bce_dmatag, &seg, rseg);
		return;
	}

	/* create a dma map for the ring */
	if ((error = bus_dmamap_create(sc->bce_dmatag, 2 * PAGE_SIZE, 1,
	    2 * PAGE_SIZE, 0, BUS_DMA_NOWAIT, &sc->bce_ring_map))) {
		printf(": unable to create ring DMA map, error = %d\n", error);
		uvm_km_free(kernel_map, (vaddr_t)sc->bce_data,
		    (BCE_NTXDESC + BCE_NRXDESC) * MCLBYTES);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_rxdata_map);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_txdata_map);
		bus_dmamem_free(sc->bce_dmatag, &seg, rseg);
		return;
	}

	/* connect the ring space to the dma map */
	if (bus_dmamap_load(sc->bce_dmatag, sc->bce_ring_map, kva,
	    2 * PAGE_SIZE, NULL, BUS_DMA_NOWAIT)) {
		printf(": unable to load ring DMA map\n");
		uvm_km_free(kernel_map, (vaddr_t)sc->bce_data,
		    (BCE_NTXDESC + BCE_NRXDESC) * MCLBYTES);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_rxdata_map);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_txdata_map);
		bus_dmamap_destroy(sc->bce_dmatag, sc->bce_ring_map);
		bus_dmamem_free(sc->bce_dmatag, &seg, rseg);
		return;
	}

	/* save the ring space in softc */
	sc->bce_rx_ring = (struct bce_dma_slot *)kva;
	sc->bce_tx_ring = (struct bce_dma_slot *)(kva + PAGE_SIZE);

	/* Set up ifnet structure */
	ifp = &sc->bce_ac.ac_if;
	strlcpy(ifp->if_xname, sc->bce_dev.dv_xname, IF_NAMESIZE);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = bce_ioctl;
	ifp->if_start = bce_start;
	ifp->if_watchdog = bce_watchdog;

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* MAC address */
	sc->bce_ac.ac_enaddr[0] =
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_ENET0);
	sc->bce_ac.ac_enaddr[1] =
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_ENET1);
	sc->bce_ac.ac_enaddr[2] =
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_ENET2);
	sc->bce_ac.ac_enaddr[3] =
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_ENET3);
	sc->bce_ac.ac_enaddr[4] =
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_ENET4);
	sc->bce_ac.ac_enaddr[5] =
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_ENET5);

	printf(": %s, address %s\n", intrstr,
	    ether_sprintf(sc->bce_ac.ac_enaddr));

	/* Initialize our media structures and probe the MII. */
	sc->bce_mii.mii_ifp = ifp;
	sc->bce_mii.mii_readreg = bce_mii_read;
	sc->bce_mii.mii_writereg = bce_mii_write;
	sc->bce_mii.mii_statchg = bce_statchg;
	ifmedia_init(&sc->bce_mii.mii_media, 0, bce_mediachange,
	    bce_mediastatus);
	mii_attach(&sc->bce_dev, &sc->bce_mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, 0);
	if (LIST_FIRST(&sc->bce_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->bce_mii.mii_media, IFM_ETHER | IFM_NONE, 0, NULL);
		ifmedia_set(&sc->bce_mii.mii_media, IFM_ETHER | IFM_NONE);
	} else
		ifmedia_set(&sc->bce_mii.mii_media, IFM_ETHER | IFM_AUTO);

	/* get the phy */
	sc->bce_phy = bus_space_read_1(sc->bce_btag, sc->bce_bhandle,
	    BCE_PHY) & 0x1f;

	/*
	 * Enable activity led.
	 * XXX This should be in a phy driver, but not currently.
	 */
	bce_mii_write((struct device *) sc, 1, 26,	 /* MAGIC */
	    bce_mii_read((struct device *) sc, 1, 26) & 0x7fff);	 /* MAGIC */

	/* enable traffic meter led mode */
	bce_mii_write((struct device *) sc, 1, 27,	 /* MAGIC */
	    bce_mii_read((struct device *) sc, 1, 27) | (1 << 6));	 /* MAGIC */

	/* Attach the interface */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->bce_timeout, bce_tick, sc);
}

int
bce_activate(struct device *self, int act)
{
	struct bce_softc *sc = (struct bce_softc *)self;
	struct ifnet *ifp = &sc->bce_ac.ac_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			bce_stop(ifp);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP) {
			bce_init(ifp);
			bce_start(ifp);
		}
		break;
	}

	return (0);
}

/* handle media, and ethernet requests */
int
bce_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct bce_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *) data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			bce_init(ifp);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				bce_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				bce_stop(ifp);
		}
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->bce_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->bce_ac, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			bce_iff(ifp);
		error = 0;
	}

	splx(s);
	return error;
}

/* Start packet transmission on the interface. */
void
bce_start(struct ifnet *ifp)
{
	struct bce_softc *sc = ifp->if_softc;
	struct mbuf *m0;
	u_int32_t ctrl;
	int txstart;
	int txsfree;
	int newpkts = 0;

	/*
	 * do not start another if currently transmitting, and more
	 * descriptors(tx slots) are needed for next packet.
	 */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	/* determine number of descriptors available */
	if (sc->bce_txsnext >= sc->bce_txin)
		txsfree = BCE_NTXDESC - 1 + sc->bce_txin - sc->bce_txsnext;
	else
		txsfree = sc->bce_txin - sc->bce_txsnext - 1;

	/*
	 * Loop through the send queue, setting up transmit descriptors
	 * until we drain the queue, or use up all available transmit
	 * descriptors.
	 */
	while (txsfree > 0) {

		/* Grab a packet off the queue. */
		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;

		/*
		 * copy mbuf chain into DMA memory buffer.
		 */
		m_copydata(m0, 0, m0->m_pkthdr.len, sc->bce_data +
		    (sc->bce_txsnext + BCE_NRXDESC) * MCLBYTES);
		ctrl = m0->m_pkthdr.len & CTRL_BC_MASK;
		ctrl |= CTRL_SOF | CTRL_EOF | CTRL_IOC;

#if NBPFILTER > 0
		/* Pass the packet to any BPF listeners. */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
		/* mbuf no longer needed */
		m_freem(m0);

		/* Sync the data DMA map. */
		bus_dmamap_sync(sc->bce_dmatag, sc->bce_txdata_map,
		    sc->bce_txsnext * MCLBYTES, MCLBYTES, BUS_DMASYNC_PREWRITE);

		/* Initialize the transmit descriptor(s). */
		txstart = sc->bce_txsnext;

		if (sc->bce_txsnext == BCE_NTXDESC - 1)
			ctrl |= CTRL_EOT;
		sc->bce_tx_ring[sc->bce_txsnext].ctrl = htole32(ctrl);
		sc->bce_tx_ring[sc->bce_txsnext].addr =
		    htole32(sc->bce_txdata_map->dm_segs[0].ds_addr +
		    sc->bce_txsnext * MCLBYTES + 0x40000000);	/* MAGIC */
		if (sc->bce_txsnext + 1 > BCE_NTXDESC - 1)
			sc->bce_txsnext = 0;
		else
			sc->bce_txsnext++;
		txsfree--;

		/* sync descriptors being used */
		bus_dmamap_sync(sc->bce_dmatag, sc->bce_ring_map,
		    sizeof(struct bce_dma_slot) * txstart + PAGE_SIZE,
		    sizeof(struct bce_dma_slot),
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

		/* Give the packet to the chip. */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_DPTR,
		    sc->bce_txsnext * sizeof(struct bce_dma_slot));

		newpkts++;
	}
	if (txsfree == 0) {
		/* No more slots left; notify upper layer. */
		ifq_set_oactive(&ifp->if_snd);
	}
	if (newpkts) {
		/* Set a watchdog timer in case the chip flakes out. */
		ifp->if_timer = 5;
	}
}

/* Watchdog timer handler. */
void
bce_watchdog(struct ifnet *ifp)
{
	struct bce_softc *sc = ifp->if_softc;

	printf("%s: device timeout\n", sc->bce_dev.dv_xname);
	ifp->if_oerrors++;

	(void) bce_init(ifp);

	/* Try to get more packets going. */
	bce_start(ifp);
}

int
bce_intr(void *xsc)
{
	struct bce_softc *sc;
	struct ifnet *ifp;
	u_int32_t intstatus;
	int wantinit;
	int handled = 0;

	sc = xsc;
	ifp = &sc->bce_ac.ac_if;


	for (wantinit = 0; wantinit == 0;) {
		intstatus = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_INT_STS);

		/* ignore if not ours, or unsolicited interrupts */
		intstatus &= sc->bce_intmask;
		if (intstatus == 0)
			break;

		handled = 1;

		/* Ack interrupt */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_INT_STS,
		    intstatus);

		/* Receive interrupts. */
		if (intstatus & I_RI)
			bce_rxintr(sc);
		/* Transmit interrupts. */
		if (intstatus & I_XI)
			bce_txintr(sc);
		/* Error interrupts */
		if (intstatus & ~(I_RI | I_XI)) {
			if (intstatus & I_XU)
				printf("%s: transmit fifo underflow\n",
				    sc->bce_dev.dv_xname);
			if (intstatus & I_RO) {
				printf("%s: receive fifo overflow\n",
				    sc->bce_dev.dv_xname);
				ifp->if_ierrors++;
			}
			if (intstatus & I_RU)
				printf("%s: receive descriptor underflow\n",
				    sc->bce_dev.dv_xname);
			if (intstatus & I_DE)
				printf("%s: descriptor protocol error\n",
				    sc->bce_dev.dv_xname);
			if (intstatus & I_PD)
				printf("%s: data error\n",
				    sc->bce_dev.dv_xname);
			if (intstatus & I_PC)
				printf("%s: descriptor error\n",
				    sc->bce_dev.dv_xname);
			if (intstatus & I_TO)
				printf("%s: general purpose timeout\n",
				    sc->bce_dev.dv_xname);
			wantinit = 1;
		}
	}

	if (handled) {
		if (wantinit)
			bce_init(ifp);
		/* Try to get more packets going. */
		bce_start(ifp);
	}
	return (handled);
}

/* Receive interrupt handler */
void
bce_rxintr(struct bce_softc *sc)
{
	struct ifnet *ifp = &sc->bce_ac.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct rx_pph *pph;
	struct mbuf *m;
	int curr;
	int len;
	int i;

	/* get pointer to active receive slot */
	curr = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_RXSTATUS)
	    & RS_CD_MASK;
	curr = curr / sizeof(struct bce_dma_slot);
	if (curr >= BCE_NRXDESC)
		curr = BCE_NRXDESC - 1;

	/* process packets up to but not current packet being worked on */
	for (i = sc->bce_rxin; i != curr; i = (i + 1) % BCE_NRXDESC) {
		/* complete any post dma memory ops on packet */
		bus_dmamap_sync(sc->bce_dmatag, sc->bce_rxdata_map,
		    i * MCLBYTES, MCLBYTES, BUS_DMASYNC_POSTREAD);

		/*
		 * If the packet had an error, simply recycle the buffer,
		 * resetting the len, and flags.
		 */
		pph = (struct rx_pph *)(sc->bce_data + i * MCLBYTES);
		if (pph->flags & (RXF_NO | RXF_RXER | RXF_CRC | RXF_OV)) {
			ifp->if_ierrors++;
			pph->len = 0;
			pph->flags = 0;
			continue;
		}
		/* receive the packet */
		len = pph->len;
		if (len == 0)
			continue;	/* no packet if empty */
		pph->len = 0;
		pph->flags = 0;

 		/*
		 * The chip includes the CRC with every packet.  Trim
		 * it off here.
		 */
		len -= ETHER_CRC_LEN;

		m = m_devget(sc->bce_data + i * MCLBYTES +
		    BCE_PREPKT_HEADER_SIZE, len, ETHER_ALIGN);

		ml_enqueue(&ml, m);

		/* re-check current in case it changed */
		curr = (bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_DMA_RXSTATUS) & RS_CD_MASK) /
		    sizeof(struct bce_dma_slot);
		if (curr >= BCE_NRXDESC)
			curr = BCE_NRXDESC - 1;
	}

	if_input(ifp, &ml);

	sc->bce_rxin = curr;
}

/* Transmit interrupt handler */
void
bce_txintr(struct bce_softc *sc)
{
	struct ifnet   *ifp = &sc->bce_ac.ac_if;
	int curr;
	int i;

	ifq_clr_oactive(&ifp->if_snd);

	/*
	 * Go through the Tx list and free mbufs for those
	 * frames which have been transmitted.
	 */
	curr = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
	    BCE_DMA_TXSTATUS) & RS_CD_MASK;
	curr = curr / sizeof(struct bce_dma_slot);
	if (curr >= BCE_NTXDESC)
		curr = BCE_NTXDESC - 1;
	for (i = sc->bce_txin; i != curr; i = (i + 1) % BCE_NTXDESC) {
		/* do any post dma memory ops on transmit data */
		bus_dmamap_sync(sc->bce_dmatag, sc->bce_txdata_map,
		    i * MCLBYTES, MCLBYTES, BUS_DMASYNC_POSTWRITE);
	}
	sc->bce_txin = curr;

	/*
	 * If there are no more pending transmissions, cancel the watchdog
	 * timer
	 */
	if (sc->bce_txsnext == sc->bce_txin)
		ifp->if_timer = 0;
}

/* initialize the interface */
int
bce_init(struct ifnet *ifp)
{
	struct bce_softc *sc = ifp->if_softc;
	u_int32_t reg_win;
	int i;

	/* Cancel any pending I/O. */
	bce_stop(ifp);

	/* enable pci inerrupts, bursts, and prefetch */

	/* remap the pci registers to the Sonics config registers */

	/* save the current map, so it can be restored */
	reg_win = pci_conf_read(sc->bce_pa.pa_pc, sc->bce_pa.pa_tag,
	    BCE_REG_WIN);

	/* set register window to Sonics registers */
	pci_conf_write(sc->bce_pa.pa_pc, sc->bce_pa.pa_tag, BCE_REG_WIN,
	    BCE_SONICS_WIN);

	/* enable SB to PCI interrupt */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_SBINTVEC,
	    bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_SBINTVEC) |
	    SBIV_ENET0);

	/* enable prefetch and bursts for sonics-to-pci translation 2 */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_SPCI_TR2,
	    bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_SPCI_TR2) |
	    SBTOPCI_PREF | SBTOPCI_BURST);

	/* restore to ethernet register space */
	pci_conf_write(sc->bce_pa.pa_pc, sc->bce_pa.pa_tag, BCE_REG_WIN,
	    reg_win);

	/* Reset the chip to a known state. */
	bce_reset(sc);

	/* Initialize transmit descriptors */
	memset(sc->bce_tx_ring, 0, BCE_NTXDESC * sizeof(struct bce_dma_slot));
	sc->bce_txsnext = 0;
	sc->bce_txin = 0;

	/* enable crc32 generation and set proper LED modes */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_MACCTL,
	    bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_MACCTL) |
	    BCE_EMC_CRC32_ENAB | BCE_EMC_LED);

	/* reset or clear powerdown control bit  */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_MACCTL,
	    bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_MACCTL) &
	    ~BCE_EMC_PDOWN);

	/* setup DMA interrupt control */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMAI_CTL, 1 << 24);	/* MAGIC */

	/* program promiscuous mode and multicast filters */
	bce_iff(ifp);

	/* set max frame length, account for possible VLAN tag */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_RX_MAX,
	    ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_TX_MAX,
	    ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);

	/* set tx watermark */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_TX_WATER, 56);

	/* enable transmit */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_TXCTL, XC_XE);
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_TXADDR,
	    sc->bce_ring_map->dm_segs[0].ds_addr + PAGE_SIZE + 0x40000000);	/* MAGIC */

	/*
	 * Give the receive ring to the chip, and
	 * start the receive DMA engine.
	 */
	sc->bce_rxin = 0;

	/* clear the rx descriptor ring */
	memset(sc->bce_rx_ring, 0, BCE_NRXDESC * sizeof(struct bce_dma_slot));
	/* enable receive */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_RXCTL,
	    BCE_PREPKT_HEADER_SIZE << 1 | XC_XE);
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_RXADDR,
	    sc->bce_ring_map->dm_segs[0].ds_addr + 0x40000000);		/* MAGIC */

	/* Initialize receive descriptors */
	for (i = 0; i < BCE_NRXDESC; i++)
		bce_add_rxbuf(sc, i);

	/* Enable interrupts */
	sc->bce_intmask =
	    I_XI | I_RI | I_XU | I_RO | I_RU | I_DE | I_PD | I_PC | I_TO;
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_INT_MASK,
	    sc->bce_intmask);

	/* start the receive dma */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_RXDPTR,
	    BCE_NRXDESC * sizeof(struct bce_dma_slot));

	/* set media */
	mii_mediachg(&sc->bce_mii);

	/* turn on the ethernet mac */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_ENET_CTL,
	    bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
	    BCE_ENET_CTL) | EC_EE);

	/* start timer */
	timeout_add_sec(&sc->bce_timeout, 1);

	/* mark as running, and no outputs active */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	return 0;
}

/* add a mac address to packet filter */
void
bce_add_mac(struct bce_softc *sc, u_int8_t *mac, unsigned long idx)
{
	int i;
	u_int32_t rval;

	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_FILT_LOW,
	    mac[2] << 24 | mac[3] << 16 | mac[4] << 8 | mac[5]);
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_FILT_HI,
	    mac[0] << 8 | mac[1] | 0x10000);	/* MAGIC */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_FILT_CTL,
	    idx << 16 | 8);	/* MAGIC */
	/* wait for write to complete */
	for (i = 0; i < 100; i++) {
		rval = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_FILT_CTL);
		if (!(rval & 0x80000000))	/* MAGIC */
			break;
		delay(10);
	}
	if (i == 100) {
		printf("%s: timed out writing pkt filter ctl\n",
		   sc->bce_dev.dv_xname);
	}
}

/* Add a receive buffer to the indiciated descriptor. */
void
bce_add_rxbuf(struct bce_softc *sc, int idx)
{
	struct bce_dma_slot *bced = &sc->bce_rx_ring[idx];

	bus_dmamap_sync(sc->bce_dmatag, sc->bce_rxdata_map, idx * MCLBYTES,
	    MCLBYTES, BUS_DMASYNC_PREREAD);

	*(u_int32_t *)(sc->bce_data + idx * MCLBYTES) = 0;
	bced->addr = htole32(sc->bce_rxdata_map->dm_segs[0].ds_addr +
	    idx * MCLBYTES + 0x40000000);
	if (idx != (BCE_NRXDESC - 1))
		bced->ctrl = htole32(BCE_RXBUF_LEN);
	else
		bced->ctrl = htole32(BCE_RXBUF_LEN | CTRL_EOT);

	bus_dmamap_sync(sc->bce_dmatag, sc->bce_ring_map,
	    sizeof(struct bce_dma_slot) * idx,
	    sizeof(struct bce_dma_slot),
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

}

/* Stop transmission on the interface */
void
bce_stop(struct ifnet *ifp)
{
	struct bce_softc *sc = ifp->if_softc;
	int i;
	u_int32_t val;

	/* Stop the 1 second timer */
	timeout_del(&sc->bce_timeout);

	/* Mark the interface down and cancel the watchdog timer. */
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	/* Down the MII. */
	mii_down(&sc->bce_mii);

	/* Disable interrupts. */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_INT_MASK, 0);
	sc->bce_intmask = 0;
	delay(10);

	/* Disable emac */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_ENET_CTL, EC_ED);
	for (i = 0; i < 200; i++) {
		val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_ENET_CTL);
		if (!(val & EC_ED))
			break;
		delay(10);
	}

	/* Stop the DMA */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_RXCTL, 0);
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_TXCTL, 0);
	delay(10);
}

/* reset the chip */
void
bce_reset(struct bce_softc *sc)
{
	u_int32_t val;
	u_int32_t sbval;
	int i;

	/* if SB core is up */
	sbval = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
	    BCE_SBTMSTATELOW);
	if ((sbval & (SBTML_RESET | SBTML_REJ | SBTML_CLK)) == SBTML_CLK) {
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMAI_CTL,
		    0);

		/* disable emac */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_ENET_CTL,
		    EC_ED);
		for (i = 0; i < 200; i++) {
			val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
			    BCE_ENET_CTL);
			if (!(val & EC_ED))
				break;
			delay(10);
		}
		if (i == 200)
			printf("%s: timed out disabling ethernet mac\n",
			    sc->bce_dev.dv_xname);

		/* reset the dma engines */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_TXCTL,
		    0);
		val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_DMA_RXSTATUS);
		/* if error on receive, wait to go idle */
		if (val & RS_ERROR) {
			for (i = 0; i < 100; i++) {
				val = bus_space_read_4(sc->bce_btag,
				    sc->bce_bhandle, BCE_DMA_RXSTATUS);
				if (val & RS_DMA_IDLE)
					break;
				delay(10);
			}
			if (i == 100)
				printf("%s: receive dma did not go idle after"
				    " error\n", sc->bce_dev.dv_xname);
		}
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle,
		   BCE_DMA_RXSTATUS, 0);

		/* reset ethernet mac */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_ENET_CTL,
		    EC_ES);
		for (i = 0; i < 200; i++) {
			val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
			    BCE_ENET_CTL);
			if (!(val & EC_ES))
				break;
			delay(10);
		}
		if (i == 200)
			printf("%s: timed out resetting ethernet mac\n",
			    sc->bce_dev.dv_xname);
	} else {
		u_int32_t reg_win;

		/* remap the pci registers to the Sonics config registers */

		/* save the current map, so it can be restored */
		reg_win = pci_conf_read(sc->bce_pa.pa_pc, sc->bce_pa.pa_tag,
		    BCE_REG_WIN);
		/* set register window to Sonics registers */
		pci_conf_write(sc->bce_pa.pa_pc, sc->bce_pa.pa_tag,
		    BCE_REG_WIN, BCE_SONICS_WIN);

		/* enable SB to PCI interrupt */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_SBINTVEC,
		    bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_SBINTVEC) | SBIV_ENET0);

		/* enable prefetch and bursts for sonics-to-pci translation 2 */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_SPCI_TR2,
		    bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_SPCI_TR2) | SBTOPCI_PREF | SBTOPCI_BURST);

		/* restore to ethernet register space */
		pci_conf_write(sc->bce_pa.pa_pc, sc->bce_pa.pa_tag, BCE_REG_WIN,
		    reg_win);
	}

	/* disable SB core if not in reset */
	if (!(sbval & SBTML_RESET)) {

		/* set the reject bit */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_SBTMSTATELOW, SBTML_REJ | SBTML_CLK);
		for (i = 0; i < 200; i++) {
			val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
			    BCE_SBTMSTATELOW);
			if (val & SBTML_REJ)
				break;
			delay(1);
		}
		if (i == 200)
			printf("%s: while resetting core, reject did not set\n",
			    sc->bce_dev.dv_xname);
		/* wait until busy is clear */
		for (i = 0; i < 200; i++) {
			val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
			    BCE_SBTMSTATEHI);
			if (!(val & 0x4))
				break;
			delay(1);
		}
		if (i == 200)
			printf("%s: while resetting core, busy did not clear\n",
			    sc->bce_dev.dv_xname);
		/* set reset and reject while enabling the clocks */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_SBTMSTATELOW,
		    SBTML_FGC | SBTML_CLK | SBTML_REJ | SBTML_RESET);
		val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_SBTMSTATELOW);
		delay(10);
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_SBTMSTATELOW, SBTML_REJ | SBTML_RESET);
		delay(1);
	}
	/* enable clock */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_SBTMSTATELOW,
	    SBTML_FGC | SBTML_CLK | SBTML_RESET);
	val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_SBTMSTATELOW);
	delay(1);

	/* clear any error bits that may be on */
	val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_SBTMSTATEHI);
	if (val & 1)
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_SBTMSTATEHI,
		    0);
	val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_SBIMSTATE);
	if (val & SBIM_ERRORBITS)
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_SBIMSTATE,
		    val & ~SBIM_ERRORBITS);

	/* clear reset and allow it to propagate throughout the core */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_SBTMSTATELOW,
	    SBTML_FGC | SBTML_CLK);
	val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_SBTMSTATELOW);
	delay(1);

	/* leave clock enabled */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_SBTMSTATELOW,
	    SBTML_CLK);
	val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_SBTMSTATELOW);
	delay(1);

	/* initialize MDC preamble, frequency */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_MI_CTL, 0x8d);	/* MAGIC */

	/* enable phy, differs for internal, and external */
	val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_DEVCTL);
	if (!(val & BCE_DC_IP)) {
		/* select external phy */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_ENET_CTL,
		    EC_EP);
	} else if (val & BCE_DC_ER) {	/* internal, clear reset bit if on */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DEVCTL,
		    val & ~BCE_DC_ER);
		delay(100);
	}
}

/* Set up the receive filter. */
void
bce_iff(struct ifnet *ifp)
{
	struct bce_softc *sc = ifp->if_softc;
	struct arpcom *ac = &sc->bce_ac;
	u_int32_t rxctl;

	rxctl = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_RX_CTL);
	rxctl &= ~(ERC_AM | ERC_DB | ERC_PE);
	ifp->if_flags |= IFF_ALLMULTI;

	/* disable the filter */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_FILT_CTL, 0);

	/* add our own address */
	bce_add_mac(sc, ac->ac_enaddr, 0);

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multicnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxctl |= ERC_PE;
		else
			rxctl |= ERC_AM;
	}

	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_RX_CTL, rxctl);

	/* enable the filter */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_FILT_CTL,
	    bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_FILT_CTL) | 1);
}

/* Read a PHY register on the MII. */
int
bce_mii_read(struct device *self, int phy, int reg)
{
	struct bce_softc *sc = (struct bce_softc *) self;
	int i;
	u_int32_t val;

	/* clear mii_int */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_MI_STS,
	    BCE_MIINTR);

	/* Read the PHY register */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_MI_COMM,
	    (MII_COMMAND_READ << 28) | (MII_COMMAND_START << 30) |	/* MAGIC */
	    (MII_COMMAND_ACK << 16) | BCE_MIPHY(phy) | BCE_MIREG(reg));	/* MAGIC */

	for (i = 0; i < BCE_TIMEOUT; i++) {
		val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_MI_STS);
		if (val & BCE_MIINTR)
			break;
		delay(10);
	}
	val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_MI_COMM);
	if (i == BCE_TIMEOUT) {
		printf("%s: PHY read timed out reading phy %d, reg %d, val = "
		    "0x%08x\n", sc->bce_dev.dv_xname, phy, reg, val);
		return (0);
	}
	return (val & BCE_MICOMM_DATA);
}

/* Write a PHY register on the MII */
void
bce_mii_write(struct device *self, int phy, int reg, int val)
{
	struct bce_softc *sc = (struct bce_softc *) self;
	int i;
	u_int32_t rval;

	/* clear mii_int */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_MI_STS,
	    BCE_MIINTR);

	/* Write the PHY register */
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_MI_COMM,
	    (MII_COMMAND_WRITE << 28) | (MII_COMMAND_START << 30) |	/* MAGIC */
	    (MII_COMMAND_ACK << 16) | (val & BCE_MICOMM_DATA) |	/* MAGIC */
	    BCE_MIPHY(phy) | BCE_MIREG(reg));

	/* wait for write to complete */
	for (i = 0; i < BCE_TIMEOUT; i++) {
		rval = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_MI_STS);
		if (rval & BCE_MIINTR)
			break;
		delay(10);
	}
	rval = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_MI_COMM);
	if (i == BCE_TIMEOUT) {
		printf("%s: PHY timed out writing phy %d, reg %d, val "
		    "= 0x%08x\n", sc->bce_dev.dv_xname, phy, reg, val);
	}
}

/* sync hardware duplex mode to software state */
void
bce_statchg(struct device *self)
{
	struct bce_softc *sc = (struct bce_softc *) self;
	u_int32_t reg;

	/* if needed, change register to match duplex mode */
	reg = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_TX_CTL);
	if (sc->bce_mii.mii_media_active & IFM_FDX && !(reg & EXC_FD))
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_TX_CTL,
		    reg | EXC_FD);
	else if (!(sc->bce_mii.mii_media_active & IFM_FDX) && reg & EXC_FD)
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_TX_CTL,
		    reg & ~EXC_FD);

	/*
	 * Enable activity led.
	 * XXX This should be in a phy driver, but not currently.
	 */
	bce_mii_write((struct device *) sc, 1, 26,	/* MAGIC */
	    bce_mii_read((struct device *) sc, 1, 26) & 0x7fff);	/* MAGIC */
	/* enable traffic meter led mode */
	bce_mii_write((struct device *) sc, 1, 26,	/* MAGIC */
	    bce_mii_read((struct device *) sc, 1, 27) | (1 << 6));	/* MAGIC */
}

/* Set hardware to newly-selected media */
int
bce_mediachange(struct ifnet *ifp)
{
	struct bce_softc *sc = ifp->if_softc;

	if (ifp->if_flags & IFF_UP)
		mii_mediachg(&sc->bce_mii);
	return (0);
}

/* Get the current interface media status */
void
bce_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct bce_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->bce_mii);
	ifmr->ifm_active = sc->bce_mii.mii_media_active;
	ifmr->ifm_status = sc->bce_mii.mii_media_status;
}

/* One second timer, checks link status */
void
bce_tick(void *v)
{
	struct bce_softc *sc = v;
	int s;

	s = splnet();
	mii_tick(&sc->bce_mii);
	splx(s);

	timeout_add_sec(&sc->bce_timeout, 1);
}
@


1.51
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.50 2015/11/25 03:09:59 dlg Exp $ */
a773 1
		ifp->if_opackets++;
@


1.50
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.49 2015/11/24 17:11:39 mpi Exp $ */
a376 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.49
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.48 2015/11/20 03:35:23 dlg Exp $ */
d520 1
a520 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d590 1
a590 1
		ifp->if_flags |= IFF_OACTIVE;
d760 1
a760 1
	ifp->if_flags &= ~IFF_OACTIVE;
d903 1
a903 1
	ifp->if_flags &= ~IFF_OACTIVE;
d971 2
a972 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.48
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.47 2015/10/25 13:04:28 mpi Exp $ */
a50 1
#include <net/if_dl.h>
@


1.47
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.46 2015/06/24 09:40:54 mpi Exp $ */
d538 1
a538 1
		IFQ_POLL(&ifp->if_snd, m0);
a548 3

		/* WE ARE NOW COMMITTED TO TRANSMITTING THE PACKET. */
		IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.46
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.45 2015/04/13 08:45:48 mpi Exp $ */
a462 1
	struct ifaddr *ifa = (struct ifaddr *) data;
a472 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->bce_ac, ifa);
@


1.45
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.44 2015/04/08 10:07:47 mpi Exp $ */
a742 1
		ifp->if_ipackets++;
@


1.44
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.43 2015/03/14 03:38:48 jsg Exp $ */
d742 1
a742 1
		    BCE_PREPKT_HEADER_SIZE, len, ETHER_ALIGN, ifp);
@


1.43
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.42 2015/01/27 00:59:39 brad Exp $ */
d697 1
d745 1
a745 11
#if NBPFILTER > 0
		/*
		 * Pass this up to any BPF listeners, but only
		 * pass it up the stack if it's for us.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		/* Pass it on. */
		ether_input_mbuf(ifp, m);
d754 3
@


1.42
log
@Rewrite receive filter handling and ioctl bits.
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.41 2015/01/24 15:15:50 kettenis Exp $ */
a66 1
#include <dev/mii/brgphyreg.h>
@


1.41
log
@Use bus_dmamem_alloc_range(9) to make sure the ring descriprtors can be
accessed by the device.

ok deraadt@@, stsp@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.40 2014/12/22 02:28:51 tedu Exp $ */
d145 1
a145 1
void	bce_set_filter(struct ifnet *);
d473 1
a473 3

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
d475 1
a476 5
			break;
		default:
			bce_init(ifp);
			break;
		}
d480 1
a480 1
		if (ifp->if_flags & IFF_UP)
d482 1
a482 1
				bce_set_filter(ifp);
d485 4
a488 2
		else if (ifp->if_flags & IFF_RUNNING)
			bce_stop(ifp);
d502 1
a502 1
			bce_set_filter(ifp);
d860 2
a861 2
	/* setup packet filter */
	bce_set_filter(ifp);
d1187 1
a1187 1
bce_set_filter(struct ifnet *ifp)
d1190 2
d1193 6
a1198 7
	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_RX_CTL,
		    bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_RX_CTL)
		    | ERC_PE);
	} else {
		ifp->if_flags &= ~IFF_ALLMULTI;
d1200 2
a1201 4
		/* turn off promiscuous */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_RX_CTL,
		    bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_RX_CTL) & ~ERC_PE);
d1203 4
a1206 5
		/* enable/disable broadcast */
		if (ifp->if_flags & IFF_BROADCAST)
			bus_space_write_4(sc->bce_btag, sc->bce_bhandle,
			    BCE_RX_CTL, bus_space_read_4(sc->bce_btag,
			    sc->bce_bhandle, BCE_RX_CTL) & ~ERC_DB);
d1208 2
a1209 3
			bus_space_write_4(sc->bce_btag, sc->bce_bhandle,
			    BCE_RX_CTL, bus_space_read_4(sc->bce_btag,
			    sc->bce_bhandle, BCE_RX_CTL) | ERC_DB);
d1211 1
a1211 3
		/* disable the filter */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_FILT_CTL,
		    0);
d1213 3
a1215 14
		/* add our own address */
		bce_add_mac(sc, sc->bce_ac.ac_enaddr, 0);

		/* for now accept all multicast */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_RX_CTL,
		bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_RX_CTL) |
		    ERC_AM);
		ifp->if_flags |= IFF_ALLMULTI;

		/* enable the filter */
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_FILT_CTL,
		    bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_FILT_CTL) | 1);
	}
@


1.40
log
@unifdef INET
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.39 2014/12/08 16:21:38 brad Exp $ */
d318 3
a320 2
	if ((error = bus_dmamem_alloc(sc->bce_dmatag, 2 * PAGE_SIZE,
	    PAGE_SIZE, 2 * PAGE_SIZE, &seg, 1, &rseg, BUS_DMA_NOWAIT))) {
@


1.39
log
@Remove a few foo_start() calls within ioctl handlers. Odd spot to have
them and the vast majority of the rest of the drivers do not do this.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.38 2014/07/22 13:12:11 mpi Exp $ */
a53 1
#ifdef INET
a55 1
#endif
a473 1
#ifdef INET
a477 1
#endif /* INET */
@


1.38
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.37 2013/08/21 05:21:43 dlg Exp $ */
a510 5
	}

	if (error == 0) {
		/* Try to get more packets going. */
		bce_start(ifp);
@


1.37
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.36 2013/08/07 01:06:33 bluhm Exp $ */
a55 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.36
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.35 2011/04/03 15:36:02 jasper Exp $ */
d756 1
a756 1
		    BCE_PREPKT_HEADER_SIZE, len, ETHER_ALIGN, ifp, NULL);
@


1.35
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.34 2011/04/03 14:29:08 claudio Exp $ */
a56 1
#include <netinet/in_var.h>
@


1.34
log
@No need to include uvm/uvm_extern.h and fix a typo.
Both found by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.33 2011/04/03 12:27:00 claudio Exp $ */
d190 1
a190 1
	    sizeof(bce_devices)/sizeof(bce_devices[0])));
@


1.33
log
@Use a own "bounce buffer" that is used to send and receive packets.
This allows bce to run properly on systems with more then 1G of
physical memory.  It also makes the driver a lot simpler since the
DMA rings are now mostly static.
bce is short for bcopy ethernet.
OK dlg@@, just commit it deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.32 2011/04/02 11:18:26 claudio Exp $ */
a75 1
#include <uvm/uvm_extern.h>
d562 1
a562 1
		 * copy mbuf chain int DMA memory buffer.
@


1.32
log
@Kill a lot of spaces and make this a bit more KNF. No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.31 2010/08/27 17:08:00 jsg Exp $ */
d77 1
a77 3

/* transmit buffer max frags allowed */
#define BCE_NTXFRAGS	16
d90 2
d108 2
a109 14
#define BCE_NRXDESC		128
#define BCE_NTXDESC		128

/*
 * Mbuf pointers. We need these to keep track of the virtual addresses
 * of our mbuf chains since we can only convert from physical to virtual,
 * not the other way around.
 */
struct bce_chain_data {
	struct mbuf    *bce_tx_chain[BCE_NTXDESC];
	struct mbuf    *bce_rx_chain[BCE_NRXDESC];
	bus_dmamap_t    bce_tx_map[BCE_NTXDESC];
	bus_dmamap_t    bce_rx_map[BCE_NRXDESC];
};
d125 1
a125 1
	struct bce_chain_data	bce_cdata;	/* mbufs */
d127 2
a136 20
/* for ring descriptors */
#define BCE_RXBUF_LEN	(MCLBYTES - 4)
#define BCE_INIT_RXDESC(sc, x)						\
do {									\
	struct bce_dma_slot *__bced = &sc->bce_rx_ring[x];		\
									\
	*mtod(sc->bce_cdata.bce_rx_chain[x], u_int32_t *) = 0;		\
	__bced->addr =							\
	    htole32(sc->bce_cdata.bce_rx_map[x]->dm_segs[0].ds_addr	\
	    + 0x40000000);						\
	if (x != (BCE_NRXDESC - 1))					\
		__bced->ctrl = htole32(BCE_RXBUF_LEN);			\
	else								\
		__bced->ctrl = htole32(BCE_RXBUF_LEN | CTRL_EOT);	\
	bus_dmamap_sync(sc->bce_dmatag, sc->bce_ring_map,		\
	    sizeof(struct bce_dma_slot) * x,				\
	    sizeof(struct bce_dma_slot),				\
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);			\
} while (/* CONSTCOND */ 0)

d148 2
a149 3
int	bce_add_rxbuf(struct bce_softc *, int);
void	bce_rxdrain(struct bce_softc *);
void	bce_stop(struct ifnet *, int);
a211 1
	int i;
d263 52
d328 4
d339 4
d351 4
a354 1
		bus_dmamem_unmap(sc->bce_dmatag, kva, 2 * PAGE_SIZE);
d363 4
a367 1
		bus_dmamem_unmap(sc->bce_dmatag, kva, 2 * PAGE_SIZE);
a375 21
	/* Create the transmit buffer DMA maps. */
	for (i = 0; i < BCE_NTXDESC; i++) {
		if ((error = bus_dmamap_create(sc->bce_dmatag, MCLBYTES,
		    BCE_NTXFRAGS, MCLBYTES, 0, 0,
		    &sc->bce_cdata.bce_tx_map[i])) != 0) {
			printf(": unable to create tx DMA map, error = %d\n",
			    error);
		}
		sc->bce_cdata.bce_tx_chain[i] = NULL;
	}

	/* Create the receive buffer DMA maps. */
	for (i = 0; i < BCE_NRXDESC; i++) {
		if ((error = bus_dmamap_create(sc->bce_dmatag, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &sc->bce_cdata.bce_rx_map[i])) != 0) {
			printf(": unable to create rx DMA map, error = %d\n",
			    error);
		}
		sc->bce_cdata.bce_rx_chain[i] = NULL;
	}

d451 1
a451 1
			bce_stop(ifp, 1);
d499 1
a499 1
			bce_stop(ifp, 0);
d532 1
a532 1
	bus_dmamap_t dmamap;
a535 1
	int error;
a555 1
		int seg;
a561 3
		/* get the transmit slot dma map */
		dmamap = sc->bce_cdata.bce_tx_map[sc->bce_txsnext];

d563 1
a563 5
		 * Load the DMA map.  If this fails, the packet either
		 * didn't fit in the alloted number of segments, or we
		 * were short on resources. If the packet will not fit,
		 * it will be dropped. If short on resources, it will
		 * be tried again later.
d565 5
a569 21
		error = bus_dmamap_load_mbuf(sc->bce_dmatag, dmamap, m0,
		    BUS_DMA_WRITE | BUS_DMA_NOWAIT);
		if (error == EFBIG) {
			printf("%s: Tx packet consumes too many DMA segments, "
			    "dropping...\n", sc->bce_dev.dv_xname);
			IFQ_DEQUEUE(&ifp->if_snd, m0);
			m_freem(m0);
			ifp->if_oerrors++;
			continue;
		} else if (error) {
			/* short on resources, come back later */
			printf("%s: unable to load Tx buffer, error = %d\n",
			    sc->bce_dev.dv_xname, error);
			break;
		}
		/* If not enough descriptors available, try again later */
		if (dmamap->dm_nsegs > txsfree) {
			ifp->if_flags |= IFF_OACTIVE;
			bus_dmamap_unload(sc->bce_dmatag, dmamap);
			break;
		}
a570 2

		/* So take it off the queue */
d573 7
a579 2
		/* save the pointer so it can be freed later */
		sc->bce_cdata.bce_tx_chain[sc->bce_txsnext] = m0;
d582 2
a583 2
		bus_dmamap_sync(sc->bce_dmatag, dmamap, 0, dmamap->dm_mapsize,
				BUS_DMASYNC_PREWRITE);
a586 2
		for (seg = 0; seg < dmamap->dm_nsegs; seg++) {
			u_int32_t ctrl;
d588 12
a599 17
			ctrl = dmamap->dm_segs[seg].ds_len & CTRL_BC_MASK;
			if (seg == 0)
				ctrl |= CTRL_SOF;
			if (seg == dmamap->dm_nsegs - 1)
				ctrl |= CTRL_EOF;
			if (sc->bce_txsnext == BCE_NTXDESC - 1)
				ctrl |= CTRL_EOT;
			ctrl |= CTRL_IOC;
			sc->bce_tx_ring[sc->bce_txsnext].ctrl = htole32(ctrl);
			sc->bce_tx_ring[sc->bce_txsnext].addr =
			    htole32(dmamap->dm_segs[seg].ds_addr + 0x40000000);	/* MAGIC */
			if (sc->bce_txsnext + 1 > BCE_NTXDESC - 1)
				sc->bce_txsnext = 0;
			else
				sc->bce_txsnext++;
			txsfree--;
		}
d603 1
a603 1
		    sizeof(struct bce_dma_slot) * dmamap->dm_nsegs,
a610 6

#if NBPFILTER > 0
		/* Pass the packet to any BPF listeners. */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
d728 1
a728 2
	for (i = sc->bce_rxin; i != curr;
	    i + 1 > BCE_NRXDESC - 1 ? i = 0 : i++) {
d730 2
a731 3
		bus_dmamap_sync(sc->bce_dmatag, sc->bce_cdata.bce_rx_map[i], 0,
		    sc->bce_cdata.bce_rx_map[i]->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);
d737 1
a737 1
		pph = mtod(sc->bce_cdata.bce_rx_chain[i], struct rx_pph *);
a749 2
		/* bump past pre header to packet */
		sc->bce_cdata.bce_rx_chain[i]->m_data += BCE_PREPKT_HEADER_SIZE;
d757 2
a758 38
		/*
		 * If the packet is small enough to fit in a
		 * single header mbuf, allocate one and copy
		 * the data into it.  This greatly reduces
		 * memory consumption when receiving lots
		 * of small packets.
		 *
		 * Otherwise, add a new buffer to the receive
		 * chain.  If this fails, drop the packet and
		 * recycle the old buffer.
		 */
		if (len <= (MHLEN - 2)) {
			MGETHDR(m, M_DONTWAIT, MT_DATA);
			if (m == NULL)
				goto dropit;
			m->m_data += 2;
			memcpy(mtod(m, caddr_t),
			    mtod(sc->bce_cdata.bce_rx_chain[i], caddr_t), len);
			sc->bce_cdata.bce_rx_chain[i]->m_data -=
			    BCE_PREPKT_HEADER_SIZE;
		} else {
			m = sc->bce_cdata.bce_rx_chain[i];
			if (bce_add_rxbuf(sc, i) != 0) {
dropit:
				ifp->if_ierrors++;
				/* continue to use old buffer */
				sc->bce_cdata.bce_rx_chain[i]->m_data -=
				    BCE_PREPKT_HEADER_SIZE;
				bus_dmamap_sync(sc->bce_dmatag,
				    sc->bce_cdata.bce_rx_map[i], 0,
				    sc->bce_cdata.bce_rx_map[i]->dm_mapsize,
				    BUS_DMASYNC_PREREAD);
				continue;
			}
		}

		m->m_pkthdr.rcvif = ifp;
		m->m_pkthdr.len = m->m_len = len;
d802 1
a802 2
	for (i = sc->bce_txin; i != curr;
	    i + 1 > BCE_NTXDESC - 1 ? i = 0 : i++) {
d804 2
a805 8
		if (sc->bce_cdata.bce_tx_chain[i] == NULL)
			continue;
		bus_dmamap_sync(sc->bce_dmatag, sc->bce_cdata.bce_tx_map[i], 0,
		    sc->bce_cdata.bce_tx_map[i]->dm_mapsize,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->bce_dmatag, sc->bce_cdata.bce_tx_map[i]);
		m_freem(sc->bce_cdata.bce_tx_chain[i]);
		sc->bce_cdata.bce_tx_chain[i] = NULL;
a823 1
	int error;
d827 1
a827 1
	bce_stop(ifp, 0);
d908 2
a909 12
	for (i = 0; i < BCE_NRXDESC; i++) {
		if (sc->bce_cdata.bce_rx_chain[i] == NULL) {
			if ((error = bce_add_rxbuf(sc, i)) != 0) {
				printf("%s: unable to allocate or map rx(%d) "
				    "mbuf, error = %d\n", sc->bce_dev.dv_xname,
				    i, error);
				bce_rxdrain(sc);
				return (error);
			}
		} else
			BCE_INIT_RXDESC(sc, i);
	}
d967 1
a967 1
int
d970 1
a970 2
	struct mbuf    *m;
	int error;
d972 2
a973 20
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);

	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}
	if (sc->bce_cdata.bce_rx_chain[idx] != NULL)
		bus_dmamap_unload(sc->bce_dmatag,
		    sc->bce_cdata.bce_rx_map[idx]);

	sc->bce_cdata.bce_rx_chain[idx] = m;

	error = bus_dmamap_load(sc->bce_dmatag, sc->bce_cdata.bce_rx_map[idx],
	    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
	    BUS_DMA_READ | BUS_DMA_NOWAIT);
	if (error)
		return (error);
d975 7
a981 6
	bus_dmamap_sync(sc->bce_dmatag, sc->bce_cdata.bce_rx_map[idx], 0,
	    sc->bce_cdata.bce_rx_map[idx]->dm_mapsize, BUS_DMASYNC_PREREAD);

	BCE_INIT_RXDESC(sc, idx);

	return (0);
d983 4
a986 7
}

/* Drain the receive queue. */
void
bce_rxdrain(struct bce_softc *sc)
{
	int i;
a987 8
	for (i = 0; i < BCE_NRXDESC; i++) {
		if (sc->bce_cdata.bce_rx_chain[i] != NULL) {
			bus_dmamap_unload(sc->bce_dmatag,
			    sc->bce_cdata.bce_rx_map[i]);
			m_freem(sc->bce_cdata.bce_rx_chain[i]);
			sc->bce_cdata.bce_rx_chain[i] = NULL;
		}
	}
d992 1
a992 1
bce_stop(struct ifnet *ifp, int disable)
a1026 14

	/* Release any queued transmit buffers. */
	for (i = 0; i < BCE_NTXDESC; i++) {
		if (sc->bce_cdata.bce_tx_chain[i] != NULL) {
			bus_dmamap_unload(sc->bce_dmatag,
			    sc->bce_cdata.bce_tx_map[i]);
			m_freem(sc->bce_cdata.bce_tx_chain[i]);
			sc->bce_cdata.bce_tx_chain[i] = NULL;
		}
	}

	/* drain receive queue */
	if (disable)
		bce_rxdrain(sc);
@


1.31
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.30 2010/07/27 21:40:40 deraadt Exp $ */
d199 1
a199 1
int             bcedebug = 0;
d232 2
a233 2
	const char     *intrstr = NULL;
	caddr_t         kva;
d235 9
a243 9
	int             rseg;
	struct ifnet   *ifp;
	pcireg_t        memtype;
	bus_addr_t      memaddr;
	bus_size_t      memsize;
	int             pmreg;
	pcireg_t        pmode;
	int             error;
	int             i;
d271 1
a271 1
			       pmode);
d304 2
a305 3
	if ((error = bus_dmamem_alloc(sc->bce_dmatag,
	    2 * PAGE_SIZE, PAGE_SIZE, 2 * PAGE_SIZE,
				      &seg, 1, &rseg, BUS_DMA_NOWAIT))) {
d307 1
a307 1
		       "error = %d\n", error);
d314 1
a314 2
		printf(": unable to map DMA buffers, error = %d\n",
		    error);
d320 3
a322 5
	if ((error = bus_dmamap_create(sc->bce_dmatag,
	    2 * PAGE_SIZE, 1, 2 * PAGE_SIZE, 0, BUS_DMA_NOWAIT,
				       &sc->bce_ring_map))) {
		printf(": unable to create ring DMA map, error = %d\n",
		    error);
d339 2
a340 2
	sc->bce_rx_ring = (struct bce_dma_slot *) kva;
	sc->bce_tx_ring = (struct bce_dma_slot *) (kva + PAGE_SIZE);
d345 2
a346 1
		    BCE_NTXFRAGS, MCLBYTES, 0, 0, &sc->bce_cdata.bce_tx_map[i])) != 0) {
d457 2
a458 2
	struct ifreq   *ifr = (struct ifreq *) data;
	int             s, error = 0;
d480 2
a481 2
		if(ifp->if_flags & IFF_UP)
			if(ifp->if_flags & IFF_RUNNING)
d485 1
a485 1
		else if(ifp->if_flags & IFF_RUNNING)
a486 1

d518 6
a523 6
	struct mbuf    *m0;
	bus_dmamap_t    dmamap;
	int             txstart;
	int             txsfree;
	int             newpkts = 0;
	int             error;
d526 3
a528 3
         * do not start another if currently transmitting, and more
         * descriptors(tx slots) are needed for next packet.
         */
d539 4
a542 4
         * Loop through the send queue, setting up transmit descriptors
         * until we drain the queue, or use up all available transmit
         * descriptors.
         */
d544 1
a544 1
		int             seg;
d618 3
a620 3
			  sizeof(struct bce_dma_slot) * txstart + PAGE_SIZE,
			     sizeof(struct bce_dma_slot) * dmamap->dm_nsegs,
				BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d624 1
a624 1
			     sc->bce_txsnext * sizeof(struct bce_dma_slot));
d632 1
a632 1
#endif				/* NBPFILTER > 0 */
d663 1
a663 1
	struct ifnet   *ifp;
d665 2
a666 2
	int             wantinit;
	int             handled = 0;
d705 1
a705 1
				       sc->bce_dev.dv_xname);
d708 1
a708 1
				       sc->bce_dev.dv_xname);
d735 6
a740 6
	struct ifnet   *ifp = &sc->bce_ac.ac_if;
	struct rx_pph  *pph;
	struct mbuf    *m;
	int             curr;
	int             len;
	int             i;
d775 1
a775 2
		sc->bce_cdata.bce_rx_chain[i]->m_data +=
			BCE_PREPKT_HEADER_SIZE;
d800 1
a800 1
			 mtod(sc->bce_cdata.bce_rx_chain[i], caddr_t), len);
d802 1
a802 1
				BCE_PREPKT_HEADER_SIZE;
d806 1
a806 1
		dropit:
d810 1
a810 1
					BCE_PREPKT_HEADER_SIZE;
d830 1
a830 1
#endif				/* NBPFILTER > 0 */
d850 2
a851 2
	int             curr;
	int             i;
d856 5
a860 5
         * Go through the Tx list and free mbufs for those
         * frames which have been transmitted.
         */
	curr = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_TXSTATUS) &
		RS_CD_MASK;
d893 2
a894 2
	int             error;
	int             i;
d964 3
a966 3
         * Give the receive ring to the chip, and
         * start the receive DMA engine.
         */
d1023 1
a1023 1
	int             i;
d1051 1
a1051 1
	int             error;
d1087 1
a1087 1
	int             i;
d1104 1
a1104 1
	int             i;
d1158 1
a1158 1
	int             i;
d1179 1
a1179 1
			       sc->bce_dev.dv_xname);
d1182 4
a1185 2
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_TXCTL, 0);
		val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_DMA_RXSTATUS);
d1214 1
a1214 1
			       sc->bce_dev.dv_xname);
d1230 1
a1230 2
		        BCE_SBINTVEC) |
		    SBIV_ENET0);
d1235 1
a1235 2
			BCE_SPCI_TR2) |
		    SBTOPCI_PREF | SBTOPCI_BURST);
d1239 1
a1239 1
			       reg_win);
d1315 2
a1316 1
		bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_ENET_CTL, EC_EP);
d1378 1
a1378 1
	int             i;
d1382 2
a1383 1
	bus_space_write_4(sc->bce_btag, sc->bce_bhandle, BCE_MI_STS, BCE_MIINTR);
d1391 2
a1392 1
		val = bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_MI_STS);
d1411 1
a1411 1
	int             i;
d1456 3
a1458 3
         * Enable activity led.
         * XXX This should be in a phy driver, but not currently.
         */
@


1.30
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.29 2010/07/27 21:35:51 todd Exp $ */
a373 1
	ifp->if_init = bce_init;
@


1.29
log
@add bce_activate(), suspends and resumes on my laptop
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.28 2009/08/13 14:24:47 jasper Exp $ */
d439 1
a439 1
	switch(act) {
@


1.28
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.27 2008/11/28 02:44:17 brad Exp $ */
d169 1
d206 1
a206 1
	sizeof(struct bce_softc), bce_probe, bce_attach
d431 22
@


1.27
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.26 2008/10/02 20:21:13 brad Exp $ */
d208 1
a208 1
	0, "bce", DV_IFNET
@


1.26
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.25 2008/09/10 14:01:22 blambert Exp $ */
d437 1
a438 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d459 1
a459 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
a469 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->bce_ac) :
		    ether_delmulti(ifr, &sc->bce_ac);
a470 10
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				bce_set_filter(ifp);
			error = 0;
		}
		break;
d475 1
d478 6
@


1.25
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.24 2008/05/23 08:49:27 brad Exp $ */
a442 5
	if ((error = ether_ioctl(ifp, &sc->bce_ac, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d496 1
a496 2
		error = ENOTTY;
		break;
@


1.24
log
@Simplify the combination use of pci_mapreg_type()/pci_mapreg_map() as
suggested by dlg@@ awhile ago.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.23 2008/05/14 04:12:57 brad Exp $ */
d1012 1
a1012 1
	timeout_add(&sc->bce_timeout, hz);
d1498 1
a1498 1
	timeout_add(&sc->bce_timeout, hz);
@


1.23
log
@Add missing splnet around mii_tick().

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.22 2008/04/02 06:49:59 brad Exp $ */
d251 2
a252 7
	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		if (pci_mapreg_map(pa, BCE_PCI_BAR0, memtype, 0, &sc->bce_btag,
		    &sc->bce_bhandle, &memaddr, &memsize, 0) == 0)
			break;
	default:
@


1.22
log
@Correct error message printing and add a missing error
message for bus_dmamap_load() failure in bce_attach().

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.21 2007/11/26 09:28:33 martynas Exp $ */
d1497 1
d1499 1
a1499 1
	/* Tick the MII. */
d1501 1
@


1.21
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.20 2007/05/21 10:30:10 reyk Exp $ */
d258 1
a258 2
		printf("%s: unable to find mem space\n",
		    sc->bce_dev.dv_xname);
d270 1
a270 2
			printf("%s: unable to wake up from power state D3\n",
			       sc->bce_dev.dv_xname);
d274 2
a275 2
			printf("%s: waking up from power state D%d\n",
			       sc->bce_dev.dv_xname, pmode);
d279 1
d281 1
a281 2
		printf("%s: couldn't map interrupt\n",
		    sc->bce_dev.dv_xname);
d284 1
a285 1

a287 1

d289 1
a289 2
		printf("%s: couldn't establish interrupt",
		    sc->bce_dev.dv_xname);
d311 2
a312 2
		printf("%s: unable to alloc space for ring descriptors, "
		       "error = %d\n", sc->bce_dev.dv_xname, error);
d315 1
d319 2
a320 2
		printf("%s: unable to map DMA buffers, error = %d\n",
		    sc->bce_dev.dv_xname, error);
d324 1
d329 2
a330 2
		printf("%s: unable to create ring DMA map, error = %d\n",
		    sc->bce_dev.dv_xname, error);
d335 1
d339 1
d345 1
d354 2
a355 2
			printf("%s: unable to create tx DMA map, error = %d\n",
			    sc->bce_dev.dv_xname, error);
d364 2
a365 2
			printf("%s: unable to create rx DMA map, error = %d\n",
			    sc->bce_dev.dv_xname, error);
d396 1
a400 1

d414 1
d418 1
d425 1
a429 1

d433 1
@


1.20
log
@sync; add new device id to the bce(4) driver

From brad
ok and tested by todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.19 2007/05/05 12:10:57 jsg Exp $ */
d980 1
a980 1
	/* Initalize receive descriptors */
@


1.19
log
@Properly ifdef debug bits to save a bit of space.
ok reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.18 2007/04/24 10:04:58 reyk Exp $ */
d213 2
a214 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4401B0 }
@


1.18
log
@do not use static function declarations in kernel drivers (no
functional change).

from Brad Smith
ok and tested by todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.17 2007/04/07 23:59:58 krw Exp $ */
a188 1
#define BCE_DEBUG
@


1.17
log
@ANSI-fy. No functional change.

From Brad.
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.16 2007/04/07 22:11:05 krw Exp $ */
d167 21
a187 21
static	int	bce_probe(struct device *, void *, void *);
static	void	bce_attach(struct device *, struct device *, void *);
static	int	bce_ioctl(struct ifnet *, u_long, caddr_t);
static	void	bce_start(struct ifnet *);
static	void	bce_watchdog(struct ifnet *);
static	int	bce_intr(void *);
static	void	bce_rxintr(struct bce_softc *);
static	void	bce_txintr(struct bce_softc *);
static	int	bce_init(struct ifnet *);
static	void	bce_add_mac(struct bce_softc *, u_int8_t *, unsigned long);
static	int	bce_add_rxbuf(struct bce_softc *, int);
static	void	bce_rxdrain(struct bce_softc *);
static	void	bce_stop(struct ifnet *, int);
static	void	bce_reset(struct bce_softc *);
static	void	bce_set_filter(struct ifnet *);
static	int	bce_mii_read(struct device *, int, int);
static	void	bce_mii_write(struct device *, int, int, int);
static	void	bce_statchg(struct device *);
static	int	bce_mediachange(struct ifnet *);
static	void	bce_mediastatus(struct ifnet *, struct ifmediareq *);
static	void	bce_tick(void *);
d434 1
a434 1
static int
d516 1
a516 1
static void
d647 1
a647 1
static void
d891 1
a891 1
static int
d1050 1
a1050 1
static int
d1087 1
a1087 1
static void
d1103 1
a1103 1
static void
d1156 1
a1156 1
static void
d1478 1
a1478 1
static void
d1489 1
a1489 1
static void
@


1.16
log
@Nuke NetBSD defines APRINTF_NORMAL/_ERROR and just use the printf they were
defined to. No functional change.

From Brad.
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.15 2007/04/07 13:40:36 krw Exp $ */
d218 1
a218 4
bce_probe(parent, match, aux)
	struct device  *parent;
	void           *match;
	void           *aux;
d225 1
a225 3
bce_attach(parent, self, aux)
	struct device  *parent, *self;
	void           *aux;
d435 1
a435 4
bce_ioctl(ifp, cmd, data)
	struct ifnet   *ifp;
	u_long          cmd;
	caddr_t         data;
d517 1
a517 2
bce_start(ifp)
	struct ifnet   *ifp;
d648 1
a648 2
bce_watchdog(ifp)
	struct ifnet   *ifp;
d662 1
a662 2
bce_intr(xsc)
	void           *xsc;
d735 1
a735 2
bce_rxintr(sc)
	struct bce_softc *sc;
d850 1
a850 2
bce_txintr(sc)
	struct bce_softc *sc;
d892 1
a892 2
bce_init(ifp)
	struct ifnet   *ifp;
d1024 1
a1024 4
bce_add_mac(sc, mac, idx)
	struct bce_softc *sc;
	u_int8_t *mac;
	unsigned long   idx;
d1051 1
a1051 3
bce_add_rxbuf(sc, idx)
	struct bce_softc *sc;
	int             idx;
d1088 1
a1088 2
bce_rxdrain(sc)
	struct bce_softc *sc;
d1104 1
a1104 3
bce_stop(ifp, disable)
	struct ifnet   *ifp;
	int             disable;
d1157 1
a1157 2
bce_reset(sc)
	struct bce_softc *sc;
d1328 1
a1328 2
bce_set_filter(ifp)
	struct ifnet   *ifp;
d1377 1
a1377 3
bce_mii_read(self, phy, reg)
	struct device  *self;
	int             phy, reg;
d1408 1
a1408 3
bce_mii_write(self, phy, reg, val)
	struct device  *self;
	int             phy, reg, val;
d1441 1
a1441 2
bce_statchg(self)
	struct device  *self;
d1468 1
a1468 2
bce_mediachange(ifp)
	struct ifnet   *ifp;
d1479 1
a1479 3
bce_mediastatus(ifp, ifmr)
	struct ifnet   *ifp;
	struct ifmediareq *ifmr;
d1490 1
a1490 2
bce_tick(v)
	void           *v;
@


1.15
log
@Use pci_matchbyid() rather than handrolled equivalent. From Brad.

tested & ok todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.14 2006/11/08 01:32:00 brad Exp $ */
a211 8
#if __NetBSD_Version__ >= 106120000
#define APRINT_ERROR	aprint_error
#define APRINT_NORMAL	aprint_normal
#else
#define APRINT_ERROR	printf
#define APRINT_NORMAL	printf
#endif

d263 1
a263 1
		APRINT_ERROR("%s: unable to find mem space\n",
d287 1
a287 1
		APRINT_ERROR("%s: couldn't map interrupt\n",
d297 1
a297 1
		APRINT_ERROR("%s: couldn't establish interrupt",
d300 2
a301 2
			APRINT_NORMAL(" at %s", intrstr);
		APRINT_NORMAL("\n");
@


1.14
log
@Clean up some of the "magic" constants in the driver, based on the
documentation for the Broadcom 43xx wireless chips that share the
same basic hardware.

From Jon Simola <jsimola at gmail dot com>
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.13 2006/05/28 00:04:24 jason Exp $ */
d220 4
a223 10
static int
bce_lookup(const struct pci_attach_args *pa)
{
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_BROADCOM &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM4401 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM4401B0))
		return 1;

	return 0;
}
d231 2
a232 3
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	return bce_lookup(pa);
a255 2

	KASSERT(bce_lookup(pa));
@


1.13
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.12 2006/03/25 22:41:44 djm Exp $ */
d99 2
d406 1
a406 1
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_MAGIC_ENET0);
d408 1
a408 1
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_MAGIC_ENET1);
d410 1
a410 1
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_MAGIC_ENET2);
d412 1
a412 1
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_MAGIC_ENET3);
d414 1
a414 1
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_MAGIC_ENET4);
d416 1
a416 1
	    bus_space_read_1(sc->bce_btag, sc->bce_bhandle, BCE_MAGIC_ENET5);
d437 1
a437 1
	    BCE_MAGIC_PHY) & 0x1f;
d806 2
a807 1
		sc->bce_cdata.bce_rx_chain[i]->m_data += 30;	/* MAGIC */
d833 2
a834 1
			sc->bce_cdata.bce_rx_chain[i]->m_data -= 30;	/* MAGIC */
d841 2
a842 1
				sc->bce_cdata.bce_rx_chain[i]->m_data -= 30;
d1007 1
a1007 1
	    30 << 1 | 1);	/* MAGIC */
d1335 1
a1335 1
	if (val & SBIM_MAGIC_ERRORBITS)
d1337 1
a1337 1
		    val & ~SBIM_MAGIC_ERRORBITS);
@


1.12
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.11 2006/02/24 00:57:49 brad Exp $ */
d525 1
a525 1
		error = EINVAL;
@


1.11
log
@clear the powerdown mode that Windows will put bce chips into
when soft rebooting a system, also set proper LED modes.

From FreeBSD's bfe driver.

Tested by Alexey E. Suslikov <suslikov at texnika dot com dot ua>
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.10 2005/10/06 20:09:28 brad Exp $ */
d657 1
a657 1
			bpf_mtap(ifp->if_bpf, m0);
d856 1
a856 1
			bpf_mtap(ifp->if_bpf, m);
@


1.10
log
@Eliminate use of M_HASFCS.

From thorpej NetBSD
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.9 2005/08/09 04:10:11 mickey Exp $ */
d962 1
a962 1
	/* enable crc32 generation */
d965 6
a970 1
	    BCE_EMC_CG);
@


1.9
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.8 2005/07/03 07:47:23 brad Exp $ */
d806 6
a845 1
//		m->m_flags |= M_HASFCS;
@


1.8
log
@fix MTU ioctl case
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.7 2005/07/02 23:10:11 brad Exp $ */
a252 1
	u_int32_t       command;
a269 10
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		APRINT_ERROR("%s: failed to enable memory mapping!\n",
		    sc->bce_dev.dv_xname);
		return;
	}
@


1.7
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.6 2005/04/23 22:59:01 brad Exp $ */
d486 1
d500 4
a503 1
		ifp->if_mtu = ifr->ifr_mtu;
@


1.6
log
@accept VLAN-sized frames
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.5 2005/01/04 02:32:18 brad Exp $ */
d1144 4
a1183 4

	/* Mark the interface down and cancel the watchdog timer. */
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
	ifp->if_timer = 0;
@


1.5
log
@though this is untested this couldn't be any worse than before.
fix completely broken multicast ioctl switch case.
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.4 2004/12/02 02:20:41 brad Exp $ */
a38 1
#include "vlan.h"
d411 2
d975 1
a975 1
	/* set max frame length, account for possible vlan tag */
d977 1
a977 1
	    ETHER_MAX_LEN + 32);
d979 1
a979 1
	    ETHER_MAX_LEN + 32);
@


1.4
log
@rev 1.4

fix obvious past-o where the activity led register gets overwritten by
the traffic meter led register

rev 1.5

Keep track of what we set the interrupt mask to, rather than reading it from
the chip.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.3 2004/11/10 10:14:47 grange Exp $ */
d512 13
a524 2
		if (ifp->if_flags & IFF_RUNNING)
			bce_set_filter(ifp);
@


1.3
log
@strncpy->strlcpy
ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.2 2004/09/01 21:11:50 millert Exp $ */
d138 1
d453 1
a453 1
	bce_mii_write((struct device *) sc, 1, 26,	 /* MAGIC */
a687 1
	u_int32_t intmask;
a697 2
		intmask = bus_space_read_4(sc->bce_btag, sc->bce_bhandle,
		    BCE_INT_MASK);
d700 1
a700 1
		intstatus &= intmask;
d1006 2
d1009 1
a1009 1
	    I_XI | I_RI | I_XU | I_RO | I_RU | I_DE | I_PD | I_PC | I_TO);
d1137 2
a1138 1
	bus_space_read_4(sc->bce_btag, sc->bce_bhandle, BCE_INT_MASK);
@


1.2
log
@Support Broadcom BCM4401-B0; from FreeBSD.  OK deraadt@@ and henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_bce.c,v 1.1 2004/02/13 23:24:30 andreas Exp $ */
d402 1
a402 1
	strncpy(ifp->if_xname, sc->bce_dev.dv_xname, IF_NAMESIZE);
@


1.1
log
@bce (Broadcom 4401 10/100 ethernet driver) from NetBSD
Most work by nate@@, ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d222 3
a224 2
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM4401)
	    return 1;
@


1.1.4.1
log
@Merge with the trunk
@
text
@@

