head	1.198;
access;
symbols
	OPENBSD_6_1:1.166.0.4
	OPENBSD_6_1_BASE:1.166
	OPENBSD_6_0:1.96.0.4
	OPENBSD_6_0_BASE:1.96
	OPENBSD_5_9:1.78.0.2
	OPENBSD_5_9_BASE:1.78
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.36.0.4
	OPENBSD_5_7_BASE:1.36;
locks; strict;
comment	@ * @;


1.198
date	2017.06.20.13.52.40;	author stsp;	state Exp;
branches;
next	1.197;
commitid	RNhHmUkhCrBEeyQG;

1.197
date	2017.06.16.08.45.34;	author stsp;	state Exp;
branches;
next	1.196;
commitid	Kn5HlRqSJXgZyDFw;

1.196
date	2017.06.14.16.58.28;	author stsp;	state Exp;
branches;
next	1.195;
commitid	hjNQpct7rKGhXctW;

1.195
date	2017.06.14.16.57.47;	author stsp;	state Exp;
branches;
next	1.194;
commitid	sEHiunZbPzW1bchR;

1.194
date	2017.06.14.16.56.50;	author stsp;	state Exp;
branches;
next	1.193;
commitid	rO67QhGrA8KcvIJv;

1.193
date	2017.06.14.16.56.04;	author stsp;	state Exp;
branches;
next	1.192;
commitid	NRw9Z32ri1vzeCx5;

1.192
date	2017.06.09.13.47.26;	author stsp;	state Exp;
branches;
next	1.191;
commitid	m765rQ0klEhJt15W;

1.191
date	2017.06.09.13.46.15;	author stsp;	state Exp;
branches;
next	1.190;
commitid	P1yDfjwwhheV450t;

1.190
date	2017.06.02.11.18.37;	author stsp;	state Exp;
branches;
next	1.189;
commitid	W4BGhhsCPfSaaUV8;

1.189
date	2017.05.31.13.22.16;	author phessler;	state Exp;
branches;
next	1.188;
commitid	mAXA4Ix78WvzoqWR;

1.188
date	2017.05.31.12.24.06;	author phessler;	state Exp;
branches;
next	1.187;
commitid	d3GbR5yPfjsGCf7t;

1.187
date	2017.05.31.09.17.39;	author stsp;	state Exp;
branches;
next	1.186;
commitid	HdZFWQoBUy9k2Mzr;

1.186
date	2017.05.31.08.33.11;	author stsp;	state Exp;
branches;
next	1.185;
commitid	2J38XLeARCTBIVrv;

1.185
date	2017.05.31.08.14.52;	author stsp;	state Exp;
branches;
next	1.184;
commitid	x6BOWuNdpzI7EEVp;

1.184
date	2017.05.28.11.03.48;	author stsp;	state Exp;
branches;
next	1.183;
commitid	vbFB9diuOf7jwCOw;

1.183
date	2017.05.28.09.59.58;	author stsp;	state Exp;
branches;
next	1.182;
commitid	KTJUKcNYY5qydrq7;

1.182
date	2017.05.26.18.40.05;	author stsp;	state Exp;
branches;
next	1.181;
commitid	1aBnbD9c3QLwhXwq;

1.181
date	2017.05.08.14.27.28;	author stsp;	state Exp;
branches;
next	1.180;
commitid	y8eJ6q0L0f3i9wbr;

1.180
date	2017.05.08.12.41.23;	author stsp;	state Exp;
branches;
next	1.179;
commitid	Vgl2ouEjszQU3whf;

1.179
date	2017.05.08.08.57.56;	author stsp;	state Exp;
branches;
next	1.178;
commitid	pgcUiwIrrIomYr3J;

1.178
date	2017.05.04.09.03.42;	author stsp;	state Exp;
branches;
next	1.177;
commitid	qSPE4lf4nUGPOecq;

1.177
date	2017.04.27.06.14.23;	author stsp;	state Exp;
branches;
next	1.176;
commitid	mhnaC8zii6ezkI1P;

1.176
date	2017.04.27.05.46.51;	author stsp;	state Exp;
branches;
next	1.175;
commitid	UQb8GzJyJw57QRUn;

1.175
date	2017.04.26.09.19.56;	author stsp;	state Exp;
branches;
next	1.174;
commitid	egVSFEdBWvRiEe76;

1.174
date	2017.04.26.08.19.09;	author stsp;	state Exp;
branches;
next	1.173;
commitid	A1LvDzCO2HxhPDTV;

1.173
date	2017.04.26.07.53.17;	author stsp;	state Exp;
branches;
next	1.172;
commitid	K2DWFYV8OTQ53vHY;

1.172
date	2017.04.24.09.48.42;	author stsp;	state Exp;
branches;
next	1.171;
commitid	RaA1vd7hLDXPgXa6;

1.171
date	2017.04.24.09.31.31;	author stsp;	state Exp;
branches;
next	1.170;
commitid	czYamycsJ3SrvAmZ;

1.170
date	2017.04.21.17.54.02;	author stsp;	state Exp;
branches;
next	1.169;
commitid	DbdUCKQzs1Bdcnj6;

1.169
date	2017.04.21.16.40.11;	author stsp;	state Exp;
branches;
next	1.168;
commitid	8U1pfVOhtBeFoEDQ;

1.168
date	2017.04.21.16.39.52;	author stsp;	state Exp;
branches;
next	1.167;
commitid	lyFcCLU4zvtXlxtQ;

1.167
date	2017.04.04.00.40.52;	author claudio;	state Exp;
branches;
next	1.166;
commitid	mSoUstPcPMs0DteO;

1.166
date	2017.03.08.12.02.41;	author mpi;	state Exp;
branches;
next	1.165;
commitid	okVP7pbbXG8IxGgU;

1.165
date	2017.02.20.15.38.04;	author krw;	state Exp;
branches;
next	1.164;
commitid	VrYnXCykMTDcgN5B;

1.164
date	2017.02.16.10.15.12;	author mpi;	state Exp;
branches;
next	1.163;
commitid	NChVcK48FdZeU9j9;

1.163
date	2017.02.07.10.08.21;	author mpi;	state Exp;
branches;
next	1.162;
commitid	gzLIBtF3UIhyOxtA;

1.162
date	2017.02.04.19.20.59;	author guenther;	state Exp;
branches;
next	1.161;
commitid	SOrm4oUsFxkdhWIJ;

1.161
date	2017.02.04.15.02.46;	author pirofti;	state Exp;
branches;
next	1.160;
commitid	XqTlEeKEGQ0fm5Xl;

1.160
date	2017.01.29.09.44.25;	author stsp;	state Exp;
branches;
next	1.159;
commitid	AdXvnVjyJHVNt5Dn;

1.159
date	2017.01.29.09.41.36;	author stsp;	state Exp;
branches;
next	1.158;
commitid	gW0sUGUdwsbYJSMI;

1.158
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.157;
commitid	VyLWTsbepAOk7VQM;

1.157
date	2017.01.21.11.21.41;	author stsp;	state Exp;
branches;
next	1.156;
commitid	R6aKUFxVS69wSgxN;

1.156
date	2017.01.12.18.06.57;	author stsp;	state Exp;
branches;
next	1.155;
commitid	j9xl1Hx6fze7kB7x;

1.155
date	2016.12.18.10.37.42;	author stsp;	state Exp;
branches;
next	1.154;
commitid	AFQR1xEK0cL7id30;

1.154
date	2016.12.10.19.03.53;	author stsp;	state Exp;
branches;
next	1.153;
commitid	B2n43853atiC9Mkg;

1.153
date	2016.12.10.13.56.38;	author stsp;	state Exp;
branches;
next	1.152;
commitid	nZf37PXwiE3Zdlxg;

1.152
date	2016.12.10.13.22.07;	author stsp;	state Exp;
branches;
next	1.151;
commitid	cF6ma8C1vctNqwbe;

1.151
date	2016.12.08.17.24.25;	author stsp;	state Exp;
branches;
next	1.150;
commitid	dWPNLWJTSP6hlvdK;

1.150
date	2016.12.06.12.57.20;	author stsp;	state Exp;
branches;
next	1.149;
commitid	ISSbA54Q0z5XC46x;

1.149
date	2016.11.30.14.31.51;	author stsp;	state Exp;
branches;
next	1.148;
commitid	41nYmZo2nRz9hk2d;

1.148
date	2016.11.19.21.07.08;	author stsp;	state Exp;
branches;
next	1.147;
commitid	boy7WCdUleXnAPjs;

1.147
date	2016.11.17.14.12.33;	author stsp;	state Exp;
branches;
next	1.146;
commitid	RZGobvsdCySKvlKP;

1.146
date	2016.11.01.13.49.50;	author stsp;	state Exp;
branches;
next	1.145;
commitid	QlpRjYIsv3Uj6nPf;

1.145
date	2016.10.19.14.15.07;	author stsp;	state Exp;
branches;
next	1.144;
commitid	iXG6kuEK8X9OhI1c;

1.144
date	2016.10.08.14.37.48;	author stsp;	state Exp;
branches;
next	1.143;
commitid	rTAy1DNkIlpg7OIE;

1.143
date	2016.10.05.18.13.25;	author stsp;	state Exp;
branches;
next	1.142;
commitid	OMn5syLTrOn15kZ5;

1.142
date	2016.09.27.15.54.33;	author stsp;	state Exp;
branches;
next	1.141;
commitid	bsjCtsAuuberiBTq;

1.141
date	2016.09.22.08.28.38;	author stsp;	state Exp;
branches;
next	1.140;
commitid	McS9bcN5RHYnantj;

1.140
date	2016.09.22.08.27.56;	author stsp;	state Exp;
branches;
next	1.139;
commitid	tfBSHywerx3PRrQs;

1.139
date	2016.09.21.14.02.33;	author stsp;	state Exp;
branches;
next	1.138;
commitid	qHH21jy4mbJS72SU;

1.138
date	2016.09.21.13.57.35;	author stsp;	state Exp;
branches;
next	1.137;
commitid	JdIpz11WYmJ1s49J;

1.137
date	2016.09.21.13.53.18;	author stsp;	state Exp;
branches;
next	1.136;
commitid	8kJwHj5e8qsEq6KP;

1.136
date	2016.09.21.13.29.11;	author stsp;	state Exp;
branches;
next	1.135;
commitid	3AAkAL6DZsacG5Hz;

1.135
date	2016.09.21.13.22.40;	author stsp;	state Exp;
branches;
next	1.134;
commitid	Fu1QBWR27ijxIIUs;

1.134
date	2016.09.21.13.08.34;	author stsp;	state Exp;
branches;
next	1.133;
commitid	lzikkEedc9zmWlZm;

1.133
date	2016.09.21.12.56.43;	author stsp;	state Exp;
branches;
next	1.132;
commitid	6F5LYb7nXqLmqOcn;

1.132
date	2016.09.12.10.18.26;	author stsp;	state Exp;
branches;
next	1.131;
commitid	x351v7nrBjOjDuVS;

1.131
date	2016.09.10.10.00.41;	author stsp;	state Exp;
branches;
next	1.130;
commitid	huIPEUbDtsP21fYg;

1.130
date	2016.09.10.09.40.24;	author stsp;	state Exp;
branches;
next	1.129;
commitid	v8LBZ8QBRPpbHoBw;

1.129
date	2016.09.10.09.32.33;	author stsp;	state Exp;
branches;
next	1.128;
commitid	NKHIC0DBd0N53xAz;

1.128
date	2016.09.10.09.13.09;	author stsp;	state Exp;
branches;
next	1.127;
commitid	af75HtpgCBlwRHtx;

1.127
date	2016.09.10.09.12.11;	author stsp;	state Exp;
branches;
next	1.126;
commitid	h003A8yP140rqR8c;

1.126
date	2016.09.10.07.38.24;	author stsp;	state Exp;
branches;
next	1.125;
commitid	Emgs4siu7oQFW1Mz;

1.125
date	2016.09.04.18.49.21;	author stsp;	state Exp;
branches;
next	1.124;
commitid	84hj2yWIdC9W7SOp;

1.124
date	2016.09.04.17.01.59;	author stsp;	state Exp;
branches;
next	1.123;
commitid	guSvznhdqA0babBn;

1.123
date	2016.09.04.16.52.43;	author stsp;	state Exp;
branches;
next	1.122;
commitid	6XRZqv9Yx0sZXo9X;

1.122
date	2016.09.04.16.46.54;	author stsp;	state Exp;
branches;
next	1.121;
commitid	Y6qKMJPX34aUzdlB;

1.121
date	2016.09.04.15.45.46;	author stsp;	state Exp;
branches;
next	1.120;
commitid	3i1zEytLY7VaT97o;

1.120
date	2016.09.04.11.07.04;	author stsp;	state Exp;
branches;
next	1.119;
commitid	nEOWx2Q0hqejrnK2;

1.119
date	2016.09.04.10.54.17;	author stsp;	state Exp;
branches;
next	1.118;
commitid	JHU6fkf4ndEvu22t;

1.118
date	2016.09.04.10.40.59;	author stsp;	state Exp;
branches;
next	1.117;
commitid	hjCoz0v3nduLokpT;

1.117
date	2016.09.04.10.21.14;	author stsp;	state Exp;
branches;
next	1.116;
commitid	iGkpzcFpS7XZknEq;

1.116
date	2016.09.04.10.14.35;	author stsp;	state Exp;
branches;
next	1.115;
commitid	gi0FFF2fk9qRtMkl;

1.115
date	2016.09.03.18.04.03;	author stsp;	state Exp;
branches;
next	1.114;
commitid	SjmFBRl49HVWcpno;

1.114
date	2016.09.03.17.29.47;	author stsp;	state Exp;
branches;
next	1.113;
commitid	BnsaG70RC9YkjJ63;

1.113
date	2016.09.03.17.09.23;	author stsp;	state Exp;
branches;
next	1.112;
commitid	vwXnntVfSbIXhVak;

1.112
date	2016.09.03.16.20.07;	author stsp;	state Exp;
branches;
next	1.111;
commitid	jf7FjBDeaFpVHMN7;

1.111
date	2016.09.03.15.33.48;	author stsp;	state Exp;
branches;
next	1.110;
commitid	fFkmBXHsUHJgLWGt;

1.110
date	2016.09.03.15.08.15;	author stsp;	state Exp;
branches;
next	1.109;
commitid	Eqey8eyk8NLNRRTr;

1.109
date	2016.09.03.15.05.03;	author stsp;	state Exp;
branches;
next	1.108;
commitid	mK92QJfUE9I47pu6;

1.108
date	2016.09.03.13.35.07;	author stsp;	state Exp;
branches;
next	1.107;
commitid	9hSPIsg1Zeg50Spl;

1.107
date	2016.09.03.12.24.21;	author stsp;	state Exp;
branches;
next	1.106;
commitid	tzXMB2Dl7smDF38f;

1.106
date	2016.09.03.11.42.12;	author stsp;	state Exp;
branches;
next	1.105;
commitid	uEzyOepw6g97AIEA;

1.105
date	2016.09.03.10.33.15;	author stsp;	state Exp;
branches;
next	1.104;
commitid	Eff39p9lR6J0x251;

1.104
date	2016.09.02.17.10.25;	author stsp;	state Exp;
branches;
next	1.103;
commitid	bNKhCvVNFrAOBdIi;

1.103
date	2016.09.02.15.47.32;	author stsp;	state Exp;
branches;
next	1.102;
commitid	uPzo2y3zoKGSUC9A;

1.102
date	2016.09.02.15.47.01;	author stsp;	state Exp;
branches;
next	1.101;
commitid	CApt2V7FWcqUGJk3;

1.101
date	2016.09.02.15.45.41;	author stsp;	state Exp;
branches;
next	1.100;
commitid	es87mxdsWJ1cDMYY;

1.100
date	2016.09.01.09.47.47;	author stsp;	state Exp;
branches;
next	1.99;
commitid	xc809MN4oOQXrEAR;

1.99
date	2016.08.17.09.39.38;	author stsp;	state Exp;
branches;
next	1.98;
commitid	2Vo2RJ82TBpkpVZ6;

1.98
date	2016.08.15.12.59.53;	author stsp;	state Exp;
branches;
next	1.97;
commitid	8Acg7y7uOkpSaDHq;

1.97
date	2016.08.07.23.06.39;	author stsp;	state Exp;
branches;
next	1.96;
commitid	D8TXrUDtoTVAgZH7;

1.96
date	2016.07.20.18.24.38;	author stsp;	state Exp;
branches;
next	1.95;
commitid	vgGdgscWybuU4Cju;

1.95
date	2016.07.18.13.10.35;	author stsp;	state Exp;
branches;
next	1.94;
commitid	CKdwcNynOUMn0GHE;

1.94
date	2016.07.18.13.09.58;	author stsp;	state Exp;
branches;
next	1.93;
commitid	X540k7ZhM1gwipwU;

1.93
date	2016.07.18.13.09.08;	author stsp;	state Exp;
branches;
next	1.92;
commitid	XhCkBgnpb16RsQZR;

1.92
date	2016.06.22.11.32.12;	author stsp;	state Exp;
branches;
next	1.91;
commitid	pgYSyotiicgfsJyi;

1.91
date	2016.06.22.11.30.00;	author stsp;	state Exp;
branches;
next	1.90;
commitid	WCeSjaejjrfnjZSa;

1.90
date	2016.06.22.11.28.27;	author stsp;	state Exp;
branches;
next	1.89;
commitid	n8T510RTMS8l0U7i;

1.89
date	2016.06.20.11.54.36;	author stsp;	state Exp;
branches;
next	1.88;
commitid	elNLq7oQ91BiVOUh;

1.88
date	2016.06.19.12.05.25;	author stsp;	state Exp;
branches;
next	1.87;
commitid	F1W53reKAUhcgrbY;

1.87
date	2016.06.18.07.49.24;	author stsp;	state Exp;
branches;
next	1.86;
commitid	j4DBSS56n1Q5xtvG;

1.86
date	2016.06.03.16.16.25;	author stsp;	state Exp;
branches;
next	1.85;
commitid	lomPcIdeQIEQevzb;

1.85
date	2016.05.28.18.30.01;	author stsp;	state Exp;
branches;
next	1.84;
commitid	6J6cB9soFzxfP4D1;

1.84
date	2016.05.28.08.34.17;	author stsp;	state Exp;
branches;
next	1.83;
commitid	oK4mtdlnAjLt7F7x;

1.83
date	2016.05.28.08.13.16;	author stsp;	state Exp;
branches;
next	1.82;
commitid	8ebmrzpPys0pIFKZ;

1.82
date	2016.05.25.13.35.12;	author stsp;	state Exp;
branches;
next	1.81;
commitid	ysQyHXeMccnGD7MG;

1.81
date	2016.05.18.07.28.01;	author stsp;	state Exp;
branches;
next	1.80;
commitid	2GRCjIWmjeIzO196;

1.80
date	2016.05.18.07.26.56;	author stsp;	state Exp;
branches;
next	1.79;
commitid	F1Mj80v9tjfUMfRc;

1.79
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.78;
commitid	8YSL8ByWzGeIGBiJ;

1.78
date	2016.02.13.10.29.13;	author stsp;	state Exp;
branches;
next	1.77;
commitid	FGrvtwAZwF9hxSLH;

1.77
date	2016.02.05.16.08.44;	author stsp;	state Exp;
branches;
next	1.76;
commitid	Jty9EDYprtCKTdCw;

1.76
date	2016.01.25.11.27.11;	author stsp;	state Exp;
branches;
next	1.75;
commitid	U9Unyh02TU5iq9jc;

1.75
date	2016.01.07.23.08.38;	author stsp;	state Exp;
branches;
next	1.74;
commitid	YQmveOCEh6MqfAJ4;

1.74
date	2016.01.06.19.56.50;	author stsp;	state Exp;
branches;
next	1.73;
commitid	vqkvQcVZc1K7MmHQ;

1.73
date	2016.01.06.09.15.31;	author stsp;	state Exp;
branches;
next	1.72;
commitid	YhlH1kyY5YaMihDc;

1.72
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.71;
commitid	2QagMjdMhQhIaQgu;

1.71
date	2015.12.14.08.34.56;	author stsp;	state Exp;
branches;
next	1.70;
commitid	mtIXAZui9PFGh9js;

1.70
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.69;
commitid	fbhqfhfdKxBcsetK;

1.69
date	2015.12.08.17.10.02;	author stsp;	state Exp;
branches;
next	1.68;
commitid	Clk4iAZ9SlzENy0G;

1.68
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.67;
commitid	B0kwmVGiD5DVx4kv;

1.67
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.66;
commitid	5gdEnqVoJuTuwdTu;

1.66
date	2015.11.24.15.43.15;	author mpi;	state Exp;
branches;
next	1.65;
commitid	4NlO6WfWlwA8ekGS;

1.65
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.64;
commitid	FuSD2mFDJWATHIDx;

1.64
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.63;
commitid	5DvsamK0GblTp8ww;

1.63
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.62;
commitid	YT6fyIEviv9qwbl6;

1.62
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.61;
commitid	hPF95ClMUQfeqQDX;

1.61
date	2015.10.22.11.51.28;	author jsg;	state Exp;
branches;
next	1.60;
commitid	U6KV6y8BsWn3FLvO;

1.60
date	2015.10.16.12.17.58;	author stsp;	state Exp;
branches;
next	1.59;
commitid	97u9XSED9FOiFona;

1.59
date	2015.10.16.12.17.38;	author stsp;	state Exp;
branches;
next	1.58;
commitid	HenFbQzCyih6T1I7;

1.58
date	2015.10.16.10.29.55;	author stsp;	state Exp;
branches;
next	1.57;
commitid	eeebrEIbE61iTWlE;

1.57
date	2015.10.16.10.04.56;	author stsp;	state Exp;
branches;
next	1.56;
commitid	NgHWD7OplbuLfYvK;

1.56
date	2015.10.12.10.01.27;	author stsp;	state Exp;
branches;
next	1.55;
commitid	cYqDJ1cY7EVyJwWu;

1.55
date	2015.10.11.10.22.28;	author stsp;	state Exp;
branches;
next	1.54;
commitid	jZzDd7EmNURq20EO;

1.54
date	2015.10.10.19.04.57;	author stsp;	state Exp;
branches;
next	1.53;
commitid	H8C3H62UJEYx7E5g;

1.53
date	2015.10.06.09.12.00;	author stsp;	state Exp;
branches;
next	1.52;
commitid	ZFRC6vNUefILhzue;

1.52
date	2015.10.05.13.05.08;	author stsp;	state Exp;
branches;
next	1.51;
commitid	zsqg29ZtiouKEBwF;

1.51
date	2015.09.27.16.53.38;	author stsp;	state Exp;
branches;
next	1.50;
commitid	4NX6S1lkoKXcWkyO;

1.50
date	2015.09.27.16.52.35;	author stsp;	state Exp;
branches;
next	1.49;
commitid	AHXYws30p8pEL4rA;

1.49
date	2015.09.26.10.52.09;	author stsp;	state Exp;
branches;
next	1.48;
commitid	JO6i6Tt1PcgUpjjr;

1.48
date	2015.09.23.17.22.18;	author stsp;	state Exp;
branches;
next	1.47;
commitid	8vI5h1pEV9k3epP2;

1.47
date	2015.09.23.17.21.50;	author stsp;	state Exp;
branches;
next	1.46;
commitid	3dOIIXk5qOUozFRg;

1.46
date	2015.07.19.21.40.00;	author stsp;	state Exp;
branches;
next	1.45;
commitid	G6X3gBX0rlx5daY2;

1.45
date	2015.06.15.08.06.11;	author stsp;	state Exp;
branches;
next	1.44;
commitid	P5lq1LqvmbH1YXqx;

1.44
date	2015.06.15.07.50.44;	author stsp;	state Exp;
branches;
next	1.43;
commitid	cvCtAwT7RzWXQ17u;

1.43
date	2015.06.12.13.11.27;	author stsp;	state Exp;
branches;
next	1.42;
commitid	WOXi0GMOFiyehJgl;

1.42
date	2015.05.30.02.49.23;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	vLJSfQJ3Cs5xZhDk;

1.41
date	2015.05.22.06.50.54;	author kettenis;	state Exp;
branches;
next	1.40;
commitid	F5f4PyqBUDw9Y25c;

1.40
date	2015.05.21.22.13.55;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	cVgAYBuMh3fKVWvV;

1.39
date	2015.03.23.00.35.19;	author jsg;	state Exp;
branches;
next	1.38;
commitid	hwMX0buFG1X2k4Pc;

1.38
date	2015.03.16.04.09.53;	author jsg;	state Exp;
branches;
next	1.37;
commitid	VSofcdbznJCBaPnY;

1.37
date	2015.03.11.12.24.44;	author jsg;	state Exp;
branches;
next	1.36;
commitid	tYvpLyH0BOFw4SFi;

1.36
date	2015.03.06.18.39.24;	author kettenis;	state Exp;
branches;
next	1.35;
commitid	i8F8zMI1bBC439iz;

1.35
date	2015.03.04.15.18.12;	author jsg;	state Exp;
branches;
next	1.34;
commitid	E7j9R5s6K5t6o2Dz;

1.34
date	2015.03.03.20.14.34;	author kettenis;	state Exp;
branches;
next	1.33;
commitid	b3mMd6p5C60DzCvz;

1.33
date	2015.03.03.06.56.12;	author kettenis;	state Exp;
branches;
next	1.32;
commitid	XPASjbuMKmUMsFHY;

1.32
date	2015.03.02.22.50.10;	author jsg;	state Exp;
branches;
next	1.31;
commitid	22iGJn0U7Tu1U6fl;

1.31
date	2015.03.02.22.31.03;	author jsg;	state Exp;
branches;
next	1.30;
commitid	WvCxDtdcQqAp0P1C;

1.30
date	2015.03.02.22.19.12;	author jsg;	state Exp;
branches;
next	1.29;
commitid	qogQLYOzYLYPgc26;

1.29
date	2015.03.02.22.12.57;	author jsg;	state Exp;
branches;
next	1.28;
commitid	U17ZPcdizYejAB8C;

1.28
date	2015.03.02.13.59.38;	author jsg;	state Exp;
branches;
next	1.27;
commitid	CvyvVb3ioWE8M8TP;

1.27
date	2015.03.02.13.56.30;	author jsg;	state Exp;
branches;
next	1.26;
commitid	LuKBhamfKdzh8TtV;

1.26
date	2015.03.02.13.53.41;	author jsg;	state Exp;
branches;
next	1.25;
commitid	Lm8Xn3zesJV4lzHI;

1.25
date	2015.03.02.13.51.10;	author jsg;	state Exp;
branches;
next	1.24;
commitid	0yRGSOyukjSEkV3a;

1.24
date	2015.03.02.13.46.40;	author jsg;	state Exp;
branches;
next	1.23;
commitid	A6K73Jj1X8bEfnpe;

1.23
date	2015.03.01.14.56.34;	author kettenis;	state Exp;
branches;
next	1.22;
commitid	LcgNUHpjf4IQwjYH;

1.22
date	2015.02.23.09.40.47;	author stsp;	state Exp;
branches;
next	1.21;
commitid	FBnvinGdxsuSvG7X;

1.21
date	2015.02.21.09.53.49;	author stsp;	state Exp;
branches;
next	1.20;
commitid	ByOKymtxrNzNox3E;

1.20
date	2015.02.20.14.08.18;	author stsp;	state Exp;
branches;
next	1.19;
commitid	ZzuVbDm6Z2kLO0sa;

1.19
date	2015.02.20.13.39.08;	author stsp;	state Exp;
branches;
next	1.18;
commitid	Flf1EzOfdsM3eiqs;

1.18
date	2015.02.11.01.12.42;	author brad;	state Exp;
branches;
next	1.17;
commitid	YDSlOBqO8VG0SJDe;

1.17
date	2015.02.11.00.57.49;	author stsp;	state Exp;
branches;
next	1.16;
commitid	IoM1XoQxBx0FB6ZE;

1.16
date	2015.02.11.00.53.37;	author stsp;	state Exp;
branches;
next	1.15;
commitid	El90X3L4W2OTgQnX;

1.15
date	2015.02.10.23.40.43;	author stsp;	state Exp;
branches;
next	1.14;
commitid	NY3AH0HhegNmnsvo;

1.14
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.13;
commitid	Hly9lJn6CNMylcFu;

1.13
date	2015.02.10.22.32.04;	author stsp;	state Exp;
branches;
next	1.12;
commitid	omR6dHl5scG3FVJr;

1.12
date	2015.02.10.22.09.11;	author stsp;	state Exp;
branches;
next	1.11;
commitid	0TyUGkGmrprNsRcZ;

1.11
date	2015.02.10.20.52.58;	author stsp;	state Exp;
branches;
next	1.10;
commitid	2KSbX2BT7cMKkmBB;

1.10
date	2015.02.10.20.34.18;	author stsp;	state Exp;
branches;
next	1.9;
commitid	nfYWQI23INr3GIrK;

1.9
date	2015.02.09.03.51.59;	author guenther;	state Exp;
branches;
next	1.8;
commitid	FuHmPxATPROOPRu3;

1.8
date	2015.02.09.00.26.27;	author phessler;	state Exp;
branches;
next	1.7;
commitid	ok6VSg308YovR1tF;

1.7
date	2015.02.08.23.30.21;	author stsp;	state Exp;
branches;
next	1.6;
commitid	K3m7Yx6EniLFywmT;

1.6
date	2015.02.08.16.07.15;	author stsp;	state Exp;
branches;
next	1.5;
commitid	TXNgAs6m1KaqveVX;

1.5
date	2015.02.08.13.43.28;	author stsp;	state Exp;
branches;
next	1.4;
commitid	9ObXGPZAphldmojf;

1.4
date	2015.02.07.19.04.41;	author stsp;	state Exp;
branches;
next	1.3;
commitid	obiTN23eOlpBGcGs;

1.3
date	2015.02.07.07.10.44;	author phessler;	state Exp;
branches;
next	1.2;
commitid	ZAFNJhanO1wXZOL4;

1.2
date	2015.02.06.23.52.23;	author stsp;	state Exp;
branches;
next	1.1;
commitid	ifyxab6WnCJwnPG4;

1.1
date	2015.02.06.19.49.29;	author stsp;	state Exp;
branches;
next	;
commitid	Uagadgn7Uonii0DS;


desc
@@


1.198
log
@Remove the IWM_FLAG_HW_INITED flag from iwm(4). This flag was redundant.
The IFF_RUNNING flag in struct ifnet serves the same purpose.
ok mpi@@ kettenis@@ deraadt@@
@
text
@/*	$OpenBSD: if_iwm.c,v 1.197 2017/06/16 08:45:34 stsp Exp $	*/

/*
 * Copyright (c) 2014, 2016 genua gmbh <info@@genua.de>
 *   Author: Stefan Sperling <stsp@@openbsd.org>
 * Copyright (c) 2014 Fixup Software Ltd.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Based on BSD-licensed source modules in the Linux iwlwifi driver,
 * which were used as the reference documentation for this implementation.
 *
 ***********************************************************************
 *
 * This file is provided under a dual BSD/GPLv2 license.  When using or
 * redistributing this file, you may do so under either license.
 *
 * GPL LICENSE SUMMARY
 *
 * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
 * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH
 * Copyright(c) 2016 Intel Deutschland GmbH
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
 * USA
 *
 * The full GNU General Public License is included in this distribution
 * in the file called COPYING.
 *
 * Contact Information:
 *  Intel Linux Wireless <ilw@@linux.intel.com>
 * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
 *
 *
 * BSD LICENSE
 *
 * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
 * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH
 * Copyright(c) 2016 Intel Deutschland GmbH
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *  * Neither the name Intel Corporation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 2007-2010 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mutex.h>
#include <sys/proc.h>
#include <sys/rwlock.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/systm.h>
#include <sys/endian.h>

#include <sys/task.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_mira.h>
#include <net80211/ieee80211_radiotap.h>

#define DEVNAME(_s)	((_s)->sc_dev.dv_xname)

#define IC2IFP(_ic_) (&(_ic_)->ic_if)

#define le16_to_cpup(_a_) (le16toh(*(const uint16_t *)(_a_)))
#define le32_to_cpup(_a_) (le32toh(*(const uint32_t *)(_a_)))

#ifdef IWM_DEBUG
#define DPRINTF(x)	do { if (iwm_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (iwm_debug >= (n)) printf x; } while (0)
int iwm_debug = 1;
#else
#define DPRINTF(x)	do { ; } while (0)
#define DPRINTFN(n, x)	do { ; } while (0)
#endif

#include <dev/pci/if_iwmreg.h>
#include <dev/pci/if_iwmvar.h>

const uint8_t iwm_nvm_channels[] = {
	/* 2.4 GHz */
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
	/* 5 GHz */
	36, 40, 44 , 48, 52, 56, 60, 64,
	100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144,
	149, 153, 157, 161, 165
};

const uint8_t iwm_nvm_channels_8000[] = {
	/* 2.4 GHz */
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
	/* 5 GHz */
	36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92,
	96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144,
	149, 153, 157, 161, 165, 169, 173, 177, 181
};

#define IWM_NUM_2GHZ_CHANNELS	14

const struct iwm_rate {
	uint16_t rate;
	uint8_t plcp;
	uint8_t ht_plcp;
} iwm_rates[] = {
		/* Legacy */		/* HT */
	{   2,	IWM_RATE_1M_PLCP,	IWM_RATE_HT_SISO_MCS_INV_PLCP  },
	{   4,	IWM_RATE_2M_PLCP,	IWM_RATE_HT_SISO_MCS_INV_PLCP },
	{  11,	IWM_RATE_5M_PLCP,	IWM_RATE_HT_SISO_MCS_INV_PLCP  },
	{  22,	IWM_RATE_11M_PLCP,	IWM_RATE_HT_SISO_MCS_INV_PLCP },
	{  12,	IWM_RATE_6M_PLCP,	IWM_RATE_HT_SISO_MCS_0_PLCP },
	{  18,	IWM_RATE_9M_PLCP,	IWM_RATE_HT_SISO_MCS_INV_PLCP  },
	{  24,	IWM_RATE_12M_PLCP,	IWM_RATE_HT_SISO_MCS_1_PLCP },
	{  26,	IWM_RATE_INVM_PLCP,	IWM_RATE_HT_MIMO2_MCS_8_PLCP },
	{  36,	IWM_RATE_18M_PLCP,	IWM_RATE_HT_SISO_MCS_2_PLCP },
	{  48,	IWM_RATE_24M_PLCP,	IWM_RATE_HT_SISO_MCS_3_PLCP },
	{  52,	IWM_RATE_INVM_PLCP,	IWM_RATE_HT_MIMO2_MCS_9_PLCP },
	{  72,	IWM_RATE_36M_PLCP,	IWM_RATE_HT_SISO_MCS_4_PLCP },
	{  78,	IWM_RATE_INVM_PLCP,	IWM_RATE_HT_MIMO2_MCS_10_PLCP },
	{  96,	IWM_RATE_48M_PLCP,	IWM_RATE_HT_SISO_MCS_5_PLCP },
	{ 104,	IWM_RATE_INVM_PLCP,	IWM_RATE_HT_MIMO2_MCS_11_PLCP },
	{ 108,	IWM_RATE_54M_PLCP,	IWM_RATE_HT_SISO_MCS_6_PLCP },
	{ 128,	IWM_RATE_INVM_PLCP,	IWM_RATE_HT_SISO_MCS_7_PLCP },
	{ 156,	IWM_RATE_INVM_PLCP,	IWM_RATE_HT_MIMO2_MCS_12_PLCP },
	{ 208,	IWM_RATE_INVM_PLCP,	IWM_RATE_HT_MIMO2_MCS_13_PLCP },
	{ 234,	IWM_RATE_INVM_PLCP,	IWM_RATE_HT_MIMO2_MCS_14_PLCP },
	{ 260,	IWM_RATE_INVM_PLCP,	IWM_RATE_HT_MIMO2_MCS_15_PLCP },
};
#define IWM_RIDX_CCK	0
#define IWM_RIDX_OFDM	4
#define IWM_RIDX_MAX	(nitems(iwm_rates)-1)
#define IWM_RIDX_IS_CCK(_i_) ((_i_) < IWM_RIDX_OFDM)
#define IWM_RIDX_IS_OFDM(_i_) ((_i_) >= IWM_RIDX_OFDM)

/* Convert an MCS index into an iwm_rates[] index. */
const int iwm_mcs2ridx[] = {
	IWM_RATE_MCS_0_INDEX,
	IWM_RATE_MCS_1_INDEX,
	IWM_RATE_MCS_2_INDEX,
	IWM_RATE_MCS_3_INDEX,
	IWM_RATE_MCS_4_INDEX,
	IWM_RATE_MCS_5_INDEX,
	IWM_RATE_MCS_6_INDEX,
	IWM_RATE_MCS_7_INDEX,
	IWM_RATE_MCS_8_INDEX,
	IWM_RATE_MCS_9_INDEX,
	IWM_RATE_MCS_10_INDEX,
	IWM_RATE_MCS_11_INDEX,
	IWM_RATE_MCS_12_INDEX,
	IWM_RATE_MCS_13_INDEX,
	IWM_RATE_MCS_14_INDEX,
	IWM_RATE_MCS_15_INDEX,
};

struct iwm_nvm_section {
	uint16_t length;
	uint8_t *data;
};

int	iwm_is_mimo_ht_plcp(uint8_t);
int	iwm_is_mimo_mcs(int);
int	iwm_store_cscheme(struct iwm_softc *, uint8_t *, size_t);
int	iwm_firmware_store_section(struct iwm_softc *, enum iwm_ucode_type,
	    uint8_t *, size_t);
int	iwm_set_default_calib(struct iwm_softc *, const void *);
void	iwm_fw_info_free(struct iwm_fw_info *);
int	iwm_read_firmware(struct iwm_softc *, enum iwm_ucode_type);
uint32_t iwm_read_prph(struct iwm_softc *, uint32_t);
void	iwm_write_prph(struct iwm_softc *, uint32_t, uint32_t);
int	iwm_read_mem(struct iwm_softc *, uint32_t, void *, int);
int	iwm_write_mem(struct iwm_softc *, uint32_t, const void *, int);
int	iwm_write_mem32(struct iwm_softc *, uint32_t, uint32_t);
int	iwm_poll_bit(struct iwm_softc *, int, uint32_t, uint32_t, int);
int	iwm_nic_lock(struct iwm_softc *);
void	iwm_nic_assert_locked(struct iwm_softc *);
void	iwm_nic_unlock(struct iwm_softc *);
void	iwm_set_bits_mask_prph(struct iwm_softc *, uint32_t, uint32_t,
	    uint32_t);
void	iwm_set_bits_prph(struct iwm_softc *, uint32_t, uint32_t);
void	iwm_clear_bits_prph(struct iwm_softc *, uint32_t, uint32_t);
int	iwm_dma_contig_alloc(bus_dma_tag_t, struct iwm_dma_info *, bus_size_t,
	    bus_size_t);
void	iwm_dma_contig_free(struct iwm_dma_info *);
int	iwm_alloc_rx_ring(struct iwm_softc *, struct iwm_rx_ring *);
void	iwm_disable_rx_dma(struct iwm_softc *);
void	iwm_reset_rx_ring(struct iwm_softc *, struct iwm_rx_ring *);
void	iwm_free_rx_ring(struct iwm_softc *, struct iwm_rx_ring *);
int	iwm_alloc_tx_ring(struct iwm_softc *, struct iwm_tx_ring *, int);
void	iwm_reset_tx_ring(struct iwm_softc *, struct iwm_tx_ring *);
void	iwm_free_tx_ring(struct iwm_softc *, struct iwm_tx_ring *);
void	iwm_enable_rfkill_int(struct iwm_softc *);
int	iwm_check_rfkill(struct iwm_softc *);
void	iwm_enable_interrupts(struct iwm_softc *);
void	iwm_restore_interrupts(struct iwm_softc *);
void	iwm_disable_interrupts(struct iwm_softc *);
void	iwm_ict_reset(struct iwm_softc *);
int	iwm_set_hw_ready(struct iwm_softc *);
int	iwm_prepare_card_hw(struct iwm_softc *);
void	iwm_apm_config(struct iwm_softc *);
int	iwm_apm_init(struct iwm_softc *);
void	iwm_apm_stop(struct iwm_softc *);
int	iwm_allow_mcast(struct iwm_softc *);
int	iwm_start_hw(struct iwm_softc *);
void	iwm_stop_device(struct iwm_softc *);
void	iwm_nic_config(struct iwm_softc *);
int	iwm_nic_rx_init(struct iwm_softc *);
int	iwm_nic_tx_init(struct iwm_softc *);
int	iwm_nic_init(struct iwm_softc *);
int	iwm_enable_txq(struct iwm_softc *, int, int, int);
int	iwm_post_alive(struct iwm_softc *);
struct iwm_phy_db_entry *iwm_phy_db_get_section(struct iwm_softc *, uint16_t,
	    uint16_t);
int	iwm_phy_db_set_section(struct iwm_softc *,
	    struct iwm_calib_res_notif_phy_db *);
int	iwm_is_valid_channel(uint16_t);
uint8_t	iwm_ch_id_to_ch_index(uint16_t);
uint16_t iwm_channel_id_to_papd(uint16_t);
uint16_t iwm_channel_id_to_txp(struct iwm_softc *, uint16_t);
int	iwm_phy_db_get_section_data(struct iwm_softc *, uint32_t, uint8_t **,
	    uint16_t *, uint16_t);
int	iwm_send_phy_db_cmd(struct iwm_softc *, uint16_t, uint16_t, void *);
int	iwm_phy_db_send_all_channel_groups(struct iwm_softc *, uint16_t,
	    uint8_t);
int	iwm_send_phy_db_data(struct iwm_softc *);
void	iwm_te_v2_to_v1(const struct iwm_time_event_cmd_v2 *,
	    struct iwm_time_event_cmd_v1 *);
int	iwm_send_time_event_cmd(struct iwm_softc *,
	    const struct iwm_time_event_cmd_v2 *);
void	iwm_protect_session(struct iwm_softc *, struct iwm_node *, uint32_t,
	    uint32_t);
int	iwm_nvm_read_chunk(struct iwm_softc *, uint16_t, uint16_t, uint16_t,
	    uint8_t *, uint16_t *);
int	iwm_nvm_read_section(struct iwm_softc *, uint16_t, uint8_t *,
	    uint16_t *, size_t);
void	iwm_init_channel_map(struct iwm_softc *, const uint16_t * const,
	    const uint8_t *nvm_channels, size_t nchan);
void	iwm_setup_ht_rates(struct iwm_softc *);
void	iwm_htprot_task(void *);
void	iwm_update_htprot(struct ieee80211com *, struct ieee80211_node *);
int	iwm_ampdu_rx_start(struct ieee80211com *, struct ieee80211_node *,
	    uint8_t);
void	iwm_ampdu_rx_stop(struct ieee80211com *, struct ieee80211_node *,
	    uint8_t);
void	iwm_sta_rx_agg(struct iwm_softc *, struct ieee80211_node *, uint8_t,
	    uint16_t, int);
#ifdef notyet
int	iwm_ampdu_tx_start(struct ieee80211com *, struct ieee80211_node *,
	    uint8_t);
void	iwm_ampdu_tx_stop(struct ieee80211com *, struct ieee80211_node *,
	    uint8_t);
#endif
void	iwm_ba_task(void *);

int	iwm_parse_nvm_data(struct iwm_softc *, const uint16_t *,
	    const uint16_t *, const uint16_t *,
	    const uint16_t *, const uint16_t *,
	    const uint16_t *);
void	iwm_set_hw_address_8000(struct iwm_softc *, struct iwm_nvm_data *,
	    const uint16_t *, const uint16_t *);
int	iwm_parse_nvm_sections(struct iwm_softc *, struct iwm_nvm_section *);
int	iwm_nvm_init(struct iwm_softc *);
int	iwm_firmware_load_sect(struct iwm_softc *, uint32_t, const uint8_t *,
	    uint32_t);
int	iwm_firmware_load_chunk(struct iwm_softc *, uint32_t, const uint8_t *,
	    uint32_t);
int	iwm_load_firmware_7000(struct iwm_softc *, enum iwm_ucode_type);
int	iwm_load_cpu_sections_8000(struct iwm_softc *, struct iwm_fw_sects *,
	    int , int *);
int	iwm_load_firmware_8000(struct iwm_softc *, enum iwm_ucode_type);
int	iwm_load_firmware(struct iwm_softc *, enum iwm_ucode_type);
int	iwm_start_fw(struct iwm_softc *, enum iwm_ucode_type);
int	iwm_send_tx_ant_cfg(struct iwm_softc *, uint8_t);
int	iwm_send_phy_cfg_cmd(struct iwm_softc *);
int	iwm_load_ucode_wait_alive(struct iwm_softc *, enum iwm_ucode_type);
int	iwm_run_init_mvm_ucode(struct iwm_softc *, int);
int	iwm_rx_addbuf(struct iwm_softc *, int, int);
int	iwm_calc_rssi(struct iwm_softc *, struct iwm_rx_phy_info *);
int	iwm_get_signal_strength(struct iwm_softc *, struct iwm_rx_phy_info *);
void	iwm_rx_rx_phy_cmd(struct iwm_softc *, struct iwm_rx_packet *,
	    struct iwm_rx_data *);
int	iwm_get_noise(const struct iwm_statistics_rx_non_phy *);
void	iwm_rx_rx_mpdu(struct iwm_softc *, struct iwm_rx_packet *,
	    struct iwm_rx_data *);
void	iwm_rx_tx_cmd_single(struct iwm_softc *, struct iwm_rx_packet *,
	    struct iwm_node *);
void	iwm_rx_tx_cmd(struct iwm_softc *, struct iwm_rx_packet *,
	    struct iwm_rx_data *);
void	iwm_rx_bmiss(struct iwm_softc *, struct iwm_rx_packet *,
	    struct iwm_rx_data *);
int	iwm_binding_cmd(struct iwm_softc *, struct iwm_node *, uint32_t);
void	iwm_phy_ctxt_cmd_hdr(struct iwm_softc *, struct iwm_phy_ctxt *,
	    struct iwm_phy_context_cmd *, uint32_t, uint32_t);
void	iwm_phy_ctxt_cmd_data(struct iwm_softc *, struct iwm_phy_context_cmd *,
	    struct ieee80211_channel *, uint8_t, uint8_t);
int	iwm_phy_ctxt_cmd(struct iwm_softc *, struct iwm_phy_ctxt *, uint8_t,
	    uint8_t, uint32_t, uint32_t);
int	iwm_send_cmd(struct iwm_softc *, struct iwm_host_cmd *);
int	iwm_send_cmd_pdu(struct iwm_softc *, uint32_t, uint32_t, uint16_t,
	    const void *);
int	iwm_send_cmd_status(struct iwm_softc *, struct iwm_host_cmd *,
	    uint32_t *);
int	iwm_send_cmd_pdu_status(struct iwm_softc *, uint32_t, uint16_t,
	    const void *, uint32_t *);
void	iwm_free_resp(struct iwm_softc *, struct iwm_host_cmd *);
void	iwm_cmd_done(struct iwm_softc *, struct iwm_rx_packet *);
void	iwm_update_sched(struct iwm_softc *, int, int, uint8_t, uint16_t);
const struct iwm_rate *iwm_tx_fill_cmd(struct iwm_softc *, struct iwm_node *,
	    struct ieee80211_frame *, struct iwm_tx_cmd *);
int	iwm_tx(struct iwm_softc *, struct mbuf *, struct ieee80211_node *, int);
void	iwm_led_enable(struct iwm_softc *);
void	iwm_led_disable(struct iwm_softc *);
int	iwm_led_is_enabled(struct iwm_softc *);
void	iwm_led_blink_timeout(void *);
void	iwm_led_blink_start(struct iwm_softc *);
void	iwm_led_blink_stop(struct iwm_softc *);
int	iwm_beacon_filter_send_cmd(struct iwm_softc *,
	    struct iwm_beacon_filter_cmd *);
void	iwm_beacon_filter_set_cqm_params(struct iwm_softc *, struct iwm_node *,
	    struct iwm_beacon_filter_cmd *);
int	iwm_update_beacon_abort(struct iwm_softc *, struct iwm_node *, int);
void	iwm_power_build_cmd(struct iwm_softc *, struct iwm_node *,
	    struct iwm_mac_power_cmd *);
int	iwm_power_mac_update_mode(struct iwm_softc *, struct iwm_node *);
int	iwm_power_update_device(struct iwm_softc *);
int	iwm_enable_beacon_filter(struct iwm_softc *, struct iwm_node *);
int	iwm_disable_beacon_filter(struct iwm_softc *);
int	iwm_add_sta_cmd(struct iwm_softc *, struct iwm_node *, int);
int	iwm_add_aux_sta(struct iwm_softc *);
uint16_t iwm_scan_rx_chain(struct iwm_softc *);
uint32_t iwm_scan_rate_n_flags(struct iwm_softc *, int, int);
uint8_t	iwm_lmac_scan_fill_channels(struct iwm_softc *,
	    struct iwm_scan_channel_cfg_lmac *, int);
int	iwm_fill_probe_req(struct iwm_softc *, struct iwm_scan_probe_req *);
int	iwm_lmac_scan(struct iwm_softc *);
int	iwm_config_umac_scan(struct iwm_softc *);
int	iwm_umac_scan(struct iwm_softc *);
uint8_t	iwm_ridx2rate(struct ieee80211_rateset *, int);
int	iwm_rval2ridx(int);
void	iwm_ack_rates(struct iwm_softc *, struct iwm_node *, int *, int *);
void	iwm_mac_ctxt_cmd_common(struct iwm_softc *, struct iwm_node *,
	    struct iwm_mac_ctx_cmd *, uint32_t, int);
void	iwm_mac_ctxt_cmd_fill_sta(struct iwm_softc *, struct iwm_node *,
	    struct iwm_mac_data_sta *, int);
int	iwm_mac_ctxt_cmd(struct iwm_softc *, struct iwm_node *, uint32_t, int);
int	iwm_update_quotas(struct iwm_softc *, struct iwm_node *);
int	iwm_auth(struct iwm_softc *);
int	iwm_assoc(struct iwm_softc *);
struct ieee80211_node *iwm_node_alloc(struct ieee80211com *);
void	iwm_calib_timeout(void *);
void	iwm_setrates(struct iwm_node *);
int	iwm_media_change(struct ifnet *);
void	iwm_newstate_task(void *);
int	iwm_newstate(struct ieee80211com *, enum ieee80211_state, int);
void	iwm_endscan_cb(void *);
void	iwm_fill_sf_command(struct iwm_softc *, struct iwm_sf_cfg_cmd *,
	    struct ieee80211_node *);
int	iwm_sf_config(struct iwm_softc *, int);
int	iwm_send_bt_init_conf(struct iwm_softc *);
int	iwm_send_update_mcc_cmd(struct iwm_softc *, const char *);
void	iwm_tt_tx_backoff(struct iwm_softc *, uint32_t);
int	iwm_init_hw(struct iwm_softc *);
int	iwm_init(struct ifnet *);
void	iwm_start(struct ifnet *);
void	iwm_stop(struct ifnet *, int);
void	iwm_watchdog(struct ifnet *);
int	iwm_ioctl(struct ifnet *, u_long, caddr_t);
#ifdef IWM_DEBUG
const char *iwm_desc_lookup(uint32_t);
void	iwm_nic_error(struct iwm_softc *);
void	iwm_nic_umac_error(struct iwm_softc *);
#endif
void	iwm_notif_intr(struct iwm_softc *);
int	iwm_intr(void *);
int	iwm_match(struct device *, void *, void *);
int	iwm_preinit(struct iwm_softc *);
void	iwm_attach_hook(struct device *);
void	iwm_attach(struct device *, struct device *, void *);
void	iwm_init_task(void *);
int	iwm_activate(struct device *, int);
int	iwm_resume(struct iwm_softc *);

#if NBPFILTER > 0
void	iwm_radiotap_attach(struct iwm_softc *);
#endif

int
iwm_is_mimo_ht_plcp(uint8_t ht_plcp)
{
	return (ht_plcp != IWM_RATE_HT_SISO_MCS_INV_PLCP &&
	    (ht_plcp & IWM_RATE_HT_MCS_NSS_MSK));
}

int
iwm_is_mimo_mcs(int mcs)
{
	int ridx = iwm_mcs2ridx[mcs];
	return iwm_is_mimo_ht_plcp(iwm_rates[ridx].ht_plcp);
	
}

int
iwm_store_cscheme(struct iwm_softc *sc, uint8_t *data, size_t dlen)
{
	struct iwm_fw_cscheme_list *l = (void *)data;

	if (dlen < sizeof(*l) ||
	    dlen < sizeof(l->size) + l->size * sizeof(*l->cs))
		return EINVAL;

	/* we don't actually store anything for now, always use s/w crypto */

	return 0;
}

int
iwm_firmware_store_section(struct iwm_softc *sc, enum iwm_ucode_type type,
    uint8_t *data, size_t dlen)
{
	struct iwm_fw_sects *fws;
	struct iwm_fw_onesect *fwone;

	if (type >= IWM_UCODE_TYPE_MAX)
		return EINVAL;
	if (dlen < sizeof(uint32_t))
		return EINVAL;

	fws = &sc->sc_fw.fw_sects[type];
	if (fws->fw_count >= IWM_UCODE_SECT_MAX)
		return EINVAL;

	fwone = &fws->fw_sect[fws->fw_count];

	/* first 32bit are device load offset */
	memcpy(&fwone->fws_devoff, data, sizeof(uint32_t));

	/* rest is data */
	fwone->fws_data = data + sizeof(uint32_t);
	fwone->fws_len = dlen - sizeof(uint32_t);

	fws->fw_count++;
	fws->fw_totlen += fwone->fws_len;

	return 0;
}

#define IWM_DEFAULT_SCAN_CHANNELS 40

struct iwm_tlv_calib_data {
	uint32_t ucode_type;
	struct iwm_tlv_calib_ctrl calib;
} __packed;

int
iwm_set_default_calib(struct iwm_softc *sc, const void *data)
{
	const struct iwm_tlv_calib_data *def_calib = data;
	uint32_t ucode_type = le32toh(def_calib->ucode_type);

	if (ucode_type >= IWM_UCODE_TYPE_MAX)
		return EINVAL;

	sc->sc_default_calib[ucode_type].flow_trigger =
	    def_calib->calib.flow_trigger;
	sc->sc_default_calib[ucode_type].event_trigger =
	    def_calib->calib.event_trigger;

	return 0;
}

void
iwm_fw_info_free(struct iwm_fw_info *fw)
{
	free(fw->fw_rawdata, M_DEVBUF, fw->fw_rawsize);
	fw->fw_rawdata = NULL;
	fw->fw_rawsize = 0;
	/* don't touch fw->fw_status */
	memset(fw->fw_sects, 0, sizeof(fw->fw_sects));
}

int
iwm_read_firmware(struct iwm_softc *sc, enum iwm_ucode_type ucode_type)
{
	struct iwm_fw_info *fw = &sc->sc_fw;
	struct iwm_tlv_ucode_header *uhdr;
	struct iwm_ucode_tlv tlv;
	uint32_t tlv_type;
	uint8_t *data;
	int err;
	size_t len;

	if (fw->fw_status == IWM_FW_STATUS_DONE &&
	    ucode_type != IWM_UCODE_TYPE_INIT)
		return 0;

	while (fw->fw_status == IWM_FW_STATUS_INPROGRESS)
		tsleep(&sc->sc_fw, 0, "iwmfwp", 0);
	fw->fw_status = IWM_FW_STATUS_INPROGRESS;

	if (fw->fw_rawdata != NULL)
		iwm_fw_info_free(fw);

	err = loadfirmware(sc->sc_fwname,
	    (u_char **)&fw->fw_rawdata, &fw->fw_rawsize);
	if (err) {
		printf("%s: could not read firmware %s (error %d)\n",
		    DEVNAME(sc), sc->sc_fwname, err);
		goto out;
	}

	sc->sc_capaflags = 0;
	sc->sc_capa_n_scan_channels = IWM_DEFAULT_SCAN_CHANNELS;
	memset(sc->sc_enabled_capa, 0, sizeof(sc->sc_enabled_capa));
	memset(sc->sc_fw_mcc, 0, sizeof(sc->sc_fw_mcc));

	uhdr = (void *)fw->fw_rawdata;
	if (*(uint32_t *)fw->fw_rawdata != 0
	    || le32toh(uhdr->magic) != IWM_TLV_UCODE_MAGIC) {
		printf("%s: invalid firmware %s\n",
		    DEVNAME(sc), sc->sc_fwname);
		err = EINVAL;
		goto out;
	}

	snprintf(sc->sc_fwver, sizeof(sc->sc_fwver), "%d.%d (API ver %d)",
	    IWM_UCODE_MAJOR(le32toh(uhdr->ver)),
	    IWM_UCODE_MINOR(le32toh(uhdr->ver)),
	    IWM_UCODE_API(le32toh(uhdr->ver)));
	data = uhdr->data;
	len = fw->fw_rawsize - sizeof(*uhdr);

	while (len >= sizeof(tlv)) {
		size_t tlv_len;
		void *tlv_data;

		memcpy(&tlv, data, sizeof(tlv));
		tlv_len = le32toh(tlv.length);
		tlv_type = le32toh(tlv.type);

		len -= sizeof(tlv);
		data += sizeof(tlv);
		tlv_data = data;

		if (len < tlv_len) {
			printf("%s: firmware too short: %zu bytes\n",
			    DEVNAME(sc), len);
			err = EINVAL;
			goto parse_out;
		}

		switch (tlv_type) {
		case IWM_UCODE_TLV_PROBE_MAX_LEN:
			if (tlv_len < sizeof(uint32_t)) {
				err = EINVAL;
				goto parse_out;
			}
			sc->sc_capa_max_probe_len
			    = le32toh(*(uint32_t *)tlv_data);
			if (sc->sc_capa_max_probe_len >
			    IWM_SCAN_OFFLOAD_PROBE_REQ_SIZE) {
				err = EINVAL;
				goto parse_out;
			}
			break;
		case IWM_UCODE_TLV_PAN:
			if (tlv_len) {
				err = EINVAL;
				goto parse_out;
			}
			sc->sc_capaflags |= IWM_UCODE_TLV_FLAGS_PAN;
			break;
		case IWM_UCODE_TLV_FLAGS:
			if (tlv_len < sizeof(uint32_t)) {
				err = EINVAL;
				goto parse_out;
			}
			/*
			 * Apparently there can be many flags, but Linux driver
			 * parses only the first one, and so do we.
			 *
			 * XXX: why does this override IWM_UCODE_TLV_PAN?
			 * Intentional or a bug?  Observations from
			 * current firmware file:
			 *  1) TLV_PAN is parsed first
			 *  2) TLV_FLAGS contains TLV_FLAGS_PAN
			 * ==> this resets TLV_PAN to itself... hnnnk
			 */
			sc->sc_capaflags = le32toh(*(uint32_t *)tlv_data);
			break;
		case IWM_UCODE_TLV_CSCHEME:
			err = iwm_store_cscheme(sc, tlv_data, tlv_len);
			if (err)
				goto parse_out;
			break;
		case IWM_UCODE_TLV_NUM_OF_CPU: {
			uint32_t num_cpu;
			if (tlv_len != sizeof(uint32_t)) {
				err = EINVAL;
				goto parse_out;
			}
			num_cpu = le32toh(*(uint32_t *)tlv_data);
			if (num_cpu < 1 || num_cpu > 2) {
				err = EINVAL;
				goto parse_out;
			}
			break;
		}
		case IWM_UCODE_TLV_SEC_RT:
			err = iwm_firmware_store_section(sc,
			    IWM_UCODE_TYPE_REGULAR, tlv_data, tlv_len);
			if (err)
				goto parse_out;
			break;
		case IWM_UCODE_TLV_SEC_INIT:
			err = iwm_firmware_store_section(sc,
			    IWM_UCODE_TYPE_INIT, tlv_data, tlv_len);
			if (err)
				goto parse_out;
			break;
		case IWM_UCODE_TLV_SEC_WOWLAN:
			err = iwm_firmware_store_section(sc,
			    IWM_UCODE_TYPE_WOW, tlv_data, tlv_len);
			if (err)
				goto parse_out;
			break;
		case IWM_UCODE_TLV_DEF_CALIB:
			if (tlv_len != sizeof(struct iwm_tlv_calib_data)) {
				err = EINVAL;
				goto parse_out;
			}
			err = iwm_set_default_calib(sc, tlv_data);
			if (err)
				goto parse_out;
			break;
		case IWM_UCODE_TLV_PHY_SKU:
			if (tlv_len != sizeof(uint32_t)) {
				err = EINVAL;
				goto parse_out;
			}
			sc->sc_fw_phy_config = le32toh(*(uint32_t *)tlv_data);
			break;

		case IWM_UCODE_TLV_API_CHANGES_SET: {
			struct iwm_ucode_api *api;
			if (tlv_len != sizeof(*api)) {
				err = EINVAL;
				goto parse_out;
			}
			api = (struct iwm_ucode_api *)tlv_data;
			/* Flags may exceed 32 bits in future firmware. */
			if (le32toh(api->api_index) > 0) {
				goto parse_out;
			}
			sc->sc_ucode_api = le32toh(api->api_flags);
			break;
		}

		case IWM_UCODE_TLV_ENABLED_CAPABILITIES: {
			struct iwm_ucode_capa *capa;
			int idx, i;
			if (tlv_len != sizeof(*capa)) {
				err = EINVAL;
				goto parse_out;
			}
			capa = (struct iwm_ucode_capa *)tlv_data;
			idx = le32toh(capa->api_index);
			if (idx >= howmany(IWM_NUM_UCODE_TLV_CAPA, 32)) {
				goto parse_out;
			}
			for (i = 0; i < 32; i++) {
				if ((le32toh(capa->api_capa) & (1 << i)) == 0)
					continue;
				setbit(sc->sc_enabled_capa, i + (32 * idx));
			}
			break;
		}

		case 48: /* undocumented TLV */
		case IWM_UCODE_TLV_SDIO_ADMA_ADDR:
		case IWM_UCODE_TLV_FW_GSCAN_CAPA:
			/* ignore, not used by current driver */
			break;

		case IWM_UCODE_TLV_SEC_RT_USNIFFER:
			err = iwm_firmware_store_section(sc,
			    IWM_UCODE_TYPE_REGULAR_USNIFFER, tlv_data,
			    tlv_len);
			if (err)
				goto parse_out;
			break;

		case IWM_UCODE_TLV_N_SCAN_CHANNELS:
			if (tlv_len != sizeof(uint32_t)) {
				err = EINVAL;
				goto parse_out;
			}
			sc->sc_capa_n_scan_channels =
			  le32toh(*(uint32_t *)tlv_data);
			break;

		case IWM_UCODE_TLV_FW_VERSION:
			if (tlv_len != sizeof(uint32_t) * 3) {
				err = EINVAL;
				goto parse_out;
			}
			snprintf(sc->sc_fwver, sizeof(sc->sc_fwver),
			    "%d.%d.%d",
			    le32toh(((uint32_t *)tlv_data)[0]),
			    le32toh(((uint32_t *)tlv_data)[1]),
			    le32toh(((uint32_t *)tlv_data)[2]));
			break;

		case IWM_UCODE_TLV_FW_MEM_SEG:
			break;

		default:
			err = EINVAL;
			goto parse_out;
		}

		len -= roundup(tlv_len, 4);
		data += roundup(tlv_len, 4);
	}

	KASSERT(err == 0);

 parse_out:
	if (err) {
		printf("%s: firmware parse error %d, "
		    "section type %d\n", DEVNAME(sc), err, tlv_type);
	}

	if (!(sc->sc_capaflags & IWM_UCODE_TLV_FLAGS_PM_CMD_SUPPORT)) {
		printf("%s: device uses unsupported power ops\n", DEVNAME(sc));
		err = ENOTSUP;
	}

 out:
	if (err) {
		fw->fw_status = IWM_FW_STATUS_NONE;
		if (fw->fw_rawdata != NULL)
			iwm_fw_info_free(fw);
	} else
		fw->fw_status = IWM_FW_STATUS_DONE;
	wakeup(&sc->sc_fw);

	return err;
}

uint32_t
iwm_read_prph(struct iwm_softc *sc, uint32_t addr)
{
	iwm_nic_assert_locked(sc);
	IWM_WRITE(sc,
	    IWM_HBUS_TARG_PRPH_RADDR, ((addr & 0x000fffff) | (3 << 24)));
	IWM_BARRIER_READ_WRITE(sc);
	return IWM_READ(sc, IWM_HBUS_TARG_PRPH_RDAT);
}

void
iwm_write_prph(struct iwm_softc *sc, uint32_t addr, uint32_t val)
{
	iwm_nic_assert_locked(sc);
	IWM_WRITE(sc,
	    IWM_HBUS_TARG_PRPH_WADDR, ((addr & 0x000fffff) | (3 << 24)));
	IWM_BARRIER_WRITE(sc);
	IWM_WRITE(sc, IWM_HBUS_TARG_PRPH_WDAT, val);
}

int
iwm_read_mem(struct iwm_softc *sc, uint32_t addr, void *buf, int dwords)
{
	int offs, err = 0;
	uint32_t *vals = buf;

	if (iwm_nic_lock(sc)) {
		IWM_WRITE(sc, IWM_HBUS_TARG_MEM_RADDR, addr);
		for (offs = 0; offs < dwords; offs++)
			vals[offs] = IWM_READ(sc, IWM_HBUS_TARG_MEM_RDAT);
		iwm_nic_unlock(sc);
	} else {
		err = EBUSY;
	}
	return err;
}

int
iwm_write_mem(struct iwm_softc *sc, uint32_t addr, const void *buf, int dwords)
{
	int offs;	
	const uint32_t *vals = buf;

	if (iwm_nic_lock(sc)) {
		IWM_WRITE(sc, IWM_HBUS_TARG_MEM_WADDR, addr);
		/* WADDR auto-increments */
		for (offs = 0; offs < dwords; offs++) {
			uint32_t val = vals ? vals[offs] : 0;
			IWM_WRITE(sc, IWM_HBUS_TARG_MEM_WDAT, val);
		}
		iwm_nic_unlock(sc);
	} else {
		return EBUSY;
	}
	return 0;
}

int
iwm_write_mem32(struct iwm_softc *sc, uint32_t addr, uint32_t val)
{
	return iwm_write_mem(sc, addr, &val, 1);
}

int
iwm_poll_bit(struct iwm_softc *sc, int reg, uint32_t bits, uint32_t mask,
    int timo)
{
	for (;;) {
		if ((IWM_READ(sc, reg) & mask) == (bits & mask)) {
			return 1;
		}
		if (timo < 10) {
			return 0;
		}
		timo -= 10;
		DELAY(10);
	}
}

int
iwm_nic_lock(struct iwm_softc *sc)
{
	if (sc->sc_nic_locks > 0) {
		iwm_nic_assert_locked(sc);
		sc->sc_nic_locks++;
		return 1; /* already locked */
	}

	IWM_SETBITS(sc, IWM_CSR_GP_CNTRL,
	    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);

	if (sc->sc_device_family == IWM_DEVICE_FAMILY_8000)
		DELAY(2);

	if (iwm_poll_bit(sc, IWM_CSR_GP_CNTRL,
	    IWM_CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN,
	    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY
	     | IWM_CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP, 150000)) {
		sc->sc_nic_locks++;
		return 1;
	}

	printf("%s: acquiring device failed\n", DEVNAME(sc));
	return 0;
}

void
iwm_nic_assert_locked(struct iwm_softc *sc)
{
	uint32_t reg = IWM_READ(sc, IWM_CSR_GP_CNTRL);
	if ((reg & IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY) == 0)
		panic("%s: mac clock not ready", DEVNAME(sc));
	if (reg & IWM_CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP)
		panic("%s: mac gone to sleep", DEVNAME(sc));
	if (sc->sc_nic_locks <= 0)
		panic("%s: nic locks counter %d", DEVNAME(sc), sc->sc_nic_locks);
}

void
iwm_nic_unlock(struct iwm_softc *sc)
{
	if (sc->sc_nic_locks > 0) {
		if (--sc->sc_nic_locks == 0)
			IWM_CLRBITS(sc, IWM_CSR_GP_CNTRL,
			    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
	} else
		printf("%s: NIC already unlocked\n", DEVNAME(sc));
}

void
iwm_set_bits_mask_prph(struct iwm_softc *sc, uint32_t reg, uint32_t bits,
    uint32_t mask)
{
	uint32_t val;

	/* XXX: no error path? */
	if (iwm_nic_lock(sc)) {
		val = iwm_read_prph(sc, reg) & mask;
		val |= bits;
		iwm_write_prph(sc, reg, val);
		iwm_nic_unlock(sc);
	}
}

void
iwm_set_bits_prph(struct iwm_softc *sc, uint32_t reg, uint32_t bits)
{
	iwm_set_bits_mask_prph(sc, reg, bits, ~0);
}

void
iwm_clear_bits_prph(struct iwm_softc *sc, uint32_t reg, uint32_t bits)
{
	iwm_set_bits_mask_prph(sc, reg, 0, ~bits);
}

int
iwm_dma_contig_alloc(bus_dma_tag_t tag, struct iwm_dma_info *dma,
    bus_size_t size, bus_size_t alignment)
{
	int nsegs, err;
	caddr_t va;

	dma->tag = tag;
	dma->size = size;

	err = bus_dmamap_create(tag, size, 1, size, 0, BUS_DMA_NOWAIT,
	    &dma->map);
	if (err)
		goto fail;

	err = bus_dmamem_alloc(tag, size, alignment, 0, &dma->seg, 1, &nsegs,
	    BUS_DMA_NOWAIT);
	if (err)
		goto fail;

	err = bus_dmamem_map(tag, &dma->seg, 1, size, &va,
	    BUS_DMA_NOWAIT);
	if (err)
		goto fail;
	dma->vaddr = va;

	err = bus_dmamap_load(tag, dma->map, dma->vaddr, size, NULL,
	    BUS_DMA_NOWAIT);
	if (err)
		goto fail;

	memset(dma->vaddr, 0, size);
	bus_dmamap_sync(tag, dma->map, 0, size, BUS_DMASYNC_PREWRITE);
	dma->paddr = dma->map->dm_segs[0].ds_addr;

	return 0;

fail:	iwm_dma_contig_free(dma);
	return err;
}

void
iwm_dma_contig_free(struct iwm_dma_info *dma)
{
	if (dma->map != NULL) {
		if (dma->vaddr != NULL) {
			bus_dmamap_sync(dma->tag, dma->map, 0, dma->size,
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(dma->tag, dma->map);
			bus_dmamem_unmap(dma->tag, dma->vaddr, dma->size);
			bus_dmamem_free(dma->tag, &dma->seg, 1);
			dma->vaddr = NULL;
		}
		bus_dmamap_destroy(dma->tag, dma->map);
		dma->map = NULL;
	}
}

int
iwm_alloc_rx_ring(struct iwm_softc *sc, struct iwm_rx_ring *ring)
{
	bus_size_t size;
	int i, err;

	ring->cur = 0;

	/* Allocate RX descriptors (256-byte aligned). */
	size = IWM_RX_RING_COUNT * sizeof(uint32_t);
	err = iwm_dma_contig_alloc(sc->sc_dmat, &ring->desc_dma, size, 256);
	if (err) {
		printf("%s: could not allocate RX ring DMA memory\n",
		    DEVNAME(sc));
		goto fail;
	}
	ring->desc = ring->desc_dma.vaddr;

	/* Allocate RX status area (16-byte aligned). */
	err = iwm_dma_contig_alloc(sc->sc_dmat, &ring->stat_dma,
	    sizeof(*ring->stat), 16);
	if (err) {
		printf("%s: could not allocate RX status DMA memory\n",
		    DEVNAME(sc));
		goto fail;
	}
	ring->stat = ring->stat_dma.vaddr;

	for (i = 0; i < IWM_RX_RING_COUNT; i++) {
		struct iwm_rx_data *data = &ring->data[i];

		memset(data, 0, sizeof(*data));
		err = bus_dmamap_create(sc->sc_dmat, IWM_RBUF_SIZE, 1,
		    IWM_RBUF_SIZE, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &data->map);
		if (err) {
			printf("%s: could not create RX buf DMA map\n",
			    DEVNAME(sc));
			goto fail;
		}

		err = iwm_rx_addbuf(sc, IWM_RBUF_SIZE, i);
		if (err)
			goto fail;
	}
	return 0;

fail:	iwm_free_rx_ring(sc, ring);
	return err;
}

void
iwm_disable_rx_dma(struct iwm_softc *sc)
{
	int ntries;

	if (iwm_nic_lock(sc)) {
		IWM_WRITE(sc, IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG, 0);
		for (ntries = 0; ntries < 1000; ntries++) {
			if (IWM_READ(sc, IWM_FH_MEM_RSSR_RX_STATUS_REG) &
			    IWM_FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE)
				break;
			DELAY(10);
		}
		iwm_nic_unlock(sc);
	}
}

void
iwm_reset_rx_ring(struct iwm_softc *sc, struct iwm_rx_ring *ring)
{
	ring->cur = 0;
	bus_dmamap_sync(sc->sc_dmat, ring->stat_dma.map, 0,
	    ring->stat_dma.size, BUS_DMASYNC_PREWRITE);
	memset(ring->stat, 0, sizeof(*ring->stat));
	bus_dmamap_sync(sc->sc_dmat, ring->stat_dma.map, 0,
	    ring->stat_dma.size, BUS_DMASYNC_POSTWRITE);

}

void
iwm_free_rx_ring(struct iwm_softc *sc, struct iwm_rx_ring *ring)
{
	int i;

	iwm_dma_contig_free(&ring->desc_dma);
	iwm_dma_contig_free(&ring->stat_dma);

	for (i = 0; i < IWM_RX_RING_COUNT; i++) {
		struct iwm_rx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}
		if (data->map != NULL)
			bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

int
iwm_alloc_tx_ring(struct iwm_softc *sc, struct iwm_tx_ring *ring, int qid)
{
	bus_addr_t paddr;
	bus_size_t size;
	int i, err;

	ring->qid = qid;
	ring->queued = 0;
	ring->cur = 0;

	/* Allocate TX descriptors (256-byte aligned). */
	size = IWM_TX_RING_COUNT * sizeof (struct iwm_tfd);
	err = iwm_dma_contig_alloc(sc->sc_dmat, &ring->desc_dma, size, 256);
	if (err) {
		printf("%s: could not allocate TX ring DMA memory\n",
		    DEVNAME(sc));
		goto fail;
	}
	ring->desc = ring->desc_dma.vaddr;

	/*
	 * We only use rings 0 through 9 (4 EDCA + cmd) so there is no need
	 * to allocate commands space for other rings.
	 */
	if (qid > IWM_CMD_QUEUE)
		return 0;

	size = IWM_TX_RING_COUNT * sizeof(struct iwm_device_cmd);
	err = iwm_dma_contig_alloc(sc->sc_dmat, &ring->cmd_dma, size, 4);
	if (err) {
		printf("%s: could not allocate cmd DMA memory\n", DEVNAME(sc));
		goto fail;
	}
	ring->cmd = ring->cmd_dma.vaddr;

	paddr = ring->cmd_dma.paddr;
	for (i = 0; i < IWM_TX_RING_COUNT; i++) {
		struct iwm_tx_data *data = &ring->data[i];
		size_t mapsize;

		data->cmd_paddr = paddr;
		data->scratch_paddr = paddr + sizeof(struct iwm_cmd_header)
		    + offsetof(struct iwm_tx_cmd, scratch);
		paddr += sizeof(struct iwm_device_cmd);

		/* FW commands may require more mapped space than packets. */
		if (qid == IWM_CMD_QUEUE)
			mapsize = (sizeof(struct iwm_cmd_header) +
			    IWM_MAX_CMD_PAYLOAD_SIZE);
		else
			mapsize = MCLBYTES;
		err = bus_dmamap_create(sc->sc_dmat, mapsize,
		    IWM_NUM_OF_TBS - 2, mapsize, 0, BUS_DMA_NOWAIT,
		    &data->map);
		if (err) {
			printf("%s: could not create TX buf DMA map\n",
			    DEVNAME(sc));
			goto fail;
		}
	}
	KASSERT(paddr == ring->cmd_dma.paddr + size);
	return 0;

fail:	iwm_free_tx_ring(sc, ring);
	return err;
}

void
iwm_reset_tx_ring(struct iwm_softc *sc, struct iwm_tx_ring *ring)
{
	int i;

	for (i = 0; i < IWM_TX_RING_COUNT; i++) {
		struct iwm_tx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}
	}
	/* Clear TX descriptors. */
	memset(ring->desc, 0, ring->desc_dma.size);
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map, 0,
	    ring->desc_dma.size, BUS_DMASYNC_PREWRITE);
	sc->qfullmsk &= ~(1 << ring->qid);
	/* 7000 family NICs are locked while commands are in progress. */
	if (ring->qid == IWM_CMD_QUEUE && ring->queued > 0) {
		if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000)
			iwm_nic_unlock(sc);
	}
	ring->queued = 0;
	ring->cur = 0;
}

void
iwm_free_tx_ring(struct iwm_softc *sc, struct iwm_tx_ring *ring)
{
	int i;

	iwm_dma_contig_free(&ring->desc_dma);
	iwm_dma_contig_free(&ring->cmd_dma);

	for (i = 0; i < IWM_TX_RING_COUNT; i++) {
		struct iwm_tx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}
		if (data->map != NULL)
			bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

void
iwm_enable_rfkill_int(struct iwm_softc *sc)
{
	sc->sc_intmask = IWM_CSR_INT_BIT_RF_KILL;
	IWM_WRITE(sc, IWM_CSR_INT_MASK, sc->sc_intmask);
}

int
iwm_check_rfkill(struct iwm_softc *sc)
{
	uint32_t v;
	int s;
	int rv;

	s = splnet();

	/*
	 * "documentation" is not really helpful here:
	 *  27:	HW_RF_KILL_SW
	 *	Indicates state of (platform's) hardware RF-Kill switch
	 *
	 * But apparently when it's off, it's on ...
	 */
	v = IWM_READ(sc, IWM_CSR_GP_CNTRL);
	rv = (v & IWM_CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW) == 0;
	if (rv) {
		sc->sc_flags |= IWM_FLAG_RFKILL;
	} else {
		sc->sc_flags &= ~IWM_FLAG_RFKILL;
	}

	splx(s);
	return rv;
}

void
iwm_enable_interrupts(struct iwm_softc *sc)
{
	sc->sc_intmask = IWM_CSR_INI_SET_MASK;
	IWM_WRITE(sc, IWM_CSR_INT_MASK, sc->sc_intmask);
}

void
iwm_restore_interrupts(struct iwm_softc *sc)
{
	IWM_WRITE(sc, IWM_CSR_INT_MASK, sc->sc_intmask);
}

void
iwm_disable_interrupts(struct iwm_softc *sc)
{
	int s = splnet();

	IWM_WRITE(sc, IWM_CSR_INT_MASK, 0);

	/* acknowledge all interrupts */
	IWM_WRITE(sc, IWM_CSR_INT, ~0);
	IWM_WRITE(sc, IWM_CSR_FH_INT_STATUS, ~0);

	splx(s);
}

void
iwm_ict_reset(struct iwm_softc *sc)
{
	iwm_disable_interrupts(sc);

	memset(sc->ict_dma.vaddr, 0, IWM_ICT_SIZE);
	sc->ict_cur = 0;

	/* Set physical address of ICT (4KB aligned). */
	IWM_WRITE(sc, IWM_CSR_DRAM_INT_TBL_REG,
	    IWM_CSR_DRAM_INT_TBL_ENABLE
	    | IWM_CSR_DRAM_INIT_TBL_WRAP_CHECK
	    | IWM_CSR_DRAM_INIT_TBL_WRITE_POINTER
	    | sc->ict_dma.paddr >> IWM_ICT_PADDR_SHIFT);

	/* Switch to ICT interrupt mode in driver. */
	sc->sc_flags |= IWM_FLAG_USE_ICT;

	IWM_WRITE(sc, IWM_CSR_INT, ~0);
	iwm_enable_interrupts(sc);
}

#define IWM_HW_READY_TIMEOUT 50
int
iwm_set_hw_ready(struct iwm_softc *sc)
{
	int ready;

	IWM_SETBITS(sc, IWM_CSR_HW_IF_CONFIG_REG,
	    IWM_CSR_HW_IF_CONFIG_REG_BIT_NIC_READY);

	ready = iwm_poll_bit(sc, IWM_CSR_HW_IF_CONFIG_REG,
	    IWM_CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,
	    IWM_CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,
	    IWM_HW_READY_TIMEOUT);
	if (ready)
		IWM_SETBITS(sc, IWM_CSR_MBOX_SET_REG,
		    IWM_CSR_MBOX_SET_REG_OS_ALIVE);

	return ready;
}
#undef IWM_HW_READY_TIMEOUT

int
iwm_prepare_card_hw(struct iwm_softc *sc)
{
	int t = 0;

	if (iwm_set_hw_ready(sc))
		return 0;

	DELAY(100);

	/* If HW is not ready, prepare the conditions to check again */
	IWM_SETBITS(sc, IWM_CSR_HW_IF_CONFIG_REG,
	    IWM_CSR_HW_IF_CONFIG_REG_PREPARE);

	do {
		if (iwm_set_hw_ready(sc))
			return 0;
		DELAY(200);
		t += 200;
	} while (t < 150000);

	return ETIMEDOUT;
}

void
iwm_apm_config(struct iwm_softc *sc)
{
	pcireg_t reg;

	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag,
	    sc->sc_cap_off + PCI_PCIE_LCSR);
	if (reg & PCI_PCIE_LCSR_ASPM_L1) {
		/* Um the Linux driver prints "Disabling L0S for this one ... */
		IWM_SETBITS(sc, IWM_CSR_GIO_REG,
		    IWM_CSR_GIO_REG_VAL_L0S_ENABLED);
	} else {
		/* ... and "Enabling" here */
		IWM_CLRBITS(sc, IWM_CSR_GIO_REG,
		    IWM_CSR_GIO_REG_VAL_L0S_ENABLED);
	}
}

/*
 * Start up NIC's basic functionality after it has been reset
 * e.g. after platform boot or shutdown.
 * NOTE:  This does not load uCode nor start the embedded processor
 */
int
iwm_apm_init(struct iwm_softc *sc)
{
	int err = 0;

	/* Disable L0S exit timer (platform NMI workaround) */
	if (sc->sc_device_family != IWM_DEVICE_FAMILY_8000)
		IWM_SETBITS(sc, IWM_CSR_GIO_CHICKEN_BITS,
		    IWM_CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER);

	/*
	 * Disable L0s without affecting L1;
	 *  don't wait for ICH L0s (ICH bug W/A)
	 */
	IWM_SETBITS(sc, IWM_CSR_GIO_CHICKEN_BITS,
	    IWM_CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX);

	/* Set FH wait threshold to maximum (HW error during stress W/A) */
	IWM_SETBITS(sc, IWM_CSR_DBG_HPET_MEM_REG, IWM_CSR_DBG_HPET_MEM_REG_VAL);

	/*
	 * Enable HAP INTA (interrupt from management bus) to
	 * wake device's PCI Express link L1a -> L0s
	 */
	IWM_SETBITS(sc, IWM_CSR_HW_IF_CONFIG_REG,
	    IWM_CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A);

	iwm_apm_config(sc);

#if 0 /* not for 7k/8k */
	/* Configure analog phase-lock-loop before activating to D0A */
	if (trans->cfg->base_params->pll_cfg_val)
		IWM_SETBITS(trans, IWM_CSR_ANA_PLL_CFG,
		    trans->cfg->base_params->pll_cfg_val);
#endif

	/*
	 * Set "initialization complete" bit to move adapter from
	 * D0U* --> D0A* (powered-up active) state.
	 */
	IWM_SETBITS(sc, IWM_CSR_GP_CNTRL, IWM_CSR_GP_CNTRL_REG_FLAG_INIT_DONE);

	/*
	 * Wait for clock stabilization; once stabilized, access to
	 * device-internal resources is supported, e.g. iwm_write_prph()
	 * and accesses to uCode SRAM.
	 */
	if (!iwm_poll_bit(sc, IWM_CSR_GP_CNTRL,
	    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
	    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY, 25000)) {
		printf("%s: timeout waiting for clock stabilization\n",
		    DEVNAME(sc));
		err = ETIMEDOUT;
		goto out;
	}

	if (sc->host_interrupt_operation_mode) {
		/*
		 * This is a bit of an abuse - This is needed for 7260 / 3160
		 * only check host_interrupt_operation_mode even if this is
		 * not related to host_interrupt_operation_mode.
		 *
		 * Enable the oscillator to count wake up time for L1 exit. This
		 * consumes slightly more power (100uA) - but allows to be sure
		 * that we wake up from L1 on time.
		 *
		 * This looks weird: read twice the same register, discard the
		 * value, set a bit, and yet again, read that same register
		 * just to discard the value. But that's the way the hardware
		 * seems to like it.
		 */
		if (iwm_nic_lock(sc)) {
			iwm_read_prph(sc, IWM_OSC_CLK);
			iwm_read_prph(sc, IWM_OSC_CLK);
			iwm_nic_unlock(sc);
		}
		iwm_set_bits_prph(sc, IWM_OSC_CLK, IWM_OSC_CLK_FORCE_CONTROL);
		if (iwm_nic_lock(sc)) {
			iwm_read_prph(sc, IWM_OSC_CLK);
			iwm_read_prph(sc, IWM_OSC_CLK);
			iwm_nic_unlock(sc);
		}
	}

	/*
	 * Enable DMA clock and wait for it to stabilize.
	 *
	 * Write to "CLK_EN_REG"; "1" bits enable clocks, while "0" bits
	 * do not disable clocks.  This preserves any hardware bits already
	 * set by default in "CLK_CTRL_REG" after reset.
	 */
	if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000) {
		if (iwm_nic_lock(sc)) {
			iwm_write_prph(sc, IWM_APMG_CLK_EN_REG,
			    IWM_APMG_CLK_VAL_DMA_CLK_RQT);
			iwm_nic_unlock(sc);
		}
		DELAY(20);

		/* Disable L1-Active */
		iwm_set_bits_prph(sc, IWM_APMG_PCIDEV_STT_REG,
		    IWM_APMG_PCIDEV_STT_VAL_L1_ACT_DIS);

		/* Clear the interrupt in APMG if the NIC is in RFKILL */
		if (iwm_nic_lock(sc)) {
			iwm_write_prph(sc, IWM_APMG_RTC_INT_STT_REG,
			    IWM_APMG_RTC_INT_STT_RFKILL);
			iwm_nic_unlock(sc);
		}
	}
 out:
	if (err)
		printf("%s: apm init error %d\n", DEVNAME(sc), err);
	return err;
}

void
iwm_apm_stop(struct iwm_softc *sc)
{
	/* stop device's busmaster DMA activity */
	IWM_SETBITS(sc, IWM_CSR_RESET, IWM_CSR_RESET_REG_FLAG_STOP_MASTER);

	if (!iwm_poll_bit(sc, IWM_CSR_RESET,
	    IWM_CSR_RESET_REG_FLAG_MASTER_DISABLED,
	    IWM_CSR_RESET_REG_FLAG_MASTER_DISABLED, 100))
		printf("%s: timeout waiting for master\n", DEVNAME(sc));
}

int
iwm_start_hw(struct iwm_softc *sc)
{
	int err;

	err = iwm_prepare_card_hw(sc);
	if (err)
		return err;

	/* Reset the entire device */
	IWM_WRITE(sc, IWM_CSR_RESET, IWM_CSR_RESET_REG_FLAG_SW_RESET);
	DELAY(10);

	err = iwm_apm_init(sc);
	if (err)
		return err;

	iwm_enable_rfkill_int(sc);
	iwm_check_rfkill(sc);

	return 0;
}


void
iwm_stop_device(struct iwm_softc *sc)
{
	int chnl, ntries;
	int qid;

	iwm_disable_interrupts(sc);
	sc->sc_flags &= ~IWM_FLAG_USE_ICT;

	/* Stop all DMA channels. */
	if (iwm_nic_lock(sc)) {
		/* Deactivate TX scheduler. */
		iwm_write_prph(sc, IWM_SCD_TXFACT, 0);

		for (chnl = 0; chnl < IWM_FH_TCSR_CHNL_NUM; chnl++) {
			IWM_WRITE(sc,
			    IWM_FH_TCSR_CHNL_TX_CONFIG_REG(chnl), 0);
			for (ntries = 0; ntries < 200; ntries++) {
				uint32_t r;

				r = IWM_READ(sc, IWM_FH_TSSR_TX_STATUS_REG);
				if (r & IWM_FH_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(
				    chnl))
					break;
				DELAY(20);
			}
		}
		iwm_nic_unlock(sc);
	}
	iwm_disable_rx_dma(sc);

	iwm_reset_rx_ring(sc, &sc->rxq);

	for (qid = 0; qid < nitems(sc->txq); qid++)
		iwm_reset_tx_ring(sc, &sc->txq[qid]);

	if (iwm_nic_lock(sc)) {
		/* Power-down device's busmaster DMA clocks */
		iwm_write_prph(sc, IWM_APMG_CLK_DIS_REG,
		    IWM_APMG_CLK_VAL_DMA_CLK_RQT);
		iwm_nic_unlock(sc);
	}
	DELAY(5);

	/* Make sure (redundant) we've released our request to stay awake */
	IWM_CLRBITS(sc, IWM_CSR_GP_CNTRL,
	    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
	if (sc->sc_nic_locks > 0)
		printf("%s: %d active NIC locks forcefully cleared\n",
		    DEVNAME(sc), sc->sc_nic_locks);
	sc->sc_nic_locks = 0;

	/* Stop the device, and put it in low power state */
	iwm_apm_stop(sc);

	/* 
	 * Upon stop, the APM issues an interrupt if HW RF kill is set.
	 * Clear the interrupt again.
	 */
	iwm_disable_interrupts(sc);

	/* Reset the on-board processor. */
	IWM_WRITE(sc, IWM_CSR_RESET, IWM_CSR_RESET_REG_FLAG_SW_RESET);

	/* Even though we stop the HW we still want the RF kill interrupt. */
	iwm_enable_rfkill_int(sc);
	iwm_check_rfkill(sc);
}

void
iwm_nic_config(struct iwm_softc *sc)
{
	uint8_t radio_cfg_type, radio_cfg_step, radio_cfg_dash;
	uint32_t reg_val = 0;

	radio_cfg_type = (sc->sc_fw_phy_config & IWM_FW_PHY_CFG_RADIO_TYPE) >>
	    IWM_FW_PHY_CFG_RADIO_TYPE_POS;
	radio_cfg_step = (sc->sc_fw_phy_config & IWM_FW_PHY_CFG_RADIO_STEP) >>
	    IWM_FW_PHY_CFG_RADIO_STEP_POS;
	radio_cfg_dash = (sc->sc_fw_phy_config & IWM_FW_PHY_CFG_RADIO_DASH) >>
	    IWM_FW_PHY_CFG_RADIO_DASH_POS;

	reg_val |= IWM_CSR_HW_REV_STEP(sc->sc_hw_rev) <<
	    IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_STEP;
	reg_val |= IWM_CSR_HW_REV_DASH(sc->sc_hw_rev) <<
	    IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_DASH;

	/* radio configuration */
	reg_val |= radio_cfg_type << IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_TYPE;
	reg_val |= radio_cfg_step << IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_STEP;
	reg_val |= radio_cfg_dash << IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_DASH;

	IWM_WRITE(sc, IWM_CSR_HW_IF_CONFIG_REG, reg_val);

	/*
	 * W/A : NIC is stuck in a reset state after Early PCIe power off
	 * (PCIe power is lost before PERST# is asserted), causing ME FW
	 * to lose ownership and not being able to obtain it back.
	 */
	if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000)
		iwm_set_bits_mask_prph(sc, IWM_APMG_PS_CTRL_REG,
		    IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS,
		    ~IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS);
}

int
iwm_nic_rx_init(struct iwm_softc *sc)
{
	memset(sc->rxq.stat, 0, sizeof(*sc->rxq.stat));

	iwm_disable_rx_dma(sc);

	if (!iwm_nic_lock(sc))
		return EBUSY;

	/* reset and flush pointers */
	IWM_WRITE(sc, IWM_FH_MEM_RCSR_CHNL0_RBDCB_WPTR, 0);
	IWM_WRITE(sc, IWM_FH_MEM_RCSR_CHNL0_FLUSH_RB_REQ, 0);
	IWM_WRITE(sc, IWM_FH_RSCSR_CHNL0_RDPTR, 0);
	IWM_WRITE(sc, IWM_FH_RSCSR_CHNL0_RBDCB_WPTR_REG, 0);

	/* Set physical address of RX ring (256-byte aligned). */
	IWM_WRITE(sc,
	    IWM_FH_RSCSR_CHNL0_RBDCB_BASE_REG, sc->rxq.desc_dma.paddr >> 8);

	/* Set physical address of RX status (16-byte aligned). */
	IWM_WRITE(sc,
	    IWM_FH_RSCSR_CHNL0_STTS_WPTR_REG, sc->rxq.stat_dma.paddr >> 4);

	/* Enable RX. */
	IWM_WRITE(sc, IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG,
	    IWM_FH_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL		|
	    IWM_FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY		|  /* HW bug */
	    IWM_FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL	|
	    IWM_FH_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK	|
	    (IWM_RX_RB_TIMEOUT << IWM_FH_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS) |
	    IWM_FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K		|
	    IWM_RX_QUEUE_SIZE_LOG << IWM_FH_RCSR_RX_CONFIG_RBDCB_SIZE_POS);

	IWM_WRITE_1(sc, IWM_CSR_INT_COALESCING, IWM_HOST_INT_TIMEOUT_DEF);

	/* W/A for interrupt coalescing bug in 7260 and 3160 */
	if (sc->host_interrupt_operation_mode)
		IWM_SETBITS(sc, IWM_CSR_INT_COALESCING, IWM_HOST_INT_OPER_MODE);

	/*
	 * This value should initially be 0 (before preparing any RBs),
	 * and should be 8 after preparing the first 8 RBs (for example).
	 */
	IWM_WRITE(sc, IWM_FH_RSCSR_CHNL0_WPTR, 8);

	iwm_nic_unlock(sc);

	return 0;
}

int
iwm_nic_tx_init(struct iwm_softc *sc)
{
	int qid;

	if (!iwm_nic_lock(sc))
		return EBUSY;

	/* Deactivate TX scheduler. */
	iwm_write_prph(sc, IWM_SCD_TXFACT, 0);

	/* Set physical address of "keep warm" page (16-byte aligned). */
	IWM_WRITE(sc, IWM_FH_KW_MEM_ADDR_REG, sc->kw_dma.paddr >> 4);

	for (qid = 0; qid < nitems(sc->txq); qid++) {
		struct iwm_tx_ring *txq = &sc->txq[qid];

		/* Set physical address of TX ring (256-byte aligned). */
		IWM_WRITE(sc, IWM_FH_MEM_CBBC_QUEUE(qid),
		    txq->desc_dma.paddr >> 8);
	}

	iwm_write_prph(sc, IWM_SCD_GP_CTRL, IWM_SCD_GP_CTRL_AUTO_ACTIVE_MODE);

	iwm_nic_unlock(sc);

	return 0;
}

int
iwm_nic_init(struct iwm_softc *sc)
{
	int err;

	iwm_apm_init(sc);
	if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000)
		iwm_set_bits_mask_prph(sc, IWM_APMG_PS_CTRL_REG,
		    IWM_APMG_PS_CTRL_VAL_PWR_SRC_VMAIN,
		    ~IWM_APMG_PS_CTRL_MSK_PWR_SRC);

	iwm_nic_config(sc);

	err = iwm_nic_rx_init(sc);
	if (err)
		return err;

	err = iwm_nic_tx_init(sc);
	if (err)
		return err;

	IWM_SETBITS(sc, IWM_CSR_MAC_SHADOW_REG_CTRL, 0x800fffff);

	return 0;
}

const uint8_t iwm_ac_to_tx_fifo[] = {
	IWM_TX_FIFO_VO,
	IWM_TX_FIFO_VI,
	IWM_TX_FIFO_BE,
	IWM_TX_FIFO_BK,
};

int
iwm_enable_txq(struct iwm_softc *sc, int sta_id, int qid, int fifo)
{
	iwm_nic_assert_locked(sc);

	IWM_WRITE(sc, IWM_HBUS_TARG_WRPTR, qid << 8 | 0);

	if (qid == IWM_CMD_QUEUE) {
		iwm_write_prph(sc, IWM_SCD_QUEUE_STATUS_BITS(qid),
		    (0 << IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE)
		    | (1 << IWM_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));

		iwm_clear_bits_prph(sc, IWM_SCD_AGGR_SEL, (1 << qid));

		iwm_write_prph(sc, IWM_SCD_QUEUE_RDPTR(qid), 0);

		iwm_write_mem32(sc,
		    sc->sched_base + IWM_SCD_CONTEXT_QUEUE_OFFSET(qid), 0);

		/* Set scheduler window size and frame limit. */
		iwm_write_mem32(sc,
		    sc->sched_base + IWM_SCD_CONTEXT_QUEUE_OFFSET(qid) +
		    sizeof(uint32_t),
		    ((IWM_FRAME_LIMIT << IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_POS) &
		    IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_MSK) |
		    ((IWM_FRAME_LIMIT
		        << IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &
		    IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK));

		iwm_write_prph(sc, IWM_SCD_QUEUE_STATUS_BITS(qid),
		    (1 << IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE) |
		    (fifo << IWM_SCD_QUEUE_STTS_REG_POS_TXF) |
		    (1 << IWM_SCD_QUEUE_STTS_REG_POS_WSL) |
		    IWM_SCD_QUEUE_STTS_REG_MSK);
	} else {
		struct iwm_scd_txq_cfg_cmd cmd;
		int err;

		memset(&cmd, 0, sizeof(cmd));
		cmd.scd_queue = qid;
		cmd.enable = 1;
		cmd.sta_id = sta_id;
		cmd.tx_fifo = fifo;
		cmd.aggregate = 0;
		cmd.window = IWM_FRAME_LIMIT;

		err = iwm_send_cmd_pdu(sc, IWM_SCD_QUEUE_CFG, 0,
		    sizeof(cmd), &cmd);
		if (err)
			return err;
	}

	iwm_write_prph(sc, IWM_SCD_EN_CTRL,
	    iwm_read_prph(sc, IWM_SCD_EN_CTRL) | qid);

	return 0;
}

int
iwm_post_alive(struct iwm_softc *sc)
{
	int nwords;
	int err, chnl;
	uint32_t base;

	if (!iwm_nic_lock(sc))
		return EBUSY;

	base = iwm_read_prph(sc, IWM_SCD_SRAM_BASE_ADDR);

	iwm_ict_reset(sc);

	/* Clear TX scheduler state in SRAM. */
	nwords = (IWM_SCD_TRANS_TBL_MEM_UPPER_BOUND -
	    IWM_SCD_CONTEXT_MEM_LOWER_BOUND)
	    / sizeof(uint32_t);
	err = iwm_write_mem(sc,
	    sc->sched_base + IWM_SCD_CONTEXT_MEM_LOWER_BOUND,
	    NULL, nwords);
	if (err)
		goto out;

	/* Set physical address of TX scheduler rings (1KB aligned). */
	iwm_write_prph(sc, IWM_SCD_DRAM_BASE_ADDR, sc->sched_dma.paddr >> 10);

	iwm_write_prph(sc, IWM_SCD_CHAINEXT_EN, 0);

	/* enable command channel */
	err = iwm_enable_txq(sc, 0 /* unused */, IWM_CMD_QUEUE, 7);
	if (err)
		goto out;

	/* Activate TX scheduler. */
	iwm_write_prph(sc, IWM_SCD_TXFACT, 0xff);

	/* Enable DMA channels. */
	for (chnl = 0; chnl < IWM_FH_TCSR_CHNL_NUM; chnl++) {
		IWM_WRITE(sc, IWM_FH_TCSR_CHNL_TX_CONFIG_REG(chnl),
		    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |
		    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE);
	}

	IWM_SETBITS(sc, IWM_FH_TX_CHICKEN_BITS_REG,
	    IWM_FH_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN);

	/* Enable L1-Active */
	if (sc->sc_device_family != IWM_DEVICE_FAMILY_8000)
		iwm_clear_bits_prph(sc, IWM_APMG_PCIDEV_STT_REG,
		    IWM_APMG_PCIDEV_STT_VAL_L1_ACT_DIS);

 out:
 	iwm_nic_unlock(sc);
	return err;
}

struct iwm_phy_db_entry *
iwm_phy_db_get_section(struct iwm_softc *sc, uint16_t type, uint16_t chg_id)
{
	struct iwm_phy_db *phy_db = &sc->sc_phy_db;

	if (type >= IWM_PHY_DB_MAX)
		return NULL;

	switch (type) {
	case IWM_PHY_DB_CFG:
		return &phy_db->cfg;
	case IWM_PHY_DB_CALIB_NCH:
		return &phy_db->calib_nch;
	case IWM_PHY_DB_CALIB_CHG_PAPD:
		if (chg_id >= IWM_NUM_PAPD_CH_GROUPS)
			return NULL;
		return &phy_db->calib_ch_group_papd[chg_id];
	case IWM_PHY_DB_CALIB_CHG_TXP:
		if (chg_id >= IWM_NUM_TXP_CH_GROUPS)
			return NULL;
		return &phy_db->calib_ch_group_txp[chg_id];
	default:
		return NULL;
	}
	return NULL;
}

int
iwm_phy_db_set_section(struct iwm_softc *sc,
    struct iwm_calib_res_notif_phy_db *phy_db_notif)
{
	uint16_t type = le16toh(phy_db_notif->type);
	uint16_t size  = le16toh(phy_db_notif->length);
	struct iwm_phy_db_entry *entry;
	uint16_t chg_id = 0;

	if (type == IWM_PHY_DB_CALIB_CHG_PAPD ||
	    type == IWM_PHY_DB_CALIB_CHG_TXP)
		chg_id = le16toh(*(uint16_t *)phy_db_notif->data);

	entry = iwm_phy_db_get_section(sc, type, chg_id);
	if (!entry)
		return EINVAL;

	if (entry->data)
		free(entry->data, M_DEVBUF, entry->size);
	entry->data = malloc(size, M_DEVBUF, M_NOWAIT);
	if (!entry->data) {
		entry->size = 0;
		return ENOMEM;
	}
	memcpy(entry->data, phy_db_notif->data, size);
	entry->size = size;

	return 0;
}

int
iwm_is_valid_channel(uint16_t ch_id)
{
	if (ch_id <= 14 ||
	    (36 <= ch_id && ch_id <= 64 && ch_id % 4 == 0) ||
	    (100 <= ch_id && ch_id <= 140 && ch_id % 4 == 0) ||
	    (145 <= ch_id && ch_id <= 165 && ch_id % 4 == 1))
		return 1;
	return 0;
}

uint8_t
iwm_ch_id_to_ch_index(uint16_t ch_id)
{
	if (!iwm_is_valid_channel(ch_id))
		return 0xff;

	if (ch_id <= 14)
		return ch_id - 1;
	if (ch_id <= 64)
		return (ch_id + 20) / 4;
	if (ch_id <= 140)
		return (ch_id - 12) / 4;
	return (ch_id - 13) / 4;
}


uint16_t
iwm_channel_id_to_papd(uint16_t ch_id)
{
	if (!iwm_is_valid_channel(ch_id))
		return 0xff;

	if (1 <= ch_id && ch_id <= 14)
		return 0;
	if (36 <= ch_id && ch_id <= 64)
		return 1;
	if (100 <= ch_id && ch_id <= 140)
		return 2;
	return 3;
}

uint16_t
iwm_channel_id_to_txp(struct iwm_softc *sc, uint16_t ch_id)
{
	struct iwm_phy_db *phy_db = &sc->sc_phy_db;
	struct iwm_phy_db_chg_txp *txp_chg;
	int i;
	uint8_t ch_index = iwm_ch_id_to_ch_index(ch_id);

	if (ch_index == 0xff)
		return 0xff;

	for (i = 0; i < IWM_NUM_TXP_CH_GROUPS; i++) {
		txp_chg = (void *)phy_db->calib_ch_group_txp[i].data;
		if (!txp_chg)
			return 0xff;
		/*
		 * Looking for the first channel group the max channel
		 * of which is higher than the requested channel.
		 */
		if (le16toh(txp_chg->max_channel_idx) >= ch_index)
			return i;
	}
	return 0xff;
}

int
iwm_phy_db_get_section_data(struct iwm_softc *sc, uint32_t type, uint8_t **data,
    uint16_t *size, uint16_t ch_id)
{
	struct iwm_phy_db_entry *entry;
	uint16_t ch_group_id = 0;

	if (type == IWM_PHY_DB_CALIB_CHG_PAPD)
		ch_group_id = iwm_channel_id_to_papd(ch_id);
	else if (type == IWM_PHY_DB_CALIB_CHG_TXP)
		ch_group_id = iwm_channel_id_to_txp(sc, ch_id);

	entry = iwm_phy_db_get_section(sc, type, ch_group_id);
	if (!entry)
		return EINVAL;

	*data = entry->data;
	*size = entry->size;

	return 0;
}

int
iwm_send_phy_db_cmd(struct iwm_softc *sc, uint16_t type, uint16_t length,
    void *data)
{
	struct iwm_phy_db_cmd phy_db_cmd;
	struct iwm_host_cmd cmd = {
		.id = IWM_PHY_DB_CMD,
		.flags = IWM_CMD_ASYNC,
	};

	phy_db_cmd.type = le16toh(type);
	phy_db_cmd.length = le16toh(length);

	cmd.data[0] = &phy_db_cmd;
	cmd.len[0] = sizeof(struct iwm_phy_db_cmd);
	cmd.data[1] = data;
	cmd.len[1] = length;

	return iwm_send_cmd(sc, &cmd);
}

int
iwm_phy_db_send_all_channel_groups(struct iwm_softc *sc, uint16_t type,
    uint8_t max_ch_groups)
{
	uint16_t i;
	int err;
	struct iwm_phy_db_entry *entry;

	for (i = 0; i < max_ch_groups; i++) {
		entry = iwm_phy_db_get_section(sc, type, i);
		if (!entry)
			return EINVAL;

		if (!entry->size)
			continue;

		err = iwm_send_phy_db_cmd(sc, type, entry->size, entry->data);
		if (err)
			return err;

		DELAY(1000);
	}

	return 0;
}

int
iwm_send_phy_db_data(struct iwm_softc *sc)
{
	uint8_t *data = NULL;
	uint16_t size = 0;
	int err;

	err = iwm_phy_db_get_section_data(sc, IWM_PHY_DB_CFG, &data, &size, 0);
	if (err)
		return err;

	err = iwm_send_phy_db_cmd(sc, IWM_PHY_DB_CFG, size, data);
	if (err)
		return err;

	err = iwm_phy_db_get_section_data(sc, IWM_PHY_DB_CALIB_NCH,
	    &data, &size, 0);
	if (err)
		return err;

	err = iwm_send_phy_db_cmd(sc, IWM_PHY_DB_CALIB_NCH, size, data);
	if (err)
		return err;

	err = iwm_phy_db_send_all_channel_groups(sc,
	    IWM_PHY_DB_CALIB_CHG_PAPD, IWM_NUM_PAPD_CH_GROUPS);
	if (err)
		return err;

	err = iwm_phy_db_send_all_channel_groups(sc,
	    IWM_PHY_DB_CALIB_CHG_TXP, IWM_NUM_TXP_CH_GROUPS);
	if (err)
		return err;

	return 0;
}

/*
 * For the high priority TE use a time event type that has similar priority to
 * the FW's action scan priority.
 */
#define IWM_ROC_TE_TYPE_NORMAL IWM_TE_P2P_DEVICE_DISCOVERABLE
#define IWM_ROC_TE_TYPE_MGMT_TX IWM_TE_P2P_CLIENT_ASSOC

/* used to convert from time event API v2 to v1 */
#define IWM_TE_V2_DEP_POLICY_MSK (IWM_TE_V2_DEP_OTHER | IWM_TE_V2_DEP_TSF |\
			     IWM_TE_V2_EVENT_SOCIOPATHIC)
static inline uint16_t
iwm_te_v2_get_notify(uint16_t policy)
{
	return le16toh(policy) & IWM_TE_V2_NOTIF_MSK;
}

static inline uint16_t
iwm_te_v2_get_dep_policy(uint16_t policy)
{
	return (le16toh(policy) & IWM_TE_V2_DEP_POLICY_MSK) >>
		IWM_TE_V2_PLACEMENT_POS;
}

static inline uint16_t
iwm_te_v2_get_absence(uint16_t policy)
{
	return (le16toh(policy) & IWM_TE_V2_ABSENCE) >> IWM_TE_V2_ABSENCE_POS;
}

void
iwm_te_v2_to_v1(const struct iwm_time_event_cmd_v2 *cmd_v2,
    struct iwm_time_event_cmd_v1 *cmd_v1)
{
	cmd_v1->id_and_color = cmd_v2->id_and_color;
	cmd_v1->action = cmd_v2->action;
	cmd_v1->id = cmd_v2->id;
	cmd_v1->apply_time = cmd_v2->apply_time;
	cmd_v1->max_delay = cmd_v2->max_delay;
	cmd_v1->depends_on = cmd_v2->depends_on;
	cmd_v1->interval = cmd_v2->interval;
	cmd_v1->duration = cmd_v2->duration;
	if (cmd_v2->repeat == IWM_TE_V2_REPEAT_ENDLESS)
		cmd_v1->repeat = htole32(IWM_TE_V1_REPEAT_ENDLESS);
	else
		cmd_v1->repeat = htole32(cmd_v2->repeat);
	cmd_v1->max_frags = htole32(cmd_v2->max_frags);
	cmd_v1->interval_reciprocal = 0; /* unused */

	cmd_v1->dep_policy = htole32(iwm_te_v2_get_dep_policy(cmd_v2->policy));
	cmd_v1->is_present = htole32(!iwm_te_v2_get_absence(cmd_v2->policy));
	cmd_v1->notify = htole32(iwm_te_v2_get_notify(cmd_v2->policy));
}

int
iwm_send_time_event_cmd(struct iwm_softc *sc,
    const struct iwm_time_event_cmd_v2 *cmd)
{
	struct iwm_time_event_cmd_v1 cmd_v1;

	if (sc->sc_capaflags & IWM_UCODE_TLV_FLAGS_TIME_EVENT_API_V2)
		return iwm_send_cmd_pdu(sc, IWM_TIME_EVENT_CMD,
		    0, sizeof(*cmd), cmd);

	iwm_te_v2_to_v1(cmd, &cmd_v1);
	return iwm_send_cmd_pdu(sc, IWM_TIME_EVENT_CMD, 0,
	    sizeof(cmd_v1), &cmd_v1);
}

void
iwm_protect_session(struct iwm_softc *sc, struct iwm_node *in,
    uint32_t duration, uint32_t max_delay)
{
	struct iwm_time_event_cmd_v2 time_cmd;

	memset(&time_cmd, 0, sizeof(time_cmd));

	time_cmd.action = htole32(IWM_FW_CTXT_ACTION_ADD);
	time_cmd.id_and_color =
	    htole32(IWM_FW_CMD_ID_AND_COLOR(in->in_id, in->in_color));
	time_cmd.id = htole32(IWM_TE_BSS_STA_AGGRESSIVE_ASSOC);

	time_cmd.apply_time = htole32(0);

	time_cmd.max_frags = IWM_TE_V2_FRAG_NONE;
	time_cmd.max_delay = htole32(max_delay);
	/* TODO: why do we need to interval = bi if it is not periodic? */
	time_cmd.interval = htole32(1);
	time_cmd.duration = htole32(duration);
	time_cmd.repeat = 1;
	time_cmd.policy
	    = htole16(IWM_TE_V2_NOTIF_HOST_EVENT_START |
	        IWM_TE_V2_NOTIF_HOST_EVENT_END |
		IWM_T2_V2_START_IMMEDIATELY);

	iwm_send_time_event_cmd(sc, &time_cmd);
}

/*
 * NVM read access and content parsing.  We do not support
 * external NVM or writing NVM.
 */

/* list of NVM sections we are allowed/need to read */
const int iwm_nvm_to_read[] = {
	IWM_NVM_SECTION_TYPE_HW,
	IWM_NVM_SECTION_TYPE_SW,
	IWM_NVM_SECTION_TYPE_REGULATORY,
	IWM_NVM_SECTION_TYPE_CALIBRATION,
	IWM_NVM_SECTION_TYPE_PRODUCTION,
	IWM_NVM_SECTION_TYPE_HW_8000,
	IWM_NVM_SECTION_TYPE_MAC_OVERRIDE,
	IWM_NVM_SECTION_TYPE_PHY_SKU,
};

#define IWM_NVM_DEFAULT_CHUNK_SIZE	(2*1024)
#define IWM_MAX_NVM_SECTION_SIZE	8192

#define IWM_NVM_WRITE_OPCODE 1
#define IWM_NVM_READ_OPCODE 0

int
iwm_nvm_read_chunk(struct iwm_softc *sc, uint16_t section, uint16_t offset,
    uint16_t length, uint8_t *data, uint16_t *len)
{
	offset = 0;
	struct iwm_nvm_access_cmd nvm_access_cmd = {
		.offset = htole16(offset),
		.length = htole16(length),
		.type = htole16(section),
		.op_code = IWM_NVM_READ_OPCODE,
	};
	struct iwm_nvm_access_resp *nvm_resp;
	struct iwm_rx_packet *pkt;
	struct iwm_host_cmd cmd = {
		.id = IWM_NVM_ACCESS_CMD,
		.flags = (IWM_CMD_WANT_SKB | IWM_CMD_SEND_IN_RFKILL),
		.data = { &nvm_access_cmd, },
	};
	int err, offset_read;
	size_t bytes_read;
	uint8_t *resp_data;

	cmd.len[0] = sizeof(struct iwm_nvm_access_cmd);

	err = iwm_send_cmd(sc, &cmd);
	if (err)
		return err;

	pkt = cmd.resp_pkt;
	if (pkt->hdr.flags & IWM_CMD_FAILED_MSK) {
		err = EIO;
		goto exit;
	}

	/* Extract NVM response */
	nvm_resp = (void *)pkt->data;

	err = le16toh(nvm_resp->status);
	bytes_read = le16toh(nvm_resp->length);
	offset_read = le16toh(nvm_resp->offset);
	resp_data = nvm_resp->data;
	if (err) {
		err = EINVAL;
		goto exit;
	}

	if (offset_read != offset) {
		err = EINVAL;
		goto exit;
	}

	if (bytes_read > length) {
		err = EINVAL;
		goto exit;
	}

	memcpy(data + offset, resp_data, bytes_read);
	*len = bytes_read;

 exit:
	iwm_free_resp(sc, &cmd);
	return err;
}

/*
 * Reads an NVM section completely.
 * NICs prior to 7000 family doesn't have a real NVM, but just read
 * section 0 which is the EEPROM. Because the EEPROM reading is unlimited
 * by uCode, we need to manually check in this case that we don't
 * overflow and try to read more than the EEPROM size.
 */
int
iwm_nvm_read_section(struct iwm_softc *sc, uint16_t section, uint8_t *data,
    uint16_t *len, size_t max_len)
{
	uint16_t chunklen, seglen;
	int err = 0;

	chunklen = seglen = IWM_NVM_DEFAULT_CHUNK_SIZE;
	*len = 0;

	/* Read NVM chunks until exhausted (reading less than requested) */
	while (seglen == chunklen && *len < max_len) {
		err = iwm_nvm_read_chunk(sc,
		    section, *len, chunklen, data, &seglen);
		if (err)
			return err;

		*len += seglen;
	}

	return err;
}

uint8_t
iwm_fw_valid_tx_ant(struct iwm_softc *sc)
{
	uint8_t tx_ant;

	tx_ant = ((sc->sc_fw_phy_config & IWM_FW_PHY_CFG_TX_CHAIN)
	    >> IWM_FW_PHY_CFG_TX_CHAIN_POS);

	if (sc->sc_nvm.valid_tx_ant)
		tx_ant &= sc->sc_nvm.valid_tx_ant;

	return tx_ant;
}

uint8_t
iwm_fw_valid_rx_ant(struct iwm_softc *sc)
{
	uint8_t rx_ant;

	rx_ant = ((sc->sc_fw_phy_config & IWM_FW_PHY_CFG_RX_CHAIN)
	    >> IWM_FW_PHY_CFG_RX_CHAIN_POS);

	if (sc->sc_nvm.valid_rx_ant)
		rx_ant &= sc->sc_nvm.valid_rx_ant;

	return rx_ant;
}

void
iwm_init_channel_map(struct iwm_softc *sc, const uint16_t * const nvm_ch_flags,
    const uint8_t *nvm_channels, size_t nchan)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_nvm_data *data = &sc->sc_nvm;
	int ch_idx;
	struct ieee80211_channel *channel;
	uint16_t ch_flags;
	int is_5ghz;
	int flags, hw_value;

	for (ch_idx = 0; ch_idx < nchan; ch_idx++) {
		ch_flags = le16_to_cpup(nvm_ch_flags + ch_idx);

		if (ch_idx >= IWM_NUM_2GHZ_CHANNELS &&
		    !data->sku_cap_band_52GHz_enable)
			ch_flags &= ~IWM_NVM_CHANNEL_VALID;

		if (!(ch_flags & IWM_NVM_CHANNEL_VALID))
			continue;

		hw_value = nvm_channels[ch_idx];
		channel = &ic->ic_channels[hw_value];

		is_5ghz = ch_idx >= IWM_NUM_2GHZ_CHANNELS;
		if (!is_5ghz) {
			flags = IEEE80211_CHAN_2GHZ;
			channel->ic_flags
			    = IEEE80211_CHAN_CCK
			    | IEEE80211_CHAN_OFDM
			    | IEEE80211_CHAN_DYN
			    | IEEE80211_CHAN_2GHZ;
		} else {
			flags = IEEE80211_CHAN_5GHZ;
			channel->ic_flags =
			    IEEE80211_CHAN_A;
		}
		channel->ic_freq = ieee80211_ieee2mhz(hw_value, flags);

		if (!(ch_flags & IWM_NVM_CHANNEL_ACTIVE))
			channel->ic_flags |= IEEE80211_CHAN_PASSIVE;

		if (data->sku_cap_11n_enable)
			channel->ic_flags |= IEEE80211_CHAN_HT;
	}
}

void
iwm_setup_ht_rates(struct iwm_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t rx_ant;

	/* TX is supported with the same MCS as RX. */
	ic->ic_tx_mcs_set = IEEE80211_TX_MCS_SET_DEFINED;

	ic->ic_sup_mcs[0] = 0xff;		/* MCS 0-7 */

	if (sc->sc_nvm.sku_cap_mimo_disable)
		return;

	rx_ant = iwm_fw_valid_rx_ant(sc);
	if ((rx_ant & IWM_ANT_AB) == IWM_ANT_AB ||
	    (rx_ant & IWM_ANT_BC) == IWM_ANT_BC)
		ic->ic_sup_mcs[1] = 0xff;	/* MCS 8-15 */
}

#define IWM_MAX_RX_BA_SESSIONS 16

void
iwm_sta_rx_agg(struct iwm_softc *sc, struct ieee80211_node *ni, uint8_t tid,
    uint16_t ssn, int start)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_add_sta_cmd_v7 cmd;
	struct iwm_node *in = (void *)ni;
	int err, s;
	uint32_t status;

	if (start && sc->sc_rx_ba_sessions >= IWM_MAX_RX_BA_SESSIONS) {
		ieee80211_addba_req_refuse(ic, ni, tid);
		return;
	}

	memset(&cmd, 0, sizeof(cmd));

	cmd.sta_id = IWM_STATION_ID;
	cmd.mac_id_n_color
	    = htole32(IWM_FW_CMD_ID_AND_COLOR(in->in_id, in->in_color));
	cmd.add_modify = IWM_STA_MODE_MODIFY;

	if (start) {
		cmd.add_immediate_ba_tid = (uint8_t)tid;
		cmd.add_immediate_ba_ssn = ssn;
	} else {
		cmd.remove_immediate_ba_tid = (uint8_t)tid;
	}
	cmd.modify_mask = start ? IWM_STA_MODIFY_ADD_BA_TID :
	    IWM_STA_MODIFY_REMOVE_BA_TID;

	status = IWM_ADD_STA_SUCCESS;
	err = iwm_send_cmd_pdu_status(sc, IWM_ADD_STA, sizeof(cmd), &cmd,
	    &status);

	s = splnet();
	if (err == 0 && status == IWM_ADD_STA_SUCCESS) {
		if (start) {
			sc->sc_rx_ba_sessions++;
			ieee80211_addba_req_accept(ic, ni, tid);
		} else if (sc->sc_rx_ba_sessions > 0)
			sc->sc_rx_ba_sessions--;
	} else if (start)
		ieee80211_addba_req_refuse(ic, ni, tid);

	splx(s);
}

void
iwm_htprot_task(void *arg)
{
	struct iwm_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_node *in = (void *)ic->ic_bss;
	int err;

	/* This call updates HT protection based on in->in_ni.ni_htop1. */
	err = iwm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY, 1);
	if (err)
		printf("%s: could not change HT protection: error %d\n",
		    DEVNAME(sc), err);
}

/*
 * This function is called by upper layer when HT protection settings in
 * beacons have changed.
 */
void
iwm_update_htprot(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct iwm_softc *sc = ic->ic_softc;

	/* assumes that ni == ic->ic_bss */
	task_add(systq, &sc->htprot_task);
}

void
iwm_ba_task(void *arg)
{
	struct iwm_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	
	if (sc->ba_start)
		iwm_sta_rx_agg(sc, ni, sc->ba_tid, sc->ba_ssn, 1);
	else
		iwm_sta_rx_agg(sc, ni, sc->ba_tid, 0, 0);
}

/*
 * This function is called by upper layer when an ADDBA request is received
 * from another STA and before the ADDBA response is sent.
 */
int
iwm_ampdu_rx_start(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];
	struct iwm_softc *sc = IC2IFP(ic)->if_softc;

	if (sc->sc_rx_ba_sessions >= IWM_MAX_RX_BA_SESSIONS)
		return ENOSPC;

	sc->ba_start = 1;
	sc->ba_tid = tid;
	sc->ba_ssn = htole16(ba->ba_winstart);
	task_add(systq, &sc->ba_task);

	return EBUSY;
}

/*
 * This function is called by upper layer on teardown of an HT-immediate
 * Block Ack agreement (eg. upon receipt of a DELBA frame).
 */
void
iwm_ampdu_rx_stop(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct iwm_softc *sc = IC2IFP(ic)->if_softc;

	sc->ba_start = 0;
	sc->ba_tid = tid;
	task_add(systq, &sc->ba_task);
}

void
iwm_set_hw_address_8000(struct iwm_softc *sc, struct iwm_nvm_data *data,
    const uint16_t *mac_override, const uint16_t *nvm_hw)
{
	const uint8_t *hw_addr;

	if (mac_override) {
		static const uint8_t reserved_mac[] = {
			0x02, 0xcc, 0xaa, 0xff, 0xee, 0x00
		};

		hw_addr = (const uint8_t *)(mac_override +
				 IWM_MAC_ADDRESS_OVERRIDE_8000);

		/*
		 * Store the MAC address from MAO section.
		 * No byte swapping is required in MAO section
		 */
		memcpy(data->hw_addr, hw_addr, ETHER_ADDR_LEN);

		/*
		 * Force the use of the OTP MAC address in case of reserved MAC
		 * address in the NVM, or if address is given but invalid.
		 */
		if (memcmp(reserved_mac, hw_addr, ETHER_ADDR_LEN) != 0 &&
		    (memcmp(etherbroadcastaddr, data->hw_addr,
		    sizeof(etherbroadcastaddr)) != 0) &&
		    (memcmp(etheranyaddr, data->hw_addr,
		    sizeof(etheranyaddr)) != 0) &&
		    !ETHER_IS_MULTICAST(data->hw_addr))
			return;
	}

	if (nvm_hw) {
		/* Read the mac address from WFMP registers. */
		uint32_t mac_addr0, mac_addr1;

		if (!iwm_nic_lock(sc))
			goto out;
		mac_addr0 = htole32(iwm_read_prph(sc, IWM_WFMP_MAC_ADDR_0));
		mac_addr1 = htole32(iwm_read_prph(sc, IWM_WFMP_MAC_ADDR_1));
		iwm_nic_unlock(sc);

		hw_addr = (const uint8_t *)&mac_addr0;
		data->hw_addr[0] = hw_addr[3];
		data->hw_addr[1] = hw_addr[2];
		data->hw_addr[2] = hw_addr[1];
		data->hw_addr[3] = hw_addr[0];

		hw_addr = (const uint8_t *)&mac_addr1;
		data->hw_addr[4] = hw_addr[1];
		data->hw_addr[5] = hw_addr[0];

		return;
	}
out:
	printf("%s: mac address not found\n", DEVNAME(sc));
	memset(data->hw_addr, 0, sizeof(data->hw_addr));
}

int
iwm_parse_nvm_data(struct iwm_softc *sc, const uint16_t *nvm_hw,
    const uint16_t *nvm_sw, const uint16_t *nvm_calib,
    const uint16_t *mac_override, const uint16_t *phy_sku,
    const uint16_t *regulatory)
{
	struct iwm_nvm_data *data = &sc->sc_nvm;
	uint8_t hw_addr[ETHER_ADDR_LEN];
	uint32_t sku;

	data->nvm_version = le16_to_cpup(nvm_sw + IWM_NVM_VERSION);

	if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000) {
		uint16_t radio_cfg = le16_to_cpup(nvm_sw + IWM_RADIO_CFG);
		data->radio_cfg_type = IWM_NVM_RF_CFG_TYPE_MSK(radio_cfg);
		data->radio_cfg_step = IWM_NVM_RF_CFG_STEP_MSK(radio_cfg);
		data->radio_cfg_dash = IWM_NVM_RF_CFG_DASH_MSK(radio_cfg);
		data->radio_cfg_pnum = IWM_NVM_RF_CFG_PNUM_MSK(radio_cfg);

		sku = le16_to_cpup(nvm_sw + IWM_SKU);
	} else {
		uint32_t radio_cfg =
		    le32_to_cpup((uint32_t *)(phy_sku + IWM_RADIO_CFG_8000));
		data->radio_cfg_type = IWM_NVM_RF_CFG_TYPE_MSK_8000(radio_cfg);
		data->radio_cfg_step = IWM_NVM_RF_CFG_STEP_MSK_8000(radio_cfg);
		data->radio_cfg_dash = IWM_NVM_RF_CFG_DASH_MSK_8000(radio_cfg);
		data->radio_cfg_pnum = IWM_NVM_RF_CFG_PNUM_MSK_8000(radio_cfg);
		data->valid_tx_ant = IWM_NVM_RF_CFG_TX_ANT_MSK_8000(radio_cfg);
		data->valid_rx_ant = IWM_NVM_RF_CFG_RX_ANT_MSK_8000(radio_cfg);

		sku = le32_to_cpup((uint32_t *)(phy_sku + IWM_SKU_8000));
	}

	data->sku_cap_band_24GHz_enable = sku & IWM_NVM_SKU_CAP_BAND_24GHZ;
	data->sku_cap_band_52GHz_enable = sku & IWM_NVM_SKU_CAP_BAND_52GHZ;
	data->sku_cap_11n_enable = sku & IWM_NVM_SKU_CAP_11N_ENABLE;
	data->sku_cap_mimo_disable = sku & IWM_NVM_SKU_CAP_MIMO_DISABLE;

	data->n_hw_addrs = le16_to_cpup(nvm_sw + IWM_N_HW_ADDRS);

	/* The byte order is little endian 16 bit, meaning 214365 */
	if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000) {
		memcpy(hw_addr, nvm_hw + IWM_HW_ADDR, ETHER_ADDR_LEN);
		data->hw_addr[0] = hw_addr[1];
		data->hw_addr[1] = hw_addr[0];
		data->hw_addr[2] = hw_addr[3];
		data->hw_addr[3] = hw_addr[2];
		data->hw_addr[4] = hw_addr[5];
		data->hw_addr[5] = hw_addr[4];
	} else
		iwm_set_hw_address_8000(sc, data, mac_override, nvm_hw);

	if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000)
		iwm_init_channel_map(sc, &nvm_sw[IWM_NVM_CHANNELS],
		    iwm_nvm_channels, nitems(iwm_nvm_channels));
	else
		iwm_init_channel_map(sc, &regulatory[IWM_NVM_CHANNELS_8000],
		    iwm_nvm_channels_8000, nitems(iwm_nvm_channels_8000));

	data->calib_version = 255;   /* TODO:
					this value will prevent some checks from
					failing, we need to check if this
					field is still needed, and if it does,
					where is it in the NVM */

	return 0;
}

int
iwm_parse_nvm_sections(struct iwm_softc *sc, struct iwm_nvm_section *sections)
{
	const uint16_t *hw, *sw, *calib, *mac_override = NULL, *phy_sku = NULL;
	const uint16_t *regulatory = NULL;

	/* Checking for required sections */
	if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000) {
		if (!sections[IWM_NVM_SECTION_TYPE_SW].data ||
		    !sections[IWM_NVM_SECTION_TYPE_HW].data) {
			return ENOENT;
		}

		hw = (const uint16_t *) sections[IWM_NVM_SECTION_TYPE_HW].data;
	} else if (sc->sc_device_family == IWM_DEVICE_FAMILY_8000) {
		/* SW and REGULATORY sections are mandatory */
		if (!sections[IWM_NVM_SECTION_TYPE_SW].data ||
		    !sections[IWM_NVM_SECTION_TYPE_REGULATORY].data) {
			return ENOENT;
		}
		/* MAC_OVERRIDE or at least HW section must exist */
		if (!sections[IWM_NVM_SECTION_TYPE_HW_8000].data &&
		    !sections[IWM_NVM_SECTION_TYPE_MAC_OVERRIDE].data) {
			return ENOENT;
		}

		/* PHY_SKU section is mandatory in B0 */
		if (!sections[IWM_NVM_SECTION_TYPE_PHY_SKU].data) {
			return ENOENT;
		}

		regulatory = (const uint16_t *)
		    sections[IWM_NVM_SECTION_TYPE_REGULATORY].data;
		hw = (const uint16_t *)
		    sections[IWM_NVM_SECTION_TYPE_HW_8000].data;
		mac_override =
			(const uint16_t *)
			sections[IWM_NVM_SECTION_TYPE_MAC_OVERRIDE].data;
		phy_sku = (const uint16_t *)
		    sections[IWM_NVM_SECTION_TYPE_PHY_SKU].data;
	} else {
		panic("unknown device family %d\n", sc->sc_device_family);
	}

	sw = (const uint16_t *)sections[IWM_NVM_SECTION_TYPE_SW].data;
	calib = (const uint16_t *)
	    sections[IWM_NVM_SECTION_TYPE_CALIBRATION].data;

	return iwm_parse_nvm_data(sc, hw, sw, calib, mac_override,
	    phy_sku, regulatory);
}

int
iwm_nvm_init(struct iwm_softc *sc)
{
	struct iwm_nvm_section nvm_sections[IWM_NVM_NUM_OF_SECTIONS];
	int i, section, err;
	uint16_t len;
	uint8_t *buf;
	const size_t bufsz = IWM_MAX_NVM_SECTION_SIZE;

	memset(nvm_sections, 0, sizeof(nvm_sections));

	buf = malloc(bufsz, M_DEVBUF, M_WAIT);
	if (buf == NULL)
		return ENOMEM;

	for (i = 0; i < nitems(iwm_nvm_to_read); i++) {
		section = iwm_nvm_to_read[i];
		KASSERT(section <= nitems(nvm_sections));

		err = iwm_nvm_read_section(sc, section, buf, &len, bufsz);
		if (err) {
			err = 0;
			continue;
		}
		nvm_sections[section].data = malloc(len, M_DEVBUF, M_WAIT);
		if (nvm_sections[section].data == NULL) {
			err = ENOMEM;
			break;
		}
		memcpy(nvm_sections[section].data, buf, len);
		nvm_sections[section].length = len;
	}
	free(buf, M_DEVBUF, bufsz);
	if (err == 0)
		err = iwm_parse_nvm_sections(sc, nvm_sections);

	for (i = 0; i < IWM_NVM_NUM_OF_SECTIONS; i++) {
		if (nvm_sections[i].data != NULL)
			free(nvm_sections[i].data, M_DEVBUF,
			    nvm_sections[i].length);
	}

	return err;
}

int
iwm_firmware_load_sect(struct iwm_softc *sc, uint32_t dst_addr,
    const uint8_t *section, uint32_t byte_cnt)
{
	int err = EINVAL;
	uint32_t chunk_sz, offset;

	chunk_sz = MIN(IWM_FH_MEM_TB_MAX_LENGTH, byte_cnt);

	for (offset = 0; offset < byte_cnt; offset += chunk_sz) {
		uint32_t addr, len;
		const uint8_t *data;

		addr = dst_addr + offset;
		len = MIN(chunk_sz, byte_cnt - offset);
		data = section + offset;

		err = iwm_firmware_load_chunk(sc, addr, data, len);
		if (err)
			break;
	}

	return err;
}

int
iwm_firmware_load_chunk(struct iwm_softc *sc, uint32_t dst_addr,
    const uint8_t *chunk, uint32_t byte_cnt)
{
	struct iwm_dma_info *dma = &sc->fw_dma;
	int err;

	/* Copy firmware chunk into pre-allocated DMA-safe memory. */
	memcpy(dma->vaddr, chunk, byte_cnt);
	bus_dmamap_sync(sc->sc_dmat,
	    dma->map, 0, byte_cnt, BUS_DMASYNC_PREWRITE);

	if (dst_addr >= IWM_FW_MEM_EXTENDED_START &&
	    dst_addr <= IWM_FW_MEM_EXTENDED_END)
		iwm_set_bits_prph(sc, IWM_LMPM_CHICK,
		    IWM_LMPM_CHICK_EXTENDED_ADDR_SPACE);

	sc->sc_fw_chunk_done = 0;

	if (!iwm_nic_lock(sc))
		return EBUSY;

	IWM_WRITE(sc, IWM_FH_TCSR_CHNL_TX_CONFIG_REG(IWM_FH_SRVC_CHNL),
	    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE);
	IWM_WRITE(sc, IWM_FH_SRVC_CHNL_SRAM_ADDR_REG(IWM_FH_SRVC_CHNL),
	    dst_addr);
	IWM_WRITE(sc, IWM_FH_TFDIB_CTRL0_REG(IWM_FH_SRVC_CHNL),
	    dma->paddr & IWM_FH_MEM_TFDIB_DRAM_ADDR_LSB_MSK);
	IWM_WRITE(sc, IWM_FH_TFDIB_CTRL1_REG(IWM_FH_SRVC_CHNL),
	    (iwm_get_dma_hi_addr(dma->paddr)
	      << IWM_FH_MEM_TFDIB_REG1_ADDR_BITSHIFT) | byte_cnt);
	IWM_WRITE(sc, IWM_FH_TCSR_CHNL_TX_BUF_STS_REG(IWM_FH_SRVC_CHNL),
	    1 << IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM |
	    1 << IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX |
	    IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID);
	IWM_WRITE(sc, IWM_FH_TCSR_CHNL_TX_CONFIG_REG(IWM_FH_SRVC_CHNL),
	    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE    |
	    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE |
	    IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_ENDTFD);

	iwm_nic_unlock(sc);

	/* Wait for this segment to load. */
	err = 0;
	while (!sc->sc_fw_chunk_done) {
		err = tsleep(&sc->sc_fw, 0, "iwmfw", hz);
		if (err)
			break;
	}

	if (!sc->sc_fw_chunk_done)
		printf("%s: fw chunk addr 0x%x len %d failed to load\n",
		    DEVNAME(sc), dst_addr, byte_cnt);

	if (dst_addr >= IWM_FW_MEM_EXTENDED_START &&
	    dst_addr <= IWM_FW_MEM_EXTENDED_END) {
		iwm_clear_bits_prph(sc, IWM_LMPM_CHICK,
		    IWM_LMPM_CHICK_EXTENDED_ADDR_SPACE);
	}

	return err;
}

int
iwm_load_firmware_7000(struct iwm_softc *sc, enum iwm_ucode_type ucode_type)
{
	struct iwm_fw_sects *fws;
	int err, i;
	void *data;
	uint32_t dlen;
	uint32_t offset;

	fws = &sc->sc_fw.fw_sects[ucode_type];
	for (i = 0; i < fws->fw_count; i++) {
		data = fws->fw_sect[i].fws_data;
		dlen = fws->fw_sect[i].fws_len;
		offset = fws->fw_sect[i].fws_devoff;
		if (dlen > sc->sc_fwdmasegsz) {
			err = EFBIG;
		} else
			err = iwm_firmware_load_sect(sc, offset, data, dlen);
		if (err) {
			printf("%s: could not load firmware chunk %u of %u\n",
			    DEVNAME(sc), i, fws->fw_count);
			return err;
		}
	}

	IWM_WRITE(sc, IWM_CSR_RESET, 0);

	return 0;
}

int
iwm_load_cpu_sections_8000(struct iwm_softc *sc, struct iwm_fw_sects *fws,
    int cpu, int *first_ucode_section)
{
	int shift_param;
	int i, err = 0, sec_num = 0x1;
	uint32_t val, last_read_idx = 0;
	void *data;
	uint32_t dlen;
	uint32_t offset;

	if (cpu == 1) {
		shift_param = 0;
		*first_ucode_section = 0;
	} else {
		shift_param = 16;
		(*first_ucode_section)++;
	}

	for (i = *first_ucode_section; i < IWM_UCODE_SECT_MAX; i++) {
		last_read_idx = i;
		data = fws->fw_sect[i].fws_data;
		dlen = fws->fw_sect[i].fws_len;
		offset = fws->fw_sect[i].fws_devoff;

		/*
		 * CPU1_CPU2_SEPARATOR_SECTION delimiter - separate between
		 * CPU1 to CPU2.
		 * PAGING_SEPARATOR_SECTION delimiter - separate between
		 * CPU2 non paged to CPU2 paging sec.
		 */
		if (!data || offset == IWM_CPU1_CPU2_SEPARATOR_SECTION ||
		    offset == IWM_PAGING_SEPARATOR_SECTION)
			break;

		if (dlen > sc->sc_fwdmasegsz) {
			err = EFBIG;
		} else
			err = iwm_firmware_load_sect(sc, offset, data, dlen);
		if (err) {
			printf("%s: could not load firmware chunk %d "
			    "(error %d)\n", DEVNAME(sc), i, err);
			return err;
		}

		/* Notify the ucode of the loaded section number and status */
		if (iwm_nic_lock(sc)) {
			val = IWM_READ(sc, IWM_FH_UCODE_LOAD_STATUS);
			val = val | (sec_num << shift_param);
			IWM_WRITE(sc, IWM_FH_UCODE_LOAD_STATUS, val);
			sec_num = (sec_num << 1) | 0x1;
			iwm_nic_unlock(sc);
		} else {
			err = EBUSY;
			printf("%s: could not load firmware chunk %d "
			    "(error %d)\n", DEVNAME(sc), i, err);
			return err;
		}
	}

	*first_ucode_section = last_read_idx;

	if (iwm_nic_lock(sc)) {
		if (cpu == 1)
			IWM_WRITE(sc, IWM_FH_UCODE_LOAD_STATUS, 0xFFFF);
		else
			IWM_WRITE(sc, IWM_FH_UCODE_LOAD_STATUS, 0xFFFFFFFF);
		iwm_nic_unlock(sc);
	} else {
		err = EBUSY;
		printf("%s: could not finalize firmware loading (error %d)\n",
		    DEVNAME(sc), err);
		return err;
	}

	return 0;
}

int
iwm_load_firmware_8000(struct iwm_softc *sc, enum iwm_ucode_type ucode_type)
{
	struct iwm_fw_sects *fws;
	int err = 0;
	int first_ucode_section;

	fws = &sc->sc_fw.fw_sects[ucode_type];

	/* configure the ucode to be ready to get the secured image */
	/* release CPU reset */
	if (iwm_nic_lock(sc)) {
		iwm_write_prph(sc, IWM_RELEASE_CPU_RESET,
		    IWM_RELEASE_CPU_RESET_BIT);
		iwm_nic_unlock(sc);
	}

	/* load to FW the binary Secured sections of CPU1 */
	err = iwm_load_cpu_sections_8000(sc, fws, 1, &first_ucode_section);
	if (err)
		return err;

	/* load to FW the binary sections of CPU2 */
	return iwm_load_cpu_sections_8000(sc, fws, 2, &first_ucode_section);
}

int
iwm_load_firmware(struct iwm_softc *sc, enum iwm_ucode_type ucode_type)
{
	int err, w;

	sc->sc_uc.uc_intr = 0;

	if (sc->sc_device_family == IWM_DEVICE_FAMILY_8000)
		err = iwm_load_firmware_8000(sc, ucode_type);
	else
		err = iwm_load_firmware_7000(sc, ucode_type);

	if (err)
		return err;

	/* wait for the firmware to load */
	for (w = 0; !sc->sc_uc.uc_intr && w < 10; w++) {
		err = tsleep(&sc->sc_uc, 0, "iwmuc", hz/10);
	}
	if (err || !sc->sc_uc.uc_ok)
		printf("%s: could not load firmware\n", DEVNAME(sc));

	return err;
}

int
iwm_start_fw(struct iwm_softc *sc, enum iwm_ucode_type ucode_type)
{
	int err;

	IWM_WRITE(sc, IWM_CSR_INT, ~0);

	err = iwm_nic_init(sc);
	if (err) {
		printf("%s: unable to init nic\n", DEVNAME(sc));
		return err;
	}

	/* make sure rfkill handshake bits are cleared */
	IWM_WRITE(sc, IWM_CSR_UCODE_DRV_GP1_CLR, IWM_CSR_UCODE_SW_BIT_RFKILL);
	IWM_WRITE(sc, IWM_CSR_UCODE_DRV_GP1_CLR,
	    IWM_CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);

	/* clear (again), then enable host interrupts */
	IWM_WRITE(sc, IWM_CSR_INT, ~0);
	iwm_enable_interrupts(sc);

	/* really make sure rfkill handshake bits are cleared */
	/* maybe we should write a few times more?  just to make sure */
	IWM_WRITE(sc, IWM_CSR_UCODE_DRV_GP1_CLR, IWM_CSR_UCODE_SW_BIT_RFKILL);
	IWM_WRITE(sc, IWM_CSR_UCODE_DRV_GP1_CLR, IWM_CSR_UCODE_SW_BIT_RFKILL);

	return iwm_load_firmware(sc, ucode_type);
}

int
iwm_send_tx_ant_cfg(struct iwm_softc *sc, uint8_t valid_tx_ant)
{
	struct iwm_tx_ant_cfg_cmd tx_ant_cmd = {
		.valid = htole32(valid_tx_ant),
	};

	return iwm_send_cmd_pdu(sc, IWM_TX_ANT_CONFIGURATION_CMD,
	    0, sizeof(tx_ant_cmd), &tx_ant_cmd);
}

int
iwm_send_phy_cfg_cmd(struct iwm_softc *sc)
{
	struct iwm_phy_cfg_cmd phy_cfg_cmd;
	enum iwm_ucode_type ucode_type = sc->sc_uc_current;

	phy_cfg_cmd.phy_cfg = htole32(sc->sc_fw_phy_config);
	phy_cfg_cmd.calib_control.event_trigger =
	    sc->sc_default_calib[ucode_type].event_trigger;
	phy_cfg_cmd.calib_control.flow_trigger =
	    sc->sc_default_calib[ucode_type].flow_trigger;

	return iwm_send_cmd_pdu(sc, IWM_PHY_CONFIGURATION_CMD, 0,
	    sizeof(phy_cfg_cmd), &phy_cfg_cmd);
}

int
iwm_load_ucode_wait_alive(struct iwm_softc *sc,
	enum iwm_ucode_type ucode_type)
{
	enum iwm_ucode_type old_type = sc->sc_uc_current;
	int err;

	err = iwm_read_firmware(sc, ucode_type);
	if (err)
		return err;

	sc->sc_uc_current = ucode_type;
	err = iwm_start_fw(sc, ucode_type);
	if (err) {
		sc->sc_uc_current = old_type;
		return err;
	}

	return iwm_post_alive(sc);
}

int
iwm_run_init_mvm_ucode(struct iwm_softc *sc, int justnvm)
{
	const int wait_flags = (IWM_INIT_COMPLETE | IWM_CALIB_COMPLETE);
	int err;

	if ((sc->sc_flags & IWM_FLAG_RFKILL) && !justnvm) {
		printf("%s: radio is disabled by hardware switch\n",
		    DEVNAME(sc));
		return EPERM;
	}

	sc->sc_init_complete = 0;
	err = iwm_load_ucode_wait_alive(sc, IWM_UCODE_TYPE_INIT);
	if (err) {
		printf("%s: failed to load init firmware\n", DEVNAME(sc));
		return err;
	}

	if (justnvm) {
		err = iwm_nvm_init(sc);
		if (err) {
			printf("%s: failed to read nvm\n", DEVNAME(sc));
			return err;
		}

		if (IEEE80211_ADDR_EQ(etheranyaddr, sc->sc_ic.ic_myaddr))
			IEEE80211_ADDR_COPY(sc->sc_ic.ic_myaddr,
			    sc->sc_nvm.hw_addr);

		return 0;
	}

	err = iwm_send_bt_init_conf(sc);
	if (err)
		return err;

	err = iwm_sf_config(sc, IWM_SF_INIT_OFF);
	if (err)
		return err;

	/* Send TX valid antennas before triggering calibrations */
	err = iwm_send_tx_ant_cfg(sc, iwm_fw_valid_tx_ant(sc));
	if (err)
		return err;

	/*
	 * Send phy configurations command to init uCode
	 * to start the 16.0 uCode init image internal calibrations.
	 */
	err = iwm_send_phy_cfg_cmd(sc);
	if (err)
		return err;

	/*
	 * Nothing to do but wait for the init complete and phy DB
	 * notifications from the firmware.
	 */
	while ((sc->sc_init_complete & wait_flags) != wait_flags) {
		err = tsleep(&sc->sc_init_complete, 0, "iwminit", 2*hz);
		if (err)
			break;
	}

	return err;
}

int
iwm_rx_addbuf(struct iwm_softc *sc, int size, int idx)
{
	struct iwm_rx_ring *ring = &sc->rxq;
	struct iwm_rx_data *data = &ring->data[idx];
	struct mbuf *m;
	int err;
	int fatal = 0;

	m = m_gethdr(M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return ENOBUFS;

	if (size <= MCLBYTES) {
		MCLGET(m, M_DONTWAIT);
	} else {
		MCLGETI(m, M_DONTWAIT, NULL, IWM_RBUF_SIZE);
	}
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return ENOBUFS;
	}

	if (data->m != NULL) {
		bus_dmamap_unload(sc->sc_dmat, data->map);
		fatal = 1;
	}

	m->m_len = m->m_pkthdr.len = m->m_ext.ext_size;
	err = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (err) {
		/* XXX */
		if (fatal)
			panic("iwm: could not load RX mbuf");
		m_freem(m);
		return err;
	}
	data->m = m;
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, size, BUS_DMASYNC_PREREAD);

	/* Update RX descriptor. */
	ring->desc[idx] = htole32(data->map->dm_segs[0].ds_addr >> 8);
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    idx * sizeof(uint32_t), sizeof(uint32_t), BUS_DMASYNC_PREWRITE);

	return 0;
}

#define IWM_RSSI_OFFSET 50
int
iwm_calc_rssi(struct iwm_softc *sc, struct iwm_rx_phy_info *phy_info)
{
	int rssi_a, rssi_b, rssi_a_dbm, rssi_b_dbm, max_rssi_dbm;
	uint32_t agc_a, agc_b;
	uint32_t val;

	val = le32toh(phy_info->non_cfg_phy[IWM_RX_INFO_AGC_IDX]);
	agc_a = (val & IWM_OFDM_AGC_A_MSK) >> IWM_OFDM_AGC_A_POS;
	agc_b = (val & IWM_OFDM_AGC_B_MSK) >> IWM_OFDM_AGC_B_POS;

	val = le32toh(phy_info->non_cfg_phy[IWM_RX_INFO_RSSI_AB_IDX]);
	rssi_a = (val & IWM_OFDM_RSSI_INBAND_A_MSK) >> IWM_OFDM_RSSI_A_POS;
	rssi_b = (val & IWM_OFDM_RSSI_INBAND_B_MSK) >> IWM_OFDM_RSSI_B_POS;

	/*
	 * dBm = rssi dB - agc dB - constant.
	 * Higher AGC (higher radio gain) means lower signal.
	 */
	rssi_a_dbm = rssi_a - IWM_RSSI_OFFSET - agc_a;
	rssi_b_dbm = rssi_b - IWM_RSSI_OFFSET - agc_b;
	max_rssi_dbm = MAX(rssi_a_dbm, rssi_b_dbm);

	return max_rssi_dbm;
}

/*
 * RSSI values are reported by the FW as positive values - need to negate
 * to obtain their dBM.  Account for missing antennas by replacing 0
 * values by -256dBm: practically 0 power and a non-feasible 8 bit value.
 */
int
iwm_get_signal_strength(struct iwm_softc *sc, struct iwm_rx_phy_info *phy_info)
{
	int energy_a, energy_b, energy_c, max_energy;
	uint32_t val;

	val = le32toh(phy_info->non_cfg_phy[IWM_RX_INFO_ENERGY_ANT_ABC_IDX]);
	energy_a = (val & IWM_RX_INFO_ENERGY_ANT_A_MSK) >>
	    IWM_RX_INFO_ENERGY_ANT_A_POS;
	energy_a = energy_a ? -energy_a : -256;
	energy_b = (val & IWM_RX_INFO_ENERGY_ANT_B_MSK) >>
	    IWM_RX_INFO_ENERGY_ANT_B_POS;
	energy_b = energy_b ? -energy_b : -256;
	energy_c = (val & IWM_RX_INFO_ENERGY_ANT_C_MSK) >>
	    IWM_RX_INFO_ENERGY_ANT_C_POS;
	energy_c = energy_c ? -energy_c : -256;
	max_energy = MAX(energy_a, energy_b);
	max_energy = MAX(max_energy, energy_c);

	return max_energy;
}

void
iwm_rx_rx_phy_cmd(struct iwm_softc *sc, struct iwm_rx_packet *pkt,
    struct iwm_rx_data *data)
{
	struct iwm_rx_phy_info *phy_info = (void *)pkt->data;

	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof(*pkt),
	    sizeof(*phy_info), BUS_DMASYNC_POSTREAD);

	memcpy(&sc->sc_last_phy_info, phy_info, sizeof(sc->sc_last_phy_info));
}

/*
 * Retrieve the average noise (in dBm) among receivers.
 */
int
iwm_get_noise(const struct iwm_statistics_rx_non_phy *stats)
{
	int i, total, nbant, noise;

	total = nbant = noise = 0;
	for (i = 0; i < 3; i++) {
		noise = letoh32(stats->beacon_silence_rssi[i]) & 0xff;
		if (noise) {
			total += noise;
			nbant++;
		}
	}

	/* There should be at least one antenna but check anyway. */
	return (nbant == 0) ? -127 : (total / nbant) - 107;
}

void
iwm_rx_rx_mpdu(struct iwm_softc *sc, struct iwm_rx_packet *pkt,
    struct iwm_rx_data *data)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_frame *wh;
	struct ieee80211_node *ni;
	struct ieee80211_channel *c = NULL;
	struct ieee80211_rxinfo rxi;
	struct mbuf *m;
	struct iwm_rx_phy_info *phy_info;
	struct iwm_rx_mpdu_res_start *rx_res;
	int device_timestamp;
	uint32_t len;
	uint32_t rx_pkt_status;
	int rssi;

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, IWM_RBUF_SIZE,
	    BUS_DMASYNC_POSTREAD);

	phy_info = &sc->sc_last_phy_info;
	rx_res = (struct iwm_rx_mpdu_res_start *)pkt->data;
	wh = (struct ieee80211_frame *)(pkt->data + sizeof(*rx_res));
	len = le16toh(rx_res->byte_count);
	rx_pkt_status = le32toh(*(uint32_t *)(pkt->data +
	    sizeof(*rx_res) + len));

	m = data->m;
	m->m_data = pkt->data + sizeof(*rx_res);
	m->m_pkthdr.len = m->m_len = len;

	if (__predict_false(phy_info->cfg_phy_cnt > 20))
		return;

	if (!(rx_pkt_status & IWM_RX_MPDU_RES_STATUS_CRC_OK) ||
	    !(rx_pkt_status & IWM_RX_MPDU_RES_STATUS_OVERRUN_OK))
		return; /* drop */

	device_timestamp = le32toh(phy_info->system_timestamp);

	if (sc->sc_capaflags & IWM_UCODE_TLV_FLAGS_RX_ENERGY_API) {
		rssi = iwm_get_signal_strength(sc, phy_info);
	} else {
		rssi = iwm_calc_rssi(sc, phy_info);
	}
	rssi = (0 - IWM_MIN_DBM) + rssi;	/* normalize */
	rssi = MIN(rssi, ic->ic_max_rssi);	/* clip to max. 100% */

	if (iwm_rx_addbuf(sc, IWM_RBUF_SIZE, sc->rxq.cur) != 0)
		return;

	if (le32toh(phy_info->channel) < nitems(ic->ic_channels))
		c = &ic->ic_channels[le32toh(phy_info->channel)];

	memset(&rxi, 0, sizeof(rxi));
	rxi.rxi_rssi = rssi;
	rxi.rxi_tstamp = device_timestamp;
	ni = ieee80211_find_rxnode(ic, wh);
	if (c)
		ni->ni_chan = c;

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct iwm_rx_radiotap_header *tap = &sc->sc_rxtap;
		uint16_t chan_flags;

		tap->wr_flags = 0;
		if (phy_info->phy_flags & htole16(IWM_PHY_INFO_FLAG_SHPREAMBLE))
			tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
		tap->wr_chan_freq =
		    htole16(ic->ic_channels[phy_info->channel].ic_freq);
		chan_flags = ic->ic_channels[phy_info->channel].ic_flags;
		if (ic->ic_curmode != IEEE80211_MODE_11N)
			chan_flags &= ~IEEE80211_CHAN_HT;
		tap->wr_chan_flags = htole16(chan_flags);
		tap->wr_dbm_antsignal = (int8_t)rssi;
		tap->wr_dbm_antnoise = (int8_t)sc->sc_noise;
		tap->wr_tsft = phy_info->system_timestamp;
		if (phy_info->phy_flags &
		    htole16(IWM_RX_RES_PHY_FLAGS_OFDM_HT)) {
			uint8_t mcs = (phy_info->rate_n_flags &
			    htole32(IWM_RATE_HT_MCS_RATE_CODE_MSK |
			        IWM_RATE_HT_MCS_NSS_MSK));
			tap->wr_rate = (0x80 | mcs);
		} else {
			uint8_t rate = (phy_info->rate_n_flags &
			    htole32(IWM_RATE_LEGACY_RATE_MSK));
			switch (rate) {
			/* CCK rates. */
			case  10: tap->wr_rate =   2; break;
			case  20: tap->wr_rate =   4; break;
			case  55: tap->wr_rate =  11; break;
			case 110: tap->wr_rate =  22; break;
			/* OFDM rates. */
			case 0xd: tap->wr_rate =  12; break;
			case 0xf: tap->wr_rate =  18; break;
			case 0x5: tap->wr_rate =  24; break;
			case 0x7: tap->wr_rate =  36; break;
			case 0x9: tap->wr_rate =  48; break;
			case 0xb: tap->wr_rate =  72; break;
			case 0x1: tap->wr_rate =  96; break;
			case 0x3: tap->wr_rate = 108; break;
			/* Unknown rate: should not happen. */
			default:  tap->wr_rate =   0;
			}
		}

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif
	ieee80211_input(IC2IFP(ic), m, ni, &rxi);
	ieee80211_release_node(ic, ni);
}

void
iwm_rx_tx_cmd_single(struct iwm_softc *sc, struct iwm_rx_packet *pkt,
    struct iwm_node *in)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = &in->in_ni;
	struct ifnet *ifp = IC2IFP(ic);
	struct iwm_tx_resp *tx_resp = (void *)pkt->data;
	int status = le16toh(tx_resp->status.status) & IWM_TX_STATUS_MSK;
	int txfail;
	
	KASSERT(tx_resp->frame_count == 1);

	txfail = (status != IWM_TX_STATUS_SUCCESS &&
	    status != IWM_TX_STATUS_DIRECT_DONE);

	/* Update rate control statistics. */
	if ((ni->ni_flags & IEEE80211_NODE_HT) == 0) {
		in->in_amn.amn_txcnt++;
		if (tx_resp->failure_frame > 0)
			in->in_amn.amn_retrycnt++;
	} else if (ic->ic_fixed_mcs == -1) {
		int omcs = ni->ni_txmcs;
		in->in_mn.frames += tx_resp->frame_count;
		in->in_mn.ampdu_size = le16toh(tx_resp->byte_cnt);
		in->in_mn.agglen = tx_resp->frame_count;
		if (tx_resp->failure_frame > 0)
			in->in_mn.retries += tx_resp->failure_frame;
		if (txfail)
			in->in_mn.txfail += tx_resp->frame_count;
		if (ic->ic_state == IEEE80211_S_RUN)
			ieee80211_mira_choose(&in->in_mn, ic, &in->in_ni);
		/* 
		 * If MiRA has chosen a new TX rate we must update
		 * the firwmare's LQ rate table from process context.
		 */
		if (omcs != ni->ni_txmcs)
			task_add(systq, &sc->setrates_task);
	}

	if (txfail)
		ifp->if_oerrors++;
}

void
iwm_rx_tx_cmd(struct iwm_softc *sc, struct iwm_rx_packet *pkt,
    struct iwm_rx_data *data)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = IC2IFP(ic);
	struct iwm_cmd_header *cmd_hdr = &pkt->hdr;
	int idx = cmd_hdr->idx;
	int qid = cmd_hdr->qid;
	struct iwm_tx_ring *ring = &sc->txq[qid];
	struct iwm_tx_data *txd = &ring->data[idx];
	struct iwm_node *in = txd->in;

	if (txd->done)
		return;

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, IWM_RBUF_SIZE,
	    BUS_DMASYNC_POSTREAD);

	sc->sc_tx_timer = 0;

	iwm_rx_tx_cmd_single(sc, pkt, in);

	bus_dmamap_sync(sc->sc_dmat, txd->map, 0, txd->map->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, txd->map);
	m_freem(txd->m);

	KASSERT(txd->done == 0);
	txd->done = 1;
	KASSERT(txd->in);

	txd->m = NULL;
	txd->in = NULL;
	ieee80211_release_node(ic, &in->in_ni);

	if (--ring->queued < IWM_TX_RING_LOMARK) {
		sc->qfullmsk &= ~(1 << ring->qid);
		if (sc->qfullmsk == 0 && ifq_is_oactive(&ifp->if_snd)) {
			ifq_clr_oactive(&ifp->if_snd);
			/*
			 * Well, we're in interrupt context, but then again
			 * I guess net80211 does all sorts of stunts in
			 * interrupt context, so maybe this is no biggie.
			 */
			(*ifp->if_start)(ifp);
		}
	}
}

void
iwm_rx_bmiss(struct iwm_softc *sc, struct iwm_rx_packet *pkt,
    struct iwm_rx_data *data)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_missed_beacons_notif *mbn = (void *)pkt->data;
	uint32_t missed;

	if ((ic->ic_opmode != IEEE80211_M_STA) ||
	    (ic->ic_state != IEEE80211_S_RUN))
		return;

	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof(*pkt),
	    sizeof(*mbn), BUS_DMASYNC_POSTREAD);

	missed = le32toh(mbn->consec_missed_beacons_since_last_rx);
	if (missed > ic->ic_bmissthres && ic->ic_mgt_timer == 0) {
		/*
		 * Rather than go directly to scan state, try to send a
		 * directed probe request first. If that fails then the
		 * state machine will drop us into scanning after timing
		 * out waiting for a probe response.
		 */
		IEEE80211_SEND_MGMT(ic, ic->ic_bss,
		    IEEE80211_FC0_SUBTYPE_PROBE_REQ, 0);
	}

}

int
iwm_binding_cmd(struct iwm_softc *sc, struct iwm_node *in, uint32_t action)
{
	struct iwm_binding_cmd cmd;
	struct iwm_phy_ctxt *phyctxt = in->in_phyctxt;
	int i, err;
	uint32_t status;

	memset(&cmd, 0, sizeof(cmd));

	cmd.id_and_color
	    = htole32(IWM_FW_CMD_ID_AND_COLOR(phyctxt->id, phyctxt->color));
	cmd.action = htole32(action);
	cmd.phy = htole32(IWM_FW_CMD_ID_AND_COLOR(phyctxt->id, phyctxt->color));

	cmd.macs[0] = htole32(IWM_FW_CMD_ID_AND_COLOR(in->in_id, in->in_color));
	for (i = 1; i < IWM_MAX_MACS_IN_BINDING; i++)
		cmd.macs[i] = htole32(IWM_FW_CTXT_INVALID);

	status = 0;
	err = iwm_send_cmd_pdu_status(sc, IWM_BINDING_CONTEXT_CMD,
	    sizeof(cmd), &cmd, &status);
	if (err == 0 && status != 0)
		err = EIO;

	return err;
}

void
iwm_phy_ctxt_cmd_hdr(struct iwm_softc *sc, struct iwm_phy_ctxt *ctxt,
    struct iwm_phy_context_cmd *cmd, uint32_t action, uint32_t apply_time)
{
	memset(cmd, 0, sizeof(struct iwm_phy_context_cmd));

	cmd->id_and_color = htole32(IWM_FW_CMD_ID_AND_COLOR(ctxt->id,
	    ctxt->color));
	cmd->action = htole32(action);
	cmd->apply_time = htole32(apply_time);
}

void
iwm_phy_ctxt_cmd_data(struct iwm_softc *sc, struct iwm_phy_context_cmd *cmd,
    struct ieee80211_channel *chan, uint8_t chains_static,
    uint8_t chains_dynamic)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t active_cnt, idle_cnt;

	cmd->ci.band = IEEE80211_IS_CHAN_2GHZ(chan) ?
	    IWM_PHY_BAND_24 : IWM_PHY_BAND_5;

	cmd->ci.channel = ieee80211_chan2ieee(ic, chan);
	cmd->ci.width = IWM_PHY_VHT_CHANNEL_MODE20;
	cmd->ci.ctrl_pos = IWM_PHY_VHT_CTRL_POS_1_BELOW;

	/* Set rx the chains */
	idle_cnt = chains_static;
	active_cnt = chains_dynamic;

	cmd->rxchain_info = htole32(iwm_fw_valid_rx_ant(sc) <<
					IWM_PHY_RX_CHAIN_VALID_POS);
	cmd->rxchain_info |= htole32(idle_cnt << IWM_PHY_RX_CHAIN_CNT_POS);
	cmd->rxchain_info |= htole32(active_cnt <<
	    IWM_PHY_RX_CHAIN_MIMO_CNT_POS);

	cmd->txchain_info = htole32(iwm_fw_valid_tx_ant(sc));
}

int
iwm_phy_ctxt_cmd(struct iwm_softc *sc, struct iwm_phy_ctxt *ctxt,
    uint8_t chains_static, uint8_t chains_dynamic, uint32_t action,
    uint32_t apply_time)
{
	struct iwm_phy_context_cmd cmd;

	iwm_phy_ctxt_cmd_hdr(sc, ctxt, &cmd, action, apply_time);

	iwm_phy_ctxt_cmd_data(sc, &cmd, ctxt->channel,
	    chains_static, chains_dynamic);

	return iwm_send_cmd_pdu(sc, IWM_PHY_CONTEXT_CMD, 0,
	    sizeof(struct iwm_phy_context_cmd), &cmd);
}

int
iwm_send_cmd(struct iwm_softc *sc, struct iwm_host_cmd *hcmd)
{
	struct iwm_tx_ring *ring = &sc->txq[IWM_CMD_QUEUE];
	struct iwm_tfd *desc;
	struct iwm_tx_data *txdata;
	struct iwm_device_cmd *cmd;
	struct mbuf *m;
	bus_addr_t paddr;
	uint32_t addr_lo;
	int err = 0, i, paylen, off, s;
	int code;
	int async, wantresp;
	int group_id;
	size_t hdrlen, datasz;
	uint8_t *data;
	int generation = sc->sc_generation;

	code = hcmd->id;
	async = hcmd->flags & IWM_CMD_ASYNC;
	wantresp = hcmd->flags & IWM_CMD_WANT_SKB;

	for (i = 0, paylen = 0; i < nitems(hcmd->len); i++) {
		paylen += hcmd->len[i];
	}

	/* if the command wants an answer, busy sc_cmd_resp */
	if (wantresp) {
		KASSERT(!async);
		while (sc->sc_wantresp != IWM_CMD_RESP_IDLE)
			tsleep(&sc->sc_wantresp, 0, "iwmcmdsl", 0);
		sc->sc_wantresp = ring->qid << 16 | ring->cur;
	}

	/*
	 * Is the hardware still available?  (after e.g. above wait).
	 */
	s = splnet();
	if (generation != sc->sc_generation) {
		err = ENXIO;
		goto out;
	}

	desc = &ring->desc[ring->cur];
	txdata = &ring->data[ring->cur];

	group_id = iwm_cmd_groupid(code);
	if (group_id != 0) {
		hdrlen = sizeof(cmd->hdr_wide);
		datasz = sizeof(cmd->data_wide);
	} else {
		hdrlen = sizeof(cmd->hdr);
		datasz = sizeof(cmd->data);
	}

	if (paylen > datasz) {
		/* Command is too large to fit in pre-allocated space. */
		size_t totlen = hdrlen + paylen;
		if (paylen > IWM_MAX_CMD_PAYLOAD_SIZE) {
			printf("%s: firmware command too long (%zd bytes)\n",
			    DEVNAME(sc), totlen);
			err = EINVAL;
			goto out;
		}
		m = MCLGETI(NULL, M_DONTWAIT, NULL, totlen);
		if (m == NULL) {
			printf("%s: could not get fw cmd mbuf (%zd bytes)\n",
			    DEVNAME(sc), totlen);
			err = ENOMEM;
			goto out;
		}
		cmd = mtod(m, struct iwm_device_cmd *);
		err = bus_dmamap_load(sc->sc_dmat, txdata->map, cmd,
		    totlen, NULL, BUS_DMA_NOWAIT | BUS_DMA_WRITE);
		if (err) {
			printf("%s: could not load fw cmd mbuf (%zd bytes)\n",
			    DEVNAME(sc), totlen);
			m_freem(m);
			goto out;
		}
		txdata->m = m; /* mbuf will be freed in iwm_cmd_done() */
		paddr = txdata->map->dm_segs[0].ds_addr;
	} else {
		cmd = &ring->cmd[ring->cur];
		paddr = txdata->cmd_paddr;
	}

	if (group_id != 0) {
		cmd->hdr_wide.opcode = iwm_cmd_opcode(code);
		cmd->hdr_wide.group_id = group_id;
		cmd->hdr_wide.qid = ring->qid;
		cmd->hdr_wide.idx = ring->cur;
		cmd->hdr_wide.length = htole16(paylen);
		cmd->hdr_wide.version = iwm_cmd_version(code);
		data = cmd->data_wide;
	} else {
		cmd->hdr.code = code;
		cmd->hdr.flags = 0;
		cmd->hdr.qid = ring->qid;
		cmd->hdr.idx = ring->cur;
		data = cmd->data;
	}

	for (i = 0, off = 0; i < nitems(hcmd->data); i++) {
		if (hcmd->len[i] == 0)
			continue;
		memcpy(data + off, hcmd->data[i], hcmd->len[i]);
		off += hcmd->len[i];
	}
	KASSERT(off == paylen);

	/* lo field is not aligned */
	addr_lo = htole32((uint32_t)paddr);
	memcpy(&desc->tbs[0].lo, &addr_lo, sizeof(uint32_t));
	desc->tbs[0].hi_n_len  = htole16(iwm_get_dma_hi_addr(paddr)
	    | ((hdrlen + paylen) << 4));
	desc->num_tbs = 1;

	if (paylen > datasz) {
		bus_dmamap_sync(sc->sc_dmat, txdata->map, 0,
		    hdrlen + paylen, BUS_DMASYNC_PREWRITE);
	} else {
		bus_dmamap_sync(sc->sc_dmat, ring->cmd_dma.map,
		    (char *)(void *)cmd - (char *)(void *)ring->cmd_dma.vaddr,
		    hdrlen + paylen, BUS_DMASYNC_PREWRITE);
	}
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    (char *)(void *)desc - (char *)(void *)ring->desc_dma.vaddr,
	    sizeof (*desc), BUS_DMASYNC_PREWRITE);

	/*
	 * Wake up the NIC to make sure that the firmware will see the host
	 * command - we will let the NIC sleep once all the host commands
	 * returned. This needs to be done only on 7000 family NICs.
	 */
	if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000) {
		if (ring->queued == 0 && !iwm_nic_lock(sc)) {
			err = EBUSY;
			goto out;
		}
	}

#if 0
	iwm_update_sched(sc, ring->qid, ring->cur, 0, 0);
#endif
	/* Kick command ring. */
	ring->queued++;
	ring->cur = (ring->cur + 1) % IWM_TX_RING_COUNT;
	IWM_WRITE(sc, IWM_HBUS_TARG_WRPTR, ring->qid << 8 | ring->cur);

	if (!async) {
		err = tsleep(desc, PCATCH, "iwmcmd", hz);
		if (err == 0) {
			/* if hardware is no longer up, return error */
			if (generation != sc->sc_generation) {
				err = ENXIO;
			} else {
				hcmd->resp_pkt = (void *)sc->sc_cmd_resp;
			}
		}
	}
 out:
	if (wantresp && err) {
		iwm_free_resp(sc, hcmd);
	}
	splx(s);

	return err;
}

int
iwm_send_cmd_pdu(struct iwm_softc *sc, uint32_t id, uint32_t flags,
    uint16_t len, const void *data)
{
	struct iwm_host_cmd cmd = {
		.id = id,
		.len = { len, },
		.data = { data, },
		.flags = flags,
	};

	return iwm_send_cmd(sc, &cmd);
}

int
iwm_send_cmd_status(struct iwm_softc *sc, struct iwm_host_cmd *cmd,
    uint32_t *status)
{
	struct iwm_rx_packet *pkt;
	struct iwm_cmd_response *resp;
	int err, resp_len;

	KASSERT((cmd->flags & IWM_CMD_WANT_SKB) == 0);
	cmd->flags |= IWM_CMD_WANT_SKB;

	err = iwm_send_cmd(sc, cmd);
	if (err)
		return err;
	pkt = cmd->resp_pkt;

	/* Can happen if RFKILL is asserted */
	if (!pkt) {
		err = 0;
		goto out_free_resp;
	}

	if (pkt->hdr.flags & IWM_CMD_FAILED_MSK) {
		err = EIO;
		goto out_free_resp;
	}

	resp_len = iwm_rx_packet_payload_len(pkt);
	if (resp_len != sizeof(*resp)) {
		err = EIO;
		goto out_free_resp;
	}

	resp = (void *)pkt->data;
	*status = le32toh(resp->status);
 out_free_resp:
	iwm_free_resp(sc, cmd);
	return err;
}

int
iwm_send_cmd_pdu_status(struct iwm_softc *sc, uint32_t id, uint16_t len,
    const void *data, uint32_t *status)
{
	struct iwm_host_cmd cmd = {
		.id = id,
		.len = { len, },
		.data = { data, },
	};

	return iwm_send_cmd_status(sc, &cmd, status);
}

void
iwm_free_resp(struct iwm_softc *sc, struct iwm_host_cmd *hcmd)
{
	KASSERT(sc->sc_wantresp != IWM_CMD_RESP_IDLE);
	KASSERT((hcmd->flags & (IWM_CMD_WANT_SKB)) == IWM_CMD_WANT_SKB);
	sc->sc_wantresp = IWM_CMD_RESP_IDLE;
	wakeup(&sc->sc_wantresp);
}

void
iwm_cmd_done(struct iwm_softc *sc, struct iwm_rx_packet *pkt)
{
	struct iwm_tx_ring *ring = &sc->txq[IWM_CMD_QUEUE];
	struct iwm_tx_data *data;

	if (pkt->hdr.qid != IWM_CMD_QUEUE) {
		return;	/* Not a command ack. */
	}

	data = &ring->data[pkt->hdr.idx];

	if (data->m != NULL) {
		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		data->m = NULL;
	}
	wakeup(&ring->desc[pkt->hdr.idx]);

	if (ring->queued == 0) {
		DPRINTF(("%s: unexpected firmware response to command 0x%x\n",
		    DEVNAME(sc), IWM_WIDE_ID(pkt->hdr.flags, pkt->hdr.code)));
	} else if (--ring->queued == 0) {
		/* 
		 * 7000 family NICs are locked while commands are in progress.
		 * All commands are now done so we may unlock the NIC again.
		 */
		if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000)
			iwm_nic_unlock(sc);
	}
}

#if 0
/*
 * necessary only for block ack mode
 */
void
iwm_update_sched(struct iwm_softc *sc, int qid, int idx, uint8_t sta_id,
    uint16_t len)
{
	struct iwm_agn_scd_bc_tbl *scd_bc_tbl;
	uint16_t w_val;

	scd_bc_tbl = sc->sched_dma.vaddr;

	len += 8; /* magic numbers came naturally from paris */
	if (sc->sc_capaflags & IWM_UCODE_TLV_FLAGS_DW_BC_TABLE)
		len = roundup(len, 4) / 4;

	w_val = htole16(sta_id << 12 | len);

	/* Update TX scheduler. */
	scd_bc_tbl[qid].tfd_offset[idx] = w_val;
	bus_dmamap_sync(sc->sc_dmat, sc->sched_dma.map,
	    (char *)(void *)w - (char *)(void *)sc->sched_dma.vaddr,
	    sizeof(uint16_t), BUS_DMASYNC_PREWRITE);

	/* I really wonder what this is ?!? */
	if (idx < IWM_TFD_QUEUE_SIZE_BC_DUP) {
		scd_bc_tbl[qid].tfd_offset[IWM_TFD_QUEUE_SIZE_MAX + idx] = w_val;
		bus_dmamap_sync(sc->sc_dmat, sc->sched_dma.map,
		    (char *)(void *)(w + IWM_TFD_QUEUE_SIZE_MAX) -
		    (char *)(void *)sc->sched_dma.vaddr,
		    sizeof (uint16_t), BUS_DMASYNC_PREWRITE);
	}
}
#endif

/*
 * Fill in various bit for management frames, and leave them
 * unfilled for data frames (firmware takes care of that).
 * Return the selected TX rate.
 */
const struct iwm_rate *
iwm_tx_fill_cmd(struct iwm_softc *sc, struct iwm_node *in,
    struct ieee80211_frame *wh, struct iwm_tx_cmd *tx)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = &in->in_ni;
	const struct iwm_rate *rinfo;
	int type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;
	int ridx, rate_flags, i;
	int nrates = ni->ni_rates.rs_nrates;

	tx->rts_retry_limit = IWM_RTS_DFAULT_RETRY_LIMIT;
	tx->data_retry_limit = IWM_DEFAULT_TX_RETRY;

	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    type != IEEE80211_FC0_TYPE_DATA) {
		/* for non-data, use the lowest supported rate */
		ridx = iwm_rval2ridx(ieee80211_min_basic_rate(ic));
		tx->data_retry_limit = IWM_MGMT_DFAULT_RETRY_LIMIT;
	} else if (ic->ic_fixed_mcs != -1) {
		ridx = sc->sc_fixed_ridx;
	} else if (ic->ic_fixed_rate != -1) {
		ridx = sc->sc_fixed_ridx;
	} else {
		/* for data frames, use RS table */
		tx->initial_rate_index = 0;
		tx->tx_flags |= htole32(IWM_TX_CMD_FLG_STA_RATE);
		if (ni->ni_flags & IEEE80211_NODE_HT) {
			ridx = iwm_mcs2ridx[ni->ni_txmcs];
			return &iwm_rates[ridx];
		}
		ridx = (IEEE80211_IS_CHAN_5GHZ(ni->ni_chan)) ?
		    IWM_RIDX_OFDM : IWM_RIDX_CCK;
		for (i = 0; i < nrates; i++) {
			if (iwm_rates[i].rate == (ni->ni_txrate &
			    IEEE80211_RATE_VAL)) {
				ridx = i;
				break;
			}
		}
		return &iwm_rates[ridx];
	}

	rinfo = &iwm_rates[ridx];
	if (iwm_is_mimo_ht_plcp(rinfo->ht_plcp))
		rate_flags = IWM_RATE_MCS_ANT_AB_MSK;
	else
		rate_flags = IWM_RATE_MCS_ANT_A_MSK;
	if (IWM_RIDX_IS_CCK(ridx))
		rate_flags |= IWM_RATE_MCS_CCK_MSK;
	if ((ni->ni_flags & IEEE80211_NODE_HT) &&
	    rinfo->ht_plcp != IWM_RATE_HT_SISO_MCS_INV_PLCP) {
		rate_flags |= IWM_RATE_MCS_HT_MSK; 
		tx->rate_n_flags = htole32(rate_flags | rinfo->ht_plcp);
	} else
		tx->rate_n_flags = htole32(rate_flags | rinfo->plcp);

	return rinfo;
}

#define TB0_SIZE 16
int
iwm_tx(struct iwm_softc *sc, struct mbuf *m, struct ieee80211_node *ni, int ac)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_node *in = (void *)ni;
	struct iwm_tx_ring *ring;
	struct iwm_tx_data *data;
	struct iwm_tfd *desc;
	struct iwm_device_cmd *cmd;
	struct iwm_tx_cmd *tx;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k = NULL;
	const struct iwm_rate *rinfo;
	uint32_t flags;
	u_int hdrlen;
	bus_dma_segment_t *seg;
	uint8_t tid, type;
	int i, totlen, err, pad;
	int hdrlen2;

	wh = mtod(m, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;

	hdrlen2 = (ieee80211_has_qos(wh)) ?
	    sizeof (struct ieee80211_qosframe) :
	    sizeof (struct ieee80211_frame);

	tid = 0;

	ring = &sc->txq[ac];
	desc = &ring->desc[ring->cur];
	memset(desc, 0, sizeof(*desc));
	data = &ring->data[ring->cur];

	cmd = &ring->cmd[ring->cur];
	cmd->hdr.code = IWM_TX_CMD;
	cmd->hdr.flags = 0;
	cmd->hdr.qid = ring->qid;
	cmd->hdr.idx = ring->cur;

	tx = (void *)cmd->data;
	memset(tx, 0, sizeof(*tx));

	rinfo = iwm_tx_fill_cmd(sc, in, wh, tx);

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct iwm_tx_radiotap_header *tap = &sc->sc_txtap;
		uint16_t chan_flags;

		tap->wt_flags = 0;
		tap->wt_chan_freq = htole16(ni->ni_chan->ic_freq);
		chan_flags = ni->ni_chan->ic_flags;
		if (ic->ic_curmode != IEEE80211_MODE_11N)
			chan_flags &= ~IEEE80211_CHAN_HT;
		tap->wt_chan_flags = htole16(chan_flags);
		if ((ni->ni_flags & IEEE80211_NODE_HT) &&
		    !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
		    type == IEEE80211_FC0_TYPE_DATA &&
		    rinfo->plcp == IWM_RATE_INVM_PLCP) {
			tap->wt_rate = (0x80 | rinfo->ht_plcp);
		} else
			tap->wt_rate = rinfo->rate;
		tap->wt_hwqueue = ac;
		if ((ic->ic_flags & IEEE80211_F_WEPON) &&
		    (wh->i_fc[1] & IEEE80211_FC1_PROTECTED))
			tap->wt_flags |= IEEE80211_RADIOTAP_F_WEP;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
                k = ieee80211_get_txkey(ic, wh, ni);
		if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
			return ENOBUFS;
		/* 802.11 header may have moved. */
		wh = mtod(m, struct ieee80211_frame *);
	}
	totlen = m->m_pkthdr.len;

	flags = 0;
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= IWM_TX_CMD_FLG_ACK;
	}

	if (type == IEEE80211_FC0_TYPE_DATA &&
	    !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (totlen + IEEE80211_CRC_LEN > ic->ic_rtsthreshold ||
	    (ic->ic_flags & IEEE80211_F_USEPROT)))
		flags |= IWM_TX_CMD_FLG_PROT_REQUIRE;

	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    type != IEEE80211_FC0_TYPE_DATA)
		tx->sta_id = IWM_AUX_STA_ID;
	else
		tx->sta_id = IWM_STATION_ID;

	if (type == IEEE80211_FC0_TYPE_MGT) {
		uint8_t subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

		if (subtype == IEEE80211_FC0_SUBTYPE_ASSOC_REQ ||
		    subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ)
			tx->pm_frame_timeout = htole16(3);
		else
			tx->pm_frame_timeout = htole16(2);
	} else {
		tx->pm_frame_timeout = htole16(0);
	}

	if (hdrlen & 3) {
		/* First segment length must be a multiple of 4. */
		flags |= IWM_TX_CMD_FLG_MH_PAD;
		pad = 4 - (hdrlen & 3);
	} else
		pad = 0;

	tx->driver_txop = 0;
	tx->next_frame_len = 0;

	tx->len = htole16(totlen);
	tx->tid_tspec = tid;
	tx->life_time = htole32(IWM_TX_CMD_LIFE_TIME_INFINITE);

	/* Set physical address of "scratch area". */
	tx->dram_lsb_ptr = htole32(data->scratch_paddr);
	tx->dram_msb_ptr = iwm_get_dma_hi_addr(data->scratch_paddr);

	/* Copy 802.11 header in TX command. */
	memcpy(((uint8_t *)tx) + sizeof(*tx), wh, hdrlen);

	flags |= IWM_TX_CMD_FLG_BT_DIS | IWM_TX_CMD_FLG_SEQ_CTL;

	tx->sec_ctl = 0;
	tx->tx_flags |= htole32(flags);

	/* Trim 802.11 header. */
	m_adj(m, hdrlen);

	err = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
	    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
	if (err && err != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n", DEVNAME(sc), err);
		m_freem(m);
		return err;
	}
	if (err) {
		/* Too many DMA segments, linearize mbuf. */
		if (m_defrag(m, M_DONTWAIT)) {
			m_freem(m);
			return ENOBUFS;
		}
		err = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
		    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
		if (err) {
			printf("%s: can't map mbuf (error %d)\n", DEVNAME(sc),
			    err);
			m_freem(m);
			return err;
		}
	}
	data->m = m;
	data->in = in;
	data->done = 0;

	/* Fill TX descriptor. */
	desc->num_tbs = 2 + data->map->dm_nsegs;

	desc->tbs[0].lo = htole32(data->cmd_paddr);
	desc->tbs[0].hi_n_len = htole16(iwm_get_dma_hi_addr(data->cmd_paddr)) |
	    (TB0_SIZE << 4);
	desc->tbs[1].lo = htole32(data->cmd_paddr + TB0_SIZE);
	desc->tbs[1].hi_n_len = htole16(iwm_get_dma_hi_addr(data->cmd_paddr)) |
	    ((sizeof(struct iwm_cmd_header) + sizeof(*tx)
	      + hdrlen + pad - TB0_SIZE) << 4);

	/* Other DMA segments are for data payload. */
	seg = data->map->dm_segs;
	for (i = 0; i < data->map->dm_nsegs; i++, seg++) {
		desc->tbs[i+2].lo = htole32(seg->ds_addr);
		desc->tbs[i+2].hi_n_len = \
		    htole16(iwm_get_dma_hi_addr(seg->ds_addr))
		    | ((seg->ds_len) << 4);
	}

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, ring->cmd_dma.map,
	    (char *)(void *)cmd - (char *)(void *)ring->cmd_dma.vaddr,
	    sizeof (*cmd), BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    (char *)(void *)desc - (char *)(void *)ring->desc_dma.vaddr,
	    sizeof (*desc), BUS_DMASYNC_PREWRITE);

#if 0
	iwm_update_sched(sc, ring->qid, ring->cur, tx->sta_id, le16toh(tx->len));
#endif

	/* Kick TX ring. */
	ring->cur = (ring->cur + 1) % IWM_TX_RING_COUNT;
	IWM_WRITE(sc, IWM_HBUS_TARG_WRPTR, ring->qid << 8 | ring->cur);

	/* Mark TX ring as full if we reach a certain threshold. */
	if (++ring->queued > IWM_TX_RING_HIMARK) {
		sc->qfullmsk |= 1 << ring->qid;
	}

	return 0;
}

#if 0
/* not necessary? */
int
iwm_flush_tx_path(struct iwm_softc *sc, int tfd_msk, int sync)
{
	struct iwm_tx_path_flush_cmd flush_cmd = {
		.queues_ctl = htole32(tfd_msk),
		.flush_ctl = htole16(IWM_DUMP_TX_FIFO_FLUSH),
	};
	int err;

	err = iwm_send_cmd_pdu(sc, IWM_TXPATH_FLUSH,
	    sync ? 0 : IWM_CMD_ASYNC,
	    sizeof(flush_cmd), &flush_cmd);
	if (err)
                printf("%s: Flushing tx queue failed: %d\n", DEVNAME(sc), err);
	return err;
}
#endif

void
iwm_led_enable(struct iwm_softc *sc)
{
	IWM_WRITE(sc, IWM_CSR_LED_REG, IWM_CSR_LED_REG_TURN_ON);
}

void
iwm_led_disable(struct iwm_softc *sc)
{
	IWM_WRITE(sc, IWM_CSR_LED_REG, IWM_CSR_LED_REG_TURN_OFF);
}

int
iwm_led_is_enabled(struct iwm_softc *sc)
{
	return (IWM_READ(sc, IWM_CSR_LED_REG) == IWM_CSR_LED_REG_TURN_ON);
}

void
iwm_led_blink_timeout(void *arg)
{
	struct iwm_softc *sc = arg;

	if (iwm_led_is_enabled(sc))
		iwm_led_disable(sc);
	else
		iwm_led_enable(sc);

	timeout_add_msec(&sc->sc_led_blink_to, 200);
}

void
iwm_led_blink_start(struct iwm_softc *sc)
{
	timeout_add(&sc->sc_led_blink_to, 0);
}

void
iwm_led_blink_stop(struct iwm_softc *sc)
{
	timeout_del(&sc->sc_led_blink_to);
	iwm_led_disable(sc);
}

#define IWM_POWER_KEEP_ALIVE_PERIOD_SEC    25

int
iwm_beacon_filter_send_cmd(struct iwm_softc *sc,
    struct iwm_beacon_filter_cmd *cmd)
{
	return iwm_send_cmd_pdu(sc, IWM_REPLY_BEACON_FILTERING_CMD,
	    0, sizeof(struct iwm_beacon_filter_cmd), cmd);
}

void
iwm_beacon_filter_set_cqm_params(struct iwm_softc *sc, struct iwm_node *in,
    struct iwm_beacon_filter_cmd *cmd)
{
	cmd->ba_enable_beacon_abort = htole32(sc->sc_bf.ba_enabled);
}

int
iwm_update_beacon_abort(struct iwm_softc *sc, struct iwm_node *in, int enable)
{
	struct iwm_beacon_filter_cmd cmd = {
		IWM_BF_CMD_CONFIG_DEFAULTS,
		.bf_enable_beacon_filter = htole32(1),
		.ba_enable_beacon_abort = htole32(enable),
	};

	if (!sc->sc_bf.bf_enabled)
		return 0;

	sc->sc_bf.ba_enabled = enable;
	iwm_beacon_filter_set_cqm_params(sc, in, &cmd);
	return iwm_beacon_filter_send_cmd(sc, &cmd);
}

void
iwm_power_build_cmd(struct iwm_softc *sc, struct iwm_node *in,
    struct iwm_mac_power_cmd *cmd)
{
	struct ieee80211_node *ni = &in->in_ni;
	int dtim_period, dtim_msec, keep_alive;

	cmd->id_and_color = htole32(IWM_FW_CMD_ID_AND_COLOR(in->in_id,
	    in->in_color));
	if (ni->ni_dtimperiod)
		dtim_period = ni->ni_dtimperiod;
	else
		dtim_period = 1;

	/*
	 * Regardless of power management state the driver must set
	 * keep alive period. FW will use it for sending keep alive NDPs
	 * immediately after association. Check that keep alive period
	 * is at least 3 * DTIM.
	 */
	dtim_msec = dtim_period * ni->ni_intval;
	keep_alive = MAX(3 * dtim_msec, 1000 * IWM_POWER_KEEP_ALIVE_PERIOD_SEC);
	keep_alive = roundup(keep_alive, 1000) / 1000;
	cmd->keep_alive_seconds = htole16(keep_alive);

#ifdef notyet
	cmd->flags = htole16(IWM_POWER_FLAGS_POWER_SAVE_ENA_MSK);
	cmd->rx_data_timeout = IWM_DEFAULT_PS_RX_DATA_TIMEOUT;
	cmd->tx_data_timeout = IWM_DEFAULT_PS_TX_DATA_TIMEOUT;
#endif
}

int
iwm_power_mac_update_mode(struct iwm_softc *sc, struct iwm_node *in)
{
	int err;
	int ba_enable;
	struct iwm_mac_power_cmd cmd;

	memset(&cmd, 0, sizeof(cmd));

	iwm_power_build_cmd(sc, in, &cmd);

	err = iwm_send_cmd_pdu(sc, IWM_MAC_PM_POWER_TABLE, 0,
	    sizeof(cmd), &cmd);
	if (err != 0)
		return err;

	ba_enable = !!(cmd.flags &
	    htole16(IWM_POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK));
	return iwm_update_beacon_abort(sc, in, ba_enable);
}

int
iwm_power_update_device(struct iwm_softc *sc)
{
	struct iwm_device_power_cmd cmd = {
#ifdef notyet
		.flags = htole16(IWM_DEVICE_POWER_FLAGS_POWER_SAVE_ENA_MSK),
#endif
	};

	if (!(sc->sc_capaflags & IWM_UCODE_TLV_FLAGS_DEVICE_PS_CMD))
		return 0;

	cmd.flags |= htole16(IWM_DEVICE_POWER_FLAGS_CAM_MSK);

	return iwm_send_cmd_pdu(sc,
	    IWM_POWER_TABLE_CMD, 0, sizeof(cmd), &cmd);
}

int
iwm_enable_beacon_filter(struct iwm_softc *sc, struct iwm_node *in)
{
	struct iwm_beacon_filter_cmd cmd = {
		IWM_BF_CMD_CONFIG_DEFAULTS,
		.bf_enable_beacon_filter = htole32(1),
	};
	int err;

	iwm_beacon_filter_set_cqm_params(sc, in, &cmd);
	err = iwm_beacon_filter_send_cmd(sc, &cmd);

	if (err == 0)
		sc->sc_bf.bf_enabled = 1;

	return err;
}

int
iwm_disable_beacon_filter(struct iwm_softc *sc)
{
	struct iwm_beacon_filter_cmd cmd;
	int err;

	memset(&cmd, 0, sizeof(cmd));
	if ((sc->sc_capaflags & IWM_UCODE_TLV_FLAGS_BF_UPDATED) == 0)
		return 0;

	err = iwm_beacon_filter_send_cmd(sc, &cmd);
	if (err == 0)
		sc->sc_bf.bf_enabled = 0;

	return err;
}

int
iwm_add_sta_cmd(struct iwm_softc *sc, struct iwm_node *in, int update)
{
	struct iwm_add_sta_cmd_v7 add_sta_cmd;
	int err;
	uint32_t status;
	struct ieee80211com *ic = &sc->sc_ic;

	memset(&add_sta_cmd, 0, sizeof(add_sta_cmd));

	add_sta_cmd.sta_id = IWM_STATION_ID;
	add_sta_cmd.mac_id_n_color
	    = htole32(IWM_FW_CMD_ID_AND_COLOR(in->in_id, in->in_color));
	if (!update) {
		int ac;
		for (ac = 0; ac < EDCA_NUM_AC; ac++) {
			add_sta_cmd.tfd_queue_msk |=
			    htole32(1 << iwm_ac_to_tx_fifo[ac]);
		}
		IEEE80211_ADDR_COPY(&add_sta_cmd.addr, in->in_ni.ni_bssid);
	}
	add_sta_cmd.add_modify = update ? 1 : 0;
	add_sta_cmd.station_flags_msk
	    |= htole32(IWM_STA_FLG_FAT_EN_MSK | IWM_STA_FLG_MIMO_EN_MSK);
	add_sta_cmd.tid_disable_tx = htole16(0xffff);
	if (update)
		add_sta_cmd.modify_mask |= (IWM_STA_MODIFY_TID_DISABLE_TX);

	if (in->in_ni.ni_flags & IEEE80211_NODE_HT) {
		add_sta_cmd.station_flags_msk
		    |= htole32(IWM_STA_FLG_MAX_AGG_SIZE_MSK |
		    IWM_STA_FLG_AGG_MPDU_DENS_MSK);

		add_sta_cmd.station_flags
		    |= htole32(IWM_STA_FLG_MAX_AGG_SIZE_64K);
		switch (ic->ic_ampdu_params & IEEE80211_AMPDU_PARAM_SS) {
		case IEEE80211_AMPDU_PARAM_SS_2:
			add_sta_cmd.station_flags
			    |= htole32(IWM_STA_FLG_AGG_MPDU_DENS_2US);
			break;
		case IEEE80211_AMPDU_PARAM_SS_4:
			add_sta_cmd.station_flags
			    |= htole32(IWM_STA_FLG_AGG_MPDU_DENS_4US);
			break;
		case IEEE80211_AMPDU_PARAM_SS_8:
			add_sta_cmd.station_flags
			    |= htole32(IWM_STA_FLG_AGG_MPDU_DENS_8US);
			break;
		case IEEE80211_AMPDU_PARAM_SS_16:
			add_sta_cmd.station_flags
			    |= htole32(IWM_STA_FLG_AGG_MPDU_DENS_16US);
			break;
		default:
			break;
		}
	}

	status = IWM_ADD_STA_SUCCESS;
	err = iwm_send_cmd_pdu_status(sc, IWM_ADD_STA, sizeof(add_sta_cmd),
	    &add_sta_cmd, &status);
	if (err == 0 && status != IWM_ADD_STA_SUCCESS)
		err = EIO;

	return err;
}

int
iwm_add_aux_sta(struct iwm_softc *sc)
{
	struct iwm_add_sta_cmd_v7 cmd;
	int err;
	uint32_t status;

	err = iwm_enable_txq(sc, 0, IWM_AUX_QUEUE, IWM_TX_FIFO_MCAST);
	if (err)
		return err;

	memset(&cmd, 0, sizeof(cmd));
	cmd.sta_id = IWM_AUX_STA_ID;
	cmd.mac_id_n_color =
	    htole32(IWM_FW_CMD_ID_AND_COLOR(IWM_MAC_INDEX_AUX, 0));
	cmd.tfd_queue_msk = htole32(1 << IWM_AUX_QUEUE);
	cmd.tid_disable_tx = htole16(0xffff);

	status = IWM_ADD_STA_SUCCESS;
	err = iwm_send_cmd_pdu_status(sc, IWM_ADD_STA, sizeof(cmd), &cmd,
	    &status);
	if (err == 0 && status != IWM_ADD_STA_SUCCESS)
		err = EIO;

	return err;
}

uint16_t
iwm_scan_rx_chain(struct iwm_softc *sc)
{
	uint16_t rx_chain;
	uint8_t rx_ant;

	rx_ant = iwm_fw_valid_rx_ant(sc);
	rx_chain = rx_ant << IWM_PHY_RX_CHAIN_VALID_POS;
	rx_chain |= rx_ant << IWM_PHY_RX_CHAIN_FORCE_MIMO_SEL_POS;
	rx_chain |= rx_ant << IWM_PHY_RX_CHAIN_FORCE_SEL_POS;
	rx_chain |= 0x1 << IWM_PHY_RX_CHAIN_DRIVER_FORCE_POS;
	return htole16(rx_chain);
}

uint32_t
iwm_scan_rate_n_flags(struct iwm_softc *sc, int flags, int no_cck)
{
	uint32_t tx_ant;
	int i, ind;

	for (i = 0, ind = sc->sc_scan_last_antenna;
	    i < IWM_RATE_MCS_ANT_NUM; i++) {
		ind = (ind + 1) % IWM_RATE_MCS_ANT_NUM;
		if (iwm_fw_valid_tx_ant(sc) & (1 << ind)) {
			sc->sc_scan_last_antenna = ind;
			break;
		}
	}
	tx_ant = (1 << sc->sc_scan_last_antenna) << IWM_RATE_MCS_ANT_POS;

	if ((flags & IEEE80211_CHAN_2GHZ) && !no_cck)
		return htole32(IWM_RATE_1M_PLCP | IWM_RATE_MCS_CCK_MSK |
				   tx_ant);
	else
		return htole32(IWM_RATE_6M_PLCP | tx_ant);
}

uint8_t
iwm_lmac_scan_fill_channels(struct iwm_softc *sc,
    struct iwm_scan_channel_cfg_lmac *chan, int n_ssids)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *c;
	uint8_t nchan;

	for (nchan = 0, c = &ic->ic_channels[1];
	    c <= &ic->ic_channels[IEEE80211_CHAN_MAX] &&
	    nchan < sc->sc_capa_n_scan_channels;
	    c++) {
		if (c->ic_flags == 0)
			continue;

		chan->channel_num = htole16(ieee80211_mhz2ieee(c->ic_freq, 0));
		chan->iter_count = htole16(1);
		chan->iter_interval = 0;
		chan->flags = htole32(IWM_UNIFIED_SCAN_CHANNEL_PARTIAL);
#if 0 /* makes scanning while associated less useful */
		if (n_ssids != 0)
			chan->flags |= htole32(1 << 1); /* select SSID 0 */
#endif
		chan++;
		nchan++;
	}

	return nchan;
}

uint8_t
iwm_umac_scan_fill_channels(struct iwm_softc *sc,
    struct iwm_scan_channel_cfg_umac *chan, int n_ssids)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *c;
	uint8_t nchan;

	for (nchan = 0, c = &ic->ic_channels[1];
	    c <= &ic->ic_channels[IEEE80211_CHAN_MAX] &&
	    nchan < sc->sc_capa_n_scan_channels;
	    c++) {
		if (c->ic_flags == 0)
			continue;

		chan->channel_num = ieee80211_mhz2ieee(c->ic_freq, 0);
		chan->iter_count = 1;
		chan->iter_interval = htole16(0);
#if 0 /* makes scanning while associated less useful */
		if (n_ssids != 0)
			chan->flags = htole32(1 << 0); /* select SSID 0 */
#endif
		chan++;
		nchan++;
	}

	return nchan;
}

int
iwm_fill_probe_req(struct iwm_softc *sc, struct iwm_scan_probe_req *preq)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = IC2IFP(ic);
	struct ieee80211_frame *wh = (struct ieee80211_frame *)preq->buf;
	struct ieee80211_rateset *rs;
	size_t remain = sizeof(preq->buf);
	uint8_t *frm, *pos;

	memset(preq, 0, sizeof(*preq));

	if (remain < sizeof(*wh) + 2 + ic->ic_des_esslen)
		return ENOBUFS;

	/*
	 * Build a probe request frame.  Most of the following code is a
	 * copy & paste of what is done in net80211.
	 */
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_PROBE_REQ;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	IEEE80211_ADDR_COPY(wh->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, etherbroadcastaddr);
	*(uint16_t *)&wh->i_dur[0] = 0;	/* filled by HW */
	*(uint16_t *)&wh->i_seq[0] = 0;	/* filled by HW */

	frm = (uint8_t *)(wh + 1);
	frm = ieee80211_add_ssid(frm, ic->ic_des_essid, ic->ic_des_esslen);

	/* Tell the firmware where the MAC header is. */
	preq->mac_header.offset = 0;
	preq->mac_header.len = htole16(frm - (uint8_t *)wh);
	remain -= frm - (uint8_t *)wh;

	/* Fill in 2GHz IEs and tell firmware where they are. */
	rs = &ic->ic_sup_rates[IEEE80211_MODE_11G];
	if (rs->rs_nrates > IEEE80211_RATE_SIZE) {
		if (remain < 4 + rs->rs_nrates)
			return ENOBUFS;
	} else if (remain < 2 + rs->rs_nrates)
		return ENOBUFS;
	preq->band_data[0].offset = htole16(frm - (uint8_t *)wh);
	pos = frm;
	frm = ieee80211_add_rates(frm, rs);
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);
	preq->band_data[0].len = htole16(frm - pos);
	remain -= frm - pos;

	if (isset(sc->sc_enabled_capa, 
	    IWM_UCODE_TLV_CAPA_DS_PARAM_SET_IE_SUPPORT)) {
		if (remain < 3)
			return ENOBUFS;
		*frm++ = IEEE80211_ELEMID_DSPARMS;
		*frm++ = 1;
		*frm++ = 0;
		remain -= 3;
	}

	if (sc->sc_nvm.sku_cap_band_52GHz_enable) {
		/* Fill in 5GHz IEs. */
		rs = &ic->ic_sup_rates[IEEE80211_MODE_11A];
		if (rs->rs_nrates > IEEE80211_RATE_SIZE) {
			if (remain < 4 + rs->rs_nrates)
				return ENOBUFS;
		} else if (remain < 2 + rs->rs_nrates)
			return ENOBUFS;
		preq->band_data[1].offset = htole16(frm - (uint8_t *)wh);
		pos = frm;
		frm = ieee80211_add_rates(frm, rs);
		if (rs->rs_nrates > IEEE80211_RATE_SIZE)
			frm = ieee80211_add_xrates(frm, rs);
		preq->band_data[1].len = htole16(frm - pos);
		remain -= frm - pos;
	}

	/* Send 11n IEs on both 2GHz and 5GHz bands. */
	preq->common_data.offset = htole16(frm - (uint8_t *)wh);
	pos = frm;
	if (ic->ic_flags & IEEE80211_F_HTON) {
		if (remain < 28)
			return ENOBUFS;
		frm = ieee80211_add_htcaps(frm, ic);
		/* XXX add WME info? */
	}
	preq->common_data.len = htole16(frm - pos);

	return 0;
}

int
iwm_lmac_scan(struct iwm_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_host_cmd hcmd = {
		.id = IWM_SCAN_OFFLOAD_REQUEST_CMD,
		.len = { 0, },
		.data = { NULL, },
		.flags = 0,
	};
	struct iwm_scan_req_lmac *req;
	size_t req_len;
	int err;

	req_len = sizeof(struct iwm_scan_req_lmac) +
	    (sizeof(struct iwm_scan_channel_cfg_lmac) *
	    sc->sc_capa_n_scan_channels) + sizeof(struct iwm_scan_probe_req);
	if (req_len > IWM_MAX_CMD_PAYLOAD_SIZE)
		return ENOMEM;
	req = malloc(req_len, M_DEVBUF, M_WAIT | M_CANFAIL | M_ZERO);
	if (req == NULL)
		return ENOMEM;

	hcmd.len[0] = (uint16_t)req_len;
	hcmd.data[0] = (void *)req;

	/* These timings correspond to iwlwifi's UNASSOC scan. */
	req->active_dwell = 10;
	req->passive_dwell = 110;
	req->fragmented_dwell = 44;
	req->extended_dwell = 90;
	req->max_out_time = 0;
	req->suspend_time = 0;

	req->scan_prio = htole32(IWM_SCAN_PRIORITY_HIGH);
	req->rx_chain_select = iwm_scan_rx_chain(sc);
	req->iter_num = htole32(1);
	req->delay = 0;

	req->scan_flags = htole32(IWM_LMAC_SCAN_FLAG_PASS_ALL |
	    IWM_LMAC_SCAN_FLAG_ITER_COMPLETE |
	    IWM_LMAC_SCAN_FLAG_EXTENDED_DWELL);
	if (ic->ic_des_esslen == 0)
		req->scan_flags |= htole32(IWM_LMAC_SCAN_FLAG_PASSIVE);
	else
		req->scan_flags |=
		    htole32(IWM_LMAC_SCAN_FLAG_PRE_CONNECTION);
	if (isset(sc->sc_enabled_capa, 
	    IWM_UCODE_TLV_CAPA_DS_PARAM_SET_IE_SUPPORT))
		req->scan_flags |= htole32(IWM_LMAC_SCAN_FLAGS_RRM_ENABLED);

	req->flags = htole32(IWM_PHY_BAND_24);
	if (sc->sc_nvm.sku_cap_band_52GHz_enable)
		req->flags |= htole32(IWM_PHY_BAND_5);
	req->filter_flags =
	    htole32(IWM_MAC_FILTER_ACCEPT_GRP | IWM_MAC_FILTER_IN_BEACON);

	/* Tx flags 2 GHz. */
	req->tx_cmd[0].tx_flags = htole32(IWM_TX_CMD_FLG_SEQ_CTL |
	    IWM_TX_CMD_FLG_BT_DIS);
	req->tx_cmd[0].rate_n_flags =
	    iwm_scan_rate_n_flags(sc, IEEE80211_CHAN_2GHZ, 1/*XXX*/);
	req->tx_cmd[0].sta_id = IWM_AUX_STA_ID;

	/* Tx flags 5 GHz. */
	req->tx_cmd[1].tx_flags = htole32(IWM_TX_CMD_FLG_SEQ_CTL |
	    IWM_TX_CMD_FLG_BT_DIS);
	req->tx_cmd[1].rate_n_flags =
	    iwm_scan_rate_n_flags(sc, IEEE80211_CHAN_5GHZ, 1/*XXX*/);
	req->tx_cmd[1].sta_id = IWM_AUX_STA_ID;

	/* Check if we're doing an active directed scan. */
	if (ic->ic_des_esslen != 0) {
		req->direct_scan[0].id = IEEE80211_ELEMID_SSID;
		req->direct_scan[0].len = ic->ic_des_esslen;
		memcpy(req->direct_scan[0].ssid, ic->ic_des_essid,
		    ic->ic_des_esslen);
	}

	req->n_channels = iwm_lmac_scan_fill_channels(sc,
	    (struct iwm_scan_channel_cfg_lmac *)req->data,
	    ic->ic_des_esslen != 0);

	err = iwm_fill_probe_req(sc,
			    (struct iwm_scan_probe_req *)(req->data +
			    (sizeof(struct iwm_scan_channel_cfg_lmac) *
			    sc->sc_capa_n_scan_channels)));
	if (err) {
		free(req, M_DEVBUF, req_len);
		return err;
	}

	/* Specify the scan plan: We'll do one iteration. */
	req->schedule[0].iterations = 1;
	req->schedule[0].full_scan_mul = 1;

	/* Disable EBS. */
	req->channel_opt[0].non_ebs_ratio = 1;
	req->channel_opt[1].non_ebs_ratio = 1;

	err = iwm_send_cmd(sc, &hcmd);
	free(req, M_DEVBUF, req_len);
	return err;
}

int
iwm_config_umac_scan(struct iwm_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_scan_config *scan_config;
	int err, nchan;
	size_t cmd_size;
	struct ieee80211_channel *c;
	struct iwm_host_cmd hcmd = {
		.id = iwm_cmd_id(IWM_SCAN_CFG_CMD, IWM_ALWAYS_LONG_GROUP, 0),
		.flags = 0,
	};
	static const uint32_t rates = (IWM_SCAN_CONFIG_RATE_1M |
	    IWM_SCAN_CONFIG_RATE_2M | IWM_SCAN_CONFIG_RATE_5M |
	    IWM_SCAN_CONFIG_RATE_11M | IWM_SCAN_CONFIG_RATE_6M |
	    IWM_SCAN_CONFIG_RATE_9M | IWM_SCAN_CONFIG_RATE_12M |
	    IWM_SCAN_CONFIG_RATE_18M | IWM_SCAN_CONFIG_RATE_24M |
	    IWM_SCAN_CONFIG_RATE_36M | IWM_SCAN_CONFIG_RATE_48M |
	    IWM_SCAN_CONFIG_RATE_54M);

	cmd_size = sizeof(*scan_config) + sc->sc_capa_n_scan_channels;

	scan_config = malloc(cmd_size, M_DEVBUF, M_WAIT | M_CANFAIL | M_ZERO);
	if (scan_config == NULL)
		return ENOMEM;

	scan_config->tx_chains = htole32(iwm_fw_valid_tx_ant(sc));
	scan_config->rx_chains = htole32(iwm_fw_valid_rx_ant(sc));
	scan_config->legacy_rates = htole32(rates |
	    IWM_SCAN_CONFIG_SUPPORTED_RATE(rates));

	/* These timings correspond to iwlwifi's UNASSOC scan. */
	scan_config->dwell_active = 10;
	scan_config->dwell_passive = 110;
	scan_config->dwell_fragmented = 44;
	scan_config->dwell_extended = 90;
	scan_config->out_of_channel_time = htole32(0);
	scan_config->suspend_time = htole32(0);

	IEEE80211_ADDR_COPY(scan_config->mac_addr, sc->sc_ic.ic_myaddr);

	scan_config->bcast_sta_id = IWM_AUX_STA_ID;
	scan_config->channel_flags = IWM_CHANNEL_FLAG_EBS |
	    IWM_CHANNEL_FLAG_ACCURATE_EBS | IWM_CHANNEL_FLAG_EBS_ADD |
	    IWM_CHANNEL_FLAG_PRE_SCAN_PASSIVE2ACTIVE;

	for (c = &ic->ic_channels[1], nchan = 0;
	    c <= &ic->ic_channels[IEEE80211_CHAN_MAX] &&
	    nchan < sc->sc_capa_n_scan_channels; c++) {
		if (c->ic_flags == 0)
			continue;
		scan_config->channel_array[nchan++] =
		    ieee80211_mhz2ieee(c->ic_freq, 0);
	}

	scan_config->flags = htole32(IWM_SCAN_CONFIG_FLAG_ACTIVATE |
	    IWM_SCAN_CONFIG_FLAG_ALLOW_CHUB_REQS |
	    IWM_SCAN_CONFIG_FLAG_SET_TX_CHAINS |
	    IWM_SCAN_CONFIG_FLAG_SET_RX_CHAINS |
	    IWM_SCAN_CONFIG_FLAG_SET_AUX_STA_ID |
	    IWM_SCAN_CONFIG_FLAG_SET_ALL_TIMES |
	    IWM_SCAN_CONFIG_FLAG_SET_LEGACY_RATES |
	    IWM_SCAN_CONFIG_FLAG_SET_MAC_ADDR |
	    IWM_SCAN_CONFIG_FLAG_SET_CHANNEL_FLAGS|
	    IWM_SCAN_CONFIG_N_CHANNELS(nchan) |
	    IWM_SCAN_CONFIG_FLAG_CLEAR_FRAGMENTED);

	hcmd.data[0] = scan_config;
	hcmd.len[0] = cmd_size;

	err = iwm_send_cmd(sc, &hcmd);
	free(scan_config, M_DEVBUF, cmd_size);
	return err;
}

int
iwm_umac_scan(struct iwm_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_host_cmd hcmd = {
		.id = iwm_cmd_id(IWM_SCAN_REQ_UMAC, IWM_ALWAYS_LONG_GROUP, 0),
		.len = { 0, },
		.data = { NULL, },
		.flags =0,
	};
	struct iwm_scan_req_umac *req;
	struct iwm_scan_req_umac_tail *tail;
	size_t req_len;
	int err;

	req_len = sizeof(struct iwm_scan_req_umac) +
	    (sizeof(struct iwm_scan_channel_cfg_umac) *
	    sc->sc_capa_n_scan_channels) +
	    sizeof(struct iwm_scan_req_umac_tail);
	if (req_len > IWM_MAX_CMD_PAYLOAD_SIZE)
		return ENOMEM;
	req = malloc(req_len, M_DEVBUF, M_WAIT | M_CANFAIL | M_ZERO);
	if (req == NULL)
		return ENOMEM;

	hcmd.len[0] = (uint16_t)req_len;
	hcmd.data[0] = (void *)req;

	/* These timings correspond to iwlwifi's UNASSOC scan. */
	req->active_dwell = 10;
	req->passive_dwell = 110;
	req->fragmented_dwell = 44;
	req->extended_dwell = 90;
	req->max_out_time = 0;
	req->suspend_time = 0;

	req->scan_priority = htole32(IWM_SCAN_PRIORITY_HIGH);
	req->ooc_priority = htole32(IWM_SCAN_PRIORITY_HIGH);

	req->n_channels = iwm_umac_scan_fill_channels(sc,
	    (struct iwm_scan_channel_cfg_umac *)req->data,
	    ic->ic_des_esslen != 0);

	req->general_flags = htole32(IWM_UMAC_SCAN_GEN_FLAGS_PASS_ALL |
	    IWM_UMAC_SCAN_GEN_FLAGS_ITER_COMPLETE |
	    IWM_UMAC_SCAN_GEN_FLAGS_EXTENDED_DWELL);

	tail = (void *)&req->data +
		sizeof(struct iwm_scan_channel_cfg_umac) *
			sc->sc_capa_n_scan_channels;

	/* Check if we're doing an active directed scan. */
	if (ic->ic_des_esslen != 0) {
		tail->direct_scan[0].id = IEEE80211_ELEMID_SSID;
		tail->direct_scan[0].len = ic->ic_des_esslen;
		memcpy(tail->direct_scan[0].ssid, ic->ic_des_essid,
		    ic->ic_des_esslen);
		req->general_flags |=
		    htole32(IWM_UMAC_SCAN_GEN_FLAGS_PRE_CONNECT);
	} else
		req->general_flags |= htole32(IWM_UMAC_SCAN_GEN_FLAGS_PASSIVE);

	if (isset(sc->sc_enabled_capa, 
	    IWM_UCODE_TLV_CAPA_DS_PARAM_SET_IE_SUPPORT))
		req->general_flags |=
		    htole32(IWM_UMAC_SCAN_GEN_FLAGS_RRM_ENABLED);

	err = iwm_fill_probe_req(sc, &tail->preq);
	if (err) {
		free(req, M_DEVBUF, req_len);
		return err;
	}

	/* Specify the scan plan: We'll do one iteration. */
	tail->schedule[0].interval = 0;
	tail->schedule[0].iter_count = 1;

	err = iwm_send_cmd(sc, &hcmd);
	free(req, M_DEVBUF, req_len);
	return err;
}

uint8_t
iwm_ridx2rate(struct ieee80211_rateset *rs, int ridx)
{
	int i;
	uint8_t rval;

	for (i = 0; i < rs->rs_nrates; i++) {
		rval = (rs->rs_rates[i] & IEEE80211_RATE_VAL);
		if (rval == iwm_rates[ridx].rate)
			return rs->rs_rates[i];
	}

	return 0;
}

int
iwm_rval2ridx(int rval)
{
	int ridx;

	for (ridx = 0; ridx < nitems(iwm_rates); ridx++) {
		if (rval == iwm_rates[ridx].rate)
			break;
	}

       return ridx;
}

void
iwm_ack_rates(struct iwm_softc *sc, struct iwm_node *in, int *cck_rates,
    int *ofdm_rates)
{
	struct ieee80211_node *ni = &in->in_ni;
	struct ieee80211_rateset *rs = &ni->ni_rates;
	int lowest_present_ofdm = -1;
	int lowest_present_cck = -1;
	uint8_t cck = 0;
	uint8_t ofdm = 0;
	int i;

	if (ni->ni_chan == IEEE80211_CHAN_ANYC ||
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan)) {
		for (i = IWM_FIRST_CCK_RATE; i < IWM_FIRST_OFDM_RATE; i++) {
			if ((iwm_ridx2rate(rs, i) & IEEE80211_RATE_BASIC) == 0)
				continue;
			cck |= (1 << i);
			if (lowest_present_cck == -1 || lowest_present_cck > i)
				lowest_present_cck = i;
		}
	}
	for (i = IWM_FIRST_OFDM_RATE; i <= IWM_LAST_NON_HT_RATE; i++) {
		if ((iwm_ridx2rate(rs, i) & IEEE80211_RATE_BASIC) == 0)
			continue;	
		ofdm |= (1 << (i - IWM_FIRST_OFDM_RATE));
		if (lowest_present_ofdm == -1 || lowest_present_ofdm > i)
			lowest_present_ofdm = i;
	}

	/*
	 * Now we've got the basic rates as bitmaps in the ofdm and cck
	 * variables. This isn't sufficient though, as there might not
	 * be all the right rates in the bitmap. E.g. if the only basic
	 * rates are 5.5 Mbps and 11 Mbps, we still need to add 1 Mbps
	 * and 6 Mbps because the 802.11-2007 standard says in 9.6:
	 *
	 *    [...] a STA responding to a received frame shall transmit
	 *    its Control Response frame [...] at the highest rate in the
	 *    BSSBasicRateSet parameter that is less than or equal to the
	 *    rate of the immediately previous frame in the frame exchange
	 *    sequence ([...]) and that is of the same modulation class
	 *    ([...]) as the received frame. If no rate contained in the
	 *    BSSBasicRateSet parameter meets these conditions, then the
	 *    control frame sent in response to a received frame shall be
	 *    transmitted at the highest mandatory rate of the PHY that is
	 *    less than or equal to the rate of the received frame, and
	 *    that is of the same modulation class as the received frame.
	 *
	 * As a consequence, we need to add all mandatory rates that are
	 * lower than all of the basic rates to these bitmaps.
	 */

	if (IWM_RATE_24M_INDEX < lowest_present_ofdm)
		ofdm |= IWM_RATE_BIT_MSK(24) >> IWM_FIRST_OFDM_RATE;
	if (IWM_RATE_12M_INDEX < lowest_present_ofdm)
		ofdm |= IWM_RATE_BIT_MSK(12) >> IWM_FIRST_OFDM_RATE;
	/* 6M already there or needed so always add */
	ofdm |= IWM_RATE_BIT_MSK(6) >> IWM_FIRST_OFDM_RATE;

	/*
	 * CCK is a bit more complex with DSSS vs. HR/DSSS vs. ERP.
	 * Note, however:
	 *  - if no CCK rates are basic, it must be ERP since there must
	 *    be some basic rates at all, so they're OFDM => ERP PHY
	 *    (or we're in 5 GHz, and the cck bitmap will never be used)
	 *  - if 11M is a basic rate, it must be ERP as well, so add 5.5M
	 *  - if 5.5M is basic, 1M and 2M are mandatory
	 *  - if 2M is basic, 1M is mandatory
	 *  - if 1M is basic, that's the only valid ACK rate.
	 * As a consequence, it's not as complicated as it sounds, just add
	 * any lower rates to the ACK rate bitmap.
	 */
	if (IWM_RATE_11M_INDEX < lowest_present_cck)
		cck |= IWM_RATE_BIT_MSK(11) >> IWM_FIRST_CCK_RATE;
	if (IWM_RATE_5M_INDEX < lowest_present_cck)
		cck |= IWM_RATE_BIT_MSK(5) >> IWM_FIRST_CCK_RATE;
	if (IWM_RATE_2M_INDEX < lowest_present_cck)
		cck |= IWM_RATE_BIT_MSK(2) >> IWM_FIRST_CCK_RATE;
	/* 1M already there or needed so always add */
	cck |= IWM_RATE_BIT_MSK(1) >> IWM_FIRST_CCK_RATE;

	*cck_rates = cck;
	*ofdm_rates = ofdm;
}

void
iwm_mac_ctxt_cmd_common(struct iwm_softc *sc, struct iwm_node *in,
    struct iwm_mac_ctx_cmd *cmd, uint32_t action, int assoc)
{
#define IWM_EXP2(x)	((1 << (x)) - 1)	/* CWmin = 2^ECWmin - 1 */
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	int cck_ack_rates, ofdm_ack_rates;
	int i;

	cmd->id_and_color = htole32(IWM_FW_CMD_ID_AND_COLOR(in->in_id,
	    in->in_color));
	cmd->action = htole32(action);

	cmd->mac_type = htole32(IWM_FW_MAC_TYPE_BSS_STA);
	cmd->tsf_id = htole32(IWM_TSF_ID_A);

	IEEE80211_ADDR_COPY(cmd->node_addr, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(cmd->bssid_addr, ni->ni_bssid);

	iwm_ack_rates(sc, in, &cck_ack_rates, &ofdm_ack_rates);
	cmd->cck_rates = htole32(cck_ack_rates);
	cmd->ofdm_rates = htole32(ofdm_ack_rates);

	cmd->cck_short_preamble
	    = htole32((ic->ic_flags & IEEE80211_F_SHPREAMBLE)
	      ? IWM_MAC_FLG_SHORT_PREAMBLE : 0);
	cmd->short_slot
	    = htole32((ic->ic_flags & IEEE80211_F_SHSLOT)
	      ? IWM_MAC_FLG_SHORT_SLOT : 0);

	for (i = 0; i < EDCA_NUM_AC; i++) {
		struct ieee80211_edca_ac_params *ac = &ic->ic_edca_ac[i];
		int txf = iwm_ac_to_tx_fifo[i];

		cmd->ac[txf].cw_min = htole16(IWM_EXP2(ac->ac_ecwmin));
		cmd->ac[txf].cw_max = htole16(IWM_EXP2(ac->ac_ecwmax));
		cmd->ac[txf].aifsn = ac->ac_aifsn;
		cmd->ac[txf].fifos_mask = (1 << txf);
		cmd->ac[txf].edca_txop = htole16(ac->ac_txoplimit * 32);
	}
	if (ni->ni_flags & IEEE80211_NODE_QOS)
		cmd->qos_flags |= htole32(IWM_MAC_QOS_FLG_UPDATE_EDCA);

	if (ni->ni_flags & IEEE80211_NODE_HT) {
		enum ieee80211_htprot htprot =
		    (ni->ni_htop1 & IEEE80211_HTOP1_PROT_MASK);
		switch (htprot) {
		case IEEE80211_HTPROT_NONE:
			break;
		case IEEE80211_HTPROT_NONMEMBER:
		case IEEE80211_HTPROT_NONHT_MIXED:
			cmd->protection_flags |=
			    htole32(IWM_MAC_PROT_FLG_HT_PROT);
			break;
		case IEEE80211_HTPROT_20MHZ:
			if (ic->ic_htcaps & IEEE80211_HTCAP_CBW20_40) {
				/* XXX ... and if our channel is 40 MHz ... */
				cmd->protection_flags |=
				    htole32(IWM_MAC_PROT_FLG_HT_PROT |
				    IWM_MAC_PROT_FLG_FAT_PROT);
			}
			break;
		default:
			break;
		}

		cmd->qos_flags |= htole32(IWM_MAC_QOS_FLG_TGN);
	}
	if (ic->ic_flags & IEEE80211_F_USEPROT)
		cmd->protection_flags |= htole32(IWM_MAC_PROT_FLG_TGG_PROTECT);

	cmd->filter_flags = htole32(IWM_MAC_FILTER_ACCEPT_GRP);
#undef IWM_EXP2
}

void
iwm_mac_ctxt_cmd_fill_sta(struct iwm_softc *sc, struct iwm_node *in,
    struct iwm_mac_data_sta *sta, int assoc)
{
	struct ieee80211_node *ni = &in->in_ni;
	uint32_t dtim_off;
	uint64_t tsf;

	dtim_off = ni->ni_dtimcount * ni->ni_intval * IEEE80211_DUR_TU;
	memcpy(&tsf, ni->ni_tstamp, sizeof(tsf));
	tsf = letoh64(tsf);

	sta->is_assoc = htole32(assoc);
	sta->dtim_time = htole32(ni->ni_rstamp + dtim_off);
	sta->dtim_tsf = htole64(tsf + dtim_off);
	sta->bi = htole32(ni->ni_intval);
	sta->bi_reciprocal = htole32(iwm_reciprocal(ni->ni_intval));
	sta->dtim_interval = htole32(ni->ni_intval * ni->ni_dtimperiod);
	sta->dtim_reciprocal = htole32(iwm_reciprocal(sta->dtim_interval));
	sta->listen_interval = htole32(10);
	sta->assoc_id = htole32(ni->ni_associd);
	sta->assoc_beacon_arrive_time = htole32(ni->ni_rstamp);
}

int
iwm_mac_ctxt_cmd(struct iwm_softc *sc, struct iwm_node *in, uint32_t action,
    int assoc)
{
	struct ieee80211_node *ni = &in->in_ni;
	struct iwm_mac_ctx_cmd cmd;

	memset(&cmd, 0, sizeof(cmd));

	iwm_mac_ctxt_cmd_common(sc, in, &cmd, action, assoc);

	/* Allow beacons to pass through as long as we are not associated or we
	 * do not have dtim period information */
	if (!assoc || !ni->ni_associd || !ni->ni_dtimperiod)
		cmd.filter_flags |= htole32(IWM_MAC_FILTER_IN_BEACON);
	else
		iwm_mac_ctxt_cmd_fill_sta(sc, in, &cmd.sta, assoc);

	return iwm_send_cmd_pdu(sc, IWM_MAC_CONTEXT_CMD, 0, sizeof(cmd), &cmd);
}

int
iwm_update_quotas(struct iwm_softc *sc, struct iwm_node *in)
{
	struct iwm_time_quota_cmd cmd;
	int i, idx, num_active_macs, quota, quota_rem;
	int colors[IWM_MAX_BINDINGS] = { -1, -1, -1, -1, };
	int n_ifs[IWM_MAX_BINDINGS] = {0, };
	uint16_t id;

	memset(&cmd, 0, sizeof(cmd));

	/* currently, PHY ID == binding ID */
	if (in) {
		id = in->in_phyctxt->id;
		KASSERT(id < IWM_MAX_BINDINGS);
		colors[id] = in->in_phyctxt->color;

		if (1)
			n_ifs[id] = 1;
	}

	/*
	 * The FW's scheduling session consists of
	 * IWM_MAX_QUOTA fragments. Divide these fragments
	 * equally between all the bindings that require quota
	 */
	num_active_macs = 0;
	for (i = 0; i < IWM_MAX_BINDINGS; i++) {
		cmd.quotas[i].id_and_color = htole32(IWM_FW_CTXT_INVALID);
		num_active_macs += n_ifs[i];
	}

	quota = 0;
	quota_rem = 0;
	if (num_active_macs) {
		quota = IWM_MAX_QUOTA / num_active_macs;
		quota_rem = IWM_MAX_QUOTA % num_active_macs;
	}

	for (idx = 0, i = 0; i < IWM_MAX_BINDINGS; i++) {
		if (colors[i] < 0)
			continue;

		cmd.quotas[idx].id_and_color =
			htole32(IWM_FW_CMD_ID_AND_COLOR(i, colors[i]));

		if (n_ifs[i] <= 0) {
			cmd.quotas[idx].quota = htole32(0);
			cmd.quotas[idx].max_duration = htole32(0);
		} else {
			cmd.quotas[idx].quota = htole32(quota * n_ifs[i]);
			cmd.quotas[idx].max_duration = htole32(0);
		}
		idx++;
	}

	/* Give the remainder of the session to the first binding */
	cmd.quotas[0].quota = htole32(le32toh(cmd.quotas[0].quota) + quota_rem);

	return iwm_send_cmd_pdu(sc, IWM_TIME_QUOTA_CMD, 0,
	    sizeof(cmd), &cmd);
}

int
iwm_auth(struct iwm_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_node *in = (void *)ic->ic_bss;
	uint32_t duration;
	int err;

	err = iwm_sf_config(sc, IWM_SF_FULL_ON);
	if (err)
		return err;

	err = iwm_allow_mcast(sc);
	if (err)
		return err;

	sc->sc_phyctxt[0].channel = in->in_ni.ni_chan;
	err = iwm_phy_ctxt_cmd(sc, &sc->sc_phyctxt[0], 1, 1,
	    IWM_FW_CTXT_ACTION_MODIFY, 0);
	if (err)
		return err;
	in->in_phyctxt = &sc->sc_phyctxt[0];

	err = iwm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_ADD, 0);
	if (err) {
		printf("%s: could not add MAC context (error %d)\n",
		    DEVNAME(sc), err);
		return err;
 	}

	err = iwm_binding_cmd(sc, in, IWM_FW_CTXT_ACTION_ADD);
	if (err)
		return err;

	err = iwm_add_sta_cmd(sc, in, 0);
	if (err)
		return err;

	err = iwm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY, 0);
	if (err) {
		printf("%s: failed to update MAC\n", DEVNAME(sc));
		return err;
	}

	/*
	 * Prevent the FW from wandering off channel during association
	 * by "protecting" the session with a time event.
	 */
	if (in->in_ni.ni_intval)
		duration = in->in_ni.ni_intval * 2;
	else
		duration = IEEE80211_DUR_TU; 
	iwm_protect_session(sc, in, duration, in->in_ni.ni_intval / 2);
	DELAY(100);

	return 0;
}

int
iwm_assoc(struct iwm_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_node *in = (void *)ic->ic_bss;
	int err;

	err = iwm_add_sta_cmd(sc, in, 1);
	if (err)
		return err;

	return 0;
}

struct ieee80211_node *
iwm_node_alloc(struct ieee80211com *ic)
{
	return malloc(sizeof (struct iwm_node), M_DEVBUF, M_NOWAIT | M_ZERO);
}

void
iwm_calib_timeout(void *arg)
{
	struct iwm_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_node *in = (void *)ic->ic_bss;
	struct ieee80211_node *ni = &in->in_ni;
	int s, otxrate;

	s = splnet();
	if ((ic->ic_fixed_rate == -1 || ic->ic_fixed_mcs == -1) &&
	    ((ni->ni_flags & IEEE80211_NODE_HT) == 0) &&
	    ic->ic_opmode == IEEE80211_M_STA && ic->ic_bss) {
		otxrate = ni->ni_txrate;
		ieee80211_amrr_choose(&sc->sc_amrr, &in->in_ni, &in->in_amn);
		/* 
		 * If AMRR has chosen a new TX rate we must update
		 * the firwmare's LQ rate table from process context.
		 */
		if (otxrate != ni->ni_txrate)
			task_add(systq, &sc->setrates_task);
	}
	splx(s);

	timeout_add_msec(&sc->sc_calib_to, 500);
}

void
iwm_setrates_task(void *arg)
{
	struct iwm_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_node *in = (struct iwm_node *)ic->ic_bss;

	/* Update rates table based on new TX rate determined by AMRR. */
	iwm_setrates(in);
}

void
iwm_setrates(struct iwm_node *in)
{
	struct ieee80211_node *ni = &in->in_ni;
	struct ieee80211com *ic = ni->ni_ic;
	struct iwm_softc *sc = IC2IFP(ic)->if_softc;
	struct iwm_lq_cmd *lq = &in->in_lq;
	struct ieee80211_rateset *rs = &ni->ni_rates;
	int i, ridx, ridx_min, ridx_max, j, sgi_ok, mimo, tab = 0;
	struct iwm_host_cmd cmd = {
		.id = IWM_LQ_CMD,
		.len = { sizeof(in->in_lq), },
	};

	memset(lq, 0, sizeof(*lq));
	lq->sta_id = IWM_STATION_ID;

	if (ic->ic_flags & IEEE80211_F_USEPROT)
		lq->flags |= IWM_LQ_FLAG_USE_RTS_MSK;

	sgi_ok = ((ni->ni_flags & IEEE80211_NODE_HT) &&
	    (ni->ni_htcaps & IEEE80211_HTCAP_SGI20));

	/*
	 * Fill the LQ rate selection table with legacy and/or HT rates
	 * in descending order, i.e. with the node's current TX rate first.
	 * In cases where throughput of an HT rate corresponds to a legacy
	 * rate it makes no sense to add both. We rely on the fact that
	 * iwm_rates is laid out such that equivalent HT/legacy rates share
	 * the same IWM_RATE_*_INDEX value. Also, rates not applicable to
	 * legacy/HT are assumed to be marked with an 'invalid' PLCP value.
	 */
	j = 0;
	ridx_min = iwm_rval2ridx(ieee80211_min_basic_rate(ic));
	mimo = iwm_is_mimo_mcs(ni->ni_txmcs);
	ridx_max = (mimo ? IWM_RIDX_MAX : IWM_LAST_HT_SISO_RATE);
	for (ridx = ridx_max; ridx >= ridx_min; ridx--) {
		uint8_t plcp = iwm_rates[ridx].plcp;
		uint8_t ht_plcp = iwm_rates[ridx].ht_plcp;

		if (j >= nitems(lq->rs_table))
			break;
		tab = 0;
		if (ni->ni_flags & IEEE80211_NODE_HT) {
		    	if (ht_plcp == IWM_RATE_HT_SISO_MCS_INV_PLCP)
				continue;
	 		/* Do not mix SISO and MIMO HT rates. */
			if ((mimo && !iwm_is_mimo_ht_plcp(ht_plcp)) ||
			    (!mimo && iwm_is_mimo_ht_plcp(ht_plcp)))
				continue;
			for (i = ni->ni_txmcs; i >= 0; i--) {
				if (isclr(ni->ni_rxmcs, i))
					continue;
				if (ridx == iwm_mcs2ridx[i]) {
					tab = ht_plcp;
					tab |= IWM_RATE_MCS_HT_MSK;
					if (sgi_ok)
						tab |= IWM_RATE_MCS_SGI_MSK;
					break;
				}
			}
		} else if (plcp != IWM_RATE_INVM_PLCP) {
			for (i = ni->ni_txrate; i >= 0; i--) {
				if (iwm_rates[ridx].rate == (rs->rs_rates[i] &
				    IEEE80211_RATE_VAL)) {
					tab = plcp;
					break;
				}
			}
		}

		if (tab == 0)
			continue;

		if (iwm_is_mimo_ht_plcp(ht_plcp))
			tab |= IWM_RATE_MCS_ANT_AB_MSK;
		else
			tab |= IWM_RATE_MCS_ANT_A_MSK;

		if (IWM_RIDX_IS_CCK(ridx))
			tab |= IWM_RATE_MCS_CCK_MSK;
		lq->rs_table[j++] = htole32(tab);
	}

	lq->mimo_delim = (mimo ? j : 0);

	/* Fill the rest with the lowest possible rate */
	while (j < nitems(lq->rs_table)) {
		tab = iwm_rates[ridx_min].plcp;
		if (IWM_RIDX_IS_CCK(ridx_min))
			tab |= IWM_RATE_MCS_CCK_MSK;
		tab |= IWM_RATE_MCS_ANT_A_MSK;
		lq->rs_table[j++] = htole32(tab);
	}

	lq->single_stream_ant_msk = IWM_ANT_A;
	lq->dual_stream_ant_msk = IWM_ANT_AB;

	lq->agg_time_limit = htole16(4000);	/* 4ms */
	lq->agg_disable_start_th = 3;
#ifdef notyet
	lq->agg_frame_cnt_limit = 0x3f;
#else
	lq->agg_frame_cnt_limit = 1; /* tx agg disabled */
#endif

	cmd.data[0] = &in->in_lq;
	iwm_send_cmd(sc, &cmd);
}

int
iwm_media_change(struct ifnet *ifp)
{
	struct iwm_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t rate, ridx;
	int err;

	err = ieee80211_media_change(ifp);
	if (err != ENETRESET)
		return err;

	if (ic->ic_fixed_mcs != -1)
		sc->sc_fixed_ridx = iwm_mcs2ridx[ic->ic_fixed_mcs];
	else if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate] & IEEE80211_RATE_VAL;
		/* Map 802.11 rate to HW rate index. */
		for (ridx = 0; ridx <= IWM_RIDX_MAX; ridx++)
			if (iwm_rates[ridx].rate == rate)
				break;
		sc->sc_fixed_ridx = ridx;
	}

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
	    (IFF_UP | IFF_RUNNING)) {
		iwm_stop(ifp, 0);
		err = iwm_init(ifp);
	}
	return err;
}

void
iwm_newstate_task(void *psc)
{
	struct iwm_softc *sc = (struct iwm_softc *)psc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = IC2IFP(ic);
	enum ieee80211_state nstate = sc->ns_nstate;
	enum ieee80211_state ostate = ic->ic_state;
	struct iwm_node *in = (struct iwm_node *)ic->ic_bss;
	int arg = sc->ns_arg;
	int err;

	DPRINTF(("switching state %s->%s\n",
	    ieee80211_state_name[ostate],
	    ieee80211_state_name[nstate]));

	if (ostate == IEEE80211_S_SCAN && nstate != ostate)
		iwm_led_blink_stop(sc);

	if (ostate == IEEE80211_S_RUN && nstate != ostate)
		iwm_disable_beacon_filter(sc);

	/* Reset the device if moving out of AUTH, ASSOC, or RUN. */
	/* XXX Is there a way to switch states without a full reset? */
	if (ostate > IEEE80211_S_SCAN && nstate < ostate) {
		iwm_stop_device(sc);
		err = iwm_init_hw(sc);
		if (err) {
			iwm_stop(ifp, 1);
			return;
		}

		/* 
		 * Upon receiving a deauth frame from AP the net80211 stack
		 * puts the driver into AUTH state. This will fail with this
		 * driver so bring the FSM from RUN to SCAN in this case.
		 */
		if (nstate == IEEE80211_S_SCAN ||
		    nstate == IEEE80211_S_AUTH ||
		    nstate == IEEE80211_S_ASSOC) {
			/* Always pass arg as -1 since we can't Tx right now. */
			sc->sc_newstate(ic, IEEE80211_S_INIT, -1);
			nstate = IEEE80211_S_SCAN;
		}
	}

	switch (nstate) {
	case IEEE80211_S_INIT:
		break;

	case IEEE80211_S_SCAN:
		if (ic->ic_state == nstate &&
		    (sc->sc_flags & IWM_FLAG_SCANNING))
			return;
		if (isset(sc->sc_enabled_capa, IWM_UCODE_TLV_CAPA_UMAC_SCAN))
			err = iwm_umac_scan(sc);
		else
			err = iwm_lmac_scan(sc);
		if (err) {
			printf("%s: could not initiate scan\n", DEVNAME(sc));
			return;
		}
		sc->sc_flags |= IWM_FLAG_SCANNING;
		ic->ic_state = nstate;
		iwm_led_blink_start(sc);
		wakeup(&ic->ic_state); /* wake iwm_init() */
		return;

	case IEEE80211_S_AUTH:
		err = iwm_auth(sc);
		if (err)
			return;

		break;

	case IEEE80211_S_ASSOC:
		err = iwm_assoc(sc);
		if (err)
			return;
		break;

	case IEEE80211_S_RUN:
		/* Configure Rx chains for MIMO. */
		if ((in->in_ni.ni_flags & IEEE80211_NODE_HT) &&
		    !sc->sc_nvm.sku_cap_mimo_disable) {
			err = iwm_phy_ctxt_cmd(sc, &sc->sc_phyctxt[0],
			    2, 2, IWM_FW_CTXT_ACTION_MODIFY, 0);
			if (err) {
				printf("%s: failed to update PHY\n",
				    DEVNAME(sc));
				return;
			}
		}

		/* We have now been assigned an associd by the AP. */
		err = iwm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY, 1);
		if (err) {
			printf("%s: failed to update MAC\n", DEVNAME(sc));
			return;
		}

		err = iwm_power_update_device(sc);
		if (err) {
			printf("%s: could send power command (error %d)\n",
			    DEVNAME(sc), err);
			return;
		}
#ifdef notyet
		/* 
		 * Disabled for now. Default beacon filter settings
		 * prevent net80211 from getting ERP and HT protection
		 * updates from beacons.
		 */
		err = iwm_enable_beacon_filter(sc, in);
		if (err) {
			printf("%s: could not enable beacon filter\n",
			    DEVNAME(sc));
			return;
		}
#endif
		err = iwm_power_mac_update_mode(sc, in);
		if (err) {
			printf("%s: could not update MAC power (error %d)\n",
			    DEVNAME(sc), err);
			return;
		}

		err = iwm_update_quotas(sc, in);
		if (err) {
			printf("%s: could not update quotas (error %d)\n",
			    DEVNAME(sc), err);
			return;
		}

		ieee80211_amrr_node_init(&sc->sc_amrr, &in->in_amn);
		ieee80211_mira_node_init(&in->in_mn);

		/* Start at lowest available bit-rate, AMRR will raise. */
		in->in_ni.ni_txrate = 0;
		in->in_ni.ni_txmcs = 0;
		iwm_setrates(in);

		timeout_add_msec(&sc->sc_calib_to, 500);
		iwm_led_enable(sc);
		break;

	default:
		break;
	}

	sc->sc_newstate(ic, nstate, arg);
}

int
iwm_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ifnet *ifp = IC2IFP(ic);
	struct iwm_softc *sc = ifp->if_softc;
	struct iwm_node *in = (void *)ic->ic_bss;

	timeout_del(&sc->sc_calib_to);
	if (ic->ic_state == IEEE80211_S_RUN)
		ieee80211_mira_cancel_timeouts(&in->in_mn);

	sc->ns_nstate = nstate;
	sc->ns_arg = arg;

	task_add(sc->sc_nswq, &sc->newstate_task);

	return 0;
}

void
iwm_endscan_cb(void *arg)
{
	struct iwm_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;

	/* Check if device was reset while scanning. */
	if (ic->ic_state != IEEE80211_S_SCAN)
		return;

	sc->sc_flags &= ~IWM_FLAG_SCANNING;
	ieee80211_end_scan(&ic->ic_if);
}

/*
 * Aging and idle timeouts for the different possible scenarios
 * in default configuration
 */
static const uint32_t
iwm_sf_full_timeout_def[IWM_SF_NUM_SCENARIO][IWM_SF_NUM_TIMEOUT_TYPES] = {
	{
		htole32(IWM_SF_SINGLE_UNICAST_AGING_TIMER_DEF),
		htole32(IWM_SF_SINGLE_UNICAST_IDLE_TIMER_DEF)
	},
	{
		htole32(IWM_SF_AGG_UNICAST_AGING_TIMER_DEF),
		htole32(IWM_SF_AGG_UNICAST_IDLE_TIMER_DEF)
	},
	{
		htole32(IWM_SF_MCAST_AGING_TIMER_DEF),
		htole32(IWM_SF_MCAST_IDLE_TIMER_DEF)
	},
	{
		htole32(IWM_SF_BA_AGING_TIMER_DEF),
		htole32(IWM_SF_BA_IDLE_TIMER_DEF)
	},
	{
		htole32(IWM_SF_TX_RE_AGING_TIMER_DEF),
		htole32(IWM_SF_TX_RE_IDLE_TIMER_DEF)
	},
};

/*
 * Aging and idle timeouts for the different possible scenarios
 * in single BSS MAC configuration.
 */
static const uint32_t
iwm_sf_full_timeout[IWM_SF_NUM_SCENARIO][IWM_SF_NUM_TIMEOUT_TYPES] = {
	{
		htole32(IWM_SF_SINGLE_UNICAST_AGING_TIMER),
		htole32(IWM_SF_SINGLE_UNICAST_IDLE_TIMER)
	},
	{
		htole32(IWM_SF_AGG_UNICAST_AGING_TIMER),
		htole32(IWM_SF_AGG_UNICAST_IDLE_TIMER)
	},
	{
		htole32(IWM_SF_MCAST_AGING_TIMER),
		htole32(IWM_SF_MCAST_IDLE_TIMER)
	},
	{
		htole32(IWM_SF_BA_AGING_TIMER),
		htole32(IWM_SF_BA_IDLE_TIMER)
	},
	{
		htole32(IWM_SF_TX_RE_AGING_TIMER),
		htole32(IWM_SF_TX_RE_IDLE_TIMER)
	},
};

void
iwm_fill_sf_command(struct iwm_softc *sc, struct iwm_sf_cfg_cmd *sf_cmd,
    struct ieee80211_node *ni)
{
	int i, j, watermark;

	sf_cmd->watermark[IWM_SF_LONG_DELAY_ON] = htole32(IWM_SF_W_MARK_SCAN);

	/*
	 * If we are in association flow - check antenna configuration
	 * capabilities of the AP station, and choose the watermark accordingly.
	 */
	if (ni) {
		if (ni->ni_flags & IEEE80211_NODE_HT) {
			if (ni->ni_rxmcs[1] != 0)
				watermark = IWM_SF_W_MARK_MIMO2;
			else
				watermark = IWM_SF_W_MARK_SISO;
		} else {
			watermark = IWM_SF_W_MARK_LEGACY;
		}
	/* default watermark value for unassociated mode. */
	} else {
		watermark = IWM_SF_W_MARK_MIMO2;
	}
	sf_cmd->watermark[IWM_SF_FULL_ON] = htole32(watermark);

	for (i = 0; i < IWM_SF_NUM_SCENARIO; i++) {
		for (j = 0; j < IWM_SF_NUM_TIMEOUT_TYPES; j++) {
			sf_cmd->long_delay_timeouts[i][j] =
					htole32(IWM_SF_LONG_DELAY_AGING_TIMER);
		}
	}

	if (ni) {
		memcpy(sf_cmd->full_on_timeouts, iwm_sf_full_timeout,
		       sizeof(iwm_sf_full_timeout));
	} else {
		memcpy(sf_cmd->full_on_timeouts, iwm_sf_full_timeout_def,
		       sizeof(iwm_sf_full_timeout_def));
	}

}

int
iwm_sf_config(struct iwm_softc *sc, int new_state)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_sf_cfg_cmd sf_cmd = {
		.state = htole32(IWM_SF_FULL_ON),
	};
	int err = 0;

	if (sc->sc_device_family == IWM_DEVICE_FAMILY_8000)
		sf_cmd.state |= htole32(IWM_SF_CFG_DUMMY_NOTIF_OFF);

	switch (new_state) {
	case IWM_SF_UNINIT:
	case IWM_SF_INIT_OFF:
		iwm_fill_sf_command(sc, &sf_cmd, NULL);
		break;
	case IWM_SF_FULL_ON:
		iwm_fill_sf_command(sc, &sf_cmd, ic->ic_bss);
		break;
	default:
		return EINVAL;
	}

	err = iwm_send_cmd_pdu(sc, IWM_REPLY_SF_CFG_CMD, IWM_CMD_ASYNC,
				   sizeof(sf_cmd), &sf_cmd);
	return err;
}

int
iwm_send_bt_init_conf(struct iwm_softc *sc)
{
	struct iwm_bt_coex_cmd bt_cmd;

	bt_cmd.mode = htole32(IWM_BT_COEX_WIFI);
	bt_cmd.enabled_modules = htole32(IWM_BT_COEX_HIGH_BAND_RET);

	return iwm_send_cmd_pdu(sc, IWM_BT_CONFIG, 0, sizeof(bt_cmd),
	    &bt_cmd);
}

int
iwm_send_update_mcc_cmd(struct iwm_softc *sc, const char *alpha2)
{
	struct iwm_mcc_update_cmd mcc_cmd;
	struct iwm_host_cmd hcmd = {
		.id = IWM_MCC_UPDATE_CMD,
		.flags = IWM_CMD_WANT_SKB,
		.data = { &mcc_cmd },
	};
	int err;
	int resp_v2 = isset(sc->sc_enabled_capa,
	    IWM_UCODE_TLV_CAPA_LAR_SUPPORT_V2);

	memset(&mcc_cmd, 0, sizeof(mcc_cmd));
	mcc_cmd.mcc = htole16(alpha2[0] << 8 | alpha2[1]);
	if ((sc->sc_ucode_api & IWM_UCODE_TLV_API_WIFI_MCC_UPDATE) ||
	    isset(sc->sc_enabled_capa, IWM_UCODE_TLV_CAPA_LAR_MULTI_MCC))
		mcc_cmd.source_id = IWM_MCC_SOURCE_GET_CURRENT;
	else
		mcc_cmd.source_id = IWM_MCC_SOURCE_OLD_FW;

	if (resp_v2)
		hcmd.len[0] = sizeof(struct iwm_mcc_update_cmd);
	else
		hcmd.len[0] = sizeof(struct iwm_mcc_update_cmd_v1);

	err = iwm_send_cmd(sc, &hcmd);
	if (err)
		return err;

	iwm_free_resp(sc, &hcmd);

	return 0;
}

void
iwm_tt_tx_backoff(struct iwm_softc *sc, uint32_t backoff)
{
	struct iwm_host_cmd cmd = {
		.id = IWM_REPLY_THERMAL_MNG_BACKOFF,
		.len = { sizeof(uint32_t), },
		.data = { &backoff, },
	};

	iwm_send_cmd(sc, &cmd);
}

int
iwm_init_hw(struct iwm_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int err, i, ac;

	err = iwm_preinit(sc);
	if (err)
		return err;

	err = iwm_start_hw(sc);
	if (err) {
		printf("%s: could not initialize hardware\n", DEVNAME(sc));
		return err;
	}

	err = iwm_run_init_mvm_ucode(sc, 0);
	if (err)
		return err;

	/* Should stop and start HW since INIT image just loaded. */
	iwm_stop_device(sc);
	err = iwm_start_hw(sc);
	if (err) {
		printf("%s: could not initialize hardware\n", DEVNAME(sc));
		return err;
	}

	/* Restart, this time with the regular firmware */
	err = iwm_load_ucode_wait_alive(sc, IWM_UCODE_TYPE_REGULAR);
	if (err) {
		printf("%s: could not load firmware\n", DEVNAME(sc));
		goto err;
	}

	if (!iwm_nic_lock(sc))
		return EBUSY;

	err = iwm_send_bt_init_conf(sc);
	if (err) {
		printf("%s: could not init bt coex (error %d)\n",
		    DEVNAME(sc), err);
		goto err;
	}

	err = iwm_send_tx_ant_cfg(sc, iwm_fw_valid_tx_ant(sc));
	if (err) {
		printf("%s: could not init tx ant config (error %d)\n",
		    DEVNAME(sc), err);
		goto err;
	}

	err = iwm_send_phy_db_data(sc);
	if (err) {
		printf("%s: could not init phy db (error %d)\n",
		    DEVNAME(sc), err);
		goto err;
	}

	err = iwm_send_phy_cfg_cmd(sc);
	if (err) {
		printf("%s: could not send phy config (error %d)\n",
		    DEVNAME(sc), err);
		goto err;
	}

	/* Add auxiliary station for scanning */
	err = iwm_add_aux_sta(sc);
	if (err) {
		printf("%s: could not add aux station (error %d)\n",
		    DEVNAME(sc), err);
		goto err;
	}

	for (i = 0; i < 1; i++) {
		/*
		 * The channel used here isn't relevant as it's
		 * going to be overwritten in the other flows.
		 * For now use the first channel we have.
		 */
		sc->sc_phyctxt[i].channel = &ic->ic_channels[1];
		err = iwm_phy_ctxt_cmd(sc, &sc->sc_phyctxt[i], 1, 1,
		    IWM_FW_CTXT_ACTION_ADD, 0);
		if (err) {
			printf("%s: could not add phy context %d (error %d)\n",
			    DEVNAME(sc), i, err);
			goto err;
		}
	}

	/* Initialize tx backoffs to the minimum. */
	if (sc->sc_device_family == IWM_DEVICE_FAMILY_7000)
		iwm_tt_tx_backoff(sc, 0);

	err = iwm_power_update_device(sc);
	if (err) {
		printf("%s: could send power command (error %d)\n",
		    DEVNAME(sc), err);
		goto err;
	}

	if (isset(sc->sc_enabled_capa, IWM_UCODE_TLV_CAPA_LAR_SUPPORT)) {
		err = iwm_send_update_mcc_cmd(sc, "ZZ");
		if (err) {
			printf("%s: could not init LAR (error %d)\n",
			    DEVNAME(sc), err);
			goto err;
		}
	}

	if (isset(sc->sc_enabled_capa, IWM_UCODE_TLV_CAPA_UMAC_SCAN)) {
		err = iwm_config_umac_scan(sc);
		if (err) {
			printf("%s: could not configure scan (error %d)\n",
			    DEVNAME(sc), err);
			goto err;
		}
	}

	for (ac = 0; ac < EDCA_NUM_AC; ac++) {
		err = iwm_enable_txq(sc, IWM_STATION_ID, ac,
		    iwm_ac_to_tx_fifo[ac]);
		if (err) {
			printf("%s: could not enable Tx queue %d (error %d)\n",
			    DEVNAME(sc), ac, err);
			goto err;
		}
	}

	err = iwm_disable_beacon_filter(sc);
	if (err) {
		printf("%s: could not disable beacon filter (error %d)\n",
		    DEVNAME(sc), err);
		goto err;
	}

err:
	iwm_nic_unlock(sc);
	return err;
}

/* Allow multicast from our BSSID. */
int
iwm_allow_mcast(struct iwm_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct iwm_mcast_filter_cmd *cmd;
	size_t size;
	int err;

	size = roundup(sizeof(*cmd), 4);
	cmd = malloc(size, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (cmd == NULL)
		return ENOMEM;
	cmd->filter_own = 1;
	cmd->port_id = 0;
	cmd->count = 0;
	cmd->pass_all = 1;
	IEEE80211_ADDR_COPY(cmd->bssid, ni->ni_bssid);

	err = iwm_send_cmd_pdu(sc, IWM_MCAST_FILTER_CMD,
	    0, size, cmd);
	free(cmd, M_DEVBUF, size);
	return err;
}

int
iwm_init(struct ifnet *ifp)
{
	struct iwm_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int err, generation;

	sc->sc_generation++;

	err = iwm_init_hw(sc);
	if (err) {
		iwm_stop(ifp, 1);
		return err;
	}

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

	ieee80211_begin_scan(ifp);

	/* 
	 * ieee80211_begin_scan() ends up scheduling iwm_newstate_task().
	 * Wait until the transition to SCAN state has completed.
	 */
	generation = sc->sc_generation;
	do {
		err = tsleep(&ic->ic_state, PCATCH, "iwminit", hz);
		if (generation != sc->sc_generation)
			return ENXIO;
		if (err)
			return err;
	} while (ic->ic_state != IEEE80211_S_SCAN);

	return 0;
}

void
iwm_start(struct ifnet *ifp)
{
	struct iwm_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct ether_header *eh;
	struct mbuf *m;
	int ac = EDCA_AC_BE; /* XXX */

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		/* why isn't this done per-queue? */
		if (sc->qfullmsk != 0) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		/* need to send management frames even if we're not RUNning */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}
		if (ic->ic_state != IEEE80211_S_RUN) {
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (!m)
			break;
		if (m->m_len < sizeof (*eh) &&
		    (m = m_pullup(m, sizeof (*eh))) == NULL) {
			ifp->if_oerrors++;
			continue;
		}
#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		if ((m = ieee80211_encap(ifp, m, &ni)) == NULL) {
			ifp->if_oerrors++;
			continue;
		}

 sendit:
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		if (iwm_tx(sc, m, ni, ac) != 0) {
			ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		if (ifp->if_flags & IFF_UP) {
			sc->sc_tx_timer = 15;
			ifp->if_timer = 1;
		}
	}

	return;
}

void
iwm_stop(struct ifnet *ifp, int disable)
{
	struct iwm_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwm_node *in = (void *)ic->ic_bss;

	sc->sc_generation++;
	ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	in->in_phyctxt = NULL;
	if (ic->ic_state == IEEE80211_S_RUN)
		ieee80211_mira_cancel_timeouts(&in->in_mn);

	task_del(systq, &sc->init_task);
	task_del(sc->sc_nswq, &sc->newstate_task);
	task_del(sc->sc_eswq, &sc->sc_eswk);
	task_del(systq, &sc->setrates_task);
	task_del(systq, &sc->ba_task);
	task_del(systq, &sc->htprot_task);

	sc->sc_flags &= ~IWM_FLAG_SCANNING;
	sc->sc_newstate(ic, IEEE80211_S_INIT, -1);

	timeout_del(&sc->sc_calib_to);
	iwm_led_blink_stop(sc);
	ifp->if_timer = sc->sc_tx_timer = 0;
	iwm_stop_device(sc);
}

void
iwm_watchdog(struct ifnet *ifp)
{
	struct iwm_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;
	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", DEVNAME(sc));
#ifdef IWM_DEBUG
			iwm_nic_error(sc);
#endif
			task_add(systq, &sc->init_task);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
iwm_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct iwm_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, err = 0, generation = sc->sc_generation;

	/*
	 * Prevent processes from entering this function while another
	 * process is tsleep'ing in it.
	 */
	err = rw_enter(&sc->ioctl_rwl, RW_WRITE | RW_INTR);
	if (err == 0 && generation != sc->sc_generation) {
		rw_exit(&sc->ioctl_rwl);
		return ENXIO;
	}
	if (err)
		return err;
	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING)) {
				err = iwm_init(ifp);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				iwm_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		err = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);
		if (err == ENETRESET)
			err = 0;
		break;

	default:
		err = ieee80211_ioctl(ifp, cmd, data);
	}

	if (err == ENETRESET) {
		err = 0;
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING)) {
			iwm_stop(ifp, 0);
			err = iwm_init(ifp);
		}
	}

	splx(s);
	rw_exit(&sc->ioctl_rwl);

	return err;
}

#ifdef IWM_DEBUG
/*
 * Note: This structure is read from the device with IO accesses,
 * and the reading already does the endian conversion. As it is
 * read with uint32_t-sized accesses, any members with a different size
 * need to be ordered correctly though!
 */
struct iwm_error_event_table {
	uint32_t valid;		/* (nonzero) valid, (0) log is empty */
	uint32_t error_id;		/* type of error */
	uint32_t trm_hw_status0;	/* TRM HW status */
	uint32_t trm_hw_status1;	/* TRM HW status */
	uint32_t blink2;		/* branch link */
	uint32_t ilink1;		/* interrupt link */
	uint32_t ilink2;		/* interrupt link */
	uint32_t data1;		/* error-specific data */
	uint32_t data2;		/* error-specific data */
	uint32_t data3;		/* error-specific data */
	uint32_t bcon_time;		/* beacon timer */
	uint32_t tsf_low;		/* network timestamp function timer */
	uint32_t tsf_hi;		/* network timestamp function timer */
	uint32_t gp1;		/* GP1 timer register */
	uint32_t gp2;		/* GP2 timer register */
	uint32_t fw_rev_type;	/* firmware revision type */
	uint32_t major;		/* uCode version major */
	uint32_t minor;		/* uCode version minor */
	uint32_t hw_ver;		/* HW Silicon version */
	uint32_t brd_ver;		/* HW board version */
	uint32_t log_pc;		/* log program counter */
	uint32_t frame_ptr;		/* frame pointer */
	uint32_t stack_ptr;		/* stack pointer */
	uint32_t hcmd;		/* last host command header */
	uint32_t isr0;		/* isr status register LMPM_NIC_ISR0:
				 * rxtx_flag */
	uint32_t isr1;		/* isr status register LMPM_NIC_ISR1:
				 * host_flag */
	uint32_t isr2;		/* isr status register LMPM_NIC_ISR2:
				 * enc_flag */
	uint32_t isr3;		/* isr status register LMPM_NIC_ISR3:
				 * time_flag */
	uint32_t isr4;		/* isr status register LMPM_NIC_ISR4:
				 * wico interrupt */
	uint32_t last_cmd_id;	/* last HCMD id handled by the firmware */
	uint32_t wait_event;		/* wait event() caller address */
	uint32_t l2p_control;	/* L2pControlField */
	uint32_t l2p_duration;	/* L2pDurationField */
	uint32_t l2p_mhvalid;	/* L2pMhValidBits */
	uint32_t l2p_addr_match;	/* L2pAddrMatchStat */
	uint32_t lmpm_pmg_sel;	/* indicate which clocks are turned on
				 * (LMPM_PMG_SEL) */
	uint32_t u_timestamp;	/* indicate when the date and time of the
				 * compilation */
	uint32_t flow_handler;	/* FH read/write pointers, RX credit */
} __packed /* LOG_ERROR_TABLE_API_S_VER_3 */;

/*
 * UMAC error struct - relevant starting from family 8000 chip.
 * Note: This structure is read from the device with IO accesses,
 * and the reading already does the endian conversion. As it is
 * read with u32-sized accesses, any members with a different size
 * need to be ordered correctly though!
 */
struct iwm_umac_error_event_table {
	uint32_t valid;		/* (nonzero) valid, (0) log is empty */
	uint32_t error_id;	/* type of error */
	uint32_t blink1;	/* branch link */
	uint32_t blink2;	/* branch link */
	uint32_t ilink1;	/* interrupt link */
	uint32_t ilink2;	/* interrupt link */
	uint32_t data1;		/* error-specific data */
	uint32_t data2;		/* error-specific data */
	uint32_t data3;		/* error-specific data */
	uint32_t umac_major;
	uint32_t umac_minor;
	uint32_t frame_pointer;	/* core register 27*/
	uint32_t stack_pointer;	/* core register 28 */
	uint32_t cmd_header;	/* latest host cmd sent to UMAC */
	uint32_t nic_isr_pref;	/* ISR status register */
} __packed;

#define ERROR_START_OFFSET  (1 * sizeof(uint32_t))
#define ERROR_ELEM_SIZE     (7 * sizeof(uint32_t))

void
iwm_nic_umac_error(struct iwm_softc *sc)
{
	struct iwm_umac_error_event_table table;
	uint32_t base;

	base = sc->sc_uc.uc_umac_error_event_table;

	if (base < 0x800000) {
		printf("%s: Invalid error log pointer 0x%08x\n",
		    DEVNAME(sc), base);
		return;
	}

	if (iwm_read_mem(sc, base, &table, sizeof(table)/sizeof(uint32_t))) {
		printf("%s: reading errlog failed\n", DEVNAME(sc));
		return;
	}

	if (ERROR_START_OFFSET <= table.valid * ERROR_ELEM_SIZE) {
		printf("%s: Start UMAC Error Log Dump:\n", DEVNAME(sc));
		printf("%s: Status: 0x%x, count: %d\n", DEVNAME(sc),
			sc->sc_flags, table.valid);
	}

	printf("%s: 0x%08X | %s\n", DEVNAME(sc), table.error_id,
		iwm_desc_lookup(table.error_id));
	printf("%s: 0x%08X | umac branchlink1\n", DEVNAME(sc), table.blink1);
	printf("%s: 0x%08X | umac branchlink2\n", DEVNAME(sc), table.blink2);
	printf("%s: 0x%08X | umac interruptlink1\n", DEVNAME(sc), table.ilink1);
	printf("%s: 0x%08X | umac interruptlink2\n", DEVNAME(sc), table.ilink2);
	printf("%s: 0x%08X | umac data1\n", DEVNAME(sc), table.data1);
	printf("%s: 0x%08X | umac data2\n", DEVNAME(sc), table.data2);
	printf("%s: 0x%08X | umac data3\n", DEVNAME(sc), table.data3);
	printf("%s: 0x%08X | umac major\n", DEVNAME(sc), table.umac_major);
	printf("%s: 0x%08X | umac minor\n", DEVNAME(sc), table.umac_minor);
	printf("%s: 0x%08X | frame pointer\n", DEVNAME(sc),
	    table.frame_pointer);
	printf("%s: 0x%08X | stack pointer\n", DEVNAME(sc),
	    table.stack_pointer);
	printf("%s: 0x%08X | last host cmd\n", DEVNAME(sc), table.cmd_header);
	printf("%s: 0x%08X | isr status reg\n", DEVNAME(sc),
	    table.nic_isr_pref);
}

struct {
	const char *name;
	uint8_t num;
} advanced_lookup[] = {
	{ "NMI_INTERRUPT_WDG", 0x34 },
	{ "SYSASSERT", 0x35 },
	{ "UCODE_VERSION_MISMATCH", 0x37 },
	{ "BAD_COMMAND", 0x38 },
	{ "NMI_INTERRUPT_DATA_ACTION_PT", 0x3C },
	{ "FATAL_ERROR", 0x3D },
	{ "NMI_TRM_HW_ERR", 0x46 },
	{ "NMI_INTERRUPT_TRM", 0x4C },
	{ "NMI_INTERRUPT_BREAK_POINT", 0x54 },
	{ "NMI_INTERRUPT_WDG_RXF_FULL", 0x5C },
	{ "NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL", 0x64 },
	{ "NMI_INTERRUPT_HOST", 0x66 },
	{ "NMI_INTERRUPT_ACTION_PT", 0x7C },
	{ "NMI_INTERRUPT_UNKNOWN", 0x84 },
	{ "NMI_INTERRUPT_INST_ACTION_PT", 0x86 },
	{ "ADVANCED_SYSASSERT", 0 },
};

const char *
iwm_desc_lookup(uint32_t num)
{
	int i;

	for (i = 0; i < nitems(advanced_lookup) - 1; i++)
		if (advanced_lookup[i].num == num)
			return advanced_lookup[i].name;

	/* No entry matches 'num', so it is the last: ADVANCED_SYSASSERT */
	return advanced_lookup[i].name;
}

/*
 * Support for dumping the error log seemed like a good idea ...
 * but it's mostly hex junk and the only sensible thing is the
 * hw/ucode revision (which we know anyway).  Since it's here,
 * I'll just leave it in, just in case e.g. the Intel guys want to
 * help us decipher some "ADVANCED_SYSASSERT" later.
 */
void
iwm_nic_error(struct iwm_softc *sc)
{
	struct iwm_error_event_table table;
	uint32_t base;

	printf("%s: dumping device error log\n", DEVNAME(sc));
	base = sc->sc_uc.uc_error_event_table;
	if (base < 0x800000) {
		printf("%s: Invalid error log pointer 0x%08x\n",
		    DEVNAME(sc), base);
		return;
	}

	if (iwm_read_mem(sc, base, &table, sizeof(table)/sizeof(uint32_t))) {
		printf("%s: reading errlog failed\n", DEVNAME(sc));
		return;
	}

	if (!table.valid) {
		printf("%s: errlog not found, skipping\n", DEVNAME(sc));
		return;
	}

	if (ERROR_START_OFFSET <= table.valid * ERROR_ELEM_SIZE) {
		printf("%s: Start Error Log Dump:\n", DEVNAME(sc));
		printf("%s: Status: 0x%x, count: %d\n", DEVNAME(sc),
		    sc->sc_flags, table.valid);
	}

	printf("%s: 0x%08X | %-28s\n", DEVNAME(sc), table.error_id,
	    iwm_desc_lookup(table.error_id));
	printf("%s: %08X | trm_hw_status0\n", DEVNAME(sc),
	    table.trm_hw_status0);
	printf("%s: %08X | trm_hw_status1\n", DEVNAME(sc),
	    table.trm_hw_status1);
	printf("%s: %08X | branchlink2\n", DEVNAME(sc), table.blink2);
	printf("%s: %08X | interruptlink1\n", DEVNAME(sc), table.ilink1);
	printf("%s: %08X | interruptlink2\n", DEVNAME(sc), table.ilink2);
	printf("%s: %08X | data1\n", DEVNAME(sc), table.data1);
	printf("%s: %08X | data2\n", DEVNAME(sc), table.data2);
	printf("%s: %08X | data3\n", DEVNAME(sc), table.data3);
	printf("%s: %08X | beacon time\n", DEVNAME(sc), table.bcon_time);
	printf("%s: %08X | tsf low\n", DEVNAME(sc), table.tsf_low);
	printf("%s: %08X | tsf hi\n", DEVNAME(sc), table.tsf_hi);
	printf("%s: %08X | time gp1\n", DEVNAME(sc), table.gp1);
	printf("%s: %08X | time gp2\n", DEVNAME(sc), table.gp2);
	printf("%s: %08X | uCode revision type\n", DEVNAME(sc),
	    table.fw_rev_type);
	printf("%s: %08X | uCode version major\n", DEVNAME(sc),
	    table.major);
	printf("%s: %08X | uCode version minor\n", DEVNAME(sc),
	    table.minor);
	printf("%s: %08X | hw version\n", DEVNAME(sc), table.hw_ver);
	printf("%s: %08X | board version\n", DEVNAME(sc), table.brd_ver);
	printf("%s: %08X | hcmd\n", DEVNAME(sc), table.hcmd);
	printf("%s: %08X | isr0\n", DEVNAME(sc), table.isr0);
	printf("%s: %08X | isr1\n", DEVNAME(sc), table.isr1);
	printf("%s: %08X | isr2\n", DEVNAME(sc), table.isr2);
	printf("%s: %08X | isr3\n", DEVNAME(sc), table.isr3);
	printf("%s: %08X | isr4\n", DEVNAME(sc), table.isr4);
	printf("%s: %08X | last cmd Id\n", DEVNAME(sc), table.last_cmd_id);
	printf("%s: %08X | wait_event\n", DEVNAME(sc), table.wait_event);
	printf("%s: %08X | l2p_control\n", DEVNAME(sc), table.l2p_control);
	printf("%s: %08X | l2p_duration\n", DEVNAME(sc), table.l2p_duration);
	printf("%s: %08X | l2p_mhvalid\n", DEVNAME(sc), table.l2p_mhvalid);
	printf("%s: %08X | l2p_addr_match\n", DEVNAME(sc), table.l2p_addr_match);
	printf("%s: %08X | lmpm_pmg_sel\n", DEVNAME(sc), table.lmpm_pmg_sel);
	printf("%s: %08X | timestamp\n", DEVNAME(sc), table.u_timestamp);
	printf("%s: %08X | flow_handler\n", DEVNAME(sc), table.flow_handler);

	if (sc->sc_uc.uc_umac_error_event_table)
		iwm_nic_umac_error(sc);
}
#endif

#define SYNC_RESP_STRUCT(_var_, _pkt_)					\
do {									\
	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof(*(_pkt_)),	\
	    sizeof(*(_var_)), BUS_DMASYNC_POSTREAD);			\
	_var_ = (void *)((_pkt_)+1);					\
} while (/*CONSTCOND*/0)

#define SYNC_RESP_PTR(_ptr_, _len_, _pkt_)				\
do {									\
	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof(*(_pkt_)),	\
	    sizeof(len), BUS_DMASYNC_POSTREAD);				\
	_ptr_ = (void *)((_pkt_)+1);					\
} while (/*CONSTCOND*/0)

#define ADVANCE_RXQ(sc) (sc->rxq.cur = (sc->rxq.cur + 1) % IWM_RX_RING_COUNT);

void
iwm_notif_intr(struct iwm_softc *sc)
{
	uint16_t hw;

	bus_dmamap_sync(sc->sc_dmat, sc->rxq.stat_dma.map,
	    0, sc->rxq.stat_dma.size, BUS_DMASYNC_POSTREAD);

	hw = le16toh(sc->rxq.stat->closed_rb_num) & 0xfff;
	while (sc->rxq.cur != hw) {
		struct iwm_rx_data *data = &sc->rxq.data[sc->rxq.cur];
		struct iwm_rx_packet *pkt;
		struct iwm_cmd_response *cresp;
		int qid, idx, code;

		bus_dmamap_sync(sc->sc_dmat, data->map, 0, sizeof(*pkt),
		    BUS_DMASYNC_POSTREAD);
		pkt = mtod(data->m, struct iwm_rx_packet *);

		qid = pkt->hdr.qid & ~0x80;
		idx = pkt->hdr.idx;

		code = IWM_WIDE_ID(pkt->hdr.flags, pkt->hdr.code);

		/*
		 * randomly get these from the firmware, no idea why.
		 * they at least seem harmless, so just ignore them for now
		 */
		if (__predict_false((pkt->hdr.code == 0 && qid == 0 && idx == 0)
		    || pkt->len_n_flags == htole32(0x55550000))) {
			ADVANCE_RXQ(sc);
			continue;
		}

		switch (code) {
		case IWM_REPLY_RX_PHY_CMD:
			iwm_rx_rx_phy_cmd(sc, pkt, data);
			break;

		case IWM_REPLY_RX_MPDU_CMD:
			iwm_rx_rx_mpdu(sc, pkt, data);
			break;

		case IWM_TX_CMD:
			iwm_rx_tx_cmd(sc, pkt, data);
			break;

		case IWM_MISSED_BEACONS_NOTIFICATION:
			iwm_rx_bmiss(sc, pkt, data);
			break;

		case IWM_MFUART_LOAD_NOTIFICATION:
			break;

		case IWM_ALIVE: {
			struct iwm_alive_resp_v1 *resp1;
			struct iwm_alive_resp_v2 *resp2;
			struct iwm_alive_resp_v3 *resp3;

			if (iwm_rx_packet_payload_len(pkt) == sizeof(*resp1)) {
				SYNC_RESP_STRUCT(resp1, pkt);
				sc->sc_uc.uc_error_event_table
				    = le32toh(resp1->error_event_table_ptr);
				sc->sc_uc.uc_log_event_table
				    = le32toh(resp1->log_event_table_ptr);
				sc->sched_base = le32toh(resp1->scd_base_ptr);
				if (resp1->status == IWM_ALIVE_STATUS_OK)
					sc->sc_uc.uc_ok = 1;
				else
					sc->sc_uc.uc_ok = 0;
			}

			if (iwm_rx_packet_payload_len(pkt) == sizeof(*resp2)) {
				SYNC_RESP_STRUCT(resp2, pkt);
				sc->sc_uc.uc_error_event_table
				    = le32toh(resp2->error_event_table_ptr);
				sc->sc_uc.uc_log_event_table
				    = le32toh(resp2->log_event_table_ptr);
				sc->sched_base = le32toh(resp2->scd_base_ptr);
				sc->sc_uc.uc_umac_error_event_table
				    = le32toh(resp2->error_info_addr);
				if (resp2->status == IWM_ALIVE_STATUS_OK)
					sc->sc_uc.uc_ok = 1;
				else
					sc->sc_uc.uc_ok = 0;
			}

			if (iwm_rx_packet_payload_len(pkt) == sizeof(*resp3)) {
				SYNC_RESP_STRUCT(resp3, pkt);
				sc->sc_uc.uc_error_event_table
				    = le32toh(resp3->error_event_table_ptr);
				sc->sc_uc.uc_log_event_table
				    = le32toh(resp3->log_event_table_ptr);
				sc->sched_base = le32toh(resp3->scd_base_ptr);
				sc->sc_uc.uc_umac_error_event_table
				    = le32toh(resp3->error_info_addr);
				if (resp3->status == IWM_ALIVE_STATUS_OK)
					sc->sc_uc.uc_ok = 1;
				else
					sc->sc_uc.uc_ok = 0;
			}

			sc->sc_uc.uc_intr = 1;
			wakeup(&sc->sc_uc);
			break;
		}

		case IWM_CALIB_RES_NOTIF_PHY_DB: {
			struct iwm_calib_res_notif_phy_db *phy_db_notif;
			SYNC_RESP_STRUCT(phy_db_notif, pkt);
			iwm_phy_db_set_section(sc, phy_db_notif);
			sc->sc_init_complete |= IWM_CALIB_COMPLETE;
			wakeup(&sc->sc_init_complete);
			break;
		}

		case IWM_STATISTICS_NOTIFICATION: {
			struct iwm_notif_statistics *stats;
			SYNC_RESP_STRUCT(stats, pkt);
			memcpy(&sc->sc_stats, stats, sizeof(sc->sc_stats));
			sc->sc_noise = iwm_get_noise(&stats->rx.general);
			break;
		}

		case IWM_NVM_ACCESS_CMD:
		case IWM_MCC_UPDATE_CMD:
			if (sc->sc_wantresp == ((qid << 16) | idx)) {
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    sizeof(sc->sc_cmd_resp),
				    BUS_DMASYNC_POSTREAD);
				memcpy(sc->sc_cmd_resp,
				    pkt, sizeof(sc->sc_cmd_resp));
			}
			break;

		case IWM_MCC_CHUB_UPDATE_CMD: {
			struct iwm_mcc_chub_notif *notif;
			SYNC_RESP_STRUCT(notif, pkt);

			sc->sc_fw_mcc[0] = (notif->mcc & 0xff00) >> 8;
			sc->sc_fw_mcc[1] = notif->mcc & 0xff;
			sc->sc_fw_mcc[2] = '\0';
		}

		case IWM_DTS_MEASUREMENT_NOTIFICATION:
			break;

		case IWM_PHY_CONFIGURATION_CMD:
		case IWM_TX_ANT_CONFIGURATION_CMD:
		case IWM_ADD_STA:
		case IWM_MAC_CONTEXT_CMD:
		case IWM_REPLY_SF_CFG_CMD:
		case IWM_POWER_TABLE_CMD:
		case IWM_PHY_CONTEXT_CMD:
		case IWM_BINDING_CONTEXT_CMD:
		case IWM_TIME_EVENT_CMD:
		case IWM_WIDE_ID(IWM_ALWAYS_LONG_GROUP, IWM_SCAN_CFG_CMD):
		case IWM_WIDE_ID(IWM_ALWAYS_LONG_GROUP, IWM_SCAN_REQ_UMAC):
		case IWM_SCAN_OFFLOAD_REQUEST_CMD:
		case IWM_REPLY_BEACON_FILTERING_CMD:
		case IWM_MAC_PM_POWER_TABLE:
		case IWM_TIME_QUOTA_CMD:
		case IWM_REMOVE_STA:
		case IWM_TXPATH_FLUSH:
		case IWM_LQ_CMD:
		case IWM_BT_CONFIG:
		case IWM_REPLY_THERMAL_MNG_BACKOFF:
			SYNC_RESP_STRUCT(cresp, pkt);
			if (sc->sc_wantresp == ((qid << 16) | idx)) {
				memcpy(sc->sc_cmd_resp,
				    pkt, sizeof(*pkt)+sizeof(*cresp));
			}
			break;

		/* ignore */
		case 0x6c: /* IWM_PHY_DB_CMD */
			break;

		case IWM_INIT_COMPLETE_NOTIF:
			sc->sc_init_complete |= IWM_INIT_COMPLETE;
			wakeup(&sc->sc_init_complete);
			break;

		case IWM_SCAN_OFFLOAD_COMPLETE: {
			struct iwm_periodic_scan_complete *notif;
			SYNC_RESP_STRUCT(notif, pkt);
			break;
		}

		case IWM_SCAN_ITERATION_COMPLETE: {
			struct iwm_lmac_scan_complete_notif *notif;
			SYNC_RESP_STRUCT(notif, pkt);
			task_add(sc->sc_eswq, &sc->sc_eswk);
			break;
		}

		case IWM_SCAN_COMPLETE_UMAC: {
			struct iwm_umac_scan_complete *notif;
			SYNC_RESP_STRUCT(notif, pkt);
			task_add(sc->sc_eswq, &sc->sc_eswk);
			break;
		}

		case IWM_SCAN_ITERATION_COMPLETE_UMAC: {
			struct iwm_umac_scan_iter_complete_notif *notif;
			SYNC_RESP_STRUCT(notif, pkt);

			task_add(sc->sc_eswq, &sc->sc_eswk);
			break;
		}

		case IWM_REPLY_ERROR: {
			struct iwm_error_resp *resp;
			SYNC_RESP_STRUCT(resp, pkt);
			printf("%s: firmware error 0x%x, cmd 0x%x\n",
				DEVNAME(sc), le32toh(resp->error_type),
				resp->cmd_id);
			break;
		}

		case IWM_TIME_EVENT_NOTIFICATION: {
			struct iwm_time_event_notif *notif;
			SYNC_RESP_STRUCT(notif, pkt);
			break;
		}

		/*
		 * Firmware versions 21 and 22 generate some DEBUG_LOG_MSG
		 * messages. Just ignore them for now.
		 */
		case IWM_DEBUG_LOG_MSG:
			break;

		case IWM_MCAST_FILTER_CMD:
			break;

		case IWM_SCD_QUEUE_CFG: {
			struct iwm_scd_txq_cfg_rsp *rsp;
			SYNC_RESP_STRUCT(rsp, pkt);

			break;
		}

		default:
			printf("%s: unhandled firmware response 0x%x/0x%x "
			    "rx ring %d[%d]\n",
			    DEVNAME(sc), pkt->hdr.code, pkt->len_n_flags, qid,
			    idx);
			break;
		}

		/*
		 * uCode sets bit 0x80 when it originates the notification,
		 * i.e. when the notification is not a direct response to a
		 * command sent by the driver. 
		 * For example, uCode issues IWM_REPLY_RX when it sends a
		 * received frame to the driver.
		 */
		if (!(pkt->hdr.qid & (1 << 7))) {
			iwm_cmd_done(sc, pkt);
		}

		ADVANCE_RXQ(sc);
	}

	/*
	 * Tell the firmware what we have processed.
	 * Seems like the hardware gets upset unless we align the write by 8??
	 */
	hw = (hw == 0) ? IWM_RX_RING_COUNT - 1 : hw - 1;
	IWM_WRITE(sc, IWM_FH_RSCSR_CHNL0_WPTR, hw & ~7);
}

int
iwm_intr(void *arg)
{
	struct iwm_softc *sc = arg;
	struct ifnet *ifp = IC2IFP(&sc->sc_ic);
	int handled = 0;
	int r1, r2, rv = 0;
	int isperiodic = 0;

	IWM_WRITE(sc, IWM_CSR_INT_MASK, 0);

	if (sc->sc_flags & IWM_FLAG_USE_ICT) {
		uint32_t *ict = sc->ict_dma.vaddr;
		int tmp;

		tmp = htole32(ict[sc->ict_cur]);
		if (!tmp)
			goto out_ena;

		/*
		 * ok, there was something.  keep plowing until we have all.
		 */
		r1 = r2 = 0;
		while (tmp) {
			r1 |= tmp;
			ict[sc->ict_cur] = 0;
			sc->ict_cur = (sc->ict_cur+1) % IWM_ICT_COUNT;
			tmp = htole32(ict[sc->ict_cur]);
		}

		/* this is where the fun begins.  don't ask */
		if (r1 == 0xffffffff)
			r1 = 0;

		/* i am not expected to understand this */
		if (r1 & 0xc0000)
			r1 |= 0x8000;
		r1 = (0xff & r1) | ((0xff00 & r1) << 16);
	} else {
		r1 = IWM_READ(sc, IWM_CSR_INT);
		if (r1 == 0xffffffff || (r1 & 0xfffffff0) == 0xa5a5a5a0)
			goto out;
		r2 = IWM_READ(sc, IWM_CSR_FH_INT_STATUS);
	}
	if (r1 == 0 && r2 == 0) {
		goto out_ena;
	}

	IWM_WRITE(sc, IWM_CSR_INT, r1 | ~sc->sc_intmask);

	/* ignored */
	handled |= (r1 & (IWM_CSR_INT_BIT_ALIVE /*| IWM_CSR_INT_BIT_SCD*/));

	if (r1 & IWM_CSR_INT_BIT_SW_ERR) {
#ifdef IWM_DEBUG
		int i;

		iwm_nic_error(sc);

		/* Dump driver status (TX and RX rings) while we're here. */
		DPRINTF(("driver status:\n"));
		for (i = 0; i < IWM_MAX_QUEUES; i++) {
			struct iwm_tx_ring *ring = &sc->txq[i];
			DPRINTF(("  tx ring %2d: qid=%-2d cur=%-3d "
			    "queued=%-3d\n",
			    i, ring->qid, ring->cur, ring->queued));
		}
		DPRINTF(("  rx ring: cur=%d\n", sc->rxq.cur));
		DPRINTF(("  802.11 state %s\n",
		    ieee80211_state_name[sc->sc_ic.ic_state]));
#endif

		printf("%s: fatal firmware error\n", DEVNAME(sc));
		iwm_stop(ifp, 1);
		task_add(systq, &sc->init_task);
		rv = 1;
		goto out;

	}

	if (r1 & IWM_CSR_INT_BIT_HW_ERR) {
		handled |= IWM_CSR_INT_BIT_HW_ERR;
		printf("%s: hardware error, stopping device \n", DEVNAME(sc));
		iwm_stop(ifp, 1);
		rv = 1;
		goto out;
	}

	/* firmware chunk loaded */
	if (r1 & IWM_CSR_INT_BIT_FH_TX) {
		IWM_WRITE(sc, IWM_CSR_FH_INT_STATUS, IWM_CSR_FH_INT_TX_MASK);
		handled |= IWM_CSR_INT_BIT_FH_TX;

		sc->sc_fw_chunk_done = 1;
		wakeup(&sc->sc_fw);
	}

	if (r1 & IWM_CSR_INT_BIT_RF_KILL) {
		handled |= IWM_CSR_INT_BIT_RF_KILL;
		if (iwm_check_rfkill(sc) && (ifp->if_flags & IFF_UP)) {
			iwm_stop(ifp, 1);
		}
	}

	if (r1 & IWM_CSR_INT_BIT_RX_PERIODIC) {
		handled |= IWM_CSR_INT_BIT_RX_PERIODIC;
		IWM_WRITE(sc, IWM_CSR_INT, IWM_CSR_INT_BIT_RX_PERIODIC);
		if ((r1 & (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX)) == 0)
			IWM_WRITE_1(sc,
			    IWM_CSR_INT_PERIODIC_REG, IWM_CSR_INT_PERIODIC_DIS);
		isperiodic = 1;
	}

	if ((r1 & (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX)) ||
	    isperiodic) {
		handled |= (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX);
		IWM_WRITE(sc, IWM_CSR_FH_INT_STATUS, IWM_CSR_FH_INT_RX_MASK);

		iwm_notif_intr(sc);

		/* enable periodic interrupt, see above */
		if (r1 & (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX) &&
		    !isperiodic)
			IWM_WRITE_1(sc, IWM_CSR_INT_PERIODIC_REG,
			    IWM_CSR_INT_PERIODIC_ENA);
	}

	rv = 1;

 out_ena:
	iwm_restore_interrupts(sc);
 out:
	return rv;
}

typedef void *iwm_match_t;

static const struct pci_matchid iwm_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_3160_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_3160_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_3165_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_3165_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_3168_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_7260_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_7260_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_7265_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_7265_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_8260_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_8260_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_WL_8265_1 },
};

int
iwm_match(struct device *parent, iwm_match_t match __unused, void *aux)
{
	return pci_matchbyid((struct pci_attach_args *)aux, iwm_devices,
	    nitems(iwm_devices));
}

int
iwm_preinit(struct iwm_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = IC2IFP(ic);
	int err;
	static int attached;

	err = iwm_prepare_card_hw(sc);
	if (err) {
		printf("%s: could not initialize hardware\n", DEVNAME(sc));
		return err;
	}

	if (attached) {
		/* Update MAC in case the upper layers changed it. */
		IEEE80211_ADDR_COPY(sc->sc_ic.ic_myaddr,
		    ((struct arpcom *)ifp)->ac_enaddr);
		return 0;
	}

	err = iwm_start_hw(sc);
	if (err) {
		printf("%s: could not initialize hardware\n", DEVNAME(sc));
		return err;
	}

	err = iwm_run_init_mvm_ucode(sc, 1);
	iwm_stop_device(sc);
	if (err)
		return err;

	/* Print version info and MAC address on first successful fw load. */
	attached = 1;
	printf("%s: hw rev 0x%x, fw ver %s, address %s\n",
	    DEVNAME(sc), sc->sc_hw_rev & IWM_CSR_HW_REV_TYPE_MSK,
	    sc->sc_fwver, ether_sprintf(sc->sc_nvm.hw_addr));

	if (sc->sc_nvm.sku_cap_11n_enable)
		iwm_setup_ht_rates(sc);

	/* not all hardware can do 5GHz band */
	if (!sc->sc_nvm.sku_cap_band_52GHz_enable)
		memset(&ic->ic_sup_rates[IEEE80211_MODE_11A], 0,
		    sizeof(ic->ic_sup_rates[IEEE80211_MODE_11A]));

	/* Configure channel information obtained from firmware. */
	ieee80211_channel_init(ifp);

	/* Configure MAC address. */
	err = if_setlladdr(ifp, ic->ic_myaddr);
	if (err)
		printf("%s: could not set MAC address (error %d)\n",
		    DEVNAME(sc), err);

	ieee80211_media_init(ifp, iwm_media_change, ieee80211_media_status);

	return 0;
}

void
iwm_attach_hook(struct device *self)
{
	struct iwm_softc *sc = (void *)self;

	KASSERT(!cold);

	iwm_preinit(sc);
}

void
iwm_attach(struct device *parent, struct device *self, void *aux)
{
	struct iwm_softc *sc = (void *)self;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
	pcireg_t reg, memtype;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	const char *intrstr;
	int err;
	int txq_i, i;

	sc->sc_pct = pa->pa_pc;
	sc->sc_pcitag = pa->pa_tag;
	sc->sc_dmat = pa->pa_dmat;

	task_set(&sc->sc_eswk, iwm_endscan_cb, sc);
	rw_init(&sc->ioctl_rwl, "iwmioctl");

	err = pci_get_capability(sc->sc_pct, sc->sc_pcitag,
	    PCI_CAP_PCIEXPRESS, &sc->sc_cap_off, NULL);
	if (err == 0) {
		printf("%s: PCIe capability structure not found!\n",
		    DEVNAME(sc));
		return;
	}

	/* Clear device-specific "PCI retry timeout" register (41h). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, reg & ~0xff00);

	/* Enable bus-mastering and hardware bug workaround. */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, PCI_COMMAND_STATUS_REG);
	reg |= PCI_COMMAND_MASTER_ENABLE;
	/* if !MSI */
	if (reg & PCI_COMMAND_INTERRUPT_DISABLE) {
		reg &= ~PCI_COMMAND_INTERRUPT_DISABLE;
	}
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, PCI_COMMAND_STATUS_REG, reg);

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, PCI_MAPREG_START);
	err = pci_mapreg_map(pa, PCI_MAPREG_START, memtype, 0,
	    &sc->sc_st, &sc->sc_sh, NULL, &sc->sc_sz, 0);
	if (err) {
		printf("%s: can't map mem space\n", DEVNAME(sc));
		return;
	}

	if (pci_intr_map_msi(pa, &ih) && pci_intr_map(pa, &ih)) {
		printf("%s: can't map interrupt\n", DEVNAME(sc));
		return;
	}

	intrstr = pci_intr_string(sc->sc_pct, ih);
	sc->sc_ih = pci_intr_establish(sc->sc_pct, ih, IPL_NET, iwm_intr, sc,
	    DEVNAME(sc));

	if (sc->sc_ih == NULL) {
		printf("\n");
		printf("%s: can't establish interrupt", DEVNAME(sc));
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(", %s\n", intrstr);

	sc->sc_wantresp = IWM_CMD_RESP_IDLE;

	sc->sc_hw_rev = IWM_READ(sc, IWM_CSR_HW_REV);
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_INTEL_WL_3160_1:
	case PCI_PRODUCT_INTEL_WL_3160_2:
		sc->sc_fwname = "iwm-3160-16";
		sc->host_interrupt_operation_mode = 1;
		sc->sc_device_family = IWM_DEVICE_FAMILY_7000;
		sc->sc_fwdmasegsz = IWM_FWDMASEGSZ;
		break;
	case PCI_PRODUCT_INTEL_WL_3165_1:
	case PCI_PRODUCT_INTEL_WL_3165_2:
		sc->sc_fwname = "iwm-7265-16";
		sc->host_interrupt_operation_mode = 0;
		sc->sc_device_family = IWM_DEVICE_FAMILY_7000;
		sc->sc_fwdmasegsz = IWM_FWDMASEGSZ;
		break;
	case PCI_PRODUCT_INTEL_WL_3168_1:
		sc->sc_fwname = "iwm-3168-22";
		sc->host_interrupt_operation_mode = 0;
		sc->sc_device_family = IWM_DEVICE_FAMILY_7000;
		sc->sc_fwdmasegsz = IWM_FWDMASEGSZ;
		break;
	case PCI_PRODUCT_INTEL_WL_7260_1:
	case PCI_PRODUCT_INTEL_WL_7260_2:
		sc->sc_fwname = "iwm-7260-16";
		sc->host_interrupt_operation_mode = 1;
		sc->sc_device_family = IWM_DEVICE_FAMILY_7000;
		sc->sc_fwdmasegsz = IWM_FWDMASEGSZ;
		break;
	case PCI_PRODUCT_INTEL_WL_7265_1:
	case PCI_PRODUCT_INTEL_WL_7265_2:
		sc->sc_fwname = "iwm-7265-16";
		sc->host_interrupt_operation_mode = 0;
		sc->sc_device_family = IWM_DEVICE_FAMILY_7000;
		sc->sc_fwdmasegsz = IWM_FWDMASEGSZ;
		break;
	case PCI_PRODUCT_INTEL_WL_8260_1:
	case PCI_PRODUCT_INTEL_WL_8260_2:
		sc->sc_fwname = "iwm-8000C-16";
		sc->host_interrupt_operation_mode = 0;
		sc->sc_device_family = IWM_DEVICE_FAMILY_8000;
		sc->sc_fwdmasegsz = IWM_FWDMASEGSZ_8000;
		break;
	case PCI_PRODUCT_INTEL_WL_8265_1:
		sc->sc_fwname = "iwm-8265-22";
		sc->host_interrupt_operation_mode = 0;
		sc->sc_device_family = IWM_DEVICE_FAMILY_8000;
		sc->sc_fwdmasegsz = IWM_FWDMASEGSZ_8000;
		break;
	default:
		printf("%s: unknown adapter type\n", DEVNAME(sc));
		return;
	}

	/*
	 * In the 8000 HW family the format of the 4 bytes of CSR_HW_REV have
	 * changed, and now the revision step also includes bit 0-1 (no more
	 * "dash" value). To keep hw_rev backwards compatible - we'll store it
	 * in the old format.
	 */
	if (sc->sc_device_family == IWM_DEVICE_FAMILY_8000)
		sc->sc_hw_rev = (sc->sc_hw_rev & 0xfff0) |
				(IWM_CSR_HW_REV_STEP(sc->sc_hw_rev << 2) << 2);
		
	if (iwm_prepare_card_hw(sc) != 0) {
		printf("%s: could not initialize hardware\n", DEVNAME(sc));
		return;
	}

	if (sc->sc_device_family == IWM_DEVICE_FAMILY_8000) {
		uint32_t hw_step;

		/*
		 * In order to recognize C step the driver should read the
		 * chip version id located at the AUX bus MISC address.
		 */
		IWM_SETBITS(sc, IWM_CSR_GP_CNTRL,
			    IWM_CSR_GP_CNTRL_REG_FLAG_INIT_DONE);
		DELAY(2);

		err = iwm_poll_bit(sc, IWM_CSR_GP_CNTRL,
				   IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
				   IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
				   25000);
		if (!err) {
			printf("%s: Failed to wake up the nic\n", DEVNAME(sc));
			return;
		}

		if (iwm_nic_lock(sc)) {
			hw_step = iwm_read_prph(sc, IWM_WFPM_CTRL_REG);
			hw_step |= IWM_ENABLE_WFPM;
			iwm_write_prph(sc, IWM_WFPM_CTRL_REG, hw_step);
			hw_step = iwm_read_prph(sc, IWM_AUX_MISC_REG);
			hw_step = (hw_step >> IWM_HW_STEP_LOCATION_BITS) & 0xF;
			if (hw_step == 0x3)
				sc->sc_hw_rev = (sc->sc_hw_rev & 0xFFFFFFF3) |
						(IWM_SILICON_C_STEP << 2);
			iwm_nic_unlock(sc);
		} else {
			printf("%s: Failed to lock the nic\n", DEVNAME(sc));
			return;
		}
	}

	/* 
	 * Allocate DMA memory for firmware transfers.
	 * Must be aligned on a 16-byte boundary.
	 */
	err = iwm_dma_contig_alloc(sc->sc_dmat, &sc->fw_dma,
	    sc->sc_fwdmasegsz, 16);
	if (err) {
		printf("%s: could not allocate memory for firmware\n",
		    DEVNAME(sc));
		return;
	}

	/* Allocate "Keep Warm" page, used internally by the card. */
	err = iwm_dma_contig_alloc(sc->sc_dmat, &sc->kw_dma, 4096, 4096);
	if (err) {
		printf("%s: could not allocate keep warm page\n", DEVNAME(sc));
		goto fail1;
	}

	/* Allocate interrupt cause table (ICT).*/
	err = iwm_dma_contig_alloc(sc->sc_dmat, &sc->ict_dma,
	    IWM_ICT_SIZE, 1<<IWM_ICT_PADDR_SHIFT);
	if (err) {
		printf("%s: could not allocate ICT table\n", DEVNAME(sc));
		goto fail2;
	}

	/* TX scheduler rings must be aligned on a 1KB boundary. */
	err = iwm_dma_contig_alloc(sc->sc_dmat, &sc->sched_dma,
	    nitems(sc->txq) * sizeof(struct iwm_agn_scd_bc_tbl), 1024);
	if (err) {
		printf("%s: could not allocate TX scheduler rings\n",
		    DEVNAME(sc));
		goto fail3;
	}

	for (txq_i = 0; txq_i < nitems(sc->txq); txq_i++) {
		err = iwm_alloc_tx_ring(sc, &sc->txq[txq_i], txq_i);
		if (err) {
			printf("%s: could not allocate TX ring %d\n",
			    DEVNAME(sc), txq_i);
			goto fail4;
		}
	}

	err = iwm_alloc_rx_ring(sc, &sc->rxq);
	if (err) {
		printf("%s: could not allocate RX ring\n", DEVNAME(sc));
		goto fail4;
	}

	sc->sc_eswq = taskq_create("iwmes", 1, IPL_NET, 0);
	if (sc->sc_eswq == NULL)
		goto fail4;
	sc->sc_nswq = taskq_create("iwmns", 1, IPL_NET, 0);
	if (sc->sc_nswq == NULL)
		goto fail4;

	/* Clear pending interrupts. */
	IWM_WRITE(sc, IWM_CSR_INT, 0xffffffff);

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* Set device capabilities. */
	ic->ic_caps =
	    IEEE80211_C_WEP |		/* WEP */
	    IEEE80211_C_RSN |		/* WPA/RSN */
	    IEEE80211_C_SCANALL |	/* device scans all channels at once */
	    IEEE80211_C_SCANALLBAND |	/* device scans all bands at once */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_SHPREAMBLE;	/* short preamble supported */

	ic->ic_htcaps = IEEE80211_HTCAP_SGI20;
	ic->ic_htcaps |=
	    (IEEE80211_HTCAP_SMPS_DIS << IEEE80211_HTCAP_SMPS_SHIFT);
	ic->ic_htxcaps = 0;
	ic->ic_txbfcaps = 0;
	ic->ic_aselcaps = 0;
	ic->ic_ampdu_params = (IEEE80211_AMPDU_PARAM_SS_4 | 0x3 /* 64k */);

	ic->ic_sup_rates[IEEE80211_MODE_11A] = ieee80211_std_rateset_11a;
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	for (i = 0; i < nitems(sc->sc_phyctxt); i++) {
		sc->sc_phyctxt[i].id = i;
	}

	sc->sc_amrr.amrr_min_success_threshold =  1;
	sc->sc_amrr.amrr_max_success_threshold = 15;

	/* IBSS channel undefined for now. */
	ic->ic_ibss_chan = &ic->ic_channels[1];

	ic->ic_max_rssi = IWM_MAX_DBM - IWM_MIN_DBM;

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = iwm_ioctl;
	ifp->if_start = iwm_start;
	ifp->if_watchdog = iwm_watchdog;
	memcpy(ifp->if_xname, DEVNAME(sc), IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ieee80211_media_init(ifp, iwm_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	iwm_radiotap_attach(sc);
#endif
	timeout_set(&sc->sc_calib_to, iwm_calib_timeout, sc);
	timeout_set(&sc->sc_led_blink_to, iwm_led_blink_timeout, sc);
	task_set(&sc->init_task, iwm_init_task, sc);
	task_set(&sc->newstate_task, iwm_newstate_task, sc);
	task_set(&sc->setrates_task, iwm_setrates_task, sc);
	task_set(&sc->ba_task, iwm_ba_task, sc);
	task_set(&sc->htprot_task, iwm_htprot_task, sc);

	ic->ic_node_alloc = iwm_node_alloc;

	/* Override 802.11 state transition machine. */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = iwm_newstate;
	ic->ic_update_htprot = iwm_update_htprot;
	ic->ic_ampdu_rx_start = iwm_ampdu_rx_start;
	ic->ic_ampdu_rx_stop = iwm_ampdu_rx_stop;
#ifdef notyet
	ic->ic_ampdu_tx_start = iwm_ampdu_tx_start;
	ic->ic_ampdu_tx_stop = iwm_ampdu_tx_stop;
#endif
	/*
	 * We cannot read the MAC address without loading the
	 * firmware from disk. Postpone until mountroot is done.
	 */
	config_mountroot(self, iwm_attach_hook);

	return;

fail4:	while (--txq_i >= 0)
		iwm_free_tx_ring(sc, &sc->txq[txq_i]);
	iwm_free_rx_ring(sc, &sc->rxq);
	iwm_dma_contig_free(&sc->sched_dma);
fail3:	if (sc->ict_dma.vaddr != NULL)
		iwm_dma_contig_free(&sc->ict_dma);
	
fail2:	iwm_dma_contig_free(&sc->kw_dma);
fail1:	iwm_dma_contig_free(&sc->fw_dma);
	return;
}

#if NBPFILTER > 0
void
iwm_radiotap_attach(struct iwm_softc *sc)
{
	bpfattach(&sc->sc_drvbpf, &sc->sc_ic.ic_if, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(IWM_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(IWM_TX_RADIOTAP_PRESENT);
}
#endif

void
iwm_init_task(void *arg1)
{
	struct iwm_softc *sc = arg1;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;
	int generation = sc->sc_generation;

	rw_enter_write(&sc->ioctl_rwl);
	if (generation != sc->sc_generation) {
		rw_exit(&sc->ioctl_rwl);
		return;
	}
	s = splnet();

	if (ifp->if_flags & IFF_RUNNING)
		iwm_stop(ifp, 0);
	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_UP)
		iwm_init(ifp);

	splx(s);
	rw_exit(&sc->ioctl_rwl);
}

int
iwm_resume(struct iwm_softc *sc)
{
	pcireg_t reg;

	/* Clear device-specific "PCI retry timeout" register (41h). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, reg & ~0xff00);

	return iwm_prepare_card_hw(sc);
}

int
iwm_activate(struct device *self, int act)
{
	struct iwm_softc *sc = (struct iwm_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int err = 0;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			iwm_stop(ifp, 0);
		break;
	case DVACT_RESUME:
		err = iwm_resume(sc);
		if (err)
			printf("%s: could not initialize hardware\n",
			    DEVNAME(sc));
		break;
	case DVACT_WAKEUP:
		/* Hardware should be up at this point. */
		if (iwm_set_hw_ready(sc))
			task_add(systq, &sc->init_task);
		break;
	}

	return 0;
}

struct cfdriver iwm_cd = {
	NULL, "iwm", DV_IFNET
};

struct cfattach iwm_ca = {
	sizeof(struct iwm_softc), iwm_match, iwm_attach,
	NULL, iwm_activate
};
@


1.197
log
@In iwm_init() save the generation counter once before looping over
tsleep(9), instead of saving it during every iteration.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.196 2017/06/14 16:58:28 stsp Exp $	*/
a6108 3
	if (sc->sc_flags & IWM_FLAG_HW_INITED) {
		return 0;
	}
a6134 2
	sc->sc_flags |= IWM_FLAG_HW_INITED;

a6211 1
	sc->sc_flags &= ~IWM_FLAG_HW_INITED;
d7447 1
a7447 1
	if (sc->sc_flags & IWM_FLAG_HW_INITED)
@


1.196
log
@Currently, iwm(4) uses only one phy context, so stop sending commands to the
firmware for unused ones. This should be refactored further, but for now this
change is good enough to reduce the amount of commands we throw at the firmware.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.195 2017/06/14 16:57:47 stsp Exp $	*/
d6129 1
a6130 1
		generation = sc->sc_generation;
@


1.195
log
@When a task in iwm(4) obtains an rwlock(9), bail out if the device was
reset while the task was asleep waiting for the lock.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.194 2017/06/14 16:56:50 stsp Exp $	*/
d6009 1
a6009 1
	for (i = 0; i < IWM_NUM_PHY_CTX; i++) {
@


1.194
log
@Make the iwm(4) ioctl handler wait until the transition to SCAN has completed
when bringing the interface up. Otherwise we get racy behaviour when running
ifconfig commands which issue several ioctls in quick succession.
Should fix the occasional "could not initiate scan" errors.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.193 2017/06/14 16:56:04 stsp Exp $	*/
d6271 1
a6271 1
	int s, err = 0;
d6278 4
a6283 1

d7444 1
d7447 4
@


1.193
log
@Make iwm(4) wait for the PHY calibration result notification during HW init.
Code inspection revealed that Linux does this, and so should we.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.192 2017/06/09 13:47:26 stsp Exp $	*/
d5626 1
d6106 2
a6107 1
	int err;
d6124 14
@


1.192
log
@Introduce iwm_nic_assert_locked() to verify that the driver has correctly
requested MAC access before accessing certain registers, as required
by the hardware.

Use it to assert that hardware is still in an accessible state before
reading or writing such a register. For now, panic if that check fails.
The long term goal is to make this a non-fatal error and handle it properly
in all code paths that end up reading or writing such a register.

Fix a missing NIC lock on 8000 hardware, found by this new assertion.

Also, grab the NIC lock early during hardware init and keep it until init
is done. The previous code relinquished and reacquired the NIC lock several
times during the init sequence. It seems this is what was causing some random
errors when the interface was brought up, such as "could not enable Tx queue",
"could not add aux station", and "could not add phy context".
For some reason, bsd.rd kernels were suffering particularly hard from such
problems, to the point where some machines could not be upgraded over iwm(4).
This change does not eliminate such problems entirely but is a step forward.

Prodded by deraadt@@
This change has already been in snaps for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.191 2017/06/09 13:46:15 stsp Exp $	*/
d3129 1
d3181 2
a3182 2
	 * Nothing to do but wait for the init complete notification
	 * from the firmware
d3184 1
a3184 1
	while (!sc->sc_init_complete) {
d6684 2
d6752 1
a6752 1
			sc->sc_init_complete = 1;
@


1.191
log
@Fix the resume code path in iwm(4) to no longer call iwm_stop() before
initializing the hardware. Prevents "acquiring device failed" messages
during resume. Also, start the hardware up in DVACT_RESUME already and
verify that it has started by the time we reach DVACT_WAKEUP, before
scheduling the iwm_init_task which loads firmware etc.
With help from deraadt@@
test & ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.190 2017/06/02 11:18:37 stsp Exp $	*/
d259 1
d836 1
d846 1
a914 2
	int rv = 0;

d916 1
d930 1
a930 2
	     | IWM_CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP, 15000)) {
	    	rv = 1;
d932 1
a932 3
	} else {
		printf("%s: acquiring device failed\n", DEVNAME(sc));
		IWM_WRITE(sc, IWM_CSR_RESET, IWM_CSR_RESET_REG_FLAG_FORCE_NMI);
d935 14
a948 1
	return rv;
d1796 1
a1796 2
	if (!iwm_nic_lock(sc))
		return EBUSY;
a1830 2
		iwm_nic_unlock(sc);

a1842 3

		if (!iwm_nic_lock(sc))
			return EBUSY;
a1847 2
	iwm_nic_unlock(sc);

a1879 2
	iwm_nic_unlock(sc);

d1883 1
a1883 4
		return err;

	if (!iwm_nic_lock(sc))
		return EBUSY;
d2611 7
a2617 4
		uint32_t mac_addr0 =
		    htole32(iwm_read_prph(sc, IWM_WFMP_MAC_ADDR_0));
		uint32_t mac_addr1 =
		    htole32(iwm_read_prph(sc, IWM_WFMP_MAC_ADDR_1));
d2631 1
a2631 1

d5565 1
d5586 5
a5590 1
		iwm_init_hw(sc);
d5968 3
d6069 2
a6070 4
	return 0;

 err:
	iwm_stop_device(sc);
@


1.190
log
@When iwm(4) firmware reports missed beacons, send a probe request only
if ic_mgt_timer indicates that we're not already waiting for a response.
Fixes a flood of probe requests sent out while the interrupt kept firing.

Also, byteswap the missed beacon counter value when reading it.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.189 2017/05/31 13:22:16 phessler Exp $	*/
d463 1
a463 1
void	iwm_wakeup(struct iwm_softc *);
d7418 2
a7419 1
	iwm_stop(ifp, 0);
d7427 2
a7428 2
void
iwm_wakeup(struct iwm_softc *sc)
d7436 1
a7436 1
	task_add(systq, &sc->init_task);
d7444 1
d7451 6
d7458 3
a7460 1
		iwm_wakeup(sc);
@


1.189
log
@another place to use ieee80211_min_basic_rate() to select the minimum tx rate

OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.188 2017/05/31 12:24:06 phessler Exp $	*/
d3547 1
d3556 2
a3557 1
	if (mbn->consec_missed_beacons_since_last_rx > ic->ic_bmissthres) {
@


1.188
log
@add ieee80211_min_basic_rate() to iwm(4), to select the lowest available
datarate for management frames

based on revs 1.187 and r 1.188 from iwn(4)

OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.187 2017/05/31 09:17:39 stsp Exp $	*/
d5447 1
a5447 2
	ridx_min = (IEEE80211_IS_CHAN_5GHZ(ni->ni_chan)) ?
	    IWM_RIDX_OFDM : IWM_RIDX_CCK;
@


1.187
log
@The net80211 stack was providing a 'beacon miss timeout' value (in ms)
which specified how much time may elapse without beacons before drivers
begin searching for a new AP.

Drivers convert this timeout value into the amount of beacons they're allowed
to miss. Having the stack provide this number upfront simplifies things.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.186 2017/05/31 08:33:11 stsp Exp $	*/
d421 1
d3990 1
a3990 2
		ridx = (IEEE80211_IS_CHAN_5GHZ(ni->ni_chan)) ?
		    IWM_RIDX_OFDM : IWM_RIDX_CCK;
d5013 13
@


1.186
log
@Add missing function prototype for iwm_rx_bmiss().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.185 2017/05/31 08:14:52 stsp Exp $	*/
a3544 1
	int bmiss_threshold = ic->ic_bmisstimeout / ic->ic_lintval;
d3554 1
a3554 1
	if (mbn->consec_missed_beacons_since_last_rx > bmiss_threshold) {
@


1.185
log
@Implement support for iwm(4) firmware's missed beacon notification.
Requested by deraadt@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.184 2017/05/28 11:03:48 stsp Exp $	*/
d370 2
@


1.184
log
@Fix some spurious fatal firmware errors in iwm(4).

If we are not in SCAN state anymore by the time hardware signals completion
of a scan command, exit the scan completion handler immediately instead of
calling ieee80211_end_scan().

Tested by tb@@ and myself.
ok mpi@@ tb@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.183 2017/05/28 09:59:58 stsp Exp $	*/
d3538 28
d6597 1
a6597 1
			/* OpenBSD does not provide ieee80211_beacon_miss() */
@


1.183
log
@Remove unused flag IWM_FLAG_STOPPED.
ok tedu@@ of course
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.182 2017/05/26 18:40:05 stsp Exp $	*/
d5687 4
d6166 1
@


1.182
log
@Get rid of the DELAY() hack in the firmware loader for 8000 family
iwm(4) devices. I don't see any problems without this hack.
I suppose the underlying problem was fixed in if_iwm.c r1.146.

Add some additional error checking while here.

Tested by me on 8260 and by claudio@@ on 8265.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.181 2017/05/08 14:27:28 stsp Exp $	*/
a6054 1
	sc->sc_flags &= ~IWM_FLAG_STOPPED;
a6145 1
	sc->sc_flags |= IWM_FLAG_STOPPED;
@


1.181
log
@In iwm_send_cmd(), look at the generation counter instead of the STOPPED flag
to determine whether the interface was reset while we were sleeping. The flag
will be set if the interface is still down when the task wakes up, but the
interface could already be up again in which case the flag will be cleared.

ok mpi@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.180 2017/05/08 12:41:23 stsp Exp $	*/
d2966 5
a2970 5

			/*
			 * The firmware won't load correctly without this delay.
			 */
			DELAY(8000);
d2982 5
@


1.180
log
@In iwm(4) avoid locking the NIC redundantly and perform accounting of
locking and unlocking. Make sure we don't unlock 7000 family NICs while
a command is being processed (later NICs apparently don't need this).

Inspired by similar approaches in Linux and Dragonfly, and a patch given
to me by Imre Vadasz.
Tested by me on 7265 and 8260 devices, and on a 7260 device by Stefan Wollny.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.179 2017/05/08 08:57:56 stsp Exp $	*/
d3633 1
d3655 1
a3655 1
	if (sc->sc_flags & IWM_FLAG_STOPPED) {
a3767 1
		int generation = sc->sc_generation;
@


1.179
log
@Fix issues with iwm(4) firmware's retry rate table:

For a HT node, ni_txrate is always zero. We should be using ni_txmcs instead.
Simplify the if-else logic to make sure of that.

The mimo delimiter in the link quality command was never set.
I don't know how important this is. But Linux sets it, so why not.

Hardcode the lowest rate at the tail of the retry table.
While debugging the old code I have encountered retry tables filled
with only 'MCS 8' which is obviously not ideal.

While here, fix a misspelled function prototype.

Tested by kettenis@@, mpi@@, and Stefan Wollny
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.178 2017/05/04 09:03:42 stsp Exp $	*/
d911 5
d927 1
d939 6
a944 2
	IWM_CLRBITS(sc, IWM_CSR_GP_CNTRL,
	    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
d1224 5
d1607 4
d3746 10
a3755 9
	IWM_SETBITS(sc, IWM_CSR_GP_CNTRL,
	    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
	if (!iwm_poll_bit(sc, IWM_CSR_GP_CNTRL,
	    IWM_CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN,
	    (IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY |
	     IWM_CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP), 15000)) {
		printf("%s: acquiring device failed\n", DEVNAME(sc));
		err = EBUSY;
		goto out;
d3762 1
d3883 12
a6774 3

	IWM_CLRBITS(sc, IWM_CSR_GP_CNTRL,
	    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
@


1.178
log
@If iwm_nic_lock() cannot access the device then print "acquiring device failed"
instead of "device timeout". The latter is printed by the Tx watchdog already.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.177 2017/04/27 06:14:23 stsp Exp $	*/
d244 1
a244 1
int	iwm_is_mimo_plcp(uint8_t);
d5378 3
a5380 2
		if ((ni->ni_flags & IEEE80211_NODE_HT) &&
		    ht_plcp != IWM_RATE_HT_SISO_MCS_INV_PLCP) {
d5396 1
a5396 2
		}
		if (tab == 0 && plcp != IWM_RATE_INVM_PLCP) {
d5419 2
d5422 7
a5428 3
	i = j > 0 ? j - 1 : 0;
	while (j < nitems(lq->rs_table))
		lq->rs_table[j++] = lq->rs_table[i];
@


1.177
log
@Restore if_iwm.c r1.173 (mira retry change) which got incarcerated by
the backout police even though it wasn't responsible for anything.
pointed out by tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.176 2017/04/27 05:46:51 stsp Exp $	*/
d923 1
a923 1
		printf("%s: device timeout\n", DEVNAME(sc));
@


1.176
log
@Revert if_iwm.c to the state of r1.170 because ETOOMANYDRAGONSATONCE.
Performance regression reported by deraadt@@ and uvm_fault reported by fcambus@@.
I will be poking further at this out of tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.170 2017/04/21 17:54:02 stsp Exp $	*/
d3447 1
a3447 1
			in->in_mn.retries++;
@


1.175
log
@Get rid of convoluted macros in iwm's receive code path.

Since we now sync the entire Rx DMA buffer the SYNC_RESP_STRUCT() macro which
was used to sync just parts of the buffer can be replaced by assignments.
The SYNC_RESP_PTR() macro was already unused so just remove it.
The ADVANCE_RXQ() macro was used just once so expand it in place.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.174 2017/04/26 08:19:09 stsp Exp $	*/
d359 1
a359 1
int	iwm_rx_addbuf(struct iwm_softc *, int);
d365 2
a366 2
void	iwm_rx_mpdu(struct iwm_softc *, struct mbuf *);
void	iwm_rx_pkt(struct iwm_softc *, struct iwm_rx_data *);
a451 1
int	iwm_rx_frame(struct iwm_softc *, struct mbuf *);
d1063 1
a1063 1
		err = iwm_rx_addbuf(sc, i);
d1675 1
d3164 1
a3164 1
iwm_rx_addbuf(struct iwm_softc *sc, int idx)
d3176 5
a3180 1
	MCLGETI(m, M_DONTWAIT, NULL, IWM_RBUF_SIZE);
d3202 1
a3202 2
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, IWM_RBUF_SIZE,
	    BUS_DMASYNC_PREREAD);
d3299 3
a3301 2
int
iwm_rx_frame(struct iwm_softc *sc, struct mbuf *m)
d3308 1
d3310 1
d3312 2
d3316 3
d3320 9
a3328 1
	wh = mtod(m, struct ieee80211_frame *);
d3331 5
a3335 1
		return EINVAL;
d3347 3
a3417 2

	return 0;
d3447 1
a3447 1
			in->in_mn.retries += tx_resp->failure_frame;
d4408 1
a4408 6
		if (ic->ic_opmode == IEEE80211_M_MONITOR)
			IEEE80211_ADDR_COPY(&add_sta_cmd.addr,
			    etherbroadcastaddr);
		else
			IEEE80211_ADDR_COPY(&add_sta_cmd.addr,
			    in->in_ni.ni_bssid);
d5048 1
a5048 7
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		cmd->mac_type = htole32(IWM_FW_MAC_TYPE_LISTENER);
	else if (ic->ic_opmode == IEEE80211_M_STA)
		cmd->mac_type = htole32(IWM_FW_MAC_TYPE_BSS_STA);
	else
		panic("unsupported operating mode %d\n", ic->ic_opmode);

a5137 1
	struct ieee80211com *ic = &sc->sc_ic;
d5145 3
a5147 11
	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		cmd.filter_flags = htole32(IWM_MAC_FILTER_IN_PROMISC |
		    IWM_MAC_FILTER_IN_CONTROL_AND_MGMT |
		    IWM_MAC_FILTER_IN_BEACON |
		    IWM_MAC_FILTER_IN_PROBE_REQUEST |
		    IWM_MAC_FILTER_IN_CRC32);
	} else if (!assoc || !ni->ni_associd || !ni->ni_dtimperiod)
		/* 
		 * Allow beacons to pass through as long as we are not
		 * associated or we do not have dtim period information.
		 */
d5234 1
a5234 4
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		sc->sc_phyctxt[0].channel = ic->ic_ibss_chan;
	else
		sc->sc_phyctxt[0].channel = in->in_ni.ni_chan;
a5261 3
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		return 0;

d5489 1
a5489 3
	if (ostate == IEEE80211_S_RUN && nstate != ostate) {
		if (ic->ic_opmode == IEEE80211_M_MONITOR)
			iwm_led_blink_stop(sc);
a5490 2
	}

a5546 7
		if (ic->ic_opmode == IEEE80211_M_MONITOR) {
			/* Add a MAC context and a sniffing STA. */
			err = iwm_auth(sc);
			if (err)
				return;
		}

d5548 1
a5548 2
		if ((ic->ic_opmode == IEEE80211_M_MONITOR ||
		    (in->in_ni.ni_flags & IEEE80211_NODE_HT)) &&
a5558 11
		if (ic->ic_opmode == IEEE80211_M_MONITOR) {
			err = iwm_update_quotas(sc, in);
			if (err) {
				printf("%s: could not update quotas "
				    "(error %d)\n", DEVNAME(sc), err);
				return;
			}
			iwm_led_blink_start(sc);
			break;
		}

a6004 1
	struct ieee80211com *ic = &sc->sc_ic;
d6022 1
a6022 5
	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		ieee80211_begin_scan(ifp);
	else
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

d6458 13
a6470 23
void
iwm_rx_mpdu(struct iwm_softc *sc, struct mbuf *m)
{
	struct ifnet *ifp = IC2IFP(&sc->sc_ic);
	struct iwm_rx_packet *pkt;
	struct iwm_rx_mpdu_res_start *rx_res;
	uint32_t len;
	uint32_t rx_pkt_status;
	int rxfail;

	pkt = mtod(m, struct iwm_rx_packet *);
	rx_res = (struct iwm_rx_mpdu_res_start *)pkt->data;
	len = le16toh(rx_res->byte_count);
	rx_pkt_status = le32toh(*(uint32_t *)(pkt->data +
	    sizeof(*rx_res) + len));

	rxfail = ((rx_pkt_status & IWM_RX_MPDU_RES_STATUS_CRC_OK) == 0 ||
	    (rx_pkt_status & IWM_RX_MPDU_RES_STATUS_OVERRUN_OK) == 0);
	if (rxfail) {
		ifp->if_ierrors++;
		m_freem(m);
		return;
	}
d6472 1
a6472 8
	/* Extract the 802.11 frame. */
	m->m_data = (caddr_t)pkt->data + sizeof(*rx_res);
	m->m_pkthdr.len = m->m_len = len;
	if (iwm_rx_frame(sc, m) != 0) {
		ifp->if_ierrors++;
		m_freem(m);
	}
}
d6475 1
a6475 1
iwm_rx_pkt(struct iwm_softc *sc, struct iwm_rx_data *data)
d6477 4
a6480 7
	struct ifnet *ifp = IC2IFP(&sc->sc_ic);
	struct iwm_rx_packet *pkt;
	struct iwm_cmd_response *cresp;
	uint32_t offset = 0, nmpdu = 0, len;
	struct mbuf *m0;
	const uint32_t minsz = sizeof(uint32_t) + sizeof(struct iwm_cmd_header);
	int qid, idx, code;
d6482 10
a6491 2
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, IWM_RBUF_SIZE,
	    BUS_DMASYNC_POSTREAD);
a6492 3
	m0 = data->m;
	while (offset + minsz < IWM_RBUF_SIZE) {
		pkt = (struct iwm_rx_packet *)(m0->m_data + offset);
d6495 1
d6498 8
a6505 12
		if ((code == 0 && qid == 0 && idx == 0) ||
		    pkt->len_n_flags == htole32(IWM_FH_RSCSR_FRAME_INVALID)) {
			break;
		}

		if (code == IWM_REPLY_RX_MPDU_CMD && ++nmpdu == 1) {
			/* Take mbuf m0 off the RX ring. */
			if (iwm_rx_addbuf(sc, sc->rxq.cur)) {
				ifp->if_ierrors++;
				break;
			}
			KASSERT(data->m != m0);
a6507 3
		len = le32toh(pkt->len_n_flags) & IWM_FH_RSCSR_FRAME_SIZE_MSK;
		len += sizeof(uint32_t); /* account for status word */

d6513 2
a6514 10
		case IWM_REPLY_RX_MPDU_CMD: {
			/* Always copy from offset zero to preserve m_pkthdr. */
			struct mbuf *m = m_copym(m0, 0, M_COPYALL, M_DONTWAIT);
			if (m == NULL) {
				ifp->if_ierrors++;
				break;
			}
			m_adj(m, offset);
			m_adj(m, -(m->m_pkthdr.len - len));
			iwm_rx_mpdu(sc, m);
a6515 1
		}
d6534 1
a6534 1
				resp1 = (void *)pkt->data;
d6547 1
a6547 1
				resp2 = (void *)pkt->data;
d6562 1
a6562 1
				resp3 = (void *)pkt->data;
d6583 1
a6583 1
			phy_db_notif = (void *)pkt->data;
d6588 5
a6592 3
		case IWM_STATISTICS_NOTIFICATION:
			memcpy(&sc->sc_stats, pkt->data, sizeof(sc->sc_stats));
			sc->sc_noise = iwm_get_noise(&sc->sc_stats.rx.general);
d6594 1
d6599 3
d6609 2
a6610 1
			notif = (void *)pkt->data;
a6613 1
			break;
d6639 1
a6639 1
			cresp = (void *)pkt->data;
d6655 3
a6657 1
		case IWM_SCAN_OFFLOAD_COMPLETE:
d6659 1
d6661 3
a6663 1
		case IWM_SCAN_ITERATION_COMPLETE:
d6666 1
d6668 3
a6670 1
		case IWM_SCAN_COMPLETE_UMAC:
d6673 5
a6678 1
		case IWM_SCAN_ITERATION_COMPLETE_UMAC:
d6681 1
d6685 1
a6685 1
			resp = (void *)pkt->data;
d6692 3
a6694 1
		case IWM_TIME_EVENT_NOTIFICATION:
d6696 1
d6708 4
a6711 1
		case IWM_SCD_QUEUE_CFG:
d6713 1
d6734 1
a6734 21
		offset += roundup(len, IWM_FH_RSCSR_FRAME_ALIGN);
	}

	if (m0 != data->m)
		m_freem(m0);
}

void
iwm_notif_intr(struct iwm_softc *sc)
{
	uint16_t hw;

	bus_dmamap_sync(sc->sc_dmat, sc->rxq.stat_dma.map,
	    0, sc->rxq.stat_dma.size, BUS_DMASYNC_POSTREAD);

	hw = le16toh(sc->rxq.stat->closed_rb_num) & 0xfff;
	while (sc->rxq.cur != hw) {
		struct iwm_rx_data *data = &sc->rxq.data[sc->rxq.cur];

		iwm_rx_pkt(sc, data);
		sc->rxq.cur = (sc->rxq.cur + 1) % IWM_RX_RING_COUNT;
a7222 1
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
@


1.174
log
@Remove the size argument of iwm_rx_addbuf() and use a constant internally.
All callers were passing the same constant IWM_RBUF_SIZE, which is derived
from the smallest RX buffer the hardware supports (4k). Smaller sizes don't
make sense anyway and larger sizes are not on our horizon for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.173 2017/04/26 07:53:17 stsp Exp $	*/
a6487 16
#define SYNC_RESP_STRUCT(_var_, _pkt_)					\
do {									\
	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof(*(_pkt_)),	\
	    sizeof(*(_var_)), BUS_DMASYNC_POSTREAD);			\
	_var_ = (void *)((_pkt_)+1);					\
} while (/*CONSTCOND*/0)

#define SYNC_RESP_PTR(_ptr_, _len_, _pkt_)				\
do {									\
	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof(*(_pkt_)),	\
	    sizeof(len), BUS_DMASYNC_POSTREAD);				\
	_ptr_ = (void *)((_pkt_)+1);					\
} while (/*CONSTCOND*/0)

#define ADVANCE_RXQ(sc) (sc->rxq.cur = (sc->rxq.cur + 1) % IWM_RX_RING_COUNT);

d6594 1
a6594 1
				SYNC_RESP_STRUCT(resp1, pkt);
d6607 1
a6607 1
				SYNC_RESP_STRUCT(resp2, pkt);
d6622 1
a6622 1
				SYNC_RESP_STRUCT(resp3, pkt);
d6643 1
a6643 1
			SYNC_RESP_STRUCT(phy_db_notif, pkt);
d6648 3
a6650 5
		case IWM_STATISTICS_NOTIFICATION: {
			struct iwm_notif_statistics *stats;
			SYNC_RESP_STRUCT(stats, pkt);
			memcpy(&sc->sc_stats, stats, sizeof(sc->sc_stats));
			sc->sc_noise = iwm_get_noise(&stats->rx.general);
a6651 1
		}
a6655 3
				bus_dmamap_sync(sc->sc_dmat, data->map, 0,
				    sizeof(sc->sc_cmd_resp),
				    BUS_DMASYNC_POSTREAD);
d6663 1
a6663 2
			SYNC_RESP_STRUCT(notif, pkt);

d6667 1
d6693 1
a6693 1
			SYNC_RESP_STRUCT(cresp, pkt);
d6709 1
a6709 3
		case IWM_SCAN_OFFLOAD_COMPLETE: {
			struct iwm_periodic_scan_complete *notif;
			SYNC_RESP_STRUCT(notif, pkt);
a6710 1
		}
d6712 1
a6712 3
		case IWM_SCAN_ITERATION_COMPLETE: {
			struct iwm_lmac_scan_complete_notif *notif;
			SYNC_RESP_STRUCT(notif, pkt);
a6714 1
		}
d6716 1
a6716 3
		case IWM_SCAN_COMPLETE_UMAC: {
			struct iwm_umac_scan_complete *notif;
			SYNC_RESP_STRUCT(notif, pkt);
a6718 5
		}

		case IWM_SCAN_ITERATION_COMPLETE_UMAC: {
			struct iwm_umac_scan_iter_complete_notif *notif;
			SYNC_RESP_STRUCT(notif, pkt);
d6720 1
a6722 1
		}
d6726 1
a6726 1
			SYNC_RESP_STRUCT(resp, pkt);
d6733 1
a6733 3
		case IWM_TIME_EVENT_NOTIFICATION: {
			struct iwm_time_event_notif *notif;
			SYNC_RESP_STRUCT(notif, pkt);
a6734 1
		}
d6746 1
a6746 4
		case IWM_SCD_QUEUE_CFG: {
			struct iwm_scd_txq_cfg_rsp *rsp;
			SYNC_RESP_STRUCT(rsp, pkt);

a6747 1
		}
d6788 1
a6788 1
		ADVANCE_RXQ(sc);
@


1.173
log
@Tell MiRA about the actual number of retries instead of pretending that
a frame which was retried N times was retried just once.
This punishes retry-heavy data rates even more and should reduce latency.
It does not seem to have a noticable effect on net throughput in my testing.
If this change causes throughput problems for anyone, let me know.
ok tb@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.172 2017/04/24 09:48:42 stsp Exp $	*/
d359 1
a359 1
int	iwm_rx_addbuf(struct iwm_softc *, int, int);
d1064 1
a1064 1
		err = iwm_rx_addbuf(sc, IWM_RBUF_SIZE, i);
d3164 1
a3164 1
iwm_rx_addbuf(struct iwm_softc *sc, int size, int idx)
d3176 1
a3176 5
	if (size <= MCLBYTES) {
		MCLGET(m, M_DONTWAIT);
	} else {
		MCLGETI(m, M_DONTWAIT, NULL, IWM_RBUF_SIZE);
	}
d3198 2
a3199 1
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, size, BUS_DMASYNC_PREREAD);
d6565 1
a6565 1
			if (iwm_rx_addbuf(sc, IWM_RBUF_SIZE, sc->rxq.cur)) {
@


1.172
log
@Implement monitor mode support for iwm(4).

The magic commands to capture raw 802.11 frames on e.g. channel 1 are:
ifconfig iwm0 mediaopt monitor chan 1
tcpdump -n -i iwm0 -y IEEE802_11_RADIO -s 4096 -w /tmp/iwm.pcap
ifconfig iwm0 -mediaopt monitor -chan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.171 2017/04/24 09:31:31 stsp Exp $	*/
d3426 1
a3426 1
			in->in_mn.retries++;
@


1.171
log
@Implement support for multiple packets per receive DMA buffer in iwm(4).

We can now clear SINGLE_FRAME_MSK in the receive configuration register.
Linux has not set this bit in years, and Dragonfly stopped setting it
in commit b5eb43f0280bbcfd26af51cf5a4b8e8ff3590b67.
This is a prerequisite for monitor mode since the firmware seems to ignore
the SINGLE_FRAME_MSK bit while running in monitor mode and sends us garbage.

Tested on 7260, 7265, and 8260 devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.170 2017/04/21 17:54:02 stsp Exp $	*/
d4387 6
a4392 1
		IEEE80211_ADDR_COPY(&add_sta_cmd.addr, in->in_ni.ni_bssid);
d5032 7
a5038 1
	cmd->mac_type = htole32(IWM_FW_MAC_TYPE_BSS_STA);
d5128 1
d5136 11
a5146 3
	/* Allow beacons to pass through as long as we are not associated or we
	 * do not have dtim period information */
	if (!assoc || !ni->ni_associd || !ni->ni_dtimperiod)
d5233 4
a5236 1
	sc->sc_phyctxt[0].channel = in->in_ni.ni_chan;
d5264 3
d5494 3
a5496 1
	if (ostate == IEEE80211_S_RUN && nstate != ostate)
d5498 2
d5556 7
d5564 2
a5565 1
		if ((in->in_ni.ni_flags & IEEE80211_NODE_HT) &&
d5576 11
d6033 1
d6051 5
a6055 1
	ieee80211_begin_scan(ifp);
d7322 1
@


1.170
log
@Make id parameter of iwm_send_cmd_pdu() a uint32_t so that it matches
the size of the corresponding id field in struct iwm_host_cmd.
Patch by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.169 2017/04/21 16:40:11 stsp Exp $	*/
d365 2
a366 2
void	iwm_rx_rx_mpdu(struct iwm_softc *, struct iwm_rx_packet *,
	    struct iwm_rx_data *);
d452 1
a1675 1
	    IWM_FH_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK	|
d3299 2
a3300 3
void
iwm_rx_rx_mpdu(struct iwm_softc *sc, struct iwm_rx_packet *pkt,
    struct iwm_rx_data *data)
a3306 1
	struct mbuf *m;
a3307 1
	struct iwm_rx_mpdu_res_start *rx_res;
a3308 2
	uint32_t len;
	uint32_t rx_pkt_status;
a3310 3
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, IWM_RBUF_SIZE,
	    BUS_DMASYNC_POSTREAD);

d3312 1
a3312 9
	rx_res = (struct iwm_rx_mpdu_res_start *)pkt->data;
	wh = (struct ieee80211_frame *)(pkt->data + sizeof(*rx_res));
	len = le16toh(rx_res->byte_count);
	rx_pkt_status = le32toh(*(uint32_t *)(pkt->data +
	    sizeof(*rx_res) + len));

	m = data->m;
	m->m_data = pkt->data + sizeof(*rx_res);
	m->m_pkthdr.len = m->m_len = len;
d3315 1
a3315 5
		return;

	if (!(rx_pkt_status & IWM_RX_MPDU_RES_STATUS_CRC_OK) ||
	    !(rx_pkt_status & IWM_RX_MPDU_RES_STATUS_OVERRUN_OK))
		return; /* drop */
a3326 3
	if (iwm_rx_addbuf(sc, IWM_RBUF_SIZE, sc->rxq.cur) != 0)
		return;

d3395 2
d6454 1
a6454 1
iwm_notif_intr(struct iwm_softc *sc)
d6456 29
a6484 1
	uint16_t hw;
d6486 10
a6495 2
	bus_dmamap_sync(sc->sc_dmat, sc->rxq.stat_dma.map,
	    0, sc->rxq.stat_dma.size, BUS_DMASYNC_POSTREAD);
d6497 2
a6498 10
	hw = le16toh(sc->rxq.stat->closed_rb_num) & 0xfff;
	while (sc->rxq.cur != hw) {
		struct iwm_rx_data *data = &sc->rxq.data[sc->rxq.cur];
		struct iwm_rx_packet *pkt;
		struct iwm_cmd_response *cresp;
		int qid, idx, code;

		bus_dmamap_sync(sc->sc_dmat, data->map, 0, sizeof(*pkt),
		    BUS_DMASYNC_POSTREAD);
		pkt = mtod(data->m, struct iwm_rx_packet *);
d6500 3
d6505 1
d6507 4
a6510 1
		code = IWM_WIDE_ID(pkt->hdr.flags, pkt->hdr.code);
d6512 7
a6518 8
		/*
		 * randomly get these from the firmware, no idea why.
		 * they at least seem harmless, so just ignore them for now
		 */
		if (__predict_false((pkt->hdr.code == 0 && qid == 0 && idx == 0)
		    || pkt->len_n_flags == htole32(0x55550000))) {
			ADVANCE_RXQ(sc);
			continue;
d6521 3
d6529 10
a6538 2
		case IWM_REPLY_RX_MPDU_CMD:
			iwm_rx_rx_mpdu(sc, pkt, data);
d6540 1
d6759 20
@


1.169
log
@Fix nic lock usage around iwm_disable_rx_dma().
iwm_disable_rx_dma() was unintentionally releasing the nic lock too early.
Patch by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.168 2017/04/21 16:39:52 stsp Exp $	*/
d379 1
a379 1
int	iwm_send_cmd_pdu(struct iwm_softc *, uint8_t, uint32_t, uint16_t,
d383 1
a383 1
int	iwm_send_cmd_pdu_status(struct iwm_softc *, uint8_t, uint16_t,
d3767 2
a3768 2
iwm_send_cmd_pdu(struct iwm_softc *sc, uint8_t id, uint32_t flags, uint16_t len,
    const void *data)
d3821 1
a3821 1
iwm_send_cmd_pdu_status(struct iwm_softc *sc, uint8_t id, uint16_t len,
@


1.168
log
@Fix nic lock usages around iwm_{read,write}_prph().

The iwm_{read,write}_prph() calls don't grab the nic lock themselves
so make sure to acquire it where necessary.
The iwm_{set,clear}_bits_prph() on the other hand acquire/release the
nic lock themselves. Since the nic lock doesn't do recursive locking
we need to be careful to avoid accidentally releasing the nic lock
too early that way.

Patch by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.167 2017/04/04 00:40:52 claudio Exp $	*/
d1649 4
d1656 1
a1656 3
	memset(sc->rxq.stat, 0, sizeof(*sc->rxq.stat));

	iwm_disable_rx_dma(sc);
@


1.167
log
@Add 8265 and 3168 support. Both cards need new firmware files which currently
need to be installed by hand until the iwm-firmware package has been updated.
This includes handling (by ignoring) of IWM_UCODE_TLV_FW_MEM_SEG and
IWM_DEBUG_LOG_MSG firmware commands. Mostly stolen from dragonflybsd.
With this in the X270 has working ethernet and wifi.
Commit! deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.166 2017/03/08 12:02:41 mpi Exp $	*/
d1464 5
a1468 2
		iwm_read_prph(sc, IWM_OSC_CLK);
		iwm_read_prph(sc, IWM_OSC_CLK);
d1470 5
a1474 2
		iwm_read_prph(sc, IWM_OSC_CLK);
		iwm_read_prph(sc, IWM_OSC_CLK);
d1485 5
a1489 2
		iwm_write_prph(sc, IWM_APMG_CLK_EN_REG,
		    IWM_APMG_CLK_VAL_DMA_CLK_RQT);
d1497 5
a1501 2
		iwm_write_prph(sc, IWM_APMG_RTC_INT_STT_REG,
		    IWM_APMG_RTC_INT_STT_RFKILL);
a1553 3
	/* Deactivate TX scheduler. */
	iwm_write_prph(sc, IWM_SCD_TXFACT, 0);

d1556 3
d1581 6
a1586 4
	/*
	 * Power-down device's busmaster DMA clocks
	 */
	iwm_write_prph(sc, IWM_APMG_CLK_DIS_REG, IWM_APMG_CLK_VAL_DMA_CLK_RQT);
d2855 1
a2855 1
	    dst_addr <= IWM_FW_MEM_EXTENDED_END && iwm_nic_lock(sc)) {
a2857 1
		iwm_nic_unlock(sc);
d2977 5
a2981 1
	iwm_write_prph(sc, IWM_RELEASE_CPU_RESET, IWM_RELEASE_CPU_RESET_BIT);
@


1.166
log
@Do not clear IFF_UP, even in the error path, clearing IFF_RUNNING
is enough.

This flag should only be set by the stack, drivers shouldn't mess
with it.

Discussed with dlg@@ and mikeb@@, ok mikeb@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.165 2017/02/20 15:38:04 krw Exp $	*/
d792 3
d6679 7
d6871 1
d6878 1
d7044 6
d7067 6
@


1.165
log
@Remove hack to release/re-acquire netlock in _ioctl().

A short hang in X11 during an ifconfig scan is better than making
tcpdump(8) an express ticket to the ddb prompt.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.164 2017/02/16 10:15:12 mpi Exp $	*/
a6153 2
				if (err)
					ifp->if_flags &= ~IFF_UP;
a6801 1
		ifp->if_flags &= ~IFF_UP;
a6818 1
			ifp->if_flags &= ~IFF_UP;
@


1.164
log
@Revert "Release the NET_LOCK() before entering per-driver ioctl() routine".

This is most likely to be the cause of the deadlock seen by port builders
since it's the only changed that happened after a2k17.

Instead bring back pirofti@@ original hack to release the NET_LOCK() inside
iwm(4) and iwn(4).

This fixes some splassert reported by bluhm@@

Deadlock reported by naddy@@ and rpe@@ and ajacoutot@@ confirmed the deadlock
has been introduced post a2k17.

Tested by and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.163 2017/02/07 10:08:21 mpi Exp $	*/
a6135 3
	/* XXXSMP breaks atomicity */
	rw_exit_write(&netlock);

d6141 1
a6141 2
	if (err) {
		rw_enter_write(&netlock);
a6142 1
	}
a6187 1
	rw_enter_write(&netlock);
@


1.163
log
@Release the NET_LOCK() before entering per-driver ioctl() routine.

This prevents a deadlock with the X server and some wireless drivers.
The real fix is to take unix domain socket code out of the NET_LOCK().

Issue reported by pirofti@@ and ajacoutot@@

ok tb@@, stsp@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.162 2017/02/04 19:20:59 guenther Exp $	*/
d6136 3
d6144 2
a6145 1
	if (err)
d6147 1
d6193 1
@


1.162
log
@Prefer <sys/endian.h> to <machine/endian.h>

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.161 2017/02/04 15:02:46 pirofti Exp $	*/
a6135 3
	/* XXXSMP breaks atomicity */
	rw_exit_write(&netlock);

d6141 1
a6141 2
	if (err) {
		rw_enter_write(&netlock);
a6142 1
	}
a6187 1
	rw_enter_write(&netlock);
@


1.161
log
@Prevent netlock related deadlock with the X server during iwm(4) scans.


The issue appears at least with 7265 and 8260 chips as confirmed by
stsp@@, tb@@ and myself.

Fixed by unlocking NET_LOCK() at the beginning of iwmioctl() and
relocking it at the end.

Guidance and ok mpi@@, ok stsp@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.160 2017/01/29 09:44:25 stsp Exp $	*/
d121 1
a124 1
#include <machine/endian.h>
@


1.160
log
@The iwm_get_active_dwell() and iwm_get_passive_dwell() functions are
unused, and where removed in Linux iwlwifi git commit
9437e9941025bc83d3dd43f2927019149029f667.

Patch by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.159 2017/01/29 09:41:36 stsp Exp $	*/
d6136 2
d6144 2
a6145 1
	if (err)
d6147 1
d6193 1
@


1.159
log
@In iwm(4), remove old deprecated scan API definitions which have been
unused since the upgrade to version 16 firmware.

Also, matching the iwlwifi code, use IWM_DEFAULT_SCAN_CHANNELS (== 40)
instead of IWM_MAX_NUM_SCAN_CHANNELS (== 36) as default value for
sc->sc_capa_n_scan_channels.

Mostly matches the header-file changes in Linux iwlwifi git
commit 1f9403863c080478ad78247c89b018e95bdfb027.

Patch by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.158 2017/01/22 10:17:38 dlg Exp $	*/
a411 2
uint16_t iwm_get_active_dwell(struct iwm_softc *, int, int);
uint16_t iwm_get_passive_dwell(struct iwm_softc *, int);
a4459 6
#define IWM_PLCP_QUIET_THRESH 1
#define IWM_ACTIVE_QUIET_TIME 10
#define LONG_OUT_TIME_PERIOD 600
#define SHORT_OUT_TIME_PERIOD 200
#define SUSPEND_TIME_PERIOD 100

a4494 24
}

/*
 * If req->n_ssids > 0, it means we should do an active scan.
 * In case of active scan w/o directed scan, we receive a zero-length SSID
 * just to notify that this scan is active and not passive.
 * In order to notify the FW of the number of SSIDs we wish to scan (including
 * the zero-length one), we need to set the corresponding bits in chan->type,
 * one for each SSID, and set the active bit (first). If the first SSID is
 * already included in the probe template, so we need to set only
 * req->n_ssids - 1 bits in addition to the first bit.
 */
uint16_t
iwm_get_active_dwell(struct iwm_softc *sc, int flags, int n_ssids)
{
	if (flags & IEEE80211_CHAN_2GHZ)
		return 30  + 3 * (n_ssids + 1);
	return 20  + 2 * (n_ssids + 1);
}

uint16_t
iwm_get_passive_dwell(struct iwm_softc *sc, int flags)
{
	return (flags & IEEE80211_CHAN_2GHZ) ? 100 + 20 : 100 + 10;
@


1.158
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.157 2017/01/21 11:21:41 stsp Exp $	*/
d528 2
d593 1
a593 1
	sc->sc_capa_n_scan_channels = IWM_MAX_NUM_SCAN_CHANNELS;
a6640 1
		case IWM_SCAN_REQUEST_CMD:
@


1.157
log
@In iwm(4), cancel mira timeouts in iwm_stop() and iwm_newstate() instead of
relying on the newstate task to do so. Fixes races of driver code against
mira timeouts leading to crashes in some situations, e.g. occasionally when
changing channels while the interface is up.
ok procter@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.156 2017/01/12 18:06:57 stsp Exp $	*/
a3439 2
	else
		ifp->if_opackets++;
@


1.156
log
@Rename ieee80211_mira_node_destroy() to ieee80211_mira_cancel_timeouts().
No functional change.

The previous name was chosen at a time when I could not yet anticipate
what this function would really end up doing.
The new name should make this function's purpose more obvious, especially
where it appears at strategic places in driver code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.155 2016/12/18 10:37:42 stsp Exp $	*/
d5499 1
a5499 1
	if (ostate == IEEE80211_S_RUN && nstate != ostate) {
a5500 2
		ieee80211_mira_cancel_timeouts(&in->in_mn);
	}
d5633 1
d5636 2
d6120 2
@


1.155
log
@While copying out channel flags to userspace, omit the HT channel flag if
we're not in 11n mode. This will allow tcpdump to show the mode correctly.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.154 2016/12/10 19:03:53 stsp Exp $	*/
d5501 1
a5501 1
		ieee80211_mira_node_destroy(&in->in_mn);
@


1.154
log
@Add support for MIMO Tx rates (MCS 8-15) to iwm(4).

The nominal maximum Tx rate is now 144Mbit/s (MCS 15, 20MHz channel, SGI).
In practice it's more around 30Mbit/s, though. The most significant limiting
factor is probably lack of Tx aggregation support. (Due to protocol overhead,
reaching the nominal max is pretty much impossible anyway. When shopping wifi
devices, do not believe what stickers on the box are saying; full of lies!)

But APs will send us aggregates, so Rx should be faster than Tx (which was
already the case, just less pronounced).

Tested by phessler@@, bmercer@@, tb@@
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.153 2016/12/10 13:56:38 stsp Exp $	*/
d3342 1
d3349 4
a3352 2
		tap->wr_chan_flags =
		    htole16(ic->ic_channels[phy_info->channel].ic_flags);
d3997 1
d4001 4
a4004 1
		tap->wt_chan_flags = htole16(ni->ni_chan->ic_flags);
@


1.153
log
@In iwm(4), do not enable HT protection (RTS) unconditionally if the AP requires
protection from 20MHz-only STAs on a 40MHz channel. We do not support 40MHz
channels yet so there is nothing to protect ourselves from. It is the 40MHz
users who need to start using RTS when a 20MHz-only user shows up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.152 2016/12/10 13:22:07 stsp Exp $	*/
d186 1
a186 1
	uint8_t rate;
d198 1
d201 1
d203 1
d205 1
d208 4
d229 8
d244 2
d469 15
d2392 1
a2398 1
#ifdef notyet
d2402 3
a2404 1
	if (iwm_fw_valid_rx_ant(sc) > 1)
a2405 3
	if (iwm_fw_valid_rx_ant(sc) > 2)
		ic->ic_sup_mcs[2] = 0xff;	/* MCS 16-23 */
#endif
d3927 4
a3930 1
	rate_flags = 1 << IWM_RATE_MCS_ANT_POS;
d5345 1
a5345 1
	int i, ridx, ridx_min, j, sgi_ok, tab = 0;
d5372 6
a5377 1
	for (ridx = IWM_RIDX_MAX; ridx >= ridx_min; ridx--) {
d5382 5
a5386 1
		    iwm_rates[ridx].ht_plcp != IWM_RATE_HT_SISO_MCS_INV_PLCP) {
d5391 1
a5391 1
					tab = iwm_rates[ridx].ht_plcp;
d5399 1
a5399 1
		if (tab == 0 && iwm_rates[ridx].plcp != IWM_RATE_INVM_PLCP) {
d5403 1
a5403 1
					tab = iwm_rates[ridx].plcp;
d5412 5
a5416 1
		tab |= 1 << IWM_RATE_MCS_ANT_POS;
d5552 12
d5719 1
a5719 4
#ifdef notyet
			if (ni->ni_rxmcs[2] != 0)
				watermark = IWM_SF_W_MARK_MIMO3;
			else if (ni->ni_rxmcs[1] != 0)
a5721 1
#endif
d7212 2
@


1.152
log
@Make retry-heavy rates less attractive to mira.
The number of retried frames shrinks significantly.
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.151 2016/12/08 17:24:25 stsp Exp $	*/
d5056 1
d5058 6
a5063 3
			cmd->protection_flags |=
			    htole32(IWM_MAC_PROT_FLG_HT_PROT |
			    IWM_MAC_PROT_FLG_FAT_PROT);
@


1.151
log
@iwm(4) was stripping some bits from the MCS index value before passing
it to bpf for tcpdump(8). Fix it so MCS >= 8 get passed on correctly.
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.150 2016/12/06 12:57:20 stsp Exp $	*/
d3389 3
a3391 2
		if (txfail) {
			in->in_mn.retries += tx_resp->failure_frame;
a3392 1
		}
@


1.150
log
@Make sure iwm(4) only calls ieee80211_mira_choose() while in RUN state.
Should fix "panic: timeout_add: not initialized" reported by danj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.149 2016/11/30 14:31:51 stsp Exp $	*/
d3324 2
a3325 1
			    htole32(IWM_RATE_HT_MCS_RATE_CODE_MSK));
@


1.149
log
@Switch the iwm(4) driver to mira rate adaptation in 11n mode.
Only the rate adaptation algorithm changes, available data rates do not (yet).
Please let me know about any regressions.

In 11a/b/g modes the driver still uses AMRR, so forcing one of these modes
with ifconfig's 'mode' subcommand will serve as a fallback if necessary.

ok tb@@ mpi@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.148 2016/11/19 21:07:08 stsp Exp $	*/
d3392 2
a3393 1
		ieee80211_mira_choose(&in->in_mn, ic, &in->in_ni);
@


1.148
log
@While setting up the basic rate bitmask for iwm's firmware, if the AP does
not specify basic rates for either the CCK or OFDM set, add just the most
basic rate to that set (1 Mbit/s in case of CCK, 6 Mbit/s in case of OFDM).
This behaviour matches what code comments seem to imply.

The previous code would add all possible basic rates in such cases.
So if all basic rates were CCK only, the code would add all possible OFDM basic
rates on top. Then the firmware would send some frames at too high rates, e.g.
RTS frames would be sent at 24Mbit/s which is a bit risky on noisy channels.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.147 2016/11/17 14:12:33 stsp Exp $	*/
d143 1
d3367 1
d3371 3
a3373 1
	int failack = tx_resp->failure_frame;
d3375 2
a3376 1
	KASSERT(tx_resp->frame_count == 1);
d3379 20
a3398 3
	in->in_amn.amn_txcnt++;
	if (failack > 0) {
		in->in_amn.amn_retrycnt++;
d3401 1
a3401 2
	if (status != IWM_TX_STATUS_SUCCESS &&
	    status != IWM_TX_STATUS_DIRECT_DONE)
d5269 1
d5271 1
a5271 4
		if (ni->ni_flags & IEEE80211_NODE_HT)
			otxrate = ni->ni_txmcs;
		else
			otxrate = ni->ni_txrate;
a5272 1

d5277 1
a5277 4
		if ((ni->ni_flags & IEEE80211_NODE_HT) &&
		    otxrate != ni->ni_txmcs)
			task_add(systq, &sc->setrates_task);
		else if (otxrate != ni->ni_txrate)
d5427 1
a5427 1
	struct iwm_node *in;
d5438 1
a5438 1
	if (ostate == IEEE80211_S_RUN && nstate != ostate)
d5440 2
a5497 2
		in = (struct iwm_node *)ic->ic_bss;

d5539 1
@


1.147
log
@Make iwm(4) pass Tx/Rx MCS rates to bpf so they can be examined with tcpdump.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.146 2016/11/01 13:49:50 stsp Exp $	*/
d4899 2
a4900 2
	int lowest_present_ofdm = 100;
	int lowest_present_cck = 100;
d4911 1
a4911 1
			if (lowest_present_cck > i)
d4919 1
a4919 1
		if (lowest_present_ofdm > i)
@


1.146
log
@Reset the ucode interrupt flag in the softc before loading iwm(4) 8k firmware.
Makes firmware load work reliably without the horrid tsleep() workaround hack.
Patch by Imre Vadasz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.145 2016/10/19 14:15:07 stsp Exp $	*/
a3321 1
#ifdef notyet
d3324 1
a3324 3
#endif
			/* XXX need a way to pass current MCS in 11n mode */
			tap->wr_rate = 0;
d3940 5
a3944 3
		if (rinfo->plcp == IWM_RATE_INVM_PLCP) {
			/* XXX need a way to pass current MCS in 11n mode */
			tap->wt_rate = 0;
@


1.145
log
@Only force iwm's firmware to use RTS for all frames if the AP requires it.
RTS is still used when sending long frames regardless of this change.
Tested by myself and Jan Stary.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.144 2016/10/08 14:37:48 stsp Exp $	*/
a2822 2
	sc->sc_uc.uc_intr = 0;

d2944 2
a2959 6

	/*
	 * Give the firmware some time to initialize.
	 * Accessing it too early causes errors.
	 */
	tsleep(&w, PCATCH, "iwmfwinit", hz);
@


1.144
log
@Rate sets managed by net80211 are sorted by effective data rate speed while
the iwm_rates array sorts CCK rates before OFDM rates. Add a mapping function
to fill the ACK rate bitmap correctly.
Problem pointed out by Imre Vadasz.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.143 2016/10/05 18:13:25 stsp Exp $	*/
d5304 3
a5306 1
	lq->flags = IWM_LQ_FLAG_USE_RTS_MSK;
@


1.143
log
@Set the USE_RTS flag in the right place. Error introduced in if_iwm.c r1.139.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.142 2016/09/27 15:54:33 stsp Exp $	*/
d401 1
d4885 15
d4914 2
a4915 2
		for (i = 0; i < MIN(IWM_FIRST_OFDM_RATE, rs->rs_nrates); i++) {
			if ((rs->rs_rates[i] & IEEE80211_RATE_BASIC) == 0)
d4922 2
a4923 3
	for (i = IWM_FIRST_OFDM_RATE;
	    i <= MIN(IWM_LAST_NON_HT_RATE, rs->rs_nrates - 1); i++) {
		if ((rs->rs_rates[i] & IEEE80211_RATE_BASIC) == 0)
@


1.142
log
@Wait until the BSSID is known before adding the MAC context to iwm firmware.
Fixes iwm connectivity issues after first boot.
Tested by myself (8260 chip) and tb@@ (7265 chip)
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.141 2016/09/22 08:28:38 stsp Exp $	*/
a5284 1
		.flags = IWM_LQ_FLAG_USE_RTS_MSK,
d5289 1
@


1.141
log
@Remove some unused cruft from iwm, including a local namespace-polluting
definition of an ieee80211_tu_to_usec() macro...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.140 2016/09/22 08:27:56 stsp Exp $	*/
d5174 7
a5752 1
	struct iwm_node *in = (struct iwm_node *)ic->ic_bss;
a5873 7

	err = iwm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_ADD, 0);
	if (err) {
		printf("%s: could not add MAC context (error %d)\n",
		    DEVNAME(sc), err);
		goto err;
 	}
@


1.140
log
@Simplify assignment of sgi_ok variable in iwm_setrates(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.139 2016/09/21 14:02:33 stsp Exp $	*/
a391 2
uint32_t iwm_scan_max_out_time(struct iwm_softc *, uint32_t, int);
uint32_t iwm_scan_suspend_time(struct iwm_softc *, int);
a4420 20
}

#define ieee80211_tu_to_usec(a) (1024*(a))

uint32_t
iwm_scan_max_out_time(struct iwm_softc *sc, uint32_t flags, int is_assoc)
{
	if (!is_assoc)
		return 0;
	if (flags & 0x1)
		return htole32(ieee80211_tu_to_usec(SHORT_OUT_TIME_PERIOD));
	return htole32(ieee80211_tu_to_usec(LONG_OUT_TIME_PERIOD));
}

uint32_t
iwm_scan_suspend_time(struct iwm_softc *sc, int is_assoc)
{
	if (!is_assoc)
		return 0;
	return htole32(ieee80211_tu_to_usec(SUSPEND_TIME_PERIOD));
@


1.139
log
@Always set the bit which allows RTS in iwm's LQ command.
This bit was only set in 11n mode previously.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.138 2016/09/21 13:57:35 stsp Exp $	*/
d5306 2
a5307 4
	if (ni->ni_flags & IEEE80211_NODE_HT)
		sgi_ok = (ni->ni_htcaps & IEEE80211_HTCAP_SGI20);
	else
		sgi_ok = 0;
@


1.138
log
@Make iwm protect the session during association more like Linux does it.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.137 2016/09/21 13:53:18 stsp Exp $	*/
d5300 1
a5300 1
		.flags = 0,
d5306 1
a5306 3
	/* For HT, enable RTS/CTS, and SGI (if supported). */
	if (ni->ni_flags & IEEE80211_NODE_HT) {
		lq->flags |= IWM_LQ_FLAG_USE_RTS_MSK;
d5308 1
a5308 1
	} else
@


1.137
log
@Properly support the mac context command in iwm. This was wrong in many ways.
This commit includes style fixes as well as actual bug fixes.

Remove the global in_assoc flag from the softc. We can just pass a fixed
argument to functions to indicate whether we're already associated.

Remove in_tfsid from the softc as well. It was implicitly set to zero
and never changed. A corresponding macro already exists so use it instead.

Always copy the BSSID into the mac context command, as the Linux driver does.
This helps the firmware during association.

Set the firmware state to 'associated' once we've moved to RUN state
and our assoc ID is known. Earlier versions of iwm used to set the
firmware to 'associated' but this was disabled in r1.91 since it
didn't work correctly due to bugs which are now fixed.

Use live DTIM information obtained from the AP, rather than using the
default DTIM period of our wireless stack.

Check return values of functions called after moving to RUN state.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.136 2016/09/21 13:29:11 stsp Exp $	*/
d5214 5
a5218 3
	/* XXX duration is in units of TU, not MS */
	duration = IWM_TE_SESSION_PROTECTION_MAX_TIME_MS;
	iwm_protect_session(sc, in, duration, 500 /* XXX magic number */);
@


1.136
log
@Make iwm return EBUSY from its ic_ampdu_rx_start() handler and
call the functions provided by the wireless stack to accept or
refuse BA agreements depending on the status returned by firmware.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.135 2016/09/21 13:22:40 stsp Exp $	*/
d405 1
a405 1
	    struct iwm_mac_ctx_cmd *, uint32_t);
d408 1
a408 1
int	iwm_mac_ctxt_cmd(struct iwm_softc *, struct iwm_node *, uint32_t);
d2435 1
a2435 1
	err = iwm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY);
d4995 1
a4995 1
    struct iwm_mac_ctx_cmd *cmd, uint32_t action)
d5008 1
a5008 1
	cmd->tsf_id = htole32(in->in_tsfid);
d5011 2
a5012 5
	if (in->in_assoc) {
		IEEE80211_ADDR_COPY(cmd->bssid_addr, ni->ni_bssid);
	} else {
		IEEE80211_ADDR_COPY(cmd->bssid_addr, etherbroadcastaddr);
	}
d5067 1
a5067 1
    struct iwm_mac_data_sta *ctxt_sta, int force_assoc_off)
d5070 2
a5071 8
	struct ieee80211com *ic = &sc->sc_ic;

	ctxt_sta->is_assoc = htole32(0);
	ctxt_sta->bi = htole32(ni->ni_intval);
	ctxt_sta->bi_reciprocal = htole32(iwm_reciprocal(ni->ni_intval));
	ctxt_sta->dtim_interval = htole32(ni->ni_intval * ic->ic_dtim_period);
	ctxt_sta->dtim_reciprocal =
	    htole32(iwm_reciprocal(ni->ni_intval * ic->ic_dtim_period));
d5073 14
a5086 3
	/* 10 = CONN_MAX_LISTEN_INTERVAL */
	ctxt_sta->listen_interval = htole32(10);
	ctxt_sta->assoc_id = htole32(ni->ni_associd);
d5090 2
a5091 1
iwm_mac_ctxt_cmd(struct iwm_softc *sc, struct iwm_node *in, uint32_t action)
d5093 1
d5098 1
a5098 1
	iwm_mac_ctxt_cmd_common(sc, in, &cmd, action);
d5102 1
a5102 1
	if (!in->in_assoc || !sc->sc_ic.ic_dtim_period)
d5105 1
a5105 5
		cmd.filter_flags &= ~htole32(IWM_MAC_FILTER_IN_BEACON);

	/* Fill the data specific for station mode */
	iwm_mac_ctxt_cmd_fill_sta(sc, in,
	    &cmd.sta, action == IWM_FW_CTXT_ACTION_ADD);
d5107 1
a5107 2
	return iwm_send_cmd_pdu(sc, IWM_MAC_CONTEXT_CMD, 0, sizeof(cmd),
	    &cmd);
a5180 2
	in->in_assoc = 0;

d5204 1
a5204 1
	err = iwm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY);
a5232 8
	in->in_assoc = 1;

	err = iwm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY);
	if (err) {
		printf("%s: failed to update MAC\n", DEVNAME(sc));
		return err;
	}

a5435 4
		in = (struct iwm_node *)ic->ic_bss;
		if (in)
			in->in_assoc = 0;

d5489 14
a5502 1
		iwm_power_mac_update_mode(sc, in);
d5509 6
a5514 1
		iwm_enable_beacon_filter(sc, in);
d5516 13
a5528 1
		iwm_update_quotas(sc, in);
d5893 1
a5893 1
	err = iwm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_ADD);
a6048 1
	in->in_assoc = 0;
@


1.135
log
@For the keep-alive period in iwm's power command, use the DTIM period
specified by the AP, rather than the default DTIM period of our wireless
stack (which is not applicable when running as a client anyway).
And tell the firmware to disable power-saving.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.134 2016/09/21 13:08:34 stsp Exp $	*/
d2382 1
d2388 2
a2389 1
	if (start && sc->sc_rx_ba_sessions >= IWM_MAX_RX_BA_SESSIONS)
d2391 1
a2411 2
	if (err)
		return;
d2413 3
a2415 3
	if (status == IWM_ADD_STA_SUCCESS) {
		s = splnet();
		if (start)
d2417 2
a2418 1
		else if (sc->sc_rx_ba_sessions > 0)
d2420 4
a2423 2
		splx(s);
	}
d2486 1
a2486 1
	return 0; /* XXX firmware may still fail to add BA agreement... */
@


1.134
log
@Copy the AP's actual EDCA parameters into iwm's mac context command
rather than some fixed values present in this file since r1.1.
Allows the firmware to properly time its transmissions in 11n networks.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.133 2016/09/21 12:56:43 stsp Exp $	*/
a4205 1
	struct ieee80211com *ic = &sc->sc_ic;
d4207 1
a4207 2
	int dtimper, dtimper_msec;
	int keep_alive;
d4211 4
a4214 1
	dtimper = ic->ic_dtim_period ?: 1;
d4222 2
a4223 3
	dtimper_msec = dtimper * ni->ni_intval;
	keep_alive
	    = MAX(3 * dtimper_msec, 1000 * IWM_POWER_KEEP_ALIVE_PERIOD_SEC);
d4226 6
d4259 1
d4261 1
d5841 1
a5841 1
		printf("%s: could send power update command (error %d)\n",
@


1.133
log
@Add the BSS's basic rates to iwm's LQ command, not all the rates.
Makes the firmware use appropriate Tx rates for ACKs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.132 2016/09/12 10:18:26 stsp Exp $	*/
d4985 1
d5015 7
a5021 6
	for (i = 0; i < IWM_AC_NUM+1; i++) {
		int txf = i;

		cmd->ac[txf].cw_min = htole16(0x0f);
		cmd->ac[txf].cw_max = htole16(0x3f);
		cmd->ac[txf].aifsn = 1;
d5023 1
a5023 1
		cmd->ac[txf].edca_txop = 0;
d5025 2
d5053 1
@


1.132
log
@Simplify handling of the AUX STA in iwm(4). There is no good reason for
storing AUX STA data in the softc. Also, simplify error handling around
iwm_send_cmd_pdu_status(), and inline its iwm_add_int_sta_common() helper
along with fixing an uninitialized 'status' output parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.131 2016/09/10 10:00:41 stsp Exp $	*/
d4899 1
d4908 3
a4910 1
		for (i = 0; i <= IWM_LAST_CCK_RATE; i++) {
d4916 5
a4920 3
	for (i = IWM_FIRST_OFDM_RATE; i <= IWM_LAST_NON_HT_RATE; i++) {
		int adj = i - IWM_FIRST_OFDM_RATE;
		ofdm |= (1 << adj);
@


1.131
log
@Use consistent indentation for multi-line function prototypes in iwm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.130 2016/09/10 09:40:24 stsp Exp $	*/
a389 2
int	iwm_add_int_sta_common(struct iwm_softc *, struct iwm_int_sta *,
	    const uint8_t *, uint16_t, uint16_t);
d2407 2
a2408 2
	err = iwm_send_cmd_pdu_status(sc, IWM_ADD_STA,
	    sizeof(cmd), &cmd, &status);
d2412 1
a2412 2
	switch (status) {
	case IWM_ADD_STA_SUCCESS:
a2418 7
		break;
	case IWM_ADD_STA_IMMEDIATE_BA_FAILURE:
		err = EIO;
		break;
	default:
		err = EIO;
		break;
d3464 1
a3464 4
	if (err)
		return err;

	if (status)
d3988 1
a3988 1
		tx->sta_id = sc->sc_aux_sta.sta_id;
d4360 1
a4360 7
	if (err)
		return err;

	switch (status) {
	case IWM_ADD_STA_SUCCESS:
		break;
	default:
a4361 2
		break;
	}
d4367 1
a4367 2
iwm_add_int_sta_common(struct iwm_softc *sc, struct iwm_int_sta *sta,
    const uint8_t *addr, uint16_t mac_id, uint16_t color)
d4373 4
d4378 4
a4381 4
	cmd.sta_id = sta->sta_id;
	cmd.mac_id_n_color = htole32(IWM_FW_CMD_ID_AND_COLOR(mac_id, color));

	cmd.tfd_queue_msk = htole32(sta->tfd_queue_msk);
d4384 4
a4387 12
	if (addr)
		memcpy(cmd.addr, addr, ETHER_ADDR_LEN);

	err = iwm_send_cmd_pdu_status(sc, IWM_ADD_STA,
	    sizeof(cmd), &cmd, &status);
	if (err)
		return err;

	switch (status) {
	case IWM_ADD_STA_SUCCESS:
		return 0;
	default:
a4388 16
		break;
	}
	return err;
}

int
iwm_add_aux_sta(struct iwm_softc *sc)
{
	int err;

	sc->sc_aux_sta.sta_id = IWM_AUX_STA_ID;
	sc->sc_aux_sta.tfd_queue_msk = (1 << IWM_AUX_QUEUE);

	err = iwm_enable_txq(sc, 0, IWM_AUX_QUEUE, IWM_TX_FIFO_MCAST);
	if (err)
		return err;
a4389 5
	err = iwm_add_int_sta_common(sc,
	    &sc->sc_aux_sta, NULL, IWM_MAC_INDEX_AUX, 0);

	if (err)
		memset(&sc->sc_aux_sta, 0, sizeof(sc->sc_aux_sta));
d4694 1
a4694 1
	req->tx_cmd[0].sta_id = sc->sc_aux_sta.sta_id;
d4701 1
a4701 1
	req->tx_cmd[1].sta_id = sc->sc_aux_sta.sta_id;
d4778 1
a4778 1
	scan_config->bcast_sta_id = sc->sc_aux_sta.sta_id;
@


1.130
log
@Rename the global nvm_to_read const int array to iwm_nvm_to_read.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.129 2016/09/10 09:32:33 stsp Exp $	*/
d229 1
a229 1
					uint8_t *, size_t);
d242 1
a242 1
		    uint32_t);
d245 2
a246 2
int	iwm_dma_contig_alloc(bus_dma_tag_t, struct iwm_dma_info *,
				bus_size_t, bus_size_t);
d276 1
a276 1
				uint16_t);
d278 1
a278 1
				struct iwm_calib_res_notif_phy_db *);
d284 1
a284 1
					uint16_t *, uint16_t);
d286 2
a287 2
int	iwm_phy_db_send_all_channel_groups(struct iwm_softc *,
		uint16_t, uint8_t);
d290 1
a290 1
				struct iwm_time_event_cmd_v1 *);
d292 3
a294 3
					const struct iwm_time_event_cmd_v2 *);
void	iwm_protect_session(struct iwm_softc *, struct iwm_node *,
				uint32_t, uint32_t);
d296 1
a296 1
				uint8_t *, uint16_t *);
d298 1
a298 1
				uint16_t *, size_t);
d300 1
a300 1
				const uint8_t *nvm_channels, size_t nchan);
d304 6
a309 6
int	iwm_ampdu_rx_start(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
void	iwm_ampdu_rx_stop(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
void	iwm_sta_rx_agg(struct iwm_softc *, struct ieee80211_node *,
				uint8_t, uint16_t, int);
d311 4
a314 4
int	iwm_ampdu_tx_start(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
void	iwm_ampdu_tx_stop(struct ieee80211com *,
		    struct ieee80211_node *, uint8_t);
d319 3
a321 3
				const uint16_t *, const uint16_t *,
				const uint16_t *, const uint16_t *,
				const uint16_t *);
d323 1
a323 1
				const uint16_t *, const uint16_t *);
d327 1
a327 1
				uint32_t);
d329 1
a329 1
				uint32_t);
d332 1
a332 1
					int , int *);
d342 1
a342 2
int	iwm_get_signal_strength(struct iwm_softc *,
					struct iwm_rx_phy_info *);
d344 1
a344 1
				struct iwm_rx_data *);
d347 1
a347 1
				struct iwm_rx_data *);
d349 1
a349 1
				struct iwm_node *);
d351 1
a351 1
			struct iwm_rx_data *);
d354 5
a358 6
			struct iwm_phy_context_cmd *, uint32_t, uint32_t);
void	iwm_phy_ctxt_cmd_data(struct iwm_softc *,
		struct iwm_phy_context_cmd *, struct ieee80211_channel *,
		uint8_t, uint8_t);
int	iwm_phy_ctxt_cmd(struct iwm_softc *, struct iwm_phy_ctxt *,
				uint8_t, uint8_t, uint32_t, uint32_t);
d361 1
a361 1
				const void *);
d363 3
a365 3
				uint32_t *);
int	iwm_send_cmd_pdu_status(struct iwm_softc *, uint8_t,
					uint16_t, const void *, uint32_t *);
d370 1
a370 1
			struct ieee80211_frame *, struct iwm_tx_cmd *);
d379 3
a381 3
					struct iwm_beacon_filter_cmd *);
void	iwm_beacon_filter_set_cqm_params(struct iwm_softc *,
			struct iwm_node *, struct iwm_beacon_filter_cmd *);
d384 1
a384 1
				struct iwm_mac_power_cmd *);
d391 1
a391 1
				const uint8_t *, uint16_t, uint16_t);
d400 1
a400 1
				struct iwm_scan_channel_cfg_lmac *, int);
d407 1
a407 1
					struct iwm_mac_ctx_cmd *, uint32_t);
d409 1
a409 1
					struct iwm_mac_data_sta *, int);
d467 2
a468 2
iwm_firmware_store_section(struct iwm_softc *sc,
	enum iwm_ucode_type type, uint8_t *data, size_t dlen)
d857 2
a858 2
iwm_poll_bit(struct iwm_softc *sc, int reg,
	uint32_t bits, uint32_t mask, int timo)
d904 2
a905 2
iwm_set_bits_mask_prph(struct iwm_softc *sc,
	uint32_t reg, uint32_t bits, uint32_t mask)
d1866 1
a1866 1
	struct iwm_calib_res_notif_phy_db *phy_db_notif)
d1962 2
a1963 2
iwm_phy_db_get_section_data(struct iwm_softc *sc,
	uint32_t type, uint8_t **data, uint16_t *size, uint16_t ch_id)
d1984 2
a1985 2
iwm_send_phy_db_cmd(struct iwm_softc *sc, uint16_t type,
	uint16_t length, void *data)
d2005 2
a2006 2
iwm_phy_db_send_all_channel_groups(struct iwm_softc *sc,
	uint16_t type, uint8_t max_ch_groups)
d2098 1
a2098 1
	struct iwm_time_event_cmd_v1 *cmd_v1)
d2122 1
a2122 1
	const struct iwm_time_event_cmd_v2 *cmd)
d2137 1
a2137 1
	uint32_t duration, uint32_t max_delay)
d2188 2
a2189 2
iwm_nvm_read_chunk(struct iwm_softc *sc, uint16_t section,
	uint16_t offset, uint16_t length, uint8_t *data, uint16_t *len)
d2259 2
a2260 2
iwm_nvm_read_section(struct iwm_softc *sc,
	uint16_t section, uint8_t *data, uint16_t *len, size_t max_len)
d2311 1
a2311 1
			const uint8_t *nvm_channels, size_t nchan)
d2381 2
a2382 2
iwm_sta_rx_agg(struct iwm_softc *sc, struct ieee80211_node *ni,
    uint8_t tid, uint16_t ssn, int start)
d2512 1
a2512 1
	const uint16_t *mac_override, const uint16_t *nvm_hw)
d2568 4
a2571 4
iwm_parse_nvm_data(struct iwm_softc *sc,
	const uint16_t *nvm_hw, const uint16_t *nvm_sw,
	const uint16_t *nvm_calib, const uint16_t *mac_override,
	const uint16_t *phy_sku, const uint16_t *regulatory)
d2734 1
a2734 1
	const uint8_t *section, uint32_t byte_cnt)
d2759 1
a2759 1
	const uint8_t *chunk, uint32_t byte_cnt)
d3203 1
a3203 2
iwm_get_signal_strength(struct iwm_softc *sc,
	struct iwm_rx_phy_info *phy_info)
d3225 2
a3226 2
iwm_rx_rx_phy_cmd(struct iwm_softc *sc,
	struct iwm_rx_packet *pkt, struct iwm_rx_data *data)
d3258 2
a3259 2
iwm_rx_rx_mpdu(struct iwm_softc *sc,
	struct iwm_rx_packet *pkt, struct iwm_rx_data *data)
d3379 1
a3379 1
	struct iwm_node *in)
d3403 2
a3404 2
iwm_rx_tx_cmd(struct iwm_softc *sc,
	struct iwm_rx_packet *pkt, struct iwm_rx_data *data)
d3485 1
a3485 1
	struct iwm_phy_context_cmd *cmd, uint32_t action, uint32_t apply_time)
d3496 3
a3498 3
iwm_phy_ctxt_cmd_data(struct iwm_softc *sc,
	struct iwm_phy_context_cmd *cmd, struct ieee80211_channel *chan,
	uint8_t chains_static, uint8_t chains_dynamic)
d3524 3
a3526 4
iwm_phy_ctxt_cmd(struct iwm_softc *sc,
	struct iwm_phy_ctxt *ctxt,
	uint8_t chains_static, uint8_t chains_dynamic,
	uint32_t action, uint32_t apply_time)
d3708 2
a3709 2
iwm_send_cmd_pdu(struct iwm_softc *sc, uint8_t id,
	uint32_t flags, uint16_t len, const void *data)
d3722 2
a3723 2
iwm_send_cmd_status(struct iwm_softc *sc,
	struct iwm_host_cmd *cmd, uint32_t *status)
d3762 2
a3763 2
iwm_send_cmd_pdu_status(struct iwm_softc *sc, uint8_t id,
	uint16_t len, const void *data, uint32_t *status)
d3811 1
a3811 1
	uint16_t len)
d3848 1
a3848 1
	struct ieee80211_frame *wh, struct iwm_tx_cmd *tx)
d4185 1
a4185 1
	struct iwm_beacon_filter_cmd *cmd)
d4192 2
a4193 2
iwm_beacon_filter_set_cqm_params(struct iwm_softc *sc,
	struct iwm_node *in, struct iwm_beacon_filter_cmd *cmd)
d4199 1
a4199 2
iwm_update_beacon_abort(struct iwm_softc *sc, struct iwm_node *in,
	int enable)
d4217 1
a4217 1
	struct iwm_mac_power_cmd *cmd)
d4389 1
a4389 1
	const uint8_t *addr, uint16_t mac_id, uint16_t color)
d4529 1
a4529 1
	struct iwm_scan_channel_cfg_lmac *chan, int n_ssids)
d4559 1
a4559 1
	struct iwm_scan_channel_cfg_umac *chan, int n_ssids)
d4942 2
a4943 2
iwm_ack_rates(struct iwm_softc *sc, struct iwm_node *in,
	int *cck_rates, int *ofdm_rates)
d5025 1
a5025 1
	struct iwm_mac_ctx_cmd *cmd, uint32_t action)
d5095 1
a5095 1
	struct iwm_mac_data_sta *ctxt_sta, int force_assoc_off)
@


1.129
log
@iwm(4) inherited the 'MVM' prefix in many of its symbol names from iwlwifi.
Linux iwlwifi implements support for iwn(4) chips in the 'DVM' driver,
and support for iwm(4) chips in the 'MVM' driver.

In OpenBSD the 'MVM' prefix is redundant, so we can remove it to shorten
many lines and reduce noise: s/iwm_mvm_/iwm_/g
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.128 2016/09/10 09:13:09 stsp Exp $	*/
d2172 1
a2172 1
const int nvm_to_read[] = {
d2704 2
a2705 2
	for (i = 0; i < nitems(nvm_to_read); i++) {
		section = nvm_to_read[i];
@


1.128
log
@Fix formatting in iwm such that

  break; }

becomes:

  break;
}
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.127 2016/09/10 09:12:11 stsp Exp $	*/
d269 1
a269 1
void	iwm_mvm_nic_config(struct iwm_softc *);
d289 1
a289 1
void	iwm_mvm_te_v2_to_v1(const struct iwm_time_event_cmd_v2 *,
d291 1
a291 1
int	iwm_mvm_send_time_event_cmd(struct iwm_softc *,
d293 1
a293 1
void	iwm_mvm_protect_session(struct iwm_softc *, struct iwm_node *,
d308 1
a308 1
void	iwm_mvm_sta_rx_agg(struct iwm_softc *, struct ieee80211_node *,
d338 1
a338 1
int	iwm_mvm_load_ucode_wait_alive(struct iwm_softc *, enum iwm_ucode_type);
d341 2
a342 2
int	iwm_mvm_calc_rssi(struct iwm_softc *, struct iwm_rx_phy_info *);
int	iwm_mvm_get_signal_strength(struct iwm_softc *,
d344 1
a344 1
void	iwm_mvm_rx_rx_phy_cmd(struct iwm_softc *, struct iwm_rx_packet *,
d346 2
a347 2
int	iwm_get_noise(const struct iwm_mvm_statistics_rx_non_phy *);
void	iwm_mvm_rx_rx_mpdu(struct iwm_softc *, struct iwm_rx_packet *,
d349 1
a349 1
void	iwm_mvm_rx_tx_cmd_single(struct iwm_softc *, struct iwm_rx_packet *,
d351 1
a351 1
void	iwm_mvm_rx_tx_cmd(struct iwm_softc *, struct iwm_rx_packet *,
d353 2
a354 2
int	iwm_mvm_binding_cmd(struct iwm_softc *, struct iwm_node *, uint32_t);
void	iwm_mvm_phy_ctxt_cmd_hdr(struct iwm_softc *, struct iwm_mvm_phy_ctxt *,
d356 1
a356 1
void	iwm_mvm_phy_ctxt_cmd_data(struct iwm_softc *,
d359 1
a359 1
int	iwm_mvm_phy_ctxt_cmd(struct iwm_softc *, struct iwm_mvm_phy_ctxt *,
d362 1
a362 1
int	iwm_mvm_send_cmd_pdu(struct iwm_softc *, uint8_t, uint32_t, uint16_t,
d364 1
a364 1
int	iwm_mvm_send_cmd_status(struct iwm_softc *, struct iwm_host_cmd *,
d366 1
a366 1
int	iwm_mvm_send_cmd_pdu_status(struct iwm_softc *, uint8_t,
d374 3
a376 3
void	iwm_mvm_led_enable(struct iwm_softc *);
void	iwm_mvm_led_disable(struct iwm_softc *);
int	iwm_mvm_led_is_enabled(struct iwm_softc *);
d380 1
a380 1
int	iwm_mvm_beacon_filter_send_cmd(struct iwm_softc *,
d382 1
a382 1
void	iwm_mvm_beacon_filter_set_cqm_params(struct iwm_softc *,
d384 2
a385 2
int	iwm_mvm_update_beacon_abort(struct iwm_softc *, struct iwm_node *, int);
void	iwm_mvm_power_build_cmd(struct iwm_softc *, struct iwm_node *,
d387 6
a392 6
int	iwm_mvm_power_mac_update_mode(struct iwm_softc *, struct iwm_node *);
int	iwm_mvm_power_update_device(struct iwm_softc *);
int	iwm_mvm_enable_beacon_filter(struct iwm_softc *, struct iwm_node *);
int	iwm_mvm_disable_beacon_filter(struct iwm_softc *);
int	iwm_mvm_add_sta_cmd(struct iwm_softc *, struct iwm_node *, int);
int	iwm_mvm_add_int_sta_common(struct iwm_softc *, struct iwm_int_sta *,
d394 8
a401 8
int	iwm_mvm_add_aux_sta(struct iwm_softc *);
uint16_t iwm_mvm_scan_rx_chain(struct iwm_softc *);
uint32_t iwm_mvm_scan_max_out_time(struct iwm_softc *, uint32_t, int);
uint32_t iwm_mvm_scan_suspend_time(struct iwm_softc *, int);
uint32_t iwm_mvm_scan_rate_n_flags(struct iwm_softc *, int, int);
uint16_t iwm_mvm_get_active_dwell(struct iwm_softc *, int, int);
uint16_t iwm_mvm_get_passive_dwell(struct iwm_softc *, int);
uint8_t	iwm_mvm_lmac_scan_fill_channels(struct iwm_softc *,
d403 6
a408 6
int	iwm_mvm_fill_probe_req(struct iwm_softc *, struct iwm_scan_probe_req *);
int	iwm_mvm_lmac_scan(struct iwm_softc *);
int	iwm_mvm_config_umac_scan(struct iwm_softc *);
int	iwm_mvm_umac_scan(struct iwm_softc *);
void	iwm_mvm_ack_rates(struct iwm_softc *, struct iwm_node *, int *, int *);
void	iwm_mvm_mac_ctxt_cmd_common(struct iwm_softc *, struct iwm_node *,
d410 1
a410 1
void	iwm_mvm_mac_ctxt_cmd_fill_sta(struct iwm_softc *, struct iwm_node *,
d412 2
a413 2
int	iwm_mvm_mac_ctxt_cmd(struct iwm_softc *, struct iwm_node *, uint32_t);
int	iwm_mvm_update_quotas(struct iwm_softc *, struct iwm_node *);
d423 1
a423 1
void	iwm_mvm_fill_sf_command(struct iwm_softc *, struct iwm_sf_cfg_cmd *,
d425 1
a425 1
int	iwm_mvm_sf_config(struct iwm_softc *, int);
d428 1
a428 1
void	iwm_mvm_tt_tx_backoff(struct iwm_softc *, uint32_t);
d1118 1
a1118 1
	if (qid > IWM_MVM_CMD_QUEUE)
d1140 1
a1140 1
		if (qid == IWM_MVM_CMD_QUEUE)
d1565 1
a1565 1
iwm_mvm_nic_config(struct iwm_softc *sc)
d1689 1
a1689 1
	iwm_mvm_nic_config(sc);
d1704 5
a1708 5
const uint8_t iwm_mvm_ac_to_tx_fifo[] = {
	IWM_MVM_TX_FIFO_VO,
	IWM_MVM_TX_FIFO_VI,
	IWM_MVM_TX_FIFO_BE,
	IWM_MVM_TX_FIFO_BK,
d1719 1
a1719 1
	if (qid == IWM_MVM_CMD_QUEUE) {
d1760 1
a1760 1
		err = iwm_mvm_send_cmd_pdu(sc, IWM_SCD_QUEUE_CFG, 0,
d1809 1
a1809 1
	err = iwm_enable_txq(sc, 0 /* unused */, IWM_MVM_CMD_QUEUE, 7);
d2073 2
a2074 2
#define IWM_MVM_ROC_TE_TYPE_NORMAL IWM_TE_P2P_DEVICE_DISCOVERABLE
#define IWM_MVM_ROC_TE_TYPE_MGMT_TX IWM_TE_P2P_CLIENT_ASSOC
d2099 1
a2099 1
iwm_mvm_te_v2_to_v1(const struct iwm_time_event_cmd_v2 *cmd_v2,
d2123 1
a2123 1
iwm_mvm_send_time_event_cmd(struct iwm_softc *sc,
d2129 1
a2129 1
		return iwm_mvm_send_cmd_pdu(sc, IWM_TIME_EVENT_CMD,
d2132 2
a2133 2
	iwm_mvm_te_v2_to_v1(cmd, &cmd_v1);
	return iwm_mvm_send_cmd_pdu(sc, IWM_TIME_EVENT_CMD, 0,
d2138 1
a2138 1
iwm_mvm_protect_session(struct iwm_softc *sc, struct iwm_node *in,
d2163 1
a2163 1
	iwm_mvm_send_time_event_cmd(sc, &time_cmd);
d2383 1
a2383 1
iwm_mvm_sta_rx_agg(struct iwm_softc *sc, struct ieee80211_node *ni,
d2386 1
a2386 1
	struct iwm_mvm_add_sta_cmd_v7 cmd;
d2411 1
a2411 1
	err = iwm_mvm_send_cmd_pdu_status(sc, IWM_ADD_STA,
d2443 1
a2443 1
	err = iwm_mvm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY);
d2470 1
a2470 1
		iwm_mvm_sta_rx_agg(sc, ni, sc->ba_tid, sc->ba_ssn, 1);
d2472 1
a2472 1
		iwm_mvm_sta_rx_agg(sc, ni, sc->ba_tid, 0, 0);
d3016 1
a3016 1
	return iwm_mvm_send_cmd_pdu(sc, IWM_TX_ANT_CONFIGURATION_CMD,
d3032 1
a3032 1
	return iwm_mvm_send_cmd_pdu(sc, IWM_PHY_CONFIGURATION_CMD, 0,
d3037 1
a3037 1
iwm_mvm_load_ucode_wait_alive(struct iwm_softc *sc,
d3069 1
a3069 1
	err = iwm_mvm_load_ucode_wait_alive(sc, IWM_UCODE_TYPE_INIT);
d3093 1
a3093 1
	err = iwm_mvm_sf_config(sc, IWM_SF_INIT_OFF);
d3174 1
a3174 1
iwm_mvm_calc_rssi(struct iwm_softc *sc, struct iwm_rx_phy_info *phy_info)
d3205 1
a3205 1
iwm_mvm_get_signal_strength(struct iwm_softc *sc,
d3228 1
a3228 1
iwm_mvm_rx_rx_phy_cmd(struct iwm_softc *sc,
d3243 1
a3243 1
iwm_get_noise(const struct iwm_mvm_statistics_rx_non_phy *stats)
d3261 1
a3261 1
iwm_mvm_rx_rx_mpdu(struct iwm_softc *sc,
d3301 1
a3301 1
		rssi = iwm_mvm_get_signal_strength(sc, phy_info);
d3303 1
a3303 1
		rssi = iwm_mvm_calc_rssi(sc, phy_info);
d3381 1
a3381 1
iwm_mvm_rx_tx_cmd_single(struct iwm_softc *sc, struct iwm_rx_packet *pkt,
d3386 1
a3386 1
	struct iwm_mvm_tx_resp *tx_resp = (void *)pkt->data;
d3406 1
a3406 1
iwm_mvm_rx_tx_cmd(struct iwm_softc *sc,
d3426 1
a3426 1
	iwm_mvm_rx_tx_cmd_single(sc, pkt, in);
d3456 1
a3456 1
iwm_mvm_binding_cmd(struct iwm_softc *sc, struct iwm_node *in, uint32_t action)
d3459 1
a3459 1
	struct iwm_mvm_phy_ctxt *phyctxt = in->in_phyctxt;
d3475 1
a3475 1
	err = iwm_mvm_send_cmd_pdu_status(sc, IWM_BINDING_CONTEXT_CMD,
d3487 1
a3487 1
iwm_mvm_phy_ctxt_cmd_hdr(struct iwm_softc *sc, struct iwm_mvm_phy_ctxt *ctxt,
d3499 1
a3499 1
iwm_mvm_phy_ctxt_cmd_data(struct iwm_softc *sc,
d3527 2
a3528 2
iwm_mvm_phy_ctxt_cmd(struct iwm_softc *sc,
	struct iwm_mvm_phy_ctxt *ctxt,
d3534 1
a3534 1
	iwm_mvm_phy_ctxt_cmd_hdr(sc, ctxt, &cmd, action, apply_time);
d3536 1
a3536 1
	iwm_mvm_phy_ctxt_cmd_data(sc, &cmd, ctxt->channel,
d3539 1
a3539 1
	return iwm_mvm_send_cmd_pdu(sc, IWM_PHY_CONTEXT_CMD, 0,
d3546 1
a3546 1
	struct iwm_tx_ring *ring = &sc->txq[IWM_MVM_CMD_QUEUE];
d3712 1
a3712 1
iwm_mvm_send_cmd_pdu(struct iwm_softc *sc, uint8_t id,
d3726 1
a3726 1
iwm_mvm_send_cmd_status(struct iwm_softc *sc,
d3766 1
a3766 1
iwm_mvm_send_cmd_pdu_status(struct iwm_softc *sc, uint8_t id,
d3775 1
a3775 1
	return iwm_mvm_send_cmd_status(sc, &cmd, status);
d3790 1
a3790 1
	struct iwm_tx_ring *ring = &sc->txq[IWM_MVM_CMD_QUEUE];
d3793 1
a3793 1
	if (pkt->hdr.qid != IWM_MVM_CMD_QUEUE) {
d4124 1
a4124 1
iwm_mvm_flush_tx_path(struct iwm_softc *sc, int tfd_msk, int sync)
d4132 1
a4132 1
	err = iwm_mvm_send_cmd_pdu(sc, IWM_TXPATH_FLUSH,
d4142 1
a4142 1
iwm_mvm_led_enable(struct iwm_softc *sc)
d4148 1
a4148 1
iwm_mvm_led_disable(struct iwm_softc *sc)
d4154 1
a4154 1
iwm_mvm_led_is_enabled(struct iwm_softc *sc)
d4164 2
a4165 2
	if (iwm_mvm_led_is_enabled(sc))
		iwm_mvm_led_disable(sc);
d4167 1
a4167 1
		iwm_mvm_led_enable(sc);
d4182 1
a4182 1
	iwm_mvm_led_disable(sc);
d4188 1
a4188 1
iwm_mvm_beacon_filter_send_cmd(struct iwm_softc *sc,
d4191 1
a4191 1
	return iwm_mvm_send_cmd_pdu(sc, IWM_REPLY_BEACON_FILTERING_CMD,
d4196 1
a4196 1
iwm_mvm_beacon_filter_set_cqm_params(struct iwm_softc *sc,
d4203 1
a4203 1
iwm_mvm_update_beacon_abort(struct iwm_softc *sc, struct iwm_node *in,
d4216 2
a4217 2
	iwm_mvm_beacon_filter_set_cqm_params(sc, in, &cmd);
	return iwm_mvm_beacon_filter_send_cmd(sc, &cmd);
d4221 1
a4221 1
iwm_mvm_power_build_cmd(struct iwm_softc *sc, struct iwm_node *in,
d4247 1
a4247 1
iwm_mvm_power_mac_update_mode(struct iwm_softc *sc, struct iwm_node *in)
d4255 1
a4255 1
	iwm_mvm_power_build_cmd(sc, in, &cmd);
d4257 1
a4257 1
	err = iwm_mvm_send_cmd_pdu(sc, IWM_MAC_PM_POWER_TABLE, 0,
d4264 1
a4264 1
	return iwm_mvm_update_beacon_abort(sc, in, ba_enable);
d4268 1
a4268 1
iwm_mvm_power_update_device(struct iwm_softc *sc)
d4279 1
a4279 1
	return iwm_mvm_send_cmd_pdu(sc,
d4284 1
a4284 1
iwm_mvm_enable_beacon_filter(struct iwm_softc *sc, struct iwm_node *in)
d4292 2
a4293 2
	iwm_mvm_beacon_filter_set_cqm_params(sc, in, &cmd);
	err = iwm_mvm_beacon_filter_send_cmd(sc, &cmd);
d4302 1
a4302 1
iwm_mvm_disable_beacon_filter(struct iwm_softc *sc)
d4311 1
a4311 1
	err = iwm_mvm_beacon_filter_send_cmd(sc, &cmd);
d4319 1
a4319 1
iwm_mvm_add_sta_cmd(struct iwm_softc *sc, struct iwm_node *in, int update)
d4321 1
a4321 1
	struct iwm_mvm_add_sta_cmd_v7 add_sta_cmd;
d4335 1
a4335 1
			    htole32(1 << iwm_mvm_ac_to_tx_fifo[ac]);
d4376 1
a4376 1
	err = iwm_mvm_send_cmd_pdu_status(sc, IWM_ADD_STA, sizeof(add_sta_cmd),
d4393 1
a4393 1
iwm_mvm_add_int_sta_common(struct iwm_softc *sc, struct iwm_int_sta *sta,
d4396 1
a4396 1
	struct iwm_mvm_add_sta_cmd_v7 cmd;
d4410 1
a4410 1
	err = iwm_mvm_send_cmd_pdu_status(sc, IWM_ADD_STA,
d4426 1
a4426 1
iwm_mvm_add_aux_sta(struct iwm_softc *sc)
d4431 1
a4431 1
	sc->sc_aux_sta.tfd_queue_msk = (1 << IWM_MVM_AUX_QUEUE);
d4433 1
a4433 1
	err = iwm_enable_txq(sc, 0, IWM_MVM_AUX_QUEUE, IWM_MVM_TX_FIFO_MCAST);
d4437 1
a4437 1
	err = iwm_mvm_add_int_sta_common(sc,
d4452 1
a4452 1
iwm_mvm_scan_rx_chain(struct iwm_softc *sc)
d4468 1
a4468 1
iwm_mvm_scan_max_out_time(struct iwm_softc *sc, uint32_t flags, int is_assoc)
d4478 1
a4478 1
iwm_mvm_scan_suspend_time(struct iwm_softc *sc, int is_assoc)
d4486 1
a4486 1
iwm_mvm_scan_rate_n_flags(struct iwm_softc *sc, int flags, int no_cck)
d4519 1
a4519 1
iwm_mvm_get_active_dwell(struct iwm_softc *sc, int flags, int n_ssids)
d4527 1
a4527 1
iwm_mvm_get_passive_dwell(struct iwm_softc *sc, int flags)
d4533 1
a4533 1
iwm_mvm_lmac_scan_fill_channels(struct iwm_softc *sc,
d4563 1
a4563 1
iwm_mvm_umac_scan_fill_channels(struct iwm_softc *sc,
d4592 1
a4592 1
iwm_mvm_fill_probe_req(struct iwm_softc *sc, struct iwm_scan_probe_req *preq)
d4685 1
a4685 1
iwm_mvm_lmac_scan(struct iwm_softc *sc)
d4719 1
a4719 1
	req->rx_chain_select = iwm_mvm_scan_rx_chain(sc);
d4723 3
a4725 3
	req->scan_flags = htole32(IWM_MVM_LMAC_SCAN_FLAG_PASS_ALL |
	    IWM_MVM_LMAC_SCAN_FLAG_ITER_COMPLETE |
	    IWM_MVM_LMAC_SCAN_FLAG_EXTENDED_DWELL);
d4727 1
a4727 1
		req->scan_flags |= htole32(IWM_MVM_LMAC_SCAN_FLAG_PASSIVE);
d4730 1
a4730 1
		    htole32(IWM_MVM_LMAC_SCAN_FLAG_PRE_CONNECTION);
d4733 1
a4733 1
		req->scan_flags |= htole32(IWM_MVM_LMAC_SCAN_FLAGS_RRM_ENABLED);
d4745 1
a4745 1
	    iwm_mvm_scan_rate_n_flags(sc, IEEE80211_CHAN_2GHZ, 1/*XXX*/);
d4752 1
a4752 1
	    iwm_mvm_scan_rate_n_flags(sc, IEEE80211_CHAN_5GHZ, 1/*XXX*/);
d4763 1
a4763 1
	req->n_channels = iwm_mvm_lmac_scan_fill_channels(sc,
d4767 1
a4767 1
	err = iwm_mvm_fill_probe_req(sc,
d4790 1
a4790 1
iwm_mvm_config_umac_scan(struct iwm_softc *sc)
d4865 1
a4865 1
iwm_mvm_umac_scan(struct iwm_softc *sc)
d4903 1
a4903 1
	req->n_channels = iwm_mvm_umac_scan_fill_channels(sc,
d4931 1
a4931 1
	err = iwm_mvm_fill_probe_req(sc, &tail->preq);
d4947 1
a4947 1
iwm_mvm_ack_rates(struct iwm_softc *sc, struct iwm_node *in,
d5029 1
a5029 1
iwm_mvm_mac_ctxt_cmd_common(struct iwm_softc *sc, struct iwm_node *in,
d5050 1
a5050 1
	iwm_mvm_ack_rates(sc, in, &cck_ack_rates, &ofdm_ack_rates);
d5099 1
a5099 1
iwm_mvm_mac_ctxt_cmd_fill_sta(struct iwm_softc *sc, struct iwm_node *in,
d5107 1
a5107 1
	ctxt_sta->bi_reciprocal = htole32(iwm_mvm_reciprocal(ni->ni_intval));
d5110 1
a5110 1
	    htole32(iwm_mvm_reciprocal(ni->ni_intval * ic->ic_dtim_period));
d5118 1
a5118 1
iwm_mvm_mac_ctxt_cmd(struct iwm_softc *sc, struct iwm_node *in, uint32_t action)
d5124 1
a5124 1
	iwm_mvm_mac_ctxt_cmd_common(sc, in, &cmd, action);
d5134 1
a5134 1
	iwm_mvm_mac_ctxt_cmd_fill_sta(sc, in,
d5137 1
a5137 1
	return iwm_mvm_send_cmd_pdu(sc, IWM_MAC_CONTEXT_CMD, 0, sizeof(cmd),
d5142 1
a5142 1
iwm_mvm_update_quotas(struct iwm_softc *sc, struct iwm_node *in)
d5164 1
a5164 1
	 * IWM_MVM_MAX_QUOTA fragments. Divide these fragments
d5176 2
a5177 2
		quota = IWM_MVM_MAX_QUOTA / num_active_macs;
		quota_rem = IWM_MVM_MAX_QUOTA % num_active_macs;
d5200 1
a5200 1
	return iwm_mvm_send_cmd_pdu(sc, IWM_TIME_QUOTA_CMD, 0,
d5214 1
a5214 1
	err = iwm_mvm_sf_config(sc, IWM_SF_FULL_ON);
d5223 1
a5223 1
	err = iwm_mvm_phy_ctxt_cmd(sc, &sc->sc_phyctxt[0], 1, 1,
d5229 1
a5229 1
	err = iwm_mvm_binding_cmd(sc, in, IWM_FW_CTXT_ACTION_ADD);
d5233 1
a5233 1
	err = iwm_mvm_add_sta_cmd(sc, in, 0);
d5237 1
a5237 1
	err = iwm_mvm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY);
d5248 2
a5249 2
	duration = IWM_MVM_TE_SESSION_PROTECTION_MAX_TIME_MS;
	iwm_mvm_protect_session(sc, in, duration, 500 /* XXX magic number */);
d5262 1
a5262 1
	err = iwm_mvm_add_sta_cmd(sc, in, 1);
d5268 1
a5268 1
	err = iwm_mvm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY);
d5472 1
a5472 1
		iwm_mvm_disable_beacon_filter(sc);
d5507 1
a5507 1
			err = iwm_mvm_umac_scan(sc);
d5509 1
a5509 1
			err = iwm_mvm_lmac_scan(sc);
d5534 1
a5534 1
		iwm_mvm_power_mac_update_mode(sc, in);
d5541 1
a5541 1
		iwm_mvm_enable_beacon_filter(sc, in);
d5543 1
a5543 1
		iwm_mvm_update_quotas(sc, in);
d5553 1
a5553 1
		iwm_mvm_led_enable(sc);
d5646 1
a5646 1
iwm_mvm_fill_sf_command(struct iwm_softc *sc, struct iwm_sf_cfg_cmd *sf_cmd,
d5694 1
a5694 1
iwm_mvm_sf_config(struct iwm_softc *sc, int new_state)
d5708 1
a5708 1
		iwm_mvm_fill_sf_command(sc, &sf_cmd, NULL);
d5711 1
a5711 1
		iwm_mvm_fill_sf_command(sc, &sf_cmd, ic->ic_bss);
d5717 1
a5717 1
	err = iwm_mvm_send_cmd_pdu(sc, IWM_REPLY_SF_CFG_CMD, IWM_CMD_ASYNC,
d5730 1
a5730 1
	return iwm_mvm_send_cmd_pdu(sc, IWM_BT_CONFIG, 0, sizeof(bt_cmd),
d5770 1
a5770 1
iwm_mvm_tt_tx_backoff(struct iwm_softc *sc, uint32_t backoff)
d5811 1
a5811 1
	err = iwm_mvm_load_ucode_wait_alive(sc, IWM_UCODE_TYPE_REGULAR);
d5846 1
a5846 1
	err = iwm_mvm_add_aux_sta(sc);
d5860 1
a5860 1
		err = iwm_mvm_phy_ctxt_cmd(sc, &sc->sc_phyctxt[i], 1, 1,
d5871 1
a5871 1
		iwm_mvm_tt_tx_backoff(sc, 0);
d5873 1
a5873 1
	err = iwm_mvm_power_update_device(sc);
d5890 1
a5890 1
		err = iwm_mvm_config_umac_scan(sc);
d5900 1
a5900 1
		    iwm_mvm_ac_to_tx_fifo[ac]);
d5908 1
a5908 1
	err = iwm_mvm_mac_ctxt_cmd(sc, in, IWM_FW_CTXT_ACTION_ADD);
d5915 1
a5915 1
	err = iwm_mvm_disable_beacon_filter(sc);
d5949 1
a5949 1
	err = iwm_mvm_send_cmd_pdu(sc, IWM_MCAST_FILTER_CMD,
d6466 1
a6466 1
			iwm_mvm_rx_rx_phy_cmd(sc, pkt, data);
d6470 1
a6470 1
			iwm_mvm_rx_rx_mpdu(sc, pkt, data);
d6474 1
a6474 1
			iwm_mvm_rx_tx_cmd(sc, pkt, data);
d6484 4
a6487 4
		case IWM_MVM_ALIVE: {
			struct iwm_mvm_alive_resp_v1 *resp1;
			struct iwm_mvm_alive_resp_v2 *resp2;
			struct iwm_mvm_alive_resp_v3 *resp3;
d6759 1
a6759 1
		for (i = 0; i < IWM_MVM_MAX_QUEUES; i++) {
@


1.127
log
@Rename iwm_mvm_sta_send_to_fw() to iwm_mvm_sta_cmd(). Get rid of pointless
wrapper functions iwm_mvm_add_sta() and iwm_mvm_update_sta().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.126 2016/09/10 07:38:24 stsp Exp $	*/
d5532 1
a5532 1
	case IEEE80211_S_RUN: {
d5554 1
a5554 1
		break; }
d6534 2
a6535 1
			break; }
a6539 1

d6541 2
a6542 2

			break; }
d6549 2
a6550 1
			break; }
d6615 2
a6616 2

			break; }
a6620 1

d6622 2
a6623 1
			break; }
a6627 1

a6642 1

d6646 2
a6647 1
			break; }
d6652 2
a6653 2

			break; }
@


1.126
log
@Move IWM_NVM_* macro definitions from if_iwm.c to if_iwmreg.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.125 2016/09/04 18:49:21 stsp Exp $	*/
d391 1
a391 3
int	iwm_mvm_sta_send_to_fw(struct iwm_softc *, struct iwm_node *, int);
int	iwm_mvm_add_sta(struct iwm_softc *, struct iwm_node *);
int	iwm_mvm_update_sta(struct iwm_softc *, struct iwm_node *);
d4319 1
a4319 1
iwm_mvm_sta_send_to_fw(struct iwm_softc *sc, struct iwm_node *in, int update)
a4392 12
iwm_mvm_add_sta(struct iwm_softc *sc, struct iwm_node *in)
{
	return iwm_mvm_sta_send_to_fw(sc, in, 0);
}

int
iwm_mvm_update_sta(struct iwm_softc *sc, struct iwm_node *in)
{
	return iwm_mvm_sta_send_to_fw(sc, in, 1);
}

int
d5233 1
a5233 1
	err = iwm_mvm_add_sta(sc, in);
d5262 1
a5262 1
	err = iwm_mvm_update_sta(sc, in);
@


1.125
log
@Replace iwm's ioctl tsleep/wakeup BUSY flag dance with an rwlock.
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.124 2016/09/04 17:01:59 stsp Exp $	*/
a2311 83

/* 7k family NVM HW-Section offset (in words) definitions */
#define IWM_HW_ADDR	0x15
/* 7k family NVM SW-Section offset (in words) definitions */
#define IWM_NVM_SW_SECTION	0x1C0
#define IWM_NVM_VERSION		0
#define IWM_RADIO_CFG		1
#define IWM_SKU			2
#define IWM_N_HW_ADDRS		3
#define IWM_NVM_CHANNELS	0x1E0 - IWM_NVM_SW_SECTION
/* 7k family NVM calibration section offset (in words) definitions */
#define IWM_NVM_CALIB_SECTION	0x2B8
#define IWM_XTAL_CALIB		(0x316 - IWM_NVM_CALIB_SECTION)

/* 8k family NVM HW-Section offset (in words) definitions */
#define IWM_HW_ADDR0_WFPM_8000		0x12
#define IWM_HW_ADDR1_WFPM_8000		0x16
#define IWM_HW_ADDR0_PCIE_8000		0x8A
#define IWM_HW_ADDR1_PCIE_8000		0x8E
#define IWM_MAC_ADDRESS_OVERRIDE_8000	1

/* 8k family NVM SW-Section offset (in words) definitions */
#define IWM_NVM_SW_SECTION_8000	0x1C0
#define IWM_NVM_VERSION_8000	0
#define IWM_RADIO_CFG_8000	0
#define IWM_SKU_8000		2
#define IWM_N_HW_ADDRS_8000	3

/* 8k family NVM REGULATORY -Section offset (in words) definitions */
#define IWM_NVM_CHANNELS_8000		0
#define IWM_NVM_LAR_OFFSET_8000_OLD	0x4C7
#define IWM_NVM_LAR_OFFSET_8000		0x507
#define IWM_NVM_LAR_ENABLED_8000	0x7

/* 8k family NVM calibration section offset (in words) definitions */
#define IWM_NVM_CALIB_SECTION_8000	0x2B8
#define IWM_XTAL_CALIB_8000		(0x316 - IWM_NVM_CALIB_SECTION_8000)

/* SKU Capabilities (actual values from NVM definition) */
#define IWM_NVM_SKU_CAP_BAND_24GHZ	(1 << 0)
#define IWM_NVM_SKU_CAP_BAND_52GHZ	(1 << 1)
#define IWM_NVM_SKU_CAP_11N_ENABLE	(1 << 2)
#define IWM_NVM_SKU_CAP_11AC_ENABLE	(1 << 3)
#define IWM_NVM_SKU_CAP_MIMO_DISABLE	(1 << 5)

/* radio config bits (actual values from NVM definition) */
#define IWM_NVM_RF_CFG_DASH_MSK(x)   (x & 0x3)         /* bits 0-1   */
#define IWM_NVM_RF_CFG_STEP_MSK(x)   ((x >> 2)  & 0x3) /* bits 2-3   */
#define IWM_NVM_RF_CFG_TYPE_MSK(x)   ((x >> 4)  & 0x3) /* bits 4-5   */
#define IWM_NVM_RF_CFG_PNUM_MSK(x)   ((x >> 6)  & 0x3) /* bits 6-7   */
#define IWM_NVM_RF_CFG_TX_ANT_MSK(x) ((x >> 8)  & 0xF) /* bits 8-11  */
#define IWM_NVM_RF_CFG_RX_ANT_MSK(x) ((x >> 12) & 0xF) /* bits 12-15 */

#define IWM_NVM_RF_CFG_PNUM_MSK_8000(x)		(x & 0xF)
#define IWM_NVM_RF_CFG_DASH_MSK_8000(x)		((x >> 4) & 0xF)
#define IWM_NVM_RF_CFG_STEP_MSK_8000(x)		((x >> 8) & 0xF)
#define IWM_NVM_RF_CFG_TYPE_MSK_8000(x)		((x >> 12) & 0xFFF)
#define IWM_NVM_RF_CFG_TX_ANT_MSK_8000(x)	((x >> 24) & 0xF)
#define IWM_NVM_RF_CFG_RX_ANT_MSK_8000(x)	((x >> 28) & 0xF)

#define DEFAULT_MAX_TX_POWER 16

/*
 * channel flags in NVM
 * @@IWM_NVM_CHANNEL_VALID: channel is usable for this SKU/geo
 * @@IWM_NVM_CHANNEL_IBSS: usable as an IBSS channel
 * @@IWM_NVM_CHANNEL_ACTIVE: active scanning allowed
 * @@IWM_NVM_CHANNEL_RADAR: radar detection required
 * @@IWM_NVM_CHANNEL_DFS: dynamic freq selection candidate
 * @@IWM_NVM_CHANNEL_WIDE: 20 MHz channel okay (?)
 * @@IWM_NVM_CHANNEL_40MHZ: 40 MHz channel okay (?)
 * @@IWM_NVM_CHANNEL_80MHZ: 80 MHz channel okay (?)
 * @@IWM_NVM_CHANNEL_160MHZ: 160 MHz channel okay (?)
 */
#define IWM_NVM_CHANNEL_VALID	(1 << 0)
#define IWM_NVM_CHANNEL_IBSS	(1 << 1)
#define IWM_NVM_CHANNEL_ACTIVE	(1 << 3)
#define IWM_NVM_CHANNEL_RADAR	(1 << 4)
#define IWM_NVM_CHANNEL_DFS	(1 << 7)
#define IWM_NVM_CHANNEL_WIDE	(1 << 8)
#define IWM_NVM_CHANNEL_40MHZ	(1 << 9)
#define IWM_NVM_CHANNEL_80MHZ	(1 << 10)
#define IWM_NVM_CHANNEL_160MHZ	(1 << 11)
@


1.124
log
@Even more enums which should be #defines were hiding inside if_iwm.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.123 2016/09/04 16:52:43 stsp Exp $	*/
d117 1
a6207 1
	s = splnet();
d6213 2
a6214 4
	while ((sc->sc_flags & IWM_FLAG_BUSY) && err == 0)
		err = tsleep(&sc->sc_flags, PCATCH, "iwmioc", 0);
	if (err) {
		splx(s);
d6216 2
a6217 2
	}
	sc->sc_flags |= IWM_FLAG_BUSY;
a6258 2
	sc->sc_flags &= ~IWM_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d6260 2
d7042 1
d7361 1
a7362 3
	while (sc->sc_flags & IWM_FLAG_BUSY)
		tsleep(&sc->sc_flags, 0, "iwmpwr", 0);
	sc->sc_flags |= IWM_FLAG_BUSY;
a7367 2
	sc->sc_flags &= ~IWM_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d7369 1
@


1.123
log
@Remove unused IWM_READ_NVM_CHUNK_... macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.122 2016/09/04 16:46:54 stsp Exp $	*/
d2312 36
a2347 43
/* NVM offsets (in words) definitions */
enum iwm_nvm_offsets {
	/* NVM HW-Section offset (in words) definitions */
	IWM_HW_ADDR = 0x15,

	/* NVM SW-Section offset (in words) definitions */
	IWM_NVM_SW_SECTION = 0x1C0,
	IWM_NVM_VERSION = 0,
	IWM_RADIO_CFG = 1,
	IWM_SKU = 2,
	IWM_N_HW_ADDRS = 3,
	IWM_NVM_CHANNELS = 0x1E0 - IWM_NVM_SW_SECTION,

	/* NVM calibration section offset (in words) definitions */
	IWM_NVM_CALIB_SECTION = 0x2B8,
	IWM_XTAL_CALIB = 0x316 - IWM_NVM_CALIB_SECTION
};

enum iwm_8000_nvm_offsets {
	/* NVM HW-Section offset (in words) definitions */
	IWM_HW_ADDR0_WFPM_8000 = 0x12,
	IWM_HW_ADDR1_WFPM_8000 = 0x16,
	IWM_HW_ADDR0_PCIE_8000 = 0x8A,
	IWM_HW_ADDR1_PCIE_8000 = 0x8E,
	IWM_MAC_ADDRESS_OVERRIDE_8000 = 1,

	/* NVM SW-Section offset (in words) definitions */
	IWM_NVM_SW_SECTION_8000 = 0x1C0,
	IWM_NVM_VERSION_8000 = 0,
	IWM_RADIO_CFG_8000 = 0,
	IWM_SKU_8000 = 2,
	IWM_N_HW_ADDRS_8000 = 3,

	/* NVM REGULATORY -Section offset (in words) definitions */
	IWM_NVM_CHANNELS_8000 = 0,
	IWM_NVM_LAR_OFFSET_8000_OLD = 0x4C7,
	IWM_NVM_LAR_OFFSET_8000 = 0x507,
	IWM_NVM_LAR_ENABLED_8000 = 0x7,

	/* NVM calibration section offset (in words) definitions */
	IWM_NVM_CALIB_SECTION_8000 = 0x2B8,
	IWM_XTAL_CALIB_8000 = 0x316 - IWM_NVM_CALIB_SECTION_8000
};
d2350 5
a2354 7
enum nvm_sku_bits {
	IWM_NVM_SKU_CAP_BAND_24GHZ	= (1 << 0),
	IWM_NVM_SKU_CAP_BAND_52GHZ	= (1 << 1),
	IWM_NVM_SKU_CAP_11N_ENABLE	= (1 << 2),
	IWM_NVM_SKU_CAP_11AC_ENABLE	= (1 << 3),
	IWM_NVM_SKU_CAP_MIMO_DISABLE	= (1 << 5),
};
d2373 2
a2374 2
/**
 * enum iwm_nvm_channel_flags - channel flags in NVM
d2385 9
a2393 11
enum iwm_nvm_channel_flags {
	IWM_NVM_CHANNEL_VALID = (1 << 0),
	IWM_NVM_CHANNEL_IBSS = (1 << 1),
	IWM_NVM_CHANNEL_ACTIVE = (1 << 3),
	IWM_NVM_CHANNEL_RADAR = (1 << 4),
	IWM_NVM_CHANNEL_DFS = (1 << 7),
	IWM_NVM_CHANNEL_WIDE = (1 << 8),
	IWM_NVM_CHANNEL_40MHZ = (1 << 9),
	IWM_NVM_CHANNEL_80MHZ = (1 << 10),
	IWM_NVM_CHANNEL_160MHZ = (1 << 11),
};
@


1.122
log
@Purge a ton of "-1 not informative" rated comments from iwm and improve
some of the more useful ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.121 2016/09/04 15:45:46 stsp Exp $	*/
a2188 4

/* load nvm chunk response */
#define IWM_READ_NVM_CHUNK_SUCCEED		0
#define IWM_READ_NVM_CHUNK_INVALID_ADDRESS	1
@


1.121
log
@Remove disabled iwm debug code which prints the regdomain.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.120 2016/09/04 11:07:04 stsp Exp $	*/
a454 4
/*
 * Firmware parser.
 */

a553 4
	/*
	 * Load firmware into driver memory.
	 * fw_rawdata and fw_rawsize will be set.
	 */
a561 1
	/* (Re-)Initialize default values. */
a566 4
	/*
	 * Parse firmware contents
	 */

a609 1
			/* limit it to something sensible */
a797 4
/*
 * basic device access
 */

a891 1
		/* jolt */
a932 4
/*
 * DMA resource routines
 */

a1018 3
	/*
	 * Allocate and map RX buffers.
	 */
a1209 4
/*
 * High-level hardware frobbing routines
 */

a1262 1
	/* disable interrupts */
a1276 1
	/* Reset ICT. */
a1289 1
	/* Re-enable interrupts. */
d1359 1
a1359 1
 * (e.g. after platform boot, or shutdown via iwm_pcie_apm_stop())
d1367 1
a1367 1
	/* Disable L0S exit timer (platform NMI Work/Around) */
a1507 1
	/* tell the device to stop sending interrupts */
d1511 1
a1511 1
	/* stop tx and rx.  tx and rx bits, as usual, are from if_iwn */
a1532 1
	/* Stop RX ring. */
a1534 1
	/* Reset all TX rings. */
d1551 3
a1553 2
	/* Upon stop, the APM issues an interrupt if HW RF kill is set.
	 * Clean again the interrupt here
d1556 2
a1557 1
	/* stop and reset the on-board processor */
d1560 1
a1560 4
	/*
	 * Even if we stop the HW, we still want the RF kill
	 * interrupt
	 */
a1577 1
	/* SKU control */
a1606 3
	/*
	 * Initialize RX ring.  This is from the iwn driver.
	 */
a1608 1
	/* stop DMA */
d1640 2
a1641 4
	 * Thus sayeth el jefe (iwlwifi) via a comment:
	 *
	 * This value should initially be 0 (before preparing any
 	 * RBs), should be 8 after preparing the first 8 RBs (for example)
a1663 1
	/* Initialize TX rings. */
a1695 3
	/*
	 * Ditto for TX, from iwn
	 */
a1720 1
		/* unactivate before configuration */
d1817 1
a1839 4
/*
 * get phy db section: returns a pointer to a phy db section specified by
 * type and channel group id.
 */
d1955 2
a1956 2
		 * Looking for the first channel group that its max channel is
		 * higher then wanted channel.
a1970 1
	/* find wanted channel group */
a1995 1
	/* Set phy db cmd variables */
a1998 1
	/* Set hcmd variables */
a2014 1
	/* Send all the channel-specific groups to operational fw */
a2022 1
		/* Send the requested PHY DB section */
a2039 1
	/* Send PHY DB CFG section */
a2056 1
	/* Send all the TXP channel specific data */
a2061 1
	/* Send all the TXP channel specific data */
a2183 1
/* Default NVM size to read */
a2263 3
 * For 7000 family NICs, we supply the maximal size we can read, and
 * the uCode fills the response with as much data as we can,
 * without overflowing, so no check is needed.
d2321 1
a2321 1
/* NVM SW-Section offset (in words) definitions */
d2329 1
a2329 1
/* NVM calibration section offset (in words) definitions */
a2520 1
			/* check that restart flow didn't zero counter */
d2645 1
a2645 1
		/* read the mac address from WFMP registers */
a2832 5
/*
 * Firmware loading gunk.  This is kind of a weird hybrid between the
 * iwn driver and the Linux iwlwifi driver.
 */

d2900 1
a2900 1
	/* wait 1s for this segment to load */
a3104 1
	/* Load the given image to the HW */
a3124 1
	/* Set parameters */
a3155 4
/*
 * mvm misc bits
 */

a3160 1
	/* do not operate with rfkill switch turned on */
a3191 1
	/* Init Smart FIFO. */
a3221 5
/*
 * receive side
 */

/* (re)stock rx ring, called at init-time and at runtime */
d3299 1
a3299 2
 * iwm_mvm_get_signal_strength - use new rx PHY INFO API
 * values are reported by the fw as positive values - need to negate
a3358 5
/*
 * iwm_mvm_rx_rx_mpdu - IWM_REPLY_RX_MPDU_CMD handler
 *
 * Handles the actual data of the Rx packet from the fw
 */
a3406 1
	/* replenish ring for the buffer we're going to feed to the sharks */
a3526 1
	/* Unmap and free mbuf. */
a3584 3
/*
 * Construct the generic fields of the PHY context command
 */
a3596 3
/*
 * Add the phy configuration to the PHY context command
 */
a3632 1
	/* Set the command header fields */
a3634 1
	/* Set the command data */
a3641 11
/*
 * transmit side
 */

/*
 * Send a command to the firmware.  We try to implement the Linux
 * driver interface for the routine.
 * mostly from if_iwn (iwn_cmd()).
 *
 * For now, we always copy the first part and map the second one (if it exists).
 */
a3789 1
		/* m..m-mmyy-mmyyyy-mym-ym m-my generation */
a3885 5
/*
 * Process a "command done" firmware notification.  This is where we wakeup
 * processes waiting for a synchronous command completion.
 * from if_iwn
 */
a3897 1
	/* If the command was mapped in an mbuf, free it. */
a4042 1
	/* Fill out iwm_tx_cmd to send to the firmware */
a4081 1
	/* Encrypt the frame if need be. */
a4082 1
		/* Retrieve key for TX && do software encryption. */
a4239 1
/* Set led register on */
a4245 1
/* Set led register off */
d4336 1
a4336 1
	 * is at least 3 * DTIM
a4416 1
/* send station add/update command to firmware */
a4713 1
	/* Ensure enough space for header and SSID IE. */
a5208 3
/*
 * Fill the specific data for mac context of type station or p2p client
 */
a5234 1
	/* Fill the common data for all mac context types */
a5314 8
/*
 * aieee80211 routines
 */

/*
 * Change to AUTH state in 80211 state machine.  Roughly matches what
 * Linux does in bss_info_changed().
 */
a5581 1
	/* disable beacon filtering if we're hopping out of RUN */
a5655 1
		/* init amrr */
d5913 1
a5913 4
	/*
	 * should stop and start HW since that INIT
	 * image just loaded
	 */
a5941 1
	/* Send phy db control command and then phy db calibration*/
a6008 1
	/* Enable Tx queues. */
a6018 1
	/* Add the MAC context. */
a6065 4
/*
 * ifnet interfaces
 */

a6083 4
	/*
 	 * Ok, firmware loaded and we are jogging
	 */

a6092 4
/*
 * Dequeue packets from sendq and call send.
 * mostly from iwn
 */
a6281 4
/*
 * The interrupt side of things
 */

a6543 4
/*
 * Process an IWM_CSR_INT_BIT_FH_RX or IWM_CSR_INT_BIT_SW_RX interrupt.
 * Basic structure from if_iwn
 */
d6788 5
a6792 12
		 * Why test bit 0x80?  The Linux driver:
		 *
		 * There is one exception:  uCode sets bit 15 when it
		 * originates the response/notification, i.e. when the
		 * response/notification is not a direct response to a
		 * command sent by the driver.  For example, uCode issues
		 * IWM_REPLY_RX when it sends a received frame to the driver;
		 * it is not a direct response to any driver command.
		 *
		 * Ok, so since when is 7 == 15?  Well, the Linux driver
		 * uses a slightly different format for pkt->hdr, and "qid"
		 * is actually the upper byte of a two-byte field.
d6806 1
a6806 2
	 * Seems like the hardware gets upset unless we align
	 * the write by 8??
a6851 1
		/* "hardware gone" (where, fishing?) */
a6917 4
	/*
	 * The Linux driver uses periodic interrupts to avoid races.
	 * We cargo-cult like it's going out of fashion.
	 */
a6948 4
/*
 * Autoconf glue-sniffing
 */

a7059 4
	/*
	 * Get the offset of the PCI Express Capability Structure in PCI
	 * Configuration Space.
	 */
a7088 1
	/* Install interrupt handler. */
a7152 4
	 * We now start fiddling with the hardware
	 */

	/*
a7229 2
	/* Allocate TX scheduler "rings". */

a7238 1
	/* Allocate TX rings */
a7247 1
	/* Allocate RX ring. */
a7296 1
	/* Max RSSI */
a7340 1
	/* Free allocated memory if something failed during attachment. */
a7353 3
/*
 * Attach the interface to 802.11 radiotap.
 */
@


1.120
log
@Rename local variables called 'ret' to 'err' everywhere in iwm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.119 2016/09/04 10:54:17 stsp Exp $	*/
a5992 7
#ifdef IWM_DEBUG
	struct iwm_rx_packet *pkt;
	struct iwm_mcc_update_resp_v1 *mcc_resp_v1 = NULL;
	struct iwm_mcc_update_resp *mcc_resp;
	int n_channels;
	uint16_t mcc;
#endif
a6012 21
#ifdef IWM_DEBUG
	pkt = hcmd.resp_pkt;

	/* Extract MCC response */
	if (resp_v2) {
		mcc_resp = (void *)pkt->data;
		mcc = mcc_resp->mcc;
		n_channels =  le32toh(mcc_resp->n_channels);
	} else {
		mcc_resp_v1 = (void *)pkt->data;
		mcc = mcc_resp_v1->mcc;
		n_channels =  le32toh(mcc_resp_v1->n_channels);
	}

	/* W/A for a FW/NVM issue - returns 0x00 for the world domain */
	if (mcc == 0)
		mcc = 0x3030;  /* "00" - world */

	DPRINTF(("%s: regulatory domain '%c%c' (%d channels available)\n",
	    DEVNAME(sc), mcc >> 8, mcc & 0xff, n_channels));
#endif
d6136 1
a6136 1
			printf("%s: could not send mcc command (error %d)\n",
@


1.119
log
@Clean up the pile of iwm MAC context command add/send/changed functions.
They all collapse to a single iwm_mvm_mac_ctxt_cmd() entry point.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.118 2016/09/04 10:40:59 stsp Exp $	*/
d837 1
a837 1
	int offs, ret = 0;
d846 1
a846 1
		ret = EBUSY;
d848 1
a848 1
	return ret;
d2273 1
a2273 1
	int ret, offset_read;
d2279 3
a2281 3
	ret = iwm_send_cmd(sc, &cmd);
	if (ret)
		return ret;
d2285 1
a2285 1
		ret = EIO;
d2292 1
a2292 1
	ret = le16toh(nvm_resp->status);
d2296 2
a2297 2
	if (ret) {
		ret = EINVAL;
d2302 1
a2302 1
		ret = EINVAL;
d2307 1
a2307 1
		ret = EINVAL;
d2316 1
a2316 1
	return ret;
d2551 1
a2551 1
	int ret, s;
d2574 1
a2574 1
	ret = iwm_mvm_send_cmd_pdu_status(sc, IWM_ADD_STA,
d2576 1
a2576 1
	if (ret)
d2590 1
a2590 1
		ret = EIO;
d2593 1
a2593 1
		ret = EIO;
d3650 1
a3650 1
	int i, ret;
d3665 1
a3665 1
	ret = iwm_mvm_send_cmd_pdu_status(sc, IWM_BINDING_CONTEXT_CMD,
d3667 2
a3668 2
	if (ret)
		return ret;
d3671 1
a3671 1
		ret = EIO;
d3673 1
a3673 1
	return ret;
d4349 1
a4349 1
	int ret;
d4351 1
a4351 1
	ret = iwm_mvm_send_cmd_pdu(sc, IWM_TXPATH_FLUSH,
d4354 3
a4356 3
	if (ret)
                printf("%s: Flushing tx queue failed: %d\n", DEVNAME(sc), ret);
	return ret;
d4470 1
a4470 1
	int ret;
d4478 4
a4481 3
	if ((ret = iwm_mvm_send_cmd_pdu(sc, IWM_MAC_PM_POWER_TABLE,
	    0, sizeof(cmd), &cmd)) != 0)
		return ret;
d4511 1
a4511 1
	int ret;
d4514 1
a4514 1
	ret = iwm_mvm_beacon_filter_send_cmd(sc, &cmd);
d4516 1
a4516 1
	if (ret == 0)
d4519 1
a4519 1
	return ret;
d4526 1
a4526 1
	int ret;
d4532 2
a4533 2
	ret = iwm_mvm_beacon_filter_send_cmd(sc, &cmd);
	if (ret == 0)
d4536 1
a4536 1
	return ret;
d4544 1
a4544 1
	int ret;
d4598 1
a4598 1
	ret = iwm_mvm_send_cmd_pdu_status(sc, IWM_ADD_STA, sizeof(add_sta_cmd),
d4600 2
a4601 2
	if (ret)
		return ret;
d4607 1
a4607 1
		ret = EIO;
d4611 1
a4611 1
	return ret;
d4631 1
a4631 1
	int ret;
d4644 1
a4644 1
	ret = iwm_mvm_send_cmd_pdu_status(sc, IWM_ADD_STA,
d4646 2
a4647 2
	if (ret)
		return ret;
d4653 1
a4653 1
		ret = EIO;
d4656 1
a4656 1
	return ret;
d4662 1
a4662 1
	int ret;
d4667 3
a4669 3
	ret = iwm_enable_txq(sc, 0, IWM_MVM_AUX_QUEUE, IWM_MVM_TX_FIFO_MCAST);
	if (ret)
		return ret;
d4671 1
a4671 1
	ret = iwm_mvm_add_int_sta_common(sc,
d4674 1
a4674 1
	if (ret)
d4676 1
a4676 1
	return ret;
d4931 1
a4931 1
	int ret;
d5002 1
a5002 1
	ret = iwm_mvm_fill_probe_req(sc,
d5006 1
a5006 1
	if (ret) {
d5008 1
a5008 1
		return ret;
d5019 1
a5019 1
	ret = iwm_send_cmd(sc, &hcmd);
d5021 1
a5021 1
	return ret;
d5029 1
a5029 1
	int ret, nchan;
d5094 1
a5094 1
	ret = iwm_send_cmd(sc, &hcmd);
d5096 1
a5096 1
	return ret;
d5112 1
a5112 1
	int ret;
d5166 2
a5167 2
	ret = iwm_mvm_fill_probe_req(sc, &tail->preq);
	if (ret) {
d5169 1
a5169 1
		return ret;
d5176 1
a5176 1
	ret = iwm_send_cmd(sc, &hcmd);
d5178 1
a5178 1
	return ret;
d5949 1
a5949 1
	int ret = 0;
d5966 1
a5966 1
	ret = iwm_mvm_send_cmd_pdu(sc, IWM_REPLY_SF_CFG_CMD, IWM_CMD_ASYNC,
d5968 1
a5968 1
	return ret;
d5992 1
a5992 1
	int ret;
d6016 3
a6018 3
	ret = iwm_send_cmd(sc, &hcmd);
	if (ret)
		return ret;
a7385 1
		int ret;
d7396 1
a7396 1
		ret = iwm_poll_bit(sc, IWM_CSR_GP_CNTRL,
d7400 1
a7400 1
		if (!ret) {
@


1.118
log
@Rename iwm_mvm_phy_ctxt_apply() to iwm_mvm_phy_ctxt_cmd() and get rid of
redundant iwm_mvm_phy_ctxt_add() and iwm_mvm_phy_ctxt_changed() wrappers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.117 2016/09/04 10:21:14 stsp Exp $	*/
a410 1
int	iwm_mvm_mac_ctxt_send_cmd(struct iwm_softc *, struct iwm_mac_ctx_cmd *);
d413 1
a413 5
int	iwm_mvm_mac_ctxt_cmd_station(struct iwm_softc *, struct iwm_node *,
					uint32_t);
int	iwm_mvm_mac_ctx_send(struct iwm_softc *, struct iwm_node *, uint32_t);
int	iwm_mvm_mac_ctxt_add(struct iwm_softc *, struct iwm_node *);
int	iwm_mvm_mac_ctxt_changed(struct iwm_softc *, struct iwm_node *);
d2607 1
a2607 1
	err = iwm_mvm_mac_ctxt_changed(sc, in);
a5331 7
int
iwm_mvm_mac_ctxt_send_cmd(struct iwm_softc *sc, struct iwm_mac_ctx_cmd *cmd)
{
	return iwm_mvm_send_cmd_pdu(sc, IWM_MAC_CONTEXT_CMD, 0,
				       sizeof(*cmd), cmd);
}

d5355 1
a5355 2
iwm_mvm_mac_ctxt_cmd_station(struct iwm_softc *sc, struct iwm_node *in,
	uint32_t action)
d5364 1
a5364 1
	/* Allow beacons to pass through as long as we are not associated,or we
d5375 2
a5376 54
	return iwm_mvm_mac_ctxt_send_cmd(sc, &cmd);
}

int
iwm_mvm_mac_ctx_send(struct iwm_softc *sc, struct iwm_node *in, uint32_t action)
{
	return iwm_mvm_mac_ctxt_cmd_station(sc, in, action);
}

int
iwm_mvm_mac_ctxt_add(struct iwm_softc *sc, struct iwm_node *in)
{
	int ret;

	ret = iwm_mvm_mac_ctx_send(sc, in, IWM_FW_CTXT_ACTION_ADD);
	if (ret)
		return ret;

	return 0;
}

int
iwm_mvm_mac_ctxt_changed(struct iwm_softc *sc, struct iwm_node *in)
{
	return iwm_mvm_mac_ctx_send(sc, in, IWM_FW_CTXT_ACTION_MODIFY);
}

#if 0
int
iwm_mvm_mac_ctxt_remove(struct iwm_softc *sc, struct iwm_node *in)
{
	struct iwm_mac_ctx_cmd cmd;
	int ret;

	if (!in->in_uploaded) {
		print("%s: attempt to remove !uploaded node %p", DEVNAME(sc), in);
		return EIO;
	}

	memset(&cmd, 0, sizeof(cmd));

	cmd.id_and_color = htole32(IWM_FW_CMD_ID_AND_COLOR(in->in_id,
	    in->in_color));
	cmd.action = htole32(IWM_FW_CTXT_ACTION_REMOVE);

	ret = iwm_mvm_send_cmd_pdu(sc,
	    IWM_MAC_CONTEXT_CMD, 0, sizeof(cmd), &cmd);
	if (ret) {
		printf("%s: Failed to remove MAC context: %d\n", DEVNAME(sc), ret);
		return ret;
	}
	in->in_uploaded = 0;

	return 0;
a5377 1
#endif
d5483 1
a5483 1
	err = iwm_mvm_mac_ctxt_changed(sc, in);
d5514 1
a5514 1
	err = iwm_mvm_mac_ctxt_changed(sc, in);
d6190 1
a6190 1
	err = iwm_mvm_mac_ctxt_add(sc, in);
@


1.117
log
@Remove unused iwm_mvm_binding_update() wrapper function and replace the
iwm_mvm_binding_add_vif() wrapper with a direct call to iwm_mvm_binding_cmd().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.116 2016/09/04 10:14:35 stsp Exp $	*/
d358 1
a358 1
int	iwm_mvm_phy_ctxt_apply(struct iwm_softc *, struct iwm_mvm_phy_ctxt *,
a359 4
int	iwm_mvm_phy_ctxt_add(struct iwm_softc *, struct iwm_mvm_phy_ctxt *,
				struct ieee80211_channel *, uint8_t, uint8_t);
int	iwm_mvm_phy_ctxt_changed(struct iwm_softc *, struct iwm_mvm_phy_ctxt *,
				struct ieee80211_channel *, uint8_t, uint8_t);
a3726 6
/*
 * Send a command
 * only if something in the configuration changed: in case that this is the
 * first time that the phy configuration is applied or in case that the phy
 * configuration changed from the previous apply.
 */
d3728 1
a3728 1
iwm_mvm_phy_ctxt_apply(struct iwm_softc *sc,
a3746 28
 * Send a command to add a PHY context based on the current HW configuration.
 */
int
iwm_mvm_phy_ctxt_add(struct iwm_softc *sc, struct iwm_mvm_phy_ctxt *ctxt,
	struct ieee80211_channel *chan,
	uint8_t chains_static, uint8_t chains_dynamic)
{
	ctxt->channel = chan;
	return iwm_mvm_phy_ctxt_apply(sc, ctxt,
	    chains_static, chains_dynamic, IWM_FW_CTXT_ACTION_ADD, 0);
}

/*
 * Send a command to modify the PHY context based on the current HW
 * configuration. Note that the function does not check that the configuration
 * changed.
 */
int
iwm_mvm_phy_ctxt_changed(struct iwm_softc *sc,
	struct iwm_mvm_phy_ctxt *ctxt, struct ieee80211_channel *chan,
	uint8_t chains_static, uint8_t chains_dynamic)
{
	ctxt->channel = chan;
	return iwm_mvm_phy_ctxt_apply(sc, ctxt,
	    chains_static, chains_dynamic, IWM_FW_CTXT_ACTION_MODIFY, 0);
}

/*
d5534 3
a5536 2
	err = iwm_mvm_phy_ctxt_changed(sc, &sc->sc_phyctxt[0],
	    in->in_ni.ni_chan, 1, 1);
d6205 3
a6207 2
		err = iwm_mvm_phy_ctxt_add(sc,
		    &sc->sc_phyctxt[i], &ic->ic_channels[1], 1, 1);
@


1.116
log
@Get rid of pointless iwm_mvm_time_event_send_add() wrapper.
Call iwm_mvm_send_time_event_cmd() directly instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.115 2016/09/03 18:04:03 stsp Exp $	*/
a352 2
int	iwm_mvm_binding_update(struct iwm_softc *, struct iwm_node *);
int	iwm_mvm_binding_add_vif(struct iwm_softc *, struct iwm_node *);
a3684 12
int
iwm_mvm_binding_update(struct iwm_softc *sc, struct iwm_node *in)
{
	return iwm_mvm_binding_cmd(sc, in, IWM_FW_CTXT_ACTION_MODIFY);
}

int
iwm_mvm_binding_add_vif(struct iwm_softc *sc, struct iwm_node *in)
{
	return iwm_mvm_binding_cmd(sc, in, IWM_FW_CTXT_ACTION_ADD);
}

d5578 1
a5578 1
	err = iwm_mvm_binding_add_vif(sc, in);
@


1.115
log
@Remove iwm_release() by inlining its implementation into its only caller.
All the speculative comments about how the HW should be reset go away.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.114 2016/09/03 17:29:47 stsp Exp $	*/
a291 2
int	iwm_mvm_time_event_send_add(struct iwm_softc *, struct iwm_node *,
					void *, struct iwm_time_event_cmd_v2 *);
a2208 7
int
iwm_mvm_time_event_send_add(struct iwm_softc *sc, struct iwm_node *in,
	void *te_data, struct iwm_time_event_cmd_v2 *te_cmd)
{
	return iwm_mvm_send_time_event_cmd(sc, te_cmd);
}

d2235 1
a2235 1
	iwm_mvm_time_event_send_add(sc, in, /*te_data*/NULL, &time_cmd);
@


1.114
log
@iwm was undecided between 'if (err != 0)' and 'if (err)'; switch to 'if (err)'
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.113 2016/09/03 17:09:23 stsp Exp $	*/
a429 1
int	iwm_release(struct iwm_softc *, struct iwm_node *);
a5648 58
int
iwm_release(struct iwm_softc *sc, struct iwm_node *in)
{
	/*
	 * Ok, so *technically* the proper set of calls for going
	 * from RUN back to SCAN is:
	 *
	 * iwm_mvm_power_mac_disable(sc, in);
	 * iwm_mvm_mac_ctxt_changed(sc, in);
	 * iwm_mvm_rm_sta(sc, in);
	 * iwm_mvm_update_quotas(sc, NULL);
	 * iwm_mvm_mac_ctxt_changed(sc, in);
	 * iwm_mvm_binding_remove_vif(sc, in);
	 * iwm_mvm_mac_ctxt_remove(sc, in);
	 *
	 * However, that freezes the device not matter which permutations
	 * and modifications are attempted.  Obviously, this driver is missing
	 * something since it works in the Linux driver, but figuring out what
	 * is missing is a little more complicated.  Now, since we're going
	 * back to nothing anyway, we'll just do a complete device reset.
	 * Up your's, device!
	 */
	/* iwm_mvm_flush_tx_path(sc, 0xf, 1); */
	iwm_stop_device(sc);
	iwm_init_hw(sc);
	if (in)
		in->in_assoc = 0;
	return 0;

#if 0
	int err;

	iwm_mvm_power_mac_disable(sc, in);

	if ((err = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) {
		printf("%s: mac ctxt change fail 1 %d\n", DEVNAME(sc), err);
		return err;
	}

	if ((err = iwm_mvm_rm_sta(sc, in)) != 0) {
		printf("%s: sta remove fail %d\n", DEVNAME(sc), err);
		return err;
	}
	err = iwm_mvm_rm_sta(sc, in);
	in->in_assoc = 0;
	iwm_mvm_update_quotas(sc, NULL);
	if ((err = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) {
		printf("%s: mac ctxt change fail 2 %d\n", DEVNAME(sc), err);
		return err;
	}
	iwm_mvm_binding_remove_vif(sc, in);

	iwm_mvm_mac_ctxt_remove(sc, in);

	return err;
#endif
}

d5848 1
d5850 2
a5851 1
		if (((in = (void *)ic->ic_bss) != NULL))
a5852 1
		iwm_release(sc, NULL);
d5854 7
a5860 10
		/*
		 * It's impossible to directly go RUN->SCAN. If we iwm_release()
		 * above then the card will be completely reinitialized,
		 * so the driver must do everything necessary to bring the card
		 * from INIT to SCAN.
		 *
		 * Additionally, upon receiving deauth frame from AP,
		 * OpenBSD 802.11 stack puts the driver in IEEE80211_S_AUTH
		 * state. This will also fail with this driver, so bring the FSM
		 * from IEEE80211_S_RUN to IEEE80211_S_SCAN in this case as well.
@


1.113
log
@In iwm, move assignments to 'err' outside of if-statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.112 2016/09/03 16:20:07 stsp Exp $	*/
d578 1
a578 1
	if (err != 0) {
d671 1
a671 1
			if (err != 0)
d690 1
a690 1
			if (err != 0)
d696 1
a696 1
			if (err != 0)
d702 1
a702 1
			if (err != 0)
d711 1
a711 1
			if (err != 0)
d767 1
a767 1
			if (err != 0)
d982 1
a982 1
	if (err != 0)
d987 1
a987 1
	if (err != 0)
d992 1
a992 1
	if (err != 0)
d998 1
a998 1
	if (err != 0)
d1039 1
a1039 1
	if (err != 0) {
d1049 1
a1049 1
	if (err != 0) {
d1066 1
a1066 1
		if (err != 0) {
d1148 1
a1148 1
	if (err != 0) {
d1164 1
a1164 1
	if (err != 0) {
d1189 1
a1189 1
		if (err != 0) {
d1531 1
a1531 1
	if (err != 0)
d1539 1
a1539 1
	if (err != 0)
d1752 1
a1752 1
	if (err != 0)
d1759 1
a1759 1
	if (err != 0)
d2629 1
a2629 1
	if (err != 0)
d2995 1
a2995 1
		if (err != 0)
d3177 1
a3177 1
	if (err != 0) {
d3236 1
a3236 1
	if (err != 0)
d3267 1
a3267 1
	if (err != 0) {
d3274 1
a3274 1
		if (err != 0) {
d3287 1
a3287 1
	if (err != 0)
d3292 1
a3292 1
	if (err != 0)
d3297 1
a3297 1
	if (err != 0)
d3305 1
a3305 1
	if (err != 0)
d3314 1
a3314 1
		if (err != 0)
d3357 1
a3357 1
	if (err != 0) {
d3892 1
a3892 1
		if (err != 0) {
d3980 1
a3980 1
	if (wantresp && err != 0) {
d4014 1
a4014 1
	if (err != 0)
d5589 1
a5589 1
	if (err != 0)
d5593 1
a5593 1
	if (err != 0)
d5598 1
a5598 1
	if (err != 0)
d5603 1
a5603 1
	if (err != 0)
d5607 1
a5607 1
	if (err != 0)
d5611 1
a5611 1
	if (err != 0) {
d5636 1
a5636 1
	if (err != 0)
d5642 1
a5642 1
	if (err != 0) {
d5944 1
a5944 1
		if (err != 0) {
d5955 1
a5955 1
		if (err != 0)
d5962 1
a5962 1
		if (err != 0)
d6252 1
a6252 1
	if (err != 0)
d6256 1
a6256 1
	if (err != 0) {
d6262 1
a6262 1
	if (err != 0)
d6271 1
a6271 1
	if (err != 0) {
d6284 1
a6284 1
	if (err != 0) {
d6291 1
a6291 1
	if (err != 0) {
d6299 1
a6299 1
	if (err != 0) {
d6306 1
a6306 1
	if (err != 0) {
d6314 1
a6314 1
	if (err != 0) {
d6328 1
a6328 1
		if (err != 0) {
d6348 1
a6348 1
		if (err != 0) {
d6357 1
a6357 1
		if (err != 0) {
d6377 1
a6377 1
	if (err != 0) {
d6384 1
a6384 1
	if (err != 0) {
d6440 1
a6440 1
	if (err != 0) {
d6599 1
a6599 1
	if (err != 0) {
d6613 1
a6613 1
				if (err != 0)
d7374 1
a7374 1
	if (err != 0) {
d7387 1
a7387 1
	if (err != 0) {
d7482 1
a7482 1
	if (err != 0) {
d7613 1
a7613 1
	if (err != 0) {
d7621 1
a7621 1
	if (err != 0) {
d7629 1
a7629 1
	if (err != 0) {
d7639 1
a7639 1
	if (err != 0) {
d7648 1
a7648 1
		if (err != 0) {
d7657 1
a7657 1
	if (err != 0) {
@


1.112
log
@The iwm code was torn between 'error' and 'err'; error -> err everywhere
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.111 2016/09/03 15:33:48 stsp Exp $	*/
d670 2
a671 2
			if ((err = iwm_store_cscheme(sc,
			    tlv_data, tlv_len)) != 0)
d688 3
a690 2
			if ((err = iwm_firmware_store_section(sc,
			    IWM_UCODE_TYPE_REGULAR, tlv_data, tlv_len)) != 0)
d694 3
a696 2
			if ((err = iwm_firmware_store_section(sc,
			    IWM_UCODE_TYPE_INIT, tlv_data, tlv_len)) != 0)
d700 3
a702 2
			if ((err = iwm_firmware_store_section(sc,
			    IWM_UCODE_TYPE_WOW, tlv_data, tlv_len)) != 0)
d710 2
a711 1
			if ((err = iwm_set_default_calib(sc, tlv_data)) != 0)
d764 1
a764 1
			if ((err = iwm_firmware_store_section(sc,
d766 2
a767 1
			    tlv_len)) != 0)
d1072 2
a1073 1
		if ((err = iwm_rx_addbuf(sc, IWM_RBUF_SIZE, i)) != 0) {
a1074 1
		}
d1530 2
a1531 1
	if ((err = iwm_prepare_card_hw(sc)) != 0)
d1538 2
a1539 1
	if ((err = iwm_apm_init(sc)) != 0)
d1751 2
a1752 1
	if ((err = iwm_nic_rx_init(sc)) != 0)
d1758 2
a1759 1
	if ((err = iwm_nic_tx_init(sc)) != 0)
d2993 3
a2995 2
	while (!sc->sc_fw_chunk_done)
		if ((err = tsleep(&sc->sc_fw, 0, "iwmfw", hz)) != 0)
d2997 1
d3176 2
a3177 1
	if ((err = iwm_nic_init(sc)) != 0) {
d3235 2
a3236 1
	if ((err = iwm_read_firmware(sc, ucode_type)) != 0)
d3266 2
a3267 2
	if ((err = iwm_mvm_load_ucode_wait_alive(sc,
	    IWM_UCODE_TYPE_INIT)) != 0) {
d3273 2
a3274 1
		if ((err = iwm_nvm_init(sc)) != 0) {
d3312 3
a3314 3
	while (!sc->sc_init_complete)
		if ((err = tsleep(&sc->sc_init_complete,
		    0, "iwminit", 2*hz)) != 0)
d3316 1
d3355 3
a3357 2
	if ((err = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT)) != 0) {
d4013 2
a4014 1
	if ((err = iwm_send_cmd(sc, cmd)) != 0)
d5641 2
a5642 1
	if ((err = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) {
d6251 2
a6252 1
	if ((err = iwm_preinit(sc)) != 0)
d6255 2
a6256 1
	if ((err = iwm_start_hw(sc)) != 0) {
d6261 2
a6262 1
	if ((err = iwm_run_init_mvm_ucode(sc, 0)) != 0)
d6270 2
a6271 1
	if ((err = iwm_start_hw(sc)) != 0) {
d6283 2
a6284 1
	if ((err = iwm_send_bt_init_conf(sc)) != 0) {
d6290 2
a6291 1
	if ((err = iwm_send_tx_ant_cfg(sc, iwm_fw_valid_tx_ant(sc))) != 0) {
d6298 2
a6299 1
	if ((err = iwm_send_phy_db_data(sc)) != 0) {
d6305 2
a6306 1
	if ((err = iwm_send_phy_cfg_cmd(sc)) != 0) {
d6313 2
a6314 1
	if ((err = iwm_mvm_add_aux_sta(sc)) != 0) {
d6326 3
a6328 2
		if ((err = iwm_mvm_phy_ctxt_add(sc,
		    &sc->sc_phyctxt[i], &ic->ic_channels[1], 1, 1)) != 0) {
d6347 2
a6348 1
		if ((err = iwm_send_update_mcc_cmd(sc, "ZZ")) != 0) {
d6356 2
a6357 1
		if ((err = iwm_mvm_config_umac_scan(sc)) != 0) {
d6376 2
a6377 1
	if ((err = iwm_mvm_mac_ctxt_add(sc, in)) != 0) {
d6383 2
a6384 1
	if ((err = iwm_mvm_disable_beacon_filter(sc)) != 0) {
d6439 2
a6440 1
	if ((err = iwm_init_hw(sc)) != 0) {
d6612 2
a6613 1
				if ((err = iwm_init(ifp)) != 0)
d7373 2
a7374 1
	if ((err = iwm_prepare_card_hw(sc)) != 0) {
d7386 2
a7387 1
	if ((err = iwm_start_hw(sc)) != 0) {
d7647 2
a7648 2
		if ((err = iwm_alloc_tx_ring(sc,
		    &sc->txq[txq_i], txq_i)) != 0) {
d7656 2
a7657 1
	if ((err = iwm_alloc_rx_ring(sc, &sc->rxq)) != 0) {
@


1.111
log
@DPRINTFs infesting iwm die in a fire... too much noise
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.110 2016/09/03 15:08:15 stsp Exp $	*/
d558 1
a558 1
	int error;
d576 1
a576 1
	error = loadfirmware(sc->sc_fwname,
d578 1
a578 1
	if (error != 0) {
d580 1
a580 1
		    DEVNAME(sc), sc->sc_fwname, error);
d599 1
a599 1
		error = EINVAL;
d625 1
a625 1
			error = EINVAL;
d632 1
a632 1
				error = EINVAL;
d640 1
a640 1
				error = EINVAL;
d646 1
a646 1
				error = EINVAL;
d653 1
a653 1
				error = EINVAL;
d670 1
a670 1
			if ((error = iwm_store_cscheme(sc,
d677 1
a677 1
				error = EINVAL;
d682 1
a682 1
				error = EINVAL;
d688 1
a688 1
			if ((error = iwm_firmware_store_section(sc,
d693 1
a693 1
			if ((error = iwm_firmware_store_section(sc,
d698 1
a698 1
			if ((error = iwm_firmware_store_section(sc,
d704 1
a704 1
				error = EINVAL;
d707 1
a707 1
			if ((error = iwm_set_default_calib(sc, tlv_data)) != 0)
d712 1
a712 1
				error = EINVAL;
d721 1
a721 1
				error = EINVAL;
d737 1
a737 1
				error = EINVAL;
d760 1
a760 1
			if ((error = iwm_firmware_store_section(sc,
d768 1
a768 1
				error = EINVAL;
d777 1
a777 1
				error = EINVAL;
d788 1
a788 1
			error = EINVAL;
d796 1
a796 1
	KASSERT(error == 0);
d799 1
a799 1
	if (error) {
d801 1
a801 1
		    "section type %d\n", DEVNAME(sc), error, tlv_type);
d806 1
a806 1
		error = ENOTSUP;
d810 1
a810 1
	if (error) {
d818 1
a818 1
	return error;
d969 1
a969 1
	int nsegs, error;
d975 1
a975 1
	error = bus_dmamap_create(tag, size, 1, size, 0, BUS_DMA_NOWAIT,
d977 1
a977 1
	if (error != 0)
d980 1
a980 1
	error = bus_dmamem_alloc(tag, size, alignment, 0, &dma->seg, 1, &nsegs,
d982 1
a982 1
	if (error != 0)
d985 1
a985 1
	error = bus_dmamem_map(tag, &dma->seg, 1, size, &va,
d987 1
a987 1
	if (error != 0)
d991 1
a991 1
	error = bus_dmamap_load(tag, dma->map, dma->vaddr, size, NULL,
d993 1
a993 1
	if (error != 0)
d1003 1
a1003 1
	return error;
d1027 1
a1027 1
	int i, error;
d1033 2
a1034 2
	error = iwm_dma_contig_alloc(sc->sc_dmat, &ring->desc_dma, size, 256);
	if (error != 0) {
d1042 1
a1042 1
	error = iwm_dma_contig_alloc(sc->sc_dmat, &ring->stat_dma,
d1044 1
a1044 1
	if (error != 0) {
d1058 1
a1058 1
		error = bus_dmamap_create(sc->sc_dmat, IWM_RBUF_SIZE, 1,
d1061 1
a1061 1
		if (error != 0) {
d1067 1
a1067 1
		if ((error = iwm_rx_addbuf(sc, IWM_RBUF_SIZE, i)) != 0) {
d1074 1
a1074 1
	return error;
d1134 1
a1134 1
	int i, error;
d1142 2
a1143 2
	error = iwm_dma_contig_alloc(sc->sc_dmat, &ring->desc_dma, size, 256);
	if (error != 0) {
d1158 2
a1159 2
	error = iwm_dma_contig_alloc(sc->sc_dmat, &ring->cmd_dma, size, 4);
	if (error != 0) {
d1181 1
a1181 1
		error = bus_dmamap_create(sc->sc_dmat, mapsize,
d1184 1
a1184 1
		if (error != 0) {
d1194 1
a1194 1
	return error;
d1407 1
a1407 1
	int error = 0;
d1456 1
a1456 1
		error = ETIMEDOUT;
d1503 3
a1505 3
	if (error)
		printf("%s: apm init error %d\n", DEVNAME(sc), error);
	return error;
d1523 1
a1523 1
	int error;
d1525 2
a1526 2
	if ((error = iwm_prepare_card_hw(sc)) != 0)
		return error;
d1532 2
a1533 2
	if ((error = iwm_apm_init(sc)) != 0)
		return error;
d1734 1
a1734 1
	int error;
d1744 2
a1745 2
	if ((error = iwm_nic_rx_init(sc)) != 0)
		return error;
d1750 2
a1751 2
	if ((error = iwm_nic_tx_init(sc)) != 0)
		return error;
d1803 1
a1803 1
		int error;
d1815 1
a1815 1
		error = iwm_mvm_send_cmd_pdu(sc, IWM_SCD_QUEUE_CFG, 0,
d1817 2
a1818 2
		if (error)
			return error;
d1836 1
a1836 1
	int error, chnl;
d1850 1
a1850 1
	error = iwm_write_mem(sc,
d1853 1
a1853 1
	if (error)
d1864 3
a1866 3
	error = iwm_enable_txq(sc, 0 /* unused */, IWM_MVM_CMD_QUEUE, 7);
	if (error)
		return error;
d1890 1
a1890 1
	return error;
d2346 1
a2346 1
	int error = 0;
d2353 1
a2353 1
		error = iwm_nvm_read_chunk(sc,
d2355 2
a2356 2
		if (error)
			return error;
d2361 1
a2361 1
	return error;
d2616 1
a2616 1
	int error;
d2619 2
a2620 2
	error = iwm_mvm_mac_ctxt_changed(sc, in);
	if (error != 0)
d2622 1
a2622 1
		    DEVNAME(sc), error);
d2869 1
a2869 1
	int i, section, error;
d2884 3
a2886 3
		error = iwm_nvm_read_section(sc, section, buf, &len, bufsz);
		if (error) {
			error = 0;
d2891 1
a2891 1
			error = ENOMEM;
d2898 2
a2899 2
	if (error == 0)
		error = iwm_parse_nvm_sections(sc, nvm_sections);
d2907 1
a2907 1
	return error;
d2919 1
a2919 1
	int error = EINVAL;
d2932 2
a2933 2
		error = iwm_firmware_load_chunk(sc, addr, data, len);
		if (error)
d2937 1
a2937 1
	return error;
d2945 1
a2945 1
	int error;
d2983 1
a2983 1
	error = 0;
d2985 1
a2985 1
		if ((error = tsleep(&sc->sc_fw, 0, "iwmfw", hz)) != 0)
d2999 1
a2999 1
	return error;
d3006 1
a3006 1
	int error, i;
d3019 1
a3019 1
			error = EFBIG;
d3021 2
a3022 2
			error = iwm_firmware_load_sect(sc, offset, data, dlen);
		if (error) {
d3025 1
a3025 1
			return error;
d3039 1
a3039 1
	int i, error = 0, sec_num = 0x1;
d3070 1
a3070 1
			error = EFBIG;
d3072 2
a3073 2
			error = iwm_firmware_load_sect(sc, offset, data, dlen);
		if (error) {
d3075 2
a3076 2
			    "(error %d)\n", DEVNAME(sc), i, error);
			return error;
d3111 1
a3111 1
	int error = 0;
d3121 3
a3123 3
	error = iwm_load_cpu_sections_8000(sc, fws, 1, &first_ucode_section);
	if (error)
		return error;
d3132 1
a3132 1
	int error, w;
d3135 1
a3135 1
		error = iwm_load_firmware_8000(sc, ucode_type);
d3137 1
a3137 1
		error = iwm_load_firmware_7000(sc, ucode_type);
d3139 2
a3140 2
	if (error)
		return error;
d3144 1
a3144 1
		error = tsleep(&sc->sc_uc, 0, "iwmuc", hz/10);
d3146 1
a3146 1
	if (error || !sc->sc_uc.uc_ok)
d3155 1
a3155 1
	return error;
d3161 1
a3161 1
	int error;
d3165 1
a3165 1
	if ((error = iwm_nic_init(sc)) != 0) {
d3167 1
a3167 1
		return error;
d3221 1
a3221 1
	int error;
d3223 2
a3224 2
	if ((error = iwm_read_firmware(sc, ucode_type)) != 0)
		return error;
d3227 2
a3228 2
	error = iwm_start_fw(sc, ucode_type);
	if (error) {
d3230 1
a3230 1
		return error;
d3243 1
a3243 1
	int error;
d3253 1
a3253 1
	if ((error = iwm_mvm_load_ucode_wait_alive(sc,
d3256 1
a3256 1
		return error;
d3260 1
a3260 1
		if ((error = iwm_nvm_init(sc)) != 0) {
d3262 1
a3262 1
			return error;
d3272 3
a3274 3
	error = iwm_send_bt_init_conf(sc);
	if (error != 0)
		return error;
d3277 3
a3279 3
	error = iwm_mvm_sf_config(sc, IWM_SF_INIT_OFF);
	if (error != 0)
		return error;
d3282 3
a3284 3
	error = iwm_send_tx_ant_cfg(sc, iwm_fw_valid_tx_ant(sc));
	if (error != 0)
		return error;
d3290 3
a3292 3
	error = iwm_send_phy_cfg_cmd(sc);
	if (error != 0)
		return error;
d3299 1
a3299 1
		if ((error = tsleep(&sc->sc_init_complete,
d3303 1
a3303 1
	return error;
d3317 1
a3317 1
	int error;
d3340 1
a3340 1
	if ((error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
d3346 1
a3346 1
		return error;
d3813 1
a3813 1
	int error = 0, i, paylen, off, s;
d3841 1
a3841 1
		error = ENXIO;
d3863 1
a3863 1
			error = EINVAL;
d3870 1
a3870 1
			error = ENOMEM;
d3874 1
a3874 1
		error = bus_dmamap_load(sc->sc_dmat, txdata->map, cmd,
d3876 1
a3876 1
		if (error != 0) {
d3939 1
a3939 1
		error = EBUSY;
d3953 2
a3954 2
		error = tsleep(desc, PCATCH, "iwmcmd", hz);
		if (error == 0) {
d3957 1
a3957 1
				error = ENXIO;
d3964 1
a3964 1
	if (wantresp && error != 0) {
d3969 1
a3969 1
	return error;
d3992 1
a3992 1
	int error, resp_len;
d3997 2
a3998 2
	if ((error = iwm_send_cmd(sc, cmd)) != 0)
		return error;
d4003 1
a4003 1
		error = 0;
d4008 1
a4008 1
		error = EIO;
d4014 1
a4014 1
		error = EIO;
d4022 1
a4022 1
	return error;
d4192 1
a4192 1
	int i, totlen, error, pad;
d4319 1
a4319 1
	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
d4321 2
a4322 2
	if (error && error != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n", DEVNAME(sc), error);
d4324 1
a4324 1
		return error;
d4326 1
a4326 1
	if (error) {
d4332 1
a4332 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
d4334 1
a4334 1
		if (error) {
d4336 1
a4336 1
			    error);
d4338 1
a4338 1
			return error;
d5567 1
a5567 1
	int error;
d5571 7
a5577 7
	error = iwm_mvm_sf_config(sc, IWM_SF_FULL_ON);
	if (error != 0)
		return error;

	error = iwm_allow_mcast(sc);
	if (error != 0)
		return error;
d5579 1
a5579 1
	error = iwm_mvm_phy_ctxt_changed(sc, &sc->sc_phyctxt[0],
d5581 2
a5582 2
	if (error != 0)
		return error;
d5585 3
a5587 7
	error = iwm_mvm_binding_add_vif(sc, in);
	if (error != 0)
		return error;

	error = iwm_mvm_add_sta(sc, in);
	if (error != 0)
		return error;
d5589 6
a5594 2
	error = iwm_mvm_mac_ctxt_changed(sc, in);
	if (error != 0) {
d5596 1
a5596 1
		return error;
d5616 1
a5616 1
	int error;
d5618 3
a5620 3
	error = iwm_mvm_update_sta(sc, in);
	if (error != 0)
		return error;
d5624 1
a5624 1
	if ((error = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) {
d5626 1
a5626 1
		return error;
d5662 1
a5662 1
	int error;
d5666 3
a5668 3
	if ((error = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) {
		printf("%s: mac ctxt change fail 1 %d\n", DEVNAME(sc), error);
		return error;
d5671 3
a5673 3
	if ((error = iwm_mvm_rm_sta(sc, in)) != 0) {
		printf("%s: sta remove fail %d\n", DEVNAME(sc), error);
		return error;
d5675 1
a5675 1
	error = iwm_mvm_rm_sta(sc, in);
d5678 3
a5680 3
	if ((error = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) {
		printf("%s: mac ctxt change fail 2 %d\n", DEVNAME(sc), error);
		return error;
d5686 1
a5686 1
	return error;
d5840 1
a5840 1
	int error;
d5842 3
a5844 3
	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;
d5861 1
a5861 1
		error = iwm_init(ifp);
d5863 1
a5863 1
	return error;
d5875 1
a5875 1
	int error;
d5923 1
a5923 1
			error = iwm_mvm_umac_scan(sc);
d5925 2
a5926 2
			error = iwm_mvm_lmac_scan(sc);
		if (error != 0) {
d5936 2
a5937 2
		error = iwm_auth(sc);
		if (error != 0)
d5943 2
a5944 2
		error = iwm_assoc(sc);
		if (error != 0)
d6231 1
a6231 1
	int error, i, ac;
d6233 2
a6234 2
	if ((error = iwm_preinit(sc)) != 0)
		return error;
d6236 1
a6236 1
	if ((error = iwm_start_hw(sc)) != 0) {
d6238 1
a6238 1
		return error;
d6241 2
a6242 2
	if ((error = iwm_run_init_mvm_ucode(sc, 0)) != 0)
		return error;
d6249 1
a6249 1
	if ((error = iwm_start_hw(sc)) != 0) {
d6251 1
a6251 1
		return error;
d6255 2
a6256 2
	error = iwm_mvm_load_ucode_wait_alive(sc, IWM_UCODE_TYPE_REGULAR);
	if (error) {
d6258 1
a6258 1
		goto error;
d6261 1
a6261 1
	if ((error = iwm_send_bt_init_conf(sc)) != 0) {
d6263 2
a6264 2
		    DEVNAME(sc), error);
		goto error;
d6267 1
a6267 1
	if ((error = iwm_send_tx_ant_cfg(sc, iwm_fw_valid_tx_ant(sc))) != 0) {
d6269 2
a6270 2
		    DEVNAME(sc), error);
		goto error;
d6274 1
a6274 1
	if ((error = iwm_send_phy_db_data(sc)) != 0) {
d6276 2
a6277 2
		    DEVNAME(sc), error);
		goto error;
d6280 1
a6280 1
	if ((error = iwm_send_phy_cfg_cmd(sc)) != 0) {
d6282 2
a6283 2
		    DEVNAME(sc), error);
		goto error;
d6287 1
a6287 1
	if ((error = iwm_mvm_add_aux_sta(sc)) != 0) {
d6289 2
a6290 2
		    DEVNAME(sc), error);
		goto error;
d6299 1
a6299 1
		if ((error = iwm_mvm_phy_ctxt_add(sc,
d6302 2
a6303 2
			    DEVNAME(sc), i, error);
			goto error;
d6311 2
a6312 2
	error = iwm_mvm_power_update_device(sc);
	if (error) {
d6314 2
a6315 2
		    DEVNAME(sc), error);
		goto error;
d6319 1
a6319 1
		if ((error = iwm_send_update_mcc_cmd(sc, "ZZ")) != 0) {
d6321 2
a6322 2
			    DEVNAME(sc), error);
			goto error;
d6327 1
a6327 1
		if ((error = iwm_mvm_config_umac_scan(sc)) != 0) {
d6329 2
a6330 2
			    DEVNAME(sc), error);
			goto error;
d6336 1
a6336 1
		error = iwm_enable_txq(sc, IWM_STATION_ID, ac,
d6338 1
a6338 1
		if (error) {
d6340 2
a6341 2
			    DEVNAME(sc), ac, error);
			goto error;
d6346 1
a6346 1
	if ((error = iwm_mvm_mac_ctxt_add(sc, in)) != 0) {
d6348 2
a6349 2
		    DEVNAME(sc), error);
		goto error;
d6352 1
a6352 1
	if ((error = iwm_mvm_disable_beacon_filter(sc)) != 0) {
d6354 2
a6355 2
		    DEVNAME(sc), error);
		goto error;
d6360 1
a6360 1
 error:
d6362 1
a6362 1
	return error;
d6373 1
a6373 1
	int error;
d6385 1
a6385 1
	error = iwm_mvm_send_cmd_pdu(sc, IWM_MCAST_FILTER_CMD,
d6388 1
a6388 1
	return error;
d6399 1
a6399 1
	int error;
d6407 1
a6407 1
	if ((error = iwm_init_hw(sc)) != 0) {
d6409 1
a6409 1
		return error;
d6556 1
a6556 1
	int s, error = 0;
d6564 3
a6566 3
	while ((sc->sc_flags & IWM_FLAG_BUSY) && error == 0)
		error = tsleep(&sc->sc_flags, PCATCH, "iwmioc", 0);
	if (error != 0) {
d6568 1
a6568 1
		return error;
d6579 1
a6579 1
				if ((error = iwm_init(ifp)) != 0)
d6591 1
a6591 1
		error = (cmd == SIOCADDMULTI) ?
d6594 2
a6595 2
		if (error == ENETRESET)
			error = 0;
d6599 1
a6599 1
		error = ieee80211_ioctl(ifp, cmd, data);
d6602 2
a6603 2
	if (error == ENETRESET) {
		error = 0;
d6607 1
a6607 1
			error = iwm_init(ifp);
d6614 1
a6614 1
	return error;
d7336 1
a7336 1
	int error;
d7339 1
a7339 1
	if ((error = iwm_prepare_card_hw(sc)) != 0) {
d7341 1
a7341 1
		return error;
d7351 1
a7351 1
	if ((error = iwm_start_hw(sc)) != 0) {
d7353 1
a7353 1
		return error;
d7356 1
a7356 1
	error = iwm_run_init_mvm_ucode(sc, 1);
d7358 2
a7359 2
	if (error)
		return error;
d7379 2
a7380 2
	error = if_setlladdr(ifp, ic->ic_myaddr);
	if (error)
d7382 1
a7382 1
		    DEVNAME(sc), error);
d7409 1
a7409 1
	int error;
d7422 1
a7422 1
	error = pci_get_capability(sc->sc_pct, sc->sc_pcitag,
d7424 1
a7424 1
	if (error == 0) {
d7444 1
a7444 1
	error = pci_mapreg_map(pa, PCI_MAPREG_START, memtype, 0,
d7446 1
a7446 1
	if (error != 0) {
d7575 1
a7575 1
	error = iwm_dma_contig_alloc(sc->sc_dmat, &sc->fw_dma,
d7577 1
a7577 1
	if (error != 0) {
d7584 2
a7585 2
	error = iwm_dma_contig_alloc(sc->sc_dmat, &sc->kw_dma, 4096, 4096);
	if (error != 0) {
d7591 1
a7591 1
	error = iwm_dma_contig_alloc(sc->sc_dmat, &sc->ict_dma,
d7593 1
a7593 1
	if (error != 0) {
d7601 1
a7601 1
	error = iwm_dma_contig_alloc(sc->sc_dmat, &sc->sched_dma,
d7603 1
a7603 1
	if (error != 0) {
d7611 1
a7611 1
		if ((error = iwm_alloc_tx_ring(sc,
d7620 1
a7620 1
	if ((error = iwm_alloc_rx_ring(sc, &sc->rxq)) != 0) {
@


1.110
log
@Get rid of iwm_set_pwr(). Call iwm_set_bits_mask_prph() directly instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.109 2016/09/03 15:05:03 stsp Exp $	*/
a391 1
void	iwm_mvm_power_log(struct iwm_softc *, struct iwm_mac_power_cmd *);
d529 1
a529 3
	if (ucode_type >= IWM_UCODE_TYPE_MAX) {
		DPRINTF(("%s: Wrong ucode_type %u for default "
		    "calibration.\n", DEVNAME(sc), ucode_type));
a530 1
	}
a639 2
				DPRINTF(("%s: IWM_UCODE_TLV_PROBE_MAX_LEN "
				    "ridiculous\n", DEVNAME(sc)));
a726 2
				DPRINTF(("%s: unsupported API index %d\n",
				    DEVNAME(sc), le32toh(api->api_index)));
a742 2
				DPRINTF(("%s: unsupported API index %d\n",
				    DEVNAME(sc), idx));
a787 2
			DPRINTF(("%s: unknown firmware section %d, abort\n",
			    DEVNAME(sc), tlv_type));
a874 1
		DPRINTF(("%s: write_mem failed\n", DEVNAME(sc)));
d920 1
a920 1
		DPRINTF(("%s: resetting device via NMI\n", __func__));
a1408 2
	DPRINTF(("iwm apm start\n"));

a1517 1
        DPRINTF(("iwm apm stop\n"));
a1634 3
	DPRINTF(("Radio type=0x%x-0x%x-0x%x\n", radio_cfg_type,
	    radio_cfg_step, radio_cfg_dash));

a1721 2
		DPRINTF(("loading ring %d descriptors (%p) at %lx\n",
		    qid, txq->desc, txq->desc_dma.paddr >> 8));
a1752 1
	DPRINTF(("shadow registers enabled\n"));
d1768 1
a1768 2
	if (!iwm_nic_lock(sc)) {
		DPRINTF(("%s: cannot enable txq %d\n", DEVNAME(sc), qid));
a1769 1
	}
d1817 1
a1817 2
		if (error) {
			DPRINTF(("%s: cannot enable txq %d\n", DEVNAME(sc), qid));
a1818 1
		}
a1828 2
	DPRINTF(("enabled txq %d FIFO %d\n", qid, fifo));

a1842 3
	if (sc->sched_base != base)
		DPRINTF(("%s: sched addr mismatch: alive: 0x%x prph: 0x%x\n",
		    DEVNAME(sc), sc->sched_base, base));
a1950 3
	DPRINTFN(10, ("%s(%d): [PHYDB]SET: Type %d , Size: %d, data: %p\n",
	    __func__, __LINE__, type, size, entry->data));

a2040 3
	DPRINTFN(10, ("%s(%d): [PHYDB] GET: Type %d , Size: %d\n",
		       __func__, __LINE__, type, *size));

a2053 2
	DPRINTFN(10, ("Sending PHY-DB hcmd of type %d, of length %d\n", type, length));

d2086 1
a2086 3
		if (err) {
			DPRINTF(("%s: Can't SEND phy_db section %d (%d), "
			    "err %d\n", DEVNAME(sc), type, i, err));
a2087 1
		}
a2089 1
		DPRINTFN(10, ("Sent PHY_DB HCMD, type = %d num = %d\n", type, i));
a2101 2
	DPRINTF(("Sending phy db data and configuration to runtime image\n"));

d2104 1
a2104 3
	if (err) {
		DPRINTF(("%s: Cannot get Phy DB cfg section, %d\n",
		    DEVNAME(sc), err));
a2105 1
	}
d2108 1
a2108 3
	if (err) {
		DPRINTF(("%s: Cannot send HCMD of Phy DB cfg section, %d\n",
		    DEVNAME(sc), err));
a2109 1
	}
d2113 1
a2113 3
	if (err) {
		DPRINTF(("%s: Cannot get Phy DB non specific channel section, "
		    "%d\n", DEVNAME(sc), err));
a2114 1
	}
d2117 1
a2117 3
	if (err) {
		DPRINTF(("%s: Cannot send HCMD of Phy DB non specific channel "
		    "sect, %d\n", DEVNAME(sc), err));
a2118 1
	}
d2123 1
a2123 3
	if (err) {
		DPRINTF(("%s: Cannot send channel specific PAPD groups, %d\n",
		    DEVNAME(sc), err));
a2124 1
	}
d2129 1
a2129 3
	if (err) {
		DPRINTF(("%s: Cannot send channel specific TX power groups, "
		    "%d\n", DEVNAME(sc), err));
a2130 1
	}
a2131 1
	DPRINTF(("Finished sending phy db non channel data\n"));
d2207 1
a2207 11
	int ret;

	DPRINTF(("Add new TE, duration %d TU\n", le32toh(te_cmd->duration)));

	ret = iwm_mvm_send_time_event_cmd(sc, te_cmd);
	if (ret) {
		DPRINTF(("%s: Couldn't send IWM_TIME_EVENT_CMD: %d\n",
		    DEVNAME(sc), ret));
	}

	return ret;
d2292 1
a2292 3
	if (ret) {
		DPRINTF(("%s: Could not send NVM_ACCESS command (error=%d)\n",
		    DEVNAME(sc), ret));
a2293 1
	}
a2296 2
		DPRINTF(("%s: Bad return from IWM_NVM_ACCES_COMMAND (0x%08X)\n",
		    DEVNAME(sc), pkt->hdr.flags));
a2308 2
		DPRINTF(("%s: NVM access command failed with status %d\n",
		    DEVNAME(sc), ret));
a2313 2
		DPRINTF(("%s: NVM ACCESS response with invalid offset %d\n",
		    DEVNAME(sc), offset_read));
a2318 3
		DPRINTF(("%s: NVM ACCESS response with too much data "
		"(%d bytes requested, %zd bytes received)\n",
		DEVNAME(sc), length, bytes_read));
a2347 2
	DPRINTFN(2, ("%s: reading NVM section %d\n", DEVNAME(sc), section));

d2355 1
a2355 3
		if (error) {
			DPRINTF(("%s: Cannot read from NVM section "
			    "%d at offset %d\n", DEVNAME(sc), section, *len));
d2357 1
a2357 1
		}
a2360 2
	DPRINTFN(2, ("%s: NVM section %d read completed (%d bytes, error=%d)\n",
	    DEVNAME(sc), section, *len, error));
d2505 1
a2505 6
		if (!(ch_flags & IWM_NVM_CHANNEL_VALID)) {
			DPRINTF(("Ch. %d Flags %x [%sGHz] - No traffic\n",
			    nvm_channels[ch_idx],
			    ch_flags,
			    (ch_idx >= IWM_NUM_2GHZ_CHANNELS) ?
			    "5.2" : "2.4"));
a2506 1
		}
a2592 2
		DPRINTF(("RX BA Session %sed in fw\n",
		    start ? "start" : "stopp"));
a2602 1
		DPRINTF(("RX BA Session refused by fw\n"));
a2605 2
		DPRINTF(("RX BA Session failed %sing, status 0x%x\n",
		    start ? "start" : "stopp", status));
a2718 3

		DPRINTF(("%s: mac address from nvm override section invalid\n",
		    DEVNAME(sc)));
a2822 2
			DPRINTF(("%s: Can't parse empty OTP/NVM sections\n",
			    DEVNAME(sc)));
a2830 2
			DPRINTF(("%s: Can't parse empty OTP/NVM sections\n",
			    DEVNAME(sc)));
a2835 2
			DPRINTF(("%s: Can't parse mac_address, empty "
			    "sections\n", DEVNAME(sc)));
a2840 2
			DPRINTF(("%s: Can't parse phy_sku in B0, empty "
			    "sections\n", DEVNAME(sc)));
a3017 2
		DPRINTFN(4, ("LOAD FIRMWARE type %d offset %u len %d\n",
		    ucode_type, offset, dlen));
a3018 1
			DPRINTF(("chunk %d too large (%d bytes)\n", i, dlen));
a3068 3
		DPRINTFN(4, ("LOAD FIRMWARE chunk %d offset 0x%x len %d "
		    "for cpu %d\n", i, offset, dlen, cpu));

a3069 1
			DPRINTF(("chunk %d too large (%d bytes)\n", i, dlen));
a3113 2
	DPRINTF(("%s: loading ucode type %d\n", DEVNAME(sc), ucode_type));

d3146 1
a3146 1
	if (error || !sc->sc_uc.uc_ok) {
a3147 7
		if (sc->sc_device_family == IWM_DEVICE_FAMILY_8000) {
			DPRINTF(("%s: cpu1 status: 0x%x\n", DEVNAME(sc),
			    iwm_read_prph(sc, IWM_SB_CPU_1_STATUS)));
			DPRINTF(("%s: cpu2 status: 0x%x\n", DEVNAME(sc),
			    iwm_read_prph(sc, IWM_SB_CPU_2_STATUS)));
		}
	}
a3211 1
	DPRINTFN(10, ("Sending Phy CFG command: 0x%x\n", phy_cfg_cmd.phy_cfg));
d3272 2
a3273 3
	if ((error = iwm_send_bt_init_conf(sc)) != 0) {
		DPRINTF(("%s: failed to send bt coex configuration: %d\n",
		    DEVNAME(sc), error));
a3274 1
	}
d3282 2
a3283 3
	if ((error = iwm_send_tx_ant_cfg(sc, iwm_fw_valid_tx_ant(sc))) != 0) {
		DPRINTF(("%s: failed to send antennas before calibration: %d\n",
		    DEVNAME(sc), error));
a3284 1
	}
d3290 2
a3291 3
	if ((error = iwm_send_phy_cfg_cmd(sc)) != 0 ) {
		DPRINTF(("%s: failed to run internal calibration: %d\n",
		    DEVNAME(sc), error));
a3292 1
	}
a3302 3
	DPRINTF(("%s: init %scomplete\n", DEVNAME(sc),
	    sc->sc_init_complete ? "" : "not "));

a3382 3
	DPRINTF(("Rssi In A %d B %d Max %d AGCA %d AGCB %d\n",
	    rssi_a_dbm, rssi_b_dbm, max_rssi_dbm, agc_a, agc_b));

a3411 3
	DPRINTFN(12, ("energy In A %d B %d C %d , and max %d\n",
	    energy_a, energy_b, energy_c, max_energy));

a3420 1
	DPRINTFN(20, ("received PHY stats\n"));
d3484 1
a3484 3
	if (__predict_false(phy_info->cfg_phy_cnt > 20)) {
		DPRINTF(("dsp size out of range [0,20]: %d\n",
		    phy_info->cfg_phy_cnt));
a3485 1
	}
d3488 1
a3488 2
	    !(rx_pkt_status & IWM_RX_MPDU_RES_STATUS_OVERRUN_OK)) {
		DPRINTF(("Bad CRC or FIFO: 0x%08X.\n", rx_pkt_status));
a3489 1
	}
d3612 1
a3612 3
	if (txd->done) {
		DPRINTF(("%s: got tx interrupt that's already been handled!\n",
		    DEVNAME(sc)));
a3613 1
	}
a3627 1
	DPRINTFN(8, ("free txd %p, in %p\n", txd, txd->in));
d3672 1
a3672 3
	if (ret) {
		DPRINTF(("%s: Failed to send binding (action:%d): %d\n",
		    DEVNAME(sc), action, ret));
a3673 1
	}
d3675 1
a3675 3
	if (status) {
		DPRINTF(("%s: Binding command failed: %u\n", DEVNAME(sc),
		    status));
a3676 1
	}
a3751 1
	int ret;
d3760 1
a3760 1
	ret = iwm_mvm_send_cmd_pdu(sc, IWM_PHY_CONTEXT_CMD, 0,
a3761 4
	if (ret) {
		DPRINTF(("PHY ctxt cmd error. ret=%d\n", ret));
	}
	return ret;
a3833 1
		DPRINTFN(12, ("wantresp is %x\n", sc->sc_wantresp));
a3919 4
	DPRINTFN(8, ("iwm_send_cmd 0x%x size=%lu %s\n",
	    code, hcmd->len[0] + hcmd->len[1] + hdrlen,
	    async ? " (async)" : ""));

a3945 3
	DPRINTF(("sending command 0x%x qid %d, idx %d\n",
	    code, ring->qid, ring->cur));

a4143 1
		DPRINTFN(12, ("start with txrate %d\n", tx->initial_rate_index));
a4202 4
	if (hdrlen != hdrlen2)
		DPRINTF(("%s: hdrlen error (%d != %d)\n",
		    DEVNAME(sc), hdrlen, hdrlen2));

a4344 6
	DPRINTFN(8, ("sending txd %p, in %p\n", data, data->in));
	KASSERT(data->in != NULL);

	DPRINTFN(8, ("sending data: qid=%d idx=%d len=%d nsegs=%d\n",
	    ring->qid, ring->cur, totlen, data->map->dm_nsegs));

d4462 1
a4462 3
	int ret;

	ret = iwm_mvm_send_cmd_pdu(sc, IWM_REPLY_BEACON_FILTERING_CMD,
a4463 26

	if (!ret) {
		DPRINTF(("ba_enable_beacon_abort is: %d\n",
		    le32toh(cmd->ba_enable_beacon_abort)));
		DPRINTF(("ba_escape_timer is: %d\n",
		    le32toh(cmd->ba_escape_timer)));
		DPRINTF(("bf_debug_flag is: %d\n",
		    le32toh(cmd->bf_debug_flag)));
		DPRINTF(("bf_enable_beacon_filter is: %d\n",
		    le32toh(cmd->bf_enable_beacon_filter)));
		DPRINTF(("bf_energy_delta is: %d\n",
		    le32toh(cmd->bf_energy_delta)));
		DPRINTF(("bf_escape_timer is: %d\n",
		    le32toh(cmd->bf_escape_timer)));
		DPRINTF(("bf_roaming_energy_delta is: %d\n",
		    le32toh(cmd->bf_roaming_energy_delta)));
		DPRINTF(("bf_roaming_state is: %d\n",
		    le32toh(cmd->bf_roaming_state)));
		DPRINTF(("bf_temp_threshold is: %d\n",
		    le32toh(cmd->bf_temp_threshold)));
		DPRINTF(("bf_temp_fast_filter is: %d\n",
		    le32toh(cmd->bf_temp_fast_filter)));
		DPRINTF(("bf_temp_slow_filter is: %d\n",
		    le32toh(cmd->bf_temp_slow_filter)));
	}
	return ret;
a4491 14
iwm_mvm_power_log(struct iwm_softc *sc, struct iwm_mac_power_cmd *cmd)
{
	DPRINTF(("Sending power table command on mac id 0x%X for "
	    "power level %d, flags = 0x%X\n",
	    cmd->id_and_color, IWM_POWER_SCHEME_CAM, le16toh(cmd->flags)));
	DPRINTF(("Keep alive = %u sec\n", le16toh(cmd->keep_alive_seconds)));

	if (!(cmd->flags & htole16(IWM_POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK))) {
		DPRINTF(("Disable power management\n"));
		return;
	}
}

void
a4526 1
	iwm_mvm_power_log(sc, &cmd);
a4547 1
	DPRINTF(("Sending device power command with flags = 0x%X\n", cmd.flags));
a4656 1
		DPRINTF(("IWM_ADD_STA failed\n"));
a4699 1
		DPRINTF(("Internal station added.\n"));
a4701 2
		DPRINTF(("%s: Add internal station failed, status=0x%x\n",
		    DEVNAME(sc), status));
a4993 2
	DPRINTF(("Handling ieee80211 scan request\n"));

a5068 2
	if (!ret)
		DPRINTF(("Scan request was sent successfully\n"));
a5142 2
	DPRINTF(("Sending UMAC scan config\n"));

a5143 3
	if (!ret)
		DPRINTF(("UMAC scan config was sent successfully\n"));

a5175 2
	DPRINTF(("Handling ieee80211 scan request\n"));

a5225 2
	if (!ret)
		DPRINTF(("Scan request was sent successfully\n"));
a5370 1
			DPRINTF(("Unknown protection mode %d\n", htprot));
d5385 1
a5385 1
	int ret = iwm_mvm_send_cmd_pdu(sc, IWM_MAC_CONTEXT_CMD, 0,
a5386 4
	if (ret)
		DPRINTF(("%s: Failed to send MAC context (action:%d): %d\n",
		    DEVNAME(sc), le32toh(cmd->action), ret));
	return ret;
d5494 1
a5494 1
	int i, idx, ret, num_active_macs, quota, quota_rem;
d5549 1
a5549 1
	ret = iwm_mvm_send_cmd_pdu(sc, IWM_TIME_QUOTA_CMD, 0,
a5550 3
	if (ret)
		DPRINTF(("%s: Failed to send quota: %d\n", DEVNAME(sc), ret));
	return ret;
d5576 1
a5576 1
	if (error)
d5579 3
a5581 3
	if ((error = iwm_mvm_phy_ctxt_changed(sc, &sc->sc_phyctxt[0],
	    in->in_ni.ni_chan, 1, 1)) != 0) {
		DPRINTF(("%s: failed add phy ctxt\n", DEVNAME(sc)));
a5582 1
	}
d5585 2
a5586 2
	if ((error = iwm_mvm_binding_add_vif(sc, in)) != 0) {
		DPRINTF(("%s: binding cmd\n", DEVNAME(sc)));
a5587 1
	}
d5589 2
a5590 2
	if ((error = iwm_mvm_add_sta(sc, in)) != 0) {
		DPRINTF(("%s: failed to add STA\n", DEVNAME(sc)));
a5591 1
	}
d5593 2
a5594 1
	if ((error = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) {
d5618 2
a5619 2
	if ((error = iwm_mvm_update_sta(sc, in)) != 0) {
		DPRINTF(("%s: failed to update STA\n", DEVNAME(sc)));
a5620 1
	}
a5810 1
		DPRINTFN(2, ("station rate %d %x\n", j, tab));
d5831 1
a5831 3
	if (iwm_send_cmd(sc, &cmd) != 0) {
		DPRINTF(("%s: IWM_LQ_CMD failed\n", DEVNAME(sc)));
	}
a5907 1
			DPRINTF(("Force transition to INIT; MGT=%d\n", arg));
a5909 1
			DPRINTF(("Going INIT->SCAN\n"));
d5936 2
a5937 3
		if ((error = iwm_auth(sc)) != 0) {
			DPRINTF(("%s: could not move to auth state: %d\n",
			    DEVNAME(sc), error));
a5938 1
		}
d5943 2
a5944 3
		if ((error = iwm_assoc(sc)) != 0) {
			DPRINTF(("%s: failed to associate: %d\n", DEVNAME(sc),
			    error));
a5945 1
		}
a6001 2
	DPRINTF(("scan ended\n"));

a6130 2
		DPRINTF(("Invalid state: %d. not sending Smart Fifo cmd\n",
			  new_state));
a6183 3
	DPRINTF(("send MCC update to FW with '%c%c' src = %d\n",
	    alpha2[0], alpha2[1], mcc_cmd.source_id));

d6223 1
a6223 3
	if (iwm_send_cmd(sc, &cmd) != 0)
		DPRINTF(("%s: failed to change thermal tx backoff\n",
		    DEVNAME(sc)));
a6909 2
		DPRINTFN(12, ("rx packet qid=%d idx=%d type=%x %d %d\n",
		    pkt->hdr.qid & ~0x80, pkt->hdr.idx, code, sc->rxq.cur, hw));
a7025 2
			DPRINTF(("%s: fw source %d sent CC '%s'\n",
			    DEVNAME(sc), notif->source_id, sc->sc_fw_mcc));
a7084 2
			DPRINTF(("UMAC scan complete, status=0x%x\n",
			    notif->status));
a7092 3
			DPRINTF(("UMAC scan iteration complete, status=0x%x, "
			"%d channels scanned\n",
			    notif->status, notif->scanned_channels));
a7109 2
			DPRINTF(("%s: TE notif status = 0x%x action = 0x%x\n",
			    DEVNAME(sc), notif->status, notif->action));
d7118 1
a7118 5
			
			DPRINTF(("%s: queue cfg token=0x%x sta_id=%d "
			    "tid=%d scd_queue=%d\n",
			    DEVNAME(sc), rsp->token, rsp->sta_id, rsp->tid,
			    rsp->scd_queue));
a7264 2
			DPRINTF(("%s: rfkill switch, disabling interface\n",
			    DEVNAME(sc)));
a7296 2
	if (__predict_false(r1 & ~handled))
		DPRINTF(("%s: unhandled interrupts: %x\n", DEVNAME(sc), r1));
@


1.109
log
@fix some whitespace and overlong lines
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.108 2016/09/03 13:35:07 stsp Exp $	*/
a267 1
void	iwm_set_pwr(struct iwm_softc *);
a1625 7
iwm_set_pwr(struct iwm_softc *sc)
{
	iwm_set_bits_mask_prph(sc, IWM_APMG_PS_CTRL_REG,
	    IWM_APMG_PS_CTRL_VAL_PWR_SRC_VMAIN, ~IWM_APMG_PS_CTRL_MSK_PWR_SRC);
}

void
d1759 3
a1761 1
		iwm_set_pwr(sc);
@


1.108
log
@Remove iwm_alloc_* wrapper functions around iwm_dma_contig_alloc().
Call iwm_dma_contig_alloc() directly instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.107 2016/09/03 12:24:21 stsp Exp $	*/
d1174 1
a1174 1
		printf("%s: could not allocate TX cmd DMA memory\n", DEVNAME(sc));
d1199 2
a1200 1
			printf("%s: could not create TX buf DMA map\n", DEVNAME(sc));
a1569 1

d1813 3
a1815 1
		iwm_write_mem32(sc, sc->sched_base + IWM_SCD_CONTEXT_QUEUE_OFFSET(qid), 0);
d1822 2
a1823 1
		    ((IWM_FRAME_LIMIT << IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &
d3542 2
a3543 1
iwm_mvm_get_signal_strength(struct iwm_softc *sc, struct iwm_rx_phy_info *phy_info)
d3630 2
a3631 1
	rx_pkt_status = le32toh(*(uint32_t *)(pkt->data + sizeof(*rx_res) + len));
d7582 2
a7583 1
	if ((r1 & (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX)) || isperiodic) {
d7590 2
a7591 1
		if (r1 & (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX) && !isperiodic)
@


1.107
log
@Get rid of the various iwm_free_* wrappers around iwm_dma_contig_free().
Call iwm_dma_contig_free() directly instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.106 2016/09/03 11:42:12 stsp Exp $	*/
a246 4
int	iwm_alloc_fwmem(struct iwm_softc *);
int	iwm_alloc_sched(struct iwm_softc *);
int	iwm_alloc_kw(struct iwm_softc *);
int	iwm_alloc_ict(struct iwm_softc *);
a1036 36
/* fwmem is used to load firmware onto the card */
int
iwm_alloc_fwmem(struct iwm_softc *sc)
{
	/* Must be aligned on a 16-byte boundary. */
	return iwm_dma_contig_alloc(sc->sc_dmat, &sc->fw_dma,
	    sc->sc_fwdmasegsz, 16);
}

/* tx scheduler rings.  not used? */
int
iwm_alloc_sched(struct iwm_softc *sc)
{
	int rv;

	/* TX scheduler rings must be aligned on a 1KB boundary. */
	rv = iwm_dma_contig_alloc(sc->sc_dmat, &sc->sched_dma,
	    nitems(sc->txq) * sizeof(struct iwm_agn_scd_bc_tbl), 1024);
	return rv;
}

/* keep-warm page is used internally by the card.  see iwl-fh.h for more info */
int
iwm_alloc_kw(struct iwm_softc *sc)
{
	return iwm_dma_contig_alloc(sc->sc_dmat, &sc->kw_dma, 4096, 4096);
}

/* interrupt cause table */
int
iwm_alloc_ict(struct iwm_softc *sc)
{
	return iwm_dma_contig_alloc(sc->sc_dmat, &sc->ict_dma,
	    IWM_ICT_SIZE, 1<<IWM_ICT_PADDR_SHIFT);
}

d1330 1
a1330 1
	/* Reset ICT table. */
d1334 1
a1334 1
	/* Set physical address of ICT table (4KB aligned). */
a1565 2

	/* device going down, Stop using ICT table */
d7865 7
a7871 2
	/* Allocate DMA memory for firmware transfers. */
	if ((error = iwm_alloc_fwmem(sc)) != 0) {
d7877 3
a7879 2
	/* Allocate "Keep Warm" page. */
	if ((error = iwm_alloc_kw(sc)) != 0) {
d7884 4
a7887 2
	/* We use ICT interrupts */
	if ((error = iwm_alloc_ict(sc)) != 0) {
d7893 5
a7897 1
	if ((error = iwm_alloc_sched(sc)) != 0) {
@


1.106
log
@Get rid of iwm_mvm_send_add_sta_cmd_status() which is a pointless wrapper
around iwm_mvm_send_cmd_pdu_status(). Just call the function directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.105 2016/09/03 10:33:15 stsp Exp $	*/
a247 1
void	iwm_free_fwmem(struct iwm_softc *);
a248 1
void	iwm_free_sched(struct iwm_softc *);
a249 1
void	iwm_free_kw(struct iwm_softc *);
a250 1
void	iwm_free_ict(struct iwm_softc *);
a1049 6
void
iwm_free_fwmem(struct iwm_softc *sc)
{
	iwm_dma_contig_free(&sc->fw_dma);
}

a1061 6
void
iwm_free_sched(struct iwm_softc *sc)
{
	iwm_dma_contig_free(&sc->sched_dma);
}

a1068 6
void
iwm_free_kw(struct iwm_softc *sc)
{
	iwm_dma_contig_free(&sc->kw_dma);
}

a1076 6
void
iwm_free_ict(struct iwm_softc *sc)
{
	iwm_dma_contig_free(&sc->ict_dma);
}

d8041 1
a8041 1
	iwm_free_sched(sc);
d8043 4
a8046 3
		iwm_free_ict(sc);
fail2:	iwm_free_kw(sc);
fail1:	iwm_free_fwmem(sc);
@


1.105
log
@Use macros for iwm(4) bitmask definitions instead of enums.
ok mpi benno
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.104 2016/09/02 17:10:25 stsp Exp $	*/
a407 2
int	iwm_mvm_send_add_sta_cmd_status(struct iwm_softc *,
					struct iwm_mvm_add_sta_cmd_v7 *, int *);
d2757 2
a2758 1
	ret = iwm_mvm_send_add_sta_cmd_status(sc, &cmd, &status);
a4888 8
int
iwm_mvm_send_add_sta_cmd_status(struct iwm_softc *sc,
	struct iwm_mvm_add_sta_cmd_v7 *cmd, int *status)
{
	return iwm_mvm_send_cmd_pdu_status(sc, IWM_ADD_STA, sizeof(*cmd),
	    cmd, status);
}

d4948 2
a4949 1
	ret = iwm_mvm_send_add_sta_cmd_status(sc, &add_sta_cmd, &status);
d4995 2
a4996 1
	ret = iwm_mvm_send_add_sta_cmd_status(sc, &cmd, &status);
@


1.104
log
@Enable SGI for iwm(4).
The maximum 11n data rate should go up from 65Mbit/s to 72Mbit/s.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.103 2016/09/02 15:47:32 stsp Exp $	*/
d283 2
a284 2
struct iwm_phy_db_entry *iwm_phy_db_get_section(struct iwm_softc *,
					enum iwm_phy_db_section_type, uint16_t);
d295 1
a295 1
		enum iwm_phy_db_section_type, uint8_t);
d452 1
a452 1
int	iwm_mvm_sf_config(struct iwm_softc *, enum iwm_sf_state);
d571 1
a571 1
	enum iwm_ucode_tlv_type tlv_type;
d644 1
a644 1
		switch ((int)tlv_type) {
d2004 1
a2004 2
iwm_phy_db_get_section(struct iwm_softc *sc,
	enum iwm_phy_db_section_type type, uint16_t chg_id)
d2034 1
a2034 1
	enum iwm_phy_db_section_type type = le16toh(phy_db_notif->type);
d2183 1
a2183 1
	enum iwm_phy_db_section_type type, uint8_t max_ch_groups)
d6458 1
a6458 1
iwm_mvm_sf_config(struct iwm_softc *sc, enum iwm_sf_state new_state)
@


1.103
log
@The policy field in struct iwm_time_event_cmd_v2 is just a 16bit integer,
so we should use htole16() when setting it, instead of htole32().
Patch by Imre Vadasz
ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.102 2016/09/02 15:47:01 stsp Exp $	*/
d6085 1
a6085 1
	int i, ridx, ridx_min, j, tab = 0;
d6095 2
a6096 2
	/* For HT, always enable RTS/CTS to avoid excessive retries. */
	if (ni->ni_flags & IEEE80211_NODE_HT)
d6098 3
d6126 2
d8008 1
a8008 2
	/* No optional HT features supported for now, */
	ic->ic_htcaps = 0;
@


1.102
log
@Fix off-by-one error in the IWM_NUM_UCODE_TLV_CAPA range check.
Patch by Imre Vadasz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.101 2016/09/02 15:45:41 stsp Exp $	*/
d2382 1
a2382 1
	    = htole32(IWM_TE_V2_NOTIF_HOST_EVENT_START |
@


1.101
log
@The iwm_poll_bit() function in iwm(4) returns 1 on success, and 0 on failure.
So instead of "if (ret < 0) {" we should check for "if (!ret) {".
Patch by Imre Vadasz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.100 2016/09/01 09:47:47 stsp Exp $	*/
d761 1
a761 1
			if (idx > howmany(IWM_NUM_UCODE_TLV_CAPA, 32)) {
@


1.100
log
@Always initialize error code returned from iwm_firmware_load_chunk().
Patch by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.99 2016/08/17 09:39:38 stsp Exp $	*/
d7917 1
a7917 1
		if (ret < 0) {
@


1.99
log
@If the stack demands protection by setting the USEPROT flag then set the
corresponding bit in the iwm(4) Tx command regardless of frame length.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.98 2016/08/15 12:59:53 stsp Exp $	*/
d3172 1
@


1.98
log
@Remove IWM_CMD_SYNC, which expands to zero while all the other
IWM_CMD_* values are bit flags. The same was done 2 years ago
in Linux git commit a10229271946731959b2269370d0492d88cfab23.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.97 2016/08/07 23:06:39 stsp Exp $	*/
d4518 4
a4521 3
	if (type == IEEE80211_FC0_TYPE_DATA
	    && (totlen + IEEE80211_CRC_LEN > ic->ic_rtsthreshold)
	    && !IEEE80211_IS_MULTICAST(wh->i_addr1)) {
a4522 1
	}
@


1.97
log
@Make iwm(4) automagically recover from fatal firmware errors by leaving the
interface marked UP and scheduling the init task. Matches iwn(4) behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.96 2016/07/20 18:24:38 stsp Exp $	*/
d1914 1
a1914 1
		error = iwm_mvm_send_cmd_pdu(sc, IWM_SCD_QUEUE_CFG, IWM_CMD_SYNC,
d2336 1
a2336 1
		    IWM_CMD_SYNC, sizeof(*cmd), cmd);
d2339 1
a2339 1
	return iwm_mvm_send_cmd_pdu(sc, IWM_TIME_EVENT_CMD, IWM_CMD_SYNC,
d2432 1
a2432 2
		.flags = IWM_CMD_SYNC | IWM_CMD_WANT_SKB |
		    IWM_CMD_SEND_IN_RFKILL,
d3400 1
a3400 1
	    IWM_CMD_SYNC, sizeof(tx_ant_cmd), &tx_ant_cmd);
d3417 1
a3417 1
	return iwm_mvm_send_cmd_pdu(sc, IWM_PHY_CONFIGURATION_CMD, IWM_CMD_SYNC,
d3995 1
a3995 1
	ret = iwm_mvm_send_cmd_pdu(sc, IWM_PHY_CONTEXT_CMD, IWM_CMD_SYNC,
d4242 1
a4242 1
	cmd->flags |= IWM_CMD_SYNC | IWM_CMD_WANT_SKB;
d4289 1
a4289 2
	KASSERT((hcmd->flags & (IWM_CMD_WANT_SKB|IWM_CMD_SYNC))
	    == (IWM_CMD_WANT_SKB|IWM_CMD_SYNC));
d4660 1
a4660 1
	    sync ? IWM_CMD_SYNC : IWM_CMD_ASYNC,
d4723 1
a4723 1
	    IWM_CMD_SYNC, sizeof(struct iwm_beacon_filter_cmd), cmd);
d4830 1
a4830 1
	    IWM_CMD_SYNC, sizeof(cmd), &cmd)) != 0)
d4852 1
a4852 1
	    IWM_POWER_TABLE_CMD, IWM_CMD_SYNC, sizeof(cmd), &cmd);
d5288 1
a5288 1
		.flags = IWM_CMD_SYNC,
d5399 1
a5399 1
		.flags = IWM_CMD_SYNC,
d5477 1
a5477 1
		.flags = IWM_CMD_SYNC,
d5711 1
a5711 1
	int ret = iwm_mvm_send_cmd_pdu(sc, IWM_MAC_CONTEXT_CMD, IWM_CMD_SYNC,
d5809 1
a5809 1
	    IWM_MAC_CONTEXT_CMD, IWM_CMD_SYNC, sizeof(cmd), &cmd);
d5879 1
a5879 1
	ret = iwm_mvm_send_cmd_pdu(sc, IWM_TIME_QUOTA_CMD, IWM_CMD_SYNC,
d6088 1
a6088 1
		.flags = IWM_CMD_SYNC,
d6501 1
a6501 1
		.flags = (IWM_CMD_SYNC | IWM_CMD_WANT_SKB),
d6735 1
a6735 1
	    IWM_CMD_SYNC, size, cmd);
@


1.96
log
@Disable the beacon filter in iwm(4). This allows beacons to pass through to
the stack while associated, which in turn makes it possible to keep track of
HT protection changes.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.95 2016/07/18 13:10:35 stsp Exp $	*/
a7602 1
		ifp->if_flags &= ~IFF_UP;
d7604 1
@


1.95
log
@Explicitly set iwm(4) firmware Tx aggregation limit to one (which disables
Tx aggregation), instead of the maximum (63 frames). Tx aggregation should
already be disabled, so this change should be a no-op. It just avoids any
side effects in case the firmware happens to interpret the limit we set here.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.94 2016/07/18 13:09:58 stsp Exp $	*/
d6293 6
d6300 1
@


1.94
log
@Fix inverted logic in iwm_tx(). The PROT_REQUIRE flag in should be set for
data frames above a certain length, but we were setting it for !data frames
above a certain length, which makes no sense at all. Found while comparing
our driver's Tx code to iwlwifi.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.93 2016/07/18 13:09:08 stsp Exp $	*/
d6158 1
d6160 3
@


1.93
log
@Make iwm(4) retry Tx of management frames less often. We now retry management
frames the same number of times as Linux iwlwifi does.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.92 2016/06/22 11:32:12 stsp Exp $	*/
d4520 1
a4520 1
	if (type != IEEE80211_FC0_TYPE_DATA
@


1.92
log
@In iwm(4), clear the in_assoc flag when going down. This flag affects behaviour
early during startup, e.g. where the BSSID for the MAC context is copied from.
Pointed out by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.91 2016/06/22 11:30:00 stsp Exp $	*/
d4384 1
@


1.91
log
@Remove code from iwm(4) which sends DTIM and TSF information to the
firmware based on information from the wireless stack. Letting the
firmware deal with these details by itself seems to work better.
Fixes association issues with 8260 hardware for me and Bryan Vyhmeister.
Also tested by jcs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.90 2016/06/22 11:28:27 stsp Exp $	*/
d6840 1
d6848 3
@


1.90
log
@Make iwm(4) explicitly send multicast frames at the lowest rate, instead of
picking a rate from the firmware RS table. This matches what other drivers do.
Also, pass the correct Tx rate to BPF (tcpdump) for 5GHz, and don't loop over
CCK rates when building the Link-Quality command's RS table for 5GHz.
tested by myself and jcs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.89 2016/06/20 11:54:36 stsp Exp $	*/
a5727 1
	unsigned dtim_period, dtim_count;
d5730 1
a5730 44
	/* will this work? */
	dtim_period = ic->ic_dtim_period;
	dtim_count = ic->ic_dtim_count;
	DPRINTF(("dtim %d %d\n", dtim_period, dtim_count));

	/* We need the dtim_period to set the MAC as associated */
	if (in->in_assoc && dtim_period && !force_assoc_off) {
		uint64_t tsf;
		uint32_t dtim_offs;

		/*
		 * The DTIM count counts down, so when it is N that means N
		 * more beacon intervals happen until the DTIM TBTT. Therefore
		 * add this to the current time. If that ends up being in the
		 * future, the firmware will handle it.
		 *
		 * Also note that the system_timestamp (which we get here as
		 * "sync_device_ts") and TSF timestamp aren't at exactly the
		 * same offset in the frame -- the TSF is at the first symbol
		 * of the TSF, the system timestamp is at signal acquisition
		 * time. This means there's an offset between them of at most
		 * a few hundred microseconds (24 * 8 bits + PLCP time gives
		 * 384us in the longest case), this is currently not relevant
		 * as the firmware wakes up around 2ms before the TBTT.
		 */
		dtim_offs = dtim_count * ni->ni_intval;
		/* convert TU to usecs */
		dtim_offs *= 1024;

		/* XXX: byte order? */
		memcpy(&tsf, ni->ni_tstamp, sizeof(tsf));

		ctxt_sta->dtim_tsf = htole64(tsf + dtim_offs);
		ctxt_sta->dtim_time = htole64(ni->ni_rstamp + dtim_offs);

		DPRINTF(("DTIM TBTT is 0x%llx/0x%x, offset %d\n",
		    (long long)le64toh(ctxt_sta->dtim_tsf),
		    le32toh(ctxt_sta->dtim_time), dtim_offs));

		ctxt_sta->is_assoc = htole32(1);
	} else {
		ctxt_sta->is_assoc = htole32(0);
	}

d5733 1
a5733 1
	ctxt_sta->dtim_interval = htole32(ni->ni_intval * dtim_period);
d5735 1
a5735 1
	    htole32(iwm_mvm_reciprocal(ni->ni_intval * dtim_period));
@


1.89
log
@In iwm(4), send PHY DB commands as async commands.

This means we won't sleep and wait for the firmware to send an interrupt
when it's done processing the command. For unknown reasons, sometimes the
firmware never wakes the driver after a phy db command so the driver gives
up partway through the hardware init sequence.

We already have a DELAY in place after each phy db command we send to give
the firmware some time for processing, so skipping the sleep is not expected
to cause problems. If it does, we'll have to revisit this change.
For now, this change makes iwm(4) work better in bsd.rd.

Problem reported by Remi Locherer on bugs@@, and confirmed by kettenis@@.
Lots of help with testing and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.88 2016/06/19 12:05:25 stsp Exp $	*/
d4379 2
a4380 1
	if (type != IEEE80211_FC0_TYPE_DATA) {
d4397 2
a4398 1
		ridx = 0;
d6129 1
a6129 1
	int i, ridx, j, tab = 0;
d6153 3
a6155 1
	for (ridx = IWM_RIDX_MAX; ridx >= 0; ridx--) {
@


1.88
log
@Make some noise in dmesg when iwm(4) fails to bring up the hardware.
ok tb@@ earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.87 2016/06/18 07:49:24 stsp Exp $	*/
d2164 1
a2164 1
		.flags = IWM_CMD_SYNC,
@


1.87
log
@Plug some memory leaks in error paths of iwm(4).
Patch by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.86 2016/06/03 16:16:25 stsp Exp $	*/
d3178 2
a3179 2
		DPRINTF(("%s: fw chunk addr 0x%x len %d failed to load\n",
		    DEVNAME(sc), dst_addr, byte_cnt));
d4183 1
a4183 1
		DPRINTF(("%s: acquiring device failed\n", DEVNAME(sc)));
d6615 2
a6616 1
	if ((error = iwm_start_hw(sc)) != 0)
d6618 1
d6620 1
a6620 1
	if ((error = iwm_run_init_mvm_ucode(sc, 0)) != 0) {
a6621 1
	}
d6633 1
a6633 1
	/* omstart, this time with the regular firmware */
d6640 3
a6642 1
	if ((error = iwm_send_bt_init_conf(sc)) != 0)
d6644 1
d6646 3
a6648 1
	if ((error = iwm_send_tx_ant_cfg(sc, iwm_fw_valid_tx_ant(sc))) != 0)
d6650 1
d6653 3
a6655 1
	if ((error = iwm_send_phy_db_data(sc)) != 0)
d6657 1
d6659 3
a6661 1
	if ((error = iwm_send_phy_cfg_cmd(sc)) != 0)
d6663 1
d6666 3
a6668 1
	if ((error = iwm_mvm_add_aux_sta(sc)) != 0)
d6670 1
d6679 3
a6681 1
		    &sc->sc_phyctxt[i], &ic->ic_channels[1], 1, 1)) != 0)
d6683 1
d6691 3
a6693 1
	if (error)
d6695 1
d6698 3
a6700 1
		if ((error = iwm_send_update_mcc_cmd(sc, "ZZ")) != 0)
d6702 1
d6706 3
a6708 1
		if ((error = iwm_mvm_config_umac_scan(sc)) != 0)
d6710 1
d6717 3
a6719 1
		if (error)
d6721 1
d6726 2
a6727 1
		printf("%s: failed to add MAC\n", DEVNAME(sc));
d6732 2
a6733 1
		printf("%s: failed to disable beacon filter\n", DEVNAME(sc));
@


1.86
log
@In iwm(4), fix multicast Rx by updating the MAC context again after
sending multicast filter and STA settings during association.
Makes ARP and inet6 autoconf work again.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.85 2016/05/28 18:30:01 stsp Exp $	*/
d3088 8
a3095 2
	if (error)
		return error;
d3097 1
a3097 1
	return iwm_parse_nvm_sections(sc, nvm_sections);
d8064 1
@


1.85
log
@Add support for Intel Wireless 3165 devices to iwm(4).
Patch by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.84 2016/05/28 08:34:17 stsp Exp $	*/
d5996 5
@


1.84
log
@In iwm(4), don't parse nvram antenna data for 7k devices, they don't have it.
And don't complain if no data is provided in nvram, needed for 3165 devices.
Patch by Imre Vadasz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.83 2016/05/28 08:13:16 stsp Exp $	*/
d7662 2
d7827 7
@


1.83
log
@Add support for Intel Wireless 8260 devices to iwm(4).

Firmware has been available in fw_update(1) for some time (thanks sthen!).
Tested by robert, reyk, Imre Vadasz, Bryan Vyhmeister.
Thank you, Emmanuel Grumbach, for helping me diagnose issues during development.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.82 2016/05/25 13:35:12 stsp Exp $	*/
a2944 2
		data->valid_tx_ant = IWM_NVM_RF_CFG_TX_ANT_MSK(radio_cfg);
		data->valid_rx_ant = IWM_NVM_RF_CFG_RX_ANT_MSK(radio_cfg);
a2963 7

	if (!data->valid_tx_ant || !data->valid_rx_ant) {
		DPRINTF(("%s: invalid antennas (0x%x, 0x%x)\n",
			    DEVNAME(sc), data->valid_tx_ant,
			    data->valid_rx_ant));
		return EINVAL;
	}
@


1.82
log
@Update iwm(4) to firmware API 16 and enable RTS/CTS frame protection.

Requires new firmware! Which has been available in fw_update(1) for some time.

With helpful hints from Emmanuel Grumbach and contributions from Imre Vadasz.
Tested verbatim by phessler@@, jasper@@, gilles@@. Tested as part of a larger
diff by reyk@@, robert@@, Imre Vadasz, and Bryan Vyhmeister.
Earlier version tested by many. Also passed by kettenis@@ very early on.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.81 2016/05/18 07:28:01 stsp Exp $	*/
d171 10
d332 2
d341 3
d426 2
d465 1
d691 2
a692 1
		case IWM_UCODE_TLV_NUM_OF_CPU:
d697 2
a698 3
			if (le32toh(*(uint32_t*)tlv_data) != 1) {
				DPRINTF(("%s: driver supports "
				    "only TLV_NUM_OF_CPU == 1", DEVNAME(sc)));
d703 1
d934 3
d944 1
d1495 3
a1497 2
	IWM_SETBITS(sc, IWM_CSR_GIO_CHICKEN_BITS,
	    IWM_CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER);
d1518 1
a1518 1
#if 0 /* not for 7k */
d1574 13
a1586 12
	iwm_write_prph(sc, IWM_APMG_CLK_EN_REG, IWM_APMG_CLK_VAL_DMA_CLK_RQT);
	//kpause("iwmapm", 0, mstohz(20), NULL);
	DELAY(20);

	/* Disable L1-Active */
	iwm_set_bits_prph(sc, IWM_APMG_PCIDEV_STT_REG,
	    IWM_APMG_PCIDEV_STT_VAL_L1_ACT_DIS);

	/* Clear the interrupt in APMG if the NIC is in RFKILL */
	iwm_write_prph(sc, IWM_APMG_RTC_INT_STT_REG,
	    IWM_APMG_RTC_INT_STT_RFKILL);

d1739 4
a1742 3
	iwm_set_bits_mask_prph(sc, IWM_APMG_PS_CTRL_REG,
	    IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS,
	    ~IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS);
d1838 2
a1839 1
	iwm_set_pwr(sc);
d1990 3
a1992 2
	iwm_clear_bits_prph(sc, IWM_APMG_PCIDEV_STT_REG,
	    IWM_APMG_PCIDEV_STT_VAL_L1_ACT_DIS);
d2401 3
d2579 26
d2622 7
d2867 60
a2934 1
	uint16_t radio_cfg;
d2939 22
a2960 7
	radio_cfg = le16_to_cpup(nvm_sw + IWM_RADIO_CFG);
	data->radio_cfg_type = IWM_NVM_RF_CFG_TYPE_MSK(radio_cfg);
	data->radio_cfg_step = IWM_NVM_RF_CFG_STEP_MSK(radio_cfg);
	data->radio_cfg_dash = IWM_NVM_RF_CFG_DASH_MSK(radio_cfg);
	data->radio_cfg_pnum = IWM_NVM_RF_CFG_PNUM_MSK(radio_cfg);
	data->valid_tx_ant = IWM_NVM_RF_CFG_TX_ANT_MSK(radio_cfg);
	data->valid_rx_ant = IWM_NVM_RF_CFG_RX_ANT_MSK(radio_cfg);
a2961 1
	sku = le16_to_cpup(nvm_sw + IWM_SKU);
d2977 10
a2986 7
	memcpy(hw_addr, nvm_hw + IWM_HW_ADDR, ETHER_ADDR_LEN);
	data->hw_addr[0] = hw_addr[1];
	data->hw_addr[1] = hw_addr[0];
	data->hw_addr[2] = hw_addr[3];
	data->hw_addr[3] = hw_addr[2];
	data->hw_addr[4] = hw_addr[5];
	data->hw_addr[5] = hw_addr[4];
d2988 6
a2993 2
	iwm_init_channel_map(sc, &nvm_sw[IWM_NVM_CHANNELS],
	    iwm_nvm_channels, nitems(iwm_nvm_channels));
d3011 43
a3053 5
	if (!sections[IWM_NVM_SECTION_TYPE_SW].data ||
	    !sections[IWM_NVM_SECTION_TYPE_HW].data) {
		DPRINTF(("%s: Can't parse empty OTP/NVM sections\n",
		    DEVNAME(sc)));
		return ENOENT;
a3055 1
	hw = (const uint16_t *) sections[IWM_NVM_SECTION_TYPE_HW].data;
d3230 101
d3335 5
a3339 1
	error = iwm_load_firmware_7000(sc, ucode_type);
d3349 6
d5159 29
d5391 166
d6293 4
a6296 1
		error = iwm_mvm_lmac_scan(sc);
d6489 3
d6666 2
a6667 1
	iwm_mvm_tt_tx_backoff(sc, 0);
d6678 5
d7014 25
d7044 45
d7201 3
d7308 2
d7323 2
d7385 2
d7425 21
d7675 2
d7828 1
d7834 2
d7841 2
d7848 9
a7861 1
	sc->sc_fwdmasegsz = IWM_FWDMASEGSZ;
d7867 10
a7876 1
	sc->sc_hw_rev = IWM_READ(sc, IWM_CSR_HW_REV);
d7880 37
@


1.81
log
@Fix several nitpicks in iwm(4).

Move some declarations to if_iwmreg.h so we can use iwm_phy_db_* prototypes.
Remove redundant declaration of iwm_send_phy_db_data().
Remove pointless iwm_fw_alive(); just call iwm_post_alive() directly.
Simplify iwm_prepare_card_hw() and iwm_mvm_add_sta().
Return timeout error from iwm_apm_init().
Print a message when init (i.e. boot) firmware fails to load.
Remove some commented-out code which wouldn't compile anyway.
Move iwm_mvm_tx_fifo to if_iwmreg.h to match better where Linux puts it.

ok kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.80 2016/05/18 07:26:56 stsp Exp $	*/
d4 2
a5 1
 * Copyright (c) 2014 genua mbh <info@@genua.de>
a24 3
 * Driver version we are currently based off of is
 * Linux 3.14.3 (tag id a2df521e42b1d9a23f620ac79dbfe8655a8391dd)
 *
d33 2
d61 2
d134 1
d211 5
d271 1
a271 1
void	iwm_enable_txq(struct iwm_softc *, int, int);
d298 3
a300 2
				uint16_t *);
void	iwm_init_channel_map(struct iwm_softc *, const uint16_t * const);
d319 3
a321 3
				const uint16_t *, const uint16_t *, uint8_t,
				uint8_t);
#ifdef notyet
a322 1
#endif
d324 2
d328 1
d349 1
a349 1
int	iwm_mvm_binding_update(struct iwm_softc *, struct iwm_node *, int);
d392 1
a392 3
int	iwm_mvm_disable_beacon_filter(struct iwm_softc *, struct iwm_node *);
void	iwm_mvm_add_sta_cmd_v6_to_v5(struct iwm_mvm_add_sta_cmd_v6 *,
					struct iwm_mvm_add_sta_cmd_v5 *);
d394 1
a394 1
					struct iwm_mvm_add_sta_cmd_v6 *, int *);
a403 1
uint32_t iwm_mvm_scan_rxon_flags(struct iwm_softc *, int);
d407 4
a410 5
int	iwm_mvm_scan_fill_channels(struct iwm_softc *, struct iwm_scan_cmd *,
				int, int, int);
uint16_t iwm_mvm_fill_probe_req(struct iwm_softc *, struct ieee80211_frame *,
	const uint8_t *, int, const uint8_t *, int, const uint8_t *, int, int);
int	iwm_mvm_scan_request(struct iwm_softc *, int, int, uint8_t *, int);
d433 6
d581 6
d600 4
a603 1
	sc->sc_fwver = le32toh(uhdr->ver);
d635 2
a636 1
			if (sc->sc_capa_max_probe_len > (1<<16)) {
d716 42
a757 2
		case IWM_UCODE_TLV_API_CHANGES_SET:
		case IWM_UCODE_TLV_ENABLED_CAPABILITIES:
d761 28
d1385 1
d1400 2
d1405 1
a1405 1
	return iwm_poll_bit(sc, IWM_CSR_HW_IF_CONFIG_REG,
d1409 5
d1590 1
a1590 3
	IWM_WRITE(sc, IWM_CSR_RESET,
	    IWM_CSR_RESET_REG_FLAG_SW_RESET |
	    IWM_CSR_RESET_REG_FLAG_NEVO_RESET);
d1663 1
a1663 1
	IWM_WRITE(sc, IWM_CSR_RESET, IWM_CSR_RESET_REG_FLAG_NEVO_RESET);
a1745 6
	/*
	 * Note: Linux driver also sets this:
	 *  (IWM_RX_RB_TIMEOUT << IWM_FH_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS) |
	 *
	 * It causes weird behavior.  YMMV.
	 */
d1750 2
d1798 3
d1838 2
a1839 2
void
iwm_enable_txq(struct iwm_softc *sc, int qid, int fifo)
d1843 1
a1843 1
		return; /* XXX return EBUSY */
d1846 1
a1846 4
	/* unactivate before configuration */
	iwm_write_prph(sc, IWM_SCD_QUEUE_STATUS_BITS(qid),
	    (0 << IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE)
	    | (1 << IWM_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));
d1848 38
a1885 3
	if (qid != IWM_MVM_CMD_QUEUE) {
		iwm_set_bits_prph(sc, IWM_SCD_QUEUECHAIN_SEL, (1 << qid));
	}
d1887 6
a1892 1
	iwm_clear_bits_prph(sc, IWM_SCD_AGGR_SEL, (1 << qid));
d1894 3
a1896 2
	IWM_WRITE(sc, IWM_HBUS_TARG_WRPTR, qid << 8 | 0);
	iwm_write_prph(sc, IWM_SCD_QUEUE_RDPTR(qid), 0);
d1898 2
a1899 15
	iwm_write_mem32(sc, sc->sched_base + IWM_SCD_CONTEXT_QUEUE_OFFSET(qid), 0);
	/* Set scheduler window size and frame limit. */
	iwm_write_mem32(sc,
	    sc->sched_base + IWM_SCD_CONTEXT_QUEUE_OFFSET(qid) +
	    sizeof(uint32_t),
	    ((IWM_FRAME_LIMIT << IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_POS) &
	    IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_MSK) |
	    ((IWM_FRAME_LIMIT << IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &
	    IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK));

	iwm_write_prph(sc, IWM_SCD_QUEUE_STATUS_BITS(qid),
	    (1 << IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE) |
	    (fifo << IWM_SCD_QUEUE_STTS_REG_POS_TXF) |
	    (1 << IWM_SCD_QUEUE_STTS_REG_POS_WSL) |
	    IWM_SCD_QUEUE_STTS_REG_MSK);
d1904 2
d1913 1
d1918 4
a1921 5
	if (sc->sched_base != iwm_read_prph(sc, IWM_SCD_SRAM_BASE_ADDR)) {
		DPRINTF(("%s: sched addr mismatch", DEVNAME(sc)));
		error = EINVAL;
		goto out;
	}
d1940 2
d1943 6
a1948 1
	iwm_enable_txq(sc, IWM_MVM_CMD_QUEUE, 7);
a2149 1
	cmd.dataflags[1] = IWM_HCMD_DFL_NOCOPY;
d2179 1
d2345 1
a2345 2
	time_cmd.apply_time = htole32(iwm_read_prph(sc,
	    IWM_DEVICE_SYSTEM_TIME_REG));
d2355 2
a2356 1
	        IWM_TE_V2_NOTIF_HOST_EVENT_END);
d2370 1
d2376 2
a2377 2
#define IWM_NVM_DEFAULT_CHUNK_SIZE (2*1024)
#define IWM_MAX_NVM_SECTION_SIZE 7000
d2382 4
d2405 2
a2406 1
	int ret, bytes_read, offset_read;
d2412 3
a2414 1
	if (ret)
d2416 1
d2447 8
d2475 1
a2475 1
	uint16_t section, uint8_t *data, uint16_t *len)
d2477 4
a2480 2
	uint16_t length, seglen;
	int error;
d2482 1
a2482 2
	/* Set nvm section read length */
	length = seglen = IWM_NVM_DEFAULT_CHUNK_SIZE;
d2485 2
a2486 2
	/* Read the NVM until exhausted (reading less than requested) */
	while (seglen == length) {
d2488 1
a2488 1
		    section, *len, length, data, &seglen);
d2490 2
a2491 3
			printf("%s: Cannot read NVM from section "
			    "%d offset %d, length %d\n",
			    DEVNAME(sc), section, *len, length);
d2497 17
a2513 2
	DPRINTFN(4, ("NVM section %d read completed\n", section));
	return 0;
d2516 10
a2525 3
/*
 * BEGIN IWM_NVM_PARSE
 */
d2527 2
a2528 6
#define IWM_FW_VALID_TX_ANT(sc) \
    ((sc->sc_fw_phy_config & IWM_FW_PHY_CFG_TX_CHAIN) \
    >> IWM_FW_PHY_CFG_TX_CHAIN_POS)
#define IWM_FW_VALID_RX_ANT(sc) \
    ((sc->sc_fw_phy_config & IWM_FW_PHY_CFG_RX_CHAIN) \
    >> IWM_FW_PHY_CFG_RX_CHAIN_POS)
d2531 1
a2531 1
enum wkp_nvm_offsets {
d2592 2
a2593 1
iwm_init_channel_map(struct iwm_softc *sc, const uint16_t * const nvm_ch_flags)
d2603 1
a2603 1
	for (ch_idx = 0; ch_idx < nitems(iwm_nvm_channels); ch_idx++) {
d2612 1
a2612 1
			    iwm_nvm_channels[ch_idx],
d2619 1
a2619 1
		hw_value = iwm_nvm_channels[ch_idx];
d2659 1
a2659 1
	if (IWM_FW_VALID_RX_ANT(sc) > 1)
d2661 1
a2661 1
	if (IWM_FW_VALID_RX_ANT(sc) > 2)
d2672 1
a2672 1
	struct iwm_mvm_add_sta_cmd_v6 cmd;
d2806 2
a2807 1
	const uint16_t *nvm_calib, uint8_t tx_chains, uint8_t rx_chains)
d2811 2
a2812 1
	uint16_t radio_cfg, sku;
a2838 3
	data->xtal_calib[0] = *(nvm_calib + IWM_XTAL_CALIB);
	data->xtal_calib[1] = *(nvm_calib + IWM_XTAL_CALIB + 1);

d2848 3
a2850 1
	iwm_init_channel_map(sc, &nvm_sw[IWM_NVM_CHANNELS]);
a2859 9
/*
 * END NVM PARSE
 */

struct iwm_nvm_section {
	uint16_t length;
	const uint8_t *data;
};

d2863 2
a2864 1
	const uint16_t *hw, *sw, *calib;
d2869 2
a2870 1
		DPRINTF(("%s: Can't parse empty NVM sections\n", DEVNAME(sc)));
d2874 1
a2874 1
	hw = (const uint16_t *)sections[IWM_NVM_SECTION_TYPE_HW].data;
d2876 5
a2880 3
	calib = (const uint16_t *)sections[IWM_NVM_SECTION_TYPE_CALIBRATION].data;
	return iwm_parse_nvm_data(sc, hw, sw, calib,
	    IWM_FW_VALID_TX_ANT(sc), IWM_FW_VALID_RX_ANT(sc));
d2889 2
a2890 1
	uint8_t *nvm_buffer, *temp;
d2892 5
a2896 2
	/* Read From FW NVM */
	DPRINTF(("Read NVM\n"));
a2897 2
	/* TODO: find correct NVM max size for a section */
	nvm_buffer = malloc(IWM_OTP_LOW_IMAGE_SIZE, M_DEVBUF, M_WAIT);
d2902 8
a2909 2
		error = iwm_nvm_read_section(sc, section, nvm_buffer, &len);
		if (error)
d2911 2
a2912 4

		temp = malloc(len, M_DEVBUF, M_WAIT);
		memcpy(temp, nvm_buffer, len);
		nvm_sections[section].data = temp;
d2915 1
a2915 1
	free(nvm_buffer, M_DEVBUF, IWM_OTP_LOW_IMAGE_SIZE);
d2928 25
d2954 1
a2954 1
	const uint8_t *section, uint32_t byte_cnt)
d2959 2
a2960 2
	/* Copy firmware section into pre-allocated DMA-safe memory. */
	memcpy(dma->vaddr, section, byte_cnt);
d2964 7
a2973 2
	sc->sc_fw_chunk_done = 0;

d2999 11
d3014 1
a3014 1
iwm_load_firmware(struct iwm_softc *sc, enum iwm_ucode_type ucode_type)
d3017 1
a3017 1
	int error, i, w;
d3029 1
a3029 1
		DPRINTF(("LOAD FIRMWARE type %d offset %u len %d\n",
d3031 5
a3035 1
		error = iwm_firmware_load_chunk(sc, offset, data, dlen);
d3037 2
a3038 1
			DPRINTF(("iwm_firmware_load_chunk() chunk %u of %u returned error %02d\n", i, fws->fw_count, error));
a3042 1
	/* wait for the firmware to load */
d3045 13
d3061 9
d3186 2
a3187 5
		sc->sc_scan_cmd_len = sizeof(struct iwm_scan_cmd)
		    + sc->sc_capa_max_probe_len
		    + IWM_MAX_NUM_SCAN_CHANNELS
		    * sizeof(struct iwm_scan_channel);
		sc->sc_scan_cmd = malloc(sc->sc_scan_cmd_len, M_DEVBUF, M_WAIT);
d3189 4
a3192 1
		return 0;
d3195 5
d3201 3
a3203 1
	if ((error = iwm_send_tx_ant_cfg(sc, IWM_FW_VALID_TX_ANT(sc))) != 0)
d3205 1
d3208 3
a3210 3
	* Send phy configurations command to init uCode
	* to start the 16.0 uCode init image internal calibrations.
	*/
d3226 3
d3441 2
a3442 4
	if (sc->sc_scanband == IEEE80211_CHAN_5GHZ) {
		if (le32toh(phy_info->channel) < nitems(ic->ic_channels))
			c = &ic->ic_channels[le32toh(phy_info->channel)];
	}
d3628 1
a3628 1
iwm_mvm_binding_update(struct iwm_softc *sc, struct iwm_node *in, int add)
d3630 1
a3630 1
	return iwm_mvm_binding_cmd(sc, in, IWM_FW_CTXT_ACTION_ADD);
d3636 1
a3636 1
	return iwm_mvm_binding_update(sc, in, IWM_FW_CTXT_ACTION_ADD);
d3676 1
a3676 1
	cmd->rxchain_info = htole32(IWM_FW_VALID_RX_ANT(sc) <<
d3682 1
a3682 1
	cmd->txchain_info = htole32(IWM_FW_VALID_TX_ANT(sc));
d3759 1
a3759 1
	struct iwm_tx_data *data;
d3767 3
d3798 10
a3807 1
	data = &ring->data[ring->cur];
d3809 1
a3809 1
	if (paylen > sizeof(cmd->data)) {
d3811 1
a3811 1
		size_t totlen = sizeof(cmd->hdr) + paylen;
d3826 1
a3826 1
		error = bus_dmamap_load(sc->sc_dmat, data->map, cmd,
d3834 2
a3835 2
		data->m = m; /* mbuf will be freed in iwm_cmd_done() */
		paddr = data->map->dm_segs[0].ds_addr;
d3838 1
a3838 1
		paddr = data->cmd_paddr;
d3841 15
a3855 4
	cmd->hdr.code = code;
	cmd->hdr.flags = 0;
	cmd->hdr.qid = ring->qid;
	cmd->hdr.idx = ring->cur;
d3860 1
a3860 1
		memcpy(cmd->data + off, hcmd->data[i], hcmd->len[i]);
d3869 1
a3869 1
	    | ((sizeof(cmd->hdr) + paylen) << 4));
d3873 1
a3873 1
	    code, hcmd->len[0] + hcmd->len[1] + sizeof(cmd->hdr),
d3876 3
a3878 3
	if (paylen > sizeof(cmd->data)) {
		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    sizeof(cmd->hdr) + paylen, BUS_DMASYNC_PREWRITE);
d3882 1
a3882 1
		    sizeof(cmd->hdr) + hcmd->len[0], BUS_DMASYNC_PREWRITE);
d4584 1
a4584 1
iwm_mvm_disable_beacon_filter(struct iwm_softc *sc, struct iwm_node *in)
a4599 35
#if 0
int
iwm_mvm_update_beacon_filter(struct iwm_softc *sc, struct iwm_node *in)
{
	if (!sc->sc_bf.bf_enabled)
		return 0;

	return iwm_mvm_enable_beacon_filter(sc, in);
}
#endif

void
iwm_mvm_add_sta_cmd_v6_to_v5(struct iwm_mvm_add_sta_cmd_v6 *cmd_v6,
	struct iwm_mvm_add_sta_cmd_v5 *cmd_v5)
{
	memset(cmd_v5, 0, sizeof(*cmd_v5));

	cmd_v5->add_modify = cmd_v6->add_modify;
	cmd_v5->tid_disable_tx = cmd_v6->tid_disable_tx;
	cmd_v5->mac_id_n_color = cmd_v6->mac_id_n_color;
	memcpy(cmd_v5->addr, cmd_v6->addr, ETHER_ADDR_LEN);
	cmd_v5->sta_id = cmd_v6->sta_id;
	cmd_v5->modify_mask = cmd_v6->modify_mask;
	cmd_v5->station_flags = cmd_v6->station_flags;
	cmd_v5->station_flags_msk = cmd_v6->station_flags_msk;
	cmd_v5->add_immediate_ba_tid = cmd_v6->add_immediate_ba_tid;
	cmd_v5->remove_immediate_ba_tid = cmd_v6->remove_immediate_ba_tid;
	cmd_v5->add_immediate_ba_ssn = cmd_v6->add_immediate_ba_ssn;
	cmd_v5->sleep_tx_count = cmd_v6->sleep_tx_count;
	cmd_v5->sleep_state_flags = cmd_v6->sleep_state_flags;
	cmd_v5->assoc_id = cmd_v6->assoc_id;
	cmd_v5->beamform_flags = cmd_v6->beamform_flags;
	cmd_v5->tfd_queue_msk = cmd_v6->tfd_queue_msk;
}

d4602 1
a4602 1
	struct iwm_mvm_add_sta_cmd_v6 *cmd, int *status)
d4604 2
a4605 11
	struct iwm_mvm_add_sta_cmd_v5 cmd_v5;

	if (sc->sc_capaflags & IWM_UCODE_TLV_FLAGS_STA_KEY_CMD) {
		return iwm_mvm_send_cmd_pdu_status(sc, IWM_ADD_STA,
		    sizeof(*cmd), cmd, status);
	}

	iwm_mvm_add_sta_cmd_v6_to_v5(cmd, &cmd_v5);

	return iwm_mvm_send_cmd_pdu_status(sc, IWM_ADD_STA, sizeof(cmd_v5),
	    &cmd_v5, status);
d4612 1
a4612 1
	struct iwm_mvm_add_sta_cmd_v6 add_sta_cmd;
d4623 5
a4627 1
		add_sta_cmd.tfd_queue_msk = htole32(0xf);
d4633 3
d4699 1
a4699 1
	struct iwm_mvm_add_sta_cmd_v6 cmd;
d4708 1
d4735 6
a4740 2
	sc->sc_aux_sta.sta_id = 3;
	sc->sc_aux_sta.tfd_queue_msk = 0;
d4762 1
a4762 1
	rx_ant = IWM_FW_VALID_RX_ANT(sc);
a4790 9
iwm_mvm_scan_rxon_flags(struct iwm_softc *sc, int flags)
{
	if (flags & IEEE80211_CHAN_2GHZ)
		return htole32(IWM_PHY_BAND_24);
	else
		return htole32(IWM_PHY_BAND_5);
}

uint32_t
d4799 1
a4799 1
		if (IWM_FW_VALID_TX_ANT(sc) & (1 << ind)) {
d4837 3
a4839 3
int
iwm_mvm_scan_fill_channels(struct iwm_softc *sc, struct iwm_scan_cmd *cmd,
	int flags, int n_ssids, int basic_ssid)
a4841 5
	uint16_t passive_dwell = iwm_mvm_get_passive_dwell(sc, flags);
	uint16_t active_dwell = iwm_mvm_get_active_dwell(sc, flags, n_ssids);
	struct iwm_scan_channel *chan = (struct iwm_scan_channel *)
		(cmd->data + le16toh(cmd->tx_cmd.len));
	int type = (1 << n_ssids) - 1;
d4843 1
a4843 4
	int nchan;

	if (!basic_ssid)
		type |= (1 << n_ssids);
d4846 2
a4847 1
	    c <= &ic->ic_channels[IEEE80211_CHAN_MAX];
d4849 1
a4849 1
		if ((c->ic_flags & flags) != flags)
d4852 8
a4859 7
		chan->channel = htole16(ieee80211_mhz2ieee(c->ic_freq, flags));
		chan->type = htole32(type);
		if (c->ic_flags & IEEE80211_CHAN_PASSIVE)
			chan->type &= htole32(~IWM_SCAN_CHANNEL_TYPE_ACTIVE);
		chan->active_dwell = htole16(active_dwell);
		chan->passive_dwell = htole16(passive_dwell);
		chan->iteration_count = htole16(1);
d4863 1
a4863 2
	if (nchan == 0)
		DPRINTF(("%s: NO CHANNEL!\n", DEVNAME(sc)));
d4867 15
a4881 21
/*
 * Fill in probe request with the following parameters:
 * TA is our vif HW address, which mac80211 ensures we have.
 * Packet is broadcasted, so this is both SA and DA.
 * The probe request IE is made out of two: first comes the most prioritized
 * SSID if a directed scan is requested. Second comes whatever extra
 * information was given to us as the scan request IE.
 */
uint16_t
iwm_mvm_fill_probe_req(struct iwm_softc *sc, struct ieee80211_frame *frame,
	const uint8_t *ta, int n_ssids, const uint8_t *ssid, int ssid_len,
	const uint8_t *ie, int ie_len, int left)
{
	int len = 0;
	uint8_t *pos = NULL;

	/* Make sure there is enough space for the probe request,
	 * two mandatory IEs and the data */
	left -= sizeof(*frame);
	if (left < 0)
		return 0;
d4883 5
a4887 1
	frame->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
d4889 39
a4927 24
	frame->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	IEEE80211_ADDR_COPY(frame->i_addr1, etherbroadcastaddr);
	memcpy(frame->i_addr2, ta, ETHER_ADDR_LEN);
	IEEE80211_ADDR_COPY(frame->i_addr3, etherbroadcastaddr);

	len += sizeof(*frame);
	CTASSERT(sizeof(*frame) == 24);

	/* for passive scans, no need to fill anything */
	if (n_ssids == 0)
		return (uint16_t)len;

	/* points to the payload of the request */
	pos = (uint8_t *)frame + sizeof(*frame);

	/* fill in our SSID IE */
	left -= ssid_len + 2;
	if (left < 0)
		return 0;
	*pos++ = IEEE80211_ELEMID_SSID;
	*pos++ = ssid_len;
	if (ssid && ssid_len) { /* ssid_len may be == 0 even if ssid is valid */
		memcpy(pos, ssid, ssid_len);
		pos += ssid_len;
d4930 16
a4945 1
	len += ssid_len + 2;
d4947 8
a4954 6
	if (left < ie_len)
		return len;

	if (ie && ie_len) {
		memcpy(pos, ie, ie_len);
		len += ie_len;
d4956 1
d4958 1
a4958 1
	return (uint16_t)len;
d4962 1
a4962 2
iwm_mvm_scan_request(struct iwm_softc *sc, int flags,
	int n_ssids, uint8_t *ssid, int ssid_len)
d4966 1
a4966 1
		.id = IWM_SCAN_REQUEST_CMD,
d4968 1
a4968 1
		.data = { sc->sc_scan_cmd, },
a4969 1
		.dataflags = { IWM_HCMD_DFL_NOCOPY, },
d4971 2
a4972 2
	struct iwm_scan_cmd *cmd = sc->sc_scan_cmd;
	int is_assoc = 0;
a4973 2
	uint32_t status;
	int basic_ssid = !(sc->sc_capaflags & IWM_UCODE_TLV_FLAGS_NO_BASIC_SSID);
d4975 8
a4982 1
	//lockdep_assert_held(&mvm->mutex);
d4984 2
a4985 1
	sc->sc_scanband = flags & (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_5GHZ);
a4987 1
	memset(cmd, 0, sc->sc_scan_cmd_len);
d4989 30
a5018 8
	cmd->quiet_time = htole16(IWM_ACTIVE_QUIET_TIME);
	cmd->quiet_plcp_th = htole16(IWM_PLCP_QUIET_THRESH);
	cmd->rxchain_sel_flags = iwm_mvm_scan_rx_chain(sc);
	cmd->max_out_time = iwm_mvm_scan_max_out_time(sc, 0, is_assoc);
	cmd->suspend_time = iwm_mvm_scan_suspend_time(sc, is_assoc);
	cmd->rxon_flags = iwm_mvm_scan_rxon_flags(sc, flags);
	cmd->filter_flags = htole32(IWM_MAC_FILTER_ACCEPT_GRP |
	    IWM_MAC_FILTER_IN_BEACON);
d5020 6
a5025 2
	cmd->type = htole32(IWM_SCAN_TYPE_FORCED);
	cmd->repeats = htole32(1);
d5027 26
a5052 16
	/*
	 * If the user asked for passive scan, don't change to active scan if
	 * you see any activity on the channel - remain passive.
	 */
	if (n_ssids > 0) {
		cmd->passive2active = htole16(1);
		cmd->scan_flags |= IWM_SCAN_FLAGS_PASSIVE2ACTIVE;
#if 0
		if (basic_ssid) {
			ssid = req->ssids[0].ssid;
			ssid_len = req->ssids[0].ssid_len;
		}
#endif
	} else {
		cmd->passive2active = 0;
		cmd->scan_flags &= ~IWM_SCAN_FLAGS_PASSIVE2ACTIVE;
d5055 10
a5064 22
	cmd->tx_cmd.tx_flags = htole32(IWM_TX_CMD_FLG_SEQ_CTL |
	    IWM_TX_CMD_FLG_BT_DIS);
	cmd->tx_cmd.sta_id = sc->sc_aux_sta.sta_id;
	cmd->tx_cmd.life_time = htole32(IWM_TX_CMD_LIFE_TIME_INFINITE);
	cmd->tx_cmd.rate_n_flags = iwm_mvm_scan_rate_n_flags(sc, flags, 1/*XXX*/);

	cmd->tx_cmd.len = htole16(iwm_mvm_fill_probe_req(sc,
			    (struct ieee80211_frame *)cmd->data,
			    ic->ic_myaddr, n_ssids, ssid, ssid_len,
			    NULL, 0, sc->sc_capa_max_probe_len));

	cmd->channel_count
	    = iwm_mvm_scan_fill_channels(sc, cmd, flags, n_ssids, basic_ssid);

	cmd->len = htole16(sizeof(struct iwm_scan_cmd) +
		le16toh(cmd->tx_cmd.len) +
		(cmd->channel_count * sizeof(struct iwm_scan_channel)));
	hcmd.len[0] = le16toh(cmd->len);

	status = IWM_SCAN_RESPONSE_OK;
	ret = iwm_mvm_send_cmd_status(sc, &hcmd, &status);
	if (!ret && status == IWM_SCAN_RESPONSE_OK) {
d5066 1
a5066 8
	} else {
		/*
		 * If the scan failed, it usually means that the FW was unable
		 * to allocate the time events. Warn on it, but maybe we
		 * should try to send the command again with different params.
		 */
		ret = EIO;
	}
d5463 4
d5484 6
a5489 1
		DPRINTF(("%s: failed to add MAC\n", DEVNAME(sc)));
a5517 4
	if ((error = iwm_mvm_mac_ctxt_changed(sc, in)) != 0) {
		DPRINTF(("%s: failed to update MAC\n", DEVNAME(sc)));
		return error;
	}
d5544 1
a5544 1
	//iwm_mvm_flush_tx_path(sc, 0xf, 1);
d5648 4
d5768 1
a5768 1
		iwm_mvm_disable_beacon_filter(sc, (void *)ic->ic_bss);
d5791 2
a5792 1
			sc->sc_newstate(ic, IEEE80211_S_INIT, arg);
a5799 1
		sc->sc_scanband = 0;
d5803 6
a5808 9
		if (sc->sc_scanband)
			break;

		if ((error = iwm_mvm_scan_request(sc, IEEE80211_CHAN_2GHZ,
		    ic->ic_des_esslen != 0,
		    ic->ic_des_essid, ic->ic_des_esslen)) != 0) {
			printf("%s: could not initiate 2 GHz scan\n",
			    DEVNAME(sc));
			sc->sc_scanband = 0;
d5811 1
a5878 1
	int done;
d5882 84
a5965 10
	if (sc->sc_scanband == IEEE80211_CHAN_2GHZ &&
	    sc->sc_nvm.sku_cap_band_52GHz_enable) {
		int error;
		done = 0;
		if ((error = iwm_mvm_scan_request(sc,
		    IEEE80211_CHAN_5GHZ, ic->ic_des_esslen != 0,
		    ic->ic_des_essid, ic->ic_des_esslen)) != 0) {
			printf("%s: could not initiate 5 GHz scan\n",
			    DEVNAME(sc));
			done = 1;
d5967 1
d5969 42
a6010 1
		done = 1;
d6013 69
a6081 3
	if (done) {
		ieee80211_end_scan(&ic->ic_if);
		sc->sc_scanband = 0;
d6083 25
d6115 1
a6115 1
	int error, i, qid;
d6144 4
a6147 1
	if ((error = iwm_send_tx_ant_cfg(sc, IWM_FW_VALID_TX_ANT(sc))) != 0)
d6172 3
d6179 11
a6189 3
	/* Mark TX rings as active. */
	for (qid = 0; qid < 4; qid++) {
		iwm_enable_txq(sc, qid, qid);
d6198 5
a6349 1
	sc->sc_scanband = 0;
d6472 2
a6473 2
	uint32_t pc;			/* program counter */
	uint32_t blink1;		/* branch link */
d6485 3
a6487 2
	uint32_t gp3;		/* GP3 timer register */
	uint32_t ucode_ver;		/* uCode version */
d6504 1
a6504 1
	uint32_t isr_pref;		/* isr status register LMPM_NIC_PREF_STAT */
d6570 2
a6571 2
	if (base < 0x800000 || base >= 0x80C000) {
		printf("%s: Not valid error log pointer 0x%08x\n",
d6576 1
a6576 1
	if (iwm_read_mem(sc, base, &table, sizeof(table)/sizeof(uint32_t)) != 0) {
d6587 1
a6587 1
		printf("%s: Start IWL Error Log Dump:\n", DEVNAME(sc));
d6593 5
a6597 3
		iwm_desc_lookup(table.error_id));
	printf("%s: %08X | uPc\n", DEVNAME(sc), table.pc);
	printf("%s: %08X | branchlink1\n", DEVNAME(sc), table.blink1);
d6609 6
a6614 2
	printf("%s: %08X | time gp3\n", DEVNAME(sc), table.gp3);
	printf("%s: %08X | uCode version\n", DEVNAME(sc), table.ucode_ver);
d6623 1
a6623 1
	printf("%s: %08X | isr_pref\n", DEVNAME(sc), table.isr_pref);
d6668 1
a6668 1
		int qid, idx;
d6677 3
a6679 3
		DPRINTFN(12, ("rx packet qid=%d idx=%d flags=%x type=%x %d %d\n",
		    pkt->hdr.qid & ~0x80, pkt->hdr.idx, pkt->hdr.flags,
		    pkt->hdr.code, sc->rxq.cur, hw));
d6691 1
a6691 1
		switch (pkt->hdr.code) {
d6708 3
d6712 29
a6740 2
			struct iwm_mvm_alive_resp *resp;
			SYNC_RESP_STRUCT(resp, pkt);
d6742 12
a6753 6
			sc->sc_uc.uc_error_event_table
			    = le32toh(resp->error_event_table_ptr);
			sc->sc_uc.uc_log_event_table
			    = le32toh(resp->log_event_table_ptr);
			sc->sched_base = le32toh(resp->scd_base_ptr);
			sc->sc_uc.uc_ok = resp->status == IWM_ALIVE_STATUS_OK;
d6775 1
d6785 14
d6809 1
d6816 2
d6834 8
a6841 2
		case IWM_SCAN_COMPLETE_NOTIFICATION: {
			struct iwm_scan_complete_notif *notif;
d6867 11
d7117 1
a7117 1
	printf("%s: hw rev 0x%x, fw ver %d.%d (API ver %d), address %s\n",
d7119 1
a7119 4
	    IWM_UCODE_MAJOR(sc->sc_fwver),
	    IWM_UCODE_MINOR(sc->sc_fwver),
	    IWM_UCODE_API(sc->sc_fwver),
	    ether_sprintf(sc->sc_nvm.hw_addr));
d7230 1
a7230 1
		sc->sc_fwname = "iwm-3160-9";
d7235 1
a7235 1
		sc->sc_fwname = "iwm-7260-9";
d7240 1
a7240 1
		sc->sc_fwname = "iwm-7265-9";
d7320 1
@


1.80
log
@In iwm(4), add bit-polling in Rx-DMA init code path.

According to a comment in iwlwifi:
 * Clearing FH_MEM_RCSR_CHNL0_CONFIG_REG to 0 turns off Rx DMA.
 * Driver should poll FH_MEM_RSSR_RX_STATUS_REG	for
 * FH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE (bit 24) before continuing.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.79 2016/04/13 10:34:32 mpi Exp $	*/
a264 1
#ifdef notyet
a268 1
#endif
a275 1
#ifdef notyet
a277 2
#endif
int	iwm_send_phy_db_data(struct iwm_softc *);
a319 1
int	iwm_fw_alive(struct iwm_softc *, uint32_t);
a1320 1
	int rv = 0;
d1324 3
a1326 1
		goto out;
d1334 1
a1334 1
			goto out;
d1339 1
a1339 4
	rv = ETIMEDOUT;

 out:
	return rv;
d1418 1
a1734 8
enum iwm_mvm_tx_fifo {
	IWM_MVM_TX_FIFO_BK = 0,
	IWM_MVM_TX_FIFO_BE,
	IWM_MVM_TX_FIFO_VI,
	IWM_MVM_TX_FIFO_VO,
	IWM_MVM_TX_FIFO_MCAST = 5,
};

a1841 39
 * PHY db
 */

enum iwm_phy_db_section_type {
	IWM_PHY_DB_CFG = 1,
	IWM_PHY_DB_CALIB_NCH,
	IWM_PHY_DB_UNUSED,
	IWM_PHY_DB_CALIB_CHG_PAPD,
	IWM_PHY_DB_CALIB_CHG_TXP,
	IWM_PHY_DB_MAX
};

#define IWM_PHY_DB_CMD 0x6c /* TEMP API - The actual is 0x8c */

/*
 * phy db - configure operational ucode
 */
struct iwm_phy_db_cmd {
	uint16_t type;
	uint16_t length;
	uint8_t data[];
} __packed;

/* for parsing of tx power channel group data that comes from the firmware*/
struct iwm_phy_db_chg_txp {
	uint32_t space;
	uint16_t max_channel_idx;
} __packed;

/*
 * phy db - Receive phy db chunk after calibrations
 */
struct iwm_calib_res_notif_phy_db {
	uint16_t type;
	uint16_t length;
	uint8_t data[];
} __packed;

/*
a2869 6
iwm_fw_alive(struct iwm_softc *sc, uint32_t sched_base)
{
	return iwm_post_alive(sc);
}

int
d2915 1
a2915 1
	return iwm_fw_alive(sc, sc->sched_base);
d2936 2
a2937 1
	    IWM_UCODE_TYPE_INIT)) != 0)
d2939 1
a3685 2
	//lockdep_assert_held(&mvm->mutex);

a4231 24
	KASSERT(0);

#if 0
	DPRINTF(mvm, "Rx timeout = %u usec\n",
			le32_to_cpu(cmd->rx_data_timeout));
	DPRINTF(mvm, "Tx timeout = %u usec\n",
			le32_to_cpu(cmd->tx_data_timeout));
	if (cmd->flags & cpu_to_le16(IWM_POWER_FLAGS_SKIP_OVER_DTIM_MSK))
		DPRINTF(mvm, "DTIM periods to skip = %u\n",
				cmd->skip_dtim_periods);
	if (cmd->flags & cpu_to_le16(IWM_POWER_FLAGS_LPRX_ENA_MSK))
		DPRINTF(mvm, "LP RX RSSI threshold = %u\n",
				cmd->lprx_rssi_threshold);
	if (cmd->flags & cpu_to_le16(IWM_POWER_FLAGS_ADVANCE_PM_ENA_MSK)) {
		DPRINTF(mvm, "uAPSD enabled\n");
		DPRINTF(mvm, "Rx timeout (uAPSD) = %u usec\n",
				le32_to_cpu(cmd->rx_data_timeout_uapsd));
		DPRINTF(mvm, "Tx timeout (uAPSD) = %u usec\n",
				le32_to_cpu(cmd->tx_data_timeout_uapsd));
		DPRINTF(mvm, "QNDP TID = %d\n", cmd->qndp_tid);
		DPRINTF(mvm, "ACs flags = 0x%x\n", cmd->uapsd_ac_flags);
		DPRINTF(mvm, "Max SP = %d\n", cmd->uapsd_max_sp);
	}
#endif
d4456 1
a4456 7
	int ret;

	ret = iwm_mvm_sta_send_to_fw(sc, in, 0);
	if (ret)
		return ret;

	return 0;
@


1.79
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.78 2016/02/13 10:29:13 stsp Exp $	*/
d238 1
d1054 1
a1054 1
iwm_reset_rx_ring(struct iwm_softc *sc, struct iwm_rx_ring *ring)
d1068 5
d1546 1
d1641 1
a1641 1
	IWM_WRITE(sc, IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG, 0);
@


1.78
log
@Make iwm(4) initialize net80211 callback pointers at attach time.
Fixes a crash reported by Donald Allen via misc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.77 2016/02/05 16:08:44 stsp Exp $	*/
a6858 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.77
log
@In iwm(4), set max A-MPDU length to 64k instead of 4k and tell the firmware
about A-MPDU spacing. Makes BlockAck happy.
tested by myself and abieber@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.76 2016/01/25 11:27:11 stsp Exp $	*/
a6644 12
	ic->ic_node_alloc = iwm_node_alloc;

	/* Override 802.11 state transition machine. */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = iwm_newstate;
	ic->ic_update_htprot = iwm_update_htprot;
	ic->ic_ampdu_rx_start = iwm_ampdu_rx_start;
	ic->ic_ampdu_rx_stop = iwm_ampdu_rx_stop;
#ifdef notyet
	ic->ic_ampdu_tx_start = iwm_ampdu_tx_start;
	ic->ic_ampdu_tx_stop = iwm_ampdu_tx_stop;
#endif
d6877 12
@


1.76
log
@Keep track of HT protection settings in beacons and have 11n-capable
drivers update hardware configuration accordingly.
tested by myself, tb@@, deraadt@@, abieber@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.75 2016/01/07 23:08:38 stsp Exp $	*/
d4469 1
d4484 29
d6847 1
a6847 1
	ic->ic_ampdu_params = IEEE80211_AMPDU_PARAM_SS_4;
@


1.75
log
@Fix A-MPDU parameters in link quality firmware commands in iwn(4) and iwm(4).
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.74 2016/01/06 19:56:50 stsp Exp $	*/
d297 2
d2607 28
d5911 1
d6620 1
d6857 1
@


1.74
log
@Initialize the A-MPDU parameters field in HT capability elements.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.73 2016/01/06 09:15:31 stsp Exp $	*/
d5449 4
@


1.73
log
@iwm(4) adjusts the firmware's tx rate retry table dynamically so we must
tell the firmware to always try the first rate in the table first.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.72 2016/01/05 18:41:15 stsp Exp $	*/
d6781 1
@


1.72
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.71 2015/12/14 08:34:56 stsp Exp $	*/
d3856 1
a3856 5
		if (ni->ni_flags & IEEE80211_NODE_HT) {
			tx->initial_rate_index =
			    (nitems(iwm_mcs2ridx) - 1) - ni->ni_txmcs;
		} else
			tx->initial_rate_index = (nrates - 1) - ni->ni_txrate;
@


1.71
log
@Add initial 802.11n support to the iwm(4) driver.

Adds support for HT MCS 0-7 (theoretical limit 65 Mbit/s) and the
reception of A-MSDU and A-MPDU aggregated frames.

None of the optional 11n features are supported for now.
MIMO, 40Mhz channels, short guard interval, etc. are left for future work.
And we're not sending A-MSDU or A-MPDU frames yet either.

Tested with various 11a/b/g/n access points. With some APs I'm seeing
a noticable increase in throughput, especially on 5Ghz.

Also, fix automatic rate selection by using the current Tx rate selected
by AMRR as the upper bound for the firmware's rate table and updating the
firmware's table whenever AMRR switches Tx rate, rather than setting the
table just once after association and ignoring AMRR updates.

ok mpi@@ krw@@ (earlier version), ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.70 2015/12/11 16:07:02 mpi Exp $	*/
a295 1
#ifndef IEEE80211_NO_HT
a310 2
#endif /* IEEE80211_NO_HT */

a2518 1
#ifndef IEEE80211_NO_HT
a2520 1
#endif
a2523 1
#ifndef IEEE80211_NO_HT
a2652 1
#endif /* IEEE80211_NO_HT */
a2675 1
#ifndef IEEE80211_NO_HT
a2677 4
#else
	data->sku_cap_11n_enable = 0;
	data->sku_cap_mimo_disable = 1;
#endif
a3849 1
#ifndef IEEE80211_NO_HT
a3851 1
#endif
a3855 1
#ifndef IEEE80211_NO_HT
a3859 1
#endif
a3862 1
#ifndef IEEE80211_NO_HT
a3866 1
#endif
a3881 1
#ifndef IEEE80211_NO_HT
a3886 1
#endif
a4951 1
#ifndef IEEE80211_NO_HT
a4973 1
#endif
d5348 2
a5349 7
	if ((ic->ic_fixed_rate == -1
#ifndef IEEE80211_NO_HT
	    || ic->ic_fixed_mcs == -1
#endif
	    ) && ic->ic_opmode == IEEE80211_M_STA
	    && ic->ic_bss) {
#ifndef IEEE80211_NO_HT
a5352 1
#endif
a5359 1
#ifndef IEEE80211_NO_HT
d5363 1
a5363 3
		else
#endif
		if (otxrate != ni->ni_txrate)
a5413 1
#ifndef IEEE80211_NO_HT
a5425 1
#endif
a5471 1
#ifndef IEEE80211_NO_HT
d5474 1
a5474 3
	else
#endif
	if (ic->ic_fixed_rate != -1) {
a5589 1
#ifndef IEEE80211_NO_HT
a5590 1
#endif
a5879 1
#ifndef IEEE80211_NO_HT
d5881 1
a5881 1
#endif
a6566 1
#ifndef IEEE80211_NO_HT
d6569 1
a6569 1
#endif
a6588 1
#ifndef IEEE80211_NO_HT
a6594 1
#endif
a6779 1
#ifndef IEEE80211_NO_HT
a6784 1
#endif
a6822 1
#ifndef IEEE80211_NO_HT
a6823 1
#endif
@


1.70
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.69 2015/12/08 17:10:02 stsp Exp $	*/
d173 1
d175 14
a188 12
	{   2,	IWM_RATE_1M_PLCP  },
	{   4,	IWM_RATE_2M_PLCP  },
	{  11,	IWM_RATE_5M_PLCP  },
	{  22,	IWM_RATE_11M_PLCP },
	{  12,	IWM_RATE_6M_PLCP  },
	{  18,	IWM_RATE_9M_PLCP  },
	{  24,	IWM_RATE_12M_PLCP },
	{  36,	IWM_RATE_18M_PLCP },
	{  48,	IWM_RATE_24M_PLCP },
	{  72,	IWM_RATE_36M_PLCP },
	{  96,	IWM_RATE_48M_PLCP },
	{ 108,	IWM_RATE_54M_PLCP },
d196 12
d296 18
d2406 7
d2437 1
d2521 5
d2529 132
d2683 4
d2688 2
a2730 7
#define IWM_FW_VALID_TX_ANT(sc) \
    ((sc->sc_fw_phy_config & IWM_FW_PHY_CFG_TX_CHAIN) \
    >> IWM_FW_PHY_CFG_TX_CHAIN_POS)
#define IWM_FW_VALID_RX_ANT(sc) \
    ((sc->sc_fw_phy_config & IWM_FW_PHY_CFG_RX_CHAIN) \
    >> IWM_FW_PHY_CFG_RX_CHAIN_POS)

d3255 29
a3283 17
		switch (phy_info->rate) {
		/* CCK rates. */
		case  10: tap->wr_rate =   2; break;
		case  20: tap->wr_rate =   4; break;
		case  55: tap->wr_rate =  11; break;
		case 110: tap->wr_rate =  22; break;
		/* OFDM rates. */
		case 0xd: tap->wr_rate =  12; break;
		case 0xf: tap->wr_rate =  18; break;
		case 0x5: tap->wr_rate =  24; break;
		case 0x7: tap->wr_rate =  36; break;
		case 0x9: tap->wr_rate =  48; break;
		case 0xb: tap->wr_rate =  72; break;
		case 0x1: tap->wr_rate =  96; break;
		case 0x3: tap->wr_rate = 108; break;
		/* Unknown rate: should not happen. */
		default:  tap->wr_rate =   0;
d3852 1
a3852 1
	int ridx, rate_flags;
d3860 1
a3860 1
		ridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
d3862 4
d3870 7
a3876 1
		tx->initial_rate_index = (nrates - 1) - ni->ni_txrate;
d3879 14
a3892 1
		ridx = in->in_ridx[ni->ni_txrate];
d3900 8
a3907 1
	tx->rate_n_flags = htole32(rate_flags | rinfo->plcp);
d3972 5
a3976 1
		tap->wt_rate = rinfo->rate;
d4972 24
d5365 3
a5367 1
	int s;
d5370 5
a5374 2
	if (ic->ic_fixed_rate == -1
	    && ic->ic_opmode == IEEE80211_M_STA
d5376 6
a5381 1
		struct iwm_node *in = (void *)ic->ic_bss;
d5383 13
d5403 11
d5420 7
a5426 9
	int nrates = ni->ni_rates.rs_nrates;
	int i, ridx, tab = 0;
	int txant = 0;

	if (nrates > nitems(lq->rs_table)) {
		DPRINTF(("%s: node supports %d rates, driver handles "
		    "only %zu\n", DEVNAME(sc), nrates, nitems(lq->rs_table)));
		return;
	}
a5427 17
	/* first figure out which rates we should support */
	memset(&in->in_ridx, -1, sizeof(in->in_ridx));
	for (i = 0; i < nrates; i++) {
		int rate = ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL;

		/* Map 802.11 rate to HW rate index. */
		for (ridx = 0; ridx <= IWM_RIDX_MAX; ridx++)
			if (iwm_rates[ridx].rate == rate)
				break;
		if (ridx > IWM_RIDX_MAX)
			DPRINTF(("%s: WARNING: device rate for %d not found!\n",
			    DEVNAME(sc), rate));
		else
			in->in_ridx[i] = ridx;
	}

	/* then construct a lq_cmd based on those */
d5432 7
a5438 2
	 * are these used? (we don't do SISO or MIMO)
	 * need to set them to non-zero, though, or we get an error.
d5440 28
a5467 2
	lq->single_stream_ant_msk = 1;
	lq->dual_stream_ant_msk = 1;
d5469 2
a5470 10
	/*
	 * Build the actual rate selection table.
	 * The lowest bits are the rates.  Additionally,
	 * CCK needs bit 9 to be set.  The rest of the bits
	 * we add to the table select the tx antenna
	 * Note that we add the rates in the highest rate first
	 * (opposite of ni_rates).
	 */
	for (i = 0; i < nrates; i++) {
		int nextant;
d5472 1
a5472 8
		if (txant == 0)
			txant = IWM_FW_VALID_TX_ANT(sc);
		nextant = 1<<(ffs(txant)-1);
		txant &= ~nextant;

		ridx = in->in_ridx[(nrates-1)-i];
		tab = iwm_rates[ridx].plcp;
		tab |= nextant << IWM_RATE_MCS_ANT_POS;
d5475 2
a5476 2
		DPRINTFN(2, ("station rate %d %x\n", i, tab));
		lq->rs_table[i] = htole32(tab);
d5478 12
a5489 4
	/* then fill the rest with the lowest possible rate */
	for (i = nrates; i < nitems(lq->rs_table); i++) {
		KASSERT(tab != 0);
		lq->rs_table[i] = htole32(tab);
a5490 5

	/* init amrr */
	ieee80211_amrr_node_init(&sc->sc_amrr, &in->in_amn);
	/* Start at lowest available bit-rate, AMRR will raise. */
	ni->ni_txrate = 0;
d5505 5
a5615 6
		struct iwm_host_cmd cmd = {
			.id = IWM_LQ_CMD,
			.len = { sizeof(in->in_lq), },
			.flags = IWM_CMD_SYNC,
		};

d5620 9
a5630 5
		cmd.data[0] = &in->in_lq;
		if ((error = iwm_send_cmd(sc, &cmd)) != 0) {
			DPRINTF(("%s: IWM_LQ_CMD failed\n", DEVNAME(sc)));
		}

d5917 4
d6606 4
d6629 8
d6822 8
d6866 4
@


1.69
log
@When iwm(4) moves to AUTH state it asks the firmware for a "time event" to
prevent it from moving off-channel during association. The firmware issues
interrupts at beginning and end of the time event. The driver tried detecting
the beginning with a tsleep() in the newstate task followed by a wakeup()
from the interrupt handler. However, sometimes the newstate task did not get
scheduled until the time event had already passed, and association was aborted.
In rare cases the newstate task would even sleep forever and the iwm(4)
interface would stop working until reboot.
Fix these issues by issuing the time event and continuing association without
checking for a "go" from the firmware. Our kernel does not provide the
scheduling guarantees required for such precise synchronization so
association is more likely to fail with the additional check than without.
ok mpi@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.68 2015/11/25 03:09:59 dlg Exp $	*/
d413 1
a413 1
void	iwm_attach_hook(void *);
d6343 1
a6343 1
iwm_attach_hook(void *arg)
d6345 1
a6345 1
	struct iwm_softc *sc = arg;
d6563 1
a6563 4
	if (rootvp == NULL)
		mountroothook_establish(iwm_attach_hook, sc);
	else
		iwm_attach_hook(sc);
@


1.68
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.67 2015/11/24 17:11:39 mpi Exp $	*/
d275 1
a275 1
				uint32_t, uint32_t, uint32_t);
d2219 1
a2219 1
	uint32_t duration, uint32_t min_duration, uint32_t max_delay)
a4990 1
	uint32_t min_duration;
d5016 8
a5023 26
	/* a bit superfluous? */
	while (sc->sc_auth_prot)
		tsleep(&sc->sc_auth_prot, 0, "iwmauth", 0);
	sc->sc_auth_prot = 1;

	duration = min(IWM_MVM_TE_SESSION_PROTECTION_MAX_TIME_MS,
	    200 + in->in_ni.ni_intval);
	min_duration = min(IWM_MVM_TE_SESSION_PROTECTION_MIN_TIME_MS,
	    100 + in->in_ni.ni_intval);
	iwm_mvm_protect_session(sc, in, duration, min_duration, 500);

	while (sc->sc_auth_prot != 2) {
		/*
		 * well, meh, but if the kernel is sleeping for half a
		 * second, we have bigger problems
		 */
		if (sc->sc_auth_prot == 0) {
			DPRINTF(("%s: missed auth window!\n", DEVNAME(sc)));
			return ETIMEDOUT;
		} else if (sc->sc_auth_prot == -1) {
			DPRINTF(("%s: no time event, denied!\n", DEVNAME(sc)));
			sc->sc_auth_prot = 0;
			return EAUTH;
		}
		tsleep(&sc->sc_auth_prot, 0, "iwmau2", 0);
	}
a5625 1
	sc->sc_auth_prot = 0;
d6065 2
a6066 10
			if (notif->status) {
				if (le32toh(notif->action) &
				    IWM_TE_V2_NOTIF_HOST_EVENT_START)
					sc->sc_auth_prot = 2;
				else
					sc->sc_auth_prot = 0;
			} else {
				sc->sc_auth_prot = -1;
			}
			wakeup(&sc->sc_auth_prot);
@


1.67
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.66 2015/11/24 15:43:15 mpi Exp $	*/
d3178 2
a3179 2
		if (sc->qfullmsk == 0 && (ifp->if_flags & IFF_OACTIVE)) {
			ifp->if_flags &= ~IFF_OACTIVE;
d5555 1
a5555 1
	ifp->if_flags &= ~IFF_OACTIVE;
d5578 1
a5578 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d5584 1
a5584 1
			ifp->if_flags |= IFF_OACTIVE;
d5647 2
a5648 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.66
log
@You need <netinet/ip.h> if you use "struct ip" for hw checksum.

You never need <netinet/ip_var.h> nor <netinet/in_systm.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.65 2015/11/24 13:45:06 mpi Exp $	*/
a131 1
#include <net/if_dl.h>
@


1.65
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.64 2015/11/24 13:33:17 mpi Exp $	*/
a135 1
#include <netinet/in_systm.h>
a136 1
#include <netinet/ip.h>
@


1.64
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.63 2015/11/04 12:11:59 dlg Exp $	*/
a131 1
#include <net/if_arp.h>
@


1.63
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.62 2015/10/25 13:04:28 mpi Exp $	*/
a134 1
#include <net/if_types.h>
@


1.62
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.61 2015/10/22 11:51:28 jsg Exp $	*/
d5594 1
a5594 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
@


1.61
log
@remove some horrible iwm typedefs
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.60 2015/10/16 12:17:58 stsp Exp $	*/
a5691 1
	struct ifaddr *ifa;
a5711 3
		ifa = (struct ifaddr *)data;
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.60
log
@Put some iwm(4) debug code into #ifdef IWM_DEBUG.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.59 2015/10/16 12:17:38 stsp Exp $	*/
d409 1
a409 1
int	iwm_ioctl(struct ifnet *, u_long, iwm_caddr_t);
d418 1
a418 1
void	iwm_attach_hook(iwm_hookarg_t);
d5688 1
a5688 1
iwm_ioctl(struct ifnet *ifp, u_long cmd, iwm_caddr_t data)
d6379 1
a6379 1
iwm_attach_hook(iwm_hookarg_t arg)
@


1.59
log
@Clean up iwm(4) scanning logic a bit: Reset sc_scanband in callers of
iwm_mvm_scan_request() and always call ieee80211_end_scan() when done.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.58 2015/10/16 10:29:55 stsp Exp $	*/
d410 1
a411 1
#ifdef IWM_DEBUG
d5762 1
a5853 1
#ifdef IWM_DEBUG
@


1.58
log
@Oops, committed old version of previous diff with a typo in it: NLL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.57 2015/10/16 10:04:56 stsp Exp $	*/
a4623 1
		sc->sc_scanband = 0;
d5327 3
a5329 1
			printf("%s: could not initiate scan\n", DEVNAME(sc));
d5414 2
a5415 1
			printf("%s: could not initiate scan\n", DEVNAME(sc));
d5423 1
a5423 5
		if (!sc->sc_scanband) {
			ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;
		} else {
			ieee80211_end_scan(&ic->ic_if);
		}
@


1.57
log
@In iwm(4), correctly size and map the mbuf used for large firmware commands.
Fixes occasional firmware errors while bringing the interface up or scanning.
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.56 2015/10/12 10:01:27 stsp Exp $	*/
d3411 1
a3411 1
		m = MCLGETI(NULL, M_DONTWAIT, NLL, totlen);
@


1.56
log
@Always initialise the index into iwm's tx queue array, fixing a
potential crash. This must have somehow been working by magic.
Fruther cleanup of QoS support in this driver is very much needed.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.55 2015/10/11 10:22:28 stsp Exp $	*/
d1111 1
d1118 8
a1125 2
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    IWM_NUM_OF_TBS - 2, MCLBYTES, 0, BUS_DMA_NOWAIT,
d3403 5
a3407 2
		/* Command is too large */
		if (sizeof(cmd->hdr) + paylen > IWM_RBUF_SIZE) {
d3411 1
a3411 1
		m = m_gethdr(M_DONTWAIT, MT_DATA);
d3413 2
a3414 6
			error = ENOMEM;
			goto out;
		}
		MCLGETI(m, M_DONTWAIT, NULL, IWM_RBUF_SIZE);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m);
d3420 1
a3420 1
		    hcmd->len[0], NULL, BUS_DMA_NOWAIT | BUS_DMA_WRITE);
d3422 2
d3427 1
a3427 1
		data->m = m;
d3458 3
a3460 3
	if (hcmd->len[0] > sizeof(cmd->data)) {
		bus_dmamap_sync(sc->sc_dmat, data->map, 0, hcmd->len[0],
		    BUS_DMASYNC_PREWRITE);
d3464 1
a3464 1
		    hcmd->len[0] + 4, BUS_DMASYNC_PREWRITE);
@


1.55
log
@Add a symbolic name for the special '-1' value of iwm's sc_wantresp.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.54 2015/10/10 19:04:57 stsp Exp $	*/
d5575 1
a5575 1
	int ac;
a5590 1
			ac = 0;
@


1.54
log
@In iwm(4), set mbuf pointers to NULL after freeing mbufs.
ok phessler mpi zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.53 2015/10/06 09:12:00 stsp Exp $	*/
d3377 1
a3377 1
		while (sc->sc_wantresp != -1)
d3576 1
a3576 1
	KASSERT(sc->sc_wantresp != -1);
d3579 1
a3579 1
	sc->sc_wantresp = -1;
d6455 1
a6455 1
	sc->sc_wantresp = -1;
@


1.53
log
@Make iwm(4) set the MAC address the same way other wireless drivers do.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.52 2015/10/05 13:05:08 stsp Exp $	*/
d1065 1
d1173 1
@


1.52
log
@Simplify iwm(4) newstate task by only queuing one state transition
at a time. The newstate task now always transitions to the most
recently requested state, rather than hopping along with every request.

This allows us get rid of the silly newstate generation counter, and
we can now task_del() a pending transition when the interface goes down.
While several issues with this driver remain, I believe this change
does not introduce new problems.

Tested by myself, jasper@@, and zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.51 2015/09/27 16:53:38 stsp Exp $	*/
a5731 5
	case SIOCSIFLLADDR:
		IEEE80211_ADDR_COPY(sc->sc_ic.ic_myaddr,
		    ((struct arpcom *)ifp)->ac_enaddr);
		break;

d6321 4
a6324 1
	if (attached)
d6326 1
@


1.51
log
@Fix bsd.rd upgrades over iwm(4), and fix `ifconfig iwm0 lladdr random`.

The bsd.rd problems happened because of the net80211 detach/attach hack
which ran when the firmware is loaded for the first time.
Do the minimum of what needs to be done instead.

To fix lladdr random pick up a changing MAC address in the ioctl handler
and don't overwrite a custom MAC address while loading the firmware.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.50 2015/09/27 16:52:35 stsp Exp $	*/
a197 8
struct iwm_newstate_state {
	struct task ns_wk;
	struct ieee80211com *ns_ic;
	enum ieee80211_state ns_nstate;
	int ns_arg;
	int ns_generation;
};

d401 1
a401 1
void	iwm_newstate_cb(void *);
d5258 1
a5258 1
iwm_newstate_cb(void *wk)
d5260 4
a5263 4
	struct iwm_newstate_state *iwmns = (void *)wk;
	struct ieee80211com *ic = iwmns->ns_ic;
	enum ieee80211_state nstate = iwmns->ns_nstate;
	int generation = iwmns->ns_generation;
d5265 1
a5265 3
	int arg = iwmns->ns_arg;
	struct ifnet *ifp = IC2IFP(ic);
	struct iwm_softc *sc = ifp->if_softc;
a5267 14
	free(iwmns, M_DEVBUF, sizeof(*iwmns));

	DPRINTF(("Prepare to switch state %s->%s\n",
	    ieee80211_state_name[ic->ic_state],
	    ieee80211_state_name[nstate]));
	if (sc->sc_generation != generation) {
		DPRINTF(("newstate_cb: someone pulled the plug meanwhile\n"));
		if (nstate == IEEE80211_S_INIT) {
			DPRINTF(("newstate_cb: nstate == IEEE80211_S_INIT: calling sc_newstate()\n"));
			sc->sc_newstate(ic, nstate, arg);
		}
		return;
	}

d5269 1
a5269 1
	    ieee80211_state_name[ic->ic_state],
d5272 1
a5272 1
	if (ic->ic_state == IEEE80211_S_SCAN && nstate != ic->ic_state)
d5276 1
a5276 1
	if (ic->ic_state == IEEE80211_S_RUN && nstate != ic->ic_state) {
d5279 2
a5373 1
	struct iwm_newstate_state *iwmns;
d5379 2
a5380 10
	iwmns = malloc(sizeof(*iwmns), M_DEVBUF, M_NOWAIT);
	if (!iwmns) {
		DPRINTF(("%s: allocating state cb mem failed\n", DEVNAME(sc)));
		return ENOMEM;
	}

	iwmns->ns_ic = ic;
	iwmns->ns_nstate = nstate;
	iwmns->ns_arg = arg;
	iwmns->ns_generation = sc->sc_generation;
d5382 1
a5382 2
	task_set(&iwmns->ns_wk, iwm_newstate_cb, iwmns);
	task_add(sc->sc_nswq, &iwmns->ns_wk);
d5647 4
a5650 2
	if (ic->ic_state != IEEE80211_S_INIT)
		ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
d6587 1
d6661 1
a6661 2
	iwm_init_task(sc);

@


1.50
log
@Align the way iwm(4) adds the MAC context with how it's done in Linux iwlwifi.
Noted by Adrian Chadd (FreeBSD).
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.49 2015/09/26 10:52:09 stsp Exp $	*/
d2806 4
a2809 2
		memcpy(&sc->sc_ic.ic_myaddr,
		    &sc->sc_nvm.hw_addr, ETHER_ADDR_LEN);
d5762 5
d6383 8
a6390 3
	/* Reattach net80211 so MAC address and channel map are picked up. */
	ieee80211_ifdetach(ifp);
	ieee80211_ifattach(ifp);
@


1.49
log
@Make iwm(4) DPRINTFs show states by name instead of number.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.48 2015/09/23 17:22:18 stsp Exp $	*/
d4637 2
a4638 1
	if (IEEE80211_IS_CHAN_2GHZ(ni->ni_chan)) {
a5001 5
	if ((error = iwm_mvm_mac_ctxt_add(sc, in)) != 0) {
		DPRINTF(("%s: failed to add MAC\n", DEVNAME(sc)));
		return error;
	}

d5454 1
d5517 6
@


1.48
log
@In iwm(4), properly reset the RX ring by clearing RX buffer status memory.
Found by Matthew Dillon (Dragonfly). DMA sync hint from tedu@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.47 2015/09/23 17:21:50 stsp Exp $	*/
d5282 3
a5284 1
	DPRINTF(("Prepare to switch state %d->%d\n", ic->ic_state, nstate));
d5294 3
a5296 1
	DPRINTF(("switching state %d->%d\n", ic->ic_state, nstate));
d6236 2
a6237 1
		DPRINTF(("  802.11 state %d\n", sc->sc_ic.ic_state));
@


1.47
log
@In iwm(4), while not associated, pass the broadcast ethernet address to
the firmware, rather than zeros. Matches what Linux iwlwifi does.
Spotted by Adrian Chadd (FreeBSD).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.46 2015/07/19 21:40:00 stsp Exp $	*/
d1049 6
@


1.46
log
@Make iwm(4) show command codes of unhandled firmware replies. Should make
debugging easier when it happens, as observed by matthieu@@ (not reproducible
on demand, unfortunately).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.45 2015/06/15 08:06:11 stsp Exp $	*/
d4721 1
a4721 1
		memset(cmd->bssid_addr, 0, sizeof(cmd->bssid_addr));
@


1.45
log
@Remove comments referring to Linux iwlwifi source filenames from iwm(4).
Linux is a moving target so these comments provide little value.
Discussed with kettenis and deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.44 2015/06/15 07:50:44 stsp Exp $	*/
d6117 4
a6120 3
			printf("%s: frame %d/%d %x UNHANDLED (this should "
			    "not happen)\n", DEVNAME(sc), qid, idx,
			    pkt->len_n_flags);
@


1.44
log
@Make the wifi LED work with iwm(4).

The bad news: Many laptops sold with iwm(4) cards don't have a wifi LED :-(
The good news: Laptops with LEDs and no wifi device white-list in BIOS
actually exist! Tested in one such machine.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.43 2015/06/12 13:11:27 stsp Exp $	*/
a484 1
/* iwlwifi: iwl-drv.c */
a741 1
/* iwlwifi: pcie/trans.c */
a758 1
/* iwlwifi: pcie/trans.c */
a1435 1
/* iwlwifi/pcie/trans.c */
a1448 1
/* iwlwifi pcie/trans.c */
a1471 1
/* iwlwifi pcie/trans.c */
a1541 1
/* iwlwifi pcie/trans.c (always main power) */
a1548 1
/* iwlwifi: mvm/ops.c */
a1816 5
 * iwlwifi/iwl-phy-db.c
 */

/*
 * BEGIN iwl-phy-db.c
a2130 8
 * END iwl-phy-db.c
 */

/*
 * BEGIN iwlwifi/mvm/time-event.c
 */

/*
a2244 4
 * END iwlwifi/mvm/time-event.c
 */

/*
a2246 1
 * iwlwifi/mvm/nvm.c
a2370 2
/* iwlwifi/iwl-nvm-parse.c */

a2688 1
/* iwlwifi: pcie/trans.c */
a2735 1
/* iwlwifi: mvm/fw.c */
a2777 3
/*
 * follows iwlwifi/fw.c
 */
a2890 1
/* iwlwifi: mvm/rx.c */
a2920 1
/* iwlwifi: mvm/rx.c */
a3185 4
/*
 * BEGIN iwlwifi/mvm/binding.c
 */

a3235 8
 * END iwlwifi/mvm/binding.c
 */

/*
 * BEGIN iwlwifi/mvm/phy-ctxt.c
 */

/*
a3339 4
 * END iwlwifi/mvm/phy-ctxt.c
 */

/*
a3502 1
/* iwlwifi: mvm/utils.c */
a3516 1
/* iwlwifi: mvm/utils.c */
a3557 1
/* iwlwifi/mvm/utils.c */
a3929 4
/*
 * BEGIN mvm/led.c
 */

a3943 4
/*
 * END mvm/led.c
 */

a3975 4
/*
 * BEGIN mvm/power.c
 */

a4186 8
/*
 * END mvm/power.c
 */

/*
 * BEGIN mvm/sta.c
 */

a4333 8
/*
 * END mvm/sta.c
 */

/*
 * BEGIN mvm/scan.c
 */

a4619 8
/*
 * END mvm/scan.c
 */

/*
 * BEGIN mvm/mac-ctxt.c
 */

a4905 8
/*
 * END mvm/mac-ctxt.c
 */

/*
 * BEGIN mvm/quota.c
 */

a4972 4
 * END mvm/quota.c
 */

/*
a5770 4
 * error dumping routines are from iwlwifi/mvm/utils.c
 */

/*
d6073 1
a6073 1
		case 0x6c: /* IWM_PHY_DB_CMD, no idea why it's not in fw-api.h */
@


1.43
log
@Actually trigger iwm_init_task() from iwm_watchdog() as intended to give
recovery after device timeout a chance. Don't mess with the IFF_UP flag
in the watchdog since this isn't done anywhere except intel wifi drivers
which probably copied this pattern amongst each other.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.42 2015/05/30 02:49:23 deraadt Exp $	*/
d350 6
d3984 53
d5390 3
d5438 1
d5477 1
a5477 1

d5770 1
d6694 1
@


1.42
log
@cleanup attach message
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.41 2015/05/22 06:50:54 kettenis Exp $	*/
d5723 1
a5723 2
			ifp->if_flags &= ~IFF_UP;
			iwm_stop(ifp, 1);
@


1.41
log
@Limit the number of dma segments used for transmitting packets to
IWM_NUM_OF_TBS - 2.  We have IWM_NUM_OF_TBS slots, but use two of those
for sending commands to the firmware.  Hopefully fixes the

  iwm0: hardware error, stopping device

errors I've seen somewhat regularly.

ok claudio@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.40 2015/05/21 22:13:55 kettenis Exp $	*/
d6392 1
a6392 1
	printf("%s: hw rev: 0x%x, fw ver %d.%d (API ver %d), address %s\n",
@


1.40
log
@Use m_defrag(9) instead of rolling our own version of it.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.39 2015/03/23 00:35:19 jsg Exp $	*/
d1116 2
a1117 1
		    IWM_NUM_OF_TBS, MCLBYTES, 0, BUS_DMA_NOWAIT, &data->map);
@


1.39
log
@Not all iwm hardware supports the 5GHz band.  Make setting 11a rates
and scanning conditional on the 5GHz support bit in the nvm.

Problem reported and fix tested by Mattieu Baptiste.

ok stsp@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.38 2015/03/16 04:09:53 jsg Exp $	*/
a3747 1
	struct mbuf *m1;
d3882 6
a3887 7
	if (error != 0) {
		if (error != EFBIG) {
			printf("%s: can't map mbuf (error %d)\n", DEVNAME(sc),
			    error);
			m_freem(m);
			return error;
		}
d3889 1
a3889 2
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
a3892 13
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(m1);
				return ENOBUFS;
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m1, void *));
		m1->m_pkthdr.len = m1->m_len = m->m_pkthdr.len;
		m_freem(m);
		m = m1;

d3895 1
a3895 1
		if (error != 0) {
@


1.38
log
@convert timeout_add() calls using hz to timeout_add_msec()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.37 2015/03/11 12:24:44 jsg Exp $	*/
d5474 2
a5475 1
	if (sc->sc_scanband == IEEE80211_CHAN_2GHZ) {
d6413 5
@


1.37
log
@Match on 3160.  Untested but should work.
ok stsp@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.36 2015/03/06 18:39:24 kettenis Exp $	*/
d5206 1
a5206 1
	timeout_add(&sc->sc_calib_to, hz/2);
d5428 1
a5428 1
		timeout_add(&sc->sc_calib_to, hz/2);
@


1.36
log
@Fix radiotap and fixed rates.  Radiotap was reporting the wrong rate for
data frames and fixed rates weren't really fixed and were converted into
the wrong hardware rate.

ok jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.35 2015/03/04 15:18:12 jsg Exp $	*/
d6363 2
@


1.35
log
@stop the calibration timeout when stopping the interface
ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.34 2015/03/03 20:14:34 kettenis Exp $	*/
d3702 1
d3706 1
a3706 1
	int nrates = in->in_ni.ni_rates.rs_nrates;
d3711 9
a3719 7
	/* for data frames, use RS table */
	if (type == IEEE80211_FC0_TYPE_DATA) {
		if (ic->ic_fixed_rate != -1) {
			tx->initial_rate_index = sc->sc_fixed_ridx;
		} else {
			tx->initial_rate_index = (nrates-1) - in->in_ni.ni_txrate;
		}
d3722 2
a3723 1
		return &iwm_rates[tx->initial_rate_index];
a3725 3
	/* for non-data, use the lowest supported rate */
	ridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
	    IWM_RIDX_OFDM : IWM_RIDX_CCK;
a3726 1

@


1.34
log
@Set/clear the IWM_MAC_FILTER_IN_BEACON flag under conditions that match what
Linux does.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.33 2015/03/03 06:56:12 kettenis Exp $	*/
d5720 1
@


1.33
log
@Fix 11a support.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.32 2015/03/02 22:50:10 jsg Exp $	*/
d4884 3
a4886 1
	if (in->in_assoc)
@


1.32
log
@match on 7265
ok kettenis@@ stsp@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.31 2015/03/02 22:31:03 jsg Exp $	*/
a174 3
/* It looks like 11a TX is broken, unfortunately. */
#define IWM_NO_5GHZ		1

a2522 1
#ifndef IWM_NO_5GHZ
a2523 3
#else
	data->sku_cap_band_52GHz_enable = 0;
#endif
d3701 1
d3712 1
a3712 1
		if (sc->sc_ic.ic_fixed_rate != -1) {
d3723 2
a3724 1
	ridx = in->in_ridx[0];
d4670 1
d4677 6
a4682 4
	for (i = 0; i <= IWM_LAST_CCK_RATE; i++) {
		cck |= (1 << i);
		if (lowest_present_cck > i)
			lowest_present_cck = i;
a5472 1
#ifndef IWM_NO_5GHZ
a5480 3
#else
		done = 1;
#endif
a6601 1
#ifndef IWM_NO_5GHZ
a6602 1
#endif
@


1.31
log
@Make setting the MAC context bit for 11g protection when transmitting
OFDM frames conditional on the node via IEEE80211_F_USEPROT.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.30 2015/03/02 22:19:12 jsg Exp $	*/
d6368 2
@


1.30
log
@Don't set CTS to self.  Linux stopped setting this back in
dc271ee0d04d12d6bfabacbec803289a7072fbd9 as it is known
to cause problems.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.29 2015/03/02 22:12:57 jsg Exp $	*/
d4792 2
a4793 1
	cmd->protection_flags |= htole32(IWM_MAC_PROT_FLG_TGG_PROTECT);
@


1.29
log
@sc_fixed_ridx is initialised to 0 but tested as it it were initialised
to -1.  The result of this is tx frames were always sent out at fixed
rate 0 instead of ni_txrate.

Match the iwn behaviour and test ic_fixed_rate for -1 instead.
Problem spotted by kettenis@@ in an earlier diff.

ok kettenis@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.28 2015/03/02 13:59:38 jsg Exp $	*/
a4792 1
	cmd->protection_flags |= htole32(IWM_MAC_PROT_FLG_SELF_CTS_EN);
@


1.28
log
@Correctly set lowest_present_ofdm in iwm_mvm_ack_rates().
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.27 2015/03/02 13:56:30 jsg Exp $	*/
d3718 1
a3718 1
		if (sc->sc_fixed_ridx != -1) {
@


1.27
log
@init error to 0 in iwm_send_cmd()
ok stsp@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.26 2015/03/02 13:53:41 jsg Exp $	*/
d4689 2
a4690 2
		if (lowest_present_ofdm > adj)
			lowest_present_ofdm = adj;
@


1.26
log
@match iwn and init txrate at lowest available bit-rate
ok stsp@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.25 2015/03/02 13:51:10 jsg Exp $	*/
d3411 1
a3411 1
	int error, i, paylen, off, s;
@


1.25
log
@workaround for interrupt coalescing bug not needed on 7265
ok kettenis@@ stsp@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.24 2015/03/02 13:46:40 jsg Exp $	*/
d5285 2
a5286 1
	ni->ni_txrate = nrates-1;
@


1.24
log
@load the correct firmware for 3160/7265
ok kettenis@@ stsp@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.23 2015/03/01 14:56:34 kettenis Exp $	*/
d1388 21
a1408 19
	/*
	 * This is a bit of an abuse - This is needed for 7260 / 3160
	 * only check host_interrupt_operation_mode even if this is
	 * not related to host_interrupt_operation_mode.
	 *
	 * Enable the oscillator to count wake up time for L1 exit. This
	 * consumes slightly more power (100uA) - but allows to be sure
	 * that we wake up from L1 on time.
	 *
	 * This looks weird: read twice the same register, discard the
	 * value, set a bit, and yet again, read that same register
	 * just to discard the value. But that's the way the hardware
	 * seems to like it.
	 */
	iwm_read_prph(sc, IWM_OSC_CLK);
	iwm_read_prph(sc, IWM_OSC_CLK);
	iwm_set_bits_prph(sc, IWM_OSC_CLK, IWM_OSC_CLK_FORCE_CONTROL);
	iwm_read_prph(sc, IWM_OSC_CLK);
	iwm_read_prph(sc, IWM_OSC_CLK);
d1633 4
a1636 1
	IWM_SETBITS(sc, IWM_CSR_INT_COALESCING, IWM_HOST_INT_OPER_MODE);
d6513 1
d6518 1
d6523 1
@


1.23
log
@Correctly set lowest_present_ofdm in iwm_mvm_ack_rates().

ok phessler@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.22 2015/02/23 09:40:47 stsp Exp $	*/
d6504 17
a6520 2
	/* only one firmware possibility for now */
	sc->sc_fwname = IWM_FWNAME;
@


1.22
log
@Make iwm(4) re-read the firmware image from disk on if down/up like other
drivers do. While here remove unused fields from struct iwm_fw_info.
test and ok brad@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.21 2015/02/21 09:53:49 stsp Exp $	*/
d4684 2
a4685 2
		if (lowest_present_cck > adj)
			lowest_present_cck = adj;
@


1.21
log
@In iwm(4), fix an inverted check for hardware-ready state. From NetBSD.
Pointed out by brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.20 2015/02/20 14:08:18 stsp Exp $	*/
d213 2
a214 1
int	iwm_read_firmware(struct iwm_softc *);
a475 4
	/* for freeing the buffer during driver unload */
	fwone->fws_alloc = data;
	fwone->fws_allocsize = dlen;

d508 10
d519 1
a519 1
iwm_read_firmware(struct iwm_softc *sc)
d526 1
a526 1
	int error, status;
d529 7
a535 7
	if (fw->fw_status == IWM_FW_STATUS_NONE) {
		fw->fw_status = IWM_FW_STATUS_INPROGRESS;
	} else {
		while (fw->fw_status == IWM_FW_STATUS_INPROGRESS)
			tsleep(&sc->sc_fw, 0, "iwmfwp", 0);
	}
	status = fw->fw_status;
d537 2
a538 2
	if (status == IWM_FW_STATUS_DONE)
		return 0;
d697 2
a698 2
		printf("%s: firmware parse error, "
		    "section type %d\n", DEVNAME(sc), tlv_type);
d707 1
a707 1
	if (error)
d709 3
a711 1
	else
a714 4
	if (error) {
		free(fw->fw_rawdata, M_DEVBUF, fw->fw_rawsize);
		fw->fw_rawdata = NULL;
	}
d2786 1
a2786 1
	if ((error = iwm_read_firmware(sc)) != 0)
@


1.20
log
@Whitespace fixes for iwm(4) code. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.19 2015/02/20 13:39:08 stsp Exp $	*/
d1284 1
a1284 1
	if (!iwm_set_hw_ready(sc))
@


1.19
log
@Make the iwm(4) hardware receive filter pass multicast traffic.
Fixes inet6 autoconf, for example.
Reported and fix tested by matthieu and brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.18 2015/02/11 01:12:42 brad Exp $	*/
d223 1
a223 1
				uint32_t); 
d515 2
a516 2
        struct iwm_tlv_ucode_header *uhdr;
        struct iwm_ucode_tlv tlv;
d1191 1
a1191 1
	
d1271 1
a1271 1
        return iwm_poll_bit(sc, IWM_CSR_HW_IF_CONFIG_REG,
d1451 1
a1451 1
        /* Reset the entire device */
d1522 3
a1524 3
        /* Upon stop, the APM issues an interrupt if HW RF kill is set.
         * Clean again the interrupt here
         */
d1572 2
a1573 2
        DPRINTF(("Radio type=0x%x-0x%x-0x%x\n", radio_cfg_type,
                       radio_cfg_step, radio_cfg_dash));
d1692 1
a1692 1
        return 0;
d1704 4
a1707 4
        IWM_MVM_TX_FIFO_VO,
        IWM_MVM_TX_FIFO_VI,
        IWM_MVM_TX_FIFO_BE,
        IWM_MVM_TX_FIFO_BK,
d1800 1
a1800 1
        /* Enable L1-Active */
d2559 2
a2560 2
        uint16_t length;
        const uint8_t *data;
d2651 1
a2651 1
	    (iwm_get_dma_hi_addr(dma->paddr)	
d2661 1
a2661 1
    
d2669 1
a2669 1
        return error;
d2785 1
a2785 1
        error = iwm_start_fw(sc, ucode_type);
d2814 1
a2814 1
        if ((error = iwm_mvm_load_ucode_wait_alive(sc,
d2906 1
a2906 1
        /* Update RX descriptor. */
d3157 1
a3157 1
iwm_mvm_rx_tx_cmd(struct iwm_softc *sc, 
d3376 1
a3376 1
/* 
d3713 1
a3713 1
                tx->tx_flags |= htole32(IWM_TX_CMD_FLG_STA_RATE);
d3847 6
a3852 6
        if (hdrlen & 3) {
                /* First segment length must be a multiple of 4. */
                flags |= IWM_TX_CMD_FLG_MH_PAD;
                pad = 4 - (hdrlen & 3);
        } else
                pad = 0;
d5069 1
a5069 1
	
d5220 1
a5220 1
		
d5523 2
a5524 2
        if ((error = iwm_send_tx_ant_cfg(sc, IWM_FW_VALID_TX_ANT(sc))) != 0)
                goto error;
d5526 3
a5528 3
        /* Send phy db control command and then phy db calibration*/
        if ((error = iwm_send_phy_db_data(sc)) != 0)
                goto error;
d5530 2
a5531 2
        if ((error = iwm_send_phy_cfg_cmd(sc)) != 0)
                goto error;
d5548 3
a5550 3
        error = iwm_mvm_power_update_device(sc);
        if (error)
                goto error;
d5634 1
a5634 1
        struct ether_header *eh;
d5662 5
a5666 5
                if (m->m_len < sizeof (*eh) &&
                    (m = m_pullup(m, sizeof (*eh))) == NULL) {
                        ifp->if_oerrors++;
                        continue;
                }
d6149 1
a6149 1
			
d6662 1
a6662 1
	
d6667 1
a6667 1
  
@


1.18
log
@g/c sys/cdefs.h header.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.17 2015/02/11 00:57:49 stsp Exp $	*/
d254 1
d5038 5
d5564 26
d6161 3
@


1.17
log
@Prevent processes from entering iwm_ioctl while another process is
tsleep'ing in it. From iwn(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.16 2015/02/11 00:53:37 stsp Exp $	*/
a106 2

#include <sys/cdefs.h>
@


1.16
log
@Show error code in DPRINTF error messages within iwm_send_phy_db_data.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.15 2015/02/10 23:40:43 stsp Exp $	*/
d5721 12
d5775 2
@


1.15
log
@Testing indicates TX is broken for 11a in iwm(4) so stop advertising 11a
support to the net80211 layer for now. Discussed with phessler.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.14 2015/02/10 23:25:46 mpi Exp $	*/
d2081 2
a2082 1
		DPRINTF(("%s: Cannot get Phy DB cfg section\n", DEVNAME(sc)));
d2088 2
a2089 2
		DPRINTF(("%s: Cannot send HCMD of  Phy DB cfg section\n",
		    DEVNAME(sc)));
d2096 2
a2097 2
		DPRINTF(("%s: Cannot get Phy DB non specific channel section\n",
		    DEVNAME(sc)));
d2112 2
a2113 2
		DPRINTF(("%s: Cannot send channel specific PAPD groups\n",
		    DEVNAME(sc)));
d2121 2
a2122 2
		DPRINTF(("%s: Cannot send channel specific TX power groups\n",
		    DEVNAME(sc)));
@


1.14
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.13 2015/02/10 22:32:04 stsp Exp $	*/
d177 1
d2516 1
d2518 3
d5459 1
a5459 1
#ifndef IWM_NO_5GHZ /* for quick testing, makes scan few sec faster */
d6529 1
d6531 1
@


1.13
log
@In iwm(4), call ieee80211_media_init() after overriding net80211 state
machine methods, like other drivers do.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.12 2015/02/10 22:09:11 stsp Exp $	*/
a3065 2

	m->m_pkthdr.rcvif = IC2IFP(ic);
@


1.12
log
@The attach procedure of iwm(4) was setting up the MAC address correctly
but forgot about other information obtained from firmware, like the map of
supported channels. Completely re-attach the net80211 layer after first
successful firmware load. Fixes output of 'ifconfig iwm0 media'.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.11 2015/02/10 20:52:58 stsp Exp $	*/
a6352 1
	ieee80211_media_init(ifp, iwm_media_change, ieee80211_media_status);
d6359 1
@


1.11
log
@In iwm(4), don't reinvent the standard rate set tables.
Just use the equivalent definitions provided by net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.10 2015/02/10 20:34:18 stsp Exp $	*/
a2798 1
	struct ifnet *ifp = IC2IFP(&sc->sc_ic);
a2819 4
		memcpy((caddr_t)((struct arpcom *)ifp)->ac_enaddr,
			&sc->sc_nvm.hw_addr, ETHER_ADDR_LEN);
		memcpy(LLADDR(ifp->if_sadl), &sc->sc_nvm.hw_addr,
		    ifp->if_addrlen);
d6318 2
d6350 11
a6552 6

	ic->ic_node_alloc = iwm_node_alloc;

	/* Override 802.11 state transition machine. */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = iwm_newstate;
@


1.10
log
@Sync iwm(4)'s fatal firmware error message with the one used by iwn(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.9 2015/02/09 03:51:59 guenther Exp $	*/
a201 12
/*
 * Supported rates for 802.11a/b/g modes (in 500Kbps unit).
 */
const struct ieee80211_rateset iwm_rateset_11a =
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };

const struct ieee80211_rateset iwm_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

const struct ieee80211_rateset iwm_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d6518 3
a6520 3
	ic->ic_sup_rates[IEEE80211_MODE_11A] = iwm_rateset_11a;
	ic->ic_sup_rates[IEEE80211_MODE_11B] = iwm_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = iwm_rateset_11g;
@


1.9
log
@Add flag to taskq_create() calls to match dlg@@ API change

ok phessler@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.8 2015/02/09 00:26:27 phessler Exp $	*/
d6243 1
a6243 1
		printf("%s: firmware error, stopping device\n", DEVNAME(sc));
@


1.8
log
@after many days of coding, enable WEP
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.7 2015/02/08 23:30:21 stsp Exp $	*/
d6508 1
a6508 1
	sc->sc_eswq = taskq_create("iwmes", 1, IPL_NET);
d6511 1
a6511 1
	sc->sc_nswq = taskq_create("iwmns", 1, IPL_NET);
@


1.7
log
@Fix iwm(4) attach and firmware loading process such that a reboot after
fw_update isn't required anymore. An iwm0 interface now appears if the
firmware isn't installed at boot, but it has no MAC address. Firmware is
now reloaded on ifconfig down/up and the MAC address is set if successful.
test + ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.6 2015/02/08 16:07:15 stsp Exp $	*/
d6524 1
@


1.6
log
@Add missing \n to DPRINTFs in iwm(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.5 2015/02/08 13:43:28 stsp Exp $	*/
a543 4
	else if (status < 0)
		return -status;

	KASSERT(status == IWM_FW_STATUS_INPROGRESS);
d712 3
a714 4
	if (error) {
		KASSERT(error > 0);
		fw->fw_status = -error;
	} else {
a715 1
	}
d2811 1
d2833 4
d5505 1
a5505 1
	if ((error = iwm_prepare_card_hw(sc)) != 0)
d5520 2
a5521 1
	if ((error = iwm_start_hw(sc)) != 0)
d5523 1
d6336 1
d6338 2
a6339 1
	if ((error = iwm_prepare_card_hw(sc)) != 0)
d6341 1
d6343 2
a6344 2
	if ((error = iwm_start_hw(sc)) != 0)
		return error;
d6346 2
a6347 1
	if ((error = iwm_run_init_mvm_ucode(sc, 1)) != 0) {
d6351 1
d6353 12
d6372 13
d6387 1
d6391 58
a6448 1
	KASSERT(!cold);
a6517 11
	if ((error = iwm_preinit(sc)) != 0) {
		goto fail4;
	}

	printf("%s: hw rev: 0x%x, fw ver %d.%d (API ver %d), address %s\n",
	    DEVNAME(sc), sc->sc_hw_rev & IWM_CSR_HW_REV_TYPE_MSK,
	    IWM_UCODE_MAJOR(sc->sc_fwver),
	    IWM_UCODE_MINOR(sc->sc_fwver),
	    IWM_UCODE_API(sc->sc_fwver),
	    ether_sprintf(sc->sc_nvm.hw_addr));
	
d6570 9
a6589 83
}

void
iwm_attach(struct device *parent, struct device *self, void *aux)
{
	struct iwm_softc *sc = (void *)self;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
	pcireg_t reg, memtype;
	const char *intrstr;
	int error;

	sc->sc_pct = pa->pa_pc;
	sc->sc_pcitag = pa->pa_tag;
	sc->sc_dmat = pa->pa_dmat;

	task_set(&sc->sc_eswk, iwm_endscan_cb, sc);

	/*
	 * Get the offset of the PCI Express Capability Structure in PCI
	 * Configuration Space.
	 */
	error = pci_get_capability(sc->sc_pct, sc->sc_pcitag,
	    PCI_CAP_PCIEXPRESS, &sc->sc_cap_off, NULL);
	if (error == 0) {
		printf("%s: PCIe capability structure not found!\n",
		    DEVNAME(sc));
		return;
	}

	/* Clear device-specific "PCI retry timeout" register (41h). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, reg & ~0xff00);

	/* Enable bus-mastering and hardware bug workaround. */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, PCI_COMMAND_STATUS_REG);
	reg |= PCI_COMMAND_MASTER_ENABLE;
	/* if !MSI */
	if (reg & PCI_COMMAND_INTERRUPT_DISABLE) {
		reg &= ~PCI_COMMAND_INTERRUPT_DISABLE;
	}
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, PCI_COMMAND_STATUS_REG, reg);

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, PCI_MAPREG_START);
	error = pci_mapreg_map(pa, PCI_MAPREG_START, memtype, 0,
	    &sc->sc_st, &sc->sc_sh, NULL, &sc->sc_sz, 0);
	if (error != 0) {
		printf("%s: can't map mem space\n", DEVNAME(sc));
		return;
	}

	/* Install interrupt handler. */
	if (pci_intr_map_msi(pa, &ih) && pci_intr_map(pa, &ih)) {
		printf("%s: can't map interrupt\n", DEVNAME(sc));
		return;
	}

	intrstr = pci_intr_string(sc->sc_pct, ih);
	sc->sc_ih = pci_intr_establish(sc->sc_pct, ih, IPL_NET, iwm_intr, sc,
	    DEVNAME(sc));

	if (sc->sc_ih == NULL) {
		printf("\n");
		printf("%s: can't establish interrupt", DEVNAME(sc));
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(", %s\n", intrstr);

	/*
	 * We can't do normal attach before the file system is mounted
	 * because we cannot read the MAC address without loading the
	 * firmware from disk.  So we postpone until mountroot is done.
	 * Notably, this will require a full driver unload/load cycle
	 * (or reboot) in case the firmware is not present when the
	 * hook runs.
	 */
	if (rootvp == NULL)
		mountroothook_establish(iwm_attach_hook, sc);
	else
		iwm_attach_hook(sc);
@


1.5
log
@In iwm(4), convert many verbose printf do DPRINTF, sync some string constants
with iwn(4), and remove a few printf which don't appear in iwn(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.4 2015/02/07 19:04:41 stsp Exp $	*/
d2076 1
a2076 1
			    "err %d", DEVNAME(sc), type, i, err));
d2128 1
a2128 1
		DPRINTF(("%s: Cannot send channel specific PAPD groups",
d2137 1
a2137 1
		DPRINTF(("%s: Cannot send channel specific TX power groups",
@


1.4
log
@Don't panic on unhandled net80211 state transitions in iwm(4).
Other drivers don't do this either.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.3 2015/02/07 07:10:44 phessler Exp $	*/
d427 1
d429 1
d510 2
a511 2
		printf("%s: Wrong ucode_type %u for default "
		    "calibration.\n", DEVNAME(sc), ucode_type);
d531 2
a532 1
	int error, status, len;
d556 2
a557 2
		printf("%s: could not read firmware %s\n",
		    DEVNAME(sc), sc->sc_fwname);
d579 1
a579 1
		uint32_t tlv_len;
d591 2
a592 1
			printf("%s: firmware image invalid length\n", DEVNAME(sc));
d607 2
a608 2
				printf("%s: IWM_UCODE_TLV_PROBE_MAX_LEN "
				    "ridiculous\n", DEVNAME(sc));
d649 2
a650 2
				printf("%s: driver supports "
				    "only TLV_NUM_OF_CPU == 1", DEVNAME(sc));
d692 2
a693 2
			printf("%s: unknown firmware section %d, abort\n",
			    DEVNAME(sc), tlv_type);
d775 1
a775 1
	int offs, ret = 0;
d787 2
a788 3
		/* let's just say that it's good to notice this failure */
		printf("%s: WARNING: write_mem failed\n", DEVNAME(sc));
		ret = EBUSY;
d790 1
a790 1
	return ret;
a1036 1
			printf("%s: could not add mbuf to ring", DEVNAME(sc));
a1058 4
		if (ntries == 1000) {
			printf("%s: unable to detect idle rx chan after "
			    "reset\n", DEVNAME(sc));
		}
d1396 2
a1397 1
		printf("%s: Failed to init the card\n", DEVNAME(sc));
d1456 1
a1456 1
		printf("%s: Master Disable Timed Out, 100 usec\n", DEVNAME(sc));
a1515 4
			if (ntries == 200) {
				printf("%s: unable to detect idle tx "
				    "chan after reset\n", DEVNAME(sc));
			}
d1732 2
a1733 2
		printf("%s: cannot enable txq %d\n", DEVNAME(sc), qid);
		return;
d1781 1
a1781 1
		printf("%s: sched addr mismatch", DEVNAME(sc));
d2075 2
a2076 2
			printf("%s: Can't SEND phy_db section %d (%d), err %d",
				DEVNAME(sc), type, i, err);
d2098 1
a2098 1
		printf("%s: Cannot get Phy DB cfg section\n", DEVNAME(sc));
d2104 2
a2105 2
		printf("%s: Cannot send HCMD of  Phy DB cfg section\n",
		    DEVNAME(sc));
d2112 2
a2113 2
		printf("%s: Cannot get Phy DB non specific channel section\n",
		    DEVNAME(sc));
d2119 2
a2120 2
		printf("%s: Cannot send HCMD of Phy DB non specific channel "
		    "sect, %d\n", DEVNAME(sc), err);
d2128 2
a2129 2
		printf("%s: Cannot send channel specific PAPD groups",
		    DEVNAME(sc));
d2137 2
a2138 2
		printf("%s: Cannot send channel specific TX power groups",
		    DEVNAME(sc));
d2232 2
a2233 2
		printf("%s: Couldn't send IWM_TIME_EVENT_CMD: %d\n",
		    DEVNAME(sc), ret);
d2323 2
a2324 2
		printf("%s: Bad return from IWM_NVM_ACCES_COMMAND (0x%08X)\n",
		    DEVNAME(sc), pkt->hdr.flags);
d2337 2
a2338 2
		printf("%s: NVM access command failed with status %d\n",
		    DEVNAME(sc), ret);
d2344 2
a2345 2
		printf("%s: NVM ACCESS response with invalid offset %d\n",
		    DEVNAME(sc), offset_read);
d2537 1
a2537 1
		printf("%s: invalid antennas (0x%x, 0x%x)\n",
d2539 1
a2539 1
			    data->valid_rx_ant);
d2591 1
a2591 1
		printf("%s: Can't parse empty NVM sections\n", DEVNAME(sc));
d2729 1
a2729 1
		printf("%s: Unable to init nic\n", DEVNAME(sc));
d2821 2
a2822 1
		printf("%s: rfkill active, no go\n", DEVNAME(sc));
d2857 2
a2858 2
		printf("%s: Failed to run INIT "
		    "calibrations: %d\n", DEVNAME(sc), error);
d3185 2
a3186 2
		printf("%s: got tx interrupt that's already been handled!\n",
		    DEVNAME(sc));
d3253 2
a3254 2
		printf("%s: Failed to send binding (action:%d): %d\n",
		    DEVNAME(sc), action, ret);
d3259 2
a3260 1
		printf("%s: Binding command failed: %u\n", DEVNAME(sc), status);
d3522 1
a3522 1
		printf("%s: acquiring device failed\n", DEVNAME(sc));
d3776 2
a3777 2
		printf("%s: hdrlen error (%d != %d)\n",
		    DEVNAME(sc), hdrlen, hdrlen2);
d4350 2
a4351 2
		printf("%s: Add internal station failed, status=0x%x\n",
		    DEVNAME(sc), status);
d4511 1
a4511 1
		printf("%s: NO CHANNEL!\n", DEVNAME(sc));
a4661 2
		printf("%s: Scan failed! status 0x%x ret %d\n", DEVNAME(sc),
		    status, ret);
d4809 2
a4810 2
		printf("%s: Failed to send MAC context (action:%d): %d\n",
		    DEVNAME(sc), le32toh(cmd->action), ret);
d5027 1
a5027 1
		printf("%s: Failed to send quota: %d\n", DEVNAME(sc), ret);
d5054 1
a5054 1
		printf("%s: failed to add MAC\n", DEVNAME(sc));
d5060 1
a5060 1
		printf("%s: failed add phy ctxt\n", DEVNAME(sc));
d5066 1
a5066 1
		printf("%s: binding cmd\n", DEVNAME(sc));
d5071 1
a5071 1
		printf("%s: failed to add MAC\n", DEVNAME(sc));
d5092 1
a5092 1
			printf("%s: missed auth window!\n", DEVNAME(sc));
d5095 1
a5095 1
			printf("%s: no time event, denied!\n", DEVNAME(sc));
d5113 1
a5113 1
		printf("%s: failed to update STA\n", DEVNAME(sc));
d5119 1
a5119 1
		printf("%s: failed to update MAC\n", DEVNAME(sc));
d5221 2
a5222 2
		printf("%s: node supports %d rates, driver handles only %zu\n",
		    DEVNAME(sc), nrates, nitems(lq->rs_table));
d5236 2
a5237 1
			printf("%s: WARNING: device rate for %d not found!\n", DEVNAME(sc), rate);
d5380 1
a5380 6
		if (sc->sc_scanband) {
			/* how does this print match the clause? */
			if (ic->ic_state != nstate)
				printf("%s: scan request(%d) "
				    "while scanning(%d) ignored\n",
				    DEVNAME(sc), nstate, ic->ic_state);
a5381 1
		}
d5394 2
a5395 2
			printf("%s: could not move to auth state: %d\n",
			    DEVNAME(sc), error);
d5403 2
a5404 2
			printf("%s: failed to associate: %d\n", DEVNAME(sc),
			    error);
d5424 1
a5424 1
			printf("%s: IWM_LQ_CMD failed\n", DEVNAME(sc));
d5449 1
a5449 1
		printf("%s: allocating state cb mem failed\n", DEVNAME(sc));
d5480 1
a5480 2
			printf("%s: could not initiate 5ghz scan\n",
			    DEVNAME(sc));
d5527 1
a5527 2
		printf("%s: Failed to start RT ucode: %d\n", DEVNAME(sc),
		    error);
d5708 1
d5710 1
d5878 1
d5951 1
d6109 1
a6109 1
			printf("%s: Firmware error 0x%x, cmd 0x%x\n",
d6271 2
a6272 2
			printf("%s: rfkill switch, disabling interface\n",
			    DEVNAME(sc));
d6304 1
a6304 1
		printf("%s: unhandled interrupts: %x\n", DEVNAME(sc), r1);
d6373 1
a6373 1
		printf("%s: failed to init hw\n", DEVNAME(sc));
@


1.3
log
@Handle suspend/resume for iwm(4) devices, by syncing with iwn(4)

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.2 2015/02/06 23:52:23 stsp Exp $	*/
d5442 1
a5442 1
		panic("unsupported state %d\n", nstate);
@


1.2
log
@Add bpf(4) support to iwm(4). Makes tcpdump -i iwm0 work. Based on iwn(4).
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwm.c,v 1.1 2015/02/06 19:49:29 stsp Exp $	*/
d434 4
d6498 1
d6616 53
d6675 1
a6675 1
	NULL, NULL
@


1.1
log
@Add iwm(4), a new driver for Intel 7260 wifi cards.

Based on iwn(4) and Linux iwlwifi (which is dual BSD/GPLv2 licenced).
Created by Fixup Software Ltd. for genua mbh, who then passed on the code
base to the OpenBSD project.

The genua version of this driver was written for OpenBSD 5.4; ported to
-current by myself, phessler@@, and deraadt@@. So far, we've done semantic
and stylistic cleanup without functional changes. The driver is functional
but has some known issues which will be worked on in-tree.

Requires iwm firmware which is available in ports thanks to sthen@@.

ok deraadt@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 2
d130 1
d132 1
d330 1
d361 1
a361 1
void	iwm_tx_fill_cmd(struct iwm_softc *, struct iwm_node *,
d434 3
d3004 21
d3098 44
d3706 1
d3708 1
a3708 1
void
d3729 1
a3729 1
		return;
d3740 2
d3758 1
d3785 36
a3831 10
	/* Fill out iwm_tx_cmd to send to the firmware */
	cmd = &ring->cmd[ring->cur];
	cmd->hdr.code = IWM_TX_CMD;
	cmd->hdr.flags = 0;
	cmd->hdr.qid = ring->qid;
	cmd->hdr.idx = ring->cur;

	tx = (void *)cmd->data;
	memset(tx, 0, sizeof(*tx));

a3886 2
	iwm_tx_fill_cmd(sc, in, wh, tx);

d5657 4
d5667 4
d6057 1
d6490 3
d6590 20
@

