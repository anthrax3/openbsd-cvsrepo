head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.10
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.16
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.14
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.12
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.10
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.14
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.12
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.10
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.19;
commitid	yM2VFFhpDTeFQlve;

1.19
date	2014.11.24.02.03.37;	author brad;	state Exp;
branches;
next	1.18;
commitid	Wmnzf8bGQILqXRTG;

1.18
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.20.17.02.24;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.20.16.54.01;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.22.23.26.08;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.25.10.13.29;	author art;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.12.05.37.00;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.03.21.13.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.09.01.21.43.38;	author deraadt;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.08.15.22.34.17;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.01.28.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.11.06.06.32.15;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	98.09.23.18.46.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.09.22.06.13.42;	author fgsch;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.25.45;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.42.17;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	;

1.10.4.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@unifdef INET
@
text
@/*	$OpenBSD: if_ne_pci.c,v 1.19 2014/11/24 02:03:37 brad Exp $	*/
/*	$NetBSD: if_ne_pci.c,v 1.8 1998/07/05 00:51:24 jonathan Exp $	*/

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/mii/miivar.h>

#include <dev/ic/dp8390reg.h>
#include <dev/ic/dp8390var.h>

#include <dev/ic/ne2000reg.h>
#include <dev/ic/ne2000var.h>

#include <dev/ic/rtl80x9reg.h>
#include <dev/ic/rtl80x9var.h>

struct ne_pci_softc {
	struct ne2000_softc sc_ne2000;		/* real "ne2000" softc */

	/* PCI-specific goo */
	void *sc_ih;				/* interrupt handle */
};

int ne_pci_match(struct device *, void *, void *);
void ne_pci_attach(struct device *, struct device *, void *);

struct cfattach ne_pci_ca = {
	sizeof(struct ne_pci_softc), ne_pci_match, ne_pci_attach
};

const struct ne_pci_product {
	pci_vendor_id_t npp_vendor;
	pci_product_id_t npp_product;
	int (*npp_mediachange)(struct dp8390_softc *);
	void (*npp_mediastatus)(struct dp8390_softc *,
	    struct ifmediareq *);
	void (*npp_init_card)(struct dp8390_softc *);
	void (*npp_media_init)(struct dp8390_softc *);
} ne_pci_prod[] = {
	{ PCI_VENDOR_REALTEK,		PCI_PRODUCT_REALTEK_RT8029,
	  rtl80x9_mediachange,		rtl80x9_mediastatus,
	  rtl80x9_init_card,		rtl80x9_media_init,
	  /* Realtek 8029 */ },

	{ PCI_VENDOR_WINBOND,		PCI_PRODUCT_WINBOND_W89C940F,
	  NULL,				NULL,
	  NULL,				NULL,
	  /* Winbond 89C940F */ },

	{ PCI_VENDOR_VIATECH,		PCI_PRODUCT_VIATECH_VT86C926,
	  NULL,				NULL,
	  NULL,				NULL,
	  /* VIA Technologies VT86C926 */ },

	{ PCI_VENDOR_SURECOM,		PCI_PRODUCT_SURECOM_NE34,
	  NULL,				NULL,
	  NULL,				NULL,
	  /* Surecom NE-34 */ },

	{ PCI_VENDOR_NETVIN,		PCI_PRODUCT_NETVIN_NV5000,
	  NULL,				NULL,
	  NULL,				NULL,
	  /* NetVin 5000 */ },

	/* XXX The following entries need sanity checking in pcidevs */
	{ PCI_VENDOR_COMPEX,		PCI_PRODUCT_COMPEX_COMPEXE,
	  NULL,				NULL,
	  NULL,				NULL,
	  /* Compex */ },

	{ PCI_VENDOR_WINBOND2,		PCI_PRODUCT_WINBOND2_W89C940,
	  NULL,				NULL,
	  NULL,				NULL,
	  /* ProLAN */ },

	{ PCI_VENDOR_KTI,		PCI_PRODUCT_KTI_KTIE,
	  NULL,				NULL,
	  NULL,				NULL,
	  /* KTI */ },
};

const struct ne_pci_product *ne_pci_lookup(struct pci_attach_args *);

const struct ne_pci_product *
ne_pci_lookup(struct pci_attach_args *pa)
{
	const struct ne_pci_product *npp;

	for (npp = ne_pci_prod;
	    npp < &ne_pci_prod[nitems(ne_pci_prod)];
	    npp++) {
		if (PCI_VENDOR(pa->pa_id) == npp->npp_vendor &&
		    PCI_PRODUCT(pa->pa_id) == npp->npp_product)
			return (npp);
	}
	return (NULL);
}

/*
 * PCI constants.
 * XXX These should be in a common file!
 */
#define PCI_CBIO	0x10		/* Configuration Base IO Address */

int
ne_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (ne_pci_lookup(pa) != NULL)
 		return (1);

	return (0);
}

void
ne_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct ne_pci_softc *psc = (struct ne_pci_softc *)self;
	struct ne2000_softc *nsc = &psc->sc_ne2000;
	struct dp8390_softc *dsc = &nsc->sc_dp8390;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	bus_size_t iosize;
	bus_space_tag_t nict;
	bus_space_handle_t nich;
	bus_space_tag_t asict;
	bus_space_handle_t asich;
	const char *intrstr;
	const struct ne_pci_product *npp;
	pci_intr_handle_t ih;

	npp = ne_pci_lookup(pa);
	if (npp == NULL) {
		printf("\n");
		panic("ne_pci_attach: impossible");
	}

	if (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
	    &nict, &nich, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}

	asict = nict;
	if (bus_space_subregion(nict, nich, NE2000_ASIC_OFFSET,
	    NE2000_ASIC_NPORTS, &asich)) {
		printf(": can't subregion i/o space\n");
		bus_space_unmap(nict, nich, iosize);
		return;
	}

	dsc->sc_regt = nict;
	dsc->sc_regh = nich;

	nsc->sc_asict = asict;
	nsc->sc_asich = asich;

	/* This interface is always enabled. */
	dsc->sc_enabled = 1;

	dsc->sc_mediachange = npp->npp_mediachange;
	dsc->sc_mediastatus = npp->npp_mediastatus;
	dsc->sc_media_init = npp->npp_media_init;
	dsc->init_card = npp->npp_init_card;

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(nict, nich, iosize);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	psc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, dp8390_intr, dsc,
		dsc->sc_dev.dv_xname);
	if (psc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(nict, nich, iosize);
		return;
	}
	printf(": %s", intrstr);

	/*
	 * Do generic NE2000 attach.  This will read the station address
	 * from the EEPROM.
	 */
	ne2000_attach(nsc, NULL);
}
@


1.19
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.18 2011/04/03 15:36:02 jasper Exp $	*/
a45 1
#ifdef INET
a47 1
#endif
@


1.18
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.17 2008/06/26 05:42:17 ray Exp $	*/
d95 1
a95 1
	  /* RealTek 8029 */ },
@


1.17
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.16 2006/10/20 17:02:24 brad Exp $	*/
d142 1
a142 1
	    npp < &ne_pci_prod[sizeof(ne_pci_prod)/sizeof(ne_pci_prod[0])];
@


1.16
log
@remove some NetBSD code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.15 2006/10/20 16:54:01 brad Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.15
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.14 2005/10/22 23:26:08 brad Exp $	*/
a50 3
#ifdef __NetBSD__
#include <net/if_ether.h>
#endif
a54 3
#ifdef __NetBSD__
#include <netinet/if_inarp.h>
#else
a55 1
#endif
@


1.14
log
@shorten ne(4) dmesg entries from 2-3 lines to 1.

Thanks to Han Boetes for testing on an isapnp card.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.13 2005/09/11 18:17:08 mickey Exp $	*/
d151 1
a151 2
ne_pci_lookup(pa)
	struct pci_attach_args *pa;
d172 1
a172 3
ne_pci_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d183 1
a183 3
ne_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
@


1.13
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.12 2005/08/09 04:10:12 mickey Exp $	*/
d255 1
a255 1
	printf(": %s\n", intrstr);
@


1.12
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.11 2002/03/14 01:26:58 millert Exp $	*/
a194 2
#ifndef __NetBSD__
	bus_addr_t iobase;
a195 1
#endif
a209 1
#ifdef __NetBSD__
d211 1
a211 1
	    &nict, &nich, NULL, NULL, 0)) {
a214 13
#else
	if (pci_io_find(pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize)) {
		printf(": can't find I/O base\n");
		return;
	}

	nict = pa->pa_iot;

	if (bus_space_map(nict, iobase, iosize, 0, &nich)) {
		printf(": can't map I/O space\n");
		return;
	}
#endif
d220 1
d241 1
d252 1
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.10 2001/08/25 10:13:29 art Exp $	*/
a205 1
	pcireg_t csr;
a244 6

	/* Enable the card. */
	csr = pci_conf_read(pc, pa->pa_tag,
	    PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_MASTER_ENABLE);
@


1.10
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.9 2001/06/12 15:40:31 niklas Exp $	*/
d90 2
a91 2
int ne_pci_match __P((struct device *, void *, void *));
void ne_pci_attach __P((struct device *, struct device *, void *));
d100 5
a104 5
	int (*npp_mediachange) __P((struct dp8390_softc *));
	void (*npp_mediastatus) __P((struct dp8390_softc *,
	    struct ifmediareq *));
	void (*npp_init_card) __P((struct dp8390_softc *));
	void (*npp_media_init) __P((struct dp8390_softc *));
d148 1
a148 1
const struct ne_pci_product *ne_pci_lookup __P((struct pci_attach_args *));
@


1.10.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.10 2001/08/25 10:13:29 art Exp $	*/
d90 2
a91 2
int ne_pci_match(struct device *, void *, void *);
void ne_pci_attach(struct device *, struct device *, void *);
d100 5
a104 5
	int (*npp_mediachange)(struct dp8390_softc *);
	void (*npp_mediastatus)(struct dp8390_softc *,
	    struct ifmediareq *);
	void (*npp_init_card)(struct dp8390_softc *);
	void (*npp_media_init)(struct dp8390_softc *);
d148 1
a148 1
const struct ne_pci_product *ne_pci_lookup(struct pci_attach_args *);
@


1.9
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.8 2001/03/12 05:37:00 aaron Exp $	*/
d262 1
a262 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.8
log
@Adjust the way that media is initialized on DP8390-compatibles; from NetBSD.
The dp8390_softc now has media_init and media_fini function pointers that
do the work. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.7 2000/04/03 21:13:48 deraadt Exp $	*/
d216 1
a216 1
	    &nict, &nich, NULL, NULL)) {
@


1.7
log
@fix dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.6 1999/09/01 21:43:38 deraadt Exp $	*/
d72 2
d104 1
a104 2
	void (*npp_init_media) __P((struct dp8390_softc *, int **,
	    int *, int *));
d108 1
a108 1
	  rtl80x9_init_card,		rtl80x9_init_media,
a206 1
	int *media, nmedia, defmedia;
d256 3
a258 11
	if (npp->npp_init_media != NULL) {
		(*npp->npp_init_media)(dsc, &media, &nmedia, &defmedia);
		dsc->sc_mediachange = npp->npp_mediachange;
		dsc->sc_mediastatus = npp->npp_mediastatus;
	} else {
		media = NULL;
		nmedia = 0;
		defmedia = 0;
	}

	/* Always fill in init_card; it might be used for non-media stuff. */
d283 1
a283 1
	ne2000_attach(nsc, NULL, media, nmedia, defmedia);
@


1.6
log
@ne2000_attach() later; this terse commit message being blown towards
our buddy Bill Fumerola
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.5 1999/08/15 22:34:17 deraadt Exp $	*/
d285 1
a285 1
	printf(" %s\n", intrstr);
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.8 2001/03/12 05:37:00 aaron Exp $	*/
a71 2
#include <dev/mii/miivar.h>

d102 2
a103 1
	void (*npp_media_init) __P((struct dp8390_softc *));
d107 1
a107 1
	  rtl80x9_init_card,		rtl80x9_media_init,
d206 1
d256 11
a266 3
	dsc->sc_mediachange = npp->npp_mediachange;
	dsc->sc_mediastatus = npp->npp_mediastatus;
	dsc->sc_media_init = npp->npp_media_init;
d285 1
a285 1
	printf(": %s\n", intrstr);
d291 1
a291 1
	ne2000_attach(nsc, NULL);
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.6.4.1 2001/05/14 22:25:45 niklas Exp $	*/
d216 1
a216 1
	    &nict, &nich, NULL, NULL, 0)) {
@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.6.4.2 2001/07/04 10:42:17 niklas Exp $	*/
d262 2
a263 1
	if (pci_intr_map(pa, &ih)) {
@


1.6.4.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 2
a91 2
int ne_pci_match(struct device *, void *, void *);
void ne_pci_attach(struct device *, struct device *, void *);
d100 5
a104 5
	int (*npp_mediachange)(struct dp8390_softc *);
	void (*npp_mediastatus)(struct dp8390_softc *,
	    struct ifmediareq *);
	void (*npp_init_card)(struct dp8390_softc *);
	void (*npp_media_init)(struct dp8390_softc *);
d148 1
a148 1
const struct ne_pci_product *ne_pci_lookup(struct pci_attach_args *);
@


1.5
log
@reduce size
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.4 1999/01/11 01:28:03 millert Exp $	*/
a240 2
	printf("\n");

a268 6
	/*
	 * Do generic NE2000 attach.  This will read the station address
	 * from the EEPROM.
	 */
	ne2000_attach(nsc, NULL, media, nmedia, defmedia);

d272 1
a272 1
		printf("%s: couldn't map interrupt\n", dsc->sc_dev.dv_xname);
d279 1
a279 2
		printf("%s: couldn't establish interrupt",
		    dsc->sc_dev.dv_xname);
d285 7
a291 1
	printf("%s: %s\n", dsc->sc_dev.dv_xname, intrstr);
@


1.4
log
@kill unnecessary printf before a panic
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.3 1998/11/06 06:32:15 fgsch Exp $	*/
d104 1
a104 2
	const char *npp_name;
} ne_pci_products[] = {
d108 1
a108 1
	  "RealTek 8029" },
d113 1
a113 1
	  "Winbond 89C940F" },
d118 1
a118 1
	  "VIA Technologies VT86C926" },
d123 1
a123 1
	  "Surecom NE-34" },
d128 1
a128 1
	  "NetVin 5000" },
d134 1
a134 1
	  "Compex" },
d139 1
a139 1
	  "ProLAN" },
d144 1
a144 6
	  "KTI" },

	{ 0,				0,
	  NULL,				NULL,
	  NULL,				NULL,
	  NULL },
d155 3
a157 1
	for (npp = ne_pci_products; npp->npp_name != NULL; npp++) {
d209 4
a212 4
	if (npp == NULL)
		panic("\nne_pci_attach: impossible");

	printf(": %s Ethernet\n", npp->npp_name);
d240 2
@


1.3
log
@Support for RealTek 8019 and 8029 NE2000-compatible network interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.2 1998/09/23 18:46:29 deraadt Exp $	*/
d213 2
a214 4
	if (npp == NULL) {
		printf("\n");
		panic("ne_pci_attach: impossible");
	}
@


1.2
log
@fix pci_io_find(), some dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pci.c,v 1.1 1998/09/22 06:13:42 fgsch Exp $	*/
d78 3
d95 35
a129 4
struct ne_pci_compatdev {
	pci_vendor_id_t vendor;
	pci_product_id_t product;
};
a130 6
struct ne_pci_compatdev ne_pci_compatdevs[] = {
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8029 },
	{ PCI_VENDOR_WINBOND, PCI_PRODUCT_WINBOND_W89C940F },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT86C926 },
	{ PCI_VENDOR_SURECOM, PCI_PRODUCT_SURECOM_NE34 },
	{ PCI_VENDOR_NETVIN, PCI_PRODUCT_NETVIN_NV5000 },
d132 19
a150 4
	{ PCI_VENDOR_COMPEX, PCI_PRODUCT_COMPEX_COMPEXE },
	{ PCI_VENDOR_WINBOND2, PCI_PRODUCT_WINBOND2_W89C940 },
	{ PCI_VENDOR_KTI, PCI_PRODUCT_KTI_KTIE },
	{ 0, 0 },
d153 1
a153 1
int ne_pci_lookup __P((pcireg_t));
d155 3
a157 3
int
ne_pci_lookup(id)
	pcireg_t id;
d159 1
a159 1
	struct ne_pci_compatdev *nc;
d161 4
a164 4
	for (nc = ne_pci_compatdevs; nc->vendor != 0; nc++) {
		if (PCI_VENDOR(id) == nc->vendor &&
		    PCI_PRODUCT(id) == nc->product)
			return (1);
d166 1
a166 1
	return (0);
d182 2
a183 2
	if (ne_pci_lookup(pa->pa_id) != 0)
		return (1);
d207 1
d210 9
d262 12
a273 1
	printf("\n");
d279 1
a279 1
	ne2000_attach(nsc, NULL);
@


1.1
log
@New ne2k pci driver.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a94 1
	char *name;
d98 5
a102 6
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8029, "Realtek 8029" },
	{ PCI_VENDOR_WINBOND, PCI_PRODUCT_WINBOND_W89C940F, "Winbond 89C940F" },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT86C926,
		"VIA Technologies VT86C926" },
	{ PCI_VENDOR_SURECOM, PCI_PRODUCT_SURECOM_NE34, "Surecom NE-34" },
	{ PCI_VENDOR_NETVIN, PCI_PRODUCT_NETVIN_NV5000, "NetVin 5000" },
d104 4
a107 4
	{ PCI_VENDOR_COMPEX, PCI_PRODUCT_COMPEX_COMPEXE, "Compex" },
	{ PCI_VENDOR_WINBOND2, PCI_PRODUCT_WINBOND2_W89C940, "Winbond 89C940" },
	{ PCI_VENDOR_KTI, PCI_PRODUCT_KTI_KTIE, "KTI" },
	{ 0, 0, NULL },
d110 1
a110 1
char *ne_pci_lookup __P((pcireg_t));
d112 1
a112 1
char *
d121 1
a121 1
			return (nc->name);
d123 1
a123 2

	return (NULL);
d139 1
a139 1
	if (ne_pci_lookup(pa->pa_id) != NULL)
d163 1
a163 1
	const char *typestr = NULL, *intrstr;
a166 8
	typestr = ne_pci_lookup(pa->pa_id);
	if (typestr == NULL) {
		printf(": unknown model?!\n");
		return;
	}

	printf(": %s Ethernet\n", typestr);

d170 1
a170 1
		printf("%s: can't map i/o space\n", dsc->sc_dev.dv_xname);
d174 2
a175 2
	if (pci_io_find(pa, pa->pa_tag, PCI_CBIO, &iobase, &iosize)) {
		printf("%s: can't find I/O base\n", dsc->sc_dev.dv_xname);
d182 1
a182 1
		printf("%s: can't map I/O space\n", dsc->sc_dev.dv_xname);
d190 1
a190 1
		printf("%s: can't subregion i/o space\n", dsc->sc_dev.dv_xname);
d209 2
d234 1
a234 1
	printf("%s: interrupting at %s\n", dsc->sc_dev.dv_xname, intrstr);
@

