head	1.172;
access;
symbols
	OPENBSD_6_1:1.172.0.2
	OPENBSD_6_1_BASE:1.172
	OPENBSD_6_0:1.171.0.6
	OPENBSD_6_0_BASE:1.171
	OPENBSD_5_9:1.171.0.2
	OPENBSD_5_9_BASE:1.171
	OPENBSD_5_8:1.167.0.4
	OPENBSD_5_8_BASE:1.167
	OPENBSD_5_7:1.165.0.4
	OPENBSD_5_7_BASE:1.165
	OPENBSD_5_6:1.163.0.4
	OPENBSD_5_6_BASE:1.163
	OPENBSD_5_5:1.159.0.4
	OPENBSD_5_5_BASE:1.159
	OPENBSD_5_4:1.154.0.2
	OPENBSD_5_4_BASE:1.154
	OPENBSD_5_3:1.152.0.2
	OPENBSD_5_3_BASE:1.152
	OPENBSD_5_2:1.151.0.8
	OPENBSD_5_2_BASE:1.151
	OPENBSD_5_1_BASE:1.151
	OPENBSD_5_1:1.151.0.6
	OPENBSD_5_0:1.151.0.4
	OPENBSD_5_0_BASE:1.151
	OPENBSD_4_9:1.151.0.2
	OPENBSD_4_9_BASE:1.151
	OPENBSD_4_8:1.149.0.2
	OPENBSD_4_8_BASE:1.149
	OPENBSD_4_7:1.141.0.2
	OPENBSD_4_7_BASE:1.141
	OPENBSD_4_6:1.133.0.4
	OPENBSD_4_6_BASE:1.133
	OPENBSD_4_5:1.114.0.2
	OPENBSD_4_5_BASE:1.114
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18;
locks; strict;
comment	@ * @;


1.172
date	2017.03.28.04.54.44;	author ratchov;	state Exp;
branches;
next	1.171;
commitid	5t0wpUgdAYVc1pkF;

1.171
date	2015.12.02.03.11.32;	author jsg;	state Exp;
branches;
next	1.170;
commitid	vNbDTyr4lIirei66;

1.170
date	2015.08.24.04.50.40;	author jsg;	state Exp;
branches;
next	1.169;
commitid	Sr7poarBLtMxMzMH;

1.169
date	2015.08.21.06.11.04;	author jsg;	state Exp;
branches;
next	1.168;
commitid	wOmTceOAPzFtMUwV;

1.168
date	2015.08.20.06.44.06;	author mlarkin;	state Exp;
branches;
next	1.167;
commitid	HJo9XRP85Bi32SU1;

1.167
date	2015.08.04.21.21.38;	author tedu;	state Exp;
branches;
next	1.166;
commitid	FJo4gm3kd0VrVcHu;

1.166
date	2015.04.25.11.37.24;	author jturner;	state Exp;
branches;
next	1.165;
commitid	ssERdgYwGvUkg5q0;

1.165
date	2014.12.10.14.18.11;	author jsg;	state Exp;
branches;
next	1.164;
commitid	ooRwNL5ZiRd3y9dQ;

1.164
date	2014.11.17.16.34.51;	author landry;	state Exp;
branches;
next	1.163;
commitid	hNOpw9wO1V2jJWRt;

1.163
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.162;
commitid	JtO5uXxVcnZfhUkR;

1.162
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.161;
commitid	OBNa5kfxQ2UXoiIw;

1.161
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.160;
commitid	EF98ch02VpFassUi;

1.160
date	2014.05.25.16.00.53;	author ratchov;	state Exp;
branches;
next	1.159;

1.159
date	2014.01.06.06.54.15;	author brad;	state Exp;
branches;
next	1.158;

1.158
date	2014.01.02.04.23.35;	author jsg;	state Exp;
branches;
next	1.157;

1.157
date	2014.01.02.03.05.20;	author jsg;	state Exp;
branches;
next	1.156;

1.156
date	2013.11.09.05.53.20;	author jsg;	state Exp;
branches;
next	1.155;

1.155
date	2013.10.06.10.46.24;	author rapha;	state Exp;
branches;
next	1.154;

1.154
date	2013.05.27.21.19.31;	author miod;	state Exp;
branches;
next	1.153;

1.153
date	2013.05.24.10.52.13;	author jsg;	state Exp;
branches;
next	1.152;

1.152
date	2012.11.30.12.05.45;	author sthen;	state Exp;
branches;
next	1.151;

1.151
date	2010.09.10.15.11.23;	author jakemsr;	state Exp;
branches;
next	1.150;

1.150
date	2010.08.23.15.48.24;	author jakemsr;	state Exp;
branches;
next	1.149;

1.149
date	2010.08.08.05.25.30;	author jakemsr;	state Exp;
branches;
next	1.148;

1.148
date	2010.08.07.20.48.56;	author jakemsr;	state Exp;
branches;
next	1.147;

1.147
date	2010.06.27.21.47.07;	author jakemsr;	state Exp;
branches;
next	1.146;

1.146
date	2010.06.27.17.42.27;	author jakemsr;	state Exp;
branches;
next	1.145;

1.145
date	2010.06.27.01.13.25;	author jakemsr;	state Exp;
branches;
next	1.144;

1.144
date	2010.06.26.21.06.52;	author jakemsr;	state Exp;
branches;
next	1.143;

1.143
date	2010.03.21.15.04.35;	author jakemsr;	state Exp;
branches;
next	1.142;

1.142
date	2010.03.21.15.02.31;	author jakemsr;	state Exp;
branches;
next	1.141;

1.141
date	2010.02.11.21.33.39;	author jakemsr;	state Exp;
branches;
next	1.140;

1.140
date	2010.02.01.05.43.21;	author jakemsr;	state Exp;
branches;
next	1.139;

1.139
date	2009.11.03.17.31.30;	author jakemsr;	state Exp;
branches;
next	1.138;

1.138
date	2009.10.20.06.01.36;	author kevlo;	state Exp;
branches;
next	1.137;

1.137
date	2009.09.12.09.34.43;	author jakemsr;	state Exp;
branches;
next	1.136;

1.136
date	2009.09.09.02.22.21;	author jakemsr;	state Exp;
branches;
next	1.135;

1.135
date	2009.09.09.02.13.35;	author jakemsr;	state Exp;
branches;
next	1.134;

1.134
date	2009.09.09.02.06.04;	author jakemsr;	state Exp;
branches;
next	1.133;

1.133
date	2009.06.26.01.48.22;	author jakemsr;	state Exp;
branches;
next	1.132;

1.132
date	2009.06.09.05.16.42;	author jakemsr;	state Exp;
branches;
next	1.131;

1.131
date	2009.06.09.05.05.48;	author jakemsr;	state Exp;
branches;
next	1.130;

1.130
date	2009.05.31.03.22.05;	author jakemsr;	state Exp;
branches;
next	1.129;

1.129
date	2009.05.31.02.57.51;	author jakemsr;	state Exp;
branches;
next	1.128;

1.128
date	2009.05.31.02.12.54;	author jakemsr;	state Exp;
branches;
next	1.127;

1.127
date	2009.05.29.21.16.37;	author jakemsr;	state Exp;
branches;
next	1.126;

1.126
date	2009.05.29.05.04.45;	author jakemsr;	state Exp;
branches;
next	1.125;

1.125
date	2009.05.25.05.51.19;	author robert;	state Exp;
branches;
next	1.124;

1.124
date	2009.05.17.02.28.26;	author jakemsr;	state Exp;
branches;
next	1.123;

1.123
date	2009.05.12.09.32.28;	author jakemsr;	state Exp;
branches;
next	1.122;

1.122
date	2009.05.01.03.45.17;	author jakemsr;	state Exp;
branches;
next	1.121;

1.121
date	2009.05.01.02.55.16;	author jakemsr;	state Exp;
branches;
next	1.120;

1.120
date	2009.04.27.23.49.04;	author jakemsr;	state Exp;
branches;
next	1.119;

1.119
date	2009.04.25.05.02.40;	author jakemsr;	state Exp;
branches;
next	1.118;

1.118
date	2009.04.24.16.30.58;	author jakemsr;	state Exp;
branches;
next	1.117;

1.117
date	2009.04.24.16.27.38;	author jakemsr;	state Exp;
branches;
next	1.116;

1.116
date	2009.04.24.16.18.23;	author jakemsr;	state Exp;
branches;
next	1.115;

1.115
date	2009.04.24.16.05.06;	author jakemsr;	state Exp;
branches;
next	1.114;

1.114
date	2009.01.24.09.44.02;	author jakemsr;	state Exp;
branches;
next	1.113;

1.113
date	2009.01.07.07.19.39;	author marco;	state Exp;
branches;
next	1.112;

1.112
date	2009.01.05.09.50.37;	author jakemsr;	state Exp;
branches;
next	1.111;

1.111
date	2009.01.05.09.46.26;	author jakemsr;	state Exp;
branches;
next	1.110;

1.110
date	2009.01.05.08.06.55;	author jakemsr;	state Exp;
branches;
next	1.109;

1.109
date	2009.01.05.07.55.34;	author jakemsr;	state Exp;
branches;
next	1.108;

1.108
date	2009.01.04.22.45.24;	author jakemsr;	state Exp;
branches;
next	1.107;

1.107
date	2009.01.03.19.17.45;	author jakemsr;	state Exp;
branches;
next	1.106;

1.106
date	2009.01.02.22.32.25;	author jakemsr;	state Exp;
branches;
next	1.105;

1.105
date	2009.01.02.20.37.57;	author jakemsr;	state Exp;
branches;
next	1.104;

1.104
date	2009.01.02.20.35.05;	author jakemsr;	state Exp;
branches;
next	1.103;

1.103
date	2009.01.02.20.18.18;	author jakemsr;	state Exp;
branches;
next	1.102;

1.102
date	2009.01.02.00.39.25;	author jakemsr;	state Exp;
branches;
next	1.101;

1.101
date	2009.01.02.00.20.14;	author jakemsr;	state Exp;
branches;
next	1.100;

1.100
date	2008.12.31.13.35.58;	author jakemsr;	state Exp;
branches;
next	1.99;

1.99
date	2008.12.31.13.13.39;	author jakemsr;	state Exp;
branches;
next	1.98;

1.98
date	2008.12.28.23.15.14;	author jakemsr;	state Exp;
branches;
next	1.97;

1.97
date	2008.12.26.10.07.48;	author jakemsr;	state Exp;
branches;
next	1.96;

1.96
date	2008.12.26.08.23.18;	author jakemsr;	state Exp;
branches;
next	1.95;

1.95
date	2008.12.26.07.24.06;	author jakemsr;	state Exp;
branches;
next	1.94;

1.94
date	2008.12.26.06.56.36;	author jakemsr;	state Exp;
branches;
next	1.93;

1.93
date	2008.12.25.22.09.51;	author jakemsr;	state Exp;
branches;
next	1.92;

1.92
date	2008.12.24.10.58.52;	author jakemsr;	state Exp;
branches;
next	1.91;

1.91
date	2008.12.23.10.43.26;	author jakemsr;	state Exp;
branches;
next	1.90;

1.90
date	2008.12.23.10.33.10;	author jakemsr;	state Exp;
branches;
next	1.89;

1.89
date	2008.12.23.10.19.39;	author jakemsr;	state Exp;
branches;
next	1.88;

1.88
date	2008.12.23.10.06.50;	author jakemsr;	state Exp;
branches;
next	1.87;

1.87
date	2008.12.23.10.01.14;	author jakemsr;	state Exp;
branches;
next	1.86;

1.86
date	2008.12.23.09.46.38;	author jakemsr;	state Exp;
branches;
next	1.85;

1.85
date	2008.12.23.04.12.19;	author jakemsr;	state Exp;
branches;
next	1.84;

1.84
date	2008.12.22.03.47.16;	author jakemsr;	state Exp;
branches;
next	1.83;

1.83
date	2008.12.22.02.20.22;	author jakemsr;	state Exp;
branches;
next	1.82;

1.82
date	2008.12.22.00.54.04;	author jakemsr;	state Exp;
branches;
next	1.81;

1.81
date	2008.12.21.20.44.04;	author jakemsr;	state Exp;
branches;
next	1.80;

1.80
date	2008.12.21.20.21.24;	author jakemsr;	state Exp;
branches;
next	1.79;

1.79
date	2008.11.30.22.01.34;	author jakemsr;	state Exp;
branches;
next	1.78;

1.78
date	2008.11.30.21.58.43;	author jakemsr;	state Exp;
branches;
next	1.77;

1.77
date	2008.11.30.04.01.53;	author jakemsr;	state Exp;
branches;
next	1.76;

1.76
date	2008.11.30.03.50.29;	author jakemsr;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.28.21.50.05;	author jakemsr;	state Exp;
branches;
next	1.74;

1.74
date	2008.11.28.21.45.49;	author jakemsr;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.28.09.58.18;	author jakemsr;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.28.04.03.37;	author jakemsr;	state Exp;
branches;
next	1.71;

1.71
date	2008.11.28.03.27.11;	author jakemsr;	state Exp;
branches;
next	1.70;

1.70
date	2008.11.28.03.18.11;	author jakemsr;	state Exp;
branches;
next	1.69;

1.69
date	2008.11.27.23.30.58;	author jakemsr;	state Exp;
branches;
next	1.68;

1.68
date	2008.11.27.23.03.29;	author jakemsr;	state Exp;
branches;
next	1.67;

1.67
date	2008.11.19.21.49.44;	author naddy;	state Exp;
branches;
next	1.66;

1.66
date	2008.11.19.03.44.14;	author jakemsr;	state Exp;
branches;
next	1.65;

1.65
date	2008.11.17.00.42.53;	author jakemsr;	state Exp;
branches;
next	1.64;

1.64
date	2008.11.17.00.33.35;	author jakemsr;	state Exp;
branches;
next	1.63;

1.63
date	2008.11.16.23.58.40;	author jakemsr;	state Exp;
branches;
next	1.62;

1.62
date	2008.11.16.23.53.37;	author jakemsr;	state Exp;
branches;
next	1.61;

1.61
date	2008.11.16.23.46.52;	author jakemsr;	state Exp;
branches;
next	1.60;

1.60
date	2008.11.16.23.33.50;	author jakemsr;	state Exp;
branches;
next	1.59;

1.59
date	2008.11.14.22.03.39;	author jakemsr;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.14.21.58.11;	author jakemsr;	state Exp;
branches;
next	1.57;

1.57
date	2008.11.05.01.14.01;	author jakemsr;	state Exp;
branches;
next	1.56;

1.56
date	2008.11.04.07.58.43;	author jakemsr;	state Exp;
branches;
next	1.55;

1.55
date	2008.10.28.21.14.19;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2008.10.27.02.55.09;	author jakemsr;	state Exp;
branches;
next	1.53;

1.53
date	2008.10.25.02.19.02;	author jakemsr;	state Exp;
branches;
next	1.52;

1.52
date	2008.10.23.02.23.04;	author jakemsr;	state Exp;
branches;
next	1.51;

1.51
date	2008.10.16.19.16.58;	author jakemsr;	state Exp;
branches;
next	1.50;

1.50
date	2008.10.16.02.13.12;	author jakemsr;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2008.04.10.17.55.17;	author deanna;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.16.18.48.19;	author deanna;	state Exp;
branches;
next	1.45;

1.45
date	2007.12.06.19.58.48;	author deanna;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.24.18.43.38;	author deanna;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.21.18.48.11;	author deanna;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.14.05.39.41;	author deanna;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.06.20.22.15;	author deanna;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.14.17.56.15;	author deanna;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.10.03.39.21;	author deanna;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.05.03.33.23;	author deanna;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.26.06.00.27;	author deanna;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.20.17.41.32;	author deanna;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.11.05.17.47;	author deanna;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.11.05.14.42;	author deanna;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.10.22.37.08;	author deanna;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.10.05.34.21;	author deanna;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.10.05.26.38;	author deanna;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.06.22.52.05;	author deanna;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.31.17.06.25;	author deanna;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.31.16.14.26;	author deanna;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.23.03.41.03;	author deanna;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.23.03.25.11;	author deanna;	state Exp;
branches;
next	1.25;

1.25
date	2007.07.23.03.21.57;	author deanna;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.23.03.03.58;	author deanna;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.23.02.03.42;	author deanna;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.07.16.33.38;	author deanna;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.19.00.39.33;	author deanna;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.13.02.32.41;	author deanna;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.02.17.01.22;	author deanna;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.23.20.23.51;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.20.23.51.48;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.19.19.22.04;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.25.00.54.16;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.17.18.38.12;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.16.08.03.42;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.16.07.29.24;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.16.06.00.46;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.14.20.24.12;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.14.19.34.52;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.18.03.34.50;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.18.03.23.23;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.11.05.12.46;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.08.04.33.54;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.08.04.28.33;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.08.04.24.47;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.08.03.53.57;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.26.15.53.08;	author jason;	state Exp;
branches;
next	;


desc
@@


1.172
log
@Add quirk for MacBook Pro 5,5. From Manav Rathi <mnvrth at gmail.com>.
Thanks!
@
text
@/*	$OpenBSD: azalia_codec.c,v 1.171 2015/12/02 03:11:32 jsg Exp $	*/
/*	$NetBSD: azalia_codec.c,v 1.8 2006/05/10 11:17:27 kent Exp $	*/

/*-
 * Copyright (c) 2005 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by TAMURA Kent
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <dev/pci/azalia.h>

#define XNAME(co)	(((struct device *)co->az)->dv_xname)
#define MIXER_DELTA(n)	(AUDIO_MAX_GAIN / (n))

int	azalia_add_convgroup(codec_t *, convgroupset_t *,
    struct io_pin *, int, nid_t *, int, uint32_t, uint32_t);

int	azalia_mixer_fix_indexes(codec_t *);
int	azalia_mixer_default(codec_t *);
int	azalia_mixer_ensure_capacity(codec_t *, size_t);
u_char	azalia_mixer_from_device_value(const codec_t *, nid_t, int, uint32_t );
uint32_t azalia_mixer_to_device_value(const codec_t *, nid_t, int, u_char);

void	azalia_devinfo_offon(mixer_devinfo_t *);
void	azalia_pin_config_ov(widget_t *, int, int);
void	azalia_ampcap_ov(widget_t *, int, int, int, int, int, int);
int	azalia_gpio_unmute(codec_t *, int);


int
azalia_codec_init_vtbl(codec_t *this)
{
	/**
	 * We can refer this->vid and this->subid.
	 */
	this->name = NULL;
	this->qrks = AZ_QRK_NONE;
	switch (this->vid) {
	case 0x10134206:
		this->name = "Cirrus Logic CS4206";
		if (this->subid == 0xcb8910de ||	/* APPLE_MBA3_1 */
		    this->subid == 0x72708086 ||	/* APPLE_MBA4_1 */
		    this->subid == 0xcb7910de) {	/* APPLE_MBP5_5 */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_1 |
			    AZ_QRK_GPIO_UNMUTE_3;
		}
		break;
	case 0x10134208:
		this->name = "Cirrus Logic CS4208";
		if (this->subid == 0x72708086) {	/* APPLE_MBA6_1 */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0 |
			    AZ_QRK_GPIO_UNMUTE_1;
		}
		break;
	case 0x10ec0221:
		this->name = "Realtek ALC221";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		break;
	case 0x10ec0260:
		this->name = "Realtek ALC260";
		if (this->subid == 0x008f1025)
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		break;
	case 0x10ec0262:
		this->name = "Realtek ALC262";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		break;
	case 0x10ec0268:
		this->name = "Realtek ALC268";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		break;
	case 0x10ec0269:
		this->name = "Realtek ALC269";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;

		/*
		 * Enable dock audio on Thinkpad docks
		 * 0x17aa : 0x21f3 = Thinkpad T430
		 * 0x17aa : 0x21f6 = Thinkpad T530
		 * 0x17aa : 0x21fa = Thinkpad X230
		 * 0x17aa : 0x21fb = Thinkpad T430s
		 * 0x17aa : 0x2203 = Thinkpad X230t
		 * 0x17aa : 0x2208 = Thinkpad T431s
		 */
		if (this->subid == 0x21f317aa ||
		    this->subid == 0x21f617aa ||
		    this->subid == 0x21fa17aa ||
		    this->subid == 0x21fb17aa ||
		    this->subid == 0x220317aa ||
		    this->subid == 0x220817aa)
			this->qrks |= AZ_QRK_WID_TPDOCK1;
		break;
	case 0x10ec0272:
		this->name = "Realtek ALC272";
		break;
	case 0x10ec0282:
		this->name = "Realtek ALC282";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		break;
	case 0x10ec0292:
		this->name = "Realtek ALC292";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;

		/*
		 * Enable dock audio on Thinkpad docks
		 * 0x17aa : 0x220c = Thinkpad T440s
		 * 0x17aa : 0x220e = Thinkpad T440p
		 * 0x17aa : 0x2210 = Thinkpad T540p
		 * 0x17aa : 0x2212 = Thinkpad T440
		 * 0x17aa : 0x2214 = Thinkpad X240
		 * 0x17aa : 0x2226 = Thinkpad X250
		 * 0x17aa : 0x501e = Thinkpad L440
		 * 0x17aa : 0x5034 = Thinkpad T450
		 * 0x17aa : 0x5036 = Thinkpad T450s
		 * 0x17aa : 0x503c = Thinkpad L450
		 */
		if (this->subid == 0x220c17aa ||
		    this->subid == 0x220e17aa ||
		    this->subid == 0x221017aa ||
		    this->subid == 0x221217aa ||
		    this->subid == 0x221417aa ||
		    this->subid == 0x222617aa ||
		    this->subid == 0x501e17aa ||
		    this->subid == 0x503417aa ||
		    this->subid == 0x503617aa ||
		    this->subid == 0x503c17aa)
			this->qrks |= AZ_QRK_WID_TPDOCK2;
		break;
	case 0x10ec0660:
		this->name = "Realtek ALC660";
		if (this->subid == 0x13391043) {	/* ASUS_G2K */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		}
		break;
	case 0x10ec0662:
		this->name = "Realtek ALC662";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		break;
	case 0x10ec0663:
		this->name = "Realtek ALC663";
		break;
	case 0x10ec0861:
		this->name = "Realtek ALC861";
		break;
	case 0x10ec0880:
		this->name = "Realtek ALC880";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		if (this->subid == 0x19931043 ||	/* ASUS_M5200 */
		    this->subid == 0x13231043) {	/* ASUS_A7M */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		}
		if (this->subid == 0x203d161f) {	/* MEDION_MD95257 */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_1;
		}
		break;
	case 0x10ec0882:
		this->name = "Realtek ALC882";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		if (this->subid == 0x13c21043 ||	/* ASUS_A7T */
		    this->subid == 0x19711043) {	/* ASUS_W2J */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		}
		break;
	case 0x10ec0883:
		this->name = "Realtek ALC883";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		if (this->subid == 0x00981025) {	/* ACER_ID */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0 |
			    AZ_QRK_GPIO_UNMUTE_1;
		}
		break;
	case 0x10ec0885:
		this->name = "Realtek ALC885";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		if (this->subid == 0x00a1106b ||	/* APPLE_MB3 */
		    this->subid == 0xcb7910de ||	/* APPLE_MACMINI3_1 (line-in + hp) */
		    this->subid == 0x00a0106b ||	/* APPLE_MB3_1 */
		    this->subid == 0x00a3106b) {	/* APPLE_MB4 */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		}
		if (this->subid == 0x00a1106b ||
		    this->subid == 0xcb7910de ||	/* APPLE_MACMINI3_1 (internal spkr) */
		    this->subid == 0x00a0106b)
			this->qrks |= AZ_QRK_WID_OVREF50;
		break;
	case 0x10ec0888:
		this->name = "Realtek ALC888";
		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D;
		break;
	case 0x10ec0900:
		this->name = "Realtek ALC1150";
		break;
	case 0x11060398:
	case 0x11061398:
	case 0x11062398:
	case 0x11063398:
	case 0x11064398:
	case 0x11065398:
	case 0x11066398:
	case 0x11067398:
		this->name = "VIA VT1702";
		break;
	case 0x111d7603:
		this->name = "IDT 92HD75B3/4";
		if ((this->subid & 0x0000ffff) == 0x0000103c) {	/* HP */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		}
		break;
	case 0x111d7604:
		this->name = "IDT 92HD83C1X";
		break;
	case 0x111d7605:
		this->name = "IDT 92HD81B1X";
		break;
	case 0x111d7608:
		this->name = "IDT 92HD75B1/2";
		if ((this->subid & 0x0000ffff) == 0x0000103c) {	/* HP */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		}
		break;
	case 0x111d7674:
		this->name = "IDT 92HD73D1";
		break;
	case 0x111d7675:
		this->name = "IDT 92HD73C1";	/* aka 92HDW74C1 */
		if ((this->subid & 0x0000ffff) == 0x00001028) {	/* DELL */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		}
		break;
	case 0x111d7676:
		this->name = "IDT 92HD73E1";	/* aka 92HDW74E1 */
		break;
	case 0x111d76b0:
		this->name = "IDT 92HD71B8";
		break;
	case 0x111d76b2:
		this->name = "IDT 92HD71B7";
		if ((this->subid & 0x0000ffff) == 0x00001028 || /* DELL */
		    (this->subid & 0x0000ffff) == 0x0000103c) { /* HP */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		}
		break;
	case 0x111d76b6:
		this->name = "IDT 92HD71B5";
		break;
	case 0x111d76d4:
		this->name = "IDT 92HD83C1C";
		break;
	case 0x111d76d5:
		this->name = "IDT 92HD81B1C";
		break;
	case 0x11d4184a:
		this->name = "Analog Devices AD1884A";
		break;
	case 0x11d41882:
		this->name = "Analog Devices AD1882";
		break;
	case 0x11d41883:
		this->name = "Analog Devices AD1883";
		break;
	case 0x11d41884:
		this->name = "Analog Devices AD1884";
		break;
	case 0x11d4194a:
		this->name = "Analog Devices AD1984A";
		break;
	case 0x11d41981:
		this->name = "Analog Devices AD1981HD";
		this->qrks |= AZ_QRK_WID_AD1981_OAMP;
		break;
	case 0x11d41983:
		this->name = "Analog Devices AD1983";
		break;
	case 0x11d41984:
		this->name = "Analog Devices AD1984";
		break;
	case 0x11d41988:
		this->name = "Analog Devices AD1988A";
		break;
	case 0x11d4198b:
		this->name = "Analog Devices AD1988B";
		break;
	case 0x11d4882a:
		this->name = "Analog Devices AD1882A";
		break;
	case 0x11d4989a:
		this->name = "Analog Devices AD1989A";
		break;
	case 0x11d4989b:
		this->name = "Analog Devices AD1989B";
		break;
	case 0x14f15045:
		this->name = "Conexant CX20549";  /* Venice */
		break;
	case 0x14f15047:
		this->name = "Conexant CX20551";  /* Waikiki */
		break;
	case 0x14f15051:
		this->name = "Conexant CX20561";  /* Hermosa */
		break;
	case 0x14f1506e:
		this->name = "Conexant CX20590";
		/*
		 * Enable dock audio on Thinkpad docks
		 * 0x17aa : 0x20f2 = Thinkpad T400
		 * 0x17aa : 0x215e = Thinkpad T410
		 * 0x17aa : 0x215f = Thinkpad T510
		 * 0x17aa : 0x21ce = Thinkpad T420
		 * 0x17aa : 0x21cf = Thinkpad T520
		 * 0x17aa : 0x21da = Thinkpad X220
		 * 0x17aa : 0x21db = Thinkpad X220t
		 */
		if (this->subid == 0x20f217aa ||
		    this->subid == 0x215e17aa ||
		    this->subid == 0x215f17aa ||
		    this->subid == 0x21ce17aa ||
		    this->subid == 0x21cf17aa ||
		    this->subid == 0x21da17aa ||
		    this->subid == 0x21db17aa)
			this->qrks |= AZ_QRK_WID_TPDOCK3;
		break;
	case 0x434d4980:
		this->name = "CMedia CMI9880";
		break;
	case 0x83847612:
		this->name = "Sigmatel STAC9230X";
		break;
	case 0x83847613:
		this->name = "Sigmatel STAC9230D";
		break;
	case 0x83847614:
		this->name = "Sigmatel STAC9229X";
		break;
	case 0x83847615:
		this->name = "Sigmatel STAC9229D";
		break;
	case 0x83847616:
		this->name = "Sigmatel STAC9228X";
		if (this->subid == 0x02271028 ||	/* DELL_V1400 */
		    this->subid == 0x01f31028) {	/* DELL_I1400 */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_2;
	 	}
		break;
	case 0x83847617:
		this->name = "Sigmatel STAC9228D";
		break;
	case 0x83847618:
		this->name = "Sigmatel STAC9227X";
		break;
	case 0x83847619:
		this->name = "Sigmatel STAC9227D";
		break;
	case 0x83847620:
		this->name = "Sigmatel STAC9274";
		break;
	case 0x83847621:
		this->name = "Sigmatel STAC9274D";
		break;
	case 0x83847626:
		this->name = "Sigmatel STAC9271X";
		break;
	case 0x83847627:
		this->name = "Sigmatel STAC9271D";
		break;
	case 0x83847632:
		this->name = "Sigmatel STAC9202";
		break;
	case 0x83847634:
		this->name = "Sigmatel STAC9250";
		break;
	case 0x83847636:
		this->name = "Sigmatel STAC9251";
		break;
	case 0x83847638:
		this->name = "IDT 92HD700X";
		break;
	case 0x83847639:
		this->name = "IDT 92HD700D";
		break;
	case 0x83847645:
		this->name = "IDT 92HD206X";
		break;
	case 0x83847646:
		this->name = "IDT 92HD206D";
		break;
	case 0x83847661:
		/* FALLTHROUGH */
	case 0x83847662:
		this->name = "Sigmatel STAC9225";
		break;
	case 0x83847680:
		this->name = "Sigmatel STAC9220/1";
		if (this->subid == 0x76808384) {	/* APPLE_ID */
			this->qrks |= AZ_QRK_GPIO_POL_0 | AZ_QRK_GPIO_UNMUTE_0 |
			     AZ_QRK_GPIO_UNMUTE_1;
		}
		break;
	case 0x83847682:
		/* FALLTHROUGH */
	case 0x83847683:
		this->name = "Sigmatel STAC9221D";	/* aka IDT 92HD202 */
		break;
	case 0x83847690:
		this->name = "Sigmatel STAC9200";	/* aka IDT 92HD001 */
		break;
	case 0x83847691:
		this->name = "Sigmatel STAC9200D";
		break;
	case 0x83847698:
		this->name = "IDT 92HD005";
		break;
	case 0x83847699:
		this->name = "IDT 92HD005D";
		break;
	case 0x838476a0:
		this->name = "Sigmatel STAC9205X";
		if (this->subid == 0x01f91028 ||	/* DELL_D630 */
		    this->subid == 0x02281028) {	/* DELL_V1500 */
			this->qrks |= AZ_QRK_GPIO_UNMUTE_0;
		}
		break;
	case 0x838476a1:
		this->name = "Sigmatel STAC9205D";
		break;
	case 0x838476a2:
		this->name = "Sigmatel STAC9204X";
		break;
	case 0x838476a3:
		this->name = "Sigmatel STAC9204D";
		break;
	}
	return 0;
}

/* ----------------------------------------------------------------
 * functions for generic codecs
 * ---------------------------------------------------------------- */

int
azalia_widget_enabled(const codec_t *this, nid_t nid)
{
	if (!VALID_WIDGET_NID(nid, this) || !this->w[nid].enable)
		return 0;
	return 1;
}

int
azalia_init_dacgroup(codec_t *this)
{
	this->dacs.ngroups = 0;
	if (this->na_dacs > 0)
		azalia_add_convgroup(this, &this->dacs,
		    this->opins, this->nopins,
		    this->a_dacs, this->na_dacs,
		    COP_AWTYPE_AUDIO_OUTPUT, 0);
	if (this->na_dacs_d > 0)
		azalia_add_convgroup(this, &this->dacs,
		    this->opins_d, this->nopins_d,
		    this->a_dacs_d, this->na_dacs_d,
		    COP_AWTYPE_AUDIO_OUTPUT, COP_AWCAP_DIGITAL);
	this->dacs.cur = 0;

	this->adcs.ngroups = 0;
	if (this->na_adcs > 0)
		azalia_add_convgroup(this, &this->adcs,
		    this->ipins, this->nipins,
		    this->a_adcs, this->na_adcs,
		    COP_AWTYPE_AUDIO_INPUT, 0);
	if (this->na_adcs_d > 0)
		azalia_add_convgroup(this, &this->adcs,
		    this->ipins_d, this->nipins_d,
		    this->a_adcs_d, this->na_adcs_d,
		    COP_AWTYPE_AUDIO_INPUT, COP_AWCAP_DIGITAL);
	this->adcs.cur = 0;

	return 0;
}

int
azalia_add_convgroup(codec_t *this, convgroupset_t *group,
    struct io_pin *pins, int npins, nid_t *all_convs, int nall_convs,
    uint32_t type, uint32_t digital)
{
	nid_t convs[HDA_MAX_CHANNELS];
	int nconvs;
	nid_t conv;
	int i, j, k;

	nconvs = 0;

	/* default pin connections */
	for (i = 0; i < npins; i++) {
		conv = pins[i].conv;
		if (conv < 0)
			continue;
		for (j = 0; j < nconvs; j++) {
			if (convs[j] == conv)
				break;
		}
		if (j < nconvs)
			continue;
		convs[nconvs++] = conv;
		if (nconvs >= nall_convs) {
			goto done;
		}
	}
	/* non-default connections */
	for (i = 0; i < npins; i++) {
		for (j = 0; j < nall_convs; j++) {
			conv = all_convs[j];
			for (k = 0; k < nconvs; k++) {
				if (convs[k] == conv)
					break;
			}
			if (k < nconvs)
				continue;
			if (type == COP_AWTYPE_AUDIO_OUTPUT) {
				k = azalia_codec_fnode(this, conv,
				    pins[i].nid, 0);
				if (k < 0)
					continue;
			} else {
				if (!azalia_widget_enabled(this, conv))
					continue;
				k = azalia_codec_fnode(this, pins[i].nid,
				    conv, 0);
				if (k < 0)
					continue;
			}
			convs[nconvs++] = conv;
			if (nconvs >= nall_convs) {
				goto done;
			}
		}
	}
	/* Make sure the speaker dac is part of the analog output convgroup
	 * or it won't get connected by azalia_codec_connect_stream().
	 */
	if (type == COP_AWTYPE_AUDIO_OUTPUT && !digital &&
	    nconvs < nall_convs && this->spkr_dac != -1) {
		for (i = 0; i < nconvs; i++)
			if (convs[i] == this->spkr_dac)
				break;
		if (i == nconvs)
			convs[nconvs++] = this->spkr_dac;
	}
done:
	for (i = 0; i < nconvs; i++)
		group->groups[group->ngroups].conv[i] = convs[i];
	if (nconvs > 0) {
		group->groups[group->ngroups].nconv = i;
		group->ngroups++;
	}

	/* Disable converters that aren't in a convgroup. */
	for (i = 0; i < nall_convs; i++) {
		conv = all_convs[i];
		for (j = 0; j < nconvs; j++)
			if (convs[j] == conv)
				break;
		if (j == nconvs)
			this->w[conv].enable = 0;
	}

	return 0;
}

int
azalia_codec_fnode(codec_t *this, nid_t node, int index, int depth)
{
	const widget_t *w;
	int i, ret;

	w = &this->w[index];
	if (w->nid == node) {
		return index;
	}
	/* back at the beginning or a bad end */
	if (depth > 0 &&
	    (w->type == COP_AWTYPE_PIN_COMPLEX ||
	    w->type == COP_AWTYPE_BEEP_GENERATOR ||
	    w->type == COP_AWTYPE_AUDIO_OUTPUT ||
	    w->type == COP_AWTYPE_AUDIO_INPUT))
		return -1;
	if (++depth >= 10)
		return -1;
	for (i = 0; i < w->nconnections; i++) {
		if (!azalia_widget_enabled(this, w->connections[i]))
			continue;
		ret = azalia_codec_fnode(this, node, w->connections[i], depth);
		if (ret >= 0)
			return ret;
	}
	return -1;
}

int
azalia_unsol_event(codec_t *this, int tag)
{
	mixer_ctrl_t mc;
	uint32_t result;
	int i, err, vol, vol2;

	err = 0;
	tag = CORB_UNSOL_TAG(tag);
	switch (tag) {
	case AZ_TAG_SPKR:
		mc.type = AUDIO_MIXER_ENUM;
		vol = 0;
		for (i = 0; !vol && !err && i < this->nsense_pins; i++) {
			if (!(this->spkr_muters & (1 << i)))
				continue;
			err = azalia_comresp(this, this->sense_pins[i],
			    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
			if (err || !(result & CORB_PWC_OUTPUT))
				continue;
			err = azalia_comresp(this, this->sense_pins[i],
			    CORB_GET_PIN_SENSE, 0, &result);
			if (!err && (result & CORB_PS_PRESENCE))
				vol = 1;
		}
		if (err)
			break;
		this->spkr_muted = vol;
		switch(this->spkr_mute_method) {
		case AZ_SPKR_MUTE_SPKR_MUTE:
			mc.un.ord = vol;
			err = azalia_mixer_set(this, this->speaker,
			    MI_TARGET_OUTAMP, &mc);
			if (!err && this->speaker2 != -1 &&
			    (this->w[this->speaker2].widgetcap & COP_AWCAP_OUTAMP) &&
			    (this->w[this->speaker2].outamp_cap & COP_AMPCAP_MUTE))
				err = azalia_mixer_set(this, this->speaker2,
				    MI_TARGET_OUTAMP, &mc);
			break;
		case AZ_SPKR_MUTE_SPKR_DIR:
			mc.un.ord = vol ? 0 : 1;
			err = azalia_mixer_set(this, this->speaker,
			    MI_TARGET_PINDIR, &mc);
			if (!err && this->speaker2 != -1 &&
			    (this->w[this->speaker2].d.pin.cap & COP_PINCAP_OUTPUT) &&
			    (this->w[this->speaker2].d.pin.cap & COP_PINCAP_INPUT))
				err = azalia_mixer_set(this, this->speaker2,
				    MI_TARGET_PINDIR, &mc);
			break;
		case AZ_SPKR_MUTE_DAC_MUTE:
			mc.un.ord = vol;
			err = azalia_mixer_set(this, this->spkr_dac,
			    MI_TARGET_OUTAMP, &mc);
			break;
		}
		break;

	case AZ_TAG_PLAYVOL:
		if (this->playvols.master == this->audiofunc)
			return EINVAL;
		err = azalia_comresp(this, this->playvols.master,
		    CORB_GET_VOLUME_KNOB, 0, &result);
		if (err)
			return err;

		vol = CORB_VKNOB_VOLUME(result) - this->playvols.hw_step;
		vol2 = vol * (AUDIO_MAX_GAIN / this->playvols.hw_nsteps);
		this->playvols.hw_step = CORB_VKNOB_VOLUME(result);

		vol = vol2 + this->playvols.vol_l;
		if (vol < 0)
			vol = 0;
		else if (vol > AUDIO_MAX_GAIN)
			vol = AUDIO_MAX_GAIN;
		this->playvols.vol_l = vol;

		vol = vol2 + this->playvols.vol_r;
		if (vol < 0)
			vol = 0;
		else if (vol > AUDIO_MAX_GAIN)
			vol = AUDIO_MAX_GAIN;
		this->playvols.vol_r = vol;

		mc.type = AUDIO_MIXER_VALUE;
		mc.un.value.num_channels = 2;
		mc.un.value.level[0] = this->playvols.vol_l;
		mc.un.value.level[1] = this->playvols.vol_r;
		err = azalia_mixer_set(this, this->playvols.master,
		    MI_TARGET_PLAYVOL, &mc);
		break;

	default:
		DPRINTF(("%s: unknown tag %d\n", __func__, tag));
		break;
	}

	return err;
}


/* ----------------------------------------------------------------
 * Generic mixer functions
 * ---------------------------------------------------------------- */

int
azalia_mixer_init(codec_t *this)
{
	/*
	 * pin		"<color>%2.2x"
	 * audio output	"dac%2.2x"
	 * audio input	"adc%2.2x"
	 * mixer	"mixer%2.2x"
	 * selector	"sel%2.2x"
	 */
	const widget_t *w, *ww;
	mixer_item_t *m;
	int err, i, j, k, bits;

	this->maxmixers = 10;
	this->nmixers = 0;
	this->mixers = mallocarray(this->maxmixers, sizeof(mixer_item_t),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}

	/* register classes */
	m = &this->mixers[AZ_CLASS_INPUT];
	m->devinfo.index = AZ_CLASS_INPUT;
	strlcpy(m->devinfo.label.name, AudioCinputs,
	    sizeof(m->devinfo.label.name));
	m->devinfo.type = AUDIO_MIXER_CLASS;
	m->devinfo.mixer_class = AZ_CLASS_INPUT;
	m->devinfo.next = AUDIO_MIXER_LAST;
	m->devinfo.prev = AUDIO_MIXER_LAST;
	m->nid = 0;

	m = &this->mixers[AZ_CLASS_OUTPUT];
	m->devinfo.index = AZ_CLASS_OUTPUT;
	strlcpy(m->devinfo.label.name, AudioCoutputs,
	    sizeof(m->devinfo.label.name));
	m->devinfo.type = AUDIO_MIXER_CLASS;
	m->devinfo.mixer_class = AZ_CLASS_OUTPUT;
	m->devinfo.next = AUDIO_MIXER_LAST;
	m->devinfo.prev = AUDIO_MIXER_LAST;
	m->nid = 0;

	m = &this->mixers[AZ_CLASS_RECORD];
	m->devinfo.index = AZ_CLASS_RECORD;
	strlcpy(m->devinfo.label.name, AudioCrecord,
	    sizeof(m->devinfo.label.name));
	m->devinfo.type = AUDIO_MIXER_CLASS;
	m->devinfo.mixer_class = AZ_CLASS_RECORD;
	m->devinfo.next = AUDIO_MIXER_LAST;
	m->devinfo.prev = AUDIO_MIXER_LAST;
	m->nid = 0;

	this->nmixers = AZ_CLASS_RECORD + 1;

#define MIXER_REG_PROLOG	\
	mixer_devinfo_t *d; \
	err = azalia_mixer_ensure_capacity(this, this->nmixers + 1); \
	if (err) \
		return err; \
	m = &this->mixers[this->nmixers]; \
	d = &m->devinfo; \
	m->nid = i

	FOR_EACH_WIDGET(this, i) {

		w = &this->w[i];
		if (!w->enable)
			continue;

		/* selector */
		if (w->nconnections > 0 && w->type != COP_AWTYPE_AUDIO_MIXER &&
		    !(w->nconnections == 1 &&
		    azalia_widget_enabled(this, w->connections[0]) &&
		    strcmp(w->name, this->w[w->connections[0]].name) == 0) &&
		    w->nid != this->mic) {
			MIXER_REG_PROLOG;
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s_source", w->name);
			d->type = AUDIO_MIXER_ENUM;
			if (w->mixer_class >= 0)
				d->mixer_class = w->mixer_class;
			else {
				if (w->type == COP_AWTYPE_AUDIO_SELECTOR)
					d->mixer_class = AZ_CLASS_INPUT;
				else
					d->mixer_class = AZ_CLASS_OUTPUT;
			}
			m->target = MI_TARGET_CONNLIST;
			for (j = 0, k = 0; j < w->nconnections && k < 32; j++) {
				if (!azalia_widget_enabled(this,
				    w->connections[j]))
					continue;
				d->un.e.member[k].ord = j;
				strlcpy(d->un.e.member[k].label.name,
				    this->w[w->connections[j]].name,
				    MAX_AUDIO_DEV_LEN);
				k++;
			}
			d->un.e.num_mem = k;
			this->nmixers++;
		}

		/* output mute */
		if (w->widgetcap & COP_AWCAP_OUTAMP &&
		    w->outamp_cap & COP_AMPCAP_MUTE &&
		    w->nid != this->mic) {
			MIXER_REG_PROLOG;
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s_mute", w->name);
			if (w->mixer_class >= 0)
				d->mixer_class = w->mixer_class;
			else {
				if (w->type == COP_AWTYPE_AUDIO_MIXER ||
				    w->type == COP_AWTYPE_AUDIO_SELECTOR ||
				    w->type == COP_AWTYPE_PIN_COMPLEX)
					d->mixer_class = AZ_CLASS_OUTPUT;
				else
					d->mixer_class = AZ_CLASS_INPUT;
			}
			m->target = MI_TARGET_OUTAMP;
			azalia_devinfo_offon(d);
			this->nmixers++;
		}

		/* output gain */
		if (w->widgetcap & COP_AWCAP_OUTAMP &&
		    COP_AMPCAP_NUMSTEPS(w->outamp_cap) &&
		    w->nid != this->mic) {
			MIXER_REG_PROLOG;
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s", w->name);
			d->type = AUDIO_MIXER_VALUE;
			if (w->mixer_class >= 0)
				d->mixer_class = w->mixer_class;
			else {
				if (w->type == COP_AWTYPE_AUDIO_MIXER ||
				    w->type == COP_AWTYPE_AUDIO_SELECTOR ||
				    w->type == COP_AWTYPE_PIN_COMPLEX)
					d->mixer_class = AZ_CLASS_OUTPUT;
				else
					d->mixer_class = AZ_CLASS_INPUT;
			}
			m->target = MI_TARGET_OUTAMP;
			d->un.v.num_channels = WIDGET_CHANNELS(w);
			d->un.v.units.name[0] = 0;
			d->un.v.delta =
			    MIXER_DELTA(COP_AMPCAP_NUMSTEPS(w->outamp_cap));
			this->nmixers++;
		}

		/* input mute */
		if (w->widgetcap & COP_AWCAP_INAMP &&
		    w->inamp_cap & COP_AMPCAP_MUTE &&
		    w->nid != this->speaker &&
		    w->nid != this->speaker2) {
			if (w->type != COP_AWTYPE_AUDIO_MIXER) {
				MIXER_REG_PROLOG;
				snprintf(d->label.name, sizeof(d->label.name),
				    "%s_mute", w->name);
				if (w->mixer_class >= 0)
					d->mixer_class = w->mixer_class;
				else
					d->mixer_class = AZ_CLASS_INPUT;
				m->target = 0;
				azalia_devinfo_offon(d);
				this->nmixers++;
			} else {
				MIXER_REG_PROLOG;
				snprintf(d->label.name, sizeof(d->label.name),
				    "%s_source", w->name);
				m->target = MI_TARGET_MUTESET;
				d->type = AUDIO_MIXER_SET;
				if (w->mixer_class >= 0)
					d->mixer_class = w->mixer_class;
				else
					d->mixer_class = AZ_CLASS_INPUT;
				for (j = 0, k = 0;
				    j < w->nconnections && k < 32; j++) {
					if (!azalia_widget_enabled(this,
					    w->connections[j]))
						continue;
					if (w->connections[j] == this->speaker ||
					    w->connections[j] == this->speaker2)
						continue;
					d->un.s.member[k].mask = 1 << j;
					strlcpy(d->un.s.member[k].label.name,
					    this->w[w->connections[j]].name,
					    MAX_AUDIO_DEV_LEN);
					k++;
				}
				d->un.s.num_mem = k;
				if (k != 0)
					this->nmixers++;
			}
		}

		/* input gain */
		if (w->widgetcap & COP_AWCAP_INAMP &&
		    COP_AMPCAP_NUMSTEPS(w->inamp_cap) &&
		    w->nid != this->speaker &&
		    w->nid != this->speaker2) {
			if (w->type != COP_AWTYPE_AUDIO_SELECTOR &&
			    w->type != COP_AWTYPE_AUDIO_MIXER) {
				MIXER_REG_PROLOG;
				snprintf(d->label.name, sizeof(d->label.name),
				    "%s", w->name);
				d->type = AUDIO_MIXER_VALUE;
				if (w->mixer_class >= 0)
					d->mixer_class = w->mixer_class;
				else
					d->mixer_class = AZ_CLASS_INPUT;
				m->target = 0;
				d->un.v.num_channels = WIDGET_CHANNELS(w);
				d->un.v.units.name[0] = 0;
				d->un.v.delta =
				    MIXER_DELTA(COP_AMPCAP_NUMSTEPS(w->inamp_cap));
				this->nmixers++;
			} else {
				for (j = 0; j < w->nconnections; j++) {
					if (!azalia_widget_enabled(this,
					    w->connections[j]))
						continue;
					if (w->connections[j] == this->speaker ||
					    w->connections[j] == this->speaker2)
						continue;
					MIXER_REG_PROLOG;
					snprintf(d->label.name,
					    sizeof(d->label.name), "%s_%s",
					    w->name,
					    this->w[w->connections[j]].name);
					d->type = AUDIO_MIXER_VALUE;
					if (w->mixer_class >= 0)
						d->mixer_class = w->mixer_class;
					else
						d->mixer_class = AZ_CLASS_INPUT;
					m->target = j;
					d->un.v.num_channels = WIDGET_CHANNELS(w);
					d->un.v.units.name[0] = 0;
					d->un.v.delta =
					    MIXER_DELTA(COP_AMPCAP_NUMSTEPS(w->inamp_cap));
					this->nmixers++;
				}
			}
		}

		/* hardcoded mixer inputs */
		if (w->type == COP_AWTYPE_AUDIO_MIXER &&
		    !(w->widgetcap & COP_AWCAP_INAMP)) {
			MIXER_REG_PROLOG;
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s_source", w->name);
			m->target = MI_TARGET_MIXERSET;
			d->type = AUDIO_MIXER_SET;
			if (w->mixer_class >= 0)
				d->mixer_class = w->mixer_class;
			else
				d->mixer_class = AZ_CLASS_INPUT;
			for (j = 0, k = 0;
			    j < w->nconnections && k < 32; j++) {
				if (!azalia_widget_enabled(this,
				    w->connections[j]))
					continue;
				if (w->connections[j] == this->speaker ||
				    w->connections[j] == this->speaker2)
					continue;
				d->un.s.member[k].mask = 1 << j;
				strlcpy(d->un.s.member[k].label.name,
				    this->w[w->connections[j]].name,
				    MAX_AUDIO_DEV_LEN);
				k++;
			}
			d->un.s.num_mem = k;
			if (k != 0)
				this->nmixers++;
		}

		/* pin direction */
		if (w->type == COP_AWTYPE_PIN_COMPLEX &&
		    ((w->d.pin.cap & COP_PINCAP_OUTPUT &&
		    w->d.pin.cap & COP_PINCAP_INPUT) ||
		    COP_PINCAP_VREF(w->d.pin.cap) > 1)) {

			MIXER_REG_PROLOG;
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s_dir", w->name);
			d->type = AUDIO_MIXER_ENUM;
			d->mixer_class = AZ_CLASS_OUTPUT;
			m->target = MI_TARGET_PINDIR;

			k = 0;
			d->un.e.member[k].ord = 0;
			strlcpy(d->un.e.member[k].label.name, "none",
			    MAX_AUDIO_DEV_LEN);
			k++;

			if (w->d.pin.cap & COP_PINCAP_OUTPUT) {
				d->un.e.member[k].ord = 1;
				strlcpy(d->un.e.member[k].label.name,
				    AudioNoutput, MAX_AUDIO_DEV_LEN);
				k++;
			}

			if (w->d.pin.cap & COP_PINCAP_INPUT) {
				d->un.e.member[k].ord = 2;
				strlcpy(d->un.e.member[k].label.name,
				    AudioNinput, MAX_AUDIO_DEV_LEN);
				k++;

				for (j = 0; j < 4; j++) {
					if (j == 0) {
						bits = (1 << CORB_PWC_VREF_GND);
						strlcpy(d->un.e.member[k].label.name,
						    AudioNinput "-vr0",
						    MAX_AUDIO_DEV_LEN);
					} else if (j == 1) {
						bits = (1 << CORB_PWC_VREF_50);
						strlcpy(d->un.e.member[k].label.name,
						    AudioNinput "-vr50",
						    MAX_AUDIO_DEV_LEN);
					} else if (j == 2) {
						bits = (1 << CORB_PWC_VREF_80);
						strlcpy(d->un.e.member[k].label.name,
						    AudioNinput "-vr80",
						    MAX_AUDIO_DEV_LEN);
					} else if (j == 3) {
						bits = (1 << CORB_PWC_VREF_100);
						strlcpy(d->un.e.member[k].label.name,
						    AudioNinput "-vr100",
						    MAX_AUDIO_DEV_LEN);
					}
					if ((COP_PINCAP_VREF(w->d.pin.cap) &
					    bits) == bits) {
						d->un.e.member[k].ord = j + 3;
						k++;
					}
				}
			}
			d->un.e.num_mem = k;
			this->nmixers++;
		}

		/* pin headphone-boost */
		if (w->type == COP_AWTYPE_PIN_COMPLEX &&
		    w->d.pin.cap & COP_PINCAP_HEADPHONE &&
		    w->nid != this->mic) {
			MIXER_REG_PROLOG;
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s_boost", w->name);
			d->mixer_class = AZ_CLASS_OUTPUT;
			m->target = MI_TARGET_PINBOOST;
			azalia_devinfo_offon(d);
			this->nmixers++;
		}

		if (w->type == COP_AWTYPE_PIN_COMPLEX &&
		    w->d.pin.cap & COP_PINCAP_EAPD) {
			MIXER_REG_PROLOG;
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s_eapd", w->name);
			d->mixer_class = AZ_CLASS_OUTPUT;
			m->target = MI_TARGET_EAPD;
			azalia_devinfo_offon(d);
			this->nmixers++;
		}
	}

	/* sense pins */
	for (i = 0; i < this->nsense_pins; i++) {
		if (!azalia_widget_enabled(this, this->sense_pins[i])) {
			DPRINTF(("%s: sense pin %2.2x not found\n",
			    __func__, this->sense_pins[i]));
			continue;
		}

		MIXER_REG_PROLOG;
		m->nid = this->w[this->sense_pins[i]].nid;
		snprintf(d->label.name, sizeof(d->label.name), "%s_sense",
		    this->w[this->sense_pins[i]].name);
		d->type = AUDIO_MIXER_ENUM;
		d->mixer_class = AZ_CLASS_OUTPUT;
		m->target = MI_TARGET_PINSENSE;
		d->un.e.num_mem = 2;
		d->un.e.member[0].ord = 0;
		strlcpy(d->un.e.member[0].label.name, "unplugged",
		    MAX_AUDIO_DEV_LEN);
		d->un.e.member[1].ord = 1;
		strlcpy(d->un.e.member[1].label.name, "plugged",
		    MAX_AUDIO_DEV_LEN);
		this->nmixers++;
	}

	/* spkr mute by jack sense */
	this->spkr_mute_method = AZ_SPKR_MUTE_NONE;
	if (this->speaker != -1 && this->spkr_dac != -1 && this->nsense_pins > 0) {
		w = &this->w[this->speaker];
		if ((w->widgetcap & COP_AWCAP_OUTAMP) &&
		    (w->outamp_cap & COP_AMPCAP_MUTE))
			this->spkr_mute_method = AZ_SPKR_MUTE_SPKR_MUTE;
		else if ((w->d.pin.cap & COP_PINCAP_OUTPUT) &&
		    (w->d.pin.cap & COP_PINCAP_INPUT))
			this->spkr_mute_method = AZ_SPKR_MUTE_SPKR_DIR;
		else {
			w = &this->w[this->spkr_dac];
			if (w->nid != this->dacs.groups[0].conv[0] &&
			    (w->widgetcap & COP_AWCAP_OUTAMP) &&
			    (w->outamp_cap & COP_AMPCAP_MUTE))
				this->spkr_mute_method = AZ_SPKR_MUTE_DAC_MUTE;
		}
	}
	if (this->spkr_mute_method != AZ_SPKR_MUTE_NONE) {
		w = &this->w[this->speaker];
		MIXER_REG_PROLOG;
		m->nid = w->nid;
		snprintf(d->label.name, sizeof(d->label.name),
		    "%s_muters", w->name);
		m->target = MI_TARGET_SENSESET;
		d->type = AUDIO_MIXER_SET;
		d->mixer_class = AZ_CLASS_OUTPUT;
		this->spkr_muters = 0;
		for (i = 0, j = 0; i < this->nsense_pins; i++) {
			ww = &this->w[this->sense_pins[i]];
			if (!(ww->d.pin.cap & COP_PINCAP_OUTPUT))
				continue;
			if (!(ww->widgetcap & COP_AWCAP_UNSOL))
				continue;
			d->un.s.member[j].mask = 1 << i;
			this->spkr_muters |= (1 << i);
			strlcpy(d->un.s.member[j++].label.name, ww->name,
			    MAX_AUDIO_DEV_LEN);
		}
		d->un.s.num_mem = j;
		if (j != 0)
			this->nmixers++;
	}

	/* playback volume group */
	if (this->playvols.nslaves > 0) {
		mixer_devinfo_t *d;
		err = azalia_mixer_ensure_capacity(this,
		    this->nmixers + 3);

		/* volume */
		m = &this->mixers[this->nmixers];
		m->nid = this->playvols.master;
		m->target = MI_TARGET_PLAYVOL;
		d = &m->devinfo;
		d->mixer_class = AZ_CLASS_OUTPUT;
		snprintf(d->label.name, sizeof(d->label.name),
		    "%s", AudioNmaster);
		d->type = AUDIO_MIXER_VALUE;
		d->un.v.num_channels = 2;
		d->un.v.delta = 8;
		this->nmixers++;
		d->next = this->nmixers;

		/* mute */
		m = &this->mixers[this->nmixers];
		m->nid = this->playvols.master;
		m->target = MI_TARGET_PLAYVOL;
		d = &m->devinfo;
		d->prev = this->nmixers - 1;
		d->mixer_class = AZ_CLASS_OUTPUT;
		snprintf(d->label.name, sizeof(d->label.name),
		    "%s", AudioNmute);
		azalia_devinfo_offon(d);
		this->nmixers++;
		d->next = this->nmixers;

		/* slaves */
		m = &this->mixers[this->nmixers];
		m->nid = this->playvols.master;
		m->target = MI_TARGET_PLAYVOL;
		d = &m->devinfo;
		d->prev = this->nmixers - 1;
		d->mixer_class = AZ_CLASS_OUTPUT;
		snprintf(d->label.name, sizeof(d->label.name),
		    "%s", "slaves");
		d->type = AUDIO_MIXER_SET;
		for (i = 0, j = 0; i < this->playvols.nslaves; i++) {
			ww = &this->w[this->playvols.slaves[i]];
			d->un.s.member[j].mask = (1 << i);
			strlcpy(d->un.s.member[j++].label.name, ww->name,
			    MAX_AUDIO_DEV_LEN);
		}
		d->un.s.num_mem = j;
		this->nmixers++;
	}

	/* recording volume group */
	if (this->recvols.nslaves > 0) {
		mixer_devinfo_t *d;
		err = azalia_mixer_ensure_capacity(this,
		    this->nmixers + 3);

		/* volume */
		m = &this->mixers[this->nmixers];
		m->nid = this->recvols.master;
		m->target = MI_TARGET_RECVOL;
		d = &m->devinfo;
		d->mixer_class = AZ_CLASS_RECORD;
		snprintf(d->label.name, sizeof(d->label.name),
		    "%s", AudioNvolume);
		d->type = AUDIO_MIXER_VALUE;
		d->un.v.num_channels = 2;
		d->un.v.delta = 8;
		this->nmixers++;
		d->next = this->nmixers;

		/* mute */
		m = &this->mixers[this->nmixers];
		m->nid = this->recvols.master;
		m->target = MI_TARGET_RECVOL;
		d = &m->devinfo;
		d->prev = this->nmixers - 1;
		d->mixer_class = AZ_CLASS_RECORD;
		snprintf(d->label.name, sizeof(d->label.name),
		    "%s", AudioNmute);
		azalia_devinfo_offon(d);
		this->nmixers++;
		d->next = this->nmixers;

		/* slaves */
		m = &this->mixers[this->nmixers];
		m->nid = this->recvols.master;
		m->target = MI_TARGET_RECVOL;
		d = &m->devinfo;
		d->prev = this->nmixers - 1;
		d->mixer_class = AZ_CLASS_RECORD;
		snprintf(d->label.name, sizeof(d->label.name),
		    "%s", "slaves");
		d->type = AUDIO_MIXER_SET;
		for (i = 0, j = 0; i < this->recvols.nslaves; i++) {
			ww = &this->w[this->recvols.slaves[i]];
			d->un.s.member[j].mask = (1 << i);
			strlcpy(d->un.s.member[j++].label.name, ww->name,
			    MAX_AUDIO_DEV_LEN);
		}
		d->un.s.num_mem = j;
		this->nmixers++;
	}

	/* if the codec has more than one DAC group, the first is analog
	 * and the second is digital.
	 */
	if (this->dacs.ngroups > 1) {
		MIXER_REG_PROLOG;
		strlcpy(d->label.name, AudioNmode, sizeof(d->label.name));
		d->type = AUDIO_MIXER_ENUM;
		d->mixer_class = AZ_CLASS_OUTPUT;
		m->target = MI_TARGET_DAC;
		m->nid = this->audiofunc;
		d->un.e.member[0].ord = 0;
		strlcpy(d->un.e.member[0].label.name, "analog",
		    MAX_AUDIO_DEV_LEN);
		d->un.e.member[1].ord = 1;
		strlcpy(d->un.e.member[1].label.name, "digital",
		    MAX_AUDIO_DEV_LEN);
		d->un.e.num_mem = 2;
		this->nmixers++;
	}

	/* if the codec has more than one ADC group, the first is analog
	 * and the second is digital.
	 */
	if (this->adcs.ngroups > 1) {
		MIXER_REG_PROLOG;
		strlcpy(d->label.name, AudioNmode, sizeof(d->label.name));
		d->type = AUDIO_MIXER_ENUM;
		d->mixer_class = AZ_CLASS_RECORD;
		m->target = MI_TARGET_ADC;
		m->nid = this->audiofunc;
		d->un.e.member[0].ord = 0;
		strlcpy(d->un.e.member[0].label.name, "analog",
		    MAX_AUDIO_DEV_LEN);
		d->un.e.member[1].ord = 1;
		strlcpy(d->un.e.member[1].label.name, "digital",
		    MAX_AUDIO_DEV_LEN);
		d->un.e.num_mem = 2;
		this->nmixers++;
	}

	azalia_mixer_fix_indexes(this);
	azalia_mixer_default(this);
	return 0;
}

void
azalia_devinfo_offon(mixer_devinfo_t *d)
{
	d->type = AUDIO_MIXER_ENUM;
	d->un.e.num_mem = 2;
	d->un.e.member[0].ord = 0;
	strlcpy(d->un.e.member[0].label.name, AudioNoff, MAX_AUDIO_DEV_LEN);
	d->un.e.member[1].ord = 1;
	strlcpy(d->un.e.member[1].label.name, AudioNon, MAX_AUDIO_DEV_LEN);
}

int
azalia_mixer_ensure_capacity(codec_t *this, size_t newsize)
{
	size_t newmax;
	void *newbuf;

	if (this->maxmixers >= newsize)
		return 0;
	newmax = this->maxmixers + 10;
	if (newmax < newsize)
		newmax = newsize;
	newbuf = mallocarray(newmax, sizeof(mixer_item_t), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (newbuf == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	bcopy(this->mixers, newbuf, this->maxmixers * sizeof(mixer_item_t));
	free(this->mixers, M_DEVBUF, 0);
	this->mixers = newbuf;
	this->maxmixers = newmax;
	return 0;
}

int
azalia_mixer_fix_indexes(codec_t *this)
{
	int i;
	mixer_devinfo_t *d;

	for (i = 0; i < this->nmixers; i++) {
		d = &this->mixers[i].devinfo;
#ifdef DIAGNOSTIC
		if (d->index != 0 && d->index != i)
			printf("%s: index mismatch %d %d\n", __func__,
			    d->index, i);
#endif
		d->index = i;
		if (d->prev == 0)
			d->prev = AUDIO_MIXER_LAST;
		if (d->next == 0)
			d->next = AUDIO_MIXER_LAST;
	}
	return 0;
}

int
azalia_mixer_default(codec_t *this)
{
	widget_t *w;
	mixer_item_t *m;
	mixer_ctrl_t mc;
	int i, j, tgt, cap, err;

	/* unmute all */
	for (i = 0; i < this->nmixers; i++) {
		m = &this->mixers[i];
		if (!IS_MI_TARGET_INAMP(m->target) &&
		    m->target != MI_TARGET_OUTAMP)
			continue;
		if (m->devinfo.type != AUDIO_MIXER_ENUM)
			continue;
		bzero(&mc, sizeof(mc));
		mc.dev = i;
		mc.type = AUDIO_MIXER_ENUM;
		azalia_mixer_set(this, m->nid, m->target, &mc);
	}

	/* set unextreme volume */
	for (i = 0; i < this->nmixers; i++) {
		m = &this->mixers[i];
		if (!IS_MI_TARGET_INAMP(m->target) &&
		    m->target != MI_TARGET_OUTAMP)
			continue;
		if (m->devinfo.type != AUDIO_MIXER_VALUE)
			continue;
		bzero(&mc, sizeof(mc));
		mc.dev = i;
		mc.type = AUDIO_MIXER_VALUE;
		mc.un.value.num_channels = 1;
		mc.un.value.level[0] = AUDIO_MAX_GAIN / 2;
		if (WIDGET_CHANNELS(&this->w[m->nid]) == 2) {
			mc.un.value.num_channels = 2;
			mc.un.value.level[1] = mc.un.value.level[0];
		}
		azalia_mixer_set(this, m->nid, m->target, &mc);
	}

	/* unmute all */
	for (i = 0; i < this->nmixers; i++) {
		m = &this->mixers[i];
		if (m->target != MI_TARGET_MUTESET)
			continue;
		if (m->devinfo.type != AUDIO_MIXER_SET)
			continue;
		bzero(&mc, sizeof(mc));
		mc.dev = i;
		mc.type = AUDIO_MIXER_SET;
		if (!azalia_widget_enabled(this, m->nid)) {
			DPRINTF(("%s: invalid set nid\n", __func__));
			return EINVAL;
		}
		w = &this->w[m->nid];
		for (j = 0; j < w->nconnections; j++) {
			if (!azalia_widget_enabled(this, w->connections[j]))
				continue;
			if (w->nid == this->input_mixer &&
			    w->connections[j] == this->mic)
				continue;
			mc.un.mask |= 1 << j;
		}
		azalia_mixer_set(this, m->nid, m->target, &mc);
	}

	/* make sure default connection is valid */
	for (i = 0; i < this->nmixers; i++) {
		m = &this->mixers[i];
		if (m->target != MI_TARGET_CONNLIST)
			continue;

		azalia_mixer_get(this, m->nid, m->target, &mc);
		for (j = 0; j < m->devinfo.un.e.num_mem; j++) {
			if (mc.un.ord == m->devinfo.un.e.member[j].ord)
				break;
		}
		if (j >= m->devinfo.un.e.num_mem) {
			bzero(&mc, sizeof(mc));
			mc.dev = i;
			mc.type = AUDIO_MIXER_ENUM;
			mc.un.ord = m->devinfo.un.e.member[0].ord;
		}
		azalia_mixer_set(this, m->nid, m->target, &mc);
	}

	/* get default value for play group master */
	for (i = 0; i < this->playvols.nslaves; i++) {
		if (!(this->playvols.cur & (1 << i)))
 			continue;
		w = &this->w[this->playvols.slaves[i]];
		if (!(COP_AMPCAP_NUMSTEPS(w->outamp_cap)))
			continue;
		mc.type = AUDIO_MIXER_VALUE;
		tgt = MI_TARGET_OUTAMP;
		azalia_mixer_get(this, w->nid, tgt, &mc);
		this->playvols.vol_l = mc.un.value.level[0];
		this->playvols.vol_r = mc.un.value.level[0];
		break;
 	}
	this->playvols.mute = 0;
 
	/* get default value for record group master */
	for (i = 0; i < this->recvols.nslaves; i++) {
		if (!(this->recvols.cur & (1 << i)))
			continue;
		w = &this->w[this->recvols.slaves[i]];
		mc.type = AUDIO_MIXER_VALUE;
		tgt = MI_TARGET_OUTAMP;
		cap = w->outamp_cap;
		if (w->type == COP_AWTYPE_PIN_COMPLEX ||
		    w->type == COP_AWTYPE_AUDIO_INPUT) {
			tgt = 0;
			cap = w->inamp_cap;
 		}
		if (!(COP_AMPCAP_NUMSTEPS(cap)))
			continue;
		azalia_mixer_get(this, w->nid, tgt, &mc);
		this->recvols.vol_l = mc.un.value.level[0];
		this->recvols.vol_r = mc.un.value.level[0];
		break;
 	}
	this->recvols.mute = 0;

	err = azalia_codec_enable_unsol(this);
	if (err)
		return(err);

	return 0;
}

int
azalia_codec_enable_unsol(codec_t *this)
{
	widget_t *w;
	uint32_t result;
	int i, err;

	/* jack sense */
	for (i = 0; i < this->nsense_pins; i++) {
		if (this->spkr_muters & (1 << i)) {
			azalia_comresp(this, this->sense_pins[i],
			    CORB_SET_UNSOLICITED_RESPONSE,
			    CORB_UNSOL_ENABLE | AZ_TAG_SPKR, NULL);
		}
	}
	if (this->spkr_muters != 0)
		azalia_unsol_event(this, AZ_TAG_SPKR);

	/* volume knob */
	if (this->playvols.master != this->audiofunc) {

		w = &this->w[this->playvols.master];
		err = azalia_comresp(this, w->nid, CORB_GET_VOLUME_KNOB,
		    0, &result);
		if (err) {
			DPRINTF(("%s: get volume knob error\n", __func__));
			return err;
		}

		/* current level */
		this->playvols.hw_step = CORB_VKNOB_VOLUME(result);
		this->playvols.hw_nsteps = COP_VKCAP_NUMSTEPS(w->d.volume.cap);

		/* indirect mode */
		result &= ~(CORB_VKNOB_DIRECT);
		err = azalia_comresp(this, w->nid, CORB_SET_VOLUME_KNOB,
		    result, NULL);
		if (err) {
			DPRINTF(("%s: set volume knob error\n", __func__));
			/* XXX If there was an error setting indirect
			 * mode, do not return an error.  However, do not
			 * enable unsolicited responses either.  Most
			 * likely the volume knob doesn't work right.
			 * Perhaps it's simply not wired/enabled.
			 */
			return 0;
		}

		/* enable unsolicited responses */
		result = CORB_UNSOL_ENABLE | AZ_TAG_PLAYVOL;
		err = azalia_comresp(this, w->nid,
		    CORB_SET_UNSOLICITED_RESPONSE, result, NULL);
		if (err) {
			DPRINTF(("%s: set vknob unsol resp error\n", __func__));
			return err;
		}
	}

	return 0;
}

int
azalia_mixer_delete(codec_t *this)
{
	if (this->mixers != NULL) {
		free(this->mixers, M_DEVBUF, 0);
		this->mixers = NULL;
	}
	return 0;
}

/**
 * @@param mc	mc->type must be set by the caller before the call
 */
int
azalia_mixer_get(const codec_t *this, nid_t nid, int target,
    mixer_ctrl_t *mc)
{
	uint32_t result, cap, value;
	nid_t n;
	int i, err;

	if (mc->type == AUDIO_MIXER_CLASS) {
		return(0);
	}

	/* inamp mute */
	else if (IS_MI_TARGET_INAMP(target) && mc->type == AUDIO_MIXER_ENUM) {
		err = azalia_comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		    CORB_GAGM_INPUT | CORB_GAGM_LEFT |
		    MI_TARGET_INAMP(target), &result);
		if (err)
			return err;
		mc->un.ord = result & CORB_GAGM_MUTE ? 1 : 0;
	}

	/* inamp gain */
	else if (IS_MI_TARGET_INAMP(target) && mc->type == AUDIO_MIXER_VALUE) {
		err = azalia_comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		      CORB_GAGM_INPUT | CORB_GAGM_LEFT |
		      MI_TARGET_INAMP(target), &result);
		if (err)
			return err;
		mc->un.value.level[0] = azalia_mixer_from_device_value(this,
		    nid, target, CORB_GAGM_GAIN(result));
		if (this->w[nid].type == COP_AWTYPE_AUDIO_SELECTOR ||
		    this->w[nid].type == COP_AWTYPE_AUDIO_MIXER) {
			n = this->w[nid].connections[MI_TARGET_INAMP(target)];
			if (!azalia_widget_enabled(this, n)) {
				DPRINTF(("%s: nid %2.2x invalid index %d\n",
				   __func__, nid,  MI_TARGET_INAMP(target)));
				n = nid;
			}
		} else
			n = nid;
		mc->un.value.num_channels = WIDGET_CHANNELS(&this->w[n]);
		if (mc->un.value.num_channels == 2) {
			err = azalia_comresp(this, nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE, CORB_GAGM_INPUT |
			    CORB_GAGM_RIGHT | MI_TARGET_INAMP(target),
			    &result);
			if (err)
				return err;
			mc->un.value.level[1] = azalia_mixer_from_device_value
			    (this, nid, target, CORB_GAGM_GAIN(result));
		}
	}

	/* outamp mute */
	else if (target == MI_TARGET_OUTAMP && mc->type == AUDIO_MIXER_ENUM) {
		err = azalia_comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		    CORB_GAGM_OUTPUT | CORB_GAGM_LEFT | 0, &result);
		if (err)
			return err;
		mc->un.ord = result & CORB_GAGM_MUTE ? 1 : 0;
	}

	/* outamp gain */
	else if (target == MI_TARGET_OUTAMP && mc->type == AUDIO_MIXER_VALUE) {
		err = azalia_comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		      CORB_GAGM_OUTPUT | CORB_GAGM_LEFT | 0, &result);
		if (err)
			return err;
		mc->un.value.level[0] = azalia_mixer_from_device_value(this,
		    nid, target, CORB_GAGM_GAIN(result));
		mc->un.value.num_channels = WIDGET_CHANNELS(&this->w[nid]);
		if (mc->un.value.num_channels == 2) {
			err = azalia_comresp(this, nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE,
			    CORB_GAGM_OUTPUT | CORB_GAGM_RIGHT | 0, &result);
			if (err)
				return err;
			mc->un.value.level[1] = azalia_mixer_from_device_value
			    (this, nid, target, CORB_GAGM_GAIN(result));
		}
	}

	/* selection */
	else if (target == MI_TARGET_CONNLIST) {
		err = azalia_comresp(this, nid,
		    CORB_GET_CONNECTION_SELECT_CONTROL, 0, &result);
		if (err)
			return err;
		result = CORB_CSC_INDEX(result);
		if (!azalia_widget_enabled(this,
		    this->w[nid].connections[result]))
			mc->un.ord = -1;
		else
			mc->un.ord = result;
	}

	/* pin I/O */
	else if (target == MI_TARGET_PINDIR) {
		err = azalia_comresp(this, nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err)
			return err;

		value = result;
		if (!(result & (CORB_PWC_INPUT | CORB_PWC_OUTPUT)))
			mc->un.ord = 0;
		else if (result & CORB_PWC_OUTPUT)
			mc->un.ord = 1;
		else {
			cap = COP_PINCAP_VREF(this->w[nid].d.pin.cap);
			result &= CORB_PWC_VREF_MASK;
			if (result == CORB_PWC_VREF_GND)
				mc->un.ord = 3;
			else if (result == CORB_PWC_VREF_50)
				mc->un.ord = 4;
			else if (result == CORB_PWC_VREF_80)
				mc->un.ord = 5;
			else if (result == CORB_PWC_VREF_100)
				mc->un.ord = 6;
			else
				mc->un.ord = 2;
		}
	}

	/* pin headphone-boost */
	else if (target == MI_TARGET_PINBOOST) {
		err = azalia_comresp(this, nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err)
			return err;
		mc->un.ord = result & CORB_PWC_HEADPHONE ? 1 : 0;
	}

	/* DAC group selection */
	else if (target == MI_TARGET_DAC) {
		mc->un.ord = this->dacs.cur;
	}

	/* ADC selection */
	else if (target == MI_TARGET_ADC) {
		mc->un.ord = this->adcs.cur;
	}

	/* S/PDIF */
	else if (target == MI_TARGET_SPDIF) {
		err = azalia_comresp(this, nid, CORB_GET_DIGITAL_CONTROL,
		    0, &result);
		if (err)
			return err;
		mc->un.mask = result & 0xff & ~(CORB_DCC_DIGEN | CORB_DCC_NAUDIO);
	} else if (target == MI_TARGET_SPDIF_CC) {
		err = azalia_comresp(this, nid, CORB_GET_DIGITAL_CONTROL,
		    0, &result);
		if (err)
			return err;
		mc->un.value.num_channels = 1;
		mc->un.value.level[0] = CORB_DCC_CC(result);
	}

	/* EAPD */
	else if (target == MI_TARGET_EAPD) {
		err = azalia_comresp(this, nid, CORB_GET_EAPD_BTL_ENABLE,
		    0, &result);
		if (err)
			return err;
		mc->un.ord = result & CORB_EAPD_EAPD ? 1 : 0;
	}

	/* sense pin */
	else if (target == MI_TARGET_PINSENSE) {
		err = azalia_comresp(this, nid, CORB_GET_PIN_SENSE,
		    0, &result);
		if (err)
			return err;
		mc->un.ord = result & CORB_PS_PRESENCE ? 1 : 0;
	}

	/* mute set */
	else if (target == MI_TARGET_MUTESET && mc->type == AUDIO_MIXER_SET) {
		const widget_t *w;

		if (!azalia_widget_enabled(this, nid)) {
			DPRINTF(("%s: invalid muteset nid\n", XNAME(this)));
			return EINVAL;
		}
		w = &this->w[nid];
		mc->un.mask = 0;
		for (i = 0; i < w->nconnections; i++) {
			if (!azalia_widget_enabled(this, w->connections[i]))
				continue;
			err = azalia_comresp(this, nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE,
			    CORB_GAGM_INPUT | CORB_GAGM_LEFT |
			    MI_TARGET_INAMP(i), &result);
			if (err)
				return err;
			mc->un.mask |= (result & CORB_GAGM_MUTE) ? 0 : (1 << i);
		}
	}

	/* mixer set - show all connections */
	else if (target == MI_TARGET_MIXERSET && mc->type == AUDIO_MIXER_SET) {
		const widget_t *w;

		if (!azalia_widget_enabled(this, nid)) {
			DPRINTF(("%s: invalid mixerset nid\n", XNAME(this)));
			return EINVAL;
		}
		w = &this->w[nid];
		mc->un.mask = 0;
		for (i = 0; i < w->nconnections; i++) {
			if (!azalia_widget_enabled(this, w->connections[i]))
				continue;
			mc->un.mask |= (1 << i);
		}
	}

	else if (target == MI_TARGET_SENSESET && mc->type == AUDIO_MIXER_SET) {

		if (nid == this->speaker) {
			mc->un.mask = this->spkr_muters;
		} else {
			DPRINTF(("%s: invalid senseset nid\n", XNAME(this)));
			return EINVAL;
		}
	}

	else if (target == MI_TARGET_PLAYVOL) {

		if (mc->type == AUDIO_MIXER_VALUE) {
			mc->un.value.num_channels = 2;
			mc->un.value.level[0] = this->playvols.vol_l;
			mc->un.value.level[1] = this->playvols.vol_r;

		} else if (mc->type == AUDIO_MIXER_ENUM) {
			mc->un.ord = this->playvols.mute;

		} else if (mc->type == AUDIO_MIXER_SET) {
			mc->un.mask = this->playvols.cur;

		} else {
			DPRINTF(("%s: invalid outmaster mixer type\n",
				XNAME(this)));
			return EINVAL;
		}
	}

	else if (target == MI_TARGET_RECVOL) {

		if (mc->type == AUDIO_MIXER_VALUE) {
			mc->un.value.num_channels = 2;
			mc->un.value.level[0] = this->recvols.vol_l;
			mc->un.value.level[1] = this->recvols.vol_r;

		} else if (mc->type == AUDIO_MIXER_ENUM) {
			mc->un.ord = this->recvols.mute;

		} else if (mc->type == AUDIO_MIXER_SET) {
			mc->un.mask = this->recvols.cur;

		} else {
			DPRINTF(("%s: invalid inmaster mixer type\n",
				XNAME(this)));
			return EINVAL;
		}
	}

	else {
		DPRINTF(("%s: internal error in %s: target=%x\n",
		    XNAME(this), __func__, target));
		return -1;
	}
	return 0;
}

int
azalia_mixer_set(codec_t *this, nid_t nid, int target, const mixer_ctrl_t *mc)
{
	uint32_t result, value;
	int i, err;

	if (mc->type == AUDIO_MIXER_CLASS) {
		return(0);
	}

	/* inamp mute */
	else if (IS_MI_TARGET_INAMP(target) && mc->type == AUDIO_MIXER_ENUM) {
		/* set stereo mute separately to keep each gain value */
		err = azalia_comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		    CORB_GAGM_INPUT | CORB_GAGM_LEFT |
		    MI_TARGET_INAMP(target), &result);
		if (err)
			return err;
		value = CORB_AGM_INPUT | CORB_AGM_LEFT |
		    (target << CORB_AGM_INDEX_SHIFT) |
		    CORB_GAGM_GAIN(result);
		if (mc->un.ord)
			value |= CORB_AGM_MUTE;
		err = azalia_comresp(this, nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
		    value, &result);
		if (err)
			return err;
		if (WIDGET_CHANNELS(&this->w[nid]) == 2) {
			err = azalia_comresp(this, nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE, CORB_GAGM_INPUT |
			    CORB_GAGM_RIGHT | MI_TARGET_INAMP(target),
			    &result);
			if (err)
				return err;
			value = CORB_AGM_INPUT | CORB_AGM_RIGHT |
			    (target << CORB_AGM_INDEX_SHIFT) |
			    CORB_GAGM_GAIN(result);
			if (mc->un.ord)
				value |= CORB_AGM_MUTE;
			err = azalia_comresp(this, nid,
			    CORB_SET_AMPLIFIER_GAIN_MUTE, value, &result);
			if (err)
				return err;
		}
	}

	/* inamp gain */
	else if (IS_MI_TARGET_INAMP(target) && mc->type == AUDIO_MIXER_VALUE) {
		if (mc->un.value.num_channels < 1)
			return EINVAL;
		err = azalia_comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		      CORB_GAGM_INPUT | CORB_GAGM_LEFT |
		      MI_TARGET_INAMP(target), &result);
		if (err)
			return err;
		value = azalia_mixer_to_device_value(this, nid, target,
		    mc->un.value.level[0]);
		value = CORB_AGM_INPUT | CORB_AGM_LEFT |
		    (target << CORB_AGM_INDEX_SHIFT) |
		    (result & CORB_GAGM_MUTE ? CORB_AGM_MUTE : 0) |
		    (value & CORB_AGM_GAIN_MASK);
		err = azalia_comresp(this, nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
		    value, &result);
		if (err)
			return err;
		if (mc->un.value.num_channels >= 2 &&
		    WIDGET_CHANNELS(&this->w[nid]) == 2) {
			err = azalia_comresp(this, nid,
			      CORB_GET_AMPLIFIER_GAIN_MUTE, CORB_GAGM_INPUT |
			      CORB_GAGM_RIGHT | MI_TARGET_INAMP(target),
			      &result);
			if (err)
				return err;
			value = azalia_mixer_to_device_value(this, nid, target,
			    mc->un.value.level[1]);
			value = CORB_AGM_INPUT | CORB_AGM_RIGHT |
			    (target << CORB_AGM_INDEX_SHIFT) |
			    (result & CORB_GAGM_MUTE ? CORB_AGM_MUTE : 0) |
			    (value & CORB_AGM_GAIN_MASK);
			err = azalia_comresp(this, nid,
			    CORB_SET_AMPLIFIER_GAIN_MUTE, value, &result);
			if (err)
				return err;
		}
	}

	/* outamp mute */
	else if (target == MI_TARGET_OUTAMP && mc->type == AUDIO_MIXER_ENUM) {
		err = azalia_comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		    CORB_GAGM_OUTPUT | CORB_GAGM_LEFT, &result);
		if (err)
			return err;
		value = CORB_AGM_OUTPUT | CORB_AGM_LEFT | CORB_GAGM_GAIN(result);
		if (mc->un.ord)
			value |= CORB_AGM_MUTE;
		err = azalia_comresp(this, nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
		    value, &result);
		if (err)
			return err;
		if (WIDGET_CHANNELS(&this->w[nid]) == 2) {
			err = azalia_comresp(this, nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE,
			    CORB_GAGM_OUTPUT | CORB_GAGM_RIGHT, &result);
			if (err)
				return err;
			value = CORB_AGM_OUTPUT | CORB_AGM_RIGHT |
			    CORB_GAGM_GAIN(result);
			if (mc->un.ord)
				value |= CORB_AGM_MUTE;
			err = azalia_comresp(this, nid,
			    CORB_SET_AMPLIFIER_GAIN_MUTE, value, &result);
			if (err)
				return err;
		}
	}

	/* outamp gain */
	else if (target == MI_TARGET_OUTAMP && mc->type == AUDIO_MIXER_VALUE) {
		if (mc->un.value.num_channels < 1)
			return EINVAL;
		err = azalia_comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		      CORB_GAGM_OUTPUT | CORB_GAGM_LEFT, &result);
		if (err)
			return err;
		value = azalia_mixer_to_device_value(this, nid, target,
		    mc->un.value.level[0]);
		value = CORB_AGM_OUTPUT | CORB_AGM_LEFT |
		    (result & CORB_GAGM_MUTE ? CORB_AGM_MUTE : 0) |
		    (value & CORB_AGM_GAIN_MASK);
		err = azalia_comresp(this, nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
		    value, &result);
		if (err)
			return err;
		if (mc->un.value.num_channels >= 2 &&
		    WIDGET_CHANNELS(&this->w[nid]) == 2) {
			err = azalia_comresp(this, nid,
			      CORB_GET_AMPLIFIER_GAIN_MUTE, CORB_GAGM_OUTPUT |
			      CORB_GAGM_RIGHT, &result);
			if (err)
				return err;
			value = azalia_mixer_to_device_value(this, nid, target,
			    mc->un.value.level[1]);
			value = CORB_AGM_OUTPUT | CORB_AGM_RIGHT |
			    (result & CORB_GAGM_MUTE ? CORB_AGM_MUTE : 0) |
			    (value & CORB_AGM_GAIN_MASK);
			err = azalia_comresp(this, nid,
			    CORB_SET_AMPLIFIER_GAIN_MUTE, value, &result);
			if (err)
				return err;
		}
	}

	/* selection */
	else if (target == MI_TARGET_CONNLIST) {
		if (mc->un.ord < 0 ||
		    mc->un.ord >= this->w[nid].nconnections ||
		    !azalia_widget_enabled(this,
		    this->w[nid].connections[mc->un.ord]))
			return EINVAL;
		err = azalia_comresp(this, nid,
		    CORB_SET_CONNECTION_SELECT_CONTROL, mc->un.ord, &result);
		if (err)
			return err;
	}

	/* pin I/O */
	else if (target == MI_TARGET_PINDIR) {

		err = azalia_comresp(this, nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err)
			return err;

		value = result;
		value &= ~(CORB_PWC_VREF_MASK);
		if (mc->un.ord == 0) {
			value &= ~(CORB_PWC_OUTPUT | CORB_PWC_INPUT);
		} else if (mc->un.ord == 1) {
			value &= ~CORB_PWC_INPUT;
			value |= CORB_PWC_OUTPUT;
			if (this->qrks & AZ_QRK_WID_OVREF50)
				value |= CORB_PWC_VREF_50;
		} else {
			value &= ~CORB_PWC_OUTPUT;
			value |= CORB_PWC_INPUT;

			if (mc->un.ord == 3)
				value |= CORB_PWC_VREF_GND;
			if (mc->un.ord == 4)
				value |= CORB_PWC_VREF_50;
			if (mc->un.ord == 5)
				value |= CORB_PWC_VREF_80;
			if (mc->un.ord == 6)
				value |= CORB_PWC_VREF_100;
		}
		err = azalia_comresp(this, nid,
		    CORB_SET_PIN_WIDGET_CONTROL, value, &result);
		if (err)
			return err;

		/* Run the unsolicited response handler for speaker mute
		 * since it depends on pin direction.
		 */
		for (i = 0; i < this->nsense_pins; i++) {
			if (this->sense_pins[i] == nid)
				break;
		}
		if (i < this->nsense_pins) {
			azalia_unsol_event(this, AZ_TAG_SPKR);
		}
	}

	/* pin headphone-boost */
	else if (target == MI_TARGET_PINBOOST) {
		if (mc->un.ord >= 2)
			return EINVAL;
		err = azalia_comresp(this, nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err)
			return err;
		if (mc->un.ord == 0) {
			result &= ~CORB_PWC_HEADPHONE;
		} else {
			result |= CORB_PWC_HEADPHONE;
		}
		err = azalia_comresp(this, nid,
		    CORB_SET_PIN_WIDGET_CONTROL, result, &result);
		if (err)
			return err;
	}

	/* DAC group selection */
	else if (target == MI_TARGET_DAC) {
		if (this->running)
			return EBUSY;
		if (mc->un.ord >= this->dacs.ngroups)
			return EINVAL;
		if (mc->un.ord != this->dacs.cur)
			return azalia_codec_construct_format(this,
			    mc->un.ord, this->adcs.cur);
		else
			return 0;
	}

	/* ADC selection */
	else if (target == MI_TARGET_ADC) {
		if (this->running)
			return EBUSY;
		if (mc->un.ord >= this->adcs.ngroups)
			return EINVAL;
		if (mc->un.ord != this->adcs.cur)
			return azalia_codec_construct_format(this,
			    this->dacs.cur, mc->un.ord);
		else
			return 0;
	}

	/* S/PDIF */
	else if (target == MI_TARGET_SPDIF) {
		err = azalia_comresp(this, nid, CORB_GET_DIGITAL_CONTROL,
		    0, &result);
		result &= CORB_DCC_DIGEN | CORB_DCC_NAUDIO;
		result |= mc->un.mask & 0xff & ~CORB_DCC_DIGEN;
		err = azalia_comresp(this, nid, CORB_SET_DIGITAL_CONTROL_L,
		    result, NULL);
		if (err)
			return err;
	} else if (target == MI_TARGET_SPDIF_CC) {
		if (mc->un.value.num_channels != 1)
			return EINVAL;
		if (mc->un.value.level[0] > 127)
			return EINVAL;
		err = azalia_comresp(this, nid, CORB_SET_DIGITAL_CONTROL_H,
		    mc->un.value.level[0], NULL);
		if (err)
			return err;
	}

	/* EAPD */
	else if (target == MI_TARGET_EAPD) {
		if (mc->un.ord >= 2)
			return EINVAL;
		err = azalia_comresp(this, nid,
		    CORB_GET_EAPD_BTL_ENABLE, 0, &result);
		if (err)
			return err;
		result &= 0xff;
		if (mc->un.ord == 0) {
			result &= ~CORB_EAPD_EAPD;
		} else {
			result |= CORB_EAPD_EAPD;
		}
		err = azalia_comresp(this, nid,
		    CORB_SET_EAPD_BTL_ENABLE, result, &result);
		if (err)
			return err;
	}

	else if (target == MI_TARGET_PINSENSE) {
		/* do nothing, control is read only */
	}

	else if (target == MI_TARGET_MUTESET && mc->type == AUDIO_MIXER_SET) {
		const widget_t *w;

		if (!azalia_widget_enabled(this, nid)) {
			DPRINTF(("%s: invalid muteset nid\n", XNAME(this)));
			return EINVAL;
		}
		w = &this->w[nid];
		for (i = 0; i < w->nconnections; i++) {
			if (!azalia_widget_enabled(this, w->connections[i]))
				continue;

			/* We have to set stereo mute separately
			 * to keep each gain value.
			 */
			err = azalia_comresp(this, nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE,
			    CORB_GAGM_INPUT | CORB_GAGM_LEFT |
			    MI_TARGET_INAMP(i), &result);
			if (err)
				return err;
			value = CORB_AGM_INPUT | CORB_AGM_LEFT |
			    (i << CORB_AGM_INDEX_SHIFT) |
			    CORB_GAGM_GAIN(result);
			if ((mc->un.mask & (1 << i)) == 0)
				value |= CORB_AGM_MUTE;
			err = azalia_comresp(this, nid,
			    CORB_SET_AMPLIFIER_GAIN_MUTE, value, &result);
			if (err)
				return err;

			if (WIDGET_CHANNELS(w) == 2) {
				err = azalia_comresp(this, nid,
				    CORB_GET_AMPLIFIER_GAIN_MUTE,
				    CORB_GAGM_INPUT | CORB_GAGM_RIGHT |
				    MI_TARGET_INAMP(i), &result);
				if (err)
					return err;
				value = CORB_AGM_INPUT | CORB_AGM_RIGHT |
				    (i << CORB_AGM_INDEX_SHIFT) |
				    CORB_GAGM_GAIN(result);
				if ((mc->un.mask & (1 << i)) == 0)
					value |= CORB_AGM_MUTE;
				err = azalia_comresp(this, nid,
				    CORB_SET_AMPLIFIER_GAIN_MUTE,
				    value, &result);
				if (err)
					return err;
			}
		}
	}

	else if (target == MI_TARGET_MIXERSET && mc->type == AUDIO_MIXER_SET) {
		/* do nothing, control is read only */
	}

	else if (target == MI_TARGET_SENSESET && mc->type == AUDIO_MIXER_SET) {

		if (nid == this->speaker) {
			this->spkr_muters = mc->un.mask;
			azalia_unsol_event(this, AZ_TAG_SPKR);
		} else {
			DPRINTF(("%s: invalid senseset nid\n", XNAME(this)));
			return EINVAL;
		}
	}

	else if (target == MI_TARGET_PLAYVOL) {

		const widget_t *w;
		mixer_ctrl_t mc2;

		if (mc->type == AUDIO_MIXER_VALUE) {
			if (mc->un.value.num_channels != 2)
				return EINVAL;
			this->playvols.vol_l = mc->un.value.level[0];
			this->playvols.vol_r = mc->un.value.level[1];
			for (i = 0; i < this->playvols.nslaves; i++) {
				if (!(this->playvols.cur & (1 << i)))
					continue;
				w = &this->w[this->playvols.slaves[i]];
				if (!(COP_AMPCAP_NUMSTEPS(w->outamp_cap)))
					continue;

				/* don't change volume if muted */
				if (w->outamp_cap & COP_AMPCAP_MUTE) {
					mc2.type = AUDIO_MIXER_ENUM;
					azalia_mixer_get(this, w->nid,
					    MI_TARGET_OUTAMP, &mc2);
					if (mc2.un.ord)
						continue;
				}
				mc2.type = AUDIO_MIXER_VALUE;
				mc2.un.value.num_channels = WIDGET_CHANNELS(w);
				mc2.un.value.level[0] = this->playvols.vol_l;
				mc2.un.value.level[1] = this->playvols.vol_r;
				err = azalia_mixer_set(this, w->nid,
				    MI_TARGET_OUTAMP, &mc2);
				if (err) {
					DPRINTF(("%s: out slave %2.2x vol\n",
					    __func__, w->nid));
					return err;
				}
			}
		} else if (mc->type == AUDIO_MIXER_ENUM) {
			if (mc->un.ord != 0 && mc->un.ord != 1)
				return EINVAL;
			this->playvols.mute = mc->un.ord;
			for (i = 0; i < this->playvols.nslaves; i++) {
				if (!(this->playvols.cur & (1 << i)))
					continue;
				w = &this->w[this->playvols.slaves[i]];
				if (!(w->outamp_cap & COP_AMPCAP_MUTE))
					continue;
				if (this->spkr_muted == 1 &&
				    ((this->spkr_mute_method ==
				    AZ_SPKR_MUTE_SPKR_MUTE &&
				    (w->nid == this->speaker ||
				    w->nid == this->speaker2)) ||
				    (this->spkr_mute_method ==
				    AZ_SPKR_MUTE_DAC_MUTE &&
				    w->nid == this->spkr_dac))) {
					continue;
				}
				mc2.type = AUDIO_MIXER_ENUM;
				mc2.un.ord = this->playvols.mute;
				err = azalia_mixer_set(this, w->nid,
				    MI_TARGET_OUTAMP, &mc2);
				if (err) {
					DPRINTF(("%s: out slave %2.2x mute\n",
					    __func__, w->nid));
					return err;
				}
			}

		} else if (mc->type == AUDIO_MIXER_SET) {
			this->playvols.cur =
			    (mc->un.mask & this->playvols.mask);

		} else {
			DPRINTF(("%s: invalid output master mixer type\n",
				XNAME(this)));
			return EINVAL;
		}
	}

	else if (target == MI_TARGET_RECVOL) {

		const widget_t *w;
		mixer_ctrl_t mc2;
		uint32_t cap;
		int tgt;

		if (mc->type == AUDIO_MIXER_VALUE) {
			if (mc->un.value.num_channels != 2)
				return EINVAL;
			this->recvols.vol_l = mc->un.value.level[0];
			this->recvols.vol_r = mc->un.value.level[1];
			for (i = 0; i < this->recvols.nslaves; i++) {
				if (!(this->recvols.cur & (1 << i)))
					continue;
				w = &this->w[this->recvols.slaves[i]];
				tgt = MI_TARGET_OUTAMP;
				cap = w->outamp_cap;
				if (w->type == COP_AWTYPE_AUDIO_INPUT ||
				    w->type == COP_AWTYPE_PIN_COMPLEX) {
					tgt = 0;
					cap = w->inamp_cap;
				}
				if (!(COP_AMPCAP_NUMSTEPS(cap)))
					continue;
				mc2.type = AUDIO_MIXER_VALUE;
				mc2.un.value.num_channels = WIDGET_CHANNELS(w);
				mc2.un.value.level[0] = this->recvols.vol_l;
				mc2.un.value.level[1] = this->recvols.vol_r;
				err = azalia_mixer_set(this, w->nid,
				    tgt, &mc2);
				if (err) {
					DPRINTF(("%s: in slave %2.2x vol\n",
					    __func__, w->nid));
					return err;
				}
			}
		} else if (mc->type == AUDIO_MIXER_ENUM) {
			if (mc->un.ord != 0 && mc->un.ord != 1)
				return EINVAL;
			this->recvols.mute = mc->un.ord;
			for (i = 0; i < this->recvols.nslaves; i++) {
				if (!(this->recvols.cur & (1 << i)))
					continue;
				w = &this->w[this->recvols.slaves[i]];
				tgt = MI_TARGET_OUTAMP;
				cap = w->outamp_cap;
				if (w->type == COP_AWTYPE_AUDIO_INPUT ||
				    w->type == COP_AWTYPE_PIN_COMPLEX) {
					tgt = 0;
					cap = w->inamp_cap;
				}
				if (!(cap & COP_AMPCAP_MUTE))
					continue;
				mc2.type = AUDIO_MIXER_ENUM;
				mc2.un.ord = this->recvols.mute;
				err = azalia_mixer_set(this, w->nid,
				    tgt, &mc2);
				if (err) {
					DPRINTF(("%s: out slave %2.2x mute\n",
					    __func__, w->nid));
					return err;
				}
			}

		} else if (mc->type == AUDIO_MIXER_SET) {
			this->recvols.cur = (mc->un.mask & this->recvols.mask);

		} else {
			DPRINTF(("%s: invalid input master mixer type\n",
				XNAME(this)));
			return EINVAL;
		}
	}

	else {
		DPRINTF(("%s: internal error in %s: target=%x\n",
		    XNAME(this), __func__, target));
		return -1;
	}
	return 0;
}

u_char
azalia_mixer_from_device_value(const codec_t *this, nid_t nid, int target,
    uint32_t dv)
{
	uint32_t steps;
	int max_gain, ctloff;

	if (IS_MI_TARGET_INAMP(target)) {
		steps = COP_AMPCAP_NUMSTEPS(this->w[nid].inamp_cap);
		ctloff = COP_AMPCAP_CTLOFF(this->w[nid].inamp_cap);
	} else if (target == MI_TARGET_OUTAMP) {
		steps = COP_AMPCAP_NUMSTEPS(this->w[nid].outamp_cap);
		ctloff = COP_AMPCAP_CTLOFF(this->w[nid].outamp_cap);
	} else {
		DPRINTF(("%s: unknown target: %d\n", __func__, target));
		steps = 255;
		ctloff = 0;
	}
	dv -= ctloff;
	if (dv <= 0 || steps == 0)
		return(AUDIO_MIN_GAIN);
	max_gain = AUDIO_MAX_GAIN - AUDIO_MAX_GAIN % steps;
	if (dv >= steps)
		return(max_gain);
	return(dv * max_gain / steps);
}

uint32_t
azalia_mixer_to_device_value(const codec_t *this, nid_t nid, int target,
    u_char uv)
{
	uint32_t steps;
	int max_gain, ctloff;

	if (IS_MI_TARGET_INAMP(target)) {
		steps = COP_AMPCAP_NUMSTEPS(this->w[nid].inamp_cap);
		ctloff = COP_AMPCAP_CTLOFF(this->w[nid].inamp_cap);
	} else if (target == MI_TARGET_OUTAMP) {
		steps = COP_AMPCAP_NUMSTEPS(this->w[nid].outamp_cap);
		ctloff = COP_AMPCAP_CTLOFF(this->w[nid].outamp_cap);
	} else {
		DPRINTF(("%s: unknown target: %d\n", __func__, target));
		steps = 255;
		ctloff = 0;
	}
	if (uv <= AUDIO_MIN_GAIN || steps == 0)
		return(ctloff);
	max_gain = AUDIO_MAX_GAIN - AUDIO_MAX_GAIN % steps;
	if (uv >= max_gain)
		return(steps + ctloff);
	return(uv * steps / max_gain + ctloff);
}

int
azalia_gpio_unmute(codec_t *this, int pin)
{
	uint32_t data, mask, dir;

	azalia_comresp(this, this->audiofunc, CORB_GET_GPIO_DATA, 0, &data);
	azalia_comresp(this, this->audiofunc, CORB_GET_GPIO_ENABLE_MASK, 0, &mask);
	azalia_comresp(this, this->audiofunc, CORB_GET_GPIO_DIRECTION, 0, &dir);

	data |= 1 << pin;
	mask |= 1 << pin;
	dir |= 1 << pin;

	azalia_comresp(this, this->audiofunc, CORB_SET_GPIO_ENABLE_MASK, mask, NULL);
	azalia_comresp(this, this->audiofunc, CORB_SET_GPIO_DIRECTION, dir, NULL);
	DELAY(1000);
	azalia_comresp(this, this->audiofunc, CORB_SET_GPIO_DATA, data, NULL);

	return 0;
}

void
azalia_ampcap_ov(widget_t *w, int type, int offset, int steps, int size,
   int ctloff, int mute)
{
	uint32_t cap;

	cap = (offset & 0x7f) | ((steps & 0x7f) << 8) |
	    ((size & 0x7f) << 16) | ((ctloff & 0x7f) << 24) |
	    (mute ? COP_AMPCAP_MUTE : 0);  

	if (type == COP_OUTPUT_AMPCAP) {
		w->outamp_cap = cap;
	} else if (type == COP_INPUT_AMPCAP) {
		w->inamp_cap = cap;
	}
}

void
azalia_pin_config_ov(widget_t *w, int mask, int val)
{
	int bits, offset;

	switch (mask) {
	case CORB_CD_DEVICE_MASK:
		bits = CORB_CD_DEVICE_BITS;
		offset = CORB_CD_DEVICE_OFFSET;
		break;
	case CORB_CD_PORT_MASK:
		bits = CORB_CD_PORT_BITS;
		offset = CORB_CD_PORT_OFFSET;
		break;
	default:
		return;
	}
	val &= bits;
	w->d.pin.config &= ~(mask);
	w->d.pin.config |= val << offset;
	if (mask == CORB_CD_DEVICE_MASK)
		w->d.pin.device = val;
}

int
azalia_codec_gpio_quirks(codec_t *this)
{
	if (this->qrks & AZ_QRK_GPIO_POL_0) {
		azalia_comresp(this, this->audiofunc,
		    CORB_SET_GPIO_POLARITY, 0, NULL);
	}
	if (this->qrks & AZ_QRK_GPIO_UNMUTE_0) {
		azalia_gpio_unmute(this, 0);
	}
	if (this->qrks & AZ_QRK_GPIO_UNMUTE_1) {
		azalia_gpio_unmute(this, 1);
	}
	if (this->qrks & AZ_QRK_GPIO_UNMUTE_2) {
		azalia_gpio_unmute(this, 2);
	}
	if (this->qrks & AZ_QRK_GPIO_UNMUTE_3) {
		azalia_gpio_unmute(this, 3);
	}

	return(0);
}

int
azalia_codec_widget_quirks(codec_t *this, nid_t nid)
{
	widget_t *w;

	w = &this->w[nid];

	if (this->qrks & AZ_QRK_WID_BEEP_1D &&
	    nid == 0x1d && w->enable == 0) {
		azalia_pin_config_ov(w, CORB_CD_DEVICE_MASK, CORB_CD_BEEP);
		azalia_pin_config_ov(w, CORB_CD_PORT_MASK, CORB_CD_FIXED);
		w->widgetcap |= COP_AWCAP_STEREO;
		w->enable = 1;
	}

	if (this->qrks & AZ_QRK_WID_TPDOCK1 &&
	    nid == 0x19) {
		/* Thinkpad x230/t430 style dock microphone */
		w->d.pin.config = 0x23a11040;
		w->enable = 1;
	}

	if (this->qrks & AZ_QRK_WID_TPDOCK1 &&
	    nid == 0x1b) {
		/* Thinkpad x230/t430 style dock headphone */
		w->d.pin.config = 0x2121103f;
		w->enable = 1;
	}

	if (this->qrks & AZ_QRK_WID_TPDOCK2 &&
	    nid == 0x16) {
		/* Thinkpad x240/t440 style dock headphone */
		w->d.pin.config = 0x21211010;
		w->enable = 1;
	}

	if (this->qrks & AZ_QRK_WID_TPDOCK2 &&
	    nid == 0x19) {
		/* Thinkpad x240/t440 style dock microphone */
		w->d.pin.config = 0x21a11010;
		w->enable = 1;
	}

	if (this->qrks & AZ_QRK_WID_TPDOCK3 &&
	    nid == 0x1a) {
		/* Thinkpad x220/t420 style dock microphone */
		w->d.pin.config = 0x21a190f0;
		w->enable = 1;
	}

	if (this->qrks & AZ_QRK_WID_TPDOCK3 &&
	    nid == 0x1c) {
		/* Thinkpad x220/t420 style dock headphone */
		w->d.pin.config = 0x212140ff;
		w->enable = 1;
	}

	if (this->qrks & AZ_QRK_WID_CDIN_1C &&
	    nid == 0x1c && w->enable == 0 && w->d.pin.device == CORB_CD_CD) {
		azalia_pin_config_ov(w, CORB_CD_PORT_MASK, CORB_CD_FIXED);
		w->widgetcap |= COP_AWCAP_STEREO;
		w->enable = 1;
	}

	if ((this->qrks & AZ_QRK_WID_AD1981_OAMP) &&
	    ((nid == 0x05) || (nid == 0x06) || (nid == 0x07) ||
	    (nid == 0x09) || (nid == 0x18))) {
		azalia_ampcap_ov(w, COP_OUTPUT_AMPCAP, 31, 33, 6, 30, 1);
	}

	return(0);
}
@


1.171
log
@Add an unmute quirk for IDT 92HD75B3/4 codecs with HP subids.
This is required to get speaker audio on the HP Elitebook 2540p.
Reported and fix tested by Mike Cond.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.170 2015/08/24 04:50:40 jsg Exp $	*/
d69 2
a70 1
		    this->subid == 0x72708086) {	/* APPLE_MBA4_1 */
@


1.170
log
@Audio on the T400/T410/T510/T420/T520/X220/X220t docks needs a quirk
for the pin configuration as well.

From Dmitry Alenichev.  ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.169 2015/08/21 06:11:04 jsg Exp $	*/
d231 3
@


1.169
log
@enable beep and CD controls on ALC292
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.168 2015/08/20 06:44:06 mlarkin Exp $	*/
d324 21
d2561 14
@


1.168
log
@
Enable audio on Thinkpad docks. Help from jsg@@ for the *40 / *50 series
docks.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.167 2015/08/04 21:21:38 tedu Exp $	*/
d128 1
@


1.167
log
@add Realtek ALC1150, from Alexandre H. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.166 2015/04/25 11:37:24 jturner Exp $	*/
d101 17
d128 25
d2511 28
@


1.166
log
@Add quirk for Cirrus Logic CS4208 which is needed for MacBookAir6,1.
ok deraadt@@ jung@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.165 2014/12/10 14:18:11 jsg Exp $	*/
d172 3
@


1.165
log
@Add an unmute quirk for HP machines with the IDT 92HD75B1/2 codec.
From Alessandro DE LAURENZIS, who requires this to get sound
out of the speakers on a Compaq 610 laptop.  Other machines such as
the HP Mini 1000 and HP Mini 5102 will likely benefit from this as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.164 2014/11/17 16:34:51 landry Exp $	*/
d72 7
@


1.164
log
@Add quirks for the "Realtek ALC885" found on MacMini3.1, unmutes the
internal speaker, line input and hp output. Tested on i386/amd64.

hints/help & ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.163 2014/07/13 23:10:23 deraadt Exp $	*/
d187 3
@


1.163
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.162 2014/07/12 18:48:51 tedu Exp $	*/
d152 1
d158 1
@


1.162
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.161 2014/07/08 17:19:25 deraadt Exp $	*/
d661 1
a661 1
	this->mixers = malloc(sizeof(mixer_item_t) * this->maxmixers,
d1255 2
a1256 1
	newbuf = malloc(sizeof(mixer_item_t) * newmax, M_DEVBUF, M_NOWAIT | M_ZERO);
@


1.161
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.160 2014/05/25 16:00:53 ratchov Exp $	*/
d1261 1
a1261 1
	free(this->mixers, M_DEVBUF);
d1487 1
a1487 1
		free(this->mixers, M_DEVBUF);
@


1.160
log
@fix format mistakes when AZALIA_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.159 2014/01/06 06:54:15 brad Exp $	*/
a36 1
#include <uvm/uvm_param.h>
@


1.159
log
@Recognize the ALC292
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.158 2014/01/02 04:23:35 jsg Exp $	*/
d1680 1
a1680 1
			DPRINTF(("%s: invalid muteset nid\n"));
d1703 1
a1703 1
			DPRINTF(("%s: invalid mixerset nid\n"));
d1720 1
a1720 1
			DPRINTF(("%s: invalid senseset nid\n"));
d1739 2
a1740 1
			DPRINTF(("%s: invalid outmaster mixer type\n"));
d1759 2
a1760 1
			DPRINTF(("%s: invalid inmaster mixer type\n"));
d2079 1
a2079 1
			DPRINTF(("%s: invalid muteset nid\n"));
d2137 1
a2137 1
			DPRINTF(("%s: invalid senseset nid\n"));
d2215 2
a2216 1
			DPRINTF(("%s: invalid output master mixer type\n"));
d2290 2
a2291 1
			DPRINTF(("%s: invalid input master mixer type\n"));
@


1.158
log
@enable beep controls on ALC221 and ALC269 as well
seems to be required when tested here
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.157 2014/01/02 03:05:20 jsg Exp $	*/
d102 3
@


1.157
log
@enable beep and CD controls on ALC282
from and tested by Mark Rowland
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.156 2013/11/09 05:53:20 jsg Exp $	*/
d77 1
d94 1
@


1.156
log
@recognise Realtek ALC221
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.155 2013/10/06 10:46:24 rapha Exp $	*/
d96 4
@


1.155
log
@Add quirk for ALC260 found on Acer Extensa 6700.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.154 2013/05/27 21:19:31 miod Exp $	*/
d74 3
@


1.154
log
@Fix edge cases of uninitialized variables. In my tree for too long, I even
got ok's for azalia but I don't remember from whom.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.153 2013/05/24 10:52:13 jsg Exp $	*/
d77 2
@


1.153
log
@MacBookAir4,1 needs the same unmute quirk as MacBookAir3,1
problem reported and fix tested by jcs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.152 2012/11/30 12:05:45 sthen Exp $	*/
d2302 1
d2329 1
@


1.152
log
@Fix speakers on Apple MacBook Air 2010, they require gpio unmuting.
From ray@@, adapted from a diff by jakemsr@@, commit req'd by Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.151 2010/09/10 15:11:23 jakemsr Exp $	*/
d69 2
a70 1
		if (this->subid == 0xcb8910de) {	/* APPLE_MBA3_1 */
@


1.151
log
@if the speaker is muted because headphones are plugged in, don't
unmute the speaker when the master volume control is unmuted
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.150 2010/08/23 15:48:24 jakemsr Exp $	*/
d67 7
d2413 3
@


1.150
log
@* if there's an error setting indirect more for a volume knob widget,
don't return the error back to the caller, but also don't turn on
unsolicited responses for the volume knob.  chances are, it isn't
acutally used.  lets sony viao tz play audio through suspend/resume
cycle.
* add some debug messages for other volume knob errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.149 2010/08/08 05:25:30 jakemsr Exp $	*/
d533 1
a533 1
		for (i = 0; err == 0 && i < this->nsense_pins; i++) {
d547 1
d2165 10
@


1.149
log
@convert printf()s that can happen in the resume path to DPRINTF()s.
silencing requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.148 2010/08/07 20:48:56 jakemsr Exp $	*/
d1424 2
a1425 1
		if (err)
d1427 1
d1437 10
a1446 2
		if (err)
			return err;
d1452 2
a1453 1
		if (err)
d1455 1
@


1.148
log
@restore unsolicited responses from volume knob widgets
tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.147 2010/06/27 21:47:07 jakemsr Exp $	*/
d1729 2
a1730 2
		printf("%s: internal error in %s: target=%x\n",
		    XNAME(this), __func__, target);
d2248 2
a2249 2
		printf("%s: internal error in %s: target=%x\n",
		    XNAME(this), __func__, target);
d2269 1
a2269 1
		printf("%s: unknown target: %d\n", __func__, target);
d2295 1
a2295 1
		printf("%s: unknown target: %d\n", __func__, target);
@


1.147
log
@don't probe "volume knobs" on resume.  probably not needed and
is currently breaking resume.
ok pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.146 2010/06/27 17:42:27 jakemsr Exp $	*/
d1393 1
a1393 1
	err = azalia_codec_enable_unsol(this, 0);
d1401 1
a1401 1
azalia_codec_enable_unsol(codec_t *this, int resuming)
d1419 1
a1419 1
	if (this->playvols.master != this->audiofunc && !resuming) {
@


1.146
log
@check if the jacks that will mute the speaker can generate unsolicited
events, instead of checking if the speaker can generate unsolicited
events
problem report and testing by Brad, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.145 2010/06/27 01:13:25 jakemsr Exp $	*/
d1393 1
a1393 1
	err = azalia_codec_enable_unsol(this);
d1401 1
a1401 1
azalia_codec_enable_unsol(codec_t *this)
d1419 1
a1419 1
	if (this->playvols.master != this->audiofunc) {
@


1.145
log
@GPIO quirk for IDT 92HD71B7 in HP laptops (such as HP HDX 18)
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.144 2010/06/26 21:06:52 jakemsr Exp $	*/
d1046 1
a1046 1
			if (!(w->d.pin.cap & COP_PINCAP_OUTPUT))
d1048 1
a1048 1
			if (!(w->widgetcap & COP_AWCAP_UNSOL))
@


1.144
log
@make sure widgets are connected to usable widgets by default.
for example: outputs.sel7_source= -> outputs.sel7_source=adc-0:1
on the HP HDX 18
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.143 2010/03/21 15:04:35 jakemsr Exp $	*/
d182 2
a183 1
		if ((this->subid & 0x0000ffff) == 0x00001028) {	/* DELL */
@


1.143
log
@another macbook that needs reference voltage for output.
problem reported and fix tested by Ted Roby.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.142 2010/03/21 15:02:31 jakemsr Exp $	*/
d1330 20
@


1.142
log
@deal with the possibility of two internal speaker pins, like on
macbooks that have a "normal" pair of stereo speakers as well
as subwoofer(s).  problem reported and fix tested by Ted Roby.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.141 2010/02/11 21:33:39 jakemsr Exp $	*/
d135 2
a136 1
		if (this->subid == 0x00a0106b)
@


1.141
log
@"unmute" GPIO 0 on all Dell machines with IDT 92HD71B7 codecs.
desilences E4300 for drahn@@.  ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.140 2010/02/01 05:43:21 jakemsr Exp $	*/
d550 5
d560 5
d776 2
a777 1
		    w->nid != this->speaker) {
d804 2
a805 1
					if (w->connections[j] == this->speaker)
d822 2
a823 1
		    w->nid != this->speaker) {
d845 2
a846 1
					if (w->connections[j] == this->speaker)
d885 2
a886 1
				if (w->connections[j] == this->speaker)
@


1.140
log
@unmute GPIO 0 on IDT 92HD73C1 codecs found in Dell machines
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.139 2009/11/03 17:31:30 jakemsr Exp $	*/
d181 1
a181 4
		if (this->subid == 0x02631028 ||	/* DELL_E5500 */
                   this->subid == 0x02501028 ||	/* DELL_M4400 */
		    this->subid == 0x02331028 ||	/* DELL_E6400 */
		    this->subid == 0x024f1028) {	/* DELL_E6500 */
@


1.139
log
@gpio quirk for Dell Precision M4400.  from Geoff Sanders.  thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.138 2009/10/20 06:01:36 kevlo Exp $	*/
d169 3
@


1.138
log
@recognize the VIA VT1702 codec

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.137 2009/09/12 09:34:43 jakemsr Exp $	*/
d179 1
@


1.137
log
@GPIO quirk for Dell Inspiron 1400
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.136 2009/09/09 02:22:21 jakemsr Exp $	*/
d141 10
@


1.136
log
@move code to enable widget unsolicited event generation into it's
own function
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.135 2009/09/09 02:13:35 jakemsr Exp $	*/
d249 2
a250 1
		if (this->subid == 0x02271028) {	/* DELL_V1400 */
@


1.135
log
@handle mixer get/set requests for class type mixer items in the underlying
mixer get/set routines instead of in the MI audio routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.134 2009/09/09 02:06:04 jakemsr Exp $	*/
a1244 1
	uint32_t result;
a1305 11
	/* turn on jack sense unsolicited responses */
	for (i = 0; i < this->nsense_pins; i++) {
		if (this->spkr_muters & (1 << i)) {
			azalia_comresp(this, this->sense_pins[i],
			    CORB_SET_UNSOLICITED_RESPONSE,
			    CORB_UNSOL_ENABLE | AZ_TAG_SPKR, NULL);
		}
	}
	if (this->spkr_muters != 0)
		azalia_unsol_event(this, AZ_TAG_SPKR);

d1343 25
@


1.134
log
@make sure node id for stream mode mixer items is valid
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.133 2009/06/26 01:48:22 jakemsr Exp $	*/
d1408 4
d1413 1
a1413 1
	if (IS_MI_TARGET_INAMP(target) && mc->type == AUDIO_MIXER_ENUM) {
d1680 4
d1685 1
a1685 1
	if (IS_MI_TARGET_INAMP(target) && mc->type == AUDIO_MIXER_ENUM) {
@


1.133
log
@the 'inputs.usingdac' mixer item was used to select which group of
DACs to use.  for several months, there have been at most two
groups, the first being all usable analog DACs and the second being
all usable digital DACs.  so 'inputs.usingdac' essentially was used
to switch between analog and digital modes.  this was entirely
unclear to most users because the DACs were listed by their NIDs,
which means nothing unless you know how azalia(4) internals works.

rename 'inputs.usingdac' to 'outputs.mode', and replace the lists of
DAC NIDs with 'analog' and 'digital'.  similarly for recording,
change 'record.usingadc' to 'record.mode', and replace the lists of
ADC NIDs with 'analog' and 'digital'.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.132 2009/06/09 05:16:42 jakemsr Exp $	*/
d1146 1
d1166 1
@


1.132
log
@AD1981HD output amps are weird.  they report 63 volume steps but the
first 30 do nothing.  perhaps there are other codecs with such
amps?  (ab)use some reserved bits in the amplifier capabilities
parameter to store the first volume step that actually changes the
volume.  problem reported and patch tested by LEVAI Daniel.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.131 2009/06/09 05:05:48 jakemsr Exp $	*/
d1137 3
a1139 1
	/* if the codec has multiple DAC groups, create "inputs.usingdac" */
d1142 1
a1142 1
		strlcpy(d->label.name, "usingdac", sizeof(d->label.name));
d1144 1
a1144 1
		d->mixer_class = AZ_CLASS_INPUT;
d1146 7
a1152 11
		for (i = 0; i < this->dacs.ngroups && i < 32; i++) {
			d->un.e.member[i].ord = i;
			for (j = 0; j < this->dacs.groups[i].nconv; j++) {
				if (j * 2 >= MAX_AUDIO_DEV_LEN)
					break;
				snprintf(d->un.e.member[i].label.name + j*2,
				    MAX_AUDIO_DEV_LEN - j*2, "%2.2x",
				    this->dacs.groups[i].conv[j]);
			}
		}
		d->un.e.num_mem = i;
d1156 3
a1158 1
	/* if the codec has multiple ADC groups, create "record.usingadc" */
d1161 1
a1161 1
		strlcpy(d->label.name, "usingadc", sizeof(d->label.name));
d1165 7
a1171 11
		for (i = 0; i < this->adcs.ngroups && i < 32; i++) {
			d->un.e.member[i].ord = i;
			for (j = 0; j < this->adcs.groups[i].nconv; j++) {
				if (j * 2 >= MAX_AUDIO_DEV_LEN)
					break;
				snprintf(d->un.e.member[i].label.name + j*2,
				    MAX_AUDIO_DEV_LEN - j*2, "%2.2x",
				    this->adcs.groups[i].conv[j]);
			}
		}
		d->un.e.num_mem = i;
@


1.131
log
@quirks for MacBookPro3,1 inspired by FreeBSD's snd_hda.  problem
reported and patch tested by Bryan Chapman.  according to FreeBSD,
this might be needed for other MacBookPro models but no one else has
told me their MacBookPro doesn't work.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.130 2009/05/31 03:22:05 jakemsr Exp $	*/
d49 2
a50 4
u_char	azalia_mixer_from_device_value
	(const codec_t *, nid_t, int, uint32_t );
uint32_t azalia_mixer_to_device_value
	(const codec_t *, nid_t, int, u_char);
d54 1
d200 1
d1673 1
a1673 2
azalia_mixer_set(codec_t *this, nid_t nid, int target,
    const mixer_ctrl_t *mc)
d1680 1
a1680 1
		/* We have to set stereo mute separately to keep each gain value. */
d2191 2
a2192 1
	uint32_t dmax;
d2194 17
a2210 13
	if (IS_MI_TARGET_INAMP(target))
		dmax = COP_AMPCAP_NUMSTEPS(this->w[nid].inamp_cap);
	else if (target == MI_TARGET_OUTAMP)
		dmax = COP_AMPCAP_NUMSTEPS(this->w[nid].outamp_cap);
	else {
		printf("unknown target: %d\n", target);
		dmax = 255;
	}
	if (dv <= 0 || dmax == 0)
		return AUDIO_MIN_GAIN;
	if (dv >= dmax)
		return AUDIO_MAX_GAIN - AUDIO_MAX_GAIN % dmax;
	return dv * (AUDIO_MAX_GAIN - AUDIO_MAX_GAIN % dmax) / dmax;
d2217 2
a2218 1
	uint32_t dmax;
d2220 16
a2235 13
	if (IS_MI_TARGET_INAMP(target))
		dmax = COP_AMPCAP_NUMSTEPS(this->w[nid].inamp_cap);
	else if (target == MI_TARGET_OUTAMP)
		dmax = COP_AMPCAP_NUMSTEPS(this->w[nid].outamp_cap);
	else {
		printf("unknown target: %d\n", target);
		dmax = 255;
	}
	if (uv <= AUDIO_MIN_GAIN || dmax == 0)
		return 0;
	if (uv >= AUDIO_MAX_GAIN - AUDIO_MAX_GAIN % dmax)
		return dmax;
	return uv * dmax / (AUDIO_MAX_GAIN - AUDIO_MAX_GAIN % dmax);
d2260 17
d2340 6
@


1.130
log
@zap _generic from the names of several functions.  there are no
more non-generic versions, and there never will be again.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.129 2009/05/31 02:57:51 jakemsr Exp $	*/
d132 1
d136 2
d1849 2
@


1.129
log
@- all codecs now use the same functions, always.  call the functions
directly instead of through pointers in the codec_t.
- fold azalia_generic_{g,s}et_port into azalia_{g,s}et_port since both
are small and partly duplicated eachother.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.128 2009/05/31 02:12:54 jakemsr Exp $	*/
d43 1
a43 1
int	azalia_generic_codec_add_convgroup(codec_t *, convgroupset_t *,
d46 4
a49 4
int	azalia_generic_mixer_fix_indexes(codec_t *);
int	azalia_generic_mixer_default(codec_t *);
int	azalia_generic_mixer_ensure_capacity(codec_t *, size_t);
u_char	azalia_generic_mixer_from_device_value
d51 1
a51 1
uint32_t azalia_generic_mixer_to_device_value
d358 1
a358 1
		azalia_generic_codec_add_convgroup(this, &this->dacs,
d363 1
a363 1
		azalia_generic_codec_add_convgroup(this, &this->dacs,
d371 1
a371 1
		azalia_generic_codec_add_convgroup(this, &this->adcs,
d376 1
a376 1
		azalia_generic_codec_add_convgroup(this, &this->adcs,
d386 1
a386 1
azalia_generic_codec_add_convgroup(codec_t *this, convgroupset_t *group,
d533 1
a533 1
			err = azalia_generic_mixer_set(this, this->speaker,
d538 1
a538 1
			err = azalia_generic_mixer_set(this, this->speaker,
d543 1
a543 1
			err = azalia_generic_mixer_set(this, this->spkr_dac,
d579 1
a579 1
		err = azalia_generic_mixer_set(this, this->playvols.master,
d654 1
a654 1
	err = azalia_generic_mixer_ensure_capacity(this, this->nmixers + 1); \
d1031 1
a1031 1
		err = azalia_generic_mixer_ensure_capacity(this,
d1084 1
a1084 1
		err = azalia_generic_mixer_ensure_capacity(this,
d1176 2
a1177 2
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);
d1193 1
a1193 1
azalia_generic_mixer_ensure_capacity(codec_t *this, size_t newsize)
d1216 1
a1216 1
azalia_generic_mixer_fix_indexes(codec_t *this)
d1238 1
a1238 1
azalia_generic_mixer_default(codec_t *this)
d1257 1
a1257 1
		azalia_generic_mixer_set(this, m->nid, m->target, &mc);
d1277 1
a1277 1
		azalia_generic_mixer_set(this, m->nid, m->target, &mc);
d1303 1
a1303 1
		azalia_generic_mixer_set(this, m->nid, m->target, &mc);
d1326 1
a1326 1
		azalia_generic_mixer_get(this, w->nid, tgt, &mc);
d1348 1
a1348 1
		azalia_generic_mixer_get(this, w->nid, tgt, &mc);
d1400 1
a1400 1
azalia_generic_mixer_get(const codec_t *this, nid_t nid, int target,
d1424 1
a1424 1
		mc->un.value.level[0] = azalia_generic_mixer_from_device_value(this,
d1444 1
a1444 1
			mc->un.value.level[1] = azalia_generic_mixer_from_device_value
d1464 1
a1464 1
		mc->un.value.level[0] = azalia_generic_mixer_from_device_value(this,
d1473 1
a1473 1
			mc->un.value.level[1] = azalia_generic_mixer_from_device_value
d1670 1
a1670 1
azalia_generic_mixer_set(codec_t *this, nid_t nid, int target,
d1721 1
a1721 1
		value = azalia_generic_mixer_to_device_value(this, nid, target,
d1739 1
a1739 1
			value = azalia_generic_mixer_to_device_value(this, nid, target,
d1790 1
a1790 1
		value = azalia_generic_mixer_to_device_value(this, nid, target,
d1806 1
a1806 1
			value = azalia_generic_mixer_to_device_value(this, nid, target,
d2053 1
a2053 1
					azalia_generic_mixer_get(this, w->nid,
d2062 1
a2062 1
				err = azalia_generic_mixer_set(this, w->nid,
d2082 1
a2082 1
				err = azalia_generic_mixer_set(this, w->nid,
d2130 1
a2130 1
				err = azalia_generic_mixer_set(this, w->nid,
d2157 1
a2157 1
				err = azalia_generic_mixer_set(this, w->nid,
d2184 1
a2184 1
azalia_generic_mixer_from_device_value(const codec_t *this, nid_t nid, int target,
d2205 1
a2205 1
azalia_generic_mixer_to_device_value(const codec_t *this, nid_t nid, int target,
@


1.128
log
@remove special handling for STAC9225 (aka STAC7661).  it was just
choosing the default recording source and muting ADC input after
the device has been configured.  the commit message that added
these doesn't give a reason why this is done, and it is
inconsistent with every other codec.  if you really want these
settings, either set them in mixerctl.conf, or convince me why
this should be done for all codecs.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.127 2009/05/29 21:16:37 jakemsr Exp $	*/
a42 1
int	azalia_generic_codec_init_dacgroup(codec_t *);
a45 3
int	azalia_generic_unsol(codec_t *, int);

int	azalia_generic_mixer_init(codec_t *);
a47 1
int	azalia_generic_mixer_delete(codec_t *);
a48 2
int	azalia_generic_mixer_get(const codec_t *, nid_t, int, mixer_ctrl_t *);
int	azalia_generic_mixer_set(codec_t *, nid_t, int, const mixer_ctrl_t *);
a52 2
int	azalia_generic_set_port(codec_t *, mixer_ctrl_t *);
int	azalia_generic_get_port(codec_t *, mixer_ctrl_t *);
a65 6
	this->init_dacgroup = azalia_generic_codec_init_dacgroup;
	this->mixer_init = azalia_generic_mixer_init;
	this->mixer_delete = azalia_generic_mixer_delete;
	this->set_port = azalia_generic_set_port;
	this->get_port = azalia_generic_get_port;
	this->unsol_event = azalia_generic_unsol;
d354 1
a354 1
azalia_generic_codec_init_dacgroup(codec_t *this)
d504 1
a504 1
azalia_generic_unsol(codec_t *this, int tag)
d519 1
a519 1
			err = this->comresp(this, this->sense_pins[i],
d523 1
a523 1
			err = this->comresp(this, this->sense_pins[i],
d552 1
a552 1
		err = this->comresp(this, this->playvols.master,
d597 1
a597 1
azalia_generic_mixer_init(codec_t *this)
d1309 1
a1309 1
			this->comresp(this, this->sense_pins[i],
d1314 2
a1315 2
	if (this->spkr_muters != 0 && this->unsol_event != NULL)
		this->unsol_event(this, AZ_TAG_SPKR);
d1359 1
a1359 1
		err = this->comresp(this, w->nid, CORB_GET_VOLUME_KNOB,
d1370 1
a1370 1
		err = this->comresp(this, w->nid, CORB_SET_VOLUME_KNOB,
d1377 1
a1377 1
		err = this->comresp(this, w->nid,
d1387 1
a1387 1
azalia_generic_mixer_delete(codec_t *this)
d1409 1
a1409 1
		err = this->comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
d1419 1
a1419 1
		err = this->comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
d1438 1
a1438 1
			err = this->comresp(this, nid,
d1451 1
a1451 1
		err = this->comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
d1460 1
a1460 1
		err = this->comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
d1468 1
a1468 1
			err = this->comresp(this, nid,
d1480 1
a1480 1
		err = this->comresp(this, nid,
d1494 1
a1494 1
		err = this->comresp(this, nid,
d1522 1
a1522 1
		err = this->comresp(this, nid,
d1541 1
a1541 1
		err = this->comresp(this, nid, CORB_GET_DIGITAL_CONTROL,
d1547 1
a1547 1
		err = this->comresp(this, nid, CORB_GET_DIGITAL_CONTROL,
d1557 2
a1558 2
		err = this->comresp(this, nid,
		    CORB_GET_EAPD_BTL_ENABLE, 0, &result);
d1566 1
a1566 1
		err = this->comresp(this, nid, CORB_GET_PIN_SENSE,
d1586 1
a1586 1
			err = this->comresp(this, nid,
d1679 1
a1679 1
		err = this->comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
d1689 1
a1689 1
		err = this->comresp(this, nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
d1694 1
a1694 1
			err = this->comresp(this, nid,
d1705 1
a1705 1
			err = this->comresp(this, nid,
d1716 1
a1716 1
		err = this->comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
d1727 1
a1727 1
		err = this->comresp(this, nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
d1733 1
a1733 1
			err = this->comresp(this, nid,
d1745 1
a1745 1
			err = this->comresp(this, nid,
d1754 1
a1754 1
		err = this->comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
d1761 1
a1761 1
		err = this->comresp(this, nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
d1766 1
a1766 1
			err = this->comresp(this, nid,
d1775 1
a1775 1
			err = this->comresp(this, nid,
d1786 1
a1786 1
		err = this->comresp(this, nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
d1795 1
a1795 1
		err = this->comresp(this, nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
d1801 1
a1801 1
			err = this->comresp(this, nid,
d1811 1
a1811 1
			err = this->comresp(this, nid,
d1825 1
a1825 1
		err = this->comresp(this, nid,
d1834 1
a1834 1
		err = this->comresp(this, nid,
d1859 1
a1859 1
		err = this->comresp(this, nid,
d1872 1
a1872 2
			if (this->unsol_event != NULL)
				this->unsol_event(this, AZ_TAG_SPKR);
d1880 1
a1880 1
		err = this->comresp(this, nid,
d1889 1
a1889 1
		err = this->comresp(this, nid,
d1923 1
a1923 1
		err = this->comresp(this, nid, CORB_GET_DIGITAL_CONTROL,
d1927 1
a1927 1
		err = this->comresp(this, nid, CORB_SET_DIGITAL_CONTROL_L,
d1936 1
a1936 1
		err = this->comresp(this, nid, CORB_SET_DIGITAL_CONTROL_H,
d1946 1
a1946 1
		err = this->comresp(this, nid,
d1956 1
a1956 1
		err = this->comresp(this, nid,
d1981 1
a1981 1
			err = this->comresp(this, nid,
d1992 1
a1992 1
			err = this->comresp(this, nid,
d1998 1
a1998 1
				err = this->comresp(this, nid,
d2009 1
a2009 1
				err = this->comresp(this, nid,
d2026 1
a2026 2
			if (this->unsol_event != NULL)
				this->unsol_event(this, AZ_TAG_SPKR);
a2225 29
azalia_generic_set_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	if (mc->type != m->devinfo.type)
		return EINVAL;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;	/* nothing to do */
	return azalia_generic_mixer_set(this, m->nid, m->target, mc);
}

int
azalia_generic_get_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	mc->type = m->devinfo.type;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;	/* nothing to do */
	return azalia_generic_mixer_get(this, m->nid, m->target, mc);
}

int
d2230 3
a2232 3
	this->comresp(this, this->audiofunc, CORB_GET_GPIO_DATA, 0, &data);
	this->comresp(this, this->audiofunc, CORB_GET_GPIO_ENABLE_MASK, 0, &mask);
	this->comresp(this, this->audiofunc, CORB_GET_GPIO_DIRECTION, 0, &dir);
d2238 2
a2239 2
	this->comresp(this, this->audiofunc, CORB_SET_GPIO_ENABLE_MASK, mask, NULL);
	this->comresp(this, this->audiofunc, CORB_SET_GPIO_DIRECTION, dir, NULL);
d2241 1
a2241 1
	this->comresp(this, this->audiofunc, CORB_SET_GPIO_DATA, data, NULL);
d2274 1
a2274 1
		this->comresp(this, this->audiofunc,
@


1.127
log
@register all GPIO and widget "quirks" in a bitmask instead of using
macros and codec->init_widget.  now there is only only place to look
to see what special handling a specific codec will get.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.126 2009/05/29 05:04:45 jakemsr Exp $	*/
a66 1
int	azalia_stac7661_mixer_init(codec_t *);
a310 1
		this->mixer_init = azalia_stac7661_mixer_init;
a2358 23
}

/* ----------------------------------------------------------------
 * codec specific functions
 * ---------------------------------------------------------------- */

/* Sigmatel STAC9225 */
int
azalia_stac7661_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;

	azalia_generic_mixer_init(this);

	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 1;
	/* mute ADC input (why?) */
	azalia_generic_mixer_set(this, 0x09, MI_TARGET_INAMP(0), &mc);
	/* select internal mic for recording */
	mc.un.ord = 2;
	azalia_generic_mixer_set(this, 0x15, MI_TARGET_CONNLIST, &mc);
	return 0;
@


1.126
log
@if a control in outputs.master.slaves is muted, don't change it's
volume when outputs.master is changed
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.125 2009/05/25 05:51:19 robert Exp $	*/
a42 26
#define REALTEK_ALC660		0x10ec0660
#define ALC660_ASUS_G2K		0x13391043
#define REALTEK_ALC880		0x10ec0880
#define ALC880_ASUS_M5200	0x19931043
#define ALC880_ASUS_A7M		0x13231043
#define ALC880_MEDION_MD95257	0x203d161f
#define REALTEK_ALC882		0x10ec0882
#define ALC882_ASUS_A7T		0x13c21043
#define ALC882_ASUS_W2J		0x19711043
#define REALTEK_ALC883		0x10ec0883
#define ALC883_ACER_ID		0x00981025
#define REALTEK_ALC885		0x10ec0885
#define ALC885_APPLE_MB3	0x00a1106b
#define ALC885_APPLE_MB4	0x00a3106b
#define SIGMATEL_STAC9221	0x83847680
#define STAC9221_APPLE_ID	0x76808384
#define SIGMATEL_STAC9205	0x838476a0
#define STAC9205_DELL_D630	0x01f91028
#define STAC9205_DELL_V1500	0x02281028
#define IDT_92HD71B7		0x111d76b2
#define IDT92HD71B7_DELL_E5500	0x02631028
#define IDT92HD71B7_DELL_E6400	0x02331028
#define IDT92HD71B7_DELL_E6500	0x024f1028
#define SIGMATEL_STAC9228X	0x83847616
#define STAC9228X_DELL_V1400	0x02271028

a66 1
int	azalia_alc88x_init_widget(const codec_t *, widget_t *, nid_t);
d82 1
d89 1
a89 1
		this->init_widget = azalia_alc88x_init_widget;
d93 1
a93 1
		this->init_widget = azalia_alc88x_init_widget;
d101 6
d109 1
a109 1
		this->init_widget = azalia_alc88x_init_widget;
d119 8
a126 1
		this->init_widget = azalia_alc88x_init_widget;
d130 5
a134 1
		this->init_widget = azalia_alc88x_init_widget;
d138 5
a142 1
		this->init_widget = azalia_alc88x_init_widget;
d146 5
a150 1
		this->init_widget = azalia_alc88x_init_widget;
d154 1
a154 1
		this->init_widget = azalia_alc88x_init_widget;
d182 5
d262 3
d316 4
d340 4
d2321 3
a2323 4
	if (this->vid == SIGMATEL_STAC9221 && this->subid == STAC9221_APPLE_ID) {
		this->comresp(this, this->audiofunc, CORB_SET_GPIO_POLARITY, 0, NULL);
		azalia_gpio_unmute(this, 0);
		azalia_gpio_unmute(this, 1);
d2325 1
a2325 1
	if (this->vid == REALTEK_ALC883 && this->subid == ALC883_ACER_ID) {
a2326 1
		azalia_gpio_unmute(this, 1);
d2328 1
a2328 15
	if ((this->vid == REALTEK_ALC660 && this->subid == ALC660_ASUS_G2K) ||
	    (this->vid == REALTEK_ALC880 && this->subid == ALC880_ASUS_M5200) ||
	    (this->vid == REALTEK_ALC880 && this->subid == ALC880_ASUS_A7M) ||
	    (this->vid == REALTEK_ALC882 && this->subid == ALC882_ASUS_A7T) ||
	    (this->vid == REALTEK_ALC882 && this->subid == ALC882_ASUS_W2J) ||
	    (this->vid == REALTEK_ALC885 && this->subid == ALC885_APPLE_MB3) ||
	    (this->vid == REALTEK_ALC885 && this->subid == ALC885_APPLE_MB4) ||
	    (this->vid == IDT_92HD71B7 && this->subid == IDT92HD71B7_DELL_E5500) ||
	    (this->vid == IDT_92HD71B7 && this->subid == IDT92HD71B7_DELL_E6400) ||
	    (this->vid == IDT_92HD71B7 && this->subid == IDT92HD71B7_DELL_E6500) ||
	    (this->vid == SIGMATEL_STAC9205 && this->subid == STAC9205_DELL_D630) ||
	    (this->vid == SIGMATEL_STAC9205 && this->subid == STAC9205_DELL_V1500)) {
		azalia_gpio_unmute(this, 0);
	}
	if (this->vid == REALTEK_ALC880 && this->subid == ALC880_MEDION_MD95257) {
d2331 1
a2331 1
	if (this->vid == SIGMATEL_STAC9228X && this->subid == STAC9228X_DELL_V1400) {
d2333 3
a2335 2
 	}
	return 0;
a2337 5
/* ----------------------------------------------------------------
 * codec specific functions
 * ---------------------------------------------------------------- */

/* Realtek ALC88x */
d2339 1
a2339 1
azalia_alc88x_init_widget(const codec_t *this, widget_t *w, nid_t nid)
d2341 7
a2347 1
	if (nid == 0x1c && w->enable == 0 && w->d.pin.device == CORB_CD_CD) {
d2352 3
a2354 2
	if (nid == 0x1d && w->enable == 0) {
		azalia_pin_config_ov(w, CORB_CD_DEVICE_MASK, CORB_CD_BEEP);
d2359 2
a2360 1
 	return 0;
d2362 4
@


1.125
log
@Add Dell Latitude E5500 to the mute quirk list.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.124 2009/05/17 02:28:26 jakemsr Exp $	*/
d2053 9
@


1.124
log
@recognize more Analog Devices codecs
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.123 2009/05/12 09:32:28 jakemsr Exp $	*/
d63 1
d2313 1
@


1.123
log
@- try to identify a "main input mixer"
- don't unmute input from a built-in mic on the main input mixer
intended to stop possible feedback loops between buit-in speakers
and built-in mics.  built-in mics also tend to capture machine
noise, especially fans.  actual recording should not be affected.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.122 2009/05/01 03:45:17 jakemsr Exp $	*/
d192 9
d221 9
@


1.122
log
@recognize several more IDT/Sigmatel codecs.  IDs taken from the codecs'
datasheets.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.121 2009/05/01 02:55:16 jakemsr Exp $	*/
d1280 3
@


1.121
log
@allow jack sensing to mute the DAC the speaker is connected to by
default, as long is the first output pin is not also connected to
that DAC.  cleanup a bit now that there are multiple muting methods.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.120 2009/04/27 23:49:04 jakemsr Exp $	*/
d156 24
d186 6
d225 12
d246 3
d270 12
d289 1
a289 1
		this->name = "Sigmatel STAC9221";
d291 2
d294 1
a294 1
		this->name = "Sigmatel STAC9221D";
d297 1
a297 1
		this->name = "Sigmatel STAC9200";
d301 6
@


1.120
log
@it's easier to have the speaker dac in the converter group than
to special case the speaker dac ...
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.119 2009/04/25 05:02:40 jakemsr Exp $	*/
d448 2
a449 2
		if ((this->w[this->speaker].widgetcap & COP_AWCAP_OUTAMP) &&
		    (this->w[this->speaker].outamp_cap & COP_AMPCAP_MUTE)) {
d453 2
a454 1
		} else {
d458 6
d903 19
a921 6
	w = &this->w[this->speaker];
	if (this->nsense_pins > 0 && this->speaker != -1 &&
	    (((w->widgetcap & COP_AWCAP_OUTAMP) &&
	    (w->outamp_cap & COP_AMPCAP_MUTE)) ||
	    ((w->d.pin.cap & COP_PINCAP_OUTPUT) &&
	    (w->d.pin.cap & COP_PINCAP_INPUT)))) {
@


1.119
log
@beep generators are input endpoints.  but ther are not supposed
to be listed in other widgets' connection lists.  if a beep
generator is found in another widget's connection list, treat it
as a dead end.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.118 2009/04/24 16:30:58 jakemsr Exp $	*/
d360 11
d379 1
a379 3
	/* Disable converters that aren't in a convgroup and aren't the
	 * speaker dac.
	 */
a381 2
		if (this->spkr_dac == conv)
			continue;
@


1.118
log
@remove no longer needed workaround
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.117 2009/04/24 16:27:38 jakemsr Exp $	*/
d398 1
@


1.117
log
@the internal/fixed speaker is special.  the dac it connects to
by default might not be in a converter group.  make sure such a
dac is not disabled and gets a meaningful name.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.116 2009/04/24 16:18:23 jakemsr Exp $	*/
a92 1
int	azalia_stac9221_init_widget(const codec_t *, widget_t *, nid_t);
a232 1
		this->init_widget = azalia_stac9221_init_widget;
a2232 24
}

/* Sigmatel STAC9221 */
int
azalia_stac9221_init_widget(const codec_t *codec, widget_t *w, nid_t nid)
{
	/* Apple didn't follow the HDA spec for associations */
	if (codec->subid == STAC9221_APPLE_ID) {
		if (nid == 0xa &&
		    (w->d.pin.color == CORB_CD_WHITE ||
		    w->d.pin.color == CORB_CD_GREEN)) {
			w->d.pin.association = 1;
			w->d.pin.sequence = 0;
		}
		if (nid == 0xc && w->d.pin.device == CORB_CD_SPEAKER) {
			w->d.pin.association = 1;
			w->d.pin.sequence = 1;
		}
		if (nid == 0xf && w->d.pin.color == CORB_CD_BLUE) {
			w->d.pin.association = 2;
			w->d.pin.sequence = 0;
		}
	}
	return 0;
@


1.116
log
@use the direction/association/sequence ordered lists of i/o pins to
create the converter group lists.  start with converters that are
connected to pins by default, then add converters that can be
connected to pins.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.115 2009/04/24 16:05:06 jakemsr Exp $	*/
d370 3
d374 3
d378 1
a378 1
			if (convs[j] == all_convs[i])
d381 1
a381 1
			this->w[all_convs[i]].enable = 0;
@


1.115
log
@drop _generic from azalia_generic_codec_fnode().  there will not
be a non-generic version.  move the prototype to azalia.h so it
can also be used in azalia.c in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.114 2009/01/24 09:44:02 jakemsr Exp $	*/
d70 1
a70 1
    uint32_t, uint32_t);
d277 10
a286 4
	azalia_generic_codec_add_convgroup(this, &this->dacs,
	    COP_AWTYPE_AUDIO_OUTPUT, 0);
	azalia_generic_codec_add_convgroup(this, &this->dacs,
	    COP_AWTYPE_AUDIO_OUTPUT, COP_AWCAP_DIGITAL);
d290 10
a299 4
	azalia_generic_codec_add_convgroup(this, &this->adcs,
	    COP_AWTYPE_AUDIO_INPUT, 0);
	azalia_generic_codec_add_convgroup(this, &this->adcs,
	    COP_AWTYPE_AUDIO_INPUT, COP_AWCAP_DIGITAL);
d307 1
a309 2
	nid_t all_convs[HDA_MAX_CHANNELS];
	int nall_convs;
a311 1
	int assoc, seq;
a314 4
	DPRINTF(("%s: looking for %s %s\n", __func__,
	    digital ? "digital" : "analog",
	    (type == COP_AWTYPE_AUDIO_OUTPUT) ? "DACs" : "ADCs"));

a315 1
	nall_convs = 0;
d317 15
a331 5
	FOR_EACH_WIDGET(this, i) {
		if (this->w[i].type == type &&
		    (this->w[i].widgetcap & COP_AWCAP_DIGITAL) == digital &&
		    nall_convs < HDA_MAX_CHANNELS)
			all_convs[nall_convs++] = this->w[i].nid;
d333 14
a346 10
	if (nall_convs == 0)
		goto done;

	for (assoc = 0; assoc <= CORB_CD_ASSOCIATION_MAX; assoc++) {
		for (seq = 0; seq <= CORB_CD_SEQUENCE_MAX; seq++) {
			FOR_EACH_WIDGET(this, i) {
				const widget_t *w;

				w = &this->w[i];
				if (!w->enable)
d348 2
a349 1
				if (w->type != COP_AWTYPE_PIN_COMPLEX)
d351 3
a353 2
				if ((w->widgetcap &
				    COP_AWCAP_DIGITAL) != digital)
d355 4
a358 49
				if (w->d.pin.sequence != seq ||
				    w->d.pin.association != assoc)
					continue;
				if (type == COP_AWTYPE_AUDIO_OUTPUT) {
					if (!(w->d.pin.cap & COP_PINCAP_OUTPUT))
						continue;
					if (this->mic != -1 &&
					    w->nid == this->mic)
						continue;
				} else {
					if (!(w->d.pin.cap & COP_PINCAP_INPUT))
						continue;
					if (this->speaker != -1 &&
					    w->nid == this->speaker)
						continue;
				}
				DPRINTF(("\tpin=%2.2x, assoc=%d, seq=%d:",
				    w->nid, assoc, seq));
				for (j = 0; j < nall_convs; j++) {
					conv = all_convs[j];
					for (k = 0; k < nconvs; k++) {
						if (convs[k] == conv)
							break;
					}
					if (k < nconvs)
						continue;
					if (type == COP_AWTYPE_AUDIO_OUTPUT) {
						k = azalia_codec_fnode
						    (this, conv, i, 0);
						if (k < 0)
							continue;
					} else {
						if (!azalia_widget_enabled(this,
						    conv))
							continue;
						k = azalia_codec_fnode
						    (this, w->nid, conv, 0);
						if (k < 0)
							continue;
					}
					convs[nconvs++] = conv;
					DPRINTF(("%2.2x", conv));
					if (nconvs >= nall_convs ||
					    nconvs >= HDA_MAX_CHANNELS) {
						DPRINTF(("\n"));
						goto done;
					}
				}
				DPRINTF(("\n"));
a388 1
		DPRINTF((" depth=%d:", depth));
d402 1
a402 2
		ret = azalia_codec_fnode(this, node,
		    w->connections[i], depth);
@


1.114
log
@fix a couple mistakes from rev 1.109
dmesg spam produced by the mistakes noticed by stsp@@, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.113 2009/01/07 07:19:39 marco Exp $	*/
a68 1
int	azalia_generic_codec_fnode(codec_t *, nid_t, int, int);
d361 1
a361 1
						k = azalia_generic_codec_fnode
d369 1
a369 1
						k = azalia_generic_codec_fnode
d406 1
a406 1
azalia_generic_codec_fnode(codec_t *this, nid_t node, int index, int depth)
d427 1
a427 1
		ret = azalia_generic_codec_fnode(this, node,
@


1.113
log
@Add Dell Latitude E6500 to mute quirk.  This makes my shiny E6500 play some
nice mp3s.

From brad, ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.112 2009/01/05 09:50:37 jakemsr Exp $	*/
d1196 1
a1196 2
		if (m->target != MI_TARGET_MUTESET &&
		    m->target != MI_TARGET_MIXERSET)
d1929 1
a1929 1
	else if (target == MI_TARGET_MUTESET && mc->type == AUDIO_MIXER_SET) {
@


1.112
log
@allow sense capable pins to mute the speaker by disabling the output
channel of the speaker.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.111 2009/01/05 09:46:26 jakemsr Exp $	*/
d64 1
d2223 1
@


1.111
log
@expand the _dir controls for output pins to also be able to select
VRef level and be sure to turn VRef off when not set for input.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.110 2009/01/05 08:06:55 jakemsr Exp $	*/
d442 1
d447 2
a448 2
		mc.un.ord = 0;
		for (i = 0; mc.un.ord == 0 && i < this->nsense_pins; i++) {
d458 13
a470 1
				mc.un.ord = 1;
a471 2
		azalia_generic_mixer_set(this, this->speaker,
		    MI_TARGET_OUTAMP, &mc);
d504 1
a504 1
		azalia_generic_mixer_set(this, this->playvols.master,
d513 1
a513 1
	return 0;
d912 4
a915 2
	    (w->widgetcap & COP_AWCAP_OUTAMP) &&
	    (w->outamp_cap & COP_AMPCAP_MUTE)) {
@


1.110
log
@no longer needed codec specific code

tested by danh@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.109 2009/01/05 07:55:34 jakemsr Exp $	*/
d522 1
a522 1
	int err, i, j, k;
d785 4
a788 2
		    w->d.pin.cap & COP_PINCAP_OUTPUT &&
		    w->d.pin.cap & COP_PINCAP_INPUT) {
d795 4
a798 6
			d->un.e.num_mem = 2;
			d->un.e.member[0].ord = 0;
			strlcpy(d->un.e.member[0].label.name, AudioNinput,
			    MAX_AUDIO_DEV_LEN);
			d->un.e.member[1].ord = 1;
			strlcpy(d->un.e.member[1].label.name, AudioNoutput,
d800 45
d1300 1
a1300 1
	uint32_t result;
d1395 20
a1414 1
		mc->un.ord = result & CORB_PWC_OUTPUT ? 1 : 0;
d1730 1
a1730 2
		if (mc->un.ord >= 2)
			return EINVAL;
d1735 1
d1737 1
d1739 5
d1746 9
a1754 3
		} else {
			value &= ~CORB_PWC_INPUT;
			value |= CORB_PWC_OUTPUT;
d1761 3
@


1.109
log
@use AUDIO_MIXER_SET instead of AUDIO_MIXER_ENUM to display mixers
that don't have selectable inputs.  all connections are active, always.
showing all connections in the set rather than just one makes a lot
more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.108 2009/01/04 22:45:24 jakemsr Exp $	*/
a91 1
int	azalia_ad1984_mixer_init(codec_t *);
a176 1
		this->mixer_init = azalia_ad1984_mixer_init;
a2145 16

/* Analog Devices AD1984 */
int
azalia_ad1984_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;

	azalia_generic_mixer_init(this);

	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 1;
	/* connect headphones to output of first DAC */
	azalia_generic_mixer_set(this, 0x22, MI_TARGET_CONNLIST, &mc);
	return 0;
}
@


1.108
log
@some mixers don't use input amp muting to "select" their sources.
instead they use the connection list setting like selectors do.
this is somewhat common in Analog Devices codecs.  it's extremely
rare in all other codecs.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.107 2009/01/03 19:17:45 jakemsr Exp $	*/
d584 1
a584 3
		if (w->nconnections > 0 &&
		    !(w->type == COP_AWTYPE_AUDIO_MIXER &&
		    (w->widgetcap & COP_AWCAP_INAMP)) &&
d755 30
d1139 2
a1140 1
		if (m->target != MI_TARGET_MUTESET)
d1148 1
a1148 1
			DPRINTF(("%s: invalid muteset nid\n", __func__));
d1431 17
d1837 4
@


1.107
log
@- configure volume knob widgets for indirect mode, which means they no
longer direcly affect other widgets
- if an unsolicited response is received from a volume knob widget,
adjust outputs.master according to the measured change in level of the
volume knob widget
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.106 2009/01/02 22:32:25 jakemsr Exp $	*/
d584 3
a586 1
		if (w->type != COP_AWTYPE_AUDIO_MIXER && w->nconnections > 0 &&
@


1.106
log
@- get rid of the function that was mostly just a wrapper for the old
function for creating "master" volume control.
- apply gpio quirks separately from and prior to configuring the mixer.
gpio manipulation can cause noise on output channels.  configuring
gpio before amps are unmuted in the mixer configuration is a good
thing.

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.105 2009/01/02 20:37:57 jakemsr Exp $	*/
d442 1
a442 1
	int i, err;
d464 35
a797 15

		/* volume knob */
		if (w->type == COP_AWTYPE_VOLUME_KNOB &&
		    w->d.volume.cap & COP_VKCAP_DELTA) {
			MIXER_REG_PROLOG;
			strlcpy(d->label.name, w->name, sizeof(d->label.name));
			d->type = AUDIO_MIXER_VALUE;
			d->mixer_class = AZ_CLASS_OUTPUT;
			m->target = MI_TARGET_VOLUME;
			d->un.v.num_channels = 1;
			d->un.v.units.name[0] = 0;
			d->un.v.delta =
			    MIXER_DELTA(COP_VKCAP_NUMSTEPS(w->d.volume.cap));
			this->nmixers++;
		}
d1069 2
a1070 1
	int i, j, tgt, cap;
d1090 1
a1090 2
		    m->target != MI_TARGET_OUTAMP &&
		    m->target != MI_TARGET_VOLUME)
d1099 1
a1099 2
		if (m->target != MI_TARGET_VOLUME &&
		    WIDGET_CHANNELS(&this->w[m->nid]) == 2) {
d1178 28
a1342 11
	/* Volume knob */
	else if (target == MI_TARGET_VOLUME) {
		err = this->comresp(this, nid, CORB_GET_VOLUME_KNOB,
		    0, &result);
		if (err)
			return err;
		mc->un.value.level[0] = azalia_generic_mixer_from_device_value(this,
		    nid, target, CORB_VKNOB_VOLUME(result));
		mc->un.value.num_channels = 1;
	}

a1693 12
	/* Volume knob */
	else if (target == MI_TARGET_VOLUME) {
		if (mc->un.value.num_channels != 1)
			return EINVAL;
		value = azalia_generic_mixer_to_device_value(this, nid, target,
		     mc->un.value.level[0]) | CORB_VKNOB_DIRECT;
		err = this->comresp(this, nid, CORB_SET_VOLUME_KNOB,
		   value, &result);
		if (err)
			return err;
	}

a1953 2
	else if (target == MI_TARGET_VOLUME)
		dmax = COP_VKCAP_NUMSTEPS(this->w[nid].d.volume.cap);
a1974 2
	else if (target == MI_TARGET_VOLUME)
		dmax = COP_VKCAP_NUMSTEPS(this->w[nid].d.volume.cap);
@


1.105
log
@add macros for setting/getting GPIO polarity instead of using
magic numbers

from Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.104 2009/01/02 20:35:05 jakemsr Exp $	*/
a74 1
int	azalia_generic_mixer_autoinit(codec_t *);
a90 1
int	azalia_codec_gpio_quirks(codec_t *);
d105 1
a105 1
	this->mixer_init = azalia_generic_mixer_autoinit;
a1162 9
azalia_generic_mixer_autoinit(codec_t *this)
{
	azalia_generic_mixer_init(this);
	azalia_codec_gpio_quirks(this);

	return 0;
}

int
d1165 4
a1168 4
	if (this->mixers == NULL)
		return 0;
	free(this->mixers, M_DEVBUF);
	this->mixers = NULL;
d2083 1
a2083 1
	azalia_generic_mixer_autoinit(this);
d2141 1
a2141 1
	azalia_generic_mixer_autoinit(this);
@


1.104
log
@* add GPIO quirk for Dell Vostro 1400 (from FreeBSD)
* move quirk for Dell E6400 into the group of quirks that set GPIO 0

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.103 2009/01/02 20:18:18 jakemsr Exp $	*/
d2055 1
a2055 1
		this->comresp(this, this->audiofunc, 0x7e7, 0, NULL);
@


1.103
log
@this is what I really wanted with r1.100 of azalia.c - fixed mics
are not really useful as output devices and fixed speakers are not
really useful as input devices
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.102 2009/01/02 00:39:25 jakemsr Exp $	*/
d64 2
d2070 1
d2078 2
a2079 2
	if (this->vid == IDT_92HD71B7 && this->subid == IDT92HD71B7_DELL_E6400) {
		azalia_gpio_unmute(this, 0);
@


1.102
log
@now that some devices will get output from/to two different sources/
outputs by default it's nice to have a way to control multiple sources/
outputs with a single control setting.

so here's an implementation of "master" controls that uses selectable
control lists, because the biggest problem is figuring out what should
be "master".

outputs.master.slaves is the current set of output mixer controls
that settings for outputs.master and outputs.master will be applied
to.  record.volume.slaves works similarly for recording inputs.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.101 2009/01/02 00:20:14 jakemsr Exp $	*/
d342 3
d348 3
d450 1
a450 1
			if (!(this->spkr_muters & (1 <<i)))
d552 2
a553 1
		    strcmp(w->name, this->w[w->connections[0]].name) == 0)) {
d583 2
a584 1
		    w->outamp_cap & COP_AMPCAP_MUTE) {
d604 3
a606 2
		if (w->widgetcap & COP_AWCAP_OUTAMP
		    && COP_AMPCAP_NUMSTEPS(w->outamp_cap)) {
d631 2
a632 1
		    w->inamp_cap & COP_AMPCAP_MUTE) {
d659 2
d674 3
a676 2
		if (w->widgetcap & COP_AWCAP_INAMP
		    && COP_AMPCAP_NUMSTEPS(w->inamp_cap)) {
d698 2
d742 2
a743 1
		    w->d.pin.cap & COP_PINCAP_HEADPHONE) {
@


1.101
log
@remove azalia_generic_mixer_create_virtual and all it's uses.  nicer
"master" volume controls coming shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.100 2008/12/31 13:35:58 jakemsr Exp $	*/
d818 106
d1033 1
a1033 1
	int i, j;
d1105 38
d1367 38
d1768 133
@


1.100
log
@- avoid using an argument twice, once as a pointer.  I just don't
like the way it looks.
- run the speaker mute handler when a muter jack changes I/O direction
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.99 2008/12/31 13:13:39 jakemsr Exp $	*/
a75 1
int	azalia_generic_mixer_create_virtual(codec_t *, int, int);
a92 2
int	azalia_alc260_mixer_init(codec_t *);
int	azalia_alc88x_mixer_init(codec_t *);
a93 2
int	azalia_stac9200_mixer_init(codec_t *);
int	azalia_stac9202_mixer_init(codec_t *);
a112 1
		this->mixer_init = azalia_alc260_mixer_init;
a139 1
		this->mixer_init = azalia_alc88x_mixer_init;
a143 1
		this->mixer_init = azalia_alc88x_mixer_init;
a147 1
		this->mixer_init = azalia_alc88x_mixer_init;
a151 1
		this->mixer_init = azalia_alc88x_mixer_init;
a155 1
		this->mixer_init = azalia_alc88x_mixer_init;
a220 1
		this->mixer_init = azalia_stac9202_mixer_init;
a223 1
		this->mixer_init = azalia_stac9202_mixer_init;
a226 1
		this->mixer_init = azalia_stac9202_mixer_init;
a242 1
		this->mixer_init = azalia_stac9200_mixer_init;
a1002 111
azalia_generic_mixer_create_virtual(codec_t *this, int pdac, int padc)
{
	mixer_item_t *m;
	mixer_devinfo_t *d;
	widget_t *w;
	convgroup_t *cgdac;
	convgroup_t *cgadc;
	int i, err, madc, mdac, target;
	uint32_t ampcap;

	if (this->dacs.ngroups > 0)
		cgdac = &this->dacs.groups[0];
	if (this->adcs.ngroups > 0)
		cgadc = &this->adcs.groups[0];

	/* Clear mixer indexes, to make generic_mixer_fix_index happy */
	for (i = 0; i < this->nmixers; i++) {
		d = &this->mixers[i].devinfo;
		d->index = d->prev = d->next = 0;
	}

	madc = mdac = -1;
	for (i = 0; i < this->nmixers && (mdac < 0 || madc < 0); i++) {
		if (this->mixers[i].devinfo.type != AUDIO_MIXER_VALUE)
			continue;
		if (pdac >= 0 && this->mixers[i].nid == pdac)
			mdac = i;
		if (mdac < 0 && this->dacs.ngroups > 0 && cgdac->nconv > 0) {
			if (this->mixers[i].nid == cgdac->conv[0])
				mdac = i;
		}
		if (padc >= 0 && this->mixers[i].nid == padc)
			madc = i;
		if (madc < 0 && this->adcs.ngroups > 0 && cgadc->nconv > 0) {
			if (this->mixers[i].nid == cgadc->conv[0])
				madc = i;
		}
	}

	if (mdac >= 0) {
		err = azalia_generic_mixer_ensure_capacity(this,
		    this->nmixers + 2);
		if (err)
			return err;
		m = &this->mixers[this->nmixers];
		d = &m->devinfo;
		memcpy(m, &this->mixers[mdac], sizeof(*m));
		d->mixer_class = AZ_CLASS_OUTPUT;
		snprintf(d->label.name, sizeof(d->label.name), AudioNmaster);
		this->nmixers++;

		w = &this->w[this->mixers[mdac].nid];
		if (IS_MI_TARGET_INAMP(m->target))
			ampcap = w->inamp_cap;
		else
			ampcap = w->outamp_cap;
		target = m->target;
		if (ampcap & COP_AMPCAP_MUTE) {
			d->next = this->nmixers;
			m = &this->mixers[this->nmixers];
			m->target = target;
			m->nid = this->mixers[mdac].nid;
			d = &m->devinfo;
			d->prev = this->nmixers - 1;
			snprintf(d->label.name, sizeof(d->label.name),
			    AudioNmute);
			d->mixer_class = AZ_CLASS_OUTPUT;
			azalia_devinfo_offon(d);
			this->nmixers++;
		}
	}

	if (madc >= 0) {
		err = azalia_generic_mixer_ensure_capacity(this,
		    this->nmixers + 2);
		if (err)
			return err;
		m = &this->mixers[this->nmixers];
		d = &m->devinfo;
		memcpy(m, &this->mixers[madc], sizeof(*m));
		d->mixer_class = AZ_CLASS_RECORD;
		snprintf(d->label.name, sizeof(d->label.name), AudioNvolume);
		this->nmixers++;

		w = &this->w[this->mixers[madc].nid];
		if (IS_MI_TARGET_INAMP(m->target))
			ampcap = w->inamp_cap;
		else
			ampcap = w->outamp_cap;
		target = m->target;
		if (ampcap & COP_AMPCAP_MUTE) {
			d->next = this->nmixers;
			m = &this->mixers[this->nmixers];
			m->target = target;
			m->nid = this->mixers[madc].nid;
			d = &m->devinfo;
			d->prev = this->nmixers - 1;
			snprintf(d->label.name, sizeof(d->label.name),
			    AudioNmute);
			d->mixer_class = AZ_CLASS_RECORD;
			azalia_devinfo_offon(d);
			this->nmixers++;
		}
	}

	azalia_generic_mixer_fix_indexes(this);

	return 0;
}

int
a1005 1
	azalia_generic_mixer_create_virtual(this, -1, -1);
a1769 10
/* Realtek ALC260 */
int
azalia_alc260_mixer_init(codec_t *this)
{
	azalia_generic_mixer_init(this);
	azalia_generic_mixer_create_virtual(this, 0x08, -1);
	azalia_codec_gpio_quirks(this);
	return 0;
}

a1771 9
azalia_alc88x_mixer_init(codec_t *this)
{
	azalia_generic_mixer_init(this);
	azalia_generic_mixer_create_virtual(this, 0x0c, -1);
	azalia_codec_gpio_quirks(this);
	return 0;
}

int
a1785 20
}

/* Sigmatel STAC9200 */
int
azalia_stac9200_mixer_init(codec_t *this)
{
	azalia_generic_mixer_init(this);
	azalia_generic_mixer_create_virtual(this, 0x0b, 0x0a);
	azalia_codec_gpio_quirks(this);
	return 0;
}

/* Sigmatel STAC9202 */
int
azalia_stac9202_mixer_init(codec_t *this)
{
	azalia_generic_mixer_init(this);
	azalia_generic_mixer_create_virtual(this, 0x0e, 0x09);
	azalia_codec_gpio_quirks(this);
	return 0;
@


1.99
log
@reimplement jack sense/speaker auto muting using unsolicited responses.
jacks which can mute speaker output are chosen with the new mixer item
'outputs.spkr_muters'.  e.g.

$ mixerctl -v outputs.spkr_muters
outputs.spkr_muters=hp,mic,line-in  { hp mic line-in }

if a jack is present in any listed "muter" plug, AND that plug is
configured for output (e.g. outputs.hp_dir=output) the speaker will
be muted.  the list of muters is selectable, selecting none turns of
muting altogether.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.98 2008/12/28 23:15:14 jakemsr Exp $	*/
d1528 1
d1530 2
a1531 2
			result &= ~CORB_PWC_OUTPUT;
			result |= CORB_PWC_INPUT;
d1533 2
a1534 2
			result &= ~CORB_PWC_INPUT;
			result |= CORB_PWC_OUTPUT;
d1537 1
a1537 1
		    CORB_SET_PIN_WIDGET_CONTROL, result, &result);
d1540 9
@


1.98
log
@get output from the first DAC to the line-out on the MacMini1,1
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.97 2008/12/26 10:07:48 jakemsr Exp $	*/
d69 3
a73 1

d114 1
a114 1
	this->unsol_event = NULL;
d446 36
d496 1
a551 1
		const widget_t *w;
d804 29
d1003 11
d1340 10
d1692 12
@


1.97
log
@don't try to create mutesets for selectors, they are only for
mixers.  problem noticed by Tas.  thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.96 2008/12/26 08:23:18 jakemsr Exp $	*/
d1848 1
a1848 1
	/* put hp and spkr dacs first in the dacgroup for MacBookPro1,2 */
d1850 3
a1852 1
		if (nid == 0xa && w->d.pin.color == CORB_CD_WHITE) {
d1856 1
a1856 1
		if (nid == 0xc && w->d.pin.color == CORB_CD_WHITE) {
d1859 4
@


1.96
log
@add a function for initializing mixer_devinfo_t off/on enums
and use it in 6 places.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.95 2008/12/26 07:24:06 jakemsr Exp $	*/
d600 1
a600 2
			if (w->type != COP_AWTYPE_AUDIO_SELECTOR &&
			    w->type != COP_AWTYPE_AUDIO_MIXER) {
@


1.95
log
@nuke unused macros.  from Alexey Suslikov.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.94 2008/12/26 06:56:36 jakemsr Exp $	*/
a84 1
int	azalia_gpio_unmute(codec_t *, int);
d86 1
d88 1
a556 1
			d->type = AUDIO_MIXER_ENUM;
d568 1
a568 7
			d->un.e.num_mem = 2;
			d->un.e.member[0].ord = 0;
			strlcpy(d->un.e.member[0].label.name, AudioNoff,
			    MAX_AUDIO_DEV_LEN);
			d->un.e.member[1].ord = 1;
			strlcpy(d->un.e.member[1].label.name, AudioNon,
			    MAX_AUDIO_DEV_LEN);
a604 1
				d->type = AUDIO_MIXER_ENUM;
d610 1
a610 7
				d->un.e.num_mem = 2;
				d->un.e.member[0].ord = 0;
				strlcpy(d->un.e.member[0].label.name,
				    AudioNoff, MAX_AUDIO_DEV_LEN);
				d->un.e.member[1].ord = 1;
				strlcpy(d->un.e.member[1].label.name,
				    AudioNon, MAX_AUDIO_DEV_LEN);
a708 1
			d->type = AUDIO_MIXER_ENUM;
d711 1
a711 7
			d->un.e.num_mem = 2;
			d->un.e.member[0].ord = 0;
			strlcpy(d->un.e.member[0].label.name, AudioNoff,
			    MAX_AUDIO_DEV_LEN);
			d->un.e.member[1].ord = 1;
			strlcpy(d->un.e.member[1].label.name, AudioNon,
			    MAX_AUDIO_DEV_LEN);
a719 1
			d->type = AUDIO_MIXER_ENUM;
d722 1
a722 7
			d->un.e.num_mem = 2;
			d->un.e.member[0].ord = 0;
			strlcpy(d->un.e.member[0].label.name, AudioNoff,
			    MAX_AUDIO_DEV_LEN);
			d->un.e.member[1].ord = 1;
			strlcpy(d->un.e.member[1].label.name, AudioNon,
			    MAX_AUDIO_DEV_LEN);
d814 11
d1008 1
a1008 8
			d->type = AUDIO_MIXER_ENUM;
			d->un.e.num_mem = 2;
			d->un.e.member[0].ord = 0;
			strlcpy(d->un.e.member[0].label.name, AudioNoff,
			    MAX_AUDIO_DEV_LEN);
			d->un.e.member[1].ord = 1;
			strlcpy(d->un.e.member[1].label.name, AudioNon,
			    MAX_AUDIO_DEV_LEN);
d1041 1
a1041 8
			d->type = AUDIO_MIXER_ENUM;
			d->un.e.num_mem = 2;
			d->un.e.member[0].ord = 0;
			strlcpy(d->un.e.member[0].label.name, AudioNoff,
			    MAX_AUDIO_DEV_LEN);
			d->un.e.member[1].ord = 1;
			strlcpy(d->un.e.member[1].label.name, AudioNon,
			    MAX_AUDIO_DEV_LEN);
@


1.94
log
@- recognize a few more realtek codecs
- beep and CD support for a few more realtek codecs (ALC268 verified by
Alexey Suslikov, the others are quite similar based on datasheets)
- "ALC662-GR" is a part number.  "ALC662" is a codec identifier.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.93 2008/12/25 22:09:51 jakemsr Exp $	*/
a41 6

#define ENUM_OFFON	.un.e={2, {{{AudioNoff}, 0}, {{AudioNon}, 1}}}
#define ENUM_IO		.un.e={2, {{{"input"}, 0}, {{"output"}, 1}}}
#define AzaliaNfront	"front"
#define AzaliaNclfe	"clfe"
#define AzaliaNside	"side"
@


1.93
log
@add "virtual" mutes if the "virtual" volume amps have mute capability
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.92 2008/12/24 10:58:52 jakemsr Exp $	*/
d123 4
d129 1
d134 3
d138 5
a142 1
		this->name = "Realtek ALC662-GR";
@


1.92
log
@typo spotted by Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.91 2008/12/23 10:43:26 jakemsr Exp $	*/
d955 1
d958 2
a959 1
	int i, err, madc, mmaster;
d972 2
a973 2
	madc = mmaster = -1;
	for (i = 0; i < this->nmixers && (mmaster < 0 || madc < 0); i++) {
d977 2
a978 2
			mmaster = i;
		if (mmaster < 0 && this->dacs.ngroups > 0 && cgdac->nconv > 0) {
d980 1
a980 1
				mmaster = i;
d990 3
a992 2
	if (mmaster >= 0) {
		err = azalia_generic_mixer_ensure_capacity(this, this->nmixers + 1);
d997 1
a997 1
		memcpy(m, &this->mixers[mmaster], sizeof(*m));
d1001 27
d1031 2
a1032 1
		err = azalia_generic_mixer_ensure_capacity(this, this->nmixers + 1);
d1041 27
@


1.91
log
@azalia_generic_mixer_pin_sense has nothing to do with pin sense anymore.
it is about codec gpio quirks.  so rename it as azalia_codec_gpio_quirks,
and move it to where the rest of the codec specific code is.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.90 2008/12/23 10:33:10 jakemsr Exp $	*/
d1777 1
a1777 1
	if (nid == 0x1c &&w->enable == 0 && w->d.pin.device == CORB_CD_CD) {
@


1.90
log
@add gpio quirk for Dell e6400
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.89 2008/12/23 10:19:39 jakemsr Exp $	*/
a79 1
int	azalia_generic_mixer_pin_sense(codec_t *);
d94 1
a280 1

a950 37
azalia_generic_mixer_pin_sense(codec_t *this)
{
	/* GPIO quirks */

	if (this->vid == SIGMATEL_STAC9221 && this->subid == STAC9221_APPLE_ID) {
		this->comresp(this, this->audiofunc, 0x7e7, 0, NULL);
		azalia_gpio_unmute(this, 0);
		azalia_gpio_unmute(this, 1);
	}
	if (this->vid == REALTEK_ALC883 && this->subid == ALC883_ACER_ID) {
		azalia_gpio_unmute(this, 0);
		azalia_gpio_unmute(this, 1);
	}
	if ((this->vid == REALTEK_ALC660 && this->subid == ALC660_ASUS_G2K) ||
	    (this->vid == REALTEK_ALC880 && this->subid == ALC880_ASUS_M5200) ||
	    (this->vid == REALTEK_ALC880 && this->subid == ALC880_ASUS_A7M) ||
	    (this->vid == REALTEK_ALC882 && this->subid == ALC882_ASUS_A7T) ||
	    (this->vid == REALTEK_ALC882 && this->subid == ALC882_ASUS_W2J) ||
	    (this->vid == REALTEK_ALC885 && this->subid == ALC885_APPLE_MB3) ||
	    (this->vid == REALTEK_ALC885 && this->subid == ALC885_APPLE_MB4) ||
	    (this->vid == SIGMATEL_STAC9205 && this->subid == STAC9205_DELL_D630) ||
	    (this->vid == SIGMATEL_STAC9205 && this->subid == STAC9205_DELL_V1500)) {
		azalia_gpio_unmute(this, 0);
	}

	if (this->vid == REALTEK_ALC880 && this->subid == ALC880_MEDION_MD95257) {
		azalia_gpio_unmute(this, 1);
	}

	if (this->vid == IDT_92HD71B7 && this->subid == IDT92HD71B7_DELL_E6400) {
		azalia_gpio_unmute(this, 0);
 	}

	return 0;
}

int
d1022 1
a1022 1
	azalia_generic_mixer_pin_sense(this);
d1702 32
d1760 1
a1760 1
	azalia_generic_mixer_pin_sense(this);
d1770 1
a1770 1
	azalia_generic_mixer_pin_sense(this);
d1797 1
a1797 1
	azalia_generic_mixer_pin_sense(this);
d1807 1
a1807 1
	azalia_generic_mixer_pin_sense(this);
@


1.89
log
@enable beep and CD mixer controls on alc88x codecs if appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.88 2008/12/23 10:06:50 jakemsr Exp $	*/
d68 2
d980 4
@


1.88
log
@add small quirks for certain codecs
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.87 2008/12/23 10:01:14 jakemsr Exp $	*/
d97 1
d136 1
d141 1
d146 1
d151 1
d156 1
d1772 17
@


1.87
log
@remove static mixer configurations wholesale, to make next commit
more clear.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.86 2008/12/23 09:46:38 jakemsr Exp $	*/
d94 1
d97 4
d172 1
d215 1
a215 2
		/* master volume at nid 0e */
		/* record volume at nid 09 */
d219 1
a219 2
		/* master volume at nid 0e */
		/* record volume at nid 09 */
d223 1
a223 2
		/* master volume at nid 0e */
		/* record volume at nid 09 */
d226 1
a226 1
		/* FALLTHRU */
d229 1
d233 1
d240 1
a1727 1

d1729 1
a1729 6
 * Realtek ALC260
 *
 * Fujitsu LOOX T70M/T
 *	Internal Speaker: 0x10
 *	Front Headphone: 0x14
 *	Front mic: 0x12
d1732 17
d1755 2
d1758 7
d1768 9
a1776 4
/* ----------------------------------------------------------------
 * Realtek ALC88x mixer init - volume control is on the mixer
 * instead of the DAC.
 * ---------------------------------------------------------------- */
d1778 1
d1780 1
a1780 1
azalia_alc88x_mixer_init(codec_t *this)
d1783 1
a1783 1
	azalia_generic_mixer_create_virtual(this, 0x0c, -1);
d1785 2
d1788 15
d1806 18
@


1.86
log
@- recognize some more codecs
- remove the codec datasheet URLs.  URLs change and these particular
datasheets are all easy to find.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.85 2008/12/23 04:12:19 jakemsr Exp $	*/
a95 15
int	azalia_ad1984_init_dacgroup(codec_t *);
int	azalia_ad1984_mixer_init(codec_t *);
int	azalia_ad1984_set_port(codec_t *, mixer_ctrl_t *);
int	azalia_ad1984_get_port(codec_t *, mixer_ctrl_t *);
int	azalia_cmi9880_init_dacgroup(codec_t *);
int	azalia_cmi9880_mixer_init(codec_t *);
int	azalia_stac9200_mixer_init(codec_t *);
int	azalia_stac9221_init_dacgroup(codec_t *);
int	azalia_stac9221_mixer_init(codec_t *);
int	azalia_stac9221_set_port(codec_t *, mixer_ctrl_t *);
int	azalia_stac9221_get_port(codec_t *, mixer_ctrl_t *);
int	azalia_stac7661_init_dacgroup(codec_t *);
int	azalia_stac7661_mixer_init(codec_t *);
int	azalia_stac7661_set_port(codec_t *, mixer_ctrl_t *);
int	azalia_stac7661_get_port(codec_t *, mixer_ctrl_t *);
a166 4
		this->init_dacgroup = azalia_ad1984_init_dacgroup;
		this->mixer_init = azalia_ad1984_mixer_init;
		this->get_port = azalia_ad1984_get_port;
		this->set_port = azalia_ad1984_set_port;
a184 2
		this->init_dacgroup = azalia_cmi9880_init_dacgroup;
		this->mixer_init = azalia_cmi9880_mixer_init;
a225 4
		this->init_dacgroup = azalia_stac7661_init_dacgroup;
		this->mixer_init = azalia_stac7661_mixer_init;
		this->get_port = azalia_stac7661_get_port;
		this->set_port = azalia_stac7661_set_port;
a228 4
		this->init_dacgroup = azalia_stac9221_init_dacgroup;
		this->mixer_init = azalia_stac9221_mixer_init;
		this->set_port = azalia_stac9221_set_port;
		this->get_port = azalia_stac9221_get_port;
a234 1
		this->mixer_init = azalia_stac9200_mixer_init;
a1756 552
/* ----------------------------------------------------------------
 * Analog Devices AD1984
 * ---------------------------------------------------------------- */

int
azalia_ad1984_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 2,
		{{2, {0x04, 0x03}},	/* analog 4ch */
		 {1, {0x02}}}};		/* digital */
	static const convgroupset_t adcs = {
		-1, 3,
		{{2, {0x08, 0x09}},	/* analog 4ch */
		 {1, {0x06}},		/* digital */
		 {1, {0x05}}}}; 	/* digital */
	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

static const mixer_item_t ad1984_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},
#define AD1984_DAC_HP        0x03
#define AD1984_DAC_SPEAKER   0x04
#define AD1984_TARGET_MASTER -1
#define AD1984_TARGET_MASTER_MUTE -2
	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  4, 0, .un.v={{""}, 2, MIXER_DELTA(39)}}, 0x03, AD1984_TARGET_MASTER},
	{{0, {AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 3, ENUM_OFFON}, 0x11, AD1984_TARGET_MASTER_MUTE},
	{{0, {AudioNvolume}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(54)}}, 0x0c, MI_TARGET_OUTAMP},
	{{0, {AudioNvolume"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_OUTAMP},
	{{0, {AudioNsource}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, .un.e={1, {{{AudioNmicrophone}, 0}}}},
	 0x0c, MI_TARGET_CONNLIST},
	{{0, {AudioNmicrophone"."AudioNpreamp}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(3)}}, 0x14, MI_TARGET_INAMP(0)},
	{{0, {AudioNmicrophone}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x20, MI_TARGET_INAMP(0)},
	{{0, {AudioNmicrophone"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x20, MI_TARGET_INAMP(0)},
	{{0, {AudioNheadphone}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(39)}}, 0x03, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x11, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x11, MI_TARGET_PINBOOST},
	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(39)}}, 0x04, MI_TARGET_OUTAMP},
	{{0, {AudioNspeaker"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x12, MI_TARGET_OUTAMP},
	{{0, {AudioNspeaker".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x12, MI_TARGET_PINBOOST},
	{{0, {AudioNmono}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(31)}}, 0x13, MI_TARGET_OUTAMP},
	{{0, {AudioNmono"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x13, MI_TARGET_OUTAMP}
};

int
azalia_ad1984_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;

	this->nmixers = sizeof(ad1984_mixer_items) / sizeof(mixer_item_t);
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, ad1984_mixer_items,
	    sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

	azalia_generic_mixer_pin_sense(this);

	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 1;		/* front DAC -> headphones */
	azalia_generic_mixer_set(this, 0x22, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 0;          /* unmute */
	azalia_generic_mixer_set(this, 0x07, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x07, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x0a, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x0a, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x0b, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x0b, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x1e, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x1e, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x24, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x24, MI_TARGET_INAMP(1), &mc);
	return 0;
}

int
azalia_ad1984_set_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;
	int err;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	if (mc->type != m->devinfo.type)
		return EINVAL;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if (m->target == AD1984_TARGET_MASTER) {
		err = azalia_generic_mixer_set(this, AD1984_DAC_HP,
		    MI_TARGET_OUTAMP, mc);
		err = azalia_generic_mixer_set(this, AD1984_DAC_SPEAKER,
		    MI_TARGET_OUTAMP, mc);
		return err;
	}
	if (m->target == AD1984_TARGET_MASTER_MUTE) {
		err = azalia_generic_mixer_set(this, 0x11, MI_TARGET_OUTAMP, mc);
		err = azalia_generic_mixer_set(this, 0x12, MI_TARGET_OUTAMP, mc);
		err = azalia_generic_mixer_set(this, 0x13, MI_TARGET_OUTAMP, mc);
		return err;
	}
	return azalia_generic_mixer_set(this, m->nid, m->target, mc);
}

int
azalia_ad1984_get_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	mc->type = m->devinfo.type;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if (m->target == AD1984_TARGET_MASTER || 
	    m->target == AD1984_TARGET_MASTER_MUTE)
		return azalia_generic_mixer_get(this, m->nid,
		    MI_TARGET_OUTAMP, mc);
	return azalia_generic_mixer_get(this, m->nid, m->target, mc);
}

/* ----------------------------------------------------------------
 * CMedia CMI9880
 * ---------------------------------------------------------------- */

static const mixer_item_t cmi9880_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},

	{{0, {AudioNmaster"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x03, MI_TARGET_OUTAMP},
	{{0, {AudioNsurround"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x04, MI_TARGET_OUTAMP},
	{{0, {AzaliaNclfe"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x05, MI_TARGET_OUTAMP},
	{{0, {AzaliaNside"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x06, MI_TARGET_OUTAMP},
	{{0, {"digital."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_OUTAMP},

	{{0, {AzaliaNfront"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(30)}}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront"."AudioNsource}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, .un.e={4, {{{AudioNmicrophone}, 5}, {{AudioNcd}, 6},
			   {{"line1"}, 7}, {{"line2"}, 8}}}},
	 0x08, MI_TARGET_CONNLIST},
	{{0, {AudioNsurround"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(30)}}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround"."AudioNsource}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, .un.e={4, {{{AudioNmicrophone}, 5}, {{AudioNcd}, 6},
			   {{"line1"}, 7}, {{"line2"}, 8}}}},
	 0x09, MI_TARGET_CONNLIST},

	{{0, {AudioNspeaker"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x23, MI_TARGET_OUTAMP},
	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(15)}}, 0x23, MI_TARGET_OUTAMP}
};

int
azalia_cmi9880_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;

	this->nmixers = sizeof(cmi9880_mixer_items) / sizeof(mixer_item_t);
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, cmi9880_mixer_items,
	    sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

	azalia_generic_mixer_pin_sense(this);

	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 5;		/* record.front.source=mic */
	azalia_generic_mixer_set(this, 0x08, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 7;		/* record.surround.source=line1 */
	azalia_generic_mixer_set(this, 0x09, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 0;		/* front DAC -> headphones */
	azalia_generic_mixer_set(this, 0x0f, MI_TARGET_CONNLIST, &mc);
	return 0;
}

int
azalia_cmi9880_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 2,
		{{4, {0x03, 0x04, 0x05, 0x06}}, /* analog 8ch */
		 {1, {0x07}}}};	/* digital */
	static const convgroupset_t adcs = {
		-1, 2,
		{{2, {0x08, 0x09}}, /* analog 4ch */
		 {1, {0x0a}}}};	/* digital */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
 * Sigmatel STAC9200
 * ---------------------------------------------------------------- */

static const mixer_item_t stac9200_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  4, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_OUTAMP},
	{{0, {AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 3, ENUM_OFFON}, 0x0b, MI_TARGET_OUTAMP},
	{{0, {AudioNvolume}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(15)}}, 0x0a, MI_TARGET_OUTAMP},
	{{0, {AudioNvolume"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x0a, MI_TARGET_OUTAMP},
	{{0, {AudioNsource}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, .un.e={5, {{{AudioNline}, 0}, {{AudioNmicrophone}, 1},
			   {{AudioNline"2"}, 2}, {{AudioNline"3"}, 3},
			   {{AudioNcd}, 4}}}},
	 0x0c, MI_TARGET_CONNLIST},
	{{0, {AudioNmicrophone}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(4)}}, 0x0c, MI_TARGET_OUTAMP},
	{{0, {AudioNmicrophone"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_OUTAMP},
	{{0, {AudioNsource}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, .un.e={3, {{{AudioNdac}, 0}, {{"digital-in"}, 1}, {{"selector"}, 2}}}},
	 0x07, MI_TARGET_CONNLIST},
	{{0, {"digital."AudioNsource}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, .un.e={2, {{{AudioNdac}, 0}, {{"selector"}, 1}}}},
	 0x09, MI_TARGET_CONNLIST}, /* AudioNdac is not accurate name */
	{{0, {AudioNheadphone".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x0d, MI_TARGET_PINBOOST},
	{{0, {AudioNspeaker".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x0e, MI_TARGET_PINBOOST},
	{{0, {AudioNmono"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x11, MI_TARGET_OUTAMP},
	{{0, {AudioNmono}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(31)}}, 0x11, MI_TARGET_OUTAMP},
	{{0, {"beep."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_OUTAMP},
	{{0, {"beep"}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(3)}}, 0x14, MI_TARGET_OUTAMP},
	{{0, {"usingdac"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}},
	 0, MI_TARGET_DAC},
	{{0, {"usingadc"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}},
	 0, MI_TARGET_ADC},
};

int
azalia_stac9200_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;

	this->nmixers = sizeof(stac9200_mixer_items) / sizeof(mixer_item_t);
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, stac9200_mixer_items,
	    sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

	azalia_generic_mixer_pin_sense(this);

	mc.dev = -1;		/* no need for generic_mixer_set() */
	mc.type = AUDIO_MIXER_VALUE;
	mc.un.value.num_channels = 2;
	mc.un.value.level[0] = AUDIO_MAX_GAIN;
	mc.un.value.level[1] = mc.un.value.level[0];
	azalia_generic_mixer_set(this, 0x0c, MI_TARGET_OUTAMP, &mc);
	return 0;
}

int
azalia_stac9221_init_dacgroup(codec_t *this)
{
	/* master volume at NID 16 */
	static const convgroupset_t dacs = {
		-1, 1,
		{{4, {0x02, 0x03, 0x04, 0x05}}}};

	/* vols: 06:12, 07:13 */
	static const convgroupset_t adcs = {
		-1, 2,
		{{2, {0x06, 0x07}},
		 {1, {0x09}}}};

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

static const mixer_item_t stac9221_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},
#define STAC9221_TARGET_MASTER -1
	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  4, 0, .un.v={{""}, 2, MIXER_DELTA(127)}}, 0x02, STAC9221_TARGET_MASTER},
	{{0, {AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 3, ENUM_OFFON}, 0x02, STAC9221_TARGET_MASTER},

	{{0, {AudioNheadphone}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(15)}}, 0x02, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x02, MI_TARGET_OUTAMP},

	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(15)}}, 0x03, MI_TARGET_OUTAMP},
	{{0, {AudioNspeaker".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x03, MI_TARGET_OUTAMP},

        {{0, {"line"}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
          0, 0, .un.v={{""}, 2, MIXER_DELTA(15)}}, 0x04, MI_TARGET_OUTAMP},
        {{0, {"line.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
          0, 0, ENUM_OFFON}, 0x04, MI_TARGET_OUTAMP},

        {{0, {"line2"}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
          0, 0, .un.v={{""}, 2, MIXER_DELTA(15)}}, 0x05, MI_TARGET_OUTAMP},
        {{0, {"line2.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
          0, 0, ENUM_OFFON}, 0x05, MI_TARGET_OUTAMP},
};

int
azalia_stac9221_mixer_init(codec_t *this)
{
	this->nmixers = sizeof(stac9221_mixer_items) / sizeof(mixer_item_t);
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, stac9221_mixer_items,
	    sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

	azalia_generic_mixer_pin_sense(this);

	return 0;
}

int
azalia_stac9221_set_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;
	int err;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	if (mc->type != m->devinfo.type)
		return EINVAL;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if (m->target == STAC9221_TARGET_MASTER) {
		err = azalia_generic_mixer_set(this, 0x02,
		    MI_TARGET_OUTAMP, mc);
		err = azalia_generic_mixer_set(this, 0x03,
		    MI_TARGET_OUTAMP, mc);
		err = azalia_generic_mixer_set(this, 0x04,
		    MI_TARGET_OUTAMP, mc);
		err = azalia_generic_mixer_set(this, 0x05,
		    MI_TARGET_OUTAMP, mc);
		return err;
	}
	return azalia_generic_mixer_set(this, m->nid, m->target, mc);
}

int
azalia_stac9221_get_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	mc->type = m->devinfo.type;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if (m->target == STAC9221_TARGET_MASTER)
		return azalia_generic_mixer_get(this, m->nid,
		    MI_TARGET_OUTAMP, mc);
	return azalia_generic_mixer_get(this, m->nid, m->target, mc);
}

/* ----------------------------------------------------------------
 * Sony VAIO FE and SZ
 * ---------------------------------------------------------------- */

int
azalia_stac7661_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 1,
		{{2, {0x02, 0x05}}}};

	static const convgroupset_t adcs = {
		-1, 1,
		{{1, {0x08}}}};

	this->dacs = dacs;
	this->adcs = adcs;

	return 0;
}

static const mixer_item_t stac7661_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},

#define STAC7661_DAC_HP        0x02
#define STAC7661_DAC_SPEAKER   0x05
#define STAC7661_TARGET_MASTER -1

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  4, 0, .un.v={{""}, 2, MIXER_DELTA(127)}}, 0x02, STAC7661_TARGET_MASTER},
	{{0, {AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 3, ENUM_OFFON}, 0x02, STAC7661_TARGET_MASTER},
	{{0, {AudioNvolume"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	    ENUM_OFFON}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AudioNvolume}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD, 0, 0,
	    .un.v={{""}, 2, MIXER_DELTA(15)}}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AudioNsource}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, .un.e={3, {{{AudioNmicrophone}, 1}, {{AudioNmicrophone"2"}, 2},
			   {{AudioNdac}, 3}}}},
	 0x15, MI_TARGET_CONNLIST},
	{{0, {AudioNmicrophone}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  .un.v={{""}, 2, MIXER_DELTA(4)}}, 0x15, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	    0, 0, ENUM_OFFON}, 0x02, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	    0, 0, .un.v={{""}, 2, MIXER_DELTA(127)}}, 0x02, MI_TARGET_OUTAMP},
	{{0, {AudioNspeaker".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	    0, 0, ENUM_OFFON}, 0x05, MI_TARGET_OUTAMP},
	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	    0, 0, .un.v={{""}, 2, MIXER_DELTA(127)}}, 0x05, MI_TARGET_OUTAMP}
};

int
azalia_stac7661_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;

	this->nmixers = sizeof(stac7661_mixer_items) / sizeof(mixer_item_t);
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, stac7661_mixer_items,
	    sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

	azalia_generic_mixer_pin_sense(this);

	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 1;
	azalia_generic_mixer_set(this, 0x09, MI_TARGET_INAMP(0), &mc); /* mute input */
	mc.un.ord = 2;          /* select internal mic for recording */
	azalia_generic_mixer_set(this, 0x15, MI_TARGET_CONNLIST, &mc);
	return 0;
}

int
azalia_stac7661_set_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;
	int err;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	if (mc->type != m->devinfo.type)
		return EINVAL;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if (m->target == STAC7661_TARGET_MASTER) {
		err = azalia_generic_mixer_set(this, STAC7661_DAC_HP,
		    MI_TARGET_OUTAMP, mc);
		err = azalia_generic_mixer_set(this, STAC7661_DAC_SPEAKER,
		    MI_TARGET_OUTAMP, mc);
		return err;
	}
	return azalia_generic_mixer_set(this, m->nid, m->target, mc);
}
int
azalia_stac7661_get_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	mc->type = m->devinfo.type;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if (m->target == STAC7661_TARGET_MASTER)
		return azalia_generic_mixer_get(this, m->nid,
		    MI_TARGET_OUTAMP, mc);
	return azalia_generic_mixer_get(this, m->nid, m->target, mc);
}
@


1.85
log
@a) a widget's nid is always it's index in the codec's widget list.
b) members of the widget connection list may be invalid.
so,
- change azalia_nid_to_index to azalia_widget_enabled, and have it only
check that the given nid is valid, and that the corresponding widget
is enabled.
- use azalia_widget_enabled every time members of the connection list
are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.84 2008/12/22 03:47:16 jakemsr Exp $	*/
a150 1
		/* ftp://209.216.61.149/pc/audio/ALC883_DataSheet_1.3.pdf */
d162 15
a177 1
		/* http://www.analog.com/en/prod/0,2877,AD1983,00.html */
a180 1
		/* http://www.analog.com/en/prod/0,2877,AD1984,00.html */
a187 1
		/* http://www.analog.com/en/prod/0,2877,AD1988A,00.html */
a190 1
		/* http://www.analog.com/en/prod/0,2877,AD1988B,00.html */
a262 1
		/* http://www.idt.com/products/getDoc.cfm?docID=17812077 */
@


1.84
log
@create "_source" mixer items for single connections, but be careful
to not be redundant.  important for understanding how widgets are
connected.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.83 2008/12/22 02:20:22 jakemsr Exp $	*/
a91 1
int	azalia_nid_to_index(const codec_t *, nid_t);
d281 1
a281 1
azalia_nid_to_index(const codec_t *this, nid_t nid)
d283 3
a285 11
	int i;

	FOR_EACH_WIDGET(this, i)
		if (this->w[i].nid == nid)
			break;
	if (i == this->wend ||
	    !VALID_WIDGET_NID(this->w[i].nid, this) ||
	    !this->w[i].enable)
		return -1;

	return i;
d319 1
a319 1
	int i, j, k, l;
d376 2
a377 3
						l = azalia_nid_to_index(this,
						    conv);
						if (l == -1)
d380 1
a380 1
						    (this, w->nid, l, 0);
d419 1
a419 1
	int i, j, ret;
d435 1
a435 2
		j = azalia_nid_to_index(this, w->connections[i]);
		if (j == -1)
d437 2
a438 1
		ret = azalia_generic_codec_fnode(this, node, j, depth);
d460 1
a460 1
	int err, i, j, k, l;
d523 1
d539 2
a540 3
				l = azalia_nid_to_index(this,
				    w->connections[j]);
				if (l == -1)
d544 2
a545 1
				    this->w[l].name, MAX_AUDIO_DEV_LEN);
d637 4
a640 5
				for (j = 0, l = 0;
				    j < w->nconnections && l < 32; j++) {
					k = azalia_nid_to_index(this,
					    w->connections[j]);
					if (k == -1)
d642 5
a646 4
					d->un.s.member[l].mask = 1 << j;
					strlcpy(d->un.s.member[l].label.name,
					    this->w[k].name, MAX_AUDIO_DEV_LEN);
					l++;
d648 2
a649 2
				d->un.s.num_mem = l;
				if (l != 0)
d675 2
a676 3
					k = azalia_nid_to_index(this,
					    w->connections[j]);
					if (k == -1)
d681 2
a682 1
					    w->name, this->w[k].name);
d773 1
a773 2
		j = azalia_nid_to_index(this, this->sense_pins[i]);
		if (j == -1) {
d780 1
a780 1
		m->nid = this->w[j].nid;
d782 1
a782 1
		    this->w[j].name);
d894 1
a894 1
	int i, j, k;
d942 1
a942 2
		j = azalia_nid_to_index(this, m->nid);
		if (j == -1) {
d946 1
a946 1
		w = &this->w[j];
d948 1
a948 2
			k = azalia_nid_to_index(this, w->connections[j]);
			if (k == -1)
d1087 1
a1087 1
	int i, j, err;
d1111 4
a1114 6
#ifdef AZALIA_DEBUG
			if (!VALID_WIDGET_NID(n, this)) {
				DPRINTF(("%s: invalid target: nid=%d nconn=%d index=%d\n",
				   __func__, nid, this->w[nid].nconnections,
				   MI_TARGET_INAMP(target)));
				return EINVAL;
a1115 1
#endif
d1167 2
a1168 1
		if (!VALID_WIDGET_NID(this->w[nid].connections[result], this))
d1251 1
a1251 2
		i = azalia_nid_to_index(this, nid);
		if (i == -1) {
d1255 1
a1255 1
		w = &this->w[i];
d1258 1
a1258 2
			j = azalia_nid_to_index(this, w->connections[i]);
			if (j == -1)
d1283 1
a1283 1
	int i, j, err;
d1431 2
a1432 1
		    !VALID_WIDGET_NID(this->w[nid].connections[mc->un.ord], this))
d1566 1
a1566 2
		i = azalia_nid_to_index(this, nid);
		if (i == -1) {
d1570 1
a1570 1
		w = &this->w[i];
d1572 1
a1572 2
			j = azalia_nid_to_index(this, w->connections[i]);
			if (j == -1)
@


1.83
log
@disable unusable converters
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.82 2008/12/22 00:54:04 jakemsr Exp $	*/
d531 3
a533 1
		if (w->type != COP_AWTYPE_AUDIO_MIXER && w->nconnections >= 2) {
@


1.82
log
@new function azalia_pin_config_ov, used to override configuration
values read from pin complex widgets.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.81 2008/12/21 20:44:04 jakemsr Exp $	*/
d412 8
@


1.81
log
@label converter widgets for their place in the converter group.
e.g. the first DAC in the converter group is now dac, the second
is dac2, etc.

unused converters (not in a converter group) will have a "u-" prefix.
these will disappear completely in the near future, as they are useless.

if there is more than one converter group, converters in the second
group will have a "dig-" prefix, since they are digital converters.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.80 2008/12/21 20:21:24 jakemsr Exp $	*/
d93 1
d1725 25
@


1.80
log
@add mixer_class member to struct widget_t, and define the mixer
classes in azalia.h instead of azalia_codec.c.  this will allow
the mixer class to be determined outside of azalia_generic_mixer_init.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.79 2008/11/30 22:01:34 jakemsr Exp $	*/
a462 3
	nid_t aconns[32];
	int naconns;

a513 1
	naconns = 0;
a520 28
		/* Widgets that are the sole input to an ADC should be in
		 * AZ_CLASS_RECORD.
		 */
		if (w->type == COP_AWTYPE_AUDIO_INPUT &&
		    this->adcs.ngroups > 0) {
			const convgroupset_t *group;

			group = &this->adcs;
			k = 0;
			for (j = 0; j < group->groups[group->cur].nconv; j++)
				if (group->groups[group->cur].conv[j] == w->nid)
					break;
			if (j < group->groups[group->cur].nconv)
				k = w->nconnections;
			if (k == 1) {
				k = azalia_nid_to_index(this,
				    w->connections[0]);
				if (k != -1) {
					for (l = 0; l < naconns; l++)
						if (aconns[l] == this->w[k].nid)
							break;
					if (l == naconns)
						aconns[naconns++] =
						    this->w[k].nid;
				}
			}
		}

d527 7
a533 16
			switch (w->type) {
			case COP_AWTYPE_AUDIO_INPUT:
				d->mixer_class = AZ_CLASS_RECORD;
				break;
			case COP_AWTYPE_AUDIO_SELECTOR:
				d->mixer_class = AZ_CLASS_INPUT;
				break;
			default:
				d->mixer_class = AZ_CLASS_OUTPUT;
				break;
			}
			for (j = 0; j < naconns; j++) {
				if (aconns[j] == w->nid) {
					d->mixer_class = AZ_CLASS_RECORD;
					break;
				}
d557 10
a566 6
			if (w->type == COP_AWTYPE_AUDIO_MIXER ||
			    w->type == COP_AWTYPE_AUDIO_SELECTOR ||
			    w->type == COP_AWTYPE_PIN_COMPLEX)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else
				d->mixer_class = AZ_CLASS_INPUT;
d585 10
a594 6
			if (w->type == COP_AWTYPE_AUDIO_MIXER ||
			    w->type == COP_AWTYPE_AUDIO_SELECTOR ||
			    w->type == COP_AWTYPE_PIN_COMPLEX)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else
				d->mixer_class = AZ_CLASS_INPUT;
d612 2
a613 2
				if (w->type == COP_AWTYPE_AUDIO_INPUT)
					d->mixer_class = AZ_CLASS_RECORD;
d631 2
a632 2
				if (w->type == COP_AWTYPE_AUDIO_INPUT)
					d->mixer_class = AZ_CLASS_RECORD;
a634 7
				for (j = 0; j < naconns; j++) {
					if (aconns[j] == w->nid) {
						d->mixer_class =
						    AZ_CLASS_RECORD;
						break;
					}
				}
d661 2
a662 2
				if (w->type == COP_AWTYPE_AUDIO_INPUT)
					d->mixer_class = AZ_CLASS_RECORD;
d682 2
a683 2
					if (w->type == COP_AWTYPE_AUDIO_INPUT)
						d->mixer_class = AZ_CLASS_RECORD;
a685 7
					for (k = 0; k < naconns; k++) {
						if (aconns[k] == w->nid) {
							d->mixer_class =
							    AZ_CLASS_RECORD;
							break;
						}
					}
@


1.79
log
@oops.  don't continue on to the next widget here.  there may be other
controls on the widget that need to be configured.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.78 2008/11/30 21:58:43 jakemsr Exp $	*/
a42 3
#define AZ_CLASS_INPUT	0
#define AZ_CLASS_OUTPUT	1
#define AZ_CLASS_RECORD	2
@


1.78
log
@only put a control in the record class if it is the sole input to
an ADC.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.77 2008/11/30 04:01:53 jakemsr Exp $	*/
d690 2
a691 3
				if (l == 0)
					continue;
				this->nmixers++;
@


1.77
log
@
don't rebuild the list of supported formats if it isn't going
to change.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.76 2008/11/30 03:50:29 jakemsr Exp $	*/
d528 3
a530 1
		/* usable adcs - connections should be in AZ_CLASS_RECORD */
d542 1
a542 1
			for (j = 0; j < k && naconns < 32; j++) {
d544 9
a552 8
				    w->connections[j]);
				if (k == -1)
					continue;
				for (l = 0; l < naconns; l++)
					if (aconns[l] == this->w[k].nid)
						break;
				if (l == naconns)
					aconns[naconns++] = this->w[k].nid;
@


1.76
log
@- don't access nonexistent converter goups
- don't try to create formats for converter groups that don't exist
- don't allow playback or recording if there is no corresponding
converter group
- don't try to set audio processing parameters on converter groups
that don't exist

allows playback (or record) only devices to work, such as the
azalias found on ATI graphics devices.

note, the ATI devices generally attach before the onboard devices
do.  that means they will be audio0 and onboard devices will be audio1.
don't forget to make sure the /dev/{audio[ctl],mixer,sound} links
point to the nodes of the device you want to be the default.

tested by naddy@@, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.75 2008/11/28 21:50:05 jakemsr Exp $	*/
d1538 5
a1542 2
		return azalia_codec_construct_format(this,
		    mc->un.ord, this->adcs.cur);
d1551 5
a1555 2
		return azalia_codec_construct_format(this,
		    this->dacs.cur, mc->un.ord);
@


1.75
log
@don't create a _source control on mixers if none of the sources are
usable.  better (generalized) solution forthcoming, but this is a
reasonable check anyway.

problem noted and fix tested by Alexey Suslikov, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.74 2008/11/28 21:45:49 jakemsr Exp $	*/
d336 1
d338 1
d345 2
a347 1
	nconvs = 0;
d529 2
a530 1
		if (w->type == COP_AWTYPE_AUDIO_INPUT) {
d534 1
d538 3
a540 4
			if (j == group->groups[group->cur].nconv)
				continue;

			for (j = 0; j < w->nconnections && naconns < 32; j++) {
d1045 2
a1046 2
	convgroup_t *cgdac = &this->dacs.groups[0];
	convgroup_t *cgadc = &this->adcs.groups[0];
d1048 5
@


1.74
log
@AZ_TARGET_PINSENSE -> MI_TARGET_PINSENSE

reminder from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.73 2008/11/28 09:58:18 jakemsr Exp $	*/
d683 2
@


1.73
log
@- remove a couple unneeded checks
- another place to use azalia_nid_to_index
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.72 2008/11/28 04:03:37 jakemsr Exp $	*/
d826 1
a826 1
		m->target = AZ_TARGET_PINSENSE;
d1279 1
a1279 1
	else if (target == AZ_TARGET_PINSENSE) {
d1594 1
a1594 1
	else if (target == AZ_TARGET_PINSENSE) {
@


1.72
log
@
- use switch() instead of multiple if else
- put selectors that feed ADCs into the record class like we do for
mixers
- use azalia_nid_to_index more
- shrink mixer items list by condensing mutes for multiple input
sources into a single _source control of type AUDIO_MIXER_SET.
for example,

record.mix6_mic_mute=off
record.mix6_mic2_mute=off
record.mix6_line_mute=off
record.mix6_hp_mute=off
record.mix6_spkr_mute=off
record.mix6_mix_mute=off

is now represented as

record.mix6_source=mic,mic2,line,hp,spkr,mix

to mute all sources but the mic just do

record.mix6_source=mic

reduces mixer items by about 25% on my machine.  also shortens the
longest names.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.71 2008/11/28 03:27:11 jakemsr Exp $	*/
d381 1
a381 2
						if (k < 0 ||
						    this->w[k].nid != conv)
d390 1
a390 2
						if (k < 0 || this->w[k].nid !=
						    w->nid)
d708 4
a711 2
					const widget_t *ww;

d713 3
a715 9
					if (!VALID_WIDGET_NID(w->connections[j],
					    this))
						continue;
					ww = &this->w[w->connections[j]];
					if (!ww->enable)
						continue;
					snprintf(d->label.name, sizeof(d->label.name),
					    "%s_%s", w->name,
					    this->w[w->connections[j]].name);
@


1.71
log
@
- DACs don't have connection lists like ADCs do
- we're only interested in ADCs in the ADC converter group
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.70 2008/11/28 03:18:11 jakemsr Exp $	*/
d557 2
a558 1
			if (w->type == COP_AWTYPE_AUDIO_MIXER)
d560 2
a561 1
			else if (w->type == COP_AWTYPE_AUDIO_SELECTOR)
d563 2
a564 1
			else
d566 8
d576 3
a578 6
				const widget_t *ww;

				if (!VALID_WIDGET_NID(w->connections[j], this))
					continue;
				ww = &this->w[w->connections[j]];
				if (!ww->enable)
d582 1
a582 2
				    this->w[w->connections[j]].name,
				    MAX_AUDIO_DEV_LEN);
d657 21
a677 6
				for (j = 0; j < w->nconnections; j++) {
					const widget_t *ww;

					MIXER_REG_PROLOG;
					if (!VALID_WIDGET_NID(w->connections[j],
					    this))
d679 4
a682 27
					ww = &this->w[w->connections[j]];
					if (!ww->enable)
						continue;
					snprintf(d->label.name, sizeof(d->label.name),
					    "%s_%s_mute", w->name,
					    this->w[w->connections[j]].name);
					d->type = AUDIO_MIXER_ENUM;
					if (w->type == COP_AWTYPE_AUDIO_INPUT)
						d->mixer_class = AZ_CLASS_RECORD;
					else
						d->mixer_class = AZ_CLASS_INPUT;
					for (k = 0; k < naconns; k++) {
						if (aconns[k] == w->nid) {
							d->mixer_class =
							    AZ_CLASS_RECORD;
							break;
						}
					}
					m->target = j;
					d->un.e.num_mem = 2;
					d->un.e.member[0].ord = 0;
					strlcpy(d->un.e.member[0].label.name,
					    AudioNoff, MAX_AUDIO_DEV_LEN);
					d->un.e.member[1].ord = 1;
					strlcpy(d->un.e.member[1].label.name,
					    AudioNon, MAX_AUDIO_DEV_LEN);
					this->nmixers++;
d684 2
d938 1
a938 1
	int i;
d940 3
a944 2
		mixer_ctrl_t mc;

d951 1
a953 1
		mc.un.ord = 0;
a958 2
		mixer_ctrl_t mc;

d966 1
d979 25
d1126 2
a1127 1
azalia_generic_mixer_get(const codec_t *this, nid_t nid, int target, mixer_ctrl_t *mc)
d1131 1
a1131 1
	int err;
d1293 25
d1327 2
a1328 1
azalia_generic_mixer_set(codec_t *this, nid_t nid, int target, const mixer_ctrl_t *mc)
d1331 1
a1331 1
	int err;
d1602 54
@


1.70
log
@
add paranoia helper function, azalia_nid_to_index.  the nid is
assumed in places to be the index of the widget in the widget_t
array of the codec_t, but I'm paranoid.

use it to shrink/simplify/fortify some parts.  will be used more
soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.69 2008/11/27 23:30:58 jakemsr Exp $	*/
d463 1
a463 1
	int err, i, j, k;
a464 2
	nid_t dconns[32];
	int ndconns = 0;
d466 1
a466 1
	int naconns = 0;
d519 1
d527 18
a544 25
		/* converters (DACc/ADCs)
		 * not mixer widgets, but keep track of connections to
		 * help determine mixer class.
		 */
		if (w->widgetcap & COP_AWCAP_FORMATOV) {
			/* adcs */
			if (w->type == COP_AWTYPE_AUDIO_INPUT) {
				for (j = 0; j < w->nconnections; j++) {
					const widget_t *ww;

					if (!VALID_WIDGET_NID(w->connections[j],
					    this))
						continue;
					ww = &this->w[w->connections[j]];
					if (!ww->enable)
						continue;
					for (k = 0; k < naconns; k++) {
						if (aconns[k] ==
						    w->connections[j])
							break;
					}
					if (k == naconns)
						aconns[naconns++] =
						    w->connections[j];
					if (naconns == 32)
d546 2
a547 24
				}
			}
			/* dacs */
			if (w->type == COP_AWTYPE_AUDIO_OUTPUT) {
				for (j = 0; j < w->nconnections; j++) {
					const widget_t *ww;

					if (!VALID_WIDGET_NID(w->connections[j],
					    this))
						continue;
					ww = &this->w[w->connections[j]];
					if (!ww->enable)
						continue;
					for (k = 0; k < ndconns; k++) {
						if (dconns[k] ==
						    w->connections[j])
							break;
					}
					if (k == ndconns)
						dconns[ndconns++] =
						    w->connections[j];
					if (ndconns == 32)
						break;
				}
@


1.69
log
@
widget initialization cleanup:
* configure widgets all in one place
* add a flag on the widget_t to let us know if the widget is not
connected; shaves a lot of connection checking code
* be sure not to add power widgets as connectable sources/sinks
* configure unconnected pins as output pins.  should help some
MacBooks and be benign to other devices.

the last change has been tested by several as a separate diff.  no
real functional changes otherwise.

from Alexey Suslikov.  thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.68 2008/11/27 23:03:29 jakemsr Exp $	*/
d95 2
d284 17
d385 4
a388 4
						FOR_EACH_WIDGET(this, l)
							if (this->w[l].nid ==
							    conv)
								break;
d422 1
a422 1
	int i, j, k, ret;
d438 2
a439 2
		j = w->connections[i];
		if (!VALID_WIDGET_NID(j, this))
d441 3
a443 11
		FOR_EACH_WIDGET(this, k)
			if (this->w[k].nid == j)
				break;
		if (k < this->wend) {
			if (this->w[k].enable) {
				ret = azalia_generic_codec_fnode(this, node,
				    k, depth);
				if (ret >= 0)
					return ret;
			}
		}
d848 2
a849 5
		FOR_EACH_WIDGET(this, j) {
			if (this->w[j].nid == this->sense_pins[i])
				break;
		}
		if (j == this->wend) {
@


1.68
log
@
finally, generic converter grouping that fits our needs and works
on all (at least all tested) devices.  briefly, it works like so:
group together all converters that can be reached from or can reach
a connected input or output pin.  ordering in the converter groups
correlates to the association and sequence of the input/output pin.

remove lots of static converter groupings in favor of the generic
grouping method.  the only static groups left are for codecs that
still have static mixer configurations.

tested by many.  thanks to all who tested; this wouldn't have
happened without your support.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.67 2008/11/19 21:49:44 naddy Exp $	*/
a51 1
#define ALC260_FUJITSU_ID	0x132610cf
a72 1
int	azalia_generic_codec_is_live_pin(const widget_t *, uint32_t, uint32_t);
d329 10
a338 1
				const widget_t *w = &this->w[i];
d343 1
a343 2
					if (azalia_generic_codec_is_live_pin(w,
					    COP_PINCAP_OUTPUT, digital) == 0)
d346 1
a346 2
					if (azalia_generic_codec_is_live_pin(w,
					    COP_PINCAP_INPUT, digital) == 0)
a399 31
azalia_generic_codec_is_live_pin(const widget_t *w, uint32_t iocap, uint32_t digital)
{
	uint8_t conn, dev;

	if (w->type != COP_AWTYPE_PIN_COMPLEX)
		return 0;
	if ((w->d.pin.cap & iocap) == 0)
		return 0;
	if ((w->widgetcap & COP_AWCAP_DIGITAL) != digital)
		return 0;
	PIN_STATUS(w, conn);
	if (conn == CORB_CD_NONE)
		return 0;
	dev = CORB_CD_DEVICE(w->d.pin.config);
	if (iocap == COP_PINCAP_OUTPUT) {
		if (dev == CORB_CD_LINEOUT || dev == CORB_CD_SPEAKER ||
		    dev == CORB_CD_HEADPHONE ||
		    (digital == COP_AWCAP_DIGITAL &&
		    (dev == CORB_CD_SPDIFOUT || dev == CORB_CD_DIGITALOUT)))
			return 1;
	} else {
		if (dev == CORB_CD_MICIN || dev == CORB_CD_LINEIN ||
		    (digital == COP_AWCAP_DIGITAL &&
		    (dev == CORB_CD_SPDIFIN || dev == CORB_CD_DIGITALIN)))
			return 1;
	}

	return 0;
}

int
d426 6
a431 3
			ret = azalia_generic_codec_fnode(this, node, k, depth);
			if (ret >= 0)
				return ret;
d514 2
a515 8

		/* skip unconnected pins */
		if (w->type == COP_AWTYPE_PIN_COMPLEX) {
			uint8_t conn =
			    (w->d.pin.config & CORB_CD_PORT_MASK) >> 30;
			if (conn == 1)	/* no physical connection */
				continue;
		}
d525 1
a525 1
					uint8_t conn;
d530 2
a531 4
					/* skip unconnected pins */
					PIN_STATUS(&this->w[w->connections[j]],
					    conn);
					if (conn == 1)
d548 1
a548 1
					uint8_t conn;
d553 2
a554 4
					/* skip unconnected pins */
					PIN_STATUS(&this->w[w->connections[j]],
					    conn);
					if (conn == 1)
d571 1
a571 2
		if (w->type != COP_AWTYPE_AUDIO_MIXER &&
		    w->type != COP_AWTYPE_POWER && w->nconnections >= 2) {
d584 1
a584 1
				uint8_t conn;
d588 2
a589 4
				/* skip unconnected pins */
				PIN_STATUS(&this->w[w->connections[j]],
				    conn);
				if (conn == 1)
d669 2
a670 1
				uint8_t conn;
a671 1
				for (j = 0; j < w->nconnections; j++) {
d673 2
a674 1
					if (!VALID_WIDGET_NID(w->connections[j], this))
d676 2
a677 4
					/* skip unconnected pins */
					PIN_STATUS(&this->w[w->connections[j]],
					    conn);
					if (conn == 1)
d727 2
a728 1
				uint8_t conn;
a729 1
				for (j = 0; j < w->nconnections; j++) {
d731 2
a732 1
					if (!VALID_WIDGET_NID(w->connections[j], this))
d734 2
a735 4
					/* skip unconnected pins */
					PIN_STATUS(&this->w[w->connections[j]],
					    conn);
					if (conn == 1)
a1005 71
	typedef enum {
		PIN_DIR_IN,
		PIN_DIR_OUT,
		PIN_DIR_MIC
	} pintype_t;
	const widget_t *w;
	int i;

	FOR_EACH_WIDGET(this, i) {
		pintype_t pintype = PIN_DIR_IN;

		w = &this->w[i];
		if (w->type != COP_AWTYPE_PIN_COMPLEX)
			continue;
		if (!(w->d.pin.cap & COP_PINCAP_INPUT))
			pintype = PIN_DIR_OUT;
		if (!(w->d.pin.cap & COP_PINCAP_OUTPUT))
			pintype = PIN_DIR_IN;

		switch (w->d.pin.device) {
		case CORB_CD_LINEOUT:
		case CORB_CD_SPEAKER:
		case CORB_CD_HEADPHONE:
		case CORB_CD_SPDIFOUT:
		case CORB_CD_DIGITALOUT:
			pintype = PIN_DIR_OUT;
			break;
		case CORB_CD_CD:
		case CORB_CD_LINEIN:
			pintype = PIN_DIR_IN;
			break;
		case CORB_CD_MICIN:
			pintype = PIN_DIR_MIC;
			break;
		}

		switch (pintype) {
		case PIN_DIR_IN:
			this->comresp(this, w->nid,
			    CORB_SET_PIN_WIDGET_CONTROL,
			    CORB_PWC_INPUT, NULL);
			break;
		case PIN_DIR_OUT:
			this->comresp(this, w->nid,
			    CORB_SET_PIN_WIDGET_CONTROL,
			    CORB_PWC_OUTPUT, NULL);
			break;
		case PIN_DIR_MIC:
			this->comresp(this, w->nid,
			    CORB_SET_PIN_WIDGET_CONTROL,
			    CORB_PWC_INPUT|CORB_PWC_VREF_80, NULL);
			break;
		}

		if (w->d.pin.cap & COP_PINCAP_EAPD) {
			uint32_t result;
			int err;

			err = this->comresp(this, w->nid,
			    CORB_GET_EAPD_BTL_ENABLE, 0, &result);
			if (err)
				continue;
			result &= 0xff;
			result |= CORB_EAPD_EAPD;
			err = this->comresp(this, w->nid,
			    CORB_SET_EAPD_BTL_ENABLE, result, &result);
			if (err)
				continue;
		}
	}

@


1.67
log
@Many ALC88x codecs have a fifth DAC at NID 0x25 for 7.1+2 multistreaming.
Add this and other missing entries to the pre-defined DAC groups.
Tested with ALC885; other models according to their data sheets.
ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.66 2008/11/19 03:44:14 jakemsr Exp $	*/
d74 4
a77 4
int	azalia_generic_codec_add_dacgroup(codec_t *, int, uint32_t);
int	azalia_generic_codec_find_pin(const codec_t *, int, int, uint32_t);
int	azalia_generic_codec_find_dac(const codec_t *, int, int);

a96 1
int	azalia_alc260_init_dacgroup(codec_t *);
a97 2
int	azalia_alc662_init_dacgroup(codec_t *);
int	azalia_alc861_init_dacgroup(codec_t *);
a98 5
int	azalia_alc880_init_dacgroup(codec_t *);
int	azalia_alc882_init_dacgroup(codec_t *);
int	azalia_alc883_init_dacgroup(codec_t *);
int	azalia_alc885_init_dacgroup(codec_t *);
int	azalia_alc888_init_dacgroup(codec_t *);
a102 1
int	azalia_ad1988_init_dacgroup(codec_t *);
d106 1
a106 1
int	azalia_stac9205_init_dacgroup(codec_t *);
a107 1
int	azalia_stac9221_init_dacgroup(codec_t *);
a109 2
int	azalia_stac9227_init_dacgroup(codec_t *);
int	azalia_stac9271_init_dacgroup(codec_t *);
a131 1
		this->init_dacgroup = azalia_alc260_init_dacgroup;
a140 1
		this->init_dacgroup = azalia_alc662_init_dacgroup;
a143 1
		this->init_dacgroup = azalia_alc861_init_dacgroup;
a146 1
		this->init_dacgroup = azalia_alc880_init_dacgroup;
a150 1
		this->init_dacgroup = azalia_alc882_init_dacgroup;
a155 1
		this->init_dacgroup = azalia_alc883_init_dacgroup;
a159 1
		this->init_dacgroup = azalia_alc885_init_dacgroup;
a163 1
		this->init_dacgroup = azalia_alc888_init_dacgroup;
a180 1
		this->init_dacgroup = azalia_ad1988_init_dacgroup;
a184 1
		this->init_dacgroup = azalia_ad1988_init_dacgroup;
a201 1
		this->init_dacgroup = azalia_stac9227_init_dacgroup;
a204 1
		this->init_dacgroup = azalia_stac9227_init_dacgroup;
a207 1
		this->init_dacgroup = azalia_stac9227_init_dacgroup;
a210 1
		this->init_dacgroup = azalia_stac9271_init_dacgroup;
a213 1
		this->init_dacgroup = azalia_stac9271_init_dacgroup;
a216 1
		this->init_dacgroup = azalia_stac9271_init_dacgroup;
a219 1
		this->init_dacgroup = azalia_stac9271_init_dacgroup;
a253 1
		this->init_dacgroup = azalia_stac9221_init_dacgroup;
a264 1
		this->init_dacgroup = azalia_stac9205_init_dacgroup;
a267 1
		this->init_dacgroup = azalia_stac9205_init_dacgroup;
a270 1
		this->init_dacgroup = azalia_stac9205_init_dacgroup;
a273 1
		this->init_dacgroup = azalia_stac9205_init_dacgroup;
a285 9
	int i, j, assoc, group;

	/*
	 * grouping DACs
	 *   [0] the lowest assoc DACs
	 *   [1] the lowest assoc digital outputs
	 *   [2] the 2nd assoc DACs
	 *      :
	 */
d287 4
a290 29
	for (assoc = 0; assoc < CORB_CD_ASSOCIATION_MAX; assoc++) {
		azalia_generic_codec_add_dacgroup(this, assoc, 0);
		azalia_generic_codec_add_dacgroup(this, assoc, COP_AWCAP_DIGITAL);
	}

	/* find DACs which do not connect with any pins by default */
	FOR_EACH_WIDGET(this, i) {
		boolean_t found;

		if (this->w[i].type != COP_AWTYPE_AUDIO_OUTPUT)
			continue;
		found = FALSE;
		for (group = 0; group < this->dacs.ngroups; group++) {
			for (j = 0; j < this->dacs.groups[group].nconv; j++) {
				if (i == this->dacs.groups[group].conv[j]) {
					found = TRUE;
					group = this->dacs.ngroups;
					break;
				}
			}
		}
		if (found)
			continue;
		if (this->dacs.ngroups >= 32)
			break;
		this->dacs.groups[this->dacs.ngroups].nconv = 1;
		this->dacs.groups[this->dacs.ngroups].conv[0] = i;
		this->dacs.ngroups++;
	}
a292 1
	/* enumerate ADCs */
d294 4
a297 9
	FOR_EACH_WIDGET(this, i) {
		if (this->w[i].type != COP_AWTYPE_AUDIO_INPUT)
			continue;
		this->adcs.groups[this->adcs.ngroups].nconv = 1;
		this->adcs.groups[this->adcs.ngroups].conv[0] = i;
		this->adcs.ngroups++;
		if (this->adcs.ngroups >= 32)
			break;
	}
d299 1
d304 2
a305 1
azalia_generic_codec_add_dacgroup(codec_t *this, int assoc, uint32_t digital)
d307 11
a317 1
	int i, j, n, dac, seq;
d319 6
a324 16
	n = 0;
	for (seq = 0 ; seq < CORB_CD_SEQUENCE_MAX; seq++) {
		i = azalia_generic_codec_find_pin(this, assoc, seq, digital);
		if (i < 0)
			continue;
		dac = azalia_generic_codec_find_dac(this, i, 0);
		if (dac < 0)
			continue;
		/* duplication check */
		for (j = 0; j < n; j++) {
			if (this->dacs.groups[this->dacs.ngroups].conv[j] == dac)
				break;
		}
		if (j < n)	/* this group already has <dac> */
			continue;
		this->dacs.groups[this->dacs.ngroups].conv[n++] = dac;
a325 3
	if (n <= 0)		/* no such DACs */
		return 0;
	this->dacs.groups[this->dacs.ngroups].nconv = n;
d327 54
a380 8
	/* check if the same combination is already registered */
	for (i = 0; i < this->dacs.ngroups; i++) {
		if (n != this->dacs.groups[i].nconv)
			continue;
		for (j = 0; j < n; j++) {
			if (this->dacs.groups[this->dacs.ngroups].conv[j] !=
			    this->dacs.groups[i].conv[j])
				break;
a381 2
		if (j >= n) /* matched */
			return 0;
d383 8
a390 2
	/* found no equivalent group */
	this->dacs.ngroups++;
d395 1
a395 1
azalia_generic_codec_find_pin(const codec_t *this, int assoc, int seq, uint32_t digital)
d397 1
a397 1
	int i;
d399 21
a419 12
	FOR_EACH_WIDGET(this, i) {
		if (this->w[i].type != COP_AWTYPE_PIN_COMPLEX)
			continue;
		if ((this->w[i].d.pin.cap & COP_PINCAP_OUTPUT) == 0)
			continue;
		if ((this->w[i].widgetcap & COP_AWCAP_DIGITAL) != digital)
			continue;
		if (this->w[i].d.pin.association != assoc)
			continue;
		if (this->w[i].d.pin.sequence == seq) {
			return i;
		}
d421 2
a422 1
	return -1;
d426 1
a426 1
azalia_generic_codec_find_dac(const codec_t *this, int index, int depth)
d429 1
a429 1
	int i, j, ret;
d432 2
a433 1
	if (w->type == COP_AWTYPE_AUDIO_OUTPUT)
d435 8
a442 1
	if (++depth > 50) {
a443 9
	}
	if (w->selected >= 0) {
		j = w->connections[w->selected];
		if (VALID_WIDGET_NID(j, this)) {
			ret = azalia_generic_codec_find_dac(this, j, depth);
			if (ret >= 0)
				return ret;
		}
	}
d448 8
a455 3
		ret = azalia_generic_codec_find_dac(this, j, depth);
		if (ret >= 0)
			return ret;
a1804 57
int
azalia_alc260_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 2,
		{{1, {0x02}},	/* analog 2ch */
		 {1, {0x03}}}};	/* digital */
	static const convgroupset_t adcs = {
		-1, 3,
		{{1, {0x04}},	/* analog 2ch */
		 {1, {0x05}},	/* analog 2ch */
		 {1, {0x06}}}};	/* digital */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
 * Realtek ALC662-GR
 * ---------------------------------------------------------------- */

int
azalia_alc662_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 1,
		{{3, {0x02, 0x03, 0x04}}}}; /* analog 6ch */
	static const convgroupset_t adcs = {
		-1, 1,
		{{2, {0x09, 0x08}}}};	/* analog 4ch */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
 * Realtek ALC861
 * ---------------------------------------------------------------- */

int
azalia_alc861_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 2,
		{{4, {0x03, 0x04, 0x05, 0x06}}, /* analog 8ch */
		 {1, {0x07}}}};	/* digital */
	static const convgroupset_t adcs = {
		-1, 1,
		{{1, {0x08}}}};	/* analog 2ch */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

a1820 107
 * Realtek ALC880
 * ---------------------------------------------------------------- */

int
azalia_alc880_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 2,
		{{4, {0x02, 0x03, 0x04, 0x05}}, /* analog 8ch */
		 {1, {0x06}}}};	/* digital */
	static const convgroupset_t adcs = {
		-1, 2,
		{{3, {0x07, 0x08, 0x09}}, /* analog 6ch */
		 {1, {0x0a}}}};	/* digital */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
 * Realtek ALC882
 * ---------------------------------------------------------------- */

int
azalia_alc882_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 2,
		{{5, {0x02, 0x03, 0x04, 0x05, 0x25}}, /* analog 10ch */
		 {1, {0x06}}}};	/* digital */
	static const convgroupset_t adcs = {
		-1, 2,
		{{3, {0x07, 0x08, 0x09}}, /* analog 6ch */
		 {1, {0x0a}}}};	/* digital */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
 * Realtek ALC883
 * ALC882 without adc07 and mix24.
 * ---------------------------------------------------------------- */

int
azalia_alc883_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 2,
		{{5, {0x02, 0x03, 0x04, 0x05, 0x25}}, /* analog 10ch */
		 {1, {0x06}}}}; /* digital */
	static const convgroupset_t adcs = {
		-1, 2,
		{{2, {0x08, 0x09}}, /* analog 4ch */
		 {1, {0x0a}}}}; /* digital */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
 * Realtek ALC885
 * ---------------------------------------------------------------- */

int
azalia_alc885_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 2,
		{{5, {0x02, 0x03, 0x04, 0x05, 0x25}}, /* analog 10ch */
		 {1, {0x06}}}};	/* digital */
	static const convgroupset_t adcs = {
		-1, 2,
		{{3, {0x07, 0x08, 0x09}},	/* analog 6ch */
		 {1, {0x0a}}}};	/* digital */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
 * Realtek ALC888
 * ---------------------------------------------------------------- */

int
azalia_alc888_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 2,
		{{5, {0x02, 0x03, 0x04, 0x05, 0x25}}, /* analog 10ch */
		 {1, {0x06}}}};	/* digital */
		/* ALC888S has another SPDIF-out 0x10 */
	static const convgroupset_t adcs = {
		-1, 2,
		{{2, {0x08, 0x09}},	/* analog 4ch */
		 {1, {0x0a}}}};	/* digital */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
a1968 22
 * Analog Devices AD1988A/AD1988B
 * ---------------------------------------------------------------- */

int
azalia_ad1988_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 3,
		{{4, {0x04, 0x05, 0x06, 0x0a}},	/* analog 8ch */
		 {1, {0x02}},	/* digital */
		 {1, {0x03}}}};	/* another analog */
	static const convgroupset_t adcs = {
		-1, 2,
		{{2, {0x08, 0x09, 0x0f}}, /* analog 6ch */
		 {1, {0x07}}}};	/* digital */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
a2250 56


int
azalia_stac9205_init_dacgroup(codec_t *this)
{
	/* volume knob at nid 24 */
	static const convgroupset_t dacs = {
		-1, 1,
		{{2, {0x10, 0x11}}}};

	/* vols: 1d:1b, 1e:1a */
	static const convgroupset_t adcs = {
		-1, 1,
		{{2, {0x1d, 0x1e}}}};

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

int
azalia_stac9227_init_dacgroup(codec_t *this)
{
	/* volume knob at nid 24 */
	static const convgroupset_t dacs = {
		-1, 1,
		{{4, {0x02, 0x03, 0x04, 0x05}}}};

	/* vols: 07:18, 08:19, 09:1a */
	static const convgroupset_t adcs = {
		-1, 1,
		{{3, {0x07, 0x08, 0x09}}}};

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

int
azalia_stac9271_init_dacgroup(codec_t *this)
{
	/* volume knob at nid 24 */
	static const convgroupset_t dacs = {
		-1, 1,
		{{5, {0x02, 0x03, 0x04, 0x05, 0x06}}}};

	/* vols: 07:18, 08:19, 09:1a */
	static const convgroupset_t adcs = {
		-1, 1,
		{{3, {0x07, 0x08, 0x09}}}};

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

@


1.66
log
@
the jack sense automatic muting code has many problems, including
being the cause of PR5982.  unfortunately, there's no easy and clean
solution to automatic muting.  we can't always rely on the codec
giving us the right information.  people have different preferences
as to what should be muted and what shouldn't.  etc, etc.

so instead, just make the sense state of jacks that support sensing
available through the mixer interface.  this allows for any possible
user configuration and supports all pins that have sense capabilities,
not just headpones.  codecs that use the generic mixer configuration
(which is the plan for all codecs) and have sensing capable pins will
now get a few more read-only mixer items, such as:

outputs.hp_sense=plugged
outputs.mic_sense=unplugged
outputs.line_sense=unplugged

hopefully what they mean is self-explanatory.

based on much discussion with ratchov@@ and Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.65 2008/11/17 00:42:53 jakemsr Exp $	*/
d1901 1
a1901 1
		{{2, {0x08, 0x09}}, /* analog 4ch */
d1918 1
a1918 1
		{{4, {0x02, 0x03, 0x04, 0x05}}, /* analog 8ch */
a1919 1
		/* don't support for 0x25 dac */
d1940 1
a1940 1
		{{4, {0x02, 0x03, 0x04, 0x05}}, /* analog 8ch */
a1941 1

d1961 1
a1961 1
		{{4, {0x02, 0x03, 0x04, 0x05}}, /* analog 8ch */
a1962 1
		/* don't support for 0x25 dac */
d1982 1
a1982 1
		{{4, {0x02, 0x03, 0x04, 0x05}}, /* analog 8ch */
a1983 1
		/* don't support for 0x25 dac */
@


1.65
log
@
- recognize some Conexant codecs.
- recognize several STAC (Sigmatel/IDT) codecs and create converter
groups for the multi-channel capable codecs.
- use the correct name for Sigmatel 7661/7662.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.64 2008/11/17 00:33:35 jakemsr Exp $	*/
d884 29
d1399 9
d1687 4
@


1.64
log
@
use the generic mixer configuration for all Realtek ALC codecs.

adds outputs.master to ALC885 and ALC888 (and probably others that
don't yet have it).  also makes ALC88{2,3} much more useful.

tested by jmc@@ and simon@@ (and myself), thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.63 2008/11/16 23:58:40 jakemsr Exp $	*/
d115 1
d120 2
d208 9
d222 52
d293 15
a307 7
	case 0x83847661:
	case 0x83847662:
		this->name = "Sigmatel STAC9872AK";
		this->init_dacgroup = azalia_stac7661_init_dacgroup;
		this->mixer_init = azalia_stac7661_mixer_init;
		this->get_port = azalia_stac7661_get_port;
		this->set_port = azalia_stac7661_set_port;
d2300 1
d2305 1
d2410 56
@


1.63
log
@
don't create a virtual inputs.dac, as this will be a duplicate of
the real and already existing inputs.dac in most cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.62 2008/11/16 23:53:37 jakemsr Exp $	*/
a98 1
int	azalia_alc260_set_port(codec_t *, mixer_ctrl_t *);
d101 1
a103 3
int	azalia_alc882_mixer_init(codec_t *);
int	azalia_alc882_set_port(codec_t *, mixer_ctrl_t *);
int	azalia_alc882_get_port(codec_t *, mixer_ctrl_t *);
a104 1
int	azalia_alc883_mixer_init(codec_t *);
a141 1
		this->set_port = azalia_alc260_set_port;
d160 1
d165 1
a165 3
		this->mixer_init = azalia_alc882_mixer_init;
		this->get_port = azalia_alc882_get_port;
		this->set_port = azalia_alc882_set_port;
d171 1
a171 3
		this->mixer_init = azalia_alc883_mixer_init;
		this->get_port = azalia_alc882_get_port;
		this->set_port = azalia_alc882_set_port;
d176 1
d181 1
a1691 133
static const mixer_item_t alc260_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, 3}}, 0x08, MI_TARGET_OUTAMP}, /* and 0x09, 0x0a(mono) */
	{{0, {AudioNmaster".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x0f, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x10, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x10, MI_TARGET_PINBOOST},
	{{0, {AudioNmono".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x11, MI_TARGET_OUTAMP},
	{{0, {"mic1.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x12, MI_TARGET_OUTAMP},
	{{0, {"mic1"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_IO}, 0x12, MI_TARGET_PINDIR},
	{{0, {"mic2.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x13, MI_TARGET_OUTAMP},
	{{0, {"mic2"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_IO}, 0x13, MI_TARGET_PINDIR},
	{{0, {"line1.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_OUTAMP},
	{{0, {"line1"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_IO}, 0x14, MI_TARGET_PINDIR},
	{{0, {"line2.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x15, MI_TARGET_OUTAMP},
	{{0, {"line2"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_IO}, 0x15, MI_TARGET_PINDIR},

	{{0, {AudioNdac".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x08, MI_TARGET_INAMP(0)}, /* and 0x09, 0x0a(mono) */
	{{0, {"mic1.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(0)},
	{{0, {"mic1"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x07, MI_TARGET_INAMP(0)},
	{{0, {"mic2.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(1)},
	{{0, {"mic2"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x07, MI_TARGET_INAMP(1)},
	{{0, {"line1.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(2)},
	{{0, {"line1"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, 3}}, 0x07, MI_TARGET_INAMP(2)},
	{{0, {"line2.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(3)},
	{{0, {"line2"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x07, MI_TARGET_INAMP(3)},
	{{0, {AudioNcd".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(4)},
	{{0, {AudioNcd}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x07, MI_TARGET_INAMP(4)},
	{{0, {AudioNspeaker".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(5)},
	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x07, MI_TARGET_INAMP(5)},

	{{0, {"adc04.source"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={5, {{{"mic1"}, 0}, {{"mic2"}, 1}, {{"line1"}, 2},
		     {{"line2"}, 3}, {{AudioNcd}, 4}}}},
	 0x04, MI_TARGET_CONNLIST},
	{{0, {"adc04.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  ENUM_OFFON}, 0x04, MI_TARGET_INAMP(0)},
	{{0, {"adc04"}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD, 0, 0,
	  .un.v={{""}, 2, MIXER_DELTA(35)}}, 0x04, MI_TARGET_INAMP(0)},
	{{0, {"adc05.source"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={6, {{{"mic1"}, 0}, {{"mic2"}, 1}, {{"line1"}, 2},
		     {{"line2"}, 3}, {{AudioNcd}, 4}, {{AudioNmixerout}, 5}}}},
	 0x05, MI_TARGET_CONNLIST},
	{{0, {"adc05.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  ENUM_OFFON}, 0x05, MI_TARGET_INAMP(0)},
	{{0, {"adc05"}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD, 0, 0,
	  .un.v={{""}, 2, MIXER_DELTA(35)}}, 0x05, MI_TARGET_INAMP(0)},

	{{0, {"usingdac"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_DAC},
	{{0, {"usingadc"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={3, {{{"adc04"}, 0}, {{"adc05"}, 1}, {{"digital"}, 2}}}}, 0, MI_TARGET_ADC},
};

static const mixer_item_t alc260_loox_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, 3}}, 0x08, MI_TARGET_OUTAMP}, /* and 0x09, 0x0a(mono) */
	{{0, {AudioNmaster".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x10, MI_TARGET_OUTAMP},
	{{0, {AudioNmaster".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x10, MI_TARGET_PINBOOST},
	{{0, {AudioNheadphone".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_PINBOOST},

	{{0, {AudioNdac".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x08, MI_TARGET_INAMP(0)}, /* and 0x09, 0x0a(mono) */
	{{0, {AudioNmicrophone".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(0)},
	{{0, {AudioNmicrophone}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x07, MI_TARGET_INAMP(0)},
	{{0, {AudioNcd".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(4)},
	{{0, {AudioNcd}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x07, MI_TARGET_INAMP(4)},
	{{0, {AudioNspeaker".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(5)},
	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x07, MI_TARGET_INAMP(5)},

	{{0, {"adc04.source"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={2, {{{AudioNmicrophone}, 0}, {{AudioNcd}, 4}}}}, 0x04, MI_TARGET_CONNLIST},
	{{0, {"adc04.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  ENUM_OFFON}, 0x04, MI_TARGET_INAMP(0)},
	{{0, {"adc04"}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD, 0, 0,
	  .un.v={{""}, 2, MIXER_DELTA(35)}}, 0x04, MI_TARGET_INAMP(0)},
	{{0, {"adc05.source"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={3, {{{AudioNmicrophone}, 0}, {{AudioNcd}, 4}, {{AudioNmixerout}, 5}}}},
	 0x05, MI_TARGET_CONNLIST},
	{{0, {"adc05.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  ENUM_OFFON}, 0x05, MI_TARGET_INAMP(0)},
	{{0, {"adc05"}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD, 0, 0,
	  .un.v={{""}, 2, MIXER_DELTA(35)}}, 0x05, MI_TARGET_INAMP(0)},

	{{0, {"usingdac"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_DAC},
	{{0, {"usingadc"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={3, {{{"adc04"}, 0}, {{"adc05"}, 1}, {{"digital"}, 2}}}}, 0, MI_TARGET_ADC},
};

d1695 2
a1696 22
	const mixer_item_t *mi;
	mixer_ctrl_t mc;

	switch (this->subid) {
	case ALC260_FUJITSU_ID:
		this->nmixers = sizeof(alc260_loox_mixer_items) / sizeof(mixer_item_t);
		mi = alc260_loox_mixer_items;
		break;
	default:
		this->nmixers = sizeof(alc260_mixer_items) / sizeof(mixer_item_t);
		mi = alc260_mixer_items;
	}
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, mi, sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

a1698 13
	mc.dev = -1;		/* no need for generic_mixer_set() */
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 0;		/* mute: off */
	azalia_generic_mixer_set(this, 0x08, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x08, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x09, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x09, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x0a, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x0a, MI_TARGET_INAMP(1), &mc);
	if (this->subid == ALC260_FUJITSU_ID) {
		mc.un.ord = 4;	/* connlist: cd */
		azalia_generic_mixer_set(this, 0x05, MI_TARGET_CONNLIST, &mc);
	}
a1719 48
int
azalia_alc260_set_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;
	mixer_ctrl_t mc2;
	int err;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	if (mc->type != m->devinfo.type)
		return EINVAL;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if (m->nid == 0x08 && m->target == MI_TARGET_OUTAMP) {
		DPRINTF(("%s: hook for outputs.master\n", __func__));
		err = azalia_generic_mixer_set(this, m->nid, m->target, mc);
		if (!err) {
			azalia_generic_mixer_set(this, 0x09, m->target, mc);
			mc2 = *mc;
			mc2.un.value.num_channels = 1;
			mc2.un.value.level[0] = (mc2.un.value.level[0]
			    + mc2.un.value.level[1]) / 2;
			azalia_generic_mixer_set(this, 0x0a, m->target, &mc2);
		}
		return err;
	} else if (m->nid == 0x08 && m->target == MI_TARGET_INAMP(0)) {
		DPRINTF(("%s: hook for inputs.dac.mute\n", __func__));
		err = azalia_generic_mixer_set(this, m->nid, m->target, mc);
		if (!err) {
			azalia_generic_mixer_set(this, 0x09, m->target, mc);
			azalia_generic_mixer_set(this, 0x0a, m->target, mc);
		}
		return err;
	} else if (m->nid == 0x04 &&
		   m->target == MI_TARGET_CONNLIST &&
		   m->devinfo.un.e.num_mem == 2) {
		if (1 <= mc->un.ord && mc->un.ord <= 3)
			return EINVAL;
	} else if (m->nid == 0x05 &&
		   m->target == MI_TARGET_CONNLIST &&
		   m->devinfo.un.e.num_mem == 3) {
		if (1 <= mc->un.ord && mc->un.ord <= 3)
			return EINVAL;
	}
	return azalia_generic_mixer_set(this, m->nid, m->target, mc);
}

d1760 15
a1798 154
static const mixer_item_t alc882_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},

	/* 0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x14,0x15,0x16,0x17 */
	{{0, {"mic1."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(0)},
	{{0, {"mic1"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(0)},
	{{0, {"mic2."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(1)},
	{{0, {"mic2"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(1)},
	{{0, {AudioNline"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(2)},
	{{0, {AudioNline}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(2)},
	{{0, {AudioNcd"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(4)},
	{{0, {AudioNcd}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(4)},
	{{0, {AudioNspeaker"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(5)},
	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(5)},

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0c, MI_TARGET_OUTAMP},
	{{0, {AudioNmaster"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_OUTAMP},
	{{0, {AudioNmaster".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_PINBOOST},
	{{0, {AudioNheadphone"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x1b, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x1b, MI_TARGET_PINBOOST},
	{{0, {AzaliaNfront".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_INAMP(1)},

	{{0, {AudioNsurround}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0d, MI_TARGET_OUTAMP},
	{{0, {AudioNsurround"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x15, MI_TARGET_OUTAMP},
	{{0, {AudioNsurround".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x15, MI_TARGET_PINBOOST},
	{{0, {AudioNsurround".dac.mut"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0d, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround".mixer.m"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0d, MI_TARGET_INAMP(1)},

	{{0, {AzaliaNclfe}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0e, MI_TARGET_OUTAMP},
	{{0, {AzaliaNclfe"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x16, MI_TARGET_OUTAMP},
	{{0, {AzaliaNclfe".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x16, MI_TARGET_PINBOOST},
	{{0, {AzaliaNclfe".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0e, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNclfe".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0e, MI_TARGET_INAMP(1)},

	{{0, {AzaliaNside}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0f, MI_TARGET_OUTAMP},
	{{0, {AzaliaNside"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x17, MI_TARGET_OUTAMP},
	{{0, {AzaliaNside".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x17, MI_TARGET_PINBOOST},
	{{0, {AzaliaNside".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0f, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNside".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0f, MI_TARGET_INAMP(1)},

	/* 0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x14,0x15,0x16,0x17,0xb */
#define ALC882_MIC1	0x001
#define ALC882_MIC2	0x002
#define ALC882_LINE	0x004
#define ALC882_CD	0x010
#define ALC882_BEEP	0x020
#define ALC882_MIX	0x400
#define ALC882_MASK	0x437
	{{0, {AzaliaNfront"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x07, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront"."AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{"mic1"}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x24, -1},
	{{0, {AudioNsurround"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround"."AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{"mic1"}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x23, -1},
	{{0, {AzaliaNclfe"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNclfe}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNclfe"."AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{"mic1"}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x22, -1},

	{{0, {"usingdac"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_DAC},
	{{0, {"usingadc"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_ADC},
};

int
azalia_alc882_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;

	this->nmixers = sizeof(alc882_mixer_items) / sizeof(mixer_item_t);
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, alc882_mixer_items,
	    sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

	azalia_generic_mixer_pin_sense(this);

	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 0;		/* [0] 0x0c */
	azalia_generic_mixer_set(this, 0x14, MI_TARGET_CONNLIST, &mc);
	azalia_generic_mixer_set(this, 0x1b, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 1;		/* [1] 0x0d */
	azalia_generic_mixer_set(this, 0x15, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 2;		/* [2] 0x0e */
	azalia_generic_mixer_set(this, 0x16, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 2;		/* [3] 0x0fb */
	azalia_generic_mixer_set(this, 0x17, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 0;		/* unmute */
	azalia_generic_mixer_set(this, 0x24, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x23, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x22, MI_TARGET_INAMP(2), &mc);
	return 0;
}

a1816 69
int
azalia_alc882_set_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;
	mixer_ctrl_t mc2;
	uint32_t mask, bit;
	int i, err;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	if (mc->type != m->devinfo.type)
		return EINVAL;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if ((m->nid == 0x22 || m->nid == 0x23 || m->nid == 0x24)
	    && m->target == -1) {
		DPRINTF(("%s: hook for record.*.source\n", __func__));
		mc2.dev = -1;
		mc2.type = AUDIO_MIXER_ENUM;
		bit = 1;
		mask = mc->un.mask & ALC882_MASK;
		for (i = 0; i < this->w[m->nid].nconnections && i < 32; i++) {
			mc2.un.ord = (mask & bit) ? 0 : 1;
			err = azalia_generic_mixer_set(this, m->nid,
			    MI_TARGET_INAMP(i), &mc2);
			if (err)
				return err;
			bit = bit << 1;
		}
		return 0;
	}
	return azalia_generic_mixer_set(this, m->nid, m->target, mc);
}

int
azalia_alc882_get_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;
	uint32_t mask, bit, result;
	int i, err;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	mc->type = m->devinfo.type;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if ((m->nid == 0x22 || m->nid == 0x23 || m->nid == 0x24)
	    && m->target == -1) {
		DPRINTF(("%s: hook for record.*.source\n", __func__));
		mask = 0;
		bit = 1;
		for (i = 0; i < this->w[m->nid].nconnections && i < 32; i++) {
			err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
				      CORB_GAGM_INPUT | CORB_GAGM_LEFT |
				      i, &result);
			if (err)
				return err;
			if ((result & CORB_GAGM_MUTE) == 0)
				mask |= bit;
			bit = bit << 1;
		}
		mc->un.mask = mask & ALC882_MASK;
		return 0;
	}
	return azalia_generic_mixer_get(this, m->nid, m->target, mc);
}

a1836 136
	return 0;
}

static const mixer_item_t alc883_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  4, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0c, MI_TARGET_OUTAMP},
	{{0, {AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 3, ENUM_OFFON}, 0x14, MI_TARGET_OUTAMP},

	/* 0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x14,0x15,0x16,0x17 */
	{{0, {AudioNmicrophone"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(0)},
	{{0, {AudioNmicrophone}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(0)},
	{{0, {"mic2."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(1)},
	{{0, {"mic2"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(1)},
	{{0, {AudioNline"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(2)},
	{{0, {AudioNline}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(2)},
	{{0, {AudioNcd"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(4)},
	{{0, {AudioNcd}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(4)},
	{{0, {AudioNspeaker"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(5)},
	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(5)},
	{{0, {AudioNmaster".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_PINBOOST},
	{{0, {AudioNheadphone"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x1b, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x1b, MI_TARGET_PINBOOST},
	{{0, {AzaliaNfront".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_INAMP(1)},
	{{0, {AudioNsurround}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0d, MI_TARGET_OUTAMP},
	{{0, {AudioNsurround"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x15, MI_TARGET_OUTAMP},
	{{0, {AudioNsurround".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x15, MI_TARGET_PINBOOST},
	{{0, {AudioNsurround".dac.mut"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0d, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround".mixer.m"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0d, MI_TARGET_INAMP(1)},

	{{0, {AzaliaNclfe}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0e, MI_TARGET_OUTAMP},
	{{0, {AzaliaNclfe"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x16, MI_TARGET_OUTAMP},
	{{0, {AzaliaNclfe".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x16, MI_TARGET_PINBOOST},
	{{0, {AzaliaNclfe".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0e, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNclfe".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0e, MI_TARGET_INAMP(1)},

	{{0, {AzaliaNside}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0f, MI_TARGET_OUTAMP},
	{{0, {AzaliaNside"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x17, MI_TARGET_OUTAMP},
	{{0, {AzaliaNside".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x17, MI_TARGET_PINBOOST},
	{{0, {AzaliaNside".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0f, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNside".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0f, MI_TARGET_INAMP(1)},

	{{0, {AudioNvolume"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AudioNvolume}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{AudioNmicrophone}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x23, -1},

	{{0, {AudioNsource"2."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AudioNvolume"2"}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AudioNsource"2"}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{AudioNmicrophone}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x22, -1},

	{{0, {"usingdac"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_DAC},
	{{0, {"usingadc"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_ADC},
};

int
azalia_alc883_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;

	this->nmixers = sizeof(alc883_mixer_items) / sizeof(mixer_item_t);
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, alc883_mixer_items,
	    sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

	azalia_generic_mixer_pin_sense(this);

	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 0;		/* [0] 0x0c */
	azalia_generic_mixer_set(this, 0x14, MI_TARGET_CONNLIST, &mc);
	azalia_generic_mixer_set(this, 0x1b, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 1;		/* [1] 0x0d */
	azalia_generic_mixer_set(this, 0x15, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 2;		/* [2] 0x0e */
	azalia_generic_mixer_set(this, 0x16, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 2;		/* [3] 0x0fb */
	azalia_generic_mixer_set(this, 0x17, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 0;		/* unmute */
	azalia_generic_mixer_set(this, 0x23, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x22, MI_TARGET_INAMP(2), &mc);
@


1.62
log
@
expand the usefulness of azalia_generic_mixer_create_virtual by
passing in "preferred" DACs and ADCs.  this will be used to give more
devices "outputs.master" and "record.volume".
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.61 2008/11/16 23:46:52 jakemsr Exp $	*/
d1068 1
a1068 1
	int i, err, mdac, madc, mmaster;
d1076 2
a1077 2
	mdac = madc = mmaster = -1;
	for (i = 0; i < this->nmixers && (mdac < 0 || madc < 0); i++) {
d1081 2
a1082 2
			mdac = mmaster = i;
		if (mdac < 0 && this->dacs.ngroups > 0 && cgdac->nconv > 0) {
d1084 1
a1084 1
				mdac = mmaster = i;
d1094 1
a1094 1
	if (mdac >= 0) {
a1102 10
		this->nmixers++;

		err = azalia_generic_mixer_ensure_capacity(this, this->nmixers + 1);
		if (err)
			return err;
		m = &this->mixers[this->nmixers];
		d = &m->devinfo;
		memcpy(m, &this->mixers[mdac], sizeof(*m));
		d->mixer_class = AZ_CLASS_INPUT;
		snprintf(d->label.name, sizeof(d->label.name), AudioNdac);
@


1.61
log
@
make lists of what widgets are directly connected to DACc and ADCs.
use the lists to figure out what class some widgets belong to.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.60 2008/11/16 23:33:50 jakemsr Exp $	*/
d84 1
a84 1
int	azalia_generic_mixer_create_virtual(codec_t *);
d1062 1
a1062 1
azalia_generic_mixer_create_virtual(codec_t *this)
d1077 1
a1077 1
	for (i = 0; i < this->nmixers; i++) {
d1080 2
d1086 2
d1137 1
a1137 1
	azalia_generic_mixer_create_virtual(this);
@


1.60
log
@'.' is a special character in mixer item names.  it's the separator
between class, device and qualifier.

replace use of '.' with '_' where it's not really a separator.

idea from/ok ratchov@@

warning: if you have a mixerctl.conf(5), it will need to be updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.59 2008/11/14 22:03:39 jakemsr Exp $	*/
d422 5
d491 57
d589 3
a591 5
			if (w->type == COP_AWTYPE_AUDIO_MIXER)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else if (w->type == COP_AWTYPE_AUDIO_SELECTOR)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else if (w->type == COP_AWTYPE_PIN_COMPLEX)
d613 3
a615 5
			if (w->type == COP_AWTYPE_AUDIO_MIXER)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else if (w->type == COP_AWTYPE_AUDIO_SELECTOR)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else if (w->type == COP_AWTYPE_PIN_COMPLEX)
d669 7
d728 7
@


1.59
log
@oops.  not yet. sorry for the noise.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.58 2008/11/14 21:58:11 jakemsr Exp $	*/
d491 1
a491 1
			    "%s.source", w->name);
d525 1
a525 1
			    "%s.mute", w->name);
d576 1
a576 1
				    "%s.mute", w->name);
d604 1
a604 1
					    "%s.%s.mute", w->name,
d656 1
a656 1
					    "%s.%s", w->name,
d679 1
a679 1
			    "%s.dir", w->name);
d698 1
a698 1
			    "%s.boost", w->name);
d716 1
a716 1
			    "%s.eapd", w->name);
@


1.58
log
@* readability improvement in azalia_codec_connect_stream
* DEBUG cleanup

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.57 2008/11/05 01:14:01 jakemsr Exp $	*/
d84 1
a84 1
int	azalia_generic_mixer_create_virtual(codec_t *, int, int);
d105 2
d170 2
d178 2
d990 1
a990 1
azalia_generic_mixer_create_virtual(codec_t *this, int pdac, int padc)
d1005 1
a1005 1
	for (i = 0; i < this->nmixers && (mdac < 0 || madc < 0); i++) {
a1007 2
		if (pdac >= 0 && this->mixers[i].nid == pdac)
			mdac = mmaster = i;
a1011 2
		if (padc >= 0 && this->mixers[i].nid == padc)
			madc = i;
d1061 1
a1061 1
	azalia_generic_mixer_create_virtual(this, -1, -1);
d1938 154
d2111 1
a2111 1
azalia_alc882_mixer_init(codec_t *this)
d2113 4
a2116 3
	azalia_generic_mixer_init(this);
	azalia_generic_mixer_create_virtual(this, 0x0c, 0x07);
	azalia_generic_mixer_pin_sense(this);
d2118 25
a2142 1
	return 0;
d2145 33
d2202 100
d2305 14
a2318 2
	azalia_generic_mixer_init(this);
	azalia_generic_mixer_create_virtual(this, 0x0c, 0x08);
d2321 14
@


1.57
log
@
* remove two custom unsolicited event handlers in favor of generic
jack sense handling.  makes azalia_generic_mixer_pinctrl useless, so zap it.
* azalia_generic_mixer_pin_sense works well enough to not need guessing
of pin direction in azalia_generic_mixer_default.

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.56 2008/11/04 07:58:43 jakemsr Exp $	*/
d84 1
a84 1
int	azalia_generic_mixer_create_virtual(codec_t *);
a104 2
int	azalia_alc882_set_port(codec_t *, mixer_ctrl_t *);
int	azalia_alc882_get_port(codec_t *, mixer_ctrl_t *);
a167 2
		this->get_port = azalia_alc882_get_port;
		this->set_port = azalia_alc882_set_port;
a173 2
		this->get_port = azalia_alc882_get_port;
		this->set_port = azalia_alc882_set_port;
d984 1
a984 1
azalia_generic_mixer_create_virtual(codec_t *this)
d999 1
a999 1
	for (i = 0; i < this->nmixers; i++) {
d1002 2
d1008 2
d1059 1
a1059 1
	azalia_generic_mixer_create_virtual(this);
a1935 154
static const mixer_item_t alc882_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},

	/* 0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x14,0x15,0x16,0x17 */
	{{0, {"mic1."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(0)},
	{{0, {"mic1"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(0)},
	{{0, {"mic2."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(1)},
	{{0, {"mic2"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(1)},
	{{0, {AudioNline"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(2)},
	{{0, {AudioNline}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(2)},
	{{0, {AudioNcd"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(4)},
	{{0, {AudioNcd}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(4)},
	{{0, {AudioNspeaker"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(5)},
	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(5)},

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0c, MI_TARGET_OUTAMP},
	{{0, {AudioNmaster"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_OUTAMP},
	{{0, {AudioNmaster".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_PINBOOST},
	{{0, {AudioNheadphone"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x1b, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x1b, MI_TARGET_PINBOOST},
	{{0, {AzaliaNfront".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_INAMP(1)},

	{{0, {AudioNsurround}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0d, MI_TARGET_OUTAMP},
	{{0, {AudioNsurround"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x15, MI_TARGET_OUTAMP},
	{{0, {AudioNsurround".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x15, MI_TARGET_PINBOOST},
	{{0, {AudioNsurround".dac.mut"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0d, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround".mixer.m"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0d, MI_TARGET_INAMP(1)},

	{{0, {AzaliaNclfe}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0e, MI_TARGET_OUTAMP},
	{{0, {AzaliaNclfe"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x16, MI_TARGET_OUTAMP},
	{{0, {AzaliaNclfe".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x16, MI_TARGET_PINBOOST},
	{{0, {AzaliaNclfe".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0e, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNclfe".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0e, MI_TARGET_INAMP(1)},

	{{0, {AzaliaNside}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0f, MI_TARGET_OUTAMP},
	{{0, {AzaliaNside"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x17, MI_TARGET_OUTAMP},
	{{0, {AzaliaNside".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x17, MI_TARGET_PINBOOST},
	{{0, {AzaliaNside".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0f, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNside".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0f, MI_TARGET_INAMP(1)},

	/* 0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x14,0x15,0x16,0x17,0xb */
#define ALC882_MIC1	0x001
#define ALC882_MIC2	0x002
#define ALC882_LINE	0x004
#define ALC882_CD	0x010
#define ALC882_BEEP	0x020
#define ALC882_MIX	0x400
#define ALC882_MASK	0x437
	{{0, {AzaliaNfront"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x07, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x07, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront"."AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{"mic1"}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x24, -1},
	{{0, {AudioNsurround"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround"."AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{"mic1"}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x23, -1},
	{{0, {AzaliaNclfe"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNclfe}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNclfe"."AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{"mic1"}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x22, -1},

	{{0, {"usingdac"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_DAC},
	{{0, {"usingadc"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_ADC},
};

int
azalia_alc882_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;

	this->nmixers = sizeof(alc882_mixer_items) / sizeof(mixer_item_t);
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, alc882_mixer_items,
	    sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

	azalia_generic_mixer_pin_sense(this);

	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 0;		/* [0] 0x0c */
	azalia_generic_mixer_set(this, 0x14, MI_TARGET_CONNLIST, &mc);
	azalia_generic_mixer_set(this, 0x1b, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 1;		/* [1] 0x0d */
	azalia_generic_mixer_set(this, 0x15, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 2;		/* [2] 0x0e */
	azalia_generic_mixer_set(this, 0x16, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 2;		/* [3] 0x0fb */
	azalia_generic_mixer_set(this, 0x17, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 0;		/* unmute */
	azalia_generic_mixer_set(this, 0x24, MI_TARGET_INAMP(0), &mc);
	azalia_generic_mixer_set(this, 0x23, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x22, MI_TARGET_INAMP(2), &mc);
	return 0;
}

d1955 1
a1955 1
azalia_alc882_set_port(codec_t *this, mixer_ctrl_t *mc)
d1957 3
a1959 4
	const mixer_item_t *m;
	mixer_ctrl_t mc2;
	uint32_t mask, bit;
	int i, err;
d1961 1
a1961 25
	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	if (mc->type != m->devinfo.type)
		return EINVAL;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if ((m->nid == 0x22 || m->nid == 0x23 || m->nid == 0x24)
	    && m->target == -1) {
		DPRINTF(("%s: hook for record.*.source\n", __func__));
		mc2.dev = -1;
		mc2.type = AUDIO_MIXER_ENUM;
		bit = 1;
		mask = mc->un.mask & ALC882_MASK;
		for (i = 0; i < this->w[m->nid].nconnections && i < 32; i++) {
			mc2.un.ord = (mask & bit) ? 0 : 1;
			err = azalia_generic_mixer_set(this, m->nid,
			    MI_TARGET_INAMP(i), &mc2);
			if (err)
				return err;
			bit = bit << 1;
		}
		return 0;
	}
	return azalia_generic_mixer_set(this, m->nid, m->target, mc);
a1963 33
int
azalia_alc882_get_port(codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;
	uint32_t mask, bit, result;
	int i, err;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	mc->type = m->devinfo.type;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;
	if ((m->nid == 0x22 || m->nid == 0x23 || m->nid == 0x24)
	    && m->target == -1) {
		DPRINTF(("%s: hook for record.*.source\n", __func__));
		mask = 0;
		bit = 1;
		for (i = 0; i < this->w[m->nid].nconnections && i < 32; i++) {
			err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
				      CORB_GAGM_INPUT | CORB_GAGM_LEFT |
				      i, &result);
			if (err)
				return err;
			if ((result & CORB_GAGM_MUTE) == 0)
				mask |= bit;
			bit = bit << 1;
		}
		mc->un.mask = mask & ALC882_MASK;
		return 0;
	}
	return azalia_generic_mixer_get(this, m->nid, m->target, mc);
}
a1987 100
static const mixer_item_t alc883_mixer_items[] = {
	{{AZ_CLASS_INPUT, {AudioCinputs}, AUDIO_MIXER_CLASS, AZ_CLASS_INPUT, 0, 0}, 0},
	{{AZ_CLASS_OUTPUT, {AudioCoutputs}, AUDIO_MIXER_CLASS, AZ_CLASS_OUTPUT, 0, 0}, 0},
	{{AZ_CLASS_RECORD, {AudioCrecord}, AUDIO_MIXER_CLASS, AZ_CLASS_RECORD, 0, 0}, 0},

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  4, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0c, MI_TARGET_OUTAMP},
	{{0, {AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 3, ENUM_OFFON}, 0x14, MI_TARGET_OUTAMP},

	/* 0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x14,0x15,0x16,0x17 */
	{{0, {AudioNmicrophone"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(0)},
	{{0, {AudioNmicrophone}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(0)},
	{{0, {"mic2."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(1)},
	{{0, {"mic2"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(1)},
	{{0, {AudioNline"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(2)},
	{{0, {AudioNline}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(2)},
	{{0, {AudioNcd"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(4)},
	{{0, {AudioNcd}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(4)},
	{{0, {AudioNspeaker"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_INAMP(5)},
	{{0, {AudioNspeaker}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_INAMP(5)},
	{{0, {AudioNmaster".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_PINBOOST},
	{{0, {AudioNheadphone"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x1b, MI_TARGET_OUTAMP},
	{{0, {AudioNheadphone".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x1b, MI_TARGET_PINBOOST},
	{{0, {AzaliaNfront".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNfront".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0c, MI_TARGET_INAMP(1)},
	{{0, {AudioNsurround}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0d, MI_TARGET_OUTAMP},
	{{0, {AudioNsurround"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x15, MI_TARGET_OUTAMP},
	{{0, {AudioNsurround".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x15, MI_TARGET_PINBOOST},
	{{0, {AudioNsurround".dac.mut"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0d, MI_TARGET_INAMP(0)},
	{{0, {AudioNsurround".mixer.m"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0d, MI_TARGET_INAMP(1)},

	{{0, {AzaliaNclfe}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0e, MI_TARGET_OUTAMP},
	{{0, {AzaliaNclfe"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x16, MI_TARGET_OUTAMP},
	{{0, {AzaliaNclfe".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x16, MI_TARGET_PINBOOST},
	{{0, {AzaliaNclfe".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0e, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNclfe".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0e, MI_TARGET_INAMP(1)},

	{{0, {AzaliaNside}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0f, MI_TARGET_OUTAMP},
	{{0, {AzaliaNside"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x17, MI_TARGET_OUTAMP},
	{{0, {AzaliaNside".boost"}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x17, MI_TARGET_PINBOOST},
	{{0, {AzaliaNside".dac.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0f, MI_TARGET_INAMP(0)},
	{{0, {AzaliaNside".mixer.mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, ENUM_OFFON}, 0x0f, MI_TARGET_INAMP(1)},

	{{0, {AudioNvolume"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AudioNvolume}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x08, MI_TARGET_INAMP(0)},
	{{0, {AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{AudioNmicrophone}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x23, -1},

	{{0, {AudioNsource"2."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
	  0, 0, ENUM_OFFON}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AudioNvolume"2"}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x09, MI_TARGET_INAMP(0)},
	{{0, {AudioNsource"2"}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{AudioNmicrophone}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
			   {{AudioNline}, ALC882_LINE}, {{AudioNcd}, ALC882_CD},
			   {{AudioNspeaker}, ALC882_BEEP},
			   {{AudioNmixerout}, ALC882_MIX}}}}, 0x22, -1},

	{{0, {"usingdac"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_DAC},
	{{0, {"usingadc"}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD, 0, 0,
	  .un.e={2, {{{"analog"}, 0}, {{"digital"}, 1}}}}, 0, MI_TARGET_ADC},
};

d1991 2
a1992 14
	mixer_ctrl_t mc;

	this->nmixers = sizeof(alc883_mixer_items) / sizeof(mixer_item_t);
	this->mixers = malloc(sizeof(mixer_item_t) * this->nmixers,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this), __func__);
		return ENOMEM;
	}
	memcpy(this->mixers, alc883_mixer_items,
	    sizeof(mixer_item_t) * this->nmixers);
	azalia_generic_mixer_fix_indexes(this);
	azalia_generic_mixer_default(this);

a1994 14
	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 0;		/* [0] 0x0c */
	azalia_generic_mixer_set(this, 0x14, MI_TARGET_CONNLIST, &mc);
	azalia_generic_mixer_set(this, 0x1b, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 1;		/* [1] 0x0d */
	azalia_generic_mixer_set(this, 0x15, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 2;		/* [2] 0x0e */
	azalia_generic_mixer_set(this, 0x16, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 2;		/* [3] 0x0fb */
	azalia_generic_mixer_set(this, 0x17, MI_TARGET_CONNLIST, &mc);
	mc.un.ord = 0;		/* unmute */
	azalia_generic_mixer_set(this, 0x23, MI_TARGET_INAMP(1), &mc);
	azalia_generic_mixer_set(this, 0x22, MI_TARGET_INAMP(2), &mc);
@


1.56
log
@
volume scaling/setting cleanup:

* MAX_VOLUME_255 has been defined for ages.  remove this define
and the code that was only being used when this wasn't defined.
* remove azalia_generic_mixer_{max,validate_value} since they
are pointless.
* when setting both stereo channels to the same level, just set
the right channel level to the left channel level instead of
calculating both separately.

from Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.55 2008/10/28 21:14:19 brad Exp $	*/
a88 1
int	azalia_generic_mixer_pinctrl(codec_t *, nid_t, uint32_t);
a118 1
int	azalia_stac9200_unsol_event(codec_t *, int);
a122 1
int	azalia_stac9221_apple_unsol_event(codec_t *, int);
a221 2
		if (this->subid == STAC9221_APPLE_ID)
			this->unsol_event = azalia_stac9221_apple_unsol_event;
a230 1
		this->unsol_event = azalia_stac9200_unsol_event;
a858 15
	/*
	 * For bidirectional pins, make the default `output'
	 */
	for (i = 0; i < this->nmixers; i++) {
		mixer_ctrl_t mc;

		m = &this->mixers[i];
		if (m->target != MI_TARGET_PINDIR)
			continue;
		mc.dev = i;
		mc.type = AUDIO_MIXER_ENUM;
		mc.un.ord = 1;
		azalia_generic_mixer_set(this, m->nid, m->target, &mc);
	}

a1526 15
int
azalia_generic_mixer_pinctrl(codec_t *this, nid_t nid, uint32_t value)
{
	int err;
	uint32_t result;

	err = this->comresp(this, nid, CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
	if (err)
		return err;
	result &= ~(CORB_PWC_OUTPUT | CORB_PWC_INPUT);
	result |= value & (CORB_PWC_OUTPUT | CORB_PWC_INPUT);
	return this->comresp(this, nid,
	    CORB_SET_PIN_WIDGET_CONTROL, result, NULL);
}

a2719 39

#define STAC9200_EVENT_HP	0
#define STAC9200_NID_HP		0x0d
#define STAC9200_NID_SPEAKER	0x0e

	/* register hp unsolicited event */
	this->comresp(this, STAC9200_NID_HP, 
	    CORB_SET_UNSOLICITED_RESPONSE,
	    CORB_UNSOL_ENABLE | STAC9200_EVENT_HP, NULL);

	azalia_stac9200_unsol_event(this, STAC9200_EVENT_HP);

	return 0;
}
int
azalia_stac9200_unsol_event(codec_t *this, int tag)
{
	int err;
	uint32_t value;

	switch (tag) {
	case STAC9200_EVENT_HP:
		err = this->comresp(this, STAC9200_NID_HP,
		    CORB_GET_PIN_SENSE, 0, &value);
		if (err)
			break;
		if (value & CORB_PS_PRESENCE) {
			DPRINTF(("%s: headphone inserted\n", __func__));
			azalia_generic_mixer_pinctrl(this, 
			    STAC9200_NID_SPEAKER, 0);
		} else {
			DPRINTF(("%s: headphone pulled\n", __func__));
			azalia_generic_mixer_pinctrl(this, 
			    STAC9200_NID_SPEAKER, CORB_PWC_OUTPUT);
		}
		break;
	default:
		DPRINTF(("%s: unknown tag: %d\n", __func__, tag));
	}
a2787 12
	if (this->subid == STAC9221_APPLE_ID) {
#define APPLE_EVENT_HP         1
#define APPLE_NID_HP           0x0a
#define APPLE_NID_SPEAKER      0x0c
#define APPLE_NID_LINE         0x0d

		/* register hp unsolicited event */
		this->comresp(this, APPLE_NID_HP, CORB_SET_UNSOLICITED_RESPONSE,
		    CORB_UNSOL_ENABLE | APPLE_EVENT_HP, NULL);

		azalia_stac9221_apple_unsol_event(this, APPLE_EVENT_HP);
	}
a2832 32
}

int
azalia_stac9221_apple_unsol_event(codec_t *this, int tag)
{
	int err;
	uint32_t value;

	switch (tag) {
	case APPLE_EVENT_HP:
		err = this->comresp(this, APPLE_NID_HP,
		    CORB_GET_PIN_SENSE, 0, &value);
		if (err)
			break;
		if (value & CORB_PS_PRESENCE) {
			DPRINTF(("%s: headphone inserted\n", __func__));
			azalia_generic_mixer_pinctrl(this,
			    APPLE_NID_SPEAKER, 0);
			azalia_generic_mixer_pinctrl(this,
			    APPLE_NID_LINE, 0);
		} else {
			DPRINTF(("%s: headphone pulled\n", __func__));
			azalia_generic_mixer_pinctrl(this,
			    APPLE_NID_SPEAKER, CORB_PWC_OUTPUT);
			azalia_generic_mixer_pinctrl(this,
			    APPLE_NID_LINE, CORB_PWC_OUTPUT);
		}
		break;
	default:
		DPRINTF(("%s: unknown tag: %d\n", __func__, tag));
	}
        return 0;
@


1.55
log
@Add the MacBookPro4,1 to the list of systems with GPIO quirks and
needs adjustment. Allows the integrated speakers to work.

from Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.54 2008/10/27 02:55:09 jakemsr Exp $	*/
d41 2
a42 5
#ifdef MAX_VOLUME_255
# define MIXER_DELTA(n)	(AUDIO_MAX_GAIN / (n))
#else
# define MIXER_DELTA(n)	(1)
#endif
a93 3
uint32_t azalia_generic_mixer_max(const codec_t *, nid_t, int);
boolean_t azalia_generic_mixer_validate_value
	(const codec_t *, nid_t, int, u_char);
a568 1
#ifdef MAX_VOLUME_255
a569 4
#else
			snprintf(d->un.v.units.name, sizeof(d->un.v.units.name),
			    "0.25x%ddB", COP_AMPCAP_STEPSIZE(w->outamp_cap)+1);
#endif
a644 1
#ifdef MAX_VOLUME_255
a645 5
#else
				snprintf(d->un.v.units.name,
				    sizeof(d->un.v.units.name), "0.25x%ddB",
				    COP_AMPCAP_STEPSIZE(w->inamp_cap)+1);
#endif
a670 1
#ifdef MAX_VOLUME_255
a671 5
#else
					snprintf(d->un.v.units.name,
					    sizeof(d->un.v.units.name), "0.25x%ddB",
					    COP_AMPCAP_STEPSIZE(w->inamp_cap)+1);
#endif
d898 1
a898 1
			mc.un.value.level[1] = AUDIO_MAX_GAIN / 2;
a1312 3
		if (!azalia_generic_mixer_validate_value(this, nid, target,
		    mc->un.value.level[0]))
			return EINVAL;
a1329 3
			if (!azalia_generic_mixer_validate_value(this, nid, target,
			    mc->un.value.level[1]))
				return EINVAL;
a1382 3
		if (!azalia_generic_mixer_validate_value(this, nid, target,
		    mc->un.value.level[0]))
			return EINVAL;
a1397 3
			if (!azalia_generic_mixer_validate_value(this, nid, target,
			    mc->un.value.level[1]))
				return EINVAL;
a1490 3
		if (!azalia_generic_mixer_validate_value(this, nid,
		    target, mc->un.value.level[0]))
			return EINVAL;
a1566 1
#ifdef MAX_VOLUME_255
a1583 3
#else
	return dv;
#endif
a1589 1
#ifdef MAX_VOLUME_255
a1606 32
#else
	return uv;
#endif
}

uint32_t
azalia_generic_mixer_max(const codec_t *this, nid_t nid, int target)
{
#ifdef MAX_VOLUME_255
	return AUDIO_MAX_GAIN;
#else
	uint32_t dmax;

	if (IS_MI_TARGET_INAMP(target))
		dmax = COP_AMPCAP_NUMSTEPS(this->w[nid].inamp_cap);
	else if (target == MI_TARGET_OUTAMP)
		dmax = COP_AMPCAP_NUMSTEPS(this->w[nid].outamp_cap);
	else if (target == MI_TARGET_VOLUME)
		dmax = COP_VKCAP_NUMSTEPS(this->w[nid].d.volume.cap);
	return dmax;
#endif
}

boolean_t
azalia_generic_mixer_validate_value(const codec_t *this, nid_t nid, int target,
    u_char uv)
{
#ifdef MAX_VOLUME_255
	return TRUE;
#else
	return uv <= generic_mixer_max(this, nid, target);
#endif
d2753 1
a2753 1
	mc.un.value.level[0] = azalia_generic_mixer_max(this, 0x0c, MI_TARGET_OUTAMP);
@


1.54
log
@
for the AD1984 codec, connect headphones to a proper DAC.

tested by danh@@ and Aaron Stellman on Thinkpad T61.

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.53 2008/10/25 02:19:02 jakemsr Exp $	*/
d59 2
a60 2
#define	ALC880_ASUS_M5200	0x19931043
#define	ALC880_ASUS_A7M		0x13231043
d69 2
a70 1
#define	SIGMATEL_STAC9221	0x83847680
d1020 1
@


1.53
log
@Add proper DAC/ADC grouping for AD1984 (from NetBSD).

This fixes fallout for AD1984 revealed by recent azalia.c
changes and reported on misc@@.

While here:

* move gpio_unmute to more logical place,
* remove code ifdef'ed and unused for ages.


from Alexey Suslikov, thanks


Index: sys/dev/pci/azalia_codec.c
===================================================================
RCS file: /cvs/src/sys/dev/pci/azalia_codec.c,v
retrieving revision 1.52
diff -u -r1.52 azalia_codec.c
--- sys/dev/pci/azalia_codec.c	23 Oct 2008 02:23:04 -0000	1.52
+++ sys/dev/pci/azalia_codec.c	24 Oct 2008 17:29:36 -0000
@@@@ -98,6 +98,7 @@@@
 	(const codec_t *, nid_t, int, u_char);
 int	azalia_generic_set_port(codec_t *, mixer_ctrl_t *);
 int	azalia_generic_get_port(codec_t *, mixer_ctrl_t *);
+int	azalia_gpio_unmute(codec_t *, int);

 int	azalia_alc260_init_dacgroup(codec_t *);
 int	azalia_alc260_mixer_init(codec_t *);
@@@@ -127,7 +128,6 @@@@
 int	azalia_stac9221_set_port(codec_t *, mixer_ctrl_t *);
 int	azalia_stac9221_get_port(codec_t *, mixer_ctrl_t *);
 int	azalia_stac9221_apple_unsol_event(codec_t *, int);
-int	azalia_gpio_unmute(codec_t *, int);
 int	azalia_stac7661_init_dacgroup(codec_t *);
 int	azalia_stac7661_mixer_init(codec_t *);
 int	azalia_stac7661_set_port(codec_t *, mixer_ctrl_t *);
@@@@ -1708,6 +1708,26 @@@@
 	return azalia_generic_mixer_get(this, m->nid, m->target, mc);
 }

+int
+azalia_gpio_unmute(codec_t *this, int pin)
+{
+	uint32_t data, mask, dir;
+
+	this->comresp(this, this->audiofunc, CORB_GET_GPIO_DATA, 0, &data);
+	this->comresp(this, this->audiofunc, CORB_GET_GPIO_ENABLE_MASK, 0, &mask);
+	this->comresp(this, this->audiofunc, CORB_GET_GPIO_DIRECTION, 0, &dir);
+
+	data |= 1 << pin;
+	mask |= 1 << pin;
+	dir |= 1 << pin;
+
+	this->comresp(this, this->audiofunc, CORB_SET_GPIO_ENABLE_MASK, mask, NULL);
+	this->comresp(this, this->audiofunc, CORB_SET_GPIO_DIRECTION, dir, NULL);
+	DELAY(1000);
+	this->comresp(this, this->audiofunc, CORB_SET_GPIO_DATA, data, NULL);
+
+	return 0;
+}

 /* ----------------------------------------------------------------
  * Realtek ALC260
@@@@ -2181,18 +2201,11 @@@@
 int
 azalia_alc882_init_dacgroup(codec_t *this)
 {
-#if 0
-	static const convgroupset_t dacs = {
-		-1, 3,
-		{{4, {0x02, 0x03, 0x04, 0x05}}, /* analog 8ch */
-		 {1, {0x06}},	/* digital */
-		 {1, {0x25}}}};	/* another analog */
-#else
 	static const convgroupset_t dacs = {
 		-1, 2,
 		{{4, {0x02, 0x03, 0x04, 0x05}}, /* analog 8ch */
 		 {1, {0x06}}}};	/* digital */
-#endif
+		/* don't support for 0x25 dac */
 	static const convgroupset_t adcs = {
 		-1, 2,
 		{{3, {0x07, 0x08, 0x09}}, /* analog 6ch */
@@@@ -2484,13 +2497,14 @@@@
 azalia_ad1984_init_dacgroup(codec_t *this)
 {
 	static const convgroupset_t dacs = {
-		-1, 1,
-		{{2, {0x03, 0x04}}}};
-
+		-1, 2,
+		{{2, {0x04, 0x03}},	/* analog 4ch */
+		 {1, {0x02}}}};		/* digital */
 	static const convgroupset_t adcs = {
-		-1, 1,
-		{{1, {0x08}}}};
-
+		-1, 3,
+		{{2, {0x08, 0x09}},	/* analog 4ch */
+		 {1, {0x06}},		/* digital */
+		 {1, {0x05}}}}; 	/* digital */
 	this->dacs = dacs;
 	this->adcs = adcs;
 	return 0;
@@@@ -3006,27 +3020,6 @@@@
 		DPRINTF(("%s: unknown tag: %d\n", __func__, tag));
 	}
         return 0;
-}
-
-int
-azalia_gpio_unmute(codec_t *this, int pin)
-{
-	uint32_t data, mask, dir;
-
-	this->comresp(this, this->audiofunc, CORB_GET_GPIO_DATA, 0, &data);
-	this->comresp(this, this->audiofunc, CORB_GET_GPIO_ENABLE_MASK, 0, &mask);
-	this->comresp(this, this->audiofunc, CORB_GET_GPIO_DIRECTION, 0, &dir);
-
-	data |= 1 << pin;
-	mask |= 1 << pin;
-	dir |= 1 << pin;
-
-	this->comresp(this, this->audiofunc, CORB_SET_GPIO_ENABLE_MASK, mask, NULL);
-	this->comresp(this, this->audiofunc, CORB_SET_GPIO_DIRECTION, dir, NULL);
-	DELAY(1000);
-	this->comresp(this, this->audiofunc, CORB_SET_GPIO_DATA, data, NULL);
-
-	return 0;
 }

 /* ----------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.52 2008/10/23 02:23:04 jakemsr Exp $	*/
d2577 2
@


1.52
log
@
- new function azalia_generic_mixer_pin_sense - configures pin direction,
enables EAPD when needed
- new function azalia_generic_mixer_create_virtual - creates some
well known mixer controls, such as outputs.master
- use the two new functions when setting up a codec with the generic
codec support
- remove explicit pindir manipulations (azalia_generic_mixer_pin_sense
does this automatically now)
- add some GPIO quirks (from FreeBSD's snd_hda)
- move all GPIO quirks into one place
- add DAC/ADC groupings and support for several more codecs using the
generic codec support
- correct Sigmatel STAC9872AK name
- initialize unsol_event to NULL by default

DAC/ADC grouping and create_virtual/pin_sense code from NetBSD.
GPIO quirks from FreeBSD.

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.51 2008/10/16 19:16:58 jakemsr Exp $	*/
d101 1
a130 1
int	azalia_gpio_unmute(codec_t *, int);
d1711 20
a2203 7
#if 0
	static const convgroupset_t dacs = {
		-1, 3,
		{{4, {0x02, 0x03, 0x04, 0x05}}, /* analog 8ch */
		 {1, {0x06}},	/* digital */
		 {1, {0x25}}}};	/* another analog */
#else
d2208 1
a2208 1
#endif
d2500 3
a2502 3
		-1, 1,
		{{2, {0x03, 0x04}}}};

d2504 4
a2507 3
		-1, 1,
		{{1, {0x08}}}};

a3022 21
}

int
azalia_gpio_unmute(codec_t *this, int pin)
{
	uint32_t data, mask, dir;

	this->comresp(this, this->audiofunc, CORB_GET_GPIO_DATA, 0, &data);
	this->comresp(this, this->audiofunc, CORB_GET_GPIO_ENABLE_MASK, 0, &mask);
	this->comresp(this, this->audiofunc, CORB_GET_GPIO_DIRECTION, 0, &dir);

	data |= 1 << pin;
	mask |= 1 << pin;
	dir |= 1 << pin;

	this->comresp(this, this->audiofunc, CORB_SET_GPIO_ENABLE_MASK, mask, NULL);
	this->comresp(this, this->audiofunc, CORB_SET_GPIO_DIRECTION, dir, NULL);
	DELAY(1000);
	this->comresp(this, this->audiofunc, CORB_SET_GPIO_DATA, data, NULL);

	return 0;
@


1.51
log
@
Add S/PDIF support. From NetBSD.

Clean up a little while here.

from Alexey Suslikov, thanks

tested by several as part of a larger diff, thanks also
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.50 2008/10/16 02:13:12 jakemsr Exp $	*/
d56 10
d67 3
d71 3
d81 2
d85 2
d105 2
d114 2
d120 1
d144 1
a144 1
	this->mixer_init = azalia_generic_mixer_init;
d148 1
d156 14
d189 8
d209 10
d248 1
a248 1
		this->name = "Sigmatel 83847661";
d929 181
d1879 2
a1882 8
	mc.un.ord = 1;		/* pindir: output */
	azalia_generic_mixer_set(this, 0x0f, MI_TARGET_PINDIR, &mc); /* lineout */
	azalia_generic_mixer_set(this, 0x10, MI_TARGET_PINDIR, &mc); /* headphones */
	mc.un.ord = 0;		/* pindir: input */
	azalia_generic_mixer_set(this, 0x12, MI_TARGET_PINDIR, &mc); /* mic1 */
	azalia_generic_mixer_set(this, 0x13, MI_TARGET_PINDIR, &mc); /* mic2 */
	azalia_generic_mixer_set(this, 0x14, MI_TARGET_PINDIR, &mc); /* line1 */
	azalia_generic_mixer_set(this, 0x15, MI_TARGET_PINDIR, &mc); /* line2 */
a1890 2
		mc.un.ord = 1;	/* pindir: output */
		azalia_generic_mixer_set(this, 0x14, MI_TARGET_PINDIR, &mc); /* line1 */
d1964 39
d2161 2
a2164 6
	mc.un.ord = 1;		/* pindir: output */
	azalia_generic_mixer_set(this, 0x14, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x1b, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x15, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x16, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x17, MI_TARGET_PINDIR, &mc);
a2173 7

	mc.un.ord = 0;		/* pindir: input */
	azalia_generic_mixer_set(this, 0x18, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x19, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x1a, MI_TARGET_PINDIR, &mc);
	/* XXX: inamp for 18/19/1a */

d2415 2
a2416 4
	if (this->subid == ALC883_ACER_ID) {
		azalia_gpio_unmute(this, 0);
		azalia_gpio_unmute(this, 1);
	}
a2418 6
	mc.un.ord = 1;		/* pindir: output */
	azalia_generic_mixer_set(this, 0x14, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x1b, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x15, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x16, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x17, MI_TARGET_PINDIR, &mc);
a2427 7

	mc.un.ord = 0;		/* pindir: input */
	azalia_generic_mixer_set(this, 0x18, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x19, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x1a, MI_TARGET_PINDIR, &mc);
	/* XXX: inamp for 18/19/1a */

d2435 45
d2558 3
a2562 6
	mc.un.ord = 0;		/* pindir: input */
	azalia_generic_mixer_set(this, 0x1c, MI_TARGET_PINDIR, &mc); /* mic */
	mc.un.ord = 1;		/* enable */
	azalia_generic_mixer_set(this, 0x12, MI_TARGET_EAPD, &mc);
	azalia_generic_mixer_set(this, 0x13, MI_TARGET_EAPD, &mc);

a2573 1

d2625 22
d2706 2
a2713 6
	mc.un.ord = 1;		/* pindir: output */
	azalia_generic_mixer_set(this, 0x0b, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x0c, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x0d, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x0e, MI_TARGET_PINDIR, &mc);
	azalia_generic_mixer_set(this, 0x0f, MI_TARGET_PINDIR, &mc);
a2715 5
	mc.un.ord = 0;		/* pindir: input */
	azalia_generic_mixer_set(this, 0x10, MI_TARGET_PINDIR, &mc);	/* mic */
	azalia_generic_mixer_set(this, 0x13, MI_TARGET_PINDIR, &mc);	/* SPDIF-in */
	azalia_generic_mixer_set(this, 0x1f, MI_TARGET_PINDIR, &mc);	/* line1 */
	azalia_generic_mixer_set(this, 0x20, MI_TARGET_PINDIR, &mc);	/* line2 */
d2805 2
a2807 7
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 1;		/* pindir: output */
	azalia_generic_mixer_set(this, 0x0d, MI_TARGET_PINDIR, &mc); /* headphones */
	azalia_generic_mixer_set(this, 0x0e, MI_TARGET_PINDIR, &mc); /* speaker */
	mc.un.ord = 0;		/* pindir: input */
	azalia_generic_mixer_set(this, 0x0f, MI_TARGET_PINDIR, &mc); /* mic2 */
	azalia_generic_mixer_set(this, 0x10, MI_TARGET_PINDIR, &mc); /* mic1 */
a2905 2
	mixer_ctrl_t mc;

d2918 1
a2918 8
	mc.dev = -1;
	mc.type = AUDIO_MIXER_ENUM;
	mc.un.ord = 1;		/* pindir: output */
	azalia_generic_mixer_set(this, 0x0a, MI_TARGET_PINDIR, &mc); /* headphones */
	azalia_generic_mixer_set(this, 0x0b, MI_TARGET_PINDIR, &mc); /* mic, set to output */
	azalia_generic_mixer_set(this, 0x0c, MI_TARGET_PINDIR, &mc); /* speaker */
	azalia_generic_mixer_set(this, 0x0d, MI_TARGET_PINDIR, &mc); /* line out */
	azalia_generic_mixer_set(this, 0x0f, MI_TARGET_PINDIR, &mc); /* another line out */
a2920 2
		azalia_gpio_unmute(this, 0);
		azalia_gpio_unmute(this, 1);
a3023 3
	if (this->subid == STAC9221_APPLE_ID)
		this->comresp(this, this->audiofunc, 0x7e7, 0, NULL);

d3102 3
a3108 3
	mc.un.ord = 0;
	azalia_generic_mixer_set(this, 0x0d, MI_TARGET_PINDIR, &mc); /* mic */
	azalia_generic_mixer_set(this, 0x14, MI_TARGET_PINDIR, &mc); /* internal mic */
a3110 1

@


1.50
log
@
Some pins are not connected and dead-end.  This diff removes such pins
from conection and mixer lists.  It also removes knobs connected to
power widgets.

from NetBSD via Alexey Suslikov, thanks

tested by several, thanks also
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.49 2008/06/26 05:42:17 ray Exp $	*/
d71 1
a71 1
int 	azalia_generic_mixer_pinctrl(codec_t *, nid_t, uint32_t);
d1016 16
d1296 21
d1335 1
a1335 1
	} 
@


1.49
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.48 2008/05/13 02:24:08 brad Exp $	*/
d431 8
d440 2
a441 1
		if (w->type != COP_AWTYPE_AUDIO_MIXER && w->nconnections >= 2) {
d454 2
d458 5
d550 2
d556 5
d608 2
d613 5
@


1.48
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.47 2008/04/10 17:55:17 deanna Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.47
log
@Add support for recording through the mic jack on AD1984.

Tested by Alexander Hall, thanks

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.46 2007/12/16 18:48:19 deanna Exp $	*/
a38 5

#include <sys/cdefs.h>
#ifdef NETBSD_GOOP
__KERNEL_RCSID(0, "$NetBSD: azalia_codec.c,v 1.3 2005/09/29 04:14:03 kent Exp $");
#endif
@


1.46
log
@Put inamp gain and inamp mute controls under AudioCinputs.  This
avoids some duplicate items when a pin widget has both input and
output amplifiers.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.45 2007/12/06 19:58:48 deanna Exp $	*/
d2147 2
a2148 3
		-1, 2,
		{{1, {0x05}},
		 {1, {0x06}}}};
d2167 13
@


1.45
log
@Remove AD1981HD code, since the generic mixer init can do all of this
now.  Also, note that codec->init_widget functions must be used with
care since they can create duplicate mixer item names.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.44 2007/11/24 18:43:38 deanna Exp $	*/
d532 1
a532 3
				if (w->type == COP_AWTYPE_PIN_COMPLEX)
					d->mixer_class = AZ_CLASS_OUTPUT;
				else if (w->type == COP_AWTYPE_AUDIO_INPUT)
d554 1
a554 3
					if (w->type == COP_AWTYPE_PIN_COMPLEX)
						d->mixer_class = AZ_CLASS_OUTPUT;
					else if (w->type == COP_AWTYPE_AUDIO_INPUT)
d580 1
a580 3
				if (w->type == COP_AWTYPE_PIN_COMPLEX)
					d->mixer_class = AZ_CLASS_OUTPUT;
				else if (w->type == COP_AWTYPE_AUDIO_INPUT)
d605 1
a605 3
					if (w->type == COP_AWTYPE_PIN_COMPLEX)
						d->mixer_class = AZ_CLASS_OUTPUT;
					else if (w->type == COP_AWTYPE_AUDIO_INPUT)
@


1.44
log
@The Sigmatel codec id 7662 looks identical to STAC7661 and works fine with
the code here.  Tested by Rob Lytle, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.43 2007/11/21 18:48:11 deanna Exp $	*/
a66 1
#define AD1981HD_THINKPAD	0x201017aa
a103 2
int	azalia_ad1981hd_init_widget(const codec_t *, widget_t *, nid_t);
int	azalia_ad1981hd_mixer_init(codec_t *);
a160 6
	case 0x11d41981:
		/* http://www.analog.com/en/prod/0,2877,AD1981HD,00.html */
		this->name = "Analog Devices AD1981HD";
		this->init_widget = azalia_ad1981hd_init_widget;
		this->mixer_init = azalia_ad1981hd_mixer_init;
		break;
a2139 62
	return 0;
}


/* ----------------------------------------------------------------
 * Analog Devices AD1981HD
 * ---------------------------------------------------------------- */


int
azalia_ad1981hd_init_widget(const codec_t *this, widget_t *w, nid_t nid)
{
	switch (nid) {
	case 0x05:
		strlcpy(w->name, AudioNline "out", sizeof(w->name));
		break;
	case 0x06:
		strlcpy(w->name, "hp", sizeof(w->name));
		break;
	case 0x07:
		strlcpy(w->name, AudioNmono, sizeof(w->name));
		break;
	case 0x08:
		strlcpy(w->name, AudioNmicrophone, sizeof(w->name));
		break;
	case 0x09:
		strlcpy(w->name, AudioNline "in", sizeof(w->name));
		break;
	case 0x0d:
		strlcpy(w->name, "beep", sizeof(w->name));
		break;
	case 0x17:
		strlcpy(w->name, AudioNaux, sizeof(w->name));
		break;
	case 0x18:
		strlcpy(w->name, AudioNmicrophone "2", sizeof(w->name));
		break;
	case 0x19:
		strlcpy(w->name, AudioNcd, sizeof(w->name));
		break;
	case 0x1d:
		strlcpy(w->name, AudioNspeaker, sizeof(w->name));
		break;
	}
	return 0;
}

int
azalia_ad1981hd_mixer_init(codec_t *this)
{
	mixer_ctrl_t mc;
	int err;

	err = azalia_generic_mixer_init(this);
	if (err)
		return err;
	if (this->subid == AD1981HD_THINKPAD) {
		mc.dev = -1;
		mc.type = AUDIO_MIXER_ENUM;
		mc.un.ord = 1;
		azalia_generic_mixer_set(this, 0x09, MI_TARGET_PINDIR, &mc);
	}
@


1.43
log
@Collect subid #defines at the top.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.42 2007/11/14 05:39:41 deanna Exp $	*/
d210 1
@


1.42
log
@less obnoxious dmesg

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.41 2007/11/06 20:22:15 deanna Exp $	*/
d67 4
a186 1
#define STAC9221_APPLE_ID 0x76808384
a1442 1
#define ALC260_FUJITSU_ID	0x132610cf
a2102 1
#define ALC883_ACER_ID	0x00981025
a2155 1
#define AD1981HD_THINKPAD	0x201017aa
@


1.41
log
@Generalize most of the apple-specific code, since it works fine on
other machines with STAC9221.

Tested by Vladas Urbonas on XPS M1210.
no objections jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.40 2007/10/14 17:56:15 deanna Exp $	*/
a127 1
	DPRINTF(("%s: vid=%08x subid=%08x\n", __func__, this->vid, this->subid));
@


1.40
log
@audio(4)-compatible mixer items for ALC883.

Tested jmc, jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.39 2007/10/10 03:39:21 deanna Exp $	*/
a108 1
int	azalia_stac9221_init_dacgroup(codec_t *);
d111 4
a114 4
int	azalia_stac9221_apple_mixer_init(codec_t *);
int	azalia_stac9221_apple_init_dacgroup(codec_t *);
int	azalia_stac9221_apple_set_port(codec_t *, mixer_ctrl_t *);
int	azalia_stac9221_apple_get_port(codec_t *, mixer_ctrl_t *);
d188 4
a191 7
		if (this->subid == STAC9221_APPLE_ID) {
			this->init_dacgroup =
			    azalia_stac9221_apple_init_dacgroup;
			this->mixer_init =
			    azalia_stac9221_apple_mixer_init;
			this->set_port = azalia_stac9221_apple_set_port;
			this->get_port = azalia_stac9221_apple_get_port;
a192 1
		}
a2450 22
 * Sigmatel STAC9221 and STAC9221D
 * ---------------------------------------------------------------- */

int
azalia_stac9221_init_dacgroup(codec_t *this)
{
	static const convgroupset_t dacs = {
		-1, 3,
		{{4, {0x02, 0x03, 0x04, 0x05}}, /* analog 8ch */
		 {1, {0x08}},	/* digital */
		 {1, {0x1a}}}};	/* another digital? */
	static const convgroupset_t adcs = {
		-1, 2,
		{{2, {0x06, 0x07}}, /* analog 4ch */
		 {1, {0x09}}}};	/* digital */

	this->dacs = dacs;
	this->adcs = adcs;
	return 0;
}

/* ----------------------------------------------------------------
d2575 1
a2575 1
azalia_stac9221_apple_init_dacgroup(codec_t *this)
d2591 1
a2591 1
static const mixer_item_t stac9221_apple_mixer_items[] = {
d2595 1
a2595 1
#define APPLE_TARGET_MASTER -1
d2597 1
a2597 1
	  4, 0, .un.v={{""}, 2, MIXER_DELTA(127)}}, 0x02, APPLE_TARGET_MASTER},
d2599 1
a2599 1
	  0, 3, ENUM_OFFON}, 0x02, APPLE_TARGET_MASTER},
d2623 1
a2623 1
azalia_stac9221_apple_mixer_init(codec_t *this)
d2627 1
a2627 1
	this->nmixers = sizeof(stac9221_apple_mixer_items) / sizeof(mixer_item_t);
d2634 1
a2634 1
	memcpy(this->mixers, stac9221_apple_mixer_items,
d2648 3
a2650 3
	azalia_gpio_unmute(this, 0);
	azalia_gpio_unmute(this, 1);

d2656 3
a2658 5
	/* register hp unsolicited event */
	this->comresp(this, APPLE_NID_HP, CORB_SET_UNSOLICITED_RESPONSE,
	    CORB_UNSOL_ENABLE | APPLE_EVENT_HP, NULL);

        azalia_stac9221_apple_unsol_event(this, APPLE_EVENT_HP);
d2660 2
d2666 1
a2666 1
azalia_stac9221_apple_set_port(codec_t *this, mixer_ctrl_t *mc)
d2678 1
a2678 1
	if (m->target == APPLE_TARGET_MASTER) {
d2693 1
a2693 1
azalia_stac9221_apple_get_port(codec_t *this, mixer_ctrl_t *mc)
d2703 1
a2703 1
	if (m->target == APPLE_TARGET_MASTER)
@


1.39
log
@Rework the debug dmesg to perform a more complete codec dump.

Tested by jmc, ckuethe, kettenis and jakemsr.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.38 2007/10/05 03:33:23 deanna Exp $	*/
d2009 5
d2015 1
a2015 1
	{{0, {"mic1."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
d2017 1
a2017 1
	{{0, {"mic1"}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT,
a2034 5

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0c, MI_TARGET_OUTAMP},
	{{0, {AudioNmaster"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x14, MI_TARGET_OUTAMP},
d2078 1
a2078 1
	{{0, {AudioNsurround"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
d2080 1
a2080 1
	{{0, {AudioNsurround}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
d2082 2
a2083 2
	{{0, {AudioNsurround"."AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{"mic1"}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
d2088 1
a2088 1
	{{0, {AzaliaNclfe"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_RECORD,
d2090 1
a2090 1
	{{0, {AzaliaNclfe}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD,
d2092 2
a2093 2
	{{0, {AzaliaNclfe"."AudioNsource}, AUDIO_MIXER_SET, AZ_CLASS_RECORD,
	  0, 0, .un.s={6, {{{"mic1"}, ALC882_MIC1}, {{"mic2"}, ALC882_MIC2},
@


1.38
log
@The Acer TravelMate 3010 (ALC883) has a couple of gpio pins that need
to be enabled in order for it to produce sound.  It can use the same
gpio function as the macs, so rename that to azalia_gpio_unmute.

Tested by damien@@, no regressions noticed by jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.37 2007/09/26 06:00:27 deanna Exp $	*/
a245 1
	DPRINTF(("%s: find non-connected DACs\n", __func__));
a306 2
		DPRINTF(("%s: assoc=%d seq=%d ==> g=%d n=%d\n",
			 __func__, assoc, seq, this->dacs.ngroups, n-1));
d357 1
a357 3
	if (w->type == COP_AWTYPE_AUDIO_OUTPUT) {
		DPRINTF(("%s: DAC: nid=0x%x index=%d\n",
		    __func__, w->nid, index));
a358 1
	}
d366 1
a366 3
			if (ret >= 0) {
				DPRINTF(("%s: DAC path: nid=0x%x index=%d\n",
				    __func__, w->nid, index));
a367 1
			}
d375 1
a375 3
		if (ret >= 0) {
			DPRINTF(("%s: DAC path: nid=0x%x index=%d\n",
			    __func__, w->nid, index));
a376 1
		}
a407 1
	DPRINTF(("%s: register classes\n", __func__));
a456 1
			DPRINTF(("%s: selector %s\n", __func__, w->name));
a469 2
				DPRINTF(("%s: selector %d=%s\n", __func__, j,
				    this->w[w->connections[j]].name));
a483 1
			DPRINTF(("%s: output mute %s\n", __func__, w->name));
a509 1
			DPRINTF(("%s: output gain %s\n", __func__, w->name));
a536 1
			DPRINTF(("%s: input mute %s\n", __func__, w->name));
a562 2
					DPRINTF(("%s: input mute %s.%s\n", __func__,
					    w->name, this->w[w->connections[j]].name));
a588 1
			DPRINTF(("%s: input gain %s\n", __func__, w->name));
a617 2
					DPRINTF(("%s: input gain %s.%s\n", __func__,
					    w->name, this->w[w->connections[j]].name));
a648 1
			DPRINTF(("%s: pin dir %s\n", __func__, w->name));
a667 1
			DPRINTF(("%s: hpboost %s\n", __func__, w->name));
a685 1
			DPRINTF(("%s: eapd %s\n", __func__, w->name));
a704 1
			DPRINTF(("%s: volume knob %s\n", __func__, w->name));
a719 1
		DPRINTF(("%s: create inputs.usingdac\n", __func__));
a740 1
		DPRINTF(("%s: create inputs.usingadc\n", __func__));
a814 1
	DPRINTF(("%s: unmute\n", __func__));
a832 1
	DPRINTF(("%s: process bidirectional pins\n", __func__));
a845 1
	DPRINTF(("%s: set volume\n", __func__));
@


1.37
log
@Clean up STAC7661 codec: sort mixer items, add prev and next pointers
for master, remove useless pin direction calls, add mixer item for mic
boost, remove useless item for the volume knob.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.36 2007/09/20 17:41:32 deanna Exp $	*/
d117 1
a117 1
int	azalia_stac9221_gpio_unmute(codec_t *, int);
d185 1
d189 1
a189 1
		if (this->subid == 0x76808384) {
d2140 1
d2155 4
d2708 2
a2709 2
	azalia_stac9221_gpio_unmute(this, 0);
	azalia_stac9221_gpio_unmute(this, 1);
d2802 1
a2802 1
azalia_stac9221_gpio_unmute(codec_t *this, int pin)
d2814 3
a2816 1
	this->comresp(this, this->audiofunc, 0x7e7, 0, NULL);
@


1.36
log
@Add mixer items, master volume and dacgroup init for Analog Devices
AD1984.  Recording isn't supported yet.

Lots of testing by reyk@@, Pau Amaro-Seoane and Alexey Vatchenko;
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.35 2007/09/11 05:17:47 deanna Exp $	*/
d2847 4
d2859 2
a2860 6
	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(127)}}, 0x02, STAC7661_TARGET_MASTER},
	{{0, {AudioNmaster"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x02, STAC7661_TARGET_MASTER},
	{{0, {AudioNvolume".knob"}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(15)}}, 0x17, MI_TARGET_VOLUME},
a2889 2
	azalia_generic_mixer_set(this, 0x0a, MI_TARGET_PINDIR, &mc); /* headphones */
	azalia_generic_mixer_set(this, 0x0f, MI_TARGET_PINDIR, &mc); /* speaker */
a2895 4
	mc.type = AUDIO_MIXER_VALUE;
	mc.un.value.num_channels = 1;
	mc.un.value.level[0] = azalia_generic_mixer_max(this, 0x17, MI_TARGET_VOLUME);
	azalia_generic_mixer_set(this, 0x17, MI_TARGET_VOLUME, &mc);
@


1.35
log
@For STAC9221 Macs - no need to max the DAC volumes now that a master
is available.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.34 2007/09/11 05:14:42 deanna Exp $	*/
d103 4
d172 8
d2244 137
@


1.34
log
@For STAC9221 Macs, create master volume and mute controls by binding
the DAC volumes.

Tested by otto@@, ajacoutot@@, merdeley@@ and Darrin Chandler.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.33 2007/09/10 22:37:08 deanna Exp $	*/
a2551 19

	/* max all volumes except master */
	mc.type = AUDIO_MIXER_VALUE;
	mc.un.value.num_channels = 2;
	mc.un.value.level[0] = azalia_generic_mixer_max(this, 0x02, MI_TARGET_OUTAMP);
	mc.un.value.level[1] = mc.un.value.level[0];
	azalia_generic_mixer_set(this, 0x02, MI_TARGET_OUTAMP, &mc);

	mc.un.value.level[0] = azalia_generic_mixer_max(this, 0x03, MI_TARGET_OUTAMP);
	mc.un.value.level[1] = mc.un.value.level[0];
	azalia_generic_mixer_set(this, 0x03, MI_TARGET_OUTAMP, &mc);

	mc.un.value.level[0] = azalia_generic_mixer_max(this, 0x04, MI_TARGET_OUTAMP);
	mc.un.value.level[1] = mc.un.value.level[0];
	azalia_generic_mixer_set(this, 0x04, MI_TARGET_OUTAMP, &mc);

	mc.un.value.level[0] = azalia_generic_mixer_max(this, 0x05, MI_TARGET_OUTAMP);
	mc.un.value.level[1] = mc.un.value.level[0];
	azalia_generic_mixer_set(this, 0x05, MI_TARGET_OUTAMP, &mc);
@


1.33
log
@Use M_ZERO.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.32 2007/09/10 05:34:21 deanna Exp $	*/
d110 2
d181 2
d2500 5
a2524 3

	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 1, MIXER_DELTA(15)}}, 0x16, MI_TARGET_VOLUME},
d2587 44
@


1.32
log
@Add command verbs, a mixer target and mixer controls for EAPD control.
Some codecs, like the AD1984 found in x60s, need this in order for the
speakers to work.

New mixer items with names *.eapd will show up for codecs that need it
and that are using the generic functions.

From kent@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.31 2007/09/10 05:26:38 deanna Exp $	*/
d396 1
a396 1
	    M_DEVBUF, M_NOWAIT);
a400 1
	bzero(this->mixers, sizeof(mixer_item_t) * this->maxmixers);
d788 1
a788 1
	newbuf = malloc(sizeof(mixer_item_t) * newmax, M_DEVBUF, M_NOWAIT);
a792 1
	bzero(newbuf, sizeof(mixer_item_t) * newmax);
d1612 1
a1612 1
	    M_DEVBUF, M_NOWAIT);
a1616 1
	bzero(this->mixers, sizeof(mixer_item_t) * this->nmixers);
d1862 1
a1862 1
	    M_DEVBUF, M_NOWAIT);
a1866 1
	bzero(this->mixers, sizeof(mixer_item_t) * this->maxmixers);
d2127 1
a2127 1
	    M_DEVBUF, M_NOWAIT);
a2131 1
	bzero(this->mixers, sizeof(mixer_item_t) * this->maxmixers);
d2280 1
a2280 1
	    M_DEVBUF, M_NOWAIT);
a2284 1
	bzero(this->mixers, sizeof(mixer_item_t) * this->maxmixers);
d2410 1
a2410 1
	    M_DEVBUF, M_NOWAIT);
a2414 1
	bzero(this->mixers, sizeof(mixer_item_t) * this->maxmixers);
d2528 1
a2528 1
	    M_DEVBUF, M_NOWAIT);
a2532 1
	bzero(this->mixers, sizeof(mixer_item_t) * this->maxmixers);
d2698 1
a2698 1
	    M_DEVBUF, M_NOWAIT);
a2702 1
	bzero(this->mixers, sizeof(mixer_item_t) * this->maxmixers);
@


1.31
log
@Set bidirectional pins to output, ignoring what the codec says is
their purpose, since that's often incorrect.

This should solve some no-sound problems for codecs using the generic
functions.

From kent@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.30 2007/09/06 22:52:05 deanna Exp $	*/
d693 19
d1035 9
d1298 20
@


1.30
log
@Add an unsolicited even handler for the Sigmatel Apple codecs.  The
speakers and line outputs will now mute and unmute depending on
headphone presence.

Tested on Macbook, Macbook Pro and Mini by otto@@, ajacoutot@@, merdely@@
and Darrin Chandler, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.29 2007/07/31 17:06:25 deanna Exp $	*/
d828 1
a828 3
	 * For bidirectional pins,
	 *   Output: lineout, speaker, headphone, spdifout, digitalout, other
	 *   Input: others
d839 1
a839 12
		switch (this->w[m->nid].d.pin.device) {
		case CORB_CD_LINEOUT:
		case CORB_CD_SPEAKER:
		case CORB_CD_HEADPHONE:
		case CORB_CD_SPDIFOUT:
		case CORB_CD_DIGITALOUT:
		case CORB_CD_DEVICE_OTHER:
			mc.un.ord = 1;
			break;
		default:
			mc.un.ord = 0;
		}
@


1.29
log
@Our audio layer doesn't know anything about mixer names like
"selector" and "front", so instead create the items that it actually
needs.

This unbreaks the mute button in wscons, and allows setting the volume
in programs like xmms and xine.  This is for STAC9200 only - similiar
fixes for other codecs coming soon.

Tested and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.28 2007/07/31 16:14:26 deanna Exp $	*/
d110 1
d179 1
a179 1
			break;
d2542 11
d2554 32
@


1.28
log
@In the mixer to device level conversions, round down to the nearest
valid step, and keep them in sync. This lets audio(4) set exact gain
levels based on the mixer delta, and unbreaks volume up/down buttons
in wscons.  This also avoids a divide by zero that could occur if the
generic mixer init found an amplifier with zero steps.

Problem noticed and tested by jmc@@, similar diff tested by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.27 2007/07/23 03:41:03 deanna Exp $	*/
d2330 17
a2352 11
	{{0, {"selector."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x0a, MI_TARGET_OUTAMP},
	{{0, {"selector"}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(15)}}, 0x0a, MI_TARGET_OUTAMP},
	{{0, {AudioNmaster"."AudioNmute}, AUDIO_MIXER_ENUM, AZ_CLASS_OUTPUT,
	  0, 0, ENUM_OFFON}, 0x0b, MI_TARGET_OUTAMP},
	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	  0, 0, .un.v={{""}, 2, MIXER_DELTA(31)}}, 0x0b, MI_TARGET_OUTAMP},
	{{0, {"selector."AudioNsource}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT,
	  0, 0, .un.e={3, {{{"mic1"}, 0}, {{"mic2"}, 1}, {{AudioNcd}, 4}}}},
	 0x0c, MI_TARGET_CONNLIST},
@


1.27
log
@STAC7661:

- enable internal mic and select it as the default recording source,

- create mixerctl record.source for selecting between internal and
external mics,

- mute input by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.26 2007/07/23 03:25:11 deanna Exp $	*/
d1323 5
a1327 1
	return dv * AUDIO_MAX_GAIN / dmax;
d1350 5
a1354 1
	return uv * dmax / AUDIO_MAX_GAIN;
@


1.26
log
@Fix a typo in a comment: VAIO SE -> VAIO SZ.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.25 2007/07/23 03:21:57 deanna Exp $	*/
d2586 4
d2628 1
d2631 2
a2632 1
	mc.un.ord = 1;          /* select mic for recording */
@


1.25
log
@STAC7661: rename "inputs.mic" to "record.volume".  This is what the
audio layer wants, and is a more accurate description.  Use the
correct number of steps.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.24 2007/07/23 03:03:58 deanna Exp $	*/
d2553 1
a2553 1
 * Sony VAIO FE and SE
@


1.24
log
@STAC7661:

- Add set_port and get_port functions and use them to create a stereo
master volume out of the headphone and speaker dacs.  Unbreaks setting
the volume in ports like xmms.

- Use the correct number of steps for the dac volumes.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.23 2007/07/23 02:03:42 deanna Exp $	*/
d2582 1
a2582 1
	{{0, {AudioNmicrophone".mute"}, AUDIO_MIXER_ENUM, AZ_CLASS_INPUT, 0, 0,
d2584 2
a2585 2
	{{0, {AudioNmicrophone}, AUDIO_MIXER_VALUE, AZ_CLASS_INPUT, 0, 0,
	    .un.v={{""}, 2, MIXER_DELTA(35)}}, 0x09, MI_TARGET_INAMP(0)},
@


1.23
log
@We will never make a mixer item out of the pin control operation, so
move it out of azalia_generic_mixer_set into its own function,
azalia_generic_mixer_pinctrl.  From kent@@netbsd.

In azalia_stac9200_mixer_init, let the unsolicited event handler make
the initial headphone vs speaker choice.  Removes some duplicate code.

These changes only affect STAC9200.  Tested by krw@@ on a Latitude
D620.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.22 2007/07/07 16:33:38 deanna Exp $	*/
d113 2
d198 2
d2578 4
d2586 6
d2595 1
a2595 1
	    0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x02, MI_TARGET_OUTAMP},
d2599 1
a2599 3
	    0, 0, .un.v={{""}, 2, MIXER_DELTA(65)}}, 0x05, MI_TARGET_OUTAMP},
	{{0, {AudioNmaster}, AUDIO_MIXER_VALUE, AZ_CLASS_OUTPUT,
	    0, 0, .un.v={{""}, 1, MIXER_DELTA(15)}}, 0x17, MI_TARGET_VOLUME},
d2629 3
a2631 7
	mc.un.value.num_channels = 2;
	mc.un.value.level[0] = azalia_generic_mixer_max(this, 0x02, MI_TARGET_OUTAMP);
	mc.un.value.level[1] = mc.un.value.level[0];
	azalia_generic_mixer_set(this, 0x02, MI_TARGET_OUTAMP, &mc);
	mc.un.value.level[0] = azalia_generic_mixer_max(this, 0x05, MI_TARGET_OUTAMP);
	mc.un.value.level[1] = mc.un.value.level[0];
	azalia_generic_mixer_set(this, 0x05, MI_TARGET_OUTAMP, &mc);
d2634 39
@


1.22
log
@Add support for Realtek ALC883.  This is the "value" edition of the
ALC882, and differs only by lacking an ADC and a mixer, so have it use
ALC882's get_port(), set_port() and a slightly modified version of its
mixer init.

This also works around a problem where the generic mixer init creates
truncated mixer item names which can't be manipulated (noticed by
steven@@).

Tested by steven@@, ckuethe@@ and jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.21 2007/06/19 00:39:33 deanna Exp $	*/
d80 1
a1224 22
	/* 
	 * pin control: enable/disable.  for bidirectional pins, set
	 * direction with MI_TARGET_PINDIR after enabling.
	 */

	else if (target == MI_TARGET_PINCTRL) {
		if (mc->un.ord >= 2)
			return EINVAL;
		err = this->comresp(this, nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err)
			return err;
		if (mc->un.ord == 0)	/* disable */
			result &= ~(CORB_PWC_OUTPUT | CORB_PWC_INPUT);
		else
			result |= CORB_PWC_OUTPUT | CORB_PWC_INPUT;
		err = this->comresp(this, nid,
		    CORB_SET_PIN_WIDGET_CONTROL, result, &result);
		if (err)
			return err;
	}

d1287 15
a2358 2
	int err;
	uint32_t value;
d2396 1
a2396 1
	/* make initial hp vs speaker choice */
a2397 23
	err = this->comresp(this, STAC9200_NID_HP,
	    CORB_GET_PIN_SENSE, 0, &value);
	if (err)
		return err;
	if (value & CORB_PS_PRESENCE) {
		mc.un.ord = 0;
		azalia_generic_mixer_set(this, STAC9200_NID_SPEAKER,
		    MI_TARGET_PINCTRL, &mc);
		mc.un.ord = 1;
		azalia_generic_mixer_set(this, STAC9200_NID_HP,
		    MI_TARGET_PINCTRL, &mc);
		azalia_generic_mixer_set(this, STAC9200_NID_HP,
		    MI_TARGET_PINDIR, &mc);
	} else {
		mc.un.ord = 0;
		azalia_generic_mixer_set(this, STAC9200_NID_HP,
		    MI_TARGET_PINCTRL, &mc);
		mc.un.ord = 1;
		azalia_generic_mixer_set(this, STAC9200_NID_SPEAKER,
		    MI_TARGET_PINCTRL, &mc);
		azalia_generic_mixer_set(this, STAC9200_NID_SPEAKER,
		    MI_TARGET_PINDIR, &mc);
	}
a2404 1
	mixer_ctrl_t mc;
d2411 1
a2411 1
			return err;
d2414 2
a2415 9
			mc.un.ord = 0; /* disable */
			azalia_generic_mixer_set(this, 
			    STAC9200_NID_SPEAKER,
			    MI_TARGET_PINCTRL, &mc);
			mc.un.ord = 1; /* enable and direction output */
			azalia_generic_mixer_set(this, STAC9200_NID_HP,
			    MI_TARGET_PINCTRL, &mc);
			azalia_generic_mixer_set(this, STAC9200_NID_HP,
			    MI_TARGET_PINDIR, &mc);
d2418 2
a2419 10
			mc.un.ord = 0;
			azalia_generic_mixer_set(this, STAC9200_NID_HP,
			    MI_TARGET_PINCTRL, &mc);
			mc.un.ord = 1;
			azalia_generic_mixer_set(this,
			    STAC9200_NID_SPEAKER,
			    MI_TARGET_PINCTRL, &mc);
			azalia_generic_mixer_set(this, 
			    STAC9200_NID_SPEAKER,
			    MI_TARGET_PINDIR, &mc);
@


1.21
log
@Add a dac group init, mixer table and mixer init for the Sigmatel
codec ID 83847661 found in some Sony VAIO FE and SZ laptops.

No regressions noticed by jasper@@, steven@@ or Will Backman.  I've been
using it for months.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.20 2007/06/13 02:32:41 deanna Exp $	*/
d98 2
d144 8
d1958 172
@


1.20
log
@Support the Macbook, Macbook Pro, Mac Mini and possibly the iMac.

Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.19 2007/05/02 17:01:22 deanna Exp $	*/
d108 2
d181 5
d2409 80
@


1.19
log
@- Add support for handling unsolicited events (based on NetBSD).

- The STAC9200 codec was mistakenly referred to as STAC9220.  Change
this to STAC9200 and add a link to the datasheet.

- Add a new target, MI_TARGET_PINCTRL, to azalia_generic_mixer_set()
that allows us to turn pins on and off.

- Add an unsolicited event handler for STAC9200 that will toggle the
headphone and speaker pins.  This means the speaker will now mute and
unmute based on headphone presence.

- Spelling: PRESENSE -> PRESENCE

Tested by ajacoutot@@, tedu@@ and krw@@, ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.18 2006/07/23 20:23:51 brad Exp $	*/
d105 3
d158 7
d2283 120
@


1.18
log
@Make the default value of outputs.linein.dir "output" for the ThinkPad T60.

From kent@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.17 2006/07/20 23:51:48 brad Exp $	*/
d103 2
a104 2
int	azalia_stac9220_mixer_init(codec_t *);

d161 7
a167 2
		this->name = "Sigmatel STAC9220";
		this->mixer_init = azalia_stac9220_mixer_init;
d1197 22
d2117 1
a2117 1
 * Sigmatel STAC9220
d2120 1
a2120 1
static const mixer_item_t stac9220_mixer_items[] = {
d2163 1
a2163 1
azalia_stac9220_mixer_init(codec_t *this)
d2166 2
d2169 1
a2169 1
	this->nmixers = sizeof(stac9220_mixer_items) / sizeof(mixer_item_t);
d2177 1
a2177 1
	memcpy(this->mixers, stac9220_mixer_items,
d2196 77
@


1.17
log
@Re-enable the widget init routine for the Analog Devices AD1981HD codec.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.16 2006/07/19 19:22:04 brad Exp $	*/
d99 1
d141 1
d1909 2
d1945 18
@


1.16
log
@fix crash by reading a mixer value with AD1891HD codec, which
has invalid connection lists.

From kent@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.15 2006/06/25 00:54:16 brad Exp $	*/
a97 1
#if 0
a98 1
#endif
a138 1
#if 0
a139 1
#endif
a1906 1
#if 0
a1943 1
#endif
@


1.15
log
@DAC&ADC group and custom mixer table for the CMedia CMI9880.

From kent NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.14 2006/06/17 18:38:12 brad Exp $	*/
d886 13
a898 1
		n = this->w[nid].connections[MI_TARGET_INAMP(target)];
@


1.14
log
@Fix a bug that AUDIO_MIXER_READ returns an incorrect
mixer_ctrl_t::un.value.num_channels in the case of the
combination of a mono pin and a stereo mixer.

From kent NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.13 2006/06/16 08:03:42 brad Exp $	*/
d90 1
a91 1
int	azalia_alc260_init_dacgroup(codec_t *);
d101 2
d149 5
d1938 100
@


1.13
log
@- generic_mixer_default()
 set the default pin direction depending on the pin's device, not color
- ALC882:
  - add usingdac and usingadc
  - remove alc882_init_widget() because it has no effect any more
- codec-specific mixer initialization for Realtek ALC882
- fix audio_format allocation for recording

From kent NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.12 2006/06/16 07:29:24 brad Exp $	*/
d857 1
d879 2
a880 1
		mc->un.value.num_channels = WIDGET_CHANNELS(&this->w[nid]);
@


1.12
log
@I am keeping the Analog Devices AD1981HD widget init routine disabled but
at least allowing the driver to recognize the codec type.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.11 2006/06/16 06:00:46 brad Exp $	*/
d53 5
d63 3
a65 5
#ifdef MAX_VOLUME_255
# define MIXER_DELTA(n)	(AUDIO_MAX_GAIN / (n))
#else
# define MIXER_DELTA(n)	(1)
#endif
d95 3
a97 1
int	azalia_alc882_init_widget(const codec_t *, widget_t *, nid_t);
d132 3
a134 1
		this->init_widget = azalia_alc882_init_widget;
d785 3
a787 3
	 * for bidirectional pins,
	 * green=front, orange=surround, gray=c/lfe, black=side --> output
	 * blue=line-in, pink=mic-in --> input
d798 7
a804 5
		switch (this->w[m->nid].d.pin.color) {
		case CORB_CD_GREEN:
		case CORB_CD_ORANGE:
		case CORB_CD_GRAY:
		case CORB_CD_BLACK:
d1626 166
d1795 1
d1801 6
d1818 36
a1853 1
azalia_alc882_init_widget(const codec_t *this, widget_t *w, nid_t nid)
d1855 27
a1881 32
	switch (nid) {
	case 0x14:
		strlcpy(w->name, "green", sizeof(w->name));
		break;
	case 0x15:
		strlcpy(w->name, "gray", sizeof(w->name));
		break;
	case 0x16:
		strlcpy(w->name, "orange", sizeof(w->name));
		break;
	case 0x17:
		strlcpy(w->name, "black", sizeof(w->name));
		break;
	case 0x18:
		strlcpy(w->name, "mic1", sizeof(w->name));
		break;
	case 0x19:
		strlcpy(w->name, "mic2", sizeof(w->name));
		break;
	case 0x1a:
		strlcpy(w->name, AudioNline, sizeof(w->name));
		break;
	case 0x1b:
		/* AudioNheadphone is too long */
		strlcpy(w->name, "hp", sizeof(w->name));
		break;
	case 0x1c:
		strlcpy(w->name, AudioNcd, sizeof(w->name));
		break;
	case 0x1d:
		strlcpy(w->name, AudioNspeaker, sizeof(w->name));
		break;
d1883 1
a1883 1
	return 0;
@


1.11
log
@* support for multi-channel (>=3) recording with ALC880, ALC882, or STAC9221
* azalia_codec_init_vtbl()
  recognize the name of AD1983
* azalia_generic_codec_find_dac()
  check validity of a node in a connection list
* introduce MIXER_DELTA, and simplify the code with it
* codec-specific mixer initialization for STAC9220

From kent NetBSD

Tested by a few end-users.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.10 2006/06/14 20:24:12 brad Exp $	*/
a128 1
#if 0
d132 1
d134 1
a135 1
#endif
@


1.10
log
@- If the codec has support for a modem then print that there is no
modem support.
- Print the name of the STAC9220 codec.

From kent NetBSD

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.9 2006/06/14 19:34:52 brad Exp $	*/
d58 5
d81 1
d97 1
d136 4
d150 1
d172 1
a172 1
	this->ndacgroups = 0;
d186 3
a188 3
		for (group = 0; group < this->ndacgroups; group++) {
			for (j = 0; j < this->dacgroups[group].nconv; j++) {
				if (i == this->dacgroups[group].conv[j]) {
d190 1
a190 1
					group = this->ndacgroups;
d197 1
a197 1
		if (this->ndacgroups >= 32)
d199 3
a201 3
		this->dacgroups[this->ndacgroups].nconv = 1;
		this->dacgroups[this->ndacgroups].conv[0] = i;
		this->ndacgroups++;
d203 1
a203 1
	this->cur_dac = 0;
d206 1
a206 1
	this->nadcs = 0;
d210 4
a213 2
		this->adcs[this->nadcs++] = i;
		if (this->nadcs >= 32)
d216 1
a216 1
	this->cur_adc = 0;
d235 1
a235 1
			if (this->dacgroups[this->ndacgroups].conv[j] == dac)
d240 1
a240 1
		this->dacgroups[this->ndacgroups].conv[n++] = dac;
d242 1
a242 1
			 __func__, assoc, seq, this->ndacgroups, n-1));
d246 1
a246 1
	this->dacgroups[this->ndacgroups].nconv = n;
d249 2
a250 2
	for (i = 0; i < this->ndacgroups; i++) {
		if (n != this->dacgroups[i].nconv)
d253 2
a254 2
			if (this->dacgroups[this->ndacgroups].conv[j] !=
			    this->dacgroups[i].conv[j])
d261 1
a261 1
	this->ndacgroups++;
d303 7
a309 5
		ret = azalia_generic_codec_find_dac(this, j, depth);
		if (ret >= 0) {
			DPRINTF(("%s: DAC path: nid=0x%x index=%d\n",
			    __func__, w->nid, index));
			return ret;
d314 2
a340 1
	int nadcs;
a342 1
	nadcs = 0;
a400 3
		if (w->type == COP_AWTYPE_AUDIO_INPUT)
			nadcs++;

a476 2
			d->un.v.delta = AUDIO_MAX_GAIN /
			    COP_AMPCAP_NUMSTEPS(w->outamp_cap);
a479 1
			d->un.v.delta = 1;
d481 2
a560 2
				d->un.v.delta = AUDIO_MAX_GAIN /
				    COP_AMPCAP_NUMSTEPS(w->inamp_cap);
a564 1
				d->un.v.delta = 1;
d566 2
a589 2
					d->un.v.delta = AUDIO_MAX_GAIN /
					    COP_AMPCAP_NUMSTEPS(w->inamp_cap);
a593 1
					d->un.v.delta = 1;
d595 2
d654 2
a655 6
#ifdef MAX_VOLUME_255
			d->un.v.delta = AUDIO_MAX_GAIN /
			    COP_VKCAP_NUMSTEPS(w->d.volume.cap);
#else
			d->un.v.delta = 1;
#endif
d661 1
a661 1
	if (this->ndacgroups > 1) {
d668 1
a668 1
		for (i = 0; i < this->ndacgroups && i < 32; i++) {
d670 1
a670 1
			for (j = 0; j < this->dacgroups[i].nconv; j++) {
d675 1
a675 1
				    this->dacgroups[i].conv[j]);
d682 2
a683 2
	/* if the codec has multiple ADCs, create "record.usingadc" */
	if (this->nadcs > 1) {
d690 1
a690 1
		for (i = 0; i < this->nadcs && i < 32; i++) {
d692 7
a698 2
			strlcpy(d->un.e.member[i].label.name,
			    this->w[this->adcs[i]].name, MAX_AUDIO_DEV_LEN);
d944 1
a944 1
		mc->un.ord = this->cur_dac;
d949 1
a949 1
		mc->un.ord = this->cur_adc;
d1187 1
a1187 1
		if (mc->un.ord >= this->ndacgroups)
d1189 2
a1190 2
		this->cur_dac = mc->un.ord;
		return azalia_codec_construct_format(this);
d1197 1
a1197 1
		if (mc->un.ord >= this->nadcs)
d1199 2
a1200 3
		this->cur_adc = mc->un.ord;
		/* use this->adcs[this->cur_adc] */
		return azalia_codec_construct_format(this);
d1272 2
a1273 3
boolean_t
azalia_generic_mixer_validate_value(const codec_t *this, nid_t nid, int target,
    u_char uv)
d1276 1
a1276 1
	return TRUE;
d1286 12
a1297 1
	return uv <= dmax;
d1378 1
a1378 1
	  0, 0, .un.v={{""}, 2, 3}}, 0x07, MI_TARGET_INAMP(0)},
d1382 1
a1382 1
	  0, 0, .un.v={{""}, 2, 3}}, 0x07, MI_TARGET_INAMP(1)},
d1390 1
a1390 1
	  0, 0, .un.v={{""}, 2, 3}}, 0x07, MI_TARGET_INAMP(3)},
d1394 1
a1394 1
	  0, 0, .un.v={{""}, 2, 3}}, 0x07, MI_TARGET_INAMP(4)},
d1398 1
a1398 1
	  0, 0, .un.v={{""}, 2, 3}}, 0x07, MI_TARGET_INAMP(5)},
d1406 2
a1407 2
	{{0, {"adc04"}, AUDIO_MIXER_VALUE, AZ_CLASS_RECORD, 0, 0, .un.v={{""}, 2, 7}},
	 0x04, MI_TARGET_INAMP(0)},
d1415 1
a1415 1
	  .un.v={{""}, 2, 7}}, 0x05, MI_TARGET_INAMP(0)},
d1444 1
a1444 1
	  0, 0, .un.v={{""}, 2, 3}}, 0x07, MI_TARGET_INAMP(0)},
d1448 1
a1448 1
	  0, 0, .un.v={{""}, 2, 3}}, 0x07, MI_TARGET_INAMP(4)},
d1452 1
a1452 1
	  0, 0, .un.v={{""}, 2, 3}}, 0x07, MI_TARGET_INAMP(5)},
d1459 1
a1459 1
	  .un.v={{""}, 2, 7}}, 0x04, MI_TARGET_INAMP(0)},
d1466 1
a1466 1
	  .un.v={{""}, 2, 7}}, 0x05, MI_TARGET_INAMP(0)},
d1529 12
a1540 12
	static const convgroup_t dacs[2] = {
		{1, {0x02}},	/* analog 2ch */
		{1, {0x03}}};	/* digital */

	this->ndacgroups = 2;
	this->dacgroups[0] = dacs[0];
	this->dacgroups[1] = dacs[1];

	this->nadcs = 3;
	this->adcs[0] = 0x04;
	this->adcs[1] = 0x05;
	this->adcs[2] = 0x06;	/* digital */
d1599 11
a1609 12
	static const convgroup_t dacs[2] = {
		{4, {0x02, 0x04, 0x03, 0x05}}, /* analog 8ch */
		{1, {0x06}}};	/* digital */

	this->ndacgroups = 2;
	this->dacgroups[0] = dacs[0];
	this->dacgroups[1] = dacs[1];

	this->nadcs = 3;
	this->adcs[0] = 0x08;
	this->adcs[1] = 0x09;
	this->adcs[2] = 0x0a;	/* digital */
d1620 12
a1631 15
	static const convgroup_t dacs[3] = {
		{4, {0x02, 0x04, 0x03, 0x05}}, /* analog 8ch */
		{1, {0x06}},	/* digital */
		{1, {0x25}}};	/* another analog */

	this->ndacgroups = 3;
	this->dacgroups[0] = dacs[0];
	this->dacgroups[1] = dacs[1];
	this->dacgroups[2] = dacs[2];

	this->nadcs = 4;
	this->adcs[0] = 0x07;
	this->adcs[1] = 0x08;
	this->adcs[2] = 0x09;
	this->adcs[3] = 0x0a;	/* digital */
d1725 93
a1817 14
	static const convgroup_t dacs[3] = {
		{4, {0x02, 0x03, 0x05, 0x04}}, /* analog 8ch */
		{1, {0x08}},	/* digital */
		{1, {0x1a}}};	/* another digital? */

	this->ndacgroups = 3;
	this->dacgroups[0] = dacs[0];
	this->dacgroups[1] = dacs[1];
	this->dacgroups[2] = dacs[2];

	this->nadcs = 3;
	this->adcs[0] = 6;	/* XXX four channel recording */
	this->adcs[1] = 7;
	this->adcs[2] = 9;	/* digital */
@


1.9
log
@* move mixer functions from azalia.c to azalia_codec.c, and
rename them like azalia_mixer_foo() to azalia_generic_mixer_foo()

* enable codec-specific code to hook any mixer operations such
as creating mixer items, or special handling for a specific
item.

* provide a custom mixer table specific to ALC260
* provide a custom mixer table specific to Fujitsu LOOX

From kent NetBSD

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.8 2006/05/18 03:34:50 brad Exp $	*/
d136 3
@


1.8
log
@disable the Analog Devices AD1981HD codec widget init routine for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.7 2006/05/18 03:23:23 brad Exp $	*/
d46 2
d52 35
a86 10

int	azalia_codec_init_dacgroup(codec_t *);
int	azalia_codec_add_dacgroup(codec_t *, int, uint32_t);
int	azalia_codec_find_pin(const codec_t *, int, int, uint32_t);
int	azalia_codec_find_dac(const codec_t *, int, int);
int	alc260_init_dacgroup(codec_t *);
int	alc260_init_widget(const codec_t *, widget_t *, nid_t);
int	alc880_init_dacgroup(codec_t *);
int	alc882_init_dacgroup(codec_t *);
int	alc882_init_widget(const codec_t *, widget_t *, nid_t);
d88 1
a88 1
int	ad1981hd_init_widget(const codec_t *, widget_t *, nid_t);
d90 1
a90 1
int	stac9221_init_dacgroup(codec_t *);
d94 1
a94 1
azalia_codec_init_vtbl(codec_t *this, uint32_t vid)
d96 11
a106 1
	switch (vid) {
d109 3
a111 2
		this->init_dacgroup = alc260_init_dacgroup;
		this->init_widget = alc260_init_widget;
d115 1
a115 1
		this->init_dacgroup = alc880_init_dacgroup;
d119 2
a120 2
		this->init_dacgroup = alc882_init_dacgroup;
		this->init_widget = alc882_init_widget;
d126 1
a126 1
		this->init_widget = ad1981hd_init_widget;
d131 1
a131 1
		this->init_dacgroup = stac9221_init_dacgroup;
d135 1
a135 1
		this->init_dacgroup = stac9221_init_dacgroup;
a136 3
	default:
		this->name = NULL;
		this->init_dacgroup = azalia_codec_init_dacgroup;
d146 1
a146 1
azalia_codec_init_dacgroup(codec_t *this)
d159 2
a160 2
		azalia_codec_add_dacgroup(this, assoc, 0);
		azalia_codec_add_dacgroup(this, assoc, COP_AWCAP_DIGITAL);
d204 1
a204 1
azalia_codec_add_dacgroup(codec_t *this, int assoc, uint32_t digital)
d210 1
a210 1
		i = azalia_codec_find_pin(this, assoc, seq, digital);
d213 1
a213 1
		dac = azalia_codec_find_dac(this, i, 0);
d249 1
a249 1
azalia_codec_find_pin(const codec_t *this, int assoc, int seq, uint32_t digital)
d270 1
a270 1
azalia_codec_find_dac(const codec_t *this, int index, int depth)
d286 1
a286 1
		ret = azalia_codec_find_dac(this, j, depth);
d295 1
a295 1
		ret = azalia_codec_find_dac(this, j, depth);
d306 1003
d1310 5
d1317 186
d1504 1
a1504 1
alc260_init_dacgroup(codec_t *this)
d1522 1
a1522 1
alc260_init_widget(const codec_t *this, widget_t *w, nid_t nid)
d1524 41
a1564 41
	switch (nid) {
	case 0x0b:		/* selector for 0x12 */
		strlcpy(w->name, AudioNmicrophone "1", sizeof(w->name));
		break;
	case 0x0c:		/* selector for 0x13 */
		strlcpy(w->name, AudioNmicrophone "2", sizeof(w->name));
		break;
	case 0x0d:		/* selector for 0x14 */
		strlcpy(w->name, AudioNline "1", sizeof(w->name));
		break;
	case 0x0e:		/* selector for 0x15 */
		strlcpy(w->name, AudioNline "2", sizeof(w->name));
		break;
	case 0x0f:
		strlcpy(w->name, AudioNline, sizeof(w->name));
		break;
	case 0x10:
		/* AudioNheadphone is too long */
		strlcpy(w->name, "hp", sizeof(w->name));
		break;
	case 0x11:
		strlcpy(w->name, AudioNmono, sizeof(w->name));
		break;
	case 0x12:
		strlcpy(w->name, AudioNmicrophone "1", sizeof(w->name));
		break;
	case 0x13:
		strlcpy(w->name, AudioNmicrophone "2", sizeof(w->name));
		break;
	case 0x14:
		strlcpy(w->name, AudioNline "1", sizeof(w->name));
		break;
	case 0x15:
		strlcpy(w->name, AudioNline "2", sizeof(w->name));
		break;
	case 0x16:
		strlcpy(w->name, AudioNcd, sizeof(w->name));
		break;
	case 0x17:
		strlcpy(w->name, AudioNspeaker, sizeof(w->name));
		break;
d1566 1
a1566 1
	return 0;
d1574 1
a1574 1
alc880_init_dacgroup(codec_t *this)
d1596 1
a1596 1
alc882_init_dacgroup(codec_t *this)
d1617 1
a1617 1
alc882_init_widget(const codec_t *this, widget_t *w, nid_t nid)
d1661 1
a1661 1
ad1981hd_init_widget(const codec_t *this, widget_t *w, nid_t nid)
d1704 1
a1704 1
stac9221_init_dacgroup(codec_t *this)
@


1.7
log
@de-static
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.6 2006/05/11 05:12:46 brad Exp $	*/
d60 1
d62 1
d84 1
d90 1
d430 1
d468 1
@


1.6
log
@fix incorrect ADC list for ALC880.

From kent NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.5 2006/05/08 04:33:54 brad Exp $	*/
d51 11
a61 11
static int	azalia_codec_init_dacgroup(codec_t *);
static int	azalia_codec_add_dacgroup(codec_t *, int, uint32_t);
static int	azalia_codec_find_pin(const codec_t *, int, int, uint32_t);
static int	azalia_codec_find_dac(const codec_t *, int, int);
static int	alc260_init_dacgroup(codec_t *);
static int	alc260_init_widget(const codec_t *, widget_t *, nid_t);
static int	alc880_init_dacgroup(codec_t *);
static int	alc882_init_dacgroup(codec_t *);
static int	alc882_init_widget(const codec_t *, widget_t *, nid_t);
static int	ad1981hd_init_widget(const codec_t *, widget_t *, nid_t);
static int	stac9221_init_dacgroup(codec_t *);
d106 1
a106 1
static int
d164 1
a164 1
static int
d209 1
a209 1
static int
d230 1
a230 1
static int
d270 1
a270 1
static int
d288 1
a288 1
static int
d340 1
a340 1
static int
d362 1
a362 1
static int
d383 1
a383 1
static int
d426 1
a426 1
static int
d468 1
a468 1
static int
@


1.5
log
@readable names for AD1981HD codec

From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: azalia_codec.c,v 1.4 2006/05/08 04:28:33 brad Exp $	*/
/*	$NetBSD: azalia_codec.c,v 1.7 2006/01/16 14:28:38 kent Exp $	*/
d351 4
a354 5
	this->nadcs = 4;
	this->adcs[0] = 0x07;
	this->adcs[1] = 0x08;
	this->adcs[2] = 0x09;
	this->adcs[3] = 0x0a;	/* digital */
d423 1
a423 1
 * Analog Device AD1981HD
@


1.4
log
@ALC260: improve readability of mixer item names.

From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: azalia_codec.c,v 1.3 2006/05/08 04:24:47 brad Exp $	*/
/*	$NetBSD: azalia_codec.c,v 1.3 2005/09/29 04:14:03 kent Exp $	*/
d60 1
d82 5
d414 42
@


1.3
log
@support for 8ch playback with STAC9221D codec.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia_codec.c,v 1.2 2006/05/08 03:53:57 brad Exp $	*/
d56 1
d70 1
d282 48
d364 1
a364 1
		
@


1.2
log
@OpenBSD RCS ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 5
d368 1
a368 1
 * Sigmatel STAC9221
@


1.1
log
@not quite working driver for azalia audio (this is essentially AC97 for > 2005)
Just as brain damaged and ill specified.  From NetBSD.
@
text
@d1 1
@

