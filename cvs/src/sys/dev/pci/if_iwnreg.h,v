head	1.54;
access;
symbols
	OPENBSD_6_2_BASE:1.54
	OPENBSD_6_1:1.53.0.6
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.4
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.49.0.6
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.49.0.4
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.47.0.6
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.43.0.8
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.6
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.4
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.2
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9;
locks; strict;
comment	@ * @;


1.54
date	2017.08.12.09.13.06;	author stsp;	state Exp;
branches;
next	1.53;
commitid	u3kzq6KolABwSpGw;

1.53
date	2016.04.28.08.28.18;	author stsp;	state Exp;
branches;
next	1.52;
commitid	SP1PldSb3yi4jHiY;

1.52
date	2016.02.05.16.09.19;	author stsp;	state Exp;
branches;
next	1.51;
commitid	mPZyiLTTdZAbwkBA;

1.51
date	2016.01.07.23.08.38;	author stsp;	state Exp;
branches;
next	1.50;
commitid	YQmveOCEh6MqfAJ4;

1.50
date	2016.01.04.13.54.19;	author stsp;	state Exp;
branches;
next	1.49;
commitid	ry4GqFXRBXnQ5vkR;

1.49
date	2014.09.09.18.56.24;	author sthen;	state Exp;
branches;
next	1.48;
commitid	z8IPodJj5IQow43B;

1.48
date	2014.09.09.18.55.08;	author sthen;	state Exp;
branches;
next	1.47;
commitid	8pWlzts5FN03iazF;

1.47
date	2014.02.11.19.30.10;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2014.02.10.19.08.58;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2013.11.26.20.33.17;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2013.08.29.19.06.40;	author syl;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.01.18.49.56;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.09.15.45.37;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.20.19.24.31;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.05.19.41.57;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.30.16.06.46;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.10.08.37.36;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2010.02.17.18.23.00;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.23.09.14.13;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.16.12.48.58;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.08.11.54.48;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.03.18.57.18;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.01.12.01.16;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.28.18.42.47;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.26.17.55.29;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.24.20.17.17;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.24.19.00.40;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.24.18.14.57;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.29.08.25.45;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.27.09.50.31;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.24.18.51.11;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.20.16.31.50;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.10.20.39.21;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.15.08.58.22;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.12.17.15.40;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.02.17.17.50;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.25.18.49.49;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.21.17.17.05;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.19.18.52.53;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.09.10.00.17;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.08.11.05.36;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.03.17.19.54;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.22.06.25.07;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.13.16.37.10;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.27.19.01.59;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.27.20.59.40;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.27.19.45.44;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.17.18.50.54;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.10.20.36.49;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.10.18.14.55;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.10.17.54.50;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.07.19.32.09;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.06.19.33.20;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.06.16.37.03;	author damien;	state Exp;
branches;
next	;


desc
@@


1.54
log
@In iwn(4), fix CID 1199266 "Missing comma in a string array"; only affects
fatal firmware error debug output.
@
text
@/*	$OpenBSD: if_iwnreg.h,v 1.53 2016/04/28 08:28:18 stsp Exp $	*/

/*-
 * Copyright (c) 2007, 2008
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#define IWN_TX_RING_COUNT	256
#define IWN_TX_RING_LOMARK	192
#define IWN_TX_RING_HIMARK	224
#define IWN_RX_RING_COUNT_LOG	6
#define IWN_RX_RING_COUNT	(1 << IWN_RX_RING_COUNT_LOG)

#define IWN4965_NTXQUEUES	16
#define IWN5000_NTXQUEUES	20

#define IWN4965_NDMACHNLS	7
#define IWN5000_NDMACHNLS	8

#define IWN_SRVC_DMACHNL	9

#define IWN_ICT_SIZE		4096
#define IWN_ICT_COUNT		(IWN_ICT_SIZE / sizeof (uint32_t))

/* Maximum number of DMA segments for TX. */
#define IWN_MAX_SCATTER	20

/* RX buffers must be large enough to hold a full 4K A-MPDU. */
#define IWN_RBUF_SIZE	(4 * 1024)

#if defined(__LP64__)
/* HW supports 36-bit DMA addresses. */
#define IWN_LOADDR(paddr)	((uint32_t)(paddr))
#define IWN_HIADDR(paddr)	(((paddr) >> 32) & 0xf)
#else
#define IWN_LOADDR(paddr)	(paddr)
#define IWN_HIADDR(paddr)	(0)
#endif

/* Base Address Register. */
#define IWN_PCI_BAR0	PCI_MAPREG_START

/*
 * Control and status registers.
 */
#define IWN_HW_IF_CONFIG	0x000
#define IWN_INT_COALESCING	0x004
#define IWN_INT_PERIODIC	0x005	/* use IWN_WRITE_1 */
#define IWN_INT			0x008
#define IWN_INT_MASK		0x00c
#define IWN_FH_INT		0x010
#define IWN_RESET		0x020
#define IWN_GP_CNTRL		0x024
#define IWN_HW_REV		0x028
#define IWN_EEPROM		0x02c
#define IWN_EEPROM_GP		0x030
#define IWN_OTP_GP		0x034
#define IWN_GIO			0x03c
#define IWN_GP_DRIVER		0x050
#define IWN_UCODE_GP1_CLR	0x05c
#define IWN_LED			0x094
#define IWN_DRAM_INT_TBL	0x0a0
#define IWN_SHADOW_REG_CTRL	0x0a8
#define IWN_GIO_CHICKEN		0x100
#define IWN_ANA_PLL		0x20c
#define IWN_HW_REV_WA		0x22c
#define IWN_DBG_HPET_MEM	0x240
#define IWN_DBG_LINK_PWR_MGMT	0x250
#define IWN_MEM_RADDR		0x40c
#define IWN_MEM_WADDR		0x410
#define IWN_MEM_WDATA		0x418
#define IWN_MEM_RDATA		0x41c
#define IWN_PRPH_WADDR  	0x444
#define IWN_PRPH_RADDR   	0x448
#define IWN_PRPH_WDATA  	0x44c
#define IWN_PRPH_RDATA   	0x450
#define IWN_HBUS_TARG_WRPTR	0x460

/*
 * Flow-Handler registers.
 */
#define IWN_FH_TFBD_CTRL0(qid)		(0x1900 + (qid) * 8)
#define IWN_FH_TFBD_CTRL1(qid)		(0x1904 + (qid) * 8)
#define IWN_FH_KW_ADDR			0x197c
#define IWN_FH_SRAM_ADDR(qid)		(0x19a4 + (qid) * 4)
#define IWN_FH_CBBC_QUEUE(qid)		(0x19d0 + (qid) * 4)
#define IWN_FH_STATUS_WPTR		0x1bc0
#define IWN_FH_RX_BASE			0x1bc4
#define IWN_FH_RX_WPTR			0x1bc8
#define IWN_FH_RX_CONFIG		0x1c00
#define IWN_FH_RX_STATUS		0x1c44
#define IWN_FH_TX_CONFIG(qid)		(0x1d00 + (qid) * 32)
#define IWN_FH_TXBUF_STATUS(qid)	(0x1d08 + (qid) * 32)
#define IWN_FH_TX_CHICKEN		0x1e98
#define IWN_FH_TX_STATUS		0x1eb0

/*
 * TX scheduler registers.
 */
#define IWN_SCHED_BASE			0xa02c00
#define IWN_SCHED_SRAM_ADDR		(IWN_SCHED_BASE + 0x000)
#define IWN5000_SCHED_DRAM_ADDR		(IWN_SCHED_BASE + 0x008)
#define IWN4965_SCHED_DRAM_ADDR		(IWN_SCHED_BASE + 0x010)
#define IWN5000_SCHED_TXFACT		(IWN_SCHED_BASE + 0x010)
#define IWN4965_SCHED_TXFACT		(IWN_SCHED_BASE + 0x01c)
#define IWN4965_SCHED_QUEUE_RDPTR(qid)	(IWN_SCHED_BASE + 0x064 + (qid) * 4)
#define IWN5000_SCHED_QUEUE_RDPTR(qid)	(IWN_SCHED_BASE + 0x068 + (qid) * 4)
#define IWN4965_SCHED_QCHAIN_SEL	(IWN_SCHED_BASE + 0x0d0)
#define IWN4965_SCHED_INTR_MASK		(IWN_SCHED_BASE + 0x0e4)
#define IWN5000_SCHED_QCHAIN_SEL	(IWN_SCHED_BASE + 0x0e8)
#define IWN4965_SCHED_QUEUE_STATUS(qid)	(IWN_SCHED_BASE + 0x104 + (qid) * 4)
#define IWN5000_SCHED_INTR_MASK		(IWN_SCHED_BASE + 0x108)
#define IWN5000_SCHED_QUEUE_STATUS(qid)	(IWN_SCHED_BASE + 0x10c + (qid) * 4)
#define IWN5000_SCHED_AGGR_SEL		(IWN_SCHED_BASE + 0x248)

/*
 * Offsets in TX scheduler's SRAM.
 */
#define IWN4965_SCHED_CTX_OFF		0x380
#define IWN4965_SCHED_CTX_LEN		416
#define IWN4965_SCHED_QUEUE_OFFSET(qid)	(0x380 + (qid) * 8)
#define IWN4965_SCHED_TRANS_TBL(qid)	(0x500 + (qid) * 2)
#define IWN5000_SCHED_CTX_OFF		0x600
#define IWN5000_SCHED_CTX_LEN		520
#define IWN5000_SCHED_QUEUE_OFFSET(qid)	(0x600 + (qid) * 8)
#define IWN5000_SCHED_TRANS_TBL(qid)	(0x7e0 + (qid) * 2)

/*
 * NIC internal memory offsets.
 */
#define IWN_APMG_CLK_CTRL	0x3000
#define IWN_APMG_CLK_EN		0x3004
#define IWN_APMG_CLK_DIS	0x3008
#define IWN_APMG_PS		0x300c
#define IWN_APMG_DIGITAL_SVR	0x3058
#define IWN_APMG_ANALOG_SVR	0x306c
#define IWN_APMG_PCI_STT	0x3010
#define IWN_BSM_WR_CTRL		0x3400
#define IWN_BSM_WR_MEM_SRC	0x3404
#define IWN_BSM_WR_MEM_DST	0x3408
#define IWN_BSM_WR_DWCOUNT	0x340c
#define IWN_BSM_DRAM_TEXT_ADDR	0x3490
#define IWN_BSM_DRAM_TEXT_SIZE	0x3494
#define IWN_BSM_DRAM_DATA_ADDR	0x3498
#define IWN_BSM_DRAM_DATA_SIZE	0x349c
#define IWN_BSM_SRAM_BASE	0x3800

/* Possible flags for register IWN_HW_IF_CONFIG. */
#define IWN_HW_IF_CONFIG_4965_R		(1 <<  4)
#define IWN_HW_IF_CONFIG_MAC_SI		(1 <<  8)
#define IWN_HW_IF_CONFIG_RADIO_SI	(1 <<  9)
#define IWN_HW_IF_CONFIG_EEPROM_LOCKED	(1 << 21)
#define IWN_HW_IF_CONFIG_NIC_READY	(1 << 22)
#define IWN_HW_IF_CONFIG_HAP_WAKE_L1A	(1 << 23)
#define IWN_HW_IF_CONFIG_PREPARE_DONE	(1 << 25)
#define IWN_HW_IF_CONFIG_PREPARE	(1 << 27)

/* Possible values for register IWN_INT_PERIODIC. */
#define IWN_INT_PERIODIC_DIS	0x00
#define IWN_INT_PERIODIC_ENA	0xff

/* Possible flags for registers IWN_PRPH_RADDR/IWN_PRPH_WADDR. */
#define IWN_PRPH_DWORD	((sizeof (uint32_t) - 1) << 24)

/* Possible values for IWN_BSM_WR_MEM_DST. */
#define IWN_FW_TEXT_BASE	0x00000000
#define IWN_FW_DATA_BASE	0x00800000

/* Possible flags for register IWN_RESET. */
#define IWN_RESET_NEVO			(1U << 0)
#define IWN_RESET_SW			(1U << 7)
#define IWN_RESET_MASTER_DISABLED	(1U << 8)
#define IWN_RESET_STOP_MASTER		(1U << 9)
#define IWN_RESET_LINK_PWR_MGMT_DIS	(1U << 31)

/* Possible flags for register IWN_GP_CNTRL. */
#define IWN_GP_CNTRL_MAC_ACCESS_ENA	(1 << 0)
#define IWN_GP_CNTRL_MAC_CLOCK_READY	(1 << 0)
#define IWN_GP_CNTRL_INIT_DONE		(1 << 2)
#define IWN_GP_CNTRL_MAC_ACCESS_REQ	(1 << 3)
#define IWN_GP_CNTRL_SLEEP		(1 << 4)
#define IWN_GP_CNTRL_RFKILL		(1 << 27)

/* Possible flags for register IWN_HW_REV. */
#define IWN_HW_REV_TYPE_SHIFT	4
#define IWN_HW_REV_TYPE_MASK	0x000001f0
#define IWN_HW_REV_TYPE_4965	0
#define IWN_HW_REV_TYPE_5300	2
#define IWN_HW_REV_TYPE_5350	3
#define IWN_HW_REV_TYPE_5150	4
#define IWN_HW_REV_TYPE_5100	5
#define IWN_HW_REV_TYPE_1000	6
#define IWN_HW_REV_TYPE_6000	7
#define IWN_HW_REV_TYPE_6050	8
#define IWN_HW_REV_TYPE_6005	11
#define IWN_HW_REV_TYPE_2030	12
#define IWN_HW_REV_TYPE_2000	16
#define IWN_HW_REV_TYPE_105	17
#define IWN_HW_REV_TYPE_135	18


/* Possible flags for register IWN_GIO_CHICKEN. */
#define IWN_GIO_CHICKEN_L1A_NO_L0S_RX	(1 << 23)
#define IWN_GIO_CHICKEN_DIS_L0S_TIMER	(1 << 29)

/* Possible flags for register IWN_GIO. */
#define IWN_GIO_L0S_ENA		(1 << 1)

/* Possible flags for register IWN_GP_DRIVER. */
#define IWN_GP_DRIVER_RADIO_3X3_HYB	(0 << 0)
#define IWN_GP_DRIVER_RADIO_2X2_HYB	(1 << 0)
#define IWN_GP_DRIVER_RADIO_2X2_IPA	(2 << 0)
#define IWN_GP_DRIVER_CALIB_VER6	(1 << 2)
#define IWN_GP_DRIVER_6050_1X2		(1 << 3)
#define IWN_GP_DRIVER_RADIO_IQ_INVERT	(1 << 7)

/* Possible flags for register IWN_UCODE_GP1_CLR. */
#define IWN_UCODE_GP1_RFKILL		(1 << 1)
#define IWN_UCODE_GP1_CMD_BLOCKED	(1 << 2)
#define IWN_UCODE_GP1_CTEMP_STOP_RF	(1 << 3)

/* Possible flags/values for register IWN_LED. */
#define IWN_LED_BSM_CTRL	(1 << 5)
#define IWN_LED_OFF		0x00000038
#define IWN_LED_ON		0x00000078

/* Possible flags for register IWN_DRAM_INT_TBL. */
#define IWN_DRAM_INT_TBL_WRAP_CHECK	(1U << 27)
#define IWN_DRAM_INT_TBL_ENABLE		(1U << 31)

/* Possible values for register IWN_ANA_PLL. */
#define IWN_ANA_PLL_INIT	0x00880300

/* Possible flags for register IWN_FH_RX_STATUS. */
#define IWN_FH_RX_STATUS_IDLE	(1 << 24)

/* Possible flags for register IWN_BSM_WR_CTRL. */
#define IWN_BSM_WR_CTRL_START_EN	(1U << 30)
#define IWN_BSM_WR_CTRL_START		(1U << 31)

/* Possible flags for register IWN_INT. */
#define IWN_INT_ALIVE		(1U <<  0)
#define IWN_INT_WAKEUP		(1U <<  1)
#define IWN_INT_SW_RX		(1U <<  3)
#define IWN_INT_CT_REACHED	(1U <<  6)
#define IWN_INT_RF_TOGGLED	(1U <<  7)
#define IWN_INT_SW_ERR		(1U << 25)
#define IWN_INT_SCHED		(1U << 26)
#define IWN_INT_FH_TX		(1U << 27)
#define IWN_INT_RX_PERIODIC	(1U << 28)
#define IWN_INT_HW_ERR		(1U << 29)
#define IWN_INT_FH_RX		(1U << 31)

/* Shortcut. */
#define IWN_INT_MASK_DEF						\
	(IWN_INT_SW_ERR | IWN_INT_HW_ERR | IWN_INT_FH_TX |		\
	 IWN_INT_FH_RX | IWN_INT_ALIVE | IWN_INT_WAKEUP |		\
	 IWN_INT_SW_RX | IWN_INT_CT_REACHED | IWN_INT_RF_TOGGLED)

/* Possible flags for register IWN_FH_INT. */
#define IWN_FH_INT_TX_CHNL(x)	(1 << (x))
#define IWN_FH_INT_RX_CHNL(x)	(1 << ((x) + 16))
#define IWN_FH_INT_HI_PRIOR	(1 << 30)
/* Shortcuts for the above. */
#define IWN_FH_INT_TX							\
	(IWN_FH_INT_TX_CHNL(0) | IWN_FH_INT_TX_CHNL(1))
#define IWN_FH_INT_RX							\
	(IWN_FH_INT_RX_CHNL(0) | IWN_FH_INT_RX_CHNL(1) | IWN_FH_INT_HI_PRIOR)

/* Possible flags/values for register IWN_FH_TX_CONFIG. */
#define IWN_FH_TX_CONFIG_DMA_PAUSE		0
#define IWN_FH_TX_CONFIG_DMA_ENA		(1U << 31)
#define IWN_FH_TX_CONFIG_CIRQ_HOST_ENDTFD	(1U << 20)

/* Possible flags/values for register IWN_FH_TXBUF_STATUS. */
#define IWN_FH_TXBUF_STATUS_TBNUM(x)	((x) << 20)
#define IWN_FH_TXBUF_STATUS_TBIDX(x)	((x) << 12)
#define IWN_FH_TXBUF_STATUS_TFBD_VALID	3

/* Possible flags for register IWN_FH_TX_CHICKEN. */
#define IWN_FH_TX_CHICKEN_SCHED_RETRY	(1 << 1)

/* Possible flags for register IWN_FH_TX_STATUS. */
#define IWN_FH_TX_STATUS_IDLE(chnl)	(1 << ((chnl) + 16))

/* Possible flags for register IWN_FH_RX_CONFIG. */
#define IWN_FH_RX_CONFIG_ENA		(1U << 31)
#define IWN_FH_RX_CONFIG_NRBD(x)	((x) << 20)
#define IWN_FH_RX_CONFIG_RB_SIZE_8K	(1U << 16)
#define IWN_FH_RX_CONFIG_SINGLE_FRAME	(1U << 15)
#define IWN_FH_RX_CONFIG_IRQ_DST_HOST	(1U << 12)
#define IWN_FH_RX_CONFIG_RB_TIMEOUT(x)	((x) << 4) /* units 32 usec */
#define IWN_FH_RX_CONFIG_IGN_RXF_EMPTY	(1U <<  2)

/* Possible flags for register IWN_FH_TX_CONFIG. */
#define IWN_FH_TX_CONFIG_DMA_ENA	(1U << 31)
#define IWN_FH_TX_CONFIG_DMA_CREDIT_ENA	(1U <<  3)

/* Possible flags for register IWN_EEPROM. */
#define IWN_EEPROM_READ_VALID	(1 << 0)
#define IWN_EEPROM_CMD		(1 << 1)

/* Possible flags for register IWN_EEPROM_GP. */
#define IWN_EEPROM_GP_IF_OWNER	0x00000180

/* Possible flags for register IWN_OTP_GP. */
#define IWN_OTP_GP_DEV_SEL_OTP		(1 << 16)
#define IWN_OTP_GP_RELATIVE_ACCESS	(1 << 17)
#define IWN_OTP_GP_ECC_CORR_STTS	(1 << 20)
#define IWN_OTP_GP_ECC_UNCORR_STTS	(1 << 21)

/* Possible flags for register IWN_SCHED_QUEUE_STATUS. */
#define IWN4965_TXQ_STATUS_ACTIVE	0x0007fc01
#define IWN4965_TXQ_STATUS_INACTIVE	0x0007fc00
#define IWN4965_TXQ_STATUS_AGGR_ENA	(1 << 5 | 1 << 8)
#define IWN4965_TXQ_STATUS_CHGACT	(1 << 10)
#define IWN5000_TXQ_STATUS_ACTIVE	0x00ff0018
#define IWN5000_TXQ_STATUS_INACTIVE	0x00ff0010
#define IWN5000_TXQ_STATUS_CHGACT	(1 << 19)

/* Possible flags for registers IWN_APMG_CLK_*. */
#define IWN_APMG_CLK_CTRL_DMA_CLK_RQT	(1 <<  9)
#define IWN_APMG_CLK_CTRL_BSM_CLK_RQT	(1 << 11)

/* Possible flags for register IWN_APMG_PS. */
#define IWN_APMG_PS_EARLY_PWROFF_DIS	(1 << 22)
#define IWN_APMG_PS_PWR_SRC(x)		((x) << 24)
#define IWN_APMG_PS_PWR_SRC_VMAIN	0
#define IWN_APMG_PS_PWR_SRC_VAUX	2
#define IWN_APMG_PS_PWR_SRC_MASK	IWN_APMG_PS_PWR_SRC(3)
#define IWN_APMG_PS_RESET_REQ		(1 << 26)

/* Possible flags for register IWN_APMG_DIGITAL_SVR. */
#define IWN_APMG_DIGITAL_SVR_VOLTAGE(x)		(((x) & 0xf) << 5)
#define IWN_APMG_DIGITAL_SVR_VOLTAGE_MASK	\
	IWN_APMG_DIGITAL_SVR_VOLTAGE(0xf)
#define IWN_APMG_DIGITAL_SVR_VOLTAGE_1_32	\
	IWN_APMG_DIGITAL_SVR_VOLTAGE(3)

/* Possible flags for IWN_APMG_PCI_STT. */
#define IWN_APMG_PCI_STT_L1A_DIS	(1 << 11)

/* Possible flags for register IWN_BSM_DRAM_TEXT_SIZE. */
#define IWN_FW_UPDATED	(1U << 31)

#define IWN_SCHED_WINSZ		64
#define IWN_SCHED_LIMIT		64
#define IWN4965_SCHED_COUNT	512
#define IWN5000_SCHED_COUNT	(IWN_TX_RING_COUNT + IWN_SCHED_WINSZ)
#define IWN4965_SCHEDSZ		(IWN4965_NTXQUEUES * IWN4965_SCHED_COUNT * 2)
#define IWN5000_SCHEDSZ		(IWN5000_NTXQUEUES * IWN5000_SCHED_COUNT * 2)

struct iwn_tx_desc {
	uint8_t		reserved1[3];
	uint8_t		nsegs;
	struct {
		uint32_t	addr;
		uint16_t	len;
	} __packed	segs[IWN_MAX_SCATTER];
	/* Pad to 128 bytes. */
	uint32_t	reserved2;
} __packed;

struct iwn_rx_status {
	uint16_t	closed_count;
	uint16_t	closed_rx_count;
	uint16_t	finished_count;
	uint16_t	finished_rx_count;
	uint32_t	reserved[2];
} __packed;

struct iwn_rx_desc {
	uint32_t	len;
#define IWN_RX_DESC_LEN_MASK		0x00003fff
#define IWN_RX_DESC_LEN_SHIFT		0
#define IWN_RX_DESC_FLAG_FLUSH_RB_REQ	0x80000000
#define IWN_RX_DESC_FLAG_IGNORE_TC	0x40000000
#define IWN_RX_DESC_FLAG_FAST_IRQ	0x20000000

	uint8_t		type;
#define IWN_UC_READY			  1
#define IWN_ADD_NODE_DONE		 24
#define IWN_TX_DONE			 28
#define IWN5000_CALIBRATION_RESULT	102
#define IWN5000_CALIBRATION_DONE	103
#define IWN_START_SCAN			130
#define IWN_STOP_SCAN			132
#define IWN_RX_STATISTICS		156
#define IWN_BEACON_STATISTICS		157
#define IWN_STATE_CHANGED		161
#define IWN_BEACON_MISSED		162
#define IWN_RX_PHY			192
#define IWN_MPDU_RX_DONE		193
#define IWN_RX_DONE			195
#define IWN_RX_COMPRESSED_BA		197

	uint8_t		flags; /* XXX iwlwifi calls this "group_id" */
	uint8_t		idx;
	uint8_t		qid;
} __packed;

/* Possible RX status flags. */
#define IWN_RX_NO_CRC_ERR	(1 <<  0)
#define IWN_RX_NO_OVFL_ERR	(1 <<  1)
/* Shortcut for the above. */
#define IWN_RX_NOERROR	(IWN_RX_NO_CRC_ERR | IWN_RX_NO_OVFL_ERR)
#define IWN_RX_MPDU_MIC_OK	(1 <<  6)
#define IWN_RX_CIPHER_MASK	(7 <<  8)
#define IWN_RX_CIPHER_CCMP	(2 <<  8)
#define IWN_RX_MPDU_DEC		(1 << 11)
#define IWN_RX_DECRYPT_MASK	(3 << 11)
#define IWN_RX_DECRYPT_OK	(3 << 11)

struct iwn_tx_cmd {
	uint8_t	code;
#define IWN_CMD_RXON			 16
#define IWN_CMD_RXON_ASSOC		 17
#define IWN_CMD_EDCA_PARAMS		 19
#define IWN_CMD_TIMING			 20
#define IWN_CMD_ADD_NODE		 24
#define IWN_CMD_TX_DATA			 28
#define IWN_CMD_LINK_QUALITY		 78
#define IWN_CMD_SET_LED			 72
#define IWN5000_CMD_WIMAX_COEX		 90
#define IWN5000_CMD_CALIB_CONFIG	101
#define IWN_CMD_SET_POWER_MODE		119
#define IWN_CMD_SCAN			128
#define IWN_CMD_TXPOWER_DBM		149
#define IWN_CMD_TXPOWER			151
#define IWN5000_CMD_TX_ANT_CONFIG	152
#define IWN_CMD_BT_COEX			155
#define IWN_CMD_GET_STATISTICS		156
#define IWN_CMD_SET_CRITICAL_TEMP	164
#define IWN_CMD_SET_SENSITIVITY		168
#define IWN_CMD_PHY_CALIB		176
#define IWN_CMD_BT_COEX_PRIOTABLE	204
#define IWN_CMD_BT_COEX_PROT		205

	uint8_t	flags;
	uint8_t	idx;
	uint8_t	qid;
	uint8_t	data[136];
} __packed;

/* Antenna flags, used in various commands. */
#define IWN_ANT_A	(1 << 0)
#define IWN_ANT_B	(1 << 1)
#define IWN_ANT_C	(1 << 2)
/* Shortcuts. */
#define IWN_ANT_AB	(IWN_ANT_A | IWN_ANT_B)
#define IWN_ANT_BC	(IWN_ANT_B | IWN_ANT_C)
#define IWN_ANT_ABC	(IWN_ANT_A | IWN_ANT_B | IWN_ANT_C)

/* Structure for command IWN_CMD_RXON. */
struct iwn_rxon {
	uint8_t		myaddr[IEEE80211_ADDR_LEN];
	uint16_t	reserved1;
	uint8_t		bssid[IEEE80211_ADDR_LEN];
	uint16_t	reserved2;
	uint8_t		wlap[IEEE80211_ADDR_LEN];
	uint16_t	reserved3;
	uint8_t		mode;
#define IWN_MODE_HOSTAP		1
#define IWN_MODE_STA		3
#define IWN_MODE_IBSS		4
#define IWN_MODE_MONITOR	6

	uint8_t		air;
	uint16_t	rxchain;
#define IWN_RXCHAIN_DRIVER_FORCE	(1 << 0)
#define IWN_RXCHAIN_VALID(x)		(((x) & IWN_ANT_ABC) << 1)
#define IWN_RXCHAIN_FORCE_SEL(x)	(((x) & IWN_ANT_ABC) << 4)
#define IWN_RXCHAIN_FORCE_MIMO_SEL(x)	(((x) & IWN_ANT_ABC) << 7)
#define IWN_RXCHAIN_IDLE_COUNT(x)	((x) << 10)
#define IWN_RXCHAIN_MIMO_COUNT(x)	((x) << 12)
#define IWN_RXCHAIN_MIMO_FORCE		(1 << 14)

	uint8_t		ofdm_mask;
	uint8_t		cck_mask;
	uint16_t	associd;
	uint32_t	flags;
#define IWN_RXON_24GHZ		(1 <<  0)
#define IWN_RXON_CCK		(1 <<  1)
#define IWN_RXON_AUTO		(1 <<  2)
#define IWN_RXON_TGG_PROT	(1 <<  3)
#define IWN_RXON_SHSLOT		(1 <<  4)
#define IWN_RXON_SHPREAMBLE	(1 <<  5)
#define IWN_RXON_NODIVERSITY	(1 <<  7)
#define IWN_RXON_ANTENNA_A	(1 <<  8)
#define IWN_RXON_ANTENNA_B	(1 <<  9)
#define IWN_RXON_TSF		(1 << 15)
#define IWN_RXON_HT_HT40MINUS	(1 << 22)
#define IWN_RXON_HT_PROTMODE(x)	((x) << 23) /* 2 bits */
#define IWN_RXON_HT_CHANMODE_PURE40	(1 << 25)
#define IWN_RXON_HT_CHANMODE_MIXED2040	(2 << 25)
#define IWN_RXON_CTS_TO_SELF	(1 << 30)

	uint32_t	filter;
#define IWN_FILTER_PROMISC	(1 << 0)
#define IWN_FILTER_CTL		(1 << 1)
#define IWN_FILTER_MULTICAST	(1 << 2)
#define IWN_FILTER_NODECRYPT	(1 << 3)
#define IWN_FILTER_BSS		(1 << 5)
#define IWN_FILTER_BEACON	(1 << 6)

	uint8_t		chan;
	uint8_t		reserved4;
	uint8_t		ht_single_mask;
	uint8_t		ht_dual_mask;
	/* The following fields are for >=5000 Series only. */
	uint8_t		ht_triple_mask;
	uint8_t		reserved5;
	uint16_t	acquisition;
	uint16_t	reserved6;
} __packed;

/* Structure for command IWN_CMD_RXON_ASSOC. */
struct iwn_rxon_assoc {
	uint32_t flags;
	uint32_t filter;
	uint8_t ofdm_mask;
	uint8_t cck_mask;
	uint16_t reserved1;
	uint8_t ht_single_mask;
	uint8_t ht_dual_mask;
	uint8_t ht_triple_mask;
	uint8_t reserved2;
	uint16_t rxchain;
	uint16_t acquisition;
	uint32_t reserved3;
} __packed;

#define IWN4965_RXONSZ	(sizeof (struct iwn_rxon) - 6)
#define IWN5000_RXONSZ	(sizeof (struct iwn_rxon))

/* Structure for command IWN_CMD_ASSOCIATE. */
struct iwn_assoc {
	uint32_t	flags;
	uint32_t	filter;
	uint8_t		ofdm_mask;
	uint8_t		cck_mask;
	uint16_t	reserved;
} __packed;

/* Structure for command IWN_CMD_EDCA_PARAMS. */
struct iwn_edca_params {
	uint32_t	flags;
#define IWN_EDCA_UPDATE	(1 << 0)
#define IWN_EDCA_TXOP	(1 << 4)

	struct {
		uint16_t	cwmin;
		uint16_t	cwmax;
		uint8_t		aifsn;
		uint8_t		reserved;
		uint16_t	txoplimit;
	} __packed	ac[EDCA_NUM_AC];
} __packed;

/* Structure for command IWN_CMD_TIMING. */
struct iwn_cmd_timing {
	uint64_t	tstamp;
	uint16_t	bintval;
	uint16_t	atim;
	uint32_t	binitval;
	uint16_t	lintval;
	uint16_t	reserved;
} __packed;

/* Structure for command IWN_CMD_ADD_NODE. */
struct iwn_node_info {
	uint8_t		control;
#define IWN_NODE_UPDATE		(1 << 0)

	uint8_t		reserved1[3];

	uint8_t		macaddr[IEEE80211_ADDR_LEN];
	uint16_t	reserved2;
	uint8_t		id;
#define IWN_ID_BSS		 0
#define IWN5000_ID_BROADCAST	15
#define IWN4965_ID_BROADCAST	31

	uint8_t		flags;
#define IWN_FLAG_SET_KEY		(1 << 0)
#define IWN_FLAG_SET_DISABLE_TID	(1 << 1)
#define IWN_FLAG_SET_TXRATE		(1 << 2)
#define IWN_FLAG_SET_ADDBA		(1 << 3)
#define IWN_FLAG_SET_DELBA		(1 << 4)

	uint16_t	reserved3;
	uint16_t	kflags;
#define IWN_KFLAG_CCMP		(1 <<  1)
#define IWN_KFLAG_MAP		(1 <<  3)
#define IWN_KFLAG_KID(kid)	((kid) << 8)
#define IWN_KFLAG_INVALID	(1 << 11)
#define IWN_KFLAG_GROUP		(1 << 14)

	uint8_t		tsc2;	/* TKIP TSC2 */
	uint8_t		reserved4;
	uint16_t	ttak[5];
	uint8_t		kid;
	uint8_t		reserved5;
	uint8_t		key[16];
	/* The following 3 fields are for 5000 Series only. */
	uint64_t	tsc;
	uint8_t		rxmic[IEEE80211_TKIP_MICLEN];
	uint8_t		txmic[IEEE80211_TKIP_MICLEN];

	uint32_t	htflags;
#define IWN_AMDPU_SIZE_FACTOR(x)	((x) << 19)
#define IWN_AMDPU_SIZE_FACTOR_MASK	((0x3) << 19)
#define IWN_AMDPU_DENSITY(x)		((x) << 23)
#define IWN_AMDPU_DENSITY_MASK		((0x7) << 23)

	uint32_t	htmask;
	uint16_t	disable_tid;
	uint16_t	reserved6;
	uint8_t		addba_tid;
	uint8_t		delba_tid;
	uint16_t	addba_ssn;
	uint32_t	reserved7;
} __packed;

struct iwn4965_node_info {
	uint8_t		control;
	uint8_t		reserved1[3];
	uint8_t		macaddr[IEEE80211_ADDR_LEN];
	uint16_t	reserved2;
	uint8_t		id;
	uint8_t		flags;
	uint16_t	reserved3;
	uint16_t	kflags;
	uint8_t		tsc2;	/* TKIP TSC2 */
	uint8_t		reserved4;
	uint16_t	ttak[5];
	uint8_t		kid;
	uint8_t		reserved5;
	uint8_t		key[16];
	uint32_t	htflags;
	uint32_t	htmask;
	uint16_t	disable_tid;
	uint16_t	reserved6;
	uint8_t		addba_tid;
	uint8_t		delba_tid;
	uint16_t	addba_ssn;
	uint32_t	reserved7;
} __packed;

#define IWN_RFLAG_MCS		(1 << 0)
#define IWN_RFLAG_CCK		(1 << 1)
#define IWN_RFLAG_GREENFIELD	(1 << 2)
#define IWN_RFLAG_HT40		(1 << 3)
#define IWN_RFLAG_DUPLICATE	(1 << 4)
#define IWN_RFLAG_SGI		(1 << 5)
#define IWN_RFLAG_ANT(x)	((x) << 6)

/* Structure for command IWN_CMD_TX_DATA. */
struct iwn_cmd_data {
	uint16_t	len;
	uint16_t	lnext;
	uint32_t	flags;
#define IWN_TX_NEED_PROTECTION	(1 <<  0)	/* 5000 only */
#define IWN_TX_NEED_RTS		(1 <<  1)
#define IWN_TX_NEED_CTS		(1 <<  2)
#define IWN_TX_NEED_ACK		(1 <<  3)
#define IWN_TX_LINKQ		(1 <<  4)
#define IWN_TX_IMM_BA		(1 <<  6)
#define IWN_TX_FULL_TXOP	(1 <<  7)
#define IWN_TX_BT_DISABLE	(1 << 12)	/* bluetooth coexistence */
#define IWN_TX_AUTO_SEQ		(1 << 13)
#define IWN_TX_MORE_FRAG	(1 << 14)
#define IWN_TX_INSERT_TSTAMP	(1 << 16)
#define IWN_TX_NEED_PADDING	(1 << 20)

	uint32_t	scratch;
	uint8_t		plcp;
	uint8_t		rflags;
	uint16_t	xrflags;

	uint8_t		id;
	uint8_t		security;
#define IWN_CIPHER_WEP40	1
#define IWN_CIPHER_CCMP		2
#define IWN_CIPHER_TKIP		3
#define IWN_CIPHER_WEP104	9

	uint8_t		linkq;
	uint8_t		reserved2;
	uint8_t		key[16];
	uint16_t	fnext;
	uint16_t	reserved3;
	uint32_t	lifetime;
#define IWN_LIFETIME_INFINITE	0xffffffff

	uint32_t	loaddr;
	uint8_t		hiaddr;
	uint8_t		rts_ntries;
	uint8_t		data_ntries;
	uint8_t		tid;
	uint16_t	timeout;
	uint16_t	txop;
} __packed;

/* Structure for command IWN_CMD_LINK_QUALITY. */
#define IWN_MAX_TX_RETRIES	16
struct iwn_cmd_link_quality {
	uint8_t		id;
	uint8_t		reserved1;
	uint16_t	ctl;
	uint8_t		flags;
	uint8_t		mimo;
	uint8_t		antmsk_1stream;
	uint8_t		antmsk_2stream;
	uint8_t		ridx[EDCA_NUM_AC];
	uint16_t	ampdu_limit;
	uint8_t		ampdu_threshold;
	uint8_t		ampdu_max;
#define IWN_AMPDU_MAX_UNLIMITED	0
#define IWN_AMPDU_MAX_NO_AGG	1
#define IWN_AMPDU_MAX		63
	uint32_t	reserved2;
	struct {
		uint8_t		plcp;
		uint8_t		rflags;
		uint16_t	xrflags;
	} __packed	retry[IWN_MAX_TX_RETRIES];
	uint32_t	reserved3;
} __packed;

/* Structure for command IWN_CMD_SET_LED. */
struct iwn_cmd_led {
	uint32_t	unit;	/* multiplier (in usecs) */
	uint8_t		which;
#define IWN_LED_ACTIVITY	1
#define IWN_LED_LINK		2

	uint8_t		off;
	uint8_t		on;
	uint8_t		reserved;
} __packed;

/* Structure for command IWN5000_CMD_WIMAX_COEX. */
struct iwn5000_wimax_coex {
	uint32_t	flags;
#define IWN_WIMAX_COEX_STA_TABLE_VALID		(1 << 0)
#define IWN_WIMAX_COEX_UNASSOC_WA_UNMASK	(1 << 2)
#define IWN_WIMAX_COEX_ASSOC_WA_UNMASK		(1 << 3)
#define IWN_WIMAX_COEX_ENABLE			(1 << 7)

	struct iwn5000_wimax_event {
		uint8_t	request;
		uint8_t	window;
		uint8_t	reserved;
		uint8_t	flags;
	} __packed	events[16];
} __packed;

/* Structures for command IWN5000_CMD_CALIB_CONFIG. */
struct iwn5000_calib_elem {
	uint32_t	enable;
	uint32_t	start;
#define IWN5000_CALIB_DC	(1 << 1)

	uint32_t	send;
	uint32_t	apply;
	uint32_t	reserved;
} __packed;

struct iwn5000_calib_status {
	struct iwn5000_calib_elem	once;
	struct iwn5000_calib_elem	perd;
	uint32_t			flags;
} __packed;

struct iwn5000_calib_config {
	struct iwn5000_calib_status	ucode;
	struct iwn5000_calib_status	driver;
	uint32_t			reserved;
} __packed;

/* Structure for command IWN_CMD_SET_POWER_MODE. */
struct iwn_pmgt_cmd {
	uint16_t	flags;
#define IWN_PS_ALLOW_SLEEP	(1 << 0)
#define IWN_PS_NOTIFY		(1 << 1)
#define IWN_PS_SLEEP_OVER_DTIM	(1 << 2)
#define IWN_PS_PCI_PMGT		(1 << 3)
#define IWN_PS_FAST_PD		(1 << 4)

	uint8_t		keepalive;
	uint8_t		debug;
	uint32_t	rxtimeout;
	uint32_t	txtimeout;
	uint32_t	intval[5];
	uint32_t	beacons;
} __packed;

/* Structures for command IWN_CMD_SCAN. */
struct iwn_scan_essid {
	uint8_t	id;
	uint8_t	len;
	uint8_t	data[IEEE80211_NWID_LEN];
} __packed;

struct iwn_scan_hdr {
	uint16_t	len;
	uint8_t		reserved1;
	uint8_t		nchan;
	uint16_t	quiet_time;
	uint16_t	quiet_threshold;
	uint16_t	crc_threshold;
	uint16_t	rxchain;
	uint32_t	max_svc;	/* background scans */
	uint32_t	pause_svc;	/* background scans */
	uint32_t	flags;
	uint32_t	filter;

	/* Followed by a struct iwn_cmd_data. */
	/* Followed by an array of 20 structs iwn_scan_essid. */
	/* Followed by probe request body. */
	/* Followed by an array of ``nchan'' structs iwn_scan_chan. */
} __packed;

struct iwn_scan_chan {
	uint32_t	flags;
#define IWN_CHAN_PASSIVE	(0 << 0)
#define IWN_CHAN_ACTIVE		(1 << 0)
#define IWN_CHAN_NPBREQS(x)	(((1 << (x)) - 1) << 1)

	uint16_t	chan;
	uint8_t		rf_gain;
	uint8_t		dsp_gain;
	uint16_t	active;		/* msecs */
	uint16_t	passive;	/* msecs */
} __packed;

/* Maximum size of a scan command. */
#define IWN_SCAN_MAXSZ	(MCLBYTES - 4)

/*
 * For active scan, listen ACTIVE_DWELL_TIME (msec) on each channel after
 * sending probe req.  This should be set long enough to hear probe responses
 * from more than one AP.
 */
#define IWN_ACTIVE_DWELL_TIME_2GHZ	(30)	/* all times in msec */
#define IWN_ACTIVE_DWELL_TIME_5GHZ	(20)
#define IWN_ACTIVE_DWELL_FACTOR_2GHZ	(3)
#define IWN_ACTIVE_DWELL_FACTOR_5GHZ	(2)

/*
 * For passive scan, listen PASSIVE_DWELL_TIME (msec) on each channel.
 * Must be set longer than active dwell time.
 * For the most reliable scan, set > AP beacon interval (typically 100msec).
 */
#define IWN_PASSIVE_DWELL_TIME_2GHZ	(20)	/* all times in msec */
#define IWN_PASSIVE_DWELL_TIME_5GHZ	(10)
#define IWN_PASSIVE_DWELL_BASE		(100)
#define IWN_CHANNEL_TUNE_TIME		(5)

/*
 * If active scanning is requested but a certain channel is
 * marked passive, we can do active scanning if we detect
 * transmissions.
 *
 * There is an issue with some firmware versions that triggers
 * a sysassert on a "good CRC threshold" of zero (== disabled),
 * on a radar channel even though this means that we should NOT
 * send probes.
 *
 * The "good CRC threshold" is the number of frames that we
 * need to receive during our dwell time on a channel before
 * sending out probes -- setting this to a huge value will
 * mean we never reach it, but at the same time work around
 * the aforementioned issue. Thus use IWN_GOOD_CRC_TH_NEVER
 * here instead of IWN_GOOD_CRC_TH_DISABLED.
 *
 * This was fixed in later versions along with some other
 * scan changes, and the threshold behaves as a flag in those
 * versions.
 */
#define IWN_GOOD_CRC_TH_DISABLED	0
#define IWN_GOOD_CRC_TH_DEFAULT		htole16(1)
#define IWN_GOOD_CRC_TH_NEVER		htole16(0xffff)

/* Structure for command IWN_CMD_TXPOWER (4965AGN only.) */
#define IWN_RIDX_MAX	32
struct iwn4965_cmd_txpower {
	uint8_t		band;
	uint8_t		reserved1;
	uint8_t		chan;
	uint8_t		reserved2;
	struct {
		uint8_t	rf_gain[2];
		uint8_t	dsp_gain[2];
	} __packed	power[IWN_RIDX_MAX + 1];
} __packed;

/* Structure for command IWN_CMD_TXPOWER_DBM (5000 Series only.) */
struct iwn5000_cmd_txpower {
	int8_t	global_limit;	/* in half-dBm */
#define IWN5000_TXPOWER_AUTO		0x7f
#define IWN5000_TXPOWER_MAX_DBM		16

	uint8_t	flags;
#define IWN5000_TXPOWER_NO_CLOSED	(1 << 6)

	int8_t	srv_limit;	/* in half-dBm */
	uint8_t	reserved;
} __packed;

/* Structures for command IWN_CMD_BLUETOOTH. */
struct iwn_bluetooth {
	uint8_t		flags;
#define IWN_BT_COEX_CHAN_ANN	(1 << 0)
#define IWN_BT_COEX_BT_PRIO	(1 << 1)
#define IWN_BT_COEX_2_WIRE	(1 << 2)

	uint8_t		lead_time;
#define IWN_BT_LEAD_TIME_DEF	30

	uint8_t		max_kill;
#define IWN_BT_MAX_KILL_DEF	5

	uint8_t		reserved;
	uint32_t	kill_ack;
	uint32_t	kill_cts;
} __packed;

struct iwn6000_btcoex_config {
	uint8_t		flags;
#define IWN_BT_COEX6000_CHAN_INHIBITION	1
#define IWN_BT_COEX6000_MODE_MASK	((1 << 3) | (1 << 4) | (1 << 5))
#define IWN_BT_COEX6000_MODE_SHIFT	3
#define IWN_BT_COEX6000_MODE_DISABLED	0
#define IWN_BT_COEX6000_MODE_LEGACY_2W	1
#define IWN_BT_COEX6000_MODE_3W		2
#define IWN_BT_COEX6000_MODE_4W		3
#define IWN_BT_UCODE_DEFAULT		(1<<6)
#define IWN_BT_SYNC_2_BT_DISABLE	(1<<7)

	uint8_t		lead_time;
	uint8_t		max_kill;
	uint8_t		bt3_t7_timer;
	uint32_t	kill_ack;
	uint32_t	kill_cts;
	uint8_t		sample_time;
	uint8_t		bt3_t2_timer;
	uint16_t	bt4_reaction;
	uint32_t	lookup_table[12];
	uint16_t	bt4_decision;
	uint16_t	valid;
	uint8_t		prio_boost;
	uint8_t		tx_prio_boost;
	uint16_t	rx_prio_boost;
} __packed;

struct iwn2000_btcoex_config {
	uint8_t		flags;		/* same as in iwn6000_btcoex_config */
	uint8_t		lead_time;
	uint8_t		max_kill;
	uint8_t		bt3_t7_timer;
	uint32_t	kill_ack;
	uint32_t	kill_cts;
	uint8_t		sample_time;
	uint8_t		bt3_t2_timer;
	uint16_t	bt4_reaction;
	uint32_t	lookup_table[12];
	uint16_t	bt4_decision;
	uint16_t	valid;
    	uint32_t	prio_boost;
	uint8_t		reserved;
	uint8_t		tx_prio_boost;
	uint16_t	rx_prio_boost;
} __packed;

/* Structure for command IWN_CMD_BT_COEX_PRIOTABLE */
struct iwn_btcoex_priotable {
	uint8_t		calib_init1;
	uint8_t		calib_init2;
	uint8_t		calib_periodic_low1;
	uint8_t		calib_periodic_low2;
	uint8_t		calib_periodic_high1;
	uint8_t		calib_periodic_high2;
	uint8_t		dtim;
	uint8_t		scan52;
	uint8_t		scan24;
	uint8_t		reserved[7];
} __packed;

/* Structure for command IWN_CMD_BT_COEX_PROT */
struct iwn_btcoex_prot {
	uint8_t		open;
	uint8_t		type;
	uint8_t		reserved[2];
} __packed;

/* Structure for command IWN_CMD_SET_CRITICAL_TEMP. */
struct iwn_critical_temp {
	uint32_t	reserved;
	uint32_t	tempM;
	uint32_t	tempR;
/* degK <-> degC conversion macros. */
#define IWN_CTOK(c)	((c) + 273)
#define IWN_KTOC(k)	((k) - 273)
#define IWN_CTOMUK(c)	(((c) * 1000000) + 273150000)
} __packed;

/* Structures for command IWN_CMD_SET_SENSITIVITY. */
struct iwn_sensitivity_cmd {
	uint16_t	which;
#define IWN_SENSITIVITY_DEFAULTTBL	0
#define IWN_SENSITIVITY_WORKTBL		1

	uint16_t	energy_cck;
	uint16_t	energy_ofdm;
	uint16_t	corr_ofdm_x1;
	uint16_t	corr_ofdm_mrc_x1;
	uint16_t	corr_cck_mrc_x4;
	uint16_t	corr_ofdm_x4;
	uint16_t	corr_ofdm_mrc_x4;
	uint16_t	corr_barker;
	uint16_t	corr_barker_mrc;
	uint16_t	corr_cck_x4;
	uint16_t	energy_ofdm_th;
} __packed;

struct iwn_enhanced_sensitivity_cmd {
	uint16_t	which;
	uint16_t	energy_cck;
	uint16_t	energy_ofdm;
	uint16_t	corr_ofdm_x1;
	uint16_t	corr_ofdm_mrc_x1;
	uint16_t	corr_cck_mrc_x4;
	uint16_t	corr_ofdm_x4;
	uint16_t	corr_ofdm_mrc_x4;
	uint16_t	corr_barker;
	uint16_t	corr_barker_mrc;
	uint16_t	corr_cck_x4;
	uint16_t	energy_ofdm_th;
	/* "Enhanced" part. */
	uint16_t	ina_det_ofdm;
	uint16_t	ina_det_cck;
	uint16_t	corr_11_9_en;
	uint16_t	ofdm_det_slope_mrc;
	uint16_t	ofdm_det_icept_mrc;
	uint16_t	ofdm_det_slope;
	uint16_t	ofdm_det_icept;
	uint16_t	cck_det_slope_mrc;
	uint16_t	cck_det_icept_mrc;
	uint16_t	cck_det_slope;
	uint16_t	cck_det_icept;
	uint16_t	reserved;
} __packed;

/* Structures for command IWN_CMD_PHY_CALIB. */
struct iwn_phy_calib {
	uint8_t	code;
#define IWN4965_PHY_CALIB_DIFF_GAIN		 7
#define IWN5000_PHY_CALIB_DC			 8
#define IWN5000_PHY_CALIB_LO			 9
#define IWN5000_PHY_CALIB_TX_IQ			11
#define IWN5000_PHY_CALIB_CRYSTAL		15
#define IWN5000_PHY_CALIB_BASE_BAND		16
#define IWN5000_PHY_CALIB_TX_IQ_PERIODIC	17
#define IWN5000_PHY_CALIB_RESET_NOISE_GAIN	18
#define IWN5000_PHY_CALIB_NOISE_GAIN		19

#define IWN6000_PHY_CALIB_TEMP_OFFSET		18
#define IWN2000_PHY_CALIB_TEMP_OFFSET		18

#define IWN5000_PHY_CALIB_MAX			253

	uint8_t	group;
	uint8_t	ngroups;
	uint8_t	isvalid;
} __packed;

struct iwn5000_phy_calib_crystal {
	uint8_t	code;
	uint8_t	group;
	uint8_t	ngroups;
	uint8_t	isvalid;

	uint8_t	cap_pin[2];
	uint8_t	reserved[2];
} __packed;

struct iwn6000_phy_calib_temp_offset {
	uint8_t		code;
	uint8_t		group;
	uint8_t		ngroups;
	uint8_t		isvalid;
	int16_t		offset;
#define IWN_DEFAULT_TEMP_OFFSET	2700

	uint16_t	reserved;
} __packed;

struct iwn2000_phy_calib_temp_offset {
	uint8_t		code;
	uint8_t		group;
	uint8_t		ngroups;
	uint8_t		isvalid;
	int16_t		offset_high;
	int16_t		offset_low;
	int16_t		burnt_voltage_ref;
	int16_t		reserved;
} __packed;

struct iwn_phy_calib_gain {
	uint8_t	code;
	uint8_t	group;
	uint8_t	ngroups;
	uint8_t	isvalid;

	int8_t	gain[3];
	uint8_t	reserved;
} __packed;

/* Structure for command IWN_CMD_SPECTRUM_MEASUREMENT. */
struct iwn_spectrum_cmd {
	uint16_t	len;
	uint8_t		token;
	uint8_t		id;
	uint8_t		origin;
	uint8_t		periodic;
	uint16_t	timeout;
	uint32_t	start;
	uint32_t	reserved1;
	uint32_t	flags;
	uint32_t	filter;
	uint16_t	nchan;
	uint16_t	reserved2;
	struct {
		uint32_t	duration;
		uint8_t		chan;
		uint8_t		type;
#define IWN_MEASUREMENT_BASIC		(1 << 0)
#define IWN_MEASUREMENT_CCA		(1 << 1)
#define IWN_MEASUREMENT_RPI_HISTOGRAM	(1 << 2)
#define IWN_MEASUREMENT_NOISE_HISTOGRAM	(1 << 3)
#define IWN_MEASUREMENT_FRAME		(1 << 4)
#define IWN_MEASUREMENT_IDLE		(1 << 7)

		uint16_t	reserved;
	} __packed	chan[10];
} __packed;

/* Structure for IWN_UC_READY notification. */
#define IWN_NATTEN_GROUPS	5
struct iwn_ucode_info {
	uint8_t		minor;
	uint8_t		major;
	uint16_t	reserved1;
	uint8_t		revision[8];
	uint8_t		type;
	uint8_t		subtype;
#define IWN_UCODE_RUNTIME	0
#define IWN_UCODE_INIT		9

	uint16_t	reserved2;
	uint32_t	logptr;
	uint32_t	errptr;
	uint32_t	tstamp;
	uint32_t	valid;

	/* The following fields are for UCODE_INIT only. */
	int32_t		volt;
	struct {
		int32_t	chan20MHz;
		int32_t	chan40MHz;
	} __packed	temp[4];
	int32_t		atten[IWN_NATTEN_GROUPS][2];
} __packed;

/* Structures for IWN_TX_DONE notification. */
struct iwn4965_tx_stat {
	uint8_t		nframes;
	uint8_t		btkillcnt;
	uint8_t		rtsfailcnt;
	uint8_t		ackfailcnt;
	uint8_t		rate;
	uint8_t		rflags;
	uint16_t	xrflags;
	uint16_t	duration;
	uint16_t	reserved;
	uint32_t	power[2];
	uint32_t	status;
} __packed;

struct iwn5000_tx_stat {
	uint8_t		nframes;
	uint8_t		btkillcnt;
	uint8_t		rtsfailcnt;
	uint8_t		ackfailcnt;
	uint8_t		rate;
	uint8_t		rflags;
	uint16_t	xrflags;
	uint16_t	duration;
	uint16_t	reserved;
	uint32_t	power[2];
	uint32_t	info;
	uint16_t	seq;
	uint16_t	len;
	uint8_t		tlc;
	uint8_t		ratid;
	uint8_t		fc[2];
	uint16_t	status;
	uint16_t	sequence;
} __packed;

/* Structure for IWN_BEACON_MISSED notification. */
struct iwn_beacon_missed {
	uint32_t	consecutive;
	uint32_t	total;
	uint32_t	expected;
	uint32_t	received;
} __packed;

/* Structure for IWN_MPDU_RX_DONE notification. */
struct iwn_rx_mpdu {
	uint16_t	len;
	uint16_t	reserved;
} __packed;

/* Structures for IWN_RX_DONE and IWN_MPDU_RX_DONE notifications. */
struct iwn4965_rx_phystat {
	uint16_t	antenna;
	uint16_t	agc;
	uint8_t		rssi[6];
} __packed;

struct iwn5000_rx_phystat {
	uint32_t	reserved1;
	uint32_t	agc;
	uint16_t	rssi[3];
} __packed;

struct iwn_rx_stat {
	uint8_t		phy_len;
	uint8_t		cfg_phy_len;
#define IWN_STAT_MAXLEN	20

	uint8_t		id;
	uint8_t		reserved1;
	uint64_t	tstamp;
	uint32_t	beacon;
	uint16_t	flags;
#define IWN_STAT_FLAG_24GHZ		(1 << 0)
#define IWN_STAT_FLAG_MOD_CCK		(1 << 1)
#define IWN_STAT_FLAG_SHPREAMBLE	(1 << 2)
#define IWN_STAT_FLAG_NARROW_BAND	(1 << 3)
#define IWN_STAT_FLAG_ANT(x)		((x) << 4) /* 3 bits */
#define IWN_STAT_FLAG_AGG		(1 << 7)

	uint16_t	chan;
	uint8_t		phybuf[32];
	uint8_t		rate;
	uint8_t		rflags;
	uint16_t	xrflags;
	uint16_t	len;
	uint16_t	reserve3;
} __packed;

#define IWN_RSSI_TO_DBM	44

/* Structure for IWN_RX_COMPRESSED_BA notification. */
struct iwn_compressed_ba {
	uint8_t		macaddr[IEEE80211_ADDR_LEN];
	uint16_t	reserved;
	uint8_t		id;
	uint8_t		tid;
	uint16_t	seq;
	uint64_t	bitmap;
	uint16_t	qid;
	uint16_t	ssn;
} __packed;

/* Structure for IWN_START_SCAN notification. */
struct iwn_start_scan {
	uint64_t	tstamp;
	uint32_t	tbeacon;
	uint8_t		chan;
	uint8_t		band;
	uint16_t	reserved;
	uint32_t	status;
} __packed;

/* Structure for IWN_STOP_SCAN notification. */
struct iwn_stop_scan {
	uint8_t		nchan;
	uint8_t		status;
	uint8_t		reserved;
	uint8_t		chan;
	uint64_t	tsf;
} __packed;

/* Structure for IWN_SPECTRUM_MEASUREMENT notification. */
struct iwn_spectrum_notif {
	uint8_t		id;
	uint8_t		token;
	uint8_t		idx;
	uint8_t		state;
#define IWN_MEASUREMENT_START	0
#define IWN_MEASUREMENT_STOP	1

	uint32_t	start;
	uint8_t		band;
	uint8_t		chan;
	uint8_t		type;
	uint8_t		reserved1;
	uint32_t	cca_ofdm;
	uint32_t	cca_cck;
	uint32_t	cca_time;
	uint8_t		basic;
	uint8_t		reserved2[3];
	uint32_t	ofdm[8];
	uint32_t	cck[8];
	uint32_t	stop;
	uint32_t	status;
#define IWN_MEASUREMENT_OK		0
#define IWN_MEASUREMENT_CONCURRENT	1
#define IWN_MEASUREMENT_CSA_CONFLICT	2
#define IWN_MEASUREMENT_TGH_CONFLICT	3
#define IWN_MEASUREMENT_STOPPED		6
#define IWN_MEASUREMENT_TIMEOUT		7
#define IWN_MEASUREMENT_FAILED		8
} __packed;

/* Structures for IWN_{RX,BEACON}_STATISTICS notification. */
struct iwn_rx_phy_stats {
	uint32_t	ina;
	uint32_t	fina;
	uint32_t	bad_plcp;
	uint32_t	bad_crc32;
	uint32_t	overrun;
	uint32_t	eoverrun;
	uint32_t	good_crc32;
	uint32_t	fa;
	uint32_t	bad_fina_sync;
	uint32_t	sfd_timeout;
	uint32_t	fina_timeout;
	uint32_t	no_rts_ack;
	uint32_t	rxe_limit;
	uint32_t	ack;
	uint32_t	cts;
	uint32_t	ba_resp;
	uint32_t	dsp_kill;
	uint32_t	bad_mh;
	uint32_t	rssi_sum;
	uint32_t	reserved;
} __packed;

struct iwn_rx_general_stats {
	uint32_t	bad_cts;
	uint32_t	bad_ack;
	uint32_t	not_bss;
	uint32_t	filtered;
	uint32_t	bad_chan;
	uint32_t	beacons;
	uint32_t	missed_beacons;
	uint32_t	adc_saturated;	/* time in 0.8us */
	uint32_t	ina_searched;	/* time in 0.8us */
	uint32_t	noise[3];
	uint32_t	flags;
	uint32_t	load;
	uint32_t	fa;
	uint32_t	rssi[3];
	uint32_t	energy[3];
} __packed;

struct iwn_rx_ht_phy_stats {
	uint32_t	bad_plcp;
	uint32_t	overrun;
	uint32_t	eoverrun;
	uint32_t	good_crc32;
	uint32_t	bad_crc32;
	uint32_t	bad_mh;
	uint32_t	good_ampdu_crc32;
	uint32_t	ampdu;
	uint32_t	fragment;
	uint32_t	reserved;
} __packed;

struct iwn_rx_stats {
	struct iwn_rx_phy_stats		ofdm;
	struct iwn_rx_phy_stats		cck;
	struct iwn_rx_general_stats	general;
	struct iwn_rx_ht_phy_stats	ht;
} __packed;

struct iwn_tx_stats {
	uint32_t	preamble;
	uint32_t	rx_detected;
	uint32_t	bt_defer;
	uint32_t	bt_kill;
	uint32_t	short_len;
	uint32_t	cts_timeout;
	uint32_t	ack_timeout;
	uint32_t	exp_ack;
	uint32_t	ack;
	uint32_t	msdu;
	uint32_t	busrt_err1;
	uint32_t	burst_err2;
	uint32_t	cts_collision;
	uint32_t	ack_collision;
	uint32_t	ba_timeout;
	uint32_t	ba_resched;
	uint32_t	query_ampdu;
	uint32_t	query;
	uint32_t	query_ampdu_frag;
	uint32_t	query_mismatch;
	uint32_t	not_ready;
	uint32_t	underrun;
	uint32_t	bt_ht_kill;
	uint32_t	rx_ba_resp;
	uint32_t	reserved[2];
} __packed;

struct iwn_general_stats {
	uint32_t	temp;
	uint32_t	temp_m;
	uint32_t	burst_check;
	uint32_t	burst;
	uint32_t	reserved1[4];
	uint32_t	sleep;
	uint32_t	slot_out;
	uint32_t	slot_idle;
	uint32_t	ttl_tstamp;
	uint32_t	tx_ant_a;
	uint32_t	tx_ant_b;
	uint32_t	exec;
	uint32_t	probe;
	uint32_t	reserved2[2];
	uint32_t	rx_enabled;
	uint32_t	reserved3[3];
} __packed;

struct iwn_stats {
	uint32_t			flags;
	struct iwn_rx_stats		rx;
	struct iwn_tx_stats		tx;
	struct iwn_general_stats	general;
} __packed;


/* Firmware error dump. */
struct iwn_fw_dump {
	uint32_t	valid;
	uint32_t	id;
	uint32_t	pc;
	uint32_t	branch_link[2];
	uint32_t	interrupt_link[2];
	uint32_t	error_data[2];
	uint32_t	src_line;
	uint32_t	tsf;
	uint32_t	time[2];
} __packed;

/* TLV firmware header. */
struct iwn_fw_tlv_hdr {
	uint32_t	zero;	/* Always 0, to differentiate from legacy. */
	uint32_t	signature;
#define IWN_FW_SIGNATURE	0x0a4c5749	/* "IWL\n" */

	uint8_t		descr[64];
	uint32_t	rev;
#define IWN_FW_API(x)	(((x) >> 8) & 0xff)

	uint32_t	build;
	uint64_t	altmask;
} __packed;

/* TLV header. */
struct iwn_fw_tlv {
	uint16_t	type;
#define IWN_FW_TLV_MAIN_TEXT		1
#define IWN_FW_TLV_MAIN_DATA		2
#define IWN_FW_TLV_INIT_TEXT		3
#define IWN_FW_TLV_INIT_DATA		4
#define IWN_FW_TLV_BOOT_TEXT		5
#define IWN_FW_TLV_PBREQ_MAXLEN		6
#define IWN_FW_TLV_ENH_SENS		14
#define IWN_FW_TLV_PHY_CALIB		15
#define IWN_FW_TLV_FLAGS		18

	uint16_t	alt;
	uint32_t	len;
} __packed;

#define IWN4965_FW_TEXT_MAXSZ	( 96 * 1024)
#define IWN4965_FW_DATA_MAXSZ	( 40 * 1024)
#define IWN5000_FW_TEXT_MAXSZ	(256 * 1024)
#define IWN5000_FW_DATA_MAXSZ	( 80 * 1024)
#define IWN_FW_BOOT_TEXT_MAXSZ	1024
#define IWN4965_FWSZ		(IWN4965_FW_TEXT_MAXSZ + IWN4965_FW_DATA_MAXSZ)
#define IWN5000_FWSZ		IWN5000_FW_TEXT_MAXSZ

/*
 * Microcode flags TLV (18.)
 */

/**
 * enum iwn_ucode_tlv_flag - ucode API flags
 * @@IWN_UCODE_TLV_FLAGS_PAN: This is PAN capable microcode; this previously
 *      was a separate TLV but moved here to save space.
 * @@IWN_UCODE_TLV_FLAGS_NEWSCAN: new uCode scan behaviour on hidden SSID,
 *      treats good CRC threshold as a boolean
 * @@IWN_UCODE_TLV_FLAGS_MFP: This uCode image supports MFP (802.11w).
 * @@IWN_UCODE_TLV_FLAGS_P2P: This uCode image supports P2P.
 * @@IWN_UCODE_TLV_FLAGS_DW_BC_TABLE: The SCD byte count table is in DWORDS
 * @@IWN_UCODE_TLV_FLAGS_UAPSD: This uCode image supports uAPSD
 * @@IWN_UCODE_TLV_FLAGS_SHORT_BL: 16 entries of black list instead of 64 in scan
 *      offload profile config command.
 * @@IWN_UCODE_TLV_FLAGS_RX_ENERGY_API: supports rx signal strength api
 * @@IWN_UCODE_TLV_FLAGS_TIME_EVENT_API_V2: using the new time event API.
 * @@IWN_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS: D3 image supports up to six
 *      (rather than two) IPv6 addresses
 * @@IWN_UCODE_TLV_FLAGS_BF_UPDATED: new beacon filtering API
 * @@IWN_UCODE_TLV_FLAGS_NO_BASIC_SSID: not sending a probe with the SSID element
 *      from the probe request template.
 * @@IWN_UCODE_TLV_FLAGS_D3_CONTINUITY_API: modified D3 API to allow keeping
 *      connection when going back to D0
 * @@IWN_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL: new NS offload (small version)
 * @@IWN_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE: new NS offload (large version)
 * @@IWN_UCODE_TLV_FLAGS_SCHED_SCAN: this uCode image supports scheduled scan.
 * @@IWN_UCODE_TLV_FLAGS_STA_KEY_CMD: new ADD_STA and ADD_STA_KEY command API
 * @@IWN_UCODE_TLV_FLAGS_DEVICE_PS_CMD: support device wide power command
 *      containing CAM (Continuous Active Mode) indication.
 */
enum iwn_ucode_tlv_flag {
	IWN_UCODE_TLV_FLAGS_PAN			= (1 << 0),
	IWN_UCODE_TLV_FLAGS_NEWSCAN		= (1 << 1),
	IWN_UCODE_TLV_FLAGS_MFP			= (1 << 2),
	IWN_UCODE_TLV_FLAGS_P2P			= (1 << 3),
	IWN_UCODE_TLV_FLAGS_DW_BC_TABLE		= (1 << 4),
	IWN_UCODE_TLV_FLAGS_NEWBT_COEX		= (1 << 5),
	IWN_UCODE_TLV_FLAGS_UAPSD		= (1 << 6),
	IWN_UCODE_TLV_FLAGS_SHORT_BL		= (1 << 7),
	IWN_UCODE_TLV_FLAGS_RX_ENERGY_API	= (1 << 8),
	IWN_UCODE_TLV_FLAGS_TIME_EVENT_API_V2	= (1 << 9),
	IWN_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS	= (1 << 10),
	IWN_UCODE_TLV_FLAGS_BF_UPDATED		= (1 << 11),
	IWN_UCODE_TLV_FLAGS_NO_BASIC_SSID	= (1 << 12),
	IWN_UCODE_TLV_FLAGS_D3_CONTINUITY_API	= (1 << 14),
	IWN_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL	= (1 << 15),
	IWN_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE	= (1 << 16),
	IWN_UCODE_TLV_FLAGS_SCHED_SCAN		= (1 << 17),
	IWN_UCODE_TLV_FLAGS_STA_KEY_CMD		= (1 << 19),
	IWN_UCODE_TLV_FLAGS_DEVICE_PS_CMD	= (1 << 20),
};

/*
 * Offsets into EEPROM.
 */
#define IWN_EEPROM_MAC		0x015
#define IWN_EEPROM_SKU_CAP	0x045
#define IWN_EEPROM_RFCFG	0x048
#define IWN4965_EEPROM_DOMAIN	0x060
#define IWN4965_EEPROM_BAND1	0x063
#define IWN5000_EEPROM_REG	0x066
#define IWN5000_EEPROM_CAL	0x067
#define IWN4965_EEPROM_BAND2	0x072
#define IWN4965_EEPROM_BAND3	0x080
#define IWN4965_EEPROM_BAND4	0x08d
#define IWN4965_EEPROM_BAND5	0x099
#define IWN4965_EEPROM_BAND6	0x0a0
#define IWN4965_EEPROM_BAND7	0x0a8
#define IWN4965_EEPROM_MAXPOW	0x0e8
#define IWN4965_EEPROM_VOLTAGE	0x0e9
#define IWN4965_EEPROM_BANDS	0x0ea
/* Indirect offsets. */
#define IWN5000_EEPROM_DOMAIN	0x001
#define IWN5000_EEPROM_BAND1	0x004
#define IWN5000_EEPROM_BAND2	0x013
#define IWN5000_EEPROM_BAND3	0x021
#define IWN5000_EEPROM_BAND4	0x02e
#define IWN5000_EEPROM_BAND5	0x03a
#define IWN5000_EEPROM_BAND6	0x041
#define IWN5000_EEPROM_BAND7	0x049
#define IWN6000_EEPROM_ENHINFO	0x054
#define IWN5000_EEPROM_CRYSTAL	0x128
#define IWN5000_EEPROM_TEMP	0x12a
#define IWN5000_EEPROM_VOLT	0x12b
#define IWN2000_EEPROM_RAWTEMP	0x12b

/* Possible flags for IWN_EEPROM_SKU_CAP. */
#define IWN_EEPROM_SKU_CAP_11N	(1 << 6)
#define IWN_EEPROM_SKU_CAP_AMT	(1 << 7)
#define IWN_EEPROM_SKU_CAP_IPAN	(1 << 8)

/* Possible flags for IWN_EEPROM_RFCFG. */
#define IWN_RFCFG_TYPE(x)	(((x) >>  0) & 0x3)
#define IWN_RFCFG_STEP(x)	(((x) >>  2) & 0x3)
#define IWN_RFCFG_DASH(x)	(((x) >>  4) & 0x3)
#define IWN_RFCFG_TXANTMSK(x)	(((x) >>  8) & 0xf)
#define IWN_RFCFG_RXANTMSK(x)	(((x) >> 12) & 0xf)

struct iwn_eeprom_chan {
	uint8_t	flags;
#define IWN_EEPROM_CHAN_VALID	(1 << 0)
#define IWN_EEPROM_CHAN_IBSS	(1 << 1)
#define IWN_EEPROM_CHAN_ACTIVE	(1 << 3)
#define IWN_EEPROM_CHAN_RADAR	(1 << 4)

	int8_t	maxpwr;
} __packed;

struct iwn_eeprom_enhinfo {
	uint16_t	chan;
	int8_t		chain[3];	/* max power in half-dBm */
	uint8_t		reserved;
	int8_t		mimo2;		/* max power in half-dBm */
	int8_t		mimo3;		/* max power in half-dBm */
} __packed;

struct iwn5000_eeprom_calib_hdr {
	uint8_t		version;
	uint8_t		pa_type;
	uint16_t	volt;
} __packed;

#define IWN_NSAMPLES	3
struct iwn4965_eeprom_chan_samples {
	uint8_t	num;
	struct {
		uint8_t temp;
		uint8_t	gain;
		uint8_t	power;
		int8_t	pa_det;
	}	samples[2][IWN_NSAMPLES];
} __packed;

#define IWN_NBANDS	8
struct iwn4965_eeprom_band {
	uint8_t	lo;	/* low channel number */
	uint8_t	hi;	/* high channel number */
	struct	iwn4965_eeprom_chan_samples chans[2];
} __packed;

/*
 * Offsets of channels descriptions in EEPROM.
 */
static const uint32_t iwn4965_regulatory_bands[IWN_NBANDS] = {
	IWN4965_EEPROM_BAND1,
	IWN4965_EEPROM_BAND2,
	IWN4965_EEPROM_BAND3,
	IWN4965_EEPROM_BAND4,
	IWN4965_EEPROM_BAND5,
	IWN4965_EEPROM_BAND6,
	IWN4965_EEPROM_BAND7
};

static const uint32_t iwn5000_regulatory_bands[IWN_NBANDS] = {
	IWN5000_EEPROM_BAND1,
	IWN5000_EEPROM_BAND2,
	IWN5000_EEPROM_BAND3,
	IWN5000_EEPROM_BAND4,
	IWN5000_EEPROM_BAND5,
	IWN5000_EEPROM_BAND6,
	IWN5000_EEPROM_BAND7
};

#define IWN_CHAN_BANDS_COUNT	 7
#define IWN_MAX_CHAN_PER_BAND	14
static const struct iwn_chan_band {
	uint8_t	nchan;
	uint8_t	chan[IWN_MAX_CHAN_PER_BAND];
} iwn_bands[] = {
	/* 20MHz channels, 2GHz band. */
	{ 14, { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 } },
	/* 20MHz channels, 5GHz band. */
	{ 13, { 183, 184, 185, 187, 188, 189, 192, 196, 7, 8, 11, 12, 16 } },
	{ 12, { 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64 } },
	{ 11, { 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140 } },
	{  6, { 145, 149, 153, 157, 161, 165 } },
	/* 40MHz channels (primary channels), 2GHz band. */
	{  7, { 1, 2, 3, 4, 5, 6, 7 } },
	/* 40MHz channels (primary channels), 5GHz band. */
	{ 11, { 36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157 } }
};

#define IWN1000_OTP_NBLOCKS	3 
#define IWN6000_OTP_NBLOCKS	4 
#define IWN6050_OTP_NBLOCKS	7

/* HW rate indices. */
#define IWN_RIDX_CCK1	0
#define IWN_RIDX_OFDM6	4

#define IWN_PLCP_INVALID 0xff

static const struct iwn_rate {
	uint8_t	rate;
	uint8_t	plcp;
	uint8_t	flags;
	uint8_t	ht_plcp;
	uint8_t	ht_flags;
} iwn_rates[IWN_RIDX_MAX + 1] = {
		/* Legacy */		/* HT */ 
	{   2,  10, IWN_RFLAG_CCK,	IWN_PLCP_INVALID, 0 },
	{   4,  20, IWN_RFLAG_CCK,	IWN_PLCP_INVALID, 0 },
	{  11,  55, IWN_RFLAG_CCK,	IWN_PLCP_INVALID, 0 },
	{  22, 110, IWN_RFLAG_CCK,	IWN_PLCP_INVALID, 0 },
	{  12, 0xd, 0,			0, IWN_RFLAG_MCS    },
	{  18, 0xf, 0, 			IWN_PLCP_INVALID, 0 },
	{  24, 0x5, 0, 			1, IWN_RFLAG_MCS    },
	{  36, 0x7, 0, 			2, IWN_RFLAG_MCS,   },
	{  48, 0x9, 0,			3, IWN_RFLAG_MCS,   },
	{  72, 0xb, 0,			4, IWN_RFLAG_MCS,   },
	{  96, 0x1, 0, 			5, IWN_RFLAG_MCS,   },
	{ 108, 0x3, 0, 			6, IWN_RFLAG_MCS,   },
	{ 128, IWN_PLCP_INVALID, 0,	7, IWN_RFLAG_MCS,   }
};

/* Convert an MCS index into an iwn_rates[] index. */
const int iwn_mcs2ridx[] = { 4, 6, 7, 8, 9, 10, 11, 12 };

#define IWN4965_MAX_PWR_INDEX	107

/*
 * RF Tx gain values from highest to lowest power (values obtained from
 * the reference driver.)
 */
static const uint8_t iwn4965_rf_gain_2ghz[IWN4965_MAX_PWR_INDEX + 1] = {
	0x3f, 0x3f, 0x3f, 0x3e, 0x3e, 0x3e, 0x3d, 0x3d, 0x3d, 0x3c, 0x3c,
	0x3c, 0x3b, 0x3b, 0x3b, 0x3a, 0x3a, 0x3a, 0x39, 0x39, 0x39, 0x38,
	0x38, 0x38, 0x37, 0x37, 0x37, 0x36, 0x36, 0x36, 0x35, 0x35, 0x35,
	0x34, 0x34, 0x34, 0x33, 0x33, 0x33, 0x32, 0x32, 0x32, 0x31, 0x31,
	0x31, 0x30, 0x30, 0x30, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x04,
	0x04, 0x04, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t iwn4965_rf_gain_5ghz[IWN4965_MAX_PWR_INDEX + 1] = {
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3e, 0x3e, 0x3e, 0x3d, 0x3d, 0x3d,
	0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b, 0x3a, 0x3a, 0x3a, 0x39, 0x39,
	0x39, 0x38, 0x38, 0x38, 0x37, 0x37, 0x37, 0x36, 0x36, 0x36, 0x35,
	0x35, 0x35, 0x34, 0x34, 0x34, 0x33, 0x33, 0x33, 0x32, 0x32, 0x32,
	0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x25, 0x25, 0x25, 0x24, 0x24,
	0x24, 0x23, 0x23, 0x23, 0x22, 0x18, 0x18, 0x17, 0x17, 0x17, 0x16,
	0x16, 0x16, 0x15, 0x15, 0x15, 0x14, 0x14, 0x14, 0x13, 0x13, 0x13,
	0x12, 0x08, 0x08, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06, 0x05, 0x05,
	0x05, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/*
 * DSP pre-DAC gain values from highest to lowest power (values obtained
 * from the reference driver.)
 */
static const uint8_t iwn4965_dsp_gain_2ghz[IWN4965_MAX_PWR_INDEX + 1] = {
	0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68,
	0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e,
	0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62,
	0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68,
	0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e,
	0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62,
	0x6e, 0x68, 0x62, 0x61, 0x60, 0x5f, 0x5e, 0x5d, 0x5c, 0x5b, 0x5a,
	0x59, 0x58, 0x57, 0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50, 0x4f,
	0x4e, 0x4d, 0x4c, 0x4b, 0x4a, 0x49, 0x48, 0x47, 0x46, 0x45, 0x44,
	0x43, 0x42, 0x41, 0x40, 0x3f, 0x3e, 0x3d, 0x3c, 0x3b
};

static const uint8_t iwn4965_dsp_gain_5ghz[IWN4965_MAX_PWR_INDEX + 1] = {
	0x7b, 0x75, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62,
	0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68,
	0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e,
	0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62,
	0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68,
	0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e,
	0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62,
	0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68,
	0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e, 0x68, 0x62, 0x6e,
	0x68, 0x62, 0x6e, 0x68, 0x62, 0x5d, 0x58, 0x53, 0x4e
};

/*
 * Power saving settings (values obtained from the reference driver.)
 */
#define IWN_NDTIMRANGES		3
#define IWN_NPOWERLEVELS	6
static const struct iwn_pmgt {
	uint32_t	rxtimeout;
	uint32_t	txtimeout;
	uint32_t	intval[5];
	int		skip_dtim;
} iwn_pmgt[IWN_NDTIMRANGES][IWN_NPOWERLEVELS] = {
	/* DTIM <= 2 */
	{
	{   0,   0, {  0,  0,  0,  0,  0 }, 0 },	/* CAM */
	{ 200, 500, {  1,  2,  2,  2, -1 }, 0 },	/* PS level 1 */
	{ 200, 300, {  1,  2,  2,  2, -1 }, 0 },	/* PS level 2 */
	{  50, 100, {  2,  2,  2,  2, -1 }, 0 },	/* PS level 3 */
	{  50,  25, {  2,  2,  4,  4, -1 }, 1 },	/* PS level 4 */
	{  25,  25, {  2,  2,  4,  6, -1 }, 2 }		/* PS level 5 */
	},
	/* 3 <= DTIM <= 10 */
	{
	{   0,   0, {  0,  0,  0,  0,  0 }, 0 },	/* CAM */
	{ 200, 500, {  1,  2,  3,  4,  4 }, 0 },	/* PS level 1 */
	{ 200, 300, {  1,  2,  3,  4,  7 }, 0 },	/* PS level 2 */
	{  50, 100, {  2,  4,  6,  7,  9 }, 0 },	/* PS level 3 */
	{  50,  25, {  2,  4,  6,  9, 10 }, 1 },	/* PS level 4 */
	{  25,  25, {  2,  4,  7, 10, 10 }, 2 }		/* PS level 5 */
	},
	/* DTIM >= 11 */
	{
	{   0,   0, {  0,  0,  0,  0,  0 }, 0 },	/* CAM */
	{ 200, 500, {  1,  2,  3,  4, -1 }, 0 },	/* PS level 1 */
	{ 200, 300, {  2,  4,  6,  7, -1 }, 0 },	/* PS level 2 */
	{  50, 100, {  2,  7,  9,  9, -1 }, 0 },	/* PS level 3 */
	{  50,  25, {  2,  7,  9,  9, -1 }, 0 },	/* PS level 4 */
	{  25,  25, {  4,  7, 10, 10, -1 }, 0 }		/* PS level 5 */
	}
};

struct iwn_sensitivity_limits {
	uint32_t	min_ofdm_x1;
	uint32_t	max_ofdm_x1;
	uint32_t	min_ofdm_mrc_x1;
	uint32_t	max_ofdm_mrc_x1;
	uint32_t	min_ofdm_x4;
	uint32_t	max_ofdm_x4;
	uint32_t	min_ofdm_mrc_x4;
	uint32_t	max_ofdm_mrc_x4;
	uint32_t	min_cck_x4;
	uint32_t	max_cck_x4;
	uint32_t	min_cck_mrc_x4;
	uint32_t	max_cck_mrc_x4;
	uint32_t	min_energy_cck;
	uint32_t	energy_cck;
	uint32_t	energy_ofdm;
};

/*
 * RX sensitivity limits (values obtained from the reference driver.)
 */
static const struct iwn_sensitivity_limits iwn4965_sensitivity_limits = {
	105, 140,
	220, 270,
	 85, 120,
	170, 210,
	125, 200,
	200, 400,
	 97,
	100,
	100
};

static const struct iwn_sensitivity_limits iwn5000_sensitivity_limits = {
	120, 120,	/* min = max for performance bug in DSP. */
	240, 240,	/* min = max for performance bug in DSP. */
	 90, 120,
	170, 210,
	125, 200,
	170, 400,
	 95,
	 95,
	 95
};

static const struct iwn_sensitivity_limits iwn5150_sensitivity_limits = {
	105, 105,	/* min = max for performance bug in DSP. */
	220, 220,	/* min = max for performance bug in DSP. */
	 90, 120,
	170, 210,
	125, 200,
	170, 400,
	 95,
	 95,
	 95
};

static const struct iwn_sensitivity_limits iwn1000_sensitivity_limits = {
	120, 155,
	240, 290,
	 90, 120,
	170, 210,
	125, 200,
	170, 400,
	 95,
	 95,
	 95
};

static const struct iwn_sensitivity_limits iwn6000_sensitivity_limits = {
	105, 110,
	192, 232,
	 80, 145,
	128, 232,
	125, 175,
	160, 310,
	 97,
	 97,
	100
};

static const struct iwn_sensitivity_limits iwn2000_sensitivity_limits = {
	105, 110,
	192, 232,
	 80, 145,
	128, 232,
	125, 175,
	160, 310,
	 97,
	 97,
	100
};

/* Map TID to TX scheduler's FIFO. */
static const uint8_t iwn_tid2fifo[] = {
	1, 0, 0, 1, 2, 2, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 3
};

/* WiFi/WiMAX coexist event priority table for 6050. */
static const struct iwn5000_wimax_event iwn6050_wimax_events[] = {
	{ 0x04, 0x03, 0x00, 0x00 },
	{ 0x04, 0x03, 0x00, 0x03 },
	{ 0x04, 0x03, 0x00, 0x03 },
	{ 0x04, 0x03, 0x00, 0x03 },
	{ 0x04, 0x03, 0x00, 0x00 },
	{ 0x04, 0x03, 0x00, 0x07 },
	{ 0x04, 0x03, 0x00, 0x00 },
	{ 0x04, 0x03, 0x00, 0x03 },
	{ 0x04, 0x03, 0x00, 0x03 },
	{ 0x04, 0x03, 0x00, 0x00 },
	{ 0x06, 0x03, 0x00, 0x07 },
	{ 0x04, 0x03, 0x00, 0x00 },
	{ 0x06, 0x06, 0x00, 0x03 },
	{ 0x04, 0x03, 0x00, 0x07 },
	{ 0x04, 0x03, 0x00, 0x00 },
	{ 0x04, 0x03, 0x00, 0x00 }
};

/* Firmware errors. */
static const char * const iwn_fw_errmsg[] = {
	"OK",
	"FAIL",
	"BAD_PARAM",
	"BAD_CHECKSUM",
	"NMI_INTERRUPT_WDG",
	"SYSASSERT",
	"FATAL_ERROR",
	"BAD_COMMAND",
	"HW_ERROR_TUNE_LOCK",
	"HW_ERROR_TEMPERATURE",
	"ILLEGAL_CHAN_FREQ",
	"VCC_NOT_STABLE",
	"FH_ERROR",
	"NMI_INTERRUPT_HOST",
	"NMI_INTERRUPT_ACTION_PT",
	"NMI_INTERRUPT_UNKNOWN",
	"UCODE_VERSION_MISMATCH",
	"HW_ERROR_ABS_LOCK",
	"HW_ERROR_CAL_LOCK_FAIL",
	"NMI_INTERRUPT_INST_ACTION_PT",
	"NMI_INTERRUPT_DATA_ACTION_PT",
	"NMI_TRM_HW_ER",
	"NMI_INTERRUPT_TRM",
	"NMI_INTERRUPT_BREAKPOINT",
	"DEBUG_0",
	"DEBUG_1",
	"DEBUG_2",
	"DEBUG_3",
	"ADVANCED_SYSASSERT"
};

/* Find least significant bit that is set. */
#define IWN_LSB(x)	((((x) - 1) & (x)) ^ (x))

#define IWN_READ(sc, reg)						\
	bus_space_read_4((sc)->sc_st, (sc)->sc_sh, (reg))

#define IWN_WRITE(sc, reg, val)						\
	bus_space_write_4((sc)->sc_st, (sc)->sc_sh, (reg), (val))

#define IWN_WRITE_1(sc, reg, val)					\
	bus_space_write_1((sc)->sc_st, (sc)->sc_sh, (reg), (val))

#define IWN_SETBITS(sc, reg, mask)					\
	IWN_WRITE(sc, reg, IWN_READ(sc, reg) | (mask))

#define IWN_CLRBITS(sc, reg, mask)					\
	IWN_WRITE(sc, reg, IWN_READ(sc, reg) & ~(mask))

#define IWN_BARRIER_WRITE(sc)						\
	bus_space_barrier((sc)->sc_st, (sc)->sc_sh, 0, (sc)->sc_sz,	\
	    BUS_SPACE_BARRIER_WRITE)

#define IWN_BARRIER_READ_WRITE(sc)					\
	bus_space_barrier((sc)->sc_st, (sc)->sc_sh, 0, (sc)->sc_sz,	\
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE)
@


1.53
log
@Add a better implementation of iwn's update_htprot callback which uses
the RXON_ASSOC command instead of clearing and restoring firmware state.
This matches the behaviour of the Linux driver more closely.

However, for now, keep this implementation disabled and do _nothing_ when
HT protection changes. For some unknown reason, updating HT protection
seems to be related to subsequent Tx errors and block ack session instablity.

We'll see how this approach works out in the wild. Please report any issues.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.52 2016/02/05 16:09:19 stsp Exp $	*/
d1977 1
a1977 1
	"NMI_INTERRUPT_BREAKPOINT"
@


1.52
log
@In iwn(4), set max A-MPDU length to 64k instead of 4k and tell the firmware
about A-MPDU spacing. Makes BlockAck happy.
tested by me, tb@@, krw@@, sthen@@, and Henrik Friedrichsen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.51 2016/01/07 23:08:38 stsp Exp $	*/
d527 16
@


1.51
log
@Fix A-MPDU parameters in link quality firmware commands in iwn(4) and iwm(4).
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.50 2016/01/04 13:54:19 stsp Exp $	*/
d608 1
d610 1
d612 1
a612 1
	uint32_t	mask;
d637 1
a637 1
	uint32_t	mask;
@


1.50
log
@Add initial support for 11n mode to the iwn(4) driver.
Only MCS 0 to 7 are supported for now.

Tested by many. There might still be outstanding issues but they now appear
to be rare. I'm putting this in so that additional fixes can be developed
and tested more easily if required. This diff is already quite large for
one commit.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.49 2014/09/09 18:56:24 sthen Exp $	*/
d713 3
@


1.49
log
@fix remaining spaces/tabs issues in #define lines
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.48 2014/09/09 18:55:08 sthen Exp $	*/
d304 1
a304 1
#define IWN_FH_RX_CONFIG_RB_TIMEOUT(x)	((x) << 4)
d386 6
d409 1
a409 1
	uint8_t		flags;
d497 1
d504 4
d644 1
d646 4
d1241 2
d1244 3
d1683 2
d1689 2
d1692 14
a1705 13
	{   2,  10, IWN_RFLAG_CCK },
	{   4,  20, IWN_RFLAG_CCK },
	{  11,  55, IWN_RFLAG_CCK },
	{  22, 110, IWN_RFLAG_CCK },
	{  12, 0xd, 0 },
	{  18, 0xf, 0 },
	{  24, 0x5, 0 },
	{  36, 0x7, 0 },
	{  48, 0x9, 0 },
	{  72, 0xb, 0 },
	{  96, 0x1, 0 },
	{ 108, 0x3, 0 },
	{ 120, 0x3, 0 }
d1707 3
@


1.48
log
@Backport https://svnweb.freebsd.org/base?view=revision&revision=258829 to fix
scans with various iwn(4) devices. From Fabian Raetz, testing by Fabian,
Marcin Piotr Pawlowski, Mike Burns, kettenis@@ and myself. ok kettenis@@ with
minor tweaks for whitespace in #define lines which I've done; also I have
done s/IWL/IWN/ in comments as noticed by dcoppa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.47 2014/02/11 19:30:10 kettenis Exp $	*/
d247 1
a247 1
#define	IWN_FH_RX_STATUS_IDLE	(1 << 24)
d907 9
a915 9
#define	IWN_BT_COEX6000_CHAN_INHIBITION	1
#define	IWN_BT_COEX6000_MODE_MASK	((1 << 3) | (1 << 4) | (1 << 5))
#define	IWN_BT_COEX6000_MODE_SHIFT	3
#define	IWN_BT_COEX6000_MODE_DISABLED	0
#define	IWN_BT_COEX6000_MODE_LEGACY_2W	1
#define	IWN_BT_COEX6000_MODE_3W		2
#define	IWN_BT_COEX6000_MODE_4W		3
#define	IWN_BT_UCODE_DEFAULT		(1<<6)
#define	IWN_BT_SYNC_2_BT_DISABLE	(1<<7)
@


1.47
log
@Intel Centrino Wireless-N 2200 (tested) and Wireless-N 105/135 (untested)
support.  Tested by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.46 2014/02/10 19:08:58 kettenis Exp $	*/
d802 1
d816 45
d1456 1
d1469 54
@


1.46
log
@Intel Centrino Wireless-N 2230 support.  From Fabian Raetz, with a little bit
of polishing from yours truly.  Tested by Fabian and Benoit Lecocq.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.45 2013/11/26 20:33:17 deraadt Exp $	*/
d198 1
a198 1
#define IWN_HW_REV_TYPE_MASK	0x000000f0
d209 4
@


1.45
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.44 2013/08/29 19:06:40 syl Exp $	*/
d208 1
d223 1
d857 9
a865 9
#define	IWN_BT_FLAG_COEX6000_CHAN_INHIBITION	1
#define	IWN_BT_FLAG_COEX6000_MODE_MASK		((1 << 3) | (1 << 4) | (1 << 5))
#define	IWN_BT_FLAG_COEX6000_MODE_SHIFT		3
#define	IWN_BT_FLAG_COEX6000_MODE_DISABLED	0
#define	IWN_BT_FLAG_COEX6000_MODE_LEGACY_2W	1
#define	IWN_BT_FLAG_COEX6000_MODE_3W		2
#define	IWN_BT_FLAG_COEX6000_MODE_4W		3
#define	IWN_BT_FLAG_UCODE_DEFAULT		(1<<6)
#define	IWN_BT_FLAG_SYNC_2_BT_DISABLE		(1<<7)
d883 19
a990 2
#define IWN5000_PHY_CALIB_TEMP_OFFSET		18

d994 5
d1014 1
a1014 1
struct iwn5000_phy_calib_temp_offset {
d1025 11
d1404 2
d1451 1
d1749 12
@


1.44
log
@Add support for advanced btcoex. This commit is not really needed
but it reduces the diff against the FreeBSD version.

Tested on:
 My Wifi Link 130.
 jca@@ Wifi Link 5300.
 Jan Stary Wifi Link 4965 (thanks).

Adapted from FreeBSD r220894.

ok mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.43 2011/09/01 18:49:56 kettenis Exp $	*/
d182 5
a186 5
#define IWN_RESET_NEVO			(1 << 0)
#define IWN_RESET_SW			(1 << 7)
#define IWN_RESET_MASTER_DISABLED	(1 << 8)
#define IWN_RESET_STOP_MASTER		(1 << 9)
#define IWN_RESET_LINK_PWR_MGMT_DIS	(1 << 31)
d234 2
a235 2
#define IWN_DRAM_INT_TBL_WRAP_CHECK	(1 << 27)
#define IWN_DRAM_INT_TBL_ENABLE		(1 << 31)
d244 2
a245 2
#define IWN_BSM_WR_CTRL_START_EN	(1 << 30)
#define IWN_BSM_WR_CTRL_START		(1 << 31)
d248 11
a258 11
#define IWN_INT_ALIVE		(1 <<  0)
#define IWN_INT_WAKEUP		(1 <<  1)
#define IWN_INT_SW_RX		(1 <<  3)
#define IWN_INT_CT_REACHED	(1 <<  6)
#define IWN_INT_RF_TOGGLED	(1 <<  7)
#define IWN_INT_SW_ERR		(1 << 25)
#define IWN_INT_SCHED		(1 << 26)
#define IWN_INT_FH_TX		(1 << 27)
#define IWN_INT_RX_PERIODIC	(1 << 28)
#define IWN_INT_HW_ERR		(1 << 29)
#define IWN_INT_FH_RX		(1 << 31)
d278 2
a279 2
#define IWN_FH_TX_CONFIG_DMA_ENA		(1 << 31)
#define IWN_FH_TX_CONFIG_CIRQ_HOST_ENDTFD	(1 << 20)
d293 1
a293 1
#define IWN_FH_RX_CONFIG_ENA		(1 << 31)
d295 3
a297 3
#define IWN_FH_RX_CONFIG_RB_SIZE_8K	(1 << 16)
#define IWN_FH_RX_CONFIG_SINGLE_FRAME	(1 << 15)
#define IWN_FH_RX_CONFIG_IRQ_DST_HOST	(1 << 12)
d299 1
a299 1
#define IWN_FH_RX_CONFIG_IGN_RXF_EMPTY	(1 <<  2)
d302 2
a303 2
#define IWN_FH_TX_CONFIG_DMA_ENA	(1 << 31)
#define IWN_FH_TX_CONFIG_DMA_CREDIT_ENA	(1 <<  3)
d350 1
a350 1
#define IWN_FW_UPDATED	(1 << 31)
@


1.43
log
@The 6005 and 6050-based parts need DC calibration turned on, otherwise the
firmware will crap out, at least on the 6005.  First step to getting my
"Intel Centrino Advanced-N 6205" to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.42 2011/01/09 15:45:37 damien Exp $	*/
d436 2
d835 1
a835 1
/* Structure for command IWN_CMD_BLUETOOTH. */
d851 49
@


1.42
log
@cleanup; change the way opns are attached.
include a fix for Intel Centrino Advanced-N 6250 devices
by Antonio R Nicolosi.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.41 2010/07/20 19:24:31 damien Exp $	*/
d730 2
@


1.41
log
@do not timeout when stopping DMA channels.
from a similar fix to iwlwifi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.40 2010/05/05 19:41:57 damien Exp $	*/
d75 1
d221 1
d860 1
a860 1
/* Structure for command IWN_CMD_SET_SENSITIVITY. */
d879 28
d917 2
d937 11
d1333 1
d1361 5
@


1.40
log
@firmware images in type-length-value format can now offer different
alternatives in a same image.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.39 2010/04/30 16:06:46 damien Exp $	*/
d288 1
a288 2
#define IWN_FH_TX_STATUS_IDLE(chnl)					\
	(1 << ((chnl) + 24) | 1 << ((chnl) + 16))
@


1.39
log
@add support for firmware images in "type-length-value" format.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.38 2010/04/10 08:37:36 damien Exp $	*/
d1262 1
d1265 3
a1267 1
/* Firmware TLV fields types. */
d1274 4
@


1.38
log
@Intel Centrino Advanced-N 6200 G2 adapters have their own hardware
revision type.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.37 2010/02/17 18:23:00 damien Exp $	*/
d1251 21
a1278 2

#define IWN_FW_API(x)	(((x) >> 8) & 0xff)
@


1.37
log
@read calibration version from ROM and set IWN_GP_DRIVER_CALIB_VER6
bit on 6x50 if version>=6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.36 2010/01/23 09:14:13 damien Exp $	*/
d206 1
@


1.36
log
@finally, 6250 parts need crystal calibration too.
update sensitivity settings for 5000 series to workaround a performance
bug in the DSP (1000 is not affected so we keep the old values for 5000.)
update sensitivity settings for 6000 series.

from similar changes to iwlwifi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.35 2010/01/16 12:48:58 damien Exp $	*/
d218 1
d1315 6
@


1.35
log
@rename bluetooth coexistence flags. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.34 2009/11/08 11:54:48 damien Exp $	*/
d1540 2
a1541 2
	120, 155,
	240, 290,
d1563 12
d1576 1
a1576 1
	105, 145,
d1642 1
a1642 1
	"UNKNOWN"
@


1.34
log
@- remove non-production pci ids for 6050 3x3
- wakeup device earlier in read_prom
- fix ampdu_tx_start (not used yet)
- initialize ht_caps field and rx mcs set (not used yet)
- start processing compressed blockack notifications (does nothing for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.33 2009/11/03 18:57:18 damien Exp $	*/
d831 3
a833 4
#define IWN_BT_COEX_DISABLE	0
#define IWN_BT_COEX_MODE_2WIRE	1
#define IWN_BT_COEX_MODE_3WIRE	2
#define IWN_BT_COEX_MODE_4WIRE	3
@


1.33
log
@s/TX_IQ_PERD/TX_IQ_PERIODIC/
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.32 2009/11/01 12:01:16 damien Exp $	*/
d392 1
d974 3
a976 3
	uint8_t		killcnt;
	uint8_t		rtscnt;
	uint8_t		retrycnt;
d988 3
a990 3
	uint8_t		killcnt;
	uint8_t		rtscnt;
	uint8_t		retrycnt;
d1000 3
a1002 1
	uint32_t	tlc;
d1057 12
d1120 1
a1120 1
/* Structure for IWN_{RX,BEACON}_STATISTICS notification. */
d1310 1
a1310 1
	uint16_t	reserved1;
d1312 1
a1312 1
	uint8_t		reserved2;
@


1.32
log
@- fix rx chain mask in scan command
- no Tx IQ calibration for 6000 series
- remove a comment about iwlwifi that is no longer true
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.31 2009/10/28 18:42:47 damien Exp $	*/
d885 1
a885 1
#define IWN5000_PHY_CALIB_TX_IQ_PERD		17
@


1.31
log
@- use bus_space_write_1 to write to IWN_INT_PERIODIC (0x5), even though
  bus_space_write_4 worked
- store enhanced power info in softc for 6000 Series
- fix a comment, remove an unused field in softc and reorder pci ids a bit
  while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.30 2009/10/26 17:55:29 damien Exp $	*/
d464 4
a467 4
#define IWN_RXCHAIN_FORCE		(1 << 0)
#define IWN_RXCHAIN_VALID(x)		((x) <<  1)
#define IWN_RXCHAIN_SEL(x)		((x) <<  4)
#define IWN_RXCHAIN_MIMO(x)		((x) <<  7)
@


1.30
log
@update WiFi Link 6000 product ids.
fix sensitivity settings for 4965.
use different sensitivity limits for 5150 (workaround for HW bug) and 6000.
set valid Tx and Rx chains based on PCI product ids for 6000 series.
cleanup setting of critical temperature.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.29 2009/10/24 20:17:17 damien Exp $	*/
d60 1
a60 1
#define IWN_INT_PERIODIC	0x005	/* XXX fixme */
d1627 3
@


1.29
log
@add explicit barriers for read/write accesses to prph and internal memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.28 2009/10/24 19:00:40 damien Exp $	*/
d443 3
a445 1
/* Shortcut. */
d1515 1
a1515 1
	170, 210,
d1535 24
@


1.28
log
@enable WiFi/WiMAX coexistence for 6050 combo adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.27 2009/10/24 18:14:57 damien Exp $	*/
d1607 8
@


1.27
log
@huge diff introducing many of the recent changes made by intel to iwlwifi:
- ICT interrupts for >=5000 series (avoids reading IWN_INT which is slow)
- support v2 firmware header (including build number)
- switch to v2 firmware api (requires a firmware package upgrade)
- initial support for 1000 series and initial bits for upcoming 6000
  series (untested as hardware is not available to the general public)
- many bug fixes, including workarounds for hardware bugs

make sure to update your iwn-firmware package to iwn-firmware-5.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.26 2009/05/29 08:25:45 damien Exp $	*/
d707 6
a712 1
	struct {
d1538 20
@


1.26
log
@fix confusion between number of DMA channels and number of Tx queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.25 2009/05/27 09:50:31 damien Exp $	*/
d34 3
d60 1
d62 1
a62 1
#define IWN_MASK		0x00c
d71 1
d74 1
d77 1
d79 1
d142 2
a143 2
#define IWN_CLOCK_CTL		0x3000
#define IWN_APMG_CLK_CTRL	0x3004
d146 2
a158 3
/* Possible values for IWN_APMG_CLK_DIS. */
#define IWN_APMG_CLK_DMA_RQT	(1 << 9)

d169 4
d185 1
d214 5
d229 4
d250 1
d252 1
d257 1
a257 1
#define IWN_INT_MASK							\
d324 1
a324 1
/* Possible flags for register IWN_APMG_CLK_CTRL. */
d336 7
d412 2
a413 2
#define IWN_CMD_CONFIGURE		 16
#define IWN_CMD_ASSOCIATE		 17
d424 1
d426 1
a426 1
#define IWN_CMD_TXPOWER_DBM		152
d446 1
a446 1
/* Structure for command IWN_CMD_CONFIGURE. */
d497 1
a497 1
	/* The following fields are for 5000 Series only. */
d823 11
a833 2
	uint8_t		lead;
	uint8_t		kill;
d835 2
a836 2
	uint32_t	ack;
	uint32_t	cts;
a1227 10
/* Firmware image file header. */
struct iwn_firmware_hdr {
	uint32_t	version;
	uint32_t	main_textsz;
	uint32_t	main_datasz;
	uint32_t	init_textsz;
	uint32_t	init_datasz;
	uint32_t	boot_textsz;
} __packed;

d1236 2
d1265 1
d1287 8
d1354 4
@


1.25
log
@allow iwn(4) to coexist with Intel Active Management Technology (AMT)
which may use WLAN too.  for Intel Centrino 2 vPro only.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.24 2009/05/24 18:51:11 damien Exp $	*/
d28 5
a32 1
#define IWN_SRVC_CHNL		9
@


1.24
log
@reduce Rx ring size from 256 to 64 slots.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.23 2009/05/20 16:31:50 damien Exp $	*/
d153 1
d155 2
@


1.23
log
@add code to read from OTPROM (1000 and 6000 series only).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.22 2009/03/10 20:39:21 damien Exp $	*/
d23 1
a23 1
#define IWN_RX_RING_COUNT_LOG	8
d436 1
a436 1
#define IWN_RXON_24GHZ	(1 <<  0)
@


1.22
log
@cleanup the mess in Intel WiFi Link PCI Ids.
WiFi Link 100 Series have been renamed to 1000 Series by Intel too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.21 2009/02/15 08:58:22 damien Exp $	*/
d61 1
d276 9
a299 1
#define IWN_APMG_PS_PWR_SRC_MASK	(3 << 24)
d302 3
@


1.21
log
@attach the Intel WiFi Link 100 and 6000 Series (though no firmware
is available yet.)
branch the ampdu_{tx,rx}_{start,stop} callbacks too.
remove code that is only needed for evaluation/test boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.20 2008/12/12 17:15:40 damien Exp $	*/
d183 1
a183 1
#define IWN_HW_REV_TYPE_100	6
@


1.20
log
@get rid of the ugly IWN_SET_DESC_SEG/NSEGS macros.
add "support" for physical addresses larger than 32-bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.19 2008/12/02 17:17:50 damien Exp $	*/
d183 3
d1181 2
a1182 2
#define IWN5000_FW_TEXT_MAXSZ	(128 * 1024)
#define IWN5000_FW_DATA_MAXSZ	( 48 * 1024)
@


1.19
log
@Add code for 5150 support (not tested since I don't have the hardware and
because it requires a specific firmware that Intel has not released yet.)
Fix crystal calibration for 5000 Series.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.18 2008/11/25 18:49:49 damien Exp $	*/
d36 9
d308 3
a310 4
		uint32_t	w1;
		uint32_t	w2;
		uint32_t	w3;
	} __packed	segs[IWN_MAX_SCATTER / 2];
a313 16

#define IWN_SET_DESC_NSEGS(d, x)					\
	(d)->nsegs = (x)

/* Set a segment physical address and length in a TX descriptor. */
#define IWN_SET_DESC_SEG(d, n, addr, size) do {				\
	if ((n) & 1) {							\
		(d)->segs[(n) / 2].w2 |=				\
		    htole32(((addr) & 0xffff) << 16);			\
		(d)->segs[(n) / 2].w3 =					\
		    htole32((((addr) >> 16) & 0xffff) | (size) << 20);	\
	} else {							\
		(d)->segs[(n) / 2].w1 = htole32(addr);			\
		(d)->segs[(n) / 2].w2 = htole32((size) << 4);		\
	}								\
} while (0)
@


1.18
log
@move some generic PCIe register flags used in wpi(4) and iwn(4)
into common pcireg.h

ok deraadt@@, kettenis@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.17 2008/11/21 17:17:05 damien Exp $	*/
d819 1
d1219 3
a1221 1
#define IWN5000_EEPROM_CRYSTAL	0x094
@


1.17
log
@Fix crystal and gain calibration on 5000 Series.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.16 2008/11/19 18:52:53 damien Exp $	*/
a37 7

/* Possible flags for PCIe Device Control Register (see PCIe 7.8.4) */
#define PCI_PCIE_DCSR_ENA_NO_SNOOP	(1 << 11)

/* Possible flags for PCIe Link Control Register (see PCIe 7.8.7) */
#define PCI_PCIE_LCSR_ASPM_L0S	(1 << 0)
#define PCI_PCIE_LCSR_ASPM_L1	(1 << 1)
@


1.16
log
@For 5000 Series, store baseband calibration results sent by the
initialization firmware and send them to the runtime firmware.
This has no effect on my 5300 since the initialization firmware
does not send baseband results. This may be important for other
chips though or for future firmware revisions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.15 2008/11/09 10:00:17 damien Exp $	*/
d836 1
a836 1
	uint8_t	valid;
d843 1
a843 1
	uint8_t	valid;
d845 2
a846 1
	uint8_t	data[2];
d853 1
a853 1
	uint8_t	valid;
d856 1
a856 1
	uint8_t	reserved2;
@


1.15
log
@rework the rate coding code to get rid of the ugly {wpi,iwn}_plcp_signal()
function.  will be required for future MCS support in iwn.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.14 2008/11/08 11:05:36 damien Exp $	*/
d90 1
d246 3
d827 1
a827 1
#define IWN5000_PHY_CALIB_LO_TX_IQ		11
d829 2
a830 1
#define IWN5000_PHY_CALIB_LO_TX_IQ_PERD		17
@


1.14
log
@rework iwn_start().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.13 2008/11/03 17:19:54 damien Exp $	*/
d589 1
a589 1
#define IWN_TX_MRR_INDEX	(1 <<  4)
d599 1
a599 1
	uint8_t		rate;
d610 1
a610 1
	uint8_t		ridx;
d643 1
a643 1
		uint8_t		rate;
a645 4
#define IWN_CCK1	 0
#define IWN_CCK11	 3
#define IWN_OFDM6	 4
#define IWN_OFDM54	11
d1298 22
a1319 3
static const uint8_t iwn_ridx_to_plcp[] = {
	10, 20, 55, 110, /* CCK */
	0xd, 0xf, 0x5, 0x7, 0x9, 0xb, 0x1, 0x3, 0x3 /* OFDM R1-R4 */
@


1.13
log
@HW CCMP encryption/decryption of unicast frames.
HW support for other ciphers (TKIP) really sucks (no Michael MIC,
not even TKIP Phase 1) and is thus not implemented here.

fix a panic in iwn_fatal_intr() when dumping the firmware error
log while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.12 2008/10/22 06:25:07 damien Exp $	*/
d253 1
@


1.12
log
@lot of cleanup, small fixes.
prepare for future enhancements.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.11 2008/10/13 16:37:10 damien Exp $	*/
d357 2
a358 2
#define IWN_RX_NO_CRC_ERR	(1 << 0)
#define IWN_RX_NO_OVFL_ERR	(1 << 1)
d361 6
d1288 1
d1290 1
d1295 1
d1297 1
@


1.11
log
@Almost complete rewrite of iwn(4).
Add support for Intel WiFi Link 5000 Series adapters (5100/5150/5300/5350).

Quite frankly, Intel made things unnecessarily difficult by gratuitously
changing firmware commands (adding new fields in the middle of a struct)
and some register offsets for the 5000 Series and by defining yet another
way of loading a firmware.
I had to write a hardware abstraction layer to manage those differences.

Committed over a 5300 adapter (3T3R).
Require an upgrade of the iwn-firmware package, even for 4965AGN users.
Not tested on 5100, 5150 and 5350 (test reports are more than welcomed.)
There should be no regression on the 4965AGN.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.10 2008/04/27 19:01:59 damien Exp $	*/
d141 1
a141 1
/* possible values for IWN_APMG_CLK_DIS */
d144 1
a144 1
/* possible flags for register IWN_HW_IF_CONFIG */
d151 1
a151 1
/* possible flags for registers IWN_PRPH_RADDR/IWN_PRPH_WADDR */
d154 1
a154 1
/* possible values for IWN_BSM_WR_MEM_DST */
d158 1
a158 1
/* possible flags for register IWN_RESET */
d164 1
a164 1
/* possible flags for register IWN_GP_CNTRL */
d172 1
a172 1
/* possibles flags for register IWN_HW_REV */
d181 1
a181 1
/* possible flags for register IWN_GIO_CHICKEN */
d185 1
a185 1
/* possible flags for register IWN_GIO */
d188 1
a188 1
/* possible flags for register IWN_UCODE_GP1_CLR */
d193 1
a193 1
/* possible flags for register IWN_LED */
d195 2
d198 1
a198 1
/* possible values for register IWN_ANA_PLL */
d201 1
a201 1
/* possible flags for register IWN_FH_RX_STATUS */
d204 1
a204 1
/* possible flags for register IWN_BSM_WR_CTRL */
d208 1
a208 1
/* possible flags for register IWN_INT */
d219 1
d225 1
a225 1
/* possible flags for register IWN_FH_INT */
d229 1
a229 1
/* shortcuts for the above */
d235 1
a235 1
/* possible flags/values for register IWN_FH_TX_CONFIG */
d240 1
a240 1
/* possible values for register IWN_FH_TXBUF_STATUS */
d245 1
a245 1
/* possible flags for register IWN_FH_TX_STATUS */
d249 1
a249 1
/* possible flags for register IWN_FH_RX_CONFIG */
d257 1
a257 1
/* possible flags for register IWN_FH_TX_CONFIG */
d261 1
a261 1
/* possible flags for register IWN_EEPROM */
d265 1
a265 1
/* possible flags for register IWN5000_SCHED_QUEUE_STATUS */
d274 1
a274 1
/* possible flags for register IWN_APMG_CLK_CTRL */
d278 1
a278 1
/* possible flags for register IWN_APMG_PS */
d284 1
a284 1
/* possible flags for IWN_APMG_PCI_STT */
d287 1
a287 1
/* possible flags for register IWN_BSM_DRAM_TEXT_SIZE */
d298 2
a299 1
	uint32_t	flags;
d305 2
a306 2
	/* pad to 128 bytes */
	uint32_t	reserved;
d310 1
a310 1
	(d)->flags = htole32(((x) & 0x1f) << 24)
d312 1
a312 1
/* set a segment physical address and length in a Tx descriptor */
d347 2
a348 2
#define IWN_AMPDU_RX_START		192
#define IWN_AMPDU_RX_DONE		193
d356 1
a356 1
/* possible Rx status flags */
d359 1
a359 1
/* shortcut for the above */
d370 1
a370 1
#define IWN_CMD_NODE_MRR_SETUP		 78
d381 2
a382 2
#define IWN_SENSITIVITY			168
#define IWN_PHY_CALIB			176
d390 8
a397 1
/* structure for command IWN_CMD_CONFIGURE */
a412 6
#define IWN_ANT_A	(1 << 0)
#define IWN_ANT_B	(1 << 1)
#define IWN_ANT_C	(1 << 2)
/* Shortcut. */
#define IWN_ANT_ABC	(IWN_ANT_A | IWN_ANT_B | IWN_ANT_C)

a420 1

d448 1
a448 1
	/* the following fields are for 5000 Series only */
d458 1
a458 1
/* structure for command IWN_CMD_ASSOCIATE */
d467 1
a467 1
/* structure for command IWN_CMD_EDCA_PARAMS */
d482 1
a482 1
/* structure for command IWN_CMD_TIMING */
d492 1
a492 1
/* structure for command IWN_CMD_ADD_NODE */
d509 3
d514 6
a520 1
	uint16_t	keyflags;
d527 1
d539 2
a540 3

	uint8_t		addba;
	uint8_t		delba;
d553 1
a553 1
	uint16_t	keyflags;
d564 2
a565 2
	uint8_t		addba;
	uint8_t		delba;
d570 2
a571 3
#define IWN_RFLAG_CCK	(1 << 1)
#define IWN_RFLAG_ANT_A	(1 << 6)
#define IWN_RFLAG_ANT_B	(1 << 7)
d573 1
a573 1
/* structure for command IWN_CMD_TX_DATA */
d578 1
a578 1
#define IWN5000_TX_NEED_RTS_CTS	(1 <<  0)	/* 5000 only */
d591 1
a591 4
	uint8_t		ntries;
	uint8_t		bluetooth;
	uint16_t	reserved1;

d620 1
a620 1
/* structure for command IWN_CMD_MRR_NODE_SETUP */
d622 1
a622 1
struct iwn_cmd_mrr {
d628 2
a629 2
	uint8_t		ssmask;
	uint8_t		dsmask;
d632 1
a632 1
	uint8_t		ampdu_disable;
d643 1
a643 1
	} __packed	table[IWN_MAX_TX_RETRIES];
d647 1
a647 1
/* structure for command IWN_CMD_SET_LED */
d659 1
a659 1
/* structure for command IWN5000_CMD_WIMAX_COEX */
d670 1
a670 1
/* structures for command IWN5000_CMD_CALIB_CONFIG */
d691 1
a691 1
/* structure for command IWN_CMD_SET_POWER_MODE */
d708 1
a708 1
/* structures for command IWN_CMD_SCAN */
d728 4
a731 4
	/* followed by a struct iwn_cmd_data */
	/* followed by an array of 20 struct iwn_scan_essid */
	/* followed by probe request body */
	/* followed by nchan x struct iwn_scan_chan */
d735 3
a737 3
	uint32_t	type;
#define IWN_CHAN_ACTIVE	(1 << 0)
#define IWN_CHAN_DIRECT	(1 << 1)
d746 4
a749 1
/* structure for command IWN_CMD_TXPOWER */
d762 1
a762 1
/* structure for command IWN_CMD_TXPOWER_DBM */
d765 2
a766 2
#define IWN5000_TX_POWER_AUTO		0x7f
#define IWN5000_TX_POWER_MAX_DBM	16
d769 1
a769 1
#define IWN5000_TX_POWER_NO_CLOSED	(1 << 6)
d775 1
a775 1
/* structure for command IWN_CMD_BLUETOOTH */
d785 1
a785 1
/* structure for command IWN_CMD_SET_CRITICAL_TEMP */
d790 1
a790 1
/* degK <-> degC conversion macros */
d796 1
a796 1
/* structure for command IWN_SENSITIVITY */
d815 2
a816 11
/* structure for command IWN_PHY_CALIB */
struct iwn_phy_calib_cmd {
	uint8_t		code;

	uint8_t		flags;
	uint16_t	reserved1;
	int8_t		gain[3];
	uint8_t		reserved2;
} __packed;

struct iwn5000_calib {
d818 1
a818 1
#define IWN4965_SET_DIFF_GAIN			 7
d831 1
a831 2
/* structure for command IWN_PHY_CALIB */
struct iwn5000_phy_calib {
d833 6
d840 2
d845 3
a847 1
	uint8_t	data[2];
d850 24
d875 5
a879 1
/* structure for IWN_UC_READY notification */
d893 1
a893 1
	uint32_t	errorptr;
d897 1
a897 1
	/* the following fields are for UCODE_INIT only */
d906 1
a906 1
/* structure for IWN_TX_DONE notification */
d940 1
a940 1
/* structure for IWN_BEACON_MISSED notification */
d948 2
a949 2
/* structure for IWN_AMPDU_RX_DONE notification */
struct iwn_rx_ampdu {
d954 1
a954 2
/* structures for IWN_RX_DONE and IWN_AMPDU_RX_START notifications */

d977 2
d990 1
a990 1
/* structure for IWN_START_SCAN notification */
d1000 1
a1000 1
/* structure for IWN_STOP_SCAN notification */
d1009 33
a1041 1
/* structure for IWN_{RX,BEACON}_STATISTICS notification */
d1158 14
a1171 1
/* firmware image header */
d1218 6
a1223 4
/* possible flags for IWN_EEPROM_RFCFG */
#define IWN_RFCFG_TYPE(x)	(((x) >> 0) & 3)
#define IWN_RFCFG_STEP(x)	(((x) >> 2) & 3)
#define IWN_RFCFG_DASH(x)	(((x) >> 4) & 3)
d1447 36
@


1.10
log
@fix rate control.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.9 2007/11/27 20:59:40 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007
d21 8
a28 1
#define IWN_RX_RING_COUNT	64
d30 5
a34 2
#define IWN_NTXQUEUES		16
#define IWN_NTXCHAINS		2
d36 2
a37 4
/*
 * Rings must be aligned on a 256-byte boundary.
 */
#define IWN_RING_DMA_ALIGN	256
d39 2
a40 2
/* maximum scatter/gather */
#define IWN_MAX_SCATTER	20
d42 3
a44 2
/* Rx buffers must be large enough to hold a full 4K A-MPDU */
#define IWN_RBUF_SIZE	(4 * 1024)
d49 3
a51 3
#define IWN_HWCONFIG		0x000
#define IWN_INTR_MIT		0x004
#define IWN_INTR		0x008
d53 1
a53 1
#define IWN_INTR_STATUS		0x010
d55 11
a65 5
#define IWN_GPIO_CTL		0x024
#define IWN_EEPROM_CTL		0x02c
#define IWN_UCODE_CLR		0x05c
#define IWN_CHICKEN		0x100
#define IWN_QUEUE_OFFSET(qid)	(0x380 + (qid) * 8)
d68 6
a73 22
#define IWN_WRITE_MEM_ADDR  	0x444
#define IWN_READ_MEM_ADDR   	0x448
#define IWN_WRITE_MEM_DATA  	0x44c
#define IWN_READ_MEM_DATA   	0x450
#define IWN_TX_WIDX		0x460

#define IWN_KW_BASE		0x197c
#define IWN_TX_BASE(qid)	(0x19d0 + (qid) * 4)
#define IWN_RW_WIDX_PTR		0x1bc0
#define IWN_RX_BASE		0x1bc4
#define IWN_RX_WIDX		0x1bc8
#define IWN_RX_CONFIG		0x1c00
#define IWN_RX_STATUS		0x1c44
#define IWN_TX_CONFIG(qid)	(0x1d00 + (qid) * 32)
#define IWN_TX_STATUS		0x1eb0

#define IWN_SRAM_BASE		0xa02c00
#define IWN_TX_ACTIVE		(IWN_SRAM_BASE + 0x01c)
#define IWN_QUEUE_RIDX(qid)	(IWN_SRAM_BASE + 0x064 + (qid) * 4)
#define IWN_SELECT_QCHAIN	(IWN_SRAM_BASE + 0x0d0)
#define IWN_QUEUE_INTR_MASK	(IWN_SRAM_BASE + 0x0e4)
#define IWN_TXQ_STATUS(qid)	(IWN_SRAM_BASE + 0x104 + (qid) * 4)
d76 1
a76 1
 * NIC internal memory offsets.
d78 13
a90 13
#define IWN_CLOCK_CTL		0x3000
#define IWN_MEM_CLOCK2		0x3008
#define IWN_MEM_POWER		0x300c
#define IWN_MEM_PCIDEV		0x3010
#define IWN_MEM_UCODE_CTL	0x3400
#define IWN_MEM_UCODE_SRC	0x3404
#define IWN_MEM_UCODE_DST	0x3408
#define IWN_MEM_UCODE_SIZE	0x340c
#define IWN_MEM_TEXT_BASE	0x3490
#define IWN_MEM_TEXT_SIZE	0x3494
#define IWN_MEM_DATA_BASE	0x3498
#define IWN_MEM_DATA_SIZE	0x349c
#define IWN_MEM_UCODE_BASE	0x3800
d92 18
d111 11
a121 2
/* possible flags for register IWN_HWCONFIG */
#define IWN_HW_EEPROM_LOCKED	(1 << 21)
d123 34
a156 5
/* possible flags for registers IWN_READ_MEM_ADDR/IWN_WRITE_MEM_ADDR */
#define IWN_MEM_4	((sizeof (uint32_t) - 1) << 24)

/* possible values for IWN_MEM_UCODE_DST */
#define IWN_FW_TEXT	0x00000000
d159 67
a225 49
#define IWN_NEVO_RESET		(1 << 0)
#define IWN_SW_RESET		(1 << 7)
#define IWN_MASTER_DISABLED	(1 << 8)
#define IWN_STOP_MASTER		(1 << 9)

/* possible flags for register IWN_GPIO_CTL */
#define IWN_GPIO_CLOCK		(1 << 0)
#define IWN_GPIO_INIT		(1 << 2)
#define IWN_GPIO_MAC		(1 << 3)
#define IWN_GPIO_SLEEP		(1 << 4)
#define IWN_GPIO_PWR_STATUS	0x07000000
#define IWN_GPIO_PWR_SLEEP	(4 << 24)
#define IWN_GPIO_RF_ENABLED	(1 << 27)

/* possible flags for register IWN_CHICKEN */
#define IWN_CHICKEN_DISLOS	(1 << 29)

/* possible flags for register IWN_UCODE_CLR */
#define IWN_RADIO_OFF		(1 << 1)
#define IWN_DISABLE_CMD		(1 << 2)
#define IWN_CTEMP_STOP_RF	(1 << 3)

/* possible flags for IWN_RX_STATUS */
#define	IWN_RX_IDLE	(1 << 24)

/* possible flags for register IWN_UC_CTL */
#define IWN_UC_ENABLE	(1 << 30)
#define IWN_UC_RUN	(1 << 31)

/* possible flags for register IWN_INTR */
#define IWN_ALIVE_INTR	(1 <<  0)
#define IWN_WAKEUP_INTR	(1 <<  1)
#define IWN_SW_RX_INTR	(1 <<  3)
#define IWN_CT_REACHED	(1 <<  6)
#define IWN_RF_TOGGLED	(1 <<  7)
#define IWN_SW_ERROR	(1 << 25)
#define IWN_TX_INTR	(1 << 27)
#define IWN_HW_ERROR	(1 << 29)
#define IWN_RX_INTR	(1 << 31)

#define IWN_INTR_MASK							\
	(IWN_SW_ERROR | IWN_HW_ERROR | IWN_TX_INTR | IWN_RX_INTR |	\
	 IWN_ALIVE_INTR | IWN_WAKEUP_INTR | IWN_SW_RX_INTR |		\
	 IWN_CT_REACHED | IWN_RF_TOGGLED)

/* possible flags for register IWN_INTR_STATUS */
#define IWN_STATUS_TXQ(x)	(1 << (x))
#define IWN_STATUS_RXQ(x)	(1 << ((x) + 16))
#define IWN_STATUS_PRI		(1 << 30)
d227 30
a256 5
#define IWN_TX_STATUS_INTR						\
	(IWN_STATUS_TXQ(0) | IWN_STATUS_TXQ(1) | IWN_STATUS_TXQ(6))
#define IWN_RX_STATUS_INTR						\
	(IWN_STATUS_RXQ(0) | IWN_STATUS_RXQ(1) | IWN_STATUS_RXQ(2) |	\
	 IWN_STATUS_PRI)
d258 2
a259 5
/* possible flags for register IWN_TX_STATUS */
#define IWN_TX_IDLE(qid)	(1 << ((qid) + 24) | 1 << ((qid) + 16))

/* possible flags for register IWN_EEPROM_CTL */
#define IWN_EEPROM_READY	(1 << 0)
d262 18
a279 2
/* possible flags for register IWN_TXQ_STATUS */
#define IWN_TXQ_STATUS_ACTIVE	0x0007fc01
d281 2
a282 2
/* possible flags for register IWN_MEM_POWER */
#define IWN_POWER_RESET	(1 << 26)
d284 1
a284 1
/* possible flags for register IWN_MEM_TEXT_SIZE */
d287 6
a292 16
/* possible flags for device-specific PCI register 0xe8 */
#define IWN_DIS_NOSNOOP	(1 << 11)

/* possible flags for device-specific PCI register 0xf0 */
#define IWN_ENA_L1	(1 << 1)


#define IWN_TX_WINDOW	64
struct iwn_shared {
	uint16_t	len[IWN_NTXQUEUES][512];	/* 16KB total */
	uint16_t	closed_count;
	uint16_t	closed_rx_count;
	uint16_t	finished_count;
	uint16_t	finished_rx_count;
	uint32_t	reserved[2];
} __packed;
d321 8
d332 14
a345 12
#define IWN_UC_READY		  1
#define IWN_ADD_NODE_DONE	 24
#define IWN_TX_DONE		 28
#define IWN_START_SCAN		130
#define IWN_STOP_SCAN		132
#define IWN_RX_STATISTICS	156
#define IWN_BEACON_STATISTICS	157
#define IWN_STATE_CHANGED	161
#define IWN_BEACON_MISSED	162
#define IWN_AMPDU_RX_START	192
#define IWN_AMPDU_RX_DONE	193
#define IWN_RX_DONE		195
d363 1
a363 1
#define IWN_CMD_TSF			 20
d368 2
d373 2
a374 1
#define IWN_CMD_BLUETOOTH		155
d387 1
a387 1
struct iwn_config {
d400 1
a400 1
	uint8_t		reserved4;
d402 14
a415 2
#define IWN_RXCHAIN_ANTMSK_SHIFT	1
#define IWN_RXCHAIN_FORCE_MIMO		(1 << 14)
d421 10
a430 9
#define IWN_CONFIG_24GHZ	(1 <<  0)
#define IWN_CONFIG_CCK		(1 <<  1)
#define IWN_CONFIG_AUTO		(1 <<  2)
#define IWN_CONFIG_SHSLOT	(1 <<  4)
#define IWN_CONFIG_SHPREAMBLE	(1 <<  5)
#define IWN_CONFIG_NODIVERSITY	(1 <<  7)
#define IWN_CONFIG_ANTENNA_A	(1 <<  8)
#define IWN_CONFIG_ANTENNA_B	(1 <<  9)
#define IWN_CONFIG_TSF		(1 << 15)
d438 1
d441 1
a441 1
	uint8_t		reserved5;
d444 5
d451 3
d478 2
a479 2
/* structure for command IWN_CMD_TSF */
struct iwn_cmd_tsf {
d494 1
d499 2
a500 1
#define IWN_ID_BROADCAST	31
d503 2
a504 1
#define IWN_FLAG_SET_KEY	(1 << 0)
d507 2
a508 1
	uint16_t	security;
d512 7
a518 2
	uint16_t	reserved5;
	uint8_t		key[IEEE80211_KEYBUF_SIZE];
d520 2
a521 2
#define IWN_AMDPU_SIZE_FACTOR_SHIFT	19
#define IWN_AMDPU_DENSITY_SHIFT		23
d524 34
a557 3
	uint16_t	tid;
	uint8_t		rate;
	uint8_t		rflags;
a561 6
	uint8_t		add_imm;
	uint8_t		del_imm;
	uint16_t	add_imm_start;
	uint32_t	reserved6;
} __packed;

d567 1
d572 1
d576 1
d583 1
d587 1
d597 1
a597 1
	uint8_t		key[IEEE80211_KEYBUF_SIZE];
d629 2
d635 1
a635 4

		uint8_t		rflags;
		uint16_t	xrflags;
	}		table[IWN_MAX_TX_RETRIES];
d651 32
d684 1
a684 1
struct iwn_power {
d686 5
a690 1
#define IWN_POWER_CAM	0	/* constantly awake mode */
d692 1
a692 1
	uint8_t		alive;
d694 3
a696 3
	uint32_t	rx_timeout;
	uint32_t	tx_timeout;
	uint32_t	sleep[5];
d711 2
a712 2
	uint16_t	quiet;
	uint16_t	plcp_threshold;
d721 1
a721 1
	/* followed by an array of 4x struct iwn_scan_essid */
d727 1
a727 1
	uint8_t		flags;
d731 1
a731 1
	uint8_t		chan;
d740 5
a744 5
struct iwn_cmd_txpower {
	uint8_t	band;
	uint8_t	reserved1;
	uint8_t	chan;
	uint8_t	reserved2;
d746 16
a761 3
		uint8_t	rf_gain[IWN_NTXCHAINS];
		uint8_t	dsp_gain[IWN_NTXCHAINS];
	}	power[IWN_RIDX_MAX + 1];
a806 1
#define IWN_SET_DIFF_GAIN	7
d811 17
a827 1
#define IWN_GAIN_SET	(1 << 2)
d829 8
a836 1
	uint8_t		reserved2;
d864 1
a864 1
	int32_t		atten[IWN_NATTEN_GROUPS][IWN_NTXCHAINS];
d868 1
a868 1
struct iwn_tx_stat {
d870 3
a872 3
	uint8_t		nkill;
	uint8_t		nrts;
	uint8_t		ntries;
d882 19
d915 14
a928 1
/* structure for IWN_RX_DONE and IWN_AMPDU_RX_START notifications */
d940 1
a940 6
	uint16_t	antenna;
	uint16_t	agc;
	uint8_t		rssi[6];
#define IWN_RSSI_TO_DBM	44

	uint8_t		reserved2[22];
d948 2
d1096 4
a1099 4
#define IWN_FW_MAIN_TEXT_MAXSZ	(96 * 1024)
#define IWN_FW_MAIN_DATA_MAXSZ	(40 * 1024)
#define IWN_FW_INIT_TEXT_MAXSZ	(96 * 1024)
#define IWN_FW_INIT_DATA_MAXSZ	(40 * 1024)
d1101 2
a1102 1

d1108 29
a1136 11
#define IWN_EEPROM_DOMAIN	0x060
#define IWN_EEPROM_BAND1	0x063
#define IWN_EEPROM_BAND2	0x072
#define IWN_EEPROM_BAND3	0x080
#define IWN_EEPROM_BAND4	0x08d
#define IWN_EEPROM_BAND5	0x099
#define IWN_EEPROM_BAND6	0x0a0
#define IWN_EEPROM_BAND7	0x0a8
#define IWN_EEPROM_MAXPOW	0x0e8
#define IWN_EEPROM_VOLTAGE	0x0e9
#define IWN_EEPROM_BANDS	0x0ea
d1149 1
a1149 1
struct iwn_eeprom_chan_samples {
d1156 1
a1156 1
	}	samples[IWN_NTXCHAINS][IWN_NSAMPLES];
d1160 1
a1160 1
struct iwn_eeprom_band {
d1163 1
a1163 1
	struct	iwn_eeprom_chan_samples chans[2];
d1166 23
d1192 2
a1193 3
	uint32_t	addr;	/* offset in EEPROM */
	uint8_t		nchan;
	uint8_t		chan[IWN_MAX_CHAN_PER_BAND];
d1195 7
a1201 14
	{ IWN_EEPROM_BAND1, 14,
	    { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 } },
	{ IWN_EEPROM_BAND2, 13,
	    { 183, 184, 185, 187, 188, 189, 192, 196, 7, 8, 11, 12, 16 } },
	{ IWN_EEPROM_BAND3, 12,
	    { 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64 } },
	{ IWN_EEPROM_BAND4, 11,
	    { 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140 } },
	{ IWN_EEPROM_BAND5, 6,
	    { 145, 149, 153, 157, 161, 165 } },
	{ IWN_EEPROM_BAND6, 7,
	    { 1, 2, 3, 4, 5, 6, 7 } },
	{ IWN_EEPROM_BAND7, 11,
	    { 36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157 } }
d1209 1
a1209 1
#define IWN_MAX_PWR_INDEX	107
d1215 1
a1215 1
static const uint8_t iwn_rf_gain_2ghz[IWN_MAX_PWR_INDEX + 1] = {
d1228 1
a1228 1
static const uint8_t iwn_rf_gain_5ghz[IWN_MAX_PWR_INDEX + 1] = {
d1245 1
a1245 1
static const uint8_t iwn_dsp_gain_2ghz[IWN_MAX_PWR_INDEX + 1] = {
d1258 1
a1258 1
static const uint8_t iwn_dsp_gain_5ghz[IWN_MAX_PWR_INDEX + 1] = {
d1271 90
d1367 5
a1371 3
#define IWN_WRITE_REGION_4(sc, offset, datap, count)			\
	bus_space_write_region_4((sc)->sc_st, (sc)->sc_sh, (offset),	\
	    (datap), (count))
@


1.9
log
@fix shared area structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.8 2007/11/27 19:45:44 damien Exp $	*/
d400 1
a400 1
#define IWN_TX_USE_NODE_RATE	(1 <<  4)
a898 6
};

/* allow fallback from CCK11 to OFDM9 and from OFDM6 to CCK5 */
static const uint8_t iwn_prev_ridx[] = {
	0, 0, 1, 5, /* CCK */
	2, 4, 3, 6, 7, 8, 9, 10, 10 /* OFDM */
@


1.8
log
@fix DMA alignment constraints: rings must be aligned on a 256-byte
boundary, "keep warm" page must be aligned on a 4KB boundary.

make sure sc->shared->len[x][y] == sc->shared->len[x + 256][y] for
all x < 64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.7 2007/11/17 18:50:54 damien Exp $	*/
d185 1
a185 1
	uint16_t	len[512][IWN_NTXQUEUES];	/* 16KB total */
@


1.7
log
@fix reading of EEPROM for some adapters.

from Benjamin Close @@ FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.6 2007/09/10 20:36:49 damien Exp $	*/
d27 1
a27 1
 * Rings must be aligned on a 16K boundary.
d29 1
a29 1
#define IWN_RING_DMA_ALIGN	0x4000
d183 1
@


1.6
log
@fix interrupts processing and scan command + cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.5 2007/09/10 18:14:55 damien Exp $	*/
d165 1
@


1.5
log
@if more than 5 consecutive beacons are lost, reinitialize sensitivity
state machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.4 2007/09/10 17:54:50 damien Exp $	*/
d149 10
a508 1
	/* followed by an 802.11 header */
@


1.4
log
@cleanup. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.3 2007/09/07 19:32:09 damien Exp $	*/
d219 1
d624 8
@


1.3
log
@make sure the length of the first segment of a Tx descriptor is a multiple
of 4 by inserting padding bytes when necessary.
802.11 QoS headers have a length that is not a multiple of 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.2 2007/09/06 19:33:20 damien Exp $	*/
a27 1
 * I had a hard time figuring this out.
d162 3
d228 1
a228 22
/* structure for IWN_TX_DONE notification */
struct iwn_tx_stat {
	uint8_t		nframes;
	uint8_t		nkill;
	uint8_t		nrts;
	uint8_t		ntries;
	uint8_t		rate;
	uint8_t		rflags;
	uint16_t	xrflags;
	uint16_t	duration;
	uint16_t	reserved;
	uint32_t	power[2];
	uint32_t	status;
} __packed;

/* structure for IWN_AMPDU_RX_DONE notification */
struct iwn_rx_ampdu {
	uint16_t	len;
	uint16_t	reserved;
} __packed;

/* structure for IWN_RX_DONE and IWN_AMPDU_RX_START notifications */
a233 24
struct iwn_rx_stat {
	uint8_t		phy_len;
	uint8_t		cfg_phy_len;
#define IWN_STAT_MAXLEN	20

	uint8_t		id;
	uint8_t		reserved1;
	uint64_t	tstamp;
	uint32_t	beacon;
	uint16_t	flags;
	uint16_t	chan;
	uint16_t	antenna;
	uint16_t	agc;
	uint8_t		rssi[6];
#define IWN_RSSI_TO_DBM	44

	uint8_t		reserved2[22];
	uint8_t		rate;
	uint8_t		rflags;
	uint16_t	xrflags;
	uint16_t	len;
	uint16_t	reserve3;
} __packed;

d259 1
a259 1
/* structure for IWN_CMD_CONFIGURE */
d339 1
a339 1
/* structure for IWN_CMD_ADD_NODE */
d424 1
a424 1
/* structure for IWN_CMD_MRR_NODE_SETUP */
d452 1
a452 1
/* structure for IWN_CMD_SET_LED */
d464 1
a464 1
/* structure for IWN_CMD_SET_POWER_MODE */
d516 1
a516 1
/* structure for IWN_CMD_TXPOWER */
d529 1
a529 1
/* structure for IWN_CMD_BLUETOOTH */
d539 1
a539 1
/* structure for IWN_CMD_SET_CRITICAL_TEMP */
d610 46
a807 2
/* possible flags for register IWN_MEM_TEXT_SIZE */
#define IWN_FW_UPDATED	(1 << 31)
@


1.2
log
@fix temperature sensor. the sensors framework wants muK not degC!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnreg.h,v 1.1 2007/09/06 16:37:03 damien Exp $	*/
d435 1
@


1.1
log
@new iwn(4) driver for Intel Wireless WiFi Link 4965AGN.
no support for 802.11n functions yet (need work in net80211(9) first).
committed over my 4965AGN, with only 2 of 3 antennas plugged :-)

needs a firmware that is not freely redistributable (see man page).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d589 1
@

