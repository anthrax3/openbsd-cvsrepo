head	1.51;
access;
symbols
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.49.0.6
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.46.0.6
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.40.0.8
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.6
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.4
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.6
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.7.0.2
	UBC_BASE:1.7
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.51
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.50;
commitid	qGgYgJTgEFuAoGj4;

1.50
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.49;
commitid	pi1a9KN0itEngOc4;

1.49
date	2015.08.11.21.10.59;	author ratchov;	state Exp;
branches;
next	1.48;
commitid	MRPkLMkpnM4TU2F9;

1.48
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.47;
commitid	RaOGL5SyOGOZylwx;

1.47
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.46;
commitid	p4LJxGKbi0BU2cG6;

1.46
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	JtO5uXxVcnZfhUkR;

1.45
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.44;
commitid	OBNa5kfxQ2UXoiIw;

1.44
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2013.06.23.21.23.45;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.12.03.17.34;	author jakemsr;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.12.02.10.52;	author jakemsr;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.10.04.52.05;	author jakemsr;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.09.12.30.12;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.29.22.37.29;	author jakemsr;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.29.02.10.01;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.10.21.25.53;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.22.11.45.36;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.10.22.04.28;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.20.09.50.31;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.30.22.17.46;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.21.18.16.41;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.02.02.09.09;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.14.21.36.41;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.14.17.06.17;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.24.18.22.30;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.26.08.01.42;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.18.14.32.13;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.21.13.20;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.29.13.05.30;	author ho;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.26.18.16.02;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.20.12.22.59;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.31.11.00.24;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.23.23.44;	author ho;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.10.24.15.09.28;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.24.03.21.06;	author mickey;	state Exp;
branches;
next	;

1.3.2.1
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2003.05.13.19.35.05;	author ho;	state Exp;
branches;
next	1.3.2.8;

1.3.2.8
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	1.3.2.9;

1.3.2.9
date	2004.06.05.23.12.49;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: emuxki.c,v 1.50 2016/09/14 06:12:19 ratchov Exp $	*/
/*	$NetBSD: emuxki.c,v 1.1 2001/10/17 18:39:41 jdolecek Exp $	*/

/*-
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Yannick Montulet.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for Creative Labs SBLive! series and probably PCI512.
 * 
 * Known bugs:
 * - inversed stereo at ac97 codec level
 *   (XXX jdolecek - don't see the problem? maybe because auvia(4) has
 *    it swapped too?)
 * - bass disappear when you plug rear jack-in on Cambridge FPS2000 speakers
 *   (and presumably all speakers that support front and rear jack-in)
 *
 * TODO:
 * - Digital Outputs
 * - (midi/mpu),joystick support
 * - Multiple voices play (problem with /dev/audio architecture)
 * - Multiple sources recording (Pb with audio(4))
 * - Independent modification of each channel's parameters (via mixer ?)
 * - DSP FX patches (to make fx like chipmunk)
 */

#include <sys/types.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/fcntl.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/param.h>
#include <sys/audioio.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/audio_if.h>
#include <dev/ic/ac97.h>

#include <dev/pci/emuxkireg.h>
#include <dev/pci/emuxkivar.h>

/* autconf goo */
int  emuxki_match(struct device *, void *, void *);
void emuxki_attach(struct device *, struct device *, void *);
int  emuxki_detach(struct device *, int);
int  emuxki_activate(struct device *, int);
int  emuxki_scinit(struct emuxki_softc *sc, int);
void emuxki_pci_shutdown(struct emuxki_softc *sc);

/* dma mem mgmt */
struct dmamem *emuxki_dmamem_alloc(bus_dma_tag_t, size_t, bus_size_t,
				 int, int, int);
void	emuxki_dmamem_free(struct dmamem *, int);
void	emuxki_dmamem_delete(struct dmamem *mem, int type);

struct emuxki_mem *emuxki_mem_new(struct emuxki_softc *sc, int ptbidx,
	size_t size, int type, int flags);
void emuxki_mem_delete(struct emuxki_mem *mem, int type);

/* Emu10k1 init & shutdown */
int  emuxki_init(struct emuxki_softc *, int);
void emuxki_shutdown(struct emuxki_softc *);

/* Emu10k1 mem mgmt */
void   *emuxki_pmem_alloc(struct emuxki_softc *, size_t,int,int);
void   *emuxki_rmem_alloc(struct emuxki_softc *, size_t,int,int);

/*
 * Emu10k1 channels funcs : There is no direct access to channels, everything
 * is done through voices I will at least provide channel based fx params
 * modification, later...
 */

/* Emu10k1 voice mgmt */
struct emuxki_voice *emuxki_voice_new(struct emuxki_softc *, u_int8_t);
void   emuxki_voice_delete(struct emuxki_voice *);
int    emuxki_voice_set_audioparms(struct emuxki_voice *, u_int8_t, u_int8_t, u_int32_t);
/* emuxki_voice_set_fxparms will come later, it'll need channel distinction */
int emuxki_voice_set_bufparms(struct emuxki_voice *, void *, u_int32_t, u_int16_t);
int emuxki_voice_set_stereo(struct emuxki_voice *voice, u_int8_t stereo);
int emuxki_voice_dataloc_create(struct emuxki_voice *voice);
void emuxki_voice_dataloc_destroy(struct emuxki_voice *voice);
void emuxki_voice_commit_parms(struct emuxki_voice *);
void emuxki_voice_recsrc_release(struct emuxki_softc *sc, emuxki_recsrc_t source);
int emuxki_recsrc_reserve(struct emuxki_voice *voice, emuxki_recsrc_t source);
int emuxki_voice_adc_rate(struct emuxki_voice *);
u_int32_t emuxki_voice_curaddr(struct emuxki_voice *);
int emuxki_set_vparms(struct emuxki_voice *voice, struct audio_params *p);
int emuxki_voice_set_srate(struct emuxki_voice *voice, u_int32_t srate);
void emuxki_voice_start(struct emuxki_voice *, void (*) (void *), void *);
void emuxki_voice_halt(struct emuxki_voice *);
int emuxki_voice_channel_create(struct emuxki_voice *voice);
void emuxki_voice_channel_destroy(struct emuxki_voice *voice);

struct emuxki_channel *emuxki_channel_new(struct emuxki_voice *voice, u_int8_t num);
void emuxki_channel_delete(struct emuxki_channel *chan);
void emuxki_channel_start(struct emuxki_channel *chan);
void emuxki_channel_stop(struct emuxki_channel *chan);
void emuxki_channel_commit_fx(struct emuxki_channel *chan);
void emuxki_channel_commit_parms(struct emuxki_channel *chan);
void emuxki_channel_set_bufparms(struct emuxki_channel *chan, u_int32_t start, u_int32_t end);
void emuxki_channel_set_srate(struct emuxki_channel *chan, u_int32_t srate);
void emuxki_channel_set_fxsend(struct emuxki_channel *chan,
	struct emuxki_chanparms_fxsend *fxsend);
void emuxki_chanparms_set_defaults(struct emuxki_channel *chan);

void emuxki_resched_timer(struct emuxki_softc *sc);

/*
 * Emu10k1 stream mgmt : not done yet
 */
#if 0
struct emuxki_stream *emuxki_stream_new(struct emu10k1 *);
void   emuxki_stream_delete(struct emuxki_stream *);
int    emuxki_stream_set_audio_params(struct emuxki_stream *, u_int8_t,
					    u_int8_t, u_int8_t, u_int16_t);
void   emuxki_stream_start(struct emuxki_stream *);
void   emuxki_stream_halt(struct emuxki_stream *);
#endif

/* fx interface */
void emuxki_initfx(struct emuxki_softc *sc);
void emuxki_dsp_addop(struct emuxki_softc *sc, u_int16_t *pc, u_int8_t op,
	u_int16_t r, u_int16_t a, u_int16_t x, u_int16_t y);
void emuxki_write_micro(struct emuxki_softc *sc, u_int32_t pc, u_int32_t data);

/* audio interface callbacks */

int	emuxki_open(void *, int);
void	emuxki_close(void *);

int	emuxki_set_params(void *, int, int,
				      struct audio_params *,
				      struct audio_params *);

int	emuxki_round_blocksize(void *, int);
size_t	emuxki_round_buffersize(void *, int, size_t);

int	emuxki_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	emuxki_trigger_input(void *, void *, void *, int, void (*) (void *),
	    void *, struct audio_params *);
int	emuxki_halt_output(void *);
int	emuxki_halt_input(void *);

int	emuxki_set_port(void *, mixer_ctrl_t *);
int	emuxki_get_port(void *, mixer_ctrl_t *);
int	emuxki_query_devinfo(void *, mixer_devinfo_t *);

void   *emuxki_allocm(void *, int, size_t, int, int);
void	emuxki_freem(void *, void *, int);

int	emuxki_get_props(void *);

/* Interrupt handler */
int  emuxki_intr(void *);

/* Emu10k1 AC97 interface callbacks */
int  emuxki_ac97_init(struct emuxki_softc *sc);
int  emuxki_ac97_attach(void *, struct ac97_codec_if *);
int  emuxki_ac97_read(void *, u_int8_t, u_int16_t *);
int  emuxki_ac97_write(void *, u_int8_t, u_int16_t);
void emuxki_ac97_reset(void *);

const struct pci_matchid emuxki_devices[] = {
	{ PCI_VENDOR_CREATIVELABS, PCI_PRODUCT_CREATIVELABS_SBLIVE },
	{ PCI_VENDOR_CREATIVELABS, PCI_PRODUCT_CREATIVELABS_AUDIGY },
	{ PCI_VENDOR_CREATIVELABS, PCI_PRODUCT_CREATIVELABS_AUDIGY2 },
};

/*
 * Autoconfig goo.
 */
struct cfdriver emu_cd = {
	NULL, "emu", DV_DULL
};

struct cfattach emu_ca = {
        sizeof(struct emuxki_softc),
        emuxki_match,
        emuxki_attach,
	emuxki_detach,
	emuxki_activate
};

struct audio_hw_if emuxki_hw_if = {
	emuxki_open,
	emuxki_close,
	emuxki_set_params,
	emuxki_round_blocksize,
	NULL,			/* commit settings */
	NULL,			/* init_output */
	NULL,			/* init_input */
	NULL,			/* start_output */
	NULL,			/* start_input */
	emuxki_halt_output,
	emuxki_halt_input,
	NULL,			/* speaker_ctl */
	NULL,			/* setfd */
	emuxki_set_port,
	emuxki_get_port,
	emuxki_query_devinfo,
	emuxki_allocm,
	emuxki_freem,
	emuxki_round_buffersize,
	emuxki_get_props,
	emuxki_trigger_output,
	emuxki_trigger_input
};

#if 0
static const int emuxki_recsrc_intrmasks[EMU_NUMRECSRCS] =
    { EMU_INTE_MICBUFENABLE, EMU_INTE_ADCBUFENABLE, EMU_INTE_EFXBUFENABLE };
#endif
static const u_int32_t emuxki_recsrc_bufaddrreg[EMU_NUMRECSRCS] =
    { EMU_MICBA, EMU_ADCBA, EMU_FXBA };
static const u_int32_t emuxki_recsrc_szreg[EMU_NUMRECSRCS] =
    { EMU_MICBS, EMU_ADCBS, EMU_FXBS };
static const int emuxki_recbuf_sz[] = {
	0, 384, 448, 512, 640, 768, 896, 1024, 1280, 1536, 1792,
	2048, 2560, 3072, 3584, 4096, 5120, 6144, 7168, 8192, 10240,
	12288, 14366, 16384, 20480, 24576, 28672, 32768, 40960, 49152,
	57344, 65536
};

/*
 * DMA memory mgmt
 */

void
emuxki_dmamem_delete(struct dmamem *mem, int type)
{
	free(mem->segs, type, 0);
	free(mem, type, 0);
}

struct dmamem *
emuxki_dmamem_alloc(bus_dma_tag_t dmat, size_t size, bus_size_t align,
	     int nsegs, int type, int flags)
{
	struct dmamem	*mem;
	int		bus_dma_flags;

	/* Allocate memory for structure */
	if ((mem = malloc(sizeof(*mem), type, flags)) == NULL)
		return (NULL);
	mem->dmat = dmat;
	mem->size = size;
	mem->align = align;
	mem->nsegs = nsegs;
	mem->bound = 0;

	mem->segs = mallocarray(mem->nsegs, sizeof(*(mem->segs)), type, flags);
	if (mem->segs == NULL) {
		free(mem, type, 0);
		return (NULL);
	}

	bus_dma_flags = (flags & M_NOWAIT) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK;
	if (bus_dmamem_alloc(dmat, mem->size, mem->align, mem->bound,
			     mem->segs, mem->nsegs, &(mem->rsegs),
			     bus_dma_flags)) {
		emuxki_dmamem_delete(mem, type);
		return (NULL);
	}

	if (bus_dmamem_map(dmat, mem->segs, mem->nsegs, mem->size,
			   &(mem->kaddr), bus_dma_flags | BUS_DMA_COHERENT)) {
		bus_dmamem_free(dmat, mem->segs, mem->nsegs);
		emuxki_dmamem_delete(mem, type);
		return (NULL);
	}

	if (bus_dmamap_create(dmat, mem->size, mem->nsegs, mem->size,
			      mem->bound, bus_dma_flags, &(mem->map))) {
		bus_dmamem_unmap(dmat, mem->kaddr, mem->size);
		bus_dmamem_free(dmat, mem->segs, mem->nsegs);
		emuxki_dmamem_delete(mem, type);
		return (NULL);
	}

	if (bus_dmamap_load(dmat, mem->map, mem->kaddr, 
			    mem->size, NULL, bus_dma_flags)) {
		bus_dmamap_destroy(dmat, mem->map);
		bus_dmamem_unmap(dmat, mem->kaddr, mem->size);
		bus_dmamem_free(dmat, mem->segs, mem->nsegs);
		emuxki_dmamem_delete(mem, type);
		return (NULL);
	}

	return (mem);
}

void
emuxki_dmamem_free(struct dmamem *mem, int type)
{
	bus_dmamap_unload(mem->dmat, mem->map);
	bus_dmamap_destroy(mem->dmat, mem->map);
	bus_dmamem_unmap(mem->dmat, mem->kaddr, mem->size);
	bus_dmamem_free(mem->dmat, mem->segs, mem->nsegs);
	emuxki_dmamem_delete(mem, type);
}


/*
 * Autoconf device callbacks : attach and detach
 */

void
emuxki_pci_shutdown(struct emuxki_softc *sc)
{
	if (sc->sc_ih != NULL)
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
	if (sc->sc_ios)
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
}

int
emuxki_scinit(struct emuxki_softc *sc, int resuming)
{
	int             err;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_HCFG,
		/* enable spdif(?) output on non-APS */
		(sc->sc_flags & EMUXKI_APS? 0 : EMU_HCFG_GPOUTPUT0) |
		EMU_HCFG_LOCKSOUNDCACHE | EMU_HCFG_LOCKTANKCACHE_MASK |
		EMU_HCFG_MUTEBUTTONENABLE);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_INTE,
		EMU_INTE_SAMPLERATER | EMU_INTE_PCIERRENABLE);

	if ((err = emuxki_init(sc, resuming)))
		return (err);

	if (sc->sc_flags & EMUXKI_AUDIGY2) {
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_HCFG,
			EMU_HCFG_AUDIOENABLE | EMU_HCFG_AC3ENABLE_CDSPDIF |
			EMU_HCFG_AC3ENABLE_GPSPDIF | EMU_HCFG_AUTOMUTE);
	} else if (sc->sc_flags & EMUXKI_AUDIGY) {
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_HCFG,
			EMU_HCFG_AUDIOENABLE | EMU_HCFG_AUTOMUTE);
	} else {
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_HCFG,
			EMU_HCFG_AUDIOENABLE | EMU_HCFG_JOYENABLE |
			EMU_HCFG_LOCKTANKCACHE_MASK | EMU_HCFG_AUTOMUTE);
	}
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_INTE,
		bus_space_read_4(sc->sc_iot, sc->sc_ioh, EMU_INTE) |
		EMU_INTE_VOLINCRENABLE | EMU_INTE_VOLDECRENABLE |
		EMU_INTE_MUTEENABLE);

	if (sc->sc_flags & EMUXKI_AUDIGY2) {
		if (sc->sc_flags & EMUXKI_CA0108) {
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A_IOCFG,
			    0x0060 | bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    EMU_A_IOCFG));
		} else {
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A_IOCFG,
			    EMU_A_IOCFG_GPOUT0 | bus_space_read_4(sc->sc_iot,
			    sc->sc_ioh, EMU_A_IOCFG));
		}
	}

	if (!resuming) {
		/* No multiple voice support for now */
		sc->pvoice = sc->rvoice = NULL;
	}

	return (0);
}

int
emuxki_ac97_init(struct emuxki_softc *sc)
{
	sc->hostif.arg = sc;
	sc->hostif.attach = emuxki_ac97_attach;
	sc->hostif.read = emuxki_ac97_read;
	sc->hostif.write = emuxki_ac97_write;
	sc->hostif.reset = emuxki_ac97_reset;
	sc->hostif.flags = NULL;
	return (ac97_attach(&(sc->hostif)));
}

int
emuxki_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, emuxki_devices,
	    nitems(emuxki_devices)));
}

void
emuxki_attach(struct device *parent, struct device *self, void *aux)
{
	struct emuxki_softc *sc = (struct emuxki_softc *) self;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
	const char     *intrstr;

	if (pci_mapreg_map(pa, EMU_PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
	    &(sc->sc_iot), &(sc->sc_ioh), &(sc->sc_iob), &(sc->sc_ios), 0)) {
		printf(": can't map i/o space\n");
		return;
	}

	sc->sc_pc   = pa->pa_pc;
	sc->sc_dmat = pa->pa_dmat;

	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		return;
	}

	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    emuxki_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		return;
	}
	printf(": %s\n", intrstr);

	/* XXX it's unknown whether APS is made from Audigy as well */
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_AUDIGY) {
		sc->sc_flags |= EMUXKI_AUDIGY;
                if (PCI_REVISION(pa->pa_class) == 0x04 ||
		    PCI_REVISION(pa->pa_class) == 0x08) {
			sc->sc_flags |= EMUXKI_AUDIGY2;
		}
	} else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_AUDIGY2) {
		sc->sc_flags |= EMUXKI_AUDIGY | EMUXKI_AUDIGY2;
		if (pci_conf_read(pa->pa_pc, pa->pa_tag,
		    PCI_SUBSYS_ID_REG) == 0x10011102) {
			sc->sc_flags |= EMUXKI_CA0108;
		}
	} else if (pci_conf_read(pa->pa_pc, pa->pa_tag,
	    PCI_SUBSYS_ID_REG) == EMU_SUBSYS_APS) {
		sc->sc_flags |= EMUXKI_APS;
	} else {
		sc->sc_flags |= EMUXKI_SBLIVE;
	}

	if (emuxki_scinit(sc, 0) ||
	    /* APS has no ac97 XXX */
	    (sc->sc_flags & EMUXKI_APS || emuxki_ac97_init(sc)) ||
	    (sc->sc_audev = audio_attach_mi(&emuxki_hw_if, sc, self)) == NULL) {
		emuxki_pci_shutdown(sc);
		return;
	}
}

int
emuxki_detach(struct device *self, int flags)
{
	struct emuxki_softc *sc = (struct emuxki_softc *) self;

        if (sc->sc_audev != NULL) /* Test in case audio didn't attach */
		config_detach(sc->sc_audev, 0);

	/* All voices should be stopped now but add some code here if not */

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_HCFG,
		EMU_HCFG_LOCKSOUNDCACHE | EMU_HCFG_LOCKTANKCACHE_MASK |
		EMU_HCFG_MUTEBUTTONENABLE);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_INTE, 0);

	emuxki_shutdown(sc);

	emuxki_pci_shutdown(sc);

	return (0);
}

int
emuxki_activate(struct device *self, int act)
{
	struct emuxki_softc *sc = (struct emuxki_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		emuxki_scinit(sc, 1);
		ac97_resume(&sc->hostif, sc->codecif);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

/* Misc stuff relative to emu10k1 */

static u_int32_t
emuxki_rate_to_pitch(u_int32_t rate)
{
	static const u_int32_t logMagTable[128] = {
		0x00000, 0x02dfc, 0x05b9e, 0x088e6, 0x0b5d6, 0x0e26f, 0x10eb3,
		0x13aa2, 0x1663f, 0x1918a, 0x1bc84, 0x1e72e, 0x2118b, 0x23b9a,
		0x2655d, 0x28ed5, 0x2b803, 0x2e0e8, 0x30985, 0x331db, 0x359eb,
		0x381b6, 0x3a93d, 0x3d081, 0x3f782, 0x41e42, 0x444c1, 0x46b01,
		0x49101, 0x4b6c4, 0x4dc49, 0x50191, 0x5269e, 0x54b6f, 0x57006,
		0x59463, 0x5b888, 0x5dc74, 0x60029, 0x623a7, 0x646ee, 0x66a00,
		0x68cdd, 0x6af86, 0x6d1fa, 0x6f43c, 0x7164b, 0x73829, 0x759d4,
		0x77b4f, 0x79c9a, 0x7bdb5, 0x7dea1, 0x7ff5e, 0x81fed, 0x8404e,
		0x86082, 0x88089, 0x8a064, 0x8c014, 0x8df98, 0x8fef1, 0x91e20,
		0x93d26, 0x95c01, 0x97ab4, 0x9993e, 0x9b79f, 0x9d5d9, 0x9f3ec,
		0xa11d8, 0xa2f9d, 0xa4d3c, 0xa6ab5, 0xa8808, 0xaa537, 0xac241,
		0xadf26, 0xafbe7, 0xb1885, 0xb3500, 0xb5157, 0xb6d8c, 0xb899f,
		0xba58f, 0xbc15e, 0xbdd0c, 0xbf899, 0xc1404, 0xc2f50, 0xc4a7b,
		0xc6587, 0xc8073, 0xc9b3f, 0xcb5ed, 0xcd07c, 0xceaec, 0xd053f,
		0xd1f73, 0xd398a, 0xd5384, 0xd6d60, 0xd8720, 0xda0c3, 0xdba4a,
		0xdd3b4, 0xded03, 0xe0636, 0xe1f4e, 0xe384a, 0xe512c, 0xe69f3,
		0xe829f, 0xe9b31, 0xeb3a9, 0xecc08, 0xee44c, 0xefc78, 0xf148a,
		0xf2c83, 0xf4463, 0xf5c2a, 0xf73da, 0xf8b71, 0xfa2f0, 0xfba57,
		0xfd1a7, 0xfe8df
	};
	static const u_int8_t logSlopeTable[128] = {
		0x5c, 0x5c, 0x5b, 0x5a, 0x5a, 0x59, 0x58, 0x58,
		0x57, 0x56, 0x56, 0x55, 0x55, 0x54, 0x53, 0x53,
		0x52, 0x52, 0x51, 0x51, 0x50, 0x50, 0x4f, 0x4f,
		0x4e, 0x4d, 0x4d, 0x4d, 0x4c, 0x4c, 0x4b, 0x4b,
		0x4a, 0x4a, 0x49, 0x49, 0x48, 0x48, 0x47, 0x47,
		0x47, 0x46, 0x46, 0x45, 0x45, 0x45, 0x44, 0x44,
		0x43, 0x43, 0x43, 0x42, 0x42, 0x42, 0x41, 0x41,
		0x41, 0x40, 0x40, 0x40, 0x3f, 0x3f, 0x3f, 0x3e,
		0x3e, 0x3e, 0x3d, 0x3d, 0x3d, 0x3c, 0x3c, 0x3c,
		0x3b, 0x3b, 0x3b, 0x3b, 0x3a, 0x3a, 0x3a, 0x39,
		0x39, 0x39, 0x39, 0x38, 0x38, 0x38, 0x38, 0x37,
		0x37, 0x37, 0x37, 0x36, 0x36, 0x36, 0x36, 0x35,
		0x35, 0x35, 0x35, 0x34, 0x34, 0x34, 0x34, 0x34,
		0x33, 0x33, 0x33, 0x33, 0x32, 0x32, 0x32, 0x32,
		0x32, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30,
		0x30, 0x30, 0x30, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f
	};
	int8_t          i;

	if (rate == 0)
		return 0;	/* Bail out if no leading "1" */
	rate *= 11185;		/* Scale 48000 to 0x20002380 */
	for (i = 31; i > 0; i--) {
		if (rate & 0x80000000) {	/* Detect leading "1" */
			return (((u_int32_t) (i - 15) << 20) +
				logMagTable[0x7f & (rate >> 24)] +
				(0x7f & (rate >> 17)) *
				logSlopeTable[0x7f & (rate >> 24)]);
		}
		rate <<= 1;
	}

	return 0;		/* Should never reach this point */
}

/* Emu10k1 Low level */

static u_int32_t
emuxki_read(struct emuxki_softc *sc, u_int16_t chano, u_int32_t reg)
{
	u_int32_t       ptr, mask = 0xffffffff;
	u_int8_t        size, offset = 0;

	ptr = ((((u_int32_t) reg) << 16) &
		(sc->sc_flags & EMUXKI_AUDIGY ?
			EMU_A_PTR_ADDR_MASK : EMU_PTR_ADDR_MASK)) |
		(chano & EMU_PTR_CHNO_MASK);
	if (reg & 0xff000000) {
		size = (reg >> 24) & 0x3f;
		offset = (reg >> 16) & 0x1f;
		mask = ((1 << size) - 1) << offset;
	}

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_PTR, ptr);
	ptr = (bus_space_read_4(sc->sc_iot, sc->sc_ioh, EMU_DATA) & mask)
		>> offset;
	return (ptr);
}

static void
emuxki_write(struct emuxki_softc *sc, u_int16_t chano,
	      u_int32_t reg, u_int32_t data)
{
	u_int32_t       ptr, mask;
	u_int8_t        size, offset;

	ptr = ((((u_int32_t) reg) << 16) &
		(sc->sc_flags & EMUXKI_AUDIGY ?
			EMU_A_PTR_ADDR_MASK : EMU_PTR_ADDR_MASK)) |
		(chano & EMU_PTR_CHNO_MASK);

	/* BE CAREFUL WITH THAT AXE, EUGENE */
	if (ptr == 0x52 || ptr == 0x53)
		return;

	if (reg & 0xff000000) {
		size = (reg >> 24) & 0x3f;
		offset = (reg >> 16) & 0x1f;
		mask = ((1 << size) - 1) << offset;
		data = ((data << offset) & mask) |
			(emuxki_read(sc, chano, reg & 0xffff) & ~mask);
	}

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_PTR, ptr);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_DATA, data);
}

/* Microcode should this go in /sys/dev/microcode ? */

void
emuxki_write_micro(struct emuxki_softc *sc, u_int32_t pc, u_int32_t data)
{
	emuxki_write(sc, 0,
		(sc->sc_flags & EMUXKI_AUDIGY ?
			EMU_A_MICROCODEBASE : EMU_MICROCODEBASE) + pc,
		 data);
}

void
emuxki_dsp_addop(struct emuxki_softc *sc, u_int16_t *pc, u_int8_t op,
		  u_int16_t r, u_int16_t a, u_int16_t x, u_int16_t y)
{
	if (sc->sc_flags & EMUXKI_AUDIGY) {
		emuxki_write_micro(sc, *pc << 1,
			((x << 12) & EMU_A_DSP_LOWORD_OPX_MASK) |
			(y & EMU_A_DSP_LOWORD_OPY_MASK));
		emuxki_write_micro(sc, (*pc << 1) + 1,
			((op << 24) & EMU_A_DSP_HIWORD_OPCODE_MASK) |
			((r << 12) & EMU_A_DSP_HIWORD_RESULT_MASK) |
			(a & EMU_A_DSP_HIWORD_OPA_MASK));
	} else {
		emuxki_write_micro(sc, *pc << 1,
			((x << 10) & EMU_DSP_LOWORD_OPX_MASK) |
			(y & EMU_DSP_LOWORD_OPY_MASK));
		emuxki_write_micro(sc, (*pc << 1) + 1,
			((op << 20) & EMU_DSP_HIWORD_OPCODE_MASK) |
			((r << 10) & EMU_DSP_HIWORD_RESULT_MASK) |
			(a & EMU_DSP_HIWORD_OPA_MASK));
	}
	(*pc)++;
}

/* init and shutdown */

void
emuxki_initfx(struct emuxki_softc *sc)
{
	u_int16_t       pc;

	/* Set all GPRs to 0 */
	for (pc = 0; pc < 256; pc++)
		emuxki_write(sc, 0, EMU_DSP_GPR(pc), 0);
	for (pc = 0; pc < 160; pc++) {
		emuxki_write(sc, 0, EMU_TANKMEMDATAREGBASE + pc, 0);
		emuxki_write(sc, 0, EMU_TANKMEMADDRREGBASE + pc, 0);
	}
	pc = 0;

	if (sc->sc_flags & EMUXKI_AUDIGY) {
		/* AC97 Out (l/r) = AC97 In (l/r) + FX[0/1] * 4 */
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
				  EMU_A_DSP_OUTL(EMU_A_DSP_OUT_A_FRONT),
				  EMU_A_DSP_CST(0),
				  EMU_DSP_FX(0), EMU_A_DSP_CST(4));
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
				  EMU_A_DSP_OUTR(EMU_A_DSP_OUT_A_FRONT),
				  EMU_A_DSP_CST(0),
				  EMU_DSP_FX(1), EMU_A_DSP_CST(4));

		/* Rear channel OUT (l/r) = FX[2/3] * 4 */
#if 0
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
				  EMU_A_DSP_OUTL(EMU_A_DSP_OUT_A_REAR),
				  EMU_A_DSP_OUTL(EMU_A_DSP_OUT_A_FRONT),
				  EMU_DSP_FX(0), EMU_A_DSP_CST(4));
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
				  EMU_A_DSP_OUTR(EMU_A_DSP_OUT_A_REAR),
				  EMU_A_DSP_OUTR(EMU_A_DSP_OUT_A_FRONT),
				  EMU_DSP_FX(1), EMU_A_DSP_CST(4));
#endif
		/* ADC recording (l/r) = AC97 In (l/r) */
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
				  EMU_A_DSP_OUTL(EMU_A_DSP_OUT_ADC),
				  EMU_A_DSP_INL(EMU_DSP_IN_AC97),
				  EMU_A_DSP_CST(0), EMU_A_DSP_CST(0));
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
				  EMU_A_DSP_OUTR(EMU_A_DSP_OUT_ADC),
				  EMU_A_DSP_INR(EMU_DSP_IN_AC97),
				  EMU_A_DSP_CST(0), EMU_A_DSP_CST(0));

		/* zero out the rest of the microcode */
		while (pc < 512)
			emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
					  EMU_A_DSP_CST(0), EMU_A_DSP_CST(0),
					  EMU_A_DSP_CST(0), EMU_A_DSP_CST(0));

		emuxki_write(sc, 0, EMU_A_DBG, 0);	/* Is it really necessary ? */
	} else {
		/* AC97 Out (l/r) = AC97 In (l/r) + FX[0/1] * 4 */
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
				  EMU_DSP_OUTL(EMU_DSP_OUT_A_FRONT),
				  EMU_DSP_CST(0),
				  EMU_DSP_FX(0), EMU_DSP_CST(4));
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
				  EMU_DSP_OUTR(EMU_DSP_OUT_A_FRONT),
				  EMU_DSP_CST(0),
				  EMU_DSP_FX(1), EMU_DSP_CST(4));

		/* Rear channel OUT (l/r) = FX[2/3] * 4 */
#if 0
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
				  EMU_DSP_OUTL(EMU_DSP_OUT_AD_REAR),
				  EMU_DSP_OUTL(EMU_DSP_OUT_A_FRONT),
				  EMU_DSP_FX(0), EMU_DSP_CST(4));
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
				  EMU_DSP_OUTR(EMU_DSP_OUT_AD_REAR),
				  EMU_DSP_OUTR(EMU_DSP_OUT_A_FRONT),
				  EMU_DSP_FX(1), EMU_DSP_CST(4));
#endif
		/* ADC recording (l/r) = AC97 In (l/r) */
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
				  EMU_DSP_OUTL(EMU_DSP_OUT_ADC),
				  EMU_DSP_INL(EMU_DSP_IN_AC97),
				  EMU_DSP_CST(0), EMU_DSP_CST(0));
		emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
				  EMU_DSP_OUTR(EMU_DSP_OUT_ADC),
				  EMU_DSP_INR(EMU_DSP_IN_AC97),
				  EMU_DSP_CST(0), EMU_DSP_CST(0));

		/* zero out the rest of the microcode */
		while (pc < 512)
			emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
					  EMU_DSP_CST(0), EMU_DSP_CST(0),
					  EMU_DSP_CST(0), EMU_DSP_CST(0));

		emuxki_write(sc, 0, EMU_DBG, 0);	/* Is it really necessary ? */
	}
}

int
emuxki_init(struct emuxki_softc *sc, int resuming)
{
	u_int16_t       i;
	u_int32_t       spcs, *ptb;
	bus_addr_t      silentpage;

	/* disable any channel interrupt */
	emuxki_write(sc, 0, EMU_CLIEL, 0);
	emuxki_write(sc, 0, EMU_CLIEH, 0);
	emuxki_write(sc, 0, EMU_SOLEL, 0);
	emuxki_write(sc, 0, EMU_SOLEH, 0);

	/* Set recording buffers sizes to zero */
	emuxki_write(sc, 0, EMU_MICBS, EMU_RECBS_BUFSIZE_NONE);
	emuxki_write(sc, 0, EMU_MICBA, 0);
	emuxki_write(sc, 0, EMU_FXBS, EMU_RECBS_BUFSIZE_NONE);
	emuxki_write(sc, 0, EMU_FXBA, 0);
	emuxki_write(sc, 0, EMU_ADCBS, EMU_RECBS_BUFSIZE_NONE);
	emuxki_write(sc, 0, EMU_ADCBA, 0);

        if (sc->sc_flags & EMUXKI_AUDIGY) {
                emuxki_write(sc, 0, EMU_SPBYPASS, EMU_SPBYPASS_24_BITS);
                emuxki_write(sc, 0, EMU_AC97SLOT, EMU_AC97SLOT_CENTER | EMU_AC97SLOT_LFE);
        }

	/* Initialize all channels to stopped and no effects */
	for (i = 0; i < EMU_NUMCHAN; i++) {
		emuxki_write(sc, i, EMU_CHAN_DCYSUSV, 0);
		emuxki_write(sc, i, EMU_CHAN_IP, 0);
		emuxki_write(sc, i, EMU_CHAN_VTFT, 0xffff);
		emuxki_write(sc, i, EMU_CHAN_CVCF, 0xffff);
		emuxki_write(sc, i, EMU_CHAN_PTRX, 0);
		emuxki_write(sc, i, EMU_CHAN_CPF, 0);
		emuxki_write(sc, i, EMU_CHAN_CCR, 0);
		emuxki_write(sc, i, EMU_CHAN_PSST, 0);
		emuxki_write(sc, i, EMU_CHAN_DSL, 0x10);	/* Why 16 ? */
		emuxki_write(sc, i, EMU_CHAN_CCCA, 0);
		emuxki_write(sc, i, EMU_CHAN_Z1, 0);
		emuxki_write(sc, i, EMU_CHAN_Z2, 0);
		emuxki_write(sc, i, EMU_CHAN_FXRT, 0x32100000);
		emuxki_write(sc, i, EMU_CHAN_ATKHLDM, 0);
		emuxki_write(sc, i, EMU_CHAN_DCYSUSM, 0);
		emuxki_write(sc, i, EMU_CHAN_IFATN, 0xffff);
		emuxki_write(sc, i, EMU_CHAN_PEFE, 0);
		emuxki_write(sc, i, EMU_CHAN_FMMOD, 0);
		emuxki_write(sc, i, EMU_CHAN_TREMFRQ, 24);
		emuxki_write(sc, i, EMU_CHAN_FM2FRQ2, 24);
		emuxki_write(sc, i, EMU_CHAN_TEMPENV, 0);

		/* these are last so OFF prevents writing */
		emuxki_write(sc, i, EMU_CHAN_LFOVAL2, 0);
		emuxki_write(sc, i, EMU_CHAN_LFOVAL1, 0);
		emuxki_write(sc, i, EMU_CHAN_ATKHLDV, 0);
		emuxki_write(sc, i, EMU_CHAN_ENVVOL, 0);
		emuxki_write(sc, i, EMU_CHAN_ENVVAL, 0);
	}

	/* set digital outputs format */
	spcs = (EMU_SPCS_CLKACCY_1000PPM | EMU_SPCS_SAMPLERATE_48 |
	      EMU_SPCS_CHANNELNUM_LEFT | EMU_SPCS_SOURCENUM_UNSPEC |
		EMU_SPCS_GENERATIONSTATUS | 0x00001200 /* Cat code. */ |
		0x00000000 /* IEC-958 Mode */ | EMU_SPCS_EMPHASIS_NONE |
		EMU_SPCS_COPYRIGHT);
	emuxki_write(sc, 0, EMU_SPCS0, spcs);
	emuxki_write(sc, 0, EMU_SPCS1, spcs);
	emuxki_write(sc, 0, EMU_SPCS2, spcs);

	if (sc->sc_flags & EMUXKI_CA0108) {
		u_int32_t tmp;

		/* Setup SRCMulti_I2S SamplingRate */
		tmp = emuxki_read(sc, 0, EMU_A_SPDIF_SAMPLERATE) & 0xfffff1ff;
		emuxki_write(sc, 0, EMU_A_SPDIF_SAMPLERATE, tmp | 0x400);

		/* Setup SRCSel (Enable SPDIF, I2S SRCMulti) */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_PTR, EMU_A2_SRCSEL);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_DATA,
		EMU_A2_SRCSEL_ENABLE_SPDIF | EMU_A2_SRCSEL_ENABLE_SRCMULTI);

		/* Setup SRCMulti Input Audio Enable */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_PTR, 0x7b0000);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_DATA, 0xff000000);

		/* Setup SPDIF Out Audio Enable
		 * The Audigy 2 Value has a separate SPDIF out,
		 * so no need for a mixer switch */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_PTR, 0x7a0000);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_DATA, 0xff000000);
		tmp = bus_space_read_4(sc->sc_iot, sc->sc_ioh, EMU_A_IOCFG) & ~0x8; /* Clear bit 3 */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A_IOCFG, tmp);
	} else if(sc->sc_flags & EMUXKI_AUDIGY2) {
                emuxki_write(sc, 0, EMU_A2_SPDIF_SAMPLERATE, EMU_A2_SPDIF_UNKNOWN);

                bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_PTR, EMU_A2_SRCSEL);
                bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_DATA, 
                        EMU_A2_SRCSEL_ENABLE_SPDIF | EMU_A2_SRCSEL_ENABLE_SRCMULTI);

                bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_PTR, EMU_A2_SRCMULTI);
                bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A2_DATA, EMU_A2_SRCMULTI_ENABLE_INPUT);
        }


	/* Let's play with sound processor */
	emuxki_initfx(sc);

	if (!resuming) {
		/* Here is our Page Table */
		if ((sc->ptb = emuxki_dmamem_alloc(sc->sc_dmat,
		    EMU_MAXPTE * sizeof(u_int32_t),
		    EMU_DMA_ALIGN, EMU_DMAMEM_NSEG,
		    M_DEVBUF, M_WAITOK)) == NULL)
			return (ENOMEM);

		/* This is necessary unless you like Metallic noise... */
		if ((sc->silentpage = emuxki_dmamem_alloc(sc->sc_dmat, EMU_PTESIZE,
		    EMU_DMA_ALIGN, EMU_DMAMEM_NSEG, M_DEVBUF, M_WAITOK))==NULL){
			emuxki_dmamem_free(sc->ptb, M_DEVBUF);
			return (ENOMEM);
		}

		/* Zero out the silent page */
		/* This might not be always true, it might be 128 for 8bit channels */
		memset(KERNADDR(sc->silentpage), 0, DMASIZE(sc->silentpage));
	}

	/*
	 * Set all the PTB Entries to the silent page We shift the physical
	 * address by one and OR it with the page number. I don't know what
	 * the ORed index is for, might be a very useful unused feature...
	 */
	silentpage = DMAADDR(sc->silentpage) << 1;
	ptb = KERNADDR(sc->ptb);
	for (i = 0; i < EMU_MAXPTE; i++)
		ptb[i] = htole32(silentpage | i);

	/* Write PTB address and set TCB to none */
	emuxki_write(sc, 0, EMU_PTB, DMAADDR(sc->ptb));
	emuxki_write(sc, 0, EMU_TCBS, 0);	/* This means 16K TCB */
	emuxki_write(sc, 0, EMU_TCB, 0);	/* No TCB use for now */

	/*
	 * Set channels MAPs to the silent page.
	 * I don't know what MAPs are for.
	 */
	silentpage |= EMU_CHAN_MAP_PTI_MASK;
	for (i = 0; i < EMU_NUMCHAN; i++) {
		emuxki_write(sc, i, EMU_CHAN_MAPA, silentpage);
		emuxki_write(sc, i, EMU_CHAN_MAPB, silentpage);
		sc->channel[i] = NULL;
	}

	if (!resuming) {
		/* Init voices list */
		LIST_INIT(&(sc->voices));
	}

	/* Timer is stopped */
	sc->timerstate &= ~EMU_TIMER_STATE_ENABLED;
	return (0);
}

void
emuxki_shutdown(struct emuxki_softc *sc)
{
	u_int32_t       i;

	/* Disable any Channels interrupts */
	emuxki_write(sc, 0, EMU_CLIEL, 0);
	emuxki_write(sc, 0, EMU_CLIEH, 0);
	emuxki_write(sc, 0, EMU_SOLEL, 0);
	emuxki_write(sc, 0, EMU_SOLEH, 0);

	/*
	 * Should do some voice(stream) stopping stuff here, that's what will
	 * stop and deallocate all channels.
	 */

	/* Stop all channels */
	/* XXX This shouldn't be necessary, I'll remove once everything works */
	for (i = 0; i < EMU_NUMCHAN; i++)
		emuxki_write(sc, i, EMU_CHAN_DCYSUSV, 0);
	for (i = 0; i < EMU_NUMCHAN; i++) {
		emuxki_write(sc, i, EMU_CHAN_VTFT, 0);
		emuxki_write(sc, i, EMU_CHAN_CVCF, 0);
		emuxki_write(sc, i, EMU_CHAN_PTRX, 0);
		emuxki_write(sc, i, EMU_CHAN_CPF, 0);
	}

	/*
	 * Deallocate Emu10k1 caches and recording buffers. Again it will be
	 * removed because it will be done in voice shutdown.
	 */
	emuxki_write(sc, 0, EMU_MICBS, EMU_RECBS_BUFSIZE_NONE);
	emuxki_write(sc, 0, EMU_MICBA, 0);
	emuxki_write(sc, 0, EMU_FXBS, EMU_RECBS_BUFSIZE_NONE);
	emuxki_write(sc, 0, EMU_FXBA, 0);
	if (sc->sc_flags & EMUXKI_AUDIGY) {
		emuxki_write(sc, 0, EMU_A_FXWC1, 0);
		emuxki_write(sc, 0, EMU_A_FXWC2, 0);
	} else
		emuxki_write(sc, 0, EMU_FXWC, 0);
	emuxki_write(sc, 0, EMU_ADCBS, EMU_RECBS_BUFSIZE_NONE);
	emuxki_write(sc, 0, EMU_ADCBA, 0);

	/*
	 * XXX I don't know yet how I will handle tank cache buffer,
	 * I don't even clearly  know what it is for.
	 */
	emuxki_write(sc, 0, EMU_TCB, 0);	/* 16K again */
	emuxki_write(sc, 0, EMU_TCBS, 0);

	emuxki_write(sc, 0, EMU_DBG, 0x8000);	/* necessary ? */

	emuxki_dmamem_free(sc->silentpage, M_DEVBUF);
	emuxki_dmamem_free(sc->ptb, M_DEVBUF);
}

/* Emu10k1 Memory management */

struct emuxki_mem *
emuxki_mem_new(struct emuxki_softc *sc, int ptbidx,
		size_t size, int type, int flags)
{
	struct emuxki_mem *mem;

	if ((mem = malloc(sizeof(*mem), type, flags)) == NULL)
		return (NULL);

	mem->ptbidx = ptbidx;
	if ((mem->dmamem = emuxki_dmamem_alloc(sc->sc_dmat, size,
	    EMU_DMA_ALIGN, EMU_DMAMEM_NSEG, type, flags)) == NULL) {
		free(mem, type, 0);
		return (NULL);
	}
	return (mem);
}

void
emuxki_mem_delete(struct emuxki_mem *mem, int type)
{
	emuxki_dmamem_free(mem->dmamem, type);
	free(mem, type, 0);
}

void *
emuxki_pmem_alloc(struct emuxki_softc *sc, size_t size, int type, int flags)
{
	int             i, j;
	size_t          numblocks;
	struct emuxki_mem *mem;
	u_int32_t      *ptb, silentpage;

	ptb = KERNADDR(sc->ptb);
	silentpage = DMAADDR(sc->silentpage) << 1;
	numblocks = size / EMU_PTESIZE;
	if (size % EMU_PTESIZE)
		numblocks++;

	for (i = 0; i < EMU_MAXPTE; i++)
		if ((letoh32(ptb[i]) & EMU_CHAN_MAP_PTE_MASK) == silentpage) {
			/* We look for a free PTE */
			for (j = 0; j < numblocks; j++)
				if ((letoh32(ptb[i + j])
				    & EMU_CHAN_MAP_PTE_MASK)
				    != silentpage)
					break;
			if (j == numblocks) {
				if ((mem = emuxki_mem_new(sc, i,
						size, type, flags)) == NULL) {
					return (NULL);
				}
				for (j = 0; j < numblocks; j++)
					ptb[i + j] =
					    htole32((((DMAADDR(mem->dmamem) +
					    j * EMU_PTESIZE)) << 1) | (i + j));
				mtx_enter(&audio_lock);
				LIST_INSERT_HEAD(&(sc->mem), mem, next);
				mtx_leave(&audio_lock);
				return (KERNADDR(mem->dmamem));
			} else
				i += j;
		}
	return (NULL);
}

void *
emuxki_rmem_alloc(struct emuxki_softc *sc, size_t size, int type, int flags)
{
	struct emuxki_mem *mem;

	mem = emuxki_mem_new(sc, EMU_RMEM, size, type, flags);
	if (mem == NULL)
		return (NULL);

	mtx_enter(&audio_lock);
	LIST_INSERT_HEAD(&(sc->mem), mem, next);
	mtx_leave(&audio_lock);

	return (KERNADDR(mem->dmamem));
}

/*
 * emuxki_channel_* : Channel management functions
 * emuxki_chanparms_* : Channel parameters modification functions
 */

/*
 * is splaudio necessary here, can the same voice be manipulated by two
 * different threads at a time ?
 */
void
emuxki_chanparms_set_defaults(struct emuxki_channel *chan)
{
	chan->fxsend.a.level = chan->fxsend.b.level =
	chan->fxsend.c.level = chan->fxsend.d.level =
	/* for audigy */
	chan->fxsend.e.level = chan->fxsend.f.level =
	chan->fxsend.g.level = chan->fxsend.h.level =
		chan->voice->sc->sc_flags & EMUXKI_AUDIGY ?
			0xc0 : 0xff;	/* not max */

	chan->fxsend.a.dest = 0x0;
	chan->fxsend.b.dest = 0x1;
	chan->fxsend.c.dest = 0x2;
	chan->fxsend.d.dest = 0x3;
	/* for audigy */
	chan->fxsend.e.dest = 0x4;
	chan->fxsend.f.dest = 0x5;
	chan->fxsend.g.dest = 0x6;
	chan->fxsend.h.dest = 0x7;

	chan->pitch.initial = 0x0000;	/* shouldn't it be 0xE000 ? */
	chan->pitch.current = 0x0000;	/* should it be 0x0400 */
	chan->pitch.target = 0x0000;	/* the unity pitch shift ? */
	chan->pitch.envelope_amount = 0x00;	/* none */

	chan->initial_attenuation = 0x00;	/* no attenuation */
	chan->volume.current = 0x0000;	/* no volume */
	chan->volume.target = 0xffff;
	chan->volume.envelope.current_state = 0x8000;	/* 0 msec delay */
	chan->volume.envelope.hold_time = 0x7f;	/* 0 msec */
	chan->volume.envelope.attack_time = 0x7F;	/* 5.5msec */
	chan->volume.envelope.sustain_level = 0x7F;	/* full  */
	chan->volume.envelope.decay_time = 0x7F;	/* 22msec  */

	chan->filter.initial_cutoff_frequency = 0xff;	/* no filter */
	chan->filter.current_cutoff_frequency = 0xffff;	/* no filtering */
	chan->filter.target_cutoff_frequency = 0xffff;	/* no filtering */
	chan->filter.lowpass_resonance_height = 0x0;
	chan->filter.interpolation_ROM = 0x1;	/* full band */
	chan->filter.envelope_amount = 0x7f;	/* none */
	chan->filter.LFO_modulation_depth = 0x00;	/* none */

	chan->loop.start = 0x000000;
	chan->loop.end = 0x000010;	/* Why ? */

	chan->modulation.envelope.current_state = 0x8000;
	chan->modulation.envelope.hold_time = 0x00;	/* 127 better ? */
	chan->modulation.envelope.attack_time = 0x00;	/* infinite */
	chan->modulation.envelope.sustain_level = 0x00;	/* off */
	chan->modulation.envelope.decay_time = 0x7f;	/* 22 msec */
	chan->modulation.LFO_state = 0x8000;

	chan->vibrato_LFO.state = 0x8000;
	chan->vibrato_LFO.modulation_depth = 0x00;	/* none */
	chan->vibrato_LFO.vibrato_depth = 0x00;
	chan->vibrato_LFO.frequency = 0x00;	/* Why set to 24 when
						 * initialized ? */

	chan->tremolo_depth = 0x00;
}

/* only call it at splaudio */
struct emuxki_channel *
emuxki_channel_new(struct emuxki_voice *voice, u_int8_t num)
{
	struct emuxki_channel *chan;

	chan = malloc(sizeof(struct emuxki_channel), M_DEVBUF,
	    M_WAITOK | M_CANFAIL);
	if (chan == NULL)
		return (NULL);

	chan->voice = voice;
	chan->num = num;
	emuxki_chanparms_set_defaults(chan);
	chan->voice->sc->channel[num] = chan;
	return (chan);
}

/* only call it at splaudio */
void
emuxki_channel_delete(struct emuxki_channel *chan)
{
	chan->voice->sc->channel[chan->num] = NULL;
	free(chan, M_DEVBUF, 0);
}

void
emuxki_channel_set_fxsend(struct emuxki_channel *chan,
			   struct emuxki_chanparms_fxsend *fxsend)
{
	/* Could do a memcpy ...*/
	chan->fxsend.a.level = fxsend->a.level;
	chan->fxsend.b.level = fxsend->b.level;
	chan->fxsend.c.level = fxsend->c.level;
	chan->fxsend.d.level = fxsend->d.level;
	chan->fxsend.a.dest = fxsend->a.dest;
	chan->fxsend.b.dest = fxsend->b.dest;
	chan->fxsend.c.dest = fxsend->c.dest;
	chan->fxsend.d.dest = fxsend->d.dest;

	/* for audigy */
	chan->fxsend.e.level = fxsend->e.level;
	chan->fxsend.f.level = fxsend->f.level;
	chan->fxsend.g.level = fxsend->g.level;
	chan->fxsend.h.level = fxsend->h.level;
	chan->fxsend.e.dest = fxsend->e.dest;
	chan->fxsend.f.dest = fxsend->f.dest;
	chan->fxsend.g.dest = fxsend->g.dest;
	chan->fxsend.h.dest = fxsend->h.dest;
}

void
emuxki_channel_set_srate(struct emuxki_channel *chan, u_int32_t srate)
{
	chan->pitch.target = (srate << 8) / 375;
	chan->pitch.target = (chan->pitch.target >> 1) +
		(chan->pitch.target & 1);
	chan->pitch.target &= 0xffff;
	chan->pitch.current = chan->pitch.target;
	chan->pitch.initial =
		(emuxki_rate_to_pitch(srate) >> 8) & EMU_CHAN_IP_MASK;
}

/* voice params must be set before calling this */
void
emuxki_channel_set_bufparms(struct emuxki_channel *chan,
			     u_int32_t start, u_int32_t end)
{
	chan->loop.start = start & EMU_CHAN_PSST_LOOPSTARTADDR_MASK;
	chan->loop.end = end & EMU_CHAN_DSL_LOOPENDADDR_MASK;
}

void
emuxki_channel_commit_fx(struct emuxki_channel *chan)
{
	struct emuxki_softc *sc = chan->voice->sc;
        u_int8_t	chano = chan->num;
        
        if (sc->sc_flags & EMUXKI_AUDIGY) {
                emuxki_write(sc, chano, EMU_A_CHAN_FXRT1,
                              (chan->fxsend.d.dest << 24) |
                              (chan->fxsend.c.dest << 16) |
                              (chan->fxsend.b.dest << 8) |
                              (chan->fxsend.a.dest));
                emuxki_write(sc, chano, EMU_A_CHAN_FXRT2,
                              (chan->fxsend.h.dest << 24) |
                              (chan->fxsend.g.dest << 16) |
                              (chan->fxsend.f.dest << 8) |
                              (chan->fxsend.e.dest));
                emuxki_write(sc, chano, EMU_A_CHAN_SENDAMOUNTS,
                              (chan->fxsend.e.level << 24) |
                              (chan->fxsend.f.level << 16) |
                              (chan->fxsend.g.level << 8) |
                              (chan->fxsend.h.level));
        } else {
                emuxki_write(sc, chano, EMU_CHAN_FXRT,
                              (chan->fxsend.d.dest << 28) |
                              (chan->fxsend.c.dest << 24) |
                              (chan->fxsend.b.dest << 20) |
                              (chan->fxsend.a.dest << 16));
        }
        
        emuxki_write(sc, chano, 0x10000000 | EMU_CHAN_PTRX,
                      (chan->fxsend.a.level << 8) | chan->fxsend.b.level);
        emuxki_write(sc, chano, EMU_CHAN_DSL,
                      (chan->fxsend.d.level << 24) | chan->loop.end);
        emuxki_write(sc, chano, EMU_CHAN_PSST,
                      (chan->fxsend.c.level << 24) | chan->loop.start);
}

void
emuxki_channel_commit_parms(struct emuxki_channel *chan)
{
	struct emuxki_voice *voice = chan->voice;
	struct emuxki_softc *sc = voice->sc;
	u_int32_t start, mapval;
	u_int8_t chano = chan->num;

	start = chan->loop.start +
		(voice->stereo ? 28 : 30) * (voice->b16 + 1);
	mapval = DMAADDR(sc->silentpage) << 1 | EMU_CHAN_MAP_PTI_MASK;

	mtx_enter(&audio_lock);
	emuxki_write(sc, chano, EMU_CHAN_CPF_STEREO, voice->stereo);

	emuxki_channel_commit_fx(chan);

	emuxki_write(sc, chano, EMU_CHAN_CCCA,
		(chan->filter.lowpass_resonance_height << 28) |
		(chan->filter.interpolation_ROM << 25) |
		(voice->b16 ? 0 : EMU_CHAN_CCCA_8BITSELECT) | start);
	emuxki_write(sc, chano, EMU_CHAN_Z1, 0);
	emuxki_write(sc, chano, EMU_CHAN_Z2, 0);
	emuxki_write(sc, chano, EMU_CHAN_MAPA, mapval);
	emuxki_write(sc, chano, EMU_CHAN_MAPB, mapval);
	emuxki_write(sc, chano, EMU_CHAN_CVCF_CURRFILTER,
		chan->filter.current_cutoff_frequency);
	emuxki_write(sc, chano, EMU_CHAN_VTFT_FILTERTARGET,
		chan->filter.target_cutoff_frequency);
	emuxki_write(sc, chano, EMU_CHAN_ATKHLDM,
		(chan->modulation.envelope.hold_time << 8) |
		chan->modulation.envelope.attack_time);
	emuxki_write(sc, chano, EMU_CHAN_DCYSUSM,
		(chan->modulation.envelope.sustain_level << 8) |
		chan->modulation.envelope.decay_time);
	emuxki_write(sc, chano, EMU_CHAN_LFOVAL1,
		chan->modulation.LFO_state);
	emuxki_write(sc, chano, EMU_CHAN_LFOVAL2,
		chan->vibrato_LFO.state);
	emuxki_write(sc, chano, EMU_CHAN_FMMOD,
		(chan->vibrato_LFO.modulation_depth << 8) |
		chan->filter.LFO_modulation_depth);
	emuxki_write(sc, chano, EMU_CHAN_TREMFRQ,
		(chan->tremolo_depth << 8));
	emuxki_write(sc, chano, EMU_CHAN_FM2FRQ2,
		(chan->vibrato_LFO.vibrato_depth << 8) |
		chan->vibrato_LFO.frequency);
	emuxki_write(sc, chano, EMU_CHAN_ENVVAL,
		chan->modulation.envelope.current_state);
	emuxki_write(sc, chano, EMU_CHAN_ATKHLDV,
		(chan->volume.envelope.hold_time << 8) |
		chan->volume.envelope.attack_time);
	emuxki_write(sc, chano, EMU_CHAN_ENVVOL,
		chan->volume.envelope.current_state);
	emuxki_write(sc, chano, EMU_CHAN_PEFE,
		(chan->pitch.envelope_amount << 8) |
		chan->filter.envelope_amount);
	mtx_leave(&audio_lock);
}

void
emuxki_channel_start(struct emuxki_channel *chan)
{
	struct emuxki_voice *voice = chan->voice;
	struct emuxki_softc *sc = voice->sc;
	u_int8_t        cache_sample, cache_invalid_size, chano = chan->num;
	u_int32_t       sample;

	cache_sample = voice->stereo ? 4 : 2;
	sample = voice->b16 ? 0x00000000 : 0x80808080;
	cache_invalid_size = (voice->stereo ? 28 : 30) * (voice->b16 + 1);

	while (cache_sample--) {
		emuxki_write(sc, chano, EMU_CHAN_CD0 + cache_sample,
			sample);
	}
	emuxki_write(sc, chano, EMU_CHAN_CCR_CACHEINVALIDSIZE, 0);
	emuxki_write(sc, chano, EMU_CHAN_CCR_READADDRESS, 64);
	emuxki_write(sc, chano, EMU_CHAN_CCR_CACHEINVALIDSIZE,
		cache_invalid_size);
	emuxki_write(sc, chano, EMU_CHAN_IFATN,
		(chan->filter.target_cutoff_frequency << 8) |
		chan->initial_attenuation);
	emuxki_write(sc, chano, EMU_CHAN_VTFT_VOLUMETARGET,
		chan->volume.target);
	emuxki_write(sc, chano, EMU_CHAN_CVCF_CURRVOL,
		chan->volume.current);
	emuxki_write(sc, 0,
		EMU_MKSUBREG(1, chano, EMU_SOLEL + (chano >> 5)),
		0);	/* Clear stop on loop */
	emuxki_write(sc, 0,
		EMU_MKSUBREG(1, chano, EMU_CLIEL + (chano >> 5)),
		0);	/* Clear loop interrupt */
	emuxki_write(sc, chano, EMU_CHAN_DCYSUSV,
		(chan->volume.envelope.sustain_level << 8) |
		chan->volume.envelope.decay_time);
	emuxki_write(sc, chano, EMU_CHAN_PTRX_PITCHTARGET,
		chan->pitch.target);
	emuxki_write(sc, chano, EMU_CHAN_CPF_PITCH,
		chan->pitch.current);
	emuxki_write(sc, chano, EMU_CHAN_IP, chan->pitch.initial);
}

void
emuxki_channel_stop(struct emuxki_channel *chan)
{
	u_int8_t chano = chan->num;
	struct emuxki_softc *sc = chan->voice->sc;

	emuxki_write(sc, chano, EMU_CHAN_PTRX_PITCHTARGET, 0);
	emuxki_write(sc, chano, EMU_CHAN_CPF_PITCH, 0);
	emuxki_write(sc, chano, EMU_CHAN_IFATN_ATTENUATION, 0xff);
	emuxki_write(sc, chano, EMU_CHAN_VTFT_VOLUMETARGET, 0);
	emuxki_write(sc, chano, EMU_CHAN_CVCF_CURRVOL, 0);
	emuxki_write(sc, chano, EMU_CHAN_IP, 0);
}

/*
 * Voices management
 * emuxki_voice_dataloc : use(play or rec) independent dataloc union helpers
 * emuxki_voice_channel_* : play part of dataloc union helpers
 * emuxki_voice_recsrc_* : rec part of dataloc union helpers
 */

/* Allocate channels for voice in case of play voice */
int
emuxki_voice_channel_create(struct emuxki_voice *voice)
{
	struct emuxki_channel **channel = voice->sc->channel;
	u_int8_t i, stereo = voice->stereo;

	for (i = 0; i < EMU_NUMCHAN; i += stereo + 1) {
		if ((stereo && (channel[i + 1] != NULL)) ||
		    (channel[i] != NULL))	/* Looking for free channels */
			continue;
		if (stereo) {
			voice->dataloc.chan[1] =
				emuxki_channel_new(voice, i + 1);
			if (voice->dataloc.chan[1] == NULL) {
				return (ENOMEM);
			}
		}
		voice->dataloc.chan[0] = emuxki_channel_new(voice, i);
		if (voice->dataloc.chan[0] == NULL) {
			if (stereo) {
				emuxki_channel_delete(voice->dataloc.chan[1]);
				voice->dataloc.chan[1] = NULL;
			}
			return (ENOMEM);
		}
		return (0);
	}
	return (EAGAIN);
}

/* When calling this function we assume no one can access the voice */
void
emuxki_voice_channel_destroy(struct emuxki_voice *voice)
{
	emuxki_channel_delete(voice->dataloc.chan[0]);
	voice->dataloc.chan[0] = NULL;
	if (voice->stereo)
		emuxki_channel_delete(voice->dataloc.chan[1]);
	voice->dataloc.chan[1] = NULL;
}

/*
 * Will come back when used in voice_dataloc_create
 */
int
emuxki_recsrc_reserve(struct emuxki_voice *voice, emuxki_recsrc_t source)
{
	if (source >= EMU_NUMRECSRCS) {
#ifdef EMUXKI_DEBUG
		printf("Tried to reserve invalid source: %d\n", source);
#endif
		return (EINVAL);
	}
	if (voice->sc->recsrc[source] == voice)
		return (0);			/* XXX */
	if (voice->sc->recsrc[source] != NULL)
		return (EBUSY);
	voice->sc->recsrc[source] = voice;
	return (0);
}

/* When calling this function we assume the voice is stopped */
void
emuxki_voice_recsrc_release(struct emuxki_softc *sc, emuxki_recsrc_t source)
{
	sc->recsrc[source] = NULL;
}

int
emuxki_voice_dataloc_create(struct emuxki_voice *voice)
{
	int             error;

	if (voice->use & EMU_VOICE_USE_PLAY) {
		if ((error = emuxki_voice_channel_create(voice)))
			return (error);
	} else {
		if ((error =
		    emuxki_recsrc_reserve(voice, voice->dataloc.source)))
			return (error);
	}
	return (0);
}

void
emuxki_voice_dataloc_destroy(struct emuxki_voice *voice)
{
	if (voice->use & EMU_VOICE_USE_PLAY) {
		if (voice->dataloc.chan[0] != NULL)
			emuxki_voice_channel_destroy(voice);
	} else {
		if (voice->dataloc.source != EMU_RECSRC_NOTSET) {
			emuxki_voice_recsrc_release(voice->sc,
						     voice->dataloc.source);
			voice->dataloc.source = EMU_RECSRC_NOTSET;
		}
	}
}

struct emuxki_voice *
emuxki_voice_new(struct emuxki_softc *sc, u_int8_t use)
{
	struct emuxki_voice *voice;

	mtx_enter(&audio_lock);
	voice = sc->lvoice;
	sc->lvoice = NULL;
	mtx_leave(&audio_lock);

	if (!voice) {
		if (!(voice = malloc(sizeof(*voice), M_DEVBUF, M_WAITOK)))
			return (NULL);
	} else if (voice->use != use) 
		emuxki_voice_dataloc_destroy(voice);
	else
		goto skip_initialize;

	voice->sc = sc;
	voice->state = !EMU_VOICE_STATE_STARTED;
	voice->stereo = EMU_VOICE_STEREO_NOTSET;
	voice->b16 = 0;
	voice->sample_rate = 0;
	if (use & EMU_VOICE_USE_PLAY)
		voice->dataloc.chan[0] = voice->dataloc.chan[1] = NULL;
	else
		voice->dataloc.source = EMU_RECSRC_NOTSET;
	voice->buffer = NULL;
	voice->blksize = 0;
	voice->trigblk = 0;
	voice->blkmod = 0;
	voice->inth = NULL;
	voice->inthparam = NULL;
	voice->use = use;

skip_initialize:
	mtx_enter(&audio_lock);
	LIST_INSERT_HEAD((&sc->voices), voice, next);
	mtx_leave(&audio_lock);

	return (voice);
}

void
emuxki_voice_delete(struct emuxki_voice *voice)
{
	struct emuxki_softc *sc = voice->sc;
	struct emuxki_voice *lvoice;

	if (voice->state & EMU_VOICE_STATE_STARTED)
		emuxki_voice_halt(voice);

	mtx_enter(&audio_lock);
	LIST_REMOVE(voice, next);
	lvoice = sc->lvoice;
	sc->lvoice = voice;
	mtx_leave(&audio_lock);

	if (lvoice) {
		emuxki_voice_dataloc_destroy(lvoice);
		free(lvoice, M_DEVBUF, 0);
	}
}

int
emuxki_voice_set_stereo(struct emuxki_voice *voice, u_int8_t stereo)
{
	int	error;
	emuxki_recsrc_t source = 0; /* XXX: gcc */
	struct emuxki_chanparms_fxsend fxsend;

	if (! (voice->use & EMU_VOICE_USE_PLAY))
		source = voice->dataloc.source;
	emuxki_voice_dataloc_destroy(voice);
	if (! (voice->use & EMU_VOICE_USE_PLAY))
		voice->dataloc.source = source;
	voice->stereo = stereo;
	if ((error = emuxki_voice_dataloc_create(voice)))
	  return (error);
	if (voice->use & EMU_VOICE_USE_PLAY) {
		fxsend.a.dest = 0x0;
		fxsend.b.dest = 0x1;
		fxsend.c.dest = 0x2;
		fxsend.d.dest = 0x3;
		/* for audigy */
		fxsend.e.dest = 0x4;
		fxsend.f.dest = 0x5;
		fxsend.g.dest = 0x6;
		fxsend.h.dest = 0x7;
		if (voice->stereo) {
			fxsend.a.level = fxsend.c.level = 0xc0;
			fxsend.b.level = fxsend.d.level = 0x00;
			fxsend.e.level = fxsend.g.level = 0xc0;
			fxsend.f.level = fxsend.h.level = 0x00;
			emuxki_channel_set_fxsend(voice->dataloc.chan[0],
						   &fxsend);
			fxsend.a.level = fxsend.c.level = 0x00;
			fxsend.b.level = fxsend.d.level = 0xc0;
			fxsend.e.level = fxsend.g.level = 0x00;
			fxsend.f.level = fxsend.h.level = 0xc0;
			emuxki_channel_set_fxsend(voice->dataloc.chan[1],
						   &fxsend);
		} /* No else : default is good for mono */	
	}
	return (0);
}

int
emuxki_voice_set_srate(struct emuxki_voice *voice, u_int32_t srate)
{
	if (voice->use & EMU_VOICE_USE_PLAY) {
		if (srate < 4000)
			srate = 4000;
		if (srate > 48000)
			srate = 48000;
		voice->sample_rate = srate;
		emuxki_channel_set_srate(voice->dataloc.chan[0], srate);
		if (voice->stereo)
			emuxki_channel_set_srate(voice->dataloc.chan[1],
						  srate);
	} else {
		if (srate < 8000)
			srate = 8000;
		if (srate > 48000)
			srate = 48000;
		voice->sample_rate = srate;
		if (emuxki_voice_adc_rate(voice) < 0) {
			voice->sample_rate = 0;
			return (EINVAL);
		}
	}
	return (0);
}

int
emuxki_voice_set_audioparms(struct emuxki_voice *voice, u_int8_t stereo,
			     u_int8_t b16, u_int32_t srate)
{
	int             error = 0;

	/*
	 * Audio driver tried to set recording AND playing params even if
	 * device opened in play or record only mode ==>
	 * modified emuxki_set_params.
	 * Stays here for now just in case ...
	 */
	if (voice == NULL) {
#ifdef EMUXKI_DEBUG
		printf("warning: tried to set unallocated voice params !!\n");
#endif
		return (0);
	}

	if (voice->stereo == stereo && voice->b16 == b16 &&
	    voice->sample_rate == srate)
		return (0);

#ifdef EMUXKI_DEBUG
	printf("Setting %s voice params : %s, %u bits, %u hz\n",
	       (voice->use & EMU_VOICE_USE_PLAY) ? "play" : "record",
	       stereo ? "stereo" : "mono", (b16 + 1) * 8, srate);
#endif
	
	voice->b16 = b16;

	/* sample rate must be set after any channel number changes */ 
	if ((voice->stereo != stereo) || (voice->sample_rate != srate)) {
		if (voice->stereo != stereo) {
			if ((error = emuxki_voice_set_stereo(voice, stereo)))
				return (error);
		}
		error = emuxki_voice_set_srate(voice, srate);
	}
	return error;
}

/* voice audio parms (see just before) must be set prior to this */
int
emuxki_voice_set_bufparms(struct emuxki_voice *voice, void *ptr,
			   u_int32_t bufsize, u_int16_t blksize)
{
	struct emuxki_mem *mem;
	struct emuxki_channel **chan;
	u_int32_t start, end;
	u_int8_t sample_size;
	int idx;
	int error = EFAULT;

	LIST_FOREACH(mem, &voice->sc->mem, next) {
		if (KERNADDR(mem->dmamem) != ptr)
			continue;

		voice->buffer = mem;
		sample_size = (voice->b16 + 1) * (voice->stereo + 1);
		voice->trigblk = 0;	/* This shouldn't be needed */
		voice->blkmod = bufsize / blksize;
		if (bufsize % blksize) 	  /* This should not happen */
			voice->blkmod++;
		error = 0;

		if (voice->use & EMU_VOICE_USE_PLAY) {
			voice->blksize = blksize / sample_size;
			chan = voice->dataloc.chan;
			start = (mem->ptbidx << 12) / sample_size;
			end = start + bufsize / sample_size;
			emuxki_channel_set_bufparms(chan[0],
						     start, end);
			if (voice->stereo)
				emuxki_channel_set_bufparms(chan[1],
				     start, end);
			voice->timerate = (u_int32_t) 48000 *
			                voice->blksize / voice->sample_rate;
			if (voice->timerate < 5)
				error = EINVAL;
		} else {
			voice->blksize = blksize;
			for(idx = sizeof(emuxki_recbuf_sz) /
			    sizeof(emuxki_recbuf_sz[0]); --idx >= 0;)
				if (emuxki_recbuf_sz[idx] == bufsize)
					break;
			if (idx < 0) {
#ifdef EMUXKI_DEBUG
				printf("Invalid bufsize: %d\n", bufsize);
#endif
				return (EINVAL);
			}
			mtx_enter(&audio_lock);
			emuxki_write(voice->sc, 0,
			    emuxki_recsrc_szreg[voice->dataloc.source], idx);
			emuxki_write(voice->sc, 0,
			    emuxki_recsrc_bufaddrreg[voice->dataloc.source],
			    DMAADDR(mem->dmamem));
			mtx_leave(&audio_lock);
			/* Use timer to emulate DMA completion interrupt */
			voice->timerate = (u_int32_t) 48000 * blksize /
			    (voice->sample_rate * sample_size);
			if (voice->timerate < 5) {
#ifdef EMUXKI_DEBUG
				printf("Invalid timerate: %d, blksize %d\n",
				    voice->timerate, blksize);
#endif
				error = EINVAL;
			}
		}

		break;
	}

	return (error);
}

void
emuxki_voice_commit_parms(struct emuxki_voice *voice)
{
	if (voice->use & EMU_VOICE_USE_PLAY) {
		emuxki_channel_commit_parms(voice->dataloc.chan[0]);
		if (voice->stereo)
			emuxki_channel_commit_parms(voice->dataloc.chan[1]);
	}
}

u_int32_t
emuxki_voice_curaddr(struct emuxki_voice *voice)
{
	int idxreg = 0;

	/* XXX different semantics in these cases */
	if (voice->use & EMU_VOICE_USE_PLAY) {
		/* returns number of samples (an l/r pair counts 1) */
		return (emuxki_read(voice->sc,
				     voice->dataloc.chan[0]->num,
				     EMU_CHAN_CCCA_CURRADDR) -
			voice->dataloc.chan[0]->loop.start);
	} else {
		/* returns number of bytes */
		switch (voice->dataloc.source) {
			case EMU_RECSRC_MIC:
				idxreg = (voice->sc->sc_flags & EMUXKI_AUDIGY) ?
					EMU_A_MICIDX : EMU_MICIDX;
				break;
			case EMU_RECSRC_ADC:
				idxreg = (voice->sc->sc_flags & EMUXKI_AUDIGY) ?
					EMU_A_ADCIDX : EMU_ADCIDX;
				break;
			case EMU_RECSRC_FX:
				idxreg = EMU_FXIDX;
				break;
			default:
#ifdef EMUXKI_DEBUG
				printf("emu: bad recording source!\n");
#endif
				break;
		}
		return (emuxki_read(voice->sc, 0, EMU_RECIDX(idxreg))
				& EMU_RECIDX_MASK);
	}
	return (0);
}

void
emuxki_resched_timer(struct emuxki_softc *sc)
{
	struct emuxki_voice *voice;
	u_int16_t       timerate = 1024;
	u_int8_t	active = 0;

	LIST_FOREACH(voice, &sc->voices, next) {
		if ((voice->state & EMU_VOICE_STATE_STARTED) == 0)
			continue;
		active = 1;
		if (voice->timerate < timerate)
			timerate = voice->timerate;
	}

	if (timerate & ~EMU_TIMER_RATE_MASK)
		timerate = 0;
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, EMU_TIMER, timerate);
	if (!active && (sc->timerstate & EMU_TIMER_STATE_ENABLED)) {
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_INTE,
			bus_space_read_4(sc->sc_iot, sc->sc_ioh, EMU_INTE) &
			~EMU_INTE_INTERTIMERENB);
		sc->timerstate &= ~EMU_TIMER_STATE_ENABLED;
	} else if (active && !(sc->timerstate & EMU_TIMER_STATE_ENABLED)) {
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_INTE,
			bus_space_read_4(sc->sc_iot, sc->sc_ioh, EMU_INTE) |
			EMU_INTE_INTERTIMERENB);
		sc->timerstate |= EMU_TIMER_STATE_ENABLED;
	}
}

int
emuxki_voice_adc_rate(struct emuxki_voice *voice)
{
	switch(voice->sample_rate) {
		case 48000:
			return EMU_ADCCR_SAMPLERATE_48;
			break;
		case 44100:
			return EMU_ADCCR_SAMPLERATE_44;
			break;
		case 32000:
			return EMU_ADCCR_SAMPLERATE_32;
			break;
		case 24000:
			return EMU_ADCCR_SAMPLERATE_24;
			break;
		case 22050:
			return EMU_ADCCR_SAMPLERATE_22;
			break;
		case 16000:
			return EMU_ADCCR_SAMPLERATE_16;
			break;
		case 12000:
			if (voice->sc->sc_flags & EMUXKI_AUDIGY)
				return EMU_A_ADCCR_SAMPLERATE_12;
			else {
#ifdef EMUXKI_DEBUG
				printf("recording sample_rate not supported : %u\n", voice->sample_rate);
#endif
				return (-1);
			}
			break;
		case 11000:
			if (voice->sc->sc_flags & EMUXKI_AUDIGY)
				return EMU_A_ADCCR_SAMPLERATE_11;
			else
				return EMU_ADCCR_SAMPLERATE_11;
			break;
		case 8000:
			if (voice->sc->sc_flags & EMUXKI_AUDIGY)
				return EMU_A_ADCCR_SAMPLERATE_8;
			else
				return EMU_ADCCR_SAMPLERATE_8;
			break;
		default:
#ifdef EMUXKI_DEBUG
				printf("recording sample_rate not supported : %u\n", voice->sample_rate);
#endif
				return (-1);
	}
	return (-1);  /* shouldn't get here */
}

void
emuxki_voice_start(struct emuxki_voice *voice,
		    void (*inth) (void *), void *inthparam)
{
	u_int32_t val;

	mtx_enter(&audio_lock);
	voice->inth = inth;
	voice->inthparam = inthparam;
	if (voice->use & EMU_VOICE_USE_PLAY) {
		voice->trigblk = 1;
		emuxki_channel_start(voice->dataloc.chan[0]);
		if (voice->stereo)
			emuxki_channel_start(voice->dataloc.chan[1]);
	} else {
		voice->trigblk = 1;
		switch (voice->dataloc.source) {
		case EMU_RECSRC_ADC:
			/* XXX need to program DSP to output L+R
			 * XXX in monaural case? */
			if (voice->sc->sc_flags & EMUXKI_AUDIGY) {
				val = EMU_A_ADCCR_LCHANENABLE;
				if (voice->stereo)
					val |= EMU_A_ADCCR_RCHANENABLE;
			} else {
				val = EMU_ADCCR_LCHANENABLE;
				if (voice->stereo)
					val |= EMU_ADCCR_RCHANENABLE;
			}
			val |= emuxki_voice_adc_rate(voice);
			emuxki_write(voice->sc, 0, EMU_ADCCR, 0);
			emuxki_write(voice->sc, 0, EMU_ADCCR, val);
			break;
		case EMU_RECSRC_MIC:
		case EMU_RECSRC_FX:
			printf("unimplemented\n");
			break;
		case EMU_RECSRC_NOTSET:
		default:
			break;
		}
#if 0
		/* DMA completion interrupt is useless; use timer */
		val = emu_rd(sc, INTE, 4);
		val |= emuxki_recsrc_intrmasks[voice->dataloc.source];
		emu_wr(sc, INTE, val, 4);
#endif
	}
	voice->state |= EMU_VOICE_STATE_STARTED;
	emuxki_resched_timer(voice->sc);
	mtx_leave(&audio_lock);
}

void
emuxki_voice_halt(struct emuxki_voice *voice)
{
	mtx_enter(&audio_lock);
	if (voice->use & EMU_VOICE_USE_PLAY) {
		emuxki_channel_stop(voice->dataloc.chan[0]);
		if (voice->stereo)
			emuxki_channel_stop(voice->dataloc.chan[1]);
	} else {
		switch (voice->dataloc.source) {
		case EMU_RECSRC_ADC:
			emuxki_write(voice->sc, 0, EMU_ADCCR, 0);
			break;
		case EMU_RECSRC_FX:
		case EMU_RECSRC_MIC:
			printf("unimplemented\n");
			break;
		case EMU_RECSRC_NOTSET:
			printf("Bad dataloc.source\n");
		}
		/* This should reset buffer pointer */
		emuxki_write(voice->sc, 0,
		    emuxki_recsrc_szreg[voice->dataloc.source],
		    EMU_RECBS_BUFSIZE_NONE);
#if 0
		val = emu_rd(sc, INTE, 4);
		val &= ~emuxki_recsrc_intrmasks[voice->dataloc.source];
		emu_wr(sc, INTE, val, 4);
#endif
	}
	voice->state &= ~EMU_VOICE_STATE_STARTED;
	emuxki_resched_timer(voice->sc);
	mtx_leave(&audio_lock);
}

/*
 * The interrupt handler
 */
int
emuxki_intr(void *arg)
{
	struct emuxki_softc *sc = arg;
	u_int32_t       ipr, curblk, us = 0;
	struct emuxki_voice *voice;

	mtx_enter(&audio_lock);
	while ((ipr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, EMU_IPR))) {
		if (ipr & EMU_IPR_INTERVALTIMER) {
			LIST_FOREACH(voice, &sc->voices, next) {
				if ((voice->state &
				      EMU_VOICE_STATE_STARTED) == 0)
					continue;

				curblk = emuxki_voice_curaddr(voice) /
				       voice->blksize;
#if 0
				if (curblk == voice->trigblk) {
					voice->inth(voice->inthparam);
					voice->trigblk++;
					voice->trigblk %= voice->blkmod;
				}
#else
				while ((curblk >= voice->trigblk &&
				    curblk < (voice->trigblk + voice->blkmod / 2)) ||
				    ((int)voice->trigblk - (int)curblk) >
				    (voice->blkmod / 2 + 1)) {
					voice->inth(voice->inthparam);
					voice->trigblk++;
					voice->trigblk %= voice->blkmod;
				}
#endif
			}
			us = 1;
		}

		/* Got interrupt */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_IPR, ipr);
	}
	mtx_leave(&audio_lock);
	return (us);
}


/*
 * Audio Architecture callbacks
 */

int
emuxki_open(void *addr, int flags)
{
	struct emuxki_softc *sc = addr;

#ifdef EMUXKI_DEBUG
	printf("%s: emuxki_open called\n", sc->sc_dev.dv_xname);
#endif

	/*
	 * Multiple voice support would be added as soon as I find a way to
	 * trick the audio arch into supporting multiple voices.
	 * Or I might integrate a modified audio arch supporting
	 * multiple voices.
	 */

	/*
	 * I did this because i have problems identifying the selected
	 * recording source(s) which is necessary when setting recording
	 * params. This will be addressed very soon.
	 */
	if (flags & FREAD) {
		sc->rvoice = emuxki_voice_new(sc, 0 /* EMU_VOICE_USE_RECORD */);
		if (sc->rvoice == NULL)
			return (EBUSY);

		/* XXX Hardcode RECSRC_ADC for now */
		sc->rvoice->dataloc.source = EMU_RECSRC_ADC;
	}

	if (flags & FWRITE) {
		sc->pvoice = emuxki_voice_new(sc, EMU_VOICE_USE_PLAY);
		if (sc->pvoice == NULL) {
			if (flags & FREAD)
				emuxki_voice_delete(sc->rvoice);
			return (EBUSY);
		}
	}

	return (0);
}

void
emuxki_close(void *addr)
{
	struct emuxki_softc *sc = addr;

#ifdef EMUXKI_DEBUG
	printf("%s: emu10K1_close called\n", sc->sc_dev.dv_xname);
#endif

	/* No multiple voice support for now */
	if (sc->rvoice != NULL)
		emuxki_voice_delete(sc->rvoice);
	sc->rvoice = NULL;
	if (sc->pvoice != NULL)
		emuxki_voice_delete(sc->pvoice);
	sc->pvoice = NULL;
}

int
emuxki_set_vparms(struct emuxki_voice *voice, struct audio_params *p)
{
	u_int8_t	b16, mode;

	mode = (voice->use & EMU_VOICE_USE_PLAY) ?
		AUMODE_PLAY : AUMODE_RECORD;
	if (p->channels > 2)
		p->channels = 2;
	if (p->precision > 16)
		p->precision = 16;
	/* Will change when streams come in use */

	/*
	 * Always use slinear_le for recording, as how to set otherwise
	 * isn't known.
	 */
	if (mode == AUMODE_PLAY)
		b16 = (p->precision == 16);
	else {
		b16 = 1;
		p->precision = 16;
	}

	switch (p->encoding) {
	case AUDIO_ENCODING_SLINEAR_LE:
		if (p->precision != 16)
			return EINVAL;
		break;

	case AUDIO_ENCODING_ULINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_BE:
		if (p->precision != 8)
			return EINVAL;
		break;

	default:
		return (EINVAL);
	}
	p->bps = AUDIO_BPS(p->precision);
	p->msb = 1;

	return (emuxki_voice_set_audioparms(voice, p->channels == 2,
				     b16, p->sample_rate));
}

int
emuxki_set_params(void *addr, int setmode, int usemode,
		   struct audio_params *play, struct audio_params *rec)
{
	struct emuxki_softc *sc = addr;
	int	     mode, error;
	struct audio_params *p;

	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((usemode & setmode & mode) == 0)
			continue;

		p = (mode == AUMODE_PLAY) ? play : rec;

		/* No multiple voice support for now */
		if ((error = emuxki_set_vparms((mode == AUMODE_PLAY) ?
						sc->pvoice : sc->rvoice, p)))
			return (error);
	}

	return (0);
}

int
emuxki_halt_output(void *addr)
{
	struct emuxki_softc *sc = addr;

	/* No multiple voice support for now */
	if (sc->pvoice == NULL)
		return (ENXIO);

	emuxki_voice_halt(sc->pvoice);
	return (0);
}

int
emuxki_halt_input(void *addr)
{
	struct emuxki_softc *sc = addr;

#ifdef EMUXKI_DEBUG
	printf("%s: emuxki_halt_input called\n", sc->sc_dev.dv_xname);
#endif

	/* No multiple voice support for now */
	if (sc->rvoice == NULL)
		return (ENXIO);
	emuxki_voice_halt(sc->rvoice);
	return (0);
}

int
emuxki_set_port(void *addr, mixer_ctrl_t *mctl)
{
	struct emuxki_softc *sc = addr;

	return sc->codecif->vtbl->mixer_set_port(sc->codecif, mctl);
}

int
emuxki_get_port(void *addr, mixer_ctrl_t *mctl)
{
	struct emuxki_softc *sc = addr;

	return sc->codecif->vtbl->mixer_get_port(sc->codecif, mctl);
}

int
emuxki_query_devinfo(void *addr, mixer_devinfo_t *minfo)
{
	struct emuxki_softc *sc = addr;

	return sc->codecif->vtbl->query_devinfo(sc->codecif, minfo);
}

void *
emuxki_allocm(void *addr, int direction, size_t size, int type, int flags)
{
	struct emuxki_softc *sc = addr;

	if (direction == AUMODE_PLAY)
		return emuxki_pmem_alloc(sc, size, type, flags);
	else
		return emuxki_rmem_alloc(sc, size, type, flags);
}

void
emuxki_freem(void *addr, void *ptr, int type)
{
	struct emuxki_softc *sc = addr;
	int	     i;
	struct emuxki_mem *mem;
	size_t	  numblocks;
	u_int32_t      *ptb, silentpage;

	ptb = KERNADDR(sc->ptb);
	silentpage = DMAADDR(sc->silentpage) << 1;
	LIST_FOREACH(mem, &sc->mem, next) {
		if (KERNADDR(mem->dmamem) != ptr)
			continue;

		mtx_enter(&audio_lock);
		if (mem->ptbidx != EMU_RMEM) {
			numblocks = DMASIZE(mem->dmamem) / EMU_PTESIZE;
			if (DMASIZE(mem->dmamem) % EMU_PTESIZE)
				numblocks++;
			for (i = 0; i < numblocks; i++)
				ptb[mem->ptbidx + i] =
				    htole32(silentpage | (mem->ptbidx + i));
		}
		LIST_REMOVE(mem, next);
		mtx_leave(&audio_lock);

		emuxki_mem_delete(mem, type);
		break;
	}
}

/* blocksize should be a divisor of allowable buffersize */
/* XXX probably this could be done better */
int
emuxki_round_blocksize(void *addr, int blksize)
{
	int bufsize = 65536;

	while (bufsize > blksize)
		bufsize /= 2;

	return bufsize;
}
	
size_t
emuxki_round_buffersize(void *addr, int direction, size_t bsize)
{

	if (direction == AUMODE_PLAY) {
		if (bsize < EMU_PTESIZE)
			bsize = EMU_PTESIZE;
		else if (bsize > (EMU_PTESIZE * EMU_MAXPTE))
			bsize = EMU_PTESIZE * EMU_MAXPTE;
		/* Would be better if set to max available */
		else if (bsize % EMU_PTESIZE)
			bsize = bsize -
				(bsize % EMU_PTESIZE) +
				EMU_PTESIZE;
	} else {
		int idx;

		/* find nearest lower recbuf size */
		for(idx = sizeof(emuxki_recbuf_sz) /
		    sizeof(emuxki_recbuf_sz[0]); --idx >= 0; ) {
			if (bsize >= emuxki_recbuf_sz[idx]) {
				bsize = emuxki_recbuf_sz[idx];
				break;
			}
		}

		if (bsize == 0)
			bsize = 384;
	}

	return (bsize);
}

int
emuxki_get_props(void *addr)
{
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT |
		AUDIO_PROP_FULLDUPLEX);
}

int
emuxki_trigger_output(void *addr, void *start, void *end, int blksize,
		       void (*inth) (void *), void *inthparam,
		       struct audio_params *params)
{
	struct emuxki_softc *sc = addr;
	/* No multiple voice support for now */
	struct emuxki_voice *voice = sc->pvoice;
	int	     error;

	if (voice == NULL)
		return (ENXIO);
	if ((error = emuxki_set_vparms(voice, params)))
		return (error);
	if ((error = emuxki_voice_set_bufparms(voice, start,
				(caddr_t)end - (caddr_t)start, blksize)))
		return (error);
	emuxki_voice_commit_parms(voice);
	emuxki_voice_start(voice, inth, inthparam);
	return (0);
}

int
emuxki_trigger_input(void *addr, void *start, void *end, int blksize,
		      void (*inth) (void *), void *inthparam,
		      struct audio_params *params)
{
	struct emuxki_softc *sc = addr;
	/* No multiple voice support for now */
	struct emuxki_voice *voice = sc->rvoice;
	int	error;

	if (voice == NULL)
		return (ENXIO);
	if ((error = emuxki_set_vparms(voice, params)))
		return (error);
	if ((error = emuxki_voice_set_bufparms(voice, start,
						(caddr_t)end - (caddr_t)start,
						blksize)))
		return (error);
	emuxki_voice_start(voice, inth, inthparam);
	return (0);
}


/*
 * AC97 callbacks
 */

int
emuxki_ac97_attach(void *arg, struct ac97_codec_if *codecif)
{
	struct emuxki_softc *sc = arg;

	sc->codecif = codecif;
	return (0);
}

int
emuxki_ac97_read(void *arg, u_int8_t reg, u_int16_t *val)
{
	struct emuxki_softc *sc = arg;

	mtx_enter(&audio_lock);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, EMU_AC97ADDR, reg);
	*val = bus_space_read_2(sc->sc_iot, sc->sc_ioh, EMU_AC97DATA);
	mtx_leave(&audio_lock);

	return (0);
}

int
emuxki_ac97_write(void *arg, u_int8_t reg, u_int16_t val)
{
	struct emuxki_softc *sc = arg;

	mtx_enter(&audio_lock);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, EMU_AC97ADDR, reg);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, EMU_AC97DATA, val);
	mtx_leave(&audio_lock);

	return (0);
}

void
emuxki_ac97_reset(void *arg)
{
}
@


1.50
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.48 2015/05/11 06:46:22 ratchov Exp $	*/
a174 1
int	emuxki_getdev(void *, struct audio_device *);
a227 1
	emuxki_getdev,
a460 3
			strlcpy(sc->sc_audv.name, "Audigy2", sizeof sc->sc_audv.name);
		} else {
			strlcpy(sc->sc_audv.name, "Audigy", sizeof sc->sc_audv.name);
d467 1
a467 3
			strlcpy(sc->sc_audv.name, "Audigy2Value", sizeof sc->sc_audv.name);
		} else
			strlcpy(sc->sc_audv.name, "Audigy2", sizeof sc->sc_audv.name);
a470 1
		strlcpy(sc->sc_audv.name, "E-mu APS", sizeof sc->sc_audv.name);
a472 1
		strlcpy(sc->sc_audv.name, "SB Live!", sizeof sc->sc_audv.name);
a473 3
	snprintf(sc->sc_audv.version, sizeof sc->sc_audv.version, "0x%02x",
		 PCI_REVISION(pa->pa_class));
	strlcpy(sc->sc_audv.config, "emuxki", sizeof sc->sc_audv.config);
a2157 8
}

int
emuxki_getdev(void *v, struct audio_device *adp)
{
	struct emuxki_softc *sc = v;
	*adp = sc->sc_audv;
	return 0;
@


1.49
log
@Don't inline long functions as this tends to increase object size
with no benefit.

ok millert, "correct" deraadt
@
text
@a160 1
int	emuxki_query_encoding(void *, struct audio_encoding *);
a163 1
void	emuxki_get_default_params(void *, int, struct audio_params *);
a182 1
paddr_t	emuxki_mappage(void *, void *, off_t, int);
a218 2
	NULL,			/* drain */
	emuxki_query_encoding,
a236 1
	emuxki_mappage,
d239 1
a239 2
	emuxki_trigger_input,
	emuxki_get_default_params
a2073 31
emuxki_query_encoding(void *addr, struct audio_encoding *fp)
{
#ifdef EMUXKI_DEBUG
	struct emuxki_softc *sc = addr;

	printf("%s: emuxki_query_encoding called\n", sc->sc_dev.dv_xname);
#endif

	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

int
a2142 6
void
emuxki_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
}

a2290 18
}

paddr_t
emuxki_mappage(void *addr, void *ptr, off_t off, int prot)
{
	struct emuxki_softc *sc = addr;
	struct emuxki_mem *mem;

	LIST_FOREACH(mem, &sc->mem, next) {
		if (KERNADDR(mem->dmamem) == ptr) {
			struct dmamem *dm = mem->dmamem;

			return bus_dmamem_mmap(dm->dmat, dm->segs, dm->nsegs,
			       off, prot, BUS_DMA_WAITOK);
		}
	}

	return (-1);
@


1.48
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.47 2015/03/14 03:38:48 jsg Exp $	*/
d546 1
a546 1
static __inline u_int32_t
d608 1
a608 1
static __inline u_int32_t
d630 1
a630 1
static __inline void
@


1.47
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.46 2014/07/13 23:10:23 deraadt Exp $	*/
a65 2
#include <dev/auconv.h>
#include <dev/mulaw.h>
a70 2
#define slinear16_to_ulinear8_le linear16_to_ulinear8_le;

a2096 18
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
a2101 18
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a2117 2
	p->factor = 1;
	p->sw_code = NULL;
d2132 1
a2132 2
		if (p->precision == 8)
			p->factor *= 2;
a2135 18
	case AUDIO_ENCODING_ULAW:
		if (mode == AUMODE_PLAY) {
			p->factor = 2;
			p->sw_code = mulaw_to_slinear16_le;
			b16 = 1;
		} else
			p->sw_code = slinear16_to_mulaw_le;
		break;

	case AUDIO_ENCODING_ALAW:
		if (mode == AUMODE_PLAY) {
			p->factor = 2;
			p->sw_code = alaw_to_slinear16_le;
			b16 = 1;
		} else
			p->sw_code = slinear16_to_alaw_le;
		break;

d2137 2
a2138 6
		if (p->precision == 8) {
			if (mode == AUMODE_PLAY)
				p->sw_code = change_sign8;
			else
				p->sw_code = linear16_to_linear8_le;
		}
a2141 17
		if (p->precision == 16)
			p->sw_code = change_sign16_le;
		else if (mode == AUMODE_RECORD)
			p->sw_code = slinear16_to_ulinear8_le;
		break;

	case AUDIO_ENCODING_SLINEAR_BE:
		if (p->precision == 16)
			p->sw_code = swap_bytes;
		else {
			if (mode == AUMODE_PLAY)
				p->sw_code = change_sign8;
			else
				p->sw_code = linear16_to_linear8_le;
		}
		break;

d2143 2
a2144 7
		if (p->precision == 16) {
			if (mode == AUMODE_PLAY)
				p->sw_code = swap_bytes_change_sign16_le;
			else
				p->sw_code = change_sign16_swap_bytes_le;
		} else if (mode == AUMODE_RECORD)
			p->sw_code = slinear16_to_ulinear8_le;
@


1.46
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.45 2014/07/12 18:48:51 tedu Exp $	*/
a59 1
#include <sys/selinfo.h>
@


1.45
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.44 2013/12/06 21:03:03 deraadt Exp $	*/
d296 1
a296 1
	mem->segs = malloc(mem->nsegs * sizeof(*(mem->segs)), type, flags);
@


1.44
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.43 2013/06/23 21:23:45 brad Exp $	*/
d276 2
a277 2
	free(mem->segs, type);
	free(mem, type);
d298 1
a298 1
		free(mem, type);
d1027 1
a1027 1
		free(mem, type);
d1037 1
a1037 1
	free(mem, type);
d1191 1
a1191 1
	free(chan, M_DEVBUF);
d1562 1
a1562 1
		free(lvoice, M_DEVBUF);
@


1.43
log
@Remove unsigned comparison < 0.

Pointed out by LLVM.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.42 2013/05/24 07:58:46 ratchov Exp $	*/
a536 5
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		break;
d542 2
a543 1
 	case DVACT_DEACTIVATE:
@


1.42
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.41 2013/05/15 08:29:24 ratchov Exp $	*/
d1454 1
a1454 1
	if (source < 0 || source >= EMU_NUMRECSRCS) {
@


1.41
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.40 2011/07/03 15:47:17 matthew Exp $	*/
d457 2
a458 2
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, emuxki_intr,
		sc, sc->sc_dev.dv_xname);
@


1.40
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.39 2011/06/17 07:06:47 mk Exp $	*/
a621 1
	int             s;
a632 1
	s = splaudio();
a635 2
	splx(s);

a644 1
	int             s;
a662 1
	s = splaudio();
a664 1
	splx(s);
d1047 1
a1047 1
	int             i, j, s;
a1060 1
			s = splaudio();
a1068 1
					splx(s);
d1075 1
d1077 1
a1077 1
				splx(s);
a1080 1
			splx(s);
a1088 1
	int             s;
d1094 1
a1094 1
	s = splaudio();
d1096 1
a1096 1
	splx(s);
a1288 1
	int s;
d1294 1
a1294 1
	s = splaudio();
d1339 1
a1339 1
	splx(s);
a1348 1
	int             s;
a1353 1
	s = splaudio();
a1382 2

	splx(s);
a1387 1
	int s;
a1390 1
	s = splaudio();
a1396 1
	splx(s);
a1411 1
	int s;
a1416 1
		s = splaudio();
a1420 1
				splx(s);
a1429 1
			splx(s);
a1431 1
		splx(s);
a1509 1
	int             s;
d1511 1
a1511 1
	s = splaudio();
d1514 1
a1514 1
	splx(s);
d1542 1
a1542 1
	s = splaudio();
d1544 1
a1544 1
	splx(s);
a1553 1
	int s;
d1558 1
a1558 1
	s = splaudio();
d1562 1
a1562 1
	splx(s);
d1732 1
d1738 1
a1738 1

a1810 1
	int s;
a1811 1
	s = splaudio();
a1833 1
	splx(s);
d1895 1
a1931 2
		int s;
		s = splaudio();
a1934 1
		splx(s);
d1939 1
d1945 1
a1966 2
		int s;
		s = splaudio();
a1969 1
		splx(s);
d1974 1
d1987 1
d2020 1
a2020 1

d2355 1
a2355 1
	int	     i, s;
d2366 1
a2366 1
		s = splaudio();
d2376 1
a2376 1
		splx(s);
a2472 1

a2494 1

a2515 1
	int s;
d2517 1
a2517 1
	s = splaudio();
d2520 1
a2520 1
	splx(s);
a2528 1
	int s;
d2530 1
a2530 1
	s = splaudio();
d2533 1
a2533 1
	splx(s);
@


1.39
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.38 2011/04/03 15:36:02 jasper Exp $	*/
a536 2
 	case DVACT_ACTIVATE:
		break;
@


1.38
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.37 2010/09/12 03:17:34 jakemsr Exp $	*/
d1190 2
a1191 1
	chan = malloc(sizeof(struct emuxki_channel), M_DEVBUF, M_WAITOK);
@


1.37
log
@silly me.  use the switch() variable, not the case value.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.36 2010/09/12 02:10:52 jakemsr Exp $	*/
d430 1
a430 1
	    sizeof(emuxki_devices)/sizeof(emuxki_devices[0])));
@


1.36
log
@autoconf activate suspend/resume for emu(4).  uses audio(4)
DVACT_{QUIESCE,RESUME}.  not 100% right yet.  after resume, interrupts,
DMA, and the mixer appear to be working, but no sound is produced.
cookie for whoever finds the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.35 2010/09/10 04:52:05 jakemsr Exp $	*/
d540 1
a540 1
		rv = config_activate_children(self, DVACT_QUIESCE);
d547 1
a547 1
		rv = config_activate_children(self, DVACT_RESUME);
@


1.35
log
@the open() functions give us flags like FREAD and FWRITE from sys/fcntl.h.
the AUOPEN_ macros from sys/dev/audiovar.h are for something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.34 2010/07/15 03:43:11 jakemsr Exp $	*/
d80 2
a81 1
int  emuxki_scinit(struct emuxki_softc *sc);
d95 1
a95 1
int  emuxki_init(struct emuxki_softc *);
d221 1
a221 1
	NULL		  /* config activate */
d362 1
a362 1
emuxki_scinit(struct emuxki_softc *sc)
d374 1
a374 1
	if ((err = emuxki_init(sc)))
d406 4
a409 2
	/* No multiple voice support for now */
	sc->pvoice = sc->rvoice = NULL;
d499 1
a499 1
	if (emuxki_scinit(sc) ||
d530 24
d809 1
a809 1
emuxki_init(struct emuxki_softc *sc)
d914 19
a932 17
	/* Here is our Page Table */
	if ((sc->ptb = emuxki_dmamem_alloc(sc->sc_dmat,
	    EMU_MAXPTE * sizeof(u_int32_t),
	    EMU_DMA_ALIGN, EMU_DMAMEM_NSEG,
	    M_DEVBUF, M_WAITOK)) == NULL)
		return (ENOMEM);

	/* This is necessary unless you like Metallic noise... */
	if ((sc->silentpage = emuxki_dmamem_alloc(sc->sc_dmat, EMU_PTESIZE,
	    EMU_DMA_ALIGN, EMU_DMAMEM_NSEG, M_DEVBUF, M_WAITOK))==NULL){
		emuxki_dmamem_free(sc->ptb, M_DEVBUF);
		return (ENOMEM);
	}

	/* Zero out the silent page */
	/* This might not be always true, it might be 128 for 8bit channels */
	memset(KERNADDR(sc->silentpage), 0, DMASIZE(sc->silentpage));
d960 4
a963 2
	/* Init voices list */
	LIST_INIT(&(sc->voices));
@


1.34
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.33 2009/03/29 21:53:52 sthen Exp $	*/
d55 1
a66 1
#include <dev/audiovar.h>
d2048 1
a2048 1
	if (flags & AUOPEN_READ) {
d2057 1
a2057 1
	if (flags & AUOPEN_WRITE) {
d2060 1
a2060 1
			if (flags & AUOPEN_READ)
@


1.33
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.32 2008/12/09 12:30:12 brad Exp $	*/
d2148 3
d2240 2
@


1.32
log
@Replace the sc_type/sc_details enum's in the softc struct with a sc_flags
flags field and use the flags as appropriate.

ok jakemsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.31 2008/10/29 22:37:29 jakemsr Exp $	*/
d440 1
a440 1
		printf(": can't map iospace\n");
d448 1
a448 1
		printf(": couldn't map interrupt\n");
d457 1
a457 1
		printf(": couldn't establish interrupt");
@


1.31
log
@
support for Audigy 2 Value based on patch from Dennis Suhonin
(openlunatic at gmail).

tested by Dawe (dawedawe at gmx de), thanks, and me.  does not disturb
currenlty working emu(4) devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.30 2008/10/25 22:30:43 jakemsr Exp $	*/
d367 1
a367 1
		(sc->sc_type == EMUXKI_APS? 0 : EMU_HCFG_GPOUTPUT0) |
d376 1
a376 1
	if (sc->sc_type & EMUXKI_AUDIGY2) {
d380 1
a380 1
	} else if (sc->sc_type & EMUXKI_AUDIGY) {
d393 2
a394 2
	if (sc->sc_type & EMUXKI_AUDIGY2) {
		if (sc->sc_details & EMUXKI_CA0108_CHIP) {
a465 1
	sc->sc_details = 0;
d468 1
a468 1
		sc->sc_type = EMUXKI_AUDIGY;
d471 1
a471 1
			sc->sc_type |= EMUXKI_AUDIGY2;
d477 1
a477 1
		sc->sc_type = EMUXKI_AUDIGY | EMUXKI_AUDIGY2;
d480 1
a480 1
			sc->sc_details = EMUXKI_CA0108_CHIP;
d482 1
a482 1
		} else {
a483 1
		}
d486 1
a486 1
		sc->sc_type = EMUXKI_APS;
d489 1
a489 1
		sc->sc_type = EMUXKI_SBLIVE;
d498 1
a498 1
	    (sc->sc_type == EMUXKI_APS || emuxki_ac97_init(sc)) ||
d600 1
a600 1
		(sc->sc_type & EMUXKI_AUDIGY ?
d627 1
a627 1
		(sc->sc_type & EMUXKI_AUDIGY ?
d655 1
a655 1
		(sc->sc_type & EMUXKI_AUDIGY ?
d664 1
a664 1
	if (sc->sc_type & EMUXKI_AUDIGY) {
d700 1
a700 1
	if (sc->sc_type & EMUXKI_AUDIGY) {
d802 1
a802 1
        if(sc->sc_type & EMUXKI_AUDIGY) {
d849 1
a849 1
	if (sc->sc_details & EMUXKI_CA0108_CHIP) {
d872 1
a872 1
	} else if(sc->sc_type & EMUXKI_AUDIGY2) {
d974 5
a978 6
        if(sc->sc_type & EMUXKI_AUDIGY) {
                emuxki_write(sc, 0, EMU_A_FXWC1, 0);
                emuxki_write(sc, 0, EMU_A_FXWC2, 0);
        } else {
                emuxki_write(sc, 0, EMU_FXWC, 0);
        }
d1099 1
a1099 1
		chan->voice->sc->sc_type & EMUXKI_AUDIGY ?
d1230 1
a1230 1
        if(sc->sc_type & EMUXKI_AUDIGY) {
d1777 1
a1777 1
				idxreg = (voice->sc->sc_type & EMUXKI_AUDIGY) ?
d1781 1
a1781 1
				idxreg = (voice->sc->sc_type & EMUXKI_AUDIGY) ?
d1856 1
a1856 1
			if(voice->sc->sc_type & EMUXKI_AUDIGY)
d1866 1
a1866 1
			if(voice->sc->sc_type & EMUXKI_AUDIGY)
d1872 1
a1872 1
			if(voice->sc->sc_type & EMUXKI_AUDIGY)
d1905 1
a1905 1
			if (voice->sc->sc_type & EMUXKI_AUDIGY) {
@


1.30
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.29 2008/06/26 05:42:17 ray Exp $	*/
d394 9
a402 3
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_A_IOCFG,
			EMU_A_IOCFG_GPOUT0 |
			bus_space_read_4(sc->sc_iot, sc->sc_ioh, EMU_A_IOCFG));
d466 1
d477 9
d851 24
a874 1
        if(sc->sc_type & EMUXKI_AUDIGY2) {
@


1.29
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.28 2008/05/29 02:10:01 jakemsr Exp $	*/
d1576 4
a1579 2
		if ((srate < 4000) || (srate > 48000))
			return (EINVAL);
d1586 4
a1589 2
		if ((srate < 8000) || (srate > 48000))
			return (EINVAL);
d2124 5
a2128 2
	if (p->channels != 1 && p->channels != 2)
		return (EINVAL);/* Will change when streams come in use */
@


1.28
log
@use ac97 default parameters for these ac97 based drivers.

this makes the emulation expansion factor 1 by default since there's no
emulation.  previously the factor was 2 because these drivers emulate
8-bit ulaw playback with 16-bit linear encodings.  having a factor
other than 1 by default creates block size and hiwat/lowat issues
with applications that set the block size and hiwat before other
parameters.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.27 2008/04/21 00:32:43 jakemsr Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.27
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.26 2008/03/10 21:25:53 jakemsr Exp $	*/
d176 1
d257 1
a257 1
	NULL
d2228 6
@


1.26
log
@
the Dell SoundBlaster Live! 5.1 cards differ enough from "regular"
SB Live!/5.1/Audigy/2/4 cards that both OSS and ALSA provide
separate modules from their emu10k1 drivers to support them.

and in PR 5143, we see that emu(4) does not support these Dell
SBLive! cards, so don't attach emu(4) to them.

ok ratchov, brad
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.25 2008/02/22 11:45:36 jakemsr Exp $	*/
d256 1
@


1.25
log
@
as can be seen in emuxki_voice_set_srate(), the sample rate needs to
be set separately on each channel.  if changing the number of channels
make sure to set the sample rate on each channels.

fixes problems with src/regress/sys/dev/audio/autest.c, and
the hydrogen port/package, which set stereo mode either after or
without changing sample rates.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.24 2007/07/10 22:04:28 jakemsr Exp $	*/
a209 1
	{ PCI_VENDOR_CREATIVELABS, PCI_PRODUCT_CREATIVELABS_SBLIVE2 },
@


1.24
log
@emu(4) incorrectly overrides the requested recoding format, setting
it to 16-bit slinear_le.

this appears to be the result of a mistake in porting the driver
from NetBSD.  when this driver was ported, NetBSD had some members
in it's 'audio_params' structure that OpenBSD doesn't have.  in
particular, NetBSD had 'hw_encoding' and 'hw_precision', which store
what the hardware is presenting.  the 'encoding' and 'precision' members
store what the audio layer is presenting (both in NetBSD and
OpenBSD) and can be different than what the hardware is presenting.
the original NetBSD code was setting 'hw_encoding' and 'hw_precision',
and in porting was changed to 'encoding' and 'precision'.

with this change the hardware is still presenting 16-bit slinear_le;
having the variable 'b16' set to '1' is enough to ensure this.
however now the audio layer will convert it to the requested format,
instead of always outputting 16-bit slinear_le.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.23 2006/01/20 09:50:31 jakemsr Exp $	*/
a1629 4
	if (voice->stereo != stereo) {
		if ((error = emuxki_voice_set_stereo(voice, stereo)))
			return (error);
	 }
d1631 7
a1637 1
	if (voice->sample_rate != srate)
d1639 1
@


1.23
log
@- match another revision of Audigy cards
- figure sample size into start of voice buffer location
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.22 2005/11/30 22:17:46 brad Exp $	*/
a2132 2
		p->encoding = AUDIO_ENCODING_SLINEAR_LE;
		p->precision = 16;
@


1.22
log
@- add initial SB Audigy support
- add big-endian support
- fix a few typos

From NetBSD

- use pci_matchbyid()

Known working SB Live's tested by numerous users with no reported regressions;
though no one has stepped up to test out the Audigy support yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.21 2005/11/21 18:16:41 millert Exp $	*/
d469 2
a470 1
                if (PCI_REVISION(pa->pa_class) == 0x04) {
d1667 1
a1667 1
			start = mem->ptbidx << 12;
@


1.21
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.20 2005/08/09 04:10:11 mickey Exp $	*/
d47 1
a47 1
 * - bass disapear when you plug rear jack-in on Cambridge FPS2000 speakers
d55 1
a55 1
 * - Independant modification of each channel's parameters (via mixer ?)
d126 1
a126 1
int emuxki_recsrc_rate_to_index(int srate);
d139 1
d208 7
a258 2
static const int emuxki_recsrc_adcrates[] =
    { 48000, 44100, 32000, 24000, 22050, 16000, 11025, 8000, -1 };
a264 2
static const u_int32_t emuxki_recsrc_idxreg[EMU_NUMRECSRCS] =
    { EMU_RECIDX(EMU_MICIDX), EMU_RECIDX(EMU_ADCIDX), EMU_RECIDX(EMU_FXIDX) };
d382 12
a393 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_HCFG,
		EMU_HCFG_AUDIOENABLE |
		EMU_HCFG_LOCKTANKCACHE_MASK | EMU_HCFG_AUTOMUTE);
d399 6
d426 2
a427 8
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CREATIVELABS &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_SBLIVE ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_SBLIVE2))
		return (1);

	return (0);
d466 1
a466 1
	/* XXX it's unknown wheather APS is made from Audigy as well */
d469 6
a474 1
		strlcpy(sc->sc_audv.name, "Audigy", sizeof sc->sc_audv.name);
d590 3
a592 1
	ptr = ((((u_int32_t) reg) << 16) & EMU_PTR_ADDR_MASK) |
d617 3
a619 1
	ptr = ((((u_int32_t) reg) << 16) & EMU_PTR_ADDR_MASK) |
d645 4
a648 1
	emuxki_write(sc, 0, EMU_MICROCODEBASE + pc, data);
d655 17
a671 7
	emuxki_write_micro(sc, *pc << 1,
		((x << 10) & EMU_DSP_LOWORD_OPX_MASK) |
		(y & EMU_DSP_LOWORD_OPY_MASK));
	emuxki_write_micro(sc, (*pc << 1) + 1,
		((op << 20) & EMU_DSP_HIWORD_OPCODE_MASK) |
		((r << 10) & EMU_DSP_HIWORD_RESULT_MASK) |
		(a & EMU_DSP_HIWORD_OPA_MASK));
a689 9
	/* AC97 Out (l/r) = AC97 In (l/r) + FX[0/1] * 4 */
	emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
			  EMU_DSP_OUTL(EMU_DSP_OUT_AC97),
			  EMU_DSP_CST(0),
			  EMU_DSP_FX(0), EMU_DSP_CST(4));
	emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
			  EMU_DSP_OUTR(EMU_DSP_OUT_AC97),
			  EMU_DSP_CST(0),
			  EMU_DSP_FX(1), EMU_DSP_CST(4));
d691 51
a741 1
	/* Rear channel OUT (l/r) = FX[2/3] * 4 */
d743 8
a750 8
	emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
			  EMU_DSP_OUTL(EMU_DSP_OUT_RCHAN),
			  EMU_DSP_OUTL(EMU_DSP_OUT_AC97),
			  EMU_DSP_FX(0), EMU_DSP_CST(4));
	emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_MACINTS,
			  EMU_DSP_OUTR(EMU_DSP_OUT_RCHAN),
			  EMU_DSP_OUTR(EMU_DSP_OUT_AC97),
			  EMU_DSP_FX(1), EMU_DSP_CST(4));
d752 5
a756 11
	/* ADC recording (l/r) = AC97 In (l/r) */
	emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
			  EMU_DSP_OUTL(EMU_DSP_OUT_ADC),
			  EMU_DSP_INL(EMU_DSP_IN_AC97),
			  EMU_DSP_CST(0), EMU_DSP_CST(0));
	emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
			  EMU_DSP_OUTR(EMU_DSP_OUT_ADC),
			  EMU_DSP_INR(EMU_DSP_IN_AC97),
			  EMU_DSP_CST(0), EMU_DSP_CST(0));
	/* zero out the rest of the microcode */
	while (pc < 512)
d758 2
a759 1
				  EMU_DSP_CST(0), EMU_DSP_CST(0),
d762 8
a769 1
	emuxki_write(sc, 0, EMU_DBG, 0);	/* Is it really necessary ? */
d793 5
d840 12
d881 1
a881 1
		ptb[i] = silentpage | i;
d942 6
a947 1
	emuxki_write(sc, 0, EMU_FXWC, 0);
d1006 1
a1006 1
		if ((ptb[i] & EMU_CHAN_MAP_PTE_MASK) == silentpage) {
d1010 2
a1011 1
				if ((ptb[i + j] & EMU_CHAN_MAP_PTE_MASK)
d1022 2
a1023 3
						(((DMAADDR(mem->dmamem) +
						 j * EMU_PTESIZE)) << 1)
						| (i + j);
d1064 7
a1070 1
	chan->fxsend.c.level = chan->fxsend.d.level = 0xc0;	/* not max */
d1075 5
d1160 10
d1194 38
d1246 3
a1248 9
	emuxki_write(sc, chano, EMU_CHAN_FXRT,
		(chan->fxsend.d.dest << 28) | (chan->fxsend.c.dest << 24) |
		(chan->fxsend.b.dest << 20) | (chan->fxsend.a.dest << 16));
	emuxki_write(sc, chano, 0x10000000 | EMU_CHAN_PTRX,
		(chan->fxsend.a.level << 8) | chan->fxsend.b.level);
	emuxki_write(sc, chano, EMU_CHAN_DSL,
		(chan->fxsend.d.level << 24) | chan->loop.end);
	emuxki_write(sc, chano, EMU_CHAN_PSST,
		(chan->fxsend.c.level << 24) | chan->loop.start);
d1358 1
a1358 1
 * emuxki_voice_dataloc : use(play or rec) independant dataloc union helpers
d1418 1
a1418 1
		printf("Tryed to reserve invalid source: %d\n", source);
a1429 14
int
emuxki_recsrc_rate_to_index(int srate)
{
	int index;

	for (index = 0; ; index++) {
		if (emuxki_recsrc_adcrates[index] == srate)
			return (index);

		if (emuxki_recsrc_adcrates[index] < 0)
			return (-1);
	}
}

d1554 5
d1562 2
d1568 2
d1589 1
a1589 1
		if (emuxki_recsrc_rate_to_index(srate) < 0)
d1592 4
d1726 1
d1729 1
a1729 1
	if (voice->use & EMU_VOICE_USE_PLAY)
d1735 1
a1735 1
	else
d1737 21
a1757 4
		return (emuxki_read(voice->sc, 0,
		    emuxki_recsrc_idxreg[voice->dataloc.source]) &
		    EMU_RECIDX_MASK);
		
d1795 53
d1863 1
a1863 1
		switch ((int)voice->dataloc.source) {
a1864 1
			val = EMU_ADCCR_LCHANENABLE;
d1867 12
a1878 5
			if (voice->stereo)
				val |= EMU_ADCCR_RCHANENABLE;
			val |= emuxki_recsrc_rate_to_index(voice->sample_rate);
                        emuxki_write(voice->sc, 0, EMU_ADCCR, 0);
                        emuxki_write(voice->sc, 0, EMU_ADCCR, val);
d1884 3
d1892 1
a1892 1
                val = emu_rd(sc, INTE, 4);
d1894 1
a1894 1
                emu_wr(sc, INTE, val, 4);
d1912 1
a1912 1
                        emuxki_write(voice->sc, 0, EMU_ADCCR, 0);
d1928 1
a1928 1
                val = emu_rd(sc, INTE, 4);
d1930 1
a1930 1
                emu_wr(sc, INTE, val, 4);
d2116 1
a2116 1
	u_int8_t        b16, mode;
d2208 1
a2208 1
	int             mode, error;
d2303 1
a2303 1
	int             i, s;
d2305 1
a2305 1
	size_t          numblocks;
d2321 1
a2321 1
					silentpage | (mem->ptbidx + i);
d2410 1
a2410 1
	int             error;
d2433 1
a2433 1
	int             error;
@


1.20
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.19 2004/09/02 02:09:09 marco Exp $	*/
d66 1
a66 1
#include <sys/select.h>
@


1.19
log
@Prevent mixer from resetting volume back to blead-from-the-ears.

From NetBSD via Antoine Jacoutot <ajacoutot at lphp.org>

Ok millert@@ mickey@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.18 2004/04/14 21:36:41 mickey Exp $	*/
a432 3
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		pci_conf_read(pa->pa_pc, pa->pa_tag,
		(PCI_COMMAND_STATUS_REG) | PCI_COMMAND_MASTER_ENABLE));
@


1.18
log
@make it compile
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.17 2004/04/14 17:06:17 brad Exp $	*/
d1613 1
a1613 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, EMU_TIMER, timerate);
@


1.17
log
@another SoundBlaster Live

From: NetBSD

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.16 2004/02/24 18:22:30 deraadt Exp $	*/
d411 1
a411 2
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_SBLIVE2)
	{
a412 1
	}
@


1.16
log
@record code, from netbsd; via jakemsr@@jakemsr.com
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.15 2003/11/07 10:16:45 jmc Exp $	*/
d410 3
a412 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_SBLIVE)
d414 1
@


1.15
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.14 2003/04/27 11:22:53 ho Exp $	*/
a52 1
 * - Single source recording
d81 2
d125 2
d176 1
d228 1
a228 1
	NULL,			/* round blocksize */
d251 19
d271 1
a271 1
 * Dma memory mgmt
d474 1
a474 1
	    (sc->sc_audev = audio_attach_mi(&emuxki_hw_if, sc, self)) == NULL)
d476 2
a483 1
	int             err = 0;
d486 1
a486 1
	        err = config_detach(sc->sc_audev, 0);
d678 9
a1069 4
	u_int8_t        shift;
	struct emuxki_voice *voice = chan->voice;

	shift = voice->stereo + voice->b16;
a1261 1
#if 0
d1265 9
a1273 1
	if (voice->emu->recsrc[source] != NULL)
d1275 1
a1275 1
	voice->emu->recsrc[source] = voice;
d1278 14
a1291 1
#endif
d1309 3
a1311 10
		/*
		 * Commented out because i don't know how to get the selected
		 * recording source
		 */
#if 0
		if (emuxki_recsrc_reserve(voice, recsrc))
			return (EBUSY);
		printf("Which rec src do i have to create!!!\n");
#endif
		return (EBUSY);	/* just return an error, no real meaning */
d1345 20
a1364 16
		voice->sc = sc;
		voice->state = !EMU_VOICE_STATE_STARTED;
		voice->stereo = EMU_VOICE_STEREO_NOTSET;
		voice->b16 = 0;
		voice->sample_rate = 0;
		if (use & EMU_VOICE_USE_PLAY)
			voice->dataloc.chan[0] = voice->dataloc.chan[0] = NULL;
		else
			voice->dataloc.source = EMU_RECSRC_NOTSET;
		voice->buffer = NULL;
		voice->blksize = 0;
		voice->trigblk = 0;
		voice->blkmod = 0;
		voice->inth = NULL;
		voice->inthparam = NULL;
	}
d1367 1
d1401 1
d1404 2
d1407 2
d1443 3
a1445 4
#ifdef EMUXKI_DEBUG
		printf("Recording voice set_srate not implemented\n");
#endif
		return (EINVAL);
d1454 1
a1454 1
	int             error;
d1485 2
a1486 2
		emuxki_voice_set_srate(voice, srate);
	return (0);
d1498 1
a1506 1
		voice->blksize = blksize / sample_size;
d1514 1
d1528 6
d1535 1
a1535 1
			printf("Rec voice set bufparms not implemented\n");
d1537 18
a1554 1
			error = ENODEV;
d1576 2
d1579 1
d1584 6
d1603 1
a1603 2
		if ((voice->use & EMU_VOICE_USE_PLAY) == 0 ||
		    (voice->state & EMU_VOICE_STATE_STARTED) == 0)
d1631 2
d1640 27
a1667 4
#ifdef EMUXKI_DEBUG
	else
		printf("Recording voice start not implemented\n");
#endif
d1669 1
a1669 2
	if (voice->use & EMU_VOICE_USE_PLAY)
		emuxki_resched_timer(voice->sc);
d1679 24
a1703 4
#ifdef EMUXKI_DEBUG
	else
		printf("Recording voice halt not implemented\n");
#endif
d1705 1
a1705 2
	if (voice->use & EMU_VOICE_USE_PLAY)
		emuxki_resched_timer(voice->sc);
d1721 1
a1721 2
				if ((voice->use & EMU_VOICE_USE_PLAY)==0 ||
				    (voice->state &
d1727 1
d1733 10
d1780 8
a1787 2
	if (flags & AUOPEN_READ)
		return (EOPNOTSUPP);
d1895 14
d1915 2
a1916 4
		} else {
			p->sw_code = ulinear8_to_mulaw;
			b16 = 0;
		}
d1924 2
a1925 4
		} else {
			p->sw_code = ulinear8_to_alaw;
			b16 = 0;
		}
d1929 6
a1934 3
		if (p->precision == 8)
			p->sw_code = change_sign8;
		b16 = (p->precision == 16);
d1940 2
a1941 1
		b16 = (p->precision == 16);
d1947 6
a1952 3
		else
			p->sw_code = change_sign8;
		b16 = (p->precision == 16);
d1961 2
a1962 2
		}
		b16 = (p->precision == 16);
d2101 13
a2116 6
	static const int recbuf_sz[] = {
		0, 384, 448, 512, 640, 768, 896, 1024, 1280, 1536, 1792,
		2048, 2560, 3072, 3584, 4096, 5120, 6144, 7168, 8192, 10240,
		12288, 14366, 16384, 20480, 24576, 28672, 32768, 40960, 49152,
		57344, 65536
	};
d2132 4
a2135 3
		for(idx=32; --idx >= 0; ) {
			if (bsize >= recbuf_sz[idx]) {
				bsize = recbuf_sz[idx];
a2151 1
	u_int32_t      *ptb;
a2152 1
	ptb = KERNADDR(sc->ptb);
a2212 1
	emuxki_voice_commit_parms(voice); /* Useless for record ? */
@


1.14
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.13 2003/04/26 08:01:42 jmc Exp $	*/
d1642 1
a1642 1
	 * params This will be adressed very soon
@


1.13
log
@managment -> management;

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.12 2003/02/18 14:32:13 jmc Exp $	*/
d435 1
a435 1
		strcpy(sc->sc_audv.name, "Audigy");
d439 1
a439 1
		strcpy(sc->sc_audv.name, "E-mu APS");
d442 1
a442 1
		strcpy(sc->sc_audv.name, "SB Live!");
d444 3
a446 2
	sprintf(sc->sc_audv.version, "0x%02x", PCI_REVISION(pa->pa_class));
	strcpy(sc->sc_audv.config, "emuxki");
d1688 1
a1688 1
		strcpy(fp->name, AudioEulinear);
d1694 1
a1694 1
		strcpy(fp->name, AudioEmulaw);
d1700 1
a1700 1
		strcpy(fp->name, AudioEalaw);
d1706 1
a1706 1
		strcpy(fp->name, AudioEslinear);
d1712 1
a1712 1
		strcpy(fp->name, AudioEslinear_le);
d1718 1
a1718 1
		strcpy(fp->name, AudioEulinear_le);
d1724 1
a1724 1
		strcpy(fp->name, AudioEslinear_be);
d1730 1
a1730 1
		strcpy(fp->name, AudioEulinear_be);
@


1.12
log
@intial -> initial

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.11 2002/06/03 21:13:20 mickey Exp $	*/
d832 1
a832 1
/* Emu10k1 Memory managment */
d920 1
a920 1
 * emuxki_channel_* : Channel managment functions
d1176 1
a1176 1
 * Voices managment
@


1.11
log
@probe for flavours, aps and audigy still need more work though
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.10 2002/03/14 03:16:06 millert Exp $	*/
d938 1
a938 1
	chan->pitch.intial = 0x0000;	/* shouldn't it be 0xE000 ? */
d1027 1
a1027 1
	chan->pitch.intial =
d1153 1
a1153 1
	emuxki_write(sc, chano, EMU_CHAN_IP, chan->pitch.intial);
@


1.10
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.9 2002/03/14 01:26:58 millert Exp $	*/
d345 2
d432 18
a449 1
	if (emuxki_scinit(sc) || emuxki_ac97_init(sc) ||
d1867 1
a1867 1
emuxki_getdev(void *addr, struct audio_device *dev)
d1869 3
a1871 5
	strncpy(dev->name, "Creative EMU10k1", sizeof(dev->name));
	strcpy(dev->version, "");
	strncpy(dev->config, "emuxki", sizeof(dev->config));

	return (0);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.8 2002/01/20 19:56:53 ericj Exp $	*/
d127 1
a127 2
void emuxki_voice_start
	__P((struct emuxki_voice *, void (*) (void *), void *));
d175 4
a178 6
int	emuxki_trigger_output   __P((void *, void *, void *, int,
				      void (*)(void *), void *,
				      struct audio_params *));
int	emuxki_trigger_input    __P((void *, void *, void *, int,
				      void (*) (void *), void *,
				      struct audio_params *));
@


1.8
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.7 2001/11/29 13:05:30 ho Exp $	*/
d83 5
a87 5
int  emuxki_match  __P((struct device *, void *, void *));
void emuxki_attach __P((struct device *, struct device *, void *));
int  emuxki_detach __P((struct device *, int));
int  emuxki_scinit __P((struct emuxki_softc *sc));
void emuxki_pci_shutdown __P((struct emuxki_softc *sc));
d90 8
a97 8
struct dmamem *emuxki_dmamem_alloc __P((bus_dma_tag_t, size_t, bus_size_t,
				 int, int, int));
void	emuxki_dmamem_free  __P((struct dmamem *, int));
void	emuxki_dmamem_delete __P((struct dmamem *mem, int type));

struct emuxki_mem *emuxki_mem_new __P((struct emuxki_softc *sc, int ptbidx,
	size_t size, int type, int flags));
void emuxki_mem_delete __P((struct emuxki_mem *mem, int type));
d100 2
a101 2
int  emuxki_init     __P((struct emuxki_softc *));
void emuxki_shutdown __P((struct emuxki_softc *));
d104 2
a105 2
void   *emuxki_pmem_alloc __P((struct emuxki_softc *, size_t,int,int));
void   *emuxki_rmem_alloc __P((struct emuxki_softc *, size_t,int,int));
d114 3
a116 4
struct emuxki_voice *emuxki_voice_new __P((struct emuxki_softc *, u_int8_t));
void   emuxki_voice_delete __P((struct emuxki_voice *));
int    emuxki_voice_set_audioparms
	__P((struct emuxki_voice *, u_int8_t, u_int8_t, u_int32_t));
d118 9
a126 11
int emuxki_voice_set_bufparms
	__P((struct emuxki_voice *, void *, u_int32_t, u_int16_t));
int emuxki_voice_set_stereo __P((struct emuxki_voice *voice, u_int8_t stereo));
int emuxki_voice_dataloc_create __P((struct emuxki_voice *voice));
void emuxki_voice_dataloc_destroy __P((struct emuxki_voice *voice));
void emuxki_voice_commit_parms  __P((struct emuxki_voice *));
void emuxki_voice_recsrc_release
	__P((struct emuxki_softc *sc, emuxki_recsrc_t source));
u_int32_t emuxki_voice_curaddr  __P((struct emuxki_voice *));
int emuxki_set_vparms __P((struct emuxki_voice *voice, struct audio_params *p));
int emuxki_voice_set_srate __P((struct emuxki_voice *voice, u_int32_t srate));
d129 14
a142 17
void emuxki_voice_halt __P((struct emuxki_voice *));
int emuxki_voice_channel_create __P((struct emuxki_voice *voice));
void emuxki_voice_channel_destroy __P((struct emuxki_voice *voice));

struct emuxki_channel *emuxki_channel_new
	__P((struct emuxki_voice *voice, u_int8_t num));
void emuxki_channel_delete __P((struct emuxki_channel *chan));
void emuxki_channel_start __P((struct emuxki_channel *chan));
void emuxki_channel_stop __P((struct emuxki_channel *chan));
void emuxki_channel_commit_parms __P((struct emuxki_channel *chan));
void emuxki_channel_set_bufparms
	__P((struct emuxki_channel *chan, u_int32_t start, u_int32_t end));
void emuxki_channel_set_srate
	__P((struct emuxki_channel *chan, u_int32_t srate));
void emuxki_channel_set_fxsend __P((struct emuxki_channel *chan,
	struct emuxki_chanparms_fxsend *fxsend));
void emuxki_chanparms_set_defaults __P((struct emuxki_channel *chan));
d144 1
a144 1
void emuxki_resched_timer __P((struct emuxki_softc *sc));
d150 6
a155 6
struct emuxki_stream *emuxki_stream_new __P((struct emu10k1 *));
void   emuxki_stream_delete __P((struct emuxki_stream *));
int    emuxki_stream_set_audio_params __P((struct emuxki_stream *, u_int8_t,
					    u_int8_t, u_int8_t, u_int16_t));
void   emuxki_stream_start __P((struct emuxki_stream *));
void   emuxki_stream_halt __P((struct emuxki_stream *));
d159 4
a162 5
void emuxki_initfx __P((struct emuxki_softc *sc));
void emuxki_dsp_addop __P((struct emuxki_softc *sc, u_int16_t *pc, u_int8_t op,
	u_int16_t r, u_int16_t a, u_int16_t x, u_int16_t y));
void emuxki_write_micro
	__P((struct emuxki_softc *sc, u_int32_t pc, u_int32_t data));
d166 2
a167 2
int	emuxki_open             __P((void *, int));
void	emuxki_close            __P((void *));
d169 2
a170 2
int	emuxki_query_encoding   __P((void *, struct audio_encoding *));
int	emuxki_set_params       __P((void *, int, int,
d172 1
a172 1
				      struct audio_params *));
d174 1
a174 1
size_t	emuxki_round_buffersize __P((void *, int, size_t));
d182 2
a183 2
int	emuxki_halt_output      __P((void *));
int	emuxki_halt_input       __P((void *));
d185 4
a188 4
int	emuxki_getdev           __P((void *, struct audio_device *));
int	emuxki_set_port         __P((void *, mixer_ctrl_t *));
int	emuxki_get_port         __P((void *, mixer_ctrl_t *));
int	emuxki_query_devinfo    __P((void *, mixer_devinfo_t *));
d190 2
a191 2
void   *emuxki_allocm           __P((void *, int, size_t, int, int));
void	emuxki_freem            __P((void *, void *, int));
d193 2
a194 2
paddr_t	emuxki_mappage          __P((void *, void *, off_t, int));
int	emuxki_get_props        __P((void *));
d197 1
a197 1
int  emuxki_intr __P((void *));
d200 5
a204 5
int  emuxki_ac97_init __P((struct emuxki_softc *sc));
int  emuxki_ac97_attach __P((void *, struct ac97_codec_if *));
int  emuxki_ac97_read   __P((void *, u_int8_t, u_int16_t *));
int  emuxki_ac97_write  __P((void *, u_int8_t, u_int16_t));
void emuxki_ac97_reset  __P((void *));
@


1.7
log
@sc must be initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.6 2001/11/26 18:16:02 mickey Exp $	*/
d248 1
a248 1
	NULL,			/* allocm_old */
d250 1
a250 1
	NULL,			/* round_buffersize_old */
a254 2
	emuxki_allocm,
	emuxki_round_buffersize
@


1.7.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.8 2002/01/20 19:56:53 ericj Exp $	*/
d248 1
a248 1
	emuxki_allocm,
d250 1
a250 1
	emuxki_round_buffersize,
d255 2
@


1.7.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.7.2.1 2002/01/31 22:55:34 niklas Exp $	*/
d83 5
a87 5
int  emuxki_match(struct device *, void *, void *);
void emuxki_attach(struct device *, struct device *, void *);
int  emuxki_detach(struct device *, int);
int  emuxki_scinit(struct emuxki_softc *sc);
void emuxki_pci_shutdown(struct emuxki_softc *sc);
d90 8
a97 8
struct dmamem *emuxki_dmamem_alloc(bus_dma_tag_t, size_t, bus_size_t,
				 int, int, int);
void	emuxki_dmamem_free(struct dmamem *, int);
void	emuxki_dmamem_delete(struct dmamem *mem, int type);

struct emuxki_mem *emuxki_mem_new(struct emuxki_softc *sc, int ptbidx,
	size_t size, int type, int flags);
void emuxki_mem_delete(struct emuxki_mem *mem, int type);
d100 2
a101 2
int  emuxki_init(struct emuxki_softc *);
void emuxki_shutdown(struct emuxki_softc *);
d104 2
a105 2
void   *emuxki_pmem_alloc(struct emuxki_softc *, size_t,int,int);
void   *emuxki_rmem_alloc(struct emuxki_softc *, size_t,int,int);
d114 4
a117 3
struct emuxki_voice *emuxki_voice_new(struct emuxki_softc *, u_int8_t);
void   emuxki_voice_delete(struct emuxki_voice *);
int    emuxki_voice_set_audioparms(struct emuxki_voice *, u_int8_t, u_int8_t, u_int32_t);
d119 30
a148 24
int emuxki_voice_set_bufparms(struct emuxki_voice *, void *, u_int32_t, u_int16_t);
int emuxki_voice_set_stereo(struct emuxki_voice *voice, u_int8_t stereo);
int emuxki_voice_dataloc_create(struct emuxki_voice *voice);
void emuxki_voice_dataloc_destroy(struct emuxki_voice *voice);
void emuxki_voice_commit_parms(struct emuxki_voice *);
void emuxki_voice_recsrc_release(struct emuxki_softc *sc, emuxki_recsrc_t source);
u_int32_t emuxki_voice_curaddr(struct emuxki_voice *);
int emuxki_set_vparms(struct emuxki_voice *voice, struct audio_params *p);
int emuxki_voice_set_srate(struct emuxki_voice *voice, u_int32_t srate);
void emuxki_voice_start(struct emuxki_voice *, void (*) (void *), void *);
void emuxki_voice_halt(struct emuxki_voice *);
int emuxki_voice_channel_create(struct emuxki_voice *voice);
void emuxki_voice_channel_destroy(struct emuxki_voice *voice);

struct emuxki_channel *emuxki_channel_new(struct emuxki_voice *voice, u_int8_t num);
void emuxki_channel_delete(struct emuxki_channel *chan);
void emuxki_channel_start(struct emuxki_channel *chan);
void emuxki_channel_stop(struct emuxki_channel *chan);
void emuxki_channel_commit_parms(struct emuxki_channel *chan);
void emuxki_channel_set_bufparms(struct emuxki_channel *chan, u_int32_t start, u_int32_t end);
void emuxki_channel_set_srate(struct emuxki_channel *chan, u_int32_t srate);
void emuxki_channel_set_fxsend(struct emuxki_channel *chan,
	struct emuxki_chanparms_fxsend *fxsend);
void emuxki_chanparms_set_defaults(struct emuxki_channel *chan);
d150 1
a150 1
void emuxki_resched_timer(struct emuxki_softc *sc);
d156 6
a161 6
struct emuxki_stream *emuxki_stream_new(struct emu10k1 *);
void   emuxki_stream_delete(struct emuxki_stream *);
int    emuxki_stream_set_audio_params(struct emuxki_stream *, u_int8_t,
					    u_int8_t, u_int8_t, u_int16_t);
void   emuxki_stream_start(struct emuxki_stream *);
void   emuxki_stream_halt(struct emuxki_stream *);
d165 5
a169 4
void emuxki_initfx(struct emuxki_softc *sc);
void emuxki_dsp_addop(struct emuxki_softc *sc, u_int16_t *pc, u_int8_t op,
	u_int16_t r, u_int16_t a, u_int16_t x, u_int16_t y);
void emuxki_write_micro(struct emuxki_softc *sc, u_int32_t pc, u_int32_t data);
d173 2
a174 2
int	emuxki_open(void *, int);
void	emuxki_close(void *);
d176 2
a177 2
int	emuxki_query_encoding(void *, struct audio_encoding *);
int	emuxki_set_params(void *, int, int,
d179 1
a179 1
				      struct audio_params *);
d181 1
a181 1
size_t	emuxki_round_buffersize(void *, int, size_t);
d183 13
a195 11
int	emuxki_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	emuxki_trigger_input(void *, void *, void *, int, void (*) (void *),
	    void *, struct audio_params *);
int	emuxki_halt_output(void *);
int	emuxki_halt_input(void *);

int	emuxki_getdev(void *, struct audio_device *);
int	emuxki_set_port(void *, mixer_ctrl_t *);
int	emuxki_get_port(void *, mixer_ctrl_t *);
int	emuxki_query_devinfo(void *, mixer_devinfo_t *);
d197 2
a198 2
void   *emuxki_allocm(void *, int, size_t, int, int);
void	emuxki_freem(void *, void *, int);
d200 2
a201 2
paddr_t	emuxki_mappage(void *, void *, off_t, int);
int	emuxki_get_props(void *);
d204 1
a204 1
int  emuxki_intr(void *);
d207 5
a211 5
int  emuxki_ac97_init(struct emuxki_softc *sc);
int  emuxki_ac97_attach(void *, struct ac97_codec_if *);
int  emuxki_ac97_read(void *, u_int8_t, u_int16_t *);
int  emuxki_ac97_write(void *, u_int8_t, u_int16_t);
void emuxki_ac97_reset(void *);
a354 2
		/* enable spdif(?) output on non-APS */
		(sc->sc_type == EMUXKI_APS? 0 : EMU_HCFG_GPOUTPUT0) |
d440 1
a440 18
	/* XXX it's unknown wheather APS is made from Audigy as well */
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_AUDIGY) {
		sc->sc_type = EMUXKI_AUDIGY;
		strcpy(sc->sc_audv.name, "Audigy");
	} else if (pci_conf_read(pa->pa_pc, pa->pa_tag,
	    PCI_SUBSYS_ID_REG) == EMU_SUBSYS_APS) {
		sc->sc_type = EMUXKI_APS;
		strcpy(sc->sc_audv.name, "E-mu APS");
	} else {
		sc->sc_type = EMUXKI_SBLIVE;
		strcpy(sc->sc_audv.name, "SB Live!");
	}
	sprintf(sc->sc_audv.version, "0x%02x", PCI_REVISION(pa->pa_class));
	strcpy(sc->sc_audv.config, "emuxki");

	if (emuxki_scinit(sc) ||
	    /* APS has no ac97 XXX */
	    (sc->sc_type == EMUXKI_APS || emuxki_ac97_init(sc)) ||
d1858 1
a1858 1
emuxki_getdev(void *v, struct audio_device *adp)
d1860 5
a1864 3
	struct emuxki_softc *sc = v;
	*adp = sc->sc_audv;
	return 0;
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d435 1
a435 1
		strlcpy(sc->sc_audv.name, "Audigy", sizeof sc->sc_audv.name);
d439 1
a439 1
		strlcpy(sc->sc_audv.name, "E-mu APS", sizeof sc->sc_audv.name);
d442 1
a442 1
		strlcpy(sc->sc_audv.name, "SB Live!", sizeof sc->sc_audv.name);
d444 2
a445 3
	snprintf(sc->sc_audv.version, sizeof sc->sc_audv.version, "0x%02x",
		 PCI_REVISION(pa->pa_class));
	strlcpy(sc->sc_audv.config, "emuxki", sizeof sc->sc_audv.config);
d832 1
a832 1
/* Emu10k1 Memory management */
d920 1
a920 1
 * emuxki_channel_* : Channel management functions
d938 1
a938 1
	chan->pitch.initial = 0x0000;	/* shouldn't it be 0xE000 ? */
d1027 1
a1027 1
	chan->pitch.initial =
d1153 1
a1153 1
	emuxki_write(sc, chano, EMU_CHAN_IP, chan->pitch.initial);
d1176 1
a1176 1
 * Voices management
d1687 1
a1687 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d1693 1
a1693 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d1699 1
a1699 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d1705 1
a1705 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d1711 1
a1711 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d1717 1
a1717 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d1723 1
a1723 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d1729 1
a1729 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.6
log
@cache the last deallocated voice and reuse on the next open.
this is to preserve the dac settings in between the openings,
by the mp3 playing software, in particular.
ho@@ help and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.5 2001/11/20 12:22:59 mickey Exp $	*/
d837 2
a838 2
	if ((mem->dmamem = emuxki_dmamem_alloc(sc->sc_dmat, size, EMU_DMA_ALIGN,
	    EMU_DMAMEM_NSEG, type, flags)) == NULL) {
d1323 1
a1323 1
	struct emuxki_softc *sc;
@


1.5
log
@use more reasonable default level values; ho@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.4 2001/10/31 11:00:24 art Exp $	*/
d1287 24
a1310 3
	if ((voice = malloc(sizeof(*voice), M_DEVBUF, M_WAITOK)) == NULL)
		return (NULL);
	voice->sc = sc;
a1311 14
	voice->state = !EMU_VOICE_STATE_STARTED;
	voice->stereo = EMU_VOICE_STEREO_NOTSET;
	voice->b16 = 0;
	voice->sample_rate = 0;
	if (use & EMU_VOICE_USE_PLAY)
		voice->dataloc.chan[0] = voice->dataloc.chan[0] = NULL;
	else
		voice->dataloc.source = EMU_RECSRC_NOTSET;
	voice->buffer = NULL;
	voice->blksize = 0;
	voice->trigblk = 0;
	voice->blkmod = 0;
	voice->inth = NULL;
	voice->inthparam = NULL;
d1323 3
a1325 1
	int             s;
d1332 2
d1336 4
a1339 2
	emuxki_voice_dataloc_destroy(voice);
	free(voice, M_DEVBUF);
@


1.4
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.3 2001/10/24 23:23:44 ho Exp $	*/
d925 1
a925 1
	chan->fxsend.c.level = chan->fxsend.d.level = 0xff;	/* max */
d1345 1
a1345 1
			fxsend.a.level = fxsend.c.level = 0xff;
d1350 1
a1350 1
			fxsend.b.level = fxsend.d.level = 0xff;
@


1.3
log
@Print intrstr, not dv_xname. mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.2 2001/10/24 15:09:28 brad Exp $	*/
d200 1
a200 1
int	emuxki_mappage          __P((void *, void *, int, int));
d1961 2
a1962 2
int
emuxki_mappage(void *addr, void *ptr, int off, int prot)
@


1.3.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.2.2
log
@Merge in -current
@
text
@d200 1
a200 1
paddr_t	emuxki_mappage          __P((void *, void *, off_t, int));
d1961 2
a1962 2
paddr_t
emuxki_mappage(void *addr, void *ptr, off_t off, int prot)
@


1.3.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.3.2.2 2001/11/13 21:10:01 niklas Exp $	*/
d837 2
a838 2
	if ((mem->dmamem = emuxki_dmamem_alloc(sc->sc_dmat, size,
	    EMU_DMA_ALIGN, EMU_DMAMEM_NSEG, type, flags)) == NULL) {
d925 1
a925 1
	chan->fxsend.c.level = chan->fxsend.d.level = 0xc0;	/* not max */
d1287 3
a1289 24
	s = splaudio();
	voice = sc->lvoice;
	sc->lvoice = NULL;
	splx(s);

	if (!voice) {
		if (!(voice = malloc(sizeof(*voice), M_DEVBUF, M_WAITOK)))
			return (NULL);
		voice->sc = sc;
		voice->state = !EMU_VOICE_STATE_STARTED;
		voice->stereo = EMU_VOICE_STEREO_NOTSET;
		voice->b16 = 0;
		voice->sample_rate = 0;
		if (use & EMU_VOICE_USE_PLAY)
			voice->dataloc.chan[0] = voice->dataloc.chan[0] = NULL;
		else
			voice->dataloc.source = EMU_RECSRC_NOTSET;
		voice->buffer = NULL;
		voice->blksize = 0;
		voice->trigblk = 0;
		voice->blkmod = 0;
		voice->inth = NULL;
		voice->inthparam = NULL;
	}
d1291 14
d1316 1
a1316 3
	struct emuxki_softc *sc = voice->sc;
	struct emuxki_voice *lvoice;
	int s;
a1322 2
	lvoice = sc->lvoice;
	sc->lvoice = voice;
d1325 2
a1326 4
	if (lvoice) {
		emuxki_voice_dataloc_destroy(lvoice);
		free(lvoice, M_DEVBUF);
	}
d1345 1
a1345 1
			fxsend.a.level = fxsend.c.level = 0xc0;
d1350 1
a1350 1
			fxsend.b.level = fxsend.d.level = 0xc0;
@


1.3.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d248 1
a248 1
	emuxki_allocm,
d250 1
a250 1
	emuxki_round_buffersize,
d255 2
@


1.3.2.5
log
@Merge in -current from roughly a week ago
@
text
@d83 5
a87 5
int  emuxki_match(struct device *, void *, void *);
void emuxki_attach(struct device *, struct device *, void *);
int  emuxki_detach(struct device *, int);
int  emuxki_scinit(struct emuxki_softc *sc);
void emuxki_pci_shutdown(struct emuxki_softc *sc);
d90 8
a97 8
struct dmamem *emuxki_dmamem_alloc(bus_dma_tag_t, size_t, bus_size_t,
				 int, int, int);
void	emuxki_dmamem_free(struct dmamem *, int);
void	emuxki_dmamem_delete(struct dmamem *mem, int type);

struct emuxki_mem *emuxki_mem_new(struct emuxki_softc *sc, int ptbidx,
	size_t size, int type, int flags);
void emuxki_mem_delete(struct emuxki_mem *mem, int type);
d100 2
a101 2
int  emuxki_init(struct emuxki_softc *);
void emuxki_shutdown(struct emuxki_softc *);
d104 2
a105 2
void   *emuxki_pmem_alloc(struct emuxki_softc *, size_t,int,int);
void   *emuxki_rmem_alloc(struct emuxki_softc *, size_t,int,int);
d114 4
a117 3
struct emuxki_voice *emuxki_voice_new(struct emuxki_softc *, u_int8_t);
void   emuxki_voice_delete(struct emuxki_voice *);
int    emuxki_voice_set_audioparms(struct emuxki_voice *, u_int8_t, u_int8_t, u_int32_t);
d119 30
a148 24
int emuxki_voice_set_bufparms(struct emuxki_voice *, void *, u_int32_t, u_int16_t);
int emuxki_voice_set_stereo(struct emuxki_voice *voice, u_int8_t stereo);
int emuxki_voice_dataloc_create(struct emuxki_voice *voice);
void emuxki_voice_dataloc_destroy(struct emuxki_voice *voice);
void emuxki_voice_commit_parms(struct emuxki_voice *);
void emuxki_voice_recsrc_release(struct emuxki_softc *sc, emuxki_recsrc_t source);
u_int32_t emuxki_voice_curaddr(struct emuxki_voice *);
int emuxki_set_vparms(struct emuxki_voice *voice, struct audio_params *p);
int emuxki_voice_set_srate(struct emuxki_voice *voice, u_int32_t srate);
void emuxki_voice_start(struct emuxki_voice *, void (*) (void *), void *);
void emuxki_voice_halt(struct emuxki_voice *);
int emuxki_voice_channel_create(struct emuxki_voice *voice);
void emuxki_voice_channel_destroy(struct emuxki_voice *voice);

struct emuxki_channel *emuxki_channel_new(struct emuxki_voice *voice, u_int8_t num);
void emuxki_channel_delete(struct emuxki_channel *chan);
void emuxki_channel_start(struct emuxki_channel *chan);
void emuxki_channel_stop(struct emuxki_channel *chan);
void emuxki_channel_commit_parms(struct emuxki_channel *chan);
void emuxki_channel_set_bufparms(struct emuxki_channel *chan, u_int32_t start, u_int32_t end);
void emuxki_channel_set_srate(struct emuxki_channel *chan, u_int32_t srate);
void emuxki_channel_set_fxsend(struct emuxki_channel *chan,
	struct emuxki_chanparms_fxsend *fxsend);
void emuxki_chanparms_set_defaults(struct emuxki_channel *chan);
d150 1
a150 1
void emuxki_resched_timer(struct emuxki_softc *sc);
d156 6
a161 6
struct emuxki_stream *emuxki_stream_new(struct emu10k1 *);
void   emuxki_stream_delete(struct emuxki_stream *);
int    emuxki_stream_set_audio_params(struct emuxki_stream *, u_int8_t,
					    u_int8_t, u_int8_t, u_int16_t);
void   emuxki_stream_start(struct emuxki_stream *);
void   emuxki_stream_halt(struct emuxki_stream *);
d165 5
a169 4
void emuxki_initfx(struct emuxki_softc *sc);
void emuxki_dsp_addop(struct emuxki_softc *sc, u_int16_t *pc, u_int8_t op,
	u_int16_t r, u_int16_t a, u_int16_t x, u_int16_t y);
void emuxki_write_micro(struct emuxki_softc *sc, u_int32_t pc, u_int32_t data);
d173 2
a174 2
int	emuxki_open(void *, int);
void	emuxki_close(void *);
d176 2
a177 2
int	emuxki_query_encoding(void *, struct audio_encoding *);
int	emuxki_set_params(void *, int, int,
d179 1
a179 1
				      struct audio_params *);
d181 1
a181 1
size_t	emuxki_round_buffersize(void *, int, size_t);
d183 13
a195 11
int	emuxki_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	emuxki_trigger_input(void *, void *, void *, int, void (*) (void *),
	    void *, struct audio_params *);
int	emuxki_halt_output(void *);
int	emuxki_halt_input(void *);

int	emuxki_getdev(void *, struct audio_device *);
int	emuxki_set_port(void *, mixer_ctrl_t *);
int	emuxki_get_port(void *, mixer_ctrl_t *);
int	emuxki_query_devinfo(void *, mixer_devinfo_t *);
d197 2
a198 2
void   *emuxki_allocm(void *, int, size_t, int, int);
void	emuxki_freem(void *, void *, int);
d200 2
a201 2
paddr_t	emuxki_mappage(void *, void *, off_t, int);
int	emuxki_get_props(void *);
d204 1
a204 1
int  emuxki_intr(void *);
d207 5
a211 5
int  emuxki_ac97_init(struct emuxki_softc *sc);
int  emuxki_ac97_attach(void *, struct ac97_codec_if *);
int  emuxki_ac97_read(void *, u_int8_t, u_int16_t *);
int  emuxki_ac97_write(void *, u_int8_t, u_int16_t);
void emuxki_ac97_reset(void *);
@


1.3.2.6
log
@Sync the SMP branch with 3.3
@
text
@a344 2
		/* enable spdif(?) output on non-APS */
		(sc->sc_type == EMUXKI_APS? 0 : EMU_HCFG_GPOUTPUT0) |
d430 1
a430 18
	/* XXX it's unknown wheather APS is made from Audigy as well */
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_AUDIGY) {
		sc->sc_type = EMUXKI_AUDIGY;
		strcpy(sc->sc_audv.name, "Audigy");
	} else if (pci_conf_read(pa->pa_pc, pa->pa_tag,
	    PCI_SUBSYS_ID_REG) == EMU_SUBSYS_APS) {
		sc->sc_type = EMUXKI_APS;
		strcpy(sc->sc_audv.name, "E-mu APS");
	} else {
		sc->sc_type = EMUXKI_SBLIVE;
		strcpy(sc->sc_audv.name, "SB Live!");
	}
	sprintf(sc->sc_audv.version, "0x%02x", PCI_REVISION(pa->pa_class));
	strcpy(sc->sc_audv.config, "emuxki");

	if (emuxki_scinit(sc) ||
	    /* APS has no ac97 XXX */
	    (sc->sc_type == EMUXKI_APS || emuxki_ac97_init(sc)) ||
d919 1
a919 1
	chan->pitch.initial = 0x0000;	/* shouldn't it be 0xE000 ? */
d1008 1
a1008 1
	chan->pitch.initial =
d1134 1
a1134 1
	emuxki_write(sc, chano, EMU_CHAN_IP, chan->pitch.initial);
d1848 1
a1848 1
emuxki_getdev(void *v, struct audio_device *adp)
d1850 5
a1854 3
	struct emuxki_softc *sc = v;
	*adp = sc->sc_audv;
	return 0;
@


1.3.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: emuxki.c,v 1.3.2.6 2003/03/28 00:38:21 niklas Exp $	*/
d435 1
a435 1
		strlcpy(sc->sc_audv.name, "Audigy", sizeof sc->sc_audv.name);
d439 1
a439 1
		strlcpy(sc->sc_audv.name, "E-mu APS", sizeof sc->sc_audv.name);
d442 1
a442 1
		strlcpy(sc->sc_audv.name, "SB Live!", sizeof sc->sc_audv.name);
d444 2
a445 3
	snprintf(sc->sc_audv.version, sizeof sc->sc_audv.version, "0x%02x",
		 PCI_REVISION(pa->pa_class));
	strlcpy(sc->sc_audv.config, "emuxki", sizeof sc->sc_audv.config);
d832 1
a832 1
/* Emu10k1 Memory management */
d920 1
a920 1
 * emuxki_channel_* : Channel management functions
d1176 1
a1176 1
 * Voices management
d1687 1
a1687 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d1693 1
a1693 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d1699 1
a1699 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d1705 1
a1705 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d1711 1
a1711 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d1717 1
a1717 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d1723 1
a1723 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d1729 1
a1729 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.3.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1642 1
a1642 1
	 * params. This will be addressed very soon.
@


1.3.2.9
log
@Merge with the trunk
@
text
@d53 1
a81 2
#define slinear16_to_ulinear8_le linear16_to_ulinear8_le;

a123 2
int emuxki_recsrc_reserve(struct emuxki_voice *voice, emuxki_recsrc_t source);
int emuxki_recsrc_rate_to_index(int srate);
a172 1
int	emuxki_round_blocksize(void *, int);
d224 1
a224 1
	emuxki_round_blocksize,
a246 19
static const int emuxki_recsrc_adcrates[] =
    { 48000, 44100, 32000, 24000, 22050, 16000, 11025, 8000, -1 };
#if 0
static const int emuxki_recsrc_intrmasks[EMU_NUMRECSRCS] =
    { EMU_INTE_MICBUFENABLE, EMU_INTE_ADCBUFENABLE, EMU_INTE_EFXBUFENABLE };
#endif
static const u_int32_t emuxki_recsrc_bufaddrreg[EMU_NUMRECSRCS] =
    { EMU_MICBA, EMU_ADCBA, EMU_FXBA };
static const u_int32_t emuxki_recsrc_idxreg[EMU_NUMRECSRCS] =
    { EMU_RECIDX(EMU_MICIDX), EMU_RECIDX(EMU_ADCIDX), EMU_RECIDX(EMU_FXIDX) };
static const u_int32_t emuxki_recsrc_szreg[EMU_NUMRECSRCS] =
    { EMU_MICBS, EMU_ADCBS, EMU_FXBS };
static const int emuxki_recbuf_sz[] = {
	0, 384, 448, 512, 640, 768, 896, 1024, 1280, 1536, 1792,
	2048, 2560, 3072, 3584, 4096, 5120, 6144, 7168, 8192, 10240,
	12288, 14366, 16384, 20480, 24576, 28672, 32768, 40960, 49152,
	57344, 65536
};

d248 1
a248 1
 * DMA memory mgmt
d387 1
a387 2
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_SBLIVE ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_SBLIVE2))
d451 1
a451 1
	    (sc->sc_audev = audio_attach_mi(&emuxki_hw_if, sc, self)) == NULL) {
a452 2
		return;
	}
d459 1
d462 1
a462 1
		config_detach(sc->sc_audev, 0);
a653 9
	/* ADC recording (l/r) = AC97 In (l/r) */
	emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
			  EMU_DSP_OUTL(EMU_DSP_OUT_ADC),
			  EMU_DSP_INL(EMU_DSP_IN_AC97),
			  EMU_DSP_CST(0), EMU_DSP_CST(0));
	emuxki_dsp_addop(sc, &pc, EMU_DSP_OP_ACC3,
			  EMU_DSP_OUTR(EMU_DSP_OUT_ADC),
			  EMU_DSP_INR(EMU_DSP_IN_AC97),
			  EMU_DSP_CST(0), EMU_DSP_CST(0));
d1037 4
d1233 1
d1237 1
a1237 9
	if (source < 0 || source >= EMU_NUMRECSRCS) {
#ifdef EMUXKI_DEBUG
		printf("Tryed to reserve invalid source: %d\n", source);
#endif
		return (EINVAL);
	}
	if (voice->sc->recsrc[source] == voice)
		return (0);			/* XXX */
	if (voice->sc->recsrc[source] != NULL)
d1239 1
a1239 1
	voice->sc->recsrc[source] = voice;
d1242 1
a1242 14

int
emuxki_recsrc_rate_to_index(int srate)
{
	int index;

	for (index = 0; ; index++) {
		if (emuxki_recsrc_adcrates[index] == srate)
			return (index);

		if (emuxki_recsrc_adcrates[index] < 0)
			return (-1);
	}
}
d1260 10
a1269 3
		if ((error =
		    emuxki_recsrc_reserve(voice, voice->dataloc.source)))
			return (error);
d1303 16
a1318 20
	} else if (voice->use != use) 
		emuxki_voice_dataloc_destroy(voice);
	else
		goto skip_initialize;

	voice->sc = sc;
	voice->state = !EMU_VOICE_STATE_STARTED;
	voice->stereo = EMU_VOICE_STEREO_NOTSET;
	voice->b16 = 0;
	voice->sample_rate = 0;
	if (use & EMU_VOICE_USE_PLAY)
		voice->dataloc.chan[0] = voice->dataloc.chan[1] = NULL;
	else
		voice->dataloc.source = EMU_RECSRC_NOTSET;
	voice->buffer = NULL;
	voice->blksize = 0;
	voice->trigblk = 0;
	voice->blkmod = 0;
	voice->inth = NULL;
	voice->inthparam = NULL;
a1320 1
skip_initialize:
a1353 1
	emuxki_recsrc_t source = 0; /* XXX: gcc */
a1355 2
	if (! (voice->use & EMU_VOICE_USE_PLAY))
		source = voice->dataloc.source;
a1356 2
	if (! (voice->use & EMU_VOICE_USE_PLAY))
		voice->dataloc.source = source;
d1391 4
a1394 3
		if (emuxki_recsrc_rate_to_index(srate) < 0)
			return (EINVAL);
		voice->sample_rate = srate;
d1403 1
a1403 1
	int             error = 0;
d1434 2
a1435 2
		error = emuxki_voice_set_srate(voice, srate);
	return error;
a1446 1
	int idx;
d1455 1
a1462 1
			voice->blksize = blksize / sample_size;
a1475 6
			voice->blksize = blksize;
			for(idx = sizeof(emuxki_recbuf_sz) /
			    sizeof(emuxki_recbuf_sz[0]); --idx >= 0;)
				if (emuxki_recbuf_sz[idx] == bufsize)
					break;
			if (idx < 0) {
d1477 1
a1477 1
				printf("Invalid bufsize: %d\n", bufsize);
d1479 1
a1479 18
				return (EINVAL);
			}
			emuxki_write(voice->sc, 0,
			    emuxki_recsrc_szreg[voice->dataloc.source], idx);
			emuxki_write(voice->sc, 0,
			    emuxki_recsrc_bufaddrreg[voice->dataloc.source],
			    DMAADDR(mem->dmamem));

			/* Use timer to emulate DMA completion interrupt */
			voice->timerate = (u_int32_t) 48000 * blksize /
			    (voice->sample_rate * sample_size);
			if (voice->timerate < 5) {
#ifdef EMUXKI_DEBUG
				printf("Invalid timerate: %d, blksize %d\n",
				    voice->timerate, blksize);
#endif
				error = EINVAL;
			}
a1500 2

	/* XXX different semantics in these cases */
a1501 1
		/* returns number of samples (an l/r pair counts 1) */
a1505 6
	else
		/* returns number of bytes */
		return (emuxki_read(voice->sc, 0,
		    emuxki_recsrc_idxreg[voice->dataloc.source]) &
		    EMU_RECIDX_MASK);
		
d1519 2
a1520 1
		if ((voice->state & EMU_VOICE_STATE_STARTED) == 0)
a1547 2
	u_int32_t val;

d1555 4
a1558 26
	} else {
		voice->trigblk = 1;
		switch ((int)voice->dataloc.source) {
		case EMU_RECSRC_ADC:
			val = EMU_ADCCR_LCHANENABLE;
			/* XXX need to program DSP to output L+R
			 * XXX in monaural case? */
			if (voice->stereo)
				val |= EMU_ADCCR_RCHANENABLE;
			val |= emuxki_recsrc_rate_to_index(voice->sample_rate);
                        emuxki_write(voice->sc, 0, EMU_ADCCR, 0);
                        emuxki_write(voice->sc, 0, EMU_ADCCR, val);
			break;
		case EMU_RECSRC_MIC:
		case EMU_RECSRC_FX:
			printf("unimplemented\n");
			break;
		}
#if 0
		/* DMA completion interrupt is useless; use timer */
		int s;
		s = splaudio();
                val = emu_rd(sc, INTE, 4);
		val |= emuxki_recsrc_intrmasks[voice->dataloc.source];
                emu_wr(sc, INTE, val, 4);
		splx(s);
a1559 1
	}
d1561 2
a1562 1
	emuxki_resched_timer(voice->sc);
d1572 4
a1575 23
	} else {
		switch (voice->dataloc.source) {
		case EMU_RECSRC_ADC:
                        emuxki_write(voice->sc, 0, EMU_ADCCR, 0);
			break;
		case EMU_RECSRC_FX:
		case EMU_RECSRC_MIC:
			printf("unimplemented\n");
			break;
		case EMU_RECSRC_NOTSET:
			printf("Bad dataloc.source\n");
		}
		/* This should reset buffer pointer */
		emuxki_write(voice->sc, 0,
		    emuxki_recsrc_szreg[voice->dataloc.source],
		    EMU_RECBS_BUFSIZE_NONE);
#if 0
		int s;
		s = splaudio();
                val = emu_rd(sc, INTE, 4);
		val &= ~emuxki_recsrc_intrmasks[voice->dataloc.source];
                emu_wr(sc, INTE, val, 4);
		splx(s);
a1576 1
	}
d1578 2
a1579 1
	emuxki_resched_timer(voice->sc);
d1595 2
a1596 1
				if ((voice->state &
a1601 1
#if 0
a1606 10
#else
				while ((curblk >= voice->trigblk &&
				    curblk < (voice->trigblk + voice->blkmod / 2)) ||
				    ((int)voice->trigblk - (int)curblk) >
				    (voice->blkmod / 2 + 1)) {
					voice->inth(voice->inthparam);
					voice->trigblk++;
					voice->trigblk %= voice->blkmod;
				}
#endif
d1644 2
a1645 8
	if (flags & AUOPEN_READ) {
		sc->rvoice = emuxki_voice_new(sc, 0 /* EMU_VOICE_USE_RECORD */);
		if (sc->rvoice == NULL)
			return (EBUSY);

		/* XXX Hardcode RECSRC_ADC for now */
		sc->rvoice->dataloc.source = EMU_RECSRC_ADC;
	}
a1752 14
	/*
	 * Always use slinear_le for recording, as how to set otherwise
	 * isn't known.
	 */
	if (mode == AUMODE_PLAY)
		b16 = (p->precision == 16);
	else {
		p->encoding = AUDIO_ENCODING_SLINEAR_LE;
		p->precision = 16;
		b16 = 1;
		if (p->precision == 8)
			p->factor *= 2;
	}

d1759 4
a1762 2
		} else
			p->sw_code = slinear16_to_mulaw_le;
d1770 4
a1773 2
		} else
			p->sw_code = slinear16_to_alaw_le;
d1777 3
a1779 6
		if (p->precision == 8) {
			if (mode == AUMODE_PLAY)
				p->sw_code = change_sign8;
			else
				p->sw_code = linear16_to_linear8_le;
		}
d1785 1
a1785 2
		else if (mode == AUMODE_RECORD)
			p->sw_code = slinear16_to_ulinear8_le;
d1791 3
a1793 6
		else {
			if (mode == AUMODE_PLAY)
				p->sw_code = change_sign8;
			else
				p->sw_code = linear16_to_linear8_le;
		}
d1802 2
a1803 2
		} else if (mode == AUMODE_RECORD)
			p->sw_code = slinear16_to_ulinear8_le;
a1941 13
/* blocksize should be a divisor of allowable buffersize */
/* XXX probably this could be done better */
int
emuxki_round_blocksize(void *addr, int blksize)
{
	int bufsize = 65536;

	while (bufsize > blksize)
		bufsize /= 2;

	return bufsize;
}
	
d1945 6
d1966 3
a1968 4
		for(idx = sizeof(emuxki_recbuf_sz) /
		    sizeof(emuxki_recbuf_sz[0]); --idx >= 0; ) {
			if (bsize >= emuxki_recbuf_sz[idx]) {
				bsize = emuxki_recbuf_sz[idx];
d1985 1
d1987 1
d2048 1
@


1.2
log
@add missing RCS ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d440 1
a440 1
	printf(": %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.1
log
@creative labs sb live! and (perhaps) pci512 driver.
from Yannick Montulet, via netbsd, w/ some minor fixens from meself.
@
text
@d1 1
@

