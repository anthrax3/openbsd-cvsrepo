head	1.53;
access;
symbols
	OPENBSD_6_0:1.51.0.8
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.49.0.4
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.44.0.4
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.37.0.4
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.6
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.4
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.53
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.52;
commitid	qGgYgJTgEFuAoGj4;

1.52
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.51;
commitid	pi1a9KN0itEngOc4;

1.51
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.50;
commitid	RaOGL5SyOGOZylwx;

1.50
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.49;
commitid	p4LJxGKbi0BU2cG6;

1.49
date	2014.08.20.06.03.20;	author doug;	state Exp;
branches;
next	1.48;
commitid	IWIdpXwekkLwffve;

1.48
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.47;
commitid	OBNa5kfxQ2UXoiIw;

1.47
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.44;

1.44
date	2012.03.30.08.18.19;	author ratchov;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.22.21.59.59;	author jakemsr;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.20.10.22.25;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2009.02.15.00.11.59;	author jakemsr;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.29.22.41.45;	author jakemsr;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.29.02.10.01;	author jakemsr;	state Exp;
branches;
next	1.32;

1.32
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.31;

1.31
date	2008.03.21.20.11.36;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.12.05.38.23;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.07.22.41.33;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.25.19.53.44;	author niallo;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.25.14.17.55;	author niallo;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.16.21.57.23;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.14.12.42.16;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.17.08.04.45;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.07.03.17.42;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.18.01.24.41;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.14.05.18.48;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.05.19.15.52;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.09.06.18.33.28;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.06.14.47.07;	author naddy;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.16.14.13.13;	author kevlo;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.18.07.03.29;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	99.12.13.06.43.01;	author csapuntz;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.10.10.00.36.46;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	99.10.05.19.24.42;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	99.03.23.08.00.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.01.02.00.02.49;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.03.21.06.39;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	98.10.28.18.06.46;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	98.06.02.23.12.31;	author provos;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.25.39;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.42.01;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2003.05.13.19.35.05;	author ho;	state Exp;
branches;
next	1.8.2.8;

1.8.2.8
date	2003.05.16.00.29.41;	author niklas;	state Exp;
branches;
next	1.8.2.9;

1.8.2.9
date	2004.06.05.23.12.49;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Remove unused getdev() audio driver functions.
@
text
@/*      $OpenBSD: eap.c,v 1.52 2016/09/14 06:12:19 ratchov Exp $ */
/*	$NetBSD: eap.c,v 1.46 2001/09/03 15:07:37 reinoud Exp $ */

/*
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson <augustss@@netbsd.org> and Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Debugging:   Andreas Gustafsson <gson@@araneus.fi>
 * Testing:     Chuck Cranor       <chuck@@maria.wustl.edu>
 *              Phil Nelson        <phil@@cs.wwu.edu>
 *
 * ES1371/AC97:	Ezra Story         <ezy@@panix.com>
 */

/* 
 * Ensoniq ES1370 + AK4531 and ES1371/ES1373 + AC97
 *
 * Documentation links:
 * 
 * ftp://ftp.alsa-project.org/pub/manuals/ensoniq/
 * ftp://ftp.alsa-project.org/pub/manuals/asahi_kasei/4531.pdf
 */

#include "midi.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/fcntl.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>
#include <dev/ic/ac97.h>

#include <machine/bus.h>

#include <dev/pci/eapreg.h>

struct        cfdriver eap_cd = {
      NULL, "eap", DV_DULL
};

#define	PCI_CBIO		0x10

/* Debug */
#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (eapdebug) printf x
#define DPRINTFN(n,x)	if (eapdebug>(n)) printf x
int	eapdebug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

int	eap_match(struct device *, void *, void *);
void	eap_attach(struct device *, struct device *, void *);
int	eap_activate(struct device *, int);
int	eap_intr(void *);

struct eap_dma {
	bus_dmamap_t map;
	caddr_t addr;
	bus_dma_segment_t segs[1];
	int nsegs;
	size_t size;
	struct eap_dma *next;
};

#define DMAADDR(p) ((p)->map->dm_segs[0].ds_addr)
#define KERNADDR(p) ((void *)((p)->addr))

struct eap_softc {
	struct device sc_dev;		/* base device */
	void *sc_ih;			/* interrupt vectoring */
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_dma_tag_t sc_dmatag;	/* DMA tag */

	struct eap_dma *sc_dmas;

	void	(*sc_pintr)(void *);	/* dma completion intr handler */
	void	*sc_parg;		/* arg for sc_intr() */
#ifdef DIAGNOSTIC
	char	sc_prun;
#endif

	void	(*sc_rintr)(void *);	/* dma completion intr handler */
	void	*sc_rarg;		/* arg for sc_intr() */
#ifdef DIAGNOSTIC
	char	sc_rrun;
#endif

#if NMIDI > 0
	void	(*sc_iintr)(void *, int); /* midi input ready handler */
	void	(*sc_ointr)(void *);	/* midi output ready handler */
	void	*sc_arg;
	int	sc_uctrl;
	struct device *sc_mididev;
#endif

	u_short	sc_port[AK_NPORTS];	/* mirror of the hardware setting */
	u_int	sc_record_source;	/* recording source mask */
	u_int	sc_input_source;	/* input source mask */
	u_int	sc_mic_preamp;
	char    sc_1371;		/* Using ES1371/AC97 codec */
	char    sc_ct5880;		/* CT5880 chip */

	struct ac97_codec_if *codec_if;
	struct ac97_host_if host_if;

	int flags;
};

enum	ac97_host_flags eap_flags_codec(void *);
int	eap_allocmem(struct eap_softc *, size_t, size_t, struct eap_dma *);
int	eap_freemem(struct eap_softc *, struct eap_dma *);

#define EWRITE1(sc, r, x) bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x))
#define EWRITE2(sc, r, x) bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x))
#define EWRITE4(sc, r, x) bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x))
#define EREAD1(sc, r) bus_space_read_1((sc)->iot, (sc)->ioh, (r))
#define EREAD2(sc, r) bus_space_read_2((sc)->iot, (sc)->ioh, (r))
#define EREAD4(sc, r) bus_space_read_4((sc)->iot, (sc)->ioh, (r))

struct cfattach eap_ca = {
	sizeof(struct eap_softc), eap_match, eap_attach, NULL, eap_activate
};

int	eap_open(void *, int);
void	eap_close(void *);
int	eap_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	eap_round_blocksize(void *, int);
int	eap_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	eap_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	eap_halt_output(void *);
int	eap_halt_input(void *);
int	eap_resume(struct eap_softc *);
void    eap1370_write_codec(struct eap_softc *, int, int);
int	eap1370_mixer_set_port(void *, mixer_ctrl_t *);
int	eap1370_mixer_get_port(void *, mixer_ctrl_t *);
int	eap1371_mixer_set_port(void *, mixer_ctrl_t *);
int	eap1371_mixer_get_port(void *, mixer_ctrl_t *);
int	eap1370_query_devinfo(void *, mixer_devinfo_t *);
void   *eap_malloc(void *, int, size_t, int, int);
void	eap_free(void *, void *, int);
int	eap_get_props(void *);
void	eap1370_set_mixer(struct eap_softc *sc, int a, int d);
u_int32_t eap1371_src_wait(struct eap_softc *sc);
void	eap1371_src_write(struct eap_softc *sc, int a, int d);
int	eap1371_query_devinfo(void *addr, mixer_devinfo_t *dip);

int     eap1371_attach_codec(void *sc, struct ac97_codec_if *);
int	eap1371_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	eap1371_write_codec(void *sc, u_int8_t a, u_int16_t d);
void    eap1371_reset_codec(void *sc);
#if NMIDI > 0
void	eap_midi_close(void *);
void	eap_midi_getinfo(void *, struct midi_info *);
int	eap_midi_open(void *, int, void (*)(void *, int),
	    void (*)(void *), void *);
int	eap_midi_output(void *, int);
#endif

struct audio_hw_if eap1370_hw_if = {
	eap_open,
	eap_close,
	eap_set_params,
	eap_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	eap_halt_output,
	eap_halt_input,
	NULL,
	NULL,
	eap1370_mixer_set_port,
	eap1370_mixer_get_port,
	eap1370_query_devinfo,
	eap_malloc,
	eap_free,
	NULL,
	eap_get_props,
	eap_trigger_output,
	eap_trigger_input
};

struct audio_hw_if eap1371_hw_if = {
	eap_open,
	eap_close,
	eap_set_params,
	eap_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	eap_halt_output,
	eap_halt_input,
	NULL,
	NULL,
	eap1371_mixer_set_port,
	eap1371_mixer_get_port,
	eap1371_query_devinfo,
	eap_malloc,
	eap_free,
	NULL,
	eap_get_props,
	eap_trigger_output,
	eap_trigger_input
};

#if NMIDI > 0
struct midi_hw_if eap_midi_hw_if = {
	eap_midi_open,
	eap_midi_close,
	eap_midi_output,
	0,				/* flush */
	eap_midi_getinfo,
	0,				/* ioctl */
};
#endif

const struct pci_matchid eap_devices[] = {
	{ PCI_VENDOR_CREATIVELABS, PCI_PRODUCT_CREATIVELABS_EV1938 },
	{ PCI_VENDOR_ENSONIQ, PCI_PRODUCT_ENSONIQ_AUDIOPCI },
	{ PCI_VENDOR_ENSONIQ, PCI_PRODUCT_ENSONIQ_AUDIOPCI97 },
	{ PCI_VENDOR_ENSONIQ, PCI_PRODUCT_ENSONIQ_CT5880 },
};

int
eap_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, eap_devices,
	    nitems(eap_devices)));
}

int
eap_activate(struct device *self, int act)
{
	struct eap_softc *sc = (struct eap_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		eap_resume(sc);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
eap1370_write_codec(struct eap_softc *sc, int a, int d)
{
	int icss, to;

	to = EAP_WRITE_TIMEOUT;
	do {
		icss = EREAD4(sc, EAP_ICSS);
		DPRINTFN(5,("eap: codec %d prog: icss=0x%08x\n", a, icss));
		if (!to--) {
			printf("%s: timeout writing to codec\n",
			    sc->sc_dev.dv_xname);
			return;
		}
	} while (icss & EAP_CWRIP);  /* XXX could use CSTAT here */
	EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));
}

/*
 * Reading and writing the CODEC is very convoluted.  This mimics the
 * FreeBSD and Linux drivers.
 */

static __inline void
eap1371_ready_codec(struct eap_softc *sc, u_int8_t a, u_int32_t wd)
{
	int to;
	u_int32_t src, t;

	for (to = 0; to < EAP_WRITE_TIMEOUT; to++) {
		if (!(EREAD4(sc, E1371_CODEC) & E1371_CODEC_WIP))
			break;
		delay(1);
	}
	if (to == EAP_WRITE_TIMEOUT)
		printf("%s: eap1371_ready_codec timeout 1\n",
		    sc->sc_dev.dv_xname);

	mtx_enter(&audio_lock);
	src = eap1371_src_wait(sc) & E1371_SRC_CTLMASK;
	EWRITE4(sc, E1371_SRC, src | E1371_SRC_STATE_OK);

	for (to = 0; to < EAP_READ_TIMEOUT; to++) {
		t = EREAD4(sc, E1371_SRC);
		if ((t & E1371_SRC_STATE_MASK) == 0)
			break;
		delay(1);
	}
	if (to == EAP_READ_TIMEOUT)
		printf("%s: eap1371_ready_codec timeout 2\n",
		    sc->sc_dev.dv_xname);

	for (to = 0; to < EAP_READ_TIMEOUT; to++) {
		t = EREAD4(sc, E1371_SRC);
		if ((t & E1371_SRC_STATE_MASK) == E1371_SRC_STATE_OK)
			break;
		delay(1);
	}
	if (to == EAP_READ_TIMEOUT)
		printf("%s: eap1371_ready_codec timeout 3\n",
		    sc->sc_dev.dv_xname);

	EWRITE4(sc, E1371_CODEC, wd);

	eap1371_src_wait(sc);
	EWRITE4(sc, E1371_SRC, src);

	mtx_leave(&audio_lock);
}

int
eap1371_read_codec(void *sc_, u_int8_t a, u_int16_t *d)
{
	struct eap_softc *sc = sc_;
	int to;
	u_int32_t t;

	eap1371_ready_codec(sc, a, E1371_SET_CODEC(a, 0) | E1371_CODEC_READ);

	for (to = 0; to < EAP_WRITE_TIMEOUT; to++) {
		if (!(EREAD4(sc, E1371_CODEC) & E1371_CODEC_WIP))
			break;
		delay(1);
	}
	if (to == EAP_WRITE_TIMEOUT)
		printf("%s: eap1371_read_codec timeout 1\n",
		    sc->sc_dev.dv_xname);

	for (to = 0; to < EAP_WRITE_TIMEOUT; to++) {
		t = EREAD4(sc, E1371_CODEC);
		if (t & E1371_CODEC_VALID)
			break;
		delay(1);
	}
	if (to == EAP_WRITE_TIMEOUT)
		printf("%s: eap1371_read_codec timeout 2\n",
		    sc->sc_dev.dv_xname);

	*d = (u_int16_t)t;

	DPRINTFN(10, ("eap1371: reading codec (%x) = %x\n", a, *d));

	return (0);
}

int
eap1371_write_codec(void *sc_, u_int8_t a, u_int16_t d)
{
	struct eap_softc *sc = sc_;

	eap1371_ready_codec(sc, a, E1371_SET_CODEC(a, d));

        DPRINTFN(10, ("eap1371: writing codec %x --> %x\n", d, a));

	return (0);
}

u_int32_t
eap1371_src_wait(struct eap_softc *sc)
{
	int to;
	u_int32_t src = 0;
	
	for (to = 0; to < EAP_READ_TIMEOUT; to++) {
		src = EREAD4(sc, E1371_SRC);
		if (!(src & E1371_SRC_RBUSY))
			return (src);
		delay(1);
	}
	printf("%s: eap1371_src_wait timeout\n", sc->sc_dev.dv_xname);
	return (src);
}

void
eap1371_src_write(struct eap_softc *sc, int a, int d)
{
	u_int32_t r;

	r = eap1371_src_wait(sc) & E1371_SRC_CTLMASK;
	r |= E1371_SRC_RAMWE | E1371_SRC_ADDR(a) | E1371_SRC_DATA(d);
	EWRITE4(sc, E1371_SRC, r);
}
	
void
eap_attach(struct device *parent, struct device *self, void *aux)
{
	struct eap_softc *sc = (struct eap_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	struct audio_hw_if *eap_hw_if;
	char const *intrstr;
	pci_intr_handle_t ih;
	mixer_ctrl_t ctl;
	int i;
	int revision;

	/* Flag if we're "creative" */
	sc->sc_1371 = !(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ENSONIQ &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI);

	revision = PCI_REVISION(pa->pa_class);
	if (sc->sc_1371) {
		if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ENSONIQ &&
		    ((PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI97 &&
		    (revision == EAP_ES1373_8 || revision == EAP_CT5880_A)) ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880))
			sc->sc_ct5880 = 1;
	}

	/* Map I/O register */
	if (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->iot, &sc->ioh, NULL, NULL, 0)) {
		return;
	}

	sc->sc_dmatag = pa->pa_dmat;

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    eap_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

	if (!sc->sc_1371) {
		/* Enable interrupts and looping mode. */
		/* enable the parts we need */
		EWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);
		EWRITE4(sc, EAP_ICSC, EAP_CDC_EN);

		/* reset codec */
		/* normal operation */
		/* select codec clocks */
		eap1370_write_codec(sc, AK_RESET, AK_PD);
		eap1370_write_codec(sc, AK_RESET, AK_PD | AK_NRST);
		eap1370_write_codec(sc, AK_CS, 0x0);

		eap_hw_if = &eap1370_hw_if;

		/* Enable all relevant mixer switches. */
		ctl.dev = EAP_INPUT_SOURCE;
		ctl.type = AUDIO_MIXER_SET;
		ctl.un.mask = 1 << EAP_VOICE_VOL | 1 << EAP_FM_VOL |
		    1 << EAP_CD_VOL | 1 << EAP_LINE_VOL | 1 << EAP_AUX_VOL |
		    1 << EAP_MIC_VOL;
		eap_hw_if->set_port(sc, &ctl);

		ctl.type = AUDIO_MIXER_VALUE;
		ctl.un.value.num_channels = 1;
		for (ctl.dev = EAP_MASTER_VOL; ctl.dev < EAP_MIC_VOL;
		     ctl.dev++) {
			ctl.un.value.level[AUDIO_MIXER_LEVEL_MONO] = VOL_0DB;
			eap_hw_if->set_port(sc, &ctl);
		}
		ctl.un.value.level[AUDIO_MIXER_LEVEL_MONO] = 0;
		eap_hw_if->set_port(sc, &ctl);
		ctl.dev = EAP_MIC_PREAMP;
		ctl.type = AUDIO_MIXER_ENUM;
		ctl.un.ord = 0;
		eap_hw_if->set_port(sc, &ctl);
		ctl.dev = EAP_RECORD_SOURCE;
		ctl.type = AUDIO_MIXER_SET;
		ctl.un.mask = 1 << EAP_MIC_VOL;
		eap_hw_if->set_port(sc, &ctl);
	} else {
		/* clean slate */

                EWRITE4(sc, EAP_SIC, 0);
		EWRITE4(sc, EAP_ICSC, 0);
		EWRITE4(sc, E1371_LEGACY, 0);

		if (sc->sc_ct5880) {
			EWRITE4(sc, EAP_ICSS, EAP_CT5880_AC97_RESET);
			/* Let codec wake up */
			delay(20000);
		}

                /* Reset from es1371's perspective */
                EWRITE4(sc, EAP_ICSC, E1371_SYNC_RES);
                delay(20);
                EWRITE4(sc, EAP_ICSC, 0);

		/*
		 * Must properly reprogram sample rate converter,
		 * or it locks up.
		 *
		 * We don't know how to program it (no documentation),
		 * and the linux/oss magic receipe doesn't work (breaks
		 * full-duplex, by selecting different play and record
		 * rates). On the other hand, the sample rate converter
		 * can't be disabled (disabling it would disable DMA),
		 * so we use these magic defaults that make it "resample"
		 * 48kHz to 48kHz without breaking full-duplex.
		 */
		EWRITE4(sc, E1371_SRC, E1371_SRC_DISABLE);
		for (i = 0; i < 0x80; i++)
			eap1371_src_write(sc, i, 0);
		eap1371_src_write(sc, ESRC_ADC + ESRC_TRUNC_N, ESRC_SET_N(16));
		eap1371_src_write(sc, ESRC_ADC + ESRC_IREGS, ESRC_SET_VFI(16));
		eap1371_src_write(sc, ESRC_ADC + ESRC_VFF, 0);
		eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(16));
		eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(16));
		eap1371_src_write(sc, ESRC_DAC1 + ESRC_TRUNC_N, ESRC_SET_N(16));
		eap1371_src_write(sc, ESRC_DAC1 + ESRC_IREGS, ESRC_SET_VFI(16));
		eap1371_src_write(sc, ESRC_DAC1 + ESRC_VFF, 0);
		eap1371_src_write(sc, ESRC_DAC1_VOLL, ESRC_SET_DAC_VOLI(1));
		eap1371_src_write(sc, ESRC_DAC1_VOLR, ESRC_SET_DAC_VOLI(1));
		eap1371_src_write(sc, ESRC_DAC2 + ESRC_IREGS, ESRC_SET_VFI(16));
		eap1371_src_write(sc, ESRC_DAC2 + ESRC_TRUNC_N, ESRC_SET_N(16));
		eap1371_src_write(sc, ESRC_DAC2 + ESRC_VFF, 0);
		eap1371_src_write(sc, ESRC_DAC2_VOLL, ESRC_SET_DAC_VOLI(1));
		eap1371_src_write(sc, ESRC_DAC2_VOLR, ESRC_SET_DAC_VOLI(1));
		EWRITE4(sc, E1371_SRC, 0);

		/* Reset codec */

		/* Interrupt enable */
		sc->host_if.arg = sc;
		sc->host_if.attach = eap1371_attach_codec;
		sc->host_if.read = eap1371_read_codec;
		sc->host_if.write = eap1371_write_codec;
		sc->host_if.reset = eap1371_reset_codec;
		sc->host_if.flags = eap_flags_codec;
		sc->flags = AC97_HOST_DONT_READ;
	
		if (ac97_attach(&sc->host_if) == 0) {
			/* Interrupt enable */
			EWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);
		} else
			return;

		eap_hw_if = &eap1371_hw_if;
	}

	audio_attach_mi(eap_hw_if, sc, &sc->sc_dev);
#if NMIDI > 0
	sc->sc_mididev = midi_attach_mi(&eap_midi_hw_if, sc, &sc->sc_dev);
#endif
}

int
eap_resume(struct eap_softc *sc)
{
	mixer_ctrl_t ctl;
	int i;

	if (!sc->sc_1371) {
		/* Enable interrupts and looping mode. */
		/* enable the parts we need */
		EWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);
		EWRITE4(sc, EAP_ICSC, EAP_CDC_EN);

		/* reset codec */
		/* normal operation */
		/* select codec clocks */
		eap1370_write_codec(sc, AK_RESET, AK_PD);
		eap1370_write_codec(sc, AK_RESET, AK_PD | AK_NRST);
		eap1370_write_codec(sc, AK_CS, 0x0);

		bzero(&ctl, sizeof(ctl));

		ctl.dev = EAP_RECORD_SOURCE;
		ctl.type = AUDIO_MIXER_SET;
		ctl.un.mask = sc->sc_record_source;
		eap1370_hw_if.set_port(sc, &ctl);

		ctl.dev = EAP_INPUT_SOURCE;
		ctl.type = AUDIO_MIXER_SET;
		ctl.un.mask = sc->sc_input_source;
		eap1370_hw_if.set_port(sc, &ctl);

		eap1370_set_mixer(sc, AK_MGAIN, sc->sc_mic_preamp);

		for (i = EAP_MASTER_VOL; i < EAP_MIC_VOL; i++)
			eap1370_write_codec(sc, i, sc->sc_port[i]);

	} else {
		/* clean slate */

		EWRITE4(sc, EAP_SIC, 0);
		EWRITE4(sc, EAP_ICSC, 0);
		EWRITE4(sc, E1371_LEGACY, 0);

		if (sc->sc_ct5880) {
			EWRITE4(sc, EAP_ICSS, EAP_CT5880_AC97_RESET);
			/* Let codec wake up */
			delay(20000);
		}

		ac97_resume(&sc->host_if, sc->codec_if);

		EWRITE4(sc, E1371_SRC, E1371_SRC_DISABLE);
		for (i = 0; i < 0x80; i++)
			eap1371_src_write(sc, i, 0);
		eap1371_src_write(sc, ESRC_ADC + ESRC_TRUNC_N, ESRC_SET_N(16));
		eap1371_src_write(sc, ESRC_ADC + ESRC_IREGS, ESRC_SET_VFI(16));
		eap1371_src_write(sc, ESRC_ADC + ESRC_VFF, 0);
		eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(16));
		eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(16));
		eap1371_src_write(sc, ESRC_DAC1 + ESRC_TRUNC_N, ESRC_SET_N(16));
		eap1371_src_write(sc, ESRC_DAC1 + ESRC_IREGS, ESRC_SET_VFI(16));
		eap1371_src_write(sc, ESRC_DAC1 + ESRC_VFF, 0);
		eap1371_src_write(sc, ESRC_DAC1_VOLL, ESRC_SET_DAC_VOLI(1));
		eap1371_src_write(sc, ESRC_DAC1_VOLR, ESRC_SET_DAC_VOLI(1));
		eap1371_src_write(sc, ESRC_DAC2 + ESRC_IREGS, ESRC_SET_VFI(16));
		eap1371_src_write(sc, ESRC_DAC2 + ESRC_TRUNC_N, ESRC_SET_N(16));
		eap1371_src_write(sc, ESRC_DAC2 + ESRC_VFF, 0);
		eap1371_src_write(sc, ESRC_DAC2_VOLL, ESRC_SET_DAC_VOLI(1));
		eap1371_src_write(sc, ESRC_DAC2_VOLR, ESRC_SET_DAC_VOLI(1));
		EWRITE4(sc, E1371_SRC, 0);

		/* Interrupt enable */
		EWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);
	}

	return (0);
}


int
eap1371_attach_codec(void *sc_, struct ac97_codec_if *codec_if)
{
	struct eap_softc *sc = sc_;
	
	sc->codec_if = codec_if;
	return (0);
}

void
eap1371_reset_codec(void *sc_)
{
	struct eap_softc *sc = sc_;
	u_int32_t icsc;

	mtx_enter(&audio_lock);
	icsc = EREAD4(sc, EAP_ICSC);
	EWRITE4(sc, EAP_ICSC, icsc | E1371_SYNC_RES);
	delay(20);
	EWRITE4(sc, EAP_ICSC, icsc & ~E1371_SYNC_RES);
	delay(1);
	mtx_leave(&audio_lock);

	return;
}

int
eap_intr(void *p)
{
	struct eap_softc *sc = p;
	u_int32_t intr, sic;

	mtx_enter(&audio_lock);
	intr = EREAD4(sc, EAP_ICSS);
	if (!(intr & EAP_INTR)) {
		mtx_leave(&audio_lock);
		return (0);
	}
	sic = EREAD4(sc, EAP_SIC);
	DPRINTFN(5, ("eap_intr: ICSS=0x%08x, SIC=0x%08x\n", intr, sic));
	if (intr & EAP_I_ADC) {
#if 0
		/*
		 * XXX This is a hack!
		 * The EAP chip sometimes generates the recording interrupt
		 * while it is still transferring the data.  To make sure
		 * it has all arrived we busy wait until the count is right.
		 * The transfer we are waiting for is 8 longwords.
		 */
		int s, nw, n;

		EWRITE4(sc, EAP_MEMPAGE, EAP_ADC_PAGE);
		s = EREAD4(sc, EAP_ADC_CSR);
		nw = ((s & 0xffff) + 1) >> 2; /* # of words in DMA */
		n = 0;
		while (((EREAD4(sc, EAP_ADC_SIZE) >> 16) + 8) % nw == 0) {
			delay(10);
			if (++n > 100) {
				printf("eapintr: dma fix timeout");
				break;
			}
		}
		/* Continue with normal interrupt handling. */
#endif
		EWRITE4(sc, EAP_SIC, sic & ~EAP_R1_INTR_EN);
		EWRITE4(sc, EAP_SIC, sic | EAP_R1_INTR_EN);
		if (sc->sc_rintr)
			sc->sc_rintr(sc->sc_rarg);
	}
	if (intr & EAP_I_DAC2) {
		EWRITE4(sc, EAP_SIC, sic & ~EAP_P2_INTR_EN);
		EWRITE4(sc, EAP_SIC, sic | EAP_P2_INTR_EN);
		if (sc->sc_pintr)
			sc->sc_pintr(sc->sc_parg);
	}
#if NMIDI > 0
	if (intr & EAP_I_UART) {
		u_int32_t data;

		if (EREAD1(sc, EAP_UART_STATUS) & EAP_US_RXINT) {
			while (EREAD1(sc, EAP_UART_STATUS) & EAP_US_RXRDY) {
				data = EREAD1(sc, EAP_UART_DATA);
				if (sc->sc_iintr)
					sc->sc_iintr(sc->sc_arg, data);
			}
		}
		if (EREAD1(sc, EAP_UART_STATUS) & EAP_US_TXINT) {
			sc->sc_uctrl &= ~EAP_UC_TXINTEN;
			EWRITE1(sc, EAP_UART_CONTROL, sc->sc_uctrl);
			if (sc->sc_ointr) 
				sc->sc_ointr(sc->sc_arg);
		}
	}
#endif
	mtx_leave(&audio_lock);
	return (1);
}

int
eap_allocmem(struct eap_softc *sc, size_t size, size_t align, struct eap_dma *p)
{
	int error;

	p->size = size;
	error = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,
	    p->segs, nitems(p->segs),
	    &p->nsegs, BUS_DMA_NOWAIT);
	if (error)
		return (error);

	error = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size,
	    &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (error)
		goto free;

	error = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,
	    0, BUS_DMA_NOWAIT, &p->map);
	if (error)
		goto unmap;

	error = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL,
	    BUS_DMA_NOWAIT);
	if (error)
		goto destroy;
	return (0);

destroy:
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
unmap:
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
free:
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return (error);
}

int
eap_freemem(struct eap_softc *sc, struct eap_dma *p)
{
	bus_dmamap_unload(sc->sc_dmatag, p->map);
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return (0);
}

int
eap_open(void *addr, int flags)
{
	return (0);
}

/*
 * Close function is called at splaudio().
 */
void
eap_close(void *addr)
{
	struct eap_softc *sc = addr;
    
	eap_halt_output(sc);
	eap_halt_input(sc);

	sc->sc_pintr = 0;
	sc->sc_rintr = 0;
}

int
eap_set_params(void *addr, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct eap_softc *sc = addr;
	struct audio_params *p;
	int mode;
	u_int32_t div;

	/*
	 * The es1370 only has one clock, so make the sample rates match.
	 */
	if (!sc->sc_1371) {
		if (play->sample_rate != rec->sample_rate &&
		    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {
			if (setmode == AUMODE_PLAY) {
				rec->sample_rate = play->sample_rate;
				setmode |= AUMODE_RECORD;
			} else if (setmode == AUMODE_RECORD) {
				play->sample_rate = rec->sample_rate;
				setmode |= AUMODE_PLAY;
			} else
				return (EINVAL);
		}
	}

	for (mode = AUMODE_RECORD; mode != -1;
	    mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = mode == AUMODE_PLAY ? play : rec;

		if (sc->sc_1371)
			p->sample_rate = 48000;
		if (p->sample_rate < 4000)
			p->sample_rate = 4000;
		if (p->sample_rate > 48000)
			p->sample_rate = 48000;
		if (p->precision > 16)
			p->precision = 16;
		if (p->channels > 2)
			p->channels = 2;
		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			if (p->precision != 16)
				return EINVAL;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 8)
				return EINVAL;
		default:
			return (EINVAL);
		}
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
	}

	if (!sc->sc_1371) {
		/* Set the speed */
		DPRINTFN(2, ("eap_set_params: old ICSC = 0x%08x\n",
		    EREAD4(sc, EAP_ICSC)));
		div = EREAD4(sc, EAP_ICSC) & ~EAP_PCLKBITS;
		/*
		 * XXX
		 * The -2 isn't documented, but seemed to make the wall
		 * time match
		 * what I expect.  - mycroft
		 */
		if (usemode == AUMODE_RECORD)
			div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ /
			    rec->sample_rate - 2);
		else
			div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ /
			    play->sample_rate - 2);
		div |= EAP_CCB_INTRM;
		EWRITE4(sc, EAP_ICSC, div);
		DPRINTFN(2, ("eap_set_params: set ICSC = 0x%08x\n", div));
	}

	return (0);
}

int
eap_round_blocksize(void *addr, int blk)
{
	return ((blk + 31) & -32);	/* keep good alignment */
}

int
eap_trigger_output(
	void *addr,
	void *start,
	void *end,
	int blksize,
	void (*intr)(void *),
	void *arg,
	struct audio_params *param)
{
	struct eap_softc *sc = addr;
	struct eap_dma *p;
	u_int32_t icsc, sic;
	int sampshift;

#ifdef DIAGNOSTIC
	if (sc->sc_prun)
		panic("eap_trigger_output: already running");
	sc->sc_prun = 1;
#endif

	DPRINTFN(1, ("eap_trigger_output: sc=%p start=%p end=%p "
	    "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));
	sc->sc_pintr = intr;
	sc->sc_parg = arg;
	mtx_enter(&audio_lock);
	sic = EREAD4(sc, EAP_SIC);
	sic &= ~(EAP_P2_S_EB | EAP_P2_S_MB | EAP_INC_BITS);
	sic |= EAP_SET_P2_ST_INC(0) | EAP_SET_P2_END_INC(param->precision / 8);
	sampshift = 0;
	if (param->precision == 16) {
		sic |= EAP_P2_S_EB;
		sampshift++;
	}
	if (param->channels == 2) {
		sic |= EAP_P2_S_MB;
		sampshift++;
	}
	EWRITE4(sc, EAP_SIC, sic & ~EAP_P2_INTR_EN);
	EWRITE4(sc, EAP_SIC, sic | EAP_P2_INTR_EN);

	for (p = sc->sc_dmas; p && KERNADDR(p) != start; p = p->next)
		;
	if (!p) {
		mtx_leave(&audio_lock);
		printf("eap_trigger_output: bad addr %p\n", start);
		return (EINVAL);
	}

	DPRINTF(("eap_trigger_output: DAC2_ADDR=0x%x, DAC2_SIZE=0x%x\n",
	    (int)DMAADDR(p),
	    (int)EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));
	EWRITE4(sc, EAP_MEMPAGE, EAP_DAC_PAGE);
	EWRITE4(sc, EAP_DAC2_ADDR, DMAADDR(p));
	EWRITE4(sc, EAP_DAC2_SIZE,
	    EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1));

	EWRITE4(sc, EAP_DAC2_CSR, (blksize >> sampshift) - 1);

	if (sc->sc_1371)
		EWRITE4(sc, E1371_SRC, 0);

	icsc = EREAD4(sc, EAP_ICSC);
	EWRITE4(sc, EAP_ICSC, icsc | EAP_DAC2_EN);

	DPRINTFN(1, ("eap_trigger_output: set ICSC = 0x%08x\n", icsc));
	mtx_leave(&audio_lock);
	return (0);
}

int
eap_trigger_input(
	void *addr,
	void *start,
	void *end,
	int blksize,
	void (*intr)(void *),
	void *arg,
	struct audio_params *param)
{
	struct eap_softc *sc = addr;
	struct eap_dma *p;
	u_int32_t icsc, sic;
	int sampshift;

#ifdef DIAGNOSTIC
	if (sc->sc_rrun)
		panic("eap_trigger_input: already running");
	sc->sc_rrun = 1;
#endif

	DPRINTFN(1, ("eap_trigger_input: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\n",
	    addr, start, end, blksize, intr, arg));
	sc->sc_rintr = intr;
	sc->sc_rarg = arg;
	mtx_enter(&audio_lock);
	sic = EREAD4(sc, EAP_SIC);
	sic &= ~(EAP_R1_S_EB | EAP_R1_S_MB);
	sampshift = 0;
	if (param->precision == 16) {
		sic |= EAP_R1_S_EB;
		sampshift++;
	}
	if (param->channels == 2) {
		sic |= EAP_R1_S_MB;
		sampshift++;
	}
	EWRITE4(sc, EAP_SIC, sic & ~EAP_R1_INTR_EN);
	EWRITE4(sc, EAP_SIC, sic | EAP_R1_INTR_EN);

	for (p = sc->sc_dmas; p && KERNADDR(p) != start; p = p->next)
		;
	if (!p) {
		mtx_leave(&audio_lock);
		printf("eap_trigger_input: bad addr %p\n", start);
		return (EINVAL);
	}

	DPRINTF(("eap_trigger_input: ADC_ADDR=0x%x, ADC_SIZE=0x%x\n",
	    (int)DMAADDR(p),
	    (int)EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));
	EWRITE4(sc, EAP_MEMPAGE, EAP_ADC_PAGE);
	EWRITE4(sc, EAP_ADC_ADDR, DMAADDR(p));
	EWRITE4(sc, EAP_ADC_SIZE,
	    EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1));

	EWRITE4(sc, EAP_ADC_CSR, (blksize >> sampshift) - 1);

	if (sc->sc_1371)
		EWRITE4(sc, E1371_SRC, 0);

	icsc = EREAD4(sc, EAP_ICSC);
	EWRITE4(sc, EAP_ICSC, icsc | EAP_ADC_EN);

	DPRINTFN(1, ("eap_trigger_input: set ICSC = 0x%08x\n", icsc));
	mtx_leave(&audio_lock);
	return (0);
}

int
eap_halt_output(void *addr)
{
	struct eap_softc *sc = addr;
	u_int32_t icsc;
	
	DPRINTF(("eap: eap_halt_output\n"));
	mtx_enter(&audio_lock);
	icsc = EREAD4(sc, EAP_ICSC);
	EWRITE4(sc, EAP_ICSC, icsc & ~EAP_DAC2_EN);
#ifdef DIAGNOSTIC
	sc->sc_prun = 0;
#endif
	mtx_leave(&audio_lock);
	return (0);
}

int
eap_halt_input(void *addr)
{
	struct eap_softc *sc = addr;
	u_int32_t icsc;
    
	DPRINTF(("eap: eap_halt_input\n"));
	mtx_enter(&audio_lock);
	icsc = EREAD4(sc, EAP_ICSC);
	EWRITE4(sc, EAP_ICSC, icsc & ~EAP_ADC_EN);
#ifdef DIAGNOSTIC
	sc->sc_rrun = 0;
#endif
	mtx_leave(&audio_lock);
	return (0);
}

int
eap1371_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct eap_softc *sc = addr;

	return (sc->codec_if->vtbl->mixer_set_port(sc->codec_if, cp));
}

int
eap1371_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct eap_softc *sc = addr;

	return (sc->codec_if->vtbl->mixer_get_port(sc->codec_if, cp));
}

int
eap1371_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct eap_softc *sc = addr;

	return (sc->codec_if->vtbl->query_devinfo(sc->codec_if, dip));
}

void
eap1370_set_mixer(struct eap_softc *sc, int a, int d)
{
	eap1370_write_codec(sc, a, d);

	sc->sc_port[a] = d;
	DPRINTFN(1, ("eap1370_mixer_set_port port 0x%02x = 0x%02x\n", a, d));
}

int
eap1370_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct eap_softc *sc = addr;
	int lval, rval, l, r, la, ra;
	int l1, r1, l2, r2, m, o1, o2;

	if (cp->dev == EAP_RECORD_SOURCE) {
		if (cp->type != AUDIO_MIXER_SET)
			return (EINVAL);
		m = sc->sc_record_source = cp->un.mask;
		l1 = l2 = r1 = r2 = 0;
		if (m & (1 << EAP_VOICE_VOL))
			l2 |= AK_M_VOICE, r2 |= AK_M_VOICE;
		if (m & (1 << EAP_FM_VOL))
			l1 |= AK_M_FM_L, r1 |= AK_M_FM_R;
		if (m & (1 << EAP_CD_VOL))
			l1 |= AK_M_CD_L, r1 |= AK_M_CD_R;
		if (m & (1 << EAP_LINE_VOL))
			l1 |= AK_M_LINE_L, r1 |= AK_M_LINE_R;
		if (m & (1 << EAP_AUX_VOL))
			l2 |= AK_M2_AUX_L, r2 |= AK_M2_AUX_R;
		if (m & (1 << EAP_MIC_VOL))
			l2 |= AK_M_TMIC, r2 |= AK_M_TMIC;
		eap1370_set_mixer(sc, AK_IN_MIXER1_L, l1);
		eap1370_set_mixer(sc, AK_IN_MIXER1_R, r1);
		eap1370_set_mixer(sc, AK_IN_MIXER2_L, l2);
		eap1370_set_mixer(sc, AK_IN_MIXER2_R, r2);
		return (0);
	}
	if (cp->dev == EAP_INPUT_SOURCE) {
		if (cp->type != AUDIO_MIXER_SET)
			return (EINVAL);
		m = sc->sc_input_source = cp->un.mask;
		o1 = o2 = 0;
		if (m & (1 << EAP_VOICE_VOL))
			o2 |= AK_M_VOICE_L | AK_M_VOICE_R;
		if (m & (1 << EAP_FM_VOL))
			o1 |= AK_M_FM_L | AK_M_FM_R;
		if (m & (1 << EAP_CD_VOL))
			o1 |= AK_M_CD_L | AK_M_CD_R;
		if (m & (1 << EAP_LINE_VOL))
			o1 |= AK_M_LINE_L | AK_M_LINE_R;
		if (m & (1 << EAP_AUX_VOL))
			o2 |= AK_M_AUX_L | AK_M_AUX_R;
		if (m & (1 << EAP_MIC_VOL))
			o1 |= AK_M_MIC;
		eap1370_set_mixer(sc, AK_OUT_MIXER1, o1);
		eap1370_set_mixer(sc, AK_OUT_MIXER2, o2);
		return (0);
	}
	if (cp->dev == EAP_MIC_PREAMP) {
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		if (cp->un.ord != 0 && cp->un.ord != 1)
			return (EINVAL);
		sc->sc_mic_preamp = cp->un.ord;
		eap1370_set_mixer(sc, AK_MGAIN, cp->un.ord);
		return (0);
	}
	if (cp->type != AUDIO_MIXER_VALUE)
		return (EINVAL);
	if (cp->un.value.num_channels == 1)
		lval = rval = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
	else if (cp->un.value.num_channels == 2) {
		lval = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
		rval = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
	} else
		return (EINVAL);
	ra = -1;
	switch (cp->dev) {
	case EAP_MASTER_VOL:
		l = VOL_TO_ATT5(lval);
		r = VOL_TO_ATT5(rval);
		la = AK_MASTER_L;
		ra = AK_MASTER_R;
		break;
	case EAP_MIC_VOL:
		if (cp->un.value.num_channels != 1)
			return (EINVAL);
		la = AK_MIC;
		goto lr;
	case EAP_VOICE_VOL:
		la = AK_VOICE_L;
		ra = AK_VOICE_R;
		goto lr;
	case EAP_FM_VOL:
		la = AK_FM_L;
		ra = AK_FM_R;
		goto lr;
	case EAP_CD_VOL:
		la = AK_CD_L;
		ra = AK_CD_R;
		goto lr;
	case EAP_LINE_VOL:
		la = AK_LINE_L;
		ra = AK_LINE_R;
		goto lr;
	case EAP_AUX_VOL:
		la = AK_AUX_L;
		ra = AK_AUX_R;
	lr:
		l = VOL_TO_GAIN5(lval);
		r = VOL_TO_GAIN5(rval);
		break;
	default:
		return (EINVAL);
	}
	eap1370_set_mixer(sc, la, l);
	if (ra >= 0) {
		eap1370_set_mixer(sc, ra, r);
	}
	return (0);
}

int
eap1370_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct eap_softc *sc = addr;
	int la, ra, l, r;

	switch (cp->dev) {
	case EAP_RECORD_SOURCE:
		if (cp->type != AUDIO_MIXER_SET)
			return (EINVAL);
		cp->un.mask = sc->sc_record_source;
		return (0);
	case EAP_INPUT_SOURCE:
		if (cp->type != AUDIO_MIXER_SET)
			return (EINVAL);
		cp->un.mask = sc->sc_input_source;
		return (0);
	case EAP_MIC_PREAMP:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		cp->un.ord = sc->sc_mic_preamp;
		return (0);
	case EAP_MASTER_VOL:
		l = ATT5_TO_VOL(sc->sc_port[AK_MASTER_L]);
		r = ATT5_TO_VOL(sc->sc_port[AK_MASTER_R]);
		break;
	case EAP_MIC_VOL:
		if (cp->un.value.num_channels != 1)
			return (EINVAL);
		la = ra = AK_MIC;
		goto lr;
	case EAP_VOICE_VOL:
		la = AK_VOICE_L;
		ra = AK_VOICE_R;
		goto lr;
	case EAP_FM_VOL:
		la = AK_FM_L;
		ra = AK_FM_R;
		goto lr;
	case EAP_CD_VOL:
		la = AK_CD_L;
		ra = AK_CD_R;
		goto lr;
	case EAP_LINE_VOL:
		la = AK_LINE_L;
		ra = AK_LINE_R;
		goto lr;
	case EAP_AUX_VOL:
		la = AK_AUX_L;
		ra = AK_AUX_R;
	lr:
		l = GAIN5_TO_VOL(sc->sc_port[la]);
		r = GAIN5_TO_VOL(sc->sc_port[ra]);
		break;
	default:
		return (EINVAL);
	}
	if (cp->un.value.num_channels == 1)
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r) / 2;
	else if (cp->un.value.num_channels == 2) {
		cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]  = l;
		cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;
	} else
		return (EINVAL);
	return (0);
}

int
eap1370_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	switch (dip->index) {
	case EAP_MASTER_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = EAP_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);
	case EAP_VOICE_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = EAP_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);
	case EAP_FM_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = EAP_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);
	case EAP_CD_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = EAP_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);
	case EAP_LINE_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = EAP_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);
	case EAP_AUX_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = EAP_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNaux, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);
	case EAP_MIC_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = EAP_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = EAP_MIC_PREAMP;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);
	case EAP_RECORD_SOURCE:
		dip->mixer_class = EAP_RECORD_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_SET;
		dip->un.s.num_mem = 6;
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[0].label.name);
		dip->un.s.member[0].mask = 1 << EAP_MIC_VOL;
		strlcpy(dip->un.s.member[1].label.name, AudioNcd,
		    sizeof dip->un.s.member[1].label.name);
		dip->un.s.member[1].mask = 1 << EAP_CD_VOL;
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
		dip->un.s.member[2].mask = 1 << EAP_LINE_VOL;
		strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
		    sizeof dip->un.s.member[3].label.name);
		dip->un.s.member[3].mask = 1 << EAP_FM_VOL;
		strlcpy(dip->un.s.member[4].label.name, AudioNaux,
		    sizeof dip->un.s.member[4].label.name);
		dip->un.s.member[4].mask = 1 << EAP_AUX_VOL;
		strlcpy(dip->un.s.member[5].label.name, AudioNdac,
		    sizeof dip->un.s.member[5].label.name);
		dip->un.s.member[5].mask = 1 << EAP_VOICE_VOL;
		return (0);
	case EAP_INPUT_SOURCE:
		dip->mixer_class = EAP_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_SET;
		dip->un.s.num_mem = 6;
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[0].label.name);
		dip->un.s.member[0].mask = 1 << EAP_MIC_VOL;
		strlcpy(dip->un.s.member[1].label.name, AudioNcd,
		    sizeof dip->un.s.member[1].label.name);
		dip->un.s.member[1].mask = 1 << EAP_CD_VOL;
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
		dip->un.s.member[2].mask = 1 << EAP_LINE_VOL;
		strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
		    sizeof dip->un.s.member[3].label.name);
		dip->un.s.member[3].mask = 1 << EAP_FM_VOL;
		strlcpy(dip->un.s.member[4].label.name, AudioNaux,
		    sizeof dip->un.s.member[4].label.name);
		dip->un.s.member[4].mask = 1 << EAP_AUX_VOL;
		strlcpy(dip->un.s.member[5].label.name, AudioNdac,
		    sizeof dip->un.s.member[5].label.name);
		dip->un.s.member[5].mask = 1 << EAP_VOICE_VOL;
		return (0);
	case EAP_MIC_PREAMP:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = EAP_INPUT_CLASS;
		dip->prev = EAP_MIC_VOL;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		return (0);
	case EAP_OUTPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = EAP_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof dip->label.name);
		return (0);
	case EAP_RECORD_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = EAP_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
		return (0);
	case EAP_INPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = EAP_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
		return (0);
	}
	return (ENXIO);
}

void *
eap_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct eap_softc *sc = addr;
	struct eap_dma *p;
	int error;

	p = malloc(sizeof(*p), pool, flags);
	if (!p)
		return (0);
	error = eap_allocmem(sc, size, 16, p);
	if (error) {
		free(p, pool, 0);
		return (0);
	}
	p->next = sc->sc_dmas;
	sc->sc_dmas = p;
	return (KERNADDR(p));
}

void
eap_free(void *addr, void *ptr, int pool)
{
	struct eap_softc *sc = addr;
	struct eap_dma **pp, *p;

	for (pp = &sc->sc_dmas; (p = *pp) != NULL; pp = &p->next) {
		if (KERNADDR(p) == ptr) {
			eap_freemem(sc, p);
			*pp = p->next;
			free(p, pool, 0);
			return;
		}
	}
}

int
eap_get_props(void *addr)
{
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT |
	    AUDIO_PROP_FULLDUPLEX);
}

enum ac97_host_flags
eap_flags_codec(void *v)
{
      struct eap_softc *sc = v;

      return (sc->flags);
}
#if NMIDI > 0
int
eap_midi_open(void *addr, int flags,
    void (*iintr)(void *, int),
    void (*ointr)(void *),
    void *arg)
{
	struct eap_softc *sc = addr;

	sc->sc_iintr = iintr;
	sc->sc_ointr = ointr;
	sc->sc_arg = arg;

	EWRITE4(sc, EAP_ICSC, EREAD4(sc, EAP_ICSC) | EAP_UART_EN);
	sc->sc_uctrl = 0;
	if (flags & FREAD)
		sc->sc_uctrl |= EAP_UC_RXINTEN;
	EWRITE1(sc, EAP_UART_CONTROL, sc->sc_uctrl);

	return (0);
}

void
eap_midi_close(void *addr)
{
	struct eap_softc *sc = addr;

	tsleep(sc, PWAIT, "eapclm", hz/10); /* give uart a chance to drain */
	EWRITE1(sc, EAP_UART_CONTROL, 0);
	EWRITE4(sc, EAP_ICSC, EREAD4(sc, EAP_ICSC) & ~EAP_UART_EN);

	sc->sc_iintr = 0;
	sc->sc_ointr = 0;
}

int
eap_midi_output(void *addr, int d)
{
	struct eap_softc *sc = addr;

	if (!(EREAD1(sc, EAP_UART_STATUS) & EAP_US_TXRDY))
		return 0;
	EWRITE1(sc, EAP_UART_DATA, d);
	sc->sc_uctrl |= EAP_UC_TXINTEN;
	EWRITE1(sc, EAP_UART_CONTROL, sc->sc_uctrl);
	return 1;
}

void
eap_midi_getinfo(void *addr, struct midi_info *mi)
{
	mi->name = "AudioPCI MIDI UART";
	mi->props = MIDI_PROP_CAN_INPUT | MIDI_PROP_OUT_INTR;
}

#endif
@


1.52
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.50 2015/03/14 03:38:48 jsg Exp $ */
a171 1
int	eap_getdev(void *, struct audio_device *);
a209 1
	eap_getdev,
a234 1
	eap_getdev,
a257 6
struct audio_device eap_device = {
	"Ensoniq AudioPCI",
	"",
	"eap"
};

a1104 7
	return (0);
}

int
eap_getdev(void *addr, struct audio_device *retp)
{
	*retp = eap_device;
@


1.51
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@a161 1
int	eap_query_encoding(void *, struct audio_encoding *);
a169 1
void	eap_get_default_params(void *, int, struct audio_params *);
a179 1
paddr_t	eap_mappage(void *, void *, off_t, int);
a200 2
	NULL,
	eap_query_encoding,
a218 1
	eap_mappage,
d221 1
a221 2
	eap_trigger_input,
	eap_get_default_params
a226 2
	NULL,
	eap_query_encoding,
a244 1
	eap_mappage,
d247 1
a247 2
	eap_trigger_input,
	eap_get_default_params
a854 31
eap_query_encoding(void *addr, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

void
eap_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
}

int
a1534 16
}

paddr_t
eap_mappage(void *addr, void *mem, off_t off, int prot)
{
	struct eap_softc *sc = addr;
	struct eap_dma *p;

	if (off < 0)
		return (-1);
	for (p = sc->sc_dmas; p && KERNADDR(p) != mem; p = p->next)
		;
	if (!p)
		return (-1);
	return (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs,
	    off, prot, BUS_DMA_WAITOK));
@


1.50
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.49 2014/08/20 06:03:20 doug Exp $ */
a63 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a875 18
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
a880 18
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a938 2
		p->factor = 1;
		p->sw_code = 0;
a939 6
		case AUDIO_ENCODING_SLINEAR_BE:
			if (p->precision == 16)
				p->sw_code = swap_bytes;
			else
				p->sw_code = change_sign8;
			break;
d942 1
a942 1
				p->sw_code = change_sign8;
d944 1
d946 2
a947 25
			if (p->precision == 16) {
				if (mode == AUMODE_PLAY)
					p->sw_code = swap_bytes_change_sign16_le;
				else
					p->sw_code = change_sign16_swap_bytes_le;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (p->precision == 16)
				p->sw_code = change_sign16_le;
			break;
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_mulaw;
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_alaw;
			break;
d1014 1
a1014 1
	sic |= EAP_SET_P2_ST_INC(0) | EAP_SET_P2_END_INC(param->precision * param->factor / 8);
d1016 1
a1016 1
	if (param->precision * param->factor == 16) {
d1085 1
a1085 1
	if (param->precision * param->factor == 16) {
@


1.49
log
@Release CPU mutexes on EINVAL.

ok guenther@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.48 2014/07/12 18:48:51 tedu Exp $ */
a55 1
#include <sys/malloc.h>
@


1.48
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.47 2013/12/06 21:03:03 deraadt Exp $ */
d1099 1
d1168 1
@


1.47
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.46 2013/05/24 07:58:46 ratchov Exp $ */
d1622 1
a1622 1
		free(p, pool);
d1640 1
a1640 1
			free(p, pool);
@


1.46
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.45 2013/05/15 08:29:24 ratchov Exp $ */
a301 5
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		break;
d306 2
a307 1
	case DVACT_DEACTIVATE:
@


1.45
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.44 2012/03/30 08:18:19 ratchov Exp $ */
d500 2
a501 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, eap_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.44
log
@If the MIDI UART is not ready for output, don't spin at IPL_CLOCK;
just return and make the midi(4) driver retry later. UART buffers
are large enough for this, except eap(4) which uses interrupts for
output.
help from and ok jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.43 2011/07/03 15:47:17 matthew Exp $ */
d343 1
a343 1
	int to, s;
d355 1
a355 1
	s = splaudio();
d384 1
a384 1
	splx(s);
a719 1
	int s;
d721 1
a721 1
	s = splaudio();
d727 1
a727 1
	splx(s);
d738 1
d740 2
a741 1
	if (!(intr & EAP_INTR))
d743 1
d800 1
d1084 1
a1084 1

d1124 1
a1124 1

d1153 1
a1153 1

d1192 1
a1192 1

d1203 1
d1209 1
d1220 1
d1226 1
@


1.43
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.42 2011/04/03 15:36:02 jasper Exp $ */
d131 1
d780 1
a780 1
	if ((intr & EAP_I_UART) && sc->sc_iintr != NULL) {
d786 2
a787 1
				sc->sc_iintr(sc->sc_arg, data);
d790 6
a1680 1
	u_int32_t uctrl;
d1687 1
a1687 1
	uctrl = 0;
d1689 2
a1690 7
		uctrl |= EAP_UC_RXINTEN;
#if 0
	/* I don't understand ../midi.c well enough to use output interrupts */
	if (flags & FWRITE)
		uctrl |= EAP_UC_TXINTEN; */
#endif
	EWRITE1(sc, EAP_UART_CONTROL, uctrl);
a1711 1
	int x;
d1713 6
a1718 8
	for (x = 0; x != MIDI_BUSY_WAIT; x++) {
		if (EREAD1(sc, EAP_UART_STATUS) & EAP_US_TXRDY) {
			EWRITE1(sc, EAP_UART_DATA, d);
			return (0);
		}
		delay(MIDI_BUSY_DELAY);
	}
	return (EIO);
d1725 1
a1725 1
	mi->props = MIDI_PROP_CAN_INPUT;
@


1.42
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.41 2010/09/22 21:59:59 jakemsr Exp $ */
a300 2
	case DVACT_ACTIVATE:
		break;
@


1.41
log
@autoconf activate, suspend/resume support
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.40 2010/07/15 03:43:11 jakemsr Exp $ */
d291 1
a291 1
	    sizeof(eap_devices)/sizeof(eap_devices[0])));
d802 1
a802 1
	    p->segs, sizeof(p->segs)/sizeof(p->segs[0]),
@


1.40
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.39 2010/06/20 10:22:25 ratchov Exp $ */
d91 1
d139 1
d159 1
a159 1
	sizeof(struct eap_softc), eap_match, eap_attach
d174 1
d294 24
d472 1
a472 1
	int revision, ct5880;
d484 1
a484 3
			ct5880 = 1;
		else
			ct5880 = 0;
d559 1
a559 1
		if (ct5880) {
d627 79
@


1.39
log
@Lock the sample rate of es1731-based devices to 48kHz (ie the
codec rate). The es1731 has a hardware sample rate converter but
we don't know how to program it (no documentation) and the current
code is wrong (breaks full-duplex).

ok jakemsr, landry
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.38 2010/04/08 00:23:53 tedu Exp $ */
d768 1
a768 1
		return (0);
d774 1
a774 1
		return (0);
d780 1
a780 1
		return (0);
d786 1
a786 1
		return (0);
d792 1
a792 1
		return (0);
d798 1
a798 1
		return (0);
d804 1
a804 1
		return (0);
d810 1
a810 1
		return (0);
d814 4
d911 2
@


1.38
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.37 2009/02/15 00:11:59 jakemsr Exp $ */
d83 1
a83 1
int	eapdebug = 20;
a184 3
void 	eap1371_set_adc_rate(struct eap_softc *sc, int rate);
void 	eap1371_set_dac_rate(struct eap_softc *sc, int rate, int which);
int	eap1371_src_read(struct eap_softc *sc, int a);
a423 27
int
eap1371_src_read(struct eap_softc *sc, int a)
{
	int to;
	u_int32_t src, t;

	t = eap1371_src_wait(sc);

	src = (t & E1371_SRC_CTLMASK) | E1371_SRC_ADDR(a);
	EWRITE4(sc, E1371_SRC, src | E1371_SRC_STATE_OK);

	t = eap1371_src_wait(sc);

	if ((t & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {
		for (to = 0; to < EAP_READ_TIMEOUT; to++) {
			t = EREAD4(sc, E1371_SRC);
			if ((t & E1371_SRC_STATE_MASK) == E1371_SRC_STATE_OK)
				break;
			delay(1);
		}
	}

	EWRITE4(sc, E1371_SRC, src);

	return t & E1371_SRC_DATAMASK;
}

a434 72
eap1371_set_adc_rate(struct eap_softc *sc, int rate)
{
	int freq, n, truncm;
	int out;
	int s;

	/* Whatever, it works, so I'll leave it :) */

	if (rate > 48000)
		rate = 48000;
	if (rate < 4000)
		rate = 4000;
	n = rate / 3000;
	if ((1 << n) & SRC_MAGIC)
		n--;
	truncm = ((21 * n) - 1) | 1;
	freq = ((48000 << 15) / rate) * n;
	if (rate >= 24000) {
		if (truncm > 239)
			truncm = 239;
		out = ESRC_SET_TRUNC((239 - truncm) / 2);
	} else {
		if (truncm > 119)
			truncm = 119;
		out = ESRC_SMF | ESRC_SET_TRUNC((119 - truncm) / 2);
	}
 	out |= ESRC_SET_N(n);
	s = splaudio();
	eap1371_src_write(sc, ESRC_ADC+ESRC_TRUNC_N, out);

      
	out = eap1371_src_read(sc, ESRC_ADC+ESRC_IREGS) & 0xff;
	eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out |
	    ESRC_SET_VFI(freq >> 15));
	eap1371_src_write(sc, ESRC_ADC+ESRC_VFF, freq & 0x7fff);
	eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(n));
	eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(n));
	splx(s);
}

void
eap1371_set_dac_rate(struct eap_softc *sc, int rate, int which)
{
	int dac = which == 1 ? ESRC_DAC1 : ESRC_DAC2;
	int freq, r;
	int s;
 
	/* Whatever, it works, so I'll leave it :) */

	if (rate > 48000)
	    rate = 48000;
	if (rate < 4000)
	    rate = 4000;
	freq = ((rate << 15) + 1500) / 3000;
	
	s = splaudio();
	eap1371_src_wait(sc);
	r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE |
	    E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);
	r |= (which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2;
	EWRITE4(sc, E1371_SRC, r);
	r = eap1371_src_read(sc, dac + ESRC_IREGS) & 0x00ff;
	eap1371_src_write(sc, dac + ESRC_IREGS, r | ((freq >> 5) & 0xfc00));
	eap1371_src_write(sc, dac + ESRC_VFF, freq & 0x7fff);
	r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE |
	    E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);
	r &= ~(which == 1 ? E1371_SRC_DISP1 : E1371_SRC_DISP2);
	EWRITE4(sc, E1371_SRC, r);
	splx(s);
}

void
d547 9
a555 2
		 * or it locks up.  Set some defaults for the life of the
		 * machine, and set up an ac97 default sample rate.
d560 3
a562 4
		eap1371_src_write(sc, ESRC_DAC1+ESRC_TRUNC_N, ESRC_SET_N(16));
		eap1371_src_write(sc, ESRC_DAC2+ESRC_TRUNC_N, ESRC_SET_N(16));
		eap1371_src_write(sc, ESRC_DAC1+ESRC_IREGS, ESRC_SET_VFI(16));
		eap1371_src_write(sc, ESRC_DAC2+ESRC_IREGS, ESRC_SET_VFI(16));
d565 3
d570 3
a574 4
		eap1371_set_adc_rate(sc, 48000);
		eap1371_set_dac_rate(sc, 48000, 1);
		eap1371_set_dac_rate(sc, 48000, 2);
	     
d855 2
d909 1
a909 5
	if (sc->sc_1371) {
		eap1371_set_dac_rate(sc, play->sample_rate, 1);
		eap1371_set_dac_rate(sc, play->sample_rate, 2);
		eap1371_set_adc_rate(sc, rec->sample_rate);
	} else {
@


1.37
log
@avoid possibly using an uninitialized variable.
problem found by chl@@, fix tested by jasper@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.36 2008/12/29 22:41:45 jakemsr Exp $ */
a57 1
#include <sys/proc.h>
@


1.36
log
@initialize the sample rate converter on es1371 chips to 48 kHz instead
of 22.5 kHz, since this is an ac97(4) device, and the default sample
rate for ac97(4) is 48 kHz.

tested by jasper@@, thanks
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.35 2008/10/25 22:30:43 jakemsr Exp $ */
d416 1
a416 1
	u_int32_t src;
d434 3
a436 2
	src = eap1371_src_wait(sc) & E1371_SRC_CTLMASK;
	src |= E1371_SRC_ADDR(a);
d439 3
a441 1
	if ((eap1371_src_wait(sc) & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {
@


1.35
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.34 2008/06/26 05:42:17 ray Exp $ */
d648 1
a648 1
		 * machine, and set up a sb default sample rate.
d663 3
a665 3
		eap1371_set_adc_rate(sc, 22050);
		eap1371_set_dac_rate(sc, 22050, 1);
		eap1371_set_dac_rate(sc, 22050, 2);
@


1.34
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.33 2008/05/29 02:10:01 jakemsr Exp $ */
d947 8
a954 5
		if (p->sample_rate < 4000 || p->sample_rate > 48000 ||
		    (p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return (EINVAL);

@


1.33
log
@use ac97 default parameters for these ac97 based drivers.

this makes the emulation expansion factor 1 by default since there's no
emulation.  previously the factor was 2 because these drivers emulate
8-bit ulaw playback with 16-bit linear encodings.  having a factor
other than 1 by default creates block size and hiwat/lowat issues
with applications that set the block size and hiwat before other
parameters.

ok ratchov@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.32 2008/04/21 00:32:43 jakemsr Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.32
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.31 2008/03/21 20:11:36 ratchov Exp $ */
d179 1
d238 1
a238 1
	NULL
d268 1
a268 1
	NULL
d913 6
@


1.31
log
@outputs.master.mute, inputs.dac.mute, record.volume.mute and record.source
are already initialized in ac97.c, we dont need to set them here too.

ok jakemsr
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.30 2007/11/12 05:38:23 jakemsr Exp $ */
d237 1
d267 1
@


1.30
log
@repair input vs output confusion

makes 'audioctl play.gain' work correctly

from NetBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.29 2006/04/07 22:41:33 jsg Exp $ */
a201 2
int     eap1371_get_portnum_by_name(struct eap_softc *, char *, char *,
	    char *);
a690 20

		/* Just enable the DAC and master volumes by default */
		ctl.type = AUDIO_MIXER_ENUM;
		ctl.un.ord = 0;  /* off */
		ctl.dev = eap1371_get_portnum_by_name(sc, AudioCoutputs,
		    AudioNmaster, AudioNmute);
		eap1371_mixer_set_port(sc, &ctl);
		ctl.dev = eap1371_get_portnum_by_name(sc, AudioCinputs,
		    AudioNdac, AudioNmute);
		eap1371_mixer_set_port(sc, &ctl);
		ctl.dev = eap1371_get_portnum_by_name(sc, AudioCrecord,
		    AudioNvolume, AudioNmute);
		eap1371_mixer_set_port(sc, &ctl);
		
		ctl.dev = eap1371_get_portnum_by_name(sc, AudioCrecord,
		    AudioNsource, NULL);
		ctl.type = AUDIO_MIXER_ENUM;
		ctl.un.ord = 0;
		eap1371_mixer_set_port(sc, &ctl);

a1224 8
}

int
eap1371_get_portnum_by_name(struct eap_softc *sc,
    char *class, char *device, char *qualifier)
{
	return (sc->codec_if->vtbl->get_portnum_by_name(sc->codec_if, class,
	    device, qualifier));
@


1.29
log
@Add optional flush method to MIDI hardware interface.
Allow umidi(4) to send multiple events in a single USB transfer.
This greatly improves the number of interrupts umidi is able to generate.

From Alexandre Ratchov.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.28 2005/08/09 04:10:11 mickey Exp $ */
d143 1
a143 1
	u_int	sc_output_source;	/* output source mask */
d609 1
a609 1
		ctl.dev = EAP_OUTPUT_SELECT;
d1296 1
a1296 1
	if (cp->dev == EAP_OUTPUT_SELECT) {
d1299 1
a1299 1
		m = sc->sc_output_source = cp->un.mask;
d1393 1
a1393 1
	case EAP_OUTPUT_SELECT:
d1396 1
a1396 1
		cp->un.mask = sc->sc_output_source;
d1548 2
a1549 2
	case EAP_OUTPUT_SELECT:
		dip->mixer_class = EAP_OUTPUT_CLASS;
d1551 1
a1551 1
		strlcpy(dip->label.name, AudioNselect, sizeof dip->label.name);
@


1.28
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.27 2005/04/25 19:53:44 niallo Exp $ */
d275 1
@


1.27
log
@KNF and zap trailing whitespace.

no binary changes.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.26 2005/04/25 14:17:55 niallo Exp $ */
a547 1
	pcireg_t csr;
a573 5

	/* Enable the device. */
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_MASTER_ENABLE);
@


1.26
log
@use delay() and not tsleep() in attach. makes driver work properly with
``Ensoniq CT5880''-based card.

from netbsd rev 1.59

ok mickey@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.25 2005/04/16 21:57:23 mickey Exp $ */
d148 1
a148 1
	struct ac97_host_if host_if;	
d203 1
a203 1
					 char *);
d208 1
a208 1
			   void (*)(void *), void *);
d335 2
a336 2
		printf("%s: eap1371_ready_codec timeout 1\n", 
		       sc->sc_dev.dv_xname);
d349 2
a350 2
		printf("%s: eap1371_ready_codec timeout 2\n", 
		       sc->sc_dev.dv_xname);
d359 2
a360 2
		printf("%s: eap1371_ready_codec timeout 3\n", 
		       sc->sc_dev.dv_xname);
d385 2
a386 2
		printf("%s: eap1371_read_codec timeout 1\n", 
		       sc->sc_dev.dv_xname);
d395 2
a396 2
		printf("%s: eap1371_read_codec timeout 2\n", 
		       sc->sc_dev.dv_xname);
d500 2
a501 2
	eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out | 
			  ESRC_SET_VFI(freq >> 15));
d525 1
a525 1
	r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | 
d532 1
a532 1
	r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | 
d555 1
a555 1
			PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI);
d561 2
a562 2
		     (revision == EAP_ES1373_8 || revision == EAP_CT5880_A)) ||
		     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880))
d570 1
a570 1
			   &sc->iot, &sc->ioh, NULL, NULL, 0)) {
d579 1
a579 1
		       csr | PCI_COMMAND_MASTER_ENABLE);
d587 2
a588 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, eap_intr, sc, 
				       sc->sc_dev.dv_xname);
d602 1
a602 1
		EWRITE4(sc, EAP_ICSC, EAP_CDC_EN); 
d604 2
a605 2
		/* reset codec */	
		/* normal operation */ 
d607 1
a607 1
		eap1370_write_codec(sc, AK_RESET, AK_PD); 
d616 3
a618 3
		ctl.un.mask = 1 << EAP_VOICE_VOL | 1 << EAP_FM_VOL | 
			1 << EAP_CD_VOL | 1 << EAP_LINE_VOL | 1 << EAP_AUX_VOL |
			1 << EAP_MIC_VOL;
d623 1
a623 1
		for (ctl.dev = EAP_MASTER_VOL; ctl.dev < EAP_MIC_VOL; 
d703 1
a703 1
		       AudioNmaster, AudioNmute);
d706 1
a706 1
		       AudioNdac, AudioNmute);
d709 1
a709 1
		       AudioNvolume, AudioNmute);
d713 1
a713 1
		       AudioNsource, NULL);
d821 2
a822 2
				 p->segs, sizeof(p->segs)/sizeof(p->segs[0]),
				 &p->nsegs, BUS_DMA_NOWAIT);
d826 2
a827 2
	error = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size, 
			       &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
d832 1
a832 1
				  0, BUS_DMA_NOWAIT, &p->map);
d836 2
a837 2
	error = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL, 
				BUS_DMA_NOWAIT);
d941 1
a941 1
	       struct audio_params *play, struct audio_params *rec)
d952 11
a962 11
	    if (play->sample_rate != rec->sample_rate &&
		usemode == (AUMODE_PLAY | AUMODE_RECORD)) {
	    	if (setmode == AUMODE_PLAY) {
		    rec->sample_rate = play->sample_rate;
		    setmode |= AUMODE_RECORD;
		} else if (setmode == AUMODE_RECORD) {
		    play->sample_rate = rec->sample_rate;
		    setmode |= AUMODE_PLAY;
		} else
		    return (EINVAL);
	    }
d965 2
a966 2
	for (mode = AUMODE_RECORD; mode != -1; 
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
d1027 2
a1028 2
		DPRINTFN(2, ("eap_set_params: old ICSC = 0x%08x\n", 
			     EREAD4(sc, EAP_ICSC)));
d1032 1
a1032 1
		 * The -2 isn't documented, but seemed to make the wall 
d1037 2
a1038 2
			div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / 
				rec->sample_rate - 2);
d1040 2
a1041 2
			div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / 
				play->sample_rate - 2);
d1105 2
a1106 2
		 (int)DMAADDR(p), 
		 (int)EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));
d1109 2
a1110 2
	EWRITE4(sc, EAP_DAC2_SIZE, 
		EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1));
d1146 1
a1146 1
	DPRINTFN(1, ("eap_trigger_input: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\n", 
d1173 2
a1174 2
		 (int)DMAADDR(p), 
		 (int)EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));
d1177 2
a1178 2
	EWRITE4(sc, EAP_ADC_SIZE, 
		EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1));
d1256 1
a1256 1
			    char *class, char *device, char *qualifier)
d1259 1
a1259 1
	     device, qualifier));
d1283 1
a1283 1
		if (m & (1 << EAP_VOICE_VOL)) 
d1285 1
a1285 1
		if (m & (1 << EAP_FM_VOL)) 
d1287 1
a1287 1
		if (m & (1 << EAP_CD_VOL)) 
d1289 1
a1289 1
		if (m & (1 << EAP_LINE_VOL)) 
d1291 1
a1291 1
		if (m & (1 << EAP_AUX_VOL)) 
d1293 1
a1293 1
		if (m & (1 << EAP_MIC_VOL)) 
d1295 1
a1295 1
		eap1370_set_mixer(sc, AK_IN_MIXER1_L, l1);		
d1306 1
a1306 1
		if (m & (1 << EAP_VOICE_VOL)) 
d1308 1
a1308 1
		if (m & (1 << EAP_FM_VOL)) 
d1310 1
a1310 1
		if (m & (1 << EAP_CD_VOL)) 
d1312 1
a1312 1
		if (m & (1 << EAP_LINE_VOL)) 
d1314 1
a1314 1
		if (m & (1 << EAP_AUX_VOL)) 
d1316 1
a1316 1
		if (m & (1 << EAP_MIC_VOL)) 
d1663 2
a1664 2
	return (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs, 
				off, prot, BUS_DMA_WAITOK));
d1670 2
a1671 2
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | 
		AUDIO_PROP_FULLDUPLEX);
d1684 3
a1686 3
	      void (*iintr)(void *, int),
	      void (*ointr)(void *),
	      void *arg)
@


1.25
log
@do not provide round_buffer if not needed unless explained why in comments
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.24 2005/04/14 12:42:16 mickey Exp $ */
d648 1
a648 1
			tsleep(sc, PRIBIO, "eapcdc", hz / 20);
@


1.24
log
@make sure round_blocksize does not produce 0 after alignment
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.23 2004/12/17 08:04:45 jsg Exp $ */
a187 1
size_t	eap_round_buffersize(void *, int, size_t);
d234 1
a234 1
	eap_round_buffersize,
d263 1
a263 1
	eap_round_buffersize,
a1648 6
}

size_t
eap_round_buffersize(void *addr, int direction, size_t size)
{
	return (size);
@


1.23
log
@Support for the eap MIDI UART from NetBSD.
Tested by serveral people. ok millert@@, mickey@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.22 2004/12/07 03:17:42 jsg Exp $ */
d1054 1
a1054 1
	return (blk & -32);	/* keep good alignment */
@


1.22
log
@Don't link to ac97 specs from individual drivers.
ok mickey@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.21 2004/03/18 01:24:41 tedu Exp $ */
d57 2
d62 1
d72 1
d134 7
d157 1
d160 1
d205 7
d271 10
d722 3
d800 12
d1688 65
@


1.21
log
@don't read registers all the time, solves timeout issues.  from Joris Vink
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.20 2003/05/14 05:18:48 jason Exp $ */
a54 1
 * ftp://download.intel.com/ial/scalableplatforms/audio/ac97r21.pdf
@


1.20
log
@time bound some of the loops instead of depending on pci read to determine
the loop time... icky poo!  ok millert, tested by margarida
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.19 2003/04/27 11:22:53 ho Exp $ */
d139 2
d143 1
d660 3
a662 1
		
d1635 8
@


1.19
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.18 2003/04/05 19:15:52 millert Exp $ */
d351 1
d361 1
@


1.18
log
@Change timeout detection from > or >= EAP_XXX_TIMEOUT to ==.
The > was wrong and >= is not needed (== is suuficient).  OK krw@@
From Patrick Latifi
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.17 2002/11/19 18:40:17 jason Exp $ */
d837 1
a837 1
		strcpy(fp->name, AudioEulinear);
d843 1
a843 1
		strcpy(fp->name, AudioEmulaw);
d849 1
a849 1
		strcpy(fp->name, AudioEalaw);
d855 1
a855 1
		strcpy(fp->name, AudioEslinear);
d861 1
a861 1
		strcpy(fp->name, AudioEslinear_le);
d867 1
a867 1
		strcpy(fp->name, AudioEulinear_le);
d873 1
a873 1
		strcpy(fp->name, AudioEslinear_be);
d879 1
a879 1
		strcpy(fp->name, AudioEulinear_be);
d1411 1
a1411 1
		strcpy(dip->label.name, AudioNmaster);
d1413 2
a1414 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1421 1
a1421 1
		strcpy(dip->label.name, AudioNdac);
d1423 2
a1424 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1431 2
a1432 1
		strcpy(dip->label.name, AudioNfmsynth);
d1434 2
a1435 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1442 1
a1442 1
		strcpy(dip->label.name, AudioNcd);
d1444 2
a1445 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1452 1
a1452 1
		strcpy(dip->label.name, AudioNline);
d1454 2
a1455 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1462 1
a1462 1
		strcpy(dip->label.name, AudioNaux);
d1464 2
a1465 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1472 2
a1473 1
		strcpy(dip->label.name, AudioNmicrophone);
d1475 2
a1476 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1481 1
a1481 1
		strcpy(dip->label.name, AudioNsource);
d1484 2
a1485 1
		strcpy(dip->un.s.member[0].label.name, AudioNmicrophone);
d1487 2
a1488 1
		strcpy(dip->un.s.member[1].label.name, AudioNcd);
d1490 2
a1491 1
		strcpy(dip->un.s.member[2].label.name, AudioNline);
d1493 2
a1494 1
		strcpy(dip->un.s.member[3].label.name, AudioNfmsynth);
d1496 2
a1497 1
		strcpy(dip->un.s.member[4].label.name, AudioNaux);
d1499 2
a1500 1
		strcpy(dip->un.s.member[5].label.name, AudioNdac);
d1506 1
a1506 1
		strcpy(dip->label.name, AudioNselect);
d1509 2
a1510 1
		strcpy(dip->un.s.member[0].label.name, AudioNmicrophone);
d1512 2
a1513 1
		strcpy(dip->un.s.member[1].label.name, AudioNcd);
d1515 2
a1516 1
		strcpy(dip->un.s.member[2].label.name, AudioNline);
d1518 2
a1519 1
		strcpy(dip->un.s.member[3].label.name, AudioNfmsynth);
d1521 2
a1522 1
		strcpy(dip->un.s.member[4].label.name, AudioNaux);
d1524 2
a1525 1
		strcpy(dip->un.s.member[5].label.name, AudioNdac);
d1533 1
a1533 1
		strcpy(dip->label.name, AudioNpreamp);
d1535 2
a1536 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d1538 2
a1539 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d1546 2
a1547 1
		strcpy(dip->label.name, AudioCoutputs);
d1553 1
a1553 1
		strcpy(dip->label.name, AudioCrecord);
d1559 1
a1559 1
		strcpy(dip->label.name, AudioCinputs);
@


1.17
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.16 2002/01/20 19:56:53 ericj Exp $ */
d303 1
a303 1
	if (to >= EAP_WRITE_TIMEOUT)
d317 1
a317 1
	if (to >= EAP_READ_TIMEOUT)
d327 1
a327 1
	if (to >= EAP_READ_TIMEOUT)
d352 1
a352 1
	if (to > EAP_WRITE_TIMEOUT)
d361 1
a361 1
	if (to > EAP_WRITE_TIMEOUT)
@


1.16
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.15 2001/10/31 11:00:24 art Exp $ */
d255 7
d265 2
a266 20
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_CREATIVELABS:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_CREATIVELABS_EV1938:
			return (1);
		}
		break;
	case PCI_VENDOR_ENSONIQ:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ENSONIQ_AUDIOPCI:
		case PCI_PRODUCT_ENSONIQ_AUDIOPCI97:
		case PCI_PRODUCT_ENSONIQ_CT5880:
			return (1);
		}
		break;
	}

	return (0);
@


1.15
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.14 2001/09/06 18:33:28 millert Exp $ */
d171 1
a171 1
void   *eap_malloc(void *, u_long, int, int);
d173 1
a173 1
u_long	eap_round_buffersize(void *, u_long);
d1553 1
a1553 1
eap_malloc(void *addr, u_long size, int pool, int flags)
d1588 2
a1589 2
u_long
eap_round_buffersize(void *addr, u_long size)
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.16 2002/01/20 19:56:53 ericj Exp $ */
d171 1
a171 1
void   *eap_malloc(void *, int, size_t, int, int);
d173 1
a173 1
size_t	eap_round_buffersize(void *, int, size_t);
d1553 1
a1553 1
eap_malloc(void *addr, int direction, size_t size, int pool, int flags)
d1588 2
a1589 2
size_t
eap_round_buffersize(void *addr, int direction, size_t size)
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
a254 7
const struct pci_matchid eap_devices[] = {
	{ PCI_VENDOR_CREATIVELABS, PCI_PRODUCT_CREATIVELABS_EV1938 },
	{ PCI_VENDOR_ENSONIQ, PCI_PRODUCT_ENSONIQ_AUDIOPCI },
	{ PCI_VENDOR_ENSONIQ, PCI_PRODUCT_ENSONIQ_AUDIOPCI97 },
	{ PCI_VENDOR_ENSONIQ, PCI_PRODUCT_ENSONIQ_CT5880 },
};

d258 20
a277 2
	return (pci_matchbyid((struct pci_attach_args *)aux, eap_devices,
	    sizeof(eap_devices)/sizeof(eap_devices[0])));
d314 1
a314 1
	if (to == EAP_WRITE_TIMEOUT)
d328 1
a328 1
	if (to == EAP_READ_TIMEOUT)
d338 1
a338 1
	if (to == EAP_READ_TIMEOUT)
a361 1
		delay(1);
d363 1
a363 1
	if (to == EAP_WRITE_TIMEOUT)
a370 1
		delay(1);
d372 1
a372 1
	if (to == EAP_WRITE_TIMEOUT)
d848 1
a848 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d854 1
a854 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d860 1
a860 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d866 1
a866 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d872 1
a872 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d878 1
a878 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d884 1
a884 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d890 1
a890 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1422 1
a1422 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1424 1
a1424 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1431 1
a1431 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1433 1
a1433 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1440 1
a1440 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d1442 1
a1442 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1449 1
a1449 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1451 1
a1451 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1458 1
a1458 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1460 1
a1460 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1467 1
a1467 1
		strlcpy(dip->label.name, AudioNaux, sizeof dip->label.name);
d1469 1
a1469 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1476 1
a1476 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1478 1
a1478 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1483 1
a1483 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1486 1
a1486 2
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[0].label.name);
d1488 1
a1488 2
		strlcpy(dip->un.s.member[1].label.name, AudioNcd,
		    sizeof dip->un.s.member[1].label.name);
d1490 1
a1490 2
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
d1492 1
a1492 2
		strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
		    sizeof dip->un.s.member[3].label.name);
d1494 1
a1494 2
		strlcpy(dip->un.s.member[4].label.name, AudioNaux,
		    sizeof dip->un.s.member[4].label.name);
d1496 1
a1496 2
		strlcpy(dip->un.s.member[5].label.name, AudioNdac,
		    sizeof dip->un.s.member[5].label.name);
d1502 1
a1502 1
		strlcpy(dip->label.name, AudioNselect, sizeof dip->label.name);
d1505 1
a1505 2
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[0].label.name);
d1507 1
a1507 2
		strlcpy(dip->un.s.member[1].label.name, AudioNcd,
		    sizeof dip->un.s.member[1].label.name);
d1509 1
a1509 2
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
d1511 1
a1511 2
		strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
		    sizeof dip->un.s.member[3].label.name);
d1513 1
a1513 2
		strlcpy(dip->un.s.member[4].label.name, AudioNaux,
		    sizeof dip->un.s.member[4].label.name);
d1515 1
a1515 2
		strlcpy(dip->un.s.member[5].label.name, AudioNdac,
		    sizeof dip->un.s.member[5].label.name);
d1523 1
a1523 1
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
d1525 1
a1525 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1527 1
a1527 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d1534 1
a1534 2
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof dip->label.name);
d1540 1
a1540 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d1546 1
a1546 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
@


1.14
log
@Remove useless "\n%s" from the attach routine to match OpenBSD attach norms.
naddy@@ OK
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.13 2001/09/06 14:47:07 naddy Exp $ */
d174 1
a174 1
int	eap_mappage(void *, void *, int, int);
d1594 2
a1595 2
int
eap_mappage(void *addr, void *mem, int off, int prot)
@


1.13
log
@sync up to NetBSD; reviewed by csapuntz@@
- better support for more chip revisions
- split register definitions into separate header file
- KNF
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.12 2001/08/25 10:13:29 art Exp $ */
d290 2
a291 1
			printf("eap: timeout writing to codec\n");
a548 1
		printf("\n%s: can't map i/o space\n", sc->sc_dev.dv_xname);
d561 1
a561 1
		printf("\n%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d568 1
a568 2
		printf("\n%s: couldn't establish interrupt",
		       sc->sc_dev.dv_xname);
@


1.12
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 2
a2 2
/*      $OpenBSD: eap.c,v 1.11 2001/06/12 15:40:30 niklas Exp $ */
/*	$NetBSD: eap.c,v 1.25 1999/02/18 07:59:30 mycroft Exp $	*/
d44 2
d49 1
a49 5
 * Ensoniq AudoiPCI ES1370 + AK4531 driver. 
 * Data sheets can be found at 
 * http://www.ensoniq.com/multimedia/semi_html/html/es1370.zip
 * and
 * http://www.akm.com/pdf/4531.pdf
d51 5
a55 4
 * Added Creative Ensoniq support: ES1371 + AC97 = hack city.
 * -- Ezra Story <ezy@@panix.com>
 * Check es1371.zip from above, and the Audio Codec 97 spec from
 * intel.com.
a56 1
 
d63 1
d76 2
a83 214
#define EAP_ICSC		0x00    /* interrupt / chip select control */
#define  EAP_SERR_DISABLE	0x00000001
#define  EAP_CDC_EN		0x00000002
#define  EAP_JYSTK_EN		0x00000004
#define  EAP_UART_EN		0x00000008
#define  EAP_ADC_EN		0x00000010
#define  EAP_DAC2_EN		0x00000020
#define  EAP_DAC1_EN		0x00000040
#define  EAP_BREQ		0x00000080
#define  EAP_XTCL0		0x00000100
#define  EAP_M_CB		0x00000200
#define  EAP_CCB_INTRM		0x00000400
#define  EAP_DAC_SYNC		0x00000800
#define  EAP_WTSRSEL		0x00003000
#define   EAP_WTSRSEL_5		0x00000000
#define   EAP_WTSRSEL_11	0x00001000
#define   EAP_WTSRSEL_22	0x00002000
#define   EAP_WTSRSEL_44	0x00003000
#define  EAP_M_SBB		0x00004000
#define  EAP_MSFMTSEL		0x00008000
#define  EAP_SET_PCLKDIV(n)	(((n)&0x1fff)<<16)
#define  EAP_GET_PCLKDIV(n)	(((n)>>16)&0x1fff)
#define  EAP_PCLKBITS		0x1fff0000
#define  EAP_XTCL1		0x40000000
#define  EAP_ADC_STOP		0x80000000
#define  E1371_SYNC_RES		(1<<14)

#define EAP_ICSS		0x04	/* interrupt / chip select status */
#define  EAP_I_ADC		0x00000001
#define  EAP_I_DAC2		0x00000002
#define  EAP_I_DAC1		0x00000004
#define  EAP_I_UART		0x00000008
#define  EAP_I_MCCB		0x00000010
#define  EAP_VC			0x00000060
#define  EAP_CWRIP		0x00000100
#define  EAP_CBUSY		0x00000200
#define  EAP_CSTAT		0x00000400
#define  CT5880_AC97_RESET      0x20000000
#define  EAP_INTR		0x80000000

#define EAP_UART_DATA		0x08
#define EAP_UART_STATUS		0x09
#define EAP_UART_CONTROL	0x09
#define EAP_MEMPAGE		0x0c
#define EAP_CODEC		0x10
#define  EAP_SET_CODEC(a,d)	(((a)<<8) | (d))

/* ES1371 Registers */
#define E1371_CODEC		0x14
#define  E1371_CODEC_WIP	(1<<30)
#define  E1371_CODEC_VALID      (1<<31)
#define  E1371_CODEC_READ       (1<<23)
#define  E1371_SET_CODEC(a,d)	(((a)<<16) | (d))
#define E1371_SRC		0x10
#define  E1371_SRC_RAMWE	(1<<24)
#define  E1371_SRC_RBUSY	(1<<23)
#define  E1371_SRC_DISABLE	(1<<22)
#define  E1371_SRC_DISP1	(1<<21)
#define  E1371_SRC_DISP2        (1<<20)
#define  E1371_SRC_DISREC       (1<<19)
#define  E1371_SRC_ADDR(a)	((a)<<25)
#define  E1371_SRC_STATE_MASK   0x870000
#define  E1371_SRC_STATE_OK     0x010000
#define  E1371_SRC_DATA(d)	(d)
#define  E1371_SRC_DATAMASK	0xffff
#define E1371_LEGACY		0x18

/* ES1371 Sample rate converter registers */
#define ESRC_ADC		0x78
#define ESRC_DAC1		0x74
#define ESRC_DAC2		0x70
#define ESRC_ADC_VOLL		0x6c
#define ESRC_ADC_VOLR		0x6d
#define ESRC_DAC1_VOLL		0x7c
#define ESRC_DAC1_VOLR		0x7d
#define ESRC_DAC2_VOLL		0x7e
#define ESRC_DAC2_VOLR		0x7f
#define  ESRC_TRUNC_N		0x00
#define  ESRC_IREGS		0x01
#define  ESRC_ACF		0x02
#define  ESRC_VFF		0x03
#define ESRC_SET_TRUNC(n)	((n)<<9)
#define ESRC_SET_N(n)		((n)<<4)
#define ESRC_SMF		0x8000
#define ESRC_SET_VFI(n)		((n)<<10)
#define ESRC_SET_ACI(n)		(n)
#define ESRC_SET_ADC_VOL(n)	((n)<<8)
#define ESRC_SET_DAC_VOLI(n)	((n)<<12)
#define ESRC_SET_DAC_VOLF(n)	(n)
#define  SRC_MAGIC ((1<15)|(1<<13)|(1<<11)|(1<<9))


#define EAP_SIC			0x20
#define  EAP_P1_S_MB		0x00000001
#define  EAP_P1_S_EB		0x00000002
#define  EAP_P2_S_MB		0x00000004
#define  EAP_P2_S_EB		0x00000008
#define  EAP_R1_S_MB		0x00000010
#define  EAP_R1_S_EB		0x00000020
#define  EAP_P2_DAC_SEN		0x00000040
#define  EAP_P1_SCT_RLD		0x00000080
#define  EAP_P1_INTR_EN		0x00000100
#define  EAP_P2_INTR_EN		0x00000200
#define  EAP_R1_INTR_EN		0x00000400
#define  EAP_P1_PAUSE		0x00000800
#define  EAP_P2_PAUSE		0x00001000
#define  EAP_P1_LOOP_SEL	0x00002000
#define  EAP_P2_LOOP_SEL	0x00004000
#define  EAP_R1_LOOP_SEL	0x00008000
#define  EAP_SET_P2_ST_INC(i)	((i) << 16)
#define  EAP_SET_P2_END_INC(i)	((i) << 19)
#define  EAP_INC_BITS		0x003f0000

#define EAP_DAC1_CSR		0x24
#define EAP_DAC2_CSR		0x28
#define EAP_ADC_CSR		0x2c
#define  EAP_GET_CURRSAMP(r)	((r) >> 16)

#define EAP_DAC_PAGE		0xc
#define EAP_ADC_PAGE		0xd
#define EAP_UART_PAGE1		0xe
#define EAP_UART_PAGE2		0xf

#define EAP_DAC1_ADDR		0x30
#define EAP_DAC1_SIZE		0x34
#define EAP_DAC2_ADDR		0x38
#define EAP_DAC2_SIZE		0x3c
#define EAP_ADC_ADDR		0x30
#define EAP_ADC_SIZE		0x34
#define  EAP_SET_SIZE(c,s)	(((c)<<16) | (s))

#define EAP_READ_TIMEOUT        0x1000
#define EAP_WRITE_TIMEOUT	0x1000


#define EAP_XTAL_FREQ 1411200 /* 22.5792 / 16 MHz */

/* AK4531 registers */
#define AK_MASTER_L		0x00
#define AK_MASTER_R		0x01
#define AK_VOICE_L		0x02
#define AK_VOICE_R		0x03
#define AK_FM_L			0x04
#define AK_FM_R			0x05
#define AK_CD_L			0x06
#define AK_CD_R			0x07
#define AK_LINE_L		0x08
#define AK_LINE_R		0x09
#define AK_AUX_L		0x0a
#define AK_AUX_R		0x0b
#define AK_MONO1		0x0c
#define AK_MONO2		0x0d
#define AK_MIC			0x0e
#define AK_MONO			0x0f
#define AK_OUT_MIXER1		0x10
#define  AK_M_FM_L		0x40
#define  AK_M_FM_R		0x20
#define  AK_M_LINE_L		0x10
#define  AK_M_LINE_R		0x08
#define  AK_M_CD_L		0x04
#define  AK_M_CD_R		0x02
#define  AK_M_MIC		0x01
#define AK_OUT_MIXER2		0x11
#define  AK_M_AUX_L		0x20
#define  AK_M_AUX_R		0x10
#define  AK_M_VOICE_L		0x08
#define  AK_M_VOICE_R		0x04
#define  AK_M_MONO2		0x02
#define  AK_M_MONO1		0x01
#define AK_IN_MIXER1_L		0x12
#define AK_IN_MIXER1_R		0x13
#define AK_IN_MIXER2_L		0x14
#define AK_IN_MIXER2_R		0x15
#define  AK_M_TMIC		0x80
#define  AK_M_TMONO1		0x40
#define  AK_M_TMONO2		0x20
#define  AK_M2_AUX_L		0x10
#define  AK_M2_AUX_R		0x08
#define  AK_M_VOICE		0x04
#define  AK_M2_MONO2		0x02
#define  AK_M2_MONO1		0x01
#define AK_RESET		0x16
#define  AK_PD			0x02
#define  AK_NRST		0x01
#define AK_CS			0x17
#define AK_ADSEL		0x18
#define AK_MGAIN		0x19
#define AK_NPORTS               0x20

#define MAX_NPORTS              AK_NPORTS

/* Not sensical for AC97? */
#define VOL_TO_ATT5(v) (0x1f - ((v) >> 3))
#define VOL_TO_GAIN5(v) VOL_TO_ATT5(v)
#define ATT5_TO_VOL(v) ((0x1f - (v)) << 3)
#define GAIN5_TO_VOL(v) ATT5_TO_VOL(v)
#define VOL_0DB 200

/* Futzable parms */
#define EAP_MASTER_VOL		0
#define EAP_VOICE_VOL		1
#define EAP_FM_VOL		2 
#define EAP_VIDEO_VOL		2 /* ES1371 */
#define EAP_CD_VOL		3
#define EAP_LINE_VOL		4
#define EAP_AUX_VOL		5
#define EAP_MIC_VOL		6
#define	EAP_RECORD_SOURCE 	7
#define EAP_OUTPUT_SELECT	8
#define	EAP_MIC_PREAMP		9  
#define EAP_OUTPUT_CLASS	10
#define EAP_RECORD_CLASS	11
#define EAP_INPUT_CLASS		12

d94 3
a96 3
int	eap_match __P((struct device *, void *, void *));
void	eap_attach __P((struct device *, struct device *, void *));
int	eap_intr __P((void *));
d106 1
d131 1
a131 1
	u_short	sc_port[MAX_NPORTS];	/* mirror of the hardware setting */
d135 1
a135 1
        char    sc_1371;                /* Using ES1371/AC97 codec */
d141 2
a142 2
int	eap_allocmem __P((struct eap_softc *, size_t, size_t, struct eap_dma *));
int	eap_freemem __P((struct eap_softc *, struct eap_dma *));
d153 37
a189 37
int	eap_open __P((void *, int));
void	eap_close __P((void *));
int	eap_query_encoding __P((void *, struct audio_encoding *));
int	eap_set_params __P((void *, int, int, struct audio_params *, struct audio_params *));
int	eap_round_blocksize __P((void *, int));
int	eap_trigger_output __P((void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *));
int	eap_trigger_input __P((void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *));
int	eap_halt_output __P((void *));
int	eap_halt_input __P((void *));
void    eap_write_codec __P((struct eap_softc *, int, int));
int	eap_getdev __P((void *, struct audio_device *));
int	eap_mixer_set_port __P((void *, mixer_ctrl_t *));
int	eap_mixer_get_port __P((void *, mixer_ctrl_t *));
int	eap1371_mixer_set_port __P((void *, mixer_ctrl_t *));
int	eap1371_mixer_get_port __P((void *, mixer_ctrl_t *));
int	eap_query_devinfo __P((void *, mixer_devinfo_t *));
void   *eap_malloc __P((void *, u_long, int, int));
void	eap_free __P((void *, void *, int));
u_long	eap_round_buffersize __P((void *, u_long));
int	eap_mappage __P((void *, void *, int, int));
int	eap_get_props __P((void *));
void	eap_set_mixer __P((struct eap_softc *sc, int a, int d));
int	eap1371_src_wait __P((struct eap_softc *sc));
void 	eap1371_set_adc_rate __P((struct eap_softc *sc, int rate));
void 	eap1371_set_dac_rate __P((struct eap_softc *sc, int rate, int which));
int	eap1371_src_read __P((struct eap_softc *sc, int a));
void	eap1371_src_write __P((struct eap_softc *sc, int a, int d));
int	eap1371_query_devinfo __P((void *addr, mixer_devinfo_t *dip));

int     eap1371_attach_codec __P((void *sc, struct ac97_codec_if *));
int	eap1371_read_codec __P((void *sc, u_int8_t a, u_int16_t *d));
int	eap1371_write_codec __P((void *sc, u_int8_t a, u_int16_t d));
void    eap1371_reset_codec __P((void *sc));
int     eap1371_get_portnum_by_name __P((struct eap_softc *, char *, char *,
					 char *));
d208 3
a210 3
	eap_mixer_set_port,
	eap_mixer_get_port,
	eap_query_devinfo,
d256 1
a256 4
eap_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d260 16
a275 9
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_ENSONIQ &&
	    PCI_VENDOR(pa->pa_id) != PCI_VENDOR_CREATIVELABS)
		return (0);

	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI97 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_EV1938)
		return (1);
d281 1
a281 3
eap_write_codec(sc, a, d)
	struct eap_softc *sc;
	int a, d;
d283 1
a284 2
	int icss, to;
	
d289 4
a292 4
                if (!to--) {
                        printf("eap: timeout writing to codec\n");
                        return;
                }
d294 1
a294 1
        EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));
d297 4
d302 2
a303 5
int
eap1371_read_codec(sc_, a, d)
        void *sc_;
	u_int8_t a;
	u_int16_t *d;
d305 2
a306 3
	struct eap_softc *sc = sc_;
        int to;
        int cdc, src;
d308 8
a315 12
        to = EAP_WRITE_TIMEOUT;
        do {
                cdc = EREAD4(sc, E1371_CODEC);
                if (!to--) {
                        printf("eap: timeout writing to codec\n");
                        return 1;
                }
        } while (cdc & E1371_CODEC_WIP);

        /* just do it */
	src = (eap1371_src_wait(sc) & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |
		E1371_SRC_DISP2 | E1371_SRC_DISREC)) ;
d317 3
a319 1
	EWRITE4(sc, E1371_SRC, src | 0x10000);
d322 2
a323 1
		if (!(EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK))
a324 1

d327 3
d331 3
a333 3
	for (to = 0; to < EAP_WRITE_TIMEOUT; to++) {
		if ((EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK) ==
			E1371_SRC_STATE_OK)
a334 1

d337 5
a341 2
	
        EWRITE4(sc, E1371_CODEC, E1371_SET_CODEC(a, 0) | E1371_CODEC_READ);
d346 1
a346 14
	for (to = 0; to < EAP_READ_TIMEOUT; to++) {
		if ((cdc = EREAD4(sc, E1371_CODEC)) & E1371_CODEC_VALID)
			break;
	}

	if (to == EAP_WRITE_TIMEOUT) {
		DPRINTF(("eap1371: read codec timeout\n"));
	}

	*d = cdc & 0xffff;

        DPRINTFN(10, ("eap1371: reading codec (%x) = %x\n", a, *d));        

	return (0);
d350 1
a350 4
eap1371_write_codec(sc_, a, d)
        void *sc_;
	u_int8_t a;
	u_int16_t d;
d353 2
a354 15
        int to;
        int cdc, src;

        to = EAP_WRITE_TIMEOUT;
        do {
                cdc = EREAD4(sc, E1371_CODEC);
                if (!to--) {
                        printf("eap: timeout writing to codec\n");
                        return 1;
                }
        } while (cdc & E1371_CODEC_WIP);

        /* just do it */
	src = (eap1371_src_wait(sc) & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |
		E1371_SRC_DISP2 | E1371_SRC_DISREC)) ;
d356 1
a356 1
	EWRITE4(sc, E1371_SRC, src | 0x10000);
d359 1
a359 1
		if (!(EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK))
d361 4
a365 3
		delay(1);
	}
	
d367 2
a368 2
		if ((EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK) ==
			E1371_SRC_STATE_OK)
d370 8
d379 2
a380 2
		delay(1);
	}
d382 4
a385 1
        EWRITE4(sc, E1371_CODEC, E1371_SET_CODEC(a, d));
d387 1
a387 2
	eap1371_src_wait(sc);
	EWRITE4(sc, E1371_SRC, src);
d391 1
a391 1
        return (0);
d394 2
a395 3
int
eap1371_src_wait(sc)
	struct eap_softc *sc;
d397 3
a399 3
        int to;
        int src;

d403 1
a403 1
			return src;
d406 2
a407 6

	
	printf("eap: timeout waiting for sample rate"
	    "converter\n");

	return src;
d411 1
a411 3
eap1371_src_read(sc, a)
	struct eap_softc *sc;
	int a;
d413 2
a414 4
	int r, to;
	int src;

	src = eap1371_src_wait(sc);
d416 3
a418 4
	EWRITE4(sc, E1371_SRC, 
	    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |
		E1371_SRC_DISP2 | E1371_SRC_DISREC)) |
	    E1371_SRC_ADDR(a) | 0x10000UL);
d420 1
a420 3
	r = eap1371_src_wait(sc);

	if ((r & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {
d422 4
a425 3
			r = EREAD4(sc, E1371_SRC);
			if ((r & E1371_SRC_STATE_MASK) == 
			    E1371_SRC_STATE_OK) break;
d429 1
a429 4
	EWRITE4 (sc, E1371_SRC,
	    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |
	    E1371_SRC_DISP2 | E1371_SRC_DISREC)) |
	    E1371_SRC_ADDR(a));
d431 1
a431 1
	return r;
d435 5
a439 9
eap1371_src_write(sc, a, d)
	struct eap_softc *sc;
	int a,d;
{
	int r;

	r = eap1371_src_wait(sc);
	r &= (E1371_SRC_DISABLE | E1371_SRC_DISP1 |
	    E1371_SRC_DISP2 | E1371_SRC_DISREC);
d445 1
a445 3
eap1371_set_adc_rate(sc, rate)
	struct eap_softc *sc;
	int rate;
d449 1
d451 1
a451 1
        /* Whatever, it works, so I'll leave it :) */
d453 12
a464 12
        if (rate > 48000)
            rate = 48000;
        if (rate < 4000)
            rate = 4000;
        n = rate / 3000;
        if ((1 << n) & SRC_MAGIC)
                n--;
        truncm = ((21 * n) - 1) | 1;
        freq = ((48000 << 15) / rate) * n;
        if (rate >= 24000) {
                if (truncm > 239)
                        truncm = 239;
d466 3
a468 3
        } else {
                if (truncm > 119)
                        truncm = 119;
d470 1
a470 1
        }
d472 2
a473 1
        eap1371_src_write(sc, ESRC_ADC+ESRC_TRUNC_N, out);
d476 2
a477 2
        out = eap1371_src_read(sc, ESRC_ADC+ESRC_IREGS) & 0xff;
        eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out | 
d479 4
a482 3
        eap1371_src_write(sc, ESRC_ADC+ESRC_VFF, freq & 0x7fff);
        eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(n));
        eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(n));
d486 1
a486 4
eap1371_set_dac_rate(sc, rate, which)
	struct eap_softc *sc;
	int rate;
	int which;
d488 1
a488 1
        int dac = (which == 1) ? ESRC_DAC1 : ESRC_DAC2;
d490 1
d492 1
a492 1
        /* Whatever, it works, so I'll leave it :) */
d494 20
a513 18
        if (rate > 48000)
            rate = 48000;
        if (rate < 4000)
            rate = 4000;
        freq = ((rate << 15) + 1500) / 3000;
        
        eap1371_src_wait(sc);
        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | 
            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);
        r |= (which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2;
        EWRITE4(sc, E1371_SRC, r);
        r = eap1371_src_read(sc, dac + ESRC_IREGS) & 0x00ff;
        eap1371_src_write(sc, dac + ESRC_IREGS, r | ((freq >> 5) & 0xfc00));
        eap1371_src_write(sc, dac + ESRC_VFF, freq & 0x7fff);
        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | 
            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);
        r &= ~((which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2);
        EWRITE4(sc, E1371_SRC, r);
d517 1
a517 4
eap_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d528 5
a532 1
	int revision;
a533 2
	sc->sc_1371 = 
	    !(PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI);
d535 9
d586 3
a588 3
		eap_write_codec(sc, AK_RESET, AK_PD); 
		eap_write_codec(sc, AK_RESET, AK_PD | AK_NRST);
		eap_write_codec(sc, AK_CS, 0x0);
d618 1
a618 1
		int error;
a619 1
                /* clean slate */
d621 2
a622 2
                EWRITE4(sc, EAP_ICSC, 0);
                EWRITE4(sc, E1371_LEGACY, 0);
d624 4
a627 8
		/* It seems that revision 7 and greater of the AUDIOPCI 97
		   are actually CT5880 */
		if ((PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880) ||
		    ((PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI97)
			&& (revision >= 7))) {
			EWRITE4(sc, EAP_ICSS, CT5880_AC97_RESET);

			delay(20000);
d635 8
a642 7
                /* must properly reprogram sample rate converter,
                 * or it locks up.  Set some defaults for the life of the
                 * machine, and set up a sb default sample rate.
                 */
                EWRITE4(sc, E1371_SRC, E1371_SRC_DISABLE);
                for (i=0; i<0x80; i++)
                        eap1371_src_write(sc, i, 0);
d645 4
a648 4
                eap1371_src_write(sc, ESRC_DAC1+ESRC_IREGS, ESRC_SET_VFI(16));
                eap1371_src_write(sc, ESRC_DAC2+ESRC_IREGS, ESRC_SET_VFI(16));
                eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(16));
                eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(16));
d653 5
a657 5
                eap1371_set_adc_rate(sc, 22050);
                eap1371_set_dac_rate(sc, 22050, 1);
                eap1371_set_dac_rate(sc, 22050, 2);
             
                EWRITE4(sc, E1371_SRC, 0);
d659 1
a659 1
                /* Reset codec */
a664 1

d668 1
a668 1
		if ((error = ac97_attach(&sc->host_if)) == 0) {
a688 1
		
d695 1
a695 1
        }
d701 1
a701 3
eap1371_attach_codec(sc_, codec_if)
	void *sc_;
	struct ac97_codec_if  *codec_if;
d710 1
a710 2
eap1371_reset_codec(sc_)
	void *sc_;
d713 5
a717 2
	u_int32_t icsc = EREAD4(sc, EAP_ICSC);
	
d719 1
a719 1
	delay(100);
d721 2
d728 1
a728 2
eap_intr(p)
	void *p;
d739 1
d761 1
d777 1
a777 5
eap_allocmem(sc, size, align, p)
	struct eap_softc *sc;
	size_t size;
	size_t align;
	struct eap_dma *p;
d814 1
a814 3
eap_freemem(sc, p)
	struct eap_softc *sc;
	struct eap_dma *p;
d824 1
a824 3
eap_open(addr, flags)
	void *addr;
	int flags;
d833 1
a833 2
eap_close(addr)
	void *addr;
d845 1
a845 3
eap_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d902 2
a903 4
eap_set_params(addr, setmode, usemode, play, rec)
	void *addr;
	int setmode, usemode;
	struct audio_params *play, *rec;
d955 1
a955 1
					p->sw_code = swap_bytes_change_sign16;
d957 1
a957 1
					p->sw_code = change_sign16_swap_bytes;
d962 1
a962 1
				p->sw_code = change_sign16;
d967 1
a967 1
				p->sw_code = mulaw_to_slinear16;
d974 1
a974 1
				p->sw_code = alaw_to_slinear16;
d983 1
a983 1
        if (sc->sc_1371) {
d988 20
a1007 20
                /* Set the speed */
                DPRINTFN(2, ("eap_set_params: old ICSC = 0x%08x\n", 
                             EREAD4(sc, EAP_ICSC)));
                div = EREAD4(sc, EAP_ICSC) & ~EAP_PCLKBITS;
                /*
                 * XXX
                 * The -2 isn't documented, but seemed to make the wall 
                 * time match
                 * what I expect.  - mycroft
                 */
                if (usemode == AUMODE_RECORD)
                        div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / 
                                rec->sample_rate - 2);
                else
                        div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / 
                                play->sample_rate - 2);
                div |= EAP_CCB_INTRM;
                EWRITE4(sc, EAP_ICSC, div);
                DPRINTFN(2, ("eap_set_params: set ICSC = 0x%08x\n", div));
        }
d1013 1
a1013 3
eap_round_blocksize(addr, blk)
	void *addr;
	int blk;
d1019 8
a1026 7
eap_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr) __P((void *));
	void *arg;
	struct audio_params *param;
a1031 1
	int idx;
d1040 1
a1040 1
            "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));
d1045 1
a1045 1
	sic &= ~(EAP_P2_S_EB | EAP_P2_S_MB | EAP_INC_BITS | EAP_P2_INTR_EN);
d1056 1
a1056 3

	DPRINTFN(1, ("set SIC=0x%08x\n", sic));
	EWRITE4(sc, EAP_SIC, sic);
d1068 1
a1068 1
		 EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));
a1074 1
	icsc = EREAD4(sc, EAP_ICSC);
d1079 2
a1080 1
      	EWRITE4(sc, EAP_ICSC, icsc | EAP_DAC2_EN);
d1082 1
a1082 11

	for (idx = 0; idx < 3; idx++) {
		DPRINTFN (1, ("icsc=%08x sic=%08x dac2csr=%08x icss=%08x src=%08x\n",
		    EREAD4(sc, EAP_ICSC), 
		    EREAD4(sc, EAP_SIC),
		    EREAD4(sc, EAP_DAC2_CSR),
		    EREAD4(sc, EAP_ICSS),
		    EREAD4(sc, E1371_SRC)));

		delay(1000);
	}
a1086 2


d1088 8
a1095 7
eap_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr) __P((void *));
	void *arg;
	struct audio_params *param;
d1124 2
a1125 3
	DPRINTFN(1, ("set SIC=0x%08x\n", sic));

	EWRITE4(sc, EAP_SIC, sic);
d1136 1
a1136 1
		 EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));
d1156 1
a1156 2
eap_halt_output(addr)
	void *addr;
d1171 1
a1171 2
eap_halt_input(addr)
	void *addr;
d1186 1
a1186 3
eap_getdev(addr, retp)
	void *addr;
	struct audio_device *retp;
d1193 1
a1193 3
eap1371_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1197 1
a1197 2
	return ((sc->codec_if->vtbl->mixer_set_port)(sc->codec_if,
						     cp));
d1201 1
a1201 3
eap1371_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1205 1
a1205 2
	return ((sc->codec_if->vtbl->mixer_get_port)(sc->codec_if,
						     cp));
d1209 1
a1209 3
eap1371_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d1213 1
a1213 1
	return ((sc->codec_if->vtbl->query_devinfo)(sc->codec_if, dip));
d1217 2
a1218 3
eap1371_get_portnum_by_name(sc, class, device, qualifier)
	struct eap_softc *sc;
	char *class, *device, *qualifier;
d1220 2
a1221 2
	return ((sc->codec_if->vtbl->get_portnum_by_name)(sc->codec_if, class,
             device, qualifier));
d1225 1
a1225 3
eap_set_mixer(sc, a, d)
	struct eap_softc *sc;
	int a, d;
d1227 1
a1227 1
	eap_write_codec(sc, a, d);
d1229 2
a1230 2
        sc->sc_port[a] = d;
        DPRINTFN(1, ("eap_mixer_set_port port 0x%02x = 0x%02x\n", a, d));
d1234 1
a1234 3
eap_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1257 4
a1260 4
		eap_set_mixer(sc, AK_IN_MIXER1_L, l1);		
		eap_set_mixer(sc, AK_IN_MIXER1_R, r1);
		eap_set_mixer(sc, AK_IN_MIXER2_L, l2);
		eap_set_mixer(sc, AK_IN_MIXER2_R, r2);
d1280 2
a1281 2
		eap_set_mixer(sc, AK_OUT_MIXER1, o1);
		eap_set_mixer(sc, AK_OUT_MIXER2, o2);
d1290 1
a1290 1
		eap_set_mixer(sc, AK_MGAIN, cp->un.ord);
d1341 1
a1341 1
	eap_set_mixer(sc, la, l);
d1343 1
a1343 1
		eap_set_mixer(sc, ra, r);
d1349 1
a1349 3
eap_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1416 1
a1416 3
eap_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d1554 1
a1554 4
eap_malloc(addr, size, pool, flags)
	void *addr;
	u_long size;
	int pool, flags;
d1574 1
a1574 4
eap_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
d1577 1
a1577 1
	struct eap_dma **p;
d1579 5
a1583 5
	for (p = &sc->sc_dmas; *p; p = &(*p)->next) {
		if (KERNADDR(*p) == ptr) {
			eap_freemem(sc, *p);
			*p = (*p)->next;
			free(*p, pool);
d1590 1
a1590 3
eap_round_buffersize(addr, size)
	void *addr;
	u_long size;
d1596 1
a1596 5
eap_mappage(addr, mem, off, prot)
	void *addr;
	void *mem;
	int off;
	int prot;
d1612 1
a1612 2
eap_get_props(addr)
	void *addr;
d1615 1
a1615 1
                AUDIO_PROP_FULLDUPLEX);
@


1.11
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.10 2000/08/16 14:13:13 kevlo Exp $ */
d795 1
a795 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &ih)) {
@


1.10
log
@Fix AK4531 data sheet link. Ok'd by deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.9 2000/07/18 07:03:29 csapuntz Exp $ */
d782 1
a782 1
			   &sc->iot, &sc->ioh, NULL, NULL)) {
@


1.9
log
@

Reset AC97 codec on ES1371 revisions 7 and above. Thanks to Alejo Sanchez
for pointin this out.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.8 1999/12/13 06:43:01 csapuntz Exp $ */
d51 1
a51 1
 * http://206.214.38.151/pdf/4531.pdf
@


1.8
log
@

(hopefully) fix pauses reported by ES1370 users

Fix failure to start playing in my ES1371-based card. Was caused by a
disabled sample rate converter.

Support for newer ES1371 variants

Codec and sample-rate converter functions updated to reflect black magic
in FreeBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.7 1999/10/10 00:36:46 csapuntz Exp $ */
d774 1
d778 1
d861 5
a865 1
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880) {
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.10 2000/08/16 14:13:13 kevlo Exp $ */
d51 1
a51 1
 * http://www.akm.com/pdf/4531.pdf
a773 1
	int revision;
a776 1
	revision = PCI_REVISION(pa->pa_class);
d859 1
a859 5
		/* It seems that revision 7 and greater of the AUDIOPCI 97
		   are actually CT5880 */
		if ((PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880) ||
		    ((PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI97)
			&& (revision >= 7))) {
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.8.2.1 2001/05/14 22:25:39 niklas Exp $ */
d782 1
a782 1
			   &sc->iot, &sc->ioh, NULL, NULL, 0)) {
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*      $OpenBSD: eap.c,v 1.8.2.2 2001/07/04 10:42:01 niklas Exp $ */
/*	$NetBSD: eap.c,v 1.46 2001/09/03 15:07:37 reinoud Exp $ */
a43 2
 *
 * ES1371/AC97:	Ezra Story         <ezy@@panix.com>
d47 5
a51 1
 * Ensoniq ES1370 + AK4531 and ES1371/ES1373 + AC97
d53 4
a56 5
 * Documentation links:
 * 
 * ftp://ftp.alsa-project.org/pub/manuals/ensoniq/
 * ftp://ftp.alsa-project.org/pub/manuals/asahi_kasei/4531.pdf
 * ftp://download.intel.com/ial/scalableplatforms/audio/ac97r21.pdf
d58 1
a64 1
#include <sys/proc.h>
a76 2
#include <dev/pci/eapreg.h>

d83 214
d307 3
a309 3
int	eap_match(struct device *, void *, void *);
void	eap_attach(struct device *, struct device *, void *);
int	eap_intr(void *);
a318 1

d343 1
a343 1
	u_short	sc_port[AK_NPORTS];	/* mirror of the hardware setting */
d347 1
a347 1
	char    sc_1371;		/* Using ES1371/AC97 codec */
d353 2
a354 2
int	eap_allocmem(struct eap_softc *, size_t, size_t, struct eap_dma *);
int	eap_freemem(struct eap_softc *, struct eap_dma *);
d365 37
a401 37
int	eap_open(void *, int);
void	eap_close(void *);
int	eap_query_encoding(void *, struct audio_encoding *);
int	eap_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	eap_round_blocksize(void *, int);
int	eap_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	eap_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	eap_halt_output(void *);
int	eap_halt_input(void *);
void    eap1370_write_codec(struct eap_softc *, int, int);
int	eap_getdev(void *, struct audio_device *);
int	eap1370_mixer_set_port(void *, mixer_ctrl_t *);
int	eap1370_mixer_get_port(void *, mixer_ctrl_t *);
int	eap1371_mixer_set_port(void *, mixer_ctrl_t *);
int	eap1371_mixer_get_port(void *, mixer_ctrl_t *);
int	eap1370_query_devinfo(void *, mixer_devinfo_t *);
void   *eap_malloc(void *, u_long, int, int);
void	eap_free(void *, void *, int);
u_long	eap_round_buffersize(void *, u_long);
int	eap_mappage(void *, void *, int, int);
int	eap_get_props(void *);
void	eap1370_set_mixer(struct eap_softc *sc, int a, int d);
u_int32_t eap1371_src_wait(struct eap_softc *sc);
void 	eap1371_set_adc_rate(struct eap_softc *sc, int rate);
void 	eap1371_set_dac_rate(struct eap_softc *sc, int rate, int which);
int	eap1371_src_read(struct eap_softc *sc, int a);
void	eap1371_src_write(struct eap_softc *sc, int a, int d);
int	eap1371_query_devinfo(void *addr, mixer_devinfo_t *dip);

int     eap1371_attach_codec(void *sc, struct ac97_codec_if *);
int	eap1371_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	eap1371_write_codec(void *sc, u_int8_t a, u_int16_t d);
void    eap1371_reset_codec(void *sc);
int     eap1371_get_portnum_by_name(struct eap_softc *, char *, char *,
					 char *);
d420 3
a422 3
	eap1370_mixer_set_port,
	eap1370_mixer_get_port,
	eap1370_query_devinfo,
d468 4
a471 1
eap_match(struct device *parent, void *match, void *aux)
d475 9
a483 16
	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_CREATIVELABS:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_CREATIVELABS_EV1938:
			return (1);
		}
		break;
	case PCI_VENDOR_ENSONIQ:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ENSONIQ_AUDIOPCI:
		case PCI_PRODUCT_ENSONIQ_AUDIOPCI97:
		case PCI_PRODUCT_ENSONIQ_CT5880:
			return (1);
		}
		break;
	}
d489 3
a491 1
eap1370_write_codec(struct eap_softc *sc, int a, int d)
d493 1
d495 1
a495 1

d500 4
a503 5
		if (!to--) {
			printf("%s: timeout writing to codec\n",
			    sc->sc_dev.dv_xname);
			return;
		}
d505 1
a505 1
	EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));
a507 4
/*
 * Reading and writing the CODEC is very convoluted.  This mimics the
 * FreeBSD and Linux drivers.
 */
d509 5
a513 2
static __inline void
eap1371_ready_codec(struct eap_softc *sc, u_int8_t a, u_int32_t wd)
d515 25
a539 2
	int to, s;
	u_int32_t src, t;
d542 2
a543 1
		if (!(EREAD4(sc, E1371_CODEC) & E1371_CODEC_WIP))
d545 1
d548 2
a549 3
	if (to >= EAP_WRITE_TIMEOUT)
		printf("%s: eap1371_ready_codec timeout 1\n", 
		       sc->sc_dev.dv_xname);
d551 2
a552 3
	s = splaudio();
	src = eap1371_src_wait(sc) & E1371_SRC_CTLMASK;
	EWRITE4(sc, E1371_SRC, src | E1371_SRC_STATE_OK);
d555 1
a555 2
		t = EREAD4(sc, E1371_SRC);
		if ((t & E1371_SRC_STATE_MASK) == 0)
a556 1
		delay(1);
a557 3
	if (to >= EAP_READ_TIMEOUT)
		printf("%s: eap1371_ready_codec timeout 2\n", 
		       sc->sc_dev.dv_xname);
d559 2
a560 5
	for (to = 0; to < EAP_READ_TIMEOUT; to++) {
		t = EREAD4(sc, E1371_SRC);
		if ((t & E1371_SRC_STATE_MASK) == E1371_SRC_STATE_OK)
			break;
		delay(1);
a561 3
	if (to >= EAP_READ_TIMEOUT)
		printf("%s: eap1371_ready_codec timeout 3\n", 
		       sc->sc_dev.dv_xname);
d563 1
a563 1
	EWRITE4(sc, E1371_CODEC, wd);
d565 1
a565 2
	eap1371_src_wait(sc);
	EWRITE4(sc, E1371_SRC, src);
d567 1
a567 1
	splx(s);
d571 4
a574 1
eap1371_read_codec(void *sc_, u_int8_t a, u_int16_t *d)
d577 15
a591 2
	int to;
	u_int32_t t;
d593 1
a593 1
	eap1371_ready_codec(sc, a, E1371_SET_CODEC(a, 0) | E1371_CODEC_READ);
d596 1
a596 1
		if (!(EREAD4(sc, E1371_CODEC) & E1371_CODEC_WIP))
d598 2
d601 1
a601 4
	if (to > EAP_WRITE_TIMEOUT)
		printf("%s: eap1371_read_codec timeout 1\n", 
		       sc->sc_dev.dv_xname);

d603 2
a604 2
		t = EREAD4(sc, E1371_CODEC);
		if (t & E1371_CODEC_VALID)
d606 2
a608 3
	if (to > EAP_WRITE_TIMEOUT)
		printf("%s: eap1371_read_codec timeout 2\n", 
		       sc->sc_dev.dv_xname);
d610 1
a610 1
	*d = (u_int16_t)t;
d612 4
a615 1
	DPRINTFN(10, ("eap1371: reading codec (%x) = %x\n", a, *d));
d617 1
a617 1
	return (0);
d621 2
a622 1
eap1371_write_codec(void *sc_, u_int8_t a, u_int16_t d)
d624 2
a625 8
	struct eap_softc *sc = sc_;

	eap1371_ready_codec(sc, a, E1371_SET_CODEC(a, d));

        DPRINTFN(10, ("eap1371: writing codec %x --> %x\n", d, a));

	return (0);
}
a626 6
u_int32_t
eap1371_src_wait(struct eap_softc *sc)
{
	int to;
	u_int32_t src;
	
d630 1
a630 1
			return (src);
d633 6
a638 2
	printf("%s: eap1371_src_wait timeout\n", sc->sc_dev.dv_xname);
	return (src);
d642 3
a644 1
eap1371_src_read(struct eap_softc *sc, int a)
d646 4
a649 2
	int to;
	u_int32_t src, t;
d651 4
a654 3
	src = eap1371_src_wait(sc) & E1371_SRC_CTLMASK;
	src |= E1371_SRC_ADDR(a);
	EWRITE4(sc, E1371_SRC, src | E1371_SRC_STATE_OK);
d656 3
a658 1
	if ((eap1371_src_wait(sc) & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {
d660 3
a662 4
			t = EREAD4(sc, E1371_SRC);
			if ((t & E1371_SRC_STATE_MASK) == E1371_SRC_STATE_OK)
				break;
			delay(1);
d666 4
a669 1
	EWRITE4(sc, E1371_SRC, src);
d671 1
a671 1
	return t & E1371_SRC_DATAMASK;
d675 9
a683 5
eap1371_src_write(struct eap_softc *sc, int a, int d)
{
	u_int32_t r;

	r = eap1371_src_wait(sc) & E1371_SRC_CTLMASK;
d689 3
a691 1
eap1371_set_adc_rate(struct eap_softc *sc, int rate)
a694 1
	int s;
d696 1
a696 1
	/* Whatever, it works, so I'll leave it :) */
d698 12
a709 12
	if (rate > 48000)
		rate = 48000;
	if (rate < 4000)
		rate = 4000;
	n = rate / 3000;
	if ((1 << n) & SRC_MAGIC)
		n--;
	truncm = ((21 * n) - 1) | 1;
	freq = ((48000 << 15) / rate) * n;
	if (rate >= 24000) {
		if (truncm > 239)
			truncm = 239;
d711 3
a713 3
	} else {
		if (truncm > 119)
			truncm = 119;
d715 1
a715 1
	}
d717 1
a717 2
	s = splaudio();
	eap1371_src_write(sc, ESRC_ADC+ESRC_TRUNC_N, out);
d720 2
a721 2
	out = eap1371_src_read(sc, ESRC_ADC+ESRC_IREGS) & 0xff;
	eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out | 
d723 3
a725 4
	eap1371_src_write(sc, ESRC_ADC+ESRC_VFF, freq & 0x7fff);
	eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(n));
	eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(n));
	splx(s);
d729 4
a732 1
eap1371_set_dac_rate(struct eap_softc *sc, int rate, int which)
d734 1
a734 1
	int dac = which == 1 ? ESRC_DAC1 : ESRC_DAC2;
a735 1
	int s;
d737 1
a737 1
	/* Whatever, it works, so I'll leave it :) */
d739 18
a756 20
	if (rate > 48000)
	    rate = 48000;
	if (rate < 4000)
	    rate = 4000;
	freq = ((rate << 15) + 1500) / 3000;
	
	s = splaudio();
	eap1371_src_wait(sc);
	r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | 
	    E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);
	r |= (which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2;
	EWRITE4(sc, E1371_SRC, r);
	r = eap1371_src_read(sc, dac + ESRC_IREGS) & 0x00ff;
	eap1371_src_write(sc, dac + ESRC_IREGS, r | ((freq >> 5) & 0xfc00));
	eap1371_src_write(sc, dac + ESRC_VFF, freq & 0x7fff);
	r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | 
	    E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);
	r &= ~(which == 1 ? E1371_SRC_DISP1 : E1371_SRC_DISP2);
	EWRITE4(sc, E1371_SRC, r);
	splx(s);
d760 4
a763 1
eap_attach(struct device *parent, struct device *self, void *aux)
d774 1
a774 5
	int revision, ct5880;

	/* Flag if we're "creative" */
	sc->sc_1371 = !(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ENSONIQ &&
			PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI);
d776 2
a778 9
	if (sc->sc_1371) {
		if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ENSONIQ &&
		    ((PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI97 &&
		     (revision == EAP_ES1373_8 || revision == EAP_CT5880_A)) ||
		     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880))
			ct5880 = 1;
		else
			ct5880 = 0;
	}
d783 1
d795 3
a797 2
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
d804 2
a805 1
		printf(": couldn't establish interrupt");
d822 3
a824 3
		eap1370_write_codec(sc, AK_RESET, AK_PD); 
		eap1370_write_codec(sc, AK_RESET, AK_PD | AK_NRST);
		eap1370_write_codec(sc, AK_CS, 0x0);
d854 1
a854 1
		/* clean slate */
d856 1
d858 9
a866 2
		EWRITE4(sc, EAP_ICSC, 0);
		EWRITE4(sc, E1371_LEGACY, 0);
d868 1
a868 4
		if (ct5880) {
			EWRITE4(sc, EAP_ICSS, EAP_CT5880_AC97_RESET);
			/* Let codec wake up */
			tsleep(sc, PRIBIO, "eapcdc", hz / 20);
d876 7
a882 8
		/*
		 * Must properly reprogram sample rate converter,
		 * or it locks up.  Set some defaults for the life of the
		 * machine, and set up a sb default sample rate.
		 */
		EWRITE4(sc, E1371_SRC, E1371_SRC_DISABLE);
		for (i = 0; i < 0x80; i++)
			eap1371_src_write(sc, i, 0);
d885 4
a888 4
		eap1371_src_write(sc, ESRC_DAC1+ESRC_IREGS, ESRC_SET_VFI(16));
		eap1371_src_write(sc, ESRC_DAC2+ESRC_IREGS, ESRC_SET_VFI(16));
		eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(16));
		eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(16));
d893 5
a897 5
		eap1371_set_adc_rate(sc, 22050);
		eap1371_set_dac_rate(sc, 22050, 1);
		eap1371_set_dac_rate(sc, 22050, 2);
	     
		EWRITE4(sc, E1371_SRC, 0);
d899 1
a899 1
		/* Reset codec */
d905 1
d909 1
a909 1
		if (ac97_attach(&sc->host_if) == 0) {
d930 1
d937 1
a937 1
	}
d943 3
a945 1
eap1371_attach_codec(void *sc_, struct ac97_codec_if *codec_if)
d954 2
a955 1
eap1371_reset_codec(void *sc_)
d958 2
a959 5
	u_int32_t icsc;
	int s;

	s = splaudio();
	icsc = EREAD4(sc, EAP_ICSC);
d961 1
a961 1
	delay(20);
a962 2
	delay(1);
	splx(s);
d968 2
a969 1
eap_intr(void *p)
a979 1
#if 0
a1000 1
#endif
d1016 5
a1020 1
eap_allocmem(struct eap_softc *sc, size_t size, size_t align, struct eap_dma *p)
d1057 3
a1059 1
eap_freemem(struct eap_softc *sc, struct eap_dma *p)
d1069 3
a1071 1
eap_open(void *addr, int flags)
d1080 2
a1081 1
eap_close(void *addr)
d1093 3
a1095 1
eap_query_encoding(void *addr, struct audio_encoding *fp)
d1152 4
a1155 2
eap_set_params(void *addr, int setmode, int usemode,
	       struct audio_params *play, struct audio_params *rec)
d1207 1
a1207 1
					p->sw_code = swap_bytes_change_sign16_le;
d1209 1
a1209 1
					p->sw_code = change_sign16_swap_bytes_le;
d1214 1
a1214 1
				p->sw_code = change_sign16_le;
d1219 1
a1219 1
				p->sw_code = mulaw_to_slinear16_le;
d1226 1
a1226 1
				p->sw_code = alaw_to_slinear16_le;
d1235 1
a1235 1
	if (sc->sc_1371) {
d1240 20
a1259 20
		/* Set the speed */
		DPRINTFN(2, ("eap_set_params: old ICSC = 0x%08x\n", 
			     EREAD4(sc, EAP_ICSC)));
		div = EREAD4(sc, EAP_ICSC) & ~EAP_PCLKBITS;
		/*
		 * XXX
		 * The -2 isn't documented, but seemed to make the wall 
		 * time match
		 * what I expect.  - mycroft
		 */
		if (usemode == AUMODE_RECORD)
			div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / 
				rec->sample_rate - 2);
		else
			div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / 
				play->sample_rate - 2);
		div |= EAP_CCB_INTRM;
		EWRITE4(sc, EAP_ICSC, div);
		DPRINTFN(2, ("eap_set_params: set ICSC = 0x%08x\n", div));
	}
d1265 3
a1267 1
eap_round_blocksize(void *addr, int blk)
d1273 7
a1279 8
eap_trigger_output(
	void *addr,
	void *start,
	void *end,
	int blksize,
	void (*intr)(void *),
	void *arg,
	struct audio_params *param)
d1285 1
d1294 1
a1294 1
	    "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));
d1299 1
a1299 1
	sic &= ~(EAP_P2_S_EB | EAP_P2_S_MB | EAP_INC_BITS);
d1310 3
a1312 1
	EWRITE4(sc, EAP_SIC, sic & ~EAP_P2_INTR_EN);
d1324 1
a1324 1
		 (int)EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));
d1331 1
d1336 10
a1345 2
	icsc = EREAD4(sc, EAP_ICSC);
	EWRITE4(sc, EAP_ICSC, icsc | EAP_DAC2_EN);
d1347 2
a1348 1
	DPRINTFN(1, ("eap_trigger_output: set ICSC = 0x%08x\n", icsc));
d1353 2
d1356 7
a1362 8
eap_trigger_input(
	void *addr,
	void *start,
	void *end,
	int blksize,
	void (*intr)(void *),
	void *arg,
	struct audio_params *param)
d1391 3
a1393 2
	EWRITE4(sc, EAP_SIC, sic & ~EAP_R1_INTR_EN);
	EWRITE4(sc, EAP_SIC, sic | EAP_R1_INTR_EN);
d1404 1
a1404 1
		 (int)EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));
d1424 2
a1425 1
eap_halt_output(void *addr)
d1440 2
a1441 1
eap_halt_input(void *addr)
d1456 3
a1458 1
eap_getdev(void *addr, struct audio_device *retp)
d1465 3
a1467 1
eap1371_mixer_set_port(void *addr, mixer_ctrl_t *cp)
d1471 2
a1472 1
	return (sc->codec_if->vtbl->mixer_set_port(sc->codec_if, cp));
d1476 3
a1478 1
eap1371_mixer_get_port(void *addr, mixer_ctrl_t *cp)
d1482 2
a1483 1
	return (sc->codec_if->vtbl->mixer_get_port(sc->codec_if, cp));
d1487 3
a1489 1
eap1371_query_devinfo(void *addr, mixer_devinfo_t *dip)
d1493 1
a1493 1
	return (sc->codec_if->vtbl->query_devinfo(sc->codec_if, dip));
d1497 3
a1499 2
eap1371_get_portnum_by_name(struct eap_softc *sc,
			    char *class, char *device, char *qualifier)
d1501 2
a1502 2
	return (sc->codec_if->vtbl->get_portnum_by_name(sc->codec_if, class,
	     device, qualifier));
d1506 3
a1508 1
eap1370_set_mixer(struct eap_softc *sc, int a, int d)
d1510 1
a1510 1
	eap1370_write_codec(sc, a, d);
d1512 2
a1513 2
	sc->sc_port[a] = d;
	DPRINTFN(1, ("eap1370_mixer_set_port port 0x%02x = 0x%02x\n", a, d));
d1517 3
a1519 1
eap1370_mixer_set_port(void *addr, mixer_ctrl_t *cp)
d1542 4
a1545 4
		eap1370_set_mixer(sc, AK_IN_MIXER1_L, l1);		
		eap1370_set_mixer(sc, AK_IN_MIXER1_R, r1);
		eap1370_set_mixer(sc, AK_IN_MIXER2_L, l2);
		eap1370_set_mixer(sc, AK_IN_MIXER2_R, r2);
d1565 2
a1566 2
		eap1370_set_mixer(sc, AK_OUT_MIXER1, o1);
		eap1370_set_mixer(sc, AK_OUT_MIXER2, o2);
d1575 1
a1575 1
		eap1370_set_mixer(sc, AK_MGAIN, cp->un.ord);
d1626 1
a1626 1
	eap1370_set_mixer(sc, la, l);
d1628 1
a1628 1
		eap1370_set_mixer(sc, ra, r);
d1634 3
a1636 1
eap1370_mixer_get_port(void *addr, mixer_ctrl_t *cp)
d1703 3
a1705 1
eap1370_query_devinfo(void *addr, mixer_devinfo_t *dip)
d1843 4
a1846 1
eap_malloc(void *addr, u_long size, int pool, int flags)
d1866 4
a1869 1
eap_free(void *addr, void *ptr, int pool)
d1872 1
a1872 1
	struct eap_dma **pp, *p;
d1874 5
a1878 5
	for (pp = &sc->sc_dmas; (p = *pp) != NULL; pp = &p->next) {
		if (KERNADDR(p) == ptr) {
			eap_freemem(sc, p);
			*pp = p->next;
			free(p, pool);
d1885 3
a1887 1
eap_round_buffersize(void *addr, u_long size)
d1893 5
a1897 1
eap_mappage(void *addr, void *mem, int off, int prot)
d1913 2
a1914 1
eap_get_props(void *addr)
d1917 1
a1917 1
		AUDIO_PROP_FULLDUPLEX);
@


1.8.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d174 1
a174 1
paddr_t	eap_mappage(void *, void *, off_t, int);
d1594 2
a1595 2
paddr_t
eap_mappage(void *addr, void *mem, off_t off, int prot)
@


1.8.2.5
log
@Merge in trunk
@
text
@d171 1
a171 1
void   *eap_malloc(void *, int, size_t, int, int);
d173 1
a173 1
size_t	eap_round_buffersize(void *, int, size_t);
d1553 1
a1553 1
eap_malloc(void *addr, int direction, size_t size, int pool, int flags)
d1588 2
a1589 2
size_t
eap_round_buffersize(void *addr, int direction, size_t size)
@


1.8.2.6
log
@Sync the SMP branch with 3.3
@
text
@a254 7
const struct pci_matchid eap_devices[] = {
	{ PCI_VENDOR_CREATIVELABS, PCI_PRODUCT_CREATIVELABS_EV1938 },
	{ PCI_VENDOR_ENSONIQ, PCI_PRODUCT_ENSONIQ_AUDIOPCI },
	{ PCI_VENDOR_ENSONIQ, PCI_PRODUCT_ENSONIQ_AUDIOPCI97 },
	{ PCI_VENDOR_ENSONIQ, PCI_PRODUCT_ENSONIQ_CT5880 },
};

d258 20
a277 2
	return (pci_matchbyid((struct pci_attach_args *)aux, eap_devices,
	    sizeof(eap_devices)/sizeof(eap_devices[0])));
@


1.8.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.8.2.6 2003/03/28 00:38:21 niklas Exp $ */
d303 1
a303 1
	if (to == EAP_WRITE_TIMEOUT)
d317 1
a317 1
	if (to == EAP_READ_TIMEOUT)
d327 1
a327 1
	if (to == EAP_READ_TIMEOUT)
d352 1
a352 1
	if (to == EAP_WRITE_TIMEOUT)
d361 1
a361 1
	if (to == EAP_WRITE_TIMEOUT)
d837 1
a837 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d843 1
a843 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d849 1
a849 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d855 1
a855 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d861 1
a861 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d867 1
a867 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d873 1
a873 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d879 1
a879 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1411 1
a1411 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1413 1
a1413 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1420 1
a1420 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1422 1
a1422 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1429 1
a1429 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d1431 1
a1431 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1438 1
a1438 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1440 1
a1440 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1447 1
a1447 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1449 1
a1449 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1456 1
a1456 1
		strlcpy(dip->label.name, AudioNaux, sizeof dip->label.name);
d1458 1
a1458 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1465 1
a1465 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1467 1
a1467 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1472 1
a1472 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1475 1
a1475 2
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[0].label.name);
d1477 1
a1477 2
		strlcpy(dip->un.s.member[1].label.name, AudioNcd,
		    sizeof dip->un.s.member[1].label.name);
d1479 1
a1479 2
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
d1481 1
a1481 2
		strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
		    sizeof dip->un.s.member[3].label.name);
d1483 1
a1483 2
		strlcpy(dip->un.s.member[4].label.name, AudioNaux,
		    sizeof dip->un.s.member[4].label.name);
d1485 1
a1485 2
		strlcpy(dip->un.s.member[5].label.name, AudioNdac,
		    sizeof dip->un.s.member[5].label.name);
d1491 1
a1491 1
		strlcpy(dip->label.name, AudioNselect, sizeof dip->label.name);
d1494 1
a1494 2
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[0].label.name);
d1496 1
a1496 2
		strlcpy(dip->un.s.member[1].label.name, AudioNcd,
		    sizeof dip->un.s.member[1].label.name);
d1498 1
a1498 2
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
d1500 1
a1500 2
		strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
		    sizeof dip->un.s.member[3].label.name);
d1502 1
a1502 2
		strlcpy(dip->un.s.member[4].label.name, AudioNaux,
		    sizeof dip->un.s.member[4].label.name);
d1504 1
a1504 2
		strlcpy(dip->un.s.member[5].label.name, AudioNdac,
		    sizeof dip->un.s.member[5].label.name);
d1512 1
a1512 1
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
d1514 1
a1514 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1516 1
a1516 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d1523 1
a1523 2
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof dip->label.name);
d1529 1
a1529 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d1535 1
a1535 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
@


1.8.2.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
a350 1
		delay(1);
a359 1
		delay(1);
@


1.8.2.9
log
@Merge with the trunk
@
text
@a138 2

	int flags;
a140 1
enum	ac97_host_flags eap_flags_codec(void *);
d657 1
a657 3
		sc->host_if.flags = eap_flags_codec;
		sc->flags = AC97_HOST_DONT_READ;
	
a1629 8
}

enum ac97_host_flags
eap_flags_codec(void *v)
{
      struct eap_softc *sc = v;

      return (sc->flags);
@


1.7
log
@

Print out the irq in attach. Thanks downsj@@cvs
@
text
@d1 1
a1 1
/*      $OpenBSD: eap.c,v 1.6 1999/10/05 19:24:42 csapuntz Exp $ */
d120 1
d144 2
d214 2
a215 2
#define EAP_READ_TIMEOUT	5000000
#define EAP_WRITE_TIMEOUT	5000000
d389 1
a389 1
void	eap1371_src_wait __P((struct eap_softc *sc));
d403 1
a403 1
struct audio_hw_if eap_hw_if = {
d432 29
d475 2
a476 1
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_ENSONIQ)
d478 5
a482 1
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI) {
a483 4
        }
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI97) {
		return (1);
        }
d494 3
a496 2
	int icss, to = EAP_WRITE_TIMEOUT;

d504 1
a504 1
	} while(to && icss & EAP_CWRIP);  /* XXX could use CSTAT here */
d517 1
a517 1
        int cdc;
d529 22
d552 1
a552 1
        EWRITE4(sc, E1371_CODEC, E1371_SET_CODEC(a, 0) | E1371_CODEC_READ);
d554 1
a554 1
	for (to = 0; to < EAP_WRITE_TIMEOUT; to++) {
d578 1
a578 1
        int cdc;
d590 22
d613 2
a614 1
        EWRITE4(sc, E1371_CODEC, E1371_SET_CODEC(a, d));
d620 1
a620 1
void
d627 12
a638 9
        to = EAP_READ_TIMEOUT;
        do {
                src = EREAD4(sc, E1371_SRC);    
                if (!to--) {
                        printf("eap: timeout waiting for sample rate"
                                "converter\n");
                        return;
                }
        } while (src & E1371_SRC_RBUSY);
d646 24
a669 1
	int r;
a670 6
	eap1371_src_wait(sc);
	r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |
				     E1371_SRC_DISP2 | E1371_SRC_DISREC);
	r |= E1371_SRC_ADDR(a);
	EWRITE4(sc, E1371_SRC, r);
	r = EREAD4(sc, E1371_SRC) & E1371_SRC_DATAMASK;
d681 3
a683 3
	eap1371_src_wait(sc);
	r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |
				     E1371_SRC_DISP2 | E1371_SRC_DISREC);
d743 1
a743 1
        freq = (rate << 15) / 3000;
d768 1
d775 3
a777 2
        /* Flag if we're "creative" */
	sc->sc_1371 = (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI97);
d824 1
a824 3
		eap_hw_if.query_devinfo = eap_query_devinfo;
		eap_hw_if.set_port = eap_mixer_set_port;
		eap_hw_if.get_port = eap_mixer_get_port;
d832 1
a832 1
		eap_hw_if.set_port(sc, &ctl);
d839 1
a839 1
			eap_hw_if.set_port(sc, &ctl);
d842 1
a842 1
		eap_hw_if.set_port(sc, &ctl);
d846 1
a846 1
		eap_hw_if.set_port(sc, &ctl);
d850 1
a850 1
		eap_hw_if.set_port(sc, &ctl);
d859 6
d899 1
d909 1
a909 3
		eap_hw_if.query_devinfo = eap1371_query_devinfo;
		eap_hw_if.set_port = eap1371_mixer_set_port;
		eap_hw_if.get_port = eap1371_mixer_get_port;
d933 1
a933 1
	audio_attach_mi(&eap_hw_if, sc, &sc->sc_dev);
d982 1
d996 1
a996 1
		EWRITE4(sc, EAP_SIC, sic);
d1002 1
a1002 1
		EWRITE4(sc, EAP_SIC, sic);
d1279 1
a1291 3
	icsc = EREAD4(sc, EAP_ICSC);
	EWRITE4(sc, EAP_ICSC, icsc & ~EAP_DAC2_EN);

d1293 1
a1293 1
	sic &= ~(EAP_P2_S_EB | EAP_P2_S_MB | EAP_INC_BITS);
d1304 2
d1307 1
d1324 7
a1330 1
	EWRITE2(sc, EAP_DAC2_CSR, (blksize >> sampshift) - 1);
a1331 1
	EWRITE4(sc, EAP_ICSC, icsc | EAP_DAC2_EN);
d1333 10
a1342 1
	DPRINTFN(1, ("eap_trigger_output: set ICSC = 0x%08x\n", icsc));
d1347 2
a1373 3
	icsc = EREAD4(sc, EAP_ICSC);
	EWRITE4(sc, EAP_ICSC, icsc & ~EAP_ADC_EN);

d1385 2
d1404 4
a1407 1
	EWRITE2(sc, EAP_ADC_CSR, (blksize >> sampshift) - 1);
d1409 1
@


1.6
log
@

Ensoniq ES1371 support.

Thanks to Ezra Story (ezy@@panix.com)
@
text
@d1 1
a1 1
/*      $OpenBSD: $ */
d708 1
a708 1
	printf(": %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.5
log
@simplify irq string
@
text
@d1 2
a2 2
/*	$OpenBSD: eap.c,v 1.4 1999/01/02 00:02:49 niklas Exp $	*/
/*	$NetBSD: eap.c,v 1.17 1998/08/25 04:56:01 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d8 2
a9 6
 * Author:      Lennart Augustsson <augustss@@cs.chalmers.se>
 *		Charles M. Hannum  <mycroft@@netbsd.org>
 *
 * Debugging:   Andreas Gustafsson <gson@@araneus.fi>
 * Testing:     Chuck Cranor       <chuck@@maria.wustl.edu>
 *              Phil Nelson        <phil@@cs.wwu.edu>
d40 6
d52 5
d58 1
d73 1
a76 4
#ifndef BUS_DMA_COHERENT
#define BUS_DMA_COHERENT 0	/* XXX */
#endif

d80 1
a80 1
 
d108 1
d129 43
d211 4
d267 1
d269 1
a269 1
#define AK_NPORTS 16
d271 1
d278 1
d281 2
a282 1
#define EAP_FM_VOL		2
d289 1
a289 1
#define	EAP_MIC_PREAMP		9
d294 1
d298 1
a298 5
#ifdef EAP_DEBUG
int	eapdebug = EAP_DEBUG;
#else
int	eapdebug = 0;
#endif
d316 2
a317 2
#define DMAADDR(map) ((map)->segs[0].ds_addr)
#define KERNADDR(map) ((void *)((map)->addr))
d340 1
a340 1
	u_char	sc_port[AK_NPORTS];	/* mirror of the hardware setting */
d344 4
d373 1
d377 2
d382 1
a382 1
u_long	eap_round __P((void *, u_long));
a384 1
void	eap_write_codec __P((struct eap_softc *sc, int a, int d));
d386 13
d422 1
a422 1
	eap_round,
d438 2
a439 1
	void *match, *aux;
d445 6
a450 2
	if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_ENSONIQ_AUDIOPCI)
		return (0);
d452 1
a452 1
	return (1);
d460 2
a461 2
	int icss;
	int timeo = 4096;
d464 1
a464 1
	        icss = EREAD4(sc, EAP_ICSS);
d466 162
a627 2
		timeo--;
	} while((timeo > 0) && (icss & EAP_CWRIP));
d629 29
a657 4
	if (timeo == 0)
		DPRINTF(("eap: codec write timeout, %d prog: icss=0x%08x\n",
		    a, icss));
	EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));
a669 2
	bus_addr_t iobase;
	bus_size_t iosize;
d673 1
d675 2
d678 2
a679 5
	if (pci_io_find(pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize)) {
		printf("\n%s: can't find i/o base\n", sc->sc_dev.dv_xname);
		return;
	}
	if (bus_space_map(sc->iot, iobase, iosize, 0, &sc->ioh)) {
d693 1
a693 1
	    pa->pa_intrline, &ih)) {
d698 2
a699 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, eap_intr, sc,
	    sc->sc_dev.dv_xname);
d702 1
a702 1
		    sc->sc_dev.dv_xname);
d708 134
a841 1
	printf(": %s\n", intrstr);
d843 10
a852 31
	/* Enable interrupts and looping mode. */
	EWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);
	EWRITE4(sc, EAP_ICSC, EAP_CDC_EN); /* enable the parts we need */

	eap_write_codec(sc, AK_RESET, AK_PD); /* reset codec */
	eap_write_codec(sc, AK_RESET, AK_PD | AK_NRST);	/* normal operation */
	eap_write_codec(sc, AK_CS, 0x0); /* select codec clocks */

	/* Enable all relevant mixer switches. */
	ctl.dev = EAP_OUTPUT_SELECT;
	ctl.type = AUDIO_MIXER_SET;
	ctl.un.mask = 1 << EAP_VOICE_VOL | 1 << EAP_FM_VOL | 1 << EAP_CD_VOL |
	    1 << EAP_LINE_VOL | 1 << EAP_AUX_VOL | 1 << EAP_MIC_VOL;
	eap_mixer_set_port(sc, &ctl);

	ctl.type = AUDIO_MIXER_VALUE;
	ctl.un.value.num_channels = 1;
	for (ctl.dev = EAP_MASTER_VOL; ctl.dev < EAP_MIC_VOL; ctl.dev++) {
		ctl.un.value.level[AUDIO_MIXER_LEVEL_MONO] = VOL_0DB;
		eap_mixer_set_port(sc, &ctl);
	}
	ctl.un.value.level[AUDIO_MIXER_LEVEL_MONO] = 0;
	eap_mixer_set_port(sc, &ctl); /* set the mic to 0 */
	ctl.dev = EAP_MIC_PREAMP;
	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;
	eap_mixer_set_port(sc, &ctl);
	ctl.dev = EAP_RECORD_SOURCE;
	ctl.type = AUDIO_MIXER_SET;
	ctl.un.mask = 1 << EAP_MIC_VOL;
	eap_mixer_set_port(sc, &ctl);
d854 1
a854 1
        audio_attach_mi(&eap_hw_if, sc, &sc->sc_dev);
a961 1

d1048 2
a1049 1
	u_int32_t mode, div;
d1052 1
a1052 1
	 * This device only has one clock, so make the sample rates match.
d1054 6
a1059 5
	if (play->sample_rate != rec->sample_rate &&
	    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {
		if (setmode == AUMODE_PLAY) {
			rec->sample_rate = play->sample_rate;
			setmode |= AUMODE_RECORD;
d1061 2
a1062 2
			play->sample_rate = rec->sample_rate;
			setmode |= AUMODE_PLAY;
d1064 2
a1065 1
			return (EINVAL);
d1075 1
a1075 1
		if (p->sample_rate < 4000 || p->sample_rate > 50000 ||
d1124 25
a1148 16
	/* Set the speed */
	DPRINTFN(2, ("eap_set_params: old ICSC = 0x%08x\n", 
		     EREAD4(sc, EAP_ICSC)));
	div = EREAD4(sc, EAP_ICSC) & ~EAP_PCLKBITS;
	/*
	 * XXX
	 * The -2 isn't documented, but seemed to make the wall time match
	 * what I expect.  - mycroft
	 */
	if (usemode == AUMODE_RECORD)
		div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / rec->sample_rate - 2);
	else
		div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / play->sample_rate - 2);
	div |= EAP_CCB_INTRM;
	EWRITE4(sc, EAP_ICSC, div);
	DPRINTFN(2, ("eap_set_params: set ICSC = 0x%08x\n", div));
d1172 1
a1172 1
	u_int32_t mode;
d1181 2
a1182 2
	DPRINTFN(1, ("eap_trigger_output: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\n", 
	    addr, start, end, blksize, intr, arg));
d1186 6
a1191 2
	mode = EREAD4(sc, EAP_SIC) & ~(EAP_P2_S_EB | EAP_P2_S_MB | EAP_INC_BITS);
	mode |= EAP_SET_P2_ST_INC(0) | EAP_SET_P2_END_INC(param->precision * param->factor / 8);
d1194 1
a1194 1
		mode |= EAP_P2_S_EB;
d1198 1
a1198 1
		mode |= EAP_P2_S_MB;
d1201 1
a1201 1
	EWRITE4(sc, EAP_SIC, mode);
d1211 2
a1212 1
		 (int)DMAADDR(p), EAP_SET_SIZE(0, ((end - start) >> 2) - 1)));
d1215 2
a1216 1
	EWRITE4(sc, EAP_DAC2_SIZE, EAP_SET_SIZE(0, ((end - start) >> 2) - 1));
d1219 4
a1222 5
	mode = EREAD4(sc, EAP_ICSC) & ~EAP_DAC2_EN;
	EWRITE4(sc, EAP_ICSC, mode);
	mode |= EAP_DAC2_EN;
	EWRITE4(sc, EAP_ICSC, mode);
	DPRINTFN(1, ("eap_trigger_output: set ICSC = 0x%08x\n", mode));
d1238 1
a1238 1
	u_int32_t mode;
d1252 5
a1256 1
	mode = EREAD4(sc, EAP_SIC) & ~(EAP_R1_S_EB | EAP_R1_S_MB);
d1259 1
a1259 1
		mode |= EAP_R1_S_EB;
d1263 1
a1263 1
		mode |= EAP_R1_S_MB;
d1266 1
a1266 1
	EWRITE4(sc, EAP_SIC, mode);
d1276 2
a1277 1
		 (int)DMAADDR(p), EAP_SET_SIZE(0, ((end - start) >> 2) - 1)));
d1280 2
a1281 1
	EWRITE4(sc, EAP_ADC_SIZE, EAP_SET_SIZE(0, ((end - start) >> 2) - 1));
d1284 4
a1287 5
	mode = EREAD4(sc, EAP_ICSC) & ~EAP_ADC_EN;
	EWRITE4(sc, EAP_ICSC, mode);
	mode |= EAP_ADC_EN;
	EWRITE4(sc, EAP_ICSC, mode);
	DPRINTFN(1, ("eap_trigger_input: set ICSC = 0x%08x\n", mode));
d1297 1
a1297 1
	u_int32_t mode;
d1300 2
a1301 2
	mode = EREAD4(sc, EAP_ICSC) & ~EAP_DAC2_EN;
	EWRITE4(sc, EAP_ICSC, mode);
d1313 1
a1313 1
	u_int32_t mode;
d1316 2
a1317 2
	mode = EREAD4(sc, EAP_ICSC) & ~EAP_ADC_EN;
	EWRITE4(sc, EAP_ICSC, mode);
d1333 41
d1380 3
a1382 1
	DPRINTFN(1, ("eap_mixer_set_port port 0x%02x = 0x%02x\n", a, d));
a1384 1

a1495 1
	sc->sc_port[la] = l;
a1497 1
		sc->sc_port[ra] = r;
d1715 1
a1715 2
	int pool;
	int flags;
d1754 1
a1754 1
eap_round(addr, size)
d1771 2
d1785 2
a1786 1
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX);
@


1.4
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: eap.c,v 1.3 1998/11/03 21:06:39 downsj Exp $	*/
d447 1
a447 1
	printf(": interrupting at %s\n", intrstr);
@


1.3
log
@Update audio_hw_if, fix problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: eap.c,v 1.2 1998/10/28 18:06:46 downsj Exp $	*/
d481 1
a481 1
        audio_attach_mi(&eap_hw_if, 0, sc, &sc->sc_dev);
@


1.2
log
@Changes from NetBSD, clean up, avoid hanging if the codec is out to lunch.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a351 1
#ifdef notyet
a353 1
#endif
d383 1
a383 1
	int timeo = 512;
d386 1
a386 5
		icss = EREAD4(sc, EAP_ICSS);
		if (!(icss & EAP_CSTAT)) {
			EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));
			return;
		}
d389 6
a394 2
	} while(timeo > 0);
	DPRINTF(("eap: codec write timeout, %d prog: icss=0x%08x\n", a, icss));
d451 1
a451 1
	EWRITE4(sc, EAP_ICSC, EAP_CDC_EN|EAP_SERR_DISABLE|EAP_SET_PCLKDIV(EAP_XTAL_FREQ / 8000)); /* enable the parts we need */
@


1.1
log
@From NetBSD, Lennart Augustsson <augustss@@cs.chalmers.se>:
Add a driver for the Ensoniq AudioPCI sound card.  The driver still
needs some testing, but it seems to produce sound.  The driver was written
by me, but since I don't have the hardware the debugging and testing was
done by Andreas Gustafsson <gson@@araneus.fi>, Chuck Cranor
<chuck@@maria.wustl.edu>, and Phil Nelson <phil@@cs.wwu.edu>.  Thanks.
@
text
@d1 2
a2 1
/*	$NetBSD: eap.c,v 1.6 1998/05/26 13:28:03 augustss Exp $	*/
d9 1
a11 1
 *		Charles Hannum     <mycroft@@netbsd.org>
a67 1
/* NetBSD 1.3 backwards compatibility */
d70 2
a74 1
#endif
a129 1
#define  EAP_R1P2_BITS		0x0000003c
d231 5
a235 6
#define EAP_OUTPUT_CLASS	8
#define EAP_RECORD_CLASS	9
#define EAP_INPUT_CLASS		10

#define EAP_NDEVS		11

d240 3
d244 1
a249 2
#define __BROKEN_INDIRECT_CONFIG
#ifdef __BROKEN_INDIRECT_CONFIG
a250 3
#else
int	eap_match __P((struct device *, struct cfdata *, void *));
#endif
d256 5
a260 5
        caddr_t addr;
        bus_dma_segment_t segs[1];
        int nsegs;
        size_t size;
        struct eap_dma *next;
d272 1
a272 1
        struct eap_dma *sc_dmas;
d276 1
d278 1
d282 1
d284 1
a284 2

	int	sc_sampsize;		/* bytes / sample */
d288 2
d309 6
a314 6
int	eap_dma_init_output __P((void *, void *, int));
int	eap_dma_init_input __P((void *, void *, int));
int	eap_dma_output __P((void *, void *, int, void (*)(void *), void*));
int	eap_dma_input __P((void *, void *, int, void (*)(void *), void*));
int	eap_halt_in_dma __P((void *));
int	eap_halt_out_dma __P((void *));
d335 6
a340 6
	eap_dma_init_output,
	eap_dma_init_input,
	eap_dma_output,
	eap_dma_input,
	eap_halt_out_dma,
	eap_halt_in_dma,
d352 4
d367 1
a367 6
#ifdef __BROKEN_INDIRECT_CONFIG
	void *match;
#else
	struct cfdata *match;
#endif
	void *aux;
d385 1
d388 5
a392 1
	        icss = EREAD4(sc, EAP_ICSS);
d394 3
a396 2
	} while(icss & EAP_CWRIP);
	EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));
a412 1
	char devinfo[256];
a414 3
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)\n", devinfo, PCI_REVISION(pa->pa_class));

d417 1
a417 1
		printf("%s: can't find i/o base\n", sc->sc_dev.dv_xname);
a419 1
#if defined(__OpenBSD__)
d421 1
a421 5
#else
	if (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
	      &sc->iot, &sc->ioh, NULL, NULL)) {
#endif
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
d435 1
a435 1
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d442 1
a442 1
		printf("%s: couldn't establish interrupt",
d449 1
a449 1
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
d452 2
a453 2
        EWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);
        EWRITE4(sc, EAP_ICSC, EAP_CDC_EN); /* enable the parts we need */
d458 1
d460 6
a465 8
	eap_write_codec(sc, AK_OUT_MIXER1, 
			AK_M_FM_L | AK_M_FM_R |
			AK_M_LINE_L | AK_M_LINE_R |
			AK_M_CD_L | AK_M_CD_R);
	eap_write_codec(sc, AK_OUT_MIXER2, 
			AK_M_AUX_L | AK_M_AUX_R |
			AK_M_VOICE_L | AK_M_VOICE_R |
			AK_M_MONO2 | AK_M_MONO1);
d474 4
d493 3
a495 3
        intr = EREAD4(sc, EAP_ICSS);
        if (!(intr & EAP_INTR))
        	return (0);
d498 21
a518 21
        if (intr & EAP_I_ADC) {
        	/*
                 * XXX This is a hack!
                 * The EAP chip sometimes generates the recording interrupt
                 * while it is still transferring the data.  To make sure
                 * it has all arrived we busy wait until the count is right.
                 * The transfer we are waiting for is 8 longwords.
                 */
        	int s, nw, n;
                EWRITE4(sc, EAP_MEMPAGE, EAP_ADC_PAGE);
                s = EREAD4(sc, EAP_ADC_CSR);
                nw = ((s & 0xffff) + 1) / 4; /* # of words in DMA */
                n = 0;
                while (((EREAD4(sc, EAP_ADC_SIZE) >> 16) + 8) % nw == 0) {
                	delay(10);
                	if (++n > 100) {
                		printf("eapintr: dma fix timeout");
                                break;
                        }
                }
                /* Continue with normal interrupt handling. */
d521 4
a524 4
                if (sc->sc_rintr)
	        	sc->sc_rintr(sc->sc_rarg);
        }
        if (intr & EAP_I_DAC2) {
d527 3
a529 3
                if (sc->sc_pintr)
	        	sc->sc_pintr(sc->sc_parg);
        }
d538 1
a538 1
        struct eap_dma *p;
d577 1
a577 1
        struct eap_dma *p;
a590 1
	struct eap_softc *sc = addr;
d592 1
a592 6
        DPRINTF(("eap_open: sc=%p\n", sc));

        sc->sc_pintr = 0;
        sc->sc_rintr = 0;

        return (0);
d604 2
a605 2
        eap_halt_in_dma(sc);
        eap_halt_out_dma(sc);
d607 2
a608 2
        sc->sc_pintr = 0;
        sc->sc_rintr = 0;
d641 1
a641 1
        case 4:
d671 1
a671 1
eap_set_params(addr, setmode, usemode, p, r)
d674 1
a674 1
	struct audio_params *p, *r;
d677 71
a747 21
	void (*pswcode) __P((void *, u_char *buf, int cnt));
	void (*rswcode) __P((void *, u_char *buf, int cnt));
        u_int32_t mode, div;
        

        pswcode = rswcode = 0;
        switch (p->encoding) {
        case AUDIO_ENCODING_SLINEAR_BE:
        	if (p->precision == 16)
                	rswcode = pswcode = swap_bytes;
		else
			pswcode = rswcode = change_sign8;
		break;
        case AUDIO_ENCODING_SLINEAR_LE:
        	if (p->precision != 16)
			pswcode = rswcode = change_sign8;
        	break;
        case AUDIO_ENCODING_ULINEAR_BE:
        	if (p->precision == 16) {
			pswcode = swap_bytes_change_sign16;
			rswcode = change_sign16_swap_bytes;
d749 1
a749 26
		break;
        case AUDIO_ENCODING_ULINEAR_LE:
        	if (p->precision == 16)
			pswcode = rswcode = change_sign16;
        	break;
        case AUDIO_ENCODING_ULAW:
        	pswcode = mulaw_to_ulinear8;
                rswcode = ulinear8_to_mulaw;
                break;
        case AUDIO_ENCODING_ALAW:
                pswcode = alaw_to_ulinear8;
                rswcode = ulinear8_to_alaw;
                break;
        default:
        	return (EINVAL);
        }
	if (p->precision == 16)
		mode = EAP_P2_S_EB | EAP_R1_S_EB;
	else
		mode = 0;
        if (p->channels == 2)
        	mode |= EAP_P2_S_MB | EAP_R1_S_MB;
	else if (p->channels != 1)
		return (EINVAL);
        if (p->sample_rate < 4000 || p->sample_rate > 50000)
        	return (EINVAL);
d751 1
a751 11
	sc->sc_sampsize = p->precision / 8 * p->channels; /* bytes / sample */
        p->sw_code = pswcode;
        r->sw_code = rswcode;

        /* Set the encoding */
        mode |= EREAD4(sc, EAP_SIC) & ~(EAP_R1P2_BITS | EAP_INC_BITS);
	mode |= EAP_SET_P2_ST_INC(0) | EAP_SET_P2_END_INC(p->precision / 8);
        EWRITE4(sc, EAP_SIC, mode);
	DPRINTFN(2, ("eap_set_params: set SIC = 0x%08x\n", mode));

        /* Set the speed */
d755 9
a763 1
        div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / p->sample_rate - 2);
d765 1
a765 1
        EWRITE4(sc, EAP_ICSC, div);
d768 1
a768 1
        return (0);
d780 1
a780 1
eap_dma_init_input(addr, buf, cc)
d782 5
a786 2
	void *buf;
	int cc;
d790 8
d799 15
a813 7
	DPRINTF(("eap_dma_init_input: dma start loop input addr=%p cc=%d\n", 
		 buf, cc));
        for (p = sc->sc_dmas; p && KERNADDR(p) != buf; p = p->next)
		;
	if (!p) {
		printf("eap_dma_init_input: bad addr %p\n", buf);
		return (EINVAL);
d815 1
a815 7
	EWRITE4(sc, EAP_MEMPAGE, EAP_ADC_PAGE);
	EWRITE4(sc, EAP_ADC_ADDR, DMAADDR(p));
	EWRITE4(sc, EAP_ADC_SIZE, EAP_SET_SIZE(0, cc / 4 - 1));
	DPRINTF(("eap_dma_init_input: ADC_ADDR=0x%x, ADC_SIZE=0x%x\n",
		 (int)DMAADDR(p), EAP_SET_SIZE(0, cc / 4 - 1)));
	return (0);
}
d817 1
a817 11
int
eap_dma_init_output(addr, buf, cc)
	void *addr;
	void *buf;
	int cc;
{
	struct eap_softc *sc = addr;
	struct eap_dma *p;

	DPRINTF(("eap: dma start loop output buf=%p cc=%d\n", buf, cc));
        for (p = sc->sc_dmas; p && KERNADDR(p) != buf; p = p->next)
d820 1
a820 1
		printf("eap_dma_init_output: bad addr %p\n", buf);
d823 3
d828 9
a836 3
	EWRITE4(sc, EAP_DAC2_SIZE, EAP_SET_SIZE(0, cc / 4 - 1));
	DPRINTF(("eap_dma_init_output: DAC2_ADDR=0x%x, DAC2_SIZE=0x%x\n",
		 (int)DMAADDR(p), EAP_SET_SIZE(0, cc / 4 - 1)));
d841 1
a841 1
eap_dma_output(addr, p, cc, intr, arg)
d843 2
a844 2
	void *p;
	int cc;
d847 1
d850 1
d852 1
d854 4
a857 11
	DPRINTFN(sc->sc_prun ? 5 : 1, 
                 ("eap_dma_output: sc=%p buf=%p cc=%d intr=%p(%p)\n", 
                  addr, p, cc, intr, arg));
	sc->sc_pintr = intr;
	sc->sc_parg = arg;
	if (!sc->sc_prun) {
#if defined(DIAGNOSTIC) || defined(AUDIO_DEBUG)
	        if (sc->sc_sampsize == 0) {
        		printf("eap_dma_output: sampsize == 0\n");
                        return EINVAL;
                }
a858 25
		EWRITE2(sc, EAP_DAC2_CSR, cc / sc->sc_sampsize - 1);
		DPRINTFN(1, ("eap_dma_output: set DAC2_CSR = %d\n", 
			     cc / sc->sc_sampsize - 1));
		DPRINTFN(1, ("eap_dma_output: old ICSC = 0x%08x\n",
			     EREAD4(sc, EAP_ICSC)));
		mode = EREAD4(sc, EAP_ICSC) & ~EAP_DAC2_EN;
		EWRITE4(sc, EAP_ICSC, mode);
		mode |= EAP_DAC2_EN;
		EWRITE4(sc, EAP_ICSC, mode);
		DPRINTFN(1, ("eap_dma_output: set ICSC = 0x%08x\n", mode));
		sc->sc_prun = 1;
	}
        return (0);
}

int
eap_dma_input(addr, p, cc, intr, arg)
	void *addr;
	void *p;
	int cc;
	void (*intr) __P((void *));
	void *arg;
{
	struct eap_softc *sc = addr;
	u_int32_t mode;
d860 2
a861 2
	DPRINTFN(1, ("eap_dma_input: sc=%p buf=%p cc=%d intr=%p(%p)\n", 
		     addr, p, cc, intr, arg));
d864 18
a881 14
	if (!sc->sc_rrun) {
#if defined(DIAGNOSTIC) || defined(AUDIO_DEBUG)
	        if (sc->sc_sampsize == 0) {
        		printf("eap_dma_input: sampsize == 0\n");
                        return EINVAL;
                }
#endif
		EWRITE2(sc, EAP_ADC_CSR, cc / sc->sc_sampsize - 1);
		mode = EREAD4(sc, EAP_ICSC) & ~EAP_ADC_EN;
		EWRITE4(sc, EAP_ICSC, mode);
		mode |= EAP_ADC_EN;
		EWRITE4(sc, EAP_ICSC, mode);
		DPRINTFN(1, ("eap_dma_input: set ICSC = 0x%08x\n", mode));
		sc->sc_rrun = 1;
d883 15
a897 1
        return (0);
d901 1
a901 1
eap_halt_out_dma(addr)
d907 1
a907 1
        DPRINTF(("eap: eap_halt_out_dma\n"));
d910 1
d912 2
a913 1
        return (0);
d917 1
a917 1
eap_halt_in_dma(addr)
d923 1
a923 1
        DPRINTF(("eap: eap_halt_in_dma\n"));
d926 1
d928 2
a929 1
        return (0);
d935 1
a935 1
        struct audio_device *retp;
d938 1
a938 1
        return (0);
d944 1
a944 1
        int a, d;
d947 1
a947 1
        DPRINTFN(1, ("eap_mixer_set_port port 0x%02x = 0x%02x\n", a, d));
d958 1
a958 1
	int l1, r1, l2, r2, m;
d966 1
a966 1
			l2 |= AK_M_VOICE_L, r2 |= AK_M_VOICE_R;
d974 1
a974 1
			l2 |= AK_M_AUX_L, r2 |= AK_M_AUX_R;
d983 30
d1080 2
d1084 10
d1134 2
a1135 1
	}
d1202 1
a1202 1
		dip->next = AUDIO_MIXER_LAST;
d1212 1
a1212 1
		dip->un.s.num_mem = 5;
d1223 33
d1287 2
a1288 2
        struct eap_dma *p;
        int error;
d1290 10
a1299 10
        p = malloc(sizeof(*p), pool, flags);
        if (!p)
                return (0);
        error = eap_allocmem(sc, size, 16, p);
        if (error) {
                free(p, pool);
        	return (0);
        }
        p->next = sc->sc_dmas;
        sc->sc_dmas = p;
d1310 1
a1310 1
        struct eap_dma **p;
d1312 8
a1319 8
        for (p = &sc->sc_dmas; *p; p = &(*p)->next) {
                if (KERNADDR(*p) == ptr) {
                        eap_freemem(sc, *p);
                        *p = (*p)->next;
                        free(*p, pool);
                        return;
                }
        }
d1333 2
a1334 2
        void *mem;
        int off;
d1338 1
a1338 1
        struct eap_dma *p;
d1340 1
a1340 1
        for (p = sc->sc_dmas; p && KERNADDR(p) != mem; p = p->next)
d1352 1
a1352 1
	return (AUDIO_PROP_MMAP | AUDIO_PROP_FULLDUPLEX);
@


