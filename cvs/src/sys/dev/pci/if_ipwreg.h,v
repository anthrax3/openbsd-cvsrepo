head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.34
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.22
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.30
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.28
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.26
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.24
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.20
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.18
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.16
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.14
	OPENBSD_5_0:1.16.0.12
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.10
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.8
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.14.0.12
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.10
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13;
locks; strict;
comment	@ * @;


1.16
date	2008.08.28.15.08.38;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.28.14.40.44;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.26.19.14.40;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.12.13.31.26;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.12.13.23.30;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.13.20.52.13;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.05.09.07.16;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.05.19.54.03;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.05.19.39.22;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.05.17.46.07;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.27.21.22.14;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.27.21.21.16;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.27.21.19.43;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.27.21.16.45;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.27.21.10.22;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.20.12.50.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@i've lost the IF_PURGE() bits in the process...
use license.template while i'm here.
@
text
@/*	$OpenBSD: if_ipwreg.h,v 1.15 2008/08/28 14:40:44 damien Exp $	*/

/*-
 * Copyright (c) 2004-2008
 *      Damien Bergamini <damien.bergamini@@free.fr>. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#define IPW_NTBD	128
#define IPW_TBD_SZ	(IPW_NTBD * sizeof (struct ipw_bd))
#define IPW_NDATA	(IPW_NTBD / 2)
#define IPW_NRBD	128
#define IPW_RBD_SZ	(IPW_NRBD * sizeof (struct ipw_bd))
#define IPW_STATUS_SZ	(IPW_NRBD * sizeof (struct ipw_status))

#define IPW_CSR_INTR		0x0008
#define IPW_CSR_INTR_MASK	0x000c
#define IPW_CSR_INDIRECT_ADDR	0x0010
#define IPW_CSR_INDIRECT_DATA	0x0014
#define IPW_CSR_AUTOINC_ADDR	0x0018
#define IPW_CSR_AUTOINC_DATA	0x001c
#define IPW_CSR_RST		0x0020
#define IPW_CSR_CTL		0x0024
#define IPW_CSR_IO		0x0030
#define IPW_CSR_TX_BD_BASE	0x0200
#define IPW_CSR_TX_BD_SIZE	0x0204
#define IPW_CSR_RX_BD_BASE	0x0240
#define IPW_CSR_RX_STATUS_BASE	0x0244
#define IPW_CSR_RX_BD_SIZE	0x0248
#define IPW_CSR_TX_READ_INDEX	0x0280
#define IPW_CSR_RX_READ_INDEX	0x02a0
#define IPW_CSR_TABLE1_BASE	0x0380
#define IPW_CSR_TABLE2_BASE	0x0384
#define IPW_CSR_TX_WRITE_INDEX	0x0f80
#define IPW_CSR_RX_WRITE_INDEX	0x0fa0

/* possible flags for register IPW_CSR_INTR */
#define IPW_INTR_TX_TRANSFER	0x00000001
#define IPW_INTR_RX_TRANSFER	0x00000002
#define IPW_INTR_STATUS_CHANGE	0x00000010
#define IPW_INTR_COMMAND_DONE	0x00010000
#define IPW_INTR_FW_INIT_DONE	0x01000000
#define IPW_INTR_FATAL_ERROR	0x40000000
#define IPW_INTR_PARITY_ERROR	0x80000000

#define IPW_INTR_MASK							\
	(IPW_INTR_TX_TRANSFER | IPW_INTR_RX_TRANSFER |			\
	 IPW_INTR_STATUS_CHANGE | IPW_INTR_COMMAND_DONE |		\
	 IPW_INTR_FW_INIT_DONE | IPW_INTR_FATAL_ERROR |			\
	 IPW_INTR_PARITY_ERROR)

/* possible flags for register IPW_CSR_RST */
#define IPW_RST_PRINCETON_RESET	0x00000001
#define IPW_RST_SW_RESET	0x00000080
#define IPW_RST_MASTER_DISABLED	0x00000100
#define IPW_RST_STOP_MASTER	0x00000200

/* possible flags for register IPW_CSR_CTL */
#define IPW_CTL_CLOCK_READY	0x00000001
#define IPW_CTL_ALLOW_STANDBY	0x00000002
#define IPW_CTL_INIT		0x00000004

/* possible flags for register IPW_CSR_IO */
#define IPW_IO_GPIO1_ENABLE	0x00000008
#define IPW_IO_GPIO1_MASK	0x0000000c
#define IPW_IO_GPIO3_MASK	0x000000c0
#define IPW_IO_LED_OFF		0x00002000
#define IPW_IO_RADIO_DISABLED	0x00010000

#define IPW_STATE_ASSOCIATED		0x0004
#define IPW_STATE_ASSOCIATION_LOST	0x0008
#define IPW_STATE_SCAN_COMPLETE		0x0020
#define IPW_STATE_RADIO_DISABLED	0x0100
#define IPW_STATE_DISABLED		0x0200
#define IPW_STATE_SCANNING		0x0800

/* table1 offsets */
#define IPW_INFO_LOCK			480
#define IPW_INFO_APS_CNT		604
#define IPW_INFO_APS_BASE		608
#define IPW_INFO_CARD_DISABLED		628
#define IPW_INFO_CURRENT_CHANNEL	756
#define IPW_INFO_CURRENT_TX_RATE	768

/* table2 offsets */
#define IPW_INFO_CURRENT_SSID	48
#define IPW_INFO_CURRENT_BSSID	112

/* supported rates */
#define IPW_RATE_DS1	1
#define IPW_RATE_DS2	2
#define IPW_RATE_DS5	4
#define IPW_RATE_DS11	8

/* firmware binary image header */
struct ipw_firmware_hdr {
	uint32_t	version;
	uint32_t	main_size;	/* firmware size */
	uint32_t	ucode_size;	/* microcode size */
} __packed;

/* buffer descriptor */
struct ipw_bd {
	uint32_t	physaddr;
	uint32_t	len;
	uint8_t		flags;
#define IPW_BD_FLAG_TX_FRAME_802_3		0x00
#define IPW_BD_FLAG_TX_NOT_LAST_FRAGMENT	0x01
#define IPW_BD_FLAG_TX_FRAME_COMMAND		0x02
#define IPW_BD_FLAG_TX_FRAME_802_11		0x04
#define IPW_BD_FLAG_TX_LAST_FRAGMENT		0x08
	uint8_t		nfrag;	/* number of fragments */
	uint8_t		reserved[6];
} __packed;

/* status */
struct ipw_status {
	uint32_t	len;
	uint16_t	code;
#define IPW_STATUS_CODE_COMMAND		0
#define IPW_STATUS_CODE_NEWSTATE	1
#define IPW_STATUS_CODE_DATA_802_11	2
#define IPW_STATUS_CODE_DATA_802_3	3
#define IPW_STATUS_CODE_NOTIFICATION	4
	uint8_t		flags;
#define IPW_STATUS_FLAG_DECRYPTED	0x01
#define IPW_STATUS_FLAG_WEP_ENCRYPTED	0x02
	uint8_t		rssi;	/* received signal strength indicator */
} __packed;

/* data header */
struct ipw_hdr {
	uint32_t	type;
#define IPW_HDR_TYPE_SEND	33
	uint32_t	subtype;
	uint8_t		encrypted;
	uint8_t		encrypt;
	uint8_t		keyidx;
	uint8_t		keysz;
	uint8_t		key[IEEE80211_KEYBUF_SIZE];
	uint8_t		reserved[10];
	uint8_t		src_addr[IEEE80211_ADDR_LEN];
	uint8_t		dst_addr[IEEE80211_ADDR_LEN];
	uint16_t	fragmentsz;
} __packed;

/* command */
struct ipw_cmd {
	uint32_t	type;
#define IPW_CMD_ENABLE				2
#define IPW_CMD_SET_CONFIGURATION		6
#define IPW_CMD_SET_ESSID			8
#define IPW_CMD_SET_MANDATORY_BSSID		9
#define IPW_CMD_SET_MAC_ADDRESS			11
#define IPW_CMD_SET_MODE			12
#define IPW_CMD_SET_CHANNEL			14
#define IPW_CMD_SET_RTS_THRESHOLD		15
#define IPW_CMD_SET_FRAG_THRESHOLD		16
#define IPW_CMD_SET_POWER_MODE			17
#define IPW_CMD_SET_TX_RATES			18
#define IPW_CMD_SET_BASIC_TX_RATES		19
#define IPW_CMD_SET_WEP_KEY			20
#define IPW_CMD_SET_WEP_KEY_INDEX		25
#define IPW_CMD_SET_PRIVACY_FLAGS		26
#define IPW_CMD_ADD_MULTICAST			27
#define IPW_CMD_SET_BEACON_INTERVAL		29
#define IPW_CMD_SET_TX_POWER_INDEX		36
#define IPW_CMD_BROADCAST_SCAN			43
#define IPW_CMD_DISABLE				44
#define IPW_CMD_SET_DESIRED_BSSID		45
#define IPW_CMD_SET_SCAN_OPTIONS		46
#define IPW_CMD_PREPARE_POWER_DOWN		58
#define IPW_CMD_DISABLE_PHY			61
#define IPW_CMD_SET_MSDU_TX_RATES		62
#define IPW_CMD_SET_SECURITY_INFORMATION	67
#define IPW_CMD_SET_ASSOC_REQ			69
	uint32_t	subtype;
	uint32_t	seq;
	uint32_t	len;
	uint8_t		data[400];
	uint32_t	status;
	uint8_t		reserved[68];
} __packed;

/* possible values for command IPW_CMD_SET_POWER_MODE */
#define IPW_POWER_MODE_CAM	0
#define IPW_POWER_AUTOMATIC	6

/* possible values for command IPW_CMD_SET_MODE */
#define IPW_MODE_BSS		0
#define IPW_MODE_IBSS		1
#define IPW_MODE_MONITOR	2

/* possible flags for command IPW_CMD_SET_PRIVACY_FLAGS */
#define IPW_PRIVACYON	0x8

/* structure for command IPW_CMD_SET_WEP_KEY */
struct ipw_wep_key {
	uint8_t	idx;
	uint8_t	len;
	uint8_t	key[13];
} __packed;

/* structure for command IPW_CMD_SET_SECURITY_INFORMATION */
struct ipw_security {
	uint32_t	ciphers;
#define IPW_CIPHER_NONE		0x00000001
#define IPW_CIPHER_WEP40	0x00000002
#define IPW_CIPHER_TKIP		0x00000004
#define IPW_CIPHER_CCMP		0x00000010
#define IPW_CIPHER_WEP104	0x00000020
	uint16_t	reserved1;
	uint8_t		authmode;
#define IPW_AUTH_OPEN	0
#define IPW_AUTH_SHARED	1
	uint16_t	reserved2;
} __packed;

/* structure for command IPW_CMD_SET_SCAN_OPTIONS */
struct ipw_scan_options {
	uint32_t	flags;
#define IPW_SCAN_DO_NOT_ASSOCIATE	0x00000001
#define IPW_SCAN_MIXED_CELL		0x00000002
#define IPW_SCAN_PASSIVE		0x00000008
	uint32_t	channels;
} __packed;

/* structure for command IPW_CMD_SET_CONFIGURATION */
struct ipw_configuration {
	uint32_t	flags;
#define IPW_CFG_PROMISCUOUS	0x00000004
#define IPW_CFG_PREAMBLE_AUTO	0x00000010
#define IPW_CFG_IBSS_AUTO_START	0x00000020
#define IPW_CFG_802_1X_ENABLE	0x00004000
#define IPW_CFG_BSS_MASK	0x00008000
#define IPW_CFG_IBSS_MASK	0x00010000
	uint32_t	bss_chan;
	uint32_t	ibss_chan;
} __packed;

/* structure for command IPW_CMD_SET_ASSOC_REQ */
struct ipw_assoc_req {
	uint16_t	flags;
#define IPW_ASSOC_CAPINFO	0x0001
#define IPW_ASSOC_LINTVAL	0x0002
#define IPW_ASSOC_BSSID		0x0004	/* reassoc */
	uint16_t	capinfo;
	uint16_t	lintval;
	uint8_t		bssid[IEEE80211_ADDR_LEN];
	uint32_t	optie_len;
	uint8_t		optie[384];
} __packed;

#define IPW_MEM_EEPROM_CTL	0x00300040

#define IPW_EEPROM_MAC	0x21

#define IPW_EEPROM_DELAY	1	/* minimum hold time (microsecond) */

#define IPW_EEPROM_C	(1 << 0)	/* Serial Clock */
#define IPW_EEPROM_S	(1 << 1)	/* Chip Select */
#define IPW_EEPROM_D	(1 << 2)	/* Serial data input */
#define IPW_EEPROM_Q	(1 << 4)	/* Serial data output */

#define IPW_EEPROM_SHIFT_D	2
#define IPW_EEPROM_SHIFT_Q	4

/*
 * control and status registers access macros
 */
#define CSR_READ_1(sc, reg)						\
	bus_space_read_1((sc)->sc_st, (sc)->sc_sh, (reg))

#define CSR_READ_2(sc, reg)						\
	bus_space_read_2((sc)->sc_st, (sc)->sc_sh, (reg))

#define CSR_READ_4(sc, reg)						\
	bus_space_read_4((sc)->sc_st, (sc)->sc_sh, (reg))

#define CSR_WRITE_1(sc, reg, val)					\
	bus_space_write_1((sc)->sc_st, (sc)->sc_sh, (reg), (val))

#define CSR_WRITE_2(sc, reg, val)					\
	bus_space_write_2((sc)->sc_st, (sc)->sc_sh, (reg), (val))

#define CSR_WRITE_4(sc, reg, val)					\
	bus_space_write_4((sc)->sc_st, (sc)->sc_sh, (reg), (val))

#define CSR_WRITE_MULTI_1(sc, reg, buf, len)				\
	bus_space_write_multi_1((sc)->sc_st, (sc)->sc_sh, (reg), 	\
	    (buf), (len))

/*
 * indirect memory space access macros
 */
#define MEM_WRITE_1(sc, addr, val) do {					\
	CSR_WRITE_4((sc), IPW_CSR_INDIRECT_ADDR, (addr));		\
	CSR_WRITE_1((sc), IPW_CSR_INDIRECT_DATA, (val));		\
} while (/* CONSTCOND */0)

#define MEM_WRITE_2(sc, addr, val) do {					\
	CSR_WRITE_4((sc), IPW_CSR_INDIRECT_ADDR, (addr));		\
	CSR_WRITE_2((sc), IPW_CSR_INDIRECT_DATA, (val));		\
} while (/* CONSTCOND */0)

#define MEM_WRITE_4(sc, addr, val) do {					\
	CSR_WRITE_4((sc), IPW_CSR_INDIRECT_ADDR, (addr));		\
	CSR_WRITE_4((sc), IPW_CSR_INDIRECT_DATA, (val));		\
} while (/* CONSTCOND */0)

#define MEM_WRITE_MULTI_1(sc, addr, buf, len) do {			\
	CSR_WRITE_4((sc), IPW_CSR_INDIRECT_ADDR, (addr));		\
	CSR_WRITE_MULTI_1((sc), IPW_CSR_INDIRECT_DATA, (buf), (len));	\
} while (/* CONSTCOND */0)

/*
 * EEPROM access macro
 */
#define IPW_EEPROM_CTL(sc, val) do {					\
	MEM_WRITE_4((sc), IPW_MEM_EEPROM_CTL, (val));			\
	DELAY(IPW_EEPROM_DELAY);					\
} while (/* CONSTCOND */0)

@


1.15
log
@WPA support for ipw(4).
Did a lot of cleanup while I was there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipwreg.h,v 1.14 2006/02/26 19:14:40 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004-2006
d7 3
a9 9
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d11 7
a17 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.14
log
@prettify + u_int{8,16,32}_t -> uint{8,16,32}_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipwreg.h,v 1.13 2005/03/12 13:31:26 damien Exp $	*/
d185 1
a185 1
#define IPW_CMD_SET_WEP_FLAGS			26
d195 1
d197 1
d215 2
a216 2
/* possible flags for command IPW_CMD_SET_WEP_FLAGS */
#define IPW_WEPON	0x8
d230 2
d244 1
d255 1
a255 1
#define IPW_CFG_802_1x_ENABLE	0x00004000
d262 12
a273 1
/* EEPROM = Electrically Erasable Programmable Read-Only Memory */
d343 1
a343 1
} while (0)
@


1.13
log
@s/__attribute__((__packed__))/__packed/
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipwreg.h,v 1.12 2005/03/12 13:23:30 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005
d118 3
a120 3
	u_int32_t	version;
	u_int32_t	main_size;	/* firmware size */
	u_int32_t	ucode_size;	/* microcode size */
d125 3
a127 3
	u_int32_t	physaddr;
	u_int32_t	len;
	u_int8_t	flags;
d133 2
a134 2
	u_int8_t	nfrag;	/* number of fragments */
	u_int8_t	reserved[6];
d139 2
a140 2
	u_int32_t	len;
	u_int16_t	code;
d146 1
a146 1
	u_int8_t	flags;
d149 1
a149 1
	u_int8_t	rssi;	/* received signal strength indicator */
d154 1
a154 1
	u_int32_t	type;
d156 10
a165 10
	u_int32_t	subtype;
	u_int8_t	encrypted;
	u_int8_t	encrypt;
	u_int8_t	keyidx;
	u_int8_t	keysz;
	u_int8_t	key[IEEE80211_KEYBUF_SIZE];
	u_int8_t	reserved[10];
	u_int8_t	src_addr[IEEE80211_ADDR_LEN];
	u_int8_t	dst_addr[IEEE80211_ADDR_LEN];
	u_int16_t	fragmentsz;
d170 1
a170 1
	u_int32_t	type;
d196 6
a201 6
	u_int32_t	subtype;
	u_int32_t	seq;
	u_int32_t	len;
	u_int8_t	data[400];
	u_int32_t	status;
	u_int8_t	reserved[68];
d218 3
a220 3
	u_int8_t	idx;
	u_int8_t	len;
	u_int8_t	key[13];
d225 1
a225 1
	u_int32_t	ciphers;
d229 2
a230 2
	u_int16_t	reserved1;
	u_int8_t	authmode;
d233 1
a233 1
	u_int16_t	reserved2;
d238 1
a238 1
	u_int32_t	flags;
d241 1
a241 1
	u_int32_t	channels;
d246 1
a246 1
	u_int32_t	flags;
d253 2
a254 2
	u_int32_t	bss_chan;
	u_int32_t	ibss_chan;
@


1.12
log
@retrieve scan results from net80211 instead of reading NIC internal memory.
this fixes a bug with multiple AP's.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipwreg.h,v 1.11 2005/01/13 20:52:13 damien Exp $	*/
d121 1
a121 1
} __attribute__((__packed__));
d135 1
a135 1
} __attribute__((__packed__));
d150 1
a150 1
} __attribute__((__packed__));
d166 1
a166 1
} __attribute__((__packed__));
d202 1
a202 1
} __attribute__((__packed__));
d221 1
a221 1
} __attribute__((__packed__));
d234 1
a234 1
} __attribute__((__packed__));
d242 1
a242 1
} __attribute__((__packed__));
d255 1
a255 1
} __attribute__((__packed__));
@


1.11
log
@fix a critical bug that made the kernel crash under heavy upstream traffic
load. pointed out by jcs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipwreg.h,v 1.10 2005/01/05 09:07:16 jsg Exp $	*/
a254 18
} __attribute__((__packed__));

/* element in AP table */
struct ipw_node {
	u_int32_t	reserved1[2];
	u_int8_t	bssid[IEEE80211_ADDR_LEN];
	u_int8_t	chan;
	u_int8_t	rates;
	u_int16_t	reserved2;
	u_int16_t	capinfo;
	u_int16_t	reserved3;
	u_int16_t	intval;
	u_int8_t	reserved4[28];
	u_int8_t	essid[IEEE80211_NWID_LEN];
	u_int16_t	reserved5;
	u_int8_t	esslen;
	u_int8_t	reserved6[7];
	u_int8_t	rssi;
@


1.10
log
@Use $OpenBSD$ instead of $Id$. ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2004
@


1.9
log
@update net80211 AP list after scanning
@
text
@d1 1
a1 1
/*      $Id: if_ipwreg.h,v 1.8 2004/12/05 19:39:22 damien Exp $ */
@


1.8
log
@mostly cosmetic changes
@
text
@d1 1
a1 1
/*      $Id: if_ipwreg.h,v 1.7 2004/12/05 17:46:07 damien Exp $ */
d100 2
d255 18
@


1.7
log
@Clean Tx/Rx rings allocation and management.
@
text
@d1 1
a1 1
/*      $Id: if_ipwreg.h,v 1.6 2004/10/27 21:22:14 damien Exp $ */
d211 3
d227 1
a227 1
	u_int16_t	version;
d231 1
a231 2
	u_int8_t	replay_counters_number;
	u_int8_t	unicast_using_group;
d246 1
a246 1
#define IPW_CFG_PREAMBLE_LEN	0x00000010
d251 1
a251 1
	u_int32_t	channels;
@


1.6
log
@Read MAC address from EEPROM in ipw_attach(). The address is now known
before the firmware has been sent. Imported from iwi.
@
text
@d1 1
a1 1
/*      $Id: if_ipwreg.h,v 1.5 2004/10/27 21:21:16 damien Exp $ */
d30 1
a30 1
#define IPW_NTBD	256
d33 1
a33 1
#define IPW_NRBD	256
@


1.5
log
@Cache firmware into kernel memory instead of sending it directly. The
firmware is now sent only when the interface is turned up.
This paves the way for proper suspend/resume support.
@
text
@d1 1
a1 1
/*      $Id: if_ipwreg.h,v 1.4 2004/10/27 21:19:43 damien Exp $ */
a104 1
#define IPW_INFO_ADAPTER_MAC	8
d253 16
d316 8
@


1.4
log
@Add ipw_media_status() to report the current Tx rate properly.
This was imported from iwi.
@
text
@d1 1
a1 1
/*      $Id: if_ipwreg.h,v 1.3 2004/10/27 21:16:45 damien Exp $ */
d116 1
a116 1
struct ipw_fw_hdr {
d118 2
a119 2
	u_int32_t	fw_size;	/* firmware size */
	u_int32_t	uc_size;	/* microcode size */
@


1.3
log
@Import ipw_get_table() and ipw_get_radio() functions from iwi.
@
text
@d1 1
a1 1
/*      $Id: if_ipwreg.h,v 1.2 2004/10/27 21:10:22 damien Exp $ */
d108 6
@


1.2
log
@Mostly cosmetic changes to be consistent with iwi:
- update web url
- sed s/ *$//
- get if_ipwreg.h and if_ipwvar.h from dev/pci
- remove unused function MEM_READ_2()
- inline -> __inline
- 11.b -> .11b
- addition of comments
- sort registers by their addresses
@
text
@d1 1
a1 1
/*      $Id: if_ipwreg.h,v 1.1 2004/10/20 12:50:48 deraadt Exp $ */
a102 1
#define IPW_INFO_EEPROM_ADDRESS		816
@


1.1
log
@support for Intel 2100/2200BG/2915ABG wireless devices written by
damien.bergamini@@free.fr. This gets imported even though there is no
firmware in the tree.  This is a ridiculous situation: everything is
free, everything works, except Intel will not let us put a little
dinky firmware flat file into OpenBSD.  So OpenBSD is ready for Intel
whenever they are.

Are you a consumer?  Do you want to see this changed -- contact
jketreno@@linux.intel.com and tell him how you feel about this.  He is
likely someone who cannot do anything about it, though.  If anyone can
work up or down the chain around his department and get me contact
information for various people, I will compile and later publish such
a list.  Go do it people -- this is how things will change.  Get me
email addresses and phone numbers.
@
text
@d1 1
a1 1
/*      $Id: if_ipwreg.h,v 1.3 2004/09/05 14:31:08 damien Exp $ */
d46 2
a47 2
#define IPW_CSR_TABLE1_BASE	0x0380
#define IPW_CSR_TABLE2_BASE	0x0384
d51 1
d53 3
a56 4
#define IPW_CSR_TX_BD_BASE	0x0200
#define IPW_CSR_TX_BD_SIZE	0x0204
#define IPW_CSR_TX_READ_INDEX	0x0280
#define IPW_CSR_TX_WRITE_INDEX	0x0f80
d58 1
d82 1
a82 1
#define IPW_CTL_INIT_DONE	0x00000004
d272 1
a272 1
	    (buf), (len));
a276 1

d296 1
@

