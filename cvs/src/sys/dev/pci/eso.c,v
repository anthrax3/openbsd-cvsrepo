head	1.43;
access;
symbols
	OPENBSD_6_2:1.43.0.2
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.41.0.6
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.6
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.35.0.10
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.8
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.6
	OPENBSD_5_0:1.35.0.4
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.22.0.10
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.8
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.6
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.4
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.43
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.42;
commitid	qGgYgJTgEFuAoGj4;

1.42
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.41;
commitid	pi1a9KN0itEngOc4;

1.41
date	2016.01.14.00.07.32;	author jsg;	state Exp;
branches;
next	1.40;
commitid	zQmmjD9Yh0ylAtkj;

1.40
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.39;
commitid	RaOGL5SyOGOZylwx;

1.39
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.38;
commitid	OBNa5kfxQ2UXoiIw;

1.38
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.21.20.11.44;	author jakemsr;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.27.18.50.57;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.23.11.41.07;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.28.21.24.06;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.29.07.20.15;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2008.02.17.05.18.42;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.11.01.32.52;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.14.12.42.16;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.01.22.44.21;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.09.02.31.20;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.19.09.04.38;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.03.21.13.48;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.11.13.40.05;	author deraadt;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.12.05.18.35.33;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	99.12.04.21.39.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.08.08.19.16.25;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.08.05.18.10.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.08.05.17.42.58;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.08.05.05.32.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.08.04.23.38.03;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.25.40;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.42.02;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.8.2.8;

1.8.2.8
date	2003.05.13.19.35.05;	author ho;	state Exp;
branches;
next	;

1.14.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: eso.c,v 1.42 2016/09/14 06:12:19 ratchov Exp $	*/
/*	$NetBSD: eso.c,v 1.48 2006/12/18 23:13:39 kleink Exp $	*/

/*
 * Copyright (c) 1999, 2000, 2004 Klaus J. Klein
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * ESS Technology Inc. Solo-1 PCI AudioDrive (ES1938/1946) device driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>

#include <dev/ic/mpuvar.h>
#include <dev/ic/i8237reg.h>
#include <dev/pci/esoreg.h>
#include <dev/pci/esovar.h>

#include <machine/bus.h>
#include <machine/intr.h>

/*
 * XXX Work around the 24-bit implementation limit of the Audio 1 DMA
 * XXX engine by allocating through the ISA DMA tag.
 */
#if defined(__amd64__) || defined(__i386__)
#include "isa.h"
#if NISA > 0
#include <dev/isa/isavar.h>
#endif
#endif

#if defined(AUDIO_DEBUG) || defined(DEBUG)
#define	DPRINTF(x)	if (esodebug) printf x
int	esodebug = 0;
#else
#define	DPRINTF(x)
#endif

struct eso_dma {
	bus_dma_tag_t		ed_dmat;
	bus_dmamap_t		ed_map;
	caddr_t			ed_addr;
	bus_dma_segment_t	ed_segs[1];
	int			ed_nsegs;
	size_t			ed_size;
	struct eso_dma *	ed_next;
};

#define KVADDR(dma)	((void *)(dma)->ed_addr)
#define DMAADDR(dma)	((dma)->ed_map->dm_segs[0].ds_addr)

int eso_match(struct device *, void *, void *);
void eso_attach(struct device *, struct device *, void *);
int eso_activate(struct device *, int);
void eso_defer(struct device *);

struct cfattach eso_ca = {
	sizeof (struct eso_softc), eso_match, eso_attach, NULL,
	eso_activate
};

struct cfdriver eso_cd = {
	NULL, "eso", DV_DULL
};

/* PCI interface */
int eso_intr(void *);

/* MI audio layer interface */
int	eso_open(void *, int);
void	eso_close(void *);
int	eso_set_params(void *, int, int, struct audio_params *,
		    struct audio_params *);
int	eso_round_blocksize(void *, int);
int	eso_halt_output(void *);
int	eso_halt_input(void *);
int	eso_set_port(void *, mixer_ctrl_t *);
int	eso_get_port(void *, mixer_ctrl_t *);
int	eso_query_devinfo(void *, mixer_devinfo_t *);
void *	eso_allocm(void *, int, size_t, int, int);
void	eso_freem(void *, void *, int);
size_t	eso_round_buffersize(void *, int, size_t);
int	eso_get_props(void *);
int	eso_trigger_output(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
int	eso_trigger_input(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
void	eso_setup(struct eso_softc *, int, int);

struct audio_hw_if eso_hw_if = {
	eso_open,
	eso_close,
	eso_set_params,
	eso_round_blocksize,
	NULL,			/* commit_settings */
	NULL,			/* init_output */
	NULL,			/* init_input */
	NULL,			/* start_output */
	NULL,			/* start_input */
	eso_halt_output,
	eso_halt_input,
	NULL,			/* speaker_ctl */
	NULL,			/* setfd */
	eso_set_port,
	eso_get_port,
	eso_query_devinfo,
	eso_allocm,
	eso_freem,
	eso_round_buffersize,
	eso_get_props,
	eso_trigger_output,
	eso_trigger_input
};

const char * const eso_rev2model[] = {
	"ES1938",
	"ES1946",
	"ES1946 rev E"
};


/*
 * Utility routines
 */

/* Register access etc. */
uint8_t	eso_read_ctlreg(struct eso_softc *, uint8_t);
uint8_t	eso_read_mixreg(struct eso_softc *, uint8_t);
uint8_t	eso_read_rdr(struct eso_softc *);
void	eso_reload_master_vol(struct eso_softc *);
int	eso_reset(struct eso_softc *);
void	eso_set_gain(struct eso_softc *, uint);
int	eso_set_recsrc(struct eso_softc *, uint);
int	eso_set_monooutsrc(struct eso_softc *, uint);
int	eso_set_monoinbypass(struct eso_softc *, uint);
int	eso_set_preamp(struct eso_softc *, uint);
void	eso_write_cmd(struct eso_softc *, uint8_t);
void	eso_write_ctlreg(struct eso_softc *, uint8_t, uint8_t);
void	eso_write_mixreg(struct eso_softc *, uint8_t, uint8_t);

/* DMA memory allocation */
int	eso_allocmem(struct eso_softc *, size_t, size_t, size_t,
		    int, int, struct eso_dma *);
void	eso_freemem(struct eso_dma *);


int
eso_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ESSTECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ESSTECH_SOLO1)
		return (1);

	return (0);
}

void
eso_attach(struct device *parent, struct device *self, void *aux)
{
	struct eso_softc *sc = (struct eso_softc *)self;
	struct pci_attach_args *pa = aux;
	struct audio_attach_args aa;
	pci_intr_handle_t ih;
	bus_addr_t vcbase;
	const char *intrstring;
	uint8_t mvctl;

	sc->sc_revision = PCI_REVISION(pa->pa_class);

	if (sc->sc_revision <
	    sizeof (eso_rev2model) / sizeof (eso_rev2model[0]))
		printf(": %s", eso_rev2model[sc->sc_revision]);
	else
		printf(": (unknown rev. 0x%02x)", sc->sc_revision);

	/* Map I/O registers. */
	if (pci_mapreg_map(pa, ESO_PCI_BAR_IO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_iot, &sc->sc_ioh, NULL, NULL, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
	if (pci_mapreg_map(pa, ESO_PCI_BAR_SB, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_sb_iot, &sc->sc_sb_ioh, NULL, NULL, 0)) {
		printf(": can't map SB I/O space\n");
		return;
	}
	if (pci_mapreg_map(pa, ESO_PCI_BAR_VC, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_dmac_iot, &sc->sc_dmac_ioh, &vcbase, &sc->sc_vcsize, 0)) {
		vcbase = 0;
		sc->sc_vcsize = 0x10; /* From the data sheet. */
	}
	if (pci_mapreg_map(pa, ESO_PCI_BAR_MPU, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_mpu_iot, &sc->sc_mpu_ioh, NULL, NULL, 0)) {
		printf(": can't map MPU I/O space\n");
		return;
	}

	sc->sc_dmat = pa->pa_dmat;
	sc->sc_dmas = NULL;
	sc->sc_dmac_configured = 0;

	sc->sc_pa = *pa;

	eso_setup(sc, 1, 0);

	/* map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(", couldn't map interrupt\n");
		return;
	}
	intrstring = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih  = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    eso_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(", couldn't establish interrupt");
		if (intrstring != NULL)
			printf(" at %s", intrstring);
		printf("\n");
		return;
	}
	printf(", %s\n", intrstring);

	/*
	 * Set up the DDMA Control register; a suitable I/O region has been
	 * supposedly mapped in the VC base address register.
	 *
	 * The Solo-1 has an ... interesting silicon bug that causes it to
	 * not respond to I/O space accesses to the Audio 1 DMA controller
	 * if the latter's mapping base address is aligned on a 1K boundary.
	 * As a consequence, it is quite possible for the mapping provided
	 * in the VC BAR to be useless.  To work around this, we defer this
	 * part until all autoconfiguration on our parent bus is completed
	 * and then try to map it ourselves in fulfillment of the constraint.
	 * 
	 * According to the register map we may write to the low 16 bits
	 * only, but experimenting has shown we're safe.
	 * -kjk
	 */

	if (ESO_VALID_DDMAC_BASE(vcbase)) {
		pci_conf_write(pa->pa_pc, pa->pa_tag, ESO_PCI_DDMAC,
			       vcbase | ESO_PCI_DDMAC_DE);
		sc->sc_dmac_configured = 1;
		sc->sc_dmac_addr = vcbase;
		
		printf("%s: mapping Audio 1 DMA using VC I/O space at 0x%lx\n",
		       sc->sc_dev.dv_xname, (unsigned long)vcbase);
	} else {
		DPRINTF(("%s: VC I/O space at 0x%lx not suitable, deferring\n",
			 sc->sc_dev.dv_xname, (unsigned long)vcbase));
		config_defer((struct device *)sc, eso_defer);
	}
	
	audio_attach_mi(&eso_hw_if, sc, &sc->sc_dev);

	aa.type = AUDIODEV_TYPE_OPL;
	aa.hwif = NULL;
	aa.hdl = NULL;
	(void)config_found(&sc->sc_dev, &aa, audioprint);

	aa.type = AUDIODEV_TYPE_MPU;
	aa.hwif = NULL;
	aa.hdl = NULL;
	sc->sc_mpudev = config_found(&sc->sc_dev, &aa, audioprint);
	if (sc->sc_mpudev != NULL) {
		/* Unmask the MPU irq. */
		mvctl = eso_read_mixreg(sc, ESO_MIXREG_MVCTL);
		mvctl |= ESO_MIXREG_MVCTL_MPUIRQM;
		eso_write_mixreg(sc, ESO_MIXREG_MVCTL, mvctl);
	}
}

void
eso_setup(struct eso_softc *sc, int verbose, int resuming)
{
	struct pci_attach_args *pa = &sc->sc_pa;	
	uint8_t a2mode, tmp;
	int idx; 

	/* Reset the device; bail out upon failure. */
	if (eso_reset(sc) != 0) {
		if (verbose) printf(", can't reset\n");
		return;
	}
	
	/* Select the DMA/IRQ policy: DDMA, ISA IRQ emulation disabled. */
	pci_conf_write(pa->pa_pc, pa->pa_tag, ESO_PCI_S1C,
		       pci_conf_read(pa->pa_pc, pa->pa_tag, ESO_PCI_S1C) &
		       ~(ESO_PCI_S1C_IRQP_MASK | ESO_PCI_S1C_DMAP_MASK));

	/* Enable the relevant DMA interrupts. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_IRQCTL,
	    ESO_IO_IRQCTL_A1IRQ | ESO_IO_IRQCTL_A2IRQ | ESO_IO_IRQCTL_HVIRQ |
	    ESO_IO_IRQCTL_MPUIRQ);

	/* Set up A1's sample rate generator for new-style parameters. */
	a2mode = eso_read_mixreg(sc, ESO_MIXREG_A2MODE);
	a2mode |= ESO_MIXREG_A2MODE_NEWA1 | ESO_MIXREG_A2MODE_ASYNC;
	eso_write_mixreg(sc, ESO_MIXREG_A2MODE, a2mode);

	/* Slave Master Volume to Hardware Volume Control Counter, unmask IRQ. */
	tmp = eso_read_mixreg(sc, ESO_MIXREG_MVCTL);
	tmp &= ~ESO_MIXREG_MVCTL_SPLIT;
	tmp |= ESO_MIXREG_MVCTL_HVIRQM;
	eso_write_mixreg(sc, ESO_MIXREG_MVCTL, tmp);

	if (!resuming) {
		/* Set mixer regs to something reasonable, needs work. */
		sc->sc_recmon = sc->sc_spatializer = sc->sc_mvmute = 0;
		eso_set_monooutsrc(sc, ESO_MIXREG_MPM_MOMUTE);
		eso_set_monoinbypass(sc, 0);
		eso_set_preamp(sc, 1);
		for (idx = 0; idx < ESO_NGAINDEVS; idx++) {
			int v;
		
			switch (idx) {
 			case ESO_MIC_PLAY_VOL:
			case ESO_LINE_PLAY_VOL:
			case ESO_CD_PLAY_VOL:
			case ESO_MONO_PLAY_VOL:
			case ESO_AUXB_PLAY_VOL:
			case ESO_DAC_REC_VOL:
			case ESO_LINE_REC_VOL:
			case ESO_SYNTH_REC_VOL:
			case ESO_CD_REC_VOL:
			case ESO_MONO_REC_VOL:
			case ESO_AUXB_REC_VOL:
			case ESO_SPATIALIZER:
				v = 0;
				break;
			case ESO_MASTER_VOL:
				v = ESO_GAIN_TO_6BIT(AUDIO_MAX_GAIN / 2);
				break;
			default:
				v = ESO_GAIN_TO_4BIT(AUDIO_MAX_GAIN / 2);
				break;
			}
			sc->sc_gain[idx][ESO_LEFT] =
			    sc->sc_gain[idx][ESO_RIGHT] = v;
			eso_set_gain(sc, idx);
		}
		eso_set_recsrc(sc, ESO_MIXREG_ERS_MIC);
	} else {
		eso_set_monooutsrc(sc, sc->sc_monooutsrc);
		eso_set_monoinbypass(sc, sc->sc_monoinbypass);
		eso_set_preamp(sc, sc->sc_preamp);
		eso_set_recsrc(sc, sc->sc_recsrc);

		/* recmon */
		tmp = eso_read_ctlreg(sc, ESO_CTLREG_ACTL);
		if (sc->sc_recmon)
			tmp |= ESO_CTLREG_ACTL_RECMON;
		else
			tmp &= ~ESO_CTLREG_ACTL_RECMON;
		eso_write_ctlreg(sc, ESO_CTLREG_ACTL, tmp);

		/* spatializer enable */
		tmp = eso_read_mixreg(sc, ESO_MIXREG_SPAT);
		if (sc->sc_spatializer)
			tmp |= ESO_MIXREG_SPAT_ENB;
		else
			tmp &= ~ESO_MIXREG_SPAT_ENB;
		eso_write_mixreg(sc, ESO_MIXREG_SPAT,
		    tmp | ESO_MIXREG_SPAT_RSTREL);

		/* master volume mute */
		if (sc->sc_mvmute) {
			eso_write_mixreg(sc, ESO_MIXREG_LMVM,
			    eso_read_mixreg(sc, ESO_MIXREG_LMVM) |
			    ESO_MIXREG_LMVM_MUTE);
			eso_write_mixreg(sc, ESO_MIXREG_RMVM,
			    eso_read_mixreg(sc, ESO_MIXREG_RMVM) |
			    ESO_MIXREG_RMVM_MUTE);
		} else { 
			eso_write_mixreg(sc, ESO_MIXREG_LMVM,
			    eso_read_mixreg(sc, ESO_MIXREG_LMVM) &
			    ~ESO_MIXREG_LMVM_MUTE);
			eso_write_mixreg(sc, ESO_MIXREG_RMVM,
			    eso_read_mixreg(sc, ESO_MIXREG_RMVM) &
			    ~ESO_MIXREG_RMVM_MUTE);
		}

		for (idx = 0; idx < ESO_NGAINDEVS; idx++)
			eso_set_gain(sc, idx);
	}
}

void
eso_defer(struct device *self)
{
	struct eso_softc *sc = (struct eso_softc *)self;
	struct pci_attach_args *pa = &sc->sc_pa;
	bus_addr_t addr, start;

	printf("%s: ", sc->sc_dev.dv_xname);

	/*
	 * This is outright ugly, but since we must not make assumptions
	 * on the underlying allocator's behaviour it's the most straight-
	 * forward way to implement it.  Note that we skip over the first
	 * 1K region, which is typically occupied by an attached ISA bus.
	 */
	for (start = 0x0400; start < 0xffff; start += 0x0400) {
		if (bus_space_alloc(sc->sc_iot,
		    start + sc->sc_vcsize, start + 0x0400 - 1,
		    sc->sc_vcsize, sc->sc_vcsize, 0, 0, &addr,
		    &sc->sc_dmac_ioh) != 0)
			continue;

		pci_conf_write(pa->pa_pc, pa->pa_tag, ESO_PCI_DDMAC,
		    addr | ESO_PCI_DDMAC_DE);
		sc->sc_dmac_iot = sc->sc_iot;
		sc->sc_dmac_configured = 1;
		sc->sc_dmac_addr = addr;
		printf("mapping Audio 1 DMA using I/O space at 0x%lx\n",
		    (unsigned long)addr);

		return;
	}
	
	printf("can't map Audio 1 DMA into I/O space\n");
}

void
eso_write_cmd(struct eso_softc *sc, uint8_t cmd)
{
	int i;

	/* Poll for busy indicator to become clear. */
	for (i = 0; i < ESO_WDR_TIMEOUT; i++) {
		if ((bus_space_read_1(sc->sc_sb_iot, sc->sc_sb_ioh, ESO_SB_RSR)
		    & ESO_SB_RSR_BUSY) == 0) {
			bus_space_write_1(sc->sc_sb_iot, sc->sc_sb_ioh,
			    ESO_SB_WDR, cmd);
			return;
		} else {
			delay(10);
		}
	}

	printf("%s: WDR timeout\n", sc->sc_dev.dv_xname);
}

/* Write to a controller register */
void
eso_write_ctlreg(struct eso_softc *sc, uint8_t reg, uint8_t val)
{

	/* DPRINTF(("ctlreg 0x%02x = 0x%02x\n", reg, val)); */
	
	eso_write_cmd(sc, reg);
	eso_write_cmd(sc, val);
}

/* Read out the Read Data Register */
uint8_t
eso_read_rdr(struct eso_softc *sc)
{
	int i;

	for (i = 0; i < ESO_RDR_TIMEOUT; i++) {
		if (bus_space_read_1(sc->sc_sb_iot, sc->sc_sb_ioh,
		    ESO_SB_RBSR) & ESO_SB_RBSR_RDAV) {
			return (bus_space_read_1(sc->sc_sb_iot,
			    sc->sc_sb_ioh, ESO_SB_RDR));
		} else {
			delay(10);
		}
	}

	printf("%s: RDR timeout\n", sc->sc_dev.dv_xname);
	return (-1);
}


uint8_t
eso_read_ctlreg(struct eso_softc *sc, uint8_t reg)
{
	eso_write_cmd(sc, ESO_CMD_RCR);
	eso_write_cmd(sc, reg);
	return (eso_read_rdr(sc));
}

void
eso_write_mixreg(struct eso_softc *sc, uint8_t reg, uint8_t val)
{
	/* DPRINTF(("mixreg 0x%02x = 0x%02x\n", reg, val)); */
	
	bus_space_write_1(sc->sc_sb_iot, sc->sc_sb_ioh, ESO_SB_MIXERADDR, reg);
	bus_space_write_1(sc->sc_sb_iot, sc->sc_sb_ioh, ESO_SB_MIXERDATA, val);
}

uint8_t
eso_read_mixreg(struct eso_softc *sc, uint8_t reg)
{
	uint8_t val;

	bus_space_write_1(sc->sc_sb_iot, sc->sc_sb_ioh, ESO_SB_MIXERADDR, reg);
	val = bus_space_read_1(sc->sc_sb_iot, sc->sc_sb_ioh, ESO_SB_MIXERDATA);
	return (val);
}

int
eso_intr(void *hdl)
{
	struct eso_softc *sc = hdl;
	uint8_t irqctl;

	mtx_enter(&audio_lock);
	irqctl = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ESO_IO_IRQCTL);

	/* If it wasn't ours, that's all she wrote. */
	if ((irqctl & (ESO_IO_IRQCTL_A1IRQ | ESO_IO_IRQCTL_A2IRQ |
	    ESO_IO_IRQCTL_HVIRQ | ESO_IO_IRQCTL_MPUIRQ)) == 0) {
		mtx_leave(&audio_lock);
		return (0);
	}
	
	if (irqctl & ESO_IO_IRQCTL_A1IRQ) {
		/* Clear interrupt. */
		(void)bus_space_read_1(sc->sc_sb_iot, sc->sc_sb_ioh,
		    ESO_SB_RBSR);
	
		if (sc->sc_rintr)
			sc->sc_rintr(sc->sc_rarg);
		else
			wakeup(&sc->sc_rintr);
	}

	if (irqctl & ESO_IO_IRQCTL_A2IRQ) {
		/*
		 * Clear the A2 IRQ latch: the cached value reflects the
		 * current DAC settings with the IRQ latch bit not set.
		 */
		eso_write_mixreg(sc, ESO_MIXREG_A2C2, sc->sc_a2c2);

		if (sc->sc_pintr)
			sc->sc_pintr(sc->sc_parg);
		else
			wakeup(&sc->sc_pintr);
	}

	if (irqctl & ESO_IO_IRQCTL_HVIRQ) {
		/* Clear interrupt. */
		eso_write_mixreg(sc, ESO_MIXREG_CHVIR, ESO_MIXREG_CHVIR_CHVIR);

		/*
		 * Raise a flag to cause a lazy update of the in-softc gain
		 * values the next time the software mixer is read to keep
		 * interrupt service cost low.  ~0 cannot occur otherwise
		 * as the master volume has a precision of 6 bits only.
		 */
		sc->sc_gain[ESO_MASTER_VOL][ESO_LEFT] = (uint8_t)~0;
	}

#if NMPU > 0
	if ((irqctl & ESO_IO_IRQCTL_MPUIRQ) && sc->sc_mpudev != NULL)
		mpu_intr(sc->sc_mpudev);
#endif
 
	mtx_leave(&audio_lock);
	return (1);
}

/* Perform a software reset, including DMA FIFOs. */
int
eso_reset(struct eso_softc *sc)
{
	int i;

	bus_space_write_1(sc->sc_sb_iot, sc->sc_sb_ioh, ESO_SB_RESET,
	    ESO_SB_RESET_SW | ESO_SB_RESET_FIFO);
	/* `Delay' suggested in the data sheet. */
	(void)bus_space_read_1(sc->sc_sb_iot, sc->sc_sb_ioh, ESO_SB_STATUS);
	bus_space_write_1(sc->sc_sb_iot, sc->sc_sb_ioh, ESO_SB_RESET, 0);

	/* Wait for reset to take effect. */
	for (i = 0; i < ESO_RESET_TIMEOUT; i++) {
		/* Poll for data to become available. */
		if ((bus_space_read_1(sc->sc_sb_iot, sc->sc_sb_ioh,
		    ESO_SB_RBSR) & ESO_SB_RBSR_RDAV) != 0 &&
		    bus_space_read_1(sc->sc_sb_iot, sc->sc_sb_ioh,
			ESO_SB_RDR) == ESO_SB_RDR_RESETMAGIC) {

			/* Activate Solo-1 extension commands. */
			eso_write_cmd(sc, ESO_CMD_EXTENB);
			/* Reset mixer registers. */
			eso_write_mixreg(sc, ESO_MIXREG_RESET,
			    ESO_MIXREG_RESET_RESET);

			return (0);
		} else {
			delay(1000);
		}
	}
	
	printf("%s: reset timeout\n", sc->sc_dev.dv_xname);
	return (-1);
}


/* ARGSUSED */
int
eso_open(void *hdl, int flags)
{
	return (0);
}

void
eso_close(void *hdl)
{
}

int
eso_set_params(void *hdl, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct eso_softc *sc = hdl;
	struct audio_params *p;
	int mode, r[2], rd[2], ar[2], clk;
	uint srg, fltdiv;

	for (mode = AUMODE_RECORD; mode != -1; 
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = (mode == AUMODE_PLAY) ? play : rec;

		if (p->sample_rate < ESO_MINRATE)
			p->sample_rate = ESO_MINRATE;
		if (p->sample_rate > ESO_MAXRATE)
			p->sample_rate = ESO_MAXRATE;
		if (p->precision > 16)
			p->precision = 16;
		if (p->channels > 2)
			p->channels = 2;

		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_BE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 8)
				return EINVAL;
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_LE:
			break;
		default:
			return (EINVAL);
		}
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;

		/*
		 * We'll compute both possible sample rate dividers and pick
		 * the one with the least error.
		 */
#define ABS(x) ((x) < 0 ? -(x) : (x))
		r[0] = ESO_CLK0 /
		    (128 - (rd[0] = 128 - ESO_CLK0 / p->sample_rate));
		r[1] = ESO_CLK1 /
		    (128 - (rd[1] = 128 - ESO_CLK1 / p->sample_rate));

		ar[0] = p->sample_rate - r[0];
		ar[1] = p->sample_rate - r[1];
		clk = ABS(ar[0]) > ABS(ar[1]) ? 1 : 0;
		srg = rd[clk] | (clk == 1 ? ESO_CLK1_SELECT : 0x00);

		/* Roll-off frequency of 87%, as in the ES1888 driver. */
		fltdiv = 256 - 200279L / r[clk];

		/* Update to reflect the possibly inexact rate. */
		p->sample_rate = r[clk];
	
		if (mode == AUMODE_RECORD) {
			/* Audio 1 */
			DPRINTF(("A1 srg 0x%02x fdiv 0x%02x\n", srg, fltdiv));
			eso_write_ctlreg(sc, ESO_CTLREG_SRG, srg);
			eso_write_ctlreg(sc, ESO_CTLREG_FLTDIV, fltdiv);
		} else {
			/* Audio 2 */
			DPRINTF(("A2 srg 0x%02x fdiv 0x%02x\n", srg, fltdiv));
			eso_write_mixreg(sc, ESO_MIXREG_A2SRG, srg);
			eso_write_mixreg(sc, ESO_MIXREG_A2FLTDIV, fltdiv);
		}
#undef ABS

	}

	return (0);
}

int
eso_round_blocksize(void *hdl, int blk)
{
	return ((blk + 31) & -32); /* keep good alignment; at least 16 req'd */
}

int
eso_halt_output(void *hdl)
{
	struct eso_softc *sc = hdl;
	int error;
	
	DPRINTF(("%s: halt_output\n", sc->sc_dev.dv_xname));

	/*
	 * Disable auto-initialize DMA, allowing the FIFO to drain and then
	 * stop.  The interrupt callback pointer is cleared at this
	 * point so that an outstanding FIFO interrupt for the remaining data
	 * will be acknowledged without further processing.
	 *
	 * This does not immediately `abort' an operation in progress (c.f.
	 * audio(9)) but is the method to leave the FIFO behind in a clean
	 * state with the least hair.  (Besides, that item needs to be
	 * rephrased for trigger_*()-based DMA environments.)
	 */
	mtx_enter(&audio_lock);
	eso_write_mixreg(sc, ESO_MIXREG_A2C1,
	    ESO_MIXREG_A2C1_FIFOENB | ESO_MIXREG_A2C1_DMAENB);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAM,
	    ESO_IO_A2DMAM_DMAENB);

	sc->sc_pintr = NULL;
	error = msleep(&sc->sc_pintr, &audio_lock, PWAIT, "esoho", sc->sc_pdrain);
	mtx_leave(&audio_lock);
	
	/* Shut down DMA completely. */
	eso_write_mixreg(sc, ESO_MIXREG_A2C1, 0);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAM, 0);
	
	return (error == EWOULDBLOCK ? 0 : error);
}

int
eso_halt_input(void *hdl)
{
	struct eso_softc *sc = hdl;
	int error;
	
	DPRINTF(("%s: halt_input\n", sc->sc_dev.dv_xname));

	/* Just like eso_halt_output(), but for Audio 1. */
	mtx_enter(&audio_lock);
	eso_write_ctlreg(sc, ESO_CTLREG_A1C2,
	    ESO_CTLREG_A1C2_READ | ESO_CTLREG_A1C2_ADC |
	    ESO_CTLREG_A1C2_DMAENB);
	bus_space_write_1(sc->sc_dmac_iot, sc->sc_dmac_ioh, ESO_DMAC_MODE,
	    DMA37MD_WRITE | DMA37MD_DEMAND);

	sc->sc_rintr = NULL;
	error = msleep(&sc->sc_rintr, &audio_lock, PWAIT, "esohi", sc->sc_rdrain);
	mtx_leave(&audio_lock);

	/* Shut down DMA completely. */
	eso_write_ctlreg(sc, ESO_CTLREG_A1C2,
	    ESO_CTLREG_A1C2_READ | ESO_CTLREG_A1C2_ADC);
	bus_space_write_1(sc->sc_dmac_iot, sc->sc_dmac_ioh, ESO_DMAC_MASK,
	    ESO_DMAC_MASK_MASK);

	return (error == EWOULDBLOCK ? 0 : error);
}

int
eso_set_port(void *hdl, mixer_ctrl_t *cp)
{
	struct eso_softc *sc = hdl;
	uint lgain, rgain;
	uint8_t tmp;
	int rc = 0;

	mtx_enter(&audio_lock);
	switch (cp->dev) {
	case ESO_DAC_PLAY_VOL:
	case ESO_MIC_PLAY_VOL:
	case ESO_LINE_PLAY_VOL:
	case ESO_SYNTH_PLAY_VOL:
	case ESO_CD_PLAY_VOL:
	case ESO_AUXB_PLAY_VOL:
	case ESO_RECORD_VOL:
	case ESO_DAC_REC_VOL:
	case ESO_MIC_REC_VOL:
	case ESO_LINE_REC_VOL:
	case ESO_SYNTH_REC_VOL:
	case ESO_CD_REC_VOL:
	case ESO_AUXB_REC_VOL:
		if (cp->type != AUDIO_MIXER_VALUE)
			goto error;

		/*
		 * Stereo-capable mixer ports: if we get a single-channel
		 * gain value passed in, then we duplicate it to both left
		 * and right channels.
		 */
		switch (cp->un.value.num_channels) {
		case 1:
			lgain = rgain = ESO_GAIN_TO_4BIT(
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
			break;
		case 2:
			lgain = ESO_GAIN_TO_4BIT(
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);
			rgain = ESO_GAIN_TO_4BIT(
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);
			break;
		default:
			goto error;
		}

		sc->sc_gain[cp->dev][ESO_LEFT] = lgain;
		sc->sc_gain[cp->dev][ESO_RIGHT] = rgain;
		eso_set_gain(sc, cp->dev);
		break;

	case ESO_MASTER_VOL:
		if (cp->type != AUDIO_MIXER_VALUE)
			goto error;

		/* Like above, but a precision of 6 bits. */
		switch (cp->un.value.num_channels) {
		case 1:
			lgain = rgain = ESO_GAIN_TO_6BIT(
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
			break;
		case 2:
			lgain = ESO_GAIN_TO_6BIT(
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);
			rgain = ESO_GAIN_TO_6BIT(
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);
			break;
		default:
			goto error;
		}

		sc->sc_gain[cp->dev][ESO_LEFT] = lgain;
		sc->sc_gain[cp->dev][ESO_RIGHT] = rgain;
		eso_set_gain(sc, cp->dev);
		break;

	case ESO_SPATIALIZER:
		if (cp->type != AUDIO_MIXER_VALUE ||
		    cp->un.value.num_channels != 1)
			goto error;

		sc->sc_gain[cp->dev][ESO_LEFT] =
		    sc->sc_gain[cp->dev][ESO_RIGHT] =
		    ESO_GAIN_TO_6BIT(
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
		eso_set_gain(sc, cp->dev);
		break;

	case ESO_MONO_PLAY_VOL:
	case ESO_MONO_REC_VOL:
		if (cp->type != AUDIO_MIXER_VALUE ||
		    cp->un.value.num_channels != 1)
			goto error;

		sc->sc_gain[cp->dev][ESO_LEFT] =
		    sc->sc_gain[cp->dev][ESO_RIGHT] =
		    ESO_GAIN_TO_4BIT(
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
		eso_set_gain(sc, cp->dev);
		break;

	case ESO_PCSPEAKER_VOL:
		if (cp->type != AUDIO_MIXER_VALUE ||
		    cp->un.value.num_channels != 1)
			goto error;

		sc->sc_gain[cp->dev][ESO_LEFT] =
		    sc->sc_gain[cp->dev][ESO_RIGHT] =
		    ESO_GAIN_TO_3BIT(
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
		eso_set_gain(sc, cp->dev);
		break;

	case ESO_SPATIALIZER_ENABLE:
		if (cp->type != AUDIO_MIXER_ENUM)
			goto error;

		sc->sc_spatializer = (cp->un.ord != 0);

		tmp = eso_read_mixreg(sc, ESO_MIXREG_SPAT);
		if (sc->sc_spatializer)
			tmp |= ESO_MIXREG_SPAT_ENB;
		else
			tmp &= ~ESO_MIXREG_SPAT_ENB;
		eso_write_mixreg(sc, ESO_MIXREG_SPAT,
		    tmp | ESO_MIXREG_SPAT_RSTREL);
		break;

	case ESO_MASTER_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			goto error;

		sc->sc_mvmute = (cp->un.ord != 0);

		if (sc->sc_mvmute) {
			eso_write_mixreg(sc, ESO_MIXREG_LMVM,
			    eso_read_mixreg(sc, ESO_MIXREG_LMVM) |
			    ESO_MIXREG_LMVM_MUTE);
			eso_write_mixreg(sc, ESO_MIXREG_RMVM,
			    eso_read_mixreg(sc, ESO_MIXREG_RMVM) |
			    ESO_MIXREG_RMVM_MUTE);
		} else { 
			eso_write_mixreg(sc, ESO_MIXREG_LMVM,
			    eso_read_mixreg(sc, ESO_MIXREG_LMVM) &
			    ~ESO_MIXREG_LMVM_MUTE);
			eso_write_mixreg(sc, ESO_MIXREG_RMVM,
			    eso_read_mixreg(sc, ESO_MIXREG_RMVM) &
			    ~ESO_MIXREG_RMVM_MUTE);
		}
		break;

	case ESO_MONOOUT_SOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			goto error;

		rc = eso_set_monooutsrc(sc, cp->un.ord);
		break;

	case ESO_MONOIN_BYPASS:
		if (cp->type != AUDIO_MIXER_ENUM)
			goto error;

		rc = eso_set_monoinbypass(sc, cp->un.ord);
		break;

	case ESO_RECORD_MONITOR:
		if (cp->type != AUDIO_MIXER_ENUM)
			goto error;

		sc->sc_recmon = (cp->un.ord != 0);

		tmp = eso_read_ctlreg(sc, ESO_CTLREG_ACTL);
		if (sc->sc_recmon)
			tmp |= ESO_CTLREG_ACTL_RECMON;
		else
			tmp &= ~ESO_CTLREG_ACTL_RECMON;
		eso_write_ctlreg(sc, ESO_CTLREG_ACTL, tmp);
		break;

	case ESO_RECORD_SOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			goto error;

		rc = eso_set_recsrc(sc, cp->un.ord);
		break;

	case ESO_MIC_PREAMP:
		if (cp->type != AUDIO_MIXER_ENUM)
			goto error;

		rc = eso_set_preamp(sc, cp->un.ord);
		break;

	default:
		goto error;
	}

	mtx_leave(&audio_lock);
	return rc;
error:
	mtx_leave(&audio_lock);
	return EINVAL;
}

int
eso_get_port(void *hdl, mixer_ctrl_t *cp)
{
	struct eso_softc *sc = hdl;

	mtx_enter(&audio_lock);
	switch (cp->dev) {
	case ESO_MASTER_VOL:
		/* Reload from mixer after hardware volume control use. */
		if (sc->sc_gain[cp->dev][ESO_LEFT] == (uint8_t)~0)
			eso_reload_master_vol(sc);
		/* FALLTHROUGH */
	case ESO_DAC_PLAY_VOL:
	case ESO_MIC_PLAY_VOL:
	case ESO_LINE_PLAY_VOL:
	case ESO_SYNTH_PLAY_VOL:
	case ESO_CD_PLAY_VOL:
	case ESO_AUXB_PLAY_VOL:
	case ESO_RECORD_VOL:
	case ESO_DAC_REC_VOL:
	case ESO_MIC_REC_VOL:
	case ESO_LINE_REC_VOL:
	case ESO_SYNTH_REC_VOL:
	case ESO_CD_REC_VOL:
	case ESO_AUXB_REC_VOL:
		/*
		 * Stereo-capable ports: if a single-channel query is made,
		 * just return the left channel's value (since single-channel
		 * settings themselves are applied to both channels).
		 */
		switch (cp->un.value.num_channels) {
		case 1:
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    sc->sc_gain[cp->dev][ESO_LEFT];
			break;
		case 2:
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
			    sc->sc_gain[cp->dev][ESO_LEFT];
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
			    sc->sc_gain[cp->dev][ESO_RIGHT];
			break;
		default:
			goto error;
		}
		break;

	case ESO_MONO_PLAY_VOL:
	case ESO_PCSPEAKER_VOL:
	case ESO_MONO_REC_VOL:
	case ESO_SPATIALIZER:
		if (cp->un.value.num_channels != 1)
			goto error;
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
		    sc->sc_gain[cp->dev][ESO_LEFT];
		break;

	case ESO_RECORD_MONITOR:
		cp->un.ord = sc->sc_recmon;
		break;

	case ESO_RECORD_SOURCE:
		cp->un.ord = sc->sc_recsrc;
		break;

	case ESO_MONOOUT_SOURCE:
		cp->un.ord = sc->sc_monooutsrc;
		break;

	case ESO_MONOIN_BYPASS:
		cp->un.ord = sc->sc_monoinbypass;
		break;

	case ESO_SPATIALIZER_ENABLE:
		cp->un.ord = sc->sc_spatializer;
		break;

	case ESO_MIC_PREAMP:
		cp->un.ord = sc->sc_preamp;
		break;

	case ESO_MASTER_MUTE:
		/* Reload from mixer after hardware volume control use. */
		if (sc->sc_gain[ESO_MASTER_VOL][ESO_LEFT] == (uint8_t)~0)
			eso_reload_master_vol(sc);
		cp->un.ord = sc->sc_mvmute;
		break;

	default:
		goto error;
	}

	mtx_leave(&audio_lock);
	return 0;
error:
	mtx_leave(&audio_lock);
	return EINVAL;
}

int
eso_query_devinfo(void *hdl, mixer_devinfo_t *dip)
{
	switch (dip->index) {
	case ESO_DAC_PLAY_VOL:
		dip->mixer_class = ESO_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_MIC_PLAY_VOL:
		dip->mixer_class = ESO_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_LINE_PLAY_VOL:
		dip->mixer_class = ESO_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_SYNTH_PLAY_VOL:
		dip->mixer_class = ESO_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_MONO_PLAY_VOL:
		dip->mixer_class = ESO_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "mono_in", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_CD_PLAY_VOL:
		dip->mixer_class = ESO_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_AUXB_PLAY_VOL:
		dip->mixer_class = ESO_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_MIC_PREAMP:
		dip->mixer_class = ESO_MICROPHONE_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		break;
	case ESO_MICROPHONE_CLASS:
		dip->mixer_class = ESO_MICROPHONE_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		break;
	case ESO_INPUT_CLASS:
		dip->mixer_class = ESO_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		break;
	case ESO_MASTER_VOL:
		dip->mixer_class = ESO_OUTPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = ESO_MASTER_MUTE;
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_MASTER_MUTE:
		dip->mixer_class = ESO_OUTPUT_CLASS;
		dip->prev = ESO_MASTER_VOL;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		break;
	case ESO_PCSPEAKER_VOL:
		dip->mixer_class = ESO_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_MONOOUT_SOURCE:
		dip->mixer_class = ESO_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "mono_out", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 3;
		strlcpy(dip->un.e.member[0].label.name, AudioNmute,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = ESO_MIXREG_MPM_MOMUTE;
		strlcpy(dip->un.e.member[1].label.name, AudioNdac,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = ESO_MIXREG_MPM_MOA2R;
		strlcpy(dip->un.e.member[2].label.name, AudioNmixerout,
		    sizeof dip->un.e.member[2].label.name);
		dip->un.e.member[2].ord = ESO_MIXREG_MPM_MOREC;
		break;
	case ESO_MONOIN_BYPASS:
		dip->mixer_class = ESO_MONOIN_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "bypass", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		break;
	case ESO_MONOIN_CLASS:
		dip->mixer_class = ESO_MONOIN_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "mono_in", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		break;
	case ESO_SPATIALIZER:
		dip->mixer_class = ESO_OUTPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = ESO_SPATIALIZER_ENABLE;
		strlcpy(dip->label.name, AudioNspatial,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, "level",
		    sizeof dip->un.v.units.name);
		break;
	case ESO_SPATIALIZER_ENABLE:
		dip->mixer_class = ESO_OUTPUT_CLASS;
		dip->prev = ESO_SPATIALIZER;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "enable", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		break;
	case ESO_OUTPUT_CLASS:
		dip->mixer_class = ESO_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		break;
	case ESO_RECORD_MONITOR:
		dip->mixer_class = ESO_MONITOR_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		break;
	case ESO_MONITOR_CLASS:
		dip->mixer_class = ESO_MONITOR_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCmonitor,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		break;
	case ESO_RECORD_VOL:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_RECORD_SOURCE:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 4;
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = ESO_MIXREG_ERS_MIC;
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = ESO_MIXREG_ERS_LINE;
		strlcpy(dip->un.e.member[2].label.name, AudioNcd,
		    sizeof dip->un.e.member[2].label.name);
		dip->un.e.member[2].ord = ESO_MIXREG_ERS_CD;
		strlcpy(dip->un.e.member[3].label.name, AudioNmixerout,
		    sizeof dip->un.e.member[3].label.name);
		dip->un.e.member[3].ord = ESO_MIXREG_ERS_MIXER;
		break;
	case ESO_DAC_REC_VOL:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_MIC_REC_VOL:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_LINE_REC_VOL:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_SYNTH_REC_VOL:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_MONO_REC_VOL:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "mono_in", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 1; /* No lies */
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_CD_REC_VOL:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_AUXB_REC_VOL:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case ESO_RECORD_CLASS:
		dip->mixer_class = ESO_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		break;
	default:
		return (ENXIO);
	}

	return (0);
}

int
eso_allocmem(struct eso_softc *sc, size_t size, size_t align,
    size_t boundary, int flags, int direction, struct eso_dma *ed)
{
	int error, wait;

	wait = (flags & M_NOWAIT) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK;
	ed->ed_size = size;

	error = bus_dmamem_alloc(ed->ed_dmat, ed->ed_size, align, boundary,
	    ed->ed_segs, sizeof (ed->ed_segs) / sizeof (ed->ed_segs[0]),
	    &ed->ed_nsegs, wait);
	if (error)
		goto out;

	error = bus_dmamem_map(ed->ed_dmat, ed->ed_segs, ed->ed_nsegs,
	    ed->ed_size, &ed->ed_addr, wait | BUS_DMA_COHERENT);
	if (error)
		goto free;

	error = bus_dmamap_create(ed->ed_dmat, ed->ed_size, 1, ed->ed_size,
	    boundary,  wait, &ed->ed_map);
	if (error)
		goto unmap;

	error = bus_dmamap_load(ed->ed_dmat, ed->ed_map, ed->ed_addr,
	    ed->ed_size, NULL, wait |
	    ((direction == AUMODE_RECORD) ? BUS_DMA_READ : BUS_DMA_WRITE));
	if (error)
		goto destroy;

	return (0);

 destroy:
	bus_dmamap_destroy(ed->ed_dmat, ed->ed_map);
 unmap:
	bus_dmamem_unmap(ed->ed_dmat, ed->ed_addr, ed->ed_size);
 free:
	bus_dmamem_free(ed->ed_dmat, ed->ed_segs, ed->ed_nsegs);
 out:
	return (error);
}

void
eso_freemem(struct eso_dma *ed)
{
	bus_dmamap_unload(ed->ed_dmat, ed->ed_map);
	bus_dmamap_destroy(ed->ed_dmat, ed->ed_map);
	bus_dmamem_unmap(ed->ed_dmat, ed->ed_addr, ed->ed_size);
	bus_dmamem_free(ed->ed_dmat, ed->ed_segs, ed->ed_nsegs);
}
	
void *
eso_allocm(void *hdl, int direction, size_t size, int type, int flags)
{
	struct eso_softc *sc = hdl;
	struct eso_dma *ed;
	size_t boundary;
	int error;

	if ((ed = malloc(sizeof (*ed), type, flags)) == NULL)
		return (NULL);

	/*
	 * Apparently the Audio 1 DMA controller's current address
	 * register can't roll over a 64K address boundary, so we have to
	 * take care of that ourselves.  Similarly, the Audio 2 DMA
	 * controller needs a 1M address boundary.
	 */
	if (direction == AUMODE_RECORD)
		boundary = 0x10000;
	else
		boundary = 0x100000;

	/*
	 * XXX Work around allocation problems for Audio 1, which
	 * XXX implements the 24 low address bits only, with
	 * XXX machine-specific DMA tag use.
	 */
#if defined(__alpha__)
	/*
	 * XXX Force allocation through the (ISA) SGMAP.
	 */
	if (direction == AUMODE_RECORD)
		ed->ed_dmat = alphabus_dma_get_tag(sc->sc_dmat, ALPHA_BUS_ISA);
	else
#elif defined(__amd64__) || defined(__i386__)
	/*
	 * XXX Force allocation through the ISA DMA tag.
	 */
	if (direction == AUMODE_RECORD)
		ed->ed_dmat = &isa_bus_dma_tag;
	else
#endif
		ed->ed_dmat = sc->sc_dmat;

	error = eso_allocmem(sc, size, 32, boundary, flags, direction, ed);
	if (error) {
		free(ed, type, 0);
		return (NULL);
	}
	ed->ed_next = sc->sc_dmas;
	sc->sc_dmas = ed;

	return (KVADDR(ed));
}

void
eso_freem(void *hdl, void *addr, int type)
{
	struct eso_softc *sc = hdl;
	struct eso_dma *p, **pp;

	for (pp = &sc->sc_dmas; (p = *pp) != NULL; pp = &p->ed_next) {
		if (KVADDR(p) == addr) {
			eso_freemem(p);
			*pp = p->ed_next;
			free(p, type, 0);
			return;
		}
	}
}

size_t
eso_round_buffersize(void *hdl, int direction, size_t bufsize)
{
	size_t maxsize;

	/*
	 * The playback DMA buffer size on the Solo-1 is limited to 0xfff0
	 * bytes.  This is because IO_A2DMAC is a two byte value
	 * indicating the literal byte count, and the 4 least significant
	 * bits are read-only.  Zero is not used as a special case for
	 * 0x10000.
	 *
	 * For recording, DMAC_DMAC is the byte count - 1, so 0x10000 can
	 * be represented.
	 */
	maxsize = (direction == AUMODE_PLAY) ? 0xfff0 : 0x10000;

	if (bufsize > maxsize)
		bufsize = maxsize;

	return (bufsize);
}

/* ARGSUSED */
int
eso_get_props(void *hdl)
{
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT |
	    AUDIO_PROP_FULLDUPLEX);
}

int
eso_trigger_output(void *hdl, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct eso_softc *sc = hdl;
	struct eso_dma *ed;
	uint8_t a2c1;

	DPRINTF((
	    "%s: trigger_output: start %p, end %p, blksize %d, intr %p(%p)\n",
	    sc->sc_dev.dv_xname, start, end, blksize, intr, arg));
	DPRINTF(("%s: param: rate %lu, encoding %u, precision %u, channels %u\n",
	    sc->sc_dev.dv_xname, param->sample_rate, param->encoding,
	    param->precision, param->channels));

	/* Find DMA buffer. */
	for (ed = sc->sc_dmas; ed != NULL && KVADDR(ed) != start;
	     ed = ed->ed_next)
		;
	if (ed == NULL) {
		printf("%s: trigger_output: bad addr %p\n",
		    sc->sc_dev.dv_xname, start);
		return (EINVAL);
	}
	DPRINTF(("%s: output dmaaddr %lx\n",
	    sc->sc_dev.dv_xname, (unsigned long)DMAADDR(ed)));

	sc->sc_pintr = intr;
	sc->sc_parg = arg;

	/* Compute drain timeout. */
	sc->sc_pdrain = hz * (blksize * 3 / 2) / 
	    (param->sample_rate * param->channels * param->bps);

	/* DMA transfer count (in `words'!) reload using 2's complement. */
	blksize = -(blksize >> 1);
	eso_write_mixreg(sc, ESO_MIXREG_A2TCRLO, blksize & 0xff);
	eso_write_mixreg(sc, ESO_MIXREG_A2TCRHI, blksize >> 8);

	/* Update DAC to reflect DMA count and audio parameters. */
	/* Note: we cache A2C2 in order to avoid r/m/w at interrupt time. */
	if (param->precision == 16)
		sc->sc_a2c2 |= ESO_MIXREG_A2C2_16BIT;
	else
		sc->sc_a2c2 &= ~ESO_MIXREG_A2C2_16BIT;
	if (param->channels == 2)
		sc->sc_a2c2 |= ESO_MIXREG_A2C2_STEREO;
	else
		sc->sc_a2c2 &= ~ESO_MIXREG_A2C2_STEREO;
	if (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_SLINEAR_LE)
		sc->sc_a2c2 |= ESO_MIXREG_A2C2_SIGNED;
	else
		sc->sc_a2c2 &= ~ESO_MIXREG_A2C2_SIGNED;
	/* Unmask IRQ. */
	sc->sc_a2c2 |= ESO_MIXREG_A2C2_IRQM;
	eso_write_mixreg(sc, ESO_MIXREG_A2C2, sc->sc_a2c2);

	/* Set up DMA controller. */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAA, DMAADDR(ed));
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAC,
	    (uint8_t *)end - (uint8_t *)start);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAM,
	    ESO_IO_A2DMAM_DMAENB | ESO_IO_A2DMAM_AUTO);

	/* Start DMA. */
	mtx_enter(&audio_lock);
	a2c1 = eso_read_mixreg(sc, ESO_MIXREG_A2C1);
	a2c1 &= ~ESO_MIXREG_A2C1_RESV0; /* Paranoia? XXX bit 5 */
	a2c1 |= ESO_MIXREG_A2C1_FIFOENB | ESO_MIXREG_A2C1_DMAENB |
	    ESO_MIXREG_A2C1_AUTO;
	eso_write_mixreg(sc, ESO_MIXREG_A2C1, a2c1);
	mtx_leave(&audio_lock);
	return (0);
}

int
eso_trigger_input(void *hdl, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct eso_softc *sc = hdl;
	struct eso_dma *ed;
	uint8_t actl, a1c1;

	DPRINTF((
	    "%s: trigger_input: start %p, end %p, blksize %d, intr %p(%p)\n",
	    sc->sc_dev.dv_xname, start, end, blksize, intr, arg));
	DPRINTF(("%s: param: rate %lu, encoding %u, precision %u, channels %u\n",
	    sc->sc_dev.dv_xname, param->sample_rate, param->encoding,
	    param->precision, param->channels));

	/*
	 * If we failed to configure the Audio 1 DMA controller, bail here
	 * while retaining availability of the DAC direction (in Audio 2).
	 */
	if (!sc->sc_dmac_configured)
		return (EIO);

	/* Find DMA buffer. */
	for (ed = sc->sc_dmas; ed != NULL && KVADDR(ed) != start;
	     ed = ed->ed_next)
		;
	if (ed == NULL) {
		printf("%s: trigger_input: bad addr %p\n",
		    sc->sc_dev.dv_xname, start);
		return (EINVAL);
	}
	DPRINTF(("%s: input dmaaddr %lx\n",
	    sc->sc_dev.dv_xname, (unsigned long)DMAADDR(ed)));

	sc->sc_rintr = intr;
	sc->sc_rarg = arg;

	/* Compute drain timeout. */
	sc->sc_rdrain = hz * (blksize * 3 / 2) / 
	    (param->sample_rate * param->channels * param->bps);

	/* Set up ADC DMA converter parameters. */
	actl = eso_read_ctlreg(sc, ESO_CTLREG_ACTL);
	if (param->channels == 2) {
		actl &= ~ESO_CTLREG_ACTL_MONO;
		actl |= ESO_CTLREG_ACTL_STEREO;
	} else {
		actl &= ~ESO_CTLREG_ACTL_STEREO;
		actl |= ESO_CTLREG_ACTL_MONO;
	}
	eso_write_ctlreg(sc, ESO_CTLREG_ACTL, actl);

	/* Set up Transfer Type: maybe move to attach time? */
	eso_write_ctlreg(sc, ESO_CTLREG_A1TT, ESO_CTLREG_A1TT_DEMAND4);

	/* DMA transfer count reload using 2's complement. */
	blksize = -blksize;
	eso_write_ctlreg(sc, ESO_CTLREG_A1TCRLO, blksize & 0xff);
	eso_write_ctlreg(sc, ESO_CTLREG_A1TCRHI, blksize >> 8);

	/* Set up and enable Audio 1 DMA FIFO. */
	a1c1 = ESO_CTLREG_A1C1_RESV1 | ESO_CTLREG_A1C1_FIFOENB;
	if (param->precision == 16)
		a1c1 |= ESO_CTLREG_A1C1_16BIT;
	if (param->channels == 2)
		a1c1 |= ESO_CTLREG_A1C1_STEREO;
	else
		a1c1 |= ESO_CTLREG_A1C1_MONO;
	if (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_SLINEAR_LE)
		a1c1 |= ESO_CTLREG_A1C1_SIGNED;
	eso_write_ctlreg(sc, ESO_CTLREG_A1C1, a1c1);

	/* Set up ADC IRQ/DRQ parameters. */
	eso_write_ctlreg(sc, ESO_CTLREG_LAIC,
	    ESO_CTLREG_LAIC_PINENB | ESO_CTLREG_LAIC_EXTENB);
	eso_write_ctlreg(sc, ESO_CTLREG_DRQCTL,
	    ESO_CTLREG_DRQCTL_ENB1 | ESO_CTLREG_DRQCTL_EXTENB);

	/* Set up and enable DMA controller. */
	bus_space_write_1(sc->sc_dmac_iot, sc->sc_dmac_ioh, ESO_DMAC_CLEAR, 0);
	bus_space_write_1(sc->sc_dmac_iot, sc->sc_dmac_ioh, ESO_DMAC_MASK,
	    ESO_DMAC_MASK_MASK);
	bus_space_write_1(sc->sc_dmac_iot, sc->sc_dmac_ioh, ESO_DMAC_MODE,
	    DMA37MD_WRITE | DMA37MD_LOOP | DMA37MD_DEMAND);
	bus_space_write_4(sc->sc_dmac_iot, sc->sc_dmac_ioh, ESO_DMAC_DMAA,
	    DMAADDR(ed));
	bus_space_write_2(sc->sc_dmac_iot, sc->sc_dmac_ioh, ESO_DMAC_DMAC,
	    (uint8_t *)end - (uint8_t *)start - 1);
	bus_space_write_1(sc->sc_dmac_iot, sc->sc_dmac_ioh, ESO_DMAC_MASK, 0);

	/* Start DMA. */
	mtx_enter(&audio_lock);
	eso_write_ctlreg(sc, ESO_CTLREG_A1C2,
	    ESO_CTLREG_A1C2_DMAENB | ESO_CTLREG_A1C2_READ |
	    ESO_CTLREG_A1C2_AUTO | ESO_CTLREG_A1C2_ADC);
	mtx_leave(&audio_lock);
	return (0);
}

/*
 * Mixer utility functions.
 */
int
eso_set_recsrc(struct eso_softc *sc, u_int recsrc)
{
	mixer_devinfo_t di;
	int i, error;

	di.index = ESO_RECORD_SOURCE;
	error = eso_query_devinfo(sc, &di);
	if (error != 0) {
		printf("eso_set_recsrc: eso_query_devinfo failed");
		return (error);
	}

	for (i = 0; i < di.un.e.num_mem; i++) {
		if (recsrc == di.un.e.member[i].ord) {
			eso_write_mixreg(sc, ESO_MIXREG_ERS, recsrc);
			sc->sc_recsrc = recsrc;
			return (0);
		}
	}

	return (EINVAL);
}

int
eso_set_monooutsrc(struct eso_softc *sc, uint monooutsrc)
{
	mixer_devinfo_t di;
	int i, error;
	uint8_t mpm;

	di.index = ESO_MONOOUT_SOURCE;
	error = eso_query_devinfo(sc, &di);
	if (error != 0) {
		printf("eso_set_monooutsrc: eso_query_devinfo failed");
		return (error);
	}

	for (i = 0; i < di.un.e.num_mem; i++) {
		if (monooutsrc == di.un.e.member[i].ord) {
			mpm = eso_read_mixreg(sc, ESO_MIXREG_MPM);
			mpm &= ~ESO_MIXREG_MPM_MOMASK;
			mpm |= monooutsrc;
			eso_write_mixreg(sc, ESO_MIXREG_MPM, mpm);
			sc->sc_monooutsrc = monooutsrc;
			return (0);
		}
	}

	return (EINVAL);
}

int
eso_set_monoinbypass(struct eso_softc *sc, uint monoinbypass)
{
	mixer_devinfo_t di;
	int i, error;
	uint8_t mpm;

	di.index = ESO_MONOIN_BYPASS;
	error = eso_query_devinfo(sc, &di);
	if (error != 0) {
		printf("eso_set_monoinbypass: eso_query_devinfo failed");
		return (error);
	}

	for (i = 0; i < di.un.e.num_mem; i++) {
		if (monoinbypass == di.un.e.member[i].ord) {
			mpm = eso_read_mixreg(sc, ESO_MIXREG_MPM);
			mpm &= ~(ESO_MIXREG_MPM_MOMASK | ESO_MIXREG_MPM_RESV0);
			mpm |= (monoinbypass ? ESO_MIXREG_MPM_MIBYPASS : 0);
			eso_write_mixreg(sc, ESO_MIXREG_MPM, mpm);
			sc->sc_monoinbypass = monoinbypass;
			return (0);
		}
	}

	return (EINVAL);
}

int
eso_set_preamp(struct eso_softc *sc, uint preamp)
{
	mixer_devinfo_t di;
	int i, error;
	uint8_t mpm;

	di.index = ESO_MIC_PREAMP;
	error = eso_query_devinfo(sc, &di);
	if (error != 0) {
		printf("eso_set_preamp: eso_query_devinfo failed");
		return (error);
	}

	for (i = 0; i < di.un.e.num_mem; i++) {
		if (preamp == di.un.e.member[i].ord) {
			mpm = eso_read_mixreg(sc, ESO_MIXREG_MPM);
			mpm &= ~(ESO_MIXREG_MPM_PREAMP | ESO_MIXREG_MPM_RESV0);
			mpm |= (preamp ? ESO_MIXREG_MPM_PREAMP : 0);
			eso_write_mixreg(sc, ESO_MIXREG_MPM, mpm);
			sc->sc_preamp = preamp;
			return (0);
		}
	}

	return (EINVAL);
}

/*
 * Reload Master Volume and Mute values in softc from mixer; used when
 * those have previously been invalidated by use of hardware volume controls.
 */
void
eso_reload_master_vol(struct eso_softc *sc)
{
	uint8_t mv;

	mv = eso_read_mixreg(sc, ESO_MIXREG_LMVM);
	sc->sc_gain[ESO_MASTER_VOL][ESO_LEFT] =
	    (mv & ~ESO_MIXREG_LMVM_MUTE) << 2;
	mv = eso_read_mixreg(sc, ESO_MIXREG_LMVM);
	sc->sc_gain[ESO_MASTER_VOL][ESO_RIGHT] =
	    (mv & ~ESO_MIXREG_RMVM_MUTE) << 2;
	/* Currently both channels are muted simultaneously; either is OK. */
	sc->sc_mvmute = (mv & ESO_MIXREG_RMVM_MUTE) != 0;
}

void
eso_set_gain(struct eso_softc *sc, uint port)
{
	uint8_t mixreg, tmp;

	switch (port) {
	case ESO_DAC_PLAY_VOL:
		mixreg = ESO_MIXREG_PVR_A2;
		break;
	case ESO_MIC_PLAY_VOL:
		mixreg = ESO_MIXREG_PVR_MIC;
		break;
	case ESO_LINE_PLAY_VOL:
		mixreg = ESO_MIXREG_PVR_LINE;
		break;
	case ESO_SYNTH_PLAY_VOL:
		mixreg = ESO_MIXREG_PVR_SYNTH;
		break;
	case ESO_CD_PLAY_VOL:
		mixreg = ESO_MIXREG_PVR_CD;
		break;
	case ESO_AUXB_PLAY_VOL:
		mixreg = ESO_MIXREG_PVR_AUXB;
		break;
	case ESO_DAC_REC_VOL:
		mixreg = ESO_MIXREG_RVR_A2;
		break;
	case ESO_MIC_REC_VOL:
		mixreg = ESO_MIXREG_RVR_MIC;
		break;
	case ESO_LINE_REC_VOL:
		mixreg = ESO_MIXREG_RVR_LINE;
		break;
	case ESO_SYNTH_REC_VOL:
		mixreg = ESO_MIXREG_RVR_SYNTH;
		break;
	case ESO_CD_REC_VOL:
		mixreg = ESO_MIXREG_RVR_CD;
		break;
	case ESO_AUXB_REC_VOL:
		mixreg = ESO_MIXREG_RVR_AUXB;
		break;
	case ESO_MONO_PLAY_VOL:
		mixreg = ESO_MIXREG_PVR_MONO;
		break;
	case ESO_MONO_REC_VOL:
		mixreg = ESO_MIXREG_RVR_MONO;
		break;
	case ESO_PCSPEAKER_VOL:
		/* Special case - only 3-bit, mono, and reserved bits. */
		tmp = eso_read_mixreg(sc, ESO_MIXREG_PCSVR);
		tmp &= ESO_MIXREG_PCSVR_RESV;
		/* Map bits 7:5 -> 2:0. */
		tmp |= (sc->sc_gain[port][ESO_LEFT] >> 5);
		eso_write_mixreg(sc, ESO_MIXREG_PCSVR, tmp);
		return;
	case ESO_MASTER_VOL:
		/* Special case - separate regs, and 6-bit precision. */
		/* Map bits 7:2 -> 5:0, reflect mute settings. */
		eso_write_mixreg(sc, ESO_MIXREG_LMVM,
		    (sc->sc_gain[port][ESO_LEFT] >> 2) |
		    (sc->sc_mvmute ? ESO_MIXREG_LMVM_MUTE : 0x00));
		eso_write_mixreg(sc, ESO_MIXREG_RMVM,
		    (sc->sc_gain[port][ESO_RIGHT] >> 2) |
		    (sc->sc_mvmute ? ESO_MIXREG_RMVM_MUTE : 0x00));
		return;
	case ESO_SPATIALIZER:
		/* Special case - only `mono', and higher precision. */
		eso_write_mixreg(sc, ESO_MIXREG_SPATLVL,
		    sc->sc_gain[port][ESO_LEFT]);
		return;
	case ESO_RECORD_VOL:
		/* Very Special case, controller register. */
		eso_write_ctlreg(sc, ESO_CTLREG_RECLVL,ESO_4BIT_GAIN_TO_STEREO(
		   sc->sc_gain[port][ESO_LEFT], sc->sc_gain[port][ESO_RIGHT]));
		return;
	default:
#ifdef DIAGNOSTIC		
		printf("eso_set_gain: bad port %u", port);
		return;
		/* NOTREACHED */
#else
		return;
#endif		
		}

	eso_write_mixreg(sc, mixreg, ESO_4BIT_GAIN_TO_STEREO(
	    sc->sc_gain[port][ESO_LEFT], sc->sc_gain[port][ESO_RIGHT]));
}

int
eso_activate(struct device *self, int act)
{
	struct eso_softc *sc = (struct eso_softc *)self;
	uint8_t tmp;
	int rv = 0;

	switch (act) {
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		tmp = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ESO_IO_IRQCTL);
		tmp &= ~(ESO_IO_IRQCTL_MASK);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_IRQCTL, tmp);
		break;
	case DVACT_SUSPEND:
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAM, 0);
		bus_space_write_1(sc->sc_dmac_iot, sc->sc_dmac_ioh,
		    ESO_DMAC_CLEAR, 0);
		bus_space_write_1(sc->sc_sb_iot, sc->sc_sb_ioh,
		    ESO_SB_STATUSFLAGS, 3);
		/* shut down dma */
		pci_conf_write(sc->sc_pa.pa_pc, sc->sc_pa.pa_tag,
		    ESO_PCI_DDMAC, 0);
		break;
	case DVACT_RESUME:
		eso_setup(sc, 1, 1);
		pci_conf_write(sc->sc_pa.pa_pc, sc->sc_pa.pa_tag,
		    ESO_PCI_DDMAC, sc->sc_dmac_addr | ESO_PCI_DDMAC_DE);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}
@


1.42
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.40 2015/05/11 06:46:22 ratchov Exp $	*/
a112 1
int	eso_getdev(void *, struct audio_device *);
a138 1
	eso_getdev,
a799 18
}

int
eso_getdev(void *hdl, struct audio_device *retp)
{
	struct eso_softc *sc = hdl;

	strlcpy(retp->name, "ESS Solo-1", sizeof retp->name);
	snprintf(retp->version, sizeof retp->version, "0x%02x",
	    sc->sc_revision);
	if (sc->sc_revision <
	    sizeof (eso_rev2model) / sizeof (eso_rev2model[0]))
		strlcpy(retp->config, eso_rev2model[sc->sc_revision],
		    sizeof retp->config);
	else
		strlcpy(retp->config, "unknown", sizeof retp->config);

	return (0);
@


1.41
log
@add brackets to avoid an operator precedence bug
ok ratchov@@ deraadt@@
@
text
@a107 1
int	eso_query_encoding(void *, struct audio_encoding *);
a109 1
void	eso_get_default_params(void *, int, struct audio_params *);
a119 1
paddr_t	eso_mappage(void *, void *, off_t, int);
a129 2
	NULL,			/* drain */
	eso_query_encoding,
a147 1
	eso_mappage,
d150 1
a150 2
	eso_trigger_input,
	eso_get_default_params
a654 48
eso_query_encoding(void *hdl, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 2:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 3:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

void
eso_get_default_params(void *addr, int mode, struct audio_params *params)
{
	params->sample_rate = 48000;
	params->encoding = AUDIO_ENCODING_ULINEAR_LE;
	params->precision = 16;
	params->bps = 2;
	params->msb = 1;
	params->channels = 2;
}

int
a1587 18
}

paddr_t
eso_mappage(void *hdl, void *addr, off_t offs, int prot)
{
	struct eso_softc *sc = hdl;
	struct eso_dma *ed;

	if (offs < 0)
		return (-1);
	for (ed = sc->sc_dmas; ed != NULL && KVADDR(ed) != addr;
	     ed = ed->ed_next)
		;
	if (ed == NULL)
		return (-1);

	return (bus_dmamem_mmap(ed->ed_dmat, ed->ed_segs, ed->ed_nsegs,
	    offs, prot, BUS_DMA_WAITOK));
@


1.40
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.39 2014/07/12 18:48:51 tedu Exp $	*/
d1526 1
a1526 1
	    (direction == AUMODE_RECORD) ? BUS_DMA_READ : BUS_DMA_WRITE);
@


1.39
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.38 2013/12/06 21:03:03 deraadt Exp $	*/
a48 3
#include <dev/mulaw.h>
#include <dev/auconv.h>

a671 12
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
d677 1
a677 1
	case 4:
d683 1
a683 1
	case 5:
a688 12
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a706 2
	params->sw_code = NULL;
	params->factor = 1;
a733 2
		p->factor = 1;
		p->sw_code = NULL;
d737 2
a738 2
			if (p->precision == 16)
				p->sw_code = swap_bytes;
a742 16
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_ulinear16_le;
			} else {
				p->sw_code = ulinear8_to_mulaw;
			}
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_ulinear16_le;
			} else {
				p->sw_code = ulinear8_to_alaw;
			}
			break;
d1682 1
a1682 1
	DPRINTF(("%s: param: rate %lu, encoding %u, precision %u, channels %u, sw_code %p, factor %d\n",
d1684 1
a1684 1
	    param->precision, param->channels, param->sw_code, param->factor));
d1703 1
a1703 1
	    (param->sample_rate * param->channels * param->bps * param->factor);
d1712 1
a1712 1
	if (param->precision * param->factor == 16)
d1758 1
a1758 1
	DPRINTF(("%s: param: rate %lu, encoding %u, precision %u, channels %u, sw_code %p, factor %d\n",
d1760 1
a1760 1
	    param->precision, param->channels, param->sw_code, param->factor));
d1786 1
a1786 1
	    (param->sample_rate * param->channels * param->bps * param->factor);
d1809 1
a1809 1
	if (param->precision * param->factor == 16)
@


1.38
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.37 2013/05/24 07:58:46 ratchov Exp $	*/
d1644 1
a1644 1
		free(ed, type);
d1663 1
a1663 1
			free(p, type);
@


1.37
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.36 2013/05/15 08:29:24 ratchov Exp $	*/
d2142 3
@


1.36
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.35 2010/09/21 20:11:44 jakemsr Exp $	*/
d262 2
a263 2
	sc->sc_ih  = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, eso_intr, sc,
					sc->sc_dev.dv_xname);
@


1.35
log
@much better suspend/resume support
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.34 2010/09/07 16:21:44 deraadt Exp $	*/
a536 2
	int s;

a538 1
	s = splaudio();
a540 1
	splx(s);
a545 1
	int s;
a547 1
	s = splaudio();
a549 2
	splx(s);
	
d559 1
d564 2
a565 1
	    ESO_IO_IRQCTL_HVIRQ | ESO_IO_IRQCTL_MPUIRQ)) == 0)
d567 1
d611 1
d845 1
a845 1
	int error, s;
d860 1
a860 1
	s = splaudio();
d867 2
a868 2
	error = tsleep(&sc->sc_pintr, PWAIT, "esoho", sc->sc_pdrain);
	splx(s);
d881 1
a881 1
	int error, s;
d886 1
a886 1
	s = splaudio();
d894 2
a895 2
	error = tsleep(&sc->sc_rintr, PWAIT, "esohi", sc->sc_rdrain);
	splx(s);
d930 1
d932 1
d948 1
a948 1
			return (EINVAL);
d967 1
a967 1
			return (EINVAL);
d977 1
a977 1
			return (EINVAL);
d992 1
a992 1
			return (EINVAL);
d1003 1
a1003 1
			return (EINVAL);
d1016 1
a1016 1
			return (EINVAL);
d1028 1
a1028 1
			return (EINVAL);
d1039 1
a1039 1
			return (EINVAL);
d1054 1
a1054 1
			return (EINVAL);
d1077 1
a1077 1
			return (EINVAL);
d1079 2
a1080 1
		return (eso_set_monooutsrc(sc, cp->un.ord));
d1084 1
a1084 1
			return (EINVAL);
d1086 2
a1087 1
		return (eso_set_monoinbypass(sc, cp->un.ord));
d1091 1
a1091 1
			return (EINVAL);
d1105 1
a1105 1
			return (EINVAL);
d1107 2
a1108 1
		return (eso_set_recsrc(sc, cp->un.ord));
d1112 1
a1112 1
			return (EINVAL);
d1114 2
a1115 1
		return (eso_set_preamp(sc, cp->un.ord));
d1118 1
a1118 1
		return (EINVAL);
d1121 5
a1125 1
	return (0);
d1133 1
d1170 1
a1170 1
			return (EINVAL);
d1179 1
a1179 1
			return (EINVAL);
d1216 1
a1216 1
		return (EINVAL);
d1219 5
a1223 2
	return (0);
	
d1784 1
d1790 1
a1790 1

d1886 1
d1890 1
a1890 1

@


1.34
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.33 2010/08/27 18:50:57 deraadt Exp $	*/
d131 1
a131 1
void	eso_setup(struct eso_softc *, int);
d254 1
a254 1
	eso_setup(sc, 1);
d294 1
d324 1
a324 1
eso_setup(struct eso_softc *sc, int verbose)
d327 1
a327 1
	uint8_t a2mode, mvctl;
d352 13
a364 12
	mvctl = eso_read_mixreg(sc, ESO_MIXREG_MVCTL);
	mvctl &= ~ESO_MIXREG_MVCTL_SPLIT;
	mvctl |= ESO_MIXREG_MVCTL_HVIRQM;
	eso_write_mixreg(sc, ESO_MIXREG_MVCTL, mvctl);

	/* Set mixer regs to something reasonable, needs work. */
	sc->sc_recmon = sc->sc_spatializer = sc->sc_mvmute = 0;
	eso_set_monooutsrc(sc, ESO_MIXREG_MPM_MOMUTE);
	eso_set_monoinbypass(sc, 0);
	eso_set_preamp(sc, 1);
	for (idx = 0; idx < ESO_NGAINDEVS; idx++) {
		int v;
d366 65
a430 21
		switch (idx) {
 		case ESO_MIC_PLAY_VOL:
		case ESO_LINE_PLAY_VOL:
		case ESO_CD_PLAY_VOL:
		case ESO_MONO_PLAY_VOL:
		case ESO_AUXB_PLAY_VOL:
		case ESO_DAC_REC_VOL:
		case ESO_LINE_REC_VOL:
		case ESO_SYNTH_REC_VOL:
		case ESO_CD_REC_VOL:
		case ESO_MONO_REC_VOL:
		case ESO_AUXB_REC_VOL:
		case ESO_SPATIALIZER:
			v = 0;
			break;
		case ESO_MASTER_VOL:
			v = ESO_GAIN_TO_6BIT(AUDIO_MAX_GAIN / 2);
			break;
		default:
			v = ESO_GAIN_TO_4BIT(AUDIO_MAX_GAIN / 2);
			break;
d432 3
a434 2
		sc->sc_gain[idx][ESO_LEFT] = sc->sc_gain[idx][ESO_RIGHT] = v;
		eso_set_gain(sc, idx);
a435 1
	eso_set_recsrc(sc, ESO_MIXREG_ERS_MIC);
d464 1
d871 1
a871 1
	error = tsleep(&sc->sc_pintr, PCATCH | PWAIT, "esoho", sc->sc_pdrain);
d898 1
a898 1
	error = tsleep(&sc->sc_rintr, PCATCH | PWAIT, "esohi", sc->sc_rdrain);
d1739 2
a1740 3
	sc->sc_pdrain = (blksize * NBBY * hz) / 
	    (param->sample_rate * param->channels *
	     param->precision * param->factor) + 2;	/* slop */
d1821 2
a1822 3
	sc->sc_rdrain = (blksize * NBBY * hz) / 
	    (param->sample_rate * param->channels *
	     param->precision * param->factor) + 2;	/* slop */
d2105 3
a2107 1
	struct eso_softc *sc = (struct eso_softc *)self;	
d2110 6
a2116 3
		eso_halt_output(sc);
		eso_halt_input(sc);

d2118 4
a2121 5
		bus_space_write_1(sc->sc_dmac_iot,
				  sc->sc_dmac_ioh, ESO_DMAC_CLEAR, 0);
		bus_space_write_1(sc->sc_sb_iot,
				  sc->sc_sb_ioh, ESO_SB_STATUSFLAGS, 3);

d2123 2
a2124 2
		pci_conf_write(sc->sc_pa.pa_pc,
		    sc->sc_pa.pa_tag, ESO_PCI_DDMAC, 0);
d2127 4
a2130 1
		eso_setup(sc, 0);
d2133 1
a2133 1
	return 0;
@


1.33
log
@Since the changes in neo(4) work, it is very likely that the exact same
mechnical changes work in these drivers too.  Testing can occur after
this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.32 2010/07/15 03:43:11 jakemsr Exp $	*/
a132 3
void	eso_powerhook(int, void *);


a309 2
	sc->sc_powerhook = powerhook_establish(&eso_powerhook, sc);

a2081 7
}

void
eso_powerhook(int why, void *self)
{
	eso_activate(self, why);

@


1.32
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.31 2010/05/23 11:41:07 deraadt Exp $	*/
d93 1
d97 2
a98 1
	sizeof (struct eso_softc), eso_match, eso_attach
d2062 2
a2063 2
void
eso_powerhook(int why, void *self)
d2067 2
a2068 1
	if (why != PWR_RESUME) {
d2080 3
a2082 2
			       sc->sc_pa.pa_tag, ESO_PCI_DDMAC, 0);
	} else
d2084 10
@


1.31
log
@rely on __alpha__, __amd64__, and __i386__ instead
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.30 2010/04/28 21:24:06 kettenis Exp $	*/
d679 2
d691 2
d753 2
@


1.30
log
@s/amd64/__amd64__/, s/i386/__i386__, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.29 2010/04/08 00:23:53 tedu Exp $	*/
d1565 1
a1565 1
#ifdef alpha
d1572 1
a1572 1
#elif defined(amd64) || defined(i386)
@


1.29
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.28 2009/03/29 21:53:52 sthen Exp $	*/
d64 1
a64 1
#if defined(amd64) || defined(i386)
@


1.28
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.27 2008/10/25 22:30:43 jakemsr Exp $	*/
a40 1
#include <sys/proc.h>
@


1.27
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.26 2008/05/29 07:20:15 jakemsr Exp $	*/
d231 1
a231 1
		printf(", can't map I/O space\n");
d236 1
a236 1
		printf(", can't map SB I/O space\n");
d246 1
a246 1
		printf(", can't map MPU I/O space\n");
@


1.26
log
@
specify alternate default audio parameters to make the default expansion
factor 1

also obsoletes a XXX workaround in azalia

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.25 2008/04/21 00:32:43 jakemsr Exp $	*/
d711 8
a718 5
		if (p->sample_rate < ESO_MINRATE ||
		    p->sample_rate > ESO_MAXRATE ||
		    (p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return (EINVAL);
@


1.25
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.24 2008/02/17 05:18:42 brad Exp $	*/
d113 1
d162 1
a162 1
	NULL
d682 11
@


1.24
log
@some cleaning.

- ANSI
- remove use of static
- remove some #ifdef's
- remove some white space

ok jakemsr@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.23 2007/11/11 01:32:52 jakemsr Exp $	*/
d161 1
@


1.23
log
@
bring in ~7 years worth of improvements and bug fixes from NetBSD

user noticible highlights:
- recording works
- setting the blockize works correctly
- added master volume mute

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.6 1999/12/04 21:39:29 deraadt Exp $	*/
a35 8
#ifdef __OpenBSD__
#define HIDE
#define MATCH_ARG_2_T void *
#else
#define HIDE static
#define MATCH_ARG_2_T struct cfdata *
#endif

d92 3
a94 4
/* Autoconfiguration interface */
HIDE int eso_match(struct device *, MATCH_ARG_2_T, void *);
HIDE void eso_attach(struct device *, struct device *, void *);
HIDE void eso_defer(struct device *);
a99 1
#ifdef __OpenBSD__
a102 1
#endif
d105 1
a105 1
HIDE int eso_intr(void *);
d108 4
a111 4
HIDE int	eso_open(void *, int);
HIDE void	eso_close(void *);
HIDE int	eso_query_encoding(void *, struct audio_encoding *);
HIDE int	eso_set_params(void *, int, int, struct audio_params *,
d113 13
a125 13
HIDE int	eso_round_blocksize(void *, int);
HIDE int	eso_halt_output(void *);
HIDE int	eso_halt_input(void *);
HIDE int	eso_getdev(void *, struct audio_device *);
HIDE int	eso_set_port(void *, mixer_ctrl_t *);
HIDE int	eso_get_port(void *, mixer_ctrl_t *);
HIDE int	eso_query_devinfo(void *, mixer_devinfo_t *);
HIDE void *	eso_allocm(void *, int, size_t, int, int);
HIDE void	eso_freem(void *, void *, int);
HIDE size_t	eso_round_buffersize(void *, int, size_t);
HIDE paddr_t	eso_mappage(void *, void *, off_t, int);
HIDE int	eso_get_props(void *);
HIDE int	eso_trigger_output(void *, void *, void *, int,
d127 1
a127 1
HIDE int	eso_trigger_input(void *, void *, void *, int,
d129 1
a129 1
HIDE void       eso_setup(struct eso_softc *, int);
d131 1
a131 1
HIDE void       eso_powerhook(int, void *);
d134 1
a134 1
HIDE struct audio_hw_if eso_hw_if = {
d163 1
a163 1
HIDE const char * const eso_rev2model[] = {
d173 1
d175 14
a188 13
HIDE uint8_t	eso_read_ctlreg(struct eso_softc *, uint8_t);
HIDE uint8_t	eso_read_mixreg(struct eso_softc *, uint8_t);
HIDE uint8_t	eso_read_rdr(struct eso_softc *);
HIDE void	eso_reload_master_vol(struct eso_softc *);
HIDE int	eso_reset(struct eso_softc *);
HIDE void	eso_set_gain(struct eso_softc *, unsigned int);
HIDE int	eso_set_recsrc(struct eso_softc *, unsigned int);
HIDE int	eso_set_monooutsrc(struct eso_softc *, unsigned int);
HIDE int	eso_set_monoinbypass(struct eso_softc *, unsigned int);
HIDE int	eso_set_preamp(struct eso_softc *, unsigned int);
HIDE void	eso_write_cmd(struct eso_softc *, uint8_t);
HIDE void	eso_write_ctlreg(struct eso_softc *, uint8_t, uint8_t);
HIDE void	eso_write_mixreg(struct eso_softc *, uint8_t, uint8_t);
d190 1
a190 1
HIDE int	eso_allocmem(struct eso_softc *, size_t, size_t, size_t,
d192 1
a192 1
HIDE void	eso_freemem(struct eso_dma *);
d195 2
a196 5
HIDE int
eso_match(parent, match, aux)
	struct device *parent;
	MATCH_ARG_2_T match;
	void *aux;
d207 2
a208 4
HIDE void
eso_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a261 1
#ifdef __OpenBSD__
a263 3
#else
	sc->sc_ih  = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, eso_intr, sc);
#endif
d324 2
a325 4
HIDE void
eso_setup(sc, verbose)
	struct eso_softc *sc;
	int verbose;
d394 2
a395 3
HIDE void
eso_defer(self)
	struct device *self;
d429 2
a430 4
HIDE void
eso_write_cmd(sc, cmd)
	struct eso_softc *sc;
	uint8_t cmd;
a446 1
	return;
d450 2
a451 4
HIDE void
eso_write_ctlreg(sc, reg, val)
	struct eso_softc *sc;
	uint8_t reg, val;
d461 2
a462 3
HIDE uint8_t
eso_read_rdr(sc)
	struct eso_softc *sc;
d481 2
a482 4
HIDE uint8_t
eso_read_ctlreg(sc, reg)
	struct eso_softc *sc;
	uint8_t reg;
a483 1

d489 2
a490 4
HIDE void
eso_write_mixreg(sc, reg, val)
	struct eso_softc *sc;
	uint8_t reg, val;
d502 2
a503 4
HIDE uint8_t
eso_read_mixreg(sc, reg)
	struct eso_softc *sc;
	uint8_t reg;
d516 2
a517 3
HIDE int
eso_intr(hdl)
	void *hdl;
d575 2
a576 3
HIDE int
eso_reset(sc)
	struct eso_softc *sc;
d612 2
a613 4
HIDE int
eso_open(hdl, flags)
	void *hdl;
	int flags;
d618 2
a619 3
HIDE void
eso_close(hdl)
	void *hdl;
d623 2
a624 4
HIDE int
eso_query_encoding(hdl, fp)
	void *hdl;
	struct audio_encoding *fp;
a625 1
	
d682 3
a684 5
HIDE int
eso_set_params(hdl, setmode, usemode, play, rec)
	void *hdl;
	int setmode, usemode;
	struct audio_params *play, *rec;
d689 2
a690 2
	unsigned int srg, fltdiv;
	
d703 1
a703 1
		
d774 2
a775 4
HIDE int
eso_round_blocksize(hdl, blk)
	void *hdl;
	int blk;
a776 1

d780 2
a781 3
HIDE int
eso_halt_output(hdl)
	void *hdl;
d816 2
a817 3
HIDE int
eso_halt_input(hdl)
	void *hdl;
d845 2
a846 4
HIDE int
eso_getdev(hdl, retp)
	void *hdl;
	struct audio_device *retp;
d859 1
a859 1
	
d863 2
a864 4
HIDE int
eso_set_port(hdl, cp)
	void *hdl;
	mixer_ctrl_t *cp;
d867 1
a867 1
	unsigned int lgain, rgain;
d869 1
a869 1
	
d886 1
a886 1
		
d948 1
a948 1
		
d961 1
a961 1
		
d1011 1
a1011 1
		
d1029 1
a1029 1
		
d1049 1
a1049 1
		
d1053 1
a1053 1
	
d1057 2
a1058 4
HIDE int
eso_get_port(hdl, cp)
	void *hdl;
	mixer_ctrl_t *cp;
d1101 1
a1101 1
		
d1115 1
a1115 1
		
d1127 1
a1127 1
		
d1131 1
a1131 1
		
a1146 1

d1151 2
a1152 4
HIDE int
eso_query_devinfo(hdl, dip)
	void *hdl;
	mixer_devinfo_t *dip;
a1153 1

a1219 1

a1239 1
		
a1245 1
		
a1269 1

a1294 1

a1313 1

a1338 1
	
a1345 1

a1365 1

a1463 1
		
d1471 3
a1473 9
HIDE int
eso_allocmem(sc, size, align, boundary, flags, direction, ed)
	struct eso_softc *sc;
	size_t size;
	size_t align;
	size_t boundary;
	int flags;
	int direction;
	struct eso_dma *ed;
d1479 1
a1479 1
	
d1514 2
a1515 3
HIDE void
eso_freemem(ed)
	struct eso_dma *ed;
a1516 1

d1523 2
a1524 6
HIDE void *
eso_allocm(hdl, direction, size, type, flags)
	void *hdl;
	int direction;
	size_t size;
	int type, flags;
a1544 1

d1578 2
a1579 5
HIDE void
eso_freem(hdl, addr, type)
	void *hdl;
	void *addr;
	int type;
d1594 2
a1595 5
HIDE size_t
eso_round_buffersize(hdl, direction, bufsize)
	void *hdl;
	int direction;
	size_t bufsize;
d1617 2
a1618 6
HIDE paddr_t
eso_mappage(hdl, addr, offs, prot)
	void *hdl;
	void *addr;
	off_t offs;
	int prot;
d1630 1
a1630 1
	
d1636 2
a1637 3
HIDE int
eso_get_props(hdl)
	void *hdl;
a1638 1

d1643 3
a1645 8
HIDE int
eso_trigger_output(hdl, start, end, blksize, intr, arg, param)
	void *hdl;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1650 1
a1650 1
	
d1657 1
a1657 1
	
d1669 1
a1669 1
	
d1701 1
a1701 1
	
d1708 1
a1708 1
	
d1715 1
a1715 1
	
d1719 3
a1721 8
HIDE int
eso_trigger_input(hdl, start, end, blksize, intr, arg, param)
	void *hdl;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1822 2
a1823 4
HIDE int
eso_set_recsrc(sc, recsrc)
	struct eso_softc *sc;
	unsigned int recsrc;
d1846 2
a1847 4
HIDE int
eso_set_monooutsrc(sc, monooutsrc)
	struct eso_softc *sc;
	unsigned int monooutsrc;
d1874 2
a1875 4
HIDE int
eso_set_monoinbypass(sc, monoinbypass)
	struct eso_softc *sc;
	unsigned int monoinbypass;
d1898 1
a1898 1
	
d1902 2
a1903 4
HIDE int
eso_set_preamp(sc, preamp)
	struct eso_softc *sc;
	unsigned int preamp;
d1926 1
a1926 1
	
d1934 2
a1935 3
HIDE void
eso_reload_master_vol(sc)
	struct eso_softc *sc;
d1949 2
a1950 4
HIDE void
eso_set_gain(sc, port)
	struct eso_softc *sc;
	unsigned int port;
a1972 1
		    
a1996 1
		
a2004 1

a2014 1

a2019 1
		
a2024 1

d2039 2
a2040 5

HIDE void
eso_powerhook(why, self)
	int why;
	void *self;
d2047 1
a2047 1
		
d2053 1
a2053 1
		
@


1.22
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: eso.c,v 1.21 2005/04/14 12:42:16 mickey Exp $	*/
/*	$NetBSD: eso.c,v 1.3 1999/08/02 17:37:43 augustss Exp $	*/
d5 1
a5 1
 * Copyright (c) 1999 Klaus J. Klein
a64 1
#include <dev/audiovar.h>
d69 11
d81 2
a82 1
#define DPRINTF(x) printf x
d84 1
a84 1
#define DPRINTF(x)
d88 1
d188 1
d192 3
d200 2
a201 2
		    int, struct eso_dma *);
HIDE void	eso_freemem(struct eso_softc *, struct eso_dma *);
d230 1
a255 1

a260 5
	if (pci_mapreg_map(pa, ESO_PCI_BAR_GAME, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_game_iot, &sc->sc_game_ioh, NULL, NULL, 0)) {
		printf(", can't map Game I/O space\n");
		return;
	}
a329 1
#if 0
d334 6
a339 1
#endif
d348 1
a348 1
	uint8_t a2mode;
d364 3
a366 2
			  ESO_IO_IRQCTL_A1IRQ | ESO_IO_IRQCTL_A2IRQ);
	
d372 6
d379 4
d560 2
a561 1
	if ((irqctl & (ESO_IO_IRQCTL_A1IRQ | ESO_IO_IRQCTL_A2IRQ)) == 0)
d588 15
a602 2
#if 0
	if ((irqctl & ESO_IO_IRQCTL_MPUIRQ) && sc->sc_mpudev != 0)
a652 7
	struct eso_softc *sc = hdl;
	
	DPRINTF(("%s: open\n", sc->sc_dev.dv_xname));

	sc->sc_pintr = NULL;
	sc->sc_rintr = NULL;
	
a659 2

	DPRINTF(("%s: close\n", ((struct eso_softc *)hdl)->sc_dev.dv_xname));
d676 2
a677 2
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
d679 1
a679 1
		fp->flags = 0;
d682 4
a685 13
		fp->precision = 16;
		if (fp->flags & AUOPEN_READ) {
			strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
			if (fp->flags & AUOPEN_WRITE)
				fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
			else
				fp->flags = 0;
		} else {
			strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
			fp->flags = 0;
		}
d688 4
a691 13
		fp->precision = 16;
		if (fp->flags & AUOPEN_READ) {
			strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
			if (fp->flags & AUOPEN_WRITE)
				fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
			else
				fp->flags = 0;
		} else {
			strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
			fp->flags = 0;
		}
d694 2
d697 1
a697 8
		if (fp->flags & AUOPEN_READ) {
			strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		} else {
			strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		}
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
d700 2
d703 1
a703 8
		if (fp->flags & AUOPEN_READ) {
			strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		} else {
			strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		}
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
d706 3
a708 3
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
d712 3
a714 3
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
d732 1
a732 1
	int mode, r[2], rd[2], clk;
d753 1
a753 1
			if (mode == AUMODE_PLAY && p->precision == 16)
a757 2
			if (mode == AUMODE_RECORD && p->precision == 16)
				p->sw_code = swap_bytes;
d762 1
a762 1
				p->sw_code = mulaw_to_ulinear16;
d770 1
a770 1
				p->sw_code = alaw_to_ulinear16;
d789 3
a791 1
		clk = ABS(p->sample_rate - r[0]) > ABS(p->sample_rate - r[1]);
d795 1
a795 1
		fltdiv = 256 - 200279L / p->sample_rate;
d854 1
a854 1
	error = tsleep(&sc->sc_pintr, PCATCH | PWAIT, "esoho", hz);
d882 1
a882 1
	error = tsleep(&sc->sc_rintr, PCATCH | PWAIT, "esohi", hz);
a893 1
/* ARGSUSED */
d904 1
a904 1
	if (sc->sc_revision <=
d1041 23
d1069 7
a1075 1
		sc->sc_monooutsrc = cp->un.ord;
a1076 6
		tmp = eso_read_mixreg(sc, ESO_MIXREG_MPM);
		tmp &= ~ESO_MIXREG_MPM_MOMASK;
		tmp |= sc->sc_monooutsrc;
		eso_write_mixreg(sc, ESO_MIXREG_MPM, tmp);
		break;
		
d1101 1
a1101 10
		sc->sc_preamp = (cp->un.ord != 0);
		
		tmp = eso_read_mixreg(sc, ESO_MIXREG_MPM);
		tmp &= ~ESO_MIXREG_MPM_RESV0;
		if (sc->sc_preamp)
			tmp |= ESO_MIXREG_MPM_PREAMP;
		else
			tmp &= ~ESO_MIXREG_MPM_PREAMP;
		eso_write_mixreg(sc, ESO_MIXREG_MPM, tmp);
		break;
d1118 5
a1128 1
	case ESO_MASTER_VOL:
d1178 4
d1191 7
d1310 2
a1311 1
		dip->next = dip->prev = AUDIO_MIXER_LAST;
d1318 15
d1358 21
d1541 1
a1541 1
eso_allocmem(sc, size, align, boundary, flags, ed)
d1547 1
d1555 1
a1555 1
	error = bus_dmamem_alloc(sc->sc_dmat, ed->ed_size, align, boundary,
d1561 1
a1561 1
	error = bus_dmamem_map(sc->sc_dmat, ed->ed_segs, ed->ed_nsegs,
d1566 2
a1567 2
	error = bus_dmamap_create(sc->sc_dmat, ed->ed_size, 1, ed->ed_size, 0,
	    wait, &ed->ed_map);
d1571 3
a1573 2
	error = bus_dmamap_load(sc->sc_dmat, ed->ed_map, ed->ed_addr,
	    ed->ed_size, NULL, wait);
d1580 1
a1580 1
	bus_dmamap_destroy(sc->sc_dmat, ed->ed_map);
d1582 1
a1582 1
	bus_dmamem_unmap(sc->sc_dmat, ed->ed_addr, ed->ed_size);
d1584 1
a1584 1
	bus_dmamem_free(sc->sc_dmat, ed->ed_segs, ed->ed_nsegs);
d1590 1
a1590 2
eso_freemem(sc, ed)
	struct eso_softc *sc;
d1594 4
a1597 4
	bus_dmamap_unload(sc->sc_dmat, ed->ed_map);
	bus_dmamap_destroy(sc->sc_dmat, ed->ed_map);
	bus_dmamem_unmap(sc->sc_dmat, ed->ed_addr, ed->ed_size);
	bus_dmamem_free(sc->sc_dmat, ed->ed_segs, ed->ed_nsegs);
d1612 1
a1612 1
	if ((ed = malloc(size, type, flags)) == NULL)
d1618 2
a1619 2
	 * take care of that ourselves.  The second channel DMA controller
	 * doesn't have that restriction, however.
d1624 1
a1624 1
		boundary = 0;
d1627 23
a1649 1
	error = eso_allocmem(sc, size, 32, boundary, flags, ed);
d1671 1
a1671 1
			eso_freemem(sc, p);
d1685 1
d1687 14
a1700 3
	/* 64K restriction: ISA at eleven? */
	if (bufsize > 65536)
		bufsize = 65536;
d1717 1
a1717 1
	for (ed = sc->sc_dmas; ed != NULL && KVADDR(ed) == addr;
d1723 1
a1723 1
	return (bus_dmamem_mmap(sc->sc_dmat, ed->ed_segs, ed->ed_nsegs,
d1766 2
d1772 5
d1850 1
a1850 1
		printf("%s: trigger_output: bad addr %p\n",
d1854 2
d1860 5
d1923 3
d1931 80
d2012 48
a2059 3
	eso_write_mixreg(sc, ESO_MIXREG_ERS, recsrc);
	sc->sc_recsrc = recsrc;
	return (0);
d2125 1
a2125 1
		/* Map bits 7:2 -> 5:0. */
d2127 2
a2128 1
		    sc->sc_gain[port][ESO_LEFT] >> 2);
d2130 2
a2131 1
		    sc->sc_gain[port][ESO_RIGHT] >> 2);
d2148 2
a2149 1
		panic("eso_set_gain: bad port %u", port);
@


1.21
log
@make sure round_blocksize does not produce 0 after alignment
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.20 2003/05/01 22:44:21 jason Exp $	*/
a256 6
	/* Enable bus mastering. */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		       pci_conf_read(pa->pa_pc, pa->pa_tag,
				     PCI_COMMAND_STATUS_REG) |
		       PCI_COMMAND_MASTER_ENABLE);
	
@


1.20
log
@- initialize sc_pa before using it
- fix another uninitialized variable
- ditch htopci() and pcitoh()... they are completely wrong with bus_space(9)
partially from NetBSD; ok mickey/millert
upshot: now works on sparc64 (and probably macppc)
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.19 2003/04/27 11:22:53 ho Exp $	*/
d827 1
a827 1
	return (blk & -32);	/* keep good alignment; at least 16 req'd */
@


1.19
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.18 2002/06/09 02:31:20 mickey Exp $	*/
a69 15
#ifdef __OpenBSD__
#include <machine/endian.h>
#define htopci(x) htole32(x)
#define pcitoh(x) letoh32(x)
#else
#if BYTE_ORDER == BIG_ENDIAN
#include <machine/bswap.h>
#define htopci(x) bswap32(x)
#define pcitoh(x) bswap32(x)
#else
#define htopci(x) (x)
#define pcitoh(x) (x)
#endif
#endif

d255 2
a312 1
		sc->sc_pa = *pa; 
d1581 1
a1581 1
	struct eso_softc *sc;
d1698 1
a1698 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAA,
	    htopci(DMAADDR(ed)));
d1700 1
a1700 1
	    htopci((uint8_t *)end - (uint8_t *)start));
d1799 1
a1799 1
	    htopci(DMAADDR(ed)));
d1801 1
a1801 1
	    htopci((uint8_t *)end - (uint8_t *)start - 1));
@


1.18
log
@fix resuming the eso through the powerhook; from marius aamodt eriksen <marius@@gone.crockster.net> via pr2704; from the #40 train
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.17 2002/03/14 03:16:06 millert Exp $	*/
d659 1
a659 1
		strcpy(fp->name, AudioEulinear);
d665 1
a665 1
		strcpy(fp->name, AudioEslinear);
d673 1
a673 1
			strcpy(fp->name, AudioEslinear_be);
d680 1
a680 1
			strcpy(fp->name, AudioEslinear_le);
d688 1
a688 1
			strcpy(fp->name, AudioEulinear_be);
d695 1
a695 1
			strcpy(fp->name, AudioEulinear_le);
d703 1
a703 1
			strcpy(fp->name, AudioEslinear_le);
d706 1
a706 1
			strcpy(fp->name, AudioEslinear_be);
d714 1
a714 1
			strcpy(fp->name, AudioEulinear_le);
d717 1
a717 1
			strcpy(fp->name, AudioEulinear_be);
d723 1
a723 1
		strcpy(fp->name, AudioEmulaw);
d729 1
a729 1
		strcpy(fp->name, AudioEalaw);
d919 2
a920 6
	strncpy(retp->name, "ESS Solo-1", sizeof (retp->name));
#ifdef __OpenBSD__
	/* This does not overflow. */
	sprintf(retp->version, "0x%02x", sc->sc_revision);
#else
	snprintf(retp->version, sizeof (retp->version), "0x%02x",
a921 1
#endif
d924 2
a925 2
		strncpy(retp->config, eso_rev2model[sc->sc_revision],
		    sizeof (retp->config));
d927 1
a927 1
		strncpy(retp->config, "unknown", sizeof (retp->config));
d1206 1
a1206 1
		strcpy(dip->label.name, AudioNdac);
d1209 2
a1210 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1215 2
a1216 1
		strcpy(dip->label.name, AudioNmicrophone);
d1219 2
a1220 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1225 1
a1225 1
		strcpy(dip->label.name, AudioNline);
d1228 2
a1229 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1234 2
a1235 1
		strcpy(dip->label.name, AudioNfmsynth);
d1238 2
a1239 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1244 1
a1244 1
		strcpy(dip->label.name, "mono_in");
d1247 2
a1248 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1253 1
a1253 1
		strcpy(dip->label.name, AudioNcd);
d1256 2
a1257 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1262 1
a1262 1
		strcpy(dip->label.name, "auxb");
d1265 2
a1266 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1272 1
a1272 1
		strcpy(dip->label.name, AudioNpreamp);
d1275 2
a1276 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d1278 2
a1279 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d1285 2
a1286 1
		strcpy(dip->label.name, AudioNmicrophone);
d1293 1
a1293 1
		strcpy(dip->label.name, AudioCinputs);
d1300 1
a1300 1
		strcpy(dip->label.name, AudioNmaster);
d1303 2
a1304 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1309 1
a1309 1
		strcpy(dip->label.name, "pc_speaker");
d1312 2
a1313 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1318 1
a1318 1
		strcpy(dip->label.name, "mono_out");
d1321 2
a1322 1
		strcpy(dip->un.e.member[0].label.name, AudioNmute);
d1324 2
a1325 1
		strcpy(dip->un.e.member[1].label.name, AudioNdac);
d1327 2
a1328 1
		strcpy(dip->un.e.member[2].label.name, AudioNmixerout);
d1335 2
a1336 1
		strcpy(dip->label.name, AudioNspatial);
d1339 2
a1340 1
		strcpy(dip->un.v.units.name, "level");
d1346 1
a1346 1
		strcpy(dip->label.name, "enable");
d1349 2
a1350 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d1352 2
a1353 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d1360 2
a1361 1
		strcpy(dip->label.name, AudioCoutputs);
d1368 1
a1368 1
		strcpy(dip->label.name, AudioNmute);
d1371 2
a1372 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d1374 2
a1375 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d1381 2
a1382 1
		strcpy(dip->label.name, AudioCmonitor);
d1389 1
a1389 1
		strcpy(dip->label.name, AudioNrecord);
d1391 2
a1392 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1397 1
a1397 1
		strcpy(dip->label.name, AudioNsource);
d1400 2
a1401 1
		strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
d1403 2
a1404 1
		strcpy(dip->un.e.member[1].label.name, AudioNline);
d1406 2
a1407 1
		strcpy(dip->un.e.member[2].label.name, AudioNcd);
d1409 2
a1410 1
		strcpy(dip->un.e.member[3].label.name, AudioNmixerout);
d1416 1
a1416 1
		strcpy(dip->label.name, AudioNdac);
d1419 2
a1420 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1425 2
a1426 1
		strcpy(dip->label.name, AudioNmicrophone);
d1429 2
a1430 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1435 1
a1435 1
		strcpy(dip->label.name, AudioNline);
d1438 2
a1439 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1444 2
a1445 1
		strcpy(dip->label.name, AudioNfmsynth);
d1448 2
a1449 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1454 1
a1454 1
		strcpy(dip->label.name, "mono_in");
d1457 2
a1458 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1463 1
a1463 1
		strcpy(dip->label.name, AudioNcd);
d1466 2
a1467 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1472 1
a1472 1
		strcpy(dip->label.name, "auxb");
d1475 2
a1476 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1481 1
a1481 1
		strcpy(dip->label.name, AudioCrecord);
@


1.17
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.16 2002/03/14 01:26:58 millert Exp $	*/
d143 4
a228 2
	int idx;
	uint8_t a2mode;
d272 3
a274 8
	    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG) |
	    PCI_COMMAND_MASTER_ENABLE);

	/* Reset the device; bail out upon failure. */
	if (eso_reset(sc) != 0) {
		printf(", can't reset\n");
		return;
	}
d276 1
a276 4
	/* Select the DMA/IRQ policy: DDMA, ISA IRQ emulation disabled. */
	pci_conf_write(pa->pa_pc, pa->pa_tag, ESO_PCI_S1C,
	    pci_conf_read(pa->pa_pc, pa->pa_tag, ESO_PCI_S1C) &
	    ~(ESO_PCI_S1C_IRQP_MASK | ESO_PCI_S1C_DMAP_MASK));
d278 1
a278 41
	/* Enable the relevant DMA interrupts. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_IRQCTL,
	    ESO_IO_IRQCTL_A1IRQ | ESO_IO_IRQCTL_A2IRQ);
	
	/* Set up A1's sample rate generator for new-style parameters. */
	a2mode = eso_read_mixreg(sc, ESO_MIXREG_A2MODE);
	a2mode |= ESO_MIXREG_A2MODE_NEWA1 | ESO_MIXREG_A2MODE_ASYNC;
	eso_write_mixreg(sc, ESO_MIXREG_A2MODE, a2mode);
	
	/* Set mixer regs to something reasonable, needs work. */
	for (idx = 0; idx < ESO_NGAINDEVS; idx++) {
		int v;
		
		switch (idx) {
 		case ESO_MIC_PLAY_VOL:
		case ESO_LINE_PLAY_VOL:
		case ESO_CD_PLAY_VOL:
		case ESO_MONO_PLAY_VOL:
		case ESO_AUXB_PLAY_VOL:
		case ESO_DAC_REC_VOL:
		case ESO_LINE_REC_VOL:
		case ESO_SYNTH_REC_VOL:
		case ESO_CD_REC_VOL:
		case ESO_MONO_REC_VOL:
		case ESO_AUXB_REC_VOL:
		case ESO_SPATIALIZER:
			v = 0;
			break;
		case ESO_MASTER_VOL:
			v = ESO_GAIN_TO_6BIT(AUDIO_MAX_GAIN / 2);
			break;
		default:
			v = ESO_GAIN_TO_4BIT(AUDIO_MAX_GAIN / 2);
			break;
		}
		sc->sc_gain[idx][ESO_LEFT] = sc->sc_gain[idx][ESO_RIGHT] = v;
		eso_set_gain(sc, idx);
	}
	eso_set_recsrc(sc, ESO_MIXREG_ERS_MIC);
	
	/* Map and establish the interrupt. */
d286 1
a286 1
	    sc->sc_dev.dv_xname);
d315 1
d318 1
a318 1
		    vcbase | ESO_PCI_DDMAC_DE);
d320 1
a320 1

d322 1
a322 1
		    sc->sc_dev.dv_xname, (unsigned long)vcbase);
d325 3
a327 3
		    sc->sc_dev.dv_xname, (unsigned long)vcbase));
		sc->sc_pa = *pa;
		config_defer(self, eso_defer);
d337 2
d348 61
d1897 25
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.15 2002/01/20 19:56:53 ericj Exp $	*/
d139 4
a142 4
HIDE int	eso_trigger_output __P((void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *));
HIDE int	eso_trigger_input __P((void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *));
@


1.15
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.14 2001/10/31 11:00:24 art Exp $	*/
d104 3
a106 3
HIDE int eso_match __P((struct device *, MATCH_ARG_2_T, void *));
HIDE void eso_attach __P((struct device *, struct device *, void *));
HIDE void eso_defer __P((struct device *));
d119 1
a119 1
HIDE int eso_intr __P((void *));
d122 17
a138 17
HIDE int	eso_open __P((void *, int));
HIDE void	eso_close __P((void *));
HIDE int	eso_query_encoding __P((void *, struct audio_encoding *));
HIDE int	eso_set_params __P((void *, int, int, struct audio_params *,
		    struct audio_params *));
HIDE int	eso_round_blocksize __P((void *, int));
HIDE int	eso_halt_output __P((void *));
HIDE int	eso_halt_input __P((void *));
HIDE int	eso_getdev __P((void *, struct audio_device *));
HIDE int	eso_set_port __P((void *, mixer_ctrl_t *));
HIDE int	eso_get_port __P((void *, mixer_ctrl_t *));
HIDE int	eso_query_devinfo __P((void *, mixer_devinfo_t *));
HIDE void *	eso_allocm __P((void *, int, size_t, int, int));
HIDE void	eso_freem __P((void *, void *, int));
HIDE size_t	eso_round_buffersize __P((void *, int, size_t));
HIDE paddr_t	eso_mappage __P((void *, void *, off_t, int));
HIDE int	eso_get_props __P((void *));
d184 9
a192 9
HIDE uint8_t	eso_read_ctlreg __P((struct eso_softc *, uint8_t));
HIDE uint8_t	eso_read_mixreg __P((struct eso_softc *, uint8_t));
HIDE uint8_t	eso_read_rdr __P((struct eso_softc *));
HIDE int	eso_reset __P((struct eso_softc *));
HIDE void	eso_set_gain __P((struct eso_softc *, unsigned int));
HIDE int	eso_set_recsrc __P((struct eso_softc *, unsigned int));
HIDE void	eso_write_cmd __P((struct eso_softc *, uint8_t));
HIDE void	eso_write_ctlreg __P((struct eso_softc *, uint8_t, uint8_t));
HIDE void	eso_write_mixreg __P((struct eso_softc *, uint8_t, uint8_t));
d194 3
a196 3
HIDE int	eso_allocmem __P((struct eso_softc *, size_t, size_t, size_t,
		    int, struct eso_dma *));
HIDE void	eso_freemem __P((struct eso_softc *, struct eso_dma *));
d1607 1
a1607 1
	void (*intr) __P((void *));
d1682 1
a1682 1
	void (*intr) __P((void *));
@


1.14
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.13 2001/09/21 17:55:43 miod Exp $	*/
a163 3
#ifdef __OpenBSD__
	0,
#else
a164 1
#endif
a165 3
#ifdef __OpenBSD__
	0, 
#else
a166 1
#endif
a170 4
#ifdef __OpenBSD__
	eso_allocm,
	eso_round_buffersize
#endif
@


1.14.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.15 2002/01/20 19:56:53 ericj Exp $	*/
d164 3
d168 1
d170 3
d174 1
d179 4
@


1.14.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.14.2.1 2002/01/31 22:55:34 niklas Exp $	*/
d104 3
a106 3
HIDE int eso_match(struct device *, MATCH_ARG_2_T, void *);
HIDE void eso_attach(struct device *, struct device *, void *);
HIDE void eso_defer(struct device *);
d119 1
a119 1
HIDE int eso_intr(void *);
d122 21
a142 25
HIDE int	eso_open(void *, int);
HIDE void	eso_close(void *);
HIDE int	eso_query_encoding(void *, struct audio_encoding *);
HIDE int	eso_set_params(void *, int, int, struct audio_params *,
		    struct audio_params *);
HIDE int	eso_round_blocksize(void *, int);
HIDE int	eso_halt_output(void *);
HIDE int	eso_halt_input(void *);
HIDE int	eso_getdev(void *, struct audio_device *);
HIDE int	eso_set_port(void *, mixer_ctrl_t *);
HIDE int	eso_get_port(void *, mixer_ctrl_t *);
HIDE int	eso_query_devinfo(void *, mixer_devinfo_t *);
HIDE void *	eso_allocm(void *, int, size_t, int, int);
HIDE void	eso_freem(void *, void *, int);
HIDE size_t	eso_round_buffersize(void *, int, size_t);
HIDE paddr_t	eso_mappage(void *, void *, off_t, int);
HIDE int	eso_get_props(void *);
HIDE int	eso_trigger_output(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
HIDE int	eso_trigger_input(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
HIDE void       eso_setup(struct eso_softc *, int);

HIDE void       eso_powerhook(int, void *);

d184 9
a192 9
HIDE uint8_t	eso_read_ctlreg(struct eso_softc *, uint8_t);
HIDE uint8_t	eso_read_mixreg(struct eso_softc *, uint8_t);
HIDE uint8_t	eso_read_rdr(struct eso_softc *);
HIDE int	eso_reset(struct eso_softc *);
HIDE void	eso_set_gain(struct eso_softc *, unsigned int);
HIDE int	eso_set_recsrc(struct eso_softc *, unsigned int);
HIDE void	eso_write_cmd(struct eso_softc *, uint8_t);
HIDE void	eso_write_ctlreg(struct eso_softc *, uint8_t, uint8_t);
HIDE void	eso_write_mixreg(struct eso_softc *, uint8_t, uint8_t);
d194 3
a196 3
HIDE int	eso_allocmem(struct eso_softc *, size_t, size_t, size_t,
		    int, struct eso_dma *);
HIDE void	eso_freemem(struct eso_softc *, struct eso_dma *);
d225 2
d270 8
a277 3
		       pci_conf_read(pa->pa_pc, pa->pa_tag,
				     PCI_COMMAND_STATUS_REG) |
		       PCI_COMMAND_MASTER_ENABLE);
d279 4
a282 1
	eso_setup(sc, 1);
d284 41
a324 1
	/* map and establish the interrupt. */
d332 1
a332 1
					sc->sc_dev.dv_xname);
a360 1

d363 1
a363 1
			       vcbase | ESO_PCI_DDMAC_DE);
d365 1
a365 1
		
d367 1
a367 1
		       sc->sc_dev.dv_xname, (unsigned long)vcbase);
d370 3
a372 3
			 sc->sc_dev.dv_xname, (unsigned long)vcbase));
		sc->sc_pa = *pa; 
		config_defer((struct device *)sc, eso_defer);
a381 2
	sc->sc_powerhook = powerhook_establish(&eso_powerhook, sc);

a390 61
eso_setup(sc, verbose)
	struct eso_softc *sc;
	int verbose;
{
	struct pci_attach_args *pa = &sc->sc_pa;	
	uint8_t a2mode;
	int idx; 

	/* Reset the device; bail out upon failure. */
	if (eso_reset(sc) != 0) {
		if (verbose) printf(", can't reset\n");
		return;
	}
	
	/* Select the DMA/IRQ policy: DDMA, ISA IRQ emulation disabled. */
	pci_conf_write(pa->pa_pc, pa->pa_tag, ESO_PCI_S1C,
		       pci_conf_read(pa->pa_pc, pa->pa_tag, ESO_PCI_S1C) &
		       ~(ESO_PCI_S1C_IRQP_MASK | ESO_PCI_S1C_DMAP_MASK));

	/* Enable the relevant DMA interrupts. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_IRQCTL,
			  ESO_IO_IRQCTL_A1IRQ | ESO_IO_IRQCTL_A2IRQ);
	
	/* Set up A1's sample rate generator for new-style parameters. */
	a2mode = eso_read_mixreg(sc, ESO_MIXREG_A2MODE);
	a2mode |= ESO_MIXREG_A2MODE_NEWA1 | ESO_MIXREG_A2MODE_ASYNC;
	eso_write_mixreg(sc, ESO_MIXREG_A2MODE, a2mode);

	/* Set mixer regs to something reasonable, needs work. */
	for (idx = 0; idx < ESO_NGAINDEVS; idx++) {
		int v;
		
		switch (idx) {
 		case ESO_MIC_PLAY_VOL:
		case ESO_LINE_PLAY_VOL:
		case ESO_CD_PLAY_VOL:
		case ESO_MONO_PLAY_VOL:
		case ESO_AUXB_PLAY_VOL:
		case ESO_DAC_REC_VOL:
		case ESO_LINE_REC_VOL:
		case ESO_SYNTH_REC_VOL:
		case ESO_CD_REC_VOL:
		case ESO_MONO_REC_VOL:
		case ESO_AUXB_REC_VOL:
		case ESO_SPATIALIZER:
			v = 0;
			break;
		case ESO_MASTER_VOL:
			v = ESO_GAIN_TO_6BIT(AUDIO_MAX_GAIN / 2);
			break;
		default:
			v = ESO_GAIN_TO_4BIT(AUDIO_MAX_GAIN / 2);
			break;
		}
		sc->sc_gain[idx][ESO_LEFT] = sc->sc_gain[idx][ESO_RIGHT] = v;
		eso_set_gain(sc, idx);
	}
	eso_set_recsrc(sc, ESO_MIXREG_ERS_MIC);
}

HIDE void
d1607 1
a1607 1
	void (*intr)(void *);
d1682 1
a1682 1
	void (*intr)(void *);
a1878 25
}


HIDE void
eso_powerhook(why, self)
	int why;
	void *self;
{
	struct eso_softc *sc = (struct eso_softc *)self;	

	if (why != PWR_RESUME) {
		eso_halt_output(sc);
		eso_halt_input(sc);
		
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAM, 0);
		bus_space_write_1(sc->sc_dmac_iot,
				  sc->sc_dmac_ioh, ESO_DMAC_CLEAR, 0);
		bus_space_write_1(sc->sc_sb_iot,
				  sc->sc_sb_ioh, ESO_SB_STATUSFLAGS, 3);
		
		/* shut down dma */
		pci_conf_write(sc->sc_pa.pa_pc,
			       sc->sc_pa.pa_tag, ESO_PCI_DDMAC, 0);
	} else
		eso_setup(sc, 0);
@


1.14.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 15
a269 2
	sc->sc_pa = *pa;

d326 1
d659 1
a659 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d665 1
a665 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d673 1
a673 1
			strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d680 1
a680 1
			strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d688 1
a688 1
			strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d695 1
a695 1
			strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d703 1
a703 1
			strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d706 1
a706 1
			strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d714 1
a714 1
			strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d717 1
a717 1
			strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d723 1
a723 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d729 1
a729 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d919 6
a924 2
	strlcpy(retp->name, "ESS Solo-1", sizeof retp->name);
	snprintf(retp->version, sizeof retp->version, "0x%02x",
d926 1
d929 2
a930 2
		strlcpy(retp->config, eso_rev2model[sc->sc_revision],
		    sizeof retp->config);
d932 1
a932 1
		strlcpy(retp->config, "unknown", sizeof retp->config);
d1211 1
a1211 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1214 1
a1214 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1219 1
a1219 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1222 1
a1222 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1227 1
a1227 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1230 1
a1230 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1235 1
a1235 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d1238 1
a1238 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1243 1
a1243 1
		strlcpy(dip->label.name, "mono_in", sizeof dip->label.name);
d1246 1
a1246 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1251 1
a1251 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1254 1
a1254 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1259 1
a1259 1
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
d1262 1
a1262 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1268 1
a1268 1
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
d1271 1
a1271 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1273 1
a1273 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d1279 1
a1279 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1286 1
a1286 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d1293 1
a1293 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1296 1
a1296 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1301 1
a1301 1
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
d1304 1
a1304 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1309 1
a1309 1
		strlcpy(dip->label.name, "mono_out", sizeof dip->label.name);
d1312 1
a1312 2
		strlcpy(dip->un.e.member[0].label.name, AudioNmute,
		    sizeof dip->un.e.member[0].label.name);
d1314 1
a1314 2
		strlcpy(dip->un.e.member[1].label.name, AudioNdac,
		    sizeof dip->un.e.member[1].label.name);
d1316 1
a1316 2
		strlcpy(dip->un.e.member[2].label.name, AudioNmixerout,
		    sizeof dip->un.e.member[2].label.name);
d1323 1
a1323 2
		strlcpy(dip->label.name, AudioNspatial,
		    sizeof dip->label.name);
d1326 1
a1326 2
		strlcpy(dip->un.v.units.name, "level",
		    sizeof dip->un.v.units.name);
d1332 1
a1332 1
		strlcpy(dip->label.name, "enable", sizeof dip->label.name);
d1335 1
a1335 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1337 1
a1337 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d1344 1
a1344 2
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof dip->label.name);
d1351 1
a1351 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1354 1
a1354 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1356 1
a1356 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d1362 1
a1362 2
		strlcpy(dip->label.name, AudioCmonitor,
		    sizeof dip->label.name);
d1369 1
a1369 1
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d1371 1
a1371 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1376 1
a1376 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1379 1
a1379 2
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
d1381 1
a1381 2
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
d1383 1
a1383 2
		strlcpy(dip->un.e.member[2].label.name, AudioNcd,
		    sizeof dip->un.e.member[2].label.name);
d1385 1
a1385 2
		strlcpy(dip->un.e.member[3].label.name, AudioNmixerout,
		    sizeof dip->un.e.member[3].label.name);
d1391 1
a1391 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1394 1
a1394 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1399 1
a1399 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1402 1
a1402 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1407 1
a1407 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1410 1
a1410 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1415 1
a1415 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d1418 1
a1418 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1423 1
a1423 1
		strlcpy(dip->label.name, "mono_in", sizeof dip->label.name);
d1426 1
a1426 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1431 1
a1431 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1434 1
a1434 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1439 1
a1439 1
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
d1442 1
a1442 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1447 1
a1447 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d1561 1
a1561 1
	struct eso_softc *sc = hdl;
d1678 2
a1679 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAA, DMAADDR(ed));
d1681 1
a1681 1
	    (uint8_t *)end - (uint8_t *)start);
d1780 1
a1780 1
	    DMAADDR(ed));
d1782 1
a1782 1
	    (uint8_t *)end - (uint8_t *)start - 1);
@


1.13
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.12 2001/08/25 10:13:29 art Exp $	*/
d137 1
a137 1
HIDE int	eso_mappage __P((void *, void *, int, int));
d1582 1
a1582 1
HIDE int
d1586 1
a1586 1
	int offs;
@


1.12
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.11 2001/06/12 15:40:30 niklas Exp $	*/
d349 1
a349 2
		printf(", couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
@


1.11
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.10 2000/07/19 09:04:38 csapuntz Exp $	*/
d337 1
a337 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.10
log
@

As in NetBSD, added direction to allocm/round_buffer_size APIs.
Accomplished by adding functions to audio_hw_if instead of redoing
current ones so as to minimize need to change drivers.

For Neomagic, tell the AC97 subsystem that we don't support reads.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.9 2000/04/03 21:13:48 deraadt Exp $	*/
d250 1
a250 1
	    &sc->sc_iot, &sc->sc_ioh, NULL, NULL)) {
d255 1
a255 1
	    &sc->sc_sb_iot, &sc->sc_sb_ioh, NULL, NULL)) {
d260 1
a260 1
	    &sc->sc_dmac_iot, &sc->sc_dmac_ioh, &vcbase, &sc->sc_vcsize)) {
d266 1
a266 1
	    &sc->sc_mpu_iot, &sc->sc_mpu_ioh, NULL, NULL)) {
d271 1
a271 1
	    &sc->sc_game_iot, &sc->sc_game_ioh, NULL, NULL)) {
@


1.9
log
@fix dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.8 2000/01/11 13:40:05 deraadt Exp $	*/
a133 3
#ifdef __OpenBSD__
void *		eso_allocm __P((void *, u_long, int, int));
#else
a134 1
#endif
a135 3
#ifdef __OpenBSD__
u_long		eso_round_buffersize __P((void *, u_long));
#else
a136 1
#endif
d164 3
d168 1
d170 3
d174 1
d178 5
a182 1
	eso_trigger_input
a1513 3
#ifdef __OpenBSD__
eso_allocm(hdl, size, type, flags)
#else
a1514 1
#endif
a1515 3
#ifdef __OpenBSD__
	u_long size;
#else
a1517 1
#endif
a1533 3
#ifdef __OpenBSD__
	boundary = 0x10000;
#else
d1538 1
a1538 1
#endif
a1569 4
#ifdef __OpenBSD__
u_long
eso_round_buffersize(hdl, bufsize)
#else
a1571 1
#endif
a1572 3
#ifdef __OpenBSD__
	u_long bufsize;
#else
a1574 1
#endif
@


1.8
log
@off by one
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.7 1999/12/05 18:35:33 espie Exp $	*/
d353 1
a353 1
	printf(" %s\n", intrstring);
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.10 2000/07/19 09:04:38 csapuntz Exp $	*/
d134 3
d138 1
d140 3
d144 1
a171 3
#ifdef __OpenBSD__
	0,
#else
a172 1
#endif
a173 3
#ifdef __OpenBSD__
	0, 
#else
a174 1
#endif
d178 1
a178 5
	eso_trigger_input,
#ifdef __OpenBSD__
	eso_allocm,
	eso_round_buffersize
#endif
d353 1
a353 1
	printf(", %s\n", intrstring);
d1510 3
d1514 1
d1516 3
d1521 1
d1538 3
d1545 1
a1545 1

d1577 4
d1583 1
d1585 3
d1590 1
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.8.2.1 2001/05/14 22:25:40 niklas Exp $	*/
d250 1
a250 1
	    &sc->sc_iot, &sc->sc_ioh, NULL, NULL, 0)) {
d255 1
a255 1
	    &sc->sc_sb_iot, &sc->sc_sb_ioh, NULL, NULL, 0)) {
d260 1
a260 1
	    &sc->sc_dmac_iot, &sc->sc_dmac_ioh, &vcbase, &sc->sc_vcsize, 0)) {
d266 1
a266 1
	    &sc->sc_mpu_iot, &sc->sc_mpu_ioh, NULL, NULL, 0)) {
d271 1
a271 1
	    &sc->sc_game_iot, &sc->sc_game_ioh, NULL, NULL, 0)) {
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.8.2.2 2001/07/04 10:42:02 niklas Exp $	*/
d337 2
a338 1
	if (pci_intr_map(pa, &ih)) {
d350 2
a351 1
		printf(", couldn't establish interrupt");
@


1.8.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d137 1
a137 1
HIDE paddr_t	eso_mappage __P((void *, void *, off_t, int));
d1582 1
a1582 1
HIDE paddr_t
d1586 1
a1586 1
	off_t offs;
@


1.8.2.5
log
@Merge in trunk
@
text
@d164 3
d168 1
d170 3
d174 1
d179 4
@


1.8.2.6
log
@Merge in -current from roughly a week ago
@
text
@d104 3
a106 3
HIDE int eso_match(struct device *, MATCH_ARG_2_T, void *);
HIDE void eso_attach(struct device *, struct device *, void *);
HIDE void eso_defer(struct device *);
d119 1
a119 1
HIDE int eso_intr(void *);
d122 21
a142 21
HIDE int	eso_open(void *, int);
HIDE void	eso_close(void *);
HIDE int	eso_query_encoding(void *, struct audio_encoding *);
HIDE int	eso_set_params(void *, int, int, struct audio_params *,
		    struct audio_params *);
HIDE int	eso_round_blocksize(void *, int);
HIDE int	eso_halt_output(void *);
HIDE int	eso_halt_input(void *);
HIDE int	eso_getdev(void *, struct audio_device *);
HIDE int	eso_set_port(void *, mixer_ctrl_t *);
HIDE int	eso_get_port(void *, mixer_ctrl_t *);
HIDE int	eso_query_devinfo(void *, mixer_devinfo_t *);
HIDE void *	eso_allocm(void *, int, size_t, int, int);
HIDE void	eso_freem(void *, void *, int);
HIDE size_t	eso_round_buffersize(void *, int, size_t);
HIDE paddr_t	eso_mappage(void *, void *, off_t, int);
HIDE int	eso_get_props(void *);
HIDE int	eso_trigger_output(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
HIDE int	eso_trigger_input(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
d184 9
a192 9
HIDE uint8_t	eso_read_ctlreg(struct eso_softc *, uint8_t);
HIDE uint8_t	eso_read_mixreg(struct eso_softc *, uint8_t);
HIDE uint8_t	eso_read_rdr(struct eso_softc *);
HIDE int	eso_reset(struct eso_softc *);
HIDE void	eso_set_gain(struct eso_softc *, unsigned int);
HIDE int	eso_set_recsrc(struct eso_softc *, unsigned int);
HIDE void	eso_write_cmd(struct eso_softc *, uint8_t);
HIDE void	eso_write_ctlreg(struct eso_softc *, uint8_t, uint8_t);
HIDE void	eso_write_mixreg(struct eso_softc *, uint8_t, uint8_t);
d194 3
a196 3
HIDE int	eso_allocmem(struct eso_softc *, size_t, size_t, size_t,
		    int, struct eso_dma *);
HIDE void	eso_freemem(struct eso_softc *, struct eso_dma *);
d1607 1
a1607 1
	void (*intr)(void *);
d1682 1
a1682 1
	void (*intr)(void *);
@


1.8.2.7
log
@Sync the SMP branch with 3.3
@
text
@a142 4
HIDE void       eso_setup(struct eso_softc *, int);

HIDE void       eso_powerhook(int, void *);

d225 2
d270 8
a277 3
		       pci_conf_read(pa->pa_pc, pa->pa_tag,
				     PCI_COMMAND_STATUS_REG) |
		       PCI_COMMAND_MASTER_ENABLE);
d279 4
a282 1
	eso_setup(sc, 1);
d284 41
a324 1
	/* map and establish the interrupt. */
d332 1
a332 1
					sc->sc_dev.dv_xname);
a360 1

d363 1
a363 1
			       vcbase | ESO_PCI_DDMAC_DE);
d365 1
a365 1
		
d367 1
a367 1
		       sc->sc_dev.dv_xname, (unsigned long)vcbase);
d370 3
a372 3
			 sc->sc_dev.dv_xname, (unsigned long)vcbase));
		sc->sc_pa = *pa; 
		config_defer((struct device *)sc, eso_defer);
a381 2
	sc->sc_powerhook = powerhook_establish(&eso_powerhook, sc);

a390 61
eso_setup(sc, verbose)
	struct eso_softc *sc;
	int verbose;
{
	struct pci_attach_args *pa = &sc->sc_pa;	
	uint8_t a2mode;
	int idx; 

	/* Reset the device; bail out upon failure. */
	if (eso_reset(sc) != 0) {
		if (verbose) printf(", can't reset\n");
		return;
	}
	
	/* Select the DMA/IRQ policy: DDMA, ISA IRQ emulation disabled. */
	pci_conf_write(pa->pa_pc, pa->pa_tag, ESO_PCI_S1C,
		       pci_conf_read(pa->pa_pc, pa->pa_tag, ESO_PCI_S1C) &
		       ~(ESO_PCI_S1C_IRQP_MASK | ESO_PCI_S1C_DMAP_MASK));

	/* Enable the relevant DMA interrupts. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_IRQCTL,
			  ESO_IO_IRQCTL_A1IRQ | ESO_IO_IRQCTL_A2IRQ);
	
	/* Set up A1's sample rate generator for new-style parameters. */
	a2mode = eso_read_mixreg(sc, ESO_MIXREG_A2MODE);
	a2mode |= ESO_MIXREG_A2MODE_NEWA1 | ESO_MIXREG_A2MODE_ASYNC;
	eso_write_mixreg(sc, ESO_MIXREG_A2MODE, a2mode);

	/* Set mixer regs to something reasonable, needs work. */
	for (idx = 0; idx < ESO_NGAINDEVS; idx++) {
		int v;
		
		switch (idx) {
 		case ESO_MIC_PLAY_VOL:
		case ESO_LINE_PLAY_VOL:
		case ESO_CD_PLAY_VOL:
		case ESO_MONO_PLAY_VOL:
		case ESO_AUXB_PLAY_VOL:
		case ESO_DAC_REC_VOL:
		case ESO_LINE_REC_VOL:
		case ESO_SYNTH_REC_VOL:
		case ESO_CD_REC_VOL:
		case ESO_MONO_REC_VOL:
		case ESO_AUXB_REC_VOL:
		case ESO_SPATIALIZER:
			v = 0;
			break;
		case ESO_MASTER_VOL:
			v = ESO_GAIN_TO_6BIT(AUDIO_MAX_GAIN / 2);
			break;
		default:
			v = ESO_GAIN_TO_4BIT(AUDIO_MAX_GAIN / 2);
			break;
		}
		sc->sc_gain[idx][ESO_LEFT] = sc->sc_gain[idx][ESO_RIGHT] = v;
		eso_set_gain(sc, idx);
	}
	eso_set_recsrc(sc, ESO_MIXREG_ERS_MIC);
}

HIDE void
a1878 25
}


HIDE void
eso_powerhook(why, self)
	int why;
	void *self;
{
	struct eso_softc *sc = (struct eso_softc *)self;	

	if (why != PWR_RESUME) {
		eso_halt_output(sc);
		eso_halt_input(sc);
		
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAM, 0);
		bus_space_write_1(sc->sc_dmac_iot,
				  sc->sc_dmac_ioh, ESO_DMAC_CLEAR, 0);
		bus_space_write_1(sc->sc_sb_iot,
				  sc->sc_sb_ioh, ESO_SB_STATUSFLAGS, 3);
		
		/* shut down dma */
		pci_conf_write(sc->sc_pa.pa_pc,
			       sc->sc_pa.pa_tag, ESO_PCI_DDMAC, 0);
	} else
		eso_setup(sc, 0);
@


1.8.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.8.2.7 2003/03/28 00:38:21 niklas Exp $	*/
d70 15
a269 2
	sc->sc_pa = *pa;

d326 1
d659 1
a659 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d665 1
a665 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d673 1
a673 1
			strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d680 1
a680 1
			strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d688 1
a688 1
			strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d695 1
a695 1
			strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d703 1
a703 1
			strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d706 1
a706 1
			strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d714 1
a714 1
			strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d717 1
a717 1
			strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d723 1
a723 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d729 1
a729 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d919 6
a924 2
	strlcpy(retp->name, "ESS Solo-1", sizeof retp->name);
	snprintf(retp->version, sizeof retp->version, "0x%02x",
d926 1
d929 2
a930 2
		strlcpy(retp->config, eso_rev2model[sc->sc_revision],
		    sizeof retp->config);
d932 1
a932 1
		strlcpy(retp->config, "unknown", sizeof retp->config);
d1211 1
a1211 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1214 1
a1214 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1219 1
a1219 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1222 1
a1222 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1227 1
a1227 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1230 1
a1230 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1235 1
a1235 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d1238 1
a1238 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1243 1
a1243 1
		strlcpy(dip->label.name, "mono_in", sizeof dip->label.name);
d1246 1
a1246 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1251 1
a1251 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1254 1
a1254 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1259 1
a1259 1
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
d1262 1
a1262 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1268 1
a1268 1
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
d1271 1
a1271 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1273 1
a1273 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d1279 1
a1279 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1286 1
a1286 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d1293 1
a1293 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1296 1
a1296 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1301 1
a1301 1
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
d1304 1
a1304 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1309 1
a1309 1
		strlcpy(dip->label.name, "mono_out", sizeof dip->label.name);
d1312 1
a1312 2
		strlcpy(dip->un.e.member[0].label.name, AudioNmute,
		    sizeof dip->un.e.member[0].label.name);
d1314 1
a1314 2
		strlcpy(dip->un.e.member[1].label.name, AudioNdac,
		    sizeof dip->un.e.member[1].label.name);
d1316 1
a1316 2
		strlcpy(dip->un.e.member[2].label.name, AudioNmixerout,
		    sizeof dip->un.e.member[2].label.name);
d1323 1
a1323 2
		strlcpy(dip->label.name, AudioNspatial,
		    sizeof dip->label.name);
d1326 1
a1326 2
		strlcpy(dip->un.v.units.name, "level",
		    sizeof dip->un.v.units.name);
d1332 1
a1332 1
		strlcpy(dip->label.name, "enable", sizeof dip->label.name);
d1335 1
a1335 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1337 1
a1337 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d1344 1
a1344 2
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof dip->label.name);
d1351 1
a1351 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1354 1
a1354 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1356 1
a1356 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d1362 1
a1362 2
		strlcpy(dip->label.name, AudioCmonitor,
		    sizeof dip->label.name);
d1369 1
a1369 1
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d1371 1
a1371 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1376 1
a1376 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1379 1
a1379 2
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
d1381 1
a1381 2
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
d1383 1
a1383 2
		strlcpy(dip->un.e.member[2].label.name, AudioNcd,
		    sizeof dip->un.e.member[2].label.name);
d1385 1
a1385 2
		strlcpy(dip->un.e.member[3].label.name, AudioNmixerout,
		    sizeof dip->un.e.member[3].label.name);
d1391 1
a1391 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1394 1
a1394 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1399 1
a1399 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1402 1
a1402 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1407 1
a1407 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1410 1
a1410 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1415 1
a1415 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d1418 1
a1418 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1423 1
a1423 1
		strlcpy(dip->label.name, "mono_in", sizeof dip->label.name);
d1426 1
a1426 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1431 1
a1431 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1434 1
a1434 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1439 1
a1439 1
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
d1442 1
a1442 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1447 1
a1447 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d1561 1
a1561 1
	struct eso_softc *sc = hdl;
d1678 2
a1679 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ESO_IO_A2DMAA, DMAADDR(ed));
d1681 1
a1681 1
	    (uint8_t *)end - (uint8_t *)start);
d1780 1
a1780 1
	    DMAADDR(ed));
d1782 1
a1782 1
	    (uint8_t *)end - (uint8_t *)start - 1);
@


1.7
log
@Pass device mode to query_encoding in the structure to fill, so
that devices that don't need it are not affected.

eso has those weird 16 bits mode that differ in endianess depending
on READ/WRITE. Use this to avoid setting AUDIO_FLAGS_EMULATED needlessly.

Reorder eso modes slightly so that emulated modes are always last.
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.6 1999/12/04 21:39:29 deraadt Exp $	*/
d238 1
a238 1
	if (sc->sc_revision <=
@


1.6
log
@rev E name
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.5 1999/08/08 19:16:25 deraadt Exp $	*/
d65 1
d657 2
a658 2
		strcpy(fp->name, AudioEmulaw);
		fp->encoding = AUDIO_ENCODING_ULAW;
d660 1
a660 1
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
d663 13
a675 4
		strcpy(fp->name, AudioEalaw);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
d678 13
a690 4
		strcpy(fp->name, AudioEslinear);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = 0;
a692 2
		strcpy(fp->name, AudioEslinear_le);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
d694 7
a703 2
		strcpy(fp->name, AudioEulinear_le);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
d705 7
d715 3
a717 3
		strcpy(fp->name, AudioEslinear_be);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
d721 3
a723 3
		strcpy(fp->name, AudioEulinear_be);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
@


1.5
log
@dmesg output corrections
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.4 1999/08/05 18:10:54 deraadt Exp $	*/
d182 2
a183 1
	"ES1946"
@


1.4
log
@simplify dmesg reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.3 1999/08/05 17:42:58 niklas Exp $	*/
d238 1
a238 1
		printf(": %s\n", eso_rev2model[sc->sc_revision]);
d240 1
a240 1
		printf(": (unknown rev. 0x%02x)\n", sc->sc_revision);
d245 1
a245 1
		printf("%s: can't map I/O space\n", sc->sc_dev.dv_xname);
d250 1
a250 1
		printf("%s: can't map SB I/O space\n", sc->sc_dev.dv_xname);
a254 2
		printf("%s: can't map VC I/O space\n", sc->sc_dev.dv_xname);
		/* Don't bail out yet: we can map it later, see below. */
d261 1
a261 1
		printf("%s: can't map MPU I/O space\n", sc->sc_dev.dv_xname);
d266 1
a266 1
		printf("%s: can't map Game I/O space\n", sc->sc_dev.dv_xname);
d281 1
a281 1
		printf("%s: can't reset\n", sc->sc_dev.dv_xname);
d333 1
a333 1
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d344 1
a344 1
		printf("%s: couldn't establish interrupt",
d351 1
a351 1
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstring);
@


1.3
log
@Use config_defer when a silicon bug hits
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.2 1999/08/05 05:32:41 deraadt Exp $	*/
a235 1
	printf(": ESS Solo-1 PCI AudioDrive ");
d238 1
a238 1
		printf("%s\n", eso_rev2model[sc->sc_revision]);
d240 1
a240 1
		printf("(unknown rev. 0x%02x)\n", sc->sc_revision);
@


1.2
log
@mv isa/mpu401var.h ic/mpuvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.1 1999/08/04 23:38:03 niklas Exp $	*/
a382 3
#ifdef __OpenBSD__
		panic("config_defer not implemented");
#else
a383 1
#endif
@


1.1
log
@ESS Solo-1 PCI audio card driver, from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: eso.c,v 1.3 1999/08/02 17:37:43 augustss Exp $	*/
a60 3
#ifdef __OpenBSD__
#include <dev/isa/mpu401var.h> /* XXX should not be ISA! */
#else
a61 1
#endif
@

