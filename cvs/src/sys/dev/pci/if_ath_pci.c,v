head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.4
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.8
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.6
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.26
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.25;
commitid	5gdEnqVoJuTuwdTu;

1.25
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.24;
commitid	FuSD2mFDJWATHIDx;

1.24
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.23;
commitid	yM2VFFhpDTeFQlve;

1.23
date	2013.11.21.16.16.08;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.27.19.44.44;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.02.06.08.38;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.10.20.29.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.30.16.47.09;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.29.00.18.25;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.14.02.28.14;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.06.21.41.31;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.04.13.14.44.41;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.03.02.29.33;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.29.21.34.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.22.10.17.04;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.08.18.45.28;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.08.17.43.26;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.08.17.23.21;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.17.12.58.39;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.03.19.59.18;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.23.09.39.29;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.03.19.15;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.02.02.45.37;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.26
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*      $OpenBSD: if_ath_pci.c,v 1.25 2015/11/24 13:45:06 mpi Exp $   */
/*	$NetBSD: if_ath_pci.c,v 1.7 2004/06/30 05:58:17 mycroft Exp $	*/

/*-
 * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
 *    redistribution must be conditioned upon including a substantially
 *    similar Disclaimer requirement for further binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGES.
 */

/*
 * PCI front-end for the Atheros Wireless LAN controller driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/lock.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/gpio.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_rssadapt.h>

#include <dev/gpio/gpiovar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/athvar.h>

/*
 * PCI glue.
 */

struct ath_pci_softc {
	struct ath_softc	sc_sc;

	pci_chipset_tag_t	sc_pc;
	pcitag_t		sc_pcitag;

	void			*sc_ih;		/* Interrupt handler. */
};

/* Base Address Register */
#define ATH_BAR0	0x10

int	 ath_pci_match(struct device *, void *, void *);
void	 ath_pci_attach(struct device *, struct device *, void *);
int	 ath_pci_detach(struct device *, int);

struct cfattach ath_pci_ca = {
	sizeof(struct ath_pci_softc),
	ath_pci_match,
	ath_pci_attach,
	ath_pci_detach,
	ath_activate
};

int
ath_pci_match(struct device *parent, void *match, void *aux)
{
	const char* devname;
	struct pci_attach_args *pa = aux;
	pci_vendor_id_t vendor;

	vendor = PCI_VENDOR(pa->pa_id);
	if (vendor == 0x128c)
		vendor = PCI_VENDOR_ATHEROS;
	devname = ath_hal_probe(vendor, PCI_PRODUCT(pa->pa_id));
	if (devname)
		return 1;

	return 0;
}

void
ath_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct ath_pci_softc *psc = (struct ath_pci_softc *)self;
	struct ath_softc *sc = &psc->sc_sc;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t pt = pa->pa_tag;
	pci_intr_handle_t ih;
	pcireg_t mem_type;
	const char *intrstr = NULL;

	psc->sc_pc = pc;
	psc->sc_pcitag = pt;

	/* 
	 * Setup memory-mapping of PCI registers.
	 */
	mem_type = pci_mapreg_type(pc, pa->pa_tag, ATH_BAR0);
	if (mem_type != PCI_MAPREG_TYPE_MEM &&
	    mem_type != PCI_MAPREG_MEM_TYPE_64BIT) {
		printf(": bad PCI register type %d\n", (int)mem_type);
		goto fail;
	}
	if (pci_mapreg_map(pa, ATH_BAR0, mem_type, 0, &sc->sc_st, &sc->sc_sh,
	    NULL, &sc->sc_ss, 0)) {
		printf(": can't map register space\n");
		goto fail;
	}

	/*
	 * PCI Express check.
	 */
	if (pci_get_capability(pc, pa->pa_tag, PCI_CAP_PCIEXPRESS,
	    NULL, NULL) != 0)
		sc->sc_pcie = 1;

	sc->sc_invalid = 1;

	/*
	 * Arrange interrupt line.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		goto unmap;
	}

	intrstr = pci_intr_string(pc, ih);
	psc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, ath_intr, sc,
	    sc->sc_dev.dv_xname);
	if (psc->sc_ih == NULL) {
		printf(": can't map interrupt\n");
		goto unmap;
	}

	printf(": %s\n", intrstr);

	sc->sc_dmat = pa->pa_dmat;

	if (ath_attach(PCI_PRODUCT(pa->pa_id), sc) == 0)
		return;

	pci_intr_disestablish(pc, psc->sc_ih);
unmap:
	bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_ss);
fail:
	return;
}

int
ath_pci_detach(struct device *self, int flags)
{
	struct ath_pci_softc *psc = (struct ath_pci_softc *)self;
	struct ath_softc *sc = &psc->sc_sc;

	ath_detach(&psc->sc_sc, flags);

	if (psc->sc_ih != NULL) {
		pci_intr_disestablish(psc->sc_pc, psc->sc_ih);
		psc->sc_ih = NULL;
	}

	if (sc->sc_ss != 0) {
		bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_ss);
		sc->sc_ss = 0;
	}

	return (0);
}
@


1.25
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.24 2014/12/22 02:28:51 tedu Exp $   */
a54 1
#include <net/if_dl.h>
@


1.24
log
@unifdef INET
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.23 2013/11/21 16:16:08 mpi Exp $   */
a56 1
#include <net/if_arp.h>
@


1.23
log
@Remove unneeded include.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.22 2010/08/27 19:44:44 deraadt Exp $   */
a57 1
#ifdef INET
a59 1
#endif
@


1.22
log
@Get rid of the clumsy pci_activate function and do this job inside ath.c
so that the powerhook wrapper can get at it
ok kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.21 2010/07/02 06:08:38 reyk Exp $   */
a56 1
#include <net/if_llc.h>
@


1.21
log
@Add an ath_pci_activate callback for ACPI suspend/resume with ath(4).
The card now should come back after resume and doesn't need a manual
ifconfig down/up.

ok deraadt@@ mlarkin@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.20 2009/08/10 20:29:52 deraadt Exp $   */
a93 1
int	 ath_pci_activate(struct device *, int);
d100 1
a100 1
	ath_pci_activate
a206 18
	return (0);
}

int
ath_pci_activate(struct device *self, int act)
{
	struct ath_pci_softc *psc = (struct ath_pci_softc *)self;
	struct ath_softc *sc = &psc->sc_sc;

	switch (act) {
	case DVACT_SUSPEND:
		/* It is safe to call ath's power hooks */
		ath_power(PWR_SUSPEND, sc);
		break;
	case DVACT_RESUME:
		ath_power(PWR_RESUME, sc);
		break;
	}
@


1.20
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.19 2009/03/29 21:53:52 sthen Exp $   */
d94 1
d100 2
a101 1
	ath_pci_detach
d208 18
@


1.19
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.18 2008/07/30 16:47:09 brad Exp $   */
a85 1
	void			*sc_sdhook;	/* Shutdown hook. */
a92 1
void	 ath_pci_shutdown(void *);
a177 6
	psc->sc_sdhook = shutdownhook_establish(ath_pci_shutdown, psc);
	if (psc->sc_sdhook == NULL) {
		printf(": can't establish shutdown hook\n");
		goto deintr;
	}

a180 2
	shutdownhook_disestablish(psc->sc_sdhook);
deintr:
a200 5
	if (psc->sc_sdhook != NULL) {
		shutdownhook_disestablish(psc->sc_sdhook);
		psc->sc_sdhook = NULL;
	}

a206 8
}

void
ath_pci_shutdown(void *self)
{
	struct ath_pci_softc *psc = (struct ath_pci_softc *)self;

	ath_shutdown(&psc->sc_sc);
@


1.18
log
@Check and clear the bus space mapping size instead of the bus space
handle in the detach function. Fixes compilation on sparc64.

ok reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.17 2008/07/29 00:18:25 reyk Exp $   */
d147 1
a147 1
		printf(": cannot map register space\n");
d164 1
a164 1
		printf(": couldn't map interrupt!\n");
d172 1
a172 1
		printf(": couldn't map interrupt!\n");
d182 1
a182 1
		printf(": couldn't establish shutdown hook!\n");
@


1.17
log
@- fix FIFO overruns on PCI-E chipsets by setting the DMA size
RX/TX configuration registers to 128 instead of 512 bytes.
- add a few more MAC/RF id strings for the dmesg.
- check for PCI-E instead of single chip variants in a few places.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.16 2008/06/14 02:28:14 jsing Exp $   */
d216 1
a216 1
	if (sc->sc_sh != 0) {
d218 1
a218 1
		sc->sc_sh = 0;
@


1.16
log
@Allow ath(4) to detach cleanly when attaching via PCI. Also
complete/cleanup the attachment cleanup code.

ok reyk@@ jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.15 2007/06/06 21:41:31 reyk Exp $   */
a144 2
	if (mem_type == PCI_MAPREG_MEM_TYPE_64BIT)
		sc->sc_64bit = 1;
d150 7
@


1.15
log
@the copyright holder changed the license from "dual bsd/gpl" to be
2-clause bsd-only. good.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.14 2007/04/13 14:44:41 reyk Exp $   */
d85 2
a86 1
	void			*sc_ih;		/* interrupt handler */
a128 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
a130 1
	void *hook;
d143 1
a143 1
		goto bad;
d147 2
a148 2
	if (pci_mapreg_map(pa, ATH_BAR0, mem_type, 0, &iot, &ioh,
	    NULL, NULL, 0)) {
d150 1
a150 1
		goto bad;
a151 2
	sc->sc_st = iot;
	sc->sc_sh = ioh;
d159 2
a160 2
		printf(": couldn't map interrupt\n");
		goto bad1;
d167 2
a168 2
		printf(": couldn't map interrupt\n");
		goto bad2;
d175 4
a178 4
	hook = shutdownhook_establish(ath_pci_shutdown, psc);
	if (hook == NULL) {
		printf(": couldn't make shutdown hook\n");
		goto bad3;
d184 6
a189 6
	shutdownhook_disestablish(hook);

bad3:	pci_intr_disestablish(pc, psc->sc_ih);
bad2:	/* XXX */
bad1:	/* XXX */
bad:
d197 1
d200 15
a214 1
	pci_intr_disestablish(psc->sc_pc, psc->sc_ih);
@


1.14
log
@The integrated Atheros NICs found in IBM/Lenovo ThinkPads use the same
device ID for old AR5212-based 32bit and new AR5424-based 64bit (PCI
Express Mini Card) interfaces.  Use an extra check to look if the card
is 64bit and attach it as a single chip device.  This prevents a panic
when attaching the device on some laptops like the T60.

Tested on a T42 (old AR5212 Mini PCI interface),
Tested on a T60 (new AR5424 Mini Card interface)

Nevertheless, the AR5424 does not work yet.

Thanks to Stefan Konrath
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.13 2006/08/03 02:29:33 brad Exp $   */
a20 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.13
log
@properly deal with Atheros chips that use a 64-bit memory address space.

From martin@@NetBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.12 2006/06/29 21:34:09 deraadt Exp $   */
d151 2
@


1.12
log
@do not check for master/io/mem enables; ok kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.11 2005/09/22 10:17:04 reyk Exp $   */
d135 1
d145 7
a151 1
	if (pci_mapreg_map(pa, ATH_BAR0, PCI_MAPREG_TYPE_MEM, 0, &iot, &ioh,
@


1.11
log
@remove the very basic ath(4) rate control implementation and use
rssadapt(9) instead. this may need some further work but now it's in
the right place and shared with other drivers (like ral(4)).

yes jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.10 2005/09/08 18:45:28 reyk Exp $   */
a128 1
	pcireg_t res;
a139 11

	res = pci_conf_read(pc, pt, PCI_COMMAND_STATUS_REG);
	if ((res & PCI_COMMAND_MEM_ENABLE) == 0) {
		printf(": couldn't enable memory mapping\n");
		goto bad;
	}

	if ((res & PCI_COMMAND_MASTER_ENABLE) == 0) {
		printf(": couldn't enable bus mastering\n");
		goto bad;
	}
@


1.10
log
@save the pcitag
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.9 2005/09/08 17:43:26 reyk Exp $   */
d69 1
@


1.9
log
@remove unused variables from ath_pci_softc
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.8 2005/09/08 17:23:21 reyk Exp $   */
d84 1
d86 2
d131 1
d139 1
d141 1
a141 1
	res = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
@


1.8
log
@tell the driver to allocate memory for the size of ath_pci_softc
instead of ath_softc. this fixes possible page faults with ath@@pci.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.7 2005/09/08 12:44:55 jsg Exp $   */
a85 3
	u_int8_t		sc_saved_intline;
	u_int8_t		sc_saved_cachelinesz;
	u_int8_t		sc_saved_lattimer;
@


1.7
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.6 2005/08/17 12:58:39 reyk Exp $   */
d85 1
a85 1
	void			*sc_ih;		/* intererupt handler */
d100 1
a100 1
	sizeof(struct ath_softc),
@


1.6
log
@cleanup and knf. remove the ath_product() workaround.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.5 2005/08/09 04:10:11 mickey Exp $   */
a67 1
#include <net80211/ieee80211_compat.h>
@


1.5
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.4 2005/01/03 19:59:18 jsg Exp $   */
d45 2
a46 2
#include <sys/systm.h> 
#include <sys/mbuf.h>   
d57 1
a57 1
 
d64 1
a64 1
#include <netinet/in.h> 
a84 4
#ifdef __FreeBSD__
	struct resource		*sc_sr;		/* memory resource */
	struct resource		*sc_irq;	/* irq resource */
#else
a85 1
#endif
d92 2
a93 1
#define	BS_BAR	0x10
d95 4
a98 5
int ath_pci_match(struct device *, void *, void *);
void ath_pci_attach(struct device *, struct device *, void *);
void ath_pci_shutdown(void *);
int ath_pci_detach(struct device *, int);
u_int16_t ath_product(pcireg_t);
d101 1
a101 1
	sizeof (struct ath_softc), 
d103 1
a103 1
	ath_pci_attach, 
a106 19
/*
 * translate some product code.  it is a workaround until HAL gets updated.
 */
u_int16_t
ath_product(pcireg_t pa_id)
{
	u_int16_t prodid;

	prodid = PCI_PRODUCT(pa_id);
	switch (prodid) {
	case 0x1014:	/* IBM 31P9702 minipci a/b/g card */
		prodid = PCI_PRODUCT_ATHEROS_AR5212;
		break;
	default:
		break;
	}
	return prodid;
}

a114 1
	/* XXX HACK until HAL is updated. */
d117 2
a118 2
	devname = ath_hal_probe(vendor, ath_product(pa->pa_id));
	if (devname) 
d154 1
a154 1
	if (pci_mapreg_map(pa, BS_BAR, PCI_MAPREG_TYPE_MEM, 0, &iot, &ioh, 
d172 1
a172 1
	intrstr = pci_intr_string(pc, ih); 
d174 1
a174 1
					sc->sc_dev.dv_xname);
d190 1
a190 1
	if (ath_attach(ath_product(pa->pa_id), sc) == 0)
@


1.4
log
@Make ath at cardbus not depend on ath at pci. ok reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.3 2004/11/23 09:39:29 reyk Exp $   */
d154 1
a154 1
	u_int32_t res;
a164 3
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG) |
	        PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_MEM_ENABLE);
a165 1

@


1.3
log
@support the gpio found on ath(4) devices.
ok grange@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.2 2004/11/02 03:19:15 brad Exp $   */
a109 3
};
struct cfdriver ath_cd = {
	0, "ath", DV_IFNET
@


1.2
log
@no CardBus here.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_ath_pci.c,v 1.1 2004/11/02 02:45:37 reyk Exp $   */
d54 1
d71 1
a71 1
#include <dev/ic/athvar.h>
d77 1
a77 1
#include <sys/device.h>
d239 1
a239 1
	ath_detach(&psc->sc_sc);
@


1.1
log
@imported Sam Leffler's ath driver for atheros multimode wireless nics
from NetBSD and FreeBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD$   */
d41 1
a41 1
 * PCI/Cardbus front-end for the Atheros Wireless LAN controller driver.
@

