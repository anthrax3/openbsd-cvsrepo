head	1.140;
access;
symbols
	OPENBSD_6_2:1.140.0.2
	OPENBSD_6_2_BASE:1.140
	OPENBSD_6_1:1.140.0.4
	OPENBSD_6_1_BASE:1.140
	OPENBSD_6_0:1.139.0.4
	OPENBSD_6_0_BASE:1.139
	OPENBSD_5_9:1.138.0.2
	OPENBSD_5_9_BASE:1.138
	OPENBSD_5_8:1.132.0.4
	OPENBSD_5_8_BASE:1.132
	OPENBSD_5_7:1.129.0.4
	OPENBSD_5_7_BASE:1.129
	OPENBSD_5_6:1.128.0.4
	OPENBSD_5_6_BASE:1.128
	OPENBSD_5_5:1.126.0.6
	OPENBSD_5_5_BASE:1.126
	OPENBSD_5_4:1.126.0.2
	OPENBSD_5_4_BASE:1.126
	OPENBSD_5_3:1.125.0.2
	OPENBSD_5_3_BASE:1.125
	OPENBSD_5_2:1.124.0.10
	OPENBSD_5_2_BASE:1.124
	OPENBSD_5_1_BASE:1.124
	OPENBSD_5_1:1.124.0.8
	OPENBSD_5_0:1.124.0.6
	OPENBSD_5_0_BASE:1.124
	OPENBSD_4_9:1.124.0.4
	OPENBSD_4_9_BASE:1.124
	OPENBSD_4_8:1.124.0.2
	OPENBSD_4_8_BASE:1.124
	OPENBSD_4_7:1.122.0.2
	OPENBSD_4_7_BASE:1.122
	OPENBSD_4_6:1.122.0.4
	OPENBSD_4_6_BASE:1.122
	OPENBSD_4_5:1.121.0.2
	OPENBSD_4_5_BASE:1.121
	OPENBSD_4_4:1.117.0.2
	OPENBSD_4_4_BASE:1.117
	OPENBSD_4_3:1.112.0.2
	OPENBSD_4_3_BASE:1.112
	OPENBSD_4_2:1.108.0.2
	OPENBSD_4_2_BASE:1.108;
locks; strict;
comment	@ * @;


1.140
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.139;
commitid	VyLWTsbepAOk7VQM;

1.139
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.138;
commitid	8YSL8ByWzGeIGBiJ;

1.138
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.137;
commitid	fbhqfhfdKxBcsetK;

1.137
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.136;
commitid	B0kwmVGiD5DVx4kv;

1.136
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.135;
commitid	5DvsamK0GblTp8ww;

1.135
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.134;
commitid	eYnPulzvLjDImPCa;

1.134
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.133;
commitid	hPF95ClMUQfeqQDX;

1.133
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.132;
commitid	NdgfPIGUgJxQPnT7;

1.132
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.131;
commitid	MVWrtktB46JRxFWT;

1.131
date	2015.04.30.07.51.07;	author mpi;	state Exp;
branches;
next	1.130;
commitid	H09AuNxNnUcYramX;

1.130
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.129;
commitid	p4LJxGKbi0BU2cG6;

1.129
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.128;
commitid	yM2VFFhpDTeFQlve;

1.128
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.127;
commitid	JtO5uXxVcnZfhUkR;

1.127
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.126;
commitid	OBNa5kfxQ2UXoiIw;

1.126
date	2013.04.02.13.43.40;	author brad;	state Exp;
branches;
next	1.125;

1.125
date	2013.01.14.23.19.39;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.123;

1.123
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.122;

1.122
date	2009.04.07.05.03.25;	author dlg;	state Exp;
branches;
next	1.121;

1.121
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.120;

1.120
date	2008.11.23.12.48.43;	author dlg;	state Exp;
branches;
next	1.119;

1.119
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.118;

1.118
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.117;

1.117
date	2008.05.13.00.52.12;	author brad;	state Exp;
branches;
next	1.116;

1.116
date	2008.05.12.10.02.42;	author kettenis;	state Exp;
branches;
next	1.115;

1.115
date	2008.05.12.06.59.19;	author canacar;	state Exp;
branches;
next	1.114;

1.114
date	2008.04.11.11.34.00;	author thib;	state Exp;
branches;
next	1.113;

1.113
date	2008.04.04.11.05.04;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2008.02.02.20.34.42;	author brad;	state Exp;
branches;
next	1.111;

1.111
date	2008.01.17.20.45.16;	author thib;	state Exp;
branches;
next	1.110;

1.110
date	2008.01.14.16.13.40;	author thib;	state Exp;
branches;
next	1.109;

1.109
date	2007.09.19.12.00.35;	author dlg;	state Exp;
branches;
next	1.108;

1.108
date	2007.07.22.03.54.15;	author dlg;	state Exp;
branches;
next	1.107;

1.107
date	2007.07.22.03.53.06;	author dlg;	state Exp;
branches;
next	1.106;

1.106
date	2007.05.28.06.34.06;	author dlg;	state Exp;
branches;
next	1.105;

1.105
date	2007.05.26.20.47.32;	author dlg;	state Exp;
branches;
next	1.104;

1.104
date	2007.05.26.20.28.22;	author claudio;	state Exp;
branches;
next	1.103;

1.103
date	2007.05.26.20.22.01;	author dlg;	state Exp;
branches;
next	1.102;

1.102
date	2007.05.17.10.12.53;	author dlg;	state Exp;
branches;
next	1.101;

1.101
date	2007.05.17.09.30.54;	author dlg;	state Exp;
branches;
next	1.100;

1.100
date	2007.05.16.09.27.44;	author dlg;	state Exp;
branches;
next	1.99;

1.99
date	2007.05.08.14.07.14;	author dlg;	state Exp;
branches;
next	1.98;

1.98
date	2007.05.08.13.40.42;	author dlg;	state Exp;
branches;
next	1.97;

1.97
date	2007.05.08.13.35.45;	author dlg;	state Exp;
branches;
next	1.96;

1.96
date	2007.05.06.08.58.02;	author dlg;	state Exp;
branches;
next	1.95;

1.95
date	2007.05.06.03.08.35;	author dlg;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.04.22.54.42;	author dlg;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.04.22.39.55;	author dlg;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.04.22.20.06;	author dlg;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.04.22.12.53;	author dlg;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.04.21.56.46;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2007.05.04.21.54.01;	author dlg;	state Exp;
branches;
next	1.88;

1.88
date	2007.05.04.21.51.11;	author dlg;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.30.00.02.12;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2007.04.29.21.44.32;	author dlg;	state Exp;
branches;
next	1.85;

1.85
date	2007.04.29.11.58.12;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.29.11.39.15;	author dlg;	state Exp;
branches;
next	1.83;

1.83
date	2007.04.29.11.31.29;	author dlg;	state Exp;
branches;
next	1.82;

1.82
date	2007.04.29.11.28.25;	author dlg;	state Exp;
branches;
next	1.81;

1.81
date	2007.04.29.08.44.13;	author dlg;	state Exp;
branches;
next	1.80;

1.80
date	2007.04.27.21.42.40;	author cloder;	state Exp;
branches;
next	1.79;

1.79
date	2007.04.27.06.45.34;	author cloder;	state Exp;
branches;
next	1.78;

1.78
date	2007.04.27.04.21.28;	author dlg;	state Exp;
branches;
next	1.77;

1.77
date	2007.04.25.13.27.31;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2007.04.25.12.52.22;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2007.04.25.12.50.29;	author dlg;	state Exp;
branches;
next	1.74;

1.74
date	2007.04.25.11.01.09;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.25.10.29.36;	author dlg;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.25.09.55.47;	author dlg;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.25.09.52.45;	author dlg;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.25.09.33.25;	author dlg;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.25.08.32.58;	author dlg;	state Exp;
branches;
next	1.68;

1.68
date	2007.04.25.08.10.27;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2007.04.25.05.47.14;	author dlg;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.25.05.46.03;	author dlg;	state Exp;
branches;
next	1.65;

1.65
date	2007.04.25.05.40.57;	author dlg;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.25.05.38.12;	author dlg;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.25.05.09.47;	author dlg;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.25.04.58.08;	author dlg;	state Exp;
branches;
next	1.61;

1.61
date	2007.04.25.04.23.05;	author dlg;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.25.04.18.05;	author dlg;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.25.04.16.44;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.24.08.08.49;	author dlg;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.23.11.32.44;	author dlg;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.23.11.27.32;	author dlg;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.23.11.24.07;	author dlg;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.23.09.59.01;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.23.09.54.42;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2007.04.22.13.14.11;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2007.04.22.09.25.14;	author dlg;	state Exp;
branches;
next	1.50;

1.50
date	2007.04.22.05.21.33;	author dlg;	state Exp;
branches;
next	1.49;

1.49
date	2007.04.22.04.59.07;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2007.04.22.04.38.31;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.22.04.24.40;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.22.04.21.25;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2007.04.21.14.48.24;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2007.04.21.14.46.35;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.21.13.58.38;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.21.13.10.51;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.21.12.47.42;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.21.12.40.42;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.21.12.36.06;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.21.12.32.32;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2007.04.21.12.25.42;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.21.12.22.57;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.20.13.59.34;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.20.13.46.40;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.20.07.10.56;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.20.05.14.32;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.20.02.24.28;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.20.01.38.32;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.20.00.41.32;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.19.14.07.08;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.18.13.35.59;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.18.11.21.41;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.18.11.19.35;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.18.07.17.44;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.18.07.13.11;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.18.07.00.11;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.18.06.57.14;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.18.06.54.32;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.18.02.12.30;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.17.14.07.15;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.17.10.34.54;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.17.02.15.13;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.17.01.28.14;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2007.04.16.22.17.54;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.16.15.14.38;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.16.14.40.18;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.16.14.35.07;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.16.14.33.35;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.16.14.32.19;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.16.14.17.32;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.16.14.01.26;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.16.13.30.45;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.16.12.13.16;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.16.11.34.35;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.16.11.07.23;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.16.10.53.51;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.16.10.35.29;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.140
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_tht.c,v 1.139 2016/04/13 10:34:32 mpi Exp $ */

/*
 * Copyright (c) 2007 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for the Tehuti TN30xx multi port 10Gb Ethernet chipsets,
 * see http://www.tehutinetworks.net/.
 *
 * This driver was made possible because Tehuti networks provided
 * hardware and documentation. Thanks!
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/queue.h>
#include <sys/rwlock.h>
#include <sys/time.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#ifdef THT_DEBUG
#define THT_D_FIFO		(1<<0)
#define THT_D_TX		(1<<1)
#define THT_D_RX		(1<<2)
#define THT_D_INTR		(1<<3)

int thtdebug = THT_D_TX | THT_D_RX | THT_D_INTR;

#define DPRINTF(l, f...)	do { if (thtdebug & (l)) printf(f); } while (0)
#else
#define DPRINTF(l, f...)
#endif

/* registers */

#define THT_PCI_BAR		0x10

#define _Q(_q)			((_q) * 4)

/* General Configuration */
#define THT_REG_END_SEL		0x5448 /* PCI Endian Select */
#define THT_REG_CLKPLL		0x5000
#define  THT_REG_CLKPLL_PLLLK		(1<<9) /* PLL is locked */
#define  THT_REG_CLKPLL_RSTEND		(1<<8) /* Reset ended */
#define  THT_REG_CLKPLL_TXF_DIS		(1<<3) /* TX Free disabled */
#define  THT_REG_CLKPLL_VNT_STOP	(1<<2) /* VENETO Stop */
#define  THT_REG_CLKPLL_PLLRST		(1<<1) /* PLL Reset */
#define  THT_REG_CLKPLL_SFTRST		(1<<0) /* Software Reset */
/* Descriptors and FIFO Registers */
#define THT_REG_TXT_CFG0(_q)	(0x4040 + _Q(_q)) /* CFG0 TX Task queues */
#define THT_REG_RXF_CFG0(_q)	(0x4050 + _Q(_q)) /* CFG0 RX Free queues */
#define THT_REG_RXD_CFG0(_q)	(0x4060 + _Q(_q)) /* CFG0 RX DSC queues */
#define THT_REG_TXF_CFG0(_q)	(0x4070 + _Q(_q)) /* CFG0 TX Free queues */
#define THT_REG_TXT_CFG1(_q)	(0x4000 + _Q(_q)) /* CFG1 TX Task queues */
#define THT_REG_RXF_CFG1(_q)	(0x4010 + _Q(_q)) /* CFG1 RX Free queues */
#define THT_REG_RXD_CFG1(_q)	(0x4020 + _Q(_q)) /* CFG1 RX DSC queues */
#define THT_REG_TXF_CFG1(_q)	(0x4030 + _Q(_q)) /* CFG1 TX Free queues */
#define THT_REG_TXT_RPTR(_q)	(0x40c0 + _Q(_q)) /* TX Task read ptr */
#define THT_REG_RXF_RPTR(_q)	(0x40d0 + _Q(_q)) /* RX Free read ptr */
#define THT_REG_RXD_RPTR(_q)	(0x40e0 + _Q(_q)) /* RX DSC read ptr */
#define THT_REG_TXF_RPTR(_q)	(0x40f0 + _Q(_q)) /* TX Free read ptr */
#define THT_REG_TXT_WPTR(_q)	(0x4080 + _Q(_q)) /* TX Task write ptr */
#define THT_REG_RXF_WPTR(_q)	(0x4090 + _Q(_q)) /* RX Free write ptr */
#define THT_REG_RXD_WPTR(_q)	(0x40a0 + _Q(_q)) /* RX DSC write ptr */
#define THT_REG_TXF_WPTR(_q)	(0x40b0 + _Q(_q)) /* TX Free write ptr */
#define THT_REG_HTB_ADDR	0x4100 /* HTB Addressing Mechanism enable */
#define THT_REG_HTB_ADDR_HI	0x4110 /* High HTB Address */
#define THT_REG_HTB_ST_TMR	0x3290 /* HTB Timer */
#define THT_REG_RDINTCM(_q)	(0x5120 + _Q(_q)) /* RX DSC Intr Coalescing */
#define  THT_REG_RDINTCM_PKT_TH(_c)	((_c)<<20) /* pkt count threshold */
#define  THT_REG_RDINTCM_RXF_TH(_c)	((_c)<<16) /* rxf intr req thresh */
#define  THT_REG_RDINTCM_COAL_RC	(1<<15) /* coalescing timer recharge */
#define  THT_REG_RDINTCM_COAL(_c)	(_c) /* coalescing timer */
#define THT_REG_TDINTCM(_q)	(0x5130 + _Q(_q)) /* TX DSC Intr Coalescing */
#define  THT_REG_TDINTCM_PKT_TH(_c)	((_c)<<20) /* pkt count threshold */
#define  THT_REG_TDINTCM_COAL_RC	(1<<15) /* coalescing timer recharge */
#define  THT_REG_TDINTCM_COAL(_c)	(_c) /* coalescing timer */
/* 10G Ethernet MAC */
#define THT_REG_10G_REV		0x6000 /* Revision */
#define THT_REG_10G_SCR		0x6004 /* Scratch */
#define THT_REG_10G_CTL		0x6008 /* Control/Status */
#define  THT_REG_10G_CTL_CMD_FRAME_EN	(1<<13) /* cmd frame enable */
#define  THT_REG_10G_CTL_SW_RESET	(1<<12) /* sw reset */
#define  THT_REG_10G_CTL_STATS_AUTO_CLR	(1<<11) /* auto clear statistics */
#define  THT_REG_10G_CTL_LOOPBACK	(1<<10) /* enable loopback */
#define  THT_REG_10G_CTL_TX_ADDR_INS	(1<<9) /* set mac on tx */
#define  THT_REG_10G_CTL_PAUSE_IGNORE	(1<<8) /* ignore pause */
#define  THT_REG_10G_CTL_PAUSE_FWD	(1<<7) /* forward pause */
#define  THT_REG_10G_CTL_CRC_FWD	(1<<6) /* crc forward */
#define  THT_REG_10G_CTL_PAD		(1<<5) /* frame padding */
#define  THT_REG_10G_CTL_PROMISC	(1<<4) /* promiscuous mode */
#define  THT_REG_10G_CTL_WAN_MODE	(1<<3) /* WAN mode */
#define  THT_REG_10G_CTL_RX_EN		(1<<1) /* RX enable */
#define  THT_REG_10G_CTL_TX_EN		(1<<0) /* TX enable */
#define THT_REG_10G_FRM_LEN	0x6014 /* Frame Length */
#define THT_REG_10G_PAUSE	0x6018 /* Pause Quanta */
#define THT_REG_10G_RX_SEC	0x601c /* RX Section */
#define THT_REG_10G_TX_SEC	0x6020 /* TX Section */
#define  THT_REG_10G_SEC_AVAIL(_t)	(_t) /* section available thresh*/
#define  THT_REG_10G_SEC_EMPTY(_t)	((_t)<<16) /* section empty avail */
#define THT_REG_10G_RFIFO_AEF	0x6024 /* RX FIFO Almost Empty/Full */
#define THT_REG_10G_TFIFO_AEF	0x6028 /* TX FIFO Almost Empty/Full */
#define  THT_REG_10G_FIFO_AE(_t)	(_t) /* almost empty */
#define  THT_REG_10G_FIFO_AF(_t)	((_t)<<16) /* almost full */
#define THT_REG_10G_SM_STAT	0x6030 /* MDIO Status */
#define THT_REG_10G_SM_CMD	0x6034 /* MDIO Command */
#define THT_REG_10G_SM_DAT	0x6038 /* MDIO Data */
#define THT_REG_10G_SM_ADD	0x603c /* MDIO Address */
#define THT_REG_10G_STAT	0x6040 /* Status */
/* Statistic Counters */
/* XXX todo */
/* Status Registers */
#define THT_REG_MAC_LNK_STAT	0x0200 /* Link Status */
#define  THT_REG_MAC_LNK_STAT_DIS	(1<<4) /* Mac Stats read disable */
#define  THT_REG_MAC_LNK_STAT_LINK	(1<<2) /* Link State */
#define  THT_REG_MAC_LNK_STAT_REM_FAULT	(1<<1) /* Remote Fault */
#define  THT_REG_MAC_LNK_STAT_LOC_FAULT	(1<<0) /* Local Fault */
/* Interrupt Registers */
#define THT_REG_ISR		0x5100 /* Interrupt Status */
#define THT_REG_ISR_LINKCHG(_p)		(1<<(27+(_p))) /* link changed */
#define THT_REG_ISR_GPIO		(1<<26) /* GPIO */
#define THT_REG_ISR_RFRSH		(1<<25) /* DDR Refresh */
#define THT_REG_ISR_SWI			(1<<23) /* software interrupt */
#define THT_REG_ISR_RXF(_q)		(1<<(19+(_q))) /* rx free fifo */
#define THT_REG_ISR_TXF(_q)		(1<<(15+(_q))) /* tx free fifo */
#define THT_REG_ISR_RXD(_q)		(1<<(11+(_q))) /* rx desc fifo */
#define THT_REG_ISR_TMR(_t)		(1<<(6+(_t))) /* timer */
#define THT_REG_ISR_VNT			(1<<5) /* optistrata */
#define THT_REG_ISR_RxFL		(1<<4) /* RX Full */
#define THT_REG_ISR_TR			(1<<2) /* table read */
#define THT_REG_ISR_PCIE_LNK_INT	(1<<1) /* pcie link fail */
#define THT_REG_ISR_GPLE_CLR		(1<<0) /* pcie timeout */
#define THT_FMT_ISR		"\020" "\035LINKCHG1" "\034LINKCHG0" \
				    "\033GPIO" "\032RFRSH" "\030SWI" \
				    "\027RXF3" "\026RXF2" "\025RXF1" \
				    "\024RXF0" "\023TXF3" "\022TXF2" \
				    "\021TXF1" "\020TXF0" "\017RXD3" \
				    "\016RXD2" "\015RXD1" "\014RXD0" \
				    "\012TMR3" "\011TMR2" "\010TMR1" \
				    "\007TMR0" "\006VNT" "\005RxFL" \
				    "\003TR" "\002PCI_LNK_INT" \
				    "\001GPLE_CLR"
#define THT_REG_ISR_GTI		0x5080 /* GTI Interrupt Status */
#define THT_REG_IMR		0x5110 /* Interrupt Mask */
#define THT_REG_IMR_LINKCHG(_p)		(1<<(27+(_p))) /* link changed */
#define THT_REG_IMR_GPIO		(1<<26) /* GPIO */
#define THT_REG_IMR_RFRSH		(1<<25) /* DDR Refresh */
#define THT_REG_IMR_SWI			(1<<23) /* software interrupt */
#define THT_REG_IMR_RXF(_q)		(1<<(19+(_q))) /* rx free fifo */
#define THT_REG_IMR_TXF(_q)		(1<<(15+(_q))) /* tx free fifo */
#define THT_REG_IMR_RXD(_q)		(1<<(11+(_q))) /* rx desc fifo */
#define THT_REG_IMR_TMR(_t)		(1<<(6+(_t))) /* timer */
#define THT_REG_IMR_VNT			(1<<5) /* optistrata */
#define THT_REG_IMR_RxFL		(1<<4) /* RX Full */
#define THT_REG_IMR_TR			(1<<2) /* table read */
#define THT_REG_IMR_PCIE_LNK_INT	(1<<1) /* pcie link fail */
#define THT_REG_IMR_GPLE_CLR		(1<<0) /* pcie timeout */
#define THT_REG_IMR_GTI		0x5090 /* GTI Interrupt Mask */
#define THT_REG_ISR_MSK		0x5140 /* ISR Masked */
/* Global Counters */
/* XXX todo */
/* DDR2 SDRAM Controller Registers */
/* XXX TBD */
/* EEPROM Registers */
/* XXX todo */
/* Init arbitration and status registers */
#define THT_REG_INIT_SEMAPHORE	0x5170 /* Init Semaphore */
#define THT_REG_INIT_STATUS	0x5180 /* Init Status */
/* PCI Credits Registers */
/* XXX todo */
/* TX Arbitration Registers */
#define THT_REG_TXTSK_PR(_q)	(0x41b0 + _Q(_q)) /* TX Queue Priority */
/* RX Part Registers */
#define THT_REG_RX_FLT		0x1240 /* RX Filter Configuration */
#define  THT_REG_RX_FLT_ATXER		(1<<15) /* accept with xfer err */
#define  THT_REG_RX_FLT_ATRM		(1<<14) /* accept with term err */
#define  THT_REG_RX_FLT_AFTSQ		(1<<13) /* accept with fault seq */
#define  THT_REG_RX_FLT_OSEN		(1<<12) /* enable pkts */
#define  THT_REG_RX_FLT_APHER		(1<<11) /* accept with phy err */
#define  THT_REG_RX_FLT_TXFC		(1<<10) /* TX flow control */
#define  THT_REG_RX_FLT_FDA		(1<<8) /* filter direct address */
#define  THT_REG_RX_FLT_AOF		(1<<7) /* accept overflow frame */
#define  THT_REG_RX_FLT_ACF		(1<<6) /* accept control frame */
#define  THT_REG_RX_FLT_ARUNT		(1<<5) /* accept runt */
#define  THT_REG_RX_FLT_ACRC		(1<<4) /* accept crc error */
#define  THT_REG_RX_FLT_AM		(1<<3) /* accept multicast */
#define  THT_REG_RX_FLT_AB		(1<<2) /* accept broadcast */
#define  THT_REG_RX_FLT_PRM_MASK	0x3 /* promiscuous mode */
#define  THT_REG_RX_FLT_PRM_NORMAL	0x0 /* normal mode */
#define  THT_REG_RX_FLT_PRM_ALL		0x1 /* pass all incoming frames */
#define THT_REG_RX_MAX_FRAME	0x12c0 /* Max Frame Size */
#define THT_REG_RX_UNC_MAC0	0x1250 /* MAC Address low word */
#define THT_REG_RX_UNC_MAC1	0x1260 /* MAC Address mid word */
#define THT_REG_RX_UNC_MAC2	0x1270 /* MAC Address high word */
#define THT_REG_RX_MAC_MCST0(_m) (0x1a80 + (_m)*8)
#define THT_REG_RX_MAC_MCST1(_m) (0x1a84 + (_m)*8)
#define  THT_REG_RX_MAC_MCST_CNT	15
#define THT_REG_RX_MCST_HASH	0x1a00 /* imperfect multicast filter hash */
#define  THT_REG_RX_MCST_HASH_SIZE	(256 / NBBY)
/* OptiStrata Debug Registers */
#define THT_REG_VPC		0x2300 /* Program Counter */
#define THT_REG_VLI		0x2310 /* Last Interrupt */
#define THT_REG_VIC		0x2320 /* Interrupts Count */
#define THT_REG_VTMR		0x2330 /* Timer */
#define THT_REG_VGLB		0x2340 /* Global */
/* SW Reset Registers */
#define THT_REG_RST_PRT		0x7000 /* Reset Port */
#define  THT_REG_RST_PRT_ACTIVE		0x1 /* port reset is active */
#define THT_REG_DIS_PRT		0x7010 /* Disable Port */
#define THT_REG_RST_QU_0	0x7020 /* Reset Queue 0 */
#define THT_REG_RST_QU_1	0x7028 /* Reset Queue 1 */
#define THT_REG_DIS_QU_0	0x7030 /* Disable Queue 0 */
#define THT_REG_DIS_QU_1	0x7038 /* Disable Queue 1 */

#define THT_PORT_SIZE		0x8000
#define THT_PORT_REGION(_p)	((_p) * THT_PORT_SIZE)
#define THT_NQUEUES		4

#define THT_FIFO_ALIGN		4096
#define THT_FIFO_SIZE_4k	0x0
#define THT_FIFO_SIZE_8k	0x1
#define THT_FIFO_SIZE_16k	0x2
#define THT_FIFO_SIZE_32k	0x3
#define THT_FIFO_SIZE(_r)	(4096 * (1<<(_r)))
#define THT_FIFO_GAP		8 /* keep 8 bytes between ptrs */
#define THT_FIFO_PTR_MASK	0x00007ff8 /* rptr/wptr mask */

#define THT_FIFO_DESC_LEN	208 /* a descriptor cant be bigger than this */

#define THT_IMR_DOWN(_p)	(THT_REG_IMR_LINKCHG(_p))
#define THT_IMR_UP(_p)		(THT_REG_IMR_LINKCHG(_p) | \
				    THT_REG_IMR_RXF(0) | THT_REG_IMR_TXF(0) | \
				    THT_REG_IMR_RXD(0))

/* hardware structures (we're using the 64 bit variants) */

/* physical buffer descriptor */
struct tht_pbd {
	u_int32_t		addr_lo;
	u_int32_t		addr_hi;
	u_int32_t		len;
} __packed;
#define THT_PBD_PKTLEN		(64 * 1024)

/* rx free fifo */
struct tht_rx_free {
	u_int16_t		bc; /* buffer count (0:4) */
	u_int16_t		type;

	u_int64_t		uid;

	/* followed by a pdb list */
} __packed;
#define THT_RXF_TYPE		1
#define THT_RXF_1ST_PDB_LEN	128
#define THT_RXF_SGL_LEN		((THT_FIFO_DESC_LEN - \
				    sizeof(struct tht_rx_free)) / \
				    sizeof(struct tht_pbd))
#define THT_RXF_PKT_NUM		128

/* rx descriptor */
struct tht_rx_desc {
	u_int32_t		flags;
#define THT_RXD_FLAGS_BC(_f)		((_f) & 0x1f) /* buffer count */
#define THT_RXD_FLAGS_RXFQ(_f)		(((_f)>>8) & 0x3) /* rxf queue id */
#define THT_RXD_FLAGS_TO		(1<<15)
#define THT_RXD_FLAGS_TYPE(_f)		(((_f)>>16) & 0xf) /* desc type */
#define THT_RXD_FLAGS_OVF		(1<<21) /* overflow error */
#define THT_RXD_FLAGS_RUNT		(1<<22) /* runt error */
#define THT_RXD_FLAGS_CRC		(1<<23) /* crc error */
#define THT_RXD_FLAGS_UDPCS		(1<<24) /* udp checksum error */
#define THT_RXD_FLAGS_TCPCS		(1<<25) /* tcp checksum error */
#define THT_RXD_FLAGS_IPCS		(1<<26) /* ip checksum error */
#define THT_RXD_FLAGS_PKT_ID		0x70000000
#define THT_RXD_FLAGS_PKT_ID_NONIP	0x00000000
#define THT_RXD_FLAGS_PKT_ID_TCP4	0x10000000
#define THT_RXD_FLAGS_PKT_ID_UDP4	0x20000000
#define THT_RXD_FLAGS_PKT_ID_IPV4	0x30000000
#define THT_RXD_FLAGS_PKT_ID_TCP6	0x50000000
#define THT_RXD_FLAGS_PKT_ID_UDP6	0x60000000
#define THT_RXD_FLAGS_PKT_ID_IPV6	0x70000000
#define THT_RXD_FLAGS_VTAG		(1<<31)
	u_int16_t		len;
	u_int16_t		vlan;
#define THT_RXD_VLAN_ID(_v)		((_v) & 0xfff)
#define THT_RXD_VLAN_CFI		(1<<12)
#define THT_RXD_VLAN_PRI(_v)		((_v) & 0x7) >> 13)

	u_int64_t		uid;
} __packed;
#define THT_RXD_TYPE		2

/* rx decriptor type 3: data chain instruction */
struct tht_rx_desc_dc {
	/* preceded by tht_rx_desc */

	u_int16_t		cd_offset;
	u_int16_t		flags;

	u_int8_t		data[4];
} __packed;
#define THT_RXD_TYPE_DC		3

/* rx descriptor type 4: rss (recv side scaling) information */
struct tht_rx_desc_rss {
	/* preceded by tht_rx_desc */

	u_int8_t		rss_hft;
	u_int8_t		rss_type;
	u_int8_t		rss_tcpu;
	u_int8_t		reserved;

	u_int32_t		rss_hash;
} __packed;
#define THT_RXD_TYPE_RSS	4

/* tx task fifo */
struct tht_tx_task {
	u_int32_t		flags;
#define THT_TXT_FLAGS_BC(_f)	(_f) /* buffer count */
#define THT_TXT_FLAGS_UDPCS	(1<<5) /* udp checksum */
#define THT_TXT_FLAGS_TCPCS	(1<<6) /* tcp checksum */
#define THT_TXT_FLAGS_IPCS	(1<<7) /* ip checksum */
#define THT_TXT_FLAGS_VTAG	(1<<8) /* insert vlan tag */
#define THT_TXT_FLAGS_LGSND	(1<<9) /* tcp large send enabled */
#define THT_TXT_FLAGS_FRAG	(1<<10) /* ip fragmentation enabled */
#define THT_TXT_FLAGS_CFI	(1<<12) /* canonical format indicator */
#define THT_TXT_FLAGS_PRIO(_f)	((_f)<<13) /* vlan priority */
#define THT_TXT_FLAGS_VLAN(_f)	((_f)<<20) /* vlan id */
	u_int16_t		mss_mtu;
	u_int16_t		len;

	u_int64_t		uid;

	/* followed by a pbd list */
} __packed;
#define THT_TXT_TYPE		(3<<16)
#define THT_TXT_SGL_LEN		((THT_FIFO_DESC_LEN - \
				    sizeof(struct tht_tx_task)) / \
				    sizeof(struct tht_pbd))
#define THT_TXT_PKT_NUM		128

/* tx free fifo */
struct tht_tx_free {
	u_int32_t		status;

	u_int64_t		uid;

	u_int32_t		pad;
} __packed;

/* pci controller autoconf glue */

struct thtc_softc {
	struct device		sc_dev;

	bus_dma_tag_t		sc_dmat;

	bus_space_tag_t		sc_memt;
	bus_space_handle_t	sc_memh;
	bus_size_t		sc_mems;
	void			*sc_ih;
};

int			thtc_match(struct device *, void *, void *);
void			thtc_attach(struct device *, struct device *, void *);
int			thtc_print(void *, const char *);

struct cfattach thtc_ca = {
	sizeof(struct thtc_softc), thtc_match, thtc_attach
};

struct cfdriver thtc_cd = {
	NULL, "thtc", DV_DULL
};

/* glue between the controller and the port */

struct tht_attach_args {
	int			taa_port;

	struct pci_attach_args	*taa_pa;
};

/* tht itself */

struct tht_dmamem {
	bus_dmamap_t		tdm_map;
	bus_dma_segment_t	tdm_seg;
	size_t			tdm_size;
	caddr_t			tdm_kva;
};
#define THT_DMA_MAP(_tdm)	((_tdm)->tdm_map)
#define THT_DMA_DVA(_tdm)	((_tdm)->tdm_map->dm_segs[0].ds_addr)
#define THT_DMA_KVA(_tdm)	((void *)(_tdm)->tdm_kva)

struct tht_fifo_desc {
	bus_size_t		tfd_cfg0;
	bus_size_t		tfd_cfg1;
	bus_size_t		tfd_rptr;
	bus_size_t		tfd_wptr;
	u_int32_t		tfd_size;
	int			tfd_write;
};
#define THT_FIFO_PRE_SYNC(_d)	((_d)->tfd_write ? \
				    BUS_DMASYNC_PREWRITE : \
				    BUS_DMASYNC_PREREAD)
#define THT_FIFO_POST_SYNC(_d)	((_d)->tfd_write ? \
				    BUS_DMASYNC_POSTWRITE : \
				    BUS_DMASYNC_POSTREAD)

struct tht_fifo {
	struct tht_fifo_desc	*tf_desc;
	struct tht_dmamem	*tf_mem;
	int			tf_len;
	int			tf_rptr;
	int			tf_wptr;
	int			tf_ready;
};

struct tht_pkt {
	u_int64_t		tp_id;

	bus_dmamap_t		tp_dmap;
	struct mbuf		*tp_m;

	TAILQ_ENTRY(tht_pkt)	tp_link;
};

struct tht_pkt_list {
	struct tht_pkt		*tpl_pkts;
	TAILQ_HEAD(, tht_pkt)	tpl_free;
	TAILQ_HEAD(, tht_pkt)	tpl_used;
};

struct tht_softc {
	struct device		sc_dev;
	struct thtc_softc	*sc_thtc;
	int			sc_port;

	bus_space_handle_t	sc_memh;

	struct arpcom		sc_ac;
	struct ifmedia		sc_media;
	struct timeval		sc_mediacheck;

	u_int16_t		sc_lladdr[3];

	struct tht_pkt_list	sc_tx_list;
	struct tht_pkt_list	sc_rx_list;

	struct tht_fifo		sc_txt;
	struct tht_fifo		sc_rxf;
	struct tht_fifo		sc_rxd;
	struct tht_fifo		sc_txf;

	u_int32_t		sc_imr;

	struct rwlock		sc_lock;
};

int			tht_match(struct device *, void *, void *);
void			tht_attach(struct device *, struct device *, void *);
void			tht_mountroot(struct device *);
int			tht_intr(void *);

struct cfattach tht_ca = {
	sizeof(struct tht_softc), tht_match, tht_attach
};

struct cfdriver tht_cd = {
	NULL, "tht", DV_IFNET
};

/* pkts */
int			tht_pkt_alloc(struct tht_softc *,
			    struct tht_pkt_list *, int, int);
void			tht_pkt_free(struct tht_softc *,
			    struct tht_pkt_list *);
void			tht_pkt_put(struct tht_pkt_list *, struct tht_pkt *);
struct tht_pkt 		*tht_pkt_get(struct tht_pkt_list *);
struct tht_pkt		*tht_pkt_used(struct tht_pkt_list *);

/* fifos */

struct tht_fifo_desc tht_txt_desc = {
	THT_REG_TXT_CFG0(0),
	THT_REG_TXT_CFG1(0),
	THT_REG_TXT_RPTR(0),
	THT_REG_TXT_WPTR(0),
	THT_FIFO_SIZE_16k,
	1
};

struct tht_fifo_desc tht_rxf_desc = {
	THT_REG_RXF_CFG0(0),
	THT_REG_RXF_CFG1(0),
	THT_REG_RXF_RPTR(0),
	THT_REG_RXF_WPTR(0),
	THT_FIFO_SIZE_16k,
	1
};

struct tht_fifo_desc tht_rxd_desc = {
	THT_REG_RXD_CFG0(0),
	THT_REG_RXD_CFG1(0),
	THT_REG_RXD_RPTR(0),
	THT_REG_RXD_WPTR(0),
	THT_FIFO_SIZE_16k,
	0
};

struct tht_fifo_desc tht_txf_desc = {
	THT_REG_TXF_CFG0(0),
	THT_REG_TXF_CFG1(0),
	THT_REG_TXF_RPTR(0),
	THT_REG_TXF_WPTR(0),
	THT_FIFO_SIZE_4k,
	0
};

int			tht_fifo_alloc(struct tht_softc *, struct tht_fifo *,
			    struct tht_fifo_desc *);
void			tht_fifo_free(struct tht_softc *, struct tht_fifo *);

size_t			tht_fifo_readable(struct tht_softc *,
			    struct tht_fifo *);
size_t			tht_fifo_writable(struct tht_softc *,
			    struct tht_fifo *);
void			tht_fifo_pre(struct tht_softc *,
			    struct tht_fifo *);
void			tht_fifo_read(struct tht_softc *, struct tht_fifo *,
			    void *, size_t);
void			tht_fifo_write(struct tht_softc *, struct tht_fifo *,
			    void *, size_t);
void			tht_fifo_write_dmap(struct tht_softc *,
			    struct tht_fifo *, bus_dmamap_t);
void			tht_fifo_write_pad(struct tht_softc *,
			    struct tht_fifo *, int);
void			tht_fifo_post(struct tht_softc *,
			    struct tht_fifo *);

/* port operations */
void			tht_lladdr_read(struct tht_softc *);
void			tht_lladdr_write(struct tht_softc *);
int			tht_sw_reset(struct tht_softc *);
int			tht_fw_load(struct tht_softc *);
void			tht_fw_tick(void *arg);
void			tht_link_state(struct tht_softc *);

/* interface operations */
int			tht_ioctl(struct ifnet *, u_long, caddr_t);
void			tht_watchdog(struct ifnet *);
void			tht_start(struct ifnet *);
int			tht_load_pkt(struct tht_softc *, struct tht_pkt *,
			    struct mbuf *);
void			tht_txf(struct tht_softc *sc);

void			tht_rxf_fill(struct tht_softc *, int);
void			tht_rxf_drain(struct tht_softc *);
void			tht_rxd(struct tht_softc *);

void			tht_up(struct tht_softc *);
void			tht_iff(struct tht_softc *);
void			tht_down(struct tht_softc *);

/* ifmedia operations */
int			tht_media_change(struct ifnet *);
void			tht_media_status(struct ifnet *, struct ifmediareq *);

/* wrapper around dma memory */
struct tht_dmamem	*tht_dmamem_alloc(struct tht_softc *, bus_size_t,
			    bus_size_t);
void			tht_dmamem_free(struct tht_softc *,
			    struct tht_dmamem *);

/* bus space operations */
u_int32_t		tht_read(struct tht_softc *, bus_size_t);
void			tht_write(struct tht_softc *, bus_size_t, u_int32_t);
void			tht_write_region(struct tht_softc *, bus_size_t,
			    void *, size_t);
int			tht_wait_eq(struct tht_softc *, bus_size_t, u_int32_t,
			    u_int32_t, int);
int			tht_wait_ne(struct tht_softc *, bus_size_t, u_int32_t,
			    u_int32_t, int);

#define tht_set(_s, _r, _b)		tht_write((_s), (_r), \
					    tht_read((_s), (_r)) | (_b))
#define tht_clr(_s, _r, _b)		tht_write((_s), (_r), \
					    tht_read((_s), (_r)) & ~(_b))
#define tht_wait_set(_s, _r, _b, _t)	tht_wait_eq((_s), (_r), \
					    (_b), (_b), (_t))


/* misc */
#define DEVNAME(_sc)	((_sc)->sc_dev.dv_xname)
#define LWORDS(_b)	(((_b) + 7) >> 3)


struct thtc_device {
	pci_vendor_id_t		td_vendor;
	pci_vendor_id_t		td_product;
	u_int			td_nports;
};

const struct thtc_device *thtc_lookup(struct pci_attach_args *);

static const struct thtc_device thtc_devices[] = {
	{ PCI_VENDOR_TEHUTI,	PCI_PRODUCT_TEHUTI_TN3009, 1 },
	{ PCI_VENDOR_TEHUTI,	PCI_PRODUCT_TEHUTI_TN3010, 1 },
	{ PCI_VENDOR_TEHUTI,	PCI_PRODUCT_TEHUTI_TN3014, 2 }
};

const struct thtc_device *
thtc_lookup(struct pci_attach_args *pa)
{
	int				i;
	const struct thtc_device	*td;

	for (i = 0; i < nitems(thtc_devices); i++) {
		td = &thtc_devices[i];
		if (td->td_vendor == PCI_VENDOR(pa->pa_id) &&
		    td->td_product == PCI_PRODUCT(pa->pa_id))
			return (td);
	}

	return (NULL);
}

int
thtc_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args		*pa = aux;

	if (thtc_lookup(pa) != NULL)
		return (1);

	return (0);
}

void
thtc_attach(struct device *parent, struct device *self, void *aux)
{
	struct thtc_softc		*sc = (struct thtc_softc *)self;
	struct pci_attach_args		*pa = aux;
	pcireg_t			memtype;
	const struct thtc_device	*td;
	struct tht_attach_args		taa;
	pci_intr_handle_t		ih;
	int				i;

	bzero(&taa, sizeof(taa));
	td = thtc_lookup(pa);

	sc->sc_dmat = pa->pa_dmat;

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, THT_PCI_BAR);
	if (pci_mapreg_map(pa, THT_PCI_BAR, memtype, 0, &sc->sc_memt,
	    &sc->sc_memh, NULL, &sc->sc_mems, 0) != 0) {
		printf(": unable to map host registers\n");
		return;
	}

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": unable to map interrupt\n");
		goto unmap;
	}

	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih,
	    IPL_NET, tht_intr, sc, DEVNAME(sc));
	if (sc->sc_ih == NULL) {
		printf(": unable to establish interrupt\n");
		return;
	}
	printf(": %s\n", pci_intr_string(pa->pa_pc, ih));

	taa.taa_pa = pa;
	for (i = 0; i < td->td_nports; i++) {
		taa.taa_port = i;

		config_found(self, &taa, thtc_print);
	}

	return;

unmap:
	bus_space_unmap(sc->sc_memt, sc->sc_memh, sc->sc_mems);
	sc->sc_mems = 0;
}

int
thtc_print(void *aux, const char *pnp)
{
	struct tht_attach_args		*taa = aux;

	if (pnp != NULL)
		printf("\"%s\" at %s", tht_cd.cd_name, pnp);

	printf(" port %d", taa->taa_port);

	return (UNCONF);
}

int
tht_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
tht_attach(struct device *parent, struct device *self, void *aux)
{
	struct thtc_softc		*csc = (struct thtc_softc *)parent;
	struct tht_softc		*sc = (struct tht_softc *)self;
	struct tht_attach_args		*taa = aux;
	struct ifnet			*ifp;

	sc->sc_thtc = csc;
	sc->sc_port = taa->taa_port;
	sc->sc_imr = THT_IMR_DOWN(sc->sc_port);
	rw_init(&sc->sc_lock, "thtioc");

	if (bus_space_subregion(csc->sc_memt, csc->sc_memh,
	    THT_PORT_REGION(sc->sc_port), THT_PORT_SIZE,
	    &sc->sc_memh) != 0) {
		printf(": unable to map port registers\n");
		return;
	}

	if (tht_sw_reset(sc) != 0) {
		printf(": unable to reset port\n");
		/* bus_space(9) says we dont have to free subregions */
		return;
	}

	tht_lladdr_read(sc);
	bcopy(sc->sc_lladdr, sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN);

	ifp = &sc->sc_ac.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_capabilities = IFCAP_VLAN_MTU;
	ifp->if_ioctl = tht_ioctl;
	ifp->if_start = tht_start;
	ifp->if_watchdog = tht_watchdog;
	ifp->if_hardmtu = MCLBYTES - ETHER_HDR_LEN - ETHER_CRC_LEN; /* XXX */
	strlcpy(ifp->if_xname, DEVNAME(sc), IFNAMSIZ);
	IFQ_SET_MAXLEN(&ifp->if_snd, 400);

	ifmedia_init(&sc->sc_media, 0, tht_media_change, tht_media_status);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_AUTO, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_AUTO);

	if_attach(ifp);
	ether_ifattach(ifp);

	printf(": address %s\n", ether_sprintf(sc->sc_ac.ac_enaddr));

	config_mountroot(self, tht_mountroot);
}

void
tht_mountroot(struct device *self)
{
	struct tht_softc		*sc = (struct tht_softc *)self;

	if (tht_fifo_alloc(sc, &sc->sc_txt, &tht_txt_desc) != 0)
		return;

	if (tht_fw_load(sc) != 0)
		printf("%s: firmware load failed\n", DEVNAME(sc));

	tht_sw_reset(sc);

	tht_fifo_free(sc, &sc->sc_txt);

	tht_link_state(sc);
	tht_write(sc, THT_REG_IMR, sc->sc_imr);
}

int
tht_intr(void *arg)
{
	struct thtc_softc		*thtc = arg;
	struct tht_softc		*sc = arg;
        struct device			*d;
	struct ifnet			*ifp;
	u_int32_t			isr;
	int				rv = 0;

	for (d = TAILQ_NEXT(&thtc->sc_dev, dv_list); d != NULL;
	    d = TAILQ_NEXT(d, dv_list)) {
		sc = (struct tht_softc *)d;

		isr = tht_read(sc, THT_REG_ISR);
		if (isr == 0x0) {
			tht_write(sc, THT_REG_IMR, sc->sc_imr);
			continue;
		}
		rv = 1;

		DPRINTF(THT_D_INTR, "%s: isr: 0x%b\n", DEVNAME(sc), isr, THT_FMT_ISR);

		if (ISSET(isr, THT_REG_ISR_LINKCHG(0) | THT_REG_ISR_LINKCHG(1)))
			tht_link_state(sc);

		ifp = &sc->sc_ac.ac_if;
		if (ifp->if_flags & IFF_RUNNING) {
			if (ISSET(isr, THT_REG_ISR_RXD(0)))
				tht_rxd(sc);

			if (ISSET(isr, THT_REG_ISR_RXF(0)))
				tht_rxf_fill(sc, 0);

			if (ISSET(isr, THT_REG_ISR_TXF(0)))
				tht_txf(sc);

			tht_start(ifp);
		}
		tht_write(sc, THT_REG_IMR, sc->sc_imr);
	}
	return (rv);
}

int
tht_ioctl(struct ifnet *ifp, u_long cmd, caddr_t addr)
{
	struct tht_softc		*sc = ifp->if_softc;
	struct ifreq			*ifr = (struct ifreq *)addr;
	int				s, error = 0;

	rw_enter_write(&sc->sc_lock);
	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				tht_up(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				tht_down(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	default:
		error =  ether_ioctl(ifp, &sc->sc_ac, cmd, addr);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			tht_iff(sc);
		error = 0;
	}

	splx(s);
	rw_exit_write(&sc->sc_lock);

	return (error);
}

void
tht_up(struct tht_softc *sc)
{
	struct ifnet			*ifp = &sc->sc_ac.ac_if;

	if (ISSET(ifp->if_flags, IFF_RUNNING)) {
		return;
	}

	if (tht_pkt_alloc(sc, &sc->sc_tx_list, THT_TXT_PKT_NUM,
	    THT_TXT_SGL_LEN) != 0)
		return;
	if (tht_pkt_alloc(sc, &sc->sc_rx_list, THT_RXF_PKT_NUM,
	    THT_RXF_SGL_LEN) != 0)
		goto free_tx_list;

	if (tht_fifo_alloc(sc, &sc->sc_txt, &tht_txt_desc) != 0)
		goto free_rx_list;
	if (tht_fifo_alloc(sc, &sc->sc_rxf, &tht_rxf_desc) != 0)
		goto free_txt;
	if (tht_fifo_alloc(sc, &sc->sc_rxd, &tht_rxd_desc) != 0)
		goto free_rxf;
	if (tht_fifo_alloc(sc, &sc->sc_txf, &tht_txf_desc) != 0)
		goto free_rxd;

	tht_write(sc, THT_REG_10G_FRM_LEN, MCLBYTES - ETHER_ALIGN);
	tht_write(sc, THT_REG_10G_PAUSE, 0x96);
	tht_write(sc, THT_REG_10G_RX_SEC, THT_REG_10G_SEC_AVAIL(0x10) |
	    THT_REG_10G_SEC_EMPTY(0x80));
	tht_write(sc, THT_REG_10G_TX_SEC, THT_REG_10G_SEC_AVAIL(0x10) |
	    THT_REG_10G_SEC_EMPTY(0xe0));
	tht_write(sc, THT_REG_10G_RFIFO_AEF, THT_REG_10G_FIFO_AE(0x0) |
	    THT_REG_10G_FIFO_AF(0x0));
	tht_write(sc, THT_REG_10G_TFIFO_AEF, THT_REG_10G_FIFO_AE(0x0) |
	    THT_REG_10G_FIFO_AF(0x0));
	tht_write(sc, THT_REG_10G_CTL, THT_REG_10G_CTL_TX_EN |
	    THT_REG_10G_CTL_RX_EN | THT_REG_10G_CTL_PAD |
	    THT_REG_10G_CTL_PROMISC);

	tht_write(sc, THT_REG_VGLB, 0);

	tht_write(sc, THT_REG_RX_MAX_FRAME, MCLBYTES - ETHER_ALIGN);

	tht_write(sc, THT_REG_RDINTCM(0), THT_REG_RDINTCM_PKT_TH(12) |
	    THT_REG_RDINTCM_RXF_TH(4) | THT_REG_RDINTCM_COAL_RC |
	    THT_REG_RDINTCM_COAL(0x20));
	tht_write(sc, THT_REG_TDINTCM(0), THT_REG_TDINTCM_PKT_TH(12) |
	    THT_REG_TDINTCM_COAL_RC | THT_REG_TDINTCM_COAL(0x20));

	bcopy(sc->sc_ac.ac_enaddr, sc->sc_lladdr, ETHER_ADDR_LEN);
	tht_lladdr_write(sc);

	/* populate rxf fifo */
	tht_rxf_fill(sc, 1);

	/* program promiscuous mode and multicast filters */
	tht_iff(sc);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	
	/* enable interrupts */
	sc->sc_imr = THT_IMR_UP(sc->sc_port);
	tht_write(sc, THT_REG_IMR, sc->sc_imr);

	return;

free_rxd:
	tht_fifo_free(sc, &sc->sc_rxd);
free_rxf:
	tht_fifo_free(sc, &sc->sc_rxf);
free_txt:
	tht_fifo_free(sc, &sc->sc_txt);

	tht_sw_reset(sc);

free_rx_list:
	tht_pkt_free(sc, &sc->sc_rx_list);
free_tx_list:
	tht_pkt_free(sc, &sc->sc_tx_list);
}

void
tht_iff(struct tht_softc *sc)
{
	struct ifnet			*ifp = &sc->sc_ac.ac_if;
	struct ether_multi		*enm;
	struct ether_multistep		step;
	u_int32_t			rxf;
	u_int8_t			imf[THT_REG_RX_MCST_HASH_SIZE];
	u_int8_t			hash;
	int				i;

	ifp->if_flags &= ~IFF_ALLMULTI;

	rxf = THT_REG_RX_FLT_OSEN | THT_REG_RX_FLT_AM | THT_REG_RX_FLT_AB;
	for (i = 0; i < THT_REG_RX_MAC_MCST_CNT; i++) {
		tht_write(sc, THT_REG_RX_MAC_MCST0(i), 0);
		tht_write(sc, THT_REG_RX_MAC_MCST1(i), 0);
	}
	memset(imf, 0x00, sizeof(imf));

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxf |= THT_REG_RX_FLT_PRM_ALL;
	} else if (sc->sc_ac.ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		memset(imf, 0xff, sizeof(imf));
	} else {
		ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);

#if 0
		/* fill the perfect multicast filters */
		for (i = 0; i < THT_REG_RX_MAC_MCST_CNT; i++) {
			if (enm == NULL)
				break;

			tht_write(sc, THT_REG_RX_MAC_MCST0(i),
			    (enm->enm_addrlo[0] << 0) |
			    (enm->enm_addrlo[1] << 8) |
			    (enm->enm_addrlo[2] << 16) |
			    (enm->enm_addrlo[3] << 24));
			tht_write(sc, THT_REG_RX_MAC_MCST1(i),
			    (enm->enm_addrlo[4] << 0) |
			    (enm->enm_addrlo[5] << 8));

			ETHER_NEXT_MULTI(step, enm);
		}
#endif

		/* fill the imperfect multicast filter with whats left */
		while (enm != NULL) {
			hash = 0x00;
			for (i = 0; i < ETHER_ADDR_LEN; i++)
				hash ^= enm->enm_addrlo[i];
			setbit(imf, hash);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	tht_write_region(sc, THT_REG_RX_MCST_HASH, imf, sizeof(imf));
	tht_write(sc, THT_REG_RX_FLT, rxf);
}

void
tht_down(struct tht_softc *sc)
{
	struct ifnet			*ifp = &sc->sc_ac.ac_if;

	if (!ISSET(ifp->if_flags, IFF_RUNNING)) {
		return;
	}

	ifp->if_flags &= ~(IFF_RUNNING | IFF_ALLMULTI);
	ifq_clr_oactive(&ifp->if_snd);

	while (tht_fifo_writable(sc, &sc->sc_txt) < sc->sc_txt.tf_len &&
	    tht_fifo_readable(sc, &sc->sc_txf) > 0)
		tsleep(sc, 0, "thtdown", hz);

	sc->sc_imr = THT_IMR_DOWN(sc->sc_port);
	tht_write(sc, THT_REG_IMR, sc->sc_imr);

	tht_sw_reset(sc);

	tht_fifo_free(sc, &sc->sc_txf);
	tht_fifo_free(sc, &sc->sc_rxd);
	tht_fifo_free(sc, &sc->sc_rxf);
	tht_fifo_free(sc, &sc->sc_txt);

	/* free mbufs that were on the rxf fifo */
	tht_rxf_drain(sc);

	tht_pkt_free(sc, &sc->sc_rx_list);
	tht_pkt_free(sc, &sc->sc_tx_list);
}

void
tht_start(struct ifnet *ifp)
{
	struct tht_softc		*sc = ifp->if_softc;
	struct tht_pkt			*pkt;
	struct tht_tx_task		txt;
	u_int32_t			flags;
	struct mbuf			*m;
	int				bc;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;
	if (ifq_is_oactive(&ifp->if_snd))
		return;
	if (IFQ_IS_EMPTY(&ifp->if_snd))
		return;

	if (tht_fifo_writable(sc, &sc->sc_txt) <= THT_FIFO_DESC_LEN)
		return;

	bzero(&txt, sizeof(txt));

	tht_fifo_pre(sc, &sc->sc_txt);

	do {
		m = ifq_deq_begin(&ifp->if_snd);
		if (m == NULL)
			break;

		pkt = tht_pkt_get(&sc->sc_tx_list);
		if (pkt == NULL) {
			ifq_deq_rollback(&ifp->if_snd, m);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		ifq_deq_commit(&ifp->if_snd, m);
		if (tht_load_pkt(sc, pkt, m) != 0) {
			m_freem(m);
			tht_pkt_put(&sc->sc_tx_list, pkt);
			ifp->if_oerrors++;
			break;
		}
		/* thou shalt not use m after this point, only pkt->tp_m */

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, pkt->tp_m, BPF_DIRECTION_OUT);
#endif

		bc = sizeof(txt) +
		    sizeof(struct tht_pbd) * pkt->tp_dmap->dm_nsegs;

		flags = THT_TXT_TYPE | LWORDS(bc);
		txt.flags = htole32(flags);
		txt.len = htole16(pkt->tp_m->m_pkthdr.len);
		txt.uid = pkt->tp_id;

		DPRINTF(THT_D_TX, "%s: txt uid 0x%llx flags 0x%08x len %d\n",
		    DEVNAME(sc), pkt->tp_id, flags, pkt->tp_m->m_pkthdr.len);

		tht_fifo_write(sc, &sc->sc_txt, &txt, sizeof(txt));
		tht_fifo_write_dmap(sc, &sc->sc_txt, pkt->tp_dmap);
		tht_fifo_write_pad(sc, &sc->sc_txt, bc);

		bus_dmamap_sync(sc->sc_thtc->sc_dmat, pkt->tp_dmap, 0,
		    pkt->tp_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	} while (sc->sc_txt.tf_ready > THT_FIFO_DESC_LEN);

	tht_fifo_post(sc, &sc->sc_txt);
}

int
tht_load_pkt(struct tht_softc *sc, struct tht_pkt *pkt, struct mbuf *m)
{
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	bus_dmamap_t			dmap = pkt->tp_dmap;
	struct mbuf			*m0 = NULL;

	switch(bus_dmamap_load_mbuf(dmat, dmap, m, BUS_DMA_NOWAIT)) {
	case 0:
		pkt->tp_m = m;
		break;

	case EFBIG: /* mbuf chain is too fragmented */
		MGETHDR(m0, M_DONTWAIT, MT_DATA);
		if (m0 == NULL)
			return (ENOBUFS);
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m0, M_DONTWAIT);
			if (!(m0->m_flags & M_EXT)) {
				m_freem(m0);
				return (ENOBUFS);
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));
		m0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;
		if (bus_dmamap_load_mbuf(dmat, dmap, m0, BUS_DMA_NOWAIT)) {
                        m_freem(m0);
			return (ENOBUFS);
                }

		m_freem(m);
		pkt->tp_m = m0;
		break;

	default:
		return (ENOBUFS);
	}

	return (0);
}

void
tht_txf(struct tht_softc *sc)
{
	struct ifnet			*ifp = &sc->sc_ac.ac_if;
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	bus_dmamap_t			dmap;
	struct tht_tx_free		txf;
	struct tht_pkt			*pkt;

	if (tht_fifo_readable(sc, &sc->sc_txf) < sizeof(txf))
		return;

	tht_fifo_pre(sc, &sc->sc_txf);

	do {
		tht_fifo_read(sc, &sc->sc_txf, &txf, sizeof(txf));

		DPRINTF(THT_D_TX, "%s: txf uid 0x%llx\n", DEVNAME(sc), txf.uid);

		pkt = &sc->sc_tx_list.tpl_pkts[txf.uid];
		dmap = pkt->tp_dmap;

		bus_dmamap_sync(dmat, dmap, 0, dmap->dm_mapsize,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(dmat, dmap);

		m_freem(pkt->tp_m);

		tht_pkt_put(&sc->sc_tx_list, pkt);

	} while (sc->sc_txf.tf_ready >= sizeof(txf));

	ifq_clr_oactive(&ifp->if_snd);

	tht_fifo_post(sc, &sc->sc_txf);
}

void
tht_rxf_fill(struct tht_softc *sc, int wait)
{
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	bus_dmamap_t			dmap;
	struct tht_rx_free		rxf;
	struct tht_pkt			*pkt;
	struct mbuf			*m;
	int				bc;

	if (tht_fifo_writable(sc, &sc->sc_rxf) <= THT_FIFO_DESC_LEN)
		return;

	tht_fifo_pre(sc, &sc->sc_rxf);

	for (;;) {
		if ((pkt = tht_pkt_get(&sc->sc_rx_list)) == NULL)
			goto done;

		MGETHDR(m, wait ? M_WAIT : M_DONTWAIT, MT_DATA);
		if (m == NULL)
			goto put_pkt;

		MCLGET(m, wait ? M_WAIT : M_DONTWAIT);
		if (!ISSET(m->m_flags, M_EXT))
			goto free_m;

		m->m_data += ETHER_ALIGN;
		m->m_len = m->m_pkthdr.len = MCLBYTES - ETHER_ALIGN;

		dmap = pkt->tp_dmap;
		if (bus_dmamap_load_mbuf(dmat, dmap, m,
		    wait ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT) != 0)
			goto free_m;

		pkt->tp_m = m;

		bc = sizeof(rxf) + sizeof(struct tht_pbd) * dmap->dm_nsegs;

		rxf.bc = htole16(LWORDS(bc));
		rxf.type = htole16(THT_RXF_TYPE);
		rxf.uid = pkt->tp_id;

		tht_fifo_write(sc, &sc->sc_rxf, &rxf, sizeof(rxf));
		tht_fifo_write_dmap(sc, &sc->sc_rxf, dmap);
		tht_fifo_write_pad(sc, &sc->sc_rxf, bc);

		bus_dmamap_sync(dmat, dmap, 0, dmap->dm_mapsize,
		    BUS_DMASYNC_PREREAD);

		if (sc->sc_rxf.tf_ready <= THT_FIFO_DESC_LEN)
			goto done;
	}

free_m:
	m_freem(m);
put_pkt:
	tht_pkt_put(&sc->sc_rx_list, pkt);
done:
	tht_fifo_post(sc, &sc->sc_rxf);
}

void
tht_rxf_drain(struct tht_softc *sc)
{
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	bus_dmamap_t			dmap;
	struct tht_pkt			*pkt;

	while ((pkt = tht_pkt_used(&sc->sc_rx_list)) != NULL) {
		dmap = pkt->tp_dmap;

		bus_dmamap_sync(dmat, dmap, 0, dmap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(dmat, dmap);

		m_freem(pkt->tp_m);

		tht_pkt_put(&sc->sc_rx_list, pkt);
	}
}

void
tht_rxd(struct tht_softc *sc)
{
	struct ifnet			*ifp = &sc->sc_ac.ac_if;
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	bus_dmamap_t			dmap;
	struct tht_rx_desc		rxd;
	struct tht_pkt			*pkt;
	struct mbuf			*m;
	struct mbuf_list		ml = MBUF_LIST_INITIALIZER();
	int				bc;
	u_int32_t			flags;

	if (tht_fifo_readable(sc, &sc->sc_rxd) < sizeof(rxd))
		return;

	tht_fifo_pre(sc, &sc->sc_rxd);

	do {
		tht_fifo_read(sc, &sc->sc_rxd, &rxd, sizeof(rxd));

		flags = letoh32(rxd.flags);
		bc = THT_RXD_FLAGS_BC(flags) * 8;
		bc -= sizeof(rxd);
		pkt = &sc->sc_rx_list.tpl_pkts[rxd.uid];

		dmap = pkt->tp_dmap;

		bus_dmamap_sync(dmat, dmap, 0, dmap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(dmat, dmap);

		m = pkt->tp_m;
		m->m_pkthdr.len = m->m_len = letoh16(rxd.len);

		/* XXX process type 3 rx descriptors */

		ml_enqueue(&ml, m);

		tht_pkt_put(&sc->sc_rx_list, pkt);

		while (bc > 0) {
			static u_int32_t pad;

			tht_fifo_read(sc, &sc->sc_rxd, &pad, sizeof(pad));
			bc -= sizeof(pad);
		}
	} while (sc->sc_rxd.tf_ready >= sizeof(rxd));

	tht_fifo_post(sc, &sc->sc_rxd);

	if_input(ifp, &ml);

	/* put more pkts on the fifo */
	tht_rxf_fill(sc, 0);
}

void
tht_watchdog(struct ifnet *ifp)
{
	/* do nothing */
}

int
tht_media_change(struct ifnet *ifp)
{
	/* ignore */
	return (0);
}

void
tht_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct tht_softc		*sc = ifp->if_softc;

	imr->ifm_active = IFM_ETHER | IFM_AUTO;
	imr->ifm_status = IFM_AVALID;

	tht_link_state(sc);

	if (LINK_STATE_IS_UP(ifp->if_link_state))
		imr->ifm_status |= IFM_ACTIVE;
}

int
tht_fifo_alloc(struct tht_softc *sc, struct tht_fifo *tf,
    struct tht_fifo_desc *tfd)
{
	u_int64_t			dva;

	tf->tf_len = THT_FIFO_SIZE(tfd->tfd_size);
	tf->tf_mem = tht_dmamem_alloc(sc, tf->tf_len, THT_FIFO_ALIGN);
	if (tf->tf_mem == NULL)
		return (1);

	tf->tf_desc = tfd;
	tf->tf_rptr = tf->tf_wptr = 0;

	bus_dmamap_sync(sc->sc_thtc->sc_dmat, THT_DMA_MAP(tf->tf_mem),
	    0, tf->tf_len, THT_FIFO_PRE_SYNC(tfd));

	dva = THT_DMA_DVA(tf->tf_mem);
	tht_write(sc, tfd->tfd_cfg0, (u_int32_t)dva | tfd->tfd_size);
	tht_write(sc, tfd->tfd_cfg1, (u_int32_t)(dva >> 32));

	return (0);
}

void
tht_fifo_free(struct tht_softc *sc, struct tht_fifo *tf)
{
	bus_dmamap_sync(sc->sc_thtc->sc_dmat, THT_DMA_MAP(tf->tf_mem),
	    0, tf->tf_len, THT_FIFO_POST_SYNC(tf->tf_desc));
	tht_dmamem_free(sc, tf->tf_mem);
}

size_t
tht_fifo_readable(struct tht_softc *sc, struct tht_fifo *tf)
{
	tf->tf_wptr = tht_read(sc, tf->tf_desc->tfd_wptr);
	tf->tf_wptr &= THT_FIFO_PTR_MASK;
	tf->tf_ready = tf->tf_wptr - tf->tf_rptr;
	if (tf->tf_ready < 0)
		tf->tf_ready += tf->tf_len;

	DPRINTF(THT_D_FIFO, "%s: fifo rdable wptr: %d rptr: %d ready: %d\n",
	    DEVNAME(sc), tf->tf_wptr, tf->tf_rptr, tf->tf_ready);

	return (tf->tf_ready);
}

size_t
tht_fifo_writable(struct tht_softc *sc, struct tht_fifo *tf)
{
	tf->tf_rptr = tht_read(sc, tf->tf_desc->tfd_rptr);
	tf->tf_rptr &= THT_FIFO_PTR_MASK;
	tf->tf_ready = tf->tf_rptr - tf->tf_wptr;
	if (tf->tf_ready <= 0)
		tf->tf_ready += tf->tf_len;

	DPRINTF(THT_D_FIFO, "%s: fifo wrable wptr: %d rptr: %d ready: %d\n",
	    DEVNAME(sc), tf->tf_wptr, tf->tf_rptr, tf->tf_ready);

	return (tf->tf_ready);
}

void
tht_fifo_pre(struct tht_softc *sc, struct tht_fifo *tf)
{
	bus_dmamap_sync(sc->sc_thtc->sc_dmat, THT_DMA_MAP(tf->tf_mem),
	    0, tf->tf_len, THT_FIFO_POST_SYNC(tf->tf_desc));
}

void
tht_fifo_read(struct tht_softc *sc, struct tht_fifo *tf,
    void *buf, size_t buflen)
{
	u_int8_t			*fifo = THT_DMA_KVA(tf->tf_mem);
	u_int8_t			*desc = buf;
	size_t				len;

	tf->tf_ready -= buflen;

	len = tf->tf_len - tf->tf_rptr;

	if (len < buflen) {
		memcpy(desc, fifo + tf->tf_rptr, len);

		buflen -= len;
		desc += len;

		tf->tf_rptr = 0;
	}

	memcpy(desc, fifo + tf->tf_rptr, buflen);
	tf->tf_rptr += buflen;

	DPRINTF(THT_D_FIFO, "%s: fifo rd wptr: %d rptr: %d ready: %d\n",
	    DEVNAME(sc), tf->tf_wptr, tf->tf_rptr, tf->tf_ready);
}

void
tht_fifo_write(struct tht_softc *sc, struct tht_fifo *tf,
    void *buf, size_t buflen)
{
	u_int8_t			*fifo = THT_DMA_KVA(tf->tf_mem);
	u_int8_t			*desc = buf;
	size_t				len;

	tf->tf_ready -= buflen;

	len = tf->tf_len - tf->tf_wptr;

	if (len < buflen) {
		memcpy(fifo + tf->tf_wptr, desc, len);

		buflen -= len;
		desc += len;

		tf->tf_wptr = 0;
	}

	memcpy(fifo + tf->tf_wptr, desc, buflen);
	tf->tf_wptr += buflen;
	tf->tf_wptr %= tf->tf_len;

	DPRINTF(THT_D_FIFO, "%s: fifo wr wptr: %d rptr: %d ready: %d\n",
	    DEVNAME(sc), tf->tf_wptr, tf->tf_rptr, tf->tf_ready);
}

void
tht_fifo_write_dmap(struct tht_softc *sc, struct tht_fifo *tf,
    bus_dmamap_t dmap)
{
	struct tht_pbd			pbd;
	u_int64_t			dva;
	int				i;

	for (i = 0; i < dmap->dm_nsegs; i++) {
		dva = dmap->dm_segs[i].ds_addr;

		pbd.addr_lo = htole32(dva);
		pbd.addr_hi = htole32(dva >> 32);
		pbd.len = htole32(dmap->dm_segs[i].ds_len);

		tht_fifo_write(sc, tf, &pbd, sizeof(pbd));
	}
}

void
tht_fifo_write_pad(struct tht_softc *sc, struct tht_fifo *tf, int bc)
{
	const static u_int32_t pad = 0x0;

	/* this assumes you'll only ever be writing multiples of 4 bytes */
	if (bc % 8)
		tht_fifo_write(sc, tf, (void *)&pad, sizeof(pad));
}

void
tht_fifo_post(struct tht_softc *sc, struct tht_fifo *tf)
{
	bus_dmamap_sync(sc->sc_thtc->sc_dmat, THT_DMA_MAP(tf->tf_mem),
	    0, tf->tf_len, THT_FIFO_PRE_SYNC(tf->tf_desc));
	if (tf->tf_desc->tfd_write)
		tht_write(sc, tf->tf_desc->tfd_wptr, tf->tf_wptr);
	else
		tht_write(sc, tf->tf_desc->tfd_rptr, tf->tf_rptr);

	DPRINTF(THT_D_FIFO, "%s: fifo post wptr: %d rptr: %d\n", DEVNAME(sc),
	    tf->tf_wptr, tf->tf_rptr);
}

const static bus_size_t tht_mac_regs[3] = {
    THT_REG_RX_UNC_MAC2, THT_REG_RX_UNC_MAC1, THT_REG_RX_UNC_MAC0
};

void
tht_lladdr_read(struct tht_softc *sc)
{
	int				i;

	for (i = 0; i < nitems(tht_mac_regs); i++)
		sc->sc_lladdr[i] = betoh16(tht_read(sc, tht_mac_regs[i]));
}

void
tht_lladdr_write(struct tht_softc *sc)
{
	int				i;

	for (i = 0; i < nitems(tht_mac_regs); i++)
		tht_write(sc, tht_mac_regs[i], htobe16(sc->sc_lladdr[i]));
}

#define tht_swrst_set(_s, _r) tht_write((_s), (_r), 0x1)
#define tht_swrst_clr(_s, _r) tht_write((_s), (_r), 0x0)
int
tht_sw_reset(struct tht_softc *sc)
{
	int				i;

	/* this follows SW Reset process in 8.8 of the doco */

	/* 1. disable rx */
	tht_clr(sc, THT_REG_RX_FLT, THT_REG_RX_FLT_OSEN);

	/* 2. initiate port disable */
	tht_swrst_set(sc, THT_REG_DIS_PRT);

	/* 3. initiate queue disable */
	tht_swrst_set(sc, THT_REG_DIS_QU_0);
	tht_swrst_set(sc, THT_REG_DIS_QU_1);

	/* 4. wait for successful finish of previous tasks */
	if (!tht_wait_set(sc, THT_REG_RST_PRT, THT_REG_RST_PRT_ACTIVE, 1000))
		return (1);

	/* 5. Reset interrupt registers */
	tht_write(sc, THT_REG_IMR, 0x0); /* 5.a */
	tht_read(sc, THT_REG_ISR); /* 5.b */
	for (i = 0; i < THT_NQUEUES; i++) {
		tht_write(sc, THT_REG_RDINTCM(i), 0x0); /* 5.c/5.d */
		tht_write(sc, THT_REG_TDINTCM(i), 0x0); /* 5.e */
	}

	/* 6. initiate queue reset */
	tht_swrst_set(sc, THT_REG_RST_QU_0);
	tht_swrst_set(sc, THT_REG_RST_QU_1);

	/* 7. initiate port reset */
	tht_swrst_set(sc, THT_REG_RST_PRT);

	/* 8. clear txt/rxf/rxd/txf read and write ptrs */
	for (i = 0; i < THT_NQUEUES; i++) {
		tht_write(sc, THT_REG_TXT_RPTR(i), 0);
		tht_write(sc, THT_REG_RXF_RPTR(i), 0);
		tht_write(sc, THT_REG_RXD_RPTR(i), 0);
		tht_write(sc, THT_REG_TXF_RPTR(i), 0);

		tht_write(sc, THT_REG_TXT_WPTR(i), 0);
		tht_write(sc, THT_REG_RXF_WPTR(i), 0);
		tht_write(sc, THT_REG_RXD_WPTR(i), 0);
		tht_write(sc, THT_REG_TXF_WPTR(i), 0);
	}

	/* 9. unset port disable */
	tht_swrst_clr(sc, THT_REG_DIS_PRT);

	/* 10. unset queue disable */
	tht_swrst_clr(sc, THT_REG_DIS_QU_0);
	tht_swrst_clr(sc, THT_REG_DIS_QU_1);

	/* 11. unset queue reset */
	tht_swrst_clr(sc, THT_REG_RST_QU_0);
	tht_swrst_clr(sc, THT_REG_RST_QU_1);

	/* 12. unset port reset */
	tht_swrst_clr(sc, THT_REG_RST_PRT);

	/* 13. enable rx */
	tht_set(sc, THT_REG_RX_FLT, THT_REG_RX_FLT_OSEN);

	return (0);
}

int
tht_fw_load(struct tht_softc *sc)
{
	struct timeout			ticker;
	volatile int			ok = 1;
	u_int8_t			*fw, *buf;
	size_t				fwlen, wrlen;
	int				error = 1;

	if (loadfirmware("tht", &fw, &fwlen) != 0)
		return (1);

	if ((fwlen % 8) != 0)
		goto err;

	buf = fw;
	while (fwlen > 0) {
		while (tht_fifo_writable(sc, &sc->sc_txt) <= THT_FIFO_GAP) {
			if (tsleep(sc, PCATCH, "thtfw", 1) == EINTR)
				goto err;
		}

		wrlen = MIN(sc->sc_txt.tf_ready - THT_FIFO_GAP, fwlen);
		tht_fifo_pre(sc, &sc->sc_txt);
		tht_fifo_write(sc, &sc->sc_txt, buf, wrlen);
		tht_fifo_post(sc, &sc->sc_txt);

		fwlen -= wrlen;
		buf += wrlen;
	}

	timeout_set(&ticker, tht_fw_tick, (void *)&ok);
	timeout_add_sec(&ticker, 2);
	while (ok) {
		if (tht_read(sc, THT_REG_INIT_STATUS) != 0) {
			error = 0;
			break;
		}

		if (tsleep(sc, PCATCH, "thtinit", 1) == EINTR)
			goto err;
	}
	timeout_del(&ticker);

	tht_write(sc, THT_REG_INIT_SEMAPHORE, 0x1);

err:
	free(fw, M_DEVBUF, fwlen);
	return (error);
}

void
tht_fw_tick(void *arg)
{
	volatile int			*ok = arg;

	*ok = 0;
}

void
tht_link_state(struct tht_softc *sc)
{
	static const struct timeval	interval = { 0, 10000 };
	struct ifnet			*ifp = &sc->sc_ac.ac_if;
	int				link_state = LINK_STATE_DOWN;

	if (!ratecheck(&sc->sc_mediacheck, &interval))
		return;

	if (tht_read(sc, THT_REG_MAC_LNK_STAT) & THT_REG_MAC_LNK_STAT_LINK)
		link_state = LINK_STATE_FULL_DUPLEX;

	if (ifp->if_link_state != link_state) {
		ifp->if_link_state = link_state;
		if_link_state_change(ifp);
	}

	if (LINK_STATE_IS_UP(ifp->if_link_state))
		ifp->if_baudrate = IF_Gbps(10);
	else
		ifp->if_baudrate = 0;
}

u_int32_t
tht_read(struct tht_softc *sc, bus_size_t r)
{
	bus_space_barrier(sc->sc_thtc->sc_memt, sc->sc_memh, r, 4,
	    BUS_SPACE_BARRIER_READ);
	return (bus_space_read_4(sc->sc_thtc->sc_memt, sc->sc_memh, r));
}

void
tht_write(struct tht_softc *sc, bus_size_t r, u_int32_t v)
{
	bus_space_write_4(sc->sc_thtc->sc_memt, sc->sc_memh, r, v);
	bus_space_barrier(sc->sc_thtc->sc_memt, sc->sc_memh, r, 4,
	    BUS_SPACE_BARRIER_WRITE);
}

void
tht_write_region(struct tht_softc *sc, bus_size_t r, void *buf, size_t len)
{
	bus_space_write_raw_region_4(sc->sc_thtc->sc_memt, sc->sc_memh, r,
	    buf, len);
	bus_space_barrier(sc->sc_thtc->sc_memt, sc->sc_memh, r, len,
	    BUS_SPACE_BARRIER_WRITE);
}

int
tht_wait_eq(struct tht_softc *sc, bus_size_t r, u_int32_t m, u_int32_t v,
    int timeout)
{
	while ((tht_read(sc, r) & m) != v) {
		if (timeout == 0)
			return (0);

		delay(1000);
		timeout--;
	}

	return (1);
}

int
tht_wait_ne(struct tht_softc *sc, bus_size_t r, u_int32_t m, u_int32_t v,
    int timeout)
{
	while ((tht_read(sc, r) & m) == v) {
		if (timeout == 0)
			return (0);

		delay(1000);
		timeout--;
	}

	return (1);
}

struct tht_dmamem *
tht_dmamem_alloc(struct tht_softc *sc, bus_size_t size, bus_size_t align)
{
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	struct tht_dmamem		*tdm;
	int				nsegs;

	tdm = malloc(sizeof(struct tht_dmamem), M_DEVBUF, M_WAITOK | M_ZERO);
	tdm->tdm_size = size;

	if (bus_dmamap_create(dmat, size, 1, size, 0,
	    BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW, &tdm->tdm_map) != 0)
		goto tdmfree;

	if (bus_dmamem_alloc(dmat, size, align, 0, &tdm->tdm_seg, 1, &nsegs,
	    BUS_DMA_WAITOK | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(dmat, &tdm->tdm_seg, nsegs, size, &tdm->tdm_kva,
	    BUS_DMA_WAITOK) != 0)
		goto free;

	if (bus_dmamap_load(dmat, tdm->tdm_map, tdm->tdm_kva, size,
	    NULL, BUS_DMA_WAITOK) != 0)
		goto unmap;

	return (tdm);

unmap:
	bus_dmamem_unmap(dmat, tdm->tdm_kva, size);
free:
	bus_dmamem_free(dmat, &tdm->tdm_seg, 1);
destroy:
	bus_dmamap_destroy(dmat, tdm->tdm_map);
tdmfree:
	free(tdm, M_DEVBUF, 0);

	return (NULL);
}

void
tht_dmamem_free(struct tht_softc *sc, struct tht_dmamem *tdm)
{
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;

	bus_dmamap_unload(dmat, tdm->tdm_map);
	bus_dmamem_unmap(dmat, tdm->tdm_kva, tdm->tdm_size);
	bus_dmamem_free(dmat, &tdm->tdm_seg, 1);
	bus_dmamap_destroy(dmat, tdm->tdm_map);
	free(tdm, M_DEVBUF, 0);
}

int
tht_pkt_alloc(struct tht_softc *sc, struct tht_pkt_list *tpl, int npkts,
    int nsegs)
{
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	struct tht_pkt			*pkt;
	int				i;

	tpl->tpl_pkts = mallocarray(npkts, sizeof(struct tht_pkt),
	    M_DEVBUF, M_WAITOK | M_ZERO);

	TAILQ_INIT(&tpl->tpl_free);
	TAILQ_INIT(&tpl->tpl_used);
	for (i = 0; i < npkts; i++) {
		pkt = &tpl->tpl_pkts[i];

		pkt->tp_id = i;
		if (bus_dmamap_create(dmat, THT_PBD_PKTLEN, nsegs,
		    THT_PBD_PKTLEN, 0, BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
		    &pkt->tp_dmap) != 0) {
			tht_pkt_free(sc, tpl);
			return (1);
		}

		TAILQ_INSERT_TAIL(&tpl->tpl_free, pkt, tp_link);
	}

	return (0);
}

void
tht_pkt_free(struct tht_softc *sc, struct tht_pkt_list *tpl)
{
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	struct tht_pkt			*pkt;

	while ((pkt = tht_pkt_get(tpl)) != NULL)
		bus_dmamap_destroy(dmat, pkt->tp_dmap);
	free(tpl->tpl_pkts, M_DEVBUF, 0);
	tpl->tpl_pkts = NULL;
}

void
tht_pkt_put(struct tht_pkt_list *tpl, struct tht_pkt *pkt)
{
	TAILQ_REMOVE(&tpl->tpl_used, pkt, tp_link);
	TAILQ_INSERT_TAIL(&tpl->tpl_free, pkt, tp_link);
}

struct tht_pkt *
tht_pkt_get(struct tht_pkt_list *tpl)
{
	struct tht_pkt			*pkt;

	pkt = TAILQ_FIRST(&tpl->tpl_free);
	if (pkt != NULL) {
		TAILQ_REMOVE(&tpl->tpl_free, pkt, tp_link);
		TAILQ_INSERT_TAIL(&tpl->tpl_used, pkt, tp_link);

	}

	return (pkt);
}

struct tht_pkt *
tht_pkt_used(struct tht_pkt_list *tpl)
{
	return (TAILQ_FIRST(&tpl->tpl_used));
}
@


1.139
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.138 2015/12/11 16:07:02 mpi Exp $ */
a1154 2

		ifp->if_opackets++;
@


1.138
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.137 2015/11/25 03:09:59 dlg Exp $ */
a785 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.137
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.136 2015/11/24 13:33:17 mpi Exp $ */
d501 1
a501 1
void			tht_mountroot(void *);
d797 1
a797 1
	mountroothook_establish(tht_mountroot, sc);
d801 1
a801 1
tht_mountroot(void *arg)
d803 1
a803 1
	struct tht_softc		*sc = arg;
@


1.136
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.135 2015/11/20 03:35:23 dlg Exp $ */
d970 1
a970 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1065 2
a1066 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE | IFF_ALLMULTI);
d1101 1
a1101 1
	if (ifp->if_flags & IFF_OACTIVE)
d1121 1
a1121 1
			ifp->if_flags |= IFF_OACTIVE;
d1237 1
a1237 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.135
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.134 2015/10/25 13:04:28 mpi Exp $ */
a49 1
#include <net/if_types.h>
@


1.134
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.133 2015/08/28 00:03:53 deraadt Exp $ */
d1114 1
a1114 1
		IFQ_POLL(&ifp->if_snd, m);
d1120 1
d1125 1
a1125 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.133
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.132 2015/06/24 09:40:54 mpi Exp $ */
a867 1
	struct ifaddr			*ifa = (struct ifaddr *)addr;
a876 3

		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.132
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.131 2015/04/30 07:51:07 mpi Exp $ */
d1720 1
a1720 1
	free(fw, M_DEVBUF, 0);
@


1.131
log
@Convert moar drivers to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.130 2015/03/14 03:38:48 jsg Exp $ */
a1373 3

		ifp->if_ipackets++;

@


1.130
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.129 2014/12/22 02:28:52 tedu Exp $ */
d1336 1
a1359 1
		m->m_pkthdr.rcvif = ifp;
d1364 1
a1364 6
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		ether_input_mbuf(ifp, m);
d1380 2
@


1.129
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.128 2014/07/13 23:10:23 deraadt Exp $ */
a48 1
#include <net/if_dl.h>
@


1.128
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.127 2014/07/12 18:48:52 tedu Exp $ */
a56 1
#ifdef INET
a58 1
#endif
a879 1
#ifdef INET
a881 1
#endif
@


1.127
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.126 2013/04/02 13:43:40 brad Exp $ */
d1882 2
a1883 2
	tpl->tpl_pkts = malloc(sizeof(struct tht_pkt) * npkts, M_DEVBUF,
	    M_WAITOK | M_ZERO);
@


1.126
log
@- Have the tht(4) ioctl handler for SIOCSIFFLAGS set ENETRESET
  instead of calling tht_iff() directly.
- Add a comment in tht_up() about the use of tht_iff().
- Have tht_iff() set IFF_ALLMULTI when in promisc mode.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.125 2013/01/14 23:19:39 deraadt Exp $ */
d1731 1
a1731 1
	free(fw, M_DEVBUF);
d1857 1
a1857 1
	free(tdm, M_DEVBUF);
d1871 1
a1871 1
	free(tdm, M_DEVBUF);
d1912 1
a1912 1
	free(tpl->tpl_pkts, M_DEVBUF);
@


1.125
log
@use one interrupt handler for the thtc headend, rather than seperate
interrupt handlers for the ports.  this ensures that the 2nd port
does not get starved.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.124 2010/05/19 15:27:35 oga Exp $ */
d891 1
a891 1
				tht_iff(sc);
d976 1
d1023 2
a1024 1
	if (ifp->if_flags & IFF_PROMISC)
d1026 1
a1026 1
	else if (sc->sc_ac.ac_multirangecnt > 0) {
@


1.124
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.123 2010/04/08 00:23:53 tedu Exp $ */
d403 1
a423 1
	pci_intr_handle_t	taa_ih;
a481 2
	void			*sc_ih;

d690 1
d705 1
a705 1
	if (pci_intr_map(pa, &taa.taa_ih) != 0) {
d709 8
a716 1
	printf(": %s\n", pci_intr_string(pa->pa_pc, taa.taa_ih));
a776 8
	sc->sc_ih = pci_intr_establish(taa->taa_pa->pa_pc, taa->taa_ih,
	    IPL_NET, tht_intr, sc, DEVNAME(sc));
	if (sc->sc_ih == NULL) {
		printf(": unable to establish interrupt\n");
		/* bus_space(9) says we dont have to free subregions */
		return;
	}

d826 1
d828 1
d831 5
d837 6
a842 5
	isr = tht_read(sc, THT_REG_ISR);
	if (isr == 0x0) {
		tht_write(sc, THT_REG_IMR, sc->sc_imr);
		return (0);
	}
d844 1
a844 1
	DPRINTF(THT_D_INTR, "%s: isr: 0x%b\n", DEVNAME(sc), isr, THT_FMT_ISR);
d846 2
a847 2
	if (ISSET(isr, THT_REG_ISR_LINKCHG(0) | THT_REG_ISR_LINKCHG(1)))
		tht_link_state(sc);
d849 4
a852 4
	ifp = &sc->sc_ac.ac_if;
	if (ifp->if_flags & IFF_RUNNING) {
		if (ISSET(isr, THT_REG_ISR_RXD(0)))
			tht_rxd(sc);
d854 2
a855 2
		if (ISSET(isr, THT_REG_ISR_RXF(0)))
			tht_rxf_fill(sc, 0);
d857 2
a858 2
		if (ISSET(isr, THT_REG_ISR_TXF(0)))
			tht_txf(sc);
d860 3
a862 1
		tht_start(ifp);
d864 1
a864 3

	tht_write(sc, THT_REG_IMR, sc->sc_imr);
	return (1);
@


1.123
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.122 2009/04/07 05:03:25 dlg Exp $ */
d1829 1
a1829 1
	    BUS_DMA_WAITOK) != 0)
a1838 2

	bzero(tdm->tdm_kva, size);
@


1.122
log
@dont enable checksumming. it appears to be broken on fragmented packets.

discovered by deraadt@@, fix tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.120 2008/11/23 12:48:43 dlg Exp $ */
d37 1
a37 1
#include <sys/proc.h>
@


1.121
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d785 1
a785 2
	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_CSUM_IPv4 |
	    IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
d1142 1
a1142 2
		flags = THT_TXT_TYPE | THT_TXT_FLAGS_UDPCS |
		    THT_TXT_FLAGS_TCPCS | THT_TXT_FLAGS_IPCS | LWORDS(bc);
a1357 7

		if (!ISSET(flags, THT_RXD_FLAGS_IPCS))
			m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;
		if (!ISSET(flags, THT_RXD_FLAGS_TCPCS))
			m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK;
		if (!ISSET(flags, THT_RXD_FLAGS_UDPCS))
			m->m_pkthdr.csum_flags |= M_UDP_CSUM_IN_OK;
@


1.120
log
@sizeofa -> nitems
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.119 2008/10/02 20:21:14 brad Exp $ */
d866 1
d868 1
a868 3
	struct ifaddr			*ifa;
	int				error = 0;
	int				s;
d875 1
a875 1
		ifa = (struct ifaddr *)addr;
d881 1
a882 2
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
a892 14
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

	case SIOCADDMULTI:
		error = ether_addmulti(ifr, &sc->sc_ac);
		break;
	case SIOCDELMULTI:
		error = ether_delmulti(ifr, &sc->sc_ac);
@


1.119
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.118 2008/09/10 14:01:22 blambert Exp $ */
a639 1
#define sizeofa(_a)	(sizeof(_a) / sizeof((_a)[0]))
d663 1
a663 1
	for (i = 0; i < sizeofa(thtc_devices); i++) {
d1617 1
a1617 1
	for (i = 0; i < sizeofa(tht_mac_regs); i++)
d1626 1
a1626 1
	for (i = 0; i < sizeofa(tht_mac_regs); i++)
@


1.118
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.117 2008/05/13 00:52:12 brad Exp $ */
d869 1
a869 1
	int				error;
a874 4
	error = ether_ioctl(ifp, &sc->sc_ac, cmd, addr);
	if (error > 0)
		goto err;

d918 1
a918 2
		error = ENOTTY;
		break;
a926 1
err:
@


1.117
log
@Also report the duplex state of the connection when calling
if_link_state_change() which is always full duplex for tht(4).

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.116 2008/05/12 10:02:42 kettenis Exp $ */
d1740 1
a1740 1
	timeout_add(&ticker, 2*hz);
@


1.116
log
@Make this compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.115 2008/05/12 06:59:19 canacar Exp $ */
d1778 1
a1778 1
		link_state = LINK_STATE_UP;
d1785 1
a1785 1
	if (ifp->if_link_state == LINK_STATE_UP)
@


1.115
log
@Pass correct argument to timeout_set so that the timeout can break the
loop as intended. ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.114 2008/04/11 11:34:00 thib Exp $ */
d1739 1
a1739 1
	timeout_set(&ticker, tht_fw_tick, &ok);
@


1.114
log
@introduce THT_{RXF/TXT}_PKT_NUM macros and use them instead of the
hard coded value of 128 for the pkt allocations.

OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.113 2008/04/04 11:05:04 dlg Exp $ */
d1739 1
a1739 1
	timeout_set(&ticker, tht_fw_tick, &ticker);
@


1.113
log
@tht is cool cos it generates interrupts when the link state change.
however, tht is uncool cos it generates these interrupts spuriously (up to
8000 times a second).

this rate limits the reading of the link state off the hardware to 100
times a second. less bus_space reads is a good thing.

tested by and ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.111 2008/01/17 20:45:16 thib Exp $ */
d300 1
d382 1
d948 2
a949 1
	if (tht_pkt_alloc(sc, &sc->sc_tx_list, 128, THT_TXT_SGL_LEN) != 0)
d951 2
a952 1
	if (tht_pkt_alloc(sc, &sc->sc_rx_list, 128, THT_RXF_SGL_LEN) != 0)
@


1.112
log
@Correct the baudrate handling.

ok dlg@@
@
text
@d40 1
d486 1
d1766 1
d1769 3
@


1.111
log
@Set if_baudrate with IF_Gbps(10);

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.110 2008/01/14 16:13:40 thib Exp $ */
a790 1
	ifp->if_baudrate = IF_Gbps(10);
d1774 5
@


1.110
log
@Zap two usless printfs.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.109 2007/09/19 12:00:35 dlg Exp $ */
d791 1
@


1.109
log
@M_ZERO. all the cool kids are doing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.108 2007/07/22 03:54:15 dlg Exp $ */
a940 1
		printf("%s: interface is already up\n", DEVNAME(sc));
a1081 1
		printf("%s: interface is already down\n", DEVNAME(sc));
@


1.108
log
@clear the IFF_ALLMULTI flag when the interface goes down.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.107 2007/07/22 03:53:06 dlg Exp $ */
d1840 1
a1840 2
	tdm = malloc(sizeof(struct tht_dmamem), M_DEVBUF, M_WAITOK);
	bzero(tdm, sizeof(struct tht_dmamem));
d1896 1
a1896 2
	    M_WAITOK);
	bzero(tpl->tpl_pkts, sizeof(struct tht_pkt) * npkts);
@


1.107
log
@the softc variable is sc, not sp.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.106 2007/05/28 06:34:06 dlg Exp $ */
d1087 1
a1087 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.106
log
@use memcpy when copying to/from the fifos, apparently gcc can do a better
job of optimising it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.105 2007/05/26 20:47:32 dlg Exp $ */
d1804 1
a1804 1
tht_wait_eq(struct tht_softc *sp, bus_size_t r, u_int32_t m, u_int32_t v,
d1807 1
a1807 1
	while ((tht_read(sp, r) & m) != v) {
d1819 1
a1819 1
tht_wait_ne(struct tht_softc *sp, bus_size_t r, u_int32_t m, u_int32_t v,
d1822 1
a1822 1
	while ((tht_read(sp, r) & m) == v) {
@


1.105
log
@chop ETHER_ALIGN off the size of the packet we tell the hw we can do
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.104 2007/05/26 20:28:22 claudio Exp $ */
d1524 1
a1524 1
		bcopy(fifo + tf->tf_rptr, desc, len);
d1532 1
a1532 1
	bcopy(fifo + tf->tf_rptr, desc, buflen);
d1552 1
a1552 1
		bcopy(desc, fifo + tf->tf_wptr, len);
d1560 1
a1560 1
	bcopy(desc, fifo + tf->tf_wptr, buflen);
@


1.104
log
@ETHER_ALIGN rx mbuf so that it works on strict alignment archs. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.103 2007/05/26 20:22:01 dlg Exp $ */
d959 1
a959 1
	tht_write(sc, THT_REG_10G_FRM_LEN, MCLBYTES);
d975 1
a975 1
	tht_write(sc, THT_REG_RX_MAX_FRAME, MCLBYTES);
@


1.103
log
@correctly byteswap the mac address when moving it on and off teh card
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.102 2007/05/17 10:12:53 dlg Exp $ */
d1290 2
a1291 1
		m->m_len = m->m_pkthdr.len = MCLBYTES;
@


1.102
log
@copy the lladdr from the arpcom struct onto the hardware when the interface
is brought up.

this driver now supports all the features our network layer expects of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.101 2007/05/17 09:30:54 dlg Exp $ */
d1620 1
a1620 1
		sc->sc_lladdr[i] = swap16(tht_read(sc, tht_mac_regs[i]));
d1629 1
a1629 1
		tht_write(sc, tht_mac_regs[i], swap16(sc->sc_lladdr[i]));
@


1.101
log
@support changing the mtu up to the maximum frame size it currently
supports (MCLBYTES).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.100 2007/05/16 09:27:44 dlg Exp $ */
d983 1
@


1.100
log
@add support for multicast addresses. this adds the add/del multi handlers
to the ioctl, and programs the multicast filter in tht_iff.

we are not using the perfect multicast filters, only the imperfect one. i
think there is a requirement that addresses in the perfect filter be in
order, but im not sure how to do that nicely (yet).

this has taken a long time because i dont know how to write c.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.99 2007/05/08 14:07:14 dlg Exp $ */
d787 1
a787 1
	ifp->if_hardmtu = 1500; /* XXX */
d896 7
@


1.99
log
@make a start at dealing with interface flags. this toggles the hardware
promiscuity depending on the if_flags IFF_PROMISC bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.98 2007/05/08 13:40:42 dlg Exp $ */
d619 2
d898 7
d909 1
d915 6
d1011 2
d1014 5
d1021 5
d1029 20
d1050 16
d1782 9
@


1.98
log
@add the multicast filter registers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.97 2007/05/08 13:35:45 dlg Exp $ */
d603 1
d887 1
a887 1
				/* multicast/promisc change */;
a961 3
	tht_write(sc, THT_REG_RX_FLT, THT_REG_RX_FLT_OSEN |
	    THT_REG_RX_FLT_AM | THT_REG_RX_FLT_AB | THT_REG_RX_FLT_PRM_ALL);

d965 2
d989 14
@


1.97
log
@write the mac back to the chip when we bring it up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.96 2007/05/06 08:58:02 dlg Exp $ */
d235 5
@


1.96
log
@point the macros for the interrupt coalescing registers at the right
location. they moved from what the doco says to somewhere else.

pointed out by Nadav Shemer (thanks)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.95 2007/05/06 03:08:35 dlg Exp $ */
d578 2
a579 1
void			tht_read_lladdr(struct tht_softc *);
d768 1
a768 1
	tht_read_lladdr(sc);
d954 2
d1519 13
d1533 1
a1533 1
tht_read_lladdr(struct tht_softc *sc)
a1534 3
	const static bus_size_t		r[3] = {
	    THT_REG_RX_UNC_MAC2, THT_REG_RX_UNC_MAC1, THT_REG_RX_UNC_MAC0
	};
d1537 2
a1538 2
	for (i = 0; i < sizeofa(r); i++)
		sc->sc_lladdr[i] = swap16(tht_read(sc, r[i]));
@


1.95
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.94 2007/05/04 22:54:42 dlg Exp $ */
d109 1
a109 1
#define THT_REG_RDINTCM(_q)	(0x0120 + _Q(_q)) /* RX DSC Intr Coalescing */
d114 1
a114 1
#define THT_REG_TDINTCM(_q)	(0x0130 + _Q(_q)) /* TX DSC Intr Coalescing */
@


1.94
log
@the hardware does checksumming on rx as well. mark the mbufs with what the
hw says.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.93 2007/05/04 22:39:55 dlg Exp $ */
d951 1
a951 1
	    THT_REG_TDINTCM_COAL_RC | THT_REG_RDINTCM_COAL(0x20));
@


1.93
log
@advertise tx checksumming to the network stack, and tell the hardware to
do it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.92 2007/05/04 22:20:06 dlg Exp $ */
d1284 7
@


1.92
log
@increase the number of tx and rx descriptors from 64 to 128 each
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.90 2007/05/04 21:56:46 dlg Exp $ */
d773 2
a774 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
d1068 2
a1069 1
		flags = THT_TXT_TYPE | LWORDS(bc); /* XXX */
@


1.91
log
@call the right function to fill the rxf fifo after rxd
@
text
@d914 1
a914 1
	if (tht_pkt_alloc(sc, &sc->sc_tx_list, 64, THT_TXT_SGL_LEN) != 0)
d916 1
a916 1
	if (tht_pkt_alloc(sc, &sc->sc_rx_list, 64, THT_RXF_SGL_LEN) != 0)
@


1.90
log
@disable debugging output
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.89 2007/05/04 21:54:01 dlg Exp $ */
d1308 1
a1308 1
	tht_rxf(sc, 0);
@


1.89
log
@put more rx descriptors back on the chip straight after we've taken some
off.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.88 2007/05/04 21:51:11 dlg Exp $ */
a59 2

#define THT_DEBUG
@


1.88
log
@wrap the wptr round when we hit the end of the fifo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.87 2007/04/30 00:02:12 deraadt Exp $ */
d1308 3
@


1.87
log
@fix dmesg; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.86 2007/04/29 21:44:32 dlg Exp $ */
d1457 1
@


1.86
log
@missing arguments in a couple of printfs.

patch from Tim van der Molen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.85 2007/04/29 11:58:12 dlg Exp $ */
d791 1
a791 1
	printf(" address %s\n", ether_sprintf(sc->sc_ac.ac_enaddr));
@


1.85
log
@Nadav Shemer of Tehuti Networks is magical.

not leaving the gap in the txt fifo when uploading the firmware was the
cause of my fifo write bug in tht_start. because i was filling the whole
fifo, i was writing the wptr back to its original position. because of
this i dont think the firmware thought i had written anything. only the
last short chunk would have been noticed, which strikes me as possibly
confusing to the chip.

this diff removes the delay at the top of tht_fifo_post. one less XXX :)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.84 2007/04/29 11:39:15 dlg Exp $ */
d912 1
a912 1
		printf("%s: interface is already up\n");
d990 1
a990 1
		printf("%s: interface is already down\n");
@


1.84
log
@clocks and pll register bits
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.83 2007/04/29 11:31:29 dlg Exp $ */
a1493 2
	delay(100); /* XXX this is dumb */

@


1.83
log
@we dont want to completely fill fifos, so leave a gap when we calculate
how much of the fifo we want to write firmware to.

from Nadav Shemer at Tehuti Networks
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.82 2007/04/29 11:28:25 dlg Exp $ */
d85 6
@


1.82
log
@when we post a fifo we're giving the dma mem back to the hardware, so we
need a presync, not a postsync.

another good find by Nadav Shemer at Tehuti Networks
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.81 2007/04/29 08:44:13 dlg Exp $ */
d1606 1
a1606 1
		wrlen = MIN(sc->sc_txt.tf_ready, fwlen);
@


1.81
log
@when completing a tx pkt, put it back on the tx free list, not the rx one.

found by Nadav Shemer at Tehuti Networks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.80 2007/04/27 21:42:40 cloder Exp $ */
d1491 1
a1491 1
	    0, tf->tf_len, THT_FIFO_POST_SYNC(tf->tf_desc));
@


1.80
log
@Correct typo in comment, no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.79 2007/04/27 06:45:34 cloder Exp $ */
d1154 1
a1154 1
		tht_pkt_put(&sc->sc_rx_list, pkt);
@


1.79
log
@Fix copy/paste-o in offset of TDINTCM register jointly spotted by dlg and
myself. This register controls TX interrupt and packet coalescing.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.78 2007/04/27 04:21:28 dlg Exp $ */
d131 1
a131 1
#define THT_REG_10G_FRM_LEN	0x6014 /* Fram Length */
@


1.78
log
@my txt fifo write bug is extremely strange. i need a delay before the
wptr write for it to work. delay(75) works, delay(67) doesnt, so im
disabling the fifo debug and adding delay(100) till this is worked out
properly with tehuti.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.77 2007/04/25 13:27:31 dlg Exp $ */
d110 1
a110 1
#define THT_REG_TDINTCM(_q)	(0x0120 + _Q(_q)) /* TX DSC Intr Coalescing */
@


1.77
log
@hook the rx path up.

despite having written it without being able to test, there was only one
real bug. i wasnt keeping track of the mbuf in the rx init path, so when
the completion tried to use it, it was dereferencing random memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.76 2007/04/25 12:52:22 dlg Exp $ */
d69 1
a69 1
int thtdebug = THT_D_FIFO | THT_D_TX | THT_D_RX | THT_D_INTR;
d1488 2
@


1.76
log
@add some dprintfs to the fifo handlers.

enabling these makes tx completions occur. i wish i could figure out why.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.75 2007/04/25 12:50:29 dlg Exp $ */
d263 2
a264 1
				    THT_REG_IMR_TXF(0))
d829 6
d1197 3
a1199 2
		bc = sizeof(rxf) +
		    sizeof(struct tht_pbd) * pkt->tp_dmap->dm_nsegs;
@


1.75
log
@when populating the rxf fifo, actually sync the rxf fifo at the start and
end of it, not txf.

still doesnt fix my bug
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.74 2007/04/25 11:01:09 dlg Exp $ */
d1364 3
d1379 3
d1415 3
d1443 3
d1486 3
@


1.74
log
@we only have to mask interrupts once when we bring the interface down
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.73 2007/04/25 10:29:36 dlg Exp $ */
d1169 1
a1169 1
	tht_fifo_pre(sc, &sc->sc_txf);
d1213 1
a1213 1
	tht_fifo_post(sc, &sc->sc_txf);
@


1.73
log
@i got a reg init wrong, still no tx completion though.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.72 2007/04/25 09:55:47 dlg Exp $ */
a1001 3

	sc->sc_imr = THT_IMR_DOWN(sc->sc_port);
	tht_write(sc, THT_REG_IMR, sc->sc_imr);
@


1.72
log
@enable tx completion interrupts and provide handling for them.

unfortunately theres a bug somehwere. i had this working 6 hours ago, but
after scrubbing that diff it no longer completes packets. so annoying.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.71 2007/04/25 09:52:45 dlg Exp $ */
d921 1
a921 1
	tht_write(sc, THT_REG_10G_RX_SEC, THT_REG_10G_SEC_AVAIL(0x10) |
@


1.71
log
@fix a dprintf in the debug path
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.70 2007/04/25 09:33:25 dlg Exp $ */
d262 2
a263 1
#define THT_IMR_UP(_p)		(THT_REG_IMR_LINKCHG(_p))
d812 1
d826 8
d1002 3
@


1.70
log
@more register init in tht_up
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.69 2007/04/25 08:32:58 dlg Exp $ */
d1052 1
a1052 1
		    DEVNAME(sc), flags, pkt->tp_m->m_pkthdr.len, pkt->tp_id);
@


1.69
log
@put a two second timeout on the chip init after the firmware is loaded
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.68 2007/04/25 08:10:27 dlg Exp $ */
d908 1
a908 1
	tht_write(sc, THT_REG_10G_PAUSE, 0x92);
d920 2
@


1.68
log
@shift some bits like the spec says i should.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.67 2007/04/25 05:47:14 dlg Exp $ */
d575 1
d1550 2
d1578 8
a1585 1
	while (tht_read(sc, THT_REG_INIT_STATUS)) {
d1589 1
d1591 1
a1591 1
	error = 0;
d1596 8
@


1.67
log
@format string fix
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.66 2007/04/25 05:46:03 dlg Exp $ */
d136 1
a136 1
#define  THT_REG_10G_SEC_EMPTY(_t)	(_t) /* section empty avail */
d140 1
a140 1
#define  THT_REG_10G_FIFO_AF(_t)	(_t) /* almost full */
@


1.66
log
@add some debug to the tx paths so i can see packets go on and off the hw.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.65 2007/04/25 05:40:57 dlg Exp $ */
d818 1
a818 1
	DPRINTF(THT_D_INTR, "%s: isr: 0x%0b\n", DEVNAME(sc), isr, THT_FMT_ISR);
@


1.65
log
@fix the conditions that the tx free path keeps looping on so that it will
process all available descriptors, instead of leaving one behind.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.64 2007/04/25 05:38:12 dlg Exp $ */
d997 1
d1043 2
a1044 1
		txt.flags = htole32(THT_TXT_TYPE | LWORDS(bc)); /* XXX */
d1048 3
d1122 2
@


1.64
log
@configure the 10G mac and enable (more) interrupts when the interface is
brought up. mask them again when the interface goes down.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.63 2007/04/25 05:09:47 dlg Exp $ */
d1110 1
a1110 1
	if (tht_fifo_readable(sc, &sc->sc_txf) <= sizeof(txf))
d1129 1
a1129 1
	} while (sc->sc_txf.tf_ready > sizeof(txf));
@


1.63
log
@split tht_fifo_ready into tht_fifo_writable and tht_fifo_readable. the way
you determine usable space in the fifo is different between read and write
fifos, not half different like i thought it was.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.62 2007/04/25 04:58:08 dlg Exp $ */
d118 13
d135 2
d139 2
d906 25
d938 2
d973 3
@


1.62
log
@start implementing interrupt handling.

the firmware generates an interrupt when it detects a link state change,
so we dont have to poll for it like other nics do. this sets it up so the
interrupt is handled even if the nic is down at the time.

you can plug and unplug the cable now and see pretty dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.61 2007/04/25 04:23:05 dlg Exp $ */
d537 3
a539 1
size_t			tht_fifo_ready(struct tht_softc *,
d926 2
a927 2
	while (tht_fifo_ready(sc, &sc->sc_txt) < sc->sc_txt.tf_len &&
	    tht_fifo_ready(sc, &sc->sc_txf) < sc->sc_txf.tf_len)
d960 1
a960 1
	if (tht_fifo_ready(sc, &sc->sc_txt) <= THT_FIFO_DESC_LEN)
d1063 1
a1063 1
	if (tht_fifo_ready(sc, &sc->sc_txf) <= sizeof(txf))
d1099 1
a1099 1
	if (tht_fifo_ready(sc, &sc->sc_rxf) <= THT_FIFO_DESC_LEN)
d1181 1
a1181 1
	if (tht_fifo_ready(sc, &sc->sc_rxd) < sizeof(rxd))
d1289 1
a1289 1
tht_fifo_ready(struct tht_softc *sc, struct tht_fifo *tf)
d1291 8
a1298 9
	if (tf->tf_desc->tfd_write) {
		tf->tf_rptr = tht_read(sc, tf->tf_desc->tfd_rptr);
		tf->tf_rptr &= THT_FIFO_PTR_MASK;
		tf->tf_ready = tf->tf_rptr - tf->tf_wptr;
	} else {
		tf->tf_wptr = tht_read(sc, tf->tf_desc->tfd_wptr);
		tf->tf_wptr &= THT_FIFO_PTR_MASK;
		tf->tf_ready = tf->tf_wptr - tf->tf_rptr;
	}
d1300 6
d1507 1
a1507 1
		while (tht_fifo_ready(sc, &sc->sc_txt) <= THT_FIFO_GAP) {
@


1.61
log
@add more register definitions, in particular the interrupt ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.60 2007/04/25 04:18:05 dlg Exp $ */
d244 3
d449 1
d468 2
d716 2
d721 1
a721 1
	    THT_PORT_REGION(taa->taa_port), THT_PORT_SIZE,
d782 3
d790 16
a805 1
	return (0);
@


1.60
log
@im an idiot. for (;;) { } while (condition); loops forever, no matter what
the condition is.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.59 2007/04/25 04:16:44 dlg Exp $ */
d106 4
d111 3
d139 23
d164 13
d194 5
a198 5
#define  THT_REG_RX_FLT_ATXER		(1<<15)
#define  THT_REG_RX_FLT_ATRM		(1<<14)
#define  THT_REG_RX_FLT_AFTSQ		(1<<13)
#define  THT_REG_RX_FLT_OSEN		(1<<12)
#define  THT_REG_RX_FLT_APHER		(1<<11)
d214 6
@


1.59
log
@add some debug goo to be used soon
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.58 2007/04/24 08:08:49 dlg Exp $ */
d991 1
a991 1
	for (;;) {
@


1.58
log
@use the fifos ready byte counter in the firmware loading.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.57 2007/04/23 11:32:44 dlg Exp $ */
d59 15
@


1.57
log
@increment opackets and ipackets. clear OACTIVE when tx completes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.56 2007/04/23 11:27:32 dlg Exp $ */
d1410 1
a1410 2
		while ((wrlen = tht_fifo_ready(sc, &sc->sc_txt)) <=
		    THT_FIFO_GAP) {
d1415 1
a1415 1
		wrlen = MIN(wrlen, fwlen);
@


1.56
log
@spelling in comment fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.55 2007/04/23 11:24:07 dlg Exp $ */
d914 2
d965 1
d992 2
d1129 2
@


1.55
log
@when we use a fifo we always seem to need to know how much of the fifo is
ready to be used, and we need to decrement that "ready" count as we go over
the fifo. this diff moves that ready counter into the tht_fifo struct.

the ready value is calculated when we read the fifo pointers off the
hardware, and decremented by fifo_read or fifo_write as we work through it.
each of the loops over the fifos checks it directly to see if there's
anything left to work on.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.54 2007/04/23 09:59:01 dlg Exp $ */
d893 1
a893 1
		/* though shalt not use m after this point, only pkt->tp_m */
@


1.54
log
@replace the code in the rxf and txt fifo handlers that loads the dma
descriptors and adds the pad with tht_write_dmap and tht_write_pad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.52 2007/04/22 13:14:11 dlg Exp $ */
d361 1
d914 1
a914 1
	} while (tht_fifo_ready(sc, &sc->sc_txt) <= THT_FIFO_DESC_LEN);
a966 1
	int				ready;
d968 1
a968 2
	ready = sc->sc_txf.tf_len - tht_fifo_ready(sc, &sc->sc_txf);
	if (ready == 0)
a974 1
		ready -= sizeof(txf);
d986 2
a987 1
	} while (ready > 0);
d1040 1
a1040 1
		if (tht_fifo_ready(sc, &sc->sc_rxf) <= THT_FIFO_DESC_LEN)
d1081 1
a1081 1
	int				ready, bc;
d1084 1
a1084 2
	ready = sc->sc_rxd.tf_len - tht_fifo_ready(sc, &sc->sc_rxd);
	if (ready == 0)
a1090 1
		ready -= sizeof(rxd);
a1121 1
			ready -= sizeof(pad);
d1125 1
a1125 1
	} while (ready > 0);
a1191 2
	int				ready;

d1195 1
a1195 1
		ready = tf->tf_rptr - tf->tf_wptr;
d1199 1
a1199 1
		ready = tf->tf_wptr - tf->tf_rptr;
d1202 2
a1203 2
	if (ready <= 0)
		ready += tf->tf_len;
d1205 1
a1205 1
	return (ready);
d1223 2
d1247 2
@


1.53
log
@add tht_write_dmap, and tht_write_pad.

tht_write_dmap will walk a loaded bus_dmamap_t and write the appropriate
pbd's to the fifo.

tht_write_pad will take the length of the whole descriptor and add a 4 byte
pad to the descriptor if necessary.
@
text
@a856 4
	struct tht_pbd			pbd;
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	bus_dmamap_t			dmap;
	int				ready;
a857 1
	u_int64_t			dva;
a858 1
	int				i;
d867 1
a867 2
	ready = tht_fifo_ready(sc, &sc->sc_txt);
	if (ready <= THT_FIFO_DESC_LEN)
d874 1
a874 1
	for (;;) {
d877 1
a877 1
			goto done;
d882 1
a882 1
			goto done;
d888 1
d890 1
a890 1
			goto free_pkt;
d892 1
a892 1
		/* though shalt not use m after tht_load_pkt */
d899 2
a900 3
		dmap = pkt->tp_dmap;

		bc = sizeof(txt) + sizeof(pbd) * dmap->dm_nsegs;
d907 2
d910 2
a911 6
		for (i = 0; i < dmap->dm_nsegs; i++) {
			dva = dmap->dm_segs[i].ds_addr;

			pbd.addr_lo = htole32(dva);
			pbd.addr_hi = htole32(dva >> 32);
			pbd.len = htole32(dmap->dm_segs[i].ds_len);
d913 1
a913 10
			tht_fifo_write(sc, &sc->sc_txt, &pbd, sizeof(pbd));
			ready -= sizeof(pbd);
		}

		if (bc & 0x7) {
			const static u_int32_t pad = 0x0;
			tht_fifo_write(sc, &sc->sc_txt, (void *)&pad,
			    sizeof(pad));
			ready -= sizeof(pad);
		}
a914 10
		bus_dmamap_sync(dmat, dmap, 0, dmap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

		if (ready <= THT_FIFO_DESC_LEN)
			goto done;
	}

free_pkt:
	tht_pkt_put(&sc->sc_rx_list, pkt);
done:
a998 1
	struct tht_pbd			pbd;
a1000 1
	u_int64_t			dva;
a1001 1
	int				i;
d1027 2
a1028 1
		bc = sizeof(rxf) + sizeof(pbd) * dmap->dm_nsegs;
d1035 2
a1036 16

		for (i = 0; i < dmap->dm_nsegs; i++) {
			dva = dmap->dm_segs[i].ds_addr;

			pbd.addr_lo = htole32(dva);
			pbd.addr_hi = htole32(dva >> 32);
			pbd.len = htole32(dmap->dm_segs[i].ds_len);

			tht_fifo_write(sc, &sc->sc_rxf, &pbd, sizeof(pbd));
		}

		if (bc & 0x7) {
			const static u_int32_t pad = 0x0;
			tht_fifo_write(sc, &sc->sc_rxf, (void *)&pad,
			    sizeof(pad));
		}
@


1.52
log
@process the tx free queue. this indicates when transmitted packets have
been completed. it's the simplest fifo of the lot, im sorry i didnt start
with it.

this is the last of the fifos we have to deal with. now we need an
interrupt handler, but i wont be doing that till i get my cable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.51 2007/04/22 09:25:14 dlg Exp $ */
d474 4
d1309 29
@


1.51
log
@this is the start of the transmit path. this takes packets off the
interface send queue and puts them on the hardwares tx task fifo. the tx
completion path hasnt been written yet.

the mbuf dmamap loading has been stolen from vic.

there's obviously a lot of code that is shared between the rxf fifo loading
and the txt fifo loading. i also have to think about how to better
calculate and keep track of space in the fifos.

this is getting harder and harder. it sucks writing tons of code without
being able to verify that it works. i might take a break for a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.50 2007/04/22 05:21:33 dlg Exp $ */
d489 1
d981 34
@


1.50
log
@only printf if the firmware load failed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.49 2007/04/22 04:59:07 dlg Exp $ */
d264 10
d281 1
d487 2
d849 131
a979 1
	/* do nothing */
@


1.49
log
@hookup bpf. this pushes packets along bpf on the rx side. i need to write
tx now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.48 2007/04/22 04:38:31 dlg Exp $ */
d685 2
a686 2
	printf("%s: firmware load %s\n", DEVNAME(sc),
	    (tht_fw_load(sc) == 0) ? "succeeded" : "failed");
@


1.48
log
@start implementing processing of the rx descriptor fifo. this is the one
that returns rx buffers to us that we previously posted in the rx free.
theoretically we should now be receiving packets.

practically, im still waiting on a cable so i can plug this card into
something and test it, and then that's going to be difficult cos i only
have two tht cards to test it. i need tx and rx working before i can test
if tx and rx work. fun fun fun.

this code doesnt process rx data change descriptors yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.45 2007/04/21 14:48:24 dlg Exp $ */
d27 2
d52 4
d973 5
@


1.47
log
@i seem to be having lots of trouble with writing bus_dmamap_sync calls
properly these days.

when draining the rxf fifo we want to POSTREAD the mbuf, not PREREAD it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.46 2007/04/22 04:21:25 dlg Exp $ */
d473 1
a832 1

d836 2
a839 2
	bus_dma_tag_t			dmat = sc->sc_thtc->sc_dmat;
	bus_dmamap_t			dmap;
d927 56
@


1.46
log
@macros for accessing bits of the rx descriptors
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.45 2007/04/21 14:48:24 dlg Exp $ */
d920 1
a920 1
		BUS_DMASYNC_PREREAD);
@


1.45
log
@fill the rx free fifo on interface up, and drain it on interface down.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.43 2007/04/21 13:58:38 dlg Exp $ */
d202 19
d223 3
d229 1
d240 1
d253 1
@


1.44
log
@tht wants at least 128 bytes in the first physical segment of an rx buffer
for some reason, so i had some code in there that tried to guarantee that.
however, newly allocated mbufs and clusters are physically contiguous and
bigger than 128 bytes. therefore we dont need to do that check.

while here check if there is enough space in the fifo before trying to
fill any of it. this means we can skip dma syncs if we're not going to end
up writing anything in the fifo.
@
text
@d747 1
d795 1
@


1.43
log
@rename tht_rx to tht_rxf_fill to avoid confusion.

keep a list of used pkts in tht_pkt_list as well as free ones. add
tht_pkt_used which can be used to see if a tht_pkt_list is in use by
returning the head of the used list inside itself.

(ab)use this to drain the rx free fifo when the interface is brought down.
tht_rxf_drain pulls used pkts off, unmaps their mbufs, frees them, and then
returns the pkt to the free list. the whole tht_pkt_list can then be freed
safely.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.42 2007/04/21 13:10:51 dlg Exp $ */
d819 3
d825 1
a825 2
		if ((tht_fifo_ready(sc, &sc->sc_rxf) <= THT_FIFO_DESC_LEN) ||
		    (pkt = tht_pkt_get(&sc->sc_rx_list)) == NULL)
a827 1
new_m:
a842 6
		if (dmap->dm_segs[0].ds_len < THT_RXF_1ST_PDB_LEN) {
			bus_dmamap_unload(dmat, dmap);
			m_freem(m);
			goto new_m;
		}

d869 3
@


1.42
log
@add tht_rx. this function will try to fill as much of the rx free fifo as
possible. it loops till it runs out of tht_pkts to use on the rx descriptor
free list, until it runs out of space in the fifo, or until it cant
allocate or map any more mbufs.

tht has a weird requirement that the first physical buffer in an sg list is
at least 128 bytes long. i have code that tries to guarantee that, but id
like someone else to look at it and tell me if its necessary or dumb.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.41 2007/04/21 12:47:42 dlg Exp $ */
d332 2
a333 1
	TAILQ_HEAD(, tht_pkt)	tpl_list;
d380 1
d445 3
a447 1
void			tht_rx(struct tht_softc *, int);
d807 1
a807 1
tht_rx(struct tht_softc *sc, int wait)
d885 20
d1301 2
a1302 1
	TAILQ_INIT(&tpl->tpl_list);
d1314 1
a1314 1
		tht_pkt_put(tpl, pkt);
d1335 2
a1336 1
	TAILQ_INSERT_TAIL(&tpl->tpl_list, pkt, tp_link);
d1344 6
a1349 3
	pkt = TAILQ_FIRST(&tpl->tpl_list);
	if (pkt != NULL)
		TAILQ_REMOVE(&tpl->tpl_list, pkt, tp_link);
d1352 6
@


1.41
log
@simplify some maths in fw_load a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.40 2007/04/21 12:40:42 dlg Exp $ */
d441 1
d443 1
a443 1
void			tht_watchdog(struct ifnet *);
d799 79
@


1.40
log
@allocate a small list of tx and rx descriptors on interface up and down.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.39 2007/04/21 12:36:06 dlg Exp $ */
d1042 2
a1043 2
		while ((wrlen = tht_fifo_ready(sc, &sc->sc_txt) -
		    THT_FIFO_GAP) <= 0) {
@


1.39
log
@quick macro to figure out how many 64bit words a buffer will use.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.38 2007/04/21 12:32:32 dlg Exp $ */
d348 3
d727 5
d733 1
a733 1
		return;
d741 2
d758 5
d787 5
@


1.38
log
@create struct tht_pkt to keep track of mbufs that are on the hardware and
their dmamaps. so far it looks like the same thing can be used to look
after both the transmitted and recved packets.

this also adds code to allocate a list of them and set up their dmamaps,
some free list handling, and code to free them when you dont want them
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.37 2007/04/21 12:25:42 dlg Exp $ */
d473 2
@


1.37
log
@represent the uid field in all the descriptors as a u_int64_t instead of
two u_int32_ts
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.36 2007/04/21 12:22:57 dlg Exp $ */
d321 14
d369 8
d1161 60
@


1.36
log
@rename tht_rxf to tht_rx_free. tweak comments describing the hw structures
a bit so theyre less offensive to my eyes. massage tht_rx_free a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.35 2007/04/20 13:59:34 dlg Exp $ */
d205 1
a205 2
	u_int32_t		uid_lo;
	u_int32_t		uid_hi;
d236 1
a236 2
	u_int32_t		uid_lo;
	u_int32_t		uid_hi;
d248 1
a248 2
	u_int32_t		uid_lo;
	u_int32_t		uid_hi;
@


1.35
log
@add a lock around ioctl handling to prevent the posssibility that someone
will try to bring the interface up in the middle of it being brought down.
im sleeping in tht_down while waiting for the tx fifos to drain, so its
possible something else can enter the ioctl handler while that's happening.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.34 2007/04/20 13:46:40 dlg Exp $ */
d172 2
d182 1
d185 3
a187 2
struct tht_rxf {
	u_int32_t		flags;
d189 1
a189 2
	u_int32_t		uid_lo;
	u_int32_t		uid_hi;
d193 5
d219 1
a219 1
/* rx descriptor type 4: rss information */
d231 1
a231 1
/* TX_TASK FIFO */
d242 3
d246 1
a246 1
/* TX_FREE FIFO */
@


1.34
log
@this implements up and down routines for the interface. currently when
brought up they allocate all four fifos and set the interface flags. when
theyre brought down they clear the flags, wait for the tx fifos to drain,
and then free all the fifos.

interrupts are not yet dealt with.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.33 2007/04/20 07:10:56 dlg Exp $ */
d37 1
d330 2
d555 1
d636 1
d640 2
a641 4
	if (error > 0) {
		splx(s);
		return (error);
	}
d675 1
d677 1
@


1.33
log
@implement reads from a fifo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.32 2007/04/20 05:14:32 dlg Exp $ */
d408 3
d612 2
a614 2

	tht_sw_reset(sc);
d628 1
d641 22
d675 60
@


1.32
log
@add fifo descriptors for the rxf and rxd fifos.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.31 2007/04/20 02:24:28 dlg Exp $ */
d390 2
d742 23
@


1.31
log
@we'd like to show if the nic has link regardless of whether the interface
is up or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.30 2007/04/20 01:38:32 dlg Exp $ */
d353 18
@


1.30
log
@implement checking of the link status according to the firmware, and teach
ifmedia about it.

im not sure what the point of the ifmedia goo is if the only link type we
support is "autoselect". using it to show the link state seems to be
easier than implementing that ioctl ourselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.29 2007/04/20 00:41:32 dlg Exp $ */
d660 1
a660 1
	if (LINK_STATE_IS_UP(ifp->if_link_state) && ifp->if_flags & IFF_UP)
@


1.29
log
@bits in the link status register
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.28 2007/04/19 14:07:08 dlg Exp $ */
d381 1
a620 1

d653 2
d658 4
a661 1
	/* TODO: check link state */
d881 15
@


1.28
log
@this is two (and a half) changes, but im too lazy to split them up.

the first is the addition of handlers for the fifos. you can now check if
there the fifo is ready to be used, pre sync it for use, do many
incremental updates to it, then post sync it to tell the hardware that
you've done something. the ready, pre, and post funcs are done for both
the reader and writer fifos, but only updates to the writer fifos is
implemented so far.

the second change is the firmware loading. i needed the above changes to do
this, and i needed firmware loading to test them, so this change gets both.
so we have a mountroot hook (that was the half change) that allocates the
tx task fifo, reads the firmware from disk, and then pushes the firmware
onto the fifo. once that is done it spins till the firmware is ready, then
cleans up everything it allocated for loading the firmware.

this diff wont time out if anything goes wrong during fw_load. if anyone
wants to look at a nice way of doing it, please do.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.25 2007/04/18 11:19:35 dlg Exp $ */
d104 4
@


1.27
log
@start implementing support for the fifos on these chips.

there are four types of fifos: a tx task fifo (packets get sent via this),
a tx free fifo (for us to know when packets have been sent), a rx
descriptor fifo (to give empty packets for the nic to fill), and an rx free
fifo (when packets are recieved).

each port can have four sets of these fifos, so you can effectively have
completely independant io paths. however, due to the nature of our kernel
there is no advantage in implementing the use of more than one set of
these.

so this diff creates wrappers around fifos, the allocation of the dma
regions for them, and a description of which registers are used to manage
them.
@
text
@d164 2
d274 25
a298 1
struct tht_dmamem;
d301 1
d303 3
d321 4
a324 4
	struct tht_fifo		sc_txt_fifo;
	struct tht_fifo		sc_rxf_fifo;
	struct tht_fifo		sc_rxd_fifo;
	struct tht_fifo		sc_txf_fifo;
d329 1
a340 7
struct tht_fifo_desc {
	bus_size_t		tfd_cfg0;
	bus_size_t		tfd_cfg1;
	bus_size_t		tfd_rptr;
	bus_size_t		tfd_wptr;
	u_int32_t		tfd_size;
};
d342 1
a342 1
const struct tht_fifo_desc tht_txt_fifo = {
d347 2
a348 1
	THT_FIFO_SIZE_16k
d351 1
a351 1
const struct tht_fifo_desc tht_txf_fifo = {
d356 2
a357 1
	THT_FIFO_SIZE_4k
d361 1
a361 1
			    const struct tht_fifo_desc *);
d364 9
d376 1
a387 10
struct tht_dmamem {
	bus_dmamap_t		tdm_map;
	bus_dma_segment_t	tdm_seg;
	size_t			tdm_size;
	caddr_t			tdm_kva;
};
#define THT_DMA_MAP(_tdm)	((_tdm)->tdm_map)
#define THT_DMA_DVA(_tdm)	((_tdm)->tdm_map->dm_segs[0].ds_addr)
#define THT_DMA_KVA(_tdm)	((void *)(_tdm)->tdm_kva)

d569 18
d657 1
a657 1
    const struct tht_fifo_desc *tfd)
a658 1
	bus_size_t			size;
d661 2
a662 2
	size = THT_FIFO_SIZE(tfd->tfd_size);
	tf->tf_mem = tht_dmamem_alloc(sc, size, THT_FIFO_ALIGN);
d666 6
d682 2
d687 62
d830 42
@


1.26
log
@move the tht attach args up a bit, for greater feng shui
@
text
@d158 7
d271 1
a271 1
/* port autoconf glue */
d274 4
d290 5
d309 29
d609 25
@


1.25
log
@add a wrapper around single segment dmaable memory allocations. this has
now been copied from ami into mpi, arc, vic, ahci, sili, and mfi. ive
probably forgotten some others too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.24 2007/04/18 07:17:44 dlg Exp $ */
d255 8
a290 9
};

/* glue between the controller and the port */

struct tht_attach_args {
	int			taa_port;

	struct pci_attach_args	*taa_pa;
	pci_intr_handle_t	taa_ih;
@


1.24
log
@callers of sw_reset will print an error message if anythign goes wrong, so
sw_reset itself doesnt have to
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.23 2007/04/18 07:13:11 dlg Exp $ */
d255 1
d257 1
d307 16
d694 55
@


1.23
log
@reset the port before establishing the interrupt handler during attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.22 2007/04/18 07:00:11 dlg Exp $ */
d581 1
a581 2
	if (!tht_wait_set(sc, THT_REG_RST_PRT, THT_REG_RST_PRT_ACTIVE, 1000)) {
		printf("%s: port reset didnt become active\n", DEVNAME(sc));
a582 1
	}
@


1.22
log
@implement the software reset of a port as per the specification
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.21 2007/04/18 06:57:14 dlg Exp $ */
d441 6
@


1.21
log
@code to busy wait on registers and bits in bus_space
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.20 2007/04/18 06:54:32 dlg Exp $ */
d293 4
d300 2
a303 1
void			tht_read_lladdr(struct tht_softc *);
d553 73
@


1.20
log
@tiny register additions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.19 2007/04/18 02:12:30 dlg Exp $ */
d303 12
d564 30
@


1.19
log
@define the bits in the RX_FLT register
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.18 2007/04/17 14:07:15 dlg Exp $ */
d147 1
d156 1
d177 1
a177 1
/* rx descriptor type 2 */
@


1.18
log
@lots of registers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.17 2007/04/17 10:34:54 dlg Exp $ */
d125 16
@


1.17
log
@start defining the hardware structures
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.16 2007/04/17 02:15:13 dlg Exp $ */
d58 78
a135 18
#define THT_REG_10G_REV		0x6000
#define THT_REG_10G_SCR		0x6004
#define THT_REG_10G_CTL		0x6008
#define THT_REG_10G_FMT_LNG	0x6014
#define THT_REG_10G_PAUSE	0x6018
#define THT_REG_10G_RX_SEC	0x601c
#define THT_REG_10G_TX_SEC	0x6020
#define THT_REG_10G_RFIFO_AEF	0x6024
#define THT_REG_10G_TFIFO_AEF	0x6028
#define THT_REG_10G_SM_STAT	0x6030
#define THT_REG_10G_SM_CMD	0x6034
#define THT_REG_10G_SM_DAT	0x6038
#define THT_REG_10G_SM_ADD	0x603c
#define THT_REG_10G_STAT	0x6040

#define THT_REG_RG_RX_UNC_MAC0	0x1250
#define THT_REG_RG_RX_UNC_MAC1	0x1260
#define THT_REG_RG_RX_UNC_MAC2	0x1270
d512 1
a512 3
	    THT_REG_RG_RX_UNC_MAC2,
	    THT_REG_RG_RX_UNC_MAC1,
	    THT_REG_RG_RX_UNC_MAC0
@


1.16
log
@add some ifmedia goop.

it looks like the firmware used to have an interface for figuring out what
the device was plugged into, and what it had negotiated, but the newer fw
just has a bit saying "link up" or "link down".

so all we will use the ifmedia stuff for is to show if the link is up or
down.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.15 2007/04/17 01:28:14 dlg Exp $ */
d79 73
@


1.15
log
@initial bits for the network interface glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.14 2007/04/16 22:17:54 dlg Exp $ */
d115 1
d145 2
d299 4
d319 1
d331 11
d344 1
a344 1
	return (ENOTTY);
d357 16
@


1.14
log
@do some byteswapping to make the mac address look more believable. i dont
know if this will work on big endian machines but its should be trivial
to fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.13 2007/04/16 15:14:38 dlg Exp $ */
d46 2
d141 3
d262 1
d284 15
d306 32
@


1.13
log
@read the mac address off the port. i hope its the right way round.

sleep time for me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.12 2007/04/16 14:40:18 dlg Exp $ */
d290 9
a298 3
	sc->sc_lladdr[0] = tht_read(sc, THT_REG_RG_RX_UNC_MAC2);
	sc->sc_lladdr[1] = tht_read(sc, THT_REG_RG_RX_UNC_MAC1);
	sc->sc_lladdr[2] = tht_read(sc, THT_REG_RG_RX_UNC_MAC0);
@


1.12
log
@add wrappers around bus space ops for each port
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.11 2007/04/16 14:35:07 dlg Exp $ */
d29 2
a30 1
#include <sys/buf.h>
d32 1
d44 8
d71 4
d111 4
d138 3
d275 4
a278 1
	printf("\n");
d285 8
@


1.11
log
@add a point from tht_softc back to thtc_softc so we can use thtc's bus
space bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.10 2007/04/16 14:33:35 dlg Exp $ */
d120 4
d261 16
@


1.10
log
@sigh, move tht autoconf stuff after thtc autoconf stuff. it will work
better this way
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.9 2007/04/16 14:32:19 dlg Exp $ */
d92 1
d232 2
@


1.9
log
@create a register window for each port.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.8 2007/04/16 14:17:32 dlg Exp $ */
d64 1
a64 1
/* port autoconf glue */
d66 1
a66 1
struct tht_softc {
d69 1
a69 1
	void			*sc_ih;
d71 1
d73 1
d76 3
a78 3
int			tht_match(struct device *, void *, void *);
void			tht_attach(struct device *, struct device *, void *);
int			tht_intr(void *);
d80 2
a81 2
struct cfattach tht_ca = {
	sizeof(struct tht_softc), tht_match, tht_attach
d84 2
a85 2
struct cfdriver tht_cd = {
	NULL, "tht", DV_IFNET
d88 1
a88 1
/* pci controller autoconf glue */
d90 1
a90 1
struct thtc_softc {
d93 1
a93 1
	bus_dma_tag_t		sc_dmat;
a94 1
	bus_space_tag_t		sc_memt;
a95 1
	bus_size_t		sc_mems;
d98 3
a100 3
int			thtc_match(struct device *, void *, void *);
void			thtc_attach(struct device *, struct device *, void *);
int			thtc_print(void *, const char *);
d102 2
a103 2
struct cfattach thtc_ca = {
	sizeof(struct thtc_softc), thtc_match, thtc_attach
d106 2
a107 2
struct cfdriver thtc_cd = {
	NULL, "thtc", DV_DULL
@


1.8
log
@move handling interrupts from thtc into separate handlers for each port.
this means that the pci interrupt handling code iterates over our ports,
not our driver, and counts the work they do separately.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.7 2007/04/16 14:01:26 dlg Exp $ */
d61 3
d70 2
d228 1
d232 7
d243 1
@


1.7
log
@move the tht autoconf glue before the thtc autoconf glue
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.6 2007/04/16 13:30:45 dlg Exp $ */
d64 3
a66 1
	struct device		csc_dev;
d71 1
a85 2
	void			*sc_ih;

d109 3
a114 2
int			thtc_intr(void *);

a164 2
	pci_intr_handle_t		ih;
	const char			*intrstr;
d169 1
d181 1
a181 1
	if (pci_intr_map(pa, &ih) != 0) {
d185 1
a185 10
	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_NET,
	    thtc_intr, sc, DEVNAME(sc));
	if (sc->sc_ih == NULL) {
		printf(": unable to map interrupt%s%s\n",
		    intrstr == NULL ? "" : " at ",
		    intrstr == NULL ? "" : intrstr);
		goto unmap;
	}
	printf(": %s\n", intrstr);
d187 1
d189 1
a189 1
		bzero(&taa, sizeof(taa));
a190 1
		taa.taa_port = i;
d223 10
d237 1
a237 1
thtc_intr(void *arg)
@


1.6
log
@add the glue to attach tht at thtc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.5 2007/04/16 12:13:16 dlg Exp $ */
d61 17
d104 1
a104 1
/* port autoconf glue */
d110 1
a110 16
struct tht_softc {
	struct device		csc_dev;
};

int			tht_match(struct device *, void *, void *);
void			tht_attach(struct device *, struct device *, void *);

struct cfattach tht_ca = {
	sizeof(struct tht_softc), tht_match, tht_attach
};

struct cfdriver tht_cd = {
	NULL, "tht", DV_IFNET
};

/* misc goo */
@


1.5
log
@different chips have a different number of ports, so map pci ids to the
number of ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.4 2007/04/16 11:34:35 dlg Exp $ */
d77 1
d89 4
d163 5
d193 7
d208 13
d223 1
a223 1
	return (0);
a236 1

@


1.4
log
@start at defining the regs. this is the 10g stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.3 2007/04/16 11:07:23 reyk Exp $ */
d109 4
a112 4
static const struct pci_matchid thtc_devices[] = {
	{ PCI_VENDOR_TEHUTI,	PCI_PRODUCT_TEHUTI_TN3009 },
	{ PCI_VENDOR_TEHUTI,	PCI_PRODUCT_TEHUTI_TN3010 },
	{ PCI_VENDOR_TEHUTI,	PCI_PRODUCT_TEHUTI_TN3014 }
d115 24
d144 4
a147 1
	return (pci_matchbyid(pa, thtc_devices, sizeofa(thtc_devices)));
@


1.3
log
@Add a note that work on this driver is possible because Tehuti
Networks donated us hardware and provided documentation. Thanks!

"go for it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.2 2007/04/16 10:53:51 dlg Exp $ */
d45 15
@


1.2
log
@map the host registers and establish the interrupt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tht.c,v 1.1 2007/04/16 10:35:29 dlg Exp $ */
d17 8
@


1.1
log
@this is a start at a driver for the tehuti networks 10Gb ethernet cards.
dual port cards appear as only one pci device, so we attach the controller
to pci (thtc at pci) and each port as a separate device (tht at thtc).

this only attaches thtc so far.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d34 4
d41 1
a41 1
	struct device		csc_dev;
d44 6
d81 1
d103 35
a137 1
	printf("\n");
d151 7
@

