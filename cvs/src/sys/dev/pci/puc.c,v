head	1.24;
access;
symbols
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.10
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.8
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.10
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.8
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.4
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.8.0.14
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.12
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.10
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.2;
locks; strict;
comment	@ * @;


1.24
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.23;
commitid	p4LJxGKbi0BU2cG6;

1.23
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.06.12.18.43.26;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2012.05.15.20.30.05;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.15.22.27.53;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.25.20.02.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.06.21.04.14;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.22.17.16.10;	author pirofti;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.07.21.32.50;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.02.01.07.20;	author pirofti;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.03.16.52.25;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.04.21.49.35;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.26.01.31.05;	author gwk;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.28.20.52.36;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.01.20.10.29;	author jolan;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.31.11.06.33;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.28.15.14.08;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.11.18.44.23;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.25.10.13.30;	author art;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.06.12.15.40.33;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.15.17.52.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.11.14.01.27.57;	author downsj;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.10.26.13.06.14;	author downsj;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.14.22.25.56;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.07.04.10.43.02;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.10.31.03.22.47;	author nate;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.05.19.22.19.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: puc.c,v 1.23 2013/05/30 16:15:02 deraadt Exp $	*/
/*	$NetBSD: puc.c,v 1.3 1999/02/06 06:29:54 cgd Exp $	*/

/*
 * Copyright (c) 1996, 1998, 1999
 *	Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI "universal" communication card device driver, glues com, lpt,
 * and similar ports to PCI via bridge chip often much larger than
 * the devices being glued.
 *
 * Author: Christopher G. Demetriou, May 14, 1998 (derived from NetBSD
 * sys/dev/pci/pciide.c, revision 1.6).
 *
 * These devices could be (and some times are) described as
 * communications/{serial,parallel}, etc. devices with known
 * programming interfaces, but those programming interfaces (in
 * particular the BAR assignments for devices, etc.) in fact are not
 * particularly well defined.
 *
 * After I/we have seen more of these devices, it may be possible
 * to generalize some of these bits.  In particular, devices which
 * describe themselves as communications/serial/16[45]50, and
 * communications/parallel/??? might be attached via direct
 * 'com' and 'lpt' attachments to pci.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/tty.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pucvar.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>

struct puc_pci_softc {
	struct puc_softc	sc_psc;

	pci_chipset_tag_t	pc;
	pci_intr_handle_t	ih;
};

int	puc_pci_match(struct device *, void *, void *);
void	puc_pci_attach(struct device *, struct device *, void *);
int	puc_pci_detach(struct device *, int);
const char *puc_pci_intr_string(struct puc_attach_args *);
void	*puc_pci_intr_establish(struct puc_attach_args *, int,
    int (*)(void *), void *, char *);

struct cfattach puc_pci_ca = {
	sizeof(struct puc_pci_softc), puc_pci_match,
	puc_pci_attach, puc_pci_detach
};

struct cfdriver puc_cd = {
	NULL, "puc", DV_DULL
};

const char *puc_port_type_name(int);

int
puc_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	const struct puc_device_description *desc;
	pcireg_t bhlc, subsys;

	bhlc = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	if (PCI_HDRTYPE_TYPE(bhlc) != 0)
		return (0);

	subsys = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

	desc = puc_find_description(PCI_VENDOR(pa->pa_id),
	    PCI_PRODUCT(pa->pa_id), PCI_VENDOR(subsys), PCI_PRODUCT(subsys));
	if (desc != NULL)
		return (1);

	return (0);
}

const char *
puc_pci_intr_string(struct puc_attach_args *paa)
{
	struct puc_pci_softc *sc = paa->puc;

	return (pci_intr_string(sc->pc, sc->ih));
}

void *
puc_pci_intr_establish(struct puc_attach_args *paa, int type,
    int (*func)(void *), void *arg, char *name)
{
	struct puc_pci_softc *sc = paa->puc;
	struct puc_softc *psc = &sc->sc_psc;
	
	psc->sc_ports[paa->port].intrhand =
	    pci_intr_establish(sc->pc, sc->ih, type, func, arg, name);

	return (psc->sc_ports[paa->port].intrhand);
}

void
puc_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct puc_pci_softc *psc = (struct puc_pci_softc *)self;
	struct puc_softc *sc = &psc->sc_psc;
	struct pci_attach_args *pa = aux;
	struct puc_attach_args paa;
	pcireg_t subsys;
	int i;

	subsys = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	sc->sc_desc = puc_find_description(PCI_VENDOR(pa->pa_id),
	    PCI_PRODUCT(pa->pa_id), PCI_VENDOR(subsys), PCI_PRODUCT(subsys));

	puc_print_ports(sc->sc_desc);

	for (i = 0; i < PUC_NBARS; i++) {
		pcireg_t type;
		int bar;

		sc->sc_bar_mappings[i].mapped = 0;
		bar = PCI_MAPREG_START + 4 * i;
		if (!pci_mapreg_probe(pa->pa_pc, pa->pa_tag, bar, &type))
			continue;

		sc->sc_bar_mappings[i].mapped = (pci_mapreg_map(pa, bar, type,
		    0, &sc->sc_bar_mappings[i].t, &sc->sc_bar_mappings[i].h,
		    &sc->sc_bar_mappings[i].a, &sc->sc_bar_mappings[i].s, 0)
		      == 0);
		if (sc->sc_bar_mappings[i].mapped)
			continue;

		/*
		 * If a port on this card is used as serial console,
		 * mapping the associated BAR will fail because the
		 * bus space is already mapped.  In that case, we try
		 * to re-use the already existing mapping.
		 * Unfortunately this means that if a BAR is used to
		 * support multiple ports, only the first port will
		 * work.
		 */
		if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, bar, type,
		    &sc->sc_bar_mappings[i].a, NULL, NULL) == 0 &&
		    pa->pa_iot == comconsiot &&
		    sc->sc_bar_mappings[i].a == comconsaddr) {
			sc->sc_bar_mappings[i].t = comconsiot;
			sc->sc_bar_mappings[i].h = comconsioh;
			sc->sc_bar_mappings[i].s = COM_NPORTS;
			sc->sc_bar_mappings[i].mapped = 1;
			continue;
		}

		printf("%s: couldn't map BAR at offset 0x%lx\n",
		    sc->sc_dev.dv_xname, (long)bar);
	}

	/* Map interrupt. */
	psc->pc = pa->pa_pc;
	if (pci_intr_map(pa, &psc->ih)) {
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
		return;
	}

	paa.puc = sc;
	paa.intr_string = &puc_pci_intr_string;
	paa.intr_establish = &puc_pci_intr_establish;

	puc_common_attach(sc, &paa);
}

void
puc_common_attach(struct puc_softc *sc, struct puc_attach_args *paa)
{
	const struct puc_device_description *desc = sc->sc_desc;
	int i, bar;

	/* Configure each port. */
	for (i = 0; i < PUC_MAX_PORTS; i++) {
		if (desc->ports[i].type == 0)	/* neither com or lpt */
			continue;
		/* make sure the base address register is mapped */
		bar = PUC_PORT_BAR_INDEX(desc->ports[i].bar);
		if (!sc->sc_bar_mappings[bar].mapped) {
			printf("%s: %s port uses unmapped BAR (0x%x)\n",
			    sc->sc_dev.dv_xname,
			    puc_port_type_name(desc->ports[i].type),
			    desc->ports[i].bar);
			continue;
		}

		/* set up to configure the child device */
		paa->port = i;
		paa->a = sc->sc_bar_mappings[bar].a;
		paa->t = sc->sc_bar_mappings[bar].t;

		paa->type = desc->ports[i].type;

		if (desc->ports[i].offset >= sc->sc_bar_mappings[bar].s ||
		    bus_space_subregion(sc->sc_bar_mappings[bar].t,
		    sc->sc_bar_mappings[bar].h, desc->ports[i].offset,
		    sc->sc_bar_mappings[bar].s - desc->ports[i].offset,
		    &paa->h)) {
			printf("%s: couldn't get subregion for port %d\n",
			    sc->sc_dev.dv_xname, i);
			continue;
		}

#if 0
		if (autoconf_verbose)
			printf("%s: port %d: %s @@ (index %d) 0x%x "
			    "(0x%lx, 0x%lx)\n", sc->sc_dev.dv_xname, paa->port,
			    puc_port_type_name(paa->type), bar, (int)paa->a,
			    (long)paa->t, (long)paa->h);
#endif

		/* and configure it */
		sc->sc_ports[i].dev = config_found_sm(&sc->sc_dev, paa,
		    puc_print, puc_submatch);
	}
}

int
puc_pci_detach(struct device *self, int flags)
{
	struct puc_pci_softc *sc = (struct puc_pci_softc *)self;
	struct puc_softc *psc = &sc->sc_psc;
	int i, rv;

	for (i = PUC_MAX_PORTS; i--; ) {
		if (psc->sc_ports[i].intrhand)
			pci_intr_disestablish(sc->pc,
			    psc->sc_ports[i].intrhand);
		if (psc->sc_ports[i].dev)
			if ((rv = config_detach(psc->sc_ports[i].dev, flags)))
				return (rv);
	}

	for (i = PUC_NBARS; i--; )
		if (psc->sc_bar_mappings[i].mapped)
			bus_space_unmap(psc->sc_bar_mappings[i].t,
			    psc->sc_bar_mappings[i].h,
			    psc->sc_bar_mappings[i].s);

	return (0);
}

int
puc_print(void *aux, const char *pnp)
{
	struct puc_attach_args *paa = aux;

	if (pnp)
		printf("%s at %s", puc_port_type_name(paa->type), pnp);
	printf(" port %d", paa->port);
	return (UNCONF);
}

int
puc_submatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = (struct cfdata *)vcf;
	struct puc_attach_args *aa = aux;

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != aa->port)
		return 0;
	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

const struct puc_device_description *
puc_find_description(u_int16_t vend, u_int16_t prod,
    u_int16_t svend, u_int16_t sprod)
{
	int i;

	for (i = 0; i < puc_ndevs; i++)
		if ((vend & puc_devs[i].rmask[0]) == puc_devs[i].rval[0] &&
		    (prod & puc_devs[i].rmask[1]) == puc_devs[i].rval[1] &&
		    (svend & puc_devs[i].rmask[2]) == puc_devs[i].rval[2] &&
		    (sprod & puc_devs[i].rmask[3]) == puc_devs[i].rval[3])
			return (&puc_devs[i]);

	return (NULL);
}

const char *
puc_port_type_name(int type)
{

	if (PUC_IS_COM(type))
		return "com";
	if (PUC_IS_LPT(type))
		return "lpt";
	return (NULL);
}

void
puc_print_ports(const struct puc_device_description *desc)
{
	int i, ncom, nlpt;

	printf(": ports: ");
	for (i = ncom = nlpt = 0; i < PUC_MAX_PORTS; i++) {
		if (PUC_IS_COM(desc->ports[i].type))
			ncom++;
		else if (PUC_IS_LPT(desc->ports[i].type))
			nlpt++;
	}
	if (ncom)
		printf("%d com", ncom);
	if (nlpt) {
		if (ncom)
			printf(", ");
		printf("%d lpt", nlpt);
	}
	printf("\n");
}
@


1.23
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.22 2012/06/12 18:43:26 kettenis Exp $	*/
a63 2

#include <dev/pci/pcidevs.h>
@


1.22
log
@Explicitly check whether a BAR is big enough for a particular port instead
of relying on bus_space_subregion(9) to fail.  Fixes double console attachment
seen by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.21 2012/05/15 20:30:05 kettenis Exp $	*/
d86 1
a86 1
	puc_pci_attach, puc_pci_detach, config_activate_children
@


1.21
log
@Allow for serial console on com@@puc.  Not perfect but should handle the
common cases.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.20 2011/11/15 22:27:53 deraadt Exp $	*/
d210 1
d215 1
a215 1
		if (sc->sc_desc->ports[i].type == 0)	/* neither com or lpt */
d218 1
a218 1
		bar = PUC_PORT_BAR_INDEX(sc->sc_desc->ports[i].bar);
d222 2
a223 2
			    puc_port_type_name(sc->sc_desc->ports[i].type),
			    sc->sc_desc->ports[i].bar);
d232 1
a232 1
		paa->type = sc->sc_desc->ports[i].type;
d234 4
a237 3
		if (bus_space_subregion(sc->sc_bar_mappings[bar].t,
		    sc->sc_bar_mappings[bar].h, sc->sc_desc->ports[i].offset,
		    sc->sc_bar_mappings[bar].s - sc->sc_desc->ports[i].offset,
@


1.20
log
@Simplify various parts of the puc(4) attachment code.  Tested lightly
by krw and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.19 2011/10/25 20:02:21 deraadt Exp $	*/
d59 1
d67 3
d168 20
@


1.19
log
@Use a new encoding for the entries in the pucdata table, the result is
that the .o file is half the size.  Tested by camield (who just doubled
the table size recently for a 16-port device).  Hopefully no regressions,
since this is a pretty large change of a very large table.
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.18 2010/08/06 21:04:14 kettenis Exp $	*/
a106 8
		return (10);

	/*
	 * Match class/subclass, so we can tell people to compile kernel
	 * with options that cause this driver to spew.
	 */
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_COMMUNICATIONS &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_PCI)
a145 19
	if (sc->sc_desc == NULL) {
		/*
		 * This was a class/subclass match, so tell people to compile
		 * kernel with options that cause this driver to spew.
		 */
#ifdef PUC_PRINT_REGS
		printf(":\n");
		pci_conf_print(pa->pa_pc, pa->pa_tag, NULL);
#else
		printf(": unknown PCI communications device\n");
		printf("%s: compile kernel with PUC_PRINT_REGS and larger\n",
		    sc->sc_dev.dv_xname);
		printf("%s: message buffer (via 'options MSGBUFSIZE=...'),\n",
		    sc->sc_dev.dv_xname);
		printf("%s: and report the result with sendbug(1)\n",
		    sc->sc_dev.dv_xname);
#endif
		return;
	}
a148 13
	/*
	 * XXX This driver assumes that 'com' ports attached to it
	 * XXX can not be console.  That isn't unreasonable, because PCI
	 * XXX devices are supposed to be dynamically mapped, and com
	 * XXX console ports want fixed addresses.  When/if baseboard
	 * XXX 'com' ports are identified as PCI/communications/serial
	 * XXX devices and are known to be mapped at the standard
	 * XXX addresses, if they can be the system console then we have
	 * XXX to cope with doing the mapping right.  Then this will get
	 * XXX really ugly.  Of course, by then we might know the real
	 * XXX definition of PCI/communications/serial, and attach 'com'
	 * XXX directly on PCI.
	 */
a176 1
	paa.hwtype = 0;	/* autodetect */
a179 8
	/*
	 * If this is a serial card with a known specific chip, provide
	 * the UART type.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_PLX &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_PLX_CRONYX_OMEGA)
		paa.hwtype = 0x08;	/* XXX COM_UART_ST16C654 */

a186 16

	/*
	 * XXX the sub-devices establish the interrupts, for the
	 * XXX following reasons:
	 * XXX
	 * XXX    * we can't really know what IPLs they'd want
	 * XXX
	 * XXX    * the MD dispatching code can ("should") dispatch
	 * XXX      chained interrupts better than we can.
	 * XXX
	 * XXX It would be nice if we could indicate to the MD interrupt
	 * XXX handling code that the interrupt line used by the device
	 * XXX was a PCI (level triggered) interrupt.
	 * XXX
	 * XXX It's not pretty, but hey, what is?
	 */
@


1.18
log
@Initial stab at making com@@puc suspend and resume properly.  Works fine
for using cu(1) between two OpenBSD machines.  Probably doesn't work for
serial consoles but we don't support those on puc(4) anyway.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.17 2010/07/22 17:16:10 pirofti Exp $	*/
d254 2
a255 4
	for (i = 0; PUC_PORT_VALID(sc->sc_desc, i); i++) {
		/* Skip unknown ports */
		if (sc->sc_desc->ports[i].type != PUC_PORT_TYPE_COM &&
		    sc->sc_desc->ports[i].type != PUC_PORT_TYPE_LPT)
a268 2
		paa->type = sc->sc_desc->ports[i].type;
		paa->flags = sc->sc_desc->ports[i].flags;
d272 2
d350 1
a350 2
	for (i = 0; !(puc_devs[i].rval[0] == 0 && puc_devs[i].rval[1] == 0 &&
	    puc_devs[i].rval[2] == 0 && puc_devs[i].rval[3] == 0); i++)
d364 1
a364 2
	switch (type) {
	case PUC_PORT_TYPE_COM:
d366 1
a366 1
	case PUC_PORT_TYPE_LPT:
d368 1
a368 3
	default:
		return "unknown";
	}
d377 2
a378 3
	for (i = ncom = nlpt = 0; PUC_PORT_VALID(desc, i); i++) {
		switch (desc->ports[i].type) {
		case PUC_PORT_TYPE_COM:
d380 1
a380 2
		break;
		case PUC_PORT_TYPE_LPT:
a381 5
		break;
		default:
			printf("port %d unknown type %d ", i,
			    desc->ports[i].type);
		}
@


1.17
log
@Clean the macros from puc(4). Now with correct logic.

Tested and okay sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.16 2010/07/07 21:32:50 sthen Exp $	*/
d82 1
a82 1
	puc_pci_attach, puc_pci_detach
@


1.16
log
@revert last commit, it made my puc(4) disappear. ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.14 2009/03/03 16:52:25 deraadt Exp $	*/
d352 7
a358 16
#define checkreg(val, index) \
    (((val) & puc_devices[i].rmask[(index)]) == puc_devices[i].rval[(index)])
#define pucdevdone(idx) \
    (puc_devices[idx].rval[0] == 0 && puc_devices[idx].rval[1] == 0 \
	&& puc_devices[idx].rval[2] == 0 && puc_devices[idx].rval[3] == 0)

	for (i = 0; !pucdevdone(i); i++) {
		if (checkreg(vend, PUC_REG_VEND) &&
		    checkreg(prod, PUC_REG_PROD) &&
		    checkreg(svend, PUC_REG_SVEND) &&
		    checkreg(sprod, PUC_REG_SPROD))
			return (&puc_devices[i]);
	}

#undef devdone
#undef checkreg
@


1.15
log
@Abstraction clean-up. `I like it' deraadt@@.
@
text
@d352 16
a367 7
	for (i = 0; puc_devs[i].rval[0] && puc_devs[i].rval[1] &&
	    puc_devs[i].rval[2] && puc_devs[i].rval[3]; i++)
		if ((vend & puc_devs[i].rmask[0]) == puc_devs[i].rval[0] &&
		    (prod & puc_devs[i].rmask[1]) == puc_devs[i].rval[1] &&
		    (svend & puc_devs[i].rmask[2]) == puc_devs[i].rval[2] &&
		    (sprod & puc_devs[i].rmask[3]) == puc_devs[i].rval[3])
			return (&puc_devs[i]);
@


1.14
log
@shorten sizes of variables to the required number of bits, and remove
unused variables, tested by todd
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.13 2007/12/04 21:49:35 kettenis Exp $	*/
d352 7
a358 16
#define checkreg(val, index) \
    (((val) & puc_devices[i].rmask[(index)]) == puc_devices[i].rval[(index)])
#define pucdevdone(idx) \
    (puc_devices[idx].rval[0] == 0 && puc_devices[idx].rval[1] == 0 \
	&& puc_devices[idx].rval[2] == 0 && puc_devices[idx].rval[3] == 0)

	for (i = 0; !pucdevdone(i); i++) {
		if (checkreg(vend, PUC_REG_VEND) &&
		    checkreg(prod, PUC_REG_PROD) &&
		    checkreg(svend, PUC_REG_SVEND) &&
		    checkreg(sprod, PUC_REG_SPROD))
			return (&puc_devices[i]);
	}

#undef devdone
#undef checkreg
@


1.13
log
@Make puc(4) detachable.

Tested by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.12 2007/04/26 01:31:05 gwk Exp $	*/
a201 1
		sc->sc_bar_mappings[i].type = type;
d347 2
a348 1
puc_find_description(u_long vend, u_long prod, u_long svend, u_long sprod)
@


1.12
log
@Some cleanup, ansify remaining K&R functions, neatly summarize the
available ports e.g.

puc0 at pci1 dev 7 function 0 "Moxa C168H" rev 0x02: com, com, com, com,
com, com, com, com
vs
puc0 at pci1 dev 7 function 0 "Moxa C168H" rev 0x02: ports: 8 com

and panicing is an extreme behaviour if we dont know the name of a port
simply print a message informing of the unknown port and dont attempt to
attach it.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.11 2006/12/28 20:52:36 miod Exp $	*/
d75 1
d81 2
a82 1
	sizeof(struct puc_pci_softc), puc_pci_match, puc_pci_attach
d133 4
d138 1
a138 1
	return (pci_intr_establish(sc->pc, sc->ih, type, func, arg, name));
d298 25
@


1.11
log
@Add support for the Cronyx Omega serial ports card; this particular card
forces the com(4) uart type to ST16C654 since that's what's on it;
from Alexei G. Malinin (alexei.malinin@@inetcomm.ru)
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.10 2006/08/01 20:10:29 jolan Exp $	*/
d67 1
a67 1
	struct puc_softc sc_psc;
d69 2
a70 2
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
d90 1
a90 3
puc_pci_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d136 1
a136 3
puc_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d250 4
d295 1
a295 3
puc_print(aux, pnp)
	void *aux;
	const char *pnp;
d298 1
a298 1
        
d306 1
a306 3
puc_submatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d317 1
a317 2
puc_find_description(vend, prod, svend, sprod)
	u_long vend, prod, svend, sprod;
d342 1
a342 2
puc_port_type_name(type)
	int type;
d351 1
a351 1
		panic("puc_port_type_name %d", type);
d358 1
a358 1
	int i;
d360 21
a380 4
	printf(": ");
	for (i = 0; PUC_PORT_VALID(desc, i); i++)
		printf("%s%s", i ? ", " : "",
		    puc_port_type_name(desc->ports[i].type));
@


1.10
log
@back out a tiny piece of mickey's commit which lets me compile a kernel
on sparc64 again
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.9 2006/07/31 11:06:33 mickey Exp $	*/
d64 2
d219 9
@


1.9
log
@puc@@cardbus (only added (commented out) to whom has puc@@pci enabled)
tested on puc@@pci by fkr and meself on the cardbus.
still needs a bit more work but generally works.
deraadt@@ ok and some input from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.8 2003/02/28 15:14:08 mickey Exp $	*/
d269 1
a269 1
#ifndef SMALL_KERNEL
@


1.8
log
@typo; from weissmanndude
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.7 2002/12/11 18:44:23 henning Exp $	*/
d64 2
a65 2
struct puc_softc {
	struct device		sc_dev;
d67 2
a68 21
	/* static configuration data */
	const struct puc_device_description *sc_desc;

	/* card-global dynamic data */
	void			*sc_ih;
	struct {
		int		mapped;
		bus_addr_t	a;
		bus_size_t	s;
		bus_space_tag_t	t;
		bus_space_handle_t h;
	} sc_bar_mappings[6];				/* XXX constant */

	/* per-port dynamic data */
        struct {
		struct device	*dev;

                /* filled in by port attachments */
                int             (*ihand)(void *);
                void            *ihandarg;
        } sc_ports[PUC_MAX_PORTS];
d71 5
a75 4
int	puc_match(struct device *, void *, void *);
void	puc_attach(struct device *, struct device *, void *);
int	puc_print(void *, const char *);
int	puc_submatch(struct device *, void *, void *);
d77 2
a78 2
struct cfattach puc_ca = {
	sizeof(struct puc_softc), puc_match, puc_attach
d85 1
a85 4
static const struct puc_device_description *
	puc_find_description(pcireg_t, pcireg_t, pcireg_t, pcireg_t);
static const char *
	puc_port_type_name(int);
d88 1
a88 1
puc_match(parent, match, aux)
d118 17
d136 1
a136 1
puc_attach(parent, self, aux)
d140 2
a141 1
	struct puc_softc *sc = (struct puc_softc *)self;
a143 1
	pci_intr_handle_t intrhandle;
d145 1
a145 1
	int i, barindex;
d170 1
a170 5
	printf(": ");
	for (i = 0; PUC_PORT_VALID(sc->sc_desc, i); i++)
		printf("%s%s", i ? ", " : "",
		    puc_port_type_name(sc->sc_desc->ports[i].type));
	printf("\n");
d185 3
a187 2
	for (i = 0; i < 6; i++) {
		pcireg_t bar, type;
d190 2
a191 4

		bar = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    PCI_MAPREG_START + 4 * i);	/* XXX const */
		if (bar == 0)			/* BAR not implemented(?) */
d194 2
a195 5
		type = (PCI_MAPREG_TYPE(bar) == PCI_MAPREG_TYPE_IO ?
		    PCI_MAPREG_TYPE_IO : PCI_MAPREG_MEM_TYPE(bar));
		sc->sc_bar_mappings[i].mapped = (pci_mapreg_map(pa,
		    PCI_MAPREG_START + 4 * i, type, 0,
		    &sc->sc_bar_mappings[i].t, &sc->sc_bar_mappings[i].h,
d198 1
d203 1
a203 1
		    sc->sc_dev.dv_xname, (long)(PCI_MAPREG_START + 4 * i));
d207 2
a208 1
	if (pci_intr_map(pa, &intrhandle)) {
d212 13
a242 2
		bus_space_handle_t subregion_handle;

d244 2
a245 2
		barindex = PUC_PORT_BAR_INDEX(sc->sc_desc->ports[i].bar);
		if (!sc->sc_bar_mappings[barindex].mapped) {
d254 10
a263 14
		paa.port = i;
		paa.type = sc->sc_desc->ports[i].type;
		paa.flags = sc->sc_desc->ports[i].flags;
		paa.pc = pa->pa_pc;
		paa.intrhandle = intrhandle;
		paa.a = sc->sc_bar_mappings[barindex].a;
		paa.t = sc->sc_bar_mappings[barindex].t;

		if (bus_space_subregion(sc->sc_bar_mappings[barindex].t,
		    sc->sc_bar_mappings[barindex].h,
		    sc->sc_desc->ports[i].offset,
		    sc->sc_bar_mappings[barindex].s - 
		      sc->sc_desc->ports[i].offset,
		    &subregion_handle)) {
a267 1
		paa.h = subregion_handle;
d269 6
a274 5
#if 0
		printf("%s: port %d: %s @@ (index %d) 0x%x (0x%lx, 0x%lx)\n",
		    sc->sc_dev.dv_xname, paa.port,
		    puc_port_type_name(paa.type), barindex, (int)paa.a,
		    (long)paa.t, (long)paa.h);
d278 2
a279 2
		sc->sc_ports[i].dev = config_found_sm(self, &paa, puc_print,
		    puc_submatch);
d309 1
a309 1
static const struct puc_device_description *
d311 1
a311 1
	pcireg_t vend, prod, svend, sprod;
d335 1
a335 1
static const char *
d348 12
@


1.7
log
@send-pr -> sendbug here as well; Peter Werner
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.6 2002/03/14 01:26:59 millert Exp $	*/
d166 1
a166 1
		printf("%s: mesage buffer (via 'options MSGBUFSIZE=...'),\n",
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.5 2001/08/25 10:13:30 art Exp $	*/
d168 1
a168 1
		printf("%s: and report the result with send-pr\n",
@


1.5
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.4 2001/06/12 15:40:33 niklas Exp $	*/
d85 1
a85 1
                int             (*ihand) __P((void *));
d90 4
a93 4
int	puc_match __P((struct device *, void *, void *));
void	puc_attach __P((struct device *, struct device *, void *));
int	puc_print __P((void *, const char *));
int	puc_submatch __P((struct device *, void *, void *));
d104 1
a104 1
	puc_find_description __P((pcireg_t, pcireg_t, pcireg_t, pcireg_t));
d106 1
a106 1
	puc_port_type_name __P((int));
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.5 2001/08/25 10:13:30 art Exp $	*/
d85 1
a85 1
                int             (*ihand)(void *);
d90 4
a93 4
int	puc_match(struct device *, void *, void *);
void	puc_attach(struct device *, struct device *, void *);
int	puc_print(void *, const char *);
int	puc_submatch(struct device *, void *, void *);
d104 1
a104 1
	puc_find_description(pcireg_t, pcireg_t, pcireg_t, pcireg_t);
d106 1
a106 1
	puc_port_type_name(int);
@


1.5.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 1
a166 1
		printf("%s: message buffer (via 'options MSGBUFSIZE=...'),\n",
d168 1
a168 1
		printf("%s: and report the result with sendbug(1)\n",
@


1.4
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.3 2001/03/15 17:52:19 deraadt Exp $	*/
d218 1
a218 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &intrhandle)) {
@


1.3
log
@support puc devices with higher speeds (not tested yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.2 1999/11/14 01:27:57 downsj Exp $	*/
a204 1

d208 1
a208 1
		    &sc->sc_bar_mappings[i].a, &sc->sc_bar_mappings[i].s)
@


1.2
log
@Kill the overly verbose description strings, add another device.
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.1 1999/10/26 13:06:14 downsj Exp $	*/
d257 1
@


1.2.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.3 2001/03/15 17:52:19 deraadt Exp $	*/
a256 1
		paa.flags = sc->sc_desc->ports[i].flags;
@


1.2.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.2.2.1 2001/05/14 22:25:56 niklas Exp $	*/
d205 1
d209 1
a209 1
		    &sc->sc_bar_mappings[i].a, &sc->sc_bar_mappings[i].s, 0)
@


1.2.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: puc.c,v 1.2.2.2 2001/07/04 10:43:02 niklas Exp $	*/
d218 2
a219 1
	if (pci_intr_map(pa, &intrhandle)) {
@


1.2.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
a85 1
                int             (*ihand)(void *);
d90 4
a93 4
int	puc_match(struct device *, void *, void *);
void	puc_attach(struct device *, struct device *, void *);
int	puc_print(void *, const char *);
int	puc_submatch(struct device *, void *, void *);
d104 1
a104 1
	puc_find_description(pcireg_t, pcireg_t, pcireg_t, pcireg_t);
d106 1
a106 1
	puc_port_type_name(int);
@


1.2.2.5
log
@Sync the SMP branch with 3.3
@
text
@d166 1
a166 1
		printf("%s: message buffer (via 'options MSGBUFSIZE=...'),\n",
d168 1
a168 1
		printf("%s: and report the result with sendbug(1)\n",
@


1.1
log
@PCI "universal" communication device driver, by cgd@@netbsd.org.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d174 1
a174 1
	printf(": %s (", sc->sc_desc->name);
d178 1
a178 1
	printf(")\n");
d321 3
d325 1
a325 1
	for (i = 0; puc_devices[i].name != NULL; i++) {
d333 1
@

