head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.34
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.32
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.22
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.30
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.28
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.26
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.24
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.20
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.18
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.16
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.14
	OPENBSD_5_0:1.17.0.12
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.10
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.8
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7;
locks; strict;
comment	@ * @;


1.17
date	2008.09.10.16.13.43;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.26.15.00.49;	author martin;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.20.22.06.43;	author cnst;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.31.21.34.39;	author cnst;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.31.21.24.37;	author cnst;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.31.21.18.49;	author cnst;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.27.20.29.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.19.17.08.39;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.27.17.18.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.21.21.53.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.18.20.51.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.18.20.47.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.17.08.42.56;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.16.04.05.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@add support for the PCA9555 device which has 16 instead of 8 pins.

ok deraadt@@
@
text
@/*	$OpenBSD: pca9554.c,v 1.16 2007/10/26 15:00:49 martin Exp $	*/

/*
 * Copyright (c) 2005 Theo de Raadt
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/gpio.h>
#include <sys/sensors.h>

#include <dev/i2c/i2cvar.h>

#include <dev/gpio/gpiovar.h>

/* Philips 9554/6/7 registers */
#define PCA9554_IN		0x00
#define PCA9554_OUT		0x01
#define PCA9554_POLARITY	0x02
#define PCA9554_CONFIG		0x03

/* Philips 9555 registers */
#define PCA9555_IN0		0x00
#define PCA9555_IN1		0x01
#define PCA9555_OUT0		0x02
#define PCA9555_OUT1		0x03
#define PCA9555_POLARITY0	0x04
#define PCA9555_POLARITY1	0x05
#define PCA9555_CONFIG0		0x06
#define PCA9555_CONFIG1		0x07

/* Sensors */
#define PCAGPIO_NPINS	16

#define PCAGPIO_NPORTS	2
#define PCAGPIO_PORT(_pin)	((_pin) > 7 ? 1 : 0)
#define PCAGPIO_BIT(_pin)	(1 << ((_pin) % 8))

/* Register mapping index */
enum pcigpio_cmd {
	PCAGPIO_IN		= 0,
	PCAGPIO_OUT,
	PCAGPIO_POLARITY,
	PCAGPIO_CONFIG,
	PCAGPIO_MAX
};

struct pcagpio_softc {
	struct device	sc_dev;
	i2c_tag_t	sc_tag;
	i2c_addr_t	sc_addr;

	u_int8_t	sc_npins;
	u_int8_t	sc_control[PCAGPIO_NPORTS];
	u_int8_t	sc_polarity[PCAGPIO_NPORTS];
	u_int8_t	sc_regs[PCAGPIO_NPORTS][PCAGPIO_MAX];

	struct gpio_chipset_tag sc_gpio_gc;
        gpio_pin_t sc_gpio_pins[PCAGPIO_NPINS];

	struct ksensor sc_sensor[PCAGPIO_NPINS];
	struct ksensordev sc_sensordev;
};

int	pcagpio_match(struct device *, void *, void *);
void	pcagpio_attach(struct device *, struct device *, void *);
int	pcagpio_init(struct pcagpio_softc *, int, u_int8_t *);
void	pcagpio_refresh(void *);

int     pcagpio_gpio_pin_read(void *, int);
void    pcagpio_gpio_pin_write(void *, int, int);
void    pcagpio_gpio_pin_ctl(void *, int, int);

struct cfattach pcagpio_ca = {
	sizeof(struct pcagpio_softc), pcagpio_match, pcagpio_attach
};

struct cfdriver pcagpio_cd = {
	NULL, "pcagpio", DV_DULL
};

int
pcagpio_match(struct device *parent, void *match, void *aux)
{
	struct i2c_attach_args *ia = aux;

	if (strcmp(ia->ia_name, "PCA9554") == 0 ||
	    strcmp(ia->ia_name, "PCA9554M") == 0 ||
	    strcmp(ia->ia_name, "pca9555") == 0 ||
	    strcmp(ia->ia_name, "pca9556") == 0 ||
	    strcmp(ia->ia_name, "pca9557") == 0)
		return (1);
	return (0);
}

void
pcagpio_attach(struct device *parent, struct device *self, void *aux)
{
	struct pcagpio_softc *sc = (struct pcagpio_softc *)self;
	struct i2c_attach_args *ia = aux;
	struct gpiobus_attach_args gba;
	int outputs = 0, i, port, bit;
	u_int8_t data[PCAGPIO_NPORTS];

	sc->sc_tag = ia->ia_tag;
	sc->sc_addr = ia->ia_addr;

	if (strcmp(ia->ia_name, "pca9555") == 0) {
		/* The pca9555 has two 8 bit ports */
		sc->sc_regs[0][PCAGPIO_IN] = PCA9555_IN0;
		sc->sc_regs[0][PCAGPIO_OUT] = PCA9555_OUT0;
		sc->sc_regs[0][PCAGPIO_POLARITY] = PCA9555_POLARITY0;
		sc->sc_regs[0][PCAGPIO_CONFIG] = PCA9555_CONFIG0;
		sc->sc_regs[1][PCAGPIO_IN] = PCA9555_IN1;
		sc->sc_regs[1][PCAGPIO_OUT] = PCA9555_OUT1;
		sc->sc_regs[1][PCAGPIO_POLARITY] = PCA9555_POLARITY1;
		sc->sc_regs[1][PCAGPIO_CONFIG] = PCA9555_CONFIG1;
		sc->sc_npins = 16;
	} else {
		/* All other supported devices have one 8 bit port */
		sc->sc_regs[0][PCAGPIO_IN] = PCA9554_IN;
		sc->sc_regs[0][PCAGPIO_OUT] = PCA9554_OUT;
		sc->sc_regs[0][PCAGPIO_POLARITY] = PCA9554_POLARITY;
		sc->sc_regs[0][PCAGPIO_CONFIG] = PCA9554_CONFIG;
		sc->sc_npins = 8;
	}
	if (pcagpio_init(sc, 0, &data[0]) != 0)
		return;
	if (sc->sc_npins > 8 && pcagpio_init(sc, 1, &data[1]) != 0)
		return;

	/* Initialize sensor data. */
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	for (i = 0; i < sc->sc_npins; i++) {
		port = PCAGPIO_PORT(i);
		bit = PCAGPIO_BIT(i);
		sc->sc_sensor[i].type = SENSOR_INDICATOR;
		if ((sc->sc_control[port] & bit) == 0) {
			strlcpy(sc->sc_sensor[i].desc, "out",
			    sizeof(sc->sc_sensor[i].desc));
			outputs++;
		} else
			strlcpy(sc->sc_sensor[i].desc, "in",
			    sizeof(sc->sc_sensor[i].desc));
	}

	if (sensor_task_register(sc, pcagpio_refresh, 5) == NULL) {
		printf(", unable to register update task\n");
		return;
	}

#if 0
	for (i = 0; i < sc->sc_npins; i++)
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[i]);
	sensordev_install(&sc->sc_sensordev);
#endif

	printf(":");
	if (sc->sc_npins - outputs)
		printf(" %d inputs", sc->sc_npins - outputs);
	if (outputs)
		printf(" %d outputs", outputs);
	printf("\n");

	for (i = 0; i < sc->sc_npins; i++) {
		port = PCAGPIO_PORT(i);
		bit = PCAGPIO_BIT(i);

		sc->sc_gpio_pins[i].pin_num = i;
		sc->sc_gpio_pins[i].pin_caps = GPIO_PIN_INPUT | GPIO_PIN_OUTPUT;

		if ((sc->sc_control[port] & bit) == 0) {
			sc->sc_gpio_pins[i].pin_flags = GPIO_PIN_OUTPUT;
			sc->sc_gpio_pins[i].pin_state = data[port] &
			    bit ? GPIO_PIN_HIGH : GPIO_PIN_LOW;
		}
	}

	/* Create controller tag */
	sc->sc_gpio_gc.gp_cookie = sc;
	sc->sc_gpio_gc.gp_pin_read = pcagpio_gpio_pin_read;
	sc->sc_gpio_gc.gp_pin_write = pcagpio_gpio_pin_write;
	sc->sc_gpio_gc.gp_pin_ctl = pcagpio_gpio_pin_ctl;

	gba.gba_name = "gpio";
	gba.gba_gc = &sc->sc_gpio_gc;
	gba.gba_pins = sc->sc_gpio_pins;
	gba.gba_npins = sc->sc_npins;

	config_found(&sc->sc_dev, &gba, gpiobus_print);

}

int
pcagpio_init(struct pcagpio_softc *sc, int port, u_int8_t *datap)
{
	u_int8_t cmd, data;

	cmd = sc->sc_regs[port][PCAGPIO_CONFIG];
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		printf(": failed to initialize\n");
		return (-1);
	}
	sc->sc_control[port] = data;
	cmd = sc->sc_regs[port][PCAGPIO_POLARITY];
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		printf(": failed to initialize\n");
		return (-1);
	}
	sc->sc_polarity[port] = data;
	cmd = sc->sc_regs[port][PCAGPIO_OUT];
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		printf(": failed to initialize\n");
		return (-1);
	}

	*datap = data;
	return (0);
}

void
pcagpio_refresh(void *arg)
{
	struct pcagpio_softc *sc = arg;
	u_int8_t cmd, bit, in[PCAGPIO_NPORTS], out[PCAGPIO_NPORTS];
	int i, port;

	iic_acquire_bus(sc->sc_tag, 0);

	for (i = 0; i < PCAGPIO_NPORTS; i++) {
		cmd = sc->sc_regs[i][PCAGPIO_IN];
		if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
		    sc->sc_addr, &cmd, sizeof cmd, &in[i], sizeof in[i], 0))
			goto invalid;

		cmd = sc->sc_regs[i][PCAGPIO_OUT];
		if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
		    sc->sc_addr, &cmd, sizeof cmd, &out[i], sizeof out[i], 0))
			goto invalid;
	}

	for (i = 0; i < sc->sc_npins; i++) {
		port = PCAGPIO_PORT(i);
		bit = PCAGPIO_BIT(i);
		if ((sc->sc_control[port] & bit))
			sc->sc_sensor[i].value = (in[port] & bit) ? 1 : 0;
		else
			sc->sc_sensor[i].value = (out[port] & bit) ? 1 : 0;
	}

invalid:
	iic_release_bus(sc->sc_tag, 0);
}


int
pcagpio_gpio_pin_read(void *arg, int pin)
{
	struct pcagpio_softc *sc = arg;
	u_int8_t cmd, in;
	int port, bit;

	port = PCAGPIO_PORT(pin);
	bit = PCAGPIO_BIT(pin);

	cmd = sc->sc_regs[port][PCAGPIO_IN];
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &in, sizeof in, 0))
		return 0;
	return ((in ^ sc->sc_polarity[port]) & bit) ? 1 : 0;
}

void
pcagpio_gpio_pin_write(void *arg, int pin, int value)
{
	struct pcagpio_softc *sc = arg;
	u_int8_t cmd, out, mask;
	int port, bit;

	port = PCAGPIO_PORT(pin);
	bit = PCAGPIO_BIT(pin);

	mask = 0xff ^ bit;
	cmd = sc->sc_regs[port][PCAGPIO_OUT];
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &out, sizeof out, 0))
		return;
	out = (out & mask) | (value ? bit : 0);

	cmd = sc->sc_regs[port][PCAGPIO_OUT];
	if (iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &out, sizeof out, 0))
		return;
}

void
pcagpio_gpio_pin_ctl(void *arg, int pin, int flags)
{
#if 0
	struct pcagpio_softc *sc = arg;
	u_int32_t conf;

	pcagpio_gpio_pin_select(sc, pin);
	conf = bus_space_read_4(sc->sc_gpio_iot, sc->sc_gpio_ioh,
	    GSCGPIO_CONF);

	conf &= ~(GSCGPIO_CONF_OUTPUTEN | GSCGPIO_CONF_PUSHPULL |
	    GSCGPIO_CONF_PULLUP);
	if ((flags & GPIO_PIN_TRISTATE) == 0)
		conf |= GSCGPIO_CONF_OUTPUTEN;
	if (flags & GPIO_PIN_PUSHPULL)
		conf |= GSCGPIO_CONF_PUSHPULL;
	if (flags & GPIO_PIN_PULLUP)
		conf |= GSCGPIO_CONF_PULLUP;
	bus_space_write_4(sc->sc_gpio_iot, sc->sc_gpio_ioh,
	    GSCGPIO_CONF, conf);
#endif
}
@


1.16
log
@Phillips -> Philips in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.15 2007/10/20 22:06:43 cnst Exp $	*/
d29 1
a29 1
/* Philips 9554 registers */
d35 10
d46 14
a59 1
#define PCAGPIO_NPINS	8
d65 5
a69 2
	u_int8_t	sc_control;
	u_int8_t	sc_polarity;
d80 1
d115 2
a116 2
	u_int8_t cmd, data;
	int outputs = 0, i;
d121 18
a138 5
	cmd = PCA9554_CONFIG;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		printf(": failed to initialize\n");
		return;
d140 1
a140 5
	sc->sc_control = data;
	cmd = PCA9554_POLARITY;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		printf(": failed to initialize\n");
d142 1
a142 6
	}
	sc->sc_polarity = data;
	cmd = PCA9554_OUT;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		printf(": failed to initialize\n");
a143 1
	}
d149 3
a151 1
	for (i = 0; i < PCAGPIO_NPINS; i++) {
d153 1
a153 1
		if ((sc->sc_control & (1 << i)) == 0) {
a159 1

d168 1
a168 1
	for (i = 0; i < PCAGPIO_NPINS; i++)
d174 2
a175 2
	if (PCAGPIO_NPINS - outputs)
		printf(" %d inputs", PCAGPIO_NPINS - outputs);
d180 4
a183 1
	for (i = 0; i < PCAGPIO_NPINS; i++) {
d187 1
a187 1
		if ((sc->sc_control & (1 << i)) == 0) {
d189 2
a190 2
			sc->sc_gpio_pins[i].pin_state =
			    data & (1 << i) ? GPIO_PIN_HIGH : GPIO_PIN_LOW;
d203 1
a203 1
	gba.gba_npins = PCAGPIO_NPINS;
d209 30
d243 2
a244 2
	u_int8_t cmd, in, out, bit;
	int i;
d248 11
a258 4
	cmd = PCA9554_IN;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &in, sizeof in, 0))
		goto invalid;
d260 5
a264 9
	cmd = PCA9554_OUT;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &out, sizeof out, 0))
		goto invalid;

	for (i = 0; i < PCAGPIO_NPINS; i++) {
		bit = 1 << i;
		if ((sc->sc_control & bit))
			sc->sc_sensor[i].value = (in & bit) ? 1 : 0;
d266 1
a266 1
			sc->sc_sensor[i].value = (out & bit) ? 1 : 0;
d279 1
d281 4
a284 1
	cmd = PCA9554_IN;
d288 1
a288 1
	return ((in ^ sc->sc_polarity) & (1 << pin)) ? 1 : 0;
d296 4
d301 2
a302 2
	mask = 0xff ^ (1 << pin);
	cmd = PCA9554_OUT;
d306 1
a306 1
	out = (out & mask) | (value << pin);
d308 1
a308 1
	cmd = PCA9554_OUT;
@


1.15
log
@_check prototypes are no longer used (replaced by i2c_scan.c); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.14 2007/07/31 21:34:39 cnst Exp $	*/
d29 1
a29 1
/* Phillips 9554 registers */
@


1.14
log
@don't duplicate .numt in .desc; 'In this driver, whatever you want' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.13 2007/07/31 21:24:37 cnst Exp $	*/
a53 1
int	pcagpio_check(struct i2c_attach_args *, u_int8_t *, u_int8_t *);
@


1.13
log
@change sensor type: if .value can only ever be 0 or 1, .type should be indicator
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.12 2007/07/31 21:18:49 cnst Exp $	*/
d123 2
a124 2
			snprintf(sc->sc_sensor[i].desc,
			    sizeof(sc->sc_sensor[i].desc), "out%d", i);
d127 2
a128 2
			snprintf(sc->sc_sensor[i].desc,
			    sizeof(sc->sc_sensor[i].desc), "in%d", i);
@


1.12
log
@remove magic numbers: use PCAGPIO_NPINS instead (no binary change); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.11 2007/06/24 05:34:35 dlg Exp $	*/
d121 1
a121 1
		sc->sc_sensor[i].type = SENSOR_INTEGER;
@


1.11
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.10 2007/03/22 16:55:31 deraadt Exp $	*/
d144 2
a145 2
	if (8 - outputs)
		printf(" %d inputs", 8 - outputs);
@


1.10
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.9 2006/12/23 17:46:39 deraadt Exp $	*/
d132 1
a132 1
	if (sensor_task_register(sc, pcagpio_refresh, 5)) {
@


1.9
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.8 2006/06/27 20:29:48 deraadt Exp $	*/
d48 2
a49 2
	struct sensor sc_sensor[PCAGPIO_NPINS];
	struct sensordev sc_sensordev;
@


1.8
log
@match pca9555 as a name too
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.7 2006/01/19 17:08:39 grange Exp $	*/
d49 1
d117 2
a118 3
	for (i = 0; i < PCAGPIO_NPINS; i++)
		strlcpy(sc->sc_sensor[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sc_sensor[i].device));
d139 2
a140 1
		sensor_add(&sc->sc_sensor[i]);
@


1.7
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.6 2005/12/27 17:18:18 deraadt Exp $	*/
d75 1
@


1.6
log
@no longer use ia_compat; tested by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.5 2005/12/21 21:53:15 deraadt Exp $	*/
d138 1
a138 1
		SENSOR_ADD(&sc->sc_sensor[i]);
@


1.5
log
@wrong comment
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.4 2005/11/18 20:51:13 deraadt Exp $	*/
d73 6
a78 9
	if (ia->ia_compat) {
		if (strcmp(ia->ia_compat, "PCA9554") == 0 ||
		    strcmp(ia->ia_compat, "PCA9554M") == 0 ||
		    strcmp(ia->ia_compat, "pca9556") == 0 ||
		    strcmp(ia->ia_compat, "pca9557") == 0)
			return (1);
		return (0);
	}
	return (1);
@


1.4
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.3 2005/11/18 20:47:45 deraadt Exp $	*/
d29 1
a29 1
/* Maxim 6690 registers */
@


1.3
log
@support pca9556 and pca9557 too
cope with the polarity input register correctly, as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.2 2005/11/17 08:42:56 grange Exp $	*/
d74 4
a77 4
		if (strcasecmp(ia->ia_compat, "PCA9554") == 0 ||
		    strcasecmp(ia->ia_compat, "PCA9554M") == 0 ||
		    strcasecmp(ia->ia_compat, "pca9556") == 0 ||
		    strcasecmp(ia->ia_compat, "pca9557") == 0)
d144 1
a144 1
	printf(":"):
@


1.2
log
@Fix pastos; ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.1 2005/11/16 04:05:55 deraadt Exp $	*/
d74 4
a77 2
		if (strcmp(ia->ia_compat, "PCA9554") == 0 ||
		    strcmp(ia->ia_compat, "PCA9554M") == 0)
d144 6
a149 1
	printf(": %d inputs %d outputs\n", 8 - outputs, outputs);
d219 1
a219 1
	return (in & (1 << pin)) ? 1 : 0;
@


1.1
log
@driver for the philips pca9554 i2c gpio device
@
text
@d1 1
a1 1
/*	$OpenBSD: pca9554.c,v 1.1 2005/11/15 16:24:49 deraadt Exp $	*/
d36 1
a36 1
#define GSCGPIO_NPINS	8
d46 1
a46 1
        gpio_pin_t sc_gpio_pins[GSCGPIO_NPINS];
d48 1
a48 1
	struct sensor sc_sensor[GSCGPIO_NPINS];
d116 1
a116 1
	for (i = 0; i < GSCGPIO_NPINS; i++)
d120 1
a120 1
	for (i = 0; i < GSCGPIO_NPINS; i++) {
d138 1
a138 1
	for (i = 0; i < GSCGPIO_NPINS; i++)
d144 1
a144 1
	for (i = 0; i < GSCGPIO_NPINS; i++) {
d164 1
a164 1
	gba.gba_npins = GSCGPIO_NPINS;
d189 1
a189 1
	for (i = 0; i < GSCGPIO_NPINS; i++) {
@

