head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.6
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.32
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.30
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.28
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.24
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.22
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.20
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.18
	OPENBSD_5_0:1.15.0.16
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.14
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.12
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.8
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.1.0.8
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.15;
commitid	p4LJxGKbi0BU2cG6;

1.15
date	2007.10.09.16.57.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.26.20.24.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.08.23.15.58;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.29.17.29.30;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.01.20.52.25;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.27.17.18.18;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.27.09.21.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.27.07.31.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.26.03.52.07;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.23.01.26.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.22.23.53.58;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.20.05.42.32;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.19.19.36.46;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.15.16.23.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.23.17.33.43;	author grange;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.12.38;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: i2c.c,v 1.15 2007/10/09 16:57:47 deraadt Exp $	*/
/*	$NetBSD: i2c.c,v 1.1 2003/09/30 00:35:31 thorpej Exp $	*/

/*
 * Copyright (c) 2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/event.h>

#define _I2C_PRIVATE
#include <dev/i2c/i2cvar.h>

#define IICCF_ADDR	0
#define IICCF_SIZE	1

struct iic_softc {
	struct device sc_dev;
	i2c_tag_t sc_tag;
};

int	iic_match(struct device *, void *, void *);
void	iic_attach(struct device *, struct device *, void *);
int	iic_search(struct device *, void *, void *);

struct cfattach iic_ca = {
	sizeof (struct iic_softc),
	iic_match,
	iic_attach
};

struct cfdriver iic_cd = {
	NULL, "iic", DV_DULL
};

int
iicbus_print(void *aux, const char *pnp)
{
	struct i2cbus_attach_args *iba = aux;

	if (pnp != NULL)
		printf("%s at %s", iba->iba_name, pnp);

	return (UNCONF);
}

int
iic_print(void *aux, const char *pnp)
{
	struct i2c_attach_args *ia = aux;

	if (pnp != NULL)
		printf("\"%s\" at %s", ia->ia_name, pnp);
	printf(" addr 0x%x", ia->ia_addr);

	return (UNCONF);
}

int
iic_search(struct device *parent, void *arg, void *aux)
{
	struct iic_softc *sc = (void *) parent;
	struct cfdata *cf = arg;
	struct i2c_attach_args ia;

	if (cf->cf_loc[IICCF_ADDR] != -1) {
		memset(&ia, 0, sizeof(ia));
		ia.ia_tag = sc->sc_tag;
		ia.ia_addr = cf->cf_loc[IICCF_ADDR];
		ia.ia_size = cf->cf_loc[IICCF_SIZE];
		ia.ia_name = "unknown";

		if (cf->cf_attach->ca_match(parent, cf, &ia) > 0)
			config_attach(parent, cf, &ia, iic_print);
	}
	return (0);
}

int
iic_match(struct device *parent, void *arg, void *aux)
{
	struct cfdata *cf = arg;
	struct i2cbus_attach_args *iba = aux;

	/* Just make sure we're looking for i2c. */
	return (strcmp(iba->iba_name, cf->cf_driver->cd_name) == 0);
}

void
iic_attach(struct device *parent, struct device *self, void *aux)
{
	struct iic_softc *sc = (void *) self;
	struct i2cbus_attach_args *iba = aux;

	sc->sc_tag = iba->iba_tag;

	printf("\n");

	/*
	 * Attach all i2c devices described in the kernel
	 * configuration file.
	 */
	config_search(iic_search, self, NULL);

	/*
	 * Scan for known device signatures.
	 */
	if (iba->iba_bus_scan)
		(iba->iba_bus_scan)(self, aux, iba->iba_bus_scan_arg);
	else
		iic_scan(self, aux);
}
@


1.15
log
@we have been knocking out i2c when ipmi exists on a machine (because
there are ipmi bmc's that apparently violate i2c bus master locking).
but those problems bite us only for sensors which we re-scan every few
seconds, and then we hit the ipmi bmc's races.  for non-sensor devices
(like spdmem) it is probably ok to look once.  let's try that method
for a while and see if anyone sees breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.14 2006/02/26 20:24:46 deraadt Exp $	*/
a42 1
#include <sys/conf.h>
@


1.14
log
@if ipmi is on the machine: instead of (confusingly) failing in match,
bail out in attach, and also say why; ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.13 2006/02/08 23:15:58 dlg Exp $	*/
a50 2
#include "ipmi.h"

a129 9

#if NIPMI > 0
	extern int ipmi_enabled;

	if (ipmi_enabled) {
		printf(": disabled to avoid ipmi0 interactions\n");
		return;
	}
#endif
@


1.13
log
@add a member to the i2c_attach args so that a controller can pass a
cookie down to the device. the most obvious use of this is to pass a
device its ofw node on sparc64 and macppc so it can configure itself more
appropriately.

ok kettenis@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.12 2006/01/29 17:29:30 marco Exp $	*/
a120 7
#if NIPMI > 0
	extern int ipmi_enabled;

	if (ipmi_enabled)
		return (0);
#endif

d132 9
@


1.12
log
@Disable iic whenever ipmi is enabled.  This fixes boxes like Sun x4200 that
freak out when more than one device driver touch the i2c devices.
Reported by: Srebrenko Sehic <ssehic at gmail dot com>

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.11 2006/01/01 20:52:25 deraadt Exp $	*/
d103 1
@


1.11
log
@switch from macppc-specific maciic(4) driver to the generic iic(4),
after teaching it to use a function pointer to get back to the OFW
scan.. this will also help the sparc64 later; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.10 2005/12/27 17:18:18 deraadt Exp $	*/
d51 2
d119 7
@


1.10
log
@no longer use ia_compat; tested by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.9 2005/12/27 09:21:03 deraadt Exp $	*/
d76 1
a76 1
		printf("\"%s\" at %s", iba->iba_name, pnp);
d87 1
a87 1
		printf("%s at %s", ia->ia_name, pnp);
d141 3
a143 1
	if (iba->iba_scan)
@


1.9
log
@make direct mappings fail for now, since noone will test that for me
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.8 2005/12/27 07:31:53 deraadt Exp $	*/
a104 1
		ia.ia_compat = "unknown";
@


1.8
log
@the name belongs in "quotes"
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.7 2005/12/26 03:52:07 deraadt Exp $	*/
d104 2
a105 2
		ia.ia_name = NULL;
		ia.ia_compat = NULL;
@


1.7
log
@if probe falls, iic_print should print the name we attempted to match under
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.6 2005/12/23 01:26:22 deraadt Exp $	*/
d76 1
a76 1
		printf("%s at %s", iba->iba_name, pnp);
@


1.6
log
@upon startup, only scan-and-attach devices which specify an address
attribute; if that is not set, then we hope something later will guess
the address.  this must be revisited later on, to avoid double-attachment
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.5 2005/12/22 23:53:58 deraadt Exp $	*/
d86 2
@


1.5
log
@permit outsider to call iic_print
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.4 2005/12/20 05:42:32 grange Exp $	*/
d98 10
a107 9
	ia.ia_tag = sc->sc_tag;
	ia.ia_addr = cf->cf_loc[IICCF_ADDR];
	ia.ia_size = cf->cf_loc[IICCF_SIZE];
	ia.ia_name = NULL;
	ia.ia_compat = NULL;

	if (cf->cf_attach->ca_match(parent, cf, &ia) > 0)
		config_attach(parent, cf, &ia, iic_print);

@


1.4
log
@Do bus scanning only if underlying controller asked for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.3 2005/12/19 19:36:46 grange Exp $	*/
a58 1
int	iic_print(void *, const char *);
@


1.3
log
@First attempt to have a table of known I2C slave devices that we
have drivers for. iic(4) will scan the bus for them and try to
attach an appropriate driver.
For now iic(4) scans for all possible addresses for debugging purposes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.2 2005/11/15 16:23:31 deraadt Exp $	*/
d140 2
a141 1
	iic_scan(self, aux);
@


1.2
log
@instead of passing OF nodes down to the drivers, pass name/compat string
pointers.  This lets their match() functions actually make real decisions.
OF-capable machines will pass name/compat pointers, but other machines
will not.  grudging ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c.c,v 1.1 2004/05/23 17:33:43 grange Exp $	*/
d45 1
d136 5
@


1.1
log
@I2C framework originally written by Steve C. Woodford and Jason R. Thorpe
for NetBSD (r).

This framework supports various i2c master controllers:
- dumb bit-bang controllers
- a few styles of automated controllers that give you control
over sending start/stop conditions on the i2c bus
- automated controllers that are too smart for its own good,
giving software no control over start/stop conditions
- smbus controllers by emulating smbus protocol with i2c commands

i2c slave devices need their addresses to be specified in the kernel
config file, no device discovery presented.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 2
@


1.1.2.1
log
@Merge with the trunk
@
text
@@

