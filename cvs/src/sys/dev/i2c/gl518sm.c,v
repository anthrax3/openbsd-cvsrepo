head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.40
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.38
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.28
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.36
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.34
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.32
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.30
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.26
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.24
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.22
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.20
	OPENBSD_5_0:1.6.0.18
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.16
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.14
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.10
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.12
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.8
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.6
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.4
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.6
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.26.22.25.34;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.25.17.13.51;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.24.21.35.06;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.6
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@/*	$OpenBSD: gl518sm.c,v 1.5 2007/03/22 16:55:31 deraadt Exp $	*/

/*
 * Copyright (c) 2006 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/sensors.h>

#include <dev/i2c/i2cvar.h>

/* GL518SM registers */
#define GL518SM_CHIPID		0x00
#define GL518SM_REVISION	0x01
#define GL518SM_VENDORID	0x02
#define GL518SM_CONFIG		0x03
#define  GL518SM_CONFIG_START		0x40
#define  GL518SM_CONFIG_CLEARST		0x20
#define  GL518SM_CONFIG_NOFAN2		0x10
#define GL518SM_TEMP		0x04
#define GL518SM_TEMP_OVER	0x05
#define GL518SM_TEMP_HYST	0x06
#define GL518SM_FAN_COUNT	0x07
#define GL518SM_FAN_LIMIT	0x08
#define GL518SM_VIN1_LIMIT	0x09
#define GL518SM_VIN2_LIMIT	0x0a
#define GL518SM_VIN3_LIMIT	0x0b
#define GL518SM_VDD_LIMIT	0x0c
#define GL518SM_VOLTMETER	0x0d
#define GL518SM_MISC		0x0f
#define GL518SM_ALARM		0x10
#define GL518SM_MASK		0x11
#define GL518SM_INTSTAT		0x12

/* Sensors */
#define GLENV_VIN3		0
#define GLENV_TEMP		1
#define GLENV_FAN1		2
#define GLENV_FAN2		3
#define GLENV_NUM_SENSORS	4

struct glenv_softc {
	struct device sc_dev;

	i2c_tag_t sc_tag;
	i2c_addr_t sc_addr;

	struct ksensor sc_sensor[GLENV_NUM_SENSORS];
	struct ksensordev sc_sensordev;
	int	sc_fan1_div, sc_fan2_div;
};

int	glenv_match(struct device *, void *, void *);
void	glenv_attach(struct device *, struct device *, void *);

void	glenv_refresh(void *);

struct cfattach glenv_ca = {
	sizeof(struct glenv_softc), glenv_match, glenv_attach
};

struct cfdriver glenv_cd = {
	NULL, "glenv", DV_DULL
};

int
glenv_match(struct device *parent, void *match, void *aux)
{
	struct i2c_attach_args *ia = aux;

	if (strcmp(ia->ia_name, "gl518sm") == 0)
		return (1);
	return (0);
}

void
glenv_attach(struct device *parent, struct device *self, void *aux)
{
	struct glenv_softc *sc = (struct glenv_softc *)self;
	struct i2c_attach_args *ia = aux;
	u_int8_t cmd, data;
	int i;

	sc->sc_tag = ia->ia_tag;
	sc->sc_addr = ia->ia_addr;

	iic_acquire_bus(sc->sc_tag, 0);

	cmd = GL518SM_REVISION;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(": cannot read revision register\n");
		return;
	}
	
	printf(": GL518SM rev 0x%02x", data);

	cmd = GL518SM_MISC;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(", cannot read misc register\n");
		return;
	}
	sc->sc_fan1_div = 1 << ((data >> 6) & 0x03);
	sc->sc_fan2_div = 1 << ((data >> 4) & 0x03);

	cmd = GL518SM_CONFIG;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(", cannot read configuration register\n");
		return;
	}
	if (data & GL518SM_CONFIG_NOFAN2)
		sc->sc_fan2_div = 0;

	/* Start monitoring and clear interrupt status. */
	data = (data | GL518SM_CONFIG_START | GL518SM_CONFIG_CLEARST);
	if (iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
			iic_release_bus(sc->sc_tag, 0);
			printf(", cannot write configuration register\n");
			return;
	}

	iic_release_bus(sc->sc_tag, 0);

	/* Initialize sensor data. */
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_sensor[GLENV_VIN3].type = SENSOR_VOLTS_DC;

	sc->sc_sensor[GLENV_TEMP].type = SENSOR_TEMP;

	sc->sc_sensor[GLENV_FAN1].type = SENSOR_FANRPM;

	sc->sc_sensor[GLENV_FAN2].type = SENSOR_FANRPM;
	if (sc->sc_fan2_div == -1)
		sc->sc_sensor[GLENV_FAN2].flags |= SENSOR_FINVALID;

	if (sensor_task_register(sc, glenv_refresh, 5) == NULL) {
		printf(", unable to register update task\n");
		return;
	}

	for (i = 0; i < GLENV_NUM_SENSORS; i++)
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[i]);
	sensordev_install(&sc->sc_sensordev);

	printf("\n");
}

void
glenv_refresh(void *arg)
{
	struct glenv_softc *sc = arg;
	u_int8_t cmd, data, data2[2];
	u_int tmp;

	iic_acquire_bus(sc->sc_tag, 0);

	cmd = GL518SM_VOLTMETER;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		sc->sc_sensor[GLENV_VIN3].flags |= SENSOR_FINVALID;
	} else {
		sc->sc_sensor[GLENV_VIN3].flags &= ~SENSOR_FINVALID;
		sc->sc_sensor[GLENV_VIN3].value = data * 19000;
	}
	
	cmd = GL518SM_TEMP;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		sc->sc_sensor[GLENV_TEMP].flags |= SENSOR_FINVALID;
	} else {
		sc->sc_sensor[GLENV_TEMP].flags &= ~SENSOR_FINVALID;
		sc->sc_sensor[GLENV_TEMP].value =
			(data - 119) * 1000000 + 273150000;
	}

	cmd = GL518SM_FAN_COUNT;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data2, sizeof data2, 0)) {
		sc->sc_sensor[GLENV_FAN1].flags |= SENSOR_FINVALID;
		sc->sc_sensor[GLENV_FAN2].flags |= SENSOR_FINVALID;
	} else {
		sc->sc_sensor[GLENV_FAN1].flags &= ~SENSOR_FINVALID;
		tmp = data2[0] * sc->sc_fan1_div * 2;
		if (tmp == 0)
			sc->sc_sensor[GLENV_FAN1].flags |= SENSOR_FINVALID;
		else
			sc->sc_sensor[GLENV_FAN1].value = 960000 / tmp;

		sc->sc_sensor[GLENV_FAN2].flags &= ~SENSOR_FINVALID;
		tmp = data2[1] * sc->sc_fan2_div * 2;
		if (tmp == 0)
			sc->sc_sensor[GLENV_FAN2].flags |= SENSOR_FINVALID;
		else
			sc->sc_sensor[GLENV_FAN2].value = 960000 / tmp;
	}

	iic_release_bus(sc->sc_tag, 0);
}
@


1.5
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: gl518sm.c,v 1.4 2006/12/23 17:46:39 deraadt Exp $	*/
d158 1
a158 1
	if (sensor_task_register(sc, glenv_refresh, 5)) {
@


1.4
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: gl518sm.c,v 1.3 2006/01/26 22:25:34 kettenis Exp $	*/
d62 2
a63 2
	struct sensor sc_sensor[GLENV_NUM_SENSORS];
	struct sensordev sc_sensordev;
@


1.3
log
@Fix printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: gl518sm.c,v 1.2 2006/01/25 17:13:51 kettenis Exp $	*/
d63 1
d145 2
a146 3
	for (i = 0; i < GLENV_NUM_SENSORS; i++)
		strlcpy(sc->sc_sensor[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sc_sensor[i].device));
a148 2
	strlcpy(sc->sc_sensor[GLENV_VIN3].desc, "Vin3",
	    sizeof(sc->sc_sensor[GLENV_VIN3].desc));
a150 2
	strlcpy(sc->sc_sensor[GLENV_TEMP].desc, "Temp",
	    sizeof(sc->sc_sensor[GLENV_TEMP].desc));
a152 2
	strlcpy(sc->sc_sensor[GLENV_FAN1].desc, "Fan1",
	    sizeof(sc->sc_sensor[GLENV_FAN1].desc));
a154 2
	strlcpy(sc->sc_sensor[GLENV_FAN2].desc, "Fan2",
	    sizeof(sc->sc_sensor[GLENV_FAN2].desc));
d164 2
a165 1
		sensor_add(&sc->sc_sensor[i]);
@


1.2
log
@Prevent division by zero, and make it actually update the fan sensors.
@
text
@d1 1
a1 1
/*	$OpenBSD: gl518sm.c,v 1.1 2006/01/24 21:35:06 kettenis Exp $	*/
d110 1
a110 1
	printf("GL518SM rev 0x%2x", data);
@


1.1
log
@Initial stab at glenv(4), a driver for the GL518SM.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 1
a130 1
		sc->sc_fan2_div = -1;
d213 11
a223 6
		sc->sc_sensor[GLENV_TEMP].value = 960000 / tmp;
		if (sc->sc_fan2_div != -1) {
			sc->sc_sensor[GLENV_FAN2].flags &= ~SENSOR_FINVALID;
			tmp = data2[0] * sc->sc_fan2_div * 2;
			sc->sc_sensor[GLENV_TEMP].value = 960000 / tmp;
		}
@

