head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.40
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.36
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.26
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.34
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.32
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.30
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.28
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.24
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.22
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.20
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.18
	OPENBSD_5_0:1.21.0.16
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.14
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.12
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.8
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.10
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6;
locks; strict;
comment	@ * @;


1.21
date	2007.12.12.16.56.59;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.06.17.23.19;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.31.20.46.17;	author cnst;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.31.06.47.14;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.26.19.45.43;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.17.06.20.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.14.15.48.41;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.13.05.30.24;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.10.17.30.38;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.09.21.06.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.12.11.21.09;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.04.02.58.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.19.17.08.39;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.28.00.42.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.27.17.18.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.27.09.23.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.17.01.09.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.17.00.37.14;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@2nd two extra fans on the 5027 are encoded differently; diff
from remco@@d-compu.dyndns.org
@
text
@/*	$OpenBSD: adt7460.c,v 1.20 2007/12/06 17:23:19 deraadt Exp $	*/

/*
 * Copyright (c) 2005 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/sensors.h>

#include <dev/i2c/i2cvar.h>

/* ADT7460 registers */
#define ADT7460_2_5V		0x20
#define ADT7460_VCCP		0x21
#define ADT7460_VCC		0x22
#define ADT7460_V5		0x23
#define ADT7460_V12		0x24
#define ADT7460_VTR		0x99
#define ADT7460_VBAT		0x9a
#define ADT7460_REM1_TEMP	0x25
#define ADT7460_LOCAL_TEMP	0x26
#define ADT7460_REM2_TEMP	0x27
#define ADT7460_TACH1L		0x28
#define ADT7460_TACH1H		0x29
#define ADT7460_TACH2L		0x2a
#define ADT7460_TACH2H		0x2b
#define ADT7460_TACH3L		0x2c
#define ADT7460_TACH3H		0x2d
#define ADT7460_TACH4L		0x2e
#define ADT7460_TACH4H		0x2f
#define ADT7460_TACH5L		0xa9
#define ADT7460_TACH5H		0xaa
#define ADT7460_TACH6L		0xab
#define ADT7460_TACH6H		0xac
#define ADT7460_REVISION	0x3f
#define ADT7460_CONFIG		0x40
#define ADT7460_CONFIG_Vcc	0x80

/* Sensors */
#define ADT_2_5V		0
#define ADT_VCCP		1
#define ADT_VCC			2
#define ADT_V5			3
#define ADT_V12			4
#define ADT_VTR			5
#define ADT_VBAT		6
#define ADT_REM1_TEMP		7
#define ADT_LOCAL_TEMP		8
#define ADT_REM2_TEMP		9
#define ADT_TACH1		10
#define ADT_TACH2		11
#define ADT_TACH3		12
#define ADT_TACH4		13
#define ADT_TACH5		14
#define ADT_TACH6		15
#define ADT_NUM_SENSORS		16

struct adt_chip {
	const char	*name;
	short		ratio[7];
	int		type;
	short		vcc;
} adt_chips[] = {
	/* register	0x20  0x21  0x22  0x23  0x24  0xa8  0xaa	type	*/
	/* 		2.5v  vccp   vcc    5v   12v   vtr  vbat		*/

	{ "adt7460",	{ 2500,    0, 3300,    0,     0,    0,    0 },	7460,	5000 },
	{ "adt7467",	{ 2500, 2250, 3300, 5000, 12000,    0,    0 },	7467,	5000 },
	{ "adt7475",	{    0, 2250, 3300,    0,     0,    0,    0 },	7475,	   0 },
	{ "adt7476",	{ 2500, 2250, 3300, 5000, 12000,    0,    0 },	7476,	   0 },
	{ "adm1027",	{ 2500, 2250, 3300, 5000, 12000,    0,    0 },	1027,	5000 },
	{ "lm85",	{ 2500, 2250, 3300, 5000, 12000,    0,    0 },	7467,	   0 },
	{ "emc6d100",	{ 2500, 2250, 3300, 5000, 12000,    0,    0 },	6100,	   0 },
	{ "emc6w201",	{ 2500, 2250, 3300, 5000, 12000,    0,    0 },	6201,	   0 },
	{ "lm96000",	{ 2500, 2250, 3300, 5000, 12000,    0,    0 },	96000,	   0 },
	{ "sch5017",	{ 5000, 2250, 3300, 5000, 12000,    0,    0 },	5017,	   0 },
	{ "sch5027",	{ 5000, 2250, 3300, 5000, 12000, 3300, 3300 },	5027,	   0 }
};

struct {
	char		sensor;
	u_int8_t	cmd;
	u_short		index;
} worklist[] = {
	{ ADT_2_5V, ADT7460_2_5V, 32768 + 0 },
	{ ADT_VCCP, ADT7460_VCCP, 32768 + 1 },
	{ ADT_VCC, ADT7460_VCC, 32768 + 2 },
	{ ADT_V5, ADT7460_V5, 32768 + 3 },
	{ ADT_V12, ADT7460_V12, 32768 + 4 },
	{ ADT_VTR, ADT7460_VTR, 32768 + 5 },
	{ ADT_VBAT, ADT7460_VBAT, 32768 + 6 },
	{ ADT_REM1_TEMP, ADT7460_REM1_TEMP },
	{ ADT_LOCAL_TEMP, ADT7460_LOCAL_TEMP },
	{ ADT_REM2_TEMP, ADT7460_REM2_TEMP },
	{ ADT_TACH1, ADT7460_TACH1L },
	{ ADT_TACH2, ADT7460_TACH2L },
	{ ADT_TACH3, ADT7460_TACH3L },
	{ ADT_TACH4, ADT7460_TACH4L },
	{ ADT_TACH5, ADT7460_TACH5L },
	{ ADT_TACH6, ADT7460_TACH6L },
};

struct adt_softc {
	struct device sc_dev;
	i2c_tag_t sc_tag;
	i2c_addr_t sc_addr;
	u_int8_t sc_conf;
	struct adt_chip *chip;

	struct ksensor sc_sensor[ADT_NUM_SENSORS];
	struct ksensordev sc_sensordev;
};

int	adt_match(struct device *, void *, void *);
void	adt_attach(struct device *, struct device *, void *);

void	adt_refresh(void *);

struct cfattach adt_ca = {
	sizeof(struct adt_softc), adt_match, adt_attach
};

struct cfdriver adt_cd = {
	NULL, "adt", DV_DULL
};

int
adt_match(struct device *parent, void *match, void *aux)
{
	struct i2c_attach_args *ia = aux;
	int i;

	for (i = 0; i < sizeof(adt_chips) / sizeof(adt_chips[0]); i++)
		if (strcmp(ia->ia_name, adt_chips[i].name) == 0)
			return (1);
	return (0);
}

void
adt_attach(struct device *parent, struct device *self, void *aux)
{
	struct adt_softc *sc = (struct adt_softc *)self;
	struct i2c_attach_args *ia = aux;
	u_int8_t cmd, rev, data;
	int i;

	sc->sc_tag = ia->ia_tag;
	sc->sc_addr = ia->ia_addr;

	iic_acquire_bus(sc->sc_tag, 0);

	for (i = 0; i < sizeof(adt_chips) / sizeof(adt_chips[0]); i++) {
		if (strcmp(ia->ia_name, adt_chips[i].name) == 0) {
			sc->chip = &adt_chips[i];
			break;
		}
	}

	cmd = ADT7460_REVISION;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &rev, sizeof rev, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(": cannot read REV register\n");
		return;
	}

	cmd = ADT7460_CONFIG;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &sc->sc_conf, sizeof sc->sc_conf, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(": cannot read config register\n");
		return;
	}

	if (sc->chip->type == 7460) {
		data = 1;
		cmd = ADT7460_CONFIG;
		if (iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
		    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
			iic_release_bus(sc->sc_tag, 0);
			printf(": cannot set control register\n");
			return;
		}
	}

	iic_release_bus(sc->sc_tag, 0);

	printf(": %s rev 0x%02x", ia->ia_name, rev);

	/* Initialize sensor data. */
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_sensor[ADT_2_5V].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[ADT_2_5V].desc, "+2.5Vin",
	    sizeof(sc->sc_sensor[ADT_2_5V].desc));
		
	if (sc->chip->type == 5017)
		strlcpy(sc->sc_sensor[ADT_2_5V].desc, "+5VTR",
		    sizeof(sc->sc_sensor[ADT_2_5V].desc));
	if (sc->chip->type == 5027)
		strlcpy(sc->sc_sensor[ADT_2_5V].desc, "+5V",
		    sizeof(sc->sc_sensor[ADT_2_5V].desc));

	sc->sc_sensor[ADT_VCCP].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[ADT_VCCP].desc, "Vccp",
	    sizeof(sc->sc_sensor[ADT_VCCP].desc));

	sc->sc_sensor[ADT_VCC].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[ADT_VCC].desc, "Vcc",
	    sizeof(sc->sc_sensor[ADT_VCC].desc));

	sc->sc_sensor[ADT_V5].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[ADT_V5].desc, "+5V",
	    sizeof(sc->sc_sensor[ADT_V5].desc));

	sc->sc_sensor[ADT_V12].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[ADT_V12].desc, "+12V",
	    sizeof(sc->sc_sensor[ADT_V12].desc));

	sc->sc_sensor[ADT_VTR].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[ADT_VTR].desc, "+Vtr",
	    sizeof(sc->sc_sensor[ADT_VTR].desc));

	sc->sc_sensor[ADT_VBAT].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[ADT_VBAT].desc, "+Vbat",
	    sizeof(sc->sc_sensor[ADT_VBAT].desc));

	sc->sc_sensor[ADT_REM1_TEMP].type = SENSOR_TEMP;
	strlcpy(sc->sc_sensor[ADT_REM1_TEMP].desc, "Remote",
	    sizeof(sc->sc_sensor[ADT_REM1_TEMP].desc));

	sc->sc_sensor[ADT_LOCAL_TEMP].type = SENSOR_TEMP;
	strlcpy(sc->sc_sensor[ADT_LOCAL_TEMP].desc, "Internal",
	    sizeof(sc->sc_sensor[ADT_LOCAL_TEMP].desc));

	sc->sc_sensor[ADT_REM2_TEMP].type = SENSOR_TEMP;
	strlcpy(sc->sc_sensor[ADT_REM2_TEMP].desc, "Remote",
	    sizeof(sc->sc_sensor[ADT_REM2_TEMP].desc));

	sc->sc_sensor[ADT_TACH1].type = SENSOR_FANRPM;
	sc->sc_sensor[ADT_TACH2].type = SENSOR_FANRPM;
	sc->sc_sensor[ADT_TACH3].type = SENSOR_FANRPM;
	sc->sc_sensor[ADT_TACH4].type = SENSOR_FANRPM;
	sc->sc_sensor[ADT_TACH5].type = SENSOR_FANRPM;
	sc->sc_sensor[ADT_TACH6].type = SENSOR_FANRPM;

	if (sensor_task_register(sc, adt_refresh, 5) == NULL) {
		printf(", unable to register update task\n");
		return;
	}

	for (i = 0; i < ADT_NUM_SENSORS; i++) {
		if (worklist[i].index >= 32768 &&
		    sc->chip->ratio[worklist[i].index - 32768] == 0)
			continue;
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[i]);
	}
	sensordev_install(&sc->sc_sensordev);


	printf("\n");
}

void
adt_refresh(void *arg)
{
	struct adt_softc *sc = arg;
	u_int8_t cmd, data, data2;
	u_int16_t fan;
	int i, ratio;

	iic_acquire_bus(sc->sc_tag, 0);

	for (i = 0; i < sizeof worklist / sizeof(worklist[0]); i++) {

		if (worklist[i].index >= 32768) {
			ratio = sc->chip->ratio[worklist[i].index - 32768];
			if (ratio == 0)	/* do not read a dead register */
				continue;
		}
		cmd = worklist[i].cmd;
		if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
		    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
			sc->sc_sensor[i].flags |= SENSOR_FINVALID;
			continue;
		}

		sc->sc_sensor[i].flags &= ~SENSOR_FINVALID;
		switch (worklist[i].sensor) {
		case ADT_VCC:
			if (sc->chip->vcc && (sc->sc_conf & ADT7460_CONFIG_Vcc))
				ratio = sc->chip->vcc;
			/* FALLTHROUGH */
		case ADT_2_5V:
		case ADT_VCCP:
		case ADT_V5:
		case ADT_V12:
		case ADT_VTR:
		case ADT_VBAT:
			sc->sc_sensor[i].value = ratio * 1000 * (u_int)data / 192;
			break;
		case ADT_LOCAL_TEMP:
		case ADT_REM1_TEMP:
		case ADT_REM2_TEMP:
			if (data == 0x80)
				sc->sc_sensor[i].flags |= SENSOR_FINVALID;
			else
				sc->sc_sensor[i].value =
				    (int8_t)data * 1000000 + 273150000;
			break;
		case ADT_TACH1:
		case ADT_TACH2:
		case ADT_TACH3:
		case ADT_TACH4:
			cmd = worklist[i].cmd + 1; /* TACHnH follows TACHnL */
			if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
			    sc->sc_addr, &cmd, sizeof cmd, &data2, sizeof data2, 0)) {
				sc->sc_sensor[i].flags |= SENSOR_FINVALID;
				continue;
			}

			fan = data + (data2 << 8);
			if (fan == 0 || fan == 0xffff)
				sc->sc_sensor[i].flags |= SENSOR_FINVALID;
			else
				sc->sc_sensor[i].value = (90000 * 60) / fan;
			break;
		case ADT_TACH5:
		case ADT_TACH6:
			if (sc->chip->type != 5027) {
				sc->sc_sensor[i].flags |= SENSOR_FINVALID;
				break;	/* only 5027 has these fans? */
			}
			cmd = worklist[i].cmd + 1; /* TACHnH follows TACHnL */
			if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
			    sc->sc_addr, &cmd, sizeof cmd, &data2, sizeof data2, 0)) {
				sc->sc_sensor[i].flags |= SENSOR_FINVALID;
				continue;
			}

			fan = data + (data2 << 8);
			if (fan == 0 || fan == 0xffff)
				sc->sc_sensor[i].flags |= SENSOR_FINVALID;
			else
				sc->sc_sensor[i].value = fan * 60;
			break;
		default:
			sc->sc_sensor[i].flags |= SENSOR_FINVALID;
			break;
		}
	}

	iic_release_bus(sc->sc_tag, 0);
}
@


1.20
log
@support sch5027 which has two extra fans and slightly different voltage
readings; from remco@@d-compu.dyndns.org
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.19 2007/10/31 20:46:17 cnst Exp $	*/
d45 4
a48 4
#define ADT7460_TACH5L		0xa8
#define ADT7460_TACH5H		0xa9
#define ADT7460_TACH6L		0xaa
#define ADT7460_TACH6H		0xab
d91 1
a91 1
	{ "sch5027",	{ 1500, 2250, 3300, 5000, 12000, 3300, 3300 },	5027,	   0 }
d216 1
a216 1
		strlcpy(sc->sc_sensor[ADT_2_5V].desc, "+1.5V",
a325 5
		case ADT_TACH5:
		case ADT_TACH6:
			if (sc->chip->type != 5027)
				goto nonexistant; /* only 5027 has these fans? */
			/* FALLTHROUGH */
d343 19
a361 1
		nonexistant:
@


1.19
log
@don't clear sensor flags that were never set; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.18 2007/06/24 05:34:35 dlg Exp $	*/
d32 2
d45 4
d59 12
a70 8
#define ADT_REM1_TEMP		5
#define ADT_LOCAL_TEMP		6
#define ADT_REM2_TEMP		7
#define ADT_TACH1		8
#define ADT_TACH2		9
#define ADT_TACH3		10
#define ADT_TACH4		11
#define ADT_NUM_SENSORS		12
d74 1
a74 1
	short		ratio[5];
d78 2
a79 2
	/* register	0x20  0x21  0x22  0x23  0x24	type	*/
	/* 		2.5v  vccp   vcc    5v   12v		*/
d81 11
a91 10
	{ "adt7460",	{ 2500,    0, 3300,    0,     0 },	7460,	5000 },
	{ "adt7467",	{ 2500, 2250, 3300, 5000, 12000 },	7467,	5000 },
	{ "adt7475",	{    0, 2250, 3300,    0,     0 },	7475,	   0 },
	{ "adt7476",	{ 2500, 2250, 3300, 5000, 12000 },	7476,	   0 },
	{ "adm1027",	{ 2500, 2250, 3300, 5000, 12000 },	1027,	5000 },
	{ "lm85",	{ 2500, 2250, 3300, 5000, 12000 },	7467,	   0 },
	{ "emc6d100",	{ 2500, 2250, 3300, 5000, 12000 },	6100,	   0 },
	{ "emc6w201",	{ 2500, 2250, 3300, 5000, 12000 },	6201,	   0 },
	{ "lm96000",	{ 2500, 2250, 3300, 5000, 12000 },	96000,	   0 },
	{ "sch5017",	{ 5000, 2250, 3300, 5000, 12000 },	5017,	   0 }
d104 2
d113 2
d215 3
d235 8
d259 2
d313 2
d326 5
d348 1
@


1.18
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.17 2007/03/22 16:55:31 deraadt Exp $	*/
a242 1
		sc->sc_sensor[i].flags &= ~SENSOR_FINVALID;
@


1.17
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.16 2006/12/31 06:47:14 deraadt Exp $	*/
d234 1
a234 1
	if (sensor_task_register(sc, adt_refresh, 5)) {
@


1.16
log
@correct the code to handle the adt7475, which stupidly is missing some
of the registers.... tested by dhartmei and others
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.15 2006/12/26 19:45:43 deraadt Exp $	*/
d109 2
a110 2
	struct sensor sc_sensor[ADT_NUM_SENSORS];
	struct sensordev sc_sensordev;
@


1.15
log
@support adt7475; tested by dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.14 2006/12/23 17:46:39 deraadt Exp $	*/
d83 19
d196 1
d240 3
a250 19

struct {
	char		sensor;
	u_int8_t	cmd;
	u_short		index;
} worklist[] = {
	{ ADT_2_5V, ADT7460_2_5V, 32768 + 0 },
	{ ADT_VCCP, ADT7460_VCCP, 32768 + 1 },
	{ ADT_VCC, ADT7460_VCC, 32768 + 2 },
	{ ADT_V5, ADT7460_V5, 32768 + 3 },
	{ ADT_V12, ADT7460_V12, 32768 + 4 },
	{ ADT_REM1_TEMP, ADT7460_REM1_TEMP },
	{ ADT_LOCAL_TEMP, ADT7460_LOCAL_TEMP },
	{ ADT_REM2_TEMP, ADT7460_REM2_TEMP },
	{ ADT_TACH1, ADT7460_TACH1L },
	{ ADT_TACH2, ADT7460_TACH2L },
	{ ADT_TACH3, ADT7460_TACH3L },
	{ ADT_TACH4, ADT7460_TACH4L },
};
@


1.14
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.13 2006/04/17 06:20:00 deraadt Exp $	*/
d73 1
d232 1
a232 1
	u_char		index;
d234 5
a238 5
	{ ADT_2_5V, ADT7460_2_5V, 0 },
	{ ADT_VCCP, ADT7460_VCCP, 1 },
	{ ADT_VCC, ADT7460_VCC, 2 },
	{ ADT_V5, ADT7460_V5, 3 },
	{ ADT_V12, ADT7460_V12, 4 },
d260 5
a264 2
		if (sc->chip->ratio[worklist[i].index] == 0)
			continue;
a272 1
		ratio = sc->chip->ratio[worklist[i].index];
@


1.13
log
@looks like 0x20 on sch5017 is a 5v input, not 2.5v
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.12 2006/04/14 15:48:41 deraadt Exp $	*/
d90 1
d170 2
a171 3
	for (i = 0; i < ADT_NUM_SENSORS; i++)
		strlcpy(sc->sc_sensor[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sc_sensor[i].device));
d197 1
a197 1
	strlcpy(sc->sc_sensor[ADT_REM1_TEMP].desc, "Remote1 Temp",
d201 1
a201 1
	strlcpy(sc->sc_sensor[ADT_LOCAL_TEMP].desc, "Internal Temp",
d205 1
a205 1
	strlcpy(sc->sc_sensor[ADT_REM2_TEMP].desc, "Remote2 Temp",
a208 3
	strlcpy(sc->sc_sensor[ADT_TACH1].desc, "TACH1",
	    sizeof(sc->sc_sensor[ADT_TACH1].desc));

a209 3
	strlcpy(sc->sc_sensor[ADT_TACH2].desc, "TACH2",
	    sizeof(sc->sc_sensor[ADT_TACH2].desc));

a210 3
	strlcpy(sc->sc_sensor[ADT_TACH3].desc, "TACH3",
	    sizeof(sc->sc_sensor[ADT_TACH3].desc));

a211 2
	strlcpy(sc->sc_sensor[ADT_TACH4].desc, "TACH4",
	    sizeof(sc->sc_sensor[ADT_TACH4].desc));
d220 1
a220 1
		sensor_add(&sc->sc_sensor[i]);
d222 2
@


1.12
log
@fix +12v conversion, because of stupid C; wilfried
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.11 2006/04/13 05:30:24 deraadt Exp $	*/
d64 3
a66 3
	short	ratio[5];
	int	type;
	short	vcc;
d79 1
a79 1
	{ "sch5017",	{ 2500, 2250, 3300, 5000, 12000 },	5017,	   0 }
a85 1
	int	sc_chip;
d153 1
a153 1
	if (sc->sc_chip == 7460) {
d176 3
@


1.11
log
@various changes to the table-driven code as a result of conversations
with wilfried.  unfortunately days have gone by without him (or
others) saying that it works fine.  in it goes.  maybe it will crash
for someone?
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.10 2006/04/10 17:30:38 deraadt Exp $	*/
d286 1
a286 1
			sc->sc_sensor[i].value = ratio * 1000 * data / 192;
@


1.10
log
@sch5017 is an adt7460 clone of some type.  also, we are seeing some
ways to determine the actual voltage multipliers, so move to a table
driven model, which we can tweak as we see more varients.  checked
by kettenis jolan and roman
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.9 2006/04/09 21:06:33 deraadt Exp $	*/
d64 3
a66 2
	short	v25, vccp, vcc, v5, v12;
	short	type;
d71 9
a79 9
	{ "adt7460",	2500, 2700, 3300, 5000, 12000,	7460 },
	{ "adt7467",	2500, 2700, 3300, 5000, 12000,	7467 },
	{ "adt7476",	2500, 2700, 3300, 5000, 12000,	7467 },
	{ "adm1027",	2500, 2250, 3300, 5000, 12000,	1027 },
	{ "lm85",	2500, 2700, 3300, 5000, 12000,	7467 },
	{ "emc6d100",	2500, 2700, 3300, 5000, 12000,	7460 },
	{ "emc6w201",	2500, 2700, 3300, 5000, 12000,	7460 },
	{ "lm96000",	2500, 2700, 3300, 5000, 12000,	7460 },
	{ "sch5017",	2500, 2250, 3300, 5000, 12000,	7460 }
a81 4
struct adt_chip adt_chips_adm1027_vcc5 =
	{ "adm1027",	2500, 2250, 5000, 5000, 12000,  7460 };


d87 1
a87 1
	u_int8_t sc_config;
d123 1
a123 1
	u_int8_t cmd, rev, data, conf;
d148 1
a148 1
	    sc->sc_addr, &cmd, sizeof cmd, &conf, sizeof conf, 0)) {
a153 4
	/* check if adm1027 is running in V5 mode */
	if (sc->sc_chip == 1027 && (conf & ADT7460_CONFIG_Vcc))
		sc->chip = &adt_chips_adm1027_vcc5;

d227 2
a228 1
	for (i = 0; i < ADT_NUM_SENSORS; i++)
d230 1
d238 1
d240 5
a244 5
	{ ADT_2_5V, ADT7460_2_5V },
	{ ADT_VCCP, ADT7460_VCCP },
	{ ADT_VCC, ADT7460_VCC },
	{ ADT_V5, ADT7460_V5 },
	{ ADT_V12, ADT7460_V12 },
d260 1
a260 1
	int i;
d265 3
d276 1
d278 4
a282 3
			sc->sc_sensor[i].value = sc->chip->v25 * 1000 *
			    data / 192;
			break;
a283 7
			sc->sc_sensor[i].value = sc->chip->vccp * 1000 *
			    data / 192;
			break;
		case ADT_VCC:
			sc->sc_sensor[i].value = sc->chip->vcc * 1000 *
			    data / 192;
			break;
a284 3
			sc->sc_sensor[i].value = sc->chip->v5 * 1000 *
			    data / 192;
			break;
d286 1
a286 2
			sc->sc_sensor[i].value = sc->chip->v12 * 1000 *
			    data / 192;
@


1.9
log
@slightly nicer sensor names
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.8 2006/03/12 11:21:09 kettenis Exp $	*/
d28 4
a31 1
#define ADT7460_VCCP1		0x22
d45 1
d49 35
a83 9
#define ADT_VCCP1		1
#define ADT_REM1_TEMP		2
#define ADT_LOCAL_TEMP		3
#define ADT_REM2_TEMP		4
#define ADT_TACH1		5
#define ADT_TACH2		6
#define ADT_TACH3		7
#define ADT_TACH4		8
#define ADT_NUM_SENSORS		9
d90 2
d113 1
d115 3
a117 9
	if (strcmp(ia->ia_name, "adt7460") == 0 ||
	    strcmp(ia->ia_name, "adt7467") == 0 ||
	    strcmp(ia->ia_name, "adt7476") == 0 ||
	    strcmp(ia->ia_name, "adm1027") == 0 ||
	    strcmp(ia->ia_name, "lm85") == 0 ||
	    strcmp(ia->ia_name, "lm96000") == 0 ||
	    strcmp(ia->ia_name, "emc6d100") == 0 ||
	    strcmp(ia->ia_name, "emc6w201") == 0)
		return (1);
d126 1
a126 1
	u_int8_t cmd, rev, data;
d134 6
a139 5
	sc->sc_chip = 7460;
	/* check for the fancy "extension" chips XXX */
	if (strcmp(ia->ia_name, "adt7467") == 0 ||
	    strcmp(ia->ia_name, "adt7467") == 0)
		sc->sc_chip = 7467;
d149 12
d174 1
a174 1
	printf(": %s (ADT%d) rev 0x%02x", ia->ia_name, sc->sc_chip, rev);
d185 15
a199 3
	sc->sc_sensor[ADT_VCCP1].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[ADT_VCCP1].desc, "Vccp1",
	    sizeof(sc->sc_sensor[ADT_VCCP1].desc));
d218 1
a218 1
	strlcpy(sc->sc_sensor[ADT_TACH2].desc, "TACH1",
d222 1
a222 1
	strlcpy(sc->sc_sensor[ADT_TACH3].desc, "TACH1",
d226 1
a226 1
	strlcpy(sc->sc_sensor[ADT_TACH4].desc, "TACH1",
d245 4
a248 1
	{ ADT_VCCP1, ADT7460_VCCP1 },
d279 14
a292 1
			sc->sc_sensor[i].value = 2500000 * data / 192;
d294 3
a296 2
		case ADT_VCCP1:
			sc->sc_sensor[i].value = 2700000 * data / 192;
@


1.8
log
@Match emc6d100 and emc6w201.  Fix typo.  print rev with 0x prefix.
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.7 2006/03/04 02:58:14 deraadt Exp $	*/
d150 1
a150 1
	strlcpy(sc->sc_sensor[ADT_REM1_TEMP].desc, "Rem1 Temp.",
d154 1
a154 1
	strlcpy(sc->sc_sensor[ADT_LOCAL_TEMP].desc, "Int. Temp.",
d158 1
a158 1
	strlcpy(sc->sc_sensor[ADT_REM2_TEMP].desc, "Rem2 Temp.",
@


1.7
log
@handle lm96000 (another similar chip); ok kettenis, tested by stu@@spacehopper.org
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.6 2006/01/19 17:08:39 grange Exp $	*/
d87 3
a89 2
	    strcmp(ia->ia_name, "emc6d10x") == 0 ||
	    strcmp(ia->ia_name, "lm96000") == 0)
d134 1
a134 1
	printf(": %s (ADT%d) rev %x", ia->ia_name, sc->sc_chip, rev);
d158 1
a158 1
	strlcpy(sc->sc_sensor[ADT_REM2_TEMP].desc, "Rem1 Temp.",
@


1.6
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.5 2005/12/28 00:42:14 deraadt Exp $	*/
d87 2
a88 1
	    strcmp(ia->ia_name, "emc6d10x") == 0)
@


1.5
log
@golly gee, adm1027 looks a lot like adt7460
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.4 2005/12/27 17:18:18 deraadt Exp $	*/
d181 1
a181 1
		SENSOR_ADD(&sc->sc_sensor[i]);
@


1.4
log
@no longer use ia_compat; tested by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.3 2005/12/27 09:23:28 deraadt Exp $	*/
d85 1
@


1.3
log
@match about 15 more clone chips
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.2 2005/11/17 01:09:36 deraadt Exp $	*/
d82 7
a88 10
	if (ia->ia_compat) {
		if (strcmp(ia->ia_compat, "adt7460") == 0 ||
		    strcmp(ia->ia_compat, "adt7467") == 0 ||
		    strcmp(ia->ia_compat, "adt7476") == 0 ||
		    strcmp(ia->ia_compat, "lm85") == 0 ||
		    strcmp(ia->ia_compat, "emc6d10x") == 0)
			return (1);
		return (0);
	}
	return (1);	/* accept the address given */
d106 2
a107 3
	if (ia->ia_compat &&
	    (strcmp(ia->ia_compat, "adt7467") == 0 ||
	    strcmp(ia->ia_compat, "adt7467") == 0))
d131 1
a131 1
	printf(": ADT%d rev %x", sc->sc_chip, rev);
@


1.2
log
@grok adt7467 somewhat, and fan disconnects
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.1 2005/11/17 00:37:14 deraadt Exp $	*/
d84 4
a87 1
		    strcmp(ia->ia_compat, "adt7467") == 0)
d108 4
a111 1
	if (ia->ia_compat && strcmp(ia->ia_compat, "adt7467") == 0)
@


1.1
log
@basic driver for adt7460 found in some machines
@
text
@d1 1
a1 1
/*	$OpenBSD: adt7460.c,v 1.6 2005/11/15 22:01:36 deraadt Exp $	*/
d41 1
d59 1
d83 2
a84 1
		if (strcmp(ia->ia_compat, "adt7460") == 0)
d96 1
a96 1
	u_int8_t cmd, rev;
d104 4
d116 11
d129 1
a129 1
	printf(": ADT7460 rev %x", rev);
d245 1
a245 1
			if (fan == 0)
@

