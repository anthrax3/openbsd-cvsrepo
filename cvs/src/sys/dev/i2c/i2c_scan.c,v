head	1.145;
access;
symbols
	OPENBSD_6_0:1.145.0.6
	OPENBSD_6_0_BASE:1.145
	OPENBSD_5_9:1.145.0.2
	OPENBSD_5_9_BASE:1.145
	OPENBSD_5_8:1.145.0.4
	OPENBSD_5_8_BASE:1.145
	OPENBSD_5_7:1.143.0.4
	OPENBSD_5_7_BASE:1.143
	OPENBSD_5_6:1.140.0.14
	OPENBSD_5_6_BASE:1.140
	OPENBSD_5_5:1.140.0.12
	OPENBSD_5_5_BASE:1.140
	OPENBSD_5_4:1.140.0.8
	OPENBSD_5_4_BASE:1.140
	OPENBSD_5_3:1.140.0.6
	OPENBSD_5_3_BASE:1.140
	OPENBSD_5_2:1.140.0.4
	OPENBSD_5_2_BASE:1.140
	OPENBSD_5_1_BASE:1.140
	OPENBSD_5_1:1.140.0.2
	OPENBSD_5_0:1.139.0.2
	OPENBSD_5_0_BASE:1.139
	OPENBSD_4_9:1.137.0.4
	OPENBSD_4_9_BASE:1.137
	OPENBSD_4_8:1.137.0.2
	OPENBSD_4_8_BASE:1.137
	OPENBSD_4_7:1.135.0.2
	OPENBSD_4_7_BASE:1.135
	OPENBSD_4_6:1.131.0.4
	OPENBSD_4_6_BASE:1.131
	OPENBSD_4_5:1.130.0.2
	OPENBSD_4_5_BASE:1.130
	OPENBSD_4_4:1.126.0.2
	OPENBSD_4_4_BASE:1.126
	OPENBSD_4_3:1.112.0.2
	OPENBSD_4_3_BASE:1.112
	OPENBSD_4_2:1.97.0.2
	OPENBSD_4_2_BASE:1.97
	OPENBSD_4_1:1.96.0.2
	OPENBSD_4_1_BASE:1.96
	OPENBSD_4_0:1.89.0.2
	OPENBSD_4_0_BASE:1.89
	OPENBSD_3_9:1.71.0.2
	OPENBSD_3_9_BASE:1.71;
locks; strict;
comment	@ * @;


1.145
date	2015.05.29.00.37.10;	author uebayasi;	state Exp;
branches;
next	1.144;
commitid	fK1KUxmxCh2v4tEt;

1.144
date	2015.05.29.00.33.37;	author uebayasi;	state Exp;
branches;
next	1.143;
commitid	k9pN2wgTn5cUwDek;

1.143
date	2014.11.14.07.03.22;	author jsg;	state Exp;
branches;
next	1.142;
commitid	naCzHMrBA7BDJc1u;

1.142
date	2014.09.27.06.07.01;	author jsg;	state Exp;
branches;
next	1.141;
commitid	wVbow7LwU9NDbltA;

1.141
date	2014.09.26.15.24.56;	author jsg;	state Exp;
branches;
next	1.140;
commitid	p7OsLSLoJ80QEHL2;

1.140
date	2011.10.07.06.29.43;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2011.05.26.01.40.33;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	2011.03.10.23.14.30;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2010.07.09.08.05.45;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2010.03.22.23.17.34;	author kettenis;	state Exp;
branches;
next	1.135;

1.135
date	2009.12.28.05.04.38;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2009.08.12.14.51.20;	author cnst;	state Exp;
branches;
next	1.133;

1.133
date	2009.07.10.19.58.41;	author cnst;	state Exp;
branches;
next	1.132;

1.132
date	2009.07.10.00.17.30;	author cnst;	state Exp;
branches;
next	1.131;

1.131
date	2009.03.14.06.31.48;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2009.02.19.23.09.17;	author jsg;	state Exp;
branches;
next	1.129;

1.129
date	2008.12.12.23.38.23;	author jsg;	state Exp;
branches;
next	1.128;

1.128
date	2008.11.13.17.57.15;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2008.11.03.00.17.47;	author cnst;	state Exp;
branches;
next	1.126;

1.126
date	2008.04.22.02.22.54;	author cnst;	state Exp;
branches;
next	1.125;

1.125
date	2008.04.20.00.22.39;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2008.04.18.19.28.44;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2008.04.18.18.51.01;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2008.04.17.19.01.48;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2008.04.10.17.14.09;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2008.04.09.22.04.10;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2008.04.09.21.56.40;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2008.04.07.00.31.07;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2008.04.01.04.18.17;	author cnst;	state Exp;
branches;
next	1.116;

1.116
date	2008.04.01.03.28.32;	author cnst;	state Exp;
branches;
next	1.115;

1.115
date	2008.04.01.01.10.49;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2008.03.27.05.46.09;	author cnst;	state Exp;
branches;
next	1.113;

1.113
date	2008.03.19.21.01.10;	author cnst;	state Exp;
branches;
next	1.112;

1.112
date	2007.12.05.16.35.14;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2007.10.30.07.10.34;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2007.10.25.03.36.01;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2007.10.24.20.15.29;	author cnst;	state Exp;
branches;
next	1.108;

1.108
date	2007.10.24.20.08.03;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2007.10.24.19.56.06;	author cnst;	state Exp;
branches;
next	1.106;

1.106
date	2007.10.24.18.32.31;	author cnst;	state Exp;
branches;
next	1.105;

1.105
date	2007.10.18.11.03.09;	author jsg;	state Exp;
branches;
next	1.104;

1.104
date	2007.10.17.17.29.54;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2007.10.11.20.48.21;	author cnst;	state Exp;
branches;
next	1.102;

1.102
date	2007.10.09.16.57.47;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.07.14.26.41;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2007.09.05.17.22.08;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2007.09.03.19.05.05;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2007.09.03.19.04.43;	author kettenis;	state Exp;
branches;
next	1.97;

1.97
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2007.01.05.19.25.45;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2006.12.26.19.57.17;	author kettenis;	state Exp;
branches;
next	1.94;

1.94
date	2006.12.25.21.25.39;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2006.11.19.16.40.02;	author kettenis;	state Exp;
branches;
next	1.92;

1.92
date	2006.11.19.16.16.22;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2006.11.01.22.24.20;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2006.09.26.23.48.56;	author jsg;	state Exp;
branches;
next	1.89;

1.89
date	2006.08.29.18.39.39;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2006.08.18.17.35.19;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2006.07.15.19.39.56;	author kettenis;	state Exp;
branches;
next	1.86;

1.86
date	2006.07.12.15.35.40;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2006.07.12.12.39.13;	author kettenis;	state Exp;
branches;
next	1.84;

1.84
date	2006.07.12.12.34.32;	author kettenis;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.14.20.42.36;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2006.04.29.12.04.26;	author djm;	state Exp;
branches;
next	1.81;

1.81
date	2006.04.17.18.33.00;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2006.03.22.21.03.40;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2006.03.19.18.19.35;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.19.04.02.22;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.18.23.06.47;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2006.03.12.11.18.51;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.07.22.36.39;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2006.03.07.21.27.52;	author kettenis;	state Exp;
branches;
next	1.73;

1.73
date	2006.03.04.12.18.58;	author kettenis;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.04.02.58.14;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2006.02.26.18.38.53;	author grange;	state Exp;
branches;
next	1.70;

1.70
date	2006.02.25.21.38.56;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2006.02.25.17.58.01;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2006.02.08.23.15.58;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2006.02.08.19.02.37;	author kettenis;	state Exp;
branches;
next	1.66;

1.66
date	2006.02.04.18.19.20;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2006.01.29.12.48.27;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2006.01.28.15.55.35;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2006.01.28.11.26.51;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2006.01.23.23.07.01;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2006.01.18.21.53.22;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2006.01.17.21.21.56;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2006.01.15.12.15.17;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2006.01.14.22.23.54;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2006.01.13.02.21.46;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2006.01.13.01.44.59;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.12.00.12.37;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.11.20.18.58;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.09.18.50.23;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.06.01.48.45;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.05.23.00.40;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2006.01.04.18.36.22;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.04.18.14.47;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.03.07.55.47;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2005.12.31.20.54.50;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.31.18.34.26;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.31.18.26.11;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.31.04.31.20;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.31.02.50.32;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.31.00.52.42;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.30.23.19.51;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.30.17.39.33;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.30.09.45.20;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.30.04.05.30;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.29.16.08.03;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.29.14.51.08;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.29.09.20.04;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.29.01.25.31;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.28.23.05.38;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.28.22.35.33;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.28.22.30.53;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.28.20.35.59;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.28.01.02.58;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.27.22.49.57;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.27.22.14.23;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.27.21.51.03;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.27.21.42.07;	author grange;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.27.21.22.36;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.27.19.46.28;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.27.17.18.18;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.27.09.23.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.27.03.46.50;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.26.17.52.12;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.26.08.14.17;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.25.12.41.40;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.25.12.32.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.24.23.29.22;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.24.22.08.17;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.24.19.33.40;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.23.22.56.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.23.21.23.43;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.23.20.54.24;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.23.20.51.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.23.15.53.35;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.23.15.09.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.23.15.06.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.23.07.07.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.23.04.09.56;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.23.03.04.39;	author pedro;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.20.05.00.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.19.19.36.46;	author grange;	state Exp;
branches;
next	;


desc
@@


1.145
log
@Revert unrelated changes in previous.
@
text
@/*	$OpenBSD$	*/

/*
 * Copyright (c) 2005 Theo de Raadt <deraadt@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * I2C bus scanning.  We apologize in advance for the massive overuse of 0x.
 */

#include "ipmi.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#define _I2C_PRIVATE
#include <dev/i2c/i2cvar.h>

#undef I2C_DEBUG
#define I2C_VERBOSE

#define MAX_IGNORE 8
u_int8_t ignore_addrs[MAX_IGNORE];

struct iicprobelist {
	u_int8_t start, end;
};

/*
 * Addresses at which to probe for sensors.  Skip address 0x4f, since
 * probing it seems to crash at least one Sony VAIO laptop.  Only a
 * few chips can actually sit at that address, and vendors seem to
 * place those at other addresses, so this isn't a big loss.
 */
struct iicprobelist probe_addrs_sensor[] = {
	{ 0x18, 0x1f },
	{ 0x20, 0x2f },
	{ 0x48, 0x4e },
	{ 0, 0 }
};

/*
 * Addresses at which to probe for eeprom devices.
 */
struct iicprobelist probe_addrs_eeprom[] = {
	{ 0x50, 0x57 },
	{ 0, 0 }
};

char 	*iic_probe_sensor(struct device *, u_int8_t);
char	*iic_probe_eeprom(struct device *, u_int8_t);

#define PFLAG_SENSOR	1
static struct {
	struct iicprobelist *pl;
	char	*(*probe)(struct device *, u_int8_t);
	int	flags;
} probes[] = {
	{ probe_addrs_sensor, iic_probe_sensor, PFLAG_SENSOR },
	{ probe_addrs_eeprom, iic_probe_eeprom, 0 },
	{ NULL, NULL }
};

/*
 * Some Maxim 1617 clones MAY NOT even read cmd 0xfc!  When it is
 * read, they will power-on-reset.  Their default condition
 * (control register bit 0x80) therefore will be that they assert
 * /ALERT for the 5 potential errors that may occur.  One of those
 * errors is that the external temperature diode is missing.  This
 * is unfortunately a common choice of system designers, except
 * suddenly now we get a /ALERT, which may on some chipsets cause
 * us to receive an entirely unexpected SMI .. and then an NMI.
 *
 * As we probe each device, if we hit something which looks suspiciously
 * like it may potentially be a 1617 or clone, we immediately set this
 * variable to avoid reading that register offset.
 */
int	skip_fc;

static i2c_tag_t probe_ic;
static u_int8_t probe_addr;
static u_int8_t probe_val[256];

void		iicprobeinit(struct i2cbus_attach_args *, u_int8_t);
u_int8_t	iicprobenc(u_int8_t);
u_int8_t	iicprobe(u_int8_t);
u_int16_t	iicprobew(u_int8_t);
char		*lm75probe(void);
char		*adm1032cloneprobe(u_int8_t);
void		iic_dump(struct device *, u_int8_t, char *);

void
iicprobeinit(struct i2cbus_attach_args *iba, u_int8_t addr)
{
	probe_ic = iba->iba_tag;
	probe_addr = addr;
	memset(probe_val, 0xff, sizeof probe_val);
}

u_int8_t
iicprobenc(u_int8_t cmd)
{
	u_int8_t data;

	/*
	 * If we think we are talking to an evil Maxim 1617 or clone,
	 * avoid accessing this register because it is death.
	 */
	if (skip_fc && cmd == 0xfc)
		return (0xff);
	iic_acquire_bus(probe_ic, 0);
	if (iic_exec(probe_ic, I2C_OP_READ_WITH_STOP,
	    probe_addr, &cmd, sizeof cmd, &data, sizeof data, 0) != 0)
		data = 0xff;
	iic_release_bus(probe_ic, 0);
	return (data);
}

u_int16_t
iicprobew(u_int8_t cmd)
{
	u_int16_t data;

	/*
	 * If we think we are talking to an evil Maxim 1617 or clone,
	 * avoid accessing this register because it is death.
	 */
	if (skip_fc && cmd == 0xfc)
		return (0xffff);
	iic_acquire_bus(probe_ic, 0);
	if (iic_exec(probe_ic, I2C_OP_READ_WITH_STOP,
	    probe_addr, &cmd, sizeof cmd, &data, sizeof data, 0) != 0)
		data = 0xffff;
	iic_release_bus(probe_ic, 0);
	return betoh16(data);
}

u_int8_t
iicprobe(u_int8_t cmd)
{
	if (probe_val[cmd] != 0xff)
		return probe_val[cmd];
	probe_val[cmd] = iicprobenc(cmd);
	return (probe_val[cmd]);
}

#define LM75TEMP	0x00
#define LM75CONF	0x01
#define LM75Thyst	0x02
#define LM75Tos		0x03
#define LM77Tlow	0x04
#define LM77Thigh	0x05
#define LM75TMASK	0xff80	/* 9 bits in temperature registers */
#define LM77TMASK	0xfff8	/* 13 bits in temperature registers */

/*
 * The LM75/LM75A/LM77 family are very hard to detect.  Thus, we check
 * for all other possible chips first.  These chips do not have an
 * ID register.  They do have a few quirks though:
 * -  on the LM75 and LM77, registers 0x06 and 0x07 return whatever
 *    value was read before
 * -  the LM75 lacks registers 0x04 and 0x05, so those act as above
 * -  the LM75A returns 0xffff for registers 0x04, 0x05, 0x06 and 0x07
 * -  the chip registers loop every 8 registers
 * The downside is that we must read almost every register to guess
 * if this is an LM75, LM75A or LM77.
 */
char *
lm75probe(void)
{
	u_int16_t temp, thyst, tos, tlow, thigh, mask = LM75TMASK;
	u_int8_t conf;
	int i, echocount, ffffcount, score;
	int echoreg67, echoreg45, ffffreg67, ffffreg45;

	temp = iicprobew(LM75TEMP);

	/*
	 * Sometimes the other probes can upset the chip, if we get 0xffff
	 * the first time, try it once more.
	 */
	if (temp == 0xffff)
		temp = iicprobew(LM75TEMP);

	conf = iicprobenc(LM75CONF);
	thyst = iicprobew(LM75Thyst);
	tos = iicprobew(LM75Tos);

	/* totally bogus data */
	if (conf == 0xff && temp == 0xffff && thyst == 0xffff)
		return (NULL);

	temp &= mask;
	thyst &= mask;
	tos &= mask;

	/* All values the same?  Very unlikely */
	if (temp == thyst && thyst == tos)
		return (NULL);

#if notsure
	/* more register aliasing effects that indicate not a lm75 */
	if ((temp >> 8) == conf)
		return (NULL);
#endif

	/*
	 * LM77/LM75 registers 6, 7
	 * echo whatever was read just before them from reg 0, 1, or 2
	 *
	 * LM75A doesn't appear to do this, but does appear to reliably
	 * return 0xffff
	 */
	for (i = 6, echocount = 2, ffffcount = 0; i <= 7; i++) {
		if ((iicprobew(LM75TEMP) & mask) != (iicprobew(i) & mask) ||
		    (iicprobew(LM75Thyst) & mask) != (iicprobew(i) & mask) ||
		    (iicprobew(LM75Tos) & mask) != (iicprobew(i) & mask))
			echocount--;
		if (iicprobew(i) == 0xffff)
			ffffcount++;
	}

	/* Make sure either both registers echo, or neither does */
	if (echocount == 1 || ffffcount == 1)
		return (NULL);

	echoreg67 = (echocount == 0) ? 0 : 1;
	ffffreg67 = (ffffcount == 0) ? 0 : 1;

	/*
	 * LM75 has no registers 4 or 5, and they will act as echos too
	 *
	 * LM75A doesn't appear to do this either, but does appear to
	 * reliably return 0xffff
	 */
	for (i = 4, echocount = 2, ffffcount = 0; i <= 5; i++) {
		if ((iicprobew(LM75TEMP) & mask) != (iicprobew(i) & mask) ||
		    (iicprobew(LM75Thyst) & mask) != (iicprobew(i) & mask) ||
		    (iicprobew(LM75Tos) & mask) != (iicprobew(i) & mask))
			echocount--;
		if (iicprobew(i) == 0xffff)
			ffffcount++;
	}

	/* Make sure either both registers echo, or neither does */
	if (echocount == 1 || ffffcount == 1)
		return (NULL);

	echoreg45 = (echocount == 0) ? 0 : 1;
	ffffreg45 = (ffffcount == 0) ? 0 : 1;

	/*
	 * If we find that 4 and 5 are not echos, and don't return 0xffff
	 * then based on whether the echo test of registers 6 and 7
	 * succeeded or not, we may have an LM77
	 */
	if (echoreg45 == 0 && ffffreg45 == 0 && echoreg67 == 1) {
		mask = LM77TMASK;

		/* mask size changed, must re-read for the next checks */
		thyst = iicprobew(LM75Thyst) & mask;
		tos = iicprobew(LM75Tos) & mask;
		tlow = iicprobew(LM77Tlow) & mask;
		thigh = iicprobew(LM77Thigh) & mask;
	}

	/* a real LM75/LM75A/LM77 repeats its registers.... */
	for (i = 0x08; i <= 0xf8; i += 8) {
		if (conf != iicprobenc(LM75CONF + i) ||
		    thyst != (iicprobew(LM75Thyst + i) & mask) ||
		    tos != (iicprobew(LM75Tos + i) & mask))
			return (NULL);

		/*
		 * Check that the repeated registers 0x06 and 0x07 still
		 * either echo or return 0xffff
		 */
		if (echoreg67 == 1) {
			tos = iicprobew(LM75Tos) & mask;
			if (tos != (iicprobew(0x06 + i) & mask) ||
			    tos != (iicprobew(0x07 + i) & mask))
				return (NULL);
		} else if (ffffreg67 == 1)
			if (iicprobew(0x06 + i) != 0xffff ||
			    iicprobew(0x07 + i) != 0xffff)
				return (NULL);

		/*
		 * Check that the repeated registers 0x04 and 0x05 still
		 * either echo or return 0xffff. If they do neither, and
		 * registers 0x06 and 0x07 echo, then we will be probing
		 * for an LM77, so make sure those still repeat
		 */
		if (echoreg45 == 1) {
			tos = iicprobew(LM75Tos) & mask;
			if (tos != (iicprobew(LM77Tlow + i) & mask) ||
			    tos != (iicprobew(LM77Thigh + i) & mask))
				return (NULL);
		} else if (ffffreg45 == 1) {
			if (iicprobew(LM77Tlow + i) != 0xffff ||
			    iicprobew(LM77Thigh + i) != 0xffff)
				return (NULL);
		} else if (echoreg67 == 1)
			if (tlow != (iicprobew(LM77Tlow + i) & mask) ||
			    thigh != (iicprobew(LM77Thigh + i) & mask))
				return (NULL);
	}

	/*
	 * Given that we now know how the first eight registers behave and
	 * that this behaviour is consistently repeated, we can now use
	 * the following table:
	 *
	 * echoreg67 | echoreg45 | ffffreg67 | ffffreg45 | chip
	 * ----------+-----------+-----------+-----------+------
	 *     1     |     1     |     0     |     0     | LM75
	 *     1     |     0     |     0     |     0     | LM77
	 *     0     |     0     |     1     |     1     | LM75A
	 */

	/* Convert the various flags into a single score */
	score = (echoreg67 << 3) + (echoreg45 << 2) + (ffffreg67 << 1) +
	    ffffreg45;

	switch (score) {
	case 12:
		return ("lm75");
	case 8:
		return ("lm77");
	case 3:
		return ("lm75a");
	default:
#if defined(I2C_DEBUG)
		printf("lm75probe: unknown chip, scored %d\n", score);
#endif /* defined(I2C_DEBUG) */
		return (NULL);
	}
}

char *
adm1032cloneprobe(u_int8_t addr)
{
	if (addr == 0x18 || addr == 0x1a || addr == 0x29 ||
	    addr == 0x2b || addr == 0x4c || addr == 0x4e) {
		u_int8_t reg, val;
		int zero = 0, copy = 0;

		val = iicprobe(0x00);
		for (reg = 0x00; reg < 0x09; reg++) {
			if (iicprobe(reg) == 0xff)
				return (NULL);
			if (iicprobe(reg) == 0x00)
				zero++;
			if (val == iicprobe(reg))
				copy++;
		}
		if (zero > 6 || copy > 6)
			return (NULL);
		val = iicprobe(0x09);
		for (reg = 0x0a; reg < 0xfc; reg++) {
			if (iicprobe(reg) != val)
				return (NULL);
		}
		/* 0xfe may be Maxim, or some other vendor */
		if (iicprobe(0xfe) == 0x4d)
			return ("max1617");
		/*
		 * "xeontemp" is the name we choose for clone chips
		 * which have all sorts of buggy bus interactions, such
		 * as those we just probed.  Why?
		 * Intel is partly to blame for this situation.
		 */
		return ("xeontemp");
	}
	return (NULL);
}

void
iic_ignore_addr(u_int8_t addr)
{
	int i;

	for (i = 0; i < sizeof(ignore_addrs); i++)
		if (ignore_addrs[i] == 0) {
			ignore_addrs[i] = addr;
			return;
		}
}

#ifdef I2C_VERBOSE
void
iic_dump(struct device *dv, u_int8_t addr, char *name)
{
	static u_int8_t iicvalcnt[256];
	u_int8_t val, val2, max;
	int i, cnt = 0;

	/*
	 * Don't bother printing the most often repeated register
	 * value, since it is often weird devices that respond
	 * incorrectly, busted controller driver, or in the worst
	 * case, it in mosts cases, the value 0xff.
	 */
	bzero(iicvalcnt, sizeof iicvalcnt);
	val = iicprobe(0);
	iicvalcnt[val]++;
	for (i = 1; i <= 0xff; i++) {
		val2 = iicprobe(i);
		iicvalcnt[val2]++;
		if (val == val2)
			cnt++;
	}

	for (val = max = i = 0; i <= 0xff; i++)
		if (max < iicvalcnt[i]) {
			max = iicvalcnt[i];
			val = i;
		}

	if (cnt == 255)
		return;

	printf("%s: addr 0x%x", dv->dv_xname, addr);
	for (i = 0; i <= 0xff; i++) {
		if (iicprobe(i) != val)
			printf(" %02x=%02x", i, iicprobe(i));
	}
	printf(" words");
	for (i = 0; i < 8; i++)
		printf(" %02x=%04x", i, iicprobew(i));
	if (name)
		printf(": %s", name);
	printf("\n");
}
#endif /* I2C_VERBOSE */

char *
iic_probe_sensor(struct device *self, u_int8_t addr)
{
	char *name = NULL;

	skip_fc = 0;

	/*
	 * Many I2C/SMBus devices use register 0x3e as a vendor ID
	 * register.
	 */
	switch (iicprobe(0x3e)) {
	case 0x01:		/* National Semiconductor */
		/*
		 * Some newer National products use a vendor code at
		 * 0x3e of 0x01, and then 0x3f contains a product code
		 * But some older products are missing a product code,
		 * and contain who knows what in that register.  We assume
		 * that some employee was smart enough to keep the numbers
		 * unique.
		 */
		if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    (iicprobe(0x3f) == 0x73 || iicprobe(0x3f) == 0x72) &&
		    iicprobe(0x00) == 0x00)
			name = "lm93";	/* product 0x72 is the prototype */
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0x3f) == 0x68)
			name = "lm96000";	/* adt7460 compat? */
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    (iicprobe(0x3f) == 0x60 || iicprobe(0x3f) == 0x62))
			name = "lm85";		/* lm85C/B == adt7460 compat */
		else if ((addr & 0x7c) == 0x2c &&	/* addr 0b01011xx */
		    iicprobe(0x48) == addr &&
		    (iicprobe(0x3f) == 0x03 || iicprobe(0x3f) == 0x04) &&
		    (iicprobe(0x40) & 0x80) == 0x00)
			name = "lm81";
		break;
	case 0x02:		/* National Semiconductor? */
		if ((iicprobe(0x3f) & 0xfc) == 0x04)
			name = "lm87";		/* complete check */
		break;
	case 0x23:		/* Analog Devices? */
		if (iicprobe(0x48) == addr &&
		    (iicprobe(0x40) & 0x80) == 0x00 &&
		    (addr & 0x7c) == 0x2c)
			name = "adm9240";	/* lm87 clone */
		break;
	case 0x41:		/* Analog Devices */
		/*
		 * Newer chips have a valid 0x3d product number, while
		 * older ones sometimes encoded the product into the
		 * upper half of the "step register" at 0x3f.
		 */
		if ((addr == 0x2c || addr == 0x2e || addr == 0x2f) &&
		    iicprobe(0x3d) == 0x70)
			name = "adt7470";
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0x3d) == 0x76)
			name = "adt7476"; /* or adt7476a */
		else if (addr == 0x2e && iicprobe(0x3d) == 0x75)
			name = "adt7475";
		else if (iicprobe(0x3d) == 0x27 &&
		    (iicprobe(0x3f) == 0x60 || iicprobe(0x3f) == 0x6a))
			name = "adm1027";	/* or adt7463 */
		else if (iicprobe(0x3d) == 0x27 &&
		    (iicprobe(0x3f) == 0x62 || iicprobe(0x3f) == 0x6a))
			name = "adt7460";	/* complete check */
		else if ((addr == 0x2c || addr == 0x2e) &&
		    iicprobe(0x3d) == 0x62 && iicprobe(0x3f) == 0x04)
			name = "adt7462";
		else if (addr == 0x4c &&
		    iicprobe(0x3d) == 0x66 && iicprobe(0x3f) == 0x02)
			name = "adt7466";
		else if (addr == 0x2e &&
		    iicprobe(0x3d) == 0x68 && (iicprobe(0x3f) & 0xf0) == 0x70)
			name = "adt7467"; /* or adt7468 */
		else if (iicprobe(0x3d) == 0x33 && iicprobe(0x3f) == 0x02)
			name = "adm1033";
		else if (iicprobe(0x3d) == 0x34 && iicprobe(0x3f) == 0x02)
			name = "adm1034";
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0x3d) == 0x30 &&
		    (iicprobe(0x01) & 0x80) == 0x00 &&
		    (iicprobe(0x0d) & 0x70) == 0x00 &&
		    (iicprobe(0x0e) & 0x70) == 0x00)
			/*
			 * Revision 3 seems to be an adm1031 with
			 * remote diode 2 shorted.  Therefore we
			 * cannot assume the reserved/unused bits of
			 * register 0x03 and 0x06 are set to zero.
			 */
			name = "adm1030";	/* complete check */
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0x3d) == 0x31 &&
		    (iicprobe(0x01) & 0x80) == 0x00 &&
		    (iicprobe(0x0d) & 0x70) == 0x00 &&
		    (iicprobe(0x0e) & 0x70) == 0x00 &&
		    (iicprobe(0x0f) & 0x70) == 0x00)
			name = "adm1031";	/* complete check */
		else if ((addr & 0x7c) == 0x2c &&	/* addr 0b01011xx */
		    (iicprobe(0x3f) & 0xf0) == 0x20 &&
		    (iicprobe(0x40) & 0x80) == 0x00 &&
		    (iicprobe(0x41) & 0xc0) == 0x00 &&
		    (iicprobe(0x42) & 0xbc) == 0x00)
			name = "adm1025";	/* complete check */
		else if ((addr & 0x7c) == 0x2c &&	/* addr 0b01011xx */
		    (iicprobe(0x3f) & 0xf0) == 0x10 &&
		    (iicprobe(0x40) & 0x80) == 0x00)
			name = "adm1024";	/* complete check */
		else if ((iicprobe(0xff) & 0xf0) == 0x30)
			name = "adm1023";
		else if (addr == 0x2e &&
		    (iicprobe(0x3f) & 0xf0) == 0xd0 &&
		    (iicprobe(0x40) & 0x80) == 0x00)
			name = "adm1028";	/* adm1022 clone? */
		else if ((addr == 0x2c || addr == 0x2e || addr == 0x2f) &&
		    (iicprobe(0x3f) & 0xf0) == 0xc0 &&
		    (iicprobe(0x40) & 0x80) == 0x00)
			name = "adm1022";
		break;
	case 0x49:		/* Texas Instruments */
		if ((addr == 0x2c || addr == 0x2e || addr == 0x2f) &&
		    (iicprobe(0x3f) & 0xf0) == 0xc0 &&
		    (iicprobe(0x40) & 0x80) == 0x00)
			name = "thmc50";	/* adm1022 clone */
		break;
	case 0x55:		/* SMSC */
		if ((addr & 0x7c) == 0x2c &&		/* addr 0b01011xx */
		    iicprobe(0x3f) == 0x20 &&
		    (iicprobe(0x47) & 0x70) == 0x00 &&
		    (iicprobe(0x49) & 0xfe) == 0x80)
			name = "47m192";	/* adm1025 compat */
		break;
	case 0x5c:		/* SMSC */
		if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    (iicprobe(0x3f) == 0x69))
			name = "sch5027";
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    (iicprobe(0x3f) & 0xf0) == 0x60)
			name = "emc6d100";   /* emc6d101, emc6d102, emc6d103 */
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    (iicprobe(0x3f) & 0xf0) == 0x80)
			name = "sch5017";
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    (iicprobe(0x3f) & 0xf0) == 0xb0)
			name = "emc6w201";
		break;
	case 0x61:		/* Andigilog */
		if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0x3f) == 0x69 &&
		    iicprobe(0x22) >= 0xaf &&		/* Vdd */
		    (iicprobe(0x09) & 0xbf) == 0x00 && iicprobe(0x0f) == 0x00 &&
		    (iicprobe(0x40) & 0xf0) == 0x00)
			name = "asc7611";
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0x3f) == 0x6c &&
		    iicprobe(0x22) >= 0xae)		/* Vdd */
			name = "asc7621";
		break;
	case 0xa1:		/* Philips */
		if ((iicprobe(0x3f) & 0xf0) == 0x20 &&
		    (iicprobe(0x40) & 0x80) == 0x00 &&
		    (iicprobe(0x41) & 0xc0) == 0x00 &&
		    (iicprobe(0x42) & 0xbc) == 0x00)
			name = "ne1619";	/* adm1025 compat */
		break;
	case 0xda:		/* Dallas Semiconductor */
		if (iicprobe(0x3f) == 0x01 && iicprobe(0x48) == addr &&
		    (iicprobe(0x40) & 0x80) == 0x00)
			name = "ds1780";	/* lm87 clones */
		break;
	}

	switch (iicprobe(0x4e)) {
	case 0x41:		/* Analog Devices */
		if ((addr == 0x48 || addr == 0x4a || addr == 0x4b) &&
		    (iicprobe(0x4d) == 0x03 || iicprobe(0x4d) == 0x08 ||
		    iicprobe(0x4d) == 0x07))
			name = "adt7516";	/* adt7517, adt7519 */
		break;
	}

	switch (iicprobe(0xfe)) {
	case 0x01:		/* National Semiconductor */
		if (addr == 0x4c &&
		    iicprobe(0xff) == 0x41 && (iicprobe(0x03) & 0x18) == 0 &&
		    iicprobe(0x04) <= 0x0f && (iicprobe(0xbf) & 0xf8) == 0)
			name = "lm63";
		else if (addr == 0x4c &&
		    iicprobe(0xff) == 0x11 && (iicprobe(0x03) & 0x2a) == 0 &&
		    iicprobe(0x04) <= 0x09 && (iicprobe(0xbf) & 0xf8) == 0)
			name = "lm86";
		else if (addr == 0x4c &&
		    iicprobe(0xff) == 0x31 && (iicprobe(0x03) & 0x2a) == 0 &&
		    iicprobe(0x04) <= 0x09 && (iicprobe(0xbf) & 0xf8) == 0)
			name = "lm89";		/* or lm99 */
		else if (addr == 0x4d &&
		    iicprobe(0xff) == 0x34 && (iicprobe(0x03) & 0x2a) == 0 &&
		    iicprobe(0x04) <= 0x09 && (iicprobe(0xbf) & 0xf8) == 0)
			name = "lm89-1";	/* or lm99-1 */
		else if (addr == 0x4c &&
		    iicprobe(0xff) == 0x21 && (iicprobe(0x03) & 0x2a) == 0 &&
		    iicprobe(0x04) <= 0x09 && (iicprobe(0xbf) & 0xf8) == 0)
			name = "lm90";
		break;
	case 0x23:		/* Genesys Logic? */
		if ((addr == 0x4c) &&
		    (iicprobe(0x03) & 0x3f) == 0x00 && iicprobe(0x04) <= 0x08)
			/*
			 * Genesys Logic doesn't make the datasheet
			 * for the GL523SM publically available, so
			 * the checks above are nothing more than a
			 * (conservative) educated guess.
			 */
			name = "gl523sm";
		break;
	case 0x41:		/* Analog Devices */
		if ((addr == 0x4c || addr == 0x4d) &&
		    iicprobe(0xff) == 0x51 &&
		    (iicprobe(0x03) & 0x1f) == 0x04 &&
		    iicprobe(0x04) <= 0x0a) {
			/* If not in adm1032 compatibility mode. */
			name = "adt7461";
		} else if ((addr == 0x18 || addr == 0x19 || addr == 0x1a ||
		    addr == 0x29 || addr == 0x2a || addr == 0x2b ||
		    addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
		    (iicprobe(0xff) & 0xf0) == 0x00 &&
		    (iicprobe(0x03) & 0x3f) == 0x00 &&
		    iicprobe(0x04) <= 0x07) {
			name = "adm1021";
			skip_fc = 1;
		} else if ((addr == 0x18 || addr == 0x19 || addr == 0x1a ||
		    addr == 0x29 || addr == 0x2a || addr == 0x2b ||
		    addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
		    (iicprobe(0xff) & 0xf0) == 0x30 &&
		    (iicprobe(0x03) & 0x3f) == 0x00 &&
		    iicprobe(0x04) <= 0x07) {
			name = "adm1023";	/* or adm1021a */
			skip_fc = 1;
		} else if ((addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
		    (iicprobe(0x03) & 0x3f) == 0x00 &&
		    iicprobe(0x04) <= 0x0a) {
			name = "adm1032";	/* or adm1020 */
			skip_fc = 1;
		}
		break;
	case 0x47:		/* Global Mixed-mode Technology */
		if (addr == 0x4c && iicprobe(0xff) == 0x01 &&
		    (iicprobe(0x03) & 0x3f) == 0x00 && iicprobe(0x04) <= 0x08)
			name = "g781";
		if (addr == 0x4d && iicprobe(0xff) == 0x03 &&
		    (iicprobe(0x03) & 0x3f) == 0x00 && iicprobe(0x04) <= 0x08)
			name = "g781-1";
		break;
	case 0x4d:		/* Maxim */
		if ((addr == 0x18 || addr == 0x19 || addr == 0x1a ||
		     addr == 0x29 || addr == 0x2a || addr == 0x2b ||
		     addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
		    iicprobe(0xff) == 0x08 && (iicprobe(0x02) & 0x03) == 0 &&
		    (iicprobe(0x03) & 0x07) == 0 && iicprobe(0x04) <= 0x08)
			name = "max6690";
		else if ((addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
		    iicprobe(0xff) == 0x59 && (iicprobe(0x03) & 0x1f) == 0 &&
		    iicprobe(0x04) <= 0x07)
			name = "max6646";	/* max6647/8/9, max6692 */
		else if ((addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
		    (iicprobe(0x02) & 0x2b) == 0 &&
		    (iicprobe(0x03) & 0x0f) == 0 && iicprobe(0x04) <= 0x09) {
			name = "max6657";	/* max6658, max6659 */
			skip_fc = 1;
		} else if ((addr >= 0x48 && addr <= 0x4f) &&
		    (iicprobe(0x02) & 0x2b) == 0 &&
		    (iicprobe(0x03) & 0x0f) == 0)
			name = "max6642";
		break;
	case 0x55:		/* Texas Instruments */
		if (addr == 0x4c && iicprobe(0xff) == 0x11 &&
		    (iicprobe(0x03) & 0x1b) == 0x00 &&
		    (iicprobe(0x04) & 0xf0) == 0x00 &&
		    (iicprobe(0x10) & 0x0f) == 0x00 &&
		    (iicprobe(0x13) & 0x0f) == 0x00 &&
		    (iicprobe(0x14) & 0x0f) == 0x00 &&
		    (iicprobe(0x15) & 0x0f) == 0x00 &&
		    (iicprobe(0x16) & 0x0f) == 0x00 &&
		    (iicprobe(0x17) & 0x0f) == 0x00)
			name = "tmp401";
		break;
	case 0xa1:
		if ((addr >= 0x48 && addr <= 0x4f) &&
		    iicprobe(0xff) == 0x00 &&
		    (iicprobe(0x03) & 0xf8) == 0x00 &&
		    iicprobe(0x04) <= 0x09) {
			name = "sa56004x";	/* NXP sa56004x */
			skip_fc = 1;
		}
		break;
	}

	if (addr == iicprobe(0x48) &&
	    ((iicprobe(0x4f) == 0x5c && (iicprobe(0x4e) & 0x80)) ||
	    (iicprobe(0x4f) == 0xa3 && !(iicprobe(0x4e) & 0x80)))) {
		/*
		 * We could toggle 0x4e bit 0x80, then re-read 0x4f to
		 * see if the value changes to 0xa3 (indicating Winbond).
		 * But we are trying to avoid writes.
		 */
		if ((iicprobe(0x4e) & 0x07) == 0) {
			switch (iicprobe(0x58)) {
			case 0x10:
			case 0x11:			/* rev 2? */
				name = "w83781d";
				break;
			case 0x21:
				name = "w83627hf";
				break;
			case 0x30:
				name = "w83782d";
				break;
			case 0x31:
				name = "as99127f";	/* rev 2 */
				break;
			case 0x40:
				name = "w83783s";
				break;
			case 0x71:
				name = "w83791d";
				break;
			case 0x72:
				name = "w83791sd";
				break;
			case 0x7a:
				name = "w83792d";
				break;
			case 0xc1:
				name = "w83627dhg";
				break;
			}
		} else {
			/*
			 * The BIOS left the chip in a non-zero
			 * register bank.  Assume it's a W83781D and
			 * let lm(4) sort out the real model.
			 */
			name = "w83781d";
		}
	} else if (addr == (iicprobe(0xfc) & 0x7f) &&
	    iicprobe(0xfe) == 0x79 && iicprobe(0xfb) == 0x51 &&
	    ((iicprobe(0xfd) == 0x5c && (iicprobe(0x00) & 0x80)) ||
	    (iicprobe(0xfd) == 0xa3 && !(iicprobe(0x00) & 0x80)))) {
		/*
		 * We could toggle 0x00 bit 0x80, then re-read 0xfd to
		 * see if the value changes to 0xa3 (indicating Nuvoton).
		 * But we are trying to avoid writes.
		 */
		name = "w83795g";
	} else if (addr == iicprobe(0x4a) && iicprobe(0x4e) == 0x50 &&
	    iicprobe(0x4c) == 0xa3 && iicprobe(0x4d) == 0x5c) {
		name = "w83l784r";
	} else if (addr == 0x2d && iicprobe(0x4e) == 0x60 &&
	    iicprobe(0x4c) == 0xa3 && iicprobe(0x4d) == 0x5c) {
		name = "w83l785r";
	} else if (addr == 0x2e && iicprobe(0x4e) == 0x70 &&
	    iicprobe(0x4c) == 0xa3 && iicprobe(0x4d) == 0x5c) {
		name = "w83l785ts-l";
	} else if (addr >= 0x2c && addr <= 0x2f &&
	    ((iicprobe(0x00) & 0x07) != 0x0 ||
	    ((iicprobe(0x00) & 0x07) == 0x0 && addr * 2 == iicprobe(0x0b) &&
	    (iicprobe(0x0c) & 0x40) && !(iicprobe(0x0c) & 0x04))) &&
	    iicprobe(0x0e) == 0x7b &&
	    (iicprobe(0x0f) & 0xf0) == 0x10 &&
	    ((iicprobe(0x0d) == 0x5c && (iicprobe(0x00) & 0x80)) ||
	    (iicprobe(0x0d) == 0xa3 && !(iicprobe(0x00) & 0x80)))) {
		name = "w83793g";
	} else if (addr >= 0x28 && addr <= 0x2f &&
	    iicprobe(0x4f) == 0x12 && (iicprobe(0x4e) & 0x80)) {
		/*
		 * We could toggle 0x4e bit 0x80, then re-read 0x4f to
		 * see if the value changes to 0xc3 (indicating ASUS).
		 * But we are trying to avoid writes.
		 */
		if (iicprobe(0x58) == 0x31)
			name = "as99127f";	/* rev 1 */
	} else if ((addr == 0x2d || addr == 0x2e) &&
	    addr * 2 == iicprobe(0x04) &&
	    iicprobe(0x5d) == 0x19 && iicprobe(0x5e) == 0x34 &&
	    iicprobe(0x5a) == 0x03 && iicprobe(0x5b) == 0x06) {
		name = "f75375";	/* Fintek */
	} else if (addr == 0x2d &&
	    ((iicprobe(0x4f) == 0x06 && (iicprobe(0x4e) & 0x80)) ||
	    (iicprobe(0x4f) == 0x94 && !(iicprobe(0x4e) & 0x80)))) {
		/*
		 * We could toggle 0x4e bit 0x80, then re-read 0x4f to
		 * see if the value changes to 0x94 (indicating ASUS).
		 * But we are trying to avoid writes.
		 *
		 * NB. we won't match if the BIOS has selected a non-zero
		 * register bank (set via 0x4e). We could select bank 0 so
		 * we see the right registers, but that would require a
		 * write.  In general though, we bet no BIOS would leave us
		 * in the wrong state.
		 */
		if ((iicprobe(0x58) & 0x7f) == 0x31 &&
		    (iicprobe(0x4e) & 0xf) == 0x00)
			name = "asb100";
	} else if ((addr == 0x2c || addr == 0x2d) &&
	    iicprobe(0x00) == 0x80 &&
	    (iicprobe(0x01) == 0x00 || iicprobe(0x01) == 0x80) &&
	    iicprobe(0x02) == 0x00 && (iicprobe(0x03) & 0x83) == 0x00 &&
	    (iicprobe(0x0f) & 0x07) == 0x00 &&
	    (iicprobe(0x11) & 0x80) == 0x00 &&
	    (iicprobe(0x12) & 0x80) == 0x00) {
		/*
		 * The GL518SM is really crappy.  It has both byte and
		 * word registers, and reading a word register with a
		 * byte read command will make the device crap out and
		 * hang the bus.  This has nasty consequences on some
		 * machines, like preventing warm reboots.  The word
		 * registers are 0x07 through 0x0c, so make sure the
		 * checks above don't access those registers.  We
		 * don't want to do this check right up front though
		 * since this chip is somewhat hard to detect (which
		 * is why we check for every single fixed bit it has).
		 */
		name = "gl518sm";
	} else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
	    iicprobe(0x16) == 0x41 && ((iicprobe(0x17) & 0xf0) == 0x40)) {
		name = "adm1026";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x1131 &&
	    (iicprobew(0x07) & 0xfffc) == 0xa200) {
		name = "se97";		/* or se97b */
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x1131 &&
	    (iicprobew(0x07) & 0xfffc) == 0xa100 &&
	    (iicprobew(0x00) & 0xfff0) == 0x0010) {
		name = "se98";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x004d &&
	    iicprobew(0x07) == 0x3e00 &&
	    (iicprobew(0x00) & 0xffe0) == 0x0000) {
		name = "max6604";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x0054 &&
	    (iicprobew(0x07) & 0xfffc) == 0x0200 &&
	    (iicprobew(0x00) & 0xffe0) == 0x0000) {
		name = "mcp9804";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x0054 &&
	    (iicprobew(0x07) & 0xff00) == 0x0000 &&
	    (iicprobew(0x00) & 0xffe0) == 0x0000) {
		name = "mcp9805";		/* or mcp9843 */
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x0054 &&
	    (iicprobew(0x07) & 0xfffc) == 0x2000 &&
	    (iicprobew(0x00) & 0xffe0) == 0x0000) {
		name = "mcp98242";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x0054 &&
	    (iicprobew(0x07) & 0xff00) == 0x2100 &&
	    (iicprobew(0x00) & 0xff00) == 0x0000) {
		name = "mcp98243";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x0054 &&
	    (iicprobew(0x07) & 0xfffc) == 0x2200 &&
	    (iicprobew(0x00) & 0xff00) == 0x0000) {
		name = "mcp98244";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x11d4 &&
	    iicprobew(0x07) == 0x0800 &&
	    iicprobew(0x00) == 0x001d) {
		name = "adt7408";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x104a &&
	    (iicprobew(0x07) & 0xfffe) == 0x0000 &&
	    (iicprobew(0x00) == 0x002d || iicprobew(0x00) == 0x002f)) {
		name = "stts424e02";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x104a &&
	    (iicprobew(0x07) & 0xfffe) == 0x0300 &&
	    (iicprobew(0x00) == 0x006f)) {
		name = "stts2002";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x104a &&
	    (iicprobew(0x07) & 0xffff) == 0x2201 &&
	    (iicprobew(0x00) == 0x00ef)) {
		name = "stts2004";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x104a &&
	    (iicprobew(0x07) & 0xffff) == 0x0200 &&
	    (iicprobew(0x00) == 0x006f)) {
		name = "stts3000";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x104a &&
	    (iicprobew(0x07) & 0xffff) == 0x0101 &&
	    (iicprobew(0x00) == 0x002d || iicprobew(0x00) == 0x002f)) {
		name = "stts424";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x1b09 &&
	    (iicprobew(0x07) & 0xffe0) == 0x0800 &&
	    (iicprobew(0x00) & 0x001f) == 0x001f) {
		name = "cat34ts02";		/* or cat6095, prod 0x0813 */
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x1b09 &&
	    (iicprobew(0x07) & 0xffff) == 0x0a00 &&
	    (iicprobew(0x00) & 0x001f) == 0x001f) {
		name = "cat34ts02c";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x1b09 &&
	    (iicprobew(0x07) & 0xffff) == 0x2200 &&
	    (iicprobew(0x00) == 0x007f)) {
		name = "cat34ts04";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x00b3 &&
	    (iicprobew(0x07) & 0xffff) == 0x2903 &&
	    (iicprobew(0x00) == 0x004f)) {
		name = "ts3000b3";		/* or tse2002b3 */
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x00b3 &&
	    (iicprobew(0x07) & 0xffff) == 0x2912 &&
	    (iicprobew(0x00) == 0x006f)) {
		name = "ts3000gb2";		/* or tse2002gb2 */
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x00b3 &&
	    (iicprobew(0x07) & 0xffff) == 0x2913 &&
	    (iicprobew(0x00) == 0x0077)) {
		name = "ts3000gb0";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x00b3 &&
	    (iicprobew(0x07) & 0xffff) == 0x3001 &&
	    (iicprobew(0x00) == 0x006f)) {
		name = "ts3001gb2";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x00b3 &&
	    (iicprobew(0x07) & 0xffff) == 0x2214 &&
	    (iicprobew(0x00) == 0x00ff)) {
		name = "tse2004gb2";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x001f &&
	    (iicprobew(0x07) & 0xffff) == 0x8201 &&
	    (iicprobew(0x00) & 0xff00) == 0x0000) {
		name = "at30ts00";		/* or at30tse002 */
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x1114 &&
	    (iicprobew(0x07) & 0xffff) == 0x2200 &&
	    (iicprobew(0x00) & 0xff00) == 0x0000) {
		name = "at30tse004";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x1c68 &&
	    (iicprobew(0x07) & 0xffff) == 0x2201 &&
	    (iicprobew(0x00) & 0xff00) == 0x0000) {
		name = "gt30ts00";
	} else if ((addr & 0x78) == 0x18 && iicprobew(0x06) == 0x132d &&
	    (iicprobew(0x07) & 0xffff) == 0x3300 &&
	    (iicprobew(0x00) & 0x001f) == 0x001f) {
		name = "gt34ts02";
	} else if ((addr & 0x7e) == 0x1c && iicprobe(0x0f) == 0x3b &&
	    (iicprobe(0x21) & 0x60) == 0x00 &&
	    iicprobe(0x0f) == iicprobe(0x8f) &&	/* registers address is 7 bits */
	    iicprobe(0x20) == iicprobe(0xa0) &&
	    iicprobe(0x21) == iicprobe(0xa1) &&
	    iicprobe(0x22) == iicprobe(0xa2) &&
	    iicprobe(0x07) == 0x00) {		/* 0x00 to 0x0e are reserved */
		name = "lis331dl";
	} else if (name == NULL &&
	    (addr & 0x78) == 0x48) {		/* addr 0b1001xxx */
		name = lm75probe();
	}
#if 0
	/*
	 * XXX This probe needs to be improved; the driver does some
	 * dangerous writes.
	 */
	if (name == NULL && (addr & 0x7c) == 0x48 &&	/* addr 0b1001xxx */
	    (iicprobew(0xaa) & 0x0007) == 0x0000 &&
	    (iicprobew(0xa1) & 0x0007) == 0x0000 &&
	    (iicprobew(0xa2) & 0x0007) == 0x0000 &&
	    (iicprobe(0xac) & 0x10) == 0x00) {
		if ((iicprobe(0xac) & 0x7e) == 0x0a &&
		    iicprobe(0xab) == 0x00 && iicprobe(0xa8) == 0x00)
			name = "ds1624";
		else if ((iicprobe(0xac) & 0x7e) == 0x0c)
			name = "ds1631";	/* terrible probe */
		else if ((iicprobe(0xac) & 0x2e) == 0x2e)
			name = "ds1721";	/* terrible probe */
	}
#endif
	if (name == NULL && (addr & 0xf8) == 0x28 && iicprobe(0x48) == addr &&
	    (iicprobe(0x00) & 0x90) == 0x10 && iicprobe(0x58) == 0x90) {
		if (iicprobe(0x5b) == 0x12)
			name = "it8712";
		else if (iicprobe(0x5b) == 0x00)
			name = "it8712f-a";		/* sis950 too */
	}

	if (name == NULL && iicprobe(0x48) == addr &&
	    (iicprobe(0x40) & 0x80) == 0x00 && iicprobe(0x58) == 0xac)
		name = "mtp008";

	if (name == NULL) {
		name = adm1032cloneprobe(addr);
		if (name)
			skip_fc = 1;
	}

	return (name);
}

char *
iic_probe_eeprom(struct device *self, u_int8_t addr)
{
	u_int8_t type;
	char *name = NULL;

	type = iicprobe(0x02);
	/* limit to SPD types seen in the wild */
	if (type < 4 || type > 11)
		return (name);

	/* more matching in driver(s) */
	name = "eeprom";

	return (name);
}

void
iic_scan(struct device *self, struct i2cbus_attach_args *iba)
{
	i2c_tag_t ic = iba->iba_tag;
	struct i2c_attach_args ia;
	struct iicprobelist *pl;
	u_int8_t cmd = 0, addr;
	char *name;
	int i, j, k;

	bzero(ignore_addrs, sizeof(ignore_addrs));

	for (i = 0; probes[i].probe; i++) {
#if NIPMI > 0
		extern int ipmi_enabled;

		if ((probes[i].flags & PFLAG_SENSOR) && ipmi_enabled) {
			printf("%s: skipping sensors to avoid ipmi0 interactions\n",
			    self->dv_xname);
			continue;
		}
#endif
		pl = probes[i].pl;
		for (j = 0; pl[j].start && pl[j].end; j++) {
			for (addr = pl[j].start; addr <= pl[j].end; addr++) {
				for (k = 0; k < sizeof(ignore_addrs); k++)
					if (ignore_addrs[k] == addr)
						break;
				if (k < sizeof(ignore_addrs))
					continue;

				/* Perform RECEIVE BYTE command */
				iic_acquire_bus(ic, 0);
				if (iic_exec(ic, I2C_OP_READ_WITH_STOP, addr,
				    &cmd, sizeof cmd, NULL, 0, 0) == 0) {
					iic_release_bus(ic, 0);

					/* Some device exists */
					iicprobeinit(iba, addr);
					name = (*probes[i].probe)(self, addr);
#ifndef I2C_VERBOSE
					if (name == NULL)
						name = "unknown";
#endif /* !I2C_VERBOSE */
					if (name) {
						memset(&ia, 0, sizeof(ia));
						ia.ia_tag = iba->iba_tag;
						ia.ia_addr = addr;
						ia.ia_size = 1;
						ia.ia_name = name;
						if (config_found(self,
						    &ia, iic_print))
							continue;
					}
#ifdef I2C_VERBOSE
					if ((probes[i].flags & PFLAG_SENSOR))
						iic_dump(self, addr, name);
#endif /* I2C_VERBOSE */
				} else
					iic_release_bus(ic, 0);
			}
		}
	}
}
@


1.144
log
@Initial addition of ``Patrol Read'' support in bio(4), biocto(8), and
mfi(4).  Based on FreeBSD, but done without mfiutil(8).

OK deraadt@@
@
text
@a1061 1
#if 0
a1069 1
#endif
@


1.143
log
@add some more sdtemp devices
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.142 2014/09/27 06:07:01 jsg Exp $	*/
d1062 1
d1071 1
@


1.142
log
@add some more sdtemp devices
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.141 2014/09/26 15:24:56 jsg Exp $	*/
d940 4
d960 4
@


1.141
log
@Don't mask off revision bits for tests against a full
device id/revision id value.  Makes it possible for se98 and stts424
sensors to match.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.140 2011/10/07 06:29:43 deraadt Exp $	*/
d889 4
d904 4
d921 8
d936 4
d944 28
@


1.140
log
@Detect the ts3000b3 and stts2002, and weaken the cat34ts02 model check
since a similar device (not yet named as far as I can see) has showed up
on the market. cat34ts02 tested by weerd.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.139 2011/05/26 01:40:33 deraadt Exp $	*/
d881 1
a881 1
	    (iicprobew(0x07) & 0xfffc) == 0xa101 &&
d913 1
a913 1
	    (iicprobew(0x07) & 0xfffe) == 0x0101 &&
@


1.139
log
@The check for the mcp98243 sdtemp(4) device was too strict.  Relax it.
Tested by Joe Gidi
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.138 2011/03/10 23:14:30 deraadt Exp $	*/
d878 2
a879 3
	    (iicprobew(0x07) & 0xfffc) == 0xa200 &&
	    (iicprobew(0x00) & 0xfff0) == 0x0010) {
		name = "se97";
d889 1
a889 1
	    iicprobew(0x07) == 0x0000 &&
d891 1
a891 1
		name = "mcp9805";
d897 1
a897 1
	    (iicprobew(0x07) & 0xfffc) == 0x2100 &&
d909 4
d918 6
a923 2
	    iicprobew(0x00) == 0x001f) {
		name = "cat34ts02";		/* or cat6095 */
@


1.138
log
@Add support for detecting the NXP SA56004X (we have not actually
seen it in the wild yet, but the detection seems easy).  Few bugs spotted
by kettenis.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.137 2010/07/09 08:05:45 deraadt Exp $	*/
d899 1
a899 1
	    (iicprobew(0x00) & 0xffe0) == 0x0000) {
@


1.137
log
@3 more JEDEC JC-42.4 sensors are the market
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.136 2010/03/22 23:17:34 kettenis Exp $	*/
d736 9
@


1.136
log
@Detect Nuvoton W83795G.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.135 2009/12/28 05:04:38 deraadt Exp $	*/
d869 1
a869 1
	    iicprobew(0x07) == 0xa101 &&
d871 1
a871 1
		name = "se98";
d873 1
a873 1
	    iicprobew(0x07) == 0xa200 &&
d875 5
a879 1
		name = "se97";
d885 1
a885 1
	    iicprobew(0x07) == 0x2000 &&
d888 4
d893 1
a893 1
	    (iicprobew(0x07) & 0xfff0) == 0x0800 &&
d900 4
@


1.135
log
@correct id for 2nd type of stts424e02; from cnst
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.134 2009/08/12 14:51:20 cnst Exp $	*/
d786 10
@


1.134
log
@New lisa(4) driver for ST LIS331DL accelerometer in HP 2133 Mini-Note PC;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.133 2009/07/10 19:58:41 cnst Exp $	*/
d880 1
a880 1
	    (iicprobew(0x00) == 0x002d || iicprobew(0x00) == 0x002e)) {
@


1.133
log
@check 4 (instead of merely 2) addr bits for probing sdtemp(4) chips;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.132 2009/07/10 00:17:30 cnst Exp $	*/
d886 8
@


1.132
log
@support onsemi's cat34ts02 and cat6095;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.131 2009/03/14 06:31:48 deraadt Exp $	*/
d858 1
a858 1
	} else if ((addr & 0x18) == 0x18 && iicprobew(0x06) == 0x1131 &&
d862 1
a862 1
	} else if ((addr & 0x18) == 0x18 && iicprobew(0x06) == 0x1131 &&
d866 1
a866 1
	} else if ((addr & 0x18) == 0x18 && iicprobew(0x06) == 0x0054 &&
d870 1
a870 1
	} else if ((addr & 0x18) == 0x18 && iicprobew(0x06) == 0x0054 &&
d874 1
a874 1
	} else if ((addr & 0x18) == 0x18 && iicprobew(0x06) == 0x11d4 &&
d878 1
a878 1
	} else if ((addr & 0x18) == 0x18 && iicprobew(0x06) == 0x104a &&
d882 1
a882 1
	} else if ((addr & 0x18) == 0x18 && iicprobew(0x06) == 0x1b09 &&
@


1.131
log
@apologize (dlg and claudio, stop snickering)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.130 2009/02/19 23:09:17 jsg Exp $	*/
d882 4
@


1.130
log
@Move most of spdmem match logic into the driver and add crc16/ddr3
support based on changes in NetBSD by Paul Goyette with goop
like bitfields/single decode function mess removed and things
like module type/simpler capacity calculations added.

Tested by a bunch of people in particular krw who tested a few revs
of the ddr3 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.129 2008/12/12 23:38:23 jsg Exp $	*/
d20 1
a20 1
 * I2C bus scanning.
@


1.129
log
@Check for zero'd spd data even if we pass the checksum
and don't offer a match in this case.

Deals with the qemu "TODO: Populate SPD eeprom data."
tested by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.128 2008/11/13 17:57:15 deraadt Exp $	*/
d929 1
a929 2
	int reg, csum = 0;
	u_int8_t size;
d932 3
a934 3
	/* SPD EEPROMs should only set lower nibble for size (ie <= 32K) */
	size = iicprobe(0x01);
	if (((size & 0xf0) != 0) || size == 0)
d937 2
a938 2
	for (reg = 0; reg < 0x3f; reg++)
		csum += iicprobe(reg);
a939 2
	if (iicprobe(0x3f) == (csum & 0xff))
		name = "spd";
@


1.128
log
@add support for ST's chip since documentation is now available at
http://www.st.com/stonline/products/literature/ds/13448/stts424e02.pdf
as discovered by Gert-Jan Vons.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.127 2008/11/03 00:17:47 cnst Exp $	*/
d930 1
d934 2
a935 1
	if ((iicprobe(0x01) & 0xf0) != 0)
@


1.127
log
@support w83627dhg at i2c (as seen on Sun Ultra 24 via dmesg@@)    ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.126 2008/04/22 02:22:54 cnst Exp $	*/
d878 4
@


1.126
log
@unbreak the ignore_addrs logic (the 'continue' was obviously meant to affect
another preceding 'for' loop);

reported by krw and kettenis;  better diff from millert;  'get it in' deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.125 2008/04/20 00:22:39 deraadt Exp $	*/
d773 3
@


1.125
log
@two more i2c probe checks.  adt has split off or been sold to ON
semi, so now even more data sheets are available at
http://www.onsemi.com/PowerSolutions/parametrics.do?id=2127
so if people want to help write drivers...
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.124 2008/04/18 19:28:44 deraadt Exp $	*/
d964 3
a966 1
						continue;
@


1.124
log
@detect adm1034
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.123 2008/04/18 18:51:01 deraadt Exp $	*/
d513 1
a513 1
			name = "adm1027";	/* complete check */
d520 3
@


1.123
log
@adm1033 has a rev register to check as well
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.122 2008/04/17 19:01:48 deraadt Exp $	*/
d525 3
a527 1
                else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
d538 2
a539 2
			name = "adm1030";       /* complete check */
                else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
d850 1
a850 1
	      iicprobe(0x16) == 0x41 && ((iicprobe(0x17) & 0xf0) == 0x40)) {
@


1.122
log
@make it more apparent that when we are dealing with 16 bit registers
(not a series of 8 bit registers), the bytes come off the wire in
big-endian order
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.121 2008/04/10 17:14:09 deraadt Exp $	*/
d523 1
a523 1
		else if (iicprobe(0x3d) == 0x33)
@


1.121
log
@MCP98242 temp sensor docs found..
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.120 2008/04/09 22:04:10 deraadt Exp $	*/
d126 1
a126 1
	    probe_addr, &cmd, 1, &data, 1, 0) != 0)
d135 1
a135 1
	u_int8_t data[2];
d145 2
a146 2
	    probe_addr, &cmd, 1, &data, 2, 0) != 0)
		data[0] = data[1] = 0xff;
d148 1
a148 1
	return ((data[0] << 8) | data[1]);
d964 1
a964 1
				    &cmd, 1, NULL, 0, 0) == 0) {
@


1.120
log
@Recognize and support the Microchip MCP9805 JC-42.2 sensor (we hope; I am
simply going through datasheets found on the net...)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.119 2008/04/09 21:56:40 deraadt Exp $	*/
d862 4
@


1.119
log
@support the NPX SE97 too
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.118 2008/04/07 00:31:07 deraadt Exp $	*/
d858 4
@


1.118
log
@Identify two chips which follow the JDEC JC-42.4 standard dimm temperature
probe -- NPX SE98 and ADT 7408
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.117 2008/04/01 04:18:17 cnst Exp $	*/
d854 4
@


1.117
log
@toast unused args from a printf call;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.116 2008/04/01 03:28:32 cnst Exp $	*/
d850 8
@


1.116
log
@match more versions of w83793g;  whilst here, also ensure that the bank 0
registers are only tested if bank 0 is selected;  'looks ok' deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.115 2008/04/01 01:10:49 deraadt Exp $	*/
d441 1
a441 1
	printf(" words", dv->dv_xname, addr);
@


1.115
log
@only need 8 words to learn about i2c spd jc-42.4 sensors
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.114 2008/03/27 05:46:09 cnst Exp $	*/
d788 3
a790 2
	    addr * 2 == iicprobe(0x0b) &&
	    (iicprobe(0x0c) & 0x40) && !(iicprobe(0x0c) & 0x04) &&
d792 1
a792 1
	    (iicprobe(0x0f) == 0x11 || iicprobe(0x0f) == 0x12) &&
@


1.114
log
@test the Vdd registers of Andigilog chips against the minimum voltage readings;
'good plan' deraadt;  ok kettenis, mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.113 2008/03/19 21:01:10 cnst Exp $	*/
d442 1
a442 1
	for (i = 0; i < 16; i++)
@


1.113
log
@add probe for Andigilog aSC7611;  discussed with deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.112 2007/12/05 16:35:14 deraadt Exp $	*/
d595 1
d600 2
a601 1
		    iicprobe(0x3f) == 0x6c)
@


1.112
log
@sch5027 probing, from remco@@d-compu.dyndns.org
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.111 2007/10/30 07:10:34 deraadt Exp $	*/
d594 5
@


1.111
log
@print some word reads as well in the verbose output
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.110 2007/10/25 03:36:01 deraadt Exp $	*/
d580 3
@


1.110
log
@expand range where we search for sensors
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.109 2007/10/24 20:15:29 cnst Exp $	*/
d433 7
a439 9
	if (cnt <= 254) {
		printf("%s: addr 0x%x", dv->dv_xname, addr);
		for (i = 0; i <= 0xff; i++) {
			if (iicprobe(i) != val)
				printf(" %02x=%02x", i, iicprobe(i));
		}
		if (name)
			printf(": %s", name);
		printf("\n");
d441 6
@


1.109
log
@remove the unused i2cbus_attach_args param from the probe functions;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.108 2007/10/24 20:08:03 deraadt Exp $	*/
d49 1
a49 2
	{ 0x18, 0x18 },
	{ 0x1a, 0x1a },
@


1.108
log
@make older gcc happier
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.107 2007/10/24 19:56:06 cnst Exp $	*/
d64 2
a65 2
char 	*iic_probe_sensor(struct device *, struct i2cbus_attach_args *, u_int8_t);
char	*iic_probe_eeprom(struct device *, struct i2cbus_attach_args *, u_int8_t);
d70 1
a70 1
	char	*(*probe)(struct device *, struct i2cbus_attach_args *, u_int8_t);
d448 1
a448 1
iic_probe_sensor(struct device *self, struct i2cbus_attach_args *iba, u_int8_t addr)
d881 1
a881 2
iic_probe_eeprom(struct device *self, struct i2cbus_attach_args *iba,
    u_int8_t addr)
d935 1
a935 2
					name = (*probes[i].probe)(self,
					    iba, addr);
@


1.107
log
@fix r1.101 (2007-10-07) regression of not calling the iic_dump() for a
successfully identified sensor chip that was not claimed by any driver;
whilst at it, get rid of the 'if defined' madness

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.106 2007/10/24 18:32:31 cnst Exp $	*/
d953 1
a953 1
					if (probes[i].flags & PFLAG_SENSOR)
@


1.106
log
@skip the ignored addresses completely (now covers the eeprom range, too);  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.105 2007/10/18 11:03:09 jsg Exp $	*/
d404 1
a404 1
#if defined(I2C_DEBUG) || defined(I2C_VERBOSE)
d445 1
a445 1
#endif /* defined(I2C_DEBUG) || defined(I2C_VERBOSE) */
d877 1
a877 16
#ifdef I2C_DEBUG
	iic_dump(self, addr, name);
#endif /* I2C_DEBUG */

#if !defined(I2C_VERBOSE) && !defined(I2C_DEBUG)
	if (name == NULL)
		name = "unknown";
#endif

	if (name)
		return (name);

#if defined(I2C_VERBOSE) && !defined(I2C_DEBUG)
	iic_dump(self, addr, name);
#endif /* defined(I2C_VERBOSE) && !defined(I2C_DEBUG) */
	return (NULL);
d938 4
a941 1

d948 3
a950 2
						(void) config_found(self,
						    &ia, iic_print);
d952 4
@


1.105
log
@Check to see if the SPD EEPROM size looks sane (ie < 32K)
when trying to decide if we have found an SPD EEPROM.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.104 2007/10/17 17:29:54 deraadt Exp $	*/
a450 5
	int i;

	for (i = 0; i < sizeof(ignore_addrs); i++)
		if (ignore_addrs[i] == addr)
			return (NULL);
d922 1
a922 1
	int i, j;
d939 4
@


1.104
log
@add probe for TI TMP401 (untested)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.103 2007/10/11 20:48:21 cnst Exp $	*/
d907 4
a910 1
	/* only check SPD memory EEPROMs for now */
@


1.103
log
@probe for Winbond W83793G; tested by jon.steel@@esentire.com; suggestions/ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.102 2007/10/09 16:57:47 deraadt Exp $	*/
d711 12
@


1.102
log
@we have been knocking out i2c when ipmi exists on a machine (because
there are ipmi bmc's that apparently violate i2c bus master locking).
but those problems bite us only for sensors which we re-scan every few
seconds, and then we hit the ipmi bmc's races.  for non-sensor devices
(like spdmem) it is probably ok to look once.  let's try that method
for a while and see if anyone sees breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.101 2007/10/07 14:26:41 deraadt Exp $	*/
d767 8
@


1.101
log
@add support for scanning the spdmem range of addresses, using a different
probe function; based on earlier work by jsg, and retested by us
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.100 2007/09/05 17:22:08 deraadt Exp $	*/
d23 2
d67 1
d71 1
d73 2
a74 2
	{ probe_addrs_sensor, iic_probe_sensor },
	{ probe_addrs_eeprom, iic_probe_eeprom },
d909 9
@


1.100
log
@probe for adt7462 (no driver yet, someone want to write one), and mention
a few more sub-types as comments; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.99 2007/09/03 19:05:05 deraadt Exp $	*/
d33 6
a38 1
void	iic_probe(struct device *, struct i2cbus_attach_args *, u_int8_t);
d46 1
a46 3
struct {
	u_int8_t start, end;
} probe_addrs[] = {
d50 10
a59 1
	{ 0x48, 0x4e }
d62 11
a72 2
#define MAX_IGNORE 8
u_int8_t ignore_addrs[MAX_IGNORE];
d443 2
a444 2
void
iic_probe(struct device *self, struct i2cbus_attach_args *iba, u_int8_t addr)
a445 1
	struct i2c_attach_args ia;
d451 1
a451 1
			return;
a452 1
	iicprobeinit(iba, addr);
d867 2
a868 9
	if (name) {
		memset(&ia, 0, sizeof(ia));
		ia.ia_tag = iba->iba_tag;
		ia.ia_addr = addr;
		ia.ia_size = 1;
		ia.ia_name = name;
		if (config_found(self, &ia, iic_print))
			return;
	}
d873 17
d896 2
d899 2
a900 1
	int i;
a902 11
	for (i = 0; i < sizeof(probe_addrs)/sizeof(probe_addrs[0]); i++) {
		for (addr = probe_addrs[i].start; addr <= probe_addrs[i].end;
		    addr++) {
			/* Perform RECEIVE BYTE command */
			iic_acquire_bus(ic, 0);
			if (iic_exec(ic, I2C_OP_READ_WITH_STOP, addr,
			    &cmd, 1, NULL, 0, 0) == 0) {
				iic_release_bus(ic, 0);

				/* Some device exists, so go scope it out */
				iic_probe(self, iba, addr);
d904 5
d910 20
a929 1

a930 1
			iic_release_bus(ic, 0);
@


1.99
log
@there is a prototype version of the lm93 (plus spacing fixes)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.98 2007/09/03 19:04:43 kettenis Exp $	*/
d487 1
a487 1
			name = "adt7476";
d496 3
d501 1
a501 1
			name = "adt7467";
@


1.98
log
@Recognize Andigilog aSC7621.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.97 2007/04/10 17:47:55 miod Exp $	*/
d451 3
a453 2
		    iicprobe(0x3f) == 0x73)
			name = "lm93";
d732 1
a732 1
	} else if (addr == iicprobe (0x4a) && iicprobe(0x4e) == 0x50 &&
d805 3
a807 3
 	    (iicprobew(0xaa) & 0x0007) == 0x0000 &&
 	    (iicprobew(0xa1) & 0x0007) == 0x0000 &&
 	    (iicprobew(0xa2) & 0x0007) == 0x0000 &&
@


1.97
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.96 2007/01/05 19:25:45 deraadt Exp $	*/
d563 5
@


1.96
log
@when i2c_dumping, instead of just skipping 0xff value registers,
skip the most common value read (which is often 0xff anyways)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.95 2006/12/26 19:57:17 kettenis Exp $	*/
d256 1
a256 1
	/* a real LM75/LM75A/LM77 repeats it's registers.... */
@


1.95
log
@The adt7475 has a fixed address of 0x2e.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.94 2006/12/25 21:25:39 deraadt Exp $	*/
d383 2
a384 1
	u_int8_t val = iicprobe(0);
d387 9
d397 3
a399 1
		if (val == iicprobe(i))
d402 7
d412 1
a412 1
			if (iicprobe(i) != 0xff)
@


1.94
log
@identify adt7475
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.93 2006/11/19 16:40:02 kettenis Exp $	*/
d468 1
a468 2
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0x3d) == 0x75)
@


1.93
log
@Probe for National Semiconductor LM63.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.92 2006/11/19 16:16:22 kettenis Exp $	*/
d468 3
@


1.92
log
@Probe for Myson MTP008.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.91 2006/11/01 22:24:20 deraadt Exp $	*/
d569 4
d576 1
a576 1
		if (addr == 0x4c &&
@


1.91
log
@lm75 scoring should not show up in verbose
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.90 2006/09/26 23:48:56 jsg Exp $	*/
d794 4
@


1.90
log
@re-enable I2C_VERBOSE
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.89 2006/08/29 18:39:39 kettenis Exp $	*/
d322 1
a322 1
#if defined(I2C_DEBUG) || defined(I2C_VERBOSE)
d324 1
a324 1
#endif /* defined(I2C_DEBUG) || defined(I2C_VERBOSE) */
@


1.89
log
@#undef I2C_VERBOSE

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.88 2006/08/18 17:35:19 deraadt Exp $	*/
d31 1
a31 1
#undef I2C_VERBOSE
@


1.88
log
@probe for the lm75a, meaning that the lm75/lm75a/lm77 probe routine must
become quite complicated.  work done by matt@@bodgit-n-scarper.com after
i explained how daft these devices are
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.87 2006/07/15 19:39:56 kettenis Exp $	*/
d31 1
a31 1
#define I2C_VERBOSE
@


1.87
log
@Add support for Genesys Logic GL523SM and Global Mixed-mode Technology G781.

tested by fgs@@ and Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.86 2006/07/12 15:35:40 deraadt Exp $	*/
d146 8
a153 6
 * The LM75/LM77 family are very hard to detect.  Thus, we check for
 * all other possible chips first.  These chips do not have an ID
 * register.  They do have a few quirks though:
 *    register 0x06 and 0x07 return whatever value was read before
 *    the LM75 lacks registers 0x04 and 0x05, so those act as above
 *    the chip registers loop every 8 registers
d155 1
a155 1
 * if this is an LM75 or LM77.
d162 2
a163 1
	int ret = 75, i;
d166 8
d199 3
d203 1
a203 1
	for (i = 6; i <= 7; i++) {
d207 3
a209 1
			return (NULL);
d212 7
d221 3
a223 1
	 * If we find that 4 and 5 are not echos, then we may have a LM77
d225 22
a246 6
	for (i = 4; i <= 5; i++) {
		if ((iicprobew(LM75TEMP) & mask) == (iicprobew(i) & mask) &&
		    (iicprobew(LM75Thyst) & mask) == (iicprobew(i) & mask) &&
		    (iicprobew(LM75Tos) & mask) == (iicprobew(i) & mask))
			continue;
		ret = 77;
a253 1
		break;
d256 1
a256 1
	/* a real LM75/LM77 repeats it's registers.... */
d262 22
a283 5
		tos = iicprobew(LM75Tos) & mask;
		if (tos != (iicprobew(0x06 + i) & mask) ||
		    tos != (iicprobew(0x07 + i) & mask))
			return (NULL);
		if (ret == 75) {
d288 5
a292 1
		} else {
a295 1
		}
d298 18
a315 2
	/* We hope */
	if (ret == 75)
d317 10
a326 1
	return ("lm77");
d765 1
a765 1
	    (addr & 0x7c) == 0x48) {		/* addr 0b1001xxx */
@


1.86
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.85 2006/07/12 12:39:13 kettenis Exp $	*/
d500 11
d540 8
@


1.85
log
@Add missing break.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.84 2006/07/12 12:34:32 kettenis Exp $	*/
d481 1
a481 1
	switch(iicprobe(0xfe)) {
@


1.84
log
@Sort switch statements by vendor ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.83 2006/06/14 20:42:36 deraadt Exp $	*/
d529 1
@


1.83
log
@teach it fintek f75375; half by drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.82 2006/04/29 12:04:26 djm Exp $	*/
d337 34
d434 5
a438 12
	case 0xa1:		/* Philips */
		if ((iicprobe(0x3f) & 0xf0) == 0x20 &&
		    (iicprobe(0x40) & 0x80) == 0x00 &&
		    (iicprobe(0x41) & 0xc0) == 0x00 &&
		    (iicprobe(0x42) & 0xbc) == 0x00)
			name = "ne1619";	/* adm1025 compat */
		break;
	case 0x23:		/* Analog Devices? */
		if (iicprobe(0x48) == addr &&
		    (iicprobe(0x40) & 0x80) == 0x00 &&
		    (addr & 0x7c) == 0x2c)
			name = "adm9240";	/* lm87 clone */
a446 30
	case 0x01:		/* National Semiconductor */
		/*
		 * Some newer National products use a vendor code at
		 * 0x3e of 0x01, and then 0x3f contains a product code
		 * But some older products are missing a product code,
		 * and contain who knows what in that register.  We assume
		 * that some employee was smart enough to keep the numbers
		 * unique.
		 */
		if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0x3f) == 0x73)
			name = "lm93";
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0x3f) == 0x68)
			name = "lm96000";	/* adt7460 compat? */
		else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    (iicprobe(0x3f) == 0x60 || iicprobe(0x3f) == 0x62))
			name = "lm85";		/* lm85C/B == adt7460 compat */
		else if ((addr & 0x7c) == 0x2c &&	/* addr 0b01011xx */
		    iicprobe(0x48) == addr &&
		    (iicprobe(0x3f) == 0x03 || iicprobe(0x3f) == 0x04) &&
		    (iicprobe(0x40) & 0x80) == 0x00)
			name = "lm81";
		break;
	case 0x49:		/* Texas Instruments */
		if ((addr == 0x2c || addr == 0x2e || addr == 0x2f) &&
		    (iicprobe(0x3f) & 0xf0) == 0xc0 &&
		    (iicprobe(0x40) & 0x80) == 0x00)
			name = "thmc50";	/* adm1022 clone */
		break;
d458 6
a463 3
	case 0x02:		/* National Semiconductor? */
		if ((iicprobe(0x3f) & 0xfc) == 0x04)
			name = "lm87";		/* complete check */
d500 1
a500 22
	case 0x4d:		/* Maxim */
		if ((addr == 0x18 || addr == 0x19 || addr == 0x1a ||
		     addr == 0x29 || addr == 0x2a || addr == 0x2b ||
		     addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
		    iicprobe(0xff) == 0x08 && (iicprobe(0x02) & 0x03) == 0 &&
		    (iicprobe(0x03) & 0x07) == 0 && iicprobe(0x04) <= 0x08)
			name = "max6690";
		else if ((addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
		    iicprobe(0xff) == 0x59 && (iicprobe(0x03) & 0x1f) == 0 &&
		    iicprobe(0x04) <= 0x07)
			name = "max6646";	/* max6647/8/9, max6692 */
		else if ((addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
		    (iicprobe(0x02) & 0x2b) == 0 &&
		    (iicprobe(0x03) & 0x0f) == 0 && iicprobe(0x04) <= 0x09) {
			name = "max6657";	/* max6658, max6659 */
			skip_fc = 1;
		} else if ((addr >= 0x48 && addr <= 0x4f) &&
		    (iicprobe(0x02) & 0x2b) == 0 &&
		    (iicprobe(0x03) & 0x0f) == 0)
			name = "max6642";
		break;
	case 0x41:
d529 21
@


1.82
log
@bring back skip_fc SMI workaround for max6657 chips; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.81 2006/04/17 18:33:00 kettenis Exp $	*/
d614 5
@


1.81
log
@Reorganize the 0xfe vendor register block, adding new devices and tightening
checks on existing devices.
"slap it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.80 2006/03/22 21:03:40 kettenis Exp $	*/
d513 1
a513 1
		    (iicprobe(0x03) & 0x0f) == 0 && iicprobe(0x04) <= 0x09)
d515 2
a516 1
		else if ((addr >= 0x48 && addr <= 0x4f) &&
@


1.80
log
@Detect newer revisions of the LM81.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.79 2006/03/19 18:19:35 deraadt Exp $	*/
d429 2
a430 10
		if (iicprobe(0x3f) == 0x52 && iicprobe(0xff) == 0x01 &&
		    (iicprobe(0xfe) == 0x4c || iicprobe(0xfe) == 0x4d))
			name = "lm89";		/* lm89 "alike" */
		else if (iicprobe(0x3f) == 0x33 && iicprobe(0xff) == 0x01 &&
		    iicprobe(0xfe) == 0x21)
			name = "lm90";		/* lm90 "alike" */
		else if (iicprobe(0x3f) == 0x49 && iicprobe(0xff) == 0x01 &&
		    (iicprobe(0xfe) == 0x31 || iicprobe(0xfe) == 0x34))
			name = "lm99";		/* lm99 "alike" */
		else if (iicprobe(0x3f) == 0x73)
a431 2
		else if (iicprobe(0x3f) == 0x17)
			name = "lm86";
d471 1
d481 5
a485 13
	if (iicprobe(0xfe) == 0x01) {
		/* Some more National devices ...*/
		if (iicprobe(0xff) == 0x21 && (iicprobe(0x03) & 0x2a) == 0 &&
		    iicprobe(0x04) <= 0x09 && iicprobe(0xff))
			name = "lm90";		/* complete check */
		else if (addr == 0x4c && iicprobe(0xff) == 0x31 &&
		    (iicprobe(0x03) & 0x2a) == 0 && iicprobe(0x04) <= 0x09)
			name = "lm99";
		else if (addr == 0x4d && iicprobe(0xff) == 0x34 &&
		    (iicprobe(0x03) & 0x2a) == 0 && iicprobe(0x04) <= 0x09)
			name = "lm99-1";
		else if (iicprobe(0xff) == 0x11 &&
		    (iicprobe(0x03) & 0x2a) == 0 && iicprobe(0x04) <= 0x09)
d487 65
a551 14
	} else if (iicprobe(0xfe) == 0x4d && iicprobe(0xff) == 0x08) {
		name = "max6690";	/* somewhat similar to lm90 */
	} else if ((addr == 0x4c || addr == 0x4d) &&
	    iicprobe(0xfe) == 0x41 && (iicprobe(0x03) & 0x2a) == 0 &&
	    iicprobe(0x04) <= 0x09) {
		name = "adm1032";
		skip_fc = 1;
	} else if ((addr == 0x18 || addr == 0x19 || addr == 0x1a ||
	    addr == 0x29 || addr == 0x2a || addr == 0x2b ||
	    addr == 0x4c || addr == 0x4d || addr == 0x4e) &&
	    iicprobe(0xfe) == 0x41 && iicprobe(0x3c) == 0x00) {
		name = "adm1021";	/* lots of addresses... bleah */
		skip_fc = 1;
	} else if (addr == iicprobe(0x48) &&
@


1.79
log
@sis950 has 0x5b missing, so it looks more like an it8712f-a
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.78 2006/03/19 04:02:22 deraadt Exp $	*/
d450 2
a451 1
		    iicprobe(0x3f) == 0x03 && (iicprobe(0x40) & 0x80) == 0x00)
@


1.78
log
@ok, what i thought was sis950 is actually likely the it8712f-a
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.77 2006/03/18 23:06:47 deraadt Exp $	*/
d646 1
a646 1
			name = "it8712f-a";		/* we think */
@


1.77
log
@probe for it8712 and sis950 (somewhat of a clone)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.76 2006/03/12 11:18:51 kettenis Exp $	*/
d371 1
a371 1
                        name = "adm1030";       /* complete check */
d558 1
a558 1
			 name = "w83781d";
d646 1
a646 1
			name = "sis950";		/* we think */
@


1.76
log
@Tweak comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.75 2006/03/07 22:36:39 kettenis Exp $	*/
d619 1
a619 1
		   (addr & 0x7c) == 0x48) {		/* addr 0b1001xxx */
d641 8
@


1.75
log
@Add a few more SMSC devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.74 2006/03/07 21:27:52 kettenis Exp $	*/
d462 1
a462 1
			name = "emc6d100";	/* adt7460 compat */
@


1.74
log
@Improve adm1030/adm1031 detection.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.73 2006/03/04 12:18:58 kettenis Exp $	*/
d462 7
a468 1
			name = "emc6d10x";	/* adt7460 compat */
@


1.73
log
@Re-enable I2C_VERBOSE.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.72 2006/03/04 02:58:14 deraadt Exp $	*/
d360 1
a360 1
		else if ((addr & 0x7c) == 0x2c &&	/* addr 0b01011xx */
d362 1
a362 4
		    (iicprobe(0x3f) & 0x70) == 0x00 &&
		    (iicprobe(0x01) & 0x4a) == 0x00 &&
		    (iicprobe(0x03) & 0x3f) == 0x00 &&
		    (iicprobe(0x22) & 0xf0) == 0x00 &&
d365 8
a372 2
			name = "adm1030";	/* complete check */
		else if ((addr & 0x7c) == 0x2c &&	/* addr 0b01011xx */
d374 1
a374 1
		    (iicprobe(0x03) & 0x3f) == 0x00 &&
@


1.72
log
@handle lm96000 (another similar chip); ok kettenis, tested by stu@@spacehopper.org
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.71 2006/02/26 18:38:53 grange Exp $	*/
d31 1
a31 1
#undef I2C_VERBOSE		/* XXX Re-enable after release. */
@


1.71
log
@Don't touch i2c bus tag internals directly.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.70 2006/02/25 21:38:56 kettenis Exp $	*/
d440 1
a440 1
		    iicprobe(0x3f) == 0x68 && iicprobe(0xf8) != 0x01)
@


1.70
log
@Make sure we print something for unidentified devices.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.69 2006/02/25 17:58:01 kettenis Exp $	*/
d100 1
a100 1
	probe_ic->ic_acquire_bus(probe_ic->ic_cookie, 0);
d104 1
a104 1
	probe_ic->ic_release_bus(probe_ic->ic_cookie, 0);
d119 1
a119 1
	probe_ic->ic_acquire_bus(probe_ic->ic_cookie, 0);
d123 1
a123 1
	probe_ic->ic_release_bus(probe_ic->ic_cookie, 0);
d674 1
a674 1
			ic->ic_acquire_bus(ic->ic_cookie, 0);
d677 1
a677 1
				ic->ic_release_bus(ic->ic_cookie, 0);
d682 1
a682 1
				ic->ic_acquire_bus(ic->ic_cookie, 0);
d685 1
a685 1
			ic->ic_release_bus(ic->ic_cookie, 0);
@


1.69
log
@#undef I2C_VERBOSE; re-enable after release.
prompted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.68 2006/02/08 23:15:58 dlg Exp $	*/
d641 5
@


1.68
log
@add a member to the i2c_attach args so that a controller can pass a
cookie down to the device. the most obvious use of this is to pass a
device its ofw node on sparc64 and macppc so it can configure itself more
appropriately.

ok kettenis@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.67 2006/02/08 19:02:37 kettenis Exp $	*/
d31 1
a31 1
#define I2C_VERBOSE
@


1.67
log
@Fix lm75 check.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.66 2006/02/04 18:19:20 kettenis Exp $	*/
d643 1
@


1.66
log
@s/amd1032cloneprobe/adm1032cloneprobe/g
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.65 2006/01/29 12:48:27 kettenis Exp $	*/
d162 1
a162 1
	temp = iicprobew(LM75TEMP) & mask;
d164 2
a165 2
	thyst = iicprobew(LM75Thyst) & mask;
	tos = iicprobew(LM75Tos) & mask;
d170 4
@


1.65
log
@Don't probe address 0x4f.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.64 2006/01/28 15:55:35 kettenis Exp $	*/
d78 1
a78 1
char		*amd1032cloneprobe(u_int8_t);
d241 1
a241 1
amd1032cloneprobe(u_int8_t addr)
d629 1
a629 1
		name = amd1032cloneprobe(addr);
@


1.64
log
@Move address checks forward.  Cleanup comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.63 2006/01/28 11:26:51 kettenis Exp $	*/
d35 6
a40 1
/* addresses at which to probe for sensors */
d47 1
a47 1
	{ 0x48, 0x4f }
@


1.63
log
@Disable ds1624/ds1631/ds1721 probe.
requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.62 2006/01/23 23:07:01 kettenis Exp $	*/
d323 4
d328 1
a328 1
	case 0x41:
a329 1
		 * Analog Devices adt/adm product code at 0x3e == 0x41.
d332 1
a332 1
		 * upper half of the "step register" at 0x3f
d334 1
a334 4
		if (iicprobe(0x3d) == 0x76 &&
		    (addr == 0x2c || addr == 0x2d || addr == 0x2e))
			name = "adt7476";
		else if ((addr == 0x2c || addr == 0x2e || addr == 0x2f) &&
d337 3
d346 2
a347 2
		else if (iicprobe(0x3d) == 0x68 && addr == 0x2e &&
		    (iicprobe(0x3f) & 0xf0) == 0x70)
d379 2
a380 1
		else if ((iicprobe(0x3f) & 0xf0) == 0xd0 && addr == 0x2e &&
d383 2
a384 2
		else if ((iicprobe(0x3f) & 0xf0) == 0xc0 &&
		    (addr == 0x2c || addr == 0x2e || addr == 0x2f) &&
d388 1
a388 2
	case 0xa1:
		/* Philips vendor code 0xa1 at 0x3e */
d395 1
a395 1
	case 0x23:	/* 2nd ADM id? */
d401 5
a405 4
	case 0x55:
		if (iicprobe(0x3f) == 0x20 && (iicprobe(0x47) & 0x70) == 0x00 &&
		    (iicprobe(0x49) & 0xfe) == 0x80 &&
		    (addr & 0x7c) == 0x2c)
d408 1
a408 1
	case 0x01:
d430 2
a431 3
		else if (iicprobe(0x3f) == 0x68 &&
		    (addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    iicprobe(0xf8) != 0x01)
d433 2
a434 2
		else if ((iicprobe(0x3f) == 0x60 || iicprobe(0x3f) == 0x62) &&
		    (addr == 0x2c || addr == 0x2d || addr == 0x2e))
d436 3
a438 2
		else if (iicprobe(0x3f) == 0x03 && iicprobe(0x48) == addr &&
		    ((iicprobe(0x40) & 0x80) == 0x00) && ((addr & 0x7c) == 0x2c))
d441 3
a443 3
	case 0x49:	/* TI */
		if ((iicprobe(0x3f) & 0xf0) == 0xc0 &&
		    (addr == 0x2c || addr == 0x2e || addr == 0x2f) &&
d447 3
a449 3
	case 0x5c:	/* SMSC */
		if ((iicprobe(0x3f) & 0xf0) == 0x60 &&
		    (addr == 0x2c || addr == 0x2d || addr == 0x2e))
d452 1
a452 1
	case 0x02:
d456 1
a456 1
	case 0xda:
d463 1
a463 1
	case 0x41:
a464 1
		    /* addr 0b1001{000, 010, 011} */
d476 1
a476 1
		else if (iicprobe(0xff) == 0x31 && addr == 0x4c &&
d479 1
a479 1
		else if (iicprobe(0xff) == 0x34 && addr == 0x4d &&
d487 3
a489 2
	} else if (iicprobe(0xfe) == 0x41 && (addr == 0x4c || addr == 0x4d) &&
	    (iicprobe(0x03) & 0x2a) == 0 && iicprobe(0x04) <= 0x09) {
d492 1
a492 2
	} else if (iicprobe(0xfe) == 0x41 && iicprobe(0x3c) == 0x00 &&
	    (addr == 0x18 || addr == 0x19 || addr == 0x1a ||
d494 2
a495 1
	    addr == 0x4c || addr == 0x4d || addr == 0x4e)) {
d577 2
a578 1
	} else if ((addr == 0x2c || addr == 0x2d) && iicprobe(0x00) == 0x80 &&
d597 2
a598 2
	} else if (iicprobe(0x16) == 0x41 && ((iicprobe(0x17) & 0xf0) == 0x40) &&
	    (addr == 0x2c || addr == 0x2d || addr == 0x2e)) {
d600 2
a601 1
	} else if (name == NULL && (addr & 0x7c) == 0x48) {
d609 1
a609 1
	if (name == NULL && (addr & 0x7c) == 0x48 &&
a644 1

@


1.62
log
@The GL518SM is a real piece of shit, and if we don't detect it bad things
will happen.  The comment in the code has all the gory details.
tested by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.61 2006/01/18 21:53:22 kettenis Exp $	*/
d598 5
d616 1
@


1.61
log
@Fix typo; w83l785ts-l has chip ID 0x70.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.60 2006/01/17 21:21:56 kettenis Exp $	*/
d573 19
@


1.60
log
@AS99127F rev 1 doesn't have i2c address in register 0x48.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.59 2006/01/15 12:15:17 kettenis Exp $	*/
d544 1
a544 1
	} else if (addr == 0x2e && iicprobe(0x4e) == 0x50 &&
@


1.59
log
@Fix typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.58 2006/01/14 22:23:54 kettenis Exp $	*/
d547 1
a547 1
	} else if (addr == iicprobe(0x48) &&
@


1.58
log
@Detect more Winbond chips.
"Of course!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.57 2006/01/13 02:21:46 deraadt Exp $	*/
d546 1
a546 1
		name = "w83l785s-l";
@


1.57
log
@damn, on the ds1721 we can be sure of even fewer known bits
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.56 2006/01/13 01:44:59 deraadt Exp $	*/
a520 1
			case 0x72:			/* rev 2? */
d523 3
d538 9
@


1.56
log
@introduce the most stupid basic scan check for the maximally braindead
ds1631/1624/1721 chips.  this will need improvement -- we MUST check for
more registers that alias or don't -- because we tend to write these chips
ok grange
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.55 2006/01/12 00:12:37 deraadt Exp $	*/
d578 1
a578 1
		else if ((iicprobe(0xac) & 0x7e) == 0x0e)
@


1.55
log
@attempt to probe for the ds1624; ok grange
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.54 2006/01/11 20:18:58 kettenis Exp $	*/
d567 13
a579 4
	} else if (name == NULL && (addr & 0x7c) == 0x48 &&
	    (iicprobe(0xac) & 0x7e) == 0x4a &&
	    (iicprobew(0xaa) & 0x0007) == 0x0000) {
		name = "ds1624";
@


1.54
log
@Identify Winbond chips that are in a non-zero register bank as w83781d.
Let the driver sort out the proper chip detection in that case.
"I like it" deraadt@@, tested by robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.53 2006/01/09 18:50:23 deraadt Exp $	*/
d565 1
a565 1
	} else if (name == NULL && (addr & 0xfc) == 0x48) {
d567 4
@


1.53
log
@do a lot more careful register checking for echos and roll-around and
nonsense values in the lm75 probe.  while there, make it look for a
significant difference the lm77 has, ok grange
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.52 2006/01/06 01:48:45 deraadt Exp $	*/
d494 3
a496 2
	} else if ((iicprobe(0x4f) == 0x5c && (iicprobe(0x4e) & 0x80)) ||
	    (iicprobe(0x4f) == 0xa3 && !(iicprobe(0x4e) & 0x80))) {
d502 33
a534 24
		switch (iicprobe(0x58)) {
		case 0x10:
		case 0x11:			/* rev 2? */
			name = "w83781d";
			break;
		case 0x21:
			name = "w83627hf";
			break;
		case 0x30:
			name = "w83782d";
			break;
		case 0x31:
			name = "as99127f";	/* rev 2 */
			break;
		case 0x40:
			name = "w83783s";
			break;
		case 0x71:
		case 0x72:			/* rev 2? */
			name = "w83791d";
			break;
		case 0x7a:
			name = "w83792d";
			break;
d536 2
a537 1
	} else if (iicprobe(0x4f) == 0x12 && (iicprobe(0x4e) & 0x80)) {
@


1.52
log
@pick some register with a known value, to try to tell a lm96000 apart
from any of a variety of National superio chipsets for which documention
is very hard to find
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.51 2006/01/05 23:00:40 deraadt Exp $	*/
d72 1
a72 1
int		lm75probe(void);
d106 1
a106 1
	u_int16_t data2;
d116 2
a117 2
	    probe_addr, &cmd, 1, &data2, 2, 0) != 0)
		data2 = 0xffff;
d119 1
a119 1
	return (data2);
d131 9
d141 8
a148 2
 * 0x06 and 0x07 return whatever value was read before, and the
 * chip loops every 8 registers.
d150 1
a150 1
int
d153 33
a185 3
	u_int16_t mains[6];
	u_int8_t main;
	int i;
d187 19
a205 20
	main = iicprobenc(0x01);
	mains[0] = iicprobew(0x02);
	mains[1] = iicprobew(0x03);

	if (main == 0xff && mains[0] == 0xffff && mains[1] == 0xffff)
		return (0);
	mains[2] = iicprobew(0x04);	/* read Low Limit */
	if (iicprobew(0x07) != mains[2] || iicprobew(0x07) != mains[2])
		return (0);

	mains[3] = iicprobew(0x05);	/* read High limit */
	mains[4] = iicprobew(0x06);
	mains[5] = iicprobew(0x07);
	if (mains[4] != mains[3] || mains[5] != mains[3])
		return (0);

#if 0
	printf("lm75probe: %02x %04x %04x %04x %04x %04x %04x\n", main,
	    mains[0], mains[1], mains[2], mains[3], mains[4], mains[5]);
#endif
d207 1
a207 1
	/* a real lm75/77 repeats it's registers.... */
d209 18
a226 8
		if (main != iicprobenc(0x01 + i) ||
		    mains[0] != iicprobew(0x02 + i) ||
		    mains[1] != iicprobew(0x03 + i) ||
		    mains[2] != iicprobew(0x04 + i) ||
		    mains[3] != iicprobew(0x05 + i) ||
		    mains[4] != iicprobew(0x06 + i) ||
		    mains[5] != iicprobew(0x07 + i))
			return (0);
d230 3
a232 1
	return (1);
d554 4
a557 3
	} else if ((addr & 0xfc) == 0x48 && lm75probe()) {
		name = "lm75";
	} else if (name == NULL) {
@


1.51
log
@if both debug and verbose defined, only spit out the dump once
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.50 2006/01/04 18:36:22 deraadt Exp $	*/
d371 2
a372 1
		    (addr == 0x2c || addr == 0x2d || addr == 0x2e))
@


1.50
log
@detect lm96000
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.49 2006/01/04 18:14:47 deraadt Exp $	*/
d518 1
a518 1
#ifdef I2C_VERBOSE
d520 1
a520 1
#endif /* I2C_DEBUG */
@


1.49
log
@split out I2C_DEBUG into I2C_VERBOSE.  VERBOSE is on.  Turn on DEBUG to
show more information to i2c developers.  thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.48 2006/01/03 07:55:47 kettenis Exp $	*/
d370 1
a370 1
		else if ((iicprobe(0x3f) & 0xf0) == 0x60 &&
d372 4
a375 1
			name = "lm85";		/* adt7460 compat */
@


1.48
log
@Use "official" chip part names/numbers for matching.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.47 2005/12/31 20:54:50 miod Exp $	*/
d30 2
a31 1
#define I2C_DEBUG
d74 1
d229 24
d502 4
d515 2
a516 20
#ifdef I2C_DEBUG
	{
		u_int8_t val = iicprobe(0);
		int cnt = 0;

		for (i = 1; i <= 0xff; i++) {
			if (val == iicprobe(i))
				cnt++;
		}
		if (cnt <= 254) {
			printf("%s: addr 0x%x", self->dv_xname, addr);
			for (i = 0; i <= 0xff; i++) {
				if (iicprobe(i) != 0xff)
					printf(" %02x=%02x", i, iicprobe(i));
			}
			if (name)
				printf(": %s", name);
			printf("\n");
		}
	}
@


1.47
log
@Better bounds for the lm7x register repeat test; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.46 2005/12/31 18:34:26 deraadt Exp $	*/
d201 1
a201 1
		/* 0xfe may be maxim, or some other vendor */
d203 1
a203 1
			return ("maxim1617");
d397 1
a397 1
		name = "maxim6690";	/* somewhat similar to lm90 */
@


1.46
log
@we do not look at the proberegs anymore, always full dumps
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.45 2005/12/31 18:26:11 deraadt Exp $	*/
d162 1
a162 1
	for (i = 0x08; i < 0xff; i += 8) {
@


1.45
log
@if a register dump is going to find that all the registers are the same,
then skip it.  it's some quirky piece of garbage we can never support
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.44 2005/12/31 04:31:20 deraadt Exp $	*/
a45 8

/* registers to print if we fail to probe */
// u_int8_t probereg[] = {
//	0x00, 0x01, 0x02, 0x03, 0x07,
//	0x3d, 0x3e, 0x3f,
//	0x4c, 0x4d, 0x4e, 0x4f,
//	0x58, 0xfe, 0xff
//};
@


1.44
log
@we think we can now probe chips correctly.  only print the register dump
if we fail to attach a driver to a chip name.  this means that if we
incorrectly diagnose a chip, someone will have to compile a debug kernel.
i think we are ready for this, but we will see what the next week brings.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.43 2005/12/31 02:50:32 deraadt Exp $	*/
d48 6
a53 6
u_int8_t probereg[] = {
	0x00, 0x01, 0x02, 0x03, 0x07,
	0x3d, 0x3e, 0x3f,
	0x4c, 0x4d, 0x4e, 0x4f,
	0x58, 0xfe, 0xff
};
d494 18
a511 8
	printf("%s: addr 0x%x", self->dv_xname, addr);
//	for (i = 0; i < sizeof(probereg); i++) {
//		if (iicprobe(probereg[i]) != 0xff)
//			printf(" %02x=%02x", probereg[i], iicprobe(probereg[i]));
//	}
	for (i = 0; i <= 0xff; i++) {
		if (iicprobe(i) != 0xff)
			printf(" %02x=%02x", i, iicprobe(i));
a512 3
	if (name)
		printf(": %s", name);
	printf("\n");
@


1.43
log
@add lots of comments.  run the xeontemp probe stuff on other architectures as
well since we are seeing some of these crummy adm1021/maxim1617 clones on
other architectures.  (Intel specified that there was a sensor chip with a
certain register layout on their Xeon processors.  That register layout is a
subset of the maxim1617, ie. without ID registers.  I guess they wanted to be
able to change them later.  But the result is that just as the industry was
starting to move towards all new chips having ID registers, Intel pushed them
all the other way... and now lots of vendors make chips like this without ID
registers.  Typical vendor power politics.)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.42 2005/12/31 00:52:42 deraadt Exp $	*/
d221 1
a221 1
}	
d401 1
a401 1
		else if (iicprobe(0xff) == 0x11 && 
d484 9
a507 7
	if (name) {
		ia.ia_tag = iba->iba_tag;
		ia.ia_addr = addr;
		ia.ia_size = 1;
		ia.ia_name = name;
		config_found(self, &ia, iic_print);
	}
@


1.42
log
@reyk, touching a file I am actively hacking on without talking to me is a serious mistake
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.39 2005/12/30 09:45:20 kettenis Exp $	*/
d80 1
a184 3
#ifdef __i386__
char 	*xeonprobe(u_int8_t);

d186 1
a186 1
xeonprobe(u_int8_t addr)
d212 6
a221 1
#endif
d419 3
a421 2
		 * We should toggle 0x4e bit 0x80, then re-read
		 * 0x4f to see if it is 0xa3 (for Winbond).
d450 3
a452 2
		 * We should toggle 0x4e bit 0x80, then re-read
		 * 0x4f to see if it is 0xc3 (for ASUS).
d460 3
a462 2
		 * We should toggle 0x4e bit 0x80, then re-read
		 * 0x4f to see if it is 0x94 (for ASUS).
d466 3
a468 1
		 * we see the right registers, but that would require a write
a477 1
#ifdef __i386__
d479 1
a479 1
		name = xeonprobe(addr);
a481 1
#endif
@


1.41
log
@add i2c driver for Asus ASB100 sensors using register info from lm_sensors
driver (Asus believe this chip is such critically important IP they won't
release docs for it); feedback deraadt@@ and kettenis@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.40 2005/12/30 17:39:33 reyk Exp $	*/
d480 4
a483 6
#if 0
	for (i = 0; i < sizeof(probereg); i++) {
		if (iicprobe(probereg[i]) != 0xff)
			printf(" %02x=%02x", probereg[i], iicprobe(probereg[i]));
	}
#endif
@


1.40
log
@knf (replace lines of c++/c99 '//' comments with #if 0)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.39 2005/12/30 09:45:20 kettenis Exp $	*/
d451 14
@


1.39
log
@Initial W83791D support for lm(4).
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.38 2005/12/30 04:05:30 deraadt Exp $	*/
d466 6
a471 4
//	for (i = 0; i < sizeof(probereg); i++) {
//		if (iicprobe(probereg[i]) != 0xff)
//			printf(" %02x=%02x", probereg[i], iicprobe(probereg[i]));
//	}
@


1.38
log
@check for another sign that a lm75 is not there
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.37 2005/12/29 16:08:03 kettenis Exp $	*/
d413 2
a414 1
	} else if (iicprobe(0x4f) == 0x5c && (iicprobe(0x4e) & 0x80)) {
d421 1
a423 3
		case 0x11:
			name = "w83781d";	/* rev 2? */
			break;
d437 1
a438 3
			break;
		case 0x72:
			name = "w12345x";	/* unknown chip id */
@


1.37
log
@Match a few more lm(4) Winbond and ASUS chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.36 2005/12/29 14:51:08 deraadt Exp $	*/
d151 2
d163 1
a163 1
#ifdef I2C_DEBUG
d166 1
a166 1
#endif /* I2C_DEBUG */
@


1.36
log
@stop using I2C_F_POLL; it is a bus driver responsibility now
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.35 2005/12/29 09:20:04 deraadt Exp $	*/
d414 35
a448 1
		 * 0x4f to see if it is 0xa3 (for Winbond)
d451 1
a451 1
			name = "as99127f";
@


1.35
log
@insanity debugged with djm -- here is the comment from the code:
+ * Some Maxim 1617 clones MAY NOT even read cmd 0xfc!  When it is
+ * read, they will power-on-reset.  Their default condition
+ * (control register bit 0x80) therefore will be that they assert
+ * /ALERT for the 5 potential errors that may occur.  One of those
+ * errors is that the external temperature diode is missing.  This
+ * is unfortunately a common choice of system designers, except
+ * suddenly now we get a /ALERT, which may on some chipsets cause
+ * us to receive an entirely unexpected SMI .. and then an NMI.
+ *
+ * As we probe each device, if we hit something which looks suspiciously
+ * like it may potentially be a 1617 or clone, we immediately set this
+ * variable to avoid reading that register offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.34 2005/12/29 01:25:31 deraadt Exp $	*/
d100 1
a100 1
	probe_ic->ic_acquire_bus(probe_ic->ic_cookie, I2C_F_POLL);
d102 1
a102 1
	    probe_addr, &cmd, 1, &data, 1, I2C_F_POLL) != 0)
d104 1
a104 1
	probe_ic->ic_release_bus(probe_ic->ic_cookie, I2C_F_POLL);
d119 1
a119 1
	probe_ic->ic_acquire_bus(probe_ic->ic_cookie, I2C_F_POLL);
d121 1
a121 1
	    probe_addr, &cmd, 1, &data2, 2, I2C_F_POLL) != 0)
d123 1
a123 1
	probe_ic->ic_release_bus(probe_ic->ic_cookie, I2C_F_POLL);
d467 1
a467 1
			ic->ic_acquire_bus(ic->ic_cookie, I2C_F_POLL);
d469 2
a470 2
			    &cmd, 1, NULL, 0, I2C_F_POLL) == 0) {
				ic->ic_release_bus(ic->ic_cookie, I2C_F_POLL);
d475 1
a475 1
				ic->ic_acquire_bus(ic->ic_cookie, I2C_F_POLL);
d478 1
a478 1
			ic->ic_release_bus(ic->ic_cookie, I2C_F_POLL);
@


1.34
log
@static functions suck
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.33 2005/12/28 23:05:38 deraadt Exp $	*/
d55 16
d94 6
d113 6
d205 1
a205 1
		for (reg = 0x0a; reg < 0xfe; reg++) {
d242 1
d404 1
d410 1
d426 2
d433 1
a433 1
//	for (i = 0; i < sizeof(probereg); i++)
d436 2
a437 1
	for (i = 0; i <= 0xff; i++)
d440 1
@


1.33
log
@probe for adm1032, a stupid stupid adm1021
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.32 2005/12/28 22:35:33 deraadt Exp $	*/
d59 5
a63 5
static void	probeinit(struct i2cbus_attach_args *, u_int8_t);
static u_int8_t	probenc(u_int8_t);
static u_int8_t	probe(u_int8_t);
static u_int16_t probew(u_int8_t);
static int	lm75probe(void);
d65 2
a66 2
static void
probeinit(struct i2cbus_attach_args *iba, u_int8_t addr)
d73 2
a74 2
static u_int8_t
probenc(u_int8_t cmd)
d86 2
a87 2
static u_int16_t
probew(u_int8_t cmd)
d99 2
a100 2
static u_int8_t
probe(u_int8_t cmd)
d104 1
a104 1
	probe_val[cmd] = probenc(cmd);
d112 1
a112 1
static int
d119 3
a121 3
	main = probenc(0x01);
	mains[0] = probew(0x02);
	mains[1] = probew(0x03);
d123 2
a124 2
	mains[2] = probew(0x04);	/* read Low Limit */
	if (probew(0x07) != mains[2] || probew(0x07) != mains[2])
d127 3
a129 3
	mains[3] = probew(0x05);	/* read High limit */
	mains[4] = probew(0x06);
	mains[5] = probew(0x07);
d140 7
a146 7
		if (main != probenc(0x01 + i) ||
		    mains[0] != probew(0x02 + i) ||
		    mains[1] != probew(0x03 + i) ||
		    mains[2] != probew(0x04 + i) ||
		    mains[3] != probew(0x05 + i) ||
		    mains[4] != probew(0x06 + i) ||
		    mains[5] != probew(0x07 + i))
d155 1
a155 1
static char 	*xeonprobe(u_int8_t);
d157 1
a157 1
static char *
d165 1
a165 1
		val = probe(0x00);
d167 1
a167 1
			if (probe(reg) == 0xff)
d169 1
a169 1
			if (probe(reg) == 0x00)
d171 1
a171 1
			if (val == probe(reg))
d176 1
a176 1
		val = probe(0x09);
d178 1
a178 1
			if (probe(reg) != val)
d182 1
a182 1
		if (probe(0xfe) == 0x4d)
d213 1
a213 1
	probeinit(iba, addr);
d215 1
a215 1
	switch (probe(0x3e)) {
d223 1
a223 1
		if (probe(0x3d) == 0x76 &&
d227 1
a227 1
		    probe(0x3d) == 0x70)
d229 2
a230 2
		else if (probe(0x3d) == 0x27 &&
		    (probe(0x3f) == 0x60 || probe(0x3f) == 0x6a))
d232 2
a233 2
		else if (probe(0x3d) == 0x27 &&
		    (probe(0x3f) == 0x62 || probe(0x3f) == 0x6a))
d235 2
a236 2
		else if (probe(0x3d) == 0x68 && addr == 0x2e &&
		    (probe(0x3f) & 0xf0) == 0x70)
d238 1
a238 1
		else if (probe(0x3d) == 0x33)
d241 7
a247 7
		    probe(0x3d) == 0x30 &&
		    (probe(0x3f) & 0x70) == 0x00 &&
		    (probe(0x01) & 0x4a) == 0x00 &&
		    (probe(0x03) & 0x3f) == 0x00 &&
		    (probe(0x22) & 0xf0) == 0x00 &&
		    (probe(0x0d) & 0x70) == 0x00 &&
		    (probe(0x0e) & 0x70) == 0x00)
d250 5
a254 5
		    probe(0x3d) == 0x31 &&
		    (probe(0x03) & 0x3f) == 0x00 &&
		    (probe(0x0d) & 0x70) == 0x00 &&
		    (probe(0x0e) & 0x70) == 0x00 &&
		    (probe(0x0f) & 0x70) == 0x00)
d257 4
a260 4
		    (probe(0x3f) & 0xf0) == 0x20 &&
		    (probe(0x40) & 0x80) == 0x00 &&
		    (probe(0x41) & 0xc0) == 0x00 &&
		    (probe(0x42) & 0xbc) == 0x00)
d263 2
a264 2
		    (probe(0x3f) & 0xf0) == 0x10 &&
		    (probe(0x40) & 0x80) == 0x00)
d266 1
a266 1
		else if ((probe(0xff) & 0xf0) == 0x30)
d268 2
a269 2
		else if ((probe(0x3f) & 0xf0) == 0xd0 && addr == 0x2e &&
		    (probe(0x40) & 0x80) == 0x00)
d271 1
a271 1
		else if ((probe(0x3f) & 0xf0) == 0xc0 &&
d273 1
a273 1
		    (probe(0x40) & 0x80) == 0x00)
d278 4
a281 4
		if ((probe(0x3f) & 0xf0) == 0x20 &&
		    (probe(0x40) & 0x80) == 0x00 &&
		    (probe(0x41) & 0xc0) == 0x00 &&
		    (probe(0x42) & 0xbc) == 0x00)
d285 2
a286 2
		if (probe(0x48) == addr &&
		    (probe(0x40) & 0x80) == 0x00 &&
d291 2
a292 2
		if (probe(0x3f) == 0x20 && (probe(0x47) & 0x70) == 0x00 &&
		    (probe(0x49) & 0xfe) == 0x80 &&
d305 2
a306 2
		if (probe(0x3f) == 0x52 && probe(0xff) == 0x01 &&
		    (probe(0xfe) == 0x4c || probe(0xfe) == 0x4d))
d308 2
a309 2
		else if (probe(0x3f) == 0x33 && probe(0xff) == 0x01 &&
		    probe(0xfe) == 0x21)
d311 2
a312 2
		else if (probe(0x3f) == 0x49 && probe(0xff) == 0x01 &&
		    (probe(0xfe) == 0x31 || probe(0xfe) == 0x34))
d314 1
a314 1
		else if (probe(0x3f) == 0x73)
d316 1
a316 1
		else if (probe(0x3f) == 0x17)
d318 1
a318 1
		else if ((probe(0x3f) & 0xf0) == 0x60 &&
d321 2
a322 2
		else if (probe(0x3f) == 0x03 && probe(0x48) == addr &&
		    ((probe(0x40) & 0x80) == 0x00) && ((addr & 0x7c) == 0x2c))
d326 1
a326 1
		if ((probe(0x3f) & 0xf0) == 0xc0 &&
d328 1
a328 1
		    (probe(0x40) & 0x80) == 0x00)
d332 1
a332 1
		if ((probe(0x3f) & 0xf0) == 0x60 &&
d337 1
a337 1
		if ((probe(0x3f) & 0xfc) == 0x04)
d341 2
a342 2
		if (probe(0x3f) == 0x01 && probe(0x48) == addr &&
		    (probe(0x40) & 0x80) == 0x00)
d346 1
a346 1
	switch (probe(0x4e)) {
d350 2
a351 2
		    (probe(0x4d) == 0x03 || probe(0x4d) == 0x08 ||
		    probe(0x4d) == 0x07))
d356 1
a356 1
	if (probe(0xfe) == 0x01) {
d358 2
a359 2
		if (probe(0xff) == 0x21 && (probe(0x03) & 0x2a) == 0 &&
		    probe(0x04) <= 0x09 && probe(0xff))
d361 2
a362 2
		else if (probe(0xff) == 0x31 && addr == 0x4c &&
		    (probe(0x03) & 0x2a) == 0 && probe(0x04) <= 0x09)
d364 2
a365 2
		else if (probe(0xff) == 0x34 && addr == 0x4d &&
		    (probe(0x03) & 0x2a) == 0 && probe(0x04) <= 0x09)
d367 2
a368 2
		else if (probe(0xff) == 0x11 && 
		    (probe(0x03) & 0x2a) == 0 && probe(0x04) <= 0x09)
d370 1
a370 1
	} else if (probe(0xfe) == 0x4d && probe(0xff) == 0x08) {
d372 2
a373 2
	} else if (probe(0xfe) == 0x41 && (addr == 0x4c || addr == 0x4d) &&
	    (probe(0x03) & 0x2a) == 0 && probe(0x04) <= 0x09) {
d375 1
a375 1
	} else if (probe(0xfe) == 0x41 && probe(0x3c) == 0x00 &&
d380 1
a380 1
	} else if (probe(0x4f) == 0x5c && (probe(0x4e) & 0x80)) {
d385 1
a385 1
		if (probe(0x58) == 0x31)
d387 1
a387 1
	} else if (probe(0x16) == 0x41 && ((probe(0x17) & 0xf0) == 0x40) &&
d401 2
a402 2
//		if (probe(probereg[i]) != 0xff)
//			printf(" %02x=%02x", probereg[i], probe(probereg[i]));
d404 2
a405 2
		if (probe(i) != 0xff)
			printf(" %02x=%02x", i, probe(i));
@


1.32
log
@correct copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.31 2005/12/28 22:30:53 deraadt Exp $	*/
d372 3
@


1.31
log
@probe true lm90, lm99, lm89, lm86 devices
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.30 2005/12/28 20:35:59 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Alexander Yurchenko <grange@@openbsd.org>
@


1.30
log
@if many regs in a "xeontemp" appear the same, it is not one
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.29 2005/12/28 01:02:58 deraadt Exp $	*/
d298 1
a298 1
		 * Most newer National products use a vendor code at
d307 1
a307 1
			name = "lm89";
d310 1
a310 1
			name = "lm90";
d313 1
a313 1
			name = "lm99";	/* and lm99-1 */
d323 1
a323 1
		    	name = "lm81";
d358 12
a369 2
		if (probe(0xff) == 0x33)
			name = "lm90";
@


1.29
log
@some chips (especially those crazy i2c/lpc/isa gross things) expose their
banks at other addresses, but there are issues with accessing these other
devices.  so allow a driver to "knock" these out from future probing.
tested by kettenis -- unfortunate enough to have one of these winbond pieces
of poo
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.28 2005/12/27 22:49:57 deraadt Exp $	*/
d163 1
a163 1
		int zero = 0;
d165 1
d169 1
a169 1
			if (probe(reg) == 0)
d171 2
d174 1
a174 1
		if (zero > 8)
@


1.28
log
@correct probe for ds1780 (lm87 clone)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.27 2005/12/27 22:14:23 deraadt Exp $	*/
a33 29
/*
 * some basic rules for finding devices...
 * 
 * 0x7 == 0x0001			national lm92
 * 0xfe == 0x4d			maxim (6659/6658/6659) == lm90
 * no 0x7 register??		maxim (6633/6634/6635) lm92
 * 
 * XXX remove this block of text later	
 * 0x00	National (on LM84)
 * 0x01	National
 * 0x12C3	Asus (at 0x4F)
 * 0x23	Analog Devices
 * 0x41	Analog Devices (also at 0x16)
 * 0x49	TI
 * 0x4D	Maxim
 * 0x54	On Semi
 * 0x5C	SMSC
 * 0x5D 	SMSC
 * 0x55	SMSC
 * 0x5CA3	Winbond (at 0x4F)
 * 0x90	ITE (at 0x58)
 * 0xA1	Philips (at 0x05 too)
 * 0xA3	Winbond (at 0x4F)
 * 0xAC	Myson (at 0x58)
 * 0xC3	Asus (at 0x4F)
 * 0xDA	Dallas
 * 0x54    Microchip (at 0x7)
 */

d44 3
d187 4
d192 6
a203 1
#ifdef I2C_DEBUG
d205 4
a208 1
#endif /* I2C_DEBUG */
d227 3
d411 1
@


1.27
log
@if too many of the early regs on a adm1021 are zero, it cannot be one..
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.26 2005/12/27 21:51:03 deraadt Exp $	*/
d350 2
a351 2
		    probe(0x00) == 0x00)
			name = "ds1780";	/* getting desperate! */
@


1.26
log
@adjust truth in adm comment
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.25 2005/12/27 21:42:07 grange Exp $	*/
d189 1
d191 1
a191 1
		for (reg = 0x00; reg < 0x09; reg++)
d194 5
d200 1
a200 1
		for (reg = 0x0a; reg < 0xfe; reg++)
d203 2
a206 1
		/* 0xfe may be maxim, or some other vendor */
@


1.25
log
@Don't touch ic_exec callback directly since it can be missed for some
controllers. Use iic_exec() instead.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.24 2005/12/27 21:22:36 deraadt Exp $	*/
d223 3
a225 3
		 * We probe newer to older.  newer chips have a valid 0x3d
		 * product number, while older ones encoded the product
		 * into the upper half of the step at 0x3f
@


1.24
log
@more paranoid checking for 47m192
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.23 2005/12/27 19:46:28 deraadt Exp $	*/
d105 1
a105 1
	if (probe_ic->ic_exec(probe_ic->ic_cookie, I2C_OP_READ_WITH_STOP,
d118 1
a118 1
	if (probe_ic->ic_exec(probe_ic->ic_cookie, I2C_OP_READ_WITH_STOP,
d420 1
a420 1
			if (ic->ic_exec(ic->ic_cookie, I2C_OP_READ_WITH_STOP, addr,
@


1.23
log
@correct adm2940 probe
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.22 2005/12/27 17:18:18 deraadt Exp $	*/
d292 3
a294 1
		if (probe(0x3f) == 0x20)
@


1.22
log
@no longer use ia_compat; tested by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.21 2005/12/27 09:23:28 deraadt Exp $	*/
d269 1
a269 1
		if ((probe(0x3f) & 0xf0) == 0xd0 && addr == 0x2e &&
a275 3
		else if (probe(0x48) == addr && probe(0x00) == 0x00 &&
		    (addr & 0x7c) == 0x2c)
			name = "adm9240";	/* getting desperate! */
d284 6
@


1.21
log
@match about 15 more clone chips
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.20 2005/12/27 03:46:50 deraadt Exp $	*/
a398 1
		ia.ia_compat = name;
@


1.20
log
@completely bogus adm1021 check; it is much more like the xeon-style
thingies; except for now i only want to do that rather loose check
chip on i386 machines
with this, i get sensors on a sparc64 v120.  hurray
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.19 2005/12/26 17:52:12 deraadt Exp $	*/
d227 2
a228 2
		if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) &&
		    probe(0x3d) == 0x76)
d236 3
d269 6
a274 1
		else if ((probe(0xff) & 0xf0) == 0x90)
d276 3
a278 2
		else if ((probe(0xff) & 0xf0) == 0x00)
			name = "adm1021";	/* ????? */
d314 17
d333 1
a333 1
		if ((probe(0x3f) & 0xfc) == 0x04) {
d335 5
a339 1
		}
d370 3
@


1.19
log
@split out debug code
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.18 2005/12/26 08:14:17 deraadt Exp $	*/
d269 1
a269 1
			name = "adm1021";
d328 5
@


1.18
log
@add address qualifiers to a few chips (ie. they can only occur at certain
addresses)
there are some "xeon" sensors that are actually real maxim1617, and hence
have a 0xfe register containing maxim's identifier .. cope.
remove totally bogus lm81 detection.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.17 2005/12/25 12:41:40 deraadt Exp $	*/
d30 2
d159 1
d162 1
d213 1
d215 1
d343 1
d354 1
@


1.17
log
@<= instead of < in two loops; spotted by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.16 2005/12/25 12:32:35 deraadt Exp $	*/
d177 1
a177 1
static int	xeonprobe(u_int8_t);
d179 1
a179 1
static int
d184 1
a184 1
		int reg;
d188 9
a196 5
				return (0);
		for (reg = 0x09; reg <= 0xff; reg++)
			if (probe(reg) != 0xff)
				return (0);
		return (1);
d198 1
a198 1
	return (0);
d221 2
a222 4
		if (probe(0x3d) == 0x03 || probe(0x3d) == 0x08 ||
		    probe(0x3d) == 0x07)
			name = "adt7516";	/* adt7517, adt7519 */
		if (probe(0x3d) == 0x76)
d224 2
a225 1
		else if (probe(0x3d) == 0x70)
d232 2
a233 1
		else if (probe(0x3d) == 0x30 &&
d241 2
a242 1
		else if (probe(0x3d) == 0x31 &&
d248 2
a249 1
		else if ((probe(0x3f) & 0xf0) == 0x20 &&
d254 2
a255 1
		else if ((probe(0x3f) & 0xf0) == 0x10 &&
a298 2
		else if (probe(0x3f) == 0x03)	/* are there others? */
			name = "lm81";
d306 9
d332 2
a333 2
	} else if (xeonprobe(addr)) {
		name = "xeon";
@


1.16
log
@even though some i2c devices have ID and chip registers which we can key
on, we must avoid false posities as much as possible.  we have to read
the manuals for the chips and find other registers which contain fixed
values (or even just fixed bits).  this will try to avoid us doing a
false detection.  as well, check for a few more chip types.. (miod should
try with this)
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.15 2005/12/24 23:29:22 deraadt Exp $	*/
d189 1
a189 1
		for (reg = 0x09; reg < 0xff; reg++)
d327 1
a327 1
	for (i = 0; i < 0xff; i++)
@


1.15
log
@even though the adm1021 manual page doesn't say that the rev at 0xff
was always 0x0?, the adm1021A (which uses 0x3?) manual page does claim
that this was the case.  trust it, why not.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.14 2005/12/24 22:08:17 deraadt Exp $	*/
d157 1
a157 1
	printf("lm75: %02x %04x %04x %04x %04x %04x %04x\n", main,
d209 2
a210 1
	if (probe(0x3e) == 0x41) {
d224 3
a226 2
		else if (probe(0x3d) == 0x27)
			name = "adt7460";	/* adt746x */
d229 22
a250 8
		else if (probe(0x3d) == 0x30)
			name = "adm1030";
		else if (probe(0x3d) == 0x31)
			name = "adm1031";
		else if ((probe(0x3f) & 0xf0) == 0x20)
			name = "adm1025";
		else if ((probe(0xff) & 0xf0) == 0x10)
			name = "adm1024";
d257 2
a258 1
	} else if (probe(0x3e) == 0xa1) {
d260 4
a263 1
		if ((probe(0x3f) & 0xf0) == 0x20)
d265 2
a266 1
	} else if (probe(0x3e) == 0x55) {
d269 2
a270 1
	} else if (probe(0x3e) == 0x01) {
d279 9
a287 2
		if (probe(0x3f) == 0x49)
			name = "lm99";
a289 4
		else if (probe(0x3f) == 0x33)
			name = "lm90";
		else if (probe(0x3f) == 0x52)
			name = "lm89";
d294 9
a302 1
	} else if (probe(0xfe) == 0x01) {
a305 2
	} else if (probe(0x3e) == 0x02 && probe(0x3f) == 0x6) {
		name = "lm87";
@


1.14
log
@handle embedded xeon temperature probes.  yes, you got it -- i2c wires
coming off the processor... for an embedded adm1021 on the chip.  only
the "external" temperature is valid, the other one is disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.13 2005/12/24 19:33:40 deraadt Exp $	*/
d239 2
a240 2
		else
			name = "adm1021";	/* getting desperate.. */
d289 1
a290 1
#endif
@


1.13
log
@add lm75/77 detection (not tested yet) and adm1031 probing.
verbose logs for the moment, we still have a ways to go
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.12 2005/12/23 22:56:44 deraadt Exp $	*/
d65 2
d176 24
d286 3
d290 1
@


1.12
log
@build a cacheing-read api internally, so that we can be even more stingy
with i2c cycles.  as well, this will let us basically now write if/else
code for basically free.  much easier; tested by kettenis and pval
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.11 2005/12/23 21:23:43 deraadt Exp $	*/
d84 2
d108 13
d130 44
d203 2
a250 2
	} else if ((addr & 0xfc) == 0x48) {
		/* address for lm75/77 ... */
d258 2
d263 6
a268 3
	for (i = 0; i < sizeof(probereg); i++)
		if (probe(probereg[i]) != 0xff)
			printf(" %02x=%02x", probereg[i], probe(probereg[i]));
@


1.11
log
@better way to probe winbonds, with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.10 2005/12/23 20:54:24 deraadt Exp $	*/
d69 6
a74 14
/* registers to load by default */
u_int8_t probereg[] = { 0x3d, 0x3e, 0x3f, 0xfe, 0xff, 0x4e, 0x4f };
#define P_3d	0
#define P_3e	1
#define P_3f	2
#define P_fe	3
#define P_ff	4
#define P_4e	5
#define P_4f	6
u_int8_t probeval[sizeof(probereg)/sizeof(probereg[0])];

/* additional registers to load later, for debugging... */
u_int8_t fprobereg[] = {
	0x00, 0x01, 0x02, 0x03, 0x07, 0x4c, 0x4d, 0x4e, 0x4f, 0x58
d76 38
a113 11
#define Pf_00	0
#define Pf_01	1
#define Pf_02	2
#define Pf_03	3
#define Pf_07	4
#define Pf_4c	5
#define Pf_4d	6
#define Pf_4e	7
#define Pf_4f	8
#define Pf_58	9
u_int8_t fprobeval[sizeof(fprobereg)/sizeof(fprobereg[0])];
a118 1
	i2c_tag_t ic = iba->iba_tag;
a119 1
	u_int8_t data;
d122 1
a122 11
	/* Load registers used by many vendors as vendor/ID */
	ic->ic_acquire_bus(ic->ic_cookie, I2C_F_POLL);
	for (i = 0; i < sizeof(probereg); i++) {
		probeval[i] = 0xff;
		if (ic->ic_exec(ic->ic_cookie,
		    I2C_OP_READ_WITH_STOP, addr,
		    &probereg[i], 1, &data, 1,
		    I2C_F_POLL) == 0)
			probeval[i] = data;
	}
	ic->ic_release_bus(ic->ic_cookie, I2C_F_POLL);
d124 1
a124 1
	if (probeval[P_3e] == 0x41) {
d131 2
a132 2
		if (probeval[P_3d] == 0x03 || probeval[P_3d] == 0x08 ||
		    probeval[P_3d] == 0x07)
d134 1
a134 1
		if (probeval[P_3d] == 0x76)
d136 1
a136 1
		else if (probeval[P_3d] == 0x70)
d138 1
a138 1
		else if (probeval[P_3d] == 0x27)
d140 1
a140 1
		else if (probeval[P_3d] == 0x33)
d142 1
a142 1
		else if (probeval[P_3d] == 0x30)
d144 1
a144 1
		else if ((probeval[P_3f] & 0xf0) == 0x20)
d146 1
a146 1
		else if ((probeval[P_ff] & 0xf0) == 0x10)
d148 1
a148 1
		else if ((probeval[P_ff] & 0xf0) == 0x30)
d150 1
a150 1
		else if ((probeval[P_ff] & 0xf0) == 0x90)
d154 1
a154 1
	} else if (probeval[P_3e] == 0xa1) {
d156 1
a156 1
		if ((probeval[P_3f] & 0xf0) == 0x20)
d158 2
a159 2
	} else if (probeval[P_3e] == 0x55) {
		if (probeval[P_3f] == 0x20)
d161 1
a161 1
	} else if (probeval[P_3e] == 0x01) {
d170 1
a170 1
		if (probeval[P_3f] == 0x49)
d172 1
a172 1
		else if (probeval[P_3f] == 0x73)
d174 1
a174 1
		else if (probeval[P_3f] == 0x33)
d176 1
a176 1
		else if (probeval[P_3f] == 0x52)
d178 1
a178 1
		else if (probeval[P_3f] == 0x17)
d180 1
a180 1
		else if (probeval[P_3f] == 0x03)	/* are there others? */
d182 1
a182 1
	} else if (probeval[P_fe] == 0x01) {
d184 1
a184 1
		if (probeval[P_ff] == 0x33)
d186 1
a186 1
	} else if (probeval[P_3e] == 0x02 && probeval[P_3f] == 0x6) {
d188 1
a188 1
	} else if (probeval[P_fe] == 0x4d && probeval[P_ff] == 0x08) {
d192 1
a192 27
	}

	printf("%s: addr 0x%x", self->dv_xname, addr);
	for (i = 0; i < sizeof(probeval); i++)
		if (probeval[i] != 0xff)
			printf(" %02x=%02x", probereg[i], probeval[i]);

	if (name)
		goto gotname;

	printf(",");

	/* print out some more test register values.... */
	ic->ic_acquire_bus(ic->ic_cookie, I2C_F_POLL);
	for (i = 0; i < sizeof(fprobereg); i++) {
		fprobeval[i] = 0xff;
		if (ic->ic_exec(ic->ic_cookie,
		    I2C_OP_READ_WITH_STOP, addr, &fprobereg[i],
		    1, &data, 1, I2C_F_POLL) == 0 &&
		    data != 0xff) {
			fprobeval[i] = data;
			printf(" %02x=%02x", fprobereg[i], data);
		}
	}
	ic->ic_release_bus(ic->ic_cookie, I2C_F_POLL);

	if (probeval[P_4f] == 0x5c && (probeval[P_4e] & 0x80)) {
d197 1
a197 1
		if (fprobeval[Pf_58] == 0x31)
d201 4
a204 1
gotname:
@


1.10
log
@oops, 0x31 is as99127f
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.9 2005/12/23 20:51:29 deraadt Exp $	*/
a95 4
u_int8_t wprobereg[] = { 0x4f };
#define PW_4f	0
u_int16_t wprobeval[sizeof(wprobereg)/sizeof(wprobereg[0])];

d103 1
a103 2
	u_int16_t data2;
	int i, widetest = 0;
a182 2
	} else if (probeval[P_4f] == 0x5c) {
		widetest = 1;
d211 7
a217 24
	if (widetest) {
		printf(";");
		/* Load registers used by many vendors as vendor/ID */
		ic->ic_acquire_bus(ic->ic_cookie, I2C_F_POLL);
		for (i = 0; i < sizeof(wprobereg)/sizeof(wprobereg[0]); i++) {
			wprobeval[i] = 0xff;
			if (ic->ic_exec(ic->ic_cookie,
			    I2C_OP_READ_WITH_STOP, addr,
			    &wprobereg[i], 1, &data2, 2,
			    I2C_F_POLL) == 0) {
				wprobeval[i] = data2;
				printf(" %02x=%04x", wprobereg[0], data2);
			}
		}
		ic->ic_release_bus(ic->ic_cookie, I2C_F_POLL);

		if (wprobeval[PW_4f] == 0x5ca3 && (probeval[P_4e] & 0x80)) {
			if (fprobeval[Pf_58] == 0x10)
				name = "w83781d";
			else if (fprobeval[Pf_58] == 0x30)
				name = "w83782d";
			else if (fprobeval[Pf_58] == 0x31)
				name = "as99127f";
		}
@


1.9
log
@not quite becoming a nightmare, but we are getting there..
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.7 2005/12/23 15:09:37 deraadt Exp $	*/
d239 1
a239 1
			else if (fprobeval[Pf_58] == 0x30)
@


1.8
log
@set both ia_name and ia_compat
@
text
@d70 1
a70 1
u_int8_t probereg[] = { 0x3d, 0x3e, 0x3f, 0xfe, 0xff };
d76 3
a78 1
u_int8_t probeval[sizeof(probereg)];
d84 15
d107 2
a108 1
	int i;
d186 1
a186 1
	} else if (probeval[P_fe] == 0x4d && probeval[P_ff] == 0x08)
d188 3
a190 2
#if 0
	} else if ((addr & 0xfc) == 0x48)
a192 1
#endif
d194 1
a194 1
	printf("addr 0x%x at %s:", addr, self->dv_xname);
d198 1
d200 17
a216 3
		printf(": %s", name);
	else {
		u_int16_t data2;
d218 3
a220 2
		/* print out some more test register values.... */
		printf(",");
d222 2
a223 1
		for (i = 0; i < sizeof(fprobereg); i++) {
d225 6
a230 4
			    I2C_OP_READ_WITH_STOP, addr, &fprobereg[i],
			    1, &data, 1, I2C_F_POLL) == 0 &&
			    data != 0xff)
				printf(" %02x=%02x", fprobereg[i], data);
d232 1
a232 6
		/* And include a 16-bit one (LM77?) */
		if (ic->ic_exec(ic->ic_cookie,
		    I2C_OP_READ_WITH_STOP, addr, &fprobereg[0],
		    1, &data2, sizeof data2, I2C_F_POLL) == 0 &&
		    data2 != 0xffff)
			printf(", %02x=%04x", fprobereg[0], data2);
d234 8
a241 1
		ic->ic_release_bus(ic->ic_cookie, I2C_F_POLL);
d243 4
@


1.7
log
@another check register
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.6 2005/12/23 15:06:18 deraadt Exp $	*/
d211 1
a211 1
		ia.ia_compat = NULL;
@


1.6
log
@next generation.  grok a few more chips, but also change the logic to
correct locking, etc, etc, and even try a 16-bit register read just to
compare against if we fail to match..
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.5 2005/12/23 07:07:20 deraadt Exp $	*/
d79 3
a81 1
u_int8_t fprobereg[] = { 0x00, 0x01, 0x02, 0x03, 0x07, 0x4d, 0x4e, 0x4f, 0x58 };
@


1.5
log
@grok some more devices
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.4 2005/12/23 04:09:56 deraadt Exp $	*/
d61 1
a61 1
/* ports to probe for sensors */
d64 1
a64 1
} probe_paddrs[] = {
d66 1
a66 2
	{ 0x48, 0x4f },
	{ 0xad, 0xad }
d69 7
a75 11
u_int8_t probereg[] = { 0x3e, 0x3f, 0xfe, 0xff, 0x07, 0x4d, 0x4e, 0x4f, 0x58, 0x3d };
#define P_3e	0
#define P_3f	1
#define P_fe	2
#define P_ff	3
#define P_07	4
#define P_4d	5
#define P_4e	6
#define P_4f	7
#define P_58	8
#define P_3d	9
d78 3
d85 1
d87 1
d90 12
d131 1
a131 1
			name = "adm1021";
d136 3
d158 1
a158 1
		else if (probeval[P_3f] == 0x03)	/* and higher? */
d168 5
d180 22
d218 2
a219 2
	u_int8_t cmd = 0, addr, data;
	int i, j;
d221 2
a222 2
	for (j = 0; j < sizeof(probe_paddrs)/sizeof(probe_paddrs[0]); j++) {
		for (addr = probe_paddrs[j].start; addr <= probe_paddrs[j].end;
d228 1
d230 1
a230 8
				for (i = 0; i < sizeof(probereg); i++) {
					cmd = probereg[i];
					probeval[i] = 0xff;
					if (ic->ic_exec(ic->ic_cookie,
					    I2C_OP_READ_WITH_STOP, addr,
					    &cmd, 1, &data, 1, I2C_F_POLL) == 0)
						probeval[i] = data;
				}
d232 3
@


1.4
log
@work in progress towards "identifying" various devices on the i2c bus.
this will later on hopefully be table driven, but first I have to read
the 100 or so data sheets and start coding up detection rules.....
bleah
@
text
@d1 1
a1 1
/*	$OpenBSD: i2c_scan.c,v 1.2 2005/12/20 05:00:47 deraadt Exp $	*/
d92 2
a93 2
		 * Analog Devices adt/adm product code at 0x3e == 0x41
		 * probe newer to older.  newer chips have a valid 0x3d
d128 4
d145 5
a149 1
	} else if (probeval[P_3e] == 0x02 && probeval[P_3f] == 0x6)
d151 2
@


1.3
log
@typo
@
text
@d30 2
d33 26
a58 37
some basic devices...

 0x7 == 0x0001			national lm92
 0x3e == 0x01			national product
	0x3f == 0x73		lm93
 0x3e == 0x02			
	0x3f == 0x06		lm87 
 0xfe == 0x01			national product
	0xff == 0x33		lm90
	0xff == 0x49 0x52	lm99 lm89
	0xff == 0x17		lm86 
	0xff == ??		lm83?
 cannot identify		lm81 lm80
 0xfe == 0x4d			maxim (6659/6658/6659) == lm90
 no 0x7 register??		maxim (6633/6634/6635) lm92

XXX remove this block of text later	
0x00	National (on LM84)
0x01	National
0x12C3	Asus (at 0x4F)
0x23	Analog Devices
0x41	Analog Devices (also at 0x16)
0x49	TI
0x4D	Maxim
0x54	On Semi
0x5C	SMSC
0x5D 	SMSC
0x55	SMSC
0x5CA3	Winbond (at 0x4F)
0x90	ITE (at 0x58)
0xA1	Philips (at 0x05 too)
0xA3	Winbond (at 0x4F)
0xAC	Myson (at 0x58)
0xC3	Asus (at 0x4F)
0xDA	Dallas
0x54    Microchip (at 0x7)

d61 1
d70 91
a160 1
u_int8_t probe[] = { 0x3e, 0x3f, 0xfe, 0xff, 0x4f, 0x58, 0x07 };
d176 4
a179 3
				printf("addr 0x%x at %s: ", addr, self->dv_xname);
				for (i = 0; i < sizeof(probe); i++) {
					cmd = probe[i];
d182 2
a183 3
					    &cmd, 1, &data, 1, I2C_F_POLL) == 0 &&
					    data != 0xff)
						printf(" %02x=%02x", cmd, data);
d185 1
a185 1
				printf("\n");
@


1.2
log
@start at a 2nd generation scanner
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d20 1
a20 1
 * I2C bus scannig.
@


1.1
log
@First attempt to have a table of known I2C slave devices that we
have drivers for. iic(4) will scan the bus for them and try to
attach an appropriate driver.
For now iic(4) scans for all possible addresses for debugging purposes.

ok deraadt@@
@
text
@d25 1
d30 46
a75 8
/* Device signatures */
static const struct {
	const char *	name;
	i2c_addr_t	addr;
	u_int8_t	offset;
	u_int8_t	value;
} iicsig[] = {
	{ "foo",	0xff, 0xff, 0xff }
d78 2
d85 1
a85 12
	int i;

	/* Do full scan */
	printf("%s: full scan:", self->dv_xname);
	for (addr = 0; addr < 0x80; addr++) {
		ic->ic_acquire_bus(ic->ic_cookie, I2C_F_POLL);
		if (ic->ic_exec(ic->ic_cookie, I2C_OP_READ_WITH_STOP, addr,
		    &cmd, 1, NULL, 0, I2C_F_POLL) == 0)
			printf(" 0x%x", addr);
		ic->ic_release_bus(ic->ic_cookie, I2C_F_POLL);
	}
	printf("\n");
d87 19
a105 12
	/* Scan only for know signatures */
	printf("%s: sign scan:", self->dv_xname);
	for (i = 0; i < sizeof(iicsig) / sizeof(iicsig[0]); i++) {
		addr = iicsig[i].addr;
		cmd = iicsig[i].offset;

		ic->ic_acquire_bus(ic->ic_cookie, I2C_F_POLL);
		if (ic->ic_exec(ic->ic_cookie, I2C_OP_READ_WITH_STOP, addr,
		    &cmd, 1, &data, 1, I2C_F_POLL) == 0) {
			if (iicsig[i].value == 0xff ||
			    iicsig[i].value == data)
				printf(" %s", iicsig[i].name);
a106 1
		ic->ic_release_bus(ic->ic_cookie, I2C_F_POLL);
a107 1
	printf("\n");
@

