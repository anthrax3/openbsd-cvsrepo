head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.44
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.42
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.38
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.28
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.36
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.34
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.32
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.30
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.26
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.24
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.22
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.20
	OPENBSD_5_0:1.12.0.18
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.16
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.14
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.10
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.12
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.12
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.14.20.26.01;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.19.14.33.10;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.14.12.40.23;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.18.05.00.19;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.12.12.09.16;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.17.13.11.54;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.16.20.26.35;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.19.17.08.39;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.15.12.20.14;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.12
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@/*	$OpenBSD: w83l784r.c,v 1.11 2007/03/22 16:55:31 deraadt Exp $	*/

/*
 * Copyright (c) 2006 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/sensors.h>

#include <dev/i2c/i2cvar.h>

/* W83L784R registers */
#define W83L784R_VCORE		0x20
#define W83L784R_VBAT		0x21
#define W83L784R_3_3V		0x22
#define W83L784R_VCC		0x23
#define W83L784R_TEMP1		0x27
#define W83L784R_FAN1		0x28
#define W83L784R_FAN2		0x29
#define W83L784R_CONFIG		0x40
#define W83L784R_FANDIV		0x49
#define W83L784R_T23ADDR	0x4b
#define W83L784R_CHIPID		0x4e

#define W83L784R_TEMP23		0x00

/* W83L785R registers */
#define W83L785R_2_5V		0x21
#define W83L785R_1_5V		0x22
#define W83L785R_VCC		0x23
#define W83L785R_TEMP2		0x26
#define W83L785R_FANDIV		0x47

/* Chip IDs */
#define WBENV_CHIPID_W83L784R		0x50
#define WBENV_CHIPID_W83L785R		0x60
#define WBENV_CHIPID_W83L785TS_L	0x70

#define WBENV_MAX_SENSORS  9

/*
 * The W83L784R/W83L785R can measure voltages up to 4.096/2.048 V.
 * To measure higher voltages the input is attenuated with (external)
 * resistors.  So we have to convert the sensor values back to real
 * voltages by applying the appropriate resistor factor.
 */
#define RFACT_NONE	10000
#define RFACT(x, y)	(RFACT_NONE * ((x) + (y)) / (y))

struct wbenv_softc;

struct wbenv_sensor {
	char *desc;
	enum sensor_type type;
	u_int8_t reg;
	void (*refresh)(struct wbenv_softc *, int);
	int rfact;
};

struct wbenv_softc {
	struct device sc_dev;

	i2c_tag_t sc_tag;
	i2c_addr_t sc_addr[3];
	u_int8_t sc_chip_id;

	struct ksensor sc_sensors[WBENV_MAX_SENSORS];
	struct ksensordev sc_sensordev;
	struct wbenv_sensor *sc_wbenv_sensors;
	int sc_numsensors;
};

int	wbenv_match(struct device *, void *, void *);
void	wbenv_attach(struct device *, struct device *, void *);

void	wbenv_setup_sensors(struct wbenv_softc *, struct wbenv_sensor *);
void	wbenv_refresh(void *);

void	w83l784r_refresh_volt(struct wbenv_softc *, int);
void	w83l785r_refresh_volt(struct wbenv_softc *, int);
void	wbenv_refresh_temp(struct wbenv_softc *, int);
void	w83l784r_refresh_temp(struct wbenv_softc *, int);
void	w83l784r_refresh_fanrpm(struct wbenv_softc *, int);
void	w83l785r_refresh_fanrpm(struct wbenv_softc *, int);

u_int8_t wbenv_readreg(struct wbenv_softc *, u_int8_t);
void	wbenv_writereg(struct wbenv_softc *, u_int8_t, u_int8_t);

struct cfattach wbenv_ca = {
	sizeof(struct wbenv_softc), wbenv_match, wbenv_attach
};

struct cfdriver wbenv_cd = {
	NULL, "wbenv", DV_DULL
};

struct wbenv_sensor w83l784r_sensors[] =
{
	{ "VCore", SENSOR_VOLTS_DC, W83L784R_VCORE, w83l784r_refresh_volt, RFACT_NONE },
	{ "VBAT", SENSOR_VOLTS_DC, W83L784R_VBAT, w83l784r_refresh_volt, RFACT(232, 99) },
	{ "+3.3V", SENSOR_VOLTS_DC, W83L784R_3_3V, w83l784r_refresh_volt, RFACT_NONE },
	{ "+5V", SENSOR_VOLTS_DC, W83L784R_VCC, w83l784r_refresh_volt, RFACT(50, 34) },
	{ "", SENSOR_TEMP, W83L784R_TEMP1, wbenv_refresh_temp },
	{ "", SENSOR_TEMP, 1, w83l784r_refresh_temp },
	{ "", SENSOR_TEMP, 2, w83l784r_refresh_temp },
	{ "", SENSOR_FANRPM, W83L784R_FAN1, w83l784r_refresh_fanrpm },
	{ "", SENSOR_FANRPM, W83L784R_FAN2, w83l784r_refresh_fanrpm },

	{ NULL }
};

struct wbenv_sensor w83l785r_sensors[] =
{
	{ "VCore", SENSOR_VOLTS_DC, W83L784R_VCORE, w83l785r_refresh_volt, RFACT_NONE },
	{ "+2.5V", SENSOR_VOLTS_DC, W83L785R_2_5V, w83l785r_refresh_volt, RFACT(100, 100) },
	{ "+1.5V", SENSOR_VOLTS_DC, W83L785R_1_5V, w83l785r_refresh_volt, RFACT_NONE },
	{ "+3.3V", SENSOR_VOLTS_DC, W83L785R_VCC, w83l785r_refresh_volt, RFACT(20, 40) },
	{ "", SENSOR_TEMP, W83L784R_TEMP1, wbenv_refresh_temp },
	{ "", SENSOR_TEMP, W83L785R_TEMP2, wbenv_refresh_temp },
	{ "", SENSOR_FANRPM, W83L784R_FAN1, w83l785r_refresh_fanrpm },
	{ "", SENSOR_FANRPM, W83L784R_FAN2, w83l785r_refresh_fanrpm },

	{ NULL }
};

struct wbenv_sensor w83l785ts_l_sensors[] =
{
	{ "", SENSOR_TEMP, W83L784R_TEMP1, wbenv_refresh_temp },

	{ NULL }
};

int
wbenv_match(struct device *parent, void *match, void *aux)
{
	struct i2c_attach_args *ia = aux;

	if (strcmp(ia->ia_name, "w83l784r") == 0 ||
	    strcmp(ia->ia_name, "w83l785r") == 0 ||
	    strcmp(ia->ia_name, "w83l785ts-l") == 0)
		return (1);
	return (0);
}

void
wbenv_attach(struct device *parent, struct device *self, void *aux)
{
	struct wbenv_softc *sc = (struct wbenv_softc *)self;
	struct i2c_attach_args *ia = aux;
	u_int8_t cmd, data, config;
	int i;

	sc->sc_tag = ia->ia_tag;
	sc->sc_addr[0] = ia->ia_addr;

	iic_acquire_bus(sc->sc_tag, 0);

	cmd = W83L784R_CHIPID;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr[0], &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(": cannot read chip ID register\n");
		return;
	}

	iic_release_bus(sc->sc_tag, 0);

	sc->sc_chip_id = data;

	switch (sc->sc_chip_id) {
	case WBENV_CHIPID_W83L784R:
		printf(": W83L784R\n");
		wbenv_setup_sensors(sc, w83l784r_sensors);
		break;
	case WBENV_CHIPID_W83L785R:
		printf(": W83L785R\n");
		wbenv_setup_sensors(sc, w83l785r_sensors);
		goto start;
	case WBENV_CHIPID_W83L785TS_L:
		printf(": W83L785TS-L\n");
		wbenv_setup_sensors(sc, w83l785ts_l_sensors);
		goto start;
	default:
		printf(": unknown Winbond chip (ID 0x%x)\n", sc->sc_chip_id);
		return;
	}

	iic_acquire_bus(sc->sc_tag, 0);

	cmd = W83L784R_T23ADDR;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr[0], &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(": cannot read address register\n");
		return;
	}

	iic_release_bus(sc->sc_tag, 0);

	sc->sc_addr[1] = 0x48 + (data & 0x7);
	sc->sc_addr[2] = 0x48 + ((data >> 4) & 0x7);

	/* Make the bus scan ignore the satellites. */
	iic_ignore_addr(sc->sc_addr[1]);
	iic_ignore_addr(sc->sc_addr[2]);

 start:
	if (sensor_task_register(sc, wbenv_refresh, 5) == NULL) {
		printf("%s: unable to register update task\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* Start the monitoring loop */
	config = wbenv_readreg(sc, W83L784R_CONFIG);
	wbenv_writereg(sc, W83L784R_CONFIG, config | 0x01);

	/* Add sensors */
	for (i = 0; i < sc->sc_numsensors; ++i)
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensors[i]);
	sensordev_install(&sc->sc_sensordev);
}

void
wbenv_setup_sensors(struct wbenv_softc *sc, struct wbenv_sensor *sensors)
{
	int i;

	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	for (i = 0; sensors[i].desc; i++) {
		sc->sc_sensors[i].type = sensors[i].type;
		strlcpy(sc->sc_sensors[i].desc, sensors[i].desc,
		    sizeof(sc->sc_sensors[i].desc));
		sc->sc_numsensors++;
	}
	sc->sc_wbenv_sensors = sensors;
}

void
wbenv_refresh(void *arg)
{
	struct wbenv_softc *sc = arg;
	int i;

	iic_acquire_bus(sc->sc_tag, 0);

	for (i = 0; i < sc->sc_numsensors; i++)
		sc->sc_wbenv_sensors[i].refresh(sc, i);

	iic_release_bus(sc->sc_tag, 0);
}

void
w83l784r_refresh_volt(struct wbenv_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sc_sensors[n];
	int data, reg = sc->sc_wbenv_sensors[n].reg;

	data = wbenv_readreg(sc, reg);
	sensor->value = (data << 4); /* 16 mV LSB */
	sensor->value *= sc->sc_wbenv_sensors[n].rfact;
	sensor->value /= 10;
}

void
w83l785r_refresh_volt(struct wbenv_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sc_sensors[n];
	int data, reg = sc->sc_wbenv_sensors[n].reg;

	data = wbenv_readreg(sc, reg);
	sensor->value = (data << 3); /* 8 mV LSB */
	sensor->value *= sc->sc_wbenv_sensors[n].rfact;
	sensor->value /= 10;
}

void
wbenv_refresh_temp(struct wbenv_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sc_sensors[n];
	int sdata;

	sdata = wbenv_readreg(sc, sc->sc_wbenv_sensors[n].reg);
	if (sdata & 0x80)
		sdata -= 0x100;
	sensor->value = sdata * 1000000 + 273150000;
}

void
w83l784r_refresh_temp(struct wbenv_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sc_sensors[n];
	int16_t sdata;
	u_int8_t cmd = 0;

	iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr[sc->sc_wbenv_sensors[n].reg],
	    &cmd, sizeof cmd, &sdata, sizeof sdata, 0);
	sensor->value = (sdata >> 7) * 500000 + 273150000;
}

void
w83l784r_refresh_fanrpm(struct wbenv_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sc_sensors[n];
	int data, divisor;

	data = wbenv_readreg(sc, W83L784R_FANDIV);
	if (sc->sc_wbenv_sensors[n].reg == W83L784R_FAN1)
		divisor = data & 0x07;
	else
		divisor = (data >> 4) & 0x07;

	data = wbenv_readreg(sc, sc->sc_wbenv_sensors[n].reg);
	if (data == 0xff || data == 0x00) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = 1350000 / (data << divisor);
	}
}

void
w83l785r_refresh_fanrpm(struct wbenv_softc *sc, int n)
{
	struct ksensor *sensor = &sc->sc_sensors[n];
	int data, divisor;

	data = wbenv_readreg(sc, W83L785R_FANDIV);
	if (sc->sc_wbenv_sensors[n].reg == W83L784R_FAN1)
		divisor = data & 0x07;
	else
		divisor = (data >> 4) & 0x07;

	data = wbenv_readreg(sc, sc->sc_wbenv_sensors[n].reg);
	if (data == 0xff || data == 0x00) {
		sensor->flags |= SENSOR_FINVALID;
		sensor->value = 0;
	} else {
		sensor->flags &= ~SENSOR_FINVALID;
		sensor->value = 1350000 / (data << divisor);
	}
}

u_int8_t
wbenv_readreg(struct wbenv_softc *sc, u_int8_t reg)
{
	u_int8_t data;

	iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr[0], &reg, sizeof reg, &data, sizeof data, 0);

	return data;
}

void
wbenv_writereg(struct wbenv_softc *sc, u_int8_t reg, u_int8_t data)
{
	iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
	    sc->sc_addr[0], &reg, sizeof reg, &data, sizeof data, 0);
}
@


1.11
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.10 2006/12/23 17:46:39 deraadt Exp $	*/
d222 1
a222 1
	if (sensor_task_register(sc, wbenv_refresh, 5)) {
@


1.10
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.9 2006/11/14 20:26:01 kettenis Exp $	*/
d81 2
a82 2
	struct sensor sc_sensors[WBENV_MAX_SENSORS];
	struct sensordev sc_sensordev;
d272 1
a272 1
	struct sensor *sensor = &sc->sc_sensors[n];
d284 1
a284 1
	struct sensor *sensor = &sc->sc_sensors[n];
d296 1
a296 1
	struct sensor *sensor = &sc->sc_sensors[n];
d308 1
a308 1
	struct sensor *sensor = &sc->sc_sensors[n];
d321 1
a321 1
	struct sensor *sensor = &sc->sc_sensors[n];
d343 1
a343 1
	struct sensor *sensor = &sc->sc_sensors[n];
@


1.9
log
@Fix typos.  From Pierre Riteau <pierre.riteau at free dot fr>.
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.8 2006/06/19 14:33:10 kettenis Exp $	*/
d82 1
d117 5
a121 5
	{ "Temp1", SENSOR_TEMP, W83L784R_TEMP1, wbenv_refresh_temp },
	{ "Temp2", SENSOR_TEMP, 1, w83l784r_refresh_temp },
	{ "Temp3", SENSOR_TEMP, 2, w83l784r_refresh_temp },
	{ "Fan1", SENSOR_FANRPM, W83L784R_FAN1, w83l784r_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, W83L784R_FAN2, w83l784r_refresh_fanrpm },
d132 4
a135 4
	{ "Temp1", SENSOR_TEMP, W83L784R_TEMP1, wbenv_refresh_temp },
	{ "Temp2", SENSOR_TEMP, W83L785R_TEMP2, wbenv_refresh_temp },
	{ "Fan1", SENSOR_FANRPM, W83L784R_FAN1, w83l785r_refresh_fanrpm },
	{ "Fan2", SENSOR_FANRPM, W83L784R_FAN2, w83l785r_refresh_fanrpm },
d142 1
a142 1
	{ "Temp", SENSOR_TEMP, W83L784R_TEMP1, wbenv_refresh_temp },
d234 2
a235 1
		sensor_add(&sc->sc_sensors[i]);
d243 3
a246 2
		strlcpy(sc->sc_sensors[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sc_sensors[i].device));
@


1.8
log
@Avoid using the rfact member of 'struct sensor' which is on its way out.
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.7 2006/05/14 12:40:23 kettenis Exp $	*/
d189 1
a189 1
		printf(": W83L784R\n");
d191 1
a191 1
		goto start;;
d193 1
a193 1
		printf(": W83L784TS-L\n");
d195 1
a195 1
		goto start;;
@


1.7
log
@Add abstraction for resistor factors; makes it easier to compare them to
the datasheets.  Fix a few bugs in the handling of voltage sensors.
From Constantine Murenin <mureninc@@gmail.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.6 2006/03/18 05:00:19 brad Exp $	*/
d274 1
a274 1
	sensor->value *= sensor->rfact;
d286 1
a286 1
	sensor->value *= sensor->rfact;
@


1.6
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.5 2006/03/12 12:09:16 kettenis Exp $	*/
d42 3
a44 3
#define W83L785R_1_5V		0x21
#define W83L785R_2_5V		0x22
#define W83L785R_3_3V		0x23
d55 9
d69 1
a69 1
	int reg;
d71 1
d92 2
a93 1
void	wbenv_refresh_volts(struct wbenv_softc *, int);
d112 4
a115 4
	{ "VCore", SENSOR_VOLTS_DC, W83L784R_VCORE, wbenv_refresh_volts },
	{ "VBAT", SENSOR_VOLTS_DC, W83L784R_VBAT, wbenv_refresh_volts },
	{ "+3.3V", SENSOR_VOLTS_DC, W83L784R_3_3V, wbenv_refresh_volts },
	{ "+5V", SENSOR_VOLTS_DC, W83L784R_VCC, wbenv_refresh_volts },
d127 4
a130 4
	{ "VCore", SENSOR_VOLTS_DC, W83L784R_VCORE, wbenv_refresh_volts },
	{ "+1.5V", SENSOR_VOLTS_DC, W83L785R_1_5V, wbenv_refresh_volts },
	{ "+2.5V", SENSOR_VOLTS_DC, W83L785R_2_5V, wbenv_refresh_volts },
	{ "+3.3V", SENSOR_VOLTS_DC, W83L785R_3_3V, wbenv_refresh_volts },
d267 13
a279 1
wbenv_refresh_volts(struct wbenv_softc *sc, int n)
d285 3
a287 5
	sensor->value = (data << 4);
	if (reg == W83L784R_VCC && sc->sc_chip_id == WBENV_CHIPID_W83L784R)
		sensor->value *= 1000 * (50 + 34) / 50;
	else
		sensor->value *= 1000;
@


1.5
log
@Properly scale voltage on w83l784r.
Origional patch from Constantine A. Murenin.
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.4 2006/02/17 13:11:54 kettenis Exp $	*/
d186 1
a186 1
		printf(": unknownd Winbond chip (ID 0x%x)\n", sc->sc_chip_id);
@


1.4
log
@Fix another typo.  From Constantine A. Murenin.
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.3 2006/02/16 20:26:35 kettenis Exp $	*/
d69 1
d170 3
a172 1
	switch (data) {
d186 1
a186 1
		printf(": unknownd Winbond chip (ID 0x%x)\n", data);
d235 1
a235 1
		     sizeof(sc->sc_sensors[i].desc));
d259 1
a259 1
	int data;
d261 1
a261 1
	data = wbenv_readreg(sc, sc->sc_wbenv_sensors[n].reg);
d263 4
a266 1
	sensor->value *= 1000;
@


1.3
log
@Fix typo's.  From Constantine A. Murenin.
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.2 2006/01/19 17:08:39 grange Exp $	*/
d122 1
a122 1
	{ "Fan2", SENSOR_FANRPM, W83L784R_FAN1, w83l785r_refresh_fanrpm },
@


1.2
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: w83l784r.c,v 1.1 2006/01/15 12:20:14 kettenis Exp $	*/
d108 1
a108 1
	{ "Fam2", SENSOR_FANRPM, W83L784R_FAN2, w83l784r_refresh_fanrpm },
d122 1
a122 1
	{ "Fam2", SENSOR_FANRPM, W83L784R_FAN1, w83l785r_refresh_fanrpm },
@


1.1
log
@wbenv(4), a driver for the Winbond W83L784R/5R/5TS-L hardware monitor.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d219 1
a219 1
		SENSOR_ADD(&sc->sc_sensors[i]);
@

