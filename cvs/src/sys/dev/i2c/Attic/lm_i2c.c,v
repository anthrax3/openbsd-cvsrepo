head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2006.01.28.11.18.41;	author kettenis;	state dead;
branches;
next	1.10;

1.10
date	2006.01.26.22.07.14;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.17.22.02.51;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.15.22.03.17;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.14.15.14.33;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.09.22.41.39;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.30.09.45.20;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.29.16.08.03;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.29.14.51.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.28.01.02.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.27.20.47.00;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Rename lm_i2c.c to lm78_i2c.c.
requested by deraadt@@
@
text
@/*	$OpenBSD: lm_i2c.c,v 1.10 2006/01/26 22:07:14 kettenis Exp $	*/

/*
 * Copyright (c) 2005 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/sensors.h>

#include <machine/bus.h>

#include <dev/i2c/i2cvar.h>
#include <dev/ic/lm78var.h>

struct lm_i2c_softc {
	struct lm_softc sc_lmsc;
	i2c_tag_t	sc_tag;
	i2c_addr_t	sc_addr;
};

int lm_i2c_match(struct device *, void *, void *);
void lm_i2c_attach(struct device *, struct device *, void *);
int lm_i2c_detach(struct device *, int);
u_int8_t lm_i2c_readreg(struct lm_softc *, int);
void lm_i2c_writereg(struct lm_softc *, int, int);

struct cfattach lm_i2c_ca = {
	sizeof(struct lm_i2c_softc), lm_i2c_match,
	lm_i2c_attach, lm_i2c_detach
};

int
lm_i2c_match(struct device *parent, void *match, void *aux)
{
	struct i2c_attach_args *ia = aux;

	if (strcmp(ia->ia_name, "as99127f") == 0 ||
	    strcmp(ia->ia_name, "w83627hf") == 0 ||
	    strcmp(ia->ia_name, "w83781d") == 0 ||
	    strcmp(ia->ia_name, "w83782d") == 0 ||
	    strcmp(ia->ia_name, "w83783s") == 0 ||
	    strcmp(ia->ia_name, "w83791d") == 0 ||
	    strcmp(ia->ia_name, "w83792d") == 0) {
		return (1);
	}
	/*
	 * XXX This chip doesn't have any real sensors, but we match
	 * it for now, just to knock out its satellites.
	 */
	if (strcmp(ia->ia_name, "w83791sd") == 0) {
		return (1);
	}
	return (0);
}

void
lm_i2c_attach(struct device *parent, struct device *self, void *aux)
{
	struct lm_i2c_softc *sc = (struct lm_i2c_softc *)self;
	struct i2c_attach_args *ia = aux;
	u_int8_t cmd, data;

	sc->sc_tag = ia->ia_tag;
	sc->sc_addr = ia->ia_addr;

	/* Bus-independent attachment. */
	sc->sc_lmsc.lm_writereg = lm_i2c_writereg;
	sc->sc_lmsc.lm_readreg = lm_i2c_readreg;
	lm_attach(&sc->sc_lmsc);

	/* Remember we attached to iic(4). */
	sc->sc_lmsc.sbusaddr = ia->ia_addr;

	iic_acquire_bus(sc->sc_tag, 0);

	cmd = 0x4a;
	iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0);

	iic_release_bus(sc->sc_tag, 0);

	/* Make the bus scan ignore the satellites. */
	iic_ignore_addr(0x48 + (data & 0x7));
	iic_ignore_addr(0x48 + ((data >> 4) & 0x7));
}

int
lm_i2c_detach(struct device *self, int flags)
{
	struct lm_i2c_softc *sc = (struct lm_i2c_softc *)self;

	return lm_detach(&sc->sc_lmsc);
}

u_int8_t
lm_i2c_readreg(struct lm_softc *lmsc, int reg)
{
	struct lm_i2c_softc *sc = (struct lm_i2c_softc *)lmsc;
	u_int8_t cmd, data;

	iic_acquire_bus(sc->sc_tag, 0);

	cmd = reg;
	iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	     sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0);

	iic_release_bus(sc->sc_tag, 0);

	return data;
}

void
lm_i2c_writereg(struct lm_softc *lmsc, int reg, int val)
{
	struct lm_i2c_softc *sc = (struct lm_i2c_softc *)lmsc;
	u_int8_t cmd, data;

	iic_acquire_bus(sc->sc_tag, 0);

	cmd = reg;
	data = val;
	iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0);

	iic_release_bus(sc->sc_tag, 0);
}
@


1.10
log
@Make lm at iic detach properly, and use config_detach(9) to fully detach
lm at iic if we attach lm at isa for the same chip.
tested by robert@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm_i2c.c,v 1.9 2006/01/17 22:02:51 kettenis Exp $	*/
@


1.9
log
@Match "w83791sd".
@
text
@d1 1
a1 1
/*	$OpenBSD: lm_i2c.c,v 1.8 2006/01/15 22:03:17 kettenis Exp $	*/
d37 1
d42 2
a43 1
	sizeof(struct lm_i2c_softc), lm_i2c_match, lm_i2c_attach
d99 8
@


1.8
log
@Commit missing bits too:

If we attach an lm(4) to isa(4) that is already attached to iic(4), disable
the one attached to iic(4).
idea from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm_i2c.c,v 1.7 2006/01/14 15:14:33 kettenis Exp $	*/
d50 3
d59 2
a60 3
	 * XXX These chips also have an ISA bus interface and are
	 * likely to attach twice. That's ok for now, but we should
	 * probably disable these.
d62 1
a62 3
	if (strcmp(ia->ia_name, "w83781d") == 0 ||
	    strcmp(ia->ia_name, "w83782d") == 0 ||
	    strcmp(ia->ia_name, "w83627hf") == 0) {
@


1.7
log
@Rename nslm7x.c into lm78.c and nslm7xvar.h into lm78var.h, and clean up
lm78var.h.
Now that I've completely rewritten the driver, replace copyright with my own.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm_i2c.c,v 1.6 2006/01/09 22:41:39 kettenis Exp $	*/
d82 3
@


1.6
log
@Remove debug message.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm_i2c.c,v 1.5 2005/12/30 09:45:20 kettenis Exp $	*/
d27 1
a27 1
#include <dev/ic/nslm7xvar.h>
@


1.5
log
@Initial W83791D support for lm(4).
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm_i2c.c,v 1.4 2005/12/29 16:08:03 kettenis Exp $	*/
a80 1

d91 1
a91 3
	printf("%s: satellites at addr 0x%x and addr 0x%x\n",
	    sc->sc_lmsc.sc_dev.dv_xname,
	    0x48 + (data & 0x7), 0x48 + ((data >> 4) & 0x7));
@


1.4
log
@Match a few more lm(4) Winbond and ASUS chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: lm_i2c.c,v 1.3 2005/12/29 14:51:08 deraadt Exp $	*/
d52 1
a52 2
	    strcmp(ia->ia_name, "w83792d") == 0 ||
	    strcmp(ia->ia_name, "w12345x") == 0) {
@


1.3
log
@stop using I2C_F_POLL; it is a bus driver responsibility now
@
text
@d1 1
a1 1
/*	$OpenBSD: lm_i2c.c,v 1.2 2005/12/28 01:02:58 deraadt Exp $	*/
d49 15
a63 1
	if (strcmp(ia->ia_name, "as99127f") == 0) {
@


1.2
log
@some chips (especially those crazy i2c/lpc/isa gross things) expose their
banks at other addresses, but there are issues with accessing these other
devices.  so allow a driver to "knock" these out from future probing.
tested by kettenis -- unfortunate enough to have one of these winbond pieces
of poo
@
text
@d1 1
a1 1
/*	$OpenBSD: lm_i2c.c,v 1.1 2005/12/27 20:47:00 kettenis Exp $	*/
d71 1
a71 1
	iic_acquire_bus(sc->sc_tag, I2C_F_POLL);
d75 1
a75 1
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, I2C_F_POLL);
d77 1
a77 1
	iic_release_bus(sc->sc_tag, I2C_F_POLL);
@


1.1
log
@lm(4) at iic(4)
ok grange@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 2
@

