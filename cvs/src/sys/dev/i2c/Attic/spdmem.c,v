head	1.34;
access;
symbols
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23;
locks; strict;
comment	@ * @;


1.34
date	2010.03.22.21.20.58;	author miod;	state dead;
branches;
next	1.33;

1.33
date	2009.09.13.23.36.10;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2009.05.23.09.14.39;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2009.02.22.13.45.11;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.19.23.21.09;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.19.23.09.17;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2008.11.24.05.28.57;	author cnst;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.10.07.22.47;	author cnst;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.21.12.51.45;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2008.04.21.05.38.30;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.17.19.01.48;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.26.17.40.56;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.26.15.30.53;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.25.20.19.02;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.20.08.33.37;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.20.02.39.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.20.01.22.20;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.20.00.42.09;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.18.23.05.20;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.17.02.35.25;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.17.02.09.18;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.16.19.17.21;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.15.18.47.24;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.14.22.31.33;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.13.19.07.05;	author cnst;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.11.06.04.57;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.10.16.04.17;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.08.06.20.21;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.08.05.39.19;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.08.05.11.14;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.08.03.10.58;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.08.01.40.09;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.07.16.40.52;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.07.14.57.16;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Split existing spdmem@@i2c code into bus-agnostic spd record decoding code,
and an i2c attachment.
No functional change; ok jsg@@ deraadt@@
@
text
@/*	$OpenBSD: spdmem.c,v 1.33 2009/09/13 23:36:10 jsg Exp $	*/
/* $NetBSD: spdmem.c,v 1.3 2007/09/20 23:09:59 xtraeme Exp $ */

/*
 * Copyright (c) 2007 Jonathan Gray <jsg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 2007 Nicolas Joly
 * Copyright (c) 2007 Paul Goyette
 * Copyright (c) 2007 Tobias Nygren
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Serial Presence Detect (SPD) memory identification
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <dev/i2c/i2cvar.h>

/* Encodings of the size used/total byte for certain memory types    */
#define	SPDMEM_SPDSIZE_MASK		0x0F	/* SPD EEPROM Size   */

#define	SPDMEM_SPDLEN_128		0x00	/* SPD EEPROM Sizes  */
#define	SPDMEM_SPDLEN_176		0x10
#define	SPDMEM_SPDLEN_256		0x20
#define	SPDMEM_SPDLEN_MASK		0x70	/* Bits 4 - 6        */

#define	SPDMEM_SPDCRC_116		0x80	/* CRC Bytes covered */
#define	SPDMEM_SPDCRC_125		0x00
#define	SPDMEM_SPDCRC_MASK		0x80	/* Bit 7             */


/* possible values for the memory type */
#define	SPDMEM_MEMTYPE_FPM		0x01
#define	SPDMEM_MEMTYPE_EDO		0x02
#define	SPDMEM_MEMTYPE_PIPE_NIBBLE	0x03
#define	SPDMEM_MEMTYPE_SDRAM		0x04
#define	SPDMEM_MEMTYPE_ROM		0x05
#define	SPDMEM_MEMTYPE_DDRSGRAM		0x06
#define	SPDMEM_MEMTYPE_DDRSDRAM		0x07
#define	SPDMEM_MEMTYPE_DDR2SDRAM	0x08
#define	SPDMEM_MEMTYPE_FBDIMM		0x09
#define	SPDMEM_MEMTYPE_FBDIMM_PROBE	0x0a
#define	SPDMEM_MEMTYPE_DDR3SDRAM	0x0b
#define	SPDMEM_MEMTYPE_NONE		0xff

#define SPDMEM_MEMTYPE_DIRECT_RAMBUS	0x01
#define SPDMEM_MEMTYPE_RAMBUS		0x11

/* possible values for the supply voltage */
#define	SPDMEM_VOLTAGE_TTL_5V		0x00
#define	SPDMEM_VOLTAGE_TTL_LV		0x01
#define	SPDMEM_VOLTAGE_HSTTL_1_5V	0x02
#define	SPDMEM_VOLTAGE_SSTL_3_3V	0x03
#define	SPDMEM_VOLTAGE_SSTL_2_5V	0x04
#define	SPDMEM_VOLTAGE_SSTL_1_8V	0x05

/* possible values for module configuration */
#define	SPDMEM_MODCONFIG_PARITY		0x01
#define	SPDMEM_MODCONFIG_ECC		0x02

/* for DDR2, module configuration is a bit-mask field */
#define	SPDMEM_MODCONFIG_HAS_DATA_PARITY	0x01
#define	SPDMEM_MODCONFIG_HAS_DATA_ECC		0x02
#define	SPDMEM_MODCONFIG_HAS_ADDR_CMD_PARITY	0x04

/* possible values for the refresh field */
#define	SPDMEM_REFRESH_STD		0x00
#define	SPDMEM_REFRESH_QUARTER		0x01
#define	SPDMEM_REFRESH_HALF		0x02
#define	SPDMEM_REFRESH_TWOX		0x03
#define	SPDMEM_REFRESH_FOURX		0x04
#define	SPDMEM_REFRESH_EIGHTX		0x05
#define	SPDMEM_REFRESH_SELFREFRESH	0x80

/* superset types */
#define	SPDMEM_SUPERSET_ESDRAM		0x01
#define	SPDMEM_SUPERSET_DDR_ESDRAM	0x02
#define	SPDMEM_SUPERSET_EDO_PEM		0x03
#define	SPDMEM_SUPERSET_SDR_PEM		0x04

/* FPM and EDO DIMMS */
#define SPDMEM_FPM_ROWS			0x00
#define SPDMEM_FPM_COLS			0x01
#define SPDMEM_FPM_BANKS		0x02
#define SPDMEM_FPM_CONFIG		0x08
#define SPDMEM_FPM_REFRESH		0x09
#define SPDMEM_FPM_SUPERSET		0x0c

/* PC66/PC100/PC133 SDRAM */
#define SPDMEM_SDR_ROWS			0x00
#define SPDMEM_SDR_COLS			0x01
#define SPDMEM_SDR_BANKS		0x02
#define SPDMEM_SDR_CYCLE		0x06
#define SPDMEM_SDR_BANKS_PER_CHIP	0x0e
#define SPDMEM_SDR_MOD_ATTRIB		0x12
#define SPDMEM_SDR_SUPERSET		0x1d

#define SPDMEM_SDR_FREQUENCY		126
#define SPDMEM_SDR_CAS			127
#define SPDMEM_SDR_FREQ_66		0x66
#define SPDMEM_SDR_FREQ_100		0x64
#define SPDMEM_SDR_FREQ_133		0x85
#define SPDMEM_SDR_CAS2			(1 << 1)
#define SPDMEM_SDR_CAS3			(1 << 2)

/* Rambus Direct DRAM */
#define SPDMEM_RDR_MODULE_TYPE		0x00
#define SPDMEM_RDR_ROWS_COLS		0x01
#define SPDMEM_RDR_BANK			0x02

#define SPDMEM_RDR_TYPE_RIMM		1
#define SPDMEM_RDR_TYPE_SORIMM		2
#define SPDMEM_RDR_TYPE_EMBED		3
#define SPDMEM_RDR_TYPE_RIMM32		4

/* Dual Data Rate SDRAM */
#define SPDMEM_DDR_ROWS			0x00
#define SPDMEM_DDR_COLS			0x01
#define SPDMEM_DDR_RANKS		0x02
#define SPDMEM_DDR_DATAWIDTH		0x03
#define SPDMEM_DDR_VOLTAGE		0x05
#define SPDMEM_DDR_CYCLE		0x06
#define SPDMEM_DDR_REFRESH		0x09
#define SPDMEM_DDR_BANKS_PER_CHIP	0x0e
#define SPDMEM_DDR_CAS			0x0f
#define SPDMEM_DDR_MOD_ATTRIB		0x12
#define SPDMEM_DDR_SUPERSET		0x1d

#define SPDMEM_DDR_ATTRIB_REG		(1 << 1)

/* Dual Data Rate 2 SDRAM */
#define SPDMEM_DDR2_ROWS		0x00
#define SPDMEM_DDR2_COLS		0x01
#define SPDMEM_DDR2_RANKS		0x02
#define SPDMEM_DDR2_DATAWIDTH		0x03
#define SPDMEM_DDR2_VOLTAGE		0x05
#define SPDMEM_DDR2_CYCLE		0x06
#define SPDMEM_DDR2_DIMMTYPE		0x11
#define SPDMEM_DDR2_RANK_DENSITY	0x1c

#define SPDMEM_DDR2_TYPE_REGMASK	((1 << 4) | (1 << 0))
#define SPDMEM_DDR2_SODIMM		(1 << 2)
#define SPDMEM_DDR2_MICRO_DIMM		(1 << 3)
#define SPDMEM_DDR2_MINI_RDIMM		(1 << 4)
#define SPDMEM_DDR2_MINI_UDIMM		(1 << 5)

/* DDR2 FB-DIMM SDRAM */
#define SPDMEM_FBDIMM_ADDR		0x01
#define SPDMEM_FBDIMM_RANKS		0x04
#define SPDMEM_FBDIMM_MTB_DIVIDEND	0x06
#define SPDMEM_FBDIMM_MTB_DIVISOR	0x07
#define SPDMEM_FBDIMM_PROTO		0x4e

#define SPDMEM_FBDIMM_RANKS_WIDTH		0x07
#define SPDMEM_FBDIMM_ADDR_BANKS		0x02
#define SPDMEM_FBDIMM_ADDR_COL			0x0c
#define SPDMEM_FBDIMM_ADDR_COL_SHIFT		2
#define SPDMEM_FBDIMM_ADDR_ROW			0xe0
#define SPDMEM_FBDIMM_ADDR_ROW_SHIFT		5
#define SPDMEM_FBDIMM_PROTO_ECC			(1 << 1)


/* Dual Data Rate 3 SDRAM */
#define SPDMEM_DDR3_MODTYPE		0x00
#define SPDMEM_DDR3_DENSITY		0x01
#define SPDMEM_DDR3_MOD_ORG		0x04
#define SPDMEM_DDR3_DATAWIDTH		0x05
#define SPDMEM_DDR3_MTB_DIVIDEND	0x07
#define SPDMEM_DDR3_MTB_DIVISOR		0x08
#define SPDMEM_DDR3_TCKMIN		0x09
#define SPDMEM_DDR3_THERMAL		0x1d

#define SPDMEM_DDR3_DENSITY_CAPMASK		0x0f
#define SPDMEM_DDR3_MOD_ORG_CHIPWIDTH_MASK	0x07
#define SPDMEM_DDR3_MOD_ORG_BANKS_SHIFT		3
#define SPDMEM_DDR3_MOD_ORG_BANKS_MASK		0x07
#define SPDMEM_DDR3_DATAWIDTH_ECCMASK		(1 << 3)
#define SPDMEM_DDR3_DATAWIDTH_PRIMASK		0x07
#define SPDMEM_DDR3_THERMAL_PRESENT		(1 << 7)

#define SPDMEM_DDR3_RDIMM		0x01
#define SPDMEM_DDR3_UDIMM		0x02
#define SPDMEM_DDR3_SODIMM		0x03
#define SPDMEM_DDR3_MICRO_DIMM		0x04
#define SPDMEM_DDR3_MINI_RDIMM		0x05
#define SPDMEM_DDR3_MINI_UDIMM		0x06

static const uint8_t ddr2_cycle_tenths[] = {
	0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 25, 33, 66, 75, 0, 0
};

struct spdmem {
	uint8_t sm_len;
	uint8_t sm_size;
	uint8_t sm_type;
	uint8_t sm_data[60];
	uint8_t	sm_cksum;
} __packed;

#define SPDMEM_TYPE_MAXLEN 16
struct spdmem_softc {
	struct device	sc_dev;
	i2c_tag_t	sc_tag;
	i2c_addr_t	sc_addr;
	struct spdmem	sc_spd_data;
};

uint16_t	 spdmem_crc16(struct spdmem_softc *, int);
int		 spdmem_match(struct device *, void *, void *);
void		 spdmem_attach(struct device *, struct device *, void *);
uint8_t		 spdmem_read(struct spdmem_softc *, uint8_t);
void		 spdmem_sdram_decode(struct spdmem_softc *, struct spdmem *);
void		 spdmem_rdr_decode(struct spdmem_softc *, struct spdmem *);
void		 spdmem_ddr_decode(struct spdmem_softc *, struct spdmem *);
void		 spdmem_ddr2_decode(struct spdmem_softc *, struct spdmem *);
void		 spdmem_fbdimm_decode(struct spdmem_softc *, struct spdmem *);
void		 spdmem_ddr3_decode(struct spdmem_softc *, struct spdmem *);

struct cfattach spdmem_ca = {
	sizeof(struct spdmem_softc), spdmem_match, spdmem_attach
};

struct cfdriver spdmem_cd = {
	NULL, "spdmem", DV_DULL
};

#define IS_RAMBUS_TYPE (s->sm_len < 4)

static const char *spdmem_basic_types[] = {
	"unknown",
	"FPM",
	"EDO",
	"Pipelined Nibble",
	"SDRAM",
	"ROM",
	"DDR SGRAM",
	"DDR SDRAM",
	"DDR2 SDRAM",
	"DDR2 SDRAM FB-DIMM",
	"DDR2 SDRAM FB-DIMM Probe",
	"DDR3 SDRAM"
};

static const char *spdmem_superset_types[] = {
	"unknown",
	"ESDRAM",
	"DDR ESDRAM",
	"PEM EDO",
	"PEM SDRAM"
};

static const char *spdmem_parity_types[] = {
	"non-parity",
	"data parity",
	"ECC",
	"data parity and ECC",
	"cmd/addr parity",
	"cmd/addr/data parity",
	"cmd/addr parity, data ECC",
	"cmd/addr/data parity, data ECC"
};

/* CRC functions used for certain memory types */
uint16_t
spdmem_crc16(struct spdmem_softc *sc, int count)
{
	uint16_t crc;
	int i, j;
	uint8_t val;
	crc = 0;
	for (j = 0; j <= count; j++) {
		val = spdmem_read(sc, j);
		crc = crc ^ val << 8;
		for (i = 0; i < 8; ++i)
			if (crc & 0x8000)
				crc = crc << 1 ^ 0x1021;
			else
				crc = crc << 1;
	}
	return (crc & 0xFFFF);
}

int
spdmem_match(struct device *parent, void *match, void *aux)
{
	struct i2c_attach_args *ia = aux;
	struct spdmem_softc sc;
	uint8_t i, val, type;
	int cksum = 0;
	int spd_len, spd_crc_cover;
	uint16_t crc_calc, crc_spd;

	/* clever attachments like openfirmware informed macppc */	
	if (strcmp(ia->ia_name, "spd") == 0)
		return (1);

	/* dumb, need sanity checks */
	if (strcmp(ia->ia_name, "eeprom") != 0)
		return (0);

	sc.sc_tag = ia->ia_tag;
	sc.sc_addr = ia->ia_addr;

	type = spdmem_read(&sc, 2);
	/* For older memory types, validate the checksum over 1st 63 bytes */
	if (type <= SPDMEM_MEMTYPE_DDR2SDRAM) {
		for (i = 0; i < 63; i++)
			cksum += spdmem_read(&sc, i);

		val = spdmem_read(&sc, 63);

		if (cksum == 0 || (cksum & 0xff) != val) {
			return 0;
		} else
			return 1;
	}

	/* For DDR3 and FBDIMM, verify the CRC */
	else if (type <= SPDMEM_MEMTYPE_DDR3SDRAM) {
		spd_len = spdmem_read(&sc, 0);
		if (spd_len && SPDMEM_SPDCRC_116)
			spd_crc_cover = 116;
		else
			spd_crc_cover = 125;
		switch (spd_len & SPDMEM_SPDLEN_MASK) {
		case SPDMEM_SPDLEN_128:
			spd_len = 128;
			break;
		case SPDMEM_SPDLEN_176:
			spd_len = 176;
			break;
		case SPDMEM_SPDLEN_256:
			spd_len = 256;
			break;
		default:
			return 0;
		}
		if (spd_crc_cover > spd_len)
			return 0;
		crc_calc = spdmem_crc16(&sc, spd_crc_cover);
		crc_spd = spdmem_read(&sc, 127) << 8;
		crc_spd |= spdmem_read(&sc, 126);
		if (crc_calc != crc_spd) {
			return 0;
		}
		return 1;
	}

	return (0);
}

void
spdmem_sdram_decode(struct spdmem_softc *sc, struct spdmem *s)
{
	const char *type;
	int dimm_size, p_clk;
	int num_banks, per_chip;
	uint8_t rows, cols;

	type = spdmem_basic_types[s->sm_type];

	if (s->sm_data[SPDMEM_SDR_SUPERSET] == SPDMEM_SUPERSET_SDR_PEM)
		type = spdmem_superset_types[SPDMEM_SUPERSET_SDR_PEM];
	if (s->sm_data[SPDMEM_SDR_SUPERSET] == SPDMEM_SUPERSET_ESDRAM)
		type = spdmem_superset_types[SPDMEM_SUPERSET_ESDRAM];

	num_banks = s->sm_data[SPDMEM_SDR_BANKS];
	per_chip = s->sm_data[SPDMEM_SDR_BANKS_PER_CHIP];
	rows = s->sm_data[SPDMEM_SDR_ROWS] & 0x0f;
	cols = s->sm_data[SPDMEM_SDR_COLS] & 0x0f;
	dimm_size = (1 << (rows + cols - 17)) * num_banks * per_chip;

	if (dimm_size > 0) {
		if (dimm_size < 1024)
			printf(" %dMB", dimm_size);
		else
			printf(" %dGB", dimm_size / 1024);
	}

	printf(" %s", type);

	if (s->sm_data[SPDMEM_DDR_MOD_ATTRIB] & SPDMEM_DDR_ATTRIB_REG)
		printf(" registered");

	if (s->sm_data[SPDMEM_FPM_CONFIG] < 8)
		printf(" %s",
		    spdmem_parity_types[s->sm_data[SPDMEM_FPM_CONFIG]]);

	p_clk = 66;
	if (s->sm_len >= 128) {
		switch (spdmem_read(sc, SPDMEM_SDR_FREQUENCY)) {
		case SPDMEM_SDR_FREQ_100:
		case SPDMEM_SDR_FREQ_133:
			/* We need to check ns to decide here */
			if (s->sm_data[SPDMEM_SDR_CYCLE] < 0x80)
				p_clk = 133;
			else
				p_clk = 100;
			break;
		case SPDMEM_SDR_FREQ_66:
		default:
			p_clk = 66;
			break;
		}
	}
	printf(" PC%d", p_clk);

	/* Print CAS latency */
	if (s->sm_len < 128)
		return;
	if (spdmem_read(sc, SPDMEM_SDR_CAS) & SPDMEM_SDR_CAS2)
		printf("CL2");
	else if (spdmem_read(sc, SPDMEM_SDR_CAS) & SPDMEM_SDR_CAS3)
		printf("CL3");
}

void
spdmem_rdr_decode(struct spdmem_softc *sc, struct spdmem *s)
{
	int rimm_size;
	uint8_t row_bits, col_bits, bank_bits;

	row_bits = s->sm_data[SPDMEM_RDR_ROWS_COLS] >> 4;
	col_bits = s->sm_data[SPDMEM_RDR_ROWS_COLS] & 0x0f;
	bank_bits = s->sm_data[SPDMEM_RDR_BANK] & 0x07;

	/* subtracting 13 here is a cheaper way of dividing by 8k later */
	rimm_size = 1 << (row_bits + col_bits + bank_bits - 13);

	if (rimm_size < 1024)
		printf(" %dMB ", rimm_size);
	else
		printf(" %dGB ", rimm_size / 1024);

	switch(s->sm_data[SPDMEM_RDR_MODULE_TYPE]) {
	case SPDMEM_RDR_TYPE_RIMM:
		printf("RIMM");
		break;
	case SPDMEM_RDR_TYPE_SORIMM:
		printf("SO-RIMM");
		break;
	case SPDMEM_RDR_TYPE_EMBED:
		printf("Embedded Rambus");
		break;
	case SPDMEM_RDR_TYPE_RIMM32:
		printf("RIMM32");
		break;
	}
}

void
spdmem_ddr_decode(struct spdmem_softc *sc, struct spdmem *s)
{
	const char *type;
	int dimm_size, cycle_time, d_clk, p_clk, bits;
	int i, num_banks, per_chip;
	uint8_t config, rows, cols, cl;

	type = spdmem_basic_types[s->sm_type];

	if (s->sm_data[SPDMEM_DDR_SUPERSET] == SPDMEM_SUPERSET_DDR_ESDRAM)
		type = spdmem_superset_types[SPDMEM_SUPERSET_DDR_ESDRAM];

	num_banks = s->sm_data[SPDMEM_SDR_BANKS];
	per_chip = s->sm_data[SPDMEM_SDR_BANKS_PER_CHIP];
	rows = s->sm_data[SPDMEM_SDR_ROWS] & 0x0f;
	cols = s->sm_data[SPDMEM_SDR_COLS] & 0x0f;
	dimm_size = (1 << (rows + cols - 17)) * num_banks * per_chip;

	if (dimm_size > 0) {
		if (dimm_size < 1024)
			printf(" %dMB", dimm_size);
		else
			printf(" %dGB", dimm_size / 1024);
	}

	printf(" %s", type);

	if (s->sm_data[SPDMEM_DDR_MOD_ATTRIB] & SPDMEM_DDR_ATTRIB_REG)
		printf(" registered");

	if (s->sm_data[SPDMEM_FPM_CONFIG] < 8)
		printf(" %s",
		    spdmem_parity_types[s->sm_data[SPDMEM_FPM_CONFIG]]);

	/* cycle_time is expressed in units of 0.01 ns */
	cycle_time = (s->sm_data[SPDMEM_DDR_CYCLE] >> 4) * 100 +
	    (s->sm_data[SPDMEM_DDR_CYCLE] & 0x0f) * 10;

	if (cycle_time != 0) {
		/*
		 * cycle time is scaled by a factor of 100 to avoid using
		 * floating point.  Calculate memory speed as the number
		 * of cycles per microsecond.
		 * DDR uses dual-pumped clock
		 */
		d_clk = 100 * 1000 * 2;
		config = s->sm_data[SPDMEM_FPM_CONFIG];
		bits = s->sm_data[SPDMEM_DDR_DATAWIDTH] |
		    (s->sm_data[SPDMEM_DDR_DATAWIDTH + 1] << 8);
		if (config == 1 || config == 2)
			bits -= 8;

		d_clk /= cycle_time;
		p_clk = d_clk * bits / 8;
		if ((p_clk % 100) >= 50)
			p_clk += 50;
		p_clk -= p_clk % 100;
		printf(" PC%d", p_clk);
	}

	/* Print CAS latency */
	for (i = 6; i >= 0; i--) {
		if (s->sm_data[SPDMEM_DDR_CAS] & (1 << i)) {
			cl = ((i * 10) / 2) + 10;
			printf("CL%d.%d", cl / 10, cl % 10);
			break;
		}
	}
}

void
spdmem_ddr2_decode(struct spdmem_softc *sc, struct spdmem *s)
{
	const char *type;
	int dimm_size, cycle_time, d_clk, p_clk, bits;
	int i, num_ranks, density;
	uint8_t config;

	type = spdmem_basic_types[s->sm_type];

	num_ranks = (s->sm_data[SPDMEM_DDR2_RANKS] & 0x7) + 1;
	density = (s->sm_data[SPDMEM_DDR2_RANK_DENSITY] & 0xf0) |
	    ((s->sm_data[SPDMEM_DDR2_RANK_DENSITY] & 0x0f) << 8);
	dimm_size = num_ranks * density * 4;

	if (dimm_size > 0) {
		if (dimm_size < 1024)
			printf(" %dMB", dimm_size);
		else
			printf(" %dGB", dimm_size / 1024);
	}

	printf(" %s", type);

	if (s->sm_data[SPDMEM_DDR2_DIMMTYPE] & SPDMEM_DDR2_TYPE_REGMASK)
		printf(" registered");

	if (s->sm_data[SPDMEM_FPM_CONFIG] < 8)
		printf(" %s",
		    spdmem_parity_types[s->sm_data[SPDMEM_FPM_CONFIG]]);

	/* cycle_time is expressed in units of 0.01 ns */
	cycle_time = (s->sm_data[SPDMEM_DDR2_CYCLE] >> 4) * 100 +
	    ddr2_cycle_tenths[(s->sm_data[SPDMEM_DDR2_CYCLE] & 0x0f)];

	if (cycle_time != 0) {
		/*
		 * cycle time is scaled by a factor of 100 to avoid using
		 * floating point.  Calculate memory speed as the number
		 * of cycles per microsecond.
		 * DDR2 uses quad-pumped clock
		 */
		d_clk = 100 * 1000 * 4;
		config = s->sm_data[SPDMEM_FPM_CONFIG];
		bits = s->sm_data[SPDMEM_DDR2_DATAWIDTH];
		if ((config & 0x03) != 0)
			bits -= 8;
		d_clk /= cycle_time;
		d_clk = (d_clk + 1) / 2;
		p_clk = d_clk * bits / 8;
		p_clk -= p_clk % 100;
		printf(" PC2-%d", p_clk);
	}

	/* Print CAS latency */
	for (i = 5; i >= 2; i--) {
		if (s->sm_data[SPDMEM_DDR_CAS] & (i << i)) {
			printf("CL%d", i);
			break;
		}
	}

	switch (s->sm_data[SPDMEM_DDR2_DIMMTYPE]) {
	case SPDMEM_DDR2_SODIMM:
		printf(" SO-DIMM");
		break;
	case SPDMEM_DDR2_MICRO_DIMM:
		printf(" Micro-DIMM");
		break;
	case SPDMEM_DDR2_MINI_RDIMM:
	case SPDMEM_DDR2_MINI_UDIMM:
		printf(" Mini-DIMM");
		break;
	}
}

void
spdmem_fbdimm_decode(struct spdmem_softc *sc, struct spdmem *s)
{
	int dimm_size, num_banks, cycle_time, d_clk, p_clk, bits;
	uint8_t rows, cols, banks, dividend, divisor;
	/*
	 * FB-DIMM is very much like DDR3
	 */

	banks = s->sm_data[SPDMEM_FBDIMM_ADDR] & SPDMEM_FBDIMM_ADDR_BANKS;
	cols = (s->sm_data[SPDMEM_FBDIMM_ADDR] & SPDMEM_FBDIMM_ADDR_COL) >>
	    SPDMEM_FBDIMM_ADDR_COL_SHIFT;
	rows = (s->sm_data[SPDMEM_FBDIMM_ADDR] & SPDMEM_FBDIMM_ADDR_ROW) >>
	    SPDMEM_FBDIMM_ADDR_ROW_SHIFT;
	dimm_size = rows + 12 + cols +  9 - 20 - 3;
	num_banks = 1 << (banks + 2);

	if (dimm_size < 1024)
		printf(" %dMB", dimm_size);
	else
		printf(" %dGB", dimm_size / 1024);

	dividend = s->sm_data[SPDMEM_FBDIMM_MTB_DIVIDEND];
	divisor = s->sm_data[SPDMEM_FBDIMM_MTB_DIVISOR];

	cycle_time = (1000 * dividend + (divisor / 2)) / divisor;

	if (cycle_time != 0) {
		/*
		 * cycle time is scaled by a factor of 1000 to avoid using
		 * floating point.  Calculate memory speed as the number
		 * of cycles per microsecond.
		 */
		d_clk = 1000 * 1000;

		/* DDR2 FB-DIMM uses a dual-pumped clock */
		d_clk *= 2;
		bits = 1 << ((s->sm_data[SPDMEM_FBDIMM_RANKS] &
		    SPDMEM_FBDIMM_RANKS_WIDTH) + 2);

		p_clk = (d_clk * bits) / 8 / cycle_time;
		d_clk = ((d_clk + cycle_time / 2) ) / cycle_time;
		p_clk -= p_clk % 100;
		printf(" PC2-%d", p_clk);
	}
}

void
spdmem_ddr3_decode(struct spdmem_softc *sc, struct spdmem *s)
{
	const char *type;
	int dimm_size, cycle_time, d_clk, p_clk, bits;
	uint8_t mtype, chipsize, dividend, divisor;
	uint8_t datawidth, chipwidth, physbanks;

	type = spdmem_basic_types[s->sm_type];

	chipsize = s->sm_data[SPDMEM_DDR3_DENSITY] &
	    SPDMEM_DDR3_DENSITY_CAPMASK;
	datawidth = s->sm_data[SPDMEM_DDR3_DATAWIDTH] &
	    SPDMEM_DDR3_DATAWIDTH_PRIMASK;
	chipwidth = s->sm_data[SPDMEM_DDR3_MOD_ORG] &
	    SPDMEM_DDR3_MOD_ORG_CHIPWIDTH_MASK;
	physbanks = (s->sm_data[SPDMEM_DDR3_MOD_ORG] >> 
	    SPDMEM_DDR3_MOD_ORG_BANKS_SHIFT) & SPDMEM_DDR3_MOD_ORG_BANKS_MASK;

	dimm_size = (chipsize + 28 - 20) - 3 + (datawidth + 3) -
	    (chipwidth + 2);
	dimm_size = (1 << dimm_size) * (physbanks + 1);

	if (dimm_size < 1024)
		printf(" %dMB", dimm_size);
	else
		printf(" %dGB", dimm_size / 1024);

	printf(" %s", type);

	mtype = s->sm_data[SPDMEM_DDR3_MODTYPE];
	if (mtype == SPDMEM_DDR3_RDIMM || mtype == SPDMEM_DDR3_MINI_RDIMM)
		printf(" registered");

	if (s->sm_data[SPDMEM_DDR3_DATAWIDTH] & SPDMEM_DDR3_DATAWIDTH_ECCMASK) 
		printf(" ECC");

	dividend = s->sm_data[SPDMEM_DDR3_MTB_DIVIDEND];
	divisor = s->sm_data[SPDMEM_DDR3_MTB_DIVISOR];
	cycle_time = (1000 * dividend +  (divisor / 2)) / divisor;
	cycle_time *= s->sm_data[SPDMEM_DDR3_TCKMIN];

	if (cycle_time != 0) {
		/*
		 * cycle time is scaled by a factor of 1000 to avoid using
		 * floating point.  Calculate memory speed as the number
		 * of cycles per microsecond.
		 * DDR3 uses a dual-pumped clock
		 */
		d_clk = 1000 * 1000;
		d_clk *= 2;
		bits = 1 << ((s->sm_data[SPDMEM_DDR3_DATAWIDTH] &
		    SPDMEM_DDR3_DATAWIDTH_PRIMASK) + 3);
		/*
		 * Calculate p_clk first, since for DDR3 we need maximum
		 * significance.  DDR3 rating is not rounded to a multiple
		 * of 100.  This results in cycle_time of 1.5ns displayed
		 * as p_clk PC3-10666 (d_clk DDR3-1333)
		 */
		p_clk = (d_clk * bits) / 8 / cycle_time;
		p_clk -= (p_clk % 100);
		d_clk = ((d_clk + cycle_time / 2) ) / cycle_time;
		printf(" PC3-%d", p_clk);
	}

	switch (s->sm_data[SPDMEM_DDR3_MODTYPE]) {
	case SPDMEM_DDR3_SODIMM:
		printf(" SO-DIMM");
		break;
	case SPDMEM_DDR3_MICRO_DIMM:
		printf(" Micro-DIMM");
		break;
	case SPDMEM_DDR3_MINI_RDIMM:
	case SPDMEM_DDR3_MINI_UDIMM:
		printf(" Mini-DIMM");
		break;
	}

	if (s->sm_data[SPDMEM_DDR3_THERMAL] & SPDMEM_DDR3_THERMAL_PRESENT)
		printf(" with thermal sensor");
}

void
spdmem_attach(struct device *parent, struct device *self, void *aux)
{
	struct spdmem_softc *sc = (struct spdmem_softc *)self;
	struct i2c_attach_args *ia = aux;
	struct spdmem *s = &(sc->sc_spd_data);
	int i;

	sc->sc_tag = ia->ia_tag;
	sc->sc_addr = ia->ia_addr;

	printf(":");

	/* All SPD have at least 64 bytes of data including checksum */
	for (i = 0; i < 64; i++) {
		((uint8_t *)s)[i] = spdmem_read(sc, i);
	}

	/*
	 * Decode and print SPD contents
	 */
	if (s->sm_len < 4) {
		if (s->sm_type == SPDMEM_MEMTYPE_DIRECT_RAMBUS)
			spdmem_rdr_decode(sc, s);
		else
			printf(" no decode method for Rambus memory");
	} else {
		switch(s->sm_type) {
		case SPDMEM_MEMTYPE_EDO:
		case SPDMEM_MEMTYPE_SDRAM:
			spdmem_sdram_decode(sc, s);
			break;
		case SPDMEM_MEMTYPE_DDRSDRAM:
			spdmem_ddr_decode(sc, s);
			break;
		case SPDMEM_MEMTYPE_DDR2SDRAM:
			spdmem_ddr2_decode(sc, s);
			break;
		case SPDMEM_MEMTYPE_FBDIMM:
		case SPDMEM_MEMTYPE_FBDIMM_PROBE:
			spdmem_fbdimm_decode(sc, s);
			break;
		case SPDMEM_MEMTYPE_DDR3SDRAM:
			spdmem_ddr3_decode(sc, s);
			break;
		case SPDMEM_MEMTYPE_NONE:
			printf(" no EEPROM found");
			break;
		default:
			if (s->sm_type <= 10)
				printf(" no decode method for %s memory",
				    spdmem_basic_types[s->sm_type]);
			else
				printf(" unknown memory type %d", s->sm_type);
			break;
		}
	}

	printf("\n");
}

uint8_t
spdmem_read(struct spdmem_softc *sc, uint8_t reg)
{
	uint8_t val = 0xff;

	iic_acquire_bus(sc->sc_tag,0);
	iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP, sc->sc_addr,
	    &reg, sizeof reg, &val, sizeof val, 0);
	iic_release_bus(sc->sc_tag, 0);

	return val;
}
@


1.33
log
@Don't try to check for ECC with fbdimm as the offset exceeds
the number of bytes currently read into the sm_data array.

Problem found by recent version of gcc.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.32 2009/05/23 09:14:39 jsg Exp $	*/
@


1.32
log
@Seems I confused Mb and MB and was in too much of a rush when I
added the DDR3 bits.  Take into account more of the spd
data and compute DDR3 module size in a way similiar to
NetBSD so it comes out correctly.

Tested by Olivier Cherrier and Christian Stuermer.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.31 2009/02/22 13:45:11 jsg Exp $	*/
a659 3

	if (s->sm_data[SPDMEM_FBDIMM_PROTO] & SPDMEM_FBDIMM_PROTO_ECC)
		printf(" ECC");
@


1.31
log
@Untested FB-DIMM decoding adapted from changes made to NetBSD
by Paul Goyette.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.30 2009/02/19 23:21:09 jsg Exp $	*/
d207 1
d215 3
d694 2
a695 1
	uint8_t mtype, capacity, dividend, divisor;
d699 1
a699 1
	capacity = s->sm_data[SPDMEM_DDR3_DENSITY] &
d701 10
a710 2
	/* capacity in MB is 2^(x+8) which we can get by shifting */
	dimm_size = 2 << (capacity + 7);
@


1.30
log
@Indicate if a thermal sensor is present on ddr3 modules.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.29 2009/02/19 23:09:17 jsg Exp $	*/
d188 16
d253 1
d636 50
d795 4
@


1.29
log
@Move most of spdmem match logic into the driver and add crc16/ddr3
support based on changes in NetBSD by Paul Goyette with goop
like bitfields/single decode function mess removed and things
like module type/simpler capacity calculations added.

Tested by a bunch of people in particular krw who tested a few revs
of the ddr3 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.28 2008/11/24 05:28:57 cnst Exp $	*/
d195 1
d200 1
d686 3
@


1.28
log
@remove more logically irrelevant DDR code from the SDR function;  ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.27 2008/11/10 07:22:47 cnst Exp $	*/
d60 13
d82 3
d188 19
a224 1
	char		sc_type[SPDMEM_TYPE_MAXLEN];
d227 1
d235 1
d257 3
a259 2
	"DDR2 SDRAM FB",
	"DDR2 SDRAM FB Probe"
d281 20
d305 7
a311 1
	
d314 53
a398 1
	strlcpy(sc->sc_type, type, SPDMEM_TYPE_MAXLEN);
a495 1
	strlcpy(sc->sc_type, type, SPDMEM_TYPE_MAXLEN);
a562 1
	strlcpy(sc->sc_type, type, SPDMEM_TYPE_MAXLEN);
d617 70
d723 3
@


1.27
log
@remove some dead code and fix a comment;  llvm/clang;  ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.26 2008/05/21 12:51:45 jsg Exp $	*/
d258 1
a258 1
	int dimm_size, cycle_time, p_clk;
d292 15
a306 27
	/* cycle_time is expressed in units of 0.01 ns */
	cycle_time = (s->sm_data[SPDMEM_DDR_CYCLE] >> 4) * 100 +
	    (s->sm_data[SPDMEM_DDR_CYCLE] & 0x0f) * 10;

	if (cycle_time != 0) {
		/*
		 * cycle time is scaled by a factor of 100 to avoid using
		 * floating point.  Calculate memory speed as the number
		 * of cycles per microsecond.
		 */

		p_clk = 66;
		if (s->sm_len >= 128) {
			switch (spdmem_read(sc, SPDMEM_SDR_FREQUENCY)) {
			case SPDMEM_SDR_FREQ_100:
			case SPDMEM_SDR_FREQ_133:
				/* We need to check ns to decide here */
				if (s->sm_data[SPDMEM_SDR_CYCLE] < 0x80)
					p_clk = 133;
				else
					p_clk = 100;
				break;
			case SPDMEM_SDR_FREQ_66:
			default:
				p_clk = 66;
				break;
			}
a307 1
		printf(" PC%d", p_clk);
d309 1
@


1.26
log
@Print a specific message for non i2c attachments like macppc
memc, in the situation where Apple cheaps out by having no SPD
on integrated RAM.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.25 2008/04/21 05:38:30 deraadt Exp $	*/
d258 1
a258 1
	int dimm_size, cycle_time, d_clk, p_clk, bits;
d260 1
a260 1
	uint8_t config, rows, cols;
a268 2
	dimm_size = 0;

a301 6
		d_clk = 100 * 1000;
		config = s->sm_data[SPDMEM_FPM_CONFIG];
		bits = s->sm_data[SPDMEM_DDR_DATAWIDTH] |
		    (s->sm_data[SPDMEM_DDR_DATAWIDTH + 1] << 8);
		if (config == 1 || config == 2)
			bits -= 8;
a378 2
	dimm_size = 0;

d411 1
a411 1
		 * DDR2 uses dual-pumped clock
a446 2

	dimm_size = 0;
@


1.25
log
@when iic_exec fails, return 0xff for the read value; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.24 2008/04/17 19:01:48 deraadt Exp $	*/
d69 1
d564 3
@


1.24
log
@make it more apparent that when we are dealing with 16 bit registers
(not a series of 8 bit registers), the bytes come off the wire in
big-endian order
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.23 2007/11/26 17:40:56 jsg Exp $	*/
d580 1
a580 1
	uint8_t val;
@


1.23
log
@Display module size for direct rambus rimms, not yet tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.22 2007/11/26 15:30:53 jsg Exp $	*/
d583 2
a584 2
	iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP, sc->sc_addr, &reg, 1,
		 &val, 1, 0);
@


1.22
log
@Add basic rambus decode method, showing the module type.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.21 2007/11/25 20:19:02 miod Exp $	*/
d70 3
a130 1
#define SPDMEM_RDR_ROWS_COLS		0x00
d132 2
d342 15
d547 6
a552 3
	if (s->sm_len < 4)
		spdmem_rdr_decode(sc, s);
	else {
@


1.21
log
@Kill spdmem_hexdump() before anyone starts using it.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.20 2007/10/20 08:33:37 jsg Exp $	*/
d127 9
a170 3
/* Direct Rambus DRAM */
#define SPDMEM_RDR_ROWS_COLS		0x00

d192 1
d336 19
d529 1
a529 1
		printf(" no decode method for Rambus memory");
@


1.20
log
@Create memory specific decode routines to make code cleaner,
suggested by deraadt.
This file has mostly been rewritten even before it was initially comitted
so add my copyright to it as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.19 2007/10/20 02:39:56 deraadt Exp $	*/
a184 1
void		 spdmem_hexdump(struct spdmem_softc *, int, int);
a539 20
}

void
spdmem_hexdump(struct spdmem_softc *sc, int start, int size)
{
	int i;
	
	uint8_t data[size];

	for (i = 0; i < size;  i++) {
		data[i] = spdmem_read(sc, i);
	}

	for (i = 0; i < size ; i += 16) {
		int j;
		printf("\n0x%02x:", start + i);
		for (j = 0; j < 16; j++)
			printf(" %02x", ((uint8_t *)data)[i + j]);
	}
	printf("\n");
@


1.19
log
@re-introduce the "p_clk rounding" for DDR -- they need it
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.18 2007/10/20 01:22:20 jsg Exp $	*/
d5 16
d186 3
d244 1
a244 1
spdmem_attach(struct device *parent, struct device *self, void *aux)
a245 3
	struct spdmem_softc *sc = (struct spdmem_softc *)self;
	struct i2c_attach_args *ia = aux;
	struct spdmem *s = &(sc->sc_spd_data);
a246 1
	const char *ddr_type_string = NULL;
d248 9
a256 2
	int i;
	uint8_t config, rows, cols, cl;
d258 1
a258 2
	sc->sc_tag = ia->ia_tag;
	sc->sc_addr = ia->ia_addr;
d260 5
a264 1
	printf(":");
d266 5
a270 3
	/* All SPD have at least 64 bytes of data including checksum */
	for (i = 0; i < 64; i++) {
		((uint8_t *)s)[i] = spdmem_read(sc, i);
d273 9
a281 9
#if 0
	for (i = 0; i < 64;  i += 16) {
		int j;
		printf("\n%s: 0x%02x:", self->dv_xname, i);
		for (j = 0; j < 16; j++)
			printf(" %02x", ((uint8_t *)s)[i + j]);
	}
	printf("\n%s", self->dv_xname);
#endif
d283 3
a285 10
	/*
	 * Decode and print SPD contents
	 */
	if (IS_RAMBUS_TYPE)
		type = "Rambus";
	else {
		if (s->sm_type <= 10)
			type = spdmem_basic_types[s->sm_type];
		else
			type = "unknown";
d287 29
a315 14
		if (s->sm_type == SPDMEM_MEMTYPE_EDO &&
		    s->sm_data[SPDMEM_FPM_SUPERSET] == SPDMEM_SUPERSET_EDO_PEM)
			type = spdmem_superset_types[SPDMEM_SUPERSET_EDO_PEM];
		if (s->sm_type == SPDMEM_MEMTYPE_SDRAM &&
		    s->sm_data[SPDMEM_SDR_SUPERSET] == SPDMEM_SUPERSET_SDR_PEM)
			type = spdmem_superset_types[SPDMEM_SUPERSET_SDR_PEM];
		if (s->sm_type == SPDMEM_MEMTYPE_DDRSDRAM &&
		    s->sm_data[SPDMEM_DDR_SUPERSET] ==
		    SPDMEM_SUPERSET_DDR_ESDRAM)
			type =
			    spdmem_superset_types[SPDMEM_SUPERSET_DDR_ESDRAM];
		if (s->sm_type == SPDMEM_MEMTYPE_SDRAM &&
		    s->sm_data[SPDMEM_SDR_SUPERSET] == SPDMEM_SUPERSET_ESDRAM) {
			type = spdmem_superset_types[SPDMEM_SUPERSET_ESDRAM];
d317 1
d320 22
d343 6
a348 21
	if (IS_RAMBUS_TYPE) {
		rows = s->sm_data[SPDMEM_RDR_ROWS_COLS] & 0x0f;
		cols = s->sm_data[SPDMEM_RDR_ROWS_COLS] >> 4;
		dimm_size = (1 << (rows + cols - 13));
	} else if (s->sm_type == SPDMEM_MEMTYPE_SDRAM ||
	    s->sm_type == SPDMEM_MEMTYPE_DDRSDRAM) {
		int num_banks, per_chip;

		num_banks = s->sm_data[SPDMEM_SDR_BANKS];
		per_chip = s->sm_data[SPDMEM_SDR_BANKS_PER_CHIP];
		rows = s->sm_data[SPDMEM_SDR_ROWS] & 0x0f;
		cols = s->sm_data[SPDMEM_SDR_COLS] & 0x0f;
		dimm_size = (1 << (rows + cols - 17)) * num_banks * per_chip;
	} else if (s->sm_type == SPDMEM_MEMTYPE_DDR2SDRAM) {
		int num_ranks, density;

		num_ranks = (s->sm_data[SPDMEM_DDR2_RANKS] & 0x7) + 1;
		density = (s->sm_data[SPDMEM_DDR2_RANK_DENSITY] & 0xf0) |
		    ((s->sm_data[SPDMEM_DDR2_RANK_DENSITY] & 0x0f) << 8);
		dimm_size = num_ranks * density * 4;
	}
d360 1
a360 5
	if (((s->sm_type == SPDMEM_MEMTYPE_DDRSDRAM ||
	      s->sm_type == SPDMEM_MEMTYPE_SDRAM) && 
	     (s->sm_data[SPDMEM_DDR_MOD_ATTRIB] & SPDMEM_DDR_ATTRIB_REG)) ||
	    ((s->sm_type == SPDMEM_MEMTYPE_DDR2SDRAM) &&
	     (s->sm_data[SPDMEM_DDR2_DIMMTYPE] & SPDMEM_DDR2_TYPE_REGMASK)))
d363 1
a363 4
	if ((s->sm_type == SPDMEM_MEMTYPE_SDRAM ||
	     s->sm_type == SPDMEM_MEMTYPE_DDRSDRAM ||
	     s->sm_type == SPDMEM_MEMTYPE_DDR2SDRAM ) &&
	    s->sm_data[SPDMEM_FPM_CONFIG] < 8)
d368 2
a369 9
	cycle_time = 0;
	if (s->sm_type == SPDMEM_MEMTYPE_DDRSDRAM ||
	    s->sm_type == SPDMEM_MEMTYPE_SDRAM)
		cycle_time = (s->sm_data[SPDMEM_DDR_CYCLE] >> 4) * 100 +
		    (s->sm_data[SPDMEM_DDR_CYCLE] & 0x0f) * 10;
	else if (s->sm_type == SPDMEM_MEMTYPE_DDR2SDRAM) {
		cycle_time = (s->sm_data[SPDMEM_DDR2_CYCLE] >> 4) * 100 +
		    ddr2_cycle_tenths[(s->sm_data[SPDMEM_DDR2_CYCLE] & 0x0f)];
	}
d376 1
d378 1
a378 1
		d_clk = 100 * 1000;
d380 18
a397 8
		switch (s->sm_type) {
		case SPDMEM_MEMTYPE_DDR2SDRAM:
			/* DDR2 uses quad-pumped clock */
			d_clk *= 4;
			bits = s->sm_data[SPDMEM_DDR2_DATAWIDTH];
			if ((config & 0x03) != 0)
				bits -= 8;
			ddr_type_string = "PC2-";
a398 10
		case SPDMEM_MEMTYPE_DDRSDRAM:
			/* DDR uses dual-pumped clock */
			d_clk *= 2;
			/* FALLTHROUGH */
		default:	/* SPDMEM_MEMTYPE_SDRAM */
			bits = s->sm_data[SPDMEM_DDR_DATAWIDTH] |
			    (s->sm_data[SPDMEM_DDR_DATAWIDTH + 1] << 8);
			if (config == 1 || config == 2)
				bits -= 8;
			ddr_type_string = "PC";
d400 40
d441 17
a457 29
		if (s->sm_type == SPDMEM_MEMTYPE_SDRAM) {
			p_clk = 66;
			if (s->sm_len >= 128) {
				switch (spdmem_read(sc, SPDMEM_SDR_FREQUENCY)) {
				case SPDMEM_SDR_FREQ_100:
				case SPDMEM_SDR_FREQ_133:
					/* We need to check ns to decide here */
					if (s->sm_data[SPDMEM_SDR_CYCLE] < 0x80)
						p_clk = 133;
					else
						p_clk = 100;
					break;
				case SPDMEM_SDR_FREQ_66:
				default:
					p_clk = 66;
					break;
				}
			} 
		} else {
			d_clk /= cycle_time;
			if (s->sm_type == SPDMEM_MEMTYPE_DDR2SDRAM)
				d_clk = (d_clk + 1) / 2;
			p_clk = d_clk * bits / 8;
			if (s->sm_type == SPDMEM_MEMTYPE_DDRSDRAM &&
			    (p_clk % 100) >= 50)
				p_clk += 50;
			p_clk -= p_clk % 100;
		}
		printf(" %s%d", ddr_type_string, p_clk);
d461 3
a463 3
	switch (s->sm_type) {
	case SPDMEM_MEMTYPE_SDRAM:
		if (s->sm_len < 128)
d465 6
a470 4
		if (spdmem_read(sc, SPDMEM_SDR_CAS) & SPDMEM_SDR_CAS2)
			printf("CL2");
		else if (spdmem_read(sc, SPDMEM_SDR_CAS) & SPDMEM_SDR_CAS3)
			printf("CL3");
d472 2
a473 8
	case SPDMEM_MEMTYPE_DDRSDRAM:
		for (i = 6; i >= 0; i--) {
			if (s->sm_data[SPDMEM_DDR_CAS] & (1 << i)) {
				cl = ((i * 10) / 2) + 10;
				printf("CL%d.%d", cl / 10, cl % 10);
				break;
			}
		}
d475 3
a477 7
	case SPDMEM_MEMTYPE_DDR2SDRAM:
		for (i = 5; i >= 2; i--) {
			if (s->sm_data[SPDMEM_DDR_CAS] & (i << i)) {
				printf("CL%d", i);
				break;
			}
		}
d480 1
d482 28
a509 4
	if (s->sm_type == SPDMEM_MEMTYPE_DDR2SDRAM) {
		switch (s->sm_data[SPDMEM_DDR2_DIMMTYPE]) {
		case SPDMEM_DDR2_SODIMM:
			printf(" SO-DIMM");
d511 5
a515 2
		case SPDMEM_DDR2_MICRO_DIMM:
			printf(" Micro-DIMM");
d517 6
a522 3
		case SPDMEM_DDR2_MINI_RDIMM:
		case SPDMEM_DDR2_MINI_UDIMM:
			printf(" Mini-DIMM");
d526 1
a526 1
		
@


1.18
log
@Print the type of DIMM (SO-DIMM/Mini-DIMM/Micro-DIMM) for
non regular DDR2, there does not seem to be any equivalent information
in the SDR/DDR layouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.17 2007/10/20 00:42:09 jsg Exp $	*/
d250 1
a250 1
		for(j = 0; j < 16; j++)
d374 1
a374 1
				switch(spdmem_read(sc, SPDMEM_SDR_FREQUENCY)) {
d394 3
d476 1
a476 1
		for(j = 0; j < 16; j++)
@


1.17
log
@Deal with all possible 16 array offsets for tenths of a nanosecond array,
and tweak p_clk rounding to return correct values.
From giovanni <qgiovanni@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.16 2007/10/18 23:05:20 jsg Exp $	*/
d137 4
d428 15
@


1.16
log
@Correct tenths of a nanosecond cycle encodings for DDR2,
this makes the PC2-xxxx values show properly in all cases.
From giovanni <qgiovanni@@gmail.com>
tested/ok cnst@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.15 2007/10/17 02:35:25 deraadt Exp $	*/
d139 1
a139 1
	0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 25, 33, 66, 75, 0
a389 2
			if ((p_clk % 100) >= 50)
				p_clk += 50;
@


1.15
log
@decl variables earlier; pointed out by fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.14 2007/10/17 02:09:18 deraadt Exp $	*/
d138 4
d334 2
a335 2
		cycle_time = (s->sm_data[SPDMEM_DDR_CYCLE] >> 4) * 100 +
		    (s->sm_data[SPDMEM_DDR_CYCLE] & 0x0f);
@


1.14
log
@some local variables can shadow to decrease kernel stack use, whee
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.13 2007/10/16 19:17:21 kettenis Exp $	*/
d283 4
a288 2
		int num_banks = s->sm_data[SPDMEM_SDR_BANKS];
		int per_chip = s->sm_data[SPDMEM_SDR_BANKS_PER_CHIP];
d291 4
a294 2
		int num_ranks = (s->sm_data[SPDMEM_DDR2_RANKS] & 0x7) + 1;
		int density = (s->sm_data[SPDMEM_DDR2_RANK_DENSITY] & 0xf0) |
@


1.13
log
@Fix printing of DIMM size for DDR2.

input from canacar@@, jsg@@, deraadt@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.12 2007/10/15 18:47:24 kettenis Exp $	*/
d173 1
a173 1
static const char* spdmem_basic_types[] = {
d187 1
a187 1
static const char* spdmem_superset_types[] = {
d195 1
a195 1
static const char* spdmem_parity_types[] = {
a224 2
	int num_banks, per_chip;
	int num_ranks, density;
d285 2
a286 2
		num_banks = s->sm_data[SPDMEM_SDR_BANKS];
		per_chip = s->sm_data[SPDMEM_SDR_BANKS_PER_CHIP];
d289 2
a290 2
		num_ranks = (s->sm_data[SPDMEM_DDR2_RANKS] & 0x7) + 1;
		density = (s->sm_data[SPDMEM_DDR2_RANK_DENSITY] & 0xf0) |
@


1.12
log
@No need to match on "at34c02" anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.11 2007/10/14 22:31:33 deraadt Exp $	*/
a132 1
#define SPDMEM_DDR2_BANKS_PER_CHIP	0x0e
d134 1
a223 2
	int num_banks = 0;
	int per_chip = 0;
d225 2
d282 1
a282 1
		printf(" %dMB", 1 << (rows + cols - 13));
a286 1
		dimm_size = rows + cols - 17;
d289 1
d291 4
a294 5
		rows = s->sm_data[SPDMEM_DDR2_ROWS] & 0x1f;
		cols = s->sm_data[SPDMEM_DDR2_COLS] & 0x0f;
		dimm_size = rows + cols - 17;
		num_banks = s->sm_data[SPDMEM_DDR_RANKS] + 1;
		per_chip = s->sm_data[SPDMEM_DDR2_BANKS_PER_CHIP];
d296 6
a301 4
	if (!(IS_RAMBUS_TYPE) && num_banks <= 8 && per_chip <= 8 &&
	    dimm_size > 0 && dimm_size <= 12) {
		dimm_size = (1 << dimm_size) * num_banks * per_chip;
		printf(" %dMB", dimm_size);
@


1.11
log
@correctly print PC and PC2- prefixes; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.10 2007/10/13 19:07:05 cnst Exp $	*/
d211 1
a211 2
	if (strcmp(ia->ia_name, "spd") == 0 ||
	    strcmp(ia->ia_name, "at34c02") == 0)
@


1.10
log
@really correct : printing; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.9 2007/10/11 06:04:57 jsg Exp $	*/
d347 1
a347 1
			ddr_type_string = "PC2";
d388 1
a388 1
		printf(" %s-%d", ddr_type_string, p_clk);
@


1.9
log
@hypenate memory type for readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.8 2007/10/10 16:04:17 deraadt Exp $	*/
d234 1
a234 1
	printf(": ");
d283 1
a283 1
		printf("%dMB", 1 << (rows + cols - 13));
d301 1
a301 1
		printf("%dMB", dimm_size);
@


1.8
log
@correct : printing; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.7 2007/10/08 06:20:21 jsg Exp $	*/
d388 1
a388 1
		printf(" %s%d", ddr_type_string, p_clk);
@


1.7
log
@Print registered/CAS latency information for SDRAM.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.6 2007/10/08 05:39:19 jsg Exp $	*/
d234 2
d283 1
a283 1
		printf(": %dMB", 1 << (rows + cols - 13));
d301 1
a301 1
		printf(": %dMB", dimm_size);
@


1.6
log
@To identity PC133 we need to check cycle time as modules
often identify as PC100.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.5 2007/10/08 05:11:14 jsg Exp $	*/
d100 1
d108 2
d305 2
a306 1
	if (((s->sm_type == SPDMEM_MEMTYPE_DDRSDRAM) && 
d389 11
a399 1
	if (s->sm_type == SPDMEM_MEMTYPE_DDRSDRAM) {
d407 2
a408 1
	} else if (s->sm_type == SPDMEM_MEMTYPE_DDR2SDRAM) {
d415 1
@


1.5
log
@Correct frequency for SDRAM.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.4 2007/10/08 03:10:58 jsg Exp $	*/
d98 1
a359 2
					p_clk = 100;
					break;
d361 5
a365 1
					p_clk = 133;
@


1.4
log
@Don't skip EEPROMs in ofw i2c scan,
match on sparc64 SPD name in spdmem.
Tested on a V120.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.3 2007/10/08 01:40:09 jsg Exp $	*/
d101 6
d353 26
a378 7
		d_clk /= cycle_time;
		if (s->sm_type == SPDMEM_MEMTYPE_DDR2SDRAM)
			d_clk = (d_clk + 1) / 2;
		p_clk = d_clk * bits / 8;
		if ((p_clk % 100) >= 50)
			p_clk += 50;
		p_clk -= p_clk % 100;
@


1.3
log
@Indicate if the module is registered, DDR/DDR2 only at the moment.
Tested by ian@@ wilfried@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.2 2007/10/07 16:40:52 jsg Exp $	*/
d201 2
a202 1
	if (strcmp(ia->ia_name, "spd") == 0)
@


1.2
log
@Print CAS latency for DDR/DDR2.
Shuffle strings around to look pretty as suggested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: spdmem.c,v 1.1 2007/10/07 14:57:16 jsg Exp $	*/
d111 1
d114 2
d124 3
d293 6
@


1.1
log
@Port of Nicolas Joly, Paul Goyette & Tobias Nygren's
spdmem(4) driver for Serial Presence Detect memory information.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d110 1
d180 1
a180 1
	"no parity or ECC",
d182 1
a182 1
	"data ECC",
d212 1
a212 1
	uint8_t config, rows, cols;
a259 10
	printf(": %s", type);
	strlcpy(sc->sc_type, type, SPDMEM_TYPE_MAXLEN);

	if ((s->sm_type == SPDMEM_MEMTYPE_SDRAM ||
	     s->sm_type == SPDMEM_MEMTYPE_DDRSDRAM ||
	     s->sm_type == SPDMEM_MEMTYPE_DDR2SDRAM ) &&
	    s->sm_data[SPDMEM_FPM_CONFIG] < 8)
		printf(", %s",
		    spdmem_parity_types[s->sm_data[SPDMEM_FPM_CONFIG]]);

d264 1
a264 1
		printf(", %dMB", 1 << (rows + cols - 13));
d282 1
a282 1
		printf(", %dMB", dimm_size);
d285 10
d341 18
a358 1
		printf(", %dMHz, %s-%d", d_clk, ddr_type_string, p_clk);
@

