head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.12
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.10
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.30
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.28
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.26
	OPENBSD_5_0:1.10.0.24
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.22
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.20
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.16
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.18
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.14
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.12
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.10
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.1.0.8
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2016.04.23.09.40.28;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	CyA3Ml7qEijeAGSi;

1.15
date	2016.04.10.16.43.17;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	f9cDTKE6qgNnPW2n;

1.14
date	2016.04.02.00.56.39;	author jsg;	state Exp;
branches;
next	1.13;
commitid	rLOT1KBG7OCl0AML;

1.13
date	2016.01.12.17.30.23;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	LJBrrbk8JfDe9zMd;

1.12
date	2016.01.12.01.11.15;	author jcs;	state Exp;
branches;
next	1.11;
commitid	vNDeumNiEMwV2q08;

1.11
date	2013.07.05.09.32.14;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.08.23.15.58;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.01.20.52.25;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.31.04.31.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.28.01.02.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.27.17.18.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.22.23.53.58;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.20.05.42.32;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.19.19.36.46;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.15.16.23.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.23.17.33.43;	author grange;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.12.38;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Print a meaningful interrupt string for i2c devices.
@
text
@/*	$OpenBSD: i2cvar.h,v 1.15 2016/04/10 16:43:17 kettenis Exp $	*/
/*	$NetBSD: i2cvar.h,v 1.1 2003/09/30 00:35:31 thorpej Exp $	*/

/*
 * Copyright (c) 2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Steve C. Woodford and Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _DEV_I2C_I2CVAR_H_
#define	_DEV_I2C_I2CVAR_H_

#include <dev/i2c/i2c_io.h>

struct device;

/* Flags passed to i2c routines. */
#define	I2C_F_WRITE		0x00	/* new transfer is a write */
#define	I2C_F_READ		0x01	/* new transfer is a read */
#define	I2C_F_LAST		0x02	/* last byte of read */
#define	I2C_F_STOP		0x04	/* send stop after byte */
#define	I2C_F_POLL		0x08	/* poll, don't sleep */

/*
 * This structure provides the interface between the i2c framework
 * and the underlying i2c controller.
 *
 * Note that this structure is designed specifically to allow us
 * to either use the autoconfiguration framework or not.  This
 * allows a driver for a board with a private i2c bus use generic
 * i2c client drivers for chips that might be on that board.
 */
typedef struct i2c_controller {
	void	*ic_cookie;		/* controller private */

	/*
	 * These provide synchronization in the presence of
	 * multiple users of the i2c bus.  When a device
	 * driver wishes to perform transfers on the i2c
	 * bus, the driver should acquire the bus.  When
	 * the driver is finished, it should release the
	 * bus.
	 *
	 * This is provided by the back-end since a single
	 * controller may present e.g. i2c and smbus views
	 * of the same set of i2c wires.
	 */
	int	(*ic_acquire_bus)(void *, int);
	void	(*ic_release_bus)(void *, int);

	/*
	 * The preferred API for clients of the i2c interface
	 * is the scripted API.  This handles i2c controllers
	 * that do not provide raw access to the i2c signals.
	 */
	int	(*ic_exec)(void *, i2c_op_t, i2c_addr_t, const void *, size_t,
		    void *, size_t, int);

	int	(*ic_send_start)(void *, int);
	int	(*ic_send_stop)(void *, int);
	int	(*ic_initiate_xfer)(void *, i2c_addr_t, int);
	int	(*ic_read_byte)(void *, uint8_t *, int);
	int	(*ic_write_byte)(void *, uint8_t, int);

	void	*(*ic_intr_establish)(void *, void *, int, int (*)(void *),
		    void *, const char *);
	const char *(*ic_intr_string)(void *, void *);
} *i2c_tag_t;

/* Used to attach the i2c framework to the controller. */
struct i2cbus_attach_args {
	const char *iba_name;		/* bus name ("iic") */
	i2c_tag_t iba_tag;		/* the controller */
	void	(*iba_bus_scan)(struct device *, struct i2cbus_attach_args *,
		    void *);
	void	*iba_bus_scan_arg;
};

/* Used to attach devices on the i2c bus. */
struct i2c_attach_args {
	i2c_tag_t	ia_tag;		/* our controller */
	i2c_addr_t	ia_addr;	/* address of device */
	int		ia_size;	/* size (for EEPROMs) */
	char		*ia_name;	/* chip name */
	void		*ia_cookie;	/* pass extra info from bus to dev */
	void		*ia_intr;	/* interrupt info */
};

/*
 * API presented to i2c controllers.
 */
int	iicbus_print(void *, const char *);

#ifdef _I2C_PRIVATE
/*
 * Macros used internally by the i2c framework.
 */
#define	iic_send_start(ic, flags)					\
	(*(ic)->ic_send_start)((ic)->ic_cookie, (flags))
#define	iic_send_stop(ic, flags)					\
	(*(ic)->ic_send_stop)((ic)->ic_cookie, (flags))
#define	iic_initiate_xfer(ic, addr, flags)				\
	(*(ic)->ic_initiate_xfer)((ic)->ic_cookie, (addr), (flags))

#define	iic_read_byte(ic, bytep, flags)					\
	(*(ic)->ic_read_byte)((ic)->ic_cookie, (bytep), (flags))
#define	iic_write_byte(ic, byte, flags)					\
	(*(ic)->ic_write_byte)((ic)->ic_cookie, (byte), (flags))

void	iic_scan(struct device *, struct i2cbus_attach_args *);
int	iic_print(void *, const char *);
#endif /* _I2C_PRIVATE */

/*
 * Simplified API for clients of the i2c framework.  Definitions
 * in <dev/i2c/i2c_io.h>.
 */
#define	iic_acquire_bus(ic, flags)					\
	(*(ic)->ic_acquire_bus)((ic)->ic_cookie, (flags))
#define	iic_release_bus(ic, flags)					\
	(*(ic)->ic_release_bus)((ic)->ic_cookie, (flags))

int	iic_exec(i2c_tag_t, i2c_op_t, i2c_addr_t, const void *,
	    size_t, void *, size_t, int);

int	iic_smbus_write_byte(i2c_tag_t, i2c_addr_t, uint8_t, uint8_t, int);
int	iic_smbus_read_byte(i2c_tag_t, i2c_addr_t, uint8_t, uint8_t *, int);
int	iic_smbus_receive_byte(i2c_tag_t, i2c_addr_t, uint8_t *, int);

#define iic_intr_establish(ic, ih, level, func, arg, name)		\
	(*(ic)->ic_intr_establish)((ic)->ic_cookie, (ih), (level),	\
	    (func), (arg), (name))
#define iic_intr_string(ic, ih)						\
	(*(ic)->ic_intr_string)((ic)->ic_cookie, (ih))

void	iic_ignore_addr(u_int8_t addr);

#endif /* _DEV_I2C_I2CVAR_H_ */
@


1.15
log
@Fix layer violation in the ihidev(4) code by implementing a generic mechanism
that allows the i2c controller implementation to establish interrupts on
behalf of i2c slave device drivers.  Use this mechanism in dwiic(4) to let
it configure the right acpi interrupt (global or gpio).  Change the level to
IPL_TTY as this is the appropriate level to use for keyboards and other
input devices.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.14 2016/04/02 00:56:39 jsg Exp $	*/
d96 1
d162 2
@


1.14
log
@Add support for I2C HID devices with GPIO signalled interrupts.
Required for the keyboard and touchpad on the ideapad 100s.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.13 2016/01/12 17:30:23 deraadt Exp $	*/
d93 3
a111 2
	int		ia_int;		/* IRQ */
	int		ia_int_flags;	/* IRQ flags */
d114 1
a114 1
	void		*acpi_gpio;
d157 4
@


1.13
log
@rename new i2c_attach_args fields to avoid conflict with cpp magic in
isavar.h (a few parts of the tree include both)
ok jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.12 2016/01/12 01:11:15 jcs Exp $	*/
d113 1
@


1.12
log
@Add dwiic, a driver for the Synopsys DesignWare i2c controller found
on the Samsung ATIV Book 9 laptop.  This initial version only
supports ACPI config/attachment.

Add ihidev, a HID-over-i2c driver largely based on uhidev.  dwiic
handles attaching ihidev devices found in ACPI.

Add ims, a HID-over-i2c mouse/trackpad driver to get basic cursor
and button functionality from HID-compliant i2c trackpads.

ok kettenis deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.11 2013/07/05 09:32:14 kettenis Exp $	*/
d109 2
a110 2
	int		ia_irq;		/* IRQ */
	int		ia_irq_flags;	/* IRQ flags */
@


1.11
log
@Provide a forward declaration of struct device.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.10 2006/02/08 23:15:58 dlg Exp $	*/
d109 2
@


1.10
log
@add a member to the i2c_attach args so that a controller can pass a
cookie down to the device. the most obvious use of this is to pass a
device its ofw node on sparc64 and macppc so it can configure itself more
appropriately.

ok kettenis@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.9 2006/01/01 20:52:25 deraadt Exp $	*/
d43 2
@


1.9
log
@switch from macppc-specific maciic(4) driver to the generic iic(4),
after teaching it to use a function pointer to get back to the OFW
scan.. this will also help the sparc64 later; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.8 2005/12/31 04:31:27 deraadt Exp $	*/
d108 1
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.7 2005/12/28 01:02:58 deraadt Exp $	*/
d97 3
a99 1
	int iba_scan;			/* do bus scanning */
@


1.7
log
@some chips (especially those crazy i2c/lpc/isa gross things) expose their
banks at other addresses, but there are issues with accessing these other
devices.  so allow a driver to "knock" these out from future probing.
tested by kettenis -- unfortunate enough to have one of these winbond pieces
of poo
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.6 2005/12/27 17:18:18 deraadt Exp $	*/
d105 1
a105 1
	char		*ia_name;	
@


1.6
log
@no longer use ia_compat; tested by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.5 2005/12/22 23:53:58 deraadt Exp $	*/
d148 2
@


1.5
log
@permit outsider to call iic_print
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.4 2005/12/20 05:42:32 grange Exp $	*/
a105 1
	char		*ia_compat;	
@


1.4
log
@Do bus scanning only if underlying controller asked for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.3 2005/12/19 19:36:46 grange Exp $	*/
d131 1
@


1.3
log
@First attempt to have a table of known I2C slave devices that we
have drivers for. iic(4) will scan the bus for them and try to
attach an appropriate driver.
For now iic(4) scans for all possible addresses for debugging purposes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.2 2005/11/15 16:23:31 deraadt Exp $	*/
d97 1
@


1.2
log
@instead of passing OF nodes down to the drivers, pass name/compat string
pointers.  This lets their match() functions actually make real decisions.
OF-capable machines will pass name/compat pointers, but other machines
will not.  grudging ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i2cvar.h,v 1.1 2004/05/23 17:33:43 grange Exp $	*/
d128 2
@


1.1
log
@I2C framework originally written by Steve C. Woodford and Jason R. Thorpe
for NetBSD (r).

This framework supports various i2c master controllers:
- dumb bit-bang controllers
- a few styles of automated controllers that give you control
over sending start/stop conditions on the i2c bus
- automated controllers that are too smart for its own good,
giving software no control over start/stop conditions
- smbus controllers by emulating smbus protocol with i2c commands

i2c slave devices need their addresses to be specified in the kernel
config file, no device discovery presented.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 2
@


1.1.2.1
log
@Merge with the trunk
@
text
@@

