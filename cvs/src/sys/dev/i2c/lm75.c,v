head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.12
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.10
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.18.0.30
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.28
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.26
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.22
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.20
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.18
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.16
	OPENBSD_5_0:1.18.0.14
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.12
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.10
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.1.0.8
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.20
date	2015.05.30.08.39.05;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	Q3NKL3TqdrfpNlPO;

1.19
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.18;
commitid	p4LJxGKbi0BU2cG6;

1.18
date	2008.04.17.19.01.48;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.16.22.44.37;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.15.20.47.52;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.19.15.55.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.10.00.57.23;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.19.17.08.39;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.10.23.02.32;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.09.23.30.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.09.19.27.34;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.09.18.51.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.29.14.51.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.27.17.18.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.15.16.23.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.13.00.19.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.11.16.14.14;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.23.18.12.37;	author grange;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.12.38;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Acquire/release the i2c bus before/after reading the temperature register.
Prevents concurrent access to the smu(4) microcontroller on Apple G5
machines, which would result in errors reading the RTC.

ok deraadt@@, mpi@@
@
text
@/*	$OpenBSD: lm75.c,v 1.19 2015/03/14 03:38:47 jsg Exp $	*/
/*	$NetBSD: lm75.c,v 1.1 2003/09/30 00:35:31 thorpej Exp $	*/
/*
 * Copyright (c) 2006 Theo de Raadt <deraadt@@openbsd.org>
 * Copyright (c) 2004 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * National Semiconductor LM75/LM76/LM77 temperature sensor.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/sensors.h>

#include <dev/i2c/i2cvar.h>

#define	LM_MODEL_LM75	1
#define	LM_MODEL_LM77	2
#define	LM_MODEL_DS1775	3
#define	LM_MODEL_LM75A	4
#define	LM_MODEL_LM76	5

#define LM_POLLTIME	3	/* 3s */

#define	LM75_REG_TEMP			0x00
#define	LM75_REG_CONFIG			0x01
#define  LM75_CONFIG_SHUTDOWN		0x01
#define  LM75_CONFIG_CMPINT		0x02
#define  LM75_CONFIG_OSPOLARITY		0x04
#define  LM75_CONFIG_FAULT_QUEUE_MASK	0x18
#define  LM75_CONFIG_FAULT_QUEUE_1	(0 << 3)
#define  LM75_CONFIG_FAULT_QUEUE_2	(1 << 3)
#define  LM75_CONFIG_FAULT_QUEUE_4	(2 << 3)
#define  LM75_CONFIG_FAULT_QUEUE_6	(3 << 3)
#define  LM77_CONFIG_INTPOLARITY	0x08
#define  LM77_CONFIG_FAULT_QUEUE_4	0x10
#define  DS1755_CONFIG_RESOLUTION(i)	(9 + (((i) >> 5) & 3))
#define	LM75_REG_THYST_SET_POINT	0x02
#define	LM75_REG_TOS_SET_POINT		0x03
#define	LM77_REG_TLOW			0x04
#define	LM77_REG_THIGH			0x05

struct lmtemp_softc {
	struct device sc_dev;
	i2c_tag_t sc_tag;
	int	sc_addr;
	int	sc_model;
	int	sc_bits;
	int	sc_ratio;

	struct ksensor sc_sensor;
	struct ksensordev sc_sensordev;
};

int  lmtemp_match(struct device *, void *, void *);
void lmtemp_attach(struct device *, struct device *, void *);

struct cfattach lmtemp_ca = {
	sizeof(struct lmtemp_softc),
	lmtemp_match,
	lmtemp_attach
};

struct cfdriver lmtemp_cd = {
	NULL, "lmtemp", DV_DULL
};

/*
 * Temperature on the LM75 is represented by a 9-bit two's complement
 * integer in steps of 0.5C.  The following examples are taken from
 * the LM75 data sheet:
 *
 *	+125C	0 1111 1010	0x0fa
 *	+25C	0 0011 0010	0x032
 *	+0.5C	0 0000 0001	0x001
 *	0C	0 0000 0000	0x000
 *	-0.5C	1 1111 1111	0x1ff
 *	-25C	1 1100 1110	0x1ce
 *	-55C	1 1001 0010	0x192
 *
 * Temperature on the LM75A is represented by an 11-bit two's complement
 * integer in steps of 0.125C.  The LM75A can be treated like an LM75 if
 * the extra precision is not required.  The following examples are
 * taken from the LM75A data sheet:
 *
 *	+127.000C	011 1111 1000	0x3f8
 *	+126.875C	011 1111 0111	0x3f7
 *	+126.125C	011 1111 0001	0x3f1
 *	+125.000C	011 1110 1000	0x3e8
 *	+25.000C	000 1100 1000	0x0c8
 *	+0.125C		000 0000 0001	0x001
 *	0C		000 0000 0000	0x000
 *	-0.125C		111 1111 1111	0x7ff
 *	-25.000C	111 0011 1000	0x738
 *	-54.875C	110 0100 1001	0x649
 *	-55.000C	110 0100 1000	0x648
 *
 * Temperature on the LM77 is represented by a 13-bit two's complement
 * integer in steps of 0.5C.  The LM76 is similar, but the integer is
 * in steps of 0.065C
 *
 * LM75 temperature word:
 *
 * MSB Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0 X X X X X X X
 * 15  14   13   12   11   10   9    8    7    6 5 4 3 2 1 0
 *
 *
 * LM75A temperature word:
 *
 * MSB Bit9 Bit8 Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0 X X X X X
 * 15  14   13   12   11   10   9    8    7    6    5    4 3 2 1 0
 *
 *
 * LM77 temperature word:
 *
 * Sign Sign Sign Sign MSB Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0 Status bits
 * 15   14   13   12   11  10   9    8    7    6    5    4    3    2 1 0
 */

int  lmtemp_temp_read(struct lmtemp_softc *, uint8_t, int *);
void lmtemp_refresh_sensor_data(void *);

int
lmtemp_match(struct device *parent, void *match, void *aux)
{
	struct i2c_attach_args *ia = aux;

	if (strcmp(ia->ia_name, "lm75") == 0 ||
	    strcmp(ia->ia_name, "lm76") == 0 ||
	    strcmp(ia->ia_name, "lm77") == 0 ||
	    strcmp(ia->ia_name, "ds1775") == 0 ||
	    strcmp(ia->ia_name, "lm75a") == 0)
		return (1);
	return (0);
}

void
lmtemp_attach(struct device *parent, struct device *self, void *aux)
{
	struct lmtemp_softc *sc = (struct lmtemp_softc *)self;
	struct i2c_attach_args *ia = aux;
	u_int8_t cmd, data;

	sc->sc_tag = ia->ia_tag;
	sc->sc_addr = ia->ia_addr;

	printf(": %s", ia->ia_name);

	/* If in SHUTDOWN mode, wake it up */
	iic_acquire_bus(sc->sc_tag, 0);
	cmd = LM75_REG_CONFIG;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(", fails to respond\n");
		return;
	}
	if (data & LM75_CONFIG_SHUTDOWN) {
		data &= ~LM75_CONFIG_SHUTDOWN;
		if (iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
		    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
			printf(", cannot wake up\n");
			iic_release_bus(sc->sc_tag, 0);
			return;
		}
		printf(", woken up");
	}
	iic_release_bus(sc->sc_tag, 0);

	sc->sc_model = LM_MODEL_LM75;
	sc->sc_bits = 9;
	sc->sc_ratio = 500000;		/* 0.5 degC for LSB */
	if (strcmp(ia->ia_name, "lm77") == 0) {
		sc->sc_model = LM_MODEL_LM77;
		sc->sc_bits = 13;
	} else if (strcmp(ia->ia_name, "lm76") == 0) {
		sc->sc_model = LM_MODEL_LM76;
		sc->sc_bits = 13;
		sc->sc_ratio = 62500;	/* 0.0625 degC for LSB */
	} else if (strcmp(ia->ia_name, "ds1775") == 0) {
		sc->sc_model = LM_MODEL_DS1775;
		//sc->sc_bits = DS1755_CONFIG_RESOLUTION(data);
	} else if (strcmp(ia->ia_name, "lm75a") == 0) {
		/* For simplicity's sake, treat the LM75A as an LM75 */
		sc->sc_model = LM_MODEL_LM75A;
	}

	printf("\n");

	/* Initialize sensor data */
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));
	sc->sc_sensor.type = SENSOR_TEMP;

	/* Hook into the hw.sensors sysctl */
	sensor_attach(&sc->sc_sensordev, &sc->sc_sensor);
	sensordev_install(&sc->sc_sensordev);

	sensor_task_register(sc, lmtemp_refresh_sensor_data, LM_POLLTIME);
}

int
lmtemp_temp_read(struct lmtemp_softc *sc, uint8_t which, int *valp)
{
	u_int8_t cmd = which;
	u_int16_t data = 0x0000;
	int error;

	iic_acquire_bus(sc->sc_tag, 0);
	error = iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0);
	iic_release_bus(sc->sc_tag, 0);
	if (error)
		return (error);

	/* Some chips return transient 0's.. we try next time */
	if (data == 0x0000)
		return (1);

	/* convert to half-degrees C */
	*valp = betoh16(data) / (1 << (16 - sc->sc_bits));
	return (0);
}

void
lmtemp_refresh_sensor_data(void *aux)
{
	struct lmtemp_softc *sc = aux;
	int val;
	int error;

	error = lmtemp_temp_read(sc, LM75_REG_TEMP, &val);
	if (error) {
#if 0
		printf("%s: unable to read temperature, error = %d\n",
		    sc->sc_dev.dv_xname, error);
#endif
		sc->sc_sensor.flags |= SENSOR_FINVALID;
		return;
	}

	sc->sc_sensor.value = val * sc->sc_ratio + 273150000;
	sc->sc_sensor.flags &= ~SENSOR_FINVALID;
}
@


1.19
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.18 2008/04/17 19:01:48 deraadt Exp $	*/
d219 1
a219 1
	u_int8_t cmd;
d223 1
a223 1
	cmd = which;
d226 1
@


1.18
log
@make it more apparent that when we are dealing with 16 bit registers
(not a series of 8 bit registers), the bytes come off the wire in
big-endian order
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.17 2008/04/16 22:44:37 deraadt Exp $	*/
a26 1
#include <sys/kernel.h>
@


1.17
log
@Use ntohs() to swap the raw i2c data to native format; tested by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.16 2008/04/15 20:47:52 deraadt Exp $	*/
d235 1
a235 1
	*valp = ntohs(data) / (1 << (16 - sc->sc_bits));
@


1.16
log
@Take a shot at LM76 support (13 bit temperature, 0.065 degC per LSB) for
when we finally find one of these devices.  looked at by kettenis..
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.15 2007/03/22 16:55:31 deraadt Exp $	*/
d168 1
a168 1
	    sc->sc_addr, &cmd, 1, &data, 1, 0)) {
d170 1
d176 1
a176 1
		    sc->sc_addr, &cmd, 1, &data, 1, 0)) {
a213 1

d220 2
a221 1
	u_int8_t cmd, buf[2];
d226 1
a226 1
	    sc->sc_addr, &cmd, 1, buf, 2, 0);
d231 1
a231 1
	if (buf[0] == 0x00 && buf[1] == 0x00)
d235 1
a235 1
	*valp = ((buf[0] << 8) | buf[1]) / (1 << (16 - sc->sc_bits));
@


1.15
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.14 2006/12/23 17:46:39 deraadt Exp $	*/
d21 1
a21 1
 * National Semiconductor LM75/LM77 temperature sensor.
d36 1
d64 1
d113 3
a115 11
 * Temperature on the LM77 is represented by a 10-bit two's complement
 * integer in steps of 0.5C:
 *
 *	+130C	01 0000 0100	0x104
 *	+125C	00 1111 1010	0x0fa
 *	+25C	00 0011 0010	0x032
 *	+0.5C	00 0000 0001	0x001
 *	0C	00 0000 0000	0x000
 *	-0.5C	11 1111 1111	0x3ff
 *	-25C	11 1100 1110	0x3ce
 *	-55C	11 1001 0010	0x392
d144 1
d186 1
d190 4
a195 1
		sc->sc_bits = 9;
a199 1
		sc->sc_bits = 9;
d255 1
a255 1
	sc->sc_sensor.value = val * 500000 + 273150000;
@


1.14
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.13 2006/08/19 15:55:47 deraadt Exp $	*/
d64 2
a65 2
	struct sensor sc_sensor;
	struct sensordev sc_sensordev;
@


1.13
log
@handle lm75a; matt@@bodgit-n-scarper.com
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.12 2006/04/10 00:57:23 deraadt Exp $	*/
d65 1
d207 2
a208 2
	strlcpy(sc->sc_sensor.device, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensor.device));
a209 1
	strlcpy(sc->sc_sensor.desc, "Temp", sizeof(sc->sc_sensor.desc));
d212 3
a214 1
	sensor_add(&sc->sc_sensor);
@


1.12
log
@make this match our code standards
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.11 2006/01/19 17:08:39 grange Exp $	*/
d35 1
d93 17
d128 6
d150 2
a151 1
	    strcmp(ia->ia_name, "ds1775") == 0)
d197 4
@


1.11
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.10 2006/01/10 23:02:32 deraadt Exp $	*/
d180 1
a180 1
	strlcpy(sc->sc_sensor.desc, "TEMP", sizeof(sc->sc_sensor.desc));
@


1.10
log
@rewritten lm75 driver.  try to cope with the lm75 and lm77 better, but
something is still odd or wrong with a ds1775 i have (which is returning
absolute garbage); tested by kettenis grange
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.9 2006/01/09 23:30:38 deraadt Exp $	*/
d183 1
a183 1
	SENSOR_ADD(&sc->sc_sensor);
@


1.9
log
@damn, left a lock
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.8 2006/01/09 19:27:34 deraadt Exp $	*/
d4 1
a20 35
 * Copyright (c) 2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
d31 24
a54 1
#include <dev/i2c/lm75reg.h>
d59 3
a61 2
	int sc_address;
	int sc_model;
d79 37
a115 1
int  lmtemp_config_write(struct lmtemp_softc *, uint8_t);
d136 1
d139 1
a139 1
	sc->sc_address = ia->ia_addr;
d141 1
a141 5
	sc->sc_model = LM_MODEL_LM75;
	if (strcmp(ia->ia_name, "lm77") == 0)
		sc->sc_model = LM_MODEL_LM77;

	printf(": %s\n", ia->ia_name);
d143 1
a143 1
	/* Set the configuration to defaults */
d145 3
a147 3
	if (lmtemp_config_write(sc, 0) != 0) {
		printf("%s: unable to write config register\n",
		    sc->sc_dev.dv_xname);
d151 10
d163 13
a188 12
lmtemp_config_write(struct lmtemp_softc *sc, uint8_t val)
{
	uint8_t cmdbuf[2];

	cmdbuf[0] = LM75_REG_CONFIG;
	cmdbuf[1] = val;

	return (iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
	    sc->sc_address, cmdbuf, 1, &cmdbuf[1], 1, 0));
}

int
d191 1
a191 2
	u_int8_t cmdbuf[1];
	u_int8_t buf[LM75_TEMP_LEN];
d194 1
a194 2
	cmdbuf[0] = which;

d196 1
a196 1
	    sc->sc_address, cmdbuf, 1, buf, LM75_TEMP_LEN, 0);
d200 2
a201 10
	switch (sc->sc_model) {
	case LM_MODEL_LM75:
		*valp = lm75_wordtotemp((buf[0] << 8) | buf[1]);
		break;
	case LM_MODEL_LM77:
		*valp = lm77_wordtotemp((buf[0] << 8) | buf[1]);
		break;
	default:
		printf("%s: unknown model (%d)\n",
		    sc->sc_dev.dv_xname, sc->sc_model);
a202 1
	}
d204 2
@


1.8
log
@variables now unused
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.7 2006/01/09 18:51:04 deraadt Exp $	*/
a118 2

	iic_release_bus(sc->sc_tag, 0);
@


1.7
log
@trust i2c_scan for telling us if this is a lm75 or lm77, instead of
stupidly relying on some power-up default register which a BIOS could
change; ok grange
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.6 2005/12/29 14:51:08 deraadt Exp $	*/
a109 1
	u_int8_t ptr[1], reg[LM75_TEMP_LEN];
@


1.6
log
@stop using I2C_F_POLL; it is a bus driver responsibility now
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.5 2005/12/27 17:18:18 deraadt Exp $	*/
d99 1
d116 2
d119 1
a119 12
	/* Try to detect LM77 by poking Thigh register */
	ptr[0] = LM77_REG_THIGH;
	iic_acquire_bus(sc->sc_tag, 0);
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_address, ptr, 1, reg, LM75_TEMP_LEN, 0) == 0) {
		/* Power up default is 64 degC */
		if (lm77_wordtotemp((reg[0] << 8) | reg[1]) == 64 * 2)
			sc->sc_model = LM_MODEL_LM77;
	}

	printf(": %s (%s)\n", ia->ia_name,
	    sc->sc_model == LM_MODEL_LM75 ? "LM75" : "LM77");
@


1.5
log
@no longer use ia_compat; tested by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.4 2005/11/15 16:23:31 deraadt Exp $	*/
d118 1
a118 1
	iic_acquire_bus(sc->sc_tag, I2C_F_POLL);
d129 1
a129 1
	iic_release_bus(sc->sc_tag, I2C_F_POLL);
d132 1
a132 1
	iic_acquire_bus(sc->sc_tag, I2C_F_POLL);
d136 1
a136 1
		iic_release_bus(sc->sc_tag, I2C_F_POLL);
d139 1
a139 1
	iic_release_bus(sc->sc_tag, I2C_F_POLL);
d162 1
a162 1
	    sc->sc_address, cmdbuf, 1, &cmdbuf[1], 1, I2C_F_POLL));
@


1.4
log
@instead of passing OF nodes down to the drivers, pass name/compat string
pointers.  This lets their match() functions actually make real decisions.
OF-capable machines will pass name/compat pointers, but other machines
will not.  grudging ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.3 2005/11/13 00:19:17 deraadt Exp $	*/
d98 2
a99 9
	if (ia->ia_compat) {
		if (strcmp(ia->ia_compat, "lm75") == 0 ||
		    strcmp(ia->ia_compat, "ds1775") == 0)
			return (1);
		return (0);
	}

	/* XXX: we allow wider mask for LM77 */
	if ((ia->ia_addr & LM75_ADDRMASK) == LM75_ADDR)
a100 1

d126 2
a127 1
	printf(": %s\n", sc->sc_model == LM_MODEL_LM75 ? "LM75" : "LM77");
@


1.3
log
@code was totally borked, if it failed to detect a LM77 it left the
type as 0; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.2 2005/11/11 16:14:14 kettenis Exp $	*/
d97 7
@


1.2
log
@Use sensors thread instead of timeouts.
ok dlg@@, "slap it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm75.c,v 1.1 2004/05/23 18:12:37 grange Exp $	*/
d115 2
d123 1
a123 1
		if (lm77_wordtotemp((reg[0] << 8) | reg[1]) == 64 * 2) {
a124 5
			printf(": LM77\n");
		}
	} else {
		sc->sc_model = LM_MODEL_LM75;
		printf(": LM75\n");
d126 3
@


1.1
log
@lmtemp(4) -- National Semiconductor LM75/LM77 temperature sensor driver.
Based on the driver from NetBSD (r) written by Jason R. Thorpe,
adapted for our sensors infrastructure and with LM77 support.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a62 1
#include <sys/timeout.h>
a73 1
	struct timeout sc_timeout;
d150 1
a150 3
	/* Set poll timer */
	timeout_set(&sc->sc_timeout, lmtemp_refresh_sensor_data, sc);
	timeout_add(&sc->sc_timeout, LM_POLLTIME);
a213 2

	timeout_add(&sc->sc_timeout, LM_POLLTIME);
@


1.1.2.1
log
@Merge with the trunk
@
text
@@

