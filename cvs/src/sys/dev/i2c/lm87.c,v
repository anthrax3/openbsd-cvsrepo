head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.32
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.22
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.30
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.28
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.26
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.24
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.20
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.18
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.16
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.14
	OPENBSD_5_0:1.20.0.12
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.10
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15;
locks; strict;
comment	@ * @;


1.20
date	2008.11.10.05.19.48;	author cnst;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.09.21.06.33;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.19.17.08.39;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.31.04.31.27;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.27.20.05.56;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.27.20.05.03;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.27.19.45.28;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.27.09.23.28;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.27.03.54.27;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.26.03.52.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.16.23.30.28;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.15.22.01.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.15.20.40.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.15.20.28.04;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.15.18.25.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.15.16.23.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.15.16.19.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@uninitialised value caused some lmenv(4) fans to never appear sometimes;
the bug was reported long time ago by Simon Slaytor with adm9240;
the eyes were cleared today by LLVM/Clang Static Analyser;  ok deraadt
@
text
@/*	$OpenBSD: lm87.c,v 1.19 2007/06/24 05:34:35 dlg Exp $	*/

/*
 * Copyright (c) 2005 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/sensors.h>

#include <dev/i2c/i2cvar.h>

/* LM87 registers */
#define LM87_2_5V	0x20
#define LM87_VCCP1	0x21
#define LM87_VCC	0x22
#define LM87_5V		0x23
#define LM87_12V	0x24
#define LM87_VCCP2	0x25
#define LM87_EXT_TEMP	0x26
#define LM87_INT_TEMP	0x27
#define LM87_FAN1	0x28
#define LM87_FAN2	0x29
#define LM87_REVISION	0x3f
#define LM87_CONFIG1	0x40
#define  LM87_CONFIG1_START	0x01
#define  LM87_CONFIG1_INTCLR	0x08
#define LM87_CHANNEL	0x16
#define  LM87_CHANNEL_AIN1	0x01
#define  LM87_CHANNEL_AIN2	0x02
#define LM87_FANDIV	0x47

/* Sensors */
#define LMENV_2_5V		0
#define LMENV_VCCP1		1
#define LMENV_VCC		2
#define LMENV_5V		3
#define LMENV_12V		4
#define LMENV_VCCP2		5
#define LMENV_EXT_TEMP		6
#define LMENV_INT_TEMP		7
#define LMENV_FAN1		8
#define LMENV_FAN2		9
#define LMENV_NUM_SENSORS	10

struct lmenv_softc {
	struct device sc_dev;
	i2c_tag_t sc_tag;
	i2c_addr_t sc_addr;

	struct ksensor sc_sensor[LMENV_NUM_SENSORS];
	struct ksensordev sc_sensordev;
	int	sc_fan1_div, sc_fan2_div;
	int	sc_family;
};

int	lmenv_match(struct device *, void *, void *);
void	lmenv_attach(struct device *, struct device *, void *);

void	lmenv_refresh(void *);

struct cfattach lmenv_ca = {
	sizeof(struct lmenv_softc), lmenv_match, lmenv_attach
};

struct cfdriver lmenv_cd = {
	NULL, "lmenv", DV_DULL
};

int
lmenv_match(struct device *parent, void *match, void *aux)
{
	struct i2c_attach_args *ia = aux;

	if (strcmp(ia->ia_name, "lm87") == 0 ||
	    strcmp(ia->ia_name, "lm87cimt") == 0 ||
	    strcmp(ia->ia_name, "adm9240") == 0 ||
	    strcmp(ia->ia_name, "lm81") == 0 ||
	    strcmp(ia->ia_name, "ds1780") == 0)
		return (1);
	return (0);
}

void
lmenv_attach(struct device *parent, struct device *self, void *aux)
{
	struct lmenv_softc *sc = (struct lmenv_softc *)self;
	struct i2c_attach_args *ia = aux;
	u_int8_t cmd, data, data2, channel;
	int i;

	sc->sc_tag = ia->ia_tag;
	sc->sc_addr = ia->ia_addr;

	sc->sc_family = 87;
	if (strcmp(ia->ia_name, "lm81") == 0 ||
	    strcmp(ia->ia_name, "adm9240") == 0 ||
	    strcmp(ia->ia_name, "ds1780") == 0)
		sc->sc_family = 81;

	iic_acquire_bus(sc->sc_tag, 0);

	cmd = LM87_REVISION;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(": cannot read ID register\n");
		return;
	}
	printf(": %s rev %x", ia->ia_name, data);

	cmd = LM87_FANDIV;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(", cannot read Fan Divisor register\n");
		return;
	}
	sc->sc_fan1_div = 1 << ((data >> 4) & 0x03);
	sc->sc_fan2_div = 1 << ((data >> 6) & 0x03);

	if (sc->sc_family == 87) {
		cmd = LM87_CHANNEL;
		if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
		    sc->sc_addr, &cmd, sizeof cmd, &channel,
		    sizeof channel, 0)) {
			iic_release_bus(sc->sc_tag, 0);
			printf(", cannot read Channel register\n");
			return;
		}
	} else
		channel = 0;

	cmd = LM87_CONFIG1;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(", cannot read Configuration Register 1\n");
		return;
	}

	/*
	 * if chip is not running, try to start it.
	 * if it is stalled doing an interrupt, unstall it
	 */
	data2 = (data | LM87_CONFIG1_START);
	data2 = data2 & ~LM87_CONFIG1_INTCLR;

	if (data != data2) {
		if (iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
		    sc->sc_addr, &cmd, sizeof cmd, &data2, sizeof data2, 0)) {
			iic_release_bus(sc->sc_tag, 0);
			printf(", cannot write Configuration Register 1\n");
			return;
		}
		printf(", starting scan");
	}
	iic_release_bus(sc->sc_tag, 0);

	/* Initialize sensor data. */
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_sensor[LMENV_2_5V].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[LMENV_2_5V].desc, "+2.5Vin",
	    sizeof(sc->sc_sensor[LMENV_2_5V].desc));

	sc->sc_sensor[LMENV_VCCP1].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[LMENV_VCCP1].desc, "Vccp",
	    sizeof(sc->sc_sensor[LMENV_VCCP1].desc));

	sc->sc_sensor[LMENV_VCC].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[LMENV_VCC].desc, "+Vcc",
	    sizeof(sc->sc_sensor[LMENV_VCC].desc));

	sc->sc_sensor[LMENV_5V].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[LMENV_5V].desc, "+5Vin/Vcc",
	    sizeof(sc->sc_sensor[LMENV_5V].desc));

	sc->sc_sensor[LMENV_12V].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[LMENV_12V].desc, "+12Vin",
	    sizeof(sc->sc_sensor[LMENV_12V].desc));

	sc->sc_sensor[LMENV_VCCP2].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[LMENV_VCCP2].desc, "Vccp",
	    sizeof(sc->sc_sensor[LMENV_VCCP2].desc));

	sc->sc_sensor[LMENV_EXT_TEMP].type = SENSOR_TEMP;
	strlcpy(sc->sc_sensor[LMENV_EXT_TEMP].desc, "External",
	    sizeof(sc->sc_sensor[LMENV_EXT_TEMP].desc));
	if (sc->sc_family == 81)
		sc->sc_sensor[LMENV_EXT_TEMP].flags |= SENSOR_FINVALID;

	sc->sc_sensor[LMENV_INT_TEMP].type = SENSOR_TEMP;
	strlcpy(sc->sc_sensor[LMENV_INT_TEMP].desc, "Internal",
	    sizeof(sc->sc_sensor[LMENV_INT_TEMP].desc));

	if (channel & LM87_CHANNEL_AIN1) {
		sc->sc_sensor[LMENV_FAN1].type = SENSOR_VOLTS_DC;
		strlcpy(sc->sc_sensor[LMENV_FAN1].desc, "AIN1",
		    sizeof(sc->sc_sensor[LMENV_FAN1].desc));
	} else {
		sc->sc_sensor[LMENV_FAN1].type = SENSOR_FANRPM;
	}

	if (channel & LM87_CHANNEL_AIN2) {
		sc->sc_sensor[LMENV_FAN2].type = SENSOR_VOLTS_DC;
		strlcpy(sc->sc_sensor[LMENV_FAN2].desc, "AIN2",
		    sizeof(sc->sc_sensor[LMENV_FAN2].desc));
	} else {
		sc->sc_sensor[LMENV_FAN2].type = SENSOR_FANRPM;
	}

	if (sensor_task_register(sc, lmenv_refresh, 5) == NULL) {
		printf(", unable to register update task\n");
		return;
	}

	for (i = 0; i < LMENV_NUM_SENSORS; i++)
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[i]);
	sensordev_install(&sc->sc_sensordev);

	printf("\n");
}

void
lmenv_refresh(void *arg)
{
	struct lmenv_softc *sc = arg;
	u_int8_t cmd, data;
	u_int tmp;
	int sensor;

	iic_acquire_bus(sc->sc_tag, 0);

	for (sensor = 0; sensor < LMENV_NUM_SENSORS; sensor++) {
		cmd = LM87_2_5V + sensor;
		if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
		    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
			sc->sc_sensor[sensor].flags |= SENSOR_FINVALID;
			continue;
		}

		sc->sc_sensor[sensor].flags &= ~SENSOR_FINVALID;
		switch (sensor) {
		case LMENV_2_5V:
			sc->sc_sensor[sensor].value = 2500000 * data / 192;
			break;
		case LMENV_5V:
			sc->sc_sensor[sensor].value = 5000000 * data / 192;
			break;
		case LMENV_12V:
			sc->sc_sensor[sensor].value = 12000000 * data / 192;
			break;
		case LMENV_VCCP1:
		case LMENV_VCCP2:
			sc->sc_sensor[sensor].value = 2700000 * data / 192;
			break;
		case LMENV_VCC:
			sc->sc_sensor[sensor].value = 3300000 * data / 192;
			break;
		case LMENV_EXT_TEMP:
			if (sc->sc_family == 81) {
				sc->sc_sensor[sensor].flags |= SENSOR_FINVALID;
				break;		/* missing on LM81 */
			}
			/* FALLTHROUGH */
		case LMENV_INT_TEMP:
			if (data == 0x80)
				sc->sc_sensor[sensor].flags |= SENSOR_FINVALID;
			else
				sc->sc_sensor[sensor].value =
				    (int8_t)data * 1000000 + 273150000;
			break;
		case LMENV_FAN1:
			if (sc->sc_sensor[sensor].type == SENSOR_VOLTS_DC) {
				sc->sc_sensor[sensor].value =
				    1870000 * data / 192;
				break;
			}
			tmp = data * sc->sc_fan1_div;
			if (tmp == 0)
				sc->sc_sensor[sensor].flags |= SENSOR_FINVALID;
			else
				sc->sc_sensor[sensor].value = 1350000 / tmp;
			break;
		case LMENV_FAN2:
			if (sc->sc_sensor[sensor].type == SENSOR_VOLTS_DC) {
				sc->sc_sensor[sensor].value =
				    1870000 * data / 192;
				break;
			}
			tmp = data * sc->sc_fan2_div;
			if (tmp == 0)
				sc->sc_sensor[sensor].flags |= SENSOR_FINVALID;
			else
				sc->sc_sensor[sensor].value = 1350000 / tmp;
			break;
		default:
			sc->sc_sensor[sensor].flags |= SENSOR_FINVALID;
			break;
		}
	}

	iic_release_bus(sc->sc_tag, 0);
}
@


1.19
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.18 2007/03/22 16:55:31 deraadt Exp $	*/
d144 2
a145 1
	}
@


1.18
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.17 2006/12/23 17:46:39 deraadt Exp $	*/
d226 1
a226 1
	if (sensor_task_register(sc, lmenv_refresh, 5)) {
@


1.17
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.16 2006/04/09 21:06:33 deraadt Exp $	*/
d64 2
a65 2
	struct sensor sc_sensor[LMENV_NUM_SENSORS];
	struct sensordev sc_sensordev;
@


1.16
log
@slightly nicer sensor names
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.15 2006/01/19 17:08:39 grange Exp $	*/
d65 1
d173 2
a174 3
	for (i = 0; i < LMENV_NUM_SENSORS; i++)
		strlcpy(sc->sc_sensor[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sc_sensor[i].device));
d181 1
a181 1
	strlcpy(sc->sc_sensor[LMENV_VCCP1].desc, "Vccp1",
d197 1
a197 1
	strlcpy(sc->sc_sensor[LMENV_VCCP2].desc, "Vccp2",
d201 1
a201 1
	strlcpy(sc->sc_sensor[LMENV_EXT_TEMP].desc, "External Temp",
d207 1
a207 1
	strlcpy(sc->sc_sensor[LMENV_INT_TEMP].desc, "Internal Temp",
a215 2
		strlcpy(sc->sc_sensor[LMENV_FAN1].desc, "FAN1",
		    sizeof(sc->sc_sensor[LMENV_FAN1].desc));
a223 2
		strlcpy(sc->sc_sensor[LMENV_FAN2].desc, "FAN2",
		    sizeof(sc->sc_sensor[LMENV_FAN2].desc));
d232 2
a233 1
		sensor_add(&sc->sc_sensor[i]);
@


1.15
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.14 2005/12/31 04:31:27 deraadt Exp $	*/
d201 1
a201 1
	strlcpy(sc->sc_sensor[LMENV_EXT_TEMP].desc, "Ext. Temp.",
d207 1
a207 1
	strlcpy(sc->sc_sensor[LMENV_INT_TEMP].desc, "Int. Temp.",
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.13 2005/12/27 20:05:56 deraadt Exp $	*/
d236 1
a236 1
		SENSOR_ADD(&sc->sc_sensor[i]);
@


1.13
log
@interrupt clearing applies to lm87 class too (not just lm81 class)
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.12 2005/12/27 20:05:03 deraadt Exp $	*/
d204 1
a204 1
		sc->sc_sensor[LMENV_EXT_TEMP].flags |= SENSOR_FINVALID;		
@


1.12
log
@if the device is busy trying to deliver an interrupt, it will stall on
scanning. at startup, that is dumb.  clear the interrupt bit.  now i get
40 sensors on the alpha... crazy
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.11 2005/12/27 19:45:28 deraadt Exp $	*/
d158 1
a158 2
	if (sc->sc_family == 81)
		data2 = data2 & ~LM87_CONFIG1_INTCLR;
@


1.11
log
@on lm81 and clones, reflag external sensor as invalid every time through
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.10 2005/12/27 09:23:28 deraadt Exp $	*/
d40 1
d101 1
a101 1
	u_int8_t cmd, data, channel;
d153 9
a161 2
	if ((data & LM87_CONFIG1_START) == 0) {
		data |= LM87_CONFIG1_START;
d163 1
a163 1
		    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
@


1.10
log
@match about 15 more clone chips
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.9 2005/12/27 03:54:27 deraadt Exp $	*/
d136 2
a137 1
		    sc->sc_addr, &cmd, sizeof cmd, &channel, sizeof channel, 0)) {
d271 2
a272 1
			if (sc->sc_family == 81)
d274 1
@


1.9
log
@if we write to the START bit, splat out a message
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.8 2005/12/26 03:52:53 deraadt Exp $	*/
d64 2
a65 1
	int sc_fan1_div, sc_fan2_div;
d86 7
a92 7
	if (ia->ia_name) {
		if (strcmp(ia->ia_name, "lm87") == 0 ||
		    strcmp(ia->ia_name, "lm87cimt") == 0)
			return (1);
		return (0);
	}
	return (1);	/* accept the address given */
d106 6
d121 1
a121 1
	printf(": LM87 rev %x", data);
d133 8
a140 6
	cmd = LM87_CHANNEL;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &channel, sizeof channel, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(", cannot read Channel register\n");
		return;
a160 2


d195 2
d270 3
@


1.8
log
@if start is already set, avoid setting it again
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.7 2005/11/16 23:30:28 kettenis Exp $	*/
d107 9
d120 1
a120 1
		printf(": cannot read Fan Divisor register\n");
d130 1
a130 1
		printf(": cannot read Channel register\n");
d138 1
a138 1
		printf(": cannot read Configuration Register 1\n");
d147 1
a147 1
			printf(": cannot write Configuration Register 1\n");
d150 1
a152 7
	cmd = LM87_REVISION;
	if (iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(": cannot read ID register\n");
		return;
	}
a154 2

	printf(": LM87 rev %x", data);
@


1.7
log
@Fix typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.6 2005/11/15 22:01:36 deraadt Exp $	*/
d133 8
a140 6
	data |= LM87_CONFIG1_START;
	if (iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(": cannot write Configuration Register 1\n");
		return;
@


1.6
log
@read the channel register, hopefully initialized by some rom (Yes, Apple
does in their rom, but not in their kernel code).  This tells us if the
2 AIN/FAN pins are wired as AIN or FAN (G4 xserve fans, G5 xserve more
voltage readings..); ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.5 2005/11/15 20:40:45 deraadt Exp $	*/
d36 1
a36 1
#define LM87_FAN2	0x28
@


1.5
log
@temperature readings of 0x80 mean "diode not connected", i think; kettenis ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.4 2005/11/15 20:28:04 kettenis Exp $	*/
d40 3
d99 1
a99 1
	u_int8_t cmd, data;
d109 1
a109 1
		     sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
d117 8
d127 1
a127 1
		     sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
d132 1
d135 1
a135 1
		     sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
d143 1
a143 1
		     sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
d190 19
a208 7
	sc->sc_sensor[LMENV_FAN1].type = SENSOR_FANRPM;
	strlcpy(sc->sc_sensor[LMENV_FAN1].desc, "FAN1",
	    sizeof(sc->sc_sensor[LMENV_FAN1].desc));

	sc->sc_sensor[LMENV_FAN2].type = SENSOR_FANRPM;
	strlcpy(sc->sc_sensor[LMENV_FAN2].desc, "FAN2",
	    sizeof(sc->sc_sensor[LMENV_FAN2].desc));
d266 5
d278 5
@


1.4
log
@Start monitoring operations such that values actually change.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.3 2005/11/15 18:25:24 deraadt Exp $	*/
d235 5
a239 2
			sc->sc_sensor[sensor].value =
			    (int8_t)data * 1000000 + 273150000;
@


1.3
log
@avoid integer overflow in fan speed calculations, from kettenis
also, if things appear majorly wonky, mark sensors invalid
@
text
@d1 1
a1 1
/*	$OpenBSD: lm87.c,v 1.2 2005/11/14 22:22:32 deraadt Exp $	*/
d38 2
d113 15
@


1.2
log
@instead of passing OF nodes down to the drivers, pass name/compat string
pointers.  This lets their match() functions actually make real decisions.
OF-capable machines will pass name/compat pointers, but other machines
will not.  grudging ok kettenis
@
text
@d109 2
a110 2
	sc->sc_fan1_div = (data >> 4) & 0x03;
	sc->sc_fan2_div = (data >> 6) & 0x03;
d185 1
d198 1
d222 5
a226 2
			sc->sc_sensor[sensor].value =
			    (1350000 * data) / sc->sc_fan1_div;
d229 5
a233 2
			sc->sc_sensor[sensor].value =
			    (1350000 * data) / sc->sc_fan2_div;
d237 1
a237 1
			continue;
a238 1
		sc->sc_sensor[sensor].flags &= ~SENSOR_FINVALID;
@


1.1
log
@move lm87 to dev/i2c; ok kettenis
@
text
@d24 1
a24 2
#include <dev/ofw/openfirm.h>
#include <arch/macppc/dev/maci2cvar.h>
d78 1
a78 2
	struct maci2c_attach_args *ia = aux;
	char compat[32], name[32];
d80 7
a86 11
	memset(compat, 0, sizeof compat);
	OF_getprop(ia->ia_node, "compatible", &compat, sizeof compat);
	if (strcmp(compat, "lm87cimt") == 0)
		return (1);

	memset(name, 0, sizeof name);
	OF_getprop(ia->ia_node, "name", &name, sizeof name);
	if (strcmp(name, "lm87") == 0)
		return (1);

	return (0);
d93 1
a93 1
	struct maci2c_attach_args *ia = aux;
d170 1
a170 1
		printf(": unable to register update task\n");
@

