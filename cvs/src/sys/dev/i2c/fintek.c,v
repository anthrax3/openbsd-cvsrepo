head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.12
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.30
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.28
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.24
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.22
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.20
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.18
	OPENBSD_5_0:1.7.0.16
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.14
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.12
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.8
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.10
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2014.10.12.19.40.22;	author miod;	state Exp;
branches;
next	1.7;
commitid	aJfLvUXCbWm6Rp0W;

1.7
date	2007.10.31.20.46.17;	author cnst;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.24.01.26.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.26.10.42.57;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.15.20.50.44;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Do not compile sensor code if option SMALL_KERNEL
@
text
@/*	$OpenBSD: fintek.c,v 1.7 2007/10/31 20:46:17 cnst Exp $ */
/*
 * Copyright (c) 2006 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/sensors.h>

#include <dev/i2c/i2cvar.h>

/* Sensors */
#define F_VCC	0
#define F_V1	1
#define F_V2	2
#define F_V3	3
#define F_TEMP1	4
#define F_TEMP2	5
#define F_FAN1	6
#define F_FAN2	7
#define F_NUM_SENSORS	8

struct fintek_softc {
	struct device sc_dev;
	i2c_tag_t sc_tag;
	i2c_addr_t sc_addr;

#ifndef SMALL_KERNEL
	struct ksensor sc_sensor[F_NUM_SENSORS];
	struct ksensordev sc_sensordev;
#endif
};

int	fintek_match(struct device *, void *, void *);
void	fintek_attach(struct device *, struct device *, void *);

void	fintek_refresh(void *);
int	fintek_read_reg(struct fintek_softc *sc, u_int8_t cmd, u_int8_t *data,
	    size_t size);
int	fintek_write_reg(struct fintek_softc *sc, u_int8_t cmd, u_int8_t *data,
	    size_t size);
void	fintek_fullspeed(struct fintek_softc *sc);

struct cfattach fintek_ca = {
	sizeof(struct fintek_softc), fintek_match, fintek_attach
};

struct cfdriver fintek_cd = {
	NULL, "fintek", DV_DULL
};

#define FINTEK_CONFIG1		0x01
#define  FINTEK_FAN1_LINEAR_MODE	0x10
#define  FINTEK_FAN2_LINEAR_MODE	0x20
#define FINTEK_VOLT0		0x10
#define FINTEK_VOLT1		0x11
#define FINTEK_VOLT2		0x12
#define FINTEK_VOLT3		0x13
#define FINTEK_TEMP1		0x14
#define FINTEK_TEMP2		0x15
#define FINTEK_FAN1		0x16
#define FINTEK_FAN2		0x18
#define FINTEK_VERSION		0x5c
#define FINTEK_RSTCR		0x60
#define  FINTEK_FAN1_MODE_MANUAL	0x30
#define  FINTEK_FAN2_MODE_MANUAL	0xc0
#define FINTEK_PWM_DUTY1	0x76
#define FINTEK_PWM_DUTY2	0x86

/* Options passed via the 'flags' config keyword. */
#define FINTEK_OPTION_FULLSPEED	0x0001

int
fintek_match(struct device *parent, void *match, void *aux)
{
	struct i2c_attach_args *ia = aux;

	if (strcmp(ia->ia_name, "f75375") == 0)
		return (1);
	return (0);
}

int
fintek_read_reg(struct fintek_softc *sc, u_int8_t cmd, u_int8_t *data,
    size_t size)
{
	return iic_exec(sc->sc_tag, I2C_OP_READ_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, data, size, 0);
}

int
fintek_write_reg(struct fintek_softc *sc, u_int8_t cmd, u_int8_t *data,
    size_t size)
{
	return iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, data, size, 0);
}

void
fintek_attach(struct device *parent, struct device *self, void *aux)
{
	struct fintek_softc *sc = (struct fintek_softc *)self;
	struct i2c_attach_args *ia = aux;
	u_int8_t cmd, data;
#ifndef SMALL_KERNEL
	int i;
#endif

	sc->sc_tag = ia->ia_tag;
	sc->sc_addr = ia->ia_addr;

	iic_acquire_bus(sc->sc_tag, 0);

	cmd = FINTEK_VERSION;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;

	printf(": F75375 rev %d.%d", data>> 4, data & 0xf);

	/*
	 * It seems the fan in the Thecus n2100 doesn't provide a
	 * reliable fan count.  As a result the automatic fan
	 * controlling mode that the chip comes up in after reset
	 * doesn't work reliably.  So we have a flag to drive the fan
	 * at maximum voltage such that the box doesn't overheat.
	 */
	if (sc->sc_dev.dv_cfdata->cf_flags & FINTEK_OPTION_FULLSPEED)
		fintek_fullspeed(sc);

	iic_release_bus(sc->sc_tag, 0);

#ifndef SMALL_KERNEL
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_sensor[F_VCC].type = SENSOR_VOLTS_DC;
	strlcpy(sc->sc_sensor[F_VCC].desc, "Vcc",
	    sizeof(sc->sc_sensor[F_VCC].desc));

	sc->sc_sensor[F_V1].type = SENSOR_VOLTS_DC;
	sc->sc_sensor[F_V2].type = SENSOR_VOLTS_DC;
	sc->sc_sensor[F_V3].type = SENSOR_VOLTS_DC;

	sc->sc_sensor[F_TEMP1].type = SENSOR_TEMP;
	sc->sc_sensor[F_TEMP2].type = SENSOR_TEMP;

	sc->sc_sensor[F_FAN1].type = SENSOR_FANRPM;
	sc->sc_sensor[F_FAN2].type = SENSOR_FANRPM;

	if (sensor_task_register(sc, fintek_refresh, 5) == NULL) {
		printf(", unable to register update task\n");
		return;
	}

	for (i = 0; i < F_NUM_SENSORS; i++)
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[i]);
	sensordev_install(&sc->sc_sensordev);
#endif

	printf("\n");
	return;

failread:
	printf("unable to read reg %d\n", cmd);
	iic_release_bus(sc->sc_tag, 0);
	return;
}


#ifndef SMALL_KERNEL
struct {
	char		sensor;
	u_int8_t	cmd;
} fintek_worklist[] = {
	{ F_VCC, FINTEK_VOLT0 },
	{ F_V1, FINTEK_VOLT1 },
	{ F_V2, FINTEK_VOLT2 },
	{ F_V3, FINTEK_VOLT3 },
	{ F_TEMP1, FINTEK_TEMP1 },
	{ F_TEMP2, FINTEK_TEMP2 },
	{ F_FAN1, FINTEK_FAN1 },
	{ F_FAN2, FINTEK_FAN2 }
};
#define FINTEK_WORKLIST_SZ (sizeof(fintek_worklist) / sizeof(fintek_worklist[0]))

void
fintek_refresh(void *arg)
{
	struct fintek_softc *sc =  arg;
	u_int8_t cmd, data, data2;
	int i;

	iic_acquire_bus(sc->sc_tag, 0);

	for (i = 0; i < FINTEK_WORKLIST_SZ; i++){
		cmd = fintek_worklist[i].cmd;
		if (fintek_read_reg(sc, cmd, &data, sizeof data)) {
			sc->sc_sensor[i].flags |= SENSOR_FINVALID;
			continue;
		}
		sc->sc_sensor[i].flags &= ~SENSOR_FINVALID;
		switch (fintek_worklist[i].sensor) {
		case  F_VCC:
			sc->sc_sensor[i].value = data * 16000;
			break;
		case  F_V1:
			/* FALLTHROUGH */
		case  F_V2:
			/* FALLTHROUGH */
		case  F_V3:
			sc->sc_sensor[i].value = data * 8000;
			break;
		case  F_TEMP1:
			/* FALLTHROUGH */
		case  F_TEMP2:
			sc->sc_sensor[i].value = 273150000 + data * 1000000;
			break;
		case  F_FAN1:
			/* FALLTHROUGH */
		case  F_FAN2:
			/* FANx LSB follows FANx MSB */
			cmd = fintek_worklist[i].cmd + 1;
			if (fintek_read_reg(sc, cmd, &data2, sizeof data2)) {
				sc->sc_sensor[i].flags |= SENSOR_FINVALID;
				continue;
			}
			if ((data == 0xff && data2 == 0xff) ||
			    (data == 0 && data2 == 0))
				sc->sc_sensor[i].value = 0;
			else
				sc->sc_sensor[i].value = 1500000 /
				    (data << 8 | data2);
			break;
		default:
			sc->sc_sensor[i].flags |= SENSOR_FINVALID;
			break;
		}
	}

	iic_release_bus(sc->sc_tag, 0);
}
#endif

void
fintek_fullspeed(struct fintek_softc *sc)
{
	u_int8_t data;

	data = FINTEK_FAN1_LINEAR_MODE | FINTEK_FAN2_LINEAR_MODE;
	fintek_write_reg(sc, FINTEK_CONFIG1, &data, sizeof data);

	data = FINTEK_FAN1_MODE_MANUAL | FINTEK_FAN2_MODE_MANUAL;
	fintek_write_reg(sc, FINTEK_RSTCR, &data, sizeof data);

	data = 0xff;		/* Maximum voltage */
	fintek_write_reg(sc, FINTEK_PWM_DUTY1, &data, sizeof data);
	fintek_write_reg(sc, FINTEK_PWM_DUTY2, &data, sizeof data);
}	
@


1.7
log
@don't clear sensor flags that were never set; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fintek.c,v 1.6 2007/06/24 05:34:35 dlg Exp $ */
d41 1
d44 1
d118 1
d120 1
d145 1
d171 1
d183 1
d255 1
@


1.6
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fintek.c,v 1.5 2007/03/22 16:55:31 deraadt Exp $ */
d163 1
a163 2
	for (i = 0; i < F_NUM_SENSORS; i++) {
		sc->sc_sensor[i].flags &= ~SENSOR_FINVALID;
a164 1
	}
@


1.5
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fintek.c,v 1.4 2006/12/24 01:26:20 deraadt Exp $ */
d158 1
a158 1
	if (sensor_task_register(sc, fintek_refresh, 5)) {
@


1.4
log
@normally hardware engineers call it Vcc not VCC
@
text
@d1 1
a1 1
/*	$OpenBSD: fintek.c,v 1.3 2006/12/23 17:46:39 deraadt Exp $ */
d41 2
a42 2
	struct sensor sc_sensor[F_NUM_SENSORS];
	struct sensordev sc_sensordev;
@


1.3
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: fintek.c,v 1.2 2006/08/26 10:42:57 kettenis Exp $ */
d145 1
a145 1
	strlcpy(sc->sc_sensor[F_VCC].desc, "VCC",
@


1.2
log
@Cleanup.  Add config flag to make fans blast at full speed.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fintek.c,v 1.1 2006/06/15 20:50:44 drahn Exp $ */
d42 1
d141 2
a142 3
	for (i = 0; i < F_NUM_SENSORS; i++)
		strlcpy(sc->sc_sensor[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sc_sensor[i].device));
a148 3
	strlcpy(sc->sc_sensor[F_V1].desc, "Volt1",
	    sizeof(sc->sc_sensor[F_V1].desc));

a149 3
	strlcpy(sc->sc_sensor[F_V2].desc, "Volt2",
	    sizeof(sc->sc_sensor[F_V2].desc));

a150 2
	strlcpy(sc->sc_sensor[F_V3].desc, "Volt3",
	    sizeof(sc->sc_sensor[F_V3].desc));
a152 3
	strlcpy(sc->sc_sensor[F_TEMP1].desc, "Temp1",
	    sizeof(sc->sc_sensor[F_TEMP1].desc));

a153 2
	strlcpy(sc->sc_sensor[F_TEMP2].desc, "Temp2",
	    sizeof(sc->sc_sensor[F_TEMP2].desc));
a155 3
	strlcpy(sc->sc_sensor[F_FAN1].desc, "Fan1",
	    sizeof(sc->sc_sensor[F_FAN1].desc));

a156 2
	strlcpy(sc->sc_sensor[F_FAN2].desc, "Fan2",
	    sizeof(sc->sc_sensor[F_FAN2].desc));
d165 1
a165 1
		sensor_add(&sc->sc_sensor[i]);
d167 1
@


1.1
log
@Fan controller for Thecus N2100, still needs more work, currently sets the
fan so it is running. The nice auto fan speed isn't working currently.
Also gives temperature sensors.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a35 1

a47 1

d52 1
a52 4

void fintek_setspeed(struct fintek_softc *sc);
void fintek_setauto(struct fintek_softc *sc);
void fintek_setpwm(struct fintek_softc *sc);
d62 20
a81 10
#define FINTEK_VOLT0	0x10
#define FINTEK_VOLT1	0x11
#define FINTEK_VOLT2	0x12
#define FINTEK_VOLT3	0x13
#define FINTEK_TEMP1	0x14
#define FINTEK_TEMP2	0x15
#define FINTEK_FAN1	0x16
#define FINTEK_FAN2	0x18
#define FINTEK_VERSION	0x5c
#define FINTEK_RSTCR	0x60
d100 1
d114 1
a114 1
	u_int8_t cmd, data, data2;
a125 1

d128 9
a137 116
	cmd = FINTEK_RSTCR;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
#if 1
	data = 0x81;
	cmd = 0;
	if (fintek_write_reg(sc, cmd, &data, sizeof data))
		goto failwrite;
	if (iic_exec(sc->sc_tag, I2C_OP_WRITE_WITH_STOP,
	    sc->sc_addr, &cmd, sizeof cmd, &data, sizeof data, 0)) {
		iic_release_bus(sc->sc_tag, 0);
		printf(": cannot read ID register\n");
		return;
	}
#endif


#ifdef NOISY_DEBUG
	cmd = 0;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	printf(" conf 0 %x", data);

	cmd = 0x1;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	printf(" conf 1 %x", data);

	cmd = 0x2;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;

	printf(" conf 2 %x", data);
	cmd = 0x3;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	printf(" conf 3 %x\n", data);
	cmd = 0x70;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	cmd = 0x71;
	if (fintek_read_reg(sc, cmd, &data2, sizeof data2))
		goto failread;
	printf(" fan full speed %x %x\n", data, data2);

	cmd = 0xa0;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	printf(" temp 1 b %x\n", data);

	cmd = 0xa1;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	printf(" temp 2 b %x\n", data);

	cmd = 0xa2;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	printf(" temp 3 b %x\n", data);

	cmd = 0xa3;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	printf(" temp 4 b %x\n", data);

	cmd = 0xa4;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	cmd = 0xa5;
	if (fintek_read_reg(sc, cmd, &data2, sizeof data))
		goto failread;
	printf(" sec1speed %x %x\n", data, data2);

	cmd = 0xa6;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	cmd = 0xa7;
	if (fintek_read_reg(sc, cmd, &data2, sizeof data))
		goto failread;
	printf(" sec2speed %x %x\n", data, data2);

	cmd = 0xa8;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	cmd = 0xa9;
	if (fintek_read_reg(sc, cmd, &data2, sizeof data))
		goto failread;
	printf(" sec3speed %x %x\n", data, data2);

	cmd = 0xaa;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	cmd = 0xab;
	if (fintek_read_reg(sc, cmd, &data2, sizeof data))
		goto failread;
	printf(" sec4speed %x %x\n", data, data2);

	cmd = 0xac;
	if (fintek_read_reg(sc, cmd, &data, sizeof data))
		goto failread;
	cmd = 0xad;
	if (fintek_read_reg(sc, cmd, &data2, sizeof data))
		goto failread;
	printf(" sec5speed %x %x\n", data, data2);
#endif

#if 0
	fintek_setpwm(sc);
#endif
#if 0
	fintek_setauto(sc);
#endif
	data2 = data2;
#if 1
	fintek_setspeed(sc);
#endif
d140 1
a140 1
for (i = 0; i < F_NUM_SENSORS; i++)
d149 1
a149 1
	strlcpy(sc->sc_sensor[F_V1].desc, "Volt 1",
d153 1
a153 1
	strlcpy(sc->sc_sensor[F_V2].desc, "Volt 2",
d157 1
a157 1
	strlcpy(sc->sc_sensor[F_V3].desc, "Volt 3",
d161 1
a161 1
	strlcpy(sc->sc_sensor[F_TEMP1].desc, "Temp 1",
d165 1
a165 1
	strlcpy(sc->sc_sensor[F_TEMP2].desc, "Temp 2",
d169 1
a169 1
	strlcpy(sc->sc_sensor[F_FAN1].desc, "FAN1",
d173 1
a173 1
	strlcpy(sc->sc_sensor[F_FAN2].desc, "FAN1",
d185 2
a192 5
#if 1
failwrite:
	printf("unable to write reg %d\n", cmd);
	iic_release_bus(sc->sc_tag, 0);
#endif
d209 1
a209 1
#define FINTEK_WORKLIST_SZ (sizeof fintek_worklist/sizeof(fintek_worklist[0]))
d229 2
a230 1
			/* FALLTHROUGH */
d236 1
a236 1
			sc->sc_sensor[i].value = 1000 * (data*8);
d241 1
a241 1
			sc->sc_sensor[i].value = 273150000 + 1000000 * (data);
d246 1
a246 1
			/* FANxLSB follows FANxMSB */
a251 2
//			printf("fan speed %x: %x %x\n", fintek_worklist[i].cmd,
//			    data, data2);
d256 1
a256 1
				sc->sc_sensor[i].value = 1500000/
a257 33
			{
				extern long hostid;
				static long currentspeed;
				int i;
				if (currentspeed != hostid) {
					currentspeed = hostid;
					printf("setting speed to %d\n", hostid);
 
#if 0
					data = hostid & 0xff;
					cmd = 0x76;
					fintek_write_reg(sc, cmd, &data,
					    sizeof data);
#else
					cmd = 0x6d;
					fintek_read_reg(sc, cmd, &data,
					    sizeof data);
					printf("reg 6d contains %x setting to 0x11\n", data);
					fintek_write_reg(sc, cmd, &data,
					    sizeof data);
					i = hostid ; /* desired value */
					cmd = 0x74;
					data = i >> 8;
					fintek_write_reg(sc, cmd, &data,
					    sizeof data);

					cmd = 0x75;
					data = i & 0xff;
					fintek_write_reg(sc, cmd, &data,
					    sizeof data);
#endif
				}
			}
d267 1
d269 1
a269 1
fintek_setspeed(struct fintek_softc *sc)
d271 1
a271 2
	u_int8_t cmd, data;
	int i;
d273 2
a274 2
	cmd = 0x1;
	fintek_read_reg(sc, cmd, &data, sizeof data);
d276 2
a277 2
	data |= (1<<4);
	fintek_write_reg(sc, cmd, &data, sizeof data);
d279 3
a281 17
	i = 300; /* desired speed */
	i = 1500000/i;
	cmd = 0x74;
	data = i >> 8;
	fintek_write_reg(sc, cmd, &data, sizeof data);

	cmd = 0x75;
	data = i & 0xff;
	fintek_write_reg(sc, cmd, &data, sizeof data);

	cmd = 0x60;
	fintek_read_reg(sc, cmd, &data, sizeof data);

	data &= ~(0x1 << 4);
	data |= (0x2 << 4); /* manual */
	fintek_write_reg(sc, cmd, &data, sizeof data);
	printf("\n");
a282 95

void
fintek_setauto(struct fintek_softc *sc)
{
	u_int8_t cmd, data, data2;
	int i;

	i = 2000; /* desired speed */
	i = 1500000/i;
	data2 = i >> 8;
	data = i & 0xff;

	cmd = 0xa4;
	fintek_write_reg(sc, cmd, &data, sizeof data);
	fintek_write_reg(sc, cmd, &data2, sizeof data2);
	
	i = 0x3A98;
	data2 = i >> 8;
	data = i & 0xff;
	cmd = 0xa6;
	fintek_write_reg(sc, cmd, &data, sizeof data);

	cmd = 0xa7;
	fintek_write_reg(sc, cmd, &data2, sizeof data2);

	i = 0x3A98;
	data2 = i >> 8;
	data = i & 0xff;
	cmd = 0xa8;
	fintek_write_reg(sc, cmd, &data, sizeof data);

	cmd = 0xa9;
	fintek_write_reg(sc, cmd, &data2, sizeof data2);

	i = 0x3A98;
	data2 = i >> 8;
	data = i & 0xff;
	cmd = 0xaa;
	fintek_write_reg(sc, cmd, &data, sizeof data);

	cmd = 0xab;
	fintek_write_reg(sc, cmd, &data2, sizeof data2);

	i = 0x3A98;
	data2 = i >> 8;
	data = i & 0xff;
	cmd = 0xac;
	fintek_write_reg(sc, cmd, &data, sizeof data);

	cmd = 0xad;
	fintek_write_reg(sc, cmd, &data2, sizeof data2);

	cmd = 0x74;
	fintek_read_reg(sc, cmd, &data, sizeof data);

	cmd = 0x75;
	fintek_read_reg(sc, cmd, &data2, sizeof data);

	printf("fan speed %x %x\n", data,  data2);

	cmd = 0x60;
	fintek_read_reg(sc, cmd, &data, sizeof data);

	data &= ~(0x3 << 4);
	data |= (1 << 4);
	fintek_write_reg(sc, cmd, &data, sizeof data);
	
	printf("\n");

}
void
fintek_setpwm(struct fintek_softc *sc)
{
	u_int8_t cmd, data;

	cmd = 0x01;
	fintek_read_reg(sc, cmd, &data, sizeof data);
	data |= 1<<4;
	fintek_write_reg(sc, cmd, &data, sizeof data);

	cmd = 0x60;
	fintek_read_reg(sc, cmd, &data, sizeof data);

	data |= 0x3 << 4;

	fintek_write_reg(sc, cmd, &data, sizeof data);


	data = 0x28;
	cmd = 0x76;
	fintek_write_reg(sc, cmd, &data, sizeof data);
	
	printf("\n");

}
@

