head	1.28;
access;
symbols
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.8
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.4
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.32
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.30
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.26
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.24
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.22
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.20
	OPENBSD_5_0:1.18.0.18
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.16
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.14
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.10
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.12
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.8
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.6
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10;
locks; strict;
comment	@ * @;


1.28
date	2016.02.05.06.29.01;	author uebayasi;	state Exp;
branches;
next	1.27;
commitid	3lmLbhQAi8VhAKnD;

1.27
date	2016.01.12.10.44.32;	author uebayasi;	state Exp;
branches;
next	1.26;
commitid	2n94FarOmfpYyZNn;

1.26
date	2016.01.12.09.11.59;	author uebayasi;	state Exp;
branches;
next	1.25;
commitid	KX10fciyr0aVdFSx;

1.25
date	2016.01.11.14.39.23;	author uebayasi;	state Exp;
branches;
next	1.24;
commitid	Pwwmqwezym0OWqQW;

1.24
date	2016.01.11.14.29.40;	author uebayasi;	state Exp;
branches;
next	1.23;
commitid	Ki9TLE760hOsqGMk;

1.23
date	2016.01.11.14.08.58;	author uebayasi;	state Exp;
branches;
next	1.22;
commitid	wmThPxam6wsHRBpQ;

1.22
date	2016.01.11.13.12.50;	author uebayasi;	state Exp;
branches;
next	1.21;
commitid	tfMWiMZi9tyVx3x0;

1.21
date	2016.01.11.12.54.33;	author uebayasi;	state Exp;
branches;
next	1.20;
commitid	UVFzOm2R2VL1xXiZ;

1.20
date	2016.01.10.14.17.00;	author uebayasi;	state Exp;
branches;
next	1.19;
commitid	axdSZ8EnQF3lprlw;

1.19
date	2015.01.07.07.49.18;	author yasuoka;	state Exp;
branches;
next	1.18;
commitid	lvEE3wJ0kXDyefaX;

1.18
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.28.20.46.12;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.21.20.55.26;	author alek;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.15.00.50.57;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.15.00.46.55;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.08.22.51.18;	author gwk;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.06.15.05.19;	author wilfried;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.05.21.28.29;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.04.23.07.02;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.16.03.16.47;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.28.23.47.42;	author jordan;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.10.11.20.00;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.19.23.45.04;	author jordan;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.19.23.35.53;	author jordan;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.18.23.08.23;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.04.22.04.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.04.21.59.41;	author marco;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Implement FreeBSD-compatible IOCTL to access BMC in ipmi(4)

Initial help & testing by jmatthew@@
Code review & input by mpi@@
Final review & OK by jsg@@
@
text
@/* $OpenBSD: ipmivar.h,v 1.27 2016/01/12 10:44:32 uebayasi Exp $ */

/*
 * Copyright (c) 2005 Jordan Hargrave
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _IPMIVAR_H_
#define _IPMIVAR_H_

#include <sys/rwlock.h>
#include <sys/sensors.h>
#include <sys/task.h>

#include <dev/ipmi.h>

#define IPMI_IF_KCS		1
#define IPMI_IF_SMIC		2
#define IPMI_IF_BT		3

#define IPMI_IF_KCS_NREGS	2
#define IPMI_IF_SMIC_NREGS	3
#define IPMI_IF_BT_NREGS	3

struct ipmi_thread;
struct ipmi_softc;
struct ipmi_cmd;

struct ipmi_iowait {
	int			offset;
	u_int8_t		mask;
	u_int8_t		value;
	volatile u_int8_t	*v;
	const char		*lbl;
};

struct ipmi_attach_args {
	char		*iaa_name;
	bus_space_tag_t	iaa_iot;
	bus_space_tag_t	iaa_memt;

	int		iaa_if_type;
	int		iaa_if_rev;
	int		iaa_if_iotype;
	int		iaa_if_iobase;
	int		iaa_if_iospacing;
	int		iaa_if_irq;
	int		iaa_if_irqlvl;
};

struct ipmi_if {
	const char	*name;
	int		nregs;
	void		(*buildmsg)(struct ipmi_cmd *);
	int		(*sendmsg)(struct ipmi_cmd *);
	int		(*recvmsg)(struct ipmi_cmd *);
	int		(*reset)(struct ipmi_softc *);
	int		(*probe)(struct ipmi_softc *);
	int		datasnd;
	int		datarcv;
};

struct ipmi_cmd {
	struct ipmi_softc	*c_sc;

	int			c_rssa;
	int			c_rslun;
	int			c_netfn;
	int			c_cmd;

	int			c_txlen;
	int			c_maxrxlen;
	int			c_rxlen;

	void			*c_data;
	u_int			c_ccode;
};

struct ipmi_softc {
	struct device		sc_dev;

	struct ipmi_if		*sc_if;			/* Interface layer */
	int			sc_if_iospacing;	/* Spacing of I/O ports */
	int			sc_if_rev;		/* IPMI Revision */

	void			*sc_ih;			/* Interrupt/IO handles */
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	int			sc_btseq;
	u_int8_t		sc_buf[IPMI_MAX_RX + 16];
	struct taskq		*sc_cmd_taskq;
	struct mutex		sc_cmd_mtx;

	struct ipmi_ioctl {
		struct rwlock		lock;
		struct ipmi_req		req;
		struct ipmi_cmd		cmd;
		uint8_t			buf[IPMI_MAX_RX];
	} sc_ioctl;

	int			sc_wdog_period;
	struct task		sc_wdog_tickle_task;

	struct ipmi_thread	*sc_thread;

	struct ipmi_sensor	*current_sensor;
	struct ksensordev	sc_sensordev;
};

struct ipmi_thread {
	struct ipmi_softc   *sc;
	volatile int	    running;
};

#define IPMI_WDOG_DONTSTOP	0x40

#define IPMI_WDOG_MASK		0x03
#define IPMI_WDOG_DISABLED	0x00
#define IPMI_WDOG_REBOOT	0x01
#define IPMI_WDOG_PWROFF	0x02
#define IPMI_WDOG_PWRCYCLE	0x03

#define IPMI_WDOG_PRE_DISABLED	0x00
#define IPMI_WDOG_PRE_SMI	0x01
#define IPMI_WDOG_PRE_NMI	0x02
#define IPMI_WDOG_PRE_INTERRUPT	0x03

#define	IPMI_SET_WDOG_TIMER	0
#define	IPMI_SET_WDOG_ACTION	1
#define	IPMI_SET_WDOG_PRETIMO	2
#define	IPMI_SET_WDOG_FLAGS	3
#define	IPMI_SET_WDOG_TIMOL	4
#define	IPMI_SET_WDOG_TIMOM	5
#define	IPMI_SET_WDOG_MAX	6

#define	IPMI_GET_WDOG_TIMER	IPMI_SET_WDOG_TIMER
#define	IPMI_GET_WDOG_ACTION	IPMI_SET_WDOG_ACTION
#define	IPMI_GET_WDOG_PRETIMO	IPMI_SET_WDOG_PRETIMO
#define	IPMI_GET_WDOG_FLAGS	IPMI_SET_WDOG_FLAGS
#define	IPMI_GET_WDOG_TIMOL	IPMI_SET_WDOG_TIMOL
#define	IPMI_GET_WDOG_TIMOM	IPMI_SET_WDOG_TIMOM
#define	IPMI_GET_WDOG_PRECDL	6
#define	IPMI_GET_WDOG_PRECDM	7
#define	IPMI_GET_WDOG_MAX	8

void	ipmi_create_thread(void *);
void	ipmi_poll_thread(void *);

int	kcs_probe(struct ipmi_softc *);
int	kcs_reset(struct ipmi_softc *);
int	kcs_sendmsg(struct ipmi_cmd *);
int	kcs_recvmsg(struct ipmi_cmd *);

int	bt_probe(struct ipmi_softc *);
int	bt_reset(struct ipmi_softc *);
int	bt_sendmsg(struct ipmi_cmd *);
int	bt_recvmsg(struct ipmi_cmd *);

int	smic_probe(struct ipmi_softc *);
int	smic_reset(struct ipmi_softc *);
int	smic_sendmsg(struct ipmi_cmd *);
int	smic_recvmsg(struct ipmi_cmd *);

struct dmd_ipmi {
	u_int8_t	dmd_sig[4];		/* Signature 'IPMI' */
	u_int8_t	dmd_i2c_address;	/* Address of BMC */
	u_int8_t	dmd_nvram_address;	/* Address of NVRAM */
	u_int8_t	dmd_if_type;		/* IPMI Interface Type */
	u_int8_t	dmd_if_rev;		/* IPMI Interface Revision */
} __packed;


#define APP_NETFN			0x06
#define APP_GET_DEVICE_ID		0x01
#define APP_RESET_WATCHDOG		0x22
#define APP_SET_WATCHDOG_TIMER		0x24
#define APP_GET_WATCHDOG_TIMER		0x25

#define TRANSPORT_NETFN			0xC
#define BRIDGE_NETFN			0x2

#define STORAGE_NETFN			0x0A
#define STORAGE_GET_FRU_INV_AREA	0x10
#define STORAGE_READ_FRU_DATA		0x11
#define STORAGE_RESERVE_SDR		0x22
#define STORAGE_GET_SDR			0x23
#define STORAGE_ADD_SDR			0x24
#define STORAGE_ADD_PARTIAL_SDR		0x25
#define STORAGE_DELETE_SDR		0x26
#define STORAGE_RESERVE_SEL		0x42
#define STORAGE_GET_SEL			0x43
#define STORAGE_ADD_SEL			0x44
#define STORAGE_ADD_PARTIAL_SEL		0x45
#define STORAGE_DELETE_SEL		0x46

#define SE_NETFN			0x04
#define SE_GET_SDR_INFO			0x20
#define SE_GET_SDR			0x21
#define SE_RESERVE_SDR			0x22
#define SE_GET_SENSOR_FACTOR		0x23
#define SE_SET_SENSOR_HYSTERESIS	0x24
#define SE_GET_SENSOR_HYSTERESIS	0x25
#define SE_SET_SENSOR_THRESHOLD		0x26
#define SE_GET_SENSOR_THRESHOLD		0x27
#define SE_SET_SENSOR_EVENT_ENABLE	0x28
#define SE_GET_SENSOR_EVENT_ENABLE	0x29
#define SE_REARM_SENSOR_EVENTS		0x2A
#define SE_GET_SENSOR_EVENT_STATUS	0x2B
#define SE_GET_SENSOR_READING		0x2D
#define SE_SET_SENSOR_TYPE		0x2E
#define SE_GET_SENSOR_TYPE		0x2F

struct sdrhdr {
	u_int16_t	record_id;		/* SDR Record ID */
	u_int8_t	sdr_version;		/* SDR Version */
	u_int8_t	record_type;		/* SDR Record Type */
	u_int8_t	record_length;		/* SDR Record Length */
} __packed;

/* SDR: Record Type 1 */
struct sdrtype1 {
	struct sdrhdr	sdrhdr;

	u_int8_t	owner_id;
	u_int8_t	owner_lun;
	u_int8_t	sensor_num;

	u_int8_t	entity_id;
	u_int8_t	entity_instance;
	u_int8_t	sensor_init;
	u_int8_t	sensor_caps;
	u_int8_t	sensor_type;
	u_int8_t	event_code;
	u_int16_t	trigger_mask;
	u_int16_t	reading_mask;
	u_int16_t	settable_mask;
	u_int8_t	units1;
	u_int8_t	units2;
	u_int8_t	units3;
	u_int8_t	linear;
	u_int8_t	m;
	u_int8_t	m_tolerance;
	u_int8_t	b;
	u_int8_t	b_accuracy;
	u_int8_t	accuracyexp;
	u_int8_t	rbexp;
	u_int8_t	analogchars;
	u_int8_t	nominalreading;
	u_int8_t	normalmax;
	u_int8_t	normalmin;
	u_int8_t	sensormax;
	u_int8_t	sensormin;
	u_int8_t	uppernr;
	u_int8_t	upperc;
	u_int8_t	uppernc;
	u_int8_t	lowernr;
	u_int8_t	lowerc;
	u_int8_t	lowernc;
	u_int8_t	physt;
	u_int8_t	nhyst;
	u_int8_t	resvd[2];
	u_int8_t	oem;
	u_int8_t	typelen;
	u_int8_t	name[1];
} __packed;

/* SDR: Record Type 2 */
struct sdrtype2 {
	struct sdrhdr	sdrhdr;

	u_int8_t	owner_id;
	u_int8_t	owner_lun;
	u_int8_t	sensor_num;

	u_int8_t	entity_id;
	u_int8_t	entity_instance;
	u_int8_t	sensor_init;
	u_int8_t	sensor_caps;
	u_int8_t	sensor_type;
	u_int8_t	event_code;
	u_int16_t	trigger_mask;
	u_int16_t	reading_mask;
	u_int16_t	set_mask;
	u_int8_t	units1;
	u_int8_t	units2;
	u_int8_t	units3;
	u_int8_t	share1;
	u_int8_t	share2;
	u_int8_t	physt;
	u_int8_t	nhyst;
	u_int8_t	resvd[3];
	u_int8_t	oem;
	u_int8_t	typelen;
	u_int8_t	name[1];
} __packed;

int ipmi_probe(void *);

#endif				/* _IPMIVAR_H_ */
@


1.27
log
@Use task to execute command except polling context.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a32 1
#include <sys/timeout.h>
d37 2
a46 2
#define	IPMI_MAX_RX		1024	/* XXX ipmi_linux.h */

d51 1
a51 1
struct ipmi_bmc_args{
d56 1
a113 1
	struct ipmi_cmd		*sc_cmd;
d117 7
a127 9

	struct timeout		sc_timeout;
	int			sc_max_retries;
	int			sc_retries;
	int			sc_wakeup;

	struct rwlock		sc_lock;

	struct ipmi_bmc_args	*sc_iowait_args;
@


1.26
log
@Use task to execute watchdog tickle.
@
text
@d115 2
@


1.25
log
@Make sendmsg() and recvmsg() functions take only struct ipmi_cmd *.
Handle interface specific command length more nicely.  No functional
changes.
@
text
@d36 1
d117 1
@


1.24
log
@Allocate command data buffer on softc and use it from both ipmi_sendcmd()
and ipmi_recvcmd().  No functional changes.
@
text
@d76 2
a77 2
	int		(*sendmsg)(struct ipmi_softc *, int, const u_int8_t *);
	int		(*recvmsg)(struct ipmi_softc *, int, int *, u_int8_t *);
d80 2
d173 2
a174 2
int	kcs_sendmsg(struct ipmi_softc *, int, const u_int8_t *);
int	kcs_recvmsg(struct ipmi_softc *, int, int *len, u_int8_t *);
d178 2
a179 2
int	bt_sendmsg(struct ipmi_softc *, int, const u_int8_t *);
int	bt_recvmsg(struct ipmi_softc *, int, int *, u_int8_t *);
d183 2
a184 2
int	smic_sendmsg(struct ipmi_softc *, int, const u_int8_t *);
int	smic_recvmsg(struct ipmi_softc *, int, int *, u_int8_t *);
@


1.23
log
@Refactor buildmsg() functions to take struct ipmi_cmd * instead of 6
arguments.  No functional changes.
@
text
@d45 2
d75 1
a75 1
	void		*(*buildmsg)(struct ipmi_cmd *);
d110 1
@


1.22
log
@Introduce struct ipmi_cmd and have ipmi_cmd() function.  IPMI command
sequence is always a pair of send and receive; call both from ipmi_cmd().
By making ipmi_cmd() take only one argument struct ipmi_cmd *, this also
helps to prepare to call ipmi_cmd() as a task.

No functional changes intended.
@
text
@d47 1
d73 1
a73 2
	void		*(*buildmsg)(struct ipmi_softc *, int, int, int,
			    const void *, int *);
@


1.21
log
@Remove useless sc_poll flag because it is always 1.  Remove unused global
ipmi_poll too.
@
text
@d80 16
d108 1
@


1.20
log
@When stopping wdog (via wdog_shutdown() e.g. before entering shutdown),
clear DONTSTOP bits.  Without this, BMC records, at least on some NEC
servers, watchdog timer expiration event, which only confuses admins.

OK kettenis@@
@
text
@a107 2

	int			sc_poll;
@


1.19
log
@Fix impi(4) to make watchdog work and not to panic.

diff from uebayasi jsg
ok uebayasi
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.18 2007/03/22 16:55:31 deraadt Exp $ */
d116 2
@


1.18
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.17 2006/12/23 17:46:39 deraadt Exp $ */
d108 2
d128 17
a144 7
struct ipmi_watchdog {
	u_int8_t		wdog_timer;
	u_int8_t		wdog_action;
	u_int8_t		wdog_pretimeout;
	u_int8_t		wdog_flags;
	u_int16_t		wdog_timeout;
} __packed;
@


1.17
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.16 2006/07/28 20:46:12 marco Exp $ */
d107 1
a107 1
	struct sensordev	sc_sensordev;
@


1.16
log
@Only read 1 sensor at a time instead of all of them.  This should help
systems that have a burst of activity every 10 seconds.

Also lower the polling frequency from 10 to 5 seconds.

ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.15 2006/05/21 20:55:26 alek Exp $ */
d35 1
d107 1
@


1.15
log
@Replace lockmgr with rwlock; help and ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.14 2006/05/15 00:50:57 marco Exp $ */
d104 2
@


1.14
log
@Kill evil spacing.
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.13 2006/05/15 00:46:55 marco Exp $ */
d34 1
d101 1
a101 1
	struct lock		sc_lock;
@


1.13
log
@Make _bmc_io_wait 1 second instead of 500ms.
Prevent multiple reads and writes to the bmc at the same time which could
interrupt a complete bmc transaction.

tested by various people.
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.12 2006/05/08 22:51:18 gwk Exp $ */
d79 1
a79 1
	struct device	    sc_dev;
d81 3
a83 3
	struct ipmi_if	    *sc_if;		/* Interface layer */
	int		    sc_if_iospacing;	/* Spacing of I/O ports */
	int		    sc_if_rev;		/* IPMI Revision */
d85 3
a87 3
	void		    *sc_ih;		/* Interrupt/IO handles */
	bus_space_tag_t	    sc_iot;
	bus_space_handle_t  sc_ioh;
d89 1
a89 1
	int		    sc_btseq;
d91 1
a91 1
	int		    sc_wdog_period;
d93 1
a93 1
	struct ipmi_thread  *sc_thread;
d95 4
a98 4
	struct timeout      sc_timeout;
	int                 sc_max_retries;
	int                 sc_retries;
	int                 sc_wakeup;
d100 1
a100 1
	struct lock         sc_lock;
d102 1
a102 1
	struct ipmi_bmc_args *sc_iowait_args;
d110 10
a119 10
#define IPMI_WDOG_MASK          0x03
#define IPMI_WDOG_DISABLED      0x00
#define IPMI_WDOG_REBOOT        0x01
#define IPMI_WDOG_PWROFF        0x02
#define IPMI_WDOG_PWRCYCLE      0x03

#define IPMI_WDOG_PRE_DISABLED  0x00
#define IPMI_WDOG_PRE_SMI       0x01
#define IPMI_WDOG_PRE_NMI       0x02
#define IPMI_WDOG_PRE_INTERRUPT 0x03
@


1.12
log
@Add smbios support for i386 and amd64, fix ipmi to use this new functionallity,
hook up some sysctls to add system vendor/product/version and UUID reporting.

"get it in" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.11 2006/05/06 15:05:19 wilfried Exp $ */
d99 2
@


1.11
log
@remove a block of duplicated defines, ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.10 2006/01/05 21:28:29 marco Exp $ */
a143 49

#define SMBIOS_TYPE_IPMI		0x26
#define SMBIOS_TYPE_END			0x7F

struct smbiosanchor {
	u_int8_t	smr_smtag[4];		/* Signature '_SM_' */
	u_int8_t	smr_ep_cksum;		/* Chcksum Entry Point struct */
	u_int8_t	smr_length;		/* Length of Anchor structure */
	u_int8_t	smr_smbios_majver;	/* SMBIOS Major Version */
	u_int8_t	smr_smbios_minver;	/* SMBIOS Minor Version */
	u_int16_t	smr_maxsize;		/* Max size of SMHDR entry */
	u_int8_t	smr_eprev;		/* SMBIOS Entry Revision (00) */
	u_int8_t	smr_format[5];		/* Should be Zero */
	u_int8_t	smr_dmitag[5];		/* Signature '_DMI_' */
	u_int8_t	smr_iep_cksum;		/* Chcksum of Intermediate Entry
						 * Point * structure */
	u_int16_t	smr_table_length;	/* Length of SMBIOS Table */
	u_int32_t	smr_table_address;	/* Phys addr of SMBIOS Table */
	u_int16_t	smr_count;		/* # of entries in SMBIOS Tbl */
	u_int8_t	smr_bcdrev;		/* BCD SMBIOS Revision */
} __packed;

struct smhdr {
	u_int8_t	smh_type;		/* SMBIOS Header Type */
	u_int8_t	smh_length;		/* SMBIOS Header Length */
	u_int16_t	smh_handle;		/* SMBIOS Header Handle */
} __packed;

struct smbios_ipmi {
	u_int8_t	smipmi_if_type;		/* IPMI Interface Type */
	u_int8_t	smipmi_if_rev;		/* BCD IPMI Revision */
	u_int8_t	smipmi_i2c_address;	/* I2C address of BMC */
	u_int8_t	smipmi_nvram_address;	/* I2C address of NVRAM
						 * storage */
	u_int64_t	smipmi_base_address;	/* Base address of BMC (BAR
						 * format) */
	u_int8_t	smipmi_base_flags;	/* Flags field:
						 * bit 7:6 : register spacing
						 *   00 = byte
						 *   01 = dword
						 *   02 = word
						 * bit 4 : Lower bit BAR
						 * bit 3 : IRQ valid
						 * bit 2 : N/A
						 * bit 1 : Interrupt polarity
						 * bit 0 : Interrupt trigger
						 */
	u_int8_t	smipmi_irq;		/* IRQ if applicable */
} __packed;
@


1.10
log
@Kill all typedef struct goo.
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.9 2006/01/04 23:07:02 marco Exp $ */
a201 39

#define APP_NETFN			0x06
#define APP_GET_DEVICE_ID		0x01
#define APP_RESET_WATCHDOG		0x22
#define APP_SET_WATCHDOG_TIMER		0x24
#define APP_GET_WATCHDOG_TIMER		0x25

#define TRANSPORT_NETFN			0xC
#define BRIDGE_NETFN			0x2

#define STORAGE_NETFN			0x0A
#define STORAGE_RESERVE_SDR		0x22
#define STORAGE_GET_SDR			0x23
#define STORAGE_ADD_SDR			0x24
#define STORAGE_ADD_PARTIAL_SDR		0x25
#define STORAGE_DELETE_SDR		0x26
#define STORAGE_RESERVE_SEL		0x42
#define STORAGE_GET_SEL			0x43
#define STORAGE_ADD_SEL			0x44
#define STORAGE_ADD_PARTIAL_SEL		0x45
#define STORAGE_DELETE_SEL		0x46
#define STORAGE_CLEAR_SEL		0x47

#define SE_NETFN			0x04
#define SE_GET_SDR_INFO			0x20
#define SE_GET_SDR			0x21
#define SE_RESERVE_SDR			0x22
#define SE_GET_SENSOR_FACTOR		0x23
#define SE_SET_SENSOR_HYSTERESIS	0x24
#define SE_GET_SENSOR_HYSTERESIS	0x25
#define SE_SET_SENSOR_THRESHOLD		0x26
#define SE_GET_SENSOR_THRESHOLD		0x27
#define SE_SET_SENSOR_EVENT_ENABLE	0x28
#define SE_GET_SENSOR_EVENT_ENABLE	0x29
#define SE_REARM_SENSOR_EVENTS		0x2A
#define SE_GET_SENSOR_EVENT_STATUS	0x2B
#define SE_GET_SENSOR_READING		0x2D
#define SE_SET_SENSOR_TYPE		0x2E
#define SE_GET_SENSOR_TYPE		0x2F
@


1.9
log
@Make bitfields readable. ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.8 2005/12/16 03:16:47 marco Exp $ */
d148 1
a148 1
typedef struct {
d164 1
a164 1
} __packed smbiosanchor_t;
d166 1
a166 1
typedef struct {
d170 1
a170 1
} smhdr_t;
d172 1
a172 1
typedef struct {
d192 1
a192 1
} __packed smbios_ipmi_t;
d194 1
a194 1
typedef struct {
d200 1
a200 1
} __packed dmd_ipmi_t;
d282 1
a282 1
typedef struct {
d287 1
a287 1
} __packed sdrhdr_t;
d290 2
a291 2
typedef struct {
	sdrhdr_t	sdrhdr;
d334 1
a334 1
} __packed sdrtype1;
d337 2
a338 2
typedef struct {
	sdrhdr_t	sdrhdr;
d364 1
a364 1
} __packed sdrtype2;
@


1.8
log
@Fix 2 issues reported by beck.

1. Sun v20z rebooted dunring autoconf.  This was due to reading a byte and
   discarding it at an inapropriate time.
2. The Sun is so fast that it could exhaust the busy counter.  This has been
   replaced with a timeout/tsleep mechanism that is more predictable.  As
   a bonus we no longer busy wait in ipmi which should improve overall
   throughput.

ok beck@@ jordan@@ dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.7 2005/11/28 23:47:42 jordan Exp $ */
d181 10
a190 9
						 * spacing/lsb/irq bit 7:6 :
						 * register spacing 00 = byte
						 * alignment 01 = dword
						 * alignment 02 = word
						 * alignment bit 4 : Lower bit
						 * of base address bit 3 : IRQ
						 * valid bit 1 : Interrupt
						 * polarity bit 0 : Interrupt
						 * trigger mode */
@


1.7
log
@Added ipmi watchdog code, based on esm watchdog code by dlg@@
Added signextend function to cleanup conversion routine
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.6 2005/11/10 11:20:00 dlg Exp $ */
d33 2
d46 7
d94 7
@


1.6
log
@__attribute__((packed)) is a gccism. use __packed instead which will be
expanded to the directive appropriate to the current compiler.
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.5 2005/10/19 23:45:04 jordan Exp $ */
d82 2
d91 19
@


1.5
log
@KNF fixes
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.4 2005/10/19 23:35:53 jordan Exp $ */
d127 1
a127 1
} __attribute__((packed)) smbiosanchor_t;
d154 1
a154 1
}__attribute__((packed)) smbios_ipmi_t;
d162 1
a162 1
}__attribute__((packed)) dmd_ipmi_t;
d249 1
a249 1
}__attribute__((packed)) sdrhdr_t;
d296 1
a296 1
} __attribute__((packed)) sdrtype1;
d326 1
a326 1
} __attribute__((packed)) sdrtype2;
@


1.4
log
@Oops.. part of ipmi_thread fixes
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.3 2005/10/18 23:08:23 marco Exp $ */
d77 1
a77 1
	bus_space_tag_t     sc_iot;
d87 1
a87 1
	volatile int        running;
d90 2
a91 2
void    ipmi_create_thread(void *);
void    ipmi_poll_thread(void *);
@


1.3
log
@Scan SMBIOS before calling config_attach() to prevent unnecessary kernel print.

Written with jordan@@ help.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.2 2005/10/04 22:04:25 deraadt Exp $ */
d41 1
d70 1
a70 1
	struct device	sc_dev;
d72 3
a74 3
	struct ipmi_if	*sc_if;			/* Interface layer */
	int		sc_if_iospacing;	/* Spacing of I/O ports */
	int		sc_if_rev;		/* IPMI Revision */
d76 3
a78 3
	void		*sc_ih;			/* Interrupt/IO handles */
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
d80 8
a87 1
	int		sc_btseq;
d89 3
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: ipmivar.h,v 1.1 2005/10/04 21:59:41 marco Exp $ */
d316 2
@


1.1
log
@Add initial IPMI implementation.  Currently only the KCS retrieval method is
supported.  SMIC and BMC are being worked on.  IPMI will remain disabled for
now.

Code written by Jordan Hargrave <jordan underscore hargrave at hotmail dot com>

help grange@@ and deraadt@@
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d129 1
a129 1
					 	 * storage */
d131 1
a131 1
					 	 * format) */
@

