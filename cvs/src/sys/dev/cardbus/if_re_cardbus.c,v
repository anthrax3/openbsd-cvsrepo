head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.4
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.10
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.8
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.2
	OPENBSD_3_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.28
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.27;
commitid	5gdEnqVoJuTuwdTu;

1.27
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.26;
commitid	p4LJxGKbi0BU2cG6;

1.26
date	2014.11.24.02.03.37;	author brad;	state Exp;
branches;
next	1.25;
commitid	Wmnzf8bGQILqXRTG;

1.25
date	2014.09.06.04.46.58;	author brad;	state Exp;
branches;
next	1.24;
commitid	NjpaYKN1EE5jORe8;

1.24
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.23;
commitid	nYggAidK85QbUFh2;

1.23
date	2013.08.07.01.06.26;	author bluhm;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.02.17.47.04;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.07.16.21.41;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.06.19.20.21;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.20.18.47.03;	author martynas;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.10.21.29.37;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.12.00.54.49;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.20.00.34.39;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.17.05.29.25;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.28.20.04.02;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.19.07.23.02;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2006.09.18.21.33.32;	author dim;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.01.21.48.08;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.24.02.36.15;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.21.11.27.03;	author fkr;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.17.17.58.17;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.16.01.36.25;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.02.52.06;	author pvalchev;	state Exp;
branches;
next	;


desc
@@


1.28
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_re_cardbus.c,v 1.27 2015/03/14 03:38:47 jsg Exp $	*/

/*
 * Copyright (c) 2005 Peter Valchev <pvalchev@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Cardbus front-end for the Realtek 8169
 */

#include <sys/param.h>
#include <sys/endian.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>

#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

#include <dev/ic/rtl81x9reg.h>
#include <dev/ic/revar.h>

struct re_cardbus_softc {
	/* General */
	struct rl_softc sc_rl;

	/* Cardbus-specific data */
	void *sc_ih;
	cardbus_devfunc_t ct;
	pcitag_t sc_tag;
	pci_chipset_tag_t sc_pc;
	int sc_csr;
	int sc_cben;
	int sc_bar_reg;
	pcireg_t sc_bar_val;
	int sc_intrline;

	bus_size_t sc_mapsize;
};

int	re_cardbus_probe(struct device *, void *, void *);
void	re_cardbus_attach(struct device *, struct device *, void *);
int	re_cardbus_detach(struct device *, int);
void	re_cardbus_setup(struct rl_softc *);

/*
 * Cardbus autoconfig definitions
 */
struct cfattach re_cardbus_ca = {
	sizeof(struct re_cardbus_softc),
	re_cardbus_probe,
	re_cardbus_attach,
	re_cardbus_detach
};

const struct pci_matchid re_cardbus_devices[] = {
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8169 },
};

/*
 * Probe for a Realtek 8169/8110 chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
re_cardbus_probe(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid((struct cardbus_attach_args *)aux,
	    re_cardbus_devices, nitems(re_cardbus_devices)));
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
re_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct re_cardbus_softc	*csc = (struct re_cardbus_softc *)self;
	struct rl_softc		*sc = &csc->sc_rl;
	struct cardbus_attach_args *ca = aux;
	struct cardbus_softc *psc =
	    (struct cardbus_softc *)sc->sc_dev.dv_parent;
	cardbus_chipset_tag_t cc = psc->sc_cc;
	cardbus_function_tag_t cf = psc->sc_cf;
	cardbus_devfunc_t ct = ca->ca_ct;
	bus_addr_t adr;
	char intrstr[16];

	sc->sc_dmat = ca->ca_dmat;
	csc->ct = ct;
	csc->sc_tag = ca->ca_tag;
	csc->sc_pc = ca->ca_pc;
	csc->sc_intrline = ca->ca_intrline;

	/*
	 * Map control/status registers.
	 */
	if (Cardbus_mapreg_map(ct, RL_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->rl_btag, &sc->rl_bhandle, &adr, &csc->sc_mapsize) == 0) {
		csc->sc_cben = CARDBUS_MEM_ENABLE;
		csc->sc_csr |= PCI_COMMAND_MEM_ENABLE;
		csc->sc_bar_reg = RL_PCI_LOMEM;
		csc->sc_bar_val = adr | PCI_MAPREG_TYPE_MEM;
	} else {
		printf(": can't map mem space\n");
		return;
	}

	/* Enable power */
	Cardbus_function_enable(ct);

	/* Get chip out of powersave mode (if applicable), initialize
	 * config registers */
	re_cardbus_setup(sc);

	/* Allocate interrupt */
	csc->sc_ih = cardbus_intr_establish(cc, cf, csc->sc_intrline,
	    IPL_NET, re_intr, sc, sc->sc_dev.dv_xname);
	if (csc->sc_ih == NULL) {
		printf(": couldn't establish interrupt at %d",
		    ca->ca_intrline);
		Cardbus_function_disable(csc->ct);
		return;
	}
	snprintf(intrstr, sizeof(intrstr), "irq %d", ca->ca_intrline);

	sc->sc_product = PCI_PRODUCT(ca->ca_id);

	/* Call bus-independent (common) attach routine */
	if (re_attach(sc, intrstr)) {
		cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, csc->sc_ih);
		Cardbus_mapreg_unmap(ct, csc->sc_bar_reg, sc->rl_btag,
		    sc->rl_bhandle, csc->sc_mapsize);
	}
}

/*
 * Get chip out of power-saving mode, init registers
 */
void
re_cardbus_setup(struct rl_softc *sc)
{
	struct re_cardbus_softc *csc = (struct re_cardbus_softc *)sc;
	cardbus_devfunc_t ct = csc->ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = csc->sc_pc;
	pcireg_t reg, command;
	int pmreg;

	/* Handle power management nonsense */
	if (pci_get_capability(pc, csc->sc_tag,
	    PCI_CAP_PWRMGMT, &pmreg, 0)) {
		command = pci_conf_read(pc, csc->sc_tag,
		    pmreg + PCI_PMCSR);

		if (command & RL_PSTATE_MASK) {
			pcireg_t iobase, membase, irq;

			/* Save important PCI config data */
			iobase = pci_conf_read(pc, csc->sc_tag, RL_PCI_LOIO);
			membase = pci_conf_read(pc, csc->sc_tag, RL_PCI_LOMEM);
			irq = pci_conf_read(pc, csc->sc_tag, RL_PCI_INTLINE);

			/* Reset the power state */
			printf("%s: chip is in D%d power mode "
			    "-- setting to D0\n", sc->sc_dev.dv_xname,
			    command & RL_PSTATE_MASK);
			command &= RL_PSTATE_MASK;
			pci_conf_write(pc, csc->sc_tag, pmreg + PCI_PMCSR,
			    command);

			/* Restore PCI config data */
			pci_conf_write(pc, csc->sc_tag, RL_PCI_LOIO, iobase);
			pci_conf_write(pc, csc->sc_tag, RL_PCI_LOMEM, membase);
			pci_conf_write(pc, csc->sc_tag, RL_PCI_INTLINE, irq);
		}
	}

	/* Make sure the right access type is on the Cardbus bridge */
	(*ct->ct_cf->cardbus_ctrl)(cc, csc->sc_cben);
	(*ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	/* Program the BAR */
	pci_conf_write(pc, csc->sc_tag, csc->sc_bar_reg, csc->sc_bar_val);

	/* Enable proper bits in CARDBUS CSR */
	reg = pci_conf_read(pc, csc->sc_tag, PCI_COMMAND_STATUS_REG);
	reg &= ~(PCI_COMMAND_IO_ENABLE|PCI_COMMAND_MEM_ENABLE);
	reg |= csc->sc_csr;
	pci_conf_write(pc, csc->sc_tag, PCI_COMMAND_STATUS_REG, reg);

	/* Make sure the latency timer is set to some reasonable value */
	reg = pci_conf_read(pc, csc->sc_tag, PCI_BHLC_REG);
	if (PCI_LATTIMER(reg) < 0x20) {
		reg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
		reg |= (0x20 << PCI_LATTIMER_SHIFT);
		pci_conf_write(pc, csc->sc_tag, PCI_BHLC_REG, reg);
	}
}

/*
 * Cardbus detach function: deallocate all resources
 */
int
re_cardbus_detach(struct device *self, int flags)
{
	struct re_cardbus_softc *csc = (void *)self;
	struct rl_softc *sc = &csc->sc_rl;
	struct cardbus_devfunc *ct = csc->ct;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Remove timeout handler */
	timeout_del(&sc->timer_handle);

	/* Detach PHY */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete media stuff */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);
	ether_ifdetach(ifp);
	if_detach(ifp);

	/* Disable interrupts */
	if (csc->sc_ih != NULL)
		cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, csc->sc_ih);

	/* Free cardbus resources */
	Cardbus_mapreg_unmap(ct, csc->sc_bar_reg, sc->rl_btag, sc->rl_bhandle,
	    csc->sc_mapsize);

	return (0);
}
@


1.27
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.26 2014/11/24 02:03:37 brad Exp $	*/
a34 1
#include <net/if_dl.h>
@


1.26
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.25 2014/09/06 04:46:58 brad Exp $	*/
a40 1
#include <dev/mii/mii.h>
@


1.25
log
@Various changes to the re(4) feature flags..

Changed RL_FLAG_MACLDPS to RL_FLAG_MACRESET.
Removed RL_FLAG_INVMAR and RL_FLAG_NOJUMBO.
Added RL_FLAG_FASTETHER, RL_FLAG_CMDSTOP_WAIT_TXQ, RL_FLAG_JUMBOV2, RL_FLAG_WOL_MANLINK,
      RL_FLAG_WAIT_TXPOLL, RL_FLAG_WOLRXENB.

Also set in the softc the maximum MTU for the various generations of chips.

Input from and Ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.24 2014/08/11 12:45:45 mpi Exp $	*/
d89 1
a89 1
 * Probe for a RealTek 8169/8110 chip. Check the PCI vendor and device
@


1.24
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.23 2013/08/07 01:06:26 bluhm Exp $	*/
d154 2
@


1.23
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.22 2011/04/02 17:47:04 jasper Exp $	*/
a37 1
#ifdef INET
a38 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a39 1
#endif
@


1.22
log
@- use nitems(); no binary change@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.21 2010/09/07 16:21:41 deraadt Exp $	*/
a40 1
#include <netinet/in_var.h>
@


1.21
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.20 2010/09/06 19:20:21 deraadt Exp $	*/
d101 1
a101 2
	    re_cardbus_devices,
	    sizeof(re_cardbus_devices)/sizeof(re_cardbus_devices[0])));
@


1.20
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.19 2010/03/27 21:40:13 jsg Exp $	*/
a78 2
void	re_cardbus_powerhook(int, void *);

a160 2
	sc->sc_pwrhook = powerhook_establish(re_cardbus_powerhook, sc);

a162 2
		if (sc->sc_pwrhook != NULL)
			powerhook_disestablish(sc->sc_pwrhook);
a255 4
	/* No more hooks */
	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);

a264 10
}

void
re_cardbus_powerhook(int why, void *arg)
{
	struct rl_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	if (why == DVACT_RESUME)
		re_init(ifp);
@


1.19
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.18 2010/03/27 20:04:03 jsg Exp $	*/
d283 1
a283 1
	if (why == PWR_RESUME)
@


1.18
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.17 2010/03/22 22:28:27 jsg Exp $	*/
d64 1
d128 1
d184 1
a184 1
	cardbus_function_tag_t cf = ct->ct_cf;
d189 1
a189 1
	if (cardbus_get_capability(cc, cf, csc->sc_tag,
d191 1
a191 1
		command = cardbus_conf_read(cc, cf, csc->sc_tag,
d198 3
a200 3
			iobase = cardbus_conf_read(cc, cf, csc->sc_tag, RL_PCI_LOIO);
			membase = cardbus_conf_read(cc, cf, csc->sc_tag, RL_PCI_LOMEM);
			irq = cardbus_conf_read(cc, cf, csc->sc_tag, RL_PCI_INTLINE);
d207 1
a207 1
			cardbus_conf_write(cc, cf, csc->sc_tag, pmreg + PCI_PMCSR,
d211 3
a213 3
			cardbus_conf_write(cc, cf, csc->sc_tag, RL_PCI_LOIO, iobase);
			cardbus_conf_write(cc, cf, csc->sc_tag, RL_PCI_LOMEM, membase);
			cardbus_conf_write(cc, cf, csc->sc_tag, RL_PCI_INTLINE, irq);
d222 1
a222 1
	cardbus_conf_write(cc, cf, csc->sc_tag, csc->sc_bar_reg, csc->sc_bar_val);
d225 1
a225 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, PCI_COMMAND_STATUS_REG);
d228 1
a228 1
	cardbus_conf_write(cc, cf, csc->sc_tag, PCI_COMMAND_STATUS_REG, reg);
d231 1
a231 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, PCI_BHLC_REG);
d235 1
a235 1
		cardbus_conf_write(cc, cf, csc->sc_tag, PCI_BHLC_REG, reg);
@


1.17
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.16 2009/08/20 18:47:03 martynas Exp $	*/
d118 1
a118 1
	pci_chipset_tag_t cc = psc->sc_cc;
d181 1
a181 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.16
log
@- fix varargs after dmesg tweaking
- intrline is not a string
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.15 2009/08/10 21:29:37 deraadt Exp $	*/
d63 1
a63 1
	cardbustag_t sc_tag;
d90 1
a90 1
const struct cardbus_matchid re_cardbus_devices[] = {
d118 1
a118 1
	cardbus_chipset_tag_t cc = psc->sc_cc;
d132 1
a132 1
	if (Cardbus_mapreg_map(ct, RL_PCI_LOMEM, CARDBUS_MAPREG_TYPE_MEM, 0,
d135 1
a135 1
		csc->sc_csr |= CARDBUS_COMMAND_MEM_ENABLE;
d137 1
a137 1
		csc->sc_bar_val = adr | CARDBUS_MAPREG_TYPE_MEM;
d181 1
a181 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d223 2
a224 2
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG);
	reg &= ~(CARDBUS_COMMAND_IO_ENABLE|CARDBUS_COMMAND_MEM_ENABLE);
d226 1
a226 1
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG, reg);
d229 5
a233 5
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG);
	if (CARDBUS_LATTIMER(reg) < 0x20) {
		reg &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
		reg |= (0x20 << CARDBUS_LATTIMER_SHIFT);
		cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG, reg);
@


1.15
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.14 2008/10/12 00:54:49 brad Exp $	*/
d154 1
a154 1
		printf(": couldn't establish interrupt at %s",
@


1.14
log
@If re_attach() fails at any point make sure to disestablish various
resources setup by the bus front ends, especially the shutdown hook.
Found while testing some other changes with a CardBus adapter and
re_attach() was failing early before the interface pointer was
assigned. Then the system was rebooted, the shutdown hook was called
and *boom* in re_stop().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.13 2008/04/20 00:34:39 brad Exp $	*/
a77 1
void	re_cardbus_shutdown(void *);
a160 1
	sc->sc_sdhook = shutdownhook_establish(re_cardbus_shutdown, sc);
a164 2
		if (sc->sc_sdhook != NULL)
			shutdownhook_disestablish(sc->sc_sdhook);
a260 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
a272 9
}

void
re_cardbus_shutdown(void *arg)
{
	struct rl_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	re_stop(ifp, 1);
@


1.13
log
@Remove unused flags.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.12 2008/02/17 05:29:25 brad Exp $	*/
d166 9
a174 1
	re_attach(sc, intrstr);
@


1.12
log
@Simplify the hw revision handling by removing the use of the
rl_type softc field and only relying on the sc_hwrev softc
field thoughout the driver.

Tested by a number of users from tech@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.11 2006/11/28 20:04:02 brad Exp $	*/
a160 2

	sc->sc_flags |= RL_ENABLED;
@


1.11
log
@move printing of the interrupt string into re_attach().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.10 2006/10/12 16:35:52 grange Exp $	*/
a162 1
	sc->rl_type = RL_8169;
@


1.10
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.9 2006/09/19 07:23:02 mickey Exp $	*/
d123 1
a124 1
	
d160 1
a160 1
	printf(": irq %d", ca->ca_intrline);
d169 1
a169 1
	re_attach(sc);
@


1.9
log
@no externs on protots ad no casts from void *
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.8 2006/09/18 21:33:32 dim Exp $	*/
d153 1
a153 1
	    IPL_NET, re_intr, sc);
@


1.8
log
@Fix for re_stop() being called from re_cardbus_shutdown() with the
wrong arguments, causing uvm_fault on halt/reboot, with a cardbus re
inserted.  While here, cleanup prototypes and use revar.h everywhere.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.7 2006/07/01 21:48:08 brad Exp $	*/
d279 1
a279 1
	struct rl_softc *sc = (struct rl_softc *)arg;
d288 1
a288 1
	struct rl_softc *sc = (struct rl_softc *)arg;
@


1.7
log
@(fxp/re)_attach_common -> (fxp/re)_attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.6 2006/06/24 02:36:15 brad Exp $	*/
d280 1
d282 1
a282 1
	re_stop(sc);
@


1.6
log
@de-register, ANSI functions and a little cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.5 2006/06/21 11:27:03 fkr Exp $	*/
d169 1
a169 1
	re_attach_common(sc);
@


1.5
log
@removal of '#ifdef rbus ... #else ...' directives, we use rbus in all
cases anyways, so we might as well remove code (the !rbus case) thats been
dead throughout the last years and just use the rbus code without ifdefs.

brad, miod "I am all for this diff"
ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.4 2006/06/17 17:58:17 brad Exp $	*/
d73 4
a76 4
int re_cardbus_probe(struct device *, void *, void *);
void re_cardbus_attach(struct device *, struct device *, void *);
int re_cardbus_detach(struct device *, int);
void re_cardbus_setup(struct rl_softc *);
d78 2
a79 2
void re_cardbus_shutdown(void *);
void re_cardbus_powerhook(int, void *);
@


1.4
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.3 2006/05/22 20:35:12 krw Exp $	*/
a134 4
#if rbus
#else
		(*ct->ct_cf->cardbus_mem_open)(cc, 0, adr, adr+csc->sc_mapsize);
#endif
@


1.3
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.2 2005/05/16 01:36:25 brad Exp $	*/
d31 1
@


1.2
log
@Use cardbus_matchbyid().

ok millert@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re_cardbus.c,v 1.1 2005/01/14 02:52:06 pvalchev Exp $	*/
d263 4
a266 2
	shutdownhook_disestablish(sc->sc_sdhook);
	powerhook_disestablish(sc->sc_pwrhook);
@


1.1
log
@cardbus re(4) support (Realtek 8169) heavily based on if_rl.
still work in progress but it works (this is committed through it),
some PHY timeout issues to resolve
@
text
@d1 1
a1 1
/*	$OpenBSD: if_re.c,v 1.14 2004/12/11 06:27:49 pvalchev Exp $	*/
d90 4
d101 3
a103 7
	struct cardbus_attach_args *ca = aux;

	if (CARDBUS_VENDOR(ca->ca_id) == PCI_VENDOR_REALTEK &&
	    CARDBUS_PRODUCT(ca->ca_id) == PCI_PRODUCT_REALTEK_RT8169)
		return 1;

	return 0;
@

