head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.6
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.8
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.10
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.8
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.6
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.18
date	2015.12.11.16.07.01;	author mpi;	state Exp;
branches;
next	1.17;
commitid	fbhqfhfdKxBcsetK;

1.17
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.16;
commitid	5gdEnqVoJuTuwdTu;

1.16
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.15;
commitid	p4LJxGKbi0BU2cG6;

1.15
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2013.11.14.12.24.18;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.06.19.20.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.27.20.06.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.11.10.28.20;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.10.20.20.04;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.09.20.45.27;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.06.21.55.33;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.02.18.06.55;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.28.05.02.33;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@/*	$OpenBSD: if_pgt_cardbus.c,v 1.17 2015/11/24 17:11:39 mpi Exp $ */

/*
 * Copyright (c) 2006 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * CardBus front-end for the PrismGT
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/pgtreg.h>
#include <dev/ic/pgtvar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

struct pgt_cardbus_softc {
	struct pgt_softc	 sc_pgt;
	cardbus_devfunc_t	 sc_ct;
	pcitag_t		 sc_tag;
	int			 sc_intrline;

	void			*sc_ih;
	bus_size_t		 sc_mapsize;
	pcireg_t		 sc_bar0_val;
	pci_chipset_tag_t	 sc_pc;
};

int	pgt_cardbus_match(struct device *, void *, void *);
void	pgt_cardbus_attach(struct device *, struct device *, void *);
int	pgt_cardbus_detach(struct device *, int);
int	pgt_cardbus_enable(struct pgt_softc *);
void	pgt_cardbus_disable(struct pgt_softc *);
void	pgt_cardbus_power(struct pgt_softc *, int);
void	pgt_cardbus_setup(struct pgt_cardbus_softc *);

struct cfattach pgt_cardbus_ca = {
	sizeof(struct pgt_cardbus_softc), pgt_cardbus_match, pgt_cardbus_attach,
	pgt_cardbus_detach
};

const struct pci_matchid pgt_cardbus_devices[] = {
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_ISL3877 },
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_ISL3890 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRWE154G72 }
};

int
pgt_cardbus_match(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid((struct cardbus_attach_args *)aux,
	    pgt_cardbus_devices,
	    sizeof(pgt_cardbus_devices) / sizeof(pgt_cardbus_devices[0])));
}

void
pgt_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct pgt_cardbus_softc *csc = (struct pgt_cardbus_softc *)self;
	struct pgt_softc *sc = &csc->sc_pgt;
	struct cardbus_attach_args *ca = aux;
	cardbus_devfunc_t ct = ca->ca_ct;
	bus_addr_t base;
	int error;

	sc->sc_dmat = ca->ca_dmat;
	csc->sc_ct = ct;
	csc->sc_tag = ca->ca_tag;
	csc->sc_intrline = ca->ca_intrline;
	csc->sc_pc = ca->ca_pc;

	/* power management hooks */
	sc->sc_enable = pgt_cardbus_enable;
	sc->sc_disable = pgt_cardbus_disable;
	sc->sc_power = pgt_cardbus_power;

	/* remember chipset */
	if (PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_INTERSIL_ISL3877)
		sc->sc_flags |= SC_ISL3877;

	/* map control / status registers */
	error = Cardbus_mapreg_map(ct, CARDBUS_BASE0_REG,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &sc->sc_iotag, &sc->sc_iohandle, &base, &csc->sc_mapsize);
	if (error != 0) {
		printf(": can't map mem space\n");
		return;
	}
	csc->sc_bar0_val = base | PCI_MAPREG_TYPE_MEM;

	/* disable all interrupts */
	bus_space_write_4(sc->sc_iotag, sc->sc_iohandle, PGT_REG_INT_EN, 0);
	(void)bus_space_read_4(sc->sc_iotag, sc->sc_iohandle, PGT_REG_INT_EN);
	DELAY(PGT_WRITEIO_DELAY);

	/* set up the PCI configuration registers */
	pgt_cardbus_setup(csc);

	printf(": irq %d\n", csc->sc_intrline);

	config_mountroot(self, pgt_attach);
}

int
pgt_cardbus_detach(struct device *self, int flags)
{
	struct pgt_cardbus_softc *csc = (struct pgt_cardbus_softc *)self;
	struct pgt_softc *sc = &csc->sc_pgt;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
	int error;

	error = pgt_detach(sc);
	if (error != 0)
		return (error);

	/* unhook the interrupt handler */
	if (csc->sc_ih != NULL) {
		cardbus_intr_disestablish(cc, cf, csc->sc_ih);
		csc->sc_ih = NULL;
	}

	/* release bus space and close window */
	Cardbus_mapreg_unmap(ct, CARDBUS_BASE0_REG,
	    sc->sc_iotag, sc->sc_iohandle, csc->sc_mapsize);

	return (0);
}

int
pgt_cardbus_enable(struct pgt_softc *sc)
{
        struct pgt_cardbus_softc *csc = (struct pgt_cardbus_softc *)sc;
        cardbus_devfunc_t ct = csc->sc_ct;
        cardbus_chipset_tag_t cc = ct->ct_cc;
        cardbus_function_tag_t cf = ct->ct_cf;

        /* power on the socket */
        Cardbus_function_enable(ct);

        /* setup the PCI configuration registers */
        pgt_cardbus_setup(csc);

        /* map and establish the interrupt handler */
        csc->sc_ih = cardbus_intr_establish(cc, cf, csc->sc_intrline, IPL_NET,
            pgt_intr, sc, sc->sc_dev.dv_xname);
        if (csc->sc_ih == NULL) {
                printf("%s: could not establish interrupt at %d\n",
                    sc->sc_dev.dv_xname, csc->sc_intrline);
                Cardbus_function_disable(ct);
                return (1);
        }

        return (0);
}

void
pgt_cardbus_disable(struct pgt_softc *sc)
{
	struct pgt_cardbus_softc *csc = (struct pgt_cardbus_softc *)sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/* unhook the interrupt handler */
	cardbus_intr_disestablish(cc, cf, csc->sc_ih);
	csc->sc_ih = NULL;

	/* power down the socket */
	Cardbus_function_disable(ct);
}

void
pgt_cardbus_power(struct pgt_softc *sc, int why)
{
	if (why == DVACT_RESUME)
		if (sc->sc_enable != NULL)
			(*sc->sc_enable)(sc);
	if (why == DVACT_SUSPEND)
		if (sc->sc_disable != NULL)
			(*sc->sc_disable)(sc);
}

void
pgt_cardbus_setup(struct pgt_cardbus_softc *csc)
{
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = csc->sc_pc;
	cardbus_function_tag_t cf = ct->ct_cf;
	pcireg_t reg;

	/* program the BAR */
	pci_conf_write(pc, csc->sc_tag, CARDBUS_BASE0_REG,
	    csc->sc_bar0_val);

	/* make sure the right access type is on the cardbus bridge */
 	(*cf->cardbus_ctrl)(cc, CARDBUS_MEM_ENABLE);
	(*cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	/* enable the appropriate bits in the PCI CSR */
	reg = pci_conf_read(pc, csc->sc_tag,
	    PCI_COMMAND_STATUS_REG);
	reg |= PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_MEM_ENABLE;
	pci_conf_write(pc, csc->sc_tag, PCI_COMMAND_STATUS_REG,
	    reg);
}
@


1.17
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.16 2015/03/14 03:38:47 jsg Exp $ */
d139 1
a139 4
	if (rootvp == NULL)
		mountroothook_establish(pgt_attach, sc);
	else
		pgt_attach(sc);
@


1.16
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.15 2013/12/06 21:03:02 deraadt Exp $ */
a37 1
#include <net/if_dl.h>
@


1.15
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.14 2013/11/14 12:24:18 dlg Exp $ */
a35 1
#include <machine/intr.h>
@


1.14
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.13 2010/09/06 19:20:21 deraadt Exp $ */
a33 1
#include <sys/task.h>
@


1.13
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.12 2010/08/27 20:06:38 deraadt Exp $ */
d34 1
a34 1
#include <sys/workq.h>
@


1.12
log
@Massage the powerhook function into an activate function, and since we do
not neccessarily have a working filesystem for the firmware yet, use a workq
to postpone resume.  Then make the powerhook function call the activate
function.  There remains some questions about the sc_power functions...
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.11 2010/03/27 21:40:13 jsg Exp $ */
d221 1
a221 1
	if (why == PWR_RESUME)
d224 1
a224 1
	if (why == PWR_SUSPEND)
@


1.11
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.10 2010/03/27 20:04:03 jsg Exp $ */
d34 1
@


1.10
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.9 2010/03/22 22:28:27 jsg Exp $ */
d66 1
d110 1
d233 1
d238 1
a238 1
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_BASE0_REG,
d246 1
a246 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag,
d249 1
a249 1
	cardbus_conf_write(cc, cf, csc->sc_tag, PCI_COMMAND_STATUS_REG,
@


1.9
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.8 2009/03/29 21:53:52 sthen Exp $ */
d151 1
a151 1
	pci_chipset_tag_t cc = ct->ct_cc;
d177 1
a177 1
        pci_chipset_tag_t cc = ct->ct_cc;
d204 1
a204 1
	pci_chipset_tag_t cc = ct->ct_cc;
d230 1
a230 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.8
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.7 2006/11/11 10:28:20 maja Exp $ */
d60 1
a60 1
	cardbustag_t		 sc_tag;
d81 1
a81 1
const struct cardbus_matchid pgt_cardbus_devices[] = {
d116 1
a116 1
	if (CARDBUS_PRODUCT(ca->ca_id) == PCI_PRODUCT_INTERSIL_ISL3877)
d127 1
a127 1
	csc->sc_bar0_val = base | CARDBUS_MAPREG_TYPE_MEM;
d151 1
a151 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d177 1
a177 1
        cardbus_chipset_tag_t cc = ct->ct_cc;
d204 1
a204 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d230 1
a230 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d244 3
a246 3
	    CARDBUS_COMMAND_STATUS_REG);
	reg |= CARDBUS_COMMAND_MASTER_ENABLE | CARDBUS_COMMAND_MEM_ENABLE;
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG,
@


1.7
log
@Add support for 3Com 3CRWE154G72. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.6 2006/11/10 20:20:04 damien Exp $ */
d124 1
a124 1
		printf(": could not map memory space\n");
@


1.6
log
@acx(4) doesn't use rssadapt(9).
pgt(4) doesn't use rssadapt(9) nor amrr.
=> remove useless #include.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.5 2006/10/12 16:35:52 grange Exp $ */
d83 2
a84 1
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_ISL3890 }
@


1.5
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.4 2006/10/09 20:45:27 mglocker Exp $ */
a45 2
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_rssadapt.h>
@


1.4
log
@Add powerhooks.  Tested with a Netgear WG511v1 on my X40.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.3 2006/10/06 21:55:33 mglocker Exp $ */
d189 1
a189 1
            pgt_intr, sc);
@


1.3
log
@Fix cardbus support for pgt(4).  Tested with a Netgear WG511.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.2 2006/10/02 18:06:55 mglocker Exp $ */
d219 6
a224 6
	struct pgt_cardbus_softc *csc = (struct pgt_cardbus_softc *)sc;

	if (why == PWR_RESUME) {
		/* kick the PCI configuration registers */
		pgt_cardbus_setup(csc);
	}
@


1.2
log
@Simplify device attachment.  From brad@@ with a tiny correction.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pgt_cardbus.c,v 1.1 2006/09/28 05:02:33 mglocker Exp $ */
d110 1
a110 1
#if 0
d115 1
a115 1
#endif
a143 2

	Cardbus_function_disable(ct);
@


1.1
log
@Add cardbus support for pgt(4).

We are still looking for PrismGT cardbus devices for testing.  One
common model should be the Netgear WG511 v1/v2 made in Taiwan.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d141 1
a141 1
		mountroothook_establish(pgt_attachhook, sc);
@

