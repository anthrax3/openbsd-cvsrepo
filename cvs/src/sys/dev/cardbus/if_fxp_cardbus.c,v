head	1.36;
access;
symbols
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.4
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.29.0.10
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.8
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.36
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.35;
commitid	5gdEnqVoJuTuwdTu;

1.35
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.34;
commitid	5DvsamK0GblTp8ww;

1.34
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.33;
commitid	LS2TNeCue5R9L67C;

1.33
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.32;
commitid	nYggAidK85QbUFh2;

1.32
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.11.14.12.16.01;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2013.08.07.01.06.26;	author bluhm;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.02.17.47.04;	author jasper;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.27.18.25.46;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.02.16.50.20;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.25.23.10.16;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.08.20.43.07;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.08.20.33.07;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.01.21.48.08;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.17.17.58.17;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.08.05.43.01;	author fkr;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.04.21.07.39;	author fkr;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.16.22.33.32;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.01.19.06.43;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.16.01.36.25;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.14.01.06.16;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.07.21.16.59;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.04.19.42.30;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.27.02.38.37;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.07.23.33.39;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.09.21.12.51;	author jason;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2000.09.17.17.08.16;	author aaron;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.09.17.05.11.12;	author aaron;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.22.23.13;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2002.03.29.23.39.33;	author niklas;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2004.06.05.23.12.37;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_fxp_cardbus.c,v 1.35 2015/11/24 13:33:17 mpi Exp $ */
/*	$NetBSD: if_fxp_cardbus.c,v 1.12 2000/05/08 18:23:36 thorpej Exp $	*/

/*
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Johan Danielsson.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * CardBus front-end for the Intel i8255x family of Ethernet chips.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/miivar.h>

#include <dev/ic/fxpreg.h>
#include <dev/ic/fxpvar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

int fxp_cardbus_match(struct device *, void *, void *);
void fxp_cardbus_attach(struct device *, struct device *, void *);
int fxp_cardbus_detach(struct device *, int);
void fxp_cardbus_setup(struct fxp_softc *);

struct fxp_cardbus_softc {
	struct fxp_softc sc;
	cardbus_devfunc_t ct;
	pcitag_t ct_tag;
	pcireg_t base0_reg;
	pcireg_t base1_reg;
	bus_size_t size;
	pci_chipset_tag_t pc;
};

struct cfattach fxp_cardbus_ca = {
	sizeof(struct fxp_cardbus_softc), fxp_cardbus_match, fxp_cardbus_attach,
	    fxp_cardbus_detach
};

const struct pci_matchid fxp_cardbus_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_8255x },
};

#ifdef CBB_DEBUG
#define DPRINTF(X) printf X
#else
#define DPRINTF(X)
#endif

int
fxp_cardbus_match(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid((struct cardbus_attach_args *)aux,
	    fxp_cardbus_devices, nitems(fxp_cardbus_devices)));
}

void
fxp_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	char intrstr[16];
	struct fxp_softc *sc = (struct fxp_softc *) self;
	struct fxp_cardbus_softc *csc = (struct fxp_cardbus_softc *) self;
	struct cardbus_attach_args *ca = aux;
	struct cardbus_softc *psc =
	    (struct cardbus_softc *)sc->sc_dev.dv_parent;
	cardbus_chipset_tag_t cc = psc->sc_cc;
	cardbus_function_tag_t cf = psc->sc_cf;
	bus_space_tag_t iot, memt;
	bus_space_handle_t ioh, memh;

	bus_addr_t adr;
	bus_size_t size;

	csc->ct = ca->ca_ct;
	csc->pc = ca->ca_pc;

	/*
	 * Map control/status registers.
	 */
	if (Cardbus_mapreg_map(csc->ct, CARDBUS_BASE1_REG,
	    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, &adr, &size) == 0) {
		csc->base1_reg = adr | 1;
		sc->sc_st = iot;
		sc->sc_sh = ioh;
		csc->size = size;
	} else if (Cardbus_mapreg_map(csc->ct, CARDBUS_BASE0_REG,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT,
	    0, &memt, &memh, &adr, &size) == 0) {
		csc->base0_reg = adr;
		sc->sc_st = memt;
		sc->sc_sh = memh;
		csc->size = size;
	} else
		panic("%s: failed to allocate mem and io space", __func__);

	sc->sc_dmat = ca->ca_dmat;
#if 0
	sc->sc_enable = fxp_cardbus_enable;
	sc->sc_disable = fxp_cardbus_disable;
	sc->sc_enabled = 0;
#endif

	Cardbus_function_enable(csc->ct);

	fxp_cardbus_setup(sc);

	/* Map and establish the interrupt. */
	sc->sc_ih = cardbus_intr_establish(cc, cf, psc->sc_intrline, IPL_NET,
	    fxp_intr, sc, sc->sc_dev.dv_xname);
	if (NULL == sc->sc_ih) {
		printf(": couldn't establish interrupt");
		printf("at %d\n", ca->ca_intrline);
		return;
	}
	snprintf(intrstr, sizeof(intrstr), "irq %d", ca->ca_intrline);
	
	sc->sc_revision = PCI_REVISION(ca->ca_class);

	fxp_attach(sc, intrstr);
}

void
fxp_cardbus_setup(struct fxp_softc *sc)
{
	struct fxp_cardbus_softc *csc = (struct fxp_cardbus_softc *) sc;
	struct cardbus_softc *psc =
	    (struct cardbus_softc *) sc->sc_dev.dv_parent;
	cardbus_chipset_tag_t cc = psc->sc_cc;
	pci_chipset_tag_t pc = csc->pc;
	cardbus_function_tag_t cf = psc->sc_cf;
	pcireg_t command;

	csc->ct_tag = pci_make_tag(pc, csc->ct->ct_bus,
	    csc->ct->ct_dev, csc->ct->ct_func);

	command = pci_conf_read(pc, csc->ct_tag, PCI_COMMAND_STATUS_REG);
	if (csc->base0_reg) {
		pci_conf_write(pc, csc->ct_tag, CARDBUS_BASE0_REG, csc->base0_reg);
		(cf->cardbus_ctrl) (cc, CARDBUS_MEM_ENABLE);
		command |= PCI_COMMAND_MEM_ENABLE |
		    PCI_COMMAND_MASTER_ENABLE;
	} else if (csc->base1_reg) {
		pci_conf_write(pc, csc->ct_tag, CARDBUS_BASE1_REG, csc->base1_reg);
		(cf->cardbus_ctrl) (cc, CARDBUS_IO_ENABLE);
		command |= (PCI_COMMAND_IO_ENABLE |
		    PCI_COMMAND_MASTER_ENABLE);
	}

	(cf->cardbus_ctrl) (cc, CARDBUS_BM_ENABLE);

	/* enable the card */
	pci_conf_write(pc, csc->ct_tag, PCI_COMMAND_STATUS_REG, command);
}

int
fxp_cardbus_detach(struct device *self, int flags)
{
	struct fxp_softc *sc = (struct fxp_softc *) self;
	struct fxp_cardbus_softc *csc = (struct fxp_cardbus_softc *) self;
	struct cardbus_devfunc *ct = csc->ct;
	int reg;

	cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, sc->sc_ih);
	fxp_detach(sc);

	if (csc->base0_reg)
		reg = CARDBUS_BASE0_REG;
	else
		reg = CARDBUS_BASE1_REG;
	Cardbus_mapreg_unmap(ct, reg, sc->sc_st, sc->sc_sh, csc->size);
	return (0);
}
@


1.35
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.34 2014/12/19 22:44:58 guenther Exp $ */
a51 1
#include <net/if_dl.h>
@


1.34
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.33 2014/08/11 12:45:45 mpi Exp $ */
a52 1
#include <net/if_types.h>
@


1.33
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.32 2013/12/06 21:03:02 deraadt Exp $ */
d49 1
a54 2

#include <machine/endian.h>
@


1.32
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.31 2013/11/14 12:16:01 dlg Exp $ */
a60 1
#ifdef INET
a61 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a62 1
#endif
@


1.31
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.30 2013/08/07 01:06:26 bluhm Exp $ */
a48 1
#include <sys/task.h>
@


1.30
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.29 2011/04/02 17:47:04 jasper Exp $ */
d49 1
a49 1
#include <sys/workq.h>
@


1.29
log
@- use nitems(); no binary change@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.28 2010/08/27 18:25:46 deraadt Exp $ */
a64 1
#include <netinet/in_var.h>
@


1.28
log
@Since the pci-specific activate function does nothing, move it to fxp.c.
Then it is possible for fxp_powerhook to use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.27 2010/03/27 21:40:13 jsg Exp $ */
d118 1
a118 2
	    fxp_cardbus_devices,
	    sizeof(fxp_cardbus_devices)/sizeof(fxp_cardbus_devices[0])));
@


1.27
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.26 2010/03/27 20:04:03 jsg Exp $ */
d49 1
@


1.26
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.25 2010/03/22 22:28:27 jsg Exp $ */
d95 1
d139 1
d193 1
d197 1
a197 1
	csc->ct_tag = cardbus_make_tag(cc, cf, csc->ct->ct_bus,
d200 1
a200 1
	command = cardbus_conf_read(cc, cf, csc->ct_tag, PCI_COMMAND_STATUS_REG);
d202 1
a202 1
		cardbus_conf_write(cc, cf, csc->ct_tag, CARDBUS_BASE0_REG, csc->base0_reg);
d207 1
a207 1
		cardbus_conf_write(cc, cf, csc->ct_tag, CARDBUS_BASE1_REG, csc->base1_reg);
d216 1
a216 1
	cardbus_conf_write(cc, cf, csc->ct_tag, PCI_COMMAND_STATUS_REG, command);
@


1.25
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.24 2009/10/15 17:54:56 deraadt Exp $ */
d129 1
a129 1
	pci_chipset_tag_t cc = psc->sc_cc;
d190 1
a190 1
	pci_chipset_tag_t cc = psc->sc_cc;
@


1.24
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.23 2009/06/02 16:50:20 jsg Exp $ */
d91 1
a91 1
	cardbustag_t ct_tag;
d102 1
a102 1
const struct cardbus_matchid fxp_cardbus_devices[] = {
d129 1
a129 1
	cardbus_chipset_tag_t cc = psc->sc_cc;
d190 1
a190 1
	cardbus_chipset_tag_t cc = psc->sc_cc;
d197 1
a197 1
	command = cardbus_conf_read(cc, cf, csc->ct_tag, CARDBUS_COMMAND_STATUS_REG);
d201 2
a202 2
		command |= CARDBUS_COMMAND_MEM_ENABLE |
		    CARDBUS_COMMAND_MASTER_ENABLE;
d206 2
a207 2
		command |= (CARDBUS_COMMAND_IO_ENABLE |
		    CARDBUS_COMMAND_MASTER_ENABLE);
d213 1
a213 1
	cardbus_conf_write(cc, cf, csc->ct_tag, CARDBUS_COMMAND_STATUS_REG, command);
@


1.23
log
@Make fxp at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.22 2008/06/26 05:42:14 ray Exp $ */
d222 1
a222 1
	int rv, reg;
d224 2
a225 4
#ifdef DIAGNOSTIC
	if (ct == NULL)
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
#endif
d227 6
a232 17
	rv = fxp_detach(sc);
	if (rv == 0) {
		/*
		 * Unhook the interrupt handler.
		 */
		cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, sc->sc_ih);

		/*
		 * release bus space and close window
		 */
		if (csc->base0_reg)
			reg = CARDBUS_BASE0_REG;
		else
			reg = CARDBUS_BASE1_REG;
		Cardbus_mapreg_unmap(ct, reg, sc->sc_st, sc->sc_sh, csc->size);
	}
	return (rv);
@


1.22
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.21 2008/02/25 23:10:16 brad Exp $ */
a213 28
}

int fxp_detach(struct fxp_softc *);

int
fxp_detach(struct fxp_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Unhook our tick handler. */
	timeout_del(&sc->stats_update_to);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);

	return (0);
@


1.21
log
@Following up with further dmesg display tweaking after the cardbusprint()
change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.20 2007/05/08 20:43:07 deraadt Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.20
log
@repair com/fxp foo_detach() stuff, the hardest part being the pccom mess
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.19 2007/05/08 20:33:07 deraadt Exp $ */
a163 6

	if (ca->ca_cis.cis1_info[0] && ca->ca_cis.cis1_info[1])
		printf(": %s %s", ca->ca_cis.cis1_info[0],
		    ca->ca_cis.cis1_info[1]);
	else
		printf("\n");
@


1.19
log
@put more foo_detach() routines where they are used
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.18 2006/10/12 16:35:52 grange Exp $ */
d229 2
a255 2

int fxp_detach(struct fxp_softc *);
@


1.18
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.17 2006/07/01 21:48:08 brad Exp $ */
d228 28
@


1.17
log
@(fxp/re)_attach_common -> (fxp/re)_attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.16 2006/06/17 17:58:17 brad Exp $ */
d184 1
a184 1
	    fxp_intr, sc);
@


1.16
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.15 2006/06/08 05:43:01 fkr Exp $ */
d194 1
a194 1
	fxp_attach_common(sc, intrstr);
@


1.15
log
@substitute the Cardbus_conf_read/Cardbus_conf_write macros with
cardbus_conf_read/cardbus_conf_write. This makes fxp* at cardbus?
work (again?) on macppc. tested by various users.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.13 2006/04/16 22:33:32 miod Exp $ */
d54 1
@


1.14
log
@KNF and whitespace cleanup, no functional change
ok mbalmer@@
@
text
@d97 1
d206 1
a206 1
	cardbustag_t tag = cardbus_make_tag(cc, cf, csc->ct->ct_bus,
d209 1
a209 1
	command = Cardbus_conf_read(csc->ct, tag, CARDBUS_COMMAND_STATUS_REG);
d211 1
a211 2
		Cardbus_conf_write(csc->ct, tag,
		    CARDBUS_BASE0_REG, csc->base0_reg);
d216 1
a216 2
		Cardbus_conf_write(csc->ct, tag,
		    CARDBUS_BASE1_REG, csc->base1_reg);
d225 1
a225 1
	Cardbus_conf_write(csc->ct, tag, CARDBUS_COMMAND_STATUS_REG, command);
@


1.13
log
@Use __func__ to get the current function name, no need to declare a variable
for this...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.12 2006/01/01 19:06:43 brad Exp $ */
d118 1
a118 4
fxp_cardbus_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d126 1
a126 3
fxp_cardbus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d145 2
a146 2
         * Map control/status registers.
         */
d196 1
a196 1
fxp_cardbus_setup(struct fxp_softc * sc)
d230 1
a230 3
fxp_cardbus_detach(self, flags)
	struct device *self;
	int flags;
@


1.12
log
@update for pcidevs name change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.11 2005/05/16 01:36:25 brad Exp $ */
a132 2
	static const char thisfunc[] = "fxp_cardbus_attach";

d166 1
a166 1
		panic("%s: failed to allocate mem and io space", thisfunc);
@


1.11
log
@Use cardbus_matchbyid().

ok millert@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.10 2005/01/14 01:06:16 pvalchev Exp $ */
d41 1
a41 1
 * CardBus front-end for the Intel i82557 family of Ethernet chips.
d108 1
a108 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82557 },
@


1.10
log
@minor prototypes style; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.9 2004/10/07 21:16:59 brad Exp $ */
d107 4
d123 3
a125 7
	struct cardbus_attach_args *ca = aux;

	if (CARDBUS_VENDOR(ca->ca_id) == PCI_VENDOR_INTEL &&
	    CARDBUS_PRODUCT(ca->ca_id) == PCI_PRODUCT_INTEL_82557)
		return (1);

	return (0);
@


1.9
log
@cardbusdevs -> pcidevs

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.8 2004/08/04 19:42:30 mickey Exp $ */
d91 2
a92 2
int fxp_cardbus_detach(struct device * self, int flags);
void fxp_cardbus_setup(struct fxp_softc * sc);
@


1.8
log
@interrupt coalescing on post 82557 chips; from freebsd via Dmitry Bogdan <dsb@@poi.dvo.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.7 2004/06/27 02:38:37 brad Exp $ */
a87 1
#include <dev/cardbus/cardbusdevs.h>
d121 2
a122 2
	if (CARDBUS_VENDOR(ca->ca_id) == CARDBUS_VENDOR_INTEL &&
	    CARDBUS_PRODUCT(ca->ca_id) == CARDBUS_PRODUCT_INTEL_82557)
a181 2

	sc->not_82557 = 1;
@


1.7
log
@stop passing an empty enaddr around since we figure out the
MAC address in the common attach code and not the PCI/CardBus
specific portions, this was a side effect of the code being
split to support CardBus.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.6 2004/05/07 23:33:39 brad Exp $ */
d199 2
@


1.6
log
@CardBus fxp's use the 82558 chipset which has a Long Receive bit,
we need to enable this to receive VLAN sized frames.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.5 2002/10/12 01:09:44 krw Exp $ */
a145 1
	u_int8_t enaddr[6];
d200 1
a200 1
	fxp_attach_common(sc, enaddr, intrstr);
@


1.5
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.4 2002/03/14 01:26:53 millert Exp $ */
d184 2
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.3 2001/08/09 21:12:51 jason Exp $ */
d248 1
a248 1
		panic("%s: data structure lacks\n", sc->sc_dev.dv_xname);
@


1.3
log
@- scb_wait() is now time based (not cpu speed based)
- rearrange multicast setup to be part of init
- convert cu operations to bus_dma(9) (still have to do RFA ops).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.2 2000/09/17 17:08:16 aaron Exp $ */
d90 4
a93 4
int fxp_cardbus_match __P((struct device *, void *, void *));
void fxp_cardbus_attach __P((struct device *, struct device *, void *));
int fxp_cardbus_detach __P((struct device * self, int flags));
void fxp_cardbus_setup __P((struct fxp_softc * sc));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.3 2001/08/09 21:12:51 jason Exp $ */
d90 4
a93 4
int fxp_cardbus_match(struct device *, void *, void *);
void fxp_cardbus_attach(struct device *, struct device *, void *);
int fxp_cardbus_detach(struct device * self, int flags);
void fxp_cardbus_setup(struct fxp_softc * sc);
@


1.3.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.3.4.1 2002/06/11 03:42:16 art Exp $ */
d248 1
a248 1
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
@


1.2
log
@Support detach of fxp devices to allow ejection of Intel CardBus adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.1 2000/09/17 05:11:12 aaron Exp $ */
d178 1
a179 1
	sc->sc_dmat = ca->ca_dmat;
@


1.2.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.2 2000/09/17 17:08:16 aaron Exp $ */
@


1.2.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.2.6.1 2001/05/14 22:23:13 niklas Exp $ */
d178 1
a179 1
#if 0
@


1.2.6.3
log
@cardbus too got skipped by cvs for some reason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_cardbus.c,v 1.2.6.2 2001/10/31 03:22:40 nate Exp $ */
d90 4
a93 4
int fxp_cardbus_match(struct device *, void *, void *);
void fxp_cardbus_attach(struct device *, struct device *, void *);
int fxp_cardbus_detach(struct device * self, int flags);
void fxp_cardbus_setup(struct fxp_softc * sc);
@


1.2.6.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d248 1
a248 1
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
@


1.2.6.5
log
@Merge with the trunk
@
text
@a184 2
	sc->not_82557 = 1;

@


1.1
log
@Add support for Intel PRO/100 CardBus PC Card Ethernet; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a250 1
#if 0
a251 1
#endif
@

