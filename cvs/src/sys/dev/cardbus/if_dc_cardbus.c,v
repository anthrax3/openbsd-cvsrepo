head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.10
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.40.0.8
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.36.0.4
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.16
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.14
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.10
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.8
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.6
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.4
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.12
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.40
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.39;
commitid	5gdEnqVoJuTuwdTu;

1.39
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.38;
commitid	5DvsamK0GblTp8ww;

1.38
date	2015.05.04.03.59.42;	author jsg;	state Exp;
branches;
next	1.37;
commitid	a8MWvErr5z5NNDlo;

1.37
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.36;
commitid	p4LJxGKbi0BU2cG6;

1.36
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.35;
commitid	uzzBR7hz9ncd4O6G;

1.35
date	2011.04.02.17.47.04;	author jasper;	state Exp;
branches;
next	1.34;

1.34
date	2010.08.31.17.01.15;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.26.16.58.46;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.02.15.39.35;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.11.06.49.14;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.11.04.32.23;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2008.01.16.03.39.04;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.08.00.04.47;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.23.19.33.28;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.15.20.53.32;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.29.07.54.33;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.16.01.36.25;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.16.20.47.44;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.16.19.46.01;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.14.15.04.52;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.07.21.16.59;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.18.00.13.02;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.29.21.39.34;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.23.17.34.14;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.09.03.14.17;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.16.21.29.54;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.22.02.32.48;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.06.05.42.12;	author jason;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.08.22.16.38.38;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.06.17.14.14;	author aaron;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.03.25.06.12.28;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.27.18.48.27;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.26.22.37.04;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.26.20.50.44;	author aaron;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.23.13;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.29.23.39.33;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.05.13.19.34.57;	author ho;	state Exp;
branches;
next	;

1.7.2.1
date	2002.01.31.22.55.30;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.05.19.22.01.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.40
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_dc_cardbus.c,v 1.39 2015/11/24 13:33:17 mpi Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_dc.c,v 1.5 2000/01/12 22:24:05 wpaul Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

#include <dev/ic/dcreg.h>

/* PCI configuration regs */
#define	PCI_CBIO	0x10
#define	PCI_CBMEM	0x14
#define	PCI_CFDA	0x40

#define	DC_CFDA_SUSPEND	0x80000000
#define	DC_CFDA_STANDBY	0x40000000

struct dc_cardbus_softc {
	struct dc_softc		sc_dc;
	int			sc_intrline;

	cardbus_devfunc_t	sc_ct;
	pci_chipset_tag_t	sc_pc;
	pcitag_t		sc_tag;
	bus_size_t		sc_mapsize;
	int			sc_actype;
};

int dc_cardbus_match(struct device *, void *, void *);
void dc_cardbus_attach(struct device *, struct device *,void *);
int dc_cardbus_detach(struct device *, int);

void dc_cardbus_setup(struct dc_cardbus_softc *csc);

struct cfattach dc_cardbus_ca = {
	sizeof(struct dc_cardbus_softc), dc_cardbus_match, dc_cardbus_attach,
	dc_cardbus_detach, dc_activate
};

const struct pci_matchid dc_cardbus_devices[] = {
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21142 },
	{ PCI_VENDOR_XIRCOM, PCI_PRODUCT_XIRCOM_X3201_3_21143 },
	{ PCI_VENDOR_ADMTEK, PCI_PRODUCT_ADMTEK_AN985 },
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_EN2242 },
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_FE2500 },
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_FE2500MX },
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_PCM200 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DRP32TXD },
	{ PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_PCMPC200 },
	{ PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_PCM200 },
	{ PCI_VENDOR_HAWKING, PCI_PRODUCT_HAWKING_PN672TX },
	{ PCI_VENDOR_MICROSOFT, PCI_PRODUCT_MICROSOFT_MN120 },
};

int
dc_cardbus_match(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid((struct cardbus_attach_args *)aux,
	    dc_cardbus_devices, nitems(dc_cardbus_devices)));
}

void
dc_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct dc_cardbus_softc *csc = (struct dc_cardbus_softc *)self;
	struct dc_softc *sc = &csc->sc_dc;
	struct cardbus_attach_args *ca = aux;
	struct cardbus_devfunc *ct = ca->ca_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = ca->ca_pc;
	cardbus_function_tag_t cf = ct->ct_cf;
	pcireg_t reg;
	bus_addr_t addr;

	sc->sc_dmat = ca->ca_dmat;
	csc->sc_ct = ct;
	csc->sc_tag = ca->ca_tag;
	csc->sc_pc = ca->ca_pc;

	Cardbus_function_enable(ct);

	if (Cardbus_mapreg_map(ct, PCI_CBIO,
	    PCI_MAPREG_TYPE_IO, 0, &sc->dc_btag, &sc->dc_bhandle, &addr,
	    &csc->sc_mapsize) == 0) {

		csc->sc_actype = CARDBUS_IO_ENABLE;
	} else if (Cardbus_mapreg_map(ct, PCI_CBMEM,
	    PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &sc->dc_btag, &sc->dc_bhandle, &addr, &csc->sc_mapsize) == 0) {
		csc->sc_actype = CARDBUS_MEM_ENABLE;
	} else {
		printf(": can't map device registers\n");
		return;
	}

	csc->sc_intrline = ca->ca_intrline;

	sc->dc_cachesize = pci_conf_read(csc->sc_pc, ca->ca_tag, DC_PCI_CFLT)
	    & 0xFF;

	dc_cardbus_setup(csc);

	/* Get the eeprom width */
	if ((PCI_VENDOR(ca->ca_id) == PCI_VENDOR_XIRCOM &&
	      PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_XIRCOM_X3201_3_21143))
		;	/* XIRCOM has non-standard eeprom */
	else
		dc_eeprom_width(sc);

	switch (PCI_VENDOR(ca->ca_id)) {
	case PCI_VENDOR_DEC:
		if (PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_DEC_21142) {
			sc->dc_type = DC_TYPE_21143;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			dc_read_srom(sc, sc->dc_romwidth);
			dc_parse_21143_srom(sc);
		}
		break;
	case PCI_VENDOR_XIRCOM:
		if (PCI_PRODUCT(ca->ca_id) ==
		    PCI_PRODUCT_XIRCOM_X3201_3_21143) {
			sc->dc_type = DC_TYPE_XIRCOM;
			sc->dc_flags |= DC_TX_INTR_ALWAYS|DC_TX_COALESCE |
					DC_TX_ALIGN;
			sc->dc_pmode = DC_PMODE_MII;
		}
		break;
	case PCI_VENDOR_ADMTEK:
	case PCI_VENDOR_ACCTON:
	case PCI_VENDOR_ABOCOM:
	case PCI_VENDOR_DLINK:
	case PCI_VENDOR_LINKSYS:
	case PCI_VENDOR_HAWKING:
	case PCI_VENDOR_MICROSOFT:
		if (PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_ADMTEK_AN985 ||
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_ACCTON_EN2242 ||
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_ABOCOM_FE2500 ||
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_ABOCOM_FE2500MX ||
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_ABOCOM_PCM200 ||
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_DLINK_DRP32TXD ||
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_LINKSYS_PCMPC200 ||
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_LINKSYS_PCM200 ||
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_HAWKING_PN672TX ||
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_MICROSOFT_MN120) {
			sc->dc_type = DC_TYPE_AN983;
			sc->dc_flags |= DC_TX_USE_TX_INTR|DC_TX_ADMTEK_WAR |
					DC_64BIT_HASH;
			sc->dc_pmode = DC_PMODE_MII;
			/* Don't read SROM for - auto-loaded on reset */
		}
		break;
	default:
		printf(": unknown device\n");
		return;
	}

 	/*
	 * set latency timer, do we really need this?
	 */
	reg = pci_conf_read(pc, ca->ca_tag, PCI_BHLC_REG);
	if (PCI_LATTIMER(reg) < 0x20) {
		reg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
		reg |= (0x20 << PCI_LATTIMER_SHIFT);
		pci_conf_write(pc, ca->ca_tag, PCI_BHLC_REG, reg);
	}

	sc->sc_ih = cardbus_intr_establish(cc, cf, ca->ca_intrline, IPL_NET,
	    dc_intr, csc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt at %d\n",
		    ca->ca_intrline);
		return;
	}
	printf(": irq %d", ca->ca_intrline);

	dc_reset(sc);

	sc->dc_revision = PCI_REVISION(ca->ca_class);
	dc_attach(sc);
}

int
dc_cardbus_detach(struct device *self, int flags)
{
	struct dc_cardbus_softc *csc = (struct dc_cardbus_softc *)self;
	struct dc_softc *sc = &csc->sc_dc;
	struct cardbus_devfunc *ct = csc->sc_ct;

	cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, sc->sc_ih);
	dc_detach(sc);

	/* unmap cardbus resources */
	Cardbus_mapreg_unmap(ct,
	    csc->sc_actype == CARDBUS_IO_ENABLE ? PCI_CBIO : PCI_CBMEM,
	    sc->dc_btag, sc->dc_bhandle, csc->sc_mapsize);

	return (0);
}

void
dc_cardbus_setup(struct dc_cardbus_softc *csc)
{
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = csc->sc_pc;
	pcireg_t reg;
	int r;

	/* wakeup the card if needed */
	reg = pci_conf_read(pc, csc->sc_tag, PCI_CFDA);
	if (reg & (DC_CFDA_SUSPEND|DC_CFDA_STANDBY)) {
		pci_conf_write(pc, csc->sc_tag, PCI_CFDA,
		    reg & ~(DC_CFDA_SUSPEND|DC_CFDA_STANDBY));
	}

	if (pci_get_capability(csc->sc_pc, csc->sc_tag, PCI_CAP_PWRMGMT, &r,
	    0)) {
		r = pci_conf_read(csc->sc_pc, csc->sc_tag, r + 4) & 3;
		if (r) {
			printf("%s: awakening from state D%d\n",
			    csc->sc_dc.sc_dev.dv_xname, r);
			pci_conf_write(csc->sc_pc, csc->sc_tag, r + 4, 0);
		}
	}

	(*ct->ct_cf->cardbus_ctrl)(cc, csc->sc_actype);
	(*ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	reg = pci_conf_read(csc->sc_pc, csc->sc_tag, PCI_COMMAND_STATUS_REG);
	reg |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(csc->sc_pc, csc->sc_tag, PCI_COMMAND_STATUS_REG, reg);
	reg = pci_conf_read(csc->sc_pc, csc->sc_tag, PCI_COMMAND_STATUS_REG);
}
@


1.39
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.38 2015/05/04 03:59:42 jsg Exp $	*/
a47 1
#include <net/if_dl.h>
@


1.38
log
@Fix some misuse of the | operator.  In particular | has higher
precedence than ?:
ok guenther@@ krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.37 2015/03/14 03:38:47 jsg Exp $	*/
a48 1
#include <net/if_types.h>
@


1.37
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.36 2014/09/14 14:17:24 jsg Exp $	*/
d269 1
a269 1
	if (reg | (DC_CFDA_SUSPEND|DC_CFDA_STANDBY)) {
@


1.36
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.35 2011/04/02 17:47:04 jasper Exp $	*/
a54 1
#include <dev/mii/mii.h>
@


1.35
log
@- use nitems(); no binary change@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.34 2010/08/31 17:01:15 deraadt Exp $	*/
a44 1
#include <sys/proc.h>
@


1.34
log
@When cardbus is fixed, this will be able to use dc_activate directly
(I stronly hope that cardbus needs no bus-specific wrappers!)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.33 2010/03/27 21:40:13 jsg Exp $	*/
d118 1
a118 2
	    dc_cardbus_devices,
	    sizeof(dc_cardbus_devices)/sizeof(dc_cardbus_devices[0])));
@


1.33
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.32 2010/03/27 20:04:03 jsg Exp $	*/
d96 1
a96 1
	    dc_cardbus_detach
@


1.32
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.31 2010/03/22 22:28:27 jsg Exp $	*/
d82 1
d130 1
d138 1
d158 1
a158 1
	sc->dc_cachesize = cardbus_conf_read(cc, cf, ca->ca_tag, DC_PCI_CFLT)
d221 1
a221 1
	reg = cardbus_conf_read(cc, cf, ca->ca_tag, PCI_BHLC_REG);
d225 1
a225 1
		cardbus_conf_write(cc, cf, ca->ca_tag, PCI_BHLC_REG, reg);
d266 1
a266 1
	cardbus_function_tag_t cf = ct->ct_cf;
d271 1
a271 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, PCI_CFDA);
d273 1
a273 1
		cardbus_conf_write(cc, cf, csc->sc_tag, PCI_CFDA,
d277 1
a277 1
	if (cardbus_get_capability(cc, cf, csc->sc_tag, PCI_CAP_PWRMGMT, &r,
d279 1
a279 1
		r = cardbus_conf_read(cc, cf, csc->sc_tag, r + 4) & 3;
d283 1
a283 1
			cardbus_conf_write(cc, cf, csc->sc_tag, r + 4, 0);
d290 1
a290 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, PCI_COMMAND_STATUS_REG);
d293 2
a294 2
	cardbus_conf_write(cc, cf, csc->sc_tag, PCI_COMMAND_STATUS_REG, reg);
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, PCI_COMMAND_STATUS_REG);
@


1.31
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.30 2009/10/15 17:54:56 deraadt Exp $	*/
d128 1
a128 1
	pci_chipset_tag_t cc = ct->ct_cc;
d262 1
a262 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.30
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.29 2009/06/26 16:58:46 deraadt Exp $	*/
d82 1
a82 1
	cardbustag_t		sc_tag;
d98 1
a98 1
const struct cardbus_matchid dc_cardbus_devices[] = {
d128 1
a128 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d130 1
a130 1
	cardbusreg_t reg;
d262 1
a262 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d264 1
a264 1
	cardbusreg_t reg;
@


1.29
log
@Using information gleamed from the FreeBSD driver, change the MAC address
reading to use the eeprom instead of CIS, and then the Xircom Cardbus cards
can work in the expresscard adaptor, as pci devices.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.28 2009/06/02 15:39:35 jsg Exp $	*/
a245 5
	int rv = 0;

	rv = dc_detach(sc);
	if (rv)
		return (rv);
d248 1
d255 1
a255 1
	return (rv);
@


1.28
log
@make dc at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.27 2008/09/11 06:49:14 brad Exp $	*/
d160 2
a161 2
	/* Get the eeprom width, but XIRCOM has no eeprom */
	if (!(PCI_VENDOR(ca->ca_id) == PCI_VENDOR_XIRCOM &&
d163 2
a183 4

			bcopy(ca->ca_cis.funce.network.netid,
			    &sc->sc_arpcom.ac_enaddr,
			    sizeof sc->sc_arpcom.ac_enaddr);
@


1.27
log
@ANSI function declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.26 2008/09/11 04:32:23 brad Exp $	*/
a239 24
}

int
dc_detach(struct dc_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	if (sc->dc_srom)
		free(sc->dc_srom, M_DEVBUF);

	timeout_del(&sc->dc_tick_tmo);

	ether_ifdetach(ifp);
	if_detach(ifp);

	if (sc->sc_dhook != NULL)
		shutdownhook_disestablish(sc->sc_dhook);
	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);

	return (0);
@


1.26
log
@Add missing license. Copy the license used elsewhere with the dc(4) driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.25 2008/01/16 03:39:04 brad Exp $	*/
d114 1
a114 3
dc_cardbus_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d122 1
a122 3
dc_cardbus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d243 1
a243 2
dc_detach(sc)
	struct dc_softc *sc;
d267 1
a267 3
dc_cardbus_detach(self, flags)
	struct device *self;
	int flags;
d289 1
a289 2
dc_cardbus_setup(csc)
	struct dc_cardbus_softc *csc;
@


1.25
log
@- Remove a unwanted slash from a error message printf
- Fix interrupt string printing in the dmesg output

ok dlg@@
@
text
@d1 35
a35 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.24 2007/05/08 00:04:47 deraadt Exp $	*/
@


1.24
log
@dc_detach() is only used by cardbus code, so move it there; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.23 2006/10/12 16:35:52 grange Exp $	*/
d119 1
a119 1
		printf(": can\'t map device registers\n");
d203 2
a204 2
	} else
		printf(" irq %d", ca->ca_intrline);
@


1.23
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.22 2006/04/23 19:33:28 brad Exp $	*/
d210 25
@


1.22
log
@Recognize the D-Link DRP32TXD CardBus adapter. It is another
ADMTek AN983 clone.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.21 2005/06/15 20:53:32 brad Exp $	*/
d198 1
a198 1
	    dc_intr, csc);
@


1.21
log
@add Linksys PCMPC200
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.20 2005/05/29 07:54:33 brad Exp $	*/
d72 1
d161 1
d170 1
@


1.20
log
@- better pcidevs entries for Intel Gig and add 82573 ids
- add/fix up Abocom enries
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.19 2005/05/16 01:36:25 brad Exp $	*/
d72 1
d168 1
@


1.19
log
@Use cardbus_matchbyid().

ok millert@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.18 2005/01/16 20:47:44 brad Exp $	*/
d70 1
d165 1
@


1.18
log
@- recognize Microsoft PCI and CardBus adapters
- recognize Hawking CardBus adapter
- simplify 3Com switch case and fold in with ADMtek case
- use 64-bit multicast hash for all instances of ADMtek 983 chipset

Hawking CardBus adapter reported by Alec Berryman <alec at thened dot net>
Microsoft adapters from FreeBSD dc(4) driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.17 2005/01/16 19:46:01 brad Exp $	*/
d64 1
a64 1
struct dc_type dc_cardbus_devs[] = {
a73 1
	{ 0 }
d81 3
a83 10
	struct cardbus_attach_args *ca = aux;
	struct dc_type *t;

	for (t = dc_cardbus_devs; t->dc_vid != 0; t++) {
		if ((PCI_VENDOR(ca->ca_id) == t->dc_vid) &&
		    (PCI_PRODUCT(ca->ca_id) == t->dc_did))
			return (1);
	}

	return (0);
@


1.17
log
@get EEPROM width on all cards except for the original PNIC
or XIRCOM cards.

Based on the FreeBSD dc(4) driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.16 2005/01/14 15:04:52 brad Exp $	*/
d72 2
d167 2
d173 3
a175 1
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_LINKSYS_PCM200) {
d177 2
a178 1
			sc->dc_flags |= DC_TX_USE_TX_INTR|DC_TX_ADMTEK_WAR;
@


1.16
log
@rev 1.63

Avoid an unnecessary copy of a packet if it is already in a single mbuf.
Introduce an additional device flag for those NICs which require the
transmit buffers to be aligned to 32-bit boundaries.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.15 2004/10/07 21:16:59 brad Exp $	*/
d133 5
a143 1
			dc_eeprom_width(sc);
d173 1
a173 2
			dc_eeprom_width(sc);
			dc_read_srom(sc, sc->dc_romwidth);
@


1.15
log
@cardbusdevs -> pcidevs

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.14 2004/09/18 00:13:02 brad Exp $	*/
d148 2
a149 1
			sc->dc_flags |= DC_TX_INTR_ALWAYS|DC_TX_COALESCE;
@


1.14
log
@add Linksys PCM200

From: Chuck Gagnon <gagnocg at mac dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.13 2003/04/29 21:39:34 jason Exp $	*/
a31 1
#include <dev/cardbus/cardbusdevs.h>
d69 3
a71 3
	{ CARDBUS_VENDOR_ABOCOM, CARDBUS_PRODUCT_ABOCOM_FE2500 },
	{ CARDBUS_VENDOR_ABOCOM, CARDBUS_PRODUCT_ABOCOM_PCM200 },
	{ CARDBUS_VENDOR_LINKSYS, CARDBUS_PRODUCT_LINKSYS_PCM200 },
d158 2
a159 2
	case CARDBUS_VENDOR_ABOCOM:
	case CARDBUS_VENDOR_LINKSYS:
d162 3
a164 3
		    PCI_PRODUCT(ca->ca_id) == CARDBUS_PRODUCT_ABOCOM_FE2500 ||
		    PCI_PRODUCT(ca->ca_id) == CARDBUS_PRODUCT_ABOCOM_PCM200 ||
		    PCI_PRODUCT(ca->ca_id) == CARDBUS_PRODUCT_LINKSYS_PCM200) {
@


1.13
log
@- remove last vestige of "old autoconf": dc_unit is dead, long live dv_xname
- remove a bunch of #if 0 stuff (most of which referred to dc_unit, grr)
- delay a bzero until necessary
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.12 2002/07/23 17:34:14 drahn Exp $	*/
d72 1
d160 1
d164 2
a165 1
		    PCI_PRODUCT(ca->ca_id) == CARDBUS_PRODUCT_ABOCOM_PCM200) {
@


1.12
log
@Use the proper cardbus_conf_read() rather than pci (in a cardbus driver).
ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.11 2002/06/09 03:14:17 todd Exp $	*/
a106 1
	sc->dc_unit = sc->sc_dev.dv_unit;
@


1.11
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.10 2002/04/16 21:29:54 jason Exp $	*/
d129 2
a130 1
	sc->dc_cachesize = pci_conf_read(cc, ca->ca_tag, DC_PCI_CFLT) & 0xFF;
@


1.10
log
@move prototypes of dc_eeprom_width, dc_read_srom, and dc_parse_21143_srom to dcreg.h and out of the bus specific drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.9 2002/03/14 01:26:53 millert Exp $	*/
d152 2
a153 2
			    &sc->arpcom.ac_enaddr,
			    sizeof sc->arpcom.ac_enaddr);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.8 2001/12/22 02:32:48 fgsch Exp $	*/
a58 4

extern void dc_eeprom_width(struct dc_softc *);
extern void dc_read_srom(struct dc_softc *, int);
extern void dc_parse_21143_srom(struct dc_softc *);
@


1.8
log
@Support for SMC 8036TX 10/100 cardbus NICs; diffs provided by
Chris Riley <chris@@riles.ra>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.7 2001/12/06 05:42:12 jason Exp $	*/
d54 9
a62 9
int dc_cardbus_match		__P((struct device *, void *, void *));
void dc_cardbus_attach		__P((struct device *, struct device *,void *));
int dc_cardbus_detach		__P((struct device *, int));

void dc_cardbus_setup		__P((struct dc_cardbus_softc *csc));

extern void dc_eeprom_width	__P((struct dc_softc *));
extern void dc_read_srom	__P((struct dc_softc *, int));
extern void dc_parse_21143_srom	__P((struct dc_softc *));
@


1.7
log
@Checkpoint bus_dma work in progress:
- descriptor lists are now bus_dma allocated and manipulated
(for those keeping score: 6 vtophys dead, 4 to go)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.6 2001/08/22 16:38:38 aaron Exp $	*/
d73 1
d161 1
d164 1
@


1.7.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.8 2001/12/22 02:32:48 fgsch Exp $	*/
a72 1
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_EN2242 },
a159 1
	case PCI_VENDOR_ACCTON:
a161 1
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_ACCTON_EN2242 ||
@


1.7.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.7.2.1 2002/01/31 22:55:30 niklas Exp $	*/
d54 9
a62 5
int dc_cardbus_match(struct device *, void *, void *);
void dc_cardbus_attach(struct device *, struct device *,void *);
int dc_cardbus_detach(struct device *, int);

void dc_cardbus_setup(struct dc_cardbus_softc *csc);
d156 2
a157 2
			    &sc->sc_arpcom.ac_enaddr,
			    sizeof sc->sc_arpcom.ac_enaddr);
@


1.7.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.7.2.2 2002/06/11 03:42:16 art Exp $	*/
d129 1
a129 2
	sc->dc_cachesize = cardbus_conf_read(cc, cf, ca->ca_tag, DC_PCI_CFLT)
	    & 0xFF;
@


1.7.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 1
@


1.6
log
@Support more dc(4) CardBus devices, including the AN985-based Linksys PCMPC200
10/100 CardBus Ethernet adapter (thanks to beck@@ for the donation).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.5 2001/04/06 17:14:14 aaron Exp $	*/
d109 1
@


1.5
log
@- For CardBus 21143 cards, parse the SROM. Makes my SMC EZ CardBus 10/100 work.
- General cleanup in the dc CardBus attachment.
- Split detach up into bus-dependent and bus-independent parts.
- Some function and variable renaming for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.4 2001/03/25 06:12:28 csapuntz Exp $	*/
d73 2
d159 4
a162 1
		if (PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_ADMTEK_AN985) {
d167 1
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.5 2001/04/06 17:14:14 aaron Exp $	*/
@


1.5.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.5.4.1 2001/05/14 22:23:13 niklas Exp $	*/
a72 2
	{ CARDBUS_VENDOR_ABOCOM, CARDBUS_PRODUCT_ABOCOM_FE2500 },
	{ CARDBUS_VENDOR_ABOCOM, CARDBUS_PRODUCT_ABOCOM_PCM200 },
d157 1
a157 4
	case CARDBUS_VENDOR_ABOCOM:
		if (PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_ADMTEK_AN985 ||
		    PCI_PRODUCT(ca->ca_id) == CARDBUS_PRODUCT_ABOCOM_FE2500 ||
		    PCI_PRODUCT(ca->ca_id) == CARDBUS_PRODUCT_ABOCOM_PCM200) {
a161 1
			dc_read_srom(sc, sc->dc_romwidth);
@


1.5.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a72 1
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_EN2242 },
a108 1
	sc->sc_dmat = ca->ca_dmat;
a158 1
	case PCI_VENDOR_ACCTON:
a160 1
		    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_ACCTON_EN2242 ||
@


1.5.4.4
log
@cardbus too got skipped by cvs for some reason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.5.4.3 2002/03/06 02:11:42 niklas Exp $	*/
d54 9
a62 9
int dc_cardbus_match(struct device *, void *, void *);
void dc_cardbus_attach(struct device *, struct device *,void *);
int dc_cardbus_detach(struct device *, int);

void dc_cardbus_setup(struct dc_cardbus_softc *csc);

extern void dc_eeprom_width(struct dc_softc *);
extern void dc_read_srom(struct dc_softc *, int);
extern void dc_parse_21143_srom(struct dc_softc *);
@


1.5.4.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 4
d133 1
a133 2
	sc->dc_cachesize = cardbus_conf_read(cc, cf, ca->ca_tag, DC_PCI_CFLT)
	    & 0xFF;
d156 2
a157 2
			    &sc->sc_arpcom.ac_enaddr,
			    sizeof sc->sc_arpcom.ac_enaddr);
@


1.5.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.5.4.5 2003/03/28 00:38:10 niklas Exp $	*/
d107 1
@


1.4
log
@lower spl on error exit. Thanks to dawson and team for finding this one
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.3 2000/10/27 18:48:27 nate Exp $	*/
d44 8
a51 8
struct	dc_cardbus_softc {
	struct dc_softc sc_dc;
	int	sc_intrline;

	cardbus_devfunc_t sc_ct;
	cardbustag_t sc_tag;
	bus_size_t sc_mapsize;
	int sc_actype;
d54 9
a62 5
int dc_cardbus_match __P((struct device *, void *, void *));
void dc_cardbus_attach __P((struct device *, struct device *,void *));
int dc_cardbus_detach __P((struct device *, int));
int dc_cardbus_activate __P((struct device *, enum devact));
void dc_cardbus_setup __P((struct dc_cardbus_softc *csc));
d65 2
a66 3
	sizeof(struct dc_cardbus_softc), dc_cardbus_match,
		dc_cardbus_attach, dc_cardbus_detach,
		dc_cardbus_activate
d113 20
d139 3
a141 2

			sc->dc_pmode = DC_PMODE_MII;
d161 1
a168 21
	if (Cardbus_mapreg_map(ct, PCI_CBIO,
	    PCI_MAPREG_TYPE_IO, 0, &sc->dc_btag, &sc->dc_bhandle, &addr,
	    &csc->sc_mapsize) == 0) {

		csc->sc_actype = CARDBUS_IO_ENABLE;
	} else if (Cardbus_mapreg_map(ct, PCI_CBMEM,
	    PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &sc->dc_btag, &sc->dc_bhandle, &addr, &csc->sc_mapsize) == 0) {
		csc->sc_actype = CARDBUS_MEM_ENABLE;
	} else {
		printf(": can\'t map device registers\n");
		return;
	}

	csc->sc_intrline = ca->ca_intrline;

	sc->dc_cachesize = pci_conf_read(cc, ca->ca_tag, DC_PCI_CFLT) & 0xFF;

	dc_cardbus_setup(csc);
	cardbus_save_bar(ct);

d172 5
a176 5
	reg = cardbus_conf_read(cc, cf, ca->ca_tag, CARDBUS_BHLC_REG);
	if (CARDBUS_LATTIMER(reg) < 0x20) {
		reg &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
		reg |= (0x20 << CARDBUS_LATTIMER_SHIFT);
		cardbus_conf_write(cc, cf, ca->ca_tag, CARDBUS_BHLC_REG, reg);
d179 2
a180 2
	sc->sc_ih = cardbus_intr_establish(cc, cf,
	    ca->ca_intrline, IPL_NET, dc_intr, csc);
d182 1
a182 1
		printf(": can\'t establish interrupt at %d\n",
d190 2
a191 2
	sc->dc_revision = CARDBUS_REVISION(ca->ca_class);
	dc_attach_common(sc);
a201 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d204 5
a208 2
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);
a214 3
	ether_ifdetach(ifp);
	if_detach(ifp);

a217 40
int
dc_cardbus_activate(dev, act)
	struct device *dev;
	enum devact act;
{
	struct dc_cardbus_softc *csc = (struct dc_cardbus_softc *)dev;
	struct dc_softc *sc = &csc->sc_dc;
	cardbus_devfunc_t ct = csc->sc_ct;
	int s;

	s = splnet();
	switch (act) {
	case DVACT_ACTIVATE:
		Cardbus_function_enable(ct);
		cardbus_restore_bar(ct);
		dc_cardbus_setup(csc);
		sc->sc_ih = cardbus_intr_establish(ct->ct_cc, ct->ct_cf,
		    csc->sc_intrline, IPL_NET, dc_intr, csc);
		if (sc->sc_ih == NULL) {
			printf(": can\'t establish interrupt at %d\n",
			    csc->sc_intrline);
			Cardbus_function_disable(ct);
			splx(s);
			return -1;
		} else
			printf("%s: interrupting at %d",
			    sc->sc_dev.dv_xname, csc->sc_intrline);
		break;

	case DVACT_DEACTIVATE:
		cardbus_save_bar(ct);
		cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, sc->sc_ih);
		Cardbus_function_disable(ct);
		break;
	}

	splx(s);
	return 0;
}

a232 3
#if 0
printf("wakeup %x\n", cardbus_conf_read(cc, cf, csc->sc_tag, PCI_CFDA));
#endif
d235 2
a236 1
	if (cardbus_get_capability(cc, cf, csc->sc_tag, PCI_CAP_PWRMGMT, &r, 0)) {
d248 5
a252 5
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG);
	reg |= CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MEM_ENABLE |
	    CARDBUS_COMMAND_MASTER_ENABLE;
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG, reg);
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG);
@


1.3
log
@Make cardbus version of dc detach properly.  OK aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.2 2000/10/26 22:37:04 aaron Exp $	*/
d237 1
@


1.2
log
@Add support for ADMtek AN985 Centaur-C CardBus Ethernet interfaces. Thanks for
ADMtek for sending me a couple demo boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_cardbus.c,v 1.1 2000/10/26 20:50:44 aaron Exp $	*/
a198 3
#if 0
	struct mii_softc *msc;
#endif
d201 2
a202 5
#if 0
	for (msc = LIST_FIRST(&sc->sc_mii.mii_phys); msc;
	    msc = LIST_FIRST(&sc->sc_mii.mii_phys))
		rv |= mii_detach(msc, flags);
#endif
@


1.1
log
@Add support for Xircom X3201-based CardBus Ethernet cards. Tested successfully
on four different models, including the CBEM56G-100, RBE-100 RealPort, and the
RBEM56G-100 RealPort. This commit adds support only for the LAN components; the
modem is not configured yet. Detach support to come. Based on work from
FreeBSD, mickey@@, nate@@, and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
d130 7
@

