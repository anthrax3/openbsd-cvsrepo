head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.2
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.22
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.20
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.18
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.16
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.15
date	2017.01.12.16.32.28;	author stsp;	state Exp;
branches;
next	1.14;
commitid	1Zd7y0b8dZf1uELZ;

1.14
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.13;
commitid	5gdEnqVoJuTuwdTu;

1.13
date	2011.01.08.10.02.32;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.31.14.52.47;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.31.14.06.05;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.06.19.20.21;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.16.15.06.22;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.02.17.16.47;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.22.16.11.26;	author sthen;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.22.11.24.19;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.23.19.11.06;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.14.16.55.11;	author damien;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Finish initial 11n support for athn(4).

The heavy lifting was done by damien@@ years ago. I didn't even have
to figure out what the hardware expects, the code was already there.

This driver now supports MCS 0-15 in client and hostap mode.
No Tx aggregation and no 40 MHz channels yet.

tested by vgross@@, bmercer@@, tb@@, jmc@@, Vadim Vygonets, Peter Kay
ok bmercer@@ tb@@ phessler@@
@
text
@/*	$OpenBSD: if_athn_cardbus.c,v 1.14 2015/11/24 17:11:39 mpi Exp $	*/

/*-
 * Copyright (c) 2009 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * CardBus front-end for Atheros 802.11a/g/n chipsets.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_mira.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/athnreg.h>
#include <dev/ic/athnvar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

struct athn_cardbus_softc {
	struct athn_softc	sc_sc;

	/* CardBus specific goo. */
	cardbus_devfunc_t	sc_ct;
	pcitag_t		sc_tag;
	void			*sc_ih;
	bus_space_tag_t		sc_st;
	bus_space_handle_t	sc_sh;
	bus_size_t		sc_mapsize;
	pcireg_t		sc_bar_val;
	int			sc_intrline;
	pci_chipset_tag_t	sc_pc;
};

int		athn_cardbus_match(struct device *, void *, void *);
void		athn_cardbus_attach(struct device *, struct device *, void *);
int		athn_cardbus_detach(struct device *, int);
int		athn_cardbus_enable(struct athn_softc *);
void		athn_cardbus_disable(struct athn_softc *);
void		athn_cardbus_power(struct athn_softc *, int);
void		athn_cardbus_setup(struct athn_cardbus_softc *);
uint32_t	athn_cardbus_read(struct athn_softc *, uint32_t);
void		athn_cardbus_write(struct athn_softc *, uint32_t, uint32_t);
void		athn_cardbus_write_barrier(struct athn_softc *);

struct cfattach athn_cardbus_ca = {
	sizeof (struct athn_cardbus_softc),
	athn_cardbus_match,
	athn_cardbus_attach,
	athn_cardbus_detach
};

static const struct pci_matchid athn_cardbus_devices[] = {
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5416 },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR5418 },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9160 },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9280 },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9281 },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9285 },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR2427 },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9227 },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9287 },
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9300 }
};

int
athn_cardbus_match(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid(aux, athn_cardbus_devices,
	    nitems(athn_cardbus_devices)));
}

void
athn_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct athn_cardbus_softc *csc = (struct athn_cardbus_softc *)self;
	struct athn_softc *sc = &csc->sc_sc;
	struct cardbus_attach_args *ca = aux;
	cardbus_devfunc_t ct = ca->ca_ct;
	bus_addr_t base;
	int error;

	sc->sc_dmat = ca->ca_dmat;
	csc->sc_ct = ct;
	csc->sc_tag = ca->ca_tag;
	csc->sc_intrline = ca->ca_intrline;
	csc->sc_pc = ca->ca_pc;

	/* Power management hooks. */
	sc->sc_enable = athn_cardbus_enable;
	sc->sc_disable = athn_cardbus_disable;
	sc->sc_power = athn_cardbus_power;

	sc->ops.read = athn_cardbus_read;
	sc->ops.write = athn_cardbus_write;
	sc->ops.write_barrier = athn_cardbus_write_barrier;

	/* Map control/status registers. */
	error = Cardbus_mapreg_map(ct, CARDBUS_BASE0_REG,
	    PCI_MAPREG_TYPE_MEM, 0, &csc->sc_st, &csc->sc_sh, &base,
	    &csc->sc_mapsize);
	if (error != 0) {
		printf(": can't map mem space\n");
		return;
	}
	csc->sc_bar_val = base | PCI_MAPREG_TYPE_MEM;

	/* Set up the PCI configuration registers. */
	athn_cardbus_setup(csc);

	printf(": irq %d\n", csc->sc_intrline);

	athn_attach(sc);
	Cardbus_function_disable(ct);
}

int
athn_cardbus_detach(struct device *self, int flags)
{
	struct athn_cardbus_softc *csc = (struct athn_cardbus_softc *)self;
	struct athn_softc *sc = &csc->sc_sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	athn_detach(sc);

	/* Unhook the interrupt handler. */
	if (csc->sc_ih != NULL)
		cardbus_intr_disestablish(cc, cf, csc->sc_ih);

	/* Release bus space and close window. */
	Cardbus_mapreg_unmap(ct, CARDBUS_BASE0_REG, csc->sc_st, csc->sc_sh,
	    csc->sc_mapsize);

	return (0);
}

int
athn_cardbus_enable(struct athn_softc *sc)
{
	struct athn_cardbus_softc *csc = (struct athn_cardbus_softc *)sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/* Power on the socket. */
	Cardbus_function_enable(ct);

	/* Setup the PCI configuration registers. */
	athn_cardbus_setup(csc);

	/* Map and establish the interrupt handler. */
	csc->sc_ih = cardbus_intr_establish(cc, cf, csc->sc_intrline, IPL_NET,
	    athn_intr, sc, sc->sc_dev.dv_xname);
	if (csc->sc_ih == NULL) {
		printf("%s: could not establish interrupt at %d\n",
		    sc->sc_dev.dv_xname, csc->sc_intrline);
		Cardbus_function_disable(ct);
		return (1);
	}
	return (0);
}

void
athn_cardbus_disable(struct athn_softc *sc)
{
	struct athn_cardbus_softc *csc = (struct athn_cardbus_softc *)sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/* Unhook the interrupt handler. */
	cardbus_intr_disestablish(cc, cf, csc->sc_ih);
	csc->sc_ih = NULL;

	/* Power down the socket. */
	Cardbus_function_disable(ct);
}

void
athn_cardbus_power(struct athn_softc *sc, int why)
{
	struct athn_cardbus_softc *csc = (struct athn_cardbus_softc *)sc;

	if (why == DVACT_RESUME) {
		/* Restore the PCI configuration registers. */
		athn_cardbus_setup(csc);
	}
}

void
athn_cardbus_setup(struct athn_cardbus_softc *csc)
{
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = csc->sc_pc;
	cardbus_function_tag_t cf = ct->ct_cf;
	pcireg_t reg;

	/* Program the BAR. */
	pci_conf_write(pc, csc->sc_tag, CARDBUS_BASE0_REG,
	    csc->sc_bar_val);

	/* Make sure the right access type is on the cardbus bridge. */
	(*cf->cardbus_ctrl)(cc, CARDBUS_MEM_ENABLE);
	(*cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	/* Enable the appropriate bits in the PCI CSR. */
	reg = pci_conf_read(pc, csc->sc_tag,
	    PCI_COMMAND_STATUS_REG);
	reg |= PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_MEM_ENABLE;
	pci_conf_write(pc, csc->sc_tag, PCI_COMMAND_STATUS_REG,
	    reg);

	/*
	 * Noone knows why this shit is necessary but there are claims that
	 * not doing this may cause very frequent PCI FATAL interrupts from
	 * the card: http://bugzilla.kernel.org/show_bug.cgi?id=13483
	 */
	reg = pci_conf_read(pc, csc->sc_tag, 0x40);
	if (reg & 0xff00)
		pci_conf_write(pc, csc->sc_tag, 0x40, reg & ~0xff00);

	/* Change latency timer; default value yields poor results. */
	reg = pci_conf_read(pc, csc->sc_tag, PCI_BHLC_REG);
	reg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
	reg |= 168 << PCI_LATTIMER_SHIFT;
	pci_conf_write(pc, csc->sc_tag, PCI_BHLC_REG, reg);
}

uint32_t
athn_cardbus_read(struct athn_softc *sc, uint32_t addr)
{
	struct athn_cardbus_softc *csc = (struct athn_cardbus_softc *)sc;

	return (bus_space_read_4(csc->sc_st, csc->sc_sh, addr));
}

void
athn_cardbus_write(struct athn_softc *sc, uint32_t addr, uint32_t val)
{
	struct athn_cardbus_softc *csc = (struct athn_cardbus_softc *)sc;

	bus_space_write_4(csc->sc_st, csc->sc_sh, addr, val);
}

void
athn_cardbus_write_barrier(struct athn_softc *sc)
{
	struct athn_cardbus_softc *csc = (struct athn_cardbus_softc *)sc;

	bus_space_barrier(csc->sc_st, csc->sc_sh, 0, csc->sc_mapsize,
	    BUS_SPACE_BARRIER_WRITE);
}
@


1.14
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.13 2011/01/08 10:02:32 damien Exp $	*/
d46 1
@


1.13
log
@clear pci configuration register 0x41 on resume, like during attach.
only clear it if it is != 0 while i'm at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.12 2010/12/31 14:52:47 damien Exp $	*/
a38 1
#include <net/if_dl.h>
@


1.12
log
@move the printing of the MAC address to the same line than the MAC rev.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.11 2010/12/31 14:06:05 damien Exp $	*/
d260 2
a261 2
	reg &= ~0xff00;
	pci_conf_write(pc, csc->sc_tag, 0x40, reg);
@


1.11
log
@Make the athn(4) back-end more bus agnostic by moving read and write
operations to callbacks in the PCI and CardBus front-ends.
This will allow support of other buses like USB.
Assume the following memory model:
- writes are ordered but may be buffered and require explicit flush
- a read always flushes all buffered writes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.10 2010/09/06 19:20:21 deraadt Exp $	*/
d149 1
a149 1
	printf(": irq %d", csc->sc_intrline);
@


1.10
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.9 2010/05/16 15:06:22 damien Exp $	*/
d65 2
d73 10
a82 7
int	athn_cardbus_match(struct device *, void *, void *);
void	athn_cardbus_attach(struct device *, struct device *, void *);
int	athn_cardbus_detach(struct device *, int);
int	athn_cardbus_enable(struct athn_softc *);
void	athn_cardbus_disable(struct athn_softc *);
void	athn_cardbus_power(struct athn_softc *, int);
void	athn_cardbus_setup(struct athn_cardbus_softc *);
d132 4
d138 1
a138 1
	    PCI_MAPREG_TYPE_MEM, 0, &sc->sc_st, &sc->sc_sh, &base,
d171 1
a171 1
	Cardbus_mapreg_unmap(ct, CARDBUS_BASE0_REG, sc->sc_st, sc->sc_sh,
d268 25
@


1.9
log
@add AR9300 PCI Id
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.8 2010/03/27 21:40:13 jsg Exp $	*/
d215 1
a215 1
	if (why == PWR_RESUME) {
@


1.8
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.7 2010/03/27 20:04:03 jsg Exp $	*/
d95 2
a96 1
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9287 }
@


1.7
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.6 2010/03/22 22:28:27 jsg Exp $	*/
d68 1
d119 1
d225 1
d230 1
a230 1
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_BASE0_REG,
d238 1
a238 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag,
d241 1
a241 1
	cardbus_conf_write(cc, cf, csc->sc_tag, PCI_COMMAND_STATUS_REG,
d249 1
a249 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, 0x40);
d251 1
a251 1
	cardbus_conf_write(cc, cf, csc->sc_tag, 0x40, reg);
d254 1
a254 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, PCI_BHLC_REG);
d257 1
a257 1
	cardbus_conf_write(cc, cf, csc->sc_tag, PCI_BHLC_REG, reg);
@


1.6
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.5 2010/02/02 17:16:47 damien Exp $	*/
d149 1
a149 1
	pci_chipset_tag_t cc = ct->ct_cc;
d170 1
a170 1
	pci_chipset_tag_t cc = ct->ct_cc;
d196 1
a196 1
	pci_chipset_tag_t cc = ct->ct_cc;
d222 1
a222 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.5
log
@Attach athn(4) to the AR2427 which is a castrated (no 11n) AR928X.
The Asus Eee PC 1005P has such a device.
This makes things even more confusing since athn now also supports
some non-802.11n devices!
Please let me know if you have such a device.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.4 2009/12/22 16:11:26 sthen Exp $	*/
d63 1
a63 1
	cardbustag_t		sc_tag;
d85 1
a85 1
static const struct cardbus_matchid athn_cardbus_devices[] = {
d126 1
a126 1
	    CARDBUS_MAPREG_TYPE_MEM, 0, &sc->sc_st, &sc->sc_sh, &base,
d132 1
a132 1
	csc->sc_bar_val = base | CARDBUS_MAPREG_TYPE_MEM;
d149 1
a149 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d170 1
a170 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d196 1
a196 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d222 1
a222 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d224 1
a224 1
	cardbusreg_t reg;
d236 3
a238 3
	    CARDBUS_COMMAND_STATUS_REG);
	reg |= CARDBUS_COMMAND_MASTER_ENABLE | CARDBUS_COMMAND_MEM_ENABLE;
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG,
d251 4
a254 4
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG);
	reg &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
	reg |= 168 << CARDBUS_LATTIMER_SHIFT;
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG, reg);
@


1.4
log
@Revert last commit, I should have checked with damien@@ first.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.2 2009/11/23 19:11:06 damien Exp $	*/
d92 1
@


1.3
log
@Sort pci ids, from Brad.
@
text
@a88 1
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9227 },
d92 1
@


1.2
log
@move things from athn_attach() to athn_init() such that we can
power off the cardbus slot after athn_attach() and in athn_stop().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_athn_cardbus.c,v 1.1 2009/11/14 16:55:11 damien Exp $	*/
d89 1
a92 1
	{ PCI_VENDOR_ATHEROS, PCI_PRODUCT_ATHEROS_AR9227 },
@


1.1
log
@athn(4), a driver for Atheros 802.11a/g/n devices.
written from scratch based on the vendor driver for Linux (ath9k).
AR9285 and AR9287 parts are 100% untested.
only basic functionnalities are enabled for now.

committed over an AR9281.

"commit" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a133 1
#ifdef notyet
d135 1
a135 3
#else
	athn_cardbus_enable(sc);
#endif
a138 1
#ifdef notyet
a139 1
#endif
@

