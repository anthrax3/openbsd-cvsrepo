head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.20
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.10
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.18
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.16
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.14
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.12
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.8
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.6
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.3.0.8
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.10
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2011.11.15.22.27.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.27.23.36.36;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.04.21.49.35;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2006.07.31.11.06.27;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Simplify various parts of the puc(4) attachment code.  Tested lightly
by krw and myself.
@
text
@/*	$OpenBSD: puc_cardbus.c,v 1.7 2010/03/27 23:36:36 jsg Exp $	*/

/*
 * Copyright (c) 2006 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/tty.h>

#include <machine/bus.h>
#include <dev/ic/comvar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/cardbus/cardbusvar.h>

#include <dev/pci/pucvar.h>

struct puc_cardbus_softc {
	struct puc_softc sc_psc;

	struct cardbus_devfunc *ct;
	int intrline;
};

int	puc_cardbus_match(struct device *, void *, void *);
void	puc_cardbus_attach(struct device *, struct device *, void *);
int	puc_cardbus_detach(struct device *, int);

const char *puc_cardbus_intr_string(struct puc_attach_args *);
void *puc_cardbus_intr_establish(struct puc_attach_args *, int,
    int (*)(void *), void *, char *);

struct cfattach puc_cardbus_ca = {
	sizeof(struct puc_cardbus_softc), puc_cardbus_match,
	puc_cardbus_attach, puc_cardbus_detach
};

int
puc_cardbus_match(struct device *parent, void *match, void *aux)
{
	struct cardbus_attach_args *ca = aux;
	pci_chipset_tag_t pc = ca->ca_pc;
	pcireg_t bhlc, reg;

	bhlc = pci_conf_read(pc, ca->ca_tag, PCI_BHLC_REG);
	if (PCI_HDRTYPE_TYPE(bhlc) != 0)
		return(0);

	/* this one is some sort of a bridge and not a puc */
	if (PCI_VENDOR(ca->ca_id) == PCI_VENDOR_OXFORD2 &&
	    PCI_PRODUCT(ca->ca_id) == PCI_PRODUCT_OXFORD2_EXSYS_EX41098)
		return (0);

	reg = pci_conf_read(pc, ca->ca_tag, PCI_SUBSYS_ID_REG);
	if (puc_find_description(PCI_VENDOR(ca->ca_id),
	    PCI_PRODUCT(ca->ca_id), PCI_VENDOR(reg), PCI_PRODUCT(reg)))
		return (10);

	return (0);
}

void
puc_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct puc_cardbus_softc *csc = (struct puc_cardbus_softc *)self;
	struct puc_softc *sc = &csc->sc_psc;
	struct cardbus_attach_args *ca = aux;
	struct cardbus_devfunc *ct = ca->ca_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = ca->ca_pc;
	cardbus_function_tag_t cf = ct->ct_cf;
	struct puc_attach_args paa;
	pcireg_t reg;
	int i;

	Cardbus_function_enable(ct);

	csc->ct = ct;

	reg = pci_conf_read(pc, ca->ca_tag, PCI_SUBSYS_ID_REG);
	sc->sc_desc = puc_find_description(PCI_VENDOR(ca->ca_id),
	    PCI_PRODUCT(ca->ca_id), PCI_VENDOR(reg), PCI_PRODUCT(reg));

	puc_print_ports(sc->sc_desc);

	/* the fifth one is some memory we dunno */
	for (i = 0; i < PUC_NBARS; i++) {
		pcireg_t type;
		int bar;

		sc->sc_bar_mappings[i].mapped = 0;
		bar = PCI_MAPREG_START + 4 * i;
		if (!pci_mapreg_probe(pc, ca->ca_tag, bar, &type))
			continue;

		if (!(sc->sc_bar_mappings[i].mapped = !Cardbus_mapreg_map(ct,
		    bar, type, 0,
		    &sc->sc_bar_mappings[i].t, &sc->sc_bar_mappings[i].h,
		    &sc->sc_bar_mappings[i].a, &sc->sc_bar_mappings[i].s)))
			printf("%s: couldn't map BAR at offset 0x%lx\n",
			    sc->sc_dev.dv_xname, (long)bar);
		sc->sc_bar_mappings[i].type = type;
	}

	csc->intrline = ca->ca_intrline;

	if (pci_get_capability(pc, ca->ca_tag, PCI_CAP_PWRMGMT, &reg,
	    0)) {
		reg = pci_conf_read(pc, ca->ca_tag, reg + 4) & 3;
		if (reg) {
			printf("%s: awakening from state D%d\n",
			    sc->sc_dev.dv_xname, reg);
			pci_conf_write(pc, ca->ca_tag, reg + 4, 0);
		}
	}

	(*cf->cardbus_ctrl)(cc, CARDBUS_MEM_ENABLE);
	(*cf->cardbus_ctrl)(cc, CARDBUS_IO_ENABLE);
	(*cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	paa.puc = sc;
	paa.intr_string = &puc_cardbus_intr_string;
	paa.intr_establish = &puc_cardbus_intr_establish;

	puc_common_attach(sc, &paa);
}

const char *
puc_cardbus_intr_string(struct puc_attach_args *paa)
{
	struct puc_cardbus_softc *sc = paa->puc;
	static char str[16];

	snprintf(str, sizeof str, "irq %d", sc->intrline);
	return (str);
}

void *
puc_cardbus_intr_establish(struct puc_attach_args *paa, int type,
    int (*func)(void *), void *arg, char *name)
{
	struct puc_cardbus_softc *sc = paa->puc;
	struct puc_softc *psc = &sc->sc_psc;
	struct cardbus_devfunc *ct = sc->ct;

	psc->sc_ports[paa->port].intrhand =
	    cardbus_intr_establish(ct->ct_cc, ct->ct_cf, sc->intrline,
		type, func, arg, name);

	return (psc->sc_ports[paa->port].intrhand);
}

int
puc_cardbus_detach(struct device *self, int flags)
{
	struct puc_cardbus_softc *sc = (struct puc_cardbus_softc *)self;
	struct puc_softc *psc = &sc->sc_psc;
	struct cardbus_devfunc *ct = sc->ct;
	int i, rv;

	for (i = PUC_MAX_PORTS; i--; ) {
		if (psc->sc_ports[i].intrhand)
			cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf,
			    psc->sc_ports[i].intrhand);
		if (psc->sc_ports[i].dev)
			if ((rv = config_detach(psc->sc_ports[i].dev, flags)))
				return (rv);
	}

	for (i = PUC_NBARS; i--; )
		if (psc->sc_bar_mappings[i].mapped)
			Cardbus_mapreg_unmap(ct, psc->sc_bar_mappings[i].type,
			    psc->sc_bar_mappings[i].t,
			    psc->sc_bar_mappings[i].h,
			    psc->sc_bar_mappings[i].s);

	return (0);
}
@


1.7
log
@replace a bunch of BAR wrangling code with calls to the pci
code it was originally copied from.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc_cardbus.c,v 1.6 2010/03/27 21:40:13 jsg Exp $	*/
a138 1
	paa.hwtype = COM_UART_OX16C950;		/* XXX */
d141 1
@


1.6
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc_cardbus.c,v 1.5 2010/03/27 20:04:03 jsg Exp $	*/
d110 1
a110 1
		if (!cardbus_mapreg_probe(pc, ca->ca_tag, bar, &type))
@


1.5
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc_cardbus.c,v 1.4 2010/03/22 22:28:27 jsg Exp $	*/
d59 1
a59 3
	struct cardbus_devfunc *ct = ca->ca_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
d62 1
a62 1
	bhlc = cardbus_conf_read(cc, cf, ca->ca_tag, PCI_BHLC_REG);
d71 1
a71 1
	reg = cardbus_conf_read(cc, cf, ca->ca_tag, PCI_SUBSYS_ID_REG);
d87 1
d97 1
a97 1
	reg = cardbus_conf_read(cc, cf, ca->ca_tag, PCI_SUBSYS_ID_REG);
d110 1
a110 1
		if (!cardbus_mapreg_probe(cc, cf, ca->ca_tag, bar, &type))
d124 1
a124 1
	if (cardbus_get_capability(cc, cf, ca->ca_tag, PCI_CAP_PWRMGMT, &reg,
d126 1
a126 1
		reg = cardbus_conf_read(cc, cf, ca->ca_tag, reg + 4) & 3;
d130 1
a130 1
			cardbus_conf_write(cc, cf, ca->ca_tag, reg + 4, 0);
@


1.4
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc_cardbus.c,v 1.3 2007/12/04 21:49:35 kettenis Exp $	*/
d60 1
a60 1
	pci_chipset_tag_t cc = ct->ct_cc;
d88 1
a88 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.3
log
@Make puc(4) detachable.

Tested by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc_cardbus.c,v 1.2 2006/10/12 16:35:52 grange Exp $	*/
d60 1
a60 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d62 1
a62 1
	cardbusreg_t bhlc, reg;
d64 1
a64 1
	bhlc = cardbus_conf_read(cc, cf, ca->ca_tag, CARDBUS_BHLC_REG);
d88 1
a88 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d91 1
a91 1
	cardbusreg_t reg;
d106 1
a106 1
		cardbusreg_t type;
@


1.2
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: puc_cardbus.c,v 1.1 2006/07/31 11:06:27 mickey Exp $	*/
d161 1
d164 5
a168 2
	return (cardbus_intr_establish(ct->ct_cc, ct->ct_cf, sc->intrline,
	    type, func, arg, name));
d174 3
a176 3
	struct puc_cardbus_softc *csc = (struct puc_cardbus_softc *)self;
	struct puc_softc *sc = &csc->sc_psc;
	struct cardbus_devfunc *ct = csc->ct;
d179 6
a184 3
	for (i = PUC_MAX_PORTS; i--; )
		if (sc->sc_ports[i].dev)
			if ((rv = config_detach(sc->sc_ports[i].dev, flags)))
d186 1
d189 5
a193 4
		if (sc->sc_bar_mappings[i].mapped)
			Cardbus_mapreg_unmap(ct, sc->sc_bar_mappings[i].type,
			    sc->sc_bar_mappings[i].t, sc->sc_bar_mappings[i].h,
			    sc->sc_bar_mappings[i].s);
@


1.1
log
@puc@@cardbus (only added (commented out) to whom has puc@@pci enabled)
tested on puc@@pci by fkr and meself on the cardbus.
still needs a bit more work but generally works.
deraadt@@ ok and some input from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d164 1
a164 1
	    type, func, arg));
@

