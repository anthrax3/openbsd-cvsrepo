head	1.26;
access;
symbols
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.21.0.10
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.8
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.26
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.25;
commitid	5gdEnqVoJuTuwdTu;

1.25
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.23;
commitid	yM2VFFhpDTeFQlve;

1.23
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.22;
commitid	LS2TNeCue5R9L67C;

1.22
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.21;
commitid	Qb045HZ5OhQfU69H;

1.21
date	2012.12.05.23.20.16;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.02.17.47.04;	author jasper;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.06.19.20.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.18.12.00.20;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.20.08.46.16;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.05.11.09.08;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.21.11.27.03;	author fkr;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.08.12.44.56;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2005.06.08.05.36.33;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.29.02.58.30;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.27.18.57.19;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.16.01.36.25;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.10.12.14.53;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.09.22.08.29;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.04.04.54.56;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.29.01.02.30;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.26
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_rtw_cardbus.c,v 1.25 2015/03/14 03:38:47 jsg Exp $	*/
/* $NetBSD: if_rtw_cardbus.c,v 1.4 2004/12/20 21:05:34 dyoung Exp $ */

/*-
 * Copyright (c) 2004, 2005 David Young.  All rights reserved.
 *
 * Adapted for the RTL8180 by David Young.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of David Young may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY David Young ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL David
 * Young BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Cardbus front-end for the Realtek RTL8180 802.11 MAC/BBP driver.
 *
 * TBD factor with atw, tlp Cardbus front-ends?
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h> 
#include <sys/mbuf.h>   
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_radiotap.h>
#include <net80211/ieee80211_var.h>

#if NBPFILTER > 0 
#include <net/bpf.h>
#endif 

#include <machine/bus.h>

#include <dev/ic/rtwreg.h>
#include <dev/ic/rtwvar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

/*
 * PCI configuration space registers used by the RTL8180.
 */
#define	RTW_PCI_IOBA		0x10	/* i/o mapped base */
#define	RTW_PCI_MMBA		0x14	/* memory mapped base */

struct rtw_cardbus_softc {
	struct rtw_softc sc_rtw;	/* real RTL8180 softc */

	/* CardBus-specific goo. */
	void			*sc_ih;		/* interrupt handle */
	cardbus_devfunc_t	sc_ct;		/* our CardBus devfuncs */
	pcitag_t		sc_tag;		/* our CardBus tag */
	pci_chipset_tag_t	sc_pc;		/* PCI chipset */
	int			sc_csr;		/* CSR bits */
	bus_size_t		sc_mapsize;	/* size of the mapped bus space
						 * region
						 */

	int			sc_cben;	/* CardBus enables */
	int			sc_bar_reg;	/* which BAR to use */
	pcireg_t		sc_bar_val;	/* value of the BAR */

	int			sc_intrline;	/* interrupt line */
};

int rtw_cardbus_match(struct device *, void *, void *);
void rtw_cardbus_attach(struct device *, struct device *, void *);
int rtw_cardbus_detach(struct device *, int);
void rtw_cardbus_intr_ack(struct rtw_regs *);
void rtw_cardbus_funcregen(struct rtw_regs *, int);

struct cfattach rtw_cardbus_ca = {
    sizeof(struct rtw_cardbus_softc), rtw_cardbus_match, rtw_cardbus_attach,
    	rtw_cardbus_detach
};

void	rtw_cardbus_setup(struct rtw_cardbus_softc *);

int rtw_cardbus_enable(struct rtw_softc *);
void rtw_cardbus_disable(struct rtw_softc *);
void rtw_cardbus_power(struct rtw_softc *, int);

const struct pci_matchid rtw_cardbus_devices[] = {
	{ PCI_VENDOR_REALTEK,	PCI_PRODUCT_REALTEK_RT8180 },
#ifdef RTW_DEBUG
	{ PCI_VENDOR_REALTEK,	PCI_PRODUCT_REALTEK_RT8185 },
	{ PCI_VENDOR_BELKIN2,	PCI_PRODUCT_BELKIN2_F5D7010 },
#endif
	{ PCI_VENDOR_BELKIN2,	PCI_PRODUCT_BELKIN2_F5D6020V3 },
	{ PCI_VENDOR_DLINK,	PCI_PRODUCT_DLINK_DWL610 }
};

int
rtw_cardbus_match(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid((struct cardbus_attach_args *)aux,
	    rtw_cardbus_devices, nitems(rtw_cardbus_devices)));
}

void
rtw_cardbus_intr_ack(struct rtw_regs *regs)
{
	RTW_WRITE(regs, RTW_FER, RTW_FER_INTR);
}

void
rtw_cardbus_funcregen(struct rtw_regs *regs, int enable)
{
	u_int32_t reg;
	rtw_config0123_enable(regs, 1);
	reg = RTW_READ(regs, RTW_CONFIG3);
	if (enable) {
		RTW_WRITE(regs, RTW_CONFIG3, reg | RTW_CONFIG3_FUNCREGEN);
	} else {
		RTW_WRITE(regs, RTW_CONFIG3, reg & ~RTW_CONFIG3_FUNCREGEN);
	}
	rtw_config0123_enable(regs, 0);
}

void
rtw_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct rtw_cardbus_softc *csc = (void *)self;
	struct rtw_softc *sc = &csc->sc_rtw;
	struct rtw_regs *regs = &sc->sc_regs;
	struct cardbus_attach_args *ca = aux;
	cardbus_devfunc_t ct = ca->ca_ct;
	bus_addr_t adr;
	int rev;

	sc->sc_dmat = ca->ca_dmat;
	csc->sc_ct = ct;
	csc->sc_tag = ca->ca_tag;
	csc->sc_pc = ca->ca_pc;

	/*
	 * Power management hooks.
	 */
	sc->sc_enable = rtw_cardbus_enable;
	sc->sc_disable = rtw_cardbus_disable;
	sc->sc_power = rtw_cardbus_power;

	sc->sc_intr_ack = rtw_cardbus_intr_ack;

	/* Get revision info. */
	rev = PCI_REVISION(ca->ca_class);

	RTW_DPRINTF(RTW_DEBUG_ATTACH,
	    ("%s: pass %d.%d signature %08x\n", sc->sc_dev.dv_xname,
	     (rev >> 4) & 0xf, rev & 0xf,
	     pci_conf_read(ca->ca_pc, csc->sc_tag, 0x80)));

	/*
	 * Map the device.
	 */
	csc->sc_csr = PCI_COMMAND_MASTER_ENABLE;
	if (Cardbus_mapreg_map(ct, RTW_PCI_MMBA,
	    PCI_MAPREG_TYPE_MEM, 0, &regs->r_bt, &regs->r_bh, &adr,
	    &csc->sc_mapsize) == 0) {
		RTW_DPRINTF(RTW_DEBUG_ATTACH,
		    ("%s: %s mapped %lu bytes mem space\n",
		     sc->sc_dev.dv_xname, __func__, (long)csc->sc_mapsize));
		csc->sc_cben = CARDBUS_MEM_ENABLE;
		csc->sc_csr |= PCI_COMMAND_MEM_ENABLE;
		csc->sc_bar_reg = RTW_PCI_MMBA;
		csc->sc_bar_val = adr | PCI_MAPREG_TYPE_MEM;
	} else if (Cardbus_mapreg_map(ct, RTW_PCI_IOBA,
	    PCI_MAPREG_TYPE_IO, 0, &regs->r_bt, &regs->r_bh, &adr,
	    &csc->sc_mapsize) == 0) {
		RTW_DPRINTF(RTW_DEBUG_ATTACH,
		    ("%s: %s mapped %lu bytes I/O space\n",
		     sc->sc_dev.dv_xname, __func__, (long)csc->sc_mapsize));
		csc->sc_cben = CARDBUS_IO_ENABLE;
		csc->sc_csr |= PCI_COMMAND_IO_ENABLE;
		csc->sc_bar_reg = RTW_PCI_IOBA;
		csc->sc_bar_val = adr | PCI_MAPREG_TYPE_IO;
	} else {
		printf("%s: unable to map device registers\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Bring the chip out of powersave mode and initialize the
	 * configuration registers.
	 */
	rtw_cardbus_setup(csc);

	/* Remember which interrupt line. */
	csc->sc_intrline = ca->ca_intrline;

	printf(": irq %d\n", csc->sc_intrline);
	    
	/*
	 * Finish off the attach.
	 */
	rtw_attach(sc);

	rtw_cardbus_funcregen(regs, 1);

	RTW_WRITE(regs, RTW_FEMR, RTW_FEMR_INTR);
	RTW_WRITE(regs, RTW_FER, RTW_FER_INTR);

	/*
	 * Power down the socket.
	 */
	Cardbus_function_disable(csc->sc_ct);
}

int
rtw_cardbus_detach(struct device *self, int flags)
{
	struct rtw_cardbus_softc *csc = (void *)self;
	struct rtw_softc *sc = &csc->sc_rtw;
	struct rtw_regs *regs = &sc->sc_regs;
	struct cardbus_devfunc *ct = csc->sc_ct;
	int rv;

#if defined(DIAGNOSTIC)
	if (ct == NULL)
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
#endif

	rv = rtw_detach(sc);
	if (rv)
		return (rv);

	rtw_cardbus_funcregen(regs, 0);

	/*
	 * Unhook the interrupt handler.
	 */
	if (csc->sc_ih != NULL)
		cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, csc->sc_ih);

	/*
	 * Release bus space and close window.
	 */
	if (csc->sc_bar_reg != 0)
		Cardbus_mapreg_unmap(ct, csc->sc_bar_reg,
		    regs->r_bt, regs->r_bh, csc->sc_mapsize);

	return (0);
}

int
rtw_cardbus_enable(struct rtw_softc *sc)
{
	struct rtw_cardbus_softc *csc = (void *) sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/*
	 * Power on the socket.
	 */
	Cardbus_function_enable(ct);

	/*
	 * Set up the PCI configuration registers.
	 */
	rtw_cardbus_setup(csc);

	/*
	 * Map and establish the interrupt.
	 */
	csc->sc_ih = cardbus_intr_establish(cc, cf, csc->sc_intrline, IPL_NET,
	    rtw_intr, sc, sc->sc_dev.dv_xname);
	if (csc->sc_ih == NULL) {
		printf("%s: unable to establish interrupt at %d\n",
		    sc->sc_dev.dv_xname, csc->sc_intrline);
		Cardbus_function_disable(csc->sc_ct);
		return (1);
	}

	rtw_cardbus_funcregen(&sc->sc_regs, 1);

	RTW_WRITE(&sc->sc_regs, RTW_FEMR, RTW_FEMR_INTR);
	RTW_WRITE(&sc->sc_regs, RTW_FER, RTW_FER_INTR);

	return (0);
}

void
rtw_cardbus_disable(struct rtw_softc *sc)
{
	struct rtw_cardbus_softc *csc = (void *) sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	RTW_WRITE(&sc->sc_regs, RTW_FEMR,
	    RTW_READ(&sc->sc_regs, RTW_FEMR) & ~RTW_FEMR_INTR);

	rtw_cardbus_funcregen(&sc->sc_regs, 0);

	/* Unhook the interrupt handler. */
	cardbus_intr_disestablish(cc, cf, csc->sc_ih);
	csc->sc_ih = NULL;

	/* Power down the socket. */
	Cardbus_function_disable(ct);
}

void
rtw_cardbus_power(struct rtw_softc *sc, int why)
{
	RTW_DPRINTF(RTW_DEBUG_ATTACH,
	    ("%s: rtw_cardbus_power\n", sc->sc_dev.dv_xname));

	if (why == DVACT_RESUME)
		rtw_enable(sc);
}

void
rtw_cardbus_setup(struct rtw_cardbus_softc *csc)
{
	struct rtw_softc *sc = &csc->sc_rtw;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = csc->sc_pc;
	pcireg_t reg;
	int pmreg;

	if (pci_get_capability(pc, csc->sc_tag,
	    PCI_CAP_PWRMGMT, &pmreg, 0)) {
		reg = pci_conf_read(pc, csc->sc_tag, pmreg + 4) & 0x03;
#if 1 /* XXX Probably not right for CardBus. */
		if (reg == 3) {
			/*
			 * The card has lost all configuration data in
			 * this state, so punt.
			 */
			printf("%s: unable to wake up from power state D3\n",
			    sc->sc_dev.dv_xname);
			return;
		}
#endif
		if (reg != 0) {
			printf("%s: waking up from power state D%d\n",
			    sc->sc_dev.dv_xname, reg);
			pci_conf_write(pc, csc->sc_tag,
			    pmreg + 4, 0);
		}
	}

	/* Program the BAR. */
	pci_conf_write(pc, csc->sc_tag, csc->sc_bar_reg,
	    csc->sc_bar_val);

	/* Make sure the right access type is on the CardBus bridge. */
	(*ct->ct_cf->cardbus_ctrl)(cc, csc->sc_cben);
	(*ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	/* Enable the appropriate bits in the PCI CSR. */
	reg = pci_conf_read(pc, csc->sc_tag,
	    PCI_COMMAND_STATUS_REG);
	reg &= ~(PCI_COMMAND_IO_ENABLE|PCI_COMMAND_MEM_ENABLE);
	reg |= csc->sc_csr;
	pci_conf_write(pc, csc->sc_tag, PCI_COMMAND_STATUS_REG,
	    reg);

	/*
	 * Make sure the latency timer is set to some reasonable
	 * value.
	 */
	reg = pci_conf_read(pc, csc->sc_tag, PCI_BHLC_REG);
	if (PCI_LATTIMER(reg) < 0x20) {
		reg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
		reg |= (0x20 << PCI_LATTIMER_SHIFT);
		pci_conf_write(pc, csc->sc_tag, PCI_BHLC_REG, reg);
	}
}
@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.24 2014/12/22 02:28:51 tedu Exp $	*/
d82 1
a82 1
 
a83 1
#include <net/if_dl.h>
d85 1
@


1.24
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.23 2014/12/19 22:44:58 guenther Exp $	*/
a96 1
#include <machine/intr.h>
@


1.23
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.22 2014/11/18 23:55:01 krw Exp $	*/
a85 1
#ifdef INET
a87 1
#endif
@


1.22
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.21 2012/12/05 23:20:16 deraadt Exp $	*/
d81 1
a81 2

#include <machine/endian.h>
@


1.21
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.20 2011/04/02 17:47:04 jasper Exp $	*/
a109 1
#include <dev/pci/pcidevs.h>
@


1.20
log
@- use nitems(); no binary change@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.19 2010/09/06 19:20:21 deraadt Exp $	*/
a68 2

#include <sys/cdefs.h>
@


1.19
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.18 2010/03/27 21:40:13 jsg Exp $	*/
d171 1
a171 2
	    rtw_cardbus_devices,
	    sizeof(rtw_cardbus_devices)/sizeof(rtw_cardbus_devices[0])));
@


1.18
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.17 2010/03/27 20:04:03 jsg Exp $	*/
d386 1
a386 1
	if (why == PWR_RESUME)
@


1.17
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.16 2010/03/22 22:28:27 jsg Exp $	*/
d127 1
d209 1
d226 1
a226 1
	     cardbus_conf_read(ct->ct_cc, ct->ct_cf, csc->sc_tag, 0x80)));
d396 1
a396 1
	cardbus_function_tag_t cf = ct->ct_cf;
d400 1
a400 1
	if (cardbus_get_capability(cc, cf, csc->sc_tag,
d402 1
a402 1
		reg = cardbus_conf_read(cc, cf, csc->sc_tag, pmreg + 4) & 0x03;
d417 1
a417 1
			cardbus_conf_write(cc, cf, csc->sc_tag,
d423 1
a423 1
	cardbus_conf_write(cc, cf, csc->sc_tag, csc->sc_bar_reg,
d431 1
a431 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag,
d435 1
a435 1
	cardbus_conf_write(cc, cf, csc->sc_tag, PCI_COMMAND_STATUS_REG,
d442 1
a442 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, PCI_BHLC_REG);
d446 1
a446 1
		cardbus_conf_write(cc, cf, csc->sc_tag, PCI_BHLC_REG, reg);
@


1.16
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.15 2008/07/18 12:00:20 reyk Exp $	*/
d324 1
a324 1
	pci_chipset_tag_t cc = ct->ct_cc;
d362 1
a362 1
	pci_chipset_tag_t cc = ct->ct_cc;
d393 1
a393 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.15
log
@the Belkin F5D7010 version # is a RTL8185 cardbus device.  this
chipset revision is not supported yet, so add it commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.14 2008/06/26 05:42:14 ray Exp $	*/
d126 1
a126 1
	cardbustag_t		sc_tag;		/* our CardBus tag */
d156 1
a156 1
const struct cardbus_matchid rtw_cardbus_devices[] = {
d229 1
a229 1
	csc->sc_csr = CARDBUS_COMMAND_MASTER_ENABLE;
d231 1
a231 1
	    CARDBUS_MAPREG_TYPE_MEM, 0, &regs->r_bt, &regs->r_bh, &adr,
d237 1
a237 1
		csc->sc_csr |= CARDBUS_COMMAND_MEM_ENABLE;
d239 1
a239 1
		csc->sc_bar_val = adr | CARDBUS_MAPREG_TYPE_MEM;
d241 1
a241 1
	    CARDBUS_MAPREG_TYPE_IO, 0, &regs->r_bt, &regs->r_bh, &adr,
d247 1
a247 1
		csc->sc_csr |= CARDBUS_COMMAND_IO_ENABLE;
d249 1
a249 1
		csc->sc_bar_val = adr | CARDBUS_MAPREG_TYPE_IO;
d324 1
a324 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d362 1
a362 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d393 1
a393 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d430 2
a431 2
	    CARDBUS_COMMAND_STATUS_REG);
	reg &= ~(CARDBUS_COMMAND_IO_ENABLE|CARDBUS_COMMAND_MEM_ENABLE);
d433 1
a433 1
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG,
d440 5
a444 5
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG);
	if (CARDBUS_LATTIMER(reg) < 0x20) {
		reg &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
		reg |= (0x20 << CARDBUS_LATTIMER_SHIFT);
		cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG, reg);
@


1.14
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.13 2007/09/20 08:46:16 brad Exp $	*/
d160 1
d163 1
a163 1
	{ PCI_VENDOR_DLINK,	PCI_PRODUCT_DLINK_DWL610 },
@


1.13
log
@Print a colon out front to correct the interrupt string printing.

ok jsg@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.12 2007/09/05 11:09:08 jsg Exp $	*/
a49 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.12
log
@Only match on RTL8185 if RTW_DEBUG is set, support for the RTL8185
was never finished due to a lack of information on the radios.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.11 2006/10/12 16:35:52 grange Exp $	*/
d271 1
a271 1
	printf(" irq %d\n", csc->sc_intrline);
@


1.11
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.10 2006/06/21 11:27:03 fkr Exp $	*/
d164 2
d167 1
a167 1
	{ PCI_VENDOR_REALTEK,	PCI_PRODUCT_REALTEK_RT8180 },
@


1.10
log
@removal of '#ifdef rbus ... #else ...' directives, we use rbus in all
cases anyways, so we might as well remove code (the !rbus case) thats been
dead throughout the last years and just use the rbus code without ifdefs.

brad, miod "I am all for this diff"
ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.9 2005/09/08 12:44:56 jsg Exp $	*/
d345 1
a345 1
	    rtw_intr, sc);
@


1.9
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.8 2005/06/08 05:36:33 henning Exp $	*/
a239 4
#if rbus
#else
		(*ct->ct_cf->cardbus_mem_open)(cc, 0, adr, adr+csc->sc_mapsize);
#endif
a249 4
#if rbus
#else
		(*ct->ct_cf->cardbus_io_open)(cc, 0, adr, adr+csc->sc_mapsize);
#endif
@


1.8
log
@useless netns includes; there was no NS stuff ever here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.7 2005/05/29 02:58:30 reyk Exp $	*/
a100 1
#include <net80211/ieee80211_compat.h>
@


1.7
log
@add the RTL8185 (not working yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.6 2005/05/27 18:57:19 robert Exp $	*/
a107 5

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif
@


1.6
log
@make sure to enable socket on resume.
in order for the enable to work disable the socket on suspend.
lot of help from mickey@@

ok jsg@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.5 2005/05/16 01:36:25 brad Exp $	*/
d170 4
a173 3
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8180 },
	{ PCI_VENDOR_BELKIN2, PCI_PRODUCT_BELKIN2_F5D6020V3 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DWL610 },
@


1.5
log
@Use cardbus_matchbyid().

ok millert@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.4 2005/02/10 12:14:53 jsg Exp $	*/
a397 2
	struct rtw_cardbus_softc *csc = (void *) sc;

d401 2
a402 11
	if (why == PWR_RESUME) {
		/*
		 * Give the PCI configuration registers a kick
		 * in the head.
		 */
#ifdef DIAGNOSTIC
		if ((sc->sc_flags & RTW_F_ENABLED) == 0)
			panic("rtw_cardbus_power");
#endif
		rtw_cardbus_setup(csc);
	}
@


1.4
log
@Remove redundant product name strings, simplify matching slightly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.3 2005/02/09 22:08:29 jsg Exp $	*/
d169 1
a169 7
const struct rtw_cardbus_product *rtw_cardbus_lookup(
     const struct cardbus_attach_args *);

const struct rtw_cardbus_product {
	u_int32_t	 rcp_vendor;	/* PCI vendor ID */
	u_int32_t	 rcp_product;	/* PCI product ID */
} rtw_cardbus_products[] = {
a172 1
	{ 0, 0 }
a174 13
const struct rtw_cardbus_product *
rtw_cardbus_lookup(const struct cardbus_attach_args *ca)
{
	const struct rtw_cardbus_product *rcp;

	for (rcp = rtw_cardbus_products; rcp->rcp_product != 0; rcp++) {
		if (PCI_VENDOR(ca->ca_id) == rcp->rcp_vendor &&
		    PCI_PRODUCT(ca->ca_id) == rcp->rcp_product)
			return (rcp);
	}
	return (NULL);
}

d178 3
a180 3
	struct cardbus_attach_args *ca = aux;

	return (rtw_cardbus_lookup(ca) != NULL);
a210 1
	const struct rtw_cardbus_product *rcp;
a216 6

	rcp = rtw_cardbus_lookup(ca);
	if (rcp == NULL) {
		printf("\n");
		panic("rtw_cardbus_attach: impossible");
	}
@


1.3
log
@Match D-Link DWL-610.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.2 2005/01/04 04:54:56 jsg Exp $	*/
a174 1
	const char	*rcp_product_name;
d176 4
a179 10
	{ PCI_VENDOR_REALTEK,		PCI_PRODUCT_REALTEK_RT8180,
	  "Realtek RTL8180 802.11 MAC/BBP" },

	{ PCI_VENDOR_BELKIN2,		PCI_PRODUCT_BELKIN2_F5D6020V3,
	  "Belkin F5D6020v3 802.11b (RTL8180 MAC/BBP)" },

	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DWL610,
	  "D-Link DWL-610" },

	{ 0,				0,	NULL },
d187 1
a187 3
	for (rcp = rtw_cardbus_products;
	     rcp->rcp_product_name != NULL;
	     rcp++) {
d200 1
a200 4
	if (rtw_cardbus_lookup(ca) != NULL)
		return (1);

	return (0);
@


1.2
log
@shrink dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rtw_cardbus.c,v 1.1 2004/12/29 01:02:30 jsg Exp $	*/
d182 3
@


1.1
log
@Driver for Realtek 802.11 devices from NetBSD.
Not yet working.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d318 2
a319 2
	printf("%s, irq %d\n", sc->sc_dev.dv_xname,
	    csc->sc_intrline);
@

