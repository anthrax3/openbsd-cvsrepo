head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.30.0.4
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.14
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.12
	UBC:1.9.0.10
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	SMP:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.33
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.32;
commitid	5gdEnqVoJuTuwdTu;

1.32
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.31;
commitid	5DvsamK0GblTp8ww;

1.31
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.30;
commitid	p4LJxGKbi0BU2cG6;

1.30
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.29;
commitid	uzzBR7hz9ncd4O6G;

1.29
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.28;
commitid	nYggAidK85QbUFh2;

1.28
date	2013.08.07.01.06.27;	author bluhm;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.13.09.10.33;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.12.00.39.10;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.02.07.55.08;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.25.20.32.10;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.05.13.24.03;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.10.20.10.19;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.21.11.27.03;	author fkr;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.07.21.16.59;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.30.03.16.58;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.21.10.07.33;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.15.05.14.41;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.29.05.28.28;	author aaron;	state Exp;
branches
	1.9.6.1
	1.9.10.1;
next	1.8;

1.8
date	2000.09.16.21.42.17;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.16.21.11.16;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.05.18.18.50;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.06.21.17.44;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.01.03.19.14;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.09.15.35.29;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.09.00.45.25;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.08.05.50.52;	author aaron;	state Exp;
branches;
next	;

1.9.6.1
date	2001.05.14.22.23.13;	author niklas;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2002.03.29.23.39.33;	author niklas;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.9.6.4;

1.9.6.4
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	;

1.9.10.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	;


desc
@@


1.33
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_xl_cardbus.c,v 1.32 2015/11/24 13:33:17 mpi Exp $ */
/*	$NetBSD: if_xl_cardbus.c,v 1.13 2000/03/07 00:32:52 mycroft Exp $	*/

/*
 * CardBus specific routines for 3Com 3C575-family CardBus ethernet adapter
 *
 * Copyright (c) 1998 and 1999
 *       HAYAKAWA Koichi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY HAYAKAWA KOICHI ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL TAKESHI OHASHI OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/cpu.h>
#include <machine/bus.h>

#include <dev/cardbus/cardbusvar.h>
#include <dev/pci/pcidevs.h>

#include <dev/mii/miivar.h>

#include <dev/ic/xlreg.h>

#if defined XL_DEBUG
#define DPRINTF(a) printf a
#else
#define DPRINTF(a)
#endif

#define CARDBUS_3C575BTX_FUNCSTAT_PCIREG  CARDBUS_BASE2_REG  /* means 0x18 */

int xl_cardbus_match(struct device *, void *, void *);
void xl_cardbus_attach(struct device *, struct device *,void *);
int xl_cardbus_detach(struct device *, int);
void xl_cardbus_intr_ack(struct xl_softc *);

#define XL_CARDBUS_BOOMERANG	0x0001
#define XL_CARDBUS_CYCLONE	0x0002

#define XL_CARDBUS_INTR		0x0004
#define XL_CARDBUS_INTR_ACK	0x8000

struct xl_cardbus_softc {
	struct xl_softc sc_softc;

	cardbus_devfunc_t sc_ct;
	int sc_intrline;
	u_int8_t sc_cardbus_flags;
	u_int8_t sc_cardtype;

	/* CardBus function status space.  575B requests it. */
	bus_space_tag_t sc_funct;
	bus_space_handle_t sc_funch;
	bus_size_t sc_funcsize;

	bus_size_t sc_mapsize;		/* size of mapped bus space region */
};

struct cfattach xl_cardbus_ca = {
	sizeof(struct xl_cardbus_softc), xl_cardbus_match,
	    xl_cardbus_attach, xl_cardbus_detach
};

const struct xl_cardbus_product {
	u_int32_t	ecp_prodid;	/* CardBus product ID */
	int		ecp_flags;	/* initial softc flags */
	pcireg_t	ecp_csr;	/* PCI CSR flags */
	int		ecp_cardtype;	/* card type */
} xl_cardbus_products[] = {
	{ PCI_PRODUCT_3COM_3C575,
	  XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 | XL_FLAG_8BITROM,
	  PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MASTER_ENABLE,
	  XL_CARDBUS_BOOMERANG },

	{ PCI_PRODUCT_3COM_3CCFE575BT,
	  XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 | XL_FLAG_8BITROM |
	      XL_FLAG_INVERT_LED_PWR,
	  PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	      PCI_COMMAND_MASTER_ENABLE,
	  XL_CARDBUS_CYCLONE },

	{ PCI_PRODUCT_3COM_3CCFE575CT,
	  XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 | XL_FLAG_8BITROM |
	      XL_FLAG_INVERT_MII_PWR,
	  PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	      PCI_COMMAND_MASTER_ENABLE,
	  XL_CARDBUS_CYCLONE },

	{ PCI_PRODUCT_3COM_3CCFEM656,
	  XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 | XL_FLAG_8BITROM |
	      XL_FLAG_INVERT_LED_PWR | XL_FLAG_INVERT_MII_PWR,
	  PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	      PCI_COMMAND_MASTER_ENABLE,
	  XL_CARDBUS_CYCLONE },

	{ PCI_PRODUCT_3COM_3CCFEM656B,
	  XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 | XL_FLAG_8BITROM |
	      XL_FLAG_INVERT_LED_PWR | XL_FLAG_INVERT_MII_PWR,
	  PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	      PCI_COMMAND_MASTER_ENABLE,
	  XL_CARDBUS_CYCLONE },

	{ PCI_PRODUCT_3COM_3CCFEM656C,
	  XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 | XL_FLAG_8BITROM |
	      XL_FLAG_INVERT_MII_PWR,
	  PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	      PCI_COMMAND_MASTER_ENABLE,
	  XL_CARDBUS_CYCLONE },

	{ 0,
	  0,
	  0,
	  0 },
};

const struct xl_cardbus_product *xl_cardbus_lookup(const struct cardbus_attach_args *);

const struct xl_cardbus_product *
xl_cardbus_lookup(const struct cardbus_attach_args *ca)
{
	const struct xl_cardbus_product *ecp;

	if (PCI_VENDOR(ca->ca_id) != PCI_VENDOR_3COM)
		return (NULL);

	for (ecp = xl_cardbus_products; ecp->ecp_prodid != 0; ecp++)
		if (PCI_PRODUCT(ca->ca_id) == ecp->ecp_prodid)
			return (ecp);
	return (NULL);
}

int
xl_cardbus_match(struct device *parent, void *match, void *aux)
{
	struct cardbus_attach_args *ca = aux;

	if (xl_cardbus_lookup(ca) != NULL)
		return (1);

	return (0);
}

void
xl_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct xl_cardbus_softc *csc = (void *)self;
	struct xl_softc *sc = &csc->sc_softc;
	struct cardbus_attach_args *ca = aux;
	cardbus_devfunc_t ct = ca->ca_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
	pcireg_t command, bhlc;
	const struct xl_cardbus_product *ecp;
	bus_space_handle_t ioh;
	bus_addr_t adr;

	if (Cardbus_mapreg_map(ct, CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO, 0,
	    &sc->xl_btag, &ioh, &adr, &csc->sc_mapsize)) {
		printf(": can't map i/o space\n");
		return;
	}

	ecp = xl_cardbus_lookup(ca);
	if (ecp == NULL) {
		printf("\n");
		panic("xl_cardbus_attach: impossible");
	}

	sc->xl_flags = ecp->ecp_flags;
	sc->sc_dmat = ca->ca_dmat;

	sc->xl_bhandle = ioh;

	(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_IO_ENABLE);

	command = pci_conf_read(ca->ca_pc, ca->ca_tag,
	    PCI_COMMAND_STATUS_REG);
	command |= ecp->ecp_csr;
	csc->sc_cardtype = ecp->ecp_cardtype;

	if (csc->sc_cardtype == XL_CARDBUS_CYCLONE) {
		/* map CardBus function status window */
		if (Cardbus_mapreg_map(ct, CARDBUS_BASE2_REG,
		    PCI_MAPREG_TYPE_MEM, 0, &csc->sc_funct,
		    &csc->sc_funch, 0, &csc->sc_funcsize)) {
			printf("%s: unable to map function status window\n",
			    self->dv_xname);
			return;
		}

		/*
		 * Make sure CardBus bridge can access memory space.  Usually
		 * memory access is enabled by BIOS, but some BIOSes do not
		 * enable it.
		 */
		(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_MEM_ENABLE);
	}

	(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);
	pci_conf_write(ca->ca_pc, ca->ca_tag, PCI_COMMAND_STATUS_REG,
	    command);
  
 	/*
	 * set latency timer
	 */
	bhlc = pci_conf_read(ca->ca_pc, ca->ca_tag, PCI_BHLC_REG);
	if (PCI_LATTIMER(bhlc) < 0x20) {
		/* at least the value of latency timer should 0x20. */
		DPRINTF(("if_xl_cardbus: lattimer 0x%x -> 0x20\n",
		    PCI_LATTIMER(bhlc)));
		bhlc &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
		bhlc |= (0x20 << PCI_LATTIMER_SHIFT);
		pci_conf_write(ca->ca_pc, ca->ca_tag, PCI_BHLC_REG, bhlc);
	}

	csc->sc_ct = ca->ca_ct;
	csc->sc_intrline = ca->ca_intrline;

	/* Map and establish the interrupt. */

	sc->xl_intrhand = cardbus_intr_establish(cc, cf, ca->ca_intrline,
	    IPL_NET, xl_intr, csc, self->dv_xname);

	if (sc->xl_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		printf(" at %d", ca->ca_intrline);
		printf("\n");
		return;
	}
	printf(": irq %d", ca->ca_intrline);

	sc->intr_ack = xl_cardbus_intr_ack;

	xl_attach(sc);

	if (csc->sc_cardtype == XL_CARDBUS_CYCLONE)
		bus_space_write_4(csc->sc_funct, csc->sc_funch,
		    XL_CARDBUS_INTR, XL_CARDBUS_INTR_ACK);

}

int
xl_cardbus_detach(struct device *self, int arg)
{
	struct xl_cardbus_softc *csc = (void *)self;
	struct xl_softc *sc = &csc->sc_softc;
	struct cardbus_devfunc *ct = csc->sc_ct;

	cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf,
	    sc->xl_intrhand);
	xl_detach(sc);
	if (csc->sc_cardtype == XL_CARDBUS_CYCLONE)
		Cardbus_mapreg_unmap(ct, CARDBUS_BASE2_REG,
		    csc->sc_funct, csc->sc_funch, csc->sc_funcsize);
	Cardbus_mapreg_unmap(ct, CARDBUS_BASE0_REG, sc->xl_btag,
	    sc->xl_bhandle, csc->sc_mapsize);
	return (0);
}

void
xl_cardbus_intr_ack(struct xl_softc *sc)
{
	struct xl_cardbus_softc *csc = (struct xl_cardbus_softc *)sc;

	bus_space_write_4(csc->sc_funct, csc->sc_funch, XL_CARDBUS_INTR,
	    XL_CARDBUS_INTR_ACK);
}
@


1.32
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.31 2015/03/14 03:38:47 jsg Exp $ */
a46 1
#include <net/if_dl.h>
@


1.31
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.30 2014/09/14 14:17:24 jsg Exp $ */
a47 1
#include <net/if_types.h>
@


1.30
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.29 2014/08/11 12:45:45 mpi Exp $ */
a59 1
#include <dev/mii/mii.h>
@


1.29
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.28 2013/08/07 01:06:27 bluhm Exp $ */
a43 1
#include <sys/proc.h>
@


1.28
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.27 2010/03/27 21:40:13 jsg Exp $ */
a51 1
#ifdef INET
a52 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a53 1
#endif
@


1.27
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.26 2010/03/27 20:04:03 jsg Exp $ */
a54 1
#include <netinet/in_var.h>
@


1.26
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.25 2010/03/22 22:28:27 jsg Exp $ */
d223 1
a223 1
	command = cardbus_conf_read(cc, cf, ca->ca_tag,
d247 1
a247 1
	cardbus_conf_write(cc, cf, ca->ca_tag, PCI_COMMAND_STATUS_REG,
d253 1
a253 1
	bhlc = cardbus_conf_read(cc, cf, ca->ca_tag, PCI_BHLC_REG);
d260 1
a260 1
		cardbus_conf_write(cc, cf, ca->ca_tag, PCI_BHLC_REG, bhlc);
@


1.25
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.24 2010/01/13 09:10:33 jsg Exp $ */
d197 1
a197 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.24
log
@As per NetBSD move HAYAKAWA Koichi's licenses to two clause.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.23 2010/01/12 00:39:10 chl Exp $ */
d119 1
a119 1
	  CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MASTER_ENABLE,
d125 2
a126 2
	  CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MEM_ENABLE |
	      CARDBUS_COMMAND_MASTER_ENABLE,
d132 2
a133 2
	  CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MEM_ENABLE |
	      CARDBUS_COMMAND_MASTER_ENABLE,
d139 2
a140 2
	  CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MEM_ENABLE |
	      CARDBUS_COMMAND_MASTER_ENABLE,
d146 2
a147 2
	  CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MEM_ENABLE |
	      CARDBUS_COMMAND_MASTER_ENABLE,
d153 2
a154 2
	  CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MEM_ENABLE |
	      CARDBUS_COMMAND_MASTER_ENABLE,
d170 1
a170 1
	if (CARDBUS_VENDOR(ca->ca_id) != PCI_VENDOR_3COM)
d174 1
a174 1
		if (CARDBUS_PRODUCT(ca->ca_id) == ecp->ecp_prodid)
d197 1
a197 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d199 1
a199 1
	cardbusreg_t command, bhlc;
d204 1
a204 1
	if (Cardbus_mapreg_map(ct, CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO, 0,
d224 1
a224 1
	    CARDBUS_COMMAND_STATUS_REG);
d231 1
a231 1
		    CARDBUS_MAPREG_TYPE_MEM, 0, &csc->sc_funct,
d247 1
a247 1
	cardbus_conf_write(cc, cf, ca->ca_tag, CARDBUS_COMMAND_STATUS_REG,
d253 2
a254 2
	bhlc = cardbus_conf_read(cc, cf, ca->ca_tag, CARDBUS_BHLC_REG);
	if (CARDBUS_LATTIMER(bhlc) < 0x20) {
d257 4
a260 4
		    CARDBUS_LATTIMER(bhlc)));
		bhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
		bhlc |= (0x20 << CARDBUS_LATTIMER_SHIFT);
		cardbus_conf_write(cc, cf, ca->ca_tag, CARDBUS_BHLC_REG, bhlc);
@


1.23
log
@Remove dead assignment and newly created unused variable.

Found by LLVM/Clang Static Analyzer.

ok grange@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.22 2009/10/15 17:54:56 deraadt Exp $ */
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the author.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.22
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.21 2009/06/02 07:55:08 deraadt Exp $ */
d205 1
a205 1
	cardbusreg_t iob, command, bhlc;
a224 1
	iob = adr;
@


1.21
log
@The xl_detach() function is now used by pci code, so it must be in the
shared code in case either cardbus or pci varients are not configured.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.20 2008/02/25 20:32:10 brad Exp $ */
a301 1
	int rv = 0;
d303 9
a311 23
#if defined(DIAGNOSTIC)
	if (ct == NULL) {
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
	}
#endif

	rv = xl_detach(sc);
	if (rv == 0) {
		/*
		 * Unhook the interrupt handler.
		 */
		cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf,
		    sc->xl_intrhand);

		if (csc->sc_cardtype == XL_CARDBUS_CYCLONE) {
			Cardbus_mapreg_unmap(ct, CARDBUS_BASE2_REG,
			    csc->sc_funct, csc->sc_funch, csc->sc_funcsize);
		}

		Cardbus_mapreg_unmap(ct, CARDBUS_BASE0_REG, sc->xl_btag,
		    sc->xl_bhandle, csc->sc_mapsize);
	}
	return (rv);
@


1.20
log
@Remove redundant information from the dmesg entry which is already
represented from the pcidevs entry.

ok deraadt@@ kettenis@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.19 2007/05/05 13:24:03 deraadt Exp $ */
a293 29
}

int
xl_detach(struct xl_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	extern void xl_freetxrx(struct xl_softc *);

	/* Unhook our tick handler. */
	timeout_del(&sc->xl_stsup_tmo);

	xl_freetxrx(sc);

	/* Detach all PHYs */
	if (sc->xl_hasmii)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete all remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);

	return (0);
@


1.19
log
@move xl_detach() -- which is only used by cardbus -- to the cardbus code.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.18 2006/10/12 16:35:52 grange Exp $ */
a121 1
	const char	*ecp_name;	/* device name */
d126 1
a126 2
	  XL_CARDBUS_BOOMERANG,
	  "3c575-TX Ethernet" },
d133 1
a133 2
	  XL_CARDBUS_CYCLONE,
	  "3c575B-TX Ethernet" },
d140 1
a140 2
	  XL_CARDBUS_CYCLONE,
	  "3c575C-TX Ethernet" },
d147 1
a147 2
	  XL_CARDBUS_CYCLONE,
	  "3c656-TX Ethernet" },
d154 1
a154 2
	  XL_CARDBUS_CYCLONE,
	  "3c656B-TX Ethernet" },
d161 1
a161 2
	  XL_CARDBUS_CYCLONE,
	  "3c656C-TX Ethernet" },
d166 1
a166 2
	  0,
	  NULL },
d179 1
a179 1
	for (ecp = xl_cardbus_products; ecp->ecp_name != NULL; ecp++)
a220 2

	printf(": 3Com %s", ecp->ecp_name);
@


1.18
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.17 2006/08/10 20:10:19 brad Exp $ */
d304 29
@


1.17
log
@- ANSI functions
- de-register
- remove return at the end of void functions
- some cosmetic tweaking
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.16 2006/06/21 11:27:03 fkr Exp $ */
d286 1
a286 1
	    IPL_NET, xl_intr, csc);
@


1.16
log
@removal of '#ifdef rbus ... #else ...' directives, we use rbus in all
cases anyways, so we might as well remove code (the !rbus case) thats been
dead throughout the last years and just use the rbus code without ifdefs.

brad, miod "I am all for this diff"
ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.15 2004/10/07 21:16:59 brad Exp $ */
d180 1
a180 2
xl_cardbus_lookup(ca)
	const struct cardbus_attach_args *ca;
d194 1
a194 4
xl_cardbus_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d205 1
a205 4
xl_cardbus_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d307 1
a307 3
xl_cardbus_detach(self, arg)
	struct device *self;
	int arg;
d340 1
a340 2
xl_cardbus_intr_ack(sc)
	struct xl_softc *sc;
@


1.15
log
@cardbusdevs -> pcidevs

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.14 2003/10/30 03:16:58 itojun Exp $ */
a244 4
#if rbus
#else
	(ct->ct_cf->cardbus_io_open)(cc, 0, iob, iob + 0x40);
#endif
@


1.14
log
@fix missing 0.  drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.13 2003/10/21 10:07:33 jmc Exp $ */
d70 1
a70 1
#include <dev/cardbus/cardbusdevs.h>
d124 1
a124 1
	{ CARDBUS_PRODUCT_3COM_3C575,
d130 1
a130 1
	{ CARDBUS_PRODUCT_3COM_3CCFE575BT,
d138 1
a138 1
	{ CARDBUS_PRODUCT_3COM_3CCFE575CT,
d146 1
a146 1
	{ CARDBUS_PRODUCT_3COM_3CCFEM656,
d154 1
a154 1
	{ CARDBUS_PRODUCT_3COM_3CCFEM656B,
d162 1
a162 1
	{ CARDBUS_PRODUCT_3COM_3CCFEM656C,
d185 1
a185 1
	if (CARDBUS_VENDOR(ca->ca_id) != CARDBUS_VENDOR_3COM)
@


1.13
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.12 2002/10/12 01:09:44 krw Exp $ */
d171 1
@


1.12
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.11 2002/06/15 05:14:41 aaron Exp $ */
d278 1
a278 1
	 * set latency timmer
@


1.11
log
@bus_dma'ify. Tested on 3c900(pci), 3c905b(pci), and 3c575c(cardbus). Thanks
to todd@@ and camiel@@ for trying it, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.10 2002/03/14 01:26:53 millert Exp $ */
d328 1
a328 1
		panic("%s: data structure lacks\n", sc->sc_dev.dv_xname);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.9 2000/09/29 05:28:28 aaron Exp $ */
d239 1
@


1.9
log
@- Add support for 3Com 3C555 MiniPCI.
- Clean up configuration flags mess. The MiniPCI adapters share some properties
  with the CardBus adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.8 2000/09/16 21:42:17 aaron Exp $ */
d85 4
a88 4
int xl_cardbus_match		__P((struct device *, void *, void *));
void xl_cardbus_attach		__P((struct device *, struct device *,void *));
int xl_cardbus_detach		__P((struct device *, int));
void xl_cardbus_intr_ack	__P((struct xl_softc *));
d176 1
a176 2
const struct xl_cardbus_product *xl_cardbus_lookup
    __P((const struct cardbus_attach_args *));
@


1.9.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.9 2000/09/29 05:28:28 aaron Exp $ */
d85 4
a88 4
int xl_cardbus_match(struct device *, void *, void *);
void xl_cardbus_attach(struct device *, struct device *,void *);
int xl_cardbus_detach(struct device *, int);
void xl_cardbus_intr_ack(struct xl_softc *);
d176 2
a177 1
const struct xl_cardbus_product *xl_cardbus_lookup(const struct cardbus_attach_args *);
@


1.9.10.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.9.10.1 2002/06/11 03:42:16 art Exp $ */
a238 1
	sc->sc_dmat = ca->ca_dmat;
d327 1
a327 1
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
@


1.9.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.9 2000/09/29 05:28:28 aaron Exp $ */
@


1.9.6.2
log
@cardbus too got skipped by cvs for some reason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.9.6.1 2001/05/14 22:23:13 niklas Exp $ */
d85 4
a88 4
int xl_cardbus_match(struct device *, void *, void *);
void xl_cardbus_attach(struct device *, struct device *,void *);
int xl_cardbus_detach(struct device *, int);
void xl_cardbus_intr_ack(struct xl_softc *);
d176 2
a177 1
const struct xl_cardbus_product *xl_cardbus_lookup(const struct cardbus_attach_args *);
@


1.9.6.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a238 1
	sc->sc_dmat = ca->ca_dmat;
d327 1
a327 1
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
@


1.9.6.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a172 1
	  0,
d278 1
a278 1
	 * set latency timer
@


1.8
log
@Add support for 3C556[B] MiniPCI Ethernet adapters, found on some laptops
(i.e., HP OmniBooks). I have sent these changes to a tester but I haven't
heard back yet. Assume for now the changes are OK since all of the other
variants I have still work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.7 2000/09/16 21:11:16 aaron Exp $ */
d85 4
a88 3
int xl_cardbus_match __P((struct device *, void *, void *));
void xl_cardbus_attach __P((struct device *, struct device *,void *));
int xl_cardbus_detach __P((struct device *, int));
d90 5
a94 2
#define XL_CB_BOOMERANG	0x01
#define XL_CB_CYCLONE	0x02
d125 1
a125 1
	  0,
d127 1
a127 1
	  XL_CB_BOOMERANG,
d131 2
a132 1
	  XL_CARDBUS_INVERT_LED_PWR,
d135 1
a135 1
	  XL_CB_CYCLONE,
d139 2
a140 1
	  XL_CARDBUS_INVERT_MII_PWR,
d143 1
a143 1
	  XL_CB_CYCLONE,
d147 2
a148 1
	  XL_CARDBUS_INVERT_LED_PWR | XL_CARDBUS_INVERT_MII_PWR,
d151 1
a151 1
	  XL_CB_CYCLONE,
d155 2
a156 1
	  XL_CARDBUS_INVERT_LED_PWR | XL_CARDBUS_INVERT_MII_PWR,
d159 1
a159 1
	  XL_CB_CYCLONE,
d163 2
a164 1
	  XL_CARDBUS_INVERT_MII_PWR,
d167 1
a167 1
	  XL_CB_CYCLONE,
d239 1
a239 3
	sc->xl_bustype = XL_BUS_CARDBUS;
	sc->xl_cb_flags = ecp->ecp_flags;
	sc->xl_flags = XL_FLAG_EEPROM_OFFSET_30|XL_FLAG_8BITROM;
d255 1
a255 1
	if (csc->sc_cardtype == XL_CB_CYCLONE) {
d306 2
d310 1
a310 1
	if (csc->sc_cardtype == XL_CB_CYCLONE)
d340 1
a340 1
		if (csc->sc_cardtype == XL_CB_CYCLONE) {
d351 9
@


1.7
log
@Some changes from NetBSD:

- Remove an unnecessary global reset that was only used for debugging purposes.
- Make the cardtype names more meaningful.
- Some variable renaming for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.6 2000/09/05 18:18:50 aaron Exp $ */
d232 1
@


1.6
log
@Support detach of xl(4) devices, mainly to allow the ejection and insertion of
3Com575-based CardBus PC Cards; from nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.5 2000/07/06 21:17:44 aaron Exp $ */
d89 2
a90 2
#define XL_3C575	0x01
#define XL_3C575B	0x02
d123 1
a123 1
	  XL_3C575,
d130 1
a130 1
	  XL_3C575B,
d137 1
a137 1
	  XL_3C575B,
d144 1
a144 1
	  XL_3C575B,
d151 1
a151 1
	  XL_3C575B,
d158 1
a158 1
	  XL_3C575B,
d205 2
a206 2
	struct xl_cardbus_softc *psc = (void *)self;
	struct xl_softc *sc = &psc->sc_softc;
d217 1
a217 1
	    &sc->xl_btag, &ioh, &adr, &psc->sc_mapsize)) {
d245 1
a245 1
	psc->sc_cardtype = ecp->ecp_cardtype;
d247 1
a247 1
	if (psc->sc_cardtype == XL_3C575B) {
d249 3
a251 3
		if (Cardbus_mapreg_map(ct, CARDBUS_3C575BTX_FUNCSTAT_PCIREG,
		    CARDBUS_MAPREG_TYPE_MEM, 0, &psc->sc_funct,
		    &psc->sc_funch, 0, &psc->sc_funcsize)) {
d282 2
a283 2
	psc->sc_ct = ca->ca_ct;
	psc->sc_intrline = ca->ca_intrline;
d288 1
a288 1
	    IPL_NET, xl_intr, psc);
a297 20
	bus_space_write_2(sc->xl_btag, sc->xl_bhandle, XL_COMMAND,
	    XL_CMD_RESET);
	delay(5000);

	{
		int i = 0;
		while (bus_space_read_2(sc->xl_btag, sc->xl_bhandle, XL_STATUS)
		    & XL_STAT_CMDBUSY) {
			if (++i > 10000) {
				printf("ex: timeout %x\n",
				    bus_space_read_2(sc->xl_btag,
				        sc->xl_bhandle, XL_STATUS));
				printf("ex: addr %x\n",
				    cardbus_conf_read(cc, cf, ca->ca_tag,
				    CARDBUS_BASE0_REG));
				return;		/* emergency exit */
			}
		}
	}

d300 2
a301 2
	if (psc->sc_cardtype == XL_3C575B)
		bus_space_write_4(psc->sc_funct, psc->sc_funch,
d311 3
a313 3
	struct xl_cardbus_softc *psc = (void *)self;
	struct xl_softc *sc = &psc->sc_softc;
	struct cardbus_devfunc *ct = psc->sc_ct;
d330 3
a332 4
		if (psc->sc_cardtype == XL_3C575B) {
			Cardbus_mapreg_unmap(ct,
			    CARDBUS_3C575BTX_FUNCSTAT_PCIREG,
			    psc->sc_funct, psc->sc_funch, psc->sc_funcsize);
d336 1
a336 1
		    sc->xl_bhandle, psc->sc_mapsize);
@


1.5
log
@Perform a much longer delay after resetting the card to give it a chance to get
its brains in order.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.4 2000/07/01 03:19:14 aaron Exp $ */
a341 1
#if 0
a342 1
#endif
@


1.4
log
@- Make the 3CCFE575BT work.
- Add support for the 3CCFEM656C.
- Lots of code cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.3 2000/06/09 15:35:29 aaron Exp $ */
d300 2
a301 1
	delay(400);
@


1.3
log
@Clean up this file a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.2 2000/06/09 00:45:25 aaron Exp $ */
a76 3
#undef XL_DEBUG
#define XL_POWER_STATIC		/* do not use enable/disable functions */

a83 2
#define XL_CB_INTR 4		/* intr acknowledge reg. CardBus only */
#define XL_CB_INTR_ACK 0x8000 /* intr acknowledge bit */
a87 1
void xl_cardbus_intr_ack __P((struct xl_softc *));
d89 2
a90 4
#if !defined XL_POWER_STATIC
int xl_cardbus_enable __P((struct xl_softc *sc));
void xl_cardbus_disable __P((struct xl_softc *sc));
#endif /* !defined XL_POWER_STATIC */
a97 2
#define XL_REATTACH		0x01
#define XL_ABSENT		0x02
a98 2
#define XL_3C575		1
#define XL_3C575B		2
d105 1
a105 1
	bus_size_t sc_mapsize;		/* the size of mapped bus space region */
d120 1
a120 1
	{ CARDBUS_PRODUCT_3COM_3C575TX,
d126 2
a127 2
	{ CARDBUS_PRODUCT_3COM_3C575BTX,
	  0,
d134 1
a134 1
	  0,
d140 2
a141 2
	{ CARDBUS_PRODUCT_3COM_3CCFE656B,
	  0,
d147 14
a229 12
#if 0
#if !defined XL_POWER_STATIC
	sc->enable = xl_cardbus_enable;
	sc->disable = xl_cardbus_disable;
#else
	sc->enable = NULL;
	sc->disable = NULL;
#endif
	sc->enabled = 1;
	sc->sc_dmat = ca->ca_dmat;
	sc->xl_conf = ecp->ecp_flags;
#endif
d231 1
a262 3

		/* Setup interrupt acknowledge hook */
		sc->intr_ack = xl_cardbus_intr_ack;
a284 1
#if defined XL_POWER_STATIC
a296 1
#endif
d321 1
a321 13
		    XL_CB_INTR, XL_CB_INTR_ACK);

#if !defined XL_POWER_STATIC
	cardbus_function_disable(psc->sc_ct);  
	sc->enabled = 0;
#endif
}

void
xl_cardbus_intr_ack(sc)
	struct xl_softc *sc;
{
	struct xl_cardbus_softc *psc = (struct xl_cardbus_softc *)sc;
a322 2
	bus_space_write_4(psc->sc_funct, psc->sc_funch, XL_CB_INTR,
	    XL_CB_INTR_ACK);
a362 38
#if !defined XL_POWER_STATIC
int
xl_cardbus_enable(sc)
	struct xl_softc *sc;
{
	struct xl_cardbus_softc *csc = (struct xl_cardbus_softc *)sc;
	cardbus_function_tag_t cf = csc->sc_ct->ct_cf;
	cardbus_chipset_tag_t cc = csc->sc_ct->ct_cc;

	Cardbus_function_enable(csc->sc_ct);
	cardbus_restore_bar(csc->sc_ct);

	sc->xl_intrhand = cardbus_intr_establish(cc, cf, csc->sc_intrline,
	    IPL_NET, xl_intr, sc);
	if (NULL == sc->xl_intrhand) {
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}

	return (0);
}

void
xl_cardbus_disable(sc)
	struct xl_softc *sc;
{
	struct xl_cardbus_softc *csc = (struct xl_cardbus_softc *)sc;
	cardbus_function_tag_t cf = csc->sc_ct->ct_cf;
	cardbus_chipset_tag_t cc = csc->sc_ct->ct_cc;

	cardbus_save_bar(csc->sc_ct);
  
 	Cardbus_function_disable(csc->sc_ct);

	cardbus_intr_disestablish(cc, cf, sc->xl_intrhand);
}
#endif /* XL_POWER_STATIC */
@


1.2
log
@Add support for 3c656, which is just the 3c575 + 56k modem. Thanks to
xav@@quakeserver.org for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_cardbus.c,v 1.1 2000/04/08 05:50:52 aaron Exp $ */
a39 7
/* #define XL_DEBUG 4 */	/* define to report infomation for debugging */

#define XL_POWER_STATIC		/* do not use enable/disable functions */
				/* I'm waiting elinkxl.c uses
                                   sc->enable and sc->disable
                                   functions. */

d72 1
d77 2
a78 3
#if defined DEBUG && !defined XL_DEBUG
#define XL_DEBUG
#endif
d133 1
a133 1
	  /* XL_CONF_MII, */ 0,
d139 1
a139 1
	  /* XL_CONF_90XB|XL_CONF_MII, */ 0,
d146 1
a146 1
	  /* XL_CONF_90XB|XL_CONF_MII, */ 0,
d153 1
a153 1
	  /* XL_CONF_90XB|XL_CONF_MII, */ 0,
d257 1
a257 1
		/* Map CardBus function status window. */
d267 1
a267 1
		 * Make sure CardBus brigde can access memory space.  Usually
d312 2
a313 1
	bus_space_write_2(sc->xl_btag, sc->xl_bhandle, XL_COMMAND, XL_CMD_RESET);
d317 2
a318 2
		while (bus_space_read_2(sc->xl_btag, sc->xl_bhandle, XL_STATUS) &
		    XL_STAT_CMDBUSY) {
d321 2
a322 2
				    bus_space_read_2(sc->xl_btag, sc->xl_bhandle,
				        XL_STATUS));
d376 2
a377 1
		cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, sc->xl_intrhand);
@


1.1
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d158 7
@

