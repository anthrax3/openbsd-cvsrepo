head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.16
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.12
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.10
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.8
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.13.0.14
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.12
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7;
locks; strict;
comment	@ * @;


1.15
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2013.11.14.12.10.04;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.06.05.26.24;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.11.20.55.34;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.21.09.53.26;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.27.22.10.25;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.24.20.12.34;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.15.07.20.51;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.13.09.09.26;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.13.08.28.37;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.12.12.59.55;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@/*	$OpenBSD: if_bwi_cardbus.c,v 1.14 2013/11/14 12:10:04 dlg Exp $ */

/*
 * Copyright (c) 2007 Marcus Glocker <mglocker@@openbsd.org>
 * Copyright (c) 2006 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Cardbus front-end for the Broadcom AirForce
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

#include <dev/ic/bwivar.h>

struct bwi_cardbus_softc {
	struct bwi_softc	 csc_bwi;

	/* cardbus specific goo */
	cardbus_devfunc_t	 csc_ct;
	pcitag_t		 csc_tag;
	void			*csc_ih;

	bus_size_t		 csc_mapsize;
	pcireg_t		 csc_bar_val;
	int			 csc_intrline;
	pci_chipset_tag_t	 csc_pc;
};

int		bwi_cardbus_match(struct device *, void *, void*);
void		bwi_cardbus_attach(struct device *, struct device *, void *);
int		bwi_cardbus_detach(struct device *, int);
void		bwi_cardbus_setup(struct bwi_cardbus_softc *);
int		bwi_cardbus_enable(struct bwi_softc *);
void		bwi_cardbus_disable(struct bwi_softc *);
void		bwi_cardbus_conf_write(void *, uint32_t, uint32_t);
uint32_t	bwi_cardbus_conf_read(void *, uint32_t);

struct cfattach bwi_cardbus_ca = {
	sizeof (struct bwi_cardbus_softc), bwi_cardbus_match,
	bwi_cardbus_attach, bwi_cardbus_detach
};

static const struct pci_matchid bwi_cardbus_devices[] = {
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4303 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4306 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4306_2 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4307 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4309 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4318 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4319 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM43XG }
};

int
bwi_cardbus_match(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid(aux, bwi_cardbus_devices,
	    sizeof (bwi_cardbus_devices) / sizeof (bwi_cardbus_devices[0])));
}

void
bwi_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct bwi_cardbus_softc *csc = (struct bwi_cardbus_softc *)self;
	struct cardbus_attach_args *ca = aux;
	struct bwi_softc *sc = &csc->csc_bwi;
	cardbus_devfunc_t ct = ca->ca_ct;
	pcireg_t reg;
	bus_addr_t base;
	int error;

	sc->sc_dmat = ca->ca_dmat;
	csc->csc_ct = ct;
	csc->csc_tag = ca->ca_tag;
	csc->csc_intrline = ca->ca_intrline;
	csc->csc_pc = ca->ca_pc;

	/* power management hooks */
	sc->sc_enable = bwi_cardbus_enable;
	sc->sc_disable = bwi_cardbus_disable;
	//sc->sc_power = bwi_cardbus_power;

	/* map control/status registers */
	error = Cardbus_mapreg_map(ct, CARDBUS_BASE0_REG,
	    PCI_MAPREG_TYPE_MEM, 0, &sc->sc_mem_bt,
	    &sc->sc_mem_bh, &base, &csc->csc_mapsize);
	if (error != 0) {
		printf(": can't map mem space\n");
		return;
	}
	csc->csc_bar_val = base | PCI_MAPREG_TYPE_MEM;

	/* set up the PCI configuration registers */
	bwi_cardbus_setup(csc);

	printf(": irq %d", csc->csc_intrline);

	/* we need to access Cardbus config space from the driver */
	sc->sc_conf_read = bwi_cardbus_conf_read;
	sc->sc_conf_write = bwi_cardbus_conf_write;

	reg = (sc->sc_conf_read)(sc, PCI_SUBSYS_ID_REG);

	sc->sc_pci_revid = PCI_REVISION(ca->ca_class);
	sc->sc_pci_did = PCI_PRODUCT(ca->ca_id);
	sc->sc_pci_subvid = PCI_VENDOR(reg);
	sc->sc_pci_subdid = PCI_PRODUCT(reg);

	error = bwi_attach(sc);
	if (error != 0)
		bwi_cardbus_detach(&sc->sc_dev, 0);

	Cardbus_function_disable(ct);
}

int
bwi_cardbus_detach(struct device *self, int flags)
{
	struct bwi_cardbus_softc *csc = (struct bwi_cardbus_softc *)self;
	struct bwi_softc *sc = &csc->csc_bwi;
	cardbus_devfunc_t ct = csc->csc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
	int error;

	error = bwi_detach(sc);
	if (error != 0)
		return (error);

	/* unhook the interrupt handler */
	if (csc->csc_ih != NULL) {
		cardbus_intr_disestablish(cc, cf, csc->csc_ih);
		csc->csc_ih = NULL;
	}

	/* release bus space and close window */
	Cardbus_mapreg_unmap(ct, CARDBUS_BASE0_REG, sc->sc_mem_bt,
	    sc->sc_mem_bh, csc->csc_mapsize);

	return (0);
}

void
bwi_cardbus_setup(struct bwi_cardbus_softc *csc)
{
	cardbus_devfunc_t ct = csc->csc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = csc->csc_pc;
	cardbus_function_tag_t cf = ct->ct_cf;
	pcireg_t reg;

	/* program the BAR */
	pci_conf_write(pc, csc->csc_tag, CARDBUS_BASE0_REG,
	    csc->csc_bar_val);

	/* make sure the right access type is on the cardbus bridge */
	(*cf->cardbus_ctrl)(cc, CARDBUS_MEM_ENABLE);
	(*cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	/* enable the appropriate bits in the PCI CSR */
	reg = pci_conf_read(pc, csc->csc_tag,
	    PCI_COMMAND_STATUS_REG);
	reg |= PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_MEM_ENABLE;
	pci_conf_write(pc, csc->csc_tag, PCI_COMMAND_STATUS_REG,
	    reg);
}

int
bwi_cardbus_enable(struct bwi_softc *sc)
{
	struct bwi_cardbus_softc *csc = (struct bwi_cardbus_softc *)sc;
	cardbus_devfunc_t ct = csc->csc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/* power on the socket */
	Cardbus_function_enable(ct);

	/* setup the PCI configuration registers */
	bwi_cardbus_setup(csc);

	/* map and establish the interrupt handler */
	csc->csc_ih = cardbus_intr_establish(cc, cf, csc->csc_intrline, IPL_NET,
	    bwi_intr, sc, sc->sc_dev.dv_xname);
	if (csc->csc_ih == NULL) {
		printf("%s: could not establish interrupt at %d\n",
		    sc->sc_dev.dv_xname, csc->csc_intrline);
		Cardbus_function_disable(ct);
		return (1);
	}

	return (0);
}

void
bwi_cardbus_disable(struct bwi_softc *sc)
{
	struct bwi_cardbus_softc *csc = (struct bwi_cardbus_softc *)sc;
	cardbus_devfunc_t ct = csc->csc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/* unhook the interrupt handler */
	cardbus_intr_disestablish(cc, cf, csc->csc_ih);
	csc->csc_ih = NULL;

	/* power down the socket */
	Cardbus_function_disable(ct);
}

void
bwi_cardbus_conf_write(void *self, uint32_t reg, uint32_t val)
{
	struct bwi_cardbus_softc *csc = (struct bwi_cardbus_softc *)self;
	pci_chipset_tag_t pc = csc->csc_pc;

	pci_conf_write(pc, csc->csc_tag, reg, val);
}

uint32_t
bwi_cardbus_conf_read(void *self, uint32_t reg)
{
	struct bwi_cardbus_softc *csc = (struct bwi_cardbus_softc *)self;
	pci_chipset_tag_t pc = csc->csc_pc;

	return (pci_conf_read(pc, csc->csc_tag, reg));
}
@


1.14
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.13 2010/08/06 05:26:24 mglocker Exp $ */
a26 1
#include <sys/task.h>
@


1.13
log
@ACPI suspend/resume for bwi(4).  Initial diff from todd@@, finished and
tested by me on X40 with a BCM4306.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.12 2010/03/27 21:40:13 jsg Exp $ */
d27 1
a27 1
#include <sys/workq.h>
@


1.12
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.11 2010/03/27 20:04:03 jsg Exp $ */
d27 1
@


1.11
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.10 2010/03/22 22:28:27 jsg Exp $ */
d61 1
d111 1
d183 1
d188 1
a188 1
	cardbus_conf_write(cc, cf, csc->csc_tag, CARDBUS_BASE0_REG,
d196 1
a196 1
	reg = cardbus_conf_read(cc, cf, csc->csc_tag,
d199 1
a199 1
	cardbus_conf_write(cc, cf, csc->csc_tag, PCI_COMMAND_STATUS_REG,
d250 1
a250 3
	cardbus_devfunc_t ct = csc->csc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
d252 1
a252 1
	cardbus_conf_write(cc, cf, csc->csc_tag, reg, val);
d259 1
a259 3
	cardbus_devfunc_t ct = csc->csc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
d261 1
a261 1
	return (cardbus_conf_read(cc, cf, csc->csc_tag, reg));
@


1.10
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.9 2009/03/29 21:53:52 sthen Exp $ */
d155 1
a155 1
	pci_chipset_tag_t cc = ct->ct_cc;
d180 1
a180 1
	pci_chipset_tag_t cc = ct->ct_cc;
d205 1
a205 1
	pci_chipset_tag_t cc = ct->ct_cc;
d232 1
a232 1
	pci_chipset_tag_t cc = ct->ct_cc;
d248 1
a248 1
	pci_chipset_tag_t cc = ct->ct_cc;
d259 1
a259 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.9
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.8 2008/09/11 20:55:34 brad Exp $ */
d55 1
a55 1
	cardbustag_t		 csc_tag;
d77 1
a77 1
static const struct cardbus_matchid bwi_cardbus_devices[] = {
d102 1
a102 1
	cardbusreg_t reg;
d118 1
a118 1
	    CARDBUS_MAPREG_TYPE_MEM, 0, &sc->sc_mem_bt,
d124 1
a124 1
	csc->csc_bar_val = base | CARDBUS_MAPREG_TYPE_MEM;
d155 1
a155 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d180 1
a180 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d194 3
a196 3
	    CARDBUS_COMMAND_STATUS_REG);
	reg |= CARDBUS_COMMAND_MASTER_ENABLE | CARDBUS_COMMAND_MEM_ENABLE;
	cardbus_conf_write(cc, cf, csc->csc_tag, CARDBUS_COMMAND_STATUS_REG,
d205 1
a205 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d232 1
a232 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d248 1
a248 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d259 1
a259 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
@


1.8
log
@Remove the BCM4322 id. This is a 802.11n chipset and also requires v4 firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.7 2007/10/21 09:53:26 mglocker Exp $ */
d121 1
a121 1
		printf(": could not map memory space\n");
@


1.7
log
@Replace Cardbus_conf_* calls by cardbus_conf_* ones.  This solves the
panic 'trap type 300` seen on macppc and makes my Linksys WPC54G Ver 3
cardbus device work entirely on my PowerBook G4.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.6 2007/09/27 22:10:25 mglocker Exp $ */
a84 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4322 },
@


1.6
log
@Add automatic rate control (AMRR).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.5 2007/09/24 20:12:34 mglocker Exp $ */
a102 2
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
d136 1
a136 1
	reg = cardbus_conf_read(cc, cf, ca->ca_tag, PCI_SUBSYS_ID_REG);
d248 3
d252 1
a252 1
	Cardbus_conf_write(csc->csc_ct, csc->csc_tag, reg, val);
d259 3
d263 1
a263 1
	return (Cardbus_conf_read(csc->csc_ct, csc->csc_tag, reg));
@


1.5
log
@Remove BCM4311 and BCM4312 which are PCIe chipsets and therefore will not
come in Cardbus devices.

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.4 2007/09/15 07:20:51 jsg Exp $ */
d39 1
@


1.4
log
@Properly fill in some of the pci information the driver uses internally.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.3 2007/09/13 09:09:26 mglocker Exp $ */
a81 2
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4311 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4312 },
@


1.3
log
@No variable names in prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.2 2007/09/13 08:28:37 mglocker Exp $ */
d104 3
d138 7
@


1.2
log
@Enable access to PCI and Cardbus config space from the driver.  Lets us
power on the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bwi_cardbus.c,v 1.1 2007/09/12 12:59:55 mglocker Exp $ */
d62 6
a67 8
int		bwi_cardbus_match(struct device *parent, void *match,
		    void *aux);
void		bwi_cardbus_attach(struct device *parent, struct device *self,
		    void *aux);
int		bwi_cardbus_detach(struct device *self, int flags);
void		bwi_cardbus_setup(struct bwi_cardbus_softc *csc);
int		bwi_cardbus_enable(struct bwi_softc *sc);
void		bwi_cardbus_disable(struct bwi_softc *sc);
@


1.1
log
@PCI and Cardbus hookup for the Broadcom AirForce devices.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d50 1
a50 1
	struct bwi_softc	 sc_bwi;
d53 7
a59 7
	cardbus_devfunc_t	 sc_ct;
	cardbustag_t		 sc_tag;
	void			*sc_ih;

	bus_size_t		 sc_mapsize;
	pcireg_t		 sc_bar_val;
	int			 sc_intrline;
d62 10
a71 7
int	bwi_cardbus_match(struct device *parent, void *match, void *aux);
void	bwi_cardbus_attach(struct device *parent, struct device *self,
	    void *aux);
int	bwi_cardbus_detach(struct device *self, int flags);
void	bwi_cardbus_setup(struct bwi_cardbus_softc *csc);
int	bwi_cardbus_enable(struct bwi_softc *sc);
void	bwi_cardbus_disable(struct bwi_softc *sc);
d104 1
a104 1
	struct bwi_softc *sc = &csc->sc_bwi;
d110 3
a112 3
	csc->sc_ct = ct;
	csc->sc_tag = ca->ca_tag;
	csc->sc_intrline = ca->ca_intrline;
d122 1
a122 1
	    &sc->sc_mem_bh, &base, &csc->sc_mapsize);
d127 1
a127 1
	csc->sc_bar_val = base | CARDBUS_MAPREG_TYPE_MEM;
d132 5
a136 1
	printf(": irq %d", csc->sc_intrline);
d149 2
a150 2
	struct bwi_softc *sc = &csc->sc_bwi;
	cardbus_devfunc_t ct = csc->sc_ct;
d160 3
a162 3
	if (csc->sc_ih != NULL) {
		cardbus_intr_disestablish(cc, cf, csc->sc_ih);
		csc->sc_ih = NULL;
d167 1
a167 1
	    sc->sc_mem_bh, csc->sc_mapsize);
d175 1
a175 1
	cardbus_devfunc_t ct = csc->sc_ct;
d181 2
a182 2
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_BASE0_REG,
	    csc->sc_bar_val);
d189 1
a189 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag,
d192 1
a192 1
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG,
d200 1
a200 1
	cardbus_devfunc_t ct = csc->sc_ct;
d211 1
a211 1
	csc->sc_ih = cardbus_intr_establish(cc, cf, csc->sc_intrline, IPL_NET,
d213 1
a213 1
	if (csc->sc_ih == NULL) {
d215 1
a215 1
		    sc->sc_dev.dv_xname, csc->sc_intrline);
d227 1
a227 1
	cardbus_devfunc_t ct = csc->sc_ct;
d232 2
a233 2
	cardbus_intr_disestablish(cc, cf, csc->sc_ih);
	csc->sc_ih = NULL;
d237 16
@

