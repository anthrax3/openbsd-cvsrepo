head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.8
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.6
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.4
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.12
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.14;
commitid	p4LJxGKbi0BU2cG6;

1.14
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.13;
commitid	uzzBR7hz9ncd4O6G;

1.13
date	2014.05.16.18.17.03;	author mpi;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.20.18.47.03;	author martynas;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.25.23.10.16;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.12.06.26.34;	author jolan;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.21.11.27.03;	author fkr;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.30.04.01.18;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.26.18.57.37;	author nate;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: uhci_cardbus.c,v 1.14 2014/09/14 14:17:24 jsg Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/cardbus/cardbusvar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#include <dev/usb/uhcireg.h>
#include <dev/usb/uhcivar.h>

int	uhci_cardbus_match(struct device *, void *, void *);
void	uhci_cardbus_attach(struct device *, struct device *, void *);
int	uhci_cardbus_detach(struct device *, int);

struct uhci_cardbus_softc {
	struct uhci_softc	sc;
	cardbus_chipset_tag_t	sc_cc;
	cardbus_function_tag_t	sc_cf;
	cardbus_devfunc_t	sc_ct;
	void 			*sc_ih;		/* interrupt vectoring */
};

struct cfattach uhci_cardbus_ca = {
	sizeof(struct uhci_cardbus_softc), uhci_cardbus_match,
	    uhci_cardbus_attach, uhci_cardbus_detach, uhci_activate
};

#define cardbus_findvendor pci_findvendor

int
uhci_cardbus_match(struct device *parent, void *match, void *aux)
{
	struct cardbus_attach_args *ca = (struct cardbus_attach_args *)aux;

	if (PCI_CLASS(ca->ca_class) == PCI_CLASS_SERIALBUS &&
	    PCI_SUBCLASS(ca->ca_class) == PCI_SUBCLASS_SERIALBUS_USB &&
	    PCI_INTERFACE(ca->ca_class) == PCI_INTERFACE_UHCI)
		return (1);
 
	return (0);
}

void
uhci_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct uhci_cardbus_softc *sc = (struct uhci_cardbus_softc *)self;
	struct cardbus_attach_args *ca = aux;
	cardbus_devfunc_t ct = ca->ca_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = ca->ca_pc;
	cardbus_function_tag_t cf = ct->ct_cf;
	pcireg_t csr;
	usbd_status r;
	const char *vendor;
	const char *devname = sc->sc.sc_bus.bdev.dv_xname;

	/* Map I/O registers */
	if (Cardbus_mapreg_map(ct, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
			   &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size)) {
		printf(": can't map io space\n");
		return;
	}

	/* Disable interrupts, so we don't get any spurious ones. */
	bus_space_write_2(sc->sc.iot, sc->sc.ioh, UHCI_INTR, 0);

	sc->sc_cc = cc;
	sc->sc_cf = cf;
	sc->sc_ct = ct;
	sc->sc.sc_bus.dmatag = ca->ca_dmat;

	(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_IO_ENABLE);
	(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	/* Enable the device. */
	csr = pci_conf_read(pc, ca->ca_tag,
				PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, ca->ca_tag, PCI_COMMAND_STATUS_REG,
		       csr | PCI_COMMAND_MASTER_ENABLE
			   | PCI_COMMAND_IO_ENABLE);

	sc->sc_ih = cardbus_intr_establish(cc, cf, ca->ca_intrline,
					   IPL_USB, uhci_intr, sc, devname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt\n");
		return;
	}
	printf(": irq %d\n", ca->ca_intrline);

	/* Set LEGSUP register to its default value. */
	pci_conf_write(pc, ca->ca_tag, PCI_LEGSUP,
			   PCI_LEGSUP_USBPIRQDEN);

	switch(pci_conf_read(pc, ca->ca_tag, PCI_USBREV) & PCI_USBREV_MASK) {
	case PCI_USBREV_PRE_1_0:
		sc->sc.sc_bus.usbrev = USBREV_PRE_1_0;
		break;
	case PCI_USBREV_1_0:
		sc->sc.sc_bus.usbrev = USBREV_1_0;
		break;
	case PCI_USBREV_1_1:
		sc->sc.sc_bus.usbrev = USBREV_1_1;
		break;
	default:
		sc->sc.sc_bus.usbrev = USBREV_UNKNOWN;
		break;
	}

	uhci_run(&sc->sc, 0);			/* stop the controller */
						/* disable interrupts */
	bus_space_barrier(sc->sc.iot, sc->sc.ioh, 0, sc->sc.sc_size,
	    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);
	bus_space_write_2(sc->sc.iot, sc->sc.ioh, UHCI_INTR, 0);

	/* Figure out vendor for root hub descriptor. */
	vendor = cardbus_findvendor(ca->ca_id);
	sc->sc.sc_id_vendor = PCI_VENDOR(ca->ca_id);
	if (vendor)
		strlcpy(sc->sc.sc_vendor, vendor, sizeof (sc->sc.sc_vendor));
	else
		snprintf(sc->sc.sc_vendor, sizeof(sc->sc.sc_vendor),
		    "vendor 0x%04x", PCI_VENDOR(ca->ca_id));
	
	r = uhci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf("%s: init failed, error=%d\n", devname, r);
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		return;
	}

	/* Attach usb device. */
	config_found(self, &sc->sc.sc_bus, usbctlprint);
}

int
uhci_cardbus_detach(struct device *self, int flags)
{
	struct uhci_cardbus_softc *sc = (struct uhci_cardbus_softc *)self;
	struct cardbus_devfunc *ct = sc->sc_ct;
	int rv;

	rv = uhci_detach(self, flags);
	if (rv)
		return (rv);

	if (sc->sc_ih != NULL) {
		cardbus_intr_disestablish(sc->sc_cc, sc->sc_cf, sc->sc_ih);
		sc->sc_ih = NULL;
	}

	if (sc->sc.sc_size) {
		Cardbus_mapreg_unmap(ct, PCI_CBIO, sc->sc.iot,
		    sc->sc.ioh, sc->sc.sc_size);
		sc->sc.sc_size = 0;
	}

	return (0);
}
@


1.14
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.13 2014/05/16 18:17:03 mpi Exp $	*/
a40 1
#include <dev/pci/pcidevs.h>
@


1.13
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.12 2013/04/15 09:23:01 mglocker Exp $	*/
a36 1
#include <sys/proc.h>
@


1.12
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.11 2010/03/27 21:40:13 jsg Exp $	*/
d173 1
a173 2
	sc->sc.sc_child = config_found((void *)sc, &sc->sc.sc_bus,
				       usbctlprint);
d183 1
a183 1
	rv = uhci_detach(&sc->sc, flags);
@


1.11
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.10 2010/03/27 20:04:03 jsg Exp $	*/
d57 1
a57 1
	uhci_softc_t		sc;
@


1.10
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.9 2010/03/22 22:28:27 jsg Exp $	*/
d91 1
d117 1
a117 1
	csr = cardbus_conf_read(cc, cf, ca->ca_tag,
d119 1
a119 1
	cardbus_conf_write(cc, cf, ca->ca_tag, PCI_COMMAND_STATUS_REG,
d132 1
a132 1
	cardbus_conf_write(cc, cf, ca->ca_tag, PCI_LEGSUP,
d135 1
a135 1
	switch(cardbus_conf_read(cc, cf, ca->ca_tag, PCI_USBREV) & PCI_USBREV_MASK) {
@


1.9
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.8 2009/08/20 18:47:03 martynas Exp $	*/
d58 1
a58 1
	pci_chipset_tag_t	sc_cc;
d90 1
a90 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.8
log
@- fix varargs after dmesg tweaking
- intrline is not a string
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.7 2008/06/26 05:42:14 ray Exp $	*/
d58 1
a58 1
	cardbus_chipset_tag_t	sc_cc;
a68 1
#define CARDBUS_INTERFACE_UHCI PCI_INTERFACE_UHCI
d76 3
a78 3
	if (CARDBUS_CLASS(ca->ca_class) == CARDBUS_CLASS_SERIALBUS &&
	    CARDBUS_SUBCLASS(ca->ca_class) == CARDBUS_SUBCLASS_SERIALBUS_USB &&
	    CARDBUS_INTERFACE(ca->ca_class) == CARDBUS_INTERFACE_UHCI)
d90 1
a90 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d92 1
a92 1
	cardbusreg_t csr;
d98 1
a98 1
	if (Cardbus_mapreg_map(ct, PCI_CBIO, CARDBUS_MAPREG_TYPE_IO, 0,
d117 4
a120 4
				CARDBUS_COMMAND_STATUS_REG);
	cardbus_conf_write(cc, cf, ca->ca_tag, CARDBUS_COMMAND_STATUS_REG,
		       csr | CARDBUS_COMMAND_MASTER_ENABLE
			   | CARDBUS_COMMAND_IO_ENABLE);
d157 1
a157 1
	sc->sc.sc_id_vendor = CARDBUS_VENDOR(ca->ca_id);
d162 1
a162 1
		    "vendor 0x%04x", CARDBUS_VENDOR(ca->ca_id));
@


1.7
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.6 2008/02/25 23:10:16 brad Exp $	*/
d101 1
a101 1
		printf(": can't map io space\n", devname);
d126 1
a126 1
		printf(": couldn't establish interrupt\n", devname);
@


1.6
log
@Following up with further dmesg display tweaking after the cardbusprint()
change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.5 2006/10/12 16:35:52 grange Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.5
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.4 2006/07/12 06:26:34 jolan Exp $	*/
a77 1
#define cardbus_devinfo pci_devinfo
a100 1
	char devinfo[256];
a104 3
	cardbus_devinfo(ca->ca_id, ca->ca_class, 0, devinfo, sizeof(devinfo));
	printf(" %s", devinfo);

d108 1
a108 1
		printf("%s: can't map io space\n", devname);
d133 1
a133 1
		printf("%s: couldn't establish interrupt\n", devname);
@


1.4
log
@make dmesg lines openbsd-style, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.3 2006/06/21 11:27:03 fkr Exp $	*/
d136 1
a136 1
					   IPL_USB, uhci_intr, sc);
@


1.3
log
@removal of '#ifdef rbus ... #else ...' directives, we use rbus in all
cases anyways, so we might as well remove code (the !rbus case) thats been
dead throughout the last years and just use the rbus code without ifdefs.

brad, miod "I am all for this diff"
ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.2 2005/12/30 04:01:18 dlg Exp $	*/
d102 1
d106 3
@


1.2
log
@remove #if __NetBSD__ and device_ptr_t. its more readable and less
confusing now.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci_cardbus.c,v 1.1 2005/05/26 18:57:37 nate Exp $	*/
a120 4
#if rbus
#else
XXX	(ct->ct_cf->cardbus_io_open)(cc, 0, iob, iob + 0x40);
#endif
@


1.1
log
@add a cardbus attachment for uhci.  This code is based on the ohci_cardbus.c
and uhci_pci.c files.  ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 1
a61 1
int	uhci_cardbus_detach(device_ptr_t, int);
d190 1
a190 1
uhci_cardbus_detach(device_ptr_t self, int flags)
@

