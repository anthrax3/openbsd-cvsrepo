head	1.13;
access;
symbols
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.13
date	2007.04.05.16.25.25;	author mglocker;	state dead;
branches;
next	1.12;

1.12
date	2007.03.04.11.06.07;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.04.00.43.25;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.26.14.36.11;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.26.14.14.02;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.25.17.03.08;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.25.10.06.04;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.25.09.07.18;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.08.01.28.39;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.06.19.21.45;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.22.23.46.49;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.22.22.20.34;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.22.15.12.50;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.13
log
@After been attacked by Michael Buesch <mb@@bu3sch.de> because we initially
were using some of their routines in the bcw driver, I decided to stop
working on it.  To avoid any further license chit chat I plain drop the
driver.
@
text
@/*	$OpenBSD: if_bcw_cardbus.c,v 1.12 2007/03/04 11:06:07 mglocker Exp $ */

/*
 * Copyright (c) 2006 Jon Simola <jsimola@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* CardBus attachment for Broadcom BCM43xx 802.11 wireless */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

#include <dev/ic/bcwreg.h>
#include <dev/ic/bcwvar.h>

struct bcw_cardbus_softc {
	struct bcw_softc	 sc_bcw;

	/* cardbus specific goo */
	cardbus_devfunc_t	 sc_ct;
	cardbustag_t		 sc_tag;
	void			*sc_ih;

	bus_size_t		 sc_mapsize;
	pcireg_t		 sc_bar_val;
	int			 sc_intrline;
};

int		bcw_cardbus_match(struct device *, void *, void *);
void		bcw_cardbus_attach(struct device *, struct device *, void *);
int		bcw_cardbus_detach(struct device *, int);
void		bcw_cardbus_power(struct bcw_softc *, int);
void		bcw_cardbus_setup(struct bcw_cardbus_softc *);
int		bcw_cardbus_enable(struct bcw_softc *);
void		bcw_cardbus_disable(struct bcw_softc *);
void		bcw_cardbus_conf_write(void *, uint32_t, uint32_t);
uint32_t	bcw_cardbus_conf_read(void *, uint32_t);

struct cfattach bcw_cardbus_ca = {
	sizeof (struct bcw_cardbus_softc), bcw_cardbus_match,
	bcw_cardbus_attach, bcw_cardbus_detach
};

static const struct cardbus_matchid bcw_cardbus_devices[] = {
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4303 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4306 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4306_2 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4307 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4309 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4311 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4312 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4318 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4319 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4322 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM43XG }
};

int
bcw_cardbus_match(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid(aux, bcw_cardbus_devices,
	    sizeof(bcw_cardbus_devices) / sizeof(bcw_cardbus_devices[0])));
}

void
bcw_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct bcw_cardbus_softc *csc = (struct bcw_cardbus_softc *)self;
	struct cardbus_attach_args *ca = aux;
	struct bcw_softc *sc = &csc->sc_bcw;
	cardbus_devfunc_t ct = ca->ca_ct;
	bus_addr_t base;
	int error;

	sc->sc_dmat = ca->ca_dmat;
	csc->sc_ct = ct;
	csc->sc_tag = ca->ca_tag;
	csc->sc_intrline = ca->ca_intrline;
	sc->sc_dev_softc = csc;

	/* power management hooks */
	sc->sc_enable = bcw_cardbus_enable;
	sc->sc_disable = bcw_cardbus_disable;
	sc->sc_power = bcw_cardbus_power;

	/* config register read/write functions */
	sc->sc_conf_read = bcw_cardbus_conf_read;
	sc->sc_conf_write = bcw_cardbus_conf_write;

	/* map control/status registers */
	error = Cardbus_mapreg_map(ct, CARDBUS_BASE0_REG,
	    CARDBUS_MAPREG_TYPE_MEM, 0, &sc->sc_iot,
	    &sc->sc_ioh, &base, &csc->sc_mapsize);
	if (error != 0) {
		printf(": could not map 1st memory space\n");
		return;
	}
	csc->sc_bar_val = base | CARDBUS_MAPREG_TYPE_MEM;

	/* set up the PCI configuration registers */
	bcw_cardbus_setup(csc);

	printf(": irq %d", csc->sc_intrline);

	/*
	 * Get some cardbus info into the softc
	 */
	sc->sc_board_vendor = CARDBUS_VENDOR(ca->ca_id);
	sc->sc_prodid = CARDBUS_PRODUCT(ca->ca_id); /* XXX */
	sc->sc_board_type = sc->sc_prodid; /* XXX */
	sc->sc_board_rev = CARDBUS_REVISION(ca->ca_class);

#if 0
	error = bcw_attach(sc);
	if (error != 0)
		bcw_cardbus_detach(&sc->sc_dev, 0);
#endif
	bcw_attach(sc);

	//Cardbus_function_disable(ct);
}

int
bcw_cardbus_detach(struct device *self, int flags)
{
	struct bcw_cardbus_softc *csc = (struct bcw_cardbus_softc *)self;
	struct bcw_softc *sc = &csc->sc_bcw;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
	int error;

	error = bcw_detach(sc);
	if (error != 0)
		return (error);

	/* unhook the interrupt handler */
	if (csc->sc_ih != NULL) {
		cardbus_intr_disestablish(cc, cf, csc->sc_ih);
		csc->sc_ih = NULL;
	}

	/* release bus space and close window */
	Cardbus_mapreg_unmap(ct, CARDBUS_BASE0_REG, sc->sc_iot,
	    sc->sc_ioh, csc->sc_mapsize);

	return (0);
}

void
bcw_cardbus_power(struct bcw_softc *sc, int why)
{
	struct bcw_cardbus_softc *csc = (struct bcw_cardbus_softc *)sc;

	if (why == PWR_RESUME) {
		/* kick the PCI configuration registers */
		bcw_cardbus_setup(csc);
	}
}

void
bcw_cardbus_setup(struct bcw_cardbus_softc *csc)
{
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
	pcireg_t reg;

	/* program the BAR */
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_BASE0_REG,
	    csc->sc_bar_val);

	/* make sure the right access type is on the cardbus bridge */
	(*cf->cardbus_ctrl)(cc, CARDBUS_MEM_ENABLE);
	(*cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	/* enable the appropriate bits in the PCI CSR */
	reg = cardbus_conf_read(cc, cf, csc->sc_tag,
	    CARDBUS_COMMAND_STATUS_REG);
	reg |= CARDBUS_COMMAND_MASTER_ENABLE | CARDBUS_COMMAND_MEM_ENABLE;
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG,
	    reg);
}

int
bcw_cardbus_enable(struct bcw_softc *sc)
{
	struct bcw_cardbus_softc *csc = (struct bcw_cardbus_softc *)sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/* power on the socket */
	Cardbus_function_enable(ct);

	/* setup the PCI configuration registers */
	bcw_cardbus_setup(csc);

	/* map and establish the interrupt handler */
	csc->sc_ih = cardbus_intr_establish(cc, cf, csc->sc_intrline, IPL_NET,
	    bcw_intr, sc, sc->sc_dev.dv_xname);
	if (csc->sc_ih == NULL) {
		printf("%s: could not establish interrupt at %d\n",
		    sc->sc_dev.dv_xname, csc->sc_intrline);
		Cardbus_function_disable(ct);
		return (1);
	}

	return (0);
}

void
bcw_cardbus_disable(struct bcw_softc *sc)
{
	struct bcw_cardbus_softc *csc = (struct bcw_cardbus_softc *)sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/* unhook the interrupt handler */
	cardbus_intr_disestablish(cc, cf, csc->sc_ih);
	csc->sc_ih = NULL;

	/* power down the socket */
	Cardbus_function_disable(ct);
}

void
bcw_cardbus_conf_write(void *self, uint32_t reg, uint32_t val)
{
	struct bcw_cardbus_softc *csc = (struct bcw_cardbus_softc *)self;

	Cardbus_conf_write(csc->sc_ct, csc->sc_tag, reg, val);
}

uint32_t
bcw_cardbus_conf_read(void *self, uint32_t reg)
{
	struct bcw_cardbus_softc *csc = (struct bcw_cardbus_softc *)self;

	return (Cardbus_conf_read(csc->sc_ct, csc->sc_tag, reg));
}
@


1.12
log
@Use CARDBUS_PRODUCT macro to read product id.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.11 2007/03/04 00:43:25 mglocker Exp $ */
@


1.11
log
@Kill a cardbus dependency which breaked kernel compilation e.g. for
sparc*.

OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.10 2007/02/26 14:36:11 mglocker Exp $ */
d140 2
a141 1
	sc->sc_board_type = sc->sc_conf_read(sc, 0x2e);
a142 1
	sc->sc_prodid = CARDBUS_PRODUCT(ca->ca_id);
@


1.10
log
@Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.9 2007/02/26 14:14:02 mglocker Exp $ */
d67 2
a68 2
void		bcw_cardbus_conf_write(struct bcw_softc *, uint32_t, uint32_t);
uint32_t	bcw_cardbus_conf_read(struct bcw_softc *, uint32_t);
d110 1
a110 2
	sc->sc_ca.ca_tag = ca->ca_tag;
	sc->sc_ca.ca_ct = ca->ca_ct;
d260 1
a260 1
bcw_cardbus_conf_write(struct bcw_softc *sc, uint32_t reg, uint32_t val)
d262 3
a264 1
	Cardbus_conf_write(sc->sc_ca.ca_ct, sc->sc_ca.ca_tag, reg, val);
d268 1
a268 1
bcw_cardbus_conf_read(struct bcw_softc *sc, uint32_t reg)
d270 3
a272 1
	return (Cardbus_conf_read(sc->sc_ca.ca_ct, sc->sc_ca.ca_tag, reg));
@


1.9
log
@We need to save some PCI infos in our softc struct for further decisions
in the driver code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.8 2007/02/25 17:03:08 mglocker Exp $ */
d48 1
a48 1
	struct bcw_softc	sc_bcw;
d51 2
a52 2
	cardbus_devfunc_t	sc_ct;
	cardbustag_t		sc_tag;
d55 3
a57 3
	bus_size_t		sc_mapsize;
	pcireg_t		sc_bar_val;
	int			sc_intrline;
d60 9
a68 9
int	bcw_cardbus_match(struct device *, void *, void *);
void	bcw_cardbus_attach(struct device *, struct device *, void *);
int	bcw_cardbus_detach(struct device *, int);
void	bcw_cardbus_power(struct bcw_softc *, int);
void	bcw_cardbus_setup(struct bcw_cardbus_softc *);
int	bcw_cardbus_enable(struct bcw_softc *);
void	bcw_cardbus_disable(struct bcw_softc *);
void	bcw_cardbus_conf_write(struct bcw_softc *, u_int32_t, u_int32_t);
u_int32_t	bcw_cardbus_conf_read(struct bcw_softc *, u_int32_t);
d261 1
a261 1
bcw_cardbus_conf_write(struct bcw_softc *sc, u_int32_t reg, u_int32_t val)
d266 2
a267 2
u_int32_t
bcw_cardbus_conf_read(struct bcw_softc *sc, u_int32_t reg)
d269 1
a269 1
	return Cardbus_conf_read(sc->sc_ca.ca_ct, sc->sc_ca.ca_tag, reg);
@


1.8
log
@Power on/off cardbus socket at attach/detach time.  Makes firmware upload
work on my BCM4318 cardbus device now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.7 2007/02/25 10:06:04 mglocker Exp $ */
d140 3
@


1.7
log
@No need to fillup chip_rev here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.6 2007/02/25 09:07:18 mglocker Exp $ */
d149 1
a149 1
	Cardbus_function_disable(ct);
@


1.6
log
@Adjust var name so cardbus attaches again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.5 2006/12/08 01:28:39 mglocker Exp $ */
a139 1
	sc->sc_chip_rev = PCI_REVISION(ca->ca_class);
@


1.5
log
@From Jon Simola <simola@@mecha.com>:

Style and whitespace cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.4 2006/12/06 19:21:45 mglocker Exp $ */
d140 1
a140 1
	sc->sc_chiprev = PCI_REVISION(ca->ca_class);
@


1.4
log
@From Jon Simola <simola@@mecha.com>:

Add bus-specific config space read and write functions, this fixes the
attach for ian@@darwinsys.com and properly enumerates multiple cores.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.3 2006/11/22 23:46:49 brad Exp $ */
d93 1
a93 1
	    sizeof (bcw_cardbus_devices) / sizeof (bcw_cardbus_devices[0])));
d140 2
a141 2
	sc->sc_chiprev=PCI_REVISION(ca->ca_class);
	sc->sc_prodid=CARDBUS_PRODUCT(ca->ca_id);
d258 1
a258 1
void      
d260 4
a263 4
{          
        Cardbus_conf_write(sc->sc_ca.ca_ct, sc->sc_ca.ca_tag, reg, val);
}       
                
d267 2
a268 2
        return Cardbus_conf_read(sc->sc_ca.ca_ct, sc->sc_ca.ca_tag, reg);
}       
@


1.3
log
@add the BCM4312 PCI id.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.2 2006/11/22 22:20:34 damien Exp $ */
d67 2
d110 2
d118 4
d257 12
@


1.2
log
@style(9): remove variables names from prototypes.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_cardbus.c,v 1.1 2006/11/22 15:12:50 mglocker Exp $ */
d80 1
@


1.1
log
@From Jon Simola <jon@@mecha.ca>:

Attach to cardbus based bcw cards, and more cleanup. This should help
with a few of the card lockup reports I've received.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d60 7
a66 8
int	bcw_cardbus_match(struct device *parent, void *match, void *aux);
void	bcw_cardbus_attach(struct device *parent, struct device *self,
	    void *aux);
int	bcw_cardbus_detach(struct device *self, int flags);
void	bcw_cardbus_power(struct bcw_softc *sc, int);
void	bcw_cardbus_setup(struct bcw_cardbus_softc *csc);
int	bcw_cardbus_enable(struct bcw_softc *sc);
void	bcw_cardbus_disable(struct bcw_softc *sc);
@

