head	1.51;
access;
symbols
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.49.0.4
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.46.0.6
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.45.0.10
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.8
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.6
	OPENBSD_5_0:1.45.0.4
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.38.0.6
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.4
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.2
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.34.0.4
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.51
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	NdgfPIGUgJxQPnT7;

1.50
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.49;
commitid	p4LJxGKbi0BU2cG6;

1.49
date	2014.12.18.10.51.35;	author mpi;	state Exp;
branches;
next	1.48;
commitid	SNaMCuMHfJem4Hr0;

1.48
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.47;
commitid	uzzBR7hz9ncd4O6G;

1.47
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.46;
commitid	I19imNlAX05zJOED;

1.46
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.25.21.37.59;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.42;

1.42
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.13.09.10.33;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2009.12.15.20.26.21;	author jasper;	state Exp;
branches;
next	1.39;

1.39
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.38;

1.38
date	2008.02.25.20.30.56;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.19.21.54.22;	author martin;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.19.04.25.52;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.17.20.29.47;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.12.16.35.51;	author grange;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.21.11.27.03;	author fkr;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.07.12.42.16;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.26.22.43.18;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.13.18.53.01;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.13.18.44.38;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.13.15.21.24;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.12.18.47.50;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.12.17.16.48;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.09.21.27.45;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.05.20.25.27;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.22.18.00.37;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.18.16.01.29;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.02.21.49.46;	author pascoe;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.28.19.46.07;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.28.02.35.48;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.27.17.03.04;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.09.02.01.36;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.09.00.38.57;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.07.21.16.59;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.18.00.19.48;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.02.21.42.58;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.15.17.59.38;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.22.17.40.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.04.16.59.31;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.26.19.12.52;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.21.10.07.33;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.03.16.04;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.03.20.28.02;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.24.21.29.05;	author mickey;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2000.05.15.06.36.21;	author niklas;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.04.08.05.50.52;	author aaron;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.22.23.09;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.07.04.10.40.19;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2002.03.29.23.39.33;	author niklas;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2003.05.13.19.34.57;	author ho;	state Exp;
branches;
next	1.2.6.6;

1.2.6.6
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	1.2.6.7;

1.2.6.7
date	2004.06.05.23.12.37;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.01.31.22.55.30;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.05.19.22.01.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.51
log
@fairly simple sizes for free(); ok tedu
@
text
@/*	$OpenBSD: cardbus.c,v 1.50 2015/03/14 03:38:47 jsg Exp $	*/
/*	$NetBSD: cardbus.c,v 1.24 2000/04/02 19:11:37 mycroft Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999 and 2000
 *     HAYAKAWA Koichi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/kernel.h>

#include <machine/bus.h>

#include <dev/cardbus/cardbusvar.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbus_exrom.h>

#include <dev/pci/pcivar.h>	/* XXX */
#include <dev/pci/pcireg.h>	/* XXX */

#include <dev/pcmcia/pcmciareg.h>

#ifdef CARDBUS_DEBUG
#define STATIC
#define DPRINTF(a) printf a
#else
#ifdef DDB
#define STATIC
#else
#define STATIC static
#endif
#define DPRINTF(a)
#endif

STATIC void cardbusattach(struct device *, struct device *, void *);
/* STATIC int cardbusprint(void *, const char *); */

STATIC int cardbusmatch(struct device *, void *, void *);
STATIC int cardbussubmatch(struct device *, void *, void *);
STATIC int cardbusprint(void *, const char *);

typedef void (*tuple_decode_func)(u_int8_t *, int, void *);

STATIC int decode_tuples(u_int8_t *, int, tuple_decode_func, void *);
STATIC void parse_tuple(u_int8_t *, int, void *);
#ifdef CARDBUS_DEBUG
static void print_tuple(u_int8_t *, int, void *);
#endif

STATIC int cardbus_read_tuples(struct cardbus_attach_args *,
    pcireg_t, u_int8_t *, size_t);

STATIC void enable_function(struct cardbus_softc *, int, int);
STATIC void disable_function(struct cardbus_softc *, int);


struct cfattach cardbus_ca = {
	sizeof(struct cardbus_softc), cardbusmatch, cardbusattach
};

struct cfdriver cardbus_cd = {
	NULL, "cardbus", DV_DULL
};

STATIC int
cardbusmatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct cbslot_attach_args *cba = aux;

	if (strcmp(cba->cba_busname, cf->cf_driver->cd_name)) {
		DPRINTF(("cardbusmatch: busname differs %s <=> %s\n",
		    cba->cba_busname, cf->cf_driver->cd_name));
		return (0);
	}

	return (1);
}

STATIC void
cardbusattach(struct device *parent, struct device *self, void *aux)
{
	struct cardbus_softc *sc = (void *)self;
	struct cbslot_attach_args *cba = aux;
	int cdstatus;

	sc->sc_bus = cba->cba_bus;
	sc->sc_device = 0;
	sc->sc_intrline = cba->cba_intrline;
	sc->sc_cacheline = cba->cba_cacheline;
	sc->sc_lattimer = cba->cba_lattimer;

	printf(": bus %d device %d", sc->sc_bus, sc->sc_device);
	printf(" cacheline 0x%x, lattimer 0x%x\n",
	    sc->sc_cacheline,sc->sc_lattimer);

	sc->sc_iot = cba->cba_iot;	/* CardBus I/O space tag */
	sc->sc_memt = cba->cba_memt;	/* CardBus MEM space tag */
	sc->sc_dmat = cba->cba_dmat;	/* DMA tag */
	sc->sc_cc = cba->cba_cc;
	sc->sc_pc = cba->cba_pc;
	sc->sc_cf = cba->cba_cf;
	sc->sc_rbus_iot = cba->cba_rbus_iot;
	sc->sc_rbus_memt = cba->cba_rbus_memt;

	cdstatus = 0;
}

STATIC int
cardbus_read_tuples(struct cardbus_attach_args *ca, pcireg_t cis_ptr,
    u_int8_t *tuples, size_t len)
{
	struct cardbus_softc *sc = ca->ca_ct->ct_sc;
	pci_chipset_tag_t pc = ca->ca_pc;
	pcitag_t tag = ca->ca_tag;
	pcireg_t command;
	int found = 0;

	int i, j;
	int cardbus_space = cis_ptr & CARDBUS_CIS_ASIMASK;
	bus_space_tag_t bar_tag;
	bus_space_handle_t bar_memh;
	bus_size_t bar_size;
	bus_addr_t bar_addr;

	int reg;

	memset(tuples, 0, len);

	cis_ptr = cis_ptr & CARDBUS_CIS_ADDRMASK;

	switch (cardbus_space) {
	case CARDBUS_CIS_ASI_TUPLE:
		DPRINTF(("%s: reading CIS data from configuration space\n",
		    sc->sc_dev.dv_xname));
		for (i = cis_ptr, j = 0; i < 0xff; i += 4) {
			u_int32_t e = pci_conf_read(pc, tag, i);
			tuples[j] = 0xff & e;
			e >>= 8;
			tuples[j + 1] = 0xff & e;
			e >>= 8;
			tuples[j + 2] = 0xff & e;
			e >>= 8;
			tuples[j + 3] = 0xff & e;
			j += 4;
		}
		found++;
		break;

	case CARDBUS_CIS_ASI_BAR0:
	case CARDBUS_CIS_ASI_BAR1:
	case CARDBUS_CIS_ASI_BAR2:
	case CARDBUS_CIS_ASI_BAR3:
	case CARDBUS_CIS_ASI_BAR4:
	case CARDBUS_CIS_ASI_BAR5:
	case CARDBUS_CIS_ASI_ROM:
		if (cardbus_space == CARDBUS_CIS_ASI_ROM) {
			reg = CARDBUS_ROM_REG;
			DPRINTF(("%s: reading CIS data from ROM\n",
			    sc->sc_dev.dv_xname));
		} else {
			reg = CARDBUS_BASE0_REG + (cardbus_space - 1) * 4;
			DPRINTF(("%s: reading CIS data from BAR%d\n",
			    sc->sc_dev.dv_xname, cardbus_space - 1));
		}

		/* XXX zero register so mapreg_map doesn't get confused by old
		   contents */
		pci_conf_write(pc, tag, reg, 0);
		if (Cardbus_mapreg_map(ca->ca_ct, reg,
		    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
		    &bar_tag, &bar_memh, &bar_addr, &bar_size)) {
			printf("%s: can't map memory\n",
			    sc->sc_dev.dv_xname);
			return (1);
		}

		if (cardbus_space == CARDBUS_CIS_ASI_ROM) {
			pcireg_t exrom;
			int save;
			struct cardbus_rom_image_head rom_image;
			struct cardbus_rom_image *p;

			save = splhigh();
			/* enable rom address decoder */
			exrom = pci_conf_read(pc, tag, reg);
			pci_conf_write(pc, tag, reg, exrom | 1);

			command = pci_conf_read(pc, tag,
			    PCI_COMMAND_STATUS_REG);
			pci_conf_write(pc, tag,
			    PCI_COMMAND_STATUS_REG,
			    command | PCI_COMMAND_MEM_ENABLE);

			if (cardbus_read_exrom(ca->ca_memt, bar_memh,
			    &rom_image))
				goto out;

			for (p = SIMPLEQ_FIRST(&rom_image); p;
			    p = SIMPLEQ_NEXT(p, next)) {
				if (p->rom_image ==
				    CARDBUS_CIS_ASI_ROM_IMAGE(cis_ptr)) {
					bus_space_read_region_1(p->romt,
					    p->romh, CARDBUS_CIS_ADDR(cis_ptr),
					    tuples, MIN(p->image_size, len));
					found++;
					break;
				}
			}

		out:
			while ((p = SIMPLEQ_FIRST(&rom_image)) != NULL) {
				SIMPLEQ_REMOVE_HEAD(&rom_image, next);
				free(p, M_DEVBUF, sizeof(*p));
			}
			exrom = pci_conf_read(pc, tag, reg);
			pci_conf_write(pc, tag, reg, exrom & ~1);
			splx(save);
		} else {
			command = pci_conf_read(pc, tag,
			    PCI_COMMAND_STATUS_REG);
			pci_conf_write(pc, tag,
			    PCI_COMMAND_STATUS_REG,
    			    command | PCI_COMMAND_MEM_ENABLE);
			/* XXX byte order? */
			bus_space_read_region_1(ca->ca_memt, bar_memh,
			    cis_ptr, tuples, 256);
			found++;
		}
		command = pci_conf_read(pc, tag,
		    PCI_COMMAND_STATUS_REG);
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
		    command & ~PCI_COMMAND_MEM_ENABLE);
		pci_conf_write(pc, tag, reg, 0);

		Cardbus_mapreg_unmap(ca->ca_ct, reg, bar_tag, bar_memh,
		    bar_size);
		break;

#ifdef DIAGNOSTIC
		default:
			panic("%s: bad CIS space (%d)", sc->sc_dev.dv_xname,
			    cardbus_space);
#endif
	}
	return (!found);
}

STATIC void
parse_tuple(u_int8_t *tuple, int len, void *data)
{
	struct cardbus_cis_info *cis = data;
	int bar_index;
	int i;
	char *p;

	switch (tuple[0]) {
	case PCMCIA_CISTPL_MANFID:
		if (tuple[1] < 4) {
			DPRINTF(("%s: wrong length manufacturer id (%d)\n",
			    __func__, tuple[1]));
			break;
		}
		cis->manufacturer = tuple[2] | (tuple[3] << 8);
		cis->product = tuple[4] | (tuple[5] << 8);
		break;
	case PCMCIA_CISTPL_VERS_1:
		bcopy(tuple + 2, cis->cis1_info_buf, tuple[1]);
		i = 0;
		p = cis->cis1_info_buf + 2;
		while (i <
		    sizeof(cis->cis1_info) / sizeof(cis->cis1_info[0])) {
			if (p >= cis->cis1_info_buf + tuple[1] || *p == '\xff')
				break;
			cis->cis1_info[i++] = p;
			while (*p != '\0' && *p != '\xff')
				p++;
			if (*p == '\0')
				p++;
		}
		break;
	case PCMCIA_CISTPL_BAR:
		if (tuple[1] != 6) {
			DPRINTF(("%s: BAR with short length (%d)\n",
			    __func__, tuple[1]));
			break;
		}
		bar_index = tuple[2] & 7;
		if (bar_index == 0) {
			DPRINTF(("%s: invalid ASI in BAR tuple\n",
			    __func__));
			break;
		}
		bar_index--;
		cis->bar[bar_index].flags = tuple[2];
		cis->bar[bar_index].size = (tuple[4] << 0) |
		    (tuple[5] << 8) | (tuple[6] << 16) | (tuple[7] << 24);
		break;
    case PCMCIA_CISTPL_FUNCID:
		cis->funcid = tuple[2];
		break;

    case PCMCIA_CISTPL_FUNCE:
		switch (cis->funcid) {
		case PCMCIA_FUNCTION_SERIAL:
			if (tuple[1] >= 2 &&
			    tuple[2] == 0
			    /* XXX PCMCIA_TPLFE_TYPE_SERIAL_??? */) {
				cis->funce.serial.uart_type = tuple[3] & 0x1f;
				cis->funce.serial.uart_present = 1;
			}
			break;
		case PCMCIA_FUNCTION_NETWORK:
			if (tuple[1] >= 8 && tuple[2] ==
			    PCMCIA_TPLFE_TYPE_LAN_NID) {
				if (tuple[3] >
				    sizeof(cis->funce.network.netid)) {
					DPRINTF(("%s: unknown network id type"
					    " (len = %d)\n", __func__,
					    tuple[3]));
				} else {
					cis->funce.network.netid_present = 1;
					bcopy(tuple + 4,
					    cis->funce.network.netid, tuple[3]);
				}
			}
		}
		break;
	}
}

/*
 * int cardbus_attach_card(struct cardbus_softc *sc)
 *
 *    This function attaches the card on the slot: turns on power,
 *    reads and analyses tuple, sets configuration index.
 *
 *    This function returns the number of recognised device functions.
 *    If no functions are recognised, return 0.
 */
int
cardbus_attach_card(struct cardbus_softc *sc)
{
	cardbus_chipset_tag_t cc;
	cardbus_function_tag_t cf;
	int cdstatus;
	pcitag_t tag;
	pcireg_t id, class, cis_ptr;
	pcireg_t bhlc;
	u_int8_t *tuple;
	int function, nfunction;
	struct device *csc;
	int no_work_funcs = 0;
	cardbus_devfunc_t ct;
	pci_chipset_tag_t pc = sc->sc_pc;
	int i;

	cc = sc->sc_cc;
	cf = sc->sc_cf;

	DPRINTF(("cardbus_attach_card: cb%d start\n", sc->sc_dev.dv_unit));

	/* inspect initial voltage */
	if (0 == (cdstatus = (cf->cardbus_ctrl)(cc, CARDBUS_CD))) {
		DPRINTF(("cardbusattach: no CardBus card on cb%d\n",
		    sc->sc_dev.dv_unit));
		return (0);
	}

	/* XXX use fake function 8 to keep power on during whole configuration */
	enable_function(sc, cdstatus, 8);

	function = 0;

	tag = pci_make_tag(pc, sc->sc_bus, sc->sc_device, function);

	/* Wait until power comes up.  Maximum 500 ms. */
	for (i = 0; i < 5; ++i) {
		id = pci_conf_read(pc, tag, PCI_ID_REG);
		if (id != 0xffffffff && id != 0)
			break;
		if (cold) {	/* before kernel thread invoked */
			delay(100*1000);
		} else {	/* thread context */
			if (tsleep((void *)sc, PCATCH, "cardbus",
			    hz/10) != EWOULDBLOCK) {
				break;
			}
		}
	}
	if (i == 5)
		return (0);

	bhlc = pci_conf_read(pc, tag, PCI_BHLC_REG);
	DPRINTF(("%s bhlc 0x%08x -> ", sc->sc_dev.dv_xname, bhlc));
	nfunction = PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1;

	tuple = malloc(2048, M_TEMP, M_NOWAIT);
	if (tuple == NULL)
		panic("no room for cardbus tuples");

	for (function = 0; function < nfunction; function++) {
		struct cardbus_attach_args ca;

		tag = pci_make_tag(pc, sc->sc_bus, sc->sc_device,
		    function);

		id = pci_conf_read(pc, tag, PCI_ID_REG);
		class = pci_conf_read(pc, tag, PCI_CLASS_REG);
		cis_ptr = pci_conf_read(pc, tag, CARDBUS_CIS_REG);

		/* Invalid vendor ID value? */
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
			continue;

		DPRINTF(("cardbus_attach_card: Vendor 0x%x, Product 0x%x, "
		    "CIS 0x%x\n", PCI_VENDOR(id), PCI_PRODUCT(id),
		    cis_ptr));

		enable_function(sc, cdstatus, function);

		/* clean up every BAR */
		pci_conf_write(pc, tag, CARDBUS_BASE0_REG, 0);
		pci_conf_write(pc, tag, CARDBUS_BASE1_REG, 0);
		pci_conf_write(pc, tag, CARDBUS_BASE2_REG, 0);
		pci_conf_write(pc, tag, CARDBUS_BASE3_REG, 0);
		pci_conf_write(pc, tag, CARDBUS_BASE4_REG, 0);
		pci_conf_write(pc, tag, CARDBUS_BASE5_REG, 0);
		pci_conf_write(pc, tag, CARDBUS_ROM_REG, 0);

		/* set initial latency and cacheline size */
		bhlc = pci_conf_read(pc, tag, PCI_BHLC_REG);
		DPRINTF(("%s func%d bhlc 0x%08x -> ", sc->sc_dev.dv_xname,
		    function, bhlc));
		bhlc &= ~((PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT) |
		    (PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT));
		bhlc |= ((sc->sc_cacheline & PCI_CACHELINE_MASK) <<
		    PCI_CACHELINE_SHIFT);
		bhlc |= ((sc->sc_lattimer & PCI_LATTIMER_MASK) <<
		    PCI_LATTIMER_SHIFT);

		pci_conf_write(pc, tag, PCI_BHLC_REG, bhlc);
		bhlc = pci_conf_read(pc, tag, PCI_BHLC_REG);
		DPRINTF(("0x%08x\n", bhlc));

		if (PCI_LATTIMER(bhlc) < 0x10) {
			bhlc &= ~(PCI_LATTIMER_MASK <<
			    PCI_LATTIMER_SHIFT);
			bhlc |= (0x10 << PCI_LATTIMER_SHIFT);
			pci_conf_write(pc, tag, PCI_BHLC_REG,
			    bhlc);
		}

		/*
		 * We need to allocate the ct here, since we might
		 * need it when reading the CIS
		 */
		if ((ct =
		    (cardbus_devfunc_t)malloc(sizeof(struct cardbus_devfunc),
		    M_DEVBUF, M_NOWAIT)) == NULL)
			panic("no room for cardbus_tag");

		ct->ct_cc = sc->sc_cc;
		ct->ct_cf = sc->sc_cf;
		ct->ct_bus = sc->sc_bus;
		ct->ct_dev = sc->sc_device;
		ct->ct_func = function;
		ct->ct_sc = sc;
		sc->sc_funcs[function] = ct;

		memset(&ca, 0, sizeof(ca));

		ca.ca_unit = sc->sc_dev.dv_unit;
		ca.ca_ct = ct;

		ca.ca_iot = sc->sc_iot;
		ca.ca_memt = sc->sc_memt;
		ca.ca_dmat = sc->sc_dmat;
		ca.ca_rbus_iot = sc->sc_rbus_iot;
		ca.ca_rbus_memt = sc->sc_rbus_memt;
		ca.ca_tag = tag;
		ca.ca_bus = sc->sc_bus;
		ca.ca_device = sc->sc_device;
		ca.ca_function = function;
		ca.ca_id = id;
		ca.ca_class = class;
		ca.ca_pc = sc->sc_pc;

		ca.ca_intrline = sc->sc_intrline;

		if (cis_ptr != 0) {
			if (cardbus_read_tuples(&ca, cis_ptr, tuple, 2048)) {
				printf("cardbus_attach_card: failed to "
				    "read CIS\n");
			} else {
#ifdef CARDBUS_DEBUG
				decode_tuples(tuple, 2048, print_tuple, NULL);
#endif
				decode_tuples(tuple, 2048, parse_tuple,
				    &ca.ca_cis);
			}
		}

		if ((csc = config_found_sm((void *)sc, &ca, cardbusprint,
		    cardbussubmatch)) == NULL) {
			/* do not match */
			disable_function(sc, function);
			sc->sc_funcs[function] = NULL;
			free(ct, M_DEVBUF, sizeof(struct cardbus_devfunc));
		} else {
			/* found */
			ct->ct_device = csc;
			++no_work_funcs;
		}
	}
	/*
	 * XXX power down pseudo function 8 (this will power down the card
	 * if no functions were attached).
	 */
	disable_function(sc, 8);
	free(tuple, M_TEMP, 2048);

	return (no_work_funcs);
}

STATIC int
cardbussubmatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct cardbus_attach_args *ca = aux;

	if (cf->cardbuscf_dev != CARDBUS_UNK_DEV &&
		cf->cardbuscf_dev != ca->ca_unit) {
		return (0);
	}
	if (cf->cardbuscf_function != CARDBUS_UNK_FUNCTION &&
	    cf->cardbuscf_function != ca->ca_function) {
		return (0);
	}

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

STATIC int
cardbusprint(void *aux, const char *pnp)
{
	struct cardbus_attach_args *ca = aux;
	char devinfo[256];

	if (pnp) {
		pci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo,
		    sizeof(devinfo));
		printf("%s at %s", devinfo, pnp);
	}
	printf(" dev %d function %d", ca->ca_device, ca->ca_function);
	if (!pnp) {
		pci_devinfo(ca->ca_id, ca->ca_class, 0, devinfo,
		    sizeof(devinfo));
		printf(" %s", devinfo);
	}

	return (UNCONF);
}

/*
 * void cardbus_detach_card(struct cardbus_softc *sc)
 *
 *    This function detaches the card on the slot: detach device data
 *    structure and turns off the power.
 *
 *    This function must not be called under interrupt context.
 */
void
cardbus_detach_card(struct cardbus_softc *sc)
{
	struct cardbus_devfunc *ct;
	int f;

	for (f = 0; f < 8; f++) {
		ct = sc->sc_funcs[f];
		if (ct == NULL)
			continue;

		DPRINTF(("%s: detaching %s\n", sc->sc_dev.dv_xname,
		    ct->ct_device->dv_xname));

		if (config_detach(ct->ct_device, 0) != 0) {
			printf("%s: cannot detach dev %s, function %d\n",
			    sc->sc_dev.dv_xname, ct->ct_device->dv_xname,
			    ct->ct_func);
		} else {
			sc->sc_poweron_func &= ~(1 << ct->ct_func);
			sc->sc_funcs[ct->ct_func] = NULL;
			free(ct, M_DEVBUF, sizeof(struct cardbus_devfunc));
		}
	}

	sc->sc_poweron_func = 0;
	sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
}

/*
 * void *cardbus_intr_establish(cc, cf, irq, level, func, arg, name)
 *   Interrupt handler of pccard.
 *  args:
 *   cardbus_chipset_tag_t *cc
 *   int irq:
 */
void *
cardbus_intr_establish(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
    cardbus_intr_handle_t irq, int level, int (*func)(void *), void *arg,
    const char *name)
{
	DPRINTF(("- cardbus_intr_establish: irq %d\n", irq));

	return (*cf->cardbus_intr_establish)(cc, irq, level, func, arg, name);
}

/*
 * void cardbus_intr_disestablish(cc, cf, handler)
 *   Interrupt handler of pccard.
 *  args:
 *   cardbus_chipset_tag_t *cc
 */
void
cardbus_intr_disestablish(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
    void *handler)
{
	DPRINTF(("- pccard_intr_disestablish\n"));

	(*cf->cardbus_intr_disestablish)(cc, handler);
}

/* XXX this should be merged with cardbus_function_{enable,disable},
   but we don't have a ct when these functions are called */

STATIC void
enable_function(struct cardbus_softc *sc, int cdstatus, int function)
{
	if (sc->sc_poweron_func == 0) {
		/* switch to 3V and/or wait for power to stabilize */
		if (cdstatus & CARDBUS_3V_CARD) {
			sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_3V);
		} else {
			/* No cards other than 3.3V cards. */
			return;
		}
		(sc->sc_cf->cardbus_ctrl)(sc->sc_cc, CARDBUS_RESET);
	}
	sc->sc_poweron_func |= (1 << function);
}

STATIC void
disable_function(struct cardbus_softc *sc, int function)
{
	sc->sc_poweron_func &= ~(1 << function);
	if (sc->sc_poweron_func == 0) {
		/* power-off because no functions are enabled */
		sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V);
	}
}

/*
 * int cardbus_function_enable(struct cardbus_softc *sc, int func)
 *
 *   This function enables a function on a card.  When no power is
 *  applied on the card, power will be applied on it.
 */
int
cardbus_function_enable(struct cardbus_softc *sc, int func)
{
	pci_chipset_tag_t pc = sc->sc_pc;
	pcireg_t command;
	pcitag_t tag;

	DPRINTF(("entering cardbus_function_enable...  "));

	/* entering critical area */

	/* XXX: sc_vold should be used */
	enable_function(sc, CARDBUS_3V_CARD, func);

	/* exiting critical area */

	tag = pci_make_tag(pc, sc->sc_bus, sc->sc_device, func);

	command = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	command |= (PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_IO_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE); /* XXX: good guess needed */

	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, command);

	DPRINTF(("%x\n", sc->sc_poweron_func));

	return (0);
}

/*
 * int cardbus_function_disable(struct cardbus_softc *, int func)
 *
 *   This function disable a function on a card.  When no functions are
 *  enabled, it turns off the power.
 */
int
cardbus_function_disable(struct cardbus_softc *sc, int func)
{
	DPRINTF(("entering cardbus_function_disable...  "));

	disable_function(sc, func);

	return (0);
}

int
cardbus_matchbyid(struct cardbus_attach_args *ca,
    const struct pci_matchid *ids, int nent)
{
	const struct pci_matchid *pm;
	int i;

	for (i = 0, pm = ids; i < nent; i++, pm++)
		if (PCI_VENDOR(ca->ca_id) == pm->pm_vid &&
		    PCI_PRODUCT(ca->ca_id) == pm->pm_pid)
			return (1);
	return (0);
}

/*
 * below this line, there are some functions for decoding tuples.
 * They should go out from this file.
 */

STATIC u_int8_t *
decode_tuple(u_int8_t *, u_int8_t *, tuple_decode_func, void *);

STATIC int
decode_tuples(u_int8_t *tuple, int buflen, tuple_decode_func func, void *data)
{
	u_int8_t *tp = tuple;

	if (PCMCIA_CISTPL_LINKTARGET != *tuple) {
		DPRINTF(("WRONG TUPLE: 0x%x\n", *tuple));
		return (0);
	}

	while ((tp = decode_tuple(tp, tuple + buflen, func, data)) != NULL)
		;

	return (1);
}

STATIC u_int8_t *
decode_tuple(u_int8_t *tuple, u_int8_t *end, tuple_decode_func func,
    void *data)
{
	u_int8_t type;
	u_int8_t len;

	type = tuple[0];
	switch (type) {
	case PCMCIA_CISTPL_NULL:
	case PCMCIA_CISTPL_END:
		len = 1;
		break;
	default:
		if (tuple + 2 > end)
			return (NULL);
		len = tuple[1] + 2;
		break;
	}

	if (tuple + len > end)
		return (NULL);

	(*func)(tuple, len, data);

	if (PCMCIA_CISTPL_END == type || tuple + len == end)
		return (NULL);

	return (tuple + len);
}

#ifdef CARDBUS_DEBUG
static char *tuple_name(int type);

static char *
tuple_name(int type)
{
	static char *tuple_name_s [] = {
	    "TPL_NULL", "TPL_DEVICE", "Reserved", "Reserved",	  /* 0-3 */
	    "CONFIG_CB", "CFTABLE_ENTRY_CB", "Reserved", "BAR",	  /* 4-7 */
	    "Reserved", "Reserved", "Reserved", "Reserved",	  /* 8-B */
	    "Reserved", "Reserved", "Reserved", "Reserved",	  /* C-F */
	    "CHECKSUM", "LONGLINK_A", "LONGLINK_C", "LINKTARGET", /* 10-13 */
	    "NO_LINK", "VERS_1", "ALTSTR", "DEVICE_A",		  /* 14-17 */
	    "JEDEC_C", "JEDEC_A", "CONFIG", "CFTABLE_ENTRY",	  /* 18-1B */
	    "DEVICE_OC", "DEVICE_OA", "DEVICE_GEO",		  /* 1C-1E */
	    "DEVICE_GEO_A", "MANFID", "FUNCID", "FUNCE", "SWIL",  /* 1F-23 */
	    "Reserved", "Reserved", "Reserved", "Reserved",	  /* 24-27 */
	    "Reserved", "Reserved", "Reserved", "Reserved",	  /* 28-2B */
	    "Reserved", "Reserved", "Reserved", "Reserved",	  /* 2C-2F */
	    "Reserved", "Reserved", "Reserved", "Reserved",	  /* 30-33 */
	    "Reserved", "Reserved", "Reserved", "Reserved",	  /* 34-37 */
	    "Reserved", "Reserved", "Reserved", "Reserved",	  /* 38-3B */
	    "Reserved", "Reserved", "Reserved", "Reserved",	  /* 3C-3F */
	    "VERS_2", "FORMAT", "GEOMETRY", "BYTEORDER",	  /* 40-43 */
	    "DATE", "BATTERY", "ORG", "FORMAT_A"		  /* 44-47 */
	};

	if (type > 0 && type < nitems(tuple_name_s))
		return (tuple_name_s[type]);
	else if (0xff == type)
		return ("END");
	else
		return ("Reserved");
}

static void
print_tuple(u_int8_t *tuple, int len, void *data)
{
	int i;

	printf("tuple: %s len %d\n", tuple_name(tuple[0]), len);

	for (i = 0; i < len; ++i) {
		if (i % 16 == 0)
			printf("  0x%02x:", i);
		printf(" %x",tuple[i]);
		if (i % 16 == 15)
			printf("\n");
	}
	if (i % 16 != 0)
		printf("\n");
}
#endif
@


1.50
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.49 2014/12/18 10:51:35 mpi Exp $	*/
d240 1
a240 1
				free(p, M_DEVBUF, 0);
d535 1
a535 1
			free(ct, M_DEVBUF, 0);
d547 1
a547 1
	free(tuple, M_TEMP, 0);
d620 1
a620 1
			free(ct, M_DEVBUF, 0);
@


1.49
log
@Merge from NetBSD r1.54 from Matthias Drochner:
--
kick out the error-prone handcrafted single-linked list of cardbus
functions; replace by a simple *array[8]
--

In other words, prevent a use after free when removing a cardbus
function.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.48 2014/09/14 14:17:24 jsg Exp $	*/
a35 1
#include <sys/syslog.h>
@


1.48
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.47 2014/07/12 18:48:17 tedu Exp $	*/
a132 2
	sc->sc_funcs = NULL;

a378 1
	struct cardbus_devfunc **previous_next = &(sc->sc_funcs);
d496 1
a496 2
		ct->ct_next = NULL;
		*previous_next = ct;
d535 1
a536 1
			*previous_next = NULL;
a538 1
			previous_next = &(ct->ct_next);
d603 2
a604 1
	struct cardbus_devfunc *ct, *ct_next, **prev_next;
d606 4
a609 5
	prev_next = &(sc->sc_funcs->ct_next);

	for (ct = sc->sc_funcs; ct != NULL; ct = ct_next) {
		struct device *fndev = ct->ct_device;
		ct_next = ct->ct_next;
d612 1
a612 2
		    fndev->dv_xname));
		/* call device detach function */
d614 1
a614 1
		if (config_detach(fndev, 0) != 0) {
d616 2
a617 2
			    sc->sc_dev.dv_xname, fndev->dv_xname, ct->ct_func);
			prev_next = &(ct->ct_next);
d620 1
a620 1
			*prev_next = ct->ct_next;
@


1.47
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.46 2013/05/30 16:15:01 deraadt Exp $	*/
a36 1
#include <sys/proc.h>
@


1.46
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.45 2010/08/25 21:37:59 kettenis Exp $	*/
d244 1
a244 1
				free(p, M_DEVBUF);
d540 1
a540 1
			free(ct, M_DEVBUF);
d554 1
a554 1
	free(tuple, M_TEMP);
d628 1
a628 1
			free(ct, M_DEVBUF);
@


1.45
log
@Make CardBus ral(4) suspend and resume properly on machines that keep the
CardBus bridge powered up during suspend.  Step zero on the long road
towards fully suspending CardBus on all machines.

ok deraadt@@, damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.44 2010/03/27 21:40:13 jsg Exp $	*/
d86 1
a86 2
	sizeof(struct cardbus_softc), cardbusmatch, cardbusattach,
	NULL, config_activate_children
@


1.44
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.43 2010/03/27 20:04:03 jsg Exp $	*/
d86 2
a87 1
	sizeof(struct cardbus_softc), cardbusmatch, cardbusattach
@


1.43
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.42 2010/03/22 22:28:27 jsg Exp $	*/
d129 1
d144 1
a144 2
	cardbus_chipset_tag_t cc = ca->ca_ct->ct_cc;
	cardbus_function_tag_t cf = ca->ca_ct->ct_cf;
d167 1
a167 1
			u_int32_t e = (cf->cardbus_conf_read)(cc, tag, i);
d199 1
a199 1
		cardbus_conf_write(cc, cf, tag, reg, 0);
d216 2
a217 2
			exrom = cardbus_conf_read(cc, cf, tag, reg);
			cardbus_conf_write(cc, cf, tag, reg, exrom | 1);
d219 1
a219 1
			command = cardbus_conf_read(cc, cf, tag,
d221 1
a221 1
			cardbus_conf_write(cc, cf, tag,
d246 2
a247 2
			exrom = cardbus_conf_read(cc, cf, tag, reg);
			cardbus_conf_write(cc, cf, tag, reg, exrom & ~1);
d250 1
a250 1
			command = cardbus_conf_read(cc, cf, tag,
d252 1
a252 1
			cardbus_conf_write(cc, cf, tag,
d260 1
a260 1
		command = cardbus_conf_read(cc, cf, tag,
d262 1
a262 1
		cardbus_conf_write(cc, cf, tag, PCI_COMMAND_STATUS_REG,
d264 1
a264 1
		cardbus_conf_write(cc, cf, tag, reg, 0);
d386 1
d406 1
a406 1
	tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);
d410 1
a410 1
		id = cardbus_conf_read(cc, cf, tag, PCI_ID_REG);
d425 1
a425 1
	bhlc = cardbus_conf_read(cc, cf, tag, PCI_BHLC_REG);
d436 1
a436 1
		tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device,
d439 3
a441 3
		id = cardbus_conf_read(cc, cf, tag, PCI_ID_REG);
		class = cardbus_conf_read(cc, cf, tag, PCI_CLASS_REG);
		cis_ptr = cardbus_conf_read(cc, cf, tag, CARDBUS_CIS_REG);
d454 7
a460 7
		cardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, 0);
		cardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, 0);
		cardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, 0);
		cardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, 0);
		cardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, 0);
		cardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, 0);
		cardbus_conf_write(cc, cf, tag, CARDBUS_ROM_REG, 0);
d463 1
a463 1
		bhlc = cardbus_conf_read(cc, cf, tag, PCI_BHLC_REG);
d473 2
a474 2
		cardbus_conf_write(cc, cf, tag, PCI_BHLC_REG, bhlc);
		bhlc = cardbus_conf_read(cc, cf, tag, PCI_BHLC_REG);
d481 1
a481 1
			cardbus_conf_write(cc, cf, tag, PCI_BHLC_REG,
d519 1
d706 1
a706 2
	cardbus_chipset_tag_t cc = sc->sc_cc;
	cardbus_function_tag_t cf = sc->sc_cf;
d719 1
a719 1
	tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);
d721 1
a721 1
	command = cardbus_conf_read(cc, cf, tag, PCI_COMMAND_STATUS_REG);
d725 1
a725 3
	cardbus_conf_write(cc, cf, tag, PCI_COMMAND_STATUS_REG, command);

	cardbus_free_tag(cc, cf, tag);
a743 39

	return (0);
}

/*
 * int cardbus_get_capability(cardbus_chipset_tag_t cc,
 *	cardbus_function_tag_t cf, pcitag_t tag, int capid, int *offset,
 *	pcireg_t *value)
 *
 *	Find the specified PCI capability.
 */
int
cardbus_get_capability(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
    pcitag_t tag, int capid, int *offset, pcireg_t *value)
{
	pcireg_t reg;
	unsigned int ofs;

	reg = cardbus_conf_read(cc, cf, tag, PCI_COMMAND_STATUS_REG);
	if (!(reg & PCI_STATUS_CAPLIST_SUPPORT))
		return (0);

	ofs = PCI_CAPLIST_PTR(cardbus_conf_read(cc, cf, tag,
	    PCI_CAPLISTPTR_REG));
	while (ofs != 0) {
#ifdef DIAGNOSTIC
		if ((ofs & 3) || (ofs < 0x40))
			panic("cardbus_get_capability 0x%x", ofs);
#endif
		reg = cardbus_conf_read(cc, cf, tag, ofs);
		if (PCI_CAPLIST_CAP(reg) == capid) {
			if (offset)
				*offset = ofs;
			if (value)
				*value = reg;
			return (1);
		}
		ofs = PCI_CAPLIST_NEXT(reg);
	}
@


1.42
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.41 2010/01/13 09:10:33 jsg Exp $	*/
d143 1
a143 1
	pci_chipset_tag_t cc = ca->ca_ct->ct_cc;
d374 1
a374 1
	pci_chipset_tag_t cc;
d638 1
a638 1
 *   pci_chipset_tag_t *cc
d642 1
a642 1
cardbus_intr_establish(pci_chipset_tag_t cc, cardbus_function_tag_t cf,
d655 1
a655 1
 *   pci_chipset_tag_t *cc
d658 1
a658 1
cardbus_intr_disestablish(pci_chipset_tag_t cc, cardbus_function_tag_t cf,
d704 1
a704 1
	pci_chipset_tag_t cc = sc->sc_cc;
d750 1
a750 1
 * int cardbus_get_capability(pci_chipset_tag_t cc,
d757 1
a757 1
cardbus_get_capability(pci_chipset_tag_t cc, cardbus_function_tag_t cf,
@


1.41
log
@As per NetBSD move HAYAKAWA Koichi's licenses to two clause.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.40 2009/12/15 20:26:21 jasper Exp $	*/
d79 1
a79 1
    cardbusreg_t, u_int8_t *, size_t);
d139 1
a139 1
cardbus_read_tuples(struct cardbus_attach_args *ca, cardbusreg_t cis_ptr,
d143 1
a143 1
	cardbus_chipset_tag_t cc = ca->ca_ct->ct_cc;
d145 2
a146 2
	cardbustag_t tag = ca->ca_tag;
	cardbusreg_t command;
d201 1
a201 1
		    CARDBUS_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
d209 1
a209 1
			cardbusreg_t exrom;
d220 1
a220 1
			    CARDBUS_COMMAND_STATUS_REG);
d222 2
a223 2
			    CARDBUS_COMMAND_STATUS_REG,
			    command | CARDBUS_COMMAND_MEM_ENABLE);
d251 1
a251 1
			    CARDBUS_COMMAND_STATUS_REG);
d253 2
a254 2
			    CARDBUS_COMMAND_STATUS_REG,
    			    command | CARDBUS_COMMAND_MEM_ENABLE);
d261 3
a263 3
		    CARDBUS_COMMAND_STATUS_REG);
		cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG,
		    command & ~CARDBUS_COMMAND_MEM_ENABLE);
d374 1
a374 1
	cardbus_chipset_tag_t cc;
d377 3
a379 3
	cardbustag_t tag;
	cardbusreg_t id, class, cis_ptr;
	cardbusreg_t bhlc;
d409 1
a409 1
		id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);
d424 1
a424 1
	bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);
d426 1
a426 1
	nfunction = CARDBUS_HDRTYPE_MULTIFN(bhlc) ? 8 : 1;
d438 2
a439 2
		id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);
		class = cardbus_conf_read(cc, cf, tag, CARDBUS_CLASS_REG);
d443 1
a443 1
		if (CARDBUS_VENDOR(id) == PCI_VENDOR_INVALID)
d447 1
a447 1
		    "CIS 0x%x\n", CARDBUS_VENDOR(id), CARDBUS_PRODUCT(id),
d462 1
a462 1
		bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);
d465 6
a470 6
		bhlc &= ~((CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT) |
		    (CARDBUS_CACHELINE_MASK << CARDBUS_CACHELINE_SHIFT));
		bhlc |= ((sc->sc_cacheline & CARDBUS_CACHELINE_MASK) <<
		    CARDBUS_CACHELINE_SHIFT);
		bhlc |= ((sc->sc_lattimer & CARDBUS_LATTIMER_MASK) <<
		    CARDBUS_LATTIMER_SHIFT);
d472 2
a473 2
		cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);
		bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);
d476 5
a480 5
		if (CARDBUS_LATTIMER(bhlc) < 0x10) {
			bhlc &= ~(CARDBUS_LATTIMER_MASK <<
			    CARDBUS_LATTIMER_SHIFT);
			bhlc |= (0x10 << CARDBUS_LATTIMER_SHIFT);
			cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG,
d638 1
a638 1
 *   cardbus_chipset_tag_t *cc
d642 1
a642 1
cardbus_intr_establish(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
d655 1
a655 1
 *   cardbus_chipset_tag_t *cc
d658 1
a658 1
cardbus_intr_disestablish(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
d704 1
a704 1
	cardbus_chipset_tag_t cc = sc->sc_cc;
d706 2
a707 2
	cardbusreg_t command;
	cardbustag_t tag;
d720 3
a722 3
	command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);
	command |= (CARDBUS_COMMAND_MEM_ENABLE | CARDBUS_COMMAND_IO_ENABLE |
	    CARDBUS_COMMAND_MASTER_ENABLE); /* XXX: good guess needed */
d724 1
a724 1
	cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, command);
d750 3
a752 3
 * int cardbus_get_capability(cardbus_chipset_tag_t cc,
 *	cardbus_function_tag_t cf, cardbustag_t tag, int capid, int *offset,
 *	cardbusreg_t *value)
d757 2
a758 2
cardbus_get_capability(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
    cardbustag_t tag, int capid, int *offset, cardbusreg_t *value)
d760 1
a760 1
	cardbusreg_t reg;
d790 1
a790 1
    const struct cardbus_matchid *ids, int nent)
d792 1
a792 1
	const struct cardbus_matchid *cm;
d795 3
a797 3
	for (i = 0, cm = ids; i < nent; i++, cm++)
		if (CARDBUS_VENDOR(ca->ca_id) == cm->cm_vid &&
		    CARDBUS_PRODUCT(ca->ca_id) == cm->cm_pid)
@


1.40
log
@- instead of rolling a macro that is functional equivalent to nitems(),
just use nitems(). (this leaves NENTS() alone for now)

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.39 2009/03/29 21:53:52 sthen Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by HAYAKAWA Koichi.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.39
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.38 2008/02/25 20:30:56 brad Exp $	*/
a887 1
#define NAME_LEN(x) (sizeof(x)/sizeof(x[0]))
d889 1
a889 1
	if (type > 0 && type < NAME_LEN(tuple_name_s))
@


1.38
log
@Stop cardbusprint() from printing the CIS data so that CardBus dmesg
entries look more like a PCI device as they're just another variant
of PCI and this looks much nicer.

ok deraadt@@ kettenis@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.37 2007/09/19 21:54:22 martin Exp $	*/
d208 1
a208 1
			printf("%s: failed to map memory\n",
@


1.37
log
@fix CARDBUS_DEBUG

noted by Markus Hennecke
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.36 2007/09/19 04:25:52 miod Exp $	*/
a584 1
	int i;
a588 12
		for (i = 0; i < 4; i++) {
			if (ca->ca_cis.cis1_info[i] == NULL)
				break;
			if (i)
				printf(", ");
			printf("%s", ca->ca_cis.cis1_info[i]);
		}
		if (i)
			printf(" ");
		if (ca->ca_cis.manufacturer)
			printf("(manufacturer 0x%x, product 0x%x) ",
			    ca->ca_cis.manufacturer, ca->ca_cis.product);
a591 1

d593 1
a593 1
		pci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo,
d595 1
a595 5
		for (i = 0; i < 3 && ca->ca_cis.cis1_info[i]; i++)
			printf("%s%s", i ? ", " : " \"",
			    ca->ca_cis.cis1_info[i]);
		if (ca->ca_cis.cis1_info[0])
			printf("\"");
@


1.36
log
@Add a missing prototype in the non-static case.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.35 2007/09/17 20:29:47 miod Exp $	*/
d80 1
a80 1
STATIC void print_tuple(u_int8_t *, int, void *);
@


1.35
log
@Un-staticize if option DDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.34 2006/10/12 16:35:51 grange Exp $	*/
d61 2
a63 2
#else
#define STATIC
d78 1
@


1.34
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.33 2006/06/21 11:27:03 fkr Exp $	*/
d56 1
a56 1
#if defined CARDBUS_DEBUG
d60 1
d62 3
d72 2
a73 2
static int cardbussubmatch(struct device *, void *, void *);
static int cardbusprint(void *, const char *);
d77 1
a77 1
static int decode_tuples(u_int8_t *, int, tuple_decode_func, void *);
d79 1
a79 1
static void print_tuple(u_int8_t *, int, void *);
d82 1
a82 1
static int cardbus_read_tuples(struct cardbus_attach_args *,
d85 2
a86 2
static void enable_function(struct cardbus_softc *, int, int);
static void disable_function(struct cardbus_softc *, int);
d142 1
a142 1
static int
d283 1
a283 1
static void
d561 1
a561 1
static int
d579 1
a579 1
static int
d691 1
a691 1
static void
d707 1
a707 1
static void
d829 1
a829 1
static u_int8_t *
d832 1
a832 1
static int
d848 1
a848 1
static u_int8_t *
@


1.33
log
@removal of '#ifdef rbus ... #else ...' directives, we use rbus in all
cases anyways, so we might as well remove code (the !rbus case) thats been
dead throughout the last years and just use the rbus code without ifdefs.

brad, miod "I am all for this diff"
ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.32 2005/12/07 12:42:16 fgsch Exp $	*/
d653 1
a653 1
 * void *cardbus_intr_establish(cc, cf, irq, level, func, arg)
d661 2
a662 1
    cardbus_intr_handle_t irq, int level, int (*func)(void *), void *arg)
d666 1
a666 1
	return (*cf->cardbus_intr_establish)(cc, irq, level, func, arg);
@


1.32
log
@o do not break after first iteration but when we found a match.
o try to read the whole cis (but not more than len bytes) instead of the
  first 256 bytes.

first one spotted by lint.  mickey@@, krw@@ and deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.31 2005/09/26 22:43:18 deraadt Exp $	*/
a129 2

#if rbus
a131 1
#endif
a509 2

#if rbus
a511 2
#endif

@


1.31
log
@minor knf
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.30 2005/09/13 18:53:01 fgsch Exp $	*/
d238 1
a238 1
					    tuples, 256);
d240 1
a241 1
				break;
@


1.30
log
@some missing cleanup from the previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.29 2005/09/13 18:44:38 fgsch Exp $	*/
d389 1
d403 2
a404 3
	enable_function(sc, cdstatus, 8); /* XXX use fake function 8 to
					     keep power on during whole
					     configuration */
d410 10
a419 8
	/*
	 * Wait until power comes up.  Maxmum 500 ms.
	 */
	{
		int i;
		for (i = 0; i < 5; ++i) {
			id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);
			if (id != 0xffffffff && id != 0)
a420 7
			if (cold) {	/* before kernel thread invoked */
				delay(100*1000);
			} else {	/* thread context */
				if (tsleep((void *)sc, PCATCH, "cardbus",
				    hz/10) != EWOULDBLOCK) {
					break;
				}
a422 2
		if (i == 5)
			return (0);
d424 2
@


1.29
log
@knf; no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.28 2005/09/13 15:21:24 mickey Exp $	*/
a284 3
#ifdef CARDBUS_DEBUG
	static const char func[] = "parse_tuple";
#endif
d294 1
a294 1
			    func, tuple[1]));
d317 2
a318 2
			DPRINTF(("%s: BAR with short length (%d)\n", func,
			    tuple[1]));
d323 2
a324 1
			DPRINTF(("%s: invalid ASI in BAR tuple\n", func));
d352 2
a353 1
					    " (len = %d)\n", func, tuple[3]));
@


1.28
log
@make compile; good
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.27 2005/09/12 18:47:50 miod Exp $	*/
a35 1
#include <sys/types.h>
a65 1
int cardbus_attach_card(struct cardbus_softc *);
d71 1
a71 1
typedef void (*tuple_decode_func)(u_int8_t*, int, void *);
d75 1
a75 1
static void print_tuple(u_int8_t*, int, void *);
@


1.27
log
@Do not leak memory if cardbus_read_exrom() fails; ok fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.26 2005/09/12 17:16:48 fgsch Exp $	*/
d926 1
a926 1
print_tuple(u_int8_t *tuple, int len, void data)
@


1.26
log
@better cis string parsing. from drochner@@netbsd.org; tested by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.25 2005/09/09 21:27:45 fgsch Exp $	*/
d246 1
a250 1
		out:
@


1.25
log
@knf. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.24 2005/09/05 20:25:27 fgsch Exp $ */
d311 2
d316 2
a317 3
			if (*p == '\xff')
				break;
			p++;
@


1.24
log
@correct manfid length check.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.23 2005/08/22 18:00:37 fgsch Exp $ */
d81 1
a81 1
				    cardbusreg_t, u_int8_t *, size_t);
a90 1
#ifndef __NetBSD_Version__
a93 1
#endif
d95 5
d101 5
a105 14
STATIC int
cardbusmatch(parent, match, aux)
     struct device *parent;
     void *match;
     void *aux;
{
  struct cfdata *cf = match;
  struct cbslot_attach_args *cba = aux;

  if (strcmp(cba->cba_busname, cf->cf_driver->cd_name)) {
    DPRINTF(("cardbusmatch: busname differs %s <=> %s\n",
	     cba->cba_busname, cf->cf_driver->cd_name));
    return 0;
  }
d107 1
a107 1
  return 1;
a109 2


d111 21
a131 23
cardbusattach(parent, self, aux)
     struct device *parent;
     struct device *self;
     void *aux;
{
  struct cardbus_softc *sc = (void *)self;
  struct cbslot_attach_args *cba = aux;
  int cdstatus;

  sc->sc_bus = cba->cba_bus;
  sc->sc_device = 0;
  sc->sc_intrline = cba->cba_intrline;
  sc->sc_cacheline = cba->cba_cacheline;
  sc->sc_lattimer = cba->cba_lattimer;

  printf(": bus %d device %d", sc->sc_bus, sc->sc_device);
  printf(" cacheline 0x%x, lattimer 0x%x\n", sc->sc_cacheline,sc->sc_lattimer);

  sc->sc_iot = cba->cba_iot;	/* CardBus I/O space tag */
  sc->sc_memt = cba->cba_memt;	/* CardBus MEM space tag */
  sc->sc_dmat = cba->cba_dmat;	/* DMA tag */
  sc->sc_cc = cba->cba_cc;
  sc->sc_cf = cba->cba_cf;
d134 2
a135 2
  sc->sc_rbus_iot = cba->cba_rbus_iot;
  sc->sc_rbus_memt = cba->cba_rbus_memt;
d138 1
a138 1
  sc->sc_funcs = NULL;
d140 1
a140 1
  cdstatus = 0;
d144 96
a239 97
cardbus_read_tuples(ca, cis_ptr, tuples, len)
     struct cardbus_attach_args *ca;
     cardbusreg_t cis_ptr;
     u_int8_t *tuples;
     size_t len;
{
    struct cardbus_softc *sc = ca->ca_ct->ct_sc;
    cardbus_chipset_tag_t cc = ca->ca_ct->ct_cc;
    cardbus_function_tag_t cf = ca->ca_ct->ct_cf;
    cardbustag_t tag = ca->ca_tag;
    cardbusreg_t command;
    int found = 0;

    int i, j;
    int cardbus_space = cis_ptr & CARDBUS_CIS_ASIMASK;
    bus_space_tag_t bar_tag;
    bus_space_handle_t bar_memh;
    bus_size_t bar_size;
    bus_addr_t bar_addr;
    
    int reg;
      
    memset(tuples, 0, len);

    cis_ptr = cis_ptr & CARDBUS_CIS_ADDRMASK;

    switch(cardbus_space) {
    case CARDBUS_CIS_ASI_TUPLE:
	DPRINTF(("%s: reading CIS data from configuration space\n", 
		 sc->sc_dev.dv_xname));
	for (i = cis_ptr, j = 0; i < 0xff; i += 4) {
	    u_int32_t e = (cf->cardbus_conf_read)(cc, tag, i);
	    tuples[j] = 0xff & e;
	    e >>= 8;
	    tuples[j + 1] = 0xff & e;
	    e >>= 8;
	    tuples[j + 2] = 0xff & e;
	    e >>= 8;
	    tuples[j + 3] = 0xff & e;
	    j += 4;
	}
	found++;
	break;

    case CARDBUS_CIS_ASI_BAR0:
    case CARDBUS_CIS_ASI_BAR1:
    case CARDBUS_CIS_ASI_BAR2:
    case CARDBUS_CIS_ASI_BAR3:
    case CARDBUS_CIS_ASI_BAR4:
    case CARDBUS_CIS_ASI_BAR5:
    case CARDBUS_CIS_ASI_ROM:
	if(cardbus_space == CARDBUS_CIS_ASI_ROM) {
	    reg = CARDBUS_ROM_REG;
	    DPRINTF(("%s: reading CIS data from ROM\n",
		     sc->sc_dev.dv_xname));
	} else {
	    reg = CARDBUS_BASE0_REG + (cardbus_space - 1) * 4;
	    DPRINTF(("%s: reading CIS data from BAR%d\n",
		     sc->sc_dev.dv_xname, cardbus_space - 1));
	}

	/* XXX zero register so mapreg_map doesn't get confused by old
           contents */
	cardbus_conf_write(cc, cf, tag, reg, 0);
	if(Cardbus_mapreg_map(ca->ca_ct, reg,
			      CARDBUS_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT,
			      0, 
			      &bar_tag, &bar_memh, &bar_addr, &bar_size)) {
	    printf("%s: failed to map memory\n", sc->sc_dev.dv_xname);
	    return 1;
	}


	if(cardbus_space == CARDBUS_CIS_ASI_ROM) {
	    cardbusreg_t exrom;
	    int save;
	    struct cardbus_rom_image_head rom_image;
	    struct cardbus_rom_image *p;
		    
	    save = splhigh();
	    /* enable rom address decoder */
	    exrom = cardbus_conf_read(cc, cf, tag, reg);
	    cardbus_conf_write(cc, cf, tag, reg, exrom | 1);
	    
	    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);
	    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, 
			       command | CARDBUS_COMMAND_MEM_ENABLE);

	    if(cardbus_read_exrom(ca->ca_memt, bar_memh, &rom_image))
		goto out;

	    for(p = SIMPLEQ_FIRST(&rom_image);
		p;
		p = SIMPLEQ_NEXT(p, next)) {
		if(p->rom_image == CARDBUS_CIS_ASI_ROM_IMAGE(cis_ptr)) {
		    bus_space_read_region_1(p->romt, p->romh,
					    CARDBUS_CIS_ADDR(cis_ptr),
d241 23
a263 1
		    found++;
d265 8
a273 26
	    }
	    while((p = SIMPLEQ_FIRST(&rom_image)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&rom_image, next);
		free(p, M_DEVBUF);
	    }
	out:
	    exrom = cardbus_conf_read(cc, cf, tag, reg);
	    cardbus_conf_write(cc, cf, tag, reg, exrom & ~1);
	    splx(save);
	} else {
	    command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);
	    cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, 
			       command | CARDBUS_COMMAND_MEM_ENABLE);
	    /* XXX byte order? */
	    bus_space_read_region_1(ca->ca_memt, bar_memh, 
				    cis_ptr, tuples, 256);
	    found++;
	}
	command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);
	cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, 
			   command & ~CARDBUS_COMMAND_MEM_ENABLE);
	cardbus_conf_write(cc, cf, tag, reg, 0);

	Cardbus_mapreg_unmap(ca->ca_ct, reg, bar_tag, bar_memh,
	    bar_size);
	break;
d276 3
a278 2
    default:
	panic("%s: bad CIS space (%d)", sc->sc_dev.dv_xname, cardbus_space);
d280 2
a281 2
    }
    return !found;
d288 1
a288 1
    static const char func[] = "parse_tuple";
d290 44
a333 23
    struct cardbus_cis_info *cis = data;
    int bar_index;
    int i;
    char *p;
    switch(tuple[0]) {
    case PCMCIA_CISTPL_MANFID:
	if(tuple[1] < 4) {
	    DPRINTF(("%s: wrong length manufacturer id (%d)\n", 
		     func, tuple[1]));
	    break;
	}
	cis->manufacturer = tuple[2] | (tuple[3] << 8);
	cis->product = tuple[4] | (tuple[5] << 8);
	break;
    case PCMCIA_CISTPL_VERS_1:
	bcopy(tuple + 2, cis->cis1_info_buf, tuple[1]);
	i = 0;
	p = cis->cis1_info_buf + 2;
	while(i < sizeof(cis->cis1_info) / sizeof(cis->cis1_info[0])) {
	    cis->cis1_info[i++] = p;
	    while(*p != '\0' && *p != '\xff')
		p++;
	    if(*p == '\xff')
a334 20
	    p++;
	}
	break;
    case PCMCIA_CISTPL_BAR:
	if(tuple[1] != 6) {
	    DPRINTF(("%s: BAR with short length (%d)\n", func, tuple[1]));
	    break;
	}
	bar_index = tuple[2] & 7;
	if(bar_index == 0) {
	    DPRINTF(("%s: invalid ASI in BAR tuple\n", func));
	    break;
	}
	bar_index--;
	cis->bar[bar_index].flags = tuple[2];
	cis->bar[bar_index].size = (tuple[4] << 0) |
				    (tuple[5] << 8) |
				    (tuple[6] << 16) |
				    (tuple[7] << 24);
	break;
d336 3
a338 3
	cis->funcid = tuple[2];
	break;
	
d340 22
a361 17
	switch(cis->funcid) {
	case PCMCIA_FUNCTION_SERIAL:
	    if(tuple[1] >= 2 && 
	       tuple[2] == 0 /* XXX PCMCIA_TPLFE_TYPE_SERIAL_??? */) {
		cis->funce.serial.uart_type = tuple[3] & 0x1f;
		cis->funce.serial.uart_present = 1;
	    }
	    break;
	case PCMCIA_FUNCTION_NETWORK:
	    if(tuple[1] >= 8 && tuple[2] == PCMCIA_TPLFE_TYPE_LAN_NID) {
		if(tuple[3] > sizeof(cis->funce.network.netid)) {
		    DPRINTF(("%s: unknown network id type (len = %d)\n", 
			     func, tuple[3]));
		} else {
		    cis->funce.network.netid_present = 1;
		    bcopy(tuple + 4, cis->funce.network.netid, 
			   tuple[3]);
d363 1
a363 1
	    }
a364 2
	break;
    }
d377 1
a377 2
cardbus_attach_card(sc)
     struct cardbus_softc *sc;
d379 141
a519 137
  cardbus_chipset_tag_t cc;
  cardbus_function_tag_t cf;
  int cdstatus;
  cardbustag_t tag;
  cardbusreg_t id, class, cis_ptr;
  cardbusreg_t bhlc;
  u_int8_t *tuple;
  int function, nfunction;
  struct cardbus_devfunc **previous_next = &(sc->sc_funcs);
  struct device *csc;
  int no_work_funcs = 0;
  cardbus_devfunc_t ct;

  cc = sc->sc_cc;
  cf = sc->sc_cf;

  DPRINTF(("cardbus_attach_card: cb%d start\n", sc->sc_dev.dv_unit));

  /* inspect initial voltage */
  if (0 == (cdstatus = (cf->cardbus_ctrl)(cc, CARDBUS_CD))) {
    DPRINTF(("cardbusattach: no CardBus card on cb%d\n", sc->sc_dev.dv_unit));
    return 0;
  }

  enable_function(sc, cdstatus, 8); /* XXX use fake function 8 to
				       keep power on during whole
				       configuration */

  function = 0;

  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);

  /*
   * Wait until power comes up.  Maxmum 500 ms.
   */
  {
    int i;
    for (i = 0; i < 5; ++i) {
      id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);
      if (id != 0xffffffff && id != 0) {
	break;
      }
      if (cold) {		/* before kernel thread invoked */
	delay(100*1000);
      } else {			/* thread context */
	if (tsleep((void *)sc, PCATCH, "cardbus", hz/10) != EWOULDBLOCK) {
	  break;
	}
      }
    }
    if (i == 5) {
      return 0;
    }
  }

  bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);
  DPRINTF(("%s bhlc 0x%08x -> ", sc->sc_dev.dv_xname, bhlc));
  nfunction = CARDBUS_HDRTYPE_MULTIFN(bhlc) ? 8 : 1;

  tuple = malloc(2048, M_TEMP, M_NOWAIT);
  if (tuple == NULL) {
     panic("no room for cardbus tuples");
  }

  for(function = 0; function < nfunction; function++) {
    struct cardbus_attach_args ca;

    tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, function);
  
    id = cardbus_conf_read(cc, cf, tag, CARDBUS_ID_REG);
    class = cardbus_conf_read(cc, cf, tag, CARDBUS_CLASS_REG);
    cis_ptr = cardbus_conf_read(cc, cf, tag, CARDBUS_CIS_REG);
  
    /* Invalid vendor ID value? */
    if (CARDBUS_VENDOR(id) == PCI_VENDOR_INVALID) {
      continue;
    }
      
    DPRINTF(("cardbus_attach_card: Vendor 0x%x, Product 0x%x, CIS 0x%x\n",
	     CARDBUS_VENDOR(id), CARDBUS_PRODUCT(id), cis_ptr));

    enable_function(sc, cdstatus, function);

    /* clean up every BAR */
    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, 0);
    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, 0);
    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, 0);
    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, 0);
    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, 0);
    cardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, 0);
    cardbus_conf_write(cc, cf, tag, CARDBUS_ROM_REG, 0);
 
    /* set initial latency and cacheline size */
    bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);
    DPRINTF(("%s func%d bhlc 0x%08x -> ", sc->sc_dev.dv_xname,
	function, bhlc));
    bhlc &= ~((CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT) |
	(CARDBUS_CACHELINE_MASK << CARDBUS_CACHELINE_SHIFT));
    bhlc |= ((sc->sc_cacheline & CARDBUS_CACHELINE_MASK) << CARDBUS_CACHELINE_SHIFT);
    bhlc |= ((sc->sc_lattimer & CARDBUS_LATTIMER_MASK) << CARDBUS_LATTIMER_SHIFT);

    cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);
    bhlc = cardbus_conf_read(cc, cf, tag, CARDBUS_BHLC_REG);
    DPRINTF(("0x%08x\n", bhlc));

    if (CARDBUS_LATTIMER(bhlc) < 0x10) {
	bhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
	bhlc |= (0x10 << CARDBUS_LATTIMER_SHIFT);
	cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);
    }

    /*
     * We need to allocate the ct here, since we might 
     * need it when reading the CIS
     */
    if (NULL == (ct = (cardbus_devfunc_t)malloc(sizeof(struct cardbus_devfunc),
						M_DEVBUF, M_NOWAIT))) {
      panic("no room for cardbus_tag");
    }

    ct->ct_cc = sc->sc_cc;
    ct->ct_cf = sc->sc_cf;
    ct->ct_bus = sc->sc_bus;
    ct->ct_dev = sc->sc_device;
    ct->ct_func = function;
    ct->ct_sc = sc;
    ct->ct_next = NULL;
    *previous_next = ct;

    memset(&ca, 0, sizeof(ca));

    ca.ca_unit = sc->sc_dev.dv_unit;
    ca.ca_ct = ct;

    ca.ca_iot = sc->sc_iot;
    ca.ca_memt = sc->sc_memt;
    ca.ca_dmat = sc->sc_dmat;
d522 2
a523 2
    ca.ca_rbus_iot = sc->sc_rbus_iot;
    ca.ca_rbus_memt = sc->sc_rbus_memt;
d526 14
a539 13
    ca.ca_tag = tag;
    ca.ca_bus = sc->sc_bus;
    ca.ca_device = sc->sc_device;
    ca.ca_function = function;
    ca.ca_id = id;
    ca.ca_class = class;

    ca.ca_intrline = sc->sc_intrline;

    if (cis_ptr != 0) {
	if(cardbus_read_tuples(&ca, cis_ptr, tuple, 2048)) {
	   printf("cardbus_attach_card: failed to read CIS\n");
	} else {
d541 1
a541 1
	   decode_tuples(tuple, 2048, print_tuple, NULL);
d543 17
a559 1
	   decode_tuples(tuple, 2048, parse_tuple, &ca.ca_cis);
d561 6
a566 20
    }

    if (NULL == (csc = config_found_sm((void *)sc, &ca, cardbusprint, cardbussubmatch))) {
      /* do not match */
      disable_function(sc, function);
      free(ct, M_DEVBUF);
      *previous_next = NULL;
    } else {
      /* found */
      previous_next = &(ct->ct_next);
      ct->ct_device = csc;
      ++no_work_funcs;
    }
  }
  /*
   * XXX power down pseudo function 8 (this will power down the card
   * if no functions were attached).
   */
  disable_function(sc, 8);
  free(tuple, M_TEMP);
d568 1
a568 1
  return no_work_funcs;
d571 5
d577 8
a584 17
static int
cardbussubmatch(parent, match, aux)
     struct device *parent;
     void *match;
     void *aux;
{
  struct cfdata *cf = match;
  struct cardbus_attach_args *ca = aux;

  if (cf->cardbuscf_dev != CARDBUS_UNK_DEV &&
      cf->cardbuscf_dev != ca->ca_unit) {
    return 0;
  }
  if (cf->cardbuscf_function != CARDBUS_UNK_FUNCTION &&
      cf->cardbuscf_function != ca->ca_function) {
    return 0;
  }
d586 1
a586 1
  return ((*cf->cf_attach->ca_match)(parent, cf, aux));
d589 6
d596 28
d625 1
a625 36
static int
cardbusprint(aux, pnp)
     void *aux;
     const char *pnp;
{
    struct cardbus_attach_args *ca = aux;
    char devinfo[256];
    int i;
    if (pnp) {
	pci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo, sizeof devinfo);
	for (i = 0; i < 4; i++) {
	    if (ca->ca_cis.cis1_info[i] == NULL)
		break;
	    if (i)
		printf(", ");
	    printf("%s", ca->ca_cis.cis1_info[i]);
	}
	if (i)
	    printf(" ");
	if (ca->ca_cis.manufacturer)
		printf("(manufacturer 0x%x, product 0x%x) ",
		    ca->ca_cis.manufacturer,
		    ca->ca_cis.product);
	printf("%s at %s", devinfo, pnp);
    }
    printf(" dev %d function %d", ca->ca_device, ca->ca_function);

    if (!pnp) {
	pci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo, sizeof devinfo);
	for (i = 0; i < 3 && ca->ca_cis.cis1_info[i]; i++)
		printf("%s%s", i ? ", " : " \"", ca->ca_cis.cis1_info[i]);
	if (ca->ca_cis.cis1_info[0])
		printf("\"");
    }

    return UNCONF;
a627 5





d637 1
a637 2
cardbus_detach_card(sc)
     struct cardbus_softc *sc;
d639 1
a639 1
    struct cardbus_devfunc *ct, *ct_next, **prev_next;
d641 1
a641 1
    prev_next = &(sc->sc_funcs->ct_next);
d643 3
a645 3
    for (ct = sc->sc_funcs; ct != NULL; ct = ct_next) {
	struct device *fndev = ct->ct_device;
	ct_next = ct->ct_next;
d647 3
a649 2
	DPRINTF(("%s: detaching %s\n", sc->sc_dev.dv_xname, fndev->dv_xname));
	/* call device detach function */
d651 9
a659 8
	if (0 != config_detach(fndev, 0)) {
	    printf("%s: cannot detach dev %s, function %d\n",
		   sc->sc_dev.dv_xname, fndev->dv_xname, ct->ct_func);
	    prev_next = &(ct->ct_next);
	} else {
	    sc->sc_poweron_func &= ~(1 << ct->ct_func);
	    *prev_next = ct->ct_next;
	    free(ct, M_DEVBUF);
a660 1
    }
d662 2
a663 2
    sc->sc_poweron_func = 0;
    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);
a665 3



d671 1
a671 1
 *   int irq: 
d674 2
a675 7
cardbus_intr_establish(cc, cf, irq, level, func, arg)
     cardbus_chipset_tag_t cc;
     cardbus_function_tag_t cf;
     cardbus_intr_handle_t irq;
     int level;
     int (*func)(void *);
     void *arg;
d677 1
a677 1
  DPRINTF(("- cardbus_intr_establish: irq %d\n", irq));
d679 1
a679 1
  return (*cf->cardbus_intr_establish)(cc, irq, level, func, arg);
a681 2


d689 2
a690 4
cardbus_intr_disestablish(cc, cf, handler)
     cardbus_chipset_tag_t cc;
     cardbus_function_tag_t cf;
     void *handler;
d692 1
a692 1
  DPRINTF(("- pccard_intr_disestablish\n"));
d694 1
a694 2
 (*cf->cardbus_intr_disestablish)(cc, handler);
  return;
a696 2


d701 13
a713 17
enable_function(sc, cdstatus, function)
     struct cardbus_softc *sc;
     int cdstatus;
     int function;
{

    if (sc->sc_poweron_func == 0) {
	/* switch to 3V and/or wait for power to stabilize */
	if (cdstatus & CARDBUS_3V_CARD) {
	    sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_3V);
	} else {
	    /* No cards other than 3.3V cards. */
	    return;
	}
	(sc->sc_cf->cardbus_ctrl)(sc->sc_cc, CARDBUS_RESET);
    }
    sc->sc_poweron_func |= (1 << function);
d717 1
a717 3
disable_function(sc, function)
     struct cardbus_softc *sc; 
     int function;
d719 5
a723 6

    sc->sc_poweron_func &= ~(1 << function);
    if (sc->sc_poweron_func == 0) {
	/* power-off because no functions are enabled */
	sc->sc_cf->cardbus_power(sc->sc_cc, CARDBUS_VCC_0V);
    }
d733 1
a733 3
cardbus_function_enable(sc, func)
     struct cardbus_softc *sc;
     int func;
d735 4
a738 4
  cardbus_chipset_tag_t cc = sc->sc_cc;
  cardbus_function_tag_t cf = sc->sc_cf;
  cardbusreg_t command;
  cardbustag_t tag;
d740 1
a740 1
  DPRINTF(("entering cardbus_function_enable...  "));
d742 1
a742 1
  /* entering critical area */
d744 2
a745 1
  enable_function(sc, CARDBUS_3V_CARD, func); /* XXX: sc_vold should be used */
d747 1
a747 1
  /* exiting critical area */
d749 1
a749 1
  tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);
d751 3
a753 2
  command = cardbus_conf_read(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG);
  command |= (CARDBUS_COMMAND_MEM_ENABLE | CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MASTER_ENABLE); /* XXX: good guess needed */
d755 1
a755 1
  cardbus_conf_write(cc, cf, tag, CARDBUS_COMMAND_STATUS_REG, command);
d757 1
a757 1
  cardbus_free_tag(cc, cf, tag);
d759 1
a759 1
  DPRINTF(("%x\n", sc->sc_poweron_func));
d761 1
a761 1
  return 0;
a763 1

d771 1
a771 3
cardbus_function_disable(sc, func)
     struct cardbus_softc *sc;
     int func;
d773 1
d775 1
a775 1
  DPRINTF(("entering cardbus_function_disable...  "));
d777 1
a777 3
  disable_function(sc, func);

  return 0;
a779 1

d788 2
a789 7
cardbus_get_capability(cc, cf, tag, capid, offset, value)
	cardbus_chipset_tag_t cc;
	cardbus_function_tag_t cf;
	cardbustag_t tag;
	int capid;
	int *offset;
	cardbusreg_t *value;
d820 2
a821 2
cardbus_matchbyid(struct cardbus_attach_args *ca, const struct cardbus_matchid *ids,
    int nent)
d842 13
a854 17
decode_tuples(tuple, buflen, func, data)
     u_int8_t *tuple;
     int buflen;
     tuple_decode_func func;
     void *data;
{
  u_int8_t *tp = tuple;

  if (PCMCIA_CISTPL_LINKTARGET != *tuple) {
    DPRINTF(("WRONG TUPLE: 0x%x\n", *tuple));
    return 0;
  }

  while ((tp = decode_tuple(tp, tuple + buflen, func, data)) != NULL)
    ;
  
  return 1;
d857 22
d880 4
a883 31
static u_int8_t *
decode_tuple(tuple, end, func, data)
     u_int8_t *tuple;
     u_int8_t *end;
     tuple_decode_func func;
     void *data;
{
    u_int8_t type;
    u_int8_t len;

    type = tuple[0];
    switch (type) {
    case PCMCIA_CISTPL_NULL:
    case PCMCIA_CISTPL_END:
        len = 1;
        break;
    default:
        if (tuple + 2 > end)
            return NULL;
        len = tuple[1] + 2;
        break;
    }

    if (tuple + len > end)
        return NULL;

    (*func)(tuple, len, data);

    if (PCMCIA_CISTPL_END == type || tuple + len == end) {
	return NULL;
    }
d885 1
a885 1
    return tuple + len;
a887 1

d892 1
a892 2
tuple_name(type)
     int type;
d894 28
a921 29
  static char *tuple_name_s [] = {
    "TPL_NULL", "TPL_DEVICE", "Reserved", "Reserved", /* 0-3 */
    "CONFIG_CB", "CFTABLE_ENTRY_CB", "Reserved", "BAR", /* 4-7 */
    "Reserved", "Reserved", "Reserved", "Reserved", /* 8-B */
    "Reserved", "Reserved", "Reserved", "Reserved", /* C-F */
    "CHECKSUM", "LONGLINK_A", "LONGLINK_C", "LINKTARGET",	/* 10-13 */
    "NO_LINK", "VERS_1", "ALTSTR", "DEVICE_A",
    "JEDEC_C", "JEDEC_A", "CONFIG", "CFTABLE_ENTRY",
    "DEVICE_OC", "DEVICE_OA", "DEVICE_GEO", "DEVICE_GEO_A",
    "MANFID", "FUNCID", "FUNCE", "SWIL", /* 20-23 */
    "Reserved", "Reserved", "Reserved", "Reserved", /* 24-27 */
    "Reserved", "Reserved", "Reserved", "Reserved", /* 28-2B */
    "Reserved", "Reserved", "Reserved", "Reserved", /* 2C-2F */
    "Reserved", "Reserved", "Reserved", "Reserved", /* 30-33 */
    "Reserved", "Reserved", "Reserved", "Reserved", /* 34-37 */
    "Reserved", "Reserved", "Reserved", "Reserved", /* 38-3B */
    "Reserved", "Reserved", "Reserved", "Reserved", /* 3C-3F */
    "VERS_2", "FORMAT", "GEOMETRY", "BYTEORDER",
    "DATE", "BATTERY", "ORG"
  };
#define NAME_LEN(x) (sizeof x / sizeof(x[0]))

  if (type > 0 && type < NAME_LEN(tuple_name_s)) {
    return tuple_name_s[type];
  } else if (0xff == type) {
    return "END";
  } else {
    return "Reserved";
  }
d925 15
a939 21
print_tuple(tuple, len, data)
     u_int8_t *tuple;
     int len;
     void *data;
{
    int i;

    printf("tuple: %s/%d len %d\n", tuple_name(tuple[0]), tuple[0], len);

    for (i = 0; i < len; ++i) {
	if (i % 16 == 0) {
	    printf("  0x%02x:", i);
	}
	printf(" %x",tuple[i]);
	if (i % 16 == 15) {
	    printf("\n");
	}
    }
    if (i % 16 != 0) {
	printf("\n");
    }
a940 1

@


1.23
log
@don't go beyond the end when parsing tuples. diff originally by pascoe@@,
final from enami@@netbsd.org.  problem found and tested by
Simon Kuhnle <simonkuhnle at web dot de> with a rtw card with a broken cis.
jsg@@ pascoe@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.22 2005/08/18 16:01:29 fgsch Exp $ */
d302 1
a302 1
	if(tuple[1] != 5) {
@


1.22
log
@on debug, print the tuple number along with the name to help debugging in
case of reserved tuples and pad to 0 the byte number. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.21 2005/08/02 21:49:46 pascoe Exp $ */
d877 1
a877 1
decode_tuple(u_int8_t *tuple, tuple_decode_func func, void *data);
d893 2
a894 5
  while (NULL != (tp = decode_tuple(tp, func, data))) {
    if (tuple + buflen < tp) {
      break;
    }
  }
d901 1
a901 1
decode_tuple(tuple, func, data)
d903 1
d911 14
a924 1
    len = tuple[1] + 2;
d928 1
a928 1
    if (PCMCIA_CISTPL_END == type) {
@


1.21
log
@kill 2kB stack offender in cardbus_attach_card.

ok deraadt fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.20 2005/05/28 19:46:07 jsg Exp $ */
d971 1
a971 1
    printf("tuple: %s len %d\n", tuple_name(tuple[0]), len);
d975 1
a975 1
	    printf("  0x%2x:", i);
@


1.20
log
@Don't display vid/pid from CIS if vid is 0.
Makes more sense than displaying the PCI values which is
already covered by the PCI code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.19 2005/05/28 02:35:48 jsg Exp $ */
d388 1
a388 1
  u_int8_t tuple[2048];
d441 5
d535 1
a535 1
	if(cardbus_read_tuples(&ca, cis_ptr, tuple, sizeof(tuple))) {
d562 1
@


1.19
log
@Don't use vid/pid from the CIS if vid is 0 when reporting unmatched
devices.  Several devices have been known to have this behaviour.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.18 2005/05/27 17:03:04 mickey Exp $ */
a590 1
    struct cardbus_matchid cm;
d604 5
a608 9
	if (ca->ca_cis.manufacturer) {
		cm.cm_vid = ca->ca_cis.manufacturer;
		cm.cm_pid = ca->ca_cis.product;
	} else {
		cm.cm_vid = CARDBUS_VENDOR(ca->ca_id);
		cm.cm_pid = CARDBUS_PRODUCT(ca->ca_id);
	}
	printf("(manufacturer 0x%x, product 0x%x)", cm.cm_vid, cm.cm_pid);
	printf(" %s at %s", devinfo, pnp);
@


1.18
log
@print the screwed ofs in the panic msg
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.17 2005/05/09 02:01:36 brad Exp $ */
d591 1
d605 8
a612 2
	printf("(manufacturer 0x%x, product 0x%x)", ca->ca_cis.manufacturer,
	       ca->ca_cis.product);
@


1.17
log
@PCI_{VENDOR,PRODUCT} -> CARDBUS_{VENDOR,PRODUCT} for correctness.
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.16 2005/05/09 00:38:57 brad Exp $ */
d833 1
a833 1
			panic("cardbus_get_capability");
@


1.16
log
@add cardbus_matchbyid(), mimics the PCI layers pci_matchbyid().
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.15 2004/10/07 21:16:59 brad Exp $ */
d857 2
a858 2
		if (PCI_VENDOR(ca->ca_id) == cm->cm_vid &&
		    PCI_PRODUCT(ca->ca_id) == cm->cm_pid)
@


1.15
log
@cardbusdevs -> pcidevs

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.14 2004/09/18 00:19:48 brad Exp $ */
d849 13
@


1.14
log
@- Record handles for memory and IO space
- If the CIS pointer is all-0s, don't try to read the CIS.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.13 2004/08/02 21:42:58 brad Exp $ */
d48 1
a48 1
#include <dev/cardbus/cardbusdevs.h>
d451 1
a451 1
    if (CARDBUS_VENDOR(id) == CARDBUS_VENDOR_INVALID) {
@


1.13
log
@- Initialise all function's latency timer and cacheline size.
- Fix grammar in error message.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.12 2004/07/15 17:59:38 brad Exp $ */
d515 5
d529 4
a532 3
    if(cardbus_read_tuples(&ca, cis_ptr, tuple, sizeof(tuple))) {
      printf("cardbus_attach_card: failed to read CIS\n");
    } else {
d534 1
a534 1
      decode_tuples(tuple, 2048, print_tuple, NULL);
d536 2
a537 1
      decode_tuples(tuple, 2048, parse_tuple, &ca.ca_cis);
@


1.12
log
@- Unmap space used to read tuple
- No need to zero clear temporary storage twice

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.11 2004/06/22 17:40:40 millert Exp $ */
d436 1
a436 1
  
d438 1
a438 6
  if (CARDBUS_LATTIMER(bhlc) < 0x10) {
    bhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
    bhlc |= (0x10 << CARDBUS_LATTIMER_SHIFT);
    cardbus_conf_write(cc, cf, tag, CARDBUS_BHLC_REG, bhlc);
  }

d468 20
a487 1
    
d643 1
a643 1
	    printf("%s: cannot detaching dev %s, function %d\n",
@


1.11
log
@If there is no CIS info the cardbus attach would print an extra
double quote; now it doesn't.  OK openbsd!beck
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.10 2004/05/04 16:59:31 grange Exp $ */
d169 1
d221 1
a221 1
			      NULL, &bar_memh, &bar_addr, &bar_size)) {
d277 3
a279 6
#if 0
	/* XXX unmap memory */
	(*ca->ca_ct->ct_cf->cardbus_space_free)(ca->ca_ct, 
						ca->ca_ct->ct_sc->sc_rbus_memt, 
						bar_memh, bar_size);
#endif
a508 2

    bzero(tuple, 2048);
@


1.10
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.9 2004/01/26 19:12:52 fgsch Exp $ */
d597 2
a598 1
	printf("\"");
@


1.9
log
@print cis information on configured cards as pcmcia(4) does; mentioned by
Ed White <ed at overminder dot com>.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.8 2003/10/21 10:07:33 jmc Exp $ */
d256 1
a256 1
		SIMPLEQ_REMOVE_HEAD(&rom_image, p, next);
@


1.8
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.7 2003/04/27 11:22:52 ho Exp $ */
d592 7
@


1.7
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.6 2002/03/14 03:16:04 millert Exp $ */
d375 1
a375 1
 *    reads and analyses tuple, sets consifuration index.
@


1.6
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.5 2002/03/14 01:26:52 millert Exp $ */
d577 1
a577 1
	pci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.4 2002/01/03 20:28:02 nate Exp $ */
d73 1
a73 1
typedef void (*tuple_decode_func)(u_int8_t*, int, void*);
d75 1
a75 1
static int decode_tuples(u_int8_t *, int, tuple_decode_func, void*);
d77 1
a77 1
static void print_tuple(u_int8_t*, int, void*);
@


1.4
log
@Add the bus to the cardbus_attach_args
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.3 2001/06/24 21:29:05 mickey Exp $ */
d65 7
a71 7
STATIC void cardbusattach __P((struct device *, struct device *, void *));
/* STATIC int cardbusprint __P((void *, const char *)); */
int cardbus_attach_card __P((struct cardbus_softc *));

STATIC int cardbusmatch __P((struct device *, void *, void *));
static int cardbussubmatch __P((struct device *, void *, void *));
static int cardbusprint __P((void *, const char *));
d75 1
a75 1
static int decode_tuples __P((u_int8_t *, int, tuple_decode_func, void*));
d77 1
a77 1
static void print_tuple __P((u_int8_t*, int, void*));
d80 2
a81 2
static int cardbus_read_tuples __P((struct cardbus_attach_args *,
				    cardbusreg_t, u_int8_t *, size_t));
d83 2
a84 2
static void enable_function __P((struct cardbus_softc *, int, int));
static void disable_function __P((struct cardbus_softc *, int));
d655 1
a655 1
     int (*func) __P((void *));
d831 1
a831 1
decode_tuple __P((u_int8_t *tuple, tuple_decode_func func, void *data));
d880 1
a880 1
static char *tuple_name __P((int type));
@


1.3
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.2 2000/05/15 06:36:21 niklas Exp $ */
d504 1
@


1.3.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.4 2002/01/03 20:28:02 nate Exp $ */
a503 1
    ca.ca_bus = sc->sc_bus;
@


1.3.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.3.4.1 2002/01/31 22:55:30 niklas Exp $ */
d65 3
a67 3
STATIC void cardbusattach(struct device *, struct device *, void *);
/* STATIC int cardbusprint(void *, const char *); */
int cardbus_attach_card(struct cardbus_softc *);
d69 3
a71 3
STATIC int cardbusmatch(struct device *, void *, void *);
static int cardbussubmatch(struct device *, void *, void *);
static int cardbusprint(void *, const char *);
d73 1
a73 1
typedef void (*tuple_decode_func)(u_int8_t*, int, void *);
d75 1
a75 1
static int decode_tuples(u_int8_t *, int, tuple_decode_func, void *);
d77 1
a77 1
static void print_tuple(u_int8_t*, int, void *);
d80 2
a81 2
static int cardbus_read_tuples(struct cardbus_attach_args *,
				    cardbusreg_t, u_int8_t *, size_t);
d83 2
a84 2
static void enable_function(struct cardbus_softc *, int, int);
static void disable_function(struct cardbus_softc *, int);
d655 1
a655 1
     int (*func)(void *);
d831 1
a831 1
decode_tuple(u_int8_t *tuple, tuple_decode_func func, void *data);
d880 1
a880 1
static char *tuple_name(int type);
@


1.3.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d577 1
a577 1
	pci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo, sizeof devinfo);
@


1.2
log
@Cardbus serial infrastructure
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.1 2000/04/08 05:50:52 aaron Exp $ */
a63 2

extern int cold;
@


1.2.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.2 2000/05/15 06:36:21 niklas Exp $ */
@


1.2.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.2.6.1 2001/05/14 22:23:09 niklas Exp $ */
d64 2
@


1.2.6.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a503 1
    ca.ca_bus = sc->sc_bus;
@


1.2.6.4
log
@cardbus too got skipped by cvs for some reason
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.2.6.3 2002/03/06 02:11:42 niklas Exp $ */
d65 3
a67 3
STATIC void cardbusattach(struct device *, struct device *, void *);
/* STATIC int cardbusprint(void *, const char *); */
int cardbus_attach_card(struct cardbus_softc *);
d69 3
a71 3
STATIC int cardbusmatch(struct device *, void *, void *);
static int cardbussubmatch(struct device *, void *, void *);
static int cardbusprint(void *, const char *);
d73 1
a73 1
typedef void (*tuple_decode_func)(u_int8_t*, int, void *);
d75 1
a75 1
static int decode_tuples(u_int8_t *, int, tuple_decode_func, void *);
d77 1
a77 1
static void print_tuple(u_int8_t*, int, void *);
d80 2
a81 2
static int cardbus_read_tuples(struct cardbus_attach_args *,
				    cardbusreg_t, u_int8_t *, size_t);
d83 2
a84 2
static void enable_function(struct cardbus_softc *, int, int);
static void disable_function(struct cardbus_softc *, int);
d655 1
a655 1
     int (*func)(void *);
d831 1
a831 1
decode_tuple(u_int8_t *tuple, tuple_decode_func func, void *data);
d880 1
a880 1
static char *tuple_name(int type);
@


1.2.6.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus.c,v 1.2.6.4 2002/03/29 23:39:33 niklas Exp $ */
d577 1
a577 1
	pci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo, sizeof devinfo);
@


1.2.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d375 1
a375 1
 *    reads and analyses tuple, sets configuration index.
a591 7

    if (!pnp) {
	pci_devinfo(ca->ca_id, ca->ca_class, 1, devinfo, sizeof devinfo);
	for (i = 0; i < 3 && ca->ca_cis.cis1_info[i]; i++)
		printf("%s%s", i ? ", " : " \"", ca->ca_cis.cis1_info[i]);
	printf("\"");
    }
@


1.2.6.7
log
@Merge with the trunk
@
text
@d256 1
a256 1
		SIMPLEQ_REMOVE_HEAD(&rom_image, next);
@


1.1
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d349 10
a358 2
	if(cis->funcid == PCMCIA_FUNCTION_NETWORK && tuple[1] >= 8) {
	    if(tuple[2] == PCMCIA_TPLFE_TYPE_LAN_NID) {
@

