head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.8
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.4
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.8
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	SMP:1.3.0.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	UBC_SYNC_B:1.3
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	UBC:1.2.0.2;
locks; strict;
comment	@ * @;


1.30
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.29;
commitid	5gdEnqVoJuTuwdTu;

1.29
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.28;
commitid	5DvsamK0GblTp8ww;

1.28
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.27;
commitid	LS2TNeCue5R9L67C;

1.27
date	2014.11.24.02.03.37;	author brad;	state Exp;
branches;
next	1.26;
commitid	Wmnzf8bGQILqXRTG;

1.26
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.25;
commitid	nYggAidK85QbUFh2;

1.25
date	2013.08.07.01.06.26;	author bluhm;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.07.01.05.28;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.07.01.03.57;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.02.17.47.04;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.21.18.14.51;	author naddy;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.02.17.27.39;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.08.18.49.32;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.16.12.30.08;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.21.11.27.03;	author fkr;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.17.17.58.17;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.29.01.00.24;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.29.07.54.33;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.16.01.36.25;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.07.21.16.59;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.09.20.08.02;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.07.15.47.52;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.21.10.07.33;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.27.19.40.23;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2002.06.08.10.01.38;	author jason;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.06.08.00.10.54;	author aaron;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2004.06.05.23.12.37;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.30
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_rl_cardbus.c,v 1.29 2015/11/24 13:33:17 mpi Exp $ */
/*	$NetBSD: if_rl_cardbus.c,v 1.3.8.3 2001/11/14 19:14:02 nathanw Exp $	*/

/*
 * Copyright (c) 2000 Masanori Kanaoka
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * if_rl_cardbus.c:
 *	Cardbus specific routines for Realtek 8139 ethernet adapter.
 *	Tested for 
 *		- elecom-Laneed	LD-10/100CBA (Accton MPX5030)
 *		- MELCO		LPC3-TX-CB   (Realtek 8139)
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/miivar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

/*
 * Default to using PIO access for this driver. On SMP systems,
 * there appear to be problems with memory mapped mode: it looks like
 * doing too many memory mapped access back to back in rapid succession
 * can hang the bus. I'm inclined to blame this on crummy design/construction
 * on the part of Realtek. Memory mapped mode does appear to work on
 * uniprocessor systems though.
 */
#define RL_USEIOSPACE 

#include <dev/ic/rtl81x9reg.h>

/*
 * Various supported device vendors/types and their names.
 */
const struct pci_matchid rl_cardbus_devices[] = {
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_FE2000VX },
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_5030 },
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_2CB_TXD },
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CB_TXD },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DFE690TXD },
	{ PCI_VENDOR_PLANEX, PCI_PRODUCT_PLANEX_FNW_3603_TX },
	{ PCI_VENDOR_PLANEX, PCI_PRODUCT_PLANEX_FNW_3800_TX },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8138 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8139 },
};

struct rl_cardbus_softc {
	struct rl_softc sc_rl;	/* real rtk softc */ 

	/* CardBus-specific goo. */
	void *sc_ih;
	cardbus_devfunc_t sc_ct;
	pci_chipset_tag_t sc_pc;
	pcitag_t sc_tag;
	int sc_csr;
	int sc_cben;
	int sc_bar_reg;
	pcireg_t sc_bar_val;
	bus_size_t sc_mapsize;
	int sc_intrline;
};

static int rl_cardbus_match(struct device *, void *, void *);
static void rl_cardbus_attach(struct device *, struct device *, void *);
static int rl_cardbus_detach(struct device *, int);
void rl_cardbus_setup(struct rl_cardbus_softc *);

struct cfattach rl_cardbus_ca = {
	sizeof(struct rl_cardbus_softc), rl_cardbus_match, rl_cardbus_attach,
	    rl_cardbus_detach
};

int
rl_cardbus_match(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid((struct cardbus_attach_args *)aux,
	    rl_cardbus_devices, nitems(rl_cardbus_devices)));
}


void
rl_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct rl_cardbus_softc		*csc =
	    (struct rl_cardbus_softc *)self;
	struct rl_softc			*sc = &csc->sc_rl;
	struct cardbus_attach_args	*ca = aux;
	struct cardbus_softc		*psc =
	    (struct cardbus_softc *)sc->sc_dev.dv_parent;
	cardbus_chipset_tag_t		cc = psc->sc_cc;
	cardbus_function_tag_t		cf = psc->sc_cf;                            
	cardbus_devfunc_t		ct = ca->ca_ct;
	bus_addr_t			adr;

	sc->sc_dmat = ca->ca_dmat;
	csc->sc_ct = ct;
	csc->sc_tag = ca->ca_tag;
	csc->sc_intrline = ca->ca_intrline;
	csc->sc_pc = ca->ca_pc;

	/*
	 * Map control/status registers.
	 */
	csc->sc_csr = PCI_COMMAND_MASTER_ENABLE;
#ifdef RL_USEIOSPACE
	if (Cardbus_mapreg_map(ct, RL_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->rl_btag, &sc->rl_bhandle, &adr, &csc->sc_mapsize) == 0) {
		csc->sc_cben = CARDBUS_IO_ENABLE;
		csc->sc_csr |= PCI_COMMAND_IO_ENABLE;
		csc->sc_bar_reg = RL_PCI_LOIO;
		csc->sc_bar_val = adr | PCI_MAPREG_TYPE_IO;
	}
#else
	if (Cardbus_mapreg_map(ct, RL_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->rl_btag, &sc->rl_bhandle, &adr, &csc->sc_mapsize) == 0) {
		csc->sc_cben = CARDBUS_MEM_ENABLE;
		csc->sc_csr |= PCI_COMMAND_MEM_ENABLE;
		csc->sc_bar_reg = RL_PCI_LOMEM;
		csc->sc_bar_val = adr | PCI_MAPREG_TYPE_MEM;
	}
#endif
	else {
		printf("%s: unable to map deviceregisters\n",
			 sc->sc_dev.dv_xname);
		return;
	}

	Cardbus_function_enable(ct);

	rl_cardbus_setup(csc);

	/*
	 * Map and establish the interrupt.
	 */
	csc->sc_ih = cardbus_intr_establish(cc, cf, csc->sc_intrline, IPL_NET,
	    rl_intr, sc, sc->sc_dev.dv_xname);
	if (csc->sc_ih == NULL) {
		printf(": couldn't establish interrupt\n");
		Cardbus_function_disable(csc->sc_ct);
		return;
	}
	printf(": irq %d", csc->sc_intrline);

	sc->rl_type = RL_8139;

	rl_attach(sc);
}

int 
rl_cardbus_detach(struct device *self, int flags)
{
	struct rl_cardbus_softc	*csc = (void *) self;
	struct rl_softc		*sc = &csc->sc_rl;
	struct cardbus_devfunc	*ct = csc->sc_ct;
	int			rv;

#ifdef DIAGNOSTIC
	if (ct == NULL)
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
#endif
	rv = rl_detach(sc);
	if (rv)
		return (rv);
	/*
	 * Unhook the interrupt handler.
	 */
	if (csc->sc_ih != NULL)
		cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, csc->sc_ih);
	
	/*
	 * Release bus space and close window.
	 */
	if (csc->sc_bar_reg != 0)
		Cardbus_mapreg_unmap(ct, csc->sc_bar_reg,
			sc->rl_btag, sc->rl_bhandle, csc->sc_mapsize);

	return (0);
}

void 
rl_cardbus_setup(struct rl_cardbus_softc *csc)
{
	struct rl_softc		*sc = &csc->sc_rl;
	cardbus_devfunc_t	ct = csc->sc_ct;
	cardbus_chipset_tag_t	cc = ct->ct_cc;
	pci_chipset_tag_t	pc = csc->sc_pc;
	pcireg_t		reg, command;
	int			pmreg;

	/*
	 * Handle power management nonsense.
	 */
	if (pci_get_capability(pc, csc->sc_tag,
	    PCI_CAP_PWRMGMT, &pmreg, 0)) {
		command = pci_conf_read(pc, csc->sc_tag, pmreg + 4);
		if (command & RL_PSTATE_MASK) {
			pcireg_t		iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pc, csc->sc_tag,
			    RL_PCI_LOIO);
			membase = pci_conf_read(pc, csc->sc_tag,
			    RL_PCI_LOMEM);
			irq = pci_conf_read(pc, csc->sc_tag,
			    PCI_PRODUCT_DELTA_8139);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode "
			    "-- setting to D0\n", sc->sc_dev.dv_xname,
			    command & RL_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, csc->sc_tag,
			    pmreg + 4, command);

			/* Restore PCI config data. */
			pci_conf_write(pc, csc->sc_tag,
			    RL_PCI_LOIO, iobase);
			pci_conf_write(pc, csc->sc_tag,
			    RL_PCI_LOMEM, membase);
			pci_conf_write(pc, csc->sc_tag,
			    PCI_PRODUCT_DELTA_8139, irq);
		}
	}

	/* Make sure the right access type is on the CardBus bridge. */
	(*ct->ct_cf->cardbus_ctrl)(cc, csc->sc_cben);
	(*ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	/* Program the BAR */
	pci_conf_write(pc, csc->sc_tag,
		csc->sc_bar_reg, csc->sc_bar_val);

	/* Enable the appropriate bits in the CARDBUS CSR. */
	reg = pci_conf_read(pc, csc->sc_tag, 
	    PCI_COMMAND_STATUS_REG);
	reg &= ~(PCI_COMMAND_IO_ENABLE|PCI_COMMAND_MEM_ENABLE);
	reg |= csc->sc_csr;
	pci_conf_write(pc, csc->sc_tag, 
	    PCI_COMMAND_STATUS_REG, reg);

	/*
	 * Make sure the latency timer is set to some reasonable
	 * value.
	 */
	reg = pci_conf_read(pc, csc->sc_tag, PCI_BHLC_REG);
	if (PCI_LATTIMER(reg) < 0x20) {
		reg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
		reg |= (0x20 << PCI_LATTIMER_SHIFT);
		pci_conf_write(pc, csc->sc_tag, PCI_BHLC_REG, reg);
	}
}

@


1.29
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.28 2014/12/19 22:44:58 guenther Exp $ */
a53 1
#include <net/if_dl.h>
@


1.28
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.27 2014/11/24 02:03:37 brad Exp $ */
d52 1
a52 1
 
a54 1
#include <net/if_types.h>
@


1.27
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.26 2014/08/11 12:45:45 mpi Exp $ */
d51 1
a56 2

#include <machine/endian.h>
@


1.26
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.25 2013/08/07 01:06:26 bluhm Exp $ */
d33 1
a33 1
 *	Cardbus specific routines for RealTek 8139 ethernet adapter.
d36 1
a36 1
 *		- MELCO		LPC3-TX-CB   (RealTek 8139)
d82 1
a82 1
 * on the part of RealTek. Memory mapped mode does appear to work on
@


1.25
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.24 2013/03/07 01:05:28 brad Exp $ */
a62 1
#ifdef INET
a63 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a64 1
#endif
@


1.24
log
@Sort the CardBus ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.22 2011/04/02 17:47:04 jasper Exp $ */
a65 1
#include <netinet/in_var.h>
@


1.23
log
@Fix and simplify determining whether we're using a 8129 or 8139 chipset. Only
the 8129 PCI id is a 8129, everything else is a 8139.

Allows the D-Link DFE-520TX board to work and would ensure proper determination
of the chipset for at least the 8138 based boards (PCI/CardBus).

Tested by kirby@@
Ok kirby@@ sthen@@ chris@@
@
text
@d98 1
d100 1
a100 3
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_FE2000VX },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8138 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8139 },
a101 1
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_2CB_TXD },
d105 2
@


1.22
log
@- use nitems(); no binary change@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.21 2010/03/27 21:40:13 jsg Exp $ */
a205 1
	/* XXX - hardcode this, for now */
@


1.21
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.20 2010/03/27 20:04:03 jsg Exp $ */
d139 1
a139 2
	    rl_cardbus_devices,
	    sizeof(rl_cardbus_devices)/sizeof(rl_cardbus_devices[0])));
@


1.20
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.19 2010/03/22 22:28:27 jsg Exp $ */
d115 1
d162 1
d250 1
a250 1
	cardbus_function_tag_t	cf = ct->ct_cf;
d257 1
a257 1
	if (cardbus_get_capability(cc, cf, csc->sc_tag,
d259 1
a259 1
		command = cardbus_conf_read(cc, cf, csc->sc_tag, pmreg + 4);
d264 1
a264 1
			iobase = cardbus_conf_read(cc, cf, csc->sc_tag,
d266 1
a266 1
			membase = cardbus_conf_read(cc, cf,csc->sc_tag,
d268 1
a268 1
			irq = cardbus_conf_read(cc, cf,csc->sc_tag,
d276 1
a276 1
			cardbus_conf_write(cc, cf, csc->sc_tag,
d280 1
a280 1
			cardbus_conf_write(cc, cf, csc->sc_tag,
d282 1
a282 1
			cardbus_conf_write(cc, cf, csc->sc_tag,
d284 1
a284 1
			cardbus_conf_write(cc, cf, csc->sc_tag,
d294 1
a294 1
	cardbus_conf_write(cc, cf, csc->sc_tag,
d298 1
a298 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, 
d302 1
a302 1
	cardbus_conf_write(cc, cf, csc->sc_tag, 
d309 1
a309 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, PCI_BHLC_REG);
d313 1
a313 1
		cardbus_conf_write(cc, cf, csc->sc_tag, PCI_BHLC_REG, reg);
@


1.19
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.18 2009/12/21 18:14:51 naddy Exp $ */
d152 1
a152 1
	pci_chipset_tag_t		cc = psc->sc_cc;
d247 1
a247 1
	pci_chipset_tag_t	cc = ct->ct_cc;
@


1.18
log
@Some cleaning for the rl(4) driver:
- ANSI
- KNF
- remove the use of register

from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.17 2009/06/02 17:27:39 jsg Exp $ */
d97 1
a97 1
const struct cardbus_matchid rl_cardbus_devices[] = {
d115 1
a115 1
	cardbustag_t sc_tag;
d152 1
a152 1
	cardbus_chipset_tag_t		cc = psc->sc_cc;
d165 1
a165 1
	csc->sc_csr = CARDBUS_COMMAND_MASTER_ENABLE;
d167 1
a167 1
	if (Cardbus_mapreg_map(ct, RL_PCI_LOIO, CARDBUS_MAPREG_TYPE_IO, 0,
d170 1
a170 1
		csc->sc_csr |= CARDBUS_COMMAND_IO_ENABLE;
d172 1
a172 1
		csc->sc_bar_val = adr | CARDBUS_MAPREG_TYPE_IO;
d175 1
a175 1
	if (Cardbus_mapreg_map(ct, RL_PCI_LOMEM, CARDBUS_MAPREG_TYPE_MEM, 0,
d178 1
a178 1
		csc->sc_csr |= CARDBUS_COMMAND_MEM_ENABLE;
d180 1
a180 1
		csc->sc_bar_val = adr | CARDBUS_MAPREG_TYPE_MEM;
d247 1
a247 1
	cardbus_chipset_tag_t	cc = ct->ct_cc;
d297 2
a298 2
	    CARDBUS_COMMAND_STATUS_REG);
	reg &= ~(CARDBUS_COMMAND_IO_ENABLE|CARDBUS_COMMAND_MEM_ENABLE);
d301 1
a301 1
	    CARDBUS_COMMAND_STATUS_REG, reg);
d307 5
a311 5
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG);
	if (CARDBUS_LATTIMER(reg) < 0x20) {
		reg &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
		reg |= (0x20 << CARDBUS_LATTIMER_SHIFT);
		cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG, reg);
@


1.17
log
@make rl at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.16 2007/05/08 18:49:32 deraadt Exp $ */
d135 1
a135 4
rl_cardbus_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d144 1
a144 3
rl_cardbus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d146 5
a150 4
	struct rl_cardbus_softc *csc = (struct rl_cardbus_softc *)self;
	struct rl_softc *sc = &csc->sc_rl;
	struct cardbus_attach_args *ca = aux;
	struct cardbus_softc *psc =
d152 4
a155 4
	cardbus_chipset_tag_t cc = psc->sc_cc;
	cardbus_function_tag_t cf = psc->sc_cf;                            
	cardbus_devfunc_t ct = ca->ca_ct;
	bus_addr_t adr;
d212 1
a212 3
rl_cardbus_detach(self, flags)
	struct device *self;
	int flags;
d214 4
a217 4
	struct rl_cardbus_softc *csc = (void *) self;
	struct rl_softc *sc = &csc->sc_rl;
	struct cardbus_devfunc *ct = csc->sc_ct;
	int	rv;
d243 1
a243 2
rl_cardbus_setup(csc)
	struct rl_cardbus_softc *csc;
d245 6
a250 6
	struct rl_softc *sc = &csc->sc_rl;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;
	pcireg_t	reg, command;
	int		pmreg;
@


1.16
log
@rl_detach() is only used for cardbus case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.15 2006/10/16 12:30:08 tom Exp $ */
a212 29
}

extern int rl_detach(struct rl_softc *);

int
rl_detach(sc)
	struct rl_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Unhook our tick handler. */
	timeout_del(&sc->sc_tick_tmo);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);

	return (0);
@


1.15
log
@Fix some "is is"s.  ok otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.14 2006/10/12 16:35:52 grange Exp $ */
d213 29
@


1.14
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.13 2006/06/21 11:27:03 fkr Exp $ */
d277 1
a277 1
			printf("%s: chip is is in D%d power mode "
@


1.13
log
@removal of '#ifdef rbus ... #else ...' directives, we use rbus in all
cases anyways, so we might as well remove code (the !rbus case) thats been
dead throughout the last years and just use the rbus code without ifdefs.

brad, miod "I am all for this diff"
ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.12 2006/06/17 17:58:17 brad Exp $ */
d201 1
a201 1
	    rl_intr, sc);
@


1.12
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.11 2006/05/29 01:00:24 pvalchev Exp $ */
a172 4
#if rbus
#else
		(*ct->ct_cf->cardbus_io_open)(cc, 0, adr, adr+csc->sc_mapsize);
#endif
a180 4
#if rbus
#else
		(*ct->ct_cf->cardbus_mem_open)(cc, 0, adr, adr+csc->sc_mapsize);
#endif
@


1.11
log
@minor space nit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.10 2005/05/29 07:54:33 brad Exp $ */
d49 1
@


1.10
log
@- better pcidevs entries for Intel Gig and add 82573 ids
- add/fix up Abocom enries
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.9 2005/05/16 01:36:25 brad Exp $ */
d263 1
a263 1
	pcireg_t	reg,command;
@


1.9
log
@Use cardbus_matchbyid().

ok millert@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.8 2004/10/07 21:16:59 brad Exp $ */
d97 2
a98 2
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_5030	},
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_TE100	},
@


1.8
log
@cardbusdevs -> pcidevs

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.7 2004/07/09 20:08:02 brad Exp $ */
d96 1
a96 1
static const struct rl_type rl_cardbus_devs[] = {
a105 1
	{ 0, 0 }
a132 17
const struct rl_type *rl_cardbus_lookup (const struct cardbus_attach_args *);

const struct rl_type *
rl_cardbus_lookup(ca)
	const struct cardbus_attach_args *ca;
{
	const struct rl_type *t;

	for (t = rl_cardbus_devs; t->rl_vid != 0; t++){ 	
		if (CARDBUS_VENDOR(ca->ca_id) == t->rl_vid &&
		    CARDBUS_PRODUCT(ca->ca_id) == t->rl_did) {
			return (t);
		}
	}
	return (NULL);
}

d139 3
a141 6
	struct cardbus_attach_args *ca = aux;

	if (rl_cardbus_lookup(ca) != NULL)
		return (1);

	return (0);
a157 1
	const struct rl_type *t;
a164 6
	t = rl_cardbus_lookup(ca); 
	if (t == NULL) { 
		printf("\n"); 
		panic("rl_cardbus_attach: impossible");
	 } 
	
@


1.7
log
@attach to Planex and Corega Ethernet cards.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.6 2004/04/07 15:47:52 mickey Exp $ */
a79 1
#include <dev/cardbus/cardbusdevs.h>
d97 9
a105 9
	{ CARDBUS_VENDOR_ACCTON, CARDBUS_PRODUCT_ACCTON_MPX5030	},
	{ CARDBUS_VENDOR_ABOCOM, CARDBUS_PRODUCT_ABOCOM_TE100	},
	{ CARDBUS_VENDOR_REALTEK, CARDBUS_PRODUCT_REALTEK_RT8138 },
	{ CARDBUS_VENDOR_REALTEK, CARDBUS_PRODUCT_REALTEK_RT8139 },
	{ CARDBUS_VENDOR_COREGA, CARDBUS_PRODUCT_COREGA_CB_TXD },
	{ CARDBUS_VENDOR_COREGA, CARDBUS_PRODUCT_COREGA_2CB_TXD },
	{ CARDBUS_VENDOR_DLINK, CARDBUS_PRODUCT_DLINK_DFE_690TXD },
	{ CARDBUS_VENDOR_PLANEX, CARDBUS_PRODUCT_PLANEX_FNW_3603_TX },
	{ CARDBUS_VENDOR_PLANEX, CARDBUS_PRODUCT_PLANEX_FNW_3800_TX },
@


1.6
log
@attach on abocom's 8139; from Kimmo Sinkko <kimmo@@sinkko.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.5 2003/10/21 10:07:33 jmc Exp $ */
d103 1
d105 2
@


1.5
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.4 2003/09/27 19:40:23 fgsch Exp $ */
d99 1
@


1.4
log
@CardBus D-Link DFE-690TXD support.
Prompted by Ed White <ed at overminder dot com>, tested by
Joshua Johnson <joshua.johnson at ftlsys dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.3 2002/10/12 01:09:44 krw Exp $ */
d265 1
a265 1
	 * Unhook the interrut handler.
@


1.3
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.2 2002/06/08 10:01:38 jason Exp $ */
d102 1
@


1.3.4.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a101 1
	{ CARDBUS_VENDOR_DLINK, CARDBUS_PRODUCT_DLINK_DFE_690TXD },
d264 1
a264 1
	 * Unhook the interrupt handler.
@


1.3.4.2
log
@Merge with the trunk
@
text
@a98 1
	{ CARDBUS_VENDOR_ABOCOM, CARDBUS_PRODUCT_ABOCOM_TE100	},
@


1.2
log
@de pee
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.1 2002/06/08 00:10:54 aaron Exp $ */
d258 1
a258 1
		panic("%s: data structure lacks\n", sc->sc_dev.dv_xname);
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.2.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_cardbus.c,v 1.2.2.1 2002/06/11 03:42:16 art Exp $ */
d258 1
a258 1
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
@


1.1
log
@Add support for RealTek 8129/8139-based CardBus cards; mostly from NetBSD.
deraadt@@, jasoni@@ ok. Thanks to niklas@@ for donating a card for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d120 4
a123 4
static int rl_cardbus_match	__P((struct device *, void *, void *));
static void rl_cardbus_attach	__P((struct device *, struct device *, void *));
static int rl_cardbus_detach	__P((struct device *, int));
void rl_cardbus_setup		__P((struct rl_cardbus_softc *));
d130 1
a130 2
const struct rl_type *rl_cardbus_lookup
	__P((const struct cardbus_attach_args *));
@

