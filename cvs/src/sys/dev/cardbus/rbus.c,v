head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.28
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.24
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.14
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.22
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.20
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.18
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.16
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.12
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.10
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2010.09.22.02.28.37;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.02.12.11.55;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.13.09.10.33;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.21.21.22.17;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.21.21.20.05;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.17.20.29.47;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.13.18.53.01;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.13.18.44.38;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.09.19.12.40;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.21.10.07.33;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.26.00.58.38;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.07.02.06.09;	author nordin;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.05.10.00.43;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2000.05.31.15.52.50;	author aaron;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.04.08.05.50.52;	author aaron;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.22.23.13;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2002.03.29.23.39.33;	author niklas;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove unused offset argument to rbus functions
ok krw@@ kettenis@@
@
text
@/*	$OpenBSD: rbus.c,v 1.15 2010/04/02 12:11:55 jsg Exp $	*/
/*	$NetBSD: rbus.c,v 1.3 1999/11/06 06:20:53 soren Exp $	*/
/*
 * Copyright (c) 1999
 *     HAYAKAWA Koichi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/extent.h>

#include <machine/bus.h>

#include <dev/cardbus/rbus.h>

/* #define RBUS_DEBUG */

#if defined RBUS_DEBUG
#define STATIC
#define DPRINTF(a) printf a
#else
#ifdef DDB
#define STATIC
#else
#define STATIC static
#endif
#define DPRINTF(a)
#endif


int
rbus_space_alloc(rbus_tag_t rbt, bus_addr_t addr, bus_size_t size,
    bus_addr_t mask, bus_addr_t align, int flags, bus_addr_t *addrp,
    bus_space_handle_t *bshp)
{
	return (rbus_space_alloc_subregion(rbt, rbt->rb_start, rbt->rb_end,
	    addr, size, mask, align, flags, addrp, bshp));
}

int
rbus_space_alloc_subregion(rbus_tag_t rbt, bus_addr_t substart,
    bus_addr_t subend, bus_addr_t addr, bus_size_t size,
    bus_addr_t mask, bus_addr_t align, int flags, bus_addr_t *addrp,
    bus_space_handle_t *bshp)
{
	bus_addr_t decodesize = mask + 1;
	bus_addr_t boundary, search_addr;
	int val;
	u_long result;
	int exflags = EX_FAST | EX_NOWAIT | EX_MALLOCOK;

	DPRINTF(("rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\n",
	    (u_long)addr, (u_long)size, (u_long)mask, (u_long)align));

	if (mask == 0) {
		/* FULL Decode */
		decodesize = 0;
	}

	if (rbt->rb_flags == RBUS_SPACE_SHARE ||
	    rbt->rb_flags == RBUS_SPACE_DEDICATE) {
		/* rbt has its own sh_extent */

		/* sanity check: the subregion [substart, subend] should be
		   smaller than the region included in sh_extent */
		if (substart < rbt->rb_ext->ex_start ||
		    subend > rbt->rb_ext->ex_end) {
			DPRINTF(("rbus: out of range\n"));
			return (1);
		}

		if (decodesize == align) {
			if (extent_alloc_subregion(rbt->rb_ext, substart,
			    subend, size, align, 0, 0, exflags, &result))
				return (1);
		} else if (decodesize == 0) {
			/* maybe, the register is overflowed. */

			if (extent_alloc_subregion(rbt->rb_ext, addr,
			    addr + size, size, 1, 0, 0, exflags, &result))
				return (1);
		} else {
			boundary = decodesize > align ? decodesize : align;

			search_addr = (substart & ~(boundary - 1)) + addr;

			if (search_addr < substart)
				search_addr += boundary;

			val = 1;
			for (; search_addr + size <= subend;
			    search_addr += boundary) {
				val = extent_alloc_subregion(
				    rbt->rb_ext,search_addr,
				    search_addr + size, size, align, 0, 0,
				    exflags, &result);
				DPRINTF(("rbus: trying [%lx:%lx] %lx\n",
				    (u_long)search_addr,
				    (u_long)search_addr + size,
				    (u_long)align));
				if (val == 0)
					break;
			}

			if (val != 0) {
				/* no space found */
				DPRINTF(("rbus: no space found\n"));
				return (1);
			}
		}

		if (md_space_map(rbt, result, size, flags, bshp)) {
			/* map failed */
			extent_free(rbt->rb_ext, result, size, exflags);
			return (1);
		}

		if (addrp != NULL)
			*addrp = result;
		return (0);
	} else {
		/* error!! */
		DPRINTF(("rbus: no rbus type\n"));
		return (1);
	}
}

int
rbus_space_free(rbus_tag_t rbt, bus_space_handle_t bsh, bus_size_t size,
    bus_addr_t *addrp)
{
	int exflags = EX_FAST | EX_NOWAIT;
	bus_addr_t addr;
	int status = 1;

	if (rbt->rb_flags == RBUS_SPACE_SHARE ||
	    rbt->rb_flags == RBUS_SPACE_DEDICATE) {
		md_space_unmap(rbt, bsh, size, &addr);

		extent_free(rbt->rb_ext, addr, size, exflags);

		status = 0;
	} else {
		/* error. INVALID rbustag */
		status = 1;
	}

	if (addrp != NULL)
		*addrp = addr;

	return (status);
}

/*
 * rbus_tag_t
 * rbus_new_body(bus_space_tag_t bt,
 *               struct extent *ex, bus_addr_t start, bus_size_t end,
 *               int flags)
 *
 */
rbus_tag_t
rbus_new_body(bus_space_tag_t bt, struct extent *ex,
    bus_addr_t start, bus_addr_t end, int flags)
{
	rbus_tag_t rb;

	if ((rb = (rbus_tag_t)malloc(sizeof(struct rbustag), M_DEVBUF,
	    M_NOWAIT)) == NULL) {
		panic("no memory for rbus instance");
	}

	rb->rb_bt = bt;
	rb->rb_start = start;
	rb->rb_end = end;
	rb->rb_flags = flags;
	rb->rb_ext = ex;

	DPRINTF(("rbus_new_body: [%lx, %lx] type %s name [%s]\n",
	    (u_long)start, (u_long)end,
	   flags == RBUS_SPACE_SHARE ? "share" :
	   flags == RBUS_SPACE_DEDICATE ? "dedicated" : "invalid",
	   ex != NULL ? ex->ex_name : "noname"));

	return (rb);
}

/*
 * rbus_tag_t rbus_new_root_delegate(bus_space_tag, bus_addr_t,
 *                                   bus_size_t)
 *
 *  This function makes a root rbus instance.
 */
rbus_tag_t
rbus_new_root_delegate(bus_space_tag_t bt, bus_addr_t start, bus_size_t size)
{
	rbus_tag_t rb;
	struct extent *ex;

	if ((ex = extent_create("rbus root", start, start + size, M_DEVBUF,
	    NULL, 0, EX_NOCOALESCE|EX_NOWAIT)) == NULL)
		return (NULL);

	rb = rbus_new_body(bt, ex, start, start + size,
	    RBUS_SPACE_DEDICATE);

	if (rb == NULL)
		extent_destroy(ex);

	return (rb);
}

/*
 * rbus_tag_t rbus_new_root_share(bus_space_tag, struct extent *,
 *                                 bus_addr_t, bus_size_t)
 *
 *  This function makes a root rbus instance.
 */
rbus_tag_t
rbus_new_root_share(bus_space_tag_t bt, struct extent *ex, bus_addr_t start,
    bus_size_t size)
{
	/* sanity check */
	if (start < ex->ex_start || start + size > ex->ex_end) {
		/* out of range: [start, size] should be contained in
		 * parent space
		 */
		return (0);
		/* Should I invoke panic? */
	}

	return (rbus_new_body(bt, ex, start, start + size,
	    RBUS_SPACE_SHARE));
}
@


1.15
log
@Remove parent/slave mode of rbus as nothing uses it.
ok kettenis, sgi usage of rbus_new_body() pointed out by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.14 2010/01/13 09:10:33 jsg Exp $	*/
a76 2
	addr += rbt->rb_offset;

d141 1
a141 1
			*addrp = result + rbt->rb_offset;
d180 1
a180 1
 *               bus_addr_t offset, int flags)
d185 1
a185 1
    bus_addr_t start, bus_addr_t end, bus_addr_t offset, int flags)
a196 1
	rb->rb_offset = offset;
d211 1
a211 1
 *                                   bus_size_t, bus_addr_t offset)
d216 1
a216 2
rbus_new_root_delegate(bus_space_tag_t bt, bus_addr_t start, bus_size_t size,
    bus_addr_t offset)
d225 1
a225 1
	rb = rbus_new_body(bt, ex, start, start + size, offset,
d236 1
a236 1
 *                                 bus_addr_t, bus_size_t, bus_addr_t offset)
d242 1
a242 1
    bus_size_t size, bus_addr_t offset)
d253 1
a253 1
	return (rbus_new_body(bt, ex, start, start + size, offset,
@


1.14
log
@As per NetBSD move HAYAKAWA Koichi's licenses to two clause.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.13 2009/07/21 21:22:17 miod Exp $	*/
d84 1
a84 4
	if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {
		return (rbus_space_alloc(rbt->rb_parent, addr, size, mask,
		    align, flags, addrp, bshp));
	} else if (rbt->rb_flags == RBUS_SPACE_SHARE ||
d160 1
a160 3
	if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {
		status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);
	} else if (rbt->rb_flags == RBUS_SPACE_SHARE ||
d180 1
a180 1
 * rbus_new_body(bus_space_tag_t bt, rbus_tag_t parent,
d186 1
a186 1
rbus_new_body(bus_space_tag_t bt, rbus_tag_t parent, struct extent *ex,
a190 11
	/* sanity check */
	if (parent != NULL) {
		if (start < parent->rb_start || end > parent->rb_end) {
			/* out of range: [start, size] should be contained
			 * in parent space
			 */
			return (0);
			/* Should I invoke panic? */
		}
	}

a196 1
	rb->rb_parent = parent;
d206 1
a206 2
	   flags == RBUS_SPACE_DEDICATE ? "dedicated" :
	   flags == RBUS_SPACE_ASK_PARENT ? "parent" : "invalid",
a212 36
 * rbus_tag_t rbus_new(rbus_tag_t parent, bus_addr_t start, bus_size_t
 *                     size, bus_addr_t offset, int flags)
 *
 *  This function makes a new child rbus instance.
 */
rbus_tag_t
rbus_new(rbus_tag_t parent, bus_addr_t start, bus_size_t size,
    bus_addr_t offset, int flags)
{
	rbus_tag_t rb;
	struct extent *ex = NULL;
	bus_addr_t end = start + size;

	if (flags == RBUS_SPACE_SHARE) {
		ex = parent->rb_ext;
	} else if (flags == RBUS_SPACE_DEDICATE) {
		if ((ex = extent_create("rbus", start, end, M_DEVBUF, NULL, 0,
		    EX_NOCOALESCE|EX_NOWAIT)) == NULL)
			return (NULL);
	} else if (flags == RBUS_SPACE_ASK_PARENT) {
		ex = NULL;
	} else {
		/* Invalid flag */
		return (0);
	}

	rb = rbus_new_body(parent->rb_bt, parent, ex, start, start + size,
	    offset, flags);

	if ((rb == NULL) && (flags == RBUS_SPACE_DEDICATE))
		extent_destroy(ex);

	return (rb);
}

/*
d229 1
a229 1
	rb = rbus_new_body(bt, NULL, ex, start, start + size, offset,
d257 1
a257 1
	return (rbus_new_body(bt, NULL, ex, start, start + size, offset,
a258 19
}

/*
 * int rbus_delete (rbus_tag_t rb)
 *
 *   This function deletes the rbus structure pointed in the argument.
 */
int
rbus_delete(rbus_tag_t rb)
{
	DPRINTF(("rbus_delete called [%s]\n", rb->rb_ext != NULL ?
	    rb->rb_ext->ex_name : "noname"));

	if (rb->rb_flags == RBUS_SPACE_DEDICATE)
		extent_destroy(rb->rb_ext);

	free(rb, M_DEVBUF);

	return (0);
@


1.13
log
@Make rbus_new_body() invocable from outside cardbus.c, to allow md code
to use it to allocate a ``every operation will fail'' rbus in case of
error.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.12 2009/07/21 21:20:05 miod Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by HAYAKAWA Koichi.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.12
log
@Change the rbus md_space_{map,unmap} signature to take a rbus_tag_t instead
of the bus_space_tag_t it contains; an upcoming implementation will need
to know the rbus_tag_t for which it works at this point.

All callers updated accordingly; no functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.11 2007/09/17 20:29:47 miod Exp $	*/
a57 3
STATIC rbus_tag_t rbus_new_body(bus_space_tag_t, rbus_tag_t, struct extent *,
		      bus_addr_t, bus_addr_t, bus_addr_t, int);

d189 1
a189 1
 * STATIC rbus_tag_t
d195 1
a195 1
STATIC rbus_tag_t
@


1.11
log
@Un-staticize if option DDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.10 2005/09/13 18:53:01 fgsch Exp $	*/
d147 1
a147 1
		if (md_space_map(rbt->rb_bt, result, size, flags, bshp)) {
d175 1
a175 1
		md_space_unmap(rbt->rb_bt, bsh, size, &addr);
@


1.10
log
@some missing cleanup from the previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.9 2005/09/13 18:44:38 fgsch Exp $	*/
d48 3
a50 1
#define DDELAY(x) delay((x)*1000*1000)
d53 1
d58 1
a58 1
static rbus_tag_t rbus_new_body(bus_space_tag_t, rbus_tag_t, struct extent *,
d192 1
a192 1
 * static rbus_tag_t
d198 1
a198 1
static rbus_tag_t
@


1.9
log
@knf; no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.8 2004/07/09 19:12:40 brad Exp $	*/
d55 2
a56 4
static rbus_tag_t rbus_new_body(bus_space_tag_t bt, rbus_tag_t parent,
				    struct extent *ex, bus_addr_t start,
				    bus_addr_t end, bus_addr_t offset,
				    int flags);
@


1.8
log
@brings in a few fixes from NetBSD...
- fix typo in comment: resister -> register
- Remove an unreachable return statement (and fix a whitespace nit)
- Fix some DPRINTF statements to deal with bus_addr_t and bus_size_t types
defined in terms if 'int' instead of 'long'.
- use u_long for extent_alloc_subregion result instead of bus_addr_t

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.7 2003/10/21 10:07:33 jmc Exp $ */
a32 3


#include <sys/types.h>
a54 1

a59 1

d61 3
a63 8
rbus_space_alloc(rbt, addr, size, mask, align, flags, addrp, bshp)
     rbus_tag_t rbt;
     bus_addr_t addr;
     bus_size_t size;
     bus_addr_t mask, align;
     int flags;
     bus_addr_t *addrp;
     bus_space_handle_t *bshp;
d65 2
a66 2
  return rbus_space_alloc_subregion(rbt, rbt->rb_start, rbt->rb_end, addr,
				    size, mask, align, flags, addrp, bshp);
a68 3



d70 4
a73 10
rbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)
     rbus_tag_t rbt;
     bus_addr_t addr;
     bus_addr_t substart;
     bus_addr_t subend;
     bus_size_t size;
     bus_addr_t mask, align;
     int flags;
     bus_addr_t *addrp;
     bus_space_handle_t *bshp;
d75 84
a158 61
  bus_addr_t decodesize = mask + 1;
  bus_addr_t boundary, search_addr;
  int val;
  u_long result;
  int exflags = EX_FAST | EX_NOWAIT | EX_MALLOCOK;

  DPRINTF(("rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\n",
	   (u_long)addr, (u_long)size, (u_long)mask, (u_long)align));

  addr += rbt->rb_offset;

  if (mask == 0) {
    /* FULL Decode */
    decodesize = 0;
  }

  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {
    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,
			    addrp, bshp);
  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||
	     rbt->rb_flags == RBUS_SPACE_DEDICATE) {
    /* rbt has its own sh_extent */

    /* sanity check: the subregion [substart, subend] should be
       smaller than the region included in sh_extent */
    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {
      DPRINTF(("rbus: out of range\n"));
      return 1;
    }

    if (decodesize == align) {
      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,
				0, exflags, &result)) {
	return 1;
      }
    } else if (decodesize == 0) {
      /* maybe, the register is overflowed. */
      
      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,
				 1, 0, 0, exflags, &result)) {
	return 1;
      }
    } else {

      boundary = decodesize > align ? decodesize : align;

      search_addr = (substart & ~(boundary - 1)) + addr;

      if (search_addr < substart) {
	search_addr += boundary;
      }

      val = 1;
      for (; search_addr + size <= subend; search_addr += boundary) {
	val = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,
				size, align, 0, 0, exflags, &result);
        DPRINTF(("rbus: trying [%lx:%lx] %lx\n",
	    (u_long)search_addr,
	    (u_long)search_addr+size, (u_long)align));
	if (val == 0) {
	  break;
a159 23
      }
      if (val != 0) {
        /* no space found */
        DPRINTF(("rbus: no space found\n"));
	return 1;
      }
    }

    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {
      /* map failed */
      extent_free(rbt->rb_ext, result, size, exflags);
      return 1;
    }

    if (addrp != NULL) {
      *addrp = result + rbt->rb_offset;
    }
    return 0;
  } else {
    /* error!! */
    DPRINTF(("rbus: no rbus type\n"));
    return 1;
  }
a161 4




d163 2
a164 5
rbus_space_free(rbt, bsh, size, addrp)
     rbus_tag_t rbt;
     bus_space_handle_t bsh;
     bus_size_t size;
     bus_addr_t *addrp;
d166 17
a182 22
  int exflags = EX_FAST | EX_NOWAIT;
  bus_addr_t addr;
  int status = 1;

  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {
    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);
  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||
	     rbt->rb_flags == RBUS_SPACE_DEDICATE) {
    md_space_unmap(rbt->rb_bt, bsh, size, &addr);

    extent_free(rbt->rb_ext, addr, size, exflags);

    status = 0;
  } else {
    /* error. INVALID rbustag */
    status = 1;
  }
  if (addrp != NULL) {
    *addrp = addr;
  }
  return status;
}
d184 2
d187 2
d198 2
a199 6
rbus_new_body(bt, parent, ex, start, end, offset, flags)
     bus_space_tag_t bt;
     rbus_tag_t parent;
     struct extent *ex;
     bus_addr_t start, end, offset;
     int flags;
d201 17
a217 1
  rbus_tag_t rb;
d219 7
a225 21
  /* sanity check */
  if (parent != NULL) {
    if (start < parent->rb_start || end > parent->rb_end) {
      /* out of range: [start, size] should be contained in parent space */
      return 0;
      /* Should I invoke panic? */
    }
  }

  if (NULL == (rb = (rbus_tag_t)malloc(sizeof(struct rbustag), M_DEVBUF,
					 M_NOWAIT))) {
    panic("no memory for rbus instance");
  }
  
  rb->rb_bt = bt;
  rb->rb_parent = parent;
  rb->rb_start = start;
  rb->rb_end = end;
  rb->rb_offset = offset;
  rb->rb_flags = flags;
  rb->rb_ext = ex;
d227 2
a228 2
  DPRINTF(("rbus_new_body: [%lx, %lx] type %s name [%s]\n",
	   (u_long)start, (u_long)end,
d234 1
a234 1
  return rb;
a236 2


d244 2
a245 6
rbus_new(parent, start, size, offset, flags)
     rbus_tag_t parent;
     bus_addr_t start;
     bus_size_t size;
     bus_addr_t offset;
     int flags;
d247 16
a262 27
  rbus_tag_t rb;
  struct extent *ex = NULL;
  bus_addr_t end = start + size;

  if (flags == RBUS_SPACE_SHARE) {
    ex = parent->rb_ext;
  } else if (flags == RBUS_SPACE_DEDICATE) {
    if (NULL == (ex = extent_create("rbus", start, end, M_DEVBUF, NULL, 0, 
				    EX_NOCOALESCE|EX_NOWAIT))) {
      return NULL;
    }
  } else if (flags == RBUS_SPACE_ASK_PARENT) {
    ex = NULL;
  } else {
    /* Invalid flag */
    return 0;
  }

  rb = rbus_new_body(parent->rb_bt, parent, ex, start, start + size,
		     offset, flags);

  if ((rb == NULL) && (flags == RBUS_SPACE_DEDICATE)) {
    extent_destroy(ex);
  }

  return rb;
}
d264 2
d267 2
d270 2
d280 2
a281 5
rbus_new_root_delegate(bt, start, size, offset)
     bus_space_tag_t bt;
     bus_addr_t start;
     bus_size_t size;
     bus_addr_t offset;
d283 2
a284 2
  rbus_tag_t rb;
  struct extent *ex;
d286 3
a288 11
  if (NULL == (ex = extent_create("rbus root", start, start + size, M_DEVBUF,
				  NULL, 0, EX_NOCOALESCE|EX_NOWAIT))) {
    return NULL;
  }
  
  rb = rbus_new_body(bt, NULL, ex, start, start + size, offset,
		     RBUS_SPACE_DEDICATE);

  if (rb == NULL) {
    extent_destroy(ex);
  }
d290 2
a291 2
  return rb;
}
d293 2
d296 2
d306 2
a307 6
rbus_new_root_share(bt, ex, start, size, offset)
     bus_space_tag_t bt;
     struct extent *ex;
     bus_addr_t start;
     bus_size_t size;
     bus_addr_t offset;
d309 8
a316 6
  /* sanity check */
  if (start < ex->ex_start || start + size > ex->ex_end) {
    /* out of range: [start, size] should be contained in parent space */
    return 0;
    /* Should I invoke panic? */
  }
d318 2
a319 2
  return rbus_new_body(bt, NULL, ex, start, start + size, offset,
		       RBUS_SPACE_SHARE);
a321 4




d328 1
a328 2
rbus_delete(rb)
     rbus_tag_t rb;
d330 5
a334 5
  DPRINTF(("rbus_delete called [%s]\n",
	   rb->rb_ext != NULL ? rb->rb_ext->ex_name : "noname"));
  if (rb->rb_flags == RBUS_SPACE_DEDICATE) {
    extent_destroy(rb->rb_ext);
  }
d336 1
a336 1
  free(rb, M_DEVBUF);
d338 1
a338 1
  return 0;
@


1.7
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.6 2003/06/26 00:58:38 mickey Exp $ */
d97 1
a97 1
  bus_addr_t result;
d101 1
a101 1
	   addr, size, mask, align));
d126 1
a126 1
				0, exflags, (u_long *)&result)) {
d130 1
a130 1
      /* maybe, the resister is overflowed. */
d133 1
a133 1
				 1, 0, 0, exflags, (u_long *)&result)) {
d149 1
a149 1
				size, align, 0, 0, exflags, (u_long *)&result);
d151 2
a152 1
            search_addr, search_addr+size, align));
a173 1

a178 1
  return 1;
d256 2
a257 1
  DPRINTF(("rbus_new_body: [%lx, %lx] type %s name [%s]\n", start, end,
@


1.6
log
@alignment for extent_alloc_subregion cannot be zero
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.5 2002/06/07 02:06:09 nordin Exp $ */
d238 1
a238 1
      /* out of range: [start, size] should be containd in parent space */
d362 1
a362 1
    /* out of range: [start, size] should be containd in parent space */
@


1.5
log
@Don't free an uninitialized pointer. art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.4 2002/03/14 01:26:53 millert Exp $ */
d133 1
a133 1
				 0, 0, 0, exflags, (u_long *)&result)) {
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.3 2001/07/05 10:00:43 art Exp $ */
a290 1
      free(rb, M_DEVBUF);
@


1.3
log
@Get rid of the wrapper macros around extent_alloc*1
Pass the right amount of arguments and rename them back to their right names.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.2 2000/05/31 15:52:50 aaron Exp $ */
d59 1
a59 1
static rbus_tag_t rbus_new_body __P((bus_space_tag_t bt, rbus_tag_t parent,
d62 1
a62 1
				    int flags));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.3 2001/07/05 10:00:43 art Exp $ */
d59 1
a59 1
static rbus_tag_t rbus_new_body(bus_space_tag_t bt, rbus_tag_t parent,
d62 1
a62 1
				    int flags);
d291 1
@


1.2
log
@Bug fix from NetBSD, plus some more DPRINTF().
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.1 2000/04/08 05:50:52 aaron Exp $ */
d126 1
a126 1
				exflags, (u_long *)&result)) {
d133 1
a133 1
				 0, 0, exflags, (u_long *)&result)) {
d149 1
a149 1
				size, align, 0, exflags, (u_long *)&result);
@


1.2.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.2 2000/05/31 15:52:50 aaron Exp $ */
@


1.2.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.2.6.1 2001/05/14 22:23:13 niklas Exp $ */
d126 1
a126 1
				0, exflags, (u_long *)&result)) {
d133 1
a133 1
				 0, 0, 0, exflags, (u_long *)&result)) {
d149 1
a149 1
				size, align, 0, 0, exflags, (u_long *)&result);
@


1.2.6.3
log
@cardbus too got skipped by cvs for some reason
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus.c,v 1.2.6.2 2001/10/31 03:22:40 nate Exp $ */
d59 1
a59 1
static rbus_tag_t rbus_new_body(bus_space_tag_t bt, rbus_tag_t parent,
d62 1
a62 1
				    int flags);
@


1.2.6.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d291 1
@


1.2.6.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d133 1
a133 1
				 1, 0, 0, exflags, (u_long *)&result)) {
d238 1
a238 1
      /* out of range: [start, size] should be contained in parent space */
d362 1
a362 1
    /* out of range: [start, size] should be contained in parent space */
@


1.1
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d96 1
a96 1
  int val = 0;
d98 1
a98 1
  int exflags = EX_FAST | EX_NOWAIT;
d120 1
d146 1
d150 2
d156 3
a158 1
      if (val) {
d176 1
@

