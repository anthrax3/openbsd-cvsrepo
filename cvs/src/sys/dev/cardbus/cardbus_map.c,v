head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.12
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.10
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.6
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.22
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.20
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.18
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.14
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.12
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.10
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.8
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.14;
commitid	p4LJxGKbi0BU2cG6;

1.14
date	2010.03.27.23.36.36;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.13.09.10.33;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.23.15.09.41;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.17.20.29.47;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.31.11.06.27;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.21.11.27.03;	author fkr;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.13.18.44.38;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.04.23.10.48;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.27.20.59.15;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.08.05.50.52;	author aaron;	state Exp;
branches
	1.1.8.1
	1.1.12.1;
next	;

1.1.8.1
date	2001.05.14.22.23.09;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2002.03.29.23.39.33;	author niklas;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	;

1.1.12.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: cardbus_map.c,v 1.14 2010/03/27 23:36:36 jsg Exp $	*/
/*	$NetBSD: cardbus_map.c,v 1.10 2000/03/07 00:31:46 mycroft Exp $	*/

/*
 * Copyright (c) 1999 and 2000
 *      HAYAKAWA Koichi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/param.h>
#include <sys/systm.h>

#include <machine/bus.h>

#include <dev/cardbus/cardbusvar.h>

#include <dev/pci/pcireg.h>	/* XXX */

#if defined DEBUG && !defined CARDBUS_MAP_DEBUG
#define CARDBUS_MAP_DEBUG
#endif

#if defined CARDBUS_MAP_DEBUG
#define STATIC
#define DPRINTF(a) printf a
#else
#ifdef DDB
#define STATIC
#else
#define STATIC static
#endif
#define DPRINTF(a)
#endif

/*
 * int cardbus_mapreg_map(struct cardbus_softc *, int, int, pcireg_t,
 *			  int bus_space_tag_t *, bus_space_handle_t *,
 *			  bus_addr_t *, bus_size_t *)
 *    This function maps bus-space on the value of Base Address
 *   Register (BAR) indexed by the argument `reg' (the second argument).
 *   When the value of the BAR is not valid, such as 0x00000000, a new
 *   address should be allocated for the BAR and new address values is
 *   written on the BAR.
 */
int
cardbus_mapreg_map(struct cardbus_softc *sc, int func, int reg,
    pcireg_t type, int busflags, bus_space_tag_t *tagp,
    bus_space_handle_t *handlep, bus_addr_t *basep, bus_size_t *sizep)
{
	cardbus_chipset_tag_t cc = sc->sc_cc;
	pci_chipset_tag_t pc = sc->sc_pc;
	cardbus_function_tag_t cf = sc->sc_cf;
	bus_space_tag_t bustag;
	rbus_tag_t rbustag;
	bus_space_handle_t handle;
	bus_addr_t base;
	bus_size_t size;
	int flags;
	int status = 0;

	pcitag_t tag = pci_make_tag(pc, sc->sc_bus,
	    sc->sc_device, func);

	DPRINTF(("cardbus_mapreg_map called: %s %x\n", sc->sc_dev.dv_xname,
	   type));

	if (pci_mapreg_info(pc, tag, reg, type, &base, &size, &flags))
		status = 1;

	if (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {
		bustag = sc->sc_iot;
		rbustag = sc->sc_rbus_iot;
	} else {
		bustag = sc->sc_memt;
		rbustag = sc->sc_rbus_memt;
	}
	if (status == 0) {
		bus_addr_t mask = size - 1;
		if (base != 0)
			mask = 0xffffffff;
		if ((*cf->cardbus_space_alloc)(cc, rbustag, base, size, mask,
		    size, busflags | flags, &base, &handle)) {
			panic("io alloc");
		}
	}
	pci_conf_write(pc, tag, reg, base);

	DPRINTF(("cardbus_mapreg_map: physaddr %lx\n", (unsigned long)base));

	if (tagp != 0)
		*tagp = bustag;
	if (handlep != 0)
		*handlep = handle;
	if (basep != 0)
		*basep = base;
	if (sizep != 0)
		*sizep = size;

	return (0);
}

/*
 * int cardbus_mapreg_unmap(struct cardbus_softc *sc, int func, int reg,
 *			    bus_space_tag_t tag, bus_space_handle_t handle,
 *			    bus_size_t size)
 *
 *   This function releases bus-space region and close memory or io
 *   window on the bridge.
 *
 *  Arguments:
 *   struct cardbus_softc *sc; the pointer to the device structure of cardbus.
 *   int func; the number of function on the device.
 *   int reg; the offset of BAR register.
 */
int
cardbus_mapreg_unmap(struct cardbus_softc *sc, int func, int reg,
    bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t size)
{
	cardbus_chipset_tag_t cc = sc->sc_cc;
	pci_chipset_tag_t pc = sc->sc_pc;
	cardbus_function_tag_t cf = sc->sc_cf;
	int st = 1;
	pcitag_t cardbustag;
	rbus_tag_t rbustag;

	if (sc->sc_iot == tag) {
		/* bus space is io space */
		DPRINTF(("%s: unmap i/o space\n", sc->sc_dev.dv_xname));
		rbustag = sc->sc_rbus_iot;
	} else if (sc->sc_memt == tag) {
		/* bus space is memory space */
		DPRINTF(("%s: unmap mem space\n", sc->sc_dev.dv_xname));
		rbustag = sc->sc_rbus_memt;
	} else
		return (1);

	cardbustag = pci_make_tag(pc, sc->sc_bus, sc->sc_device, func);

	pci_conf_write(pc, cardbustag, reg, 0);

	(*cf->cardbus_space_free)(cc, rbustag, handle, size);

	return (st);
}
@


1.14
log
@replace a bunch of BAR wrangling code with calls to the pci
code it was originally copied from.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.13 2010/03/27 21:40:13 jsg Exp $	*/
a33 1
#include <sys/device.h>
@


1.13
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.12 2010/03/27 20:04:03 jsg Exp $	*/
a57 176

STATIC int cardbus_io_find(pci_chipset_tag_t,
	       pcitag_t, int, pcireg_t, bus_addr_t *, bus_size_t *,
	       int *);
STATIC int cardbus_mem_find(pci_chipset_tag_t,
	       pcitag_t, int, pcireg_t, bus_addr_t *, bus_size_t *,
	       int *);

int
cardbus_mapreg_probe(pci_chipset_tag_t pc,
    pcitag_t tag, int reg, pcireg_t *typep)
{
	pcireg_t address, mask;
	int s;

	s = splhigh();
	address = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, 0xffffffff);
	mask = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, address);
	splx(s);

	if (mask == 0) /* unimplemented mapping register */
		return (0);

	if (typep)
		*typep = _PCI_MAPREG_TYPEBITS(address);
	return (1);
}

/*
 * STATIC int cardbus_io_find(pci_chipset_tag_t pc,
 *			      pcitag_t tag,
 *			      int reg, pcireg_t type, bus_addr_t *basep,
 *			      bus_size_t *sizep, int *flagsp)
 * This code is stolen from sys/dev/pci_map.c.
 */
STATIC int
cardbus_io_find(pci_chipset_tag_t pc,
    pcitag_t tag, int reg, pcireg_t type, bus_addr_t *basep,
    bus_size_t *sizep, int *flagsp)
{
	pcireg_t address, mask;
	int s;

	/* EXT ROM is able to map on memory space ONLY. */
	if (reg == CARDBUS_ROM_REG)
		return (1);

	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3)) {
		panic("cardbus_io_find: bad request");
	}

	/*
	 * Section 6.2.5.1, `Address Maps', tells us that:
	 *
	 * 1) The builtin software should have already mapped the device in a
	 * reasonable way.
	 *
	 * 2) A device which wants 2^n bytes of memory will hardwire the bottom
	 * n bits of the address to 0.  As recommended, we write all 1s and see
	 * what we get back.
	 */
	s = splhigh();
	address = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, 0xffffffff);
	mask = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, address);
	splx(s);

	if (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_IO) {
		printf("cardbus_io_find: expected type i/o, found mem\n");
		return (1);
	}

	if (PCI_MAPREG_IO_SIZE(mask) == 0) {
		printf("cardbus_io_find: void region\n");
		return (1);
	}

	if (basep != 0)
		*basep = PCI_MAPREG_IO_ADDR(address);
	if (sizep != 0)
		*sizep = PCI_MAPREG_IO_SIZE(mask);
	if (flagsp != 0)
		*flagsp = 0;

	return (0);
}

/*
 * STATIC int cardbus_mem_find(pci_chipset_tag_t pc,
 *			       pcitag_t tag,
 *			       int reg, pcireg_t type, bus_addr_t *basep,
 *			       bus_size_t *sizep, int *flagsp)
 * This code is stolen from sys/dev/pci_map.c.
 */
STATIC int
cardbus_mem_find(pci_chipset_tag_t pc,
    pcitag_t tag, int reg, pcireg_t type, bus_addr_t *basep,
    bus_size_t *sizep, int *flagsp)
{
	pcireg_t address, mask;
	int s;

	if (reg != CARDBUS_ROM_REG &&
	    (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))) {
		panic("cardbus_mem_find: bad request");
	}

	/*
	 * Section 6.2.5.1, `Address Maps', tells us that:
	 *
	 * 1) The builtin software should have already mapped the device in a
	 * reasonable way.
	 *
	 * 2) A device which wants 2^n bytes of memory will hardwire the bottom
	 * n bits of the address to 0.  As recommended, we write all 1s and see
	 * what we get back.
	 */
	s = splhigh();
	address = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, 0xffffffff);
	mask = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, address);
	splx(s);

	if (reg != CARDBUS_ROM_REG) {
		/* memory space BAR */

		if (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_MEM) {
			printf("cardbus_mem_find: expected type mem, "
			    "found i/o\n");
			return (1);
		}
		if (PCI_MAPREG_MEM_TYPE(address) != PCI_MAPREG_MEM_TYPE(type)) {
			printf("cardbus_mem_find: expected mem type %08x, "
			    "found %08x\n", PCI_MAPREG_MEM_TYPE(type),
			    PCI_MAPREG_MEM_TYPE(address));
			return (1);
		}
	}

	if (PCI_MAPREG_MEM_SIZE(mask) == 0) {
		printf("cardbus_mem_find: void region\n");
		return (1);
	}

	switch (PCI_MAPREG_MEM_TYPE(address)) {
	case PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_MEM_TYPE_32BIT_1M:
		break;
	case PCI_MAPREG_MEM_TYPE_64BIT:
		printf("cardbus_mem_find: 64-bit memory mapping register\n");
		return (1);
	default:
		printf("cardbus_mem_find: reserved mapping register type\n");
		return (1);
	}

	if (basep != 0)
		*basep = PCI_MAPREG_MEM_ADDR(address);
	if (sizep != 0)
		*sizep = PCI_MAPREG_MEM_SIZE(mask);
	if (flagsp != 0) {
		*flagsp =
#ifdef BUS_SPACE_MAP_PREFETCHABLE
		    PCI_MAPREG_MEM_PREFETCHABLE(address) ?
		      BUS_SPACE_MAP_PREFETCHABLE :
#endif
		0;
	}

	return (0);
}

d90 3
a93 3
		if (cardbus_io_find(pc, tag, reg, type, &base, &size,
		    &flags))
			status = 1;
a96 3
		if (cardbus_mem_find(pc, tag, reg, type, &base, &size,
		    &flags))
			status = 1;
@


1.12
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.11 2010/03/22 22:28:27 jsg Exp $	*/
d59 1
a59 1
STATIC int cardbus_io_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
d62 1
a62 1
STATIC int cardbus_mem_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
d67 1
a67 1
cardbus_mapreg_probe(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
d74 4
a77 4
	address = cardbus_conf_read(cc, cf, tag, reg);
	cardbus_conf_write(cc, cf, tag, reg, 0xffffffff);
	mask = cardbus_conf_read(cc, cf, tag, reg);
	cardbus_conf_write(cc, cf, tag, reg, address);
d89 2
a90 2
 * STATIC int cardbus_io_find(cardbus_chipset_tag_t cc,
 *			      cardbus_function_tag_t cf, pcitag_t tag,
d96 1
a96 1
cardbus_io_find(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
d122 4
a125 4
	address = cardbus_conf_read(cc, cf, tag, reg);
	cardbus_conf_write(cc, cf, tag, reg, 0xffffffff);
	mask = cardbus_conf_read(cc, cf, tag, reg);
	cardbus_conf_write(cc, cf, tag, reg, address);
d149 2
a150 2
 * STATIC int cardbus_mem_find(cardbus_chipset_tag_t cc,
 *			       cardbus_function_tag_t cf, pcitag_t tag,
d156 1
a156 1
cardbus_mem_find(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
d179 4
a182 4
	address = cardbus_conf_read(cc, cf, tag, reg);
	cardbus_conf_write(cc, cf, tag, reg, 0xffffffff);
	mask = cardbus_conf_read(cc, cf, tag, reg);
	cardbus_conf_write(cc, cf, tag, reg, address);
d250 1
d260 1
a260 1
	pcitag_t tag = cardbus_make_tag(cc, cf, sc->sc_bus,
d267 1
a267 1
		if (cardbus_io_find(cc, cf, tag, reg, type, &base, &size,
d273 1
a273 1
		if (cardbus_mem_find(cc, cf, tag, reg, type, &base, &size,
d288 1
a288 1
	cardbus_conf_write(cc, cf, tag, reg, base);
a299 1
	cardbus_free_tag(cc, cf, tag);
d322 1
d339 1
a339 1
	cardbustag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);
d341 1
a341 1
	cardbus_conf_write(cc, cf, cardbustag, reg, 0);
a343 2

	cardbus_free_tag(cc, cf, cardbustag);
@


1.11
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.10 2010/01/13 09:10:33 jsg Exp $	*/
d59 1
a59 1
STATIC int cardbus_io_find(pci_chipset_tag_t, cardbus_function_tag_t,
d62 1
a62 1
STATIC int cardbus_mem_find(pci_chipset_tag_t, cardbus_function_tag_t,
d67 1
a67 1
cardbus_mapreg_probe(pci_chipset_tag_t cc, cardbus_function_tag_t cf,
d89 1
a89 1
 * STATIC int cardbus_io_find(pci_chipset_tag_t cc,
d96 1
a96 1
cardbus_io_find(pci_chipset_tag_t cc, cardbus_function_tag_t cf,
d149 1
a149 1
 * STATIC int cardbus_mem_find(pci_chipset_tag_t cc,
d156 1
a156 1
cardbus_mem_find(pci_chipset_tag_t cc, cardbus_function_tag_t cf,
d249 1
a249 1
	pci_chipset_tag_t cc = sc->sc_cc;
d321 1
a321 1
	pci_chipset_tag_t cc = sc->sc_cc;
@


1.10
log
@As per NetBSD move HAYAKAWA Koichi's licenses to two clause.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.9 2009/07/23 15:09:41 kettenis Exp $	*/
d59 2
a60 2
STATIC int cardbus_io_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
	       cardbustag_t, int, cardbusreg_t, bus_addr_t *, bus_size_t *,
d62 2
a63 2
STATIC int cardbus_mem_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
	       cardbustag_t, int, cardbusreg_t, bus_addr_t *, bus_size_t *,
d67 2
a68 2
cardbus_mapreg_probe(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
    cardbustag_t tag, int reg, pcireg_t *typep)
d89 3
a91 3
 * STATIC int cardbus_io_find(cardbus_chipset_tag_t cc,
 *			      cardbus_function_tag_t cf, cardbustag_t tag,
 *			      int reg, cardbusreg_t type, bus_addr_t *basep,
d96 2
a97 2
cardbus_io_find(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
    cardbustag_t tag, int reg, cardbusreg_t type, bus_addr_t *basep,
d100 1
a100 1
	cardbusreg_t address, mask;
d149 3
a151 3
 * STATIC int cardbus_mem_find(cardbus_chipset_tag_t cc,
 *			       cardbus_function_tag_t cf, cardbustag_t tag,
 *			       int reg, cardbusreg_t type, bus_addr_t *basep,
d156 2
a157 2
cardbus_mem_find(cardbus_chipset_tag_t cc, cardbus_function_tag_t cf,
    cardbustag_t tag, int reg, cardbusreg_t type, bus_addr_t *basep,
d160 1
a160 1
	cardbusreg_t address, mask;
d235 1
a235 1
 * int cardbus_mapreg_map(struct cardbus_softc *, int, int, cardbusreg_t,
d246 1
a246 1
    cardbusreg_t type, int busflags, bus_space_tag_t *tagp,
d249 1
a249 1
	cardbus_chipset_tag_t cc = sc->sc_cc;
d259 1
a259 1
	cardbustag_t tag = cardbus_make_tag(cc, cf, sc->sc_bus,
d321 1
a321 1
	cardbus_chipset_tag_t cc = sc->sc_cc;
d324 1
a324 1
	cardbustag_t cardbustag;
@


1.9
log
@Remove unused code.

ok oga@@, jsg@@, blambert@@, zap zap zap deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.8 2007/09/17 20:29:47 miod Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by HAYAKAWA Koichi.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.8
log
@Un-staticize if option DDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.7 2006/07/31 11:06:27 mickey Exp $	*/
a351 52
}

/*
 * int cardbus_save_bar(cardbus_devfunc_t);
 *
 *   This function saves the Base Address Registers at the CardBus
 *   function denoted by the argument.
 */
int
cardbus_save_bar(cardbus_devfunc_t ct)
{
	cardbustag_t tag = Cardbus_make_tag(ct);
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	ct->ct_bar[0] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE0_REG);
	ct->ct_bar[1] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE1_REG);
	ct->ct_bar[2] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE2_REG);
	ct->ct_bar[3] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE3_REG);
	ct->ct_bar[4] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE4_REG);
	ct->ct_bar[5] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE5_REG);

	DPRINTF(("cardbus_save_bar: %x %x\n", ct->ct_bar[0], ct->ct_bar[1]));

	Cardbus_free_tag(ct, tag);

	return (0);
}

/*
 * int cardbus_restore_bar(cardbus_devfunc_t);
 *
 *   This function saves the Base Address Registers at the CardBus
 *   function denoted by the argument.
 */
int
cardbus_restore_bar(cardbus_devfunc_t ct)
{
	cardbustag_t tag = Cardbus_make_tag(ct);
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	cardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, ct->ct_bar[0]);
	cardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, ct->ct_bar[1]);
	cardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, ct->ct_bar[2]);
	cardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, ct->ct_bar[3]);
	cardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, ct->ct_bar[4]);
	cardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, ct->ct_bar[5]);

	Cardbus_free_tag(ct, tag);

	return (0);
@


1.7
log
@puc@@cardbus (only added (commented out) to whom has puc@@pci enabled)
tested on puc@@pci by fkr and meself on the cardbus.
still needs a bit more work but generally works.
deraadt@@ ok and some input from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.6 2006/06/21 11:27:03 fkr Exp $	*/
d55 3
d59 1
d64 1
a64 1
static int cardbus_io_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
d67 1
a67 1
static int cardbus_mem_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
d94 1
a94 1
 * static int cardbus_io_find(cardbus_chipset_tag_t cc,
d100 1
a100 1
static int
d154 1
a154 1
 * static int cardbus_mem_find(cardbus_chipset_tag_t cc,
d160 1
a160 1
static int
@


1.6
log
@removal of '#ifdef rbus ... #else ...' directives, we use rbus in all
cases anyways, so we might as well remove code (the !rbus case) thats been
dead throughout the last years and just use the rbus code without ifdefs.

brad, miod "I am all for this diff"
ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.5 2005/09/13 18:44:38 fgsch Exp $	*/
d66 22
@


1.5
log
@knf; no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.4 2004/07/04 23:10:48 brad Exp $	*/
a230 1
#if rbus
a231 1
#endif
a248 1
#if rbus
a249 1
#endif
a254 1
#if rbus
a255 1
#endif
a257 1
#if rbus
a264 12
#else
		bus_addr_t start = 0x8300;
		bus_addr_t end = 0x8400;
		if (base != 0) {
			bus_addr_t start = base;
			bus_addr_t end = base + size;
		}
		if (bus_space_alloc(bustag, start, end, size, size, 0, 0,
		    &base, &handle)) {
			panic("io alloc");
		}
#endif
a303 1
#if rbus
a315 1
#endif
a320 1
#if rbus
a321 1
#endif
@


1.4
log
@- two typos, stallen -> stolen
- cast base correctly for format string

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.3 2003/08/27 20:59:15 mickey Exp $ */
a36 1
#include <sys/types.h>
d61 2
a62 2
				cardbustag_t, int, cardbusreg_t,
				bus_addr_t *, bus_size_t *, int *);
d64 2
a65 2
				 cardbustag_t, int, cardbusreg_t,
				 bus_addr_t *, bus_size_t *, int *);
d75 3
a77 9
cardbus_io_find(cc, cf, tag, reg, type, basep, sizep, flagsp)
	cardbus_chipset_tag_t cc;
	cardbus_function_tag_t cf;
	cardbustag_t tag;
	int reg;
	cardbusreg_t type;
	bus_addr_t *basep;
	bus_size_t *sizep;
	int *flagsp;
d83 2
a84 3
	if (reg == CARDBUS_ROM_REG) {
		return 1;
	}
d86 1
a86 1
	if(reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3)) {
d109 1
a109 1
		return 1;
d114 1
a114 1
		return 1;
d117 1
a117 1
	if (basep != 0) {
d119 1
a119 2
	}
	if (sizep != 0) {
d121 1
a121 2
	}
	if (flagsp != 0) {
a122 1
	}
d124 1
a124 1
	return 0;
a126 2


d135 3
a137 9
cardbus_mem_find(cc, cf, tag, reg, type, basep, sizep, flagsp)
	cardbus_chipset_tag_t cc;
	cardbus_function_tag_t cf;
	cardbustag_t tag;
	int reg;
	cardbusreg_t type;
	bus_addr_t *basep;
	bus_size_t *sizep;
	int *flagsp;
d142 1
a142 1
	if (reg != CARDBUS_ROM_REG && 
d168 3
a170 2
			printf("cardbus_mem_find: expected type mem, found i/o\n");
			return 1;
d173 2
a174 2
			printf("cardbus_mem_find: expected mem type %08x, found %08x\n",
			    PCI_MAPREG_MEM_TYPE(type),
d176 1
a176 1
			return 1;
d182 1
a182 1
		return 1;
d191 1
a191 1
		return 1;
d194 1
a194 1
		return 1;
d197 1
a197 1
	if (basep != 0) {
d199 1
a199 2
	}
	if (sizep != 0) {
a200 1
	}
d209 2
a210 2
	
	return 0;
a212 3



d224 3
a226 8
cardbus_mapreg_map(sc, func, reg, type, busflags, tagp, handlep, basep, sizep)
	struct cardbus_softc *sc;
	int func, reg, busflags;
	cardbusreg_t type;
	bus_space_tag_t *tagp;
	bus_space_handle_t *handlep;
	bus_addr_t *basep;
	bus_size_t *sizep;
d240 2
a241 1
	cardbustag_t tag = cardbus_make_tag(cc, cf, sc->sc_bus, sc->sc_device, func);
d247 2
a248 1
		if (cardbus_io_find(cc, cf, tag, reg, type, &base, &size, &flags)) {
a249 1
		}
d255 2
a256 1
		if (cardbus_mem_find(cc, cf, tag, reg, type, &base, &size, &flags)){
a257 1
		}
d266 1
a266 1
		if (base != 0) {
a267 1
		}
d279 2
a280 1
		if (bus_space_alloc(bustag, start, end, size, size, 0, 0, &base, &handle)) {
d289 1
a289 1
	if (tagp != 0) {
d291 1
a291 2
	}
	if (handlep != 0) {
d293 1
a293 2
	}
	if (basep != 0) {
d295 1
a295 2
	}
	if (sizep != 0) {
a296 1
	}
d299 1
a299 1
	return 0;
a301 4




d316 2
a317 6
cardbus_mapreg_unmap(sc, func, reg, tag, handle, size)
	struct cardbus_softc *sc;
	int func, reg;
	bus_space_tag_t tag;
	bus_space_handle_t handle;
	bus_size_t size;
d334 2
a335 3
	} else {
		return 1;
	}
d348 1
a348 1
	return st;
a350 4




d357 2
a358 2
int cardbus_save_bar(ct)
	cardbus_devfunc_t ct;
d375 1
a375 1
	return 0;
a377 2


d384 2
a385 2
int cardbus_restore_bar(ct)
	cardbus_devfunc_t ct;
d400 1
a400 1
	return 0;
@


1.3
log
@this bit is defined as prefetchable and not cachable and thus rename and use appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.2 2002/03/14 01:26:52 millert Exp $ */
d73 1
a73 1
 * This code is stallen from sys/dev/pci_map.c.
d145 1
a145 1
 * This code is stallen from sys/dev/pci_map.c.
d314 1
a314 1
	DPRINTF(("cardbus_mapreg_map: physaddr %lx\n", base));
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.1 2000/04/08 05:50:52 aaron Exp $ */
d222 6
a227 1
		*flagsp = PCI_MAPREG_MEM_CACHEABLE(address);
@


1.1
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d61 1
a61 1
static int cardbus_io_find __P((cardbus_chipset_tag_t, cardbus_function_tag_t,
d63 2
a64 2
				bus_addr_t *, bus_size_t *, int *));
static int cardbus_mem_find __P((cardbus_chipset_tag_t, cardbus_function_tag_t,
d66 1
a66 1
				 bus_addr_t *, bus_size_t *, int *));
@


1.1.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.1 2000/04/08 05:50:52 aaron Exp $ */
d61 1
a61 1
static int cardbus_io_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
d63 2
a64 2
				bus_addr_t *, bus_size_t *, int *);
static int cardbus_mem_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
d66 1
a66 1
				 bus_addr_t *, bus_size_t *, int *);
@


1.1.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.1 2000/04/08 05:50:52 aaron Exp $ */
@


1.1.8.2
log
@cardbus too got skipped by cvs for some reason
@
text
@d1 1
a1 1
/*	$OpenBSD: cardbus_map.c,v 1.1.8.1 2001/05/14 22:23:09 niklas Exp $ */
d61 1
a61 1
static int cardbus_io_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
d63 2
a64 2
				bus_addr_t *, bus_size_t *, int *);
static int cardbus_mem_find(cardbus_chipset_tag_t, cardbus_function_tag_t,
d66 1
a66 1
				 bus_addr_t *, bus_size_t *, int *);
@


1.1.8.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d222 1
a222 6
		*flagsp =
#ifdef BUS_SPACE_MAP_PREFETCHABLE
		    PCI_MAPREG_MEM_PREFETCHABLE(address) ?
		      BUS_SPACE_MAP_PREFETCHABLE :
#endif
		0;
@


