head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.2
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.4
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.7.0.8
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.20;
commitid	RlO92XR575sygHqm;

1.20
date	2016.08.24.09.31.56;	author dlg;	state Exp;
branches;
next	1.19;
commitid	bOHrwaZkgMMKmHmR;

1.19
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.18;
commitid	p4LJxGKbi0BU2cG6;

1.18
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.17;
commitid	MyKPm9Q3dQu92BiX;

1.17
date	2014.12.19.05.48.36;	author tedu;	state Exp;
branches;
next	1.16;
commitid	JuxA5gwod4vfhCes;

1.16
date	2013.10.30.08.47.20;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2010.08.25.21.37.59;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.13.09.10.33;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.03.21.44.26;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.24.15.50.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.21.17.36.52;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.16.13.46.36;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.17.20.29.47;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.19.19.05.39;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.25.00.13.29;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.18.04.16;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.04.16.59.31;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.21.10.07.33;	author jmc;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.08.05.50.52;	author aaron;	state Exp;
branches
	1.1.8.1
	1.1.12.1;
next	;

1.1.8.1
date	2001.05.14.22.23.11;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2002.03.29.23.39.33;	author niklas;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	1.1.8.4;

1.1.8.4
date	2004.06.05.23.12.37;	author niklas;	state Exp;
branches;
next	;

1.1.12.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@/*	$OpenBSD: cardslot.c,v 1.20 2016/08/24 09:31:56 dlg Exp $	*/
/*	$NetBSD: cardslot.c,v 1.9 2000/03/22 09:35:06 haya Exp $	*/

/*
 * Copyright (c) 1999 and 2000
 *       HAYAKAWA Koichi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/kthread.h>
#include <sys/pool.h>
#include <sys/task.h>

#include <dev/cardbus/cardslotvar.h>
#include <dev/cardbus/cardbusvar.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciachip.h>
#include <dev/ic/i82365var.h>

#if defined CARDSLOT_DEBUG
#define STATIC
#define DPRINTF(a) printf a
#else
#ifdef DDB
#define STATIC
#else
#define STATIC static
#endif
#define DPRINTF(a)
#endif

STATIC void cardslotattach(struct device *, struct device *, void *);

STATIC int cardslotmatch(struct device *, void *, void *);
STATIC void cardslot_event(void *arg);
STATIC void cardslot_process_event(struct cardslot_softc *);

STATIC int cardslot_cb_print(void *aux, const char *pcic);
STATIC int cardslot_16_print(void *, const char *);
STATIC int cardslot_16_submatch(struct device *, void *,void *);

struct cfattach cardslot_ca = {
	sizeof(struct cardslot_softc), cardslotmatch, cardslotattach
};

struct cfdriver cardslot_cd = {
	NULL, "cardslot", DV_DULL
};

struct pool cardsloteventpool;

STATIC int
cardslotmatch(struct device *parent, void *match, void *aux)
{
	struct cardslot_attach_args *caa = aux;

	if (caa->caa_cb_attach == NULL && caa->caa_16_attach == NULL) {
		/* Neither CardBus nor 16-bit PCMCIA are defined. */
		return (0);
	}

	return (1);
}

STATIC void
cardslotattach(struct device *parent, struct device *self, void *aux)
{
	struct cardslot_softc *sc = (struct cardslot_softc *)self;
	struct cardslot_attach_args *caa = aux;

	struct cbslot_attach_args *cba = caa->caa_cb_attach;
	struct pcmciabus_attach_args *pa = caa->caa_16_attach;

	struct cardbus_softc *csc = NULL;
	struct pcmcia_softc *psc = NULL;

	if (cardsloteventpool.pr_size == 0) {
		pool_init(&cardsloteventpool, sizeof(struct cardslot_event),
		    0, IPL_BIO, 0, "cardslot", NULL);
	}

	sc->sc_slot = sc->sc_dev.dv_unit;
	sc->sc_cb_softc = NULL;
	sc->sc_16_softc = NULL;
	SIMPLEQ_INIT(&sc->sc_events);
	task_set(&sc->sc_event_task, cardslot_event, sc);

	printf(" slot %d flags %x\n", sc->sc_slot,
	    sc->sc_dev.dv_cfdata->cf_flags);

	DPRINTF(("%s attaching CardBus bus...\n", sc->sc_dev.dv_xname));
	if (cba != NULL) {
		if ((csc = (void *)config_found(self, cba,
		    cardslot_cb_print)) != NULL) {
			/* cardbus found */
			DPRINTF(("cardslotattach: found cardbus on %s\n",
			    sc->sc_dev.dv_xname));
			sc->sc_cb_softc = csc;
		}
	}

	if (pa != NULL) {
		if ((psc = (void *)config_found_sm(self, pa, cardslot_16_print,
		    cardslot_16_submatch)) != NULL) {
			/* pcmcia 16-bit bus found */
			DPRINTF(("cardslotattach: found 16-bit pcmcia bus\n"));
			sc->sc_16_softc = psc;
			/* XXX: dirty.  This code should be removed
			 * to achieve MI
			 */
			caa->caa_ph->pcmcia = (struct device *)psc;
		}
	}

	if (csc && (csc->sc_cf->cardbus_ctrl)(csc->sc_cc, CARDBUS_CD)) {
		DPRINTF(("cardslotattach: CardBus card found\n"));
		/* attach deferred */
		cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_CB);
	}

	if (psc && (psc->pct->card_detect)(psc->pch)) {
		DPRINTF(("cardbusattach: 16-bit card found\n"));
		/* attach deferred */
		cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_16);
	}
}

STATIC int
cardslot_cb_print(void *aux, const char *pnp)
{
	struct cbslot_attach_args *cba = aux;

	if (pnp)
		printf("cardbus at %s subordinate bus %d", pnp, cba->cba_bus);

	return (UNCONF);
}

STATIC int
cardslot_16_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != 0)
		return (0);

	if (cf->cf_loc[0] == -1)
		return ((*cf->cf_attach->ca_match)(parent, cf, aux));

	return (0);
}

STATIC int
cardslot_16_print(void *arg, const char *pnp)
{
	if (pnp)
		printf("pcmciabus at %s", pnp);

	return (UNCONF);
}

/*
 * void cardslot_event_throw(struct cardslot_softc *sc, int ev)
 *
 *   This function throws an event to the event handler.  If the state
 *   of a slot is changed, it should be noticed using this function.
 */
void
cardslot_event_throw(struct cardslot_softc *sc, int ev)
{
	struct cardslot_event *ce;
	int s;

	DPRINTF(("cardslot_event_throw: an event %s comes\n",
	    ev == CARDSLOT_EVENT_INSERTION_CB ? "CardBus Card inserted" :
	    ev == CARDSLOT_EVENT_INSERTION_16 ? "16-bit Card inserted" :
	    ev == CARDSLOT_EVENT_REMOVAL_CB ? "CardBus Card removed" :
	    ev == CARDSLOT_EVENT_REMOVAL_16 ? "16-bit Card removed" : "???"));

	ce = pool_get(&cardsloteventpool, PR_NOWAIT);
	if (ce == NULL)
		return;
	ce->ce_type = ev;

	s = spltty();
	SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);
	splx(s);

	task_add(systq, &sc->sc_event_task);
}

/*
 * STATIC void cardslot_event(void *arg)
 *
 *   This function is the main routine handing cardslot events such as
 *   insertions and removals.
 *
 */
STATIC void
cardslot_event(void *arg1)
{
	struct cardslot_softc *sc = arg1;

	while (!SIMPLEQ_EMPTY(&sc->sc_events))
		cardslot_process_event(sc);
}


STATIC void
cardslot_process_event(struct cardslot_softc *sc)
{
	struct cardslot_event *ce;
	int s, ev;

	s = spltty();
	if ((ce = SIMPLEQ_FIRST(&sc->sc_events)) == NULL) {
		splx(s);
		return;
	}
	SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);

	if (IS_CARDSLOT_INSERT_REMOVE_EV(ce->ce_type)) {
		/* Chattering suppression */
		static int antonym_ev[4] = {
			CARDSLOT_EVENT_REMOVAL_16,
			CARDSLOT_EVENT_INSERTION_16,
			CARDSLOT_EVENT_REMOVAL_CB,
			CARDSLOT_EVENT_INSERTION_CB
		};

		while (1) {
			struct cardslot_event *ce1, *ce2;

			if ((ce1 = SIMPLEQ_FIRST(&sc->sc_events)) ==
			    NULL)
				break;
			if (ce1->ce_type != antonym_ev[ce->ce_type])
				break;
			if ((ce2 = SIMPLEQ_NEXT(ce1, ce_q)) == NULL)
				break;
			if (ce2->ce_type == ce->ce_type) {
				SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);
				pool_put(&cardsloteventpool, ce1);
				SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);
				pool_put(&cardsloteventpool, ce2);
			}
		}
	}
	splx(s);

	ev = ce->ce_type;
	pool_put(&cardsloteventpool, ce);

	switch (ev) {
	case CARDSLOT_EVENT_INSERTION_CB:
		if ((CARDSLOT_CARDTYPE(sc->sc_status) ==
		     CARDSLOT_STATUS_CARD_CB) ||
		    (CARDSLOT_CARDTYPE(sc->sc_status) ==
		     CARDSLOT_STATUS_CARD_16)) {
			if (CARDSLOT_WORK(sc->sc_status) ==
			    CARDSLOT_STATUS_WORKING) {
				/* A card has already been inserted
				 * and works.
				 */
				break;
			}
		}

		if (sc->sc_cb_softc) {
			CARDSLOT_SET_CARDTYPE(sc->sc_status,
			    CARDSLOT_STATUS_CARD_CB);
			if (cardbus_attach_card(sc->sc_cb_softc) > 0) {
				/* At least one function works */
				CARDSLOT_SET_WORK(sc->sc_status,
				    CARDSLOT_STATUS_WORKING);
			} else {
				/* No functions work or this card is
				 * not known
				 */
				CARDSLOT_SET_WORK(sc->sc_status,
				    CARDSLOT_STATUS_NOTWORK);
			}
		} else {
			printf("%s: CardBus support disabled\n",
			    sc->sc_dev.dv_xname);
		}
		break;

	case CARDSLOT_EVENT_INSERTION_16:
		if ((CARDSLOT_CARDTYPE(sc->sc_status) ==
		     CARDSLOT_STATUS_CARD_CB) ||
		    (CARDSLOT_CARDTYPE(sc->sc_status) ==
		     CARDSLOT_STATUS_CARD_16)) {
			if (CARDSLOT_WORK(sc->sc_status) ==
			    CARDSLOT_STATUS_WORKING) {
				/* A card has already been inserted
				 * and works.
				 */
				break;
			}
		}
		if (sc->sc_16_softc) {
			CARDSLOT_SET_CARDTYPE(sc->sc_status,
			    CARDSLOT_STATUS_CARD_16);
			if (pcmcia_card_attach(
			    (struct device *)sc->sc_16_softc)) {
				/* Do not attach */
				CARDSLOT_SET_WORK(sc->sc_status,
				    CARDSLOT_STATUS_NOTWORK);
			} else {
				/* working */
				CARDSLOT_SET_WORK(sc->sc_status,
				    CARDSLOT_STATUS_WORKING);
			}
		} else {
			panic("no 16-bit pcmcia on %s",
			    sc->sc_dev.dv_xname);
		}
		break;

	case CARDSLOT_EVENT_REMOVAL_CB:
		if (CARDSLOT_CARDTYPE(sc->sc_status) ==
		    CARDSLOT_STATUS_CARD_CB) {
			/* CardBus card has not been inserted. */
			if (CARDSLOT_WORK(sc->sc_status) ==
			    CARDSLOT_STATUS_WORKING) {
				cardbus_detach_card(sc->sc_cb_softc);
				CARDSLOT_SET_WORK(sc->sc_status,
				    CARDSLOT_STATUS_NOTWORK);
				CARDSLOT_SET_WORK(sc->sc_status,
				    CARDSLOT_STATUS_CARD_NONE);
			}
			CARDSLOT_SET_CARDTYPE(sc->sc_status,
			    CARDSLOT_STATUS_CARD_NONE);
		} else if (CARDSLOT_CARDTYPE(sc->sc_status) !=
		    CARDSLOT_STATUS_CARD_16) {
			/* Unknown card... */
			CARDSLOT_SET_CARDTYPE(sc->sc_status,
			    CARDSLOT_STATUS_CARD_NONE);
		}
		CARDSLOT_SET_WORK(sc->sc_status,
		    CARDSLOT_STATUS_NOTWORK);
		break;

	case CARDSLOT_EVENT_REMOVAL_16:
		DPRINTF(("%s: removal event\n", sc->sc_dev.dv_xname));
		if (CARDSLOT_CARDTYPE(sc->sc_status) !=
		    CARDSLOT_STATUS_CARD_16) {
			/* 16-bit card has not been inserted. */
			break;
		}
		if ((sc->sc_16_softc != NULL) &&
		    (CARDSLOT_WORK(sc->sc_status) ==
		     CARDSLOT_STATUS_WORKING)) {
			struct pcmcia_softc *psc = sc->sc_16_softc;

			pcmcia_card_deactivate((struct device *)psc);
			pcmcia_chip_socket_disable(psc->pct, psc->pch);
			pcmcia_card_detach((struct device *)psc,
			    DETACH_FORCE);
		}
		CARDSLOT_SET_CARDTYPE(sc->sc_status,
		    CARDSLOT_STATUS_CARD_NONE);
		CARDSLOT_SET_WORK(sc->sc_status,
		    CARDSLOT_STATUS_NOTWORK);
		break;

	default:
		panic("cardslot_event_thread: unknown event %d", ev);
	}
}
@


1.20
log
@pool_setipl for cardbus and drm pools.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.19 2015/03/14 03:38:47 jsg Exp $	*/
d106 1
a106 2
		    0, 0, 0, "cardslot", NULL);
		pool_setipl(&cardsloteventpool, IPL_BIO);
@


1.19
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.18 2015/01/27 03:17:36 dlg Exp $	*/
d104 1
a104 1
	if (cardsloteventpool.pr_size == 0)
d107 2
@


1.18
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.17 2014/12/19 05:48:36 tedu Exp $	*/
a39 2

#include <machine/bus.h>
@


1.17
log
@if you really must look inside the pool to decide if you've called
pool_init already, the pr_size field is the least worst field to peek at.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.16 2013/10/30 08:47:20 mpi Exp $	*/
d64 1
a64 1
STATIC void cardslot_event(void *arg1, void *arg2);
d114 1
a114 1
	task_set(&sc->sc_event_task, cardslot_event, sc, NULL);
d228 1
a228 1
cardslot_event(void *arg1, void *arg2)
@


1.16
log
@Replace workqs with tasks.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.15 2013/05/30 16:15:01 deraadt Exp $	*/
d106 1
a106 1
	if (cardsloteventpool.pr_align == 0)
@


1.15
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.14 2010/08/25 21:37:59 kettenis Exp $	*/
d39 1
a39 1
#include <sys/workq.h>
d65 1
d114 1
d217 1
a217 1
	workq_add_task(NULL, 0, cardslot_event, sc, NULL);
d231 9
@


1.14
log
@Make CardBus ral(4) suspend and resume properly on machines that keep the
CardBus bridge powered up during suspend.  Step zero on the long road
towards fully suspending CardBus on all machines.

ok deraadt@@, damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.13 2010/01/13 09:10:33 jsg Exp $	*/
d71 1
a71 2
	sizeof(struct cardslot_softc), cardslotmatch, cardslotattach,
	NULL, config_activate_children
@


1.13
log
@As per NetBSD move HAYAKAWA Koichi's licenses to two clause.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.12 2008/12/03 21:44:26 ray Exp $	*/
d71 2
a72 1
	sizeof(struct cardslot_softc), cardslotmatch, cardslotattach
@


1.12
log
@Get size of the struct cardslot_event, not the function cardslot_event.

Found by pcc.

OK deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.11 2008/11/24 15:50:44 deraadt Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by HAYAKAWA Koichi.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.11
log
@use workq instead of crafting our own kthread, since the tasks being done
are fairly small.  tested by a few, and kettenis says he will test it sooner
if it is commited...
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.10 2007/12/21 17:36:52 kettenis Exp $	*/
d111 2
a112 2
		pool_init(&cardsloteventpool, sizeof(cardslot_event), 0, 0, 0,
		    "cardslot", NULL);
@


1.10
log
@Don't panic if someone inserts a CardBus slot for which we disabled CardBus
support; print a properly formatted message instead.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.9 2007/12/16 13:46:36 kettenis Exp $	*/
d43 2
d69 1
a69 2
STATIC void create_slot_manager(void *);
STATIC void cardslot_event_thread(void *arg);
d83 2
d110 4
a117 1
	sc->sc_th_enable = 0;
a145 3
	if (csc != NULL || psc != NULL)
		kthread_create_deferred(create_slot_manager, (void *)sc);

a192 15
STATIC void
create_slot_manager(void *arg)
{
	struct cardslot_softc *sc = (struct cardslot_softc *)arg;

	sc->sc_th_enable = 1;

	if (kthread_create(cardslot_event_thread, sc, &sc->sc_event_thread,
	    "%s", sc->sc_dev.dv_xname)) {
		printf("%s: unable to create event thread for slot %d\n",
		    sc->sc_dev.dv_xname, sc->sc_slot);
		panic("create_slot_manager");
	}
}

d203 1
d211 3
a213 5
	if ((ce = (struct cardslot_event *)malloc(sizeof(struct cardslot_event),
	    M_TEMP, M_NOWAIT)) == NULL) {
		panic("cardslot_event");
	}

d216 3
a218 5
	{
		int s = spltty();
		SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);
		splx(s);
	}
d220 1
a220 1
	wakeup(&sc->sc_events);
d224 1
a224 1
 * STATIC void cardslot_event_thread(void *arg)
d231 1
a231 1
cardslot_event_thread(void *arg)
d233 1
a233 1
	struct cardslot_softc *sc = arg;
d235 4
a238 14
	int s;
	static int antonym_ev[4] = {
		CARDSLOT_EVENT_REMOVAL_16, CARDSLOT_EVENT_INSERTION_16,
		CARDSLOT_EVENT_REMOVAL_CB, CARDSLOT_EVENT_INSERTION_CB
	};

	while (sc->sc_th_enable) {
		s = spltty();
		if ((ce = SIMPLEQ_FIRST(&sc->sc_events)) == NULL) {
			splx(s);
			(void) tsleep(&sc->sc_events, PWAIT, "cardslotev", 0);
			continue;
		}
		SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);
d240 15
d256 12
a267 21
		if (IS_CARDSLOT_INSERT_REMOVE_EV(ce->ce_type)) {
			/* Chattering suppression */
			s = spltty();
			while (1) {
				struct cardslot_event *ce1, *ce2;

				if ((ce1 = SIMPLEQ_FIRST(&sc->sc_events)) ==
				    NULL)
					break;
				if (ce1->ce_type != antonym_ev[ce->ce_type])
					break;
				if ((ce2 = SIMPLEQ_NEXT(ce1, ce_q)) == NULL)
					break;
				if (ce2->ce_type == ce->ce_type) {
					SIMPLEQ_REMOVE_HEAD(&sc->sc_events,
					    ce_q);
					free(ce1, M_TEMP);
					SIMPLEQ_REMOVE_HEAD(&sc->sc_events,
					    ce_q);
					free(ce2, M_TEMP);
				}
a268 1
			splx(s);
d270 5
d276 12
a287 13
		switch (ce->ce_type) {
		case CARDSLOT_EVENT_INSERTION_CB:
			if ((CARDSLOT_CARDTYPE(sc->sc_status) ==
			     CARDSLOT_STATUS_CARD_CB) ||
			    (CARDSLOT_CARDTYPE(sc->sc_status) ==
			     CARDSLOT_STATUS_CARD_16)) {
				if (CARDSLOT_WORK(sc->sc_status) ==
				    CARDSLOT_STATUS_WORKING) {
					/* A card has already been inserted
					 * and works.
					 */
					break;
				}
d289 1
d291 7
a297 14
			if (sc->sc_cb_softc) {
				CARDSLOT_SET_CARDTYPE(sc->sc_status,
				    CARDSLOT_STATUS_CARD_CB);
				if (cardbus_attach_card(sc->sc_cb_softc) > 0) {
					/* At least one function works */
					CARDSLOT_SET_WORK(sc->sc_status,
					    CARDSLOT_STATUS_WORKING);
				} else {
					/* No functions work or this card is
					 * not known
					 */
					CARDSLOT_SET_WORK(sc->sc_status,
					    CARDSLOT_STATUS_NOTWORK);
				}
d299 5
a303 2
				printf("%s: CardBus support disabled\n",
				    sc->sc_dev.dv_xname);
d305 5
d311 11
a321 14
			break;

		case CARDSLOT_EVENT_INSERTION_16:
			if ((CARDSLOT_CARDTYPE(sc->sc_status) ==
			     CARDSLOT_STATUS_CARD_CB) ||
			    (CARDSLOT_CARDTYPE(sc->sc_status) ==
			     CARDSLOT_STATUS_CARD_16)) {
				if (CARDSLOT_WORK(sc->sc_status) ==
				    CARDSLOT_STATUS_WORKING) {
					/* A card has already been inserted
					 * and works.
					 */
					break;
				}
d323 9
a331 13
			if (sc->sc_16_softc) {
				CARDSLOT_SET_CARDTYPE(sc->sc_status,
				    CARDSLOT_STATUS_CARD_16);
				if (pcmcia_card_attach(
				    (struct device *)sc->sc_16_softc)) {
					/* Do not attach */
					CARDSLOT_SET_WORK(sc->sc_status,
					    CARDSLOT_STATUS_NOTWORK);
				} else {
					/* working */
					CARDSLOT_SET_WORK(sc->sc_status,
					    CARDSLOT_STATUS_WORKING);
				}
d333 3
a335 2
				panic("no 16-bit pcmcia on %s",
				    sc->sc_dev.dv_xname);
d337 5
d343 10
a352 20
			break;

		case CARDSLOT_EVENT_REMOVAL_CB:
			if (CARDSLOT_CARDTYPE(sc->sc_status) ==
			    CARDSLOT_STATUS_CARD_CB) {
				/* CardBus card has not been inserted. */
				if (CARDSLOT_WORK(sc->sc_status) ==
				    CARDSLOT_STATUS_WORKING) {
					cardbus_detach_card(sc->sc_cb_softc);
					CARDSLOT_SET_WORK(sc->sc_status,
					    CARDSLOT_STATUS_NOTWORK);
					CARDSLOT_SET_WORK(sc->sc_status,
					    CARDSLOT_STATUS_CARD_NONE);
				}
				CARDSLOT_SET_CARDTYPE(sc->sc_status,
				    CARDSLOT_STATUS_CARD_NONE);
			} else if (CARDSLOT_CARDTYPE(sc->sc_status) !=
			    CARDSLOT_STATUS_CARD_16) {
				/* Unknown card... */
				CARDSLOT_SET_CARDTYPE(sc->sc_status,
a354 21
			CARDSLOT_SET_WORK(sc->sc_status,
			    CARDSLOT_STATUS_NOTWORK);
			break;

		case CARDSLOT_EVENT_REMOVAL_16:
			DPRINTF(("%s: removal event\n", sc->sc_dev.dv_xname));
			if (CARDSLOT_CARDTYPE(sc->sc_status) !=
			    CARDSLOT_STATUS_CARD_16) {
				/* 16-bit card has not been inserted. */
				break;
			}
			if ((sc->sc_16_softc != NULL) &&
			    (CARDSLOT_WORK(sc->sc_status) ==
			     CARDSLOT_STATUS_WORKING)) {
				struct pcmcia_softc *psc = sc->sc_16_softc;

				pcmcia_card_deactivate((struct device *)psc);
				pcmcia_chip_socket_disable(psc->pct, psc->pch);
				pcmcia_card_detach((struct device *)psc,
				    DETACH_FORCE);
			}
d357 15
a371 2
			CARDSLOT_SET_WORK(sc->sc_status,
			    CARDSLOT_STATUS_NOTWORK);
d373 16
d390 2
a391 5
		default:
			panic("cardslot_event_thread: unknown event %d",
			    ce->ce_type);
		}
		free(ce, M_TEMP);
a392 7

	sc->sc_event_thread = NULL;

	/* In case the parent device is waiting for us to exit. */
	wakeup(sc);

	kthread_exit(0);
@


1.9
log
@Don't crash if we only try to attach pcmcia(4).

ok jsing@@, fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.8 2007/09/17 20:29:47 miod Exp $	*/
d321 2
a322 1
				panic("no cardbus on %s", sc->sc_dev.dv_xname);
@


1.8
log
@Un-staticize if option DDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.7 2005/09/19 19:05:39 fgsch Exp $	*/
d104 2
a105 2
	struct cardbus_softc *csc;
	struct pcmcia_softc *psc;
@


1.7
log
@knf.
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.6 2004/07/25 00:13:29 brad Exp $	*/
d56 3
d60 1
d67 2
a68 2
static void create_slot_manager(void *);
static void cardslot_event_thread(void *arg);
d71 2
a72 2
static int cardslot_16_print(void *, const char *);
static int cardslot_16_submatch(struct device *, void *,void *);
d167 1
a167 1
static int
d181 1
a181 1
static int
d190 1
a190 1
static void
d239 1
a239 1
 * static void cardslot_event_thread(void *arg)
d245 1
a245 1
static void
@


1.6
log
@typo, enevt -> event
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.5 2004/07/15 18:04:16 brad Exp $ */
a59 2


a73 1
#ifndef __NetBSD_Version__
a76 2
#endif

d79 1
a79 4
cardslotmatch(parent, match, aux)
     struct device *parent;
     void *match;
     void *aux;
d81 1
a81 1
  struct cardslot_attach_args *caa = aux;
d83 4
a86 4
  if (caa->caa_cb_attach == NULL && caa->caa_16_attach == NULL) {
    /* Neither CardBus nor 16-bit PCMCIA are defined. */
    return 0;
  }
d88 1
a88 1
  return 1;
d91 5
d97 2
d100 2
a101 8
STATIC void
cardslotattach(parent, self, aux)
     struct device *parent;
     struct device *self;
     void *aux;
{
  struct cardslot_softc *sc = (struct cardslot_softc *)self;
  struct cardslot_attach_args *caa = aux;
d103 19
a121 2
  struct cbslot_attach_args *cba = caa->caa_cb_attach;
  struct pcmciabus_attach_args *pa = caa->caa_16_attach;
d123 12
a134 2
  struct cardbus_softc *csc;
  struct pcmcia_softc *psc;
d136 2
a137 43
  sc->sc_slot = sc->sc_dev.dv_unit;
  sc->sc_cb_softc = NULL;
  sc->sc_16_softc = NULL;
  SIMPLEQ_INIT(&sc->sc_events);
  sc->sc_th_enable = 0;

  printf(" slot %d flags %x\n", sc->sc_slot, sc->sc_dev.dv_cfdata->cf_flags);

  DPRINTF(("%s attaching CardBus bus...\n", sc->sc_dev.dv_xname));
  if (cba != NULL) {
    if (NULL != (csc = (void *)config_found(self, cba, cardslot_cb_print))) {
      /* cardbus found */
      DPRINTF(("cardslotattach: found cardbus on %s\n", sc->sc_dev.dv_xname));
      sc->sc_cb_softc = csc;
    }
  }

  if (pa != NULL) {
    if (NULL != (psc = (void *)config_found_sm(self, pa, cardslot_16_print, 
				       cardslot_16_submatch))) {
      /* pcmcia 16-bit bus found */
      DPRINTF(("cardslotattach: found 16-bit pcmcia bus\n"));
      sc->sc_16_softc = psc;
      /* XXX: dirty.  This code should be removed to achieve MI */
      caa->caa_ph->pcmcia = (struct device *)psc;
    }
  }

  if (csc != NULL || psc != NULL)
    kthread_create_deferred(create_slot_manager, (void *)sc);

  if (csc && (csc->sc_cf->cardbus_ctrl)(csc->sc_cc, CARDBUS_CD)) {
    DPRINTF(("cardslotattach: CardBus card found\n"));
    /* attach deferred */
    cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_CB);
  }

  if (psc && (psc->pct->card_detect)(psc->pch)) {
    DPRINTF(("cardbusattach: 16-bit card found\n"));
    /* attach deferred */
    cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_16);
  }
}
d139 5
d145 6
d153 1
a153 3
cardslot_cb_print(aux, pnp)
	void *aux;
	const char *pnp;
d157 1
a157 1
	if (pnp) {
a158 1
	}
d160 1
a160 1
	return UNCONF;
a162 1

d164 1
a164 4
cardslot_16_submatch(parent, match, aux)
     struct device *parent;
     void *match;
     void *aux;
d166 1
a166 1
  struct cfdata *cf = match;
d168 2
a169 2
  if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != 0)
    return 0;
d171 2
a172 3
  if (cf->cf_loc[0] == -1) {
    return ((*cf->cf_attach->ca_match)(parent, cf, aux));
  }
d174 1
a174 1
  return 0;
a176 2


d178 1
a178 3
cardslot_16_print(arg, pnp)
     void *arg;
     const char *pnp;
d180 2
d183 1
a183 5
  if (pnp) {
    printf("pcmciabus at %s", pnp);
  }

  return UNCONF;
a185 3



d187 1
a187 2
create_slot_manager(arg)
     void *arg;
d189 1
a189 1
  struct cardslot_softc *sc = (struct cardslot_softc *)arg;
d191 1
a191 1
  sc->sc_th_enable = 1;
d193 6
a198 6
 if (kthread_create(cardslot_event_thread, sc, &sc->sc_event_thread, "%s",
		     sc->sc_dev.dv_xname)) {
    printf("%s: unable to create event thread for slot %d\n",
	   sc->sc_dev.dv_xname, sc->sc_slot);
    panic("create_slot_manager");
  }
a200 3



d208 1
a208 3
cardslot_event_throw(sc, ev)
     struct cardslot_softc *sc;
     int ev;
d210 1
a210 1
  struct cardslot_event *ce;
d212 10
a221 5
  DPRINTF(("cardslot_event_throw: an event %s comes\n",
	   ev == CARDSLOT_EVENT_INSERTION_CB ? "CardBus Card inserted" :
	   ev == CARDSLOT_EVENT_INSERTION_16 ? "16-bit Card inserted" :
	   ev == CARDSLOT_EVENT_REMOVAL_CB ? "CardBus Card removed" :
	   ev == CARDSLOT_EVENT_REMOVAL_16 ? "16-bit Card removed" : "???"));
d223 1
a223 3
  if (NULL == (ce = (struct cardslot_event *)malloc(sizeof (struct cardslot_event), M_TEMP, M_NOWAIT))) {
    panic("cardslot_event");
  }
d225 5
a229 7
  ce->ce_type = ev;

  {
    int s = spltty();
    SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);
    splx(s);
  }
d231 1
a231 3
  wakeup(&sc->sc_events);

  return;
a233 1

d242 1
a242 2
cardslot_event_thread(arg)
     void *arg;
d244 163
a406 98
  struct cardslot_softc *sc = arg;
  struct cardslot_event *ce;
  int s;
  static int antonym_ev[4] = {
    CARDSLOT_EVENT_REMOVAL_16, CARDSLOT_EVENT_INSERTION_16,
    CARDSLOT_EVENT_REMOVAL_CB, CARDSLOT_EVENT_INSERTION_CB
  };

  while (sc->sc_th_enable) {
    s = spltty();
    if ((ce = SIMPLEQ_FIRST(&sc->sc_events)) == NULL) {
      splx(s);
      (void) tsleep(&sc->sc_events, PWAIT, "cardslotev", 0);
      continue;
    }
    SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);
    splx(s);

    if (IS_CARDSLOT_INSERT_REMOVE_EV(ce->ce_type)) {
      /* Chattering suppression */
      s = spltty();
      while (1) {
	struct cardslot_event *ce1, *ce2;

	if ((ce1 = SIMPLEQ_FIRST(&sc->sc_events)) == NULL) {
	  break;
	}
	if (ce1->ce_type != antonym_ev[ce->ce_type]) {
	  break;
	}
	if ((ce2 = SIMPLEQ_NEXT(ce1, ce_q)) == NULL) {
	  break;
	}
	if (ce2->ce_type == ce->ce_type) {
	  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);
	  free(ce1, M_TEMP);
	  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);
	  free(ce2, M_TEMP);
	}
      }
      splx(s);
    }

    switch (ce->ce_type) {
    case CARDSLOT_EVENT_INSERTION_CB:
      if ((CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_CB)
	  || (CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_16)) {
	if (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING) {
	  /* A card has already been inserted and works. */
	  break;
	}
      }

      if (sc->sc_cb_softc) {
	CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_CB);
	if (cardbus_attach_card(sc->sc_cb_softc) > 0) {
	  /* at least one function works */
	  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_WORKING);
	} else {
	  /* no functions work or this card is not known */
	  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);
	}
      } else {
	panic("no cardbus on %s", sc->sc_dev.dv_xname);
      }

      break;

    case CARDSLOT_EVENT_INSERTION_16:
      if ((CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_CB)
	  || (CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_16)) {
	if (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING) {
	  /* A card has already been inserted and works. */
	  break;
	}
      }
      if (sc->sc_16_softc) {
	CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_16);
	if (pcmcia_card_attach((struct device *)sc->sc_16_softc)) {
	  /* Do not attach */
	  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);
	} else {
	  /* working */
	  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_WORKING);
	}
      } else {
	panic("no 16-bit pcmcia on %s", sc->sc_dev.dv_xname);
      }

      break;

    case CARDSLOT_EVENT_REMOVAL_CB:
      if (CARDSLOT_CARDTYPE(sc->sc_status) == CARDSLOT_STATUS_CARD_CB) {
	/* CardBus card has not been inserted. */
	if (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING) {
	  cardbus_detach_card(sc->sc_cb_softc);
	  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);
	  CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);
a407 31
	CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);
      } else if (CARDSLOT_CARDTYPE(sc->sc_status) != CARDSLOT_STATUS_CARD_16) {
	/* Unknown card... */
	CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);
      }
      CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);
      break;

    case CARDSLOT_EVENT_REMOVAL_16:
      DPRINTF(("%s: removal event\n", sc->sc_dev.dv_xname));
      if (CARDSLOT_CARDTYPE(sc->sc_status) != CARDSLOT_STATUS_CARD_16) {
	/* 16-bit card has not been inserted. */
	break;
      }
      if ((sc->sc_16_softc != NULL)
	  && (CARDSLOT_WORK(sc->sc_status) == CARDSLOT_STATUS_WORKING)) {
	struct pcmcia_softc *psc = sc->sc_16_softc;

	pcmcia_card_deactivate((struct device *)psc);
	pcmcia_chip_socket_disable(psc->pct, psc->pch);
	pcmcia_card_detach((struct device *)psc, DETACH_FORCE);
      }
      CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_NONE);
      CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);
      break;

    default:
      panic("cardslot_event_thread: unknown event %d", ce->ce_type);
    }
    free(ce, M_TEMP);
  }
d409 1
a409 1
  sc->sc_event_thread = NULL;
d411 2
a412 2
  /* In case the parent device is waiting for us to exit. */
  wakeup(sc);
d414 1
a414 1
  kthread_exit(0);
@


1.5
log
@- The card_attach_now flag hasn't been necessary or useful for some time.
Garbage collect the code and corresponding documentation.
- some minor grammar/spelling fixes.

From NetBSD, the documentation change changed slightly
after a suggestion from jmc@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.4 2004/05/04 16:59:31 grange Exp $ */
d252 1
a252 1
    panic("cardslot_enevt");
@


1.4
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.3 2003/10/21 10:07:33 jmc Exp $ */
a35 1
#include <sys/types.h>
a115 2
  int card_attach_now;

a146 2
  card_attach_now = sc->sc_dev.dv_cfdata->cf_flags & 0x01;

d149 2
a150 13
    if (card_attach_now) {
      if (cardbus_attach_card(sc->sc_cb_softc) > 0) {
	/* at least one function works */
	CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_WORKING);
      } else {
	/* no functions work or this card is not known */
	CARDSLOT_SET_WORK(sc->sc_status, CARDSLOT_STATUS_NOTWORK);
      }
      CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_CB);
    } else {
      /* attach deferred */
      cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_CB);
    }
d155 2
a156 8
    if (card_attach_now) {
      /* attach now */
      pcmcia_card_attach((struct device *)sc->sc_16_softc);
      CARDSLOT_SET_CARDTYPE(sc->sc_status, CARDSLOT_STATUS_CARD_16);
    } else {
      /* attach deferred */
      cardslot_event_throw(sc, CARDSLOT_EVENT_INSERTION_16);
    }
d328 1
a328 1
	  /* A card has already been inserted and work. */
d352 1
a352 1
	  /* A card has already been inserted and work. */
d413 1
a413 1
  /* In case parent is waiting for us to exit. */
@


1.3
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.2 2002/03/14 01:26:53 millert Exp $ */
d317 1
a317 1
    SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce, ce_q);
d336 1
a336 1
	  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce1, ce_q);
d338 1
a338 1
	  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce2, ce_q);
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.1 2000/04/08 05:50:52 aaron Exp $ */
d164 1
a164 1
      /* attach deffered */
d176 1
a176 1
      /* attach deffered */
d321 1
a321 1
      /* Chattering supression */
@


1.1
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d63 1
a63 1
STATIC void cardslotattach __P((struct device *, struct device *, void *));
d65 7
a71 7
STATIC int cardslotmatch __P((struct device *, void *, void *));
static void create_slot_manager __P((void *));
static void cardslot_event_thread __P((void *arg));

STATIC int cardslot_cb_print __P((void *aux, const char *pcic));
static int cardslot_16_print __P((void *, const char *));
static int cardslot_16_submatch __P((struct device *, void *,void *));
@


1.1.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.1 2000/04/08 05:50:52 aaron Exp $ */
d63 1
a63 1
STATIC void cardslotattach(struct device *, struct device *, void *);
d65 7
a71 7
STATIC int cardslotmatch(struct device *, void *, void *);
static void create_slot_manager(void *);
static void cardslot_event_thread(void *arg);

STATIC int cardslot_cb_print(void *aux, const char *pcic);
static int cardslot_16_print(void *, const char *);
static int cardslot_16_submatch(struct device *, void *,void *);
@


1.1.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.1 2000/04/08 05:50:52 aaron Exp $ */
@


1.1.8.2
log
@cardbus too got skipped by cvs for some reason
@
text
@d1 1
a1 1
/*	$OpenBSD: cardslot.c,v 1.1.8.1 2001/05/14 22:23:11 niklas Exp $ */
d63 1
a63 1
STATIC void cardslotattach(struct device *, struct device *, void *);
d65 7
a71 7
STATIC int cardslotmatch(struct device *, void *, void *);
static void create_slot_manager(void *);
static void cardslot_event_thread(void *arg);

STATIC int cardslot_cb_print(void *aux, const char *pcic);
static int cardslot_16_print(void *, const char *);
static int cardslot_16_submatch(struct device *, void *,void *);
@


1.1.8.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d164 1
a164 1
      /* attach deferred */
d176 1
a176 1
      /* attach deferred */
d321 1
a321 1
      /* Chattering suppression */
@


1.1.8.4
log
@Merge with the trunk
@
text
@d317 1
a317 1
    SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);
d336 1
a336 1
	  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);
d338 1
a338 1
	  SIMPLEQ_REMOVE_HEAD(&sc->sc_events, ce_q);
@


