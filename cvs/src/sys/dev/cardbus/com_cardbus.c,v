head	1.43;
access;
symbols
	OPENBSD_6_2:1.43.0.6
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.43.0.8
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.42.0.16
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.14
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.12
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.10
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.6
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.4
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.2
	OPENBSD_5_0:1.40.0.4
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.43
date	2015.11.14.14.47.56;	author miod;	state Exp;
branches;
next	1.42;
commitid	2pkGyPKPBHGgYDCE;

1.42
date	2012.07.12.08.20.53;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2011.10.09.21.46.32;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2010.11.15.23.19.34;	author mikeb;	state Exp;
branches;
next	1.39;

1.39
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2009.08.20.18.47.03;	author martynas;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.26.17.41.30;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.33;

1.33
date	2008.09.11.21.00.56;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.21.18.49.47;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.25.23.10.16;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.08.21.28.11;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.08.21.18.18;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.08.20.43.07;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.08.20.33.07;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.12.16.35.51;	author grange;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.02.20.11.48;	author fkr;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.01.22.26.48;	author fkr;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.31.01.50.48;	author fkr;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.30.21.44.03;	author fkr;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.28.16.49.46;	author fkr;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.28.01.09.25;	author fkr;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.07.07.38.16;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.26.22.32.06;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.25.01.38.15;	author pascoe;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.24.20.40.05;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.12.04.15.28;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.04.18.45.20;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.04.18.44.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.29.18.22.49;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.27.21.38.57;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.27.19.21.07;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.07.21.16.59;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.12.22.52.35;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.30.20.45.34;	author nordin;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.09.23.11.44;	author niklas;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.01.08.21.41.13;	author mickey;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2000.06.17.18.02.05;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.09.00.45.25;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.15.06.26.58;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.23.12;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2002.03.29.23.39.33;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.01.31.22.55.30;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Various *syncron* -> *synchron* typos.
@
text
@/* $OpenBSD: com_cardbus.c,v 1.42 2012/07/12 08:20:53 deraadt Exp $ */
/* $NetBSD: com_cardbus.c,v 1.4 2000/04/17 09:21:59 joda Exp $ */

/*
 * Copyright (c) 2000 Johan Danielsson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of author nor the names of any contributors may
 *    be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This is a driver for CardBus based serial devices. It is less
   generic than it could be, but it keeps the complexity down. So far
   it assumes that anything that reports itself as a `serial' device
   is infact a 16x50 or 8250, which is not necessarily true (in
   practice this shouldn't be a problem). It also does not handle
   devices in the `multiport serial' or `modem' sub-classes, I've
   never seen any of these, so I don't know what they might look like.

   If the CardBus device only has one BAR (that is not also the CIS
   BAR) listed in the CIS, it is assumed to be the one to use. For
   devices with more than one BAR, the list of known devies has to be
   updated below.  */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/tty.h>
#include <sys/device.h>

#include <dev/cardbus/cardbusvar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pcmcia/pcmciareg.h>

#include "com.h"

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>
#include <dev/ic/ns16550reg.h>

#define	com_lcr		com_cfcr

struct com_cardbus_softc {
	struct com_softc	cc_com;
	void			*cc_ih;
	cardbus_devfunc_t	cc_ct;
	bus_addr_t		cc_addr;
	pcireg_t		cc_base;
	bus_size_t		cc_size;
	pcireg_t		cc_csr;
	int			cc_cben;
	pcitag_t		cc_tag;
	pcireg_t		cc_reg;
	int			cc_type;
	u_char			cc_bug;
	pci_chipset_tag_t	cc_pc;
};

#define DEVNAME(CSC) ((CSC)->cc_com.sc_dev.dv_xname)

int	com_cardbus_match(struct device *, void *, void *);
void	com_cardbus_attach(struct device *, struct device *, void *);
int	com_cardbus_detach(struct device *, int);

void	com_cardbus_setup(struct com_cardbus_softc *);
int	com_cardbus_enable(struct com_softc *);
void	com_cardbus_disable(struct com_softc *);
struct csdev *com_cardbus_find_csdev(struct cardbus_attach_args *);
int	com_cardbus_gofigure(struct cardbus_attach_args *,
    struct com_cardbus_softc *);

struct cfattach com_cardbus_ca = {
	sizeof(struct com_cardbus_softc), com_cardbus_match,
	com_cardbus_attach, com_cardbus_detach, com_activate
};

#define BUG_BROADCOM	0x01

/* XXX Keep this list synchronized with the corresponding one in pucdata.c */
static struct csdev {
	u_short		vendor;
	u_short		product;
	pcireg_t	reg;
	u_char		type;
	u_char		bug;
} csdevs[] = {
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_GLOBALMODEM56,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_MODEM56,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_SERIAL,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO, BUG_BROADCOM },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_SERIAL_2,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO, BUG_BROADCOM },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_SERIAL_GC,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_MODEM56,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO },
	{ PCI_VENDOR_OXFORD2, PCI_PRODUCT_OXFORD2_OXCB950,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO },
	{ PCI_VENDOR_XIRCOM, PCI_PRODUCT_XIRCOM_CBEM56G,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO },
	{ PCI_VENDOR_XIRCOM, PCI_PRODUCT_XIRCOM_MODEM56,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO },
	{ PCI_VENDOR_WCH, PCI_PRODUCT_WCH_CH352,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO },
	{ PCI_VENDOR_NETMOS, PCI_PRODUCT_NETMOS_NM9820,
	  CARDBUS_BASE0_REG, PCI_MAPREG_TYPE_IO }
};

static const int ncsdevs = sizeof(csdevs) / sizeof(csdevs[0]);

struct csdev*
com_cardbus_find_csdev(struct cardbus_attach_args *ca)
{
	struct csdev *cp;

	for (cp = csdevs; cp < csdevs + ncsdevs; cp++)
		if (cp->vendor == PCI_VENDOR(ca->ca_id) &&
		    cp->product == PCI_PRODUCT(ca->ca_id))
			return (cp);
	return (NULL);
}

int
com_cardbus_match(struct device *parent, void *match, void *aux)
{
	struct cardbus_attach_args *ca = aux;

	/* known devices are ok */
	if (com_cardbus_find_csdev(ca) != NULL)
	    return (10);

	/* as are serial devices with a known UART */
	if (ca->ca_cis.funcid == PCMCIA_FUNCTION_SERIAL &&
	    ca->ca_cis.funce.serial.uart_present != 0 &&
	    (ca->ca_cis.funce.serial.uart_type == 0 ||	/* 8250 */
	    ca->ca_cis.funce.serial.uart_type == 1 ||	/* 16450 */
	    ca->ca_cis.funce.serial.uart_type == 2))	/* 16550 */
		return (1);

	return (0);
}

int
com_cardbus_gofigure(struct cardbus_attach_args *ca,
    struct com_cardbus_softc *csc)
{
	int i, index = -1;
	pcireg_t cis_ptr;
	struct csdev *cp;

	/* If this device is listed above, use the known values, */
	cp = com_cardbus_find_csdev(ca);
	if (cp != NULL) {
		csc->cc_reg = cp->reg;
		csc->cc_type = cp->type;
		csc->cc_bug = cp->bug;
		return (0);
	}

	cis_ptr = pci_conf_read(ca->ca_pc, csc->cc_tag, CARDBUS_CIS_REG);

	/* otherwise try to deduce which BAR and type to use from CIS.  If
	   there is only one BAR, it must be the one we should use, if
	   there are more, we're out of luck.  */
	for (i = 0; i < 7; i++) {
		/* ignore zero sized BARs */
		if (ca->ca_cis.bar[i].size == 0)
			continue;
		/* ignore the CIS BAR */
		if (CARDBUS_CIS_ASI_BAR(cis_ptr) ==
		    CARDBUS_CIS_ASI_BAR(ca->ca_cis.bar[i].flags))
			continue;
		if (index != -1)
			goto multi_bar;
		index = i;
	}
	if (index == -1) {
		printf(": couldn't find any base address tuple\n");
		return (1);
	}
	csc->cc_reg = CARDBUS_CIS_ASI_BAR(ca->ca_cis.bar[index].flags);
	if ((ca->ca_cis.bar[index].flags & 0x10) == 0)
		csc->cc_type = PCI_MAPREG_TYPE_MEM;
	else
		csc->cc_type = PCI_MAPREG_TYPE_IO;
	return (0);

  multi_bar:
	printf(": there are more than one possible base\n");

	printf("%s: address for this device, "
	    "please report the following information\n",
	    DEVNAME(csc));
	printf("%s: vendor 0x%x product 0x%x\n", DEVNAME(csc),
	    PCI_VENDOR(ca->ca_id), PCI_PRODUCT(ca->ca_id));
	for (i = 0; i < 7; i++) {
		/* ignore zero sized BARs */
		if (ca->ca_cis.bar[i].size == 0)
			continue;
		/* ignore the CIS BAR */
		if (CARDBUS_CIS_ASI_BAR(cis_ptr) ==
		    CARDBUS_CIS_ASI_BAR(ca->ca_cis.bar[i].flags))
			continue;
		printf("%s: base address %x type %s size %x\n",
		    DEVNAME(csc), CARDBUS_CIS_ASI_BAR(ca->ca_cis.bar[i].flags),
		    (ca->ca_cis.bar[i].flags & 0x10) ? "i/o" : "mem",
		    ca->ca_cis.bar[i].size);
	}
	return (1);
}

void
com_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct com_softc *sc = (struct com_softc*)self;
	struct com_cardbus_softc *csc = (struct com_cardbus_softc*)self;
	struct cardbus_attach_args *ca = aux;
	cardbus_devfunc_t ct;

	csc->cc_ct = ct = ca->ca_ct;
	csc->cc_tag = pci_make_tag(ca->ca_pc, ct->ct_bus, ct->ct_dev, ct->ct_func);
	csc->cc_pc = ca->ca_pc;

	if (com_cardbus_gofigure(ca, csc) != 0)
		return;

	if (Cardbus_mapreg_map(ca->ca_ct, csc->cc_reg, csc->cc_type, 0,
	    &sc->sc_iot, &sc->sc_ioh, &csc->cc_addr, &csc->cc_size) != 0) {
		printf(": can't map memory\n");
		return;
	}

	csc->cc_base = csc->cc_addr;
	csc->cc_csr = PCI_COMMAND_MASTER_ENABLE;
	if (csc->cc_type == PCI_MAPREG_TYPE_IO) {
		csc->cc_base |= PCI_MAPREG_TYPE_IO;
		csc->cc_csr |= PCI_COMMAND_IO_ENABLE;
		csc->cc_cben = CARDBUS_IO_ENABLE;
	} else {
		csc->cc_csr |= PCI_COMMAND_MEM_ENABLE;
		csc->cc_cben = CARDBUS_MEM_ENABLE;
	}

	sc->sc_iobase = csc->cc_addr;
	sc->sc_frequency = COM_FREQ;

	sc->enable = com_cardbus_enable;
	sc->disable = com_cardbus_disable;
	sc->enabled = 0;

	if (com_cardbus_enable(sc))
		return;
	sc->enabled = 1;

	sc->sc_hwflags = 0;
	sc->sc_swflags = 0;

	if (csc->cc_bug & BUG_BROADCOM)
		sc->sc_fifolen = 15;

	com_attach_subr(sc);
}

void
com_cardbus_setup(struct com_cardbus_softc *csc)
{
	cardbus_devfunc_t ct = csc->cc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = csc->cc_pc;
	cardbus_function_tag_t cf = ct->ct_cf;
	pcireg_t reg;

	pci_conf_write(pc, csc->cc_tag, csc->cc_reg, csc->cc_base);

	/* enable accesses on cardbus bridge */
	cf->cardbus_ctrl(cc, csc->cc_cben);
	cf->cardbus_ctrl(cc, CARDBUS_BM_ENABLE);

	/* and the card itself */
	reg = pci_conf_read(pc, csc->cc_tag, PCI_COMMAND_STATUS_REG);
	reg &= ~(PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE);
	reg |= csc->cc_csr;
	pci_conf_write(pc, csc->cc_tag, PCI_COMMAND_STATUS_REG, reg);

	/*
	 * Make sure the latency timer is set to some reasonable
	 * value.
	 */
	reg = pci_conf_read(pc, csc->cc_tag, PCI_BHLC_REG);
	if (PCI_LATTIMER(reg) < 0x20) {
			reg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
			reg |= (0x20 << PCI_LATTIMER_SHIFT);
			pci_conf_write(pc, csc->cc_tag, PCI_BHLC_REG, reg);
	}
}

int
com_cardbus_enable(struct com_softc *sc)
{
	struct com_cardbus_softc *csc = (struct com_cardbus_softc*)sc;
	struct cardbus_softc *psc =
	    (struct cardbus_softc *)sc->sc_dev.dv_parent;
	cardbus_chipset_tag_t cc = psc->sc_cc;
	cardbus_function_tag_t cf = psc->sc_cf;

	Cardbus_function_enable(csc->cc_ct);

	com_cardbus_setup(csc);

	/* establish the interrupt. */
	csc->cc_ih = cardbus_intr_establish(cc, cf, psc->sc_intrline,
	    IPL_TTY, comintr, sc, DEVNAME(csc));
	if (csc->cc_ih == NULL) {
		printf(": couldn't establish interrupt\n");
		return (1);
	}

	printf(": irq %d", psc->sc_intrline);

	return (0);
}

void
com_cardbus_disable(struct com_softc *sc)
{
	struct com_cardbus_softc *csc = (struct com_cardbus_softc*)sc;
	struct cardbus_softc *psc =
	    (struct cardbus_softc *)sc->sc_dev.dv_parent;
	cardbus_chipset_tag_t cc = psc->sc_cc;
	cardbus_function_tag_t cf = psc->sc_cf;

	cardbus_intr_disestablish(cc, cf, csc->cc_ih);
	Cardbus_function_disable(csc->cc_ct);
}

int
com_cardbus_detach(struct device *self, int flags)
{
	struct com_cardbus_softc *csc = (struct com_cardbus_softc *) self;
	struct com_softc *sc = (struct com_softc *) self;
	struct cardbus_softc *psc = (struct cardbus_softc *)self->dv_parent;
	int error;

	if ((error = com_detach(self, flags)) != 0)
		return (error);

	cardbus_intr_disestablish(psc->sc_cc, psc->sc_cf, csc->cc_ih);

	Cardbus_mapreg_unmap(csc->cc_ct, csc->cc_reg, sc->sc_iot, sc->sc_ioh,
	    csc->cc_size);

	return (0);
}
@


1.42
log
@Support NetMos NM9820 cardbus (added to puc as well, for the
adaptor cages and because one day com@@cardbus should be replaced by
puc@@cardbus)
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.41 2011/10/09 21:46:32 jsg Exp $ */
d103 1
a103 1
/* XXX Keep this list syncronized with the corresponding one in pucdata.c */
@


1.41
log
@add support for WCH CH352 serial
tested by Atanas Vladimirov on a CardBus device with one physical port
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.40 2010/11/15 23:19:34 mikeb Exp $ */
d130 2
@


1.40
log
@fix up a pointer bug introduced in the previous revision
jsg agrees, ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.39 2010/03/27 21:40:13 jsg Exp $ */
d128 2
@


1.39
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.38 2010/03/27 20:04:03 jsg Exp $ */
d240 1
a240 1
	cardbus_devfunc_t ct = csc->cc_ct;
d242 1
a242 1
	csc->cc_ct = ca->ca_ct;
@


1.38
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.37 2010/03/22 22:28:27 jsg Exp $ */
d80 1
d182 1
a182 1
	cis_ptr = Cardbus_conf_read(csc->cc_ct, csc->cc_tag, CARDBUS_CIS_REG);
d240 1
d243 2
a244 1
	csc->cc_tag = Cardbus_make_tag(csc->cc_ct);
d291 1
d295 1
a295 1
	cardbus_conf_write(cc, cf, csc->cc_tag, csc->cc_reg, csc->cc_base);
d302 1
a302 1
	reg = cardbus_conf_read(cc, cf, csc->cc_tag, PCI_COMMAND_STATUS_REG);
d305 1
a305 1
	cardbus_conf_write(cc, cf, csc->cc_tag, PCI_COMMAND_STATUS_REG, reg);
d311 1
a311 1
	reg = cardbus_conf_read(cc, cf, csc->cc_tag, PCI_BHLC_REG);
d315 1
a315 1
			cardbus_conf_write(cc, cf, csc->cc_tag, PCI_BHLC_REG, reg);
@


1.37
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.36 2009/08/20 18:47:03 martynas Exp $ */
d287 1
a287 1
	pci_chipset_tag_t cc = ct->ct_cc;
d321 1
a321 1
	pci_chipset_tag_t cc = psc->sc_cc;
d347 1
a347 1
	pci_chipset_tag_t cc = psc->sc_cc;
@


1.36
log
@- fix varargs after dmesg tweaking
- intrline is not a string
ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.35 2009/06/26 17:41:30 deraadt Exp $ */
d72 1
a72 1
	cardbusreg_t		cc_base;
d74 1
a74 1
	cardbusreg_t		cc_csr;
d76 2
a77 2
	cardbustag_t		cc_tag;
	cardbusreg_t		cc_reg;
d106 1
a106 1
	cardbusreg_t	reg;
d111 1
a111 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
d113 1
a113 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
d115 1
a115 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO, BUG_BROADCOM },
d117 1
a117 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO, BUG_BROADCOM },
d119 1
a119 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
d121 1
a121 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
d123 1
a123 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
d125 1
a125 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
d127 1
a127 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO }
d138 2
a139 2
		if (cp->vendor == CARDBUS_VENDOR(ca->ca_id) &&
		    cp->product == CARDBUS_PRODUCT(ca->ca_id))
d169 1
a169 1
	cardbusreg_t cis_ptr;
d204 1
a204 1
		csc->cc_type = CARDBUS_MAPREG_TYPE_MEM;
d206 1
a206 1
		csc->cc_type = CARDBUS_MAPREG_TYPE_IO;
d216 1
a216 1
	    CARDBUS_VENDOR(ca->ca_id), CARDBUS_PRODUCT(ca->ca_id));
d253 4
a256 4
	csc->cc_csr = CARDBUS_COMMAND_MASTER_ENABLE;
	if (csc->cc_type == CARDBUS_MAPREG_TYPE_IO) {
		csc->cc_base |= CARDBUS_MAPREG_TYPE_IO;
		csc->cc_csr |= CARDBUS_COMMAND_IO_ENABLE;
d259 1
a259 1
		csc->cc_csr |= CARDBUS_COMMAND_MEM_ENABLE;
d287 1
a287 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d289 1
a289 1
	cardbusreg_t reg;
d298 2
a299 2
	reg = cardbus_conf_read(cc, cf, csc->cc_tag, CARDBUS_COMMAND_STATUS_REG);
	reg &= ~(CARDBUS_COMMAND_IO_ENABLE | CARDBUS_COMMAND_MEM_ENABLE);
d301 1
a301 1
	cardbus_conf_write(cc, cf, csc->cc_tag, CARDBUS_COMMAND_STATUS_REG, reg);
d307 5
a311 5
	reg = cardbus_conf_read(cc, cf, csc->cc_tag, CARDBUS_BHLC_REG);
	if (CARDBUS_LATTIMER(reg) < 0x20) {
			reg &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
			reg |= (0x20 << CARDBUS_LATTIMER_SHIFT);
			cardbus_conf_write(cc, cf, csc->cc_tag, CARDBUS_BHLC_REG, reg);
d321 1
a321 1
	cardbus_chipset_tag_t cc = psc->sc_cc;
d347 1
a347 1
	cardbus_chipset_tag_t cc = psc->sc_cc;
@


1.35
log
@Add all the cardbus com devices to puc, since these can show up on the
pci bus because of the expresscard adaptors... Lacking a better mechanism,
also remind people to keep those lists syncronised.
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.34 2009/03/29 21:53:52 sthen Exp $ */
d332 1
a332 1
		printf(": couldn't establish interrupt\n", DEVNAME(csc));
@


1.34
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.33 2008/09/11 21:00:56 brad Exp $ */
d102 1
@


1.33
log
@Update for the renaming of the existing BCM4322 entry to SERIAL_2.
A COM port should not be misleadingly labeled as a Wifi chipset.
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.32 2008/05/21 18:49:47 kettenis Exp $ */
d247 1
a247 1
		printf(": failed to map memory\n");
@


1.32
log
@Switch i386 from pccom to com.  Welcomed by many.

ok dlg@@, jsing@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.31 2008/02/25 23:10:16 brad Exp $ */
d113 1
a113 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4322,
d115 1
a115 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_SERIAL,
@


1.31
log
@Following up with further dmesg display tweaking after the cardbusprint()
change.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.30 2007/05/08 21:28:11 deraadt Exp $ */
a59 3
#ifdef i386
#include "pccom.h"
#endif
a61 4
#if NPCCOM > 0
#include <i386/isa/pccomvar.h>
#endif
#if NCOM > 0
a62 1
#endif
a94 1
#if NCOM_CARDBUS
a98 6
#elif NPCCOM_CARDBUS
struct cfattach pccom_cardbus_ca = {
	sizeof(struct com_cardbus_softc), com_cardbus_match,
	com_cardbus_attach, com_cardbus_detach, com_activate
};
#endif
@


1.30
log
@backout while the amd64 puc situation is rethought
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.26 2006/10/12 16:35:51 grange Exp $ */
d262 1
a262 1
		printf("failed to map memory");
a283 6
	if (ca->ca_cis.cis1_info[0] && ca->ca_cis.cis1_info[1]) {
		printf(": %s %s\n", ca->ca_cis.cis1_info[0],
		    ca->ca_cis.cis1_info[1]);
		printf("%s", DEVNAME(csc));
	}

d285 1
a285 1
		printf(": function enable failed\n");
d346 1
a346 1
		printf("%s: couldn't establish interrupt\n", DEVNAME(csc));
@


1.29
log
@move com_activate() to where it belongs
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.28 2007/05/08 20:43:07 deraadt Exp $ */
a50 2
#include <sys/ioctl.h>
#include <sys/selinfo.h>
a51 7
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
a52 1
#include <sys/vnode.h>
a58 10
#include <machine/bus.h>
#if defined(__sparc64__) || !defined(__sparc__)
#include <machine/intr.h>
#endif

#if !defined(__sparc__) || defined(__sparc64__)
#define	COM_CONSOLE
#include <dev/cons.h>
#endif

d65 4
d70 1
a102 4
int	com_activate(struct device *, enum devact);
int	com_detach(struct device *, int);
int	comopen(dev_t dev, int flag, int mode, struct proc *p);

a371 72
}

int
com_detach(self, flags)
	struct device *self;
	int flags;
{
	struct com_softc *sc = (struct com_softc *)self;
	int maj, mn;

	sc->sc_swflags |= COM_SW_DEAD;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == comopen)
			break;

	/* Nuke the vnodes for any open instances. */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	/* XXX a symbolic constant for the cua bit would be nicer. */
	mn |= 0x80;
	vdevgone(maj, mn, mn, VCHR);

	/* Detach and free the tty. */
	if (sc->sc_tty) {
		ttyfree(sc->sc_tty);
	}

	timeout_del(&sc->sc_dtr_tmo);
	timeout_del(&sc->sc_diag_tmo);
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	softintr_disestablish(sc->sc_si);
#else
	timeout_del(&sc->sc_comsoft_tmo);
#endif

	return (0);
}

int
com_activate(self, act)
	struct device *self;
	enum devact act;
{
	struct com_softc *sc = (struct com_softc *)self;
	int s, rv = 0;

	s = spltty();
	switch (act) {
	case DVACT_ACTIVATE:
		break;

	case DVACT_DEACTIVATE:
#ifdef KGDB
		if (sc->sc_hwflags & (COM_HW_CONSOLE|COM_HW_KGDB)) {
#else
		if (sc->sc_hwflags & COM_HW_CONSOLE) {
#endif /* KGDB */
			rv = EBUSY;
			break;
		}

		if (sc->disable != NULL && sc->enabled != 0) {
			(*sc->disable)(sc);
			sc->enabled = 0;
		}
		break;
	}
	splx(s);
	return (rv);
@


1.28
log
@repair com/fxp foo_detach() stuff, the hardest part being the pccom mess
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.27 2007/05/08 20:33:07 deraadt Exp $ */
d118 4
a392 3
int	com_detach(struct device *, int);
int	comopen(dev_t dev, int flag, int mode, struct proc *p);

d430 33
@


1.27
log
@put more foo_detach() routines where they are used
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.26 2006/10/12 16:35:51 grange Exp $ */
d51 2
d54 7
d62 1
d69 10
a84 4
#if NPCCOM > 0
#include <i386/isa/pccomvar.h>
#endif
#if NCOM > 0
a85 1
#endif
d389 3
a429 2

int	com_detach(struct device *, int);
@


1.26
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.25 2006/06/02 20:11:48 fkr Exp $ */
d373 41
@


1.25
log
@use the cardbus_conf_read/cardbus_conf_write macros instead of the
Cardbus_conf_read/Cardbus_conf_write ones, since the latters cause
us to panic on macppc.

ok pascoe@@, uwe@@, martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.24 2006/06/01 22:26:48 fkr Exp $ */
d350 1
a350 1
	    IPL_TTY, comintr, sc);
@


1.24
log
@remove a comma from the attach line, makes dmesg prettier
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.23 2006/05/31 01:50:48 fkr Exp $ */
d311 1
a311 1
	Cardbus_conf_write(ct, csc->cc_tag, csc->cc_reg, csc->cc_base);
d318 1
a318 1
	reg = Cardbus_conf_read(ct, csc->cc_tag, CARDBUS_COMMAND_STATUS_REG);
d321 1
a321 1
	Cardbus_conf_write(ct, csc->cc_tag, CARDBUS_COMMAND_STATUS_REG, reg);
@


1.23
log
@order cdevs alphabetically by vendor
ok brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.22 2006/05/30 21:44:03 fkr Exp $ */
d356 1
a356 1
	printf(": irq %d,", psc->sc_intrline);
@


1.22
log
@add Oxford CB950 to the list of devices having more than one BAR, so
that it can be attached properly
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.21 2006/05/28 16:49:46 fkr Exp $ */
d124 1
a124 5
	{ PCI_VENDOR_XIRCOM, PCI_PRODUCT_XIRCOM_MODEM56,
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
	{ PCI_VENDOR_XIRCOM, PCI_PRODUCT_XIRCOM_CBEM56G,
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_MODEM56,
d128 2
a129 2
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_GLOBALMODEM56,
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
d134 2
a135 2
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4322,
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO, BUG_BROADCOM },
d137 4
@


1.21
log
@remove the dev/isa/isavar.h include, as it is not needed
ok miod@@, martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.20 2006/05/28 01:09:25 fkr Exp $ */
d139 3
a141 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO, BUG_BROADCOM }
@


1.20
log
@cleanup whitespaces, tabs are so much nicer
ok mbalmer@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.19 2006/03/07 07:38:16 jsg Exp $ */
a57 2

#include <dev/isa/isavar.h>
@


1.19
log
@Add support for the serial interface to the UMTS/GPRS/GSM modem
portion of the Sony Ericsson GC89 card.

From Felix Kronlage.
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.18 2005/09/26 22:32:06 miod Exp $ */
d306 3
a308 3
        cardbus_devfunc_t ct = csc->cc_ct;
        cardbus_chipset_tag_t cc = ct->ct_cc;
        cardbus_function_tag_t cf = ct->ct_cf;
d323 10
a332 10
        /*
         * Make sure the latency timer is set to some reasonable
         * value.
         */
        reg = cardbus_conf_read(cc, cf, csc->cc_tag, CARDBUS_BHLC_REG);
        if (CARDBUS_LATTIMER(reg) < 0x20) {
                reg &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
                reg |= (0x20 << CARDBUS_LATTIMER_SHIFT);
                cardbus_conf_write(cc, cf, csc->cc_tag, CARDBUS_BHLC_REG, reg);
        }
@


1.18
log
@Share com probe code between com and pccom; allows us to get rid of awkward
code duplication in cardbus, pcmcia and puc attachments.

Joint effort with fgs@@; blessed deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.17 2005/07/25 01:38:15 pascoe Exp $ */
d138 2
@


1.17
log
@add missing comma to initializer.
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.16 2005/07/24 20:40:05 fgsch Exp $ */
a103 1
void	com_cardbus_attach2(struct com_softc *, u_char);
a277 3
	timeout_set(&sc->sc_dtr_tmo, com_raisedtr, sc);
	timeout_set(&sc->sc_diag_tmo, comdiag, sc);

d291 8
a298 1
	com_cardbus_attach2(sc, csc->cc_bug);
a388 169
}


/*
 * XXX This should be handled by a generic attach
 */
void
com_cardbus_attach2(struct com_softc *sc, u_char bug)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t lcr;

	sc->sc_hwflags = 0;
	sc->sc_swflags = 0;

	/*
	 * Probe for all known forms of UART.
	 */
	lcr = bus_space_read_1(iot, ioh, com_lcr);

	bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
	bus_space_write_1(iot, ioh, com_efr, 0);
	bus_space_write_1(iot, ioh, com_lcr, 0);

	bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	delay(100);

	switch(bus_space_read_1(iot, ioh, com_iir) >> 6) {
	case 0:
		sc->sc_uarttype = COM_UART_16450;
		break;
	case 2:
		sc->sc_uarttype = COM_UART_16550;
		break;
	case 3:
		sc->sc_uarttype = COM_UART_16550A;
		break;
	default:
		sc->sc_uarttype = COM_UART_UNKNOWN;
		break;
	}

	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		if (bus_space_read_1(iot, ioh, com_efr) == 0) {
			sc->sc_uarttype = COM_UART_ST16650;
		} else {
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			if (bus_space_read_1(iot, ioh, com_efr) == 0)
				sc->sc_uarttype = COM_UART_ST16650V2;
		}
	}

	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for TI16750s */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		bus_space_write_1(iot, ioh, com_fifo,
		    FIFO_ENABLE | FIFO_ENABLE_64BYTE);
		if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 7) {
#if 0
			bus_space_write_1(iot, ioh, com_lcr, 0);
			if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 6)
#endif
				sc->sc_uarttype = COM_UART_TI16750;
		}
		bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	}

#if NPCCOM > 0
#ifdef i386
	if (sc->sc_uarttype == COM_UART_ST16650V2) {	/* Probe for XR16850s */
		u_int8_t dlbl, dlbh;

		/* Enable latch access and get the current values. */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		dlbl = bus_space_read_1(iot, ioh, com_dlbl);
		dlbh = bus_space_read_1(iot, ioh, com_dlbh);

		/* Zero out the latch divisors */
		bus_space_write_1(iot, ioh, com_dlbl, 0);
		bus_space_write_1(iot, ioh, com_dlbh, 0);

		if (bus_space_read_1(iot, ioh, com_dlbh) == 0x10) {
			sc->sc_uarttype = COM_UART_XR16850;
			sc->sc_uartrev = bus_space_read_1(iot, ioh, com_dlbl);
		}

		/* Reset to original. */
		bus_space_write_1(iot, ioh, com_dlbl, dlbl);
		bus_space_write_1(iot, ioh, com_dlbh, dlbh);
	}
#endif
#endif

	/* Reset the LCR (latch access is probably enabled). */
	bus_space_write_1(iot, ioh, com_lcr, lcr);
	if (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */
		u_int8_t scr0, scr1, scr2;

		scr0 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0xa5);
		scr1 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0x5a);
		scr2 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, scr0);

		if ((scr1 != 0xa5) || (scr2 != 0x5a))
			sc->sc_uarttype = COM_UART_8250;
	}

	/*
	 * Print UART type and initialize ourself.
	 */
	sc->sc_fifolen = 1;	/* default */
	printf(" ");
	switch (sc->sc_uarttype) {
	case COM_UART_UNKNOWN:
		printf("unknown uart\n");
		break;
	case COM_UART_8250:
		printf("ns8250, no fifo\n");
		break;
	case COM_UART_16450:
		printf("ns16450, no fifo\n");
		break;
	case COM_UART_16550:
		printf("ns16550, no working fifo\n");
		break;
	case COM_UART_16550A:
		if (bug & BUG_BROADCOM) {
			printf("Broadcom ns16550a, 15 byte fifo\n");
			SET(sc->sc_hwflags, COM_HW_FIFO);
			sc->sc_fifolen = 15;
			break;
		}
		printf("ns16550a, 16 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 16;
		break;
	case COM_UART_ST16650:
		printf("st16650, no working fifo\n");
		break;
	case COM_UART_ST16650V2:
		printf("st16650, 32 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 32;
		break;
	case COM_UART_TI16750:
		printf("ti16750, 64 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 64;
		break;
#if NPCCOM > 0
#ifdef i386
	case COM_UART_XR16850:
		printf("xr16850 (rev %d), 128 byte fifo\n", sc->sc_uartrev);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 128;
		break;
#endif
#endif
	default:
		panic("comattach: bad fifo type");
	}

	/* clear and disable fifo */
	bus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);
	(void)bus_space_read_1(iot, ioh, com_data);
	bus_space_write_1(iot, ioh, com_fifo, 0);
@


1.16
log
@add Broadcom BCM4322 support; reported and tested by Alexander Topolanek
(atopo at ocv dot org).
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.15 2005/07/12 04:15:28 deraadt Exp $ */
d138 1
a138 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO, BUG_BROADCOM }
@


1.15
log
@handle TI 64 byte fifo units here too; steve.shockley@@shockley.net
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.14 2005/07/04 18:45:20 deraadt Exp $ */
d138 2
@


1.14
log
@probe & handle TI16750 if they ever show up here
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.13 2005/07/04 18:44:53 deraadt Exp $ */
d530 5
@


1.13
log
@broadcom never ceases to amaze us.  the fifos on their 16550a
serial chips are apparently 15 bytes not 16 bytes.  reported to me by
the option driver author
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.12 2005/06/29 18:22:49 deraadt Exp $ */
d436 14
@


1.12
log
@initialize timeouts needed by pccom
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.11 2005/06/27 21:38:57 deraadt Exp $ */
d89 1
d104 1
a104 1
void	com_cardbus_attach2(struct com_softc *);
d118 2
d121 2
a122 2
	int		vendor;
	int		product;
d124 2
a125 1
	int		type;
d138 1
a138 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO }
d170 1
a170 1
	    return (1);
d188 1
d293 1
a293 1
	com_cardbus_attach2(sc);
d391 1
a391 2
com_cardbus_attach2(sc)
	struct com_softc *sc;
d499 6
@


1.11
log
@comma
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.10 2005/06/27 19:21:07 deraadt Exp $ */
d240 1
a240 1
com_cardbus_attach (struct device *parent, struct device *self, void *aux)
d271 3
@


1.10
log
@card broadcom serial, plus set frequency
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.9 2004/10/07 21:16:59 brad Exp $ */
d341 1
a341 1
	printf(": irq %d", psc->sc_intrline);
@


1.9
log
@cardbusdevs -> pcidevs

From NetBSD
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.8 2004/07/12 22:52:35 brad Exp $ */
d132 2
d268 1
a269 2

#if 0
a270 1
#endif
a281 1
#ifdef __OpenBSD__
a283 1

a284 1

a285 7
#else
	com_cardbus_setup(csc);

	com_attach_subr(sc);

	Cardbus_function_disable(csc->cc_ct);
#endif
d477 1
@


1.8
log
@typo, thise -> these
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.7 2002/03/14 01:26:53 millert Exp $ */
d55 1
a55 1
#include <dev/cardbus/cardbusdevs.h>
d123 1
a123 1
	{ CARDBUS_VENDOR_XIRCOM, CARDBUS_PRODUCT_XIRCOM_MODEM56,
d125 1
a125 1
	{ CARDBUS_VENDOR_XIRCOM, CARDBUS_PRODUCT_XIRCOM_CBEM56G,
d127 1
a127 1
	{ CARDBUS_VENDOR_INTEL, CARDBUS_PRODUCT_INTEL_MODEM56,
d129 1
a129 1
	{ CARDBUS_VENDOR_3COM, CARDBUS_PRODUCT_3COM_MODEM56,
d131 1
a131 1
	{ CARDBUS_VENDOR_3COM, CARDBUS_PRODUCT_3COM_GLOBALMODEM56,
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.6 2002/01/30 20:45:34 nordin Exp $ */
d42 1
a42 1
   never seen any of thise, so I don't know what they might look like.
@


1.6
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.5 2001/07/09 23:11:44 niklas Exp $ */
d93 11
a103 11
int	com_cardbus_match __P((struct device *, void *, void *));
void	com_cardbus_attach __P((struct device *, struct device *, void *));
int	com_cardbus_detach __P((struct device *, int));

void	com_cardbus_setup __P((struct com_cardbus_softc *));
int	com_cardbus_enable __P((struct com_softc *));
void	com_cardbus_disable __P((struct com_softc *));
struct csdev *com_cardbus_find_csdev __P((struct cardbus_attach_args *));
int	com_cardbus_gofigure __P((struct cardbus_attach_args *,
    struct com_cardbus_softc *));
void	com_cardbus_attach2 __P((struct com_softc *));
@


1.5
log
@Match CBEM56G as well
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.4 2001/01/08 21:41:13 mickey Exp $ */
a75 1
#define	SET(t, f)	(t) |= (f)
@


1.5.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.6 2002/01/30 20:45:34 nordin Exp $ */
d76 1
@


1.5.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.5.4.1 2002/01/31 22:55:30 niklas Exp $ */
d93 11
a103 11
int	com_cardbus_match(struct device *, void *, void *);
void	com_cardbus_attach(struct device *, struct device *, void *);
int	com_cardbus_detach(struct device *, int);

void	com_cardbus_setup(struct com_cardbus_softc *);
int	com_cardbus_enable(struct com_softc *);
void	com_cardbus_disable(struct com_softc *);
struct csdev *com_cardbus_find_csdev(struct cardbus_attach_args *);
int	com_cardbus_gofigure(struct cardbus_attach_args *,
    struct com_cardbus_softc *);
void	com_cardbus_attach2(struct com_softc *);
@


1.4
log
@match on 3CXFEM656C's global modem too, does not seem to work right, but; from openbsd@@zenbu.com
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.3 2000/06/17 18:02:05 niklas Exp $ */
d125 2
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.4 2001/01/08 21:41:13 mickey Exp $ */
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.4.4.1 2001/05/14 22:23:12 niklas Exp $ */
a124 2
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO },
	{ CARDBUS_VENDOR_XIRCOM, CARDBUS_PRODUCT_XIRCOM_CBEM56G,
@


1.4.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d76 1
@


1.4.4.4
log
@cardbus too got skipped by cvs for some reason
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.4.4.3 2002/03/06 02:11:42 niklas Exp $ */
d93 11
a103 11
int	com_cardbus_match(struct device *, void *, void *);
void	com_cardbus_attach(struct device *, struct device *, void *);
int	com_cardbus_detach(struct device *, int);

void	com_cardbus_setup(struct com_cardbus_softc *);
int	com_cardbus_enable(struct com_softc *);
void	com_cardbus_disable(struct com_softc *);
struct csdev *com_cardbus_find_csdev(struct cardbus_attach_args *);
int	com_cardbus_gofigure(struct cardbus_attach_args *,
    struct com_cardbus_softc *);
void	com_cardbus_attach2(struct com_softc *);
@


1.3
log
@Do not disable the com port as sson as it is attached.  Make compile again.
Fix interrupt printing.  Hi from OpenBSD crypto 2K
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.2 2000/06/09 00:45:25 aaron Exp $ */
d129 2
@


1.2
log
@Add support for 3c656, which is just the 3c575 + 56k modem. Thanks to
xav@@quakeserver.org for testing.
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.1 2000/05/15 06:26:58 niklas Exp $ */
d127 1
a127 1
	  CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO }
d279 8
a288 1
#if 0
a289 3
#else
	com_cardbus_attach2(sc);
#endif
d292 1
d348 1
a348 1
	printf("%s: interrupting at irq %d\n", DEVNAME(csc), psc->sc_intrline);
d486 1
a486 1
		printf(": unknown uart\n");
d489 1
a489 1
		printf(": ns8250, no fifo\n");
d492 1
a492 1
		printf(": ns16450, no fifo\n");
d495 1
a495 1
		printf(": ns16550, no working fifo\n");
d498 1
a498 1
		printf(": ns16550a, 16 byte fifo\n");
d503 1
a503 1
		printf(": st16650, no working fifo\n");
d506 1
a506 1
		printf(": st16650, 32 byte fifo\n");
d513 1
a513 1
		printf(": xr16850 (rev %d), 128 byte fifo\n", sc->sc_uartrev);
@


1.1
log
@Cardbus com driver, from NetBSD, but adapted for our style conventions
and with pccom support added
@
text
@d1 1
a1 1
/* $OpenBSD: com_cardbus.c,v 1.4 2000/04/17 09:21:59 joda Exp $ */
d127 2
@

