head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.8
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.6
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.4
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.12
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.10
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.5
	UBC:1.1.0.8
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.18
date	2016.12.15.19.18.41;	author fcambus;	state Exp;
branches;
next	1.17;
commitid	45LhUG6e3lYbiYAV;

1.17
date	2015.09.07.18.00.58;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	nhg8EbZxMSdby1MI;

1.16
date	2014.12.22.20.08.05;	author krw;	state Exp;
branches;
next	1.15;
commitid	L3dUcSGDRm3ciu0V;

1.15
date	2013.10.20.21.24.00;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.20.16.44.48;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.28.20.06.50;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2013.05.17.12.03.12;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.19.49.08;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.15.20.23.10;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.30.23.13.47;	author pascoe;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.12.02.31.01;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.28.01.30.08;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.02.19.38.55;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.18.04.32.44;	author nate;	state Exp;
branches
	1.1.4.1
	1.1.8.1;
next	;

1.1.4.1
date	2001.05.14.22.26.15;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.30.08.19.20;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.1.8.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Remove rasops2 (2-bit color depth) functions, they are unused.

It seems unlikely that any future new platform will ever need them.

OK mpi@@
@
text
@/*	$OpenBSD: rasops.h,v 1.17 2015/09/07 18:00:58 kettenis Exp $ */
/* 	$NetBSD: rasops.h,v 1.13 2000/06/13 13:36:54 ad Exp $ */

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Doran.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _RASOPS_H_
#define _RASOPS_H_ 1

#include <sys/task.h>

#ifdef	SMALL_KERNEL
#define	RASOPS_SMALL
#endif

#include "rasops_glue.h"

struct wsdisplay_font;

/* For rasops_info::ri_flg */
#define RI_FULLCLEAR	0x0001	/* eraserows() hack to clear full screen */
#define RI_FORCEMONO	0x0002	/* monochrome output even if we can do color */
#define RI_BSWAP	0x0004	/* framebuffer endianness doesn't match CPU */
#define RI_CURSOR	0x0008	/* cursor is switched on */
#define RI_CLEAR	0x0010	/* clear display on startup */
#define	RI_CLEARMARGINS	0x0020	/* clear display margins on startup */
#define RI_CENTER	0x0040	/* center onscreen output */
#define RI_CURSORCLIP	0x0080	/* cursor is currently clipped */
#define	RI_ROTATE_CW	0x0100	/* display is rotated, quarter clockwise */
#define RI_CFGDONE	0x0200	/* rasops_reconfig() completed successfully */
#define RI_VCONS	0x0400	/* virtual consoles */
#define RI_WRONLY	0x0800	/* avoid framebuffer reads */

struct rasops_screen;

struct rasops_info {
	/* These must be filled in by the caller */
	int	ri_depth;	/* depth in bits */
	u_char	*ri_bits;	/* ptr to bits */
	int	ri_width;	/* width (pels) */
	int	ri_height;	/* height (pels) */
	int	ri_stride;	/* stride in bytes */

	/*
	 * These can optionally be left zeroed out. If you fill ri_font,
	 * but aren't using wsfont, set ri_wsfcookie to -1.
	 */
	struct	wsdisplay_font *ri_font;
	int	ri_wsfcookie;	/* wsfont cookie */
	void	*ri_hw;		/* driver private data; ignored by rasops */
	struct wsdisplay_charcell *ri_bs; /* character backing store */
	int	ri_crow;	/* cursor row */
	int	ri_ccol;	/* cursor column */
	int	ri_flg;		/* various operational flags */

	/*
	 * These are optional and will default if zero. Meaningless
	 * on depths other than 15, 16, 24 and 32 bits per pel. On
	 * 24 bit displays, ri_{r,g,b}num must be 8.
	 */
	u_char	ri_rnum;	/* number of bits for red */
	u_char	ri_gnum;	/* number of bits for green */
	u_char	ri_bnum;	/* number of bits for blue */
	u_char	ri_rpos;	/* which bit red starts at */
	u_char	ri_gpos;	/* which bit green starts at */
	u_char	ri_bpos;	/* which bit blue starts at */

	/* These are filled in by rasops_init() */
	int	ri_emuwidth;	/* width we actually care about */
	int	ri_emuheight;	/* height we actually care about */
	int	ri_emustride;	/* bytes per row we actually care about */
	int	ri_rows;	/* number of rows (characters, not pels) */
	int	ri_cols;	/* number of columns (characters, not pels) */
	int	ri_delta;	/* row delta in bytes */
	int	ri_pelbytes;	/* bytes per pel (may be zero) */
	int	ri_fontscale;	/* fontheight * fontstride */
	int	ri_xscale;	/* fontwidth * pelbytes */
	int	ri_yscale;	/* fontheight * stride */
	u_char  *ri_origbits;	/* where screen bits actually start */
	int	ri_xorigin;	/* where ri_bits begins (x) */
	int	ri_yorigin;	/* where ri_bits begins (y) */
	int32_t	ri_devcmap[16]; /* color -> framebuffer data */

	/* The emulops you need to use, and the screen caps for wscons */
	struct	wsdisplay_emulops ri_ops;
	int	ri_caps;

	/* Callbacks so we can share some code */
	int	(*ri_do_cursor)(struct rasops_info *);
	void	(*ri_updatecursor)(struct rasops_info *);

#if NRASOPS_ROTATION > 0
	/* Used to intercept putchar to permit display rotation */
	struct	wsdisplay_emulops ri_real_ops;
#endif

	int	ri_nscreens;
	LIST_HEAD(, rasops_screen) ri_screens;
	struct rasops_screen *ri_active;

	void	(*ri_switchcb)(void *, int, int);
	void	*ri_switchcbarg;
	void	*ri_switchcookie;
	struct task ri_switchtask;

	int	(*ri_putchar)(void *, int, int, u_int, long);
	int	(*ri_copycols)(void *, int, int, int, int);
	int	(*ri_erasecols)(void *, int, int, int, long);
	int	(*ri_copyrows)(void *, int, int, int);
	int	(*ri_eraserows)(void *, int, int, long);
	int	(*ri_alloc_attr)(void *, int, int, int, long *);
};

#define DELTA(p, d, cast) ((p) = (cast)((caddr_t)(p) + (d)))

/*
 * rasops_init().
 *
 * Integer parameters are the number of rows and columns we'd *like*.
 *
 * In terms of optimization, fonts that are a multiple of 8 pixels wide
 * work the best.
 *
 * rasops_init() takes care of rasops_reconfig(). The parameters to both
 * are the same. If calling rasops_reconfig() to change the font and
 * ri_wsfcookie >= 0, you must call wsfont_unlock() on it, and reset it
 * to -1 (or a new, valid cookie).
 */

/*
 * Per-depth initialization functions. These should not be called outside
 * the rasops code.
 */
void	rasops1_init(struct rasops_info *);
void	rasops4_init(struct rasops_info *);
void	rasops8_init(struct rasops_info *);
void	rasops15_init(struct rasops_info *);
void	rasops24_init(struct rasops_info *);
void	rasops32_init(struct rasops_info *);

/* rasops.c */
int	rasops_init(struct rasops_info *, int, int);
int	rasops_reconfig(struct rasops_info *, int, int);
int	rasops_eraserows(void *, int, int, long);
int	rasops_erasecols(void *, int, int, int, long);

int	rasops_alloc_screen(void *, void **, int *, int *, long *);
void	rasops_free_screen(void *, void *);
int	rasops_show_screen(void *, void *, int,
	    void (*)(void *, int, int), void *);
int	rasops_load_font(void *, void *, struct wsdisplay_font *);
int	rasops_list_font(void *, struct wsdisplay_font *);
int	rasops_getchar(void *, int, int, struct wsdisplay_charcell *);

extern const u_char	rasops_isgray[16];
extern const u_char	rasops_cmap[256*3];

#endif /* _RASOPS_H_ */
@


1.17
log
@Make it possible to use RI_WRONLY for the aframebuffer during early boot.
In this case, the caller has to provide the backing store for the screen
contents by setting the ri_bs member of "struct rasops_info".  The screen
contents are retained if the rasops_info descriptor is later reinitialized
after adding the RI_VCONS flag.

ok yasuoka@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.16 2014/12/22 20:08:05 krw Exp $ */
a160 1
void	rasops2_init(struct rasops_info *);
@


1.16
log
@Replace switch workq with taskq, using the blambert@@ method (tm).

Tested with non-drm and wsfb systems. ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.15 2013/10/20 21:24:00 miod Exp $ */
d77 1
@


1.15
log
@No longer store fonts added with the WSDISPLAYIO_LDFONT ioctl into the
wsdisplay softc. Instead, since the knowledge about available fonts lies in
the parent driver itself, introduce a list_font wsdisplay_accessop which
queries a font index, suitable to use within the WSDISPLAYIO_LSFONT ioctl.

With this in place:
- there is no global wsdisplay limit on the number of fonts loaded. Such a
  limit will be enforced by the display drivers themselves.
- built-in kernel fonts will now appear in the list of fonts.

Grow a list_font accesop for rasops, which relies upon wsfont_enum(), which
is turned into something useful (and abortable if you do not need to iterate
further). Not used by any rasops driver yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.14 2013/10/20 16:44:48 miod Exp $ */
d36 1
a36 1
#include <sys/workq.h>
d128 2
a129 1
	struct workq_task ri_switchwqt;
@


1.14
log
@Add a load_font accessop to rasops, to allow for fonts to be loaded and
selected. All rasops fonts are managed by wsfont, which allows a font to be
loaded on a rasops device and used on another.

Currently not plumbed in any driver yet. This is work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.13 2013/06/28 20:06:50 kettenis Exp $ */
d177 1
@


1.13
log
@Add support for write-only framebuffers.  This makes the code that copies
rows and columns redraw the destination area instead of reading pixel values
from the framebuffer.  This can be a considerable performance win.  Only
works together with RI_VCONS.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.12 2013/05/17 12:03:12 kettenis Exp $ */
d176 1
@


1.12
log
@Implement wsmoused support based on the new multiple screen support.  Only
works if the RI_VCONS flag is specified when initializing a rasops_info
descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.11 2013/03/25 19:49:08 kettenis Exp $ */
d58 1
@


1.11
log
@Add basic support for multiple screens.

ok mpi@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.10 2009/09/05 14:09:35 miod Exp $ */
d175 1
@


1.10
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.9 2008/06/26 05:42:17 ray Exp $ */
d36 2
d57 3
d120 15
d170 5
@


1.9
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.8 2006/11/29 19:08:22 miod Exp $ */
d108 1
a108 1
	void	(*ri_do_cursor)(struct rasops_info *);
d148 2
a149 2
void	rasops_eraserows(void *, int, int, long);
void	rasops_erasecols(void *, int, int, int, long);
@


1.8
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.7 2005/09/15 20:23:10 miod Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.7
log
@Stop compiling the texte console rotation code #ifdef __zaurus__, but use
a flag in the rasops_info structure; drivers which may use it shall declare
a specific attribute for the config(8) machinery, so that the necessary code
is compiled in.

In addition to this, rotated font computation is now done on-demand, and a
list of unrotated-rotated font cookie pairs is kept, rather than rotating all
built-in wsfonts at initialization time.

No user-perceptible functional change.

Tested matthieu@@ uwe@@, ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.6 2005/04/30 23:13:47 pascoe Exp $ */
a154 1
void	rasops_unpack_attr(long, int *, int *, int *);
@


1.6
log
@Temporary hack to (un)rotate the Zaurus console until a proper rasops
rotation framework is ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.5 2002/08/12 02:31:01 jason Exp $ */
d47 2
d52 10
a61 8
#define RI_FULLCLEAR	0x01	/* eraserows() hack to clear full screen */
#define RI_FORCEMONO	0x02	/* monochrome output even if we can do color */
#define RI_BSWAP	0x04	/* framebuffer endianness doesn't match CPU */
#define RI_CURSOR	0x08	/* cursor is switched on */
#define RI_CLEAR	0x10	/* clear display on startup */
#define RI_CENTER	0x20	/* center onscreen output */
#define RI_CURSORCLIP	0x40	/* cursor is currently clipped */
#define RI_CFGDONE	0x80	/* rasops_reconfig() completed successfully */
d118 1
a118 1
#ifdef __zaurus__
a157 1
void	rasops_copycols(void *, int, int, int, int);
@


1.5
log
@Add a callback routine for when the cursor position is updated (this allows
for updating prom cursor locations).
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.4 2002/07/28 01:30:08 miod Exp $ */
d113 5
@


1.4
log
@Define RASOPS_SMALL when SMALL_KERNEL is also defined.
Shaves a few more KB out of alpha (and others) ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.3 2002/07/02 19:38:55 nate Exp $ */
d112 1
@


1.3
log
@inital -> initial
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.2 2002/03/14 01:27:02 millert Exp $ */
d42 4
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.1 2001/03/18 04:32:44 nate Exp $ */
d127 1
a127 1
 * Per-depth initalization functions. These should not be called outside
@


1.1
log
@Import rasops from NetBSD.  This gives improved performance for raster
operations.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d107 1
a107 1
	void	(*ri_do_cursor) __P((struct rasops_info *));
d130 7
a136 7
void	rasops1_init __P((struct rasops_info *));
void	rasops2_init __P((struct rasops_info *));
void	rasops4_init __P((struct rasops_info *));
void	rasops8_init __P((struct rasops_info *));
void	rasops15_init __P((struct rasops_info *));
void	rasops24_init __P((struct rasops_info *));
void	rasops32_init __P((struct rasops_info *));
d139 6
a144 6
int	rasops_init __P((struct rasops_info *, int, int));
int	rasops_reconfig __P((struct rasops_info *, int, int));
void	rasops_unpack_attr __P((long, int *, int *, int *));
void	rasops_eraserows __P((void *, int, int, long));
void	rasops_erasecols __P((void *, int, int, int, long));
void	rasops_copycols __P((void *, int, int, int, int));
@


1.1.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.1 2001/03/18 04:32:44 nate Exp $ */
d107 1
a107 1
	void	(*ri_do_cursor)(struct rasops_info *);
d130 7
a136 7
void	rasops1_init(struct rasops_info *);
void	rasops2_init(struct rasops_info *);
void	rasops4_init(struct rasops_info *);
void	rasops8_init(struct rasops_info *);
void	rasops15_init(struct rasops_info *);
void	rasops24_init(struct rasops_info *);
void	rasops32_init(struct rasops_info *);
d139 6
a144 6
int	rasops_init(struct rasops_info *, int, int);
int	rasops_reconfig(struct rasops_info *, int, int);
void	rasops_unpack_attr(long, int *, int *, int *);
void	rasops_eraserows(void *, int, int, long);
void	rasops_erasecols(void *, int, int, int, long);
void	rasops_copycols(void *, int, int, int, int);
@


1.1.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.1.8.1 2002/06/11 03:42:28 art Exp $ */
a42 4
#ifdef	SMALL_KERNEL
#define	RASOPS_SMALL
#endif

a107 1
	void	(*ri_updatecursor)(struct rasops_info *);
d127 1
a127 1
 * Per-depth initialization functions. These should not be called outside
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.h,v 1.1 2001/03/18 04:32:44 nate Exp $ */
@


1.1.4.2
log
@Merge unpeeing cvs missed
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d107 1
a107 1
	void	(*ri_do_cursor)(struct rasops_info *);
d130 7
a136 7
void	rasops1_init(struct rasops_info *);
void	rasops2_init(struct rasops_info *);
void	rasops4_init(struct rasops_info *);
void	rasops8_init(struct rasops_info *);
void	rasops15_init(struct rasops_info *);
void	rasops24_init(struct rasops_info *);
void	rasops32_init(struct rasops_info *);
d139 6
a144 6
int	rasops_init(struct rasops_info *, int, int);
int	rasops_reconfig(struct rasops_info *, int, int);
void	rasops_unpack_attr(long, int *, int *, int *);
void	rasops_eraserows(void *, int, int, long);
void	rasops_erasecols(void *, int, int, int, long);
void	rasops_copycols(void *, int, int, int, int);
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@a42 4
#ifdef	SMALL_KERNEL
#define	RASOPS_SMALL
#endif

a107 1
	void	(*ri_updatecursor)(struct rasops_info *);
d127 1
a127 1
 * Per-depth initialization functions. These should not be called outside
@


