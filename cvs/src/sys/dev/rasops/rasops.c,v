head	1.47;
access;
symbols
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.38.0.4
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.8
	UBC:1.1.0.8
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.47
date	2017.08.17.20.21.53;	author kettenis;	state Exp;
branches;
next	1.46;
commitid	7lXpZyid0vR5Zwgg;

1.46
date	2017.08.13.22.28.23;	author kettenis;	state Exp;
branches;
next	1.45;
commitid	PrXY80nFbIfhG08I;

1.45
date	2017.05.16.02.22.51;	author jcs;	state Exp;
branches;
next	1.44;
commitid	MnoXGrgpNIkm30Jb;

1.44
date	2016.12.15.19.18.41;	author fcambus;	state Exp;
branches;
next	1.43;
commitid	45LhUG6e3lYbiYAV;

1.43
date	2016.09.26.20.41.08;	author fcambus;	state Exp;
branches;
next	1.42;
commitid	ydQNJZy8wNyOnZeH;

1.42
date	2015.09.07.18.00.58;	author kettenis;	state Exp;
branches;
next	1.41;
commitid	nhg8EbZxMSdby1MI;

1.41
date	2015.09.01.01.54.04;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	ga85MOyiKe4YIZEE;

1.40
date	2015.06.21.20.49.18;	author jca;	state Exp;
branches;
next	1.39;
commitid	dgX9IO20s4LxfIjP;

1.39
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.38;
commitid	p4LJxGKbi0BU2cG6;

1.38
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.37;
commitid	MyKPm9Q3dQu92BiX;

1.37
date	2014.12.22.20.08.05;	author krw;	state Exp;
branches;
next	1.36;
commitid	L3dUcSGDRm3ciu0V;

1.36
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.35;
commitid	LS2TNeCue5R9L67C;

1.35
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.34;
commitid	20ZyHa9gTJxHxhwD;

1.34
date	2014.11.20.10.37.21;	author landry;	state Exp;
branches;
next	1.33;
commitid	TZzUe1PacwLcI0DC;

1.33
date	2014.11.20.08.15.07;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	zHQioC77DkYvHHbr;

1.32
date	2014.11.20.01.53.06;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	aY5BQS7xw5Lb9qvd;

1.31
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.30;
commitid	OBNa5kfxQ2UXoiIw;

1.30
date	2013.10.20.21.24.00;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.20.16.44.47;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.18.17.38.34;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2013.08.20.17.44.34;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.28.20.06.50;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2013.06.11.18.15.55;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2013.05.17.12.03.11;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.25.19.49.08;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.28.12.48.14;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.01.12.00.41.03;	author chl;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.20.18.49.12;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.02.18.02.53;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.02.15.55.18;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.10.20.03.38;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.08.16.34.55;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.15.20.23.10;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.01.11.49.31;	author pascoe;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.30.23.13.47;	author pascoe;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.17.11.21.08;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.12.02.31.01;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.27.22.17.49;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.23.22.02.08;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.17.14.49.51;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.28.22.10.03;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.02.19.21.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.18.04.32.44;	author nate;	state Exp;
branches
	1.1.4.1
	1.1.8.1;
next	;

1.1.4.1
date	2001.05.14.22.26.15;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.30.08.19.19;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.56.31;	author niklas;	state Exp;
branches;
next	;

1.1.8.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Implement counter-clockwise rotation.

ok bcook@@, stsp@@
@
text
@/*	$OpenBSD: rasops.c,v 1.46 2017/08/13 22:28:23 kettenis Exp $	*/
/*	$NetBSD: rasops.c,v 1.35 2001/02/02 06:01:01 marcus Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Doran.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/task.h>

#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wsfont/wsfont.h>
#include <dev/rasops/rasops.h>

#ifndef _KERNEL
#include <errno.h>
#endif

/* ANSI colormap (R,G,B) */

#define	NORMAL_BLACK	0x000000
#define	NORMAL_RED	0x7f0000
#define	NORMAL_GREEN	0x007f00
#define	NORMAL_BROWN	0x7f7f00
#define	NORMAL_BLUE	0x00007f
#define	NORMAL_MAGENTA	0x7f007f
#define	NORMAL_CYAN	0x007f7f
#define	NORMAL_WHITE	0xc7c7c7	/* XXX too dim? */

#define	HILITE_BLACK	0x7f7f7f
#define	HILITE_RED	0xff0000
#define	HILITE_GREEN	0x00ff00
#define	HILITE_BROWN	0xffff00
#define	HILITE_BLUE	0x0000ff
#define	HILITE_MAGENTA	0xff00ff
#define	HILITE_CYAN	0x00ffff
#define	HILITE_WHITE	0xffffff

const u_char rasops_cmap[256 * 3] = {
#define	_C(x)	((x) & 0xff0000) >> 16, ((x) & 0x00ff00) >> 8, ((x) & 0x0000ff)

	_C(NORMAL_BLACK),
	_C(NORMAL_RED),
	_C(NORMAL_GREEN),
	_C(NORMAL_BROWN),
	_C(NORMAL_BLUE),
	_C(NORMAL_MAGENTA),
	_C(NORMAL_CYAN),
	_C(NORMAL_WHITE),

	_C(HILITE_BLACK),
	_C(HILITE_RED),
	_C(HILITE_GREEN),
	_C(HILITE_BROWN),
	_C(HILITE_BLUE),
	_C(HILITE_MAGENTA),
	_C(HILITE_CYAN),
	_C(HILITE_WHITE),

	/*
	 * For the cursor, we need the last 16 colors to be the
	 * opposite of the first 16. Fill the intermediate space with
	 * white completely for simplicity.
	 */
#define _CMWHITE16 \
	_C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), \
	_C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), \
	_C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), \
	_C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE),
	_CMWHITE16 _CMWHITE16 _CMWHITE16 _CMWHITE16 _CMWHITE16
	_CMWHITE16 _CMWHITE16 _CMWHITE16 _CMWHITE16 _CMWHITE16
	_CMWHITE16 _CMWHITE16 _CMWHITE16 _CMWHITE16
#undef _CMWHITE16

	_C(~HILITE_WHITE),
	_C(~HILITE_CYAN),
	_C(~HILITE_MAGENTA),
	_C(~HILITE_BLUE),
	_C(~HILITE_BROWN),
	_C(~HILITE_GREEN),
	_C(~HILITE_RED),
	_C(~HILITE_BLACK),

	_C(~NORMAL_WHITE),
	_C(~NORMAL_CYAN),
	_C(~NORMAL_MAGENTA),
	_C(~NORMAL_BLUE),
	_C(~NORMAL_BROWN),
	_C(~NORMAL_GREEN),
	_C(~NORMAL_RED),
	_C(~NORMAL_BLACK),

#undef	_C
};

/* True if color is gray */
const u_char rasops_isgray[16] = {
	1, 0, 0, 0,
	0, 0, 0, 1,
	1, 0, 0, 0,
	0, 0, 0, 1
};

/* Generic functions */
int	rasops_copycols(void *, int, int, int, int);
int	rasops_copyrows(void *, int, int, int);
int	rasops_mapchar(void *, int, u_int *);
int	rasops_cursor(void *, int, int, int);
int	rasops_alloc_cattr(void *, int, int, int, long *);
int	rasops_alloc_mattr(void *, int, int, int, long *);
int	rasops_do_cursor(struct rasops_info *);
void	rasops_init_devcmap(struct rasops_info *);
void	rasops_unpack_attr(void *, long, int *, int *, int *);
#if NRASOPS_BSWAP > 0
static void slow_bcopy(void *, void *, size_t);
#endif
#if NRASOPS_ROTATION > 0
void	rasops_copychar(void *, int, int, int, int);
int	rasops_copycols_rotated(void *, int, int, int, int);
int	rasops_copyrows_rotated(void *, int, int, int);
int	rasops_erasecols_rotated(void *, int, int, int, long);
int	rasops_eraserows_rotated(void *, int, int, long);
int	rasops_putchar_rotated(void *, int, int, u_int, long);
void	rasops_rotate_font(int *, int);

/*
 * List of all rotated fonts
 */
SLIST_HEAD(, rotatedfont) rotatedfonts = SLIST_HEAD_INITIALIZER(rotatedfonts);
struct	rotatedfont {
	SLIST_ENTRY(rotatedfont) rf_next;
	int rf_cookie;
	int rf_rotated;
};
#endif

void	rasops_doswitch(void *);
int	rasops_vcons_cursor(void *, int, int, int);
int	rasops_vcons_mapchar(void *, int, u_int *);
int	rasops_vcons_putchar(void *, int, int, u_int, long);
int	rasops_vcons_copycols(void *, int, int, int, int);
int	rasops_vcons_erasecols(void *, int, int, int, long);
int	rasops_vcons_copyrows(void *, int, int, int);
int	rasops_vcons_eraserows(void *, int, int, long);
int	rasops_vcons_alloc_attr(void *, int, int, int, long *);
void	rasops_vcons_unpack_attr(void *, long, int *, int *, int *);

int	rasops_wronly_putchar(void *, int, int, u_int, long);
int	rasops_wronly_copycols(void *, int, int, int, int);
int	rasops_wronly_erasecols(void *, int, int, int, long);
int	rasops_wronly_copyrows(void *, int, int, int);
int	rasops_wronly_eraserows(void *, int, int, long);

int	rasops_add_font(struct rasops_info *, struct wsdisplay_font *);
int	rasops_use_font(struct rasops_info *, struct wsdisplay_font *);
int	rasops_list_font_cb(void *, struct wsdisplay_font *);

/*
 * Initialize a 'rasops_info' descriptor.
 */
int
rasops_init(struct rasops_info *ri, int wantrows, int wantcols)
{

#ifdef _KERNEL
	/* Select a font if the caller doesn't care */
	if (ri->ri_font == NULL) {
		int cookie;

		wsfont_init();

		if (ri->ri_width > 80*12)
			/* High res screen, choose a big font */
			cookie = wsfont_find(NULL, 12, 0, 0);
		else
			/*  lower res, choose a 8 pixel wide font */
			cookie = wsfont_find(NULL, 8, 0, 0);

		if (cookie <= 0)
			cookie = wsfont_find(NULL, 0, 0, 0);

		if (cookie <= 0) {
			printf("rasops_init: font table is empty\n");
			return (-1);
		}

#if NRASOPS_ROTATION > 0
		/*
		 * Pick the rotated version of this font. This will create it
		 * if necessary.
		 */
		if (ri->ri_flg & (RI_ROTATE_CW | RI_ROTATE_CCW))
			rasops_rotate_font(&cookie,
			    ISSET(ri->ri_flg, RI_ROTATE_CCW));
#endif

		if (wsfont_lock(cookie, &ri->ri_font,
		    WSDISPLAY_FONTORDER_L2R, WSDISPLAY_FONTORDER_L2R) <= 0) {
			printf("rasops_init: couldn't lock font\n");
			return (-1);
		}

		ri->ri_wsfcookie = cookie;
	}
#endif

	/* This should never happen in reality... */
#ifdef DEBUG
	if ((long)ri->ri_bits & 3) {
		printf("rasops_init: bits not aligned on 32-bit boundary\n");
		return (-1);
	}

	if ((int)ri->ri_stride & 3) {
		printf("rasops_init: stride not aligned on 32-bit boundary\n");
		return (-1);
	}
#endif

	if (rasops_reconfig(ri, wantrows, wantcols))
		return (-1);

	LIST_INIT(&ri->ri_screens);
	ri->ri_nscreens = 0;

	ri->ri_putchar = ri->ri_ops.putchar;
	ri->ri_copycols = ri->ri_ops.copycols;
	ri->ri_erasecols = ri->ri_ops.erasecols;
	ri->ri_copyrows = ri->ri_ops.copyrows;
	ri->ri_eraserows = ri->ri_ops.eraserows;
	ri->ri_alloc_attr = ri->ri_ops.alloc_attr;

	if (ri->ri_flg & RI_VCONS) {
		void *cookie;
		int curx, cury;
		long attr;

		if (rasops_alloc_screen(ri, &cookie, &curx, &cury, &attr))
			return (-1);

		ri->ri_active = cookie;

		ri->ri_ops.cursor = rasops_vcons_cursor;
		ri->ri_ops.mapchar = rasops_vcons_mapchar;
		ri->ri_ops.putchar = rasops_vcons_putchar;
		ri->ri_ops.copycols = rasops_vcons_copycols;
		ri->ri_ops.erasecols = rasops_vcons_erasecols;
		ri->ri_ops.copyrows = rasops_vcons_copyrows;
		ri->ri_ops.eraserows = rasops_vcons_eraserows;
		ri->ri_ops.alloc_attr = rasops_vcons_alloc_attr;
		ri->ri_ops.unpack_attr = rasops_vcons_unpack_attr;
	} else if ((ri->ri_flg & RI_WRONLY) && ri->ri_bs != NULL) {
		long attr;
		int i;

		ri->ri_ops.putchar = rasops_wronly_putchar;
		ri->ri_ops.copycols = rasops_wronly_copycols;
		ri->ri_ops.erasecols = rasops_wronly_erasecols;
		ri->ri_ops.copyrows = rasops_wronly_copyrows;
		ri->ri_ops.eraserows = rasops_wronly_eraserows;

		ri->ri_alloc_attr(ri, 0, 0, 0, &attr);
		for (i = 0; i < ri->ri_rows * ri->ri_cols; i++) {
			ri->ri_bs[i].uc = ' ';
			ri->ri_bs[i].attr = attr;
		}
	}

	task_set(&ri->ri_switchtask, rasops_doswitch, ri);

	rasops_init_devcmap(ri);
	return (0);
}

/*
 * Reconfigure (because parameters have changed in some way).
 */
int
rasops_reconfig(struct rasops_info *ri, int wantrows, int wantcols)
{
	int l, bpp, s;

	s = splhigh();

	if (ri->ri_font->fontwidth > 32 || ri->ri_font->fontwidth < 4)
		panic("rasops_init: fontwidth assumptions botched!");

	/* Need this to frob the setup below */
	bpp = (ri->ri_depth == 15 ? 16 : ri->ri_depth);

	if ((ri->ri_flg & RI_CFGDONE) != 0)
		ri->ri_bits = ri->ri_origbits;

	/* Don't care if the caller wants a hideously small console */
	if (wantrows < 10)
		wantrows = 10;

	if (wantcols < 20)
		wantcols = 20;

	/* Now constrain what they get */
	ri->ri_emuwidth = ri->ri_font->fontwidth * wantcols;
	ri->ri_emuheight = ri->ri_font->fontheight * wantrows;

	if (ri->ri_emuwidth > ri->ri_width)
		ri->ri_emuwidth = ri->ri_width;

	if (ri->ri_emuheight > ri->ri_height)
		ri->ri_emuheight = ri->ri_height;

	/* Reduce width until aligned on a 32-bit boundary */
	while ((ri->ri_emuwidth * bpp & 31) != 0)
		ri->ri_emuwidth--;

#if NRASOPS_ROTATION > 0
	if (ri->ri_flg & (RI_ROTATE_CW | RI_ROTATE_CCW)) {
		ri->ri_rows = ri->ri_emuwidth / ri->ri_font->fontwidth;
		ri->ri_cols = ri->ri_emuheight / ri->ri_font->fontheight;
	} else
#endif
	{
		ri->ri_cols = ri->ri_emuwidth / ri->ri_font->fontwidth;
		ri->ri_rows = ri->ri_emuheight / ri->ri_font->fontheight;
	}
	ri->ri_emustride = ri->ri_emuwidth * bpp >> 3;
	ri->ri_delta = ri->ri_stride - ri->ri_emustride;
	ri->ri_ccol = 0;
	ri->ri_crow = 0;
	ri->ri_pelbytes = bpp >> 3;

	ri->ri_xscale = (ri->ri_font->fontwidth * bpp) >> 3;
	ri->ri_yscale = ri->ri_font->fontheight * ri->ri_stride;
	ri->ri_fontscale = ri->ri_font->fontheight * ri->ri_font->stride;

#ifdef DEBUG
	if ((ri->ri_delta & 3) != 0)
		panic("rasops_init: ri_delta not aligned on 32-bit boundary");
#endif
	/* Clear the entire display */
	if ((ri->ri_flg & RI_CLEAR) != 0) {
		memset(ri->ri_bits, 0, ri->ri_stride * ri->ri_height);
		ri->ri_flg &= ~RI_CLEARMARGINS;
	}

	/* Now centre our window if needs be */
	ri->ri_origbits = ri->ri_bits;

	if ((ri->ri_flg & RI_CENTER) != 0) {
		ri->ri_bits += (((ri->ri_width * bpp >> 3) -
		    ri->ri_emustride) >> 1) & ~3;
		ri->ri_bits += ((ri->ri_height - ri->ri_emuheight) >> 1) *
		    ri->ri_stride;

		ri->ri_yorigin = (int)(ri->ri_bits - ri->ri_origbits)
		   / ri->ri_stride;
		ri->ri_xorigin = (((int)(ri->ri_bits - ri->ri_origbits)
		   % ri->ri_stride) * 8 / bpp);
	} else
		ri->ri_xorigin = ri->ri_yorigin = 0;

	/* Clear the margins */
	if ((ri->ri_flg & RI_CLEARMARGINS) != 0) {
		memset(ri->ri_origbits, 0, ri->ri_bits - ri->ri_origbits);
		for (l = 0; l < ri->ri_emuheight; l++)
			memset(ri->ri_bits + ri->ri_emustride +
			    l * ri->ri_stride, 0,
			    ri->ri_stride - ri->ri_emustride);
		memset(ri->ri_bits + ri->ri_emuheight * ri->ri_stride, 0,
		    (ri->ri_origbits + ri->ri_height * ri->ri_stride) -
		    (ri->ri_bits + ri->ri_emuheight * ri->ri_stride));
	}

	/*
	 * Fill in defaults for operations set.  XXX this nukes private
	 * routines used by accelerated fb drivers.
	 */
	ri->ri_ops.mapchar = rasops_mapchar;
	ri->ri_ops.copyrows = rasops_copyrows;
	ri->ri_ops.copycols = rasops_copycols;
	ri->ri_ops.erasecols = rasops_erasecols;
	ri->ri_ops.eraserows = rasops_eraserows;
	ri->ri_ops.cursor = rasops_cursor;
	ri->ri_ops.unpack_attr = rasops_unpack_attr;
	ri->ri_do_cursor = rasops_do_cursor;
	ri->ri_updatecursor = NULL;

	if (ri->ri_depth < 8 || (ri->ri_flg & RI_FORCEMONO) != 0) {
		ri->ri_ops.alloc_attr = rasops_alloc_mattr;
		ri->ri_caps = WSSCREEN_UNDERLINE | WSSCREEN_REVERSE;
	} else {
		ri->ri_ops.alloc_attr = rasops_alloc_cattr;
		ri->ri_caps = WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
		    WSSCREEN_WSCOLORS | WSSCREEN_REVERSE;
	}

	switch (ri->ri_depth) {
#if NRASOPS1 > 0
	case 1:
		rasops1_init(ri);
		break;
#endif
#if NRASOPS4 > 0
	case 4:
		rasops4_init(ri);
		break;
#endif
#if NRASOPS8 > 0
	case 8:
		rasops8_init(ri);
		break;
#endif
#if NRASOPS15 > 0 || NRASOPS16 > 0
	case 15:
	case 16:
		rasops15_init(ri);
		break;
#endif
#if NRASOPS24 > 0
	case 24:
		rasops24_init(ri);
		break;
#endif
#if NRASOPS32 > 0
	case 32:
		rasops32_init(ri);
		break;
#endif
	default:
		ri->ri_flg &= ~RI_CFGDONE;
		splx(s);
		return (-1);
	}

#if NRASOPS_ROTATION > 0
	if (ri->ri_flg & (RI_ROTATE_CW | RI_ROTATE_CCW)) {
		ri->ri_real_ops = ri->ri_ops;
		ri->ri_ops.copycols = rasops_copycols_rotated;
		ri->ri_ops.copyrows = rasops_copyrows_rotated;
		ri->ri_ops.erasecols = rasops_erasecols_rotated;
		ri->ri_ops.eraserows = rasops_eraserows_rotated;
		ri->ri_ops.putchar = rasops_putchar_rotated;
	}
#endif

	ri->ri_flg |= RI_CFGDONE;
	splx(s);
	return (0);
}

/*
 * Map a character.
 */
int
rasops_mapchar(void *cookie, int c, u_int *cp)
{
	struct rasops_info *ri;

	ri = (struct rasops_info *)cookie;

#ifdef DIAGNOSTIC
	if (ri->ri_font == NULL)
		panic("rasops_mapchar: no font selected");
#endif
	if (ri->ri_font->encoding != WSDISPLAY_FONTENC_ISO) {

		if ( (c = wsfont_map_unichar(ri->ri_font, c)) < 0) {

			*cp = '?';
			return (0);

		}
	}


	if (c < ri->ri_font->firstchar) {
		*cp = '?';
		return (0);
	}

	if (c - ri->ri_font->firstchar >= ri->ri_font->numchars) {
		*cp = '?';
		return (0);
	}

	*cp = c;
	return (5);
}

/*
 * Allocate a color attribute.
 */
int
rasops_alloc_cattr(void *cookie, int fg, int bg, int flg, long *attr)
{
	int swap;

#ifdef RASOPS_CLIPPING
	fg &= 7;
	bg &= 7;
#endif
	if ((flg & WSATTR_BLINK) != 0)
		return (EINVAL);

	if ((flg & WSATTR_WSCOLORS) == 0) {
		fg = WS_DEFAULT_FG;
		bg = WS_DEFAULT_BG;
	}

	if ((flg & WSATTR_REVERSE) != 0) {
		swap = fg;
		fg = bg;
		bg = swap;
	}

	if ((flg & WSATTR_HILIT) != 0)
		fg += 8;

	flg = ((flg & WSATTR_UNDERLINE) ? 1 : 0);

	if (rasops_isgray[fg])
		flg |= 2;

	if (rasops_isgray[bg])
		flg |= 4;

	*attr = (bg << 16) | (fg << 24) | flg;
	return (0);
}

/*
 * Allocate a mono attribute.
 */
int
rasops_alloc_mattr(void *cookie, int fg, int bg, int flg, long *attr)
{
	int swap;

	if ((flg & (WSATTR_BLINK | WSATTR_HILIT | WSATTR_WSCOLORS)) != 0)
		return (EINVAL);

	fg = 1;
	bg = 0;

	if ((flg & WSATTR_REVERSE) != 0) {
		swap = fg;
		fg = bg;
		bg = swap;
	}

	*attr = (bg << 16) | (fg << 24) | ((flg & WSATTR_UNDERLINE) ? 7 : 6);
	return (0);
}

/*
 * Copy rows.
 */
int
rasops_copyrows(void *cookie, int src, int dst, int num)
{
	int32_t *sp, *dp, *srp, *drp;
	struct rasops_info *ri;
	int n8, n1, cnt, delta;

	ri = (struct rasops_info *)cookie;

#ifdef RASOPS_CLIPPING
	if (dst == src)
		return 0;

	if (src < 0) {
		num += src;
		src = 0;
	}

	if ((src + num) > ri->ri_rows)
		num = ri->ri_rows - src;

	if (dst < 0) {
		num += dst;
		dst = 0;
	}

	if ((dst + num) > ri->ri_rows)
		num = ri->ri_rows - dst;

	if (num <= 0)
		return 0;
#endif

	num *= ri->ri_font->fontheight;
	n8 = ri->ri_emustride >> 5;
	n1 = (ri->ri_emustride >> 2) & 7;

	if (dst < src) {
		srp = (int32_t *)(ri->ri_bits + src * ri->ri_yscale);
		drp = (int32_t *)(ri->ri_bits + dst * ri->ri_yscale);
		delta = ri->ri_stride;
	} else {
		src = ri->ri_font->fontheight * src + num - 1;
		dst = ri->ri_font->fontheight * dst + num - 1;
		srp = (int32_t *)(ri->ri_bits + src * ri->ri_stride);
		drp = (int32_t *)(ri->ri_bits + dst * ri->ri_stride);
		delta = -ri->ri_stride;
	}

	while (num--) {
		dp = drp;
		sp = srp;
		DELTA(drp, delta, int32_t *);
		DELTA(srp, delta, int32_t *);

		for (cnt = n8; cnt; cnt--) {
			dp[0] = sp[0];
			dp[1] = sp[1];
			dp[2] = sp[2];
			dp[3] = sp[3];
			dp[4] = sp[4];
			dp[5] = sp[5];
			dp[6] = sp[6];
			dp[7] = sp[7];
			dp += 8;
			sp += 8;
		}

		for (cnt = n1; cnt; cnt--)
			*dp++ = *sp++;
	}

	return 0;
}

/*
 * Copy columns. This is slow, and hard to optimize due to alignment,
 * and the fact that we have to copy both left->right and right->left.
 * We simply cop-out here and use bcopy(), since it handles all of
 * these cases anyway.
 */
int
rasops_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct rasops_info *ri;
	u_char *sp, *dp;
	int height;

	ri = (struct rasops_info *)cookie;

#ifdef RASOPS_CLIPPING
	if (dst == src)
		return 0;

	/* Catches < 0 case too */
	if ((unsigned)row >= (unsigned)ri->ri_rows)
		return 0;

	if (src < 0) {
		num += src;
		src = 0;
	}

	if ((src + num) > ri->ri_cols)
		num = ri->ri_cols - src;

	if (dst < 0) {
		num += dst;
		dst = 0;
	}

	if ((dst + num) > ri->ri_cols)
		num = ri->ri_cols - dst;

	if (num <= 0)
		return 0;
#endif

	num *= ri->ri_xscale;
	row *= ri->ri_yscale;
	height = ri->ri_font->fontheight;

	sp = ri->ri_bits + row + src * ri->ri_xscale;
	dp = ri->ri_bits + row + dst * ri->ri_xscale;

#if NRASOPS_BSWAP > 0
	if (ri->ri_flg & RI_BSWAP) {
		while (height--) {
			slow_bcopy(sp, dp, num);
			dp += ri->ri_stride;
			sp += ri->ri_stride;
		}
	} else
#endif
	{
		while (height--) {
			memmove(dp, sp, num);
			dp += ri->ri_stride;
			sp += ri->ri_stride;
		}
	}

	return 0;
}

/*
 * Turn cursor off/on.
 */
int
rasops_cursor(void *cookie, int on, int row, int col)
{
	struct rasops_info *ri;
	int rc;

	ri = (struct rasops_info *)cookie;

	/* Turn old cursor off */
	if ((ri->ri_flg & RI_CURSOR) != 0) {
#ifdef RASOPS_CLIPPING
		if ((ri->ri_flg & RI_CURSORCLIP) == 0)
#endif
			if ((rc = ri->ri_do_cursor(ri)) != 0)
				return rc;
		ri->ri_flg &= ~RI_CURSOR;
	}

	/* Select new cursor */
#ifdef RASOPS_CLIPPING
	ri->ri_flg &= ~RI_CURSORCLIP;

	if (row < 0 || row >= ri->ri_rows)
		ri->ri_flg |= RI_CURSORCLIP;
	else if (col < 0 || col >= ri->ri_cols)
		ri->ri_flg |= RI_CURSORCLIP;
#endif
	ri->ri_crow = row;
	ri->ri_ccol = col;

	if (ri->ri_updatecursor != NULL)
		ri->ri_updatecursor(ri);

	if (on) {
#ifdef RASOPS_CLIPPING
		if ((ri->ri_flg & RI_CURSORCLIP) == 0)
#endif
			if ((rc = ri->ri_do_cursor(ri)) != 0)
				return rc;
		ri->ri_flg |= RI_CURSOR;
	}

	return 0;
}

/*
 * Make the device colormap
 */
void
rasops_init_devcmap(struct rasops_info *ri)
{
	int i;
#if NRASOPS15 > 0 || NRASOPS16 > 0 || NRASOPS24 > 0 || NRASOPS32 > 0
	const u_char *p;
#endif
#if NRASOPS4 > 0 || NRASOPS15 > 0 || NRASOPS16 > 0 || NRASOPS24 > 0 || NRASOPS32 > 0
	int c;
#endif

	if (ri->ri_depth == 1 || (ri->ri_flg & RI_FORCEMONO) != 0) {
		ri->ri_devcmap[0] = 0;
		for (i = 1; i < 16; i++)
			ri->ri_devcmap[i] = 0xffffffff;
		return;
	}

	switch (ri->ri_depth) {
#if NRASOPS4 > 0
	case 4:
		for (i = 0; i < 16; i++) {
			c = i | (i << 4);
			ri->ri_devcmap[i] = c | (c<<8) | (c<<16) | (c<<24);
		}
		return;
#endif
#if NRASOPS8 > 0
	case 8:
		for (i = 0; i < 16; i++)
			ri->ri_devcmap[i] = i | (i<<8) | (i<<16) | (i<<24);
		return;
#endif
	default:
		break;
	}

#if NRASOPS15 > 0 || NRASOPS16 > 0 || NRASOPS24 > 0 || NRASOPS32 > 0
	p = rasops_cmap;

	for (i = 0; i < 16; i++) {
		if (ri->ri_rnum <= 8)
			c = (*p >> (8 - ri->ri_rnum)) << ri->ri_rpos;
		else
			c = (*p << (ri->ri_rnum - 8)) << ri->ri_rpos;
		p++;

		if (ri->ri_gnum <= 8)
			c |= (*p >> (8 - ri->ri_gnum)) << ri->ri_gpos;
		else
			c |= (*p << (ri->ri_gnum - 8)) << ri->ri_gpos;
		p++;

		if (ri->ri_bnum <= 8)
			c |= (*p >> (8 - ri->ri_bnum)) << ri->ri_bpos;
		else
			c |= (*p << (ri->ri_bnum - 8)) << ri->ri_bpos;
		p++;

		/* Fill the word for generic routines, which want this */
		if (ri->ri_depth == 24)
			c = c | ((c & 0xff) << 24);
		else if (ri->ri_depth <= 16)
			c = c | (c << 16);

		/* 24bpp does bswap on the fly. {32,16,15}bpp do it here. */
#if NRASOPS_BSWAP > 0
		if ((ri->ri_flg & RI_BSWAP) == 0)
			ri->ri_devcmap[i] = c;
		else if (ri->ri_depth == 32)
			ri->ri_devcmap[i] = swap32(c);
		else if (ri->ri_depth == 16 || ri->ri_depth == 15)
			ri->ri_devcmap[i] = swap16(c);
		else
			ri->ri_devcmap[i] = c;
#else
		ri->ri_devcmap[i] = c;
#endif
	}
#endif
}

/*
 * Unpack a rasops attribute
 */
void
rasops_unpack_attr(void *cookie, long attr, int *fg, int *bg, int *underline)
{
	*fg = ((u_int)attr >> 24) & 0xf;
	*bg = ((u_int)attr >> 16) & 0xf;
	if (underline != NULL)
		*underline = (u_int)attr & 1;
}

/*
 * Erase rows
 */
int
rasops_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri;
	int np, nw, cnt, delta;
	int32_t *dp, clr;

	ri = (struct rasops_info *)cookie;

#ifdef RASOPS_CLIPPING
	if (row < 0) {
		num += row;
		row = 0;
	}

	if ((row + num) > ri->ri_rows)
		num = ri->ri_rows - row;

	if (num <= 0)
		return 0;
#endif

	clr = ri->ri_devcmap[(attr >> 16) & 0xf];

	/*
	 * XXX The wsdisplay_emulops interface seems a little deficient in
	 * that there is no way to clear the *entire* screen. We provide a
	 * workaround here: if the entire console area is being cleared, and
	 * the RI_FULLCLEAR flag is set, clear the entire display.
	 */
	if (num == ri->ri_rows && (ri->ri_flg & RI_FULLCLEAR) != 0) {
		np = ri->ri_stride >> 5;
		nw = (ri->ri_stride >> 2) & 7;
		num = ri->ri_height;
		dp = (int32_t *)ri->ri_origbits;
		delta = 0;
	} else {
		np = ri->ri_emustride >> 5;
		nw = (ri->ri_emustride >> 2) & 7;
		num *= ri->ri_font->fontheight;
		dp = (int32_t *)(ri->ri_bits + row * ri->ri_yscale);
		delta = ri->ri_delta;
	}

	while (num--) {
		for (cnt = np; cnt; cnt--) {
			dp[0] = clr;
			dp[1] = clr;
			dp[2] = clr;
			dp[3] = clr;
			dp[4] = clr;
			dp[5] = clr;
			dp[6] = clr;
			dp[7] = clr;
			dp += 8;
		}

		for (cnt = nw; cnt; cnt--) {
			*(int32_t *)dp = clr;
			DELTA(dp, 4, int32_t *);
		}

		DELTA(dp, delta, int32_t *);
	}

	return 0;
}

/*
 * Actually turn the cursor on or off. This does the dirty work for
 * rasops_cursor().
 */
int
rasops_do_cursor(struct rasops_info *ri)
{
	int full1, height, cnt, slop1, slop2, row, col;
	u_char *dp, *rp;

#if NRASOPS_ROTATION > 0
	if (ri->ri_flg & RI_ROTATE_CW) {
		/* Rotate rows/columns */
		row = ri->ri_ccol;
		col = ri->ri_rows - ri->ri_crow - 1;
	} else if (ri->ri_flg & RI_ROTATE_CCW) {
		/* Rotate rows/columns */
		row = ri->ri_cols - ri->ri_ccol - 1;
		col = ri->ri_crow;
	} else		
#endif
	{
		row = ri->ri_crow;
		col = ri->ri_ccol;
	}

	rp = ri->ri_bits + row * ri->ri_yscale + col * ri->ri_xscale;
	height = ri->ri_font->fontheight;
	slop1 = (4 - ((long)rp & 3)) & 3;

	if (slop1 > ri->ri_xscale)
		slop1 = ri->ri_xscale;

	slop2 = (ri->ri_xscale - slop1) & 3;
	full1 = (ri->ri_xscale - slop1 - slop2) >> 2;

	if ((slop1 | slop2) == 0) {
		/* A common case */
		while (height--) {
			dp = rp;
			rp += ri->ri_stride;

			for (cnt = full1; cnt; cnt--) {
				*(int32_t *)dp ^= ~0;
				dp += 4;
			}
		}
	} else {
		/* XXX this is stupid.. use masks instead */
		while (height--) {
			dp = rp;
			rp += ri->ri_stride;

			if (slop1 & 1)
				*dp++ ^= ~0;

			if (slop1 & 2) {
				*(int16_t *)dp ^= ~0;
				dp += 2;
			}

			for (cnt = full1; cnt; cnt--) {
				*(int32_t *)dp ^= ~0;
				dp += 4;
			}

			if (slop2 & 1)
				*dp++ ^= ~0;

			if (slop2 & 2)
				*(int16_t *)dp ^= ~0;
		}
	}

	return 0;
}

/*
 * Erase columns.
 */
int
rasops_erasecols(void *cookie, int row, int col, int num, long attr)
{
	int n8, height, cnt, slop1, slop2, clr;
	struct rasops_info *ri;
	int32_t *rp, *dp;

	ri = (struct rasops_info *)cookie;

#ifdef RASOPS_CLIPPING
	if ((unsigned)row >= (unsigned)ri->ri_rows)
		return 0;

	if (col < 0) {
		num += col;
		col = 0;
	}

	if ((col + num) > ri->ri_cols)
		num = ri->ri_cols - col;

	if (num <= 0)
		return 0;
#endif

	num = num * ri->ri_xscale;
	rp = (int32_t *)(ri->ri_bits + row*ri->ri_yscale + col*ri->ri_xscale);
	height = ri->ri_font->fontheight;
	clr = ri->ri_devcmap[(attr >> 16) & 0xf];

	/* Don't bother using the full loop for <= 32 pels */
	if (num <= 32) {
		if (((num | ri->ri_xscale) & 3) == 0) {
			/* Word aligned blt */
			num >>= 2;

			while (height--) {
				dp = rp;
				DELTA(rp, ri->ri_stride, int32_t *);

				for (cnt = num; cnt; cnt--)
					*dp++ = clr;
			}
		} else if (((num | ri->ri_xscale) & 1) == 0) {
			/*
			 * Halfword aligned blt. This is needed so the
			 * 15/16 bit ops can use this function.
			 */
			num >>= 1;

			while (height--) {
				dp = rp;
				DELTA(rp, ri->ri_stride, int32_t *);

				for (cnt = num; cnt; cnt--) {
					*(int16_t *)dp = clr;
					DELTA(dp, 2, int32_t *);
				}
			}
		} else {
			while (height--) {
				dp = rp;
				DELTA(rp, ri->ri_stride, int32_t *);

				for (cnt = num; cnt; cnt--) {
					*(u_char *)dp = clr;
					DELTA(dp, 1, int32_t *);
				}
			}
		}

		return 0;
	}

	slop1 = (4 - ((long)rp & 3)) & 3;
	slop2 = (num - slop1) & 3;
	num -= slop1 + slop2;
	n8 = num >> 5;
	num = (num >> 2) & 7;

	while (height--) {
		dp = rp;
		DELTA(rp, ri->ri_stride, int32_t *);

		/* Align span to 4 bytes */
		if (slop1 & 1) {
			*(u_char *)dp = clr;
			DELTA(dp, 1, int32_t *);
		}

		if (slop1 & 2) {
			*(int16_t *)dp = clr;
			DELTA(dp, 2, int32_t *);
		}

		/* Write 32 bytes per loop */
		for (cnt = n8; cnt; cnt--) {
			dp[0] = clr;
			dp[1] = clr;
			dp[2] = clr;
			dp[3] = clr;
			dp[4] = clr;
			dp[5] = clr;
			dp[6] = clr;
			dp[7] = clr;
			dp += 8;
		}

		/* Write 4 bytes per loop */
		for (cnt = num; cnt; cnt--)
			*dp++ = clr;

		/* Write unaligned trailing slop */
		if (slop2 & 1) {
			*(u_char *)dp = clr;
			DELTA(dp, 1, int32_t *);
		}

		if (slop2 & 2)
			*(int16_t *)dp = clr;
	}

	return 0;
}

#if NRASOPS_ROTATION > 0
/*
 * Quarter clockwise rotation routines (originally intended for the
 * built-in Zaurus C3x00 display in 16bpp).
 */

#include <sys/malloc.h>

void
rasops_rotate_font(int *cookie, int ccw)
{
	struct rotatedfont *f;
	int ncookie;

	SLIST_FOREACH(f, &rotatedfonts, rf_next) {
		if (f->rf_cookie == *cookie) {
			*cookie = f->rf_rotated;
			return;
		}
	}

	/*
	 * We did not find a rotated version of this font. Ask the wsfont
	 * code to compute one for us.
	 */
	if ((ncookie = wsfont_rotate(*cookie, ccw)) == -1)
		return;

	f = malloc(sizeof(struct rotatedfont), M_DEVBUF, M_WAITOK);
	f->rf_cookie = *cookie;
	f->rf_rotated = ncookie;
	SLIST_INSERT_HEAD(&rotatedfonts, f, rf_next);

	*cookie = ncookie;
}

void
rasops_copychar(void *cookie, int srcrow, int dstrow, int srccol, int dstcol)
{
	struct rasops_info *ri;
	u_char *sp, *dp;
	int height;
	int r_srcrow, r_dstrow, r_srccol, r_dstcol;

	ri = (struct rasops_info *)cookie;

	r_srcrow = srccol;
	r_dstrow = dstcol;
	r_srccol = ri->ri_rows - srcrow - 1;
	r_dstcol = ri->ri_rows - dstrow - 1;

	r_srcrow *= ri->ri_yscale;
	r_dstrow *= ri->ri_yscale;
	height = ri->ri_font->fontheight;

	sp = ri->ri_bits + r_srcrow + r_srccol * ri->ri_xscale;
	dp = ri->ri_bits + r_dstrow + r_dstcol * ri->ri_xscale;

#if NRASOPS_BSWAP > 0
	if (ri->ri_flg & RI_BSWAP) {
		while (height--) {
			slow_bcopy(sp, dp, ri->ri_xscale);
			dp += ri->ri_stride;
			sp += ri->ri_stride;
		}
	} else
#endif
	{
		while (height--) {
			memmove(dp, sp, ri->ri_xscale);
			dp += ri->ri_stride;
			sp += ri->ri_stride;
		}
	}
}

int
rasops_putchar_rotated(void *cookie, int row, int col, u_int uc, long attr)
{
	struct rasops_info *ri;
	u_char *rp;
	int height;
	int rc;

	ri = (struct rasops_info *)cookie;

	if (ri->ri_flg & RI_ROTATE_CW)
		row = ri->ri_rows - row - 1;
	else
		col = ri->ri_cols - col - 1;

	/* Do rotated char sans (side)underline */
	rc = ri->ri_real_ops.putchar(cookie, col, row, uc, attr & ~1);
	if (rc != 0)
		return rc;

	/* Do rotated underline */
	rp = ri->ri_bits + col * ri->ri_yscale + row * ri->ri_xscale;
	height = ri->ri_font->fontheight;

	/* XXX this assumes 16-bit color depth */
	if ((attr & 1) != 0) {
		int16_t c = (int16_t)ri->ri_devcmap[((u_int)attr >> 24) & 0xf];

		while (height--) {
			*(int16_t *)rp = c;
			rp += ri->ri_stride;
		}
	}

	return 0;
}

int
rasops_erasecols_rotated(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri;
	int i;
	int rc;

	ri = (struct rasops_info *)cookie;

	for (i = col; i < col + num; i++) {
		rc = rasops_putchar_rotated(cookie, row, i, ' ', attr);
		if (rc != 0)
			return rc;
	}

	return 0;
}

/* XXX: these could likely be optimised somewhat. */
int
rasops_copyrows_rotated(void *cookie, int src, int dst, int num)
{
	struct rasops_info *ri = (struct rasops_info *)cookie;
	int col, roff;

	if (src > dst) {
		for (roff = 0; roff < num; roff++)
			for (col = 0; col < ri->ri_cols; col++)
				rasops_copychar(cookie, src + roff, dst + roff,
				    col, col);
	} else {
		for (roff = num - 1; roff >= 0; roff--)
			for (col = 0; col < ri->ri_cols; col++)
				rasops_copychar(cookie, src + roff, dst + roff,
				    col, col);
	}

	return 0;
}

int
rasops_copycols_rotated(void *cookie, int row, int src, int dst, int num)
{
	int coff;

	if (src > dst) {
		for (coff = 0; coff < num; coff++)
			rasops_copychar(cookie, row, row, src + coff,
			    dst + coff);
	} else {
		for (coff = num - 1; coff >= 0; coff--)
			rasops_copychar(cookie, row, row, src + coff,
			    dst + coff);
	}

	return 0;
}

int
rasops_eraserows_rotated(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri;
	int col, rn;
	int rc;

	ri = (struct rasops_info *)cookie;

	for (rn = row; rn < row + num; rn++)
		for (col = 0; col < ri->ri_cols; col++) {
			rc = rasops_putchar_rotated(cookie, rn, col, ' ', attr);
			if (rc != 0)
				return rc;
		}

	return 0;
}
#endif	/* NRASOPS_ROTATION */

#if NRASOPS_BSWAP > 0
/*
 * Strictly byte-only bcopy() version, to be used with RI_BSWAP, as the
 * regular bcopy() may want to optimize things by doing larger-than-byte
 * reads or write. This may confuse things if src and dst have different
 * alignments.
 */
void
slow_bcopy(void *s, void *d, size_t len)
{
	u_int8_t *src = s;
	u_int8_t *dst = d;

	if ((vaddr_t)dst <= (vaddr_t)src) {
		while (len-- != 0)
			*dst++ = *src++;
	} else {
		src += len;
		dst += len;
		if (len != 0)
			while (--len != 0)
				*--dst = *--src;
	}
}
#endif	/* NRASOPS_BSWAP */

struct rasops_screen {
	LIST_ENTRY(rasops_screen) rs_next;
	struct rasops_info *rs_ri;

	struct wsdisplay_charcell *rs_bs;
	int rs_visible;
	int rs_crow;
	int rs_ccol;
};

int
rasops_alloc_screen(void *v, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct rasops_info *ri = v;
	struct rasops_screen *scr;
	int i;

	scr = malloc(sizeof(*scr), M_DEVBUF, M_NOWAIT);
	if (scr == NULL)
		return (ENOMEM);

	scr->rs_bs = mallocarray(ri->ri_rows,
	    ri->ri_cols * sizeof(struct wsdisplay_charcell), M_DEVBUF,
	    M_NOWAIT);
	if (scr->rs_bs == NULL) {
		free(scr, M_DEVBUF, sizeof(*scr));
		return (ENOMEM);
	}

	*cookiep = scr;
	*curxp = 0;
	*curyp = 0;
	ri->ri_alloc_attr(ri, 0, 0, 0, attrp);

	scr->rs_ri = ri;
	scr->rs_visible = (ri->ri_nscreens == 0);
	scr->rs_crow = -1;
	scr->rs_ccol = -1;

	if (ri->ri_bs && scr->rs_visible) {
		memcpy(scr->rs_bs, ri->ri_bs, ri->ri_rows * ri->ri_cols *
		    sizeof(struct wsdisplay_charcell));
	} else {
		for (i = 0; i < ri->ri_rows * ri->ri_cols; i++) {
			scr->rs_bs[i].uc = ' ';
			scr->rs_bs[i].attr = *attrp;
		}
	}

	LIST_INSERT_HEAD(&ri->ri_screens, scr, rs_next);
	ri->ri_nscreens++;

	return (0);
}

void
rasops_free_screen(void *v, void *cookie)
{
	struct rasops_info *ri = v;
	struct rasops_screen *scr = cookie;

	LIST_REMOVE(scr, rs_next);
	ri->ri_nscreens--;

	free(scr->rs_bs, M_DEVBUF,
	    ri->ri_rows * ri->ri_cols * sizeof(struct wsdisplay_charcell));
	free(scr, M_DEVBUF, sizeof(*scr));
}

int
rasops_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	struct rasops_info *ri = v;

	ri->ri_switchcookie = cookie;
	if (cb) {
		ri->ri_switchcb = cb;
		ri->ri_switchcbarg = cbarg;
		task_add(systq, &ri->ri_switchtask);
		return (EAGAIN);
	}

	rasops_doswitch(ri);
	return (0);
}

void
rasops_doswitch(void *v)
{
	struct rasops_info *ri = v;
	struct rasops_screen *scr = ri->ri_switchcookie;
	int row, col;
	long attr;

	rasops_cursor(ri, 0, 0, 0);
	ri->ri_active->rs_visible = 0;
	ri->ri_alloc_attr(ri, 0, 0, 0, &attr);
	ri->ri_eraserows(ri, 0, ri->ri_rows, attr);
	ri->ri_active = scr;
	ri->ri_active->rs_visible = 1;
	for (row = 0; row < ri->ri_rows; row++) {
		for (col = 0; col < ri->ri_cols; col++) {
			int off = row * scr->rs_ri->ri_cols + col;

			ri->ri_putchar(ri, row, col, scr->rs_bs[off].uc,
			    scr->rs_bs[off].attr);
		}
	}
	if (scr->rs_crow != -1)
		rasops_cursor(ri, 1, scr->rs_crow, scr->rs_ccol);

	if (ri->ri_switchcb)
		(*ri->ri_switchcb)(ri->ri_switchcbarg, 0, 0);
}

int
rasops_getchar(void *v, int row, int col, struct wsdisplay_charcell *cell)
{
	struct rasops_info *ri = v;
	struct rasops_screen *scr = ri->ri_active;

	if (scr == NULL || scr->rs_bs == NULL)
		return (1);

	*cell = scr->rs_bs[row * ri->ri_cols + col];
	return (0);
}

int
rasops_vcons_cursor(void *cookie, int on, int row, int col)
{
	struct rasops_screen *scr = cookie;

	scr->rs_crow = on ? row : -1;
	scr->rs_ccol = on ? col : -1;

	if (!scr->rs_visible)
		return 0;

	return rasops_cursor(scr->rs_ri, on, row, col);
}

int
rasops_vcons_mapchar(void *cookie, int c, u_int *cp)
{
	struct rasops_screen *scr = cookie;

	return rasops_mapchar(scr->rs_ri, c, cp);
}

int
rasops_vcons_putchar(void *cookie, int row, int col, u_int uc, long attr)
{
	struct rasops_screen *scr = cookie;
	int off = row * scr->rs_ri->ri_cols + col;

	scr->rs_bs[off].uc = uc;
	scr->rs_bs[off].attr = attr;

	if (!scr->rs_visible)
		return 0;

	return scr->rs_ri->ri_putchar(scr->rs_ri, row, col, uc, attr);
}

int
rasops_vcons_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct rasops_screen *scr = cookie;
	struct rasops_info *ri = scr->rs_ri;
	int cols = scr->rs_ri->ri_cols;
	int col, rc;

	memmove(&scr->rs_bs[row * cols + dst], &scr->rs_bs[row * cols + src],
	    num * sizeof(struct wsdisplay_charcell));

	if (!scr->rs_visible)
		return 0;

	if ((ri->ri_flg & RI_WRONLY) == 0)
		return ri->ri_copycols(ri, row, src, dst, num);

	for (col = dst; col < dst + num; col++) {
		int off = row * cols + col;

		rc = ri->ri_putchar(ri, row, col,
		    scr->rs_bs[off].uc, scr->rs_bs[off].attr);
		if (rc != 0)
			return rc;
	}

	return 0;
}

int
rasops_vcons_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_screen *scr = cookie;
	int cols = scr->rs_ri->ri_cols;
	int i;

	for (i = 0; i < num; i++) {
		int off = row * cols + col + i;

		scr->rs_bs[off].uc = ' ';
		scr->rs_bs[off].attr = attr;
	}

	if (!scr->rs_visible)
		return 0;

	return scr->rs_ri->ri_erasecols(scr->rs_ri, row, col, num, attr);
}

int
rasops_vcons_copyrows(void *cookie, int src, int dst, int num)
{
	struct rasops_screen *scr = cookie;
	struct rasops_info *ri = scr->rs_ri;
	int cols = ri->ri_cols;
	int row, col, rc;

	memmove(&scr->rs_bs[dst * cols], &scr->rs_bs[src * cols],
	    num * cols * sizeof(struct wsdisplay_charcell));

	if (!scr->rs_visible)
		return 0;

	if ((ri->ri_flg & RI_WRONLY) == 0)
		return ri->ri_copyrows(ri, src, dst, num);

	for (row = dst; row < dst + num; row++) {
		for (col = 0; col < cols; col++) {
			int off = row * cols + col;

			rc = ri->ri_putchar(ri, row, col,
			    scr->rs_bs[off].uc, scr->rs_bs[off].attr);
			if (rc != 0)
				return rc;
		}
	}

	return 0;
}

int
rasops_vcons_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_screen *scr = cookie;
	int cols = scr->rs_ri->ri_cols;
	int i;

	for (i = 0; i < num * cols; i++) {
		int off = row * cols + i;

		scr->rs_bs[off].uc = ' ';
		scr->rs_bs[off].attr = attr;
	}

	if (!scr->rs_visible)
		return 0;

	return scr->rs_ri->ri_eraserows(scr->rs_ri, row, num, attr);
}

int
rasops_vcons_alloc_attr(void *cookie, int fg, int bg, int flg, long *attr)
{
	struct rasops_screen *scr = cookie;

	return scr->rs_ri->ri_alloc_attr(scr->rs_ri, fg, bg, flg, attr);
}

void
rasops_vcons_unpack_attr(void *cookie, long attr, int *fg, int *bg,
    int *underline)
{
	struct rasops_screen *scr = cookie;

	rasops_unpack_attr(scr->rs_ri, attr, fg, bg, underline);
}

int
rasops_wronly_putchar(void *cookie, int row, int col, u_int uc, long attr)
{
	struct rasops_info *ri = cookie;
	int off = row * ri->ri_cols + col;

	ri->ri_bs[off].uc = uc;
	ri->ri_bs[off].attr = attr;

	return ri->ri_putchar(ri, row, col, uc, attr);
}

int
rasops_wronly_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	int cols = ri->ri_cols;
	int col, rc;

	memmove(&ri->ri_bs[row * cols + dst], &ri->ri_bs[row * cols + src],
	    num * sizeof(struct wsdisplay_charcell));

	for (col = dst; col < dst + num; col++) {
		int off = row * cols + col;

		rc = ri->ri_putchar(ri, row, col,
		    ri->ri_bs[off].uc, ri->ri_bs[off].attr);
		if (rc != 0)
			return rc;
	}

	return 0;
}

int
rasops_wronly_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri = cookie;
	int cols = ri->ri_cols;
	int i;

	for (i = 0; i < num; i++) {
		int off = row * cols + col + i;

		ri->ri_bs[off].uc = ' ';
		ri->ri_bs[off].attr = attr;
	}

	return ri->ri_erasecols(ri, row, col, num, attr);
}

int
rasops_wronly_copyrows(void *cookie, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	int cols = ri->ri_cols;
	int row, col, rc;

	memmove(&ri->ri_bs[dst * cols], &ri->ri_bs[src * cols],
	    num * cols * sizeof(struct wsdisplay_charcell));

	for (row = dst; row < dst + num; row++) {
		for (col = 0; col < cols; col++) {
			int off = row * cols + col;

			rc = ri->ri_putchar(ri, row, col,
			    ri->ri_bs[off].uc, ri->ri_bs[off].attr);
			if (rc != 0)
				return rc;
		}
	}

	return 0;
}

int
rasops_wronly_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri = cookie;
	int cols = ri->ri_cols;
	int i;

	for (i = 0; i < num * cols; i++) {
		int off = row * cols + i;

		ri->ri_bs[off].uc = ' ';
		ri->ri_bs[off].attr = attr;
	}

	return ri->ri_eraserows(ri, row, num, attr);
}

/*
 * Font management.
 *
 * Fonts usable on raster frame buffers are managed by wsfont, and are not
 * tied to any particular display.
 */

int
rasops_add_font(struct rasops_info *ri, struct wsdisplay_font *font)
{
	/* only accept matching metrics */
	if (font->fontwidth != ri->ri_font->fontwidth ||
	    font->fontheight != ri->ri_font->fontheight)
		return EINVAL;

	/* for raster consoles, only accept ISO Latin-1 or Unicode encoding */
	if (font->encoding != WSDISPLAY_FONTENC_ISO)
		return EINVAL;

	if (wsfont_add(font, 1) != 0)
		return EEXIST;	/* name collision */

	font->index = -1;	/* do not store in wsdisplay_softc */

	return 0;
}

int
rasops_use_font(struct rasops_info *ri, struct wsdisplay_font *font)
{
	int wsfcookie;
	struct wsdisplay_font *wsf;
	const char *name;

	/* allow an empty font name to revert to the initial font choice */
	name = font->name;
	if (*name == '\0')
		name = NULL;

	wsfcookie = wsfont_find(name, ri->ri_font->fontwidth,
	    ri->ri_font->fontheight, 0);
	if (wsfcookie < 0) {
		wsfcookie = wsfont_find(name, 0, 0, 0);
		if (wsfcookie < 0)
			return ENOENT;	/* font exist, but different metrics */
		else
			return EINVAL;
	}
	if (wsfont_lock(wsfcookie, &wsf, WSDISPLAY_FONTORDER_KNOWN,
	    WSDISPLAY_FONTORDER_KNOWN) < 0)
		return EINVAL;

	/* if (ri->ri_wsfcookie >= 0) */
		wsfont_unlock(ri->ri_wsfcookie);
	ri->ri_wsfcookie = wsfcookie;
	ri->ri_font = wsf;
	ri->ri_fontscale = ri->ri_font->fontheight * ri->ri_font->stride;

	return 0;
}

int
rasops_load_font(void *v, void *cookie, struct wsdisplay_font *font)
{
	struct rasops_info *ri = v;

	/*
	 * For now, we want to only allow loading fonts of the same
	 * metrics as the currently in-use font. This requires the
	 * rasops struct to have been correctly configured, and a
	 * font to have been selected.
	 */
	if ((ri->ri_flg & RI_CFGDONE) == 0 || ri->ri_font == NULL)
		return EINVAL;

	if (font->data != NULL)
		return rasops_add_font(ri, font);
	else
		return rasops_use_font(ri, font);
}

struct rasops_list_font_ctx {
	struct rasops_info *ri;
	int cnt;
	struct wsdisplay_font *font;
};

int
rasops_list_font_cb(void *cbarg, struct wsdisplay_font *font)
{
	struct rasops_list_font_ctx *ctx = cbarg;

	if (font->fontheight != ctx->ri->ri_font->fontheight ||
	    font->fontwidth != ctx->ri->ri_font->fontwidth)
		return 0;

	if (ctx->cnt-- == 0) {
		ctx->font = font;
		return 1;
	}

	return 0;
}

int
rasops_list_font(void *v, struct wsdisplay_font *font)
{
	struct rasops_info *ri = v;
	struct rasops_list_font_ctx ctx;
	int idx;

	if ((ri->ri_flg & RI_CFGDONE) == 0 || ri->ri_font == NULL)
		return EINVAL;

	if (font->index < 0)
		return EINVAL;

	ctx.ri = ri;
	ctx.cnt = font->index;
	ctx.font = NULL;
	wsfont_enum(rasops_list_font_cb, &ctx);

	if (ctx.font == NULL)
		return EINVAL;

	idx = font->index;
	*font = *ctx.font;	/* struct copy */
	font->index = idx;
	font->cookie = font->data = NULL;	/* don't leak kernel pointers */
	return 0;
}
@


1.46
log
@Fix rotation in combination wth vcons support by calling
rasops_putchar_rotated() within the other rotation support functions.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.45 2017/05/16 02:22:51 jcs Exp $	*/
d153 1
a153 1
void	rasops_rotate_font(int *);
d221 3
a223 2
		if (ri->ri_flg & RI_ROTATE_CW)
			rasops_rotate_font(&cookie);
d345 1
a345 1
	if (ri->ri_flg & RI_ROTATE_CW) {
d464 1
a464 1
	if (ri->ri_flg & RI_ROTATE_CW) {
d962 5
a966 1
	} else
d1161 1
a1161 1
rasops_rotate_font(int *cookie)
d1177 1
a1177 1
	if ((ncookie = wsfont_rotate(*cookie)) == -1)
d1238 5
d1244 1
a1244 2
	rc = ri->ri_real_ops.putchar(cookie, col, ri->ri_rows - row - 1, uc,
	    attr & ~1);
d1249 1
a1249 2
	rp = ri->ri_bits + col * ri->ri_yscale + (ri->ri_rows - row - 1) * 
	    ri->ri_xscale;
@


1.45
log
@when allocating a new screen, only copy the current buffer contents
to it for visible screens (i.e., the console).  initialize other
virtual screens with just blank character cells.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.44 2016/12/15 19:18:41 fcambus Exp $	*/
d1267 1
a1267 1
		rc = ri->ri_ops.putchar(cookie, row, i, ' ', attr);
d1326 1
a1326 1
			rc = ri->ri_ops.putchar(cookie, rn, col, ' ', attr);
@


1.44
log
@Remove rasops2 (2-bit color depth) functions, they are unused.

It seems unlikely that any future new platform will ever need them.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.43 2016/09/26 20:41:08 fcambus Exp $	*/
d1401 1
a1401 1
	if (ri->ri_bs) {
@


1.43
log
@Avoid calculating offset several times. This was done for a few functions already, but not all of them.

OK natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.42 2015/09/07 18:00:58 kettenis Exp $	*/
a429 5
#if NRASOPS2 > 0
	case 2:
		rasops2_init(ri);
		break;
#endif
a799 10
#if NRASOPS2 > 0
	case 2:
		for (i = 1; i < 15; i++)
			ri->ri_devcmap[i] = 0xaaaaaaaa;

		ri->ri_devcmap[0] = 0;
		ri->ri_devcmap[8] = 0x55555555;
		ri->ri_devcmap[15] = 0xffffffff;
		return;
#endif
@


1.42
log
@Make it possible to use RI_WRONLY for the aframebuffer during early boot.
In this case, the caller has to provide the backing store for the screen
contents by setting the ri_bs member of "struct rasops_info".  The screen
contents are retained if the rasops_info descriptor is later reinitialized
after adding the RI_VCONS flag.

ok yasuoka@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.41 2015/09/01 01:54:04 deraadt Exp $	*/
d1580 4
a1583 2
		scr->rs_bs[row * cols + col + i].uc = ' ';
		scr->rs_bs[row * cols + col + i].attr = attr;
d1631 4
a1634 2
		scr->rs_bs[row * cols + i].uc = ' ';
		scr->rs_bs[row * cols + i].attr = attr;
d1702 4
a1705 2
		ri->ri_bs[row * cols + col + i].uc = ' ';
		ri->ri_bs[row * cols + col + i].attr = attr;
d1743 4
a1746 2
		ri->ri_bs[row * cols + i].uc = ' ';
		ri->ri_bs[row * cols + i].attr = attr;
@


1.41
log
@uses sizes for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.40 2015/06/21 20:49:18 jca Exp $	*/
d177 6
d280 15
a1391 1
	size_t size;
a1404 1
	size = ri->ri_rows * ri->ri_cols * sizeof(struct wsdisplay_charcell);
d1416 8
a1423 3
	for (i = 0; i < ri->ri_rows * ri->ri_cols; i++) {
		scr->rs_bs[i].uc = ' ';
		scr->rs_bs[i].attr = *attrp;
d1654 88
@


1.40
log
@Don't leak mem if wsfont_rotate() fails.

Problem reported by Maxime Villard, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.39 2015/03/14 03:38:49 jsg Exp $	*/
d1374 1
a1374 1
	scr = malloc(sizeof(struct rasops_screen), M_DEVBUF, M_NOWAIT);
d1382 1
a1382 1
		free(scr, M_DEVBUF, 0);
d1417 3
a1419 2
	free(scr->rs_bs, M_DEVBUF, 0);
	free(scr, M_DEVBUF, 0);
@


1.39
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.38 2015/01/27 03:17:36 dlg Exp $	*/
a1165 3

	f = malloc(sizeof(struct rotatedfont), M_DEVBUF, M_WAITOK);

d1169 1
@


1.38
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.37 2014/12/22 20:08:05 krw Exp $	*/
a37 1
#include <sys/endian.h>
@


1.37
log
@Replace switch workq with taskq, using the blambert@@ method (tm).

Tested with non-drm and wsfb systems. ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.36 2014/12/19 22:44:58 guenther Exp $	*/
d167 1
a167 1
void	rasops_doswitch(void *, void *);
d277 1
a277 1
	task_set(&ri->ri_switchtask, rasops_doswitch, ri, NULL);
d1438 1
a1438 1
	rasops_doswitch(ri, NULL);
d1443 1
a1443 1
rasops_doswitch(void *v, void *dummy)
@


1.36
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.35 2014/12/13 21:05:33 doug Exp $	*/
d37 1
a37 1
#include <sys/workq.h>
d277 2
d1430 1
d1434 1
a1434 2
		workq_queue_task(NULL, &ri->ri_switchwqt, 0,
		    rasops_doswitch, v, cookie);
d1438 1
a1438 1
	rasops_doswitch(v, cookie);
d1443 1
a1443 1
rasops_doswitch(void *v, void *cookie)
d1446 1
a1446 1
	struct rasops_screen *scr = cookie;
@


1.35
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.34 2014/11/20 10:37:21 landry Exp $	*/
d38 1
a38 2

#include <machine/endian.h>
@


1.34
log
@Fix previous.
Build failure reported by Sebastien Marie
testing & ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.33 2014/11/20 08:15:07 deraadt Exp $	*/
d1380 3
a1382 2
	size = ri->ri_rows * ri->ri_cols * sizeof(struct wsdisplay_charcell);
	scr->rs_bs = malloc(size, M_DEVBUF, M_NOWAIT);
d1387 1
@


1.33
log
@oops, mangled the prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.32 2014/11/20 01:53:06 deraadt Exp $	*/
d145 1
d147 1
@


1.32
log
@Rename slow_ovbcopy() to slow_bcopy(), since ovbcopy means nothing to
the young kids and old greybeards who know that bcopy has always handled
the ov case.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.31 2014/07/12 18:48:52 tedu Exp $	*/
d145 1
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.30 2013/10/20 21:24:00 miod Exp $	*/
a144 3
#if NRASOPS_BSWAP > 0
static void slow_ovbcopy(void *, void *, size_t);
#endif
d644 1
a644 1
 * We simply cop-out here and use ovbcopy(), since it handles all of
d694 1
a694 1
			slow_ovbcopy(sp, dp, num);
d1201 1
a1201 1
			slow_ovbcopy(sp, dp, ri->ri_xscale);
d1330 2
a1331 2
 * Strictly byte-only ovbcopy() version, to be used with RI_BSWAP, as the
 * regular ovbcopy() may want to optimize things by doing larger-than-byte
d1336 1
a1336 1
slow_ovbcopy(void *s, void *d, size_t len)
@


1.30
log
@No longer store fonts added with the WSDISPLAYIO_LDFONT ioctl into the
wsdisplay softc. Instead, since the knowledge about available fonts lies in
the parent driver itself, introduce a list_font wsdisplay_accessop which
queries a font index, suitable to use within the WSDISPLAYIO_LSFONT ioctl.

With this in place:
- there is no global wsdisplay limit on the number of fonts loaded. Such a
  limit will be enforced by the display drivers themselves.
- built-in kernel fonts will now appear in the list of fonts.

Grow a list_font accesop for rasops, which relies upon wsfont_enum(), which
is turned into something useful (and abortable if you do not need to iterate
further). Not used by any rasops driver yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.29 2013/10/20 16:44:47 miod Exp $	*/
d1383 1
a1383 1
		free(scr, M_DEVBUF);
d1417 2
a1418 2
	free(scr->rs_bs, M_DEVBUF);
	free(scr, M_DEVBUF);
@


1.29
log
@Add a load_font accessop to rasops, to allow for fonts to be loaded and
selected. All rasops fonts are managed by wsfont, which allows a font to be
loaded on a rasops device and used on another.

Currently not plumbed in any driver yet. This is work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.28 2013/10/18 17:38:34 miod Exp $	*/
d181 1
d1710 51
@


1.28
log
@Make sure that, when a particular mapchar() can't find a proper glyph for the
requested character in the font it is using, it suggests a question mark
character, instead of a space, so that the existence of the non-representable
character becomes visible.

Note that this is consistent with pcdisplay which suggests a diamond for
missing glyphs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.27 2013/08/20 17:44:34 kettenis Exp $	*/
d179 3
d1628 81
@


1.27
log
@Define WS_DEFAULT_FG and WS_DEFAULT_BG as default colors (black on white for
sparc/sparc64, white on black for everybody else), and use them to construct
a default color attribute in the rasops(4) code.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.26 2013/06/28 20:06:50 kettenis Exp $	*/
d476 1
a476 1
			*cp = ' ';
d484 1
a484 1
		*cp = ' ';
d489 1
a489 1
		*cp = ' ';
@


1.26
log
@Add support for write-only framebuffers.  This makes the code that copies
rows and columns redraw the destination area instead of reading pixel values
from the framebuffer.  This can be a considerable performance win.  Only
works together with RI_VCONS.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.25 2013/06/11 18:15:55 deraadt Exp $	*/
d513 2
a514 2
		fg = WSCOL_WHITE;
		bg = WSCOL_BLACK;
@


1.25
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.24 2013/05/17 12:03:11 kettenis Exp $	*/
d1518 1
d1520 1
d1528 13
a1540 1
	return scr->rs_ri->ri_copycols(scr->rs_ri, row, src, dst, num);
d1565 3
a1567 1
	int cols = scr->rs_ri->ri_cols;
d1575 15
a1589 1
	return scr->rs_ri->ri_copyrows(scr->rs_ri, src, dst, num);
@


1.24
log
@Implement wsmoused support based on the new multiple screen support.  Only
works if the RI_VCONS flag is specified when initializing a rasops_info
descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.23 2013/03/25 19:49:08 kettenis Exp $	*/
d701 1
a701 1
			ovbcopy(sp, dp, num);
d1208 1
a1208 1
			ovbcopy(sp, dp, ri->ri_xscale);
d1520 1
a1520 1
	ovbcopy(&scr->rs_bs[row * cols + src], &scr->rs_bs[row * cols + dst],
d1553 1
a1553 1
	ovbcopy(&scr->rs_bs[src * cols], &scr->rs_bs[dst * cols],
@


1.23
log
@Add basic support for multiple screens.

ok mpi@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.22 2010/08/28 12:48:14 miod Exp $	*/
d1370 1
d1376 2
a1377 2
	size = ri->ri_cols * ri->ri_rows * sizeof(struct wsdisplay_charcell);
	scr->rs_bs = malloc(size, M_DEVBUF, M_NOWAIT | M_ZERO);
d1393 5
a1452 2
			if (scr->rs_bs[off].uc == 0)
				continue;
d1465 13
d1537 1
a1537 1
		scr->rs_bs[row * cols + col + i].uc = 0;
d1570 1
a1570 1
		scr->rs_bs[row * cols + i].uc = 0;
@


1.22
log
@ansify function definitions, and constify a few arrays while there.
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.21 2010/01/12 00:41:03 chl Exp $	*/
d34 1
d37 1
d168 11
d243 31
d1352 227
@


1.21
log
@Do not check malloc return value against NULL, as M_WAITOK is used.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.20 2009/09/05 14:09:35 miod Exp $	*/
d170 1
a170 3
rasops_init(ri, wantrows, wantcols)
	struct rasops_info *ri;
	int wantrows, wantcols;
d238 1
a238 3
rasops_reconfig(ri, wantrows, wantcols)
	struct rasops_info *ri;
	int wantrows, wantcols;
d418 1
a418 4
rasops_mapchar(cookie, c, cp)
	void *cookie;
	int c;
	u_int *cp;
d457 1
a457 4
rasops_alloc_cattr(cookie, fg, bg, flg, attr)
	void *cookie;
	int fg, bg, flg;
	long *attr;
d498 1
a498 4
rasops_alloc_mattr(cookie, fg, bg, flg, attr)
	void *cookie;
	int fg, bg, flg;
	long *attr;
d522 1
a522 3
rasops_copyrows(cookie, src, dst, num)
	void *cookie;
	int src, dst, num;
d603 1
a603 3
rasops_copycols(cookie, row, src, dst, num)
	void *cookie;
	int row, src, dst, num;
d670 1
a670 3
rasops_cursor(cookie, on, row, col)
	void *cookie;
	int on, row, col;
d718 1
a718 2
rasops_init_devcmap(ri)
	struct rasops_info *ri;
d813 1
a813 4
rasops_unpack_attr(cookie, attr, fg, bg, underline)
	void *cookie;
	long attr;
	int *fg, *bg, *underline;
d825 1
a825 4
rasops_eraserows(cookie, row, num, attr)
	void *cookie;
	int row, num;
	long attr;
d897 1
a897 2
rasops_do_cursor(ri)
	struct rasops_info *ri;
d969 1
a969 4
rasops_erasecols(cookie, row, col, num, attr)
	void *cookie;
	int row, col, num;
	long attr;
d1132 1
a1132 3
rasops_copychar(cookie, srcrow, dstrow, srccol, dstcol)
	void *cookie;
	int srcrow, dstrow, srccol, dstcol;
d1172 1
a1172 5
rasops_putchar_rotated(cookie, row, col, uc, attr)
	void *cookie;
	int row, col;
	u_int uc;
	long attr;
d1206 1
a1206 4
rasops_erasecols_rotated(cookie, row, col, num, attr)
	void *cookie;
	int row, col, num;
	long attr;
d1225 1
a1225 3
rasops_copyrows_rotated(cookie, src, dst, num)
	void *cookie;
	int src, dst, num;
d1246 1
a1246 3
rasops_copycols_rotated(cookie, row, src, dst, num)
	void *cookie;
	int row, src, dst, num;
d1264 1
a1264 4
rasops_eraserows_rotated(cookie, row, num, attr)
	void *cookie;
	int row, num;
	long attr;
@


1.20
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.19 2008/08/20 18:49:12 miod Exp $	*/
a1149 2
	if (f == NULL)
		return;
@


1.19
log
@If RI_FORCEMONO is set in ri_flags, build ri_devcmap as if it was a 1bpp
frame buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.18 2008/06/26 05:42:17 ray Exp $	*/
d134 2
a135 2
void	rasops_copycols(void *, int, int, int, int);
void	rasops_copyrows(void *, int, int, int);
d137 1
a137 1
void	rasops_cursor(void *, int, int, int);
d140 1
a140 1
void	rasops_do_cursor(struct rasops_info *);
d148 5
a152 5
void	rasops_copycols_rotated(void *, int, int, int, int);
void	rasops_copyrows_rotated(void *, int, int, int);
void	rasops_erasecols_rotated(void *, int, int, int, long);
void	rasops_eraserows_rotated(void *, int, int, long);
void	rasops_putchar_rotated(void *, int, int, u_int, long);
d534 1
a534 1
void
d547 1
a547 1
		return;
d566 1
a566 1
		return;
d607 2
d617 1
a617 1
void
d630 1
a630 1
		return;
d634 1
a634 1
		return;
d653 1
a653 1
		return;
d679 2
d686 1
a686 1
void
d692 1
d697 1
a697 1
	if ((ri->ri_flg & RI_CURSOR) != 0)
d701 4
a704 1
			ri->ri_do_cursor(ri);
a721 1
		ri->ri_flg |= RI_CURSOR;
d725 6
a730 3
			ri->ri_do_cursor(ri);
	} else
		ri->ri_flg &= ~RI_CURSOR;
d847 1
a847 1
void
d869 1
a869 1
		return;
d914 2
d922 1
a922 1
void
d988 2
d995 1
a995 1
void
d1009 1
a1009 1
		return;
d1020 1
a1020 1
		return;
d1069 1
a1069 1
		return;
d1119 2
d1205 1
a1205 1
void
d1215 1
d1220 1
a1220 1
	ri->ri_real_ops.putchar(cookie, col, ri->ri_rows - row - 1, uc,
d1222 2
d1239 2
d1243 1
a1243 1
void
d1251 1
d1255 7
a1261 2
	for (i = col; i < col + num; i++)
		ri->ri_ops.putchar(cookie, row, i, ' ', attr);
d1265 1
a1265 1
void
d1273 1
a1273 1
	if (src > dst)
d1278 1
a1278 1
	else
d1283 3
d1288 1
a1288 1
void
d1295 1
a1295 1
	if (src > dst)
d1297 3
a1299 2
			rasops_copychar(cookie, row, row, src + coff, dst + coff);
	else
d1301 5
a1305 1
			rasops_copychar(cookie, row, row, src + coff, dst + coff);
d1308 1
a1308 1
void
d1316 1
d1321 7
a1327 2
		for (col = 0; col < ri->ri_cols; col++)
			ri->ri_ops.putchar(cookie, rn, col, ' ', attr);
@


1.18
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.17 2006/12/02 18:02:53 miod Exp $	*/
d738 1
a738 3
	switch (ri->ri_depth) {
#if NRASOPS1 > 0
	case 1:
d743 3
a745 1
#endif
@


1.17
log
@Oops, prevent a warning if rasops_bswap is not required.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.16 2006/12/02 15:55:18 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.16
log
@On frame buffers which endianness differs from the host CPU, we can not afford
using ovbcopy() in the erasecols emulop, as the ovbcopy implementation might
do larger-than-byte loads and store, which will not have the expected result
if the source and destination addresses are not similarly aligned.

Instead, roll our own byte-only ovbcopy() in this case. This is made dependent
on a config(8) attribute to avoid bloating platforms which do not need this,
thus frame buffers which may set RI_BSWAP in ri_flg need to depend on this
attribute.

Problem spotted by matthieu@@ using tcsh on sparc64 console.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.15 2006/11/29 19:08:22 miod Exp $	*/
d150 1
d152 1
a152 1

@


1.15
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.14 2006/03/10 20:03:38 miod Exp $	*/
d150 1
d667 15
a681 4
	while (height--) {
		ovbcopy(sp, dp, num);
		dp += ri->ri_stride;
		sp += ri->ri_stride;
d809 1
d818 3
d1177 15
a1191 4
	while (height--) {
		ovbcopy(sp, dp, ri->ri_xscale);
		dp += ri->ri_stride;
		sp += ri->ri_stride;
d1295 26
@


1.14
log
@Omit specific depth in rasops_init_devcmap() if not compiling for them.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.13 2006/01/08 16:34:55 miod Exp $	*/
d149 1
d351 1
d813 2
a814 1
rasops_unpack_attr(attr, fg, bg, underline)
a817 1

@


1.13
log
@Correctly initialize ri_devcmap at 4bpp.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.12 2005/09/15 20:23:10 miod Exp $	*/
d722 2
d725 4
a728 1
	int i, c;
d731 1
d737 2
a738 1

d747 2
a748 1

d755 2
a756 1

d761 3
d766 1
d804 1
@


1.12
log
@Stop compiling the texte console rotation code #ifdef __zaurus__, but use
a flag in the rasops_info structure; drivers which may use it shall declare
a specific attribute for the config(8) machinery, so that the necessary code
is compiled in.

In addition to this, rotated font computation is now done on-demand, and a
list of unrotated-rotated font cookie pairs is kept, rather than rotating all
built-in wsfonts at initialization time.

No user-perceptible functional change.

Tested matthieu@@ uwe@@, ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.11 2005/05/01 11:49:31 pascoe Exp $	*/
d729 1
a729 1
			ri->ri_devcmap[i] = -1;
d738 8
a745 1
		ri->ri_devcmap[15] = -1;
@


1.11
log
@Another evil hack to turn sidelining into underlining on the Zaurus console.

tested dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.10 2005/04/30 23:13:47 pascoe Exp $	*/
a39 2
#include "rasops_glue.h"

d141 1
d149 2
a150 1
#ifdef __zaurus__
d152 4
d157 1
d159 9
a167 63
void
rasops_copychar(cookie, srcrow, dstrow, srccol, dstcol)
	void *cookie;
	int srcrow, dstrow, srccol, dstcol;
{
	struct rasops_info *ri;
	u_char *sp, *dp;
	int height;
	int r_srcrow, r_dstrow, r_srccol, r_dstcol;

	ri = (struct rasops_info *)cookie;

	r_srcrow = srccol;
	r_dstrow = dstcol;
	r_srccol = ri->ri_rows - srcrow - 1;
	r_dstcol = ri->ri_rows - dstrow - 1;

	r_srcrow *= ri->ri_yscale;
	r_dstrow *= ri->ri_yscale;
	height = ri->ri_font->fontheight;

	sp = ri->ri_bits + r_srcrow + r_srccol * ri->ri_xscale;
	dp = ri->ri_bits + r_dstrow + r_dstcol * ri->ri_xscale;

	while (height--) {
		ovbcopy(sp, dp, ri->ri_xscale);
		dp += ri->ri_stride;
		sp += ri->ri_stride;
	}
}

void
rasops_putchar_rotated(cookie, row, col, uc, attr)
	void *cookie;
	int row, col;
	u_int uc;
	long attr;
{
	struct rasops_info *ri;
	u_char *rp;
	int height;

	ri = (struct rasops_info *)cookie;

	/* Do rotated char sans (side)underline */
	ri->ri_real_ops.putchar(cookie, col, ri->ri_rows - row - 1, uc,
	    attr & ~1);

	/* Do rotated underline */
	rp = ri->ri_bits + col * ri->ri_yscale + (ri->ri_rows - row - 1) * 
	    ri->ri_xscale;
	height = ri->ri_font->fontheight;

	/* XXX this assumes 16-bit color depth */
	if ((attr & 1) != 0) {
		int16_t c = (int16_t)ri->ri_devcmap[((u_int)attr >> 24) & 0xf];

		while (height--) {
			*(int16_t *)rp = c;
			rp += ri->ri_stride;
		}
	}
}
a187 1
#ifndef __zaurus__
a188 3
#else
			cookie = wsfont_find(NULL, 0, 12, 0);
#endif
a190 1
#ifndef __zaurus__
a191 3
#else
			cookie = wsfont_find(NULL, 0, 8, 0);
#endif
d201 9
d248 1
a248 1
	int bpp, s;
d282 5
a286 6
#ifndef __zaurus__
	ri->ri_cols = ri->ri_emuwidth / ri->ri_font->fontwidth;
	ri->ri_rows = ri->ri_emuheight / ri->ri_font->fontheight;
#else
	ri->ri_rows = ri->ri_emuwidth / ri->ri_font->fontwidth;
	ri->ri_cols = ri->ri_emuheight / ri->ri_font->fontheight;
d288 4
d307 1
a307 1
	if ((ri->ri_flg & RI_CLEAR) != 0)
d309 2
d328 12
d405 9
a413 3
#ifdef __zaurus__
	ri->ri_real_ops = ri->ri_ops;
	ri->ri_ops.putchar = rasops_putchar_rotated;
a533 1
#ifndef __zaurus__
a669 35
#else
/* XXX: these could likely be optimised somewhat. */
void
rasops_copyrows(cookie, src, dst, num)
	void *cookie;
	int src, dst, num;
{
	struct rasops_info *ri = (struct rasops_info *)cookie;
	int col, roff;

	if (src > dst)
		for (roff = 0; roff < num; roff++)
			for (col = 0; col < ri->ri_cols; col++)
				rasops_copychar(cookie, src + roff, dst + roff, col, col);
	else
		for (roff = num - 1; roff >= 0; roff--)
			for (col = 0; col < ri->ri_cols; col++)
				rasops_copychar(cookie, src + roff, dst + roff, col, col);
}

void
rasops_copycols(cookie, row, src, dst, num)
	void *cookie;
	int row, src, dst, num;
{
	int coff;

	if (src > dst)
		for (coff = 0; coff < num; coff++)
			rasops_copychar(cookie, row, row, src + coff, dst + coff);
	else
		for (coff = num - 1; coff >= 0; coff--)
			rasops_copychar(cookie, row, row, src + coff, dst + coff);
}
#endif
a803 1
#ifndef __zaurus__
a871 17
#else
void
rasops_eraserows(cookie, row, num, attr)
	void *cookie;
	int row, num;
	long attr;
{
	struct rasops_info *ri;
	int col, rn;

	ri = (struct rasops_info *)cookie;

	for (rn = row; rn < row + num; rn++)
		for (col = 0; col < ri->ri_cols; col++)
			ri->ri_ops.putchar(cookie, rn, col, ' ', attr);
}
#endif
d884 6
a889 7
#ifndef __zaurus__
	row = ri->ri_crow;
	col = ri->ri_ccol;
#else
	/* Rotate rows/columns */
	row = ri->ri_ccol;
	col = ri->ri_rows - ri->ri_crow - 1;
d891 4
a947 1
#ifndef __zaurus__
d1073 105
a1177 1
#else
d1179 1
a1179 1
rasops_erasecols(cookie, row, col, num, attr)
d1192 53
a1244 1
#endif
@


1.10
log
@Temporary hack to (un)rotate the Zaurus console until a proper rasops
rotation framework is ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.9 2003/12/17 11:21:08 miod Exp $	*/
d193 2
d198 18
a215 1
	ri->ri_real_ops.putchar(cookie, col, ri->ri_rows - row - 1, uc, attr);
@


1.9
log
@Provide a real inverted cursor for rasops-based consoles; inspired by
a similar diff in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.8 2002/08/12 02:31:01 jason Exp $	*/
d150 49
d218 1
d220 3
d225 1
d227 3
d311 1
d314 4
d417 5
d540 1
d677 35
d846 1
d915 17
d944 1
d947 5
d1005 1
d1131 16
@


1.8
log
@Add a callback routine for when the cursor position is updated (this allows
for updating prom cursor locations).
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.7 2002/07/27 22:17:49 miod Exp $	*/
d57 40
a96 19
/* ANSI colormap (R,G,B). Upper 8 are high-intensity */
const u_char rasops_cmap[256*3] = {
	0x00, 0x00, 0x00, /* black */
	0x7f, 0x00, 0x00, /* red */
	0x00, 0x7f, 0x00, /* green */
	0x7f, 0x7f, 0x00, /* brown */
	0x00, 0x00, 0x7f, /* blue */
	0x7f, 0x00, 0x7f, /* magenta */
	0x00, 0x7f, 0x7f, /* cyan */
	0xc7, 0xc7, 0xc7, /* white - XXX too dim? */

	0x7f, 0x7f, 0x7f, /* black */
	0xff, 0x00, 0x00, /* red */
	0x00, 0xff, 0x00, /* green */
	0xff, 0xff, 0x00, /* brown */
	0x00, 0x00, 0xff, /* blue */
	0xff, 0x00, 0xff, /* magenta */
	0x00, 0xff, 0xff, /* cyan */
	0xff, 0xff, 0xff, /* white */
d99 3
a101 3
	 * For the cursor, we need at least the last (255th)
	 * color to be white. Fill up white completely for
	 * simplicity.
d103 5
a107 6
#define _CMWHITE 0xff, 0xff, 0xff,
#define _CMWHITE16	_CMWHITE _CMWHITE _CMWHITE _CMWHITE \
			_CMWHITE _CMWHITE _CMWHITE _CMWHITE \
			_CMWHITE _CMWHITE _CMWHITE _CMWHITE \
			_CMWHITE _CMWHITE _CMWHITE _CMWHITE
	_CMWHITE16 _CMWHITE16 _CMWHITE16 _CMWHITE16 _CMWHITE16
d110 1
d112 20
a131 1
#undef _CMWHITE
@


1.7
log
@Unstaticize functions, for my ddb sessions pleasure.
Plus it makes hangman more difficult.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.6 2002/07/23 22:02:08 miod Exp $	*/
d261 1
d600 3
@


1.6
log
@Do not use bcopy() when you mean ovbcopy(); found the hard way by aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.5 2002/07/17 14:49:51 miod Exp $	*/
d103 7
a109 7
static void	rasops_copyrows(void *, int, int, int);
static int	rasops_mapchar(void *, int, u_int *);
static void	rasops_cursor(void *, int, int, int);
static int	rasops_alloc_cattr(void *, int, int, int, long *);
static int	rasops_alloc_mattr(void *, int, int, int, long *);
static void	rasops_do_cursor(struct rasops_info *);
static void	rasops_init_devcmap(struct rasops_info *);
d322 1
a322 1
static int
d364 1
a364 1
static int
d408 1
a408 1
static int
d435 1
a435 1
static void
d572 1
a572 1
static void
d613 1
a613 1
static void
d697 1
a697 1
 * Erase rows. This isn't static, since 24-bpp uses it in special cases.
d772 1
a772 1
static void
@


1.5
log
@No newline in panic messages
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.4 2002/05/28 22:10:03 fgsch Exp $	*/
d513 1
a513 1
 * We simply cop-out here and use bcopy(), since it handles all of
d563 1
a563 1
		bcopy(sp, dp, num);
@


1.4
log
@o spaces, tabs, spelling cleanup.
o remove unneeded headers.
o makes this to compile if RASOPS_SMALL is defined.
o makes rasops2 to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.3 2002/05/02 19:21:48 matthieu Exp $	*/
d185 1
a185 1
		panic("rasops_init: fontwidth assumptions botched!\n");
d334 1
a334 1
		panic("rasops_mapchar: no font selected\n");
@


1.3
log
@use the gallant 12x22 font by default on screens that are more
than 960 pixels wide if !SMALL_KERNEL, like rcons does.
Ok drahn@@, mickey@@, miod@@.x
@
text
@d1 2
a2 2
/*	$OpenBSD: rasops.c,v 1.2 2002/03/14 01:27:02 millert Exp $ */
/*	 $NetBSD: rasops.c,v 1.35 2001/02/02 06:01:01 marcus Exp $	*/
a39 3
#include <sys/cdefs.h>
//__KERNEL_RCSID(0, "$NetBSD: rasops.c,v 1.35 2001/02/02 06:01:01 marcus Exp $");

a41 1
#include <sys/types.h>
a45 1
/* #include <machine/bswap.h> */
d112 1
a112 1
 * Initalize a 'rasops_info' descriptor.
d127 1
a127 1
		if (ri->ri_width > 80*12) 
d130 1
a130 1
		else 
d133 1
a133 1
		
d167 1
a167 1
 
d238 1
a238 1
		ri->ri_bits += (((ri->ri_width * bpp >> 3) - 
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.1 2001/03/18 04:32:44 nate Exp $ */
d132 8
a139 2
		/* Want 8 pixel wide, don't care about aestethics */
		if ((cookie = wsfont_find(NULL, 8, 0, 0)) <= 0)
@


1.1
log
@Import rasops from NetBSD.  This gives improved performance for raster
operations.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d108 7
a114 7
static void	rasops_copyrows __P((void *, int, int, int));
static int	rasops_mapchar __P((void *, int, u_int *));
static void	rasops_cursor __P((void *, int, int, int));
static int	rasops_alloc_cattr __P((void *, int, int, int, long *));
static int	rasops_alloc_mattr __P((void *, int, int, int, long *));
static void	rasops_do_cursor __P((struct rasops_info *));
static void	rasops_init_devcmap __P((struct rasops_info *));
@


1.1.8.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: rasops.c,v 1.35 2001/02/02 06:01:01 marcus Exp $	*/
d40 3
d45 1
d50 1
d108 7
a114 7
static void	rasops_copyrows(void *, int, int, int);
static int	rasops_mapchar(void *, int, u_int *);
static void	rasops_cursor(void *, int, int, int);
static int	rasops_alloc_cattr(void *, int, int, int, long *);
static int	rasops_alloc_mattr(void *, int, int, int, long *);
static void	rasops_do_cursor(struct rasops_info *);
static void	rasops_init_devcmap(struct rasops_info *);
d117 1
a117 1
 * Initialize a 'rasops_info' descriptor.
d132 2
a133 8
		if (ri->ri_width > 80*12)
			/* High res screen, choose a big font */
			cookie = wsfont_find(NULL, 12, 0, 0);
		else
			/*  lower res, choose a 8 pixel wide font */
			cookie = wsfont_find(NULL, 8, 0, 0);

		if (cookie <= 0)
d166 1
a166 1

d237 1
a237 1
		ri->ri_bits += (((ri->ri_width * bpp >> 3) -
@


1.1.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.1.8.1 2002/06/11 03:42:28 art Exp $	*/
d103 7
a109 7
void	rasops_copyrows(void *, int, int, int);
int	rasops_mapchar(void *, int, u_int *);
void	rasops_cursor(void *, int, int, int);
int	rasops_alloc_cattr(void *, int, int, int, long *);
int	rasops_alloc_mattr(void *, int, int, int, long *);
void	rasops_do_cursor(struct rasops_info *);
void	rasops_init_devcmap(struct rasops_info *);
d185 1
a185 1
		panic("rasops_init: fontwidth assumptions botched!");
a260 1
	ri->ri_updatecursor = NULL;
d322 1
a322 1
int
d334 1
a334 1
		panic("rasops_mapchar: no font selected");
d364 1
a364 1
int
d408 1
a408 1
int
d435 1
a435 1
void
d513 1
a513 1
 * We simply cop-out here and use ovbcopy(), since it handles all of
d563 1
a563 1
		ovbcopy(sp, dp, num);
d572 1
a572 1
void
a599 3
	if (ri->ri_updatecursor != NULL)
		ri->ri_updatecursor(ri);

d613 1
a613 1
void
d697 1
a697 1
 * Erase rows
d772 1
a772 1
void
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops.c,v 1.1 2001/03/18 04:32:44 nate Exp $ */
@


1.1.4.2
log
@Merge unpeeing cvs missed
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d108 7
a114 7
static void	rasops_copyrows(void *, int, int, int);
static int	rasops_mapchar(void *, int, u_int *);
static void	rasops_cursor(void *, int, int, int);
static int	rasops_alloc_cattr(void *, int, int, int, long *);
static int	rasops_alloc_mattr(void *, int, int, int, long *);
static void	rasops_do_cursor(struct rasops_info *);
static void	rasops_init_devcmap(struct rasops_info *);
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: rasops.c,v 1.35 2001/02/02 06:01:01 marcus Exp $	*/
d40 3
d45 1
d50 1
d108 7
a114 7
void	rasops_copyrows(void *, int, int, int);
int	rasops_mapchar(void *, int, u_int *);
void	rasops_cursor(void *, int, int, int);
int	rasops_alloc_cattr(void *, int, int, int, long *);
int	rasops_alloc_mattr(void *, int, int, int, long *);
void	rasops_do_cursor(struct rasops_info *);
void	rasops_init_devcmap(struct rasops_info *);
d117 1
a117 1
 * Initialize a 'rasops_info' descriptor.
d132 2
a133 8
		if (ri->ri_width > 80*12)
			/* High res screen, choose a big font */
			cookie = wsfont_find(NULL, 12, 0, 0);
		else
			/*  lower res, choose a 8 pixel wide font */
			cookie = wsfont_find(NULL, 8, 0, 0);

		if (cookie <= 0)
d166 1
a166 1

d184 1
a184 1
		panic("rasops_init: fontwidth assumptions botched!");
d237 1
a237 1
		ri->ri_bits += (((ri->ri_width * bpp >> 3) -
a259 1
	ri->ri_updatecursor = NULL;
d321 1
a321 1
int
d333 1
a333 1
		panic("rasops_mapchar: no font selected");
d363 1
a363 1
int
d407 1
a407 1
int
d434 1
a434 1
void
d512 1
a512 1
 * We simply cop-out here and use ovbcopy(), since it handles all of
d562 1
a562 1
		ovbcopy(sp, dp, num);
d571 1
a571 1
void
a598 3
	if (ri->ri_updatecursor != NULL)
		ri->ri_updatecursor(ri);

d612 1
a612 1
void
d696 1
a696 1
 * Erase rows
d771 1
a771 1
void
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d57 19
a75 40
/* ANSI colormap (R,G,B) */

#define	NORMAL_BLACK	0x000000
#define	NORMAL_RED	0x7f0000
#define	NORMAL_GREEN	0x007f00
#define	NORMAL_BROWN	0x7f7f00
#define	NORMAL_BLUE	0x00007f
#define	NORMAL_MAGENTA	0x7f007f
#define	NORMAL_CYAN	0x007f7f
#define	NORMAL_WHITE	0xc7c7c7	/* XXX too dim? */

#define	HILITE_BLACK	0x7f7f7f
#define	HILITE_RED	0xff0000
#define	HILITE_GREEN	0x00ff00
#define	HILITE_BROWN	0xffff00
#define	HILITE_BLUE	0x0000ff
#define	HILITE_MAGENTA	0xff00ff
#define	HILITE_CYAN	0x00ffff
#define	HILITE_WHITE	0xffffff

const u_char rasops_cmap[256 * 3] = {
#define	_C(x)	((x) & 0xff0000) >> 16, ((x) & 0x00ff00) >> 8, ((x) & 0x0000ff)

	_C(NORMAL_BLACK),
	_C(NORMAL_RED),
	_C(NORMAL_GREEN),
	_C(NORMAL_BROWN),
	_C(NORMAL_BLUE),
	_C(NORMAL_MAGENTA),
	_C(NORMAL_CYAN),
	_C(NORMAL_WHITE),

	_C(HILITE_BLACK),
	_C(HILITE_RED),
	_C(HILITE_GREEN),
	_C(HILITE_BROWN),
	_C(HILITE_BLUE),
	_C(HILITE_MAGENTA),
	_C(HILITE_CYAN),
	_C(HILITE_WHITE),
d78 3
a80 3
	 * For the cursor, we need the last 16 colors to be the
	 * opposite of the first 16. Fill the intermediate space with
	 * white completely for simplicity.
d82 6
a87 5
#define _CMWHITE16 \
	_C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), \
	_C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), \
	_C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), \
	_C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE), _C(HILITE_WHITE),
a89 1
	_CMWHITE16 _CMWHITE16 _CMWHITE16 _CMWHITE16
d91 1
a91 20

	_C(~HILITE_WHITE),
	_C(~HILITE_CYAN),
	_C(~HILITE_MAGENTA),
	_C(~HILITE_BLUE),
	_C(~HILITE_BROWN),
	_C(~HILITE_GREEN),
	_C(~HILITE_RED),
	_C(~HILITE_BLACK),

	_C(~NORMAL_WHITE),
	_C(~NORMAL_CYAN),
	_C(~NORMAL_MAGENTA),
	_C(~NORMAL_BLUE),
	_C(~NORMAL_BROWN),
	_C(~NORMAL_GREEN),
	_C(~NORMAL_RED),
	_C(~NORMAL_BLACK),

#undef	_C
@


