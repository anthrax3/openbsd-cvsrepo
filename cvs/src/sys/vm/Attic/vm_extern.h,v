head	1.24;
access;
symbols
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	UBC_SYNC_A:1.24
	UBC_SYNC_B:1.24
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.6
	OPENBSD_2_8:1.18.0.4
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	SMP:1.16.0.4
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.15.0.6
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.4
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2001.08.12.20.18.30;	author mickey;	state dead;
branches;
next	1.23;

1.23
date	2001.07.05.07.24.10;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.27.07.14.22;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.07.10.27;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.27.04.52.39;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.06.01.23.35;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.13.14.33.42;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.13.14.30.19;	author art;	state Exp;
branches;
next	1.16;

1.16
date	99.08.17.10.32.19;	author niklas;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	98.03.01.00.38.02;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.11.06.05.59.31;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	97.10.06.20.21.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.15.28.51;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.07.25.06.03.05;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.04.17.01.25.17;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.01.07.05.37.35;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.08.02.00.05.58;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.07.23.23.54.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.06.10.19.26.51;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.13.21.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.03.17.45.26;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.07.17.20.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.16.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.36;	author deraadt;	state Exp;
branches;
next	;

1.16.4.1
date	2000.03.24.09.09.53;	author niklas;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2001.07.04.11.01.17;	author niklas;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2001.10.31.03.32.14;	author nate;	state dead;
branches;
next	;


desc
@@


1.24
log
@vm_extern.h no more
@
text
@/*	$OpenBSD: vm_extern.h,v 1.23 2001/07/05 07:24:10 art Exp $	*/
/*	$NetBSD: vm_extern.h,v 1.20 1996/04/23 12:25:23 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_extern.h	8.5 (Berkeley) 5/3/95
 */

struct buf;
struct loadavg;
struct proc;
struct vmspace;
struct vmtotal;
struct mount;
struct vnode;
struct core;

#ifdef _KERNEL
void		swstrategy __P((struct buf *));

/* Machine dependent portion */
void		vmapbuf __P((struct buf *, vsize_t));
void		vunmapbuf __P((struct buf *, vsize_t));
void		pagemove __P((caddr_t, caddr_t, size_t));
void		cpu_fork __P((struct proc *, struct proc *, void *, size_t));
#ifndef	cpu_swapin
void		cpu_swapin __P((struct proc *));
#endif
#ifndef	cpu_swapout
void		cpu_swapout __P((struct proc *));
#endif

#endif
@


1.23
log
@kern_fthread is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.22 2001/06/27 07:14:22 art Exp $	*/
@


1.22
log
@no more fork braindamage
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.21 2001/06/27 07:10:27 art Exp $	*/
a48 1
void		assert_wait __P((void *, boolean_t));
a49 13
void		thread_block __P((char *));
void		thread_sleep_msg __P((void *, simple_lock_t,
		    boolean_t, char *, int));

/* backwards compatibility */
#define		thread_sleep(event, lock, ruptible) \
	thread_sleep_msg((event), (lock), (ruptible), "thrd_sleep")

/*
 * This define replaces a thread_wakeup prototype, as thread_wakeup
 * was solely a wrapper around wakeup.
 */
#define thread_wakeup wakeup
@


1.21
log
@clean cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.20 2001/06/27 04:52:39 art Exp $	*/
a68 3
#ifdef __FORK_BRAINDAMAGE
int		cpu_fork __P((struct proc *, struct proc *, void *, size_t));
#else
a69 1
#endif
@


1.20
log
@Remove junk from headers, just leave enough for UVM.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.19 2001/05/06 01:23:35 art Exp $	*/
a48 14
#ifdef TYPEDEF_FOR_UAP
int		compat_43_getpagesize __P((struct proc *p, void *, int *));
int		madvise __P((struct proc *, void *, int *));
int		mincore __P((struct proc *, void *, int *));
int		mprotect __P((struct proc *, void *, int *));
int		minherit __P((struct proc *, void *, int *));
int		msync __P((struct proc *, void *, int *));
int		munmap __P((struct proc *, void *, int *));
int		obreak __P((struct proc *, void *, int *));
int		sbrk __P((struct proc *, void *, int *));
int		smmap __P((struct proc *, void *, int *));
int		sstk __P((struct proc *, void *, int *));
#endif

a53 1

@


1.19
log
@iprintf is not used with UVM
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.18 2000/03/13 14:33:42 art Exp $	*/
a47 4
#if defined(KGDB) && !defined(UVM)
void		chgkprot __P((caddr_t, int, int));
#endif

a63 31
#if !defined(UVM)
void		iprintf __P((int (*)(const char *, ...), const char *, ...));
int		grow __P((struct proc *, vm_offset_t));
int		kernacc __P((caddr_t, int, int));
vm_offset_t	kmem_alloc __P((vm_map_t, vm_size_t));
vm_offset_t	kmem_alloc_pageable __P((vm_map_t, vm_size_t));
vm_offset_t	kmem_alloc_wait __P((vm_map_t, vm_size_t));
void		kmem_free __P((vm_map_t, vm_offset_t, vm_size_t));
void		kmem_free_wakeup __P((vm_map_t, vm_offset_t, vm_size_t));
void		kmem_init __P((vm_offset_t, vm_offset_t));
vm_offset_t	kmem_malloc __P((vm_map_t, vm_size_t, boolean_t));
vm_map_t	kmem_suballoc __P((vm_map_t, vm_offset_t *, vm_offset_t *,
		    vm_size_t, boolean_t));
void		loadav __P((struct loadavg *));
void		munmapfd __P((struct proc *, int));
int		pager_cache __P((vm_object_t, boolean_t));
void		sched __P((void));
#ifdef __GNUC__
void		scheduler __P((void)) __attribute ((noreturn));
#else
void		scheduler __P((void));
#endif
int		svm_allocate __P((struct proc *, void *, int *));
int		svm_deallocate __P((struct proc *, void *, int *));
int		svm_inherit __P((struct proc *, void *, int *));
int		svm_protect __P((struct proc *, void *, int *));
void		swapinit __P((void));
void		swapout __P((struct proc *));
void		swapout_threads __P((void));
int		swfree __P((struct proc *, int));
#endif /* !UVM */
a78 39
#if !defined(UVM)
int		useracc __P((caddr_t, int, int));
int		vm_allocate __P((vm_map_t, vm_offset_t *, vm_size_t,
		    boolean_t));
int		vm_allocate_with_pager __P((vm_map_t, vm_offset_t *,
		    vm_size_t, boolean_t, vm_pager_t, vm_offset_t, boolean_t));
int		vm_coredump __P((struct proc *, struct vnode *, struct ucred *,
		    struct core *));
int		vm_deallocate __P((vm_map_t, vm_offset_t, vm_size_t));
int		vm_fault __P((vm_map_t, vm_offset_t, vm_prot_t, boolean_t));
void		vm_fault_copy_entry __P((vm_map_t,
		    vm_map_t, vm_map_entry_t, vm_map_entry_t));
void		vm_fault_unwire __P((vm_map_t, vm_offset_t, vm_offset_t));
int		vm_fault_wire __P((vm_map_t, vm_offset_t, vm_offset_t));
#ifdef __FORK_BRAINDAMAGE
int		vm_fork __P((struct proc *, struct proc *, void *, size_t));
#else
void		vm_fork __P((struct proc *, struct proc *, void *, size_t));
#endif
int		vm_inherit __P((vm_map_t,
		    vm_offset_t, vm_size_t, vm_inherit_t));
void		vm_init_limits __P((struct proc *));
void		vm_mem_init __P((void));
int		vm_mmap __P((vm_map_t, vm_offset_t *, vm_size_t,
		    vm_prot_t, vm_prot_t, int, caddr_t, vm_offset_t));
int		vm_protect __P((vm_map_t,
		    vm_offset_t, vm_size_t, boolean_t, vm_prot_t));
void		vm_set_page_size __P((void));
void		vmmeter __P((void));
struct vmspace	*vmspace_alloc __P((vm_offset_t, vm_offset_t, int));
struct vmspace	*vmspace_fork __P((struct vmspace *));
void		vmspace_free __P((struct vmspace *));
void		vmtotal __P((struct vmtotal *));
void		vnode_pager_setsize __P((struct vnode *, u_long));
void		vnode_pager_umount __P((struct mount *));
boolean_t	vnode_pager_uncache __P((struct vnode *));
int		vslock __P((caddr_t, u_int));
int		vsunlock __P((caddr_t, u_int));
#endif /* !UVM */
@


1.18
log
@vm_size_t -> vsize_t
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.17 2000/03/13 14:30:19 art Exp $	*/
d68 1
a69 1
#if !defined(UVM)
@


1.17
log
@Put a lot more behind ifndef UVM.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.16 1999/08/17 10:32:19 niklas Exp $	*/
d155 2
a156 2
void		vmapbuf __P((struct buf *, vm_size_t));
void		vunmapbuf __P((struct buf *, vm_size_t));
@


1.16
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.15 1998/03/01 00:38:02 niklas Exp $	*/
d68 1
a70 3
#endif
void		iprintf __P((int (*)(const char *, ...), const char *, ...));
#if !defined(UVM)
a71 3
#endif
int		kinfo_loadavg __P((int, char *, int *, int, int *));
int		kinfo_meter __P((int, caddr_t, int *, int, int *));
a81 1
#if !defined(UVM)
a82 1
#endif
a84 1
#if !defined(UVM)
a89 1
#endif
a94 1
#if !defined(UVM)
a96 1
#endif
d98 1
a122 1
#endif
a127 1
#if !defined(UVM)
a132 1
#endif
a134 1
#if !defined(UVM)
a135 1
#endif
a136 1
#if !defined(UVM)
a138 1
#endif
a142 1
#if !defined(UVM)
a145 1
#endif
a149 1
#if !defined(UVM)
d152 1
a152 1
#endif
@


1.16.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 3
a72 1
int		grow __P((struct proc *, vm_offset_t));
d74 3
d87 1
d89 1
d92 1
d98 1
d104 1
d107 1
a108 1
#endif /* !UVM */
d133 1
d139 1
d145 1
d148 1
d150 1
d152 1
d155 1
d160 1
d164 1
d169 1
d172 1
a172 1
#endif /* !UVM */
d175 2
a176 2
void		vmapbuf __P((struct buf *, vsize_t));
void		vunmapbuf __P((struct buf *, vsize_t));
@


1.16.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.16.4.1 2000/03/24 09:09:53 niklas Exp $	*/
d48 4
d53 14
d68 31
d104 1
d114 39
d158 3
d162 1
@


1.16.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.16.4.2 2001/07/04 11:01:17 niklas Exp $	*/
@


1.15
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.14 1997/11/06 05:59:31 csapuntz Exp $	*/
d141 1
a141 1
int		vm_fork __P((struct proc *, struct proc *));
d143 1
a143 1
void		vm_fork __P((struct proc *, struct proc *));
d179 1
a179 1
int		cpu_fork __P((struct proc *, struct proc *));
d181 1
a181 1
void		cpu_fork __P((struct proc *, struct proc *));
@


1.14
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.13 1997/10/06 20:21:16 deraadt Exp $	*/
d48 1
a48 1
#ifdef KGDB
d68 1
d70 1
d72 1
d74 1
d87 1
d89 1
d92 1
d98 1
d104 1
d107 1
d110 1
a110 1
void		thread_block __P((void));
d112 2
a113 1
		    boolean_t, char *));
d124 1
d133 1
d139 1
d145 1
d148 1
d150 1
d152 1
d155 1
d160 1
d164 1
d169 1
d172 1
@


1.13
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.11 1997/07/25 06:03:05 mickey Exp $	*/
d36 1
a36 1
 *	@@(#)vm_extern.h	8.2 (Berkeley) 1/12/94
@


1.12
log
@VFS Lite2 Changes
@
text
@d36 1
a36 1
 *	@@(#)vm_extern.h	8.5 (Berkeley) 5/3/95
@


1.11
log
@tabify
some /lx/p/ printf changes
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.10 1997/04/17 01:25:17 niklas Exp $	*/
d36 1
a36 1
 *	@@(#)vm_extern.h	8.2 (Berkeley) 1/12/94
@


1.10
log
@Removal of race conditions.  Inspired by Charles Hannum's
<mycroft@@netbsd.org> reorganization of the vm_collapse logic, although not
used verbatim.  We no longer collapse objects from the pagedaemon as that
is not necessary anymore with the more aggressive collapses that gets done.
This also increases performance of loaded systems.  Much KNF too.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.9 1997/01/07 05:37:35 tholo Exp $	*/
d106 1
a106 1
    thread_sleep_msg((event), (lock), (ruptible), "thrd_sleep")
@


1.9
log
@Fix for final ptdi panic on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.8 1996/08/02 00:05:58 niklas Exp $	*/
d101 7
a107 1
void		thread_sleep __P((void *, simple_lock_t, boolean_t));
a153 1
void		remrq __P((struct proc *));
@


1.8
log
@Fix long-standing swap-leak. Add OpenBSD tags. Optimize thread_wakeup.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.7 1996/07/23 23:54:21 deraadt Exp $	*/
d142 2
a143 2
void		vslock __P((caddr_t, u_int));
void		vsunlock __P((caddr_t, u_int));
@


1.7
log
@make printf/addlog return 0, for compat to userland
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.6 1996/06/10 19:26:51 niklas Exp $	*/
d49 1
a49 1
void		 chgkprot __P((caddr_t, int, int));
d54 11
a64 11
int		 compat_43_getpagesize __P((struct proc *p, void *, int *));
int		 madvise __P((struct proc *, void *, int *));
int		 mincore __P((struct proc *, void *, int *));
int		 mprotect __P((struct proc *, void *, int *));
int		 minherit __P((struct proc *, void *, int *));
int		 msync __P((struct proc *, void *, int *));
int		 munmap __P((struct proc *, void *, int *));
int		 obreak __P((struct proc *, void *, int *));
int		 sbrk __P((struct proc *, void *, int *));
int		 smmap __P((struct proc *, void *, int *));
int		 sstk __P((struct proc *, void *, int *));
d67 19
a85 19
void		 assert_wait __P((void *, boolean_t));
int		 grow __P((struct proc *, vm_offset_t));
void		 iprintf __P((int (*)(const char *, ...), const char *, ...));
int		 kernacc __P((caddr_t, int, int));
int		 kinfo_loadavg __P((int, char *, int *, int, int *));
int		 kinfo_meter __P((int, caddr_t, int *, int, int *));
vm_offset_t	 kmem_alloc __P((vm_map_t, vm_size_t));
vm_offset_t	 kmem_alloc_pageable __P((vm_map_t, vm_size_t));
vm_offset_t	 kmem_alloc_wait __P((vm_map_t, vm_size_t));
void		 kmem_free __P((vm_map_t, vm_offset_t, vm_size_t));
void		 kmem_free_wakeup __P((vm_map_t, vm_offset_t, vm_size_t));
void		 kmem_init __P((vm_offset_t, vm_offset_t));
vm_offset_t	 kmem_malloc __P((vm_map_t, vm_size_t, boolean_t));
vm_map_t	 kmem_suballoc __P((vm_map_t, vm_offset_t *, vm_offset_t *,
				    vm_size_t, boolean_t));
void		 loadav __P((struct loadavg *));
void		 munmapfd __P((struct proc *, int));
int		 pager_cache __P((vm_object_t, boolean_t));
void		 sched __P((void));
d87 1
a87 1
void		 scheduler __P((void)) __attribute ((noreturn));
d89 1
a89 1
void		 scheduler __P((void));
d91 20
a110 16
int		 svm_allocate __P((struct proc *, void *, int *));
int		 svm_deallocate __P((struct proc *, void *, int *));
int		 svm_inherit __P((struct proc *, void *, int *));
int		 svm_protect __P((struct proc *, void *, int *));
void		 swapinit __P((void));
void		 swapout __P((struct proc *));
void		 swapout_threads __P((void));
int		 swfree __P((struct proc *, int));
void		 swstrategy __P((struct buf *));
void		 thread_block __P((void));
void		 thread_sleep __P((void *, simple_lock_t, boolean_t));
void		 thread_wakeup __P((void *));
int		 useracc __P((caddr_t, int, int));
int		 vm_allocate __P((vm_map_t, vm_offset_t *, vm_size_t,
				  boolean_t));
int		 vm_allocate_with_pager __P((vm_map_t, vm_offset_t *,
d112 5
a116 5
int		 vm_coredump __P((struct proc *, struct vnode *, struct ucred *,
				  struct core *));
int		 vm_deallocate __P((vm_map_t, vm_offset_t, vm_size_t));
int		 vm_fault __P((vm_map_t, vm_offset_t, vm_prot_t, boolean_t));
void		 vm_fault_copy_entry __P((vm_map_t,
d118 2
a119 2
void		 vm_fault_unwire __P((vm_map_t, vm_offset_t, vm_offset_t));
int		 vm_fault_wire __P((vm_map_t, vm_offset_t, vm_offset_t));
d121 1
a121 1
int		 vm_fork __P((struct proc *, struct proc *));
d123 1
a123 1
void		 vm_fork __P((struct proc *, struct proc *));
d125 1
a125 1
int		 vm_inherit __P((vm_map_t,
d127 3
a129 3
void		 vm_init_limits __P((struct proc *));
void		 vm_mem_init __P((void));
int		 vm_mmap __P((vm_map_t, vm_offset_t *, vm_size_t,
d131 1
a131 1
int		 vm_protect __P((vm_map_t,
d133 2
a134 2
void		 vm_set_page_size __P((void));
void		 vmmeter __P((void));
d137 7
a143 7
void		 vmspace_free __P((struct vmspace *));
void		 vmtotal __P((struct vmtotal *));
void		 vnode_pager_setsize __P((struct vnode *, u_long));
void		 vnode_pager_umount __P((struct mount *));
boolean_t	 vnode_pager_uncache __P((struct vnode *));
void		 vslock __P((caddr_t, u_int));
void		 vsunlock __P((caddr_t, u_int));
@


1.6
log
@If we use GCC, tell the compiler that scheduler() do not return
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_extern.h,v 1.4 1996/03/03 17:45:26 niklas Exp $	*/
d69 1
a69 1
void		 iprintf __P((void (*)(const char *, ...), const char *, ...));
@


1.5
log
@proto more stuff
@
text
@d86 3
d90 1
@


1.4
log
@From NetBSD: merge with 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: vm_extern.h,v 1.19 1996/02/10 00:08:05 christos Exp $	*/
d141 1
d146 6
@


1.3
log
@add minherit() system call
@
text
@d1 2
a2 1
/*	$NetBSD: vm_extern.h,v 1.15 1995/12/09 04:28:16 mycroft Exp $	*/
d46 1
d81 1
a81 1
		    vm_size_t, boolean_t));
d86 1
d100 2
a101 2
int		 vm_allocate __P((vm_map_t,
		    vm_offset_t *, vm_size_t, boolean_t));
d104 2
d135 12
a146 1
void		 vsunlock __P((caddr_t, u_int, int));
@


1.2
log
@from netbsd:
Extend use of vm_object_prefer() to vm_allocate_with_pager().
Make vm_object_prefer() call MD aligner for "pageless" objects too,
so we can have more control over the virtual address to be used.

Implementation could be simpler if we by-pass the object to mapped, but
we'd loose the ability to adapt alignment to objects that were previously
mmap'ed with MAP_FIXED on.

Only expect vm_fork() to return if __FORK_BRAINDAMAGE is defined.
Eliminate unused third arg to vm_fork().
@
text
@d56 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vm_extern.h,v 1.14 1995/09/27 20:30:17 thorpej Exp $	*/
d106 5
a110 1
int		 vm_fork __P((struct proc *, struct proc *, int));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

