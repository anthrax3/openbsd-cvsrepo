head	1.12;
access;
symbols
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	UBC_SYNC_A:1.12
	UBC_SYNC_B:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.10
	OPENBSD_2_8:1.11.0.8
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.6
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.4
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2001.06.27.04.53.30;	author art;	state dead;
branches;
next	1.11;

1.11
date	99.09.03.18.02.27;	author art;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	98.03.01.00.38.08;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	98.02.23.20.22.17;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.11.06.05.59.33;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.20.21.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.15.28.53;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.09.22.15.17.18;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	97.04.17.01.25.18;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.00.06.01;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.20.10.53.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.37;	author deraadt;	state Exp;
branches;
next	;

1.11.4.1
date	2001.07.04.11.01.19;	author niklas;	state dead;
branches;
next	;


desc
@@


1.12
log
@Die!
@
text
@/*	$OpenBSD: vm_kern.c,v 1.11 1999/09/03 18:02:27 art Exp $	*/
/*	$NetBSD: vm_kern.c,v 1.17.6.1 1996/06/13 17:21:28 cgd Exp $	*/

/* 
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * The Mach Operating System project at Carnegie-Mellon University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_kern.c	8.4 (Berkeley) 1/9/95
 *
 *
 * Copyright (c) 1987, 1990 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Avadis Tevanian, Jr., Michael Wayne Young
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 *	Kernel memory management.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>

#include <vm/vm.h>
#include <vm/vm_extern.h>
#include <vm/vm_page.h>
#include <vm/vm_pageout.h>
#include <vm/vm_kern.h>

/*
 *	kmem_alloc_pageable:
 *
 *	Allocate pageable memory to the kernel's address map.
 *	map must be "kernel_map" below.
 */
vm_offset_t
kmem_alloc_pageable(map, size)
	vm_map_t		map;
	register vm_size_t	size;
{
	vm_offset_t		addr;
	register int		result;

#if	0
	if (map != kernel_map)
		panic("kmem_alloc_pageable: not called with kernel_map");
#endif

	size = round_page(size);

	addr = vm_map_min(map);
	result = vm_map_find(map, NULL, (vm_offset_t)0, &addr, size, TRUE);
	if (result != KERN_SUCCESS) {
		return (0);
	}

	return (addr);
}

/*
 *	Allocate wired-down memory in the kernel's address map
 *	or a submap.
 */
vm_offset_t
kmem_alloc(map, size)
	register vm_map_t	map;
	register vm_size_t	size;
{
	vm_offset_t		addr;
	register vm_offset_t	offset;
	extern vm_object_t	kernel_object;
	vm_offset_t		i;

	size = round_page(size);

	/*
	 *	Use the kernel object for wired-down kernel pages.
	 *	Assume that no region of the kernel object is
	 *	referenced more than once.
	 */

	/*
	 * Locate sufficient space in the map.  This will give us the
	 * final virtual address for the new memory, and thus will tell
	 * us the offset within the kernel map.
	 */
	vm_map_lock(map);
	if (vm_map_findspace(map, 0, size, &addr)) {
		vm_map_unlock(map);
		return (0);
	}
	offset = addr - VM_MIN_KERNEL_ADDRESS;
	vm_object_reference(kernel_object);
	vm_map_insert(map, kernel_object, offset, addr, addr + size);
	vm_map_unlock(map);

	/*
	 *	Guarantee that there are pages already in this object
	 *	before calling vm_map_pageable.  This is to prevent the
	 *	following scenario:
	 *
	 *		1) Threads have swapped out, so that there is a
	 *		   pager for the kernel_object.
	 *		2) The kmsg zone is empty, and so we are kmem_allocing
	 *		   a new page for it.
	 *		3) vm_map_pageable calls vm_fault; there is no page,
	 *		   but there is a pager, so we call
	 *		   pager_data_request.  But the kmsg zone is empty,
	 *		   so we must kmem_alloc.
	 *		4) goto 1
	 *		5) Even if the kmsg zone is not empty: when we get
	 *		   the data back from the pager, it will be (very
	 *		   stale) non-zero data.  kmem_alloc is defined to
	 *		   return zero-filled memory.
	 *
	 *	We're intentionally not activating the pages we allocate
	 *	to prevent a race with page-out.  vm_map_pageable will wire
	 *	the pages.
	 */

	vm_object_lock(kernel_object);
	for (i = 0; i < size; i += PAGE_SIZE) {
		vm_page_t	mem;

		while ((mem = vm_page_alloc(kernel_object, offset + i)) ==
		    NULL) {
			vm_object_unlock(kernel_object);
			vm_wait("fKmwire");
			vm_object_lock(kernel_object);
		}
		vm_page_zero_fill(mem);
		mem->flags &= ~PG_BUSY;
	}
	vm_object_unlock(kernel_object);
		
	/*
	 * And finally, mark the data as non-pageable.
	 */

	(void)vm_map_pageable(map, (vm_offset_t)addr, addr + size, FALSE);

	/*
	 * Try to coalesce the map
	 */

	vm_map_simplify(map, addr);

	return (addr);
}

/*
 *	kmem_free:
 *
 *	Release a region of kernel virtual memory allocated
 *	with kmem_alloc, and return the physical pages
 *	associated with that region.
 */
void
kmem_free(map, addr, size)
	vm_map_t		map;
	register vm_offset_t	addr;
	vm_size_t		size;
{
	(void)vm_map_remove(map, trunc_page(addr), round_page(addr + size));
}

/*
 *	kmem_suballoc:
 *
 *	Allocates a map to manage a subrange
 *	of the kernel virtual address space.
 *
 *	Arguments are as follows:
 *
 *	parent		Map to take range from
 *	size		Size of range to find
 *	min, max	Returned endpoints of map
 *	pageable	Can the region be paged
 */
vm_map_t
kmem_suballoc(parent, min, max, size, pageable)
	register vm_map_t	parent;
	vm_offset_t		*min, *max;
	register vm_size_t	size;
	boolean_t		pageable;
{
	register int	ret;
	vm_map_t	result;

	size = round_page(size);

	*min = (vm_offset_t)vm_map_min(parent);
	ret = vm_map_find(parent, NULL, (vm_offset_t)0, min, size, TRUE);
	if (ret != KERN_SUCCESS) {
		printf("kmem_suballoc: bad status return of %d.\n", ret);
		panic("kmem_suballoc");
	}
	*max = *min + size;
	pmap_reference(vm_map_pmap(parent));
	result = vm_map_create(vm_map_pmap(parent), *min, *max, pageable);
	if (result == NULL)
		panic("kmem_suballoc: cannot create submap");
	if ((ret = vm_map_submap(parent, *min, *max, result)) != KERN_SUCCESS)
		panic("kmem_suballoc: unable to change range to submap");
	return (result);
}

/*
 * Allocate wired-down memory in the kernel's address map for the higher
 * level kernel memory allocator (kern/kern_malloc.c).  We cannot use
 * kmem_alloc() because we may need to allocate memory at interrupt
 * level where we cannot block (canwait == FALSE).
 *
 * This routine has its own private kernel submap (kmem_map) and object
 * (kmem_object).  This, combined with the fact that only malloc uses
 * this routine, ensures that we will never block in map or object waits.
 *
 * Note that this still only works in a uni-processor environment and
 * when called at splimp().
 *
 * We don't worry about expanding the map (adding entries) since entries
 * for wired maps are statically allocated.
 */
vm_offset_t
kmem_malloc(map, size, canwait)
	register vm_map_t	map;
	register vm_size_t	size;
	boolean_t		canwait;
{
	register vm_offset_t	offset, i;
	vm_map_entry_t		entry;
	vm_offset_t		addr;
	vm_page_t		m;
	extern vm_object_t	kmem_object;

	if (map != kmem_map && map != mb_map)
		panic("kern_malloc_alloc: map != {kmem,mb}_map");

	size = round_page(size);
	addr = vm_map_min(map);

	/*
	 * Locate sufficient space in the map.  This will give us the
	 * final virtual address for the new memory, and thus will tell
	 * us the offset within the kernel map.
	 */
	vm_map_lock(map);
	if (vm_map_findspace(map, 0, size, &addr)) {
		vm_map_unlock(map);
		/*
		 * Should wait, but that makes no sense since we will
		 * likely never wake up unless action to free resources
		 * is taken by the calling subsystem.
		 *
		 * We return NULL, and if the caller was able to wait
		 * then they should take corrective action and retry.
		 */
		return (0);
	}
	offset = addr - vm_map_min(kmem_map);
	vm_object_reference(kmem_object);
	vm_map_insert(map, kmem_object, offset, addr, addr + size);

	/*
	 * If we can wait, just mark the range as wired
	 * (will fault pages as necessary).
	 */
	if (canwait) {
		vm_map_unlock(map);
		(void)vm_map_pageable(map, (vm_offset_t)addr, addr + size,
		    FALSE);
		vm_map_simplify(map, addr);
		return (addr);
	}

	/*
	 * If we cannot wait then we must allocate all memory up front,
	 * pulling it off the active queue to prevent pageout.
	 */
	vm_object_lock(kmem_object);
	for (i = 0; i < size; i += PAGE_SIZE) {
		m = vm_page_alloc(kmem_object, offset + i);

		/*
		 * Ran out of space, free everything up and return.
		 * Don't need to lock page queues here as we know
		 * that the pages we got aren't on any queues.
		 */
		if (m == NULL) {
			while (i != 0) {
				i -= PAGE_SIZE;
				m = vm_page_lookup(kmem_object, offset + i);
				vm_page_free(m);
			}
			vm_object_unlock(kmem_object);
			vm_map_delete(map, addr, addr + size);
			vm_map_unlock(map);
			return (0);
		}
#if 0
		vm_page_zero_fill(m);
#endif
		m->flags &= ~PG_BUSY;
	}
	vm_object_unlock(kmem_object);

	/*
	 * Mark map entry as non-pageable.
	 * Assert: vm_map_insert() will never be able to extend the previous
	 * entry so there will be a new entry exactly corresponding to this
	 * address range and it will have wired_count == 0.
	 */
	if (!vm_map_lookup_entry(map, addr, &entry) ||
	    entry->start != addr || entry->end != addr + size ||
	    entry->wired_count)
		panic("kmem_malloc: entry not found or misaligned");
	entry->wired_count++;

	/*
	 * Loop thru pages, entering them in the pmap.
	 * (We cannot add them to the wired count without
	 * wrapping the vm_page_queue_lock in splimp...)
	 */
	for (i = 0; i < size; i += PAGE_SIZE) {
		vm_object_lock(kmem_object);
		m = vm_page_lookup(kmem_object, offset + i);
		vm_object_unlock(kmem_object);
		pmap_enter(map->pmap, addr + i, VM_PAGE_TO_PHYS(m),
		    VM_PROT_DEFAULT, TRUE, 0);
	}
	vm_map_unlock(map);

	vm_map_simplify(map, addr);
	return (addr);
}

/*
 *	kmem_alloc_wait
 *
 *	Allocates pageable memory from a sub-map of the kernel.  If the submap
 *	has no room, the caller sleeps waiting for more memory in the submap.
 *
 */
vm_offset_t
kmem_alloc_wait(map, size)
	vm_map_t	map;
	vm_size_t	size;
{
	vm_offset_t	addr;

	size = round_page(size);

	for (;;) {
		/*
		 * To make this work for more than one map,
		 * use the map's lock to lock out sleepers/wakers.
		 */
		vm_map_lock(map);
		if (vm_map_findspace(map, 0, size, &addr) == 0)
			break;
		/* no space now; see if we can ever get space */
		if (vm_map_max(map) - vm_map_min(map) < size) {
			vm_map_unlock(map);
			return (0);
		}
		assert_wait(map, TRUE);
		vm_map_unlock(map);
		thread_block("mKmwait");
	}
	vm_map_insert(map, NULL, (vm_offset_t)0, addr, addr + size);
	vm_map_unlock(map);
	return (addr);
}

/*
 *	kmem_free_wakeup
 *
 *	Returns memory to a submap of the kernel, and wakes up any threads
 *	waiting for memory in that map.
 */
void
kmem_free_wakeup(map, addr, size)
	vm_map_t	map;
	vm_offset_t	addr;
	vm_size_t	size;
{
	vm_map_lock(map);
	(void)vm_map_delete(map, trunc_page(addr), round_page(addr + size));
	thread_wakeup(map);
	vm_map_unlock(map);
}

/*
 * Create the kernel map; insert a mapping covering kernel text, data, bss,
 * and all space allocated thus far (`boostrap' data).  The new map will thus
 * map the range between VM_MIN_KERNEL_ADDRESS and `start' as allocated, and
 * the range between `start' and `end' as free.
 */
void
kmem_init(start, end)
	vm_offset_t start, end;
{
	register vm_map_t m;

	m = vm_map_create(pmap_kernel(), VM_MIN_KERNEL_ADDRESS, end, FALSE);
	vm_map_lock(m);
	/* N.B.: cannot use kgdb to debug, starting with this assignment ... */
	kernel_map = m;
	(void)vm_map_insert(m, NULL, (vm_offset_t)0, VM_MIN_KERNEL_ADDRESS,
	    start);
	/* ... and ending with the completion of the above `insert' */
	vm_map_unlock(m);
}
@


1.11
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_kern.c,v 1.10 1998/03/01 00:38:08 niklas Exp $	*/
@


1.11.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_kern.c,v 1.11 1999/09/03 18:02:27 art Exp $	*/
@


1.10
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_kern.c,v 1.9 1998/02/23 20:22:17 niklas Exp $	*/
d381 1
a381 1
		    VM_PROT_DEFAULT, TRUE);
@


1.9
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_kern.c,v 1.8 1997/11/06 05:59:33 csapuntz Exp $	*/
d180 1
a180 1
			VM_WAIT;
d244 1
a244 1
	*min = (vm_offset_t) vm_map_min(parent);
d420 1
a420 1
		thread_block();
@


1.8
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_kern.c,v 1.7 1997/10/06 20:21:19 deraadt Exp $	*/
d104 1
a104 2
	result = vm_map_find(map, NULL, (vm_offset_t) 0,
				&addr, size, TRUE);
d106 1
a106 1
		return(0);
d109 1
a109 1
	return(addr);
d174 1
a174 1
	for (i = 0 ; i < size; i+= PAGE_SIZE) {
d177 2
a178 1
		while ((mem = vm_page_alloc(kernel_object, offset+i)) == NULL) {
d189 1
a189 1
	 *	And finally, mark the data as non-pageable.
d192 1
a192 1
	(void) vm_map_pageable(map, (vm_offset_t) addr, addr + size, FALSE);
d195 1
a195 1
	 *	Try to coalesce the map
d200 1
a200 1
	return(addr);
d216 1
a216 1
	(void) vm_map_remove(map, trunc_page(addr), round_page(addr + size));
d245 1
a245 2
	ret = vm_map_find(parent, NULL, (vm_offset_t) 0,
				min, size, TRUE);
d257 1
a257 1
	return(result);
d322 2
a323 2
		(void) vm_map_pageable(map, (vm_offset_t) addr, addr + size,
				       FALSE);
d325 1
a325 1
		return(addr);
d350 1
a350 1
			return(0);
d381 1
a381 1
			   VM_PROT_DEFAULT, TRUE);
d386 1
a386 1
	return(addr);
d440 1
a440 1
	(void) vm_map_delete(map, trunc_page(addr), round_page(addr + size));
d461 2
a462 2
	(void) vm_map_insert(m, NULL, (vm_offset_t)0,
	    VM_MIN_KERNEL_ADDRESS, start);
@


1.7
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_kern.c,v 1.5 1997/09/22 15:17:18 chuck Exp $	*/
d39 1
a39 1
 *	@@(#)vm_kern.c	8.3 (Berkeley) 1/12/94
@


1.6
log
@VFS Lite2 Changes
@
text
@d39 1
a39 1
 *	@@(#)vm_kern.c	8.4 (Berkeley) 1/9/95
@


1.5
log
@correct a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_kern.c,v 1.4 1997/04/17 01:25:18 niklas Exp $	*/
d39 1
a39 1
 *	@@(#)vm_kern.c	8.3 (Berkeley) 1/12/94
@


1.4
log
@Removal of race conditions.  Inspired by Charles Hannum's
<mycroft@@netbsd.org> reorganization of the vm_collapse logic, although not
used verbatim.  We no longer collapse objects from the pagedaemon as that
is not necessary anymore with the more aggressive collapses that gets done.
This also increases performance of loaded systems.  Much KNF too.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_kern.c,v 1.3 1996/08/02 00:06:01 niklas Exp $	*/
d272 1
a272 1
 * when called at splhigh().
@


1.3
log
@Fix long-standing swap-leak. Add OpenBSD tags. Optimize thread_wakeup.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_kern.c,v 1.17.6.1 1996/06/13 17:21:28 cgd Exp $	*/
d77 1
@


1.2
log
@kern_malloc() can fail in canwait case if no more map space; return NULL in
that case so that callers can deal with shortage rather than deadlocking.
@
text
@d1 1
d74 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vm_kern.c,v 1.17 1995/04/10 16:53:55 mycroft Exp $	*/
d300 8
a307 3
		if (canwait)		/* XXX  should wait */
			panic("kmem_malloc: %s too small",
			    map == kmem_map ? "kmem_map" : "mb_map");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

