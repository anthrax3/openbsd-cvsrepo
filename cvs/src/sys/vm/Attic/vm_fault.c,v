head	1.20;
access;
symbols
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	UBC_SYNC_A:1.20
	UBC_SYNC_B:1.20
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.10
	OPENBSD_2_8:1.17.0.8
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.17.0.6
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.4
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.16.0.6
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.4
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2001.06.27.04.53.30;	author art;	state dead;
branches;
next	1.19;

1.19
date	2001.06.08.08.09.43;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.09.15.31.23;	author art;	state Exp;
branches;
next	1.17;

1.17
date	99.09.03.18.02.27;	author art;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	98.03.30.18.50.59;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	98.03.26.21.36.18;	author chuck;	state Exp;
branches;
next	1.14;

1.14
date	98.03.01.00.38.04;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.11.06.05.59.32;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.20.21.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.15.28.52;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.07.30.23.32.24;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.07.30.20.31.24;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.07.30.20.09.26;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.06.03.06;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.17.01.25.17;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.47.14;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.08.02.00.05.59;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.05.23.08.34.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.45.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.36;	author deraadt;	state Exp;
branches;
next	;

1.17.4.1
date	2001.07.04.11.01.17;	author niklas;	state dead;
branches;
next	;


desc
@@


1.20
log
@Die!
@
text
@/*	$OpenBSD: vm_fault.c,v 1.19 2001/06/08 08:09:43 art Exp $	*/
/*	$NetBSD: vm_fault.c,v 1.21 1998/01/31 04:02:39 ross Exp $	*/

/* 
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * The Mach Operating System project at Carnegie-Mellon University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_fault.c	8.5 (Berkeley) 1/9/95
 *
 *
 * Copyright (c) 1987, 1990 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Avadis Tevanian, Jr., Michael Wayne Young
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 *	Page fault handling module.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/user.h>

#include <vm/vm.h>
#include <vm/vm_page.h>
#include <vm/vm_pageout.h>

/*
 *	vm_fault:
 *
 *	Handle a page fault occuring at the given address,
 *	requiring the given permissions, in the map specified.
 *	If successful, the page is inserted into the
 *	associated physical map.
 *
 *	NOTE: the given address should be truncated to the
 *	proper page address.
 *
 *	KERN_SUCCESS is returned if the page fault is handled; otherwise,
 *	a standard error specifying why the fault is fatal is returned.
 *
 *
 *	The map in question must be referenced, and remains so.
 *	Caller may hold no locks.
 */
int
vm_fault(map, vaddr, fault_type, change_wiring)
	vm_map_t	map;
	vm_offset_t	vaddr;
	vm_prot_t	fault_type;
	boolean_t	change_wiring;
{
	vm_object_t		first_object;
	vm_offset_t		first_offset;
	vm_map_entry_t		entry;
	register vm_object_t	object;
	register vm_offset_t	offset;
	register vm_page_t	m;
	vm_page_t		first_m;
	vm_prot_t		prot;
	int			result;
	boolean_t		wired;
	boolean_t		su;
	boolean_t		lookup_still_valid;
	boolean_t		page_exists;
	vm_page_t		old_m;
	vm_object_t		next_object;

	cnt.v_faults++;		/* needs lock XXX */

/*
 *	Recovery actions
 */
#define	FREE_PAGE(m)	{				\
	PAGE_WAKEUP(m);					\
	vm_page_lock_queues();				\
	vm_page_free(m);				\
	vm_page_unlock_queues();			\
}

#define	RELEASE_PAGE(m)	{				\
	PAGE_WAKEUP(m);					\
	vm_page_lock_queues();				\
	vm_page_activate(m);				\
	vm_page_unlock_queues();			\
}

#define	UNLOCK_MAP	{				\
	if (lookup_still_valid) {			\
		vm_map_lookup_done(map, entry);		\
		lookup_still_valid = FALSE;		\
	}						\
}

#define	UNLOCK_THINGS	{				\
	vm_object_paging_end(object);			\
	vm_object_unlock(object);			\
	if (object != first_object) {			\
		vm_object_lock(first_object);		\
		FREE_PAGE(first_m);			\
		vm_object_paging_end(first_object);	\
		vm_object_unlock(first_object);		\
	}						\
	UNLOCK_MAP;					\
}

#define	UNLOCK_AND_DEALLOCATE	{			\
	UNLOCK_THINGS;					\
	vm_object_deallocate(first_object);		\
}

    RetryFault: ;

	/*
	 *	Find the backing store object and offset into
	 *	it to begin the search.
	 */

	if ((result = vm_map_lookup(&map, vaddr, fault_type, &entry,
	    &first_object, &first_offset, &prot, &wired, &su)) !=
	    KERN_SUCCESS) {
		return (result);
	}
	lookup_still_valid = TRUE;

	if (wired)
		fault_type = prot;

	first_m = NULL;

	/*
	 *	Make a reference to this object to
	 *	prevent its disposal while we are messing with
	 *	it.  Once we have the reference, the map is free
	 *	to be diddled.  Since objects reference their
	 *	shadows (and copies), they will stay around as well.
	 */

	vm_object_lock(first_object);

	first_object->ref_count++;
	vm_object_paging_begin(first_object);

	/*
	 * INVARIANTS (through entire routine):
	 *
	 * 1)	At all times, we must either have the object lock or a busy
	 *	page in some object to prevent some other thread from trying
	 *	to bring in the same page.
	 *
	 * 	Note that we cannot hold any locks during the pager access or
	 *	when waiting for memory, so we use a busy page then.
	 *
	 * 	Note also that we aren't as concerned about more than one thead
	 *	attempting to pager_data_unlock the same page at once, so we
	 *	don't hold the page as busy then, but do record the highest
	 *	unlock value so far.  [Unlock requests may also be delivered
	 * 	out of order.]
	 *
	 * 2)	Once we have a busy page, we must remove it from the pageout
	 *	queues, so that the pageout daemon will not grab it away.
	 *
	 * 3)	To prevent another thread from racing us down the shadow chain
	 *	and entering a new page in the top object before we do, we must
	 *	keep a busy page in the top object while following the shadow
	 *	chain.
	 *
	 * 4)	We must increment paging_in_progress on any object for which we
	 *	have a busy page, to prevent vm_object_collapse from removing
	 *	the busy page without our noticing.
	 */

	/*
	 * Search for the page at object/offset.
	 */
	object = first_object;
	offset = first_offset;

	/*
	 * See whether this page is resident
	 */
	while (TRUE) {
		m = vm_page_lookup(object, offset);
		if (m != NULL) {
			/*
			 * If the page is being brought in,
			 * wait for it and then retry.
			 */
			if (m->flags & PG_BUSY) {
#ifdef DOTHREADS
				int	wait_result;

				PAGE_ASSERT_WAIT(m, !change_wiring);
				UNLOCK_THINGS;
				thread_block("mFltbsy");
				wait_result = current_thread()->wait_result;
				vm_object_deallocate(first_object);
				if (wait_result != THREAD_AWAKENED)
					return (KERN_SUCCESS);
				goto RetryFault;
#else
				PAGE_ASSERT_WAIT(m, !change_wiring);
				UNLOCK_THINGS;
				cnt.v_intrans++;
				thread_block("mFltbsy2");
				vm_object_deallocate(first_object);
				goto RetryFault;
#endif
			}

			/*
			 * Remove the page from the pageout daemon's
			 * reach while we play with it.
			 */

			vm_page_lock_queues();
			if (m->flags & PG_INACTIVE) {
				TAILQ_REMOVE(&vm_page_queue_inactive, m,
				    pageq);
				m->flags &= ~PG_INACTIVE;
				cnt.v_inactive_count--;
				cnt.v_reactivated++;
			} 

			if (m->flags & PG_ACTIVE) {
				TAILQ_REMOVE(&vm_page_queue_active, m, pageq);
				m->flags &= ~PG_ACTIVE;
				cnt.v_active_count--;
			}
			vm_page_unlock_queues();

			/*
			 * Mark page busy for other threads.
			 */
			m->flags |= PG_BUSY;
			if (curproc != &proc0)
				curproc->p_addr->u_stats.p_ru.ru_minflt++;
			break;
		}

		if (((object->pager != NULL) && (!change_wiring || wired))
		    || (object == first_object)) {

			/*
			 * Allocate a new page for this object/offset
			 * pair.
			 */
			m = vm_page_alloc(object, offset);

			if (m == NULL) {
				UNLOCK_AND_DEALLOCATE;
				vm_wait("fVfault1");
				goto RetryFault;
			}
		}

		if (object->pager != NULL && (!change_wiring || wired)) {
			int rv;

			/*
			 * Now that we have a busy page, we can
			 * release the object lock.
			 */
			vm_object_unlock(object);

			/*
			 * Call the pager to retrieve the data, if any,
			 * after releasing the lock on the map.
			 */
			UNLOCK_MAP;
			cnt.v_pageins++;
			rv = vm_pager_get(object->pager, m, TRUE);

			/*
			 * Reaquire the object lock to preserve our
			 * invariant.
			 */
			vm_object_lock(object);

			/*
			 * Found the page.
			 * Leave it busy while we play with it.
			 */
			if (rv == VM_PAGER_OK) {
				/*
				 * Relookup in case pager changed page.
				 * Pager is responsible for disposition
				 * of old page if moved.
				 */
				m = vm_page_lookup(object, offset);

				cnt.v_pgpgin++;
				m->flags &= ~PG_FAKE;
				m->flags |= PG_CLEAN;
				pmap_clear_modify(VM_PAGE_TO_PHYS(m));
				if (curproc != &proc0)
					curproc->p_addr->
					    u_stats.p_ru.ru_majflt++;
				break;
			}

			/*
			 * IO error or page outside the range of the pager:
			 * cleanup and return an error.
			 */
			if (rv == VM_PAGER_ERROR || rv == VM_PAGER_BAD) {
				FREE_PAGE(m);
				UNLOCK_AND_DEALLOCATE;
				return (KERN_PROTECTION_FAILURE); /* XXX */
			}
			/*
			 * rv == VM_PAGER_FAIL:
			 *
			 * Page does not exist at this object/offset.
			 * Free the bogus page (waking up anyone waiting
			 * for it) and continue on to the next object.
			 *
			 * If this is the top-level object, we must
			 * leave the busy page to prevent another
			 * thread from rushing past us, and inserting
			 * the page in that object at the same time
			 * that we are.
			 */
			if (object != first_object) {
				FREE_PAGE(m);
				/* note that `m' is not used after this */
			}
		}

		/*
		 * We get here if the object has no pager (or unwiring)
		 * or the pager doesn't have the page.
		 */
		if (object == first_object)
			first_m = m;

		/*
		 * Move on to the next object.  Lock the next
		 * object before unlocking the current one.
		 */

		offset += object->shadow_offset;
		next_object = object->shadow;
		if (next_object == NULL) {
			/*
			 * If there's no object left, fill the page
			 * in the top object with zeros.
			 */
			if (object != first_object) {
				vm_object_paging_end(object);
				vm_object_unlock(object);

				object = first_object;
				offset = first_offset;
				m = first_m;
				vm_object_lock(object);
			}
			first_m = NULL;

			vm_page_zero_fill(m);
			cnt.v_zfod++;
			m->flags &= ~PG_FAKE;
			if (curproc != &proc0)
				curproc->p_addr->u_stats.p_ru.ru_minflt++;
			break;
		}
		else {
			vm_object_lock(next_object);
			if (object != first_object)
				vm_object_paging_end(object);
			vm_object_unlock(object);
			object = next_object;
			vm_object_paging_begin(object);
		}
	}

	if ((m->flags & (PG_ACTIVE | PG_INACTIVE | PG_BUSY)) != PG_BUSY)
		panic("vm_fault: active, inactive or !busy after main loop");

	/*
	 * PAGE HAS BEEN FOUND.
	 * [Loop invariant still holds -- the object lock is held.]
	 */
	old_m = m;	/* save page that would be copied */

	/*
	 * If the page is being written, but isn't already owned by the
	 * top-level object, we have to copy it into a new page owned
	 * by the top-level object.
	 */
	if (object != first_object) {
	    	/*
		 * We only really need to copy if we want to write it.
		 */
	    	if (fault_type & VM_PROT_WRITE) {

			/*
			 * If we try to collapse first_object at this
			 * point, we may deadlock when we try to get
			 * the lock on an intermediate object (since we
			 * have the bottom object locked).  We can't
			 * unlock the bottom object, because the page
			 * we found may move (by collapse) if we do.
			 *
			 * Instead, we first copy the page.  Then, when
			 * we have no more use for the bottom object,
			 * we unlock it and try to collapse.
			 *
			 * Note that we copy the page even if we didn't
			 * need to... that's the breaks.
			 */

		    	/*
			 * We already have an empty page in
			 * first_object - use it.
			 */
			vm_page_copy(m, first_m);
			first_m->flags &= ~PG_FAKE;

			/*
			 * If another map is truly sharing this
			 * page with us, we have to flush all
			 * uses of the original page, since we
			 * can't distinguish those which want the
			 * original from those which need the
			 * new copy.
			 *
			 * XXX If we know that only one map has
			 * access to this page, then we could
			 * avoid the pmap_page_protect() call.
			 */
			vm_page_lock_queues();
			vm_page_deactivate(m);
			pmap_page_protect(VM_PAGE_TO_PHYS(m), VM_PROT_NONE);
			vm_page_unlock_queues();

			/*
			 * We no longer need the old page or object.
			 */
			PAGE_WAKEUP(m);
			vm_object_paging_end(object);
			vm_object_unlock(object);

			/*
			 * Only use the new page below...
			 */
			cnt.v_cow_faults++;
			m = first_m;
			object = first_object;
			offset = first_offset;

			/*
			 * Now that we've gotten the copy out of the
			 * way, let's try to collapse the top object.
			 */
			vm_object_lock(object);
			/*
			 * But we have to play ugly games with
			 * paging_in_progress to do that...
			 */
			vm_object_paging_end(object);
			vm_object_collapse(object);
			vm_object_paging_begin(object);
		} else {
		    	prot &= ~VM_PROT_WRITE;
			m->flags |= PG_COPYONWRITE;
		}
	}

	if (m->flags & (PG_ACTIVE|PG_INACTIVE))
		panic("%s: active or inactive before copy object handling",
		    "vm_fault");

	/*
	 * If the page is being written, but hasn't been
	 * copied to the copy-object, we have to copy it there.
	 */
    RetryCopy:
	if (first_object->copy != NULL) {
		vm_object_t copy_object = first_object->copy;
		vm_offset_t copy_offset;
		vm_page_t copy_m;

		/*
		 * We only need to copy if we want to write it.
		 */
		if ((fault_type & VM_PROT_WRITE) == 0) {
			prot &= ~VM_PROT_WRITE;
			m->flags |= PG_COPYONWRITE;
		}
		else {
			/*
			 * Try to get the lock on the copy_object.
			 */
			if (!vm_object_lock_try(copy_object)) {
				vm_object_unlock(object);
				/* should spin a bit here... */
				vm_object_lock(object);
				goto RetryCopy;
			}

			/*
			 * Make another reference to the copy-object,
			 * to keep it from disappearing during the
			 * copy.
			 */
			copy_object->ref_count++;

			/*
			 * Does the page exist in the copy?
			 */
			copy_offset = first_offset -
			    copy_object->shadow_offset;
			copy_m = vm_page_lookup(copy_object, copy_offset);
			if ((page_exists = (copy_m != NULL)) != 0) {
				if (copy_m->flags & PG_BUSY) {
#ifdef DOTHREADS
					int	wait_result;

					/*
					 * If the page is being brought
					 * in, wait for it and then retry.
					 */
					PAGE_ASSERT_WAIT(copy_m,
					    !change_wiring);
					RELEASE_PAGE(m);
					copy_object->ref_count--;
					vm_object_unlock(copy_object);
					UNLOCK_THINGS;
					thread_block("mCpybsy");
					wait_result =
					    current_thread()->wait_result;
					vm_object_deallocate(first_object);
					if (wait_result != THREAD_AWAKENED)
						return (KERN_SUCCESS);
					goto RetryFault;
#else
					/*
					 * If the page is being brought
					 * in, wait for it and then retry.
					 */
					PAGE_ASSERT_WAIT(copy_m,
					    !change_wiring);
					RELEASE_PAGE(m);
					copy_object->ref_count--;
					vm_object_unlock(copy_object);
					UNLOCK_THINGS;
					thread_block("mCpybsy2");
					vm_object_deallocate(first_object);
					goto RetryFault;
#endif
				}
			}

			/*
			 * If the page is not in memory (in the object)
			 * and the object has a pager, we have to check
			 * if the pager has the data in secondary
			 * storage.
			 */
			if (!page_exists) {

				/*
				 * If we don't allocate a (blank) page
				 * here... another thread could try
				 * to page it in, allocate a page, and
				 * then block on the busy page in its
				 * shadow (first_object).  Then we'd
				 * trip over the busy page after we
				 * found that the copy_object's pager
				 * doesn't have the page...
				 */
				copy_m =
				    vm_page_alloc(copy_object, copy_offset);
				if (copy_m == NULL) {
					/*
					 * Wait for a page, then retry.
					 */
					RELEASE_PAGE(m);
					copy_object->ref_count--;
					vm_object_unlock(copy_object);
					UNLOCK_AND_DEALLOCATE;
					vm_wait("fCopy");
					goto RetryFault;
				}

			 	if (copy_object->pager != NULL) {
					vm_object_unlock(object);
					vm_object_unlock(copy_object);
					UNLOCK_MAP;

					page_exists = vm_pager_has_page(
					    copy_object->pager,
					    (copy_offset +
					    copy_object->paging_offset));

					vm_object_lock(copy_object);

					/*
					 * Since the map is unlocked, someone
					 * else could have copied this object
					 * and put a different copy_object
					 * between the two.  Or, the last
					 * reference to the copy-object (other
					 * than the one we have) may have
					 * disappeared - if that has happened,
					 * we don't need to make the copy.
					 */
					if (copy_object->shadow != object ||
					    copy_object->ref_count == 1) {
						/*
						 * Gaah... start over!
						 */
						FREE_PAGE(copy_m);
						vm_object_unlock(copy_object);
						/* may block */
						vm_object_deallocate(
						    copy_object);
						vm_object_lock(object);
						goto RetryCopy;
					}
					vm_object_lock(object);

					if (page_exists) {
						/*
						 * We didn't need the page
						 */
						FREE_PAGE(copy_m);
					}
				}
			}
			if (!page_exists) {
				/*
				 * Must copy page into copy-object.
				 */
				vm_page_copy(m, copy_m);
				copy_m->flags &= ~PG_FAKE;

				/*
				 * Things to remember:
				 * 1. The copied page must be marked 'dirty'
				 *    so it will be paged out to the copy
				 *    object.
				 * 2. If the old page was in use by any users
				 *    of the copy-object, it must be removed
				 *    from all pmaps.  (We can't know which
				 *    pmaps use it.)
				 */
				vm_page_lock_queues();
				pmap_page_protect(VM_PAGE_TO_PHYS(old_m),
				    VM_PROT_NONE);
				copy_m->flags &= ~PG_CLEAN;
				vm_page_activate(copy_m);	/* XXX */
				vm_page_unlock_queues();

				PAGE_WAKEUP(copy_m);
			}
			/*
			 * The reference count on copy_object must be
			 * at least 2: one for our extra reference,
			 * and at least one from the outside world
			 * (we checked that when we last locked
			 * copy_object).
			 */
			copy_object->ref_count--;
			vm_object_unlock(copy_object);
			m->flags &= ~PG_COPYONWRITE;
		}
	}

	if (m->flags & (PG_ACTIVE | PG_INACTIVE))
		panic("vm_fault: active or inactive before retrying lookup");

	/*
	 * We must verify that the maps have not changed
	 * since our last lookup.
	 */
	if (!lookup_still_valid) {
		vm_object_t	retry_object;
		vm_offset_t	retry_offset;
		vm_prot_t	retry_prot;

		/*
		 * Since map entries may be pageable, make sure we can
		 * take a page fault on them.
		 */
		vm_object_unlock(object);

		/*
		 * To avoid trying to write_lock the map while another
		 * thread has it read_locked (in vm_map_pageable), we
		 * do not try for write permission.  If the page is
		 * still writable, we will get write permission.  If it
		 * is not, or has been marked needs_copy, we enter the
		 * mapping without write permission, and will merely
		 * take another fault.
		 */
		result = vm_map_lookup(&map, vaddr,
		    fault_type & ~VM_PROT_WRITE, &entry, &retry_object,
		    &retry_offset, &retry_prot,	&wired, &su);

		vm_object_lock(object);

		/*
		 * If we don't need the page any longer, put it on the
		 * active list (the easiest thing to do here).  If no
		 * one needs it, pageout will grab it eventually.
		 */

		if (result != KERN_SUCCESS) {
			RELEASE_PAGE(m);
			UNLOCK_AND_DEALLOCATE;
			return (result);
		}

		lookup_still_valid = TRUE;

		if ((retry_object != first_object) ||
		    (retry_offset != first_offset)) {
			RELEASE_PAGE(m);
			UNLOCK_AND_DEALLOCATE;
			goto RetryFault;
		}

		/*
		 * Check whether the protection has changed or the object
		 * has been copied while we left the map unlocked.
		 * Changing from read to write permission is OK - we leave
		 * the page write-protected, and catch the write fault.
		 * Changing from write to read permission means that we
		 * can't mark the page write-enabled after all.
		 */
		prot &= retry_prot;
		if (m->flags & PG_COPYONWRITE)
			prot &= ~VM_PROT_WRITE;
	}

	/*
	 * (the various bits we're fiddling with here are locked by
	 * the object's lock)
	 */

	/* XXX This distorts the meaning of the copy_on_write bit */

	if (prot & VM_PROT_WRITE)
		m->flags &= ~PG_COPYONWRITE;

	/*
	 * It's critically important that a wired-down page be faulted
	 * only once in each map for which it is wired.
	 */

	if (m->flags & (PG_ACTIVE | PG_INACTIVE))
		panic("vm_fault: active or inactive before pmap_enter");

	vm_object_unlock(object);

	/*
	 * Put this page into the physical map.
	 * We had to do the unlock above because pmap_enter
	 * may cause other faults.   We don't put the
	 * page back on the active queue until later so
	 * that the page-out daemon won't find us (yet).
	 */

	pmap_enter(map->pmap, vaddr, VM_PAGE_TO_PHYS(m), prot, wired, 0);

	/*
	 * If the page is not wired down, then put it where the
	 * pageout daemon can find it.
	 */
	vm_object_lock(object);
	vm_page_lock_queues();
	if (change_wiring) {
		if (wired)
			vm_page_wire(m);
		else
			vm_page_unwire(m);
	}
	else
		vm_page_activate(m);
	vm_page_unlock_queues();

	/*
	 * Unlock everything, and return
	 */

	PAGE_WAKEUP(m);
	UNLOCK_AND_DEALLOCATE;

	return (KERN_SUCCESS);
}

/*
 * vm_fault_wire:
 *
 * Wire down a range of virtual addresses in a map.
 */
int
vm_fault_wire(map, start, end)
	vm_map_t	map;
	vm_offset_t	start, end;
{
	register vm_offset_t	va;
	register pmap_t		pmap;
	int			rv;

	pmap = vm_map_pmap(map);

	/*
	 * We simulate a fault to get the page and enter it
	 * in the physical map.
	 */

	for (va = start; va < end; va += PAGE_SIZE) {
		rv = vm_fault(map, va, VM_PROT_NONE, TRUE);
		if (rv) {
			if (va != start)
				vm_fault_unwire(map, start, va);
			return (rv);
		}
	}
	return (KERN_SUCCESS);
}


/*
 * vm_fault_unwire:
 *
 * Unwire a range of virtual addresses in a map.
 */
void
vm_fault_unwire(map, start, end)
	vm_map_t	map;
	vm_offset_t	start, end;
{

	register vm_offset_t	va;
	vm_offset_t pa;
	register pmap_t		pmap;

	pmap = vm_map_pmap(map);

	/*
	 * Since the pages are wired down, we must be able to
	 * get their mappings from the physical map system.
	 */
	vm_page_lock_queues();

	for (va = start; va < end; va += PAGE_SIZE) {
		if (pmap_extract(pmap, va, &pa) == FALSE) {
			panic("unwire: page not in pmap");
		}
		pmap_unwire(pmap, va);
		vm_page_unwire(PHYS_TO_VM_PAGE(pa));
	}
	vm_page_unlock_queues();
}

/*
 * Routine:
 * 	vm_fault_copy_entry
 * Function:
 * 	Copy all of the pages from a wired-down map entry to another.
 *
 * In/out conditions:
 * 	The source and destination maps must be locked for write.
 * 	The source map entry must be wired down (or be a sharing map
 * 	entry corresponding to a main map entry that is wired down).
 */
void
vm_fault_copy_entry(dst_map, src_map, dst_entry, src_entry)
	vm_map_t	dst_map;
	vm_map_t	src_map;
	vm_map_entry_t	dst_entry;
	vm_map_entry_t	src_entry;
{

	vm_object_t	dst_object;
	vm_object_t	src_object;
	vm_offset_t	dst_offset;
	vm_offset_t	src_offset;
	vm_prot_t	prot;
	vm_offset_t	vaddr;
	vm_page_t	dst_m;
	vm_page_t	src_m;

#ifdef	lint
	src_map++;
#endif

	src_object = src_entry->object.vm_object;
	src_offset = src_entry->offset;

	/*
	 * Create the top-level object for the destination entry.
	 * (Doesn't actually shadow anything - we copy the pages
	 * directly.)
	 */
	dst_object =
	    vm_object_allocate((vm_size_t)(dst_entry->end - dst_entry->start));

	dst_entry->object.vm_object = dst_object;
	dst_entry->offset = 0;

	prot = dst_entry->max_protection;

	/*
	 * Loop through all of the pages in the entry's range, copying
	 * each one from the source object (it should be there) to the
	 * destination object.
	 */
	for (vaddr = dst_entry->start, dst_offset = 0;
	    vaddr < dst_entry->end;
	    vaddr += PAGE_SIZE, dst_offset += PAGE_SIZE) {

		/*
		 * Allocate a page in the destination object
		 */
		vm_object_lock(dst_object);
		do {
			dst_m = vm_page_alloc(dst_object, dst_offset);
			if (dst_m == NULL) {
				vm_object_unlock(dst_object);
				vm_wait("fVm_copy");
				vm_object_lock(dst_object);
			}
		} while (dst_m == NULL);

		/*
		 * Find the page in the source object, and copy it in.
		 * (Because the source is wired down, the page will be
		 * in memory.)
		 */
		vm_object_lock(src_object);
		src_m = vm_page_lookup(src_object, dst_offset + src_offset);
		if (src_m == NULL)
			panic("vm_fault_copy_wired: page missing");

		vm_page_copy(src_m, dst_m);

		/*
		 * Enter it in the pmap...
		 */
		vm_object_unlock(src_object);
		vm_object_unlock(dst_object);

		pmap_enter(dst_map->pmap, vaddr, VM_PAGE_TO_PHYS(dst_m), prot,
		    FALSE, 0);

		/*
		 * Mark it no longer busy, and put it on the active list.
		 */
		vm_object_lock(dst_object);
		vm_page_lock_queues();
		vm_page_activate(dst_m);
		vm_page_unlock_queues();
		PAGE_WAKEUP(dst_m);
		vm_object_unlock(dst_object);
	}

}
@


1.19
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.18 2001/05/09 15:31:23 art Exp $	*/
@


1.18
log
@More sync to NetBSD.

 - Change pmap_change_wiring to pmap_unwire because it's only called that way.
 - Remove pmap_pageable because it's seldom implemented and when it is, it's
   either almost useless or incorrect. The same information is already passed
   to the pmap anyway by pmap_enter and pmap_unwire.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.17 1999/09/03 18:02:27 art Exp $	*/
d891 2
a892 1
	register vm_offset_t	va, pa;
d904 1
a904 2
		pa = pmap_extract(pmap, va);
		if (pa == (vm_offset_t)0) {
@


1.17
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.16 1998/03/30 18:50:59 niklas Exp $	*/
a863 8
	 * Inform the physical mapping system that the
	 * range of addresses may not fault, so that
	 * page tables and such can be locked down as well.
	 */

	pmap_pageable(pmap, start, end, FALSE);

	/*
d907 1
a907 1
		pmap_change_wiring(pmap, va, FALSE);
a910 9

	/*
	 * Inform the physical mapping system that the range
	 * of addresses may fault, so that page tables and
	 * such may be unwired themselves.
	 */

	pmap_pageable(pmap, start, end, TRUE);

@


1.17.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.17 1999/09/03 18:02:27 art Exp $	*/
@


1.16
log
@do not count proc0 faults (happens in amiga pmap_init)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.15 1998/03/26 21:36:18 chuck Exp $	*/
d819 1
a819 1
	pmap_enter(map->pmap, vaddr, VM_PAGE_TO_PHYS(m), prot, wired);
d1019 1
a1019 1
		    FALSE);
@


1.15
log
@correctly count ru_majflt.   the fix pulled in from netbsd pr#1397 is
incorrect.  calling vm_pager_get() doesn't count as a "majflt" unless the
pager returns VM_PAGER_OK.  when walking an object chain we can get
VM_PAGER_FAIL (indicating that the requested data does not reside in
this object and we must continue to walk the chain) -- we don't want to
count this as a majflt.

i also added code to count ru_minflt.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.14 1998/03/01 00:38:04 niklas Exp $	*/
d289 2
a290 1
			curproc->p_addr->u_stats.p_ru.ru_minflt++;
d349 3
a351 1
				curproc->p_addr->u_stats.p_ru.ru_majflt++;
d416 2
a417 1
			curproc->p_addr->u_stats.p_ru.ru_minflt++;
@


1.14
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.13 1997/11/06 05:59:32 csapuntz Exp $	*/
d289 1
a323 1
			curproc->p_addr->u_stats.p_ru.ru_majflt++;
d348 1
d413 1
@


1.13
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_fault.c,v 1.12 1997/10/06 20:21:17 deraadt Exp $	*/
/*	$NetBSD: vm_fault.c,v 1.20 1997/02/18 13:39:33 mrg Exp $	*/
d248 1
a248 1
				thread_block();
d258 1
a258 1
				thread_block();
d303 1
a303 1
				VM_WAIT;
d577 1
a577 1
					thread_block();
d595 1
a595 1
					thread_block();
d630 1
a630 1
					VM_WAIT;
d989 1
a989 1
				VM_WAIT;
@


1.12
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.10 1997/07/30 23:32:24 niklas Exp $	*/
d39 1
a39 1
 *	@@(#)vm_fault.c	8.4 (Berkeley) 1/12/94
@


1.11
log
@VFS Lite2 Changes
@
text
@d39 1
a39 1
 *	@@(#)vm_fault.c	8.5 (Berkeley) 1/9/95
@


1.10
log
@backout the curproc dereference change says kstailey@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.7 1997/07/25 06:03:06 mickey Exp $	*/
d39 1
a39 1
 *	@@(#)vm_fault.c	8.4 (Berkeley) 1/12/94
@


1.9
log
@KNF
@
text
@d323 1
a323 2
			if (curproc)
				curproc->p_addr->u_stats.p_ru.ru_majflt++;
@


1.8
log
@From NetBSD: protect a curproc dereference against NULL
@
text
@d123 1
d173 3
a175 3
			&first_object, &first_offset,
			&prot, &wired, &su)) != KERN_SUCCESS) {
		return(result);
d198 1
a198 1
	 *	INVARIANTS (through entire routine):
d200 3
a202 4
	 *	1)	At all times, we must either have the object
	 *		lock or a busy page in some object to prevent
	 *		some other thread from trying to bring in
	 *		the same page.
d204 2
a205 3
	 *		Note that we cannot hold any locks during the
	 *		pager access or when waiting for memory, so
	 *		we use a busy page then.
d207 5
a211 6
	 *		Note also that we aren't as concerned about
	 *		more than one thead attempting to pager_data_unlock
	 *		the same page at once, so we don't hold the page
	 *		as busy then, but do record the highest unlock
	 *		value so far.  [Unlock requests may also be delivered
	 *		out of order.]
d213 2
a214 3
	 *	2)	Once we have a busy page, we must remove it from
	 *		the pageout queues, so that the pageout daemon
	 *		will not grab it away.
d216 4
a219 4
	 *	3)	To prevent another thread from racing us down the
	 *		shadow chain and entering a new page in the top
	 *		object before we do, we must keep a busy page in
	 *		the top object while following the shadow chain.
d221 3
a223 4
	 *	4)	We must increment paging_in_progress on any object
	 *		for which we have a busy page, to prevent
	 *		vm_object_collapse from removing the busy page
	 *		without our noticing.
d227 1
a227 1
	 *	Search for the page at object/offset.
a228 1

d233 1
a233 1
	 *	See whether this page is resident
a234 1

d239 2
a240 2
			 *	If the page is being brought in,
			 *	wait for it and then retry.
d252 1
a252 1
					return(KERN_SUCCESS);
d265 2
a266 2
			 *	Remove the page from the pageout daemon's
			 *	reach while we play with it.
d271 2
a272 1
				TAILQ_REMOVE(&vm_page_queue_inactive, m, pageq);
d286 1
a286 1
			 *	Mark page busy for other threads.
d292 1
a292 2
		if (((object->pager != NULL) &&
				(!change_wiring || wired))
d296 2
a297 2
			 *	Allocate a new page for this object/offset
			 *	pair.
a298 1

d312 2
a313 2
			 *	Now that we have a busy page, we can
			 *	release the object lock.
d318 2
a319 2
			 *	Call the pager to retrieve the data, if any,
			 *	after releasing the lock on the map.
d328 2
a329 2
			 *	Reaquire the object lock to preserve our
			 *	invariant.
d334 2
a335 2
			 *	Found the page.
			 *	Leave it busy while we play with it.
d339 3
a341 3
				 *	Relookup in case pager changed page.
				 *	Pager is responsible for disposition
				 *	of old page if moved.
d359 1
a359 1
				return(KERN_PROTECTION_FAILURE); /* XXX */
d388 2
a389 2
		 *	Move on to the next object.  Lock the next
		 *	object before unlocking the current one.
d396 2
a397 2
			 *	If there's no object left, fill the page
			 *	in the top object with zeros.
d429 2
a430 3
	 *	PAGE HAS BEEN FOUND.
	 *	[Loop invariant still holds -- the object lock
	 *	is held.]
a431 1

d435 3
a437 4
	 *	If the page is being written, but isn't
	 *	already owned by the top-level object,
	 *	we have to copy it into a new page owned
	 *	by the top-level object.
a438 1

d441 1
a441 2
		 *	We only really need to copy if we
		 *	want to write it.
a442 1

d446 6
a451 6
			 *	If we try to collapse first_object at this
			 *	point, we may deadlock when we try to get
			 *	the lock on an intermediate object (since we
			 *	have the bottom object locked).  We can't
			 *	unlock the bottom object, because the page
			 *	we found may move (by collapse) if we do.
d453 3
a455 3
			 *	Instead, we first copy the page.  Then, when
			 *	we have no more use for the bottom object,
			 *	we unlock it and try to collapse.
d457 2
a458 2
			 *	Note that we copy the page even if we didn't
			 *	need to... that's the breaks.
d462 2
a463 2
			 *	We already have an empty page in
			 *	first_object - use it.
a464 1

d469 6
a474 6
			 *	If another map is truly sharing this
			 *	page with us, we have to flush all
			 *	uses of the original page, since we
			 *	can't distinguish those which want the
			 *	original from those which need the
			 *	new copy.
d476 3
a478 3
			 *	XXX If we know that only one map has
			 *	access to this page, then we could
			 *	avoid the pmap_page_protect() call.
a479 1

d486 1
a486 1
			 *	We no longer need the old page or object.
d493 1
a493 1
			 *	Only use the new page below...
a494 1

d501 2
a502 2
			 *	Now that we've gotten the copy out of the
			 *	way, let's try to collapse the top object.
d506 2
a507 2
			 *	But we have to play ugly games with
			 *	paging_in_progress to do that...
d519 2
a520 1
		panic("vm_fault: active or inactive before copy object handling");
d523 2
a524 2
	 *	If the page is being written, but hasn't been
	 *	copied to the copy-object, we have to copy it there.
d533 1
a533 1
		 *	We only need to copy if we want to write it.
d541 1
a541 1
			 *	Try to get the lock on the copy_object.
d551 3
a553 3
			 *	Make another reference to the copy-object,
			 *	to keep it from disappearing during the
			 *	copy.
d558 1
a558 1
			 *	Does the page exist in the copy?
d560 2
a561 2
			copy_offset = first_offset
				- copy_object->shadow_offset;
d569 2
a570 2
					 *	If the page is being brought
					 *	in, wait for it and then retry.
d572 2
a573 1
					PAGE_ASSERT_WAIT(copy_m, !change_wiring);
d579 2
a580 1
					wait_result = current_thread()->wait_result;
d583 1
a583 1
						return(KERN_SUCCESS);
d587 2
a588 2
					 *	If the page is being brought
					 *	in, wait for it and then retry.
d590 2
a591 1
					PAGE_ASSERT_WAIT(copy_m, !change_wiring);
d604 4
a607 4
			 *	If the page is not in memory (in the object)
			 *	and the object has a pager, we have to check
			 *	if the pager has the data in secondary
			 *	storage.
d612 8
a619 8
				 *	If we don't allocate a (blank) page
				 *	here... another thread could try
				 *	to page it in, allocate a page, and
				 *	then block on the busy page in its
				 *	shadow (first_object).  Then we'd
				 *	trip over the busy page after we
				 *	found that the copy_object's pager
				 *	doesn't have the page...
d621 2
a622 2
				copy_m = vm_page_alloc(copy_object,
								copy_offset);
d625 1
a625 1
					 *	Wait for a page, then retry.
d641 3
a643 2
							copy_object->pager,
							(copy_offset + copy_object->paging_offset));
d660 1
a660 1
						 *	Gaah... start over!
d664 3
a666 2
						vm_object_deallocate(copy_object);
							/* may block */
d674 1
a674 1
						 *	We didn't need the page
d682 1
a682 1
				 *	Must copy page into copy-object.
d699 1
a699 1
						  VM_PROT_NONE);
d707 5
a711 5
			 *	The reference count on copy_object must be
			 *	at least 2: one for our extra reference,
			 *	and at least one from the outside world
			 *	(we checked that when we last locked
			 *	copy_object).
d723 2
a724 2
	 *	We must verify that the maps have not changed
	 *	since our last lookup.
a725 1

d732 2
a733 2
		 *	Since map entries may be pageable, make sure we can
		 *	take a page fault on them.
d738 7
a744 7
		 *	To avoid trying to write_lock the map while another
		 *	thread has it read_locked (in vm_map_pageable), we
		 *	do not try for write permission.  If the page is
		 *	still writable, we will get write permission.  If it
		 *	is not, or has been marked needs_copy, we enter the
		 *	mapping without write permission, and will merely
		 *	take another fault.
d747 2
a748 3
				fault_type & ~VM_PROT_WRITE, &entry,
				&retry_object, &retry_offset, &retry_prot,
				&wired, &su);
d753 3
a755 3
		 *	If we don't need the page any longer, put it on the
		 *	active list (the easiest thing to do here).  If no
		 *	one needs it, pageout will grab it eventually.
d761 1
a761 1
			return(result);
d767 1
a767 1
				(retry_offset != first_offset)) {
d774 6
a779 6
		 *	Check whether the protection has changed or the object
		 *	has been copied while we left the map unlocked.
		 *	Changing from read to write permission is OK - we leave
		 *	the page write-protected, and catch the write fault.
		 *	Changing from write to read permission means that we
		 *	can't mark the page write-enabled after all.
d797 2
a798 2
	 *	It's critically important that a wired-down page be faulted
	 *	only once in each map for which it is wired.
d807 5
a811 5
	 *	Put this page into the physical map.
	 *	We had to do the unlock above because pmap_enter
	 *	may cause other faults.   We don't put the
	 *	page back on the active queue until later so
	 *	that the page-out daemon won't find us (yet).
d817 2
a818 2
	 *	If the page is not wired down, then put it where the
	 *	pageout daemon can find it.
d833 1
a833 1
	 *	Unlock everything, and return
d839 1
a839 1
	return(KERN_SUCCESS);
d843 1
a843 1
 *	vm_fault_wire:
d845 1
a845 1
 *	Wire down a range of virtual addresses in a map.
d859 3
a861 3
	 *	Inform the physical mapping system that the
	 *	range of addresses may not fault, so that
	 *	page tables and such can be locked down as well.
d867 2
a868 2
	 *	We simulate a fault to get the page and enter it
	 *	in the physical map.
d876 1
a876 1
			return(rv);
d879 1
a879 1
	return(KERN_SUCCESS);
d884 1
a884 1
 *	vm_fault_unwire:
d886 1
a886 1
 *	Unwire a range of virtual addresses in a map.
d900 2
a901 2
	 *	Since the pages are wired down, we must be able to
	 *	get their mappings from the physical map system.
a902 1

d907 1
a907 1
		if (pa == (vm_offset_t) 0) {
d916 3
a918 3
	 *	Inform the physical mapping system that the range
	 *	of addresses may fault, so that page tables and
	 *	such may be unwired themselves.
d926 4
a929 4
 *	Routine:
 *		vm_fault_copy_entry
 *	Function:
 *		Copy all of the pages from a wired-down map entry to another.
d931 4
a934 4
 *	In/out conditions:
 *		The source and destination maps must be locked for write.
 *		The source map entry must be wired down (or be a sharing map
 *		entry corresponding to a main map entry that is wired down).
d961 3
a963 3
	 *	Create the top-level object for the destination entry.
	 *	(Doesn't actually shadow anything - we copy the pages
	 *	directly.)
d965 2
a966 2
	dst_object = vm_object_allocate(
			(vm_size_t) (dst_entry->end - dst_entry->start));
d971 1
a971 1
	prot  = dst_entry->max_protection;
d974 3
a976 3
	 *	Loop through all of the pages in the entry's range, copying
	 *	each one from the source object (it should be there) to the
	 *	destination object.
d979 2
a980 2
	     vaddr < dst_entry->end;
	     vaddr += PAGE_SIZE, dst_offset += PAGE_SIZE) {
d983 1
a983 1
		 *	Allocate a page in the destination object
d996 3
a998 3
		 *	Find the page in the source object, and copy it in.
		 *	(Because the source is wired down, the page will be
		 *	in memory.)
d1008 1
a1008 1
		 *	Enter it in the pmap...
d1013 2
a1014 2
		pmap_enter(dst_map->pmap, vaddr, VM_PAGE_TO_PHYS(dst_m),
				prot, FALSE);
d1017 1
a1017 1
		 *	Mark it no longer busy, and put it on the active list.
@


1.7
log
@tabify
some /lx/p/ printf changes
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_fault.c,v 1.6 1997/04/17 01:25:17 niklas Exp $	*/
/*	$NetBSD: vm_fault.c,v 1.18 1996/05/20 17:40:02 mrg Exp $	*/
d330 2
a331 1
			curproc->p_addr->u_stats.p_ru.ru_majflt++;
@


1.6
log
@Removal of race conditions.  Inspired by Charles Hannum's
<mycroft@@netbsd.org> reorganization of the vm_collapse logic, although not
used verbatim.  We no longer collapse objects from the pagedaemon as that
is not necessary anymore with the more aggressive collapses that gets done.
This also increases performance of loaded systems.  Much KNF too.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.5 1996/11/23 21:47:14 kstailey Exp $	*/
d183 1
a183 1
   	/*
@


1.5
log
@curproc is never NULL when this code is executed
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.4 1996/08/02 00:05:59 niklas Exp $	*/
d148 1
a148 1
	object->paging_in_progress--;			\
d153 1
a153 1
		first_object->paging_in_progress--;	\
d194 1
a194 5
#ifdef DIAGNOSTIC
	if (first_object->paging_in_progress == 0xdead)
		panic("vm_fault: first_object deallocated");
#endif
	first_object->paging_in_progress++;
d406 1
a406 1
				object->paging_in_progress--;
d424 1
a424 1
				object->paging_in_progress--;
d427 1
a427 5
#ifdef DIAGNOSTIC
			if (object->paging_in_progress == 0xdead)
				panic("vm_fault: object deallocated (1)");
#endif
			object->paging_in_progress++;
d503 1
a503 1
			object->paging_in_progress--;
d524 1
a524 1
			object->paging_in_progress--;
d526 2
a527 7
#ifdef DIAGNOSTIC
			if (object->paging_in_progress == 0xdead)
				panic("vm_fault: object deallocated (2)");
#endif
			object->paging_in_progress++;
		}
		else {
@


1.4
log
@Fix long-standing swap-leak. Add OpenBSD tags. Optimize thread_wakeup.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_fault.c,v 1.3 1996/05/23 08:34:51 deraadt Exp $	*/
d334 1
a334 2
			if (curproc)
				curproc->p_addr->u_stats.p_ru.ru_majflt++;
@


1.3
log
@count pagein faults; netbsd pr#1397
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d194 4
d432 4
d535 4
@


1.2
log
@From NetBSD: merge with 960217
@
text
@d2 1
a2 1
/*	$NetBSD: vm_fault.c,v 1.17 1996/02/05 01:53:55 christos Exp $	*/
d73 1
d75 1
d330 2
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: vm_fault.c,v 1.16 1994/09/07 20:25:07 mycroft Exp $	*/
d575 1
a575 1
			if (page_exists = (copy_m != NULL)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

