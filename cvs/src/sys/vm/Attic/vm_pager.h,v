head	1.9;
access;
symbols
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	UBC_SYNC_A:1.9
	UBC_SYNC_B:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.10
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2001.08.12.21.36.48;	author mickey;	state dead;
branches;
next	1.8;

1.8
date	2001.06.27.04.52.40;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.08.18.14.05.39;	author art;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	98.03.01.00.38.24;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.59.38;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.20.21.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.06.15.28.57;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	96.08.02.00.06.05;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.38;	author deraadt;	state Exp;
branches;
next	;

1.7.4.1
date	2001.07.04.11.01.27;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2001.10.31.03.32.14;	author nate;	state dead;
branches;
next	;


desc
@@


1.9
log
@vm_pager.h no more
@
text
@/*	$OpenBSD: vm_pager.h,v 1.8 2001/06/27 04:52:40 art Exp $	*/
/*	$NetBSD: vm_pager.h,v 1.10 1995/03/26 20:39:15 jtc Exp $	*/

/*
 * Copyright (c) 1990 University of Utah.
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_pager.h	8.5 (Berkeley) 7/7/94
 */

/*
 * Pager routine interface definition.
 * For BSD we use a cleaner version of the internal pager interface.
 */

#ifndef	_VM_PAGER_
#define	_VM_PAGER_

/*
 * get/put return values
 * OK	   operation was successful
 * BAD	   specified data was out of the accepted range
 * FAIL	   specified data was in range, but doesn't exist
 * PEND	   operations was initiated but not completed
 * ERROR   error while accessing data that is in range and exists
 * AGAIN   temporary resource shortage prevented operation from happening
 * UNLOCK  unlock the map and try again
 * REFAULT [uvm_fault internal use only!] unable to relock data structures,
 *         thus the mapping needs to be reverified before we can procede
 */
#define	VM_PAGER_OK		0
#define	VM_PAGER_BAD		1
#define	VM_PAGER_FAIL		2
#define	VM_PAGER_PEND		3
#define	VM_PAGER_ERROR		4
#define VM_PAGER_AGAIN		5
#define VM_PAGER_UNLOCK		6
#define VM_PAGER_REFAULT	7

#endif	/* _VM_PAGER_ */
@


1.8
log
@Remove junk from headers, just leave enough for UVM.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_pager.h,v 1.7 1999/08/18 14:05:39 art Exp $	*/
@


1.7
log
@some ifndef UVM
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_pager.h,v 1.6 1998/03/01 00:38:24 niklas Exp $	*/
a51 56
#if !defined(UVM)
TAILQ_HEAD(pagerlst, pager_struct);

struct	pager_struct {
	TAILQ_ENTRY(pager_struct) pg_list;	/* links for list management */
	caddr_t			  pg_handle;	/* ext. handle (vp, dev, fp) */
	int			  pg_type;	/* type of pager */
	int			  pg_flags;	/* flags */
	struct pagerops		  *pg_ops;	/* pager operations */
	void			  *pg_data;	/* private pager data */
};

/* pager types */
#define PG_DFLT		-1
#define	PG_SWAP		0
#define	PG_VNODE	1
#define PG_DEVICE	2

/* flags */
#define PG_CLUSTERGET	1
#define PG_CLUSTERPUT	2

struct	pagerops {
	void		(*pgo_init)		/* Initialize pager. */
			    __P((void));
	vm_pager_t	(*pgo_alloc)		/* Allocate pager. */
			    __P((caddr_t, vm_size_t, vm_prot_t, vm_offset_t));
	void		(*pgo_dealloc)		/* Disassociate. */
			    __P((vm_pager_t));
	int		(*pgo_getpages)		/* Get (read) pages. */
			    __P((vm_pager_t, vm_page_t *, int, boolean_t));
	int		(*pgo_putpages)		/* Put (write) pages. */
			    __P((vm_pager_t, vm_page_t *, int, boolean_t));
	boolean_t  	(*pgo_haspage)		/* Does pager have page? */
			    __P((vm_pager_t, vm_offset_t));
	void		(*pgo_cluster)		/* Return range of cluster. */
			    __P((vm_pager_t, vm_offset_t,
				 vm_offset_t *, vm_offset_t *));
	/*
	 *	The following are an extension to the original Mach pager
	 *	interface first seen in BSD/OS 2.1 (at least as far as I am
	 *	aware).  As compatibility is a good thing (tm) I choose to
	 *	use that interface extension instead of coming up with one
	 *	of my own (the interface must be extended to make the
	 *	object collapse operation work in the presense of pagers).
	 *	-- Niklas Hallqvist (niklas@@appli.se).
	 */
	int		(*pgo_remove)		/* Don't manage range anymore */
			    __P((vm_pager_t, vm_offset_t, vm_offset_t));
	vm_offset_t	(*pgo_next)		/* Find next page in pager. */
			    __P((vm_pager_t, vm_offset_t));
	int		(*pgo_count)		/* How many pages in pager? */
			    __P((vm_pager_t));
};
#endif /* !UVM */

a71 37

#if defined(_KERNEL) && !defined(UVM)
extern struct pagerops *dfltpagerops;

vm_pager_t	vm_pager_allocate
		    __P((int, caddr_t, vm_size_t, vm_prot_t, vm_offset_t));
vm_page_t	vm_pager_atop __P((vm_offset_t));
void		vm_pager_cluster
		    __P((vm_pager_t, vm_offset_t,
			 vm_offset_t *, vm_offset_t *));
void		vm_pager_clusternull
		    __P((vm_pager_t, vm_offset_t,
			 vm_offset_t *, vm_offset_t *));
void		vm_pager_deallocate __P((vm_pager_t));
int		vm_pager_remove
		    __P((vm_pager_t, vm_offset_t, vm_offset_t));
int		vm_pager_count __P((vm_pager_t));
vm_offset_t	vm_pager_next __P((vm_pager_t, vm_offset_t));
int		vm_pager_get_pages
		    __P((vm_pager_t, vm_page_t *, int, boolean_t));
boolean_t	vm_pager_has_page __P((vm_pager_t, vm_offset_t));
void		vm_pager_init __P((void));
vm_pager_t	vm_pager_lookup __P((struct pagerlst *, caddr_t));
vm_offset_t	vm_pager_map_pages __P((vm_page_t *, int, boolean_t));
int		vm_pager_put_pages
		    __P((vm_pager_t, vm_page_t *, int, boolean_t));
void		vm_pager_sync __P((void));
void		vm_pager_unmap_pages __P((vm_offset_t, int));

#define vm_pager_cancluster(p, b)	((p)->pg_flags & (b))

/*
 * XXX compat with old interface
 */
int		vm_pager_get __P((vm_pager_t, vm_page_t, boolean_t));
int		vm_pager_put __P((vm_pager_t, vm_page_t, boolean_t));
#endif /* _KERNEL && !UVM */
@


1.7.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_pager.h,v 1.7 1999/08/18 14:05:39 art Exp $	*/
d52 56
d128 37
@


1.7.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_pager.h,v 1.7.4.1 2001/07/04 11:01:27 niklas Exp $	*/
@


1.6
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_pager.h,v 1.5 1997/11/06 05:59:38 csapuntz Exp $	*/
d52 1
d106 1
d129 1
a129 1
#ifdef _KERNEL
d164 1
a164 1
#endif
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_pager.h,v 1.4 1997/10/06 20:21:28 deraadt Exp $	*/
d108 9
a116 6
 * OK	 operation was successful
 * BAD	 specified data was out of the accepted range
 * FAIL	 specified data was in range, but doesn't exist
 * PEND	 operations was initiated but not completed
 * ERROR error while accessing data that is in range and exists
 * AGAIN temporary resource shortage prevented operation from happening
d118 8
a125 6
#define	VM_PAGER_OK	0
#define	VM_PAGER_BAD	1
#define	VM_PAGER_FAIL	2
#define	VM_PAGER_PEND	3
#define	VM_PAGER_ERROR	4
#define VM_PAGER_AGAIN	5
@


1.4
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_pager.h,v 1.2 1996/08/02 00:06:05 niklas Exp $	*/
d41 1
a41 1
 *	@@(#)vm_pager.h	8.4 (Berkeley) 1/12/94
@


1.3
log
@VFS Lite2 Changes
@
text
@d41 1
a41 1
 *	@@(#)vm_pager.h	8.5 (Berkeley) 7/7/94
@


1.2
log
@Fix long-standing swap-leak. Add OpenBSD tags. Optimize thread_wakeup.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_pager.h,v 1.10 1995/03/26 20:39:15 jtc Exp $	*/
d41 1
a41 1
 *	@@(#)vm_pager.h	8.4 (Berkeley) 1/12/94
@


1.1
log
@Initial revision
@
text
@d1 1
d80 1
a80 1
	int		(*pgo_getpages)		/* Get (read) page. */
d82 1
a82 1
	int		(*pgo_putpages)		/* Put (write) page. */
d89 15
d125 1
a125 1
vm_pager_t	 vm_pager_allocate
d127 2
a128 2
vm_page_t	 vm_pager_atop __P((vm_offset_t));
void		 vm_pager_cluster
d131 1
a131 1
void		 vm_pager_clusternull
d134 6
a139 2
void		 vm_pager_deallocate __P((vm_pager_t));
int		 vm_pager_get_pages
d141 5
a145 5
boolean_t	 vm_pager_has_page __P((vm_pager_t, vm_offset_t));
void		 vm_pager_init __P((void));
vm_pager_t	 vm_pager_lookup __P((struct pagerlst *, caddr_t));
vm_offset_t	 vm_pager_map_pages __P((vm_page_t *, int, boolean_t));
int		 vm_pager_put_pages
d147 2
a148 2
void		 vm_pager_sync __P((void));
void		 vm_pager_unmap_pages __P((vm_offset_t, int));
d155 2
a156 2
int		 vm_pager_get __P((vm_pager_t, vm_page_t, boolean_t));
int		 vm_pager_put __P((vm_pager_t, vm_page_t, boolean_t));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

