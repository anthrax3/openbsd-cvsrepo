head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.8
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.12.50;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.03.14.45.54;	author jj;	state Exp;
branches;
next	;


desc
@@


1.4
log
@kill nnpfs dead
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* $arla: nnpfs_vnodeops.h,v 1.25 2002/09/07 10:46:12 lha Exp $ */

#ifndef _nnpfs_vnodeops_h
#define _nnpfs_vnodeops_h

/*
 * nnpfs_vfs_readlock
 * nnpfs_vfs_writelock
 * nnpfs_vfs_unlock
 */

#ifdef __osf__			/* XXX - what about VN_LOCK? */

#define nnpfs_vfs_readlock(vp, proc) vref((vp))
#define nnpfs_vfs_writelock(vp, proc) vref((vp))
#define nnpfs_vfs_unlock(vp, proc) vrele((vp))

/* XXX - should this do anything? */

#define nnpfs_vfs_vn_lock(vp, flags, proc) (0)

#elif defined(HAVE_TWO_ARGUMENT_VOP_LOCK)

#define nnpfs_vfs_readlock(vp, proc) vn_lock((vp), LK_SHARED | LK_RETRY)
#define nnpfs_vfs_writelock(vp, proc) vn_lock((vp), LK_EXCLUSIVE | LK_RETRY)
#define nnpfs_vfs_unlock(vp, proc) VOP_UNLOCK((vp), (proc))
#define nnpfs_vfs_vn_lock(vp, flags, proc) vn_lock((vp), (flags))

#elif defined(HAVE_THREE_ARGUMENT_VOP_LOCK)

#define nnpfs_vfs_readlock(vp, proc) vn_lock((vp), LK_SHARED | LK_RETRY, (proc))
#define nnpfs_vfs_writelock(vp, proc) vn_lock((vp), LK_EXCLUSIVE | LK_RETRY, (proc))
#define nnpfs_vfs_unlock(vp, proc) VOP_UNLOCK((vp), 0, (proc))
#define nnpfs_vfs_vn_lock(vp, flags, proc) vn_lock((vp), (flags), (proc))

#elif defined(HAVE_ONE_ARGUMENT_VOP_LOCK)

#define nnpfs_vfs_readlock(vp, proc) VOP_LOCK((vp))
#define nnpfs_vfs_writelock(vp, proc) VOP_LOCK((vp))
#define nnpfs_vfs_unlock(vp, proc) VOP_UNLOCK((vp))

/* XXX - should this do anything? */

#define nnpfs_vfs_vn_lock(vp, flags, proc) (0)

#else

#error what kind of VOP_LOCK?

#endif

int
nnpfs_open_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
	       u_int tok);

int
nnpfs_attr_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
	       u_int tok);

int
nnpfs_fetch_rights(struct vnode *vp, struct ucred *cred, d_thread_t *p);

int
nnpfs_data_valid(struct vnode *vp, struct ucred *cred, d_thread_t *p,
	       u_int tok, uint32_t offset);

int
nnpfs_open_common(struct vnode *vp,
		int mode,
		struct ucred *cred,
		d_thread_t *p);

int
nnpfs_fsync_common(struct vnode *vp, struct ucred *cred,
		 int waitfor, d_thread_t *proc);

int
nnpfs_close_common(struct vnode *vp, int fflag,
		 d_thread_t *proc, struct ucred *cred);

int
nnpfs_read_common(struct vnode *vp, struct uio *uio, int ioflag,
		struct ucred *cred);

int
nnpfs_write_common(struct vnode *vp, struct uio *uiop, int ioflag,
		 struct ucred *cred);

int
nnpfs_getattr_common(struct vnode *vp, struct vattr *vap,
		   struct ucred *cred, d_thread_t *p);

int
nnpfs_setattr_common(struct vnode *vp, struct vattr *vap,
		   struct ucred *cred, d_thread_t *p);

int
nnpfs_access_common(struct vnode *vp, int mode,
		  struct ucred *cred, d_thread_t *p);

int
nnpfs_lookup_common(struct vnode *dvp, 
		  nnpfs_componentname *cnp, 
		  struct vnode **vpp);

int
nnpfs_create_common(struct vnode *dvp,
		  const char *name,
		  struct vattr *vap, 
		  struct ucred *cred,
		  d_thread_t *p);

int
nnpfs_remove_common(struct vnode *dvp, 
		  struct vnode *vp, 
		  const char *name,
		  struct ucred *cred,
		  d_thread_t *p);

int
nnpfs_rename_common(struct vnode *fdvp, 
		  struct vnode *fvp,
		  const char *fname,
		  struct vnode *tdvp,
		  struct vnode *tvp,
		  const char *tname,
		  struct ucred *cred,
		  d_thread_t *p);

int
nnpfs_mkdir_common(struct vnode *dvp, 
		 const char *name,
		 struct vattr *vap, 
		 struct ucred *cred,
		 d_thread_t *p);

int
nnpfs_rmdir_common(struct vnode *dvp,
		 struct vnode *vp,
		 const char *name,
		 struct ucred *cred,
		 d_thread_t *p);

int
nnpfs_readdir_common(struct vnode *vp, 
		   struct uio *uiop, 
		   struct ucred *cred,
		   d_thread_t *p,
		   int *eofflag);

int
nnpfs_link_common(struct vnode *dvp, 
		struct vnode *vp, 
		const char *name,
		struct ucred *cred,
		d_thread_t *p);

int
nnpfs_symlink_common(struct vnode *dvp,
		   struct vnode **vpp,
		   nnpfs_componentname *cnp,
		   struct vattr *vap,
		   char *target);

int
nnpfs_readlink_common(struct vnode *vp, struct uio *uiop, struct ucred *cred);

int
nnpfs_inactive_common(struct vnode *vp, d_thread_t *p);

int
nnpfs_reclaim_common(struct vnode *vp);

int
nnpfs_eopnotsupp (struct vop_generic_args *ap);

int
nnpfs_returnzero (struct vop_generic_args *ap);

void
nnpfs_printnode_common (struct vnode *vp);

size_t
nnpfs_uio_end_length (struct uio *uio);


#endif /* _nnpfs_vnodeops_h */
@


1.3
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@@


1.2
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d59 1
a59 1
#define nnpfs_vfs_unlock(vp, proc) VOP_UNLOCK((vp), 0)
@


1.1
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@d47 2
a48 2
#define nnpfs_vfs_readlock(vp, proc) VREF((vp))
#define nnpfs_vfs_writelock(vp, proc) VREF((vp))
@

