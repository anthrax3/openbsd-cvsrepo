head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.2
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.39.0.6
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2017.05.29.14.36.22;	author mpi;	state Exp;
branches;
next	1.39;
commitid	Bm2EDWmoITKmkDvl;

1.39
date	2016.06.15.19.39.34;	author gerhard;	state Exp;
branches;
next	1.38;
commitid	qJ1QnDnimibODQ30;

1.38
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.37;
commitid	5qLGnZtXVLeqUvHc;

1.37
date	2015.12.03.21.57.59;	author mpi;	state Exp;
branches;
next	1.36;
commitid	nmbu8xP0zmz2PPN0;

1.36
date	2015.11.11.10.01.46;	author mpi;	state Exp;
branches;
next	1.35;
commitid	r0fBjQTx4oDDv9YH;

1.35
date	2015.01.12.13.51.45;	author mpi;	state Exp;
branches;
next	1.34;
commitid	v60fHRGiGOxDVlm2;

1.34
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.13.09.48.12;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2013.11.29.00.19.33;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.11.28.10.16.44;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.27.08.37.08;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.21.16.34.33;	author mikeb;	state Exp;
branches;
next	1.27;

1.27
date	2013.11.21.09.08.38;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.23.13.39.35;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.18.09.04.03;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2013.10.17.16.27.43;	author bluhm;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.14.11.07.42;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2013.08.28.21.19.16;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.31.19.16.52;	author mpi;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.11.04.45.44;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2011.10.13.18.23.40;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2010.11.17.19.25.49;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.13.07.05.28;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.13.01.26.28;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.08.12.54.58;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.20.19.00.35;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.09.09.27;	author pascoe;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.09.07.03.41;	author angelos;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	96.03.03.22.30.34;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches;
next	;

1.3.2.1
date	2001.07.04.10.54.35;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Per-interface list of addresses, both multicast and unicast, are
currently protected by the NET_LOCK().

They are not accessed in the hot path, so protecting them with a
mutex could be an option.  However since we're now going to run
with a NET_LOCK() for some time, assert that it is held.

IPsec is not yet ready to run without KERNEL_LOCK(), so assert it
is held, even in the forwarding path.

Tested by sthen@@, ok visa@@, claudio@@, bluhm@@
@
text
@/*	$OpenBSD: in_var.h,v 1.39 2016/06/15 19:39:34 gerhard Exp $	*/
/*	$NetBSD: in_var.h,v 1.16 1996/02/13 23:42:15 christos Exp $	*/

/*
 * Copyright (c) 1985, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in_var.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET_IN_VAR_H_
#define _NETINET_IN_VAR_H_

#include <sys/queue.h>

#ifdef _KERNEL
/*
 * Interface address, Internet version.  One of these structures
 * is allocated for each interface with an Internet address.
 * The ifaddr structure contains the protocol-independent part
 * of the structure and is assumed to be first.
 */
struct in_ifaddr {
	struct	ifaddr ia_ifa;		/* protocol-independent info */
#define	ia_ifp		ia_ifa.ifa_ifp
#define	ia_flags	ia_ifa.ifa_flags
					/* ia_net{,mask} in host order */
	u_int32_t ia_net;		/* network number of interface */
	u_int32_t ia_netmask;		/* mask of net part */
	TAILQ_ENTRY(in_ifaddr) ia_list;	/* list of internet addresses */
	struct	sockaddr_in ia_addr;	/* reserve space for interface name */
	struct	sockaddr_in ia_dstaddr;	/* reserve space for broadcast addr */
#define	ia_broadaddr	ia_dstaddr
	struct	sockaddr_in ia_sockmask; /* reserve space for general netmask */
	struct  in_multi *ia_allhosts;	/* multicast address record for
					   the allhosts multicast group */
};
#endif

struct	in_aliasreq {
	char	ifra_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	union {
		struct	sockaddr_in ifrau_addr;
		int	ifrau_align;
	} ifra_ifrau;
#ifndef ifra_addr
#define ifra_addr	ifra_ifrau.ifrau_addr
#endif
	struct	sockaddr_in ifra_dstaddr;
#define	ifra_broadaddr	ifra_dstaddr
	struct	sockaddr_in ifra_mask;
};


#ifdef	_KERNEL
/*
 * Macro for finding the internet address structure (in_ifaddr) corresponding
 * to a given interface (ifnet structure).
 */
#define IFP_TO_IA(ifp, ia)						\
	/* struct ifnet *ifp; */					\
	/* struct in_ifaddr *ia; */					\
do {									\
	struct ifaddr *ifa;						\
	NET_ASSERT_LOCKED();						\
	TAILQ_FOREACH(ifa, &(ifp)->if_addrlist, ifa_list) {		\
		if (ifa->ifa_addr->sa_family == AF_INET)		\
			break;						\
	}								\
	(ia) = ifatoia(ifa);						\
} while (/* CONSTCOND */ 0)
#endif

/*
 * Per-interface router version information.
 */
struct router_info {
	unsigned int	rti_ifidx;
	int		rti_type;	/* type of router on this interface */
	int		rti_age;	/* time since last v1 query */
	struct	router_info *rti_next;
};

#ifdef _KERNEL
/*
 * Internet multicast address structure.  There is one of these for each IP
 * multicast group to which this host belongs on a given network interface.
 */
struct in_multi {
	struct ifmaddr		inm_ifma;   /* Protocol-independent info */
#define inm_refcnt		inm_ifma.ifma_refcnt
#define inm_ifidx		inm_ifma.ifma_ifidx

	struct sockaddr_in	inm_sin;   /* IPv4 multicast address */
#define inm_addr		inm_sin.sin_addr

	u_int			inm_state; /* state of membership */
	u_int			inm_timer; /* IGMP membership report timer */

	struct router_info	*inm_rti;  /* router version info */
};

static __inline struct in_multi *
ifmatoinm(struct ifmaddr *ifma)
{
       return ((struct in_multi *)(ifma));
}

/*
 * Macro for looking up the in_multi record for a given IP multicast
 * address on a given interface.  If no matching record is found, "inm"
 * returns NULL.
 */
#define IN_LOOKUP_MULTI(addr, ifp, inm)					\
	/* struct in_addr addr; */					\
	/* struct ifnet *ifp; */					\
	/* struct in_multi *inm; */					\
do {									\
	struct ifmaddr *ifma;						\
									\
	(inm) = NULL;							\
	NET_ASSERT_LOCKED();						\
	TAILQ_FOREACH(ifma, &(ifp)->if_maddrlist, ifma_list)		\
		if (ifma->ifma_addr->sa_family == AF_INET &&		\
		    ifmatoinm(ifma)->inm_addr.s_addr == (addr).s_addr) {\
			(inm) = ifmatoinm(ifma);			\
			break;						\
		}							\
} while (/* CONSTCOND */ 0)

int	in_ifinit(struct ifnet *,
	    struct in_ifaddr *, struct sockaddr_in *, int);
struct	in_multi *in_addmulti(struct in_addr *, struct ifnet *);
void	in_delmulti(struct in_multi *);
int	in_hasmulti(struct in_addr *, struct ifnet *);
void	in_ifscrub(struct ifnet *, struct in_ifaddr *);
int	in_control(struct socket *, u_long, caddr_t, struct ifnet *);
int	in_ioctl(u_long, caddr_t, struct ifnet *, int);
void	in_prefixlen2mask(struct in_addr *, int);
#endif

#endif /* _NETINET_IN_VAR_H_ */
@


1.39
log
@Add umb(4) - a driver for the Mobile Broadband Interface Model (MBIM)

The umb(4) driver provides support for USB MBIM devices.
Those devices establish connections via celluar networks such as
GPRS, UMTS, and LTE.

ok mpi@@ sthen@@
additional feedback from deraadt@@ jmc@@ stsp@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.38 2016/01/21 11:23:48 mpi Exp $	*/
d89 1
d146 1
@


1.38
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.37 2015/12/03 21:57:59 mpi Exp $	*/
d160 1
@


1.37
log
@Get rid of rt_mask() and stop allocating a "struct sockaddr" for every
route entry in ART.

rt_plen() now represents the prefix length of a route entry and should
be used instead.

For now use a "struct sockaddr_in6" to represent the mask when needed,
this should be then replaced by the prefix length and RTA_NETMASK only
used for compatibility with userland.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.36 2015/11/11 10:01:46 mpi Exp $	*/
d157 1
@


1.36
log
@Store an interface index instead of a pointer that's never dereferenced.

Get rid of an if_ref()/if_put() dance.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.35 2015/01/12 13:51:45 mpi Exp $	*/
d159 1
@


1.35
log
@Kill the global list of IPv4 addresses.

ok claudio@@, mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.34 2014/03/27 10:39:23 mpi Exp $	*/
d101 3
a103 3
	struct	ifnet *rti_ifp;
	int	rti_type;	/* type of router on this interface */
	int	rti_age;	/* time since last v1 query */
@


1.34
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.33 2014/01/21 10:18:26 mpi Exp $	*/
a79 3
TAILQ_HEAD(in_ifaddrhead, in_ifaddr);
extern	struct	in_ifaddrhead in_ifaddr;

@


1.33
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.32 2014/01/13 09:48:12 mpi Exp $	*/
d50 1
a50 1
#define ia_flags	ia_ifa.ifa_flags
@


1.32
log
@Iterate over the per interface address list instead of the global one
in IFP_TO_IA().

ok bluhm@@, henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.31 2013/11/29 00:19:33 deraadt Exp $	*/
d118 1
a118 1
#define inm_ifp			inm_ifma.ifma_ifp
@


1.31
log
@move in_multi definition into kernel-only
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.30 2013/11/28 10:16:44 mpi Exp $	*/
d91 3
a93 2
	TAILQ_FOREACH((ia), &in_ifaddr, ia_list)			\
		if ((ia)->ia_ifp == (ifp))				\
d95 2
@


1.30
log
@Change the way protocol multicast addresses are linked to an interface.

Instead of linking multicast records to the first configured address of
the corresponding protocol, making this address and its position in the
global list special, add them to a new list directly linked to the
interface descriptor.

This new multicast address list is similar to the address list, all its
elements contain a protocol agnostic part.  This design allows us to
be able to join a multicast group without necessarily having a configured
address.  That means IPv6 multicast kludges are no longer needed.

Another benefit is to be able to add and remove an IP address from an
interface without worrying about multicast records.  That means that the
global IPv4 list is no longer needed since the first configured address
of an interface is no longer special.

This new list might also be extended in the future to contain the
link-layer addresses used to configure hardware filters.

Tested by sthen@@ and weerd@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.29 2013/11/27 08:37:08 mpi Exp $	*/
d107 1
a124 3


#ifdef _KERNEL
@


1.29
log
@Replace INADDR_TO_IFP() by in_iawithaddr() and kill the macro.

ok mikeb@@, ports@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.28 2013/11/21 16:34:33 mikeb Exp $	*/
a58 1
	LIST_HEAD(, in_multi) ia_multiaddrs; /* list of multicast addresses */
a109 2
 * They are kept in a linked list, rooted in the interface's in_ifaddr
 * structure.
d112 11
a122 8
	struct	in_addr inm_addr;	/* IP multicast address */
	struct	in_ifaddr *inm_ia;	/* back pointer to in_ifaddr */
#define inm_ifp	inm_ia->ia_ifp
	u_int	inm_refcount;		/* no. membership claims by sockets */
	u_int	inm_timer;		/* IGMP membership report timer */
	LIST_ENTRY(in_multi) inm_list;	/* list of multicast addresses */
	u_int	inm_state;		/* state of membership */
	struct	router_info *inm_rti;	/* router version info */
d125 1
d127 6
a132 11
/*
 * Macro for iterating over all the in_multi records linked to a given
 * interface.
 */
#define IN_FOREACH_MULTI(ia, ifp, inm)					\
	/* struct in_ifaddr *ia; */					\
	/* struct ifnet *ifp; */					\
	/* struct in_multi *inm; */					\
	IFP_TO_IA((ifp), ia);						\
	if (ia != NULL)							\
		LIST_FOREACH((inm), &ia->ia_multiaddrs, inm_list)	\
d144 1
a144 1
	struct in_ifaddr *ia;						\
d147 4
a150 2
	IN_FOREACH_MULTI(ia, ifp, inm)					\
		if ((inm)->inm_addr.s_addr == (addr).s_addr)		\
d152 1
@


1.28
log
@hide a bunch of structures (namely arpcom, llinfo_arp, ethernet
multicast macros and in_ifaddr) that reference ifnet in some way;
looked over by deraadt, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.27 2013/11/21 09:08:38 mpi Exp $	*/
a82 17

/*
 * Macro for finding the interface (ifnet structure) corresponding to one
 * of our IP addresses.
 */
#define INADDR_TO_IFP(addr, ifp, rtableid)				\
	/* struct in_addr addr; */					\
	/* struct ifnet *ifp; */					\
do {									\
	struct in_ifaddr *ia;						\
									\
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list)				\
		if (ia->ia_ifp->if_rdomain == rtable_l2(rtableid) &&	\
		    ia->ia_addr.sin_addr.s_addr == (addr).s_addr)	\
			 break;						\
	(ifp) = (ia == NULL) ? NULL : ia->ia_ifp;			\
} while (/* CONSTCOND */ 0)
@


1.27
log
@Replace the last usage of IA_SIN() and kill this macro.

ok henning@@, sthen@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.26 2013/10/23 15:12:42 mpi Exp $	*/
d40 1
d63 1
@


1.26
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.25 2013/10/23 13:39:35 mpi Exp $	*/
a75 5
/*
 * Given a pointer to an in_ifaddr (ifaddr),
 * return a pointer to the addr as a sockaddr_in.
 */
#define	IA_SIN(ia) (&(((struct in_ifaddr *)(ia))->ia_addr))
@


1.25
log
@No need to expose twice in_socktrim(), it is only used in one file.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.24 2013/10/18 09:04:03 mpi Exp $	*/
a85 3
extern	struct	ifqueue	ipintrq;		/* ip packet input queue */
extern	int	inetctlerrmap[];

a181 4

int	inet_nat64(int, const void *, void *, const void *, u_int8_t);
int	inet_nat46(int, const void *, void *, const void *, u_int8_t);
int	in_mask2len(struct in_addr *);
@


1.24
log
@Abstract the fact that IPv4 muticast records are linked to the
interface descriptor throught the first configured address in the
global list, this will help reducing the size of future diffs.

No object change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.23 2013/10/17 16:27:43 bluhm Exp $	*/
a87 1
void	in_socktrim(struct sockaddr_in *);
@


1.23
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.22 2013/10/14 11:07:42 mpi Exp $	*/
d141 1
@


1.22
log
@Change the macros used to iterate over the multicast records of an
interface to not depend on the global list of addresses.

For IPv4 the IP_TO_IA() macro still depends on the global list of
addresses because we want to be sure to grab the first configured
address of an interface, where the records are linked.

Tested by sthen@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.21 2013/08/28 21:19:16 bluhm Exp $	*/
a189 4


/* INET6 stuff */
#include <netinet6/in6_var.h>
@


1.21
log
@Replace hand-crafted for loop over in_ifaddr with FOREACH macro.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.20 2013/05/31 19:16:52 mpi Exp $	*/
d150 2
a151 2
 * Structure used by macros below to remember position when stepping through
 * all of the in_multi records.
d153 7
a159 4
struct in_multistep {
	struct in_ifaddr *i_ia;
	struct in_multi *i_inm;
};
d162 3
a164 2
 * Macro for looking up the in_multi record for a given IP multicast address
 * on a given interface.  If no matching record is found, "inm" returns NULL.
d173 4
a176 42
	IFP_TO_IA((ifp), ia);						\
	if (ia == NULL)							\
		(inm) = NULL;						\
	else								\
		for ((inm) = LIST_FIRST(&ia->ia_multiaddrs);		\
		     (inm) != NULL &&		\
		      (inm)->inm_addr.s_addr != (addr).s_addr;		\
		     (inm) = LIST_NEXT(inm, inm_list))			\
			 continue;					\
} while (/* CONSTCOND */ 0)

/*
 * Macro to step through all of the in_multi records, one at a time.
 * The current position is remembered in "step", which the caller must
 * provide.  IN_FIRST_MULTI(), below, must be called to initialize "step"
 * and get the first record.  Both macros return a NULL "inm" when there
 * are no remaining records.
 */
#define IN_NEXT_MULTI(step, inm)					\
	/* struct in_multistep  step; */				\
	/* struct in_multi *inm; */					\
do {									\
	if (((inm) = (step).i_inm) != NULL)				\
		(step).i_inm = LIST_NEXT((inm), inm_list);		\
	else								\
		while ((step).i_ia != NULL) {				\
			(inm) = LIST_FIRST(&(step).i_ia->ia_multiaddrs); \
			(step).i_ia = TAILQ_NEXT((step).i_ia, ia_list);	\
			if ((inm) != NULL) {				\
				(step).i_inm = LIST_NEXT((inm), inm_list); \
				break;					\
			}						\
		}							\
} while (/* CONSTCOND */ 0)

#define IN_FIRST_MULTI(step, inm)					\
	/* struct in_multistep step; */					\
	/* struct in_multi *inm; */					\
do {									\
	(step).i_ia = TAILQ_FIRST(&in_ifaddr);				\
	(step).i_inm = NULL;						\
	IN_NEXT_MULTI((step), (inm));					\
@


1.20
log
@Remove the scrub argument from in_ifinit() and simply call in_ifscrub()
unconditionally for SIOCSIFADDR.

ok bluhm@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.19 2013/03/22 01:41:12 tedu Exp $	*/
d95 1
a95 1
#define INADDR_TO_IFP(addr, ifp, rdomain)				\
d101 4
a104 5
	for (ia = TAILQ_FIRST(&in_ifaddr); ia != NULL && \
	    (ia->ia_ifp->if_rdomain != rtable_l2(rdomain) || 		\
	    ia->ia_addr.sin_addr.s_addr != (addr).s_addr);		\
	    ia = TAILQ_NEXT(ia, ia_list))				\
		 continue;						\
d116 3
a118 4
	for ((ia) = TAILQ_FIRST(&in_ifaddr);				\
	    (ia) != NULL && (ia)->ia_ifp != (ifp);	\
	    (ia) = TAILQ_NEXT((ia), ia_list))				\
		continue;						\
@


1.19
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.18 2012/11/11 04:45:44 deraadt Exp $	*/
d216 1
a216 1
	    struct in_ifaddr *, struct sockaddr_in *, int, int);
@


1.18
log
@align ifaliasreq.ifra_addr similar to the way that ifreq is fixed --
a gruesome union, to block the compiler from placing the struct
incorrectly aligned on stack frames
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.17 2011/10/13 18:23:40 claudio Exp $	*/
d101 1
a101 1
	for (ia = TAILQ_FIRST(&in_ifaddr); ia != TAILQ_END(&in_ifaddr) && \
d118 1
a118 1
	    (ia) != TAILQ_END(&in_ifaddr) && (ia)->ia_ifp != (ifp);	\
d176 1
a176 1
		     (inm) != LIST_END(&ia->ia_multiaddrs) &&		\
@


1.17
log
@Since the IPv6 madness is not enough introduce NAT64 -- which is actually
"af-to" a generic IP version translator for pf(4).
Not everything perfect yet but lets fix these things in the tree.
Insane amount of work done by sperreault@@, mikeb@@ and reyk@@.
Looked over by mcbride@@ henning@@ and myself at eurobsdcon.
OK mcbride@@ and general put it in from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.16 2010/11/17 19:25:49 henning Exp $	*/
d65 7
a71 1
	struct	sockaddr_in ifra_addr;
@


1.16
log
@an extra parameter for in_ifinit, indicating wether the ifaddr passed to it
is new or an already existing one. for existing ones, call ifa_del first
tested by many as part of a larger diff, ok claudio dlg krw sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.15 2010/01/13 07:05:28 henning Exp $	*/
d215 4
@


1.15
log
@we don't need broadcast for the classful network AND broadcast for the
subnet of the classful network. at least, not since 1992.
ok mpf dlg bob
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.14 2010/01/13 01:26:28 henning Exp $	*/
d210 1
a210 1
	    struct in_ifaddr *, struct sockaddr_in *, int);
@


1.14
log
@let's admit it's not 1992 any more. CIDR is around for a long time, even
that router vendor doesn't default to classful routing any more, and there
really is no point in having a classful netmask and a subnetmask to split
it. we still do classful guesses on the netmask if it isn't supplied by
userland, but that's about it.
i decided to keep ia_netmask and kill ia_subnetmask which makes this diff
bigish, the classful ia_netmask wasn't really used all that much. the real
changes are in in.c, the rest is mostly s/ia_subnetmask/ia_netmask.
ok claudio dlg ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.13 2009/11/03 10:59:04 claudio Exp $	*/
a52 1
	struct	in_addr ia_netbroadcast; /* to recognize net broadcasts */
@


1.13
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.12 2009/06/05 00:05:22 claudio Exp $	*/
d50 1
a50 1
					/* ia_{,sub}net{,mask} in host order */
a52 2
	u_int32_t ia_subnet;		/* subnet number, including net */
	u_int32_t ia_subnetmask;	/* mask of subnet part */
@


1.12
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.11 2008/11/08 12:54:58 dlg Exp $	*/
d99 1
a99 1
	    (ia->ia_ifp->if_rdomain != rdomain || 			\
@


1.11
log
@fix macros up so they use the do { } while (/* CONSTCOND */ 0) idiom

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.9 2006/03/05 21:48:56 miod Exp $	*/
d92 1
a92 1
#define INADDR_TO_IFP(addr, ifp)					\
d99 2
a100 1
	    ia->ia_addr.sin_addr.s_addr != (addr).s_addr;		\
@


1.10
log
@Remove inm_ifp from struct in_multi -- caching struct ifnet is dangerous
because interfaces may disappear without notice causing use after free bugs.
Instead use the inm_ia->ia_ifp as a hint, struct in_ifaddr correctly tracks
removals of interfaces and invalidates ia_ifp in such cases.
looks good henning@@ markus@@
@
text
@d92 6
a97 6
#define INADDR_TO_IFP(addr, ifp) \
	/* struct in_addr addr; */ \
	/* struct ifnet *ifp; */ \
{ \
	struct in_ifaddr *ia; \
\
d99 5
a103 5
	    ia->ia_addr.sin_addr.s_addr != (addr).s_addr; \
	    ia = TAILQ_NEXT(ia, ia_list)) \
		 continue; \
	(ifp) = (ia == NULL) ? NULL : ia->ia_ifp; \
}
d109 9
a117 9
#define IFP_TO_IA(ifp, ia) \
	/* struct ifnet *ifp; */ \
	/* struct in_ifaddr *ia; */ \
{ \
	for ((ia) = TAILQ_FIRST(&in_ifaddr); \
	    (ia) != TAILQ_END(&in_ifaddr) && (ia)->ia_ifp != (ifp); \
	    (ia) = TAILQ_NEXT((ia), ia_list)) \
		continue; \
}
d160 17
a176 17
#define IN_LOOKUP_MULTI(addr, ifp, inm) \
	/* struct in_addr addr; */ \
	/* struct ifnet *ifp; */ \
	/* struct in_multi *inm; */ \
{ \
	struct in_ifaddr *ia; \
\
	IFP_TO_IA((ifp), ia); \
	if (ia == NULL) \
		(inm) = NULL; \
	else \
		for ((inm) = LIST_FIRST(&ia->ia_multiaddrs); \
		     (inm) != LIST_END(&ia->ia_multiaddrs) && \
		      (inm)->inm_addr.s_addr != (addr).s_addr; \
		     (inm) = LIST_NEXT(inm, inm_list)) \
			 continue; \
}
d185 8
a192 8
#define IN_NEXT_MULTI(step, inm) \
	/* struct in_multistep  step; */ \
	/* struct in_multi *inm; */ \
{ \
	if (((inm) = (step).i_inm) != NULL) \
		(step).i_inm = LIST_NEXT((inm), inm_list); \
	else \
		while ((step).i_ia != NULL) { \
d194 2
a195 2
			(step).i_ia = TAILQ_NEXT((step).i_ia, ia_list); \
			if ((inm) != NULL) { \
d197 13
a209 13
				break; \
			} \
		} \
}

#define IN_FIRST_MULTI(step, inm) \
	/* struct in_multistep step; */ \
	/* struct in_multi *inm; */ \
{ \
	(step).i_ia = TAILQ_FIRST(&in_ifaddr); \
	(step).i_inm = NULL; \
	IN_NEXT_MULTI((step), (inm)); \
}
@


1.9
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.8 2005/01/15 09:09:27 pascoe Exp $	*/
a137 1
	struct	ifnet *inm_ifp;		/* back pointer to ifnet */
@


1.8
log
@From NetBSD:
- Keep track of allhost multicast address record we joined into
  each in_ifaddr and delete it when an address is purged.
- Don't simply try to delete a multicast address record listed in the
  ia_multiaddrs.  It results a dangling pointer.  Let whoever holds a
  reference to it to delete it.

mcbride@@ markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.7 2003/12/10 07:22:43 itojun Exp $	*/
d98 3
a100 3
	for (ia = in_ifaddr.tqh_first; \
	    ia != NULL && ia->ia_addr.sin_addr.s_addr != (addr).s_addr; \
	    ia = ia->ia_list.tqe_next) \
d113 3
a115 3
	for ((ia) = in_ifaddr.tqh_first; \
	    (ia) != NULL && (ia)->ia_ifp != (ifp); \
	    (ia) = (ia)->ia_list.tqe_next) \
d172 4
a175 3
		for ((inm) = ia->ia_multiaddrs.lh_first; \
		    (inm) != NULL && (inm)->inm_addr.s_addr != (addr).s_addr; \
		     (inm) = inm->inm_list.le_next) \
d191 1
a191 1
		(step).i_inm = (inm)->inm_list.le_next; \
d194 2
a195 2
			(inm) = (step).i_ia->ia_multiaddrs.lh_first; \
			(step).i_ia = (step).i_ia->ia_list.tqe_next; \
d197 1
a197 1
				(step).i_inm = (inm)->inm_list.le_next; \
d207 1
a207 1
	(step).i_ia = in_ifaddr.tqh_first; \
@


1.7
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.6 2003/06/02 23:28:14 millert Exp $	*/
d62 2
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.5 2002/03/14 01:27:11 millert Exp $	*/
d94 1
a94 1
	register struct in_ifaddr *ia; \
d164 1
a164 1
	register struct in_ifaddr *ia; \
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.4 2001/06/09 07:03:41 angelos Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@Inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.3 1999/12/08 06:50:19 itojun Exp $	*/
d87 1
a87 1
void	in_socktrim __P((struct sockaddr_in *));
d213 6
a218 6
int	in_ifinit __P((struct ifnet *,
	    struct in_ifaddr *, struct sockaddr_in *, int));
struct	in_multi *in_addmulti __P((struct in_addr *, struct ifnet *));
void	in_delmulti __P((struct in_multi *));
void	in_ifscrub __P((struct ifnet *, struct in_ifaddr *));
int	in_control __P((struct socket *, u_long, caddr_t, struct ifnet *));
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.4 2001/06/09 07:03:41 angelos Exp $	*/
d87 1
a87 1
void	in_socktrim(struct sockaddr_in *);
d213 6
a218 6
int	in_ifinit(struct ifnet *,
	    struct in_ifaddr *, struct sockaddr_in *, int);
struct	in_multi *in_addmulti(struct in_addr *, struct ifnet *);
void	in_delmulti(struct in_multi *);
void	in_ifscrub(struct ifnet *, struct in_ifaddr *);
int	in_control(struct socket *, u_long, caddr_t, struct ifnet *);
@


1.3
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.2 1996/03/03 22:30:34 niklas Exp $	*/
d39 3
d224 2
@


1.3.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.3 1999/12/08 06:50:19 itojun Exp $	*/
a38 3
#ifndef _NETINET_IN_VAR_H_
#define _NETINET_IN_VAR_H_

a220 2

#endif /* _NETINET_IN_VAR_H_ */
@


1.3.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 1
a87 1
void	in_socktrim(struct sockaddr_in *);
d213 6
a218 6
int	in_ifinit(struct ifnet *,
	    struct in_ifaddr *, struct sockaddr_in *, int);
struct	in_multi *in_addmulti(struct in_addr *, struct ifnet *);
void	in_delmulti(struct in_multi *);
void	in_ifscrub(struct ifnet *, struct in_ifaddr *);
int	in_control(struct socket *, u_long, caddr_t, struct ifnet *);
@


1.3.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_var.h,v 1.3.2.2 2002/03/28 14:56:45 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d94 1
a94 1
	struct in_ifaddr *ia; \
d164 1
a164 1
	struct in_ifaddr *ia; \
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 1
d217 4
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: in_var.h,v 1.15 1995/06/12 00:47:37 mycroft Exp $	*/
d212 1
a212 1
int	in_delmulti __P((struct in_multi *));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
