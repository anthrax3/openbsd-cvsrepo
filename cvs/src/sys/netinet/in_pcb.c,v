head	1.224;
access;
symbols
	OPENBSD_6_1:1.220.0.4
	OPENBSD_6_1_BASE:1.220
	OPENBSD_6_0:1.212.0.4
	OPENBSD_6_0_BASE:1.212
	OPENBSD_5_9:1.195.0.2
	OPENBSD_5_9_BASE:1.195
	OPENBSD_5_8:1.172.0.4
	OPENBSD_5_8_BASE:1.172
	OPENBSD_5_7:1.168.0.2
	OPENBSD_5_7_BASE:1.168
	OPENBSD_5_6:1.158.0.4
	OPENBSD_5_6_BASE:1.158
	OPENBSD_5_5:1.147.0.4
	OPENBSD_5_5_BASE:1.147
	OPENBSD_5_4:1.139.0.2
	OPENBSD_5_4_BASE:1.139
	OPENBSD_5_3:1.131.0.2
	OPENBSD_5_3_BASE:1.131
	OPENBSD_5_2:1.127.0.2
	OPENBSD_5_2_BASE:1.127
	OPENBSD_5_1_BASE:1.125
	OPENBSD_5_1:1.125.0.2
	OPENBSD_5_0:1.124.0.2
	OPENBSD_5_0_BASE:1.124
	OPENBSD_4_9:1.113.0.4
	OPENBSD_4_9_BASE:1.113
	OPENBSD_4_8:1.113.0.2
	OPENBSD_4_8_BASE:1.113
	OPENBSD_4_7:1.111.0.2
	OPENBSD_4_7_BASE:1.111
	OPENBSD_4_6:1.105.0.4
	OPENBSD_4_6_BASE:1.105
	OPENBSD_4_5:1.103.0.2
	OPENBSD_4_5_BASE:1.103
	OPENBSD_4_4:1.102.0.2
	OPENBSD_4_4_BASE:1.102
	OPENBSD_4_3:1.92.0.2
	OPENBSD_4_3_BASE:1.92
	OPENBSD_4_2:1.89.0.2
	OPENBSD_4_2_BASE:1.89
	OPENBSD_4_1:1.88.0.4
	OPENBSD_4_1_BASE:1.88
	OPENBSD_4_0:1.88.0.2
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.84.0.4
	OPENBSD_3_9_BASE:1.84
	OPENBSD_3_8:1.84.0.2
	OPENBSD_3_8_BASE:1.84
	OPENBSD_3_7:1.83.0.2
	OPENBSD_3_7_BASE:1.83
	OPENBSD_3_6:1.80.0.2
	OPENBSD_3_6_BASE:1.80
	SMP_SYNC_A:1.76
	SMP_SYNC_B:1.76
	OPENBSD_3_5:1.75.0.2
	OPENBSD_3_5_BASE:1.75
	OPENBSD_3_4:1.67.0.2
	OPENBSD_3_4_BASE:1.67
	UBC_SYNC_A:1.65
	OPENBSD_3_3:1.64.0.4
	OPENBSD_3_3_BASE:1.64
	OPENBSD_3_2:1.64.0.2
	OPENBSD_3_2_BASE:1.64
	OPENBSD_3_1:1.60.0.2
	OPENBSD_3_1_BASE:1.60
	UBC_SYNC_B:1.64
	UBC:1.58.0.2
	UBC_BASE:1.58
	OPENBSD_3_0:1.56.0.2
	OPENBSD_3_0_BASE:1.56
	OPENBSD_2_9_BASE:1.50
	OPENBSD_2_9:1.50.0.2
	OPENBSD_2_8:1.48.0.2
	OPENBSD_2_8_BASE:1.48
	OPENBSD_2_7:1.42.0.2
	OPENBSD_2_7_BASE:1.42
	SMP:1.40.0.2
	SMP_BASE:1.40
	kame_19991208:1.35
	OPENBSD_2_6:1.34.0.2
	OPENBSD_2_6_BASE:1.34
	OPENBSD_2_5:1.32.0.2
	OPENBSD_2_5_BASE:1.32
	OPENBSD_2_4:1.24.0.2
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.18.0.2
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.224
date	2017.08.11.19.53.02;	author bluhm;	state Exp;
branches;
next	1.223;
commitid	ZSLEQCt6cCaCd9uI;

1.223
date	2017.08.04.18.16.42;	author bluhm;	state Exp;
branches;
next	1.222;
commitid	QSvbBHviN55gYPsY;

1.222
date	2017.06.09.12.56.43;	author mpi;	state Exp;
branches;
next	1.221;
commitid	QXIy2rZA5FPYfFIG;

1.221
date	2017.06.07.13.28.02;	author mpi;	state Exp;
branches;
next	1.220;
commitid	c48G09HN6s8XE6t3;

1.220
date	2017.03.07.16.59.40;	author bluhm;	state Exp;
branches;
next	1.219;
commitid	FWorR2yatnd5ZrSk;

1.219
date	2017.03.07.12.00.31;	author bluhm;	state Exp;
branches;
next	1.218;
commitid	iCkvYb3P1MibOmQw;

1.218
date	2017.03.06.08.59.07;	author mpi;	state Exp;
branches;
next	1.217;
commitid	5F7mwVgpVaCdO0cW;

1.217
date	2017.03.06.08.56.39;	author mpi;	state Exp;
branches;
next	1.216;
commitid	aDXuIkVsOPuafbD0;

1.216
date	2016.10.06.19.09.08;	author bluhm;	state Exp;
branches;
next	1.215;
commitid	IO8dsedjngxSg7J1;

1.215
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.214;
commitid	RlO92XR575sygHqm;

1.214
date	2016.09.06.00.04.15;	author dlg;	state Exp;
branches;
next	1.213;
commitid	UqrCCAsrdk9XuY5o;

1.213
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.212;
commitid	nbCHuHn2E9uBfKJT;

1.212
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.211;
commitid	Cm0qxR09oTCkXjXZ;

1.211
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.210;
commitid	jodmGXAB42f8N6nf;

1.210
date	2016.07.19.14.49.46;	author mpi;	state Exp;
branches;
next	1.209;
commitid	IFP1zlYfgFO8tNPI;

1.209
date	2016.07.05.09.17.10;	author mpi;	state Exp;
branches;
next	1.208;
commitid	1gPJe3piOxCmCu6H;

1.208
date	2016.06.30.12.36.27;	author mpi;	state Exp;
branches;
next	1.207;
commitid	CBXvgAdAkcHfXnGX;

1.207
date	2016.06.18.10.36.13;	author vgross;	state Exp;
branches;
next	1.206;
commitid	r16P5gVURcjZa76o;

1.206
date	2016.04.19.22.16.25;	author sthen;	state Exp;
branches;
next	1.205;
commitid	TuX5u1PkoKAoQ7lf;

1.205
date	2016.04.13.06.06.04;	author vgross;	state Exp;
branches;
next	1.204;
commitid	dRE5Yozk19tPaCFC;

1.204
date	2016.04.12.14.42.54;	author krw;	state Exp;
branches;
next	1.203;
commitid	pEWM2RYOeXwDzdKS;

1.203
date	2016.04.11.21.39.18;	author vgross;	state Exp;
branches;
next	1.202;
commitid	sc9jv20Fsj39U5rl;

1.202
date	2016.04.11.21.24.29;	author vgross;	state Exp;
branches;
next	1.201;
commitid	KN7g5vtebtPTCcjK;

1.201
date	2016.04.08.14.34.21;	author vgross;	state Exp;
branches;
next	1.200;
commitid	6jlcoxfxBOSLK13Q;

1.200
date	2016.04.05.21.21.41;	author vgross;	state Exp;
branches;
next	1.199;
commitid	hj4FrKNwbP0WyZIh;

1.199
date	2016.04.05.19.34.05;	author vgross;	state Exp;
branches;
next	1.198;
commitid	wDN5EGniV99A0gDC;

1.198
date	2016.03.26.21.56.04;	author mpi;	state Exp;
branches;
next	1.197;
commitid	vJtQRrj5mFxFKXT0;

1.197
date	2016.03.23.15.50.36;	author vgross;	state Exp;
branches;
next	1.196;
commitid	iMWKOVeEybjVAEfv;

1.196
date	2016.03.23.00.07.31;	author vgross;	state Exp;
branches;
next	1.195;
commitid	1WuXi1AsK2Cl7cAo;

1.195
date	2015.12.18.22.25.16;	author vgross;	state Exp;
branches;
next	1.194;
commitid	y6SQx88Uf5pOjMYS;

1.194
date	2015.12.03.21.57.59;	author mpi;	state Exp;
branches;
next	1.193;
commitid	nmbu8xP0zmz2PPN0;

1.193
date	2015.12.03.14.55.18;	author vgross;	state Exp;
branches;
next	1.192;
commitid	DukW6jeSHPpp8ZFD;

1.192
date	2015.12.03.14.05.28;	author bluhm;	state Exp;
branches;
next	1.191;
commitid	Qo1JIwCdJHaA2LFI;

1.191
date	2015.12.03.09.49.15;	author bluhm;	state Exp;
branches;
next	1.190;
commitid	6HkfIaw2ROsrfw1Q;

1.190
date	2015.12.02.22.13.44;	author vgross;	state Exp;
branches;
next	1.189;
commitid	Qc8hTbFRvzRyD1WZ;

1.189
date	2015.12.02.16.00.42;	author sashan;	state Exp;
branches;
next	1.188;
commitid	uojPT94sS2Q9I95I;

1.188
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.187;
commitid	7wrRch1SS813fOcY;

1.187
date	2015.10.25.10.05.09;	author bluhm;	state Exp;
branches;
next	1.186;
commitid	X8Mu7F8ZYc1VV9Gs;

1.186
date	2015.10.23.13.26.07;	author mpi;	state Exp;
branches;
next	1.185;
commitid	hjcGRV2JOMz2huwE;

1.185
date	2015.10.20.18.04.03;	author deraadt;	state Exp;
branches;
next	1.184;
commitid	cbpu7TMBEmsrNLlG;

1.184
date	2015.10.19.12.10.05;	author mpi;	state Exp;
branches;
next	1.183;
commitid	PaTczkH5eq9sS4jy;

1.183
date	2015.10.19.08.49.13;	author vgross;	state Exp;
branches;
next	1.182;
commitid	OkNHrnqnaRaotlx9;

1.182
date	2015.10.18.00.04.43;	author deraadt;	state Exp;
branches;
next	1.181;
commitid	19QhHGSTTsDpRV7q;

1.181
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.180;
commitid	av6ZVErLSWkVP5Zz;

1.180
date	2015.09.22.09.34.38;	author vgross;	state Exp;
branches;
next	1.179;
commitid	S3cAlx4uzc9zehGV;

1.179
date	2015.09.11.15.29.47;	author deraadt;	state Exp;
branches;
next	1.178;
commitid	0NZe9BgjJety4Dtk;

1.178
date	2015.09.11.13.59.27;	author vgross;	state Exp;
branches;
next	1.177;
commitid	NyNuX1q0M9Dwr560;

1.177
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.176;
commitid	Lqreadw8v5IPAc0L;

1.176
date	2015.09.09.20.14.40;	author dlg;	state Exp;
branches;
next	1.175;
commitid	dW4xfE1GdCIaKwyU;

1.175
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.174;
commitid	RRi5waWu1LaKRicG;

1.174
date	2015.08.22.20.18.50;	author deraadt;	state Exp;
branches;
next	1.173;
commitid	6NDuzTPjBp2GqkfQ;

1.173
date	2015.08.19.13.27.38;	author bluhm;	state Exp;
branches;
next	1.172;
commitid	t09qBDKQRv4jxgp3;

1.172
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.171;
commitid	CJwjm9NDWu6nJ6ES;

1.171
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.170;
commitid	ncpqEGjDtSFuLAgn;

1.170
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.169;
commitid	2c41FFL8044mZVko;

1.169
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.168;
commitid	bQi1IVHgugweH5gs;

1.168
date	2015.02.10.03.07.56;	author claudio;	state Exp;
branches;
next	1.167;
commitid	S4cFKg3KJGlAFqVT;

1.167
date	2015.02.10.01.36.59;	author claudio;	state Exp;
branches;
next	1.166;
commitid	bKwIcjQXtTovtJIS;

1.166
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.165;
commitid	VK3ncyiP3NS1N4Sy;

1.165
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.164;
commitid	Vq8oSnWLkf7dyy0N;

1.164
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.163;
commitid	t9FBKDfc4VDxpEy2;

1.163
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.162;
commitid	Z1vcFtHO8wRH0yRt;

1.162
date	2014.11.15.10.55.47;	author dlg;	state Exp;
branches;
next	1.161;
commitid	dnbbVVnOgRkrlZ0W;

1.161
date	2014.10.28.11.02.38;	author yasuoka;	state Exp;
branches;
next	1.160;
commitid	UZElNclhn6WmOsyn;

1.160
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.159;
commitid	6AYfDT0Lpez1LFQp;

1.159
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.158;
commitid	HQcmytntiCJTHORs;

1.158
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.157;
commitid	DQakU8LLWV6Iwx84;

1.157
date	2014.07.12.21.06.34;	author yasuoka;	state Exp;
branches;
next	1.156;
commitid	LARYP0a27ik2w0nd;

1.156
date	2014.06.04.13.45.47;	author mpi;	state Exp;
branches;
next	1.155;
commitid	aYR3UhMPRsViFuPg;

1.155
date	2014.05.07.08.26.38;	author mpi;	state Exp;
branches;
next	1.154;

1.154
date	2014.04.18.10.48.29;	author jca;	state Exp;
branches;
next	1.153;

1.153
date	2014.04.16.13.04.38;	author mpi;	state Exp;
branches;
next	1.152;

1.152
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.151;

1.151
date	2014.04.06.17.13.23;	author chrisz;	state Exp;
branches;
next	1.150;

1.150
date	2014.04.06.16.49.40;	author chrisz;	state Exp;
branches;
next	1.149;

1.149
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.148;

1.148
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.147;

1.147
date	2014.01.18.21.14.46;	author bluhm;	state Exp;
branches;
next	1.146;

1.146
date	2013.12.20.02.04.08;	author krw;	state Exp;
branches;
next	1.145;

1.145
date	2013.10.23.19.57.49;	author deraadt;	state Exp;
branches;
next	1.144;

1.144
date	2013.10.20.22.28.58;	author bluhm;	state Exp;
branches;
next	1.143;

1.143
date	2013.10.20.11.03.00;	author phessler;	state Exp;
branches;
next	1.142;

1.142
date	2013.10.18.21.27.27;	author bluhm;	state Exp;
branches;
next	1.141;

1.141
date	2013.10.17.16.27.43;	author bluhm;	state Exp;
branches;
next	1.140;

1.140
date	2013.09.06.12.12.45;	author mpi;	state Exp;
branches;
next	1.139;

1.139
date	2013.06.01.13.25.40;	author bluhm;	state Exp;
branches;
next	1.138;

1.138
date	2013.05.31.13.15.53;	author bluhm;	state Exp;
branches;
next	1.137;

1.137
date	2013.04.09.08.35.38;	author mpi;	state Exp;
branches;
next	1.136;

1.136
date	2013.04.02.18.27.46;	author bluhm;	state Exp;
branches;
next	1.135;

1.135
date	2013.03.31.11.18.35;	author bluhm;	state Exp;
branches;
next	1.134;

1.134
date	2013.03.29.13.16.14;	author bluhm;	state Exp;
branches;
next	1.133;

1.133
date	2013.03.28.12.06.55;	author mpi;	state Exp;
branches;
next	1.132;

1.132
date	2013.03.28.00.32.11;	author bluhm;	state Exp;
branches;
next	1.131;

1.131
date	2013.02.05.19.09.52;	author bluhm;	state Exp;
branches;
next	1.130;

1.130
date	2013.02.04.15.10.22;	author millert;	state Exp;
branches;
next	1.129;

1.129
date	2013.01.16.00.07.22;	author bluhm;	state Exp;
branches;
next	1.128;

1.128
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.127;

1.127
date	2012.07.12.15.59.17;	author claudio;	state Exp;
branches;
next	1.126;

1.126
date	2012.03.06.12.44.17;	author claudio;	state Exp;
branches;
next	1.125;

1.125
date	2012.01.11.17.45.05;	author bluhm;	state Exp;
branches;
next	1.124;

1.124
date	2011.07.06.01.57.37;	author dlg;	state Exp;
branches;
next	1.123;

1.123
date	2011.07.05.21.40.38;	author dhill;	state Exp;
branches;
next	1.122;

1.122
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches;
next	1.121;

1.121
date	2011.05.29.13.22.53;	author claudio;	state Exp;
branches;
next	1.120;

1.120
date	2011.05.13.14.31.16;	author oga;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.28.09.56.27;	author claudio;	state Exp;
branches;
next	1.118;

1.118
date	2011.04.28.07.10.03;	author claudio;	state Exp;
branches;
next	1.117;

1.117
date	2011.04.24.19.36.54;	author bluhm;	state Exp;
branches;
next	1.116;

1.116
date	2011.04.19.03.47.29;	author dlg;	state Exp;
branches;
next	1.115;

1.115
date	2011.04.14.08.15.26;	author claudio;	state Exp;
branches;
next	1.114;

1.114
date	2011.04.04.13.26.46;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.112;

1.112
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2010.01.15.18.20.23;	author chl;	state Exp;
branches;
next	1.110;

1.110
date	2009.12.23.07.40.31;	author guenther;	state Exp;
branches;
next	1.109;

1.109
date	2009.11.27.20.05.50;	author guenther;	state Exp;
branches;
next	1.108;

1.108
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.107;

1.107
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.106;

1.106
date	2009.07.26.12.59.16;	author thib;	state Exp;
branches;
next	1.105;

1.105
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.104;

1.104
date	2009.03.15.19.40.41;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2008.10.23.22.22.44;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2008.07.29.21.46.27;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2008.07.09.20.20.45;	author djm;	state Exp;
branches;
next	1.100;

1.100
date	2008.07.03.15.46.24;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.98;

1.98
date	2008.05.15.19.40.38;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2008.05.09.03.14.07;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2008.05.09.02.52.15;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2008.05.07.05.14.21;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2008.04.18.06.42.20;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2007.12.30.21.13.27;	author claudio;	state Exp;
branches
	1.92.2.1;
next	1.91;

1.91
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.90;

1.90
date	2007.09.01.18.49.28;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2006.06.18.11.47.45;	author pascoe;	state Exp;
branches;
next	1.87;

1.87
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2006.04.22.19.43.07;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2005.06.24.07.57.24;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2004.12.06.02.46.34;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2004.12.06.02.41.43;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2004.11.23.15.35.36;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2004.08.10.20.12.15;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2004.08.04.20.45.09;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2004.06.25.03.04.24;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2004.06.22.07.35.20;	author cedric;	state Exp;
branches;
next	1.76;

1.76
date	2004.06.06.16.49.09;	author cedric;	state Exp;
branches;
next	1.75;

1.75
date	2004.03.12.17.49.23;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.02.16.08.54;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2003.12.21.15.12.27;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2003.12.21.14.57.19;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.70;

1.70
date	2003.12.08.07.07.36;	author mcbride;	state Exp;
branches;
next	1.69;

1.69
date	2003.11.04.21.43.16;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2003.10.25.12.15.24;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2003.08.15.20.32.20;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2003.05.06.20.35.14;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.11.05.13.59;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.31.02.39.25;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2002.01.21.05.33.14;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	2001.12.06.02.21.48;	author itojun;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2001.12.06.02.12.52;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2001.07.05.16.45.54;	author jjbg;	state Exp;
branches;
next	1.55;

1.55
date	2001.06.12.10.59.53;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.08.03.53.45;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.05.02.31.35;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.27.03.54.12;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.21.03.02.18;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2001.03.28.20.03.02;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2001.02.08.18.46.22;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2000.10.11.09.14.10;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2000.10.10.15.16.01;	author provos;	state Exp;
branches;
next	1.46;

1.46
date	2000.10.09.14.39.46;	author provos;	state Exp;
branches;
next	1.45;

1.45
date	2000.09.20.16.39.50;	author provos;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.19.03.20.57;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2000.09.18.22.06.37;	author provos;	state Exp;
branches;
next	1.42;

1.42
date	2000.04.27.09.23.21;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2000.04.21.11.42.23;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2000.01.04.10.39.21;	author itojun;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	99.12.19.01.57.07;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	99.12.19.01.51.32;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	99.12.17.22.47.04;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	99.12.08.11.36.40;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	99.05.16.21.48.29;	author niklas;	state Exp;
branches;
next	1.33;

1.33
date	99.04.28.09.28.16;	author art;	state Exp;
branches;
next	1.32;

1.32
date	99.03.27.21.04.18;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	99.03.24.02.28.21;	author cmetz;	state Exp;
branches;
next	1.30;

1.30
date	99.02.24.22.32.57;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	99.01.11.02.01.34;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	99.01.08.07.47.22;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	99.01.07.21.50.51;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.01.07.06.05.04;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.01.07.05.44.31;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.05.18.21.10.27;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	98.02.14.18.50.35;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	98.02.14.10.55.10;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.02.01.21.46.02;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.02.01.18.09.22;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.11.30.06.10.43;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.08.09.23.36.26;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.07.27.08.11.10;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.04.17.02.02.26;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.02.28.04.03.47;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	97.02.05.15.48.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.15.03.27.14;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	96.08.24.04.56.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.08.05.01.17.25;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.08.05.01.16.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.05.01.00.57;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.29.07.54.58;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.07.29.05.03.33;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.07.29.04.47.21;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.07.29.02.34.29;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.05.14.19.37.34;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.14.07.58.29;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.22.30.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches;
next	;

1.40.2.1
date	2001.05.14.22.40.08;	author niklas;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2001.07.04.10.54.33;	author niklas;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.40.2.4;

1.40.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.40.2.5;

1.40.2.5
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.40.2.6;

1.40.2.6
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.40.2.7;

1.40.2.7
date	2003.05.13.19.36.16;	author ho;	state Exp;
branches;
next	1.40.2.8;

1.40.2.8
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.40.2.9;

1.40.2.9
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.40.2.10;

1.40.2.10
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.40.2.11;

1.40.2.11
date	2004.06.07.20.41.39;	author niklas;	state Exp;
branches;
next	;

1.58.2.1
date	2002.01.31.22.55.44;	author niklas;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.58.2.3;

1.58.2.3
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.58.2.4;

1.58.2.4
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;

1.89.2.1
date	2008.07.30.05.27.03;	author brad;	state Exp;
branches;
next	;

1.92.2.1
date	2008.07.30.05.36.15;	author brad;	state Exp;
branches;
next	;


desc
@@


1.224
log
@Validate sockaddr from userland in central functions.  This results
in common checks for unix, inet, inet6 instead of partial checks
here and there.  Some checks are already done at a higher layer,
but better be paranoid with user input.
OK claudio@@ millert@@
@
text
@/*	$OpenBSD: in_pcb.c,v 1.223 2017/08/04 18:16:42 bluhm Exp $	*/
/*	$NetBSD: in_pcb.c,v 1.25 1996/02/13 23:41:53 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/proc.h>
#include <sys/pledge.h>
#include <sys/domain.h>
#include <sys/pool.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>

#include <net/pfvar.h>

#include <sys/mount.h>
#include <nfs/nfsproto.h>

#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet6/ip6_var.h>
#endif /* INET6 */
#ifdef IPSEC
#include <netinet/ip_esp.h>
#endif /* IPSEC */

struct	in_addr zeroin_addr;

union {
	struct in_addr	za_in;
	struct in6_addr	za_in6;
} zeroin46_addr;

/*
 * These configure the range of local port addresses assigned to
 * "unspecified" outgoing connections/packets/whatever.
 */
int ipport_firstauto = IPPORT_RESERVED;
int ipport_lastauto = IPPORT_USERRESERVED;
int ipport_hifirstauto = IPPORT_HIFIRSTAUTO;
int ipport_hilastauto = IPPORT_HILASTAUTO;

struct baddynamicports baddynamicports;
struct baddynamicports rootonlyports;
struct pool inpcb_pool;
int inpcb_pool_initialized = 0;

int in_pcbresize (struct inpcbtable *, int);

#define	INPCBHASH_LOADFACTOR(_x)	(((_x) * 3) / 4)

struct inpcbhead *in_pcbhash(struct inpcbtable *, int,
    const struct in_addr *, u_short, const struct in_addr *, u_short);
struct inpcbhead *in6_pcbhash(struct inpcbtable *, int,
    const struct in6_addr *, u_short, const struct in6_addr *, u_short);
struct inpcbhead *in_pcblhash(struct inpcbtable *, int, u_short);

struct inpcbhead *
in_pcbhash(struct inpcbtable *table, int rdom,
    const struct in_addr *faddr, u_short fport,
    const struct in_addr *laddr, u_short lport)
{
	SIPHASH_CTX ctx;
	u_int32_t nrdom = htonl(rdom);

	SipHash24_Init(&ctx, &table->inpt_key);
	SipHash24_Update(&ctx, &nrdom, sizeof(nrdom));
	SipHash24_Update(&ctx, faddr, sizeof(*faddr));
	SipHash24_Update(&ctx, &fport, sizeof(fport));
	SipHash24_Update(&ctx, laddr, sizeof(*laddr));
	SipHash24_Update(&ctx, &lport, sizeof(lport));

	return (&table->inpt_hashtbl[SipHash24_End(&ctx) & table->inpt_hash]);
}

#define	INPCBHASH(table, faddr, fport, laddr, lport, rdom) \
	in_pcbhash(table, rdom, faddr, fport, laddr, lport)

struct inpcbhead *
in6_pcbhash(struct inpcbtable *table, int rdom,
    const struct in6_addr *faddr, u_short fport,
    const struct in6_addr *laddr, u_short lport)
{
	SIPHASH_CTX ctx;
	u_int32_t nrdom = htonl(rdom);

	SipHash24_Init(&ctx, &table->inpt_key);
	SipHash24_Update(&ctx, &nrdom, sizeof(nrdom));
	SipHash24_Update(&ctx, faddr, sizeof(*faddr));
	SipHash24_Update(&ctx, &fport, sizeof(fport));
	SipHash24_Update(&ctx, laddr, sizeof(*laddr));
	SipHash24_Update(&ctx, &lport, sizeof(lport));

	return (&table->inpt_hashtbl[SipHash24_End(&ctx) & table->inpt_hash]);
}

#define	IN6PCBHASH(table, faddr, fport, laddr, lport, rdom) \
	in6_pcbhash(table, rdom, faddr, fport, laddr, lport)

struct inpcbhead *
in_pcblhash(struct inpcbtable *table, int rdom, u_short lport)
{
	SIPHASH_CTX ctx;
	u_int32_t nrdom = htonl(rdom);

	SipHash24_Init(&ctx, &table->inpt_key);
	SipHash24_Update(&ctx, &nrdom, sizeof(nrdom));
	SipHash24_Update(&ctx, &lport, sizeof(lport));

	return (&table->inpt_lhashtbl[SipHash24_End(&ctx) & table->inpt_lhash]);
}

#define	INPCBLHASH(table, lport, rdom) in_pcblhash(table, rdom, lport)

void
in_pcbinit(struct inpcbtable *table, int hashsize)
{

	TAILQ_INIT(&table->inpt_queue);
	table->inpt_hashtbl = hashinit(hashsize, M_PCB, M_NOWAIT,
	    &table->inpt_hash);
	if (table->inpt_hashtbl == NULL)
		panic("in_pcbinit: hashinit failed");
	table->inpt_lhashtbl = hashinit(hashsize, M_PCB, M_NOWAIT,
	    &table->inpt_lhash);
	if (table->inpt_lhashtbl == NULL)
		panic("in_pcbinit: hashinit failed for lport");
	table->inpt_count = 0;
	arc4random_buf(&table->inpt_key, sizeof(table->inpt_key));
}

/*
 * Check if the specified port is invalid for dynamic allocation.
 */
int
in_baddynamic(u_int16_t port, u_int16_t proto)
{
	switch (proto) {
	case IPPROTO_TCP:
		return (DP_ISSET(baddynamicports.tcp, port));
	case IPPROTO_UDP:
#ifdef IPSEC
		/* Cannot preset this as it is a sysctl */
		if (port == udpencap_port)
			return (1);
#endif
		return (DP_ISSET(baddynamicports.udp, port));
	default:
		return (0);
	}
}

int
in_rootonly(u_int16_t port, u_int16_t proto)
{
	switch (proto) {
	case IPPROTO_TCP:
		return (port < IPPORT_RESERVED ||
		    DP_ISSET(rootonlyports.tcp, port));
	case IPPROTO_UDP:
		return (port < IPPORT_RESERVED ||
		    DP_ISSET(rootonlyports.udp, port));
	default:
		return (0);
	}
}

int
in_pcballoc(struct socket *so, struct inpcbtable *table)
{
	struct inpcb *inp;
	struct inpcbhead *head;

	NET_ASSERT_LOCKED();

	if (inpcb_pool_initialized == 0) {
		pool_init(&inpcb_pool, sizeof(struct inpcb), 0,
		    IPL_SOFTNET, 0, "inpcbpl", NULL);
		inpcb_pool_initialized = 1;
	}
	inp = pool_get(&inpcb_pool, PR_NOWAIT|PR_ZERO);
	if (inp == NULL)
		return (ENOBUFS);
	inp->inp_table = table;
	inp->inp_socket = so;
	inp->inp_seclevel[SL_AUTH] = IPSEC_AUTH_LEVEL_DEFAULT;
	inp->inp_seclevel[SL_ESP_TRANS] = IPSEC_ESP_TRANS_LEVEL_DEFAULT;
	inp->inp_seclevel[SL_ESP_NETWORK] = IPSEC_ESP_NETWORK_LEVEL_DEFAULT;
	inp->inp_seclevel[SL_IPCOMP] = IPSEC_IPCOMP_LEVEL_DEFAULT;
	inp->inp_rtableid = curproc->p_p->ps_rtableid;
	if (table->inpt_hash != 0 &&
	    table->inpt_count++ > INPCBHASH_LOADFACTOR(table->inpt_hash))
		(void)in_pcbresize(table, (table->inpt_hash + 1) * 2);
	TAILQ_INSERT_HEAD(&table->inpt_queue, inp, inp_queue);
	head = INPCBLHASH(table, inp->inp_lport, inp->inp_rtableid);
	LIST_INSERT_HEAD(head, inp, inp_lhash);
#ifdef INET6
	if (sotopf(so) == PF_INET6)
		head = IN6PCBHASH(table, &inp->inp_faddr6, inp->inp_fport,
		    &inp->inp_laddr6, inp->inp_lport,
		    rtable_l2(inp->inp_rtableid));
	else
#endif /* INET6 */
		head = INPCBHASH(table, &inp->inp_faddr, inp->inp_fport,
		    &inp->inp_laddr, inp->inp_lport,
		    rtable_l2(inp->inp_rtableid));
	LIST_INSERT_HEAD(head, inp, inp_hash);
	so->so_pcb = inp;
	inp->inp_hops = -1;

#ifdef INET6
	/*
	 * Small change in this function to set the INP_IPV6 flag so routines
	 * outside pcb-specific routines don't need to use sotopf(), and all
	 * of its pointer chasing, later.
	 */
	if (sotopf(so) == PF_INET6)
		inp->inp_flags = INP_IPV6;
	inp->inp_cksum6 = -1;
#endif /* INET6 */
	return (0);
}

int
in_pcbbind(struct inpcb *inp, struct mbuf *nam, struct proc *p)
{
	struct socket *so = inp->inp_socket;
	u_int16_t lport = 0;
	int wild = 0;
	void *laddr = &zeroin46_addr;
	int error;

	if (inp->inp_lport)
		return (EINVAL);

	if ((so->so_options & (SO_REUSEADDR|SO_REUSEPORT)) == 0 &&
	    ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
	     (so->so_options & SO_ACCEPTCONN) == 0))
		wild = INPLOOKUP_WILDCARD;

	switch (sotopf(so)) {
#ifdef INET6
	case PF_INET6:
		if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
			return (EINVAL);
		wild |= INPLOOKUP_IPV6;

		if (nam) {
			struct sockaddr_in6 *sin6;

			if ((error = in6_nam2sin6(nam, &sin6)))
				return (error);
			if ((error = in6_pcbaddrisavail(inp, sin6, wild, p)))
				return (error);
			laddr = &sin6->sin6_addr;
			lport = sin6->sin6_port;
		}
		break;
#endif
	case PF_INET:
		if (inp->inp_laddr.s_addr != INADDR_ANY)
			return (EINVAL);

		if (nam) {
			struct sockaddr_in *sin;

			if ((error = in_nam2sin(nam, &sin)))
				return (error);
			if ((error = in_pcbaddrisavail(inp, sin, wild, p)))
				return (error);
			laddr = &sin->sin_addr;
			lport = sin->sin_port;
		}
		break;
	default:
		return (EINVAL);
	}

	if (lport == 0) {
		if ((error = in_pcbpickport(&lport, laddr, wild, inp, p)))
			return (error);
	} else {
		if (in_rootonly(ntohs(lport), so->so_proto->pr_protocol) &&
		    suser(p, 0) != 0)
			return (EACCES);
	}
	if (nam) {
		switch (sotopf(so)) {
#ifdef INET6
		case PF_INET6:
			inp->inp_laddr6 = *(struct in6_addr *)laddr;
			break;
#endif
		case PF_INET:
			inp->inp_laddr = *(struct in_addr *)laddr;
			break;
		}
	}
	inp->inp_lport = lport;
	in_pcbrehash(inp);
	return (0);
}

int
in_pcbaddrisavail(struct inpcb *inp, struct sockaddr_in *sin, int wild,
    struct proc *p)
{
	struct socket *so = inp->inp_socket;
	struct inpcbtable *table = inp->inp_table;
	u_int16_t lport = sin->sin_port;
	int reuseport = (so->so_options & SO_REUSEPORT);

	if (IN_MULTICAST(sin->sin_addr.s_addr)) {
		/*
		 * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
		 * allow complete duplication of binding if
		 * SO_REUSEPORT is set, or if SO_REUSEADDR is set
		 * and a multicast address is bound on both
		 * new and duplicated sockets.
		 */
		if (so->so_options & (SO_REUSEADDR|SO_REUSEPORT))
			reuseport = SO_REUSEADDR|SO_REUSEPORT;
	} else if (sin->sin_addr.s_addr != INADDR_ANY) {
		/*
		 * we must check that we are binding to an address we
		 * own except when:
		 * - SO_BINDANY is set or
		 * - we are binding a UDP socket to 255.255.255.255 or
		 * - we are binding a UDP socket to one of our broadcast
		 *   addresses
		 */
		if (!ISSET(so->so_options, SO_BINDANY) &&
		    !(so->so_type == SOCK_DGRAM &&
		    sin->sin_addr.s_addr == INADDR_BROADCAST) &&
		    !(so->so_type == SOCK_DGRAM &&
		    in_broadcast(sin->sin_addr, inp->inp_rtableid))) {
			struct ifaddr *ia;

			sin->sin_port = 0;
			memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
			ia = ifa_ifwithaddr(sintosa(sin), inp->inp_rtableid);
			sin->sin_port = lport;

			if (ia == NULL)
				return (EADDRNOTAVAIL);
		}
	}
	if (lport) {
		struct inpcb *t;

		if (so->so_euid) {
			t = in_pcblookup_local(table, &sin->sin_addr, lport,
			    INPLOOKUP_WILDCARD, inp->inp_rtableid);
			if (t && (so->so_euid != t->inp_socket->so_euid))
				return (EADDRINUSE);
		}
		t = in_pcblookup_local(table, &sin->sin_addr, lport,
		    wild, inp->inp_rtableid);
		if (t && (reuseport & t->inp_socket->so_options) == 0)
			return (EADDRINUSE);
	}

	return (0);
}

int
in_pcbpickport(u_int16_t *lport, void *laddr, int wild, struct inpcb *inp,
    struct proc *p)
{
	struct socket *so = inp->inp_socket;
	struct inpcbtable *table = inp->inp_table;
	u_int16_t first, last, lower, higher, candidate, localport;
	int count;

	if (inp->inp_flags & INP_HIGHPORT) {
		first = ipport_hifirstauto;	/* sysctl */
		last = ipport_hilastauto;
	} else if (inp->inp_flags & INP_LOWPORT) {
		if (suser(p, 0))
			return (EACCES);
		first = IPPORT_RESERVED-1; /* 1023 */
		last = 600;		   /* not IPPORT_RESERVED/2 */
	} else {
		first = ipport_firstauto;	/* sysctl */
		last = ipport_lastauto;
	}
	if (first < last) {
		lower = first;
		higher = last;
	} else {
		lower = last;
		higher = first;
	}

	/*
	 * Simple check to ensure all ports are not used up causing
	 * a deadlock here.
	 */

	count = higher - lower;
	candidate = lower + arc4random_uniform(count);

	do {
		if (count-- < 0) 	/* completely used? */
			return (EADDRNOTAVAIL);
		++candidate;
		if (candidate < lower || candidate > higher)
			candidate = lower;
		localport = htons(candidate);
	} while (in_baddynamic(candidate, so->so_proto->pr_protocol) ||
	    in_pcblookup_local(table, laddr, localport, wild,
	    inp->inp_rtableid));
	*lport = localport;

	return (0);
}

/*
 * Connect from a socket to a specified address.
 * Both address and port must be specified in argument sin.
 * If don't have a local address for this socket yet,
 * then pick one.
 */
int
in_pcbconnect(struct inpcb *inp, struct mbuf *nam)
{
	struct in_addr *ina = NULL;
	struct sockaddr_in *sin;
	int error;

#ifdef INET6
	if (sotopf(inp->inp_socket) == PF_INET6)
		return (in6_pcbconnect(inp, nam));
	if ((inp->inp_flags & INP_IPV6) != 0)
		panic("IPv6 pcb passed into in_pcbconnect");
#endif /* INET6 */

	if ((error = in_nam2sin(nam, &sin)))
		return (error);
	if (sin->sin_port == 0)
		return (EADDRNOTAVAIL);
	error = in_pcbselsrc(&ina, sin, inp);
	if (error)
		return (error);

	if (in_pcbhashlookup(inp->inp_table, sin->sin_addr, sin->sin_port,
	    *ina, inp->inp_lport, inp->inp_rtableid) != NULL)
		return (EADDRINUSE);

	KASSERT(inp->inp_laddr.s_addr == INADDR_ANY || inp->inp_lport);

	if (inp->inp_laddr.s_addr == INADDR_ANY) {
		if (inp->inp_lport == 0) {
			error = in_pcbbind(inp, NULL, curproc);
			if (error)
				return (error);
			if (in_pcbhashlookup(inp->inp_table, sin->sin_addr,
			    sin->sin_port, *ina, inp->inp_lport,
			    inp->inp_rtableid) != NULL) {
				inp->inp_lport = 0;
				return (EADDRINUSE);
			}
		}
		inp->inp_laddr = *ina;
	}
	inp->inp_faddr = sin->sin_addr;
	inp->inp_fport = sin->sin_port;
	in_pcbrehash(inp);
#ifdef IPSEC
	{
		/* Cause an IPsec SA to be established. */
	  	/* error is just ignored */
		ipsp_spd_inp(NULL, AF_INET, 0, &error, IPSP_DIRECTION_OUT,
		    NULL, inp, NULL);
	}
#endif
	return (0);
}

void
in_pcbdisconnect(struct inpcb *inp)
{
	switch (sotopf(inp->inp_socket)) {
#ifdef INET6
	case PF_INET6:
		inp->inp_faddr6 = in6addr_any;
		break;
#endif
	case PF_INET:
		inp->inp_faddr.s_addr = INADDR_ANY;
		break;
	}

	inp->inp_fport = 0;
	in_pcbrehash(inp);
	if (inp->inp_socket->so_state & SS_NOFDREF)
		in_pcbdetach(inp);
}

void
in_pcbdetach(struct inpcb *inp)
{
	struct socket *so = inp->inp_socket;

	NET_ASSERT_LOCKED();

	so->so_pcb = 0;
	sofree(so);
	m_freem(inp->inp_options);
	if (inp->inp_route.ro_rt) {
		rtfree(inp->inp_route.ro_rt);
		inp->inp_route.ro_rt = NULL;
	}
#ifdef INET6
	if (inp->inp_flags & INP_IPV6) {
		ip6_freepcbopts(inp->inp_outputopts6);
		ip6_freemoptions(inp->inp_moptions6);
	} else
#endif
		ip_freemoptions(inp->inp_moptions);
#if NPF > 0
	if (inp->inp_pf_sk) {
		pf_remove_divert_state(inp->inp_pf_sk);
		/* pf_remove_divert_state() may have detached the state */
		pf_inp_unlink(inp);
	}
#endif
	LIST_REMOVE(inp, inp_lhash);
	LIST_REMOVE(inp, inp_hash);
	TAILQ_REMOVE(&inp->inp_table->inpt_queue, inp, inp_queue);
	inp->inp_table->inpt_count--;
	pool_put(&inpcb_pool, inp);
}

void
in_setsockaddr(struct inpcb *inp, struct mbuf *nam)
{
	struct sockaddr_in *sin;

	nam->m_len = sizeof(*sin);
	sin = mtod(nam, struct sockaddr_in *);
	memset(sin, 0, sizeof(*sin));
	sin->sin_family = AF_INET;
	sin->sin_len = sizeof(*sin);
	sin->sin_port = inp->inp_lport;
	sin->sin_addr = inp->inp_laddr;
}

void
in_setpeeraddr(struct inpcb *inp, struct mbuf *nam)
{
	struct sockaddr_in *sin;

#ifdef INET6
	if (sotopf(inp->inp_socket) == PF_INET6) {
		in6_setpeeraddr(inp, nam);
		return;
	}
#endif /* INET6 */

	nam->m_len = sizeof(*sin);
	sin = mtod(nam, struct sockaddr_in *);
	memset(sin, 0, sizeof(*sin));
	sin->sin_family = AF_INET;
	sin->sin_len = sizeof(*sin);
	sin->sin_port = inp->inp_fport;
	sin->sin_addr = inp->inp_faddr;
}

/*
 * Pass some notification to all connections of a protocol
 * associated with address dst.  The "usual action" will be
 * taken, depending on the ctlinput cmd.  The caller must filter any
 * cmds that are uninteresting (e.g., no error in the map).
 * Call the protocol specific routine (if any) to report
 * any errors for each matching socket.
 */
void
in_pcbnotifyall(struct inpcbtable *table, struct sockaddr *dst, u_int rdomain,
    int errno, void (*notify)(struct inpcb *, int))
{
	struct inpcb *inp, *ninp;
	struct in_addr faddr;

	NET_ASSERT_LOCKED();

#ifdef INET6
	/*
	 * See in6_pcbnotify() for IPv6 codepath.  By the time this
	 * gets called, the addresses passed are either definitely IPv4 or
	 * IPv6; *_pcbnotify() never gets called with v4-mapped v6 addresses.
	 */
#endif /* INET6 */

	if (dst->sa_family != AF_INET)
		return;
	faddr = satosin(dst)->sin_addr;
	if (faddr.s_addr == INADDR_ANY)
		return;

	rdomain = rtable_l2(rdomain);
	TAILQ_FOREACH_SAFE(inp, &table->inpt_queue, inp_queue, ninp) {
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			continue;
#endif
		if (inp->inp_faddr.s_addr != faddr.s_addr ||
		    rtable_l2(inp->inp_rtableid) != rdomain ||
		    inp->inp_socket == 0) {
			continue;
		}
		if (notify)
			(*notify)(inp, errno);
	}
}

/*
 * Check for alternatives when higher level complains
 * about service problems.  For now, invalidate cached
 * routing information.  If the route was created dynamically
 * (by a redirect), time to try a default gateway again.
 */
void
in_losing(struct inpcb *inp)
{
	struct rtentry *rt;
	struct rt_addrinfo info;
	struct sockaddr_in6 sa_mask;

	if ((rt = inp->inp_route.ro_rt)) {
		inp->inp_route.ro_rt = 0;

		memset(&info, 0, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = &inp->inp_route.ro_dst;
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_plen2mask(rt, &sa_mask);

		KERNEL_LOCK();
		rtm_miss(RTM_LOSING, &info, rt->rt_flags, rt->rt_priority,
		    rt->rt_ifidx, 0, inp->inp_rtableid);
		KERNEL_UNLOCK();
		if (rt->rt_flags & RTF_DYNAMIC) {
			struct ifnet *ifp;

			ifp = if_get(rt->rt_ifidx);
			/*
			 * If the interface is gone, all its attached
			 * route entries have been removed from the table,
			 * so we're dealing with a stale cache and have
			 * nothing to do.
			 */
			if (ifp != NULL) {
				rtrequest_delete(&info, rt->rt_priority, ifp,
				    NULL, inp->inp_rtableid);
			}
			if_put(ifp);
		}
		/*
		 * A new route can be allocated
		 * the next time output is attempted.
		 * rtfree() needs to be called in anycase because the inp
		 * is still holding a reference to rt.
		 */
		rtfree(rt);
	}
}

/*
 * After a routing change, flush old routing
 * and allocate a (hopefully) better one.
 */
void
in_rtchange(struct inpcb *inp, int errno)
{
	if (inp->inp_route.ro_rt) {
		rtfree(inp->inp_route.ro_rt);
		inp->inp_route.ro_rt = 0;
		/*
		 * A new route can be allocated the next time
		 * output is attempted.
		 */
	}
}

struct inpcb *
in_pcblookup_local(struct inpcbtable *table, void *laddrp, u_int lport_arg,
    int flags, u_int rdomain)
{
	struct inpcb *inp, *match = NULL;
	int matchwild = 3, wildcard;
	u_int16_t lport = lport_arg;
	struct in_addr laddr = *(struct in_addr *)laddrp;
#ifdef INET6
	struct in6_addr *laddr6 = (struct in6_addr *)laddrp;
#endif
	struct inpcbhead *head;

	rdomain = rtable_l2(rdomain);	/* convert passed rtableid to rdomain */
	head = INPCBLHASH(table, lport, rdomain);
	LIST_FOREACH(inp, head, inp_lhash) {
		if (rtable_l2(inp->inp_rtableid) != rdomain)
			continue;
		if (inp->inp_lport != lport)
			continue;
		wildcard = 0;
#ifdef INET6
		if (ISSET(flags, INPLOOKUP_IPV6)) {
			if (!ISSET(inp->inp_flags, INP_IPV6))
				continue;

			if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
				wildcard++;

			if (!IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, laddr6)) {
				if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) ||
				    IN6_IS_ADDR_UNSPECIFIED(laddr6))
					wildcard++;
				else
					continue;
			}

		} else
#endif /* INET6 */
		{
#ifdef INET6
			if (ISSET(inp->inp_flags, INP_IPV6))
				continue;
#endif /* INET6 */

			if (inp->inp_faddr.s_addr != INADDR_ANY)
				wildcard++;

			if (inp->inp_laddr.s_addr != laddr.s_addr) {
				if (inp->inp_laddr.s_addr == INADDR_ANY ||
				    laddr.s_addr == INADDR_ANY)
					wildcard++;
				else
					continue;
			}

		}
		if ((!wildcard || (flags & INPLOOKUP_WILDCARD)) &&
		    wildcard < matchwild) {
			match = inp;
			if ((matchwild = wildcard) == 0)
				break;
		}
	}
	return (match);
}

struct rtentry *
in_pcbrtentry(struct inpcb *inp)
{
	struct route *ro;

	ro = &inp->inp_route;

	/* check if route is still valid */
	if (!rtisvalid(ro->ro_rt)) {
		rtfree(ro->ro_rt);
		ro->ro_rt = NULL;
	}

	/*
	 * No route yet, so try to acquire one.
	 */
	if (ro->ro_rt == NULL) {
#ifdef INET6
		memset(ro, 0, sizeof(struct route_in6));
#else
		memset(ro, 0, sizeof(struct route));
#endif

		switch(sotopf(inp->inp_socket)) {
#ifdef INET6
		case PF_INET6:
			if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
				break;
			ro->ro_dst.sa_family = AF_INET6;
			ro->ro_dst.sa_len = sizeof(struct sockaddr_in6);
			satosin6(&ro->ro_dst)->sin6_addr = inp->inp_faddr6;
			ro->ro_tableid = inp->inp_rtableid;
			ro->ro_rt = rtalloc_mpath(&ro->ro_dst,
			    &inp->inp_laddr6.s6_addr32[0], ro->ro_tableid);
			break;
#endif /* INET6 */
		case PF_INET:
			if (inp->inp_faddr.s_addr == INADDR_ANY)
				break;
			ro->ro_dst.sa_family = AF_INET;
			ro->ro_dst.sa_len = sizeof(struct sockaddr_in);
			satosin(&ro->ro_dst)->sin_addr = inp->inp_faddr;
			ro->ro_tableid = inp->inp_rtableid;
			ro->ro_rt = rtalloc_mpath(&ro->ro_dst,
			    &inp->inp_laddr.s_addr, ro->ro_tableid);
			break;
		}
	}
	return (ro->ro_rt);
}

/*
 * Return an IPv4 address, which is the most appropriate for a given
 * destination.
 * If necessary, this function lookups the routing table and returns
 * an entry to the caller for later use.
 */
int
in_pcbselsrc(struct in_addr **insrc, struct sockaddr_in *sin,
    struct inpcb *inp)
{
	struct ip_moptions *mopts = inp->inp_moptions;
	struct route *ro = &inp->inp_route;
	struct in_addr *laddr = &inp->inp_laddr;
	u_int rtableid = inp->inp_rtableid;

	struct sockaddr_in *sin2;
	struct in_ifaddr *ia = NULL;

	/*
	 * If the socket(if any) is already bound, use that bound address
	 * unless it is INADDR_ANY or INADDR_BROADCAST.
	 */
	if (laddr && laddr->s_addr != INADDR_ANY &&
	    laddr->s_addr != INADDR_BROADCAST) {
		*insrc = laddr;
		return (0);
	}

	/*
	 * If the destination address is multicast and an outgoing
	 * interface has been set as a multicast option, use the
	 * address of that interface as our source address.
	 */
	if (IN_MULTICAST(sin->sin_addr.s_addr) && mopts != NULL) {
		struct ifnet *ifp;

		ifp = if_get(mopts->imo_ifidx);
		if (ifp != NULL) {
			if (ifp->if_rdomain == rtable_l2(rtableid))
				IFP_TO_IA(ifp, ia);
			if (ia == NULL) {
				if_put(ifp);
				return (EADDRNOTAVAIL);
			}

			*insrc = &ia->ia_addr.sin_addr;
			if_put(ifp);
			return (0);
		}
	}
	/*
	 * If route is known or can be allocated now,
	 * our src addr is taken from the i/f, else punt.
	 */
	if (!rtisvalid(ro->ro_rt) || (ro->ro_tableid != rtableid) ||
	    (satosin(&ro->ro_dst)->sin_addr.s_addr != sin->sin_addr.s_addr)) {
		rtfree(ro->ro_rt);
		ro->ro_rt = NULL;
	}
	if (ro->ro_rt == NULL) {
		/* No route yet, so try to acquire one */
		ro->ro_dst.sa_family = AF_INET;
		ro->ro_dst.sa_len = sizeof(struct sockaddr_in);
		satosin(&ro->ro_dst)->sin_addr = sin->sin_addr;
		ro->ro_tableid = rtableid;
		ro->ro_rt = rtalloc_mpath(&ro->ro_dst, NULL, ro->ro_tableid);

		/*
		 * It is important to zero out the rest of the
		 * struct sockaddr_in when mixing v6 & v4!
		 */
		sin2 = satosin(&ro->ro_dst);
		memset(sin2->sin_zero, 0, sizeof(sin2->sin_zero));
	}
	/*
	 * If we found a route, use the address
	 * corresponding to the outgoing interface.
	 */
	if (ro->ro_rt != NULL)
		ia = ifatoia(ro->ro_rt->rt_ifa);

	if (ia == NULL)
		return (EADDRNOTAVAIL);

	*insrc = &ia->ia_addr.sin_addr;
	return (0);
}

void
in_pcbrehash(struct inpcb *inp)
{
	struct inpcbtable *table = inp->inp_table;
	struct inpcbhead *head;

	NET_ASSERT_LOCKED();

	LIST_REMOVE(inp, inp_lhash);
	head = INPCBLHASH(table, inp->inp_lport, inp->inp_rtableid);
	LIST_INSERT_HEAD(head, inp, inp_lhash);
	LIST_REMOVE(inp, inp_hash);
#ifdef INET6
	if (inp->inp_flags & INP_IPV6)
		head = IN6PCBHASH(table, &inp->inp_faddr6, inp->inp_fport,
		    &inp->inp_laddr6, inp->inp_lport,
		    rtable_l2(inp->inp_rtableid));
	else
#endif /* INET6 */
		head = INPCBHASH(table, &inp->inp_faddr, inp->inp_fport,
		    &inp->inp_laddr, inp->inp_lport,
		    rtable_l2(inp->inp_rtableid));
	LIST_INSERT_HEAD(head, inp, inp_hash);
}

int
in_pcbresize(struct inpcbtable *table, int hashsize)
{
	u_long nhash, nlhash;
	void *nhashtbl, *nlhashtbl, *ohashtbl, *olhashtbl;
	struct inpcb *inp0, *inp1;

	ohashtbl = table->inpt_hashtbl;
	olhashtbl = table->inpt_lhashtbl;

	nhashtbl = hashinit(hashsize, M_PCB, M_NOWAIT, &nhash);
	nlhashtbl = hashinit(hashsize, M_PCB, M_NOWAIT, &nlhash);
	if (nhashtbl == NULL || nlhashtbl == NULL) {
		if (nhashtbl != NULL)
			free(nhashtbl, M_PCB, 0);
		if (nlhashtbl != NULL)
			free(nlhashtbl, M_PCB, 0);
		return (ENOBUFS);
	}
	table->inpt_hashtbl = nhashtbl;
	table->inpt_lhashtbl = nlhashtbl;
	table->inpt_hash = nhash;
	table->inpt_lhash = nlhash;
	arc4random_buf(&table->inpt_key, sizeof(table->inpt_key));

	TAILQ_FOREACH_SAFE(inp0, &table->inpt_queue, inp_queue, inp1) {
		in_pcbrehash(inp0);
	}
	free(ohashtbl, M_PCB, 0);
	free(olhashtbl, M_PCB, 0);

	return (0);
}

#ifdef DIAGNOSTIC
int	in_pcbnotifymiss = 0;
#endif

/*
 * The in(6)_pcbhashlookup functions are used to locate connected sockets
 * quickly:
 * 		faddr.fport <-> laddr.lport
 * No wildcard matching is done so that listening sockets are not found.
 * If the functions return NULL in(6)_pcblookup_listen can be used to
 * find a listening/bound socket that may accept the connection.
 * After those two lookups no other are necessary.
 */
struct inpcb *
in_pcbhashlookup(struct inpcbtable *table, struct in_addr faddr,
    u_int fport_arg, struct in_addr laddr, u_int lport_arg, u_int rdomain)
{
	struct inpcbhead *head;
	struct inpcb *inp;
	u_int16_t fport = fport_arg, lport = lport_arg;

	rdomain = rtable_l2(rdomain);	/* convert passed rtableid to rdomain */
	head = INPCBHASH(table, &faddr, fport, &laddr, lport, rdomain);
	LIST_FOREACH(inp, head, inp_hash) {
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			continue;	/*XXX*/
#endif
		if (inp->inp_faddr.s_addr == faddr.s_addr &&
		    inp->inp_fport == fport && inp->inp_lport == lport &&
		    inp->inp_laddr.s_addr == laddr.s_addr &&
		    rtable_l2(inp->inp_rtableid) == rdomain) {
			/*
			 * Move this PCB to the head of hash chain so that
			 * repeated accesses are quicker.  This is analogous to
			 * the historic single-entry PCB cache.
			 */
			if (inp != LIST_FIRST(head)) {
				LIST_REMOVE(inp, inp_hash);
				LIST_INSERT_HEAD(head, inp, inp_hash);
			}
			break;
		}
	}
#ifdef DIAGNOSTIC
	if (inp == NULL && in_pcbnotifymiss) {
		printf("in_pcbhashlookup: faddr=%08x fport=%d laddr=%08x lport=%d rdom=%d\n",
		    ntohl(faddr.s_addr), ntohs(fport),
		    ntohl(laddr.s_addr), ntohs(lport), rdomain);
	}
#endif
	return (inp);
}

#ifdef INET6
struct inpcb *
in6_pcbhashlookup(struct inpcbtable *table, const struct in6_addr *faddr,
    u_int fport_arg, const struct in6_addr *laddr, u_int lport_arg,
    u_int rtable)
{
	struct inpcbhead *head;
	struct inpcb *inp;
	u_int16_t fport = fport_arg, lport = lport_arg;

	rtable = rtable_l2(rtable);	/* convert passed rtableid to rdomain */
	head = IN6PCBHASH(table, faddr, fport, laddr, lport, rtable);
	LIST_FOREACH(inp, head, inp_hash) {
		if (!(inp->inp_flags & INP_IPV6))
			continue;
		if (IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6, faddr) &&
		    inp->inp_fport == fport && inp->inp_lport == lport &&
		    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, laddr) &&
		    rtable_l2(inp->inp_rtableid) == rtable) {
			/*
			 * Move this PCB to the head of hash chain so that
			 * repeated accesses are quicker.  This is analogous to
			 * the historic single-entry PCB cache.
			 */
			if (inp != LIST_FIRST(head)) {
				LIST_REMOVE(inp, inp_hash);
				LIST_INSERT_HEAD(head, inp, inp_hash);
			}
			break;
		}
	}
#ifdef DIAGNOSTIC
	if (inp == NULL && in_pcbnotifymiss) {
		printf("in6_pcbhashlookup: faddr=");
		printf(" fport=%d laddr=", ntohs(fport));
		printf(" lport=%d\n", ntohs(lport));
	}
#endif
	return (inp);
}
#endif /* INET6 */

/*
 * The in(6)_pcblookup_listen functions are used to locate listening
 * sockets quickly.  This are sockets with unspecified foreign address
 * and port:
 *		*.*     <-> laddr.lport
 *		*.*     <->     *.lport
 */
struct inpcb *
in_pcblookup_listen(struct inpcbtable *table, struct in_addr laddr,
    u_int lport_arg, int reverse, struct mbuf *m, u_int rdomain)
{
	struct inpcbhead *head;
	struct in_addr *key1, *key2;
	struct inpcb *inp;
	u_int16_t lport = lport_arg;

	rdomain = rtable_l2(rdomain);	/* convert passed rtableid to rdomain */
#if NPF > 0
	if (m && m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) {
		struct pf_divert *divert;

		if ((divert = pf_find_divert(m)) == NULL)
			return (NULL);
		key1 = key2 = &divert->addr.v4;
		lport = divert->port;
	} else
#endif
	if (reverse) {
		key1 = &zeroin_addr;
		key2 = &laddr;
	} else {
		key1 = &laddr;
		key2 = &zeroin_addr;
	}

	head = INPCBHASH(table, &zeroin_addr, 0, key1, lport, rdomain);
	LIST_FOREACH(inp, head, inp_hash) {
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			continue;	/*XXX*/
#endif
		if (inp->inp_lport == lport && inp->inp_fport == 0 &&
		    inp->inp_laddr.s_addr == key1->s_addr &&
		    inp->inp_faddr.s_addr == INADDR_ANY &&
		    rtable_l2(inp->inp_rtableid) == rdomain)
			break;
	}
	if (inp == NULL && key1->s_addr != key2->s_addr) {
		head = INPCBHASH(table, &zeroin_addr, 0, key2, lport, rdomain);
		LIST_FOREACH(inp, head, inp_hash) {
#ifdef INET6
			if (inp->inp_flags & INP_IPV6)
				continue;	/*XXX*/
#endif
			if (inp->inp_lport == lport && inp->inp_fport == 0 &&
			    inp->inp_laddr.s_addr == key2->s_addr &&
			    inp->inp_faddr.s_addr == INADDR_ANY &&
			    rtable_l2(inp->inp_rtableid) == rdomain)
				break;
		}
	}
#ifdef DIAGNOSTIC
	if (inp == NULL && in_pcbnotifymiss) {
		printf("in_pcblookup_listen: laddr=%08x lport=%d\n",
		    ntohl(laddr.s_addr), ntohs(lport));
	}
#endif
	/*
	 * Move this PCB to the head of hash chain so that
	 * repeated accesses are quicker.  This is analogous to
	 * the historic single-entry PCB cache.
	 */
	if (inp != NULL && inp != LIST_FIRST(head)) {
		LIST_REMOVE(inp, inp_hash);
		LIST_INSERT_HEAD(head, inp, inp_hash);
	}
	return (inp);
}

#ifdef INET6
struct inpcb *
in6_pcblookup_listen(struct inpcbtable *table, struct in6_addr *laddr,
    u_int lport_arg, int reverse, struct mbuf *m, u_int rtable)
{
	struct inpcbhead *head;
	struct in6_addr *key1, *key2;
	struct inpcb *inp;
	u_int16_t lport = lport_arg;

	rtable = rtable_l2(rtable);	/* convert passed rtableid to rdomain */
#if NPF > 0
	if (m && m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) {
		struct pf_divert *divert;

		if ((divert = pf_find_divert(m)) == NULL)
			return (NULL);
		key1 = key2 = &divert->addr.v6;
		lport = divert->port;
	} else
#endif
	if (reverse) {
		key1 = &zeroin6_addr;
		key2 = laddr;
	} else {
		key1 = laddr;
		key2 = &zeroin6_addr;
	}

	head = IN6PCBHASH(table, &zeroin6_addr, 0, key1, lport, rtable);
	LIST_FOREACH(inp, head, inp_hash) {
		if (!(inp->inp_flags & INP_IPV6))
			continue;
		if (inp->inp_lport == lport && inp->inp_fport == 0 &&
		    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, key1) &&
		    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6) &&
		    rtable_l2(inp->inp_rtableid) == rtable)
			break;
	}
	if (inp == NULL && ! IN6_ARE_ADDR_EQUAL(key1, key2)) {
		head = IN6PCBHASH(table, &zeroin6_addr, 0, key2, lport, rtable);
		LIST_FOREACH(inp, head, inp_hash) {
			if (!(inp->inp_flags & INP_IPV6))
				continue;
			if (inp->inp_lport == lport && inp->inp_fport == 0 &&
			    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, key2) &&
			    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6) &&
			    rtable_l2(inp->inp_rtableid) == rtable)
				break;
		}
	}
#ifdef DIAGNOSTIC
	if (inp == NULL && in_pcbnotifymiss) {
		printf("in6_pcblookup_listen: laddr= lport=%d\n",
		    ntohs(lport));
	}
#endif
	/*
	 * Move this PCB to the head of hash chain so that
	 * repeated accesses are quicker.  This is analogous to
	 * the historic single-entry PCB cache.
	 */
	if (inp != NULL && inp != LIST_FIRST(head)) {
		LIST_REMOVE(inp, inp_hash);
		LIST_INSERT_HEAD(head, inp, inp_hash);
	}
	return (inp);
}
#endif /* INET6 */
@


1.223
log
@The in_pcbhashlookup() in in_pcbconnect() enforces that the 4 tupel
of src/dst ip/port is unique for TCP.  But if the socket is not
bound, the automatic bind by connect happens after the check.  If
the socket has the SO_REUSEADDR flag, in_pcbbind() may select an
existing local port.  Then we had two colliding TCP PCBs.  This
resulted in a packet storm of ACK packets on loopback.  The softnet
task was constantly holding the netlock and has a high priority,
so the system hung.
Do the in_pcbhashlookup() again after in_pcbbind().  This creates
sporadic "connect: Address already in use" errors instead of a hang.
bug report and testing Olivier Antoine; OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.222 2017/06/09 12:56:43 mpi Exp $	*/
a329 5
			sin6 = mtod(nam, struct sockaddr_in6 *);
			if (nam->m_len != sizeof(struct sockaddr_in6))
				return (EINVAL);
			if (sin6->sin6_family != AF_INET6)
				return (EAFNOSUPPORT);
d331 2
a345 5
			sin = mtod(nam, struct sockaddr_in *);
			if (nam->m_len != sizeof(*sin))
				return (EINVAL);
			if (sin->sin_family != AF_INET)
				return (EAFNOSUPPORT);
d347 2
d508 1
a508 1
	struct sockaddr_in *sin = mtod(nam, struct sockaddr_in *);
d518 2
a519 4
	if (nam->m_len != sizeof(*sin))
		return (EINVAL);
	if (sin->sin_family != AF_INET)
		return (EAFNOSUPPORT);
a521 1

@


1.222
log
@Replace rtrequest(RTM_DELETE...) rtrequest_delete() and do not even
try to remove a route from the table if it is and invalid cache.

This is a step towards decoupling code dealing with userland and kernel
inserted routes.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.221 2017/06/07 13:28:02 mpi Exp $	*/
d536 1
a536 1
	    *ina, inp->inp_lport, inp->inp_rtableid) != 0)
d542 11
a552 3
		if (inp->inp_lport == 0 &&
		    in_pcbbind(inp, NULL, curproc) == EADDRNOTAVAIL)
			return (EADDRNOTAVAIL);
@


1.221
log
@Grab the KERNEL_LOCK() around rtm*() functions.  Routing sockets globals
aren't protected by the NET_LOCK().

While here change lock assertions in rt_{set,put}gwroute(), the NET_LOCK()
is enough.

Tested by Hrvoje Popovski.

ok jmatthew@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.220 2017/03/07 16:59:40 bluhm Exp $	*/
d724 16
a739 3
		if (rt->rt_flags & RTF_DYNAMIC)
			(void)rtrequest(RTM_DELETE, &info, rt->rt_priority,
			    NULL, inp->inp_rtableid);
@


1.220
log
@When the inpcb queue and hash lists are traversed or modified we
need netlock.  Remove the obsolete splnet.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.219 2017/03/07 12:00:31 bluhm Exp $	*/
d719 2
d723 1
@


1.219
log
@Initially in_pcballoc() hooked all new inpcb, including the IPv6
ones, into the IPv4 hash.  They cannot be used before bind(2) anyway
and then they are rehashed and rehooked, so this was not noticed.
Nevertheless put IPv6 PCBs into the IPv6 hash from the beginning.
OK jca@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.218 2017/03/06 08:59:07 mpi Exp $	*/
a251 1
	int s;
d254 1
a254 1
	splsoftassert(IPL_SOFTNET);
a270 1
	s = splnet();
a287 1
	splx(s);
a584 1
	int s;
d586 1
a586 1
	splsoftassert(IPL_SOFTNET);
a608 1
	s = splnet();
a612 1
	splx(s);
d666 1
a666 1
	splsoftassert(IPL_SOFTNET);
a960 1
	int s;
d963 2
a964 1
	s = splnet();
a979 1
	splx(s);
@


1.218
log
@Kill global list of IPv6 addresses.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.217 2017/03/06 08:56:39 mpi Exp $	*/
d279 10
a288 2
	head = INPCBHASH(table, &inp->inp_faddr, inp->inp_fport,
	    &inp->inp_laddr, inp->inp_lport, rtable_l2(inp->inp_rtableid));
@


1.217
log
@Prefix functions dealing with routing messages with 'rtm_' and keep
them all in net/rtsock.c.

This allows to easily spot which functions are doing a copyout(9)
when dealing with the routing midlayer.

ok phessler@@, bluhm@@, dhill@@, krw@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.216 2016/10/06 19:09:08 bluhm Exp $	*/
a318 2
		if (TAILQ_EMPTY(&in6_ifaddr))
			return (EADDRNOTAVAIL);
@


1.216
log
@Remove redundant comments that say a function must be called at
splsoftnet() if the function does a splsoftassert(IPL_SOFTNET)
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.215 2016/09/15 02:00:18 dlg Exp $	*/
d719 1
a719 1
		rt_missmsg(RTM_LOSING, &info, rt->rt_flags, rt->rt_priority,
@


1.215
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.214 2016/09/06 00:04:15 dlg Exp $	*/
a657 2
 *
 * Must be called at splsoftnet.
@


1.214
log
@pool_setipl for various netinet and netinet6 bits

thank you to everyone who helped reviewed these diffs

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.213 2016/08/04 20:46:24 vgross Exp $	*/
d258 2
a259 3
		pool_init(&inpcb_pool, sizeof(struct inpcb), 0, 0, 0,
		    "inpcbpl", NULL);
		pool_setipl(&inpcb_pool, IPL_SOFTNET);
@


1.213
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.212 2016/07/22 11:14:41 mpi Exp $	*/
d260 1
@


1.212
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.210 2016/07/19 14:49:46 mpi Exp $	*/
d528 1
a528 2
	error = in_selectsrc(&ina, sin, inp->inp_moptions, &inp->inp_route,
	    &inp->inp_laddr, inp->inp_rtableid);
d878 2
a879 3
in_selectsrc(struct in_addr **insrc, struct sockaddr_in *sin,
    struct ip_moptions *mopts, struct route *ro, struct in_addr *laddr,
    u_int rtableid)
d881 5
@


1.211
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@d528 2
a529 1
	error = in_pcbselsrc(&ina, sin, inp);
d879 3
a881 2
in_pcbselsrc(struct in_addr **insrc, struct sockaddr_in *sin,
    struct inpcb *inp)
a882 5
	struct ip_moptions *mopts = inp->inp_moptions;
	struct route *ro = &inp->inp_route;
	struct in_addr *laddr = &inp->inp_laddr;
	u_int rtableid = inp->inp_rtableid;

@


1.210
log
@NULLify a route pointer after calling rtfree(9).

This should theoretically be a no-op because we're freeing the PCB
right after, but it helps us debug a reference count problem found
by otto@@.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.209 2016/07/05 09:17:10 mpi Exp $	*/
d528 1
a528 2
	error = in_selectsrc(&ina, sin, inp->inp_moptions, &inp->inp_route,
	    &inp->inp_laddr, inp->inp_rtableid);
d878 2
a879 3
in_selectsrc(struct in_addr **insrc, struct sockaddr_in *sin,
    struct ip_moptions *mopts, struct route *ro, struct in_addr *laddr,
    u_int rtableid)
d881 5
@


1.209
log
@Do not use ``rt_addr'' in in{6,}_selectsrc() it doesn't work with magic
addresses set on p2p interfaces.

Found the hardway by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.208 2016/06/30 12:36:27 mpi Exp $	*/
d590 1
a590 1
	if (inp->inp_route.ro_rt)
d592 2
@


1.208
log
@Use ``rt_addr'' rather than ``rt_ifa'' to get the source address
corresponding to a route.

ok florian@@ on a previous version, input and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.207 2016/06/18 10:36:13 vgross Exp $	*/
d882 1
a903 2
			struct in_ifaddr *ia = NULL;

d944 5
a948 4
	if (ro->ro_rt != NULL) {
		*insrc = &satosin(ro->ro_rt->rt_addr)->sin_addr;
		return (0);
	}
d950 2
a951 1
	return (EADDRNOTAVAIL);
@


1.207
log
@Add net.inet.{tcp,udp}.rootonly sysctl, to mark which ports
cannot be bound to by non-root users.

Ok millert@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.206 2016/04/19 22:16:25 sthen Exp $	*/
a881 1
	struct in_ifaddr *ia = NULL;
d903 2
d945 4
a948 2
	if (ro->ro_rt != NULL)
		ia = ifatoia(ro->ro_rt->rt_ifa);
d950 1
a950 5
	if (ia == NULL)
		return (EADDRNOTAVAIL);

	*insrc = &ia->ia_addr.sin_addr;
	return (0);
@


1.206
log
@Use the correct byte-order when checking against baddynamic ports,
restoring pre-1.190 behaviour. ok millert@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.205 2016/04/13 06:06:04 vgross Exp $	*/
d124 1
d234 15
d366 2
a367 1
		if (ntohs(lport) < IPPORT_RESERVED && (error = suser(p, 0)))
@


1.205
log
@Remove extra parenthesis around comparison.

Found by David Hill <dhill@@mindcry.org> with clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.204 2016/04/12 14:42:54 krw Exp $	*/
d476 1
a476 1
	} while (in_baddynamic(localport, so->so_proto->pr_protocol) ||
@


1.204
log
@Unbreak tree. Put 'laddr6' declaration inside #ifdef INET6/#endif.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.203 2016/04/11 21:39:18 vgross Exp $	*/
d908 1
a908 1
	if ((ro->ro_rt == NULL)) {
@


1.203
log
@Simplify in_pcblookup_local() logic.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.202 2016/04/11 21:24:29 vgross Exp $	*/
d743 1
d745 1
@


1.202
log
@Rename in_pcblookup() to in_pcblookup_local() and change its prototype
to get rid of the now useless foreign address and ports parameters.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.201 2016/04/08 14:34:21 vgross Exp $	*/
a740 1
	u_int16_t fport = 0;
a741 2
	struct in_addr faddr = zeroin_addr;
	struct in6_addr *faddrp = &zeroin6_addr;
d743 1
d755 3
a757 3
		if (flags & INPLOOKUP_IPV6) {
			struct in6_addr *laddr6 = (struct in6_addr *)laddrp;
			struct in6_addr *faddr6 = (struct in6_addr *)faddrp;
d759 2
a760 2
			if (!(inp->inp_flags & INP_IPV6))
				continue;
d762 3
a764 2
			if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)) {
				if (IN6_IS_ADDR_UNSPECIFIED(laddr6))
d766 1
a766 1
				else if (!IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, laddr6))
a767 3
			} else {
				if (!IN6_IS_ADDR_UNSPECIFIED(laddr6))
					wildcard++;
a769 10
			if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6)) {
				if (IN6_IS_ADDR_UNSPECIFIED(faddr6))
					wildcard++;
				else if (!IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6,
				    faddr6) || inp->inp_fport != fport)
					continue;
			} else {
				if (!IN6_IS_ADDR_UNSPECIFIED(faddr6))
					wildcard++;
			}
d774 1
a774 1
			if (inp->inp_flags & INP_IPV6)
d778 6
a783 2
			if (inp->inp_faddr.s_addr != INADDR_ANY) {
				if (faddr.s_addr == INADDR_ANY)
d785 1
a785 2
				else if (inp->inp_faddr.s_addr != faddr.s_addr ||
				    inp->inp_fport != fport)
a786 12
			} else {
				if (faddr.s_addr != INADDR_ANY)
					wildcard++;
			}
			if (inp->inp_laddr.s_addr != INADDR_ANY) {
				if (laddr.s_addr == INADDR_ANY)
					wildcard++;
				else if (inp->inp_laddr.s_addr != laddr.s_addr)
					continue;
			} else {
				if (laddr.s_addr != INADDR_ANY)
					wildcard++;
d788 1
@


1.201
log
@We must always check if the socket is already bound, and always set
INPLOOKUP_IPV6 when applicable. Bug introduced in revision 1.197 by
yours truly.

Ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.200 2016/04/05 21:21:41 vgross Exp $	*/
d418 2
a419 3
			t = in_pcblookup(table, &zeroin_addr, 0,
			    &sin->sin_addr, lport, INPLOOKUP_WILDCARD,
			    inp->inp_rtableid);
d423 2
a424 2
		t = in_pcblookup(table, &zeroin_addr, 0,
		    &sin->sin_addr, lport, wild, inp->inp_rtableid);
d477 2
a478 2
	    in_pcblookup(table, &zeroin46_addr, 0,
	    laddr, localport, wild, inp->inp_rtableid));
d736 2
a737 2
in_pcblookup(struct inpcbtable *table, void *faddrp, u_int fport_arg,
    void *laddrp, u_int lport_arg, int flags, u_int rdomain)
d741 4
a744 2
	u_int16_t fport = fport_arg, lport = lport_arg;
	struct in_addr faddr = *(struct in_addr *)faddrp;
@


1.200
log
@Move reserved port checks from in(6)_pcbaddrisavail() to in_pcbbind().
Kill old comments while at it.

Ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.199 2016/04/05 19:34:05 vgross Exp $	*/
d300 1
a300 2
	if (nam) {
		switch (sotopf(so)) {
d302 8
a309 1
		case PF_INET6: {
a310 5
			if (TAILQ_EMPTY(&in6_ifaddr))
				return (EADDRNOTAVAIL);
			if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
				return (EINVAL);

a316 1
			wild |= INPLOOKUP_IPV6;
a320 1
			break;
d322 1
d324 5
a328 1
		case PF_INET: {
a329 3
			if (inp->inp_laddr.s_addr != INADDR_ANY)
				return (EINVAL);

a339 4
			break;
		}
		default:
			return (EINVAL);
d341 3
@


1.199
log
@Move inp_laddr assignment after in_pcbpickport(), extend in_pcbpickport()
as needed.

Ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.198 2016/03/26 21:56:04 mpi Exp $	*/
d346 1
a346 1
	if (lport == 0)
d349 4
a377 1
	int error;
a416 4
		/* GROSS */
		if (ntohs(lport) < IPPORT_RESERVED &&
		    (error = suser(p, 0)))
			return (EACCES);
@


1.198
log
@Always include the route priority in routing messages.

From Florian Riehm, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.197 2016/03/23 15:50:36 vgross Exp $	*/
d289 1
d316 1
d319 1
a319 1
			inp->inp_laddr6 = sin6->sin6_addr;
d337 1
a337 1
			inp->inp_laddr = sin->sin_addr;
d347 1
a347 1
		if ((error = in_pcbpickport(&lport, wild, inp, p)))
d349 12
d435 2
a436 1
in_pcbpickport(u_int16_t *lport, int wild, struct inpcb *inp, struct proc *p)
a440 1
	void *laddr;
a469 4
	if (sotopf(so) == PF_INET6)
		laddr = &inp->inp_laddr6;
	else
		laddr = &inp->inp_laddr;
@


1.197
log
@Merge in_pcbbind() and in6_pcbbind(), and change every call to
in6_pcbbind() into in_pcbbind().

Ok jca@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.196 2016/03/23 00:07:31 vgross Exp $	*/
d695 2
a696 2
		rt_missmsg(RTM_LOSING, &info, rt->rt_flags, rt->rt_ifidx, 0,
		    inp->inp_rtableid);
@


1.196
log
@Extract in_pcbaddrisavail() from in_pcbbind().

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.195 2015/12/18 22:25:16 vgross Exp $	*/
a286 1
	struct sockaddr_in *sin;
d291 2
a292 4
#ifdef INET6
	if (sotopf(so) == PF_INET6)
		return in6_pcbbind(inp, nam, p);
#endif /* INET6 */
a293 2
	if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
		return (EINVAL);
d298 1
d300 40
a339 2
		sin = mtod(nam, struct sockaddr_in *);
		if (nam->m_len != sizeof(*sin))
d341 1
a341 9

		if (sin->sin_family != AF_INET)
			return (EAFNOSUPPORT);

		lport = sin->sin_port;

		if ((error = in_pcbaddrisavail(inp, sin, wild, p)))
			return (error);
		inp->inp_laddr = sin->sin_addr;
@


1.195
log
@Fix SO_REUSE* flags effects when binding multicast addresses. No
regression observed on avahi.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.194 2015/12/03 21:57:59 mpi Exp $	*/
a286 1
	struct inpcbtable *table = inp->inp_table;
d289 1
a289 1
	int wild = 0, reuseport = (so->so_options & SO_REUSEPORT);
d312 51
a362 13
		if (IN_MULTICAST(sin->sin_addr.s_addr)) {
			/*
			 * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
			 * allow complete duplication of binding if
			 * SO_REUSEPORT is set, or if SO_REUSEADDR is set
			 * and a multicast address is bound on both
			 * new and duplicated sockets.
			 */
			if (so->so_options & (SO_REUSEADDR|SO_REUSEPORT))
				reuseport = SO_REUSEADDR|SO_REUSEPORT;
		} else if (sin->sin_addr.s_addr != INADDR_ANY) {
			sin->sin_port = 0;		/* yech... */
			/* ... must also clear the zeropad in the sockaddr */
d364 2
d367 2
a368 15
			if (!((so->so_options & SO_BINDANY) ||
			    (sin->sin_addr.s_addr == INADDR_BROADCAST &&
			     so->so_type == SOCK_DGRAM))) {
				struct in_ifaddr *ia;

				ia = ifatoia(ifa_ifwithaddr(sintosa(sin),
				    inp->inp_rtableid));

				/* SOCK_RAW does not use in_pcbbind() */
				if (ia == NULL &&
				    (so->so_type != SOCK_DGRAM ||
				    !in_broadcast(sin->sin_addr,
					inp->inp_rtableid)))
						return (EADDRNOTAVAIL);
			}
d370 3
a372 2
		if (lport) {
			struct inpcb *t;
d374 5
a378 12
			/* GROSS */
			if (ntohs(lport) < IPPORT_RESERVED &&
			    (error = suser(p, 0)))
				return (EACCES);
			if (so->so_euid) {
				t = in_pcblookup(table, &zeroin_addr, 0,
				    &sin->sin_addr, lport, INPLOOKUP_WILDCARD,
				    inp->inp_rtableid);
				if (t &&
				    (so->so_euid != t->inp_socket->so_euid))
					return (EADDRINUSE);
			}
d380 3
a382 2
			    &sin->sin_addr, lport, wild, inp->inp_rtableid);
			if (t && (reuseport & t->inp_socket->so_options) == 0)
d385 4
a388 1
		inp->inp_laddr = sin->sin_addr;
a390 5
	if (lport == 0)
		if ((error = in_pcbpickport(&lport, wild, inp, p)))
			return (error);
	inp->inp_lport = lport;
	in_pcbrehash(inp);
@


1.194
log
@Get rid of rt_mask() and stop allocating a "struct sockaddr" for every
route entry in ART.

rt_plen() now represents the prefix length of a route entry and should
be used instead.

For now use a "struct sockaddr_in6" to represent the mask when needed,
this should be then replaced by the prefix length and RTA_NETMASK only
used for compatibility with userland.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.193 2015/12/03 14:55:18 vgross Exp $	*/
d321 1
a321 1
			if (so->so_options & SO_REUSEADDR)
@


1.193
log
@Remove broadcast matching from ifa_ifwithaddr(), use in_broadcast() where
required.

ok bluhm@@ mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.192 2015/12/03 14:05:28 bluhm Exp $	*/
d640 1
d649 1
a649 1
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
@


1.192
log
@To avoid that the stack manipules the pf statekeys directly, introduce
pf_inp_...() lookup, link and unlink functions as an interface.
Locking can be added to them later.  Remove the first linking at
the beginning of tcp_input() and udp_input() as it is not necessary.
It will be done later anyway.  That code was a relict, from the
time before I had added the second linking.
Input from mikeb@@ and sashan@@;  OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.191 2015/12/03 09:49:15 bluhm Exp $	*/
a334 2
				if (ia == NULL)
					return (EADDRNOTAVAIL);
d337 5
a341 4
				if (so->so_type != SOCK_DGRAM &&
				    sin->sin_addr.s_addr !=
				    ia->ia_addr.sin_addr.s_addr)
					return (EADDRNOTAVAIL);
d355 2
a356 1
				if (t && (so->so_euid != t->inp_socket->so_euid))
@


1.191
log
@Rename pf_unlink_state() to pf_remove_state() so the name does not
collide with the statekey to inp unlinking.
OK sashan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.190 2015/12/02 22:13:44 vgross Exp $	*/
d533 1
a533 2
		if (inp->inp_pf_sk)
			inp->inp_pf_sk->inp = NULL;
@


1.190
log
@Move port picking away from in_pcbbind()

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.189 2015/12/02 16:00:42 sashan Exp $	*/
d531 2
a532 2
		pf_unlink_divert_state(inp->inp_pf_sk);
		/* pf_unlink_divert_state() may have detached the state */
@


1.189
log
@- hide PF internals to pf_unlink_divert_state() from in_pcb.c

OK mpi@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.188 2015/10/30 09:39:42 bluhm Exp $	*/
d109 5
a288 1
	u_int16_t lastport = 0;
a365 23
	if (lport == 0) {
		u_int16_t bound_a, bound_b, first, last;
		int count;

		if (inp->inp_flags & INP_HIGHPORT) {
			bound_a = ipport_hifirstauto;	/* sysctl */
			bound_b = ipport_hilastauto;
		} else if (inp->inp_flags & INP_LOWPORT) {
			if ((error = suser(p, 0)))
				return (EACCES);
			bound_a = IPPORT_RESERVED-1; /* 1023 */
			bound_b = 600;		   /* not IPPORT_RESERVED/2 */
		} else {
			bound_a = ipport_firstauto;	/* sysctl */
			bound_b = ipport_lastauto;
		}
		if (bound_a < bound_b) {
			first = bound_a;
			last  = bound_b;
		} else {
			first = bound_b;
			last  = bound_a;
		}
d367 3
a369 19
		/*
		 * Simple check to ensure all ports are not used up causing
		 * a deadlock here.
		 */

		count = last - first;
		lastport = first + arc4random_uniform(count);

		do {
			if (count-- < 0)	/* completely used? */
				return (EADDRNOTAVAIL);
			++lastport;
			if (lastport < first || lastport > last)
				lastport = first;
			lport = htons(lastport);
		} while (in_baddynamic(lastport, so->so_proto->pr_protocol) ||
		    in_pcblookup(table, &zeroin_addr, 0,
		    &inp->inp_laddr, lport, wild, inp->inp_rtableid));
	}
d372 56
@


1.188
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.187 2015/10/25 10:05:09 bluhm Exp $	*/
d510 2
a511 11
		struct pf_state_key	*sk;
		struct pf_state_item	*si;

		sk = inp->inp_pf_sk;
		TAILQ_FOREACH(si, &sk->states, entry)
			if (sk == si->s->key[PF_SK_STACK] && si->s->rule.ptr &&
			    si->s->rule.ptr->divert.port) {
				pf_unlink_state(si->s);
				break;
			}
		/* pf_unlink_state() may have detached the state */
@


1.187
log
@Instead of doing the the if_get() dance for rt_missmsg(), change the
function to take an interface index.
discussed with mpi@@;  OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.186 2015/10/23 13:26:07 mpi Exp $	*/
d641 1
a641 1
			(void)rtrequest1(RTM_DELETE, &info, rt->rt_priority,
@


1.186
log
@``rt_ifp'' cannot be NULL.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.185 2015/10/20 18:04:03 deraadt Exp $	*/
d638 1
a638 1
		rt_missmsg(RTM_LOSING, &info, rt->rt_flags, rt->rt_ifp, 0,
@


1.185
log
@At guenther's suggestion replace dnssocket() with a SOCK_DNS flag on
socket().  Without pledge, all other socket behaviours become permitted,
except this one case: connect/send* only works to *:53.  In pledge mode,
a very few are further restricted.  Some backwards compatibility for
the dnssocket/dnsconnect calls will remain in the tree temporarily so
that people can build through the transition.
ok tedu guenther semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.184 2015/10/19 12:10:05 mpi Exp $	*/
d861 1
a861 1
	if ((ro->ro_rt == NULL || ro->ro_rt->rt_ifp == NULL)) {
d880 1
a880 1
	if (ro->ro_rt && ro->ro_rt->rt_ifp)
@


1.184
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add a missing ``rtableid'' check in in_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.183 2015/10/19 08:49:13 vgross Exp $	*/
a420 1
	struct proc *p = curproc;
a435 3

	if (pledge_dns_check(p, sin->sin_port))
		return (pledge_fail(p, EPERM, PLEDGE_DNS));
@


1.183
log
@deduplicate in[6]_pcbbind() port scan loop.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.182 2015/10/18 00:04:43 deraadt Exp $	*/
d767 1
a767 1
	if (ro->ro_rt && (ro->ro_rt->rt_flags & RTF_UP) == 0) {
d860 2
a861 2
	if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
	    (satosin(&ro->ro_dst)->sin_addr.s_addr != sin->sin_addr.s_addr))) {
@


1.182
log
@Add two new system calls: dnssocket() and dnsconnect().  This creates a
SS_DNS tagged socket which has limited functionality (for example, you
cannot accept on them...)  The libc resolver will switch to using these,
therefore pledge can identify a DNS transaction better.
ok tedu guenther kettenis beck and others
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.181 2015/10/09 01:10:27 deraadt Exp $	*/
d363 1
a363 1
		u_int16_t first, last;
d367 2
a368 2
			first = ipport_hifirstauto;	/* sysctl */
			last = ipport_hilastauto;
d372 2
a373 2
			first = IPPORT_RESERVED-1; /* 1023 */
			last = 600;		   /* not IPPORT_RESERVED/2 */
d375 9
a383 2
			first = ipport_firstauto;	/* sysctl */
			last  = ipport_lastauto;
a388 3
		 *
		 * We split the two cases (up and down) so that the direction
		 * is not being tested on each round of the loop.
d391 2
a392 7
		if (first > last) {
			/*
			 * counting down
			 */
			count = first - last;
			if (count)
				lastport = first - arc4random_uniform(count);
d394 10
a403 29
			do {
				if (count-- < 0)	/* completely used? */
					return (EADDRNOTAVAIL);
				--lastport;
				if (lastport > first || lastport < last)
					lastport = first;
				lport = htons(lastport);
			} while (in_baddynamic(lastport, so->so_proto->pr_protocol) ||
			    in_pcblookup(table, &zeroin_addr, 0,
			    &inp->inp_laddr, lport, wild, inp->inp_rtableid));
		} else {
			/*
			 * counting up
			 */
			count = last - first;
			if (count)
				lastport = first + arc4random_uniform(count);

			do {
				if (count-- < 0)	/* completely used? */
					return (EADDRNOTAVAIL);
				++lastport;
				if (lastport < first || lastport > last)
					lastport = first;
				lport = htons(lastport);
			} while (in_baddynamic(lastport, so->so_proto->pr_protocol) ||
			    in_pcblookup(table, &zeroin_addr, 0,
			    &inp->inp_laddr, lport, wild, inp->inp_rtableid));
		}
@


1.181
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.180 2015/09/22 09:34:38 vgross Exp $	*/
d459 1
a459 1
		return (pledge_fail(p, EPERM, PLEDGE_DNSPATH));
@


1.180
log
@Remove inpt_lastport from struct inpcbtable, use local variables
in in_pcbbind() and in6_pcbsetport()

ok claudio@@, with input from David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.179 2015/09/11 15:29:47 deraadt Exp $	*/
d80 1
a80 1
#include <sys/tame.h>
d458 2
a459 2
	if (tame_dns_check(p, sin->sin_port))
		return (tame_fail(p, EPERM, TAME_DNSPATH));
@


1.179
log
@Convert _TM_ flags to TAME_ flags, collapsing the entire mapping
layer because the strings select the right options.  Mechanical
conversion.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.178 2015/09/11 13:59:27 vgross Exp $	*/
a201 1
	table->inpt_lastport = 0;
a282 1
	u_int16_t *lastport = &inp->inp_table->inpt_lastport;
d284 1
d393 1
a393 1
				*lastport = first - arc4random_uniform(count);
d398 5
a402 5
				--*lastport;
				if (*lastport > first || *lastport < last)
					*lastport = first;
				lport = htons(*lastport);
			} while (in_baddynamic(*lastport, so->so_proto->pr_protocol) ||
d411 1
a411 1
				*lastport = first + arc4random_uniform(count);
d416 5
a420 5
				++*lastport;
				if (*lastport < first || *lastport > last)
					*lastport = first;
				lport = htons(*lastport);
			} while (in_baddynamic(*lastport, so->so_proto->pr_protocol) ||
@


1.178
log
@Stricter checks on sockaddr content when binding PF_INET sockets.

Ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.177 2015/09/11 08:22:31 guenther Exp $	*/
d460 1
a460 1
		return (tame_fail(p, EPERM, TAME_DNS));
@


1.177
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.176 2015/09/09 20:14:40 dlg Exp $	*/
d305 1
a305 5
#ifdef notdef
		/*
		 * We should check the family, but old programs
		 * incorrectly fail to initialize it.
		 */
d308 1
a308 1
#endif
@


1.176
log
@if_put after you if_get

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.175 2015/09/01 21:24:04 bluhm Exp $	*/
d80 1
@


1.175
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.174 2015/08/22 20:18:50 deraadt Exp $	*/
d870 2
a871 1
			if (ia == NULL)
d873 1
d876 1
@


1.174
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.173 2015/08/19 13:27:38 bluhm Exp $	*/
d898 1
a898 1
		sin2 = (struct sockaddr_in *)&ro->ro_dst;
@


1.173
log
@Convert all calls to rtrequest1() and the following error check
into a common pattern.  In the man page clarify the usage of the
returned route.
OK mpi@@ mikeb@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.172 2015/07/19 02:35:35 deraadt Exp $	*/
a81 1
#include <sys/tame.h>
@


1.172
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.171 2015/07/15 22:16:42 deraadt Exp $	*/
d671 1
a671 1
				(struct rtentry **)0, inp->inp_rtableid);
@


1.171
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.170 2015/04/16 19:24:13 markus Exp $	*/
d82 1
d446 1
d462 3
@


1.170
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.169 2015/04/14 12:22:15 mikeb Exp $	*/
d522 1
a522 2
	if (inp->inp_options)
		m_freem(inp->inp_options);
@


1.169
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.168 2015/02/10 03:07:56 claudio Exp $	*/
a532 11
#ifdef IPSEC
	/* IPsec cleanup here */
	if (inp->inp_tdb_in)
		TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in,
			     inp, inp_tdb_in_next);
	if (inp->inp_tdb_out)
		TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out, inp,
			     inp_tdb_out_next);
	if (inp->inp_ipo)
		ipsec_delete_policy(inp->inp_ipo);
#endif
@


1.168
log
@bzero -> memset and unify sizeof() usage (no space).
Requested by reyk@@, dlg@@ and OK mpi@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.167 2015/02/10 01:36:59 claudio Exp $	*/
a540 4
	if (inp->inp_ipsec_remotecred)
		ipsp_reffree(inp->inp_ipsec_remotecred);
	if (inp->inp_ipsec_remoteauth)
		ipsp_reffree(inp->inp_ipsec_remoteauth);
@


1.167
log
@Nuke sin_zero before passing it on down into the ifa_ifwithaddr() that
way garbage in the pad bytes does not perturb the outcome.
This fixes regress/sys/kern/bind.
OK mpi@@, phessler@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.166 2015/01/24 00:29:06 deraadt Exp $	*/
d302 1
a302 1
		if (nam->m_len != sizeof (*sin))
d326 1
a326 1
			bzero(sin->sin_zero, sizeof(sin->sin_zero));
d454 1
a454 1
	if (nam->m_len != sizeof (*sin))
d579 1
a579 1
	nam->m_len = sizeof (*sin);
d581 1
a581 1
	bzero((caddr_t)sin, sizeof (*sin));
d600 1
a600 1
	nam->m_len = sizeof (*sin);
d602 1
a602 1
	bzero((caddr_t)sin, sizeof (*sin));
d673 1
a673 1
		bzero((caddr_t)&info, sizeof(info));
d813 1
a813 1
		bzero(ro, sizeof(struct route_in6));
d815 1
a815 1
		bzero(ro, sizeof(struct route));
d907 1
a907 1
		 * It is important to bzero out the rest of the
d911 1
a911 1
		bzero(sin2->sin_zero, sizeof(sin2->sin_zero));
@


1.166
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.165 2014/12/17 09:45:59 mpi Exp $	*/
d325 3
@


1.165
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.164 2014/12/05 15:50:04 mpi Exp $	*/
a85 1
#include <net/pfvar.h>
d92 2
@


1.164
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.163 2014/11/18 02:37:31 tedu Exp $	*/
d874 1
a874 1
		ifp = mopts->imo_multicast_ifp;
@


1.163
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.162 2014/11/15 10:55:47 dlg Exp $	*/
d84 1
@


1.162
log
@use siphash in the in_pcb hashing. this mitigates it against flooding
attacks.

this is a textbook use of siphash.

the idea of using siphash for this came from yasuoka-san, but i had
the time to do it. he also tested and tweaked this diff.

ok yasuoka@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.161 2014/10/28 11:02:38 yasuoka Exp $	*/
a91 1
#include <dev/rndvar.h>
@


1.161
log
@Select a proper source address when the bound address is
INADDR_BROADCAST the same as INADDR_ANY.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.160 2014/10/14 09:52:26 mpi Exp $	*/
d124 24
d149 19
a167 2
	&(table)->inpt_hashtbl[(ntohl((faddr)->s_addr) + \
	ntohs((fport)) + ntohs((lport)) + (rdom)) & (table->inpt_hash)]
d170 7
a176 3
	&(table)->inpt_hashtbl[(ntohl((faddr)->s6_addr32[0] ^ \
	(faddr)->s6_addr32[3]) + ntohs((fport)) + ntohs((lport)) + (rdom)) & \
	(table->inpt_hash)]
d178 8
a185 2
#define	INPCBLHASH(table, lport, rdom) \
	&(table)->inpt_lhashtbl[(ntohs((lport)) + (rdom)) & table->inpt_lhash]
d202 1
d231 1
d255 5
a259 5
	LIST_INSERT_HEAD(INPCBLHASH(table, inp->inp_lport,
	    inp->inp_rtableid), inp, inp_lhash);
	LIST_INSERT_HEAD(INPCBHASH(table, &inp->inp_faddr, inp->inp_fport,
	    &inp->inp_laddr, inp->inp_lport, rtable_l2(inp->inp_rtableid)),
	    inp, inp_hash);
d715 1
d718 2
a719 1
	LIST_FOREACH(inp, INPCBLHASH(table, lport, rdomain), inp_lhash) {
d928 1
d932 2
a933 2
	LIST_INSERT_HEAD(INPCBLHASH(table, inp->inp_lport, inp->inp_rtableid),
	    inp, inp_lhash);
d936 10
a945 12
	if (inp->inp_flags & INP_IPV6) {
		LIST_INSERT_HEAD(IN6PCBHASH(table, &inp->inp_faddr6,
		    inp->inp_fport, &inp->inp_laddr6, inp->inp_lport,
		    rtable_l2(inp->inp_rtableid)), inp, inp_hash);
	} else {
#endif /* INET6 */
		LIST_INSERT_HEAD(INPCBHASH(table, &inp->inp_faddr,
		    inp->inp_fport, &inp->inp_laddr, inp->inp_lport,
		    rtable_l2(inp->inp_rtableid)), inp, inp_hash);
#ifdef INET6
	}
#endif /* INET6 */
d972 1
@


1.160
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.159 2014/09/27 12:26:16 mpi Exp $	*/
d802 2
a803 2
	 * If the source address is not specified but the socket(if any)
	 * is already bound, use the bound address.
d805 2
a806 1
	if (laddr && laddr->s_addr != INADDR_ANY) {
@


1.159
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.158 2014/07/22 11:06:10 mpi Exp $	*/
d745 1
a745 1
		RTFREE(ro->ro_rt);
d835 1
a835 1
		RTFREE(ro->ro_rt);
@


1.158
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.157 2014/07/12 21:06:34 yasuoka Exp $	*/
d615 1
d768 2
a769 1
			rtalloc_mpath(ro, &inp->inp_laddr6.s6_addr32[0]);
d779 2
a780 1
			rtalloc_mpath(ro, &inp->inp_laddr.s_addr);
d844 1
a844 1
		rtalloc_mpath(ro, NULL);
@


1.157
log
@Resize the pcb hashtable automatically.  The table size will be doubled
when the number of the hash entries reaches 75% of the table size.

ok dlg henning, 'commit in' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.156 2014/06/04 13:45:47 mpi Exp $	*/
a87 1
#include <netinet/in_systm.h>
@


1.156
log
@Only use ifa_ifwithaddr() to check if the binding address is on the
system.

Yes, this is ugly for the moment because OpenBSD prevents you from
binding a tcp socket to broadcast address and checking for a broadcast
address is... funny!  If you've ever wondered why would lead people to
write:

ina.s_addr != ia->ia_addr.sin_addr.s_addr

instead of:

ina.s_addr == ia->ia_broadaddr.sin_addr.s_addr

Well this is because all the IPv4 addresses belonging to your lo(4)
interfaces match the second idiom.  Hopefully we'll get rid of this
hack soon.

ok jca@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.155 2014/05/07 08:26:38 mpi Exp $	*/
d121 4
d151 1
d199 3
d513 1
d890 33
@


1.155
log
@Remove the last hacks concerning the global list of IPv4 addresses in the
source address selection logic.

These hacks were only relevant for the NFS diskless boot code in order to
pick the local broadcast address of the only configured interface.  So, be
explicit and set this address directly.

Tested by florian@@, ok henning@@, beck@@, chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.154 2014/04/18 10:48:29 jca Exp $	*/
d264 10
a273 3
			if (!(so->so_options & SO_BINDANY) &&
			    in_iawithaddr(sin->sin_addr,
			    inp->inp_rtableid) == NULL)
d275 3
a277 3
				if (!(so->so_type == SOCK_DGRAM &&
				    in_broadcast(sin->sin_addr, NULL,
				    inp->inp_rtableid)))
d279 1
@


1.154
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.153 2014/04/16 13:04:38 mpi Exp $	*/
a232 2
	if (TAILQ_EMPTY(&in_ifaddr))
		return (EADDRNOTAVAIL);
a781 11
	if (!TAILQ_EMPTY(&in_ifaddr)) {
		if (sin->sin_addr.s_addr == INADDR_ANY)
			sin->sin_addr =
			    TAILQ_FIRST(&in_ifaddr)->ia_addr.sin_addr;
		else if (sin->sin_addr.s_addr == INADDR_BROADCAST &&
		  (TAILQ_FIRST(&in_ifaddr)->ia_ifp->if_flags & IFF_BROADCAST) &&
		  TAILQ_FIRST(&in_ifaddr)->ia_broadaddr.sin_addr.s_addr)
			sin->sin_addr =
			    TAILQ_FIRST(&in_ifaddr)->ia_broadaddr.sin_addr;
	}

d840 3
a842 5
	if (ia == NULL) {
		ia = TAILQ_FIRST(&in_ifaddr);
		if (ia == NULL)
			return (EADDRNOTAVAIL);
	}
@


1.153
log
@Merge in_fixaddr() into in_selectsrc() in order to prepare for
IP_SENDSRCADDR support.  This reduces the differences with the
IPv6 version and kill some comments that are no longer true.

ok jca@@, chrisz@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.152 2014/04/07 10:04:17 mpi Exp $	*/
d391 3
a393 5
	ina = in_selectsrc(sin, inp->inp_moptions, &inp->inp_route,
	    &inp->inp_laddr, &error, inp->inp_rtableid);
	if (ina == NULL) {
		if (error == 0)
			error = EADDRNOTAVAIL;
a394 1
	}
d776 4
a779 3
struct in_addr *
in_selectsrc(struct sockaddr_in *sin, struct ip_moptions *mopts,
    struct route *ro, struct in_addr *laddr, int *errorp, u_int rtableid)
d799 4
a802 2
	if (laddr && laddr->s_addr != INADDR_ANY)
		return (laddr);
d816 2
d819 2
a820 5
			if (ia == NULL) {
				*errorp = EADDRNOTAVAIL;
				return (NULL);
			}
			return (&ia->ia_addr.sin_addr);
d853 1
a853 1
	if (ia == 0) {
d855 2
a856 4
		if (ia == 0) {
			*errorp = EADDRNOTAVAIL;
			return (NULL);
		}
d859 2
a860 1
	return (&ia->ia_addr.sin_addr);
@


1.152
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.148 2014/03/27 13:27:28 mpi Exp $	*/
d373 1
a374 1
	struct in_addr laddr;
d386 4
d391 5
a395 1
	if ((error = in_fixaddr(inp, sin, &laddr)))
d397 1
d400 1
a400 1
	    laddr, inp->inp_lport, inp->inp_rtableid) != 0)
d402 3
a404 1
	KASSERT(inp->inp_laddr.s_addr == INADDR_ANY || inp->inp_lport != 0);
d409 1
a409 1
		inp->inp_laddr = laddr;
d773 9
a781 3
struct sockaddr_in *
in_selectsrc(struct sockaddr_in *sin, struct route *ro, int soopts,
    struct ip_moptions *mopts, int *errorp, u_int rtableid)
d786 18
d819 1
a819 1
				return NULL;
d821 1
a821 1
			return (&ia->ia_addr);
a860 52
	return (&ia->ia_addr);
}

/*
 * Fix up source (*laddr) and destination addresses (*sin).
 *
 * If the destination address is INADDR_ANY, use the primary local address.
 * If the supplied address is INADDR_BROADCAST
 * and the primary interface supports broadcast,
 * choose the broadcast address for that interface.
 *
 * If *inp is already bound to a local address, return it in *laddr,
 * otherwise call in_selectsrc() to get a suitable local address.
 */
int
in_fixaddr(struct inpcb *inp,
    struct sockaddr_in *sin, struct in_addr *laddr)
{
	if (sin->sin_family != AF_INET)
		return (EAFNOSUPPORT);
	if (sin->sin_port == 0)
		return (EADDRNOTAVAIL);
	if (!TAILQ_EMPTY(&in_ifaddr)) {
		if (sin->sin_addr.s_addr == INADDR_ANY)
			sin->sin_addr = TAILQ_FIRST(&in_ifaddr)->ia_addr.sin_addr;
		else if (sin->sin_addr.s_addr == INADDR_BROADCAST &&
		  (TAILQ_FIRST(&in_ifaddr)->ia_ifp->if_flags & IFF_BROADCAST) &&
		  TAILQ_FIRST(&in_ifaddr)->ia_broadaddr.sin_addr.s_addr)
			sin->sin_addr =
			    TAILQ_FIRST(&in_ifaddr)->ia_broadaddr.sin_addr;
	}

	if (laddr != NULL) {
		if (inp->inp_laddr.s_addr != INADDR_ANY) {
			*laddr = inp->inp_laddr;
		}
		else {
			struct sockaddr_in *ifaddr;
			int error;

			ifaddr = in_selectsrc(sin, &inp->inp_route,
					inp->inp_socket->so_options,
					inp->inp_moptions,
					&error, inp->inp_rtableid);
			if (ifaddr == NULL) {
				if (error == 0)
					error = EADDRNOTAVAIL;
				return (error);
			}
			*laddr = ifaddr->sin_addr;
		}
	}
d862 1
a862 1
	return (0);
@


1.151
log
@factor out source and destination address mangling from in_pcbconnect()
for later reuse in udp_output().

"Apart from that OK" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.150 2014/04/06 16:49:40 chrisz Exp $	*/
d793 2
a794 3
	if (ro->ro_rt && (!(ro->ro_rt->rt_flags & RTF_UP) ||
	    (satosin(&ro->ro_dst)->sin_addr.s_addr != sin->sin_addr.s_addr ||
	    soopts & SO_DONTROUTE))) {
d798 1
a798 2
	if ((soopts & SO_DONTROUTE) == 0 && /*XXX*/
	    (ro->ro_rt == NULL || ro->ro_rt->rt_ifp == NULL)) {
d815 1
a815 3
	 * corresponding to the outgoing interface
	 * unless it is the loopback (in case a route
	 * to our address on another net goes to loopback).
d817 1
a817 2
	if (ro->ro_rt && ro->ro_rt->rt_ifp &&
	    !(ro->ro_rt->rt_ifp->if_flags & IFF_LOOPBACK))
d820 1
a820 9
		u_int16_t fport = sin->sin_port;

		sin->sin_port = 0;
		ia = ifatoia(ifa_ifwithdstaddr(sintosa(sin), rtableid));
		if (ia == 0)
			ia = ifatoia(ifa_ifwithnet(sintosa(sin), rtableid));
		sin->sin_port = fport;
		if (ia == 0)
			ia = TAILQ_FIRST(&in_ifaddr);
d823 1
a823 1
			return NULL;
@


1.150
log
@Remove redundant call to in{,6}_pcbbind() from tcp PRU_CONNECT.
Make sure that in_pcbbind() is called from in_pcbconnect() by KASSERTing that
local port == 0 implies an unspecified local address.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.149 2014/03/28 08:33:51 sthen Exp $	*/
a372 1
	struct sockaddr_in *ifaddr = NULL;
d374 2
d386 4
a389 31
	if (sin->sin_family != AF_INET)
		return (EAFNOSUPPORT);
	if (sin->sin_port == 0)
		return (EADDRNOTAVAIL);
	if (!TAILQ_EMPTY(&in_ifaddr)) {
		/*
		 * If the destination address is INADDR_ANY,
		 * use the primary local address.
		 * If the supplied address is INADDR_BROADCAST,
		 * and the primary interface supports broadcast,
		 * choose the broadcast address for that interface.
		 */
		if (sin->sin_addr.s_addr == INADDR_ANY)
			sin->sin_addr = TAILQ_FIRST(&in_ifaddr)->ia_addr.sin_addr;
		else if (sin->sin_addr.s_addr == INADDR_BROADCAST &&
		  (TAILQ_FIRST(&in_ifaddr)->ia_ifp->if_flags & IFF_BROADCAST) &&
		  TAILQ_FIRST(&in_ifaddr)->ia_broadaddr.sin_addr.s_addr)
			sin->sin_addr =
			    TAILQ_FIRST(&in_ifaddr)->ia_broadaddr.sin_addr;
	}
	if (inp->inp_laddr.s_addr == INADDR_ANY) {
		int error;
		ifaddr = in_selectsrc(sin, &inp->inp_route,
			inp->inp_socket->so_options, inp->inp_moptions, &error,
			inp->inp_rtableid);
		if (ifaddr == NULL) {
			if (error == 0)
				error = EADDRNOTAVAIL;
			return error;
		}
	}
d391 1
a391 2
	    inp->inp_laddr.s_addr ? inp->inp_laddr : ifaddr->sin_addr,
	    inp->inp_lport, inp->inp_rtableid) != 0)
d398 1
a398 1
		inp->inp_laddr = ifaddr->sin_addr;
a404 2
		int error; /* This is just ignored */

d406 1
d840 53
@


1.149
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.147 2014/01/18 21:14:46 bluhm Exp $	*/
d420 1
@


1.148
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d820 3
a822 2
	if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
	    (satosin(&ro->ro_dst)->sin_addr.s_addr != sin->sin_addr.s_addr))) {
d826 2
a827 1
	if ((ro->ro_rt == NULL || ro->ro_rt->rt_ifp == NULL)) {
d852 13
a864 2
		*errorp = EADDRNOTAVAIL;
		return (NULL);
@


1.147
log
@There was an awkward behaviour after a connection had been diverted
to a socket.  When the application removed the socket, the pf state
would persist.  A new connection did not hit the divert rule as the
state still grabed the packet.  The solution is to unlink the
associated divert state when the socket gets destroyed.  This is
possible as both are linked together and a divert state without
socket does not make sense.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.146 2013/12/20 02:04:08 krw Exp $	*/
d820 2
a821 3
	if (ro->ro_rt && (!(ro->ro_rt->rt_flags & RTF_UP) ||
	    (satosin(&ro->ro_dst)->sin_addr.s_addr != sin->sin_addr.s_addr ||
	    soopts & SO_DONTROUTE))) {
d825 1
a825 2
	if ((soopts & SO_DONTROUTE) == 0 && /*XXX*/
	    (ro->ro_rt == NULL || ro->ro_rt->rt_ifp == NULL)) {
d850 2
a851 13
		u_int16_t fport = sin->sin_port;

		sin->sin_port = 0;
		ia = ifatoia(ifa_ifwithdstaddr(sintosa(sin), rtableid));
		if (ia == 0)
			ia = ifatoia(ifa_ifwithnet(sintosa(sin), rtableid));
		sin->sin_port = fport;
		if (ia == 0)
			ia = TAILQ_FIRST(&in_ifaddr);
		if (ia == 0) {
			*errorp = EADDRNOTAVAIL;
			return NULL;
		}
@


1.146
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.145 2013/10/23 19:57:49 deraadt Exp $	*/
d498 15
a512 2
	if (inp->inp_pf_sk)
		inp->inp_pf_sk->inp = NULL;
@


1.145
log
@Back when some NRL code was merged into KAME to create the *BSD IPV6
stack (factoid: by a bunch of people in my living room), some compatibility
#define's were created to shim incompatible inpcb access methods. There
was an understanding they would eventually be removed.  Since they are
error prone, and 1999 is a long time ago, now they die.
ok mikeb claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.144 2013/10/20 22:28:58 bluhm Exp $	*/
d137 1
a137 1
	CIRCLEQ_INIT(&table->inpt_queue);
d194 1
a194 1
	CIRCLEQ_INSERT_HEAD(&table->inpt_queue, inp, inp_queue);
d504 1
a504 1
	CIRCLEQ_REMOVE(&inp->inp_table->inpt_queue, inp, inp_queue);
d558 1
a558 1
	struct inpcb *inp, *oinp;
d578 1
a578 2
	for (inp = CIRCLEQ_FIRST(&table->inpt_queue);
	    inp != CIRCLEQ_END(&table->inpt_queue);) {
d580 1
a580 2
		if (inp->inp_flags & INP_IPV6) {
			inp = CIRCLEQ_NEXT(inp, inp_queue);
a581 1
		}
a585 1
			inp = CIRCLEQ_NEXT(inp, inp_queue);
a587 2
		oinp = inp;
		inp = CIRCLEQ_NEXT(inp, inp_queue);
d589 1
a589 1
			(*notify)(oinp, errno);
@


1.144
log
@Make the IPv4 and IPv6 code look similar to allow easy comparison.
While there fix some white space errors.  No functional change.
OK claudio@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.143 2013/10/20 11:03:00 phessler Exp $	*/
d212 1
a212 1
	inp->in6p_cksum = -1;
@


1.143
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.142 2013/10/18 21:27:27 bluhm Exp $	*/
d488 1
a488 1
	        TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out, inp,
d699 2
a700 2
		        if (inp->inp_flags & INP_IPV6)
			        continue;
d918 1
a918 2
		    inp->inp_fport == fport &&
		    inp->inp_lport == lport &&
a1097 1
		    rtable_l2(inp->inp_rtableid) == rtable &&
d1099 2
a1100 1
		    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
d1109 3
a1111 3
		    	    rtable_l2(inp->inp_rtableid) == rtable &&
		    	    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, key2) &&
			    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
@


1.142
log
@In in_pcblookup() convert a hand crafted loop into a LIST_FOREACH
macro.  No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.141 2013/10/17 16:27:43 bluhm Exp $	*/
d125 1
a125 1
#define	IN6PCBHASH(table, faddr, fport, laddr, lport) \
d127 1
a127 1
	(faddr)->s6_addr32[3]) + ntohs((fport)) + ntohs((lport))) & \
d876 2
a877 2
		    inp->inp_fport, &inp->inp_laddr6, inp->inp_lport),
		    inp, inp_hash);
d947 2
a948 1
    u_int fport_arg, const struct in6_addr *laddr, u_int lport_arg)
d954 2
a955 1
	head = IN6PCBHASH(table, faddr, fport, laddr, lport);
d961 2
a962 1
		    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, laddr)) {
d1068 1
a1068 1
    u_int lport_arg, int reverse, struct mbuf *m)
d1075 1
d1094 1
a1094 1
	head = IN6PCBHASH(table, &zeroin6_addr, 0, key1, lport);
d1099 1
d1105 1
a1105 1
		head = IN6PCBHASH(table, &zeroin6_addr, 0, key2, lport);
d1110 1
@


1.141
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.140 2013/09/06 12:12:45 mpi Exp $	*/
d661 1
a661 2
	for (inp = LIST_FIRST(INPCBLHASH(table, lport, rdomain)); inp;
	    inp = LIST_NEXT(inp, inp_lhash)) {
@


1.140
log
@Make use of IFP_TO_IA() instead of rolling our own copy.

ok bluhm@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.139 2013/06/01 13:25:40 bluhm Exp $	*/
d99 1
@


1.139
log
@Remove redundant call to splsoftnet().  There is a
splsoftassert(IPL_SOFTNET) at the start of in_pcbdetach().
From David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.138 2013/05/31 13:15:53 bluhm Exp $	*/
d797 6
a802 7
		if (mopts->imo_multicast_ifp != NULL) {
			ifp = mopts->imo_multicast_ifp;
			TAILQ_FOREACH(ia, &in_ifaddr, ia_list)
				if (ia->ia_ifp == ifp &&
				    rtable_l2(rtableid) == ifp->if_rdomain)
					break;
			if (ia == 0) {
@


1.138
log
@The function rip6_ctlinput() claims that sa6_src is constant to
allow the assingment of &sa6_any.  But rip6_ctlinput() could not
guarantee that as it casted away the const attribute when it passes
the pointer to in6_pcbnotify().  Replace sockaddr with const
sockaddr_in6 in the in6_pcbnotify() parameters.  This reduces the
number of casts.  Also adjust in6_pcbhashlookup() to handle the
const attribute correctly.
Input and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.137 2013/04/09 08:35:38 mpi Exp $	*/
a482 1
	s = splsoftnet();
a494 1
	splx(s);
@


1.137
log
@Remove read-only ipsec variables and directly use defines instead.

ok mikeb@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.136 2013/04/02 18:27:46 bluhm Exp $	*/
d949 2
a950 2
in6_pcbhashlookup(struct inpcbtable *table, struct in6_addr *faddr,
    u_int fport_arg, struct in6_addr *laddr, u_int lport_arg)
@


1.136
log
@Use macros sotoinpcb() and intotcpcb() instead of casts.  Use NULL
instead of 0 for pointers.  No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.135 2013/03/31 11:18:35 bluhm Exp $	*/
a106 5
extern int ipsec_auth_default_level;
extern int ipsec_esp_trans_default_level;
extern int ipsec_esp_network_default_level;
extern int ipsec_ipcomp_default_level;

d187 4
a190 4
	inp->inp_seclevel[SL_AUTH] = ipsec_auth_default_level;
	inp->inp_seclevel[SL_ESP_TRANS] = ipsec_esp_trans_default_level;
	inp->inp_seclevel[SL_ESP_NETWORK] = ipsec_esp_network_default_level;
	inp->inp_seclevel[SL_IPCOMP] = ipsec_ipcomp_default_level;
@


1.135
log
@The call to in_pcballoc() in user request attach was handled in
three different ways.  Use the same code in udp_usrreq() and
rip_usrreq() and rip6_usrreq(). This also fixes a pcb and socket
leak in udp_usrreq() in case soreserve() fails.  Put an splsoftassert()
into in_pcballoc() for safety.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.134 2013/03/29 13:16:14 bluhm Exp $	*/
d660 1
a660 1
	struct inpcb *inp, *match = 0;
@


1.134
log
@Declare struct pf_state_key in the mbuf and in_pcb header files to
avoid ugly casts.
OK krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.133 2013/03/28 12:06:55 mpi Exp $	*/
d179 2
@


1.133
log
@Replace some casts to struct in_ifaddr pointer by ifatoia() or NULL.

ok millert@@, haesbaert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.132 2013/03/28 00:32:11 bluhm Exp $	*/
d503 1
a503 1
		((struct pf_state_key *)inp->inp_pf_sk)->inp = NULL;
@


1.132
log
@Unfortunately the satosin, sintosa, ifatoia, satosin6, sin6tosa,
ifatoia6 macros do not check the source type.  They just cast
anything.  Remove needless casts and do not use those macros if the
source type does not match.  Remove duplicate defines.
No binary change.  OK kettenis@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.131 2013/02/05 19:09:52 bluhm Exp $	*/
d792 1
a792 1
	struct in_ifaddr *ia;
a793 1
	ia = (struct in_ifaddr *)0;
@


1.131
log
@Make the inet6 and inet cases in in_pcbrtentry() look similar.
No functional change.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.130 2013/02/04 15:10:22 millert Exp $	*/
d813 1
a813 1
			return satosin(&ia->ia_addr);
d866 1
a866 1
	return satosin(&ia->ia_addr);
@


1.130
log
@Set sa_len correctly for PF_INET (and be consistent with the PF_INET6
case).  On our platforms, sizeof(struct sockaddr) matches sizeof(struct
sockaddr_in) so this hasn't caused problems but it is still incorrect.
From Anthony Low.  OK martynas@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.129 2013/01/16 00:07:22 bluhm Exp $	*/
d768 1
a768 2
			((struct sockaddr_in6 *) &ro->ro_dst)->sin6_addr =
			    inp->inp_faddr6;
d778 1
a779 1
			satosin(&ro->ro_dst)->sin_addr = inp->inp_faddr;
@


1.129
log
@Pass struct inpcb pointer to in_pcb...() functions instead of void
pointer.  Allows stricter type checking.  No functional change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.128 2012/09/20 10:25:03 blambert Exp $	*/
d778 1
a778 1
			ro->ro_dst.sa_len = sizeof(ro->ro_dst);
@


1.128
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.127 2012/07/12 15:59:17 claudio Exp $	*/
d175 1
a175 1
in_pcballoc(struct socket *so, void *v)
a176 1
	struct inpcbtable *table = v;
d220 1
a220 1
in_pcbbind(void *v, struct mbuf *nam, struct proc *p)
a221 1
	struct inpcb *inp = v;
d373 1
a373 1
in_pcbconnect(void *v, struct mbuf *nam)
a374 1
	struct inpcb *inp = v;
d444 1
a444 1
in_pcbdisconnect(void *v)
a445 2
	struct inpcb *inp = v;

d464 1
a464 1
in_pcbdetach(void *v)
a465 1
	struct inpcb *inp = v;
@


1.127
log
@Be way more careful when accessing a possibly cached route in_selectsrc()
since it may already been gone. Fixes panic seen by stsp@@ when unplugging
a used USB interface. Tested and OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.126 2012/03/06 12:44:17 claudio Exp $	*/
d492 1
a492 1
	s = spltdb();
@


1.126
log
@Check if route is still valid when getting the cached rt entry of a pcb.
While there make sure we do the lookup in the correct routing table.
OK mikeb, henning and phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.125 2012/01/11 17:45:05 bluhm Exp $	*/
d827 3
a829 4
	if (ro->ro_rt &&
	    (satosin(&ro->ro_dst)->sin_addr.s_addr !=
		sin->sin_addr.s_addr ||
	    soopts & SO_DONTROUTE)) {
d831 1
a831 1
		ro->ro_rt = (struct rtentry *)0;
d834 1
a834 2
	    (ro->ro_rt == (struct rtentry *)0 ||
	    ro->ro_rt->rt_ifp == (struct ifnet *)0)) {
d855 2
a856 1
	if (ro->ro_rt && !(ro->ro_rt->rt_ifp->if_flags & IFF_LOOPBACK))
@


1.125
log
@Put an splsoftassert(IPL_SOFTNET) into in_pcbdetach().
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.124 2011/07/06 01:57:37 dlg Exp $	*/
d751 6
d776 1
@


1.124
log
@allow /31s on broadcast interfaces (eg ethernet) to work as per rfc3021.
the issue in our kernel was the broadcast address calculated on the /31
caused a ton of checks for use of broadcast addresses to kick in and
prevent one of the two addresses on the /31 from being used.

this diff basically detects if a /31 has been configured and doesnt
configure a broadcast address for it, which makes the ips usable
for normal traffic.

i wrote this so i could interoperate with "carrier" network gear
better, and sthen wants it so he can conserve address space use.

the further special casing of broadcast address handling was from claudio@@

ok claudio@@ markus@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.123 2011/07/05 21:40:38 dhill Exp $	*/
d474 2
@


1.123
log
@ansify

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.122 2011/07/04 06:54:49 claudio Exp $	*/
d405 4
a408 2
		  (TAILQ_FIRST(&in_ifaddr)->ia_ifp->if_flags & IFF_BROADCAST))
			sin->sin_addr = TAILQ_FIRST(&in_ifaddr)->ia_broadaddr.sin_addr;
@


1.122
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.121 2011/05/29 13:22:53 claudio Exp $	*/
d121 1
d138 1
a138 3
in_pcbinit(table, hashsize)
	struct inpcbtable *table;
	int hashsize;
a152 2
struct baddynamicports baddynamicports;

d175 1
a175 3
in_pcballoc(so, v)
	struct socket *so;
	void *v;
d221 1
a221 4
in_pcbbind(v, nam, p)
	void *v;
	struct mbuf *nam;
	struct proc *p;
d375 1
a375 3
in_pcbconnect(v, nam)
	void *v;
	struct mbuf *nam;
d445 1
a445 2
in_pcbdisconnect(v)
	void *v;
d467 1
a467 2
in_pcbdetach(v)
	void *v;
d516 1
a516 3
in_setsockaddr(inp, nam)
	struct inpcb *inp;
	struct mbuf *nam;
d530 1
a530 3
in_setpeeraddr(inp, nam)
	struct inpcb *inp;
	struct mbuf *nam;
d612 1
a612 2
in_losing(inp)
	struct inpcb *inp;
d644 1
a644 3
in_rtchange(inp, errno)
	struct inpcb *inp;
	int errno;
d741 1
a741 2
in_pcbrtentry(inp)
	struct inpcb *inp;
d867 1
a867 2
in_pcbrehash(inp)
	struct inpcb *inp;
@


1.121
log
@Move the source address selection for multicast destinations that
specify the outgoing interface with a multicast option up. Doing
this before the route lookup allows multicast traffic to work even
when the default 224/4 reject route is installed. Raw IP and IPv6
already had this behaviour.
Based on work by Christiano F. Haesbaert. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.120 2011/05/13 14:31:16 oga Exp $	*/
d1028 1
a1028 1
		/* XXX rdomain */
d1031 1
a1031 1
		key1 = key2 = &divert->addr.ipv4;
d1103 1
a1103 1
		key1 = key2 = &divert->addr.ipv6;
@


1.120
log
@Revert the pf->socket linking diff.

at least krw@@, pirofti@@ and todd@@ have been seeing panics (todd and krw
with xxxterm not sure about pirofti) involving pool corruption while
using this commit.

krw and todd confirm that this backout fixes the problem.

ok blambert@@ krw@@, todd@@ henning@@ and kettenis@@

	    Double link between pf states and sockets.  Henning has
	    already implemented half of it.  The additional part is: -
	    The pf state lookup for outgoing packets is optimized by
	    using mbuf->inp->state.
	    - For incomming tcp, udp, raw, raw6 packets the socket
	    lookup always is optimized by using mbuf->state->inp.
	    - All protocols establish the link for incomming packets.
	    - All protocols set the inp in the mbuf for outgoing packets.
	      This allows the linkage beginning with the first packet
	      for outgoing connections.
	    - In case of divert states, delete the state when the socket
	      closes.  Otherwise new connections could match on old
	      states instead of being diverted to the listen socket.
	    ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.119 2011/04/28 09:56:27 claudio Exp $	*/
d812 21
a880 21
		}
	}
	/*
	 * If the destination address is multicast and an outgoing
	 * interface has been set as a multicast option, use the
	 * address of that interface as our source address.
	 */
	if (IN_MULTICAST(sin->sin_addr.s_addr) && mopts != NULL) {
		struct ip_moptions *imo;
		struct ifnet *ifp;

		imo = mopts;
		if (imo->imo_multicast_ifp != NULL) {
			ifp = imo->imo_multicast_ifp;
			TAILQ_FOREACH(ia, &in_ifaddr, ia_list)
				if (ia->ia_ifp == ifp)
					break;
			if (ia == 0) {
				*errorp = EADDRNOTAVAIL;
				return NULL;
			}
@


1.119
log
@Make in_broadcast() rdomain aware. Mostly mechanical change.
This fixes the problem of binding sockets to broadcast IPs in other
rdomains.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.118 2011/04/28 07:10:03 claudio Exp $	*/
d516 2
a517 17
	if (inp->inp_pf_sk) {
		struct pf_state_key	*sk;
		struct pf_state_item	*si;

		s = splsoftnet();
		sk = (struct pf_state_key *)inp->inp_pf_sk;
		TAILQ_FOREACH(si, &sk->states, entry)
			if (sk == si->s->key[PF_SK_STACK] && si->s->rule.ptr &&
			    si->s->rule.ptr->divert.port) {
				pf_unlink_state(si->s);
				break;
			}
		/* pf_unlink_state() may have detached the state */
		if (inp->inp_pf_sk)
			((struct pf_state_key *)inp->inp_pf_sk)->inp = NULL;
		splx(s);
	}
@


1.118
log
@Allow SOCK_DGRAM sockets to be bound to the local network broadcast addr.
These sockets will only see broadcast sent to that particular address.
Some applications like samba use this feature.
Problem found and initial version by sthen@@, OK sthen@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.117 2011/04/24 19:36:54 bluhm Exp $	*/
d283 2
a284 1
				    in_broadcast(sin->sin_addr, NULL)))
@


1.117
log
@Double link between pf states and sockets.  Henning has already
implemented half of it.  The additional part is:
- The pf state lookup for outgoing packets is optimized by using
  mbuf->inp->state.
- For incomming tcp, udp, raw, raw6 packets the socket lookup always
  is optimized by using mbuf->state->inp.
- All protocols establish the link for incomming packets.
- All protocols set the inp in the mbuf for outgoing packets.
  This allows the linkage beginning with the first packet for
  outgoing connections.
- In case of divert states, delete the state when the socket closes.
  Otherwise new connections could match on old states instead of
  being diverted to the listen socket.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.116 2011/04/19 03:47:29 dlg Exp $	*/
d281 4
a284 1
				return (EADDRNOTAVAIL);
@


1.116
log
@reintroduce using the RB tree for local address lookups. this is
confusing because both addresses and broadcast addresses are put
into the tree.

there are two types of local address lookup. the first is when the
socket layer wants a local address, the second is in ip_input when
the kernel is figuring out the packet is for it to process or
forward.

ip_input considers local addresses and broadcast addresses as local,
however, the handling of broadcast addresses is different depending
on whether ip_directedbcast is set. if if ip_directbcast is unset
then a packet coming in on any interface to any of the systems
broadcast addresses is considered local, otherwise the broadcast
packet must exist on the interface it was received on.

the code also needs to consider classful broadcast addresses so we
can continue some legacy applications (eg, netbooting old sparcs
that use rarp and bootparam requests to classful broadcast addresses
as per PR6382). this diff maintains that support, but restricts it
to packets that are broadcast on the link layer (eg, ethernet
broadcasted packets), and it only looks up addresses on the local
interface. we now only support classful broadcast addresses on local
interfaces to avoid weird side effects with packets routed to us.

the ip4 socket layer does lookups for local addresses with a wrapper
around the global address tree that rejects matches against broadcast
addresses. we now no longer support bind sockets to broadcast
addresses, no matter what the value of ip_directedbcast is.

ok henning@@
testing (and possibly ok) claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.115 2011/04/14 08:15:26 claudio Exp $	*/
d512 17
a528 2
	if (inp->inp_pf_sk)
		((struct pf_state_key *)inp->inp_pf_sk)->inp = NULL;
@


1.115
log
@Backout the in_iawithaddr() -> ifa_ifwithaddr() change.
There is a massive issue with broadcast addrs because ifa_ifwithaddr()
handles them differently then in_iawithaddr().
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.114 2011/04/04 13:26:46 henning Exp $	*/
d279 2
a280 2
			    in_iawithaddr(sin->sin_addr, NULL,
			    inp->inp_rtableid) == 0)
@


1.114
log
@in_iawithaddr -> ifawithaddr
the latter is now much faster and the former becomes a wrapper + compat hacks
around the latter in a bit.
ok dlg sthen and "ah hai" from various in various bars here
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.113 2010/07/03 04:44:51 guenther Exp $	*/
d279 2
a280 1
			    !ifa_ifwithaddr(sintosa(sin), inp->inp_rtableid))
@


1.113
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.112 2010/05/07 13:33:16 claudio Exp $	*/
d279 1
a279 2
			    in_iawithaddr(sin->sin_addr, NULL,
			    inp->inp_rtableid) == 0)
@


1.112
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.111 2010/01/15 18:20:23 chl Exp $	*/
d200 1
a200 1
	inp->inp_rdomain = curproc->p_p->ps_rdomain;
d204 1
a204 1
	    inp->inp_rdomain), inp, inp_lhash);
d206 1
a206 1
	    &inp->inp_laddr, inp->inp_lport, inp->inp_rdomain),
d280 1
a280 1
			    inp->inp_rdomain) == 0)
d293 1
a293 1
				    inp->inp_rdomain);
d298 1
a298 1
			    &sin->sin_addr, lport, wild, inp->inp_rdomain);
d346 1
a346 1
			    &inp->inp_laddr, lport, wild, inp->inp_rdomain));
d364 1
a364 1
			    &inp->inp_laddr, lport, wild, inp->inp_rdomain));
d418 1
a418 1
			inp->inp_rdomain);
d427 1
a427 1
	    inp->inp_lport, inp->inp_rdomain) != 0)
d573 2
a574 6
in_pcbnotifyall(table, dst, rdomain, errno, notify)
	struct inpcbtable *table;
	struct sockaddr *dst;
	u_int rdomain;
	int errno;
	void (*notify)(struct inpcb *, int);
d595 1
d605 1
a605 1
		    inp->inp_rdomain != rdomain ||
d638 1
a638 1
		    inp->inp_rdomain);
d641 1
a641 1
				(struct rtentry **)0, inp->inp_rdomain);
d672 2
a673 1
in_pcblookup(struct inpcbtable *table, void *faddrp, u_int fport_arg, void *laddrp, u_int lport_arg, int flags, u_int rdomain)
d681 1
a681 1
	rdomain = rtable_l2(rdomain);
d684 1
a684 1
		if (inp->inp_rdomain != rdomain)
d790 1
a790 1
			ro->ro_tableid = inp->inp_rdomain;
d801 1
a801 1
    struct ip_moptions *mopts, int *errorp, u_int rdomain)
d825 1
a825 1
		ro->ro_tableid = rdomain;
d847 1
a847 1
		ia = ifatoia(ifa_ifwithdstaddr(sintosa(sin), rdomain));
d849 1
a849 1
			ia = ifatoia(ifa_ifwithnet(sintosa(sin), rdomain));
d891 1
a891 1
	LIST_INSERT_HEAD(INPCBLHASH(table, inp->inp_lport, inp->inp_rdomain),
d903 1
a903 1
		    inp->inp_rdomain), inp, inp_hash);
d931 1
a931 1
	rdomain = rtable_l2(rdomain);
d942 1
a942 1
		    inp->inp_rdomain == rdomain) {
d1020 1
a1020 1
	rdomain = rtable_l2(rdomain);
d1048 1
a1048 1
		    inp->inp_rdomain == rdomain)
d1061 1
a1061 1
			    inp->inp_rdomain == rdomain)
@


1.111
log
@Replace pool_get() + bzero() with pool_get(..., PR_ZERO).

With input from oga@@ and krw@@

ok oga@@ krw@@ thib@@ markus@@ mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.110 2009/12/23 07:40:31 guenther Exp $	*/
d784 1
a784 1
			rtalloc_mpath(ro, &inp->inp_laddr6.s6_addr32[0], 0);
d792 1
d794 1
a794 2
			rtalloc_mpath(ro, &inp->inp_laddr.s_addr,
			    inp->inp_rdomain);
d827 2
a828 1
		rtalloc_mpath(ro, NULL, rdomain);
@


1.110
log
@The process's rdomain should be, well, per-process and not per-rthread,
so put it in struct process instead of struct proc.  While at it,
move the p_emul member inside struct proc so that it gets copied
automatically instead of requiring manual assignment.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.109 2009/11/27 20:05:50 guenther Exp $	*/
d191 1
a191 1
	inp = pool_get(&inpcb_pool, PR_NOWAIT);
a193 1
	bzero((caddr_t)inp, sizeof(*inp));
@


1.109
log
@Add setrdomain() and getrdomain() system calls.  Committing now to
catch the libc major bump per request from deraadt@@

Diff by reyk.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.108 2009/11/13 20:54:05 claudio Exp $	*/
d201 1
a201 1
	inp->inp_rdomain = curproc->p_rdomain;
@


1.108
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.107 2009/11/03 10:59:04 claudio Exp $	*/
d201 1
@


1.107
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.106 2009/07/26 12:59:16 thib Exp $	*/
d573 1
a573 1
in_pcbnotifyall(table, dst, errno, notify)
d576 1
d608 1
d793 2
a794 1
			rtalloc_mpath(ro, &inp->inp_laddr.s_addr, 0);
@


1.106
log
@no need to cast the return value of m_freem() to void
as its a void function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.104 2009/03/15 19:40:41 miod Exp $	*/
d203 2
a204 2
	LIST_INSERT_HEAD(INPCBLHASH(table, inp->inp_lport, inp->inp_rdomain),
	    inp, inp_lhash);
d206 2
a207 1
	    &inp->inp_laddr, inp->inp_lport, inp->inp_rdomain), inp, inp_hash);
d681 1
d929 1
d1018 1
@


1.105
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d483 1
a483 1
		(void)m_freem(inp->inp_options);
@


1.104
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.103 2008/10/23 22:22:44 deraadt Exp $	*/
d124 1
a124 1
#define	INPCBHASH(table, faddr, fport, laddr, lport) \
d126 1
a126 1
	ntohs((fport)) + ntohs((lport))) & (table->inpt_hash)]
d133 2
a134 2
#define	INPCBLHASH(table, lport) \
	&(table)->inpt_lhashtbl[lport & table->inpt_lhash]
d203 2
a204 1
	LIST_INSERT_HEAD(INPCBLHASH(table, inp->inp_lport), inp, inp_lhash);
d206 1
a206 1
	    &inp->inp_laddr, inp->inp_lport), inp, inp_hash);
d278 2
a279 1
			    in_iawithaddr(sin->sin_addr, NULL) == 0)
d291 2
a292 1
				    &sin->sin_addr, lport, INPLOOKUP_WILDCARD);
d297 1
a297 1
			    &sin->sin_addr, lport, wild);
d345 1
a345 1
			    &inp->inp_laddr, lport, wild));
d363 1
a363 1
			    &inp->inp_laddr, lport, wild));
d416 2
a417 1
			inp->inp_socket->so_options, inp->inp_moptions, &error);
d426 1
a426 1
	    inp->inp_lport) != 0)
d637 2
a638 1
		rt_missmsg(RTM_LOSING, &info, rt->rt_flags, rt->rt_ifp, 0, 0);
d641 1
a641 1
				(struct rtentry **)0, 0);
d672 1
a672 5
in_pcblookup(table, faddrp, fport_arg, laddrp, lport_arg, flags)
	struct inpcbtable *table;
	void *faddrp, *laddrp;
	u_int fport_arg, lport_arg;
	int flags;
d680 1
a680 1
	for (inp = LIST_FIRST(INPCBLHASH(table, lport)); inp;
d682 2
d797 2
a798 6
in_selectsrc(sin, ro, soopts, mopts, errorp)
	struct sockaddr_in *sin;
	struct route *ro;
	int soopts;
	struct ip_moptions *mopts;
	int *errorp;
d822 1
a822 1
		rtalloc_mpath(ro, NULL, 0);
d843 1
a843 1
		ia = ifatoia(ifa_ifwithdstaddr(sintosa(sin)));
d845 1
a845 1
			ia = ifatoia(ifa_ifwithnet(sintosa(sin)));
d887 2
a888 1
	LIST_INSERT_HEAD(INPCBLHASH(table, inp->inp_lport), inp, inp_lhash);
d898 2
a899 2
		    inp->inp_fport, &inp->inp_laddr, inp->inp_lport),
		    inp, inp_hash);
d920 2
a921 4
in_pcbhashlookup(table, faddr, fport_arg, laddr, lport_arg)
	struct inpcbtable *table;
	struct in_addr faddr, laddr;
	u_int fport_arg, lport_arg;
d927 1
a927 1
	head = INPCBHASH(table, &faddr, fport, &laddr, lport);
d936 2
a937 1
		    inp->inp_laddr.s_addr == laddr.s_addr) {
d952 1
a952 1
		printf("in_pcbhashlookup: faddr=%08x fport=%d laddr=%08x lport=%d\n",
d954 1
a954 1
		    ntohl(laddr.s_addr), ntohs(lport));
d962 2
a963 4
in6_pcbhashlookup(table, faddr, fport_arg, laddr, lport_arg)
	struct inpcbtable *table;
	struct in6_addr *faddr, *laddr;
	u_int fport_arg, lport_arg;
d1008 1
a1008 1
    u_int lport_arg, int reverse, struct mbuf *m)
d1018 1
a1018 1

d1033 1
a1033 1
	head = INPCBHASH(table, &zeroin_addr, 0, key1, lport);
d1041 2
a1042 1
		    inp->inp_faddr.s_addr == INADDR_ANY)
d1046 1
a1046 1
		head = INPCBHASH(table, &zeroin_addr, 0, key2, lport);
d1054 2
a1055 1
			    inp->inp_faddr.s_addr == INADDR_ANY)
@


1.103
log
@use the correct idiom for NFOO things which come from "foo.h" files
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.102 2008/07/29 21:46:27 deraadt Exp $	*/
d577 1
a577 1
	splassert(IPL_SOFTNET);
@


1.102
log
@when detaching pcbs, also free the v6 output options so that we do not
leak kernel memory for every closed v6 descriptor with certain options set
ok otto jsing todd claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.101 2008/07/09 20:20:45 djm Exp $	*/
d1018 1
a1018 1
#if NPF
d1088 1
a1088 1
#if NPF
@


1.101
log
@expand the net.inet.(tcp|udp).baddynamic dynamic source port
skipping bitmasks to cover the entire 65536 port space - previously
they covered 512-1024 only.

sysctl needs to be updated to cope with this change; please
"make includes" before rebuilding it.

feedback millert@@ ok millert@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.100 2008/07/03 15:46:24 henning Exp $	*/
d483 2
a484 1
	if (inp->inp_flags & INP_IPV6)
d486 1
a486 1
	else
@


1.100
log
@link pf state keys to tcp pcbs and vice versa.
when we first do a pcb lookup and we have a pointer to a pf state key
in the mbuf header, store the state key pointer in the pcb and a pointer
to the pcb we just found in the state key. when either the state key
or the pcb is removed, clear the pointers.
on subsequent packets inbound we can skip the pcb lookup and just use the
pointer from the state key.
on subsequent packets outbound we can skip the state key lookup and use
the pointer from the pcb.
about 8% speedup with 100 concurrent tcp sessions, should help much more
with more tcp sessions.
ok markus ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.99 2008/05/23 15:51:12 thib Exp $	*/
d160 1
a160 3
in_baddynamic(port, proto)
	u_int16_t port;
	u_int16_t proto;
a161 2


a163 4
		if (port == NFS_PORT)
			return (1);
		if (port < IPPORT_RESERVED/2 || port >= IPPORT_RESERVED)
			return (0);
d167 1
a170 4
		if (port == NFS_PORT)
			return (1);
		if (port < IPPORT_RESERVED/2 || port >= IPPORT_RESERVED)
			return (0);
@


1.99
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.98 2008/05/15 19:40:38 markus Exp $	*/
d515 4
@


1.98
log
@divert for ipv6; ok henning, pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.97 2008/05/09 03:14:07 markus Exp $	*/
d235 1
a235 1
in_pcbbind(v, nam)
d238 1
a244 1
	struct proc *p = curproc;		/* XXX */
d251 1
a251 1
		return in6_pcbbind(inp, nam);
d437 1
a437 1
		    in_pcbbind(inp, (struct mbuf *)0) == EADDRNOTAVAIL)
@


1.97
log
@should check for null pointers; from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.96 2008/05/09 02:52:15 markus Exp $	*/
d1086 2
a1087 5
in6_pcblookup_listen(table, laddr, lport_arg, reverse)
	struct inpcbtable *table;
	struct in6_addr *laddr;
	u_int lport_arg;
	int reverse;
d1094 10
@


1.96
log
@Add SO_BINDANY socket option from BSD/OS.

The option allows a socket to be bound to addresses which are not
local to the machine.  In order to receive packets for these addresses
SO_BINDANY needs to be combined with matching outgoing pf(4) divert
rules, see pf.conf(5).

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.95 2008/05/09 02:44:54 markus Exp $	*/
d1025 1
a1025 1
	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) {
@


1.95
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.94 2008/05/07 05:14:21 claudio Exp $	*/
d287 2
a288 1
			if (in_iawithaddr(sin->sin_addr, NULL) == 0)
@


1.94
log
@Implement routing priorities. Every route inserted has a priority assigned
and the one route with the lowest number wins. This will be used by the
routing daemons to resolve the synchronisations issue in case of conflicts.
The nasty bits of this are in the multipath code. If no priority is specified
the kernel will choose an appropriate priority.

Looked at by a few people at n2k8 code is much older
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.93 2008/04/18 06:42:20 djm Exp $	*/
d71 2
d85 1
d1015 2
a1016 5
in_pcblookup_listen(table, laddr, lport_arg, reverse)
	struct inpcbtable *table;
	struct in_addr laddr;
	u_int lport_arg;
	int reverse;
d1023 10
@


1.93
log
@use arc4random_uniform() for random number requests that are not a
power of two.

use arc4random_bytes() when requesting more than a word of PRNG
output.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.92 2007/12/30 21:13:27 claudio Exp $	*/
d637 1
a637 1
			(void)rtrequest1(RTM_DELETE, &info,
@


1.92
log
@A struct rt_addrinfo is needed for rt_missmsg() so we can use rtrequest1()
directly instead of takeing the detour via rtrequest().
OK henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.91 2007/11/26 09:28:33 martynas Exp $	*/
d338 1
a338 1
				*lastport = first - (arc4random() % count);
d356 1
a356 1
				*lastport = first + (arc4random() % count);
@


1.92.2.1
log
@when detaching pcbs, also free the v6 output options so that we do not
leak kernel memory for every closed v6 descriptor with certain options set
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.92 2007/12/30 21:13:27 claudio Exp $	*/
d490 1
a490 2
	if (inp->inp_flags & INP_IPV6) {
		ip6_freepcbopts(inp->inp_outputopts6);
d492 1
a492 1
	} else
@


1.91
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.90 2007/09/01 18:49:28 henning Exp $	*/
d631 1
d637 1
a637 2
			(void) rtrequest(RTM_DELETE, rt_key(rt),
				rt->rt_gateway, rt_mask(rt), rt->rt_flags,
@


1.90
log
@since the
MGET* macros were changed to function calls, there wasn't any
need for the pool declarations and the inclusion of pool.h
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.89 2007/04/10 17:47:55 miod Exp $	*/
d119 1
a119 1
int inpcb_pool_initalized = 0;
d194 1
a194 1
	if (inpcb_pool_initalized == 0) {
d197 1
a197 1
		inpcb_pool_initalized = 1;
@


1.89
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.88 2006/06/18 11:47:45 pascoe Exp $	*/
d79 1
@


1.89.2.1
log
@when detaching pcbs, also free the v6 output options so that we do not
leak kernel memory for every closed v6 descriptor with certain options set
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.89 2007/04/10 17:47:55 miod Exp $	*/
d489 1
a489 2
	if (inp->inp_flags & INP_IPV6) {
		ip6_freepcbopts(inp->inp_outputopts6);
d491 1
a491 1
	} else
@


1.88
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.87 2006/06/16 16:49:40 henning Exp $	*/
d221 1
a221 1
	 * of it's pointer chasing, later.
@


1.87
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.86 2006/04/22 19:43:07 claudio Exp $	*/
d778 1
a778 1
			rtalloc(ro);
d787 1
a787 1
			rtalloc(ro);
d824 1
a824 1
		rtalloc(ro);
@


1.86
log
@Routes announced via rt_missmsg() do not have rtm_index set. While in most
cases harmless it is used by the IPv6 code. The result is that bgpd is unable
to assigning link local addresses to the correct interface. OK henning@@
Fix for PR 5063.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.85 2006/03/05 21:48:56 miod Exp $	*/
d633 1
a633 1
		rt_missmsg(RTM_LOSING, &info, rt->rt_flags, rt->rt_ifp, 0);
d637 1
a637 1
				(struct rtentry **)0);
@


1.85
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.84 2005/06/24 07:57:24 markus Exp $	*/
d633 1
a633 1
		rt_missmsg(RTM_LOSING, &info, rt->rt_flags, 0);
@


1.84
log
@simplify port allocation in pcb_bind(); based on freebsd; ok claudio henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.83 2004/12/06 02:46:34 deraadt Exp $	*/
d250 1
a250 1
	if (in_ifaddr.tqh_first == 0)
d402 1
a402 1
	if (in_ifaddr.tqh_first != 0) {
d411 1
a411 1
			sin->sin_addr = in_ifaddr.tqh_first->ia_addr.sin_addr;
d413 2
a414 2
		  (in_ifaddr.tqh_first->ia_ifp->if_flags & IFF_BROADCAST))
			sin->sin_addr = in_ifaddr.tqh_first->ia_broadaddr.sin_addr;
d850 1
a850 1
			ia = in_ifaddr.tqh_first;
d868 1
a868 2
			for (ia = in_ifaddr.tqh_first; ia != 0;
			    ia = ia->ia_list.tqe_next)
d931 1
a931 1
	for (inp = head->lh_first; inp != NULL; inp = inp->inp_hash.le_next) {
d945 1
a945 1
			if (inp != head->lh_first) {
d974 1
a974 1
	for (inp = head->lh_first; inp != NULL; inp = inp->inp_hash.le_next) {
d985 1
a985 1
			if (inp != head->lh_first) {
d1065 1
a1065 1
	if (inp != NULL && inp != head->lh_first) {
d1124 1
a1124 1
	if (inp != NULL && inp != head->lh_first) {
@


1.83
log
@also consider NFS_PORT to be a reserved port, as in 1.18 or something like
that.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.82 2004/12/06 02:41:43 deraadt Exp $	*/
d307 1
a307 1
		u_int16_t first, last, old = 0;
a308 1
		int loopcount = 0;
a330 1
portloop:
a334 4
			if (loopcount == 0) {	/* only do this once. */
				old = first;
				first -= (arc4random() % (first - last));
			}
d336 2
a337 1
			*lastport = first;		/* restart each time */
d340 1
a340 6
				if (count-- <= 0) {	/* completely used? */
					if (loopcount == 0) {
						last = old;
						loopcount++;
						goto portloop;
					}
a341 1
				}
a352 4
			if (loopcount == 0) {	/* only do this once. */
				old = first;
				first += (arc4random() % (last - first));
			}
d354 2
a355 1
			*lastport = first;		/* restart each time */
d358 1
a358 6
				if (count-- <= 0) {	/* completely used? */
					if (loopcount == 0) {
						first = old;
						loopcount++;
						goto portloop;
					}
a359 1
				}
@


1.82
log
@ipsec udpencap check was done after baddynamicports ports checks (those
tables only map from 512 to 1023 using bitmaps, sorry); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.81 2004/11/23 15:35:36 markus Exp $	*/
d91 3
d164 2
d174 2
@


1.81
log
@remove wrong comments; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.80 2004/08/10 20:12:15 markus Exp $	*/
a157 2
	if (port < IPPORT_RESERVED/2 || port >= IPPORT_RESERVED)
		return (0);
d161 2
d169 2
@


1.80
log
@remove in_pcbnotify, it is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.79 2004/08/04 20:45:09 markus Exp $	*/
d109 4
a112 4
int ipport_firstauto = IPPORT_RESERVED;		/* 1024 */
int ipport_lastauto = IPPORT_USERRESERVED;	/* 5000 */
int ipport_hifirstauto = IPPORT_HIFIRSTAUTO;	/* 40000 */
int ipport_hilastauto = IPPORT_HILASTAUTO;	/* 44999 */
@


1.79
log
@use CIRCLEQ_XXX; ok mcbride, miod
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.78 2004/06/25 03:04:24 markus Exp $	*/
d571 1
a571 2
 * associated with address dst.  The local address and/or port numbers
 * may be specified to limit the search.  The "usual action" will be
d579 2
a580 2
int
in_pcbnotify(table, dst, fport_arg, laddr, lport_arg, errno, notify)
a582 2
	u_int fport_arg, lport_arg;
	struct in_addr laddr;
a587 2
	u_int16_t fport = fport_arg, lport = lport_arg;
	int nmatch = 0;
a589 49

#ifdef INET6
	/*
	 * See in6_pcbnotify() for IPv6 codepath.  By the time this
	 * gets called, the addresses passed are either definitely IPv4 or
	 * IPv6; *_pcbnotify() never gets called with v4-mapped v6 addresses.
	 */
#endif /* INET6 */

	if (dst->sa_family != AF_INET)
		return (0);
	faddr = satosin(dst)->sin_addr;
	if (faddr.s_addr == INADDR_ANY)
		return (0);

	for (inp = CIRCLEQ_FIRST(&table->inpt_queue);
	    inp != CIRCLEQ_END(&table->inpt_queue);) {
#ifdef INET6
		if (inp->inp_flags & INP_IPV6) {
			inp = CIRCLEQ_NEXT(inp, inp_queue);
			continue;
		}
#endif
		if (inp->inp_faddr.s_addr != faddr.s_addr ||
		    inp->inp_socket == 0 ||
		    inp->inp_fport != fport ||
		    inp->inp_lport != lport ||
		    inp->inp_laddr.s_addr != laddr.s_addr) {
			inp = CIRCLEQ_NEXT(inp, inp_queue);
			continue;
		}
		oinp = inp;
		inp = CIRCLEQ_NEXT(inp, inp_queue);
		nmatch++;
		if (notify)
			(*notify)(oinp, errno);
	}
	return (nmatch);
}

void
in_pcbnotifyall(table, dst, errno, notify)
	struct inpcbtable *table;
	struct sockaddr *dst;
	int errno;
	void (*notify)(struct inpcb *, int);
{
	struct inpcb *inp, *oinp;
	struct in_addr faddr;
@


1.78
log
@disallow udpencap_port in bind(0); ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.77 2004/06/22 07:35:20 cedric Exp $	*/
d659 2
a660 2
	for (inp = table->inpt_queue.cqh_first;
	    inp != (struct inpcb *)&table->inpt_queue;) {
d673 1
a673 1
		inp = inp->inp_queue.cqe_next;
@


1.77
log
@Pull the plug on source-based routing until remaining bugs are eradicated.
No need to reconfig kernel or rebuild userland stuff.
requested deraadt@@, help beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.76 2004/06/06 16:49:09 cedric Exp $	*/
d94 3
d165 4
@


1.76
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.75 2004/03/12 17:49:23 claudio Exp $	*/
d844 1
a844 2
			satortin(&ro->ro_dst)->rtin_dst = inp->inp_faddr;
			satortin(&ro->ro_dst)->rtin_src = inp->inp_laddr;
@


1.75
log
@Fix rtentry leak in in_losing(). The rtentry needs to be freed in anycase.
Found by Greg Wooledge. A lot of debugging and help by dhartmei@@ markus@@
cedric@@. OK dhartmei@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.74 2004/01/02 16:08:54 markus Exp $	*/
d844 2
a845 1
			satosin(&ro->ro_dst)->sin_addr = inp->inp_faddr;
@


1.74
log
@use pool for pcb; with grange@@ like netbsd; ok itojun@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.73 2003/12/21 15:12:27 markus Exp $	*/
a695 1
		else
d699 2
d702 1
a702 1
			rtfree(rt);
@


1.73
log
@change in*_pcbnotify to return numbers of matches; ok itojun, mcbride, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.72 2003/12/21 14:57:19 markus Exp $	*/
d111 3
d177 6
a182 1
	MALLOC(inp, struct inpcb *, sizeof(*inp), M_PCB, M_NOWAIT);
d520 1
a520 1
	FREE(inp, M_PCB);
@


1.72
log
@use CIRCLEQ* for pcb's; ok deraadt, henning, mcbride, with help from canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.71 2003/12/10 07:22:43 itojun Exp $	*/
d565 1
a565 1
void
d577 1
d590 1
a590 1
		return;
d593 1
a593 1
		return;
d613 1
d617 1
@


1.71
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.70 2003/12/08 07:07:36 mcbride Exp $	*/
d594 2
a595 2
	for (inp = table->inpt_queue.cqh_first;
	    inp != (struct inpcb *)&table->inpt_queue;) {
d598 1
a598 1
			inp = inp->inp_queue.cqe_next;
d607 1
a607 1
			inp = inp->inp_queue.cqe_next;
d611 1
a611 1
		inp = inp->inp_queue.cqe_next;
d645 1
a645 1
			inp = inp->inp_queue.cqe_next;
d651 1
a651 1
			inp = inp->inp_queue.cqe_next;
@


1.70
log
@Mbuf tag tcp and udp packets which are translated to localhost, and
use the the presence of this tag to reverse the match order in
in{6}_pcblookup_listen(). Some daemons (such as portmap) do a double
bind, binding to both * and localhost in order to differentiate local
from non-local connections, and potentially granting more privilege to
local ones. This change ensures that redirected connections to localhost
do not appear local to such a daemon.

Bulk of changes from dhartmei@@, some changes markus@@

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.69 2003/11/04 21:43:16 markus Exp $	*/
d171 1
a171 1
	register struct inpcb *inp;
d208 1
a208 1
	register void *v;
d211 3
a213 3
	register struct inpcb *inp = v;
	register struct socket *so = inp->inp_socket;
	register struct inpcbtable *table = inp->inp_table;
d215 1
a215 1
	register struct sockaddr_in *sin;
d378 1
a378 1
	register void *v;
d381 1
a381 1
	register struct inpcb *inp = v;
d383 1
a383 1
	register struct sockaddr_in *sin = mtod(nam, struct sockaddr_in *);
d517 1
a517 1
	register struct inpcb *inp;
d520 1
a520 1
	register struct sockaddr_in *sin;
d536 1
a536 1
	register struct sockaddr_in *sin;
d624 1
a624 1
	register struct inpcb *inp, *oinp;
d671 1
a671 1
	register struct rtentry *rt;
d700 1
a700 1
	register struct inpcb *inp;
d720 1
a720 1
	register struct inpcb *inp, *match = 0;
d974 1
a974 1
	register struct inpcb *inp;
d1017 1
a1017 1
	register struct inpcb *inp;
d1066 1
a1066 1
	register struct inpcb *inp;
d1129 1
a1129 1
	register struct inpcb *inp;
@


1.69
log
@add in(6)_pcblookup_listen() and replace all calls to in_pcblookup()
with either in(6)_pcbhashlookup() or in(6)_pcblookup_listen();
in_pcblookup is now only used by bind(2); speeds up pcb lookup for
listening sockets; from Claudio Jeker
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.68 2003/10/25 12:15:24 markus Exp $	*/
d1058 1
a1058 1
in_pcblookup_listen(table, laddr, lport_arg)
d1062 1
d1065 1
d1069 9
a1077 1
	head = INPCBHASH(table, &zeroin_addr, 0, &laddr, lport);
d1084 1
a1084 1
		    inp->inp_laddr.s_addr == laddr.s_addr &&
d1088 2
a1089 2
	if (inp == NULL && laddr.s_addr != INADDR_ANY) {
		head = INPCBHASH(table, &zeroin_addr, 0, &zeroin_addr, lport);
d1096 1
a1096 1
			    inp->inp_laddr.s_addr == INADDR_ANY &&
d1121 1
a1121 1
in6_pcblookup_listen(table, laddr, lport_arg)
d1125 1
d1128 1
d1132 9
a1140 1
	head = IN6PCBHASH(table, &zeroin6_addr, 0, laddr, lport);
d1145 1
a1145 1
		    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, laddr) &&
d1149 2
a1150 3
	if (inp == NULL && !IN6_IS_ADDR_UNSPECIFIED(laddr)) {
		head = IN6PCBHASH(table, &zeroin6_addr, 0,
		    &zeroin6_addr, lport);
d1155 1
a1155 1
			    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) &&
@


1.68
log
@additional hash for local port; improves speed of implicit bind
from >1000K cpu cycles to 20-30K for 18000 sockets on i386;
test+feedback by Claudio Jeker; ok itojun@@;
[make sure you rebuild netstat/systat, too]
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.67 2003/08/15 20:32:20 tedu Exp $	*/
d958 9
d1041 1
a1041 1
		printf("in6_pcblookup_connect: faddr=");
d1050 69
d1120 39
@


1.67
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.66 2003/06/02 23:28:13 millert Exp $	*/
d120 3
d130 2
a131 1
	table->inpt_hashtbl = hashinit(hashsize, M_PCB, M_NOWAIT, &table->inpt_hash);
d134 4
d186 1
d508 1
d726 2
a727 3
	for (inp = table->inpt_queue.cqh_first;
	    inp != (struct inpcb *)&table->inpt_queue;
	    inp = inp->inp_queue.cqe_next) {
d935 2
@


1.66
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.65 2003/05/06 20:35:14 tedu Exp $	*/
d258 1
a258 1
			    (error = suser(p->p_ucred, &p->p_acflag)))
d282 1
a282 1
			if ((error = suser(p->p_ucred, &p->p_acflag)))
@


1.65
log
@use M_NOWAIT instead of WAITOK for the hashtable allocation.  ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.64 2002/09/11 03:15:36 itojun Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.64
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.63 2002/06/11 05:13:59 art Exp $	*/
d131 3
a133 1
	table->inpt_hashtbl = hashinit(hashsize, M_PCB, M_WAITOK, &table->inpt_hash);
@


1.63
log
@splassert where comments tell us to.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.62 2002/06/09 16:26:10 itojun Exp $	*/
d147 1
a147 1
		return(0);
@


1.62
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.61 2002/05/31 02:39:25 angelos Exp $	*/
d566 1
a566 1
	register struct inpcb *inp, *oinp;
d569 2
@


1.61
log
@Keep an policy attached to each socket (that needs it), and cleanup as
needed on socket tear-down.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.60 2002/03/14 01:27:11 millert Exp $	*/
d37 1
a37 1
 * 
d41 1
a41 1
 * 
d56 1
a56 1
 * 
d68 1
a68 1
 * 
d136 1
a136 1
 
d435 1
a435 1
	}		
d480 1
a480 1
	else 
d513 1
a513 1
	
d529 1
a529 1
	
d673 1
a673 1
				rt->rt_gateway, rt_mask(rt), rt->rt_flags, 
d675 1
a675 1
		else 
d843 1
a843 1
	/* 
d849 1
a849 1
		sin->sin_addr.s_addr || 
@


1.60
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.59 2002/01/21 05:33:14 itojun Exp $	*/
d429 8
a436 3
        /* XXX Find IPsec TDB */
        return (0);
#else
a437 1
#endif
d484 1
a484 1
	/* XXX IPsec cleanup here */
a491 6
	if (inp->inp_ipsec_localid)
		ipsp_reffree(inp->inp_ipsec_localid);
	if (inp->inp_ipsec_remoteid)
		ipsp_reffree(inp->inp_ipsec_remoteid);
	if (inp->inp_ipsec_localcred)
		ipsp_reffree(inp->inp_ipsec_localcred);
a493 2
	if (inp->inp_ipsec_localauth)
		ipsp_reffree(inp->inp_ipsec_localauth);
d496 2
@


1.59
log
@remove couple of #if 0'ed portion we will never use
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.58 2001/12/06 02:21:48 itojun Exp $	*/
d566 1
a566 1
	void (*notify) __P((struct inpcb *, int));
d614 1
a614 1
	void (*notify) __P((struct inpcb *, int));
@


1.58
log
@remove obsolete comment; we don't support IPv4 mapped addr
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.57 2001/12/06 02:12:52 itojun Exp $	*/
a405 78
#if 0
		register struct route *ro;
		struct sockaddr_in *sin2;
		struct in_ifaddr *ia;

		ia = (struct in_ifaddr *)0;
		/* 
		 * If route is known or can be allocated now,
		 * our src addr is taken from the i/f, else punt.
		 */
		ro = &inp->inp_route;
		if (ro->ro_rt &&
		    (satosin(&ro->ro_dst)->sin_addr.s_addr !=
			sin->sin_addr.s_addr || 
		    inp->inp_socket->so_options & SO_DONTROUTE)) {
			RTFREE(ro->ro_rt);
			ro->ro_rt = (struct rtentry *)0;
		}
		if ((inp->inp_socket->so_options & SO_DONTROUTE) == 0 && /*XXX*/
		    (ro->ro_rt == (struct rtentry *)0 ||
		    ro->ro_rt->rt_ifp == (struct ifnet *)0)) {
			/* No route yet, so try to acquire one */
			ro->ro_dst.sa_family = AF_INET;
			ro->ro_dst.sa_len = sizeof(struct sockaddr_in);
			satosin(&ro->ro_dst)->sin_addr = sin->sin_addr;
			rtalloc(ro);

			/*
			 * It is important to bzero out the rest of the
			 * struct sockaddr_in when mixing v6 & v4!
			 */
			sin2 = (struct sockaddr_in *)&ro->ro_dst;
			bzero(sin2->sin_zero, sizeof(sin2->sin_zero));
		}
		/*
		 * If we found a route, use the address
		 * corresponding to the outgoing interface
		 * unless it is the loopback (in case a route
		 * to our address on another net goes to loopback).
		 */
		if (ro->ro_rt && !(ro->ro_rt->rt_ifp->if_flags & IFF_LOOPBACK))
			ia = ifatoia(ro->ro_rt->rt_ifa);
		if (ia == 0) {
			u_int16_t fport = sin->sin_port;

			sin->sin_port = 0;
			ia = ifatoia(ifa_ifwithdstaddr(sintosa(sin)));
			if (ia == 0)
				ia = ifatoia(ifa_ifwithnet(sintosa(sin)));
			sin->sin_port = fport;
			if (ia == 0)
				ia = in_ifaddr.tqh_first;
			if (ia == 0)
				return (EADDRNOTAVAIL);
		}
		/*
		 * If the destination address is multicast and an outgoing
		 * interface has been set as a multicast option, use the
		 * address of that interface as our source address.
		 */
		if (IN_MULTICAST(sin->sin_addr.s_addr) &&
		    inp->inp_moptions != NULL) {
			struct ip_moptions *imo;
			struct ifnet *ifp;

			imo = inp->inp_moptions;
			if (imo->imo_multicast_ifp != NULL) {
				ifp = imo->imo_multicast_ifp;
				for (ia = in_ifaddr.tqh_first; ia != 0;
				    ia = ia->ia_list.tqe_next)
					if (ia->ia_ifp == ifp)
						break;
				if (ia == 0)
					return (EADDRNOTAVAIL);
			}
		}
		ifaddr = satosin(&ia->ia_addr);
#else
a413 1
#endif
@


1.58.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.59 2002/01/21 05:33:14 itojun Exp $	*/
d406 78
d492 1
@


1.58.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.58.2.1 2002/01/31 22:55:44 niklas Exp $	*/
d429 4
a432 7
	{
		int error; /* This is just ignored */

		/* Cause an IPsec SA to be established. */
		ipsp_spd_inp(NULL, AF_INET, 0, &error, IPSP_DIRECTION_OUT,
		    NULL, inp, NULL);
	}		
a433 1
	return (0);
d480 1
a480 1
	/* IPsec cleanup here */
d488 6
d496 2
a499 2
	if (inp->inp_ipo)
		ipsec_delete_policy(inp->inp_ipo);
d566 1
a566 1
	void (*notify)(struct inpcb *, int);
d614 1
a614 1
	void (*notify)(struct inpcb *, int);
@


1.58.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.58.2.2 2002/06/11 03:31:36 art Exp $	*/
d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
d136 1
a136 1

d147 1
a147 1
		return (0);
d435 1
a435 1
	}
d480 1
a480 1
	else
d513 1
a513 1

d529 1
a529 1

d566 1
a566 1
	struct inpcb *inp, *oinp;
a569 2
	splassert(IPL_SOFTNET);

d673 1
a673 1
				rt->rt_gateway, rt_mask(rt), rt->rt_flags,
d675 1
a675 1
		else
d843 1
a843 1
	/*
d849 1
a849 1
		sin->sin_addr.s_addr ||
@


1.58.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d131 1
a131 3
	table->inpt_hashtbl = hashinit(hashsize, M_PCB, M_NOWAIT, &table->inpt_hash);
	if (table->inpt_hashtbl == NULL)
		panic("in_pcbinit: hashinit failed");
@


1.57
log
@remove #if 0'ed portion (for KAME IPSEC - not needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.56 2001/07/05 16:45:54 jjbg Exp $	*/
a807 10
			/* 
			 * Always skip AF_INET sockets when looking
			 * for AF_INET6 addresses.  The only problem
			 * with this comes if the PF_INET6 addresses
			 * are v4-mapped addresses.  From what I've
			 * been able to see, none of the callers cause
			 * such a situation to occur.  If such a
			 * situation DID occur, then it is possible to
			 * miss a matching PCB.
			 */
@


1.56
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.55 2001/06/12 10:59:53 angelos Exp $	*/
a545 8
#if 0 /*KAME IPSEC*/
	if (so->so_pcb) {
		KEYDEBUG(KEYDEBUG_KEY_STAMP,
			printf("DP call free SO=%p from in_pcbdetach\n", so));
		key_freeso(so);
	}
	ipsec4_delete_pcbpolicy(inp);
#endif /*IPSEC*/
@


1.55
log
@IPsec-related socket options; these can be set/removed/retrieved, but
are not taken into consideration in anything just yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.54 2001/06/08 03:53:45 angelos Exp $	*/
d104 1
d177 1
@


1.54
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.53 2001/06/05 02:31:35 deraadt Exp $	*/
d581 4
a584 2
	if (inp->inp_ipsec_auth)
		ipsp_reffree(inp->inp_ipsec_auth);
@


1.53
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.52 2001/05/27 03:54:12 angelos Exp $	*/
a76 1
#include <sys/malloc.h>
a80 3
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/time.h>
a97 10

#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#endif

#if 0 /*KAME IPSEC*/
#include <netinet6/ipsec.h>
#include <netkey/key.h>
#include <netkey/key_debug.h>
#endif /* IPSEC */
@


1.52
log
@Free IPsec authentication material on PCB tear down.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.51 2001/05/21 03:02:18 angelos Exp $	*/
d36 37
a72 1
 *	@@(#)in_pcb.c	8.2 (Berkeley) 1/4/94
a73 12

/*
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.51
log
@Use a reference-counted structure for IPsec IDs and credentials, so we
can cheaply keep copies of them at the PCB. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.50 2001/03/28 20:03:02 angelos Exp $	*/
d571 2
@


1.50
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.49 2001/02/08 18:46:22 itojun Exp $	*/
d563 8
@


1.49
log
@witch raw ip6 socket code from NRL to kame.
makes upgrades/code sharing much easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.48 2000/10/11 09:14:10 itojun Exp $	*/
d557 6
a562 2
	if (inp->inp_tdb)
		TAILQ_REMOVE(&inp->inp_tdb->tdb_inp, inp, inp_tdb_next);
@


1.48
log
@nuke inp_flags bits for controlling IPv4 mapped address.
we don't support IPv4 mapped address,
and there are inconsistent bit manipulation code so it's safer to nuke them.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.47 2000/10/10 15:16:01 provos Exp $	*/
d182 1
a182 1
	inp->inp_csumoffset = -1;
@


1.47
log
@verify payload of the icmp need fragment message at the tcp layer. okay itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.46 2000/10/09 14:39:46 provos Exp $	*/
d369 2
d455 1
a455 7
#ifdef INET6
		    inp->inp_moptions != NULL &&
		    !(inp->inp_flags & INP_IPV6_MCAST))
#else
		    inp->inp_moptions != NULL)
#endif
		{
d509 1
d511 1
a511 1
	if (sotopf(inp->inp_socket) == PF_INET6) {
d513 1
a513 3
		/* Disconnected AF_INET6 sockets cannot be "v4-mapped" */
		inp->inp_flags &= ~INP_IPV6_MAPPED;
	} else
d515 1
d517 2
d969 1
a969 8
	if (IN_MULTICAST(sin->sin_addr.s_addr) &&
#if 0 /*def INET6*/
	    mopts != NULL &&
	    !(inp->inp_flags & INP_IPV6_MCAST))
#else
	    mopts != NULL)
#endif
	{
@


1.46
log
@check if we have a tcb connected to the destination quoted in the icmp need
fragment message when doing path mtu discovery. okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.45 2000/09/20 16:39:50 provos Exp $	*/
a711 32
}

/*
 * Check if we have a socket that talks to the given destination.
 */

int
in_pcbconnected(table, dst)
	struct inpcbtable *table;
	struct sockaddr *dst;
{
	struct inpcb *inp;
	struct in_addr faddr;

	if (dst->sa_family != AF_INET)
		return (0);
	faddr = satosin(dst)->sin_addr;
	if (faddr.s_addr == INADDR_ANY)
		return (0);

	for (inp = table->inpt_queue.cqh_first;
	    inp != (struct inpcb *)&table->inpt_queue;
	    inp = inp->inp_queue.cqe_next) {
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			continue;
#endif
		if (inp->inp_faddr.s_addr == faddr.s_addr && inp->inp_socket)
			break;
	}

	return (inp != (struct inpcb *)&table->inpt_queue);
@


1.45
log
@fix in_pcbrtentry
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.44 2000/09/19 03:20:57 angelos Exp $	*/
d712 32
@


1.44
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.43 2000/09/18 22:06:37 provos Exp $	*/
d873 6
d892 1
a892 1
			if (inp->inp_faddr.s_addr != INADDR_ANY)
@


1.43
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.42 2000/04/27 09:23:21 itojun Exp $	*/
a80 2

extern int	check_ipsec_policy  __P((struct inpcb *, u_int32_t));
d500 2
a501 1
	return (check_ipsec_policy(inp, 0));
@


1.42
log
@avoid infinite loop in in{6,}_pcbnotify (can occurs on family mismatch)
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.41 2000/04/21 11:42:23 itojun Exp $	*/
d860 37
@


1.41
log
@NRL pcb issue; inp_{f,l}addr{,6} is a union so we need to be sure about
af match.
- do not touch IPv4 pcb entries on in6_pcbnotify.
- do not touch IPv6 pcb entries on in_pcbnotify.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.40 2000/01/04 10:39:21 itojun Exp $	*/
d651 2
a652 1
		if (inp->inp_flags & INP_IPV6)
d654 1
d698 2
a699 1
		if (inp->inp_flags & INP_IPV6)
d701 1
@


1.40
log
@if we call in6_setpeeraddr, don't visit code for ipv4.
(the case seems to be never bisited)
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.39 1999/12/19 01:57:07 angelos Exp $	*/
d650 4
d695 4
@


1.40.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.50 2001/03/28 20:03:02 angelos Exp $	*/
d81 2
d184 1
a184 1
	inp->in6p_cksum = -1;
a370 2
	if ((inp->inp_flags & INP_IPV6) != 0)
		panic("IPv6 pcb passed into in_pcbconnect");
d455 7
a461 1
		    inp->inp_moptions != NULL) {
d502 1
a502 2
        /* XXX Find IPsec TDB */
        return (0);
a513 1
	switch (sotopf(inp->inp_socket)) {
d515 1
a515 1
	case PF_INET6:
d517 3
a519 1
		break;
a520 1
	case PF_INET:
a521 2
		break;
	}
d560 2
a561 6
	if (inp->inp_tdb_in)
		TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in,
			     inp, inp_tdb_in_next);
	if (inp->inp_tdb_out)
	        TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out, inp,
			     inp_tdb_out_next);
a649 6
#ifdef INET6
		if (inp->inp_flags & INP_IPV6) {
			inp = inp->inp_queue.cqe_next;
			continue;
		}
#endif
a690 6
#ifdef INET6
		if (inp->inp_flags & INP_IPV6) {
			inp = inp->inp_queue.cqe_next;
			continue;
		}
#endif
a849 43
struct rtentry *
in_pcbrtentry(inp)
	struct inpcb *inp;
{
	struct route *ro;

	ro = &inp->inp_route;

	/*
	 * No route yet, so try to acquire one.
	 */
	if (ro->ro_rt == NULL) {
#ifdef INET6
		bzero(ro, sizeof(struct route_in6));
#else
		bzero(ro, sizeof(struct route));
#endif

		switch(sotopf(inp->inp_socket)) {
#ifdef INET6
		case PF_INET6:
			if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
				break;
			ro->ro_dst.sa_family = AF_INET6;
			ro->ro_dst.sa_len = sizeof(struct sockaddr_in6);
			((struct sockaddr_in6 *) &ro->ro_dst)->sin6_addr =
			    inp->inp_faddr6;
			rtalloc(ro);
			break;
#endif /* INET6 */
		case PF_INET:
			if (inp->inp_faddr.s_addr == INADDR_ANY)
				break;
			ro->ro_dst.sa_family = AF_INET;
			ro->ro_dst.sa_len = sizeof(ro->ro_dst);
			satosin(&ro->ro_dst)->sin_addr = inp->inp_faddr;
			rtalloc(ro);
			break;
		}
	}
	return (ro->ro_rt);
}

d917 8
a924 1
	if (IN_MULTICAST(sin->sin_addr.s_addr) && mopts != NULL) {
@


1.40.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.40.2.1 2001/05/14 22:40:08 niklas Exp $	*/
d36 1
a36 37
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
d39 12
d53 1
d58 3
d79 10
a562 12
	if (inp->inp_ipsec_localid)
		ipsp_reffree(inp->inp_ipsec_localid);
	if (inp->inp_ipsec_remoteid)
		ipsp_reffree(inp->inp_ipsec_remoteid);
	if (inp->inp_ipsec_localcred)
		ipsp_reffree(inp->inp_ipsec_localcred);
	if (inp->inp_ipsec_remotecred)
		ipsp_reffree(inp->inp_ipsec_remotecred);
	if (inp->inp_ipsec_localauth)
		ipsp_reffree(inp->inp_ipsec_localauth);
	if (inp->inp_ipsec_remoteauth)
		ipsp_reffree(inp->inp_ipsec_remoteauth);
@


1.40.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.40.2.2 2001/07/04 10:54:33 niklas Exp $	*/
a103 1
extern int ipsec_ipcomp_default_level;
a175 1
	inp->inp_seclevel[SL_IPCOMP] = ipsec_ipcomp_default_level;
@


1.40.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d406 78
d492 1
d546 8
d816 10
@


1.40.2.5
log
@Merge in -current from roughly a week ago
@
text
@d566 1
a566 1
	void (*notify)(struct inpcb *, int);
d614 1
a614 1
	void (*notify)(struct inpcb *, int);
@


1.40.2.6
log
@Sync the SMP branch with 3.3
@
text
@d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
d136 1
a136 1

d147 1
a147 1
		return (0);
d429 4
a432 7
	{
		int error; /* This is just ignored */

		/* Cause an IPsec SA to be established. */
		ipsp_spd_inp(NULL, AF_INET, 0, &error, IPSP_DIRECTION_OUT,
		    NULL, inp, NULL);
	}
a433 1
	return (0);
d476 1
a476 1
	else
d480 1
a480 1
	/* IPsec cleanup here */
d488 6
d496 2
a499 2
	if (inp->inp_ipo)
		ipsec_delete_policy(inp->inp_ipo);
d515 1
a515 1

d531 1
a531 1

d568 1
a568 1
	struct inpcb *inp, *oinp;
a571 2
	splassert(IPL_SOFTNET);

d675 1
a675 1
				rt->rt_gateway, rt_mask(rt), rt->rt_flags,
d677 1
a677 1
		else
d845 1
a845 1
	/*
d851 1
a851 1
		sin->sin_addr.s_addr ||
@


1.40.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.40.2.6 2003/03/28 00:06:54 niklas Exp $	*/
d131 1
a131 3
	table->inpt_hashtbl = hashinit(hashsize, M_PCB, M_NOWAIT, &table->inpt_hash);
	if (table->inpt_hashtbl == NULL)
		panic("in_pcbinit: hashinit failed");
@


1.40.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.40.2.7 2003/05/13 19:36:16 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.40.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a110 3
struct pool inpcb_pool;
int inpcb_pool_initalized = 0;

a119 3
#define	INPCBLHASH(table, lport) \
	&(table)->inpt_lhashtbl[lport & table->inpt_lhash]

d127 1
a127 2
	table->inpt_hashtbl = hashinit(hashsize, M_PCB, M_NOWAIT,
	    &table->inpt_hash);
a129 4
	table->inpt_lhashtbl = hashinit(hashsize, M_PCB, M_NOWAIT,
	    &table->inpt_lhash);
	if (table->inpt_lhashtbl == NULL)
		panic("in_pcbinit: hashinit failed for lport");
d163 1
a163 1
	struct inpcb *inp;
d166 1
a166 6
	if (inpcb_pool_initalized == 0) {
		pool_init(&inpcb_pool, sizeof(struct inpcb), 0, 0, 0,
		    "inpcbpl", NULL);
		inpcb_pool_initalized = 1;
	}
	inp = pool_get(&inpcb_pool, PR_NOWAIT);
a177 1
	LIST_INSERT_HEAD(INPCBLHASH(table, inp->inp_lport), inp, inp_lhash);
d199 1
a199 1
	void *v;
d202 3
a204 3
	struct inpcb *inp = v;
	struct socket *so = inp->inp_socket;
	struct inpcbtable *table = inp->inp_table;
d206 1
a206 1
	struct sockaddr_in *sin;
d258 1
a258 1
			    (error = suser(p, 0)))
d282 1
a282 1
			if ((error = suser(p, 0)))
d369 1
a369 1
	void *v;
d372 1
a372 1
	struct inpcb *inp = v;
d374 1
a374 1
	struct sockaddr_in *sin = mtod(nam, struct sockaddr_in *);
a498 1
	LIST_REMOVE(inp, inp_lhash);
d502 1
a502 1
	pool_put(&inpcb_pool, inp);
d507 1
a507 1
	struct inpcb *inp;
d510 1
a510 1
	struct sockaddr_in *sin;
d526 1
a526 1
	struct sockaddr_in *sin;
d555 1
a555 1
int
a566 1
	int nmatch = 0;
d579 1
a579 1
		return (0);
d582 1
a582 1
		return (0);
d584 2
a585 2
	for (inp = CIRCLEQ_FIRST(&table->inpt_queue);
	    inp != CIRCLEQ_END(&table->inpt_queue);) {
d588 1
a588 1
			inp = CIRCLEQ_NEXT(inp, inp_queue);
d597 1
a597 1
			inp = CIRCLEQ_NEXT(inp, inp_queue);
d601 1
a601 2
		inp = CIRCLEQ_NEXT(inp, inp_queue);
		nmatch++;
a604 1
	return (nmatch);
d614 1
a614 1
	struct inpcb *inp, *oinp;
d635 1
a635 1
			inp = CIRCLEQ_NEXT(inp, inp_queue);
d641 1
a641 1
			inp = CIRCLEQ_NEXT(inp, inp_queue);
d661 1
a661 1
	struct rtentry *rt;
d690 1
a690 1
	struct inpcb *inp;
d710 1
a710 1
	struct inpcb *inp, *match = 0;
d716 3
a718 2
	for (inp = LIST_FIRST(INPCBLHASH(table, lport)); inp;
	    inp = LIST_NEXT(inp, inp_lhash)) {
a925 2
	LIST_REMOVE(inp, inp_lhash);
	LIST_INSERT_HEAD(INPCBLHASH(table, inp->inp_lport), inp, inp_lhash);
a946 9
/*
 * The in(6)_pcbhashlookup functions are used to locate connected sockets
 * quickly:
 * 		faddr.fport <-> laddr.lport
 * No wildcard matching is done so that listening sockets are not found.
 * If the functions return NULL in(6)_pcblookup_listen can be used to
 * find a listening/bound socket that may accept the connection.
 * After those two lookups no other are necessary.
 */
d954 1
a954 1
	struct inpcb *inp;
d997 1
a997 1
	struct inpcb *inp;
d1021 1
a1021 1
		printf("in6_pcbhashlookup: faddr=");
a1029 89
/*
 * The in(6)_pcblookup_listen functions are used to locate listening
 * sockets quickly.  This are sockets with unspecified foreign address
 * and port:
 *		*.*     <-> laddr.lport
 *		*.*     <->     *.lport
 */
struct inpcb *
in_pcblookup_listen(table, laddr, lport_arg, reverse)
	struct inpcbtable *table;
	struct in_addr laddr;
	u_int lport_arg;
	int reverse;
{
	struct inpcbhead *head;
	struct in_addr *key1, *key2;
	struct inpcb *inp;
	u_int16_t lport = lport_arg;

	if (reverse) {
		key1 = &zeroin_addr;
		key2 = &laddr;
	} else {
		key1 = &laddr;
		key2 = &zeroin_addr;
	}

	head = INPCBHASH(table, &zeroin_addr, 0, key1, lport);
	LIST_FOREACH(inp, head, inp_hash) {
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			continue;	/*XXX*/
#endif
		if (inp->inp_lport == lport && inp->inp_fport == 0 &&
		    inp->inp_laddr.s_addr == key1->s_addr &&
		    inp->inp_faddr.s_addr == INADDR_ANY)
			break;
	}
	if (inp == NULL && key1->s_addr != key2->s_addr) {
		head = INPCBHASH(table, &zeroin_addr, 0, key2, lport);
		LIST_FOREACH(inp, head, inp_hash) {
#ifdef INET6
			if (inp->inp_flags & INP_IPV6)
				continue;	/*XXX*/
#endif
			if (inp->inp_lport == lport && inp->inp_fport == 0 &&
			    inp->inp_laddr.s_addr == key2->s_addr &&
			    inp->inp_faddr.s_addr == INADDR_ANY)
				break;
		}
	}
#ifdef DIAGNOSTIC
	if (inp == NULL && in_pcbnotifymiss) {
		printf("in_pcblookup_listen: laddr=%08x lport=%d\n",
		    ntohl(laddr.s_addr), ntohs(lport));
	}
#endif
	/*
	 * Move this PCB to the head of hash chain so that
	 * repeated accesses are quicker.  This is analogous to
	 * the historic single-entry PCB cache.
	 */
	if (inp != NULL && inp != head->lh_first) {
		LIST_REMOVE(inp, inp_hash);
		LIST_INSERT_HEAD(head, inp, inp_hash);
	}
	return (inp);
}

#ifdef INET6
struct inpcb *
in6_pcblookup_listen(table, laddr, lport_arg, reverse)
	struct inpcbtable *table;
	struct in6_addr *laddr;
	u_int lport_arg;
	int reverse;
{
	struct inpcbhead *head;
	struct in6_addr *key1, *key2;
	struct inpcb *inp;
	u_int16_t lport = lport_arg;

	if (reverse) {
		key1 = &zeroin6_addr;
		key2 = laddr;
	} else {
		key1 = laddr;
		key2 = &zeroin6_addr;
	}
a1030 38
	head = IN6PCBHASH(table, &zeroin6_addr, 0, key1, lport);
	LIST_FOREACH(inp, head, inp_hash) {
		if (!(inp->inp_flags & INP_IPV6))
			continue;
		if (inp->inp_lport == lport && inp->inp_fport == 0 &&
		    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, key1) &&
		    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
			break;
	}
	if (inp == NULL && ! IN6_ARE_ADDR_EQUAL(key1, key2)) {
		head = IN6PCBHASH(table, &zeroin6_addr, 0, key2, lport);
		LIST_FOREACH(inp, head, inp_hash) {
			if (!(inp->inp_flags & INP_IPV6))
				continue;
			if (inp->inp_lport == lport && inp->inp_fport == 0 &&
		    	    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, key2) &&
			    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
				break;
		}
	}
#ifdef DIAGNOSTIC
	if (inp == NULL && in_pcbnotifymiss) {
		printf("in6_pcblookup_listen: laddr= lport=%d\n",
		    ntohs(lport));
	}
#endif
	/*
	 * Move this PCB to the head of hash chain so that
	 * repeated accesses are quicker.  This is analogous to
	 * the historic single-entry PCB cache.
	 */
	if (inp != NULL && inp != head->lh_first) {
		LIST_REMOVE(inp, inp_hash);
		LIST_INSERT_HEAD(head, inp, inp_hash);
	}
	return (inp);
}
#endif /* INET6 */
@


1.40.2.10
log
@Merge with the trunk
@
text
@d696 1
a699 2
		 * rtfree() needs to be called in anycase because the inp
		 * is still holding a reference to rt.
d701 1
a701 1
		rtfree(rt);
@


1.40.2.11
log
@sync to head
@
text
@d844 1
a844 2
			satortin(&ro->ro_dst)->rtin_dst = inp->inp_faddr;
			satortin(&ro->ro_dst)->rtin_src = inp->inp_laddr;
@


1.39
log
@Remove PCB protocol checks rendered unnecessary by the previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.38 1999/12/19 01:51:32 angelos Exp $	*/
d595 1
a595 1
	if (sotopf(inp->inp_socket) == PF_INET6)
d597 2
@


1.38
log
@Be a bit more paranoid when searching for a PCB in the presence of IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.37 1999/12/17 22:47:04 itojun Exp $	*/
a824 5
#ifdef INET6
				if (inp->inp_flags & INP_IPV6)
					continue; /*XXX*/
				else
#endif
a833 5
#ifdef INET6
				if (inp->inp_flags & INP_IPV6)
					continue;	/*XXX*/
				else
#endif
@


1.37
log
@do not accept IPv4 traffic by AF_INET6 socket.  IPv4 mapped address is
bad for access controls.
(quickhack fix, need sysctl/setsockopt knob to enable this functionality)
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.36 1999/12/08 11:36:40 angelos Exp $	*/
d813 5
@


1.36
log
@Identation.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.35 1999/12/08 06:50:19 itojun Exp $	*/
d820 5
d834 5
d988 4
@


1.35
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.34 1999/05/16 21:48:29 niklas Exp $	*/
d778 8
a785 6
			 * Always skip AF_INET sockets when looking for AF_INET6
			 * addresses.  The only problem with this comes if the
			 * PF_INET6 addresses are v4-mapped addresses.  From what
			 * I've been able to see, none of the callers cause such
			 * a situation to occur.  If such a situation DID occur,
			 * then it is possible to miss a matching PCB.
@


1.34
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.33 1999/04/28 09:28:16 art Exp $	*/
d76 1
a76 1
#include <netinet6/ipv6_var.h>
d85 6
d174 1
a364 1
	struct in_ifaddr *ia;
a366 1
	struct sockaddr_in *sin2;
d394 1
d396 2
d457 1
a457 1
		    !(inp->inp_flags & INP_IPV6_MCAST)) {
d459 1
a459 1
		    inp->inp_moptions != NULL) {
d461 1
d477 10
d537 8
d552 2
a553 2
	if (inp->inp_flags & INP_IPV6_MCAST)
		ipv6_freemoptions(inp->inp_moptions6);
d555 1
a555 1
#endif /* INET6 */
d808 1
a808 1
		} else {
d810 1
a829 1
#ifdef INET6
a830 1
#endif /* INET6 */
d841 94
d1042 2
@


1.33
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.32 1999/03/27 21:04:18 provos Exp $	*/
d532 1
d535 1
@


1.32
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.31 1999/03/24 02:28:21 cmetz Exp $	*/
d116 1
a116 1
	table->inpt_hashtbl = hashinit(hashsize, M_PCB, &table->inpt_hash);
@


1.31
log
@Replace 'in6a_words' (old NRL convention) with 's6_addr32' (new BSDI et al.
convention that is more common and more specific as to the access size)
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.30 1999/02/24 22:32:57 angelos Exp $	*/
d532 2
@


1.30
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.29 1999/01/11 02:01:34 deraadt Exp $	*/
d105 2
a106 2
	&(table)->inpt_hashtbl[(ntohl((faddr)->in6a_words[0] ^ \
	(faddr)->in6a_words[3]) + ntohs((fport)) + ntohs((lport))) & \
@


1.29
log
@netinet merge of NRL stuff. some indent and shrinkage needed; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.28 1999/01/08 07:47:22 deraadt Exp $	*/
a79 1
#include <net/encap.h>
@


1.28
log
@remove NRL debugging goop; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.27 1999/01/07 21:50:51 deraadt Exp $	*/
a61 1
#ifdef INET6
a62 1
#endif /* INET6 */
d74 4
@


1.27
log
@INET6 support
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.26 1999/01/07 06:05:04 deraadt Exp $	*/
d62 3
a495 1
		DPRINTF(IDL_FINISHED,("In INET6 disconnect!"));
d742 2
a743 2
			struct in6_addr *laddr6 = (struct in6_addr *)laddr_arg;
			struct in6_addr *faddr6 = (struct in6_addr *)faddr_arg;
a887 5
	DPRINTF(IDL_FINISHED,
	    ("in6_pcbhashlookup(table=%08x, faddr=%08x, fport_arg=%x, "
	    "laddr=%08x, lport_arg=%x)\n", OSDEP_PCAST(table),
	    OSDEP_PCAST(faddr), fport_arg, OSDEP_PCAST(laddr), lport_arg));

a909 1
		DDO(IDL_MAJOR_EVENT, dump_in6_addr(faddr));
a910 1
		DDO(IDL_MAJOR_EVENT, dump_in6_addr(laddr));
@


1.26
log
@in_pcblookup() now takes ptr to both ip address arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.25 1999/01/07 05:44:31 deraadt Exp $	*/
d39 12
d97 7
a103 1
	&(table)->inpt_hashtbl[(ntohl((faddr)->s_addr) + ntohs((fport)) + ntohs((lport))) & (table->inpt_hash)]
d164 11
d193 5
d357 6
d408 7
d443 4
d448 1
d491 10
a500 1
	inp->inp_faddr.s_addr = INADDR_ANY;
d518 1
a518 1
		(void)m_free(inp->inp_options);
d521 6
a526 1
	ip_freemoptions(inp->inp_moptions);
d560 5
d598 8
d639 8
d738 14
a751 5
		if (inp->inp_faddr.s_addr != INADDR_ANY) {
			if (faddr.s_addr == INADDR_ANY)
				wildcard++;
			else if (inp->inp_faddr.s_addr != faddr.s_addr ||
			    inp->inp_fport != fport)
d753 21
d775 21
a795 11
			if (faddr.s_addr != INADDR_ANY)
				wildcard++;
		}
		if (inp->inp_laddr.s_addr != INADDR_ANY) {
			if (laddr.s_addr == INADDR_ANY)
				wildcard++;
			else if (inp->inp_laddr.s_addr != laddr.s_addr)
				continue;
		} else {
			if (laddr.s_addr != INADDR_ANY)
				wildcard++;
d797 1
d817 13
a829 2
	LIST_INSERT_HEAD(INPCBHASH(table, &inp->inp_faddr, inp->inp_fport,
	    &inp->inp_laddr, inp->inp_lport), inp, inp_hash);
d874 48
@


1.25
log
@rename baddynamic() to in_baddynamic(), and export it
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.24 1998/05/18 21:10:27 provos Exp $	*/
d208 2
a209 2
				t = in_pcblookup(table, zeroin_addr, 0,
				    sin->sin_addr, lport, INPLOOKUP_WILDCARD);
d213 2
a214 2
			t = in_pcblookup(table, zeroin_addr, 0,
			    sin->sin_addr, lport, wild);
d272 2
a273 2
			    in_pcblookup(table, zeroin_addr, 0,
			    inp->inp_laddr, lport, wild));
d299 2
a300 2
			    in_pcblookup(table, zeroin_addr, 0,
			    inp->inp_laddr, lport, wild));
d633 1
a633 1
in_pcblookup(table, faddr, fport_arg, laddr, lport_arg, flags)
d635 1
a635 1
	struct in_addr faddr, laddr;
d642 2
@


1.24
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.23 1998/02/14 18:50:35 mickey Exp $	*/
a86 2
static int baddynamic __P((u_int16_t, u_int16_t));

d103 2
a104 2
static int
baddynamic(port, proto)
d113 6
a118 6
		case IPPROTO_TCP:
			return (DP_ISSET(baddynamicports.tcp, port));
		case IPPROTO_UDP:
			return (DP_ISSET(baddynamicports.udp, port));
		default:
			return (0);
d271 1
a271 1
			} while (baddynamic(*lastport, so->so_proto->pr_protocol) ||
d298 1
a298 1
			} while (baddynamic(*lastport, so->so_proto->pr_protocol) ||
@


1.23
log
@wildcard ifaces; finally, after HE said it's ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.22 1998/02/14 10:55:10 deraadt Exp $	*/
d62 7
d71 3
a73 3
extern u_char ipsec_auth_default_level;
extern u_char ipsec_esp_trans_default_level;
extern u_char ipsec_esp_network_default_level;
d428 3
d432 1
@


1.22
log
@add seperate so_euid & so_ruid to struct socket, so that identd is still fast.. Sigh. I will change this again later
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.21 1998/02/01 21:46:02 deraadt Exp $	*/
d192 1
a192 1
			if (ifa_ifwithaddr(sintosa(sin)) == 0)
d659 2
a660 3
		if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
			continue;
		if (wildcard < matchwild) {
d662 1
a662 2
			matchwild = wildcard;
			if (matchwild == 0)
@


1.21
log
@undo wildcard loopback stuff; it was not checked by other developers
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.19 1997/11/30 06:10:43 deraadt Exp $	*/
d202 1
a202 1
			if (so->so_uid) {
d205 1
a205 1
				if (t && (so->so_uid != t->inp_socket->so_uid))
@


1.20
log
@support wildcard loopbacks. that is, setting up lo1 like:
ifconfig lo1 inet 192.168.1.1 netmask 255.255.255.0 link1
would force it to act like all the addresses from net 192.168.1 were
added to the interface.
todo: man lo
@
text
@d192 1
a192 1
			if (in_iawithaddr(sin->sin_addr, NULL) == 0)
d209 1
a209 1
					 sin->sin_addr, lport, wild);
d268 1
a268 1
					 inp->inp_laddr, lport, wild));
d295 1
a295 1
			    		 inp->inp_laddr, lport, wild));
d659 3
a661 2
		if ((!wildcard || (flags & INPLOOKUP_WILDCARD)) &&
		    wildcard < matchwild) {
d663 2
a664 1
			if ((matchwild = wildcard) == 0)
@


1.19
log
@hmm. If out of ports, return EADDRNOTAVAIL
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.18 1997/08/09 23:36:26 millert Exp $	*/
d192 1
a192 1
			if (ifa_ifwithaddr(sintosa(sin)) == 0)
d209 1
a209 1
			    sin->sin_addr, lport, wild);
d268 1
a268 1
			    inp->inp_laddr, lport, wild));
d295 1
a295 1
			    inp->inp_laddr, lport, wild));
d659 2
a660 3
		if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
			continue;
		if (wildcard < matchwild) {
d662 1
a662 2
			matchwild = wildcard;
			if (matchwild == 0)
@


1.18
log
@The list of tcp/udp ports not to allocate dynamically is now
a bitmask configurable via sysctl([38]).  The default values
have not changed.  If one wants to change the list it should
be done early on in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.17 1997/07/27 08:11:10 deraadt Exp $	*/
d413 3
a415 2
		if (inp->inp_lport == 0)
			(void)in_pcbbind(inp, (struct mbuf *)0);
@


1.17
log
@hardcode list of ports to not randomly allocate; will add configuration later
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.16 1997/04/17 02:02:26 deraadt Exp $	*/
d80 1
a80 1
static int baddynamic __P((u_int16_t));
d93 2
a94 9
/*
 * List of standard locked-down reserved ports.
 * XXX need to be able to modify this from userland. 
 */
static u_int16_t baddynamicports[] = {
	765, 749, 750, 751, 760, 761, 871,
	0	/* terminator */
};

d99 1
a99 1
baddynamic(port)
d101 1
a102 1
	int i;
d104 11
a114 4
	for (i = 0; baddynamicports[i] != 0; i++)
		if (baddynamicports[i] == port)
			return (1);
	return (0);
d266 1
a266 1
			} while (baddynamic(*lastport) ||
d293 1
a293 1
			} while (baddynamic(*lastport) ||
@


1.16
log
@make unconnected sockets get a random port #, too
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.15 1997/02/28 04:03:47 angelos Exp $	*/
d80 2
d93 24
d266 2
a267 1
			} while (in_pcblookup(table, zeroin_addr, 0,
d293 2
a294 1
			} while (in_pcblookup(table, zeroin_addr, 0,
@


1.15
log
@Moved IPsec socket state to the PCB.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.14 1997/02/05 15:48:23 deraadt Exp $	*/
d200 2
a201 9
			first = IPPORT_RESERVED - 1;	/* 1023 */
#if 0
			/* traditional way */
			last = IPPORT_RESERVED / 2;	/* traditional - 512 */
#else
			/* our way */
			last = 600;
#endif
			*lastport = first;		/* restart each time */
d206 1
d225 1
a231 1

d240 2
a241 2
			} while (in_pcblookup(table,
				 zeroin_addr, 0, inp->inp_laddr, lport, wild));
d251 1
a257 1

d266 2
a267 2
			} while (in_pcblookup(table,
				 zeroin_addr, 0, inp->inp_laddr, lport, wild));
@


1.14
log
@use arc4random()
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.13 1997/01/15 03:27:14 kstailey Exp $	*/
d64 4
d106 3
d429 3
@


1.13
log
@prevent warning:
in_pcb.c:182: warning: `old' might be used uninitialized in this function
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.12 1996/08/24 04:56:39 deraadt Exp $	*/
d60 1
d221 1
a221 1
				first -= (random() % (first - last));
d247 1
a247 1
				first += (random() % (last - first));
@


1.12
log
@change to so_uid, also fix a missing credential found by dm
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.11 1996/08/05 01:17:25 deraadt Exp $	*/
d182 1
a182 1
		u_int16_t first, last, old;
@


1.11
log
@stupid typo, going to bed in penance
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.10 1996/08/05 01:16:45 deraadt Exp $	*/
d168 1
a168 1
			if (so->so_ucred->cr_uid) {
d171 1
a171 2
				if (t && (so->so_ucred->cr_uid !=
				    t->inp_socket->so_ucred->cr_uid))
@


1.10
log
@only check for takeover permission if non-root
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.9 1996/08/05 01:00:57 deraadt Exp $	*/
d168 1
a168 1
			if (so->so_ucred->cr_uid)
@


1.9
log
@struct socket gets so_ucred; permit only same uid or root to do port takeover.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.8 1996/07/29 07:54:58 downsj Exp $	*/
d168 7
a174 5
			t = in_pcblookup(table, zeroin_addr, 0,
			    sin->sin_addr, lport, INPLOOKUP_WILDCARD);
			if (t && so->so_ucred->cr_uid && (so->so_ucred->cr_uid
			    != t->inp_socket->so_ucred->cr_uid))
				return (EADDRINUSE);
@


1.8
log
@Fix stupid logic error in bind().
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.7 1996/07/29 05:03:33 downsj Exp $	*/
d168 4
a171 7
			/*
			 * treat port 2049 as a reserved port, but indicate
			 * that it is used to not confuse a bindresvport()
			 * type function
			 */
			if (ntohs(lport) == 2049 &&
			    suser(p->p_ucred, &p->p_acflag))
d613 1
a613 1
					wildcard++;
@


1.7
log
@Make 600, instead of 512, the lower limit for reserved ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.6 1996/07/29 04:47:21 downsj Exp $	*/
d221 2
a222 2
				old = last;
				last += (random() % (first - last));
a247 1

@


1.6
log
@Fix a small bug and change the logic of the bind() port choosing:
Use a random starting point the first time through the loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.5 1996/07/29 02:34:29 downsj Exp $	*/
d195 2
d198 4
@


1.5
log
@From FreeBSD (with slightly different sysctl names):

"... Allow the user to nominate one of three ranges of port numbers as
candidates for selecting a local address to replace a zero port number.
The ranges are selected via a setsockopt(s, IPPROTO_IP, IP_PORTRANGE, &arg)
call.  The three ranges are: default, high (to bypass firewalls) and
low (to get a port below 1024).

The default and high port ranges are sysctl settable under sysctl
net.inet.ip.portrange.* [net.inet.ip.portfirst, net.inet.ip.portlast,
net.inet.ip.porthifirst, and net.inet.ip.porthilast currently in OpenBSD.]

This code also fixes a potential deadlock if the system accidently ran out
of local port addresses. It'd drop into an infinite while loop.

The secure port selection (for root) should reduce overheads and increase
reliability of rlogin/rlogind/rsh/rshd if they are modified to take
advantage of it."
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.4 1996/05/14 19:37:34 deraadt Exp $	*/
d184 1
a184 1
		ushort first, last;
d186 1
d208 2
d214 4
d221 7
a227 1
				if (count-- <= 0)	/* completely used? */
d229 1
d240 5
d248 7
a254 1
				if (count-- <= 0)	/* completely used? */
d256 1
@


1.4
log
@non-root bind() to 2049 gets EADDRINUSE
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.c,v 1.2 1996/03/03 22:30:31 niklas Exp $	*/
d63 9
d118 1
d183 56
a238 8
	if (lport == 0)
		do {
			if (table->inpt_lastport++ < IPPORT_RESERVED ||
			    table->inpt_lastport > IPPORT_USERRESERVED)
				table->inpt_lastport = IPPORT_RESERVED;
			lport = htons(table->inpt_lastport);
		} while (in_pcblookup(table,
			    zeroin_addr, 0, inp->inp_laddr, lport, wild));
@


1.3
log
@From Lite2; we should fail a malloc, not block waiting for memory to become
available in in_pcballoc()
@
text
@d158 8
d527 1
a527 1
				wildcard++;
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
a86 1
	MALLOC(inp, struct inpcb *, sizeof(*inp), M_PCB, M_WAITOK);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: in_pcb.c,v 1.23 1995/08/17 02:57:27 mycroft Exp $	*/
d63 3
d67 1
a67 1
in_pcbinit(table)
d69 1
d73 1
d78 1
a78 1
in_pcballoc(so, table)
d80 1
a80 1
	struct inpcbtable *table;
d82 1
d84 1
d92 1
d94 3
d102 2
a103 2
in_pcbbind(inp, nam)
	register struct inpcb *inp;
d106 1
d174 1
d185 2
a186 2
in_pcbconnect(inp, nam)
	register struct inpcb *inp;
d189 1
d191 1
a191 1
	struct sockaddr_in *ifaddr;
d283 1
a283 3
	if (in_pcblookup(inp->inp_table,
	    sin->sin_addr,
	    sin->sin_port,
d285 1
a285 2
	    inp->inp_lport,
	    0))
d294 1
d298 3
a300 3
int
in_pcbdisconnect(inp)
	struct inpcb *inp;
d302 1
d306 1
d311 3
a313 3
int
in_pcbdetach(inp)
	struct inpcb *inp;
d315 1
d317 1
d326 2
d329 1
d333 1
a333 1
int
d349 1
a349 1
int
d448 1
a448 1
int
d511 2
a512 2
		if (inp->inp_laddr.s_addr != INADDR_ANY) {
			if (laddr.s_addr == INADDR_ANY)
d514 2
a515 1
			else if (inp->inp_laddr.s_addr != laddr.s_addr)
d518 1
a518 1
			if (laddr.s_addr != INADDR_ANY)
d521 2
a522 2
		if (inp->inp_faddr.s_addr != INADDR_ANY) {
			if (faddr.s_addr == INADDR_ANY)
d524 1
a524 2
			else if (inp->inp_faddr.s_addr != faddr.s_addr ||
			    inp->inp_fport != fport)
d527 1
a527 1
			if (faddr.s_addr != INADDR_ANY)
d540 56
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
