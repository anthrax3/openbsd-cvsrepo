head	1.104;
access;
symbols
	OPENBSD_6_1:1.104.0.4
	OPENBSD_6_1_BASE:1.104
	OPENBSD_6_0:1.102.0.4
	OPENBSD_6_0_BASE:1.102
	OPENBSD_5_9:1.93.0.2
	OPENBSD_5_9_BASE:1.93
	OPENBSD_5_8:1.89.0.4
	OPENBSD_5_8_BASE:1.89
	OPENBSD_5_7:1.87.0.2
	OPENBSD_5_7_BASE:1.87
	OPENBSD_5_6:1.86.0.4
	OPENBSD_5_6_BASE:1.86
	OPENBSD_5_5:1.82.0.4
	OPENBSD_5_5_BASE:1.82
	OPENBSD_5_4:1.79.0.2
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.75.0.2
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.72.0.2
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.71
	OPENBSD_5_1:1.71.0.4
	OPENBSD_5_0:1.71.0.2
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.70.0.2
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.69.0.2
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.67.0.4
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.66.0.4
	OPENBSD_4_5_BASE:1.66
	OPENBSD_4_4:1.66.0.2
	OPENBSD_4_4_BASE:1.66
	OPENBSD_4_3:1.59.0.6
	OPENBSD_4_3_BASE:1.59
	OPENBSD_4_2:1.59.0.4
	OPENBSD_4_2_BASE:1.59
	OPENBSD_4_1:1.59.0.2
	OPENBSD_4_1_BASE:1.59
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.52.0.2
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.51.0.6
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.51.0.4
	OPENBSD_3_7_BASE:1.51
	OPENBSD_3_6:1.51.0.2
	OPENBSD_3_6_BASE:1.51
	SMP_SYNC_A:1.50
	SMP_SYNC_B:1.49
	OPENBSD_3_5:1.49.0.2
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.45.0.2
	OPENBSD_3_4_BASE:1.45
	UBC_SYNC_A:1.44
	OPENBSD_3_3:1.44.0.4
	OPENBSD_3_3_BASE:1.44
	OPENBSD_3_2:1.44.0.2
	OPENBSD_3_2_BASE:1.44
	OPENBSD_3_1:1.40.0.2
	OPENBSD_3_1_BASE:1.40
	UBC_SYNC_B:1.44
	UBC:1.38.0.4
	UBC_BASE:1.38
	OPENBSD_3_0:1.38.0.2
	OPENBSD_3_0_BASE:1.38
	OPENBSD_2_9_BASE:1.33
	OPENBSD_2_9:1.33.0.2
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.22.0.2
	SMP_BASE:1.22
	kame_19991208:1.18
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.104
date	2016.09.03.14.18.42;	author phessler;	state Exp;
branches;
next	1.103;
commitid	skLnJYKwA51LkD1n;

1.103
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.102;
commitid	nbCHuHn2E9uBfKJT;

1.102
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.101;
commitid	Cm0qxR09oTCkXjXZ;

1.101
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.100;
commitid	jodmGXAB42f8N6nf;

1.100
date	2016.06.27.16.33.48;	author jca;	state Exp;
branches;
next	1.99;
commitid	s8BpQvqrMutiVjd6;

1.99
date	2016.06.18.10.36.13;	author vgross;	state Exp;
branches;
next	1.98;
commitid	r16P5gVURcjZa76o;

1.98
date	2016.04.11.21.24.29;	author vgross;	state Exp;
branches;
next	1.97;
commitid	KN7g5vtebtPTCcjK;

1.97
date	2016.04.05.19.34.05;	author vgross;	state Exp;
branches;
next	1.96;
commitid	wDN5EGniV99A0gDC;

1.96
date	2016.03.23.15.50.36;	author vgross;	state Exp;
branches;
next	1.95;
commitid	iMWKOVeEybjVAEfv;

1.95
date	2016.03.23.00.07.31;	author vgross;	state Exp;
branches;
next	1.94;
commitid	1WuXi1AsK2Cl7cAo;

1.94
date	2016.03.21.21.21.35;	author vgross;	state Exp;
branches;
next	1.93;
commitid	kJec2D6LBVBbvezW;

1.93
date	2015.12.03.10.34.24;	author tedu;	state Exp;
branches;
next	1.92;
commitid	gajQhAV7FbVEB3lm;

1.92
date	2015.12.02.22.13.44;	author vgross;	state Exp;
branches;
next	1.91;
commitid	Qc8hTbFRvzRyD1WZ;

1.91
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.90;
commitid	xFxvBxiFybIsZNMc;

1.90
date	2015.09.22.09.34.39;	author vgross;	state Exp;
branches;
next	1.89;
commitid	S3cAlx4uzc9zehGV;

1.89
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.88;
commitid	2c41FFL8044mZVko;

1.88
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.87;
commitid	bQi1IVHgugweH5gs;

1.87
date	2014.11.15.10.55.47;	author dlg;	state Exp;
branches;
next	1.86;
commitid	dnbbVVnOgRkrlZ0W;

1.86
date	2014.07.12.21.06.34;	author yasuoka;	state Exp;
branches;
next	1.85;
commitid	LARYP0a27ik2w0nd;

1.85
date	2014.04.18.10.48.29;	author jca;	state Exp;
branches;
next	1.84;

1.84
date	2014.04.16.13.04.38;	author mpi;	state Exp;
branches;
next	1.83;

1.83
date	2014.04.06.17.13.23;	author chrisz;	state Exp;
branches;
next	1.82;

1.82
date	2013.12.20.02.04.08;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2013.10.23.19.57.50;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2013.10.20.11.03.00;	author phessler;	state Exp;
branches;
next	1.79;

1.79
date	2013.05.31.13.15.53;	author bluhm;	state Exp;
branches;
next	1.78;

1.78
date	2013.05.17.09.04.30;	author mpi;	state Exp;
branches;
next	1.77;

1.77
date	2013.03.29.13.16.14;	author bluhm;	state Exp;
branches;
next	1.76;

1.76
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.75;

1.75
date	2013.01.16.00.07.22;	author bluhm;	state Exp;
branches;
next	1.74;

1.74
date	2012.10.21.13.06.03;	author benno;	state Exp;
branches;
next	1.73;

1.73
date	2012.09.17.20.01.26;	author yasuoka;	state Exp;
branches;
next	1.72;

1.72
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2011.06.15.09.11.01;	author mikeb;	state Exp;
branches;
next	1.70;

1.70
date	2010.09.23.04.45.15;	author yasuoka;	state Exp;
branches;
next	1.69;

1.69
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2008.07.10.02.19.28;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2008.07.09.20.20.46;	author djm;	state Exp;
branches;
next	1.64;

1.64
date	2008.07.03.15.46.24;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.62;

1.62
date	2008.05.15.19.40.38;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2008.05.09.02.56.36;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.22.20.23.07;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.57;

1.57
date	2006.10.11.09.34.51;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.11.09.29.20;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2006.09.26.21.10.53;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.30.19.26.57;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.29.20.42.27;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2005.12.10.01.30.14;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2004.08.10.20.12.15;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.12.04.36.13;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.21.15.12.27;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.08.07.07.36;	author mcbride;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.04.21.43.16;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.25.12.15.24;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.04.07.26.53;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.08.21.22.02;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.31.02.39.25;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.14.03.16.11;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.05.08.31.47;	author jjbg;	state Exp;
branches
	1.38.4.1;
next	1.37;

1.37
date	2001.06.12.10.59.53;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.09.07.03.40;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.27.03.53.09;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.21.03.02.18;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.28.20.03.02;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2001.02.16.16.00.53;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.16.14.45.11;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2001.02.08.18.46.22;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.11.09.14.11;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.10.15.16.02;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.09.14.39.46;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.18.22.06.37;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.18.17.32.48;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.13.10.12.00;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.27.15.41.06;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.07.06.09.09;	author itojun;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.01.11.01.13.49;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	99.12.27.06.40.38;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	99.12.12.12.10.43;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	99.03.27.21.04.19;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	99.03.24.02.33.02;	author cmetz;	state Exp;
branches;
next	1.15;

1.15
date	99.01.11.02.01.34;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.01.08.07.47.54;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.01.07.21.50.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.01.07.06.05.04;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.01.07.05.44.32;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.05.18.21.10.28;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.08.26.20.02.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.19.06.29.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.08.19.04.54.52;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.08.16.16.49.42;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.08.09.23.36.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.28.04.03.48;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.02.34.30;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.22.30.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches;
next	;

1.22.2.1
date	2001.05.14.22.40.08;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.07.04.10.54.34;	author niklas;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2004.06.13.08.50.18;	author niklas;	state Exp;
branches;
next	;

1.38.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.38.4.2;

1.38.4.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	;


desc
@@


1.104
log
@Reserve the BFD destination ports in baddynamic

OK claudio@@, henning@@
@
text
@/*	$OpenBSD: in_pcb.h,v 1.103 2016/08/04 20:46:24 vgross Exp $	*/
/*	$NetBSD: in_pcb.h,v 1.14 1996/02/13 23:42:00 christos Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in_pcb.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET_IN_PCB_H_
#define _NETINET_IN_PCB_H_

#include <sys/queue.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet/ip_ipsp.h>

#include <crypto/siphash.h>

struct pf_state_key;

union inpaddru {
	struct in6_addr iau_addr6;
	struct {
		uint8_t pad[12];
		struct in_addr inaddr;	/* easier transition */
	} iau_a4u;
};

/*
 * Common structure pcb for internet protocol implementation.
 * Here are stored pointers to local and foreign host table
 * entries, local and foreign socket numbers, and pointers
 * up (to a socket structure) and down (to a protocol-specific)
 * control block.
 */
struct inpcb {
	LIST_ENTRY(inpcb) inp_hash;
	LIST_ENTRY(inpcb) inp_lhash;		/* extra hash for lport */
	TAILQ_ENTRY(inpcb) inp_queue;
	struct	  inpcbtable *inp_table;
	union	  inpaddru inp_faddru;		/* Foreign address. */
	union	  inpaddru inp_laddru;		/* Local address. */
#define	inp_faddr	inp_faddru.iau_a4u.inaddr
#define	inp_faddr6	inp_faddru.iau_addr6
#define	inp_laddr	inp_laddru.iau_a4u.inaddr
#define	inp_laddr6	inp_laddru.iau_addr6
	u_int16_t inp_fport;		/* foreign port */
	u_int16_t inp_lport;		/* local port */
	struct	  socket *inp_socket;	/* back pointer to socket */
	caddr_t	  inp_ppcb;		/* pointer to per-protocol pcb */
	union {				/* Route (notice increased size). */
		struct route ru_route;
		struct route_in6 ru_route6;
	} inp_ru;
#define	inp_route	inp_ru.ru_route
#define	inp_route6	inp_ru.ru_route6
	int	  inp_flags;		/* generic IP/datagram flags */
	union {				/* Header prototype. */
		struct ip hu_ip;
		struct ip6_hdr hu_ipv6;
	} inp_hu;
#define	inp_ip		inp_hu.hu_ip
#define	inp_ipv6	inp_hu.hu_ipv6
	struct	  mbuf *inp_options;	/* IP options */
	struct ip6_pktopts *inp_outputopts6; /* IP6 options for outgoing packets */
	int inp_hops;
	union {
		struct ip_moptions *mou_mo;    /* IPv4 multicast options */
		struct ip6_moptions *mou_mo6; /* IPv6 multicast options */
	} inp_mou;
#define inp_moptions inp_mou.mou_mo
#define inp_moptions6 inp_mou.mou_mo6
	u_char	  inp_seclevel[4];
#define SL_AUTH           0             /* Authentication level */
#define SL_ESP_TRANS      1             /* ESP transport level */
#define SL_ESP_NETWORK    2             /* ESP network (encapsulation) level */
#define SL_IPCOMP         3             /* Compression level */
	u_char	inp_ip_minttl;		/* minimum TTL or drop */
#define inp_ip6_minhlim inp_ip_minttl	/* minimum Hop Limit or drop */
#define	inp_flowinfo	inp_hu.hu_ipv6.ip6_flow

	int	inp_cksum6;
#ifndef _KERNEL
#define inp_csumoffset	inp_cksum6
#endif
	struct	icmp6_filter *inp_icmp6filt;
	struct	pf_state_key *inp_pf_sk;
	u_int	inp_rtableid;
	int	inp_pipex;		/* pipex indication */
	int	inp_divertfl;		/* divert flags */
};

LIST_HEAD(inpcbhead, inpcb);

struct inpcbtable {
	TAILQ_HEAD(inpthead, inpcb) inpt_queue;
	struct inpcbhead *inpt_hashtbl, *inpt_lhashtbl;
	SIPHASH_KEY inpt_key;
	u_long	  inpt_hash, inpt_lhash;
	int	  inpt_count;
};

/* flags in inp_flags: */
#define	INP_RECVOPTS	0x001	/* receive incoming IP options */
#define	INP_RECVRETOPTS	0x002	/* receive IP options for reply */
#define	INP_RECVDSTADDR	0x004	/* receive IP dst address */

#define	INP_RXDSTOPTS	INP_RECVOPTS
#define	INP_RXHOPOPTS	INP_RECVRETOPTS
#define	INP_RXINFO	INP_RECVDSTADDR
#define	INP_RXSRCRT	0x010
#define	INP_HOPLIMIT	0x020

#define	INP_HDRINCL	0x008	/* user supplies entire IP header */
#define	INP_HIGHPORT	0x010	/* user wants "high" port binding */
#define	INP_LOWPORT	0x020	/* user wants "low" port binding */
#define	INP_RECVIF	0x080	/* receive incoming interface */
#define	INP_RECVTTL	0x040	/* receive incoming IP TTL */
#define	INP_RECVDSTPORT	0x200	/* receive IP dst addr before rdr */
#define	INP_RECVRTABLE	0x400	/* receive routing table */
#define	INP_IPSECFLOWINFO 0x800	/* receive IPsec flow info */

#define	INP_CONTROLOPTS	(INP_RECVOPTS|INP_RECVRETOPTS|INP_RECVDSTADDR| \
	    INP_RXSRCRT|INP_HOPLIMIT|INP_RECVIF|INP_RECVTTL|INP_RECVDSTPORT| \
	    INP_RECVRTABLE)

/*
 * These flags' values should be determined by either the transport
 * protocol at PRU_BIND, PRU_LISTEN, PRU_CONNECT, etc, or by in_pcb*().
 */
#define	INP_IPV6	0x100	/* sotopf(inp->inp_socket) == PF_INET6 */

/*
 * Flags in inp_flags for IPV6
 */
#define IN6P_HIGHPORT		INP_HIGHPORT	/* user wants "high" port */
#define IN6P_LOWPORT		INP_LOWPORT	/* user wants "low" port */
#define IN6P_RECVDSTPORT	INP_RECVDSTPORT	/* receive IP dst addr before rdr */
#define IN6P_PKTINFO		0x010000 /* receive IP6 dst and I/F */
#define IN6P_HOPLIMIT		0x020000 /* receive hoplimit */
#define IN6P_HOPOPTS		0x040000 /* receive hop-by-hop options */
#define IN6P_DSTOPTS		0x080000 /* receive dst options after rthdr */
#define IN6P_RTHDR		0x100000 /* receive routing header */
#define IN6P_TCLASS		0x400000 /* receive traffic class value */
#define IN6P_AUTOFLOWLABEL	0x800000 /* attach flowlabel automatically */

#define IN6P_ANONPORT		0x4000000 /* port chosen for user */
#define IN6P_RFC2292		0x40000000 /* used RFC2292 API on the socket */
#define IN6P_MTU		0x80000000 /* receive path MTU */

#define IN6P_MINMTU		0x20000000 /* use minimum MTU */

#define IN6P_CONTROLOPTS	(IN6P_PKTINFO|IN6P_HOPLIMIT|IN6P_HOPOPTS|\
				 IN6P_DSTOPTS|IN6P_RTHDR|\
				 IN6P_TCLASS|IN6P_AUTOFLOWLABEL|IN6P_RFC2292|\
				 IN6P_MTU|IN6P_RECVDSTPORT)

#define	INPLOOKUP_WILDCARD	1
#define	INPLOOKUP_SETLOCAL	2
#define	INPLOOKUP_IPV6		4

#define	sotoinpcb(so)	((struct inpcb *)(so)->so_pcb)

/* macros for handling bitmap of ports not to allocate dynamically */
#define	DP_MAPBITS	(sizeof(u_int32_t) * NBBY)
#define	DP_MAPSIZE	(howmany(65536, DP_MAPBITS))
#define	DP_SET(m, p)	((m)[(p) / DP_MAPBITS] |= (1 << ((p) % DP_MAPBITS)))
#define	DP_CLR(m, p)	((m)[(p) / DP_MAPBITS] &= ~(1 << ((p) % DP_MAPBITS)))
#define	DP_ISSET(m, p)	((m)[(p) / DP_MAPBITS] & (1 << ((p) % DP_MAPBITS)))

/* default values for baddynamicports [see ip_init()] */
#define	DEFBADDYNAMICPORTS_TCP	{ \
	587, 749, 750, 751, 871, 2049, \
	6000, 6001, 6002, 6003, 6004, 6005, 6006, 6007, 6008, 6009, 6010, \
	0 }
#define	DEFBADDYNAMICPORTS_UDP	{ 623, 664, 749, 750, 751, 2049, \
	3784, 3785, 7784, /* BFD/S-BFD ports */ \
	 0 }

#define DEFROOTONLYPORTS_TCP { \
	2049, \
	0 }
#define DEFROOTONLYPORTS_UDP { \
	2049, \
	0 }

struct baddynamicports {
	u_int32_t tcp[DP_MAPSIZE];
	u_int32_t udp[DP_MAPSIZE];
};

#ifdef _KERNEL

extern struct baddynamicports baddynamicports;
extern struct baddynamicports rootonlyports;

#define sotopf(so)  (so->so_proto->pr_domain->dom_family)

void	 in_losing(struct inpcb *);
int	 in_pcballoc(struct socket *, struct inpcbtable *);
int	 in_pcbbind(struct inpcb *, struct mbuf *, struct proc *);
int	 in_pcbaddrisavail(struct inpcb *, struct sockaddr_in *, int,
	    struct proc *);
int	 in_pcbconnect(struct inpcb *, struct mbuf *);
void	 in_pcbdetach(struct inpcb *);
void	 in_pcbdisconnect(struct inpcb *);
struct inpcb *
	 in_pcbhashlookup(struct inpcbtable *, struct in_addr,
			       u_int, struct in_addr, u_int, u_int);
struct inpcb *
	 in_pcblookup_listen(struct inpcbtable *, struct in_addr, u_int, int,
	    struct mbuf *, u_int);
#ifdef INET6
struct inpcb *
	 in6_pcbhashlookup(struct inpcbtable *, const struct in6_addr *,
			       u_int, const struct in6_addr *, u_int, u_int);
struct inpcb *
	 in6_pcblookup_listen(struct inpcbtable *,
			       struct in6_addr *, u_int, int, struct mbuf *,
			       u_int);
int	 in6_pcbaddrisavail(struct inpcb *, struct sockaddr_in6 *, int,
	    struct proc *);
int	 in6_pcbconnect(struct inpcb *, struct mbuf *);
int	 in6_setsockaddr(struct inpcb *, struct mbuf *);
int	 in6_setpeeraddr(struct inpcb *, struct mbuf *);
#endif /* INET6 */
void	 in_pcbinit(struct inpcbtable *, int);
struct inpcb *
	 in_pcblookup_local(struct inpcbtable *, void *, u_int, int, u_int);
void	 in_pcbnotifyall(struct inpcbtable *, struct sockaddr *,
	    u_int, int, void (*)(struct inpcb *, int));
void	 in_pcbrehash(struct inpcb *);
void	 in_rtchange(struct inpcb *, int);
void	 in_setpeeraddr(struct inpcb *, struct mbuf *);
void	 in_setsockaddr(struct inpcb *, struct mbuf *);
int	 in_baddynamic(u_int16_t, u_int16_t);
int	 in_rootonly(u_int16_t, u_int16_t);
int	 in_pcbselsrc(struct in_addr **, struct sockaddr_in *, struct inpcb *);
struct rtentry *
	in_pcbrtentry(struct inpcb *);

/* INET6 stuff */
int	in6_pcbnotify(struct inpcbtable *, struct sockaddr_in6 *,
	u_int, const struct sockaddr_in6 *, u_int, u_int, int, void *,
	void (*)(struct inpcb *, int));
int	in6_selecthlim(struct inpcb *);
int	in_pcbpickport(u_int16_t *, void *, int, struct inpcb *, struct proc *);
#endif /* _KERNEL */
#endif /* _NETINET_IN_PCB_H_ */
@


1.103
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.102 2016/07/22 11:14:41 mpi Exp $	*/
d232 3
a234 1
#define	DEFBADDYNAMICPORTS_UDP	{ 623, 664, 749, 750, 751, 2049, 0 }
@


1.102
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.100 2016/06/27 16:33:48 jca Exp $	*/
d292 1
a292 2
int	 in_selectsrc(struct in_addr **, struct sockaddr_in *,
	    struct ip_moptions *, struct route *, struct in_addr *, u_int);
@


1.101
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@d292 2
a293 1
int	 in_pcbselsrc(struct in_addr **, struct sockaddr_in *, struct inpcb *);
@


1.100
log
@Implement IPV6_MINHOPCOUNT support.

Useful to implement GTSM support in daemons such as bgpd(8). Diff from
2013 revived by renato@@.  Input from bluhm@@, ok bluhm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.99 2016/06/18 10:36:13 vgross Exp $	*/
d292 1
a292 2
int	 in_selectsrc(struct in_addr **, struct sockaddr_in *,
	    struct ip_moptions *, struct route *, struct in_addr *, u_int);
@


1.99
log
@Add net.inet.{tcp,udp}.rootonly sysctl, to mark which ports
cannot be bound to by non-root users.

Ok millert@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.98 2016/04/11 21:24:29 vgross Exp $	*/
d135 1
@


1.98
log
@Rename in_pcblookup() to in_pcblookup_local() and change its prototype
to get rid of the now useless foreign address and ports parameters.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.97 2016/04/05 19:34:05 vgross Exp $	*/
d233 7
d248 1
d290 1
@


1.97
log
@Move inp_laddr assignment after in_pcbpickport(), extend in_pcbpickport()
as needed.

Ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.96 2016/03/23 15:50:36 vgross Exp $	*/
d274 1
a274 2
	 in_pcblookup(struct inpcbtable *, void *, u_int, void *,
	    u_int, int, u_int);
@


1.96
log
@Merge in_pcbbind() and in6_pcbbind(), and change every call to
in6_pcbbind() into in_pcbbind().

Ok jca@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.95 2016/03/23 00:07:31 vgross Exp $	*/
d293 1
a293 1
int	in_pcbpickport(u_int16_t *, int, struct inpcb *, struct proc *);
@


1.95
log
@Extract in_pcbaddrisavail() from in_pcbbind().

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.94 2016/03/21 21:21:35 vgross Exp $	*/
a265 1
int	 in6_pcbbind(struct inpcb *, struct mbuf *, struct proc *);
@


1.94
log
@Extract in6_pcbaddrisavail() from in6_pcbbind(), and use it when
checking for source availability in udp6_output(); This time with
all the files.

Ok jca@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.93 2015/12/03 10:34:24 tedu Exp $	*/
d247 2
@


1.93
log
@rm unused kernel only IPV6_RECVRTHDRDSTOPTS sockopt. ok deraadt sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.92 2015/12/02 22:13:44 vgross Exp $	*/
d265 2
@


1.92
log
@Move port picking away from in_pcbbind()

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.91 2015/10/24 16:08:48 mpi Exp $	*/
a198 1
#define IN6P_RTHDRDSTOPTS	0x200000 /* receive dstoptions before rthdr */
d209 1
a209 1
				 IN6P_DSTOPTS|IN6P_RTHDR|IN6P_RTHDRDSTOPTS|\
@


1.91
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.90 2015/09/22 09:34:39 vgross Exp $	*/
d291 1
a291 1
int	in6_pcbsetport(struct in6_addr *, struct inpcb *, struct proc *);
@


1.90
log
@Remove inpt_lastport from struct inpcbtable, use local variables
in in_pcbbind() and in6_pcbsetport()

ok claudio@@, with input from David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.89 2015/04/16 19:24:13 markus Exp $	*/
d290 1
a290 1
int	in6_selecthlim(struct inpcb *, struct ifnet *);
@


1.89
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.88 2015/04/14 12:22:15 mikeb Exp $	*/
a154 1
	u_int16_t inpt_lastport;
@


1.88
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.87 2014/11/15 10:55:47 dlg Exp $	*/
a133 5
	u_int     inp_secrequire:4,     /* Condensed State from above */
	          inp_secresult:4;	/* Result from Key Management */
#define SR_FAILED         1             /* Negotiation failed permanently */
#define SR_SUCCESS        2             /* SA successfully established */
#define SR_WAIT           3             /* Waiting for SA */
a134 3
	TAILQ_ENTRY(inpcb) inp_tdb_in_next, inp_tdb_out_next;
	struct tdb     *inp_tdb_in, *inp_tdb_out;
	struct ipsec_policy *inp_ipo;
@


1.87
log
@use siphash in the in_pcb hashing. this mitigates it against flooding
attacks.

this is a textbook use of siphash.

the idea of using siphash for this came from yasuoka-san, but i had
the time to do it. he also tested and tweaked this diff.

ok yasuoka@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.86 2014/07/12 21:06:34 yasuoka Exp $	*/
a142 2
	struct ipsec_ref *inp_ipsec_remotecred;
	struct ipsec_ref *inp_ipsec_remoteauth;
@


1.86
log
@Resize the pcb hashtable automatically.  The table size will be doubled
when the number of the hash entries reaches 75% of the table size.

ok dlg henning, 'commit in' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.85 2014/04/18 10:48:29 jca Exp $	*/
d73 2
d158 2
d162 2
a163 1
	LIST_HEAD(inpcbhead, inpcb) *inpt_hashtbl, *inpt_lhashtbl;
@


1.85
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.84 2014/04/16 13:04:38 mpi Exp $	*/
d161 1
@


1.84
log
@Merge in_fixaddr() into in_selectsrc() in order to prepare for
IP_SENDSRCADDR support.  This reduces the differences with the
IPv6 version and kill some comments that are no longer true.

ok jca@@, chrisz@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.83 2014/04/06 17:13:23 chrisz Exp $	*/
d286 2
a287 3
struct in_addr *
	in_selectsrc(struct sockaddr_in *, struct ip_moptions *,
	    struct route *, struct in_addr *, int *, u_int);
@


1.83
log
@factor out source and destination address mangling from in_pcbconnect()
for later reuse in udp_output().

"Apart from that OK" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.82 2013/12/20 02:04:08 krw Exp $	*/
d286 3
a288 4
int	 in_fixaddr(struct inpcb *inp,
			struct sockaddr_in *, struct in_addr *laddr);
extern struct sockaddr_in *in_selectsrc(struct sockaddr_in *,
	struct route *, int, struct ip_moptions *, int *, u_int);
@


1.82
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.81 2013/10/23 19:57:50 deraadt Exp $	*/
d286 2
@


1.81
log
@Back when some NRL code was merged into KAME to create the *BSD IPV6
stack (factoid: by a bunch of people in my living room), some compatibility
#define's were created to shim incompatible inpcb access methods. There
was an understanding they would eventually be removed.  Since they are
error prone, and 1999 is a long time ago, now they die.
ok mikeb claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.80 2013/10/20 11:03:00 phessler Exp $	*/
d93 1
a93 1
	CIRCLEQ_ENTRY(inpcb) inp_queue;
d157 1
a157 1
	CIRCLEQ_HEAD(, inpcb) inpt_queue;
@


1.80
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.79 2013/05/31 13:15:53 bluhm Exp $	*/
d145 1
a145 1
	int	in6p_cksum;
d147 1
a147 1
#define inp_csumoffset	in6p_cksum
a192 1
#if 1	/*KAME*/
d194 1
a194 4
 * Flags in in6p_flags
 * We define KAME's original flags in higher 16 bits as much as possible
 * for compatibility with *bsd*s.
 * XXX: Should IN6P_HIGHPORT and IN6P_LOWPORT be moved as well?
a217 1
#endif
@


1.79
log
@The function rip6_ctlinput() claims that sa6_src is constant to
allow the assingment of &sa6_any.  But rip6_ctlinput() could not
guarantee that as it casted away the const attribute when it passes
the pointer to in6_pcbnotify().  Replace sockaddr with const
sockaddr_in6 in the in6_pcbnotify() parameters.  This reduces the
number of casts.  Also adjust in6_pcbhashlookup() to handle the
const attribute correctly.
Input and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.78 2013/05/17 09:04:30 mpi Exp $	*/
d270 1
a270 1
			       u_int, const struct in6_addr *, u_int);
d273 2
a274 1
			       struct in6_addr *, u_int, int, struct mbuf *);
d298 1
a298 1
	u_int, const struct sockaddr_in6 *, u_int, int, void *,
@


1.78
log
@Move an extern declaration into its corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.77 2013/03/29 13:16:14 bluhm Exp $	*/
d269 2
a270 2
	 in6_pcbhashlookup(struct inpcbtable *, struct in6_addr *,
			       u_int, struct in6_addr *, u_int);
d296 2
a297 2
int	in6_pcbnotify(struct inpcbtable *, struct sockaddr *,
	u_int, struct sockaddr *, u_int, int, void *,
@


1.77
log
@Declare struct pf_state_key in the mbuf and in_pcb header files to
avoid ugly casts.
OK krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.76 2013/03/14 11:18:37 mpi Exp $	*/
d250 2
@


1.76
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.75 2013/01/16 00:07:22 bluhm Exp $	*/
d73 2
d150 1
a150 1
	void	*inp_pf_sk;
@


1.75
log
@Pass struct inpcb pointer to in_pcb...() functions instead of void
pointer.  Allows stricter type checking.  No functional change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.74 2012/10/21 13:06:03 benno Exp $	*/
a210 1
#define IN6P_FAITH		0x8000000 /* accept FAITH'ed connections */
@


1.74
log
@Add the IP_DIVERTFL socket option on divert(4) sockets to control
which packets (as in direction) of the traffic will be diverted
through the divert socket.
ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.73 2012/09/17 20:01:26 yasuoka Exp $	*/
d253 5
a257 5
int	 in_pcballoc(struct socket *, void *);
int	 in_pcbbind(void *, struct mbuf *, struct proc *);
int	 in_pcbconnect(void *, struct mbuf *);
void	 in_pcbdetach(void *);
void	 in_pcbdisconnect(void *);
@


1.73
log
@add IPV6_RECVDSTPORT socket option, which enables us to get original
(= before divert) destination port of a UDP packet.  The way to use
this option is same as IP_RECVDSTPORT.

from UMEZAWA Takeshi
tweaks from jmc; ok henning bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.72 2012/07/16 18:05:36 markus Exp $	*/
d151 1
@


1.72
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.71 2011/06/15 09:11:01 mikeb Exp $	*/
d199 1
d219 1
a219 1
				 IN6P_MTU)
@


1.71
log
@Add IP_RECVRTABLE socket option to be used with a IPPROTO_IP
level that allows one to retrieve the original routing domain
of UDP datagrams diverted by the pf via "divert-to" with a
recvmsg(2).

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.70 2010/09/23 04:45:15 yasuoka Exp $	*/
d178 1
@


1.70
log
@add a new IP level socket option IP_PIPEX.  This option is used for L2TP
support by pipex.
OK henning@@, "Carry on" blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.69 2010/07/03 04:44:51 guenther Exp $	*/
d177 1
d180 2
a181 1
	    INP_RXSRCRT|INP_HOPLIMIT|INP_RECVIF|INP_RECVTTL|INP_RECVDSTPORT)
@


1.69
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.68 2009/11/13 20:54:05 claudio Exp $	*/
d150 1
@


1.68
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.67 2009/06/05 00:05:22 claudio Exp $	*/
d149 1
a149 1
	u_int	inp_rdomain;
@


1.67
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.66 2008/07/10 02:19:28 djm Exp $	*/
d275 1
a275 1
	    int, void (*)(struct inpcb *, int));
@


1.66
log
@add X11 ports to default TCP baddynamic list
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.65 2008/07/09 20:20:46 djm Exp $	*/
d149 1
d254 1
a254 1
			       u_int, struct in_addr, u_int);
d257 1
a257 1
	    struct mbuf *);
d273 1
a273 1
	    u_int, int);
d282 1
a282 1
	struct route *, int, struct ip_moptions *, int *);
@


1.65
log
@expand the net.inet.(tcp|udp).baddynamic dynamic source port
skipping bitmasks to cover the entire 65536 port space - previously
they covered 512-1024 only.

sysctl needs to be updated to cope with this change; please
"make includes" before rebuilding it.

feedback millert@@ ok millert@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.64 2008/07/03 15:46:24 henning Exp $	*/
d230 4
a233 1
#define	DEFBADDYNAMICPORTS_TCP	{ 587, 749, 750, 751, 871, 2049, 0 }
@


1.64
log
@link pf state keys to tcp pcbs and vice versa.
when we first do a pcb lookup and we have a pointer to a pf state key
in the mbuf header, store the state key pointer in the pcb and a pointer
to the pcb we just found in the state key. when either the state key
or the pcb is removed, clear the pointers.
on subsequent packets inbound we can skip the pcb lookup and just use the
pointer from the state key.
on subsequent packets outbound we can skip the state key lookup and use
the pointer from the pcb.
about 8% speedup with 100 concurrent tcp sessions, should help much more
with more tcp sessions.
ok markus ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.63 2008/05/23 15:51:12 thib Exp $	*/
d224 4
a227 4
#define	DP_MAPSIZE	(howmany(IPPORT_RESERVED/2, DP_MAPBITS))
#define	DP_SET(m, p)	((m)[((p) - IPPORT_RESERVED/2) / DP_MAPBITS] |= (1 << ((p) % DP_MAPBITS)))
#define	DP_CLR(m, p)	((m)[((p) - IPPORT_RESERVED/2) / DP_MAPBITS] &= ~(1 << ((p) % DP_MAPBITS)))
#define	DP_ISSET(m, p)	((m)[((p) - IPPORT_RESERVED/2) / DP_MAPBITS] & (1 << ((p) % DP_MAPBITS)))
d230 2
a231 2
#define	DEFBADDYNAMICPORTS_TCP	{ 587, 749, 750, 751, 871, 0 }
#define	DEFBADDYNAMICPORTS_UDP	{ 623, 664, 749, 750, 751, 0 }
@


1.63
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.62 2008/05/15 19:40:38 markus Exp $	*/
d148 1
@


1.62
log
@divert for ipv6; ok henning, pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.61 2008/05/09 02:56:36 markus Exp $	*/
d243 1
a243 1
int	 in_pcbbind(void *, struct mbuf *);
d260 1
a260 1
int	 in6_pcbbind(struct inpcb *, struct mbuf *);
@


1.61
log
@IP_RECVDSTPORT, allows you to get the destination port of UDP datagrams
for pf(4) diverted packets; based on patch by Scot Loach; ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.60 2008/05/09 02:44:54 markus Exp $	*/
d259 1
a259 1
			       struct in6_addr *, u_int, int);
@


1.60
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.59 2007/02/22 20:23:07 millert Exp $	*/
d173 1
d176 1
a176 1
	    INP_RXSRCRT|INP_HOPLIMIT|INP_RECVIF|INP_RECVTTL)
@


1.59
log
@Remove TCP ports 760 and 761 from DEFBADDYNAMICPORTS_TCP; they are
not used with Heimdal.  Add UDP port 749 to DEFBADDYNAMICPORTS_UDP
for consistency with DEFBADDYNAMICPORTS_TCP.  We retain some Kerberos
4 ports for people running Heimdal in Kerberos 4 compat mode.
OK deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.58 2006/12/09 01:12:28 itojun Exp $	*/
d250 2
a251 1
	 in_pcblookup_listen(struct inpcbtable *, struct in_addr, u_int, int);
@


1.58
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.57 2006/10/11 09:34:51 henning Exp $	*/
d228 2
a229 2
#define	DEFBADDYNAMICPORTS_TCP	{ 587, 749, 750, 751, 760, 761, 871, 0 }
#define	DEFBADDYNAMICPORTS_UDP	{ 623, 664, 750, 751, 0 }
@


1.57
log
@implement IP_MINTTL socket option fo tcp sockets
This is for RFC3682 aka the TTL security hack - sender sets TTL to 255,
receiver checks no router on the way (or, no more than expected) reduced
the TTL. carp uses that technique already.
modeled after FreeBSD implementation.
ok claudio djm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.55 2006/09/26 21:10:53 deraadt Exp $	*/
a189 3
#define IN6P_RECVOPTS		INP_RECVOPTS	/* recv incoming IP6 options */
#define IN6P_RECVRETOPTS	INP_RECVRETOPTS /* recv IP6 options for reply */
#define IN6P_RECVDSTADDR	INP_RECVDSTADDR /* recv IP6 dst address */
d198 2
d203 2
d210 2
a211 1
				 IN6P_MINMTU)
@


1.56
log
@implement IP_RECVTTL socket option.
when set on raw or udp sockets, userland receives the incoming packet's TTL
as ancillary data (cmsg shitz). modeled after the FreeBSD implementation.
ok claudio djm deraadt
@
text
@d135 1
@


1.55
log
@udp port 664 is sometimes also stolen on the wire by ipmi/asf balony.
Did these vendors really really really not think?  Absolute morons.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.54 2006/05/30 19:26:57 deraadt Exp $	*/
d171 1
d174 1
a174 1
	    INP_RXSRCRT|INP_HOPLIMIT|INP_RECVIF)
@


1.54
log
@Put ASF/IPMI port 623 into the bad dynamic udp table, because otherwise
we will randomly choose that stupid port, which NIC's are sometimes
programmed to eat invisibly; sthen@@bootes.spacehopper.org, pr5139
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.53 2006/05/29 20:42:27 claudio Exp $	*/
d225 1
a225 1
#define	DEFBADDYNAMICPORTS_UDP	{ 623, 750, 751, 0 }
@


1.53
log
@Make savecontrol functions more generic and use them now for raw IP too.
Additionally add the IP_RECVIF option which returns the interface a packet
was received on. OK markus@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.52 2005/12/10 01:30:14 deraadt Exp $	*/
d225 1
a225 1
#define	DEFBADDYNAMICPORTS_UDP	{ 750, 751, 0 }
@


1.52
log
@in ansi c, bitfields must be done against int, unsigned int, or _Bool.
so we must start to use u_int; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.51 2004/08/10 20:12:15 markus Exp $	*/
a166 3
#define	INP_CONTROLOPTS	(INP_RECVOPTS|INP_RECVRETOPTS|INP_RECVDSTADDR| \
	    INP_RXSRCRT|INP_HOPLIMIT)

d170 4
@


1.51
log
@remove in_pcbnotify, it is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.50 2004/06/12 04:36:13 itojun Exp $	*/
d130 1
a130 1
	u_int8_t  inp_secrequire:4,     /* Condensed State from above */
@


1.50
log
@support IPV6_USE_MIN_MTU (forgot to commit the file, sorry).  noted by Anil
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.49 2003/12/21 15:12:27 markus Exp $	*/
a261 2
int	 in_pcbnotify(struct inpcbtable *, struct sockaddr *,
	    u_int, struct in_addr, u_int, int, void (*)(struct inpcb *, int));
@


1.49
log
@change in*_pcbnotify to return numbers of matches; ok itojun, mcbride, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.48 2003/12/08 07:07:36 mcbride Exp $	*/
d202 2
d205 2
a206 1
				 IN6P_DSTOPTS|IN6P_RTHDR|IN6P_RTHDRDSTOPTS)
@


1.48
log
@Mbuf tag tcp and udp packets which are translated to localhost, and
use the the presence of this tag to reverse the match order in
in{6}_pcblookup_listen(). Some daemons (such as portmap) do a double
bind, binding to both * and localhost in order to differentiate local
from non-local connections, and potentially granting more privilege to
local ones. This change ensures that redirected connections to localhost
do not appear local to such a daemon.

Bulk of changes from dhartmei@@, some changes markus@@

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.47 2003/11/04 21:43:16 markus Exp $	*/
d259 1
a259 1
void	 in_pcbnotify(struct inpcbtable *, struct sockaddr *,
@


1.47
log
@add in(6)_pcblookup_listen() and replace all calls to in_pcblookup()
with either in(6)_pcbhashlookup() or in(6)_pcblookup_listen();
in_pcblookup is now only used by bind(2); speeds up pcb lookup for
listening sockets; from Claudio Jeker
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.46 2003/10/25 12:15:24 markus Exp $	*/
d242 1
a242 1
	 in_pcblookup_listen(struct inpcbtable *, struct in_addr, u_int);
d249 1
a249 1
			       struct in6_addr *, u_int);
@


1.46
log
@additional hash for local port; improves speed of implicit bind
from >1000K cpu cycles to 20-30K for 18000 sockets on i386;
test+feedback by Claudio Jeker; ok itojun@@;
[make sure you rebuild netstat/systat, too]
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.45 2003/06/02 23:28:14 millert Exp $	*/
d241 2
d247 3
@


1.45
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.44 2002/09/04 07:26:53 itojun Exp $	*/
d90 1
d151 2
a152 2
	LIST_HEAD(inpcbhead, inpcb) *inpt_hashtbl;
	u_long	  inpt_hash;
@


1.44
log
@pass struct proc * down to in6_pcbsetport
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.43 2002/06/09 16:26:10 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.43
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.42 2002/06/08 21:22:02 itojun Exp $	*/
d276 1
a276 1
int	in6_pcbsetport(struct in6_addr *, struct inpcb *);
@


1.42
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.41 2002/05/31 02:39:25 angelos Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d188 1
a188 1
 * XXX: Should IN6P_HIGHPORT and IN6P_LOWPORT be moved as well?  
@


1.41
log
@Keep an policy attached to each socket (that needs it), and cleanup as
needed on socket tear-down.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.40 2002/03/14 03:16:11 millert Exp $	*/
d273 2
a274 7
			   u_int, struct sockaddr *, u_int, int, void *,
			   void (*)(struct inpcb *, int));
struct 	in6_addr *in6_selectsrc(struct sockaddr_in6 *,
				     struct ip6_pktopts *,
				     struct ip6_moptions *,
				     struct route_in6 *,
				     struct in6_addr *, int *);
@


1.40
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.39 2002/03/14 01:27:11 millert Exp $	*/
d140 1
a140 3
	struct ipsec_ref *inp_ipsec_localid;
	struct ipsec_ref *inp_ipsec_remoteid;
	struct ipsec_ref *inp_ipsec_localcred;
a141 1
	struct ipsec_ref *inp_ipsec_localauth;
@


1.39
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.38 2001/07/05 08:31:47 jjbg Exp $	*/
d260 4
a263 4
void	 in_pcbnotify __P((struct inpcbtable *, struct sockaddr *,
	    u_int, struct in_addr, u_int, int, void (*)(struct inpcb *, int)));
void	 in_pcbnotifyall __P((struct inpcbtable *, struct sockaddr *,
	    int, void (*)(struct inpcb *, int)));
d275 1
a275 1
int	in6_pcbnotify __P((struct inpcbtable *, struct sockaddr *,
d277 1
a277 1
			   void (*)(struct inpcb *, int)));
@


1.38
log
@IPComp itself (include files). angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.37 2001/06/12 10:59:53 angelos Exp $	*/
d238 6
a243 6
void	 in_losing __P((struct inpcb *));
int	 in_pcballoc __P((struct socket *, void *));
int	 in_pcbbind __P((void *, struct mbuf *));
int	 in_pcbconnect __P((void *, struct mbuf *));
void	 in_pcbdetach __P((void *));
void	 in_pcbdisconnect __P((void *));
d245 2
a246 2
	 in_pcbhashlookup __P((struct inpcbtable *, struct in_addr,
			       u_int, struct in_addr, u_int));
d249 6
a254 6
	 in6_pcbhashlookup __P((struct inpcbtable *, struct in6_addr *,
			       u_int, struct in6_addr *, u_int));
int	 in6_pcbbind __P((struct inpcb *, struct mbuf *));
int	 in6_pcbconnect __P((struct inpcb *, struct mbuf *));
int	 in6_setsockaddr __P((struct inpcb *, struct mbuf *));
int	 in6_setpeeraddr __P((struct inpcb *, struct mbuf *));
d256 1
a256 1
void	 in_pcbinit __P((struct inpcbtable *, int));
d258 2
a259 2
	 in_pcblookup __P((struct inpcbtable *, void *, u_int, void *,
	    u_int, int));
d264 7
a270 7
void	 in_pcbrehash __P((struct inpcb *));
void	 in_rtchange __P((struct inpcb *, int));
void	 in_setpeeraddr __P((struct inpcb *, struct mbuf *));
void	 in_setsockaddr __P((struct inpcb *, struct mbuf *));
int	 in_baddynamic __P((u_int16_t, u_int16_t));
extern struct sockaddr_in *in_selectsrc __P((struct sockaddr_in *,
	struct route *, int, struct ip_moptions *, int *));
d272 1
a272 1
	in_pcbrtentry __P((struct inpcb *));
d278 1
a278 1
struct 	in6_addr *in6_selectsrc __P((struct sockaddr_in6 *,
d282 3
a284 3
				     struct in6_addr *, int *));
int	in6_selecthlim __P((struct inpcb *, struct ifnet *));
int	in6_pcbsetport __P((struct in6_addr *, struct inpcb *));
@


1.38.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.38 2001/07/05 08:31:47 jjbg Exp $	*/
d140 3
a142 1
	struct ipsec_policy *inp_ipo;
d144 1
d238 6
a243 6
void	 in_losing(struct inpcb *);
int	 in_pcballoc(struct socket *, void *);
int	 in_pcbbind(void *, struct mbuf *);
int	 in_pcbconnect(void *, struct mbuf *);
void	 in_pcbdetach(void *);
void	 in_pcbdisconnect(void *);
d245 2
a246 2
	 in_pcbhashlookup(struct inpcbtable *, struct in_addr,
			       u_int, struct in_addr, u_int);
d249 6
a254 6
	 in6_pcbhashlookup(struct inpcbtable *, struct in6_addr *,
			       u_int, struct in6_addr *, u_int);
int	 in6_pcbbind(struct inpcb *, struct mbuf *);
int	 in6_pcbconnect(struct inpcb *, struct mbuf *);
int	 in6_setsockaddr(struct inpcb *, struct mbuf *);
int	 in6_setpeeraddr(struct inpcb *, struct mbuf *);
d256 1
a256 1
void	 in_pcbinit(struct inpcbtable *, int);
d258 13
a270 13
	 in_pcblookup(struct inpcbtable *, void *, u_int, void *,
	    u_int, int);
void	 in_pcbnotify(struct inpcbtable *, struct sockaddr *,
	    u_int, struct in_addr, u_int, int, void (*)(struct inpcb *, int));
void	 in_pcbnotifyall(struct inpcbtable *, struct sockaddr *,
	    int, void (*)(struct inpcb *, int));
void	 in_pcbrehash(struct inpcb *);
void	 in_rtchange(struct inpcb *, int);
void	 in_setpeeraddr(struct inpcb *, struct mbuf *);
void	 in_setsockaddr(struct inpcb *, struct mbuf *);
int	 in_baddynamic(u_int16_t, u_int16_t);
extern struct sockaddr_in *in_selectsrc(struct sockaddr_in *,
	struct route *, int, struct ip_moptions *, int *);
d272 1
a272 1
	in_pcbrtentry(struct inpcb *);
d275 10
a284 5
int	in6_pcbnotify(struct inpcbtable *, struct sockaddr *,
	u_int, struct sockaddr *, u_int, int, void *,
	void (*)(struct inpcb *, int));
int	in6_selecthlim(struct inpcb *, struct ifnet *);
int	in6_pcbsetport(struct in6_addr *, struct inpcb *);
@


1.38.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.38.4.1 2002/06/11 03:31:36 art Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
d188 1
a188 1
 * XXX: Should IN6P_HIGHPORT and IN6P_LOWPORT be moved as well?
d276 1
a276 1
int	in6_pcbsetport(struct in6_addr *, struct inpcb *, struct proc *);
@


1.37
log
@IPsec-related socket options; these can be set/removed/retrieved, but
are not taken into consideration in anything just yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.36 2001/06/09 07:03:40 angelos Exp $	*/
d128 1
a128 1
	u_char	  inp_seclevel[3];
d132 1
@


1.36
log
@Inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.35 2001/05/27 03:53:09 angelos Exp $	*/
d143 2
a144 1
	struct ipsec_ref *inp_ipsec_auth;
@


1.35
log
@Keep local authentication material on the PCB.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.34 2001/05/21 03:02:18 angelos Exp $	*/
d68 3
d283 2
a284 1
#endif
@


1.34
log
@Use a reference-counted structure for IPsec IDs and credentials, so we
can cheaply keep copies of them at the PCB. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.33 2001/03/28 20:03:02 angelos Exp $	*/
d140 1
@


1.33
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.32 2001/02/16 16:00:53 itojun Exp $	*/
d136 4
@


1.32
log
@pull in new pcb notification code from kame.  better handling of scope address.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.31 2001/02/16 14:45:11 itojun Exp $	*/
d125 1
a125 1
	u_char	  inp_seclevel[3];	/* Only the first 3 are used for now */
d134 2
a135 2
	TAILQ_ENTRY(inpcb) inp_tdb_next;
	struct tdb     *inp_tdb;	/* If tdb_dst matches our dst, use */
@


1.31
log
@amove in6_{embed,recover}scope prototypes to in6_var.h (kernel only).
add in6_clearscope.  sync better with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.30 2001/02/08 18:46:22 itojun Exp $	*/
d266 1
a266 1
			   u_int, struct in6_addr *, u_int, int,
@


1.30
log
@witch raw ip6 socket code from NRL to kame.
makes upgrades/code sharing much easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.29 2000/10/11 09:14:11 itojun Exp $	*/
a274 4
int in6_embedscope __P((struct in6_addr *, const struct sockaddr_in6 *,
	struct inpcb *, struct ifnet **));
int in6_recoverscope __P((struct sockaddr_in6 *, const struct in6_addr *,
	struct ifnet *));
@


1.29
log
@nuke inp_flags bits for controlling IPv4 mapped address.
we don't support IPv4 mapped address,
and there are inconsistent bit manipulation code so it's safer to nuke them.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.28 2000/10/10 15:16:02 provos Exp $	*/
d136 6
a141 2
	int	inp_fflowinfo;          /* Foreign flowlabel & priority */
	int	inp_csumoffset;
@


1.28
log
@verify payload of the icmp need fragment message at the tcp layer. okay itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.27 2000/10/09 14:39:46 provos Exp $	*/
a170 6
#define	INP_IPV6_UNDEC	0x200	/* PCB is PF_INET6, but listens for V4/V6 */
#define	INP_IPV6_MAPPED	0x400	/* PF_INET6 PCB which is connected to
				 * an IPv4 host, or is bound to
				 * an IPv4 address (specified with
				 * the mapped form of v6 addresses) */
#define INP_IPV6_MCAST	0x800	/* Set if inp_moptions points to ipv6 ones */
@


1.27
log
@check if we have a tcb connected to the destination quoted in the icmp need
fragment message when doing path mtu discovery. okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.26 2000/09/18 22:06:37 provos Exp $	*/
a255 1
int	 in_pcbconnected __P((struct inpcbtable *, struct sockaddr *));
@


1.26
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.25 2000/06/18 17:32:48 itojun Exp $	*/
d256 1
@


1.25
log
@sync with KAME udp6_output().  udp output logic is very different between
IPv4/v6 so the separation should make more sense.

TODO: remove IPv6 case from udp_output()
TODO: remove/comment out/#if 0 IPv4 mapped address cases
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.24 2000/06/13 10:12:00 itojun Exp $	*/
d263 2
@


1.24
log
@allow link-local IPv6 addres in in6_pcbbind.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.23 2000/04/27 15:41:06 millert Exp $	*/
d274 1
@


1.23
log
@add TCP port 587 to default list of reserved ports not to allocate dynamically in order to reserve it for sendmail.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.22 2000/02/07 06:09:09 itojun Exp $	*/
d274 4
@


1.22
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.21 2000/01/11 01:13:49 angelos Exp $	*/
d218 1
a218 1
#define	DEFBADDYNAMICPORTS_TCP	{ 749, 750, 751, 760, 761, 871, 0 }
@


1.22.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.33 2001/03/28 20:03:02 angelos Exp $	*/
d125 1
a125 1
	u_char	  inp_seclevel[3];
d134 4
a137 8
	TAILQ_ENTRY(inpcb) inp_tdb_in_next, inp_tdb_out_next;
	struct tdb     *inp_tdb_in, *inp_tdb_out;
#define	inp_flowinfo	inp_hu.hu_ipv6.ip6_flow

	int	in6p_cksum;
#ifndef _KERNEL
#define inp_csumoffset	in6p_cksum
#endif
d171 6
d218 1
a218 1
#define	DEFBADDYNAMICPORTS_TCP	{ 587, 749, 750, 751, 760, 761, 871, 0 }
a262 2
struct rtentry *
	in_pcbrtentry __P((struct inpcb *));
d266 1
a266 1
			   u_int, struct sockaddr *, u_int, int, void *,
a273 1
int	in6_pcbsetport __P((struct in6_addr *, struct inpcb *));
@


1.22.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.22.2.1 2001/05/14 22:40:08 niklas Exp $	*/
a67 3
#ifndef _NETINET_IN_PCB_H_
#define _NETINET_IN_PCB_H_

a135 6
	struct ipsec_ref *inp_ipsec_localid;
	struct ipsec_ref *inp_ipsec_remoteid;
	struct ipsec_ref *inp_ipsec_localcred;
	struct ipsec_ref *inp_ipsec_remotecred;
	struct ipsec_ref *inp_ipsec_localauth;
	struct ipsec_ref *inp_ipsec_remoteauth;
d275 1
a275 2
#endif /* _KERNEL */
#endif /* _NETINET_IN_PCB_H_ */
@


1.22.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.22.2.2 2001/07/04 10:54:34 niklas Exp $	*/
d128 1
a128 1
	u_char	  inp_seclevel[4];
a131 1
#define SL_IPCOMP         3             /* Compression level */
@


1.22.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d238 6
a243 6
void	 in_losing(struct inpcb *);
int	 in_pcballoc(struct socket *, void *);
int	 in_pcbbind(void *, struct mbuf *);
int	 in_pcbconnect(void *, struct mbuf *);
void	 in_pcbdetach(void *);
void	 in_pcbdisconnect(void *);
d245 2
a246 2
	 in_pcbhashlookup(struct inpcbtable *, struct in_addr,
			       u_int, struct in_addr, u_int);
d249 6
a254 6
	 in6_pcbhashlookup(struct inpcbtable *, struct in6_addr *,
			       u_int, struct in6_addr *, u_int);
int	 in6_pcbbind(struct inpcb *, struct mbuf *);
int	 in6_pcbconnect(struct inpcb *, struct mbuf *);
int	 in6_setsockaddr(struct inpcb *, struct mbuf *);
int	 in6_setpeeraddr(struct inpcb *, struct mbuf *);
d256 1
a256 1
void	 in_pcbinit(struct inpcbtable *, int);
d258 13
a270 13
	 in_pcblookup(struct inpcbtable *, void *, u_int, void *,
	    u_int, int);
void	 in_pcbnotify(struct inpcbtable *, struct sockaddr *,
	    u_int, struct in_addr, u_int, int, void (*)(struct inpcb *, int));
void	 in_pcbnotifyall(struct inpcbtable *, struct sockaddr *,
	    int, void (*)(struct inpcb *, int));
void	 in_pcbrehash(struct inpcb *);
void	 in_rtchange(struct inpcb *, int);
void	 in_setpeeraddr(struct inpcb *, struct mbuf *);
void	 in_setsockaddr(struct inpcb *, struct mbuf *);
int	 in_baddynamic(u_int16_t, u_int16_t);
extern struct sockaddr_in *in_selectsrc(struct sockaddr_in *,
	struct route *, int, struct ip_moptions *, int *);
d272 1
a272 1
	in_pcbrtentry(struct inpcb *);
d275 1
a275 1
int	in6_pcbnotify(struct inpcbtable *, struct sockaddr *,
d277 2
a278 2
			   void (*)(struct inpcb *, int));
struct 	in6_addr *in6_selectsrc(struct sockaddr_in6 *,
d282 3
a284 3
				     struct in6_addr *, int *);
int	in6_selecthlim(struct inpcb *, struct ifnet *);
int	in6_pcbsetport(struct in6_addr *, struct inpcb *);
@


1.22.2.5
log
@Sync the SMP branch with 3.3
@
text
@d7 1
a7 1
 *
d19 1
a19 1
 *
d140 3
a142 1
	struct ipsec_policy *inp_ipo;
d144 1
d191 1
a191 1
 * XXX: Should IN6P_HIGHPORT and IN6P_LOWPORT be moved as well?
d276 7
a282 2
	u_int, struct sockaddr *, u_int, int, void *,
	void (*)(struct inpcb *, int));
d284 1
a284 1
int	in6_pcbsetport(struct in6_addr *, struct inpcb *, struct proc *);
@


1.22.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.22.2.5 2003/03/28 00:06:54 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.22.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a89 1
	LIST_ENTRY(inpcb) inp_lhash;		/* extra hash for lport */
d150 2
a151 2
	LIST_HEAD(inpcbhead, inpcb) *inpt_hashtbl, *inpt_lhashtbl;
	u_long	  inpt_hash, inpt_lhash;
a239 2
struct inpcb *
	 in_pcblookup_listen(struct inpcbtable *, struct in_addr, u_int, int);
a243 3
struct inpcb *
	 in6_pcblookup_listen(struct inpcbtable *,
			       struct in6_addr *, u_int, int);
d253 1
a253 1
int	 in_pcbnotify(struct inpcbtable *, struct sockaddr *,
@


1.22.2.8
log
@sync to HEAD
@
text
@a201 2
#define IN6P_MINMTU		0x20000000 /* use minimum MTU */

d203 1
a203 2
				 IN6P_DSTOPTS|IN6P_RTHDR|IN6P_RTHDRDSTOPTS|\
				 IN6P_MINMTU)
@


1.21
log
@Remove ifdef'ed out definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.20 1999/12/27 06:40:38 itojun Exp $	*/
d69 1
a69 1
#include <netinet6/ip6.h>
d71 1
a71 1
#include <netinet6/icmp6.h>
@


1.20
log
@synchronize inp_flags definition across kame/*bsd.
this would ease us implement future COMPAT_*BSD.

(sync with kame tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.19 1999/12/12 12:10:43 itojun Exp $	*/
a68 3
#if 0	/*KAME IPSEC*/
#include <netinet6/ipsec.h>
#endif
a138 5
#if 0 /*KAME IPSEC*/
	struct secpolicy *inp_sp;	/* security policy. It may not be
					 * used according to policy selection.
					 */
#endif
@


1.19
log
@make it easier to synchronize INP_xx flags and IN6P_xx flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.18 1999/12/08 06:50:19 itojun Exp $	*/
d187 23
a209 15
/* flags in in6p_flags */
#define IN6P_RECVOPTS	INP_RECVOPTS	/* receive incoming IP6 options */
#define IN6P_RECVRETOPTS INP_RECVRETOPTS /* receive IP6 options for reply */
#define IN6P_RECVDSTADDR INP_RECVDSTADDR /* receive IP6 dst address */
#define IN6P_HIGHPORT	INP_HIGHPORT	/* user wants "high" port binding */
#define IN6P_LOWPORT	INP_LOWPORT	/* user wants "low" port binding */
#define IN6P_ANONPORT	0x40		/* port chosen for user */
#define IN6P_FAITH	0x80		/* accept FAITH'ed connections */
#define IN6P_PKTINFO	0x010000
#define IN6P_HOPLIMIT	0x020000
#define IN6P_NEXTHOP	0x040000
#define IN6P_HOPOPTS	0x080000
#define IN6P_DSTOPTS	0x100000
#define IN6P_RTHDR	0x200000
#define IN6P_CONTROLOPTS	(0x3f0000 | IN6P_RECVOPTS | IN6P_RECVRETOPTS | IN6P_RECVDSTADDR)
@


1.18
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.17 1999/03/27 21:04:19 provos Exp $	*/
d188 13
a200 13
#define IN6P_RECVOPTS		0x01	/* receive incoming IP6 options */
#define IN6P_RECVRETOPTS	0x02	/* receive IP6 options for reply */
#define IN6P_RECVDSTADDR	0x04	/* receive IP6 dst address */
#define IN6P_HIGHPORT		0x10	/* user wants "high" port binding */
#define IN6P_LOWPORT		0x20	/* user wants "low" port binding */
#define IN6P_ANONPORT		0x40	/* port chosen for user */
#define IN6P_FAITH		0x80	/* accept FAITH'ed connections */
#define IN6P_PKTINFO		0x010000
#define IN6P_HOPLIMIT		0x020000
#define IN6P_NEXTHOP		0x040000
#define IN6P_HOPOPTS		0x080000
#define IN6P_DSTOPTS		0x100000
#define IN6P_RTHDR		0x200000
@


1.17
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.16 1999/03/24 02:33:02 cmetz Exp $	*/
d5 29
d69 6
a74 3
#include <netinet6/ipv6.h>
#include <netinet6/ipv6_var.h>
#include <netinet6/icmpv6.h>
d108 1
a108 1
		struct route6 ru_route6;
d115 1
a115 1
		struct ipv6 hu_ipv6;
d120 2
d124 1
a124 1
		struct ipv6_moptions *mou_mo6; /* IPv6 multicast options */
d141 6
a146 1
	struct	icmpv6_filter inp_filter;
d186 18
d261 13
@


1.16
log
@Removed inclusion of netinet6/in6.h. This was an artifact of when the core
IPv6 symbols were there rather than in netinet/in.h, and now not only is
unnecessary but also could create problems (see PR library/781).
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.15 1999/01/11 02:01:34 deraadt Exp $	*/
d43 1
d103 2
@


1.15
log
@netinet merge of NRL stuff. some indent and shrinkage needed; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.14 1999/01/08 07:47:54 deraadt Exp $	*/
a39 1
#include <netinet6/in6.h>
@


1.14
log
@more IPV6 merge; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.13 1999/01/07 21:50:52 deraadt Exp $	*/
d184 4
@


1.13
log
@INET6 support
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.12 1999/01/07 06:05:04 deraadt Exp $	*/
d88 6
a93 1
	struct	  ip_moptions *inp_moptions; /* IP multicast options */
d180 5
@


1.12
log
@in_pcblookup() now takes ptr to both ip address arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.11 1999/01/07 05:44:32 deraadt Exp $	*/
d40 12
d64 6
a69 2
	struct	  in_addr inp_faddr;	/* foreign host table entry */
	struct	  in_addr inp_laddr;	/* local host table entry */
d74 6
a79 1
	struct	  route inp_route;	/* placeholder for routing entry */
d81 6
a86 1
	struct	  ip inp_ip;		/* header prototype; should have more */
d98 3
d111 28
a138 7
#define	INP_RECVOPTS		0x01	/* receive incoming IP options */
#define	INP_RECVRETOPTS		0x02	/* receive IP options for reply */
#define	INP_RECVDSTADDR		0x04	/* receive IP dst address */
#define	INP_CONTROLOPTS		(INP_RECVOPTS|INP_RECVRETOPTS|INP_RECVDSTADDR)
#define	INP_HDRINCL		0x08	/* user supplies entire IP header */
#define INP_HIGHPORT		0x10	/* user wants "high" port binding */
#define INP_LOWPORT		0x20	/* user wants "low" port binding */
d142 1
d163 3
@


1.11
log
@rename baddynamic() to in_baddynamic(), and export it
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.10 1998/05/18 21:10:28 provos Exp $	*/
d123 2
a124 2
	 in_pcblookup __P((struct inpcbtable *,
	    struct in_addr, u_int, struct in_addr, u_int, int));
@


1.10
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.9 1997/08/26 20:02:30 deraadt Exp $	*/
d133 1
@


1.9
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.8 1997/08/19 06:29:50 millert Exp $	*/
d63 1
a63 1
	u_char	  inp_seclevel[4];	/* Only the first 3 are used for now */
d67 5
@


1.8
log
@Add DP_CLR() macro
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.7 1997/08/19 04:54:52 millert Exp $	*/
d63 1
a63 1
	u_char 	  inp_seclevel[4];	/* Only the first 3 are used for now */
@


1.7
log
@Theo doesn't like extra kernel options, so don't allow
DEFBADDYNAMICPORTS_TCP and DEFBADDYNAMICPORTS_UDP to be
overridden from the kernel.  It's not really too useful
since there is a nice sysctl interface for this stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.6 1997/08/16 16:49:42 millert Exp $	*/
d94 1
@


1.6
log
@Allow DEFBADDYNAMICPORTS_TCP and DEFBADDYNAMICPORTS_UDP to be
overridden via kernel config file.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.5 1997/08/09 23:36:25 millert Exp $	*/
a96 1
#ifndef DEFBADDYNAMICPORTS_TCP
a97 2
#endif
#ifndef DEFBADDYNAMICPORTS_UDP
a98 1
#endif
@


1.5
log
@The list of tcp/udp ports not to allocate dynamically is now
a bitmask configurable via sysctl([38]).  The default values
have not changed.  If one wants to change the list it should
be done early on in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.4 1997/02/28 04:03:48 angelos Exp $	*/
d97 1
d99 2
d102 1
@


1.4
log
@Moved IPsec socket state to the PCB.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_pcb.h,v 1.2 1996/03/03 22:30:32 niklas Exp $	*/
d89 15
@


1.3
log
@From FreeBSD (with slightly different sysctl names):

"... Allow the user to nominate one of three ranges of port numbers as
candidates for selecting a local address to replace a zero port number.
The ranges are selected via a setsockopt(s, IPPROTO_IP, IP_PORTRANGE, &arg)
call.  The three ranges are: default, high (to bypass firewalls) and
low (to get a port below 1024).

The default and high port ranges are sysctl settable under sysctl
net.inet.ip.portrange.* [net.inet.ip.portfirst, net.inet.ip.portlast,
net.inet.ip.porthifirst, and net.inet.ip.porthilast currently in OpenBSD.]

This code also fixes a potential deadlock if the system accidently ran out
of local port addresses. It'd drop into an infinite while loop.

The secure port selection (for root) should reduce overheads and increase
reliability of rlogin/rlogind/rsh/rshd if they are modified to take
advantage of it."
@
text
@d63 4
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 2
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: in_pcb.h,v 1.12 1995/06/18 20:01:13 cgd Exp $	*/
d49 1
d66 3
a68 1
	CIRCLEQ_HEAD(inpcbhead, inpcb) inpt_queue;
d85 10
a94 7
int	 in_losing __P((struct inpcb *));
int	 in_pcballoc __P((struct socket *, struct inpcbtable *));
int	 in_pcbbind __P((struct inpcb *, struct mbuf *));
int	 in_pcbconnect __P((struct inpcb *, struct mbuf *));
int	 in_pcbdetach __P((struct inpcb *));
int	 in_pcbdisconnect __P((struct inpcb *));
void	 in_pcbinit __P((struct inpcbtable *));
d102 1
d104 2
a105 2
int	 in_setpeeraddr __P((struct inpcb *, struct mbuf *));
int	 in_setsockaddr __P((struct inpcb *, struct mbuf *));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
