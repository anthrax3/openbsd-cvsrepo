head	1.47;
access;
symbols
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.42.0.6
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.34.0.4
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.2
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.8
	OPENBSD_5_0:1.33.0.6
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.14
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.16
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.12
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.10
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.8
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.6
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.29.0.10
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.8
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.6
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.4
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.25
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.47
date	2017.08.08.18.15.58;	author florian;	state Exp;
branches;
next	1.46;
commitid	0uoQs1W80abGpq2t;

1.46
date	2017.08.03.17.36.06;	author florian;	state Exp;
branches;
next	1.45;
commitid	MoP2xHBFrsqGwwVP;

1.45
date	2017.07.12.16.53.58;	author florian;	state Exp;
branches;
next	1.44;
commitid	P3S1WvuGoZI0WHQU;

1.44
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.43;
commitid	00hB28wQPwG5Ysk0;

1.43
date	2017.02.09.15.23.35;	author jca;	state Exp;
branches;
next	1.42;
commitid	1ap8YFU49Zg4mM41;

1.42
date	2015.09.09.15.51.40;	author mpi;	state Exp;
branches;
next	1.41;
commitid	MtXIH0WHmPXVgeDN;

1.41
date	2014.08.27.14.04.15;	author florian;	state Exp;
branches;
next	1.40;
commitid	JNq3mHDvq54quWei;

1.40
date	2014.07.11.12.20.26;	author benno;	state Exp;
branches;
next	1.39;
commitid	P8JppJvHVB5bPsqa;

1.39
date	2014.05.07.08.14.59;	author mpi;	state Exp;
branches;
next	1.38;

1.38
date	2013.10.24.11.20.16;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2013.10.21.08.42.24;	author phessler;	state Exp;
branches;
next	1.36;

1.36
date	2013.06.01.01.30.53;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.17.00.38.29;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2012.07.08.10.45.46;	author phessler;	state Exp;
branches;
next	1.33;

1.33
date	2010.03.22.12.23.32;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.06.02.56.58;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.27.02.19.32;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.07.09.21.55;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.15.11.16.08;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.16.20.30.07;	author avsm;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.11.02.54.02;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.09.02.11.47;	author jsyn;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.08.21.22.02;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.29.02.59.12;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.03.16.11;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.28.02.29.13;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.07.09.33.10;	author itojun;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.12.06.03.28.49;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.09.07.03.39;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.07.11.43.52;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.22.04.31.21;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.21.15.42.35;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.11.08.04.55;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.10.15.53.07;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.10.14.24.32;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.19.09.17.36;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.03.14.39.23;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.06.10.11.21;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.12.17.24.26;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.09.21.21.12;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.28.14.05.59;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.28.11.55.20;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.07.05.45.55;	author itojun;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches;
next	;

1.2.2.1
date	2000.03.02.07.04.42;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.03.24.09.09.35;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.05.14.22.40.06;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.07.04.10.54.27;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.2.2.10;

1.2.2.10
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.44;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Stop running nd6_expire every second.
We know when pltime or vltime decrease to zero. Run nd6_expire then.
Input & OK mpi, bluhm
@
text
@/*	$OpenBSD: icmp6.h,v 1.46 2017/08/03 17:36:06 florian Exp $	*/
/*	$KAME: icmp6.h,v 1.84 2003/04/23 10:26:51 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET_ICMP6_H_
#define _NETINET_ICMP6_H_

#define ICMPV6_PLD_MAXLEN	1232	/* IPV6_MMTU - sizeof(struct ip6_hdr)
					   - sizeof(struct icmp6_hdr) */

struct icmp6_hdr {
	u_int8_t	icmp6_type;	/* type field */
	u_int8_t	icmp6_code;	/* code field */
	u_int16_t	icmp6_cksum;	/* checksum field */
	union {
		u_int32_t	icmp6_un_data32[1]; /* type-specific field */
		u_int16_t	icmp6_un_data16[2]; /* type-specific field */
		u_int8_t	icmp6_un_data8[4];  /* type-specific field */
	} icmp6_dataun;
} __packed;

#define icmp6_data32	icmp6_dataun.icmp6_un_data32
#define icmp6_data16	icmp6_dataun.icmp6_un_data16
#define icmp6_data8	icmp6_dataun.icmp6_un_data8
#define icmp6_pptr	icmp6_data32[0]		/* parameter prob */
#define icmp6_mtu	icmp6_data32[0]		/* packet too big */
#define icmp6_id	icmp6_data16[0]		/* echo request/reply */
#define icmp6_seq	icmp6_data16[1]		/* echo request/reply */
#define icmp6_maxdelay	icmp6_data16[0]		/* mcast group membership */

#define ICMP6_DST_UNREACH		1	/* dest unreachable, codes: */
#define ICMP6_PACKET_TOO_BIG		2	/* packet too big */
#define ICMP6_TIME_EXCEEDED		3	/* time exceeded, code: */
#define ICMP6_PARAM_PROB		4	/* ip6 header bad */

#define ICMP6_ECHO_REQUEST		128	/* echo service */
#define ICMP6_ECHO_REPLY		129	/* echo reply */
#define MLD_LISTENER_QUERY		130 	/* multicast listener query */
#define MLD_LISTENER_REPORT		131	/* multicast listener report */
#define MLD_LISTENER_DONE		132	/* multicast listener done */

/* RFC2292 decls */
#define ICMP6_MEMBERSHIP_QUERY		130	/* group membership query */
#define ICMP6_MEMBERSHIP_REPORT		131	/* group membership report */
#define ICMP6_MEMBERSHIP_REDUCTION	132	/* group membership termination */

#define ND_ROUTER_SOLICIT		133	/* router solicitation */
#define ND_ROUTER_ADVERT		134	/* router advertisement */
#define ND_NEIGHBOR_SOLICIT		135	/* neighbor solicitation */
#define ND_NEIGHBOR_ADVERT		136	/* neighbor advertisement */
#define ND_REDIRECT			137	/* redirect */

#define ICMP6_ROUTER_RENUMBERING	138	/* router renumbering */

#define ICMP6_WRUREQUEST		139	/* who are you request */
#define ICMP6_WRUREPLY			140	/* who are you reply */
#define ICMP6_FQDN_QUERY		139	/* FQDN query */
#define ICMP6_FQDN_REPLY		140	/* FQDN reply */
#define ICMP6_NI_QUERY			139	/* node information request */
#define ICMP6_NI_REPLY			140	/* node information reply */
#define MLDV2_LISTENER_REPORT		143	/* RFC3810 listener report */

/* The definitions below are experimental. TBA */
#define MLD_MTRACE_RESP			200	/* mtrace response(to sender) */
#define MLD_MTRACE			201	/* mtrace messages */

#define ICMP6_MAXTYPE			201

#define ICMP6_DST_UNREACH_NOROUTE	0	/* no route to destination */
#define ICMP6_DST_UNREACH_ADMIN	 	1	/* administratively prohibited */
#define ICMP6_DST_UNREACH_BEYONDSCOPE	2	/* beyond scope of source address */
#define ICMP6_DST_UNREACH_ADDR		3	/* address unreachable */
#define ICMP6_DST_UNREACH_NOPORT	4	/* port unreachable */

#define ICMP6_TIME_EXCEED_TRANSIT 	0	/* ttl==0 in transit */
#define ICMP6_TIME_EXCEED_REASSEMBLY	1	/* ttl==0 in reass */

#define ICMP6_PARAMPROB_HEADER 	 	0	/* erroneous header field */
#define ICMP6_PARAMPROB_NEXTHEADER	1	/* unrecognized next header */
#define ICMP6_PARAMPROB_OPTION		2	/* unrecognized option */

#define ICMP6_INFOMSG_MASK		0x80	/* all informational messages */

#define ICMP6_NI_SUBJ_IPV6	0	/* Query Subject is an IPv6 address */
#define ICMP6_NI_SUBJ_FQDN	1	/* Query Subject is a Domain name */
#define ICMP6_NI_SUBJ_IPV4	2	/* Query Subject is an IPv4 address */

#define ICMP6_NI_SUCCESS	0	/* node information successful reply */
#define ICMP6_NI_REFUSED	1	/* node information request is refused */
#define ICMP6_NI_UNKNOWN	2	/* unknown Qtype */

#define ICMP6_ROUTER_RENUMBERING_COMMAND  0	/* rr command */
#define ICMP6_ROUTER_RENUMBERING_RESULT   1	/* rr result */
#define ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET   255	/* rr seq num reset */

/* Used in kernel only */
#define ND_REDIRECT_ONLINK	0	/* redirect to an on-link node */
#define ND_REDIRECT_ROUTER	1	/* redirect to a better router */

/*
 * Multicast Listener Discovery
 */
struct mld_hdr {
	struct icmp6_hdr	mld_icmp6_hdr;
	struct in6_addr		mld_addr; /* multicast address */
} __packed;

/* shortcut macro definitions */
#define mld_type	mld_icmp6_hdr.icmp6_type
#define mld_code	mld_icmp6_hdr.icmp6_code
#define mld_cksum	mld_icmp6_hdr.icmp6_cksum
#define mld_maxdelay	mld_icmp6_hdr.icmp6_data16[0]
#define mld_reserved	mld_icmp6_hdr.icmp6_data16[1]

/*
 * Neighbor Discovery
 */

struct nd_router_solicit {	/* router solicitation */
	struct icmp6_hdr 	nd_rs_hdr;
	/* could be followed by options */
} __packed;

#define nd_rs_type	nd_rs_hdr.icmp6_type
#define nd_rs_code	nd_rs_hdr.icmp6_code
#define nd_rs_cksum	nd_rs_hdr.icmp6_cksum
#define nd_rs_reserved	nd_rs_hdr.icmp6_data32[0]

struct nd_router_advert {	/* router advertisement */
	struct icmp6_hdr	nd_ra_hdr;
	u_int32_t		nd_ra_reachable;	/* reachable time */
	u_int32_t		nd_ra_retransmit;	/* retransmit timer */
	/* could be followed by options */
} __packed;

#define nd_ra_type		nd_ra_hdr.icmp6_type
#define nd_ra_code		nd_ra_hdr.icmp6_code
#define nd_ra_cksum		nd_ra_hdr.icmp6_cksum
#define nd_ra_curhoplimit	nd_ra_hdr.icmp6_data8[0]
#define nd_ra_flags_reserved	nd_ra_hdr.icmp6_data8[1]
#define ND_RA_FLAG_MANAGED	0x80
#define ND_RA_FLAG_OTHER	0x40

#define ND_RA_FLAG_RTPREF_MASK	0x18	/* 00011000 */

#define ND_RA_FLAG_RTPREF_HIGH	0x08	/* 00001000 */ 
#define ND_RA_FLAG_RTPREF_MEDIUM	0x00	/* 00000000 */
#define ND_RA_FLAG_RTPREF_LOW	0x18	/* 00011000 */
#define ND_RA_FLAG_RTPREF_RSV	0x10	/* 00010000 */

#define nd_ra_router_lifetime	nd_ra_hdr.icmp6_data16[1]

struct nd_neighbor_solicit {	/* neighbor solicitation */
	struct icmp6_hdr	nd_ns_hdr;
	struct in6_addr		nd_ns_target;	/*target address */
	/* could be followed by options */
} __packed;

#define nd_ns_type		nd_ns_hdr.icmp6_type
#define nd_ns_code		nd_ns_hdr.icmp6_code
#define nd_ns_cksum		nd_ns_hdr.icmp6_cksum
#define nd_ns_reserved		nd_ns_hdr.icmp6_data32[0]

struct nd_neighbor_advert {	/* neighbor advertisement */
	struct icmp6_hdr	nd_na_hdr;
	struct in6_addr		nd_na_target;	/* target address */
	/* could be followed by options */
} __packed;

#define nd_na_type		nd_na_hdr.icmp6_type
#define nd_na_code		nd_na_hdr.icmp6_code
#define nd_na_cksum		nd_na_hdr.icmp6_cksum
#define nd_na_flags_reserved	nd_na_hdr.icmp6_data32[0]
#define ND_NA_FLAG_ROUTER		htonl(0x80000000)
#define ND_NA_FLAG_SOLICITED		htonl(0x40000000)
#define ND_NA_FLAG_OVERRIDE		htonl(0x20000000)

struct nd_redirect {		/* redirect */
	struct icmp6_hdr	nd_rd_hdr;
	struct in6_addr		nd_rd_target;	/* target address */
	struct in6_addr		nd_rd_dst;	/* destination address */
	/* could be followed by options */
} __packed;

#define nd_rd_type		nd_rd_hdr.icmp6_type
#define nd_rd_code		nd_rd_hdr.icmp6_code
#define nd_rd_cksum		nd_rd_hdr.icmp6_cksum
#define nd_rd_reserved		nd_rd_hdr.icmp6_data32[0]

struct nd_opt_hdr {		/* Neighbor discovery option header */
	u_int8_t	nd_opt_type;
	u_int8_t	nd_opt_len;
	/* followed by option specific data*/
} __packed;

#define ND_OPT_SOURCE_LINKADDR		1
#define ND_OPT_TARGET_LINKADDR		2
#define ND_OPT_PREFIX_INFORMATION	3
#define ND_OPT_REDIRECTED_HEADER	4
#define ND_OPT_MTU			5
#define ND_OPT_ROUTE_INFO		24
#define ND_OPT_RDNSS			25
#define ND_OPT_DNSSL			31

struct nd_opt_prefix_info {	/* prefix information */
	u_int8_t	nd_opt_pi_type;
	u_int8_t	nd_opt_pi_len;
	u_int8_t	nd_opt_pi_prefix_len;
	u_int8_t	nd_opt_pi_flags_reserved;
	u_int32_t	nd_opt_pi_valid_time;
	u_int32_t	nd_opt_pi_preferred_time;
	u_int32_t	nd_opt_pi_reserved2;
	struct in6_addr	nd_opt_pi_prefix;
} __packed;

#define ND_OPT_PI_FLAG_ONLINK		0x80
#define ND_OPT_PI_FLAG_AUTO		0x40

struct nd_opt_rd_hdr {		/* redirected header */
	u_int8_t	nd_opt_rh_type;
	u_int8_t	nd_opt_rh_len;
	u_int16_t	nd_opt_rh_reserved1;
	u_int32_t	nd_opt_rh_reserved2;
	/* followed by IP header and data */
} __packed;

struct nd_opt_mtu {		/* MTU option */
	u_int8_t	nd_opt_mtu_type;
	u_int8_t	nd_opt_mtu_len;
	u_int16_t	nd_opt_mtu_reserved;
	u_int32_t	nd_opt_mtu_mtu;
} __packed;

struct nd_opt_route_info {	/* route info */
	u_int8_t	nd_opt_rti_type;
	u_int8_t	nd_opt_rti_len;
	u_int8_t	nd_opt_rti_prefixlen;
	u_int8_t	nd_opt_rti_flags;
	u_int32_t	nd_opt_rti_lifetime;
} __packed;

struct nd_opt_rdnss {		/* RDNSS option */
	u_int8_t	nd_opt_rdnss_type;
	u_int8_t	nd_opt_rdnss_len;
	u_int16_t	nd_opt_rdnss_reserved;
	u_int32_t	nd_opt_rdnss_lifetime;
	/* followed by list of recursive DNS servers */
} __packed;

struct nd_opt_dnssl {		/* DNSSL option */
	u_int8_t	nd_opt_dnssl_type;
	u_int8_t	nd_opt_dnssl_len;
	u_int16_t	nd_opt_dnssl_reserved;
	u_int32_t	nd_opt_dnssl_lifetime;
	/* followed by list of DNS search domains */
} __packed;

/*
 * icmp6 namelookup
 */
struct icmp6_namelookup {
	struct icmp6_hdr 	icmp6_nl_hdr;
	u_int8_t	icmp6_nl_nonce[8];
	int32_t		icmp6_nl_ttl;
#if 0
	u_int8_t	icmp6_nl_len;
	u_int8_t	icmp6_nl_name[3];
#endif
	/* could be followed by options */
} __packed;

/*
 * icmp6 node information
 */
struct icmp6_nodeinfo {
	struct icmp6_hdr icmp6_ni_hdr;
	u_int8_t icmp6_ni_nonce[8];
	/* could be followed by reply data */
} __packed;

#define ni_type		icmp6_ni_hdr.icmp6_type
#define ni_code		icmp6_ni_hdr.icmp6_code
#define ni_cksum	icmp6_ni_hdr.icmp6_cksum
#define ni_qtype	icmp6_ni_hdr.icmp6_data16[0]
#define ni_flags	icmp6_ni_hdr.icmp6_data16[1]

#define NI_QTYPE_NOOP		0 /* NOOP  */
#define NI_QTYPE_SUPTYPES	1 /* Supported Qtypes */
#define NI_QTYPE_FQDN		2 /* FQDN (draft 04) */
#define NI_QTYPE_DNSNAME	2 /* DNS Name */
#define NI_QTYPE_NODEADDR	3 /* Node Addresses */
#define NI_QTYPE_IPV4ADDR	4 /* IPv4 Addresses */

#define NI_SUPTYPE_FLAG_COMPRESS	htons(0x0001)
#define NI_FQDN_FLAG_VALIDTTL		htons(0x0001)

#define NI_NODEADDR_FLAG_TRUNCATE	htons(0x0001)
#define NI_NODEADDR_FLAG_ALL		htons(0x0002)
#define NI_NODEADDR_FLAG_COMPAT		htons(0x0004)
#define NI_NODEADDR_FLAG_LINKLOCAL	htons(0x0008)
#define NI_NODEADDR_FLAG_SITELOCAL	htons(0x0010)
#define NI_NODEADDR_FLAG_GLOBAL		htons(0x0020)
#define NI_NODEADDR_FLAG_ANYCAST	htons(0x0040)	/* not in spec */

struct ni_reply_fqdn {
	u_int32_t ni_fqdn_ttl;	/* TTL */
	u_int8_t ni_fqdn_namelen; /* length in octets of the FQDN */
	u_int8_t ni_fqdn_name[3]; /* XXX: alignment */
} __packed;

/*
 * Router Renumbering. as router-renum-08.txt
 */
struct icmp6_router_renum {	/* router renumbering header */
	struct icmp6_hdr	rr_hdr;
	u_int8_t	rr_segnum;
	u_int8_t	rr_flags;
	u_int16_t	rr_maxdelay;
	u_int32_t	rr_reserved;
} __packed;

#define ICMP6_RR_FLAGS_TEST		0x80
#define ICMP6_RR_FLAGS_REQRESULT	0x40
#define ICMP6_RR_FLAGS_FORCEAPPLY	0x20
#define ICMP6_RR_FLAGS_SPECSITE		0x10
#define ICMP6_RR_FLAGS_PREVDONE		0x08

#define rr_type		rr_hdr.icmp6_type
#define rr_code		rr_hdr.icmp6_code
#define rr_cksum	rr_hdr.icmp6_cksum
#define rr_seqnum 	rr_hdr.icmp6_data32[0]

struct rr_pco_match {		/* match prefix part */
	u_int8_t	rpm_code;
	u_int8_t	rpm_len;
	u_int8_t	rpm_ordinal;
	u_int8_t	rpm_matchlen;
	u_int8_t	rpm_minlen;
	u_int8_t	rpm_maxlen;
	u_int16_t	rpm_reserved;
	struct	in6_addr	rpm_prefix;
} __packed;

#define RPM_PCO_ADD		1
#define RPM_PCO_CHANGE		2
#define RPM_PCO_SETGLOBAL	3
#define RPM_PCO_MAX		4

struct rr_pco_use {		/* use prefix part */
	u_int8_t	rpu_uselen;
	u_int8_t	rpu_keeplen;
	u_int8_t	rpu_ramask;
	u_int8_t	rpu_raflags;
	u_int32_t	rpu_vltime;
	u_int32_t	rpu_pltime;
	u_int32_t	rpu_flags;
	struct	in6_addr rpu_prefix;
} __packed;
#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK	0x80
#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO	0x40

#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME     htonl(0x80000000)
#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME     htonl(0x40000000)

struct rr_result {		/* router renumbering result message */
	u_int16_t	rrr_flags;
	u_int8_t	rrr_ordinal;
	u_int8_t	rrr_matchedlen;
	u_int32_t	rrr_ifid;
	struct	in6_addr rrr_prefix;
} __packed;
#define ICMP6_RR_RESULT_FLAGS_OOB		htons(0x0002)
#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN		htons(0x0001)

/*
 * icmp6 filter structures.
 */

struct icmp6_filter {
	u_int32_t icmp6_filt[8];
};

#define	ICMP6_FILTER_SETPASSALL(filterp) \
	memset(filterp, 0xff, sizeof(struct icmp6_filter))
#define	ICMP6_FILTER_SETBLOCKALL(filterp) \
	memset(filterp, 0x00, sizeof(struct icmp6_filter))
#define	ICMP6_FILTER_SETPASS(type, filterp) \
	(((filterp)->icmp6_filt[(type) >> 5]) |= (1 << ((type) & 31)))
#define	ICMP6_FILTER_SETBLOCK(type, filterp) \
	(((filterp)->icmp6_filt[(type) >> 5]) &= ~(1 << ((type) & 31)))
#define	ICMP6_FILTER_WILLPASS(type, filterp) \
	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) != 0)
#define	ICMP6_FILTER_WILLBLOCK(type, filterp) \
	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) == 0)

/*
 * Variables related to this implementation
 * of the internet control message protocol version 6.
 */
struct icmp6stat {
/* statistics related to icmp6 packets generated */
	u_int64_t icp6s_error;		/* # of calls to icmp6_error */
	u_int64_t icp6s_canterror;	/* no error because old was icmp */
	u_int64_t icp6s_toofreq;	/* no error because rate limitation */
	u_int64_t icp6s_outhist[256];
/* statistics related to input message processed */
	u_int64_t icp6s_badcode;	/* icmp6_code out of range */
	u_int64_t icp6s_tooshort;	/* packet < sizeof(struct icmp6_hdr) */
	u_int64_t icp6s_checksum;	/* bad checksum */
	u_int64_t icp6s_badlen;		/* calculated bound mismatch */
	/*
	 * number of responses: this member is inherited from netinet code, but
	 * for netinet6 code, it is already available in icp6s_outhist[].
	 */
	u_int64_t icp6s_reflect;
	u_int64_t icp6s_inhist[256];
	u_int64_t icp6s_nd_toomanyopt;	/* too many ND options */
	u_int64_t icp6s_odst_unreach_noroute;
	u_int64_t icp6s_odst_unreach_admin;
	u_int64_t icp6s_odst_unreach_beyondscope;
	u_int64_t icp6s_odst_unreach_addr;
	u_int64_t icp6s_odst_unreach_noport;
	u_int64_t icp6s_opacket_too_big;
	u_int64_t icp6s_otime_exceed_transit;
	u_int64_t icp6s_otime_exceed_reassembly;
	u_int64_t icp6s_oparamprob_header;
	u_int64_t icp6s_oparamprob_nextheader;
	u_int64_t icp6s_oparamprob_option;
	u_int64_t icp6s_oredirect;	/* we regard redirect as an error here */
	u_int64_t icp6s_ounknown;
	u_int64_t icp6s_pmtuchg;	/* path MTU changes */
	u_int64_t icp6s_nd_badopt;	/* bad ND options */
	u_int64_t icp6s_badns;		/* bad neighbor solicitation */
	u_int64_t icp6s_badna;		/* bad neighbor advertisement */
	u_int64_t icp6s_badrs;		/* bad router advertisement */
	u_int64_t icp6s_badra;		/* bad router advertisement */
	u_int64_t icp6s_badredirect;	/* bad redirect message */
};

/*
 * Names for ICMP sysctl objects
 */
#define ICMPV6CTL_STATS		1
#define ICMPV6CTL_REDIRACCEPT	2	/* accept/process redirects */
#define ICMPV6CTL_REDIRTIMEOUT	3	/* redirect cache time */
#define ICMPV6CTL_ND6_DELAY	8
#define ICMPV6CTL_ND6_UMAXTRIES	9
#define ICMPV6CTL_ND6_MMAXTRIES		10
#define ICMPV6CTL_NODEINFO	13
#define ICMPV6CTL_ERRPPSLIMIT	14	/* ICMPv6 error pps limitation */
#define ICMPV6CTL_ND6_MAXNUDHINT	15
#define ICMPV6CTL_MTUDISC_HIWAT	16
#define ICMPV6CTL_MTUDISC_LOWAT	17
#define ICMPV6CTL_ND6_DEBUG	18
#define ICMPV6CTL_MAXID		19

#define ICMPV6CTL_NAMES { \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "redirtimeout", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "nd6_delay", CTLTYPE_INT }, \
	{ "nd6_umaxtries", CTLTYPE_INT }, \
	{ "nd6_mmaxtries", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "errppslimit", CTLTYPE_INT }, \
	{ "nd6_maxnudhint", CTLTYPE_INT }, \
	{ "mtudisc_hiwat", CTLTYPE_INT }, \
	{ "mtudisc_lowat", CTLTYPE_INT }, \
	{ "nd6_debug", CTLTYPE_INT }, \
}

#define ICMPV6CTL_VARS { \
	NULL, \
	NULL, \
	NULL, \
	&icmp6_redirtimeout, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	&nd6_delay, \
	&nd6_umaxtries, \
	&nd6_mmaxtries, \
	NULL, \
	NULL, \
	NULL, \
	&icmp6errppslim, \
	&nd6_maxnudhint, \
	&icmp6_mtudisc_hiwat, \
	&icmp6_mtudisc_lowat, \
	&nd6_debug, \
}

#define RTF_PROBEMTU	RTF_PROTO1

#ifdef _KERNEL

#include <sys/percpu.h>

enum icmp6stat_counters {
	icp6s_error,
	icp6s_canterror,
	icp6s_toofreq,
	icp6s_outhist,
	icp6s_badcode = icp6s_outhist + 256,
	icp6s_tooshort,
	icp6s_checksum,
	icp6s_badlen,
	icp6s_reflect,
	icp6s_inhist,
	icp6s_nd_toomanyopt = icp6s_inhist + 256,
	icp6s_odst_unreach_noroute,
	icp6s_odst_unreach_admin,
	icp6s_odst_unreach_beyondscope,
	icp6s_odst_unreach_addr,
	icp6s_odst_unreach_noport,
	icp6s_opacket_too_big,
	icp6s_otime_exceed_transit,
	icp6s_otime_exceed_reassembly,
	icp6s_oparamprob_header,
	icp6s_oparamprob_nextheader,
	icp6s_oparamprob_option,
	icp6s_oredirect,
	icp6s_ounknown,
	icp6s_pmtuchg,
	icp6s_nd_badopt,
	icp6s_badns,
	icp6s_badna,
	icp6s_badrs,
	icp6s_badra,
	icp6s_badredirect,
	icp6s_ncounters,
};

extern struct cpumem *icmp6counters;

static inline void
icmp6stat_inc(enum icmp6stat_counters c)
{
	counters_inc(icmp6counters, c);
}

struct	rtentry;
struct	rttimer;
struct	in6_multi;

void	icmp6_init(void);
void	icmp6_paramerror(struct mbuf *, int);
void	icmp6_error(struct mbuf *, int, int, int);
int	icmp6_input(struct mbuf **, int *, int, int);
void	icmp6_fasttimo(void);
void	icmp6_reflect(struct mbuf *, size_t);
void	icmp6_prepare(struct mbuf *);
void	icmp6_redirect_input(struct mbuf *, int);
void	icmp6_redirect_output(struct mbuf *, struct rtentry *);
int	icmp6_sysctl(int *, u_int, void *, size_t *, void *, size_t);

struct	ip6ctlparam;
void	icmp6_mtudisc_update(struct ip6ctlparam *, int);
void	icmp6_mtudisc_callback_register(void (*)(struct sockaddr_in6 *, u_int));

extern int	icmp6_redirtimeout;	/* cache time for redirect routes */

#endif /* _KERNEL */
#endif /* _NETINET_ICMP6_H_ */
@


1.46
log
@Since nearly 20 years the correct spelling of
ICMP6_DST_UNREACH_NOTNEIGHBOR is ICMP6_DST_UNREACH_BEYONDSCOPE (RFC
1885 was obsoleted).
sthen grepped the ports sources to make sure nothing uses it.
OK millert, jca
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.45 2017/07/12 16:53:58 florian Exp $	*/
a504 1
#define ICMPV6CTL_ND6_PRUNE	6
d523 1
a523 1
	{ "nd6_prune", CTLTYPE_INT }, \
d545 1
a545 1
	&nd6_prune, \
@


1.45
log
@Get rid of ICMPV6CTL_ND6_DRLIST and ICMPV6CTL_ND6_PRLIST sysctls
With this we can also get rid of in6_prefix and in6_defrouter. They
are meaningless, the kernel no longer tracks this information.

Pointed out by & OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.44 2017/04/14 20:46:31 bluhm Exp $	*/
a129 1
#define ICMP6_DST_UNREACH_NOTNEIGHBOR	2	/* not a neighbor(obsolete) */
@


1.44
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.43 2017/02/09 15:23:35 jca Exp $	*/
d516 1
a516 3
#define ICMPV6CTL_ND6_DRLIST	19
#define ICMPV6CTL_ND6_PRLIST	20
#define ICMPV6CTL_MAXID		21
a537 2
	{ 0, 0 }, \
	{ 0, 0 }, \
a559 2
	NULL, \
	NULL, \
@


1.43
log
@percpu counters for raw ipv6 and icmp6 stats

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.42 2015/09/09 15:51:40 mpi Exp $	*/
d624 1
a624 1
int	icmp6_input(struct mbuf **, int *, int);
@


1.42
log
@Kill icmp6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_ICMP6 is no longer supported.

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.41 2014/08/27 14:04:15 florian Exp $	*/
a459 16
struct icmp6errstat {
	u_int64_t icp6errs_dst_unreach_noroute;
	u_int64_t icp6errs_dst_unreach_admin;
	u_int64_t icp6errs_dst_unreach_beyondscope;
	u_int64_t icp6errs_dst_unreach_addr;
	u_int64_t icp6errs_dst_unreach_noport;
	u_int64_t icp6errs_packet_too_big;
	u_int64_t icp6errs_time_exceed_transit;
	u_int64_t icp6errs_time_exceed_reassembly;
	u_int64_t icp6errs_paramprob_header;
	u_int64_t icp6errs_paramprob_nextheader;
	u_int64_t icp6errs_paramprob_option;
	u_int64_t icp6errs_redirect; /* we regard redirect as an error here */
	u_int64_t icp6errs_unknown;
};

d478 13
a490 19
	struct icmp6errstat icp6s_outerrhist;
#define icp6s_odst_unreach_noroute \
	icp6s_outerrhist.icp6errs_dst_unreach_noroute
#define icp6s_odst_unreach_admin icp6s_outerrhist.icp6errs_dst_unreach_admin
#define icp6s_odst_unreach_beyondscope \
	icp6s_outerrhist.icp6errs_dst_unreach_beyondscope
#define icp6s_odst_unreach_addr icp6s_outerrhist.icp6errs_dst_unreach_addr
#define icp6s_odst_unreach_noport icp6s_outerrhist.icp6errs_dst_unreach_noport
#define icp6s_opacket_too_big icp6s_outerrhist.icp6errs_packet_too_big
#define icp6s_otime_exceed_transit \
	icp6s_outerrhist.icp6errs_time_exceed_transit
#define icp6s_otime_exceed_reassembly \
	icp6s_outerrhist.icp6errs_time_exceed_reassembly
#define icp6s_oparamprob_header icp6s_outerrhist.icp6errs_paramprob_header
#define icp6s_oparamprob_nextheader \
	icp6s_outerrhist.icp6errs_paramprob_nextheader
#define icp6s_oparamprob_option icp6s_outerrhist.icp6errs_paramprob_option
#define icp6s_oredirect icp6s_outerrhist.icp6errs_redirect
#define icp6s_ounknown icp6s_outerrhist.icp6errs_unknown
d571 45
@


1.41
log
@Nuke net.inet6.icmp6.rediraccept and allow redirects on interfaces
with autoconf enabled.
If one is doing SLAAC one does already trust link local icmp6 so the
policy for icmp6 redirects should be the same.
pointed out by & OK bluhm@@; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.40 2014/07/11 12:20:26 benno Exp $	*/
a611 58

/* XXX: is this the right place for these macros? */
#define icmp6_ifstat_inc(ifp, tag) \
do {								\
	if (ifp)						\
		((struct in6_ifextra *)((ifp)->if_afdata[AF_INET6]))->icmp6_ifstat->tag++; \
} while (0)

#define icmp6_ifoutstat_inc(ifp, type, code) \
do { \
		icmp6_ifstat_inc(ifp, ifs6_out_msg); \
		switch(type) { \
		 case ICMP6_DST_UNREACH: \
			 icmp6_ifstat_inc(ifp, ifs6_out_dstunreach); \
			 if (code == ICMP6_DST_UNREACH_ADMIN) \
				 icmp6_ifstat_inc(ifp, ifs6_out_adminprohib); \
			 break; \
		 case ICMP6_PACKET_TOO_BIG: \
			 icmp6_ifstat_inc(ifp, ifs6_out_pkttoobig); \
			 break; \
		 case ICMP6_TIME_EXCEEDED: \
			 icmp6_ifstat_inc(ifp, ifs6_out_timeexceed); \
			 break; \
		 case ICMP6_PARAM_PROB: \
			 icmp6_ifstat_inc(ifp, ifs6_out_paramprob); \
			 break; \
		 case ICMP6_ECHO_REQUEST: \
			 icmp6_ifstat_inc(ifp, ifs6_out_echo); \
			 break; \
		 case ICMP6_ECHO_REPLY: \
			 icmp6_ifstat_inc(ifp, ifs6_out_echoreply); \
			 break; \
		 case MLD_LISTENER_QUERY: \
			 icmp6_ifstat_inc(ifp, ifs6_out_mldquery); \
			 break; \
		 case MLD_LISTENER_REPORT: \
			 icmp6_ifstat_inc(ifp, ifs6_out_mldreport); \
			 break; \
		 case MLD_LISTENER_DONE: \
			 icmp6_ifstat_inc(ifp, ifs6_out_mlddone); \
			 break; \
		 case ND_ROUTER_SOLICIT: \
			 icmp6_ifstat_inc(ifp, ifs6_out_routersolicit); \
			 break; \
		 case ND_ROUTER_ADVERT: \
			 icmp6_ifstat_inc(ifp, ifs6_out_routeradvert); \
			 break; \
		 case ND_NEIGHBOR_SOLICIT: \
			 icmp6_ifstat_inc(ifp, ifs6_out_neighborsolicit); \
			 break; \
		 case ND_NEIGHBOR_ADVERT: \
			 icmp6_ifstat_inc(ifp, ifs6_out_neighboradvert); \
			 break; \
		 case ND_REDIRECT: \
			 icmp6_ifstat_inc(ifp, ifs6_out_redirect); \
			 break; \
		} \
} while (0)
@


1.40
log
@Remove rfc 4620 Node Information Query support (from the kernel).

ok henning@@ stu@@, Yay! weerd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.39 2014/05/07 08:14:59 mpi Exp $	*/
d545 1
a545 1
	{ "rediraccept", CTLTYPE_INT }, \
d569 1
a569 1
	&icmp6_rediraccept, \
a670 1
extern int	icmp6_rediraccept;	/* accept/process redirects */
@


1.39
log
@Kill the {nd6_,}useloopback buttons, using the loopback interface for
local traffic is not optional.

ok mikeb@@, stsp@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.38 2013/10/24 11:20:16 deraadt Exp $	*/
d556 1
a556 1
	{ "nodeinfo", CTLTYPE_INT }, \
d580 1
a580 1
	&icmp6_nodeinfo, \
@


1.38
log
@Significant namespace cleanup of netinet6 symbols.

One worrying bit is in icmp6.h where some htols() and htonl() are
added, which may affect compatibility down the line.  This component
can be reverted if issues show up.  Ports tree greps indicate no issue.

ok claudio mpi etc
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.37 2013/10/21 08:42:24 phessler Exp $	*/
a531 1
#define ICMPV6CTL_ND6_USELOOPBACK	11
d554 1
a554 1
	{ "nd6_useloopback", CTLTYPE_INT }, \
d578 1
a578 1
	&nd6_useloopback, \
@


1.37
log
@Sprinkle a lot more IPv6 routing domains support in the kernel.

Mostly mechanical, setting and passing the rdomain and rtable correctly.
Not yet enabled.

Lots of help and hints from claudio and bluhm

OK claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.36 2013/06/01 01:30:53 brad Exp $	*/
a105 7
#ifndef _KERNEL
/* the followings are for backward compatibility to old KAME apps. */
#define MLD6_LISTENER_QUERY	MLD_LISTENER_QUERY
#define MLD6_LISTENER_REPORT	MLD_LISTENER_REPORT
#define MLD6_LISTENER_DONE	MLD_LISTENER_DONE
#endif

a125 6
#ifndef _KERNEL
/* the followings are for backward compatibility to old KAME apps. */
#define MLD6_MTRACE_RESP	MLD_MTRACE_RESP
#define MLD6_MTRACE		MLD_MTRACE
#endif

a167 11
/* definitions to provide backward compatibility to old KAME applications */
#ifndef _KERNEL
#define mld6_hdr	mld_hdr
#define mld6_type	mld_type
#define mld6_code	mld_code
#define mld6_cksum	mld_cksum
#define mld6_maxdelay	mld_maxdelay
#define mld6_reserved	mld_reserved
#define mld6_addr	mld_addr
#endif

d234 3
a236 11
#if _BYTE_ORDER == _BIG_ENDIAN
#define ND_NA_FLAG_ROUTER		0x80000000
#define ND_NA_FLAG_SOLICITED		0x40000000
#define ND_NA_FLAG_OVERRIDE		0x20000000
#else
#if _BYTE_ORDER == _LITTLE_ENDIAN
#define ND_NA_FLAG_ROUTER		0x80
#define ND_NA_FLAG_SOLICITED		0x40
#define ND_NA_FLAG_OVERRIDE		0x20
#endif
#endif
a320 1

d354 2
a355 7
#if _BYTE_ORDER == _BIG_ENDIAN
#define NI_SUPTYPE_FLAG_COMPRESS	0x1
#define NI_FQDN_FLAG_VALIDTTL		0x1
#elif _BYTE_ORDER == _LITTLE_ENDIAN
#define NI_SUPTYPE_FLAG_COMPRESS	0x0100
#define NI_FQDN_FLAG_VALIDTTL		0x0100
#endif
d357 7
a363 35
#ifdef NAME_LOOKUPS_04
#if _BYTE_ORDER == _BIG_ENDIAN
#define NI_NODEADDR_FLAG_LINKLOCAL	0x1
#define NI_NODEADDR_FLAG_SITELOCAL	0x2
#define NI_NODEADDR_FLAG_GLOBAL		0x4
#define NI_NODEADDR_FLAG_ALL		0x8
#define NI_NODEADDR_FLAG_TRUNCATE	0x10
#define NI_NODEADDR_FLAG_ANYCAST	0x20 /* just experimental. not in spec */
#elif _BYTE_ORDER == _LITTLE_ENDIAN
#define NI_NODEADDR_FLAG_LINKLOCAL	0x0100
#define NI_NODEADDR_FLAG_SITELOCAL	0x0200
#define NI_NODEADDR_FLAG_GLOBAL		0x0400
#define NI_NODEADDR_FLAG_ALL		0x0800
#define NI_NODEADDR_FLAG_TRUNCATE	0x1000
#define NI_NODEADDR_FLAG_ANYCAST	0x2000 /* just experimental. not in spec */
#endif
#else  /* draft-ietf-ipngwg-icmp-name-lookups-05 (and later?) */
#if _BYTE_ORDER == _BIG_ENDIAN
#define NI_NODEADDR_FLAG_TRUNCATE	0x1
#define NI_NODEADDR_FLAG_ALL		0x2
#define NI_NODEADDR_FLAG_COMPAT		0x4
#define NI_NODEADDR_FLAG_LINKLOCAL	0x8
#define NI_NODEADDR_FLAG_SITELOCAL	0x10
#define NI_NODEADDR_FLAG_GLOBAL		0x20
#define NI_NODEADDR_FLAG_ANYCAST	0x40 /* just experimental. not in spec */
#elif _BYTE_ORDER == _LITTLE_ENDIAN
#define NI_NODEADDR_FLAG_TRUNCATE	0x0100
#define NI_NODEADDR_FLAG_ALL		0x0200
#define NI_NODEADDR_FLAG_COMPAT		0x0400
#define NI_NODEADDR_FLAG_LINKLOCAL	0x0800
#define NI_NODEADDR_FLAG_SITELOCAL	0x1000
#define NI_NODEADDR_FLAG_GLOBAL		0x2000
#define NI_NODEADDR_FLAG_ANYCAST	0x4000 /* just experimental. not in spec */
#endif
#endif
d422 2
a423 7
#if _BYTE_ORDER == _BIG_ENDIAN
#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME     0x80000000
#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME     0x40000000
#elif _BYTE_ORDER == _LITTLE_ENDIAN
#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME     0x80
#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME     0x40
#endif
d432 2
a433 7
#if _BYTE_ORDER == _BIG_ENDIAN
#define ICMP6_RR_RESULT_FLAGS_OOB		0x0002
#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN		0x0001
#elif _BYTE_ORDER == _LITTLE_ENDIAN
#define ICMP6_RR_RESULT_FLAGS_OOB		0x0200
#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN		0x0100
#endif
a442 11
#ifdef _KERNEL
#define	ICMP6_FILTER_SETPASSALL(filterp) \
do {								\
	int i; u_char *p;					\
	p = (u_char *)filterp;					\
	for (i = 0; i < sizeof(struct icmp6_filter); i++)	\
		p[i] = 0xff;					\
} while (0)
#define	ICMP6_FILTER_SETBLOCKALL(filterp) \
	bzero(filterp, sizeof(struct icmp6_filter))
#else /* _KERNEL */
a446 2
#endif /* _KERNEL */

a527 3
#if 0	/*obsoleted*/
#define ICMPV6CTL_ERRRATELIMIT	5	/* ICMPv6 error rate limitation */
#endif
a532 1
/*#define ICMPV6CTL_ND6_PROXYALL	12	obsoleted, do not reuse here */
d594 1
a594 1
# ifdef __STDC__
d598 1
a598 1
# endif
d674 1
@


1.36
log
@Add support for advertising route information (RFC 4191).

From FreeBSD via UMEZAWA Takeshi

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.35 2013/03/17 00:38:29 brad Exp $	*/
d705 1
a705 1
void	icmp6_mtudisc_callback_register(void (*)(struct in6_addr *));
@


1.35
log
@Add the router preference defines to the icmp6.h header and remove the
defines that were part of rtadvd's code.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.34 2012/07/08 10:45:46 phessler Exp $	*/
d293 1
d324 8
@


1.34
log
@Add support for advertising dns servers and search paths in router
advertisements, according to RFC 6106.

original diff from Stephane A. Sezer on tech@@, many thanks!

OK phessler@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.33 2010/03/22 12:23:32 jsg Exp $	*/
d227 8
@


1.33
log
@Add some MLDv2 definitions from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.32 2006/07/06 02:56:58 brad Exp $	*/
d285 2
d315 16
@


1.32
log
@u_quad_t -> u_int64_t

no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.31 2006/04/27 02:19:32 tedu Exp $	*/
d127 1
@


1.31
log
@use underscore variants of _BYTE_ORDER macros which are always defined
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.30 2006/03/07 09:21:55 jmc Exp $	*/
d514 13
a526 13
	u_quad_t icp6errs_dst_unreach_noroute;
	u_quad_t icp6errs_dst_unreach_admin;
	u_quad_t icp6errs_dst_unreach_beyondscope;
	u_quad_t icp6errs_dst_unreach_addr;
	u_quad_t icp6errs_dst_unreach_noport;
	u_quad_t icp6errs_packet_too_big;
	u_quad_t icp6errs_time_exceed_transit;
	u_quad_t icp6errs_time_exceed_reassembly;
	u_quad_t icp6errs_paramprob_header;
	u_quad_t icp6errs_paramprob_nextheader;
	u_quad_t icp6errs_paramprob_option;
	u_quad_t icp6errs_redirect; /* we regard redirect as an error here */
	u_quad_t icp6errs_unknown;
d531 4
a534 4
	u_quad_t icp6s_error;		/* # of calls to icmp6_error */
	u_quad_t icp6s_canterror;	/* no error because old was icmp */
	u_quad_t icp6s_toofreq;		/* no error because rate limitation */
	u_quad_t icp6s_outhist[256];
d536 4
a539 4
	u_quad_t icp6s_badcode;		/* icmp6_code out of range */
	u_quad_t icp6s_tooshort;	/* packet < sizeof(struct icmp6_hdr) */
	u_quad_t icp6s_checksum;	/* bad checksum */
	u_quad_t icp6s_badlen;		/* calculated bound mismatch */
d544 3
a546 3
	u_quad_t icp6s_reflect;
	u_quad_t icp6s_inhist[256];
	u_quad_t icp6s_nd_toomanyopt;	/* too many ND options */
d566 7
a572 7
	u_quad_t icp6s_pmtuchg;		/* path MTU changes */
	u_quad_t icp6s_nd_badopt;	/* bad ND options */
	u_quad_t icp6s_badns;		/* bad neighbor solicitation */
	u_quad_t icp6s_badna;		/* bad neighbor advertisement */
	u_quad_t icp6s_badrs;		/* bad router advertisement */
	u_quad_t icp6s_badra;		/* bad router advertisement */
	u_quad_t icp6s_badredirect;	/* bad redirect message */
@


1.30
log
@advertisment -> advertisement; from leonardo chiquitto filho
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.29 2004/02/15 11:16:08 markus Exp $	*/
d249 1
a249 1
#if BYTE_ORDER == BIG_ENDIAN
d254 1
a254 1
#if BYTE_ORDER == LITTLE_ENDIAN
d351 1
a351 1
#if BYTE_ORDER == BIG_ENDIAN
d354 1
a354 1
#elif BYTE_ORDER == LITTLE_ENDIAN
d360 1
a360 1
#if BYTE_ORDER == BIG_ENDIAN
d367 1
a367 1
#elif BYTE_ORDER == LITTLE_ENDIAN
d376 1
a376 1
#if BYTE_ORDER == BIG_ENDIAN
d384 1
a384 1
#elif BYTE_ORDER == LITTLE_ENDIAN
d452 1
a452 1
#if BYTE_ORDER == BIG_ENDIAN
d455 1
a455 1
#elif BYTE_ORDER == LITTLE_ENDIAN
d467 1
a467 1
#if BYTE_ORDER == BIG_ENDIAN
d470 1
a470 1
#elif BYTE_ORDER == LITTLE_ENDIAN
@


1.29
log
@switch to sysctl_int_arr(); ok itojun, henning, miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.28 2003/11/16 20:30:07 avsm Exp $	*/
d114 1
a114 1
#define ND_ROUTER_ADVERT		134	/* router advertisment */
d116 1
a116 1
#define ND_NEIGHBOR_ADVERT		136	/* neighbor advertisment */
@


1.28
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.27 2003/06/11 02:54:02 itojun Exp $	*/
d622 24
@


1.27
log
@- sync up MLD declaration with RFC3542 (s/MLD6/MLD/)
- routing header declaration with RFC3542
  (note: sizeof(ip6_rthdr0) has changed!)
  also, sync up with RFC2460 routing header definition (no "strict" source
  routing mode any more)

part of advanced API update (RFC2292 -> 3542).

markus, todd, millert, henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.26 2003/06/02 23:28:13 millert Exp $	*/
d79 1
a79 1
} __attribute__((__packed__));
d178 1
a178 1
} __attribute__((__packed__));
d205 1
a205 1
} __attribute__((__packed__));
d217 1
a217 1
} __attribute__((__packed__));
d232 1
a232 1
} __attribute__((__packed__));
d243 1
a243 1
} __attribute__((__packed__));
d266 1
a266 1
} __attribute__((__packed__));
d277 1
a277 1
} __attribute__((__packed__));
d294 1
a294 1
} __attribute__((__packed__));
d305 1
a305 1
} __attribute__((__packed__));
d312 1
a312 1
} __attribute__((__packed__));
d327 1
a327 1
} __attribute__((__packed__));
d336 1
a336 1
} __attribute__((__packed__));
d399 1
a399 1
} __attribute__((__packed__));
d410 1
a410 1
} __attribute__((__packed__));
d432 1
a432 1
} __attribute__((__packed__));
d448 1
a448 1
} __attribute__((__packed__));
d466 1
a466 1
} __attribute__((__packed__));
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.25 2002/06/09 16:26:10 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.71 2002/05/27 04:18:29 itojun Exp $	*/
d97 5
a102 1
#define MLD6_LISTENER_QUERY		130 	/* multicast listener query */
a103 1
#define MLD6_LISTENER_REPORT		131	/* multicast listener report */
d105 7
a111 1
#define MLD6_LISTENER_DONE		132	/* multicast listener done */
d129 8
a136 2
#define MLD6_MTRACE_RESP		200	/* mtrace response(to sender) */
#define MLD6_MTRACE			201	/* mtrace messages */
d175 3
a177 3
struct mld6_hdr {
	struct icmp6_hdr	mld6_hdr;
	struct in6_addr		mld6_addr; /* multicast address */
d180 17
a196 5
#define mld6_type	mld6_hdr.icmp6_type
#define mld6_code	mld6_hdr.icmp6_code
#define mld6_cksum	mld6_hdr.icmp6_cksum
#define mld6_maxdelay	mld6_hdr.icmp6_data16[0]
#define mld6_reserved	mld6_hdr.icmp6_data16[1]
d678 1
a678 1
		 case MLD6_LISTENER_QUERY: \
d681 1
a681 1
		 case MLD6_LISTENER_REPORT: \
d684 1
a684 1
		 case MLD6_LISTENER_DONE: \
@


1.25
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.24 2002/06/09 02:11:47 jsyn Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@fix the use of "cuz" in the tree; these are all in comments

noticed by aaron@@, recommended by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.23 2002/06/08 21:22:02 itojun Exp $	*/
d522 1
a522 1
	u_quad_t icp6s_inhist[256];	
@


1.23
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.22 2002/05/29 02:59:12 itojun Exp $	*/
d509 2
a510 2
	u_quad_t icp6s_canterror;	/* no error 'cuz old was icmp */
	u_quad_t icp6s_toofreq;		/* no error 'cuz rate limitation */
@


1.22
log
@move per-interface ip6/icmp6 stat to ifnet->if_afdata.   sync w/kame
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.21 2002/03/14 03:16:11 millert Exp $	*/
/*	$KAME: icmp6.h,v 1.39 2001/02/06 03:48:06 itojun Exp $	*/
d573 3
a575 1
#define ICMPV6CTL_MAXID		19
d597 2
@


1.21
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.20 2002/03/14 01:27:11 millert Exp $	*/
d623 2
a624 5
	if ((ifp) && (ifp)->if_index <= if_index			\
	 && (ifp)->if_index < icmp6_ifstatmax			\
	 && icmp6_ifstat && icmp6_ifstat[(ifp)->if_index]) {	\
		icmp6_ifstat[(ifp)->if_index]->tag++;		\
	}							\
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.19 2001/12/28 02:29:13 itojun Exp $	*/
d618 1
a618 1
void	icmp6_mtudisc_callback_register __P((void (*)(struct in6_addr *)));
@


1.19
log
@move experimental icmp6 type to 200; 141-142 are used for inverse neighbor
discovery.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.18 2001/12/07 09:33:10 itojun Exp $	*/
d605 10
a614 10
void	icmp6_init __P((void));
void	icmp6_paramerror __P((struct mbuf *, int));
void	icmp6_error __P((struct mbuf *, int, int, int));
int	icmp6_input __P((struct mbuf **, int *, int));
void	icmp6_fasttimo __P((void));
void	icmp6_reflect __P((struct mbuf *, size_t));
void	icmp6_prepare __P((struct mbuf *));
void	icmp6_redirect_input __P((struct mbuf *, int));
void	icmp6_redirect_output __P((struct mbuf *, struct rtentry *));
int	icmp6_sysctl __P((int *, u_int, void *, size_t *, void *, size_t));
d617 1
a617 1
void	icmp6_mtudisc_update __P((struct ip6ctlparam *, int));
@


1.18
log
@correct icmp6 MIB counter mistake
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.17 2001/12/06 03:28:49 itojun Exp $	*/
d124 2
a125 2
#define MLD6_MTRACE_RESP		141	/* mtrace response(to sender) */
#define MLD6_MTRACE			142	/* mtrace messages */
d127 1
a127 1
#define ICMP6_MAXTYPE			142
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.19 2001/12/28 02:29:13 itojun Exp $	*/
d124 2
a125 2
#define MLD6_MTRACE_RESP		200	/* mtrace response(to sender) */
#define MLD6_MTRACE			201	/* mtrace messages */
d127 1
a127 1
#define ICMP6_MAXTYPE			201
@


1.18.2.2
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: icmp6.h,v 1.71 2002/05/27 04:18:29 itojun Exp $	*/
d509 2
a510 2
	u_quad_t icp6s_canterror;	/* no error because old was icmp */
	u_quad_t icp6s_toofreq;		/* no error because rate limitation */
d573 1
a573 3
#define ICMPV6CTL_ND6_DRLIST	19
#define ICMPV6CTL_ND6_PRLIST	20
#define ICMPV6CTL_MAXID		21
a594 2
	{ 0, 0 }, \
	{ 0, 0 }, \
d605 10
a614 10
void	icmp6_init(void);
void	icmp6_paramerror(struct mbuf *, int);
void	icmp6_error(struct mbuf *, int, int, int);
int	icmp6_input(struct mbuf **, int *, int);
void	icmp6_fasttimo(void);
void	icmp6_reflect(struct mbuf *, size_t);
void	icmp6_prepare(struct mbuf *);
void	icmp6_redirect_input(struct mbuf *, int);
void	icmp6_redirect_output(struct mbuf *, struct rtentry *);
int	icmp6_sysctl(int *, u_int, void *, size_t *, void *, size_t);
d617 2
a618 2
void	icmp6_mtudisc_update(struct ip6ctlparam *, int);
void	icmp6_mtudisc_callback_register(void (*)(struct in6_addr *));
d623 5
a627 2
	if (ifp)						\
		((struct in6_ifextra *)((ifp)->if_afdata[AF_INET6]))->icmp6_ifstat->tag++; \
@


1.18.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.18.2.2 2002/06/11 03:31:36 art Exp $	*/
d522 1
a522 1
	u_quad_t icp6s_inhist[256];
@


1.17
log
@put __attribute__ to header decls to avoid align strangeness.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.16 2001/06/09 07:03:39 angelos Exp $	*/
a632 2
 		if (type < ICMP6_INFOMSG_MASK) \
 			icmp6_ifstat_inc(ifp, ifs6_out_error); \
@


1.16
log
@Inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.15 2001/02/07 11:43:52 itojun Exp $	*/
d83 1
a83 1
};
d167 1
a167 1
};
d182 1
a182 1
};
d194 1
a194 1
};
d209 1
a209 1
};
d220 1
a220 1
};
d243 1
a243 1
};
d254 1
a254 1
};
d271 1
a271 1
};
d276 1
a276 1
struct nd_opt_rd_hdr {         /* redirected header */
d282 1
a282 1
};
d289 1
a289 1
};
d304 1
a304 1
};
d313 1
a313 1
};
d376 1
a376 1
};
d387 1
a387 1
};
d409 1
a409 1
};
d425 1
a425 1
};
d443 1
a443 1
};
d517 5
a521 1
	u_quad_t icp6s_reflect;		/* number of responses */
@


1.15
log
@by default, don't bark on inbound ND messages, as outsider may be able to
fill up /var with bogus packets.
setting net.inet6.icmp6.nd6_debug will re-enable kernel messages on invalid
ND packet and other occasions.

improve icmp6 stats.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.14 2001/01/22 04:31:21 itojun Exp $	*/
d682 1
a682 2

#endif /* not _NETINET_ICMP6_H_ */
@


1.14
log
@fix router renumbering bit decl for little endian.  KAME PR 320
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.13 2001/01/21 15:42:35 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.32 2001/01/22 02:26:00 itojun Exp $	*/
d540 6
d568 2
a569 1
#define ICMPV6CTL_MAXID		18
d590 1
@


1.13
log
@sync router renumbering flag bit to conform to 2292bis-02 and RR RFC.
sync with latest kame rtadvd (again).  mostly cosmetic.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.12 2000/12/11 08:04:55 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.31 2001/01/21 15:32:16 itojun Exp $	*/
d448 2
a449 2
#define ICMP6_RR_RESULT_FLAGS_OOB		0x02
#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN		0x01
@


1.12
log
@nuke #ifdef TCP6 (no longer supported).
validate ICMPv6 too big messages (pmtud) based on pcb.  we accept
certain amount of non-validated ones, as IPv6 mandates ICMPv6 (so even for
traffic from unconnected pcb, we need pmtud).
sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.11 2000/10/10 15:53:07 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.24 2000/10/18 19:24:24 itojun Exp $	*/
d388 6
a393 6
#define ICMP6_RR_FLAGS_SEGNUM		0x80
#define ICMP6_RR_FLAGS_TEST		0x40
#define ICMP6_RR_FLAGS_REQRESULT	0x20
#define ICMP6_RR_FLAGS_FORCEAPPLY	0x10
#define ICMP6_RR_FLAGS_SPECSITE		0x08
#define ICMP6_RR_FLAGS_PREVDONE		0x04
@


1.11
log
@little bit of sync with kame ($KAME, s/u_char/u_int8_t/)
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.10 2000/10/10 14:24:32 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.23 2000/10/10 15:35:45 itojun Exp $	*/
d539 1
d560 3
a562 1
#define ICMPV6CTL_MAXID		16
d581 2
d603 4
@


1.10
log
@bring in icmp rate limitation code.
make icmp6 rate limitation to latest (uses ppsratecheck only).
(sync with netbsd)
TODO: tcp SYN rate limit?
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.9 2000/08/19 09:17:36 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.22 2000/08/03 15:25:16 jinmei Exp $	*/
@


1.9
log
@- upgrade icmp6 node information query support to 06 draft.
- pedant: possible alignment issue in ALIGN > 8 arch (should be okay for now)
(sync with kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.8 2000/08/03 14:39:23 itojun Exp $	*/
d547 1
d549 1
d567 1
a567 1
	{ "errratelimit", CTLTYPE_INT }, \
@


1.8
log
@typo in #define.  ICMP6_NI_SUCESS -> SUCCESS.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.7 2000/07/06 10:11:21 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.21 2000/08/03 14:22:09 itojun Exp $	*/
d323 2
a324 1
#define NI_QTYPE_FQDN		2 /* FQDN */
@


1.7
log
@- more icmp6/ip6 stats.
- protect IPv6 ND from being hosed (due to neighbor unreachability detection
  hint) by wrong tcp traffic.  still not sure if there's real attack, but
  it is good to be cautious.
- avoid bitfield for router renumbering header decl.
- implement packet-per-sec limitation for icmp6 errors, turn interval
  limit off (it is not very useful due to unix timer resolution).
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.6 2000/06/12 17:24:26 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.18 2000/07/03 02:51:08 itojun Exp $	*/
d149 1
a149 1
#define ICMP6_NI_SUCESS		0	/* node information successful reply */
d324 2
a325 1
#define NI_QTYPE_NODEADDR	3 /* Node Addresses. XXX: spec says 2, but it may be a typo... */
@


1.6
log
@update icmp6 name lookup code to conform to 05 draft.  previous code
was 03/05 chimera.

ping6: -n by default due to too many false error report due to too long
reverse query delay.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.5 2000/03/09 21:21:12 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.17 2000/06/11 17:23:40 jinmei Exp $	*/
a378 1
#if BYTE_ORDER == BIG_ENDIAN /* net byte order */
d381 16
a396 29
	u_int8_t		rr_segnum;
	u_int8_t		rr_test : 1;
	u_int8_t		rr_reqresult : 1;
	u_int8_t		rr_forceapply : 1;
	u_int8_t		rr_specsite : 1;
	u_int8_t		rr_prevdone : 1;
	u_int8_t		rr_flags_reserved : 3;
	u_int16_t		rr_maxdelay;
	u_int32_t		rr_reserved;
};
#elif BYTE_ORDER == LITTLE_ENDIAN
struct icmp6_router_renum {	/* router renumbering header */
	struct icmp6_hdr	rr_hdr;
	u_int8_t		rr_segnum;
	u_int8_t		rr_flags_reserved : 3;
	u_int8_t		rr_prevdone : 1;
	u_int8_t		rr_specsite : 1;
	u_int8_t		rr_forceapply : 1;
	u_int8_t		rr_reqresult : 1;
	u_int8_t		rr_test : 1;
	u_int16_t		rr_maxdelay;
	u_int32_t		rr_reserved;
};
#endif /* BYTE_ORDER */

#define rr_type			rr_hdr.icmp6_type
#define rr_code			rr_hdr.icmp6_code
#define rr_cksum		rr_hdr.icmp6_cksum
#define rr_seqnum 		rr_hdr.icmp6_data32[0]
d406 1
a406 1
	struct in6_addr	rpm_prefix;
a413 1
#if BYTE_ORDER == BIG_ENDIAN /* net byte order */
d417 2
a418 6
	u_int8_t	rpu_mask_onlink : 1;
	u_int8_t	rpu_mask_autonomous : 1;
	u_int8_t	rpu_mask_reserved : 6;
	u_int8_t	rpu_onlink : 1;
	u_int8_t	rpu_autonomous : 1;
	u_int8_t	rpu_raflags_reserved : 6;
d421 2
a422 5
	u_int32_t	rpu_decr_vltime : 1;
	u_int32_t	rpu_decr_pltime : 1;
	u_int32_t	rpu_flags_reserved : 6;
	u_int32_t	rpu_reserved : 24;
	struct in6_addr rpu_prefix;
d424 6
d431 3
a433 18
struct rr_pco_use {		/* use prefix part */
	u_int8_t	rpu_uselen;
	u_int8_t	rpu_keeplen;
	u_int8_t	rpu_mask_reserved : 6;
	u_int8_t	rpu_mask_autonomous : 1;
	u_int8_t	rpu_mask_onlink : 1;
	u_int8_t	rpu_raflags_reserved : 6;
	u_int8_t	rpu_autonomous : 1;
	u_int8_t	rpu_onlink : 1;
	u_int32_t	rpu_vltime;
	u_int32_t	rpu_pltime;
	u_int32_t	rpu_flags_reserved : 6;
	u_int32_t	rpu_decr_pltime : 1;
	u_int32_t	rpu_decr_vltime : 1;
	u_int32_t	rpu_reserved : 24;
	struct in6_addr rpu_prefix;
};
#endif /* BYTE_ORDER */
a434 1
#if BYTE_ORDER == BIG_ENDIAN /* net byte order */
d436 1
a436 4
	u_int8_t	rrr_reserved;
	u_int8_t	rrr_flags_reserved : 6;
	u_int8_t	rrr_outofbound : 1;
	u_int8_t	rrr_forbidden : 1;
d440 1
a440 1
	struct in6_addr rrr_prefix;
d442 3
d446 3
a448 11
struct rr_result {		/* router renumbering result message */
	u_int8_t	rrr_reserved;
	u_int8_t	rrr_forbidden : 1;
	u_int8_t	rrr_outofbound : 1;
	u_int8_t	rrr_flags_reserved : 6;
	u_int8_t	rrr_ordinal;
	u_int8_t	rrr_matchedlen;
	u_int32_t	rrr_ifid;
	struct in6_addr rrr_prefix;
};
#endif /* BYTE_ORDER */
d488 16
d518 19
d553 3
a555 1
#define ICMPV6CTL_MAXID		14
d572 2
@


1.5
log
@change struct icmp6_filter member name: s/icmp6_filter/icmp6_filt/,
to be compliant with RFC2292.
From: Francis Dupont
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.4 2000/02/28 14:05:59 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.8 2000/02/28 10:59:30 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d145 4
d298 1
a298 1
	u_int32_t	icmp6_nl_ttl;
a319 1

@


1.4
log
@upgrade node information query protocol support from 04 draft to
draft-ietf-ipngwg-icmp-name-lookups-05.txt.

NOTE: 04 and 05 has no interoperability, in terms of "ping6 -a".
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.3 2000/02/28 11:55:20 itojun Exp $	*/
d492 1
a492 1
	u_int32_t icmp6_filter[8];
d513 1
a513 1
	(((filterp)->icmp6_filter[(type) >> 5]) |= (1 << ((type) & 31)))
d515 1
a515 1
	(((filterp)->icmp6_filter[(type) >> 5]) &= ~(1 << ((type) & 31)))
d517 1
a517 1
	((((filterp)->icmp6_filter[(type) >> 5]) & (1 << ((type) & 31))) != 0)
d519 1
a519 1
	((((filterp)->icmp6_filter[(type) >> 5]) & (1 << ((type) & 31))) == 0)
@


1.3
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 2
a2 1
/*	$OpenBSD: icmp6.h,v 1.2 2000/02/07 05:45:55 itojun Exp $	*/
d326 7
a339 2
#define NI_SUPTYPE_FLAG_COMPRESS	0x0100
#define NI_FQDN_FLAG_VALIDTTL		0x0100
d346 19
@


1.2
log
@for more strict rfc2292 compliance swap netinet{,6}/{ip6,icmp6}.h.
netinet6/{ip6,icmp6}.h will be nuked afterwards.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.5 2000/01/19 16:02:18 itojun Exp $	*/
d472 1
a472 1
    {								\
d477 1
a477 1
    }
d528 1
a528 1
#define ICMPV6CTL_ND6_PROXYALL	12
d545 1
a545 1
	{ "nd6_proxyall", CTLTYPE_INT }, \
a546 18
}

#define ICMPV6CTL_VARS { \
	0, \
	0, \
	&icmp6_rediraccept,   \
	&icmp6_redirtimeout,  \
	0, \
	0, \
	&icmp6errratelim, \
	&nd6_prune,	\
	0, \
	&nd6_delay,	\
	&nd6_umaxtries, \
	&nd6_mmaxtries,	\
	&nd6_useloopback, \
	&nd6_proxyall, \
	&icmp6_nodeinfo, \
@


1.2.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: icmp6.h,v 1.8 2000/02/28 10:59:30 itojun Exp $	*/
a324 7
#elif BYTE_ORDER == LITTLE_ENDIAN
#define NI_SUPTYPE_FLAG_COMPRESS	0x0100
#define NI_FQDN_FLAG_VALIDTTL		0x0100
#endif

#ifdef NAME_LOOKUPS_04
#if BYTE_ORDER == BIG_ENDIAN
d332 2
a340 19
#else  /* draft-ietf-ipngwg-icmp-name-lookups-05 (and later?) */
#if BYTE_ORDER == BIG_ENDIAN
#define NI_NODEADDR_FLAG_TRUNCATE	0x1
#define NI_NODEADDR_FLAG_ALL		0x2
#define NI_NODEADDR_FLAG_COMPAT		0x4
#define NI_NODEADDR_FLAG_LINKLOCAL	0x8
#define NI_NODEADDR_FLAG_SITELOCAL	0x10
#define NI_NODEADDR_FLAG_GLOBAL		0x20
#define NI_NODEADDR_FLAG_ANYCAST	0x40 /* just experimental. not in spec */
#elif BYTE_ORDER == LITTLE_ENDIAN
#define NI_NODEADDR_FLAG_TRUNCATE	0x0100
#define NI_NODEADDR_FLAG_ALL		0x0200
#define NI_NODEADDR_FLAG_COMPAT		0x0400
#define NI_NODEADDR_FLAG_LINKLOCAL	0x0800
#define NI_NODEADDR_FLAG_SITELOCAL	0x1000
#define NI_NODEADDR_FLAG_GLOBAL		0x2000
#define NI_NODEADDR_FLAG_ANYCAST	0x4000 /* just experimental. not in spec */
#endif
#endif
d472 1
a472 1
do {								\
d477 1
a477 1
} while (0)
d528 1
a528 1
/*#define ICMPV6CTL_ND6_PROXYALL	12	obsoleted, do not reuse here */
d545 1
a545 1
	{ 0, 0 }, \
d547 18
@


1.2.2.2
log
@Sync with -current
@
text
@d492 1
a492 1
	u_int32_t icmp6_filt[8];
d513 1
a513 1
	(((filterp)->icmp6_filt[(type) >> 5]) |= (1 << ((type) & 31)))
d515 1
a515 1
	(((filterp)->icmp6_filt[(type) >> 5]) &= ~(1 << ((type) & 31)))
d517 1
a517 1
	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) != 0)
d519 1
a519 1
	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) == 0)
@


1.2.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.h,v 1.15 2001/02/07 11:43:52 itojun Exp $	*/
/*	$KAME: icmp6.h,v 1.39 2001/02/06 03:48:06 itojun Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
d145 1
a145 5
#define ICMP6_NI_SUBJ_IPV6	0	/* Query Subject is an IPv6 address */
#define ICMP6_NI_SUBJ_FQDN	1	/* Query Subject is a Domain name */
#define ICMP6_NI_SUBJ_IPV4	2	/* Query Subject is an IPv4 address */

#define ICMP6_NI_SUCCESS	0	/* node information successful reply */
d294 1
a294 1
	int32_t		icmp6_nl_ttl;
d317 1
d320 2
a321 4
#define NI_QTYPE_FQDN		2 /* FQDN (draft 04) */
#define NI_QTYPE_DNSNAME	2 /* DNS Name */
#define NI_QTYPE_NODEADDR	3 /* Node Addresses */
#define NI_QTYPE_IPV4ADDR	4 /* IPv4 Addresses */
d376 14
d392 16
a407 16
	u_int8_t	rr_segnum;
	u_int8_t	rr_flags;
	u_int16_t	rr_maxdelay;
	u_int32_t	rr_reserved;
};

#define ICMP6_RR_FLAGS_TEST		0x80
#define ICMP6_RR_FLAGS_REQRESULT	0x40
#define ICMP6_RR_FLAGS_FORCEAPPLY	0x20
#define ICMP6_RR_FLAGS_SPECSITE		0x10
#define ICMP6_RR_FLAGS_PREVDONE		0x08

#define rr_type		rr_hdr.icmp6_type
#define rr_code		rr_hdr.icmp6_code
#define rr_cksum	rr_hdr.icmp6_cksum
#define rr_seqnum 	rr_hdr.icmp6_data32[0]
d417 1
a417 1
	struct	in6_addr	rpm_prefix;
d425 1
d429 6
a434 2
	u_int8_t	rpu_ramask;
	u_int8_t	rpu_raflags;
d437 5
a441 2
	u_int32_t	rpu_flags;
	struct	in6_addr rpu_prefix;
a442 6
#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK	0x80
#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO	0x40

#if BYTE_ORDER == BIG_ENDIAN
#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME     0x80000000
#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME     0x40000000
d444 18
a461 3
#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME     0x80
#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME     0x40
#endif
d463 1
d465 4
a468 1
	u_int16_t	rrr_flags;
d472 1
a472 1
	struct	in6_addr rrr_prefix;
a473 3
#if BYTE_ORDER == BIG_ENDIAN
#define ICMP6_RR_RESULT_FLAGS_OOB		0x0002
#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN		0x0001
d475 11
a485 3
#define ICMP6_RR_RESULT_FLAGS_OOB		0x0200
#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN		0x0100
#endif
a524 16
struct icmp6errstat {
	u_quad_t icp6errs_dst_unreach_noroute;
	u_quad_t icp6errs_dst_unreach_admin;
	u_quad_t icp6errs_dst_unreach_beyondscope;
	u_quad_t icp6errs_dst_unreach_addr;
	u_quad_t icp6errs_dst_unreach_noport;
	u_quad_t icp6errs_packet_too_big;
	u_quad_t icp6errs_time_exceed_transit;
	u_quad_t icp6errs_time_exceed_reassembly;
	u_quad_t icp6errs_paramprob_header;
	u_quad_t icp6errs_paramprob_nextheader;
	u_quad_t icp6errs_paramprob_option;
	u_quad_t icp6errs_redirect; /* we regard redirect as an error here */
	u_quad_t icp6errs_unknown;
};

a538 26
	struct icmp6errstat icp6s_outerrhist;
#define icp6s_odst_unreach_noroute \
	icp6s_outerrhist.icp6errs_dst_unreach_noroute
#define icp6s_odst_unreach_admin icp6s_outerrhist.icp6errs_dst_unreach_admin
#define icp6s_odst_unreach_beyondscope \
	icp6s_outerrhist.icp6errs_dst_unreach_beyondscope
#define icp6s_odst_unreach_addr icp6s_outerrhist.icp6errs_dst_unreach_addr
#define icp6s_odst_unreach_noport icp6s_outerrhist.icp6errs_dst_unreach_noport
#define icp6s_opacket_too_big icp6s_outerrhist.icp6errs_packet_too_big
#define icp6s_otime_exceed_transit \
	icp6s_outerrhist.icp6errs_time_exceed_transit
#define icp6s_otime_exceed_reassembly \
	icp6s_outerrhist.icp6errs_time_exceed_reassembly
#define icp6s_oparamprob_header icp6s_outerrhist.icp6errs_paramprob_header
#define icp6s_oparamprob_nextheader \
	icp6s_outerrhist.icp6errs_paramprob_nextheader
#define icp6s_oparamprob_option icp6s_outerrhist.icp6errs_paramprob_option
#define icp6s_oredirect icp6s_outerrhist.icp6errs_redirect
#define icp6s_ounknown icp6s_outerrhist.icp6errs_unknown
	u_quad_t icp6s_pmtuchg;		/* path MTU changes */
	u_quad_t icp6s_nd_badopt;	/* bad ND options */
	u_quad_t icp6s_badns;		/* bad neighbor solicitation */
	u_quad_t icp6s_badna;		/* bad neighbor advertisement */
	u_quad_t icp6s_badrs;		/* bad router advertisement */
	u_quad_t icp6s_badra;		/* bad router advertisement */
	u_quad_t icp6s_badredirect;	/* bad redirect message */
a546 1
#if 0	/*obsoleted*/
a547 1
#endif
d555 1
a555 6
#define ICMPV6CTL_ERRPPSLIMIT	14	/* ICMPv6 error pps limitation */
#define ICMPV6CTL_ND6_MAXNUDHINT	15
#define ICMPV6CTL_MTUDISC_HIWAT	16
#define ICMPV6CTL_MTUDISC_LOWAT	17
#define ICMPV6CTL_ND6_DEBUG	18
#define ICMPV6CTL_MAXID		19
d563 1
a563 1
	{ 0, 0 }, \
a571 5
	{ "errppslimit", CTLTYPE_INT }, \
	{ "nd6_maxnudhint", CTLTYPE_INT }, \
	{ "mtudisc_hiwat", CTLTYPE_INT }, \
	{ "mtudisc_lowat", CTLTYPE_INT }, \
	{ "nd6_debug", CTLTYPE_INT }, \
a591 4

struct	ip6ctlparam;
void	icmp6_mtudisc_update __P((struct ip6ctlparam *, int));
void	icmp6_mtudisc_callback_register __P((void (*)(struct in6_addr *)));
@


1.2.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.2.2.3 2001/05/14 22:40:06 niklas Exp $	*/
d682 2
a683 1
#endif /* _NETINET_ICMP6_H_ */
@


1.2.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 1
a83 1
} __attribute__((__packed__));
d124 2
a125 2
#define MLD6_MTRACE_RESP		200	/* mtrace response(to sender) */
#define MLD6_MTRACE			201	/* mtrace messages */
d127 1
a127 1
#define ICMP6_MAXTYPE			201
d167 1
a167 1
} __attribute__((__packed__));
d182 1
a182 1
} __attribute__((__packed__));
d194 1
a194 1
} __attribute__((__packed__));
d209 1
a209 1
} __attribute__((__packed__));
d220 1
a220 1
} __attribute__((__packed__));
d243 1
a243 1
} __attribute__((__packed__));
d254 1
a254 1
} __attribute__((__packed__));
d271 1
a271 1
} __attribute__((__packed__));
d276 1
a276 1
struct nd_opt_rd_hdr {		/* redirected header */
d282 1
a282 1
} __attribute__((__packed__));
d289 1
a289 1
} __attribute__((__packed__));
d304 1
a304 1
} __attribute__((__packed__));
d313 1
a313 1
} __attribute__((__packed__));
d376 1
a376 1
} __attribute__((__packed__));
d387 1
a387 1
} __attribute__((__packed__));
d409 1
a409 1
} __attribute__((__packed__));
d425 1
a425 1
} __attribute__((__packed__));
d443 1
a443 1
} __attribute__((__packed__));
d517 1
a517 5
	/*
	 * number of responses: this member is inherited from netinet code, but
	 * for netinet6 code, it is already available in icp6s_outhist[].
	 */
	u_quad_t icp6s_reflect;
d629 2
@


1.2.2.6
log
@Merge in -current from roughly a week ago
@
text
@d605 10
a614 10
void	icmp6_init(void);
void	icmp6_paramerror(struct mbuf *, int);
void	icmp6_error(struct mbuf *, int, int, int);
int	icmp6_input(struct mbuf **, int *, int);
void	icmp6_fasttimo(void);
void	icmp6_reflect(struct mbuf *, size_t);
void	icmp6_prepare(struct mbuf *);
void	icmp6_redirect_input(struct mbuf *, int);
void	icmp6_redirect_output(struct mbuf *, struct rtentry *);
int	icmp6_sysctl(int *, u_int, void *, size_t *, void *, size_t);
d617 2
a618 2
void	icmp6_mtudisc_update(struct ip6ctlparam *, int);
void	icmp6_mtudisc_callback_register(void (*)(struct in6_addr *));
@


1.2.2.7
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$KAME: icmp6.h,v 1.71 2002/05/27 04:18:29 itojun Exp $	*/
d509 2
a510 2
	u_quad_t icp6s_canterror;	/* no error because old was icmp */
	u_quad_t icp6s_toofreq;		/* no error because rate limitation */
d522 1
a522 1
	u_quad_t icp6s_inhist[256];
d573 1
a573 3
#define ICMPV6CTL_ND6_DRLIST	19
#define ICMPV6CTL_ND6_PRLIST	20
#define ICMPV6CTL_MAXID		21
a594 2
	{ 0, 0 }, \
	{ 0, 0 }, \
d623 5
a627 2
	if (ifp)						\
		((struct in6_ifextra *)((ifp)->if_afdata[AF_INET6]))->icmp6_ifstat->tag++; \
@


1.2.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.h,v 1.2.2.7 2003/03/28 00:06:54 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: icmp6.h,v 1.84 2003/04/23 10:26:51 itojun Exp $	*/
d79 1
a79 1
} __packed;
a96 5
#define MLD_LISTENER_QUERY		130 	/* multicast listener query */
#define MLD_LISTENER_REPORT		131	/* multicast listener report */
#define MLD_LISTENER_DONE		132	/* multicast listener done */

/* RFC2292 decls */
d98 1
d100 1
d102 1
a102 7

#ifndef _KERNEL
/* the followings are for backward compatibility to old KAME apps. */
#define MLD6_LISTENER_QUERY	MLD_LISTENER_QUERY
#define MLD6_LISTENER_REPORT	MLD_LISTENER_REPORT
#define MLD6_LISTENER_DONE	MLD_LISTENER_DONE
#endif
d120 2
a121 8
#define MLD_MTRACE_RESP			200	/* mtrace response(to sender) */
#define MLD_MTRACE			201	/* mtrace messages */

#ifndef _KERNEL
/* the followings are for backward compatibility to old KAME apps. */
#define MLD6_MTRACE_RESP	MLD_MTRACE_RESP
#define MLD6_MTRACE		MLD_MTRACE
#endif
d160 10
a169 22
struct mld_hdr {
	struct icmp6_hdr	mld_icmp6_hdr;
	struct in6_addr		mld_addr; /* multicast address */
} __packed;

/* definitions to provide backward compatibility to old KAME applications */
#ifndef _KERNEL
#define mld6_hdr	mld_hdr
#define mld6_type	mld_type
#define mld6_code	mld_code
#define mld6_cksum	mld_cksum
#define mld6_maxdelay	mld_maxdelay
#define mld6_reserved	mld_reserved
#define mld6_addr	mld_addr
#endif

/* shortcut macro definitions */
#define mld_type	mld_icmp6_hdr.icmp6_type
#define mld_code	mld_icmp6_hdr.icmp6_code
#define mld_cksum	mld_icmp6_hdr.icmp6_cksum
#define mld_maxdelay	mld_icmp6_hdr.icmp6_data16[0]
#define mld_reserved	mld_icmp6_hdr.icmp6_data16[1]
d178 1
a178 1
} __packed;
d190 1
a190 1
} __packed;
d205 1
a205 1
} __packed;
d216 1
a216 1
} __packed;
d239 1
a239 1
} __packed;
d250 1
a250 1
} __packed;
d267 1
a267 1
} __packed;
d278 1
a278 1
} __packed;
d285 1
a285 1
} __packed;
d300 1
a300 1
} __packed;
d309 1
a309 1
} __packed;
d372 1
a372 1
} __packed;
d383 1
a383 1
} __packed;
d405 1
a405 1
} __packed;
d421 1
a421 1
} __packed;
d439 1
a439 1
} __packed;
d651 1
a651 1
		 case MLD_LISTENER_QUERY: \
d654 1
a654 1
		 case MLD_LISTENER_REPORT: \
d657 1
a657 1
		 case MLD_LISTENER_DONE: \
@


1.2.2.10
log
@Merge with the trunk
@
text
@a623 24
#define ICMPV6CTL_VARS { \
	NULL, \
	NULL, \
	&icmp6_rediraccept, \
	&icmp6_redirtimeout, \
	NULL, \
	NULL, \
	&nd6_prune, \
	NULL, \
	&nd6_delay, \
	&nd6_umaxtries, \
	&nd6_mmaxtries, \
	&nd6_useloopback, \
	NULL, \
	&icmp6_nodeinfo, \
	&icmp6errppslim, \
	&nd6_maxnudhint, \
	&icmp6_mtudisc_hiwat, \
	&icmp6_mtudisc_lowat, \
	&nd6_debug, \
	NULL, \
	NULL, \
}

@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 35
d70 582
a651 1
#include <netinet6/icmp6.h>
d653 1
a653 1
#endif /* !_NETINET_ICMP6_H_ */
@

