head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.24
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.18
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.20
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.12
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.16
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.14
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.10
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.8
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.4
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.8
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.8
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.6
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.20
date	2011.04.05.15.14.59;	author blambert;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.08.12.54.58;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.27.02.19.32;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.09.09.14.12;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.26.05.12.12;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.08.05.31.13;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.16.20.30.07;	author avsm;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.11.04.42.01;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.14.17.46.23;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.06.03.28.49;	author itojun;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.07.05.23.41.34;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.09.07.03.41;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.10.15.53.08;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.12.16.41.31;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.13.01.17.13;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.24.11.37.49;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.07.05.45.55;	author itojun;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	;

1.2.2.1
date	2000.03.02.07.04.42;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.05.14.22.40.08;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.07.04.10.54.36;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove unused macro.

ok henning@@ claudio@@
@
text
@/*	$OpenBSD: ip6.h,v 1.19 2008/11/08 12:54:58 dlg Exp $	*/
/*	$KAME: ip6.h,v 1.45 2003/06/05 04:46:38 keiichi Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET_IP6_H_
#define _NETINET_IP6_H_

/*
 * Definition for internet protocol version 6.
 * RFC 2460
 */

struct ip6_hdr {
	union {
		struct ip6_hdrctl {
			u_int32_t ip6_un1_flow;	/* 20 bits of flow-ID */
			u_int16_t ip6_un1_plen;	/* payload length */
			u_int8_t  ip6_un1_nxt;	/* next header */
			u_int8_t  ip6_un1_hlim;	/* hop limit */
		} ip6_un1;
		u_int8_t ip6_un2_vfc;	/* 4 bits version, top 4 bits class */
	} ip6_ctlun;
	struct in6_addr ip6_src;	/* source address */
	struct in6_addr ip6_dst;	/* destination address */
} __packed;

#define ip6_vfc		ip6_ctlun.ip6_un2_vfc
#define ip6_flow	ip6_ctlun.ip6_un1.ip6_un1_flow
#define ip6_plen	ip6_ctlun.ip6_un1.ip6_un1_plen
#define ip6_nxt		ip6_ctlun.ip6_un1.ip6_un1_nxt
#define ip6_hlim	ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_hops	ip6_ctlun.ip6_un1.ip6_un1_hlim

#define IPV6_VERSION		0x60
#define IPV6_VERSION_MASK	0xf0

#if _BYTE_ORDER == _BIG_ENDIAN
#define IPV6_FLOWINFO_MASK	0x0fffffff	/* flow info (28 bits) */
#define IPV6_FLOWLABEL_MASK	0x000fffff	/* flow label (20 bits) */
#else
#if _BYTE_ORDER == _LITTLE_ENDIAN
#define IPV6_FLOWINFO_MASK	0xffffff0f	/* flow info (28 bits) */
#define IPV6_FLOWLABEL_MASK	0xffff0f00	/* flow label (20 bits) */
#endif /* _LITTLE_ENDIAN */
#endif
#if 1
/* ECN bits proposed by Sally Floyd */
#define IP6TOS_CE		0x01	/* congestion experienced */
#define IP6TOS_ECT		0x02	/* ECN-capable transport */
#endif

#ifdef _KERNEL
/*
 * for IPv6 pseudo header checksum
 * XXX nonstandard
 */
struct ip6_hdr_pseudo {
	struct in6_addr ip6ph_src;
	struct in6_addr ip6ph_dst;
	u_int32_t	ip6ph_len;
	u_int8_t	ip6ph_zero[3];
	u_int8_t	ip6ph_nxt;
} __packed;
#endif

/*
 * Extension Headers
 */
struct	ip6_ext {
	u_int8_t ip6e_nxt;
	u_int8_t ip6e_len;
} __packed;

/* Hop-by-Hop options header */
/* XXX should we pad it to force alignment on an 8-byte boundary? */
struct ip6_hbh {
	u_int8_t ip6h_nxt;	/* next header */
	u_int8_t ip6h_len;	/* length in units of 8 octets */
	/* followed by options */
} __packed;

/* Destination options header */
/* XXX should we pad it to force alignment on an 8-byte boundary? */
struct ip6_dest {
	u_int8_t ip6d_nxt;	/* next header */
	u_int8_t ip6d_len;	/* length in units of 8 octets */
	/* followed by options */
} __packed;

/* Option types and related macros */
#define IP6OPT_PAD1		0x00	/* 00 0 00000 */
#define IP6OPT_PADN		0x01	/* 00 0 00001 */
#define IP6OPT_JUMBO		0xC2	/* 11 0 00010 = 194 */
#define IP6OPT_NSAP_ADDR	0xC3	/* 11 0 00011 */
#define IP6OPT_TUNNEL_LIMIT	0x04	/* 00 0 00100 */
#define IP6OPT_ROUTER_ALERT	0x05	/* 00 0 00101 (RFC3542, recommended) */

#define IP6OPT_RTALERT_LEN	4
#define IP6OPT_RTALERT_MLD	0	/* Datagram contains an MLD message */
#define IP6OPT_RTALERT_RSVP	1	/* Datagram contains an RSVP message */
#define IP6OPT_RTALERT_ACTNET	2 	/* contains an Active Networks msg */
#define IP6OPT_MINLEN		2

#define IP6OPT_TYPE(o)		((o) & 0xC0)
#define IP6OPT_TYPE_SKIP	0x00
#define IP6OPT_TYPE_DISCARD	0x40
#define IP6OPT_TYPE_FORCEICMP	0x80
#define IP6OPT_TYPE_ICMP	0xC0

#define IP6OPT_MUTABLE		0x20

/* IPv6 options: common part */
struct ip6_opt {
	u_int8_t ip6o_type;
	u_int8_t ip6o_len;
} __packed;

/* Jumbo Payload Option */
struct ip6_opt_jumbo {
	u_int8_t ip6oj_type;
	u_int8_t ip6oj_len;
	u_int8_t ip6oj_jumbo_len[4];
} __packed;
#define IP6OPT_JUMBO_LEN 6

/* NSAP Address Option */
struct ip6_opt_nsap {
	u_int8_t ip6on_type;
	u_int8_t ip6on_len;
	u_int8_t ip6on_src_nsap_len;
	u_int8_t ip6on_dst_nsap_len;
	/* followed by source NSAP */
	/* followed by destination NSAP */
} __packed;

/* Tunnel Limit Option */
struct ip6_opt_tunnel {
	u_int8_t ip6ot_type;
	u_int8_t ip6ot_len;
	u_int8_t ip6ot_encap_limit;
} __packed;

/* Router Alert Option */
struct ip6_opt_router {
	u_int8_t ip6or_type;
	u_int8_t ip6or_len;
	u_int8_t ip6or_value[2];
} __packed;
/* Router alert values (in network byte order) */
#if _BYTE_ORDER == _BIG_ENDIAN
#define IP6_ALERT_MLD	0x0000
#define IP6_ALERT_RSVP	0x0001
#define IP6_ALERT_AN	0x0002
#else
#if _BYTE_ORDER == _LITTLE_ENDIAN
#define IP6_ALERT_MLD	0x0000
#define IP6_ALERT_RSVP	0x0100
#define IP6_ALERT_AN	0x0200
#endif /* _LITTLE_ENDIAN */
#endif

/* Routing header */
struct ip6_rthdr {
	u_int8_t  ip6r_nxt;	/* next header */
	u_int8_t  ip6r_len;	/* length in units of 8 octets */
	u_int8_t  ip6r_type;	/* routing type */
	u_int8_t  ip6r_segleft;	/* segments left */
	/* followed by routing type specific data */
} __packed;

/* Type 0 Routing header */
struct ip6_rthdr0 {
	u_int8_t  ip6r0_nxt;		/* next header */
	u_int8_t  ip6r0_len;		/* length in units of 8 octets */
	u_int8_t  ip6r0_type;		/* always zero */
	u_int8_t  ip6r0_segleft;	/* segments left */
	u_int32_t ip6r0_reserved;	/* reserved field */
} __packed;

/* Fragment header */
struct ip6_frag {
	u_int8_t  ip6f_nxt;		/* next header */
	u_int8_t  ip6f_reserved;	/* reserved field */
	u_int16_t ip6f_offlg;		/* offset, reserved, and flag */
	u_int32_t ip6f_ident;		/* identification */
} __packed;

#if _BYTE_ORDER == _BIG_ENDIAN
#define IP6F_OFF_MASK		0xfff8	/* mask out offset from _offlg */
#define IP6F_RESERVED_MASK	0x0006	/* reserved bits in ip6f_offlg */
#define IP6F_MORE_FRAG		0x0001	/* more-fragments flag */
#else /* _BYTE_ORDER == _LITTLE_ENDIAN */
#define IP6F_OFF_MASK		0xf8ff	/* mask out offset from _offlg */
#define IP6F_RESERVED_MASK	0x0600	/* reserved bits in ip6f_offlg */
#define IP6F_MORE_FRAG		0x0100	/* more-fragments flag */
#endif /* _BYTE_ORDER == _LITTLE_ENDIAN */

/*
 * Internet implementation parameters.
 */
#define IPV6_MAXHLIM	255	/* maximum hoplimit */
#define IPV6_DEFHLIM	64	/* default hlim */
#define IPV6_FRAGTTL	120	/* ttl for fragment packets, in slowtimo tick */
#define IPV6_HLIMDEC	1	/* subtracted when forwarding */

#define IPV6_MMTU	1280	/* minimal MTU and reassembly. 1024 + 256 */
#define IPV6_MAXPACKET	65535	/* ip6 max packet size without Jumbo payload*/

#ifdef _KERNEL
/*
 * IP6_EXTHDR_GET ensures that intermediate protocol header (from "off" to
 * "len") is located in single mbuf, on contiguous memory region.
 * The pointer to the region will be returned to pointer variable "val",
 * with type "typ".
 */
#define IP6_EXTHDR_GET(val, typ, m, off, len)				\
do {									\
	struct mbuf *t;							\
	int tmp;							\
	if ((m)->m_len >= (off) + (len))				\
		(val) = (typ)(mtod((m), caddr_t) + (off));		\
	else {								\
		t = m_pulldown((m), (off), (len), &tmp);		\
		if (t) {						\
			if (t->m_len < tmp + (len))			\
				panic("m_pulldown malfunction");	\
			(val) = (typ)(mtod(t, caddr_t) + tmp);		\
		} else {						\
			(val) = (typ)NULL;				\
			(m) = NULL;					\
		}							\
	}								\
} while (/* CONSTCOND */ 0)
#endif /* _KERNEL */
#endif /* _NETINET_IP6_H_ */
@


1.19
log
@fix macros up so they use the do { } while (/* CONSTCOND */ 0) idiom

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.17 2006/04/27 02:19:32 tedu Exp $	*/
a273 2
 * IP6_EXTHDR_GET0 does the same, except that it aligns the structure at the
 * very top of mbuf.  GET0 is likely to make memory copy than GET.
a286 18
		} else {						\
			(val) = (typ)NULL;				\
			(m) = NULL;					\
		}							\
	}								\
} while (/* CONSTCOND */ 0)

#define IP6_EXTHDR_GET0(val, typ, m, off, len)				\
do {									\
	struct mbuf *t;							\
	if ((off) == 0 && (m)->m_len >= len)				\
		(val) = (typ)mtod((m), caddr_t);			\
	else {								\
		t = m_pulldown((m), (off), (len), NULL);		\
		if (t) {						\
			if (t->m_len < (len))				\
				panic("m_pulldown malfunction");	\
			(val) = (typ)mtod(t, caddr_t);			\
@


1.18
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d277 1
a277 1
#define IP6_EXTHDR_GET(val, typ, m, off, len) \
d294 1
a294 1
} while (0)
d296 1
a296 1
#define IP6_EXTHDR_GET0(val, typ, m, off, len) \
d312 1
a312 1
} while (0)
@


1.17
log
@use underscore variants of _BYTE_ORDER macros which are always defined
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.16 2004/07/09 09:14:12 itojun Exp $	*/
d155 1
a155 2
#define IP6OPT_RTALERT		0x05	/* 00 0 00101 (KAME definition) */
#define IP6OPT_ROUTER_ALERT	0x05	/* (2292bis def, recommended) */
a275 2
 *
 * XXX we're now testing this, needs m_pulldown()
@


1.16
log
@typo.  Bruno Rohee
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.15 2004/04/26 05:12:12 itojun Exp $	*/
d96 1
a96 1
#if BYTE_ORDER == BIG_ENDIAN
d100 1
a100 1
#if BYTE_ORDER == LITTLE_ENDIAN
d103 1
a103 1
#endif /* LITTLE_ENDIAN */
d210 1
a210 1
#if BYTE_ORDER == BIG_ENDIAN
d215 1
a215 1
#if BYTE_ORDER == LITTLE_ENDIAN
d219 1
a219 1
#endif /* LITTLE_ENDIAN */
d248 1
a248 1
#if BYTE_ORDER == BIG_ENDIAN
d252 1
a252 1
#else /* BYTE_ORDER == LITTLE_ENDIAN */
d256 1
a256 1
#endif /* BYTE_ORDER == LITTLE_ENDIAN */
@


1.15
log
@hide nonstandard struct from userland
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.14 2004/01/08 05:31:13 itojun Exp $	*/
d261 1
a261 1
#define IPV6_MAXHLIM	255	/* maximun hoplimit */
d264 1
a264 1
#define IPV6_HLIMDEC	1	/* subtracted when forwaeding */
@


1.14
log
@struct for IPv6 pseudo header checksum - nonstandard.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.13 2003/11/16 20:30:07 avsm Exp $	*/
d111 1
d123 1
@


1.13
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.12 2003/06/11 04:42:01 itojun Exp $	*/
d112 12
a125 1

@


1.12
log
@- sync up MLD declaration with RFC3542 (s/MLD6/MLD/)
- routing header declaration with RFC3542
(note: sizeof(ip6_rthdr0) has changed!)
also, sync up with RFC2460 routing header definition (no "strict" source
routing mode any more)

part of advanced API update (RFC2292 -> 3542).

markus, todd, millert, henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.11 2003/06/02 23:28:14 millert Exp $	*/
d84 1
a84 1
} __attribute__((__packed__));
d118 1
a118 1
} __attribute__((__packed__));
d126 1
a126 1
} __attribute__((__packed__));
d134 1
a134 1
} __attribute__((__packed__));
d163 1
a163 1
} __attribute__((__packed__));
d170 1
a170 1
} __attribute__((__packed__));
d181 1
a181 1
} __attribute__((__packed__));
d188 1
a188 1
} __attribute__((__packed__));
d195 1
a195 1
} __attribute__((__packed__));
d216 1
a216 1
} __attribute__((__packed__));
d225 1
a225 1
} __attribute__((__packed__));
d233 1
a233 1
} __attribute__((__packed__));
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6.h,v 1.10 2003/05/14 17:46:23 itojun Exp $	*/
/*	$KAME: ip6.h,v 1.14 2000/10/09 01:04:09 itojun Exp $	*/
d140 5
a144 2
#define IP6OPT_JUMBO_LEN	6
#define IP6OPT_RTALERT		0x05	/* 00 0 00101 */
d159 50
d224 1
a224 3
	u_int8_t  ip6r0_reserved;	/* reserved field */
	u_int8_t  ip6r0_slmap[3];	/* strict/loose bit map */
	struct in6_addr  ip6r0_addr[1];	/* up to 23 addresses */
@


1.10
log
@nuke !PULLDOWN_TEST case.  (leftover from yesterday)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.9 2001/12/06 03:28:49 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@put __attribute__ to header decls to avoid align strangeness.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.8 2001/07/05 23:41:34 itojun Exp $	*/
a209 35
/*
 * IP6_EXTHDR_CHECK ensures that region between the IP6 header and the
 * target header (including IPv6 itself, extension headers and
 * TCP/UDP/ICMP6 headers) are continuous. KAME requires drivers
 * to store incoming data into one internal mbuf or one or more external
 * mbufs(never into two or more internal mbufs). Thus, the third case is
 * supposed to never be matched but is prepared just in case.
 */

#define IP6_EXTHDR_CHECK(m, off, hlen, ret)				\
do {									\
    if ((m)->m_next != NULL) {						\
	if ((m)->m_flags & M_EXT) {					\
		if ((m)->m_len < (off) + (hlen)) {			\
			ip6stat.ip6s_exthdrtoolong++;			\
			m_freem(m);					\
			return ret;					\
		}							\
	} else {							\
		if ((m)->m_len < (off) + (hlen)) {			\
			ip6stat.ip6s_exthdrtoolong++;			\
			m_freem(m);					\
			return ret;					\
		}							\
	}								\
    } else {								\
	if ((m)->m_len < (off) + (hlen)) {				\
		ip6stat.ip6s_tooshort++;				\
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_truncated);	\
		m_freem(m);						\
		return ret;						\
	}								\
    }									\
} while (0)

@


1.9.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d210 35
@


1.8
log
@IP6_EXTHDR_GET0 did not check m->m_len (noone was using this macro).
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.7 2001/06/09 07:03:41 angelos Exp $	*/
d88 1
a88 1
};
d122 1
a122 1
};
d130 1
a130 1
};
d138 1
a138 1
};
d167 1
a167 1
};
d178 1
a178 1
};
d186 1
a186 1
};
d222 1
a222 6
	if (((m)->m_flags & M_LOOP) &&					\
	    ((m)->m_len < (off) + (hlen)) &&				\
	    (((m) = m_pullup((m), (off) + (hlen))) == NULL)) {		\
		ip6stat.ip6s_exthdrtoolong++;				\
		return ret;						\
	} else if ((m)->m_flags & M_EXT) {				\
d235 1
a235 2
    }									\
    else {								\
@


1.7
log
@Inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.6 2000/10/10 15:53:08 itojun Exp $	*/
d283 2
a284 2
	if ((off) == 0)							\
		(val) = (typ)mtod(m, caddr_t);				\
@


1.6
log
@little bit of sync with kame ($KAME, s/u_char/u_int8_t/)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.5 2000/07/12 16:41:31 itojun Exp $	*/
d297 2
a298 3
#endif /*_KERNEL*/

#endif /* not _NETINET_IP6_H_ */
@


1.5
log
@remove m_pulldown statistics, which is highly experimental
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6.h,v 1.4 2000/06/13 01:17:13 itojun Exp $	*/
/*	$KAME: ip6.h,v 1.7 2000/03/25 07:23:36 sumikawa Exp $	*/
d120 2
a121 2
	u_char	ip6e_nxt;
	u_char	ip6e_len;
@


1.4
log
@declare IP6_EXTHDR_GET{,0}.  sorry i forgot to commit this one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.3 2000/02/24 11:37:49 itojun Exp $	*/
a264 1
	ip6stat.ip6s_exthdrget++;					\
a282 1
	ip6stat.ip6s_exthdrget0++;					\
@


1.3
log
@hide IP6_EXTHDR_CHECK from the userland.
@
text
@d1 2
a2 1
/*	$OpenBSD: ip6.h,v 1.2 2000/02/07 05:45:55 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d84 1
a84 1
		u_int8_t ip6_un2_vfc;	/* 4 bits version, 4 bits class */
d249 49
@


1.2
log
@for more strict rfc2292 compliance swap netinet{,6}/{ip6,icmp6}.h.
netinet6/{ip6,icmp6}.h will be nuked afterwards.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.2 2000/01/03 12:34:23 angelos Exp $	*/
d208 1
d249 1
@


1.2.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a207 1
#ifdef _KERNEL
a247 1
#endif /*_KERNEL*/
@


1.2.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: ip6.h,v 1.6 2000/10/10 15:53:08 itojun Exp $	*/
/*	$KAME: ip6.h,v 1.14 2000/10/09 01:04:09 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d83 1
a83 1
		u_int8_t ip6_un2_vfc;	/* 4 bits version, top 4 bits class */
d119 2
a120 2
	u_int8_t ip6e_nxt;
	u_int8_t ip6e_len;
a247 47
} while (0)

/*
 * IP6_EXTHDR_GET ensures that intermediate protocol header (from "off" to
 * "len") is located in single mbuf, on contiguous memory region.
 * The pointer to the region will be returned to pointer variable "val",
 * with type "typ".
 * IP6_EXTHDR_GET0 does the same, except that it aligns the structure at the
 * very top of mbuf.  GET0 is likely to make memory copy than GET.
 *
 * XXX we're now testing this, needs m_pulldown()
 */
#define IP6_EXTHDR_GET(val, typ, m, off, len) \
do {									\
	struct mbuf *t;							\
	int tmp;							\
	if ((m)->m_len >= (off) + (len))				\
		(val) = (typ)(mtod((m), caddr_t) + (off));		\
	else {								\
		t = m_pulldown((m), (off), (len), &tmp);		\
		if (t) {						\
			if (t->m_len < tmp + (len))			\
				panic("m_pulldown malfunction");	\
			(val) = (typ)(mtod(t, caddr_t) + tmp);		\
		} else {						\
			(val) = (typ)NULL;				\
			(m) = NULL;					\
		}							\
	}								\
} while (0)

#define IP6_EXTHDR_GET0(val, typ, m, off, len) \
do {									\
	struct mbuf *t;							\
	if ((off) == 0)							\
		(val) = (typ)mtod(m, caddr_t);				\
	else {								\
		t = m_pulldown((m), (off), (len), NULL);		\
		if (t) {						\
			if (t->m_len < (len))				\
				panic("m_pulldown malfunction");	\
			(val) = (typ)mtod(t, caddr_t);			\
		} else {						\
			(val) = (typ)NULL;				\
			(m) = NULL;					\
		}							\
	}								\
@


1.2.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.2.2.2 2001/05/14 22:40:08 niklas Exp $	*/
d297 3
a299 2
#endif /* _KERNEL */
#endif /* _NETINET_IP6_H_ */
@


1.2.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.2.2.3 2001/07/04 10:54:36 niklas Exp $	*/
d283 2
a284 2
	if ((off) == 0 && (m)->m_len >= len)				\
		(val) = (typ)mtod((m), caddr_t);			\
@


1.2.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
a88 1
} __attribute__((__packed__));
d122 1
a122 1
} __attribute__((__packed__));
d130 1
a130 1
} __attribute__((__packed__));
d138 1
a138 1
} __attribute__((__packed__));
d167 1
a167 1
} __attribute__((__packed__));
d178 1
a178 1
} __attribute__((__packed__));
d186 1
a186 1
} __attribute__((__packed__));
d222 6
a227 1
	if ((m)->m_flags & M_EXT) {					\
d240 2
a241 1
    } else {								\
@


1.2.2.6
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d211 35
@


1.2.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6.h,v 1.2.2.6 2003/05/16 00:29:44 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: ip6.h,v 1.45 2003/06/05 04:46:38 keiichi Exp $	*/
d84 1
a84 1
} __packed;
d112 1
a112 2
 * for IPv6 pseudo header checksum
 * XXX nonstandard
a113 7
struct ip6_hdr_pseudo {
	struct in6_addr ip6ph_src;
	struct in6_addr ip6ph_dst;
	u_int32_t	ip6ph_len;
	u_int8_t	ip6ph_zero[3];
	u_int8_t	ip6ph_nxt;
} __packed;
a114 3
/*
 * Extension Headers
 */
d118 1
a118 1
} __packed;
d126 1
a126 1
} __packed;
d134 1
a134 1
} __packed;
d140 2
a141 5
#define IP6OPT_NSAP_ADDR	0xC3	/* 11 0 00011 */
#define IP6OPT_TUNNEL_LIMIT	0x04	/* 00 0 00100 */
#define IP6OPT_RTALERT		0x05	/* 00 0 00101 (KAME definition) */
#define IP6OPT_ROUTER_ALERT	0x05	/* (2292bis def, recommended) */

a155 50
/* IPv6 options: common part */
struct ip6_opt {
	u_int8_t ip6o_type;
	u_int8_t ip6o_len;
} __packed;

/* Jumbo Payload Option */
struct ip6_opt_jumbo {
	u_int8_t ip6oj_type;
	u_int8_t ip6oj_len;
	u_int8_t ip6oj_jumbo_len[4];
} __packed;
#define IP6OPT_JUMBO_LEN 6

/* NSAP Address Option */
struct ip6_opt_nsap {
	u_int8_t ip6on_type;
	u_int8_t ip6on_len;
	u_int8_t ip6on_src_nsap_len;
	u_int8_t ip6on_dst_nsap_len;
	/* followed by source NSAP */
	/* followed by destination NSAP */
} __packed;

/* Tunnel Limit Option */
struct ip6_opt_tunnel {
	u_int8_t ip6ot_type;
	u_int8_t ip6ot_len;
	u_int8_t ip6ot_encap_limit;
} __packed;

/* Router Alert Option */
struct ip6_opt_router {
	u_int8_t ip6or_type;
	u_int8_t ip6or_len;
	u_int8_t ip6or_value[2];
} __packed;
/* Router alert values (in network byte order) */
#if BYTE_ORDER == BIG_ENDIAN
#define IP6_ALERT_MLD	0x0000
#define IP6_ALERT_RSVP	0x0001
#define IP6_ALERT_AN	0x0002
#else
#if BYTE_ORDER == LITTLE_ENDIAN
#define IP6_ALERT_MLD	0x0000
#define IP6_ALERT_RSVP	0x0100
#define IP6_ALERT_AN	0x0200
#endif /* LITTLE_ENDIAN */
#endif

d163 1
a163 1
} __packed;
d171 4
a174 2
	u_int32_t ip6r0_reserved;	/* reserved field */
} __packed;
d182 1
a182 1
} __packed;
@


1.2.2.9
log
@Merge with the trunk
@
text
@a110 1
#ifdef _KERNEL
a121 1
#endif
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 247
a249 1
#include <netinet6/ip6.h>
@

