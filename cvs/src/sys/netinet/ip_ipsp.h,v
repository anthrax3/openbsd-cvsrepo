head	1.178;
access;
symbols
	OPENBSD_6_1:1.178.0.4
	OPENBSD_6_1_BASE:1.178
	OPENBSD_6_0:1.173.0.6
	OPENBSD_6_0_BASE:1.173
	OPENBSD_5_9:1.173.0.2
	OPENBSD_5_9_BASE:1.173
	OPENBSD_5_8:1.171.0.4
	OPENBSD_5_8_BASE:1.171
	OPENBSD_5_7:1.160.0.2
	OPENBSD_5_7_BASE:1.160
	OPENBSD_5_6:1.156.0.6
	OPENBSD_5_6_BASE:1.156
	OPENBSD_5_5:1.156.0.4
	OPENBSD_5_5_BASE:1.156
	OPENBSD_5_4:1.155.0.2
	OPENBSD_5_4_BASE:1.155
	OPENBSD_5_3:1.153.0.2
	OPENBSD_5_3_BASE:1.153
	OPENBSD_5_2:1.148.0.2
	OPENBSD_5_2_BASE:1.148
	OPENBSD_5_1_BASE:1.146
	OPENBSD_5_1:1.146.0.6
	OPENBSD_5_0:1.146.0.4
	OPENBSD_5_0_BASE:1.146
	OPENBSD_4_9:1.146.0.2
	OPENBSD_4_9_BASE:1.146
	OPENBSD_4_8:1.144.0.2
	OPENBSD_4_8_BASE:1.144
	OPENBSD_4_7:1.140.0.2
	OPENBSD_4_7_BASE:1.140
	OPENBSD_4_6:1.138.0.4
	OPENBSD_4_6_BASE:1.138
	OPENBSD_4_5:1.137.0.2
	OPENBSD_4_5_BASE:1.137
	OPENBSD_4_4:1.135.0.8
	OPENBSD_4_4_BASE:1.135
	OPENBSD_4_3:1.135.0.6
	OPENBSD_4_3_BASE:1.135
	OPENBSD_4_2:1.135.0.4
	OPENBSD_4_2_BASE:1.135
	OPENBSD_4_1:1.135.0.2
	OPENBSD_4_1_BASE:1.135
	OPENBSD_4_0:1.134.0.2
	OPENBSD_4_0_BASE:1.134
	OPENBSD_3_9:1.132.0.2
	OPENBSD_3_9_BASE:1.132
	OPENBSD_3_8:1.130.0.2
	OPENBSD_3_8_BASE:1.130
	OPENBSD_3_7:1.128.0.2
	OPENBSD_3_7_BASE:1.128
	OPENBSD_3_6:1.127.0.2
	OPENBSD_3_6_BASE:1.127
	SMP_SYNC_A:1.127
	SMP_SYNC_B:1.127
	OPENBSD_3_5:1.126.0.2
	OPENBSD_3_5_BASE:1.126
	OPENBSD_3_4:1.123.0.2
	OPENBSD_3_4_BASE:1.123
	UBC_SYNC_A:1.122
	OPENBSD_3_3:1.121.0.4
	OPENBSD_3_3_BASE:1.121
	OPENBSD_3_2:1.121.0.2
	OPENBSD_3_2_BASE:1.121
	OPENBSD_3_1:1.119.0.2
	OPENBSD_3_1_BASE:1.119
	UBC_SYNC_B:1.121
	UBC:1.118.0.4
	UBC_BASE:1.118
	OPENBSD_3_0:1.118.0.2
	OPENBSD_3_0_BASE:1.118
	OPENBSD_2_9_BASE:1.83
	OPENBSD_2_9:1.83.0.2
	OPENBSD_2_8:1.74.0.2
	OPENBSD_2_8_BASE:1.74
	OPENBSD_2_7:1.64.0.2
	OPENBSD_2_7_BASE:1.64
	SMP:1.60.0.2
	SMP_BASE:1.60
	kame_19991208:1.49
	OPENBSD_2_6:1.42.0.2
	OPENBSD_2_6_BASE:1.42
	OPENBSD_2_5:1.29.0.2
	OPENBSD_2_5_BASE:1.29
	OPENBSD_2_4:1.19.0.2
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.178
date	2017.02.07.22.28.37;	author bluhm;	state Exp;
branches;
next	1.177;
commitid	M4FFpRkmaBUO6y38;

1.177
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.176;
commitid	3e3CkrbYekyVOcxy;

1.176
date	2017.01.26.13.03.47;	author bluhm;	state Exp;
branches;
next	1.175;
commitid	wBlwxPiTlfo8m7xr;

1.175
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.174;
commitid	pVtptbHA3yk4jSpN;

1.174
date	2016.09.15.03.37.09;	author dlg;	state Exp;
branches;
next	1.173;
commitid	7p87LlYGjhDvSGxy;

1.173
date	2015.12.03.13.12.20;	author tedu;	state Exp;
branches;
next	1.172;
commitid	0RMZoVcTJQM3BgiV;

1.172
date	2015.08.25.11.50.14;	author deraadt;	state Exp;
branches;
next	1.171;
commitid	70jv2EMX3banpFOK;

1.171
date	2015.07.17.18.31.08;	author blambert;	state Exp;
branches;
next	1.170;
commitid	WEUQfMsVq6mbe3cF;

1.170
date	2015.05.23.12.38.53;	author markus;	state Exp;
branches;
next	1.169;
commitid	Mgx7ewWJ5ueyVCxt;

1.169
date	2015.04.17.11.04.01;	author mikeb;	state Exp;
branches;
next	1.168;
commitid	6glXvFR7NxzCcdRd;

1.168
date	2015.04.17.10.04.37;	author mikeb;	state Exp;
branches;
next	1.167;
commitid	KP3L4W0chjmfJmS7;

1.167
date	2015.04.16.19.44.01;	author markus;	state Exp;
branches;
next	1.166;
commitid	HTJr7z2fx2Mxcnu5;

1.166
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.165;
commitid	2c41FFL8044mZVko;

1.165
date	2015.04.14.14.20.01;	author mikeb;	state Exp;
branches;
next	1.164;
commitid	70u0dWUlToMcLCnj;

1.164
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.163;
commitid	bQi1IVHgugweH5gs;

1.163
date	2015.04.13.16.48.01;	author mikeb;	state Exp;
branches;
next	1.162;
commitid	oA7CWTJPEeh3MwNg;

1.162
date	2015.04.13.16.45.52;	author mikeb;	state Exp;
branches;
next	1.161;
commitid	3C62OTk3mwJg0NNx;

1.161
date	2015.03.26.12.21.37;	author mikeb;	state Exp;
branches;
next	1.160;
commitid	GUv4gLlXi8Tx36WA;

1.160
date	2015.01.19.18.36.51;	author deraadt;	state Exp;
branches;
next	1.159;
commitid	wSfPhuhGyTngya54;

1.159
date	2015.01.19.16.49.05;	author deraadt;	state Exp;
branches;
next	1.158;
commitid	V2o55D2oGJk5KNhj;

1.158
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.157;
commitid	PYnSnAqgemmk34E3;

1.157
date	2014.11.25.13.10.03;	author mpi;	state Exp;
branches;
next	1.156;
commitid	NGBbDDWXFXkKytPH;

1.156
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.155;

1.155
date	2013.07.04.09.48.49;	author mpi;	state Exp;
branches;
next	1.154;

1.154
date	2013.04.11.12.06.25;	author mpi;	state Exp;
branches;
next	1.153;

1.153
date	2013.02.14.16.22.34;	author mikeb;	state Exp;
branches;
next	1.152;

1.152
date	2012.10.18.10.49.48;	author markus;	state Exp;
branches;
next	1.151;

1.151
date	2012.10.08.17.41.55;	author camield;	state Exp;
branches;
next	1.150;

1.150
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.149;

1.149
date	2012.09.18.09.24.45;	author markus;	state Exp;
branches;
next	1.148;

1.148
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.147;

1.147
date	2012.06.29.14.48.04;	author mikeb;	state Exp;
branches;
next	1.146;

1.146
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.145;

1.145
date	2010.09.23.16.34.09;	author mikeb;	state Exp;
branches;
next	1.144;

1.144
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.143;

1.143
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.142;

1.142
date	2010.05.11.09.36.07;	author claudio;	state Exp;
branches;
next	1.141;

1.141
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.140;

1.140
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches;
next	1.139;

1.139
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.138;

1.138
date	2009.06.02.21.28.36;	author blambert;	state Exp;
branches;
next	1.137;

1.137
date	2009.02.16.00.31.25;	author dlg;	state Exp;
branches;
next	1.136;

1.136
date	2008.11.08.12.54.58;	author dlg;	state Exp;
branches;
next	1.135;

1.135
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.134;

1.134
date	2006.06.30.21.41.12;	author deraadt;	state Exp;
branches;
next	1.133;

1.133
date	2006.04.27.02.19.32;	author tedu;	state Exp;
branches;
next	1.132;

1.132
date	2006.01.13.10.11.23;	author mpf;	state Exp;
branches;
next	1.131;

1.131
date	2005.11.24.12.08.16;	author pedro;	state Exp;
branches;
next	1.130;

1.130
date	2005.05.28.15.10.07;	author ho;	state Exp;
branches;
next	1.129;

1.129
date	2005.05.27.19.32.31;	author hshoexer;	state Exp;
branches;
next	1.128;

1.128
date	2004.11.19.10.11.52;	author hshoexer;	state Exp;
branches;
next	1.127;

1.127
date	2004.04.14.20.10.04;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2004.01.22.14.38.28;	author markus;	state Exp;
branches;
next	1.125;

1.125
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.124;

1.124
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches;
next	1.123;

1.123
date	2003.07.24.08.03.20;	author itojun;	state Exp;
branches;
next	1.122;

1.122
date	2003.05.06.07.28.39;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.120;

1.120
date	2002.05.31.02.39.53;	author angelos;	state Exp;
branches;
next	1.119;

1.119
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.118;

1.118
date	2001.08.19.06.31.56;	author angelos;	state Exp;
branches
	1.118.4.1;
next	1.117;

1.117
date	2001.07.05.08.42.57;	author angelos;	state Exp;
branches;
next	1.116;

1.116
date	2001.07.05.08.31.48;	author jjbg;	state Exp;
branches;
next	1.115;

1.115
date	2001.06.27.04.44.03;	author angelos;	state Exp;
branches;
next	1.114;

1.114
date	2001.06.27.04.39.11;	author angelos;	state Exp;
branches;
next	1.113;

1.113
date	2001.06.27.01.34.07;	author angelos;	state Exp;
branches;
next	1.112;

1.112
date	2001.06.26.18.56.30;	author angelos;	state Exp;
branches;
next	1.111;

1.111
date	2001.06.26.18.34.40;	author angelos;	state Exp;
branches;
next	1.110;

1.110
date	2001.06.26.03.52.42;	author angelos;	state Exp;
branches;
next	1.109;

1.109
date	2001.06.25.23.18.08;	author beck;	state Exp;
branches;
next	1.108;

1.108
date	2001.06.25.23.08.24;	author angelos;	state Exp;
branches;
next	1.107;

1.107
date	2001.06.25.05.11.59;	author angelos;	state Exp;
branches;
next	1.106;

1.106
date	2001.06.24.21.52.28;	author mickey;	state Exp;
branches;
next	1.105;

1.105
date	2001.06.24.18.22.47;	author provos;	state Exp;
branches;
next	1.104;

1.104
date	2001.06.24.18.15.38;	author provos;	state Exp;
branches;
next	1.103;

1.103
date	2001.06.08.19.40.09;	author angelos;	state Exp;
branches;
next	1.102;

1.102
date	2001.06.07.16.19.47;	author angelos;	state Exp;
branches;
next	1.101;

1.101
date	2001.06.01.07.56.46;	author angelos;	state Exp;
branches;
next	1.100;

1.100
date	2001.06.01.00.09.24;	author angelos;	state Exp;
branches;
next	1.99;

1.99
date	2001.05.31.23.45.50;	author angelos;	state Exp;
branches;
next	1.98;

1.98
date	2001.05.30.16.43.12;	author angelos;	state Exp;
branches;
next	1.97;

1.97
date	2001.05.30.12.24.39;	author angelos;	state Exp;
branches;
next	1.96;

1.96
date	2001.05.30.12.20.20;	author angelos;	state Exp;
branches;
next	1.95;

1.95
date	2001.05.30.11.14.42;	author angelos;	state Exp;
branches;
next	1.94;

1.94
date	2001.05.30.10.55.06;	author angelos;	state Exp;
branches;
next	1.93;

1.93
date	2001.05.29.01.12.27;	author angelos;	state Exp;
branches;
next	1.92;

1.92
date	2001.05.29.01.03.01;	author angelos;	state Exp;
branches;
next	1.91;

1.91
date	2001.05.27.05.17.07;	author angelos;	state Exp;
branches;
next	1.90;

1.90
date	2001.05.27.03.48.15;	author angelos;	state Exp;
branches;
next	1.89;

1.89
date	2001.05.21.06.01.34;	author angelos;	state Exp;
branches;
next	1.88;

1.88
date	2001.05.21.03.27.48;	author angelos;	state Exp;
branches;
next	1.87;

1.87
date	2001.05.21.03.23.36;	author angelos;	state Exp;
branches;
next	1.86;

1.86
date	2001.05.21.03.02.19;	author angelos;	state Exp;
branches;
next	1.85;

1.85
date	2001.05.05.00.31.20;	author angelos;	state Exp;
branches;
next	1.84;

1.84
date	2001.05.01.18.31.35;	author fgsch;	state Exp;
branches;
next	1.83;

1.83
date	2001.04.14.00.30.59;	author angelos;	state Exp;
branches;
next	1.82;

1.82
date	2001.03.28.20.03.04;	author angelos;	state Exp;
branches;
next	1.81;

1.81
date	2001.03.27.14.45.22;	author art;	state Exp;
branches;
next	1.80;

1.80
date	2001.03.15.06.31.00;	author mickey;	state Exp;
branches;
next	1.79;

1.79
date	2001.03.04.20.34.00;	author angelos;	state Exp;
branches;
next	1.78;

1.78
date	2001.02.28.04.16.57;	author angelos;	state Exp;
branches;
next	1.77;

1.77
date	2001.02.12.06.57.19;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2001.02.11.16.25.37;	author fgsch;	state Exp;
branches;
next	1.75;

1.75
date	2000.12.24.04.18.04;	author angelos;	state Exp;
branches;
next	1.74;

1.74
date	2000.10.14.06.23.52;	author angelos;	state Exp;
branches;
next	1.73;

1.73
date	2000.10.09.22.20.41;	author angelos;	state Exp;
branches;
next	1.72;

1.72
date	2000.09.20.19.13.17;	author angelos;	state Exp;
branches;
next	1.71;

1.71
date	2000.09.19.08.38.59;	author angelos;	state Exp;
branches;
next	1.70;

1.70
date	2000.09.19.03.20.59;	author angelos;	state Exp;
branches;
next	1.69;

1.69
date	2000.06.18.19.05.49;	author angelos;	state Exp;
branches;
next	1.68;

1.68
date	2000.06.18.05.58.46;	author itojun;	state Exp;
branches;
next	1.67;

1.67
date	2000.06.06.04.49.29;	author angelos;	state Exp;
branches;
next	1.66;

1.66
date	2000.06.01.04.24.26;	author angelos;	state Exp;
branches;
next	1.65;

1.65
date	2000.06.01.04.01.54;	author angelos;	state Exp;
branches;
next	1.64;

1.64
date	2000.04.19.03.37.36;	author angelos;	state Exp;
branches;
next	1.63;

1.63
date	2000.03.29.07.09.57;	author angelos;	state Exp;
branches;
next	1.62;

1.62
date	2000.03.17.10.25.22;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	2000.02.28.23.13.07;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2000.01.27.08.09.12;	author angelos;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2000.01.21.03.15.05;	author angelos;	state Exp;
branches;
next	1.58;

1.58
date	2000.01.13.06.02.31;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	2000.01.13.05.03.45;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	2000.01.13.00.34.31;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2000.01.10.06.59.23;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	2000.01.10.04.30.53;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2000.01.09.22.31.07;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	99.12.29.20.27.55;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	99.12.25.04.48.16;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	99.12.08.12.10.25;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	99.12.08.06.16.56;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	99.12.06.07.14.36;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	99.12.04.23.20.21;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	99.10.29.05.20.46;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	99.10.29.02.10.02;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	99.10.29.02.02.33;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	99.10.28.03.08.34;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	99.09.29.09.11.21;	author niklas;	state Exp;
branches;
next	1.41;

1.41
date	99.08.10.11.35.26;	author ho;	state Exp;
branches;
next	1.40;

1.40
date	99.08.05.21.58.15;	author ho;	state Exp;
branches;
next	1.39;

1.39
date	99.07.15.14.15.41;	author niklas;	state Exp;
branches;
next	1.38;

1.38
date	99.07.06.20.17.52;	author cmetz;	state Exp;
branches;
next	1.37;

1.37
date	99.06.30.17.23.59;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	99.06.18.07.24.07;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	99.06.06.23.53.02;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	99.05.23.09.04.46;	author niklas;	state Exp;
branches;
next	1.33;

1.33
date	99.05.20.12.52.35;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	99.05.16.21.48.37;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	99.05.14.23.36.21;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	99.05.11.22.57.17;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	99.04.11.19.41.39;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	99.03.27.21.04.19;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	99.02.25.01.30.49;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	99.02.24.23.45.52;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	99.02.24.23.07.20;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	99.02.24.22.33.06;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	99.02.17.20.39.17;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.02.17.18.10.38;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.01.08.21.40.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.11.25.11.47.17;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	98.05.18.21.10.59;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	98.03.18.10.51.38;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	98.03.18.10.16.29;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	97.11.24.19.14.15;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	97.11.04.09.11.17;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.07.27.23.30.37;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.07.15.23.11.10;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	97.07.14.08.46.38;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.07.11.23.37.59;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.07.02.06.58.43;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.07.01.22.12.52;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.06.25.07.53.28;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.06.24.12.15.26;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.06.21.00.09.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.06.20.05.41.53;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.02.28.02.55.33;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	97.02.24.14.06.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.02.21.08.42.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.08.01;	author deraadt;	state Exp;
branches;
next	;

1.60.2.1
date	2000.03.02.07.04.42;	author niklas;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2000.03.24.09.09.37;	author niklas;	state Exp;
branches;
next	1.60.2.3;

1.60.2.3
date	2001.05.14.22.40.11;	author niklas;	state Exp;
branches;
next	1.60.2.4;

1.60.2.4
date	2001.07.04.10.54.52;	author niklas;	state Exp;
branches;
next	1.60.2.5;

1.60.2.5
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.60.2.6;

1.60.2.6
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.60.2.7;

1.60.2.7
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.60.2.8;

1.60.2.8
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.60.2.9;

1.60.2.9
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.60.2.10;

1.60.2.10
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.118.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.118.4.2;

1.118.4.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.118.4.3;

1.118.4.3
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.178
log
@Error propagation does neither make sense for ip input path nor for
asynchronous callbacks.  Make the IPsec functions void, there is
already a counter in the error path.
OK mpi@@
@
text
@/*	$OpenBSD: ip_ipsp.h,v 1.177 2017/01/29 19:58:47 bluhm Exp $	*/
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr),
 * Niels Provos (provos@@physnet.uni-hamburg.de) and
 * Niklas Hallqvist (niklas@@appli.se).
 *
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis and Niklas Hallqvist.
 *
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 * Copyright (c) 1999 Niklas Hallqvist.
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#ifndef _NETINET_IPSP_H_
#define _NETINET_IPSP_H_

struct m_tag;

/* IPSP global definitions. */

#include <sys/types.h>
#ifdef _KERNEL
#include <sys/timeout.h>
#include <sys/tree.h>
#endif
#include <sys/queue.h>
#include <netinet/in.h>
#include <net/radix.h>

union sockaddr_union {
	struct sockaddr		sa;
	struct sockaddr_in	sin;
	struct sockaddr_in6	sin6;
};

#define	AH_HMAC_MAX_HASHLEN	32	/* 256 bits of authenticator for SHA512 */
#define	AH_HMAC_RPLENGTH	4	/* 32 bits of replay counter */
#define	AH_HMAC_INITIAL_RPL	1	/* Replay counter initial value */

/* Authenticator lengths */
#define	AH_MD5_ALEN		16
#define	AH_SHA1_ALEN		20
#define	AH_RMD160_ALEN		20
#define	AH_SHA2_256_ALEN	32
#define	AH_SHA2_384_ALEN	48
#define	AH_SHA2_512_ALEN	64
#define	AH_ALEN_MAX		64 	/* Keep updated */

/* Reserved SPI numbers */
#define	SPI_LOCAL_USE		0
#define	SPI_RESERVED_MIN	1
#define	SPI_RESERVED_MAX	255

/* Reserved CPI numbers */
#define CPI_RESERVED_MIN	1
#define CPI_RESERVED_MAX	255
#define CPI_PRIVATE_MIN		61440
#define CPI_PRIVATE_MAX		65535

/* sysctl default values */
#define	IPSEC_DEFAULT_EMBRYONIC_SA_TIMEOUT	60	/* 1 minute */
#define	IPSEC_DEFAULT_PFS			1
#define	IPSEC_DEFAULT_SOFT_ALLOCATIONS		0
#define	IPSEC_DEFAULT_EXP_ALLOCATIONS		0
#define	IPSEC_DEFAULT_SOFT_BYTES		0
#define	IPSEC_DEFAULT_EXP_BYTES			0
#define	IPSEC_DEFAULT_SOFT_TIMEOUT		80000
#define	IPSEC_DEFAULT_EXP_TIMEOUT		86400
#define	IPSEC_DEFAULT_SOFT_FIRST_USE		3600
#define	IPSEC_DEFAULT_EXP_FIRST_USE		7200
#define	IPSEC_DEFAULT_DEF_ENC			"aes"
#define	IPSEC_DEFAULT_DEF_AUTH			"hmac-sha1"
#define	IPSEC_DEFAULT_EXPIRE_ACQUIRE		30
#define	IPSEC_DEFAULT_DEF_COMP			"deflate"

struct sockaddr_encap {
	u_int8_t	sen_len;		/* length */
	u_int8_t	sen_family;		/* PF_KEY */
	u_int16_t	sen_type;		/* see SENT_* */
	union {
		struct {				/* SENT_IP4 */
			u_int8_t	Direction;
			struct in_addr	Src;
			struct in_addr	Dst;
			u_int8_t	Proto;
			u_int16_t	Sport;
			u_int16_t	Dport;
		} Sip4;

		struct {				/* SENT_IP6 */
			u_int8_t	Direction;
			struct in6_addr	Src;
			struct in6_addr	Dst;
			u_int8_t	Proto;
			u_int16_t	Sport;
			u_int16_t	Dport;
		} Sip6;

		struct ipsec_policy	*PolicyHead;	/* SENT_IPSP */
	} Sen;
};

#define	IPSP_DIRECTION_IN	0x1
#define	IPSP_DIRECTION_OUT	0x2

#ifdef _KERNEL

#define	sen_data		Sen.Data
#define	sen_ip_src		Sen.Sip4.Src
#define	sen_ip_dst		Sen.Sip4.Dst
#define	sen_proto		Sen.Sip4.Proto
#define	sen_sport		Sen.Sip4.Sport
#define	sen_dport		Sen.Sip4.Dport
#define	sen_direction		Sen.Sip4.Direction
#define	sen_ip6_src		Sen.Sip6.Src
#define	sen_ip6_dst		Sen.Sip6.Dst
#define	sen_ip6_proto		Sen.Sip6.Proto
#define	sen_ip6_sport		Sen.Sip6.Sport
#define	sen_ip6_dport		Sen.Sip6.Dport
#define	sen_ip6_direction	Sen.Sip6.Direction
#define	sen_ipsp		Sen.PolicyHead

/*
 * The "type" is really part of the address as far as the routing
 * system is concerned. By using only one bit in the type field
 * for each type, we sort-of make sure that different types of
 * encapsulation addresses won't be matched against the wrong type.
 *
 */

#define	SENT_IP4	0x0001		/* data is two struct in_addr */
#define	SENT_IPSP	0x0002		/* data as in IP4/6 plus SPI */
#define	SENT_IP6	0x0004

#define	SENT_LEN	sizeof(struct sockaddr_encap)

struct ipsec_id {
	u_int16_t	type;		/* Subtype of data */
	int16_t		len;		/* Length of data following */
};

struct ipsec_ids {
	RBT_ENTRY(ipsec_ids)	id_node_id;
	RBT_ENTRY(ipsec_ids)	id_node_flow;
	struct ipsec_id		*id_local;
	struct ipsec_id		*id_remote;
	u_int32_t		id_flow;
	int			id_refcount;
	struct timeout		id_timeout;
};
RBT_HEAD(ipsec_ids_flows, ipsec_ids);
RBT_HEAD(ipsec_ids_tree, ipsec_ids);

struct ipsec_acquire {
	union sockaddr_union		ipa_addr;
	u_int32_t			ipa_seq;
	struct sockaddr_encap		ipa_info;
	struct sockaddr_encap		ipa_mask;
	struct timeout			ipa_timeout;
	struct ipsec_policy		*ipa_policy;
	struct inpcb                    *ipa_pcb;
	TAILQ_ENTRY(ipsec_acquire)	ipa_ipo_next;
	TAILQ_ENTRY(ipsec_acquire)	ipa_next;
};

struct ipsec_policy {
	struct radix_node	ipo_nodes[2];	/* radix tree glue */
	struct sockaddr_encap	ipo_addr;
	struct sockaddr_encap	ipo_mask;

	union sockaddr_union	ipo_src;	/* Local address to use */
	union sockaddr_union	ipo_dst;	/* Remote gateway -- if it's zeroed:
						 * - on output, we try to
						 * contact the remote host
						 * directly (if needed).  
						 * - on input, we accept on if
						 * the inner source is the
						 * same as the outer source
						 * address, or if transport
						 * mode was used.
						 */

	u_int64_t		ipo_last_searched;	/* Timestamp of last lookup */

	u_int8_t		ipo_flags;	/* See IPSP_POLICY_* definitions */
	u_int8_t		ipo_type;	/* USE/ACQUIRE/... */
	u_int8_t		ipo_sproto;	/* ESP/AH; if zero, use system dflts */
	u_int			ipo_rdomain;

	int                     ipo_ref_count;

	struct tdb		*ipo_tdb;		/* Cached entry */

	struct ipsec_ids	*ipo_ids;

	TAILQ_HEAD(ipo_acquires_head, ipsec_acquire) ipo_acquires; /* List of acquires */
	TAILQ_ENTRY(ipsec_policy)	ipo_tdb_next;	/* List TDB policies */
	TAILQ_ENTRY(ipsec_policy)	ipo_list;	/* List of all policies */
};

#define	IPSP_POLICY_NONE	0x0000	/* No flags set */
#define	IPSP_POLICY_STATIC	0x0002	/* Static policy */

#define	IPSP_IPSEC_USE		0	/* Use if existing, don't acquire */
#define	IPSP_IPSEC_ACQUIRE	1	/* Try acquire, let packet through */
#define	IPSP_IPSEC_REQUIRE	2	/* Require SA */
#define	IPSP_PERMIT		3	/* Permit traffic through */
#define	IPSP_DENY		4	/* Deny traffic */
#define	IPSP_IPSEC_DONTACQ	5	/* Require, but don't acquire */

/* Identity types */
#define	IPSP_IDENTITY_NONE		0
#define	IPSP_IDENTITY_PREFIX		1
#define	IPSP_IDENTITY_FQDN		2
#define	IPSP_IDENTITY_USERFQDN		3

struct tdb {				/* tunnel descriptor block */
	/*
	 * Each TDB is on three hash tables: one keyed on dst/spi/sproto,
	 * one keyed on dst/sproto, and one keyed on src/sproto. The first
	 * is used for finding a specific TDB, the second for finding TDBs
	 * for outgoing policy matching, and the third for incoming
	 * policy matching. The following three fields maintain the hash
	 * queues in those three tables.
	 */
	struct tdb	*tdb_hnext;	/* dst/spi/sproto table */
	struct tdb	*tdb_dnext;	/* dst/sproto table */
	struct tdb	*tdb_snext;	/* src/sproto table */
	struct tdb	*tdb_inext;
	struct tdb	*tdb_onext;

	struct xformsw		*tdb_xform;		/* Transform to use */
	struct enc_xform	*tdb_encalgxform;	/* Enc algorithm */
	struct auth_hash	*tdb_authalgxform;	/* Auth algorithm */
	struct comp_algo	*tdb_compalgxform;	/* Compression algo */

#define	TDBF_UNIQUE		0x00001	/* This should not be used by others */
#define	TDBF_TIMER		0x00002	/* Absolute expiration timer in use */
#define	TDBF_BYTES		0x00004	/* Check the byte counters */
#define	TDBF_ALLOCATIONS	0x00008	/* Check the flows counters */
#define	TDBF_INVALID		0x00010	/* This SPI is not valid yet/anymore */
#define	TDBF_FIRSTUSE		0x00020	/* Expire after first use */
#define	TDBF_SOFT_TIMER		0x00080	/* Soft expiration */
#define	TDBF_SOFT_BYTES		0x00100	/* Soft expiration */
#define	TDBF_SOFT_ALLOCATIONS	0x00200	/* Soft expiration */
#define	TDBF_SOFT_FIRSTUSE	0x00400	/* Soft expiration */
#define	TDBF_PFS		0x00800	/* Ask for PFS from Key Mgmt. */
#define	TDBF_TUNNELING		0x01000	/* Force IP-IP encapsulation */
#define	TDBF_USEDTUNNEL		0x10000	/* Appended a tunnel header in past */
#define	TDBF_UDPENCAP		0x20000	/* UDP encapsulation */
#define	TDBF_PFSYNC		0x40000	/* TDB will be synced */
#define	TDBF_PFSYNC_RPL		0x80000	/* Replay counter should be bumped */
#define	TDBF_ESN		0x100000 /* 64-bit sequence numbers (ESN) */

	u_int32_t	tdb_flags;	/* Flags related to this TDB */

	struct timeout	tdb_timer_tmo;
	struct timeout	tdb_first_tmo;
	struct timeout	tdb_stimer_tmo;
	struct timeout	tdb_sfirst_tmo;

	u_int32_t	tdb_seq;		/* Tracking number for PFKEY */
	u_int32_t	tdb_exp_allocations;	/* Expire after so many flows */
	u_int32_t	tdb_soft_allocations;	/* Expiration warning */
	u_int32_t	tdb_cur_allocations;	/* Total number of allocs */

	u_int64_t	tdb_exp_bytes;	/* Expire after so many bytes passed */
	u_int64_t	tdb_soft_bytes;	/* Expiration warning */
	u_int64_t	tdb_cur_bytes;	/* Current count of bytes */

	u_int64_t	tdb_exp_timeout;	/* When does the SPI expire */
	u_int64_t	tdb_soft_timeout;	/* Send soft-expire warning */
	u_int64_t	tdb_established;	/* When was SPI established */

	u_int64_t	tdb_first_use;		/* When was it first used */
	u_int64_t	tdb_soft_first_use;	/* Soft warning */
	u_int64_t	tdb_exp_first_use;	/* Expire if tdb_first_use +
						 * tdb_exp_first_use <= curtime
						 */

	u_int64_t	tdb_last_used;	/* When was this SA last used */
	u_int64_t	tdb_last_marked;/* Last SKIPCRYPTO status change */

	u_int64_t	tdb_cryptoid;	/* Crypto session ID */

	u_int32_t	tdb_spi;	/* SPI */
	u_int16_t	tdb_amxkeylen;	/* Raw authentication key length */
	u_int16_t	tdb_emxkeylen;	/* Raw encryption key length */
	u_int16_t	tdb_ivlen;	/* IV length */
	u_int8_t	tdb_sproto;	/* IPsec protocol */
	u_int8_t	tdb_wnd;	/* Replay window */
	u_int8_t	tdb_satype;	/* SA type (RFC2367, PF_KEY) */
	u_int8_t	tdb_updates;	/* pfsync update counter */

	union sockaddr_union	tdb_dst;	/* Destination address */
	union sockaddr_union	tdb_src;	/* Source address */

	u_int8_t	*tdb_amxkey;	/* Raw authentication key */
	u_int8_t	*tdb_emxkey;	/* Raw encryption key */

#define TDB_REPLAYWASTE	32
#define TDB_REPLAYMAX	(2100+TDB_REPLAYWASTE)

	u_int64_t	tdb_rpl;	/* Replay counter */
	u_int32_t	tdb_seen[howmany(TDB_REPLAYMAX, 32)]; /* Anti-replay window */

	u_int8_t	tdb_iv[4];	/* Used for HALF-IV ESP */

	struct ipsec_ids	*tdb_ids;	/* Src/Dst ID for this SA */
	int		tdb_ids_swapped;	/* XXX */

	u_int32_t	tdb_mtu;	/* MTU at this point in the chain */
	u_int64_t	tdb_mtutimeout;	/* When to ignore this entry */

	u_int16_t	tdb_udpencap_port;	/* Peer UDP port */

	u_int16_t	tdb_tag;		/* Packet filter tag */
	u_int32_t	tdb_tap;		/* Alternate enc(4) interface */

	u_int		tdb_rdomain;		/* Routing domain */

	struct sockaddr_encap   tdb_filter; /* What traffic is acceptable */
	struct sockaddr_encap   tdb_filtermask; /* And the mask */

	TAILQ_HEAD(tdb_policy_head, ipsec_policy)	tdb_policy_head;
	TAILQ_ENTRY(tdb)	tdb_sync_entry;
};

#endif /* _KERNEL */

struct tdb_ident {
	u_int32_t spi;
	union sockaddr_union dst;
	u_int8_t proto;
	u_int rdomain;
};

struct tdb_crypto {
	u_int32_t		tc_spi;
	union sockaddr_union	tc_dst;
	u_int8_t		tc_proto;
	int			tc_protoff;
	int			tc_skip;
	u_int			tc_rdomain;
};

struct ipsecinit {
	u_int8_t	*ii_enckey;
	u_int8_t	*ii_authkey;
	u_int16_t	ii_enckeylen;
	u_int16_t	ii_authkeylen;
	u_int8_t	ii_encalg;
	u_int8_t	ii_authalg;
	u_int8_t	ii_compalg;
};

/* xform IDs */
#define	XF_IP4		1	/* IP inside IP */
#define	XF_AH		2	/* AH */
#define	XF_ESP		3	/* ESP */
#define	XF_TCPSIGNATURE	5	/* TCP MD5 Signature option, RFC 2358 */
#define	XF_IPCOMP	6	/* IPCOMP */

/* xform attributes */
#define	XFT_AUTH	0x0001
#define	XFT_CONF	0x0100
#define	XFT_COMP	0x1000

#define	IPSEC_ZEROES_SIZE	256	/* Larger than an IP6 extension hdr. */

#ifdef _KERNEL

struct xformsw {
	u_short	xf_type;		/* Unique ID of xform */
	u_short	xf_flags;		/* flags (see below) */
	char	*xf_name;		/* human-readable name */
	int	(*xf_attach)(void);	/* called at config time */
	int	(*xf_init)(struct tdb *, struct xformsw *, struct ipsecinit *);
	int	(*xf_zeroize)(struct tdb *); /* termination */
	int	(*xf_input)(struct mbuf *, struct tdb *, int, int); /* input */
	int	(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **,
	    int, int);        /* output */
};

extern int ipsec_in_use;
extern u_int64_t ipsec_last_added;
extern int ipsec_policy_pool_initialized;

extern int ipsec_keep_invalid;		/* lifetime of embryonic SAs (in sec) */
extern int ipsec_require_pfs;		/* use Perfect Forward Secrecy */
extern int ipsec_expire_acquire;	/* wait for security assoc. (in sec) */
extern int ipsec_soft_allocations;	/* flows/SA before renegotiation */
extern int ipsec_exp_allocations;	/* num. of flows/SA before it expires */
extern int ipsec_soft_bytes;		/* bytes/SA before renegotiation */
extern int ipsec_exp_bytes;		/* num of bytes/SA before it expires */
extern int ipsec_soft_timeout;		/* seconds/SA before renegotiation */
extern int ipsec_exp_timeout;		/* seconds/SA before it expires */
extern int ipsec_soft_first_use;	/* seconds between 1st asso & renego */
extern int ipsec_exp_first_use;		/* seconds between 1st asso & expire */	

extern char ipsec_def_enc[];
extern char ipsec_def_auth[];
extern char ipsec_def_comp[];

extern struct enc_xform enc_xform_des;
extern struct enc_xform enc_xform_3des;
extern struct enc_xform enc_xform_blf;
extern struct enc_xform enc_xform_cast5;

extern struct auth_hash auth_hash_hmac_md5_96;
extern struct auth_hash auth_hash_hmac_sha1_96;
extern struct auth_hash auth_hash_hmac_ripemd_160_96;

extern struct comp_algo comp_algo_deflate;

extern TAILQ_HEAD(ipsec_policy_head, ipsec_policy) ipsec_policy_head;
extern TAILQ_HEAD(ipsec_acquire_head, ipsec_acquire) ipsec_acquire_head;

/* Misc. */
#ifdef ENCDEBUG
const char *ipsp_address(union sockaddr_union *, char *, socklen_t);
#endif /* ENCDEBUG */

/* SPD tables */
struct radix_node_head *spd_table_add(unsigned int);
struct radix_node_head *spd_table_get(unsigned int);

/* TDB management routines */
uint32_t reserve_spi(u_int, u_int32_t, u_int32_t, union sockaddr_union *,
		union sockaddr_union *, u_int8_t, int *);
struct	tdb *gettdb(u_int, u_int32_t, union sockaddr_union *, u_int8_t);
struct	tdb *gettdbbydst(u_int, union sockaddr_union *, u_int8_t,
		struct ipsec_ids *,
		struct sockaddr_encap *, struct sockaddr_encap *);
struct	tdb *gettdbbysrc(u_int, union sockaddr_union *, u_int8_t,
		struct ipsec_ids *,
		struct sockaddr_encap *, struct sockaddr_encap *);
struct	tdb *gettdbbysrcdst(u_int, u_int32_t, union sockaddr_union *,
		union sockaddr_union *, u_int8_t);
void	puttdb(struct tdb *);
void	tdb_delete(struct tdb *);
struct	tdb *tdb_alloc(u_int);
void	tdb_free(struct tdb *);
int	tdb_init(struct tdb *, u_int16_t, struct ipsecinit *);
int	tdb_walk(u_int, int (*)(struct tdb *, void *, int), void *);

/* XF_IP4 */
int	ipe4_attach(void);
int	ipe4_init(struct tdb *, struct xformsw *, struct ipsecinit *);
int	ipe4_zeroize(struct tdb *);
void	ipe4_input(struct mbuf *, int, int);
int	ipip_input(struct mbuf **, int *, struct ifnet *, int);
int	ipip_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);

int	ip4_input(struct mbuf **, int *, int);

/* XF_AH */
int 	ah_attach(void);
int 	ah_init(struct tdb *, struct xformsw *, struct ipsecinit *);
int 	ah_zeroize(struct tdb *);
int	ah_input(struct mbuf *, struct tdb *, int, int);
int	ah_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
int	ah_sysctl(int *, u_int, void *, size_t *, void *, size_t);

int	ah4_input(struct mbuf **, int *, int);
void	ah4_ctlinput(int, struct sockaddr *, u_int, void *);
void	udpencap_ctlinput(int, struct sockaddr *, u_int, void *);

#ifdef INET6
int	ah6_input(struct mbuf **, int *, int);
#endif /* INET6 */

/* XF_ESP */
int	esp_attach(void);
int	esp_init(struct tdb *, struct xformsw *, struct ipsecinit *);
int	esp_zeroize(struct tdb *);
int	esp_input(struct mbuf *, struct tdb *, int, int);
int	esp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
int	esp_sysctl(int *, u_int, void *, size_t *, void *, size_t);

int	esp4_input(struct mbuf **, int *, int);
void	esp4_ctlinput(int, struct sockaddr *, u_int, void *);

#ifdef INET6
int 	esp6_input(struct mbuf **, int *, int);
#endif /* INET6 */

/* XF_IPCOMP */
int	ipcomp_attach(void);
int	ipcomp_init(struct tdb *, struct xformsw *, struct ipsecinit *);
int	ipcomp_zeroize(struct tdb *);
int	ipcomp_input(struct mbuf *, struct tdb *, int, int);
int	ipcomp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
int	ipcomp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
int	ipcomp4_input(struct mbuf **, int *, int);
#ifdef INET6
int	ipcomp6_input(struct mbuf **, int *, int);
#endif /* INET6 */

/* XF_TCPSIGNATURE */
int	tcp_signature_tdb_attach(void);
int	tcp_signature_tdb_init(struct tdb *, struct xformsw *,
	    struct ipsecinit *);
int	tcp_signature_tdb_zeroize(struct tdb *);
int	tcp_signature_tdb_input(struct mbuf *, struct tdb *, int, int);
int	tcp_signature_tdb_output(struct mbuf *, struct tdb *, struct mbuf **,
	  int, int);

/* Replay window */
int	checkreplaywindow(struct tdb *, u_int32_t, u_int32_t *, int);

/* Packet processing */
int	ipsp_process_packet(struct mbuf *, struct tdb *, int, int);
int	ipsp_process_done(struct mbuf *, struct tdb *);
struct	tdb *ipsp_spd_lookup(struct mbuf *, int, int, int *, int,
	    struct tdb *, struct inpcb *, u_int32_t);
struct	tdb *ipsp_spd_inp(struct mbuf *, int, int, int *, int,
	    struct tdb *, struct inpcb *, struct ipsec_policy *);
int	ipsp_is_unspecified(union sockaddr_union);
int	ipsp_aux_match(struct tdb *, struct ipsec_ids *,
	    struct sockaddr_encap *, struct sockaddr_encap *);
int	ipsp_ids_match(struct ipsec_ids *, struct ipsec_ids *);
struct ipsec_ids *ipsp_ids_insert(struct ipsec_ids *);
struct ipsec_ids *ipsp_ids_lookup(u_int32_t);
void	ipsp_ids_free(struct ipsec_ids *);

int	ipsec_common_input(struct mbuf *, int, int, int, int, int);
void	ipsec_common_input_cb(struct mbuf *, struct tdb *, int, int);
int	ipsec_delete_policy(struct ipsec_policy *);
ssize_t	ipsec_hdrsz(struct tdb *);
void	ipsec_adjust_mtu(struct mbuf *, u_int32_t);
struct	ipsec_acquire *ipsec_get_acquire(u_int32_t);

#endif /* _KERNEL */
#endif /* _NETINET_IPSP_H_ */
@


1.177
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.176 2017/01/26 13:03:47 bluhm Exp $	*/
d554 1
a554 1
int	ipsec_common_input_cb(struct mbuf *, struct tdb *, int, int);
@


1.176
log
@Reduce the difference between struct protosw and ip6protosw.  The
IPv4 pr_ctlinput functions did return a void pointer that was always
NULL and never used.  Make all functions void like in the IPv6 case.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.175 2017/01/25 17:34:31 bluhm Exp $	*/
d478 1
a478 1
void	ipip_input(struct mbuf *, int, struct ifnet *, int);
d481 1
a481 5
void	ip4_input(struct mbuf *, int, int);

#ifdef INET6
int	ip4_input6(struct mbuf **, int *, int);
#endif /* INET6 */
d491 1
a491 1
void	ah4_input(struct mbuf *, int, int);
d507 1
a507 1
void	esp4_input(struct mbuf *, int, int);
d521 1
a521 3

void	ipcomp4_input(struct mbuf *, int, int);

@


1.175
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.174 2016/09/15 03:37:09 dlg Exp $	*/
d496 2
a497 2
void	*ah4_ctlinput(int, struct sockaddr *, u_int, void *);
void	*udpencap_ctlinput(int, struct sockaddr *, u_int, void *);
d512 1
a512 1
void	*esp4_ctlinput(int, struct sockaddr *, u_int, void *);
@


1.174
log
@move from RB macros to RBT functions

shaves a bunch of bytes off kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.173 2015/12/03 13:12:20 tedu Exp $	*/
d477 1
a477 1
void	ipe4_input(struct mbuf *, ...);
d481 1
a481 1
void	ip4_input(struct mbuf *, ...);
d495 1
a495 1
void	ah4_input(struct mbuf *, ...);
d511 1
a511 1
void	esp4_input(struct mbuf *, ...);
d526 1
a526 1
void	ipcomp4_input(struct mbuf *, ...);
@


1.173
log
@remove some unused defines. ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.172 2015/08/25 11:50:14 deraadt Exp $	*/
d169 2
a170 2
	RB_ENTRY(ipsec_ids)	id_node_id;
	RB_ENTRY(ipsec_ids)	id_node_flow;
d177 2
a178 2
RB_HEAD(ipsec_ids_flows, ipsec_ids);
RB_HEAD(ipsec_ids_tree, ipsec_ids);
@


1.172
log
@correct #if/#endif guard comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.171 2015/07/17 18:31:08 blambert Exp $	*/
a60 8

/* HMAC key sizes */
#define	MD5HMAC96_KEYSIZE	16
#define	SHA1HMAC96_KEYSIZE	20
#define	RIPEMD160HMAC96_KEYSIZE	20
#define	SHA2_256HMAC96_KEYSIZE	32
#define	SHA2_384HMAC96_KEYSIZE	48
#define	SHA2_512HMAC96_KEYSIZE	64
@


1.171
log
@manage spd entries by using the radix api directly instead of
reaching around through the routing table

original diff by myself, much improved by mikeb@@ and mpi@@

ok and testing mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.170 2015/05/23 12:38:53 markus Exp $	*/
d493 1
a493 1
#endif /* INET */
@


1.170
log
@introduce ipsec-id bundles and use them for ipsecflowinfo,
fixes rekeying for l2tp/ipsec against multiple windows clients
and saves memory (for many SAs to same peers); feedback and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.169 2015/04/17 11:04:01 mikeb Exp $	*/
d54 1
d201 1
d457 4
@


1.169
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.168 2015/04/17 10:04:37 mikeb Exp $	*/
d50 1
d170 3
a172 5
struct ipsec_ref {
	u_int16_t	ref_type;	/* Subtype of data */
	int16_t		ref_len;	/* Length of data following */
	int		ref_count;	/* Reference count */
	int		ref_malloctype;	/* malloc(9) type, for freeing */
d175 12
d226 1
a226 2
	struct ipsec_ref	*ipo_srcid;
	struct ipsec_ref	*ipo_dstid;
d341 2
a342 2
	struct ipsec_ref	*tdb_srcid;	/* Source ID for this SA */
	struct ipsec_ref	*tdb_dstid;	/* Destination ID for this SA */
d461 1
a461 1
		struct ipsec_ref *, struct ipsec_ref *,
d464 1
a464 1
		struct ipsec_ref *, struct ipsec_ref *,
d554 1
a554 3
int	ipsp_ref_match(struct ipsec_ref *, struct ipsec_ref *);
void	ipsp_reffree(struct ipsec_ref *);
int	ipsp_aux_match(struct tdb *, struct ipsec_ref *, struct ipsec_ref *,
d556 4
@


1.168
log
@Remove unsupported SADB_X_IDENTTYPE_CONNECTION;  OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.167 2015/04/16 19:44:01 markus Exp $	*/
a270 1
#define	TDBF_SKIPCRYPTO		0x08000	/* Skip actual crypto processing */
a365 1
	caddr_t			tc_ptr;
a545 2
void	ipsp_skipcrypto_mark(struct tdb_ident *);
void	ipsp_skipcrypto_unmark(struct tdb_ident *);
d550 1
a550 2
int	ipsec_common_input_cb(struct mbuf *, struct tdb *, int, int,
	    struct m_tag *);
@


1.167
log
@ipa_inp_next is unused; via mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.166 2015/04/16 19:24:13 markus Exp $	*/
a237 1
#define	IPSP_IDENTITY_CONNECTION	4
@


1.166
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.165 2015/04/14 14:20:01 mikeb Exp $	*/
a185 1
	TAILQ_ENTRY(ipsec_acquire)      ipa_inp_next;
@


1.165
log
@make ipsp_address thread safe;  ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.164 2015/04/14 12:22:15 mikeb Exp $	*/
a224 1
#define	IPSP_POLICY_SOCKET	0x0001	/* Socket-attached policy */
a233 10
/* Notification types */
#define	NOTIFY_SOFT_EXPIRE	0	/* Soft expiration of SA */
#define	NOTIFY_HARD_EXPIRE	1	/* Hard expiration of SA */
#define	NOTIFY_REQUEST_SA	2	/* Establish an SA */

#define	NOTIFY_SATYPE_CONF	1	/* SA should do encryption */
#define	NOTIFY_SATYPE_AUTH	2	/* SA should do authentication */
#define	NOTIFY_SATYPE_TUNNEL	4	/* SA should use tunneling */
#define NOTIFY_SATYPE_COMP	5       /* SA (IPCA) should use compression */

a349 2
	TAILQ_HEAD(tdb_inp_head_in, inpcb)	tdb_inp_in;
	TAILQ_HEAD(tdb_inp_head_out, inpcb)	tdb_inp_out;
a444 22
/* Check if a given tdb has encryption, authentication and/or tunneling */
#define	TDB_ATTRIB(x) (((x)->tdb_encalgxform ? NOTIFY_SATYPE_CONF : 0) | \
		       ((x)->tdb_authalgxform ? NOTIFY_SATYPE_AUTH : 0) | \
		       ((x)->tdb_compalgxform ? NOTIFY_SATYPE_COMP : 0))

/* Traverse spi chain and get attributes */

#define	SPI_CHAIN_ATTRIB(have, TDB_DIR, TDBP)				\
do {									\
	int s = splsoftnet();						\
	struct tdb *tmptdb = (TDBP);					\
									\
	(have) = 0;							\
	while (tmptdb && tmptdb->tdb_xform) {				\
	        if (tmptdb == NULL || tmptdb->tdb_flags & TDBF_INVALID)	\
			break;						\
		(have) |= TDB_ATTRIB(tmptdb);				\
		tmptdb = tmptdb->TDB_DIR;				\
	}								\
	splx(s);							\
} while (/* CONSTCOND */ 0)

a445 1
uint8_t	get_sa_require(struct inpcb *);
a450 1
void	tdb_add_inp(struct tdb *, struct inpcb *, int);
a560 1
struct	ipsec_policy *ipsec_add_policy(struct inpcb *, int, int);
@


1.164
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.163 2015/04/13 16:48:01 mikeb Exp $	*/
d483 1
a483 1
const char *ipsp_address(union sockaddr_union);
@


1.163
log
@Rename gettdbbyaddr to gettdbbydst;  OK markus, hshoexer, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.162 2015/04/13 16:45:52 mikeb Exp $	*/
a217 2
	struct ipsec_ref	*ipo_local_cred;
	struct ipsec_ref	*ipo_local_auth;
a244 10
/* Authentication types */
#define	IPSP_AUTH_NONE		0
#define	IPSP_AUTH_PASSPHRASE	1
#define	IPSP_AUTH_RSA		2

/* Credential types */
#define	IPSP_CRED_NONE		0
#define	IPSP_CRED_KEYNOTE	1
#define	IPSP_CRED_X509		2

a344 2
	struct ipsec_ref	*tdb_local_cred;
	struct ipsec_ref	*tdb_remote_cred;
a346 2
	struct ipsec_ref	*tdb_local_auth;/* Local authentication material */
	struct ipsec_ref	*tdb_remote_auth;/* Remote authentication material */
d492 1
a492 1
		struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
d590 1
a590 2
	    struct ipsec_ref *, struct ipsec_ref *, struct sockaddr_encap *,
	    struct sockaddr_encap *);
@


1.162
log
@Remove unused arguments from gettdb* functions;  OK markus, hshoexer, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.161 2015/03/26 12:21:37 mikeb Exp $	*/
d274 1
a274 1
	struct tdb	*tdb_anext;	/* dst/sproto table */
d507 1
a507 1
struct	tdb *gettdbbyaddr(u_int, union sockaddr_union *, u_int8_t,
@


1.161
log
@Remove bits of unfinished IPsec proxy support.  DNS' KX records, anyone?
ok markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.160 2015/01/19 18:36:51 deraadt Exp $	*/
d507 1
a507 1
struct	tdb *gettdbbyaddr(u_int, union sockaddr_union *, u_int8_t, 
d509 1
a509 2
		struct mbuf *, int, struct sockaddr_encap *,
		struct sockaddr_encap *);
d511 1
a511 1
		struct ipsec_ref *, struct ipsec_ref *, struct mbuf *, int,
@


1.160
log
@mikeb points out that 'struct ipsec_policy' can also be hidden by _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.159 2015/01/19 16:49:05 deraadt Exp $	*/
a344 1
	union sockaddr_union	tdb_proxy;
@


1.159
log
@First step of hiding many kernel-only parts of <netinet/ip_ipsp.h>
under _KERNEL, and adjust the one consumer (netstat) so that it requests
the exposure.  Will take a few more rounds to get this right.
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.158 2014/12/23 03:24:08 tedu Exp $	*/
a188 2
#endif /* _KERNEL */

a224 2

#ifdef _KERNEL
@


1.158
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.157 2014/11/25 13:10:03 mpi Exp $	*/
d48 3
a51 1
#include <sys/timeout.h>
d138 2
d189 2
d228 2
d387 2
@


1.157
log
@The proliferation of "struct route" in all its flavors didn't make
any good to our network stack.

The most visible effect is the maze of #ifdef's and casts.  But the
real problem is the very fragile way of checking if a (cached) route
entry is still valid or not.  What should we do if the route jumped
to another ifaddr or if its gateway has been changed?

This change start the dance of "struct route" & friends removal by
sending the completly useless "struct route_enc" to the bucket.

Tweak & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.156 2013/11/11 09:15:35 mpi Exp $	*/
a525 1
#ifdef INET
a526 1
#endif /* INET */
a539 1
#ifdef INET
a542 1
#endif /* INET */
a555 1
#ifdef INET
a557 1
#endif /* INET */
a570 1
#ifdef INET
a571 1
#endif /* INET */
@


1.156
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.155 2013/07/04 09:48:49 mpi Exp $	*/
a258 12

/*
 * For encapsulation routes are possible not only for the destination
 * address but also for the protocol, source and destination ports
 * if available
 */

struct route_enc {
	struct rtentry		*re_rt;
	u_long			re_tableid; /* u_long because of alignment */
	struct sockaddr_encap	re_dst;
};
@


1.155
log
@These functions are only used in debug code, so put them under
ifdef ENCDEBUG to make sure we don't use them elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.154 2013/04/11 12:06:25 mpi Exp $	*/
d506 1
a506 2
char	*inet_ntoa4(struct in_addr);
char	*ipsp_address(union sockaddr_union);
@


1.154
log
@Remove the extern keyword from function declarations, document
sysctl declarations, move variables and functions used in only
one place in their corresponding file. No functional change.

No objection from markus@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.153 2013/02/14 16:22:34 mikeb Exp $	*/
d505 1
d508 1
@


1.153
log
@Merge of an original work by markus@@ and gerhard@@ to increase
the anti-replay window size to 2100 entries; plus small ESN
related improvements.  ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.152 2012/10/18 10:49:48 markus Exp $	*/
a446 3
extern int encdebug;
extern int ipsec_acl;
extern int ipsec_keep_invalid;
d449 1
a449 2
extern int ipsec_require_pfs;
extern int ipsec_expire_acquire;
d451 11
a461 1
extern int ipsec_policy_pool_initialized;
a462 8
extern int ipsec_soft_allocations;
extern int ipsec_exp_allocations;
extern int ipsec_soft_bytes;
extern int ipsec_exp_bytes;
extern int ipsec_soft_timeout;
extern int ipsec_exp_timeout;
extern int ipsec_soft_first_use;
extern int ipsec_exp_first_use;
a480 2
extern struct xformsw xformsw[], *xformswNXFORMSW;

d504 3
a506 2
extern char *inet_ntoa4(struct in_addr);
extern char *ipsp_address(union sockaddr_union);
d509 19
a527 18
extern void tdb_add_inp(struct tdb *, struct inpcb *, int);
extern u_int32_t reserve_spi(u_int, u_int32_t, u_int32_t,
    union sockaddr_union *, union sockaddr_union *, u_int8_t, int *);
extern struct tdb *gettdb(u_int, u_int32_t, union sockaddr_union *, u_int8_t);
extern struct tdb *gettdbbyaddr(u_int, union sockaddr_union *, u_int8_t,
    struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
    struct mbuf *, int, struct sockaddr_encap *, struct sockaddr_encap *);
extern struct tdb *gettdbbysrc(u_int, union sockaddr_union *, u_int8_t,
    struct ipsec_ref *, struct ipsec_ref *, struct mbuf *, int,
    struct sockaddr_encap *, struct sockaddr_encap *);
extern struct tdb *gettdbbysrcdst(u_int, u_int32_t, union sockaddr_union *,
    union sockaddr_union *, u_int8_t);
extern void puttdb(struct tdb *);
extern void tdb_delete(struct tdb *);
extern struct tdb *tdb_alloc(u_int);
extern void tdb_free(struct tdb *);
extern int tdb_init(struct tdb *, u_int16_t, struct ipsecinit *);
extern int tdb_walk(u_int, int (*)(struct tdb *, void *, int), void *);
d530 6
a535 6
extern int ipe4_attach(void);
extern int ipe4_init(struct tdb *, struct xformsw *, struct ipsecinit *);
extern int ipe4_zeroize(struct tdb *);
extern int ipip_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
extern void ipe4_input(struct mbuf *, ...);
extern void ipip_input(struct mbuf *, int, struct ifnet *, int);
d538 1
a538 1
extern void ip4_input(struct mbuf *, ...);
d542 1
a542 1
extern int ip4_input6(struct mbuf **, int *, int);
d546 6
a551 9
extern int ah_attach(void);
extern int ah_init(struct tdb *, struct xformsw *, struct ipsecinit *);
extern int ah_zeroize(struct tdb *);
extern int ah_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
extern int ah_output_cb(void *);
extern int ah_input(struct mbuf *, struct tdb *, int, int);
extern int ah_input_cb(void *);
extern int ah_sysctl(int *, u_int, void *, size_t *, void *, size_t);
extern int ah_massage_headers(struct mbuf **, int, int, int, int);
d554 3
a556 4
extern void ah4_input(struct mbuf *, ...);
extern int ah4_input_cb(struct mbuf *, ...);
extern void *ah4_ctlinput(int, struct sockaddr *, u_int, void *);
extern void *udpencap_ctlinput(int, struct sockaddr *, u_int, void *);
d560 1
a560 2
extern int ah6_input(struct mbuf **, int *, int);
extern int ah6_input_cb(struct mbuf *, int, int);
d564 6
a569 8
extern int esp_attach(void);
extern int esp_init(struct tdb *, struct xformsw *, struct ipsecinit *);
extern int esp_zeroize(struct tdb *);
extern int esp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
extern int esp_output_cb(void *);
extern int esp_input(struct mbuf *, struct tdb *, int, int);
extern int esp_input_cb(void *);
extern int esp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
d572 2
a573 3
extern void esp4_input(struct mbuf *, ...);
extern int esp4_input_cb(struct mbuf *, ...);
extern void *esp4_ctlinput(int, struct sockaddr *, u_int, void *);
d577 1
a577 2
extern int esp6_input(struct mbuf **, int *, int);
extern int esp6_input_cb(struct mbuf *, int, int);
d581 6
a586 8
extern int ipcomp_attach(void);
extern int ipcomp_init(struct tdb *, struct xformsw *, struct ipsecinit *);
extern int ipcomp_zeroize(struct tdb *);
extern int ipcomp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
extern int ipcomp_output_cb(void *);
extern int ipcomp_input(struct mbuf *, struct tdb *, int, int);
extern int ipcomp_input_cb(void *);
extern int ipcomp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
d589 1
a589 2
extern void ipcomp4_input(struct mbuf *, ...);
extern int ipcomp4_input_cb(struct mbuf *, ...);
d593 1
a593 2
extern int ipcomp6_input(struct mbuf **, int *, int);
extern int ipcomp6_input_cb(struct mbuf *, int, int);
d597 7
a603 8
extern int tcp_signature_tdb_attach(void);
extern int tcp_signature_tdb_init(struct tdb *, struct xformsw *,
    struct ipsecinit *);
extern int tcp_signature_tdb_zeroize(struct tdb *);
extern int tcp_signature_tdb_input(struct mbuf *, struct tdb *, int,
    int);
extern int tcp_signature_tdb_output(struct mbuf *, struct tdb *,
    struct mbuf **, int, int);
d606 1
a606 1
extern int checkreplaywindow(struct tdb *, u_int32_t, u_int32_t *, int);
d608 24
a631 1
extern unsigned char ipseczeroes[];
a632 33
/* Packet processing */
extern int ipsp_process_packet(struct mbuf *, struct tdb *, int, int);
extern int ipsp_process_done(struct mbuf *, struct tdb *);
extern struct tdb *ipsp_spd_lookup(struct mbuf *, int, int, int *, int,
    struct tdb *, struct inpcb *, u_int32_t);
extern struct tdb *ipsp_spd_inp(struct mbuf *, int, int, int *, int,
    struct tdb *, struct inpcb *, struct ipsec_policy *);
extern int ipsec_common_input(struct mbuf *, int, int, int, int, int);
extern int ipsec_common_input_cb(struct mbuf *, struct tdb *, int, int,
    struct m_tag *);
extern int ipsp_acquire_sa(struct ipsec_policy *, union sockaddr_union *,
    union sockaddr_union *, struct sockaddr_encap *, struct mbuf *);
extern struct ipsec_policy *ipsec_add_policy(struct inpcb *, int, int);
extern void ipsec_update_policy(struct inpcb *, struct ipsec_policy *,
    int, int);
extern int ipsec_delete_policy(struct ipsec_policy *);
extern struct ipsec_acquire *ipsp_pending_acquire(struct ipsec_policy *,
    union sockaddr_union *);
extern void ipsp_delete_acquire(void *);
extern int ipsp_is_unspecified(union sockaddr_union);
extern void ipsp_reffree(struct ipsec_ref *);
extern void ipsp_skipcrypto_unmark(struct tdb_ident *);
extern void ipsp_skipcrypto_mark(struct tdb_ident *);
extern struct m_tag *ipsp_parse_headers(struct mbuf *, int, u_int8_t);
extern int ipsp_ref_match(struct ipsec_ref *, struct ipsec_ref *);
extern ssize_t ipsec_hdrsz(struct tdb *);
extern void ipsec_adjust_mtu(struct mbuf *, u_int32_t);
extern int ipsp_print_tdb(struct tdb *, char *, size_t);
extern struct ipsec_acquire *ipsec_get_acquire(u_int32_t);
extern int ipsp_aux_match(struct tdb *,
    struct ipsec_ref *, struct ipsec_ref *,
    struct ipsec_ref *, struct ipsec_ref *,
    struct sockaddr_encap *, struct sockaddr_encap *);
@


1.152
log
@simplify checkreplaywindow() API; make call/return code handling consistent
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.151 2012/10/08 17:41:55 camield Exp $	*/
d358 3
d362 1
a362 1
	u_int64_t	tdb_bitmap;	/* Used for replay sliding window */
@


1.151
log
@Forward declare struct m_tag in netinet/ip_ipsp.h so we don't need to
include sys/mbuf.h in net/pfvar.h.

Flagged by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.150 2012/09/20 10:25:03 blambert Exp $	*/
d619 1
a619 2
extern int checkreplaywindow(u_int32_t, u_int64_t *, u_int32_t, u_int64_t *,
    u_int32_t *, int, int);
@


1.150
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.149 2012/09/18 09:24:45 markus Exp $	*/
d42 2
@


1.149
log
@remove the SADB_X_SAFLAGS_{HALFIV,RANDOMPADDING,NOREPLAY} pfkey-API (not set
anywhere) as well as the matching TDBF_{HALFIV,RANDOMPADDING,NOREPLAY} code.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.148 2012/07/16 18:05:36 markus Exp $	*/
a441 8
/*
 * Protects all tdb lists.
 * Must at least be splsoftnet (note: do not use splsoftclock as it is
 * special on some architectures, assuming it is always an spl lowering
 * operation).
 */
#define	spltdb	splsoftnet

d489 1
a489 1
	int s = spltdb();						\
@


1.148
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.147 2012/06/29 14:48:04 mikeb Exp $	*/
a295 1
#define	TDBF_HALFIV		0x00040	/* Use half-length IV (ESP old only) */
a301 2
#define	TDBF_NOREPLAY		0x02000	/* No replay counter present */
#define	TDBF_RANDOMPADDING	0x04000	/* Random data in the ESP padding */
@


1.147
log
@Add support for the Extended (64-bit) Sequence Number as defined
in RFC4302 and RFC4303.  Right now only software crypto engine is
capable of doing it.

Replay check was rewritten to implement algorithm described in the
Appendix A of RFC4303 and the window size was increased to 64.

Tested against OpenBSD, Linux (strongswan) and Windows.

No objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.146 2010/10/06 22:19:20 mikeb Exp $	*/
d637 1
a637 1
    struct tdb *, struct inpcb *);
@


1.146
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.145 2010/09/23 16:34:09 mikeb Exp $	*/
d310 1
d359 2
a360 2
	u_int32_t	tdb_rpl;	/* Replay counter */
	u_int32_t	tdb_bitmap;	/* Used for replay sliding window */
d628 2
a629 2
extern int checkreplaywindow32(u_int32_t, u_int32_t, u_int32_t *, u_int32_t,
    u_int32_t *, int);
@


1.145
log
@remove m_pad in favor of m_inject as it's equivalent to m_inject
with an offset equal to the actual data length.

ok henning blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.144 2010/07/09 16:58:06 reyk Exp $	*/
a477 1
extern struct enc_xform enc_xform_skipjack;
@


1.144
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.143 2010/07/01 02:09:45 reyk Exp $	*/
a625 3

/* Padding */
extern caddr_t m_pad(struct mbuf *, int);
@


1.143
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.141 2010/05/07 13:33:17 claudio Exp $	*/
d204 1
d378 2
d393 1
d403 1
d519 4
a522 4
extern u_int32_t reserve_spi(u_int32_t, u_int32_t, union sockaddr_union *,
    union sockaddr_union *, u_int8_t, int *);
extern struct tdb *gettdb(u_int32_t, union sockaddr_union *, u_int8_t);
extern struct tdb *gettdbbyaddr(union sockaddr_union *, u_int8_t,
d525 1
a525 1
extern struct tdb *gettdbbysrc(union sockaddr_union *, u_int8_t,
d528 1
a528 1
extern struct tdb *gettdbbysrcdst(u_int32_t, union sockaddr_union *,
d532 1
a532 1
extern struct tdb *tdb_alloc(void);
d535 1
a535 1
extern int tdb_walk(int (*)(struct tdb *, void *, int), void *);
@


1.142
log
@Massiv cleanup of the gif(4) mess. Move encapsulation into gif_output()
where it is not necessary to guess protocols by looking at the first nibble.
in_gif_output() will encapsulate the packet but not send it. Because of
etherip support and the way the bridge works a minimal hack is needed in
gif_start() to ensure that the bridged packets are encapsulated as well.
This actually started with the idea to add MPLS support but that turned out
to be not as simple as in the gre(4) case.
Tested by myself (IP, IPv6, etherip, MPLS), sthen@@ (IP, IPv6), naddy (IPv6)
OK sthen@@
@
text
@d375 1
@


1.141
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.140 2010/01/10 12:43:07 markus Exp $	*/
d537 1
a537 1
extern void ipip_input(struct mbuf *, int, struct ifnet *);
a545 5

/* XF_ETHERIP */
extern int etherip_output(struct mbuf *, struct tdb *, struct mbuf **,
    int, int);
extern void etherip_input(struct mbuf *, ...);
@


1.140
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.139 2009/11/13 20:54:05 claudio Exp $	*/
d265 1
@


1.139
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.138 2009/06/02 21:28:36 blambert Exp $	*/
d64 1
a64 1
#define	AH_HMAC_HASHLEN		12	/* 96 bits of authenticator */
@


1.138
log
@Shuffle function declarations a bit; ipsp_kern doesn't actually exist,
and tdb_hash is only used in ip_ipsp.c, so there's no need to declare
it as extern in ip_ipsp.h

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.137 2009/02/16 00:31:25 dlg Exp $	*/
d565 2
a566 2
extern void *ah4_ctlinput(int, struct sockaddr *, void *);
extern void *udpencap_ctlinput(int, struct sockaddr *, void *);
d587 1
a587 1
extern void *esp4_ctlinput(int, struct sockaddr *, void *);
@


1.137
log
@pfsync v5, mostly written at n2k9, but based on work done at n2k8.

WARNING: THIS BREAKS COMPATIBILITY WITH THE PREVIOUS VERSION OF PFSYNC

this is a new variant of the protocol and a large reworking of the
pfsync code to address some performance issues. the single largest
benefit comes from having multiple pfsync messages of different
types handled in a single packet. pfsyncs handling of pf states is
highly optimised now, along with packet parsing and construction.

huggz for beck@@ for testing.
huge thanks to mcbride@@ for his help during development and for
finding all the bugs during the initial tests.
thanks to peter sutton for letting me get credit for this work.

ok beck@@ mcbride@@ "good." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.136 2008/11/08 12:54:58 dlg Exp $	*/
a526 1
extern int tdb_hash(u_int32_t, union sockaddr_union *, u_int8_t);
@


1.136
log
@fix macros up so they use the do { } while (/* CONSTCOND */ 0) idiom

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.134 2006/06/30 21:41:12 deraadt Exp $	*/
d306 2
d347 1
d381 1
@


1.135
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d487 14
a500 13
#define	SPI_CHAIN_ATTRIB(have, TDB_DIR, TDBP) do {\
	int s = spltdb(); \
	struct tdb *tmptdb = (TDBP); \
	\
	(have) = 0; \
	while (tmptdb && tmptdb->tdb_xform) { \
	        if (tmptdb == NULL || tmptdb->tdb_flags & TDBF_INVALID) \
			break; \
		(have) |= TDB_ATTRIB(tmptdb); \
		tmptdb = tmptdb->TDB_DIR; \
	} \
	splx(s); \
} while (0)
@


1.134
log
@htonq() is not used, at all
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.133 2006/04/27 02:19:32 tedu Exp $	*/
d273 1
a273 1
	 * TDBs for outgoing policy matching, and the third for incoming
d369 2
@


1.133
log
@use underscore variants of _BYTE_ORDER macros which are always defined
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.132 2006/01/13 10:11:23 mpf Exp $	*/
a415 22

#if _BYTE_ORDER == _LITTLE_ENDIAN
static __inline u_int64_t
htonq(u_int64_t q)
{
	u_int32_t u, l;
	u = q >> 32;
	l = (u_int32_t) q;

	return htonl(u) | ((u_int64_t)htonl(l) << 32);
}

#define	ntohq(_x)	htonq(_x)

#elif _BYTE_ORDER == _BIG_ENDIAN

#define	htonq(_x)	(_x)
#define	ntohq(_x)	htonq(_x)

#else
#error	"Please fix <machine/endian.h>"
#endif
@


1.132
log
@Path MTU discovery for NAT-T.
OK markus@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.131 2005/11/24 12:08:16 pedro Exp $	*/
d417 1
a417 1
#if BYTE_ORDER == LITTLE_ENDIAN
d430 1
a430 1
#elif BYTE_ORDER == BIG_ENDIAN
@


1.131
log
@Remove kernfs, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.130 2005/05/28 15:10:07 ho Exp $	*/
d582 1
@


1.130
log
@Add SA replay counter synchronization to pfsync(4). Required for IPsec
failover gateways. ok mcbride@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.129 2005/05/27 19:32:31 hshoexer Exp $	*/
a355 1
	u_int32_t	tdb_epoch;	/* Used by the kernfs interface */
a415 1
#define	IPSEC_KERNFS_BUFSIZE	4096
@


1.129
log
@wrap some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.128 2004/11/19 10:11:52 hshoexer Exp $	*/
d544 1
@


1.128
log
@Plug memory leak.  Found by pat@@.  Thanks!

ok myself markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.127 2004/04/14 20:10:04 markus Exp $	*/
d189 7
a195 5
						 * - on output, we try to contact the
						 * remote host directly (if needed).
						 * - on input, we accept on if the
						 * inner source is the same as the
						 * outer source address, or if transport
@


1.127
log
@simpler ipsp_aux_match() API; ok henning, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.126 2004/01/22 14:38:28 markus Exp $	*/
d541 1
@


1.126
log
@add gettdbbysrcdst(), just like gettdb(), but compares tdb_src as well; ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.125 2003/12/10 07:22:43 itojun Exp $	*/
d676 3
a678 4
extern int ipsp_aux_match(struct ipsec_ref *, struct ipsec_ref *,
    struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
    struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
    struct sockaddr_encap *, struct sockaddr_encap *,
@


1.125
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.124 2003/12/02 23:16:29 markus Exp $	*/
d536 2
@


1.124
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.123 2003/07/24 08:03:20 itojun Exp $	*/
d421 1
a421 1
	register u_int32_t u, l;
@


1.123
log
@hmac-sha2-{256,384,512} support in AH/ESP auth.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.122 2003/05/06 07:28:39 deraadt Exp $	*/
d303 1
d367 2
d652 1
@


1.122
log
@string cleaning; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.121 2002/06/09 16:26:10 itojun Exp $	*/
d60 3
d72 4
a75 1
#define	AH_ALEN_MAX		20 	/* Keep updated */
@


1.121
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.120 2002/05/31 02:39:53 angelos Exp $	*/
d662 1
a662 1
extern int ipsp_print_tdb(struct tdb *, char *);
@


1.120
log
@New fields in policy and TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.119 2002/03/14 01:27:11 millert Exp $	*/
d198 1
a198 1
       
@


1.119
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.118 2001/08/19 06:31:56 angelos Exp $	*/
d171 1
d174 1
d197 2
a345 1
	u_int32_t	tdb_initial;	/* Initial replay value */
a347 1

d360 3
a392 12
struct xformsw {
	u_short	xf_type;		/* Unique ID of xform */
	u_short	xf_flags;		/* flags (see below) */
	char	*xf_name;		/* human-readable name */
	int	(*xf_attach)(void);	/* called at config time */
	int	(*xf_init)(struct tdb *, struct xformsw *, struct ipsecinit *);
	int	(*xf_zeroize)(struct tdb *); /* termination */
	int	(*xf_input)(struct mbuf *, struct tdb *, int, int); /* input */
	int	(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **,
	    int, int);        /* output */
};

d432 12
d521 6
a526 4
extern struct tdb *gettdbbyaddr(union sockaddr_union *, struct ipsec_policy *,
    struct mbuf *, int);
extern struct tdb *gettdbbysrc(union sockaddr_union *, struct ipsec_policy *,
    struct mbuf *, int);
d632 1
a632 1
    u_int32_t *);
d647 3
a649 2
extern struct ipsec_policy *ipsec_add_policy(struct sockaddr_encap *,
    struct sockaddr_encap *, union sockaddr_union *, int, int);
d664 5
@


1.118
log
@Pass the interface (if any) to ipip_input(), so it can be used in
BPF. Closes PR 2000.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.117 2001/07/05 08:42:57 angelos Exp $	*/
d531 2
a532 2
extern void ipe4_input __P((struct mbuf *, ...));
extern void ipip_input __P((struct mbuf *, int, struct ifnet *));
d535 1
a535 1
extern void ip4_input __P((struct mbuf *, ...));
d539 1
a539 1
extern int ip4_input6 __P((struct mbuf **, int *, int));
d545 1
a545 1
extern void etherip_input __P((struct mbuf *, ...));
d559 3
a561 3
extern void ah4_input __P((struct mbuf *, ...));
extern int ah4_input_cb __P((struct mbuf *, ...));
extern void *ah4_ctlinput __P((int, struct sockaddr *, void *));
d565 2
a566 2
extern int ah6_input __P((struct mbuf **, int *, int));
extern int ah6_input_cb __P((struct mbuf *, int, int));
d580 3
a582 3
extern void esp4_input __P((struct mbuf *, ...));
extern int esp4_input_cb __P((struct mbuf *, ...));
extern void *esp4_ctlinput __P((int, struct sockaddr *, void *));
d586 2
a587 2
extern int esp6_input __P((struct mbuf **, int *, int));
extern int esp6_input_cb __P((struct mbuf *, int, int));
d601 2
a602 2
extern void ipcomp4_input __P((struct mbuf *, ...));
extern int ipcomp4_input_cb __P((struct mbuf *, ...));
d606 2
a607 2
extern int ipcomp6_input __P((struct mbuf **, int *, int));
extern int ipcomp6_input_cb __P((struct mbuf *, int, int));
d611 8
a618 8
extern int tcp_signature_tdb_attach __P((void));
extern int tcp_signature_tdb_init __P((struct tdb *, struct xformsw *,
    struct ipsecinit *));
extern int tcp_signature_tdb_zeroize __P((struct tdb *));
extern int tcp_signature_tdb_input __P((struct mbuf *, struct tdb *, int,
    int));
extern int tcp_signature_tdb_output __P((struct mbuf *, struct tdb *,
    struct mbuf **, int, int));
@


1.118.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.118 2001/08/19 06:31:56 angelos Exp $	*/
a170 1
	struct inpcb                    *ipa_pcb;
a172 1
	TAILQ_ENTRY(ipsec_acquire)      ipa_inp_next;
a194 2
	int                     ipo_ref_count;
       
d342 1
d345 1
a357 3
	struct sockaddr_encap   tdb_filter; /* What traffic is acceptable */
	struct sockaddr_encap   tdb_filtermask; /* And the mask */

d388 12
a438 12
struct xformsw {
	u_short	xf_type;		/* Unique ID of xform */
	u_short	xf_flags;		/* flags (see below) */
	char	*xf_name;		/* human-readable name */
	int	(*xf_attach)(void);	/* called at config time */
	int	(*xf_init)(struct tdb *, struct xformsw *, struct ipsecinit *);
	int	(*xf_zeroize)(struct tdb *); /* termination */
	int	(*xf_input)(struct mbuf *, struct tdb *, int, int); /* input */
	int	(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **,
	    int, int);        /* output */
};

d516 4
a519 6
extern struct tdb *gettdbbyaddr(union sockaddr_union *, u_int8_t,
    struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
    struct mbuf *, int, struct sockaddr_encap *, struct sockaddr_encap *);
extern struct tdb *gettdbbysrc(union sockaddr_union *, u_int8_t,
    struct ipsec_ref *, struct ipsec_ref *, struct mbuf *, int,
    struct sockaddr_encap *, struct sockaddr_encap *);
d531 2
a532 2
extern void ipe4_input(struct mbuf *, ...);
extern void ipip_input(struct mbuf *, int, struct ifnet *);
d535 1
a535 1
extern void ip4_input(struct mbuf *, ...);
d539 1
a539 1
extern int ip4_input6(struct mbuf **, int *, int);
d545 1
a545 1
extern void etherip_input(struct mbuf *, ...);
d559 3
a561 3
extern void ah4_input(struct mbuf *, ...);
extern int ah4_input_cb(struct mbuf *, ...);
extern void *ah4_ctlinput(int, struct sockaddr *, void *);
d565 2
a566 2
extern int ah6_input(struct mbuf **, int *, int);
extern int ah6_input_cb(struct mbuf *, int, int);
d580 3
a582 3
extern void esp4_input(struct mbuf *, ...);
extern int esp4_input_cb(struct mbuf *, ...);
extern void *esp4_ctlinput(int, struct sockaddr *, void *);
d586 2
a587 2
extern int esp6_input(struct mbuf **, int *, int);
extern int esp6_input_cb(struct mbuf *, int, int);
d601 2
a602 2
extern void ipcomp4_input(struct mbuf *, ...);
extern int ipcomp4_input_cb(struct mbuf *, ...);
d606 2
a607 2
extern int ipcomp6_input(struct mbuf **, int *, int);
extern int ipcomp6_input_cb(struct mbuf *, int, int);
d611 8
a618 8
extern int tcp_signature_tdb_attach(void);
extern int tcp_signature_tdb_init(struct tdb *, struct xformsw *,
    struct ipsecinit *);
extern int tcp_signature_tdb_zeroize(struct tdb *);
extern int tcp_signature_tdb_input(struct mbuf *, struct tdb *, int,
    int);
extern int tcp_signature_tdb_output(struct mbuf *, struct tdb *,
    struct mbuf **, int, int);
d625 1
a625 1
    u_int32_t *, int);
d640 2
a641 3
extern struct ipsec_policy *ipsec_add_policy(struct inpcb *, int, int);
extern void ipsec_update_policy(struct inpcb *, struct ipsec_policy *,
    int, int);
a655 5
extern int ipsp_aux_match(struct ipsec_ref *, struct ipsec_ref *,
    struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
    struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
    struct sockaddr_encap *, struct sockaddr_encap *,
    struct sockaddr_encap *, struct sockaddr_encap *);
@


1.118.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.118.4.1 2002/06/11 03:31:36 art Exp $	*/
d198 1
a198 1

@


1.118.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d662 1
a662 1
extern int ipsp_print_tdb(struct tdb *, char *, size_t);
@


1.117
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.116 2001/07/05 08:31:48 jjbg Exp $	*/
d532 1
a532 1
extern void ipip_input __P((struct mbuf *, int));
@


1.116
log
@IPComp itself (include files). angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.115 2001/06/27 04:44:03 angelos Exp $	*/
d96 1
a96 1
#define IPSEC_DEFAULT_DEF_COMP			"deflate"
d405 1
a405 1
#define XF_IPCOMP	6	/* IPCOMP */
d410 1
a410 1
#define XFT_COMP	0x1000
@


1.115
log
@When determining whether there's a pending acquire wrt a policy, look
at the acquires associated with the policy only.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.114 2001/06/27 04:39:11 angelos Exp $	*/
d76 6
d96 1
d226 1
d274 1
d385 1
d405 1
d410 1
d467 1
d479 2
d488 2
a489 1
		       ((x)->tdb_authalgxform ? NOTIFY_SATYPE_AUTH : 0))
d588 20
@


1.114
log
@Also link acquire state to the relevant IPsec policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.113 2001/06/27 01:34:07 angelos Exp $	*/
d607 2
a608 1
extern struct ipsec_acquire *ipsp_pending_acquire(union sockaddr_union *);
@


1.113
log
@Don't cache packets that hit policies -- we'll do that at the PCB for
local packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.112 2001/06/26 18:56:30 angelos Exp $	*/
d163 2
d195 1
@


1.112
log
@Use pool(9) for IPsec policy structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.111 2001/06/26 18:34:40 angelos Exp $	*/
a161 1
	struct mbuf			*ipa_packet;
d495 1
a495 1
    union sockaddr_union *, u_int8_t, int *, u_int32_t);
a604 1
extern struct ipsec_acquire *ipsec_get_acquire(u_int32_t);
a605 1
extern void ipsp_clear_acquire(struct tdb *);
d615 1
@


1.111
log
@Keep the PFKEY sequence number at the TDB, plus a little bit of KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.110 2001/06/26 03:52:42 angelos Exp $	*/
d440 2
@


1.110
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.109 2001/06/25 23:18:08 beck Exp $	*/
d290 1
d494 1
a494 1
			     union sockaddr_union *, u_int8_t, int *);
d497 1
a497 1
				struct mbuf *, int);
d499 1
a499 1
			       struct mbuf *, int);
d524 1
a524 1
			  int, int);
d573 1
a573 1
				       struct ipsecinit *));
d576 1
a576 1
					int));
d578 1
a578 1
					 struct mbuf **, int, int));
d585 1
a585 1
                               u_int32_t *);
d593 1
a593 1
                                   struct tdb *, struct inpcb *);
d597 1
a597 1
				 struct m_tag *);
d599 1
a599 2
			   union sockaddr_union *, struct sockaddr_encap *,
			   struct mbuf *);
d601 1
a601 2
					     struct sockaddr_encap *,
					     union sockaddr_union *, int, int);
@


1.109
log
@damn greeks desperate for commits...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.108 2001/06/25 23:08:24 angelos Exp $	*/
d616 1
@


1.108
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.107 2001/06/25 05:11:59 angelos Exp $	*/
d430 1
a430 1
#define	spltdb	plsoftnet
@


1.107
log
@Copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.106 2001/06/24 21:52:28 mickey Exp $	*/
d50 4
a53 5
union sockaddr_union
{
    struct sockaddr     sa;
    struct sockaddr_in  sin;
    struct sockaddr_in6 sin6;
d57 7
a63 7
#define MD5HMAC96_KEYSIZE       16
#define SHA1HMAC96_KEYSIZE      20
#define RIPEMD160HMAC96_KEYSIZE 20

#define AH_HMAC_HASHLEN		12	/* 96 bits of authenticator */
#define AH_HMAC_RPLENGTH        4	/* 32 bits of replay counter */
#define AH_HMAC_INITIAL_RPL	1	/* Replay counter initial value */
d66 4
a69 4
#define AH_MD5_ALEN		16
#define AH_SHA1_ALEN		20
#define AH_RMD160_ALEN		20
#define AH_ALEN_MAX		20 	/* Keep updated */
d72 3
a74 3
#define SPI_LOCAL_USE		0
#define SPI_RESERVED_MIN	1
#define SPI_RESERVED_MAX	255
d77 58
a134 62
#define IPSEC_DEFAULT_EMBRYONIC_SA_TIMEOUT	60	/* 1 minute */
#define IPSEC_DEFAULT_PFS                       1
#define IPSEC_DEFAULT_SOFT_ALLOCATIONS          0
#define IPSEC_DEFAULT_EXP_ALLOCATIONS           0
#define IPSEC_DEFAULT_SOFT_BYTES                0
#define IPSEC_DEFAULT_EXP_BYTES                 0
#define IPSEC_DEFAULT_SOFT_TIMEOUT              80000
#define IPSEC_DEFAULT_EXP_TIMEOUT               86400
#define IPSEC_DEFAULT_SOFT_FIRST_USE            3600
#define IPSEC_DEFAULT_EXP_FIRST_USE             7200
#define IPSEC_DEFAULT_DEF_ENC                   "aes"
#define IPSEC_DEFAULT_DEF_AUTH                   "hmac-sha1"
#define IPSEC_DEFAULT_EXPIRE_ACQUIRE            30

struct sockaddr_encap
{
    u_int8_t	sen_len;		/* length */
    u_int8_t	sen_family;		/* PF_KEY */
    u_int16_t	sen_type;		/* see SENT_* */
    union
    {
	struct				/* SENT_IP4 */
	{
	    u_int8_t Direction;
	    struct in_addr Src;
	    struct in_addr Dst;
	    u_int8_t Proto;
	    u_int16_t Sport;
	    u_int16_t Dport;
	} Sip4;

	struct				/* SENT_IP6 */
	{
	    u_int8_t Direction;
	    struct in6_addr Src;
	    struct in6_addr Dst;
	    u_int8_t Proto;
	    u_int16_t Sport;
	    u_int16_t Dport;
	} Sip6;

	struct ipsec_policy *PolicyHead;  /* SENT_IPSP */
    } Sen;
};

#define IPSP_DIRECTION_IN     0x1
#define IPSP_DIRECTION_OUT    0x2

#define sen_data	  Sen.Data
#define sen_ip_src	  Sen.Sip4.Src
#define sen_ip_dst	  Sen.Sip4.Dst
#define sen_proto	  Sen.Sip4.Proto
#define sen_sport	  Sen.Sip4.Sport
#define sen_dport	  Sen.Sip4.Dport
#define sen_direction     Sen.Sip4.Direction
#define sen_ip6_src	  Sen.Sip6.Src
#define sen_ip6_dst	  Sen.Sip6.Dst
#define sen_ip6_proto	  Sen.Sip6.Proto
#define sen_ip6_sport	  Sen.Sip6.Sport
#define sen_ip6_dport	  Sen.Sip6.Dport
#define sen_ip6_direction Sen.Sip6.Direction
#define sen_ipsp          Sen.PolicyHead
d144 64
a207 67
#define SENT_IP4	0x0001		/* data is two struct in_addr */
#define SENT_IPSP	0x0002		/* data as in IP4/6 plus SPI */
#define SENT_IP6        0x0004

#define SENT_LEN        sizeof(struct sockaddr_encap)

struct ipsec_ref
{
    u_int16_t ref_type;		/* Subtype of data */
    int16_t   ref_len;		/* Length of data following */
    int       ref_count;	/* Reference count */
    int       ref_malloctype;	/* malloc(9) type, for freeing purposes */
};

struct ipsec_acquire
{
    union sockaddr_union       ipa_addr;
    u_int32_t                  ipa_seq;
    struct sockaddr_encap      ipa_info;
    struct sockaddr_encap      ipa_mask;
    struct mbuf               *ipa_packet;
    struct timeout	       ipa_timeout;
    TAILQ_ENTRY(ipsec_acquire) ipa_next;
};

struct ipsec_policy
{
    struct sockaddr_encap ipo_addr;
    struct sockaddr_encap ipo_mask;

    union sockaddr_union ipo_src;   /* Local address to use */
    union sockaddr_union ipo_dst;   /* Remote gateway -- if it's zeroed:
				     * - on output, we try to contact the
				     * remote host directly (if needed).
				     * - on input, we accept on if the
				     * inner source is the same as the
				     * outer source address, or if transport
				     * mode was used.
				     */

    u_int64_t            ipo_last_searched; /* Timestamp of last lookup */

    u_int8_t             ipo_flags; /* See IPSP_POLICY_* definitions */
    u_int8_t             ipo_type;  /* USE/ACQUIRE/... */
    u_int8_t             ipo_sproto;/* ESP, AH; if zero we use system dflts */

    struct tdb          *ipo_tdb;   /* Cached entry */

    struct ipsec_ref    *ipo_srcid;
    struct ipsec_ref    *ipo_dstid;
    struct ipsec_ref    *ipo_local_cred;
    struct ipsec_ref    *ipo_local_auth;

    TAILQ_ENTRY(ipsec_policy) ipo_tdb_next; /* List of policies on TDB */
    TAILQ_ENTRY(ipsec_policy) ipo_list; /* List of all policy entries */
};

#define IPSP_POLICY_NONE    0x0000  /* No flags set */
#define IPSP_POLICY_SOCKET  0x0001  /* Socket-attached policy */
#define IPSP_POLICY_STATIC  0x0002  /* Static policy */

#define IPSP_IPSEC_USE      0 /* Use if existing, don't bother establishing */
#define IPSP_IPSEC_ACQUIRE  1 /* Try to acquire in parallel but let packet */
#define IPSP_IPSEC_REQUIRE  2 /* Require SA */
#define IPSP_PERMIT         3 /* Permit traffic through */
#define IPSP_DENY           4 /* Deny traffic */
#define IPSP_IPSEC_DONTACQ  5 /* Require, but don't acquire */
d210 7
a216 7
#define NOTIFY_SOFT_EXPIRE      0       /* Soft expiration of SA */
#define NOTIFY_HARD_EXPIRE      1       /* Hard expiration of SA */
#define NOTIFY_REQUEST_SA       2       /* Establish an SA */

#define NOTIFY_SATYPE_CONF      1       /* SA should do encryption */
#define NOTIFY_SATYPE_AUTH      2       /* SA should do authentication */
#define NOTIFY_SATYPE_TUNNEL    4       /* SA should use tunneling */
d219 3
a221 3
#define IPSP_AUTH_NONE          0
#define IPSP_AUTH_PASSPHRASE    1
#define IPSP_AUTH_RSA           2
d224 3
a226 3
#define IPSP_CRED_NONE          0
#define IPSP_CRED_KEYNOTE       1
#define IPSP_CRED_X509          2
d229 5
a233 5
#define IPSP_IDENTITY_NONE       0
#define IPSP_IDENTITY_PREFIX     1
#define IPSP_IDENTITY_FQDN       2
#define IPSP_IDENTITY_USERFQDN   3
#define IPSP_IDENTITY_CONNECTION 4
d242 2
a243 107
    struct rtentry *re_rt;
    struct sockaddr_encap re_dst;
};

struct tdb				/* tunnel descriptor block */
{
    /*
     * Each TDB is on three hash tables: one keyed on dst/spi/sproto,
     * one keyed on dst/sproto, and one keyed on src/sproto. The first
     * is used for finding a specific TDB, the second for finding TDBs
     * TDBs for outgoing policy matching, and the third for incoming
     * policy matching. The following three fields maintain the hash
     * queues in those three tables.
     */
    struct tdb	     *tdb_hnext;   /* dst/spi/sproto table */
    struct tdb       *tdb_anext;   /* dst/sproto table */
    struct tdb       *tdb_snext;   /* src/sproto table */
    struct tdb       *tdb_inext;
    struct tdb       *tdb_onext;

    struct xformsw   *tdb_xform;	/* Transformation to use */
    struct enc_xform *tdb_encalgxform;  /* Encryption algorithm xform */
    struct auth_hash *tdb_authalgxform; /* Authentication algorithm xform */

#define TDBF_UNIQUE	      0x00001	/* This should not be used by others */
#define TDBF_TIMER            0x00002	/* Absolute expiration timer in use */
#define TDBF_BYTES            0x00004	/* Check the byte counters */
#define TDBF_ALLOCATIONS      0x00008	/* Check the flows counters */
#define TDBF_INVALID          0x00010	/* This SPI is not valid yet/anymore */
#define TDBF_FIRSTUSE         0x00020	/* Expire after first use */
#define TDBF_HALFIV           0x00040	/* Use half-length IV (ESP old only) */
#define TDBF_SOFT_TIMER       0x00080	/* Soft expiration */
#define TDBF_SOFT_BYTES       0x00100	/* Soft expiration */
#define TDBF_SOFT_ALLOCATIONS 0x00200	/* Soft expiration */
#define TDBF_SOFT_FIRSTUSE    0x00400	/* Soft expiration */
#define TDBF_PFS              0x00800	/* Ask for PFS from Key Mgmt. */
#define TDBF_TUNNELING        0x01000	/* Force IP-IP encapsulation */
#define TDBF_NOREPLAY         0x02000	/* No replay counter present */
#define TDBF_RANDOMPADDING    0x04000	/* Random data in the ESP padding */
#define TDBF_SKIPCRYPTO       0x08000	/* Skip actual crypto processing */
#define TDBF_USEDTUNNEL       0x10000	/* Appended a tunnel header in past */

    u_int32_t	      tdb_flags;	/* Flags related to this TDB */

    struct timeout    tdb_timer_tmo;
    struct timeout    tdb_first_tmo;
    struct timeout    tdb_stimer_tmo;
    struct timeout    tdb_sfirst_tmo;

    u_int32_t         tdb_exp_allocations;  /* Expire after so many flows */
    u_int32_t         tdb_soft_allocations; /* Expiration warning */
    u_int32_t         tdb_cur_allocations;  /* Total number of allocations */

    u_int64_t         tdb_exp_bytes;	/* Expire after so many bytes passed */
    u_int64_t         tdb_soft_bytes;	/* Expiration warning */
    u_int64_t         tdb_cur_bytes;	/* Current count of bytes */

    u_int64_t         tdb_exp_timeout;	/* When does the SPI expire */
    u_int64_t         tdb_soft_timeout;	/* Send a soft-expire warning */
    u_int64_t         tdb_established;	/* When was the SPI established */

    u_int64_t	      tdb_first_use;	  /* When was it first used */
    u_int64_t         tdb_soft_first_use; /* Soft warning */
    u_int64_t         tdb_exp_first_use;  /* Expire if tdb_first_use +
					   * tdb_exp_first_use <= curtime */

    u_int64_t         tdb_last_used;    /* When was this SA last used */
    u_int64_t         tdb_last_marked;  /* Last SKIPCRYPTO status change */

    u_int64_t         tdb_cryptoid;     /* Crypto session ID */

    u_int32_t	      tdb_spi;    	/* SPI */
    u_int16_t         tdb_amxkeylen;    /* Raw authentication key length */
    u_int16_t         tdb_emxkeylen;    /* Raw encryption key length */
    u_int16_t         tdb_ivlen;        /* IV length */
    u_int8_t	      tdb_sproto;	/* IPsec protocol */
    u_int8_t          tdb_wnd;          /* Replay window */
    u_int8_t          tdb_satype;       /* SA type (RFC2367, PF_KEY) */

    union sockaddr_union tdb_dst;	/* Destination address for this SA */
    union sockaddr_union tdb_src;	/* Source address for this SA */
    union sockaddr_union tdb_proxy;

    u_int8_t         *tdb_amxkey;       /* Raw authentication key */
    u_int8_t         *tdb_emxkey;       /* Raw encryption key */

    u_int32_t         tdb_rpl;	        /* Replay counter */
    u_int32_t         tdb_bitmap;       /* Used for replay sliding window */
    u_int32_t         tdb_initial;	/* Initial replay value */

    u_int32_t         tdb_epoch;	/* Used by the kernfs interface */

    u_int8_t          tdb_iv[4];        /* Used for HALF-IV ESP */

    struct ipsec_ref *tdb_local_cred;
    struct ipsec_ref *tdb_remote_cred;
    struct ipsec_ref *tdb_srcid;	/* Source ID for this SA */
    struct ipsec_ref *tdb_dstid;	/* Destination ID for this SA */
    struct ipsec_ref *tdb_local_auth;	/* Local authentication material */
    struct ipsec_ref *tdb_remote_auth;	/* Remote authentication material */

    u_int32_t	      tdb_mtu;		/* MTU at this point in the chain */
    u_int64_t	      tdb_mtutimeout;	/* When to ignore this entry */

    TAILQ_HEAD(tdb_inp_head_in, inpcb) tdb_inp_in;
    TAILQ_HEAD(tdb_inp_head_out, inpcb) tdb_inp_out;
    TAILQ_HEAD(tdb_policy_head, ipsec_policy) tdb_policy_head;
d246 109
a354 5
struct tdb_ident
{
    u_int32_t spi;
    union sockaddr_union dst;
    u_int8_t proto;
d358 27
a384 28
    u_int32_t			tc_spi;
    union sockaddr_union	tc_dst;
    u_int8_t			tc_proto;
    int                         tc_protoff;
    int                         tc_skip;
    caddr_t                     tc_ptr;
};

struct ipsecinit
{
    u_int8_t       *ii_enckey;
    u_int8_t       *ii_authkey;
    u_int16_t       ii_enckeylen;
    u_int16_t       ii_authkeylen;
    u_int8_t        ii_encalg;
    u_int8_t        ii_authalg;
};

struct xformsw
{
    u_short		xf_type;	/* Unique ID of xform */
    u_short		xf_flags;	/* flags (see below) */
    char		*xf_name;	/* human-readable name */
    int		(*xf_attach)(void);	/* called at config time */
    int		(*xf_init)(struct tdb *, struct xformsw *, struct ipsecinit *);
    int		(*xf_zeroize)(struct tdb *); /* termination */
    int         (*xf_input)(struct mbuf *, struct tdb *, int, int); /* input */
    int		(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **, int, int);        /* output */
d388 4
a391 4
#define XF_IP4		1	/* IP inside IP */
#define XF_AH		2	/* AH */
#define XF_ESP		3	/* ESP */
#define XF_TCPSIGNATURE	5	/* TCP MD5 Signature option, RFC 2358 */
d394 2
a395 2
#define XFT_AUTH	0x0001
#define XFT_CONF	0x0100
d397 2
a398 2
#define IPSEC_ZEROES_SIZE	256	/* Larger than an IP6 extension hdr. */
#define IPSEC_KERNFS_BUFSIZE    4096
d404 3
a406 3
    register u_int32_t u, l;
    u = q >> 32;
    l = (u_int32_t) q;
d408 1
a408 1
    return htonl(u) | ((u_int64_t)htonl(l) << 32);
d411 1
a411 1
#define ntohq(_x) htonq(_x)
d415 2
a416 2
#define htonq(_x) (_x)
#define ntohq(_x) htonq(_x)
d419 1
a419 1
#error  "Please fix <machine/endian.h>"
d430 1
a430 1
#define spltdb	splsoftnet
d467 1
a467 1
#define TDB_ATTRIB(x) (((x)->tdb_encalgxform ? NOTIFY_SATYPE_CONF : 0)| \
d472 1
a472 1
#define SPI_CHAIN_ATTRIB(have, TDB_DIR, TDBP) do {\
d479 4
a482 4
	                break; \
                (have) |= TDB_ATTRIB(tmptdb); \
                tmptdb = tmptdb->TDB_DIR; \
        } \
d593 2
@


1.106
log
@use new timeouts for spd expirations (hmm cvs did not pick up the file); ho@@ ok
@
text
@d1 1
a1 2
/*	$OpenBSD: ip_ipsp.h,v 1.105 2001/06/24 18:22:47 provos Exp $	*/

d22 1
d24 1
a24 1
 * Permission to use, copy, and modify this software without fee
@


1.105
log
@path mtu discovery for ipsec.  on receiving a need fragment icmp match
against active tdb and store the ipsec header size corrected mtu
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.103 2001/06/08 19:40:09 angelos Exp $	*/
a165 1
    u_int64_t                  ipa_expire;
d170 1
a611 1
extern void ipsp_acquire_expirations(void *);
d614 1
a614 1
extern void ipsp_delete_acquire(struct ipsec_acquire *);
@


1.104
log
@remove whitespace
@
text
@d290 1
d351 3
d550 1
d571 1
d623 2
@


1.103
log
@IPSP_POLICY_STATIC flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.102 2001/06/07 16:19:47 angelos Exp $	*/
d280 1
a280 1
#define TDBF_HALFIV           0x00040   /* Use half-length IV (ESP old only) */
d287 3
a289 3
#define TDBF_NOREPLAY         0x02000   /* No replay counter present */
#define TDBF_RANDOMPADDING    0x04000   /* Random data in the ESP padding */
#define TDBF_SKIPCRYPTO       0x08000   /* Skip actual crypto processing */
d291 1
a291 1
    u_int32_t	      tdb_flags;  	/* Flags related to this TDB */
d302 1
a302 1
    u_int64_t         tdb_exp_bytes;    /* Expire after so many bytes passed */
d345 4
a348 4
    struct ipsec_ref *tdb_srcid;        /* Source ID for this SA */
    struct ipsec_ref *tdb_dstid;        /* Destination ID for this SA */
    struct ipsec_ref *tdb_local_auth;   /* Local authentication material */
    struct ipsec_ref *tdb_remote_auth; /* Remote authentication material */
@


1.102
log
@Simplify SPD logic (and correct some input cases).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.101 2001/06/01 07:56:46 angelos Exp $	*/
d208 1
@


1.101
log
@ipsp_parse_headers() goes down a list of IPv4/IPv6/AH/ESP headers and
creates a tag for each of the ESP/AH headers. This will be used by
IPsec-aware NIC device drivers that need to notify IPsec that crypto
processing has already been done.

There is an excessive amount of m_copydata() calls used by this
routine, but there's no way around it that I can think of.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.100 2001/06/01 00:09:24 angelos Exp $	*/
a603 2
extern int ipsp_match_policy(struct tdb *, struct ipsec_policy *,
			     struct mbuf *, int);
d615 1
@


1.100
log
@The IPsec-aware NIC cards don't pass the ICV for later verification
by the stack; that means, if we have a tag it means the ICV was
successfully verified and we don't need to do anything else. As well,
we don't need any other status information from the NIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.99 2001/05/31 23:45:50 angelos Exp $	*/
d616 1
@


1.99
log
@Structure for NIC IPsec processing status reports.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.98 2001/05/30 16:43:12 angelos Exp $	*/
a90 10

/* Status for IPsec processing done on IPsec-aware NICs */
struct ipsec_nic_crypto
{
  u_int8_t	nic_status;	/* Bitfield */
};

#define	IPSEC_NIC_STATUS_OK		0
#define	IPSEC_NIC_HASH_FAILED		0x0001
#define	IPSEC_NIC_ BAD_ESP_FORMAT	0x0002
@


1.98
log
@IPSP_IDENTITY_MBOX -> IPSP_IDENTITY_FQDN, and print type of creds/auth
in kernfs
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.97 2001/05/30 12:24:39 angelos Exp $	*/
d91 10
@


1.97
log
@Forgot to update ipsec_output_done()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.96 2001/05/30 12:20:20 angelos Exp $	*/
d239 1
a239 1
#define IPSP_IDENTITY_MBOX       3
@


1.96
log
@With the tags, we don't need to abuse the IPsec API to do socket keying.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.95 2001/05/30 11:14:42 angelos Exp $	*/
d593 1
a593 1
extern int ipsp_process_done(struct mbuf *, struct tdb *, struct tdb *);
@


1.95
log
@Keep track of remote authentication material (like public key) as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.94 2001/05/30 10:55:06 angelos Exp $	*/
a364 3
    u_int32_t			tc_spi2;
    union sockaddr_union	tc_dst2;
    u_int8_t			tc_proto2;
d389 1
a389 1
    int		(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **, int, int, struct tdb *);        /* output */
d514 1
a514 2
extern int ipip_output(struct mbuf *, struct tdb *, struct mbuf **, int, int,
		       struct tdb *);
d535 1
a535 2
extern int ah_output(struct mbuf *, struct tdb *, struct mbuf **, int, int,
		     struct tdb *);
d556 1
a556 2
extern int esp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int,
		      struct tdb *);
d580 1
a580 2
					 struct mbuf **, int, int,
					 struct tdb *));
d592 1
a592 2
extern int ipsp_process_packet(struct mbuf *, struct tdb *, int, int,
			       struct tdb *);
@


1.94
log
@Fields to store local auth information in policy and TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.93 2001/05/29 01:12:27 angelos Exp $	*/
d235 7
d347 1
@


1.93
log
@Fields on TDB for last used and last SKIPCRYPTO status change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.92 2001/05/29 01:03:01 angelos Exp $	*/
d200 1
d225 10
d339 1
@


1.92
log
@Add ipsp_skipcrypto_{mark,unmark}()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.91 2001/05/27 05:17:07 angelos Exp $	*/
d295 4
@


1.91
log
@Remove ipsp_copy_ident() prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.90 2001/05/27 03:48:15 angelos Exp $	*/
d598 2
@


1.90
log
@Change prototype of ipsp_common_input_cb() to also accept a packet tag
as the last argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.89 2001/05/21 06:01:34 angelos Exp $	*/
a595 1
extern void *ipsp_copy_ident(void *);
@


1.89
log
@SKIPCRYPTO flag
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.88 2001/05/21 03:27:48 angelos Exp $	*/
d330 2
a331 1
struct tdb_ident {
d580 2
a581 1
extern int ipsec_common_input_cb(struct mbuf *, struct tdb *, int, int);
@


1.88
log
@Cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.87 2001/05/21 03:23:36 angelos Exp $	*/
d270 1
@


1.87
log
@Use int16_t for the type and length of ipsec_ref objects.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.86 2001/05/21 03:02:19 angelos Exp $	*/
d43 1
a43 3
/*
 * IPSP global definitions.
 */
@


1.86
log
@Use a reference-counted structure for IPsec IDs and credentials, so we
can cheaply keep copies of them at the PCB. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.85 2001/05/05 00:31:20 angelos Exp $	*/
d159 4
a162 4
    int ref_type;		/* Subtype of data */
    int ref_len;		/* Length of data following */
    int ref_count;		/* Reference count */
    int ref_malloctype;		/* malloc(9) type, for free'ing purposes */
@


1.85
log
@Check that SAs also match on the credentials and the IDs. This means
that flows with different source/destination ID requirements will
cause different SAs to be established by IKE (or whatever other
protocol). Also, use the new data types for allocated memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.84 2001/05/01 18:31:35 fgsch Exp $	*/
d157 8
d199 3
a201 10
    u_int16_t            ipo_srcid_len;
    u_int16_t            ipo_dstid_len;
    u_int16_t            ipo_local_cred_len;
    u_int16_t            ipo_srcid_type;
    u_int16_t            ipo_dstid_type;
    u_int16_t            ipo_local_cred_type;

    u_int8_t            *ipo_srcid;
    u_int8_t            *ipo_dstid;
    u_int8_t            *ipo_local_cred;
a301 2
    u_int16_t         tdb_local_cred_len; /* size of tdb_local_cred */
    u_int16_t         tdb_remote_cred_len; /* size of tdb_remote_cred */
a304 2
    u_int8_t          tdb_local_cred_type;/* type of tdb_local_cred */
    u_int8_t          tdb_remote_cred_type;/* type of tdb_remote_cred */
a309 2
    u_int8_t         *tdb_srcid;        /* Source ID for this SA */
    u_int8_t         *tdb_dstid;        /* Destination ID for this SA */
a317 4
    u_int16_t         tdb_srcid_len;
    u_int16_t         tdb_dstid_len;
    u_int16_t         tdb_srcid_type;
    u_int16_t         tdb_dstid_type;
d321 4
a324 2
    caddr_t           tdb_local_cred;
    caddr_t           tdb_remote_cred;
d597 1
@


1.84
log
@Fix tcp_signature_tdb_input decl; kernel compiles again if TCP_SIGNATURE
option is used. Note that this does not work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.83 2001/04/14 00:30:59 angelos Exp $	*/
d193 1
d196 1
d200 1
d207 1
d301 2
a302 2
    u_int16_t         tdb_src_cred_len; /* size of tdb_src_credentials */
    u_int16_t         tdb_dst_cred_len; /* size of tdb_dst_credentials */
d306 2
a307 2
    u_int8_t          tdb_src_cred_type;/* type of tdb_src_credentials */
    u_int8_t          tdb_dst_cred_type;/* type of tdb_dst_credentials */
d330 2
a331 2
    caddr_t           tdb_src_credentials;
    caddr_t           tdb_dst_credentials;
d486 1
a486 1
extern struct tdb *gettdbbyaddr(union sockaddr_union *, u_int8_t,
d488 1
a488 1
extern struct tdb *gettdbbysrc(union sockaddr_union *, u_int8_t,
d603 1
@


1.83
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.82 2001/03/28 20:03:04 angelos Exp $	*/
d565 2
a566 1
					 struct mbuf **, int, int));
@


1.82
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.81 2001/03/27 14:45:22 art Exp $	*/
d344 3
d371 1
a371 1
    int		(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **, int, int);        /* output */
d496 2
a497 1
extern int ipip_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
d518 2
a519 1
extern int ah_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
d540 2
a541 1
extern int esp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
d577 3
a579 2
extern int ipsp_process_packet(struct mbuf *, struct tdb *, int, int);
extern int ipsp_process_done(struct mbuf *, struct tdb *);
@


1.81
log
@Fix a problem with how TDB timeouts were used in pfkeyv2.
When we allocated a tdb we did a timeout_add before a timeout_set.
This was a problem in itself, but it shouldn't hurt too much.
What did hurt was that we did a timeout_set after the timeout_add,
timeout_set marked the timeout as not being on the timeout list and if we
did a timeout_del (or timeout_add) later (before the timeout fired) we
ended up with a chunk of freed memory on the timeout queue or maybe
even dangling pointers (or a circular list).

This should probably cure the timeout queue corruption some people were
seeing lately.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.80 2001/03/15 06:31:00 mickey Exp $	*/
d297 2
a298 1
    u_int16_t         tdb_cred_len;     /* size of tdb_credentials */
d302 2
a303 1
    u_int8_t          tdb_cred_type;    /* type of tdb_credentials */
d326 2
a327 2
    caddr_t           tdb_interface;
    caddr_t           tdb_credentials;
d329 2
a330 1
    TAILQ_HEAD(tdb_inp_head, inpcb) tdb_inp;
d475 1
a475 1
extern void tdb_add_inp(struct tdb *tdb, struct inpcb *inp);
d590 1
@


1.80
log
@convert SA expirations to the new timeouts.
simplifies expirations handling a lot.
tdb_exp_timeout and tdb_soft_timeout are made
consistant throughout the code to be a relative time offsets,
just like first_use timeouts.
tested on singlehost isakmpd setup.
lots of dangling spaces and tabs removed.
angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.79 2001/03/04 20:34:00 angelos Exp $	*/
d482 1
@


1.79
log
@Store peer's credentials in TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.78 2001/02/28 04:16:57 angelos Exp $	*/
d27 1
a27 1
 * modification of this software. 
d49 1
d148 1
a148 1
 * 
d216 1
a216 1
  
d270 4
a273 2
    TAILQ_ENTRY(tdb)  tdb_expnext;	/* Expiration cluster list link */
    TAILQ_ENTRY(tdb)  tdb_explink;	/* Expiration ordered list link */
d276 1
a276 1
    u_int32_t         tdb_soft_allocations; /* Expiration warning */ 
a285 1
    u_int64_t	      tdb_timeout;	/* Next absolute expiration time.  */
d355 1
a355 1
	  
d388 1
a388 1
        
d401 1
a401 1
#endif                                          
a441 2
extern TAILQ_HEAD(expclusterlist_head, tdb) expclusterlist;
extern TAILQ_HEAD(explist_head, tdb) explist;
d481 1
a481 1
extern void tdb_delete(struct tdb *, int);
a482 4
extern void tdb_expiration(struct tdb *, int);
/* Flag values for the last argument of tdb_expiration().  */
#define TDBEXP_EARLY	1	/* The tdb is likely to end up early.  */
#define TDBEXP_TIMEOUT	2	/* Maintain expiration timeout.  */
a483 1
extern void handle_expirations(void *);
@


1.78
log
@Keep the last packet sent or received that matched an SPD entry, and
retransmit if we eventually have an SA setup for that policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.77 2001/02/12 06:57:19 deraadt Exp $	*/
d295 1
d299 2
a300 1
    
d323 1
@


1.77
log
@putting #error into an include file is totally wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.75 2000/12/24 04:18:04 angelos Exp $	*/
d163 1
d575 2
a576 1
			   union sockaddr_union *, struct sockaddr_encap *);
d582 1
d584 1
a584 1
extern int ipsec_delete_policy(struct ipsec_policy *);
d586 2
@


1.76
log
@If IPSEC is defined but not CRYPTO, spit an error; angelos@@ ok
@
text
@a397 3
#ifndef CRYPTO
#error "Must define CRYPTO in kernel config"
#endif
@


1.75
log
@Extra argument in the function to tdb_walk(), indicating last TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.74 2000/10/14 06:23:52 angelos Exp $	*/
d398 3
@


1.74
log
@ASKPOLICY message; used by key management to inquire about policy
triggering an ACQUIRE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.73 2000/10/09 22:20:41 angelos Exp $	*/
d483 1
a483 1
extern int tdb_walk(int (*)(struct tdb *, void *), void *);
@


1.73
log
@AES support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.72 2000/09/20 19:13:17 angelos Exp $	*/
d158 5
a162 2
    union sockaddr_union ipa_addr;
    u_int64_t            ipa_expire;
d574 1
a574 1
			   union sockaddr_union *);
d582 1
@


1.72
log
@Add IDENTITY payloads to flow establishment (and cleanup accordingly)
-- this will address one of itojun's question on how are IDs for IKE
to be determined (need to add support for this to ipsecadm).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.71 2000/09/19 08:38:59 angelos Exp $	*/
d89 1
a89 1
#define IPSEC_DEFAULT_DEF_ENC                   "3des"
@


1.71
log
@SA bundles.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.70 2000/09/19 03:20:59 angelos Exp $	*/
d185 8
@


1.70
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.69 2000/06/18 19:05:49 angelos Exp $	*/
d232 2
@


1.69
log
@Use ip6_sprintf() rather than the home-cooked inet6_ntoa4()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.68 2000/06/18 05:58:46 itojun Exp $	*/
d9 2
a10 2
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
a57 3
#define FLOW_EGRESS             0
#define FLOW_INGRESS            1

d91 1
a99 2
	u_int8_t	Data[16];	/* other stuff mapped here */

d102 1
d105 1
a107 2
	    u_int8_t Proto;
	    u_int8_t Filler[3];
d112 1
d115 1
a117 2
	    u_int8_t Proto;
	    u_int8_t Filler[3];
d120 1
a120 15
	struct				/* SENT_IPSP */
	{
	    struct in_addr Dst;
	    u_int32_t Spi;
	    u_int8_t Sproto;
	    u_int8_t Filler[7];
	} Sipsp;

	struct				/* SENT_IPSP6 */
	{
	    struct in6_addr Dst;
	    u_int32_t Spi;
	    u_int8_t Sproto;
	    u_int8_t Filler[7];
	} Sipsp6;
d124 3
d133 1
d139 2
a140 6
#define sen_ipsp_dst	  Sen.Sipsp.Dst
#define sen_ipsp_spi	  Sen.Sipsp.Spi
#define sen_ipsp_sproto	  Sen.Sipsp.Sproto
#define sen_ipsp6_dst	  Sen.Sipsp6.Dst
#define sen_ipsp6_spi	  Sen.Sipsp6.Spi
#define sen_ipsp6_sproto  Sen.Sipsp6.Sproto
a152 1
#define SENT_IPSP6      0x0008
d154 13
a166 5
/*
 * SENT_HDRLEN is the length of the "header"
 * SENT_*_LEN are the lengths of various forms of sen_data
 * SENT_*_OFF are the offsets in the sen_data array of various fields
 */
d168 15
a182 1
#define SENT_HDRLEN	(2 * sizeof(u_int8_t) + sizeof(u_int16_t))
d184 1
a184 2
#define SENT_IP4_SRCOFF	(0)
#define SENT_IP4_DSTOFF (sizeof (struct in_addr))
d186 3
a188 2
#define SENT_IP6_SRCOFF (0)
#define SENT_IP6_DSTOFF (sizeof (struct in6_addr))
d190 1
a190 4
#define SENT_IP4_LEN	20
#define SENT_IPSP_LEN	20
#define SENT_IP6_LEN    44
#define SENT_IPSP6_LEN  32
d192 8
a218 13
struct flow
{
    struct flow          *flow_next;	/* Next in flow chain */
    struct flow          *flow_prev;	/* Previous in flow chain */
    struct tdb           *flow_sa;	/* Pointer to the SA */
    union sockaddr_union  flow_src;   	/* Source address */
    union sockaddr_union  flow_srcmask; /* Source netmask */
    union sockaddr_union  flow_dst;	/* Destination address */
    union sockaddr_union  flow_dstmask;	/* Destination netmask */
    u_int8_t	          flow_proto;	/* Transport protocol, if applicable */
    u_int8_t	          foo[3];	/* Alignment */
};

d221 11
a231 3
    struct tdb	     *tdb_hnext;  	/* Next in hash chain */
    struct tdb	     *tdb_onext;        /* Next in output */
    struct tdb	     *tdb_inext;        /* Previous in output */
a306 2
    struct flow	     *tdb_flow; 	/* Which outboind flows use this SA */
    struct flow	     *tdb_access;	/* Ingress access control */
a307 3
    struct tdb       *tdb_bind_out;	/* Outgoing SA to use */
    TAILQ_HEAD(tdb_bind_head, tdb) tdb_bind_in;
    TAILQ_ENTRY(tdb)  tdb_bind_in_next;	/* Refering Incoming SAs */
d309 1
d398 1
d400 1
d425 2
a451 1

d459 4
d464 1
a464 1
extern void tdb_delete(struct tdb *, int, int);
a472 12
/* Flow management routines */
extern struct flow *get_flow(void);
extern void put_flow(struct flow *, struct tdb *, int);
extern void delete_flow(struct flow *, struct tdb *, int);
extern struct flow *find_flow(union sockaddr_union *, union sockaddr_union *,
			      union sockaddr_union *, union sockaddr_union *,
			      u_int8_t, struct tdb *, int);
extern struct flow *find_global_flow(union sockaddr_union *,
				     union sockaddr_union *,
				     union sockaddr_union *,
				     union sockaddr_union *, u_int8_t);

d546 1
a546 1
extern caddr_t m_pad(struct mbuf *, int, int);
d557 2
a558 1
extern struct tdb *ipsp_spd_lookup(struct mbuf *, int, int, int *);
d560 9
a568 1
extern int ipsp_acquire_sa(struct tdb *);
@


1.68
log
@IPv6 AH/ESP support, inbound side only.  tested with KAME.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.67 2000/06/06 04:49:29 angelos Exp $	*/
a448 4

#ifdef INET6
extern char *inet6_ntoa4(struct in6_addr);
#endif /* INET6 */
@


1.67
log
@Get rid of tdb_ref, keep indirect pointer to TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.66 2000/06/01 04:24:26 angelos Exp $	*/
d522 1
a522 1
extern int ah6_input_cb __P((struct mbuf *, int));
d542 1
a542 1
extern int esp6_input_cb __P((struct mbuf *, int));
@


1.66
log
@ipsp_acquire_sa()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.65 2000/06/01 04:01:54 angelos Exp $	*/
a273 1
    int32_t           tdb_ref;		/* References */
d317 9
@


1.65
log
@Prototype for ipsp_spd_lookup()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.64 2000/04/19 03:37:36 angelos Exp $	*/
d561 1
@


1.64
log
@tdb_ref should be signed, this avoid a problem with flushing the TDB
table causing repeated allocations of bypass TDBs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.63 2000/03/29 07:09:57 angelos Exp $	*/
d559 1
@


1.63
log
@Conform to crypto framework changes for IVs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.62 2000/03/17 10:25:22 angelos Exp $	*/
d274 1
a274 1
    u_int32_t         tdb_ref;		/* References */
@


1.62
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.61 2000/02/28 23:13:07 deraadt Exp $	*/
d301 2
@


1.61
log
@move crypto code
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.60 2000/01/27 08:09:12 angelos Exp $	*/
a49 6
#include <sys/md5k.h>
#include <crypto/sha1.h>
#include <crypto/rmd160.h>
#include <crypto/blf.h>
#include <crypto/cast.h>
#include <crypto/skipjack.h>
a65 18
/* IV lengths */
#define ESP_DES_IVS		8
#define ESP_3DES_IVS		8
#define ESP_BLF_IVS             8
#define ESP_CAST_IVS            8
#define ESP_SKIPJACK_IVS	8
#define ESP_MAX_IVS		8       /* Keep updated */

/* Block sizes -- it is assumed that they're powers of 2 */
#define ESP_DES_BLKS		8
#define ESP_3DES_BLKS		8
#define ESP_BLF_BLKS            8
#define ESP_CAST_BLKS           8
#define ESP_SKIPJACK_BLKS	8
#define ESP_MAX_BLKS            8       /* Keep updated */

#define HMAC_BLOCK_LEN		64

a69 5
/* HMAC definitions */
#define HMAC_IPAD_VAL           0x36
#define HMAC_OPAD_VAL           0x5C
#define HMAC_BLOCK_LEN          64

d272 1
d274 1
a286 3
    u_int8_t         *tdb_key;          /* Key material (schedules) */
    u_int8_t         *tdb_ictx;         /* Authentication contexts */
    u_int8_t         *tdb_octx;
a291 10
    union
    {
	u_int8_t  Iv[ESP_3DES_IVS];     /* That's enough space */
	u_int32_t Ivl;        	        /* Make sure this is 4 bytes */
	u_int64_t Ivq; 		        /* Make sure this is 8 bytes! */
    }IV;
#define tdb_iv  IV.Iv
#define tdb_ivl IV.Ivl
#define tdb_ivq IV.Ivq

a311 11
union authctx_old {
    MD5_CTX md5ctx;
    SHA1_CTX sha1ctx;
};

union authctx {
    MD5_CTX md5ctx;
    SHA1_CTX sha1ctx;
    RMD160_CTX rmd160ctx;
};

a317 24
struct auth_hash {
    int type;
    char *name;
    u_int16_t keysize;
    u_int16_t hashsize; 
    u_int16_t authsize;
    u_int16_t ctxsize;
    void (*Init)(void *);
    void (*Update)(void *, u_int8_t *, u_int16_t);
    void (*Final)(u_int8_t *, void *);
};

struct enc_xform {
    int type;
    char *name;
    u_int16_t blocksize, ivsize;
    u_int16_t minkey, maxkey;
    u_int32_t ivmask;           /* Or all possible modes, zero iv = 1 */ 
    void (*encrypt)(struct tdb *, u_int8_t *);
    void (*decrypt)(struct tdb *, u_int8_t *);
    void (*setkey)(u_int8_t **, u_int8_t *, int len);
    void (*zerokey)(u_int8_t **);
};

d336 1
a336 1
    struct mbuf 	*(*xf_input)(struct mbuf *, struct tdb *, int, int); /* input */
a390 2
extern u_int8_t hmac_ipad_buffer[64];
extern u_int8_t hmac_opad_buffer[64];
d414 1
d498 4
a501 3
extern int ah_output(struct mbuf *, struct tdb *, struct mbuf **,
			 int, int);
extern struct mbuf *ah_input(struct mbuf *, struct tdb *, int, int);
d503 1
d507 1
d511 2
a512 1
int     ah6_input __P((struct mbuf **, int *, int));
d519 4
a522 3
extern int esp_output(struct mbuf *, struct tdb *, struct mbuf **,
		      int, int);
extern struct mbuf *esp_input(struct mbuf *, struct tdb *, int, int);
d527 1
d531 2
a532 1
int     esp6_input __P((struct mbuf **, int *, int));
d540 2
a541 1
extern struct mbuf *tcp_signature_tdb_input __P((struct mbuf *, struct tdb *, int, int));
d555 3
a557 2
int ipsp_process_packet(struct mbuf *, struct mbuf **, struct tdb *,
			int *, int);
@


1.60
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.59 2000/01/21 03:15:05 angelos Exp $	*/
d51 5
a55 5
#include <netinet/ip_sha1.h>
#include <netinet/ip_rmd160.h>
#include <netinet/ip_blf.h>
#include <netinet/ip_cast.h>
#include <netinet/ip_skipjack.h>
@


1.60.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 5
a55 5
#include <crypto/sha1.h>
#include <crypto/rmd160.h>
#include <crypto/blf.h>
#include <crypto/cast.h>
#include <crypto/skipjack.h>
@


1.60.2.2
log
@Sync with -current
@
text
@d50 6
d72 18
d94 5
a300 1
    u_int64_t         tdb_cryptoid;     /* Crypto session ID */
a301 1
    u_int32_t         tdb_ref;		/* References */
d314 3
d322 10
d352 11
d369 24
d411 1
a411 1
    int         (*xf_input)(struct mbuf *, struct tdb *, int, int); /* input */
d466 2
a490 1

d574 3
a576 4
extern int ah_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
extern int ah_output_cb(void *);
extern int ah_input(struct mbuf *, struct tdb *, int, int);
extern int ah_input_cb(void *);
a577 1
extern int ah_massage_headers(struct mbuf **, int, int, int, int);
a580 1
extern int ah4_input_cb __P((struct mbuf *, ...));
d584 1
a584 2
extern int ah6_input __P((struct mbuf **, int *, int));
extern int ah6_input_cb __P((struct mbuf *, int));
d591 3
a593 4
extern int esp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
extern int esp_output_cb(void *);
extern int esp_input(struct mbuf *, struct tdb *, int, int);
extern int esp_input_cb(void *);
a597 1
extern int esp4_input_cb __P((struct mbuf *, ...));
d601 1
a601 2
extern int esp6_input __P((struct mbuf **, int *, int));
extern int esp6_input_cb __P((struct mbuf *, int));
d609 1
a609 2
extern int tcp_signature_tdb_input __P((struct mbuf *, struct tdb *, int,
					int));
d623 2
a624 3
extern int ipsp_process_packet(struct mbuf *, struct tdb *, int, int);
extern int ipsp_process_done(struct mbuf *, struct tdb *);
extern int ipsec_common_input_cb(struct mbuf *, struct tdb *, int, int);
@


1.60.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.83 2001/04/14 00:30:59 angelos Exp $	*/
d9 2
a10 2
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
d27 1
a27 1
 * modification of this software.
a48 1
#include <sys/timeout.h>
d58 3
d92 1
a92 1
#define IPSEC_DEFAULT_DEF_ENC                   "aes"
a93 1
#define IPSEC_DEFAULT_EXPIRE_ACQUIRE            30
d102 2
a105 1
	    u_int8_t Direction;
a107 1
	    u_int8_t Proto;
d110 2
a115 1
	    u_int8_t Direction;
a117 1
	    u_int8_t Proto;
d120 2
d124 15
a138 1
	struct ipsec_policy *PolicyHead;  /* SENT_IPSP */
a141 3
#define IPSP_DIRECTION_IN     0x1
#define IPSP_DIRECTION_OUT    0x2

a147 1
#define sen_direction     Sen.Sip4.Direction
d153 6
a158 2
#define sen_ip6_direction Sen.Sip6.Direction
#define sen_ipsp          Sen.PolicyHead
d165 1
a165 1
 *
d171 1
d173 5
a177 1
#define SENT_LEN        sizeof(struct sockaddr_encap)
d179 1
a179 10
struct ipsec_acquire
{
    union sockaddr_union       ipa_addr;
    u_int64_t                  ipa_expire;
    u_int32_t                  ipa_seq;
    struct sockaddr_encap      ipa_info;
    struct sockaddr_encap      ipa_mask;
    struct mbuf               *ipa_packet;
    TAILQ_ENTRY(ipsec_acquire) ipa_next;
};
d181 2
a182 4
struct ipsec_policy
{
    struct sockaddr_encap ipo_addr;
    struct sockaddr_encap ipo_mask;
d184 2
a185 22
    union sockaddr_union ipo_src;   /* Local address to use */
    union sockaddr_union ipo_dst;   /* Remote gateway -- if it's zeroed:
				     * - on output, we try to contact the
				     * remote host directly (if needed).
				     * - on input, we accept on if the
				     * inner source is the same as the
				     * outer source address, or if transport
				     * mode was used.
				     */

    u_int64_t            ipo_last_searched; /* Timestamp of last lookup */

    u_int8_t             ipo_flags; /* See IPSP_POLICY_* definitions */
    u_int8_t             ipo_type;  /* USE/ACQUIRE/... */
    u_int8_t             ipo_sproto;/* ESP, AH; if zero we use system dflts */

    struct tdb          *ipo_tdb;   /* Cached entry */

    u_int16_t            ipo_srcid_len;
    u_int16_t            ipo_dstid_len;
    u_int16_t            ipo_srcid_type;
    u_int16_t            ipo_dstid_type;
d187 4
a190 2
    u_int8_t            *ipo_srcid;
    u_int8_t            *ipo_dstid;
a191 14
    TAILQ_ENTRY(ipsec_policy) ipo_tdb_next; /* List of policies on TDB */
    TAILQ_ENTRY(ipsec_policy) ipo_list; /* List of all policy entries */
};

#define IPSP_POLICY_NONE    0x0000  /* No flags set */

#define IPSP_IPSEC_USE      0 /* Use if existing, don't bother establishing */
#define IPSP_IPSEC_ACQUIRE  1 /* Try to acquire in parallel but let packet */
#define IPSP_IPSEC_REQUIRE  2 /* Require SA */
#define IPSP_PERMIT         3 /* Permit traffic through */
#define IPSP_DENY           4 /* Deny traffic */
#define IPSP_IPSEC_DONTACQ  5 /* Require, but don't acquire */

/* Notification types */
d195 1
a195 1

d211 13
d226 3
a228 13
    /*
     * Each TDB is on three hash tables: one keyed on dst/spi/sproto,
     * one keyed on dst/sproto, and one keyed on src/sproto. The first
     * is used for finding a specific TDB, the second for finding TDBs
     * TDBs for outgoing policy matching, and the third for incoming
     * policy matching. The following three fields maintain the hash
     * queues in those three tables.
     */
    struct tdb	     *tdb_hnext;   /* dst/spi/sproto table */
    struct tdb       *tdb_anext;   /* dst/sproto table */
    struct tdb       *tdb_snext;   /* src/sproto table */
    struct tdb       *tdb_inext;
    struct tdb       *tdb_onext;
d252 2
a253 4
    struct timeout    tdb_timer_tmo;
    struct timeout    tdb_first_tmo;
    struct timeout    tdb_stimer_tmo;
    struct timeout    tdb_sfirst_tmo;
d256 1
a256 1
    u_int32_t         tdb_soft_allocations; /* Expiration warning */
d266 1
d274 1
a278 2
    u_int16_t         tdb_src_cred_len; /* size of tdb_src_credentials */
    u_int16_t         tdb_dst_cred_len; /* size of tdb_dst_credentials */
d282 1
a282 3
    u_int8_t          tdb_src_cred_type;/* type of tdb_src_credentials */
    u_int8_t          tdb_dst_cred_type;/* type of tdb_dst_credentials */

d302 8
a309 8
    u_int8_t          tdb_iv[4];        /* Used for HALF-IV ESP */

    caddr_t           tdb_src_credentials;
    caddr_t           tdb_dst_credentials;

    TAILQ_HEAD(tdb_inp_head_in, inpcb) tdb_inp_in;
    TAILQ_HEAD(tdb_inp_head_out, inpcb) tdb_inp_out;
    TAILQ_HEAD(tdb_policy_head, ipsec_policy) tdb_policy_head;
a317 12
struct tdb_crypto {
    u_int32_t			tc_spi;
    union sockaddr_union	tc_dst;
    u_int8_t			tc_proto;
    u_int32_t			tc_spi2;
    union sockaddr_union	tc_dst2;
    u_int8_t			tc_proto2;
    int                         tc_protoff;
    int                         tc_skip;
    caddr_t                     tc_ptr;
};

d327 1
a327 1

d337 1
a337 1
    int		(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **, int, int, struct tdb *);        /* output */
d360 1
a360 1

d373 1
a373 1
#endif
a388 1
extern u_int64_t ipsec_last_added;
a389 1
extern int ipsec_expire_acquire;
d412 2
a413 2
extern TAILQ_HEAD(ipsec_policy_head, ipsec_policy) ipsec_policy_head;
extern TAILQ_HEAD(ipsec_acquire_head, ipsec_acquire) ipsec_acquire_head;
d439 5
d447 1
a447 1
extern void tdb_add_inp(struct tdb *, struct inpcb *, int);
a450 4
extern struct tdb *gettdbbyaddr(union sockaddr_union *, u_int8_t,
				struct mbuf *, int);
extern struct tdb *gettdbbysrc(union sockaddr_union *, u_int8_t,
			       struct mbuf *, int);
d452 1
a452 2
extern void tdb_delete(struct tdb *);
extern struct tdb *tdb_alloc(void);
d454 18
a471 1
extern int tdb_walk(int (*)(struct tdb *, void *, int), void *);
d477 1
a477 2
extern int ipip_output(struct mbuf *, struct tdb *, struct mbuf **, int, int,
		       struct tdb *);
d498 1
a498 2
extern int ah_output(struct mbuf *, struct tdb *, struct mbuf **, int, int,
		     struct tdb *);
d512 1
a512 1
extern int ah6_input_cb __P((struct mbuf *, int, int));
d519 1
a519 2
extern int esp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int,
		      struct tdb *);
d532 1
a532 1
extern int esp6_input_cb __P((struct mbuf *, int, int));
d546 1
a546 1
extern caddr_t m_pad(struct mbuf *, int);
d555 2
a556 5
extern int ipsp_process_packet(struct mbuf *, struct tdb *, int, int,
			       struct tdb *);
extern int ipsp_process_done(struct mbuf *, struct tdb *, struct tdb *);
extern struct tdb *ipsp_spd_lookup(struct mbuf *, int, int, int *, int,
                                   struct tdb *, struct inpcb *);
a557 15
extern int ipsp_acquire_sa(struct ipsec_policy *, union sockaddr_union *,
			   union sockaddr_union *, struct sockaddr_encap *,
			   struct mbuf *);
extern struct ipsec_policy *ipsec_add_policy(struct sockaddr_encap *,
					     struct sockaddr_encap *,
					     union sockaddr_union *, int, int);
extern int ipsp_match_policy(struct tdb *, struct ipsec_policy *,
			     struct mbuf *, int);
extern int ipsec_delete_policy(struct ipsec_policy *);
extern void ipsp_acquire_expirations(void *);
extern struct ipsec_acquire *ipsp_pending_acquire(union sockaddr_union *);
extern struct ipsec_acquire *ipsec_get_acquire(u_int32_t);
extern void ipsp_delete_acquire(struct ipsec_acquire *);
extern void ipsp_clear_acquire(struct tdb *);
extern void *ipsp_copy_ident(void *);
@


1.60.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
a22 1
 * Copyright (c) 2001, Angelos D. Keromytis.
d24 1
a24 1
 * Permission to use, copy, and modify this software with or without fee
d43 3
a45 1
/* IPSP global definitions. */
d52 5
a56 4
union sockaddr_union {
	struct sockaddr		sa;
	struct sockaddr_in	sin;
	struct sockaddr_in6	sin6;
d60 7
a66 7
#define	MD5HMAC96_KEYSIZE	16
#define	SHA1HMAC96_KEYSIZE	20
#define	RIPEMD160HMAC96_KEYSIZE	20

#define	AH_HMAC_HASHLEN		12	/* 96 bits of authenticator */
#define	AH_HMAC_RPLENGTH	4	/* 32 bits of replay counter */
#define	AH_HMAC_INITIAL_RPL	1	/* Replay counter initial value */
d69 4
a72 4
#define	AH_MD5_ALEN		16
#define	AH_SHA1_ALEN		20
#define	AH_RMD160_ALEN		20
#define	AH_ALEN_MAX		20 	/* Keep updated */
d75 3
a77 3
#define	SPI_LOCAL_USE		0
#define	SPI_RESERVED_MIN	1
#define	SPI_RESERVED_MAX	255
d80 13
a92 36
#define	IPSEC_DEFAULT_EMBRYONIC_SA_TIMEOUT	60	/* 1 minute */
#define	IPSEC_DEFAULT_PFS			1
#define	IPSEC_DEFAULT_SOFT_ALLOCATIONS		0
#define	IPSEC_DEFAULT_EXP_ALLOCATIONS		0
#define	IPSEC_DEFAULT_SOFT_BYTES		0
#define	IPSEC_DEFAULT_EXP_BYTES			0
#define	IPSEC_DEFAULT_SOFT_TIMEOUT		80000
#define	IPSEC_DEFAULT_EXP_TIMEOUT		86400
#define	IPSEC_DEFAULT_SOFT_FIRST_USE		3600
#define	IPSEC_DEFAULT_EXP_FIRST_USE		7200
#define	IPSEC_DEFAULT_DEF_ENC			"aes"
#define	IPSEC_DEFAULT_DEF_AUTH			"hmac-sha1"
#define	IPSEC_DEFAULT_EXPIRE_ACQUIRE		30

struct sockaddr_encap {
	u_int8_t	sen_len;		/* length */
	u_int8_t	sen_family;		/* PF_KEY */
	u_int16_t	sen_type;		/* see SENT_* */
	union {
		struct {				/* SENT_IP4 */
			u_int8_t	Direction;
			struct in_addr	Src;
			struct in_addr	Dst;
			u_int8_t	Proto;
			u_int16_t	Sport;
			u_int16_t	Dport;
		} Sip4;

		struct {				/* SENT_IP6 */
			u_int8_t	Direction;
			struct in6_addr	Src;
			struct in6_addr	Dst;
			u_int8_t	Proto;
			u_int16_t	Sport;
			u_int16_t	Dport;
		} Sip6;
d94 48
a141 21
		struct ipsec_policy	*PolicyHead;	/* SENT_IPSP */
	} Sen;
};

#define	IPSP_DIRECTION_IN	0x1
#define	IPSP_DIRECTION_OUT	0x2

#define	sen_data		Sen.Data
#define	sen_ip_src		Sen.Sip4.Src
#define	sen_ip_dst		Sen.Sip4.Dst
#define	sen_proto		Sen.Sip4.Proto
#define	sen_sport		Sen.Sip4.Sport
#define	sen_dport		Sen.Sip4.Dport
#define	sen_direction		Sen.Sip4.Direction
#define	sen_ip6_src		Sen.Sip6.Src
#define	sen_ip6_dst		Sen.Sip6.Dst
#define	sen_ip6_proto		Sen.Sip6.Proto
#define	sen_ip6_sport		Sen.Sip6.Sport
#define	sen_ip6_dport		Sen.Sip6.Dport
#define	sen_ip6_direction	Sen.Sip6.Direction
#define	sen_ipsp		Sen.PolicyHead
d151 5
a155 12
#define	SENT_IP4	0x0001		/* data is two struct in_addr */
#define	SENT_IPSP	0x0002		/* data as in IP4/6 plus SPI */
#define	SENT_IP6	0x0004

#define	SENT_LEN	sizeof(struct sockaddr_encap)

struct ipsec_ref {
	u_int16_t	ref_type;	/* Subtype of data */
	int16_t		ref_len;	/* Length of data following */
	int		ref_count;	/* Reference count */
	int		ref_malloctype;	/* malloc(9) type, for freeing */
};
d157 9
a165 9
struct ipsec_acquire {
	union sockaddr_union		ipa_addr;
	u_int32_t			ipa_seq;
	struct sockaddr_encap		ipa_info;
	struct sockaddr_encap		ipa_mask;
	struct timeout			ipa_timeout;
	struct ipsec_policy		*ipa_policy;
	TAILQ_ENTRY(ipsec_acquire)	ipa_ipo_next;
	TAILQ_ENTRY(ipsec_acquire)	ipa_next;
d168 4
a171 31
struct ipsec_policy {
	struct sockaddr_encap	ipo_addr;
	struct sockaddr_encap	ipo_mask;

	union sockaddr_union	ipo_src;	/* Local address to use */
	union sockaddr_union	ipo_dst;	/* Remote gateway -- if it's zeroed:
						 * - on output, we try to contact the
						 * remote host directly (if needed).
						 * - on input, we accept on if the
						 * inner source is the same as the
						 * outer source address, or if transport
						 * mode was used.
						 */

	u_int64_t		ipo_last_searched;	/* Timestamp of last lookup */

	u_int8_t		ipo_flags;	/* See IPSP_POLICY_* definitions */
	u_int8_t		ipo_type;	/* USE/ACQUIRE/... */
	u_int8_t		ipo_sproto;	/* ESP/AH; if zero, use system dflts */

	struct tdb		*ipo_tdb;		/* Cached entry */

	struct ipsec_ref	*ipo_srcid;
	struct ipsec_ref	*ipo_dstid;
	struct ipsec_ref	*ipo_local_cred;
	struct ipsec_ref	*ipo_local_auth;

	TAILQ_HEAD(ipo_acquires_head, ipsec_acquire) ipo_acquires; /* List of acquires */
	TAILQ_ENTRY(ipsec_policy)	ipo_tdb_next;	/* List TDB policies */
	TAILQ_ENTRY(ipsec_policy)	ipo_list;	/* List of all policies */
};
d173 38
a210 10
#define	IPSP_POLICY_NONE	0x0000	/* No flags set */
#define	IPSP_POLICY_SOCKET	0x0001	/* Socket-attached policy */
#define	IPSP_POLICY_STATIC	0x0002	/* Static policy */

#define	IPSP_IPSEC_USE		0	/* Use if existing, don't acquire */
#define	IPSP_IPSEC_ACQUIRE	1	/* Try acquire, let packet through */
#define	IPSP_IPSEC_REQUIRE	2	/* Require SA */
#define	IPSP_PERMIT		3	/* Permit traffic through */
#define	IPSP_DENY		4	/* Deny traffic */
#define	IPSP_IPSEC_DONTACQ	5	/* Require, but don't acquire */
d213 7
a219 24
#define	NOTIFY_SOFT_EXPIRE	0	/* Soft expiration of SA */
#define	NOTIFY_HARD_EXPIRE	1	/* Hard expiration of SA */
#define	NOTIFY_REQUEST_SA	2	/* Establish an SA */

#define	NOTIFY_SATYPE_CONF	1	/* SA should do encryption */
#define	NOTIFY_SATYPE_AUTH	2	/* SA should do authentication */
#define	NOTIFY_SATYPE_TUNNEL	4	/* SA should use tunneling */

/* Authentication types */
#define	IPSP_AUTH_NONE		0
#define	IPSP_AUTH_PASSPHRASE	1
#define	IPSP_AUTH_RSA		2

/* Credential types */
#define	IPSP_CRED_NONE		0
#define	IPSP_CRED_KEYNOTE	1
#define	IPSP_CRED_X509		2

/* Identity types */
#define	IPSP_IDENTITY_NONE		0
#define	IPSP_IDENTITY_PREFIX		1
#define	IPSP_IDENTITY_FQDN		2
#define	IPSP_IDENTITY_USERFQDN		3
#define	IPSP_IDENTITY_CONNECTION	4
d228 2
a229 2
	struct rtentry		*re_rt;
	struct sockaddr_encap	re_dst;
d232 100
a331 104
struct tdb {				/* tunnel descriptor block */
	/*
	 * Each TDB is on three hash tables: one keyed on dst/spi/sproto,
	 * one keyed on dst/sproto, and one keyed on src/sproto. The first
	 * is used for finding a specific TDB, the second for finding TDBs
	 * TDBs for outgoing policy matching, and the third for incoming
	 * policy matching. The following three fields maintain the hash
	 * queues in those three tables.
	 */
	struct tdb	*tdb_hnext;	/* dst/spi/sproto table */
	struct tdb	*tdb_anext;	/* dst/sproto table */
	struct tdb	*tdb_snext;	/* src/sproto table */
	struct tdb	*tdb_inext;
	struct tdb	*tdb_onext;

	struct xformsw		*tdb_xform;		/* Transform to use */
	struct enc_xform	*tdb_encalgxform;	/* Enc algorithm */
	struct auth_hash	*tdb_authalgxform;	/* Auth algorithm */

#define	TDBF_UNIQUE		0x00001	/* This should not be used by others */
#define	TDBF_TIMER		0x00002	/* Absolute expiration timer in use */
#define	TDBF_BYTES		0x00004	/* Check the byte counters */
#define	TDBF_ALLOCATIONS	0x00008	/* Check the flows counters */
#define	TDBF_INVALID		0x00010	/* This SPI is not valid yet/anymore */
#define	TDBF_FIRSTUSE		0x00020	/* Expire after first use */
#define	TDBF_HALFIV		0x00040	/* Use half-length IV (ESP old only) */
#define	TDBF_SOFT_TIMER		0x00080	/* Soft expiration */
#define	TDBF_SOFT_BYTES		0x00100	/* Soft expiration */
#define	TDBF_SOFT_ALLOCATIONS	0x00200	/* Soft expiration */
#define	TDBF_SOFT_FIRSTUSE	0x00400	/* Soft expiration */
#define	TDBF_PFS		0x00800	/* Ask for PFS from Key Mgmt. */
#define	TDBF_TUNNELING		0x01000	/* Force IP-IP encapsulation */
#define	TDBF_NOREPLAY		0x02000	/* No replay counter present */
#define	TDBF_RANDOMPADDING	0x04000	/* Random data in the ESP padding */
#define	TDBF_SKIPCRYPTO		0x08000	/* Skip actual crypto processing */
#define	TDBF_USEDTUNNEL		0x10000	/* Appended a tunnel header in past */

	u_int32_t	tdb_flags;	/* Flags related to this TDB */

	struct timeout	tdb_timer_tmo;
	struct timeout	tdb_first_tmo;
	struct timeout	tdb_stimer_tmo;
	struct timeout	tdb_sfirst_tmo;

	u_int32_t	tdb_seq;		/* Tracking number for PFKEY */
	u_int32_t	tdb_exp_allocations;	/* Expire after so many flows */
	u_int32_t	tdb_soft_allocations;	/* Expiration warning */
	u_int32_t	tdb_cur_allocations;	/* Total number of allocs */

	u_int64_t	tdb_exp_bytes;	/* Expire after so many bytes passed */
	u_int64_t	tdb_soft_bytes;	/* Expiration warning */
	u_int64_t	tdb_cur_bytes;	/* Current count of bytes */

	u_int64_t	tdb_exp_timeout;	/* When does the SPI expire */
	u_int64_t	tdb_soft_timeout;	/* Send soft-expire warning */
	u_int64_t	tdb_established;	/* When was SPI established */

	u_int64_t	tdb_first_use;		/* When was it first used */
	u_int64_t	tdb_soft_first_use;	/* Soft warning */
	u_int64_t	tdb_exp_first_use;	/* Expire if tdb_first_use +
						 * tdb_exp_first_use <= curtime
						 */

	u_int64_t	tdb_last_used;	/* When was this SA last used */
	u_int64_t	tdb_last_marked;/* Last SKIPCRYPTO status change */

	u_int64_t	tdb_cryptoid;	/* Crypto session ID */

	u_int32_t	tdb_spi;	/* SPI */
	u_int16_t	tdb_amxkeylen;	/* Raw authentication key length */
	u_int16_t	tdb_emxkeylen;	/* Raw encryption key length */
	u_int16_t	tdb_ivlen;	/* IV length */
	u_int8_t	tdb_sproto;	/* IPsec protocol */
	u_int8_t	tdb_wnd;	/* Replay window */
	u_int8_t	tdb_satype;	/* SA type (RFC2367, PF_KEY) */

	union sockaddr_union	tdb_dst;	/* Destination address */
	union sockaddr_union	tdb_src;	/* Source address */
	union sockaddr_union	tdb_proxy;

	u_int8_t	*tdb_amxkey;	/* Raw authentication key */
	u_int8_t	*tdb_emxkey;	/* Raw encryption key */

	u_int32_t	tdb_rpl;	/* Replay counter */
	u_int32_t	tdb_bitmap;	/* Used for replay sliding window */
	u_int32_t	tdb_initial;	/* Initial replay value */

	u_int32_t	tdb_epoch;	/* Used by the kernfs interface */

	u_int8_t	tdb_iv[4];	/* Used for HALF-IV ESP */

	struct ipsec_ref	*tdb_local_cred;
	struct ipsec_ref	*tdb_remote_cred;
	struct ipsec_ref	*tdb_srcid;	/* Source ID for this SA */
	struct ipsec_ref	*tdb_dstid;	/* Destination ID for this SA */
	struct ipsec_ref	*tdb_local_auth;/* Local authentication material */
	struct ipsec_ref	*tdb_remote_auth;/* Remote authentication material */

	u_int32_t	tdb_mtu;	/* MTU at this point in the chain */
	u_int64_t	tdb_mtutimeout;	/* When to ignore this entry */

	TAILQ_HEAD(tdb_inp_head_in, inpcb)	tdb_inp_in;
	TAILQ_HEAD(tdb_inp_head_out, inpcb)	tdb_inp_out;
	TAILQ_HEAD(tdb_policy_head, ipsec_policy)	tdb_policy_head;
d335 3
a337 3
	u_int32_t spi;
	union sockaddr_union dst;
	u_int8_t proto;
d341 9
a349 6
	u_int32_t		tc_spi;
	union sockaddr_union	tc_dst;
	u_int8_t		tc_proto;
	int			tc_protoff;
	int			tc_skip;
	caddr_t			tc_ptr;
d352 8
a359 7
struct ipsecinit {
	u_int8_t	*ii_enckey;
	u_int8_t	*ii_authkey;
	u_int16_t	ii_enckeylen;
	u_int16_t	ii_authkeylen;
	u_int8_t	ii_encalg;
	u_int8_t	ii_authalg;
d362 10
a371 10
struct xformsw {
	u_short	xf_type;		/* Unique ID of xform */
	u_short	xf_flags;		/* flags (see below) */
	char	*xf_name;		/* human-readable name */
	int	(*xf_attach)(void);	/* called at config time */
	int	(*xf_init)(struct tdb *, struct xformsw *, struct ipsecinit *);
	int	(*xf_zeroize)(struct tdb *); /* termination */
	int	(*xf_input)(struct mbuf *, struct tdb *, int, int); /* input */
	int	(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **,
	    int, int);        /* output */
d375 4
a378 4
#define	XF_IP4		1	/* IP inside IP */
#define	XF_AH		2	/* AH */
#define	XF_ESP		3	/* ESP */
#define	XF_TCPSIGNATURE	5	/* TCP MD5 Signature option, RFC 2358 */
d381 2
a382 2
#define	XFT_AUTH	0x0001
#define	XFT_CONF	0x0100
d384 2
a385 2
#define	IPSEC_ZEROES_SIZE	256	/* Larger than an IP6 extension hdr. */
#define	IPSEC_KERNFS_BUFSIZE	4096
d391 3
a393 3
	register u_int32_t u, l;
	u = q >> 32;
	l = (u_int32_t) q;
d395 1
a395 1
	return htonl(u) | ((u_int64_t)htonl(l) << 32);
d398 1
a398 1
#define	ntohq(_x)	htonq(_x)
d402 2
a403 2
#define	htonq(_x)	(_x)
#define	ntohq(_x)	htonq(_x)
d406 1
a406 1
#error	"Please fix <machine/endian.h>"
d417 1
a417 1
#define	spltdb	splsoftnet
a426 2
extern int ipsec_policy_pool_initialized;

d454 1
a454 1
#define	TDB_ATTRIB(x) (((x)->tdb_encalgxform ? NOTIFY_SATYPE_CONF : 0) | \
d459 1
a459 1
#define	SPI_CHAIN_ATTRIB(have, TDB_DIR, TDBP) do {\
d466 4
a469 4
			break; \
		(have) |= TDB_ATTRIB(tmptdb); \
		tmptdb = tmptdb->TDB_DIR; \
	} \
d480 1
a480 1
    union sockaddr_union *, u_int8_t, int *);
d482 4
a485 4
extern struct tdb *gettdbbyaddr(union sockaddr_union *, struct ipsec_policy *,
    struct mbuf *, int);
extern struct tdb *gettdbbysrc(union sockaddr_union *, struct ipsec_policy *,
    struct mbuf *, int);
d496 2
a497 1
extern int ipip_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
d511 1
a511 1
    int, int);
d518 2
a519 1
extern int ah_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
a528 1
extern void *ah4_ctlinput __P((int, struct sockaddr *, void *));
d540 2
a541 1
extern int esp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
a549 1
extern void *esp4_ctlinput __P((int, struct sockaddr *, void *));
d560 1
a560 1
    struct ipsecinit *));
d563 1
a563 1
    int));
d565 1
a565 1
    struct mbuf **, int, int));
d572 1
a572 1
    u_int32_t *);
d577 3
a579 2
extern int ipsp_process_packet(struct mbuf *, struct tdb *, int, int);
extern int ipsp_process_done(struct mbuf *, struct tdb *);
d581 2
a582 5
    struct tdb *, struct inpcb *);
extern struct tdb *ipsp_spd_inp(struct mbuf *, int, int, int *, int,
    struct tdb *, struct inpcb *, struct ipsec_policy *);
extern int ipsec_common_input_cb(struct mbuf *, struct tdb *, int, int,
    struct m_tag *);
d584 2
a585 1
    union sockaddr_union *, struct sockaddr_encap *, struct mbuf *);
d587 4
a590 1
    struct sockaddr_encap *, union sockaddr_union *, int, int);
d592 2
a593 12
extern struct ipsec_acquire *ipsp_pending_acquire(struct ipsec_policy *,
    union sockaddr_union *);
extern void ipsp_delete_acquire(void *);
extern int ipsp_is_unspecified(union sockaddr_union);
extern void ipsp_reffree(struct ipsec_ref *);
extern void ipsp_skipcrypto_unmark(struct tdb_ident *);
extern void ipsp_skipcrypto_mark(struct tdb_ident *);
extern struct m_tag *ipsp_parse_headers(struct mbuf *, int, u_int8_t);
extern int ipsp_ref_match(struct ipsec_ref *, struct ipsec_ref *);
extern ssize_t ipsec_hdrsz(struct tdb *);
extern void ipsec_adjust_mtu(struct mbuf *, u_int32_t);
extern int ipsp_print_tdb(struct tdb *, char *);
d595 3
@


1.60.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.60.2.4 2001/07/04 10:54:52 niklas Exp $	*/
a75 6
/* Reserved CPI numbers */
#define CPI_RESERVED_MIN	1
#define CPI_RESERVED_MAX	255
#define CPI_PRIVATE_MIN		61440
#define CPI_PRIVATE_MAX		65535

a89 1
#define	IPSEC_DEFAULT_DEF_COMP			"deflate"
a218 1
#define NOTIFY_SATYPE_COMP	5       /* SA (IPCA) should use compression */
a265 1
	struct comp_algo	*tdb_compalgxform;	/* Compression algo */
a375 1
	u_int8_t	ii_compalg;
a394 1
#define	XF_IPCOMP	6	/* IPCOMP */
a398 1
#define	XFT_COMP	0x1000
a454 1
extern char ipsec_def_comp[];
a465 2
extern struct comp_algo comp_algo_deflate;

d473 1
a473 2
		       ((x)->tdb_authalgxform ? NOTIFY_SATYPE_AUTH : 0) | \
		       ((x)->tdb_compalgxform ? NOTIFY_SATYPE_COMP : 0))
d516 1
a516 1
extern void ipip_input __P((struct mbuf *, int, struct ifnet *));
a571 20
#endif /* INET6 */

/* XF_IPCOMP */
extern int ipcomp_attach(void);
extern int ipcomp_init(struct tdb *, struct xformsw *, struct ipsecinit *);
extern int ipcomp_zeroize(struct tdb *);
extern int ipcomp_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
extern int ipcomp_output_cb(void *);
extern int ipcomp_input(struct mbuf *, struct tdb *, int, int);
extern int ipcomp_input_cb(void *);
extern int ipcomp_sysctl(int *, u_int, void *, size_t *, void *, size_t);

#ifdef INET
extern void ipcomp4_input __P((struct mbuf *, ...));
extern int ipcomp4_input_cb __P((struct mbuf *, ...));
#endif /* INET */

#ifdef INET6
extern int ipcomp6_input __P((struct mbuf **, int *, int));
extern int ipcomp6_input_cb __P((struct mbuf *, int, int));
@


1.60.2.6
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d531 2
a532 2
extern void ipe4_input(struct mbuf *, ...);
extern void ipip_input(struct mbuf *, int, struct ifnet *);
d535 1
a535 1
extern void ip4_input(struct mbuf *, ...);
d539 1
a539 1
extern int ip4_input6(struct mbuf **, int *, int);
d545 1
a545 1
extern void etherip_input(struct mbuf *, ...);
d559 3
a561 3
extern void ah4_input(struct mbuf *, ...);
extern int ah4_input_cb(struct mbuf *, ...);
extern void *ah4_ctlinput(int, struct sockaddr *, void *);
d565 2
a566 2
extern int ah6_input(struct mbuf **, int *, int);
extern int ah6_input_cb(struct mbuf *, int, int);
d580 3
a582 3
extern void esp4_input(struct mbuf *, ...);
extern int esp4_input_cb(struct mbuf *, ...);
extern void *esp4_ctlinput(int, struct sockaddr *, void *);
d586 2
a587 2
extern int esp6_input(struct mbuf **, int *, int);
extern int esp6_input_cb(struct mbuf *, int, int);
d601 2
a602 2
extern void ipcomp4_input(struct mbuf *, ...);
extern int ipcomp4_input_cb(struct mbuf *, ...);
d606 2
a607 2
extern int ipcomp6_input(struct mbuf **, int *, int);
extern int ipcomp6_input_cb(struct mbuf *, int, int);
d611 8
a618 8
extern int tcp_signature_tdb_attach(void);
extern int tcp_signature_tdb_init(struct tdb *, struct xformsw *,
    struct ipsecinit *);
extern int tcp_signature_tdb_zeroize(struct tdb *);
extern int tcp_signature_tdb_input(struct mbuf *, struct tdb *, int,
    int);
extern int tcp_signature_tdb_output(struct mbuf *, struct tdb *,
    struct mbuf **, int, int);
@


1.60.2.7
log
@Sync the SMP branch with 3.3
@
text
@a170 1
	struct inpcb                    *ipa_pcb;
a172 1
	TAILQ_ENTRY(ipsec_acquire)      ipa_inp_next;
a194 2
	int                     ipo_ref_count;

d342 1
d345 1
a357 3
	struct sockaddr_encap   tdb_filter; /* What traffic is acceptable */
	struct sockaddr_encap   tdb_filtermask; /* And the mask */

d388 12
a438 12
struct xformsw {
	u_short	xf_type;		/* Unique ID of xform */
	u_short	xf_flags;		/* flags (see below) */
	char	*xf_name;		/* human-readable name */
	int	(*xf_attach)(void);	/* called at config time */
	int	(*xf_init)(struct tdb *, struct xformsw *, struct ipsecinit *);
	int	(*xf_zeroize)(struct tdb *); /* termination */
	int	(*xf_input)(struct mbuf *, struct tdb *, int, int); /* input */
	int	(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **,
	    int, int);        /* output */
};

d516 4
a519 6
extern struct tdb *gettdbbyaddr(union sockaddr_union *, u_int8_t,
    struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
    struct mbuf *, int, struct sockaddr_encap *, struct sockaddr_encap *);
extern struct tdb *gettdbbysrc(union sockaddr_union *, u_int8_t,
    struct ipsec_ref *, struct ipsec_ref *, struct mbuf *, int,
    struct sockaddr_encap *, struct sockaddr_encap *);
d625 1
a625 1
    u_int32_t *, int);
d640 2
a641 3
extern struct ipsec_policy *ipsec_add_policy(struct inpcb *, int, int);
extern void ipsec_update_policy(struct inpcb *, struct ipsec_policy *,
    int, int);
a655 5
extern int ipsp_aux_match(struct ipsec_ref *, struct ipsec_ref *,
    struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
    struct ipsec_ref *, struct ipsec_ref *, struct ipsec_ref *,
    struct sockaddr_encap *, struct sockaddr_encap *,
    struct sockaddr_encap *, struct sockaddr_encap *);
@


1.60.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.60.2.7 2003/03/28 00:06:54 niklas Exp $	*/
d662 1
a662 1
extern int ipsp_print_tdb(struct tdb *, char *, size_t);
@


1.60.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a59 3
#define	SHA2_256HMAC96_KEYSIZE	32
#define	SHA2_384HMAC96_KEYSIZE	48
#define	SHA2_512HMAC96_KEYSIZE	64
d69 1
a69 4
#define	AH_SHA2_256_ALEN	32
#define	AH_SHA2_384_ALEN	48
#define	AH_SHA2_512_ALEN	64
#define	AH_ALEN_MAX		64 	/* Keep updated */
a296 1
#define	TDBF_UDPENCAP		0x20000	/* UDP encapsulation */
a359 2
	u_int16_t	tdb_udpencap_port;	/* Peer UDP port */

d412 1
a412 1
	u_int32_t u, l;
a526 2
extern struct tdb *gettdbbysrcdst(u_int32_t, union sockaddr_union *,
    union sockaddr_union *, u_int8_t);
a642 1
extern int ipsec_common_input(struct mbuf *, int, int, int, int, int);
@


1.60.2.10
log
@Merge with the trunk
@
text
@d676 4
a679 3
extern int ipsp_aux_match(struct tdb *,
    struct ipsec_ref *, struct ipsec_ref *,
    struct ipsec_ref *, struct ipsec_ref *,
@


1.59
log
@Rename the ip4_* routines to ipip_*, make it so GIF tunnels are not
affected by net.inet.ipip.allow (the sysctl formerly known as
net.inet.ip4.allow), rename the VIF ipip_input to ipip_mroute_input.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.58 2000/01/13 06:02:31 angelos Exp $	*/
d276 3
d303 2
a304 1
    u_int16_t         tdb_amxkeylen;    /* AH-old only */
a308 1
    u_int8_t          tdb_FILLER;       /* Padding */
d319 2
a320 1
    u_int8_t         *tdb_amxkey;       /* AH-old only */
d374 1
d417 3
a419 5
#define XF_OLD_AH	2	/* RFCs 1828 & 1852 */
#define XF_OLD_ESP	3	/* RFCs 1829 & 1851 */
#define XF_NEW_AH	4	/* AH HMAC 96bits */
#define XF_NEW_ESP	5	/* ESP + auth 96bits + replay counter */
#define XF_TCPSIGNATURE	6	/* TCP MD5 Signature option, RFC 2358 */
d570 5
a574 5
/* XF_OLD_AH */
extern int ah_old_attach(void);
extern int ah_old_init(struct tdb *, struct xformsw *, struct ipsecinit *);
extern int ah_old_zeroize(struct tdb *);
extern int ah_old_output(struct mbuf *, struct tdb *, struct mbuf **,
d576 10
a585 1
extern struct mbuf *ah_old_input(struct mbuf *, struct tdb *, int, int);
d587 8
a594 7
/* XF_NEW_AH */
extern int ah_new_attach(void);
extern int ah_new_init(struct tdb *, struct xformsw *, struct ipsecinit *);
extern int ah_new_zeroize(struct tdb *);
extern int ah_new_output(struct mbuf *, struct tdb *, struct mbuf **,
			 int, int);
extern struct mbuf *ah_new_input(struct mbuf *, struct tdb *, int, int);
d596 3
a598 7
/* XF_OLD_ESP */
extern int esp_old_attach(void);
extern int esp_old_init(struct tdb *, struct xformsw *, struct ipsecinit *);
extern int esp_old_zeroize(struct tdb *);
extern int esp_old_output(struct mbuf *, struct tdb *, struct mbuf **,
			  int, int);
extern struct mbuf *esp_old_input(struct mbuf *, struct tdb *, int, int);
d600 3
a602 7
/* XF_NEW_ESP */
extern int esp_new_attach(void);
extern int esp_new_init(struct tdb *, struct xformsw *, struct ipsecinit *);
extern int esp_new_zeroize(struct tdb *);
extern int esp_new_output(struct mbuf *, struct tdb *, struct mbuf **,
			  int, int);
extern struct mbuf *esp_new_input(struct mbuf *, struct tdb *, int, int);
@


1.58
log
@mbuf **, not mbuf * you twit...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.57 2000/01/13 05:03:45 angelos Exp $	*/
d550 1
a550 1
extern int ipe4_output(struct mbuf *, struct tdb *, struct mbuf **, int, int);
d552 3
d556 1
@


1.57
log
@Add an ip4_input6() for use with IPv6 (just a wrapper for
ip4_input()), add prototype, ifdef include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.56 2000/01/13 00:34:31 angelos Exp $	*/
d555 1
a555 1
extern int ip4_input6 __P((struct mbuf *, int *, int));
@


1.56
log
@put_flow(), find_flow(), and delete_flow() get a third argument (for
ingress or egress flow)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.55 2000/01/10 06:59:23 angelos Exp $	*/
d553 4
@


1.55
log
@Add 10 new ipsec-related sysctl variables...they are currently under
net.inet.ip; perhaps they should be moved under net.inet.ipsec or some
such.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.54 2000/01/10 04:30:53 angelos Exp $	*/
d64 3
d536 2
a537 2
extern void put_flow(struct flow *, struct tdb *);
extern void delete_flow(struct flow *, struct tdb *);
d540 1
a540 1
			      u_int8_t, struct tdb *);
@


1.54
log
@Add net.inet.ip.ipsec-invalid-life, default value 60 seconds; the
amount of time embryonic SAs will be kept before they have to be
initialized by key management (this only affects automated key
management).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.53 2000/01/09 22:31:07 angelos Exp $	*/
d107 1
a107 1
/* How long are we going to keep embryonic SAs (default value) */
d109 11
d458 2
d462 20
@


1.53
log
@externalize ipsec_acl
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.52 1999/12/29 20:27:55 mickey Exp $	*/
d107 3
d445 1
@


1.52
log
@fix _input/_output proto changes for tcp_signature; angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.51 1999/12/25 04:48:16 angelos Exp $	*/
d322 2
a323 1
    struct flow	     *tdb_flow; 	/* Which flows use this SA */
d441 1
@


1.51
log
@Move the IPsec packet-processing loop to a separate routine, so we can
reuse it in ip6_output and the bridge. The policy-lookup code will
probably follow suit in a separate routine sometime soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.50 1999/12/08 12:10:25 angelos Exp $	*/
d554 1
a554 1
extern struct mbuf *tcp_signature_tdb_input __P((struct mbuf *, struct tdb *));
d556 1
a556 1
					 struct mbuf **));
@


1.50
log
@Fix debugging printf compilation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.49 1999/12/08 06:16:56 angelos Exp $	*/
d566 4
@


1.49
log
@IPv6 header handling, improve IPv4 option handling support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.48 1999/12/06 07:14:36 angelos Exp $	*/
d471 1
a471 1
#if INET6
@


1.48
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.47 1999/12/04 23:20:21 angelos Exp $	*/
d404 1
a404 1
#define IPSEC_ZEROES_SIZE	64
@


1.47
log
@Address independence, IPv6 support, and the -local flag in ipsecadm is
no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.46 1999/10/29 05:20:46 angelos Exp $	*/
d388 2
a389 2
    struct mbuf 	*(*xf_input)(struct mbuf *, struct tdb *); /* input */
    int		(*xf_output)(struct mbuf *, struct tdb *, struct mbuf **);        /* output */
d508 1
a508 1
extern int ipe4_output(struct mbuf *, struct tdb *, struct mbuf **);
d513 2
a514 1
extern int etherip_output(struct mbuf *, struct tdb *, struct mbuf **);
d521 3
a523 2
extern int ah_old_output(struct mbuf *, struct tdb *, struct mbuf **);
extern struct mbuf *ah_old_input(struct mbuf *, struct tdb *);
d529 3
a531 2
extern int ah_new_output(struct mbuf *, struct tdb *, struct mbuf **);
extern struct mbuf *ah_new_input(struct mbuf *, struct tdb *);
d537 3
a539 2
extern int esp_old_output(struct mbuf *, struct tdb *, struct mbuf **);
extern struct mbuf *esp_old_input(struct mbuf *, struct tdb *);
d545 3
a547 2
extern int esp_new_output(struct mbuf *, struct tdb *, struct mbuf **);
extern struct mbuf *esp_new_input(struct mbuf *, struct tdb *);
@


1.46
log
@New field in tdb, to be used with bridging.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.45 1999/10/29 02:10:02 angelos Exp $	*/
d126 10
d143 8
d154 17
a170 9
#define sen_data	Sen.Data
#define sen_ip_src	Sen.Sip4.Src
#define sen_ip_dst	Sen.Sip4.Dst
#define sen_proto	Sen.Sip4.Proto
#define sen_sport	Sen.Sip4.Sport
#define sen_dport	Sen.Sip4.Dport
#define sen_ipsp_dst	Sen.Sipsp.Dst
#define sen_ipsp_spi	Sen.Sipsp.Spi
#define sen_ipsp_sproto	Sen.Sipsp.Sproto
d181 3
a183 1
#define SENT_IPSP	0x0002		/* data as in IP4 plus SPI */
d196 3
d201 2
d470 5
@


1.45
log
@Get rid of unnecessary third argument in *_output routines of IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.44 1999/10/29 02:02:33 angelos Exp $	*/
d288 1
@


1.44
log
@Remove unnecessary argument from ipe4_output() and etherip_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.43 1999/10/28 03:08:34 angelos Exp $	*/
d355 1
a355 2
    int		(*xf_output)(struct mbuf *, struct sockaddr_encap *,
			     struct tdb *, struct mbuf **);        /* output */
d481 1
a481 2
extern int ah_old_output(struct mbuf *, struct sockaddr_encap *, struct tdb *,
			 struct mbuf **);
d488 1
a488 2
extern int ah_new_output(struct mbuf *, struct sockaddr_encap *, struct tdb *,
			 struct mbuf **);
d495 1
a495 2
extern int esp_old_output(struct mbuf *, struct sockaddr_encap *, struct tdb *,
			  struct mbuf **);
d502 1
a502 2
extern int esp_new_output(struct mbuf *, struct sockaddr_encap *, struct tdb *,
			  struct mbuf **);
d511 1
a511 2
extern int tcp_signature_tdb_output __P((struct mbuf *,
					 struct sockaddr_encap *, struct tdb *,
@


1.43
log
@Add Ethernet-IP encapsulation handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.42 1999/09/29 09:11:21 niklas Exp $	*/
d470 1
a470 2
extern int ipe4_output(struct mbuf *, struct sockaddr_encap *, struct tdb *,
		       struct mbuf **);
d475 1
a475 2
extern int etherip_output(struct mbuf *, struct sockaddr_encap *, struct tdb *,
		          struct mbuf **);
@


1.42
log
@Critical reliability fix for IPsec.  On i386 splsoftclock is not
a perfect emulation of a "real" architecture's splsoftclock, as it
assumes it is only invoked from higher spl levels.  Use splsoftnet instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.41 1999/08/10 11:35:26 ho Exp $	*/
d474 5
@


1.41
log
@Add tdb_satype (PF_KEY SADB_SATYPE_<XXX>) to struct tdb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.40 1999/08/05 21:58:15 ho Exp $	*/
d400 3
a402 1
 * Must at least be splsoftclock.
d404 1
a404 1
#define spltdb	splsoftclock
@


1.40
log
@Add tdb_walk. tdb_delete() should clean up routes when deleting flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.39 1999/07/15 14:15:41 niklas Exp $	*/
d254 2
a255 1
    u_int16_t         tdb_FILLER;       /* Padding */
@


1.39
log
@From angelos@@, edits by me, demand keying for PF_KEY
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.38 1999/07/06 20:17:52 cmetz Exp $	*/
d443 1
a443 1
extern int tdb_init (struct tdb *, u_int16_t, struct ipsecinit *);
d448 1
@


1.38
log
@Added support for TCP MD5 option (RFC 2385).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.37 1999/06/30 17:23:59 deraadt Exp $	*/
d101 5
@


1.37
log
@remove final low-level crypto knowledge from base ipsec code
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.36 1999/06/18 07:24:07 deraadt Exp $	*/
d359 1
d497 10
@


1.36
log
@split out transforms; some debugging done but there may still be bugs in
the new key init/zero functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.35 1999/06/06 23:53:02 angelos Exp $	*/
d288 11
@


1.35
log
@Ident.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.34 1999/05/23 09:04:46 niklas Exp $	*/
d315 2
@


1.34
log
@SA hash table resizing
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.33 1999/05/20 12:52:35 niklas Exp $	*/
d187 3
a189 3
    struct flow           *flow_next;	/* Next in flow chain */
    struct flow           *flow_prev;	/* Previous in flow chain */
    struct tdb            *flow_sa;	/* Pointer to the SA */
@


1.33
log
@Fix a bug where the ordered expiration list could get out of order.  Add
invariant checking of the lists when DIAGNOSTIC compiled.  Extend the
critical region to cover all of tdb_expiration so the tdb won't
disappear behind our back.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.32 1999/05/16 21:48:37 niklas Exp $	*/
a289 2
#define TDB_HASHMOD	257

a388 1
struct tdb *tdbh[TDB_HASHMOD];
@


1.32
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.31 1999/05/14 23:36:21 niklas Exp $	*/
d224 1
a224 1
    LIST_ENTRY(tdb)   tdb_explink;	/* Expiration ordered list link */
d393 1
a393 1
extern LIST_HEAD(explist_head, tdb) explist;
@


1.31
log
@A new scalable IPsec SA expiration model.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.30 1999/05/11 22:57:17 niklas Exp $	*/
d379 7
d402 2
a403 1
#define SPI_CHAIN_ATTRIB(have, TDB_DIR, TDBP) {\
d405 1
a406 1
	\
d413 2
a414 1
}
d426 1
a426 1
extern int tdb_delete(struct tdb *, int);
d429 3
@


1.30
log
@Remove cruft that wasted space en masse in the IPsec subsystem
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.29 1999/04/11 19:41:39 niklas Exp $	*/
d5 3
a7 2
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
d18 1
a18 1
 * Additional features in 1999 by Angelos D. Keromytis.
d20 1
a20 1
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
d22 2
a23 1
 *	
a184 10
struct expiration
{
    u_int32_t             exp_timeout;
    union sockaddr_union  exp_dst;
    u_int32_t             exp_spi;
    u_int8_t              exp_sproto;
    struct expiration    *exp_next;
    struct expiration    *exp_prev;
};

d223 3
d237 1
d243 1
d385 2
a386 1
struct expiration *explist;
d419 1
a419 4

/* Expiration management routines */
extern struct expiration *get_expiration(void);
extern void put_expiration(struct expiration *);
a420 1
extern void cleanup_expirations(union sockaddr_union *, u_int32_t, u_int8_t);
@


1.29
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.28 1999/03/27 21:04:19 provos Exp $	*/
a59 1
    char  __maxsize[128];
@


1.28
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.27 1999/02/25 01:30:49 angelos Exp $	*/
a380 18

/*
 * Names for IPsec sysctl objects
 */
#define IPSECCTL_PFKEY  		0
#define IPSECCTL_MAXID			1

#define CTL_IPSEC_NAMES {\
	{ "pfkey", CTLTYPE_NODE }, \
}

#define PFKEYCTL_ENCDEBUG	1
#define PFKEYCTL_MAXID		2

#define PFKEYCTL_NAMES {\
	{ 0, 0 }, \
	{ "encdebug", CTLTYPE_INT }, \
}
@


1.27
log
@Move union sockaddr_union to ip_ipsp.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.26 1999/02/24 23:45:52 angelos Exp $	*/
d46 1
d287 5
d296 6
d433 1
@


1.26
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.25 1999/02/24 23:07:20 deraadt Exp $	*/
d38 3
d45 2
d53 8
a60 1
#include <sys/socket.h>
d495 2
a496 1
#endif
@


1.25
log
@add skipjack support back
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.24 1999/02/24 22:33:06 angelos Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
@


1.24
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.21 1999/01/08 21:40:28 deraadt Exp $	*/
d45 1
d58 1
d66 1
@


1.23
log
@ipsec skipjack, based on free .fi code (some .gov type will test this for me)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.22 1999/02/17 18:10:38 deraadt Exp $	*/
d40 70
a109 7
struct expiration {
	u_int32_t	exp_timeout;
	struct in_addr	exp_dst;
	u_int32_t	exp_spi;
	u_int8_t	exp_sproto;
	struct expiration *exp_next;
	struct expiration *exp_prev;
d112 52
a163 12
struct flow {
	struct flow	*flow_next;	/* Next in flow chain */
	struct flow	*flow_prev;	/* Previous in flow chain */
	struct tdb	*flow_sa;	/* Pointer to the SA */
	struct in_addr	flow_src;   	/* Source address */
	struct in_addr	flow_srcmask;	/* Source netmask */
	struct in_addr	flow_dst;	/* Destination address */
	struct in_addr	flow_dstmask;	/* Destination netmask */
	u_int16_t	flow_sport;	/* Source port, if applicable */
	u_int16_t	flow_dport;	/* Destination port, if applicable */
	u_int8_t	flow_proto;	/* Transport protocol, if applicable */
	u_int8_t	foo[3];		/* Alignment */
d166 103
a268 48
struct tdb {				/* tunnel descriptor block */
	struct tdb	*tdb_hnext;  	/* next in hash chain */
	struct tdb	*tdb_onext;	/* next in output */
	struct tdb	*tdb_inext;  	/* next in input (prev!) */
	struct xformsw *tdb_xform;	/* transformation to use */
	u_int32_t	tdb_spi;    	/* SPI to use */
	u_int32_t	tdb_flags;  	/* Flags related to this TDB */
#define TDBF_UNIQUE	   0x00001	/* This should not be used by others */
#define TDBF_TIMER         0x00002	/* Absolute expiration timer in use */
#define TDBF_BYTES         0x00004	/* Check the byte counters */
#define TDBF_PACKETS       0x00008	/* Check the packet counters */
#define TDBF_INVALID       0x00010	/* This SPI is not valid yet/anymore */
#define TDBF_FIRSTUSE      0x00020	/* Expire after first use */
#define TDBF_TUNNELING     0x00040	/* Do IP-in-IP encapsulation */
#define TDBF_SOFT_TIMER    0x00080	/* Soft expiration */
#define TDBF_SOFT_BYTES    0x00100	/* Soft expiration */
#define TDBF_SOFT_PACKETS  0x00200	/* Soft expiration */
#define TDBF_SOFT_FIRSTUSE 0x00400	/* Soft expiration */
#define TDBF_SAME_TTL      0x00800	/* Keep the packet TTL, in tunneling */
	u_int64_t	tdb_exp_packets; /* Expire after so many packets s|r */
	u_int64_t	tdb_soft_packets; /* Expiration warning */ 
	u_int64_t	tdb_cur_packets; /* Current number of packets s|r'ed */
	u_int64_t	tdb_exp_bytes;	/* Expire after so many bytes passed */
	u_int64_t	tdb_soft_bytes;	/* Expiration warning */
	u_int64_t	tdb_cur_bytes;	/* Current count of bytes */
	u_int64_t	tdb_exp_timeout; /* When does the SPI expire */
	u_int64_t	tdb_soft_timeout; /* Send a soft-expire warning */
	u_int64_t	tdb_established; /* When was the SPI established */
	u_int64_t	tdb_first_use;	/* When was it first used */
	u_int64_t	tdb_soft_first_use; /* Soft warning */
	u_int64_t	tdb_exp_first_use; /* Expire if tdb_first_use +
					   tdb_exp_first_use <= curtime */
	struct in_addr	tdb_dst;	/* dest address for this SPI */
	struct in_addr	tdb_src;	/* source address for this SPI,
					 * used when tunneling */
	struct in_addr	tdb_osrc;
	struct in_addr	tdb_odst;	/* Source and destination addresses
					 * of outer IP header if we're doing
					 * tunneling */
	caddr_t		tdb_xdata;	/* transformation data (opaque) */
	struct flow	*tdb_flow; 	/* Which flows use this SA */

	u_int8_t	tdb_ttl;	/* TTL used in tunneling */
	u_int8_t	tdb_sproto;	/* IPsec protocol */
	u_int16_t	tdb_satype;	/* Alignment */
	u_int32_t	tdb_epoch;	/* Used by the kernfs interface */
	u_int8_t	*tdb_confname;	/* Used by the kernfs interface */
	u_int8_t	*tdb_authname;	/* Used by the kernfs interface */
d273 31
d306 9
a314 16
	u_short		xf_type;	/* Unique ID of xform */
	u_short		xf_flags;	/* flags (see below) */
	char		*xf_name;	/* human-readable name */
	int		(*xf_attach) __P((void));	/* called at config time */

	/* xform initialization */
	int		(*xf_init) __P((struct tdb *, struct xformsw *, struct mbuf *));

	int		(*xf_zeroize) __P((struct tdb *));	/* termination */

	/* called when packet received */
	struct mbuf 	*(*xf_input) __P((struct mbuf *, struct tdb *));

	/* called when packet sent */
	int		(*xf_output) __P((struct mbuf *, struct sockaddr_encap *,
			    struct tdb *, struct mbuf **));
d317 6
a322 17
#define XF_IP4			1	/* IP inside IP */
#define XF_OLD_AH		2	/* RFCs 1828 & 1852 */
#define XF_OLD_ESP		3	/* RFCs 1829 & 1851 */
#define XF_NEW_AH		4	/* AH HMAC 96bits */
#define XF_NEW_ESP		5	/* ESP + auth 96bits + replay counter */

/* Supported key hash algorithms */
#define ALG_AUTH_MD5		1
#define ALG_AUTH_SHA1		2
#define ALG_AUTH_RMD160		3

/* Supported encryption algorithms */
#define ALG_ENC_DES		1
#define ALG_ENC_3DES		2
#define ALG_ENC_BLF		3
#define ALG_ENC_CAST		4
#define ALG_ENC_SKIPJACK	5
d324 1
d335 3
a337 3
	register u_int32_t u, l;
	u = q >> 32;
	l = (u_int32_t) q;
d339 1
a339 1
	return htonl(u) | ((u_int64_t)htonl(l) << 32);
a352 2
extern unsigned char ipseczeroes[];

d356 1
a356 1
#define IPSECCTL_ENCAP			0
d360 9
a368 1
	{ "encap", CTLTYPE_NODE }, \
d373 3
a379 1
u_int32_t notify_msgids;
d382 2
a383 5
#define TDB_ATTRIB(x) \
    (((x)->tdb_confname != NULL ? NOTIFY_SATYPE_CONF : 0)| \
    ((x)->tdb_authname != NULL ? NOTIFY_SATYPE_AUTH : 0)| \
    ((x)->tdb_confname != NULL && \
    ((x)->tdb_flags & TDBF_TUNNELING) ? NOTIFY_SATYPE_TUNNEL : 0))
d387 1
a387 1
#define SPI_CHAIN_ATTRIB(have, TDB_DIR, TDBP) { \
d399 4
d404 3
a406 2
extern u_int32_t reserve_spi(u_int32_t, struct in_addr, u_int8_t, int *);
extern struct tdb *gettdb(u_int32_t, struct in_addr, u_int8_t);
d409 1
d415 1
a415 1
extern void cleanup_expirations(struct in_addr, u_int32_t, u_int8_t);
d421 7
a427 6
extern struct flow *find_flow(struct in_addr, struct in_addr, struct in_addr,
			      struct in_addr, u_int8_t, u_int16_t, u_int16_t,
			      struct tdb *);
extern struct flow *find_global_flow(struct in_addr, struct in_addr,
				     struct in_addr, struct in_addr, u_int8_t,
				     u_int16_t, u_int16_t);
d431 1
a431 1
extern int ipe4_init(struct tdb *, struct xformsw *, struct mbuf *);
d440 1
a440 1
extern int ah_old_init(struct tdb *, struct xformsw *, struct mbuf *);
d448 1
a448 1
extern int ah_new_init(struct tdb *, struct xformsw *, struct mbuf *);
d456 1
a456 1
extern int esp_old_init(struct tdb *, struct xformsw *, struct mbuf *);
d464 1
a464 1
extern int esp_new_init(struct tdb *, struct xformsw *, struct mbuf *);
d475 3
a477 1
			       u_int32_t *);
@


1.22
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.21 1999/01/08 21:40:28 deraadt Exp $	*/
d135 5
a139 5
#define XF_IP4		1		/* IP inside IP */
#define XF_OLD_AH	2		/* RFCs 1828 & 1852 */
#define XF_OLD_ESP	3		/* RFCs 1829 & 1851 */
#define XF_NEW_AH	4		/* AH HMAC 96bits */
#define XF_NEW_ESP	5		/* ESP + auth 96bits + replay counter */
d142 3
a144 3
#define ALG_AUTH_MD5	1
#define ALG_AUTH_SHA1	2
#define ALG_AUTH_RMD160 3
d147 5
a151 4
#define ALG_ENC_DES	1
#define ALG_ENC_3DES	2
#define ALG_ENC_BLF     3
#define ALG_ENC_CAST    4
@


1.21
log
@do not use random bits when not necessary, remove 8-byte block dependence
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.20 1998/11/25 11:47:17 niklas Exp $	*/
d40 7
a46 8
struct expiration
{
    u_int32_t          exp_timeout;
    struct in_addr     exp_dst;
    u_int32_t          exp_spi;
    u_int8_t           exp_sproto;
    struct expiration *exp_next;
    struct expiration *exp_prev;
d49 12
a60 13
struct flow
{
    struct flow     *flow_next;		/* Next in flow chain */
    struct flow     *flow_prev;		/* Previous in flow chain */
    struct tdb      *flow_sa;		/* Pointer to the SA */
    struct in_addr   flow_src;   	/* Source address */
    struct in_addr   flow_srcmask;	/* Source netmask */
    struct in_addr   flow_dst;		/* Destination address */
    struct in_addr   flow_dstmask;	/* Destination netmask */
    u_int16_t	     flow_sport;	/* Source port, if applicable */
    u_int16_t	     flow_dport;	/* Destination port, if applicable */
    u_int8_t	     flow_proto;	/* Transport protocol, if applicable */
    u_int8_t	     foo[3];		/* Alignment */
d63 7
a69 8
struct tdb				/* tunnel descriptor block */
{
    struct tdb	   *tdb_hnext;  	/* next in hash chain */
    struct tdb	   *tdb_onext;	        /* next in output */
    struct tdb	   *tdb_inext;  	/* next in input (prev!) */
    struct xformsw *tdb_xform;	        /* transformation to use */
    u_int32_t	    tdb_spi;    	/* SPI to use */
    u_int32_t	    tdb_flags;  	/* Flags related to this TDB */
d82 12
a93 12
    u_int64_t       tdb_exp_packets;	/* Expire after so many packets s|r */
    u_int64_t       tdb_soft_packets;	/* Expiration warning */ 
    u_int64_t       tdb_cur_packets;    /* Current number of packets s|r'ed */
    u_int64_t       tdb_exp_bytes;	/* Expire after so many bytes passed */
    u_int64_t       tdb_soft_bytes;	/* Expiration warning */
    u_int64_t       tdb_cur_bytes;	/* Current count of bytes */
    u_int64_t       tdb_exp_timeout;	/* When does the SPI expire */
    u_int64_t       tdb_soft_timeout;	/* Send a soft-expire warning */
    u_int64_t       tdb_established;	/* When was the SPI established */
    u_int64_t	    tdb_first_use;	/* When was it first used */
    u_int64_t       tdb_soft_first_use; /* Soft warning */
    u_int64_t       tdb_exp_first_use;	/* Expire if tdb_first_use +
d95 2
a96 2
    struct in_addr  tdb_dst;	        /* dest address for this SPI */
    struct in_addr  tdb_src;	        /* source address for this SPI,
d98 2
a99 2
    struct in_addr  tdb_osrc;
    struct in_addr  tdb_odst;		/* Source and destination addresses
d102 2
a103 2
    caddr_t	    tdb_xdata;	        /* transformation data (opaque) */
    struct flow	   *tdb_flow; 		/* Which flows use this SA */
d105 6
a110 6
    u_int8_t	    tdb_ttl;		/* TTL used in tunneling */
    u_int8_t	    tdb_sproto;		/* IPsec protocol */
    u_int16_t       tdb_satype;		/* Alignment */
    u_int32_t       tdb_epoch;		/* Used by the kernfs interface */
    u_int8_t       *tdb_confname;       /* Used by the kernfs interface */
    u_int8_t       *tdb_authname;       /* Used by the kernfs interface */
d117 16
a132 8
    u_short		xf_type;	/* Unique ID of xform */
    u_short		xf_flags;	/* flags (see below) */
    char		*xf_name;	/* human-readable name */
    int		(*xf_attach)(void);	/* called at config time */
    int		(*xf_init)(struct tdb *, struct xformsw *, struct mbuf *);	/* xform initialization */
    int		(*xf_zeroize)(struct tdb *); /* termination */
    struct mbuf 	*(*xf_input)(struct mbuf *, struct tdb *);	/* called when packet received */
    int		(*xf_output)(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);	/* called when packet sent */
d162 3
a164 3
    register u_int32_t u, l;
    u = q >> 32;
    l = (u_int32_t) q;
d166 1
a166 1
    return htonl(u) | ((u_int64_t)htonl(l) << 32);
d201 5
a205 4
#define TDB_ATTRIB(x) (((x)->tdb_confname != NULL ? NOTIFY_SATYPE_CONF : 0)| \
		       ((x)->tdb_authname != NULL ? NOTIFY_SATYPE_AUTH : 0)| \
		       ((x)->tdb_confname != NULL && \
			((x)->tdb_flags & TDBF_TUNNELING) ? NOTIFY_SATYPE_TUNNEL : 0))
d209 1
a209 1
#define SPI_CHAIN_ATTRIB(have, TDB_DIR, TDBP) {\
@


1.20
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.19 1998/05/18 21:10:59 provos Exp $	*/
d280 1
a280 1
extern caddr_t m_pad(struct mbuf *, int);
@


1.19
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.18 1998/03/18 10:51:38 provos Exp $	*/
d103 1
a103 1
					 * of outter IP header if we're doing
@


1.18
log
@adapt function arguments to get the expected prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.16 1997/11/24 19:14:15 provos Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
d194 20
@


1.17
log
@Fix tunnel mode input processing (use ip4_input instead of ipe4_input),
fix some old code leftovers in ah_new_input (adjust to variable hash length),
avoid double ip encapsulation in tunnel mode. Problems reportd by
Petr Novak <petr@@internet.cz>.
@
text
@d219 1
a219 1
extern void ip4_input __P((struct mbuf *, int));
@


1.16
log
@add ripemd-160 as authentication function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.15 1997/11/04 09:11:17 provos Exp $	*/
d219 1
@


1.15
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.14 1997/07/27 23:30:37 niklas Exp $	*/
d133 1
@


1.14
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.13 1997/07/15 23:11:10 provos Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
d106 2
d137 2
@


1.13
log
@flags for tunnels and replacing existing routes, sysctl! + tiny bug fix
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.12 1997/07/14 08:46:38 provos Exp $	*/
d30 10
d69 1
a69 1
#define TDBF_RELATIVE      0x00040	/* Expire after X secs from establ. */
d74 1
a74 3
#define TDBF_SOFT_RELATIVE 0x00800	/* Soft expiration */
#define TDBF_TUNNELING     0x01000	/* Do IP-in-IP encapsulation */
#define TDBF_SAME_TTL      0x02000	/* Keep the packet TTL, in tunneling */
a83 3
    u_int64_t	    tdb_soft_relative ; /* Soft warning */
    u_int64_t       tdb_exp_relative;   /* Expire if tdb_established +
					    tdb_exp_relative <= curtime */
d97 1
d100 2
a101 1
    u_int8_t        tdb_foo[2];		/* Alignment */
d136 1
d176 1
d178 1
d185 6
@


1.12
log
@sysctl...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.11 1997/07/11 23:37:59 provos Exp $	*/
d157 2
a158 2
#define IPSECCTL_ENCAP			28
#define IPSECCTL_MAXID			29
a160 28
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
@


1.11
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.10 1997/07/02 06:58:43 provos Exp $	*/
d157 2
a158 2
#define IPSECCTL_ENCDEBUG		1	/* turn debugging on/off */
#define IPSECCTL_MAXID			2
d160 1
a160 1
#define IPSECCTL_NAMES {\
d162 28
a189 1
	{ "encdebug", CTLTYPE_INT }, \
@


1.10
log
@fix neglected _FLEN's + reserve_spi + output reserved spi's without alg.
correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.9 1997/07/01 22:12:52 provos Exp $	*/
d30 15
d91 1
a91 3
    u_int16_t	    tdb_sport;		/* Source port, if applicable */
    u_int16_t       tdb_dport;		/* Destination port, if applicable */

d93 2
a94 2
    u_int8_t	    tdb_proto;		/* Protocol carried */
    u_int16_t	    tdb_foo;		/* alignment */
d112 12
a123 10
#define XF_AHMD5	2		/* AH MD5 */
#define XF_AHSHA1	3		/* AH SHA */
#define XF_ESPDES	4		/* ESP DES-CBC */
#define XF_ESP3DES	5		/* ESP DES3-CBC */
#define XF_AHHMACMD5	6		/* AH-HMAC-MD5 with opt replay prot */
#define XF_AHHMACSHA1	7		/* AH-HMAC-SHA1 with opt replay prot */
#define XF_ESPDESMD5	8		/* ESP DES-CBC + MD5 */
#define XF_ESP3DESMD5	9		/* ESP 3DES-CBC + MD5 */
#define XF_NEWESP       10		/* The new ESP transforms */
#define XF_NEWAH        11		/* The new AH transforms */
d154 11
a165 1
#undef ENCDEBUG	
d171 3
a173 2
extern u_int32_t reserve_spi(u_int32_t, struct in_addr, int *);
extern struct tdb *gettdb(u_int32_t, struct in_addr);
d177 17
a193 2
extern int ipe4_attach(void), ipe4_init(struct tdb *, struct xformsw *, struct mbuf *), ipe4_zeroize(struct tdb *);
extern int ipe4_output(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);
d196 31
a226 31
extern int ahmd5_attach(void), ahmd5_init(struct tdb *, struct xformsw *, struct mbuf *), ahmd5_zeroize(struct tdb *);
extern int ahmd5_output(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);
extern struct mbuf *ahmd5_input(struct mbuf *, struct tdb *);

extern int ahsha1_attach(void), ahsha1_init(struct tdb *, struct xformsw *, struct mbuf *), ahsha1_zeroize(struct tdb *);
extern int ahsha1_output(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);
extern struct mbuf *ahsha1_input(struct mbuf *, struct tdb *);

extern int ahhmacmd5_attach(void), ahhmacmd5_init(struct tdb *, struct xformsw *, struct mbuf *), ahhmacmd5_zeroize(struct tdb *);
extern int ahhmacmd5_output(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);
extern struct mbuf *ahhmacmd5_input(struct mbuf *, struct tdb *);

extern int ahhmacsha1_attach(void), ahhmacsha1_init(struct tdb *, struct xformsw *, struct mbuf *), ahhmacsha1_zeroize(struct tdb *);
extern int ahhmacsha1_output(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);
extern struct mbuf *ahhmacsha1_input(struct mbuf *, struct tdb *);

extern int espdes_attach(void), espdes_init(struct tdb *, struct xformsw *, struct mbuf *), espdes_zeroize(struct tdb *);
extern int espdes_output(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);
extern struct mbuf *espdes_input(struct mbuf *, struct tdb *);

extern int esp3des_attach(void), esp3des_init(struct tdb *, struct xformsw *, struct mbuf *), esp3des_zeroize(struct tdb *);
extern int esp3des_output(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);
extern struct mbuf *esp3des_input(struct mbuf *, struct tdb *);

extern int espdesmd5_attach(void), espdesmd5_init(struct tdb *, struct xformsw *, struct mbuf *), espdesmd5_zeroize(struct tdb *);
extern int espdesmd5_output(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);
extern struct mbuf *espdesmd5_input(struct mbuf *, struct tdb *);

extern int esp3desmd5_attach(void), esp3desmd5_init(struct tdb *, struct xformsw *, struct mbuf *), esp3desmd5_zeroize(struct tdb *);
extern int esp3desmd5_output(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);
extern struct mbuf *esp3desmd5_input(struct mbuf *, struct tdb *);
d228 1
d230 4
a233 2
extern int checkreplaywindow32(u_int32_t, u_int32_t, u_int32_t *, u_int32_t, u_int32_t *);
extern int checkreplaywindow64(u_int64_t, u_int64_t *, u_int64_t, u_int64_t *);
@


1.9
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.8 1997/06/25 07:53:28 provos Exp $	*/
d146 1
a146 1
extern u_int32_t reserve_spi(u_int32_t, struct in_addr);
@


1.8
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.7 1997/06/24 12:15:26 provos Exp $	*/
d35 1
d50 2
d69 6
a74 2
    struct ifnet   *tdb_rcvif;	        /* related rcv encap interface */
    struct xformsw *tdb_xform;	        /* transformation to use */
d76 6
@


1.7
log
@handle IP options in AH + allow IP options in outgoing encapsulated packets
+ usage counters for later use with keymanagement processes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.6 1997/06/21 00:09:19 deraadt Exp $	*/
d37 13
a49 6
#define TDBF_UNIQUE	0x0001		/* This should not be used by others */
#define TDBF_TIMER      0x0002		/* Check the timers */
#define TDBF_BYTES      0x0004		/* Check the byte counters */
#define TDBF_PACKETS    0x0008		/* Check the packet counters */
#define TDBF_INVALID    0x0010          /* This SPI is no longer valid */
    u_int64_t       tdb_packets;	/* Expire after so many packets s|r */
d52 1
a52 1
    u_int64_t       tdb_bytes;		/* Expire after so many bytes passed */
d55 1
a55 1
    u_int64_t       tdb_timeout;	/* When does the SPI expire */
d58 7
d133 1
@


1.6
log
@u_int32_t changes, need testing
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.5 1997/06/20 05:41:53 provos Exp $	*/
d39 6
a44 1
#define TDBF_BYTES      0x0004		/* Update the byte counters */
d46 1
d48 1
a49 1
    u_int64_t       tdb_hard_timeout;	/* When does the SPI expire */
@


1.5
log
@ah-sha1 + esp-3des + indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.4 1997/02/28 02:55:33 angelos Exp $	*/
d113 1
a113 1
extern struct tdb *gettdb(u_long, struct in_addr);
@


1.4
log
@Added flags field in the TDB structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.h,v 1.3 1997/02/24 14:06:42 niklas Exp $	*/
d32 17
a48 10
	struct tdb	*tdb_hnext;	/* next in hash chain */
	struct tdb	*tdb_onext;	/* next in output */
	struct tdb	*tdb_inext;	/* next in input (prev!) */
	u_long		tdb_spi;	/* SPI to use */
	u_long		tdb_flags;	/* Flags related to this TDB */
#define TDBF_UNIQUE	0x0001
	struct in_addr	tdb_dst;	/* dest address for this SPI */
	struct ifnet	*tdb_rcvif;	/* related rcv encap interface */
	struct xformsw	*tdb_xform;	/* transformation to use */
	caddr_t		tdb_xdata;	/* transformation data (opaque) */
d55 8
a62 8
	u_short		xf_type;	/* Unique ID of xform */
	u_short		xf_flags;	/* flags (see below) */
	char		*xf_name;	/* human-readable name */
	int		(*xf_attach)(void);	/* called at config time */
	int		(*xf_init)(struct tdb *, struct xformsw *, struct mbuf *);	/* xform initialization */
	int		(*xf_zeroize)(struct tdb *); /* termination */
	struct mbuf 	*(*xf_input)(struct mbuf *, struct tdb *);	/* called when packet received */
	int		(*xf_output)(struct mbuf *, struct sockaddr_encap *, struct tdb *, struct mbuf **);	/* called when packet sent */
d74 2
d86 3
a88 3
        register u_int32_t u, l;
        u = q >> 32;
        l = (u_int32_t) q;
d90 1
a90 1
        return htonl(u) | ((u_int64_t)htonl(l) << 32);
d125 4
d140 4
@


1.3
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 2
@


1.2
log
@-nostdinc and big endian cleanup
@
text
@d1 2
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@a68 1
#ifdef IPSEC_IPSP_C
d70 1
a70 1
inline u_int64_t
d90 2
a91 5
#else
u_int64_t htonq(u_int64_t);
#define ntohq(_x) htonq(_x)
extern unsigned char ipseczeroes[IPSEC_ZEROES_SIZE];
#endif
@

