head	1.65;
access;
symbols
	OPENBSD_6_1:1.62.0.4
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.57.0.4
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.50.0.4
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.44.0.10
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.8
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.6
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.33.0.4
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.32.0.4
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.4
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.19
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6;
locks; strict;
comment	@ * @;


1.65
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.64;
commitid	p51F2KIwIJB1dU8P;

1.64
date	2017.05.04.17.58.46;	author bluhm;	state Exp;
branches;
next	1.63;
commitid	Q1XaPbKgEyYyAOP7;

1.63
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.62;
commitid	00hB28wQPwG5Ysk0;

1.62
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.61;
commitid	3e3CkrbYekyVOcxy;

1.61
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.60;
commitid	pVtptbHA3yk4jSpN;

1.60
date	2017.01.03.10.52.21;	author mpi;	state Exp;
branches;
next	1.59;
commitid	RtLBKSTwcJi8fv4z;

1.59
date	2016.03.04.22.38.23;	author sashan;	state Exp;
branches;
next	1.58;
commitid	7fajBfMUpKRTskMd;

1.58
date	2015.12.02.08.47.00;	author claudio;	state Exp;
branches;
next	1.57;
commitid	bBZq0t5zueGnkAtX;

1.57
date	2015.07.29.00.04.03;	author rzalamena;	state Exp;
branches;
next	1.56;
commitid	9x7oePEcDKgC05vn;

1.56
date	2015.07.20.21.16.39;	author rzalamena;	state Exp;
branches;
next	1.55;
commitid	t2fhFUpUuj89g4Sj;

1.55
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.54;
commitid	h7z8lokZ0dFyuWpg;

1.54
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.53;
commitid	c7ei8kPelCOOwHXy;

1.53
date	2015.03.18.01.12.16;	author mcbride;	state Exp;
branches;
next	1.52;
commitid	Wovrw86Qlsv0Xqdi;

1.52
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.51;
commitid	zhW8jJrfVCoAthrR;

1.51
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.50;
commitid	uzzBR7hz9ncd4O6G;

1.50
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.49;
commitid	DQakU8LLWV6Iwx84;

1.49
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.48;

1.48
date	2013.12.31.03.24.44;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.10.17.16.27.44;	author bluhm;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.08.18.30.17;	author yasuoka;	state Exp;
branches;
next	1.42;

1.42
date	2011.07.05.21.40.38;	author dhill;	state Exp;
branches;
next	1.41;

1.41
date	2011.05.31.13.07.20;	author sthen;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.28.14.14.54;	author yasuoka;	state Exp;
branches;
next	1.39;

1.39
date	2010.09.24.14.50.30;	author hsuenaga;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.26.19.49.54;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.11.09.22.56;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.12.23.33.24;	author yasuoka;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.21.14.08.14;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.02.17.10.23;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.27.21.20.52;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.31.03.52.19;	author pascoe;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.08.06.16.42;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.26.21.37.09;	author pb;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.03.14.52.23;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.22.02.52.28;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.16.09.32.39;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.03.20.37.28;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.24.01.26.05;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.16.11;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.04.00.57.44;	author angelos;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.06.19.00.48.23;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.08.03.53.46;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.05.23.43.46;	author maja;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.27.09.54.21;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.09.19.59.10;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.17.18.59;	author espie;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.01.16.00.35.43;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.08.00.07.18;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.07.21.57.02;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.07.21.50.21;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.07.21.38.01;	author angelos;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.40.10;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.54.47;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@/*      $OpenBSD: ip_gre.c,v 1.64 2017/05/04 17:58:46 bluhm Exp $ */
/*	$NetBSD: ip_gre.c,v 1.9 1999/10/25 19:18:11 drochner Exp $ */

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Heiko W.Rupp <hwr@@pilhuhn.de>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * decapsulate tunneled packets and send them on
 * output half is in net/if_gre.[ch]
 * This currently handles IPPROTO_GRE, IPPROTO_MOBILE
 */


#include "gre.h"
#if NGRE > 0

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>
#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/ip_gre.h>
#include <netinet/if_ether.h>
#include <netinet/in_pcb.h>

#ifdef MPLS
#include <netmpls/mpls.h>
#endif

#include "bpfilter.h"
#include "pf.h"

#if NPF > 0
#include <net/pfvar.h>
#endif

#ifdef PIPEX
#include <net/pipex.h>
#endif

/* Needs IP headers. */
#include <net/if_gre.h>

struct gre_softc *gre_lookup(struct mbuf *, u_int8_t);
int gre_input2(struct mbuf *, int, int);

/*
 * Decapsulate.
 * Does the real work and is called from gre_input() (above)
 * returns 0 if packet is not yet processed
 * and 1 if it needs no further processing
 * proto is the protocol number of the "calling" foo_input()
 * routine.
 */

int
gre_input2(struct mbuf *m, int hlen, int proto)
{
	struct greip *gip;
	struct gre_softc *sc;
	u_short flags;
	u_int af;

	if ((sc = gre_lookup(m, proto)) == NULL) {
		/* No matching tunnel or tunnel is down. */
		return (0);
	}

	if (m->m_len < sizeof(*gip)) {
		m = m_pullup(m, sizeof(*gip));
		if (m == NULL)
			return (ENOBUFS);
	}
	gip = mtod(m, struct greip *);

	m->m_pkthdr.ph_ifidx = sc->sc_if.if_index;
	m->m_pkthdr.ph_rtableid = sc->sc_if.if_rdomain;

	sc->sc_if.if_ipackets++;
	sc->sc_if.if_ibytes += m->m_pkthdr.len;

	switch (proto) {
	case IPPROTO_GRE:
		hlen += sizeof (struct gre_h);

		/* process GRE flags as packet can be of variable len */
		flags = ntohs(gip->gi_flags);

		/* Checksum & Offset are present */
		if ((flags & GRE_CP) | (flags & GRE_RP))
			hlen += 4;

		/* We don't support routing fields (variable length) */
		if (flags & GRE_RP)
			return (0);

		if (flags & GRE_KP)
			hlen += 4;

		if (flags & GRE_SP)
			hlen += 4;

		switch (ntohs(gip->gi_ptype)) { /* ethertypes */
		case GREPROTO_WCCP:
			/* WCCP/GRE:
			 *   So far as I can see (and test) it seems that Cisco's WCCP
			 *   GRE tunnel is precisely a IP-in-GRE tunnel that differs
			 *   only in its protocol number.  At least, it works for me.
			 *
			 *   The Internet Drafts can be found if you look for
			 *   the following:
			 *     draft-forster-wrec-wccp-v1-00.txt
			 *     draft-wilson-wrec-wccp-v2-01.txt
			 *
			 *   So yes, we're doing a fall-through (unless, of course,
			 *   net.inet.gre.wccp is 0).
			 */
			if (!gre_wccp)
				return (0);
			/*
			 * For WCCPv2, additionally skip the 4 byte
			 * redirect header.
			 */
			if (gre_wccp == 2) 
				hlen += 4;
		case ETHERTYPE_IP:
			af = AF_INET;
			break;
#ifdef INET6
		case ETHERTYPE_IPV6:
			af = AF_INET6;
			break;
#endif
		case 0:
			/* keepalive reply, retrigger hold timer */
			gre_recv_keepalive(sc);
			m_freem(m);
			return (1);
#ifdef MPLS
		case ETHERTYPE_MPLS:
		case ETHERTYPE_MPLS_MCAST:
			mpls_input(m);
			return (1);
#endif
		default:	   /* others not yet supported */
			return (0);
		}
		break;
	default:
		/* others not yet supported */
		return (0);
	}

	if (hlen > m->m_pkthdr.len) {
		m_freem(m);
		return (EINVAL);
	}
	m_adj(m, hlen);

#if NBPFILTER > 0
        if (sc->sc_if.if_bpf)
		bpf_mtap_af(sc->sc_if.if_bpf, af, m, BPF_DIRECTION_IN);
#endif

#if NPF > 0
	pf_pkt_addr_changed(m);
#endif

	switch (af) {
	case AF_INET:
		ipv4_input(&sc->sc_if, m);
		break;
#ifdef INET6
	case AF_INET6:
		ipv6_input(&sc->sc_if, m);
		break;
#endif
	default:
		return (0);
	}


	return (1);	/* packet is done, no further processing needed */
}

/*
 * Decapsulate a packet and feed it back through ip_input (this
 * routine is called whenever IP gets a packet with proto type
 * IPPROTO_GRE and a local destination address).
 */
int
gre_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct mbuf *m = *mp;
	int hlen = *offp;
	int ret;

	if (!gre_allow) {
	        m_freem(m);
		return IPPROTO_DONE;
	}

#ifdef PIPEX
	if (pipex_enable) {
		struct pipex_session *session;

		if ((session = pipex_pptp_lookup_session(m)) != NULL) {
			if (pipex_pptp_input(m, session) == NULL)
				return IPPROTO_DONE;
		}
	}
#endif

	ret = gre_input2(m, hlen, proto);
	/*
	 * ret == 0: packet not processed, but input from here
	 * means no matching tunnel that is up is found.
	 * we inject it to raw ip socket to see if anyone picks it up.
	 * possible that we received a WCCPv1-style GRE packet
	 * but we're not set to accept them.
	 */
	if (!ret)
		return rip_input(mp, offp, proto, af);
	return IPPROTO_DONE;
}

/*
 * Input routine for IPPROTO_MOBILE.
 * This is a little bit different from the other modes, as the
 * encapsulating header was not prepended, but instead inserted
 * between IP header and payload.
 */

int
gre_mobile_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct mbuf *m = *mp;
	struct ip *ip;
	struct mobip_h *mip;
	struct gre_softc *sc;
	u_char osrc = 0;
	int msiz;

	if (!ip_mobile_allow) {
	        m_freem(m);
		return IPPROTO_DONE;
	}

	if ((sc = gre_lookup(m, proto)) == NULL) {
		/* No matching tunnel or tunnel is down. */
		m_freem(m);
		return IPPROTO_DONE;
	}

	if (m->m_len < sizeof(*mip)) {
		m = *mp = m_pullup(m, sizeof(*mip));
		if (m == NULL)
			return IPPROTO_DONE;
	}
	ip = mtod(m, struct ip *);
	mip = mtod(m, struct mobip_h *);

	m->m_pkthdr.ph_ifidx = sc->sc_if.if_index;

	sc->sc_if.if_ipackets++;
	sc->sc_if.if_ibytes += m->m_pkthdr.len;

	if (ntohs(mip->mh.proto) & MOB_H_SBIT) {
		osrc = 1;
		msiz = MOB_H_SIZ_L;
		mip->mi.ip_src.s_addr = mip->mh.osrc;
	} else
		msiz = MOB_H_SIZ_S;

	if (m->m_len < (ip->ip_hl << 2) + msiz) {
		m = *mp = m_pullup(m, (ip->ip_hl << 2) + msiz);
		if (m == NULL)
			return IPPROTO_DONE;
		ip = mtod(m, struct ip *);
		mip = mtod(m, struct mobip_h *);
	}

	mip->mi.ip_dst.s_addr = mip->mh.odst;
	mip->mi.ip_p = (ntohs(mip->mh.proto) >> 8);

	if (gre_in_cksum((u_short *) &mip->mh, msiz) != 0) {
		m_freem(m);
		return IPPROTO_DONE;
	}

	memmove(ip + (ip->ip_hl << 2), ip + (ip->ip_hl << 2) + msiz, 
	      m->m_len - msiz - (ip->ip_hl << 2));

	m->m_len -= msiz;
	ip->ip_len = htons(ntohs(ip->ip_len) - msiz);
	m->m_pkthdr.len -= msiz;

	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m,(ip->ip_hl << 2));

#if NBPFILTER > 0
        if (sc->sc_if.if_bpf)
		bpf_mtap_af(sc->sc_if.if_bpf, AF_INET, m, BPF_DIRECTION_IN);
#endif

#if NPF > 0
	pf_pkt_addr_changed(m);
#endif

	ipv4_input(&sc->sc_if, m);
	return IPPROTO_DONE;
}

/*
 * Find the gre interface associated with our src/dst/proto set.
 */
struct gre_softc *
gre_lookup(struct mbuf *m, u_int8_t proto)
{
	struct ip *ip = mtod(m, struct ip *);
	struct gre_softc *sc;

	LIST_FOREACH(sc, &gre_softc_list, sc_list) {
		if ((sc->g_dst.s_addr == ip->ip_src.s_addr) &&
		    (sc->g_src.s_addr == ip->ip_dst.s_addr) &&
		    (sc->g_proto == proto) &&
		    (rtable_l2(sc->g_rtableid) ==
		    rtable_l2(m->m_pkthdr.ph_rtableid)) &&
		    ((sc->sc_if.if_flags & IFF_UP) != 0))
			return (sc);
	}

	return (NULL);
}

int
gre_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
        /* All sysctl names at this level are terminal. */
        if (namelen != 1)
                return (ENOTDIR);

        switch (name[0]) {
        case GRECTL_ALLOW:
                return (sysctl_int(oldp, oldlenp, newp, newlen, &gre_allow));
        case GRECTL_WCCP:
                return (sysctl_int(oldp, oldlenp, newp, newlen, &gre_wccp));
        default:
                return (ENOPROTOOPT);
        }
        /* NOTREACHED */
}

int
ipmobile_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
        /* All sysctl names at this level are terminal. */
        if (namelen != 1)
                return (ENOTDIR);

        switch (name[0]) {
        case MOBILEIPCTL_ALLOW:
                return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ip_mobile_allow));
        default:
                return (ENOPROTOOPT);
        }
        /* NOTREACHED */
}

int
gre_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control, struct proc *p)
{
#ifdef  PIPEX 
	struct inpcb *inp = sotoinpcb(so);

	if (inp != NULL && inp->inp_pipex && req == PRU_SEND) {
		struct sockaddr_in *sin4;
		struct in_addr *ina_dst;
		struct pipex_session *session;

		ina_dst = NULL;
		if ((so->so_state & SS_ISCONNECTED) != 0) {
			inp = sotoinpcb(so);
			if (inp)
				ina_dst = &inp->inp_laddr;
		} else if (nam) {
			sin4 = mtod(nam, struct sockaddr_in *);
			if (nam->m_len == sizeof(struct sockaddr_in) &&
			    sin4->sin_family == AF_INET)
				ina_dst = &sin4->sin_addr;
		}
		if (ina_dst != NULL &&
		    (session = pipex_pptp_userland_lookup_session_ipv4(m,
			    *ina_dst)))
			m = pipex_pptp_userland_output(m, session);

		if (m == NULL)
			return (ENOMEM);
	}
#endif
	return rip_usrreq(so, req, m, nam, control, p);
}
#endif /* if NGRE > 0 */
@


1.64
log
@If m is not a continuous mbuf cluster, m_pullup() in pr_input may
change the pointer.  Then *mp keeps the invalid pointer and it might
be used.  Fix the potential use after free and also reset *mp in
other places to have less dangling pointers to freed mbufs.
OK mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.63 2017/04/14 20:46:31 bluhm Exp $ */
a95 1
	struct niqueue *ifq;
d162 1
a162 2
		case ETHERTYPE_IP: /* shouldn't need a schednetisr(), as */
			ifq = &ipintrq;          /* we are in ip_input */
a166 1
		        ifq = &ip6intrq;
d205 13
a217 1
	niq_enqueue(ifq, m);
d346 1
a346 1
	niq_enqueue(&ipintrq, m);
@


1.63
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.62 2017/01/29 19:58:47 bluhm Exp $ */
d283 1
a283 1
		m = m_pullup(m, sizeof(*mip));
d303 1
a303 1
		m = m_pullup(m, (ip->ip_hl << 2) + msiz);
@


1.62
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.61 2017/01/25 17:34:31 bluhm Exp $ */
d219 1
a219 1
gre_input(struct mbuf **mp, int *offp, int proto)
d250 1
a250 1
		return rip_input(mp, offp, proto);
d262 1
a262 1
gre_mobile_input(struct mbuf **mp, int *offp, int proto)
@


1.61
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.60 2017/01/03 10:52:21 mpi Exp $ */
d218 2
a219 2
void
gre_input(struct mbuf *m, int hlen, int proto)
d221 2
d227 1
a227 1
		return;
d236 1
a236 1
				return;
d250 2
a251 1
		rip_input(m, hlen, proto);
d261 2
a262 2
void
gre_mobile_input(struct mbuf *m, int hlen, int proto)
d264 1
d273 1
a273 1
		return;
d279 1
a279 1
		return;
d285 1
a285 1
			return;
d305 1
a305 1
			return;
d315 1
a315 1
		return;
d338 1
@


1.60
log
@Remove some recursives splsoftnet().

ok visa@@, mikeb@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.59 2016/03/04 22:38:23 sashan Exp $ */
d81 1
a81 1
int gre_input2(struct mbuf *, int, u_char);
d93 1
a93 1
gre_input2(struct mbuf *m, int hlen, u_char proto)
d219 1
a219 1
gre_input(struct mbuf *m, ...)
d221 1
a221 6
	int hlen, ret;
	va_list ap;

	va_start(ap, m);
	hlen = va_arg(ap, int);
	va_end(ap);
d239 1
a239 1
	ret = gre_input2(m, hlen, IPPROTO_GRE);
d248 1
a248 1
		rip_input(m, hlen, IPPROTO_GRE);
d259 1
a259 1
gre_mobile_input(struct mbuf *m, ...)
a263 2
	int hlen;
	va_list ap;
a266 4
	va_start(ap, m);
	hlen = va_arg(ap, int);
	va_end(ap);

d272 1
a272 1
	if ((sc = gre_lookup(m, IPPROTO_MOBILE)) == NULL) {
@


1.59
log
@- putting back KASSERT(), which I've backed out on Jan 31
  We don't expect inbound packets to come to PF with statekey attached.

- I've also found missing call to pf_pkt_addr_changed() at various
  places, which needs to get fixed to prevent KASSERT() from firing.

OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.58 2015/12/02 08:47:00 claudio Exp $ */
a413 1
		int s;
a417 1
		s = splsoftnet();
a432 1
		splx(s);
@


1.58
log
@Rework the MPLS handling. Remove the lookup loops since nothing is using
them and they make everything so much harder with no gain. Remove the
ifp argument from mpls_input since it is not needed. On the input side
the lookup side is modified a bit when it comes to BOS handling.
Tested in a L3VPN setup with ldpd and bgpd. Commiting now so we can move
on with cleaning up rt_ifp usage. If this breaks L2VPN I will fix it once
reported. OK mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.57 2015/07/29 00:04:03 rzalamena Exp $ */
d338 4
@


1.57
log
@Don't use mpls_input() as input handler anymore and instead call it
directly. Also protect non mp-safe functions while at it.

ok mpi@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.56 2015/07/20 21:16:39 rzalamena Exp $ */
d181 1
a181 1
			mpls_input(&sc->sc_if, m);
@


1.56
log
@Kill NETISR_MPLS, from now on we will use interface input handlers to deal
with MPLS packets.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.55 2015/06/16 11:09:40 mpi Exp $ */
a99 2
	int s;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
d181 2
a182 11
			if ((sc->sc_if.if_xflags & IFXF_MPLS) == 0) {
				m_freem(m);
				return (0);
			}

			ml_enqueue(&ml, m);

			s = splnet();
			if_input(&sc->sc_if, &ml);
			splx(s);
			return (0);
@


1.55
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.54 2015/04/10 13:58:20 dlg Exp $ */
d100 2
d183 11
a193 3
			ifq = &mplsintrq;
			af = AF_MPLS;
			break;
@


1.54
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.53 2015/03/18 01:12:16 mcbride Exp $ */
d113 1
a113 1
	m->m_pkthdr.rcvif = &sc->sc_if;
d298 1
a298 1
	m->m_pkthdr.rcvif = &sc->sc_if;
@


1.53
log
@"handle" wccp2 packets if net.inet.gre.wccp is set to 2 by truncating
skipping the wccp 2 header. Tested with Cisco ASA.

"looks correct" claudio
ok yasuoka
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.52 2014/12/19 17:14:40 tedu Exp $ */
d96 1
a96 2
	int s;
	struct ifqueue *ifq;
a169 1
			schednetisr(NETISR_IPV6);
a181 1
			schednetisr(NETISR_MPLS);
d209 1
a209 3
	s = splnet();		/* possible */
	IF_INPUT_ENQUEUE(ifq, m);
	splx(s);
a268 1
	struct ifqueue *ifq;
d270 1
a270 1
	int hlen, s;
a335 2
	ifq = &ipintrq;

d341 1
a341 3
	s = splnet();       /* possible */
	IF_INPUT_ENQUEUE(ifq, m);
	splx(s);
@


1.52
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.51 2014/09/14 14:17:26 jsg Exp $ */
d148 2
a149 1
			 *   The Internet Draft can be found if you look for
d151 1
d158 6
@


1.51
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.50 2014/07/22 11:06:10 mpi Exp $ */
a54 1
#ifdef INET
a60 3
#else
#error "ip_gre used without inet"
#endif
@


1.50
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.49 2014/04/14 09:06:42 mpi Exp $ */
a48 1
#include <sys/proc.h>
@


1.49
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.48 2013/12/31 03:24:44 tedu Exp $ */
a57 1
#include <netinet/in_systm.h>
@


1.48
log
@bcopy -> memcpy. reviewed with one fix from matthew
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.47 2013/10/24 11:31:43 mpi Exp $ */
d121 1
a121 1
	m->m_pkthdr.rdomain = sc->sc_if.if_rdomain;
d366 1
a366 1
		    rtable_l2(m->m_pkthdr.rdomain)) &&
@


1.47
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.46 2013/10/23 15:12:42 mpi Exp $ */
d330 1
a330 1
	bcopy(ip + (ip->ip_hl << 2) + msiz, ip + (ip->ip_hl << 2),
@


1.46
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.45 2013/10/17 16:27:44 bluhm Exp $ */
a65 4
#endif

#ifdef INET6
#include <netinet6/in6_var.h>
@


1.45
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.44 2011/07/09 00:47:18 henning Exp $ */
a57 1
#include <netinet/in_var.h>
@


1.44
log
@begone, fucking rotten appletalk shit. ok room
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.43 2011/07/08 18:30:17 yasuoka Exp $ */
d67 4
@


1.43
log
@Include PIPEX in kernel by default.  And add new sysctl variable
`net.pipex.enable' to enable PIPEX.   By default, pipex is disabled
and it will not process packets from wire.  Update man pages and
update HOWTO_PIPEX_NPPPD.txt for testers.

discussed with dlg@@, ok deraadt@@ mcbride@@ claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.42 2011/07/05 21:40:38 dhill Exp $ */
a68 6
#ifdef NETATALK
#include <netatalk/at.h>
#include <netatalk/at_var.h>
#include <netatalk/at_extern.h>
#endif

a166 7
#ifdef NETATALK
		case ETHERTYPE_AT:
			ifq = &atintrq1;
			schednetisr(NETISR_ATALK);
			af = AF_APPLETALK;
			break;
#endif
@


1.42
log
@ansify

ok claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.41 2011/05/31 13:07:20 sthen Exp $ */
d252 2
a253 2
    {
	struct pipex_session *session;
d255 4
a258 3
	if ((session = pipex_pptp_lookup_session(m)) != NULL) {
		if (pipex_pptp_input(m, session) == NULL)
			return;
a259 1
    }
@


1.41
log
@fix typos in comment
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.40 2010/09/28 14:14:54 yasuoka Exp $ */
d106 1
a106 4
gre_input2(m , hlen, proto)
        struct mbuf *m;
	int hlen;
	u_char proto;
d370 1
a370 3
gre_lookup(m, proto)
	struct mbuf *m;
	u_int8_t proto;
d389 2
a390 7
gre_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
        int *name;
        u_int namelen;
        void *oldp;
        size_t *oldlenp;
        void *newp;
        size_t newlen;
d408 2
a409 7
ipmobile_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
        int *name;
        u_int namelen;
        void *oldp;
        size_t *oldlenp;
        void *newp;
        size_t newlen;
@


1.40
log
@wrap long line.  correct indent.  delete a useless comment.

OK djm@@ claudio@@ dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.39 2010/09/24 14:50:30 hsuenaga Exp $ */
d278 2
a279 2
 * Input routine for IPPRPOTO_MOBILE.
 * This is a little bit diffrent from the other modes, as the
@


1.39
log
@Add L2TP support to PIPEX.
We can use IPv6 address as outer header of L2TP.

Kernel ABI is changed. You must update npppd.

OK @@claudio, yasuoka@@, dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.38 2010/06/26 19:49:54 claudio Exp $ */
d466 2
a467 1
		    (session = pipex_pptp_userland_lookup_session_ipv4(m, *ina_dst)))
@


1.38
log
@Implement a simple keepalive mechanism in gre(4) that is compatible with
the one used by Cisco. It sends a return gre packet inside a gre packet
to the other side and expects it to return.
OK deraadt, reyk additional testing by sthen
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.37 2010/05/11 09:22:56 claudio Exp $ */
d445 3
a447 1
	if (req == PRU_SEND) {
a448 1
		struct inpcb *inp;
d466 1
a466 1
		    (session = pipex_pptp_userland_lookup_session(m, *ina_dst)))
@


1.37
log
@Add support for MPLS in GRE. Fairly trivial and a NOP unless option MPLS
is defined.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.36 2010/04/20 22:05:43 tedu Exp $ */
d190 5
@


1.36
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.35 2010/01/12 23:33:24 yasuoka Exp $ */
d75 4
d189 9
a197 1
#endif /* INET6 */
@


1.35
log
@Add input and user protocol hook to handle GRE packets by pipex.

ok @@dlg
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.34 2009/11/21 14:08:14 claudio Exp $ */
d49 1
@


1.34
log
@Add a way to bind the tunnel endpoint of a gif/gre interface into a
different rdomain than the default one. This allows to do MPLS VPNs
without the MPLS madness.  OK deraadt@@, henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.33 2009/06/02 17:10:23 henning Exp $ */
d46 1
d48 1
d63 1
d81 4
d236 11
d420 36
@


1.33
log
@do the pf_pkt_addr_changed(m) magic just like gif etc
tested by Manuel Rodriguez Morales <marodriguez at grupogdt.com>
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.32 2008/06/26 05:42:20 ray Exp $ */
d119 1
d197 1
d348 2
@


1.32
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.31 2007/05/27 21:20:52 claudio Exp $ */
d72 5
d195 3
@


1.31
log
@De-static. OK dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.30 2007/04/10 17:47:55 miod Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.30
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.29 2006/03/25 22:41:48 djm Exp $ */
d84 1
a84 1
static int gre_input2(struct mbuf *, int, u_char);
d95 1
a95 1
static int
@


1.29
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.28 2006/03/04 22:40:16 brad Exp $ */
d151 1
a151 1
			 *   only in it's protocol number.  At least, it works for me.
@


1.28
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.27 2005/07/31 03:52:19 pascoe Exp $ */
d196 1
a196 1
		bpf_mtap_af(sc->sc_if.if_bpf, af, m);
d322 1
a322 1
		bpf_mtap_af(sc->sc_if.if_bpf, AF_INET, m);
@


1.27
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.26 2005/06/08 06:16:42 henning Exp $ */
d199 1
a199 1
	s = splimp();		/* possible */
d325 1
a325 1
	s = splimp();       /* possible */
@


1.26
log
@netns bites the dust
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.25 2004/06/26 21:37:09 pb Exp $ */
d195 2
a196 17
        if (sc->sc_if.if_bpf) {
                /*
                 * We need to prepend the address family as
                 * a four byte field.  Cons up a fake header
                 * to pacify bpf.  This is safe because bpf
                 * will only read from the mbuf (i.e., it won't
                 * try to free it or keep a pointer a to it).
                 */
                struct mbuf m0;

		m0.m_flags = 0;
                m0.m_next = m;
                m0.m_len = 4;
                m0.m_data = (char *) &af;

                bpf_mtap(sc->sc_if.if_bpf, &m0);
        }
d321 2
a322 18
        if (sc->sc_if.if_bpf) {
                /*
                 * We need to prepend the address family as
                 * a four byte field.  Cons up a fake header
                 * to pacify bpf.  This is safe because bpf
                 * will only read from the mbuf (i.e., it won't
                 * try to free it or keep a pointer a to it).
                 */
                struct mbuf m0;
		u_int af = AF_INET;

		m0.m_flags = 0;
                m0.m_next = m;
                m0.m_len = 4;
                m0.m_data = (char *) &af;

                bpf_mtap(sc->sc_if.if_bpf, &m0);
        }
@


1.25
log
@use IF_INPUT_ENQUEUE

ok henning@@, mcbride@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.24 2003/12/10 07:22:43 itojun Exp $ */
a71 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a164 7
#ifdef NS
		case ETHERTYPE_NS:
			ifq = &nsintrq;
			schednetisr(NETISR_NS);
			af = AF_NS;
			break;
#endif
@


1.24
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.23 2003/12/03 14:52:23 markus Exp $ */
d227 1
a227 6
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
	} else {
		IF_ENQUEUE(ifq, m);
	}
d369 1
a369 6
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
	} else {
		IF_ENQUEUE(ifq, m);
	}
@


1.23
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.22 2003/07/09 22:03:16 itojun Exp $ */
d106 3
a108 3
	register struct greip *gip;
	register int s;
	register struct ifqueue *ifq;
d246 1
a246 1
	register int hlen, ret;
d280 3
a282 3
	register struct ip *ip;
	register struct mobip_h *mip;
	register struct ifqueue *ifq;
d284 1
a284 1
	register int hlen, s;
@


1.22
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.21 2003/05/03 01:43:07 itojun Exp $ */
a392 1
	int i;
d394 1
a394 1
	for (i = 0, sc = gre; i < ngre; i++, sc++) {
@


1.21
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.20 2003/04/22 02:52:28 itojun Exp $ */
d344 1
a344 2
	ip->ip_len -= msiz;
	HTONS(ip->ip_len);
@


1.20
log
@correct (false) assumption made about m->m_len.  dhartmei ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.19 2002/08/16 09:32:39 itojun Exp $ */
d217 1
d365 1
@


1.19
log
@pass unprocessed GRE packet to raw ip socket.  binkertn@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.18 2002/06/09 16:26:10 itojun Exp $ */
d106 1
a106 1
	register struct greip *gip = mtod(m, struct greip *);
d118 7
d200 5
a204 3
	m->m_data += hlen;
	m->m_len -= hlen;
	m->m_pkthdr.len -= hlen;
d245 1
a245 1
	register int hlen,ret;
d279 2
a280 2
	register struct ip *ip = mtod(m, struct ip *);
	register struct mobip_h *mip = mtod(m, struct mobip_h *);
d283 1
a283 1
	register int hlen,s;
d288 1
a288 1
	va_start(ap,m);
d303 8
d316 1
a316 1
	if(ntohs(mip->mh.proto) & MOB_H_SBIT) {
d320 1
a320 1
	} else {
d322 7
d330 1
d334 1
a334 1
	if (gre_in_cksum((u_short *) &mip->mh,msiz) != 0) {
@


1.18
log
@whitespace
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.17 2002/04/03 20:37:28 angelos Exp $ */
d65 1
d251 2
a252 2
	 * means no matching tunnel that is up is found,
	 * so we can just free the mbuf and return.  It is also
d257 1
a257 1
		m_freem(m);
@


1.17
log
@Don't process WCCPv1-style GRE packets, unless allowed (via sysctl
variable); GRE processing must also be allowed. From
joeycoleman@@acm.org, ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.16 2002/03/24 01:26:05 angelos Exp $ */
d26 1
a26 1
 *    
d93 1
a93 1
 * returns 0 if packet is not yet processed 
d191 2
a192 2
		
	m->m_data += hlen; 
d246 1
a246 1
	
d248 2
a249 2
	/* 
 	 * ret == 0: packet not processed, but input from here
d261 1
a261 1
 * This is a little bit diffrent from the other modes, as the 
d295 1
a295 1
	sc->sc_if.if_ipackets++;  
d307 1
a307 1
	
d350 2
a351 2
	} else { 
		IF_ENQUEUE(ifq, m);  
d391 1
a391 1
 
d415 1
a415 1
 
@


1.16
log
@WCCP support (trivial hack, it's not the complete protocol, but it'll
accept packets from Cisco boxes) --- from joeycoleman@@acm.org
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.15 2002/03/15 18:19:52 millert Exp $ */
d153 2
a154 1
			 *   So yes, we're doing a fall-through.
d156 2
d189 1
a189 1
		return(0);
d251 3
a253 1
	 * so we can just free the mbuf and return
d395 2
@


1.15
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.14 2002/03/14 03:16:11 millert Exp $ */
d144 11
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.13 2002/03/14 01:27:11 millert Exp $ */
a218 1
#if __STDC__
a219 5
#else
gre_input(m, va_alist)
        struct mbuf *m;
        va_dcl
#endif
a250 1
#if __STDC__
a251 5
#else
gre_mobile_input(m, va_alist)
        struct mbuf *m;
        va_dcl
#endif
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.12 2001/09/04 00:57:44 angelos Exp $ */
d304 1
a304 1
	if (gre_in_cksum((u_short*) &mip->mh,msiz) != 0) {
@


1.12
log
@Make it compile without option BPF.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.11 2001/06/19 00:48:23 deraadt Exp $ */
d87 2
a88 2
struct gre_softc *gre_lookup __P((struct mbuf *, u_int8_t));
static int gre_input2 __P((struct mbuf *, int, u_char));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.12 2001/09/04 00:57:44 angelos Exp $ */
d87 2
a88 2
struct gre_softc *gre_lookup(struct mbuf *, u_int8_t);
static int gre_input2(struct mbuf *, int, u_char);
a143 14
		case GREPROTO_WCCP:
			/* WCCP/GRE:
			 *   So far as I can see (and test) it seems that Cisco's WCCP
			 *   GRE tunnel is precisely a IP-in-GRE tunnel that differs
			 *   only in it's protocol number.  At least, it works for me.
			 *
			 *   The Internet Draft can be found if you look for
			 *     draft-forster-wrec-wccp-v1-00.txt
			 *
			 *   So yes, we're doing a fall-through (unless, of course,
			 *   net.inet.gre.wccp is 0).
			 */
			if (!gre_wccp)
				return (0);
d175 1
a175 1
		return (0);
d219 1
d221 5
d243 1
a243 3
	 * so we can just free the mbuf and return.  It is also
	 * possible that we received a WCCPv1-style GRE packet
	 * but we're not set to accept them.
d257 1
d259 5
d304 1
a304 1
	if (gre_in_cksum((u_short *) &mip->mh,msiz) != 0) {
a390 2
        case GRECTL_WCCP:
                return (sysctl_int(oldp, oldlenp, newp, newlen, &gre_wccp));
@


1.12.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.12.4.1 2002/06/11 03:31:36 art Exp $ */
d26 1
a26 1
 *
a64 1
#include <netinet/ip_var.h>
d93 1
a93 1
 * returns 0 if packet is not yet processed
d191 2
a192 2

	m->m_data += hlen;
d246 1
a246 1

d248 4
a251 4
	/*
	 * ret == 0: packet not processed, but input from here
	 * means no matching tunnel that is up is found.
	 * we inject it to raw ip socket to see if anyone picks it up.
d256 1
a256 1
		rip_input(m, hlen, IPPROTO_GRE);
d261 1
a261 1
 * This is a little bit diffrent from the other modes, as the
d295 1
a295 1
	sc->sc_if.if_ipackets++;
d307 1
a307 1

d350 2
a351 2
	} else {
		IF_ENQUEUE(ifq, m);
d391 1
a391 1

d415 1
a415 1

@


1.12.4.3
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d106 1
a106 1
	register struct greip *gip;
a117 7
	if (m->m_len < sizeof(*gip)) {
		m = m_pullup(m, sizeof(*gip));
		if (m == NULL)
			return (ENOBUFS);
	}
	gip = mtod(m, struct greip *);

d193 3
a195 5
	if (hlen > m->m_pkthdr.len) {
		m_freem(m);
		return (EINVAL);
	}
	m_adj(m, hlen);
a207 1
		m0.m_flags = 0;
d236 1
a236 1
	register int hlen, ret;
d270 2
a271 2
	register struct ip *ip;
	register struct mobip_h *mip;
d274 1
a274 1
	register int hlen, s;
d279 1
a279 1
	va_start(ap, m);
a293 8
	if (m->m_len < sizeof(*mip)) {
		m = m_pullup(m, sizeof(*mip));
		if (m == NULL)
			return;
	}
	ip = mtod(m, struct ip *);
	mip = mtod(m, struct mobip_h *);

d299 1
a299 1
	if (ntohs(mip->mh.proto) & MOB_H_SBIT) {
d303 1
a303 1
	} else
a304 7

	if (m->m_len < (ip->ip_hl << 2) + msiz) {
		m = m_pullup(m, (ip->ip_hl << 2) + msiz);
		if (m == NULL)
			return;
		ip = mtod(m, struct ip *);
		mip = mtod(m, struct mobip_h *);
a305 1

d309 1
a309 1
	if (gre_in_cksum((u_short *) &mip->mh, msiz) != 0) {
a338 1
		m0.m_flags = 0;
@


1.11
log
@mop up after angelos
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.10 2001/06/08 03:53:46 angelos Exp $ */
a272 1
	u_int af = AF_INET;
d332 1
@


1.10
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.9 2001/06/05 23:43:46 maja Exp $ */
d51 1
@


1.9
log
@Allow boot -c to change number of gre devices. -moj ok angelos@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.8 2001/02/27 09:54:21 niklas Exp $ */
a50 1
#include <sys/systm.h>
a58 2
#include <machine/cpu.h>

a84 2

#include <machine/stdarg.h>
@


1.8
log
@Remove superfluous printf in Angelos last commit
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.7 2001/02/09 19:59:10 angelos Exp $ */
d368 1
a368 2
	for (i = 0; i < NGRE; i++) {
		sc = &gre_softc[i];
@


1.7
log
@Fix BPF support.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.6 2000/01/25 17:18:59 espie Exp $ */
a121 1
	printf("%s\n", sc->sc_if.if_xname);
@


1.6
log
@Ok, so setsoftnet is md.

Well, on the amiga, setsoftnet *REQUIRES* machine/cpu.h to work...
and no include mentioned in those files pulls machine/cpu.h...

Nit-fix: / * INET6 */ -> /* INET6 */
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.5 2000/01/16 00:35:43 angelos Exp $ */
d58 1
d84 2
d92 1
d104 4
a107 1
gre_input2(struct mbuf *m ,int hlen,u_char proto)
d114 1
d121 3
d151 1
d157 1
d164 1
d171 1
d187 2
a188 2
#if NBPFILTER >0
        if (sc->sc_if->if_bpf) {
a196 1
                u_int af = dst->sa_family;
d202 1
a202 1
                bpf_mtap(sc->sc_if->if_bpf, &m0);
d278 1
d295 2
d328 2
a329 2
#if NBPFILTER >0
        if (sc->sc_if->if_bpf) {
a337 1
                u_int af = dst->sa_family;
d343 1
a343 1
                bpf_mtap(sc->sc_if->if_bpf, &m0);
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.8 2001/02/27 09:54:21 niklas Exp $ */
a57 1
#include <net/bpf.h>
a82 2
#include "bpfilter.h"

a88 1
static int gre_input2 __P((struct mbuf *, int, u_char));
d100 1
a100 4
gre_input2(m , hlen, proto)
        struct mbuf *m;
	int hlen;
	u_char proto;
a106 1
	u_int af;
a112 2
	m->m_pkthdr.rcvif = &sc->sc_if;

a139 1
			af = AF_INET;
a144 1
			af = AF_NS;
a150 1
			af = AF_APPLETALK;
a156 1
			af = AF_INET6;
d172 2
a173 2
#if NBPFILTER > 0
        if (sc->sc_if.if_bpf) {
d182 1
d188 1
a188 1
                bpf_mtap(sc->sc_if.if_bpf, &m0);
a263 1
	u_int af = AF_INET;
a279 2
	m->m_pkthdr.rcvif = &sc->sc_if;

d311 2
a312 2
#if NBPFILTER > 0
        if (sc->sc_if.if_bpf) {
d321 1
d327 1
a327 1
                bpf_mtap(sc->sc_if.if_bpf, &m0);
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.6.2.1 2001/05/14 22:40:10 niklas Exp $ */
d60 2
d89 2
d368 2
a369 1
	for (i = 0, sc = gre; i < ngre; i++, sc++) {
@


1.6.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.6.2.2 2001/07/04 10:54:47 niklas Exp $ */
d273 1
a332 1
		u_int af = AF_INET;
@


1.6.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d87 2
a88 2
struct gre_softc *gre_lookup(struct mbuf *, u_int8_t);
static int gre_input2(struct mbuf *, int, u_char);
d219 1
d221 5
d257 1
d259 5
d304 1
a304 1
	if (gre_in_cksum((u_short *) &mip->mh,msiz) != 0) {
@


1.6.2.5
log
@Sync the SMP branch with 3.3
@
text
@d26 1
a26 1
 *
a64 1
#include <netinet/ip_var.h>
d93 1
a93 1
 * returns 0 if packet is not yet processed
a143 14
		case GREPROTO_WCCP:
			/* WCCP/GRE:
			 *   So far as I can see (and test) it seems that Cisco's WCCP
			 *   GRE tunnel is precisely a IP-in-GRE tunnel that differs
			 *   only in it's protocol number.  At least, it works for me.
			 *
			 *   The Internet Draft can be found if you look for
			 *     draft-forster-wrec-wccp-v1-00.txt
			 *
			 *   So yes, we're doing a fall-through (unless, of course,
			 *   net.inet.gre.wccp is 0).
			 */
			if (!gre_wccp)
				return (0);
d175 1
a175 1
		return (0);
d177 2
a178 2

	m->m_data += hlen;
d232 1
a232 1

d234 4
a237 6
	/*
	 * ret == 0: packet not processed, but input from here
	 * means no matching tunnel that is up is found.
	 * we inject it to raw ip socket to see if anyone picks it up.
	 * possible that we received a WCCPv1-style GRE packet
	 * but we're not set to accept them.
d240 1
a240 1
		rip_input(m, hlen, IPPROTO_GRE);
d245 1
a245 1
 * This is a little bit diffrent from the other modes, as the
d279 1
a279 1
	sc->sc_if.if_ipackets++;
d291 1
a291 1

d334 2
a335 2
	} else {
		IF_ENQUEUE(ifq, m);
d375 1
a375 1

a378 2
        case GRECTL_WCCP:
                return (sysctl_int(oldp, oldlenp, newp, newlen, &gre_wccp));
d397 1
a397 1

@


1.6.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.6.2.5 2003/03/28 00:06:54 niklas Exp $ */
d106 1
a106 1
	register struct greip *gip;
a117 7
	if (m->m_len < sizeof(*gip)) {
		m = m_pullup(m, sizeof(*gip));
		if (m == NULL)
			return (ENOBUFS);
	}
	gip = mtod(m, struct greip *);

d193 3
a195 5
	if (hlen > m->m_pkthdr.len) {
		m_freem(m);
		return (EINVAL);
	}
	m_adj(m, hlen);
a207 1
		m0.m_flags = 0;
d236 1
a236 1
	register int hlen, ret;
d270 2
a271 2
	register struct ip *ip;
	register struct mobip_h *mip;
d274 1
a274 1
	register int hlen, s;
d279 1
a279 1
	va_start(ap, m);
a293 8
	if (m->m_len < sizeof(*mip)) {
		m = m_pullup(m, sizeof(*mip));
		if (m == NULL)
			return;
	}
	ip = mtod(m, struct ip *);
	mip = mtod(m, struct mobip_h *);

d299 1
a299 1
	if (ntohs(mip->mh.proto) & MOB_H_SBIT) {
d303 1
a303 1
	} else
a304 7

	if (m->m_len < (ip->ip_hl << 2) + msiz) {
		m = m_pullup(m, (ip->ip_hl << 2) + msiz);
		if (m == NULL)
			return;
		ip = mtod(m, struct ip *);
		mip = mtod(m, struct mobip_h *);
a305 1

d309 1
a309 1
	if (gre_in_cksum((u_short *) &mip->mh, msiz) != 0) {
a338 1
		m0.m_flags = 0;
@


1.6.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d106 3
a108 3
	struct greip *gip;
	int s;
	struct ifqueue *ifq;
d246 1
a246 1
	int hlen, ret;
d280 3
a282 3
	struct ip *ip;
	struct mobip_h *mip;
	struct ifqueue *ifq;
d284 1
a284 1
	int hlen, s;
d344 2
a345 1
	ip->ip_len = htons(ntohs(ip->ip_len) - msiz);
d394 1
d396 1
a396 1
	LIST_FOREACH(sc, &gre_softc_list, sc_list) {
@


1.5
log
@ETHERTYPE_ATALK -> ETHERTYPE_AT (op21@@squish.org)
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.4 2000/01/08 00:07:18 angelos Exp $ */
d58 2
@


1.4
log
@Incoming bpf tap.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.3 2000/01/07 21:57:02 angelos Exp $ */
d146 1
a146 1
		case ETHERTYPE_ATALK:
@


1.3
log
@Remove unused include files.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.2 2000/01/07 21:50:21 angelos Exp $ */
d170 20
d308 20
@


1.2
log
@Missing sysctl.h include
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_gre.c,v 1.1 2000/01/07 21:38:01 angelos Exp $ */
d41 1
a41 1
 * deencapsulate tunneled packets and send them on
a53 7
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
a57 1
#include <net/raw_cb.h>
a63 1
#include <netinet/ip_var.h>
@


1.1
log
@GRE/MobileIP input routine processing, from NetBSD (with a few
changes). Also, minor cleanup in in_proto.c
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d61 1
@

