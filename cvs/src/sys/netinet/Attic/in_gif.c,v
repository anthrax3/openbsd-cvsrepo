head	1.47;
access;
symbols
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.39.0.14
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.10
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.8
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.6
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.38.0.4
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.36.0.4
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.8
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.6
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.4
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.30.0.8
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.4
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.26
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.47
date	2015.09.28.08.32.05;	author mpi;	state dead;
branches;
next	1.46;
commitid	MCjArMsyMPhqxF1g;

1.46
date	2015.08.14.18.07.28;	author bluhm;	state Exp;
branches;
next	1.45;
commitid	mu9yDScTa557hRQD;

1.45
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.44;
commitid	h7z8lokZ0dFyuWpg;

1.44
date	2015.05.12.12.27.17;	author mpi;	state Exp;
branches;
next	1.43;
commitid	4yX3v2RRayuqFsNr;

1.43
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.42;
commitid	p4LJxGKbi0BU2cG6;

1.42
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.41;
commitid	t9FBKDfc4VDxpEy2;

1.41
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.40;
commitid	DQakU8LLWV6Iwx84;

1.40
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.19.17.55.37;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.11.09.36.07;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.21.14.08.14;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.02.17.01.20;	author blambert;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.28.16.14.40;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.28.15.25.32;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.15.22.40.02;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.10.15.34.22;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.23.13.01.23;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.03.14.51.05;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.28.10.10.16;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.30.04.19.44;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.07.09.32.45;	author itojun;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.08.19.06.31.56;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.27.15.48.38;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.08.10.37.46;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.08.03.53.45;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.30.12.30.02;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.14.00.30.58;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.16.08.48.04;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.31.17.23.35;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.31.17.20.14;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.30.21.50.46;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.30.19.03.38;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.25.01.22.00;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.07.06.18.44;	author itojun;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.01.21.03.15.04;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.11.07.47.09;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.07.00.57.54;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.12.28.07.17.38;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	99.12.21.09.00.50;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.09.03.45.21;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.40.08;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.54.32;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Merge gif(4)'s tentacles in a single file.

Tested by <mxb AT alumni DOT chalmers DOT se>.

ok dlg@@
@
text
@/*	$OpenBSD: in_gif.c,v 1.46 2015/08/14 18:07:28 bluhm Exp $	*/
/*	$KAME: in_gif.c,v 1.50 2001/01/22 07:27:16 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/socket.h>
#include <sys/mbuf.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>
#include <net/if_gif.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/in_gif.h>
#include <netinet/ip_ipsp.h>

#include "gif.h"
#include "bridge.h"
#if NBRIDGE > 0 || defined(MPLS)
#include <netinet/ip_ether.h>
#endif

#if NPF > 0
#include <net/pfvar.h>
#endif

int
in_gif_output(struct ifnet *ifp, int family, struct mbuf **m0)
{
	struct gif_softc *sc = (struct gif_softc*)ifp;
	struct sockaddr_in *sin_src = satosin(sc->gif_psrc);
	struct sockaddr_in *sin_dst = satosin(sc->gif_pdst);
	struct tdb tdb;
	struct xformsw xfs;
	int error;
	struct mbuf *m = *m0;

	if (sin_src == NULL || sin_dst == NULL ||
	    sin_src->sin_family != AF_INET ||
	    sin_dst->sin_family != AF_INET) {
		m_freem(m);
		return EAFNOSUPPORT;
	}

#ifdef DIAGNOSTIC
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid)) {
		printf("%s: trying to send packet on wrong domain. "
		    "if %d vs. mbuf %d, AF %d\n", ifp->if_xname,
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.ph_rtableid),
		    family);
	}
#endif

	/* setup dummy tdb.  it highly depends on ipip_output() code. */
	bzero(&tdb, sizeof(tdb));
	bzero(&xfs, sizeof(xfs));
	tdb.tdb_src.sin.sin_family = AF_INET;
	tdb.tdb_src.sin.sin_len = sizeof(struct sockaddr_in);
	tdb.tdb_src.sin.sin_addr = sin_src->sin_addr;
	tdb.tdb_dst.sin.sin_family = AF_INET;
	tdb.tdb_dst.sin.sin_len = sizeof(struct sockaddr_in);
	tdb.tdb_dst.sin.sin_addr = sin_dst->sin_addr;
	tdb.tdb_xform = &xfs;
	xfs.xf_type = -1;	/* not XF_IP4 */

	switch (family) {
	case AF_INET:
		break;
#ifdef INET6
	case AF_INET6:
		break;
#endif
#if NBRIDGE > 0
	case AF_LINK:
		break;
#endif
#if MPLS
	case AF_MPLS:
		break;
#endif
	default:
#ifdef DEBUG
	        printf("in_gif_output: warning: unknown family %d passed\n",
			family);
#endif
		m_freem(m);
		return EAFNOSUPPORT;
	}

	/* encapsulate into IPv4 packet */
	*m0 = NULL;
#if NBRIDGE > 0
	if (family == AF_LINK)
		error = etherip_output(m, &tdb, m0, IPPROTO_ETHERIP);
	else
#endif /* NBRIDGE */
#ifdef MPLS
	if (family == AF_MPLS)
		error = etherip_output(m, &tdb, m0, IPPROTO_MPLS);
	else
#endif
	error = ipip_output(m, &tdb, m0, 0, 0);
	if (error)
		return error;
	else if (*m0 == NULL)
		return EFAULT;

	m = *m0;

	m->m_pkthdr.ph_rtableid = sc->gif_rtableid;
#if NPF > 0
	pf_pkt_addr_changed(m);
#endif
	return 0;
}

void
in_gif_input(struct mbuf *m, ...)
{
	int off;
	struct gif_softc *sc;
	struct ifnet *gifp = NULL;
	struct ip *ip;
	va_list ap;

	va_start(ap, m);
	off = va_arg(ap, int);
	va_end(ap);

	/* IP-in-IP header is caused by tunnel mode, so skip gif lookup */
	if (m->m_flags & M_TUNNEL) {
		m->m_flags &= ~M_TUNNEL;
		goto inject;
	}

	ip = mtod(m, struct ip *);

	/* this code will be soon improved. */
	LIST_FOREACH(sc, &gif_softc_list, gif_list) {
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
		    sc->gif_psrc->sa_family != AF_INET ||
		    sc->gif_pdst->sa_family != AF_INET ||
		    rtable_l2(sc->gif_rtableid) !=
		    rtable_l2(m->m_pkthdr.ph_rtableid)) {
			continue;
		}

		if ((sc->gif_if.if_flags & IFF_UP) == 0)
			continue;

		if (in_hosteq(satosin(sc->gif_psrc)->sin_addr, ip->ip_dst) &&
		    in_hosteq(satosin(sc->gif_pdst)->sin_addr, ip->ip_src)) {
			gifp = &sc->gif_if;
			break;
		}
	}

	if (gifp) {
		m->m_pkthdr.ph_ifidx = gifp->if_index;
		m->m_pkthdr.ph_rtableid = gifp->if_rdomain;
		gifp->if_ipackets++;
		gifp->if_ibytes += m->m_pkthdr.len;
		/* We have a configured GIF */
		ipip_input(m, off, gifp, ip->ip_p);
		return;
	}

inject:
	ip4_input(m, off); /* No GIF interface was configured */
	return;
}
@


1.46
log
@Replace sockaddr casts with the proper satosin() or satosin6() calls.
From David Hill;  OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.45 2015/06/16 11:09:40 mpi Exp $	*/
@


1.45
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.44 2015/05/12 12:27:17 mpi Exp $	*/
d65 2
a66 2
	struct sockaddr_in *sin_src = (struct sockaddr_in *)sc->gif_psrc;
	struct sockaddr_in *sin_dst = (struct sockaddr_in *)sc->gif_pdst;
@


1.44
log
@MPLS also needs a definition for etherip_output(), fix build without
bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.43 2015/03/14 03:38:51 jsg Exp $	*/
d193 1
a193 1
		m->m_pkthdr.rcvif = gifp;
@


1.43
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.42 2014/12/05 15:50:04 mpi Exp $	*/
d53 1
a53 1
#if NBRIDGE > 0
@


1.42
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.41 2014/07/22 11:06:10 mpi Exp $	*/
a49 4

#ifdef INET6
#include <netinet/ip6.h>
#endif
@


1.41
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.40 2014/04/14 09:06:42 mpi Exp $	*/
d41 1
@


1.40
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.39 2011/06/19 17:55:37 jsg Exp $	*/
a44 1
#include <netinet/in_systm.h>
@


1.39
log
@fix up unbalanced format strings
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.38 2010/05/11 09:36:07 claudio Exp $	*/
d84 1
a84 1
	if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain)) {
d87 1
a87 1
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain),
d148 1
a148 1
	m->m_pkthdr.rdomain = sc->gif_rtableid;
d182 1
a182 1
		    rtable_l2(m->m_pkthdr.rdomain)) {
d198 1
a198 1
		m->m_pkthdr.rdomain = gifp->if_rdomain;
@


1.38
log
@Massiv cleanup of the gif(4) mess. Move encapsulation into gif_output()
where it is not necessary to guess protocols by looking at the first nibble.
in_gif_output() will encapsulate the packet but not send it. Because of
etherip support and the way the bridge works a minimal hack is needed in
gif_start() to ensure that the bridged packets are encapsulated as well.
This actually started with the idea to add MPLS support but that turned out
to be not as simple as in the gre(4) case.
Tested by myself (IP, IPv6, etherip, MPLS), sthen@@ (IP, IPv6), naddy (IPv6)
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.37 2009/11/21 14:08:14 claudio Exp $	*/
d87 2
a88 1
		    ifp->if_rdomain, rtable_l2(m->m_pkthdr.rdomain));
@


1.37
log
@Add a way to bind the tunnel endpoint of a gif/gre interface into a
different rdomain than the default one. This allows to do MPLS VPNs
without the MPLS madness.  OK deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.36 2009/06/02 17:01:20 blambert Exp $	*/
d57 3
d66 1
a66 1
in_gif_output(struct ifnet *ifp, int family, struct mbuf *m)
d74 1
a74 1
	struct mbuf *mp;
d91 1
a91 1
	/* setup dummy tdb.  it highly depends on ipipoutput() code. */
d113 5
a117 1
#endif /* NBRIDGE */
d128 1
a128 1
	mp = NULL;
d131 1
a131 1
		error = etherip_output(m, &tdb, &mp, 0, 0);
d134 6
a139 1
	error = ipip_output(m, &tdb, &mp, 0, 0);
d142 1
a142 1
	else if (mp == NULL)
d145 1
a145 1
	m = mp;
d151 1
a151 2
	return ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL,
	    (void *)NULL);
d200 2
a201 1
		ipip_input(m, off, gifp); /* We have a configured GIF */
@


1.36
log
@satosin was already defined in in.h, no need to redefine it here

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.35 2008/09/28 16:14:40 jsing Exp $	*/
d80 8
d135 1
d168 3
a170 1
		    sc->gif_pdst->sa_family != AF_INET) {
d178 1
a178 2
		    in_hosteq(satosin(sc->gif_pdst)->sin_addr, ip->ip_src))
		{
d186 1
@


1.35
log
@Ansify function declarations for gif(4).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.34 2008/09/28 15:25:32 jsing Exp $	*/
a155 1
#define	satosin(sa)	((struct sockaddr_in *)(sa))
@


1.34
log
@Clear the PF state key before an IP packet exits a gif(4) tunnel, in order
to prevent state key mismatches.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.32 2007/02/10 15:34:22 claudio Exp $	*/
d63 1
a63 4
in_gif_output(ifp, family, m)
	struct ifnet	*ifp;
	int		family;
	struct mbuf	*m;
@


1.33
log
@Simplify even more by reducing shared code in #if NBRIDGE and default case.
OK mglocker@@
@
text
@d33 2
d58 4
d130 3
@


1.32
log
@Cleanup, kill dead code and unused arguments. Mostly stuff that is computed
and passed around but never used. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.31 2005/12/23 13:01:23 claudio Exp $	*/
d109 2
d112 1
a112 2
	if (family == AF_LINK) {
	        mp = NULL;
d114 1
a114 9
		if (error)
		        return error;
		else if (mp == NULL)
		        return EFAULT;

		m = mp;
		return ip_output(m, (void *)NULL, (void *)NULL, 0,
		    (void *)NULL, (void *)NULL);
	}
a115 3

	/* encapsulate into IPv4 packet */
	mp = NULL;
@


1.31
log
@Remove unnecessary #ifdef MROUTING blocks. OK brad@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.30 2003/12/10 07:22:43 itojun Exp $	*/
d57 1
a57 1
in_gif_output(ifp, family, m, rt)
a60 1
	struct rtentry *rt;
a67 1
	int hlen, poff;
a90 7
		if (m->m_len < sizeof(struct ip)) {
			m = m_pullup(m, sizeof(struct ip));
			if (m == NULL)
				return ENOBUFS;
		}
		hlen = (mtod(m, struct ip *)->ip_hl) << 2;
		poff = offsetof(struct ip, ip_p);
a93 2
		hlen = sizeof(struct ip6_hdr);
		poff = offsetof(struct ip6_hdr, ip6_nxt);
d119 2
a120 1
		goto sendit;
d126 1
a126 1
	error = ipip_output(m, &tdb, &mp, hlen, poff);
d134 2
a135 5
#if NBRIDGE > 0
 sendit:
#endif /* NBRIDGE */

	return ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL, (void *)NULL);
@


1.30
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.29 2003/12/03 14:51:05 markus Exp $	*/
a51 4

#ifdef MROUTING
#include <netinet/ip_mroute.h>
#endif /* MROUTING */
@


1.29
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.28 2003/07/28 10:10:16 markus Exp $	*/
d67 1
a67 1
	register struct gif_softc *sc = (struct gif_softc*)ifp;
@


1.28
log
@allow gif(4) over ipsec: mark mbuf for transport mode SA,
so in_gif_input can detect whether a proto 4 header is due
to ipsec tunnel mode or gif(4) encapsulation; fixes pr 3023
ok itojun@@. provos@@ and angelos@@ agree; tested by sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.27 2003/07/09 22:03:16 itojun Exp $	*/
a161 1
	int i;
d178 1
a178 1
	for (i = 0, sc = gif_softc; i < ngif; i++, sc++) {
@


1.27
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.26 2002/08/28 15:43:03 pefo Exp $	*/
d169 3
a171 2
	/* XXX what if we run transport-mode IPsec to protect gif tunnel ? */
	if (m->m_flags & (M_AUTH | M_CONF))
d173 1
@


1.26
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.25 2002/06/09 16:26:10 itojun Exp $	*/
a73 1
	u_int16_t plen;
a150 6
	/* ip_output needs host-order length.  it should be nuked */
	m_copydata(m, offsetof(struct ip, ip_len), sizeof(u_int16_t),
		   (caddr_t) &plen);
	NTOHS(plen);
	m_copyback(m, offsetof(struct ip, ip_len), sizeof(u_int16_t),
		   (caddr_t) &plen);
@


1.25
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.24 2002/05/30 04:19:44 itojun Exp $	*/
d159 1
a159 1
	return ip_output(m, NULL, NULL, 0, NULL, NULL);
@


1.24
log
@minor KNF.  nuke obsolete IFF_LINK0 support completely
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.23 2002/03/15 18:19:52 millert Exp $	*/
d183 1
a183 1
#define	satosin(sa)	((struct sockaddr_in *)(sa))	
@


1.23
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.22 2001/12/07 09:32:45 itojun Exp $	*/
a83 6
	/* multi-destination mode is not supported */
	if (ifp->if_flags & IFF_LINK0) {
		m_freem(m);
		return ENETUNREACH;
	}

d185 3
a187 4
		if (sc->gif_psrc == NULL
		 || sc->gif_pdst == NULL
		 || sc->gif_psrc->sa_family != AF_INET
		 || sc->gif_pdst->sa_family != AF_INET) {
d194 2
a195 11
		if ((sc->gif_if.if_flags & IFF_LINK0)
		 && satosin(sc->gif_psrc)->sin_addr.s_addr == ip->ip_dst.s_addr
		 && satosin(sc->gif_pdst)->sin_addr.s_addr == INADDR_ANY) {
			gifp = &sc->gif_if;
			continue;
		}

		if (satosin(sc->gif_psrc)->sin_addr.s_addr ==
		    ip->ip_dst.s_addr
		 && satosin(sc->gif_pdst)->sin_addr.s_addr ==
		    ip->ip_src.s_addr)
@


1.22
log
@sync comment with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.21 2001/08/19 06:31:56 angelos Exp $	*/
a168 1
#if __STDC__
a169 5
#else
in_gif_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.22.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.22 2001/12/07 09:32:45 itojun Exp $	*/
d84 6
d169 1
d171 5
d197 4
a200 3
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
		    sc->gif_psrc->sa_family != AF_INET ||
		    sc->gif_pdst->sa_family != AF_INET) {
d207 11
a217 2
		if (in_hosteq(satosin(sc->gif_psrc)->sin_addr, ip->ip_dst) &&
		    in_hosteq(satosin(sc->gif_pdst)->sin_addr, ip->ip_src))
@


1.22.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.22.2.1 2002/06/11 03:31:36 art Exp $	*/
d159 1
a159 1
	return ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL, (void *)NULL);
d183 1
a183 1
#define	satosin(sa)	((struct sockaddr_in *)(sa))
@


1.21
log
@Pass the interface (if any) to ipip_input(), so it can be used in
BPF. Closes PR 2000.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.20 2001/07/27 15:48:38 itojun Exp $	*/
a30 4
 */

/*
 * in_gif.c
@


1.20
log
@variable name "gif" is way too generic - use "gif_softc".  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.19 2001/06/08 10:37:46 art Exp $	*/
d232 1
a232 1
		ipip_input(m, off); /* We have a configured GIF */
@


1.19
log
@Update packet counters correctly.
From Robert J. Wozny <speedy@@atman.pl>
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.18 2001/06/08 03:53:45 angelos Exp $	*/
d200 1
a200 1
	for (i = 0, sc = gif; i < ngif; i++, sc++) {
@


1.18
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.17 2001/05/30 12:30:02 angelos Exp $	*/
d230 2
@


1.17
log
@No need for last argument in ipip_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.16 2001/04/14 00:30:58 angelos Exp $	*/
a39 1
#include <sys/sockio.h>
a40 3
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/protosw.h>
a50 1
#include <netinet/ip_ecn.h>
a60 2
#include <net/if_gif.h>	

a62 4

#include <machine/stdarg.h>

#include <net/net_osdep.h>
@


1.16
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.15 2001/04/06 04:42:08 csapuntz Exp $	*/
d162 1
a162 1
	error = ipip_output(m, &tdb, &mp, hlen, poff, NULL);
@


1.15
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.14 2001/02/16 08:48:04 itojun Exp $	*/
d162 1
a162 1
	error = ipip_output(m, &tdb, &mp, hlen, poff);
@


1.14
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.13 2000/12/31 17:23:35 angelos Exp $	*/
a73 4

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
#endif
@


1.13
log
@Fix non-NBRIDGE case
@
text
@d1 2
a2 1
/*	$OpenBSD: in_gif.c,v 1.12 2000/12/31 17:20:14 angelos Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
@


1.12
log
@Remove debugging printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.11 2000/12/30 21:50:46 angelos Exp $	*/
d173 1
d175 1
@


1.11
log
@AF_LINK case.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.10 2000/12/30 19:03:38 angelos Exp $	*/
a98 1
printf("failure 1\n");
@


1.10
log
@Send AF_LINK to etherip_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.9 2000/05/25 01:22:00 itojun Exp $	*/
d99 1
d137 4
@


1.9
log
@net.inet.ip.gif_ttl (and IPv6 counterpart) is never used.
enforce type checking on IN6_ARE_ADDR_EQUAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.8 2000/02/07 06:18:44 itojun Exp $	*/
d68 1
d145 14
d169 1
@


1.8
log
@s/DIAGNOSTIC/DEBUG/
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.7 2000/01/21 03:15:04 angelos Exp $	*/
a71 6

#if NGIF > 0
int ip_gif_ttl = GIF_TTL;
#else
int ip_gif_ttl = 0;
#endif
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: in_gif.c,v 1.16 2001/04/14 00:30:58 angelos Exp $	*/
/*	$KAME: in_gif.c,v 1.50 2001/01/22 07:27:16 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
a67 1
#include "bridge.h"
d73 10
a140 4
#if NBRIDGE > 0
	case AF_LINK:
		break;
#endif /* NBRIDGE */
a149 14
#if NBRIDGE > 0
	if (family == AF_LINK) {
	        mp = NULL;
		error = etherip_output(m, &tdb, &mp, 0, 0);
		if (error)
		        return error;
		else if (mp == NULL)
		        return EFAULT;

		m = mp;
		goto sendit;
	}
#endif /* NBRIDGE */

d152 1
a152 1
	error = ipip_output(m, &tdb, &mp, hlen, poff, NULL);
a159 3
#if NBRIDGE > 0
 sendit:
#endif /* NBRIDGE */
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.8.2.1 2001/05/14 22:40:08 niklas Exp $	*/
d40 1
d42 3
d55 1
d66 2
d71 4
d162 1
a162 1
	error = ipip_output(m, &tdb, &mp, hlen, poff);
a240 2
		gifp->if_ipackets++;
		gifp->if_ibytes += m->m_pkthdr.len;
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.8.2.2 2001/07/04 10:54:32 niklas Exp $	*/
d200 1
a200 1
	for (i = 0, sc = gif_softc; i < ngif; i++, sc++) {
d232 1
a232 1
		ipip_input(m, off, gifp); /* We have a configured GIF */
@


1.8.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 4
@


1.8.2.5
log
@Merge in -current from roughly a week ago
@
text
@d169 1
d171 5
@


1.8.2.6
log
@Sync the SMP branch with 3.3
@
text
@d84 6
d165 1
a165 1
	return ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL, (void *)NULL);
d189 1
a189 1
#define	satosin(sa)	((struct sockaddr_in *)(sa))
d191 4
a194 3
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
		    sc->gif_psrc->sa_family != AF_INET ||
		    sc->gif_pdst->sa_family != AF_INET) {
d201 11
a211 2
		if (in_hosteq(satosin(sc->gif_psrc)->sin_addr, ip->ip_dst) &&
		    in_hosteq(satosin(sc->gif_pdst)->sin_addr, ip->ip_src))
@


1.8.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d67 1
a67 1
	struct gif_softc *sc = (struct gif_softc*)ifp;
d74 1
d152 6
d169 1
d176 2
a177 3
	/* IP-in-IP header is caused by tunnel mode, so skip gif lookup */
	if (m->m_flags & M_TUNNEL) {
		m->m_flags &= ~M_TUNNEL;
a178 1
	}
d184 1
a184 1
	LIST_FOREACH(sc, &gif_softc_list, gif_list) {
@


1.7
log
@Rename the ip4_* routines to ipip_*, make it so GIF tunnels are not
affected by net.inet.ipip.allow (the sysctl formerly known as
net.inet.ip4.allow), rename the VIF ipip_input to ipip_mroute_input.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.6 2000/01/11 07:47:09 angelos Exp $	*/
d142 1
a142 1
#ifdef DIAGNOSTIC
@


1.6
log
@Mostly cosmetic changes, and avoid an m_pullup()
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.5 2000/01/07 00:57:54 itojun Exp $	*/
d113 1
a113 1
	/* setup dummy tdb.  it highly depends on ipe4_output() code. */
d152 1
a152 1
	error = ipe4_output(m, &tdb, &mp, hlen, poff);
d226 1
a226 1
	if (gifp && (m->m_flags & (M_AUTH | M_CONF)) == 0)
d228 3
d233 1
a233 1
	ip4_input(m, off);
@


1.5
log
@s/memset/bzero/
From: Michael Shalayeff <mickey@@lucifier.dial-up.user.akula.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.4 1999/12/28 07:17:38 itojun Exp $	*/
d97 1
d142 4
a159 1
    {
d161 5
a165 9
	struct ip *ip;
	if (m->m_len < sizeof(struct ip)) {
		m = m_pullup(m, sizeof(struct ip));
		if (m == NULL)
			return ENOBUFS;
	}
	ip = mtod(m, struct ip *);
	ip->ip_len = ntohs(ip->ip_len);
    }
d190 1
a190 4
	/*
	 * XXX
	 * what if we run transport-mode IPsec to protect gif tunnel?
	 */
d216 4
a219 2
		if (satosin(sc->gif_psrc)->sin_addr.s_addr == ip->ip_dst.s_addr
		 && satosin(sc->gif_pdst)->sin_addr.s_addr == ip->ip_src.s_addr)
@


1.4
log
@remove non-effective kame patch.  openbsd ip_input() passes
different thing to the upper-layers than other KAME/*BSD does
(additional NULL pointer and "0"), so live with that.

(sync with kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.3 1999/12/21 09:00:50 itojun Exp $	*/
d113 2
a114 2
	memset(&tdb, 0, sizeof(tdb));
	memset(&xfs, 0, sizeof(xfs));
@


1.3
log
@reuse encapsulate/decapsulate routine in ip_ip4.c from gif interface
(outer=IPv4 case).  tested with (inner=IPv6, outer=IPv4) case.

BUG ALERT: in_gif_output() assumes about ipe4_output()'s behavior too much.
I mean, "tdb" is configured with certain knowledge about ipe4_output()'s
behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.2 1999/12/09 03:45:21 angelos Exp $	*/
d179 1
a179 1
	int off, proto;
a187 1
	proto = va_arg(ap, int);
d231 1
a231 1
	ip4_input(m, off, proto);
@


1.2
log
@Minor cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: in_gif.c,v 1.1 1999/12/08 06:50:19 itojun Exp $	*/
d55 1
d79 4
a90 1
	struct sockaddr_in *dst = (struct sockaddr_in *)&sc->gif_ro.ro_dst;
d93 5
a97 3
	struct ip iphdr;	/* capsule IP header, host byte ordered */
	int proto;
	u_int8_t tos;
d106 18
a124 1
#ifdef INET
d126 3
a128 7
	    {
		struct ip *ip;

		proto = IPPROTO_IPV4;
		if (m->m_len < sizeof(*ip)) {
			m = m_pullup(m, sizeof(*ip));
			if (!m)
d131 2
a132 2
		ip = mtod(m, struct ip *);
		tos = ip->ip_tos;
a133 2
	    }
#endif /*INET*/
d136 2
a137 10
	    {
		struct ip6_hdr *ip6;
		proto = IPPROTO_IPV6;
		if (m->m_len < sizeof(*ip6)) {
			m = m_pullup(m, sizeof(*ip6));
			if (!m)
				return ENOBUFS;
		}
		ip6 = mtod(m, struct ip6_hdr *);
		tos = (ntohl(ip6->ip6_flow) >> 20) & 0xff;
d139 1
a139 2
	    }
#endif /*INET6*/
a140 4
#ifdef DIAGNOSTIC
		printf("in_gif_output: warning: unknown family %d passed\n",
			family);
#endif
d145 7
a151 41
	bzero(&iphdr, sizeof(iphdr));
	iphdr.ip_src = sin_src->sin_addr;
	if (ifp->if_flags & IFF_LINK0) {
		/* multi-destination mode */
		if (sin_dst->sin_addr.s_addr != INADDR_ANY)
			iphdr.ip_dst = sin_dst->sin_addr;
		else if (rt) {
			if (family != AF_INET) {
				m_freem(m);
				return EINVAL;	/*XXX*/
			}
			iphdr.ip_dst = ((struct sockaddr_in *)
					(rt->rt_gateway))->sin_addr;
		} else {
			m_freem(m);
			return ENETUNREACH;
		}
	} else {
		/* bidirectional configured tunnel mode */
		if (sin_dst->sin_addr.s_addr != INADDR_ANY)
			iphdr.ip_dst = sin_dst->sin_addr;
		else {
			m_freem(m);
			return ENETUNREACH;
		}
	}
	iphdr.ip_p = proto;
	/* version will be set in ip_output() */
	iphdr.ip_ttl = ip_gif_ttl;
	iphdr.ip_len = m->m_pkthdr.len + sizeof(struct ip);
	if (ifp->if_flags & IFF_LINK1)
		ip_ecn_ingress(ECN_ALLOWED, &iphdr.ip_tos, &tos);

	/* prepend new IP header */
	M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
	if (m && m->m_len < sizeof(struct ip))
		m = m_pullup(m, sizeof(struct ip));
	if (m == NULL) {
		printf("ENOBUFS in in_gif_output %d\n", __LINE__);
		return ENOBUFS;
	}
d153 1
a153 1
	*(mtod(m, struct ip *)) = iphdr;
d155 7
a161 13
	if (dst->sin_family != sin_dst->sin_family ||
	    dst->sin_addr.s_addr != sin_dst->sin_addr.s_addr) {
		/* cache route doesn't match */
		dst->sin_family = sin_dst->sin_family;
		dst->sin_len = sizeof(struct sockaddr_in);
		dst->sin_addr = sin_dst->sin_addr;
		if (sc->gif_ro.ro_rt) {
			RTFREE(sc->gif_ro.ro_rt);
			sc->gif_ro.ro_rt = NULL;
		}
#if 0
		sc->gif_if.if_mtu = GIF_MTU;
#endif
d163 3
d167 1
a167 19
	if (sc->gif_ro.ro_rt == NULL) {
		rtalloc(&sc->gif_ro);
		if (sc->gif_ro.ro_rt == NULL) {
			m_freem(m);
			return ENETUNREACH;
		}
#if 0
		ifp->if_mtu = sc->gif_ro.ro_rt->rt_ifp->if_mtu
			- sizeof(struct ip);
#endif 
	}
	
#ifdef IPSEC
#ifndef __OpenBSD__	/*KAME IPSEC*/
	m->m_pkthdr.rcvif = NULL;
#endif
#endif /*IPSEC*/

	return ip_output(m, NULL, &sc->gif_ro, 0, NULL, NULL);
d183 1
a183 1
	int i, af;
a184 1
	u_int8_t otos;
d191 7
d228 2
a229 12
	if (gifp == NULL) {
#ifdef MROUTING
		/* for backward compatibility */
		if (proto == IPPROTO_IPV4) {
			ipip_input(m, off, proto);
			return;
		}
#endif /*MROUTING*/
		m_freem(m);
		ipstat.ips_nogif++;
		return;
	}
d231 2
a232 46
	otos = ip->ip_tos;
	m_adj(m, off);

	switch (proto) {
#ifdef INET
	case IPPROTO_IPV4:
	    {
		struct ip *ip;
		af = AF_INET;
		if (m->m_len < sizeof(*ip)) {
			m = m_pullup(m, sizeof(*ip));
			if (!m)
				return;
		}
		ip = mtod(m, struct ip *);
		if (gifp->if_flags & IFF_LINK1)
			ip_ecn_egress(ECN_ALLOWED, &otos, &ip->ip_tos);
		break;
	    }
#endif
#ifdef INET6
	case IPPROTO_IPV6:
	    {
		struct ip6_hdr *ip6;
		u_int8_t itos;
		af = AF_INET6;
		if (m->m_len < sizeof(*ip6)) {
			m = m_pullup(m, sizeof(*ip6));
			if (!m)
				return;
		}
		ip6 = mtod(m, struct ip6_hdr *);
		itos = (ntohl(ip6->ip6_flow) >> 20) & 0xff;
		if (gifp->if_flags & IFF_LINK1)
			ip_ecn_egress(ECN_ALLOWED, &otos, &itos);
		ip6->ip6_flow &= ~htonl(0xff << 20);
		ip6->ip6_flow |= htonl((u_int32_t)itos << 20);
		break;
	    }
#endif /* INET6 */
	default:
		ipstat.ips_nogif++;
		m_freem(m);
		return;
	}
	gif_input(m, af, gifp);
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a35 10
#ifdef __FreeBSD__
#include "opt_mrouting.h"
#endif
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#ifdef __NetBSD__	/*XXX*/
#include "opt_ipsec.h"
#endif
#endif

a41 5
#ifdef __FreeBSD__
#include <sys/kernel.h>
#include <sys/sysctl.h>
#endif
#if !defined(__FreeBSD__) || __FreeBSD__ < 3
a42 1
#endif
a76 4
#ifdef __FreeBSD__
SYSCTL_INT(_net_inet_ip, IPCTL_GIF_TTL, gifttl, CTLFLAG_RW,
	&ip_gif_ttl,	0, "");
#endif
d90 1
a90 1
	int proto, error;
d217 2
a218 6
#ifndef __OpenBSD__
	error = ip_output(m, NULL, &sc->gif_ro, 0, NULL);
#else
	error = ip_output(m, NULL, &sc->gif_ro, 0, NULL, NULL);
#endif
	return(error);
@

