head	1.47;
access;
symbols
	SMP_SYNC_A:1.47
	SMP_SYNC_B:1.47
	UBC_SYNC_A:1.47
	UBC_SYNC_B:1.47
	OPENBSD_2_9_BASE:1.43
	OPENBSD_2_9:1.43.0.2
	OPENBSD_2_8:1.37.0.2
	OPENBSD_2_8_BASE:1.37
	OPENBSD_2_7:1.34.0.2
	OPENBSD_2_7_BASE:1.34
	SMP:1.29.0.2
	SMP_BASE:1.29
	kame_19991208:1.25
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.19.0.2
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.47
date	2001.05.30.02.12.29;	author deraadt;	state dead;
branches;
next	1.46;

1.46
date	2001.05.08.20.13.15;	author fgsch;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.08.20.02.59;	author fgsch;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.08.19.58.01;	author fgsch;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.22.19.44.34;	author gluk;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2001.03.07.05.43.17;	author aaron;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.06.17.29.30;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.30.04.23.55;	author kjell;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.17.05.16.37;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.17.04.47.12;	author fgsch;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.07.19.45.04;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2000.08.10.05.50.25;	author kjell;	state Exp;
branches;
next	1.35;

1.35
date	2000.05.24.21.59.11;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2000.05.01.06.16.47;	author kjell;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.04.05.05.35.27;	author kjell;	state Exp;
branches;
next	1.32;

1.32
date	2000.03.13.23.40.17;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.18.07.47.02;	author kjell;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.16.22.34.18;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.01.19.29.58;	author kjell;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	99.12.17.06.17.08;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	99.12.15.05.20.21;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	99.12.13.10.41.56;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	99.06.07.22.00.32;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.04.22.16.12.40;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.04.20.22.41.34;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.04.16.13.44.25;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.02.05.05.58.50;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.09.15.09.51.17;	author pattonme;	state Exp;
branches;
next	1.18;

1.18
date	98.05.18.21.10.46;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	98.03.04.23.20.41;	author dgregor;	state Exp;
branches;
next	1.16;

1.16
date	98.01.26.04.10.39;	author dgregor;	state Exp;
branches;
next	1.15;

1.15
date	97.12.03.01.25.32;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.06.23.19.03.48;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.04.18.06.10.08;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.03.31.15.52.45;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.03.15.17.18.07;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.02.11.22.23.12;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.02.05.00.53.11;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.01.18.08.29.19;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.10.24.17.56.20;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.10.08.07.33.25;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.09.30.14.06.37;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.18.05.00.58;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.21.38.16;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.25.05.41.42;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.02.34.02;	author dm;	state Exp;
branches;
next	;

1.29.2.1
date	2000.02.20.11.57.23;	author niklas;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2000.03.24.09.09.36;	author niklas;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2001.05.14.22.40.09;	author niklas;	state Exp;
branches;
next	1.29.2.4;

1.29.2.4
date	2001.07.04.10.54.44;	author niklas;	state dead;
branches;
next	;

1.34.2.1
date	2000.05.27.20.45.17;	author jason;	state Exp;
branches;
next	;

1.43.2.1
date	2001.09.08.17.42.37;	author jason;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ip_fil.c,v 1.46 2001/05/08 20:13:15 fgsch Exp $	*/

/*
 * Copyright (C) 1993-2001 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#if !defined(lint)
static const char sccsid[] = "@@(#)ip_fil.c	2.41 6/5/96 (C) 1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.42.2.19 2001/04/03 14:13:37 darrenr Exp $";
#endif

#ifndef	SOLARIS
#define	SOLARIS	(defined(sun) && (defined(__svr4__) || defined(__SVR4)))
#endif

#if defined(KERNEL) && !defined(_KERNEL)
# define	_KERNEL
#endif
#if defined(_KERNEL) && defined(__FreeBSD_version) && \
    (__FreeBSD_version >= 400000) && !defined(KLD_MODULE)
#include "opt_inet6.h"
#endif
#include <sys/param.h>
#if defined(__NetBSD__) && (NetBSD >= 199905) && !defined(IPFILTER_LKM) && \
    defined(_KERNEL)
# include "opt_ipfilter_log.h"
#endif
#if defined(__FreeBSD__) && !defined(__FreeBSD_version)
# if !defined(_KERNEL) || defined(IPFILTER_LKM)
#  include <osreldate.h>
# endif
#endif
#ifndef	_KERNEL
# include <stdio.h>
# include <string.h>
# include <stdlib.h>
# include <ctype.h>
# include <fcntl.h>
#endif
#include <sys/errno.h>
#include <sys/types.h>
#include <sys/file.h>
#if __FreeBSD_version >= 220000 && defined(_KERNEL)
# include <sys/fcntl.h>
# include <sys/filio.h>
#else
# include <sys/ioctl.h>
#endif
#include <sys/time.h>
#ifdef	_KERNEL
# include <sys/systm.h>
#endif
#include <sys/uio.h>
#if !SOLARIS
# if (NetBSD > 199609) || (OpenBSD > 199603) || (__FreeBSD_version >= 300000)
#  include <sys/dirent.h>
# else
#  include <sys/dir.h>
# endif
# include <sys/mbuf.h>
#else
# include <sys/filio.h>
#endif
#include <sys/protosw.h>
#include <sys/socket.h>

#include <net/if.h>
#ifdef sun
# include <net/af.h>
#endif
#if __FreeBSD_version >= 300000
# include <net/if_var.h>
# if defined(_KERNEL) && !defined(IPFILTER_LKM)
#  include "opt_ipfilter.h"
# endif
#endif
#ifdef __sgi
#include <sys/debug.h>
# ifdef IFF_DRVRLOCK /* IRIX6 */
#include <sys/hashing.h>
# endif
#endif
#include <net/route.h>
#include <netinet/in.h>
#if !(defined(__sgi) && !defined(IFF_DRVRLOCK)) /* IRIX < 6 */
# include <netinet/in_var.h>
#endif
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/tcpip.h>
#include <netinet/ip_icmp.h>
#ifndef	_KERNEL
# include <unistd.h>
# include <syslog.h>
#endif
#include <netinet/ip_fil_compat.h>
#ifdef USE_INET6
# include <netinet/icmp6.h>
#endif
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_frag.h>
#include <netinet/ip_state.h>
#include <netinet/ip_auth.h>
#if defined(__FreeBSD_version) && (__FreeBSD_version >= 300000)
# include <sys/malloc.h>
#endif
#ifndef	MIN
# define	MIN(a,b)	(((a)<(b))?(a):(b))
#endif
#if !SOLARIS && defined(_KERNEL) && !defined(__sgi)
# include <sys/kernel.h>
extern	int	ip_optcopy __P((struct ip *, struct ip *));
#endif


extern	struct	protosw	inetsw[];

#ifndef	_KERNEL
# include "ipt.h"
static	struct	ifnet **ifneta = NULL;
static	int	nifs = 0;
#else
# if	(BSD < 199306) || defined(__sgi)
extern	int	tcp_ttl;
# endif
#endif

int	ipl_unreach = ICMP_UNREACH_FILTER;
u_long	ipl_frouteok[2] = {0, 0};

static	int	frzerostats __P((caddr_t));
#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD_version >= 300003)
static	int	frrequest __P((int, u_long, caddr_t, int));
#else
static	int	frrequest __P((int, int, caddr_t, int));
#endif
#ifdef	_KERNEL
static	int	(*fr_savep) __P((ip_t *, int, void *, int, struct mbuf **));
static	int	send_ip __P((ip_t *, fr_info_t *, struct mbuf *));
# ifdef	__sgi
extern  kmutex_t        ipf_rw;
extern	KRWLOCK_T	ipf_mutex;
# endif
#else
int	ipllog __P((void));
void	init_ifp __P((void));
# ifdef __sgi
static int 	no_output __P((struct ifnet *, struct mbuf *,
			       struct sockaddr *));
static int	write_output __P((struct ifnet *, struct mbuf *,
				  struct sockaddr *));
# else
static int 	no_output __P((struct ifnet *, struct mbuf *,
			       struct sockaddr *, struct rtentry *));
static int	write_output __P((struct ifnet *, struct mbuf *,
				  struct sockaddr *, struct rtentry *));
# endif
#endif
int	fr_running = 0;

#if (__FreeBSD_version >= 300000) && defined(_KERNEL)
struct callout_handle ipfr_slowtimer_ch;
#endif
#if defined(__NetBSD__) && (__NetBSD_Version__ >= 104230000)
# include <sys/callout.h>
struct callout ipfr_slowtimer_ch;
#endif
#if defined(__OpenBSD__)
# include <sys/timeout.h>
struct timeout ipfr_slowtimer_ch;
#endif
#if defined(__sgi) && defined(_KERNEL)
toid_t ipfr_slowtimer_ch;
#endif

#if (_BSDI_VERSION >= 199510) && defined(_KERNEL)
# include <sys/device.h>
# include <sys/conf.h>

struct cfdriver iplcd = {
	NULL, "ipl", NULL, NULL, DV_DULL, 0
};

struct devsw iplsw = {
	&iplcd,
	iplopen, iplclose, iplread, nowrite, iplioctl, noselect, nommap,
	nostrat, nodump, nopsize, 0,
	nostop
};
#endif /* _BSDI_VERSION >= 199510  && _KERNEL */

#if defined(__NetBSD__) || defined(__OpenBSD__)  || (_BSDI_VERSION >= 199701)
# include <sys/conf.h>
# if defined(NETBSD_PF)
#  include <net/pfil.h>
/*
 * We provide the fr_checkp name just to minimize changes later.
 */
int (*fr_checkp) __P((ip_t *ip, int hlen, void *ifp, int out, mb_t **mp));
# endif /* NETBSD_PF */
#endif /* __NetBSD__ */

#ifdef	_KERNEL
# if	defined(IPFILTER_LKM) && !defined(__sgi)
int iplidentify(s)
char *s;
{
	if (strcmp(s, "ipl") == 0)
		return 1;
	return 0;
}
# endif /* IPFILTER_LKM */


/*
 * Try to detect the case when compiling for NetBSD with pseudo-device
 */
# if defined(__NetBSD__) && defined(PFIL_HOOKS)
void
ipfilterattach(count)
int count;
{
	if (iplattach() != 0)
		printf("IP Filter failed to attach\n");
}
# endif


int iplattach()
{
	char *defpass;
	int s;
# if defined(__sgi) || (defined(NETBSD_PF) && (__NetBSD_Version__ >= 104200000))
	int error = 0;
# endif

	SPL_NET(s);
	if (fr_running || (fr_checkp == fr_check)) {
		printf("IP Filter: already initialized\n");
		SPL_X(s);
		return EBUSY;
	}

# ifdef	IPFILTER_LOG
	ipflog_init();
# endif
	if (nat_init() == -1) {
		SPL_X(s);
		return EIO;
	}
	if (fr_stateinit() == -1) {
		SPL_X(s);
		return EIO;
	}
	if (appr_init() == -1) {
		SPL_X(s);
		return EIO;
	}

# ifdef NETBSD_PF
#  if __NetBSD_Version__ >= 104200000
	error = pfil_add_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
			      &inetsw[ip_protox[IPPROTO_IP]].pr_pfh);
	if (error) {
#   ifdef USE_INET6
		goto pfil_error;
#   else
		SPL_X(s);
		appr_unload();
		ip_natunload();
		fr_stateunload();
		return error;
#   endif
	}
#  else
	pfil_add_hook((void *)fr_check, PFIL_IN|PFIL_OUT);
#  endif
#  ifdef USE_INET6
	error = pfil_add_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
			      &inetsw[ip_protox[IPPROTO_IPV6]].pr_pfh);
	if (error) {
		pfil_remove_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
				 &inetsw[ip_protox[IPPROTO_IP]].pr_pfh);
pfil_error:
		SPL_X(s);
		appr_unload();
		ip_natunload();
		fr_stateunload();
		return error;
	}
#  endif
# endif

# ifdef __sgi
	error = ipfilter_sgi_attach();
	if (error) {
		SPL_X(s);
		appr_unload();
		ip_natunload();
		fr_stateunload();
		return error;
	}
# endif

	bzero((char *)frcache, sizeof(frcache));
	fr_savep = fr_checkp;
	fr_checkp = fr_check;
	fr_running = 1;

	SPL_X(s);
	if (fr_pass & FR_PASS)
		defpass = "pass";
	else if (fr_pass & FR_BLOCK)
		defpass = "block";
	else
		defpass = "no-match -> block";

#if !defined(__OpenBSD__)
	printf("%s initialized.  Default = %s all, Logging = %s\n",
		ipfilter_version, defpass,
# ifdef	IPFILTER_LOG
		"enabled");
# else
		"disabled");
# endif
#endif

#ifdef  _KERNEL
# if defined(__NetBSD__) && (__NetBSD_Version__ >= 104230000)
	callout_init(&ipfr_slowtimer_ch);
	callout_reset(&ipfr_slowtimer_ch, hz / 2, ipfr_slowtimer, NULL);
# else
#  if defined(__OpenBSD__)
	timeout_set(&ipfr_slowtimer_ch, ipfr_slowtimer, NULL);
	timeout_add(&ipfr_slowtimer_ch, hz / 2);
#  else
#   if (__FreeBSD_version >= 300000) || defined(__sgi)
	ipfr_slowtimer_ch = timeout(ipfr_slowtimer, NULL, hz/2);
#   else
	timeout(ipfr_slowtimer, NULL, hz/2);
#   endif
#  endif
# endif
#endif
	return 0;
}


/*
 * Disable the filter by removing the hooks from the IP input/output
 * stream.
 */
int ipldetach()
{
	int s, i = FR_INQUE|FR_OUTQUE;
#if defined(NETBSD_PF) && (__NetBSD_Version__ >= 104200000)
	int error = 0;
#endif

#ifdef  _KERNEL
# if defined(__NetBSD__) && (__NetBSD_Version__ >= 104230000)
	callout_stop(&ipfr_slowtimer_ch);
# else
#  if defined(__OpenBSD__)
	timeout_del(&ipfr_slowtimer_ch);
#  else
#   if (__FreeBSD_version >= 300000)
	untimeout(ipfr_slowtimer, NULL, ipfr_slowtimer_ch);
#   else
#    ifdef __sgi
	untimeout(ipfr_slowtimer_ch);
#    else
	untimeout(ipfr_slowtimer, NULL);
#    endif
#   endif /* FreeBSD */
#  endif /* OpenBSD */
# endif /* NetBSD */
#endif
	SPL_NET(s);
	if (!fr_running)
	{
		printf("IP Filter: not initialized\n");
		SPL_X(s);
		return 0;
	}

	printf("%s unloaded\n", ipfilter_version);

	fr_checkp = fr_savep;
	i = frflush(IPL_LOGIPF, i);
	fr_running = 0;

# ifdef NETBSD_PF
#  if __NetBSD_Version__ >= 104200000
	error = pfil_remove_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
				 &inetsw[ip_protox[IPPROTO_IP]].pr_pfh);
	if (error) {
		SPL_X(s);
		return error;
	}
#  else
	pfil_remove_hook((void *)fr_check, PFIL_IN|PFIL_OUT);
#  endif
#  ifdef USE_INET6
	error = pfil_remove_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
				 &inetsw[ip_protox[IPPROTO_IPV6]].pr_pfh);
	if (error) {
		SPL_X(s);
		return error;
	}
#  endif
# endif

# ifdef __sgi
	ipfilter_sgi_detach();
# endif

	appr_unload();
	ipfr_unload();
	ip_natunload();
	fr_stateunload();
	fr_authunload();

	SPL_X(s);
	return 0;
}
#endif /* _KERNEL */


static	int	frzerostats(data)
caddr_t	data;
{
	friostat_t fio;
	int error;

	fr_getstat(&fio);
	error = IWCOPYPTR((caddr_t)&fio, data, sizeof(fio));
	if (error)
		return EFAULT;

	bzero((char *)frstats, sizeof(*frstats) * 2);

	return 0;
}


/*
 * Filter ioctl interface.
 */
#ifdef __sgi
int IPL_EXTERN(ioctl)(dev_t dev, int cmd, caddr_t data, int mode
# ifdef _KERNEL
	, cred_t *cp, int *rp
# endif
)
#else
int IPL_EXTERN(ioctl)(dev, cmd, data, mode
# if (defined(_KERNEL) && ((_BSDI_VERSION >= 199510) || (BSD >= 199506) || \
       (NetBSD >= 199511) || (__FreeBSD_version >= 220000) || \
       defined(__OpenBSD__)))
, p)
struct proc *p;
# else
)
# endif
dev_t dev;
# if defined(__NetBSD__) || defined(__OpenBSD__) || \
	(_BSDI_VERSION >= 199701) || (__FreeBSD_version >= 300000)
u_long cmd;
# else
int cmd;
# endif
caddr_t data;
int mode;
#endif /* __sgi */
{
#if defined(_KERNEL) && !SOLARIS
	int s;
#endif
	int error = 0, unit = 0, tmp;

#if (BSD >= 199306) && defined(_KERNEL)
	if ((securelevel >= 2) && (mode & FWRITE))
		return EPERM;
#endif
#ifdef	_KERNEL
	unit = GET_MINOR(dev);
	if ((IPL_LOGMAX < unit) || (unit < 0))
		return ENXIO;
#else
	unit = dev;
#endif

	SPL_NET(s);

	if (unit == IPL_LOGNAT) {
		if (fr_running)
			error = nat_ioctl(data, cmd, mode);
		else
			error = EIO;
		SPL_X(s);
		return error;
	}
	if (unit == IPL_LOGSTATE) {
		if (fr_running)
			error = fr_state_ioctl(data, cmd, mode);
		else
			error = EIO;
		SPL_X(s);
		return error;
	}
	if (unit == IPL_LOGAUTH) {
		if (fr_running)
			error = fr_auth_ioctl(data, cmd, NULL, NULL);
		else
			error = EIO;
		SPL_X(s);
		return error;
	}

	switch (cmd) {
	case FIONREAD :
#ifdef IPFILTER_LOG
		error = IWCOPY((caddr_t)&iplused[IPL_LOGIPF], (caddr_t)data,
			       sizeof(iplused[IPL_LOGIPF]));
#endif
		break;
#if !defined(IPFILTER_LKM) && defined(_KERNEL)
	case SIOCFRENB :
	{
		u_int	enable;

		if (!(mode & FWRITE))
			error = EPERM;
		else {
			error = IRCOPY(data, (caddr_t)&enable, sizeof(enable));
			if (error)
				break;
			if (enable)
				error = iplattach();
			else
				error = ipldetach();
		}
		break;
	}
#endif
	case SIOCSETFF :
		if (!(mode & FWRITE))
			error = EPERM;
		else
			error = IRCOPY(data, (caddr_t)&fr_flags,
				       sizeof(fr_flags));
		break;
	case SIOCGETFF :
		error = IWCOPY((caddr_t)&fr_flags, data, sizeof(fr_flags));
		break;
	case SIOCINAFR :
	case SIOCRMAFR :
	case SIOCADAFR :
	case SIOCZRLST :
		if (!(mode & FWRITE))
			error = EPERM;
		else
			error = frrequest(unit, cmd, data, fr_active);
		break;
	case SIOCINIFR :
	case SIOCRMIFR :
	case SIOCADIFR :
		if (!(mode & FWRITE))
			error = EPERM;
		else
			error = frrequest(unit, cmd, data, 1 - fr_active);
		break;
	case SIOCSWAPA :
		if (!(mode & FWRITE))
			error = EPERM;
		else {
			bzero((char *)frcache, sizeof(frcache[0]) * 2);
			*(u_int *)data = fr_active;
			fr_active = 1 - fr_active;
		}
		break;
	case SIOCGETFS :
	{
		friostat_t	fio;

		fr_getstat(&fio);
		error = IWCOPYPTR((caddr_t)&fio, data, sizeof(fio));
		if (error)
			error = EFAULT;
		break;
	}
	case	SIOCFRZST :
		if (!(mode & FWRITE))
			error = EPERM;
		else
			error = frzerostats(data);
		break;
	case	SIOCIPFFL :
		if (!(mode & FWRITE))
			error = EPERM;
		else {
			error = IRCOPY(data, (caddr_t)&tmp, sizeof(tmp));
			if (!error) {
				tmp = frflush(unit, tmp);
				error = IWCOPY((caddr_t)&tmp, data,
					       sizeof(tmp));
			}
		}
		break;
	case SIOCSTLCK :
		error = IRCOPY(data, (caddr_t)&tmp, sizeof(tmp));
		if (!error) {
			fr_state_lock = tmp;
			fr_nat_lock = tmp;
			fr_frag_lock = tmp;
			fr_auth_lock = tmp;
		} else
			error = EFAULT;
		break;
#ifdef	IPFILTER_LOG
	case	SIOCIPFFB :
		if (!(mode & FWRITE))
			error = EPERM;
		else
			*(int *)data = ipflog_clear(unit);
		break;
#endif /* IPFILTER_LOG */
	case SIOCGFRST :
		error = IWCOPYPTR((caddr_t)ipfr_fragstats(), data,
				  sizeof(ipfrstat_t));
		if (error)
			error = EFAULT;
		break;
	case SIOCAUTHW :
	case SIOCAUTHR :
		if (!(mode & FWRITE)) {
			error = EPERM;
			break;
		}
	case SIOCFRSYN :
		if (!(mode & FWRITE))
			error = EPERM;
		else {
#if defined(_KERNEL) && defined(__sgi)
			ipfsync();
#endif
			frsync();
		}
		break;
	default :
		error = EINVAL;
		break;
	}
	SPL_X(s);
	return error;
}


void fr_forgetifp(ifp)
void *ifp;
{
	register frentry_t *f;

	WRITE_ENTER(&ipf_mutex);
	for (f = ipacct[0][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
	for (f = ipacct[1][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
	for (f = ipfilter[0][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
	for (f = ipfilter[1][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
#ifdef	USE_INET6
	for (f = ipacct6[0][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
	for (f = ipacct6[1][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
	for (f = ipfilter6[0][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
	for (f = ipfilter6[1][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
#endif
	RWLOCK_EXIT(&ipf_mutex);
	ip_natsync(ifp);
}


static int frrequest(unit, req, data, set)
int unit;
#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD_version >= 300003)
u_long req;
#else
int req;
#endif
int set;
caddr_t data;
{
	register frentry_t *fp, *f, **fprev;
	register frentry_t **ftail;
	frentry_t frd;
	frdest_t *fdp;
	frgroup_t *fg = NULL;
	u_int   *p, *pp;
	int error = 0, in;
	u_int group;

	fp = &frd;
	error = IRCOPYPTR(data, (caddr_t)fp, sizeof(*fp));
	if (error)
		return EFAULT;
	fp->fr_ref = 0;
#if (BSD >= 199306) && defined(_KERNEL)
	if ((securelevel > 0) && (fp->fr_func != NULL))
		return EPERM;
#endif

	/*
	 * Check that the group number does exist and that if a head group
	 * has been specified, doesn't exist.
	 */
	if ((req != SIOCZRLST) && fp->fr_grhead &&
	    fr_findgroup((u_int)fp->fr_grhead, fp->fr_flags, unit, set, NULL))
		return EEXIST;
	if ((req != SIOCZRLST) && fp->fr_group &&
	    !fr_findgroup((u_int)fp->fr_group, fp->fr_flags, unit, set, NULL))
		return ESRCH;

	in = (fp->fr_flags & FR_INQUE) ? 0 : 1;

	if (unit == IPL_LOGAUTH)
		ftail = fprev = &ipauth;
	else if ((fp->fr_flags & FR_ACCOUNT) && (fp->fr_v == 4))
		ftail = fprev = &ipacct[in][set];
	else if ((fp->fr_flags & (FR_OUTQUE|FR_INQUE)) && (fp->fr_v == 4))
		ftail = fprev = &ipfilter[in][set];
#ifdef	USE_INET6
	else if ((fp->fr_flags & FR_ACCOUNT) && (fp->fr_v == 6))
		ftail = fprev = &ipacct6[in][set];
	else if ((fp->fr_flags & (FR_OUTQUE|FR_INQUE)) && (fp->fr_v == 6))
		ftail = fprev = &ipfilter6[in][set];
#endif
	else
		return ESRCH;

	if ((group = fp->fr_group)) {
		if (!(fg = fr_findgroup(group, fp->fr_flags, unit, set, NULL)))
			return ESRCH;
		ftail = fprev = fg->fg_start;
	}

	bzero((char *)frcache, sizeof(frcache[0]) * 2);

	if (*fp->fr_ifname) {
		fp->fr_ifa = GETUNIT(fp->fr_ifname, fp->fr_v);
		if (!fp->fr_ifa)
			fp->fr_ifa = (void *)-1;
	}
#if BSD >= 199306
	if (*fp->fr_oifname) {
		fp->fr_oifa = GETUNIT(fp->fr_oifname, fp->fr_v);
		if (!fp->fr_oifa)
			fp->fr_oifa = (void *)-1;
	}
#endif

	fdp = &fp->fr_dif;
	fp->fr_flags &= ~FR_DUP;
	if (*fdp->fd_ifname) {
		fdp->fd_ifp = GETUNIT(fdp->fd_ifname, fp->fr_v);
		if (!fdp->fd_ifp)
			fdp->fd_ifp = (struct ifnet *)-1;
		else
			fp->fr_flags |= FR_DUP;
	}

	fdp = &fp->fr_tif;
	if (*fdp->fd_ifname) {
		fdp->fd_ifp = GETUNIT(fdp->fd_ifname, fp->fr_v);
		if (!fdp->fd_ifp)
			fdp->fd_ifp = (struct ifnet *)-1;
	}

	/*
	 * Look for a matching filter rule, but don't include the next or
	 * interface pointer in the comparison (fr_next, fr_ifa).
	 */
	for (fp->fr_cksum = 0, p = (u_int *)&fp->fr_ip, pp = &fp->fr_cksum;
	     p < pp; p++)
		fp->fr_cksum += *p;

	for (; (f = *ftail); ftail = &f->fr_next)
		if ((fp->fr_cksum == f->fr_cksum) &&
		    !bcmp((char *)&f->fr_ip, (char *)&fp->fr_ip, FR_CMPSIZ))
			break;

	/*
	 * If zero'ing statistics, copy current to caller and zero.
	 */
	if (req == SIOCZRLST) {
		if (!f)
			return ESRCH;
		error = IWCOPYPTR((caddr_t)f, data, sizeof(*f));
		if (error)
			return EFAULT;
		f->fr_hits = 0;
		f->fr_bytes = 0;
		return 0;
	}

	if (!f) {
		if (req != SIOCINAFR && req != SIOCINIFR)
			while ((f = *ftail))
				ftail = &f->fr_next;
		else {
			if (fp->fr_hits) {
				ftail = fprev;
				while (--fp->fr_hits && (f = *ftail))
					ftail = &f->fr_next;
			}
			f = NULL;
		}
	}

	if (req == SIOCRMAFR || req == SIOCRMIFR) {
		if (!f)
			error = ESRCH;
		else {
			/*
			 * Only return EBUSY if there is a group list, else
			 * it's probably just state information referencing
			 * the rule.
			 */
			if ((f->fr_ref > 1) && f->fr_grp)
				return EBUSY;
			if (fg && fg->fg_head)
				fg->fg_head->fr_ref--;
			if (unit == IPL_LOGAUTH)
				return fr_auth_ioctl(data, req, f, ftail);
			if (f->fr_grhead)
				fr_delgroup((u_int)f->fr_grhead, fp->fr_flags,
					    unit, set);
			fixskip(fprev, f, -1);
			*ftail = f->fr_next;
			f->fr_next = NULL;
			if (f->fr_ref == 0)
				KFREE(f);
		}
	} else {
		if (f)
			error = EEXIST;
		else {
			if (unit == IPL_LOGAUTH)
				return fr_auth_ioctl(data, req, fp, ftail);
			KMALLOC(f, frentry_t *);
			if (f != NULL) {
				if (fg && fg->fg_head)
					fg->fg_head->fr_ref++;
				bcopy((char *)fp, (char *)f, sizeof(*f));
				f->fr_ref = 1;
				f->fr_hits = 0;
				f->fr_next = *ftail;
				*ftail = f;
				if (req == SIOCINIFR || req == SIOCINAFR)
					fixskip(fprev, f, 1);
				f->fr_grp = NULL;
				if ((group = f->fr_grhead))
					fg = fr_addgroup(group, f, unit, set);
			} else
				error = ENOMEM;
		}
	}
	return (error);
}


#ifdef	_KERNEL
/*
 * routines below for saving IP headers to buffer
 */
# ifdef __sgi
#  ifdef _KERNEL
int IPL_EXTERN(open)(dev_t *pdev, int flags, int devtype, cred_t *cp)
#  else
int IPL_EXTERN(open)(dev_t dev, int flags)
#  endif
# else
int IPL_EXTERN(open)(dev, flags
#  if ((_BSDI_VERSION >= 199510) || (BSD >= 199506) || (NetBSD >= 199511) || \
     (__FreeBSD_version >= 220000) || defined(__OpenBSD__)) && defined(_KERNEL)
, devtype, p)
int devtype;
struct proc *p;
#  else
)
#  endif
dev_t dev;
int flags;
# endif /* __sgi */
{
# if defined(__sgi) && defined(_KERNEL)
	u_int min = geteminor(*pdev);
# else
	u_int min = GET_MINOR(dev);
# endif

	if (IPL_LOGMAX < min)
		min = ENXIO;
	else
		min = 0;
	return min;
}


# ifdef __sgi
int IPL_EXTERN(close)(dev_t dev, int flags, int devtype, cred_t *cp)
#else
int IPL_EXTERN(close)(dev, flags
#  if ((_BSDI_VERSION >= 199510) || (BSD >= 199506) || (NetBSD >= 199511) || \
     (__FreeBSD_version >= 220000) || defined(__OpenBSD__)) && defined(_KERNEL)
, devtype, p)
int devtype;
struct proc *p;
#  else
)
#  endif
dev_t dev;
int flags;
# endif /* __sgi */
{
	u_int	min = GET_MINOR(dev);

	if (IPL_LOGMAX < min)
		min = ENXIO;
	else
		min = 0;
	return min;
}

/*
 * iplread/ipllog
 * both of these must operate with at least splnet() lest they be
 * called during packet processing and cause an inconsistancy to appear in
 * the filter lists.
 */
# ifdef __sgi
int IPL_EXTERN(read)(dev_t dev, uio_t *uio, cred_t *crp)
# else
#  if BSD >= 199306
int IPL_EXTERN(read)(dev, uio, ioflag)
int ioflag;
#  else
int IPL_EXTERN(read)(dev, uio)
#  endif
dev_t dev;
register struct uio *uio;
# endif /* __sgi */
{
# ifdef IPFILTER_LOG
	return ipflog_read(GET_MINOR(dev), uio);
# else
	return ENXIO;
# endif
}


/*
 * send_reset - this could conceivably be a call to tcp_respond(), but that
 * requires a large amount of setting up and isn't any more efficient.
 */
int send_reset(oip, fin)
struct ip *oip;
fr_info_t *fin;
{
	struct tcphdr *tcp, *tcp2;
	int tlen = 0, hlen;
	struct mbuf *m;
#ifdef	USE_INET6
	ip6_t *ip6, *oip6 = (ip6_t *)oip;
#endif
	ip_t *ip;

	tcp = (struct tcphdr *)fin->fin_dp;
	if (tcp->th_flags & TH_RST)
		return -1;		/* feedback loop */
# if	(BSD < 199306) || defined(__sgi)
	m = m_get(M_DONTWAIT, MT_HEADER);
# else
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
# endif
	if (m == NULL)
		return ENOBUFS;
	if (m == NULL)
		return -1;

	tlen = oip->ip_len - fin->fin_hlen - (tcp->th_off << 2) +
			((tcp->th_flags & TH_SYN) ? 1 : 0) +
			((tcp->th_flags & TH_FIN) ? 1 : 0);

#ifdef	USE_INET6
	hlen = (fin->fin_v == 6) ? sizeof(ip6_t) : sizeof(ip_t);
#else
	hlen = sizeof(ip_t);
#endif
	m->m_len = sizeof(*tcp2) + hlen;
# if	BSD >= 199306
	m->m_data += max_linkhdr;
	m->m_pkthdr.len = m->m_len;
	m->m_pkthdr.rcvif = (struct ifnet *)0;
# endif
	ip = mtod(m, struct ip *);
# ifdef	USE_INET6
	ip6 = (ip6_t *)ip;
# endif
	bzero((char *)ip, sizeof(*tcp2) + hlen);
	tcp2 = (struct tcphdr *)((char *)ip + hlen);

	tcp2->th_sport = tcp->th_dport;
	tcp2->th_dport = tcp->th_sport;
	if (tcp->th_flags & TH_ACK) {
		tcp2->th_seq = tcp->th_ack;
		tcp2->th_flags = TH_RST;
	} else {
		tcp2->th_ack = ntohl(tcp->th_seq);
		tcp2->th_ack += tlen;
		tcp2->th_ack = htonl(tcp2->th_ack);
		tcp2->th_flags = TH_RST|TH_ACK;
	}
	tcp2->th_off = sizeof(*tcp2) >> 2;
# ifdef	USE_INET6
	if (fin->fin_v == 6) {
		ip6->ip6_plen = htons(sizeof(struct tcphdr));
		ip6->ip6_nxt = IPPROTO_TCP;
		ip6->ip6_src = oip6->ip6_dst;
		ip6->ip6_dst = oip6->ip6_src;
		tcp2->th_sum = in6_cksum(m, IPPROTO_TCP,
					 sizeof(*ip6), sizeof(*tcp2));
		return send_ip(oip, fin, m);
	}
# endif
	ip->ip_p = IPPROTO_TCP;
	ip->ip_len = htons(sizeof(struct tcphdr));
	ip->ip_src.s_addr = oip->ip_dst.s_addr;
	ip->ip_dst.s_addr = oip->ip_src.s_addr;
	tcp2->th_sum = in_cksum(m, hlen + sizeof(*tcp2));
	ip->ip_len = hlen + sizeof(*tcp2);
	return send_ip(oip, fin, m);
}


static int send_ip(oip, fin, m)
ip_t *oip;
fr_info_t *fin;
struct mbuf *m;
{
	ip_t *ip;

	ip = mtod(m, ip_t *);

	ip->ip_v = fin->fin_v;
	if (ip->ip_v == 4) {
		ip->ip_hl = (sizeof(*oip) >> 2);
		ip->ip_v = IPVERSION;
		ip->ip_tos = oip->ip_tos;
		ip->ip_id = oip->ip_id;
		ip->ip_off = 0;
# if (BSD < 199306) || defined(__sgi)
		ip->ip_ttl = tcp_ttl;
# else
		ip->ip_ttl = ip_defttl;
# endif
		ip->ip_sum = 0;
	}
# ifdef	USE_INET6
	else if (ip->ip_v == 6) {
		ip6_t *ip6 = (ip6_t *)ip;

		ip6->ip6_hlim = 127;

		return ip6_output(m, NULL, NULL, 0, NULL, NULL);
	}
# endif
# ifdef	IPSEC
	m->m_pkthdr.rcvif = NULL;
# endif
	return ipfr_fastroute(m, fin, NULL);
}


int send_icmp_err(oip, type, fin, dst)
ip_t *oip;
int type;
fr_info_t *fin;
int dst;
{
	int err, hlen = 0, xtra = 0, iclen, ohlen = 0, avail, code;
	struct in_addr dst4;
	struct icmp *icmp;
	struct mbuf *m;
	void *ifp;
#ifdef USE_INET6
	ip6_t *ip6, *oip6 = (ip6_t *)oip;
	struct in6_addr dst6;
#endif
	ip_t *ip;

	if ((type < 0) || (type > ICMP_MAXTYPE))
		return -1;

	code = fin->fin_icode;
#ifdef USE_INET6
	if ((code < 0) || (code > sizeof(icmptoicmp6unreach)/sizeof(int)))
		return -1;
#endif

	avail = 0;
	m = NULL;
	ifp = fin->fin_ifp;
	if (fin->fin_v == 4) {
		if ((oip->ip_p == IPPROTO_ICMP) &&
		    !(fin->fin_fi.fi_fl & FI_SHORT))
			switch (ntohs(fin->fin_data[0]) >> 8)
			{
			case ICMP_ECHO :
			case ICMP_TSTAMP :
			case ICMP_IREQ :
			case ICMP_MASKREQ :
				break;
			default :
				return 0;
			}

# if	(BSD < 199306) || defined(__sgi)
		avail = MLEN;
		m = m_get(M_DONTWAIT, MT_HEADER);
# else
		avail = MHLEN;
		m = m_gethdr(M_DONTWAIT, MT_HEADER);
# endif
		if (m == NULL)
			return ENOBUFS;

		if (dst == 0) {
			if (fr_ifpaddr(4, ifp, &dst4) == -1)
				return -1;
		} else
			dst4.s_addr = oip->ip_dst.s_addr;

		hlen = sizeof(ip_t);
		ohlen = oip->ip_hl << 2;
		xtra = 8;
	}

#ifdef	USE_INET6
	else if (fin->fin_v == 6) {
		hlen = sizeof(ip6_t);
		ohlen = sizeof(ip6_t);
		type = icmptoicmp6types[type];
		if (type == ICMP6_DST_UNREACH)
			code = icmptoicmp6unreach[code];

		MGETHDR(m, M_DONTWAIT, MT_HEADER);
		if (!m)
			return ENOBUFS;

		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
			return ENOBUFS;
		}
# ifdef	M_TRAILINGSPACE
		m->m_len = 0;
		avail = M_TRAILINGSPACE(m);
# else
		avail = (m->m_flags & M_EXT) ? MCLBYTES : MHLEN;
# endif
		xtra = MIN(ntohs(oip6->ip6_plen) + sizeof(ip6_t),
			   avail - hlen - sizeof(*icmp) - max_linkhdr);
		if (dst == 0) {
			if (fr_ifpaddr(6, ifp, (struct in_addr *)&dst6) == -1)
				return -1;
		} else
			dst6 = oip6->ip6_dst;
	}
#endif

	iclen = hlen + sizeof(*icmp);
# if	BSD >= 199306
	avail -= (max_linkhdr + iclen);
	m->m_data += max_linkhdr;
	m->m_pkthdr.rcvif = (struct ifnet *)0;
	if (xtra > avail)
		xtra = avail;
	iclen += xtra;
	m->m_pkthdr.len = iclen;
#else
	avail -= (m->m_off + iclen);
	if (xtra > avail)
		xtra = avail;
	iclen += xtra;
#endif
	m->m_len = iclen;
	ip = mtod(m, ip_t *);
	icmp = (struct icmp *)((char *)ip + hlen);
	bzero((char *)ip, iclen);

	icmp->icmp_type = type;
	icmp->icmp_code = fin->fin_icode;
	icmp->icmp_cksum = 0;
#ifdef	icmp_nextmtu
	if (type == ICMP_UNREACH &&
	    fin->fin_icode == ICMP_UNREACH_NEEDFRAG && ifp)
		icmp->icmp_nextmtu = htons(((struct ifnet *) ifp)->if_mtu);
#endif

	if (avail) {
		bcopy((char *)oip, (char *)&icmp->icmp_ip, MIN(ohlen, avail));
		avail -= MIN(ohlen, avail);
	}

#ifdef	USE_INET6
	ip6 = (ip6_t *)ip;
	if (fin->fin_v == 6) {
		ip6->ip6_flow = 0;
		ip6->ip6_plen = htons(iclen - hlen);
		ip6->ip6_nxt = IPPROTO_ICMPV6;
		ip6->ip6_hlim = 0;
		ip6->ip6_src = dst6;
		ip6->ip6_dst = oip6->ip6_src;
		if (avail)
			bcopy((char *)oip + ohlen,
			      (char *)&icmp->icmp_ip + ohlen, avail);
		icmp->icmp_cksum = in6_cksum(m, IPPROTO_ICMPV6,
					     sizeof(*ip6), iclen - hlen);
	} else
#endif
	{
		ip->ip_src.s_addr = dst4.s_addr;
		ip->ip_dst.s_addr = oip->ip_src.s_addr;

		if (avail > 8)
			avail = 8;
		if (avail)
			bcopy((char *)oip + ohlen,
			      (char *)&icmp->icmp_ip + ohlen, avail);
		icmp->icmp_cksum = ipf_cksum((u_short *)icmp,
					     sizeof(*icmp) + 8);
		ip->ip_len = iclen;
		ip->ip_p = IPPROTO_ICMP;
	}
	err = send_ip(oip, fin, m);
	return err;
}


# if !defined(IPFILTER_LKM) && (__FreeBSD_version < 300000) && !defined(__sgi)
#  if	(BSD < 199306)
int iplinit __P((void));

int
#  else
void iplinit __P((void));

void
#  endif
iplinit()
{
	if (iplattach() != 0)
		printf("IP Filter failed to attach\n");
	ip_init();
}
# endif /* ! __NetBSD__ */


size_t mbufchainlen(m0)
register struct mbuf *m0;
{
	register size_t len = 0;

	for (; m0; m0 = m0->m_next)
		len += m0->m_len;
	return len;
}


int ipfr_fastroute(m0, fin, fdp)
struct mbuf *m0;
fr_info_t *fin;
frdest_t *fdp;
{
	register struct ip *ip, *mhip;
	register struct mbuf *m = m0;
	register struct route *ro;
	int len, off, error = 0, hlen, code;
	struct ifnet *ifp, *sifp;
	struct sockaddr_in *dst;
	struct route iproute;
	frentry_t *fr;

	hlen = fin->fin_hlen;
	ip = mtod(m0, struct ip *);

#ifdef	USE_INET6
	if (ip->ip_v == 6) {
		/*
		 * currently "to <if>" and "to <if>:ip#" are not supported
		 * for IPv6
		 */
		return ip6_output(m0, NULL, NULL, 0, NULL, NULL);
	}
#endif
	/*
	 * Route packet.
	 */
	ro = &iproute;
	bzero((caddr_t)ro, sizeof (*ro));
	dst = (struct sockaddr_in *)&ro->ro_dst;
	dst->sin_family = AF_INET;

	fr = fin->fin_fr;
	if (fdp)
		ifp = fdp->fd_ifp;
	else {
		ifp = fin->fin_ifp;
		dst->sin_addr = ip->ip_dst;
	}

	/*
	 * In case we're here due to "to <if>" being used with "keep state",
	 * check that we're going in the correct direction.
	 */
	if ((fr != NULL) && (fin->fin_rev != 0)) {
		if ((ifp != NULL) && (fdp == &fr->fr_tif))
			return -1;
		dst->sin_addr = ip->ip_dst;
	} else if (fdp) {
		if (fdp->fd_ip.s_addr) {
			dst->sin_addr = fdp->fd_ip;
			ip->ip_dst = fdp->fd_ip;
		} else
			dst->sin_addr = ip->ip_dst; 
	}

# if BSD >= 199306
	dst->sin_len = sizeof(*dst);
# endif
# if	(BSD >= 199306) && !defined(__NetBSD__) && !defined(__bsdi__) && \
	!defined(__OpenBSD__)
#  ifdef	RTF_CLONING
	rtalloc_ign(ro, RTF_CLONING);
#  else
	rtalloc_ign(ro, RTF_PRCLONING);
#  endif
# else
	rtalloc(ro);
# endif
	if (!ifp) {
		if (!fr || !(fr->fr_flags & FR_FASTROUTE)) {
			error = -2;
			goto bad;
		}
		if (ro->ro_rt == 0 || (ifp = ro->ro_rt->rt_ifp) == 0) {
			if (in_localaddr(ip->ip_dst))
				error = EHOSTUNREACH;
			else
				error = ENETUNREACH;
			goto bad;
		}
		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			dst = (struct sockaddr_in *)&ro->ro_rt->rt_gateway;
	}
	if (ro->ro_rt)
		ro->ro_rt->rt_use++;

	/*
	 * For input packets which are being "fastrouted", they won't
	 * go back through output filtering and miss their chance to get
	 * NAT'd and counted.
	 */
	fin->fin_ifp = ifp;
	if (fin->fin_out == 0) {
		fin->fin_out = 1;
		if ((fin->fin_fr = ipacct[1][fr_active]) &&
		    (fr_scanlist(FR_NOMATCH, ip, fin, m) & FR_ACCOUNT)) {
			ATOMIC_INCL(frstats[1].fr_acct);
		}
		fin->fin_fr = NULL;
		if (!fr || !(fr->fr_flags & FR_RETMASK))
			(void) fr_checkstate(ip, fin);
		(void) ip_natout(ip, fin);
	} else
		ip->ip_sum = 0;
	/*
	 * If small enough for interface, can just send directly.
	 */
	if (ip->ip_len <= ifp->if_mtu) {
# if	BSD >= 199306
		int i = 0;

#  ifdef	MCLISREFERENCED
		if ((m->m_flags & M_EXT) && MCLISREFERENCED(m))
#  else
		if (m->m_flags & M_EXT)
#  endif
			i = 1;
# endif
		ip->ip_id = htons(ip->ip_id);
		ip->ip_len = htons(ip->ip_len);
		ip->ip_off = htons(ip->ip_off);
		if (!ip->ip_sum)
			ip->ip_sum = in_cksum(m, hlen);
# if	BSD >= 199306
		error = (*ifp->if_output)(ifp, m, (struct sockaddr *)dst,
					  ro->ro_rt);
		if (i) {
			ip->ip_id = ntohs(ip->ip_id);
			ip->ip_len = ntohs(ip->ip_len);
			ip->ip_off = ntohs(ip->ip_off);
		}
# else
		error = (*ifp->if_output)(ifp, m, (struct sockaddr *)dst);
# endif
		goto done;
	}
	/*
	 * Too large for interface; fragment if possible.
	 * Must be able to put at least 8 bytes per fragment.
	 */
	if (ip->ip_off & IP_DF) {
		error = EMSGSIZE;
		goto bad;
	}
	len = (ifp->if_mtu - hlen) &~ 7;
	if (len < 8) {
		error = EMSGSIZE;
		goto bad;
	}

    {
	int mhlen, firstlen = len;
	struct mbuf **mnext = &m->m_act;

	/*
	 * Loop through length of segment after first fragment,
	 * make new header and copy data of each part and link onto chain.
	 */
	m0 = m;
	mhlen = sizeof (struct ip);
	for (off = hlen + len; off < ip->ip_len; off += len) {
# ifdef	MGETHDR
		MGETHDR(m, M_DONTWAIT, MT_HEADER);
# else
		MGET(m, M_DONTWAIT, MT_HEADER);
# endif
		if (m == 0) {
			error = ENOBUFS;
			goto bad;
		}
# if BSD >= 199306
		m->m_data += max_linkhdr;
# else
		m->m_off = MMAXOFF - hlen;
# endif
		mhip = mtod(m, struct ip *);
		bcopy((char *)ip, (char *)mhip, sizeof(*ip));
		if (hlen > sizeof (struct ip)) {
			mhlen = ip_optcopy(ip, mhip) + sizeof (struct ip);
			mhip->ip_hl = mhlen >> 2;
		}
		m->m_len = mhlen;
		mhip->ip_off = ((off - hlen) >> 3) + (ip->ip_off & ~IP_MF);
		if (ip->ip_off & IP_MF)
			mhip->ip_off |= IP_MF;
		if (off + len >= ip->ip_len)
			len = ip->ip_len - off;
		else
			mhip->ip_off |= IP_MF;
		mhip->ip_len = htons((u_short)(len + mhlen));
		m->m_next = m_copy(m0, off, len);
		if (m->m_next == 0) {
			error = ENOBUFS;	/* ??? */
			goto sendorfree;
		}
# if BSD >= 199306
		m->m_pkthdr.len = mhlen + len;
		m->m_pkthdr.rcvif = NULL;
# endif
		mhip->ip_off = htons((u_short)mhip->ip_off);
		mhip->ip_sum = 0;
		mhip->ip_sum = in_cksum(m, mhlen);
		*mnext = m;
		mnext = &m->m_act;
	}
	/*
	 * Update first fragment by trimming what's been copied out
	 * and updating header, then send each fragment (in order).
	 */
	m_adj(m0, hlen + firstlen - ip->ip_len);
	ip->ip_len = htons((u_short)(hlen + firstlen));
	ip->ip_off = htons((u_short)(ip->ip_off | IP_MF));
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m0, hlen);
sendorfree:
	for (m = m0; m; m = m0) {
		m0 = m->m_act;
		m->m_act = 0;
		if (error == 0)
# if BSD >= 199306
			error = (*ifp->if_output)(ifp, m,
			    (struct sockaddr *)dst, ro->ro_rt);
# else
			error = (*ifp->if_output)(ifp, m,
			    (struct sockaddr *)dst);
# endif
		else
			m_freem(m);
	}
    }	
done:
	if (!error)
		ipl_frouteok[0]++;
	else
		ipl_frouteok[1]++;

	if (ro->ro_rt)
		RTFREE(ro->ro_rt);
	return 0;
bad:
	if (error == EMSGSIZE) {
		sifp = fin->fin_ifp;
		code = fin->fin_icode;
		fin->fin_icode = ICMP_UNREACH_NEEDFRAG;
		fin->fin_ifp = ifp;
		(void) send_icmp_err(ip, ICMP_UNREACH, fin, 1);
		fin->fin_ifp = sifp;
		fin->fin_icode = code;
	}
	m_freem(m);
	goto done;
}


int fr_verifysrc(ipa, ifp)
struct in_addr ipa;
void *ifp;
{
	struct sockaddr_in *dst;
	struct route iproute;

	bzero((char *)&iproute, sizeof(iproute));
	dst = (struct sockaddr_in *)&iproute.ro_dst;
	dst->sin_family = AF_INET;
	dst->sin_addr = ipa;
# if    (BSD >= 199306) && !defined(__NetBSD__) && !defined(__bsdi__) && \
        !defined(__OpenBSD__)
#  ifdef        RTF_CLONING
	rtalloc_ign(&iproute, RTF_CLONING);
#  else
	rtalloc_ign(&iproute, RTF_PRCLONING);
#  endif
# else
	rtalloc(&iproute);
# endif
	if (iproute.ro_rt == NULL)
		return 0;
	return (ifp == iproute.ro_rt->rt_ifp);
}

#else /* #ifdef _KERNEL */


# ifdef __sgi
static int no_output __P((struct ifnet *ifp, struct mbuf *m,
			   struct sockaddr *s))
# else
static int no_output __P((struct ifnet *ifp, struct mbuf *m,
			   struct sockaddr *s, struct rtentry *rt))
# endif
{
	return 0;
}


# ifdef __STDC__
#  ifdef __sgi
static int write_output __P((struct ifnet *ifp, struct mbuf *m,
			     struct sockaddr *s))
#  else
static int write_output __P((struct ifnet *ifp, struct mbuf *m,
			     struct sockaddr *s, struct rtentry *rt))
#  endif
{
	ip_t *ip = (ip_t *)m;
# else
static int write_output(ifp, ip)
struct ifnet *ifp;
ip_t *ip;
{
# endif
	char fname[32];
	FILE *fp;

# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
#    if defined __OpenBSD__
	sprintf(fname, "/var/run/%s", ifp->if_xname);
#    else
	sprintf(fname, "/tmp/%s", ifp->if_xname);
#    endif
# else
	sprintf(fname, "/tmp/%s%d", ifp->if_name, ifp->if_unit);
# endif
	/*
	 * XXX
	 * This is still raceable, if the attacker gains the ability to
	 * erase the existing file in /tmp
	 */
	if ((fp = fopen(fname, "a"))) {
		fwrite((char *)ip, ntohs(ip->ip_len), 1, fp);
		fclose(fp);
	}
	return 0;
}


struct ifnet *get_unit(name, v)
char *name;
int v;
{
	struct ifnet *ifp, **ifa, **nifneta;
# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
	for (ifa = ifneta; ifa && (ifp = *ifa); ifa++) {
		if (!strcmp(name, ifp->if_xname))
			return ifp;
	}
# else
	char ifname[32], *s;

	for (ifa = ifneta; ifa && (ifp = *ifa); ifa++) {
		(void) sprintf(ifname, "%s%d", ifp->if_name, ifp->if_unit);
		if (!strcmp(name, ifname))
			return ifp;
	}
# endif

	if (!ifneta) {
		ifneta = (struct ifnet **)malloc(sizeof(ifp) * 2);
		if (!ifneta)
			return NULL;
		ifneta[1] = NULL;
		ifneta[0] = (struct ifnet *)calloc(1, sizeof(*ifp));
		if (!ifneta[0]) {
			free(ifneta);
			return NULL;
		}
		nifs = 1;
	} else {
		nifs++;
		nifneta = (struct ifnet **)realloc(ifneta,
						  (nifs + 1) * sizeof(*ifa));
		if (!nifneta) {
			nifs = 0;
			free(ifneta);
			return NULL;
		}
		ifneta = nifneta;
		ifneta[nifs] = NULL;
		ifneta[nifs - 1] = (struct ifnet *)malloc(sizeof(*ifp));
		if (!ifneta[nifs - 1]) {
			nifs--;
			return NULL;
		}
	}
	ifp = ifneta[nifs - 1];

# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
	strncpy(ifp->if_xname, name, sizeof(ifp->if_xname));
# else
	for (s = name; *s && !isdigit(*s); s++)
		;
	if (*s && isdigit(*s)) {
		ifp->if_unit = atoi(s);
		ifp->if_name = (char *)malloc(s - name + 1);
		strncpy(ifp->if_name, name, s - name);
		ifp->if_name[s - name] = '\0';
	} else {
		ifp->if_name = strdup(name);
		ifp->if_unit = -1;
	}
# endif
	ifp->if_output = no_output;
	return ifp;
}



void init_ifp()
{
	struct ifnet *ifp, **ifa;
	char fname[32];
	int fd;

# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
	for (ifa = ifneta; ifa && (ifp = *ifa); ifa++) {
		ifp->if_output = write_output;
#    if defined(__OpenBSD__)
		sprintf(fname, "/var/run/%s", ifp->if_xname);
#    else
		sprintf(fname, "/tmp/%s", ifp->if_xname);
#    endif
		fd = open(fname, O_WRONLY|O_CREAT|O_EXCL|O_TRUNC, 0600);
		if (fd == -1)
			perror("open");
		else
			close(fd);
	}
# else

	for (ifa = ifneta; ifa && (ifp = *ifa); ifa++) {
		ifp->if_output = write_output;
		sprintf(fname, "/tmp/%s%d", ifp->if_name, ifp->if_unit);
		fd = open(fname, O_WRONLY|O_CREAT|O_EXCL|O_TRUNC, 0600);
		if (fd == -1)
			perror("open");
		else
			close(fd);
	}
# endif
}


int ipfr_fastroute(ip, fin, fdp)
ip_t *ip;
fr_info_t *fin;
frdest_t *fdp;
{
	struct ifnet *ifp = fdp->fd_ifp;

	if (!ifp)
		return 0;	/* no routing table out here */

	ip->ip_len = htons((u_short)ip->ip_len);
	ip->ip_off = htons((u_short)(ip->ip_off | IP_MF));
	ip->ip_sum = 0;
#ifdef __sgi
	(*ifp->if_output)(ifp, (void *)ip, NULL);
#else
	(*ifp->if_output)(ifp, (void *)ip, NULL, 0);
#endif
	return 0;
}


int ipllog __P((void))
{
	verbose("l");
	return 0;
}


int send_reset(ip, ifp)
ip_t *ip;
struct ifnet *ifp;
{
	verbose("- TCP RST sent\n");
	return 0;
}


int icmp_error(ip, ifp)
ip_t *ip;
struct ifnet *ifp;
{
	verbose("- TCP RST sent\n");
	return 0;
}


void frsync()
{
	return;
}
#endif /* _KERNEL */
@


1.46
log
@Fix realloc possible leak; this is userland, not kernel; reported by
Ted U <grendel@@heorot.stanford.edu>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.45 2001/05/08 20:02:59 fgsch Exp $	*/
@


1.45
log
@When `dup-to if:addr' clause is used, be sure to rewrite the dest addr
with the one supplied; fix by ericj@@, darrenr notified.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.44 2001/05/08 19:58:01 fgsch Exp $	*/
d1646 1
a1646 1
	struct ifnet *ifp, **ifa;
d1676 1
a1676 1
		ifneta = (struct ifnet **)realloc(ifneta,
d1678 1
a1678 1
		if (!ifneta) {
d1680 1
d1683 1
@


1.44
log
@IPfilter 3.4.17; kjell@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.43 2001/04/22 19:44:34 gluk Exp $	*/
d1352 7
a1358 2
	} else if (fdp)
		dst->sin_addr = fdp->fd_ip.s_addr ? fdp->fd_ip : ip->ip_dst;
@


1.43
log
@Fix spl handling in ipfilter ioctl interface. Work by aaron@@ and me.
Problem was reported by DK <obsd@@snti.com> as kernel panic loading ipa -
"WARNING: SPL NOT LOWERED ON SYSCALL EXIT".

deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.42 2001/03/07 05:43:17 aaron Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-2000 by Darren Reed.
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.42.2.17 2000/10/19 15:39:42 darrenr Exp $";
d257 1
a257 1
		return -1;
d261 1
a261 1
		return -1;
d265 1
a265 1
		return -1;
@


1.43.2.1
log
@Two fastroute fixes (gets byte ordering correct in more cases).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.43 2001/04/22 19:44:34 gluk Exp $	*/
d1381 1
a1381 1
			dst = satosin(ro->ro_rt->rt_gateway);
d1416 1
a1416 1
			i = 0;
@


1.42
log
@Missing SPL_X(); deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.41 2001/02/06 17:29:30 fgsch Exp $	*/
d276 1
d293 1
d405 2
a406 1
	if (error)
d408 1
d415 2
a416 1
	if (error)
d418 1
d521 4
a524 3
		if (!fr_running)
			return EIO;
		error = fr_auth_ioctl(data, cmd, NULL, NULL);
d598 1
a598 1
			return EFAULT;
d641 1
a641 1
			return EFAULT;
@


1.41
log
@ipf/ipnat check the securelevel in the original code, so don't do it twice.
Also remove uneeded definition of ICMP_UNREACH_FILTER_PROHIB; this isn't
needed. Why keep adding things to make diffs harder?
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.40 2001/01/30 04:23:55 kjell Exp $	*/
d255 2
a256 1
	if (nat_init() == -1)
d258 3
a260 1
	if (fr_stateinit() == -1)
d262 3
a264 1
	if (appr_init() == -1)
d266 1
@


1.40
log
@re-add local ipf changes that were whacked in the 3.4.16 merge. userland to follow
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.39 2001/01/17 05:16:37 fgsch Exp $	*/
a135 3
# if defined (__OpenBSD__)
int	ipl_unreach = ICMP_UNREACH_FILTER_PROHIB;
# else
a136 2
# endif

d486 1
a486 28

# if defined(__OpenBSD__)
       	/* Prevent IPF changes when securelevel > 1 */
	if (securelevel > 1) {
		switch (cmd) {
#  ifndef IPFILTER_LKM
		case SIOCFRENB:
#  endif
		case SIOCSETFF:
		case SIOCADAFR:
		case SIOCADIFR:
		case SIOCINAFR:
		case SIOCINIFR:
		case SIOCRMAFR:
		case SIOCRMIFR:
		case SIOCZRLST:
		case SIOCSWAPA:
		case SIOCFRZST:
		case SIOCIPFFL:
#  ifdef IPFILTER_LOG
		case SIOCIPFFB:
#  endif
		case SIOCSTLCK:
			return EPERM;
		}
	}
# endif /* OpenBSD */
#else /* _KERNEL */
@


1.39
log
@include sys/timeout.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.38 2001/01/17 04:47:12 fgsch Exp $	*/
d102 1
a102 1
#include "netinet/ip_compat.h"
d106 6
a111 6
#include "netinet/ip_fil.h"
#include "netinet/ip_proxy.h"
#include "netinet/ip_nat.h"
#include "netinet/ip_frag.h"
#include "netinet/ip_state.h"
#include "netinet/ip_auth.h"
d136 3
d140 2
d182 1
a182 1
#include <sys/timeout.h>
d343 1
a343 1
 	ipfr_slowtimer_ch = timeout(ipfr_slowtimer, NULL, hz/2);
d375 1
a375 1
#   ifdef __sgi
a391 1
#if !defined(__OpenBSD__)
a392 1
#endif
d491 28
a518 1
#else
a1436 1
# ifndef sparc
a1439 1
# endif
a1517 1
# ifndef sparc
a1518 1
# endif
d1613 1
d1631 1
a1631 1
	int fd;
d1635 3
d1639 1
d1643 8
a1650 4
	fd = open(fname, O_WRONLY|O_APPEND);
	if (fd == -1) {
		perror("open");
		return -1;
a1651 2
	write(fd, (char *)ip, ntohs(ip->ip_len));
	close(fd);
d1737 3
d1741 1
@


1.38
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d177 1
@


1.37
log
@New timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.36 2000/08/10 05:50:25 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d11 2
a12 2
static const char sccsid[] = "@@(#)ip_fil.c	2.41 6/5/96 (C) 1993-1995 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.22 2000/07/08 02:43:47 darrenr Exp $";
d22 4
d31 2
a32 4
#ifdef	__FreeBSD__
# if defined(_KERNEL) && !defined(IPFILTER_LKM)
#  include <sys/osreldate.h>
# else
d102 10
a111 7
#include <netinet/ip_fil_compat.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_frag.h>
#include <netinet/ip_state.h>
#include <netinet/ip_auth.h>
a135 3
# if defined (__OpenBSD__)
int	ipl_unreach = ICMP_UNREACH_FILTER_PROHIB;
# else
a136 2
# endif

d139 2
a140 2
static	void	frzerostats __P((caddr_t));
#if defined(__NetBSD__) || defined(__OpenBSD__)
d172 9
a180 4

#ifdef __OpenBSD__
#include <sys/timeout.h>
struct timeout ipfr_slowtimer_to;
d266 3
d273 1
d278 13
d318 2
a319 2
	printf("IP Filter: initialized.  Default = %s all, Logging = %s\n",
		defpass,
a324 1
	printf("%s\n", ipfilter_version);
d327 12
a338 7
#ifdef	_KERNEL
# if (__FreeBSD_version >= 300000) && defined(_KERNEL)
	ipfr_slowtimer_ch = timeout(ipfr_slowtimer, NULL, hz/2);
# elif defined(__OpenBSD__)
	timeout_set(&ipfr_slowtimer_to, ipfr_slowtimer, NULL);
	timeout_add(&ipfr_slowtimer_to, hz/2);
#else
d340 2
d359 3
a361 5
#ifdef	_KERNEL
# if (__FreeBSD_version >= 300000)
	untimeout(ipfr_slowtimer, NULL, ipfr_slowtimer_ch);
# elif defined(__OpenBSD__)
	timeout_del(&ipfr_slowtimer_to);
d363 2
a364 2
#  ifdef __sgi
	untimeout(ipfr_slowtimer);
d366 6
d373 4
a376 2
#  endif
# endif
d386 4
d397 1
a397 1
			      &inetsw[ip_protox[IPPROTO_IP]].pr_pfh);
d403 6
d427 1
a427 1
static	void	frzerostats(data)
d431 6
a437 14
	bcopy((char *)frstats, (char *)fio.f_st,
		sizeof(struct filterstats) * 2);
	fio.f_fin[0] = ipfilter[0][0];
	fio.f_fin[1] = ipfilter[0][1];
	fio.f_fout[0] = ipfilter[1][0];
	fio.f_fout[1] = ipfilter[1][1];
	fio.f_acctin[0] = ipacct[0][0];
	fio.f_acctin[1] = ipacct[0][1];
	fio.f_acctout[0] = ipacct[1][0];
	fio.f_acctout[1] = ipacct[1][1];
	fio.f_active = fr_active;
	fio.f_froute[0] = ipl_frouteok[0];
	fio.f_froute[1] = ipl_frouteok[1];
	IWCOPY((caddr_t)&fio, data, sizeof(fio));
d439 2
d455 3
a457 2
#if ((_BSDI_VERSION >= 199510) || (BSD >= 199506) || (NetBSD >= 199511) || \
     (__FreeBSD_version >= 220000) || defined(__OpenBSD__)) && defined(_KERNEL)
d460 1
a460 1
#else
d462 1
a462 1
#endif
d464 2
a465 2
#if defined(__NetBSD__) || defined(__OpenBSD__) || \
	 (_BSDI_VERSION >= 199701) || (__FreeBSD_version >= 300000)
d467 1
a467 1
#else
d469 1
a469 1
#endif
d487 1
a487 31

# if defined(__OpenBSD__)
       	/* Prevent IPF and NAT changes when securelevel > 1 */
	if (securelevel > 1) {
		switch (cmd) {
#  ifndef IPFILTER_LKM
		case SIOCFRENB:
#  endif
		case SIOCSETFF:
		case SIOCADAFR:
		case SIOCADIFR:
		case SIOCINAFR:
		case SIOCINIFR:
		case SIOCRMAFR:
		case SIOCRMIFR:
		case SIOCZRLST:
		case SIOCSWAPA:
		case SIOCFRZST:
		case SIOCIPFFL:
#  ifdef IPFILTER_LOG
		case SIOCIPFFB:
#  endif
		case SIOCADNAT:
		case SIOCRMNAT:
		case SIOCFLNAT:
		case SIOCCNATL:
			return EPERM;
		}
	}
# endif /* OpenBSD */
#else /* _KERNEL */
a500 1

d509 7
d520 2
a521 2
		IWCOPY((caddr_t)&iplused[IPL_LOGIPF], (caddr_t)data,
		       sizeof(iplused[IPL_LOGIPF]));
d532 3
a534 1
			IRCOPY(data, (caddr_t)&enable, sizeof(enable));
d547 2
a548 1
			IRCOPY(data, (caddr_t)&fr_flags, sizeof(fr_flags));
d551 1
a551 1
		IWCOPY((caddr_t)&fr_flags, data, sizeof(fr_flags));
d581 1
a581 1
		struct	friostat	fio;
d583 4
a586 30
		bcopy((char *)frstats, (char *)fio.f_st,
			sizeof(struct filterstats) * 2);
		fio.f_fin[0] = ipfilter[0][0];
		fio.f_fin[1] = ipfilter[0][1];
		fio.f_fout[0] = ipfilter[1][0];
		fio.f_fout[1] = ipfilter[1][1];
		fio.f_acctin[0] = ipacct[0][0];
		fio.f_acctin[1] = ipacct[0][1];
		fio.f_acctout[0] = ipacct[1][0];
		fio.f_acctout[1] = ipacct[1][1];
		fio.f_auth = ipauth;
		fio.f_active = fr_active;
		fio.f_froute[0] = ipl_frouteok[0];
		fio.f_froute[1] = ipl_frouteok[1];
		fio.f_running = fr_running;
		fio.f_groups[0][0] = ipfgroups[0][0];
		fio.f_groups[0][1] = ipfgroups[0][1];
		fio.f_groups[1][0] = ipfgroups[1][0];
		fio.f_groups[1][1] = ipfgroups[1][1];
		fio.f_groups[2][0] = ipfgroups[2][0];
		fio.f_groups[2][1] = ipfgroups[2][1];
#ifdef	IPFILTER_LOG
		fio.f_logging = 1;
#else
		fio.f_logging = 0;
#endif
		fio.f_defpass = fr_pass;
		strncpy(fio.f_version, ipfilter_version,
			sizeof(fio.f_version));
		IWCOPY((caddr_t)&fio, data, sizeof(fio));
d593 1
a593 1
			frzerostats(data);
d599 6
a604 3
			IRCOPY(data, (caddr_t)&tmp, sizeof(tmp));
			tmp = frflush(unit, tmp);
			IWCOPY((caddr_t)&tmp, data, sizeof(tmp));
d607 10
d626 4
a629 1
		IWCOPY((caddr_t)ipfr_fragstats(), data, sizeof(ipfrstat_t));
a636 3
	case SIOCATHST :
		error = fr_auth_ioctl(data, cmd, NULL, NULL);
		break;
d674 14
d695 1
a695 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d708 1
d713 3
a715 1
	IRCOPY(data, (caddr_t)fp, sizeof(*fp));
d717 4
d737 1
a737 1
	else if (fp->fr_flags & FR_ACCOUNT)
d739 1
a739 1
	else if (fp->fr_flags & (FR_OUTQUE|FR_INQUE))
d741 6
d759 1
a759 1
		fp->fr_ifa = GETUNIT(fp->fr_ifname);
d765 1
a765 1
		fp->fr_oifa = GETUNIT(fp->fr_oifname);
d774 1
a774 1
		fdp->fd_ifp = GETUNIT(fdp->fd_ifname);
d783 1
a783 1
		fdp->fd_ifp = GETUNIT(fdp->fd_ifname);
d792 4
d797 2
a798 2
		if (bcmp((char *)&f->fr_ip, (char *)&fp->fr_ip,
			 FR_CMPSIZ) == 0)
d807 3
a809 1
		IWCOPY((caddr_t)f, data, sizeof(*f));
d816 4
a819 2
		if (req == SIOCINAFR || req == SIOCINIFR) {
			ftail = fprev;
d821 1
d829 1
a829 1
	if (req == SIOCDELFR || req == SIOCRMIFR) {
d833 6
a838 1
			if (f->fr_ref > 1)
d849 3
a851 1
			KFREE(f);
d980 1
d982 3
a984 1
	int tlen = 0;
d1000 10
a1009 3
	if (tcp->th_flags & TH_SYN)
		tlen = 1;
	m->m_len = sizeof(*tcp2) + sizeof(*ip);
d1012 1
a1012 1
	m->m_pkthdr.len = sizeof(*tcp2) + sizeof(*ip);
d1016 5
a1020 2
	bzero((char *)ip, sizeof(*tcp2) + sizeof(*ip));
	tcp2 = (struct tcphdr *)(ip + 1);
d1022 1
a1022 2
	ip->ip_src.s_addr = oip->ip_dst.s_addr;
	ip->ip_dst.s_addr = oip->ip_src.s_addr;
d1024 9
a1032 4
	tcp2->th_sport = tcp->th_dport;
	tcp2->th_ack = ntohl(tcp->th_seq);
	tcp2->th_ack += tlen;
	tcp2->th_ack = htonl(tcp2->th_ack);
d1034 11
a1044 1
	tcp2->th_flags = TH_RST|TH_ACK;
d1047 5
a1051 7
	tcp2->th_sum = in_cksum(m, sizeof(*ip) + sizeof(*tcp2));

	ip->ip_id = oip->ip_id;
	ip->ip_tos = oip->ip_tos;
	ip->ip_len = sizeof(*ip) + sizeof(*tcp2);

	return send_ip(ip, fin, m);
d1055 2
a1056 1
static int send_ip(ip, fin, m)
a1058 1
ip_t *ip;
d1060 11
a1070 2
	ip->ip_v = IPVERSION;
	ip->ip_hl = (sizeof(*ip) >> 2);
d1072 1
a1072 1
	ip->ip_ttl = tcp_ttl;
d1074 1
a1074 1
	ip->ip_ttl = ip_defttl;
d1076 7
d1084 3
d1098 1
a1098 1
struct in_addr dst;
d1100 2
d1104 6
a1109 2
	ip_t *nip;
	int code;
d1111 2
a1112 11
	if ((oip->ip_p == IPPROTO_ICMP) && !(fin->fin_fi.fi_fl & FI_SHORT))
		switch (ntohs(fin->fin_data[0]) >> 8)
		{
		case ICMP_ECHO :
		case ICMP_TSTAMP :
		case ICMP_IREQ :
		case ICMP_MASKREQ :
			break;
		default :
			return 0;
		}
d1115 22
d1138 40
a1177 1
	m = m_get(M_DONTWAIT, MT_HEADER);
d1179 1
a1179 1
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
d1181 11
a1191 3
	if (m == NULL)
		return ENOBUFS;
	m->m_len = sizeof(*nip) + sizeof(*icmp) + 8;
d1193 1
a1194 1
	m->m_pkthdr.len = sizeof(*nip) + sizeof(*icmp) + 8;
d1196 14
a1209 18
# endif

	bzero(mtod(m, char *), (size_t)sizeof(*nip) + sizeof(*icmp) + 8);
	nip = mtod(m, ip_t *);
	icmp = (struct icmp *)(nip + 1);

	nip->ip_p = IPPROTO_ICMP;
	nip->ip_id = oip->ip_id;
	nip->ip_sum = 0;
	nip->ip_ttl = 60;
	nip->ip_tos = oip->ip_tos;
	nip->ip_len = sizeof(*nip) + sizeof(*icmp) + 8;
	if (dst.s_addr == 0) {
		if (fr_ifpaddr(fin->fin_ifp, &dst) == -1)
			return -1;
	}
	nip->ip_src = dst;
	nip->ip_dst = oip->ip_src;
d1212 1
a1212 1
	icmp->icmp_code = code;
d1214 27
a1240 4
	bcopy((char *)oip, (char *)&icmp->icmp_ip, sizeof(*oip));
	bcopy((char *)oip + (oip->ip_hl << 2),
	      (char *)&icmp->icmp_ip + sizeof(*oip), 8);	/* 64 bits */
# ifndef	sparc
d1242 2
a1243 2
	register u_short	__iplen, __ipoff;
	ip_t *ip = &icmp->icmp_ip;
d1245 9
a1253 4
	__iplen = ip->ip_len;
	__ipoff = ip->ip_off;
	ip->ip_len = htons(__iplen);
	ip->ip_off = htons(__ipoff);
d1255 2
a1256 3
# endif
	icmp->icmp_cksum = ipf_cksum((u_short *)icmp, sizeof(*icmp) + 8);
	return send_ip(nip, fin, m);
d1306 10
d1384 1
a1384 1
			ATOMIC_INC(frstats[1].fr_acct);
d1387 1
a1387 1
		if (!fr || !(fr->fr_flags & FR_RETMASK)) {
d1389 1
a1389 2
			(void) ip_natout(ip, fin);
		}
d1396 11
d1410 1
d1416 5
d1489 1
d1491 1
a1533 1
		fin->fin_ifp = ifp;
d1536 2
a1537 1
		(void) send_icmp_err(ip, ICMP_UNREACH, fin, ip->ip_dst);
d1544 28
a1585 1

d1603 1
a1603 1
	FILE *fp;
a1606 3
#    if defined __OpenBSD__
	sprintf(fname, "/var/run/%s", ifp->if_xname);
#    else
a1607 1
#    endif
d1611 4
a1614 8
	/*
	 * XXX
	 * This is still raceable, if the attacker gains the ability to
	 * erase the existing file in /tmp
	 */
	if ((fp = fopen(fname, "a"))) {
		fwrite((char *)ip, ntohs(ip->ip_len), 1, fp);
		fclose(fp);
d1616 2
d1622 1
a1622 1
struct ifnet *get_unit(name)
d1624 1
a1702 3
#    if defined(__OpenBSD__)
		sprintf(fname, "/var/run/%s", ifp->if_xname);
#    else
a1703 1
#    endif
@


1.36
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.35 2000/05/24 21:59:11 kjell Exp $	*/
d173 5
d309 4
a312 1
# else
d334 2
@


1.35
log
@Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
  RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.34 2000/05/01 06:16:47 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.21 2000/05/22 06:57:47 darrenr Exp $";
d1404 2
d1408 4
d1417 4
d1423 4
@


1.34
log
@Update to ipfilter 3.3.13. This should be the last of the 3.3.x releases.
This patch fixes mostly ICMP timeout problems, as the ftp proxy
changes were imported previously.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.33 2000/04/05 05:35:27 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.20 2000/04/18 16:31:27 darrenr Exp $";
d147 1
a147 1
static	int	send_ip __P((struct mbuf *, ip_t *));
d917 2
a918 1
int send_reset(fin, oip)
a919 1
struct ip *oip;
a921 1
	struct tcpiphdr *tp;
d944 1
a944 1
	m->m_pkthdr.len = m->m_len;
a946 1
	bzero(mtod(m, char *), sizeof(struct tcpiphdr));
d948 2
a949 2
	tp = mtod(m, struct tcpiphdr *);
	tcp2 = (struct tcphdr *)((char *)ip + sizeof(*ip));
d960 2
a961 2
	tp->ti_pr = oip->ip_p;
	tp->ti_len = htons(sizeof(struct tcphdr));
d964 1
a965 1
	ip->ip_p = oip->ip_p;
d968 1
a968 1
	return send_ip(m, ip);
d972 2
a973 1
static int send_ip(m, ip)
d977 2
a978 5
# if (defined(__FreeBSD_version) && (__FreeBSD_version >= 220000)) || \
     (defined(_BSDI_VERSION) && (_BSDI_VERSION >= 199802))
	struct route ro;
# endif

d988 1
a988 24
# if defined(__FreeBSD_version) && (__FreeBSD_version >= 220000)
	{
	int err;

	bzero((char *)&ro, sizeof(ro));
	err = ip_output(m, (struct mbuf *)0, &ro, 0, 0);
	if (ro.ro_rt)
		RTFREE(ro.ro_rt);
	return err;
	}
# else
	/*
	 * extra 0 in case of multicast
	 */
#  if _BSDI_VERSION >= 199802
	return ip_output(m, (struct mbuf *)0, &ro, 0, 0, NULL);
#  else
#   if	defined(__OpenBSD__)
	return ip_output(m, (struct mbuf *)0, 0, 0, 0, NULL);
#   else
	return ip_output(m, (struct mbuf *)0, 0, 0, 0);
#   endif
#  endif
# endif
d992 1
a992 1
int send_icmp_err(oip, type, code, ifp, dst)
d994 2
a995 2
int type, code;
void *ifp;
d1001 1
d1003 13
a1033 2
	nip->ip_v = IPVERSION;
	nip->ip_hl = (sizeof(*nip) >> 2);
d1041 1
a1041 1
		if (fr_ifpaddr(ifp, &dst) == -1)
d1065 1
a1065 1
	return send_ip(m, nip);
d1107 2
a1108 1
	int len, off, error = 0, hlen;
a1110 1
	struct ifnet *ifp;
d1124 7
a1130 1
	ifp = fdp->fd_ifp;
d1139 1
a1139 1
	} else
d1141 2
a1142 1
# ifdef	__bsdi__
d1156 1
a1156 1
		if (!(fin->fin_fr->fr_flags & FR_FASTROUTE)) {
d1186 4
a1189 2
		(void) fr_checkstate(ip, fin);
		(void) ip_natout(ip, fin);
d1313 9
a1321 3
	if (error == EMSGSIZE)
		(void) send_icmp_err(ip, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG,
				     ifp, ip->ip_dst);
@


1.34.2.1
log
@Pull in patch from current:
Errata:
A misuse of ipf(8) keep-state rules can result in firewall rules being bypassed.
Fix (kjell):
Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.35 2000/05/24 21:59:11 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.21 2000/05/22 06:57:47 darrenr Exp $";
d147 1
a147 1
static	int	send_ip __P((ip_t *, fr_info_t *, struct mbuf *));
d917 2
a918 1
int send_reset(oip, fin)
a919 1
fr_info_t *fin;
d922 1
d945 1
a945 1
	m->m_pkthdr.len = sizeof(*tcp2) + sizeof(*ip);
d948 1
d950 2
a951 2
	bzero((char *)ip, sizeof(*tcp2) + sizeof(*ip));
	tcp2 = (struct tcphdr *)(ip + 1);
d962 2
a963 2
	ip->ip_p = IPPROTO_TCP;
	ip->ip_len = htons(sizeof(struct tcphdr));
a965 1
	ip->ip_id = oip->ip_id;
d967 1
d970 1
a970 1
	return send_ip(ip, fin, m);
d974 1
a974 2
static int send_ip(ip, fin, m)
fr_info_t *fin;
d978 5
a982 2
	ip->ip_v = IPVERSION;
	ip->ip_hl = (sizeof(*ip) >> 2);
d992 24
a1015 1
	return ipfr_fastroute(m, fin, NULL);
d1019 1
a1019 1
int send_icmp_err(oip, type, fin, dst)
d1021 2
a1022 2
int type;
fr_info_t *fin;
a1027 1
	int code;
a1028 13
	if ((oip->ip_p == IPPROTO_ICMP) && !(fin->fin_fi.fi_fl & FI_SHORT))
		switch (ntohs(fin->fin_data[0]) >> 8)
		{
		case ICMP_ECHO :
		case ICMP_TSTAMP :
		case ICMP_IREQ :
		case ICMP_MASKREQ :
			break;
		default :
			return 0;
		}

	code = fin->fin_icode;
d1047 2
d1056 1
a1056 1
		if (fr_ifpaddr(fin->fin_ifp, &dst) == -1)
d1080 1
a1080 1
	return send_ip(nip, fin, m);
d1122 1
a1122 2
	int len, off, error = 0, hlen, code;
	struct ifnet *ifp, *sifp;
d1125 1
d1139 1
a1139 7
	if (fdp)
		ifp = fdp->fd_ifp;
	else {
		ifp = fin->fin_ifp;
		dst->sin_addr = ip->ip_dst;
	}

d1148 1
a1148 1
	} else if (fdp)
d1150 1
a1150 2

# if BSD >= 199306
d1164 1
a1164 1
		if (!fr || !(fr->fr_flags & FR_FASTROUTE)) {
d1194 2
a1195 4
		if (!fr || !(fr->fr_flags & FR_RETMASK)) {
			(void) fr_checkstate(ip, fin);
			(void) ip_natout(ip, fin);
		}
d1319 3
a1321 9
	if (error == EMSGSIZE) {
		sifp = fin->fin_ifp;
		fin->fin_ifp = ifp;
		code = fin->fin_icode;
		fin->fin_icode = ICMP_UNREACH_NEEDFRAG;
		(void) send_icmp_err(ip, ICMP_UNREACH, fin, ip->ip_dst);
		fin->fin_ifp = sifp;
		fin->fin_icode = code;
	}
@


1.33
log
@Update to ipf 3.3.12. Most fixes relate to hardening of
in-kernel ftp proxy. See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.32 2000/03/13 23:40:17 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.19 2000/03/07 14:41:39 darrenr Exp $";
d768 2
a769 4
		if (req != SIOCINAFR && req != SIOCINIFR)
			while ((f = *ftail))
				ftail = &f->fr_next;
		else {
a770 1
				ftail = fprev;
@


1.32
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.18 2000/02/22 11:40:06 darrenr Exp $";
d475 4
a478 3
		if (!fr_running)
			return EIO;
		error = nat_ioctl(data, cmd, mode);
d482 1
d484 4
a487 3
		if (!fr_running)
			return EIO;
		error = fr_state_ioctl(data, cmd, mode);
d491 1
@


1.31
log
@Get rid of printf message from ipf enable, as per theo's request.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.30 2000/02/16 22:34:18 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.17 2000/02/10 01:47:28 darrenr Exp $";
d230 2
a231 2
# ifdef __sgi
	int error;
d252 10
d263 1
d270 3
d319 3
d347 6
d354 1
d361 1
@


1.30
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d276 1
d285 2
@


1.29
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.16 2000/01/16 10:12:42 darrenr Exp $";
a166 3
#if defined(IPFILTER_LKM)
int	fr_running = 1;
#else
a167 1
#endif
d266 1
a290 1
	fr_running = 1;
@


1.29.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.31 2000/02/18 07:47:02 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.17 2000/02/10 01:47:28 darrenr Exp $";
d167 3
d171 1
a269 1
	fr_running = 1;
a278 1
#if !defined(__OpenBSD__)
a286 2
#endif

d294 1
@


1.29.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.4.2.18 2000/02/22 11:40:06 darrenr Exp $";
d230 2
a231 2
# if defined(__sgi) || (defined(NETBSD_PF) && (__NetBSD_Version__ >= 104200000))
	int error = 0;
a251 10
#  if __NetBSD_Version__ >= 104200000
	error = pfil_add_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
			      &inetsw[ip_protox[IPPROTO_IP]].pr_pfh);
	if (error) {
		appr_unload();
		ip_natunload();
		fr_stateunload();
		return error;
	}
#  else
a252 1
#  endif
a258 3
		appr_unload();
		ip_natunload();
		fr_stateunload();
a304 3
#if defined(NETBSD_PF) && (__NetBSD_Version__ >= 104200000)
	int error = 0;
#endif
a329 6
#  if __NetBSD_Version__ >= 104200000
	error = pfil_remove_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
			      &inetsw[ip_protox[IPPROTO_IP]].pr_pfh);
	if (error)
		return error;
#  else
a330 1
#  endif
a336 1
	appr_unload();
@


1.29.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.42 2001/03/07 05:43:17 aaron Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-2000 by Darren Reed.
d11 2
a12 2
static const char sccsid[] = "@@(#)ip_fil.c	2.41 6/5/96 (C) 1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ip_fil.c,v 2.42.2.17 2000/10/19 15:39:42 darrenr Exp $";
a21 4
#if defined(_KERNEL) && defined(__FreeBSD_version) && \
    (__FreeBSD_version >= 400000) && !defined(KLD_MODULE)
#include "opt_inet6.h"
#endif
d27 4
a30 2
#if defined(__FreeBSD__) && !defined(__FreeBSD_version)
# if !defined(_KERNEL) || defined(IPFILTER_LKM)
a100 3
#ifdef USE_INET6
# include <netinet/icmp6.h>
#endif
d131 3
d135 2
d139 2
a140 2
static	int	frzerostats __P((caddr_t));
#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD_version >= 300003)
d147 1
a147 1
static	int	send_ip __P((ip_t *, fr_info_t *, struct mbuf *));
a171 11
#if defined(__NetBSD__) && (__NetBSD_Version__ >= 104230000)
# include <sys/callout.h>
struct callout ipfr_slowtimer_ch;
#endif
#if defined(__OpenBSD__)
# include <sys/timeout.h>
struct timeout ipfr_slowtimer_ch;
#endif
#if defined(__sgi) && defined(_KERNEL)
toid_t ipfr_slowtimer_ch;
#endif
d244 1
a244 2
	if (nat_init() == -1) {
		SPL_X(s);
d246 1
a246 3
	}
	if (fr_stateinit() == -1) {
		SPL_X(s);
d248 1
a248 3
	}
	if (appr_init() == -1) {
		SPL_X(s);
a249 1
	}
a255 3
#   ifdef USE_INET6
		goto pfil_error;
#   else
a259 1
#   endif
a263 13
#  ifdef USE_INET6
	error = pfil_add_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
			      &inetsw[ip_protox[IPPROTO_IPV6]].pr_pfh);
	if (error) {
		pfil_remove_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
				 &inetsw[ip_protox[IPPROTO_IP]].pr_pfh);
pfil_error:
		appr_unload();
		ip_natunload();
		fr_stateunload();
		return error;
	}
#  endif
d291 2
a292 2
	printf("%s initialized.  Default = %s all, Logging = %s\n",
		ipfilter_version, defpass,
d298 1
d301 2
a302 10
#ifdef  _KERNEL
# if defined(__NetBSD__) && (__NetBSD_Version__ >= 104230000)
	callout_init(&ipfr_slowtimer_ch);
	callout_reset(&ipfr_slowtimer_ch, hz / 2, ipfr_slowtimer, NULL);
# else
#  if defined(__OpenBSD__)
	timeout_set(&ipfr_slowtimer_ch, ipfr_slowtimer, NULL);
	timeout_add(&ipfr_slowtimer_ch, hz / 2);
#  else
#   if (__FreeBSD_version >= 300000) || defined(__sgi)
d304 1
a304 1
#   else
a305 2
#   endif
#  endif
d323 3
a325 3
#ifdef  _KERNEL
# if defined(__NetBSD__) && (__NetBSD_Version__ >= 104230000)
	callout_stop(&ipfr_slowtimer_ch);
d327 2
a328 2
#  if defined(__OpenBSD__)
	timeout_del(&ipfr_slowtimer_ch);
a329 6
#   if (__FreeBSD_version >= 300000)
	untimeout(ipfr_slowtimer, NULL, ipfr_slowtimer_ch);
#   else
#    ifdef __sgi
	untimeout(ipfr_slowtimer_ch);
#    else
d331 2
a332 4
#    endif
#   endif /* FreeBSD */
#  endif /* OpenBSD */
# endif /* NetBSD */
a341 2
	printf("%s unloaded\n", ipfilter_version);

d349 1
a349 1
				 &inetsw[ip_protox[IPPROTO_IP]].pr_pfh);
a354 6
#  ifdef USE_INET6
	error = pfil_remove_hook((void *)fr_check, PFIL_IN|PFIL_OUT,
				 &inetsw[ip_protox[IPPROTO_IPV6]].pr_pfh);
	if (error)
		return error;
#  endif
d373 1
a373 1
static	int	frzerostats(data)
a376 6
	int error;

	fr_getstat(&fio);
	error = IWCOPYPTR((caddr_t)&fio, data, sizeof(fio));
	if (error)
		return EFAULT;
d378 14
a392 2

	return 0;
d407 2
a408 3
# if (defined(_KERNEL) && ((_BSDI_VERSION >= 199510) || (BSD >= 199506) || \
       (NetBSD >= 199511) || (__FreeBSD_version >= 220000) || \
       defined(__OpenBSD__)))
d411 1
a411 1
# else
d413 1
a413 1
# endif
d415 2
a416 2
# if defined(__NetBSD__) || defined(__OpenBSD__) || \
	(_BSDI_VERSION >= 199701) || (__FreeBSD_version >= 300000)
d418 1
a418 1
# else
d420 1
a420 1
# endif
d438 31
a468 1
#else
d475 3
a477 4
		if (fr_running)
			error = nat_ioctl(data, cmd, mode);
		else
			error = EIO;
a481 8
		if (fr_running)
			error = fr_state_ioctl(data, cmd, mode);
		else
			error = EIO;
		SPL_X(s);
		return error;
	}
	if (unit == IPL_LOGAUTH) {
d484 1
a484 1
		error = fr_auth_ioctl(data, cmd, NULL, NULL);
a487 1

d491 2
a492 2
		error = IWCOPY((caddr_t)&iplused[IPL_LOGIPF], (caddr_t)data,
			       sizeof(iplused[IPL_LOGIPF]));
d503 1
a503 3
			error = IRCOPY(data, (caddr_t)&enable, sizeof(enable));
			if (error)
				break;
d516 1
a516 2
			error = IRCOPY(data, (caddr_t)&fr_flags,
				       sizeof(fr_flags));
d519 1
a519 1
		error = IWCOPY((caddr_t)&fr_flags, data, sizeof(fr_flags));
d549 1
a549 1
		friostat_t	fio;
d551 30
a580 4
		fr_getstat(&fio);
		error = IWCOPYPTR((caddr_t)&fio, data, sizeof(fio));
		if (error)
			return EFAULT;
d587 1
a587 1
			error = frzerostats(data);
d593 3
a595 6
			error = IRCOPY(data, (caddr_t)&tmp, sizeof(tmp));
			if (!error) {
				tmp = frflush(unit, tmp);
				error = IWCOPY((caddr_t)&tmp, data,
					       sizeof(tmp));
			}
a597 10
	case SIOCSTLCK :
		error = IRCOPY(data, (caddr_t)&tmp, sizeof(tmp));
		if (!error) {
			fr_state_lock = tmp;
			fr_nat_lock = tmp;
			fr_frag_lock = tmp;
			fr_auth_lock = tmp;
		} else
			error = EFAULT;
		break;
d607 1
a607 4
		error = IWCOPYPTR((caddr_t)ipfr_fragstats(), data,
				  sizeof(ipfrstat_t));
		if (error)
			return EFAULT;
d615 3
a654 14
#ifdef	USE_INET6
	for (f = ipacct6[0][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
	for (f = ipacct6[1][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
	for (f = ipfilter6[0][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
	for (f = ipfilter6[1][fr_active]; (f != NULL); f = f->fr_next)
		if (f->fr_ifa == ifp)
			f->fr_ifa = (void *)-1;
#endif
d662 1
a662 1
#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD_version >= 300003)
a674 1
	u_int   *p, *pp;
d679 1
a679 3
	error = IRCOPYPTR(data, (caddr_t)fp, sizeof(*fp));
	if (error)
		return EFAULT;
a680 4
#if (BSD >= 199306) && defined(_KERNEL)
	if ((securelevel > 0) && (fp->fr_func != NULL))
		return EPERM;
#endif
d697 1
a697 1
	else if ((fp->fr_flags & FR_ACCOUNT) && (fp->fr_v == 4))
d699 1
a699 1
	else if ((fp->fr_flags & (FR_OUTQUE|FR_INQUE)) && (fp->fr_v == 4))
a700 6
#ifdef	USE_INET6
	else if ((fp->fr_flags & FR_ACCOUNT) && (fp->fr_v == 6))
		ftail = fprev = &ipacct6[in][set];
	else if ((fp->fr_flags & (FR_OUTQUE|FR_INQUE)) && (fp->fr_v == 6))
		ftail = fprev = &ipfilter6[in][set];
#endif
d713 1
a713 1
		fp->fr_ifa = GETUNIT(fp->fr_ifname, fp->fr_v);
d719 1
a719 1
		fp->fr_oifa = GETUNIT(fp->fr_oifname, fp->fr_v);
d728 1
a728 1
		fdp->fd_ifp = GETUNIT(fdp->fd_ifname, fp->fr_v);
d737 1
a737 1
		fdp->fd_ifp = GETUNIT(fdp->fd_ifname, fp->fr_v);
a745 4
	for (fp->fr_cksum = 0, p = (u_int *)&fp->fr_ip, pp = &fp->fr_cksum;
	     p < pp; p++)
		fp->fr_cksum += *p;

d747 2
a748 2
		if ((fp->fr_cksum == f->fr_cksum) &&
		    !bcmp((char *)&f->fr_ip, (char *)&fp->fr_ip, FR_CMPSIZ))
d757 1
a757 3
		error = IWCOPYPTR((caddr_t)f, data, sizeof(*f));
		if (error)
			return EFAULT;
d777 1
a777 1
	if (req == SIOCRMAFR || req == SIOCRMIFR) {
d781 1
a781 6
			/*
			 * Only return EBUSY if there is a group list, else
			 * it's probably just state information referencing
			 * the rule.
			 */
			if ((f->fr_ref > 1) && f->fr_grp)
d792 1
a792 3
			f->fr_next = NULL;
			if (f->fr_ref == 0)
				KFREE(f);
d916 2
a917 1
int send_reset(oip, fin)
a918 1
fr_info_t *fin;
d921 1
a921 1
	int tlen = 0, hlen;
d923 1
a923 3
#ifdef	USE_INET6
	ip6_t *ip6, *oip6 = (ip6_t *)oip;
#endif
d939 3
a941 10
	tlen = oip->ip_len - fin->fin_hlen - (tcp->th_off << 2) +
			((tcp->th_flags & TH_SYN) ? 1 : 0) +
			((tcp->th_flags & TH_FIN) ? 1 : 0);

#ifdef	USE_INET6
	hlen = (fin->fin_v == 6) ? sizeof(ip6_t) : sizeof(ip_t);
#else
	hlen = sizeof(ip_t);
#endif
	m->m_len = sizeof(*tcp2) + hlen;
d947 1
d949 2
a950 5
# ifdef	USE_INET6
	ip6 = (ip6_t *)ip;
# endif
	bzero((char *)ip, sizeof(*tcp2) + hlen);
	tcp2 = (struct tcphdr *)((char *)ip + hlen);
d952 3
d956 3
a958 10
	tcp2->th_dport = tcp->th_sport;
	if (tcp->th_flags & TH_ACK) {
		tcp2->th_seq = tcp->th_ack;
		tcp2->th_flags = TH_RST;
	} else {
		tcp2->th_ack = ntohl(tcp->th_seq);
		tcp2->th_ack += tlen;
		tcp2->th_ack = htonl(tcp2->th_ack);
		tcp2->th_flags = TH_RST|TH_ACK;
	}
d960 10
a969 18
# ifdef	USE_INET6
	if (fin->fin_v == 6) {
		ip6->ip6_plen = htons(sizeof(struct tcphdr));
		ip6->ip6_nxt = IPPROTO_TCP;
		ip6->ip6_src = oip6->ip6_dst;
		ip6->ip6_dst = oip6->ip6_src;
		tcp2->th_sum = in6_cksum(m, IPPROTO_TCP,
					 sizeof(*ip6), sizeof(*tcp2));
		return send_ip(oip, fin, m);
	}
# endif
	ip->ip_p = IPPROTO_TCP;
	ip->ip_len = htons(sizeof(struct tcphdr));
	ip->ip_src.s_addr = oip->ip_dst.s_addr;
	ip->ip_dst.s_addr = oip->ip_src.s_addr;
	tcp2->th_sum = in_cksum(m, hlen + sizeof(*tcp2));
	ip->ip_len = hlen + sizeof(*tcp2);
	return send_ip(oip, fin, m);
d973 1
a973 3
static int send_ip(oip, fin, m)
ip_t *oip;
fr_info_t *fin;
d975 1
d977 4
a980 3
	ip_t *ip;

	ip = mtod(m, ip_t *);
a981 7
	ip->ip_v = fin->fin_v;
	if (ip->ip_v == 4) {
		ip->ip_hl = (sizeof(*oip) >> 2);
		ip->ip_v = IPVERSION;
		ip->ip_tos = oip->ip_tos;
		ip->ip_id = oip->ip_id;
		ip->ip_off = 0;
d983 1
a983 1
		ip->ip_ttl = tcp_ttl;
d985 1
a985 1
		ip->ip_ttl = ip_defttl;
a986 5
		ip->ip_sum = 0;
	}
# ifdef	USE_INET6
	else if (ip->ip_v == 6) {
		ip6_t *ip6 = (ip6_t *)ip;
d988 6
a993 1
		ip6->ip6_hlim = 127;
d995 5
a999 1
		return ip6_output(m, NULL, NULL, 0, NULL, NULL);
d1001 13
a1014 4
# ifdef	IPSEC
	m->m_pkthdr.rcvif = NULL;
# endif
	return ipfr_fastroute(m, fin, NULL);
d1018 1
a1018 1
int send_icmp_err(oip, type, fin, dst)
d1020 3
a1022 3
int type;
fr_info_t *fin;
int dst;
a1023 2
	int err, hlen = 0, xtra = 0, iclen, ohlen = 0, avail, code;
	struct in_addr dst4;
d1026 1
a1026 32
	void *ifp;
#ifdef USE_INET6
	ip6_t *ip6, *oip6 = (ip6_t *)oip;
	struct in6_addr dst6;
#endif
	ip_t *ip;

	if ((type < 0) || (type > ICMP_MAXTYPE))
		return -1;

	code = fin->fin_icode;
#ifdef USE_INET6
	if ((code < 0) || (code > sizeof(icmptoicmp6unreach)/sizeof(int)))
		return -1;
#endif

	avail = 0;
	m = NULL;
	ifp = fin->fin_ifp;
	if (fin->fin_v == 4) {
		if ((oip->ip_p == IPPROTO_ICMP) &&
		    !(fin->fin_fi.fi_fl & FI_SHORT))
			switch (ntohs(fin->fin_data[0]) >> 8)
			{
			case ICMP_ECHO :
			case ICMP_TSTAMP :
			case ICMP_IREQ :
			case ICMP_MASKREQ :
				break;
			default :
				return 0;
			}
d1029 1
a1029 2
		avail = MLEN;
		m = m_get(M_DONTWAIT, MT_HEADER);
d1031 1
a1031 2
		avail = MHLEN;
		m = m_gethdr(M_DONTWAIT, MT_HEADER);
d1033 3
a1035 48
		if (m == NULL)
			return ENOBUFS;

		if (dst == 0) {
			if (fr_ifpaddr(4, ifp, &dst4) == -1)
				return -1;
		} else
			dst4.s_addr = oip->ip_dst.s_addr;

		hlen = sizeof(ip_t);
		ohlen = oip->ip_hl << 2;
		xtra = 8;
	}

#ifdef	USE_INET6
	else if (fin->fin_v == 6) {
		hlen = sizeof(ip6_t);
		ohlen = sizeof(ip6_t);
		type = icmptoicmp6types[type];
		if (type == ICMP6_DST_UNREACH)
			code = icmptoicmp6unreach[code];

		MGETHDR(m, M_DONTWAIT, MT_HEADER);
		if (!m)
			return ENOBUFS;

		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
			return ENOBUFS;
		}
# ifdef	M_TRAILINGSPACE
		m->m_len = 0;
		avail = M_TRAILINGSPACE(m);
# else
		avail = (m->m_flags & M_EXT) ? MCLBYTES : MHLEN;
# endif
		xtra = MIN(ntohs(oip6->ip6_plen) + sizeof(ip6_t),
			   avail - hlen - sizeof(*icmp) - max_linkhdr);
		if (dst == 0) {
			if (fr_ifpaddr(6, ifp, (struct in_addr *)&dst6) == -1)
				return -1;
		} else
			dst6 = oip6->ip6_dst;
	}
#endif

	iclen = hlen + sizeof(*icmp);
a1036 1
	avail -= (max_linkhdr + iclen);
d1038 1
d1040 20
a1059 14
	if (xtra > avail)
		xtra = avail;
	iclen += xtra;
	m->m_pkthdr.len = iclen;
#else
	avail -= (m->m_off + iclen);
	if (xtra > avail)
		xtra = avail;
	iclen += xtra;
#endif
	m->m_len = iclen;
	ip = mtod(m, ip_t *);
	icmp = (struct icmp *)((char *)ip + hlen);
	bzero((char *)ip, iclen);
d1062 1
a1062 1
	icmp->icmp_code = fin->fin_icode;
d1064 4
a1067 27
#ifdef	icmp_nextmtu
	if (type == ICMP_UNREACH &&
	    fin->fin_icode == ICMP_UNREACH_NEEDFRAG && ifp)
		icmp->icmp_nextmtu = htons(((struct ifnet *) ifp)->if_mtu);
#endif

	if (avail) {
		bcopy((char *)oip, (char *)&icmp->icmp_ip, MIN(ohlen, avail));
		avail -= MIN(ohlen, avail);
	}

#ifdef	USE_INET6
	ip6 = (ip6_t *)ip;
	if (fin->fin_v == 6) {
		ip6->ip6_flow = 0;
		ip6->ip6_plen = htons(iclen - hlen);
		ip6->ip6_nxt = IPPROTO_ICMPV6;
		ip6->ip6_hlim = 0;
		ip6->ip6_src = dst6;
		ip6->ip6_dst = oip6->ip6_src;
		if (avail)
			bcopy((char *)oip + ohlen,
			      (char *)&icmp->icmp_ip + ohlen, avail);
		icmp->icmp_cksum = in6_cksum(m, IPPROTO_ICMPV6,
					     sizeof(*ip6), iclen - hlen);
	} else
#endif
d1069 2
a1070 2
		ip->ip_src.s_addr = dst4.s_addr;
		ip->ip_dst.s_addr = oip->ip_src.s_addr;
d1072 4
a1075 9
		if (avail > 8)
			avail = 8;
		if (avail)
			bcopy((char *)oip + ohlen,
			      (char *)&icmp->icmp_ip + ohlen, avail);
		icmp->icmp_cksum = ipf_cksum((u_short *)icmp,
					     sizeof(*icmp) + 8);
		ip->ip_len = iclen;
		ip->ip_p = IPPROTO_ICMP;
d1077 3
a1079 2
	err = send_ip(oip, fin, m);
	return err;
d1121 1
a1121 2
	int len, off, error = 0, hlen, code;
	struct ifnet *ifp, *sifp;
d1124 1
a1128 10

#ifdef	USE_INET6
	if (ip->ip_v == 6) {
		/*
		 * currently "to <if>" and "to <if>:ip#" are not supported
		 * for IPv6
		 */
		return ip6_output(m0, NULL, NULL, 0, NULL, NULL);
	}
#endif
d1138 1
a1138 7
	if (fdp)
		ifp = fdp->fd_ifp;
	else {
		ifp = fin->fin_ifp;
		dst->sin_addr = ip->ip_dst;
	}

d1147 1
a1147 1
	} else if (fdp)
d1149 1
a1149 2

# if BSD >= 199306
d1163 1
a1163 1
		if (!fr || !(fr->fr_flags & FR_FASTROUTE)) {
d1190 1
a1190 1
			ATOMIC_INCL(frstats[1].fr_acct);
d1193 1
a1193 2
		if (!fr || !(fr->fr_flags & FR_RETMASK))
			(void) fr_checkstate(ip, fin);
a1200 10
# if	BSD >= 199306
		int i = 0;

#  ifdef	MCLISREFERENCED
		if ((m->m_flags & M_EXT) && MCLISREFERENCED(m))
#  else
		if (m->m_flags & M_EXT)
#  endif
			i = 1;
# endif
a1208 5
		if (i) {
			ip->ip_id = ntohs(ip->ip_id);
			ip->ip_len = ntohs(ip->ip_len);
			ip->ip_off = ntohs(ip->ip_off);
		}
d1318 3
a1320 9
	if (error == EMSGSIZE) {
		sifp = fin->fin_ifp;
		code = fin->fin_icode;
		fin->fin_icode = ICMP_UNREACH_NEEDFRAG;
		fin->fin_ifp = ifp;
		(void) send_icmp_err(ip, ICMP_UNREACH, fin, 1);
		fin->fin_ifp = sifp;
		fin->fin_icode = code;
	}
a1323 28


int fr_verifysrc(ipa, ifp)
struct in_addr ipa;
void *ifp;
{
	struct sockaddr_in *dst;
	struct route iproute;

	bzero((char *)&iproute, sizeof(iproute));
	dst = (struct sockaddr_in *)&iproute.ro_dst;
	dst->sin_family = AF_INET;
	dst->sin_addr = ipa;
# if    (BSD >= 199306) && !defined(__NetBSD__) && !defined(__bsdi__) && \
        !defined(__OpenBSD__)
#  ifdef        RTF_CLONING
	rtalloc_ign(&iproute, RTF_CLONING);
#  else
	rtalloc_ign(&iproute, RTF_PRCLONING);
#  endif
# else
	rtalloc(&iproute);
# endif
	if (iproute.ro_rt == NULL)
		return 0;
	return (ifp == iproute.ro_rt->rt_ifp);
}

d1381 1
a1381 1
struct ifnet *get_unit(name, v)
a1382 1
int v;
a1402 2
		if (!ifneta)
			return NULL;
a1404 4
		if (!ifneta[0]) {
			free(ifneta);
			return NULL;
		}
a1409 4
		if (!ifneta) {
			nifs = 0;
			return NULL;
		}
a1411 4
		if (!ifneta[nifs - 1]) {
			nifs--;
			return NULL;
		}
@


1.29.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.29.2.3 2001/05/14 22:40:09 niklas Exp $	*/
@


1.28
log
@Update to Darren Reed's IPFilter 3.3.5
Fixes: realaudio proxy issues, "log level" printing, and
source address for icmp replies (was reversed).

Thoughtfully submitted by techs@@obfuscation.org
@
text
@d1 2
a2 1
/*    $OpenBSD: ip_fil.c,v 1.27 1999/12/15 05:20:21 kjell Exp $    */
d12 1
a12 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.27 1999/12/15 05:20:21 kjell Exp $";
a130 1
int	ipl_inited = 0;
a228 9
#if defined( __OpenBSD__)
/*
 * Since iplattach() is called by main() at boot time, we put in a 
 * fake stub so that none of the machinery is initialized till explicitly
 * enabled via ipf -E. Therefore we rename the real iplattach() to 
 * ipl_enable(). See also skeleton iplinit() later in this file. 
 */
void iplattach __P((int));
void iplattach(int dummy) {};
a229 2
int ipl_enable()
# else
a230 1
# endif /* OpenBSD */
d239 1
a239 1
	if (ipl_inited || (fr_checkp == fr_check)) {
a266 1
	ipl_inited = 1;
d294 1
a302 3
# if defined(__OpenBSD__)
int ipl_disable()
# else
a303 1
# endif
d319 1
a319 1
	if (!ipl_inited)
d328 1
a328 1
	ipl_inited = 0;
d451 2
d458 2
d480 1
a480 4
			if (enable) {
# if defined(__OpenBSD__)
				error = ipl_enable();
# else
d482 1
a482 7
# endif
				if (error == 0)
					fr_running = 1;
			} else {
# if defined(__OpenBSD__)
				error = ipl_disable();
# else
a483 4
# endif
				if (error == 0)
					fr_running = 0;
			}
d740 1
a740 1
		if (req != SIOCINAFR || req != SIOCINIFR)
d744 2
a745 1
			if (fp->fr_hits)
d748 1
d984 2
a985 2
#   if defined(__OpenBSD__)
       return ip_output(m, (struct mbuf *)0, 0, 0, 0, NULL);
a1070 4
#  if defined(__OpenBSD__)
	/* must explicitly enable with 'ipf -E'
	 * which invokes ipl_enable(); */
#  else
a1072 1
#  endif
@


1.27
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.26 1999/12/13 10:41:56 itojun Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.26 1999/12/13 10:41:56 itojun Exp $";
d765 6
a770 4
		if (req == SIOCINAFR || req == SIOCINIFR) {
			ftail = fprev;
			if (fp->fr_hits) {
				while (--fp->fr_hits && (f = *ftail)) {
d772 1
a772 2
				}
			}
a773 1
		f = NULL;
d798 1
a798 1
				return fr_auth_ioctl(data, req, f, ftail);
d1021 1
a1021 1
struct in_addr	dst;
a1055 1
		dst.s_addr = htonl(dst.s_addr);
d1322 3
a1324 13
# if BSD >= 199306
	if (error == EMSGSIZE) {
		/* Send ICMP error here */
		struct mbuf *mcopy;

		mcopy = m_copy(m, 0, imin((int)ip->ip_len, 68));
		if (mcopy) {
			mcopy->m_pkthdr.rcvif = (struct ifnet *)ifp;
			icmp_error(mcopy, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG,
				   ip->ip_dst.s_addr, ifp);
		}
	}
# endif
@


1.26
log
@remove extra checks for #define INET (merged mistakingly from kame).
this is harmful against some of lkm compilation.
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.25 1999/12/08 06:50:19 itojun Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.25 1999/12/08 06:50:19 itojun Exp $";
d21 5
d38 1
a41 1
#include <sys/param.h>
d55 1
a55 1
# if (NetBSD > 199609) || (OpenBSD > 199603)
d73 3
d86 1
a86 1
#include <netinet/in_var.h>
d96 1
a98 1
#if defined(__OpenBSD__)
a99 3
#else
#include <netinet/ip_compat.h>
#endif
d106 3
d110 1
a110 1
#define	MIN(a,b)	(((a)<(b))?(a):(b))
d112 2
a113 1
#if	!SOLARIS && defined(_KERNEL)
a124 5
# if	(BSD < 199306) && !defined(__sgi)
static	int	(*fr_saveslowtimo) __P((void));
# else
static	void	(*fr_saveslowtimo) __P((void));
# endif
d131 1
a131 1
#if defined(__OpenBSD__)
d133 1
a133 1
#else
d135 2
a136 1
#endif
a138 1
static	void	fixskip __P((frentry_t **, frentry_t *, int));
a139 1
static	void	frsync __P((void));
d147 1
d150 1
d167 9
d224 2
a225 1
	iplattach();
d257 10
a280 1
	bzero((char *)nat_table, sizeof(nat_table));
a282 2
	fr_saveslowtimo = inetsw[0].pr_slowtimo;
	inetsw[0].pr_slowtimo = ipfr_slowtimer;
a283 3
# ifdef	IPFILTER_LOG
	ipflog_init();
# endif
d299 8
d323 11
d343 1
a343 2
	inetsw[0].pr_slowtimo = fr_saveslowtimo;
	frflush(IPL_LOGIPF, &i);
d368 1
a368 1
	struct	friostat	fio;
d407 2
a408 1
#if defined(__NetBSD__) || defined(__OpenBSD__) || (_BSDI_VERSION >= 199701)
d422 4
d432 1
d460 3
a462 1
#endif /* _KERNEL */
a475 1

d492 1
a492 1
			if (enable)
d495 7
a501 1
			else
a503 2
				error = iplattach();
			else
d505 4
a508 1
# endif /* OpenBSD */
d566 15
d595 1
a595 1
			frflush(unit, &tmp);
d638 2
a639 18
static void frsync()
{
#ifdef _KERNEL
	struct ifnet *ifp;

# if defined(__OpenBSD__) || (NetBSD >= 199511)
	for (ifp = ifnet.tqh_first; ifp; ifp = ifp->if_list.tqe_next)
# else
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
# endif
		ip_natsync(ifp);
#endif
}


static void fixskip(listp, rp, addremove)
frentry_t **listp, *rp;
int addremove;
d641 1
a641 8
	frentry_t *fp;
	int rules = 0, rn = 0;

	for (fp = *listp; fp && (fp != rp); fp = fp->fr_next, rules++)
		;

	if (!fp)
		return;
d643 15
a657 3
	for (fp = *listp; fp && (fp != rp); fp = fp->fr_next, rn++)
		if (fp->fr_skip && (rn + fp->fr_skip >= rules))
			fp->fr_skip += addremove;
d676 2
a677 1
	int error = 0, in, group;
d681 1
d687 2
a688 2
	if (fp->fr_grhead &&
	    fr_findgroup(fp->fr_grhead, fp->fr_flags, unit, set, NULL))
d690 2
a691 2
	if (fp->fr_group &&
	    !fr_findgroup(fp->fr_group, fp->fr_flags, unit, set, NULL))
d718 7
d765 8
a772 7
		ftail = fprev;
		if (req != SIOCINAFR && req != SIOCINIFR)
			while ((f = *ftail))
				ftail = &f->fr_next;
		else if (fp->fr_hits)
			while (--fp->fr_hits && (f = *ftail))
				ftail = &f->fr_next;
d787 2
a788 2
				fr_delgroup(f->fr_grhead, fp->fr_flags, unit,
					    set);
d799 1
a799 1
			KMALLOC(f, frentry_t *, sizeof(*f));
d825 2
a826 2
#ifdef __sgi
# ifdef _KERNEL
d828 3
a831 3
int IPL_EXTERN(open)(dev_t dev, int flags)
# endif
#else
d833 1
a833 1
# if ((_BSDI_VERSION >= 199510) || (BSD >= 199506) || (NetBSD >= 199511) || \
d838 1
a838 1
# else
d840 1
a840 1
# endif
d843 1
a843 1
#endif /* __sgi */
d845 1
a845 1
#if defined(__sgi) && defined(_KERNEL)
d847 1
a847 1
#else
d849 1
a849 1
#endif
d851 1
a851 1
	if (2 < min)
d859 1
a859 1
#ifdef __sgi
d863 1
a863 1
# if ((_BSDI_VERSION >= 199510) || (BSD >= 199506) || (NetBSD >= 199511) || \
d868 1
a868 1
# else
d870 1
a870 1
# endif
d873 1
a873 1
#endif /* __sgi */
d877 1
a877 1
	if (2 < min)
d890 1
a890 1
#ifdef __sgi
d892 1
a892 1
#else
d901 1
a901 1
#endif /* __sgi */
d903 1
a903 1
#  ifdef IPFILTER_LOG
d905 1
a905 1
#  else
d907 1
a907 1
#  endif
d915 3
a917 2
int send_reset(ti)
struct tcpiphdr *ti;
d919 1
a920 1
	struct tcphdr *tcp;
d922 1
a922 1
	int tlen = 0, err;
a923 3
# if defined(__FreeBSD_version) && (__FreeBSD_version >= 220000)
	struct route ro;
# endif
d925 2
a926 1
	if (ti->ti_flags & TH_RST)
a931 1
	m->m_data += max_linkhdr;
d934 2
d938 1
a938 1
	if (ti->ti_flags & TH_SYN)
d940 1
a940 1
	m->m_len = sizeof (struct tcpiphdr);
d942 2
a943 1
	m->m_pkthdr.len = sizeof (struct tcpiphdr);
d949 1
a949 1
	tcp = (struct tcphdr *)((char *)ip + sizeof(struct ip));
d951 10
a960 8
	ip->ip_src.s_addr = ti->ti_dst.s_addr;
	ip->ip_dst.s_addr = ti->ti_src.s_addr;
	tcp->th_dport = ti->ti_sport;
	tcp->th_sport = ti->ti_dport;
	tcp->th_ack = htonl(ntohl(ti->ti_seq) + tlen);
	tcp->th_off = sizeof(struct tcphdr) >> 2;
	tcp->th_flags = TH_RST|TH_ACK;
	tp->ti_pr = ((struct ip *)ti)->ip_p;
d962 18
a979 1
	tcp->th_sum = in_cksum(m, sizeof(struct tcpiphdr));
a980 3
	ip->ip_tos = ((struct ip *)ti)->ip_tos;
	ip->ip_p = ((struct ip *)ti)->ip_p;
	ip->ip_len = sizeof (struct tcpiphdr);
d987 3
d991 3
d998 2
d1004 2
a1005 2
#  ifdef __OpenBSD__
	err = ip_output(m, (struct mbuf *)0, 0, 0, 0, 0);
d1007 5
a1011 1
	err = ip_output(m, (struct mbuf *)0, 0, 0, 0);
d1014 66
a1079 1
	return err;
d1099 2
a1100 1
	(void) iplattach();
d1104 1
a1104 1
# endif /* !LKM, !sgi, FreeBSD < 3 */
d1118 1
a1118 1
void ipfr_fastroute(m0, fin, fdp)
d1126 2
a1127 3
	struct ifnet *ifp = fdp->fd_ifp;
	int len, off, error = 0;
	int hlen = fin->fin_hlen;
d1129 2
a1130 1
	struct sockaddr_in *dst;
d1132 1
d1141 13
a1153 1
	dst->sin_addr = fdp->fd_ip.s_addr ? fdp->fd_ip : ip->ip_dst;
d1159 1
a1159 1
# ifdef	RTF_CLONING
d1190 1
d1192 1
d1194 1
a1194 1
		    (FR_SCANLIST(FR_NOMATCH, ip, fin, m) & FR_ACCOUNT)) {
d1198 3
a1200 3
		(void) ip_natout(ip, hlen, fin);
	}
	if (fin->fin_out)
d1244 3
d1248 1
d1278 4
d1321 1
a1321 1
	return;
d1323 13
d1342 1
a1342 1
#ifdef __sgi
d1345 1
a1345 1
#else
d1348 1
a1348 1
#endif
d1355 1
a1355 1
#ifdef __sgi
d1358 1
a1358 1
#else
d1361 1
a1361 1
#endif
a1362 2
# if !(defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
a1363 1
#  endif
d1370 1
a1371 1
	char fname[32];
d1374 1
a1374 1
    (defined(OpenBSD) && (OpenBSD >= 199603))
a1453 1

d1466 5
a1470 2
#endif
		if ((fd = open(fname, O_WRONLY|O_CREAT|O_EXCL, 0600)) != -1)
d1478 4
a1481 1
		if ((fd = open(fname, O_WRONLY|O_CREAT|O_EXCL, 0600)) != -1)
d1488 1
a1488 1
void ipfr_fastroute(ip, fin, fdp)
d1496 1
a1496 1
		return;	/* no routing table out here */
d1506 1
d1532 6
@


1.25
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.24 1999/06/07 22:00:32 deraadt Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.24 1999/06/07 22:00:32 deraadt Exp $";
a75 5
#ifdef _KERNEL
#ifndef INET
#error ipfilter assumes options INET
#endif
#endif
@


1.24
log
@I do not believe this
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.23 1999/04/22 16:12:40 niklas Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.23 1999/04/22 16:12:40 niklas Exp $";
d76 5
@


1.23
log
@Heh, this was definitely not tested.  cpp sytax errors.
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.22 1999/04/20 22:41:34 deraadt Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.22 1999/04/20 22:41:34 deraadt Exp $";
a1030 1
# ifndef sparc
a1033 1
# endif
a1098 1
# ifndef sparc
a1099 1
# endif
@


1.22
log
@use open() with O_EXCL.. but also move to /var/run to avoid the 2nd-level /tmp race which darren obviously does not think important
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.21 1999/04/16 13:44:25 deraadt Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.21 1999/04/16 13:44:25 deraadt Exp $";
d1184 1
a1184 1
# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) ||
d1270 2
a1271 2
# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606))
	if (defined(OpenBSD) && (OpenBSD >= 199603))
@


1.21
log
@fix ipf return-rst panic bug; beck
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.20 1999/02/05 05:58:50 deraadt Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.20 1999/02/05 05:58:50 deraadt Exp $";
d1184 5
a1188 2
# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
d1190 1
a1190 3
	if ((fp = fopen(fname, "a"))) {
		fclose(fp);
	}
d1193 6
a1202 1
# endif
d1265 1
a1265 1
	FILE *fp;
d1268 4
a1271 2
# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
d1274 3
d1278 3
a1280 2
		if ((fp = fopen(fname, "w")))
			fclose(fp);
d1287 2
a1288 2
		if ((fp = fopen(fname, "w")))
			fclose(fp);
@


1.20
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.19 1998/09/15 09:51:17 pattonme Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.19 1998/09/15 09:51:17 pattonme Exp $";
d914 3
a916 1
/* XXX if openbsd, add ", NULL" to end of ip_output?? */
d918 1
@


1.19
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.18 1998/05/18 21:10:46 provos Exp $    */
d3 1
a3 1
 * Copyright (C) 1993-1997 by Darren Reed.
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id$";
d144 3
d1012 1
a1012 1
	 * NAT'd.
d1014 8
a1021 1
	(void) ip_natout(ip, hlen, fin);
d1137 1
a1137 1
	if (ro->ro_rt) {
a1138 1
	}
@


1.18
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.17 1998/03/04 23:20:41 dgregor Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.17 1998/03/04 23:20:41 dgregor Exp $";
d90 11
a100 7
#include "ip_fil_compat.h"
#include "ip_fil.h"
#include "ip_proxy.h"
#include "ip_nat.h"
#include "ip_frag.h"
#include "ip_state.h"
#include "ip_auth.h"
d127 1
a127 1
#ifdef __OpenBSD__
d176 1
a176 6
#ifdef __OpenBSD__
/* called by main() at boot time */
void  iplattach __P((int));
#endif

#if defined(__NetBSD__) || defined(__OpenBSD__)
d211 1
a211 1

d213 4
a216 2
 * None of the machinery should be initialized until the caller explicitly
 * enables the filter with ipf -E.
d218 2
a219 5
void
iplattach(dummy)
int dummy;
{
}
d221 4
a224 2
int
ipl_enable()
a269 1
#ifndef __OpenBSD__	/* don't print this message */ 
a276 1
#endif /* __OpenBSD__ */
d285 1
d287 3
a384 3
#endif

#if defined(__OpenBSD__) && defined(_KERNEL)
d386 1
d389 1
a389 1
# ifndef	IPFILTER_LKM
d391 1
a391 1
# endif
d403 1
a403 1
# ifdef	IPFILTER_LOG
d405 1
a405 1
# endif
d410 1
a410 1
		     return EPERM;
d413 2
a414 1
#endif
d428 1
d446 1
d450 5
d911 2
a912 1
	err = ip_output(m, (struct mbuf *)0, 0, 0, 0, NULL);
d930 6
a935 1
/*	(void) ipl_enable();  must explicitly enable with ipf -E */
d938 1
a938 1
# endif /* ! __NetBSD__ */
d1003 2
a1004 1
	ro->ro_rt->rt_use++;
@


1.17
log
@don't print "IP Filter: initialized"
@
text
@d1 1
a1 1
/*    $OpenBSD: ip_fil.c,v 1.16 1998/01/26 04:10:39 dgregor Exp $    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 1.16 1998/01/26 04:10:39 dgregor Exp $";
d903 1
a903 1
	err = ip_output(m, (struct mbuf *)0, 0, 0, 0);
@


1.16
log
@IPF 3.2.3
@
text
@d1 1
a1 1
/*    $OpenBSD$    */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_fil.c,v 2.0.2.44.2.5 1997/11/24 10:02:02 darrenr Exp $";
d270 1
a270 1
#ifdef __OpenBSD__	/* don't print this message */ 
@


1.15
log
@Prevent IPF and NAT configuration changes when securelevel > 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.14 1997/06/23 19:03:48 kstailey Exp $	*/
d3 1
a3 1
 * (C)opyright 1993,1994,1995 by Darren Reed.
d9 3
a11 3
#if !defined(lint) && defined(LIBC_SCCS)
static	char	sccsid[] = "@@(#)ip_fil.c	2.41 6/5/96 (C) 1993-1995 Darren Reed";
static char    rcsid[] = "$DRId: ip_fil.c,v 2.0.1.8 1997/03/20 15:51:56 darrenr Exp $";
d14 22
a36 1
#include <sys/errno.h>
d38 21
a58 2
#include <sys/ioctl.h>
#include <sys/mbuf.h>
a60 3
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/uio.h>
d64 10
a73 1
#include <net/af.h>
d77 1
d79 1
d87 3
a89 1

d92 2
a94 1
#include "ip_nat.h"
d96 1
d100 4
a104 1
extern	fr_flags, fr_active;
d106 7
a112 4
extern	int	(*fr_checkp) __P((ip_t *, int, struct ifnet *, int,
				 struct mbuf **));
#if	BSD < 199306
extern	int	ipfr_slowtimer __P((void));
d114 4
d119 1
a119 3
#else
extern	void	ipfr_slowtimer __P((void));
static	void	(*fr_saveslowtimo) __P((void));
a121 2
static	void	frzerostats __P((caddr_t));

d123 1
d125 4
a128 1
int	send_reset __P((struct tcpiphdr *));
d130 25
a154 11
#ifdef	IPFILTER_LOG
# define LOGSIZE	8192
int	ipllog __P((u_int, ip_t *, register fr_info_t *, struct mbuf *));
char	iplbuf[LOGSIZE];
caddr_t	iplh = iplbuf, iplt = iplbuf;
static	int	iplused = 0;
#endif /* IPFILTER_LOG */
static	int	(*fr_savep) __P((ip_t *, int, struct ifnet *, int,
				struct mbuf **));
static	void	frflush __P((caddr_t));
static	int	frrequest __P((u_long, caddr_t, int));
d156 1
a156 1
#if _BSDI_VERSION >= 199501
a159 9
int	iplioctl __P((dev_t, int, caddr_t, int, struct proc *));
int	iplopen __P((dev_t, int, int, struct proc *));
int	iplclose __P((dev_t, int, int, struct proc *));
# ifdef IPFILTER_LOG
int	iplread __P((dev_t, struct uio *, int));
# else
#  define iplread	noread
# endif

d170 1
a170 1
#else /* _BSDI_VERSION >= 199501 */
d172 1
d174 2
a175 1
void	iplattach __P((int));
d177 15
a191 23
# ifdef IPFILTER_LOG
#  if BSD >= 199306
int	iplread __P((dev_t, struct uio *, int));
#  else
int	iplread __P((dev_t, struct uio *));
#  endif
# else
#  define iplread	noread
# endif
int	iplioctl __P((dev_t, int, caddr_t, int));
int	iplopen __P((dev_t, int));
int	iplclose __P((dev_t, int));
#endif /* _BSDI_VERSION >= 199501 */

int	ipl_enable __P((void));
int	ipl_disable __P((void));

#ifdef	IPFILTER_LKM
int	iplidentify __P((char *));

int
iplidentify(s)
     char *s;
d197 14
a210 3
#else
void	iplinit __P((void));
#endif /* IPFILTER_LKM */
a211 1
void	ipfr_fastroute __P((struct mbuf *, fr_info_t *, frdest_t *));
d226 1
d228 3
d232 1
a232 1
	SPLNET(s);
d235 1
a235 1
		SPLX(s);
d238 13
d252 2
a253 1
	bzero((char *)nat_table, sizeof(nat_t *) * NAT_SIZE * 2);
d258 21
a278 1
	SPLX(s);
d283 5
a287 2
int
ipl_disable()
d291 1
a291 1
	SPLNET(s);
d295 2
a296 2
		SPLX(s);
		return EBUSY;
d301 1
a301 1
	frflush((caddr_t)&i);
d304 8
d315 1
d317 1
a317 1
	SPLX(s);
d320 1
d323 2
a324 3
static	void
frzerostats(data)
     caddr_t	data;
d339 2
a345 39
static void
frflush(data)
     caddr_t data;
{
	struct frentry *f, **fp;
	int flags = *(int *)data, flushed = 0, set = fr_active;

	bzero((char *)frcache, sizeof(frcache[0]) * 2);

	if (flags & FR_INACTIVE)
		set = 1 - set;
	if (flags & FR_OUTQUE) {
		for (fp = &ipfilter[1][set]; (f = *fp); ) {
			*fp = f->fr_next;
			KFREE(f);
			flushed++;
		}
		for (fp = &ipacct[1][set]; (f = *fp); ) {
			*fp = f->fr_next;
			KFREE(f);
			flushed++;
		}
	}
	if (flags & FR_INQUE) {
		for (fp = &ipfilter[0][set]; (f = *fp); ) {
			*fp = f->fr_next;
			KFREE(f);
			flushed++;
		}
		for (fp = &ipacct[0][set]; (f = *fp); ) {
			*fp = f->fr_next;
			KFREE(f);
			flushed++;
		}
	}
	*(int *)data = flushed;
}


d349 24
a372 12
int
iplioctl(dev, cmd, data, mode
#if _BSDI_VERSION >= 199501
   , p)
	struct proc *p;
#else
   )
#endif
     dev_t dev;
     int cmd;
     caddr_t data;
     int mode;
d374 4
a377 1
	int error = 0, s, unit;
d379 3
a381 2
	unit = minor(dev);
	if (unit != 0)
d383 3
d389 1
a389 1
#ifndef	IPFILTER_LKM
d391 1
a391 1
#endif
d403 1
a403 1
#ifdef	IPFILTER_LOG
d405 1
a405 1
#endif
d413 1
d415 12
a426 1
	SPLNET(s);
d430 2
a431 1
		*(int *)data = iplused;
d434 1
a434 1
#ifndef	IPFILTER_LKM
d467 1
a467 1
			error = frrequest(cmd, data, fr_active);
d475 1
a475 1
			error = frrequest(cmd, data, 1 - fr_active);
d500 1
d502 2
d516 5
a520 2
		else
			frflush(data);
d526 2
a527 5
		else {
			*(int *)data = iplused;
			iplh = iplt = iplbuf;
			iplused = 0;
		}
a529 8
	case SIOCADNAT :
	case SIOCRMNAT :
	case SIOCGNATS :
	case SIOCGNATL :
	case SIOCFLNAT :
	case SIOCCNATL :
		error = nat_ioctl(data, cmd, mode);
		break;
d533 18
a550 2
	case SIOCGIPST :
		IWCOPY((caddr_t)fr_statetstats(), data, sizeof(ips_stat_t));
d556 1
a556 1
	SPLX(s);
d561 43
a603 5
static int
frrequest(req, data, set)
     u_long req;
     caddr_t data;
     int set;
d609 2
a610 1
	int error = 0, in;
d615 11
d627 4
a630 1
	if (fp->fr_flags & FR_ACCOUNT) {
d632 1
a632 1
	} else if (fp->fr_flags & (FR_OUTQUE|FR_INQUE))
d637 6
d648 1
a648 1
			fp->fr_ifa = (struct ifnet *)-1;
d704 10
d715 1
a715 1
			(void) KFREE(f);
d721 6
a726 1
			if ((f = (struct frentry *)KMALLOC(sizeof(*f)))) {
d728 1
d732 5
d745 1
a745 1
#if !defined(linux)
d749 22
a770 6
int
iplopen(dev, flags
#if _BSDI_VERSION >= 199501
    , devtype, p)
	int devtype;
	struct proc *p;
d772 1
a772 1
    )
a773 4
     dev_t dev;
     int flags;
{
	u_int min = minor(dev);
d775 1
a775 1
	if (min)
d777 2
d783 2
a784 6
int
iplclose(dev, flags
#if _BSDI_VERSION >= 199501
    , devtype, p)
	int devtype;
	struct proc *p;
d786 12
a797 4
    )
#endif
     dev_t dev;
     int flags;
d799 1
a799 1
	u_int	min = minor(dev);
d801 1
a801 1
	if (min)
d803 2
a807 1
# ifdef	IPFILTER_LOG
d814 3
d818 2
a819 3
int
iplread(dev, uio, ioflag)
     int ioflag;
d821 1
a821 2
int
iplread(dev, uio)
d823 3
a825 2
     dev_t dev;
     register struct uio *uio;
d827 4
a830 20
	register int ret, s;
	register size_t sz, sx;
	int error;

	if (!uio->uio_resid)
		return 0;
	while (!iplused) {
		error = SLEEP(iplbuf, "ipl_sleep");
		if (error)
			return error;
	}
	SPLNET(s);

	sx = sz = MIN(uio->uio_resid, iplused);
	if (iplh < iplt)
		sz = MIN(sz, LOGSIZE - (iplt - iplbuf));
	sx -= sz;

#  if BSD >= 199306 || defined(__FreeBSD__)
	uio->uio_rw = UIO_READ;
a831 17
	if (!(ret = UIOMOVE(iplt, sz, UIO_READ, uio))) {
		iplt += sz;
		iplused -= sz;
		if ((iplh < iplt) && (iplt == iplbuf + LOGSIZE))
			iplt = iplbuf;

		if (sx && !(ret = UIOMOVE(iplt, sx, UIO_READ, uio))) {
			iplt += sx;
			iplused -= sx;
			if ((iplh < iplt) && (iplt == iplbuf + LOGSIZE))
				iplt = iplbuf;
		}
		if (!iplused)	/* minimise wrapping around the end */
			iplh = iplt = iplbuf;
	}
	SPLX(s);
	return ret;
a832 35
# endif /* IPFILTER_LOG */
#endif /* linux */


#ifdef	IPFILTER_LOG
int
ipllog(flags, ip, fin, m)
     u_int flags;
     ip_t *ip;
     register fr_info_t *fin;
     struct mbuf *m;
{
	struct ipl_ci iplci;
	register int len, mlen, hlen;
	struct ifnet *ifp = fin->fin_ifp;

	hlen = fin->fin_hlen;
	if (ip->ip_p == IPPROTO_TCP || ip->ip_p == IPPROTO_UDP)
		hlen += MIN(sizeof(tcphdr_t), fin->fin_dlen);
	else if (ip->ip_p == IPPROTO_ICMP) {
		struct	icmp	*icmp = (struct icmp *)((char *)ip + hlen);

		switch (icmp->icmp_type) {
		case ICMP_UNREACH :
		case ICMP_SOURCEQUENCH :
		case ICMP_REDIRECT :
		case ICMP_TIMXCEED :
		case ICMP_PARAMPROB :
			hlen += MIN(sizeof(struct icmp) + 8, fin->fin_dlen);
			break;
		default :
			hlen += MIN(sizeof(struct icmp), fin->fin_dlen);
			break;
		}
	}
a833 41
	mlen = (flags & FR_LOGBODY) ? MIN(ip->ip_len - hlen, 128) : 0;
	len = hlen + sizeof(iplci) + mlen;
	if (iplused + len > LOGSIZE)
		return 0;
	iplused += len;

# ifdef	sun
	uniqtime(&iplci);
# endif
# if BSD >= 199306 || defined(__FreeBSD__)
	microtime((struct timeval *)&iplci);
# endif
	iplci.flags = flags;
	iplci.hlen = (u_char)hlen;
	iplci.plen = (u_char)mlen;
	iplci.rule = fin->fin_rule;
# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199603)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
	strncpy(iplci.ifname, ifp->if_xname, IFNAMSIZ);
# else
	iplci.unit = (u_char)ifp->if_unit;
	if ((iplci.ifname[0] = ifp->if_name[0]))
		if ((iplci.ifname[1] = ifp->if_name[1]))
			if ((iplci.ifname[2] = ifp->if_name[2]))
				iplci.ifname[3] = ifp->if_name[3];
# endif
	/*      
	 * Guaranteed to succeed from above
	 */     
	(void) fr_copytolog((char *)&iplci, sizeof(iplci));

	for (len -= sizeof(iplci); m && len > 0; m = m->m_next, len -= hlen) {
		hlen = MIN(len, m->m_len);
		if (fr_copytolog(mtod(m, char *), hlen))
			break;
	}

	wakeup(iplbuf);
	return 1;
}
#endif /* IPFILTER_LOG */
d839 2
a840 3
int
send_reset(ti)
     struct tcpiphdr *ti;
a842 1
	struct ip *ip;
d845 5
a849 1
	int tlen = 0;
d853 1
a853 1
#if	BSD < 199306
d855 1
a855 1
#else
d858 1
a858 1
#endif
d865 1
a865 1
#if	BSD >= 199306
d868 1
a868 1
#endif
d888 1
a888 1
#if BSD < 199306
d890 1
a890 1
#else
d892 1
a892 1
#endif
d894 6
d903 3
a905 2
	(void) ip_output(m, (struct mbuf *)0, 0, 0, 0);
	return 0;
d909 4
a912 2
#ifndef	IPFILTER_LKM
# if	BSD < 199306
d914 3
a916 1
# else
d918 1
a918 1
# endif
d924 12
a935 1
#endif
d938 4
a941 5
void
ipfr_fastroute(m0, fin, fdp)
     struct mbuf *m0;
     fr_info_t *fin;
     frdest_t *fdp;
d961 5
a965 2
#if	(BSD >= 199306) && !defined(__NetBSD__) && !defined(__bsdi__) \
	&& !defined(__OpenBSD__)
d968 3
d972 1
a972 1
	rtalloc_ign(ro, RTF_PRCLONING);
a973 3
#else
	rtalloc(ro);
#endif
d1003 1
a1003 1
#ifndef sparc
d1007 1
a1007 1
#endif
d1010 1
a1010 1
#if	BSD >= 199306
d1013 1
a1013 2

#else
d1015 1
a1015 1
#endif
d1048 1
a1048 1
#if BSD >= 199306
d1050 1
a1050 1
#else
d1052 1
a1052 1
#endif
d1073 1
a1073 1
#ifndef sparc
d1075 1
a1075 1
#endif
d1095 1
a1095 1
#if BSD >= 199306
d1098 1
a1098 1
#else
d1101 1
a1101 1
#endif
d1107 5
d1120 180
@


1.14
log
@merge in 3.1.11
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.13 1997/04/18 06:10:08 niklas Exp $	*/
d283 27
@


1.13
log
@Use the right types on 64-bit machines
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.12 1997/03/31 15:52:45 kstailey Exp $	*/
d11 1
a11 1
static	char	rcsid[] = "Id: ip_fil.c,v 2.0.1.5 1997/01/29 13:41:45 darrenr Exp ";
d415 1
a415 1
	frentry_t fr;
a416 1
	struct frentry frd;
d419 1
a419 1
	fp = &fr;
a421 2
	bzero((char *)frcache, sizeof(frcache[0]) * 2);

d430 2
a431 2
	IRCOPY((char *)fp, (char *)&frd, sizeof(frd));
	fp = &frd;
d755 3
d759 1
@


1.12
log
@changed ipfattach() to ipf_enable()
changed ipfdetach() to ipf_disable()
added stub ipfattach() which is called from main()
commented out activation of ipf from iplinit()
	must explicitly enable with ipf -E
removed bogus deactivation of ipf from iplinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.11 1997/03/15 17:18:07 kstailey Exp $	*/
d78 1
a78 1
static	int	frrequest __P((int, caddr_t, int));
d409 1
a409 1
     int req, set;
d411 1
@


1.11
log
@remove space from tsleep() message
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.c,v 1.10 1997/02/11 22:23:12 kstailey Exp $	*/
d105 3
d122 2
a123 2
int	iplattach __P((void));
int	ipldetach __P((void));
d142 10
d153 1
a153 1
iplattach()
d175 1
a175 1
ipldetach()
d301 1
a301 1
				error = iplattach();
d303 1
a303 1
				error = ipldetach();
d760 1
a760 1
	(void) iplattach();
a761 1
	(void) ipldetach();	/* XXX */
@


1.10
log
@IPF 1.3.7
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d568 1
a568 1
		error = SLEEP(iplbuf, "ipl sleep");
@


1.9
log
@#define ICMP_UNREACH_FILTER -> ICMP_UNREACH_FILTER_PROHIB to match tcpdump/print_icmp.c which had it first
@
text
@d1 1
d9 1
a9 2
#if 0
#ifndef	lint
d11 1
a11 2
static	char	rcsid[] = "$OpenBSD: ip_fil.c,v 1.8 1997/01/18 08:29:19 downsj Exp $";
#endif
d14 1
a14 1
#ifndef	linux
a15 2
#include <sys/types.h>
#include <sys/param.h>
a16 5
#if defined(__OpenBSD__)
# include <sys/dirent.h>
#else
# include <sys/dir.h>
#endif
a17 2
#include <sys/systm.h>
#include <sys/uio.h>
d21 3
d39 1
a39 2
#include <sys/syslog.h>
#endif
d52 1
a52 1
    struct mbuf **));
d62 2
d66 1
d70 3
a72 2
static	char	iplbuf[LOGSIZE];
static	caddr_t	iplh = iplbuf, iplt = iplbuf;
a74 1
static	int	iplbusy = 0;
d76 3
a78 1
    struct mbuf **));
d80 1
a80 1
#if _BSDI_VERSION >= 199510
d85 1
d87 5
a91 1
int	iplopen __P((dev_t, int, int, struct proc *));
d103 1
a103 1
#else /* _BSDI_VERSION >= 199510 */
d105 2
a106 3
# ifndef linux
#  ifdef IPFILTER_LOG
#   if BSD >= 199306
d108 1
a108 1
#   else
a109 3
#   endif
#  else
#   define iplread	noread
d111 5
d117 1
a117 5
int	iplopen __P((dev_t, int));
# endif /* linux */
int	iplioctl __P((dev_t, int, caddr_t, int));

#endif /* _BSDI_VERSION >= 199510 */
a120 7
void	frzerostats __P((caddr_t));
void	frflush __P((caddr_t));
int	frrequest __P((int, caddr_t, int));

#ifndef	IPFILTER_LKM
void	iplinit __P((void));
#endif /* !IPFILTER_LKM */
d127 1
a127 1
	char *s;
d133 2
d137 1
d146 1
a146 1
		printf("ipl: already initialized (%d)\n", iplbusy);
d151 1
a165 4
	if (iplbusy > 1) {
		printf("iplbusy: %d\n", iplbusy);
		return EBUSY;
	}
d169 1
a169 1
		printf("ipl: not initialized\n");
d188 1
a188 1
void
d190 1
a190 1
	caddr_t	data;
d206 1
a206 1
	bzero((char *)frstats, sizeof(*frstats));
d210 1
a210 1
void
d212 1
a212 1
	caddr_t data;
d254 2
a255 2
#if _BSDI_VERSION >= 199510
    , p)
d258 1
a258 1
    )
d260 4
a263 4
	dev_t dev;
	int cmd;
	caddr_t data;
	int mode;
d394 1
a394 1
int
d396 2
a397 2
	int req, set;
	caddr_t data;
d506 1
a506 1
#if _BSDI_VERSION >= 199510
d513 2
a514 2
	dev_t dev;
	int flags;
d526 1
a526 1
#if _BSDI_VERSION >= 199510
d533 2
a534 2
	dev_t dev;
	int flags;
d553 1
a553 1
	int ioflag;
d558 2
a559 2
	dev_t dev;
	register struct uio *uio;
a566 1
	iplbusy++;
d569 1
a569 2
		if (error) {
			iplbusy--;
a570 1
		}
a597 1
	iplbusy--;
d607 4
a610 4
	u_int flags;
	ip_t *ip;
	register fr_info_t *fin;
	struct mbuf *m;
a612 1
	register size_t tail = 0;
d636 1
a636 1
	mlen = (flags & FR_LOGBODY) ? (MIN(m->m_len, 128) & 0xfa) : 0;
d650 1
a650 1
	iplci.plen = (flags & FR_LOGBODY) ? (u_char)mlen : 0 ;
d652 3
a654 3
# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
    (defined(OpenBSD) && (OpenBSD >= 199606))
	strcpy(iplci.ifname, ifp->if_xname);
d662 10
a671 5
	if (iplh == iplbuf + LOGSIZE)
		iplh = iplbuf;
	tail = (iplh >= iplt) ? (iplbuf + LOGSIZE - iplh) : (iplt - iplh);

	len = MIN(tail, sizeof(iplci));
a672 44
	/*
	 * check in both cases where we add stuff to the buffer to see if we
	 * are going to wrap around at the end.
	 */
	bcopy((char *)&iplci, iplh, len);
	iplh += len;
	if (len < sizeof(iplci)) {
		bcopy((char *)&iplci + len, iplbuf, sizeof(iplci) - len);
		iplh = iplbuf + sizeof(iplci) - len;
		tail = iplt - iplh;
	} else
		tail -= len;

	len = MIN(tail, hlen);
	bcopy((char *)ip, iplh, len);
	iplh += len;
	if (len < hlen) {
		iplh = iplbuf;
		bcopy((char *)ip + len, iplh, hlen - len);
		iplh += hlen - len;
		tail = iplt - iplh;
	} else
		tail -= len;

	if (mlen) {
		len = MIN(tail, mlen);
#if BSD < 199103
		bcopy((char *)m->m_un.mun_dat, iplh, len);
#else
		bcopy((char *)m->M_dat.M_databuf, iplh, len);
#endif
		iplh += len;
		if (len < mlen) {
			iplh = iplbuf;
#if BSD < 199103
			bcopy((char *)m->m_un.mun_dat + len, iplh,
				mlen - len);
#else
			bcopy((char *)m->M_dat.M_databuf + len, iplh,
				mlen - len);
#endif
			iplh += mlen - len;
		}
	}
d684 1
a684 1
	struct tcpiphdr *ti;
d747 1
a747 1
	/* (void) iplattach(); */
d749 1
d756 3
a758 3
	struct mbuf *m0;
	fr_info_t *fin;
	frdest_t *fdp;
d778 2
a779 1
#if	BSD >= 199306 && !(defined(__NetBSD__) || defined(__OpenBSD__))
d805 9
a813 1
	/*	
@


1.8
log
@syslog.h -> sys/syslog.h

THIS IS THE KERNEL, DAMNIT.
@
text
@d11 1
a11 1
static	char	rcsid[] = "$OpenBSD: ip_fil.c,v 1.7 1996/10/24 17:56:20 tholo Exp $";
d71 1
a71 1
int	ipl_unreach = ICMP_UNREACH_FILTER;
@


1.7
log
@<sys/dir.h> is for use as a compatibility interface only.  Warn if
included by kernel modules, and also remove use from any modules that
currently attempt to use it.
@
text
@d11 1
a11 1
static	char	rcsid[] = "$OpenBSD: ip_fil.c,v 1.6 1996/10/08 07:33:25 niklas Exp $";
d46 1
a46 1
#include <syslog.h>
@


1.6
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d11 1
a11 1
static	char	rcsid[] = "$OpenBSD: ip_fil.c,v 1.5 1996/09/30 14:06:37 deraadt Exp $";
d20 5
a24 1
#include <sys/dir.h>
@


1.5
log
@handle openbsd cases
@
text
@d8 1
d11 2
a12 1
static	char	rcsid[] = "$Id: ip_fil.c,v 1.4 1996/07/18 05:00:58 dm Exp $";
d44 1
a45 1
#include "ip_fil_compat.h"
d55 2
a56 1
extern	int	(*fr_checkp)();
d58 2
a59 2
extern	int	ipfr_slowtimer();
static	int	(*fr_saveslowtimo)();
d62 2
a63 2
extern	void	ipfr_slowtimer();
static	void	(*fr_saveslowtimo)();
a67 1
int	send_reset();
a70 1
int	ipllog();
a74 2
static	void	frflush();
static	int	frrequest();
d76 2
a77 1
static	int	(*fr_savep)();
d84 1
a85 7
int	iplclose __P((dev_t, int, int, struct proc *));
# ifdef IPFILTER_LOG
int	iplread __P((dev_t, struct uio *, int));
# else
#  define iplread	noread
# endif
int	iplioctl __P((dev_t, int, caddr_t, int, struct proc *));
d97 17
d116 10
d127 5
a131 2
int iplidentify(s)
char *s;
d140 2
a141 1
int iplattach()
d161 2
a162 1
int ipldetach()
d192 3
a194 2
static	void	frzerostats(data)
caddr_t	data;
d214 3
a216 2
static void frflush(data)
caddr_t data;
d256 2
a257 1
int iplioctl(dev, cmd, data, mode
d259 2
a260 2
, p)
struct proc *p;
d262 1
a262 1
)
d264 4
a267 4
dev_t dev;
int cmd;
caddr_t data;
int mode;
d269 1
a269 1
	int error = 0, s, unit, used;
d398 4
a401 3
static int frrequest(req, data, set)
int req, set;
caddr_t data;
d508 2
a509 1
int iplopen(dev, flags
d511 3
a513 3
, devtype, p)
int devtype;
struct proc *p;
d515 1
a515 1
)
d517 2
a518 2
dev_t dev;
int flags;
d528 2
a529 1
int iplclose(dev, flags
d531 3
a533 3
, devtype, p)
int devtype;
struct proc *p;
d535 1
a535 1
)
d537 2
a538 2
dev_t dev;
int flags;
d555 3
a557 2
int iplread(dev, uio, ioflag)
int ioflag;
d559 2
a560 1
int iplread(dev, uio)
d562 2
a563 2
dev_t dev;
register struct uio *uio;
d613 6
a618 5
int ipllog(flags, ip, fin, m)
u_int flags;
ip_t *ip;
register fr_info_t *fin;
struct mbuf *m;
d730 3
a732 2
int send_reset(ti)
struct tcpiphdr *ti;
d792 1
d801 5
a805 4
void ipfr_fastroute(m0, fin, fdp)
struct mbuf *m0;
fr_info_t *fin;
frdest_t *fdp;
d811 1
a811 1
	int len, off, error = 0, s;
@


1.4
log
@ipfilter 3.1.0
@
text
@d10 1
a10 1
static	char	rcsid[] = "$Id: ip_fil.c,v 1.2 1996/07/04 13:24:05 darrenr Exp $";
d626 2
a627 1
# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606))
d787 1
a787 1
#if	BSD >= 199306 && !(defined(__NetBSD__))
@


1.3
log
@ipfilter 3.0.4
@
text
@d9 2
a10 1
static	char	sccsid[] = "@@(#)ip_fil.c	2.37 4/10/96 (C) 1993-1995 Darren Reed";
d32 1
d43 1
d68 1
a68 1
#define	LOGSIZE	8192
d80 2
a81 2
#include <sys/device.h>
#include <sys/conf.h>
d86 1
a86 1
#ifdef IPFILTER_LOG
d88 3
a90 3
#else
#define iplread noread
#endif
d103 1
a103 1
#endif
d249 1
d251 1
d258 9
a266 5
		IRCOPY(data, (caddr_t)&enable, sizeof(enable));
		if (enable)
			error = iplattach();
		else
			error = ipldetach();
d271 4
a274 1
		IRCOPY(data, (caddr_t)&fr_flags, sizeof(fr_flags));
d282 5
a286 1
		error = frrequest(cmd, (struct frentry *)data, fr_active);
d291 4
a294 1
		error = frrequest(cmd, (struct frentry *)data, 1-fr_active);
d297 7
a303 3
		bzero((char *)frcache, sizeof(frcache[0]) * 2);
		*(u_int *)data = fr_active;
		fr_active = 1 - fr_active;
d324 4
a327 1
		frzerostats(data);
d330 4
a333 1
		frflush(data);
d337 7
a343 3
		*(int *)data = iplused;
		iplh = iplt = iplbuf;
		iplused = 0;
d350 3
a352 1
		error = nat_ioctl(data, cmd);
d361 1
a361 1
		error = -EINVAL;
d369 1
a369 1
static int frrequest(req, fp, set)
d371 1
a371 1
register struct frentry *fp;
d373 4
a376 2
	register struct frentry *f, **fprev;
	register struct frentry **ftail;
d380 3
d400 18
d426 13
d491 1
a491 1
	if ((flags & FWRITE) || min)
a492 2
	else
		iplbusy++;
a511 2
	else if (iplbusy > 0)
		iplbusy--;
d537 1
d540 2
a541 1
		if (error)
d543 1
a544 1

d571 1
d626 3
a628 1
#if !defined (__OpenBSD__) && !defined (__NetBSD__)
d630 5
a634 8
	iplci.ifname[0] = ifp->if_name[0];
	iplci.ifname[1] = ifp->if_name[1];
	iplci.ifname[2] = ifp->if_name[2];
	iplci.ifname[3] = ifp->if_name[3];
#else /* OpenBSD or NetBSD */
	bcopy (ifp->if_xname, iplci.ifname, IFNAMSIZ);
#endif /* OpenBSD or NetBSD */

a736 2
	ip->ip_hl = sizeof(struct ip) >> 2;
	ip->ip_v = IPVERSION;
a737 2
	ip->ip_id = ((struct ip *)ti)->ip_id;
	ip->ip_off = ((struct ip *)ti)->ip_off;
d749 1
a749 1
	(void) ip_output(m, (struct mbuf *)0, 0, IP_FORWARDING, 0);
d757 1
a757 1
	(void) iplattach();
d761 168
@


1.2
log
@IP filter 3.0.1
@
text
@d9 1
a9 1
static	char	sccsid[] = "@@(#)ip_fil.c	2.31 1/14/96 (C) 1993-1995 Darren Reed";
d76 25
a125 4
#if BSD >= 199306
	fr_saveslowtimo = inetsw[0].pr_slowtimo;
	inetsw[0].pr_slowtimo = ipfr_slowtimer;
#else
a127 1
#endif
d137 1
a137 1
	if (iplbusy) {
d188 3
a190 1
	int flags = *(int *)data, flushed = 0, set = fr_active, in;
a217 1

d225 7
a231 1
int iplioctl(dev, cmd, data, mode)
d237 1
a237 1
	int error = 0, s, unit;
d245 3
d278 1
d316 1
d343 2
d364 1
a364 1
	for (; f = *ftail; ftail = &f->fr_next)
d407 8
a414 1
int iplopen(dev, flags)
d428 8
a435 1
int iplclose(dev, flags)
d509 1
a509 1
int ipllog(flags, ip, ifp, fi, m)
d512 1
a512 2
struct ifnet *ifp;
register struct fr_ip *fi;
d518 1
d520 1
a520 1
	hlen = fi->fi_hlen;
d522 1
a522 1
		hlen += MIN(sizeof(tcphdr_t), ip->ip_len - hlen);
d532 1
a532 1
			hlen += MIN(sizeof(struct icmp) + 8, ip->ip_len - hlen);
d535 1
a535 1
			hlen += MIN(sizeof(struct icmp), ip->ip_len - hlen);
d555 2
a556 1
	iplci.rule = fi->fi_rule;
d562 3
d687 9
@


1.1
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d9 1
a9 1
static	char	sccsid[] = "@@(#)ip_fil.c	2.26 11/8/95 (C) 1993-1995 Darren Reed";
d41 3
d49 2
a50 1
extern	int	fr_check(), (*fr_checkp)();
d52 2
d56 2
a57 1
extern	int	ip_defttl;
d85 1
d101 7
a107 1

d130 1
d134 4
a140 1
#endif /* IPFILTER_LKM */
d150 8
a157 4
	fio.f_fin[0] = filterin[0];
	fio.f_fin[1] = filterin[1];
	fio.f_fout[0] = filterout[0];
	fio.f_fout[1] = filterout[1];
d168 1
a168 1
	int flags = *(int *)data, flushed = 0, set = fr_active;
d172 2
a173 2
	if (flags & FR_OUTQUE)
		for (fp = &filterout[set]; (f = *fp); ) {
d178 8
a185 2
	if (flags & FR_INQUE)
		for (fp = &filterin[set]; (f = *fp); ) {
d190 6
d224 4
a227 7
		if (enable) {
			if (fr_checkp != fr_check) {
				fr_savep = fr_checkp;
				fr_checkp = fr_check;
			}
		} else
			fr_checkp = fr_savep;
d257 8
a264 4
		fio.f_fin[0] = filterin[0];
		fio.f_fin[1] = filterin[1];
		fio.f_fout[0] = filterout[0];
		fio.f_fout[1] = filterout[1];
d282 11
d309 1
a309 1
	int error = 0;
d311 5
a315 4
	if (fp->fr_flags & FR_OUTQUE)
		ftail = fprev = &filterout[set];
	else if (fp->fr_flags & FR_INQUE)
		ftail = fprev = &filterin[set];
d461 1
a461 2
int ipllog(hlen, flags, ip, ifp, rule)
register int hlen;
d465 2
a466 1
u_short rule;
d470 1
a470 2
	register int len, mlen;
	register struct mbuf *m = dtom(ip);
d472 1
d474 1
a474 1
		hlen += sizeof(tcphdr_t);
d484 2
a485 1
			hlen += 8;
d487 2
a488 1
			hlen += sizeof(struct icmp);
d507 1
a507 1
	iplci.rule = rule;
@

