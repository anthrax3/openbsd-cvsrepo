head	1.49;
access;
symbols
	SMP_SYNC_A:1.49
	SMP_SYNC_B:1.49
	UBC_SYNC_A:1.49
	UBC_SYNC_B:1.49
	SMP:1.49.0.2
	kame_19991208:1.35
	OPENBSD_2_6:1.31.0.2
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.28.0.2
	OPENBSD_2_5_BASE:1.28
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.49
date	2000.01.21.03.15.52;	author angelos;	state dead;
branches;
next	1.48;

1.48
date	2000.01.17.05.35.23;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2000.01.13.06.02.31;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2000.01.13.05.03.45;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2000.01.02.09.31.03;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	99.12.24.20.02.44;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	99.12.21.20.26.13;	author provos;	state Exp;
branches;
next	1.42;

1.42
date	99.12.21.09.00.52;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	99.12.09.20.38.35;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	99.12.09.17.55.35;	author downsj;	state Exp;
branches;
next	1.39;

1.39
date	99.12.09.09.10.05;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	99.12.09.09.07.54;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	99.12.09.04.00.07;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	99.12.09.03.52.37;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	99.12.08.06.05.32;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	99.12.06.07.14.36;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	99.10.29.02.02.33;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	99.10.29.01.50.34;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	99.05.16.22.31.40;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	99.05.12.23.18.35;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	99.04.20.20.06.11;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	99.04.09.23.28.45;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	99.04.09.19.42.09;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	99.04.04.21.33.49;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.02.25.19.21.09;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	99.02.24.23.45.51;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	99.02.24.22.33.04;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	99.01.08.21.51.21;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	98.12.26.12.35.11;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	98.07.29.22.18.49;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	98.06.10.23.57.12;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	98.05.22.07.29.20;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	98.05.18.21.10.51;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	98.03.18.10.51.36;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	97.11.04.09.11.14;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.10.02.02.31.05;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.09.28.23.09.57;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.07.14.08.48.47;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.07.11.23.37.58;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.07.01.22.12.49;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.06.25.07.53.27;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.06.24.12.15.25;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.06.24.02.20.23;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	97.06.20.05.41.52;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.02.26.03.01.04;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	97.02.24.14.06.41;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.02.22.15.51.18;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.02.22.03.39.35;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.07.58;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Forgot to delete this.
@
text
@/*	$OpenBSD: ip_ip4.c,v 1.48 2000/01/17 05:35:23 itojun Exp $	*/

/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * IP-inside-IP processing
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/sysctl.h>
#include <machine/cpu.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_ecn.h>

#ifdef MROUTING
#include <netinet/ip_mroute.h>
#endif

#include <sys/socketvar.h>
#include <net/raw_cb.h>

#include <netinet/ip_ipsp.h>
#include <netinet/ip_ip4.h>
#include <dev/rndvar.h>

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
#endif

/*
 * We can control the acceptance of IP4 packets by altering the sysctl
 * net.inet.ip4.allow value.  Zero means drop them, all else is acceptance.
 */
int ip4_allow = 0;

struct ip4stat ip4stat;

#ifdef INET6
/*
 * Really only a wrapper for ip4_input(), for use with IPv6.
 */
int
ip4_input6(struct mbuf **m, int *offp, int proto)
{
    ip4_input(*m, *offp);
    return IPPROTO_DONE;
}
#endif /* INET6 */

/*
 * ip4_input gets called when we receive an IPv4 encapsulated packet,
 * either because we got it at a real interface, or because AH or ESP
 * were being used in tunnel mode (in which case the rcvif element will 
 * contain the address of the encX interface associated with the tunnel.
 */

void
#if __STDC__
ip4_input(struct mbuf *m, ...)
#else
ip4_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
{
    register struct sockaddr_in *sin;
    register struct ifnet *ifp;
    register struct ifaddr *ifa;
    struct ifqueue *ifq = NULL;
    struct ip *ipo;
#ifdef INET6
    register struct sockaddr_in6 *sin6;
    struct ip6_hdr *ip6 = NULL;
    u_int8_t itos;
#endif
    u_int8_t nxt;
    int s, iphlen;
    va_list ap;
    int isr;
    u_int8_t otos;
    u_int8_t v;
    int hlen;

    va_start(ap, m);
    iphlen = va_arg(ap, int);
    va_end(ap);

    ip4stat.ip4s_ipackets++;

    m_copydata(m, 0, 1, &v);
    if ((v >> 4) == 4)
	hlen = sizeof(struct ip);
#ifdef INET6
    else if ((v >> 4) == 6)
	hlen = sizeof(struct ip6_hdr);
#endif
    else {
	m_freem(m);
	return /*EAFNOSUPPORT*/;
    }

    /* Bring the outer IP(v4) header in the first mbuf, if not there already */
    if (m->m_len < hlen)
    {
	if ((m = m_pullup(m, hlen)) == 0)
	{
	    DPRINTF(("ip4_input(): m_pullup() failed\n"));
	    ip4stat.ip4s_hdrops++;
	    return;
	}
    }

    ipo = mtod(m, struct ip *);

#ifdef MROUTING
    if (ipo->ip_v == IPVERSION && ipo->ip_p == IPPROTO_IPV4)
    {
	if (IN_MULTICAST(((struct ip *)((char *)ipo + iphlen))->ip_dst.s_addr))
	{
	    ipip_input (m, iphlen);
	    return;
	}
    }
#endif MROUTING

    /* keep outer ecn field */
    if ((v >> 4) == 4)
	otos = ipo->ip_tos;
#ifdef INET6
    else if ((v >> 4) == 6)
	otos = (ntohl(mtod(m, struct ip6_hdr *)->ip6_flow) >> 20) & 0xff;
#endif
    else
	otos = 0;

    /* If we do not accept IP4 explicitly, drop.  */
    if (!ip4_allow && (m->m_flags & (M_AUTH|M_CONF)) == 0)
    {
	DPRINTF(("ip4_input(): dropped due to policy\n"));
	ip4stat.ip4s_pdrops++;
	m_freem(m);
	return;
    }

    /* Remove outter IP header */
    m_adj(m, iphlen);

    m_copydata(m, 0, 1, &v);
    if ((v >> 4) == 4)
	hlen = sizeof(struct ip);
#ifdef INET6
    else if ((v >> 4) == 6)
	hlen = sizeof(struct ip6_hdr);
#endif
    else {
	m_freem(m);
	return /*EAFNOSUPPORT*/;
    }

    /* Bring the inner IP(v4) header in the first mbuf, if not there already */
    if (m->m_len < hlen)
    {
	if ((m = m_pullup(m, hlen)) == 0)
	{
	    DPRINTF(("ip4_input(): m_pullup() failed\n"));
	    ip4stat.ip4s_hdrops++;
	    return;
	}
    }

    ipo = mtod(m, struct ip *);
    v = ipo->ip_v;

    /*
     * RFC 1853 specifies that the inner TTL should not be touched on
     * decapsulation. There's no reason this comment should be here, but
     * this is as good as any a position.
     */

    /* Some sanity checks in the inner IPv4 header */
    switch (v) {
    case IPVERSION:
	nxt = ipo->ip_p;
	break;
#ifdef INET6
    case 6:
	ip6 = (struct ip6_hdr *)ipo;
	ipo = NULL;
	nxt = ip6->ip6_nxt;
	break;
#endif
    default:
	DPRINTF(("ip4_input(): wrong version %d on packet from %s to %s (%s->%s)\n", ipo->ip_v, inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst)));
	ip4stat.ip4s_family++;
	m_freem(m);
	return;
    }

    /*
     * If we do not accept IP4 other than as part of ESP & AH, we should
     * not accept a packet with double ip4 headers neither.
     */
 
    if (!ip4_allow && ((nxt == IPPROTO_IPIP) || (nxt == IPPROTO_IPV6)))
    {
	DPRINTF(("ip4_input(): dropped due to policy\n"));
	ip4stat.ip4s_pdrops++;
	m_freem(m);
	return;
    }

    /* update inner ecn field. */
    switch (v) {
    case IPVERSION:
	ip_ecn_egress(ECN_ALLOWED, &otos, &ipo->ip_tos);
	break;
#ifdef INET6
    case 6:
	itos = (ntohl(ip6->ip6_flow) >> 20) & 0xff;
	ip_ecn_egress(ECN_ALLOWED, &otos, &itos);
	ip6->ip6_flow &= ~htonl(0xff << 20);
	ip6->ip6_flow |= htonl((u_int32_t)itos << 20);
	break;
#endif
    }

    /* Check for local address spoofing. */
    if (m->m_pkthdr.rcvif == NULL ||
	!(m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK))
    {
        for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
	{
	    for (ifa = ifp->if_addrlist.tqh_first;
		 ifa != 0;
		 ifa = ifa->ifa_list.tqe_next)
	    {
		if (ipo)
		{
		    if (ifa->ifa_addr->sa_family != AF_INET)
		      continue;

		    sin = (struct sockaddr_in *) ifa->ifa_addr;

		    if (sin->sin_addr.s_addr == ipo->ip_src.s_addr)
		    {
			DPRINTF(("ip4_input(): possible local address spoofing detected on packet from %s to %s (%s->%s)\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst)));
			ip4stat.ip4s_spoof++;
			m_freem(m);
			return;
		    }
		}
#ifdef INET6
		else if (ip6)
		{
		    if (ifa->ifa_addr->sa_family != AF_INET6)
		      continue;

		    sin6 = (struct sockaddr_in6 *) ifa->ifa_addr;

		    if (IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr, &ip6->ip6_src))
		    {
			DPRINTF(("ip4_input(): possible local address spoofing detected on packet\n"));
			m_freem(m);
			return;
		    }

		}
#endif
	    }
	}
    }
    
    /* Statistics */
    if (ipo)
      ip4stat.ip4s_ibytes += m->m_pkthdr.len - iphlen;

    /* tdbi is only set in ESP or AH, if the next protocol is UDP or TCP */
    if (m->m_flags & (M_CONF|M_AUTH))
      m->m_pkthdr.tdbi = NULL;

    /*
     * Interface pointer stays the same; if no IPsec processing has
     * been done (or will be done), this will point to a normal 
     * interface. Otherwise, it'll point to an enc interface, which
     * will allow a packet filter to distinguish between secure and
     * untrusted packets.
     */

    if (ipo)
    {
	ifq = &ipintrq;
	isr = NETISR_IP;
    }
#ifdef INET6
    else if (ip6)
    {
	ifq = &ip6intrq;
	isr = NETISR_IPV6;
    }
#endif
    else
    {
	/* just in case */
	m_freem(m);
	return;
    }

    s = splimp();			/* isn't it already? */
    if (IF_QFULL(ifq))
    {
	IF_DROP(ifq);
	m_freem(m);
	if (ipo)
	    ip4stat.ip4s_qfull++;

	splx(s);

	DPRINTF(("ip4_input(): packet dropped because of full queue\n"));
	return;
    }

    IF_ENQUEUE(ifq, m);
    schednetisr(isr);
    splx(s);

    return;
}

int
ipe4_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
	    int protoff)
{
    u_int8_t tp, otos;

#ifdef INET
    u_int8_t itos;
    struct ip *ipo;
#endif /* INET */

#ifdef INET6    
    struct ip6_hdr *ip6o;
#endif /* INET6 */

    /* Deal with empty TDB source/destination addresses */
    /* XXX */

    m_copydata(m, 0, 1, &tp);
    tp = (tp >> 4) & 0xff;  /* Get the IP version number */

    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    if ((tdb->tdb_src.sa.sa_family != AF_INET) ||
		(tdb->tdb_src.sin.sin_addr.s_addr == INADDR_ANY) ||
		(tdb->tdb_dst.sin.sin_addr.s_addr == INADDR_ANY))
	    {
		DPRINTF(("ipe4_output(): unspecified tunnel endpoind address in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ip4stat.ip4s_unspec++;
		m_freem(m);
		*mp = NULL;
		return EINVAL;
	    }

	    M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
	    if (m == 0)
	    {
		DPRINTF(("ipe4_output(): M_PREPEND failed\n"));
		ip4stat.ip4s_hdrops++;
		*mp = NULL;
		return ENOBUFS;
	    }
	    
	    ipo = mtod(m, struct ip *);

	    ipo->ip_v = IPVERSION;
	    ipo->ip_hl = 5;
	    ipo->ip_len = htons(m->m_pkthdr.len);
	    ipo->ip_ttl = ip_defttl;
	    ipo->ip_sum = 0;
	    ipo->ip_src = tdb->tdb_src.sin.sin_addr;
	    ipo->ip_dst = tdb->tdb_dst.sin.sin_addr;

	    /*
	     * We do the htons() to prevent snoopers from determining our
	     * endianness.
	     */
	    ipo->ip_id = htons(ip_randomid());

	    /* If the inner protocol is IP */
	    if (tp == IPVERSION)
	    {
		/* Save ECN notification */
		m_copydata(m, sizeof(struct ip) + offsetof(struct ip, ip_tos),
			   sizeof(u_int8_t), (caddr_t) &itos);

		ipo->ip_p = IPPROTO_IPIP;

		/*
		 * We should be keeping tunnel soft-state and send back ICMPs
		 * if needed.
		 */
		m_copydata(m, sizeof(struct ip) + offsetof(struct ip, ip_off),
			   sizeof(u_int16_t), (caddr_t) &ipo->ip_off);
		ipo->ip_off &= ~(IP_DF | IP_MF | IP_OFFMASK);
	    }
#ifdef INET6
	    else if (tp == (IPV6_VERSION >> 4))
	    {
		u_int32_t itos32;
		/* Save ECN notification */
		m_copydata(m, sizeof(struct ip) +
			   offsetof(struct ip6_hdr, ip6_flow),
			   sizeof(u_int32_t), (caddr_t) &itos32);
		itos = ntohl(itos32) >> 20;

		ipo->ip_p = IPPROTO_IPV6;
		ipo->ip_off = 0;
	    }
#endif /* INET6 */
	    else
	    {
		m_freem(m);
		*mp = NULL;
		return EAFNOSUPPORT;
	    }

	    otos = 0;
	    ip_ecn_ingress(ECN_ALLOWED, &otos, &itos);
	    ipo->ip_tos = otos;
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    if (IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr) ||
		(tdb->tdb_src.sa.sa_family != AF_INET6) ||
		IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_src.sin6.sin6_addr))
	    {
		DPRINTF(("ipe4_output(): unspecified tunnel endpoind address in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ip4stat.ip4s_unspec++;
		m_freem(m);
		*mp = NULL;
		return ENOBUFS;
	    }

	    M_PREPEND(m, sizeof(struct ip6_hdr), M_DONTWAIT);
	    if (m == 0)
	    {
		DPRINTF(("ipe4_output(): M_PREPEND failed\n"));
		ip4stat.ip4s_hdrops++;
		*mp = NULL;
		return ENOBUFS;
	    }

	    /* Initialize IPv6 header */
	    ip6o = mtod(m, struct ip6_hdr *);
	    ip6o->ip6_flow = 0;
	    ip6o->ip6_vfc &= ~IPV6_VERSION_MASK;
	    ip6o->ip6_vfc |= IPV6_VERSION;
	    ip6o->ip6_plen = htons(m->m_pkthdr.len);
	    ip6o->ip6_hlim = ip_defttl;
	    ip6o->ip6_dst = tdb->tdb_dst.sin6.sin6_addr;
	    ip6o->ip6_src = tdb->tdb_src.sin6.sin6_addr;

#ifdef INET
	    if (tp == IPVERSION)
	    {
		/* Save ECN notification */
		m_copydata(m, sizeof(struct ip6_hdr) +
			   offsetof(struct ip, ip_tos), sizeof(u_int8_t),
			   (caddr_t) &itos);

		ip6o->ip6_nxt = IPPROTO_IPIP; /* This is really IPVERSION */
	    }
	    else
#endif /* INET */
	    if (tp == (IPV6_VERSION >> 4))
	    {
		u_int32_t itos32;
		/* Save ECN notification */
		m_copydata(m, sizeof(struct ip6_hdr) +
			   offsetof(struct ip6_hdr, ip6_flow),
			   sizeof(u_int32_t), (caddr_t) &itos32);
		itos = ntohl(itos32) >> 20;

		ip6o->ip6_nxt = IPPROTO_IPV6;
	    }
	    else
	    {
		m_freem(m);
		*mp = NULL;
		return EAFNOSUPPORT;
	    }

	    otos = 0;
	    ip_ecn_ingress(ECN_ALLOWED, &otos, &itos);
	    ip6o->ip6_flow |= htonl((u_int32_t) otos << 20);
	    break;
#endif /* INET6 */

	default:
	    DPRINTF(("ipe4_output(): unsupported protocol family %d\n",
		     tdb->tdb_dst.sa.sa_family));
	    m_freem(m);
	    *mp = NULL;
	    ip4stat.ip4s_family++;
	    return ENOBUFS;
    }

    ip4stat.ip4s_opackets++;

    *mp = m;

#ifdef INET
    if (tdb->tdb_dst.sa.sa_family == AF_INET)
    {
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  tdb->tdb_cur_bytes += m->m_pkthdr.len - sizeof(struct ip);

	ip4stat.ip4s_obytes += m->m_pkthdr.len - sizeof(struct ip);
    }
#endif /* INET */

#ifdef INET6
    if (tdb->tdb_dst.sa.sa_family == AF_INET6)
    {
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  tdb->tdb_cur_bytes += m->m_pkthdr.len - sizeof(struct ip6_hdr);

	ip4stat.ip4s_obytes += m->m_pkthdr.len - sizeof(struct ip6_hdr);
    }
#endif /* INET6 */

    return 0;
}

#ifdef IPSEC

int
ipe4_attach()
{
    return 0;
}

int
ipe4_init(struct tdb *tdbp, struct xformsw *xsp, struct ipsecinit *ii)
{
    tdbp->tdb_xform = xsp;
    return 0;
}

int
ipe4_zeroize(struct tdb *tdbp)
{
    return 0;
}

void
ipe4_input(struct mbuf *m, ...)
{
    /* This is a rather serious mistake, so no conditional printing */
    printf("ipe4_input(): should never be called\n");
    if (m)
      m_freem(m);
}
#endif	/* IPSEC */

int
ip4_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case IP4CTL_ALLOW:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip4_allow));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


1.48
log
@fix pullup and otos saving code for ip6
(ip4_input will be visited with IPv6 packet!  better change the func name...)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.47 2000/01/13 06:02:31 angelos Exp $	*/
@


1.47
log
@mbuf **, not mbuf * you twit...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.46 2000/01/13 05:03:45 angelos Exp $	*/
d150 14
a163 2
    /* Bring the IP(v4) header in the first mbuf, if not there already */
    if (m->m_len < sizeof(struct ip))
d165 1
a165 1
	if ((m = m_pullup(m, sizeof(struct ip))) == 0)
a168 1
	    m_freem(m);
d187 8
a194 1
    otos = ipo->ip_tos;
@


1.46
log
@Add an ip4_input6() for use with IPv6 (just a wrapper for
ip4_input()), add prototype, ifdef include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.45 2000/01/02 09:31:03 angelos Exp $	*/
d103 1
a103 1
ip4_input6(struct mbuf *m, int *offp, int proto)
d105 1
a105 1
    ip4_input(m, *offp);
@


1.45
log
@Fix ifdef IPSEC
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.44 1999/12/24 20:02:44 angelos Exp $	*/
d97 12
@


1.44
log
@Return EINVAL instead of ENOBUFS if the source address is not specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.43 1999/12/21 20:26:13 provos Exp $	*/
a358 1
#ifdef IPSEC
d567 2
@


1.43
log
@compile without INET6, okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.42 1999/12/21 09:00:52 itojun Exp $	*/
d393 1
a393 1
		return ENOBUFS;
@


1.42
log
@reuse encapsulate/decapsulate routine in ip_ip4.c from gif interface
(outer=IPv4 case).  tested with (inner=IPv6, outer=IPv4) case.

BUG ALERT: in_gif_output() assumes about ipe4_output()'s behavior too much.
I mean, "tdb" is configured with certain knowledge about ipe4_output()'s
behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.41 1999/12/09 20:38:35 angelos Exp $	*/
d122 1
d128 1
a128 1
    u_int8_t otos, itos;
d282 1
d298 1
d324 1
d330 1
@


1.41
log
@Use otos rather than writing directly to ip_tos in the IPv4 header
(bitfields can be a pain).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.40 1999/12/09 17:55:35 downsj Exp $	*/
d119 5
d126 4
a136 1
#ifdef MROUTING
d151 2
a152 1
    if (ipo->ip_v == IPVERSION)
d162 3
d177 12
d190 1
a190 1
    if (m->m_len < sizeof(struct ip))
d192 1
a192 1
	if ((m = m_pullup(m, sizeof(struct ip))) == 0)
d201 1
d210 12
a221 2
    if (ipo->ip_v != IPVERSION)
    {
d233 1
a233 2
    if (!ip4_allow && ((ipo->ip_p == IPPROTO_IPIP) ||
	 (ipo->ip_p == IPPROTO_IPV6)))
d241 15
d261 37
a297 17
	  for (ifa = ifp->if_addrlist.tqh_first;
	       ifa != 0;
	       ifa = ifa->ifa_list.tqe_next)
	  {
	      if (ifa->ifa_addr->sa_family != AF_INET)
		continue;

	      sin = (struct sockaddr_in *) ifa->ifa_addr;

	      if (sin->sin_addr.s_addr == ipo->ip_src.s_addr)
	      {
		  DPRINTF(("ip_input(): possible local address spoofing detected on packet from %s to %s (%s->%s)\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst)));
		  ip4stat.ip4s_spoof++;
		  m_freem(m);
		  return;
	      }
	  }
d301 2
a302 1
    ip4stat.ip4s_ibytes += m->m_pkthdr.len - iphlen;
d316 16
a331 1
    ifq = &ipintrq;
d338 3
a340 1
	ip4stat.ip4s_qfull++;
d348 1
a348 1
    schednetisr(NETISR_IP);
d386 2
d396 1
a432 1

d434 1
a434 1
	    if (tp == IPPROTO_IPV6)
d436 1
d440 2
a441 2
			   sizeof(u_int32_t), (caddr_t) &itos);
		itos = ntohl(itos) >> 20;
d447 6
d454 1
d468 2
d478 1
d485 2
a486 1
	    ip6o->ip6_vfc = IPV6_VERSION;
d502 1
d504 1
a504 2

	    if (tp == IPPROTO_IPV6)
d506 1
d510 2
a511 2
			   sizeof(u_int32_t), (caddr_t) &itos);
		itos = ntohl(itos) >> 20;
d515 6
d522 1
d532 1
@


1.40
log
@Move variable decls into the appropriate #ifdefs so GENERIC compiles...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.39 1999/12/09 09:10:05 angelos Exp $	*/
d272 1
a272 1
    u_int8_t tp;
a280 1
    u_int8_t otos;
d358 2
a359 1
	    ip_ecn_ingress(ECN_ALLOWED, &ipo->ip_tos, &itos);
@


1.39
log
@Couple of paranoid ifdefs...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.38 1999/12/09 09:07:54 angelos Exp $	*/
a271 1
    u_int8_t itos, otos;
d275 1
d281 1
@


1.38
log
@ip4e_output() can now generate any combination of IP{4,6}-in-IP{4,6}
tunnels.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.37 1999/12/09 04:00:07 angelos Exp $	*/
d343 3
a345 1
	    else
d356 1
d390 1
d400 3
a402 1
	    else
@


1.37
log
@Be more careful with IPv4 multicast (make sure it's IPv4), and remove
unnecessary include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.36 1999/12/09 03:52:37 angelos Exp $	*/
d67 1
d86 4
d99 1
a99 1
 * ip4_input gets called when we receive an encapsulated packet,
a171 1
	    m_freem(m);
d188 1
a188 1
	ip4stat.ip4s_notip4++;
d272 2
a273 2
    struct ip *ipo, *ipi;
    ushort ilen;
d275 3
a277 8
    /* Check that the source address, if present, is from AF_INET */
    if ((tdb->tdb_src.sa.sa_family != 0) &&
	(tdb->tdb_src.sa.sa_family != AF_INET))
    {
	DPRINTF(("ipe4_output(): IP in protocol-family <%d> attempted, aborting", tdb->tdb_src.sa.sa_family));
	m_freem(m);
	return EINVAL;
    }
d279 139
a417 6
    /* Check that the destination address are AF_INET */
    if (tdb->tdb_dst.sa.sa_family != AF_INET)
    {
	DPRINTF(("ipe4_output(): IP in protocol-family <%d> attempted, aborting", tdb->tdb_dst.sa.sa_family));
	m_freem(m);
	return EINVAL;
a420 2
    ipi = mtod(m, struct ip *);
    ilen = ntohs(ipi->ip_len);
d422 4
a425 2
    M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
    if (m == 0)
d427 4
a430 2
	DPRINTF(("ipe4_output(): M_PREPEND failed\n"));
      	return ENOBUFS;
d432 1
d434 5
a438 1
    ipo = mtod(m, struct ip *);
d440 3
a442 22
    ipo->ip_v = IPVERSION;
    ipo->ip_hl = 5;
    ipo->ip_tos = ipi->ip_tos;
    ipo->ip_len = htons(ilen + sizeof(struct ip));
    ipo->ip_ttl = ip_defttl;
    ipo->ip_p = IPPROTO_IPIP;
    ipo->ip_id = ip_randomid();
    HTONS(ipo->ip_id);

    /* We should be keeping tunnel soft-state and send back ICMPs if needed. */
    ipo->ip_off = ipi->ip_off & ~(IP_DF | IP_MF | IP_OFFMASK);

    ipo->ip_sum = 0;

    ipo->ip_src = tdb->tdb_src.sin.sin_addr;
    ipo->ip_dst = tdb->tdb_dst.sin.sin_addr;

    *mp = m;

    /* Update the counters */
    if (tdb->tdb_xform->xf_type == XF_IP4)
      tdb->tdb_cur_bytes += ntohs(ipo->ip_len) - (ipo->ip_hl << 2);
a443 1
    ip4stat.ip4s_obytes += ntohs(ipo->ip_len) - (ipo->ip_hl << 2);
@


1.36
log
@ip4_input() can now handle either of IP-in-IP or IP-in-IPv6
encapsulation. Eventually, this routine will be made to deal with all
4 combinations of IP/IPv6 encapsulation.

gif interface support should be added here too (itojun :-), when the
packet has not been received over an IPsec tunnel. ECN handling should
also be done.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.35 1999/12/08 06:05:32 itojun Exp $	*/
a71 7
#ifdef INET6
#include <netinet6/in6.h>
#include <netinet6/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/icmp6.h>
#endif /* INET6 */

a123 2
    /* XXX Make v6 compliant */

d137 2
a138 1
    if (IN_MULTICAST(((struct ip *)((char *)ipo + iphlen))->ip_dst.s_addr))
d140 5
a144 2
	ipip_input (m, iphlen);
	return;
@


1.35
log
@fix field name (ip6_hdr->ip6_src).  use IN6_ARE_ADDR_EQUAL for comparison.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.34 1999/12/06 07:14:36 angelos Exp $	*/
d120 1
a120 1
    struct ip *ipo, *ipi;
a123 5
#ifdef INET6
    register struct sockaddr_in6 *sin6;
    struct ip6_hdr *ipv6;
#endif /* INET6 */

d131 14
d162 2
a163 16
    /*
     * Strip IP options, if any.
     */
    if (iphlen > sizeof(struct ip))
    {
	ip_stripoptions(m, (struct mbuf *) 0);
	iphlen = sizeof(struct ip);
    }
	
    /*
     * Make sure next IP header is in the first mbuf.
     *
     * Careful here! we are receiving the packet from ipintr;
     * this means that the ip_len field has been adjusted to
     * not count the ip header, and is also in host order.
     */
d165 2
a166 3
    ipo = mtod(m, struct ip *);

    if (m->m_len < iphlen + sizeof(struct ip))
d168 1
a168 1
	if ((m = m_pullup(m, iphlen + sizeof(struct ip))) == 0)
d175 1
d177 1
a177 2
	ipo = mtod(m, struct ip *);
    }
d185 2
a186 1
    if (ipo->ip_p == IPPROTO_IPIP)
d188 5
a192 1
	ipi = (struct ip *) ((caddr_t) ipo + iphlen);
d194 4
a197 12
	if (ipi->ip_v != IPVERSION)
	{
	    DPRINTF(("ip4_input(): wrong version %d on packet from %s to %s (%s->%s)\n", ipi->ip_v, inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipi->ip_src), inet_ntoa4(ipi->ip_dst)));
	    ip4stat.ip4s_notip4++;
	    m_freem(m);
	    return;
	}

	/*
	 * If we do not accept IP4 other than as part of ESP & AH, we should
	 * not accept a packet with double ip4 headers neither.
	 */
d199 2
a200 13
	if (!ip4_allow &&
	    ((ipi->ip_p == IPPROTO_IPIP) ||
	     (ipi->ip_p == IPPROTO_IPV6)))
	{
	    DPRINTF(("ip4_input(): dropped due to policy\n"));
	    ip4stat.ip4s_pdrops++;
	    m_freem(m);
	    return;
	}
    }

#ifdef INET6
    if (ipo->ip_p == IPPROTO_IPIP)
d202 4
a205 11
	ipv6 = (struct ip6_hdr *) ((caddr_t) ipo + iphlen);

	if (ipv6->ip6_vfc != IPV6_VERSION)
	{
	    DPRINTF(("ip4_input(): wrong version %d on packet from %s to %s (%s->%s)\n", ipi->ip_v, inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet6_ntoa4(ipv6->ip6_src), inet6_ntoa4(ipv6->ip6_dst)));
	    ip4stat.ip4s_notip4++;
	    m_freem(m);
	    return;
	}

	/* XXX Do we need to check that we don't have double-headers ? */
a206 5
#endif /* INET6 */

    /*
     * Check remote packets for local address spoofing.
     */
d208 1
d217 2
a218 15
	      switch (ipo->ip_p)
	      {
		  case IPPROTO_IPIP:
		      if (ifa->ifa_addr->sa_family != AF_INET)
			continue;

		      sin = (struct sockaddr_in *) ifa->ifa_addr;

		      if (sin->sin_addr.s_addr == ipi->ip_src.s_addr)
		      {
			  DPRINTF(("ip_input(): possible local address spoofing detected on packet from %s to %s (%s->%s)\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipi->ip_src), inet_ntoa4(ipi->ip_dst)));
			  ip4stat.ip4s_spoof++;
			  m_freem(m);
			  return;
		      }
d220 1
a220 1
		      break;
d222 6
a227 17
#ifdef INET6
		  case IPPROTO_IPV6:
		      if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		      sin6 = (struct sockaddr_in6 *) ifa->ifa_addr;

		      if (IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr, &ipv6->ip6_src))
		      {
			  DPRINTF(("ip_input(): possible local address spoofing detected on packet from %s to %s (%s->%s)\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet6_ntoa4(ipv6->ip6_src), inet6_ntoa4(ipv6->ip6_dst)));
			  ip4stat.ip4s_spoof++;
			  m_freem(m);
			  return;
		      }

		      break;
#endif /* INET6 */
a228 1
	      
a234 17
    /* Determine whether we need to queue in IPv4 or IPv6 input queue */
    ifq = &ipintrq;

#ifdef INET6
    if (ipo->ip_p == IPPROTO_IPV6)
      ifq = &ip6intrq;
#endif

    /*
     * Interface pointer is already in first mbuf; chop off the 
     * `outer' header and reschedule.
     */

    m->m_len -= iphlen;
    m->m_pkthdr.len -= iphlen;
    m->m_data += iphlen;

d237 1
a237 1
	m->m_pkthdr.tdbi = NULL;
d247 2
d262 2
a264 9
    if (ifq == &ipintrq)
      schednetisr(NETISR_IP);

#ifdef INET6
    if (ifq == &ip6intrq)
      schednetisr(NETISR_IPV6);
#endif /* INET6 */

    splx(s);
@


1.34
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.33 1999/10/29 02:02:33 angelos Exp $	*/
a74 1
#include <netinet6/in6_pcb.h>
d273 1
a273 2
		      if (!bcmp(&sin6->sin6_addr, &ipv6->sin6_addr,
				sizeof(struct in6_addr)))
d339 1
a339 1
      schednetisr(NETISR_IP6);
@


1.33
log
@Remove unnecessary argument from ipe4_output() and etherip_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.32 1999/10/29 01:50:34 angelos Exp $	*/
d72 8
d117 1
d120 1
a120 2
    register struct sockaddr_in *sin;
    int iphlen;
d122 1
a122 2
    struct ifqueue *ifq = NULL;
    int s;
d125 5
a185 2
    ipi = (struct ip *) ((caddr_t) ipo + iphlen);

d192 1
a192 1
    if (ipi->ip_v != IPVERSION)
d194 24
a217 4
	DPRINTF(("ip4_input(): wrong version %d on packet from %s to %s (%s->%s)\n", ipi->ip_v, inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipi->ip_src), inet_ntoa4(ipi->ip_dst)));
	ip4stat.ip4s_notip4++;
	m_freem(m);
	return;
d220 2
a221 6
    /*
     * If we do not accept IP4 other than part of ESP & AH, we should
     * not accept a packet with double ip4 headers neither.
     */
 
    if (!ip4_allow && ipi->ip_p == IPPROTO_IPIP)
d223 11
a233 4
 	DPRINTF(("ip4_input(): dropped due to policy\n"));
 	ip4stat.ip4s_pdrops++;
 	m_freem(m);
 	return;
d235 1
d249 33
a281 4
	      if (ifa->ifa_addr->sa_family != AF_INET)
		continue;

	      sin = (struct sockaddr_in *) ifa->ifa_addr;
d283 2
a284 6
	      if (sin->sin_addr.s_addr == ipi->ip_src.s_addr)
	      {
		  DPRINTF(("ip_input(): possible local address spoofing detected on packet from %s to %s (%s->%s)\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipi->ip_src), inet_ntoa4(ipi->ip_dst)));
		  ip4stat.ip4s_spoof++;
		  m_freem(m);
		  return;
d286 1
d291 9
a299 1
    ip4stat.ip4s_ibytes += ntohs(ipi->ip_len);
d310 1
a310 1
    /* tdbi is only set in esp or ah, if next protocol is udp or tcp */
a321 2
    ifq = &ipintrq;

d335 9
a343 1
    schednetisr(NETISR_IP);
d350 2
a351 1
ipe4_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp)
@


1.32
log
@Fix some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.31 1999/05/16 22:31:40 niklas Exp $	*/
d276 1
a276 2
ipe4_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb, 
	    struct mbuf **mp)
@


1.31
log
@Don't judge locally generated tunnel packets as spoof attempts.  indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.30 1999/05/12 23:18:35 niklas Exp $	*/
d97 1
a97 1
 * contain the address of the encapX interface associated with the tunnel.
d249 1
a249 1
     * interface. Otherwise, it'll point to an encap interface, which
d291 1
a291 1
    /* Check that the destination address is AF_INET */
d311 1
a311 1
	
d321 1
a321 4
    /*
     * XXX We should be keeping tunnel soft-state and send back ICMPs
     * if needed
     */
@


1.30
log
@Obvious pasto
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.29 1999/04/20 20:06:11 niklas Exp $	*/
d87 1
a87 1
 * net.inet.ip4.allow value.  Zero means drop them, all ilse is acceptance.
d90 1
d190 4
a193 4
     /*
      * If we do not accept IP4 other than part of ESP & AH, we should
      * not accept a packet with double ip4 headers neither.
      */
d195 2
a196 2
     if (!ip4_allow && ipi->ip_p == IPPROTO_IPIP)
     {
d201 2
a202 2
     }
 
d204 1
a204 1
     * Check for local address spoofing.
a205 7
    for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
      for (ifa = ifp->if_addrlist.tqh_first;
	   ifa != 0;
	   ifa = ifa->ifa_list.tqe_next)
      {
	  if (ifa->ifa_addr->sa_family != AF_INET)
	    continue;
d207 12
a218 1
	  sin = (struct sockaddr_in *) ifa->ifa_addr;
d220 7
a226 6
	  if (sin->sin_addr.s_addr == ipi->ip_src.s_addr)
	  {
	      DPRINTF(("ip_input(): possible local address spoofing detected on packet from %s to %s (%s->%s)\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipi->ip_src), inet_ntoa4(ipi->ip_dst)));
 	      ip4stat.ip4s_spoof++;
	      m_freem(m);
	      return;
d228 1
a228 1
      }
@


1.29
log
@Merge MROUTING and IPSEC wrt handling of IP-in-IP tunnelled packets.
Fix a panic case in the MROUTING code too.  Drop M_TUNNEL support, nothing
ever uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.28 1999/04/09 23:28:45 niklas Exp $	*/
d286 1
a286 1
    if (tdb->tdb_src.sa.sa_family != AF_INET)
@


1.28
log
@The kernel parts of a sysctl that can switch on/off IP-in-IP (protocol 4)
support, when IPSEC is compiled in.  The default is disabled.  Turn on with:
sysctl -w net.inet.ip4.allow=1
***Only*** do this if you are really knowing what you do!
This control does not control the tunnel modes of ESP and AH.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.27 1999/04/09 19:42:09 angelos Exp $	*/
d68 4
d123 9
d268 1
d363 1
@


1.27
log
@Check for local address spoofing on encapsulated packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.26 1999/04/04 21:33:49 deraadt Exp $	*/
d53 1
d82 7
d119 9
d153 1
d176 13
d205 1
d348 22
@


1.26
log
@fix tunnelling; provos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.25 1999/02/25 19:21:09 angelos Exp $	*/
d96 3
a142 1
    ip4stat.ip4s_ibytes += ntohs(ipi->ip_len);
d154 1
d157 25
a181 1
	
@


1.25
log
@Clear the DF bit, so packets don't get dropped inside a tunnel.
The real solution is probably to keep soft state; however, it's not
entirely clear what a tunnel's properties with regards to
fragmentation are (it may be considered a infinitely-large MTU pipe).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.24 1999/02/24 23:45:51 angelos Exp $	*/
d163 4
@


1.24
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.23 1999/02/24 22:33:04 angelos Exp $	*/
a112 1
	DPRINTF(("ip4_input(): stripping options\n"));
d233 2
d237 7
a243 3
    ipo->ip_off = ipi->ip_off & ~(IP_MF | IP_OFFMASK); /* XXX keep C and DF */
    ipo->ip_ttl = ip_defttl;
    ipo->ip_p = IPPROTO_IPIP;
@


1.23
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.22 1999/01/08 21:51:21 provos Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
@


1.22
log
@dont call ip_randomid() in htons().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.21 1998/12/26 12:35:11 provos Exp $	*/
a66 1
#include <net/encap.h>
a70 1
#include <sys/syslog.h>
d72 5
d111 1
a111 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ip4_input(): stripping options\n");
#endif /* ENCDEBUG */

d130 1
a130 5
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("ip4_input(): m_pullup() failed\n");
#endif /* ENCDEBUG */

d149 1
a149 2
	if (encdebug)
	  log(LOG_WARNING, "ip4_input(): wrong version %d on IP packet from %x to %x (%x->%x)\n", ipi->ip_v, ipo->ip_src, ipo->ip_dst, ipi->ip_src, ipi->ip_dst);
a161 1
    m->m_flags |= M_TUNNEL;
d180 2
a181 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ip4_input(): packet dropped because of full queue\n");
#endif /* ENCDEBUG */
d198 17
d222 1
a222 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ipe4_output(): M_PREPEND failed\n");
#endif /* ENCDEBUG */
d234 2
a235 10
    ipo->ip_off = ipi->ip_off & ~(IP_MF | IP_OFFMASK); /* keep C and DF */

    if (tdb->tdb_flags & TDBF_SAME_TTL)
      ipo->ip_ttl = ipi->ip_ttl;
    else
      if (tdb->tdb_ttl == 0)
        ipo->ip_ttl = ip_defttl;
      else
        ipo->ip_ttl = tdb->tdb_ttl;
	
a237 2
    ipo->ip_src = tdb->tdb_osrc;
    ipo->ip_dst = tdb->tdb_odst;
d239 2
a240 8
/* 
 *  printf("ip4_output: [%x->%x](l=%d, p=%d)", 
 *  	   ntohl(ipi->ip_src.s_addr), ntohl(ipi->ip_dst.s_addr),
 *	   ilen, ipi->ip_p);
 *  printf(" through [%x->%x](l=%d, p=%d)\n", 
 *	   ntohl(ipo->ip_src.s_addr), ntohl(ipo->ip_dst.s_addr),
 *	   ipo->ip_len, ipo->ip_p);
 */
d246 1
a246 4
    {
	tdb->tdb_cur_packets++;
	tdb->tdb_cur_bytes += ntohs(ipo->ip_len) - (ipo->ip_hl << 2);
    }
a248 1

a249 2

/*  return ip_output(m, NULL, NULL, IP_ENCAPSULATED, NULL); */
a254 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("ipe4_attach(): setting up\n");
#endif /* ENCDEBUG */
d259 1
a259 1
ipe4_init(struct tdb *tdbp, struct xformsw *xsp, struct mbuf *m)
a260 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("ipe4_init(): setting up\n");
#endif /* ENCDEBUG */
a267 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("ipe4_zeroize(): nothing to do really...\n");
#endif /* ENCDEBUG */
d275 1
a275 1
    log(LOG_ALERT, "ipe4_input(): should never be called\n");
@


1.21
log
@make ip_id random but ensure that ids dont repeat for some period.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.20 1998/07/29 22:18:49 angelos Exp $	*/
d227 2
a228 1
    ipo->ip_id = htons(ip_randomid());
@


1.20
log
@Proper handling of IP in IP and checksumming.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.19 1998/06/10 23:57:12 provos Exp $	*/
d227 1
a227 2
/*  ipo->ip_id = htons(ip_id++); */
    get_random_bytes((void *) &(ipo->ip_id), sizeof(ipo->ip_id));
@


1.19
log
@make the packets which were successfully processed by IPSec available to
bpf via the enc0 interface, using linktype DLT_ENC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.18 1998/05/22 07:29:20 angelos Exp $	*/
a143 1

a167 1
	
a196 1
	
d243 1
a243 1
	
@


1.18
log
@Set the outter IP header's ttl, not the inner.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.17 1998/05/18 21:10:51 provos Exp $	*/
d170 2
@


1.17
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.16 1998/03/18 10:51:36 provos Exp $	*/
d238 1
a238 1
        ipi->ip_ttl = tdb->tdb_ttl;
@


1.16
log
@adapt function arguments to get the expected prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.15 1997/11/04 09:11:14 provos Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
@


1.15
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.14 1997/10/02 02:31:05 deraadt Exp $	*/
a67 1
void	ip4_input __P((struct mbuf *, int));
d77 7
a83 1
ip4_input(register struct mbuf *m, int iphlen)
d85 1
d89 5
@


1.14
log
@conditional error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.13 1997/09/28 23:09:57 deraadt Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
@


1.13
log
@more \n in log()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.12 1997/07/14 08:48:47 provos Exp $	*/
d134 2
a135 3
	log(LOG_WARNING,
	    "ip4_input(): wrong version %d on IP packet from %x to %x (%x->%x)\n",
	    ipi->ip_v, ipo->ip_src, ipo->ip_dst, ipi->ip_src, ipi->ip_dst);
d283 1
@


1.12
log
@global byte counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.11 1997/07/11 23:37:58 provos Exp $	*/
d135 1
a135 1
	    "ip4_input(): wrong version %d on IP packet from %x to %x (%x->%x)",
d284 1
a284 1
    log(LOG_ALERT, "ipe4_input(): should never be called");
@


1.11
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.10 1997/07/01 22:12:49 provos Exp $	*/
d123 3
a125 1
	
d242 2
@


1.10
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.9 1997/06/25 07:53:27 provos Exp $	*/
d62 1
d85 1
a85 1
    if (iphlen > sizeof (struct ip))
d87 7
a93 2
	ip_stripoptions(m, (struct mbuf *)0);
	iphlen = sizeof (struct ip);
d106 1
a106 1
    if (m->m_len < iphlen + sizeof (struct ip))
d108 1
a108 1
	if ((m = m_pullup(m, iphlen + sizeof (struct ip))) == 0)
d110 5
d118 1
d121 2
a122 1
    ipi = (struct ip *)((caddr_t)ipo + iphlen);
d126 2
a127 1
     * decapsulation.
d132 3
d165 4
d171 1
d190 1
a190 1
    M_PREPEND(m, sizeof (struct ip), M_DONTWAIT);
d192 7
a198 1
      return ENOBUFS;
d205 3
a207 3
    ipo->ip_len = htons(ilen + sizeof (struct ip));
    /* ipo->ip_id = htons(ip_id++); */
    get_random_bytes((void *)&(ipo->ip_id), sizeof(ipo->ip_id));
d243 1
a243 1
/*	return ip_output(m, NULL, NULL, IP_ENCAPSULATED, NULL);*/
d249 4
d261 2
a262 2
      printf("ipe4_init: setting up\n");
#endif
d270 4
a276 2


d280 1
a280 1
    printf("ipe4_input: should never be called\n");
@


1.9
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.8 1997/06/24 12:15:25 provos Exp $	*/
d158 2
a159 1
ipe4_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb, struct mbuf **mp)
a161 1
    struct ip4_xdata *xd;
d181 8
a188 12
    xd = (struct ip4_xdata *)tdb->tdb_xdata;
    switch (xd->ip4_ttl)
    {
	case IP4_SAME_TTL:
	    ipo->ip_ttl = ipi->ip_ttl;
	    break;
	case IP4_DEFAULT_TTL:
	    ipo->ip_ttl = ip_defttl;
	    break;
	default:
	    ipo->ip_ttl = xd->ip4_ttl;
    }
d192 2
a193 2
    ipo->ip_src = gw->sen_ipsp_src;
    ipo->ip_dst = gw->sen_ipsp_dst;
d207 5
a211 2
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ntohs(ipo->ip_len) - (ipo->ip_hl << 2);
a226 4
    struct ip4_xdata *xd;
    struct ip4_xencap txd;
    struct encap_msghdr *em;
	
a231 17
    MALLOC(tdbp->tdb_xdata, caddr_t, sizeof (struct ip4_xdata), M_XDATA,
	   M_WAITOK);
    if (tdbp->tdb_xdata == NULL)
      return ENOBUFS;
    bzero(tdbp->tdb_xdata, sizeof (struct ip4_xdata));
    xd = (struct ip4_xdata *)tdbp->tdb_xdata;
	
    em = mtod(m, struct encap_msghdr *);
    if (em->em_msglen - EMT_SETSPI_FLEN > sizeof (struct ip4_xencap))
    {
	free((caddr_t)tdbp->tdb_xdata, M_XDATA);
	tdbp->tdb_xdata = NULL;
	return EINVAL;
    }
    m_copydata(m, EMT_SETSPI_FLEN, em->em_msglen - EMT_SETSPI_FLEN,
	       (caddr_t)&txd);
    xd->ip4_ttl = txd.ip4_ttl;
a237 1
    FREE(tdbp->tdb_xdata, M_XDATA);
@


1.8
log
@handle IP options in AH + allow IP options in outgoing encapsulated packets
+ usage counters for later use with keymanagement processes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.7 1997/06/24 02:20:23 angelos Exp $	*/
d211 2
a212 2
    tdb->tdb_packets++;
    tdb->tdb_bytes += ntohs(ipo->ip_len) - (ipo->ip_hl << 2);
@


1.7
log
@Comment reordering.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.6 1997/06/20 05:41:52 provos Exp $	*/
d199 8
a206 6
/*	printf("ip4_output: [%x->%x](l=%d, p=%d)", 
	ntohl(ipi->ip_src.s_addr), ntohl(ipi->ip_dst.s_addr),
	ilen, ipi->ip_p);
	printf(" through [%x->%x](l=%d, p=%d)\n", 
	ntohl(ipo->ip_src.s_addr), ntohl(ipo->ip_dst.s_addr),
	ipo->ip_len, ipo->ip_p);*/
d209 5
@


1.6
log
@ah-sha1 + esp-3des + indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.5 1997/02/26 03:01:04 angelos Exp $	*/
d78 3
a83 2

    ip4stat.ip4s_ipackets++;
@


1.5
log
@I/O packet counters for IP-in-IP and AH.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ip4.c,v 1.4 1997/02/24 14:06:41 niklas Exp $	*/
d75 27
a101 9
	struct ip *ipo, *ipi;
	struct ifqueue *ifq = NULL;
	int s;
	/*
	 * Strip IP options, if any.
	 */

	ip4stat.ip4s_ipackets++;
	if (iphlen > sizeof (struct ip))
d103 2
a104 2
		ip_stripoptions(m, (struct mbuf *)0);
		iphlen = sizeof (struct ip);
a105 9
	
	/*
	 * Make sure next IP header is in the first mbuf.
	 *
	 * Careful here! we are receiving the packet from ipintr;
	 * this means that the ip_len field has been adjusted to
	 * not count the ip header, and is also in host order.
	 */

d107 2
a108 11

	if (m->m_len < iphlen + sizeof (struct ip))
	{
		if ((m = m_pullup(m, iphlen + sizeof (struct ip))) == 0)
		{
			ip4stat.ip4s_hdrops++;
			return;
		}
		ipo = mtod(m, struct ip *);
	}
	ipi = (struct ip *)((caddr_t)ipo + iphlen);
d110 10
a119 10
	/*
	 * RFC 1853 specifies that the inner TTL should not be touched on
	 * decapsulation.
	 */

	if (ipi->ip_v != IPVERSION)
	{
		ip4stat.ip4s_notip4++;
		return;
	}
d121 8
a128 8
	/*
	 * Interface pointer is already in first mbuf; chop off the 
	 * `outer' header and reschedule.
	 */

	m->m_len -= iphlen;
	m->m_pkthdr.len -= iphlen;
	m->m_data += iphlen;
d130 16
a145 21
	/*
	 * Interface pointer stays the same; if no IPsec processing has
	 * been done (or will be done), this will point to a normal 
  	 * interface. Otherwise, it'll point to an encap interface, which
 	 * will allow a packet filter to distinguish between secure and
	 * untrusted packets.
 	 */

	ifq = &ipintrq;

	s = splimp();			/* isn't it already? */
	if (IF_QFULL(ifq))
	{
		IF_DROP(ifq);
		m_freem(m);
		ip4stat.ip4s_qfull++;
		splx(s);
		return;
	}
	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IP);
d147 5
d153 1
a153 1
	return;
d159 11
a169 11
	struct ip *ipo, *ipi;
	struct ip4_xdata *xd;
	ushort ilen;

	ip4stat.ip4s_opackets++;
	ipi = mtod(m, struct ip *);
	ilen = ntohs(ipi->ip_len);

	M_PREPEND(m, sizeof (struct ip), M_DONTWAIT);
	if (m == 0)
	  return ENOBUFS;
d171 1
a171 1
	ipo = mtod(m, struct ip *);
d173 19
a191 19
	ipo->ip_v = IPVERSION;
	ipo->ip_hl = 5;
	ipo->ip_tos = ipi->ip_tos;
	ipo->ip_len = htons(ilen + sizeof (struct ip));
	/* ipo->ip_id = htons(ip_id++); */
	get_random_bytes((void *)&(ipo->ip_id), sizeof(ipo->ip_id));
	ipo->ip_off = ipi->ip_off & ~(IP_MF | IP_OFFMASK); /* keep C and DF */
	xd = (struct ip4_xdata *)tdb->tdb_xdata;
	switch (xd->ip4_ttl)
	{
	    case IP4_SAME_TTL:
		ipo->ip_ttl = ipi->ip_ttl;
		break;
	    case IP4_DEFAULT_TTL:
		ipo->ip_ttl = ip_defttl;
		break;
	    default:
		ipo->ip_ttl = xd->ip4_ttl;
	}
d193 4
a196 4
	ipo->ip_p = IPPROTO_IPIP;
	ipo->ip_sum = 0;
	ipo->ip_src = gw->sen_ipsp_src;
	ipo->ip_dst = gw->sen_ipsp_dst;
d199 2
a200 2
	       ntohl(ipi->ip_src.s_addr), ntohl(ipi->ip_dst.s_addr),
	       ilen, ipi->ip_p);
d202 2
a203 2
	       ntohl(ipo->ip_src.s_addr), ntohl(ipo->ip_dst.s_addr),
	       ipo->ip_len, ipo->ip_p);*/
d205 2
a206 2
	*mp = m;
	return 0;
d214 1
a214 1
	return 0;
d220 3
a222 3
        struct ip4_xdata *xd;
	struct ip4_xencap txd;
	struct encap_msghdr *em;
d225 2
a226 2
        if (encdebug)
	  printf("ipe4_init: setting up\n");
d228 7
a234 7
	tdbp->tdb_xform = xsp;
	MALLOC(tdbp->tdb_xdata, caddr_t, sizeof (struct ip4_xdata), M_XDATA,
	       M_WAITOK);
	if (tdbp->tdb_xdata == NULL)
	  return ENOBUFS;
	bzero(tdbp->tdb_xdata, sizeof (struct ip4_xdata));
	xd = (struct ip4_xdata *)tdbp->tdb_xdata;
d236 11
a246 11
	em = mtod(m, struct encap_msghdr *);
	if (em->em_msglen - EMT_SETSPI_FLEN > sizeof (struct ip4_xencap))
	{
	    free((caddr_t)tdbp->tdb_xdata, M_XDATA);
	    tdbp->tdb_xdata = NULL;
	    return EINVAL;
	}
	m_copydata(m, EMT_SETSPI_FLEN, em->em_msglen - EMT_SETSPI_FLEN,
		   (caddr_t)&txd);
	xd->ip4_ttl = txd.ip4_ttl;
	return 0;
d252 2
a253 2
        FREE(tdbp->tdb_xdata, M_XDATA);
	return 0;
d261 3
a263 3
	printf("ipe4_input: should never be called\n");
	if (m)
	  m_freem(m);
@


1.4
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 1
d163 1
@


1.3
log
@Resolved a couple of open issues (just changed comments after checking
RFCs).
@
text
@d1 2
d63 1
a63 1

@


1.2
log
@User-defined TTL for external IP header.
@
text
@d108 2
a109 3
	 * XXX - Should we do anything to the inner packet?
	 * Does arriving at the far end of the tunnel count as one hop
	 * (thus requiring ipi->ip_ttl to be decremented)?
d127 7
a133 3
	/* XXX -- interface pointer stays the same (which is probably
	 * the way it should be.
	 */
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d154 1
d173 13
a185 1
	ipo->ip_ttl = ipi->ip_ttl;	/* already decremented if fwding */
d213 8
a220 1
	printf("ipe4_init: setting up\n");
d222 17
a238 2
	if (m)
	  m_freem(m);
d245 1
a245 1
	/* Nothing much really - we don't need any state */
@

