head	1.28;
access;
symbols
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	UBC_SYNC_A:1.28
	UBC_SYNC_B:1.28
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	SMP:1.18.0.2
	SMP_BASE:1.18
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.4
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.28
date	2001.05.30.02.12.37;	author deraadt;	state dead;
branches;
next	1.27;

1.27
date	2001.04.07.01.06.28;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.30.04.23.56;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.17.07.25.19;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.17.04.47.16;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.10.05.50.26;	author kjell;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.05.24.21.59.11;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.01.06.16.47;	author kjell;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2000.03.13.23.40.18;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.16.22.34.20;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.01.19.29.59;	author kjell;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	99.12.28.09.43.33;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	99.12.28.08.20.40;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	99.12.17.07.50.06;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	99.12.15.05.20.23;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	99.02.05.05.58.54;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.09.15.09.51.19;	author pattonme;	state Exp;
branches;
next	1.11;

1.11
date	98.02.17.01.39.07;	author dgregor;	state Exp;
branches;
next	1.10;

1.10
date	98.01.26.04.10.46;	author dgregor;	state Exp;
branches;
next	1.9;

1.9
date	97.06.23.19.03.51;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.09.15.50.57;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.02.11.22.23.28;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.18.08.29.21;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.10.24.17.56.21;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.10.08.07.33.29;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.18.05.01.08;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.05.10.21.38.18;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.25.05.41.48;	author dm;	state Exp;
branches;
next	;

1.18.2.1
date	2000.02.20.11.57.29;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2000.03.24.09.09.38;	author niklas;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2001.05.14.22.40.13;	author niklas;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2001.07.04.10.55.00;	author niklas;	state dead;
branches;
next	;

1.21.2.1
date	2000.05.27.20.45.18;	author jason;	state Exp;
branches;
next	;

1.23.2.1
date	2001.04.18.01.02.45;	author jason;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ip_state.c,v 1.27 2001/04/07 01:06:28 fgsch Exp $	*/

/*
 * Copyright (C) 1995-2001 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#if !defined(lint)
static const char sccsid[] = "@@(#)ip_state.c	1.8 6/5/96 (C) 1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.30.2.30 2001/04/06 12:31:21 darrenr Exp $";
#endif

#include <sys/errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/file.h>
#if defined(__NetBSD__) && (NetBSD >= 199905) && !defined(IPFILTER_LKM) && \
    defined(_KERNEL)
# include "opt_ipfilter_log.h"
#endif
#if defined(_KERNEL) && defined(__FreeBSD_version) && \
    (__FreeBSD_version >= 400000) && !defined(KLD_MODULE)
#include "opt_inet6.h"
#endif
#if !defined(_KERNEL) && !defined(KERNEL) && !defined(__KERNEL__)
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
#else
# ifdef linux
#  include <linux/kernel.h>
#  include <linux/module.h>
# endif
#endif
#if (defined(KERNEL) || defined(_KERNEL)) && (__FreeBSD_version >= 220000)
# include <sys/filio.h>
# include <sys/fcntl.h>
# if (__FreeBSD_version >= 300000) && !defined(IPFILTER_LKM)
#  include "opt_ipfilter.h"
# endif
#else
# include <sys/ioctl.h>
#endif
#include <sys/time.h>
#include <sys/uio.h>
#ifndef linux
# include <sys/protosw.h>
#endif
#include <sys/socket.h>
#if (defined(_KERNEL) || defined(KERNEL)) && !defined(linux)
# include <sys/systm.h>
#endif
#if !defined(__SVR4) && !defined(__svr4__)
# ifndef linux
#  include <sys/mbuf.h>
# endif
#else
# include <sys/filio.h>
# include <sys/byteorder.h>
# ifdef _KERNEL
#  include <sys/dditypes.h>
# endif
# include <sys/stream.h>
# include <sys/kmem.h>
#endif

#include <net/if.h>
#ifdef sun
# include <net/af.h>
#endif
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#ifndef linux
# include <netinet/ip_var.h>
# include <netinet/tcp_fsm.h>
#endif
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_fil_compat.h>
#include <netinet/tcpip.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_frag.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_state.h>
#ifdef	USE_INET6
#include <netinet/icmp6.h>
#endif
#if (__FreeBSD_version >= 300000)
# include <sys/malloc.h>
# if (defined(_KERNEL) || defined(KERNEL)) && !defined(IPFILTER_LKM)
#  include <sys/libkern.h>
#  include <sys/systm.h>
# endif
#endif

#ifndef	MIN
# define	MIN(a,b)	(((a)<(b))?(a):(b))
#endif

#define	TCP_CLOSE	(TH_FIN|TH_RST)

static ipstate_t **ips_table = NULL;
static ipstate_t *ips_list = NULL;
static int	ips_num = 0;
static int	ips_wild = 0;
static ips_stat_t ips_stats;
#if	(SOLARIS || defined(__sgi)) && defined(_KERNEL)
extern	KRWLOCK_T	ipf_state, ipf_mutex;
extern	kmutex_t	ipf_rw;
#endif

#ifdef	USE_INET6
static frentry_t *fr_checkicmp6matchingstate __P((ip6_t *, fr_info_t *));
#endif
static int fr_matchsrcdst __P((ipstate_t *, union i6addr, union i6addr,
			       fr_info_t *, tcphdr_t *));
static frentry_t *fr_checkicmpmatchingstate __P((ip_t *, fr_info_t *));
static int fr_matchicmpqueryreply __P((int, ipstate_t *, icmphdr_t *));
static int fr_state_flush __P((int));
static ips_stat_t *fr_statetstats __P((void));
static void fr_delstate __P((ipstate_t *));
static int fr_state_remove __P((caddr_t));
static void fr_ipsmove __P((ipstate_t **, ipstate_t *, u_int));
int fr_stputent __P((caddr_t));
int fr_stgetent __P((caddr_t));
void fr_stinsert __P((ipstate_t *));


#define	FIVE_DAYS	(2 * 5 * 86400)	/* 5 days: half closed session */

#define	TCP_MSL	240			/* 2 minutes */
u_long	fr_tcpidletimeout = FIVE_DAYS,
	fr_tcpclosewait = 2 * TCP_MSL,
	fr_tcplastack = 2 * TCP_MSL,
	fr_tcptimeout = 2 * TCP_MSL,
	fr_tcpclosed = 120,
	fr_tcphalfclosed = 2 * 2 * 3600,    /* 2 hours */
	fr_udptimeout = 240,
	fr_udpacktimeout = 24,
	fr_icmptimeout = 120,
	fr_icmpacktimeout = 12;
int	fr_statemax = IPSTATE_MAX,
	fr_statesize = IPSTATE_SIZE;
int	fr_state_doflush = 0,
	fr_state_lock = 0;

static 	int icmpreplytype4[ICMP_MAXTYPE + 1];

int fr_stateinit()
{
	int i;

	KMALLOCS(ips_table, ipstate_t **, fr_statesize * sizeof(ipstate_t *));
	if (ips_table != NULL)
		bzero((char *)ips_table, fr_statesize * sizeof(ipstate_t *));
	else
		return -1;

	/* fill icmp reply type table */
	for (i = 0; i <= ICMP_MAXTYPE; i++)
		icmpreplytype4[i] = -1;
	icmpreplytype4[ICMP_ECHO] = ICMP_ECHOREPLY;
	icmpreplytype4[ICMP_TSTAMP] = ICMP_TSTAMPREPLY;
	icmpreplytype4[ICMP_IREQ] = ICMP_IREQREPLY;
	icmpreplytype4[ICMP_MASKREQ] = ICMP_MASKREPLY;

	return 0;
}


static ips_stat_t *fr_statetstats()
{
	ips_stats.iss_active = ips_num;
	ips_stats.iss_table = ips_table;
	ips_stats.iss_list = ips_list;
	return &ips_stats;
}


/*
 * flush state tables.  two actions currently defined:
 * which == 0 : flush all state table entries
 * which == 1 : flush TCP connections which have started to close but are
 *	        stuck for some reason.
 */
static int fr_state_flush(which)
int which;
{
	register ipstate_t *is, **isp;
#if defined(_KERNEL) && !SOLARIS
	int s;
#endif
	int delete, removed = 0;

	SPL_NET(s);
	for (isp = &ips_list; (is = *isp); ) {
		delete = 0;

		switch (which)
		{
		case 0 :
			delete = 1;
			break;
		case 1 :
			if (is->is_p != IPPROTO_TCP)
				break;
			if ((is->is_state[0] != TCPS_ESTABLISHED) ||
			    (is->is_state[1] != TCPS_ESTABLISHED))
				delete = 1;
			break;
		}

		if (delete) {
			if (is->is_p == IPPROTO_TCP)
				ips_stats.iss_fin++;
			else
				ips_stats.iss_expire++;
#ifdef	IPFILTER_LOG
			ipstate_log(is, ISL_FLUSH);
#endif
			fr_delstate(is);
			removed++;
		} else
			isp = &is->is_next;
	}
	SPL_X(s);
	return removed;
}


static int fr_state_remove(data)
caddr_t data;
{
	ipstate_t *sp, st;
	int error;

	sp = &st;
	error = IRCOPYPTR(data, (caddr_t)&st, sizeof(st));
	if (error)
		return EFAULT;

	for (sp = ips_list; sp; sp = sp->is_next)
		if ((sp->is_p == st.is_p) && (sp->is_v == st.is_v) &&
		    !bcmp((char *)&sp->is_src, (char *)&st.is_src,
			  sizeof(st.is_src)) &&
		    !bcmp((char *)&sp->is_dst, (char *)&st.is_src,
			  sizeof(st.is_dst)) &&
		    !bcmp((char *)&sp->is_ps, (char *)&st.is_ps,
			  sizeof(st.is_ps))) {
			WRITE_ENTER(&ipf_state);
#ifdef	IPFILTER_LOG
			ipstate_log(sp, ISL_REMOVE);
#endif
			fr_delstate(sp);
			RWLOCK_EXIT(&ipf_state);
			return 0;
		}
	return ESRCH;
}


int fr_state_ioctl(data, cmd, mode)
caddr_t data;
#if defined(__NetBSD__) || defined(__OpenBSD__)
u_long cmd;
#else
int cmd;
#endif
int mode;
{
	int arg, ret, error = 0;

	switch (cmd)
	{
	case SIOCDELST :
		error = fr_state_remove(data);
		break;
	case SIOCIPFFL :
		error = IRCOPY(data, (caddr_t)&arg, sizeof(arg));
		if (error)
			break;
		if (arg == 0 || arg == 1) {
			WRITE_ENTER(&ipf_state);
			ret = fr_state_flush(arg);
			RWLOCK_EXIT(&ipf_state);
			error = IWCOPY((caddr_t)&ret, data, sizeof(ret));
		} else
			error = EINVAL;
		break;
#ifdef	IPFILTER_LOG
	case SIOCIPFFB :
		if (!(mode & FWRITE))
			error = EPERM;
		else {
			int tmp;

			tmp = ipflog_clear(IPL_LOGSTATE);
			IWCOPY((char *)&tmp, data, sizeof(tmp));
		}
		break;
#endif
	case SIOCGETFS :
		error = IWCOPYPTR((caddr_t)fr_statetstats(), data,
				  sizeof(ips_stat_t));
		break;
	case FIONREAD :
#ifdef	IPFILTER_LOG
		arg = (int)iplused[IPL_LOGSTATE];
		error = IWCOPY((caddr_t)&arg, (caddr_t)data, sizeof(arg));
#endif
		break;
	case SIOCSTLCK :
		error = fr_lock(data, &fr_state_lock);
		break;
	case SIOCSTPUT :
		if (!fr_state_lock) {
			error = EACCES;
			break;
		}
		error = fr_stputent(data);
		break;
	case SIOCSTGET :
		if (!fr_state_lock) {
			error = EACCES;
			break;
		}
		error = fr_stgetent(data);
		break;
	default :
		error = EINVAL;
		break;
	}
	return error;
}


int fr_stgetent(data)
caddr_t data;
{
	register ipstate_t *is, *isn;
	ipstate_save_t ips, *ipsp;
	int error;

	error = IRCOPY(data, (caddr_t)&ipsp, sizeof(ipsp));
	if (error)
		return EFAULT;
	error = IRCOPY((caddr_t)ipsp, (caddr_t)&ips, sizeof(ips));
	if (error)
		return EFAULT;

	isn = ips.ips_next;
	if (!isn) {
		isn = ips_list;
		if (isn == NULL) {
			if (ips.ips_next == NULL)
				return ENOENT;
			return 0;
		}
	} else {
		/*
		 * Make sure the pointer we're copying from exists in the
		 * current list of entries.  Security precaution to prevent
		 * copying of random kernel data.
		 */
		for (is = ips_list; is; is = is->is_next)
			if (is == isn)
				break;
		if (!is)
			return ESRCH;
	}
	ips.ips_next = isn->is_next;
	bcopy((char *)isn, (char *)&ips.ips_is, sizeof(ips.ips_is));
	if (isn->is_rule)
		bcopy((char *)isn->is_rule, (char *)&ips.ips_fr,
		      sizeof(ips.ips_fr));
	error = IWCOPY((caddr_t)&ips, ipsp, sizeof(ips));
	if (error)
		error = EFAULT;
	return error;
}


int fr_stputent(data)
caddr_t data;
{
	register ipstate_t *is, *isn;
	ipstate_save_t ips, *ipsp;
	int error, out;
	frentry_t *fr;

	error = IRCOPY(data, (caddr_t)&ipsp, sizeof(ipsp));
	if (error)
		return EFAULT;
	error = IRCOPY((caddr_t)ipsp, (caddr_t)&ips, sizeof(ips));
	if (error)
		return EFAULT;

	KMALLOC(isn, ipstate_t *);
	if (isn == NULL)
		return ENOMEM;

	bcopy((char *)&ips.ips_is, (char *)isn, sizeof(*isn));
	fr = isn->is_rule;
	if (fr != NULL) {
		if (isn->is_flags & FI_NEWFR) {
			KMALLOC(fr, frentry_t *);
			if (fr == NULL) {
				KFREE(isn);
				return ENOMEM;
			}
			bcopy((char *)&ips.ips_fr, (char *)fr, sizeof(*fr));
			out = fr->fr_flags & FR_OUTQUE ? 1 : 0;
			isn->is_rule = fr;
			ips.ips_is.is_rule = fr;
			if (*fr->fr_ifname) {
				fr->fr_ifa = GETUNIT(fr->fr_ifname, fr->fr_v);
				if (fr->fr_ifa == NULL)
					fr->fr_ifa = (void *)-1;
#ifdef	_KERNEL
				else {
					strncpy(isn->is_ifname[out],
						IFNAME(fr->fr_ifa), IFNAMSIZ);
					isn->is_ifp[out] = fr->fr_ifa;
				}
#endif
			} else
				fr->fr_ifa = NULL;
			/*
			 * send a copy back to userland of what we ended up
			 * to allow for verification.
			 */
			error = IWCOPY((caddr_t)&ips, ipsp, sizeof(ips));
			if (error) {
				KFREE(isn);
				KFREE(fr);
				return EFAULT;
			}
		} else {
			for (is = ips_list; is; is = is->is_next)
				if (is->is_rule == fr)
					break;
			if (!is) {
				KFREE(isn);
				return ESRCH;
			}
		}
	}
	fr_stinsert(isn);
	return 0;
}


void fr_stinsert(is)
register ipstate_t *is;
{
	register u_int hv = is->is_hv;

	MUTEX_INIT(&is->is_lock, "ipf state entry", NULL);

	is->is_ifname[0][sizeof(is->is_ifname[0]) - 1] = '\0';
	if (is->is_ifname[0][0] != '\0') {
		is->is_ifp[0] = GETUNIT(is->is_ifname[0], is->is_v);
	}
	is->is_ifname[1][sizeof(is->is_ifname[0]) - 1] = '\0';
	if (is->is_ifname[1][0] != '\0') {
		is->is_ifp[1] = GETUNIT(is->is_ifname[1], is->is_v);
	}

	/*
	 * add into list table.
	 */
	if (ips_list)
		ips_list->is_pnext = &is->is_next;
	is->is_pnext = &ips_list;
	is->is_next = ips_list;
	ips_list = is;
	if (ips_table[hv])
		ips_table[hv]->is_phnext = &is->is_hnext;
	else
		ips_stats.iss_inuse++;
	is->is_phnext = ips_table + hv;
	is->is_hnext = ips_table[hv];
	ips_table[hv] = is;
	ips_num++;
}


/*
 * Create a new ipstate structure and hang it off the hash table.
 */
ipstate_t *fr_addstate(ip, fin, flags)
ip_t *ip;
fr_info_t *fin;
u_int flags;
{
	register tcphdr_t *tcp = NULL;
	register ipstate_t *is;
	register u_int hv;
	ipstate_t ips;
	u_int pass;
	int out;

	if (fr_state_lock || (fin->fin_off & IP_OFFMASK) ||
	    (fin->fin_fi.fi_fl & FI_SHORT))
		return NULL;
	if (ips_num == fr_statemax) {
		ips_stats.iss_max++;
		fr_state_doflush = 1;
		return NULL;
	}
	out = fin->fin_out;
	is = &ips;
	bzero((char *)is, sizeof(*is));
	ips.is_age = 1;
	ips.is_state[0] = 0;
	ips.is_state[1] = 0;
	/*
	 * Copy and calculate...
	 */
	hv = (is->is_p = fin->fin_fi.fi_p);
	is->is_src = fin->fin_fi.fi_src;
	hv += is->is_saddr;
	is->is_dst = fin->fin_fi.fi_dst;
	hv += is->is_daddr;
#ifdef	USE_INET6
	if (fin->fin_v == 6) {
		if (is->is_p == IPPROTO_ICMPV6) {
			if (IN6_IS_ADDR_MULTICAST(&is->is_dst.in6))
				flags |= FI_W_DADDR;
			if (out)
				hv -= is->is_daddr;
			else
				hv -= is->is_saddr;
		}
	}
#endif

	switch (is->is_p)
	{
#ifdef	USE_INET6
	case IPPROTO_ICMPV6 :
#endif
	case IPPROTO_ICMP :
	    {
		struct icmp *ic = (struct icmp *)fin->fin_dp;

#ifdef	USE_INET6
		if ((is->is_p == IPPROTO_ICMPV6) &&
		    ((ic->icmp_type & ICMP6_INFOMSG_MASK) == 0))
			return NULL;
#endif
		switch (ic->icmp_type)
		{
#ifdef	USE_INET6
		case ICMP6_ECHO_REQUEST :
			is->is_icmp.ics_type = ICMP6_ECHO_REPLY;
			hv += (is->is_icmp.ics_id = ic->icmp_id);
			hv += (is->is_icmp.ics_seq = ic->icmp_seq);
			break;
		case ICMP6_MEMBERSHIP_QUERY :
		case ND_ROUTER_SOLICIT :
		case ND_NEIGHBOR_SOLICIT :
			is->is_icmp.ics_type = ic->icmp_type + 1;
			break;
#endif
		case ICMP_ECHO :
		case ICMP_TSTAMP :
		case ICMP_IREQ :
		case ICMP_MASKREQ :
			is->is_icmp.ics_type = ic->icmp_type;
			hv += (is->is_icmp.ics_id = ic->icmp_id);
			hv += (is->is_icmp.ics_seq = ic->icmp_seq);
			break;
		default :
			return NULL;
		}
		ATOMIC_INCL(ips_stats.iss_icmp);
		is->is_age = fr_icmptimeout;
		break;
	    }
	case IPPROTO_TCP :
	    {
		tcp = (tcphdr_t *)fin->fin_dp;

		if (tcp->th_flags & TH_RST)
			return NULL;
		/*
		 * The endian of the ports doesn't matter, but the ack and
		 * sequence numbers do as we do mathematics on them later.
		 */
		is->is_dport = tcp->th_dport;
		is->is_sport = tcp->th_sport;
		if ((flags & (FI_W_DPORT|FI_W_SPORT)) == 0) {
			hv += tcp->th_dport;
			hv += tcp->th_sport;
		}
		is->is_send = ntohl(tcp->th_seq) + fin->fin_dlen -
			      (tcp->th_off << 2) +
			      ((tcp->th_flags & TH_SYN) ? 1 : 0) +
			      ((tcp->th_flags & TH_FIN) ? 1 : 0);
		is->is_maxsend = is->is_send;
		is->is_dend = 0;
		is->is_maxdwin = 1;
		is->is_maxswin = ntohs(tcp->th_win);
		if (is->is_maxswin == 0)
			is->is_maxswin = 1;
		/*
		 * If we're creating state for a starting connection, start the
		 * timer on it as we'll never see an error if it fails to
		 * connect.
		 */
		ATOMIC_INCL(ips_stats.iss_tcp);
		break;
	    }
	case IPPROTO_UDP :
	    {
		tcp = (tcphdr_t *)fin->fin_dp;

		is->is_dport = tcp->th_dport;
		is->is_sport = tcp->th_sport;
		if ((flags & (FI_W_DPORT|FI_W_SPORT)) == 0) {
			hv += tcp->th_dport;
			hv += tcp->th_sport;
		}
		ATOMIC_INCL(ips_stats.iss_udp);
		is->is_age = fr_udptimeout;
		break;
	    }
	default :
		return NULL;
	}

	KMALLOC(is, ipstate_t *);
	if (is == NULL) {
		ATOMIC_INCL(ips_stats.iss_nomem);
		return NULL;
	}
	bcopy((char *)&ips, (char *)is, sizeof(*is));
	hv %= fr_statesize;
	is->is_hv = hv;
	is->is_rule = fin->fin_fr;
	if (is->is_rule != NULL) {
		ATOMIC_INC32(is->is_rule->fr_ref);
		pass = is->is_rule->fr_flags;
	} else
		pass = fr_flags;
	WRITE_ENTER(&ipf_state);

	is->is_pass = pass;
	is->is_pkts = 1;
	is->is_bytes = fin->fin_dlen + fin->fin_hlen;
	/*
	 * We want to check everything that is a property of this packet,
	 * but we don't (automatically) care about it's fragment status as
	 * this may change.
	 */
	is->is_v = fin->fin_fi.fi_v;
	is->is_opt = fin->fin_fi.fi_optmsk;
	is->is_optmsk = 0xffffffff;
	is->is_sec = fin->fin_fi.fi_secmsk;
	is->is_secmsk = 0xffff;
	is->is_auth = fin->fin_fi.fi_auth;
	is->is_authmsk = 0xffff;
	is->is_flags = fin->fin_fi.fi_fl & FI_CMP;
	is->is_flags |= FI_CMP << 4;
	is->is_flags |= flags & (FI_WILDP|FI_WILDA);
	if (flags & (FI_WILDP|FI_WILDA))
		ips_wild++;
	is->is_ifp[1 - out] = NULL;
	is->is_ifp[out] = fin->fin_ifp;
#ifdef	_KERNEL
	strncpy(is->is_ifname[out], IFNAME(fin->fin_ifp), IFNAMSIZ);
#endif
	is->is_ifname[1 - out][0] = '\0';
	if (pass & FR_LOGFIRST)
		is->is_pass &= ~(FR_LOGFIRST|FR_LOG);
	fr_stinsert(is);
	if (is->is_p == IPPROTO_TCP) {
		MUTEX_ENTER(&is->is_lock);
		fr_tcp_age(&is->is_age, is->is_state, fin,
			   0); /* 0 = packet from the source */
		MUTEX_EXIT(&is->is_lock);
	}
#ifdef	IPFILTER_LOG
	ipstate_log(is, ISL_NEW);
#endif
	RWLOCK_EXIT(&ipf_state);
	fin->fin_rev = IP6NEQ(is->is_dst, fin->fin_fi.fi_dst);
	if ((fin->fin_fi.fi_fl & FI_FRAG) && (pass & FR_KEEPFRAG))
		ipfr_newfrag(ip, fin, pass ^ FR_KEEPSTATE);
	return is;
}



/*
 * check to see if a packet with TCP headers fits within the TCP window.
 * change timeout depending on whether new packet is a SYN-ACK returning for a
 * SYN or a RST or FIN which indicate time to close up shop.
 */
int fr_tcpstate(is, fin, ip, tcp)
register ipstate_t *is;
fr_info_t *fin;
ip_t *ip;
tcphdr_t *tcp;
{
	register tcp_seq seq, ack, end;
	register int ackskew;
	tcpdata_t  *fdata, *tdata;
	u_short	win, maxwin;
	int ret = 0;
	int source;

	/*
	 * Find difference between last checked packet and this packet.
	 */
	source = IP6EQ(fin->fin_fi.fi_src, is->is_src);
	fdata = &is->is_tcp.ts_data[!source];
	tdata = &is->is_tcp.ts_data[source];
	seq = ntohl(tcp->th_seq);
	ack = ntohl(tcp->th_ack);
	win = ntohs(tcp->th_win);
	end = seq + fin->fin_dlen - (tcp->th_off << 2) +
	       ((tcp->th_flags & TH_SYN) ? 1 : 0) +
	       ((tcp->th_flags & TH_FIN) ? 1 : 0);

	MUTEX_ENTER(&is->is_lock);
	if (fdata->td_end == 0) {
		/*
		 * Must be a (outgoing) SYN-ACK in reply to a SYN.
		 */
		fdata->td_end = end;
		fdata->td_maxwin = 1;
		fdata->td_maxend = end + 1;
	}

	if (!(tcp->th_flags & TH_ACK)) {  /* Pretend an ack was sent */
		ack = tdata->td_end;
	} else if (((tcp->th_flags & (TH_ACK|TH_RST)) == (TH_ACK|TH_RST)) &&
		   (ack == 0)) {
		/* gross hack to get around certain broken tcp stacks */
		ack = tdata->td_end;
	}

	if (seq == end)
		seq = end = fdata->td_end;

	maxwin = tdata->td_maxwin;
	ackskew = tdata->td_end - ack;

#define	SEQ_GE(a,b)	((int)((a) - (b)) >= 0)
#define	SEQ_GT(a,b)	((int)((a) - (b)) > 0)
	if ((SEQ_GE(fdata->td_maxend, end)) &&
	    (SEQ_GE(seq, fdata->td_end - maxwin)) &&
/* XXX what about big packets */
#define MAXACKWINDOW 66000
	    (ackskew >= -MAXACKWINDOW) &&
	    (ackskew <= MAXACKWINDOW)) {
		/* if ackskew < 0 then this should be due to fragented
		 * packets. There is no way to know the length of the
		 * total packet in advance.
		 * We do know the total length from the fragment cache though.
		 * Note however that there might be more sessions with
		 * exactly the same source and destination paramters in the
		 * state cache (and source and destination is the only stuff
		 * that is saved in the fragment cache). Note further that
		 * some TCP connections in the state cache are hashed with
		 * sport and dport as well which makes it not worthwhile to
		 * look for them.
		 * Thus, when ackskew is negative but still seems to belong
		 * to this session, we bump up the destinations end value.
		 */
		if (ackskew < 0)
			tdata->td_end = ack;

		/* update max window seen */
		if (fdata->td_maxwin < win)
			fdata->td_maxwin = win;
		if (SEQ_GT(end, fdata->td_end))
			fdata->td_end = end;
		if (SEQ_GE(ack + win, tdata->td_maxend)) {
			tdata->td_maxend = ack + win;
			if (win == 0)
				tdata->td_maxend++;
		}

		ATOMIC_INCL(ips_stats.iss_hits);
		/*
		 * Nearing end of connection, start timeout.
		 */
		/* source ? 0 : 1 -> !source */
		fr_tcp_age(&is->is_age, is->is_state, fin, !source);
		ret = 1;
	}
	MUTEX_EXIT(&is->is_lock);
	return ret;
}


static int fr_matchsrcdst(is, src, dst, fin, tcp)
ipstate_t *is;
union i6addr src, dst;
fr_info_t *fin;
tcphdr_t *tcp;
{
	int ret = 0, rev, out, flags;
	u_short sp, dp;
	void *ifp;

	rev = fin->fin_rev = IP6NEQ(is->is_dst, dst);
	ifp = fin->fin_ifp;
	out = fin->fin_out;

	if (tcp != NULL) {
		flags = is->is_flags;
		sp = tcp->th_sport;
		dp = tcp->th_dport;
	} else {
		flags = is->is_flags & FI_WILDA;
		sp = 0;
		dp = 0;
	}

	if (rev == 0) {
		if (!out) {
			if (is->is_ifpin == NULL || is->is_ifpin == ifp)
				ret = 1;
		} else {
			if (is->is_ifpout == NULL || is->is_ifpout == ifp)
				ret = 1;
		}
	} else {
		if (out) {
			if (is->is_ifpin == NULL || is->is_ifpin == ifp)
				ret = 1;
		} else {
			if (is->is_ifpout == NULL || is->is_ifpout == ifp)
				ret = 1;
		}
	}
	if (ret == 0)
		return 0;
	ret = 0;

	if (rev == 0) {
		if (
		    (IP6EQ(is->is_dst, dst) || (flags & FI_W_DADDR)) &&
		    (IP6EQ(is->is_src, src) || (flags & FI_W_SADDR)) &&
		    (!tcp || ((sp == is->is_sport || flags & FI_W_SPORT) &&
		     (dp == is->is_dport || flags & FI_W_DPORT)))) {
			ret = 1;
		}
	} else {
		if (
		    (IP6EQ(is->is_dst, src) || (flags & FI_W_DADDR)) &&
		    (IP6EQ(is->is_src, dst) || (flags & FI_W_SADDR)) &&
		    (!tcp || ((sp == is->is_dport || flags & FI_W_DPORT) &&
		     (dp == is->is_sport || flags & FI_W_SPORT)))) {
			ret = 1;
		}
	}
	if (ret == 0)
		return 0;

	/*
	 * Whether or not this should be here, is questionable, but the aim
	 * is to get this out of the main line.
	 */
	if (tcp == NULL)
		flags = is->is_flags & (FI_CMP|(FI_CMP<<4));

	if (((fin->fin_fi.fi_fl & (flags >> 4)) != (flags & FI_CMP)) ||
	    ((fin->fin_fi.fi_optmsk & is->is_optmsk) != is->is_opt) ||
	    ((fin->fin_fi.fi_secmsk & is->is_secmsk) != is->is_sec) ||
	    ((fin->fin_fi.fi_auth & is->is_authmsk) != is->is_auth))
		return 0;

	if ((flags & (FI_W_SPORT|FI_W_DPORT))) {
		if ((flags & FI_W_SPORT) != 0) {
			if (rev == 0) {
				is->is_sport = sp;
				is->is_send = htonl(tcp->th_seq);
			} else {
				is->is_sport = dp;
				is->is_send = htonl(tcp->th_ack);
			}
			is->is_maxsend = is->is_send + 1;
		} else if ((flags & FI_W_DPORT) != 0) {
			if (rev == 0) {
				is->is_dport = dp;
				is->is_dend = htonl(tcp->th_ack);
			} else {
				is->is_dport = sp;
				is->is_dend = htonl(tcp->th_seq);
			}
			is->is_maxdend = is->is_dend + 1;
		}
		is->is_flags &= ~(FI_W_SPORT|FI_W_DPORT);
		ips_wild--;
	}

	ret = -1;

	if (!rev) {
		if (out) {
			if (!is->is_ifpout)
				ret = 1;
		} else {
			if (!is->is_ifpin)
				ret = 0;
		}
	} else {
		if (out) {
			if (!is->is_ifpin)
				ret = 0;
		} else {
			if (!is->is_ifpout)
				ret = 1;
		}
	}

	if (ret >= 0) {
		is->is_ifp[ret] = ifp;
#ifdef	_KERNEL
		strncpy(is->is_ifname[out], IFNAME(fin->fin_ifp),
			sizeof(is->is_ifname[1]));
#endif
	}
#ifdef  _KERNEL
	if (ret >= 0) {
		strncpy(is->is_ifname[out], IFNAME(fin->fin_ifp),
			sizeof(is->is_ifname[1]));
	}
#endif
	return 1;
}

static int fr_matchicmpqueryreply(v, is, icmp)
int v;
ipstate_t *is;
icmphdr_t *icmp;
{
	if (v == 4) {
		/*
		 * If we matched its type on the way in, then when going out
		 * it will still be the same type.
		 */
		if (((icmp->icmp_type == is->is_type) ||
		     (icmpreplytype4[is->is_type] == icmp->icmp_type)) &&
		    (icmp->icmp_id == is->is_icmp.ics_id) &&
		    (icmp->icmp_seq == is->is_icmp.ics_seq)) {
			return 1;
		};
	}
#ifdef	USE_INET6
	else if (is->is_v == 6) {
		if ((is->is_type == ICMP6_ECHO_REPLY) &&
		    (icmp->icmp_type == ICMP6_ECHO_REQUEST) &&
		    (icmp->icmp_id == is->is_icmp.ics_id) &&
		    (icmp->icmp_seq == is->is_icmp.ics_seq)) {
			return 1;
		};
	}
#endif
	return 0;
}

static frentry_t *fr_checkicmpmatchingstate(ip, fin)
ip_t *ip;
fr_info_t *fin;
{
	register ipstate_t *is, **isp;
	register u_short sport, dport;
	register u_char	pr;
	union i6addr dst, src;
	struct icmp *ic;
	u_short savelen;
	icmphdr_t *icmp;
	fr_info_t ofin;
	int type, len;
	tcphdr_t *tcp;
	frentry_t *fr;
	ip_t *oip;
	u_int hv;

	/*
	 * Does it at least have the return (basic) IP header ?
	 * Only a basic IP header (no options) should be with
	 * an ICMP error header.
	 */
	if (((ip->ip_v != 4) || (ip->ip_hl != 5)) ||
	    (fin->fin_plen < ICMPERR_MINPKTLEN))
		return NULL;
	ic = (struct icmp *)fin->fin_dp;
	type = ic->icmp_type;
	/*
	 * If it's not an error type, then return
	 */
	if ((type != ICMP_UNREACH) && (type != ICMP_SOURCEQUENCH) &&
    	    (type != ICMP_REDIRECT) && (type != ICMP_TIMXCEED) &&
    	    (type != ICMP_PARAMPROB))
		return NULL;

	oip = (ip_t *)((char *)ic + ICMPERR_ICMPHLEN);
	if (fin->fin_plen < ICMPERR_MAXPKTLEN + ((oip->ip_hl - 5) << 2))
		return NULL;

	/*
	 * Sanity checks.
	 */
	len = fin->fin_dlen - ICMPERR_ICMPHLEN;
	if ((len <= 0) || ((oip->ip_hl << 2) > len))
		return NULL;

	/*
	 * Is the buffer big enough for all of it ?  It's the size of the IP
	 * header claimed in the encapsulated part which is of concern.  It
	 * may be too big to be in this buffer but not so big that it's
	 * outside the ICMP packet, leading to TCP deref's causing problems.
	 * This is possible because we don't know how big oip_hl is when we
	 * do the pullup early in fr_check() and thus can't gaurantee it is
	 * all here now.
	 */
#ifdef  _KERNEL
	{
	mb_t *m;

# if SOLARIS
	m = fin->fin_qfm;
	if ((char *)oip + len > (char *)m->b_wptr)
		return NULL;
# else
	m = *(mb_t **)fin->fin_mp;
	if ((char *)oip + len > (char *)ip + m->m_len)
		return NULL;
# endif
	}
#endif

	/*
	 * in the IPv4 case we must zero the i6addr union otherwise
	 * the IP6EQ and IP6NEQ macros produce the wrong results because
	 * of the 'junk' in the unused part of the union
	 */
	bzero((char *)&src, sizeof(src));
	bzero((char *)&dst, sizeof(dst));

	if (oip->ip_p == IPPROTO_ICMP) {
		icmp = (icmphdr_t *)((char *)oip + (oip->ip_hl << 2));

		/*
		 * a ICMP error can only be generated as a result of an
		 * ICMP query, not as the response on an ICMP error
		 *
		 * XXX theoretically ICMP_ECHOREP and the other reply's are
		 * ICMP query's as well, but adding them here seems strange XXX
		 */
		 if ((icmp->icmp_type != ICMP_ECHO) &&
		     (icmp->icmp_type != ICMP_TSTAMP) &&
		     (icmp->icmp_type != ICMP_IREQ) &&
		     (icmp->icmp_type != ICMP_MASKREQ))
		    	return NULL;

		/*
		 * perform a lookup of the ICMP packet in the state table
		 */
		hv = (pr = oip->ip_p);
		src.in4 = oip->ip_src;
		hv += src.in4.s_addr;
		dst.in4 = oip->ip_dst;
		hv += dst.in4.s_addr;
		hv += icmp->icmp_id;
		hv += icmp->icmp_seq;
		hv %= fr_statesize;

		savelen = oip->ip_len;
		oip->ip_len = len;
		ofin.fin_v = 4;
		fr_makefrip(oip->ip_hl << 2, oip, &ofin);
		oip->ip_len = savelen;
		ofin.fin_ifp = fin->fin_ifp;
		ofin.fin_out = !fin->fin_out;
		ofin.fin_mp = NULL; /* if dereferenced, panic XXX */

		READ_ENTER(&ipf_state);
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext)
			if ((is->is_p == pr) && (is->is_v == 4) &&
			    fr_matchsrcdst(is, src, dst, &ofin, NULL) &&
			    fr_matchicmpqueryreply(is->is_v, is, icmp)) {
				ips_stats.iss_hits++;
				is->is_pkts++;
				is->is_bytes += ip->ip_len;
				fr = is->is_rule;
				RWLOCK_EXIT(&ipf_state);
				return fr;
			}
		RWLOCK_EXIT(&ipf_state);
		return NULL;
	};

	if ((oip->ip_p != IPPROTO_TCP) && (oip->ip_p != IPPROTO_UDP))
		return NULL;

	tcp = (tcphdr_t *)((char *)oip + (oip->ip_hl << 2));
	dport = tcp->th_dport;
	sport = tcp->th_sport;

	hv = (pr = oip->ip_p);
	src.in4 = oip->ip_src;
	hv += src.in4.s_addr;
	dst.in4 = oip->ip_dst;
	hv += dst.in4.s_addr;
	hv += dport;
	hv += sport;
	hv %= fr_statesize;
	/*
	 * we make an fin entry to be able to feed it to
	 * matchsrcdst note that not all fields are encessary
	 * but this is the cleanest way. Note further we fill
	 * in fin_mp such that if someone uses it we'll get
	 * a kernel panic. fr_matchsrcdst does not use this.
	 *
	 * watch out here, as ip is in host order and oip in network
	 * order. Any change we make must be undone afterwards.
	 */
	savelen = oip->ip_len;
	oip->ip_len = len;
	ofin.fin_v = 4;
	fr_makefrip(oip->ip_hl << 2, oip, &ofin);
	oip->ip_len = savelen;
	ofin.fin_ifp = fin->fin_ifp;
	ofin.fin_out = !fin->fin_out;
	ofin.fin_mp = NULL; /* if dereferenced, panic XXX */
	READ_ENTER(&ipf_state);
	for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext) {
		/*
		 * Only allow this icmp though if the
		 * encapsulated packet was allowed through the
		 * other way around. Note that the minimal amount
		 * of info present does not allow for checking against
		 * tcp internals such as seq and ack numbers.
		 */
		if ((is->is_p == pr) && (is->is_v == 4) &&
		    fr_matchsrcdst(is, src, dst, &ofin, tcp)) {
			fr = is->is_rule;
			ips_stats.iss_hits++;
			is->is_pkts++;
			is->is_bytes += fin->fin_plen;
			/*
			 * we deliberately do not touch the timeouts
			 * for the accompanying state table entry.
			 * It remains to be seen if that is correct. XXX
			 */
			RWLOCK_EXIT(&ipf_state);
			return fr;
		}
	}
	RWLOCK_EXIT(&ipf_state);
	return NULL;
}


static void fr_ipsmove(isp, is, hv)
ipstate_t **isp, *is;
u_int hv;
{
	u_int hvm;

	hvm = is->is_hv;
	/*
	 * Remove the hash from the old location...
	 */
	if (is->is_hnext)
		is->is_hnext->is_phnext = isp;
	*isp = is->is_hnext;
	if (ips_table[hvm] == NULL)
		ips_stats.iss_inuse--;

	/*
	 * ...and put the hash in the new one.
	 */
	hvm = hv % fr_statesize;
	is->is_hv = hvm;
	isp = &ips_table[hvm];
	if (*isp)
		(*isp)->is_phnext = &is->is_hnext;
	else
		ips_stats.iss_inuse++;
	is->is_phnext = isp;
	is->is_hnext = *isp;
	*isp = is;
}


/*
 * Check if a packet has a registered state.
 */
frentry_t *fr_checkstate(ip, fin)
ip_t *ip;
fr_info_t *fin;
{
	union i6addr dst, src;
	register ipstate_t *is, **isp;
	register u_char pr;
	u_int hv, hvm, hlen, tryagain, pass, v;
	struct icmp *ic;
	frentry_t *fr;
	tcphdr_t *tcp;

	if (fr_state_lock || (fin->fin_off & IP_OFFMASK) ||
	    (fin->fin_fi.fi_fl & FI_SHORT))
		return NULL;

	is = NULL;
	hlen = fin->fin_hlen;
	tcp = (tcphdr_t *)((char *)ip + hlen);
	ic = (struct icmp *)tcp;
	hv = (pr = fin->fin_fi.fi_p);
	src = fin->fin_fi.fi_src;
	dst = fin->fin_fi.fi_dst;
	hv += src.in4.s_addr;
	hv += dst.in4.s_addr;

	/*
	 * Search the hash table for matching packet header info.
	 */
	v = fin->fin_fi.fi_v;
	switch (fin->fin_fi.fi_p)
	{
#ifdef	USE_INET6
	case IPPROTO_ICMPV6 :
		if (v == 6) {
			if (fin->fin_out)
				hv -= dst.in4.s_addr;
			else
				hv -= src.in4.s_addr;
			if ((ic->icmp_type == ICMP6_ECHO_REQUEST) ||
			    (ic->icmp_type == ICMP6_ECHO_REPLY)) {
				hv += ic->icmp_id;
				hv += ic->icmp_seq;
			}
		}
#endif
	case IPPROTO_ICMP :
		if (v == 4) {
			hv += ic->icmp_id;
			hv += ic->icmp_seq;
		}
		hv %= fr_statesize;
		READ_ENTER(&ipf_state);
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext) {
			if ((is->is_p == pr) && (is->is_v == v) &&
			    fr_matchsrcdst(is, src, dst, fin, NULL) &&
			    fr_matchicmpqueryreply(v, is, ic)) {
				if (fin->fin_rev)
					is->is_age = fr_icmpacktimeout;
				else
					is->is_age = fr_icmptimeout;
				break;
			}
		}
		if (is != NULL)
			break;
		RWLOCK_EXIT(&ipf_state);
		/*
		 * No matching icmp state entry. Perhaps this is a
		 * response to another state entry.
		 */
#ifdef	USE_INET6
		if (v == 6)
			fr = fr_checkicmp6matchingstate((ip6_t *)ip, fin);
		else
#endif
			fr = fr_checkicmpmatchingstate(ip, fin);
		if (fr)
			return fr;
		break;
	case IPPROTO_TCP :
	    {
		register u_short dport, sport;
		register int i;

		i = tcp->th_flags;
		/*
		 * Just plain ignore RST flag set with either FIN or SYN.
		 */
		if ((i & TH_RST) &&
		    ((i & (TH_FIN|TH_SYN|TH_RST)) != TH_RST))
			break;
	case IPPROTO_UDP :
		dport = tcp->th_dport;
		sport = tcp->th_sport;
		tryagain = 0;
		hv += dport;
		hv += sport;
		READ_ENTER(&ipf_state);
retry_tcpudp:
		hvm = hv % fr_statesize;
		for (isp = &ips_table[hvm]; (is = *isp); isp = &is->is_hnext)
			if ((is->is_p == pr) && (is->is_v == v) &&
			    fr_matchsrcdst(is, src, dst, fin, tcp)) {
				if ((pr == IPPROTO_TCP)) {
					if (!fr_tcpstate(is, fin, ip, tcp)) {
						continue;
					}
				} if ((pr == IPPROTO_UDP)) {
					if (fin->fin_rev)
						is->is_age = fr_udpacktimeout;
					else
						is->is_age = fr_udptimeout;
				}
				break;
			}
		if (is != NULL) {
			if (tryagain &&
			    !(is->is_flags & (FI_WILDP|FI_WILDA))) {
				hv += dport;
				hv += sport;
				fr_ipsmove(isp, is, hv);
				MUTEX_DOWNGRADE(&ipf_state);
			}
			break;
		}
		RWLOCK_EXIT(&ipf_state);
		if (!tryagain && ips_wild) {
			hv -= dport;
			hv -= sport;
			tryagain = 1;
			WRITE_ENTER(&ipf_state);
			goto retry_tcpudp;
		}
		break;
	    }
	default :
		break;
	}
	if (is == NULL) {
		ATOMIC_INCL(ips_stats.iss_miss);
		return NULL;
	}
	MUTEX_ENTER(&is->is_lock);
	is->is_bytes += fin->fin_plen;
	ips_stats.iss_hits++;
	is->is_pkts++;
	MUTEX_EXIT(&is->is_lock);
	fr = is->is_rule;
	fin->fin_fr = fr;
	pass = is->is_pass;
#ifndef	_KERNEL
	if (tcp->th_flags & TCP_CLOSE)
		fr_delstate(is);
#endif
	RWLOCK_EXIT(&ipf_state);
	if ((fin->fin_fi.fi_fl & FI_FRAG) && (pass & FR_KEEPFRAG))
		ipfr_newfrag(ip, fin, pass ^ FR_KEEPSTATE);
	return fr;
}


void ip_statesync(ifp)
void *ifp;
{
	register ipstate_t *is;

	WRITE_ENTER(&ipf_state);
	for (is = ips_list; is; is = is->is_next) {
		if (is->is_ifpin == ifp) {
			is->is_ifpin = GETUNIT(is->is_ifname[0], is->is_v);
			if (!is->is_ifpin)
				is->is_ifpin = (void *)-1;
		}
		if (is->is_ifpout == ifp) {
			is->is_ifpout = GETUNIT(is->is_ifname[1], is->is_v);
			if (!is->is_ifpout)
				is->is_ifpout = (void *)-1;
		}
	}
	RWLOCK_EXIT(&ipf_state);
}


/*
 * Must always be called with fr_ipfstate held as a write lock.
 */
static void fr_delstate(is)
ipstate_t *is;
{
	frentry_t *fr;

	if (is->is_flags & (FI_WILDP|FI_WILDA))
		ips_wild--;
	if (is->is_next)
		is->is_next->is_pnext = is->is_pnext;
	*is->is_pnext = is->is_next;
	if (is->is_hnext)
		is->is_hnext->is_phnext = is->is_phnext;
	*is->is_phnext = is->is_hnext;
	if (ips_table[is->is_hv] == NULL)
		ips_stats.iss_inuse--;

	fr = is->is_rule;
	if (fr != NULL) {
		fr->fr_ref--;
		if (fr->fr_ref == 0) {
			KFREE(fr);
		}
	}
#ifdef	_KERNEL
	MUTEX_DESTROY(&is->is_lock);
#endif
	KFREE(is);
	ips_num--;
}


/*
 * Free memory in use by all state info. kept.
 */
void fr_stateunload()
{
	register ipstate_t *is;

	WRITE_ENTER(&ipf_state);
	while ((is = ips_list))
		fr_delstate(is);
	ips_stats.iss_inuse = 0;
	ips_num = 0;
	RWLOCK_EXIT(&ipf_state);
	KFREES(ips_table, fr_statesize * sizeof(ipstate_t *));
	ips_table = NULL;
}


/*
 * Slowly expire held state for thingslike UDP and ICMP.  Timeouts are set
 * in expectation of this being called twice per second.
 */
void fr_timeoutstate()
{
	register ipstate_t *is, **isp;
#if defined(_KERNEL) && !SOLARIS
	int s;
#endif

	SPL_NET(s);
	WRITE_ENTER(&ipf_state);
	for (isp = &ips_list; (is = *isp); )
		if (is->is_age && !--is->is_age) {
			if (is->is_p == IPPROTO_TCP)
				ips_stats.iss_fin++;
			else
				ips_stats.iss_expire++;
#ifdef	IPFILTER_LOG
			ipstate_log(is, ISL_EXPIRE);
#endif
			fr_delstate(is);
		} else
			isp = &is->is_next;
	if (fr_state_doflush) {
		(void) fr_state_flush(1);
		fr_state_doflush = 0;
	}
	RWLOCK_EXIT(&ipf_state);
	SPL_X(s);
}


/*
 * Original idea freom Pradeep Krishnan for use primarily with NAT code.
 * (pkrishna@@netcom.com)
 *
 * Rewritten by Arjan de Vet <Arjan.deVet@@adv.iae.nl>, 2000-07-29:
 *
 * - (try to) base state transitions on real evidence only,
 *   i.e. packets that are sent and have been received by ipfilter;
 *   diagram 18.12 of TCP/IP volume 1 by W. Richard Stevens was used.
 *
 * - deal with half-closed connections correctly;
 *
 * - store the state of the source in state[0] such that ipfstat
 *   displays the state as source/dest instead of dest/source; the calls
 *   to fr_tcp_age have been changed accordingly.
 *
 * Parameters:
 *
 *    state[0] = state of source (host that initiated connection)
 *    state[1] = state of dest   (host that accepted the connection)
 *
 *    dir == 0 : a packet from source to dest
 *    dir == 1 : a packet from dest to source
 *
 */
void fr_tcp_age(age, state, fin, dir)
u_long *age;
u_char *state;
fr_info_t *fin;
int dir;
{
	tcphdr_t *tcp = (tcphdr_t *)fin->fin_dp;
	u_char flags = tcp->th_flags;
	int dlen, ostate;

	ostate = state[1 - dir];

	dlen = fin->fin_plen - fin->fin_hlen - (tcp->th_off << 2);

	if (flags & TH_RST) {
		if (!(tcp->th_flags & TH_PUSH) && !dlen) {
			*age = fr_tcpclosed;
			state[dir] = TCPS_CLOSED;
		} else {
			*age = fr_tcpclosewait;
			state[dir] = TCPS_CLOSE_WAIT;
		}
		return;
	}

	*age = fr_tcptimeout; /* default 4 mins */

	switch(state[dir])
	{
	case TCPS_CLOSED: /* 0 */
		if ((flags & TH_OPENING) == TH_OPENING) {
			/*
			 * 'dir' received an S and sends SA in response,
			 * CLOSED -> SYN_RECEIVED
			 */
			state[dir] = TCPS_SYN_RECEIVED;
			*age = fr_tcptimeout;
		} else if ((flags & (TH_SYN|TH_ACK)) == TH_SYN) {
			/* 'dir' sent S, CLOSED -> SYN_SENT */
			state[dir] = TCPS_SYN_SENT;
			*age = fr_tcptimeout;
		}
		/*
		 * The next piece of code makes it possible to get
		 * already established connections into the state table
		 * after a restart or reload of the filter rules; this
		 * does not work when a strict 'flags S keep state' is
		 * used for tcp connections of course
		 */
		if ((flags & (TH_FIN|TH_SYN|TH_RST|TH_ACK)) == TH_ACK) {
			/* we saw an A, guess 'dir' is in ESTABLISHED mode */
			state[dir] = TCPS_ESTABLISHED;
			*age = fr_tcpidletimeout;
		}
		/*
		 * TODO: besides regular ACK packets we can have other
		 * packets as well; it is yet to be determined how we
		 * should initialize the states in those cases
		 */
		break;

	case TCPS_LISTEN: /* 1 */
		/* NOT USED */
		break;

	case TCPS_SYN_SENT: /* 2 */
		if ((flags & (TH_SYN|TH_FIN|TH_ACK)) == TH_ACK) {
			/*
			 * We see an A from 'dir' which is in SYN_SENT
			 * state: 'dir' sent an A in response to an SA
			 * which it received, SYN_SENT -> ESTABLISHED
			 */
			state[dir] = TCPS_ESTABLISHED;
			*age = fr_tcpidletimeout;
		} else if (flags & TH_FIN) {
			/*
			 * We see an F from 'dir' which is in SYN_SENT
			 * state and wants to close its side of the
			 * connection; SYN_SENT -> FIN_WAIT_1
			 */
			state[dir] = TCPS_FIN_WAIT_1;
			*age = fr_tcpidletimeout; /* or fr_tcptimeout? */
		} else if ((flags & TH_OPENING) == TH_OPENING) {
			/*
			 * We see an SA from 'dir' which is already in
			 * SYN_SENT state, this means we have a
			 * simultaneous open; SYN_SENT -> SYN_RECEIVED
			 */
			state[dir] = TCPS_SYN_RECEIVED;
			*age = fr_tcptimeout;
		}
		break;

	case TCPS_SYN_RECEIVED: /* 3 */
		if ((flags & (TH_SYN|TH_FIN|TH_ACK)) == TH_ACK) {
			/*
			 * We see an A from 'dir' which was in SYN_RECEIVED
			 * state so it must now be in established state,
			 * SYN_RECEIVED -> ESTABLISHED
			 */
			state[dir] = TCPS_ESTABLISHED;
			*age = fr_tcpidletimeout;
		} else if (flags & TH_FIN) {
			/*
			 * We see an F from 'dir' which is in SYN_RECEIVED
			 * state and wants to close its side of the connection;
			 * SYN_RECEIVED -> FIN_WAIT_1
			 */
			state[dir] = TCPS_FIN_WAIT_1;
			*age = fr_tcpidletimeout;
		}
		break;

	case TCPS_ESTABLISHED: /* 4 */
		if (flags & TH_FIN) {
			/*
			 * 'dir' closed its side of the connection; this
			 * gives us a half-closed connection;
			 * ESTABLISHED -> FIN_WAIT_1
			 */
			state[dir] = TCPS_FIN_WAIT_1;
			*age = fr_tcphalfclosed;
		} else if (flags & TH_ACK) {
			/* an ACK, should we exclude other flags here? */
			if (ostate == TCPS_FIN_WAIT_1) {
				/*
				 * We know the other side did an active close,
				 * so we are ACKing the recvd FIN packet (does
				 * the window matching code guarantee this?)
				 * and go into CLOSE_WAIT state; this gives us
				 * a half-closed connection
				 */
				state[dir] = TCPS_CLOSE_WAIT;
				*age = fr_tcphalfclosed;
			} else if (ostate < TCPS_CLOSE_WAIT)
				/*
				 * Still a fully established connection,
				 * reset timeout
				 */
				*age = fr_tcpidletimeout;
		}
		break;

	case TCPS_CLOSE_WAIT: /* 5 */
		if (flags & TH_FIN) {
			/*
			 * Application closed and 'dir' sent a FIN, we're now
			 * going into LAST_ACK state
			 */
			*age  = fr_tcplastack;
			state[dir] = TCPS_LAST_ACK;
		} else {
			/*
			 * We remain in CLOSE_WAIT because the other side has
			 * closed already and we did not close our side yet;
			 * reset timeout
			 */
			*age  = fr_tcphalfclosed;
		}
		break;

	case TCPS_FIN_WAIT_1: /* 6 */
		if ((flags & TH_ACK) && ostate > TCPS_CLOSE_WAIT) {
			/*
			 * If the other side is not active anymore it has sent
			 * us a FIN packet that we are ack'ing now with an ACK;
			 * this means both sides have now closed the connection
			 * and we go into TIME_WAIT
			 */
			/*
			 * XXX: how do we know we really are ACKing the FIN
			 * packet here? does the window code guarantee that?
			 */
			state[dir] = TCPS_TIME_WAIT;
			*age = fr_tcptimeout;
		} else
			/*
			 * We closed our side of the connection already but the
			 * other side is still active (ESTABLISHED/CLOSE_WAIT);
			 * continue with this half-closed connection
			 */
			*age = fr_tcphalfclosed;
		break;

	case TCPS_CLOSING: /* 7 */
		/* NOT USED */
		break;

	case TCPS_LAST_ACK: /* 8 */
		if (flags & TH_ACK) {
			if ((flags & TH_PUSH) || dlen)
				/*
				 * There is still data to be delivered, reset
				 * timeout
				 */
				*age  = fr_tcplastack;
		}
		/*
		 * We cannot detect when we go out of LAST_ACK state to CLOSED
		 * because that is based on the reception of ACK packets;
		 * ipfilter can only detect that a packet has been sent by a
		 * host
		 */
		break;

	case TCPS_FIN_WAIT_2: /* 9 */
		/* NOT USED */
		break;

	case TCPS_TIME_WAIT: /* 10 */
		/* we're in 2MSL timeout now */
		break;
	}
}


#ifdef	IPFILTER_LOG
void ipstate_log(is, type)
struct ipstate *is;
u_int type;
{
	struct	ipslog	ipsl;
	void *items[1];
	size_t sizes[1];
	int types[1];

	ipsl.isl_type = type;
	ipsl.isl_pkts = is->is_pkts;
	ipsl.isl_bytes = is->is_bytes;
	ipsl.isl_src = is->is_src;
	ipsl.isl_dst = is->is_dst;
	ipsl.isl_p = is->is_p;
	ipsl.isl_v = is->is_v;
	ipsl.isl_flags = is->is_flags;
	if (ipsl.isl_p == IPPROTO_TCP || ipsl.isl_p == IPPROTO_UDP) {
		ipsl.isl_sport = is->is_sport;
		ipsl.isl_dport = is->is_dport;
		if (ipsl.isl_p == IPPROTO_TCP) {
			ipsl.isl_state[0] = is->is_state[0];
			ipsl.isl_state[1] = is->is_state[1];
		}
	} else if (ipsl.isl_p == IPPROTO_ICMP)
		ipsl.isl_itype = is->is_icmp.ics_type;
	else {
		ipsl.isl_ps.isl_filler[0] = 0;
		ipsl.isl_ps.isl_filler[1] = 0;
	}
	items[0] = &ipsl;
	sizes[0] = sizeof(ipsl);
	types[0] = 0;

	(void) ipllog(IPL_LOGSTATE, NULL, items, sizes, types, 1);
}
#endif


#ifdef	USE_INET6
frentry_t *fr_checkicmp6matchingstate(ip, fin)
ip6_t *ip;
fr_info_t *fin;
{
	register ipstate_t *is, **isp;
	register u_short sport, dport;
	register u_char	pr;
	struct icmp6_hdr *ic, *oic;
	union i6addr dst, src;
	u_short savelen;
	fr_info_t ofin;
	tcphdr_t *tcp;
	frentry_t *fr;
	ip6_t *oip;
	int type;
	u_int hv;

	/*
	 * Does it at least have the return (basic) IP header ?
	 * Only a basic IP header (no options) should be with
	 * an ICMP error header.
	 */
	if ((fin->fin_v != 6) || (fin->fin_plen < ICMP6ERR_MINPKTLEN))
		return NULL;
	ic = (struct icmp6_hdr *)fin->fin_dp;
	type = ic->icmp6_type;
	/*
	 * If it's not an error type, then return
	 */
	if ((type != ICMP6_DST_UNREACH) && (type != ICMP6_PACKET_TOO_BIG) &&
	    (type != ICMP6_TIME_EXCEEDED) && (type != ICMP6_PARAM_PROB))
		return NULL;

	oip = (ip6_t *)((char *)ic + ICMPERR_ICMPHLEN);
	if (fin->fin_plen < sizeof(*oip))
		return NULL;

	if (oip->ip6_nxt == IPPROTO_ICMPV6) {
		oic = (struct icmp6_hdr *)(oip + 1);
		/*
		 * a ICMP error can only be generated as a result of an
		 * ICMP query, not as the response on an ICMP error
		 *
		 * XXX theoretically ICMP_ECHOREP and the other reply's are
		 * ICMP query's as well, but adding them here seems strange XXX
		 */
		 if (!(oic->icmp6_type & ICMP6_INFOMSG_MASK))
		    	return NULL;

		/*
		 * perform a lookup of the ICMP packet in the state table
		 */
		hv = (pr = oip->ip6_nxt);
		src.in6 = oip->ip6_src;
		hv += src.in4.s_addr;
		dst.in6 = oip->ip6_dst;
		hv += dst.in4.s_addr;
		hv += oic->icmp6_id;
		hv += oic->icmp6_seq;
		hv %= fr_statesize;

		oip->ip6_plen = ntohs(oip->ip6_plen);
		ofin.fin_v = 6;
		fr_makefrip(sizeof(*oip), (ip_t *)oip, &ofin);
		oip->ip6_plen = htons(oip->ip6_plen);
		ofin.fin_ifp = fin->fin_ifp;
		ofin.fin_out = !fin->fin_out;
		ofin.fin_mp = NULL; /* if dereferenced, panic XXX */

		READ_ENTER(&ipf_state);
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext)
			if ((is->is_p == pr) &&
			    (oic->icmp6_id == is->is_icmp.ics_id) &&
			    (oic->icmp6_seq == is->is_icmp.ics_seq) &&
			    fr_matchsrcdst(is, src, dst, &ofin, NULL)) {
			    	/*
			    	 * in the state table ICMP query's are stored
			    	 * with the type of the corresponding ICMP
			    	 * response. Correct here
			    	 */
				if (((is->is_type == ICMP6_ECHO_REPLY) &&
				     (oic->icmp6_type == ICMP6_ECHO_REQUEST)) ||
				     (is->is_type - 1 == oic->icmp6_type )) {
				    	ips_stats.iss_hits++;
    					is->is_pkts++;
					is->is_bytes += fin->fin_plen;
					return is->is_rule;
				}
			}
		RWLOCK_EXIT(&ipf_state);

		return NULL;
	};

	if ((oip->ip6_nxt != IPPROTO_TCP) && (oip->ip6_nxt != IPPROTO_UDP))
		return NULL;
	tcp = (tcphdr_t *)(oip + 1);
	dport = tcp->th_dport;
	sport = tcp->th_sport;

	hv = (pr = oip->ip6_nxt);
	src.in6 = oip->ip6_src;
	hv += src.in4.s_addr;
	dst.in6 = oip->ip6_dst;
	hv += dst.in4.s_addr;
	hv += dport;
	hv += sport;
	hv %= fr_statesize;
	/*
	 * we make an fin entry to be able to feed it to
	 * matchsrcdst note that not all fields are encessary
	 * but this is the cleanest way. Note further we fill
	 * in fin_mp such that if someone uses it we'll get
	 * a kernel panic. fr_matchsrcdst does not use this.
	 *
	 * watch out here, as ip is in host order and oip in network
	 * order. Any change we make must be undone afterwards.
	 */
	savelen = oip->ip6_plen;
	oip->ip6_plen = ip->ip6_plen - sizeof(*ip) - ICMPERR_ICMPHLEN;
	ofin.fin_v = 6;
	fr_makefrip(sizeof(*oip), (ip_t *)oip, &ofin);
	oip->ip6_plen = savelen;
	ofin.fin_ifp = fin->fin_ifp;
	ofin.fin_out = !fin->fin_out;
	ofin.fin_mp = NULL; /* if dereferenced, panic XXX */
	READ_ENTER(&ipf_state);
	for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext) {
		/*
		 * Only allow this icmp though if the
		 * encapsulated packet was allowed through the
		 * other way around. Note that the minimal amount
		 * of info present does not allow for checking against
		 * tcp internals such as seq and ack numbers.
		 */
		if ((is->is_p == pr) && (is->is_v == 6) &&
		    fr_matchsrcdst(is, src, dst, &ofin, tcp)) {
			fr = is->is_rule;
			ips_stats.iss_hits++;
			/*
			 * we must swap src and dst here because the icmp
			 * comes the other way around
			 */
			is->is_pkts++;
			is->is_bytes += fin->fin_plen;
			/*
			 * we deliberately do not touch the timeouts
			 * for the accompanying state table entry.
			 * It remains to be seen if that is correct. XXX
			 */
			RWLOCK_EXIT(&ipf_state);
			return fr;
		}
	}
	RWLOCK_EXIT(&ipf_state);
	return NULL;
}
#endif
@


1.27
log
@Partial update to IPF 3.4.17; this fixes the *VERY* serious fragment
caching bug recently discussed in the ipfilter list.

People using IPF is urged to sync with these changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.26 2001/01/30 04:23:56 kjell Exp $	*/
@


1.26
log
@re-add local ipf changes that were whacked in the 3.4.16 merge. userland to follow
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.25 2001/01/17 07:25:19 fgsch Exp $	*/
d4 1
a4 1
 * Copyright (C) 1995-2000 by Darren Reed.
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.30.2.28 2001/01/08 14:04:46 darrenr Exp $";
d145 3
a147 1
	fr_icmptimeout = 120;
d695 1
a695 1
	if (fin->fin_fi.fi_fl & FI_FRAG)
d1261 4
a1264 1
				is->is_age = fr_icmptimeout;
d1312 5
d1360 1
a1360 1
	if (fin->fin_fi.fi_fl & FI_FRAG)
@


1.25
log
@IPF 3.4.16.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.24 2001/01/17 04:47:16 fgsch Exp $	*/
d84 1
a84 1
#include "netinet/ip_compat.h"
d86 5
a90 5
#include "netinet/ip_fil.h"
#include "netinet/ip_nat.h"
#include "netinet/ip_frag.h"
#include "netinet/ip_proxy.h"
#include "netinet/ip_state.h"
@


1.24
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.30.2.27 2000/12/02 00:15:25 darrenr Exp $";
d1378 3
d1399 1
a1399 1
		ATOMIC_DEC32(fr->fr_ref);
a1454 2
	RWLOCK_EXIT(&ipf_state);
	SPL_X(s);
d1459 2
@


1.23
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.22 2000/05/24 21:59:11 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1995-1998 by Darren Reed.
d11 2
a12 2
static const char sccsid[] = "@@(#)ip_state.c	1.8 6/5/96 (C) 1993-1995 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.3.2.28 2000/08/08 16:00:35 darrenr Exp $";
d23 4
d52 1
a52 1
#if defined(_KERNEL) && !defined(linux)
d84 1
a84 1
#include <netinet/ip_fil_compat.h>
d86 8
a93 5
#include <netinet/ip_fil.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_frag.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_state.h>
d108 5
a112 3
ipstate_t **ips_table = NULL;
int	ips_num = 0;
ips_stat_t ips_stats;
d118 4
a121 1
static int fr_matchsrcdst __P((ipstate_t *, struct in_addr, struct in_addr,
d124 1
d128 5
d142 2
a143 1
	fr_tcpclosed = 1,
d148 2
a149 1
int	fr_state_doflush = 0;
d151 1
d155 2
d162 9
d179 1
a192 1
	register int i;
d200 13
a212 8
	WRITE_ENTER(&ipf_state);
	for (i = fr_statesize - 1; i >= 0; i--)
		for (isp = &ips_table[i]; (is = *isp); ) {
			delete = 0;

			switch (which)
			{
			case 0 :
d214 2
a215 9
				break;
			case 1 :
				if (is->is_p != IPPROTO_TCP)
					break;
				if ((is->is_state[0] != TCPS_ESTABLISHED) ||
				    (is->is_state[1] != TCPS_ESTABLISHED))
					delete = 1;
				break;
			}
d217 5
a221 8
			if (delete) {
				*isp = is->is_next;
				if (is->is_p == IPPROTO_TCP)
					ips_stats.iss_fin++;
				else
					ips_stats.iss_expire++;
				if (ips_table[i] == NULL)
					ips_stats.iss_inuse--;
d223 1
a223 1
				ipstate_log(is, ISL_FLUSH);
d225 5
a229 7
				fr_delstate(is);
				ips_num--;
				removed++;
			} else
				isp = &is->is_next;
		}
	RWLOCK_EXIT(&ipf_state);
d235 31
d275 1
a275 1
	int	arg, ret, error = 0;
d279 3
d283 3
a285 1
		IRCOPY(data, (caddr_t)&arg, sizeof(arg));
d287 1
d289 2
a290 1
			IWCOPY((caddr_t)&ret, data, sizeof(ret));
d306 3
a308 2
	case SIOCGIPST :
		IWCOPY((caddr_t)fr_statetstats(), data, sizeof(ips_stat_t));
d312 2
a313 2
		IWCOPY((caddr_t)&iplused[IPL_LOGSTATE], (caddr_t)data,
		       sizeof(iplused[IPL_LOGSTATE]));
d316 17
d341 151
d500 1
d505 1
d507 2
a508 1
	if ((ip->ip_off & IP_OFFMASK) || (fin->fin_fi.fi_fl & FI_SHORT))
d515 1
d524 17
a540 3
	hv = (is->is_p = ip->ip_p);
	hv += (is->is_src.s_addr = ip->ip_src.s_addr);
	hv += (is->is_dst.s_addr = ip->ip_dst.s_addr);
d542 1
a542 1
	switch (ip->ip_p)
d544 3
d551 5
d558 3
a560 2
		case ICMP_ECHO :
			is->is_icmp.ics_type = ICMP_ECHOREPLY;	/* XXX */
d564 7
d574 3
a576 1
			is->is_icmp.ics_type = ic->icmp_type + 1;
d581 1
a581 1
		ATOMIC_INC(ips_stats.iss_icmp);
d587 1
a587 1
		register tcphdr_t *tcp = (tcphdr_t *)fin->fin_dp;
d601 5
a605 7
		if (tcp->th_seq != 0) {
			is->is_send = ntohl(tcp->th_seq) + ip->ip_len -
				      fin->fin_hlen - (tcp->th_off << 2) +
				      ((tcp->th_flags & TH_SYN) ? 1 : 0) +
				      ((tcp->th_flags & TH_FIN) ? 1 : 0);
			is->is_maxsend = is->is_send + 1;
		}
d607 1
d616 1
a616 5
		MUTEX_ENTER(&ipf_rw);
		ips_stats.iss_tcp++;
		fr_tcp_age(&is->is_age, is->is_state, ip, fin,
			   tcp->th_sport == is->is_sport);
		MUTEX_EXIT(&ipf_rw);
d621 1
a621 1
		register tcphdr_t *tcp = (tcphdr_t *)fin->fin_dp;
d629 1
a629 1
		ATOMIC_INC(ips_stats.iss_udp);
d639 1
a639 1
		ATOMIC_INC(ips_stats.iss_nomem);
d644 1
d647 1
a647 1
		ATOMIC_INC(is->is_rule->fr_ref);
d655 1
a655 1
	is->is_bytes = ip->ip_len;
d661 1
d670 7
a676 3
	is->is_flags |= flags & (FI_W_DPORT|FI_W_SPORT);
#ifdef  _KERNEL
	strncpy(is->is_ifname[fin->fin_out], IFNAME(fin->fin_ifp), IFNAMSIZ);
d678 1
a678 15
	is->is_ifname[1 - fin->fin_out][0] = '\0';
	/*
	 * add into table.
	 */
	is->is_next = ips_table[hv];
	ips_table[hv] = is;
	if (is->is_next == NULL)
		ips_stats.iss_inuse++;
	if (fin->fin_out) {
		is->is_ifpin = NULL;
		is->is_ifpout = fin->fin_ifp;
	} else {
		is->is_ifpin = fin->fin_ifp;
		is->is_ifpout = NULL;
	}
d681 7
a687 1
	ATOMIC_INC(ips_num);
d692 1
a692 1
	fin->fin_rev = (is->is_dst.s_addr != ip->ip_dst.s_addr);
d721 1
a721 1
	source = (ip->ip_src.s_addr == is->is_src.s_addr);
d727 1
a727 1
	end = seq + ip->ip_len - fin->fin_hlen - (tcp->th_off << 2) +
d731 1
a742 3
		win = 1;
		if ((tcp->th_flags == TH_SYN) && (tdata->td_maxwin == 0))
			 tdata->td_maxwin = 1;
d791 1
a791 3
		ATOMIC_INC(ips_stats.iss_hits);
		is->is_pkts++;
		is->is_bytes += ip->ip_len;
d795 2
a796 3
		MUTEX_ENTER(&ipf_rw);
		fr_tcp_age(&is->is_age, is->is_state, ip, fin, source);
		MUTEX_EXIT(&ipf_rw);
d799 1
d806 1
a806 1
struct in_addr src, dst;
d814 1
a814 1
	rev = fin->fin_rev = (is->is_dst.s_addr != dst.s_addr);
d823 1
a823 1
		flags = 0;
d850 3
a852 2
		if ((is->is_dst.s_addr == dst.s_addr) &&
		    (is->is_src.s_addr == src.s_addr) &&
d858 3
a860 2
		if ((is->is_dst.s_addr == src.s_addr) &&
		    (is->is_src.s_addr == dst.s_addr) &&
d903 1
d906 2
d911 1
a911 1
				is->is_ifpout = ifp;
d914 1
a914 1
				is->is_ifpin = ifp;
d919 1
a919 1
				is->is_ifpin = ifp;
d922 1
a922 1
				is->is_ifpout = ifp;
d925 8
d942 31
a972 1
frentry_t *fr_checkicmpmatchingstate(ip, fin)
a975 1
	register struct in_addr	dst, src;
d979 1
d984 1
a985 1
	int type, len;
d995 2
a996 1
	if ((ip->ip_hl != 5) || (ip->ip_len < ICMPERR_MINPKTLEN))
d998 1
a998 1
	ic = (struct icmp *)((char *)ip + fin->fin_hlen);
d1008 2
a1009 2
	oip = (ip_t *)((char *)fin->fin_dp + ICMPERR_ICMPHLEN);
	if (ip->ip_len < ICMPERR_MAXPKTLEN + ((oip->ip_hl - 5) << 2))
d1013 1
a1013 1
	 * Sanity Checks.
d1044 8
a1052 1

a1070 1

d1072 6
a1077 6
		hv += (src.s_addr = oip->ip_src.s_addr);
		hv += (dst.s_addr = oip->ip_dst.s_addr);
		if (icmp->icmp_type == ICMP_ECHO) {
			hv += icmp->icmp_id;
			hv += icmp->icmp_seq;
		}
d1082 1
d1090 10
a1099 20
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_next)
			if ((is->is_p == pr) &&
			    fr_matchsrcdst(is, src, dst, &ofin, NULL)) {
			    	/*
			    	 * in the state table ICMP query's are stored
			    	 * with the type of the corresponding ICMP
			    	 * response. Correct here
			    	 */
				if (((is->is_type == ICMP_ECHOREPLY) &&
				     (icmp->icmp_id == is->is_icmp.ics_id) &&
				     (icmp->icmp_seq == is->is_icmp.ics_seq) &&
				     (icmp->icmp_type == ICMP_ECHO)) ||
				    (is->is_type - 1 == ic->icmp_type)) {
				    	ips_stats.iss_hits++;
    		                        is->is_pkts++;
                	                is->is_bytes += ip->ip_len;
					fr = is->is_rule;
					RWLOCK_EXIT(&ipf_state);
					return fr;
				}
d1113 4
a1116 2
	hv += (src.s_addr = oip->ip_src.s_addr);
	hv += (dst.s_addr = oip->ip_dst.s_addr);
d1132 1
d1139 1
a1139 1
	for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_next) {
d1147 1
a1147 1
		if ((is->is_p == pr) &&
a1150 4
			/*
			 * we must swap src and dst here because the icmp
			 * comes the other way around
			 */
d1152 1
a1152 1
			is->is_bytes += ip->ip_len;
d1166 33
d1206 1
a1206 1
	register struct in_addr dst, src;
d1209 1
a1209 1
	u_int hv, hvm, hlen, tryagain, pass;
d1214 2
a1215 1
	if ((ip->ip_off & IP_OFFMASK) || (fin->fin_fi.fi_fl & FI_SHORT))
d1222 5
a1226 3
	hv = (pr = ip->ip_p);
	hv += (src.s_addr = ip->ip_src.s_addr);
	hv += (dst.s_addr = ip->ip_dst.s_addr);
d1231 2
a1232 1
	switch (ip->ip_p)
d1234 14
d1249 1
a1249 2
		if ((ic->icmp_type == ICMP_ECHO) ||
		    (ic->icmp_type == ICMP_ECHOREPLY)) {
d1255 4
a1258 10
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_next)
			if ((is->is_p == pr) &&
			    fr_matchsrcdst(is, src, dst, fin, NULL)) {
				if ((is->is_type == ICMP_ECHOREPLY) &&
				    (ic->icmp_type == ICMP_ECHO) &&
				    (ic->icmp_id == is->is_icmp.ics_id) &&
				    (ic->icmp_seq == is->is_icmp.ics_seq))
					;
				else if (is->is_type != ic->icmp_type)
					continue;
d1262 1
d1270 6
a1275 1
		fr = fr_checkicmpmatchingstate(ip, fin);
d1281 1
a1281 1
		register u_short dport = tcp->th_dport, sport = tcp->th_sport;
d1291 3
d1295 4
a1298 1
retry_tcp:
d1300 2
a1301 4
		WRITE_ENTER(&ipf_state);
		for (isp = &ips_table[hvm]; (is = *isp);
		     isp = &is->is_next)
			if ((is->is_p == pr) &&
d1303 3
a1305 8
				if (fr_tcpstate(is, fin, ip, tcp)) {
#ifndef	_KERNEL
					if (tcp->th_flags & TCP_CLOSE) {
						*isp = is->is_next;
						isp = &ips_table[hvm];
						if (ips_table[hvm] == NULL)
							ips_stats.iss_inuse--;
						ips_num--;
a1306 2
#endif
					break;
a1307 1
				is = NULL;
d1310 8
a1317 1
		if (is != NULL)
a1318 6
		RWLOCK_EXIT(&ipf_state);
		hv += dport;
		hv += sport;
		if (tryagain == 0) {
			tryagain = 1;
			goto retry_tcp;
a1319 21
		break;
	    }
	case IPPROTO_UDP :
	    {
		register u_short dport = tcp->th_dport, sport = tcp->th_sport;

		tryagain = 0;
retry_udp:
		hvm = hv % fr_statesize;
		/*
		 * Nothing else to match on but ports. and IP#'s
		 */
		READ_ENTER(&ipf_state);
		for (is = ips_table[hvm]; is; is = is->is_next)
			if ((is->is_p == pr) &&
			    fr_matchsrcdst(is, src, dst, fin, tcp)) {
				is->is_age = fr_udptimeout;
				break;
			}
		if (is != NULL)
			break;
d1321 3
a1323 3
		hv += dport;
		hv += sport;
		if (tryagain == 0) {
d1325 2
a1326 1
			goto retry_udp;
d1334 1
a1334 1
		ATOMIC_INC(ips_stats.iss_miss);
d1337 2
a1338 2
	MUTEX_ENTER(&ipf_rw);
	is->is_bytes += ip->ip_len;
d1341 1
a1341 1
	MUTEX_EXIT(&ipf_rw);
d1356 22
d1383 11
d1396 2
a1397 2
		ATOMIC_DEC(fr->fr_ref);
		if (fr->fr_ref == 0)
d1399 1
d1401 3
d1405 1
d1414 1
a1414 2
	register int i;
	register ipstate_t *is, **isp;
d1417 2
a1418 6
	for (i = fr_statesize - 1; i >= 0; i--)
		for (isp = &ips_table[i]; (is = *isp); ) {
			*isp = is->is_next;
			fr_delstate(is);
			ips_num--;
		}
a1432 1
	register int i;
d1440 6
a1445 10
	for (i = fr_statesize - 1; i >= 0; i--)
		for (isp = &ips_table[i]; (is = *isp); )
			if (is->is_age && !--is->is_age) {
				*isp = is->is_next;
				if (is->is_p == IPPROTO_TCP)
					ips_stats.iss_fin++;
				else
					ips_stats.iss_expire++;
				if (ips_table[i] == NULL)
					ips_stats.iss_inuse--;
d1447 1
a1447 1
				ipstate_log(is, ISL_EXPIRE);
d1449 3
a1451 4
				fr_delstate(is);
				ips_num--;
			} else
				isp = &is->is_next;
d1464 21
d1486 1
a1486 1
void fr_tcp_age(age, state, ip, fin, dir)
a1488 1
ip_t *ip;
d1498 1
a1498 1
	dlen = ip->ip_len - fin->fin_hlen - (tcp->th_off << 2);
d1511 1
a1511 1
	*age = fr_tcptimeout; /* 1 min */
d1515 20
a1534 1
	case TCPS_CLOSED:
d1536 1
d1540 34
a1573 2
	case TCPS_FIN_WAIT_2:
		if ((flags & TH_OPENING) == TH_OPENING)
d1575 2
a1576 2
		else if (flags & TH_SYN)
			state[dir] = TCPS_SYN_SENT;
d1578 8
a1585 3
	case TCPS_SYN_RECEIVED:
	case TCPS_SYN_SENT:
		if ((flags & (TH_FIN|TH_ACK)) == TH_ACK) {
d1588 8
a1595 7
		} else if ((flags & (TH_FIN|TH_ACK)) == (TH_FIN|TH_ACK)) {
			state[dir] = TCPS_CLOSE_WAIT;
			if (!(flags & TH_PUSH) && !dlen &&
			    ostate > TCPS_ESTABLISHED)
				*age  = fr_tcplastack;
			else
				*age  = fr_tcpclosewait;
d1598 2
a1599 1
	case TCPS_ESTABLISHED:
d1601 24
a1624 8
			state[dir] = TCPS_CLOSE_WAIT;
			if (!(flags & TH_PUSH) && !dlen &&
			    ostate > TCPS_ESTABLISHED)
				*age  = fr_tcplastack;
			else
				*age  = fr_tcpclosewait;
		} else {
			if (ostate < TCPS_CLOSE_WAIT)
d1628 7
a1634 3
	case TCPS_CLOSE_WAIT:
		if ((flags & TH_FIN) && !(flags & TH_PUSH) && !dlen &&
		    ostate > TCPS_ESTABLISHED) {
d1637 24
d1662 6
a1667 1
			*age  = fr_tcpclosewait;
d1669 6
a1674 1
	case TCPS_LAST_ACK:
d1676 5
a1680 3
			state[dir] = TCPS_FIN_WAIT_2;
			if (!(flags & TH_PUSH) && !dlen &&
			    ostate > TCPS_ESTABLISHED)
a1681 4
			else {
				*age  = fr_tcpclosewait;
				state[dir] = TCPS_CLOSE_WAIT;
			}
d1683 14
d1718 1
d1742 4
a1745 2
void ip_statesync(ifp)
void *ifp;
d1747 64
a1810 2
	register ipstate_t *is;
	register int i;
d1812 19
a1830 12
	WRITE_ENTER(&ipf_state);
	for (i = fr_statesize - 1; i >= 0; i--)
		for (is = ips_table[i]; is != NULL; is = is->is_next) {
			if (is->is_ifpin == ifp) {
				is->is_ifpin = GETUNIT(is->is_ifname[0]);
				if (!is->is_ifpin)
					is->is_ifpin = (void *)-1;
			}
			if (is->is_ifpout == ifp) {
				is->is_ifpout = GETUNIT(is->is_ifname[1]);
				if (!is->is_ifpout)
					is->is_ifpout = (void *)-1;
d1832 63
d1896 1
d1898 1
d1900 1
@


1.23.2.1
log
@Pull in patch
Fix (fgsch):
fix ipf fragment caching bug
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.23 2000/08/10 05:50:26 kjell Exp $	*/
d432 1
a432 1
	if ((fin->fin_fi.fi_fl & FI_FRAG) && (pass & FR_KEEPFRAG))
d1026 1
a1026 1
	if ((fin->fin_fi.fi_fl & FI_FRAG) && (pass & FR_KEEPFRAG))
@


1.22
log
@Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
  RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.21 2000/05/01 06:16:47 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.3.2.25 2000/05/22 06:57:53 darrenr Exp $";
d155 1
a155 1
 *              stuck for some reason.
d682 1
d685 1
a685 1
	icmphdr_t *icmp;
a687 1
	int type;
d711 32
d773 2
a774 1
		oip->ip_len = ntohs(oip->ip_len);
d776 1
a776 1
		oip->ip_len = htons(oip->ip_len);
d831 1
a831 1
	oip->ip_len = ip->ip_len - (ip->ip_hl << 2) - ICMPERR_ICMPHLEN;
d935 1
d937 7
@


1.21
log
@Update to ipfilter 3.3.13. This should be the last of the 3.3.x releases.
This patch fixes mostly ICMP timeout problems, as the ftp proxy
changes were imported previously.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.20 2000/03/13 23:40:18 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.3.2.23 2000/04/25 16:21:16 darrenr Exp $";
d235 6
a240 2
		else
			*(int *)data = ipflog_clear(IPL_LOGSTATE);
d321 2
@


1.21.2.1
log
@Pull in patch from current:
Errata:
A misuse of ipf(8) keep-state rules can result in firewall rules being bypassed.
Fix (kjell):
Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.22 2000/05/24 21:59:11 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.3.2.25 2000/05/22 06:57:53 darrenr Exp $";
d235 2
a236 6
		else {
			int tmp;

			tmp = ipflog_clear(IPL_LOGSTATE);
			IWCOPY((char *)&tmp, data, sizeof(tmp));
		}
a316 2
		if (tcp->th_flags & TH_RST)
			return NULL;
@


1.20
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.3.2.22 2000/02/23 15:23:24 darrenr Exp $";
d33 1
a33 1
#if defined(KERNEL) && (__FreeBSD_version >= 220000)
@


1.19
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.3.2.21 2000/02/15 08:04:01 darrenr Exp $";
a382 1
	is->is_rout = pass & FR_OUTQUE ? 1 : 0;
d567 1
a567 1
			if (is->is_ifpin == ifp)
d575 1
a575 1
			if (is->is_ifpin == ifp)
d641 1
a641 1
		if (out && (out == is->is_rout)) {
d649 1
a649 1
		if (!out && (out != is->is_rout)) {
@


1.18
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.3.2.18 2000/01/27 08:51:30 darrenr Exp $";
a374 1
	RW_UPGRADE(&ipf_mutex);
d377 1
a377 1
		is->is_rule->fr_ref++;
a380 1
	MUTEX_DOWNGRADE(&ipf_mutex);
d401 4
d658 6
a912 1
						fr_delstate(is);
d975 4
d1208 10
a1217 4
			if (is->is_ifpin == ifp)
				is->is_ifpin = NULL;
			if (is->is_ifpout == ifp)
				is->is_ifpout = NULL;
@


1.18.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.19 2000/02/16 22:34:20 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.3.2.21 2000/02/15 08:04:01 darrenr Exp $";
d375 1
d378 1
a378 1
		ATOMIC_INC(is->is_rule->fr_ref);
d382 1
a402 4
#ifdef  _KERNEL
	strncpy(is->is_ifname[fin->fin_out], IFNAME(fin->fin_ifp), IFNAMSIZ);
#endif
	is->is_ifname[1 - fin->fin_out][0] = '\0';
a655 6
#ifdef  _KERNEL
	if (ret >= 0) {
		strncpy(is->is_ifname[out], IFNAME(fin->fin_ifp),
			sizeof(is->is_ifname[1]));
	}
#endif
d905 1
a967 4
#ifndef	_KERNEL
	if (tcp->th_flags & TCP_CLOSE)
		fr_delstate(is);
#endif
d1197 4
a1200 10
			if (is->is_ifpin == ifp) {
				is->is_ifpin = GETUNIT(is->is_ifname[0]);
				if (!is->is_ifpin)
					is->is_ifpin = (void *)-1;
			}
			if (is->is_ifpout == ifp) {
				is->is_ifpout = GETUNIT(is->is_ifname[1]);
				if (!is->is_ifpout)
					is->is_ifpout = (void *)-1;
			}
@


1.18.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.3.2.22 2000/02/23 15:23:24 darrenr Exp $";
d383 1
d568 1
a568 1
			if (is->is_ifpin == NULL || is->is_ifpin == ifp)
d576 1
a576 1
			if (is->is_ifpin == NULL || is->is_ifpin == ifp)
d642 1
a642 1
		if (out) {
d650 1
a650 1
		if (out) {
@


1.18.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.27 2001/04/07 01:06:28 fgsch Exp $	*/
d4 1
a4 1
 * Copyright (C) 1995-2001 by Darren Reed.
d11 2
a12 2
static const char sccsid[] = "@@(#)ip_state.c	1.8 6/5/96 (C) 1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ip_state.c,v 2.30.2.30 2001/04/06 12:31:21 darrenr Exp $";
a22 4
#if defined(_KERNEL) && defined(__FreeBSD_version) && \
    (__FreeBSD_version >= 400000) && !defined(KLD_MODULE)
#include "opt_inet6.h"
#endif
d33 1
a33 1
#if (defined(KERNEL) || defined(_KERNEL)) && (__FreeBSD_version >= 220000)
d48 1
a48 1
#if (defined(_KERNEL) || defined(KERNEL)) && !defined(linux)
a86 3
#ifdef	USE_INET6
#include <netinet/icmp6.h>
#endif
d101 3
a103 5
static ipstate_t **ips_table = NULL;
static ipstate_t *ips_list = NULL;
static int	ips_num = 0;
static int	ips_wild = 0;
static ips_stat_t ips_stats;
d109 1
a109 4
#ifdef	USE_INET6
static frentry_t *fr_checkicmp6matchingstate __P((ip6_t *, fr_info_t *));
#endif
static int fr_matchsrcdst __P((ipstate_t *, union i6addr, union i6addr,
a111 1
static int fr_matchicmpqueryreply __P((int, ipstate_t *, icmphdr_t *));
a114 5
static int fr_state_remove __P((caddr_t));
static void fr_ipsmove __P((ipstate_t **, ipstate_t *, u_int));
int fr_stputent __P((caddr_t));
int fr_stgetent __P((caddr_t));
void fr_stinsert __P((ipstate_t *));
d124 1
a124 2
	fr_tcpclosed = 120,
	fr_tcphalfclosed = 2 * 2 * 3600,    /* 2 hours */
d126 1
a126 3
	fr_udpacktimeout = 24,
	fr_icmptimeout = 120,
	fr_icmpacktimeout = 12;
d129 1
a129 2
int	fr_state_doflush = 0,
	fr_state_lock = 0;
a130 1
static 	int icmpreplytype4[ICMP_MAXTYPE + 1];
a133 2
	int i;

a138 9

	/* fill icmp reply type table */
	for (i = 0; i <= ICMP_MAXTYPE; i++)
		icmpreplytype4[i] = -1;
	icmpreplytype4[ICMP_ECHO] = ICMP_ECHOREPLY;
	icmpreplytype4[ICMP_TSTAMP] = ICMP_TSTAMPREPLY;
	icmpreplytype4[ICMP_IREQ] = ICMP_IREQREPLY;
	icmpreplytype4[ICMP_MASKREQ] = ICMP_MASKREPLY;

a146 1
	ips_stats.iss_list = ips_list;
d155 1
a155 1
 *	        stuck for some reason.
d160 1
d168 16
a183 10
	for (isp = &ips_list; (is = *isp); ) {
		delete = 0;

		switch (which)
		{
		case 0 :
			delete = 1;
			break;
		case 1 :
			if (is->is_p != IPPROTO_TCP)
d185 1
a185 5
			if ((is->is_state[0] != TCPS_ESTABLISHED) ||
			    (is->is_state[1] != TCPS_ESTABLISHED))
				delete = 1;
			break;
		}
d187 8
a194 5
		if (delete) {
			if (is->is_p == IPPROTO_TCP)
				ips_stats.iss_fin++;
			else
				ips_stats.iss_expire++;
d196 1
a196 1
			ipstate_log(is, ISL_FLUSH);
d198 7
a204 5
			fr_delstate(is);
			removed++;
		} else
			isp = &is->is_next;
	}
a209 31
static int fr_state_remove(data)
caddr_t data;
{
	ipstate_t *sp, st;
	int error;

	sp = &st;
	error = IRCOPYPTR(data, (caddr_t)&st, sizeof(st));
	if (error)
		return EFAULT;

	for (sp = ips_list; sp; sp = sp->is_next)
		if ((sp->is_p == st.is_p) && (sp->is_v == st.is_v) &&
		    !bcmp((char *)&sp->is_src, (char *)&st.is_src,
			  sizeof(st.is_src)) &&
		    !bcmp((char *)&sp->is_dst, (char *)&st.is_src,
			  sizeof(st.is_dst)) &&
		    !bcmp((char *)&sp->is_ps, (char *)&st.is_ps,
			  sizeof(st.is_ps))) {
			WRITE_ENTER(&ipf_state);
#ifdef	IPFILTER_LOG
			ipstate_log(sp, ISL_REMOVE);
#endif
			fr_delstate(sp);
			RWLOCK_EXIT(&ipf_state);
			return 0;
		}
	return ESRCH;
}


d219 1
a219 1
	int arg, ret, error = 0;
a222 3
	case SIOCDELST :
		error = fr_state_remove(data);
		break;
d224 1
a224 3
		error = IRCOPY(data, (caddr_t)&arg, sizeof(arg));
		if (error)
			break;
a225 1
			WRITE_ENTER(&ipf_state);
d227 1
a227 2
			RWLOCK_EXIT(&ipf_state);
			error = IWCOPY((caddr_t)&ret, data, sizeof(ret));
d235 2
a236 6
		else {
			int tmp;

			tmp = ipflog_clear(IPL_LOGSTATE);
			IWCOPY((char *)&tmp, data, sizeof(tmp));
		}
d239 2
a240 3
	case SIOCGETFS :
		error = IWCOPYPTR((caddr_t)fr_statetstats(), data,
				  sizeof(ips_stat_t));
d244 2
a245 2
		arg = (int)iplused[IPL_LOGSTATE];
		error = IWCOPY((caddr_t)&arg, (caddr_t)data, sizeof(arg));
a247 17
	case SIOCSTLCK :
		error = fr_lock(data, &fr_state_lock);
		break;
	case SIOCSTPUT :
		if (!fr_state_lock) {
			error = EACCES;
			break;
		}
		error = fr_stputent(data);
		break;
	case SIOCSTGET :
		if (!fr_state_lock) {
			error = EACCES;
			break;
		}
		error = fr_stgetent(data);
		break;
a255 151
int fr_stgetent(data)
caddr_t data;
{
	register ipstate_t *is, *isn;
	ipstate_save_t ips, *ipsp;
	int error;

	error = IRCOPY(data, (caddr_t)&ipsp, sizeof(ipsp));
	if (error)
		return EFAULT;
	error = IRCOPY((caddr_t)ipsp, (caddr_t)&ips, sizeof(ips));
	if (error)
		return EFAULT;

	isn = ips.ips_next;
	if (!isn) {
		isn = ips_list;
		if (isn == NULL) {
			if (ips.ips_next == NULL)
				return ENOENT;
			return 0;
		}
	} else {
		/*
		 * Make sure the pointer we're copying from exists in the
		 * current list of entries.  Security precaution to prevent
		 * copying of random kernel data.
		 */
		for (is = ips_list; is; is = is->is_next)
			if (is == isn)
				break;
		if (!is)
			return ESRCH;
	}
	ips.ips_next = isn->is_next;
	bcopy((char *)isn, (char *)&ips.ips_is, sizeof(ips.ips_is));
	if (isn->is_rule)
		bcopy((char *)isn->is_rule, (char *)&ips.ips_fr,
		      sizeof(ips.ips_fr));
	error = IWCOPY((caddr_t)&ips, ipsp, sizeof(ips));
	if (error)
		error = EFAULT;
	return error;
}


int fr_stputent(data)
caddr_t data;
{
	register ipstate_t *is, *isn;
	ipstate_save_t ips, *ipsp;
	int error, out;
	frentry_t *fr;

	error = IRCOPY(data, (caddr_t)&ipsp, sizeof(ipsp));
	if (error)
		return EFAULT;
	error = IRCOPY((caddr_t)ipsp, (caddr_t)&ips, sizeof(ips));
	if (error)
		return EFAULT;

	KMALLOC(isn, ipstate_t *);
	if (isn == NULL)
		return ENOMEM;

	bcopy((char *)&ips.ips_is, (char *)isn, sizeof(*isn));
	fr = isn->is_rule;
	if (fr != NULL) {
		if (isn->is_flags & FI_NEWFR) {
			KMALLOC(fr, frentry_t *);
			if (fr == NULL) {
				KFREE(isn);
				return ENOMEM;
			}
			bcopy((char *)&ips.ips_fr, (char *)fr, sizeof(*fr));
			out = fr->fr_flags & FR_OUTQUE ? 1 : 0;
			isn->is_rule = fr;
			ips.ips_is.is_rule = fr;
			if (*fr->fr_ifname) {
				fr->fr_ifa = GETUNIT(fr->fr_ifname, fr->fr_v);
				if (fr->fr_ifa == NULL)
					fr->fr_ifa = (void *)-1;
#ifdef	_KERNEL
				else {
					strncpy(isn->is_ifname[out],
						IFNAME(fr->fr_ifa), IFNAMSIZ);
					isn->is_ifp[out] = fr->fr_ifa;
				}
#endif
			} else
				fr->fr_ifa = NULL;
			/*
			 * send a copy back to userland of what we ended up
			 * to allow for verification.
			 */
			error = IWCOPY((caddr_t)&ips, ipsp, sizeof(ips));
			if (error) {
				KFREE(isn);
				KFREE(fr);
				return EFAULT;
			}
		} else {
			for (is = ips_list; is; is = is->is_next)
				if (is->is_rule == fr)
					break;
			if (!is) {
				KFREE(isn);
				return ESRCH;
			}
		}
	}
	fr_stinsert(isn);
	return 0;
}


void fr_stinsert(is)
register ipstate_t *is;
{
	register u_int hv = is->is_hv;

	MUTEX_INIT(&is->is_lock, "ipf state entry", NULL);

	is->is_ifname[0][sizeof(is->is_ifname[0]) - 1] = '\0';
	if (is->is_ifname[0][0] != '\0') {
		is->is_ifp[0] = GETUNIT(is->is_ifname[0], is->is_v);
	}
	is->is_ifname[1][sizeof(is->is_ifname[0]) - 1] = '\0';
	if (is->is_ifname[1][0] != '\0') {
		is->is_ifp[1] = GETUNIT(is->is_ifname[1], is->is_v);
	}

	/*
	 * add into list table.
	 */
	if (ips_list)
		ips_list->is_pnext = &is->is_next;
	is->is_pnext = &ips_list;
	is->is_next = ips_list;
	ips_list = is;
	if (ips_table[hv])
		ips_table[hv]->is_phnext = &is->is_hnext;
	else
		ips_stats.iss_inuse++;
	is->is_phnext = ips_table + hv;
	is->is_hnext = ips_table[hv];
	ips_table[hv] = is;
	ips_num++;
}


a263 1
	register tcphdr_t *tcp = NULL;
a267 1
	int out;
d269 1
a269 2
	if (fr_state_lock || (fin->fin_off & IP_OFFMASK) ||
	    (fin->fin_fi.fi_fl & FI_SHORT))
a275 1
	out = fin->fin_out;
d284 3
a286 17
	hv = (is->is_p = fin->fin_fi.fi_p);
	is->is_src = fin->fin_fi.fi_src;
	hv += is->is_saddr;
	is->is_dst = fin->fin_fi.fi_dst;
	hv += is->is_daddr;
#ifdef	USE_INET6
	if (fin->fin_v == 6) {
		if (is->is_p == IPPROTO_ICMPV6) {
			if (IN6_IS_ADDR_MULTICAST(&is->is_dst.in6))
				flags |= FI_W_DADDR;
			if (out)
				hv -= is->is_daddr;
			else
				hv -= is->is_saddr;
		}
	}
#endif
d288 1
a288 1
	switch (is->is_p)
a289 3
#ifdef	USE_INET6
	case IPPROTO_ICMPV6 :
#endif
a293 5
#ifdef	USE_INET6
		if ((is->is_p == IPPROTO_ICMPV6) &&
		    ((ic->icmp_type & ICMP6_INFOMSG_MASK) == 0))
			return NULL;
#endif
d296 2
a297 3
#ifdef	USE_INET6
		case ICMP6_ECHO_REQUEST :
			is->is_icmp.ics_type = ICMP6_ECHO_REPLY;
a300 7
		case ICMP6_MEMBERSHIP_QUERY :
		case ND_ROUTER_SOLICIT :
		case ND_NEIGHBOR_SOLICIT :
			is->is_icmp.ics_type = ic->icmp_type + 1;
			break;
#endif
		case ICMP_ECHO :
d304 1
a304 3
			is->is_icmp.ics_type = ic->icmp_type;
			hv += (is->is_icmp.ics_id = ic->icmp_id);
			hv += (is->is_icmp.ics_seq = ic->icmp_seq);
d309 1
a309 1
		ATOMIC_INCL(ips_stats.iss_icmp);
d315 1
a315 1
		tcp = (tcphdr_t *)fin->fin_dp;
a316 2
		if (tcp->th_flags & TH_RST)
			return NULL;
d327 7
a333 5
		is->is_send = ntohl(tcp->th_seq) + fin->fin_dlen -
			      (tcp->th_off << 2) +
			      ((tcp->th_flags & TH_SYN) ? 1 : 0) +
			      ((tcp->th_flags & TH_FIN) ? 1 : 0);
		is->is_maxsend = is->is_send;
a334 1
		is->is_maxdwin = 1;
d343 5
a347 1
		ATOMIC_INCL(ips_stats.iss_tcp);
d352 1
a352 1
		tcp = (tcphdr_t *)fin->fin_dp;
d360 1
a360 1
		ATOMIC_INCL(ips_stats.iss_udp);
d370 1
a370 1
		ATOMIC_INCL(ips_stats.iss_nomem);
a374 1
	is->is_hv = hv;
d377 1
a377 1
		ATOMIC_INC32(is->is_rule->fr_ref);
d385 1
a385 1
	is->is_bytes = fin->fin_dlen + fin->fin_hlen;
a390 1
	is->is_v = fin->fin_fi.fi_v;
d399 3
a401 7
	is->is_flags |= flags & (FI_WILDP|FI_WILDA);
	if (flags & (FI_WILDP|FI_WILDA))
		ips_wild++;
	is->is_ifp[1 - out] = NULL;
	is->is_ifp[out] = fin->fin_ifp;
#ifdef	_KERNEL
	strncpy(is->is_ifname[out], IFNAME(fin->fin_ifp), IFNAMSIZ);
d403 15
a417 1
	is->is_ifname[1 - out][0] = '\0';
d420 1
a420 7
	fr_stinsert(is);
	if (is->is_p == IPPROTO_TCP) {
		MUTEX_ENTER(&is->is_lock);
		fr_tcp_age(&is->is_age, is->is_state, fin,
			   0); /* 0 = packet from the source */
		MUTEX_EXIT(&is->is_lock);
	}
d425 2
a426 2
	fin->fin_rev = IP6NEQ(is->is_dst, fin->fin_fi.fi_dst);
	if ((fin->fin_fi.fi_fl & FI_FRAG) && (pass & FR_KEEPFRAG))
d454 1
a454 1
	source = IP6EQ(fin->fin_fi.fi_src, is->is_src);
d460 1
a460 1
	end = seq + fin->fin_dlen - (tcp->th_off << 2) +
a463 1
	MUTEX_ENTER(&is->is_lock);
d475 3
d526 3
a528 1
		ATOMIC_INCL(ips_stats.iss_hits);
d532 3
a534 2
		/* source ? 0 : 1 -> !source */
		fr_tcp_age(&is->is_age, is->is_state, fin, !source);
a536 1
	MUTEX_EXIT(&is->is_lock);
d543 1
a543 1
union i6addr src, dst;
d551 1
a551 1
	rev = fin->fin_rev = IP6NEQ(is->is_dst, dst);
d560 1
a560 1
		flags = is->is_flags & FI_WILDA;
d587 2
a588 3
		if (
		    (IP6EQ(is->is_dst, dst) || (flags & FI_W_DADDR)) &&
		    (IP6EQ(is->is_src, src) || (flags & FI_W_SADDR)) &&
d594 2
a595 3
		if (
		    (IP6EQ(is->is_dst, src) || (flags & FI_W_DADDR)) &&
		    (IP6EQ(is->is_src, dst) || (flags & FI_W_SADDR)) &&
a637 1
		ips_wild--;
a639 2
	ret = -1;

d643 1
a643 1
				ret = 1;
d646 1
a646 1
				ret = 0;
d651 1
a651 1
				ret = 0;
d654 1
a654 1
				ret = 1;
a656 8

	if (ret >= 0) {
		is->is_ifp[ret] = ifp;
#ifdef	_KERNEL
		strncpy(is->is_ifname[out], IFNAME(fin->fin_ifp),
			sizeof(is->is_ifname[1]));
#endif
	}
d666 1
a666 31
static int fr_matchicmpqueryreply(v, is, icmp)
int v;
ipstate_t *is;
icmphdr_t *icmp;
{
	if (v == 4) {
		/*
		 * If we matched its type on the way in, then when going out
		 * it will still be the same type.
		 */
		if (((icmp->icmp_type == is->is_type) ||
		     (icmpreplytype4[is->is_type] == icmp->icmp_type)) &&
		    (icmp->icmp_id == is->is_icmp.ics_id) &&
		    (icmp->icmp_seq == is->is_icmp.ics_seq)) {
			return 1;
		};
	}
#ifdef	USE_INET6
	else if (is->is_v == 6) {
		if ((is->is_type == ICMP6_ECHO_REPLY) &&
		    (icmp->icmp_type == ICMP6_ECHO_REQUEST) &&
		    (icmp->icmp_id == is->is_icmp.ics_id) &&
		    (icmp->icmp_seq == is->is_icmp.ics_seq)) {
			return 1;
		};
	}
#endif
	return 0;
}

static frentry_t *fr_checkicmpmatchingstate(ip, fin)
d670 1
a673 1
	union i6addr dst, src;
a675 1
	icmphdr_t *icmp;
a676 1
	int type, len;
d678 1
d681 1
d689 1
a689 2
	if (((ip->ip_v != 4) || (ip->ip_hl != 5)) ||
	    (fin->fin_plen < ICMPERR_MINPKTLEN))
d691 1
a691 1
	ic = (struct icmp *)fin->fin_dp;
d701 2
a702 2
	oip = (ip_t *)((char *)ic + ICMPERR_ICMPHLEN);
	if (fin->fin_plen < ICMPERR_MAXPKTLEN + ((oip->ip_hl - 5) << 2))
d705 1
a705 31
	/*
	 * Sanity checks.
	 */
	len = fin->fin_dlen - ICMPERR_ICMPHLEN;
	if ((len <= 0) || ((oip->ip_hl << 2) > len))
		return NULL;

	/*
	 * Is the buffer big enough for all of it ?  It's the size of the IP
	 * header claimed in the encapsulated part which is of concern.  It
	 * may be too big to be in this buffer but not so big that it's
	 * outside the ICMP packet, leading to TCP deref's causing problems.
	 * This is possible because we don't know how big oip_hl is when we
	 * do the pullup early in fr_check() and thus can't gaurantee it is
	 * all here now.
	 */
#ifdef  _KERNEL
	{
	mb_t *m;

# if SOLARIS
	m = fin->fin_qfm;
	if ((char *)oip + len > (char *)m->b_wptr)
		return NULL;
# else
	m = *(mb_t **)fin->fin_mp;
	if ((char *)oip + len > (char *)ip + m->m_len)
		return NULL;
# endif
	}
#endif
a706 9
	/*
	 * in the IPv4 case we must zero the i6addr union otherwise
	 * the IP6EQ and IP6NEQ macros produce the wrong results because
	 * of the 'junk' in the unused part of the union
	 */
	bzero((char *)&src, sizeof(src));
	bzero((char *)&dst, sizeof(dst));

	if (oip->ip_p == IPPROTO_ICMP) {
d725 1
d727 6
a732 6
		src.in4 = oip->ip_src;
		hv += src.in4.s_addr;
		dst.in4 = oip->ip_dst;
		hv += dst.in4.s_addr;
		hv += icmp->icmp_id;
		hv += icmp->icmp_seq;
d735 1
a735 3
		savelen = oip->ip_len;
		oip->ip_len = len;
		ofin.fin_v = 4;
d737 1
a737 1
		oip->ip_len = savelen;
d743 20
a762 10
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext)
			if ((is->is_p == pr) && (is->is_v == 4) &&
			    fr_matchsrcdst(is, src, dst, &ofin, NULL) &&
			    fr_matchicmpqueryreply(is->is_v, is, icmp)) {
				ips_stats.iss_hits++;
				is->is_pkts++;
				is->is_bytes += ip->ip_len;
				fr = is->is_rule;
				RWLOCK_EXIT(&ipf_state);
				return fr;
d776 2
a777 4
	src.in4 = oip->ip_src;
	hv += src.in4.s_addr;
	dst.in4 = oip->ip_dst;
	hv += dst.in4.s_addr;
d792 1
a792 2
	oip->ip_len = len;
	ofin.fin_v = 4;
d799 1
a799 1
	for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext) {
d807 1
a807 1
		if ((is->is_p == pr) && (is->is_v == 4) &&
d811 4
d816 1
a816 1
			is->is_bytes += fin->fin_plen;
a829 33

static void fr_ipsmove(isp, is, hv)
ipstate_t **isp, *is;
u_int hv;
{
	u_int hvm;

	hvm = is->is_hv;
	/*
	 * Remove the hash from the old location...
	 */
	if (is->is_hnext)
		is->is_hnext->is_phnext = isp;
	*isp = is->is_hnext;
	if (ips_table[hvm] == NULL)
		ips_stats.iss_inuse--;

	/*
	 * ...and put the hash in the new one.
	 */
	hvm = hv % fr_statesize;
	is->is_hv = hvm;
	isp = &ips_table[hvm];
	if (*isp)
		(*isp)->is_phnext = &is->is_hnext;
	else
		ips_stats.iss_inuse++;
	is->is_phnext = isp;
	is->is_hnext = *isp;
	*isp = is;
}


d837 1
a837 1
	union i6addr dst, src;
d840 1
a840 1
	u_int hv, hvm, hlen, tryagain, pass, v;
d845 1
a845 2
	if (fr_state_lock || (fin->fin_off & IP_OFFMASK) ||
	    (fin->fin_fi.fi_fl & FI_SHORT))
d852 3
a854 5
	hv = (pr = fin->fin_fi.fi_p);
	src = fin->fin_fi.fi_src;
	dst = fin->fin_fi.fi_dst;
	hv += src.in4.s_addr;
	hv += dst.in4.s_addr;
d859 1
a859 2
	v = fin->fin_fi.fi_v;
	switch (fin->fin_fi.fi_p)
a860 14
#ifdef	USE_INET6
	case IPPROTO_ICMPV6 :
		if (v == 6) {
			if (fin->fin_out)
				hv -= dst.in4.s_addr;
			else
				hv -= src.in4.s_addr;
			if ((ic->icmp_type == ICMP6_ECHO_REQUEST) ||
			    (ic->icmp_type == ICMP6_ECHO_REPLY)) {
				hv += ic->icmp_id;
				hv += ic->icmp_seq;
			}
		}
#endif
d862 2
a863 1
		if (v == 4) {
d869 11
a879 8
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext) {
			if ((is->is_p == pr) && (is->is_v == v) &&
			    fr_matchsrcdst(is, src, dst, fin, NULL) &&
			    fr_matchicmpqueryreply(v, is, ic)) {
				if (fin->fin_rev)
					is->is_age = fr_icmpacktimeout;
				else
					is->is_age = fr_icmptimeout;
a881 1
		}
d889 1
a889 6
#ifdef	USE_INET6
		if (v == 6)
			fr = fr_checkicmp6matchingstate((ip6_t *)ip, fin);
		else
#endif
			fr = fr_checkicmpmatchingstate(ip, fin);
d895 1
a895 2
		register u_short dport, sport;
		register int i;
a896 10
		i = tcp->th_flags;
		/*
		 * Just plain ignore RST flag set with either FIN or SYN.
		 */
		if ((i & TH_RST) &&
		    ((i & (TH_FIN|TH_SYN|TH_RST)) != TH_RST))
			break;
	case IPPROTO_UDP :
		dport = tcp->th_dport;
		sport = tcp->th_sport;
d898 1
a898 4
		hv += dport;
		hv += sport;
		READ_ENTER(&ipf_state);
retry_tcpudp:
d900 4
a903 2
		for (isp = &ips_table[hvm]; (is = *isp); isp = &is->is_hnext)
			if ((is->is_p == pr) && (is->is_v == v) &&
d905 8
a912 3
				if ((pr == IPPROTO_TCP)) {
					if (!fr_tcpstate(is, fin, ip, tcp)) {
						continue;
d914 2
a915 5
				} if ((pr == IPPROTO_UDP)) {
					if (fin->fin_rev)
						is->is_age = fr_udpacktimeout;
					else
						is->is_age = fr_udptimeout;
d917 1
d920 27
a946 7
		if (is != NULL) {
			if (tryagain &&
			    !(is->is_flags & (FI_WILDP|FI_WILDA))) {
				hv += dport;
				hv += sport;
				fr_ipsmove(isp, is, hv);
				MUTEX_DOWNGRADE(&ipf_state);
d948 1
a949 1
		}
d951 3
a953 3
		if (!tryagain && ips_wild) {
			hv -= dport;
			hv -= sport;
d955 1
a955 2
			WRITE_ENTER(&ipf_state);
			goto retry_tcpudp;
d963 1
a963 1
		ATOMIC_INCL(ips_stats.iss_miss);
d966 2
a967 2
	MUTEX_ENTER(&is->is_lock);
	is->is_bytes += fin->fin_plen;
d970 1
a970 1
	MUTEX_EXIT(&is->is_lock);
d979 1
a979 1
	if ((fin->fin_fi.fi_fl & FI_FRAG) && (pass & FR_KEEPFRAG))
a984 25
void ip_statesync(ifp)
void *ifp;
{
	register ipstate_t *is;

	WRITE_ENTER(&ipf_state);
	for (is = ips_list; is; is = is->is_next) {
		if (is->is_ifpin == ifp) {
			is->is_ifpin = GETUNIT(is->is_ifname[0], is->is_v);
			if (!is->is_ifpin)
				is->is_ifpin = (void *)-1;
		}
		if (is->is_ifpout == ifp) {
			is->is_ifpout = GETUNIT(is->is_ifname[1], is->is_v);
			if (!is->is_ifpout)
				is->is_ifpout = (void *)-1;
		}
	}
	RWLOCK_EXIT(&ipf_state);
}


/*
 * Must always be called with fr_ipfstate held as a write lock.
 */
a989 11
	if (is->is_flags & (FI_WILDP|FI_WILDA))
		ips_wild--;
	if (is->is_next)
		is->is_next->is_pnext = is->is_pnext;
	*is->is_pnext = is->is_next;
	if (is->is_hnext)
		is->is_hnext->is_phnext = is->is_phnext;
	*is->is_phnext = is->is_hnext;
	if (ips_table[is->is_hv] == NULL)
		ips_stats.iss_inuse--;

d992 2
a993 2
		fr->fr_ref--;
		if (fr->fr_ref == 0) {
a994 1
		}
a995 3
#ifdef	_KERNEL
	MUTEX_DESTROY(&is->is_lock);
#endif
a996 1
	ips_num--;
d1005 2
a1006 1
	register ipstate_t *is;
d1009 6
a1014 2
	while ((is = ips_list))
		fr_delstate(is);
d1029 1
d1037 10
a1046 6
	for (isp = &ips_list; (is = *isp); )
		if (is->is_age && !--is->is_age) {
			if (is->is_p == IPPROTO_TCP)
				ips_stats.iss_fin++;
			else
				ips_stats.iss_expire++;
d1048 1
a1048 1
			ipstate_log(is, ISL_EXPIRE);
d1050 6
a1055 3
			fr_delstate(is);
		} else
			isp = &is->is_next;
a1059 2
	RWLOCK_EXIT(&ipf_state);
	SPL_X(s);
a1065 21
 *
 * Rewritten by Arjan de Vet <Arjan.deVet@@adv.iae.nl>, 2000-07-29:
 *
 * - (try to) base state transitions on real evidence only,
 *   i.e. packets that are sent and have been received by ipfilter;
 *   diagram 18.12 of TCP/IP volume 1 by W. Richard Stevens was used.
 *
 * - deal with half-closed connections correctly;
 *
 * - store the state of the source in state[0] such that ipfstat
 *   displays the state as source/dest instead of dest/source; the calls
 *   to fr_tcp_age have been changed accordingly.
 *
 * Parameters:
 *
 *    state[0] = state of source (host that initiated connection)
 *    state[1] = state of dest   (host that accepted the connection)
 *
 *    dir == 0 : a packet from source to dest
 *    dir == 1 : a packet from dest to source
 *
d1067 1
a1067 1
void fr_tcp_age(age, state, fin, dir)
d1070 1
d1080 1
a1080 1
	dlen = fin->fin_plen - fin->fin_hlen - (tcp->th_off << 2);
d1093 1
a1093 1
	*age = fr_tcptimeout; /* default 4 mins */
d1097 1
a1097 20
	case TCPS_CLOSED: /* 0 */
		if ((flags & TH_OPENING) == TH_OPENING) {
			/*
			 * 'dir' received an S and sends SA in response,
			 * CLOSED -> SYN_RECEIVED
			 */
			state[dir] = TCPS_SYN_RECEIVED;
			*age = fr_tcptimeout;
		} else if ((flags & (TH_SYN|TH_ACK)) == TH_SYN) {
			/* 'dir' sent S, CLOSED -> SYN_SENT */
			state[dir] = TCPS_SYN_SENT;
			*age = fr_tcptimeout;
		}
		/*
		 * The next piece of code makes it possible to get
		 * already established connections into the state table
		 * after a restart or reload of the filter rules; this
		 * does not work when a strict 'flags S keep state' is
		 * used for tcp connections of course
		 */
a1098 1
			/* we saw an A, guess 'dir' is in ESTABLISHED mode */
d1102 2
a1103 34
		/*
		 * TODO: besides regular ACK packets we can have other
		 * packets as well; it is yet to be determined how we
		 * should initialize the states in those cases
		 */
		break;

	case TCPS_LISTEN: /* 1 */
		/* NOT USED */
		break;

	case TCPS_SYN_SENT: /* 2 */
		if ((flags & (TH_SYN|TH_FIN|TH_ACK)) == TH_ACK) {
			/*
			 * We see an A from 'dir' which is in SYN_SENT
			 * state: 'dir' sent an A in response to an SA
			 * which it received, SYN_SENT -> ESTABLISHED
			 */
			state[dir] = TCPS_ESTABLISHED;
			*age = fr_tcpidletimeout;
		} else if (flags & TH_FIN) {
			/*
			 * We see an F from 'dir' which is in SYN_SENT
			 * state and wants to close its side of the
			 * connection; SYN_SENT -> FIN_WAIT_1
			 */
			state[dir] = TCPS_FIN_WAIT_1;
			*age = fr_tcpidletimeout; /* or fr_tcptimeout? */
		} else if ((flags & TH_OPENING) == TH_OPENING) {
			/*
			 * We see an SA from 'dir' which is already in
			 * SYN_SENT state, this means we have a
			 * simultaneous open; SYN_SENT -> SYN_RECEIVED
			 */
d1105 2
a1106 2
			*age = fr_tcptimeout;
		}
d1108 3
a1110 8

	case TCPS_SYN_RECEIVED: /* 3 */
		if ((flags & (TH_SYN|TH_FIN|TH_ACK)) == TH_ACK) {
			/*
			 * We see an A from 'dir' which was in SYN_RECEIVED
			 * state so it must now be in established state,
			 * SYN_RECEIVED -> ESTABLISHED
			 */
d1113 7
a1119 8
		} else if (flags & TH_FIN) {
			/*
			 * We see an F from 'dir' which is in SYN_RECEIVED
			 * state and wants to close its side of the connection;
			 * SYN_RECEIVED -> FIN_WAIT_1
			 */
			state[dir] = TCPS_FIN_WAIT_1;
			*age = fr_tcpidletimeout;
d1122 1
a1122 2

	case TCPS_ESTABLISHED: /* 4 */
d1124 8
a1131 24
			/*
			 * 'dir' closed its side of the connection; this
			 * gives us a half-closed connection;
			 * ESTABLISHED -> FIN_WAIT_1
			 */
			state[dir] = TCPS_FIN_WAIT_1;
			*age = fr_tcphalfclosed;
		} else if (flags & TH_ACK) {
			/* an ACK, should we exclude other flags here? */
			if (ostate == TCPS_FIN_WAIT_1) {
				/*
				 * We know the other side did an active close,
				 * so we are ACKing the recvd FIN packet (does
				 * the window matching code guarantee this?)
				 * and go into CLOSE_WAIT state; this gives us
				 * a half-closed connection
				 */
				state[dir] = TCPS_CLOSE_WAIT;
				*age = fr_tcphalfclosed;
			} else if (ostate < TCPS_CLOSE_WAIT)
				/*
				 * Still a fully established connection,
				 * reset timeout
				 */
d1135 3
a1137 7

	case TCPS_CLOSE_WAIT: /* 5 */
		if (flags & TH_FIN) {
			/*
			 * Application closed and 'dir' sent a FIN, we're now
			 * going into LAST_ACK state
			 */
a1139 24
		} else {
			/*
			 * We remain in CLOSE_WAIT because the other side has
			 * closed already and we did not close our side yet;
			 * reset timeout
			 */
			*age  = fr_tcphalfclosed;
		}
		break;

	case TCPS_FIN_WAIT_1: /* 6 */
		if ((flags & TH_ACK) && ostate > TCPS_CLOSE_WAIT) {
			/*
			 * If the other side is not active anymore it has sent
			 * us a FIN packet that we are ack'ing now with an ACK;
			 * this means both sides have now closed the connection
			 * and we go into TIME_WAIT
			 */
			/*
			 * XXX: how do we know we really are ACKing the FIN
			 * packet here? does the window code guarantee that?
			 */
			state[dir] = TCPS_TIME_WAIT;
			*age = fr_tcptimeout;
d1141 1
a1141 10
			/*
			 * We closed our side of the connection already but the
			 * other side is still active (ESTABLISHED/CLOSE_WAIT);
			 * continue with this half-closed connection
			 */
			*age = fr_tcphalfclosed;
		break;

	case TCPS_CLOSING: /* 7 */
		/* NOT USED */
d1143 1
a1143 2

	case TCPS_LAST_ACK: /* 8 */
d1145 3
a1147 5
			if ((flags & TH_PUSH) || dlen)
				/*
				 * There is still data to be delivered, reset
				 * timeout
				 */
d1149 4
a1153 14
		/*
		 * We cannot detect when we go out of LAST_ACK state to CLOSED
		 * because that is based on the reception of ACK packets;
		 * ipfilter can only detect that a packet has been sent by a
		 * host
		 */
		break;

	case TCPS_FIN_WAIT_2: /* 9 */
		/* NOT USED */
		break;

	case TCPS_TIME_WAIT: /* 10 */
		/* we're in 2MSL timeout now */
a1174 1
	ipsl.isl_v = is->is_v;
d1198 2
a1199 4
#ifdef	USE_INET6
frentry_t *fr_checkicmp6matchingstate(ip, fin)
ip6_t *ip;
fr_info_t *fin;
d1201 2
a1202 12
	register ipstate_t *is, **isp;
	register u_short sport, dport;
	register u_char	pr;
	struct icmp6_hdr *ic, *oic;
	union i6addr dst, src;
	u_short savelen;
	fr_info_t ofin;
	tcphdr_t *tcp;
	frentry_t *fr;
	ip6_t *oip;
	int type;
	u_int hv;
d1204 12
a1215 71
	/*
	 * Does it at least have the return (basic) IP header ?
	 * Only a basic IP header (no options) should be with
	 * an ICMP error header.
	 */
	if ((fin->fin_v != 6) || (fin->fin_plen < ICMP6ERR_MINPKTLEN))
		return NULL;
	ic = (struct icmp6_hdr *)fin->fin_dp;
	type = ic->icmp6_type;
	/*
	 * If it's not an error type, then return
	 */
	if ((type != ICMP6_DST_UNREACH) && (type != ICMP6_PACKET_TOO_BIG) &&
	    (type != ICMP6_TIME_EXCEEDED) && (type != ICMP6_PARAM_PROB))
		return NULL;

	oip = (ip6_t *)((char *)ic + ICMPERR_ICMPHLEN);
	if (fin->fin_plen < sizeof(*oip))
		return NULL;

	if (oip->ip6_nxt == IPPROTO_ICMPV6) {
		oic = (struct icmp6_hdr *)(oip + 1);
		/*
		 * a ICMP error can only be generated as a result of an
		 * ICMP query, not as the response on an ICMP error
		 *
		 * XXX theoretically ICMP_ECHOREP and the other reply's are
		 * ICMP query's as well, but adding them here seems strange XXX
		 */
		 if (!(oic->icmp6_type & ICMP6_INFOMSG_MASK))
		    	return NULL;

		/*
		 * perform a lookup of the ICMP packet in the state table
		 */
		hv = (pr = oip->ip6_nxt);
		src.in6 = oip->ip6_src;
		hv += src.in4.s_addr;
		dst.in6 = oip->ip6_dst;
		hv += dst.in4.s_addr;
		hv += oic->icmp6_id;
		hv += oic->icmp6_seq;
		hv %= fr_statesize;

		oip->ip6_plen = ntohs(oip->ip6_plen);
		ofin.fin_v = 6;
		fr_makefrip(sizeof(*oip), (ip_t *)oip, &ofin);
		oip->ip6_plen = htons(oip->ip6_plen);
		ofin.fin_ifp = fin->fin_ifp;
		ofin.fin_out = !fin->fin_out;
		ofin.fin_mp = NULL; /* if dereferenced, panic XXX */

		READ_ENTER(&ipf_state);
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext)
			if ((is->is_p == pr) &&
			    (oic->icmp6_id == is->is_icmp.ics_id) &&
			    (oic->icmp6_seq == is->is_icmp.ics_seq) &&
			    fr_matchsrcdst(is, src, dst, &ofin, NULL)) {
			    	/*
			    	 * in the state table ICMP query's are stored
			    	 * with the type of the corresponding ICMP
			    	 * response. Correct here
			    	 */
				if (((is->is_type == ICMP6_ECHO_REPLY) &&
				     (oic->icmp6_type == ICMP6_ECHO_REQUEST)) ||
				     (is->is_type - 1 == oic->icmp6_type )) {
				    	ips_stats.iss_hits++;
    					is->is_pkts++;
					is->is_bytes += fin->fin_plen;
					return is->is_rule;
				}
a1216 63
		RWLOCK_EXIT(&ipf_state);

		return NULL;
	};

	if ((oip->ip6_nxt != IPPROTO_TCP) && (oip->ip6_nxt != IPPROTO_UDP))
		return NULL;
	tcp = (tcphdr_t *)(oip + 1);
	dport = tcp->th_dport;
	sport = tcp->th_sport;

	hv = (pr = oip->ip6_nxt);
	src.in6 = oip->ip6_src;
	hv += src.in4.s_addr;
	dst.in6 = oip->ip6_dst;
	hv += dst.in4.s_addr;
	hv += dport;
	hv += sport;
	hv %= fr_statesize;
	/*
	 * we make an fin entry to be able to feed it to
	 * matchsrcdst note that not all fields are encessary
	 * but this is the cleanest way. Note further we fill
	 * in fin_mp such that if someone uses it we'll get
	 * a kernel panic. fr_matchsrcdst does not use this.
	 *
	 * watch out here, as ip is in host order and oip in network
	 * order. Any change we make must be undone afterwards.
	 */
	savelen = oip->ip6_plen;
	oip->ip6_plen = ip->ip6_plen - sizeof(*ip) - ICMPERR_ICMPHLEN;
	ofin.fin_v = 6;
	fr_makefrip(sizeof(*oip), (ip_t *)oip, &ofin);
	oip->ip6_plen = savelen;
	ofin.fin_ifp = fin->fin_ifp;
	ofin.fin_out = !fin->fin_out;
	ofin.fin_mp = NULL; /* if dereferenced, panic XXX */
	READ_ENTER(&ipf_state);
	for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_hnext) {
		/*
		 * Only allow this icmp though if the
		 * encapsulated packet was allowed through the
		 * other way around. Note that the minimal amount
		 * of info present does not allow for checking against
		 * tcp internals such as seq and ack numbers.
		 */
		if ((is->is_p == pr) && (is->is_v == 6) &&
		    fr_matchsrcdst(is, src, dst, &ofin, tcp)) {
			fr = is->is_rule;
			ips_stats.iss_hits++;
			/*
			 * we must swap src and dst here because the icmp
			 * comes the other way around
			 */
			is->is_pkts++;
			is->is_bytes += fin->fin_plen;
			/*
			 * we deliberately do not touch the timeouts
			 * for the accompanying state table entry.
			 * It remains to be seen if that is correct. XXX
			 */
			RWLOCK_EXIT(&ipf_state);
			return fr;
a1217 1
	}
a1218 1
	return NULL;
a1219 1
#endif
@


1.18.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.18.2.3 2001/05/14 22:40:13 niklas Exp $	*/
@


1.17
log
@Avoid recursive rw_enter panic. From darrenr@@pobox.com.
@
text
@d1 2
a2 1
/* $OpenBSD: ip_state.c,v 1.16 1999/12/28 08:20:40 kjell Exp $ */
d12 1
a12 1
static const char rcsid[] = "@@(#)$Id: ip_state.c,v 1.16 1999/12/28 08:20:40 kjell Exp $";
d179 4
a182 5
				if ((is->is_p == IPPROTO_TCP) &&
				    (((is->is_state[0] <= TCPS_ESTABLISHED) &&
				      (is->is_state[1] > TCPS_ESTABLISHED)) ||
				     ((is->is_state[1] <= TCPS_ESTABLISHED) &&
				      (is->is_state[0] > TCPS_ESTABLISHED))))
d461 1
a461 1
	       ((tcp->th_flags & TH_FIN) ? 1 : 0);      
d475 2
d492 1
a492 1
	    (SEQ_GE(seq + maxwin, fdata->td_end - maxwin)) && 
d677 2
a678 2
	/* 
	 * Does it at least have the return (basic) IP header ? 
d712 1
a712 1
		     (icmp->icmp_type != ICMP_MASKREQ))  
d715 1
a715 1
		/* 
d739 1
a739 1
			    	/* 
d741 1
a741 1
			    	 * with the type of the corresponding ICMP 
d751 1
a751 1
                	                is->is_bytes += ip->ip_len;     
d809 1
a809 1
			is->is_bytes += ip->ip_len;     
d1045 1
a1049 1
	SPL_X(s);
d1186 18
@


1.16
log
@Update to ipfilter 3.3.6. See src/sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_state.c,v 1.15 1999/12/17 07:50:06 kjell Exp $ */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_state.c,v 1.15 1999/12/17 07:50:06 kjell Exp $";
d1042 1
a1046 1
	RWLOCK_EXIT(&ipf_state);
@


1.15
log
@Patch to fix ipmon -F. /dev/ipnat and /dev/ipstate now handle SIOCIPFFB.
from darrenr@@pobox.com
@
text
@d1 1
a1 1
/* $OpenBSD: ip_state.c,v 1.14 1999/12/15 05:20:23 kjell Exp $ */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_state.c,v 1.14 1999/12/15 05:20:23 kjell Exp $";
a667 1
	u_int hv, dest;
d673 1
d707 4
a710 2
		 if ((icmp->icmp_type != ICMP_ECHO) && (icmp->icmp_type != ICMP_TSTAMP) &&
		     (icmp->icmp_type != ICMP_IREQ) && (icmp->icmp_type != ICMP_MASKREQ))  
d720 4
a723 2
		hv += icmp->icmp_id;
		hv += icmp->icmp_seq;
d732 1
a732 1
		
a735 2
			    (icmp->icmp_id == is->is_icmp.ics_id) &&
			    (icmp->icmp_seq == is->is_icmp.ics_seq) &&
a736 1
			    
d743 2
d746 1
a746 1
				     (is->is_type - 1 == ic->icmp_type )) {
d750 3
a752 1
					return is->is_rule;
a755 1

a805 1
			dest = (is->is_dst.s_addr != src.s_addr);
d853 5
a857 2
		hv += ic->icmp_id;
		hv += ic->icmp_seq;
a861 2
			    (ic->icmp_id == is->is_icmp.ics_id) &&
			    (ic->icmp_seq == is->is_icmp.ics_seq) &&
d864 3
a866 1
				    (ic->icmp_type == ICMP_ECHO))
@


1.14
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_state.c,v 2.3.2.14 1999/11/30 13:46:05 darrenr Exp $";
d231 8
@


1.13
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_state.c,v 1.12 1998/09/15 09:51:19 pattonme Exp $       */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_state.c,v 1.12 1998/09/15 09:51:19 pattonme Exp $";
d18 4
d35 3
d44 1
a44 1
#include <sys/protosw.h>
d57 3
a59 1
# include <sys/dditypes.h>
d66 1
a66 1
#include <net/af.h>
d79 1
a79 5
#if defined(__OpenBSD__)
# include <netinet/ip_fil_compat.h>
#else
# include <netinet/ip_compat.h>
#endif
d86 8
d95 1
a95 1
#define	MIN(a,b)	(((a)<(b))?(a):(b))
d100 1
a100 1
ipstate_t *ips_table[IPSTATE_SIZE];
d104 1
a104 1
extern	KRWLOCK_T	ipf_state;
d109 2
a110 1
			       fr_info_t *, void *, u_short, u_short));
d113 1
d118 1
d120 3
a122 3
	fr_tcpclosewait = 60,
	fr_tcplastack = 20,
	fr_tcptimeout = 120,
d124 1
a124 1
	fr_udptimeout = 120,
d126 14
d168 1
a168 1
	for (i = 0; i < IPSTATE_SIZE; i++)
d193 2
d198 1
a198 1
				KFREE(is);
d241 2
a242 1
		return EINVAL;
d251 1
a251 1
int fr_addstate(ip, fin, pass)
d254 1
a254 1
u_int pass;
d256 2
d259 1
a259 2
	register ipstate_t *is = &ips;
	register u_int hv;
d262 2
a263 2
		return -1;
	if (ips_num == IPSTATE_MAX) {
d265 2
a266 1
		return -1;
d268 2
d299 1
a299 1
			return -1;
d313 17
a329 6
		hv += (is->is_dport = tcp->th_dport);
		hv += (is->is_sport = tcp->th_sport);
		is->is_seq = ntohl(tcp->th_seq);
		is->is_ack = ntohl(tcp->th_ack);
		is->is_swin = ntohs(tcp->th_win);
		is->is_dwin = is->is_swin;	/* start them the same */
a334 2
		if ((tcp->th_flags & (TH_SYN|TH_ACK)) == TH_SYN)
			is->is_ack = 0;	/* Trumpet WinSock 'ism */
d346 6
a351 2
		hv += (is->is_dport = tcp->th_dport);
		hv += (is->is_sport = tcp->th_sport);
d357 1
a357 1
		return -1;
d360 1
a360 1
	KMALLOC(is, ipstate_t *, sizeof(*is));
d363 1
a363 1
		return -1;
d366 9
a374 1
	hv %= IPSTATE_SIZE;
d377 1
d392 3
a394 3
	is->is_flags = fin->fin_fi.fi_fl;
	is->is_flags |= FI_OPTIONS|FI_TCPUDP|FI_SHORT;
	is->is_flags |= fin->fin_fi.fi_fl << 4;
d400 2
d416 1
d419 1
a419 1
	return 0;
d423 1
d435 5
a439 3
	register int seqskew, ackskew;
	register tcp_seq seq, ack;
	u_short win;
d445 3
d450 4
a453 1
	source = (ip->ip_src.s_addr == is->is_src.s_addr);
d455 8
a462 2
	if (!(tcp->th_flags & TH_ACK))  /* Pretend an ack was sent */
		ack = source ? is->is_ack : is->is_seq;
d464 7
a470 16
	if (source) {
		if (!is->is_seq)
			/*
			 * Must be an outgoing SYN-ACK in reply to a SYN.
			 */
			is->is_seq = seq;
		seqskew = seq - is->is_seq;
		ackskew = (ack - 1) - is->is_ack;
	} else {
		if (!is->is_ack)
			/*
			 * Must be a SYN-ACK in reply to a SYN.
			 */
			is->is_ack = seq;
		ackskew = seq - is->is_ack;
		seqskew = (ack - 1) - is->is_seq;
d473 30
a502 7
	/*
	 * Make skew values absolute
	 */
	if (seqskew < 0)
		seqskew = -seqskew;
	if (ackskew < 0)
		ackskew = -ackskew;
d504 9
a512 17
	/*
	 * If the difference in sequence and ack numbers is within the
	 * window size of the connection, store these values and match
	 * the packet.
	 */
	win = ntohs(tcp->th_win);
	if ((seqskew <= is->is_dwin) && (ackskew <= is->is_swin)) {
		if (source) {
			is->is_seq = seq;
			is->is_ack = ack;
			if (win != 0)
				is->is_swin = win;
		} else {
			is->is_seq = ack;
			is->is_ack = seq;
			if (win != 0)
				is->is_dwin = win;
d514 1
d524 1
a524 1
		return 1;
d526 1
a526 1
	return 0;
d530 1
a530 1
static int fr_matchsrcdst(is, src, dst, fin, tcp, sp, dp)
d534 1
a534 2
void *tcp;
u_short sp, dp;
d536 2
a537 1
	int ret = 0, rev, out;
d540 1
a540 1
	rev = (is->is_dst.s_addr != dst.s_addr);
d544 14
a557 4
	if (!rev) {
		if (out) {
			if (!is->is_ifpout)
				is->is_ifpout = ifp;
d559 2
a560 2
			if (!is->is_ifpin)
				is->is_ifpin = ifp;
d564 2
a565 2
			if (!is->is_ifpin)
				is->is_ifpin = ifp;
d567 2
a568 2
			if (!is->is_ifpout)
				is->is_ifpout = ifp;
d571 3
d575 2
a576 4
	if (!rev) {
		if (((out && is->is_ifpout == ifp) ||
		     (!out && is->is_ifpin == ifp)) &&
		    (is->is_dst.s_addr == dst.s_addr) &&
d578 2
a579 2
		    (!tcp || ((sp == is->is_sport) &&
		     (dp == is->is_dport)))) {
d583 1
a583 3
		if (((out && is->is_ifpin == ifp) ||
		     (!out && is->is_ifpout == ifp)) &&
		    (is->is_dst.s_addr == src.s_addr) &&
d585 2
a586 2
		    (!tcp || ((sp == is->is_dport) &&
		     (dp == is->is_sport)))) {
d590 2
d597 30
a626 7
	if (ret) {
		if (((fin->fin_fi.fi_optmsk & is->is_optmsk) != is->is_opt) ||
		    ((fin->fin_fi.fi_secmsk & is->is_secmsk) != is->is_sec) ||
		    ((fin->fin_fi.fi_auth & is->is_authmsk) != is->is_auth) ||
		    ((fin->fin_fi.fi_fl & (is->is_flags & 0xf)) !=
		     (is->is_flags >> 4)))
			ret = 0;
d628 19
a646 1
	return ret;
d649 160
d813 1
a813 1
int fr_checkstate(ip, fin)
d820 1
d822 1
a823 1
	u_int hv, hlen, pass;
d826 1
a826 1
		return 0;
d828 1
d844 1
a844 1
		hv %= IPSTATE_SIZE;
d850 5
a854 2
			    fr_matchsrcdst(is, src, dst, fin, NULL, 0, 0)) {
				if (is->is_icmp.ics_type != ic->icmp_type)
a855 6
				pass = is->is_pass;
				RWLOCK_EXIT(&ipf_state);
				if (fin->fin_fi.fi_fl & FI_FRAG)
					ipfr_newfrag(ip, fin,
						   pass ^ FR_KEEPSTATE);
				WRITE_ENTER(&ipf_state);
d857 1
a857 5
				is->is_bytes += ip->ip_len;
				ips_stats.iss_hits++;
				is->is_pkts++;
				RWLOCK_EXIT(&ipf_state);
				return pass;
d859 2
d862 7
d874 3
a876 3
		hv += dport;
		hv += sport;
		hv %= IPSTATE_SIZE;
d878 2
a879 1
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_next)
d881 1
a881 2
			    fr_matchsrcdst(is, src, dst, fin, tcp,
					   sport, dport)) {
d883 1
a883 5
					pass = is->is_pass;
#ifdef	_KERNEL
					RWLOCK_EXIT(&ipf_state);
#else

d886 5
a890 2
						isp = &ips_table[hv];
						KFREE(is);
d893 1
a893 4
					if (fin->fin_fi.fi_fl & FI_FRAG)
						ipfr_newfrag(ip, fin,
							   pass ^ FR_KEEPSTATE);
					return pass;
d895 2
d898 2
d901 6
d913 3
a915 3
		hv += dport;
		hv += sport;
		hv %= IPSTATE_SIZE;
d920 1
a920 1
		for (is = ips_table[hv]; is; is = is->is_next)
d922 1
a922 5
			    fr_matchsrcdst(is, src, dst, fin,
					   tcp, sport, dport)) {
				pass = is->is_pass;
				MUTEX_ENTER(&ipf_rw);
				is->is_bytes += ip->ip_len;
d924 1
a924 8
				ips_stats.iss_hits++;
				is->is_pkts++;
				MUTEX_EXIT(&ipf_rw);
				RWLOCK_EXIT(&ipf_state);
				if (fin->fin_fi.fi_fl & FI_FRAG)
					ipfr_newfrag(ip, fin,
						     pass ^ FR_KEEPSTATE);
				return pass;
d926 2
d929 6
d940 31
a970 2
	ATOMIC_INC(ips_stats.iss_miss);
	return 0;
d983 1
a983 1
	for (i = 0; i < IPSTATE_SIZE; i++)
d986 2
a987 1
			KFREE(is);
d989 1
d992 2
d1011 1
a1011 1
	for (i = 0; i < IPSTATE_SIZE; i++)
d1019 2
d1024 1
a1024 1
				KFREE(is);
d1028 4
d1071 5
a1076 1
	case TCPS_CLOSED:
a1082 5
		if ((flags & (TH_FIN|TH_ACK)) == TH_ACK) {
			state[dir] = TCPS_ESTABLISHED;
			*age = fr_tcpidletimeout;
		}
		break;
d1087 7
d1104 4
a1107 2
		} else
			*age = fr_tcpidletimeout;
d1136 1
a1136 1
u_short type;
d1167 1
a1167 1
	(void) ipllog(IPL_LOGSTATE, 0, items, sizes, types, 1);
@


1.12
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_state.c,v 1.11 1998/02/17 01:39:07 dgregor Exp $       */
d3 1
a3 1
 * Copyright (C) 1995-1997 by Darren Reed.
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id$";
d14 4
d19 1
a27 4
#include <sys/errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/file.h>
d91 1
a91 1
extern	krwlock_t	ipf_state;
d227 1
a227 1
	if ((ip->ip_off & 0x1fff) || (fin->fin_fi.fi_fl & FI_SHORT))
a372 1
	register u_short swin, dwin;
d374 1
d394 1
a394 1
		ackskew = ack - is->is_ack;
d402 1
a402 1
		seqskew = ack - is->is_seq;
d418 2
a419 9
	if (source) {
		swin = is->is_swin;
		dwin = is->is_dwin;
	} else {
		dwin = is->is_swin;
		swin = is->is_dwin;
	}

	if ((seqskew <= dwin) && (ackskew <= swin)) {
d423 2
a424 1
			is->is_swin = ntohs(tcp->th_win);
d428 2
a429 1
			is->is_dwin = ntohs(tcp->th_win);
d528 1
a528 1
	if ((ip->ip_off & 0x1fff) || (fin->fin_fi.fi_fl & FI_SHORT))
d656 1
d793 1
a799 1
	ipsl.isl_type = type;
d803 4
@


1.11
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*       $OpenBSD$       */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_state.c,v 1.10 1998/01/26 04:10:46 dgregor Exp $";
d69 5
a73 1
#include "ip_fil_compat.h"
d75 5
a79 5
#include "ip_fil.h"
#include "ip_nat.h"
#include "ip_frag.h"
#include "ip_proxy.h"
#include "ip_state.h"
d90 2
a91 1
extern	kmutex_t	ipf_state;
d94 5
d111 1
a111 1
ips_stat_t *fr_statetstats()
d125 1
a125 1
int fr_state_flush(which)
d136 1
a136 1
	MUTEX_ENTER(&ipf_state);
d149 3
a151 3
				     (is->is_state[1] > TCPS_ESTABLISHED)) ||
				    ((is->is_state[1] <= TCPS_ESTABLISHED) &&
				     (is->is_state[0] > TCPS_ESTABLISHED))))
d171 1
a171 1
	MUTEX_EXIT(&ipf_state);
d251 1
a251 1
			is->is_icmp.ics_type = 0;
d263 1
a263 1
		ips_stats.iss_icmp++;
a280 1
		ips_stats.iss_tcp++;
d288 2
d292 1
d301 1
a301 1
		ips_stats.iss_udp++;
d311 1
a311 1
		ips_stats.iss_nomem++;
d316 2
a317 3
	MUTEX_ENTER(&ipf_state);
	is->is_next = ips_table[hv];
	ips_table[hv] = is;
d321 26
d349 1
a349 1
	ips_num++;
d353 1
a353 1
	MUTEX_EXIT(&ipf_state);
d365 1
a365 1
int fr_tcpstate(is, fin, ip, tcp, sport)
a369 1
u_short sport;
d381 1
a381 1
	source = (sport == is->is_sport);
d425 1
a425 1
	if ((seqskew <= swin) && (ackskew <= dwin)) {
d435 1
a435 1
		ips_stats.iss_hits++;
d441 3
a443 2
		fr_tcp_age(&is->is_age, is->is_state, ip, fin,
			   tcp->th_sport == is->is_sport);
d450 68
d551 1
a551 1
		MUTEX_ENTER(&ipf_state);
d556 2
a557 7
			    IPPAIR(src, dst, is->is_src, is->is_dst)) {
				/*
				 * If we have type 0 stored, allow any icmp
				 * replies through.
				 */
				if (is->is_icmp.ics_type &&
				    is->is_icmp.ics_type != ic->icmp_type)
d559 6
a565 1
				is->is_pkts++;
d568 2
a569 2
				pass = is->is_pass;
				MUTEX_EXIT(&ipf_state);
d572 1
a572 1
		MUTEX_EXIT(&ipf_state);
d581 2
a582 2
		MUTEX_ENTER(&ipf_state);
		for (isp = &ips_table[hv]; (is = *isp); isp = &is->is_next) {
d584 3
a586 3
			    PAIRS(sport, dport, is->is_sport, is->is_dport) &&
			    IPPAIR(src, dst, is->is_src, is->is_dst))
				if (fr_tcpstate(is, fin, ip, tcp, sport)) {
d589 1
a589 1
					MUTEX_EXIT(&ipf_state);
d598 3
d603 2
a604 2
		}
		MUTEX_EXIT(&ipf_state);
d617 1
a617 1
		MUTEX_ENTER(&ipf_state);
d620 6
a625 2
			    PAIRS(sport, dport, is->is_sport, is->is_dport) &&
			    IPPAIR(src, dst, is->is_src, is->is_dst)) {
d628 5
a632 4
				is->is_bytes += ip->ip_len;
				is->is_age = fr_udptimeout;
				pass = is->is_pass;
				MUTEX_EXIT(&ipf_state);
d635 1
a635 1
		MUTEX_EXIT(&ipf_state);
d641 1
a641 1
	ips_stats.iss_miss++;
d654 1
a654 1
	MUTEX_ENTER(&ipf_state);
d660 1
a660 1
	MUTEX_EXIT(&ipf_state);
d677 1
a677 1
	MUTEX_ENTER(&ipf_state);
d693 1
a693 1
	MUTEX_EXIT(&ipf_state);
@


1.10
log
@IPF 3.2.3
@
text
@d1 1
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_state.c,v 2.0.2.24.2.4 1997/11/19 11:44:09 darrenr Exp $";
@


1.9
log
@merge in 3.1.11
@
text
@a0 1
/*	$OpenBSD: ip_state.c,v 1.8 1997/06/09 15:50:57 kstailey Exp $	*/
d2 1
a2 1
 * (C)opyright 1995 by Darren Reed.
d8 3
a10 5
#if 0
#if !defined(lint) && defined(LIBC_SCCS)
static	char	sccsid[] = "@@(#)ip_state.c	1.8 6/5/96 (C) 1993-1995 Darren Reed";
static	char	rcsid[] = "$DRId: ip_state.c,v 2.0.1.5 1997/04/13 22:29:18 darrenr Exp $";
#endif
d13 1
a13 1
#if !defined(_KERNEL) && !defined(KERNEL)
d16 5
d26 7
a32 1
#include <sys/ioctl.h>
d34 1
d36 1
d38 1
a38 1
#ifdef	_KERNEL
d42 3
a44 1
# include <sys/mbuf.h>
d46 1
a60 1
#include <netinet/ip_var.h>
d62 4
a65 1
#include <netinet/tcp_fsm.h>
a66 1
#include <netinet/tcpip.h>
d69 1
d71 3
a78 8
#ifndef _KERNEL
int fr_tcpstate __P((register ipstate_t *, fr_info_t *, ip_t *, tcphdr_t *,
		     u_short, ipstate_t **));
#else
int fr_tcpstate __P((register ipstate_t *,  fr_info_t *, ip_t *, tcphdr_t *,
		     u_short));
#endif

d84 1
a84 1
#if	SOLARIS
a85 3
# if	!defined(_KERNEL)
#define	bcopy(a,b,c)	memmove(b,a,c)
# endif
d100 1
a100 2
ips_stat_t *
fr_statetstats()
d108 94
a201 4
#define	PAIRS(s1,d1,s2,d2)	((((s1) == (s2)) && ((d1) == (d2))) ||\
				 (((s1) == (d2)) && ((d1) == (s2))))
#define	IPPAIR(s1,d1,s2,d2)	PAIRS((s1).s_addr, (d1).s_addr, \
				      (s2).s_addr, (d2).s_addr)
d206 4
a209 5
int
fr_addstate(ip, fin, pass)
	ip_t *ip;
	fr_info_t *fin;
	u_int pass;
d272 1
a272 1
		 * If we're creating state for a starting connectoin, start the
d278 2
a279 2
		set_tcp_age(&is->is_age, is->is_state, ip, fin,
			    tcp->th_sport == is->is_sport);
d296 2
a297 1
	if (!(is = (ipstate_t *)KMALLOC(sizeof(*is)))) {
d307 2
d312 3
d316 2
d327 6
a332 13
int
fr_tcpstate(is, fin, ip, tcp, sport
#ifndef	_KERNEL
     ,isp)
	ipstate_t **isp;
#else
	)
#endif
	register ipstate_t *is;
	fr_info_t *fin;
	ip_t *ip;
	tcphdr_t *tcp;
	u_short sport;
d350 5
a357 1
		seqskew = ack - is->is_seq;
d364 1
d399 2
d404 2
a405 2
		set_tcp_age(&is->is_age, is->is_state, ip, fin,
			    tcp->th_sport == is->is_sport);
d415 3
a417 4
int
fr_checkstate(ip, fin)
	ip_t *ip;
	fr_info_t *fin;
d459 2
d480 1
a480 5
				if (fr_tcpstate(is, fin, ip, tcp, sport
#ifndef _KERNEL
						, NULL
#endif
						)) {
d485 1
d514 2
d535 1
a535 2
void
fr_stateunload()
a538 1
	int s;
a540 1
	SPLNET(s);
a545 1
	SPLX(s);
d551 1
a551 1
 * Slowly expire held state for things like UDP and ICMP.  Timeouts are set
d554 1
a554 2
void
fr_timeoutstate()
d558 1
d560 1
d562 1
a563 1
	SPLNET(s);
d572 3
a578 1
	SPLX(s);
d580 1
d588 6
a593 7
void
set_tcp_age(age, state, ip, fin, dir)
	long *age;
	u_char *state;
	ip_t *ip;
	fr_info_t *fin;
	int dir;
d670 35
@


1.8
log
@fix a problem with TCP RST packets which only include a non-zero SEQ # in the
RST packet.  Darren Reed; Guido van Rooij.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_state.c,v 1.7 1997/02/11 22:23:28 kstailey Exp $	*/
d12 1
a12 1
static	char	rcsid[] = "Id: ip_state.c,v 2.0.1.2 1997/01/09 15:22:45 darrenr Exp ";
a60 1
void set_tcp_age __P((int *, u_char *, ip_t *, fr_info_t *, int));
a247 1

d250 1
a250 1
	if (!(tcp->th_flags & TH_ACK))	/* Pretend an ack was sent */
d322 1
a322 1
	u_int hv, hlen;
d358 1
d360 1
a360 1
				return is->is_pass;
d381 1
a383 1
					return is->is_pass;
a384 2
					int pass = is->is_pass;

d390 1
a391 1
#endif
d414 1
d416 1
a416 1
				return is->is_pass;
d437 1
d440 1
d446 1
d460 1
d463 1
d476 1
d487 1
a487 1
	int *age;
@


1.7
log
@IPF 1.3.7
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d249 7
a255 1
	if (sport == is->is_sport) {
d281 1
a281 1
	if ((source = (sport == is->is_sport))) {
@


1.6
log
@syslog.h -> sys/syslog.h

THIS IS THE KERNEL, DAMNIT.
@
text
@d1 1
d10 1
a10 1
#ifndef	lint
d12 1
a12 1
static	char	rcsid[] = "$OpenBSD: ip_state.c,v 1.5 1996/10/24 17:56:21 tholo Exp $";
a19 1
#ifndef	linux
a21 3
#if defined(_KERNEL) || defined(KERNEL)
#include <sys/systm.h>
#endif
d28 3
a31 5
# if defined(__OpenBSD__)
#  include <sys/dirent.h>
# else
#  include <sys/dir.h>
# endif
d50 1
a53 2
#include <sys/syslog.h>
#endif
d61 9
d83 11
d121 2
d127 3
d159 1
a159 1
		is->is_age = 120;
d174 2
a175 1
		is->is_win = ntohs(tcp->th_win);
d183 3
a185 3
			is->is_age = 120;
		else
			is->is_age = 0;
d195 1
a195 1
		is->is_age = 120;
d221 85
d320 1
a320 1
	if ((ip->ip_off & 0x1fff) && !(fin->fin_fi.fi_fl & FI_SHORT))
d352 1
a352 1
				is->is_age = 120;
a361 2
		register u_short win = ntohs(tcp->th_win);
		tcp_seq seq, ack;
a367 2
			register int dl, seqskew, ackskew;

d370 6
a375 52
			    IPPAIR(src, dst, is->is_src, is->is_dst)) {
				dl = ip->ip_len - hlen - sizeof(tcphdr_t);
				/*
				 * Find difference between last checked packet
				 * and this packet.
				 */
				seq = ntohl(tcp->th_seq);
				ack = ntohl(tcp->th_ack);
				if (sport == is->is_sport) {
					seqskew = seq - is->is_seq;
					ackskew = ack - is->is_ack;
				} else {
					seqskew = ack - is->is_seq;
					if (!is->is_ack) {
						/*
						 * Must be a SYN-ACK in reply
						 * to a SYN.  Set age timeout
						 * to 0 to stop deletion.
						 */
						is->is_ack = seq;
						is->is_age = 0;
					}
					ackskew = seq - is->is_ack;
				}

				/*
				 * Make skew values absolute
				 */
				if (seqskew < 0)
					seqskew = -seqskew;
				if (ackskew < 0)
					ackskew = -ackskew;
				/*
				 * If the difference in sequence and ack
				 * numbers is within the window size of the
				 * connection, store these values and match
				 * the packet.
				 */
				if ((seqskew <= win) && (ackskew <= win)) {
					is->is_win = win;
					if (sport == is->is_sport) {
						is->is_seq = seq;
						is->is_ack = ack;
					} else {
						is->is_seq = ack;
						is->is_ack = seq;
					}
					ips_stats.iss_hits++;
					/*
					 * Nearing end of connection, start
					 * timeout.
					 */
a376 6
					if (!is->is_age) {
						if (tcp->th_flags & TH_FIN)
							is->is_age = 120;
						if (tcp->th_flags & TH_RST)
							is->is_age = 1;
					}
d380 2
a382 2
						int pass = is->is_pass;

a385 1
						return pass;
d387 1
a387 1
					return is->is_pass;
a389 1
			}
d410 1
a410 1
				is->is_age = 120;
d445 1
a445 1
 * Slowly expire held state for thingslike UDP and ICMP.  Timeouts are set
d468 89
@


1.5
log
@<sys/dir.h> is for use as a compatibility interface only.  Warn if
included by kernel modules, and also remove use from any modules that
currently attempt to use it.
@
text
@d11 1
a11 1
static	char	rcsid[] = "$OpenBSD: ip_state.c,v 1.4 1996/10/08 07:33:29 niklas Exp $";
d58 1
a58 1
#include <syslog.h>
@


1.4
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d11 1
a11 1
static	char	rcsid[] = "$OpenBSD: ip_state.c,v 1.3 1996/07/18 05:01:08 dm Exp $";
d32 5
a36 1
# include <sys/dir.h>
@


1.3
log
@ipfilter 3.1.0
@
text
@d8 1
d11 2
a12 1
static	char	rcsid[] = "$Id: ip_state.c,v 1.1.1.1 1996/06/23 07:27:18 darrenr Exp $";
d22 3
d56 1
a57 1
#include "ip_fil_compat.h"
d76 2
a77 1
ips_stat_t *fr_statetstats()
d93 5
a97 4
int fr_addstate(ip, fin, pass)
ip_t *ip;
fr_info_t *fin;
u_int pass;
d199 4
a202 3
int fr_checkstate(ip, fin)
ip_t *ip;
fr_info_t *fin;
d377 2
a378 1
void fr_stateunload()
d397 2
a398 1
void fr_timeoutstate()
@


1.2
log
@ipfilter 3.0.4
@
text
@d9 2
a10 1
static	char	sccsid[] = "@@(#)ip_state.c	1.6 3/24/96 (C) 1993-1995 Darren Reed";
d52 1
d87 1
a87 1
int fr_addstate(ip, hlen, pass)
d89 1
a89 1
int hlen;
d111 1
a111 1
		struct icmp *ic = (struct icmp *)((char *)ip + hlen);
d134 1
a134 1
		register tcphdr_t *tcp = (tcphdr_t *)((char *)ip + hlen);
d159 1
a159 1
		register tcphdr_t *tcp = (tcphdr_t *)((char *)ip + hlen);
d180 3
a182 1
	is->is_pass = pass & ~(FR_LOGFIRST|FR_LOG);
d310 6
a315 3
					if ((tcp->th_flags & TCP_CLOSE) &&
					    !is->is_age)
						is->is_age = 120;
@


1.1
log
@IP filter 3.0.1
@
text
@d9 1
a9 1
static	char	sccsid[] = "@@(#)ip_state.c	1.3 1/12/96 (C) 1993-1995 Darren Reed";
d12 4
a15 1
#include <string.h>
d178 1
a178 1
	is->is_pass = pass;
d188 1
a188 1
int fr_checkstate(ip, hlen)
d190 1
a190 1
int hlen;
d197 4
a200 1
	u_int hv;
d202 1
@
