head	1.41;
access;
symbols
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	UBC_SYNC_A:1.41
	UBC_SYNC_B:1.41
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_8:1.35.0.2
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	SMP:1.26.0.2
	SMP_BASE:1.26
	kame_19991208:1.22
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.41
date	2001.05.30.02.12.33;	author deraadt;	state dead;
branches;
next	1.40;

1.40
date	2001.05.08.19.58.01;	author fgsch;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.06.17.29.30;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.30.04.23.56;	author kjell;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.17.07.25.19;	author fgsch;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.17.04.47.14;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2000.08.10.15.43.20;	author kjell;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.10.05.50.26;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2000.07.03.04.50.05;	author aaron;	state Exp;
branches;
next	1.32;

1.32
date	2000.05.24.21.59.11;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.10.20.40.53;	author deraadt;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.05.01.06.16.47;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.05.05.35.27;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2000.03.13.23.40.18;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.16.22.34.19;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2000.02.01.19.29.58;	author kjell;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	99.12.17.07.50.05;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	99.12.17.06.17.08;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	99.12.15.05.20.22;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.06.07.22.00.34;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.02.05.05.58.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.02.01.07.45.53;	author d;	state Exp;
branches;
next	1.18;

1.18
date	99.01.29.07.01.46;	author d;	state Exp;
branches;
next	1.17;

1.17
date	98.10.11.05.37.28;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.09.15.09.51.18;	author pattonme;	state Exp;
branches;
next	1.15;

1.15
date	98.06.27.08.07.58;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.02.17.01.39.05;	author dgregor;	state Exp;
branches;
next	1.13;

1.13
date	98.01.26.04.10.43;	author dgregor;	state Exp;
branches;
next	1.12;

1.12
date	97.06.23.19.03.49;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.04.18.06.10.07;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.02.13.18.13.31;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.02.12.15.16.02;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.02.11.22.23.25;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.18.08.29.21;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.10.24.17.56.22;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.10.08.07.33.28;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.18.05.01.05;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.05.13.19.49.32;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.05.10.21.38.17;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.25.05.41.45;	author dm;	state Exp;
branches;
next	;

1.26.2.1
date	2000.02.20.11.57.27;	author niklas;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2001.05.14.22.40.12;	author niklas;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2001.07.04.10.54.55;	author niklas;	state dead;
branches;
next	;

1.31.2.1
date	2000.05.27.20.45.17;	author jason;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ip_nat.c,v 1.40 2001/05/08 19:58:01 fgsch Exp $	*/

/*
 * Copyright (C) 1995-2001 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 *
 * Added redirect stuff and a LOT of bug fixes. (mcn@@EnGarde.com)
 */
#if !defined(lint)
static const char sccsid[] = "@@(#)ip_nat.c	1.11 6/5/96 (C) 1995 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.37.2.35 2001/04/06 14:07:40 darrenr Exp $";
#endif

#if defined(__FreeBSD__) && defined(KERNEL) && !defined(_KERNEL)
#define _KERNEL
#endif

#include <sys/errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/file.h>
#if defined(__NetBSD__) && (NetBSD >= 199905) && !defined(IPFILTER_LKM) && \
    defined(_KERNEL)
# include "opt_ipfilter_log.h"
#endif
#if !defined(_KERNEL) && !defined(KERNEL)
# include <stdio.h>
# include <string.h>
# include <stdlib.h>
#endif
#if (defined(KERNEL) || defined(_KERNEL)) && (__FreeBSD_version >= 220000)
# include <sys/filio.h>
# include <sys/fcntl.h>
#else
# include <sys/ioctl.h>
#endif
#include <sys/fcntl.h>
#include <sys/uio.h>
#ifndef linux
# include <sys/protosw.h>
#endif
#include <sys/socket.h>
#if defined(_KERNEL) && !defined(linux)
# include <sys/systm.h>
#endif
#if !defined(__SVR4) && !defined(__svr4__)
# ifndef linux
#  include <sys/mbuf.h>
# endif
#else
# include <sys/filio.h>
# include <sys/byteorder.h>
# ifdef _KERNEL
#  include <sys/dditypes.h>
# endif
# include <sys/stream.h>
# include <sys/kmem.h>
#endif
#if __FreeBSD_version >= 300000
# include <sys/queue.h>
#endif
#include <net/if.h>
#if __FreeBSD_version >= 300000
# include <net/if_var.h>
# if defined(_KERNEL) && !defined(IPFILTER_LKM)
#  include "opt_ipfilter.h"
# endif
#endif
#ifdef sun
# include <net/af.h>
#endif
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>

#ifdef __sgi
# ifdef IFF_DRVRLOCK /* IRIX6 */
#include <sys/hashing.h>
#include <netinet/in_var.h>
# endif
#endif

#ifdef RFC1825
# include <vpn/md5.h>
# include <vpn/ipsec.h>
extern struct ifnet vpnif;
#endif

#ifndef linux
# include <netinet/ip_var.h>
#endif
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_fil_compat.h>
#include <netinet/tcpip.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_frag.h>
#include <netinet/ip_state.h>
#if (__FreeBSD_version >= 300000)
# include <sys/malloc.h>
#endif
#ifndef	MIN
# define	MIN(a,b)	(((a)<(b))?(a):(b))
#endif
#undef	SOCKADDR_IN
#define	SOCKADDR_IN	struct sockaddr_in

nat_t	**nat_table[2] = { NULL, NULL },
	*nat_instances = NULL;
ipnat_t	*nat_list = NULL;
u_int	ipf_nattable_sz = NAT_TABLE_SZ;
u_int	ipf_natrules_sz = NAT_SIZE;
u_int	ipf_rdrrules_sz = RDR_SIZE;
u_int	ipf_hostmap_sz = HOSTMAP_SIZE;
u_32_t	nat_masks = 0;
u_32_t	rdr_masks = 0;
ipnat_t	**nat_rules = NULL;
ipnat_t	**rdr_rules = NULL;
hostmap_t	**maptable  = NULL;

u_long	fr_defnatage = DEF_NAT_AGE,
	fr_defnaticmpage = 6;		/* 3 seconds */
natstat_t nat_stats;
int	fr_nat_lock = 0;
#if	(SOLARIS || defined(__sgi)) && defined(_KERNEL)
extern	kmutex_t	ipf_rw;
extern	KRWLOCK_T	ipf_nat;
#endif

static	int	nat_flushtable __P((void));
static	void	nat_addnat __P((struct ipnat *));
static	void	nat_addrdr __P((struct ipnat *));
static	void	nat_delete __P((struct nat *));
static	void	nat_delrdr __P((struct ipnat *));
static	void	nat_delnat __P((struct ipnat *));
static	int	fr_natgetent __P((caddr_t));
static	int	fr_natgetsz __P((caddr_t));
static	int	fr_natputent __P((caddr_t));
static	void	nat_tabmove __P((nat_t *, u_32_t));
static	int	nat_match __P((fr_info_t *, ipnat_t *, ip_t *));
static	hostmap_t *nat_hostmap __P((ipnat_t *, struct in_addr,
				    struct in_addr));
static	void	nat_hostmapdel __P((struct hostmap *));


int nat_init()
{
	KMALLOCS(nat_table[0], nat_t **, sizeof(nat_t *) * ipf_nattable_sz);
	if (nat_table[0] != NULL)
		bzero((char *)nat_table[0], ipf_nattable_sz * sizeof(nat_t *));
	else
		return -1;

	KMALLOCS(nat_table[1], nat_t **, sizeof(nat_t *) * ipf_nattable_sz);
	if (nat_table[1] != NULL)
		bzero((char *)nat_table[1], ipf_nattable_sz * sizeof(nat_t *));
	else
		return -1;

	KMALLOCS(nat_rules, ipnat_t **, sizeof(ipnat_t *) * ipf_natrules_sz);
	if (nat_rules != NULL)
		bzero((char *)nat_rules, ipf_natrules_sz * sizeof(ipnat_t *));
	else
		return -1;

	KMALLOCS(rdr_rules, ipnat_t **, sizeof(ipnat_t *) * ipf_rdrrules_sz);
	if (rdr_rules != NULL)
		bzero((char *)rdr_rules, ipf_rdrrules_sz * sizeof(ipnat_t *));
	else
		return -1;

	KMALLOCS(maptable, hostmap_t **, sizeof(hostmap_t *) * ipf_hostmap_sz);
	if (maptable != NULL)
		bzero((char *)maptable, sizeof(hostmap_t *) * ipf_hostmap_sz);
	else
		return -1;
	return 0;
}


static void nat_addrdr(n)
ipnat_t *n;
{
	ipnat_t **np;
	u_32_t j;
	u_int hv;
	int k;

	k = countbits(n->in_outmsk);
	if ((k >= 0) && (k != 32))
		rdr_masks |= 1 << k;
	j = (n->in_outip & n->in_outmsk);
	hv = NAT_HASH_FN(j, 0, ipf_rdrrules_sz);
	np = rdr_rules + hv;
	while (*np != NULL)
		np = &(*np)->in_rnext;
	n->in_rnext = NULL;
	n->in_prnext = np;
	*np = n;
}


static void nat_addnat(n)
ipnat_t *n;
{
	ipnat_t **np;
	u_32_t j;
	u_int hv;
	int k;

	k = countbits(n->in_inmsk);
	if ((k >= 0) && (k != 32))
		nat_masks |= 1 << k;
	j = (n->in_inip & n->in_inmsk);
	hv = NAT_HASH_FN(j, 0, ipf_natrules_sz);
	np = nat_rules + hv;
	while (*np != NULL)
		np = &(*np)->in_mnext;
	n->in_mnext = NULL;
	n->in_pmnext = np;
	*np = n;
}


static void nat_delrdr(n)
ipnat_t *n;
{
	if (n->in_rnext)
		n->in_rnext->in_prnext = n->in_prnext;
	*n->in_prnext = n->in_rnext;
}


static void nat_delnat(n)
ipnat_t *n;
{
	if (n->in_mnext)
		n->in_mnext->in_pmnext = n->in_pmnext;
	*n->in_pmnext = n->in_mnext;
}


/*
 * check if an ip address has already been allocated for a given mapping that
 * is not doing port based translation.
 *
 * Must be called with ipf_nat held as a write lock.
 */
static struct hostmap *nat_hostmap(np, real, map)
ipnat_t *np;
struct in_addr real;
struct in_addr map;
{
	hostmap_t *hm;
	u_int hv;

	hv = real.s_addr % HOSTMAP_SIZE;
	for (hm = maptable[hv]; hm; hm = hm->hm_next)
		if ((hm->hm_realip.s_addr == real.s_addr) &&
		    (np == hm->hm_ipnat)) {
			hm->hm_ref++;
			return hm;
		}

	KMALLOC(hm, hostmap_t *);
	if (hm) {
		hm->hm_next = maptable[hv];
		hm->hm_pnext = maptable + hv;
		if (maptable[hv])
			maptable[hv]->hm_pnext = &hm->hm_next;
		maptable[hv] = hm;
		hm->hm_ipnat = np;
		hm->hm_realip = real;
		hm->hm_mapip = map;
		hm->hm_ref = 1;
	}
	return hm;
}


/*
 * Must be called with ipf_nat held as a write lock.
 */
static void nat_hostmapdel(hm)
struct hostmap *hm;
{
	ATOMIC_DEC32(hm->hm_ref);
	if (hm->hm_ref == 0) {
		if (hm->hm_next)
			hm->hm_next->hm_pnext = hm->hm_pnext;
		*hm->hm_pnext = hm->hm_next;
		KFREE(hm);
	}
}


void fix_outcksum(sp, n)
u_short *sp;
u_32_t n;
{
	register u_short sumshort;
	register u_32_t sum1;

	if (!n)
		return;
#if SOLARIS2 >= 6
	else if (n & NAT_HW_CKSUM) {
		*sp = n & 0xffff;
		return;
	}
#endif
	sum1 = (~ntohs(*sp)) & 0xffff;
	sum1 += (n);
	sum1 = (sum1 >> 16) + (sum1 & 0xffff);
	/* Again */
	sum1 = (sum1 >> 16) + (sum1 & 0xffff);
	sumshort = ~(u_short)sum1;
	*(sp) = htons(sumshort);
}


void fix_incksum(sp, n)
u_short *sp;
u_32_t n;
{
	register u_short sumshort;
	register u_32_t sum1;

	if (!n)
		return;
#if SOLARIS2 >= 6
	else if (n & NAT_HW_CKSUM) {
		*sp = n & 0xffff;
		return;
	}
#endif
	sum1 = (~ntohs(*sp)) & 0xffff;
	sum1 += ~(n) & 0xffff;
	sum1 = (sum1 >> 16) + (sum1 & 0xffff);
	/* Again */
	sum1 = (sum1 >> 16) + (sum1 & 0xffff);
	sumshort = ~(u_short)sum1;
	*(sp) = htons(sumshort);
}


/*
 * fix_datacksum is used *only* for the adjustments of checksums in the data
 * section of an IP packet.
 *
 * The only situation in which you need to do this is when NAT'ing an 
 * ICMP error message. Such a message, contains in its body the IP header
 * of the original IP packet, that causes the error.
 *
 * You can't use fix_incksum or fix_outcksum in that case, because for the
 * kernel the data section of the ICMP error is just data, and no special 
 * processing like hardware cksum or ntohs processing have been done by the 
 * kernel on the data section.
 */
void fix_datacksum(sp, n)
u_short *sp;
u_32_t n;
{
	register u_short sumshort;
	register u_32_t sum1;

	if (!n)
		return;

	sum1 = (~ntohs(*sp)) & 0xffff;
	sum1 += (n);
	sum1 = (sum1 >> 16) + (sum1 & 0xffff);
	/* Again */
	sum1 = (sum1 >> 16) + (sum1 & 0xffff);
	sumshort = ~(u_short)sum1;
	*(sp) = htons(sumshort);
}

/*
 * How the NAT is organised and works.
 *
 * Inside (interface y) NAT       Outside (interface x)
 * -------------------- -+- -------------------------------------
 * Packet going          |   out, processsed by ip_natout() for x
 * ------------>         |   ------------>
 * src=10.1.1.1          |   src=192.1.1.1
 *                       |
 *                       |   in, processed by ip_natin() for x
 * <------------         |   <------------
 * dst=10.1.1.1          |   dst=192.1.1.1
 * -------------------- -+- -------------------------------------
 * ip_natout() - changes ip_src and if required, sport
 *             - creates a new mapping, if required.
 * ip_natin()  - changes ip_dst and if required, dport
 *
 * In the NAT table, internal source is recorded as "in" and externally
 * seen as "out".
 */

/*
 * Handle ioctls which manipulate the NAT.
 */
int nat_ioctl(data, cmd, mode)
#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD_version >= 300003)
u_long cmd;
#else
int cmd;
#endif
caddr_t data;
int mode;
{
	register ipnat_t *nat, *nt, *n = NULL, **np = NULL;
	int error = 0, ret, arg;
	ipnat_t natd;
	u_32_t i, j;

#if (BSD >= 199306) && defined(_KERNEL)
	if ((securelevel >= 2) && (mode & FWRITE))
		return EPERM;
#endif

	nat = NULL;     /* XXX gcc -Wuninitialized */
	KMALLOC(nt, ipnat_t *);
	if ((cmd == SIOCADNAT) || (cmd == SIOCRMNAT))
		error = IRCOPYPTR(data, (char *)&natd, sizeof(natd));
	else if (cmd == SIOCIPFFL) {	/* SIOCFLNAT & SIOCCNATL */
		error = IRCOPY(data, (char *)&arg, sizeof(arg));
		if (error)
			error = EFAULT;
	}

	if (error)
		goto done;

	/*
	 * For add/delete, look to see if the NAT entry is already present
	 */
	WRITE_ENTER(&ipf_nat);
	if ((cmd == SIOCADNAT) || (cmd == SIOCRMNAT)) {
		nat = &natd;
		nat->in_flags &= IPN_USERFLAGS;
		if ((nat->in_redir & NAT_MAPBLK) == 0) {
			if ((nat->in_flags & IPN_SPLIT) == 0)
				nat->in_inip &= nat->in_inmsk;
			if ((nat->in_flags & IPN_IPRANGE) == 0)
				nat->in_outip &= nat->in_outmsk;
		}
		for (np = &nat_list; (n = *np); np = &n->in_next)
			if (!bcmp((char *)&nat->in_flags, (char *)&n->in_flags,
					IPN_CMPSIZ))
				break;
	}

	switch (cmd)
	{
#ifdef  IPFILTER_LOG
	case SIOCIPFFB :
	{
		int tmp;

		if (!(mode & FWRITE))
			error = EPERM;
		else {
			tmp = ipflog_clear(IPL_LOGNAT);
			IWCOPY((char *)&tmp, (char *)data, sizeof(tmp));
		}
		break;
	}
#endif
	case SIOCADNAT :
		if (!(mode & FWRITE)) {
			error = EPERM;
			break;
		}
		if (n) {
			error = EEXIST;
			break;
		}
		if (nt == NULL) {
			error = ENOMEM;
			break;
		}
		n = nt;
		nt = NULL;
		bcopy((char *)nat, (char *)n, sizeof(*n));
		n->in_ifp = (void *)GETUNIT(n->in_ifname, 4);
		if (!n->in_ifp)
			n->in_ifp = (void *)-1;
		if (n->in_plabel[0] != '\0') {
			n->in_apr = appr_match(n->in_p, n->in_plabel);
			if (!n->in_apr) {
				error = ENOENT;
				break;
			}
		}
		n->in_next = NULL;
		*np = n;

		if (n->in_redir & NAT_REDIRECT) {
			n->in_flags &= ~IPN_NOTDST;
			nat_addrdr(n);
		}
		if (n->in_redir & (NAT_MAP|NAT_MAPBLK)) {
			n->in_flags &= ~IPN_NOTSRC;
			nat_addnat(n);
		}

		n->in_use = 0;
		if (n->in_redir & NAT_MAPBLK)
			n->in_space = USABLE_PORTS * ~ntohl(n->in_outmsk);
		else if (n->in_flags & IPN_AUTOPORTMAP)
			n->in_space = USABLE_PORTS * ~ntohl(n->in_inmsk);
		else if (n->in_flags & IPN_IPRANGE)
			n->in_space = ntohl(n->in_outmsk) - ntohl(n->in_outip);
		else if (n->in_flags & IPN_SPLIT)
			n->in_space = 2;
		else
			n->in_space = ~ntohl(n->in_outmsk);
		/*
		 * Calculate the number of valid IP addresses in the output
		 * mapping range.  In all cases, the range is inclusive of
		 * the start and ending IP addresses.
		 * If to a CIDR address, lose 2: broadcast + network address
		 *			         (so subtract 1)
		 * If to a range, add one.
		 * If to a single IP address, set to 1.
		 */
		if (n->in_space) {
			if ((n->in_flags & IPN_IPRANGE) != 0)
				n->in_space += 1;
			else
				n->in_space -= 1;
		} else
			n->in_space = 1;
		if ((n->in_outmsk != 0xffffffff) && (n->in_outmsk != 0) &&
		    ((n->in_flags & (IPN_IPRANGE|IPN_SPLIT)) == 0))
			n->in_nip = ntohl(n->in_outip) + 1;
		else if ((n->in_flags & IPN_SPLIT) &&
			 (n->in_redir & NAT_REDIRECT))
			n->in_nip = ntohl(n->in_inip);
		else
			n->in_nip = ntohl(n->in_outip);
		if (n->in_redir & NAT_MAP) {
			n->in_pnext = ntohs(n->in_pmin);
			/*
			 * Multiply by the number of ports made available.
			 */
			if (ntohs(n->in_pmax) >= ntohs(n->in_pmin)) {
				n->in_space *= (ntohs(n->in_pmax) -
						ntohs(n->in_pmin) + 1);
				/*
				 * Because two different sources can map to
				 * different destinations but use the same
				 * local IP#/port #.
				 * If the result is smaller than in_space, then
				 * we may have wrapped around 32bits.
				 */
				i = n->in_inmsk;
				if ((i != 0) && (i != 0xffffffff)) {
					j = n->in_space * (~ntohl(i) + 1);
					if (j >= n->in_space)
						n->in_space = j;
					else
						n->in_space = 0xffffffff;
				}
			}
			/*
			 * If no protocol is specified, multiple by 256.
			 */
			if ((n->in_flags & IPN_TCPUDP) == 0) {
					j = n->in_space * 256;
					if (j >= n->in_space)
						n->in_space = j;
					else
						n->in_space = 0xffffffff;
			}
		}
		/* Otherwise, these fields are preset */
		n = NULL;
		nat_stats.ns_rules++;
		break;
	case SIOCRMNAT :
		if (!(mode & FWRITE)) {
			error = EPERM;
			n = NULL;
			break;
		}
		if (!n) {
			error = ESRCH;
			break;
		}
		if (n->in_redir & NAT_REDIRECT)
			nat_delrdr(n);
		if (n->in_redir & (NAT_MAPBLK|NAT_MAP))
			nat_delnat(n);
		if (nat_list == NULL) {
			nat_masks = 0;
			rdr_masks = 0;
		}
		*np = n->in_next;
		if (!n->in_use) {
			if (n->in_apr)
				appr_free(n->in_apr);
			KFREE(n);
			nat_stats.ns_rules--;
		} else {
			n->in_flags |= IPN_DELETE;
			n->in_next = NULL;
		}
		n = NULL;
		break;
	case SIOCGNATS :
		MUTEX_DOWNGRADE(&ipf_nat);
		nat_stats.ns_table[0] = nat_table[0];
		nat_stats.ns_table[1] = nat_table[1];
		nat_stats.ns_list = nat_list;
		nat_stats.ns_nattab_sz = ipf_nattable_sz;
		nat_stats.ns_rultab_sz = ipf_natrules_sz;
		nat_stats.ns_rdrtab_sz = ipf_rdrrules_sz;
		nat_stats.ns_instances = nat_instances;
		nat_stats.ns_apslist = ap_sess_list;
		error = IWCOPYPTR((char *)&nat_stats, (char *)data,
				  sizeof(nat_stats));
		break;
	case SIOCGNATL :
	    {
		natlookup_t nl;

		MUTEX_DOWNGRADE(&ipf_nat);
		error = IRCOPYPTR((char *)data, (char *)&nl, sizeof(nl));
		if (error)
			break;

		if (nat_lookupredir(&nl)) {
			error = IWCOPYPTR((char *)&nl, (char *)data,
					  sizeof(nl));
		} else
			error = ESRCH;
		break;
	    }
	case SIOCIPFFL :	/* old SIOCFLNAT & SIOCCNATL */
		if (!(mode & FWRITE)) {
			error = EPERM;
			break;
		}
		error = 0;
		if (arg == 0)
			ret = nat_flushtable();
		else if (arg == 1)
			ret = nat_clearlist();
		else
			error = EINVAL;
		MUTEX_DOWNGRADE(&ipf_nat);
		if (!error) {
			error = IWCOPY((caddr_t)&ret, data, sizeof(ret));
			if (error)
				error = EFAULT;
		}
		break;
	case SIOCSTLCK :
		error = IRCOPY(data, (caddr_t)&arg, sizeof(arg));
		if (!error) {
			error = IWCOPY((caddr_t)&fr_nat_lock, data,
					sizeof(fr_nat_lock));
			if (!error)
				fr_nat_lock = arg;
		} else
			error = EFAULT;
		break;
	case SIOCSTPUT :
		if (fr_nat_lock)
			error = fr_natputent(data);
		else
			error = EACCES;
		break;
	case SIOCSTGSZ :
		if (fr_nat_lock)
			error = fr_natgetsz(data);
		else
			error = EACCES;
		break;
	case SIOCSTGET :
		if (fr_nat_lock)
			error = fr_natgetent(data);
		else
			error = EACCES;
		break;
	case FIONREAD :
#ifdef	IPFILTER_LOG
		arg = (int)iplused[IPL_LOGNAT];
		MUTEX_DOWNGRADE(&ipf_nat);
		error = IWCOPY((caddr_t)&arg, (caddr_t)data, sizeof(arg));
		if (error)
			error = EFAULT;
#endif
		break;
	default :
		error = EINVAL;
		break;
	}
	RWLOCK_EXIT(&ipf_nat);			/* READ/WRITE */
done:
	if (nt)
		KFREE(nt);
	return error;
}


static int fr_natgetsz(data)
caddr_t data;
{
	ap_session_t *aps;
	nat_t *nat, *n;
	int error = 0;
	natget_t ng;

	error = IRCOPY(data, (caddr_t)&ng, sizeof(ng));
	if (error)
		return EFAULT;

	nat = ng.ng_ptr;
	if (!nat) {
		nat = nat_instances;
		ng.ng_sz = 0;
		if (nat == NULL) {
			error = IWCOPY((caddr_t)&ng, data, sizeof(ng));
			if (error)
				error = EFAULT;
			return error;
		}
	} else {
		/*
		 * Make sure the pointer we're copying from exists in the
		 * current list of entries.  Security precaution to prevent
		 * copying of random kernel data.
		 */
		for (n = nat_instances; n; n = n->nat_next)
			if (n == nat)
				break;
		if (!n)
			return ESRCH;
	}

	ng.ng_sz = sizeof(nat_save_t);
	aps = nat->nat_aps;
	if ((aps != NULL) && (aps->aps_data != 0)) {
		ng.ng_sz += sizeof(ap_session_t);
		ng.ng_sz += aps->aps_psiz;
	}

	error = IWCOPY((caddr_t)&ng, data, sizeof(ng));
	if (error)
		error = EFAULT;
	return error;
}


static int fr_natgetent(data)
caddr_t data;
{
	nat_save_t ipn, *ipnp, *ipnn = NULL;
	register nat_t *n, *nat;
	ap_session_t *aps;
	int error;

	error = IRCOPY(data, (caddr_t)&ipnp, sizeof(ipnp));
	if (error)
		return EFAULT;
	error = IRCOPY((caddr_t)ipnp, (caddr_t)&ipn, sizeof(ipn));
	if (error)
		return EFAULT;

	nat = ipn.ipn_next;
	if (!nat) {
		nat = nat_instances;
		if (nat == NULL) {
			if (nat_instances == NULL)
				return ENOENT;
			return 0;
		}
	} else {
		/*
		 * Make sure the pointer we're copying from exists in the
		 * current list of entries.  Security precaution to prevent
		 * copying of random kernel data.
		 */
		for (n = nat_instances; n; n = n->nat_next)
			if (n == nat)
				break;
		if (!n)
			return ESRCH;
	}

	ipn.ipn_next = nat->nat_next;
	ipn.ipn_dsize = 0;
	bcopy((char *)nat, (char *)&ipn.ipn_nat, sizeof(ipn.ipn_nat));
	ipn.ipn_nat.nat_data = NULL;

	if (nat->nat_ptr) {
		bcopy((char *)nat->nat_ptr, (char *)&ipn.ipn_ipnat,
		      sizeof(ipn.ipn_ipnat));
	}

	if (nat->nat_fr)
		bcopy((char *)nat->nat_fr, (char *)&ipn.ipn_rule,
		      sizeof(ipn.ipn_rule));

	if ((aps = nat->nat_aps)) {
		ipn.ipn_dsize = sizeof(*aps);
		if (aps->aps_data)
			ipn.ipn_dsize += aps->aps_psiz;
		KMALLOCS(ipnn, nat_save_t *, sizeof(*ipnn) + ipn.ipn_dsize);
		if (ipnn == NULL)
			return ENOMEM;
		bcopy((char *)&ipn, (char *)ipnn, sizeof(ipn));

		bcopy((char *)aps, ipnn->ipn_data, sizeof(*aps));
		if (aps->aps_data) {
			bcopy(aps->aps_data, ipnn->ipn_data + sizeof(*aps),
			      aps->aps_psiz);
			ipnn->ipn_dsize += aps->aps_psiz;
		}
		error = IWCOPY((caddr_t)ipnn, ipnp,
			       sizeof(ipn) + ipn.ipn_dsize);
		if (error)
			error = EFAULT;
		KFREES(ipnn, sizeof(*ipnn) + ipn.ipn_dsize);
	} else {
		error = IWCOPY((caddr_t)&ipn, ipnp, sizeof(ipn));
		if (error)
			error = EFAULT;
	}
	return error;
}


static int fr_natputent(data)
caddr_t data;
{
	nat_save_t ipn, *ipnp, *ipnn = NULL;
	register nat_t *n, *nat;
	ap_session_t *aps;
	frentry_t *fr;
	ipnat_t *in;

	int error;

	error = IRCOPY(data, (caddr_t)&ipnp, sizeof(ipnp));
	if (error)
		return EFAULT;
	error = IRCOPY((caddr_t)ipnp, (caddr_t)&ipn, sizeof(ipn));
	if (error)
		return EFAULT;
	nat = NULL;
	if (ipn.ipn_dsize) {
		KMALLOCS(ipnn, nat_save_t *, sizeof(ipn) + ipn.ipn_dsize);
		if (ipnn == NULL)
			return ENOMEM;
		bcopy((char *)&ipn, (char *)ipnn, sizeof(ipn));
		error = IRCOPY((caddr_t)ipnp, (caddr_t)ipn.ipn_data,
			       ipn.ipn_dsize);
		if (error) {
			error = EFAULT;
			goto junkput;
		}
	} else
		ipnn = NULL;

	KMALLOC(nat, nat_t *);
	if (nat == NULL) {
		error = EFAULT;
		goto junkput;
	}

	bcopy((char *)&ipn.ipn_nat, (char *)nat, sizeof(*nat));
	/*
	 * Initialize all these so that nat_delete() doesn't cause a crash.
	 */
	nat->nat_phnext[0] = NULL;
	nat->nat_phnext[1] = NULL;
	fr = nat->nat_fr;
	nat->nat_fr = NULL;
	aps = nat->nat_aps;
	nat->nat_aps = NULL;
	in = nat->nat_ptr;
	nat->nat_ptr = NULL;
	nat->nat_data = NULL;

	/*
	 * Restore the rule associated with this nat session
	 */
	if (in) {
		KMALLOC(in, ipnat_t *);
		if (in == NULL) {
			error = ENOMEM;
			goto junkput;
		}
		nat->nat_ptr = in;
		bcopy((char *)&ipn.ipn_ipnat, (char *)in, sizeof(*in));
		in->in_use = 1;
		in->in_flags |= IPN_DELETE;
		in->in_next = NULL;
		in->in_rnext = NULL;
		in->in_prnext = NULL;
		in->in_mnext = NULL;
		in->in_pmnext = NULL;
		in->in_ifp = GETUNIT(in->in_ifname, 4);
		if (in->in_plabel[0] != '\0') {
			in->in_apr = appr_match(in->in_p, in->in_plabel);
		}
	}

	/*
	 * Restore ap_session_t structure.  Include the private data allocated
	 * if it was there.
	 */
	if (aps) {
		KMALLOC(aps, ap_session_t *);
		if (aps == NULL) {
			error = ENOMEM;
			goto junkput;
		}
		nat->nat_aps = aps;
		aps->aps_next = ap_sess_list;
		ap_sess_list = aps;
		bcopy(ipnn->ipn_data, (char *)aps, sizeof(*aps));
		if (in)
			aps->aps_apr = in->in_apr;
		if (aps->aps_psiz) {
			KMALLOCS(aps->aps_data, void *, aps->aps_psiz);
			if (aps->aps_data == NULL) {
				error = ENOMEM;
				goto junkput;
			}
			bcopy(ipnn->ipn_data + sizeof(*aps), aps->aps_data,
			      aps->aps_psiz);
		} else {
			aps->aps_psiz = 0;
			aps->aps_data = NULL;
		}
	}

	/*
	 * If there was a filtering rule associated with this entry then
	 * build up a new one.
	 */
	if (fr != NULL) {
		if (nat->nat_flags & FI_NEWFR) {
			KMALLOC(fr, frentry_t *);
			nat->nat_fr = fr;
			if (fr == NULL) {
				error = ENOMEM;
				goto junkput;
			}
			bcopy((char *)&ipn.ipn_fr, (char *)fr, sizeof(*fr));
			ipn.ipn_nat.nat_fr = fr;
			error = IWCOPY((caddr_t)&ipn, ipnp, sizeof(ipn));
			if (error) {
				error = EFAULT;
				goto junkput;
			}
		} else {
			for (n = nat_instances; n; n = n->nat_next)
				if (n->nat_fr == fr)
					break;
			if (!n) {
				error = ESRCH;
				goto junkput;
			}
		}
	}

	if (ipnn)
		KFREES(ipnn, sizeof(ipn) + ipn.ipn_dsize);
	nat_insert(nat);
	return 0;
junkput:
	if (ipnn)
		KFREES(ipnn, sizeof(ipn) + ipn.ipn_dsize);
	if (nat)
		nat_delete(nat);
	return error;
}


/*
 * Delete a nat entry from the various lists and table.
 */
static void nat_delete(natd)
struct nat *natd;
{
	struct ipnat *ipn;

	if (natd->nat_flags & FI_WILDP)
		nat_stats.ns_wilds--;
	if (natd->nat_hnext[0])
		natd->nat_hnext[0]->nat_phnext[0] = natd->nat_phnext[0];
	*natd->nat_phnext[0] = natd->nat_hnext[0];
	if (natd->nat_hnext[1])
		natd->nat_hnext[1]->nat_phnext[1] = natd->nat_phnext[1];
	*natd->nat_phnext[1] = natd->nat_hnext[1];

	if (natd->nat_fr != NULL) {
		ATOMIC_DEC32(natd->nat_fr->fr_ref);
	}

	if (natd->nat_hm != NULL)
		nat_hostmapdel(natd->nat_hm);

	/*
	 * If there is an active reference from the nat entry to its parent
	 * rule, decrement the rule's reference count and free it too if no
	 * longer being used.
	 */
	ipn = natd->nat_ptr;
	if (ipn != NULL) {
		ipn->in_space++;
		ipn->in_use--;
		if (!ipn->in_use && (ipn->in_flags & IPN_DELETE)) {
			if (ipn->in_apr)
				appr_free(ipn->in_apr);
			KFREE(ipn);
			nat_stats.ns_rules--;
		}
	}

	MUTEX_DESTROY(&natd->nat_lock);
	/*
	 * If there's a fragment table entry too for this nat entry, then
	 * dereference that as well.
	 */
	ipfr_forget((void *)natd);
	aps_free(natd->nat_aps);
	nat_stats.ns_inuse--;
	KFREE(natd);
}


/*
 * nat_flushtable - clear the NAT table of all mapping entries.
 */
static int nat_flushtable()
{
	register nat_t *nat, **natp;
	register int j = 0;

	/*
	 * ALL NAT mappings deleted, so lets just make the deletions
	 * quicker.
	 */
	if (nat_table[0] != NULL)
		bzero((char *)nat_table[0],
		      sizeof(nat_table[0]) * ipf_nattable_sz);
	if (nat_table[1] != NULL)
		bzero((char *)nat_table[1],
		      sizeof(nat_table[1]) * ipf_nattable_sz);

	for (natp = &nat_instances; (nat = *natp); ) {
		*natp = nat->nat_next;
#ifdef	IPFILTER_LOG
		nat_log(nat, NL_FLUSH);
#endif
		nat_delete(nat);
		j++;
	}
	nat_stats.ns_inuse = 0;
	return j;
}


/*
 * nat_clearlist - delete all rules in the active NAT mapping list.
 */
int nat_clearlist()
{
	register ipnat_t *n, **np = &nat_list;
	int i = 0;

	if (nat_rules != NULL)
		bzero((char *)nat_rules, sizeof(*nat_rules) * ipf_natrules_sz);
	if (rdr_rules != NULL)
		bzero((char *)rdr_rules, sizeof(*rdr_rules) * ipf_rdrrules_sz);

	while ((n = *np)) {
		*np = n->in_next;
		if (!n->in_use) {
			if (n->in_apr)
				appr_free(n->in_apr);
			KFREE(n);
			nat_stats.ns_rules--;
		} else {
			n->in_flags |= IPN_DELETE;
			n->in_next = NULL;
		}
		i++;
	}
	nat_masks = 0;
	rdr_masks = 0;
	return i;
}


/*
 * Create a new NAT table entry.
 * NOTE: assumes write lock on ipf_nat has been obtained already.
 */
nat_t *nat_new(np, ip, fin, flags, direction)
ipnat_t *np;
ip_t *ip;
fr_info_t *fin;
u_int flags;
int direction;
{
	register u_32_t sum1, sum2, sumd, l;
	u_short port = 0, sport = 0, dport = 0, nport = 0;
	struct in_addr in, inb;
	tcphdr_t *tcp = NULL;
	hostmap_t *hm = NULL;
	nat_t *nat, *natl;
	u_short nflags;
#if SOLARIS && defined(_KERNEL) && (SOLARIS2 >= 6)
	qif_t *qf = fin->fin_qif;
#endif

	nflags = flags & np->in_flags;
	if (flags & IPN_TCPUDP) {
		tcp = (tcphdr_t *)fin->fin_dp;
		sport = tcp->th_sport;
		dport = tcp->th_dport;
	}

	/* Give me a new nat */
	KMALLOC(nat, nat_t *);
	if (nat == NULL) {
		nat_stats.ns_memfail++;
		return NULL;
	}

	bzero((char *)nat, sizeof(*nat));
	nat->nat_flags = flags;
	if (flags & FI_WILDP)
		nat_stats.ns_wilds++;
	/*
	 * Search the current table for a match.
	 */
	if (direction == NAT_OUTBOUND) {
		/*
		 * Values at which the search for a free resouce starts.
		 */
		u_32_t st_ip;
		u_short st_port;

		/*
		 * If it's an outbound packet which doesn't match any existing
		 * record, then create a new port
		 */
		l = 0;
		st_ip = np->in_nip;
		st_port = np->in_pnext;

		do {
			port = 0;
			in.s_addr = htonl(np->in_nip);
			if (l == 0) {
				/*
				 * Check to see if there is an existing NAT
				 * setup for this IP address pair.
				 */
				hm = nat_hostmap(np, ip->ip_src, in);
				if (hm != NULL)
					in.s_addr = hm->hm_mapip.s_addr;
			} else if ((l == 1) && (hm != NULL)) {
				nat_hostmapdel(hm);
				hm = NULL;
			}
			in.s_addr = ntohl(in.s_addr);

			nat->nat_hm = hm;

			if ((np->in_outmsk == 0xffffffff) &&
			    (np->in_pnext == 0)) {
				if (l > 0)
					goto badnat;
			}

			if (np->in_redir & NAT_MAPBLK) {
				if ((l >= np->in_ppip) || ((l > 0) &&
				     !(flags & IPN_TCPUDP)))
					goto badnat;
				/*
				 * map-block - Calculate destination address.
				 */
				in.s_addr = ntohl(ip->ip_src.s_addr);
				in.s_addr &= ntohl(~np->in_inmsk);
				inb.s_addr = in.s_addr;
				in.s_addr /= np->in_ippip;
				in.s_addr &= ntohl(~np->in_outmsk);
				in.s_addr += ntohl(np->in_outip);
				/*
				 * Calculate destination port.
				 */
				if ((flags & IPN_TCPUDP) &&
				    (np->in_ppip != 0)) {
					port = ntohs(sport) + l;
					port %= np->in_ppip;
					port += np->in_ppip *
						(inb.s_addr % np->in_ippip);
					port += MAPBLK_MINPORT;
					port = htons(port);
				}
			} else if (!np->in_outip &&
				   (np->in_outmsk == 0xffffffff)) {
				/*
				 * 0/32 - use the interface's IP address.
				 */
				if ((l > 0) ||
				    fr_ifpaddr(4, fin->fin_ifp, &in) == -1)
					goto badnat;
				in.s_addr = ntohl(in.s_addr);
			} else if (!np->in_outip && !np->in_outmsk) {
				/*
				 * 0/0 - use the original source address/port.
				 */
				if (l > 0)
					goto badnat;
				in.s_addr = ntohl(ip->ip_src.s_addr);
			} else if ((np->in_outmsk != 0xffffffff) &&
				   (np->in_pnext == 0) &&
				   ((l > 0) || (hm == NULL)))
				np->in_nip++;
			natl = NULL;

			if ((nflags & IPN_TCPUDP) &&
			    ((np->in_redir & NAT_MAPBLK) == 0) &&
			    (np->in_flags & IPN_AUTOPORTMAP)) {
				if ((l > 0) && (l % np->in_ppip == 0)) {
					if (l > np->in_space) {
						goto badnat;
					} else if ((l > np->in_ppip) &&
						   np->in_outmsk != 0xffffffff)
						np->in_nip++;
				}
				if (np->in_ppip != 0) {
					port = ntohs(sport);
					port += (l % np->in_ppip);
					port %= np->in_ppip;
					port += np->in_ppip *
						(ntohl(ip->ip_src.s_addr) %
						 np->in_ippip);
					port += MAPBLK_MINPORT;
					port = htons(port);
				}
			} else if (((np->in_redir & NAT_MAPBLK) == 0) &&
				   (nflags & IPN_TCPUDP) &&
				   (np->in_pnext != 0)) {
				port = htons(np->in_pnext++);
				if (np->in_pnext > ntohs(np->in_pmax)) {
					np->in_pnext = ntohs(np->in_pmin);
					if (np->in_outmsk != 0xffffffff)
						np->in_nip++;
				}
			}

			if (np->in_flags & IPN_IPRANGE) {
				if (np->in_nip > ntohl(np->in_outmsk))
					np->in_nip = ntohl(np->in_outip);
			} else {
				if ((np->in_outmsk != 0xffffffff) &&
				    ((np->in_nip + 1) & ntohl(np->in_outmsk)) >
				    ntohl(np->in_outip))
					np->in_nip = ntohl(np->in_outip) + 1;
			}

			if (!port && (flags & IPN_TCPUDP))
				port = sport;

			/*
			 * Here we do a lookup of the connection as seen from
			 * the outside.  If an IP# pair already exists, try
			 * again.  So if you have A->B becomes C->B, you can
			 * also have D->E become C->E but not D->B causing
			 * another C->B.  Also take protocol and ports into
			 * account when determining whether a pre-existing
			 * NAT setup will cause an external conflict where
			 * this is appropriate.
			 */
			inb.s_addr = htonl(in.s_addr);
			natl = nat_inlookup(fin->fin_ifp, flags & ~FI_WILDP,
					    (u_int)ip->ip_p, ip->ip_dst, inb,
					    (port << 16) | dport, 1);

			/*
			 * Has the search wrapped around and come back to the
			 * start ?
			 */
			if ((natl != NULL) &&
			    (np->in_pnext != 0) && (st_port == np->in_pnext) &&
			    (np->in_nip != 0) && (st_ip == np->in_nip))
				goto badnat;
			l++;
		} while (natl != NULL);

		if (np->in_space > 0)
			np->in_space--;

		/* Setup the NAT table */
		nat->nat_inip = ip->ip_src;
		nat->nat_outip.s_addr = htonl(in.s_addr);
		nat->nat_oip = ip->ip_dst;
		if (nat->nat_hm == NULL)
			nat->nat_hm = nat_hostmap(np, ip->ip_src,
						  nat->nat_outip);

		sum1 = LONG_SUM(ntohl(ip->ip_src.s_addr)) + ntohs(sport);
		sum2 = LONG_SUM(in.s_addr) + ntohs(port);

		if (flags & IPN_TCPUDP) {
			nat->nat_inport = sport;
			nat->nat_outport = port;	/* sport */
			nat->nat_oport = dport;
		}
	} else {
		/*
		 * Otherwise, it's an inbound packet. Most likely, we don't
		 * want to rewrite source ports and source addresses. Instead,
		 * we want to rewrite to a fixed internal address and fixed
		 * internal port.
		 */
		if (np->in_flags & IPN_SPLIT) {
			in.s_addr = np->in_nip;
			if (np->in_inip == htonl(in.s_addr))
				np->in_nip = ntohl(np->in_inmsk);
			else {
				np->in_nip = ntohl(np->in_inip);
				if (np->in_flags & IPN_ROUNDR) {
					nat_delrdr(np);
					nat_addrdr(np);
				}
			}
		} else {
			in.s_addr = ntohl(np->in_inip);
			if (np->in_flags & IPN_ROUNDR) {
				nat_delrdr(np);
				nat_addrdr(np);
			}
		}
		if (!np->in_pnext)
			nport = dport;
		else {
			/*
			 * Whilst not optimized for the case where
			 * pmin == pmax, the gain is not significant.
			 */
			nport = ntohs(dport) - ntohs(np->in_pmin) +
				ntohs(np->in_pnext);
			nport = htons(nport);
		}

		/*
		 * When the redirect-to address is set to 0.0.0.0, just
		 * assume a blank `forwarding' of the packet.  We don't
		 * setup any translation for this either.
		 */
		if (in.s_addr == 0) {
			if (nport == dport)
				goto badnat;
			in.s_addr = ntohl(ip->ip_dst.s_addr);
		}

		nat->nat_inip.s_addr = htonl(in.s_addr);
		nat->nat_outip = ip->ip_dst;
		nat->nat_oip = ip->ip_src;

		sum1 = LONG_SUM(ntohl(ip->ip_dst.s_addr)) + ntohs(dport);
		sum2 = LONG_SUM(in.s_addr) + ntohs(nport);

		if (flags & IPN_TCPUDP) {
			nat->nat_inport = nport;
			nat->nat_outport = dport;
			nat->nat_oport = sport;
		}
	}

	CALC_SUMD(sum1, sum2, sumd);
	nat->nat_sumd[0] = (sumd & 0xffff) + (sumd >> 16);
#if SOLARIS && defined(_KERNEL) && (SOLARIS2 >= 6)
	if ((flags == IPN_TCP) && dohwcksum &&
	    (qf->qf_ill->ill_ick.ick_magic == ICK_M_CTL_MAGIC)) {
		if (direction == NAT_OUTBOUND)
			sum1 = LONG_SUM(ntohl(in.s_addr));
		else
			sum1 = LONG_SUM(ntohl(ip->ip_src.s_addr));
		sum1 += LONG_SUM(ntohl(ip->ip_dst.s_addr));
		sum1 += 30;
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);
		nat->nat_sumd[1] = NAT_HW_CKSUM|(sum1 & 0xffff);
	} else
#endif
		nat->nat_sumd[1] = nat->nat_sumd[0];

	if ((flags & IPN_TCPUDP) && ((sport != port) || (dport != nport))) {
		if (direction == NAT_OUTBOUND)
			sum1 = LONG_SUM(ntohl(ip->ip_src.s_addr));
		else
			sum1 = LONG_SUM(ntohl(ip->ip_dst.s_addr));

		sum2 = LONG_SUM(in.s_addr);

		CALC_SUMD(sum1, sum2, sumd);
		nat->nat_ipsumd = (sumd & 0xffff) + (sumd >> 16);
	} else
		nat->nat_ipsumd = nat->nat_sumd[0];

	in.s_addr = htonl(in.s_addr);

#ifdef  _KERNEL
	strncpy(nat->nat_ifname, IFNAME(fin->fin_ifp), IFNAMSIZ);
#endif
	nat_insert(nat);

	nat->nat_dir = direction;
	nat->nat_ifp = fin->fin_ifp;
	nat->nat_ptr = np;
	nat->nat_p = ip->ip_p;
	nat->nat_bytes = 0;
	nat->nat_pkts = 0;
	nat->nat_fr = fin->fin_fr;
	if (nat->nat_fr != NULL) {
		ATOMIC_INC32(nat->nat_fr->fr_ref);
	}
	if (direction == NAT_OUTBOUND) {
		if (flags & IPN_TCPUDP)
			tcp->th_sport = port;
	} else {
		if (flags & IPN_TCPUDP)
			tcp->th_dport = nport;
	}
	np->in_use++;
#ifdef	IPFILTER_LOG
	nat_log(nat, (u_int)np->in_redir);
#endif
	return nat;
badnat:
	nat_stats.ns_badnat++;
	if ((hm = nat->nat_hm) != NULL)
		nat_hostmapdel(hm);
	KFREE(nat);
	return NULL;
}


void	nat_insert(nat)
nat_t	*nat;
{
	nat_t **natp;
	u_int hv;

	MUTEX_INIT(&nat->nat_lock, "nat entry lock", NULL);

	nat->nat_age = fr_defnatage;
	nat->nat_ifname[sizeof(nat->nat_ifname) - 1] = '\0';
	if (nat->nat_ifname[0] !='\0') {
		nat->nat_ifp = GETUNIT(nat->nat_ifname, 4);
	}

	nat->nat_next = nat_instances;
	nat_instances = nat;

	hv = NAT_HASH_FN(nat->nat_inip.s_addr, nat->nat_inport,
			 ipf_nattable_sz);
	natp = &nat_table[0][hv];
	if (*natp)
		(*natp)->nat_phnext[0] = &nat->nat_hnext[0];
	nat->nat_phnext[0] = natp;
	nat->nat_hnext[0] = *natp;
	*natp = nat;

	hv = NAT_HASH_FN(nat->nat_outip.s_addr, nat->nat_outport,
			 ipf_nattable_sz);
	natp = &nat_table[1][hv];
	if (*natp)
		(*natp)->nat_phnext[1] = &nat->nat_hnext[1];
	nat->nat_phnext[1] = natp;
	nat->nat_hnext[1] = *natp;
	*natp = nat;

	nat_stats.ns_added++;
	nat_stats.ns_inuse++;
}


nat_t *nat_icmplookup(ip, fin, dir)
ip_t *ip;
fr_info_t *fin;
int dir;
{
	icmphdr_t *icmp;
	tcphdr_t *tcp = NULL;
	ip_t *oip;
	int flags = 0, type, minlen;

	icmp = (icmphdr_t *)fin->fin_dp;
	/*
	 * Does it at least have the return (basic) IP header ?
	 * Only a basic IP header (no options) should be with an ICMP error
	 * header.
	 */
	if ((ip->ip_hl != 5) || (ip->ip_len < ICMPERR_MINPKTLEN))
		return NULL;
	type = icmp->icmp_type;
	/*
	 * If it's not an error type, then return.
	 */
	if ((type != ICMP_UNREACH) && (type != ICMP_SOURCEQUENCH) &&
	    (type != ICMP_REDIRECT) && (type != ICMP_TIMXCEED) &&
	    (type != ICMP_PARAMPROB))
		return NULL;

	oip = (ip_t *)((char *)fin->fin_dp + 8);
	minlen = (oip->ip_hl << 2);
	if (minlen < sizeof(ip_t))
		return NULL;
	if (ip->ip_len < ICMPERR_IPICMPHLEN + minlen)
		return NULL;
	/*
	 * Is the buffer big enough for all of it ?  It's the size of the IP
	 * header claimed in the encapsulated part which is of concern.  It
	 * may be too big to be in this buffer but not so big that it's
	 * outside the ICMP packet, leading to TCP deref's causing problems.
	 * This is possible because we don't know how big oip_hl is when we
	 * do the pullup early in fr_check() and thus can't gaurantee it is
	 * all here now.
	 */
#ifdef  _KERNEL
	{
	mb_t *m;

# if SOLARIS
	m = fin->fin_qfm;
	if ((char *)oip + fin->fin_dlen - ICMPERR_ICMPHLEN > (char *)m->b_wptr)
		return NULL;
# else
	m = *(mb_t **)fin->fin_mp;
	if ((char *)oip + fin->fin_dlen - ICMPERR_ICMPHLEN >
	    (char *)ip + m->m_len)
		return NULL;
# endif
	}
#endif

	if (oip->ip_p == IPPROTO_TCP)
		flags = IPN_TCP;
	else if (oip->ip_p == IPPROTO_UDP)
		flags = IPN_UDP;
	if (flags & IPN_TCPUDP) {
		minlen += 8;		/* + 64bits of data to get ports */
		if (ip->ip_len < ICMPERR_IPICMPHLEN + minlen)
			return NULL;
		tcp = (tcphdr_t *)((char *)oip + (oip->ip_hl << 2));
		if (dir == NAT_INBOUND)
			return nat_inlookup(fin->fin_ifp, flags,
				(u_int)oip->ip_p, oip->ip_dst, oip->ip_src,
				(tcp->th_sport << 16) | tcp->th_dport, 0);
		else
			return nat_outlookup(fin->fin_ifp, flags,
				(u_int)oip->ip_p, oip->ip_dst, oip->ip_src,
				(tcp->th_sport << 16) | tcp->th_dport, 0);
	}
	if (dir == NAT_INBOUND)
		return nat_inlookup(fin->fin_ifp, 0, (u_int)oip->ip_p,
			oip->ip_dst, oip->ip_src, 0, 0);
	else
		return nat_outlookup(fin->fin_ifp, 0, (u_int)oip->ip_p,
			oip->ip_dst, oip->ip_src, 0, 0);
}


/*
 * This should *ONLY* be used for incoming packets to make sure a NAT'd ICMP
 * packet gets correctly recognised.
 */
nat_t *nat_icmp(ip, fin, nflags, dir)
ip_t *ip;
fr_info_t *fin;
u_int *nflags;
int dir;
{
	u_32_t sum1, sum2, sumd, sumd2 = 0;
	struct in_addr in;
	icmphdr_t *icmp;
	udphdr_t *udp;
	nat_t *nat;
	ip_t *oip;
	int flags = 0;

	if ((fin->fin_fi.fi_fl & FI_SHORT) || (ip->ip_off & IP_OFFMASK))
		return NULL;
	/*
	 * nat_icmplookup() will return NULL for `defective' packets.
	 */
	if ((ip->ip_v != 4) || !(nat = nat_icmplookup(ip, fin, dir)))
		return NULL;
	*nflags = IPN_ICMPERR;
	icmp = (icmphdr_t *)fin->fin_dp;
	oip = (ip_t *)&icmp->icmp_ip;
	if (oip->ip_p == IPPROTO_TCP)
		flags = IPN_TCP;
	else if (oip->ip_p == IPPROTO_UDP)
		flags = IPN_UDP;
	udp = (udphdr_t *)((((char *)oip) + (oip->ip_hl << 2)));
	/*
	 * Need to adjust ICMP header to include the real IP#'s and
	 * port #'s.  Only apply a checksum change relative to the
	 * IP address change as it will be modified again in ip_natout
	 * for both address and port.  Two checksum changes are
	 * necessary for the two header address changes.  Be careful
	 * to only modify the checksum once for the port # and twice
	 * for the IP#.
	 */

	/*
	 * Step 1
	 * Fix the IP addresses in the offending IP packet. You also need
	 * to adjust the IP header checksum of that offending IP packet
	 * and the ICMP checksum of the ICMP error message itself.
	 *
	 * Unfortunately, for UDP and TCP, the IP addresses are also contained
	 * in the pseudo header that is used to compute the UDP resp. TCP
	 * checksum. So, we must compensate that as well. Even worse, the
	 * change in the UDP and TCP checksums require yet another
	 * adjustment of the ICMP checksum of the ICMP error message.
	 *
	 * For the moment we forget about TCP, because that checksum is not
	 * in the first 8 bytes, so it will not be available in most cases.
	 */

	if (oip->ip_dst.s_addr == nat->nat_oip.s_addr) {
		sum1 = LONG_SUM(ntohl(oip->ip_src.s_addr));
		in = nat->nat_inip;
		oip->ip_src = in;
	} else {
		sum1 = LONG_SUM(ntohl(oip->ip_dst.s_addr));
		in = nat->nat_outip;
		oip->ip_dst = in;
	}

	sum2 = LONG_SUM(ntohl(in.s_addr));

	CALC_SUMD(sum1, sum2, sumd);

	if (nat->nat_dir == NAT_OUTBOUND) {
		/*
		 * Fix IP checksum of the offending IP packet to adjust for
		 * the change in the IP address.
		 *
		 * Normally, you would expect that the ICMP checksum of the 
		 * ICMP error message needs to be adjusted as well for the
		 * IP address change in oip.
		 * However, this is a NOP, because the ICMP checksum is 
		 * calculated over the complete ICMP packet, which includes the
		 * changed oip IP addresses and oip->ip_sum. However, these 
		 * two changes cancel each other out (if the delta for
		 * the IP address is x, then the delta for ip_sum is minus x), 
		 * so no change in the icmp_cksum is necessary.
		 *
		 * Be careful that nat_dir refers to the direction of the
		 * offending IP packet (oip), not to its ICMP response (icmp)
		 */
		fix_datacksum(&oip->ip_sum, sumd);

		/*
		 * Fix UDP pseudo header checksum to compensate for the
		 * IP address change.
		 */
		if (oip->ip_p == IPPROTO_UDP && udp->uh_sum) {
			/*
			 * The UDP checksum is optional, only adjust it 
			 * if it has been set.
			 */
			sum1 = ntohs(udp->uh_sum);
			fix_datacksum(&udp->uh_sum, sumd);
			sum2 = ntohs(udp->uh_sum);

			/*
			 * Fix ICMP checksum to compensate the UDP 
			 * checksum adjustment.
			 */
			CALC_SUMD(sum1, sum2, sumd);
			sumd2 = sumd;
		}

#if 0
		/*
		 * Fix TCP pseudo header checksum to compensate for the 
		 * IP address change. Before we can do the change, we
		 * must make sure that oip is sufficient large to hold
		 * the TCP checksum (normally it does not!).
		 */
		if (oip->ip_p == IPPROTO_TCP) {
		
		}
#endif
	} else {

		/*
		 * Fix IP checksum of the offending IP packet to adjust for
		 * the change in the IP address.
		 *
		 * Normally, you would expect that the ICMP checksum of the 
		 * ICMP error message needs to be adjusted as well for the
		 * IP address change in oip.
		 * However, this is a NOP, because the ICMP checksum is 
		 * calculated over the complete ICMP packet, which includes the
		 * changed oip IP addresses and oip->ip_sum. However, these 
		 * two changes cancel each other out (if the delta for
		 * the IP address is x, then the delta for ip_sum is minus x), 
		 * so no change in the icmp_cksum is necessary.
		 *
		 * Be careful that nat_dir refers to the direction of the
		 * offending IP packet (oip), not to its ICMP response (icmp)
		 */
		fix_datacksum(&oip->ip_sum, sumd);

/* XXX FV : without having looked at Solaris source code, it seems unlikely
 * that SOLARIS would compensate this in the kernel (a body of an IP packet 
 * in the data section of an ICMP packet). I have the feeling that this should
 * be unconditional, but I'm not in a position to check.
 */
#if !SOLARIS && !defined(__sgi)
		/*
		 * Fix UDP pseudo header checksum to compensate for the
		 * IP address change.
		 */
		if (oip->ip_p == IPPROTO_UDP && udp->uh_sum) {
			/*
			 * The UDP checksum is optional, only adjust it 
			 * if it has been set 
			 */
			sum1 = ntohs(udp->uh_sum);
			fix_datacksum(&udp->uh_sum, sumd);
			sum2 = ntohs(udp->uh_sum);

			/*
			 * Fix ICMP checksum to compensate the UDP 
			 * checksum adjustment.
			 */
			CALC_SUMD(sum1, sum2, sumd);
			sumd2 = sumd;
		}
		
#if 0
		/* 
		 * Fix TCP pseudo header checksum to compensate for the 
		 * IP address change. Before we can do the change, we
		 * must make sure that oip is sufficient large to hold
		 * the TCP checksum (normally it does not!).
		 */
		if (oip->ip_p == IPPROTO_TCP) {
		
		};
#endif
		
#endif
	}

	if ((flags & IPN_TCPUDP) != 0) {
		tcphdr_t *tcp;

		/*
		 * XXX - what if this is bogus hl and we go off the end ?
		 * In this case, nat_icmpinlookup() will have returned NULL.
		 */
		tcp = (tcphdr_t *)udp;

		/*
		 * Step 2 :
		 * For offending TCP/UDP IP packets, translate the ports as
		 * well, based on the NAT specification. Of course such
		 * a change must be reflected in the ICMP checksum as well.
		 *
		 * Advance notice : Now it becomes complicated :-)
		 *
		 * Since the port fields are part of the TCP/UDP checksum
		 * of the offending IP packet, you need to adjust that checksum
		 * as well... but, if you change, you must change the icmp
		 * checksum *again*, to reflect that change.
		 *
		 * To further complicate: the TCP checksum is not in the first
		 * 8 bytes of the offending ip packet, so it most likely is not
		 * available (we might have to fix that if the encounter a
		 * device that returns more than 8 data bytes on icmp error)
		 */

		if (nat->nat_oport == tcp->th_dport) {
			if (tcp->th_sport != nat->nat_inport) {
				/*
				 * Fix ICMP checksum to compensate port
				 * adjustment.
				 */
				sum1 = ntohs(tcp->th_sport);
				sum2 = ntohs(nat->nat_inport);
				CALC_SUMD(sum1, sum2, sumd);
				sumd2 += sumd;
				tcp->th_sport = nat->nat_inport;

				/*
				 * Fix udp checksum to compensate port
				 * adjustment.  NOTE : the offending IP packet
				 * flows the other direction compared to the
				 * ICMP message.
				 *
				 * The UDP checksum is optional, only adjust
				 * it if it has been set.
				 */
				if (oip->ip_p == IPPROTO_UDP && udp->uh_sum) {

					sum1 = ntohs(udp->uh_sum);
					fix_datacksum(&udp->uh_sum, sumd);
					sum2 = ntohs(udp->uh_sum);

					/*
					 * Fix ICMP checksum to 
					 * compensate UDP checksum 
					 * adjustment.
					 */
					CALC_SUMD(sum1, sum2, sumd);
					sumd2 += sumd;
				}
			}
		} else {
			if (tcp->th_dport != nat->nat_outport) {
				/*
				 * Fix ICMP checksum to compensate port
				 * adjustment.
				 */
				sum1 = ntohs(tcp->th_dport);
				sum2 = ntohs(nat->nat_outport);
				CALC_SUMD(sum1, sum2, sumd);
				sumd2 += sumd;
				tcp->th_dport = nat->nat_outport;

				/*
				 * Fix udp checksum to compensate port
				 * adjustment.   NOTE : the offending IP
				 * packet flows the other direction compared
				 * to the ICMP message.
				 *
				 * The UDP checksum is optional, only adjust
				 * it if it has been set.
				 */
				if (oip->ip_p == IPPROTO_UDP && udp->uh_sum) {

					sum1 = ntohs(udp->uh_sum);
					fix_datacksum(&udp->uh_sum, sumd);
					sum2 = ntohs(udp->uh_sum);

					/*
					 * Fix ICMP checksum to compensate
					 * UDP checksum adjustment.
					 */
					CALC_SUMD(sum1, sum2, sumd);
					sumd2 += sumd;
				}
			}
		}
		if (sumd2) {
			sumd2 = (sumd2 & 0xffff) + (sumd2 >> 16);
			sumd2 = (sumd2 & 0xffff) + (sumd2 >> 16);
			if (nat->nat_dir == NAT_OUTBOUND) {
				fix_outcksum(&icmp->icmp_cksum, sumd2);
			} else {
				fix_incksum(&icmp->icmp_cksum, sumd2);
			}
		}
	}
	nat->nat_age = fr_defnaticmpage;
	return nat;
}


/*
 * NB: these lookups don't lock access to the list, it assume it has already
 * been done!
 */
/*
 * Lookup a nat entry based on the mapped destination ip address/port and
 * real source address/port.  We use this lookup when receiving a packet,
 * we're looking for a table entry, based on the destination address.
 * NOTE: THE PACKET BEING CHECKED (IF FOUND) HAS A MAPPING ALREADY.
 */
nat_t *nat_inlookup(ifp, flags, p, src, mapdst, ports, rw)
void *ifp;
register u_int flags, p;
struct in_addr src , mapdst;
u_32_t ports;
int rw;
{
	register u_short sport, dport;
	register nat_t *nat;
	register int nflags;
	register u_32_t dst;
	u_int hv;

	dst = mapdst.s_addr;
	dport = ports >> 16;
	sport = ports & 0xffff;
	flags &= IPN_TCPUDP;

	hv = NAT_HASH_FN(dst, dport, ipf_nattable_sz);
	nat = nat_table[1][hv];
	for (; nat; nat = nat->nat_hnext[1]) {
		nflags = nat->nat_flags;
		if ((!ifp || ifp == nat->nat_ifp) &&
		    nat->nat_oip.s_addr == src.s_addr &&
		    nat->nat_outip.s_addr == dst &&
		    (((p == 0) && (flags == (nat->nat_flags & IPN_TCPUDP)))
		     || (p == nat->nat_p)) && (!flags ||
		     (((nat->nat_oport == sport) || (nflags & FI_W_DPORT)) &&
		      ((nat->nat_outport == dport) || (nflags & FI_W_SPORT)))))
			return nat;
	}
	if (!nat_stats.ns_wilds || !(flags & IPN_TCPUDP))
		return NULL;
	if (!rw) {
		RWLOCK_EXIT(&ipf_nat);
	}
	hv = NAT_HASH_FN(dst, 0, ipf_nattable_sz);
	if (!rw) {
		WRITE_ENTER(&ipf_nat);
	}
	nat = nat_table[1][hv];
	for (; nat; nat = nat->nat_hnext[1]) {
		nflags = nat->nat_flags;
		if (ifp && ifp != nat->nat_ifp)
			continue;
		if (!(nflags & IPN_TCPUDP))
			continue;
		if (!(nflags & FI_WILDP))
			continue;
		if (nat->nat_oip.s_addr != src.s_addr ||
		    nat->nat_outip.s_addr != dst)
			continue;
		if (((nat->nat_oport == sport) || (nflags & FI_W_DPORT)) &&
		    ((nat->nat_outport == dport) || (nflags & FI_W_SPORT))) {
			nat_tabmove(nat, ports);
			break;
		}
	}
	if (!rw) {
		MUTEX_DOWNGRADE(&ipf_nat);
	}
	return nat;
}


/*
 * This function is only called for TCP/UDP NAT table entries where the
 * original was placed in the table without hashing on the ports and we now
 * want to include hashing on port numbers.
 */
static void nat_tabmove(nat, ports)
nat_t *nat;
u_32_t ports;
{
	register u_short sport, dport;
	nat_t **natp;
	u_int hv;

	dport = ports >> 16;
	sport = ports & 0xffff;

	if (nat->nat_oport == dport) {
		nat->nat_inport = sport;
		nat->nat_outport = sport;
	}

	/*
	 * Remove the NAT entry from the old location
	 */
	if (nat->nat_hnext[0])
		nat->nat_hnext[0]->nat_phnext[0] = nat->nat_phnext[0];
	*nat->nat_phnext[0] = nat->nat_hnext[0];

	if (nat->nat_hnext[1])
		nat->nat_hnext[1]->nat_phnext[1] = nat->nat_phnext[1];
	*nat->nat_phnext[1] = nat->nat_hnext[1];

	/*
	 * Add into the NAT table in the new position
	 */
	hv = NAT_HASH_FN(nat->nat_inip.s_addr, sport, ipf_nattable_sz);
	natp = &nat_table[0][hv];
	if (*natp)
		(*natp)->nat_phnext[0] = &nat->nat_hnext[0];
	nat->nat_phnext[0] = natp;
	nat->nat_hnext[0] = *natp;
	*natp = nat;

	hv = NAT_HASH_FN(nat->nat_outip.s_addr, sport, ipf_nattable_sz);
	natp = &nat_table[1][hv];
	if (*natp)
		(*natp)->nat_phnext[1] = &nat->nat_hnext[1];
	nat->nat_phnext[1] = natp;
	nat->nat_hnext[1] = *natp;
	*natp = nat;
}


/*
 * Lookup a nat entry based on the source 'real' ip address/port and
 * destination address/port.  We use this lookup when sending a packet out,
 * we're looking for a table entry, based on the source address.
 * NOTE: THE PACKET BEING CHECKED (IF FOUND) HAS A MAPPING ALREADY.
 */
nat_t *nat_outlookup(ifp, flags, p, src, dst, ports, rw)
void *ifp;
register u_int flags, p;
struct in_addr src , dst;
u_32_t ports;
int rw;
{
	register u_short sport, dport;
	register nat_t *nat;
	register int nflags;
	u_32_t srcip;
	u_int hv;

	sport = ports & 0xffff;
	dport = ports >> 16;
	flags &= IPN_TCPUDP;
	srcip = src.s_addr;

	hv = NAT_HASH_FN(srcip, sport, ipf_nattable_sz);
	nat = nat_table[0][hv];
	for (; nat; nat = nat->nat_hnext[0]) {
		nflags = nat->nat_flags;

		if ((!ifp || ifp == nat->nat_ifp) &&
		    nat->nat_inip.s_addr == srcip &&
		    nat->nat_oip.s_addr == dst.s_addr &&
		    (((p == 0) && (flags == (nflags & IPN_TCPUDP)))
		     || (p == nat->nat_p)) && (!flags ||
		     ((nat->nat_inport == sport || nflags & FI_W_SPORT) &&
		      (nat->nat_oport == dport || nflags & FI_W_DPORT))))
			return nat;
	}
	if (!nat_stats.ns_wilds || !(flags & IPN_TCPUDP))
		return NULL;
	if (!rw) {
		RWLOCK_EXIT(&ipf_nat);
	}
	hv = NAT_HASH_FN(srcip, 0, ipf_nattable_sz);
	if (!rw) {
		WRITE_ENTER(&ipf_nat);
	}
	nat = nat_table[0][hv];
	for (; nat; nat = nat->nat_hnext[0]) {
		nflags = nat->nat_flags;
		if (ifp && ifp != nat->nat_ifp)
			continue;
		if (!(nflags & IPN_TCPUDP))
			continue;
		if (!(nflags & FI_WILDP))
			continue;
		if ((nat->nat_inip.s_addr != srcip) ||
		    (nat->nat_oip.s_addr != dst.s_addr))
			continue;
		if (((nat->nat_inport == sport) || (nflags & FI_W_SPORT)) &&
		    ((nat->nat_oport == dport) || (nflags & FI_W_DPORT))) {
			nat_tabmove(nat, ports);
			break;
		}
	}
	if (!rw) {
		MUTEX_DOWNGRADE(&ipf_nat);
	}
	return nat;
}


/*
 * Lookup the NAT tables to search for a matching redirect
 */
nat_t *nat_lookupredir(np)
register natlookup_t *np;
{
	u_32_t ports;
	nat_t *nat;

	ports = (np->nl_outport << 16) | np->nl_inport;
	/*
	 * If nl_inip is non null, this is a lookup based on the real
	 * ip address. Else, we use the fake.
	 */
	if ((nat = nat_outlookup(NULL, np->nl_flags, 0, np->nl_inip,
				 np->nl_outip, ports, 0))) {
		np->nl_realip = nat->nat_outip;
		np->nl_realport = nat->nat_outport;
	}
	return nat;
}


static int nat_match(fin, np, ip)
fr_info_t *fin;
ipnat_t *np;
ip_t *ip;
{
	frtuc_t *ft;

	if (ip->ip_v != 4)
		return 0;

	if (np->in_p && ip->ip_p != np->in_p)
		return 0;
	if (fin->fin_out) {
		if (!(np->in_redir & (NAT_MAP|NAT_MAPBLK)))
			return 0;
		if (((fin->fin_fi.fi_saddr & np->in_inmsk) != np->in_inip)
		    ^ ((np->in_flags & IPN_NOTSRC) != 0))
			return 0;
		if (((fin->fin_fi.fi_daddr & np->in_srcmsk) != np->in_srcip)
		    ^ ((np->in_flags & IPN_NOTDST) != 0))
			return 0;
	} else {
		if (!(np->in_redir & NAT_REDIRECT))
			return 0;
		if (((fin->fin_fi.fi_saddr & np->in_srcmsk) != np->in_srcip)
		    ^ ((np->in_flags & IPN_NOTSRC) != 0))
			return 0;
		if (((fin->fin_fi.fi_daddr & np->in_outmsk) != np->in_outip)
		    ^ ((np->in_flags & IPN_NOTDST) != 0))
			return 0;
	}

	ft = &np->in_tuc;
	if (!(fin->fin_fi.fi_fl & FI_TCPUDP) ||
	    (fin->fin_fi.fi_fl & FI_SHORT) || (ip->ip_off & IP_OFFMASK)) {
		if (ft->ftu_scmp || ft->ftu_dcmp)
			return 0;
		return 1;
	}

	return fr_tcpudpchk(ft, fin);
}


/*
 * Packets going out on the external interface go through this.
 * Here, the source address requires alteration, if anything.
 */
int ip_natout(ip, fin)
ip_t *ip;
fr_info_t *fin;
{
	register ipnat_t *np = NULL;
	register u_32_t ipa;
	tcphdr_t *tcp = NULL;
	u_short sport = 0, dport = 0, *csump = NULL;
	struct ifnet *ifp;
	int natadd = 1;
	frentry_t *fr;
	u_int nflags = 0, hv, msk;
	u_32_t iph;
	nat_t *nat;
	int i;

	if (nat_list == NULL || (fr_nat_lock))
		return 0;

	if ((fr = fin->fin_fr) && !(fr->fr_flags & FR_DUP) &&
	    fr->fr_tif.fd_ifp && fr->fr_tif.fd_ifp != (void *)-1)
		ifp = fr->fr_tif.fd_ifp;
	else
		ifp = fin->fin_ifp;

	if (!(ip->ip_off & IP_OFFMASK) && !(fin->fin_fi.fi_fl & FI_SHORT)) {
		if (ip->ip_p == IPPROTO_TCP)
			nflags = IPN_TCP;
		else if (ip->ip_p == IPPROTO_UDP)
			nflags = IPN_UDP;
		if ((nflags & IPN_TCPUDP)) {
			tcp = (tcphdr_t *)fin->fin_dp;
			sport = tcp->th_sport;
			dport = tcp->th_dport;
		}
	}

	ipa = ip->ip_src.s_addr;

	READ_ENTER(&ipf_nat);

	if ((ip->ip_p == IPPROTO_ICMP) &&
	    (nat = nat_icmp(ip, fin, &nflags, NAT_OUTBOUND)))
		;
	else if ((ip->ip_off & (IP_OFFMASK|IP_MF)) &&
	    (nat = ipfr_nat_knownfrag(ip, fin)))
		natadd = 0;
	else if ((nat = nat_outlookup(ifp, nflags, (u_int)ip->ip_p,
				      ip->ip_src, ip->ip_dst,
				      (dport << 16) | sport, 0))) {
		nflags = nat->nat_flags;
		if ((nflags & (FI_W_SPORT|FI_W_DPORT)) != 0) {
			if ((nflags & FI_W_SPORT) &&
			    (nat->nat_inport != sport))
				nat->nat_inport = sport;
			else if ((nflags & FI_W_DPORT) &&
				 (nat->nat_oport != dport))
				nat->nat_oport = dport;
			if (nat->nat_outport == 0)
				nat->nat_outport = sport;
			nat->nat_flags &= ~(FI_W_DPORT|FI_W_SPORT);
			nflags = nat->nat_flags;
			nat_stats.ns_wilds--;
		}
	} else {
		RWLOCK_EXIT(&ipf_nat);
		WRITE_ENTER(&ipf_nat);
		/*
		 * If there is no current entry in the nat table for this IP#,
		 * create one for it (if there is a matching rule).
		 */
		msk = 0xffffffff;
		i = 32;
maskloop:
		iph = ipa & htonl(msk);
		hv = NAT_HASH_FN(iph, 0, ipf_natrules_sz);
		for (np = nat_rules[hv]; np; np = np->in_mnext)
		{
			if ((np->in_ifp && (np->in_ifp != ifp)) ||
			    !np->in_space)
				continue;
			if ((np->in_flags & IPN_RF) &&
			    !(np->in_flags & nflags))
				continue;
			if (np->in_flags & IPN_FILTER) {
				if (!nat_match(fin, np, ip))
					continue;
			} else if ((ipa & np->in_inmsk) != np->in_inip)
				continue;
			if (np->in_redir & (NAT_MAP|NAT_MAPBLK)) {
				if (*np->in_plabel && !appr_ok(ip, tcp, np))
					continue;
				/*
				 * If it's a redirection, then we don't want to
				 * create new outgoing port stuff.
				 * Redirections are only for incoming
				 * connections.
				 */
				if (!(np->in_redir & (NAT_MAP|NAT_MAPBLK)))
					continue;
				if ((nat = nat_new(np, ip, fin, (u_int)nflags,
						    NAT_OUTBOUND))) {
					np->in_hits++;
					break;
				}
			}
		}
		if ((np == NULL) && (i > 0)) {
			do {
				i--;
				msk <<= 1;
			} while ((i >= 0) && ((nat_masks & (1 << i)) == 0));
			if (i >= 0)
				goto maskloop;
		}
		MUTEX_DOWNGRADE(&ipf_nat);
	}

	/*
	 * NOTE: ipf_nat must now only be held as a read lock
	 */
	if (nat) {
		np = nat->nat_ptr;
		if (natadd && (fin->fin_fi.fi_fl & FI_FRAG) &&
		    np && (np->in_flags & IPN_FRAG))
			ipfr_nat_newfrag(ip, fin, 0, nat);
		MUTEX_ENTER(&nat->nat_lock);
		nat->nat_age = fr_defnatage;
		nat->nat_bytes += ip->ip_len;
		nat->nat_pkts++;
		MUTEX_EXIT(&nat->nat_lock);

		/*
		 * Fix up checksums, not by recalculating them, but
		 * simply computing adjustments.
		 */
		if (nflags == IPN_ICMPERR) {
			u_32_t s1, s2, sumd;

			s1 = LONG_SUM(ntohl(ip->ip_src.s_addr));
			s2 = LONG_SUM(ntohl(nat->nat_outip.s_addr));
			CALC_SUMD(s1, s2, sumd);

			if (nat->nat_dir == NAT_OUTBOUND)
				fix_incksum(&ip->ip_sum, sumd);
			else
				fix_outcksum(&ip->ip_sum, sumd);
		}
#if SOLARIS || defined(__sgi)
		else {
			if (nat->nat_dir == NAT_OUTBOUND)
				fix_outcksum(&ip->ip_sum, nat->nat_ipsumd);
			else
				fix_incksum(&ip->ip_sum, nat->nat_ipsumd);
		}
#endif
		ip->ip_src = nat->nat_outip;

		if (!(ip->ip_off & IP_OFFMASK) &&
		    !(fin->fin_fi.fi_fl & FI_SHORT)) {

			if ((nat->nat_outport != 0) && (nflags & IPN_TCPUDP)) {
				tcp->th_sport = nat->nat_outport;
				fin->fin_data[0] = ntohs(tcp->th_sport);
			}

			if (ip->ip_p == IPPROTO_TCP) {
				csump = &tcp->th_sum;
				MUTEX_ENTER(&nat->nat_lock);
				fr_tcp_age(&nat->nat_age,
					   nat->nat_tcpstate, fin, 1);
				if (nat->nat_age < fr_defnaticmpage)
					nat->nat_age = fr_defnaticmpage;
#ifdef LARGE_NAT
				else if (nat->nat_age > fr_defnatage)
					nat->nat_age = fr_defnatage;
#endif
				/*
				 * Increase this because we may have
				 * "keep state" following this too and
				 * packet storms can occur if this is
				 * removed too quickly.
				 */
				if (nat->nat_age == fr_tcpclosed)
					nat->nat_age = fr_tcplastack;
				MUTEX_EXIT(&nat->nat_lock);
			} else if (ip->ip_p == IPPROTO_UDP) {
				udphdr_t *udp = (udphdr_t *)tcp;

				if (udp->uh_sum)
					csump = &udp->uh_sum;
			} else if (ip->ip_p == IPPROTO_ICMP) {
				nat->nat_age = fr_defnaticmpage;
			}

			if (csump) {
				if (nat->nat_dir == NAT_OUTBOUND)
					fix_outcksum(csump, nat->nat_sumd[1]);
				else
					fix_incksum(csump, nat->nat_sumd[1]);
			}
		}

		if ((np->in_apr != NULL) && (np->in_dport == 0 ||
		     (tcp != NULL && dport == np->in_dport))) {
			i = appr_check(ip, fin, nat);
			if (i == 0)
				i = 1;
		} else
			i = 1;
		ATOMIC_INCL(nat_stats.ns_mapped[1]);
		RWLOCK_EXIT(&ipf_nat);	/* READ */
		return i;
	}
	RWLOCK_EXIT(&ipf_nat);			/* READ/WRITE */
	return 0;
}


/*
 * Packets coming in from the external interface go through this.
 * Here, the destination address requires alteration, if anything.
 */
int ip_natin(ip, fin)
ip_t *ip;
fr_info_t *fin;
{
	register struct in_addr src;
	register struct in_addr in;
	register ipnat_t *np;
	u_int nflags = 0, natadd = 1, hv, msk;
	struct ifnet *ifp = fin->fin_ifp;
	tcphdr_t *tcp = NULL;
	u_short sport = 0, dport = 0, *csump = NULL;
	nat_t *nat;
	u_32_t iph;
	int i;

	if ((nat_list == NULL) || (ip->ip_v != 4) || (fr_nat_lock))
		return 0;

	if (!(ip->ip_off & IP_OFFMASK) && !(fin->fin_fi.fi_fl & FI_SHORT)) {
		if (ip->ip_p == IPPROTO_TCP)
			nflags = IPN_TCP;
		else if (ip->ip_p == IPPROTO_UDP)
			nflags = IPN_UDP;
		if ((nflags & IPN_TCPUDP)) {
			tcp = (tcphdr_t *)fin->fin_dp;
			dport = tcp->th_dport;
			sport = tcp->th_sport;
		}
	}

	in = ip->ip_dst;
	/* make sure the source address is to be redirected */
	src = ip->ip_src;

	READ_ENTER(&ipf_nat);

	if ((ip->ip_p == IPPROTO_ICMP) &&
	    (nat = nat_icmp(ip, fin, &nflags, NAT_INBOUND)))
		;
	else if ((ip->ip_off & (IP_OFFMASK|IP_MF)) &&
		 (nat = ipfr_nat_knownfrag(ip, fin)))
		natadd = 0;
	else if ((nat = nat_inlookup(fin->fin_ifp, nflags, (u_int)ip->ip_p,
				     ip->ip_src, in, (dport << 16) | sport,
				     0))) {
		nflags = nat->nat_flags;
		if ((nflags & (FI_W_SPORT|FI_W_DPORT)) != 0) {
			if ((nat->nat_oport != sport) && (nflags & FI_W_DPORT))
				nat->nat_oport = sport;
			else if ((nat->nat_outport != dport) &&
				 (nflags & FI_W_SPORT))
				nat->nat_outport = dport;
			nat->nat_flags &= ~(FI_W_SPORT|FI_W_DPORT);
			nflags = nat->nat_flags;
			nat_stats.ns_wilds--;
		}
	} else {
		RWLOCK_EXIT(&ipf_nat);
		WRITE_ENTER(&ipf_nat);
		/*
		 * If there is no current entry in the nat table for this IP#,
		 * create one for it (if there is a matching rule).
		 */
		msk = 0xffffffff;
		i = 32;
maskloop:
		iph = in.s_addr & htonl(msk);
		hv = NAT_HASH_FN(iph, 0, ipf_rdrrules_sz);
		for (np = rdr_rules[hv]; np; np = np->in_rnext) {
			if ((np->in_ifp && (np->in_ifp != ifp)) ||
			    (np->in_p && (np->in_p != ip->ip_p)) ||
			    (np->in_flags && !(nflags & np->in_flags)))
				continue;
			if (np->in_flags & IPN_FILTER) {
				if (!nat_match(fin, np, ip))
					continue;
			} else if ((in.s_addr & np->in_outmsk) != np->in_outip)
				continue;
			if ((np->in_redir & NAT_REDIRECT) &&
			    (!np->in_pmin || (np->in_flags & IPN_FILTER) ||
			     ((ntohs(np->in_pmax) >= ntohs(dport)) &&
			      (ntohs(dport) >= ntohs(np->in_pmin)))))
				if ((nat = nat_new(np, ip, fin, nflags,
						    NAT_INBOUND))) {
					np->in_hits++;
					break;
				}
		}

		if ((np == NULL) && (i > 0)) {
			do {
				i--;
				msk <<= 1;
			} while ((i >= 0) && ((rdr_masks & (1 << i)) == 0));
			if (i >= 0)
				goto maskloop;
		}
		MUTEX_DOWNGRADE(&ipf_nat);
	}

	/*
	 * NOTE: ipf_nat must now only be held as a read lock
	 */
	if (nat) {
		np = nat->nat_ptr;
		fin->fin_fr = nat->nat_fr;
		if (natadd && (fin->fin_fi.fi_fl & FI_FRAG) &&
		    np && (np->in_flags & IPN_FRAG))
			ipfr_nat_newfrag(ip, fin, 0, nat);
		if ((np->in_apr != NULL) && (np->in_dport == 0 ||
		    (tcp != NULL && sport == np->in_dport))) {
			i = appr_check(ip, fin, nat);
			if (i == -1) {
				RWLOCK_EXIT(&ipf_nat);
				return i;
			}
		}

		MUTEX_ENTER(&nat->nat_lock);
		if (nflags != IPN_ICMPERR)
			nat->nat_age = fr_defnatage;

		nat->nat_bytes += ip->ip_len;
		nat->nat_pkts++;
		MUTEX_EXIT(&nat->nat_lock);
		ip->ip_dst = nat->nat_inip;
		fin->fin_fi.fi_daddr = nat->nat_inip.s_addr;

		/*
		 * Fix up checksums, not by recalculating them, but
		 * simply computing adjustments.
		 */
#if SOLARIS || defined(__sgi)
		if (nat->nat_dir == NAT_OUTBOUND)
			fix_incksum(&ip->ip_sum, nat->nat_ipsumd);
		else
			fix_outcksum(&ip->ip_sum, nat->nat_ipsumd);
#endif
		if (!(ip->ip_off & IP_OFFMASK) &&
		    !(fin->fin_fi.fi_fl & FI_SHORT)) {

			if ((nat->nat_inport != 0) && (nflags & IPN_TCPUDP)) {
				tcp->th_dport = nat->nat_inport;
				fin->fin_data[1] = ntohs(tcp->th_dport);
			}

			if (ip->ip_p == IPPROTO_TCP) {
				csump = &tcp->th_sum;
				MUTEX_ENTER(&nat->nat_lock);
				fr_tcp_age(&nat->nat_age,
					   nat->nat_tcpstate, fin, 0);
				if (nat->nat_age < fr_defnaticmpage)
					nat->nat_age = fr_defnaticmpage;
#ifdef LARGE_NAT
				else if (nat->nat_age > fr_defnatage)
					nat->nat_age = fr_defnatage;
#endif
				/*
				 * Increase this because we may have
				 * "keep state" following this too and
				 * packet storms can occur if this is
				 * removed too quickly.
				 */
				if (nat->nat_age == fr_tcpclosed)
					nat->nat_age = fr_tcplastack;
				MUTEX_EXIT(&nat->nat_lock);
			} else if (ip->ip_p == IPPROTO_UDP) {
				udphdr_t *udp = (udphdr_t *)tcp;

				if (udp->uh_sum)
					csump = &udp->uh_sum;
			} else if (ip->ip_p == IPPROTO_ICMP) {
				nat->nat_age = fr_defnaticmpage;
			}

			if (csump) {
				if (nat->nat_dir == NAT_OUTBOUND)
					fix_incksum(csump, nat->nat_sumd[0]);
				else
					fix_outcksum(csump, nat->nat_sumd[0]);
			}
		}
		ATOMIC_INCL(nat_stats.ns_mapped[0]);
		RWLOCK_EXIT(&ipf_nat);			/* READ */
		return 1;
	}
	RWLOCK_EXIT(&ipf_nat);			/* READ/WRITE */
	return 0;
}


/*
 * Free all memory used by NAT structures allocated at runtime.
 */
void ip_natunload()
{
	WRITE_ENTER(&ipf_nat);
	(void) nat_clearlist();
	(void) nat_flushtable();
	RWLOCK_EXIT(&ipf_nat);

	if (nat_table[0] != NULL) {
		KFREES(nat_table[0], sizeof(nat_t *) * ipf_nattable_sz);
		nat_table[0] = NULL;
	}
	if (nat_table[1] != NULL) {
		KFREES(nat_table[1], sizeof(nat_t *) * ipf_nattable_sz);
		nat_table[1] = NULL;
	}
	if (nat_rules != NULL) {
		KFREES(nat_rules, sizeof(ipnat_t *) * ipf_natrules_sz);
		nat_rules = NULL;
	}
	if (rdr_rules != NULL) {
		KFREES(rdr_rules, sizeof(ipnat_t *) * ipf_rdrrules_sz);
		rdr_rules = NULL;
	}
	if (maptable != NULL) {
		KFREES(maptable, sizeof(hostmap_t *) * ipf_hostmap_sz);
		maptable = NULL;
	}
}


/*
 * Slowly expire held state for NAT entries.  Timeouts are set in
 * expectation of this being called twice per second.
 */
void ip_natexpire()
{
	register struct nat *nat, **natp;
#if defined(_KERNEL) && !SOLARIS
	int s;
#endif

	SPL_NET(s);
	WRITE_ENTER(&ipf_nat);
	for (natp = &nat_instances; (nat = *natp); ) {
		nat->nat_age--;
		if (nat->nat_age) {
			natp = &nat->nat_next;
			continue;
		}
		*natp = nat->nat_next;
#ifdef	IPFILTER_LOG
		nat_log(nat, NL_EXPIRE);
#endif
		nat_delete(nat);
		nat_stats.ns_expire++;
	}
	RWLOCK_EXIT(&ipf_nat);
	SPL_X(s);
}


/*
 */
void ip_natsync(ifp)
void *ifp;
{
	register ipnat_t *n;
	register nat_t *nat;
	register u_32_t sum1, sum2, sumd;
	struct in_addr in;
	ipnat_t *np;
	void *ifp2;
#if defined(_KERNEL) && !SOLARIS
	int s;
#endif

	/*
	 * Change IP addresses for NAT sessions for any protocol except TCP
	 * since it will break the TCP connection anyway.
	 */
	SPL_NET(s);
	WRITE_ENTER(&ipf_nat);
	for (nat = nat_instances; nat; nat = nat->nat_next)
		if (((ifp == NULL) || (ifp == nat->nat_ifp)) &&
		    !(nat->nat_flags & IPN_TCP) && (np = nat->nat_ptr) &&
		    (np->in_outmsk == 0xffffffff) && !np->in_nip) {
			ifp2 = nat->nat_ifp;
			/*
			 * Change the map-to address to be the same as the
			 * new one.
			 */
			sum1 = nat->nat_outip.s_addr;
			if (fr_ifpaddr(4, ifp2, &in) != -1)
				nat->nat_outip = in;
			sum2 = nat->nat_outip.s_addr;

			if (sum1 == sum2)
				continue;
			/*
			 * Readjust the checksum adjustment to take into
			 * account the new IP#.
			 */
			CALC_SUMD(sum1, sum2, sumd);
			/* XXX - dont change for TCP when solaris does
			 * hardware checksumming.
			 */
			sumd += nat->nat_sumd[0];
			nat->nat_sumd[0] = (sumd & 0xffff) + (sumd >> 16);
			nat->nat_sumd[1] = nat->nat_sumd[0];
		}

	for (n = nat_list; (n != NULL); n = n->in_next)
		if (n->in_ifp == ifp) {
			n->in_ifp = (void *)GETUNIT(n->in_ifname, 4);
			if (!n->in_ifp)
				n->in_ifp = (void *)-1;
		}
	RWLOCK_EXIT(&ipf_nat);
	SPL_X(s);
}


#ifdef	IPFILTER_LOG
void nat_log(nat, type)
struct nat *nat;
u_int type;
{
	struct ipnat *np;
	struct natlog natl;
	void *items[1];
	size_t sizes[1];
	int rulen, types[1];

	natl.nl_inip = nat->nat_inip;
	natl.nl_outip = nat->nat_outip;
	natl.nl_origip = nat->nat_oip;
	natl.nl_bytes = nat->nat_bytes;
	natl.nl_pkts = nat->nat_pkts;
	natl.nl_origport = nat->nat_oport;
	natl.nl_inport = nat->nat_inport;
	natl.nl_outport = nat->nat_outport;
	natl.nl_p = nat->nat_p;
	natl.nl_type = type;
	natl.nl_rule = -1;
#ifndef LARGE_NAT
	if (nat->nat_ptr != NULL) {
		for (rulen = 0, np = nat_list; np; np = np->in_next, rulen++)
			if (np == nat->nat_ptr) {
				natl.nl_rule = rulen;
				break;
			}
	}
#endif
	items[0] = &natl;
	sizes[0] = sizeof(natl);
	types[0] = 0;

	(void) ipllog(IPL_LOGNAT, NULL, items, sizes, types, 1);
}
#endif
@


1.40
log
@IPfilter 3.4.17; kjell@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.39 2001/02/06 17:29:30 fgsch Exp $	*/
@


1.39
log
@ipf/ipnat check the securelevel in the original code, so don't do it twice.
Also remove uneeded definition of ICMP_UNREACH_FILTER_PROHIB; this isn't
needed. Why keep adding things to make diffs harder?
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.38 2001/01/30 04:23:56 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1995-2000 by Darren Reed.
d14 1
a14 1
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.37.2.32 2001/01/10 06:19:11 darrenr Exp $";
d2283 2
a2284 1
		if (natadd && fin->fin_fi.fi_fl & FI_FRAG)
d2489 2
a2490 1
		if (natadd && fin->fin_fi.fi_fl & FI_FRAG)
@


1.38
log
@re-add local ipf changes that were whacked in the 3.4.16 merge. userland to follow
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.37 2001/01/17 07:25:19 fgsch Exp $	*/
a428 18
#if defined(_KERNEL)
# if defined(__OpenBSD__)
       	/* Prevent IPNAT changes when securelevel > 1 */
	if (securelevel > 1) {
		switch (cmd) {
		case SIOCIPFFL:
#  ifdef IPFILTER_LOG
		case SIOCIPFFB:
#  endif
		case SIOCADNAT:
		case SIOCRMNAT:
		case SIOCSTPUT:
		case SIOCSTLCK:
			return EPERM;
		}
	}
# endif /* OpenBSD */
#endif /* _KERNEL */
@


1.37
log
@IPF 3.4.16.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.36 2001/01/17 04:47:14 fgsch Exp $	*/
d100 1
a100 1
#include "netinet/ip_compat.h"
d102 5
a106 5
#include "netinet/ip_fil.h"
#include "netinet/ip_proxy.h"
#include "netinet/ip_nat.h"
#include "netinet/ip_frag.h"
#include "netinet/ip_state.h"
a344 3
#ifdef sparc
	sum1 = (~(*sp)) & 0xffff;
#else
a345 1
#endif
d429 18
@


1.36
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d14 1
a14 1
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.37.2.31 2000/12/16 21:06:40 darrenr Exp $";
d2053 1
a2053 1
		    (((p == 0) && (flags == (nat->nat_flags & IPN_TCPUDP)))
@


1.35
log
@Whoops. Reapply Aaron's detach code fix. inadvertantly whacked in the
3.3.18 import.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.34 2000/08/10 05:50:26 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1995-1998 by Darren Reed.
d14 1
a14 1
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.2.2.21 2000/08/08 16:00:33 darrenr Exp $";
d100 1
a100 1
#include <netinet/ip_fil_compat.h>
d102 5
a106 5
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_frag.h>
#include <netinet/ip_state.h>
d122 1
d127 1
d132 1
d139 2
a140 1
static	int	nat_clearlist __P((void));
d144 8
d179 6
d189 1
a189 1
void nat_delrdr(n)
d192 24
a215 2
	ipnat_t **n1;
	u_32_t iph;
d217 1
d219 20
a238 6
	iph = n->in_outip & n->in_outmsk;
	hv = NAT_HASH_FN(iph, ipf_rdrrules_sz);
	for (n1 = &rdr_rules[hv]; *n1 && (*n1 != n); n1 = &(*n1)->in_rnext)
		;
	if (*n1)
		*n1 = n->in_rnext;
d245 18
a262 2
	ipnat_t **n1;
	u_32_t iph;
d265 37
a301 6
	iph = n->in_inip & n->in_inmsk;
	hv = NAT_HASH_FN(iph, ipf_natrules_sz);
	for (n1 = &nat_rules[hv]; *n1 && (*n1 != n); n1 = &(*n1)->in_mnext)
		;
	if (*n1)
		*n1 = n->in_mnext;
d305 1
a305 1
void fix_outcksum(sp, n , len)
a307 1
int len;
d330 1
a330 1
void fix_incksum(sp, n , len)
a332 1
int len;
d345 3
d349 1
d360 32
d416 1
a416 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d425 1
a425 1
	int error = 0, ret, k;
a427 3
#if defined(_KERNEL) && !SOLARIS
	int s;
#endif
d437 9
a445 1
		IRCOPY(data, (char *)&natd, sizeof(natd));
a449 1
	SPL_NET(s);
d455 3
a457 2
			nat->in_inip &= nat->in_inmsk;
			if ((nat->in_flags & IPN_RANGE) == 0)
d498 1
a498 1
		n->in_ifp = (void *)GETUNIT(n->in_ifname);
d512 2
a513 12
			u_int hv;

			k = countbits(n->in_outmsk);
			if ((k >= 0) && (k != 32))
				rdr_masks |= 1 << k;
			j = (n->in_outip & n->in_outmsk);
			hv = NAT_HASH_FN(j, ipf_rdrrules_sz);
			np = rdr_rules + hv;
			while (*np != NULL)
				np = &(*np)->in_rnext;
			n->in_rnext = NULL;
			*np = n;
d516 2
a517 12
			u_int hv;

			k = countbits(n->in_inmsk);
			if ((k >= 0) && (k != 32))
				nat_masks |= 1 << k;
			j = (n->in_inip & n->in_inmsk);
			hv = NAT_HASH_FN(j, ipf_natrules_sz);
			np = nat_rules + hv;
			while (*np != NULL)
				np = &(*np)->in_mnext;
			n->in_mnext = NULL;
			*np = n;
d525 1
a525 1
		else if (n->in_flags & IPN_RANGE)
d527 2
d541 1
a541 1
			if ((n->in_flags & IPN_RANGE) != 0)
d548 1
a548 1
		    ((n->in_flags & IPN_RANGE) == 0))
d550 3
d634 2
a635 1
		IWCOPY((char *)&nat_stats, (char *)data, sizeof(nat_stats));
d642 3
a644 1
		IRCOPY((char *)data, (char *)&nl, sizeof(nl));
d647 2
a648 1
			IWCOPY((char *)&nl, (char *)data, sizeof(nl));
d653 1
a653 1
	case SIOCFLNAT :
d658 7
a664 1
		ret = nat_flushtable();
d666 5
a670 1
		IWCOPY((caddr_t)&ret, data, sizeof(ret));
d672 27
a698 8
	case SIOCCNATL :
		if (!(mode & FWRITE)) {
			error = EPERM;
			break;
		}
		ret = nat_clearlist();
		MUTEX_DOWNGRADE(&ipf_nat);
		IWCOPY((caddr_t)&ret, data, sizeof(ret));
d702 1
d704 3
a706 2
		IWCOPY((caddr_t)&iplused[IPL_LOGNAT], (caddr_t)data,
		       sizeof(iplused[IPL_LOGNAT]));
d714 1
a714 1
	SPL_X(s);
d721 277
a1003 1
	register struct nat **natp, *nat;
d1006 8
a1013 13
	for (natp = natd->nat_hstart[0]; (nat = *natp);
	     natp = &nat->nat_hnext[0])
		if (nat == natd) {
			*natp = nat->nat_hnext[0];
			break;
		}

	for (natp = natd->nat_hstart[1]; (nat = *natp);
	     natp = &nat->nat_hnext[1])
		if (nat == natd) {
			*natp = nat->nat_hnext[1];
			break;
		}
d1016 1
a1016 1
		ATOMIC_DEC(natd->nat_fr->fr_ref);
d1018 4
d1039 1
a1049 20
void
nat_ifdetach(ifp)
	struct ifnet *ifp;
{
	ipnat_t *n, **np = &nat_list;

	while ((n = *np)) {
		*np = n->in_next;
		if (!n->in_use) {
			if (n->in_apr)
				appr_free(n->in_apr);
			KFREE(n);
			nat_stats.ns_rules--;
		} else {
			n->in_flags |= IPN_DELETE;
			n->in_next = NULL;
		}
	}
}

d1058 1
a1058 1
  
d1072 3
d1086 1
a1086 1
static int nat_clearlist()
a1127 1
	nat_t *nat, **natp, *natl = NULL;
d1130 2
a1132 1
	u_int hv;
d1146 2
a1147 1
	if (nat == NULL)
d1149 1
d1153 2
d1175 1
a1175 1
			in.s_addr = np->in_nip;
d1181 6
a1186 14
				natl = nat_maplookup(fin->fin_ifp, flags,
						     ip->ip_src, ip->ip_dst);
				if (natl != NULL) {
					in = natl->nat_outip;
					if ((in.s_addr & np->in_outmsk) !=
					    np->in_outip)
						in.s_addr = 0;
					else
#ifndef sparc
						in.s_addr = ntohl(in.s_addr);
#else
						;
#endif
				}
d1188 3
d1194 2
a1195 4
				if (l > 0) {
					KFREE(nat);
					return NULL;
				}
d1200 2
a1201 4
				     !(flags & IPN_TCPUDP))) {
					KFREE(nat);
					return NULL;
				}
d1229 2
a1230 4
				    fr_ifpaddr(fin->fin_ifp, &in) == -1) {
					KFREE(nat);
					return NULL;
				}
d1236 2
a1237 4
				if (l > 0) {
					KFREE(nat);
					return NULL;
				}
d1241 1
a1241 1
				   ((l > 0) || (natl == NULL)))
d1250 1
a1250 2
						KFREE(nat);
						return NULL;
d1276 1
a1276 1
			if (np->in_flags & IPN_RANGE) {
d1300 1
a1300 1
			natl = nat_inlookup(fin->fin_ifp, flags & ~FI_WILD,
d1302 1
a1302 1
					    (port << 16) | dport);
d1310 2
a1311 4
			    (np->in_nip != 0) && (st_ip == np->in_nip)) {
				KFREE(nat);
				return NULL;
			}
d1322 3
d1341 19
a1359 2
		in.s_addr = ntohl(np->in_inip);
		if (!(nport = np->in_pnext))
d1361 9
d1376 4
a1379 3
		if ((in.s_addr == 0) && (nport == dport)) {
			KFREE(nat);
			return NULL;
d1427 6
a1432 12
	nat->nat_next = nat_instances;
	nat_instances = nat;
	hv = NAT_HASH_FN(nat->nat_inip.s_addr, ipf_nattable_sz);
	natp = &nat_table[0][hv];
	nat->nat_hstart[0] = natp;
	nat->nat_hnext[0] = *natp;
	*natp = nat;
	hv = NAT_HASH_FN(nat->nat_outip.s_addr, ipf_nattable_sz);
	natp = &nat_table[1][hv];
	nat->nat_hstart[1] = natp;
	nat->nat_hnext[1] = *natp;
	*natp = nat;
a1438 1
	nat->nat_age = fr_defnatage;
d1441 1
a1441 1
		ATOMIC_INC(nat->nat_fr->fr_ref);
d1450 49
a1500 2
	np->in_use++;
	return nat;
d1504 1
a1504 1
nat_t *nat_icmpinlookup(ip, fin)
d1507 1
d1509 1
a1510 1
	icmphdr_t *icmp;
a1513 2
	if ((fin->fin_fi.fi_fl & FI_SHORT) || (ip->ip_off & IP_OFFMASK))
		return NULL;
d1533 3
a1535 1
	if (ip->ip_len < ICMPERR_MINPKTLEN + minlen)
d1569 1
a1569 1
		if (ip->ip_len < ICMPERR_MINPKTLEN + minlen)
d1572 15
a1586 6
		return nat_inlookup(fin->fin_ifp, flags, (u_int)oip->ip_p,
				    oip->ip_dst, oip->ip_src,
				    (tcp->th_sport << 16) | tcp->th_dport);
	}
	return nat_inlookup(fin->fin_ifp, 0, (u_int)oip->ip_p, oip->ip_dst,
			    oip->ip_src, 0);
d1594 1
a1594 1
nat_t *nat_icmpin(ip, fin, nflags)
d1598 1
d1600 1
a1600 1
	u_32_t sum1, sum2, sumd;
d1603 1
d1608 6
a1613 1
	if (!(nat = nat_icmpinlookup(ip, fin)))
d1622 1
d1626 1
a1626 1
	 * IP address change is it will be modified again in ip_natout
d1632 18
a1649 1
	if (nat->nat_dir == NAT_OUTBOUND) {
d1664 18
a1681 1
		fix_incksum(&oip->ip_sum, sumd, 0);
d1683 32
a1714 4
		sumd += (sumd & 0xffff);
		while (sumd > 0xffff)
			sumd = (sumd & 0xffff) + (sumd >> 16);
		fix_outcksum(&icmp->icmp_cksum, sumd, 0);
a1715 1
		fix_outcksum(&oip->ip_sum, sumd, 0);
d1717 59
a1775 4
		sumd += (sumd & 0xffff);
		while (sumd > 0xffff)
			sumd = (sumd & 0xffff) + (sumd >> 16);
		fix_incksum(&icmp->icmp_cksum, sumd, 0);
a1777 1

d1785 1
a1785 1
		tcp = (tcphdr_t *)((((char *)oip) + (oip->ip_hl << 2)));
d1787 20
a1806 1
		if (nat->nat_dir == NAT_OUTBOUND) {
d1808 4
d1815 1
d1817 24
a1840 1
				fix_outcksum(&icmp->icmp_cksum, sumd, 0);
d1844 4
d1851 1
d1853 32
a1884 1
				fix_incksum(&icmp->icmp_cksum, sumd, 0);
d1903 1
a1903 1
nat_t *nat_inlookup(ifp, flags, p, src, mapdst, ports)
d1908 1
d1910 1
a1910 1
	register u_short sport, mapdport;
d1913 1
d1916 2
a1917 1
	mapdport = ports >> 16;
d1921 1
a1921 1
	hv = NAT_HASH_FN(mapdst.s_addr, ipf_nattable_sz);
d1927 1
a1927 1
		    nat->nat_outip.s_addr == mapdst.s_addr &&
d1931 1
a1931 2
		      ((nat->nat_outport == mapdport) ||
		       (nflags & FI_W_SPORT)))))
d1934 84
a2017 1
	return NULL;
d2027 1
a2027 1
nat_t *nat_outlookup(ifp, flags, p, src, dst, ports)
d2032 1
d2037 1
d2043 1
d2045 1
a2045 1
	hv = NAT_HASH_FN(src.s_addr, ipf_nattable_sz);
d2051 1
a2051 1
		    nat->nat_inip.s_addr == src.s_addr &&
d2059 9
a2067 18
	return NULL;
}


/*
 * check if an ip address has already been allocated for a given mapping that
 * is not doing port based translation.
 */
nat_t *nat_maplookup(ifp, flags, src, dst)
void *ifp;
register u_int flags;
struct in_addr src , dst;
{
	register nat_t *nat;
	register int oflags;
	u_int hv;

	hv = NAT_HASH_FN(src.s_addr, ipf_nattable_sz);
d2070 6
a2075 2
		oflags = (flags & IPN_TCPUDP) & nat->nat_ptr->in_flags;
		if (oflags != 0)
d2077 11
a2087 5

		if ((!ifp || ifp == nat->nat_ifp) &&
		    nat->nat_inip.s_addr == src.s_addr &&
		    nat->nat_oip.s_addr == dst.s_addr)
			return nat;
d2089 1
a2089 1
	return NULL;
d2108 1
a2108 1
				 np->nl_outip, ports))) {
d2116 44
d2171 1
a2171 1
	u_short nflags = 0, sport = 0, dport = 0, *csump = NULL;
d2175 1
a2175 1
	u_int hv, msk;
d2180 1
a2180 1
	if (nat_list == NULL)
d2204 5
a2208 1
	if ((ip->ip_off & (IP_OFFMASK|IP_MF)) &&
d2211 3
a2213 2
	else if ((nat = nat_outlookup(ifp, nflags, (u_int)ip->ip_p, ip->ip_src,
				      ip->ip_dst, (dport << 16) | sport))) {
d2226 1
d2239 1
a2239 1
		hv = NAT_HASH_FN(iph, ipf_natrules_sz);
d2242 12
a2253 6
			if ((np->in_ifp == ifp) && np->in_space &&
			    (!(np->in_flags & IPN_RF) ||
			     (np->in_flags & nflags)) &&
			    ((ipa & np->in_inmsk) == np->in_inip) &&
			    ((np->in_redir & (NAT_MAP|NAT_MAPBLK)) ||
			     (np->in_pnext == sport))) {
a2266 3
#ifdef	IPFILTER_LOG
					nat_log(nat, (u_int)np->in_redir);
#endif
d2282 3
d2289 1
a2289 2
		ip->ip_src = nat->nat_outip;
		MUTEX_ENTER(&ipf_rw);
d2293 1
a2293 1
		MUTEX_EXIT(&ipf_rw);
d2299 12
d2312 6
a2317 4
		if (nat->nat_dir == NAT_OUTBOUND)
			fix_outcksum(&ip->ip_sum, nat->nat_ipsumd, 0);
		else
			fix_incksum(&ip->ip_sum, nat->nat_ipsumd, 0);
d2319 1
d2331 1
a2331 1
				MUTEX_ENTER(&ipf_rw);
d2333 1
a2333 1
					   nat->nat_tcpstate, ip, fin, 1);
d2337 2
a2338 2
				else if (nat->nat_age > DEF_NAT_AGE)
					nat->nat_age = DEF_NAT_AGE;
d2348 1
a2348 1
				MUTEX_EXIT(&ipf_rw);
d2360 1
a2360 2
					fix_outcksum(csump, nat->nat_sumd[1],
						     ip->ip_len);
d2362 1
a2362 2
					fix_incksum(csump, nat->nat_sumd[1],
						     ip->ip_len);
d2365 1
d2367 7
a2373 3
		     (tcp != NULL && dport == np->in_dport)))
			(void) appr_check(ip, fin, nat);
		ATOMIC_INC(nat_stats.ns_mapped[1]);
d2375 1
a2375 1
		return 1;
d2401 1
a2401 1
	if (nat_list == NULL)
d2422 2
a2423 1
	if ((ip->ip_p == IPPROTO_ICMP) && (nat = nat_icmpin(ip, fin, &nflags)))
d2425 1
a2425 1
	else if ((ip->ip_off & IP_OFFMASK) &&
d2429 2
a2430 1
				     ip->ip_src, in, (dport << 16) | sport))) {
d2440 1
d2453 15
a2467 9
		hv = NAT_HASH_FN(iph, ipf_rdrrules_sz);
		for (np = rdr_rules[hv]; np; np = np->in_rnext)
			if ((np->in_ifp == ifp) &&
			    (!np->in_flags || (nflags & np->in_flags)) &&
			    ((in.s_addr & np->in_outmsk) == np->in_outip) &&
			    ((src.s_addr & np->in_srcmsk) == np->in_srcip) &&
			    (np->in_redir & NAT_REDIRECT) &&
			    (!np->in_pmin || np->in_pmin == dport) &&
			    (!np->in_p || np->in_p == ip->ip_p)) {
a2470 3
#ifdef	IPFILTER_LOG
					nat_log(nat, (u_int)np->in_redir);
#endif
d2473 2
a2474 1
			}
d2485 4
d2495 7
a2501 2
		    (tcp != NULL && sport == np->in_dport)))
			(void) appr_check(ip, fin, nat);
d2503 1
a2503 1
		MUTEX_ENTER(&ipf_rw);
d2509 1
a2509 1
		MUTEX_EXIT(&ipf_rw);
d2511 1
a2511 1
		fin->fin_fi.fi_dst = nat->nat_inip;
d2519 1
a2519 1
			fix_incksum(&ip->ip_sum, nat->nat_ipsumd, 0);
d2521 1
a2521 1
			fix_outcksum(&ip->ip_sum, nat->nat_ipsumd, 0);
d2533 1
a2533 1
				MUTEX_ENTER(&ipf_rw);
d2535 1
a2535 1
					   nat->nat_tcpstate, ip, fin, 0);
d2539 2
a2540 2
				else if (nat->nat_age > DEF_NAT_AGE)
					nat->nat_age = DEF_NAT_AGE;
d2550 1
a2550 1
				MUTEX_EXIT(&ipf_rw);
d2559 1
d2562 1
a2562 1
					fix_incksum(csump, nat->nat_sumd[0], 0);
d2564 1
a2564 1
					fix_outcksum(csump, nat->nat_sumd[0], 0);
d2567 1
a2567 1
		ATOMIC_INC(nat_stats.ns_mapped[0]);
d2602 4
d2671 1
a2671 1
			if (fr_ifpaddr(ifp2, &in) != -1)
d2692 1
a2692 1
			n->in_ifp = (void *)GETUNIT(n->in_ifname);
@


1.34
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.33 2000/07/03 04:50:05 aaron Exp $	*/
d617 1
a617 1
	ipnat_t *n, **np;
d619 1
a619 1
	for (np = &nat_list; (n = *np) != NULL; np = &n->in_next) {
a629 1
		n = NULL;
@


1.33
log
@Make nat_ifdetach() actually work; beck@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.32 2000/05/24 21:59:11 kjell Exp $	*/
d14 1
a14 1
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.2.2.18 2000/05/19 15:52:29 darrenr Exp $";
d413 1
a413 1
		 *                               (so subtract 1)
d617 1
a617 1
	ipnat_t *n, **np = &nat_list;
d619 1
a619 1
	while ((n = *np)) {
d630 1
d1031 1
a1032 1
	tcphdr_t *tcp = NULL;
d1034 1
a1034 1
	int flags = 0, type;
d1036 2
d1056 19
a1074 1
	if (ip->ip_len < ICMPERR_MAXPKTLEN + ((oip->ip_hl - 5) << 2))
d1076 9
d1090 3
d1171 4
a1174 1
		/* XXX - what if this is bogus hl and we go off the end ? */
d1505 1
@


1.32
log
@Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
  RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.31 2000/05/10 20:40:53 deraadt Exp $	*/
d617 1
a617 1
	ipnat_t *n, **np;
d619 1
a619 1
	for (np = &nat_list; (n = *np) != NULL; np = &n->in_next) {
a629 1
		n = NULL;
@


1.31
log
@ipf 3.3.14, fixes an ipnat problem and ip option mishandling, which the bridge code cares about
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.30 2000/05/01 06:16:47 kjell Exp $	*/
d14 1
a14 1
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.2.2.15 2000/04/25 16:21:13 darrenr Exp $";
d329 3
d334 4
a337 2
		else
			*(int *)data = ipflog_clear(IPL_LOGNAT);
d339 1
d809 1
a809 1
			} else if (!np->in_nip &&
d820 1
a820 1
			} else if (!np->in_nip && !np->in_outmsk) {
@


1.31.2.1
log
@Pull in patch from current:
Errata:
A misuse of ipf(8) keep-state rules can result in firewall rules being bypassed.
Fix (kjell):
Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.32 2000/05/24 21:59:11 kjell Exp $	*/
d14 1
a14 1
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.2.2.18 2000/05/19 15:52:29 darrenr Exp $";
a328 3
	{
		int tmp;

d331 2
a332 4
		else {
			tmp = ipflog_clear(IPL_LOGNAT);
			IWCOPY((char *)&tmp, (char *)data, sizeof(tmp));
		}
a333 1
	}
d803 1
a803 1
			} else if (!np->in_outip &&
d814 1
a814 1
			} else if (!np->in_outip && !np->in_outmsk) {
@


1.30
log
@Update to ipfilter 3.3.13. This should be the last of the 3.3.x releases.
This patch fixes mostly ICMP timeout problems, as the ftp proxy
changes were imported previously.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.29 2000/04/05 05:35:27 kjell Exp $	*/
d803 1
a803 1
			} else if (!in.s_addr &&
d814 1
a814 1
			} else if (!in.s_addr && !np->in_outmsk) {
@


1.29
log
@Update to ipf 3.3.12. Most fixes relate to hardening of
in-kernel ftp proxy. See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.28 2000/03/13 23:40:18 kjell Exp $	*/
d14 1
a14 1
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.2.2.13 2000/03/08 14:17:26 darrenr Exp $";
d35 1
a35 1
#if defined(KERNEL) && (__FreeBSD_version >= 220000)
d1461 2
d1643 2
@


1.28
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d14 1
a14 1
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.2.2.12 2000/01/24 12:43:40 darrenr Exp $";
d862 1
a862 1
				if (np->in_nip >= ntohl(np->in_outmsk))
@


1.27
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@@


1.26
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.26.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.27 2000/02/16 22:34:19 kjell Exp $	*/
@


1.26.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.39 2001/02/06 17:29:30 fgsch Exp $	*/
d4 1
a4 1
 * Copyright (C) 1995-2000 by Darren Reed.
d14 1
a14 1
static const char rcsid[] = "@@(#)$IPFilter: ip_nat.c,v 2.37.2.32 2001/01/10 06:19:11 darrenr Exp $";
d35 1
a35 1
#if (defined(KERNEL) || defined(_KERNEL)) && (__FreeBSD_version >= 220000)
a121 1
u_int	ipf_hostmap_sz = HOSTMAP_SIZE;
a125 1
hostmap_t	**maptable  = NULL;
a129 1
int	fr_nat_lock = 0;
d136 1
a136 2
static	void	nat_addnat __P((struct ipnat *));
static	void	nat_addrdr __P((struct ipnat *));
a139 8
static	int	fr_natgetent __P((caddr_t));
static	int	fr_natgetsz __P((caddr_t));
static	int	fr_natputent __P((caddr_t));
static	void	nat_tabmove __P((nat_t *, u_32_t));
static	int	nat_match __P((fr_info_t *, ipnat_t *, ip_t *));
static	hostmap_t *nat_hostmap __P((ipnat_t *, struct in_addr,
				    struct in_addr));
static	void	nat_hostmapdel __P((struct hostmap *));
a166 6

	KMALLOCS(maptable, hostmap_t **, sizeof(hostmap_t *) * ipf_hostmap_sz);
	if (maptable != NULL)
		bzero((char *)maptable, sizeof(hostmap_t *) * ipf_hostmap_sz);
	else
		return -1;
d171 1
a171 1
static void nat_addrdr(n)
d174 2
a175 2
	ipnat_t **np;
	u_32_t j;
a176 1
	int k;
d178 6
a183 42
	k = countbits(n->in_outmsk);
	if ((k >= 0) && (k != 32))
		rdr_masks |= 1 << k;
	j = (n->in_outip & n->in_outmsk);
	hv = NAT_HASH_FN(j, 0, ipf_rdrrules_sz);
	np = rdr_rules + hv;
	while (*np != NULL)
		np = &(*np)->in_rnext;
	n->in_rnext = NULL;
	n->in_prnext = np;
	*np = n;
}


static void nat_addnat(n)
ipnat_t *n;
{
	ipnat_t **np;
	u_32_t j;
	u_int hv;
	int k;

	k = countbits(n->in_inmsk);
	if ((k >= 0) && (k != 32))
		nat_masks |= 1 << k;
	j = (n->in_inip & n->in_inmsk);
	hv = NAT_HASH_FN(j, 0, ipf_natrules_sz);
	np = nat_rules + hv;
	while (*np != NULL)
		np = &(*np)->in_mnext;
	n->in_mnext = NULL;
	n->in_pmnext = np;
	*np = n;
}


static void nat_delrdr(n)
ipnat_t *n;
{
	if (n->in_rnext)
		n->in_rnext->in_prnext = n->in_prnext;
	*n->in_prnext = n->in_rnext;
d190 2
a191 18
	if (n->in_mnext)
		n->in_mnext->in_pmnext = n->in_pmnext;
	*n->in_pmnext = n->in_mnext;
}


/*
 * check if an ip address has already been allocated for a given mapping that
 * is not doing port based translation.
 *
 * Must be called with ipf_nat held as a write lock.
 */
static struct hostmap *nat_hostmap(np, real, map)
ipnat_t *np;
struct in_addr real;
struct in_addr map;
{
	hostmap_t *hm;
d194 6
a199 21
	hv = real.s_addr % HOSTMAP_SIZE;
	for (hm = maptable[hv]; hm; hm = hm->hm_next)
		if ((hm->hm_realip.s_addr == real.s_addr) &&
		    (np == hm->hm_ipnat)) {
			hm->hm_ref++;
			return hm;
		}

	KMALLOC(hm, hostmap_t *);
	if (hm) {
		hm->hm_next = maptable[hv];
		hm->hm_pnext = maptable + hv;
		if (maptable[hv])
			maptable[hv]->hm_pnext = &hm->hm_next;
		maptable[hv] = hm;
		hm->hm_ipnat = np;
		hm->hm_realip = real;
		hm->hm_mapip = map;
		hm->hm_ref = 1;
	}
	return hm;
d203 1
a203 17
/*
 * Must be called with ipf_nat held as a write lock.
 */
static void nat_hostmapdel(hm)
struct hostmap *hm;
{
	ATOMIC_DEC32(hm->hm_ref);
	if (hm->hm_ref == 0) {
		if (hm->hm_next)
			hm->hm_next->hm_pnext = hm->hm_pnext;
		*hm->hm_pnext = hm->hm_next;
		KFREE(hm);
	}
}


void fix_outcksum(sp, n)
d206 1
d229 1
a229 1
void fix_incksum(sp, n)
d232 1
a255 32
 * fix_datacksum is used *only* for the adjustments of checksums in the data
 * section of an IP packet.
 *
 * The only situation in which you need to do this is when NAT'ing an 
 * ICMP error message. Such a message, contains in its body the IP header
 * of the original IP packet, that causes the error.
 *
 * You can't use fix_incksum or fix_outcksum in that case, because for the
 * kernel the data section of the ICMP error is just data, and no special 
 * processing like hardware cksum or ntohs processing have been done by the 
 * kernel on the data section.
 */
void fix_datacksum(sp, n)
u_short *sp;
u_32_t n;
{
	register u_short sumshort;
	register u_32_t sum1;

	if (!n)
		return;

	sum1 = (~ntohs(*sp)) & 0xffff;
	sum1 += (n);
	sum1 = (sum1 >> 16) + (sum1 & 0xffff);
	/* Again */
	sum1 = (sum1 >> 16) + (sum1 & 0xffff);
	sumshort = ~(u_short)sum1;
	*(sp) = htons(sumshort);
}

/*
d280 1
a280 1
#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD_version >= 300003)
d289 1
a289 1
	int error = 0, ret, arg;
d292 3
d304 1
a304 9
		error = IRCOPYPTR(data, (char *)&natd, sizeof(natd));
	else if (cmd == SIOCIPFFL) {	/* SIOCFLNAT & SIOCCNATL */
		error = IRCOPY(data, (char *)&arg, sizeof(arg));
		if (error)
			error = EFAULT;
	}

	if (error)
		goto done;
d309 1
d315 2
a316 3
			if ((nat->in_flags & IPN_SPLIT) == 0)
				nat->in_inip &= nat->in_inmsk;
			if ((nat->in_flags & IPN_IPRANGE) == 0)
a328 3
	{
		int tmp;

d331 2
a332 4
		else {
			tmp = ipflog_clear(IPL_LOGNAT);
			IWCOPY((char *)&tmp, (char *)data, sizeof(tmp));
		}
a333 1
	}
d351 1
a351 1
		n->in_ifp = (void *)GETUNIT(n->in_ifname, 4);
d365 12
a376 2
			n->in_flags &= ~IPN_NOTDST;
			nat_addrdr(n);
d379 12
a390 2
			n->in_flags &= ~IPN_NOTSRC;
			nat_addnat(n);
d398 1
a398 1
		else if (n->in_flags & IPN_IPRANGE)
a399 2
		else if (n->in_flags & IPN_SPLIT)
			n->in_space = 2;
d407 1
a407 1
		 *			         (so subtract 1)
d412 1
a412 1
			if ((n->in_flags & IPN_IPRANGE) != 0)
d419 1
a419 1
		    ((n->in_flags & (IPN_IPRANGE|IPN_SPLIT)) == 0))
a420 3
		else if ((n->in_flags & IPN_SPLIT) &&
			 (n->in_redir & NAT_REDIRECT))
			n->in_nip = ntohl(n->in_inip);
d502 1
a502 2
		error = IWCOPYPTR((char *)&nat_stats, (char *)data,
				  sizeof(nat_stats));
d509 1
a509 3
		error = IRCOPYPTR((char *)data, (char *)&nl, sizeof(nl));
		if (error)
			break;
d512 1
a512 2
			error = IWCOPYPTR((char *)&nl, (char *)data,
					  sizeof(nl));
d517 1
a517 1
	case SIOCIPFFL :	/* old SIOCFLNAT & SIOCCNATL */
d522 1
a522 7
		error = 0;
		if (arg == 0)
			ret = nat_flushtable();
		else if (arg == 1)
			ret = nat_clearlist();
		else
			error = EINVAL;
d524 6
a529 4
		if (!error) {
			error = IWCOPY((caddr_t)&ret, data, sizeof(ret));
			if (error)
				error = EFAULT;
d531 3
a533 28
		break;
	case SIOCSTLCK :
		error = IRCOPY(data, (caddr_t)&arg, sizeof(arg));
		if (!error) {
			error = IWCOPY((caddr_t)&fr_nat_lock, data,
					sizeof(fr_nat_lock));
			if (!error)
				fr_nat_lock = arg;
		} else
			error = EFAULT;
		break;
	case SIOCSTPUT :
		if (fr_nat_lock)
			error = fr_natputent(data);
		else
			error = EACCES;
		break;
	case SIOCSTGSZ :
		if (fr_nat_lock)
			error = fr_natgetsz(data);
		else
			error = EACCES;
		break;
	case SIOCSTGET :
		if (fr_nat_lock)
			error = fr_natgetent(data);
		else
			error = EACCES;
a536 1
		arg = (int)iplused[IPL_LOGNAT];
d538 2
a539 3
		error = IWCOPY((caddr_t)&arg, (caddr_t)data, sizeof(arg));
		if (error)
			error = EFAULT;
d547 1
a547 1
done:
a553 277
static int fr_natgetsz(data)
caddr_t data;
{
	ap_session_t *aps;
	nat_t *nat, *n;
	int error = 0;
	natget_t ng;

	error = IRCOPY(data, (caddr_t)&ng, sizeof(ng));
	if (error)
		return EFAULT;

	nat = ng.ng_ptr;
	if (!nat) {
		nat = nat_instances;
		ng.ng_sz = 0;
		if (nat == NULL) {
			error = IWCOPY((caddr_t)&ng, data, sizeof(ng));
			if (error)
				error = EFAULT;
			return error;
		}
	} else {
		/*
		 * Make sure the pointer we're copying from exists in the
		 * current list of entries.  Security precaution to prevent
		 * copying of random kernel data.
		 */
		for (n = nat_instances; n; n = n->nat_next)
			if (n == nat)
				break;
		if (!n)
			return ESRCH;
	}

	ng.ng_sz = sizeof(nat_save_t);
	aps = nat->nat_aps;
	if ((aps != NULL) && (aps->aps_data != 0)) {
		ng.ng_sz += sizeof(ap_session_t);
		ng.ng_sz += aps->aps_psiz;
	}

	error = IWCOPY((caddr_t)&ng, data, sizeof(ng));
	if (error)
		error = EFAULT;
	return error;
}


static int fr_natgetent(data)
caddr_t data;
{
	nat_save_t ipn, *ipnp, *ipnn = NULL;
	register nat_t *n, *nat;
	ap_session_t *aps;
	int error;

	error = IRCOPY(data, (caddr_t)&ipnp, sizeof(ipnp));
	if (error)
		return EFAULT;
	error = IRCOPY((caddr_t)ipnp, (caddr_t)&ipn, sizeof(ipn));
	if (error)
		return EFAULT;

	nat = ipn.ipn_next;
	if (!nat) {
		nat = nat_instances;
		if (nat == NULL) {
			if (nat_instances == NULL)
				return ENOENT;
			return 0;
		}
	} else {
		/*
		 * Make sure the pointer we're copying from exists in the
		 * current list of entries.  Security precaution to prevent
		 * copying of random kernel data.
		 */
		for (n = nat_instances; n; n = n->nat_next)
			if (n == nat)
				break;
		if (!n)
			return ESRCH;
	}

	ipn.ipn_next = nat->nat_next;
	ipn.ipn_dsize = 0;
	bcopy((char *)nat, (char *)&ipn.ipn_nat, sizeof(ipn.ipn_nat));
	ipn.ipn_nat.nat_data = NULL;

	if (nat->nat_ptr) {
		bcopy((char *)nat->nat_ptr, (char *)&ipn.ipn_ipnat,
		      sizeof(ipn.ipn_ipnat));
	}

	if (nat->nat_fr)
		bcopy((char *)nat->nat_fr, (char *)&ipn.ipn_rule,
		      sizeof(ipn.ipn_rule));

	if ((aps = nat->nat_aps)) {
		ipn.ipn_dsize = sizeof(*aps);
		if (aps->aps_data)
			ipn.ipn_dsize += aps->aps_psiz;
		KMALLOCS(ipnn, nat_save_t *, sizeof(*ipnn) + ipn.ipn_dsize);
		if (ipnn == NULL)
			return ENOMEM;
		bcopy((char *)&ipn, (char *)ipnn, sizeof(ipn));

		bcopy((char *)aps, ipnn->ipn_data, sizeof(*aps));
		if (aps->aps_data) {
			bcopy(aps->aps_data, ipnn->ipn_data + sizeof(*aps),
			      aps->aps_psiz);
			ipnn->ipn_dsize += aps->aps_psiz;
		}
		error = IWCOPY((caddr_t)ipnn, ipnp,
			       sizeof(ipn) + ipn.ipn_dsize);
		if (error)
			error = EFAULT;
		KFREES(ipnn, sizeof(*ipnn) + ipn.ipn_dsize);
	} else {
		error = IWCOPY((caddr_t)&ipn, ipnp, sizeof(ipn));
		if (error)
			error = EFAULT;
	}
	return error;
}


static int fr_natputent(data)
caddr_t data;
{
	nat_save_t ipn, *ipnp, *ipnn = NULL;
	register nat_t *n, *nat;
	ap_session_t *aps;
	frentry_t *fr;
	ipnat_t *in;

	int error;

	error = IRCOPY(data, (caddr_t)&ipnp, sizeof(ipnp));
	if (error)
		return EFAULT;
	error = IRCOPY((caddr_t)ipnp, (caddr_t)&ipn, sizeof(ipn));
	if (error)
		return EFAULT;
	nat = NULL;
	if (ipn.ipn_dsize) {
		KMALLOCS(ipnn, nat_save_t *, sizeof(ipn) + ipn.ipn_dsize);
		if (ipnn == NULL)
			return ENOMEM;
		bcopy((char *)&ipn, (char *)ipnn, sizeof(ipn));
		error = IRCOPY((caddr_t)ipnp, (caddr_t)ipn.ipn_data,
			       ipn.ipn_dsize);
		if (error) {
			error = EFAULT;
			goto junkput;
		}
	} else
		ipnn = NULL;

	KMALLOC(nat, nat_t *);
	if (nat == NULL) {
		error = EFAULT;
		goto junkput;
	}

	bcopy((char *)&ipn.ipn_nat, (char *)nat, sizeof(*nat));
	/*
	 * Initialize all these so that nat_delete() doesn't cause a crash.
	 */
	nat->nat_phnext[0] = NULL;
	nat->nat_phnext[1] = NULL;
	fr = nat->nat_fr;
	nat->nat_fr = NULL;
	aps = nat->nat_aps;
	nat->nat_aps = NULL;
	in = nat->nat_ptr;
	nat->nat_ptr = NULL;
	nat->nat_data = NULL;

	/*
	 * Restore the rule associated with this nat session
	 */
	if (in) {
		KMALLOC(in, ipnat_t *);
		if (in == NULL) {
			error = ENOMEM;
			goto junkput;
		}
		nat->nat_ptr = in;
		bcopy((char *)&ipn.ipn_ipnat, (char *)in, sizeof(*in));
		in->in_use = 1;
		in->in_flags |= IPN_DELETE;
		in->in_next = NULL;
		in->in_rnext = NULL;
		in->in_prnext = NULL;
		in->in_mnext = NULL;
		in->in_pmnext = NULL;
		in->in_ifp = GETUNIT(in->in_ifname, 4);
		if (in->in_plabel[0] != '\0') {
			in->in_apr = appr_match(in->in_p, in->in_plabel);
		}
	}

	/*
	 * Restore ap_session_t structure.  Include the private data allocated
	 * if it was there.
	 */
	if (aps) {
		KMALLOC(aps, ap_session_t *);
		if (aps == NULL) {
			error = ENOMEM;
			goto junkput;
		}
		nat->nat_aps = aps;
		aps->aps_next = ap_sess_list;
		ap_sess_list = aps;
		bcopy(ipnn->ipn_data, (char *)aps, sizeof(*aps));
		if (in)
			aps->aps_apr = in->in_apr;
		if (aps->aps_psiz) {
			KMALLOCS(aps->aps_data, void *, aps->aps_psiz);
			if (aps->aps_data == NULL) {
				error = ENOMEM;
				goto junkput;
			}
			bcopy(ipnn->ipn_data + sizeof(*aps), aps->aps_data,
			      aps->aps_psiz);
		} else {
			aps->aps_psiz = 0;
			aps->aps_data = NULL;
		}
	}

	/*
	 * If there was a filtering rule associated with this entry then
	 * build up a new one.
	 */
	if (fr != NULL) {
		if (nat->nat_flags & FI_NEWFR) {
			KMALLOC(fr, frentry_t *);
			nat->nat_fr = fr;
			if (fr == NULL) {
				error = ENOMEM;
				goto junkput;
			}
			bcopy((char *)&ipn.ipn_fr, (char *)fr, sizeof(*fr));
			ipn.ipn_nat.nat_fr = fr;
			error = IWCOPY((caddr_t)&ipn, ipnp, sizeof(ipn));
			if (error) {
				error = EFAULT;
				goto junkput;
			}
		} else {
			for (n = nat_instances; n; n = n->nat_next)
				if (n->nat_fr == fr)
					break;
			if (!n) {
				error = ESRCH;
				goto junkput;
			}
		}
	}

	if (ipnn)
		KFREES(ipnn, sizeof(ipn) + ipn.ipn_dsize);
	nat_insert(nat);
	return 0;
junkput:
	if (ipnn)
		KFREES(ipnn, sizeof(ipn) + ipn.ipn_dsize);
	if (nat)
		nat_delete(nat);
	return error;
}


d560 1
d563 13
a575 8
	if (natd->nat_flags & FI_WILDP)
		nat_stats.ns_wilds--;
	if (natd->nat_hnext[0])
		natd->nat_hnext[0]->nat_phnext[0] = natd->nat_phnext[0];
	*natd->nat_phnext[0] = natd->nat_hnext[0];
	if (natd->nat_hnext[1])
		natd->nat_hnext[1]->nat_phnext[1] = natd->nat_phnext[1];
	*natd->nat_phnext[1] = natd->nat_hnext[1];
d578 1
a578 1
		ATOMIC_DEC32(natd->nat_fr->fr_ref);
a579 4

	if (natd->nat_hm != NULL)
		nat_hostmapdel(natd->nat_hm);

a596 1
	MUTEX_DESTROY(&natd->nat_lock);
d607 21
d636 1
a636 1

a649 3
#ifdef	IPFILTER_LOG
		nat_log(nat, NL_FLUSH);
#endif
d661 1
a661 1
int nat_clearlist()
d703 1
a705 2
	hostmap_t *hm = NULL;
	nat_t *nat, *natl;
d707 1
d721 1
a721 2
	if (nat == NULL) {
		nat_stats.ns_memfail++;
a722 1
	}
a725 2
	if (flags & FI_WILDP)
		nat_stats.ns_wilds++;
d746 1
a746 1
			in.s_addr = htonl(np->in_nip);
d752 14
a765 6
				hm = nat_hostmap(np, ip->ip_src, in);
				if (hm != NULL)
					in.s_addr = hm->hm_mapip.s_addr;
			} else if ((l == 1) && (hm != NULL)) {
				nat_hostmapdel(hm);
				hm = NULL;
a766 3
			in.s_addr = ntohl(in.s_addr);

			nat->nat_hm = hm;
d770 4
a773 2
				if (l > 0)
					goto badnat;
d778 4
a781 2
				     !(flags & IPN_TCPUDP)))
					goto badnat;
d803 1
a803 1
			} else if (!np->in_outip &&
d809 4
a812 2
				    fr_ifpaddr(4, fin->fin_ifp, &in) == -1)
					goto badnat;
d814 1
a814 1
			} else if (!np->in_outip && !np->in_outmsk) {
d818 4
a821 2
				if (l > 0)
					goto badnat;
d825 1
a825 1
				   ((l > 0) || (hm == NULL)))
d834 2
a835 1
						goto badnat;
d861 2
a862 2
			if (np->in_flags & IPN_IPRANGE) {
				if (np->in_nip > ntohl(np->in_outmsk))
d885 1
a885 1
			natl = nat_inlookup(fin->fin_ifp, flags & ~FI_WILDP,
d887 1
a887 1
					    (port << 16) | dport, 1);
d895 4
a898 2
			    (np->in_nip != 0) && (st_ip == np->in_nip))
				goto badnat;
a908 3
		if (nat->nat_hm == NULL)
			nat->nat_hm = nat_hostmap(np, ip->ip_src,
						  nat->nat_outip);
d925 2
a926 19
		if (np->in_flags & IPN_SPLIT) {
			in.s_addr = np->in_nip;
			if (np->in_inip == htonl(in.s_addr))
				np->in_nip = ntohl(np->in_inmsk);
			else {
				np->in_nip = ntohl(np->in_inip);
				if (np->in_flags & IPN_ROUNDR) {
					nat_delrdr(np);
					nat_addrdr(np);
				}
			}
		} else {
			in.s_addr = ntohl(np->in_inip);
			if (np->in_flags & IPN_ROUNDR) {
				nat_delrdr(np);
				nat_addrdr(np);
			}
		}
		if (!np->in_pnext)
a927 9
		else {
			/*
			 * Whilst not optimized for the case where
			 * pmin == pmax, the gain is not significant.
			 */
			nport = ntohs(dport) - ntohs(np->in_pmin) +
				ntohs(np->in_pnext);
			nport = htons(nport);
		}
d934 3
a936 4
		if (in.s_addr == 0) {
			if (nport == dport)
				goto badnat;
			in.s_addr = ntohl(ip->ip_dst.s_addr);
d984 12
a995 6

#ifdef  _KERNEL
	strncpy(nat->nat_ifname, IFNAME(fin->fin_ifp), IFNAMSIZ);
#endif
	nat_insert(nat);

d1002 1
d1005 1
a1005 1
		ATOMIC_INC32(nat->nat_fr->fr_ref);
d1014 2
a1016 3
#ifdef	IPFILTER_LOG
	nat_log(nat, (u_int)np->in_redir);
#endif
a1017 46
badnat:
	nat_stats.ns_badnat++;
	if ((hm = nat->nat_hm) != NULL)
		nat_hostmapdel(hm);
	KFREE(nat);
	return NULL;
}


void	nat_insert(nat)
nat_t	*nat;
{
	nat_t **natp;
	u_int hv;

	MUTEX_INIT(&nat->nat_lock, "nat entry lock", NULL);

	nat->nat_age = fr_defnatage;
	nat->nat_ifname[sizeof(nat->nat_ifname) - 1] = '\0';
	if (nat->nat_ifname[0] !='\0') {
		nat->nat_ifp = GETUNIT(nat->nat_ifname, 4);
	}

	nat->nat_next = nat_instances;
	nat_instances = nat;

	hv = NAT_HASH_FN(nat->nat_inip.s_addr, nat->nat_inport,
			 ipf_nattable_sz);
	natp = &nat_table[0][hv];
	if (*natp)
		(*natp)->nat_phnext[0] = &nat->nat_hnext[0];
	nat->nat_phnext[0] = natp;
	nat->nat_hnext[0] = *natp;
	*natp = nat;

	hv = NAT_HASH_FN(nat->nat_outip.s_addr, nat->nat_outport,
			 ipf_nattable_sz);
	natp = &nat_table[1][hv];
	if (*natp)
		(*natp)->nat_phnext[1] = &nat->nat_hnext[1];
	nat->nat_phnext[1] = natp;
	nat->nat_hnext[1] = *natp;
	*natp = nat;

	nat_stats.ns_added++;
	nat_stats.ns_inuse++;
d1021 1
a1021 1
nat_t *nat_icmplookup(ip, fin, dir)
a1023 1
int dir;
d1028 1
a1028 1
	int flags = 0, type, minlen;
d1048 1
a1048 2
	minlen = (oip->ip_hl << 2);
	if (minlen < sizeof(ip_t))
a1049 28
	if (ip->ip_len < ICMPERR_IPICMPHLEN + minlen)
		return NULL;
	/*
	 * Is the buffer big enough for all of it ?  It's the size of the IP
	 * header claimed in the encapsulated part which is of concern.  It
	 * may be too big to be in this buffer but not so big that it's
	 * outside the ICMP packet, leading to TCP deref's causing problems.
	 * This is possible because we don't know how big oip_hl is when we
	 * do the pullup early in fr_check() and thus can't gaurantee it is
	 * all here now.
	 */
#ifdef  _KERNEL
	{
	mb_t *m;

# if SOLARIS
	m = fin->fin_qfm;
	if ((char *)oip + fin->fin_dlen - ICMPERR_ICMPHLEN > (char *)m->b_wptr)
		return NULL;
# else
	m = *(mb_t **)fin->fin_mp;
	if ((char *)oip + fin->fin_dlen - ICMPERR_ICMPHLEN >
	    (char *)ip + m->m_len)
		return NULL;
# endif
	}
#endif

a1054 3
		minlen += 8;		/* + 64bits of data to get ports */
		if (ip->ip_len < ICMPERR_IPICMPHLEN + minlen)
			return NULL;
d1056 6
a1061 15
		if (dir == NAT_INBOUND)
			return nat_inlookup(fin->fin_ifp, flags,
				(u_int)oip->ip_p, oip->ip_dst, oip->ip_src,
				(tcp->th_sport << 16) | tcp->th_dport, 0);
		else
			return nat_outlookup(fin->fin_ifp, flags,
				(u_int)oip->ip_p, oip->ip_dst, oip->ip_src,
				(tcp->th_sport << 16) | tcp->th_dport, 0);
	}
	if (dir == NAT_INBOUND)
		return nat_inlookup(fin->fin_ifp, 0, (u_int)oip->ip_p,
			oip->ip_dst, oip->ip_src, 0, 0);
	else
		return nat_outlookup(fin->fin_ifp, 0, (u_int)oip->ip_p,
			oip->ip_dst, oip->ip_src, 0, 0);
d1069 1
a1069 1
nat_t *nat_icmp(ip, fin, nflags, dir)
a1072 1
int dir;
d1074 1
a1074 1
	u_32_t sum1, sum2, sumd, sumd2 = 0;
a1076 1
	udphdr_t *udp;
d1081 1
a1081 6
	if ((fin->fin_fi.fi_fl & FI_SHORT) || (ip->ip_off & IP_OFFMASK))
		return NULL;
	/*
	 * nat_icmplookup() will return NULL for `defective' packets.
	 */
	if ((ip->ip_v != 4) || !(nat = nat_icmplookup(ip, fin, dir)))
a1089 1
	udp = (udphdr_t *)((((char *)oip) + (oip->ip_hl << 2)));
d1093 1
a1093 1
	 * IP address change as it will be modified again in ip_natout
d1099 1
a1099 18

	/*
	 * Step 1
	 * Fix the IP addresses in the offending IP packet. You also need
	 * to adjust the IP header checksum of that offending IP packet
	 * and the ICMP checksum of the ICMP error message itself.
	 *
	 * Unfortunately, for UDP and TCP, the IP addresses are also contained
	 * in the pseudo header that is used to compute the UDP resp. TCP
	 * checksum. So, we must compensate that as well. Even worse, the
	 * change in the UDP and TCP checksums require yet another
	 * adjustment of the ICMP checksum of the ICMP error message.
	 *
	 * For the moment we forget about TCP, because that checksum is not
	 * in the first 8 bytes, so it will not be available in most cases.
	 */

	if (oip->ip_dst.s_addr == nat->nat_oip.s_addr) {
d1114 1
a1114 18
		/*
		 * Fix IP checksum of the offending IP packet to adjust for
		 * the change in the IP address.
		 *
		 * Normally, you would expect that the ICMP checksum of the 
		 * ICMP error message needs to be adjusted as well for the
		 * IP address change in oip.
		 * However, this is a NOP, because the ICMP checksum is 
		 * calculated over the complete ICMP packet, which includes the
		 * changed oip IP addresses and oip->ip_sum. However, these 
		 * two changes cancel each other out (if the delta for
		 * the IP address is x, then the delta for ip_sum is minus x), 
		 * so no change in the icmp_cksum is necessary.
		 *
		 * Be careful that nat_dir refers to the direction of the
		 * offending IP packet (oip), not to its ICMP response (icmp)
		 */
		fix_datacksum(&oip->ip_sum, sumd);
d1116 4
a1119 32
		/*
		 * Fix UDP pseudo header checksum to compensate for the
		 * IP address change.
		 */
		if (oip->ip_p == IPPROTO_UDP && udp->uh_sum) {
			/*
			 * The UDP checksum is optional, only adjust it 
			 * if it has been set.
			 */
			sum1 = ntohs(udp->uh_sum);
			fix_datacksum(&udp->uh_sum, sumd);
			sum2 = ntohs(udp->uh_sum);

			/*
			 * Fix ICMP checksum to compensate the UDP 
			 * checksum adjustment.
			 */
			CALC_SUMD(sum1, sum2, sumd);
			sumd2 = sumd;
		}

#if 0
		/*
		 * Fix TCP pseudo header checksum to compensate for the 
		 * IP address change. Before we can do the change, we
		 * must make sure that oip is sufficient large to hold
		 * the TCP checksum (normally it does not!).
		 */
		if (oip->ip_p == IPPROTO_TCP) {
		
		}
#endif
d1121 1
d1123 5
a1127 37
		/*
		 * Fix IP checksum of the offending IP packet to adjust for
		 * the change in the IP address.
		 *
		 * Normally, you would expect that the ICMP checksum of the 
		 * ICMP error message needs to be adjusted as well for the
		 * IP address change in oip.
		 * However, this is a NOP, because the ICMP checksum is 
		 * calculated over the complete ICMP packet, which includes the
		 * changed oip IP addresses and oip->ip_sum. However, these 
		 * two changes cancel each other out (if the delta for
		 * the IP address is x, then the delta for ip_sum is minus x), 
		 * so no change in the icmp_cksum is necessary.
		 *
		 * Be careful that nat_dir refers to the direction of the
		 * offending IP packet (oip), not to its ICMP response (icmp)
		 */
		fix_datacksum(&oip->ip_sum, sumd);

/* XXX FV : without having looked at Solaris source code, it seems unlikely
 * that SOLARIS would compensate this in the kernel (a body of an IP packet 
 * in the data section of an ICMP packet). I have the feeling that this should
 * be unconditional, but I'm not in a position to check.
 */
#if !SOLARIS && !defined(__sgi)
		/*
		 * Fix UDP pseudo header checksum to compensate for the
		 * IP address change.
		 */
		if (oip->ip_p == IPPROTO_UDP && udp->uh_sum) {
			/*
			 * The UDP checksum is optional, only adjust it 
			 * if it has been set 
			 */
			sum1 = ntohs(udp->uh_sum);
			fix_datacksum(&udp->uh_sum, sumd);
			sum2 = ntohs(udp->uh_sum);
a1128 22
			/*
			 * Fix ICMP checksum to compensate the UDP 
			 * checksum adjustment.
			 */
			CALC_SUMD(sum1, sum2, sumd);
			sumd2 = sumd;
		}
		
#if 0
		/* 
		 * Fix TCP pseudo header checksum to compensate for the 
		 * IP address change. Before we can do the change, we
		 * must make sure that oip is sufficient large to hold
		 * the TCP checksum (normally it does not!).
		 */
		if (oip->ip_p == IPPROTO_TCP) {
		
		};
#endif
		
#endif
	}
d1133 2
a1134 24
		/*
		 * XXX - what if this is bogus hl and we go off the end ?
		 * In this case, nat_icmpinlookup() will have returned NULL.
		 */
		tcp = (tcphdr_t *)udp;

		/*
		 * Step 2 :
		 * For offending TCP/UDP IP packets, translate the ports as
		 * well, based on the NAT specification. Of course such
		 * a change must be reflected in the ICMP checksum as well.
		 *
		 * Advance notice : Now it becomes complicated :-)
		 *
		 * Since the port fields are part of the TCP/UDP checksum
		 * of the offending IP packet, you need to adjust that checksum
		 * as well... but, if you change, you must change the icmp
		 * checksum *again*, to reflect that change.
		 *
		 * To further complicate: the TCP checksum is not in the first
		 * 8 bytes of the offending ip packet, so it most likely is not
		 * available (we might have to fix that if the encounter a
		 * device that returns more than 8 data bytes on icmp error)
		 */
d1136 1
a1136 1
		if (nat->nat_oport == tcp->th_dport) {
a1137 4
				/*
				 * Fix ICMP checksum to compensate port
				 * adjustment.
				 */
a1140 1
				sumd2 += sumd;
d1142 1
a1142 24

				/*
				 * Fix udp checksum to compensate port
				 * adjustment.  NOTE : the offending IP packet
				 * flows the other direction compared to the
				 * ICMP message.
				 *
				 * The UDP checksum is optional, only adjust
				 * it if it has been set.
				 */
				if (oip->ip_p == IPPROTO_UDP && udp->uh_sum) {

					sum1 = ntohs(udp->uh_sum);
					fix_datacksum(&udp->uh_sum, sumd);
					sum2 = ntohs(udp->uh_sum);

					/*
					 * Fix ICMP checksum to 
					 * compensate UDP checksum 
					 * adjustment.
					 */
					CALC_SUMD(sum1, sum2, sumd);
					sumd2 += sumd;
				}
a1145 4
				/*
				 * Fix ICMP checksum to compensate port
				 * adjustment.
				 */
a1148 1
				sumd2 += sumd;
d1150 1
a1150 32

				/*
				 * Fix udp checksum to compensate port
				 * adjustment.   NOTE : the offending IP
				 * packet flows the other direction compared
				 * to the ICMP message.
				 *
				 * The UDP checksum is optional, only adjust
				 * it if it has been set.
				 */
				if (oip->ip_p == IPPROTO_UDP && udp->uh_sum) {

					sum1 = ntohs(udp->uh_sum);
					fix_datacksum(&udp->uh_sum, sumd);
					sum2 = ntohs(udp->uh_sum);

					/*
					 * Fix ICMP checksum to compensate
					 * UDP checksum adjustment.
					 */
					CALC_SUMD(sum1, sum2, sumd);
					sumd2 += sumd;
				}
			}
		}
		if (sumd2) {
			sumd2 = (sumd2 & 0xffff) + (sumd2 >> 16);
			sumd2 = (sumd2 & 0xffff) + (sumd2 >> 16);
			if (nat->nat_dir == NAT_OUTBOUND) {
				fix_outcksum(&icmp->icmp_cksum, sumd2);
			} else {
				fix_incksum(&icmp->icmp_cksum, sumd2);
d1169 1
a1169 1
nat_t *nat_inlookup(ifp, flags, p, src, mapdst, ports, rw)
a1173 1
int rw;
d1175 1
a1175 1
	register u_short sport, dport;
a1177 1
	register u_32_t dst;
d1180 1
a1180 2
	dst = mapdst.s_addr;
	dport = ports >> 16;
d1184 1
a1184 1
	hv = NAT_HASH_FN(dst, dport, ipf_nattable_sz);
d1190 1
a1190 1
		    nat->nat_outip.s_addr == dst &&
d1194 2
a1195 1
		      ((nat->nat_outport == dport) || (nflags & FI_W_SPORT)))))
d1198 1
a1198 84
	if (!nat_stats.ns_wilds || !(flags & IPN_TCPUDP))
		return NULL;
	if (!rw) {
		RWLOCK_EXIT(&ipf_nat);
	}
	hv = NAT_HASH_FN(dst, 0, ipf_nattable_sz);
	if (!rw) {
		WRITE_ENTER(&ipf_nat);
	}
	nat = nat_table[1][hv];
	for (; nat; nat = nat->nat_hnext[1]) {
		nflags = nat->nat_flags;
		if (ifp && ifp != nat->nat_ifp)
			continue;
		if (!(nflags & IPN_TCPUDP))
			continue;
		if (!(nflags & FI_WILDP))
			continue;
		if (nat->nat_oip.s_addr != src.s_addr ||
		    nat->nat_outip.s_addr != dst)
			continue;
		if (((nat->nat_oport == sport) || (nflags & FI_W_DPORT)) &&
		    ((nat->nat_outport == dport) || (nflags & FI_W_SPORT))) {
			nat_tabmove(nat, ports);
			break;
		}
	}
	if (!rw) {
		MUTEX_DOWNGRADE(&ipf_nat);
	}
	return nat;
}


/*
 * This function is only called for TCP/UDP NAT table entries where the
 * original was placed in the table without hashing on the ports and we now
 * want to include hashing on port numbers.
 */
static void nat_tabmove(nat, ports)
nat_t *nat;
u_32_t ports;
{
	register u_short sport, dport;
	nat_t **natp;
	u_int hv;

	dport = ports >> 16;
	sport = ports & 0xffff;

	if (nat->nat_oport == dport) {
		nat->nat_inport = sport;
		nat->nat_outport = sport;
	}

	/*
	 * Remove the NAT entry from the old location
	 */
	if (nat->nat_hnext[0])
		nat->nat_hnext[0]->nat_phnext[0] = nat->nat_phnext[0];
	*nat->nat_phnext[0] = nat->nat_hnext[0];

	if (nat->nat_hnext[1])
		nat->nat_hnext[1]->nat_phnext[1] = nat->nat_phnext[1];
	*nat->nat_phnext[1] = nat->nat_hnext[1];

	/*
	 * Add into the NAT table in the new position
	 */
	hv = NAT_HASH_FN(nat->nat_inip.s_addr, sport, ipf_nattable_sz);
	natp = &nat_table[0][hv];
	if (*natp)
		(*natp)->nat_phnext[0] = &nat->nat_hnext[0];
	nat->nat_phnext[0] = natp;
	nat->nat_hnext[0] = *natp;
	*natp = nat;

	hv = NAT_HASH_FN(nat->nat_outip.s_addr, sport, ipf_nattable_sz);
	natp = &nat_table[1][hv];
	if (*natp)
		(*natp)->nat_phnext[1] = &nat->nat_hnext[1];
	nat->nat_phnext[1] = natp;
	nat->nat_hnext[1] = *natp;
	*natp = nat;
d1208 1
a1208 1
nat_t *nat_outlookup(ifp, flags, p, src, dst, ports, rw)
a1212 1
int rw;
a1216 1
	u_32_t srcip;
a1221 1
	srcip = src.s_addr;
d1223 1
a1223 1
	hv = NAT_HASH_FN(srcip, sport, ipf_nattable_sz);
d1229 1
a1229 1
		    nat->nat_inip.s_addr == srcip &&
d1231 1
a1231 1
		    (((p == 0) && (flags == (nflags & IPN_TCPUDP)))
d1237 18
a1254 9
	if (!nat_stats.ns_wilds || !(flags & IPN_TCPUDP))
		return NULL;
	if (!rw) {
		RWLOCK_EXIT(&ipf_nat);
	}
	hv = NAT_HASH_FN(srcip, 0, ipf_nattable_sz);
	if (!rw) {
		WRITE_ENTER(&ipf_nat);
	}
d1257 2
a1258 2
		nflags = nat->nat_flags;
		if (ifp && ifp != nat->nat_ifp)
d1260 5
a1264 12
		if (!(nflags & IPN_TCPUDP))
			continue;
		if (!(nflags & FI_WILDP))
			continue;
		if ((nat->nat_inip.s_addr != srcip) ||
		    (nat->nat_oip.s_addr != dst.s_addr))
			continue;
		if (((nat->nat_inport == sport) || (nflags & FI_W_SPORT)) &&
		    ((nat->nat_oport == dport) || (nflags & FI_W_DPORT))) {
			nat_tabmove(nat, ports);
			break;
		}
d1266 1
a1266 4
	if (!rw) {
		MUTEX_DOWNGRADE(&ipf_nat);
	}
	return nat;
d1285 1
a1285 1
				 np->nl_outip, ports, 0))) {
a1292 44
static int nat_match(fin, np, ip)
fr_info_t *fin;
ipnat_t *np;
ip_t *ip;
{
	frtuc_t *ft;

	if (ip->ip_v != 4)
		return 0;

	if (np->in_p && ip->ip_p != np->in_p)
		return 0;
	if (fin->fin_out) {
		if (!(np->in_redir & (NAT_MAP|NAT_MAPBLK)))
			return 0;
		if (((fin->fin_fi.fi_saddr & np->in_inmsk) != np->in_inip)
		    ^ ((np->in_flags & IPN_NOTSRC) != 0))
			return 0;
		if (((fin->fin_fi.fi_daddr & np->in_srcmsk) != np->in_srcip)
		    ^ ((np->in_flags & IPN_NOTDST) != 0))
			return 0;
	} else {
		if (!(np->in_redir & NAT_REDIRECT))
			return 0;
		if (((fin->fin_fi.fi_saddr & np->in_srcmsk) != np->in_srcip)
		    ^ ((np->in_flags & IPN_NOTSRC) != 0))
			return 0;
		if (((fin->fin_fi.fi_daddr & np->in_outmsk) != np->in_outip)
		    ^ ((np->in_flags & IPN_NOTDST) != 0))
			return 0;
	}

	ft = &np->in_tuc;
	if (!(fin->fin_fi.fi_fl & FI_TCPUDP) ||
	    (fin->fin_fi.fi_fl & FI_SHORT) || (ip->ip_off & IP_OFFMASK)) {
		if (ft->ftu_scmp || ft->ftu_dcmp)
			return 0;
		return 1;
	}

	return fr_tcpudpchk(ft, fin);
}


d1304 1
a1304 1
	u_short sport = 0, dport = 0, *csump = NULL;
d1308 1
a1308 1
	u_int nflags = 0, hv, msk;
d1313 1
a1313 1
	if (nat_list == NULL || (fr_nat_lock))
d1337 1
a1337 5

	if ((ip->ip_p == IPPROTO_ICMP) &&
	    (nat = nat_icmp(ip, fin, &nflags, NAT_OUTBOUND)))
		;
	else if ((ip->ip_off & (IP_OFFMASK|IP_MF)) &&
d1340 2
a1341 3
	else if ((nat = nat_outlookup(ifp, nflags, (u_int)ip->ip_p,
				      ip->ip_src, ip->ip_dst,
				      (dport << 16) | sport, 0))) {
a1353 1
			nat_stats.ns_wilds--;
d1366 1
a1366 1
		hv = NAT_HASH_FN(iph, 0, ipf_natrules_sz);
d1369 6
a1374 12
			if ((np->in_ifp && (np->in_ifp != ifp)) ||
			    !np->in_space)
				continue;
			if ((np->in_flags & IPN_RF) &&
			    !(np->in_flags & nflags))
				continue;
			if (np->in_flags & IPN_FILTER) {
				if (!nat_match(fin, np, ip))
					continue;
			} else if ((ipa & np->in_inmsk) != np->in_inip)
				continue;
			if (np->in_redir & (NAT_MAP|NAT_MAPBLK)) {
d1388 3
a1405 3
	/*
	 * NOTE: ipf_nat must now only be held as a read lock
	 */
d1410 2
a1411 1
		MUTEX_ENTER(&nat->nat_lock);
d1415 1
a1415 1
		MUTEX_EXIT(&nat->nat_lock);
a1420 12
		if (nflags == IPN_ICMPERR) {
			u_32_t s1, s2, sumd;

			s1 = LONG_SUM(ntohl(ip->ip_src.s_addr));
			s2 = LONG_SUM(ntohl(nat->nat_outip.s_addr));
			CALC_SUMD(s1, s2, sumd);

			if (nat->nat_dir == NAT_OUTBOUND)
				fix_incksum(&ip->ip_sum, sumd);
			else
				fix_outcksum(&ip->ip_sum, sumd);
		}
d1422 4
a1425 6
		else {
			if (nat->nat_dir == NAT_OUTBOUND)
				fix_outcksum(&ip->ip_sum, nat->nat_ipsumd);
			else
				fix_incksum(&ip->ip_sum, nat->nat_ipsumd);
		}
a1426 1
		ip->ip_src = nat->nat_outip;
d1438 1
a1438 1
				MUTEX_ENTER(&nat->nat_lock);
d1440 1
a1440 1
					   nat->nat_tcpstate, fin, 1);
d1444 2
a1445 2
				else if (nat->nat_age > fr_defnatage)
					nat->nat_age = fr_defnatage;
d1455 1
a1455 1
				MUTEX_EXIT(&nat->nat_lock);
a1460 2
			} else if (ip->ip_p == IPPROTO_ICMP) {
				nat->nat_age = fr_defnaticmpage;
a1461 1

d1464 2
a1465 1
					fix_outcksum(csump, nat->nat_sumd[1]);
d1467 2
a1468 1
					fix_incksum(csump, nat->nat_sumd[1]);
a1470 1

d1472 3
a1474 7
		     (tcp != NULL && dport == np->in_dport))) {
			i = appr_check(ip, fin, nat);
			if (i == 0)
				i = 1;
		} else
			i = 1;
		ATOMIC_INCL(nat_stats.ns_mapped[1]);
d1476 1
a1476 1
		return i;
d1502 1
a1502 1
	if ((nat_list == NULL) || (ip->ip_v != 4) || (fr_nat_lock))
d1523 1
a1523 2
	if ((ip->ip_p == IPPROTO_ICMP) &&
	    (nat = nat_icmp(ip, fin, &nflags, NAT_INBOUND)))
d1525 1
a1525 1
	else if ((ip->ip_off & (IP_OFFMASK|IP_MF)) &&
d1529 1
a1529 2
				     ip->ip_src, in, (dport << 16) | sport,
				     0))) {
a1538 1
			nat_stats.ns_wilds--;
d1551 9
a1559 15
		hv = NAT_HASH_FN(iph, 0, ipf_rdrrules_sz);
		for (np = rdr_rules[hv]; np; np = np->in_rnext) {
			if ((np->in_ifp && (np->in_ifp != ifp)) ||
			    (np->in_p && (np->in_p != ip->ip_p)) ||
			    (np->in_flags && !(nflags & np->in_flags)))
				continue;
			if (np->in_flags & IPN_FILTER) {
				if (!nat_match(fin, np, ip))
					continue;
			} else if ((in.s_addr & np->in_outmsk) != np->in_outip)
				continue;
			if ((np->in_redir & NAT_REDIRECT) &&
			    (!np->in_pmin || (np->in_flags & IPN_FILTER) ||
			     ((ntohs(np->in_pmax) >= ntohs(dport)) &&
			      (ntohs(dport) >= ntohs(np->in_pmin)))))
d1563 3
d1568 1
a1568 2
		}

a1578 4

	/*
	 * NOTE: ipf_nat must now only be held as a read lock
	 */
d1585 2
a1586 7
		    (tcp != NULL && sport == np->in_dport))) {
			i = appr_check(ip, fin, nat);
			if (i == -1) {
				RWLOCK_EXIT(&ipf_nat);
				return i;
			}
		}
d1588 1
a1588 1
		MUTEX_ENTER(&nat->nat_lock);
d1594 1
a1594 1
		MUTEX_EXIT(&nat->nat_lock);
d1596 1
a1596 1
		fin->fin_fi.fi_daddr = nat->nat_inip.s_addr;
d1604 1
a1604 1
			fix_incksum(&ip->ip_sum, nat->nat_ipsumd);
d1606 1
a1606 1
			fix_outcksum(&ip->ip_sum, nat->nat_ipsumd);
d1618 1
a1618 1
				MUTEX_ENTER(&nat->nat_lock);
d1620 1
a1620 1
					   nat->nat_tcpstate, fin, 0);
d1624 2
a1625 2
				else if (nat->nat_age > fr_defnatage)
					nat->nat_age = fr_defnatage;
d1635 1
a1635 1
				MUTEX_EXIT(&nat->nat_lock);
a1640 2
			} else if (ip->ip_p == IPPROTO_ICMP) {
				nat->nat_age = fr_defnaticmpage;
a1641 1

d1644 1
a1644 1
					fix_incksum(csump, nat->nat_sumd[0]);
d1646 1
a1646 1
					fix_outcksum(csump, nat->nat_sumd[0]);
d1649 1
a1649 1
		ATOMIC_INCL(nat_stats.ns_mapped[0]);
a1683 4
	if (maptable != NULL) {
		KFREES(maptable, sizeof(hostmap_t *) * ipf_hostmap_sz);
		maptable = NULL;
	}
d1749 1
a1749 1
			if (fr_ifpaddr(4, ifp2, &in) != -1)
d1770 1
a1770 1
			n->in_ifp = (void *)GETUNIT(n->in_ifname, 4);
@


1.26.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.26.2.2 2001/05/14 22:40:12 niklas Exp $	*/
@


1.25
log
@Patch to fix ipmon -F. /dev/ipnat and /dev/ipstate now handle SIOCIPFFB.
from darrenr@@pobox.com
@
text
@d1 2
a2 1
/* $OpenBSD: ip_nat.c,v 1.24 1999/12/17 06:17:08 kjell Exp $ */
d14 1
a14 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.24 1999/12/17 06:17:08 kjell Exp $";
d748 4
d756 4
d761 3
a763 1
					in.s_addr = ntohl(in.s_addr);
d1798 1
@


1.24
log
@Update to Darren Reed's IPFilter 3.3.5
Fixes: realaudio proxy issues, "log level" printing, and
source address for icmp replies (was reversed).

Thoughtfully submitted by techs@@obfuscation.org
@
text
@d1 1
a1 1
/* $OpenBSD: ip_nat.c,v 1.23 1999/12/15 05:20:22 kjell Exp $ */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.23 1999/12/15 05:20:22 kjell Exp $";
d326 8
@


1.23
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 2.2.2.9 1999/12/04 02:08:43 darrenr Exp $";
d794 1
d1731 1
a1731 1
				nat->nat_outip.s_addr = htonl(in.s_addr);
@


1.22
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.c,v 1.21 1999/06/07 22:00:34 deraadt Exp $       */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.21 1999/06/07 22:00:34 deraadt Exp $";
d25 4
d56 3
a58 1
# include <sys/dditypes.h>
d68 3
d73 1
a73 1
#include <net/af.h>
d88 2
a89 2
#include <vpn/md5.h>
#include <vpn/ipsec.h>
a98 1
#if defined(__OpenBSD__)
a99 3
#else
#include <netinet/ip_compat.h>
#endif
d106 3
d110 1
a110 1
#define	MIN(a,b)	(((a)<(b))?(a):(b))
d115 2
a116 1
nat_t	*nat_table[2][NAT_SIZE], *nat_instances = NULL;
d118 10
a127 2
u_long	fr_defnatage = 1200,	/* 10 minutes (600 seconds) */
	fr_defnaticmpage = 6;	/* 3 seconds */
d137 31
a167 1
static	int	nat_ifpaddr __P((nat_t *, void *, struct in_addr *));
d170 30
a199 1
#define	LONG_SUM(in)	(((in) & 0xffff) + ((in) >> 16))
a200 10
#define	CALC_SUMD(s1, s2, sd) { \
			    (s1) = ((s1) & 0xffff) + ((s1) >> 16); \
			    (s2) = ((s2) & 0xffff) + ((s2) >> 16); \
			    /* Do it twice */ \
			    (s1) = ((s1) & 0xffff) + ((s1) >> 16); \
			    (s2) = ((s2) & 0xffff) + ((s2) >> 16); \
			    /* Because ~1 == -2, We really need ~1 == -1 */ \
			    if ((s1) > (s2)) (s2)--; \
			    (sd) = (s2) - (s1); \
			    (sd) = ((sd) & 0xffff) + ((sd) >> 16); }
d202 1
a202 1
void fix_outcksum(sp, n)
d205 1
d212 6
d228 1
a228 1
void fix_incksum(sp, n)
d231 1
d238 6
d288 1
d290 1
a290 1
	int error = 0, ret;
d295 5
d301 1
a301 1
	KMALLOC(nt, ipnat_t *, sizeof(*nt));
d312 6
a317 2
		nat->in_inip &= nat->in_inmsk;
		nat->in_outip &= nat->in_outmsk;
d335 1
a335 3
		n = nt;
		nt = NULL;
		if (n == NULL) {
d339 2
d346 1
a346 1
			n->in_apr = ap_match(n->in_p, n->in_plabel);
d352 32
a383 1
		n->in_next = *np;
d385 6
a390 3
		n->in_space = ~(0xffffffff & ntohl(n->in_outmsk));
		if (n->in_space) /* lose 2: broadcast + network address */
			n->in_space -= 2;
d392 19
a410 2
			n->in_space = 1;	/* single IP# mapping */
		if ((n->in_outmsk != 0xffffffff) && n->in_outmsk)
d419 1
a419 1
			if (ntohs(n->in_pmax) > ntohs(n->in_pmin))
d421 27
a447 1
						ntohs(n->in_pmin));
a449 1
		*np = n;
d463 8
d474 1
a474 1
				ap_free(n->in_apr);
d488 4
d568 3
d576 2
a577 1
	if ((ipn = natd->nat_ptr)) {
d582 1
a582 1
				ap_free(ipn->in_apr);
d608 1
a608 1
				ap_free(n->in_apr);
d619 1
d627 1
a627 1

d629 1
a629 1
         * ALL NAT mappings deleted, so lets just make it the deletions
d632 6
a637 2
	bzero((char *)nat_table[0], sizeof(nat_table[0]));
	bzero((char *)nat_table[1], sizeof(nat_table[1]));
d657 5
d666 1
a666 1
				ap_free(n->in_apr);
d675 2
a681 67
 * return the first IP Address associated with an interface
 */
static int nat_ifpaddr(nat, ifptr, inp)
nat_t *nat;
void *ifptr;
struct in_addr *inp;
{
#if SOLARIS
	ill_t *ill = ifptr;
#else
	struct ifnet *ifp = ifptr;
#endif
	struct in_addr in;

#if SOLARIS
	in.s_addr = ntohl(ill->ill_ipif->ipif_local_addr);
#else /* SOLARIS */
# if linux
	;
# else /* linux */
	struct ifaddr *ifa;
	struct sockaddr_in *sin;

#  if	(__FreeBSD_version >= 300000)
	ifa = TAILQ_FIRST(&ifp->if_addrhead);
#  else
#   if defined(__NetBSD__) || defined(__OpenBSD__)
	ifa = ifp->if_addrlist.tqh_first;
#   else
#    if defined(__sgi) && defined(IFF_DRVRLOCK) /* IRIX 6 */
	ifa = &((struct in_ifaddr *)ifp->in_ifaddr)->ia_ifa;
#    else
	ifa = ifp->if_addrlist;
#    endif
#   endif /* __NetBSD__ || __OpenBSD__ */
#  endif /* __FreeBSD_version >= 300000 */
#  if (BSD < 199306) && !(/*IRIX6*/defined(__sgi) && defined(IFF_DRVRLOCK))
	sin = (SOCKADDR_IN *)&ifa->ifa_addr;
#  else
	sin = (SOCKADDR_IN *)ifa->ifa_addr;
	while (sin && ifa &&
	       sin->sin_family != AF_INET) {
#   if	(__FreeBSD_version >= 300000)
		ifa = TAILQ_NEXT(ifa, ifa_link);
#   else
#    if defined(__NetBSD__) || defined(__OpenBSD__)
		ifa = ifa->ifa_list.tqe_next;
#    else
		ifa = ifa->ifa_next;
#    endif
#   endif /* __FreeBSD_version >= 300000 */
		if (ifa)
			sin = (SOCKADDR_IN *)ifa->ifa_addr;
	}
	if (!ifa || !sin)
		return -1;
#  endif /* (BSD < 199306) && (!__sgi && IFF_DRVLOCK) */
	in = sin->sin_addr;
	in.s_addr = ntohl(in.s_addr);
# endif /* linux */
#endif /* SOLARIS */
	*inp = in;
	return 0;
}


/*
d689 1
a689 1
u_short flags;
d694 2
a695 1
	struct in_addr in;
a696 1
	nat_t *nat, **natp;
d698 4
d711 1
a711 1
	KMALLOC(nat, nat_t *, sizeof(*nat));
a716 1

d722 2
a723 2
		* Values at which the search for a free resouce starts.
		*/
a735 1
			l++;
d738 11
d751 1
a751 1
				if (l > 1) {
d757 34
a790 3
			if (!in.s_addr && (np->in_outmsk == 0xffffffff)) {
				if ((l > 1) ||
				    nat_ifpaddr(nat, fin->fin_ifp, &in) == -1) {
d795 4
a798 1
				if (l > 1) {
d803 30
a832 1
			} else if ((nflags & IPN_TCPUDP)) {
d834 1
a834 1
				if (np->in_pnext >= ntohs(np->in_pmax)) {
d839 1
a839 2
			} else if (np->in_outmsk != 0xffffffff)
				np->in_nip++;
d841 8
a848 5
			if (!np->in_nip && (nflags & IPN_TCPUDP) &&
			    (np->in_pnext != 0)) {
				port = htons(np->in_pnext++);
				if (np->in_pnext >= ntohs(np->in_pmax))
					np->in_pnext = ntohs(np->in_pmin);
a852 3
			if ((np->in_nip & ntohl(np->in_outmsk)) >
			    ntohl(np->in_outip))
				np->in_nip = ntohl(np->in_outip) + 1;
d855 20
a874 4
			* Has the search wrapped around and come back to the
			* start ?
			*/
			if ((np->in_pnext != 0) && (st_port == np->in_pnext) &&
d879 2
d882 1
a882 4
		} while (nat_inlookup(fin->fin_ifp, flags, ip->ip_dst,
				      dport, in, port));

		if (np->in_space > 1)
d890 2
a891 4
		sum1 = (ntohl(ip->ip_src.s_addr) & 0xffff) +
			(ntohl(ip->ip_src.s_addr) >> 16) + ntohs(sport);

		sum2 = (in.s_addr & 0xffff) + (in.s_addr >> 16) + ntohs(port);
d895 1
a895 1
			nat->nat_outport = port;
a898 1

d909 10
d923 2
a924 4
		sum1 = (ntohl(ip->ip_dst.s_addr) & 0xffff) +
			(ntohl(ip->ip_dst.s_addr) >> 16) + ntohs(dport);

		sum2 = (in.s_addr & 0xffff) + (in.s_addr >> 16) + ntohs(nport);
d933 16
a948 11
	sum1 = (sum1 & 0xffff) + (sum1 >> 16);
	sum2 = (sum2 & 0xffff) + (sum2 >> 16);
	/* Do it twice */
	sum1 = (sum1 & 0xffff) + (sum1 >> 16);
	sum2 = (sum2 & 0xffff) + (sum2 >> 16);

	if (sum1 > sum2)
		sum2--; /* Because ~1 == -2, We really need ~1 == -1 */
	sumd = sum2 - sum1;
	sumd = (sumd & 0xffff) + (sumd >> 16);
	nat->nat_sumd = (sumd & 0xffff) + (sumd >> 16);
d952 1
a952 2
			sum1 = (ntohl(ip->ip_src.s_addr) & 0xffff) +
				(ntohl(ip->ip_src.s_addr) >> 16);
d954 1
a954 2
			sum1 = (ntohl(ip->ip_dst.s_addr) & 0xffff) +
				(ntohl(ip->ip_dst.s_addr) >> 16);
d956 1
a956 1
		sum2 = (in.s_addr & 0xffff) + (in.s_addr >> 16);
d958 1
a958 10
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);
		/* Do it twice */
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);

		if (sum1 > sum2)
			sum2--; /* Because ~1 == -2, We really need ~1 == -1 */
		sumd = sum2 - sum1;
		sumd = (sumd & 0xffff) + (sumd >> 16);
d961 1
a961 1
		nat->nat_ipsumd = nat->nat_sumd;
d966 2
a967 1
	natp = &nat_table[0][nat->nat_inip.s_addr % NAT_SIZE];
d971 2
a972 1
	natp = &nat_table[1][nat->nat_outip.s_addr % NAT_SIZE];
d976 2
d979 1
a981 2
	nat->nat_ifp = fin->fin_ifp;
	nat->nat_dir = direction;
d983 4
d1036 3
a1038 2
		return nat_inlookup(fin->fin_ifp, flags, oip->ip_dst,
				    tcp->th_dport, oip->ip_src, tcp->th_sport);
d1040 2
a1041 1
	return nat_inlookup(fin->fin_ifp, 0, oip->ip_dst, 0, oip->ip_src, 0);
d1052 1
a1052 1
int *nflags;
d1094 1
a1094 1
		fix_incksum(&oip->ip_sum, sumd);
d1099 1
a1099 1
		fix_outcksum(&icmp->icmp_cksum, sumd);
d1101 1
a1101 1
		fix_outcksum(&oip->ip_sum, sumd);
d1103 4
a1106 4
                sumd += (sumd & 0xffff);
                while (sumd > 0xffff)
                       sumd = (sumd & 0xffff) + (sumd >> 16);
                fix_incksum(&icmp->icmp_cksum, sumd);
d1108 2
a1109 2
 
 
d1111 1
a1111 1
                tcphdr_t *tcp;
d1122 1
a1122 1
				fix_outcksum(&icmp->icmp_cksum, sumd);
d1130 1
a1130 1
				fix_incksum(&icmp->icmp_cksum, sumd);
a1133 1

d1149 1
a1149 4
#ifdef __STDC__
nat_t *nat_inlookup(void *ifp, int flags, struct in_addr src, u_short sport, struct in_addr mapdst, u_short mapdport)
#else
nat_t *nat_inlookup(ifp, flags, src, sport, mapdst, mapdport)
d1151 1
a1151 1
register int flags;
d1153 1
a1153 2
u_short sport, mapdport;
#endif
d1155 1
d1157 2
d1160 2
d1164 4
a1167 2
	nat = nat_table[1][mapdst.s_addr % NAT_SIZE];
	for (; nat; nat = nat->nat_hnext[1])
d1171 5
a1175 3
		    flags == nat->nat_flags && (!flags ||
		     (nat->nat_oport == sport &&
		      nat->nat_outport == mapdport)))
d1177 1
d1188 1
a1188 4
#ifdef __STDC__
nat_t *nat_outlookup(void *ifp, int flags, struct in_addr src, u_short sport, struct in_addr dst, u_short dport)
#else
nat_t *nat_outlookup(ifp, flags, src, sport, dst, dport)
d1190 1
a1190 1
register int flags;
d1192 1
a1192 2
u_short sport, dport;
#endif
d1194 1
d1196 2
d1199 2
d1203 2
a1204 1
	nat = nat_table[0][src.s_addr % NAT_SIZE];
d1206 2
d1211 4
a1214 2
		    flags == nat->nat_flags && (!flags ||
		     (nat->nat_inport == sport && nat->nat_oport == dport)))
d1222 2
a1223 3
 * Lookup a nat entry based on the mapped source ip address/port and
 * real destination address/port.  We use this lookup when sending a packet
 * out, we're looking for a table entry, based on the source address.
d1225 1
a1225 4
#ifdef __STDC__
nat_t *nat_lookupmapip(void *ifp, int flags, struct in_addr mapsrc, u_short mapsport, struct in_addr dst, u_short dport)
#else
nat_t *nat_lookupmapip(ifp, flags, mapsrc, mapsport, dst, dport)
d1227 2
a1228 4
register int flags;
struct in_addr mapsrc , dst;
u_short mapsport, dport;
#endif
d1231 2
d1234 6
a1239 1
	flags &= IPN_TCPUDP;
a1240 2
	nat = nat_table[1][mapsrc.s_addr % NAT_SIZE];
	for (; nat; nat = nat->nat_hnext[0])
d1242 2
a1243 5
		    nat->nat_oip.s_addr == dst.s_addr &&
		    nat->nat_outip.s_addr == mapsrc.s_addr &&
		    flags == nat->nat_flags && (!flags ||
		     (nat->nat_outport == mapsport &&
		      nat->nat_oport == dport)))
d1245 1
d1256 1
d1259 1
d1264 2
a1265 3
	if ((nat = nat_outlookup(NULL, np->nl_flags, np->nl_inip,
				 np->nl_inport, np->nl_outip,
				 np->nl_outport))) {
d1277 1
a1277 1
int ip_natout(ip, hlen, fin)
a1278 1
int hlen;
d1281 1
a1281 1
	register ipnat_t *np;
d1286 1
d1288 2
d1291 4
a1294 1
	int natadd = 1;
d1320 16
a1335 4
	else if ((nat = nat_outlookup(ifp, nflags, ip->ip_src, sport,
				      ip->ip_dst, dport)))
		;
	else {
d1342 7
a1348 1
		for (np = nat_list; np; np = np->in_next)
d1350 2
a1351 1
			    (!np->in_flags || (np->in_flags & nflags)) &&
d1353 1
a1353 1
			    ((np->in_redir & NAT_MAP) ||
d1355 1
a1355 1
				if (*np->in_plabel && !ap_ok(ip, tcp, np))
d1363 1
a1363 1
				if (!(np->in_redir & NAT_MAP))
d1365 3
a1367 2
				if ((nat = nat_new(np, ip, fin, nflags,
						    NAT_OUTBOUND)))
d1369 1
a1369 3
					nat_log(nat, (u_short)np->in_redir);
#else
					;
d1371 2
a1372 1
				break;
d1374 9
d1387 9
a1395 8
			if (natadd && fin->fin_fi.fi_fl & FI_FRAG)
				ipfr_nat_newfrag(ip, fin, 0, nat);
			ip->ip_src = nat->nat_outip;
			MUTEX_ENTER(&ipf_rw);
			nat->nat_age = fr_defnatage;
			nat->nat_bytes += ip->ip_len;
			nat->nat_pkts++;
			MUTEX_EXIT(&ipf_rw);
d1397 4
a1400 4
			/*
			 * Fix up checksums, not by recalculating them, but
			 * simply computing adjustments.
			 */
d1402 4
a1405 4
			if (nat->nat_dir == NAT_OUTBOUND)
				fix_outcksum(&ip->ip_sum, nat->nat_ipsumd);
			else
				fix_incksum(&ip->ip_sum, nat->nat_ipsumd);
d1408 2
a1409 2
			if (!(ip->ip_off & IP_OFFMASK) &&
			    !(fin->fin_fi.fi_fl & FI_SHORT)) {
d1411 4
a1414 5
				if ((nat->nat_outport != 0) &&
				    (nflags & IPN_TCPUDP)) {
					tcp->th_sport = nat->nat_outport;
					fin->fin_data[0] = ntohs(tcp->th_sport);
				}
d1416 22
a1437 16
				if (ip->ip_p == IPPROTO_TCP) {
					csump = &tcp->th_sum;
					MUTEX_ENTER(&ipf_rw);
					fr_tcp_age(&nat->nat_age,
						   nat->nat_state, ip, fin,1);
					/*
					 * Increase this because we may have
					 * "keep state" following this too and
					 * packet storms can occur if this is
					 * removed too quickly.
					 */
					if (nat->nat_age == fr_tcpclosed)
						nat->nat_age = fr_tcplastack;
					MUTEX_EXIT(&ipf_rw);
				} else if (ip->ip_p == IPPROTO_UDP) {
					udphdr_t *udp = (udphdr_t *)tcp;
d1439 10
a1448 11
					if (udp->uh_sum)
						csump = &udp->uh_sum;
				}
				if (csump) {
					if (nat->nat_dir == NAT_OUTBOUND)
						fix_outcksum(csump,
							     nat->nat_sumd);
					else
						fix_incksum(csump,
							    nat->nat_sumd);
				}
a1449 4
			(void) ap_check(ip, fin, nat);
			ATOMIC_INC(nat_stats.ns_mapped[1]);
			RWLOCK_EXIT(&ipf_nat);	/* READ */
			return -2;
d1451 7
d1467 1
a1467 1
int ip_natin(ip, hlen, fin)
a1468 1
int hlen;
d1471 2
d1474 1
a1474 1
	register struct in_addr in;
d1479 5
a1483 1
	int nflags = 0, natadd = 1;
d1498 2
d1508 13
a1520 4
	else if ((nat = nat_inlookup(fin->fin_ifp, nflags, ip->ip_src, sport,
				     ip->ip_dst, dport)))
		;
	else {
d1527 6
a1532 1
		for (np = nat_list; np; np = np->in_next)
d1536 1
d1538 2
a1539 1
			     (!np->in_pmin || np->in_pmin == dport)) {
d1541 2
a1542 1
						    NAT_INBOUND)))
d1544 1
a1544 3
					nat_log(nat, (u_short)np->in_redir);
#else
					;
d1546 2
a1547 1
				break;
d1549 8
d1560 17
a1576 13
			if (natadd && fin->fin_fi.fi_fl & FI_FRAG)
				ipfr_nat_newfrag(ip, fin, 0, nat);
			(void) ap_check(ip, fin, nat);

			MUTEX_ENTER(&ipf_rw);
			if (nflags != IPN_ICMPERR)
				nat->nat_age = fr_defnatage;

			nat->nat_bytes += ip->ip_len;
			nat->nat_pkts++;
			MUTEX_EXIT(&ipf_rw);
			ip->ip_dst = nat->nat_inip;
			fin->fin_fi.fi_dst = nat->nat_inip;
d1578 4
a1581 4
			/*
			 * Fix up checksums, not by recalculating them, but
			 * simply computing adjustments.
			 */
d1583 4
a1586 4
			if (nat->nat_dir == NAT_OUTBOUND)
				fix_incksum(&ip->ip_sum, nat->nat_ipsumd);
			else
				fix_outcksum(&ip->ip_sum, nat->nat_ipsumd);
d1588 2
a1589 2
			if (!(ip->ip_off & IP_OFFMASK) &&
			    !(fin->fin_fi.fi_fl & FI_SHORT)) {
d1591 4
a1594 5
				if ((nat->nat_inport != 0) &&
				    (nflags & IPN_TCPUDP)) {
					tcp->th_dport = nat->nat_inport;
					fin->fin_data[1] = ntohs(tcp->th_dport);
				}
d1596 22
a1617 16
				if (ip->ip_p == IPPROTO_TCP) {
					csump = &tcp->th_sum;
					MUTEX_ENTER(&ipf_rw);
					fr_tcp_age(&nat->nat_age,
						   nat->nat_state, ip, fin,0);
					/*
					 * Increase this because we may have
					 * "keep state" following this too and
					 * packet storms can occur if this is
					 * removed too quickly.
					 */
					if (nat->nat_age == fr_tcpclosed)
						nat->nat_age = fr_tcplastack;
					MUTEX_EXIT(&ipf_rw);
				} else if (ip->ip_p == IPPROTO_UDP) {
					udphdr_t *udp = (udphdr_t *)tcp;
d1619 8
a1626 11
					if (udp->uh_sum)
						csump = &udp->uh_sum;
				}
				if (csump) {
					if (nat->nat_dir == NAT_OUTBOUND)
						fix_incksum(csump,
							    nat->nat_sumd);
					else
						fix_outcksum(csump,
							     nat->nat_sumd);
				}
a1627 3
			ATOMIC_INC(nat_stats.ns_mapped[0]);
			RWLOCK_EXIT(&ipf_nat);			/* READ */
			return -2;
d1629 4
d1647 17
a1699 3
#ifdef __STDC__
void ip_natsync(void *ifp)
#else
a1701 1
#endif
d1703 1
d1708 1
d1713 4
d1720 12
a1731 10
		if ((ifp == nat->nat_ifp) && (np = nat->nat_ptr))
			if ((np->in_outmsk == 0xffffffff) && !np->in_nip) {
				/*
				 * Change the map-to address to be the same
				 * as the new one.
				 */
				sum1 = nat->nat_outip.s_addr;
				if (nat_ifpaddr(nat, ifp, &in) == -1)
				    nat->nat_outip.s_addr = htonl(in.s_addr);
				sum2 = nat->nat_outip.s_addr;
d1733 14
a1746 8
				/*
				 * Readjust the checksum adjustment to take
				 * into account the new IP#.
				 *
				 * Do it twice
				 */
				sum1 = (sum1 & 0xffff) + (sum1 >> 16);
				sum2 = (sum2 & 0xffff) + (sum2 >> 16);
d1748 6
a1753 12
				/* Do it twice */
				sum1 = (sum1 & 0xffff) + (sum1 >> 16);
				sum2 = (sum2 & 0xffff) + (sum2 >> 16);

				 /* Because ~1 == -2, We really need ~1 == -1 */
				if (sum1 > sum2)
					sum2--;
				sumd = sum2 - sum1;
				sumd = (sumd & 0xffff) + (sumd >> 16);
				sumd += nat->nat_sumd;
				nat->nat_sumd = (sumd & 0xffff) + (sumd >> 16);
			}
a1759 3
# ifdef __STDC__
void nat_log(struct nat *nat, u_short type)
# else
d1762 1
a1762 2
u_short type;
# endif
d1780 2
a1781 1
	if (nat->nat_ptr) {
d1788 1
d1793 1
a1793 1
	(void) ipllog(IPL_LOGNAT, 0, items, sizes, types, 1);
@


1.21
log
@I do not believe this
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.c,v 1.20 1999/02/05 05:58:52 deraadt Exp $       */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.20 1999/02/05 05:58:52 deraadt Exp $";
d416 20
@


1.20
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.c,v 1.19 1999/02/01 07:45:53 d Exp $       */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.19 1999/02/01 07:45:53 d Exp $";
a163 3
#ifdef sparc
	sum1 = (~(*sp)) & 0xffff;
#else
a164 1
#endif
@


1.19
log
@remove the correct KFREE
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.c,v 1.18 1999/01/29 07:01:46 d Exp $       */
d3 1
a3 1
 * Copyright (C) 1995-1997 by Darren Reed.
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.18 1999/01/29 07:01:46 d Exp $";
d20 5
a29 5
#include <sys/errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/file.h>
d114 1
a114 1
extern	krwlock_t	ipf_nat;
d126 2
a129 3
			    (s1) = ((s1) & 0xffff) + ((s1) >> 16); \
			    /* Do it twice */ \
			    (s2) = ((s2) & 0xffff) + ((s2) >> 16); \
d259 7
a265 1
		n->in_apr = ap_match(n->in_p, n->in_plabel);
d289 1
a289 1
		ATOMIC_INC(nat_stats.ns_rules);
d306 1
a306 1
			ATOMIC_DEC(nat_stats.ns_rules);
d318 1
a339 1
		(void) ap_unload();
d363 1
a363 1
	RWLOCK_EXIT(&ipf_nat);
d400 1
a400 1
		ATOMIC_INC(ipn->in_space);
d415 2
d428 1
a428 1
  
d430 1
a430 1
	 * Everything will be deleted, so lets just make it the deletions
d441 1
a441 1

d447 1
a447 1
 * nat_clearlist - delete all entries in the active NAT mapping list.
d460 1
a460 2
			ATOMIC_DEC(nat_stats.ns_rules);
			i++;
d465 1
a466 1
	nat_stats.ns_inuse = 0;
d540 1
d576 6
d586 3
d593 8
d613 1
a613 3
				if (nflags & IPN_TCPUDP)
					port = sport;
			} else if (nflags & IPN_TCPUDP) {
a616 1
					np->in_space--;
d620 1
a620 2
			} else if (np->in_outmsk != 0xffffffff) {
				np->in_space--;
d622 6
d635 11
d649 3
d695 2
a698 4
	sum1 = (sum1 & 0xffff) + (sum1 >> 16);

	/* Do it twice */
	sum2 = (sum2 & 0xffff) + (sum2 >> 16);
d717 2
a720 4
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);

		/* Do it twice */
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);
d747 1
d755 3
a757 3
	ATOMIC_INC(nat_stats.ns_added);
	ATOMIC_INC(nat_stats.ns_inuse);
	ATOMIC_INC(np->in_use);
d777 1
a777 1
	if ((ip->ip_hl != 5) || (ip->ip_len < sizeof(*icmp) + sizeof(ip_t)))
d789 2
d800 1
a800 1
	return nat_inlookup(fin->fin_ifp, 0, oip->ip_src, 0, oip->ip_dst, 0);
d813 2
a821 1

d824 1
a824 1
	oip = (ip_t *)((char *)icmp + 8);
d838 16
a853 4
	if (flags & IPN_TCPUDP) {
		tcphdr_t *tcp = (tcphdr_t *)(oip + 1);
		u_32_t	sum1, sum2, sumd;
		struct in_addr in;
d855 6
a860 11
		if (nat->nat_dir == NAT_OUTBOUND) {
			sum1 = LONG_SUM(ntohl(oip->ip_src.s_addr));
			in = nat->nat_outip;
			oip->ip_src = in;
			tcp->th_sport = nat->nat_outport;
		} else {
			sum1 = LONG_SUM(ntohl(oip->ip_dst.s_addr));
			in = nat->nat_inip;
			oip->ip_dst = in;
			tcp->th_dport = nat->nat_inport;
		}
d862 9
a870 1
		sum2 = LONG_SUM(in.s_addr);
d872 2
a873 2
		CALC_SUMD(sum1, sum2, sumd);
		sumd = (sumd & 0xffff) + (sumd >> 16);
d876 7
a882 2
			fix_incksum(&oip->ip_sum, sumd);
			fix_incksum(&icmp->icmp_cksum, sumd);
d884 7
a890 2
			fix_outcksum(&oip->ip_sum, sumd);
			fix_outcksum(&icmp->icmp_cksum, sumd);
d892 1
a893 18
		/*
		 * TCP checksum doesn't make it into the 1st eight
		 * bytes but UDP does.
		 */
		if (ip->ip_p == IPPROTO_UDP) {
			udphdr_t *udp = (udphdr_t *)tcp;

			if (udp->uh_sum) {
				if (nat->nat_dir == NAT_OUTBOUND)
					fix_incksum(&udp->uh_sum,
						    nat->nat_sumd);
				else
					fix_outcksum(&udp->uh_sum,
						     nat->nat_sumd);
			}
		}
	} else
		ip->ip_dst = nat->nat_outip;
d1047 1
a1047 1
	if (!(ip->ip_off & 0x1fff) && !(fin->fin_fi.fi_fl & FI_SHORT)) {
d1052 1
a1052 1
		if (nflags) {
d1100 1
a1100 1
			MUTEX_DOWNGRADE(&ipf_nat);
d1124 1
a1124 1
			if (nflags && !(ip->ip_off & 0x1fff) &&
d1127 2
a1128 1
				if (nat->nat_outport)
d1130 2
a1151 4
				} else if (ip->ip_p == IPPROTO_ICMP) {
					icmphdr_t *ic = (icmphdr_t *)tcp;

					csump = &ic->icmp_cksum;
d1162 1
a1162 1
			(void) ap_check(ip, tcp, fin, nat);
d1164 1
a1164 1
			RWLOCK_EXIT(&ipf_nat);
d1167 1
a1167 1
	RWLOCK_EXIT(&ipf_nat);
d1189 1
a1189 1
	if (!(ip->ip_off & 0x1fff) && !(fin->fin_fi.fi_fl & FI_SHORT)) {
d1194 2
a1195 2
		if (nflags) {
			tcp = (tcphdr_t *)((char *)ip + hlen);
d1235 1
a1235 1
			MUTEX_DOWNGRADE(&ipf_nat);
d1240 2
a1242 2
			(void) ap_check(ip, tcp, fin, nat);

d1250 1
d1262 1
a1262 1
			if ((nflags & IPN_TCPUDP) && !(ip->ip_off & 0x1fff) &&
d1265 2
a1266 1
				if (nat->nat_inport)
d1268 2
a1289 4
				} else if (ip->ip_p == IPPROTO_ICMP) {
					icmphdr_t *ic = (icmphdr_t *)tcp;

					csump = &ic->icmp_cksum;
d1301 1
a1301 1
			RWLOCK_EXIT(&ipf_nat);
d1304 1
a1304 1
	RWLOCK_EXIT(&ipf_nat);
a1316 1
	(void) ap_unload();
d1335 1
a1335 1
		ATOMIC_DEC(nat->nat_age);
d1345 1
a1345 1
		ATOMIC_INC(nat_stats.ns_expire);
a1346 3

	ap_expire();

d1390 1
a1390 1
				sum1 = (sum1 & 0xffff) + (sum1 >> 16);
d1393 1
a1393 1
				sum2 = (sum2 & 0xffff) + (sum2 >> 16);
@


1.18
log
@remove multiple free
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.c,v 1.17 1998/10/11 05:37:28 deraadt Exp $       */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.17 1998/10/11 05:37:28 deraadt Exp $";
d520 1
a520 4
	if (!ifa)
		sin = NULL;
	if (!sin) {
		KFREE(nat);
a521 1
	}
d579 2
a580 1
				    nat_ifpaddr(nat, fin->fin_ifp, &in) == -1)
d582 1
d1337 1
a1337 1
				nat->nat_outip.s_addr = htonl(in.s_addr);
@


1.17
log
@bad ioctls return EINVAL; garath@@code.ridgefield.org
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.c,v 1.16 1998/09/15 09:51:18 pattonme Exp $       */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.16 1998/09/15 09:51:18 pattonme Exp $";
d583 1
a583 2
				    nat_ifpaddr(nat, fin->fin_ifp, &in) == -1) {
					KFREE(nat);
a584 1
				}
@


1.16
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.c,v 1.15 1998/06/27 08:07:58 deraadt Exp $       */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id$";
d353 3
@


1.15
log
@delete extra KFREE(); d@@openbsd.org
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.c,v 1.14 1998/02/17 01:39:05 dgregor Exp $       */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.14 1998/02/17 01:39:05 dgregor Exp $";
d90 5
a94 1
#include "ip_fil_compat.h"
d96 5
a100 5
#include "ip_fil.h"
#include "ip_proxy.h"
#include "ip_nat.h"
#include "ip_frag.h"
#include "ip_state.h"
d113 2
a114 1
extern	kmutex_t	ipf_nat;
d139 1
a139 1
u_long n;
d142 1
a142 1
	register u_long sum1;
d158 1
a158 1
u_long n;
d161 1
a161 1
	register u_long sum1;
d212 1
a212 1
	register ipnat_t *nat, *n = NULL, **np = NULL;
d220 3
d228 1
a228 1
	MUTEX_ENTER(&ipf_nat);
a229 1
		IRCOPY(data, (char *)&natd, sizeof(natd));
d250 2
a251 1
		KMALLOC(n, ipnat_t *, sizeof(*n));
d283 2
a284 1
		nat_stats.ns_rules++;
d289 1
d301 1
a301 1
			nat_stats.ns_rules--;
d306 1
d309 1
d319 1
d335 1
d344 1
d349 1
d355 1
a355 1
	MUTEX_EXIT(&ipf_nat);
d357 2
d392 1
a392 1
		ipn->in_space++;
d450 1
a450 1
			nat_stats.ns_rules--;
d478 1
a478 1
	in.s_addr = ill->ill_ipif->ipif_local_addr;
d519 2
a520 1
	if (!sin)
d522 1
d543 1
a543 1
	register u_long sum1, sum2, sumd, l;
d719 3
a721 3
	nat_stats.ns_added++;
	nat_stats.ns_inuse++;
	np->in_use++;
d801 1
a801 1
		u_long	sum1, sum2, sumd;
d986 1
a986 1
	register u_long ipa;
d1014 1
a1014 1
	MUTEX_ENTER(&ipf_nat);
d1021 3
a1023 1
	else
d1053 2
d1059 2
a1061 1
			ip->ip_src = nat->nat_outip;
d1064 1
d1085 1
d1096 1
d1117 2
a1118 2
			nat_stats.ns_mapped[1]++;
			MUTEX_EXIT(&ipf_nat);
d1121 1
a1121 1
	MUTEX_EXIT(&ipf_nat);
d1157 1
a1157 1
	MUTEX_ENTER(&ipf_nat);
d1167 3
a1169 1
	else
d1189 2
d1194 1
a1199 1
			ip->ip_dst = nat->nat_inip;
d1202 2
d1223 1
d1234 1
d1254 2
a1255 2
			nat_stats.ns_mapped[0]++;
			MUTEX_EXIT(&ipf_nat);
d1258 1
a1258 1
	MUTEX_EXIT(&ipf_nat);
d1268 1
a1268 1
	MUTEX_ENTER(&ipf_nat);
d1272 1
a1272 1
	MUTEX_EXIT(&ipf_nat);
d1288 1
a1288 1
	MUTEX_ENTER(&ipf_nat);
d1290 2
a1291 1
		if (--nat->nat_age) {
d1300 1
a1300 1
		nat_stats.ns_expire++;
d1305 1
a1305 1
	MUTEX_EXIT(&ipf_nat);
d1320 1
a1320 1
	register u_long sum1, sum2, sumd;
d1328 1
a1328 1
	MUTEX_ENTER(&ipf_nat);
d1362 1
a1362 1
	MUTEX_EXIT(&ipf_nat);
@


1.14
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*       $OpenBSD$       */
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 1.13 1998/01/26 04:10:43 dgregor Exp $";
d501 1
a501 2
	if (!sin) {
		KFREE(nat);
a502 1
	}
@


1.13
log
@IPF 3.2.3
@
text
@d1 1
d13 1
a13 1
static const char rcsid[] = "@@(#)$Id: ip_nat.c,v 2.0.2.44.2.7 1997/12/02 13:54:27 darrenr Exp $";
@


1.12
log
@merge in 3.1.11
@
text
@a0 1
/*	$OpenBSD: ip_nat.c,v 1.11 1997/04/18 06:10:07 niklas Exp $	*/
d2 1
a2 1
 * (C)opyright 1995-1996 by Darren Reed.
a8 1
 *
d10 3
a12 4
#if 0
#if !defined(lint) && defined(LIBC_SCCS)
static	char	sccsid[] = "@@(#)ip_nat.c	1.11 6/5/96 (C) 1995 Darren Reed";
static	char	rcsid[] = "$DRId: ip_nat.c,v 2.0.1.14 1997/04/22 12:47:39 darrenr Exp $";
d14 3
d25 1
a25 3
#ifndef __OpenBSD__
# include <sys/types.h>
#endif
d27 1
d29 7
a35 1
#include <sys/ioctl.h>
d37 3
a39 1
#include <sys/protosw.h>
d41 1
a41 1
#ifdef	_KERNEL
d45 3
a47 1
# include <sys/mbuf.h>
d49 1
d55 3
a57 1

d59 3
d70 7
d83 3
a85 1
#include <netinet/ip_var.h>
a87 1
#include <netinet/tcpip.h>
d90 1
d92 1
d94 1
d99 2
d104 2
a105 2
u_long	nat_inuse = 0,
	fr_defnatage = 1200;
d107 1
a107 6
#if	SOLARIS
# ifndef	_KERNEL
#define	bzero(a,b)	memset(a,0,b)
#define	bcmp(a,b,c)	memcpy(a,b,c)
#define	bcopy(a,b,c)	memmove(b,a,c)
# else
a108 1
# endif
d111 23
a133 12
static	int	flush_nattable __P((void)), clear_natlist __P((void));
static	void	nattable_sync __P((void)), nat_delete __P((struct nat *));
void		fix_incksum __P((u_short *, u_long));
void		fix_outcksum __P((u_short *, u_long));
nat_t		*nat_new __P((ipnat_t *, ip_t *, fr_info_t *, u_short, int));
nat_t		*nat_lookupmapip __P((register int, struct in_addr, u_short,
			struct in_addr, u_short));

void
fix_outcksum(sp, n)
	u_short *sp;
	u_long n;
d138 2
a139 3
#ifdef sparc
	sum1 = (~(*sp)) & 0xffff;
#else
a140 1
#endif
d150 3
a152 4
void
fix_incksum(sp, n)
	u_short *sp;
	u_long n;
d157 2
d197 8
a204 5
int
nat_ioctl(data, cmd, mode)
	caddr_t data;
	u_long cmd;
	int mode;
d208 6
a213 1
	int error = 0, ret, s;
d218 1
a219 1
	SPLNET(s);
d242 2
a243 1
		if (!(n = (ipnat_t *)KMALLOC(sizeof(*n)))) {
d249 3
d259 1
a259 1
		if (n->in_outmsk != 0xffffffff)
d263 1
a263 1
		if (n->in_redir == NAT_MAP) {
d274 1
d286 9
a294 3

		KFREE(n);
		nattable_sync();
a299 1
		nat_stats.ns_inuse = nat_inuse;
d308 1
a308 1
		if (nat_lookupredir(&nl))
d310 1
a310 1
		else
d319 2
a320 1
		ret = flush_nattable();
d328 1
a328 1
		ret = clear_natlist();
d331 6
a337 1
	SPLX(s);
d339 1
d344 5
a348 3
static void
nat_delete(natd)
	struct nat *natd;
d351 1
d367 14
a380 3
	if (natd->nat_ptr) {
		natd->nat_ptr->in_space++;
		natd->nat_ptr->in_use--;
d382 6
a388 1
	nat_inuse--;
d393 1
a393 1
 * flush_nattable - clear the NAT table of all mapping entries.
d395 1
a395 2
static int
flush_nattable()
d418 1
a418 1
 * I know this is O(N*M), but it can't be avoided.
d420 1
a420 2
static void
nattable_sync()
d422 2
a423 3
	register nat_t *nat;
	register ipnat_t *np;
	int i;
d425 11
a435 11
	for (i = NAT_SIZE - 1; i >= 0; i--)
		for (nat = nat_instances; nat; nat = nat->nat_next) {
			for (np = nat_list; np; np = np->in_next)
				if (nat->nat_ptr == np)
					break;
			/*
			 * XXX - is it better to remove this if ? works the
			 * same if it is just "nat->nat_ptr = np".
			 */
			if (!np)
				nat->nat_ptr = NULL;
d437 3
d444 1
a444 1
 * clear_natlist - delete all entries in the active NAT mapping list.
d446 4
a449 2
static int
clear_natlist()
d451 6
a456 2
	register ipnat_t *n, **np;
	int i = 0;
d458 45
a502 3
	for (np = &nat_list; (n = *np); i++) {
		*np = n->in_next;
		KFREE(n);
d504 7
a510 3

	nattable_sync();
	return i;
d517 6
a522 7
nat_t *
nat_new(np, ip, fin, flags, direction)
	ipnat_t *np;
	ip_t *ip;
	fr_info_t *fin;
	u_short flags;
	int direction;
d524 1
a524 1
	register u_long sum1, sum2, sumd;
d539 2
a540 1
	if (!(nat = (nat_t *)KMALLOC(sizeof(*nat))))
d554 1
d556 1
d559 15
a573 1
			if (nflags & IPN_TCPUDP) {
d591 2
a592 1
		} while (nat_inlookup(flags, ip->ip_dst, dport, in, port));
d689 4
a692 1
	np->in_use++;
d695 1
a695 1
			tcp->th_sport = htons(port);
d698 1
a698 1
			tcp->th_dport = htons(nport);
d701 128
a828 1
	nat_inuse++;
d843 9
a851 5
nat_t *
nat_inlookup(flags, src, sport, mapdst, mapdport)
	register int flags;
	struct in_addr src, mapdst;
	u_short sport, mapdport;
d859 2
a860 1
		if (nat->nat_oip.s_addr == src.s_addr &&
d876 9
a884 5
nat_t *
nat_outlookup(flags, src, sport, dst, dport)
	register int flags;
	struct in_addr src, dst;
	u_short sport, dport;
d891 3
a893 2
	for (; nat; nat = nat->nat_hnext[0])
		if (nat->nat_inip.s_addr == src.s_addr &&
d895 1
a895 1
		    (!flags || flags & nat->nat_flags) && (!flags ||
d898 1
d908 9
a916 5
nat_t *
nat_lookupmapip(flags, mapsrc, mapsport, dst, dport)
	register int flags;
	struct in_addr mapsrc, dst;
	u_short mapsport, dport;
d924 1
a924 1
		if (nat->nat_outip.s_addr == mapsrc.s_addr &&
d926 1
d938 2
a939 3
nat_t *
nat_lookupredir(np)
	register natlookup_t *np;
d947 5
a951 4
	if ((nat = nat_outlookup(IPN_TCPUDP, np->nl_inip, np->nl_inport,
				 np->nl_outip, np->nl_outport))) {
		np->nl_inip = nat->nat_outip;
		np->nl_inport = nat->nat_outport;
d961 4
a964 5
int
ip_natout(ip, hlen, fin)
	ip_t *ip;
	int hlen;
	fr_info_t *fin;
a968 1
	nat_t *nat;
d972 2
d996 18
a1013 13
	for (np = nat_list; np; np = np->in_next)
		if ((np->in_ifp == ifp) && np->in_space &&
		    (!np->in_flags || (np->in_flags & nflags)) &&
		    ((ipa & np->in_inmsk) == np->in_inip) &&
		    ((np->in_redir == NAT_MAP) ||
		     (np->in_pnext == sport))) {
			/*
			 * If there is no current entry in the nat table for
			 * this IP#, create one for it.
			 */
			if (!(nat = nat_outlookup(nflags, ip->ip_src, sport,
						  ip->ip_dst, dport))) {
				if (np->in_redir == NAT_REDIRECT)
d1016 2
a1017 2
				 * if it's a redirection, then we don't want
				 * to create new outgoing port stuff.
d1021 3
a1023 1
				if (!(nat = nat_new(np, ip, fin, nflags,
d1025 6
a1030 1
					break;
d1032 5
d1038 2
a1039 2

			nat->nat_age = fr_defnatage;	/* 5 mins */
d1045 2
a1046 2
#if SOLARIS
			if (np->in_redir == NAT_MAP)
d1060 10
a1069 2
					set_tcp_age(&nat->nat_age,
						    nat->nat_state, ip, fin,1);
d1081 1
a1081 1
					if (np->in_redir == NAT_MAP)
d1089 1
d1092 1
a1092 1
			return 1;
d1103 4
a1106 5
int
ip_natin(ip, hlen, fin)
	ip_t *ip;
	int hlen;
	fr_info_t *fin;
d1112 1
a1112 1
	u_short sport = 0, dport = 0, nflags = 0, *csump = NULL;
d1114 1
d1131 28
a1158 21
	for (np = nat_list; np; np = np->in_next)
		if ((np->in_ifp == ifp) &&
		    (!np->in_flags || (nflags & np->in_flags)) &&
		    ((in.s_addr & np->in_outmsk) == np->in_outip) &&
		    (np->in_redir == NAT_MAP || np->in_pmin == dport)) {
			if (!(nat = nat_inlookup(nflags, ip->ip_src, sport,
						 ip->ip_dst, dport))) {
				if (np->in_redir == NAT_MAP)
					continue;
				else {
					/*
					 * If this rule (np) is a redirection,
					 * rather than a mapping, then do a
					 * nat_new. Otherwise, if it's just a
					 * mapping, do a continue;
					 */
					if (!(nat = nat_new(np, ip, fin,
							    nflags,
							    NAT_INBOUND)))
						break;
				}
d1160 8
d1169 2
a1170 2

			nat->nat_age = fr_defnatage;
d1176 2
a1177 2
#if SOLARIS
			if (np->in_redir == NAT_MAP)
d1182 1
a1182 1
			if (nflags && !(ip->ip_off & 0x1fff) &&
d1190 10
a1199 2
					set_tcp_age(&nat->nat_age,
						    nat->nat_state, ip, fin,0);
d1211 1
a1211 1
					if (np->in_redir == NAT_MAP)
d1221 1
a1221 1
			return 1;
d1231 1
a1231 2
void
ip_natunload()
a1232 2
	int s;

d1234 3
a1236 4
	SPLNET(s);
	(void) clear_natlist();
	(void) flush_nattable();
	SPLX(s)
d1245 1
a1245 2
void
ip_natexpire()
d1248 1
d1250 1
d1252 1
a1253 1
	SPLNET(s);
d1260 3
d1266 60
a1325 1
	SPLX(s);
d1327 41
d1369 1
@


1.11
log
@Use the right types on 64-bit machines
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.10 1997/02/13 18:13:31 kstailey Exp $	*/
d15 1
a15 1
static	char	rcsid[] = "Id: ip_nat.c,v 2.0.1.10 1997/02/08 06:38:49 darrenr Exp";
d173 1
a173 1
	int error = 0, ret;
d179 1
d183 2
d206 1
a206 1
		IRCOPY((char *)data, (char *)n, sizeof(*n));
d281 1
d416 1
d582 3
a584 2
		    (!flags || (nat->nat_oport == sport &&
		     nat->nat_outport == mapdport)))
d610 2
a611 2
		    (!flags || (nat->nat_inport == sport &&
		     nat->nat_oport == dport)))
d636 3
a638 2
		    (!flags || (nat->nat_outport == mapsport &&
		     nat->nat_oport == dport)))
d894 1
d897 1
a897 1

d900 1
a900 1

@


1.10
log
@prevent free()ed object from being referenced
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.9 1997/02/12 15:16:02 kstailey Exp $	*/
d168 2
a169 1
	int cmd, mode;
@


1.9
log
@protect ip_natexpire
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.c,v 1.8 1997/02/11 22:23:25 kstailey Exp $	*/
d25 3
a27 1
#include <sys/types.h>
d908 3
a910 2
	for (natp = &nat_instances; (nat = *natp); natp = &nat->nat_next) {
		if (--nat->nat_age)
d912 1
@


1.8
log
@IPF 1.3.7
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d902 1
d905 1
d913 1
@


1.7
log
@syslog.h -> sys/syslog.h

THIS IS THE KERNEL, DAMNIT.
@
text
@d1 1
d3 1
a3 1
 * (C)opyright 1995 by Darren Reed.
d9 1
a9 14
 *  Added redirect stuff and a LOT of bug fixes. (mcn@@EnGarde.com)
 *
 * Things still screwed:
 *  1) You can't specify a mapping to a class D address. By default, it
 *     always adds 1 to that address. As a result, when a packet comes back,
 *     the rule won't be matched. (e.g. outgoing address = 199.165.219.2,
 *     whereas the rule says outgoing address = 199.165.219.1/32. Because
 *     ADNATS always adds one, and there really isn't any provision for
 *     only using 1 address (the in_space stuff is broke), there isn't any
 *     easy solution)
 *  2) There needs to be a way to flush the NATs table completely. Either
 *     an ioctl, or an easy way of doing it from ipnat.c.
 *
 * Missing from RFC 1631: ICMP header checksum recalculations.
d13 1
a13 1
#ifndef	lint
d15 1
a15 1
static	char	rcsid[] = "$OpenBSD: ip_nat.c,v 1.6 1996/10/24 17:56:22 tholo Exp $";
a26 3
#if defined(_KERNEL) || defined(KERNEL)
#include <sys/systm.h>
#endif
d32 3
a35 5
# if defined(__OpenBSD__)
#  include <sys/dirent.h>
# else
#  include <sys/dir.h>
# endif
d52 7
a63 1
#include <sys/syslog.h>
d67 1
d72 1
a72 1
nat_t	*nat_table[2][NAT_SIZE];
d74 2
a75 1
u_long	nat_inuse = 0;
d79 1
d87 51
a137 3
int	flush_nattable __P((void));
int	clear_natlist __P((void));
nat_t	*nat_new __P((ipnat_t *, ip_t *, int, u_short, int));
d168 1
a168 1
	register ipnat_t *nat, *n, **np;
d177 1
a177 1
		IRCOPY(data, &natd, sizeof(natd));
d180 1
a180 1
			if (!bcmp((char *)&nat->in_port, (char *)&n->in_port,
d203 1
d205 5
a209 2
		n->in_space -= 2; /* lose 2: broadcast + network address */
		if (n->in_inmsk != 0xffffffff)
d213 1
a213 1
		if (n->in_redir == NAT_MAP)
d215 7
d235 1
d237 1
d240 2
a241 1
		nat_stats.ns_table = (nat_t ***)nat_table;
a248 1
		nat_t	*na;
d251 2
a252 3
		if ((na = nat_lookupredir(&nl))) {
			nl.nl_inip = na->nat_outip;
			nl.nl_inport = na->nat_outport;
d254 1
a254 1
		} else
d280 29
d312 1
a312 1
int
d315 19
a333 2
	nat_t *nat, **natp;
	int i, j = 0;
d335 9
a343 6
	for (natp = &nat_table[0][0], i = NAT_SIZE - 1; i >= 0; i--, natp++)
		while ((nat = *natp)) {
			*natp = nat->nat_next;
			KFREE((caddr_t)nat);
			j++;
		}
d345 11
a355 5
	for (natp = &nat_table[1][0], i = NAT_SIZE - 1; i >= 0; i--, natp++)
		while ((nat = *natp)) {
			*natp = nat->nat_next;
			KFREE((caddr_t)nat);
			j++;
a356 1
	return j;
d363 1
a363 1
int
d373 2
d383 1
a383 1
nat_new(np, ip, hlen, flags, direction)
d386 1
a386 1
	int hlen;
d393 1
a393 1
	tcphdr_t *tcp;
d395 1
d397 3
a399 2
	if (flags) {
		tcp = (tcphdr_t *)((char *)ip + hlen);
d408 2
d419 1
d421 1
a421 1
			if (np->in_flags & IPN_TCPUDP) {
d429 1
a429 1
			} else {
d431 1
a431 2
				if (np->in_outmsk != 0xffffffff)
					np->in_nip++;
d433 3
d437 1
a437 1
					ntohl(np->in_outip))
d439 1
a439 1
		} while (nat_lookupinip(in, sport));
a441 1
		nat->nat_use = 0;
d444 1
a448 4
		/* Do it twice */
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);

d451 1
a451 11
		/* Do it twice */
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);

		if (sum1 > sum2)
			sum2--; /* Because ~1 == -2, We really need ~1 == -1 */
		sumd = sum2 - sum1;
		sumd = (sumd & 0xffff) + (sumd >> 16);
		nat->nat_sumd = (sumd & 0xffff) + (sumd >> 16);

		if (sport) {
d454 1
a454 3
		} else {
			nat->nat_inport = 0;
			nat->nat_outport = 0;
d465 2
a466 1
		nport = np->in_pnext;
a467 1
		nat->nat_use = 0;
d475 33
a511 2
		sum2 = (in.s_addr & 0xffff) + (in.s_addr >> 16) + ntohs(nport);

d516 3
a518 3
		if (sum2 > sum1)
			sum1--; /* Because ~1 == -2, We really need ~1 == -1 */
		sumd = (sum1 - sum2);
d520 3
a522 11
		nat->nat_sumd = (sumd & 0xffff) + (sumd >> 16);

		if (dport) {
			nat->nat_inport = nport;
			nat->nat_outport = dport;
			nat->nat_oport = sport;
		} else {
			nat->nat_inport = 0;
			nat->nat_outport = 0;
		}
	}
d525 2
d528 2
a529 1
	nat->nat_next = *natp;
a530 1
	nat->nat_use++;
d532 2
a533 1
	nat->nat_next = *natp;
d535 4
a538 4
	nat->nat_use++;
	if (direction == NAT_REDIRECT) {
		ip->ip_src = in;
		if (flags)
d541 1
a541 2
		ip->ip_dst = in;
		if (flags)
a543 1

d554 6
d561 15
a575 11
nat_lookupredir(np)
	natlookup_t *np;
{
	nat_t *nat;

	nat = nat_table[0][np->nl_inip.s_addr % NAT_SIZE];
	for (; nat; nat = nat->nat_next)
		if ((nat->nat_inip.s_addr == np->nl_inip.s_addr) &&
		    (nat->nat_oip.s_addr == np->nl_outip.s_addr) &&
		    (np->nl_inport == nat->nat_inport) &&
		    (np->nl_outport == nat->nat_oport))
d581 6
d588 18
a605 5
nat_lookupinip(ipaddr, sport)
	struct in_addr ipaddr;
	u_short sport;
{
	nat_t *nat;
a606 1
	nat = nat_table[0][ipaddr.s_addr % NAT_SIZE];
d608 21
a628 4
	for (; nat; nat = nat->nat_next)
		if (nat->nat_inip.s_addr == ipaddr.s_addr) {
			if (nat->nat_inport && (sport != nat->nat_inport))
				continue;
a629 1
		}
d634 3
d638 2
a639 4
nat_lookupoutip(np, ip, tcp)
	register ipnat_t *np;
	ip_t *ip;
	tcphdr_t *tcp;
a640 2
	struct in_addr ipaddr;
	u_short	port = tcp->th_dport;
d643 10
a652 16
	ipaddr.s_addr = ip->ip_dst.s_addr;
	nat = nat_table[1][ipaddr.s_addr % NAT_SIZE];

	if (np->in_redir == NAT_MAP) {
		for (; nat; nat = nat->nat_next)
			if (nat->nat_outip.s_addr == ipaddr.s_addr &&
			    (!nat->nat_outport || (port == nat->nat_outport)))
				return nat;
	} else
		for (; nat; nat = nat->nat_next)
			if (nat->nat_outip.s_addr == ipaddr.s_addr &&
			    nat->nat_oip.s_addr == ip->ip_src.s_addr &&
			    port == nat->nat_outport &&
			    tcp->th_sport == nat->nat_oport)
				return nat;
	return NULL;
d660 1
a660 1
void
d668 1
a668 2
	register u_long sum1;
	tcphdr_t *tcp;
d670 9
a678 2
	u_short nflags = 0, sport = 0;
	struct ifnet *ifp = fin->fin_ifp;
d685 5
a689 4
	}
	if (nflags) {
		tcp = (tcphdr_t *)fin->fin_dp;
		sport = tcp->th_sport;
d699 2
a700 2
		    (np->in_redir == NAT_MAP ||
		     np->in_pnext == sport)) {
d705 2
a706 1
			if (!(nat = nat_lookupinip(ip->ip_src, sport))) {
d715 1
a715 2
				if (!(nat = nat_new(np, ip, hlen,
						    nflags & np->in_flags,
d718 2
a719 2
			} else
				ip->ip_src = nat->nat_outip;
d721 1
a721 1
			nat->nat_age = 1200;	/* 5 mins */
d727 7
a735 2
				u_short *sp;
				u_short sumshort;
d741 3
a743 12
					sp = &tcp->th_sum;

					sum1 = (~ntohs(*sp)) & 0xffff;

					sum1 += nat->nat_sumd;

					sum1 = (sum1 >> 16) + (sum1 & 0xffff);
					/* Again */
					sum1 = (sum1 >> 16) + (sum1 & 0xffff);
					sumshort = ~(u_short)sum1;
					*sp = htons(sumshort);

d747 4
a750 1
					sp = &udp->uh_sum;
d752 9
a760 11
					if (udp->uh_sum) {
						sum1 = (~ntohs(*sp)) & 0xffff;
						sum1 += nat->nat_sumd;
						sum1 = (sum1 >> 16) +
						       (sum1 & 0xffff);
						/* Again */
						sum1 = (sum1 >> 16) +
						       (sum1 & 0xffff);
						sumshort = ~(u_short)sum1;
						*sp = htons(sumshort);
					}
d765 1
a765 1
			return;
d768 1
a768 1
	return;
d776 1
a776 1
void
a783 1
	register u_long sum1;
d785 2
a786 2
	tcphdr_t *tcp;
	u_short port = 0, nflags;
d794 5
a798 4
	}
	if (nflags) {
		tcp = (tcphdr_t *)((char *)ip + hlen);
		port = tcp->th_dport;
d808 3
a810 2
		    (np->in_redir == NAT_MAP || np->in_pmin == port)) {
			if (!(nat = nat_lookupoutip(np, ip, tcp))) {
d820 1
a820 2
					nflags &= np->in_flags;
					if (!(nat = nat_new(np, ip, hlen,
d826 1
a826 1
			nat->nat_age = 1200;
d828 1
a828 1
			ip->ip_dst = nat->nat_inip;
d834 6
a841 2
				u_short	*sp;
				u_short sumshort;
d847 3
a849 9
					sp = &tcp->th_sum;

					sum1 = (~ntohs(*sp)) & 0xffff;
					sum1 += ~nat->nat_sumd & 0xffff;
					sum1 = (sum1 >> 16) + (sum1 & 0xffff);
					/* Again */
					sum1 = (sum1 >> 16) + (sum1 & 0xffff);
					sumshort = ~(u_short)sum1;
					*sp = htons(sumshort);
d853 4
a856 1
					sp = &udp->uh_sum;
d858 9
a866 11
					if (udp->uh_sum) {
						sum1 = (~ntohs(*sp)) & 0xffff;
						sum1+= ~nat->nat_sumd & 0xffff;
						sum1 = (sum1 >> 16) +
						       (sum1 & 0xffff);
						/* Again */
						sum1 = (sum1 >> 16) +
						       (sum1 & 0xffff);
						sumshort = ~(u_short)sum1;
						*sp = htons(sumshort);
					}
d871 1
a871 1
			return;
d874 1
a874 1
	return;
a883 3
	register struct nat *nat, **natp;
	register struct ipnat *ipn, **ipnp;
	register int i;
d886 4
a889 17
	for (i = 0; i < NAT_SIZE; i++)
		for (natp = &nat_table[0][i]; (nat = *natp); ) {
			*natp = nat->nat_next;
			if (!--nat->nat_use)
				KFREE(nat);
		}
	for (i = 0; i < NAT_SIZE; i++)
		for (natp = &nat_table[1][i]; (nat = *natp); ) {
			*natp = nat->nat_next;
			if (!--nat->nat_use)
				KFREE(nat);
		}

	for (ipnp = &nat_list; (ipn = *ipnp); ) {
		*ipnp = ipn->in_next;
		KFREE(ipn);
	}
a901 1
	register int i;
d904 7
a910 33
	for (i = 0; i < NAT_SIZE; i++)
		for (natp = &nat_table[0][i]; (nat = *natp); ) {
			if (nat->nat_age > 0)
				nat->nat_age--;
			if (!nat->nat_use || !nat->nat_age) {
				*natp = nat->nat_next;
				if (nat->nat_use)
					nat->nat_use--;
				if (!nat->nat_use) {
					KFREE(nat);
					nat_stats.ns_expire++;
					nat_inuse--;
				}
			} else
				natp = &nat->nat_next;
		}

	for (i = 0; i < NAT_SIZE; i++)
		for (natp = &nat_table[1][i]; (nat = *natp); ) {
			if (nat->nat_age > 0)
				nat->nat_age--;
			if (!nat->nat_use || !nat->nat_age) {
				*natp = nat->nat_next;
				if (nat->nat_use)
					nat->nat_use--;
				if (!nat->nat_use) {
					KFREE(nat);
					nat_stats.ns_expire++;
					nat_inuse--;
				}
			} else
				natp = &nat->nat_next;
		}
@


1.6
log
@<sys/dir.h> is for use as a compatibility interface only.  Warn if
included by kernel modules, and also remove use from any modules that
currently attempt to use it.
@
text
@d27 1
a27 1
static	char	rcsid[] = "$OpenBSD: ip_nat.c,v 1.5 1996/10/08 07:33:28 niklas Exp $";
d74 1
a74 1
#include <syslog.h>
@


1.5
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d27 1
a27 1
static	char	rcsid[] = "$OpenBSD: ip_nat.c,v 1.4 1996/07/18 05:01:05 dm Exp $";
d48 5
a52 1
# include <sys/dir.h>
@


1.4
log
@ipfilter 3.1.0
@
text
@d24 1
d27 2
a28 1
static	char	rcsid[] = "$Id: ip_nat.c,v 1.2 1996/07/04 13:17:33 darrenr Exp $";
d39 3
d71 1
a72 1
#include "ip_fil_compat.h"
d91 3
d119 4
a122 3
int nat_ioctl(data, cmd, mode)
caddr_t data;
int cmd, mode;
d227 2
a228 1
int flush_nattable()
d253 2
a254 1
int clear_natlist()
d270 7
a276 6
nat_t *nat_new(np, ip, hlen, flags, direction)
ipnat_t *np;
ip_t *ip;
int hlen;
u_short flags;
int direction;
d427 3
a429 2
nat_t *nat_lookupredir(np)
natlookup_t *np;
d444 4
a447 3
nat_t *nat_lookupinip(ipaddr, sport)
struct in_addr ipaddr;
u_short sport;
d463 5
a467 4
nat_t *nat_lookupoutip(np, ip, tcp)
register ipnat_t *np;
ip_t *ip;
tcphdr_t *tcp;
d496 5
a500 4
void ip_natout(ip, hlen, fin)
ip_t *ip;
int hlen;
fr_info_t *fin;
d608 5
a612 4
void ip_natin(ip, hlen, fin)
ip_t *ip;
int hlen;
fr_info_t *fin;
d714 2
a715 1
void ip_natunload()
d747 2
a748 1
void ip_natexpire()
@


1.3
log
@fix return-rst
@
text
@d20 3
d25 2
a26 1
static	char	sccsid[] = "@@(#)ip_nat.c	1.9 4/10/96 (C) 1995 Darren Reed";
d67 1
d111 1
a111 1
int nat_ioctl(data, cmd)
d113 1
a113 1
int cmd;
d116 2
a117 1
	int error = 0;
d124 2
a125 1
		nat = (ipnat_t *)data;
d135 4
d162 4
a182 3
#if !SOLARIS && defined(_KERNEL)
		int	s;
#endif
a183 1
		SPLNET(s);
a190 1
		SPLX(s);
d193 16
d216 41
a258 1

a280 1

@


1.2
log
@ipfilter 3.0.4
@
text
@a211 2
	MUTEX_ENTER(&ipf_nat);

d213 1
a213 2
	if (!(nat = (nat_t *)KMALLOC(sizeof(*nat)))) {
		MUTEX_EXIT(&ipf_nat);
d215 1
a215 1
	}
a341 1
	MUTEX_EXIT(&ipf_nat);
@


1.1
log
@IP filter 3.0.1
@
text
@d7 13
d22 1
a22 1
static	char	sccsid[] = "@@(#)ip_nat.c	1.3 1/12/96 (C) 1995 Darren Reed";
d25 5
a29 2
#include <stdio.h>
#include <string.h>
d111 1
d121 1
a121 1
				  IPN_CMPSIZ))
d129 2
a130 2
			MUTEX_EXIT(&ipf_nat);
			return EEXIST;
d133 2
a134 2
			MUTEX_EXIT(&ipf_nat);
			return ENOMEM;
d136 1
a136 2
		IRCOPY((char *)data, (char *)np, sizeof(*np));
		bcopy((char *)nat, (char *)n, sizeof(*n));
d140 8
a147 3
		n->in_space--;	/* lose 1 for broadcast address */
		n->in_nip = ntohl(n->in_outip) + 1;
		n->in_pnext = ntohs(n->in_pmin);
d152 2
a153 2
			MUTEX_EXIT(&ipf_nat);
			return ESRCH;
d164 19
d185 1
a185 1
	return 0;
d192 3
a194 1
nat_t *nat_new(ip, hlen, flags)
d198 1
d200 2
a201 1
	u_short port = 0, sport = 0;
a203 1
	ipnat_t *np;
d209 1
d213 7
d223 16
a238 7
	do {
		in.s_addr = np->in_nip;
		if (np->in_flags & IPN_TCPUDP) {
			port = htons(np->in_pnext++);
			if (np->in_pnext >= ntohs(np->in_pmax)) {
				np->in_pnext = ntohs(np->in_pmin);
				np->in_nip++;
d240 2
d243 32
d276 2
a277 2
			np->in_space--;
			np->in_nip++;
d279 1
a279 3
		if ((np->in_nip & ntohl(np->in_outmsk)) > ntohl(np->in_outip))
			np->in_nip = ntohl(np->in_outip) + 1;
	} while (nat_lookupinip(in, sport));
d281 41
a321 3
	if (!(nat = (nat_t *)KMALLOC(sizeof(*nat)))) {
		MUTEX_EXIT(&ipf_nat);
		return NULL;
d323 1
a323 1
	nat->nat_use = 0;
a324 14
	nat->nat_inip = ip->ip_src;
	nat->nat_outip = in;
	nat->nat_sumd = (ntohl(ip->ip_src.s_addr) & 0xffff) +
			(ntohl(ip->ip_src.s_addr) >> 16);
	nat->nat_sumd -= ((ntohl(in.s_addr) & 0xffff) +
			  (ntohl(in.s_addr) >> 16));
	if (sport) {
		nat->nat_inport = sport;
		nat->nat_outport = port;
		nat->nat_sumd += (ntohs(sport) - ntohs(port));
	} else {
		nat->nat_inport = 0;
		nat->nat_outport = 0;
	}
d333 10
a342 3
	ip->ip_src = in;
	if (flags)
		tcp->th_sport = htons(port);
d350 21
a370 1
nat_t *nat_lookupoutip(ipaddr, sport)
d376 1
a376 1
	nat = nat_table[1][ipaddr.s_addr % NAT_SIZE];
a377 1
	MUTEX_ENTER(&ipf_nat);
d379 2
a380 2
		if (nat->nat_outip.s_addr == ipaddr.s_addr) {
			if (nat->nat_outport && (sport != nat->nat_outport))
d384 28
a411 1
	MUTEX_EXIT(&ipf_nat);
d420 1
a420 2
void ip_natout(ifp, ip, hlen)
struct ifnet *ifp;
d423 1
d427 1
a427 1
	register u_long sum1, sum2;
d431 1
d433 6
a438 4
	if (ip->ip_p == IPPROTO_TCP)
		nflags = IPN_TCP;
	else if (ip->ip_p == IPPROTO_UDP)
		nflags = IPN_UDP;
d440 1
a440 1
		tcp = (tcphdr_t *)((char *)ip + hlen);
d450 3
a452 1
		    ((ipa & np->in_inmsk) == np->in_inip)) {
d458 12
a469 5
				if (!(nat = nat_new(ip, hlen,
						    nflags & np->in_flags))) {
					MUTEX_EXIT(&ipf_nat);
					return;
				}
d479 6
a484 3
			if (nflags) {
				if (nat->nat_outport) {
					sum1 += sport;
a485 2
					sum2 += tcp->th_sport;
				}
d487 12
a498 1
				sum2 = nat->nat_sumd;
a499 5
				if (ip->ip_p == IPPROTO_TCP) {
					sum2 += ntohs(tcp->th_sum);
					sum2 = (sum2 >> 16) + (sum2 & 0xffff);
					sum2 += (sum2 >> 16);
					tcp->th_sum = htons(sum2);
d503 13
a515 1
					udp->uh_sum = 0;
a525 19
nat_t *nat_lookupinip(ipaddr, sport)
struct in_addr ipaddr;
u_short sport;
{
	nat_t *nat;

	nat = nat_table[0][ipaddr.s_addr % NAT_SIZE];

	MUTEX_ENTER(&ipf_nat);
	for (; nat; nat = nat->nat_next)
		if (nat->nat_inip.s_addr == ipaddr.s_addr) {
			if (nat->nat_inport && (sport != nat->nat_inport))
				continue;
			return nat;
		}
	MUTEX_EXIT(&ipf_nat);
	return NULL;
}

d531 1
a531 2
void ip_natin(ifp, ip, hlen)
struct ifnet *ifp;
d534 1
d538 2
a539 1
	register u_long sum1, sum2;
d544 6
a549 4
	if (ip->ip_p == IPPROTO_TCP)
		nflags = IPN_TCP;
	else if (ip->ip_p == IPPROTO_UDP)
		nflags = IPN_UDP;
d561 19
a579 3
		    ((in.s_addr & np->in_outmsk) == np->in_outip)) {
			if (!(nat = nat_lookupoutip(in, port)))
				continue;
d581 1
d588 4
d593 1
a593 5
			if (nflags) {
				u_short *sp = NULL;

				if (nat->nat_inport) {
					sum1 += port;
a594 4
					sum2 += tcp->th_dport;
				}

				sum2 = nat->nat_sumd;
d598 8
a605 6
					if (ntohs(*sp) > sum2)
						sum2--;
					sum2 -= ntohs(*sp);
					sum2 = (sum2 >> 16) + (sum2 & 0xffff);
					sum2 += (sum2 >> 16);
					*sp = htons(~sum2);
d609 13
a621 1
					udp->uh_sum = 0;
@
