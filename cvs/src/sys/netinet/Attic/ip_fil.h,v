head	1.25;
access;
symbols
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	UBC_SYNC_A:1.25
	UBC_SYNC_B:1.25
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	SMP:1.15.0.2
	SMP_BASE:1.15
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.25
date	2001.05.30.02.12.29;	author deraadt;	state dead;
branches;
next	1.24;

1.24
date	2001.05.08.19.58.01;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.06.17.29.30;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.30.04.23.56;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.17.04.47.13;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.24.21.59.11;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.10.20.40.53;	author deraadt;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2000.04.05.05.35.27;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.13.23.40.17;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.16.22.34.18;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.01.19.29.58;	author kjell;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	99.12.28.08.20.40;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	99.12.15.05.20.21;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	99.02.05.05.58.50;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.09.15.09.51.18;	author pattonme;	state Exp;
branches;
next	1.10;

1.10
date	98.02.17.01.39.02;	author dgregor;	state Exp;
branches;
next	1.9;

1.9
date	98.01.26.04.10.39;	author dgregor;	state Exp;
branches;
next	1.8;

1.8
date	97.02.11.22.23.16;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.02.05.00.53.12;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.10.08.07.33.26;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.09.30.14.06.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.18.05.00.59;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.21.38.16;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.25.05.41.43;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.02.34.03;	author dm;	state Exp;
branches;
next	;

1.15.2.1
date	2000.02.20.11.57.24;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2000.03.24.09.09.36;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.05.14.22.40.10;	author niklas;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2001.07.04.10.54.44;	author niklas;	state dead;
branches;
next	;

1.19.2.1
date	2000.05.27.20.45.17;	author jason;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ip_fil.h,v 1.24 2001/05/08 19:58:01 fgsch Exp $	*/

/*
 * Copyright (C) 1993-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 *
 * @@(#)ip_fil.h	1.35 6/5/96
 * $IPFilter: ip_fil.h,v 2.29.2.5 2001/03/20 13:18:05 darrenr Exp $
 */

#ifndef	__IP_FIL_H__
#define	__IP_FIL_H__

/*
 * Pathnames for various IP Filter control devices.  Used by LKM
 * and userland, so defined here.
 */
#define	IPNAT_NAME	"/dev/ipnat"
#define	IPSTATE_NAME	"/dev/ipstate"
#define	IPAUTH_NAME	"/dev/ipauth"

#ifndef	SOLARIS
# define SOLARIS (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
#endif

#if defined(KERNEL) && !defined(_KERNEL)
# define	_KERNEL
#endif

#ifndef	__P
# ifdef	__STDC__
#  define	__P(x)	x
# else
#  define	__P(x)	()
# endif
#endif

#if defined(__STDC__) || defined(__GNUC__)
# define	SIOCADAFR	_IOW('r', 60, struct frentry *)
# define	SIOCRMAFR	_IOW('r', 61, struct frentry *)
# define	SIOCSETFF	_IOW('r', 62, u_int)
# define	SIOCGETFF	_IOR('r', 63, u_int)
# define	SIOCGETFS	_IOWR('r', 64, struct friostat *)
# define	SIOCIPFFL	_IOWR('r', 65, int)
# define	SIOCIPFFB	_IOR('r', 66, int)
# define	SIOCADIFR	_IOW('r', 67, struct frentry *)
# define	SIOCRMIFR	_IOW('r', 68, struct frentry *)
# define	SIOCSWAPA	_IOR('r', 69, u_int)
# define	SIOCINAFR	_IOW('r', 70, struct frentry *)
# define	SIOCINIFR	_IOW('r', 71, struct frentry *)
# define	SIOCFRENB	_IOW('r', 72, u_int)
# define	SIOCFRSYN	_IOW('r', 73, u_int)
# define	SIOCFRZST	_IOWR('r', 74, struct friostat *)
# define	SIOCZRLST	_IOWR('r', 75, struct frentry *)
# define	SIOCAUTHW	_IOWR('r', 76, struct fr_info *)
# define	SIOCAUTHR	_IOWR('r', 77, struct fr_info *)
# define	SIOCATHST	_IOWR('r', 78, struct fr_authstat *)
# define	SIOCSTLCK	_IOWR('r', 79, u_int)
# define	SIOCSTPUT	_IOWR('r', 80, struct ipstate_save *)
# define	SIOCSTGET	_IOWR('r', 81, struct ipstate_save *)
# define	SIOCSTGSZ	_IOWR('r', 82, struct natget)
# define	SIOCGFRST	_IOWR('r', 83, struct ipfrstat *)
#else
# define	SIOCADAFR	_IOW(r, 60, struct frentry *)
# define	SIOCRMAFR	_IOW(r, 61, struct frentry *)
# define	SIOCSETFF	_IOW(r, 62, u_int)
# define	SIOCGETFF	_IOR(r, 63, u_int)
# define	SIOCGETFS	_IOWR(r, 64, struct friostat *)
# define	SIOCIPFFL	_IOWR(r, 65, int)
# define	SIOCIPFFB	_IOR(r, 66, int)
# define	SIOCADIFR	_IOW(r, 67, struct frentry *)
# define	SIOCRMIFR	_IOW(r, 68, struct frentry *)
# define	SIOCSWAPA	_IOR(r, 69, u_int)
# define	SIOCINAFR	_IOW(r, 70, struct frentry *)
# define	SIOCINIFR	_IOW(r, 71, struct frentry *)
# define	SIOCFRENB	_IOW(r, 72, u_int)
# define	SIOCFRSYN	_IOW(r, 73, u_int)
# define	SIOCFRZST	_IOWR(r, 74, struct friostat *)
# define	SIOCZRLST	_IOWR(r, 75, struct frentry *)
# define	SIOCAUTHW	_IOWR(r, 76, struct fr_info *)
# define	SIOCAUTHR	_IOWR(r, 77, struct fr_info *)
# define	SIOCATHST	_IOWR(r, 78, struct fr_authstat *)
# define	SIOCSTLCK	_IOWR(r, 79, u_int)
# define	SIOCSTPUT	_IOWR(r, 80, struct ipstate_save *)
# define	SIOCSTGET	_IOWR(r, 81, struct ipstate_save *)
# define	SIOCSTGSZ	_IOWR(r, 82, struct natget)
# define	SIOCGFRST	_IOWR(r, 83, struct ipfrstat *)
#endif
#define	SIOCADDFR	SIOCADAFR
#define	SIOCDELFR	SIOCRMAFR
#define	SIOCINSFR	SIOCINAFR


typedef	struct	fr_ip	{
	u_32_t	fi_v:4;		/* IP version */
	u_32_t	fi_fl:4;	/* packet flags */
	u_32_t	fi_tos:8;	/* IP packet TOS */
	u_32_t	fi_ttl:8;	/* IP packet TTL */
	u_32_t	fi_p:8;		/* IP packet protocol */
	union	i6addr fi_src;	/* source address from packet */
	union	i6addr fi_dst;	/* destination address from packet */
	u_32_t	fi_optmsk;	/* bitmask composed from IP options */
	u_short	fi_secmsk;	/* bitmask composed from IP security options */
	u_short	fi_auth;	/* authentication code from IP sec. options */
} fr_ip_t;

#define	FI_OPTIONS	(FF_OPTIONS >> 24)
#define	FI_TCPUDP	(FF_TCPUDP >> 24)	/* TCP/UCP implied comparison*/
#define	FI_FRAG		(FF_FRAG >> 24)
#define	FI_SHORT	(FF_SHORT >> 24)
#define	FI_CMP		(FI_OPTIONS|FI_TCPUDP|FI_SHORT)

#define	fi_saddr	fi_src.in4.s_addr
#define	fi_daddr	fi_dst.in4.s_addr


/*
 * These are both used by the state and NAT code to indicate that one port or
 * the other should be treated as a wildcard.
 */
#define	FI_W_SPORT	0x00000100
#define	FI_W_DPORT	0x00000200
#define	FI_WILDP	(FI_W_SPORT|FI_W_DPORT)
#define	FI_W_SADDR	0x00000400
#define	FI_W_DADDR	0x00000800
#define	FI_WILDA	(FI_W_SADDR|FI_W_DADDR)
#define	FI_NEWFR	0x00001000

typedef	struct	fr_info	{
	void	*fin_ifp;		/* interface packet is `on' */
	struct	fr_ip	fin_fi;		/* IP Packet summary */
	u_short	fin_data[2];		/* TCP/UDP ports, ICMP code/type */
	u_char	fin_out;		/* in or out ? 1 == out, 0 == in */
	u_char	fin_rev;		/* state only: 1 = reverse */
	u_short	fin_hlen;		/* length of IP header in bytes */
	u_char	fin_tcpf;		/* TCP header flags (SYN, ACK, etc) */
	/* From here on is packet specific */
	u_char	fin_icode;		/* ICMP error to return */
	u_short	fin_rule;		/* rule # last matched */
	u_32_t	fin_group;		/* group number, -1 for none */
	struct	frentry *fin_fr;	/* last matching rule */
	char	*fin_dp;		/* start of data past IP header */
	u_short	fin_dlen;		/* length of data portion of packet */
	u_short	fin_id;			/* IP packet id field */
	void	*fin_mp;		/* pointer to pointer to mbuf */
#if SOLARIS
	void	*fin_qfm;		/* pointer to mblk where pkt starts */
	void	*fin_qif;
#endif
	u_short	fin_plen;
	u_short	fin_off;
} fr_info_t;

#define	fin_v	fin_fi.fi_v

/*
 * Size for compares on fr_info structures
 */
#define	FI_CSIZE	offsetof(fr_info_t, fin_icode)

/*
 * Size for copying cache fr_info structure
 */
#define	FI_COPYSIZE	offsetof(fr_info_t, fin_dp)

typedef	struct	frdest	{
	void	*fd_ifp;
	struct	in_addr	fd_ip;
	char	fd_ifname[IFNAMSIZ];
} frdest_t;

typedef	struct	frpcmp	{
	int	frp_cmp;	/* data for port comparisons */
	u_short	frp_port;	/* top port for <> and >< */
	u_short	frp_top;	/* top port for <> and >< */
} frpcmp_t;

typedef	struct	frtuc	{
	u_char	ftu_tcpfm;	/* tcp flags mask */
	u_char	ftu_tcpf;	/* tcp flags */
	frpcmp_t	ftu_src;
	frpcmp_t	ftu_dst;
} frtuc_t;

#define	ftu_scmp	ftu_src.frp_cmp
#define	ftu_dcmp	ftu_dst.frp_cmp
#define	ftu_sport	ftu_src.frp_port
#define	ftu_dport	ftu_dst.frp_port
#define	ftu_stop	ftu_src.frp_top
#define	ftu_dtop	ftu_dst.frp_top

typedef	struct	frentry {
	struct	frentry	*fr_next;
	u_32_t	fr_group;	/* group to which this rule belongs */
	u_32_t	fr_grhead;	/* group # which this rule starts */
	struct	frentry	*fr_grp;
	int	fr_ref;		/* reference count - for grouping */
	void	*fr_ifa;
#if BSD >= 199306
	void	*fr_oifa;
#endif
	/*
	 * These are only incremented when a packet  matches this rule and
	 * it is the last match
	 */
	U_QUAD_T	fr_hits;
	U_QUAD_T	fr_bytes;
	/*
	 * Fields after this may not change whilst in the kernel.
	 */
	struct	fr_ip	fr_ip;
	struct	fr_ip	fr_mip;	/* mask structure */


	u_short	fr_icmpm;	/* data for ICMP packets (mask) */
	u_short	fr_icmp;

	frtuc_t	fr_tuc;
	u_32_t	fr_flags;	/* per-rule flags && options (see below) */
	u_int	fr_skip;	/* # of rules to skip */
	u_int	fr_loglevel;	/* syslog log facility + priority */
	int	(*fr_func) __P((int, ip_t *, fr_info_t *));	/* call this function */
	int	fr_sap;		/* For solaris only */
	u_char	fr_icode;	/* return ICMP code */
	char	fr_ifname[IFNAMSIZ];
#if BSD >= 199306
	char	fr_oifname[IFNAMSIZ];
#endif
	struct	frdest	fr_tif;	/* "to" interface */
	struct	frdest	fr_dif;	/* duplicate packet interfaces */
	u_int	fr_cksum;	/* checksum on filter rules for performance */
} frentry_t;

#define	fr_v		fr_ip.fi_v
#define	fr_proto	fr_ip.fi_p
#define	fr_ttl		fr_ip.fi_ttl
#define	fr_tos		fr_ip.fi_tos
#define	fr_tcpfm	fr_tuc.ftu_tcpfm
#define	fr_tcpf		fr_tuc.ftu_tcpf
#define	fr_scmp		fr_tuc.ftu_scmp
#define	fr_dcmp		fr_tuc.ftu_dcmp
#define	fr_dport	fr_tuc.ftu_dport
#define	fr_sport	fr_tuc.ftu_sport
#define	fr_stop		fr_tuc.ftu_stop
#define	fr_dtop		fr_tuc.ftu_dtop
#define	fr_dst		fr_ip.fi_dst.in4
#define	fr_src		fr_ip.fi_src.in4
#define	fr_dmsk		fr_mip.fi_dst.in4
#define	fr_smsk		fr_mip.fi_src.in4

#ifndef	offsetof
#define	offsetof(t,m)	(int)((&((t *)0L)->m))
#endif
#define	FR_CMPSIZ	(sizeof(struct frentry) - offsetof(frentry_t, fr_ip))

/*
 * fr_flags
 */
#define	FR_BLOCK	0x00001	/* do not allow packet to pass */
#define	FR_PASS		0x00002	/* allow packet to pass */
#define	FR_OUTQUE	0x00004	/* outgoing packets */
#define	FR_INQUE	0x00008	/* ingoing packets */
#define	FR_LOG		0x00010	/* Log */
#define	FR_LOGB		0x00011	/* Log-fail */
#define	FR_LOGP		0x00012	/* Log-pass */
#define	FR_LOGBODY	0x00020	/* Log the body */
#define	FR_LOGFIRST	0x00040	/* Log the first byte if state held */
#define	FR_RETRST	0x00080	/* Return TCP RST packet - reset connection */
#define	FR_RETICMP	0x00100	/* Return ICMP unreachable packet */
#define	FR_FAKEICMP	0x00180	/* Return ICMP unreachable with fake source */
#define	FR_NOMATCH	0x00200	/* no match occured */
#define	FR_ACCOUNT	0x00400	/* count packet bytes */
#define	FR_KEEPFRAG	0x00800	/* keep fragment information */
#define	FR_KEEPSTATE	0x01000	/* keep `connection' state information */
#define	FR_INACTIVE	0x02000
#define	FR_QUICK	0x04000	/* match & stop processing list */
#define	FR_FASTROUTE	0x08000	/* bypass normal routing */
#define	FR_CALLNOW	0x10000	/* call another function (fr_func) if matches */
#define	FR_DUP		0x20000	/* duplicate packet */
#define	FR_LOGORBLOCK	0x40000	/* block the packet if it can't be logged */
#define	FR_NOTSRCIP	0x80000	/* not the src IP# */
#define	FR_NOTDSTIP	0x100000	/* not the dst IP# */
#define	FR_AUTH		0x200000	/* use authentication */
#define	FR_PREAUTH	0x400000	/* require preauthentication */
#define	FR_DONTCACHE	0x800000	/* don't cache the result */

#define	FR_LOGMASK	(FR_LOG|FR_LOGP|FR_LOGB)
#define	FR_RETMASK	(FR_RETICMP|FR_RETRST|FR_FAKEICMP)

/*
 * These correspond to #define's for FI_* and are stored in fr_flags
 */
#define	FF_OPTIONS	0x01000000
#define	FF_TCPUDP	0x02000000
#define	FF_FRAG		0x04000000
#define	FF_SHORT	0x08000000
/*
 * recognized flags for SIOCGETFF and SIOCSETFF, and get put in fr_flags
 */
#define	FF_LOGPASS	0x10000000
#define	FF_LOGBLOCK	0x20000000
#define	FF_LOGNOMATCH	0x40000000
#define	FF_LOGGING	(FF_LOGPASS|FF_LOGBLOCK|FF_LOGNOMATCH)
#define	FF_BLOCKNONIP	0x80000000	/* Solaris2 Only */

#define	FR_NONE 0
#define	FR_EQUAL 1
#define	FR_NEQUAL 2
#define FR_LESST 3
#define FR_GREATERT 4
#define FR_LESSTE 5
#define FR_GREATERTE 6
#define	FR_OUTRANGE 7
#define	FR_INRANGE 8

typedef	struct	filterstats {
	u_long	fr_pass;	/* packets allowed */
	u_long	fr_block;	/* packets denied */
	u_long	fr_nom;		/* packets which don't match any rule */
	u_long	fr_short;	/* packets which are short */
	u_long	fr_ppkl;	/* packets allowed and logged */
	u_long	fr_bpkl;	/* packets denied and logged */
	u_long	fr_npkl;	/* packets unmatched and logged */
	u_long	fr_pkl;		/* packets logged */
	u_long	fr_skip;	/* packets to be logged but buffer full */
	u_long	fr_ret;		/* packets for which a return is sent */
	u_long	fr_acct;	/* packets for which counting was performed */
	u_long	fr_bnfr;	/* bad attempts to allocate fragment state */
	u_long	fr_nfr;		/* new fragment state kept */
	u_long	fr_cfr;		/* add new fragment state but complete pkt */
	u_long	fr_bads;	/* bad attempts to allocate packet state */
	u_long	fr_ads;		/* new packet state kept */
	u_long	fr_chit;	/* cached hit */
	u_long	fr_tcpbad;	/* TCP checksum check failures */
	u_long	fr_pull[2];	/* good and bad pullup attempts */
	u_long	fr_badsrc;	/* source received doesn't match route */
	u_long	fr_badttl;	/* TTL in packet doesn't reach minimum */
#if SOLARIS
	u_long	fr_notdata;	/* PROTO/PCPROTO that have no data */
	u_long	fr_nodata;	/* mblks that have no data */
	u_long	fr_bad;		/* bad IP packets to the filter */
	u_long	fr_notip;	/* packets passed through no on ip queue */
	u_long	fr_drop;	/* packets dropped - no info for them! */
	u_long	fr_copy;	/* messages copied due to db_ref > 1 */
#endif
	u_long	fr_ipv6[2];	/* IPv6 packets in/out */
} filterstats_t;

/*
 * For SIOCGETFS
 */
typedef	struct	friostat	{
	struct	filterstats	f_st[2];
	struct	frentry		*f_fin[2];
	struct	frentry		*f_fout[2];
	struct	frentry		*f_acctin[2];
	struct	frentry		*f_acctout[2];
	struct	frentry		*f_fin6[2];
	struct	frentry		*f_fout6[2];
	struct	frentry		*f_acctin6[2];
	struct	frentry		*f_acctout6[2];
	struct	frentry		*f_auth;
	struct	frgroup		*f_groups[3][2];
	u_long	f_froute[2];
	int	f_defpass;	/* default pass - from fr_pass */
	char	f_active;	/* 1 or 0 - active rule set */
	char	f_running;	/* 1 if running, else 0 */
	char	f_logging;	/* 1 if enabled, else 0 */
	char	f_version[32];	/* version string */
	int	f_locks[4];
} friostat_t;

typedef struct	optlist {
	u_short ol_val;
	int	ol_bit;
} optlist_t;


/*
 * Group list structure.
 */
typedef	struct frgroup {
	u_32_t	fg_num;
	struct	frgroup	*fg_next;
	struct	frentry	*fg_head;
	struct	frentry	**fg_start;
} frgroup_t;


/*
 * Log structure.  Each packet header logged is prepended by one of these.
 * Following this in the log records read from the device will be an ipflog
 * structure which is then followed by any packet data.
 */
typedef	struct	iplog	{
	u_32_t	ipl_magic;
	u_int	ipl_count;
	u_long	ipl_sec;
	u_long	ipl_usec;
	size_t	ipl_dsize;
	struct	iplog	*ipl_next;
} iplog_t;

#define IPL_MAGIC 0x49504c4d /* 'IPLM' */

typedef	struct	ipflog	{
#if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199603)) || \
        (defined(OpenBSD) && (OpenBSD >= 199603))
	u_char	fl_ifname[IFNAMSIZ];
#else
	u_int	fl_unit;
	u_char	fl_ifname[4];
#endif
	u_char	fl_plen;	/* extra data after hlen */
	u_char	fl_hlen;	/* length of IP headers saved */
	u_short	fl_loglevel;	/* syslog log level */
	u_32_t	fl_rule;
	u_32_t	fl_group;
	u_32_t	fl_flags;
	u_32_t	fl_lflags;
} ipflog_t;


#ifndef	ICMP_UNREACH_FILTER
# define	ICMP_UNREACH_FILTER	13
#endif

#ifndef	IPF_LOGGING
# define	IPF_LOGGING	0
#endif
#ifndef	IPF_DEFAULT_PASS
# define	IPF_DEFAULT_PASS	FR_PASS
#endif

#define	IPMINLEN(i, h)	((i)->ip_len >= ((i)->ip_hl * 4 + sizeof(struct h)))
#define	IPLLOGSIZE	8192

/*
 * Device filenames for reading log information.  Use ipf on Solaris2 because
 * ipl is already a name used by something else.
 */
#ifndef	IPL_NAME
# if	SOLARIS
#  define	IPL_NAME	"/dev/ipf"
# else
#  define	IPL_NAME	"/dev/ipl"
# endif
#endif
#define	IPL_NAT		IPNAT_NAME
#define	IPL_STATE	IPSTATE_NAME
#define	IPL_AUTH	IPAUTH_NAME

#define	IPL_LOGIPF	0	/* Minor device #'s for accessing logs */
#define	IPL_LOGNAT	1
#define	IPL_LOGSTATE	2
#define	IPL_LOGAUTH	3
#define	IPL_LOGMAX	3

#if !defined(CDEV_MAJOR) && defined (__FreeBSD_version) && \
    (__FreeBSD_version >= 220000)
# define	CDEV_MAJOR	79
#endif

/*
 * Post NetBSD 1.2 has the PFIL interface for packet filters.  This turns
 * on those hooks.  We don't need any special mods in non-IP Filter code
 * with this!
 */
#if (defined(NetBSD) && (NetBSD > 199609) && (NetBSD <= 1991011)) || \
    (defined(NetBSD1_2) && NetBSD1_2 > 1)
# if (NetBSD >= 199905)
#  define PFIL_HOOKS
# endif
# ifdef PFIL_HOOKS
#  define NETBSD_PF
# endif
#endif


#ifndef	_KERNEL
extern	int	fr_check __P((ip_t *, int, void *, int, mb_t **));
extern	int	(*fr_checkp) __P((ip_t *, int, void *, int, mb_t **));
extern	int	send_reset __P((ip_t *, struct ifnet *));
extern	int	icmp_error __P((ip_t *, struct ifnet *));
extern	int	ipf_log __P((void));
extern	int	ipfr_fastroute __P((ip_t *, fr_info_t *, frdest_t *));
extern	struct	ifnet *get_unit __P((char *, int));
# if defined(__NetBSD__) || defined(__OpenBSD__) || \
	  (_BSDI_VERSION >= 199701) || (__FreeBSD_version >= 300000)
extern	int	iplioctl __P((dev_t, u_long, caddr_t, int));
# else
extern	int	iplioctl __P((dev_t, int, caddr_t, int));
# endif
extern	int	iplopen __P((dev_t, int));
extern	int	iplclose __P((dev_t, int));
#else /* #ifndef _KERNEL */
# if defined(__NetBSD__) && defined(PFIL_HOOKS)
extern	void	ipfilterattach __P((int));
# endif
extern	int	iplattach __P((void));
extern	int	ipl_enable __P((void));
extern	int	ipl_disable __P((void));
extern	void	ipflog_init __P((void));
extern	int	ipflog_clear __P((minor_t));
extern	int	ipflog_read __P((minor_t, struct uio *));
extern	int	ipflog __P((u_int, ip_t *, fr_info_t *, mb_t *));
extern	int	ipllog __P((int, fr_info_t *, void **, size_t *, int *, int));
extern	int	send_icmp_err __P((ip_t *, int, fr_info_t *, int));
extern	int	send_reset __P((ip_t *, fr_info_t *));
# if	SOLARIS
extern	int	fr_check __P((ip_t *, int, void *, int, qif_t *, mb_t **));
extern	int	(*fr_checkp) __P((ip_t *, int, void *,
				  int, qif_t *, mb_t **));
#  if SOLARIS2 >= 7
extern	int	iplioctl __P((dev_t, int, intptr_t, int, cred_t *, int *));
#  else
extern	int	iplioctl __P((dev_t, int, int *, int, cred_t *, int *));
#  endif
extern	int	iplopen __P((dev_t *, int, int, cred_t *));
extern	int	iplclose __P((dev_t, int, int, cred_t *));
extern	int	ipfsync __P((void));
extern	int	ipfr_fastroute __P((ip_t *, mblk_t *, mblk_t **,
				    fr_info_t *, frdest_t *));
extern	void	copyin_mblk __P((mblk_t *, size_t, size_t, char *));
extern	void	copyout_mblk __P((mblk_t *, size_t, size_t, char *));
extern	int	fr_qin __P((queue_t *, mblk_t *));
extern	int	fr_qout __P((queue_t *, mblk_t *));
extern	int	iplread __P((dev_t, struct uio *, cred_t *));
# else /* SOLARIS */
extern	int	fr_check __P((ip_t *, int, void *, int, mb_t **));
extern	int	(*fr_checkp) __P((ip_t *, int, void *, int, mb_t **));
extern	int	ipfr_fastroute __P((mb_t *, fr_info_t *, frdest_t *));
extern	size_t	mbufchainlen __P((mb_t *));
#  ifdef	__sgi
#   include <sys/cred.h>
extern	int	iplioctl __P((dev_t, int, caddr_t, int, cred_t *, int *));
extern	int	iplopen __P((dev_t *, int, int, cred_t *));
extern	int	iplclose __P((dev_t, int, int, cred_t *));
extern	int	iplread __P((dev_t, struct uio *, cred_t *));
extern	int	ipfsync __P((void));
extern	int	ipfilter_sgi_attach __P((void));
extern	void	ipfilter_sgi_detach __P((void));
extern	void	ipfilter_sgi_intfsync __P((void));
#  else
#   ifdef	IPFILTER_LKM
extern	int	iplidentify __P((char *));
#   endif
#   if (_BSDI_VERSION >= 199510) || (__FreeBSD_version >= 220000) || \
      (NetBSD >= 199511) || defined(__OpenBSD__)
#    if defined(__NetBSD__) || (_BSDI_VERSION >= 199701) || \
       defined(__OpenBSD__) || (__FreeBSD_version >= 300000)
extern	int	iplioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
#    else
extern	int	iplioctl __P((dev_t, int, caddr_t, int, struct proc *));
#    endif
extern	int	iplopen __P((dev_t, int, int, struct proc *));
extern	int	iplclose __P((dev_t, int, int, struct proc *));
#   else
#    ifndef	linux
extern	int	iplopen __P((dev_t, int));
extern	int	iplclose __P((dev_t, int));
extern	int	iplioctl __P((dev_t, int, caddr_t, int));
#    else
extern	int	iplioctl(struct inode *, struct file *, u_int, u_long);
extern	int	iplopen __P((struct inode *, struct file *));
extern	void	iplclose __P((struct inode *, struct file *));
#    endif /* !linux */
#   endif /* (_BSDI_VERSION >= 199510) */
#   if	BSD >= 199306
extern	int	iplread __P((dev_t, struct uio *, int));
#   else
#    ifndef linux
extern	int	iplread __P((dev_t, struct uio *));
#    else
extern	int	iplread(struct inode *, struct file *, char *, int);
#    endif /* !linux */
#   endif /* BSD >= 199306 */
#  endif /* __ sgi */
# endif /* SOLARIS */
#endif /* #ifndef _KERNEL */

extern	char	*memstr __P((char *, char *, int, int));
extern	void	fixskip __P((frentry_t **, frentry_t *, int));
extern	int	countbits __P((u_32_t));
extern	int	ipldetach __P((void));
extern	u_short	ipf_cksum __P((u_short *, int));
extern	int	ircopyptr __P((void *, void *, size_t));
extern	int	iwcopyptr __P((void *, void *, size_t));

extern	int	frflush __P((minor_t, int));
extern	void	frsync __P((void));
extern	frgroup_t *fr_addgroup __P((u_32_t, frentry_t *, minor_t, int));
extern	void	fr_delgroup __P((u_32_t, u_32_t, minor_t, int));
extern	frgroup_t *fr_findgroup __P((u_32_t, u_32_t, minor_t, int,
				    frgroup_t ***));

extern	int	fr_copytolog __P((int, char *, int));
extern	void	fr_forgetifp __P((void *));
extern	void	fr_getstat __P((struct friostat *));
extern	int	fr_ifpaddr __P((int, void *, struct in_addr *));
extern	int	fr_lock __P((caddr_t, int *));
extern  void	fr_makefrip __P((int, ip_t *, fr_info_t *));
extern	u_short	fr_tcpsum __P((mb_t *, ip_t *, tcphdr_t *));
extern	int	fr_scanlist __P((u_32_t, ip_t *, fr_info_t *, void *));
extern	int	fr_tcpudpchk __P((frtuc_t *, fr_info_t *));
extern	int	fr_verifysrc __P((struct in_addr, void *));

extern	int	ipl_unreach;
extern	int	fr_running;
extern	u_long	ipl_frouteok[2];
extern	int	fr_pass;
extern	int	fr_flags;
extern	int	fr_active;
extern	int	fr_chksrc;
extern	int	fr_minttl;
extern	int	fr_minttllog;
extern	fr_info_t	frcache[2];
extern	char	ipfilter_version[];
extern	iplog_t	**iplh[IPL_LOGMAX+1], *iplt[IPL_LOGMAX+1];
extern	size_t	iplused[IPL_LOGMAX + 1];
extern	struct frentry *ipfilter[2][2], *ipacct[2][2];
#ifdef	USE_INET6
extern	struct frentry *ipfilter6[2][2], *ipacct6[2][2];
extern	int	icmptoicmp6types[ICMP_MAXTYPE+1];
extern	int	icmptoicmp6unreach[ICMP_MAX_UNREACH];
#endif
extern	struct frgroup *ipfgroups[3][2];
extern	struct filterstats frstats[];

#endif	/* __IP_FIL_H__ */
@


1.24
log
@IPfilter 3.4.17; kjell@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.23 2001/02/06 17:29:30 fgsch Exp $	*/
@


1.23
log
@ipf/ipnat check the securelevel in the original code, so don't do it twice.
Also remove uneeded definition of ICMP_UNREACH_FILTER_PROHIB; this isn't
needed. Why keep adding things to make diffs harder?
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.22 2001/01/30 04:23:56 kjell Exp $	*/
d11 1
a11 1
 * $IPFilter: ip_fil.h,v 2.29.2.4 2000/11/12 11:54:53 darrenr Exp $
d64 1
a64 1
# define	SIOCSTGSZ	_IOWR('r', 82, struct natget *)
d89 1
a89 1
# define	SIOCSTGSZ	_IOWR(r, 82, struct natget *)
d427 3
a429 3
# ifndef	ICMP_UNREACH_FILTER
#  define	ICMP_UNREACH_FILTER	13
# endif
@


1.22
log
@re-add local ipf changes that were whacked in the 3.4.16 merge. userland to follow
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.21 2001/01/17 04:47:13 fgsch Exp $	*/
a426 1
#if !defined(__OpenBSD__)
a429 1
#endif
@


1.21
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d427 4
a430 2
#ifndef	ICMP_UNREACH_FILTER
# define	ICMP_UNREACH_FILTER	13
@


1.20
log
@Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
  RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.19 2000/05/10 20:40:53 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d11 1
a11 1
 * $IPFilter: ip_fil.h,v 2.3.2.11 2000/05/22 06:57:50 darrenr Exp $
d42 2
a43 2
# define	SIOCADAFR	_IOW('r', 60, struct frentry)
# define	SIOCRMAFR	_IOW('r', 61, struct frentry)
d46 1
a46 1
# define	SIOCGETFS	_IOR('r', 64, struct friostat)
d49 2
a50 2
# define	SIOCADIFR	_IOW('r', 67, struct frentry)
# define	SIOCRMIFR	_IOW('r', 68, struct frentry)
d52 2
a53 2
# define	SIOCINAFR	_IOW('r', 70, struct frentry)
# define	SIOCINIFR	_IOW('r', 71, struct frentry)
d56 10
a65 5
# define	SIOCFRZST	_IOWR('r', 74, struct friostat)
# define	SIOCZRLST	_IOWR('r', 75, struct frentry)
# define	SIOCAUTHW	_IOWR('r', 76, struct fr_info)
# define	SIOCAUTHR	_IOWR('r', 77, struct fr_info)
# define	SIOCATHST	_IOWR('r', 78, struct fr_authstat)
d67 2
a68 2
# define	SIOCADAFR	_IOW(r, 60, struct frentry)
# define	SIOCRMAFR	_IOW(r, 61, struct frentry)
d71 1
a71 1
# define	SIOCGETFS	_IOR(r, 64, struct friostat)
d74 2
a75 2
# define	SIOCADIFR	_IOW(r, 67, struct frentry)
# define	SIOCRMIFR	_IOW(r, 68, struct frentry)
d77 2
a78 2
# define	SIOCINAFR	_IOW(r, 70, struct frentry)
# define	SIOCINIFR	_IOW(r, 71, struct frentry)
d81 10
a90 5
# define	SIOCFRZST	_IOWR(r, 74, struct friostat)
# define	SIOCZRLST	_IOWR(r, 75, struct frentry)
# define	SIOCAUTHW	_IOWR(r, 76, struct fr_info)
# define	SIOCAUTHR	_IOWR(r, 77, struct fr_info)
# define	SIOCATHST	_IOWR(r, 78, struct fr_authstat)
d96 1
d98 7
a104 7
	u_char	fi_v:4;		/* IP version */
	u_char	fi_fl:4;	/* packet flags */
	u_char	fi_tos;		/* IP packet TOS */
	u_char	fi_ttl;		/* IP packet TTL */
	u_char	fi_p;		/* IP packet protocol */
	struct	in_addr	fi_src;	/* source address from packet */
	struct	in_addr	fi_dst;	/* destination address from packet */
d116 4
d126 5
a130 1
#define	FI_WILD		(FI_W_SPORT|FI_W_DPORT)
d143 1
a143 1
	u_short	fin_group;		/* group number, -1 for none */
d149 1
a149 1
#if SOLARIS && defined(_KERNEL)
d153 2
d157 2
d175 20
d197 2
a198 2
	u_short	fr_group;	/* group to which this rule belongs */
	u_short	fr_grhead;	/* group # which this rule starts */
a216 2
	u_char	fr_tcpfm;	/* tcp flags mask */
	u_char	fr_tcpf;	/* tcp flags */
d221 1
a221 6
	u_char	fr_scmp;	/* data for port comparisons */
	u_char	fr_dcmp;
	u_short	fr_dport;
	u_short	fr_sport;
	u_short	fr_stop;	/* top port for <> and >< */
	u_short	fr_dtop;	/* top port for <> and >< */
d223 2
a224 2
	u_short	fr_skip;	/* # of rules to skip */
	u_short	fr_loglevel;	/* syslog log facility + priority */
d226 1
d234 1
d237 1
d241 12
a252 4
#define	fr_dst		fr_ip.fi_dst
#define	fr_src		fr_ip.fi_src
#define	fr_dmsk		fr_mip.fi_dst
#define	fr_smsk		fr_mip.fi_src
d339 2
d349 1
d361 4
a371 3
#if !SOLARIS && defined(sun)
	char	f_version[17];	/* version string */
#else
d373 1
a373 1
#endif
d386 1
a386 1
	u_short	fg_num;
a418 2
	u_short	fl_rule;	/* assume never more than 64k rules, total */
	u_short	fl_group;
d420 2
d427 2
a428 4
#if !defined(__OpenBSD__)
# ifndef	ICMP_UNREACH_FILTER
#  define	ICMP_UNREACH_FILTER	13
# endif
d490 1
a490 1
extern	struct	ifnet *get_unit __P((char *));
d511 1
a511 1
extern	int	send_icmp_err __P((ip_t *, int, fr_info_t *, struct in_addr));
d525 2
a526 2
extern	int	ipfr_fastroute __P((qif_t *, ip_t *, mblk_t *, mblk_t **,
				   fr_info_t *, frdest_t *));
a530 1
#  ifdef	IPFILTER_LOG
a531 1
#  endif
d585 1
a588 2
extern	u_short	fr_tcpsum __P((mb_t *, ip_t *, tcphdr_t *));
extern	int	fr_scanlist __P((u_32_t, ip_t *, fr_info_t *, void *));
d590 10
d602 3
a604 5
extern	int	frflush __P((minor_t, int));
extern	void	frsync __P((void));
extern	frgroup_t *fr_addgroup __P((u_int, frentry_t *, minor_t, int));
extern	frgroup_t *fr_findgroup __P((u_int, u_32_t, minor_t, int, frgroup_t ***));
extern	void	fr_delgroup __P((u_int, u_32_t, minor_t, int));
d606 5
a610 2
extern	int	fr_ifpaddr __P((void *, struct in_addr *));
extern	char	*memstr __P((char *, char *, int, int));
d617 3
a621 1
#ifdef	IPFILTER_LOG
d624 5
a629 1
extern	struct frentry *ipfilter[2][2], *ipacct[2][2];
@


1.19
log
@ipf 3.3.14, fixes an ipnat problem and ip option mishandling, which the bridge code cares about
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.18 2000/04/05 05:35:27 kjell Exp $	*/
d11 1
a11 1
 * $IPFilter: ip_fil.h,v 2.3.2.9 2000/03/08 11:43:30 darrenr Exp $
d462 2
a467 1
extern	int	icmp_error __P((ip_t *, int, int, qif_t *, struct in_addr));
a475 1
extern	int	send_reset __P((fr_info_t *, ip_t *, qif_t *));
a487 6
#  ifdef	linux
extern	int	send_reset __P((tcpiphdr_t *, struct ifnet *));
#  else
extern	int	send_reset __P((fr_info_t *, struct ip *));
extern	int	send_icmp_err __P((ip_t *, int, int, void *, struct in_addr));
#  endif
@


1.19.2.1
log
@Pull in patch from current:
Errata:
A misuse of ipf(8) keep-state rules can result in firewall rules being bypassed.
Fix (kjell):
Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.20 2000/05/24 21:59:11 kjell Exp $	*/
d11 1
a11 1
 * $IPFilter: ip_fil.h,v 2.3.2.11 2000/05/22 06:57:50 darrenr Exp $
a461 2
extern	int	send_icmp_err __P((ip_t *, int, fr_info_t *, struct in_addr));
extern	int	send_reset __P((ip_t *, fr_info_t *));
d466 1
d475 1
d488 6
@


1.18
log
@Update to ipf 3.3.12. Most fixes relate to hardening of
in-kernel ftp proxy. See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.17 2000/03/13 23:40:17 kjell Exp $	*/
d319 1
a319 1
	char	f_version[25];	/* version string */
@


1.17
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d11 1
a11 1
 * $IPFilter: ip_fil.h,v 2.3.2.8 2000/02/23 11:16:36 darrenr Exp $
d190 1
a190 1
	char	fr_icode;	/* return ICMP code */
@


1.16
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@d11 1
a11 1
 * $IPFilter: ip_fil.h,v 2.3.2.7 2000/01/27 08:49:41 darrenr Exp $
d298 1
@


1.15
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.15.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.16 2000/02/16 22:34:18 kjell Exp $	*/
@


1.15.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d11 1
a11 1
 * $IPFilter: ip_fil.h,v 2.3.2.8 2000/02/23 11:16:36 darrenr Exp $
a297 1
	u_long	fr_copy;	/* messages copied due to db_ref > 1 */
@


1.15.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.23 2001/02/06 17:29:30 fgsch Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-2000 by Darren Reed.
d11 1
a11 1
 * $IPFilter: ip_fil.h,v 2.29.2.4 2000/11/12 11:54:53 darrenr Exp $
d42 2
a43 2
# define	SIOCADAFR	_IOW('r', 60, struct frentry *)
# define	SIOCRMAFR	_IOW('r', 61, struct frentry *)
d46 1
a46 1
# define	SIOCGETFS	_IOWR('r', 64, struct friostat *)
d49 2
a50 2
# define	SIOCADIFR	_IOW('r', 67, struct frentry *)
# define	SIOCRMIFR	_IOW('r', 68, struct frentry *)
d52 2
a53 2
# define	SIOCINAFR	_IOW('r', 70, struct frentry *)
# define	SIOCINIFR	_IOW('r', 71, struct frentry *)
d56 5
a60 10
# define	SIOCFRZST	_IOWR('r', 74, struct friostat *)
# define	SIOCZRLST	_IOWR('r', 75, struct frentry *)
# define	SIOCAUTHW	_IOWR('r', 76, struct fr_info *)
# define	SIOCAUTHR	_IOWR('r', 77, struct fr_info *)
# define	SIOCATHST	_IOWR('r', 78, struct fr_authstat *)
# define	SIOCSTLCK	_IOWR('r', 79, u_int)
# define	SIOCSTPUT	_IOWR('r', 80, struct ipstate_save *)
# define	SIOCSTGET	_IOWR('r', 81, struct ipstate_save *)
# define	SIOCSTGSZ	_IOWR('r', 82, struct natget *)
# define	SIOCGFRST	_IOWR('r', 83, struct ipfrstat *)
d62 2
a63 2
# define	SIOCADAFR	_IOW(r, 60, struct frentry *)
# define	SIOCRMAFR	_IOW(r, 61, struct frentry *)
d66 1
a66 1
# define	SIOCGETFS	_IOWR(r, 64, struct friostat *)
d69 2
a70 2
# define	SIOCADIFR	_IOW(r, 67, struct frentry *)
# define	SIOCRMIFR	_IOW(r, 68, struct frentry *)
d72 2
a73 2
# define	SIOCINAFR	_IOW(r, 70, struct frentry *)
# define	SIOCINIFR	_IOW(r, 71, struct frentry *)
d76 5
a80 10
# define	SIOCFRZST	_IOWR(r, 74, struct friostat *)
# define	SIOCZRLST	_IOWR(r, 75, struct frentry *)
# define	SIOCAUTHW	_IOWR(r, 76, struct fr_info *)
# define	SIOCAUTHR	_IOWR(r, 77, struct fr_info *)
# define	SIOCATHST	_IOWR(r, 78, struct fr_authstat *)
# define	SIOCSTLCK	_IOWR(r, 79, u_int)
# define	SIOCSTPUT	_IOWR(r, 80, struct ipstate_save *)
# define	SIOCSTGET	_IOWR(r, 81, struct ipstate_save *)
# define	SIOCSTGSZ	_IOWR(r, 82, struct natget *)
# define	SIOCGFRST	_IOWR(r, 83, struct ipfrstat *)
a85 1

d87 7
a93 7
	u_32_t	fi_v:4;		/* IP version */
	u_32_t	fi_fl:4;	/* packet flags */
	u_32_t	fi_tos:8;	/* IP packet TOS */
	u_32_t	fi_ttl:8;	/* IP packet TTL */
	u_32_t	fi_p:8;		/* IP packet protocol */
	union	i6addr fi_src;	/* source address from packet */
	union	i6addr fi_dst;	/* destination address from packet */
a104 4
#define	fi_saddr	fi_src.in4.s_addr
#define	fi_daddr	fi_dst.in4.s_addr


d111 1
a111 5
#define	FI_WILDP	(FI_W_SPORT|FI_W_DPORT)
#define	FI_W_SADDR	0x00000400
#define	FI_W_DADDR	0x00000800
#define	FI_WILDA	(FI_W_SADDR|FI_W_DADDR)
#define	FI_NEWFR	0x00001000
d124 1
a124 1
	u_32_t	fin_group;		/* group number, -1 for none */
d130 1
a130 1
#if SOLARIS
a133 2
	u_short	fin_plen;
	u_short	fin_off;
a135 2
#define	fin_v	fin_fi.fi_v

a151 20
typedef	struct	frpcmp	{
	int	frp_cmp;	/* data for port comparisons */
	u_short	frp_port;	/* top port for <> and >< */
	u_short	frp_top;	/* top port for <> and >< */
} frpcmp_t;

typedef	struct	frtuc	{
	u_char	ftu_tcpfm;	/* tcp flags mask */
	u_char	ftu_tcpf;	/* tcp flags */
	frpcmp_t	ftu_src;
	frpcmp_t	ftu_dst;
} frtuc_t;

#define	ftu_scmp	ftu_src.frp_cmp
#define	ftu_dcmp	ftu_dst.frp_cmp
#define	ftu_sport	ftu_src.frp_port
#define	ftu_dport	ftu_dst.frp_port
#define	ftu_stop	ftu_src.frp_top
#define	ftu_dtop	ftu_dst.frp_top

d154 2
a155 2
	u_32_t	fr_group;	/* group to which this rule belongs */
	u_32_t	fr_grhead;	/* group # which this rule starts */
d174 2
d180 6
a185 1
	frtuc_t	fr_tuc;
d187 2
a188 2
	u_int	fr_skip;	/* # of rules to skip */
	u_int	fr_loglevel;	/* syslog log facility + priority */
d190 1
a190 2
	int	fr_sap;		/* For solaris only */
	u_char	fr_icode;	/* return ICMP code */
a196 1
	u_int	fr_cksum;	/* checksum on filter rules for performance */
a198 1
#define	fr_v		fr_ip.fi_v
d202 4
a205 12
#define	fr_tcpfm	fr_tuc.ftu_tcpfm
#define	fr_tcpf		fr_tuc.ftu_tcpf
#define	fr_scmp		fr_tuc.ftu_scmp
#define	fr_dcmp		fr_tuc.ftu_dcmp
#define	fr_dport	fr_tuc.ftu_dport
#define	fr_sport	fr_tuc.ftu_sport
#define	fr_stop		fr_tuc.ftu_stop
#define	fr_dtop		fr_tuc.ftu_dtop
#define	fr_dst		fr_ip.fi_dst.in4
#define	fr_src		fr_ip.fi_src.in4
#define	fr_dmsk		fr_mip.fi_dst.in4
#define	fr_smsk		fr_mip.fi_src.in4
a291 2
	u_long	fr_badsrc;	/* source received doesn't match route */
	u_long	fr_badttl;	/* TTL in packet doesn't reach minimum */
a299 1
	u_long	fr_ipv6[2];	/* IPv6 packets in/out */
a310 4
	struct	frentry		*f_fin6[2];
	struct	frentry		*f_fout6[2];
	struct	frentry		*f_acctin6[2];
	struct	frentry		*f_acctout6[2];
d318 3
d322 1
a322 1
	int	f_locks[4];
d335 1
a335 1
	u_32_t	fg_num;
d368 2
a370 2
	u_32_t	fl_rule;
	u_32_t	fl_group;
d376 1
d380 1
d441 1
a441 1
extern	struct	ifnet *get_unit __P((char *, int));
a461 2
extern	int	send_icmp_err __P((ip_t *, int, fr_info_t *, int));
extern	int	send_reset __P((ip_t *, fr_info_t *));
d466 1
d475 3
a477 2
extern	int	ipfr_fastroute __P((ip_t *, mblk_t *, mblk_t **,
				    fr_info_t *, frdest_t *));
d482 1
d484 1
d488 6
a543 1
extern	char	*memstr __P((char *, char *, int, int));
d547 2
d550 2
a551 3
extern	int	ircopyptr __P((void *, void *, size_t));
extern	int	iwcopyptr __P((void *, void *, size_t));

d554 3
a556 10
extern	frgroup_t *fr_addgroup __P((u_32_t, frentry_t *, minor_t, int));
extern	void	fr_delgroup __P((u_32_t, u_32_t, minor_t, int));
extern	frgroup_t *fr_findgroup __P((u_32_t, u_32_t, minor_t, int,
				    frgroup_t ***));

extern	int	fr_copytolog __P((int, char *, int));
extern	void	fr_forgetifp __P((void *));
extern	void	fr_getstat __P((struct friostat *));
extern	int	fr_ifpaddr __P((int, void *, struct in_addr *));
extern	int	fr_lock __P((caddr_t, int *));
d558 2
a559 5
extern	u_short	fr_tcpsum __P((mb_t *, ip_t *, tcphdr_t *));
extern	int	fr_scanlist __P((u_32_t, ip_t *, fr_info_t *, void *));
extern	int	fr_tcpudpchk __P((frtuc_t *, fr_info_t *));
extern	int	fr_verifysrc __P((struct in_addr, void *));

a565 3
extern	int	fr_chksrc;
extern	int	fr_minttl;
extern	int	fr_minttllog;
d568 1
d571 1
a572 5
#ifdef	USE_INET6
extern	struct frentry *ipfilter6[2][2], *ipacct6[2][2];
extern	int	icmptoicmp6types[ICMP_MAXTYPE+1];
extern	int	icmptoicmp6unreach[ICMP_MAX_UNREACH];
#endif
@


1.15.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil.h,v 1.15.2.3 2001/05/14 22:40:10 niklas Exp $	*/
@


1.14
log
@Update to ipfilter 3.3.6. See src/sbin/ipf/HISTORY for details.
@
text
@d1 2
a2 1
/* $OpenBSD: ip_fil.h,v 1.13 1999/12/15 05:20:21 kjell Exp $ */
d11 1
a11 1
 * $Id: ip_fil.h,v 1.13 1999/12/15 05:20:21 kjell Exp $
d276 1
a452 6

#if !defined(__OpenBSD__)
/*
 * OpenBSD has this call in the kernel but doesn't export it to userland.
 * See ip_fil.c for actual hook and more details.
 */
a453 2
#endif

d560 1
a560 1
extern	int	ipl_inited;
@


1.13
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d10 1
a10 1
 * $Id: ip_fil.h,v 2.3.2.5 1999/12/04 02:07:00 darrenr Exp $
a310 1
	int	f_active;	/* 1 or 0 - active rule set */
d312 6
a317 2
	int	f_running;	/* 1 if running, else 0 */
	int	f_logging;	/* 1 if enabled, else 0 */
d319 1
@


1.12
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_fil.h,v 1.11 1998/09/15 09:51:18 pattonme Exp $       */
d10 1
a10 1
 * $Id: ip_fil.h,v 1.11 1998/09/15 09:51:18 pattonme Exp $
a15 4
#if defined(__NetBSD__) && defined(PFIL_HOOKS)
#include "opt_pfil_hooks.h"
#endif

d25 1
a25 1
#define	SOLARIS	(defined(sun) && (defined(__svr4__) || defined(__SVR4)))
d29 1
a29 1
#define	_KERNEL
d41 19
a59 19
#define	SIOCADAFR	_IOW('r', 60, struct frentry)
#define	SIOCRMAFR	_IOW('r', 61, struct frentry)
#define	SIOCSETFF	_IOW('r', 62, u_int)
#define	SIOCGETFF	_IOR('r', 63, u_int)
#define	SIOCGETFS	_IOR('r', 64, struct friostat)
#define	SIOCIPFFL	_IOWR('r', 65, int)
#define	SIOCIPFFB	_IOR('r', 66, int)
#define	SIOCADIFR	_IOW('r', 67, struct frentry)
#define	SIOCRMIFR	_IOW('r', 68, struct frentry)
#define	SIOCSWAPA	_IOR('r', 69, u_int)
#define	SIOCINAFR	_IOW('r', 70, struct frentry)
#define	SIOCINIFR	_IOW('r', 71, struct frentry)
#define	SIOCFRENB	_IOW('r', 72, u_int)
#define	SIOCFRSYN	_IOW('r', 73, u_int)
#define	SIOCFRZST	_IOWR('r', 74, struct friostat)
#define	SIOCZRLST	_IOWR('r', 75, struct frentry)
#define	SIOCAUTHW	_IOWR('r', 76, struct fr_info)
#define	SIOCAUTHR	_IOWR('r', 77, struct fr_info)
#define	SIOCATHST	_IOWR('r', 78, struct fr_authstat)
d61 19
a79 19
#define	SIOCADAFR	_IOW(r, 60, struct frentry)
#define	SIOCRMAFR	_IOW(r, 61, struct frentry)
#define	SIOCSETFF	_IOW(r, 62, u_int)
#define	SIOCGETFF	_IOR(r, 63, u_int)
#define	SIOCGETFS	_IOR(r, 64, struct friostat)
#define	SIOCIPFFL	_IOWR(r, 65, int)
#define	SIOCIPFFB	_IOR(r, 66, int)
#define	SIOCADIFR	_IOW(r, 67, struct frentry)
#define	SIOCRMIFR	_IOW(r, 68, struct frentry)
#define	SIOCSWAPA	_IOR(r, 69, u_int)
#define	SIOCINAFR	_IOW(r, 70, struct frentry)
#define	SIOCINIFR	_IOW(r, 71, struct frentry)
#define SIOCFRENB	_IOW(r, 72, u_int)
#define	SIOCFRSYN	_IOW(r, 73, u_int)
#define	SIOCFRZST	_IOWR(r, 74, struct friostat)
#define	SIOCZRLST	_IOWR(r, 75, struct frentry)
#define	SIOCAUTHW	_IOWR(r, 76, struct fr_info)
#define	SIOCAUTHR	_IOWR(r, 77, struct fr_info)
#define	SIOCATHST	_IOWR(r, 78, struct fr_authstat)
d102 9
d113 1
d116 2
a117 1
	u_short	fin_out;		/* in or out ? 1 == out, 0 == in */
d124 2
a127 3
	void	*fin_ifp;		/* interface packet is `on' */
	struct	frentry *fin_fr;	/* last matching rule */
	char	*fin_dp;		/* start of data past IP header */
d131 1
d138 1
a138 1
#define       FI_CSIZE        offsetof(fr_info_t, fin_icode)
d158 3
d186 2
a187 1
	int	fr_skip;	/* # of rules to skip */
d191 3
d225 1
d240 1
d243 1
d309 1
d311 5
a315 1
	int	f_active;
d341 2
a342 1
	u_long	ipl_magic;
a344 2
	u_int	ipl_len;
	u_int	ipl_count;
d363 1
d365 1
a377 1

d411 16
d433 1
a433 1
extern	void	ipfr_fastroute __P((ip_t *, fr_info_t *, frdest_t *));
d435 2
a436 2
# define	FR_SCANLIST(p, ip, fi, m)	fr_scanlist(p, ip, fi, m)
# if defined(__NetBSD__) || defined(__OpenBSD__) || (_BSDI_VERSION >= 199701)
d445 1
a445 1
extern	int	ipfilterattach __P((int));
d459 2
a460 2
extern	int	ipflog_clear __P((int));
extern	int	ipflog_read __P((int, struct uio *));
d462 1
a462 1
extern	int	ipllog __P((int, u_long, void **, size_t *, int *, int));
d467 6
a472 3
extern	int	icmp_error __P((ip_t *, int, int, qif_t *,
				struct in_addr));
extern	int	iplioctl __P((dev_t, int, int, int, cred_t *, int *));
d476 1
a476 1
extern	int	send_reset __P((ip_t *, qif_t *));
d479 2
a480 2
extern	void	copyin_mblk __P((mblk_t *, int, int, char *));
extern	void	copyout_mblk __P((mblk_t *, int, int, char *));
d492 2
a493 1
extern	int	send_reset __P((tcpiphdr_t *));
d495 1
a495 1
extern	void	ipfr_fastroute __P((mb_t *, fr_info_t *, frdest_t *));
d513 2
a514 1
#    if defined(__NetBSD__) || (_BSDI_VERSION >= 199701) || defined(__OpenBSD__)
d516 1
a516 1
#    else /* FreeBSD v2.2+ or BSDI >= 199510 and < 199701 */
d518 1
a518 1
#    endif /* NetBSD, modern BSDI and OpenBSD */
d521 7
a527 3
#   else /* everybody else */
#     ifdef	linux
extern 	int	iplioctl(struct inode *, struct file *, u_int, u_long);
d530 1
a530 5
      else
extern	int	iplioctl __P((dev_t, int, caddr_t, int));
extern	int	iplopen __P((dev_t, int));
extern	int	iplclose __P((dev_t, int));
#     endif /* linux */
d535 3
a537 1
#    ifdef linux
d539 1
a539 3
     else
extern	int	iplread __P((dev_t, struct uio *));
#    endif /* linux */
d545 2
a546 10
/*
 * Post NetBSD 1.2 has the PFIL interface for packet filters.  This turns
 * on those hooks.  We don't need any special mods in non-IP Filter code
 * with this!
 */
#if (defined(NetBSD) && (NetBSD > 199609) && (NetBSD <= 1991011)) || \
    (defined(NetBSD1_2) && NetBSD1_2 > 1)
# define NETBSD_PF
#endif

d548 2
a549 3
extern	u_short	fr_tcpsum __P((mb_t *, ip_t *, tcphdr_t *, int));
#define	FR_SCANLIST(p, ip, fi, m)	fr_scanlist(p, ip, fi, m)
extern	int	fr_scanlist __P((int, ip_t *, fr_info_t *, void *));
d552 9
a560 4
extern	void	frflush __P((int, int *));
extern	frgroup_t *fr_addgroup __P((u_short, frentry_t *, int, int));
extern	frgroup_t *fr_findgroup __P((u_short, u_32_t, int, int, frgroup_t ***));
extern	void	fr_delgroup __P((u_short, u_32_t, int, int));
d568 1
d571 1
a571 1
extern	int	iplused[IPL_LOGMAX + 1];
@


1.11
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_fil.h,v 1.10 1998/02/17 01:39:02 dgregor Exp $       */
d3 1
a3 1
 * Copyright (C) 1993-1997 by Darren Reed.
d10 1
a10 1
 * $Id$
d16 4
d92 5
a96 5
	u_char	fi_tos;
	u_char	fi_ttl;
	u_char	fi_p;
	struct	in_addr	fi_src;
	struct	in_addr	fi_dst;
d99 1
a99 1
	u_short	fi_auth;
d108 13
a120 12
	struct	fr_ip	fin_fi;
	u_short	fin_data[2];
	u_short	fin_out;
	u_short	fin_hlen;
	u_char	fin_tcpf;
	u_char	fin_icode;		/* From here on is packet specific */
	u_short	fin_rule;
	u_short	fin_group;
	u_short	fin_dlen;
	u_short	fin_id;
	void	*fin_ifp;
	struct	frentry *fin_fr;
d122 1
a122 1
	void	*fin_mp;
d124 1
a124 1
	void	*fin_qfm;
d131 2
a132 2
#define	FI_CSIZE	(sizeof(struct fr_ip) + sizeof(u_short) * 4 + \
			 sizeof(u_char))
d136 1
a136 1
#define	FI_COPYSIZE	(sizeof(fr_info_t) - sizeof(void *) * 2)
d274 2
@


1.10
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*       $OpenBSD$       */
d10 1
a10 1
 * $Id: ip_fil.h,v 1.9 1998/01/26 04:10:39 dgregor Exp $
d118 3
d338 2
a339 5
# ifdef __OpenBSD__
# ifndef	ICMP_UNREACH_FILTER_PROHIB
#  define	ICMP_UNREACH_FILTER_PROHIB	13
# endif
#else
d346 1
a346 1
#define	IPF_LOGGING	0
d348 1
d350 1
a350 1
#define	IPF_DEFAULT_PASS	FR_PASS
a395 1
# ifdef __OpenBSD__
a397 3
# endif
extern  int     ipl_enable __P((void));
extern  int     ipl_disable __P((void));
d402 6
a407 1
# ifndef __OpenBSD__
d409 2
a410 1
# endif
d466 1
a466 1
#    else
d468 1
a468 1
#    endif
d471 6
a476 5
#   else
#    if defined(__OpenBSD__)
extern	int	iplioctl __P((dev_t, u_long, caddr_t, int));
#    else /* __OpenBSD__ */
#     ifndef	linux
a477 5
#     else
extern	int	iplioctl(struct inode *, struct file *, u_int, u_long);
#     endif
#    endif /* __OpenBSD__ */
#    ifndef linux
d480 1
a480 4
#    else
extern	int	iplopen __P((struct inode *, struct file *));
extern	void	iplclose __P((struct inode *, struct file *));
#    endif /* !linux */
d485 3
a487 1
#    ifndef linux
d489 1
a489 3
#    else
extern	int	iplread(struct inode *, struct file *, char *, int);
#    endif /* !linux */
d529 1
@


1.9
log
@IPF 3.2.3
@
text
@d1 1
d10 1
a10 1
 * $Id: ip_fil.h,v 2.0.2.39.2.10 1997/12/03 10:02:30 darrenr Exp $
@


1.8
log
@IPF 1.3.7
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * (C)opyright 1993-1996 by Darren Reed.
d9 1
a9 1
 * Id: ip_fil.h,v 2.0.1.2 1997/01/10 00:28:15 darrenr Exp 
d15 8
d30 6
a35 14
#if SOLARIS
# include <sys/ioccom.h>
# include <sys/sysmacros.h>
# ifdef	_KERNEL
#  include <inet/common.h>
/*
 * because Solaris 2 defines these in two places :-/
 */
#undef	IPOPT_EOL
#undef	IPOPT_NOP
#undef	IPOPT_LSRR
#undef	IPOPT_RR
#undef	IPOPT_SSRR
#  include <inet/ip.h>
d56 3
d76 3
d92 1
a92 1
	u_long	fi_optmsk;	/* bitmask composed from IP options */
d97 4
a100 4
#define	FI_OPTIONS	0x01
#define	FI_TCPUDP	0x02	/* TCP/UCP implied comparison involved */
#define	FI_FRAG		0x04
#define	FI_SHORT	0x08
a103 1
	void	*fin_ifp;
d106 1
d108 1
a108 1
	u_char	fin_icode;
d110 1
a110 1
	u_short	fin_hlen;
d112 3
d116 1
a116 1
	struct	frentry *fin_fr;
d119 9
a127 1
#define	FI_CSIZE	(sizeof(struct fr_ip) + 11)
d137 11
a147 4
	struct	ifnet	*fr_ifa;
	u_long	fr_hits;
	u_long	fr_bytes;	/* this is only incremented when a packet */
				/* matches this rule and it is the last match*/
d166 3
a168 3
	u_long	fr_flags;	/* per-rule flags && options (see below) */
	int	(*fr_func) __P((int, ip_t *, fr_info_t *));
				/* call this function */
d190 5
a194 5
*/
#define	FR_BLOCK	0x00001
#define	FR_PASS		0x00002
#define	FR_OUTQUE	0x00004
#define	FR_INQUE	0x00008
d202 1
a202 1
#define	FR_NOMATCH	0x00200
d212 4
d218 8
d227 1
a227 1
 * recognized flags for SIOCGETFF and SIOCSETFF
d229 3
a231 3
#define	FF_LOGPASS	0x100000
#define	FF_LOGBLOCK	0x200000
#define	FF_LOGNOMATCH	0x400000
d233 1
a233 1
#define	FF_BLOCKNONIP	0x800000	/* Solaris2 Only */
d262 1
d280 2
d285 1
a285 1
typedef struct  optlist {
d287 1
a287 1
	int     ol_bit;
d290 12
d303 17
a319 10
 * Log structure.  Each packet header logged is prepended by one of these,
 * minimize size to make most effective use of log space which should
 * (ideally) be a muliple of the most common log entry size.
 */
typedef	struct ipl_ci	{
	u_long	sec;
	u_long	usec;
	u_char	hlen;
	u_char	plen;
	u_short	rule;		/* assume never more than 64k rules, total */
d321 2
a322 3
    (defined(OpenBSD) && (OpenBSD >= 199603))
	u_long	flags;
	u_char	ifname[IFNAMSIZ];	/* = 32 bytes */
d324 18
a341 3
	u_long	flags:24;
	u_long	unit:8;
	u_char	ifname[4];	/* = 20 bytes */
a342 1
} ipl_ci_t;
d344 5
a348 3

#ifndef	ICMP_UNREACH_FILTER_PROHIB
#define	ICMP_UNREACH_FILTER_PROHIB	13
d354 24
a377 5
#ifdef _KERNEL
extern	int	fr_check __P((ip_t *, int, struct ifnet *, int,
			      struct mbuf **));
#else
extern	int	fr_check __P((ip_t *, int, struct ifnet *, int));
a378 4
extern	int	fr_copytolog(char *, int);
extern	fr_info_t	frcache[];
extern	char	*iplh, *iplt;
extern	char	iplbuf[IPLLOGSIZE];
d380 117
a496 1
#ifdef _KERNEL
d498 34
a531 6
extern struct frentry *ipfilter[2][2], *ipacct[2][2];
extern struct filterstats frstats[];
# if	SOLARIS
extern	int	ipfsync();
# endif
#endif /* _KERNEL */
@


1.7
log
@#define ICMP_UNREACH_FILTER -> ICMP_UNREACH_FILTER_PROHIB to match tcpdump/print_icmp.c which had it first
@
text
@d1 1
d10 1
a10 1
 * $OpenBSD: ip_fil.h,v 1.6 1996/10/08 07:33:26 niklas Exp $
a15 4
#ifdef _KERNEL
#define IPFILTER_LOG
#endif /* _KERNEL */

d56 1
a56 3
#define	SIOCFLNAT	_IOWR('r', 75, int)
#define	SIOCCNATL	_IOWR('r', 76, int)
#define	SIOCZRLST	_IOWR('r', 77, struct frentry)
d73 1
a73 3
#define	SIOCFLNAT	_IOWR(r, 75, int)
#define	SIOCCNATL	_IOWR(r, 76, int)
#define	SIOCZRLST	_IOWR(r, 77, struct frentry)
d80 2
a81 2
	u_char	fi_v:4;
	u_char	fi_fl:4;
d87 2
a88 2
	u_long	fi_optmsk;
	u_short	fi_secmsk;
d107 1
a107 1
	char	*fin_dp;
d124 1
a124 1
				/* stops matching on this rule */
d129 1
a129 1
	struct	fr_ip	fr_mip;
d176 3
a178 3
#define	FR_LOGFIRST	0x00040
#define	FR_RETRST	0x00080
#define	FR_RETICMP	0x00100
d181 2
a182 2
#define	FR_KEEPFRAG	0x00800
#define	FR_KEEPSTATE	0x01000
d184 5
a188 4
#define	FR_QUICK	0x04000
#define	FR_FASTROUTE	0x08000
#define	FR_CALLNOW	0x10000
#define	FR_DUP		0x20000
d198 1
d227 1
d252 5
d262 5
a266 6
	u_short	rule;
	u_long	flags:24;			/* XXX FIXME do we care about the extra bytes? */
#if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
    (defined(OpenBSD) && (OpenBSD >= 199606))
	u_long	filler:8;			/* XXX FIXME do we care? */
	u_char	ifname[IFNAMSIZ];
d268 1
d270 1
a270 1
	u_char	ifname[4];
a277 52
/*
 * Security Options for Intenet Protocol (IPSO) as defined in RFC 1108.
 *
 * Basic Option
 *
 * 00000001   -   (Reserved 4)
 * 00111101   -   Top Secret
 * 01011010   -   Secret
 * 10010110   -   Confidential
 * 01100110   -   (Reserved 3)
 * 11001100   -   (Reserved 2)
 * 10101011   -   Unclassified
 * 11110001   -   (Reserved 1)
 */
#define	IPSO_CLASS_RES4		0x01
#define	IPSO_CLASS_TOPS		0x3d
#define	IPSO_CLASS_SECR		0x5a
#define	IPSO_CLASS_CONF		0x96
#define	IPSO_CLASS_RES3		0x66
#define	IPSO_CLASS_RES2		0xcc
#define	IPSO_CLASS_UNCL		0xab
#define	IPSO_CLASS_RES1		0xf1

#define	IPSO_AUTH_GENSER	0x80
#define	IPSO_AUTH_ESI		0x40
#define	IPSO_AUTH_SCI		0x20
#define	IPSO_AUTH_NSA		0x10
#define	IPSO_AUTH_DOE		0x08
#define	IPSO_AUTH_UN		0x06
#define	IPSO_AUTH_FTE		0x01

/*#define	IPOPT_RR	7 */
#define	IPOPT_ZSU	10	/* ZSU */
#define	IPOPT_MTUP	11	/* MTUP */
#define	IPOPT_MTUR	12	/* MTUR */
#define	IPOPT_ENCODE	15	/* ENCODE */
/*#define	IPOPT_TS	68 */
#define	IPOPT_TR	82	/* TR */
/*#define	IPOPT_SECURITY	130 */
/*#define	IPOPT_LSRR	131 */
#define	IPOPT_E_SEC	133	/* E-SEC */
#define	IPOPT_CIPSO	134	/* CIPSO */
/*#define	IPOPT_SATID	136 */
#ifndef	IPOPT_SID
# define	IPOPT_SID	IPOPT_SATID
#endif
/*#define	IPOPT_SSRR	137 */
#define	IPOPT_ADDEXT	147	/* ADDEXT */
#define	IPOPT_VISA	142	/* VISA */
#define	IPOPT_IMITD	144	/* IMITD */
#define	IPOPT_EIP	145	/* EIP */
#define	IPOPT_FINN	205	/* FINN */
d280 1
d282 7
d290 2
a296 6

#ifdef IPFILTER_LOG
extern int	ipllog __P((u_int, ip_t *, fr_info_t *, struct mbuf *));
#endif
extern int	send_reset __P((struct tcpiphdr *));
extern void	ipfr_fastroute __P((struct mbuf *, fr_info_t *, frdest_t *));
a297 1
extern	int	fr_check();
d299 1
a299 6
# else /* SOLARIS */
extern	int	fr_check __P((ip_t *, int, struct ifnet *, int,
    struct mbuf **));
# endif /* SOLARIS */
#else /* _KERNEL */
extern	int	fr_check __P((ip_t *, int, struct ifnet *, int));
@


1.6
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d9 1
a9 1
 * $OpenBSD: ip_fil.h,v 1.5 1996/09/30 14:06:38 deraadt Exp $
d274 2
a275 2
#ifndef	ICMP_UNREACH_FILTER
#define	ICMP_UNREACH_FILTER	13
@


1.5
log
@handle openbsd cases
@
text
@d9 1
a9 1
 * $Id: ip_fil.h,v 1.4 1996/07/18 05:00:59 dm Exp $
d151 2
a152 1
	int	(*fr_func)();	/* call this function */
a331 1
extern	int	fr_check();
d338 6
d345 1
d347 6
a352 1
# endif
@


1.4
log
@ipfilter 3.1.0
@
text
@d9 1
a9 1
 * $Id: ip_fil.h,v 1.3 1996/07/04 13:24:06 darrenr Exp $
d262 2
a263 1
#if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606))
@


1.3
log
@ipfilter 3.0.4
@
text
@d8 2
a9 1
 * @@(#)ip_fil.h	1.32 3/24/96
a21 201
#define	IPMINLEN(i, h)	((i)->ip_len >= ((i)->ip_hl * 4 + sizeof(struct h)))

#ifndef	IP_OFFMASK
#define	IP_OFFMASK	0x1fff
#endif

#ifndef	MAX
#define	MAX(a,b)	(((a) > (b)) ? (a) : (b))
#endif

#ifdef _KERNEL
# if SOLARIS
#  define	MUTEX_ENTER(x)	mutex_enter(x)
#  define	MUTEX_EXIT(x)	mutex_exit(x)
#  define	MTOD(m,t)	(t)((m)->b_rptr)
#  define	IRCOPY(a,b,c)	copyin((a), (b), (c))
#  define	IWCOPY(a,b,c)	copyout((a), (b), (c))
# else
#  define	MUTEX_ENTER(x)	;
#  define	MUTEX_EXIT(x)	;
#  ifndef linux
#   define	MTOD(m,t)	mtod(m,t)
#   define	IRCOPY(a,b,c)	bcopy((a), (b), (c))
#   define	IWCOPY(a,b,c)	bcopy((a), (b), (c))
#  endif
# endif /* SOLARIS */

# ifdef sun
#  if defined(__svr4__) || defined(__SVR4)
#   define	GETUNIT(n)	get_unit((n))
#  else
#   include	<sys/kmem_alloc.h>
#   define	GETUNIT(n)	ifunit((n), IFNAMSIZ)
#  endif
# else
#  define	GETUNIT(n)	ifunit((n))
# endif /* sun */

# if defined(sun) && !defined(linux)
#  define	UIOMOVE(a,b,c,d)	uiomove(a,b,c,d)
#  define	SLEEP(id, n)	sleep((id), PZERO+1)
#  define	KFREE(x)	kmem_free((char *)(x), sizeof(*(x)))
#  if SOLARIS
typedef	struct	qif	{
	struct	qif	*qf_next;
	ill_t	*qf_ill;
	kmutex_t	qf_lock;
	void	*qf_iptr;
	void	*qf_optr;
	queue_t	*qf_in;
	queue_t	*qf_out;
	void	*qf_wqinfo;
	void	*qf_rqinfo;
	char	qf_name[8];
	int	(*qf_inp)();
	int	(*qf_outp)();
	/*
	 * in case the ILL has disappeared...
	 */
	int	qf_hl;	/* header length */
} qif_t;
#   define	SPLNET(x)	;
#   undef	SPLX
#   define	SPLX(x)		;
#   ifdef	sparc
#    define	ntohs(x)	(x)
#    define	ntohl(x)	(x)
#    define	htons(x)	(x)
#    define	htonl(x)	(x)
#   endif
#   define	KMALLOC(x)	kmem_alloc((x), KM_SLEEP)
#   define	GET_MINOR(x)	getminor(x)
#  else
#   define	KMALLOC(x)	new_kmem_alloc((x), KMEM_SLEEP)
#  endif /* __svr4__ */
# endif /* sun && !linux */
# ifndef	GET_MINOR
#  define	GET_MINOR(x)	minor(x)
# endif
# if BSD >= 199306 || defined(__FreeBSD__)
#  include <vm/vm.h>
#  if !defined(__FreeBSD__)
#   include <vm/vm_extern.h>
#   include <sys/proc.h>
extern	vm_map_t	kmem_map;
#  else
#   include <vm/vm_kern.h>
#  endif /* __FreeBSD__ */
#  define	KMALLOC(x)	kmem_alloc(kmem_map, (x))
#  define	KFREE(x)	kmem_free(kmem_map, (vm_offset_t)(x), \
					  sizeof(*(x)))
#  define	UIOMOVE(a,b,c,d)	uiomove(a,b,d)
#  define	SLEEP(id, n)	tsleep((id), PPAUSE|PCATCH, n, 0)
# endif /* BSD */
# if defined(NetBSD1_0) && (NetBSD1_0 > 1)
#  define	SPLNET(x)	x = splsoftnet()
# else
#  if !SOLARIS
#   define	SPLNET(x)	x = splnet()
#   define	SPLX(x)		(void) splx(x)
#  endif
# endif
#else
# define	MUTEX_ENTER(x)	;
# define	MUTEX_EXIT(x)	;
# define	SPLNET(x)	;
# define	SPLX(x)		;
# define	KMALLOC(x)	malloc(x)
# define	KFREE(x)	free(x)
# define	GETUNIT(x)	(x)
# define	IRCOPY(a,b,c)	bcopy((a), (b), (c))
# define	IWCOPY(a,b,c)	bcopy((a), (b), (c))
#endif /* KERNEL */

#ifdef linux
# define	ICMP_UNREACH	ICMP_DEST_UNREACH
# define	ICMP_SOURCEQUENCH	ICMP_SOURCE_QUENCH
# define	ICMP_TIMXCEED	ICMP_TIME_EXCEEDED
# define	ICMP_PARAMPROB	ICMP_PARAMETERPROB
# define	icmp	icmphdr
# define	icmp_type	type
# define	icmp_code	code

# define	TH_FIN	0x01
# define	TH_SYN	0x02
# define	TH_RST	0x04
# define	TH_PUSH	0x08
# define	TH_ACK	0x10
# define	TH_URG	0x20

typedef	struct	{
	__u16	th_sport;
	__u16	th_dport;
	__u32	th_seq;
	__u32	th_ack;
	__u8	th_x;
	__u8	th_flags;
	__u16	th_win;
	__u16	th_sum;
	__u16	th_urp;
} tcphdr_t;

typedef	struct	{
	__u16	uh_sport;
	__u16	uh_dport;
	__u16	uh_ulen;
	__u16	uh_sun;
} udphdr_t;

typedef	struct	{
# if defined(__i386__) || defined(__MIPSEL__) || defined(__alpha__) ||\
    defined(vax)
	__u8	ip_hl:4;
	__u8	ip_v:4;
# else
	__u8	ip_hl:4;
	__u8	ip_v:4;
# endif
	__u8	ip_tos;
	__u16	ip_len;
	__u16	ip_id;
	__u16	ip_off;
	__u8	ip_ttl;
	__u8	ip_p;
	__u16	ip_sum;
	__u32	ip_src;
	__u32	ip_dst;
} ip_t;

# define	SPLX(x)		(void)
# define	SPLNET(x)	(void)

# define	bcopy(a,b,c)	memmove(b,a,c)
# define	bcmp(a,b,c)	memcmp(a,b,c)

# define	UNITNAME(n)	dev_get((n))
# define	ifnet	device

# define	KMALLOC(x)	kmalloc((x), GFP_ATOMIC)
# define	KFREE(x)	kfree_s((x), sizeof(*(x)))
# define	IRCOPY(a,b,c)	{ \
				 error = verify_area(VERIFY_READ, \
						     (b) ,sizeof((b))); \
				 if (!error) \
					memcpy_fromfs((b), (a), (c)); \
				}
# define	IWCOPY(a,b,c)	{ \
				 error = verify_area(VERIFY_WRITE, \
						     (b) ,sizeof((b))); \
				 if (!error) \
					memcpy_tofs((b), (a), (c)); \
				}
#else
typedef	struct	tcphdr	tcphdr_t;
typedef	struct	udphdr	udphdr_t;
typedef	struct	ip	ip_t;
#endif /* linux */

#ifndef	SOLARIS
#define	SOLARIS	(defined(sun) && (defined(__svr4__) || defined(__SVR4)))
#endif
d59 3
d78 3
d120 6
d151 1
d154 2
d174 22
a195 17
#define	FR_BLOCK	0x0001
#define	FR_PASS		0x0002
#define	FR_OUTQUE	0x0004
#define	FR_INQUE	0x0008
#define	FR_LOG		0x0010	/* Log */
#define	FR_LOGB		0x0021	/* Log-fail */
#define	FR_LOGP		0x0022	/* Log-pass */
#define	FR_LOGBODY	0x0040	/* Log the body */
#define	FR_LOGFIRST	0x0080
#define	FR_RETRST	0x0100
#define	FR_RETICMP	0x0200
#define	FR_NOMATCH	0x0400
#define	FR_ACCOUNT	0x0800	/* count packet bytes */
#define	FR_KEEPFRAG	0x1000
#define	FR_KEEPSTATE	0x2000
#define	FR_INACTIVE	0x4000
#define	FR_QUICK	0x8000
d202 1
d261 5
a265 2
	u_long	flags:24;
#if !defined (__OpenBSD__) && !defined (__NetBSD__)
d268 1
a268 4
#else /* OpenBSD or NetBSD */
	u_long : 0;
	u_char	ifname[IFNAMSIZ];
#endif /* OpenBSD or NetBSD */
@


1.2
log
@IP filter 3.0.1
@
text
@d2 1
a2 1
 * (C)opyright 1993, 1994, 1995 by Darren Reed.
d8 1
a8 1
 * @@(#)ip_fil.h	1.29 1/12/96
d11 1
a11 1
#ifndef	__IP_FIL_H_
d14 1
a14 1
#ifndef IPFILTER_LOG
d16 13
d31 188
a290 5
	u_short	fi_out;
	u_short	fi_rule;
	u_short	fi_hlen;
	u_char	fi_icode;
	struct	frentry *fi_fr;
d298 16
d406 1
d409 1
d441 1
d444 4
d510 1
a519 202

#ifndef	SOLARIS
#define	SOLARIS	(defined(sun) && (defined(__svr4__) || defined(__SVR4)))
#endif
#define	IPMINLEN(i, h)	((i)->ip_len >= ((i)->ip_hl * 4 + sizeof(struct h)))

#ifndef	IP_OFFMASK
#define	IP_OFFMASK	0x1fff
#endif

#ifndef	MAX
#define	MAX(a,b)	(((a) > (b)) ? (a) : (b))
#endif

#ifdef _KERNEL
# if SOLARIS
#  define	MUTEX_ENTER(x)	mutex_enter(x)
#  define	MUTEX_EXIT(x)	mutex_exit(x)
#  define	MTOD(m,t)	(t)((m)->b_rptr)
#  define	IRCOPY(a,b,c)	copyin((a), (b), (c))
#  define	IWCOPY(a,b,c)	copyout((a), (b), (c))
# else
#  define	MUTEX_ENTER(x)	;
#  define	MUTEX_EXIT(x)	;
#  ifndef linux
#   define	MTOD(m,t)	mtod(m,t)
#   define	IRCOPY(a,b,c)	bcopy((a), (b), (c))
#   define	IWCOPY(a,b,c)	bcopy((a), (b), (c))
#  endif
# endif /* SOLARIS */

# ifdef sun
#  if defined(__svr4__) || defined(__SVR4)
#   define	GETUNIT(n)	get_unit((n))
#  else
#   include	<sys/kmem_alloc.h>
#   define	GETUNIT(n)	ifunit((n), IFNAMSIZ)
#  endif
# else
#  define	GETUNIT(n)	ifunit((n))
# endif /* sun */

# if defined(sun) && !defined(linux) && !defined(__NetBSD__) && !defined (__OpenBSD__)
#  define	UIOMOVE(a,b,c,d)	uiomove(a,b,c,d)
#  define	SLEEP(id, n)	sleep((id), PZERO+1)
#  define	KFREE(x)	kmem_free((char *)(x), sizeof(*(x)))
#  if SOLARIS
typedef	struct	qif	{
	struct	qif	*qf_next;
	ill_t	*qf_ill;
	kmutex_t	qf_lock;
	void	*qf_iptr;
	void	*qf_optr;
	queue_t	*qf_in;
	queue_t	*qf_out;
	void	*qf_wqinfo;
	void	*qf_rqinfo;
	char	qf_name[8];
	int	(*qf_inp)();
	int	(*qf_outp)();
	/*
	 * in case the ILL has disappeared...
	 */
	int	qf_hl;	/* header length */
} qif_t;
#   define	SPLNET(x)	;
#   undef	SPLX
#   define	SPLX(x)		;
#   ifdef	sparc
#    define	ntohs(x)	(x)
#    define	ntohl(x)	(x)
#    define	htons(x)	(x)
#    define	htonl(x)	(x)
#   endif
#   define	KMALLOC(x)	kmem_alloc((x), KM_SLEEP)
#   define	GET_MINOR(x)	getminor(x)
#  else
#   define	KMALLOC(x)	new_kmem_alloc((x), KMEM_SLEEP)
#  endif /* __svr4__ */
# endif /* sun && !linux && !__NetBSD__ && !__OpenBSD__*/
# ifndef	GET_MINOR
#  define	GET_MINOR(x)	minor(x)
# endif
# if BSD >= 199306 || defined(__FreeBSD__)
#  include <vm/vm.h>
#  if !defined(__FreeBSD__)
#   include <vm/vm_extern.h>
#   include <sys/proc.h>
extern	vm_map_t	kmem_map;
#  else
#   include <vm/vm_kern.h>
#  endif /* __FreeBSD__ */
#  define	KMALLOC(x)	kmem_alloc(kmem_map, (x))
#  define	KFREE(x)	kmem_free(kmem_map, (vm_offset_t)(x), \
					  sizeof(*(x)))
#  define	UIOMOVE(a,b,c,d)	uiomove(a,b,d)
#  define	SLEEP(id, n)	tsleep((id), PPAUSE|PCATCH, n, 0)
# endif /* BSD */
# if defined(NetBSD1_0) && (NetBSD1_0 > 1)
#  define	SPLNET(x)	x = splsoftnet()
# else
#  if !SOLARIS
#   define	SPLNET(x)	x = splnet()
#   define	SPLX(x)		(void) splx(x)
#  endif
# endif
#else
# define	MUTEX_ENTER(x)	;
# define	MUTEX_EXIT(x)	;
# define	SPLNET(x)	;
# define	SPLX(x)		;
# define	KMALLOC(x)	malloc(x)
# define	KFREE(x)	free(x)
# define	GETUNIT(x)	(x)
# define	IRCOPY(a,b,c)	bcopy((a), (b), (c))
# define	IWCOPY(a,b,c)	bcopy((a), (b), (c))
#endif /* KERNEL */

#ifdef linux
# define	ICMP_UNREACH	ICMP_DEST_UNREACH
# define	ICMP_SOURCEQUENCH	ICMP_SOURCE_QUENCH
# define	ICMP_TIMXCEED	ICMP_TIME_EXCEEDED
# define	ICMP_PARAMPROB	ICMP_PARAMETERPROB
# define	icmp	icmphdr
# define	icmp_type	type
# define	icmp_code	code

# define	TH_FIN	0x01
# define	TH_SYN	0x02
# define	TH_RST	0x04
# define	TH_PUSH	0x08
# define	TH_ACK	0x10
# define	TH_URG	0x20

typedef	struct	{
	__u16	th_sport;
	__u16	th_dport;
	__u32	th_seq;
	__u32	th_ack;
	__u8	th_x;
	__u8	th_flags;
	__u16	th_win;
	__u16	th_sum;
	__u16	th_urp;
} tcphdr_t;

typedef	struct	{
	__u16	uh_sport;
	__u16	uh_dport;
	__u16	uh_ulen;
	__u16	uh_sun;
} udphdr_t;

typedef	struct	{
# if defined(__i386__) || defined(__MIPSEL__) || defined(__alpha__) ||\
    defined(vax)
	__u8	ip_hl:4;
	__u8	ip_v:4;
# else
	__u8	ip_hl:4;
	__u8	ip_v:4;
# endif
	__u8	ip_tos;
	__u16	ip_len;
	__u16	ip_id;
	__u16	ip_off;
	__u8	ip_ttl;
	__u8	ip_p;
	__u16	ip_sum;
	__u32	ip_src;
	__u32	ip_dst;
} ip_t;

# define	SPLX(x)		(void)
# define	SPLNET(x)	(void)

# define	bcopy(a,b,c)	memmove(b,a,c)
# define	bcmp(a,b,c)	memcmp(a,b,c)

# define	UNITNAME(n)	dev_get((n))
# define	ifnet	device

# define	KMALLOC(x)	kmalloc((x), GFP_ATOMIC)
# define	KFREE(x)	kfree_s((x), sizeof(*(x)))
# define	IRCOPY(a,b,c)	{ \
				 error = verify_area(VERIFY_READ, \
						     (b) ,sizeof((b))); \
				 if (!error) \
					memcpy_fromfs((b), (a), (c)); \
				}
# define	IWCOPY(a,b,c)	{ \
				 error = verify_area(VERIFY_WRITE, \
						     (b) ,sizeof((b))); \
				 if (!error) \
					memcpy_tofs((b), (a), (c)); \
				}
#else
typedef	struct	tcphdr	tcphdr_t;
typedef	struct	udphdr	udphdr_t;
typedef	struct	ip	ip_t;
#endif /* linux */

@


1.1
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d8 1
a8 1
 * @@(#)ip_fil.h	1.23 11/11/95
d15 1
a15 1
#define IPFILTER_LOG 1
d18 1
d20 2
d90 5
d97 2
a98 2
#define	FI_SHORT	0x01
#define	FI_OPTIONS	0x02
d100 1
a100 1
#define	FI_TCPUDP	0x08	/* TCP/UCP implied comparison involved */
d105 3
a107 2
	u_int	fr_hits;

d126 2
a127 1
	u_short	fr_flags;	/* per-rule flags && options (see below) */
d146 1
a146 1
 */
d151 19
a169 9
#define	FR_LOGP		0x0010	/* Log-pass */
#define	FR_LOGB		0x0020	/* Log-fail */
#define	FR_LOG		0x0040	/* Log */
#define	FR_LOGBODY	0x0080	/* Log the body */
#define	FR_QUICK	0x0100
#define	FR_RETRST	0x0200
#define	FR_RETICMP	0x0400
#define	FR_INACTIVE	0x0800
#define	FR_NOMATCH	0x1000
d187 1
d191 5
a203 6
 * recognized flags for SIOCGETFF and SIOCSETFF
 */
#define	FF_LOGPASS	1
#define	FF_LOGBLOCK	2

/*
d210 2
a219 5
#ifdef	_KERNEL
extern struct frentry *filterin[], *filterout[];
extern struct filterstats frstats[];
#endif

a230 1
#ifdef	_KERNEL
d232 73
a304 10
typedef	struct	ipfr	{
	struct	ipfr	*ipfr_next, *ipfr_prev;
	struct	in_addr	ipfr_src;
	struct	in_addr	ipfr_dst;
	u_short	ipfr_id;
	u_short	ipfr_age;
	u_char	ipfr_p;
	u_char	ipfr_tos;
	u_char	ipfr_pass;
} ipfr_t;
d306 3
a308 1
#define	IPFR_CMPSZ	(4 + 4 + 2 + 1 + 1)
d310 33
a342 1
# if defined(sun) && !defined(linux)
d347 21
d379 1
a379 1
# endif /* sun && !linux */
d397 3
d401 16
a416 2
# endif /* BSD */
#endif /* _KERNEL */
d447 7
d473 2
a474 2
# define	SPLX(x)		;
# define	SPLNET(x)	;
a496 1

d498 1
a499 61

# if SOLARIS
#  define	MTOD(m,t)	(t)((m)->b_rptr)
#  define	IRCOPY(a,b,c)	copyin((a), (b), (c))
#  define	IWCOPY(a,b,c)	copyout((a), (b), (c))
#  ifdef	_KERNEL
typedef	struct	qif	{
	struct	qif	*qf_next;
	ill_t	*qf_ill;
	kmutex_t	qf_lock;
	void	*qf_iptr;
	void	*qf_optr;
	queue_t	*qf_in;
	queue_t	*qf_out;
	void	*qf_wqinfo;
	void	*qf_rqinfo;
	char	qf_name[8];
	int	(*qf_inp)();
	int	(*qf_outp)();
	/*
	 * in case the ILL has disappeared...
	 */
	int	qf_hl;	/* header length */
} qif_t;
#  endif /* _KERNEL */
# else
#  define	MTOD(m,t)	mtod(m,t)
#  define	IRCOPY(a,b,c)	bcopy((a), (b), (c))
#  define	IWCOPY(a,b,c)	bcopy((a), (b), (c))
# endif /* SOLARIS */
# ifdef	_KERNEL
#  if defined(NetBSD1_0) && (NetBSD1_0 > 1)
#   define	SPLNET(x)	x = splsoftnet()
#  else
#   if SOLARIS
#    define	SPLNET(x)	;
#   else
#    define	SPLNET(x)	x = splnet()
#   endif
#  endif
#  ifdef SPLX
#   undef	SPLX
#  endif
#  if SOLARIS
#   define	SPLX(x)		;
#  else
#   define	SPLX(x)		(void) splx(x)
#  endif
# else
#  define	SPLNET(x)	;
#  define	SPLX(x)		;
# endif /* KERNEL */

# ifdef sun
#  if !defined(__sysv__) && !defined(__SVR4)
#   define	GETUNIT(n)	ifunit((n), IFNAMSIZ)
#  endif
# else
#  define	GETUNIT(n)	ifunit((n))
# endif /* sun */
extern struct ifnet *ifunit();
a500 58

#define	IPMINLEN(i, h)	((i)->ip_len >= ((i)->ip_hl * 4 + sizeof(struct h)))

/*#define	IPOPT_RR	7 */
#define	IPOPT_ZSU	10	/* ZSU */
#define	IPOPT_MTUP	11	/* MTUP */
#define	IPOPT_MTUR	12	/* MTUR */
#define	IPOPT_ENCODE	15	/* ENCODE */
/*#define	IPOPT_TS	68 */
#define	IPOPT_TR	82	/* TR */
/*#define	IPOPT_SECURITY	130 */
/*#define	IPOPT_LSRR	131 */
#define	IPOPT_E_SEC	133	/* E-SEC */
#define	IPOPT_CIPSO	134	/* CIPSO */
/*#define	IPOPT_SATID	136 */
#ifndef	IPOPT_SID
# define	IPOPT_SID	IPOPT_SATID
#endif
/*#define	IPOPT_SSRR	137 */
#define	IPOPT_ADDEXT	147	/* ADDEXT */
#define	IPOPT_VISA	142	/* VISA */
#define	IPOPT_IMITD	144	/* IMITD */
#define	IPOPT_EIP	145	/* EIP */
#define	IPOPT_FINN	205	/* FINN */

#ifndef	ICMP_UNREACH_FILTER
#define	ICMP_UNREACH_FILTER	13
#endif
/*
 * Security Options for Intenet Protocol (IPSO) as defined in RFC 1108.
 *
 * Basic Option
 *
 * 00000001   -   (Reserved 4)
 * 00111101   -   Top Secret
 * 01011010   -   Secret
 * 10010110   -   Confidential
 * 01100110   -   (Reserved 3)
 * 11001100   -   (Reserved 2)
 * 10101011   -   Unclassified
 * 11110001   -   (Reserved 1)
 */
#define	IPSO_CLASS_RES4		0x01
#define	IPSO_CLASS_TOPS		0x3d
#define	IPSO_CLASS_SECR		0x5a
#define	IPSO_CLASS_CONF		0x96
#define	IPSO_CLASS_RES3		0x66
#define	IPSO_CLASS_RES2		0xcc
#define	IPSO_CLASS_UNCL		0xab
#define	IPSO_CLASS_RES1		0xf1

#define	IPSO_AUTH_GENSER	0x80
#define	IPSO_AUTH_ESI		0x40
#define	IPSO_AUTH_SCI		0x20
#define	IPSO_AUTH_NSA		0x10
#define	IPSO_AUTH_DOE		0x08
#define	IPSO_AUTH_UN		0x06
#define	IPSO_AUTH_FTE		0x01
@
