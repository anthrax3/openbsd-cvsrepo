head	1.31;
access;
symbols
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	UBC_SYNC_A:1.31
	UBC_SYNC_B:1.31
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.26.0.2
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.24.0.2
	OPENBSD_2_7_BASE:1.24
	SMP:1.20.0.2
	SMP_BASE:1.20
	kame_19991208:1.16
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.31
date	2001.05.30.02.12.26;	author deraadt;	state dead;
branches;
next	1.30;

1.30
date	2001.05.11.17.20.11;	author aaron;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.08.19.58.01;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.30.04.23.55;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.17.04.47.11;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.10.05.50.25;	author kjell;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.24.21.59.10;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.10.20.40.52;	author deraadt;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2000.05.01.06.16.47;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.13.23.40.17;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.16.22.34.17;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.01.19.29.57;	author kjell;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	99.12.17.06.17.07;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	99.12.15.07.04.20;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	99.12.15.05.20.20;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	99.02.19.20.52.22;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	99.02.05.05.58.49;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.09.15.09.51.17;	author pattonme;	state Exp;
branches;
next	1.12;

1.12
date	98.02.17.01.39.01;	author dgregor;	state Exp;
branches;
next	1.11;

1.11
date	98.01.26.04.10.37;	author dgregor;	state Exp;
branches;
next	1.10;

1.10
date	97.06.23.19.03.47;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.04.03.15.46.36;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.02.11.22.23.08;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.10.24.17.56.20;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.10.08.07.33.24;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.18.05.00.55;	author dm;	state Exp;
branches;
next	1.4;

1.4
date	96.05.13.19.49.31;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.21.38.15;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.25.05.41.41;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.02.34.01;	author dm;	state Exp;
branches;
next	;

1.20.2.1
date	2000.02.20.11.57.22;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2000.03.24.09.09.34;	author niklas;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.05.14.22.40.06;	author niklas;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2001.07.04.10.54.26;	author niklas;	state dead;
branches;
next	;

1.24.2.1
date	2000.05.27.20.45.17;	author jason;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: fil.c,v 1.30 2001/05/11 17:20:11 aaron Exp $	*/

/*
 * Copyright (C) 1993-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#if !defined(lint)
static const char sccsid[] = "@@(#)fil.c	1.36 6/5/96 (C) 1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.35.2.31 2001/04/03 15:46:41 dar renr Exp $";
#endif

#include <sys/errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/file.h>
#if defined(__NetBSD__) && (NetBSD >= 199905) && !defined(IPFILTER_LKM) && \
    defined(_KERNEL)
# include "opt_ipfilter_log.h"
#endif
#if (defined(KERNEL) || defined(_KERNEL)) && defined(__FreeBSD_version) && \
    (__FreeBSD_version >= 220000)
# if (__FreeBSD_version >= 400000)
#  ifndef KLD_MODULE
#   include "opt_inet6.h"
#  endif
#  if (__FreeBSD_version == 400019)
#   define CSUM_DELAY_DATA
#  endif
# endif
# include <sys/filio.h>
# include <sys/fcntl.h>
#else
# include <sys/ioctl.h>
#endif
#if (defined(_KERNEL) || defined(KERNEL)) && !defined(linux)
# include <sys/systm.h>
#else
# include <stdio.h>
# include <string.h>
# include <stdlib.h>
#endif
#include <sys/uio.h>
#if !defined(__SVR4) && !defined(__svr4__)
# ifndef linux
#  include <sys/mbuf.h>
# endif
#else
# include <sys/byteorder.h>
# if SOLARIS2 < 5
#  include <sys/dditypes.h>
# endif
#  include <sys/stream.h>
#endif
#ifndef linux
# include <sys/protosw.h>
# include <sys/socket.h>
#endif
#include <net/if.h>
#ifdef sun
# include <net/af.h>
#endif
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#ifndef linux
# include <netinet/ip_var.h>
#endif
#if defined(__sgi) && defined(IFF_DRVRLOCK) /* IRIX 6 */
# include <sys/hashing.h>
# include <netinet/in_var.h>
#endif
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_fil_compat.h>
#ifdef	USE_INET6
# include <netinet/icmp6.h>
# if !SOLARIS && defined(_KERNEL)
#  include <netinet6/in6_var.h>
# endif
#endif
#include <netinet/tcpip.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_frag.h>
#include <netinet/ip_state.h>
#include <netinet/ip_auth.h>
# if defined(__FreeBSD_version) && (__FreeBSD_version >= 300000)
#  include <sys/malloc.h>
#  if defined(_KERNEL) && !defined(IPFILTER_LKM)
#   include "opt_ipfilter.h"
#  endif
# endif
#ifndef	MIN
# define	MIN(a,b)	(((a)<(b))?(a):(b))
#endif
#include <netinet/ipl.h>

#ifndef	_KERNEL
# include "ipf.h"
# include "ipt.h"
extern	int	opts;

# define	FR_VERBOSE(verb_pr)			verbose verb_pr
# define	FR_DEBUG(verb_pr)			debug verb_pr
# define	IPLLOG(a, c, d, e)		ipllog()
#else /* #ifndef _KERNEL */
# define	FR_VERBOSE(verb_pr)
# define	FR_DEBUG(verb_pr)
# define	IPLLOG(a, c, d, e)		ipflog(a, c, d, e)
# if SOLARIS || defined(__sgi)
extern	KRWLOCK_T	ipf_mutex, ipf_auth, ipf_nat;
extern	kmutex_t	ipf_rw;
# endif
# if SOLARIS
#  define	FR_NEWAUTH(m, fi, ip, qif)	fr_newauth((mb_t *)m, fi, \
							   ip, qif)
# else /* SOLARIS */
#  define	FR_NEWAUTH(m, fi, ip, qif)	fr_newauth((mb_t *)m, fi, ip)
# endif /* SOLARIS || __sgi */
#endif /* _KERNEL */


struct	filterstats frstats[2] = {{0,0,0,0,0},{0,0,0,0,0}};
struct	frentry	*ipfilter[2][2] = { { NULL, NULL }, { NULL, NULL } },
#ifdef	USE_INET6
		*ipfilter6[2][2] = { { NULL, NULL }, { NULL, NULL } },
		*ipacct6[2][2] = { { NULL, NULL }, { NULL, NULL } },
#endif
		*ipacct[2][2] = { { NULL, NULL }, { NULL, NULL } };
struct	frgroup *ipfgroups[3][2];
int	fr_flags = IPF_LOGGING;
int	fr_active = 0;
int	fr_chksrc = 0;
int	fr_minttl = 3;
int	fr_minttllog = 1;
#if defined(IPFILTER_DEFAULT_BLOCK)
int	fr_pass = FR_NOMATCH|FR_BLOCK;
#else
int	fr_pass = (IPF_DEFAULT_PASS|FR_NOMATCH);
#endif
char	ipfilter_version[] = IPL_VERSION;

fr_info_t	frcache[2];

static	int	frflushlist __P((int, minor_t, int *, frentry_t **));
#ifdef	_KERNEL
static	void	frsynclist __P((frentry_t *));
#endif


/*
 * bit values for identifying presence of individual IP options
 */
struct	optlist	ipopts[20] = {
	{ IPOPT_NOP,	0x000001 },
	{ IPOPT_RR,	0x000002 },
	{ IPOPT_ZSU,	0x000004 },
	{ IPOPT_MTUP,	0x000008 },
	{ IPOPT_MTUR,	0x000010 },
	{ IPOPT_ENCODE,	0x000020 },
	{ IPOPT_TS,	0x000040 },
	{ IPOPT_TR,	0x000080 },
	{ IPOPT_SECURITY, 0x000100 },
	{ IPOPT_LSRR,	0x000200 },
	{ IPOPT_E_SEC,	0x000400 },
	{ IPOPT_CIPSO,	0x000800 },
	{ IPOPT_SATID,	0x001000 },
	{ IPOPT_SSRR,	0x002000 },
	{ IPOPT_ADDEXT,	0x004000 },
	{ IPOPT_VISA,	0x008000 },
	{ IPOPT_IMITD,	0x010000 },
	{ IPOPT_EIP,	0x020000 },
	{ IPOPT_FINN,	0x040000 },
	{ 0,		0x000000 }
};

/*
 * bit values for identifying presence of individual IP security options
 */
struct	optlist	secopt[8] = {
	{ IPSO_CLASS_RES4,	0x01 },
	{ IPSO_CLASS_TOPS,	0x02 },
	{ IPSO_CLASS_SECR,	0x04 },
	{ IPSO_CLASS_RES3,	0x08 },
	{ IPSO_CLASS_CONF,	0x10 },
	{ IPSO_CLASS_UNCL,	0x20 },
	{ IPSO_CLASS_RES2,	0x40 },
	{ IPSO_CLASS_RES1,	0x80 }
};


/*
 * compact the IP header into a structure which contains just the info.
 * which is useful for comparing IP headers with.
 */
void	fr_makefrip(hlen, ip, fin)
int hlen;
ip_t *ip;
fr_info_t *fin;
{
	u_short optmsk = 0, secmsk = 0, auth = 0;
	int i, mv, ol, off, p, plen, v;
	fr_ip_t *fi = &fin->fin_fi;
	struct optlist *op;
	u_char *s, opt;
	tcphdr_t *tcp;

	fin->fin_rev = 0;
	fin->fin_fr = NULL;
	fin->fin_tcpf = 0;
	fin->fin_data[0] = 0;
	fin->fin_data[1] = 0;
	fin->fin_rule = -1;
	fin->fin_group = -1;
#ifdef	_KERNEL
	fin->fin_icode = ipl_unreach;
#endif
	v = fin->fin_v;
	fi->fi_v = v;
	fin->fin_hlen = hlen;
	if (v == 4) {
		fin->fin_id = ip->ip_id;
		fi->fi_tos = ip->ip_tos;
		off = (ip->ip_off & IP_OFFMASK) << 3;
		tcp = (tcphdr_t *)((char *)ip + hlen);
		(*(((u_short *)fi) + 1)) = (*(((u_short *)ip) + 4));
		fi->fi_src.i6[1] = 0;
		fi->fi_src.i6[2] = 0;
		fi->fi_src.i6[3] = 0;
		fi->fi_dst.i6[1] = 0;
		fi->fi_dst.i6[2] = 0;
		fi->fi_dst.i6[3] = 0;
		fi->fi_saddr = ip->ip_src.s_addr;
		fi->fi_daddr = ip->ip_dst.s_addr;
		p = ip->ip_p;
		fi->fi_fl = (hlen > sizeof(ip_t)) ? FI_OPTIONS : 0;
		if (ip->ip_off & 0x3fff)
			fi->fi_fl |= FI_FRAG;
		plen = ip->ip_len;
		fin->fin_dlen = plen - hlen;
	}
#ifdef	USE_INET6
	else if (v == 6) {
		ip6_t *ip6 = (ip6_t *)ip;

		off = 0;
		p = ip6->ip6_nxt;
		fi->fi_p = p;
		fi->fi_ttl = ip6->ip6_hlim;
		tcp = (tcphdr_t *)(ip6 + 1);
		fi->fi_src.in6 = ip6->ip6_src;
		fi->fi_dst.in6 = ip6->ip6_dst;
		fin->fin_id = (u_short)(ip6->ip6_flow & 0xffff);
		fi->fi_tos = 0;
		fi->fi_fl = 0;
		plen = ntohs(ip6->ip6_plen) + sizeof(*ip6);
		fin->fin_dlen = plen;
	}
#endif
	else
		return;

	fin->fin_off = off;
	fin->fin_plen = plen;
	fin->fin_dp = (void *)tcp;

	switch (p)
	{
#ifdef USE_INET6
	case IPPROTO_ICMPV6 :
	{
		int minicmpsz = sizeof(struct icmp6_hdr);
		struct icmp6_hdr *icmp6;

		if (fin->fin_dlen > 1) {
			fin->fin_data[0] = *(u_short *)tcp;

			icmp6 = (struct icmp6_hdr *)tcp;

			switch (icmp6->icmp6_type)
			{
			case ICMP6_ECHO_REPLY :
			case ICMP6_ECHO_REQUEST :
				minicmpsz = ICMP6ERR_MINPKTLEN;
				break;
			case ICMP6_DST_UNREACH :
			case ICMP6_PACKET_TOO_BIG :
			case ICMP6_TIME_EXCEEDED :
			case ICMP6_PARAM_PROB :
				minicmpsz = ICMP6ERR_IPICMPHLEN;
				break;
			default :
				break;
			}
		}

		if (!(plen >= hlen + minicmpsz))
			fi->fi_fl |= FI_SHORT;

		break;
	}
#endif
	case IPPROTO_ICMP :
	{
		int minicmpsz = sizeof(struct icmp);
		icmphdr_t *icmp;

		if (!off && (fin->fin_dlen > 1)) {
			fin->fin_data[0] = *(u_short *)tcp;

			icmp = (icmphdr_t *)tcp;

			if (icmp->icmp_type == ICMP_ECHOREPLY ||
			    icmp->icmp_type == ICMP_ECHO)
				minicmpsz = ICMP_MINLEN;

			/*
			 * type(1) + code(1) + cksum(2) + id(2) seq(2) +
			 * 3*timestamp(3*4)
			 */
			else if (icmp->icmp_type == ICMP_TSTAMP ||
				 icmp->icmp_type == ICMP_TSTAMPREPLY)
				minicmpsz = 20;

			/*
			 * type(1) + code(1) + cksum(2) + id(2) seq(2) +
			 * mask(4)
			 */
			else if (icmp->icmp_type == ICMP_MASKREQ ||
				 icmp->icmp_type == ICMP_MASKREPLY)
				minicmpsz = 12;
		}

		if ((!(plen >= hlen + minicmpsz) && !off) ||
		    (off && off < sizeof(struct icmp)))
			fi->fi_fl |= FI_SHORT;

		break;
	}
	case IPPROTO_TCP :
		fi->fi_fl |= FI_TCPUDP;
#ifdef	USE_INET6
		if (v == 6) {
			if (plen < sizeof(struct tcphdr))
				fi->fi_fl |= FI_SHORT;
		} else
#endif
		if (v == 4) {
			if ((!IPMINLEN(ip, tcphdr) && !off) ||
			     (off && off < sizeof(struct tcphdr)))
				fi->fi_fl |= FI_SHORT;
		}
		if (!(fi->fi_fl & FI_SHORT) && !off)
			fin->fin_tcpf = tcp->th_flags;
		goto getports;
	case IPPROTO_UDP :
		fi->fi_fl |= FI_TCPUDP;
#ifdef	USE_INET6
		if (v == 6) {
			if (plen < sizeof(struct udphdr))
				fi->fi_fl |= FI_SHORT;
		} else
#endif
		if (v == 4) {
			if ((!IPMINLEN(ip, udphdr) && !off) ||
			    (off && off < sizeof(struct udphdr)))
				fi->fi_fl |= FI_SHORT;
		}
getports:
		if (!off && (fin->fin_dlen > 3)) {
			fin->fin_data[0] = ntohs(tcp->th_sport);
			fin->fin_data[1] = ntohs(tcp->th_dport);
		}
		break;
	default :
		break;
	}

#ifdef	USE_INET6
	if (v == 6) {
		fi->fi_optmsk = 0;
		fi->fi_secmsk = 0;
		fi->fi_auth = 0;
		return;
	}
#endif

	for (s = (u_char *)(ip + 1), hlen -= (int)sizeof(*ip); hlen > 0; ) {
		opt = *s;
		if (opt == '\0')
			break;
		else if (opt == IPOPT_NOP)
			ol = 1;
		else {
			if (hlen < 2)
				break;
			ol = (int)*(s + 1);
			if (ol < 2 || ol > hlen)
				break;
		}
		for (i = 9, mv = 4; mv >= 0; ) {
			op = ipopts + i;
			if (opt == (u_char)op->ol_val) {
				optmsk |= op->ol_bit;
				if (opt == IPOPT_SECURITY) {
					struct optlist *sp;
					u_char	sec;
					int j, m;

					sec = *(s + 2);	/* classification */
					for (j = 3, m = 2; m >= 0; ) {
						sp = secopt + j;
						if (sec == sp->ol_val) {
							secmsk |= sp->ol_bit;
							auth = *(s + 3);
							auth *= 256;
							auth += *(s + 4);
							break;
						}
						if (sec < sp->ol_val)
							j -= m--;
						else
							j += m--;
					}
				}
				break;
			}
			if (opt < op->ol_val)
				i -= mv--;
			else
				i += mv--;
		}
		hlen -= ol;
		s += ol;
	}
	if (auth && !(auth & 0x0100))
		auth &= 0xff00;
	fi->fi_optmsk = optmsk;
	fi->fi_secmsk = secmsk;
	fi->fi_auth = auth;
}


/*
 * check an IP packet for TCP/UDP characteristics such as ports and flags.
 */
int fr_tcpudpchk(ft, fin)
frtuc_t *ft;
fr_info_t *fin;
{
	register u_short po, tup;
	register char i;
	register int err = 1;

	/*
	 * Both ports should *always* be in the first fragment.
	 * So far, I cannot find any cases where they can not be.
	 *
	 * compare destination ports
	 */
	if ((i = (int)ft->ftu_dcmp)) {
		po = ft->ftu_dport;
		tup = fin->fin_data[1];
		/*
		 * Do opposite test to that required and
		 * continue if that succeeds.
		 */
		if (!--i && tup != po) /* EQUAL */
			err = 0;
		else if (!--i && tup == po) /* NOTEQUAL */
			err = 0;
		else if (!--i && tup >= po) /* LESSTHAN */
			err = 0;
		else if (!--i && tup <= po) /* GREATERTHAN */
			err = 0;
		else if (!--i && tup > po) /* LT or EQ */
			err = 0;
		else if (!--i && tup < po) /* GT or EQ */
			err = 0;
		else if (!--i &&	   /* Out of range */
			 (tup >= po && tup <= ft->ftu_dtop))
			err = 0;
		else if (!--i &&	   /* In range */
			 (tup <= po || tup >= ft->ftu_dtop))
			err = 0;
	}
	/*
	 * compare source ports
	 */
	if (err && (i = (int)ft->ftu_scmp)) {
		po = ft->ftu_sport;
		tup = fin->fin_data[0];
		if (!--i && tup != po)
			err = 0;
		else if (!--i && tup == po)
			err = 0;
		else if (!--i && tup >= po)
			err = 0;
		else if (!--i && tup <= po)
			err = 0;
		else if (!--i && tup > po)
			err = 0;
		else if (!--i && tup < po)
			err = 0;
		else if (!--i &&	   /* Out of range */
			 (tup >= po && tup <= ft->ftu_stop))
			err = 0;
		else if (!--i &&	   /* In range */
			 (tup <= po || tup >= ft->ftu_stop))
			err = 0;
	}

	/*
	 * If we don't have all the TCP/UDP header, then how can we
	 * expect to do any sort of match on it ?  If we were looking for
	 * TCP flags, then NO match.  If not, then match (which should
	 * satisfy the "short" class too).
	 */
	if (err && (fin->fin_fi.fi_p == IPPROTO_TCP)) {
		if (fin->fin_fi.fi_fl & FI_SHORT)
			return !(ft->ftu_tcpf | ft->ftu_tcpfm);
		/*
		 * Match the flags ?  If not, abort this match.
		 */
		if (ft->ftu_tcpfm &&
		    ft->ftu_tcpf != (fin->fin_tcpf & ft->ftu_tcpfm)) {
			FR_DEBUG(("f. %#x & %#x != %#x\n", fin->fin_tcpf,
				 ft->ftu_tcpfm, ft->ftu_tcpf));
			err = 0;
		}
	}
	return err;
}

/*
 * Check the input/output list of rules for a match and result.
 * Could be per interface, but this gets real nasty when you don't have
 * kernel sauce.
 */
int fr_scanlist(pass, ip, fin, m)
u_32_t pass;
ip_t *ip;
register fr_info_t *fin;
void *m;
{
	register struct frentry *fr;
	register fr_ip_t *fi = &fin->fin_fi;
	int rulen, portcmp = 0, off, skip = 0, logged = 0;
	u_32_t passt;

	fr = fin->fin_fr;
	fin->fin_fr = NULL;
	fin->fin_rule = 0;
	fin->fin_group = 0;
	if (fin->fin_v == 4)
		off = ip->ip_off & IP_OFFMASK;
	else
		off = 0;
	pass |= (fi->fi_fl << 24);

	if ((fi->fi_fl & FI_TCPUDP) && (fin->fin_dlen > 3) && !off)
		portcmp = 1;

	for (rulen = 0; fr; fr = fr->fr_next, rulen++) {
		if (skip) {
			skip--;
			continue;
		}
		/*
		 * In all checks below, a null (zero) value in the
		 * filter struture is taken to mean a wildcard.
		 *
		 * check that we are working for the right interface
		 */
#ifdef	_KERNEL
# if BSD >= 199306
		if (fin->fin_out != 0) {
			if ((fr->fr_oifa &&
			     fr->fr_oifa != ((mb_t *)m)->m_pkthdr.rcvif) ||
			    (fr->fr_ifa && fr->fr_ifa != fin->fin_ifp))
				continue;
		} else
# endif
			if (fr->fr_ifa && fr->fr_ifa != fin->fin_ifp)
				continue;
#else
		if (opts & (OPT_VERBOSE|OPT_DEBUG))
			printf("\n");
		FR_VERBOSE(("%c", (pass & FR_PASS) ? 'p' : 
				  (pass & FR_AUTH) ? 'a' : 'b'));
		if (fr->fr_ifa && fr->fr_ifa != fin->fin_ifp)
			continue;
		FR_VERBOSE((":i"));
#endif
		{
			register u_32_t	*ld, *lm, *lip;
			register int i;

			lip = (u_32_t *)fi;
			lm = (u_32_t *)&fr->fr_mip;
			ld = (u_32_t *)&fr->fr_ip;
			i = ((*lip & *lm) != *ld);
			FR_DEBUG(("0. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
			if (i)
				continue;
			/*
			 * We now know whether the packet version and the
			 * rule version match, along with protocol, ttl and
			 * tos.
			 */
			lip++, lm++, ld++;
			/*
			 * Unrolled loops (4 each, for 32 bits).
			 */
			i |= ((*lip & *lm) != *ld) << 19;
			FR_DEBUG(("1a. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
			if (fi->fi_v == 6) {
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 19;
				FR_DEBUG(("1b. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 19;
				FR_DEBUG(("1c. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 19;
				FR_DEBUG(("1d. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
			} else {
				lip += 3;
				lm += 3;
				ld += 3;
			}
			i ^= (fr->fr_flags & FR_NOTSRCIP);
			if (i)
				continue;
			lip++, lm++, ld++;
			i |= ((*lip & *lm) != *ld) << 20;
			FR_DEBUG(("2a. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
			if (fi->fi_v == 6) {
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 20;
				FR_DEBUG(("2b. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 20;
				FR_DEBUG(("2c. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 20;
				FR_DEBUG(("2d. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
			} else {
				lip += 3;
				lm += 3;
				ld += 3;
			}
			i ^= (fr->fr_flags & FR_NOTDSTIP);
			if (i)
				continue;
			lip++, lm++, ld++;
			i |= ((*lip & *lm) != *ld);
			FR_DEBUG(("3. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
			lip++, lm++, ld++;
			i |= ((*lip & *lm) != *ld);
			FR_DEBUG(("4. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
			if (i)
				continue;
		}

		/*
		 * If a fragment, then only the first has what we're looking
		 * for here...
		 */
		if (!portcmp && (fr->fr_dcmp || fr->fr_scmp || fr->fr_tcpf ||
				 fr->fr_tcpfm))
			continue;
		if (fi->fi_fl & FI_TCPUDP) {
			if (!fr_tcpudpchk(&fr->fr_tuc, fin))
				continue;
		} else if (fr->fr_icmpm || fr->fr_icmp) {
			if ((fi->fi_p != IPPROTO_ICMP) || off ||
			    (fin->fin_dlen < 2))
				continue;
			if ((fin->fin_data[0] & fr->fr_icmpm) != fr->fr_icmp) {
				FR_DEBUG(("i. %#x & %#x != %#x\n",
					 fin->fin_data[0], fr->fr_icmpm,
					 fr->fr_icmp));
				continue;
			}
		}
		FR_VERBOSE(("*"));
		/*
		 * Just log this packet...
		 */
		passt = fr->fr_flags;
#if (BSD >= 199306) && (defined(_KERNEL) || defined(KERNEL))
		if (securelevel <= 0)
#endif
			if ((passt & FR_CALLNOW) && fr->fr_func)
				passt = (*fr->fr_func)(passt, ip, fin);
		fin->fin_fr = fr;
#ifdef  IPFILTER_LOG
		if ((passt & FR_LOGMASK) == FR_LOG) {
			if (!IPLLOG(passt, ip, fin, m)) {
				if (passt & FR_LOGORBLOCK)
					passt |= FR_BLOCK|FR_QUICK;
				ATOMIC_INCL(frstats[fin->fin_out].fr_skip);
			}
			ATOMIC_INCL(frstats[fin->fin_out].fr_pkl);
			logged = 1;
		}
#endif /* IPFILTER_LOG */
		if (!(skip = fr->fr_skip) && (passt & FR_LOGMASK) != FR_LOG)
			pass = passt;
		FR_DEBUG(("pass %#x\n", pass));
		ATOMIC_INCL(fr->fr_hits);
		if (pass & FR_ACCOUNT)
			fr->fr_bytes += (U_QUAD_T)ip->ip_len;
		else
			fin->fin_icode = fr->fr_icode;
		fin->fin_rule = rulen;
		fin->fin_group = fr->fr_group;
		if (fr->fr_grp) {
			fin->fin_fr = fr->fr_grp;
			pass = fr_scanlist(pass, ip, fin, m);
			if (fin->fin_fr == NULL) {
				fin->fin_rule = rulen;
				fin->fin_group = fr->fr_group;
				fin->fin_fr = fr;
			}
			if (pass & FR_DONTCACHE)
				logged = 1;
		}
		if (pass & FR_QUICK)
			break;
	}
	if (logged)
		pass |= FR_DONTCACHE;
	return pass;
}


/*
 * frcheck - filter check
 * check using source and destination addresses/ports in a packet whether
 * or not to pass it on or not.
 */
int fr_check(ip, hlen, ifp, out
#if defined(_KERNEL) && SOLARIS
, qif, mp)
qif_t *qif;
#else
, mp)
#endif
mb_t **mp;
ip_t *ip;
int hlen;
void *ifp;
int out;
{
	/*
	 * The above really sucks, but short of writing a diff
	 */
	fr_info_t frinfo, *fc;
	register fr_info_t *fin = &frinfo;
	int changed, error = EHOSTUNREACH, v = ip->ip_v;
	frentry_t *fr = NULL, *list;
	u_32_t pass, apass;
#if !SOLARIS || !defined(_KERNEL)
	register mb_t *m = *mp;
#endif

#ifdef	_KERNEL
	int p, len, drop = 0, logit = 0;
	mb_t *mc = NULL;
# if !defined(__SVR4) && !defined(__svr4__)
#  ifdef __sgi
	char hbuf[128];
#  endif
	int up;

#  ifdef M_CANFASTFWD
	/*
	 * XXX For now, IP Filter and fast-forwarding of cached flows
	 * XXX are mutually exclusive.  Eventually, IP Filter should
	 * XXX get a "can-fast-forward" filter rule.
	 */
	m->m_flags &= ~M_CANFASTFWD;
#  endif /* M_CANFASTFWD */
#  ifdef CSUM_DELAY_DATA
	/*
	 * disable delayed checksums.
	 */
	if (m->m_pkthdr.csum_flags & CSUM_DELAY_DATA) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum_flags &= ~CSUM_DELAY_DATA;
	}
#  endif /* CSUM_DELAY_DATA */

# ifdef	USE_INET6
	if (v == 6) {
		len = ntohs(((ip6_t*)ip)->ip6_plen);
		if (!len)
			return -1;	/* potential jumbo gram */
		len += sizeof(ip6_t);
		p = ((ip6_t *)ip)->ip6_nxt;
	} else
# endif
	{
		p = ip->ip_p;
		len = ip->ip_len;
	}

	if ((p == IPPROTO_TCP || p == IPPROTO_UDP ||
	    (v == 4 && p == IPPROTO_ICMP)
# ifdef USE_INET6
	    || (v == 6 && p == IPPROTO_ICMPV6)
# endif
	   )) {
		int plen = 0;

		if ((v == 6) || (ip->ip_off & IP_OFFMASK) == 0)
			switch(p)
			{
			case IPPROTO_TCP:
				plen = sizeof(tcphdr_t);
				break;
			case IPPROTO_UDP:
				plen = sizeof(udphdr_t);
				break;
			/* 96 - enough for complete ICMP error IP header */
			case IPPROTO_ICMP:
				plen = ICMPERR_MAXPKTLEN - sizeof(ip_t);
				break;
# ifdef USE_INET6
	    		case IPPROTO_ICMPV6 :
				/*
				 * XXX does not take intermediate header
				 * into account
				 */
				plen = ICMP6ERR_MINPKTLEN + 8 - sizeof(ip6_t);
				break;
# endif
			}
		up = MIN(hlen + plen, len);

		if (up > m->m_len) {
#  ifdef __sgi
	/* Under IRIX, avoid m_pullup as it makes ping <hostname> panic */
			if ((up > sizeof(hbuf)) || (m_length(m) < up)) {
				ATOMIC_INCL(frstats[out].fr_pull[1]);
				return -1;
			}
			m_copydata(m, 0, up, hbuf);
			ATOMIC_INCL(frstats[out].fr_pull[0]);
			ip = (ip_t *)hbuf;
#  else /* __ sgi */
#   ifndef linux
			if ((*mp = m_pullup(m, up)) == NULL) {
				ATOMIC_INCL(frstats[out].fr_pull[1]);
				return -1;
			} else {
				ATOMIC_INCL(frstats[out].fr_pull[0]);
				m = *mp;
				ip = mtod(m, ip_t *);
			}
#   endif /* !linux */
#  endif /* __sgi */
		} else
			up = 0;
	} else
		up = 0;
# endif /* !defined(__SVR4) && !defined(__svr4__) */
# if SOLARIS
	mb_t *m = qif->qf_m;

	if ((u_int)ip & 0x3)
		return 2;
	fin->fin_qfm = m;
	fin->fin_qif = qif;
# endif
#endif /* _KERNEL */
	
	/*
	 * Be careful here: ip_id is in network byte order when called
	 * from ip_output()
	 */
	if ((out) && (v == 4))
		ip->ip_id = ntohs(ip->ip_id);

	changed = 0;
	fin->fin_ifp = ifp;
	fin->fin_v = v;
	fin->fin_out = out;
	fin->fin_mp = mp;
	fr_makefrip(hlen, ip, fin);

#ifdef _KERNEL
# ifdef	USE_INET6
	if (v == 6) {
		ATOMIC_INCL(frstats[0].fr_ipv6[out]);
		if (((ip6_t *)ip)->ip6_hlim < fr_minttl) {
			ATOMIC_INCL(frstats[0].fr_badttl);
			if (fr_minttllog)
				logit = -2;
		}
	} else
# endif
	if (!out) {
		if (fr_chksrc && !fr_verifysrc(ip->ip_src, ifp)) {
			ATOMIC_INCL(frstats[0].fr_badsrc);
			if (fr_chksrc == 2)
				logit = -2;
		} else if (ip->ip_ttl < fr_minttl) {
			ATOMIC_INCL(frstats[0].fr_badttl);
			if (fr_minttllog)
				logit = -3;
		}
	}
	if (drop) {
# ifdef	IPFILTER_LOG
		if (logit) {
			fin->fin_group = logit;
			pass = FR_INQUE|FR_NOMATCH|FR_LOGB;
			(void) IPLLOG(pass, ip, fin, m);
		}
# endif
# if !SOLARIS
		m_freem(m);
# endif
		return error;
	}
#endif
	pass = fr_pass;
	if (fin->fin_fi.fi_fl & FI_SHORT) {
		ATOMIC_INCL(frstats[out].fr_short);
	}

	READ_ENTER(&ipf_mutex);

	if (fin->fin_fi.fi_fl & FI_SHORT)
		ATOMIC_INCL(frstats[out].fr_short);
	
	/*
	 * Check auth now.  This, combined with the check below to see if apass
	 * is 0 is to ensure that we don't count the packet twice, which can
	 * otherwise occur when we reprocess it.  As it is, we only count it
	 * after it has no auth. table matchup.  This also stops NAT from
	 * occuring until after the packet has been auth'd.
	 */
	apass = fr_checkauth(ip, fin);

	if (!out) {
#ifdef	USE_INET6
		if (v == 6)
			list = ipacct6[0][fr_active];
		else
#endif
			list = ipacct[0][fr_active];
		changed = ip_natin(ip, fin);
		if (!apass && (fin->fin_fr = list) &&
		    (fr_scanlist(FR_NOMATCH, ip, fin, m) & FR_ACCOUNT)) {
			ATOMIC_INCL(frstats[0].fr_acct);
		}
	}

	if (apass || (!(fr = ipfr_knownfrag(ip, fin)) &&
	    !(fr = fr_checkstate(ip, fin)))) {
		/*
		 * If a packet is found in the auth table, then skip checking
		 * the access lists for permission but we do need to consider
		 * the result as if it were from the ACL's.
		 */
		if (!apass) {
			fc = frcache + out;
			if (!bcmp((char *)fin, (char *)fc, FI_CSIZE)) {
				/*
				 * copy cached data so we can unlock the mutex
				 * earlier.
				 */
				bcopy((char *)fc, (char *)fin, FI_COPYSIZE);
				ATOMIC_INCL(frstats[out].fr_chit);
				if ((fr = fin->fin_fr)) {
					ATOMIC_INCL(fr->fr_hits);
					pass = fr->fr_flags;
				}
			} else {
#ifdef	USE_INET6
				if (v == 6)
					list = ipfilter6[out][fr_active];
				else
#endif
					list = ipfilter[out][fr_active];
				if ((fin->fin_fr = list))
					pass = fr_scanlist(fr_pass, ip, fin, m);
				if (!(pass & (FR_KEEPSTATE|FR_DONTCACHE)))
					bcopy((char *)fin, (char *)fc,
					      FI_COPYSIZE);
				if (pass & FR_NOMATCH) {
					ATOMIC_INCL(frstats[out].fr_nom);
				}
			}
			fr = fin->fin_fr;
		} else
			pass = apass;

		/*
		 * If we fail to add a packet to the authorization queue,
		 * then we drop the packet later.  However, if it was added
		 * then pretend we've dropped it already.
		 */
		if ((pass & FR_AUTH))
			if (fr_newauth((mb_t *)m, fin, ip) != 0)
#ifdef	_KERNEL
				m = *mp = NULL;
#else
				;
#endif

		if (pass & FR_PREAUTH) {
			READ_ENTER(&ipf_auth);
			if ((fin->fin_fr = ipauth) &&
			    (pass = fr_scanlist(0, ip, fin, m))) {
				ATOMIC_INCL(fr_authstats.fas_hits);
			} else {
				ATOMIC_INCL(fr_authstats.fas_miss);
			}
			RWLOCK_EXIT(&ipf_auth);
		}

		fin->fin_fr = fr;
		if ((pass & (FR_KEEPFRAG|FR_KEEPSTATE)) == FR_KEEPFRAG) {
			if (fin->fin_fi.fi_fl & FI_FRAG) {
				if (ipfr_newfrag(ip, fin, pass) == -1) {
					ATOMIC_INCL(frstats[out].fr_bnfr);
				} else {
					ATOMIC_INCL(frstats[out].fr_nfr);
				}
			} else {
				ATOMIC_INCL(frstats[out].fr_cfr);
			}
		}
		if (pass & FR_KEEPSTATE) {
			if (fr_addstate(ip, fin, 0) == NULL) {
				ATOMIC_INCL(frstats[out].fr_bads);
			} else {
				ATOMIC_INCL(frstats[out].fr_ads);
			}
		}
	} else if (fr != NULL) {
		pass = fr->fr_flags;
		if (pass & FR_LOGFIRST)
			pass &= ~(FR_LOGFIRST|FR_LOG);
	}

#if (BSD >= 199306) && (defined(_KERNEL) || defined(KERNEL))
	if (securelevel <= 0)
#endif
		if (fr && fr->fr_func && !(pass & FR_CALLNOW))
			pass = (*fr->fr_func)(pass, ip, fin);

	/*
	 * Only count/translate packets which will be passed on, out the
	 * interface.
	 */
	if (out && (pass & FR_PASS)) {
#ifdef	USE_INET6
		if (v == 6)
			list = ipacct6[1][fr_active];
		else
#endif
			list = ipacct[1][fr_active];
		if ((fin->fin_fr = list) &&
		    (fr_scanlist(FR_NOMATCH, ip, fin, m) & FR_ACCOUNT)) {
			ATOMIC_INCL(frstats[1].fr_acct);
		}
		fin->fin_fr = fr;
		changed = ip_natout(ip, fin);
	} else
		fin->fin_fr = fr;
	RWLOCK_EXIT(&ipf_mutex);

#ifdef	IPFILTER_LOG
	if ((fr_flags & FF_LOGGING) || (pass & FR_LOGMASK)) {
		if ((fr_flags & FF_LOGNOMATCH) && (pass & FR_NOMATCH)) {
			pass |= FF_LOGNOMATCH;
			ATOMIC_INCL(frstats[out].fr_npkl);
			goto logit;
		} else if (((pass & FR_LOGMASK) == FR_LOGP) ||
		    ((pass & FR_PASS) && (fr_flags & FF_LOGPASS))) {
			if ((pass & FR_LOGMASK) != FR_LOGP)
				pass |= FF_LOGPASS;
			ATOMIC_INCL(frstats[out].fr_ppkl);
			goto logit;
		} else if (((pass & FR_LOGMASK) == FR_LOGB) ||
			   ((pass & FR_BLOCK) && (fr_flags & FF_LOGBLOCK))) {
			if ((pass & FR_LOGMASK) != FR_LOGB)
				pass |= FF_LOGBLOCK;
			ATOMIC_INCL(frstats[out].fr_bpkl);
logit:
			if (!IPLLOG(pass, ip, fin, m)) {
				ATOMIC_INCL(frstats[out].fr_skip);
				if ((pass & (FR_PASS|FR_LOGORBLOCK)) ==
				    (FR_PASS|FR_LOGORBLOCK))
					pass ^= FR_PASS|FR_BLOCK;
			}
		}
	}
#endif /* IPFILTER_LOG */

	if ((out) && (v == 4))
		ip->ip_id = htons(ip->ip_id);

#ifdef	_KERNEL
	/*
	 * Only allow FR_DUP to work if a rule matched - it makes no sense to
	 * set FR_DUP as a "default" as there are no instructions about where
	 * to send the packet.
	 */
	if (fr && (pass & FR_DUP))
# if	SOLARIS
		mc = dupmsg(m);
# else
#  ifndef linux
		mc = m_copy(m, 0, M_COPYALL);
#  else
		;
#  endif
# endif
#endif
	if (pass & FR_PASS) {
		ATOMIC_INCL(frstats[out].fr_pass);
	} else if (pass & FR_BLOCK) {
		ATOMIC_INCL(frstats[out].fr_block);
		/*
		 * Should we return an ICMP packet to indicate error
		 * status passing through the packet filter ?
		 * WARNING: ICMP error packets AND TCP RST packets should
		 * ONLY be sent in repsonse to incoming packets.  Sending them
		 * in response to outbound packets can result in a panic on
		 * some operating systems.
		 */
		if (!out) {
#ifdef	_KERNEL
			if (pass & FR_RETICMP) {
				int dst;

				if ((pass & FR_RETMASK) == FR_FAKEICMP)
					dst = 1;
				else
					dst = 0;
				send_icmp_err(ip, ICMP_UNREACH, fin, dst);
				ATOMIC_INCL(frstats[0].fr_ret);
			} else if (((pass & FR_RETMASK) == FR_RETRST) &&
				   !(fin->fin_fi.fi_fl & FI_SHORT)) {
				if (send_reset(ip, fin) == 0) {
					ATOMIC_INCL(frstats[1].fr_ret);
				}
			}
#else
			if ((pass & FR_RETMASK) == FR_RETICMP) {
				verbose("- ICMP unreachable sent\n");
				ATOMIC_INCL(frstats[0].fr_ret);
			} else if ((pass & FR_RETMASK) == FR_FAKEICMP) {
				verbose("- forged ICMP unreachable sent\n");
				ATOMIC_INCL(frstats[0].fr_ret);
			} else if (((pass & FR_RETMASK) == FR_RETRST) &&
				   !(fin->fin_fi.fi_fl & FI_SHORT)) {
				verbose("- TCP RST sent\n");
				ATOMIC_INCL(frstats[1].fr_ret);
			}
#endif
		} else {
			if (pass & FR_RETRST)
				error = ECONNRESET;
		}
	}

	/*
	 * If we didn't drop off the bottom of the list of rules (and thus
	 * the 'current' rule fr is not NULL), then we may have some extra
	 * instructions about what to do with a packet.
	 * Once we're finished return to our caller, freeing the packet if
	 * we are dropping it (* BSD ONLY *).
	 */
	if ((changed == -1) && (pass & FR_PASS)) {
		pass &= ~FR_PASS;
		pass |= FR_BLOCK;
	}
#if defined(_KERNEL)
# if !SOLARIS
#  if !defined(linux)
	if (fr) {
		frdest_t *fdp = &fr->fr_tif;

		if (((pass & FR_FASTROUTE) && !out) ||
		    (fdp->fd_ifp && fdp->fd_ifp != (struct ifnet *)-1)) {
			if (ipfr_fastroute(m, fin, fdp) == 0)
				m = *mp = NULL;
		}
		if (mc)
			ipfr_fastroute(mc, fin, &fr->fr_dif);
	}
	if (!(pass & FR_PASS) && m)
		m_freem(m);
#   ifdef __sgi
	else if (changed && up && m)
		m_copyback(m, 0, up, hbuf);
#   endif
#  endif /* !linux */
# else /* !SOLARIS */
	if (fr) {
		frdest_t *fdp = &fr->fr_tif;

		if (((pass & FR_FASTROUTE) && !out) ||
		    (fdp->fd_ifp && fdp->fd_ifp != (struct ifnet *)-1)) {
			if (ipfr_fastroute(ip, m, mp, fin, fdp) == 0)
				m = *mp = NULL;
		}
		if (mc)
			ipfr_fastroute(ip, mc, mp, fin, &fr->fr_dif);
	}
# endif /* !SOLARIS */
	return (pass & (FR_PASS|FR_AUTH)) ? 0 : error;
#else /* _KERNEL */
	if (pass & FR_NOMATCH)
		return 1;
	if (pass & FR_PASS)
		return 0;
	if (pass & FR_AUTH)
		return -2;
	return -1;
#endif /* _KERNEL */
}


/*
 * ipf_cksum
 * addr should be 16bit aligned and len is in bytes.
 * length is in bytes
 */
u_short ipf_cksum(addr, len)
register u_short *addr;
register int len;
{
	register u_32_t sum = 0;

	for (sum = 0; len > 1; len -= 2)
		sum += *addr++;

	/* mop up an odd byte, if necessary */
	if (len == 1)
		sum += *(u_char *)addr;

	/*
	 * add back carry outs from top 16 bits to low 16 bits
	 */
	sum = (sum >> 16) + (sum & 0xffff);	/* add hi 16 to low 16 */
	sum += (sum >> 16);			/* add carry */
	return (u_short)(~sum);
}


/*
 * NB: This function assumes we've pullup'd enough for all of the IP header
 * and the TCP header.  We also assume that data blocks aren't allocated in
 * odd sizes.
 */
u_short fr_tcpsum(m, ip, tcp)
mb_t *m;
ip_t *ip;
tcphdr_t *tcp;
{
	u_short *sp, slen, ts;
	u_int sum, sum2;
	int hlen;

	/*
	 * Add up IP Header portion
	 */
	hlen = ip->ip_hl << 2;
	slen = ip->ip_len - hlen;
	sum = htons((u_short)ip->ip_p);
	sum += htons(slen);
	sp = (u_short *)&ip->ip_src;
	sum += *sp++;	/* ip_src */
	sum += *sp++;
	sum += *sp++;	/* ip_dst */
	sum += *sp++;
	ts = tcp->th_sum;
	tcp->th_sum = 0;
#ifdef	KERNEL
# if SOLARIS
	sum2 = ip_cksum(m, hlen, sum);	/* hlen == offset */
	sum2 = (sum2 & 0xffff) + (sum2 >> 16);
	sum2 = ~sum2 & 0xffff;
# else /* SOLARIS */
#  if defined(BSD) || defined(sun)
#   if BSD >= 199306
	m->m_data += hlen;
#   else
	m->m_off += hlen;
#   endif
	m->m_len -= hlen;
	sum2 = in_cksum(m, slen);
	m->m_len += hlen;
#   if BSD >= 199306
	m->m_data -= hlen;
#   else
	m->m_off -= hlen;
#   endif
	/*
	 * Both sum and sum2 are partial sums, so combine them together.
	 */
	sum = (sum & 0xffff) + (sum >> 16);
	sum = ~sum & 0xffff;
	sum2 += sum;
	sum2 = (sum2 & 0xffff) + (sum2 >> 16);
#  else /* defined(BSD) || defined(sun) */
{
	union {
		u_char	c[2];
		u_short	s;
	} bytes;
	u_short len = ip->ip_len;
# if defined(__sgi)
	int add;
# endif

	/*
	 * Add up IP Header portion
	 */
	sp = (u_short *)&ip->ip_src;
	len -= (ip->ip_hl << 2);
	sum = ntohs(IPPROTO_TCP);
	sum += htons(len);
	sum += *sp++;	/* ip_src */
	sum += *sp++;
	sum += *sp++;	/* ip_dst */
	sum += *sp++;
	if (sp != (u_short *)tcp)
		sp = (u_short *)tcp;
	sum += *sp++;	/* sport */
	sum += *sp++;	/* dport */
	sum += *sp++;	/* seq */
	sum += *sp++;
	sum += *sp++;	/* ack */
	sum += *sp++;
	sum += *sp++;	/* off */
	sum += *sp++;	/* win */
	sum += *sp++;	/* Skip over checksum */
	sum += *sp++;	/* urp */

# ifdef	__sgi
	/*
	 * In case we had to copy the IP & TCP header out of mbufs,
	 * skip over the mbuf bits which are the header
	 */
	if ((caddr_t)ip != mtod(m, caddr_t)) {
		hlen = (caddr_t)sp - (caddr_t)ip;
		while (hlen) {
			add = MIN(hlen, m->m_len);
			sp = (u_short *)(mtod(m, caddr_t) + add);
			hlen -= add;
			if (add == m->m_len) {
				m = m->m_next;
				if (!hlen) {
					if (!m)
						break;
					sp = mtod(m, u_short *);
				}
				PANIC((!m),("fr_tcpsum(1): not enough data"));
			}
		}
	}
# endif

	if (!(len -= sizeof(*tcp)))
		goto nodata;
	while (len > 1) {
		if (((caddr_t)sp - mtod(m, caddr_t)) >= m->m_len) {
			m = m->m_next;
			PANIC((!m),("fr_tcpsum(2): not enough data"));
			sp = mtod(m, u_short *);
		}
		if (((caddr_t)(sp + 1) - mtod(m, caddr_t)) > m->m_len) {
			bytes.c[0] = *(u_char *)sp;
			m = m->m_next;
			PANIC((!m),("fr_tcpsum(3): not enough data"));
			sp = mtod(m, u_short *);
			bytes.c[1] = *(u_char *)sp;
			sum += bytes.s;
			sp = (u_short *)((u_char *)sp + 1);
		}
		if ((u_long)sp & 1) {
			bcopy((char *)sp++, (char *)&bytes.s, sizeof(bytes.s));
			sum += bytes.s;
		} else
			sum += *sp++;
		len -= 2;
	}
	if (len)
		sum += ntohs(*(u_char *)sp << 8);
nodata:
	while (sum > 0xffff)
		sum = (sum & 0xffff) + (sum >> 16);
	sum2 = (u_short)(~sum & 0xffff);
}
#  endif /*  defined(BSD) || defined(sun) */
# endif /* SOLARIS */
#else /* KERNEL */
	sum2 = 0;
#endif /* KERNEL */
	tcp->th_sum = ts;
	return sum2;
}


#if defined(_KERNEL) && ( ((BSD < 199306) && !SOLARIS) || defined(__sgi) )
/*
 * Copyright (c) 1982, 1986, 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uipc_mbuf.c	8.2 (Berkeley) 1/4/94
 * $IPFilter: fil.c,v 2.35.2.31 2001/04/03 15:46:41 darrenr Exp $
 */
/*
 * Copy data from an mbuf chain starting "off" bytes from the beginning,
 * continuing for "len" bytes, into the indicated buffer.
 */
void
m_copydata(m, off, len, cp)
	register mb_t *m;
	register int off;
	register int len;
	caddr_t cp;
{
	register unsigned count;

	if (off < 0 || len < 0)
		panic("m_copydata");
	while (off > 0) {
		if (m == 0)
			panic("m_copydata");
		if (off < m->m_len)
			break;
		off -= m->m_len;
		m = m->m_next;
	}
	while (len > 0) {
		if (m == 0)
			panic("m_copydata");
		count = MIN(m->m_len - off, len);
		bcopy(mtod(m, caddr_t) + off, cp, count);
		len -= count;
		cp += count;
		off = 0;
		m = m->m_next;
	}
}


# ifndef linux
/*
 * Copy data from a buffer back into the indicated mbuf chain,
 * starting "off" bytes from the beginning, extending the mbuf
 * chain if necessary.
 */
void
m_copyback(m0, off, len, cp)
	struct	mbuf *m0;
	register int off;
	register int len;
	caddr_t cp;
{
	register int mlen;
	register struct mbuf *m = m0, *n;
	int totlen = 0;

	if (m0 == 0)
		return;
	while (off > (mlen = m->m_len)) {
		off -= mlen;
		totlen += mlen;
		if (m->m_next == 0) {
			n = m_getclr(M_DONTWAIT, m->m_type);
			if (n == 0)
				goto out;
			n->m_len = min(MLEN, len + off);
			m->m_next = n;
		}
		m = m->m_next;
	}
	while (len > 0) {
		mlen = min (m->m_len - off, len);
		bcopy(cp, off + mtod(m, caddr_t), (unsigned)mlen);
		cp += mlen;
		len -= mlen;
		mlen += off;
		off = 0;
		totlen += mlen;
		if (len == 0)
			break;
		if (m->m_next == 0) {
			n = m_get(M_DONTWAIT, m->m_type);
			if (n == 0)
				break;
			n->m_len = min(MLEN, len);
			m->m_next = n;
		}
		m = m->m_next;
	}
out:
#if 0
	if (((m = m0)->m_flags & M_PKTHDR) && (m->m_pkthdr.len < totlen))
		m->m_pkthdr.len = totlen;
#endif
	return;
}
# endif /* linux */
#endif /* (_KERNEL) && ( ((BSD < 199306) && !SOLARIS) || __sgi) */


frgroup_t *fr_findgroup(num, flags, which, set, fgpp)
u_32_t num, flags;
minor_t which;
int set;
frgroup_t ***fgpp;
{
	frgroup_t *fg, **fgp;

	if (which == IPL_LOGAUTH)
		fgp = &ipfgroups[2][set];
	else if (flags & FR_ACCOUNT)
		fgp = &ipfgroups[1][set];
	else if (flags & (FR_OUTQUE|FR_INQUE))
		fgp = &ipfgroups[0][set];
	else
		return NULL;
	num &= 0xffff;

	while ((fg = *fgp))
		if (fg->fg_num == num)
			break;
		else
			fgp = &fg->fg_next;
	if (fgpp)
		*fgpp = fgp;
	return fg;
}


frgroup_t *fr_addgroup(num, fp, which, set)
u_32_t num;
frentry_t *fp;
minor_t which;
int set;
{
	frgroup_t *fg, **fgp;

	if ((fg = fr_findgroup(num, fp->fr_flags, which, set, &fgp)))
		return fg;

	KMALLOC(fg, frgroup_t *);
	if (fg) {
		fg->fg_num = num;
		fg->fg_next = *fgp;
		fg->fg_head = fp;
		fg->fg_start = &fp->fr_grp;
		*fgp = fg;
	}
	return fg;
}


void fr_delgroup(num, flags, which, set)
u_32_t num, flags;
minor_t which;
int set;
{
	frgroup_t *fg, **fgp;
 
	if (!(fg = fr_findgroup(num, flags, which, set, &fgp)))
		return;
 
	*fgp = fg->fg_next;
	KFREE(fg);
}



/*
 * recursively flush rules from the list, descending groups as they are
 * encountered.  if a rule is the head of a group and it has lost all its
 * group members, then also delete the group reference.
 */
static int frflushlist(set, unit, nfreedp, listp)
int set;
minor_t unit;
int *nfreedp;
frentry_t **listp;
{
	register int freed = 0, i;
	register frentry_t *fp;

	while ((fp = *listp)) {
		*listp = fp->fr_next;
		if (fp->fr_grp) {
			i = frflushlist(set, unit, nfreedp, &fp->fr_grp);
			MUTEX_ENTER(&ipf_rw);
			fp->fr_ref -= i;
			MUTEX_EXIT(&ipf_rw);
		}

		ATOMIC_DEC32(fp->fr_ref);
		if (fp->fr_grhead) {
			fr_delgroup(fp->fr_grhead, fp->fr_flags, 
				    unit, set);
			fp->fr_grhead = 0;
		}
		if (fp->fr_ref == 0) {
			KFREE(fp);
			freed++;
		} else
			fp->fr_next = NULL;
	}
	*nfreedp += freed;
	return freed;
}


int frflush(unit, flags)
minor_t unit;
int flags;
{
	int flushed = 0, set;

	if (unit != IPL_LOGIPF)
		return 0;
	WRITE_ENTER(&ipf_mutex);
	bzero((char *)frcache, sizeof(frcache[0]) * 2);

	set = fr_active;
	if (flags & FR_INACTIVE)
		set = 1 - set;

	if (flags & FR_OUTQUE) {
#ifdef	USE_INET6
		(void) frflushlist(set, unit, &flushed, &ipfilter6[1][set]);
		(void) frflushlist(set, unit, &flushed, &ipacct6[1][set]);
#endif
		(void) frflushlist(set, unit, &flushed, &ipfilter[1][set]);
		(void) frflushlist(set, unit, &flushed, &ipacct[1][set]);
	}
	if (flags & FR_INQUE) {
#ifdef	USE_INET6
		(void) frflushlist(set, unit, &flushed, &ipfilter6[0][set]);
		(void) frflushlist(set, unit, &flushed, &ipacct6[0][set]);
#endif
		(void) frflushlist(set, unit, &flushed, &ipfilter[0][set]);
		(void) frflushlist(set, unit, &flushed, &ipacct[0][set]);
	}
	RWLOCK_EXIT(&ipf_mutex);
	return flushed;
}


char *memstr(src, dst, slen, dlen)
char *src, *dst;
int slen, dlen;
{
	char *s = NULL;

	while (dlen >= slen) {
		if (bcmp(src, dst, slen) == 0) {
			s = dst;
			break;
		}
		dst++;
		dlen--;
	}
	return s;
}


void fixskip(listp, rp, addremove)
frentry_t **listp, *rp;
int addremove;
{
	frentry_t *fp;
	int rules = 0, rn = 0;

	for (fp = *listp; fp && (fp != rp); fp = fp->fr_next, rules++)
		;

	if (!fp)
		return;

	for (fp = *listp; fp && (fp != rp); fp = fp->fr_next, rn++)
		if (fp->fr_skip && (rn + fp->fr_skip >= rules))
			fp->fr_skip += addremove;
}


#ifdef	_KERNEL
/*
 * count consecutive 1's in bit mask.  If the mask generated by counting
 * consecutive 1's is different to that passed, return -1, else return #
 * of bits.
 */
int	countbits(ip)
u_32_t	ip;
{
	u_32_t	ipn;
	int	cnt = 0, i, j;

	ip = ipn = ntohl(ip);
	for (i = 32; i; i--, ipn *= 2)
		if (ipn & 0x80000000)
			cnt++;
		else
			break;
	ipn = 0;
	for (i = 32, j = cnt; i; i--, j--) {
		ipn *= 2;
		if (j > 0)
			ipn++;
	}
	if (ipn == ip)
		return cnt;
	return -1;
}


/*
 * return the first IP Address associated with an interface
 */
int fr_ifpaddr(v, ifptr, inp)
int v;
void *ifptr;
struct in_addr *inp;
{
# ifdef	USE_INET6
	struct in6_addr *inp6 = NULL;
# endif
# if SOLARIS
	ill_t *ill = ifptr;
# else
	struct ifnet *ifp = ifptr;
# endif
	struct in_addr in;

# if SOLARIS
#  ifdef	USE_INET6
	if (v == 6) {
		struct in6_addr in6;

		/*
		 * First is always link local.
		 */
		if (ill->ill_ipif->ipif_next)
			in6 = ill->ill_ipif->ipif_next->ipif_v6lcl_addr;
		else
			bzero((char *)&in6, sizeof(in6));
		bcopy((char *)&in6, (char *)inp, sizeof(in6));
	} else
#  endif
	{
		in.s_addr = ill->ill_ipif->ipif_local_addr;
		*inp = in;
	}
# else /* SOLARIS */
#  if linux
	;
#  else /* linux */
	struct sockaddr_in *sin;
	struct ifaddr *ifa;

#   if	(__FreeBSD_version >= 300000)
	ifa = TAILQ_FIRST(&ifp->if_addrhead);
#   else
#    if defined(__NetBSD__) || defined(__OpenBSD__)
	ifa = ifp->if_addrlist.tqh_first;
#    else
#     if defined(__sgi) && defined(IFF_DRVRLOCK) /* IRIX 6 */
	ifa = &((struct in_ifaddr *)ifp->in_ifaddr)->ia_ifa;
#     else
	ifa = ifp->if_addrlist;
#     endif
#    endif /* __NetBSD__ || __OpenBSD__ */
#   endif /* __FreeBSD_version >= 300000 */
#   if (BSD < 199306) && !(/*IRIX6*/defined(__sgi) && defined(IFF_DRVRLOCK))
	sin = (struct sockaddr_in *)&ifa->ifa_addr;
#   else
	sin = (struct sockaddr_in *)ifa->ifa_addr;
	while (sin && ifa) {
		if ((v == 4) && (sin->sin_family == AF_INET))
			break;
#    ifdef USE_INET6
		if ((v == 6) && (sin->sin_family == AF_INET6)) {
			inp6 = &((struct sockaddr_in6 *)sin)->sin6_addr;
			if (!IN6_IS_ADDR_LINKLOCAL(inp6) &&
			    !IN6_IS_ADDR_LOOPBACK(inp6))
				break;
		}
#    endif
#    if	(__FreeBSD_version >= 300000)
		ifa = TAILQ_NEXT(ifa, ifa_link);
#    else
#     if defined(__NetBSD__) || defined(__OpenBSD__)
		ifa = ifa->ifa_list.tqe_next;
#     else
		ifa = ifa->ifa_next;
#     endif
#    endif /* __FreeBSD_version >= 300000 */
		if (ifa)
			sin = (struct sockaddr_in *)ifa->ifa_addr;
	}
	if (ifa == NULL)
		sin = NULL;
	if (sin == NULL)
		return -1;
#   endif /* (BSD < 199306) && (!__sgi && IFF_DRVLOCK) */
#    ifdef	USE_INET6
	if (v == 6)
		bcopy((char *)inp6, (char *)inp, sizeof(*inp6));
	else
#    endif
	{
		in = sin->sin_addr;
		*inp = in;
	}
#  endif /* linux */
# endif /* SOLARIS */
	return 0;
}


static void frsynclist(fr)
register frentry_t *fr;
{
	for (; fr; fr = fr->fr_next) {
		if (fr->fr_ifa != NULL) {
			fr->fr_ifa = GETUNIT(fr->fr_ifname, fr->fr_ip.fi_v);
			if (fr->fr_ifa == NULL)
				fr->fr_ifa = (void *)-1;
		}
		if (fr->fr_grp)
			frsynclist(fr->fr_grp);
	}
}


void frsync()
{
# if !SOLARIS
	register struct ifnet *ifp;

#  if defined(__OpenBSD__) || ((NetBSD >= 199511) && (NetBSD < 1991011)) || \
     (defined(__FreeBSD_version) && (__FreeBSD_version >= 300000))
#   if (NetBSD >= 199905) || defined(__OpenBSD__)
	for (ifp = ifnet.tqh_first; ifp; ifp = ifp->if_list.tqe_next)
#   else
	for (ifp = ifnet.tqh_first; ifp; ifp = ifp->if_link.tqe_next)
#   endif
#  else
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
#  endif
	{
		ip_natsync(ifp);
		ip_statesync(ifp);
	}
	ip_natsync((struct ifnet *)-1);
# endif

	WRITE_ENTER(&ipf_mutex);
	frsynclist(ipacct[0][fr_active]);
	frsynclist(ipacct[1][fr_active]);
	frsynclist(ipfilter[0][fr_active]);
	frsynclist(ipfilter[1][fr_active]);
#ifdef	USE_INET6
	frsynclist(ipacct6[0][fr_active]);
	frsynclist(ipacct6[1][fr_active]);
	frsynclist(ipfilter6[0][fr_active]);
	frsynclist(ipfilter6[1][fr_active]);
#endif
	RWLOCK_EXIT(&ipf_mutex);
}


/*
 * In the functions below, bcopy() is called because the pointer being
 * copied _from_ in this instance is a pointer to a char buf (which could
 * end up being unaligned) and on the kernel's local stack.
 */
int ircopyptr(a, b, c)
void *a, *b;
size_t c;
{
	caddr_t ca;
	int err;

#if SOLARIS
	if (copyin(a, (char *)&ca, sizeof(ca)))
		return EFAULT;
#else
	bcopy(a, &ca, sizeof(ca));
#endif
	err = copyin(ca, b, c);
	if (err)
		err = EFAULT;
	return err;
}


int iwcopyptr(a, b, c)
void *a, *b;
size_t c;
{
	caddr_t ca;
	int err;

#if SOLARIS
	if (copyin(b, (char *)&ca, sizeof(ca)))
		return EFAULT;
#else
	bcopy(b, &ca, sizeof(ca));
#endif
	err = copyout(a, ca, c);
	if (err)
		err = EFAULT;
	return err;
}

#else /* _KERNEL */


/*
 * return the first IP Address associated with an interface
 */
int fr_ifpaddr(v, ifptr, inp)
int v;
void *ifptr;
struct in_addr *inp;
{
	return 0;
}


int ircopyptr(a, b, c)
void *a, *b;
size_t c;
{
	caddr_t ca;

	bcopy(a, &ca, sizeof(ca));
	bcopy(ca, b, c);
	return 0;
}


int iwcopyptr(a, b, c)
void *a, *b;
size_t c;
{
	caddr_t ca;

	bcopy(b, &ca, sizeof(ca));
	bcopy(a, ca, c);
	return 0;
}


#endif


int fr_lock(data, lockp)
caddr_t data;
int *lockp;
{
	int arg, error;

	error = IRCOPY(data, (caddr_t)&arg, sizeof(arg));
	if (!error) {
		error = IWCOPY((caddr_t)lockp, data, sizeof(*lockp));
		if (!error)
			*lockp = arg;
	}
	return error;
}


void fr_getstat(fiop)
friostat_t *fiop;
{
	bcopy((char *)frstats, (char *)fiop->f_st, sizeof(filterstats_t) * 2);
	fiop->f_locks[0] = fr_state_lock;
	fiop->f_locks[1] = fr_nat_lock;
	fiop->f_locks[2] = fr_frag_lock;
	fiop->f_locks[3] = fr_auth_lock;
	fiop->f_fin[0] = ipfilter[0][0];
	fiop->f_fin[1] = ipfilter[0][1];
	fiop->f_fout[0] = ipfilter[1][0];
	fiop->f_fout[1] = ipfilter[1][1];
	fiop->f_acctin[0] = ipacct[0][0];
	fiop->f_acctin[1] = ipacct[0][1];
	fiop->f_acctout[0] = ipacct[1][0];
	fiop->f_acctout[1] = ipacct[1][1];
#ifdef	USE_INET6
	fiop->f_fin6[0] = ipfilter6[0][0];
	fiop->f_fin6[1] = ipfilter6[0][1];
	fiop->f_fout6[0] = ipfilter6[1][0];
	fiop->f_fout6[1] = ipfilter6[1][1];
	fiop->f_acctin6[0] = ipacct6[0][0];
	fiop->f_acctin6[1] = ipacct6[0][1];
	fiop->f_acctout6[0] = ipacct6[1][0];
	fiop->f_acctout6[1] = ipacct6[1][1];
#else
	fiop->f_fin6[0] = NULL;
	fiop->f_fin6[1] = NULL;
	fiop->f_fout6[0] = NULL;
	fiop->f_fout6[1] = NULL;
	fiop->f_acctin6[0] = NULL;
	fiop->f_acctin6[1] = NULL;
	fiop->f_acctout6[0] = NULL;
	fiop->f_acctout6[1] = NULL;
#endif
	fiop->f_active = fr_active;
	fiop->f_froute[0] = ipl_frouteok[0];
	fiop->f_froute[1] = ipl_frouteok[1];

	fiop->f_running = fr_running;
	fiop->f_groups[0][0] = ipfgroups[0][0];
	fiop->f_groups[0][1] = ipfgroups[0][1];
	fiop->f_groups[1][0] = ipfgroups[1][0];
	fiop->f_groups[1][1] = ipfgroups[1][1];
	fiop->f_groups[2][0] = ipfgroups[2][0];
	fiop->f_groups[2][1] = ipfgroups[2][1];
#ifdef  IPFILTER_LOG
	fiop->f_logging = 1;
#else
	fiop->f_logging = 0;
#endif
	fiop->f_defpass = fr_pass;
	strncpy(fiop->f_version, ipfilter_version, sizeof(fiop->f_version));
}


#ifdef	USE_INET6
int icmptoicmp6types[ICMP_MAXTYPE+1] = {
	ICMP6_ECHO_REPLY,	/* 0: ICMP_ECHOREPLY */
	-1,			/* 1: UNUSED */
	-1,			/* 2: UNUSED */
	ICMP6_DST_UNREACH,	/* 3: ICMP_UNREACH */
	-1,			/* 4: ICMP_SOURCEQUENCH */
	ND_REDIRECT,		/* 5: ICMP_REDIRECT */
	-1,			/* 6: UNUSED */
	-1,			/* 7: UNUSED */
	ICMP6_ECHO_REQUEST,	/* 8: ICMP_ECHO */
	-1,			/* 9: UNUSED */
	-1,			/* 10: UNUSED */
	ICMP6_TIME_EXCEEDED,	/* 11: ICMP_TIMXCEED */
	ICMP6_PARAM_PROB,	/* 12: ICMP_PARAMPROB */
	-1,			/* 13: ICMP_TSTAMP */
	-1,			/* 14: ICMP_TSTAMPREPLY */
	-1,			/* 15: ICMP_IREQ */
	-1,			/* 16: ICMP_IREQREPLY */
	-1,			/* 17: ICMP_MASKREQ */
	-1,			/* 18: ICMP_MASKREPLY */
};


int	icmptoicmp6unreach[ICMP_MAX_UNREACH] = {
	ICMP6_DST_UNREACH_ADDR,		/* 0: ICMP_UNREACH_NET */
	ICMP6_DST_UNREACH_ADDR,		/* 1: ICMP_UNREACH_HOST */
	-1,				/* 2: ICMP_UNREACH_PROTOCOL */
	ICMP6_DST_UNREACH_NOPORT,	/* 3: ICMP_UNREACH_PORT */
	-1,				/* 4: ICMP_UNREACH_NEEDFRAG */
	ICMP6_DST_UNREACH_NOTNEIGHBOR,	/* 5: ICMP_UNREACH_SRCFAIL */
	ICMP6_DST_UNREACH_ADDR,		/* 6: ICMP_UNREACH_NET_UNKNOWN */
	ICMP6_DST_UNREACH_ADDR,		/* 7: ICMP_UNREACH_HOST_UNKNOWN */
	-1,				/* 8: ICMP_UNREACH_ISOLATED */
	ICMP6_DST_UNREACH_ADMIN,	/* 9: ICMP_UNREACH_NET_PROHIB */
	ICMP6_DST_UNREACH_ADMIN,	/* 10: ICMP_UNREACH_HOST_PROHIB */
	-1,				/* 11: ICMP_UNREACH_TOSNET */
	-1,				/* 12: ICMP_UNREACH_TOSHOST */
	ICMP6_DST_UNREACH_ADMIN,	/* 13: ICMP_UNREACH_ADMIN_PROHIBIT */
};
#endif
@


1.30
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.29 2001/05/08 19:58:01 fgsch Exp $	*/
@


1.29
log
@IPfilter 3.4.17; kjell@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.28 2001/01/30 04:23:55 kjell Exp $	*/
d873 1
a873 1
			if ((*mp = m_pullup(m, up)) == 0) {
@


1.28
log
@re-add local ipf changes that were whacked in the 3.4.16 merge. userland to follow
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.27 2001/01/17 04:47:11 fgsch Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.35.2.30 2000/12/17 05:49:22 darrenr Exp $";
d263 1
a263 1
		plen = ntohs(ip6->ip6_plen);
d792 1
a792 1
	char hbuf[(0xf << 2) + sizeof(struct icmp) + sizeof(ip_t) + 8];
d817 3
d828 2
a829 1
	if ((p == IPPROTO_TCP || p == IPPROTO_UDP || p == IPPROTO_ICMP
d1238 1
a1238 1
	return (pass & FR_PASS) ? 0 : error;
d1467 1
a1467 1
 * $IPFilter: fil.c,v 2.35.2.30 2000/12/17 05:49:22 darrenr Exp $
@


1.27
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
#include "netinet/ip_compat.h"
d88 6
a93 6
#include "netinet/ip_fil.h"
#include "netinet/ip_proxy.h"
#include "netinet/ip_nat.h"
#include "netinet/ip_frag.h"
#include "netinet/ip_state.h"
#include "netinet/ip_auth.h"
d103 1
a103 1
#include "netinet/ipl.h"
@


1.26
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.25 2000/05/24 21:59:10 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d11 2
a12 2
static const char sccsid[] = "@@(#)fil.c	1.36 6/5/96 (C) 1993-1996 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.3.2.22 2000/07/08 02:13:28 darrenr Exp $";
d26 7
a32 2
# if (__FreeBSD_version >= 400019)
#  define CSUM_DELAY_DATA
d80 7
a86 1
#include <netinet/ip_fil_compat.h>
d88 6
a93 6
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_frag.h>
#include <netinet/ip_state.h>
#include <netinet/ip_auth.h>
d103 1
a103 1
#include <netinet/ipl.h>
a109 4
# define	FR_IFVERBOSE(ex,second,verb_pr)	if (ex) { verbose verb_pr; \
							  second; }
# define	FR_IFDEBUG(ex,second,verb_pr)	if (ex) { debug verb_pr; \
							  second; }
a113 2
# define	FR_IFVERBOSE(ex,second,verb_pr)	;
# define	FR_IFDEBUG(ex,second,verb_pr)	;
d120 6
d132 4
d138 5
a142 1
int	fr_flags = IPF_LOGGING, fr_active = 0;
a151 1
static	int	fr_tcpudpchk __P((frentry_t *, fr_info_t *));
d208 3
d212 1
a213 4
	fr_ip_t *fi = &fin->fin_fi;
	u_short optmsk = 0, secmsk = 0, auth = 0;
	int i, mv, ol, off;
	u_char *s, opt;
a221 1
	fin->fin_id = ip->ip_id;
d225 2
a226 2
	fi->fi_v = ip->ip_v;
	fi->fi_tos = ip->ip_tos;
d228 44
a271 2
	fin->fin_dlen = ip->ip_len - hlen;
	tcp = (tcphdr_t *)((char *)ip + hlen);
d273 2
a274 9
	(*(((u_short *)fi) + 1)) = (*(((u_short *)ip) + 4));
	fi->fi_src.s_addr = ip->ip_src.s_addr;
	fi->fi_dst.s_addr = ip->ip_dst.s_addr;

	fi->fi_fl = (hlen > sizeof(ip_t)) ? FI_OPTIONS : 0;
	off = (ip->ip_off & IP_OFFMASK) << 3;
	if (ip->ip_off & 0x3fff)
		fi->fi_fl |= FI_FRAG;
	switch (ip->ip_p)
d276 34
d315 2
a316 1
		icmp = (icmphdr_t *)tcp;
d318 1
a318 13
		if (!off && (icmp->icmp_type == ICMP_ECHOREPLY ||
		     icmp->icmp_type == ICMP_ECHO))
			minicmpsz = ICMP_MINLEN;

		if (!off && (icmp->icmp_type == ICMP_TSTAMP ||
		     icmp->icmp_type == ICMP_TSTAMPREPLY))
			minicmpsz = 20;
/* type(1) + code(1) + cksum(2) + id(2) + seq(2) + 3*timestamp(3*4) */

		if (!off && (icmp->icmp_type == ICMP_MASKREQ ||
		     icmp->icmp_type == ICMP_MASKREPLY))
			minicmpsz = 12;
/* type(1) + code(1) + cksum(2) + id(2) + seq(2) + mask(4) */
d320 22
a341 1
		if ((!(ip->ip_len >= hlen + minicmpsz) && !off) ||
d344 1
a344 2
		if (fin->fin_dlen > 1)
			fin->fin_data[0] = *(u_short *)tcp;
d349 11
a359 3
		if ((!IPMINLEN(ip, tcphdr) && !off) ||
		    (off && off < sizeof(struct tcphdr)))
			fi->fi_fl |= FI_SHORT;
d365 11
a375 3
		if ((!IPMINLEN(ip, udphdr) && !off) ||
		    (off && off < sizeof(struct udphdr)))
			fi->fi_fl |= FI_SHORT;
d386 8
d454 2
a455 2
static int fr_tcpudpchk(fr, fin)
frentry_t *fr;
d468 2
a469 2
	if ((i = (int)fr->fr_dcmp)) {
		po = fr->fr_dport;
d488 1
a488 1
			 (tup >= po && tup <= fr->fr_dtop))
d491 1
a491 1
			 (tup <= po || tup >= fr->fr_dtop))
d497 2
a498 2
	if (err && (i = (int)fr->fr_scmp)) {
		po = fr->fr_sport;
d513 1
a513 1
			 (tup >= po && tup <= fr->fr_stop))
d516 1
a516 1
			 (tup <= po || tup >= fr->fr_stop))
d528 1
a528 1
			return !(fr->fr_tcpf | fr->fr_tcpfm);
d532 2
a533 2
		if (fr->fr_tcpfm &&
		    fr->fr_tcpf != (fin->fin_tcpf & fr->fr_tcpfm)) {
d535 1
a535 1
				 fr->fr_tcpfm, fr->fr_tcpf));
d562 4
a565 1
	off = ip->ip_off & IP_OFFMASK;
d609 35
a643 4
			i = ((lip[0] & lm[0]) != ld[0]);
			FR_IFDEBUG(i,continue,("0. %#08x & %#08x != %#08x\n",
				   lip[0], lm[0], ld[0]));
			i |= ((lip[1] & lm[1]) != ld[1]) << 19;
d645 24
a668 3
			FR_IFDEBUG(i,continue,("1. %#08x & %#08x != %#08x\n",
				   lip[1], lm[1], ld[1]));
			i |= ((lip[2] & lm[2]) != ld[2]) << 20;
d670 10
a679 8
			FR_IFDEBUG(i,continue,("2. %#08x & %#08x != %#08x\n",
				   lip[2], lm[2], ld[2]));
			i |= ((lip[3] & lm[3]) != ld[3]);
			FR_IFDEBUG(i,continue,("3. %#08x & %#08x != %#08x\n",
				   lip[3], lm[3], ld[3]));
			i |= ((lip[4] & lm[4]) != ld[4]);
			FR_IFDEBUG(i,continue,("4. %#08x & %#08x != %#08x\n",
				   lip[4], lm[4], ld[4]));
d692 1
a692 1
			if (!fr_tcpudpchk(fr, fin))
d710 5
a714 2
		if ((passt & FR_CALLNOW) && fr->fr_func)
			passt = (*fr->fr_func)(passt, ip, fin);
d721 1
a721 1
				ATOMIC_INC(frstats[fin->fin_out].fr_skip);
d723 1
a723 1
			ATOMIC_INC(frstats[fin->fin_out].fr_pkl);
d730 1
a730 1
		ATOMIC_INC(fr->fr_hits);
d780 2
a781 2
	frentry_t *fr = NULL;
	int changed, error = EHOSTUNREACH;
d788 1
d814 10
d825 5
a829 2
	if ((ip->ip_p == IPPROTO_TCP || ip->ip_p == IPPROTO_UDP ||
	     ip->ip_p == IPPROTO_ICMP)) {
d832 2
a833 2
		if ((ip->ip_off & IP_OFFMASK) == 0)
			switch(ip->ip_p)
d845 9
d855 1
a855 1
		up = MIN(hlen + plen, ip->ip_len);
d861 1
a861 1
				ATOMIC_INC(frstats[out].fr_pull[1]);
d865 1
a865 1
			ATOMIC_INC(frstats[out].fr_pull[0]);
d870 1
a870 1
				ATOMIC_INC(frstats[out].fr_pull[1]);
d873 1
a873 1
				ATOMIC_INC(frstats[out].fr_pull[0]);
d893 1
a893 1

d898 1
a898 1
	if (out)
d900 2
a901 1
	fr_makefrip(hlen, ip, fin);
d903 1
d906 38
d945 3
d952 1
a952 1
		ATOMIC_INC(frstats[out].fr_short);
d964 6
d971 1
a971 1
		if (!apass && (fin->fin_fr = ipacct[0][fr_active]) &&
d973 1
a973 1
			ATOMIC_INC(frstats[0].fr_acct);
d992 1
a992 1
				ATOMIC_INC(frstats[out].fr_chit);
d994 1
a994 1
					ATOMIC_INC(fr->fr_hits);
d998 7
a1004 1
				if ((fin->fin_fr = ipfilter[out][fr_active]))
d1010 1
a1010 1
					ATOMIC_INC(frstats[out].fr_nom);
d1034 1
a1034 1
				ATOMIC_INC(fr_authstats.fas_hits);
d1036 1
a1036 1
				ATOMIC_INC(fr_authstats.fas_miss);
d1045 1
a1045 1
					ATOMIC_INC(frstats[out].fr_bnfr);
d1047 1
a1047 1
					ATOMIC_INC(frstats[out].fr_nfr);
d1050 1
a1050 1
				ATOMIC_INC(frstats[out].fr_cfr);
d1055 1
a1055 1
				ATOMIC_INC(frstats[out].fr_bads);
d1057 1
a1057 1
				ATOMIC_INC(frstats[out].fr_ads);
d1066 5
a1070 2
	if (fr && fr->fr_func && !(pass & FR_CALLNOW))
		pass = (*fr->fr_func)(pass, ip, fin);
d1077 7
a1083 1
		if ((fin->fin_fr = ipacct[1][fr_active]) &&
d1085 1
a1085 1
			ATOMIC_INC(frstats[1].fr_acct);
d1097 1
a1097 1
			ATOMIC_INC(frstats[out].fr_npkl);
d1103 1
a1103 1
			ATOMIC_INC(frstats[out].fr_ppkl);
d1109 1
a1109 1
			ATOMIC_INC(frstats[out].fr_bpkl);
d1112 1
a1112 1
				ATOMIC_INC(frstats[out].fr_skip);
d1121 1
a1121 1
	if (out)
d1142 1
a1142 1
		ATOMIC_INC(frstats[out].fr_pass);
d1144 1
a1144 1
		ATOMIC_INC(frstats[out].fr_block);
d1156 1
a1156 1
				struct in_addr dst;
d1159 1
a1159 1
					dst = ip->ip_dst;
d1161 1
a1161 1
					dst.s_addr = 0;
d1163 1
a1163 1
				ATOMIC_INC(frstats[0].fr_ret);
d1167 1
a1167 1
					ATOMIC_INC(frstats[1].fr_ret);
d1173 1
a1173 1
				ATOMIC_INC(frstats[0].fr_ret);
d1176 1
a1176 1
				ATOMIC_INC(frstats[0].fr_ret);
d1180 1
a1180 1
				ATOMIC_INC(frstats[1].fr_ret);
d1196 4
d1227 1
a1227 1
			if (ipfr_fastroute(qif, ip, m, mp, fin, fdp) == 0)
d1231 1
a1231 1
			ipfr_fastroute(qif, ip, mc, mp, fin, &fr->fr_dif);
d1463 1
a1463 1
 * $IPFilter: fil.c,v 2.3.2.22 2000/07/08 02:13:28 darrenr Exp $
d1563 1
a1563 2
u_int num;
u_32_t flags;
d1592 1
a1592 1
u_int num;
d1604 1
a1604 1
		fg->fg_num = num & 0xffff;
d1615 1
a1615 2
u_int num;
u_32_t flags;
d1653 1
a1653 1
		ATOMIC_DEC(fp->fr_ref);
d1655 1
a1655 1
			fr_delgroup((u_int)fp->fr_grhead, fp->fr_flags, 
d1657 1
a1657 1
			fp->fr_grhead = NULL;
d1686 4
d1694 4
d1776 2
a1777 1
int fr_ifpaddr(ifptr, inp)
d1781 3
d1792 18
a1809 1
	in.s_addr = ill->ill_ipif->ipif_local_addr;
d1814 1
a1815 1
	struct sockaddr_in *sin;
d1834 11
a1844 2
	while (sin && ifa &&
	       sin->sin_family != AF_INET) {
d1862 9
a1870 1
	in = sin->sin_addr;
a1872 1
	*inp = in;
d1882 1
a1882 1
			fr->fr_ifa = GETUNIT(fr->fr_ifname);
d1894 1
a1896 1
# if !SOLARIS
d1919 6
d1928 36
d1965 9
d1979 2
a1980 1
int fr_ifpaddr(ifptr, inp)
d1986 142
a2127 1
#endif       
@


1.25
log
@Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
  RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.24 2000/05/10 20:40:52 deraadt Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.3.2.20 2000/05/22 06:57:42 darrenr Exp $";
d26 3
d1193 1
a1193 1
 * $IPFilter: fil.c,v 2.3.2.20 2000/05/22 06:57:42 darrenr Exp $
d1598 1
@


1.24
log
@ipf 3.3.14, fixes an ipnat problem and ip option mishandling, which the bridge code cares about
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.23 2000/05/01 06:16:47 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.3.2.18 2000/04/25 16:21:09 darrenr Exp $";
a101 1
# define	SEND_RESET(ip, qif, if, m, fin)		send_reset(ip, if)
a102 1
# define	FR_NEWAUTH(m, fi, ip, qif)	fr_newauth((mb_t *)m, fi, ip)
a111 17
# endif
# if SOLARIS
#  define	FR_NEWAUTH(m, fi, ip, qif)	fr_newauth((mb_t *)m, fi, \
							   ip, qif)
#  define	SEND_RESET(ip, qif, if, fin)	send_reset(fin, ip, qif)
#  define	ICMP_ERROR(b, ip, t, c, if, dst) \
			icmp_error(ip, t, c, if, dst)
# else /* SOLARIS */
#  define	FR_NEWAUTH(m, fi, ip, qif)	fr_newauth((mb_t *)m, fi, ip)
#  ifdef linux
#   define	SEND_RESET(ip, qif, if, fin)	send_reset(ip, ifp)
#   define	ICMP_ERROR(b, ip, t, c, if, dst) 	icmp_send(b,t,c,0,if)
#  else
#   define	SEND_RESET(ip, qif, if, fin)	send_reset(fin, ip)
#   define	ICMP_ERROR(b, ip, t, c, if, dst) \
		send_icmp_err(ip, t, c, if, dst)
#  endif /* linux */
d231 1
d234 3
a236 1
			minicmpsz = 20; /* type(1) + code(1) + cksum(2) + id(2) + seq(2) + 3*timestamp(3*4) */
d239 3
a241 1
			minicmpsz = 12; /* type(1) + code(1) + cksum(2) + id(2) + seq(2) + mask(4) */
d621 10
d763 1
a763 1
			if (FR_NEWAUTH(m, fin, ip, qif) != 0)
d893 1
a893 7
# if SOLARIS
				ICMP_ERROR(q, ip, ICMP_UNREACH, fin->fin_icode,
					   qif, dst);
# else
				ICMP_ERROR(m, ip, ICMP_UNREACH, fin->fin_icode,
					   ifp, dst);
# endif
d897 1
a897 1
				if (SEND_RESET(ip, qif, ifp, fin) == 0) {
d1190 1
a1190 1
 * $IPFilter: fil.c,v 2.3.2.18 2000/04/25 16:21:09 darrenr Exp $
@


1.24.2.1
log
@Pull in patch from current:
Errata:
A misuse of ipf(8) keep-state rules can result in firewall rules being bypassed.
Fix (kjell):
Update to ipf 3.3.16. among other things, this addresses a security issue
with certain rule configurations:

* don't add TCP state if it is an RST packet and (attempt) to send out
RST/ICMP packets in a manner that bypasses IP Filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.25 2000/05/24 21:59:10 kjell Exp $	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.3.2.20 2000/05/22 06:57:42 darrenr Exp $";
d102 1
d104 1
d114 17
a249 1

d252 1
a252 3
			minicmpsz = 20;
/* type(1) + code(1) + cksum(2) + id(2) + seq(2) + 3*timestamp(3*4) */

d255 1
a255 3
			minicmpsz = 12;
/* type(1) + code(1) + cksum(2) + id(2) + seq(2) + mask(4) */

a634 10
#  ifdef CSUM_DELAY_DATA
	/*
	 * disable delayed checksums.
	 */
	if (m->m_pkthdr.csum_flags & CSUM_DELAY_DATA) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum_flags &= ~CSUM_DELAY_DATA;
	}
#  endif /* CSUM_DELAY_DATA */

d767 1
a767 1
			if (fr_newauth((mb_t *)m, fin, ip) != 0)
d897 7
a903 1
				send_icmp_err(ip, ICMP_UNREACH, fin, dst);
d907 1
a907 1
				if (send_reset(ip, fin) == 0) {
d1200 1
a1200 1
 * $IPFilter: fil.c,v 2.3.2.20 2000/05/22 06:57:42 darrenr Exp $
@


1.23
log
@Update to ipfilter 3.3.13. This should be the last of the 3.3.x releases.
This patch fixes mostly ICMP timeout problems, as the ftp proxy
changes were imported previously.
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.22 2000/03/13 23:40:17 kjell Exp $	*/
d287 1
a287 1
	for (s = (u_char *)(ip + 1), hlen -= (int)sizeof(*ip); hlen; ) {
d291 9
a299 3
		ol = (opt == IPOPT_NOP) ? 1 : (int)*(s+1);
		if (opt > 1 && (ol < 2 || ol > hlen))
			break;
@


1.22
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.3.2.17 2000/03/03 14:51:16 darrenr Exp $";
d24 1
a24 1
#if defined(KERNEL) && defined(__FreeBSD_version) && \
d1194 1
a1194 1
 * $IPFilter: fil.c,v 2.3.2.17 2000/03/03 14:51:16 darrenr Exp $
@


1.21
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.3.2.16 2000/01/27 08:49:37 darrenr Exp $";
d545 2
d1194 1
a1194 1
 * $IPFilter: fil.c,v 2.3.2.16 2000/01/27 08:49:37 darrenr Exp $
@


1.20
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.20.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.21 2000/02/16 22:34:17 kjell Exp $	*/
@


1.20.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.3.2.17 2000/03/03 14:51:16 darrenr Exp $";
a544 2
				if (passt & FR_LOGORBLOCK)
					passt |= FR_BLOCK|FR_QUICK;
d1192 1
a1192 1
 * $IPFilter: fil.c,v 2.3.2.17 2000/03/03 14:51:16 darrenr Exp $
@


1.20.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.28 2001/01/30 04:23:55 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-2000 by Darren Reed.
d11 2
a12 2
static const char sccsid[] = "@@(#)fil.c	1.36 6/5/96 (C) 1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: fil.c,v 2.35.2.30 2000/12/17 05:49:22 darrenr Exp $";
d24 1
a24 1
#if (defined(KERNEL) || defined(_KERNEL)) && defined(__FreeBSD_version) && \
a25 8
# if (__FreeBSD_version >= 400000)
#  ifndef KLD_MODULE
#   include "opt_inet6.h"
#  endif
#  if (__FreeBSD_version == 400019)
#   define CSUM_DELAY_DATA
#  endif
# endif
a72 6
#ifdef	USE_INET6
# include <netinet/icmp6.h>
# if !SOLARIS && defined(_KERNEL)
#  include <netinet6/in6_var.h>
# endif
#endif
d96 4
d102 1
d104 1
d106 2
d118 3
d123 8
a136 4
#ifdef	USE_INET6
		*ipfilter6[2][2] = { { NULL, NULL }, { NULL, NULL } },
		*ipacct6[2][2] = { { NULL, NULL }, { NULL, NULL } },
#endif
d139 1
a139 5
int	fr_flags = IPF_LOGGING;
int	fr_active = 0;
int	fr_chksrc = 0;
int	fr_minttl = 3;
int	fr_minttllog = 1;
d149 1
d206 3
d210 1
a210 3
	int i, mv, ol, off, p, plen, v;
	fr_ip_t *fi = &fin->fin_fi;
	struct optlist *op;
a211 1
	tcphdr_t *tcp;
d220 1
d224 2
a225 2
	v = fin->fin_v;
	fi->fi_v = v;
d227 2
a228 44
	if (v == 4) {
		fin->fin_id = ip->ip_id;
		fi->fi_tos = ip->ip_tos;
		off = (ip->ip_off & IP_OFFMASK) << 3;
		tcp = (tcphdr_t *)((char *)ip + hlen);
		(*(((u_short *)fi) + 1)) = (*(((u_short *)ip) + 4));
		fi->fi_src.i6[1] = 0;
		fi->fi_src.i6[2] = 0;
		fi->fi_src.i6[3] = 0;
		fi->fi_dst.i6[1] = 0;
		fi->fi_dst.i6[2] = 0;
		fi->fi_dst.i6[3] = 0;
		fi->fi_saddr = ip->ip_src.s_addr;
		fi->fi_daddr = ip->ip_dst.s_addr;
		p = ip->ip_p;
		fi->fi_fl = (hlen > sizeof(ip_t)) ? FI_OPTIONS : 0;
		if (ip->ip_off & 0x3fff)
			fi->fi_fl |= FI_FRAG;
		plen = ip->ip_len;
		fin->fin_dlen = plen - hlen;
	}
#ifdef	USE_INET6
	else if (v == 6) {
		ip6_t *ip6 = (ip6_t *)ip;

		off = 0;
		p = ip6->ip6_nxt;
		fi->fi_p = p;
		fi->fi_ttl = ip6->ip6_hlim;
		tcp = (tcphdr_t *)(ip6 + 1);
		fi->fi_src.in6 = ip6->ip6_src;
		fi->fi_dst.in6 = ip6->ip6_dst;
		fin->fin_id = (u_short)(ip6->ip6_flow & 0xffff);
		fi->fi_tos = 0;
		fi->fi_fl = 0;
		plen = ntohs(ip6->ip6_plen);
		fin->fin_dlen = plen;
	}
#endif
	else
		return;

	fin->fin_off = off;
	fin->fin_plen = plen;
d230 9
a238 5

	switch (p)
	{
#ifdef USE_INET6
	case IPPROTO_ICMPV6 :
a239 31
		int minicmpsz = sizeof(struct icmp6_hdr);
		struct icmp6_hdr *icmp6;

		if (fin->fin_dlen > 1) {
			fin->fin_data[0] = *(u_short *)tcp;

			icmp6 = (struct icmp6_hdr *)tcp;

			switch (icmp6->icmp6_type)
			{
			case ICMP6_ECHO_REPLY :
			case ICMP6_ECHO_REQUEST :
				minicmpsz = ICMP6ERR_MINPKTLEN;
				break;
			case ICMP6_DST_UNREACH :
			case ICMP6_PACKET_TOO_BIG :
			case ICMP6_TIME_EXCEEDED :
			case ICMP6_PARAM_PROB :
				minicmpsz = ICMP6ERR_IPICMPHLEN;
				break;
			default :
				break;
			}
		}

		if (!(plen >= hlen + minicmpsz))
			fi->fi_fl |= FI_SHORT;

		break;
	}
#endif
d245 1
a245 4
		if (!off && (fin->fin_dlen > 1)) {
			fin->fin_data[0] = *(u_short *)tcp;

			icmp = (icmphdr_t *)tcp;
d247 10
a256 22
			if (icmp->icmp_type == ICMP_ECHOREPLY ||
			    icmp->icmp_type == ICMP_ECHO)
				minicmpsz = ICMP_MINLEN;

			/*
			 * type(1) + code(1) + cksum(2) + id(2) seq(2) +
			 * 3*timestamp(3*4)
			 */
			else if (icmp->icmp_type == ICMP_TSTAMP ||
				 icmp->icmp_type == ICMP_TSTAMPREPLY)
				minicmpsz = 20;

			/*
			 * type(1) + code(1) + cksum(2) + id(2) seq(2) +
			 * mask(4)
			 */
			else if (icmp->icmp_type == ICMP_MASKREQ ||
				 icmp->icmp_type == ICMP_MASKREPLY)
				minicmpsz = 12;
		}

		if ((!(plen >= hlen + minicmpsz) && !off) ||
d259 2
a260 1

d265 3
a267 11
#ifdef	USE_INET6
		if (v == 6) {
			if (plen < sizeof(struct tcphdr))
				fi->fi_fl |= FI_SHORT;
		} else
#endif
		if (v == 4) {
			if ((!IPMINLEN(ip, tcphdr) && !off) ||
			     (off && off < sizeof(struct tcphdr)))
				fi->fi_fl |= FI_SHORT;
		}
d273 3
a275 11
#ifdef	USE_INET6
		if (v == 6) {
			if (plen < sizeof(struct udphdr))
				fi->fi_fl |= FI_SHORT;
		} else
#endif
		if (v == 4) {
			if ((!IPMINLEN(ip, udphdr) && !off) ||
			    (off && off < sizeof(struct udphdr)))
				fi->fi_fl |= FI_SHORT;
		}
a285 8
#ifdef	USE_INET6
	if (v == 6) {
		fi->fi_optmsk = 0;
		fi->fi_secmsk = 0;
		fi->fi_auth = 0;
		return;
	}
#endif
d287 1
a287 1
	for (s = (u_char *)(ip + 1), hlen -= (int)sizeof(*ip); hlen > 0; ) {
d291 3
a293 9
		else if (opt == IPOPT_NOP)
			ol = 1;
		else {
			if (hlen < 2)
				break;
			ol = (int)*(s + 1);
			if (ol < 2 || ol > hlen)
				break;
		}
d340 2
a341 2
int fr_tcpudpchk(ft, fin)
frtuc_t *ft;
d354 2
a355 2
	if ((i = (int)ft->ftu_dcmp)) {
		po = ft->ftu_dport;
d374 1
a374 1
			 (tup >= po && tup <= ft->ftu_dtop))
d377 1
a377 1
			 (tup <= po || tup >= ft->ftu_dtop))
d383 2
a384 2
	if (err && (i = (int)ft->ftu_scmp)) {
		po = ft->ftu_sport;
d399 1
a399 1
			 (tup >= po && tup <= ft->ftu_stop))
d402 1
a402 1
			 (tup <= po || tup >= ft->ftu_stop))
d414 1
a414 1
			return !(ft->ftu_tcpf | ft->ftu_tcpfm);
d418 2
a419 2
		if (ft->ftu_tcpfm &&
		    ft->ftu_tcpf != (fin->fin_tcpf & ft->ftu_tcpfm)) {
d421 1
a421 1
				 ft->ftu_tcpfm, ft->ftu_tcpf));
d448 1
a448 4
	if (fin->fin_v == 4)
		off = ip->ip_off & IP_OFFMASK;
	else
		off = 0;
d492 4
a495 35
			i = ((*lip & *lm) != *ld);
			FR_DEBUG(("0. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
			if (i)
				continue;
			/*
			 * We now know whether the packet version and the
			 * rule version match, along with protocol, ttl and
			 * tos.
			 */
			lip++, lm++, ld++;
			/*
			 * Unrolled loops (4 each, for 32 bits).
			 */
			i |= ((*lip & *lm) != *ld) << 19;
			FR_DEBUG(("1a. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
			if (fi->fi_v == 6) {
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 19;
				FR_DEBUG(("1b. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 19;
				FR_DEBUG(("1c. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 19;
				FR_DEBUG(("1d. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
			} else {
				lip += 3;
				lm += 3;
				ld += 3;
			}
d497 3
a499 24
			if (i)
				continue;
			lip++, lm++, ld++;
			i |= ((*lip & *lm) != *ld) << 20;
			FR_DEBUG(("2a. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
			if (fi->fi_v == 6) {
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 20;
				FR_DEBUG(("2b. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 20;
				FR_DEBUG(("2c. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
				lip++, lm++, ld++;
				i |= ((*lip & *lm) != *ld) << 20;
				FR_DEBUG(("2d. %#08x & %#08x != %#08x\n",
					   *lip, *lm, *ld));
			} else {
				lip += 3;
				lm += 3;
				ld += 3;
			}
d501 8
a508 10
			if (i)
				continue;
			lip++, lm++, ld++;
			i |= ((*lip & *lm) != *ld);
			FR_DEBUG(("3. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
			lip++, lm++, ld++;
			i |= ((*lip & *lm) != *ld);
			FR_DEBUG(("4. %#08x & %#08x != %#08x\n",
				   *lip, *lm, *ld));
d521 1
a521 1
			if (!fr_tcpudpchk(&fr->fr_tuc, fin))
d539 2
a540 5
#if (BSD >= 199306) && (defined(_KERNEL) || defined(KERNEL))
		if (securelevel <= 0)
#endif
			if ((passt & FR_CALLNOW) && fr->fr_func)
				passt = (*fr->fr_func)(passt, ip, fin);
d547 1
a547 1
				ATOMIC_INCL(frstats[fin->fin_out].fr_skip);
d549 1
a549 1
			ATOMIC_INCL(frstats[fin->fin_out].fr_pkl);
d556 1
a556 1
		ATOMIC_INCL(fr->fr_hits);
d606 2
a607 2
	int changed, error = EHOSTUNREACH, v = ip->ip_v;
	frentry_t *fr = NULL, *list;
a613 1
	int p, len, drop = 0, logit = 0;
a628 20
#  ifdef CSUM_DELAY_DATA
	/*
	 * disable delayed checksums.
	 */
	if (m->m_pkthdr.csum_flags & CSUM_DELAY_DATA) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum_flags &= ~CSUM_DELAY_DATA;
	}
#  endif /* CSUM_DELAY_DATA */

# ifdef	USE_INET6
	if (v == 6) {
		len = ntohs(((ip6_t*)ip)->ip6_plen);
		p = ((ip6_t *)ip)->ip6_nxt;
	} else
# endif
	{
		p = ip->ip_p;
		len = ip->ip_len;
	}
d630 2
a631 5
	if ((p == IPPROTO_TCP || p == IPPROTO_UDP || p == IPPROTO_ICMP
# ifdef USE_INET6
	    || (v == 6 && p == IPPROTO_ICMPV6)
# endif
	   )) {
d634 2
a635 2
		if ((v == 6) || (ip->ip_off & IP_OFFMASK) == 0)
			switch(p)
a646 9
# ifdef USE_INET6
	    		case IPPROTO_ICMPV6 :
				/*
				 * XXX does not take intermediate header
				 * into account
				 */
				plen = ICMP6ERR_MINPKTLEN + 8 - sizeof(ip6_t);
				break;
# endif
d648 1
a648 1
		up = MIN(hlen + plen, len);
d654 1
a654 1
				ATOMIC_INCL(frstats[out].fr_pull[1]);
d658 1
a658 1
			ATOMIC_INCL(frstats[out].fr_pull[0]);
d663 1
a663 1
				ATOMIC_INCL(frstats[out].fr_pull[1]);
d666 1
a666 1
				ATOMIC_INCL(frstats[out].fr_pull[0]);
d686 1
a686 1
	
d691 1
a691 1
	if ((out) && (v == 4))
d693 1
a693 2

	changed = 0;
a694 1
	fin->fin_v = v;
a696 38
	fr_makefrip(hlen, ip, fin);

#ifdef _KERNEL
# ifdef	USE_INET6
	if (v == 6) {
		ATOMIC_INCL(frstats[0].fr_ipv6[out]);
		if (((ip6_t *)ip)->ip6_hlim < fr_minttl) {
			ATOMIC_INCL(frstats[0].fr_badttl);
			if (fr_minttllog)
				logit = -2;
		}
	} else
# endif
	if (!out) {
		if (fr_chksrc && !fr_verifysrc(ip->ip_src, ifp)) {
			ATOMIC_INCL(frstats[0].fr_badsrc);
			if (fr_chksrc == 2)
				logit = -2;
		} else if (ip->ip_ttl < fr_minttl) {
			ATOMIC_INCL(frstats[0].fr_badttl);
			if (fr_minttllog)
				logit = -3;
		}
	}
	if (drop) {
# ifdef	IPFILTER_LOG
		if (logit) {
			fin->fin_group = logit;
			pass = FR_INQUE|FR_NOMATCH|FR_LOGB;
			(void) IPLLOG(pass, ip, fin, m);
		}
# endif
# if !SOLARIS
		m_freem(m);
# endif
		return error;
	}
#endif
a697 3
	if (fin->fin_fi.fi_fl & FI_SHORT) {
		ATOMIC_INCL(frstats[out].fr_short);
	}
d702 1
a702 1
		ATOMIC_INCL(frstats[out].fr_short);
a713 6
#ifdef	USE_INET6
		if (v == 6)
			list = ipacct6[0][fr_active];
		else
#endif
			list = ipacct[0][fr_active];
d715 1
a715 1
		if (!apass && (fin->fin_fr = list) &&
d717 1
a717 1
			ATOMIC_INCL(frstats[0].fr_acct);
d736 1
a736 1
				ATOMIC_INCL(frstats[out].fr_chit);
d738 1
a738 1
					ATOMIC_INCL(fr->fr_hits);
d742 1
a742 7
#ifdef	USE_INET6
				if (v == 6)
					list = ipfilter6[out][fr_active];
				else
#endif
					list = ipfilter[out][fr_active];
				if ((fin->fin_fr = list))
d748 1
a748 1
					ATOMIC_INCL(frstats[out].fr_nom);
d761 1
a761 1
			if (fr_newauth((mb_t *)m, fin, ip) != 0)
d772 1
a772 1
				ATOMIC_INCL(fr_authstats.fas_hits);
d774 1
a774 1
				ATOMIC_INCL(fr_authstats.fas_miss);
d783 1
a783 1
					ATOMIC_INCL(frstats[out].fr_bnfr);
d785 1
a785 1
					ATOMIC_INCL(frstats[out].fr_nfr);
d788 1
a788 1
				ATOMIC_INCL(frstats[out].fr_cfr);
d793 1
a793 1
				ATOMIC_INCL(frstats[out].fr_bads);
d795 1
a795 1
				ATOMIC_INCL(frstats[out].fr_ads);
d804 2
a805 5
#if (BSD >= 199306) && (defined(_KERNEL) || defined(KERNEL))
	if (securelevel <= 0)
#endif
		if (fr && fr->fr_func && !(pass & FR_CALLNOW))
			pass = (*fr->fr_func)(pass, ip, fin);
d812 1
a812 7
#ifdef	USE_INET6
		if (v == 6)
			list = ipacct6[1][fr_active];
		else
#endif
			list = ipacct[1][fr_active];
		if ((fin->fin_fr = list) &&
d814 1
a814 1
			ATOMIC_INCL(frstats[1].fr_acct);
d826 1
a826 1
			ATOMIC_INCL(frstats[out].fr_npkl);
d832 1
a832 1
			ATOMIC_INCL(frstats[out].fr_ppkl);
d838 1
a838 1
			ATOMIC_INCL(frstats[out].fr_bpkl);
d841 1
a841 1
				ATOMIC_INCL(frstats[out].fr_skip);
d850 1
a850 1
	if ((out) && (v == 4))
d871 1
a871 1
		ATOMIC_INCL(frstats[out].fr_pass);
d873 1
a873 1
		ATOMIC_INCL(frstats[out].fr_block);
d885 1
a885 1
				int dst;
d888 1
a888 1
					dst = 1;
d890 9
a898 3
					dst = 0;
				send_icmp_err(ip, ICMP_UNREACH, fin, dst);
				ATOMIC_INCL(frstats[0].fr_ret);
d901 2
a902 2
				if (send_reset(ip, fin) == 0) {
					ATOMIC_INCL(frstats[1].fr_ret);
d908 1
a908 1
				ATOMIC_INCL(frstats[0].fr_ret);
d911 1
a911 1
				ATOMIC_INCL(frstats[0].fr_ret);
d915 1
a915 1
				ATOMIC_INCL(frstats[1].fr_ret);
a930 4
	if ((changed == -1) && (pass & FR_PASS)) {
		pass &= ~FR_PASS;
		pass |= FR_BLOCK;
	}
d958 1
a958 1
			if (ipfr_fastroute(ip, m, mp, fin, fdp) == 0)
d962 1
a962 1
			ipfr_fastroute(ip, mc, mp, fin, &fr->fr_dif);
d1194 1
a1194 1
 * $IPFilter: fil.c,v 2.35.2.30 2000/12/17 05:49:22 darrenr Exp $
d1294 2
a1295 1
u_32_t num, flags;
d1324 1
a1324 1
u_32_t num;
d1336 1
a1336 1
		fg->fg_num = num;
d1347 2
a1348 1
u_32_t num, flags;
d1386 1
a1386 1
		ATOMIC_DEC32(fp->fr_ref);
d1388 1
a1388 1
			fr_delgroup(fp->fr_grhead, fp->fr_flags, 
d1390 1
a1390 1
			fp->fr_grhead = 0;
a1418 4
#ifdef	USE_INET6
		(void) frflushlist(set, unit, &flushed, &ipfilter6[1][set]);
		(void) frflushlist(set, unit, &flushed, &ipacct6[1][set]);
#endif
a1422 4
#ifdef	USE_INET6
		(void) frflushlist(set, unit, &flushed, &ipfilter6[0][set]);
		(void) frflushlist(set, unit, &flushed, &ipacct6[0][set]);
#endif
d1501 1
a1501 2
int fr_ifpaddr(v, ifptr, inp)
int v;
a1504 3
# ifdef	USE_INET6
	struct in6_addr *inp6 = NULL;
# endif
d1513 1
a1513 18
#  ifdef	USE_INET6
	if (v == 6) {
		struct in6_addr in6;

		/*
		 * First is always link local.
		 */
		if (ill->ill_ipif->ipif_next)
			in6 = ill->ill_ipif->ipif_next->ipif_v6lcl_addr;
		else
			bzero((char *)&in6, sizeof(in6));
		bcopy((char *)&in6, (char *)inp, sizeof(in6));
	} else
#  endif
	{
		in.s_addr = ill->ill_ipif->ipif_local_addr;
		*inp = in;
	}
d1518 1
a1519 1
	struct ifaddr *ifa;
d1538 2
a1539 11
	while (sin && ifa) {
		if ((v == 4) && (sin->sin_family == AF_INET))
			break;
#    ifdef USE_INET6
		if ((v == 6) && (sin->sin_family == AF_INET6)) {
			inp6 = &((struct sockaddr_in6 *)sin)->sin6_addr;
			if (!IN6_IS_ADDR_LINKLOCAL(inp6) &&
			    !IN6_IS_ADDR_LOOPBACK(inp6))
				break;
		}
#    endif
d1557 1
a1557 9
#    ifdef	USE_INET6
	if (v == 6)
		bcopy((char *)inp6, (char *)inp, sizeof(*inp6));
	else
#    endif
	{
		in = sin->sin_addr;
		*inp = in;
	}
d1560 1
d1570 1
a1570 1
			fr->fr_ifa = GETUNIT(fr->fr_ifname, fr->fr_ip.fi_v);
a1581 1
# if !SOLARIS
d1584 1
a1598 1
	ip_natsync((struct ifnet *)-1);
a1605 6
#ifdef	USE_INET6
	frsynclist(ipacct6[0][fr_active]);
	frsynclist(ipacct6[1][fr_active]);
	frsynclist(ipfilter6[0][fr_active]);
	frsynclist(ipfilter6[1][fr_active]);
#endif
a1608 36

/*
 * In the functions below, bcopy() is called because the pointer being
 * copied _from_ in this instance is a pointer to a char buf (which could
 * end up being unaligned) and on the kernel's local stack.
 */
int ircopyptr(a, b, c)
void *a, *b;
size_t c;
{
	caddr_t ca;
	int err;

#if SOLARIS
	if (copyin(a, (char *)&ca, sizeof(ca)))
		return EFAULT;
#else
	bcopy(a, &ca, sizeof(ca));
#endif
	err = copyin(ca, b, c);
	if (err)
		err = EFAULT;
	return err;
}


int iwcopyptr(a, b, c)
void *a, *b;
size_t c;
{
	caddr_t ca;
	int err;

#if SOLARIS
	if (copyin(b, (char *)&ca, sizeof(ca)))
		return EFAULT;
a1609 9
	bcopy(b, &ca, sizeof(ca));
#endif
	err = copyout(a, ca, c);
	if (err)
		err = EFAULT;
	return err;
}

#else /* _KERNEL */
d1615 1
a1615 2
int fr_ifpaddr(v, ifptr, inp)
int v;
d1621 1
a1621 142


int ircopyptr(a, b, c)
void *a, *b;
size_t c;
{
	caddr_t ca;

	bcopy(a, &ca, sizeof(ca));
	bcopy(ca, b, c);
	return 0;
}


int iwcopyptr(a, b, c)
void *a, *b;
size_t c;
{
	caddr_t ca;

	bcopy(b, &ca, sizeof(ca));
	bcopy(a, ca, c);
	return 0;
}


#endif


int fr_lock(data, lockp)
caddr_t data;
int *lockp;
{
	int arg, error;

	error = IRCOPY(data, (caddr_t)&arg, sizeof(arg));
	if (!error) {
		error = IWCOPY((caddr_t)lockp, data, sizeof(*lockp));
		if (!error)
			*lockp = arg;
	}
	return error;
}


void fr_getstat(fiop)
friostat_t *fiop;
{
	bcopy((char *)frstats, (char *)fiop->f_st, sizeof(filterstats_t) * 2);
	fiop->f_locks[0] = fr_state_lock;
	fiop->f_locks[1] = fr_nat_lock;
	fiop->f_locks[2] = fr_frag_lock;
	fiop->f_locks[3] = fr_auth_lock;
	fiop->f_fin[0] = ipfilter[0][0];
	fiop->f_fin[1] = ipfilter[0][1];
	fiop->f_fout[0] = ipfilter[1][0];
	fiop->f_fout[1] = ipfilter[1][1];
	fiop->f_acctin[0] = ipacct[0][0];
	fiop->f_acctin[1] = ipacct[0][1];
	fiop->f_acctout[0] = ipacct[1][0];
	fiop->f_acctout[1] = ipacct[1][1];
#ifdef	USE_INET6
	fiop->f_fin6[0] = ipfilter6[0][0];
	fiop->f_fin6[1] = ipfilter6[0][1];
	fiop->f_fout6[0] = ipfilter6[1][0];
	fiop->f_fout6[1] = ipfilter6[1][1];
	fiop->f_acctin6[0] = ipacct6[0][0];
	fiop->f_acctin6[1] = ipacct6[0][1];
	fiop->f_acctout6[0] = ipacct6[1][0];
	fiop->f_acctout6[1] = ipacct6[1][1];
#else
	fiop->f_fin6[0] = NULL;
	fiop->f_fin6[1] = NULL;
	fiop->f_fout6[0] = NULL;
	fiop->f_fout6[1] = NULL;
	fiop->f_acctin6[0] = NULL;
	fiop->f_acctin6[1] = NULL;
	fiop->f_acctout6[0] = NULL;
	fiop->f_acctout6[1] = NULL;
#endif
	fiop->f_active = fr_active;
	fiop->f_froute[0] = ipl_frouteok[0];
	fiop->f_froute[1] = ipl_frouteok[1];

	fiop->f_running = fr_running;
	fiop->f_groups[0][0] = ipfgroups[0][0];
	fiop->f_groups[0][1] = ipfgroups[0][1];
	fiop->f_groups[1][0] = ipfgroups[1][0];
	fiop->f_groups[1][1] = ipfgroups[1][1];
	fiop->f_groups[2][0] = ipfgroups[2][0];
	fiop->f_groups[2][1] = ipfgroups[2][1];
#ifdef  IPFILTER_LOG
	fiop->f_logging = 1;
#else
	fiop->f_logging = 0;
#endif
	fiop->f_defpass = fr_pass;
	strncpy(fiop->f_version, ipfilter_version, sizeof(fiop->f_version));
}


#ifdef	USE_INET6
int icmptoicmp6types[ICMP_MAXTYPE+1] = {
	ICMP6_ECHO_REPLY,	/* 0: ICMP_ECHOREPLY */
	-1,			/* 1: UNUSED */
	-1,			/* 2: UNUSED */
	ICMP6_DST_UNREACH,	/* 3: ICMP_UNREACH */
	-1,			/* 4: ICMP_SOURCEQUENCH */
	ND_REDIRECT,		/* 5: ICMP_REDIRECT */
	-1,			/* 6: UNUSED */
	-1,			/* 7: UNUSED */
	ICMP6_ECHO_REQUEST,	/* 8: ICMP_ECHO */
	-1,			/* 9: UNUSED */
	-1,			/* 10: UNUSED */
	ICMP6_TIME_EXCEEDED,	/* 11: ICMP_TIMXCEED */
	ICMP6_PARAM_PROB,	/* 12: ICMP_PARAMPROB */
	-1,			/* 13: ICMP_TSTAMP */
	-1,			/* 14: ICMP_TSTAMPREPLY */
	-1,			/* 15: ICMP_IREQ */
	-1,			/* 16: ICMP_IREQREPLY */
	-1,			/* 17: ICMP_MASKREQ */
	-1,			/* 18: ICMP_MASKREPLY */
};


int	icmptoicmp6unreach[ICMP_MAX_UNREACH] = {
	ICMP6_DST_UNREACH_ADDR,		/* 0: ICMP_UNREACH_NET */
	ICMP6_DST_UNREACH_ADDR,		/* 1: ICMP_UNREACH_HOST */
	-1,				/* 2: ICMP_UNREACH_PROTOCOL */
	ICMP6_DST_UNREACH_NOPORT,	/* 3: ICMP_UNREACH_PORT */
	-1,				/* 4: ICMP_UNREACH_NEEDFRAG */
	ICMP6_DST_UNREACH_NOTNEIGHBOR,	/* 5: ICMP_UNREACH_SRCFAIL */
	ICMP6_DST_UNREACH_ADDR,		/* 6: ICMP_UNREACH_NET_UNKNOWN */
	ICMP6_DST_UNREACH_ADDR,		/* 7: ICMP_UNREACH_HOST_UNKNOWN */
	-1,				/* 8: ICMP_UNREACH_ISOLATED */
	ICMP6_DST_UNREACH_ADMIN,	/* 9: ICMP_UNREACH_NET_PROHIB */
	ICMP6_DST_UNREACH_ADMIN,	/* 10: ICMP_UNREACH_HOST_PROHIB */
	-1,				/* 11: ICMP_UNREACH_TOSNET */
	-1,				/* 12: ICMP_UNREACH_TOSHOST */
	ICMP6_DST_UNREACH_ADMIN,	/* 13: ICMP_UNREACH_ADMIN_PROHIBIT */
};
#endif
@


1.20.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.20.2.3 2001/05/14 22:40:06 niklas Exp $	*/
@


1.19
log
@Update to Darren Reed's IPFilter 3.3.5
Fixes: realaudio proxy issues, "log level" printing, and
source address for icmp replies (was reversed).

Thoughtfully submitted by techs@@obfuscation.org
@
text
@d1 2
a2 1
/*       $OpenBSD: fil.c,v 1.18 1999/12/15 07:04:20 itojun Exp $       */
d12 1
a12 1
static const char rcsid[] = "@@(#)$Id: fil.c,v 1.18 1999/12/15 07:04:20 itojun Exp $";
d250 6
d641 1
a641 1
			/* need enough for complete ICMP error IP header */
d699 3
d1192 1
a1192 1
 * $Id: fil.c,v 1.18 1999/12/15 07:04:20 itojun Exp $
d1593 1
d1595 2
@


1.18
log
@don't check INET too much, it will make trouble with lkm compilation.
@
text
@d1 1
a1 1
/*       $OpenBSD: fil.c,v 1.17 1999/12/15 05:20:20 kjell Exp $       */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: fil.c,v 1.17 1999/12/15 05:20:20 kjell Exp $";
d1182 1
a1182 1
 * $Id: fil.c,v 1.17 1999/12/15 05:20:20 kjell Exp $
a1547 1
	in.s_addr = ntohl(in.s_addr);
@


1.17
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 1
a1 1
/*       $OpenBSD: fil.c,v 1.16 1999/12/08 06:50:18 itojun Exp $       */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: fil.c,v 1.16 1999/12/08 06:50:18 itojun Exp $";
a57 5
#ifdef _KERNEL
# ifndef INET
# error ipfilter assumes options INET
# endif
#endif
d1182 1
a1182 1
 * $Id: fil.c,v 2.3.2.13 1999/12/04 02:05:42 darrenr Exp $
@


1.16
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*       $OpenBSD: fil.c,v 1.15 1999/02/19 20:52:22 kjell Exp $       */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: fil.c,v 1.15 1999/02/19 20:52:22 kjell Exp $";
d19 11
a29 1
#include <sys/ioctl.h>
d45 1
a45 1
# include <sys/dditypes.h>
d47 1
a47 1
# include <sys/stream.h>
d59 3
a61 3
#ifndef INET
#error ipfilter assumes options INET
#endif
d69 4
d76 1
a76 5
#if defined(__OpenBSD__)
# include <netinet/ip_fil_compat.h>
#else
# include <netinet/ip_compat.h>
#endif
d84 6
d91 1
a91 1
#define	MIN(a,b)	(((a)<(b))?(a):(b))
d93 1
d106 1
a106 1
# define	SEND_RESET(ip, qif, if, m)		send_reset(ip, if)
a108 5
# if SOLARIS
#  define	ICMP_ERROR(b, ip, t, c, if, src) 	icmp_error(ip)
# else
#  define	ICMP_ERROR(b, ip, t, c, if, src) 	icmp_error(b, ip, if)
# endif
d116 1
a116 1
extern	KRWLOCK_T	ipf_mutex, ipf_auth;
d122 3
a124 3
#  define	SEND_RESET(ip, qif, if)		send_reset(ip, qif)
#  define	ICMP_ERROR(b, ip, t, c, if, src) \
			icmp_error(ip, t, c, if, src)
d128 2
a129 2
#   define	SEND_RESET(ip, qif, if)		send_reset((tcpiphdr_t *)ip,\
							   ifp)
d131 4
a134 18
#   define	SEND_RESET(ip, qif, if)		send_reset((tcpiphdr_t *)ip)
#  endif
#  ifdef __sgi
#   define	ICMP_ERROR(b, ip, t, c, if, src) \
			icmp_error(b, t, c, if, src, if)
#  else
#   if BSD < 199103
#    ifdef linux
#     define	ICMP_ERROR(b, ip, t, c, if, src) 	icmp_send(b,t,c,0,if)
#    else
#     define	ICMP_ERROR(b, ip, t, c, if, src) \
			icmp_error(mtod(b, ip_t *), t, c, if, src)
#    endif /* linux */
#   else
#    define	ICMP_ERROR(b, ip, t, c, if, src) \
			icmp_error(b, t, c, (src).s_addr, if)
#   endif /* BSD < 199103 */
#  endif /* __sgi */
d149 1
a152 1
static	void	fr_makefrip __P((int, ip_t *, fr_info_t *));
d154 4
a157 1
static	int	frflushlist __P((int, int, int *, frentry_t *, frentry_t **));
d205 1
a205 1
static	void	fr_makefrip(hlen, ip, fin)
d217 1
d235 2
a236 2
	(*(((u_32_t *)fi) + 1)) = (*(((u_32_t *)ip) + 3));
	(*(((u_32_t *)fi) + 2)) = (*(((u_32_t *)ip) + 4));
d285 3
a287 2
	for (s = (u_char *)(ip + 1), hlen -= sizeof(*ip); hlen; ) {
		if (!(opt = *s))
d432 1
a432 1
int pass;
d439 2
a440 1
	int rulen, portcmp = 0, off, skip = 0;
d464 10
a473 2
		if (fr->fr_ifa && fr->fr_ifa != fin->fin_ifp)
			continue;
d493 2
a494 1
			i |= ((lip[1] & lm[1]) != ld[1]) << 21;
d497 2
a498 1
			i |= ((lip[2] & lm[2]) != ld[2]) << 22;
a506 1
			i ^= (fi->fi_fl & (FR_NOTSRCIP|FR_NOTDSTIP));
d536 4
a539 4
		if (!(skip = fr->fr_skip))
			pass = fr->fr_flags;
		if ((pass & FR_CALLNOW) && fr->fr_func)
			pass = (*fr->fr_func)(pass, ip, fin);
d541 2
a542 2
		if ((pass & FR_LOGMASK) == FR_LOG) {
			if (!IPLLOG(fr->fr_flags, ip, fin, m)) {
d546 1
d549 2
a558 1
		fin->fin_fr = fr;
d567 2
d573 2
d603 2
a604 1
	int pass, changed, apass, error = EHOSTUNREACH;
d639 1
a640 1
			/* need enough for complete ICMP error IP header */
d676 2
d679 1
d682 7
d693 1
d707 1
a707 1
		changed = ip_natin(ip, hlen, fin);
d709 1
a709 1
		    (FR_SCANLIST(FR_NOMATCH, ip, fin, m) & FR_ACCOUNT)) {
d714 2
a715 2
	if (apass || (!(pass = ipfr_knownfrag(ip, fin)) &&
	    !(pass = fr_checkstate(ip, fin)))) {
d733 1
a733 2
				} else
					pass = fr_pass;
a734 1
				pass = fr_pass;
d736 4
a739 2
					pass = FR_SCANLIST(fr_pass, ip, fin, m);
				bcopy((char *)fin, (char *)fc, FI_COPYSIZE);
d764 1
a764 1
			    (pass = FR_SCANLIST(0, ip, fin, m))) {
d772 2
a773 1
		if (pass & FR_KEEPFRAG) {
d785 1
a785 1
			if (fr_addstate(ip, fin, pass) == -1) {
d791 4
d806 1
a806 1
		    (FR_SCANLIST(FR_NOMATCH, ip, fin, m) & FR_ACCOUNT)) {
d809 4
a812 4
		fin->fin_fr = NULL;
		changed = ip_natout(ip, hlen, fin);
	}
	fin->fin_fr = fr;
d842 4
d878 6
d886 1
a886 1
					   qif, ip->ip_src);
d889 1
a889 2
					   ifp, ip->ip_src);
				m = *mp = NULL;	/* freed by icmp_error() */
a890 1

d892 1
a892 1
			} else if ((pass & FR_RETRST) &&
d894 1
a894 1
				if (SEND_RESET(ip, qif, ifp) == 0) {
d899 1
a899 1
			if (pass & FR_RETICMP) {
d902 4
a905 1
			} else if ((pass & FR_RETRST) &&
d930 1
a930 1
		if ((pass & FR_FASTROUTE) ||
d932 2
a933 2
			ipfr_fastroute(m, fin, fdp);
			m = *mp = NULL;
a944 1
	return (pass & FR_PASS) ? 0 : error;
d949 1
a949 1
		if ((pass & FR_FASTROUTE) ||
d951 2
a952 2
			ipfr_fastroute(qif, ip, m, mp, fin, fdp);
			m = *mp = NULL;
a956 1
	return (pass & FR_PASS) ? changed : error;
d958 1
d1003 1
a1003 1
u_short fr_tcpsum(m, ip, tcp, len)
a1006 1
int len;
a1011 1

d1017 1
a1017 1
	sum = htons(ip->ip_p);
d1028 1
a1028 1
	sum2 = ip_cksum(m, hlen, sum);
a1054 1

d1059 1
a1059 2
	u_32_t sum;
	u_short	*sp, slen;
d1070 1
a1070 1
	sum += htons((u_short)len);
d1084 2
a1085 2
	sum += *sp;	/* win */
	sp += 2;	/* Skip over checksum */
d1143 1
a1143 1
#   endif /*  defined(BSD)  || defined(sun) */
d1187 1
a1187 1
 * $Id: fil.c,v 1.15 1999/02/19 20:52:22 kjell Exp $
d1287 1
a1287 1
u_short num;
d1289 2
a1290 1
int which, set;
d1303 1
d1317 1
a1317 1
u_short num;
d1319 2
a1320 1
int which, set;
d1327 1
a1327 1
	KMALLOC(fg, frgroup_t *, sizeof(*fg));
d1329 1
a1329 1
		fg->fg_num = num;
d1340 1
a1340 1
u_short num;
d1342 2
a1343 1
int which, set;
d1361 5
a1365 3
static int frflushlist(set, unit, nfreedp, list, listp)
int set, unit, *nfreedp;
frentry_t *list, **listp;
d1367 2
a1368 2
	register frentry_t *fp = list, *fpn;
	register int freed = 0;
d1370 2
a1371 2
	while (fp) {
		fpn = fp->fr_next;
d1373 4
a1376 2
			fp->fr_ref -= frflushlist(set, unit, nfreedp,
						  fp->fr_grp, &fp->fr_grp);
d1379 7
a1385 4
		if (fp->fr_ref == 1) {
			if (fp->fr_grhead)
				fr_delgroup(fp->fr_grhead, fp->fr_flags, unit,
					    set);
a1386 1
			*listp = fpn;
d1388 2
a1389 2
		}
		fp = fpn;
d1396 3
a1398 3
void frflush(unit, result)
int unit;
int *result;
d1400 1
a1400 1
	int flags = *result, flushed = 0, set = fr_active;
d1402 2
d1407 1
d1411 156
a1566 14
	if (unit == IPL_LOGIPF) {
		if (flags & FR_OUTQUE) {
			(void) frflushlist(set, unit, &flushed,
					   ipfilter[1][set],
					   &ipfilter[1][set]);
			(void) frflushlist(set, unit, &flushed,
					   ipacct[1][set], &ipacct[1][set]);
		}
		if (flags & FR_INQUE) {
			(void) frflushlist(set, unit, &flushed,
					   ipfilter[0][set],
					   &ipfilter[0][set]);
			(void) frflushlist(set, unit, &flushed,
					   ipacct[0][set], &ipacct[0][set]);
d1568 2
d1571 26
a1597 1
	*result = flushed;
d1599 14
@


1.15
log
@fix definition of plen for ICMP (ping -s73 problem)
@
text
@d1 1
a1 1
/*       $OpenBSD: fil.c,v 1.14 1999/02/05 05:58:49 deraadt Exp $       */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: fil.c,v 1.14 1999/02/05 05:58:49 deraadt Exp $";
d48 5
d1145 1
a1145 1
 * $Id: fil.c,v 1.14 1999/02/05 05:58:49 deraadt Exp $
@


1.14
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*       $OpenBSD: fil.c,v 1.13 1998/09/15 09:51:17 pattonme Exp $       */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: fil.c,v 1.2 1999/01/28 23:15:36 cgrant Exp $";
a613 1
			/* 96 - enough for complete ICMP error IP header */
d615 2
a616 1
				plen = 76 + sizeof(struct icmp);
d1140 1
a1140 1
 * $Id: fil.c,v 1.2 1999/01/28 23:15:36 cgrant Exp $
@


1.13
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*       $OpenBSD: fil.c,v 1.12 1998/02/17 01:39:01 dgregor Exp $       */
d3 1
a3 1
 * Copyright (C) 1993-1997 by Darren Reed.
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id$";
d34 1
d36 1
a97 6
# if SOLARIS
extern	krwlock_t	ipf_mutex, ipf_auth;
# endif
# if defined(__sgi)
extern	kmutex_t	ipf_mutex, ipf_auth;
# endif
d99 1
a205 1
	icmphdr_t *icmp;
a225 1
	icmp = (icmphdr_t *)tcp;
d232 1
a232 1
	off = (ip->ip_off & 0x1fff) << 3;
d240 1
d242 4
a245 3
		if (!off && ip->ip_len > ICMP_MINLEN + hlen &&
		    (icmp->icmp_type == ICMP_ECHOREPLY ||
		     icmp->icmp_type == ICMP_UNREACH))
d408 1
a408 1
		if (fr->fr_tcpf &&
d437 1
a437 1
	off = ip->ip_off & 0x1fff;
d557 1
a557 1
 * check using source and destination addresses/pors in a packet whether
d605 9
a613 9
		switch(ip->ip_p)
		{
		case IPPROTO_TCP:
			plen = sizeof(tcphdr_t);
			break;
		case IPPROTO_UDP:
			plen = sizeof(udphdr_t);
			break;
		case IPPROTO_ICMP:
d615 4
a618 3
			plen = sizeof(struct icmp) + sizeof(ip_t) + 8;
			break;
		}
d958 49
d1012 3
a1014 3
	u_short	*sp;
# if SOLARIS || defined(__sgi)
	int add, hlen;
d1020 1
a1020 2
	bytes.c[0] = 0;
	bytes.c[1] = IPPROTO_TCP;
d1022 1
a1022 1
	sum = bytes.s;
d1024 1
a1024 3
	sp = (u_short *)&ip->ip_src;
	sum += *sp++;
	sum += *sp++;
d1026 1
d1030 3
d1034 1
d1036 2
a1037 6
	sum += *sp++;
	sum += *sp++;
	sum += *sp++;
	sum += *sp++;
	sum += *sp++;
	sum += *sp;
d1039 1
a1039 1
	sum += *sp++;
d1041 1
a1041 21
#if SOLARIS
	/*
	 * In case we had to copy the IP & TCP header out of mblks,
	 * skip over the mblk bits which are the header
	 */
	if ((caddr_t)ip != (caddr_t)m->b_rptr) {
		hlen = (caddr_t)sp - (caddr_t)ip;
		while (hlen) {
			add = MIN(hlen, m->b_wptr - m->b_rptr);
			sp = (u_short *)((caddr_t)m->b_rptr + add);
			hlen -= add;
			if ((caddr_t)sp >= (caddr_t)m->b_wptr) {
				m = m->b_cont;
				PANIC((!m),("fr_tcpsum: not enough data"));
				if (!hlen)
					sp = (u_short *)m->b_rptr;
			}
		}
	}
#endif
#ifdef	__sgi
d1052 1
a1052 1
			if (add >= m->m_len) {
d1054 3
a1056 2
				PANIC((!m),("fr_tcpsum: not enough data"));
				if (!hlen)
d1058 2
d1063 1
a1063 1
#endif
d1067 5
a1071 6
	while (len > 0) {
#if SOLARIS
		while ((caddr_t)sp >= (caddr_t)m->b_wptr) {
			m = m->b_cont;
			PANIC((!m),("fr_tcpsum: not enough data"));
			sp = (u_short *)m->b_rptr;
d1073 2
a1074 3
#else
		while (((caddr_t)sp - mtod(m, caddr_t)) >= m->m_len)
		{
d1076 1
a1076 1
			PANIC((!m),("fr_tcpsum: not enough data"));
d1078 3
d1082 1
a1082 4
#endif /* SOLARIS */
		if (len < 2)
			break;
		if((u_long)sp & 1) {
d1089 2
a1090 5
	if (len) {
		bytes.c[1] = 0;
		bytes.c[0] = *(u_char *)sp;
		sum += bytes.s;
	}
d1092 11
a1102 4
	sum = (sum >> 16) + (sum & 0xffff);
	sum += (sum >> 16);
	sum = (u_short)((~sum) & 0xffff);
	return sum;
d1140 1
a1140 1
 * $Id: fil.c,v 1.3 1998/09/02 18:47:44 pattonme Exp $
@


1.12
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*       $OpenBSD$       */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: fil.c,v 1.11 1998/01/26 04:10:37 dgregor Exp $";
d25 1
d55 5
a59 1
#include "ip_fil_compat.h"
d61 6
a66 6
#include "ip_fil.h"
#include "ip_proxy.h"
#include "ip_nat.h"
#include "ip_frag.h"
#include "ip_state.h"
#include "ip_auth.h"
d84 1
a84 1
#  define	FR_NEWAUTH(m, fi, ip, qif)	fr_newauth((mb_t *)m, fi, ip)
d96 6
d103 1
a103 1
extern	kmutex_t	ipf_mutex, ipf_auth;
d209 1
d230 1
d243 8
a250 1
		if ((!IPMINLEN(ip, icmp) && !off) ||
d256 1
d500 3
d504 1
a504 5
			if (portcmp) {
				if (!fr_tcpudpchk(fr, fin))
					continue;
			} else if (fr->fr_dcmp || fr->fr_scmp || fr->fr_tcpf ||
				   fr->fr_tcpfm)
d506 8
a513 10
		} else if (fi->fi_p == IPPROTO_ICMP) {
			if (!off && (fin->fin_dlen > 1)) {
				if ((fin->fin_data[0] & fr->fr_icmpm) !=
				    fr->fr_icmp) {
					FR_DEBUG(("i. %#x & %#x != %#x\n",
						 fin->fin_data[0],
						 fr->fr_icmpm, fr->fr_icmp));
					continue;
				}
			} else if (fr->fr_icmpm || fr->fr_icmp)
d515 1
d527 4
a530 3
			if (!IPLLOG(fr->fr_flags, ip, fin, m))
				frstats[fin->fin_out].fr_skip++;
			frstats[fin->fin_out].fr_pkl++;
d534 1
a534 1
		fr->fr_hits++;
d595 9
d624 2
a625 1
#ifdef __sgi /* Under IRIX, avoid m_pullup as it makes ping <hostname> panic */
d627 1
a627 1
				frstats[out].fr_pull[1]++;
d631 1
a631 1
			frstats[out].fr_pull[0]++;
d633 2
a634 2
#else
# ifndef linux
d636 1
a636 1
				frstats[out].fr_pull[1]++;
d639 1
a639 1
				frstats[out].fr_pull[0]++;
d643 2
a644 2
# endif
#endif
d649 1
a649 1
# endif
d652 2
d655 1
a655 1
#endif
d661 1
a661 1
	MUTEX_ENTER(&ipf_mutex);
d675 3
a677 2
		    (FR_SCANLIST(FR_NOMATCH, ip, fin, m) & FR_ACCOUNT))
			frstats[0].fr_acct++;
d695 1
a695 1
				frstats[out].fr_chit++;
d697 1
a697 1
					fr->fr_hits++;
d706 3
a708 2
				if (pass & FR_NOMATCH)
					frstats[out].fr_nom++;
d728 1
a728 1
			MUTEX_ENTER(&ipf_auth);
d730 6
a735 5
			    (pass = FR_SCANLIST(0, ip, fin, m)))
				fr_authstats.fas_hits++;
			else
				fr_authstats.fas_miss++;
			MUTEX_EXIT(&ipf_auth);
d740 8
a747 6
				if (ipfr_newfrag(ip, fin, pass) == -1)
					frstats[out].fr_bnfr++;
				else
					frstats[out].fr_nfr++;
			} else
				frstats[out].fr_cfr++;
d750 5
a754 4
			if (fr_addstate(ip, fin, pass) == -1)
				frstats[out].fr_bads++;
			else
				frstats[out].fr_ads++;
d767 3
a769 2
		    (FR_SCANLIST(FR_NOMATCH, ip, fin, m) & FR_ACCOUNT))
			frstats[1].fr_acct++;
d774 1
a774 1
	MUTEX_EXIT(&ipf_mutex);
d780 1
a780 1
			frstats[out].fr_npkl++;
d786 1
a786 1
			frstats[out].fr_ppkl++;
d792 1
a792 1
			frstats[out].fr_bpkl++;
d795 1
a795 1
				frstats[out].fr_skip++;
d820 4
a823 4
	if (pass & FR_PASS)
		frstats[out].fr_pass++;
	else if (pass & FR_BLOCK) {
		frstats[out].fr_block++;
d844 1
a844 1
				frstats[0].fr_ret++;
d847 3
a849 2
				if (SEND_RESET(ip, qif, ifp) == 0)
					frstats[1].fr_ret++;
d854 1
a854 1
				frstats[0].fr_ret++;
d858 1
a858 1
				frstats[1].fr_ret++;
d931 1
a931 1
	register u_long sum = 0;
d964 1
a964 1
	u_long sum;
a969 7
# if SOLARIS
	/* skip any leading M_PROTOs */
	while(m && (MTYPE(m) != M_DATA))
		m = m->b_cont;
	PANIC((!m),("fr_tcpsum: no M_DATA"));
# endif

d1110 1
a1110 1
 * $Id: fil.c,v 1.11 1998/01/26 04:10:37 dgregor Exp $
d1315 1
d1337 1
a1337 1

@


1.11
log
@IPF 3.2.3
@
text
@d1 1
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: fil.c,v 2.0.2.41.2.9 1997/12/02 13:56:06 darrenr Exp $";
d1077 1
a1077 1
 * $Id: fil.c,v 2.0.2.41.2.9 1997/12/02 13:56:06 darrenr Exp $
@


1.10
log
@merge in 3.1.11
@
text
@a0 1
/*	$OpenBSD: fil.c,v 1.9 1997/04/03 15:46:36 kstailey Exp $	*/
d2 1
a2 1
 * (C)opyright 1993-1996 by Darren Reed.
d8 3
a10 5
#if 0
#if !defined(lint) && defined(LIBC_SCCS)
static	char	sccsid[] = "@@(#)fil.c	1.36 6/5/96 (C) 1993-1996 Darren Reed";
static	char	rcsid[] = "$DRId: fil.c,v 2.0.1.10 1997/04/13 22:33:07 darrenr Exp $";
#endif
d16 1
d19 1
a19 1
#if defined(_KERNEL) || defined(KERNEL)
d27 3
a29 1
# include <sys/mbuf.h>
d35 4
a38 2
#include <sys/protosw.h>
#include <sys/socket.h>
d47 3
a49 1
#include <netinet/ip_var.h>
a51 1
#include <netinet/tcpip.h>
d54 1
d56 1
d60 1
d66 2
a67 1
#include "ipf.h"
a68 1
extern	void	debug(), verbose();
d70 9
a78 5
#define	FR_IFVERBOSE(ex,second,verb_pr)	if (ex) { verbose verb_pr; second; }
#define	FR_IFDEBUG(ex,second,verb_pr)	if (ex) { debug verb_pr; second; }
#define	FR_VERBOSE(verb_pr)	verbose verb_pr
#define	FR_DEBUG(verb_pr)	debug verb_pr
#define	FR_SCANLIST(p, ip, fi, m)	fr_scanlist(p, ip, fi, NULL)
d80 12
a91 1
#  define	bcmp	memcmp
a92 7
#else
#define	FR_IFVERBOSE(ex,second,verb_pr)	;
#define	FR_IFDEBUG(ex,second,verb_pr)	;
#define	FR_VERBOSE(verb_pr)
#define	FR_DEBUG(verb_pr)
#define	FR_SCANLIST(p, ip, fi, m)	fr_scanlist(p, ip, fi, m)
extern	int	send_reset __P((struct tcpiphdr *));
d94 3
a96 18
extern	int	icmp_error(), ipfr_fastroute();
extern	kmutex_t	ipf_mutex, ipl_mutex;
# else
extern	void	ipfr_fastroute __P((struct mbuf *, fr_info_t *, frdest_t *));
# endif
extern	int	ipl_unreach;
extern	int	ipllog __P((u_int, ip_t *, register fr_info_t *,
			    struct mbuf *));
#endif

#if SOLARIS
# define	SEND_RESET(ip, if, q)		send_reset(ip, qif, q)
# define	ICMP_ERROR(b, ip, t, c, if, src) \
			icmp_error(b, ip, t, c, if, src)
#else
# define	SEND_RESET(ip, if, q)		send_reset( \
						    (struct tcpiphdr *)ip)
# if BSD < 199103
d98 18
d117 3
a119 2
# else
#  define	ICMP_ERROR(b, ip, t, c, if, src) \
d121 4
a124 2
# endif
#endif
a125 8
#ifndef	IPF_LOGGING
#define	IPF_LOGGING	0
#endif
#ifdef	IPF_DEFAULT_PASS
#define	IPF_NOMATCH	(IPF_DEFAULT_PASS|FR_NOMATCH)
#else
#define	IPF_NOMATCH	(FR_PASS|FR_NOMATCH)
#endif
d130 1
d132 5
d140 4
a143 3
void	fr_makefrip __P((int, ip_t *, fr_info_t *));
int	fr_tcpudpchk __P((frentry_t *, fr_info_t *));
int	fr_scanlist __P((int, ip_t *, fr_info_t *, void *m));
d190 4
a193 5
void
fr_makefrip(hlen, ip, fin)
     int hlen;
     ip_t *ip;
     fr_info_t *fin;
d207 2
d219 2
a220 2
	(*(((u_int32_t *)fi) + 1)) = (*(((u_int32_t *)ip) + 3));
	(*(((u_int32_t *)fi) + 2)) = (*(((u_int32_t *)ip) + 4));
d222 1
a222 1
	fi->fi_fl = (hlen > sizeof(struct ip)) ? FI_OPTIONS : 0;
d311 3
a313 4
int
fr_tcpudpchk(fr, fin)
     frentry_t *fr;
     fr_info_t *fin;
d404 5
a408 6
int
fr_scanlist(pass, ip, fin, m)
     int pass;
     ip_t *ip;
     register fr_info_t *fin;
     void *m;
d412 1
a412 1
	int rulen, portcmp = 0, off;
d417 1
d419 1
a419 1
	pass |= (fi->fi_fl << 20);
d425 4
d441 3
a443 3
		FR_VERBOSE(("%c", (pass & FR_PASS) ? 'p' : 'b'));
		if (fin->fin_ifp && *fr->fr_ifname &&
		    strcasecmp((char *)fin->fin_ifp, fr->fr_ifname))
d448 1
a448 1
			register u_long	*ld, *lm, *lip;
d451 3
a453 3
			lip = (u_long *)fi;
			lm = (u_long *)&fr->fr_mip;
			ld = (u_long *)&fr->fr_ip;
d457 1
a457 1
			i |= ((lip[1] & lm[1]) != ld[1]);
d460 1
a460 1
			i |= ((lip[2] & lm[2]) != ld[2]);
d469 1
d501 2
a502 1
		pass = fr->fr_flags;
d507 1
a507 1
			if (!ipllog(fr->fr_flags, ip, fin, m))
d515 1
a515 1
			fr->fr_bytes += ip->ip_len;
d519 1
d521 9
d539 1
a539 1
 * check using source and destination addresses/ports in a packet whether
d542 4
a545 12
int
fr_check(ip, hlen, ifp, out
#ifdef _KERNEL
# if SOLARIS
    , qif, q, mp)
	qif_t *qif;
	queue_t *q;
	mblk_t **mp;
# else
    , mp)
	struct mbuf **mp;
# endif
d547 1
a547 1
    )
d549 5
a553 4
     ip_t *ip;
     int hlen;
     struct ifnet *ifp;
     int out;
d561 4
a564 1
	int pass, changed;
d566 7
a572 3
#if !defined(__SVR4) && !defined(__svr4__) && defined(_KERNEL)
	register struct mbuf *m = *mp;
	struct mbuf *mc = NULL;
d576 16
a591 1
		register int up = MIN(hlen + 8, ip->ip_len);
d594 10
d610 1
a610 1
				ip = mtod(m, struct ip *);
d612 1
a612 2
		}
	}
d614 8
a621 2
#if SOLARIS && defined(_KERNEL)
	mblk_t *mc = NULL, *m = qif->qf_m;
d626 1
d629 10
d641 1
a641 1
		if ((fin->fin_fr = ipacct[0][fr_active]) &&
d646 51
a696 4
	if ((pass = ipfr_knownfrag(ip, fin))) {
		if ((pass & FR_KEEPSTATE)) {
			if (fr_addstate(ip, fin, pass) == -1)
				frstats[out].fr_bads++;
d698 2
a699 29
				frstats[out].fr_ads++;
		}
	} else if ((pass = fr_checkstate(ip, fin))) {
		if ((pass & FR_KEEPFRAG)) {
			if (fin->fin_fi.fi_fl & FI_FRAG) {
				if (ipfr_newfrag(ip, fin, pass) == -1)
					frstats[out].fr_bnfr++;
				else
					frstats[out].fr_nfr++;
			} else
				frstats[out].fr_cfr++;
		}
	} else {
		fc = frcache + out;
		if (fc->fin_fr && !bcmp((char *)fin, (char *)fc, FI_CSIZE)) {
			/*
			 * copy cached data so we can unlock the mutex
			 * earlier.
			 */
			bcopy((char *)fc, (char *)fin, sizeof(*fin));
			frstats[out].fr_chit++;
			pass = fin->fin_fr->fr_flags;
		} else {
			pass = IPF_NOMATCH;
			if ((fin->fin_fr = ipfilter[out][fr_active]))
				pass = FR_SCANLIST(IPF_NOMATCH, ip, fin, m);
			bcopy((char *)fin, (char *)fc, FI_CSIZE);
			if (pass & FR_NOMATCH)
				frstats[out].fr_nom++;
a700 1
		fr = fin->fin_fr;
d702 1
a702 1
		if ((pass & FR_KEEPFRAG)) {
d722 5
a726 1
	if (out) {
d754 1
a754 1
			if (!ipllog(pass, ip, fin, m)) {
a762 1

d764 5
d770 1
a770 1
# if SOLARIS
d773 1
d775 3
d807 1
a807 1
				if (SEND_RESET(ip, qif, q) == 0)
d820 3
d825 11
a835 2
#ifdef	_KERNEL
# if	!SOLARIS
d849 7
a855 2
	return (pass & FR_PASS) ? 0 : -1;
# else
d867 3
a869 3
	return (pass & FR_PASS) ? changed : -1;
# endif
#else
d874 2
d877 1
a877 1
#endif
d881 8
a888 3
#ifdef	IPFILTER_LOG
# if !(defined(_KERNEL))
static void ipllog()
d890 15
a904 1
	verbose("l");
d906 21
d929 112
d1042 46
a1087 3
int fr_copytolog(buf, len)
char *buf;
int len;
d1089 1
a1089 1
	int	clen, tail;
d1091 19
a1109 16
	tail = (iplh >= iplt) ? (iplbuf + IPLLOGSIZE - iplh) : (iplt - iplh);
	clen = MIN(tail, len);
	bcopy(buf, iplh, clen);
	len -= clen;
	tail -= clen;
	iplh += clen;
	buf += clen;
	if (iplh == iplbuf + IPLLOGSIZE) {
		iplh = iplbuf;
		tail = iplt - iplh;
	}
	if (len && tail) {
		clen = MIN(tail, len);
		bcopy(buf, iplh, clen);
		len -= clen;
		iplh += clen;
a1110 1
	return len;
d1112 56
d1169 136
@


1.9
log
@>Number:         3412
>Category:       port-alpha
>Synopsis:       incorrect use of long crashes netbsd/alpha
>Confidential:   no
>Severity:       serious
>Priority:       low
>Responsible:    gnats-admin (GNATS administrator)
>State:          open
>Class:          sw-bug
>Submitter-Id:   net
>Arrival-Date:   Sat Mar 29 23:50:01 1997
>Last-Modified:
>Originator:     Ross Harvey
>Organization:
Avalon Computer Systems, Inc.
>Release:        NetBSD-current
>Environment:
System: NetBSD epsilon.ghs.com 1.2D NetBSD 1.2D (e) #5: Sat Mar 29 22:32:33 PST 1997 ross@@epsilon.ghs.com:/bsd/ross/e alpha

>Description:
	Adding "pseudo-device ipfilter 1" to netbsd/alpha will
	cause it to crash when ifconfig turns on the interface.

	Ipfilter code in netinet/fil.c uses pointer arithmetic to
	effectively make structure-to-scalar casts. It uses long when
	it really wants an int32 and gets alignment faults that crash
	netbsd/alpha. General 64 bit problem, not exactly alpha.

>How-To-Repeat:
	Add pseudo-device ipfilter 1. Boot your alpha. 2. Try to come
	up multiuser. The first packet or so will halt everything.

>Fix:
	Apply patch...
@
text
@d1 1
a1 1
/*	$OpenBSD: fil.c,v 1.8 1997/02/11 22:23:08 kstailey Exp $	*/
d12 1
a12 1
static	char	rcsid[] = "Id: fil.c,v 2.0.1.3 1997/01/29 13:38:54 darrenr Exp";
d106 9
d118 1
a118 1
int	fr_flags = 0, fr_active = 0;
d458 2
a459 2
 			} else if (fr->fr_dcmp || fr->fr_scmp || fr->fr_tcpf ||
 				   fr->fr_tcpfm)
d598 1
a598 1
			pass = FR_NOMATCH;
d600 1
a600 1
				pass = FR_SCANLIST(FR_NOMATCH, ip, fin, m);
d602 1
a602 1
			if (pass & FR_NOMATCH) {
a603 4
#ifdef	NOMATCH
				pass |= NOMATCH;
#endif
			}
d624 1
a624 1
	if (fr && fr->fr_func)
d665 8
d680 4
d685 1
d687 1
a687 1
		if (pass & FR_RETICMP) {
d689 2
a690 2
			ICMP_ERROR(q, ip, ICMP_UNREACH, fin->fin_icode,
				   qif, ip->ip_src);
d692 3
a694 3
			ICMP_ERROR(m, ip, ICMP_UNREACH, fin->fin_icode,
				   ifp, ip->ip_src);
			m = NULL;	/* freed by icmp_error() */
d697 13
a709 4
			frstats[0].fr_ret++;
		} else if ((pass & FR_RETRST) &&
			   !(fin->fin_fi.fi_fl & FI_SHORT)) {
			if (SEND_RESET(ip, qif, q) == 0)
d711 2
a713 10
#else
		if (pass & FR_RETICMP) {
			verbose("- ICMP unreachable sent\n");
			frstats[0].fr_ret++;
		} else if ((pass & FR_RETRST) &&
			   !(fin->fin_fi.fi_fl & FI_SHORT)) {
			verbose("- TCP RST sent\n");
			frstats[1].fr_ret++;
		}
#endif
a716 2
	if (pass & FR_DUP)
		mc = m_copy(m, 0, M_COPYALL);
a723 1
			pass = 0;
a731 2
	if (pass & FR_DUP)
		mc = dupmsg(m);
@


1.8
log
@IPF 1.3.7
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d190 2
a191 2
	(*(((u_long *)fi) + 1)) = (*(((u_long *)ip) + 3));
	(*(((u_long *)fi) + 2)) = (*(((u_long *)ip) + 4));
@


1.7
log
@<sys/dir.h> is for use as a compatibility interface only.  Warn if
included by kernel modules, and also remove use from any modules that
currently attempt to use it.
@
text
@d1 1
d10 1
a10 1
#ifndef	lint
d12 1
a12 1
static	char	rcsid[] = "$OpenBSD: fil.c,v 1.6 1996/10/08 07:33:24 niklas Exp $";
a28 5
# if defined(__OpenBSD__)
#  include <sys/dirent.h>
# else
#  include <sys/dir.h>
# endif
d68 1
a68 1
#define	FR_SCANLIST(p, ip, fi, m)	fr_scanlist(p, ip, fi)
d77 2
d80 2
a81 3
extern	int	icmp_error();
extern	kmutex_t	ipf_mutex;
# define	FR_SCANLIST(p, ip, fi, m)	fr_scanlist(p, ip, fi)
d83 1
a83 1
# define	FR_SCANLIST(p, ip, fi, m)	fr_scanlist(p, ip, fi, m)
d86 2
a90 1
# define	IPLLOG(fl, ip, fi, m)		ipllog(fl, ip, fi)
a94 1
# define	IPLLOG(fl, ip, fi, m)		ipllog(fl, ip, fi, m)
d112 1
a112 1
 
d115 1
a115 5
#if (defined(_KERNEL) || defined(KERNEL)) && !SOLARIS
int	fr_scanlist __P((int, ip_t *, fr_info_t *, void *));
#else
int	fr_scanlist __P((int, ip_t *, fr_info_t *));
#endif
d164 3
a166 3
	int hlen;
	ip_t *ip;
	fr_info_t *fin;
d284 2
a285 2
	frentry_t *fr;
	fr_info_t *fin;
d377 5
a381 10
fr_scanlist(pass, ip, fin
#if (defined(_KERNEL) || defined(KERNEL)) && !SOLARIS
    , m)
	void *m;
#else
    )
#endif
	int pass;
	ip_t *ip;
	register fr_info_t *fin;
d387 2
d396 1
a396 1
	for (rulen = 0, fr = fin->fin_fr; fr; fr = fr->fr_next, rulen++) {
d449 2
a450 1
			} else if (fr->fr_dcmp || fr->fr_scmp)
d461 1
a461 1
			} else if (fr->fr_icmpm || fr->fr_tcpfm)
d465 3
a467 3
                /*
                 * Just log this packet...
                 */
d473 1
a473 1
			if (!IPLLOG(fr->fr_flags, ip, fin, m))
d484 2
a488 2
	fin->fin_rule = rulen;
	fin->fin_fr = fr;
d495 1
a495 1
 * check using source and destination addresses/pors in a packet whether
d502 1
a502 1
    , qif, q, mb)
d505 1
a505 1
	mblk_t *mb;
d513 4
a516 4
	ip_t *ip;
	int hlen;
	struct ifnet *ifp;
	int out;
d523 2
a524 2
	frentry_t *fr;
	int pass;
d535 2
a536 1
			if ((*mp = m_pullup(m, up)) == 0)
d538 2
a539 1
			else {
d546 2
a547 2
#if SOLARIS
	mblk_t *mc = NULL;
d555 1
a555 1
		ip_natin(ip, hlen, fin);
a562 7
			/*
			 * XXX I don't know if changing hlen to fin is right,
			 * but at least that is typesafe.  //niklas@@appli.se
			 *
			 * old code was:
			 * if (fr_addstate(ip, hlen, pass) == -1)
			 */
d600 1
a618 2
	fr = fin->fin_fr;

d626 2
a627 1
		ip_natout(ip, hlen, fin);
d629 1
d650 1
a650 1
			if (!IPLLOG(pass, ip, fin, m))
d652 4
d704 1
a704 1
		    (fdp->fd_ifp && fdp->fd_ifp != (struct ifnet *)-1))
d706 3
d714 1
a715 1
	/*
d717 1
a717 1
		mc = dupmsg(mb);
d722 4
a725 2
		    (fdp->fd_ifp && fdp->fd_ifp != (struct ifnet *)-1))
			ipfr_fastroute(mb, fin, fdp);
d727 1
a727 1
			ipfr_fastroute(mc, fin, &fr->fr_dif);
d729 1
a729 1
	*/
a730 1
	return (pass & FR_PASS) ? 0 : -1;
d741 2
a742 1
#ifndef	_KERNEL
d746 28
@


1.6
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d11 1
a11 1
static	char	rcsid[] = "$OpenBSD: fil.c,v 1.5 1996/07/18 05:00:55 dm Exp $";
d28 5
a32 1
# include <sys/dir.h>
@


1.5
log
@ipfilter 3.1.0
@
text
@d8 1
d11 2
a12 1
static	char	rcsid[] = "$Id: fil.c,v 1.3 1996/07/01 13:30:39 darrenr Exp $";
d50 1
a51 1
#include "ip_fil_compat.h"
a76 1
extern	int	send_reset();
d84 1
a84 1
extern	int	ipl_unreach, ipllog();
d94 2
a95 1
# define	SEND_RESET(ip, if, q)		send_reset(ip)
d112 7
d165 5
a169 4
void	fr_makefrip(hlen, ip, fin)
int hlen;
ip_t *ip;
fr_info_t *fin;
d285 4
a288 3
int fr_tcpudpchk(fr, fin)
frentry_t *fr;
fr_info_t *fin;
d379 11
a389 5
int fr_scanlist(pass, ip, fin, m)
int pass;
ip_t *ip;
register fr_info_t *fin;
void *m;
d475 1
a475 1
			pass = (*fr->fr_func)(ip, fin);
d503 2
a504 1
int fr_check(ip, hlen, ifp, out
d507 4
a510 4
, qif, q, mb)
qif_t *qif;
queue_t *q;
mblk_t *mb;
d512 2
a513 2
, mp)
struct mbuf **mp;
d516 1
a516 1
)
d518 4
a521 4
ip_t *ip;
int hlen;
struct ifnet *ifp;
int out;
d566 8
a573 1
			if (fr_addstate(ip, hlen, pass) == -1)
@


1.4
log
@fix return-rst
@
text
@d9 2
a10 1
static	char	sccsid[] = "@@(#)fil.c	1.32 4/10/96 (C) 1993-1996 Darren Reed";
d49 1
d156 1
a156 1
fr_info_t *fr_makefrip(hlen, ip, fin)
d168 1
a168 3
	fin->fin_dp = ((char *)ip + hlen);
	tcp = (tcphdr_t *)fin->fin_dp;
	fi->fi_fl = 0;
d180 2
d186 1
a186 2
	if (hlen > sizeof(struct ip))
		fi->fi_fl |= FI_OPTIONS;
d206 1
a206 1
		break;
d212 5
a221 4
	if ((fi->fi_fl & FI_TCPUDP) && !off && (fin->fin_dlen > 3)) {
		fin->fin_data[0] = ntohs(tcp->th_sport);
		fin->fin_data[1] = ntohs(tcp->th_dport);
	}
a268 1
	return fin;
d442 1
a442 1
				if ((*(u_short *)fin->fin_dp & fr->fr_icmpm) !=
d445 1
a445 1
						 *(u_short *)fin->fin_dp,
d457 2
d460 1
a460 1
		if (pass & FR_LOG) {
a467 2
		fin->fin_fr = fr;
		fin->fin_rule = rulen;
d475 2
d489 1
a489 1
, qif, q)
d492 1
a507 1
	register fr_info_t *fin;
d509 2
d515 1
d531 4
a534 1
	fin = fr_makefrip(hlen, ip, &frinfo);
d564 1
a564 1
		fc = frcache+out;
d566 5
a570 1
			fin = fc;
d596 1
a596 1
			if (fr_addstate(ip, hlen, pass) == -1)
d603 5
d617 20
a636 19
	if ((fr_flags & FF_LOGNOMATCH) && (pass & FR_NOMATCH)) {
		pass |= FF_LOGNOMATCH;
		if (!IPLLOG(pass, ip, fin, m))
			frstats[out].fr_skip++;
		frstats[out].fr_npkl++;
	} else if (((pass & FR_LOGP) == FR_LOGP) ||
	    ((pass & FR_PASS) && (fr_flags & FF_LOGPASS))) {
		if ((pass & FR_LOGP) != FR_LOGP)
			pass |= FF_LOGPASS;
		if (!IPLLOG(pass, ip, fin, m))
			frstats[out].fr_skip++;
		frstats[out].fr_ppkl++;
	} else if (((pass & FR_LOGB) == FR_LOGB) ||
		   ((pass & FR_BLOCK) && (fr_flags & FF_LOGBLOCK))) {
		if ((pass & FR_LOGB) != FR_LOGB)
			pass |= FF_LOGBLOCK;
		if (!IPLLOG(pass, ip, fin, m))
			frstats[out].fr_skip++;
		frstats[out].fr_bpkl++;
d660 1
a660 1
		} else if (pass & FR_RETRST &&
d669 2
a670 1
		} else if (pass & FR_RETRST && IPMINLEN(ip, tcphdr)) {
d678 11
d691 14
@


1.3
log
@ipfilter 3.0.4
@
text
@d642 1
a642 1
			   (fin->fin_fi.fi_fl & FI_SHORT)) {
@


1.2
log
@IP filter 3.0.1
@
text
@d2 1
a2 1
 * (C)opyright 1993,1994,1995 by Darren Reed.
d9 1
a9 1
static	char	sccsid[] = "@@(#)fil.c	1.26 1/14/96 (C) 1993-1996 Darren Reed";
d12 10
a21 35
#ifndef	linux
# include <sys/errno.h>
# include <sys/types.h>
# include <sys/param.h>
# include <sys/file.h>
# include <sys/ioctl.h>
# if defined(_KERNEL) || defined(KERNEL)
#  include <sys/systm.h>
# else
#  include <string.h>
# endif
# include <sys/uio.h>
# if !defined(__SVR4) && !defined(__svr4__)
#  include <sys/dir.h>
#  include <sys/mbuf.h>
# else
#  include <sys/byteorder.h>
#  include <sys/dditypes.h>
#  include <sys/stream.h>
# endif
# include <sys/protosw.h>
# include <sys/socket.h>
# include <net/if.h>
# ifdef sun
#  include <net/af.h>
# endif
# include <net/route.h>
# include <netinet/in.h>
# include <netinet/in_systm.h>
# include <netinet/ip.h>
# include <netinet/ip_var.h>
# include <netinet/tcp.h>
# include <netinet/udp.h>
# include <netinet/tcpip.h>
# include <netinet/ip_icmp.h>
d23 24
d64 4
a67 1
#define	FR_SCANLIST(p, ip, if, fi, m)	fr_scanlist(p, ip, ifp, fi)
d77 1
a77 1
# define	FR_SCANLIST(p, ip, if, fi, m)	fr_scanlist(p, ip, ifp, fi)
d79 1
a79 1
# define	FR_SCANLIST(p, ip, if, fi, m)	fr_scanlist(p, ip, ifp, fi, m)
d85 1
a85 1
# define	IPLLOG(fl, ip, if, fi, m)	ipllog(fl, ip, if, fi)
d90 1
a90 5
#ifdef _KERNEL
# define	IPLLOG(fl, ip, if, fi, m)	ipllog(fl, ip, if, fi, m)
#else
# define        IPLLOG(fl, ip, if, fi, m)       ipllog()
#endif
d106 1
d108 1
d154 1
a154 1
struct fr_ip *fr_makefrip(hlen, ip)
d157 1
a158 1
	static struct fr_ip fi;
d160 2
d166 7
d174 1
a174 1
	fi.fi_icode = ipl_unreach;
d176 7
a182 7
	fi.fi_fl = 0;
	fi.fi_v = ip->ip_v;
	fi.fi_tos = ip->ip_tos;
	fi.fi_hlen = hlen;
	(*(((u_short *)&fi) + 1)) = (*(((u_short *)ip) + 4));
	(*(((u_long *)&fi) + 1)) = (*(((u_long *)ip) + 3));
	(*(((u_long *)&fi) + 2)) = (*(((u_long *)ip) + 4));
d185 1
a185 6
		fi.fi_fl |= FI_OPTIONS;
#if	SOLARIS
	off = (ntohs(ip->ip_off) & 0x1fff) << 3;
	if (ntohs(ip->ip_off) & 0x3fff)
		fi.fi_fl |= FI_FRAG;
#else
d188 1
a188 2
		fi.fi_fl |= FI_FRAG;
#endif
d194 3
a196 1
			fi.fi_fl |= FI_SHORT;
d199 1
a199 1
		fi.fi_fl |= FI_TCPUDP;
d202 3
a204 1
			fi.fi_fl |= FI_SHORT;
d207 1
a207 1
		fi.fi_fl |= FI_TCPUDP;
d210 1
a210 1
			fi.fi_fl |= FI_SHORT;
d216 5
d225 1
a225 1
		if (opt > 1 && (ol < 0 || ol > hlen))
d236 1
a236 1
					sec = *(s + 3);	/* classification */
d264 4
a267 4
	fi.fi_optmsk = optmsk;
	fi.fi_secmsk = secmsk;
	fi.fi_auth = auth;
	return &fi;
d274 3
a276 4
int fr_tcpudpchk(ip, tcp, fr)
ip_t *ip;
tcphdr_t *tcp;
struct frentry *fr;
d280 1
a280 1
	int err = 1;
d289 2
a290 2
		po = ntohs(fr->fr_dport);
		tup = ntohs(tcp->th_dport);
d308 1
a308 1
			 (tup >= po && tup <= ntohs(fr->fr_dtop)))
d311 1
a311 1
			 (tup <= po || tup >= ntohs(fr->fr_dtop)))
d318 2
a319 2
		po = ntohs(fr->fr_sport);
		tup = ntohs(tcp->th_sport);
d333 1
a333 1
			 (tup >= po && tup <= ntohs(fr->fr_stop)))
d336 1
a336 1
			 (tup <= po || tup >= ntohs(fr->fr_stop)))
d346 11
a356 14
	if (err)
		if (ip->ip_p == IPPROTO_TCP) {
			if (!IPMINLEN(ip, tcphdr))
				return !(fr->fr_tcpf);
			/*
			 * Match the flags ?  If not, abort this match.
			 */
			if (fr->fr_tcpf &&
			    fr->fr_tcpf != (tcp->th_flags & fr->fr_tcpfm)) {
				FR_DEBUG(("f. %#x & %#x != %#x\n",
					 tcp->th_flags, fr->fr_tcpfm,
					 fr->fr_tcpf));
				err = 0;
			}
d358 1
a358 2
		else if (!IPMINLEN(ip, udphdr))	/* must be UDP */
			return 1;
d367 1
a367 1
int fr_scanlist(pass, ip, ifp, fi, m)
d370 1
a370 2
struct ifnet *ifp;
register struct fr_ip *fi;
d374 2
a375 2
	tcphdr_t *tcp;
	int	rulen;
d377 2
a378 2
	fi->fi_rule = 0;
	tcp = (tcphdr_t *)((char *)ip + fi->fi_hlen);
d381 4
a384 1
	for (rulen = 0, fr = fi->fi_fr; fr; fr = fr->fr_next, rulen++) {
d392 1
a392 1
		if (fr->fr_ifa && fr->fr_ifa != ifp)
d398 2
a399 2
		if (ifp && *fr->fr_ifname && strcasecmp((char *)ifp,
							fr->fr_ifname))
d433 5
a437 3
		if (!(ntohs(ip->ip_off) & 0x1fff)) {
			if ((fi->fi_fl & FI_TCPUDP) &&
			    !fr_tcpudpchk(ip, tcp, fr))
d439 10
a448 6
			else if (ip->ip_p == IPPROTO_ICMP &&
				   (*(u_short *)((char *)ip + fi->fi_hlen) &
				     fr->fr_icmpm) != fr->fr_icmp) {
				FR_DEBUG(("i. %#x & %#x != %#x\n",
					 *(u_short *)((char *)ip + fi->fi_hlen),
					 fr->fr_icmpm, fr->fr_icmp));
d450 1
a450 4
			}
		} else if (fr->fr_dcmp || fr->fr_scmp || fr->fr_icmpm ||
			   fr->fr_tcpfm)
			continue;
d452 10
a461 8
		/*
		 * Just log this packet...
		 */
		if (fr->fr_flags & FR_LOG) {
#ifdef	IPFILTER_LOG
			if (!IPLLOG(fr->fr_flags, ip, ifp, fi, m))
				frstats[fi->fi_out].fr_skip++;
			frstats[fi->fi_out].fr_pkl++;
a462 2
		} else
			pass = fr->fr_flags;
d465 2
a466 2
		fi->fi_rule = rulen;
		fi->fi_icode = fr->fr_icode;
d469 2
a470 4
		else {
			fi->fi_rule = rulen;
			fi->fi_icode = fr->fr_icode;
		}
d504 2
a505 1
	register struct fr_ip *fi;
d511 1
a511 1
	if (!out && (ip->ip_p == IPPROTO_TCP || ip->ip_p == IPPROTO_UDP ||
d515 1
a515 1
		if ((up > m->m_len)) {
d525 3
a527 2
	fi = fr_makefrip(hlen, ip);
	fi->fi_out = out;
d531 3
a533 3
		ip_natin(ifp, ip, hlen);
		if ((fi->fi_fr = ipacct[0][fr_active]) &&
		    (FR_SCANLIST(FR_NOMATCH, ip, ifp, fi, m) & FR_ACCOUNT))
d537 30
a566 7
	if (!(pass = ipfr_knownfrag(ip)) &&
	    !(pass = fr_checkstate(ip, hlen))) {
		pass = FR_NOMATCH;
		if ((fi->fi_fr = ipfilter[out][fr_active]))
			pass = FR_SCANLIST(FR_NOMATCH, ip, ifp, fi, m);
		if (pass & FR_NOMATCH) {
			frstats[out].fr_nom++;
d568 1
a568 1
			pass |= NOMATCH;
d570 1
d572 9
a580 5
		if (pass & FR_KEEPFRAG) {
			if (ipfr_newfrag(ip, pass) == -1)
				frstats[out].fr_bnfr++;
			else
				frstats[out].fr_nfr++;
d588 1
a588 3
	} else if (pass & FR_LOGFIRST)
		pass &= ~(FR_LOGFIRST|FR_LOG);

d591 2
a592 2
		if ((fi->fi_fr = ipacct[1][fr_active]) &&
		    (FR_SCANLIST(FR_NOMATCH, ip, ifp, fi, m) & FR_ACCOUNT))
d594 1
a594 1
		ip_natout(ifp, ip, hlen);
d601 1
a601 1
		if (!IPLLOG(pass, ip, ifp, fi, m))
d608 1
a608 1
		if (!IPLLOG(pass, ip, ifp, fi, m))
d615 1
a615 1
		if (!IPLLOG(pass, ip, ifp, fi, m))
d632 1
a632 1
			ICMP_ERROR(q, ip, ICMP_UNREACH, fi->fi_icode,
d635 1
a635 1
			ICMP_ERROR(m, ip, ICMP_UNREACH, fi->fi_icode,
d641 2
a642 1
		} else if (pass & FR_RETRST && IPMINLEN(ip, tcphdr)) {
d673 1
a673 1
int ipllog()
@


1.1
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d9 1
a9 1
static	char	sccsid[] = "@@(#)fil.c	1.18 10/24/95 (C) 1993-1995 Darren Reed";
d20 2
d48 4
a51 1
#include <netinet/ip_fil.h>
d65 1
d71 10
d82 19
a100 1
extern	int	ipl_unreach, ipllog();
d104 2
a105 2
struct	frentry	*filterin[2] = { NULL, NULL },
		*filterout[2] = { NULL, NULL };
a106 1
int	fr_check();
d164 3
d170 1
d177 5
d185 1
d360 1
a360 1
int fr_scanlist(pass, ip, hlen, ifp, out, rule)
a362 1
int hlen, out;
d364 2
a365 1
u_short *rule;
a367 1
	register struct fr_ip *fi;
d371 3
a373 4
	*rule = 1;
	tcp = (tcphdr_t *)((char *)ip + hlen);
	fr = (out) ? filterout[fr_active] : filterin[fr_active];
	fi = fr_makefrip(hlen, ip);
d375 1
a375 1
	for (rulen = 0; fr; fr = fr->fr_next, rulen++) {
d389 1
a389 1
		if (ifp && *fr->fr_ifname && strcasecmp(ifp->if_name,
d424 1
a424 1
		if (!(ip->ip_off & 0x1fff)) {
d429 1
a429 1
				   (*(u_short *)((char *)ip + hlen) &
d432 1
a432 1
					 *(u_short *)((char *)ip + hlen),
d445 3
a447 3
			if (!ipllog(hlen, fr->fr_flags, ip, ifp, *rule))
				frstats[out].fr_skip++;
			frstats[out].fr_pkl++;
d453 8
a460 1
		*rule = rulen;
d474 2
a475 1
#if SOLARIS && defined(_KERNEL)
d479 4
d491 41
a531 9
	int pass = FR_NOMATCH;
	int sl;
	u_short rule;

	SPLNET(sl);

	pass = fr_scanlist(pass, ip, hlen, ifp, out, &rule);
	if (pass == FR_NOMATCH) {
		frstats[out].fr_nom++;
d533 1
a533 1
		pass |= NOMATCH;
d535 22
d558 1
d561 6
a566 1
	if ((pass & FR_LOGP) ||
d568 3
a570 3
		if (!(pass & FR_LOGP))
			pass |= FF_LOGPASS << 8;
		if (!ipllog(hlen, pass, ip, ifp, rule))
d573 1
a573 1
	} else if ((pass & FR_LOGB) ||
d575 3
a577 3
		if (!(pass & FR_LOGB))
			pass |= FF_LOGBLOCK << 8;
		if (!ipllog(hlen, pass, ip, ifp, rule))
d582 1
a582 1
	SPLX(sl);
a589 2
		 * XXX - copy mbuf as icmp_error() calls mfree() - fix this
		 * later, but preserve backward compatibility for now.
d594 2
a595 2
			icmp_error(q, ip, ICMP_UNREACH, ipl_unreach, qif,
				   ip->ip_src);
d597 4
a600 1
			struct mbuf *copy;
a601 9
			copy = m_copy(dtom(ip), 0, imin((int)ip->ip_len, 64));
#  if BSD < 199103
			icmp_error(mtod(copy, struct ip *),
				   ICMP_UNREACH, ipl_unreach, ifp, ip->ip_src);
#  else
			icmp_error(copy, ICMP_UNREACH, ipl_unreach,
				   ip->ip_src.s_addr, ifp);
#  endif
# endif
d604 1
a604 5
# if SOLARIS
			if (send_reset(ip, qif, q) == 0)
# else
			if (send_reset(ip) == 0)
# endif
d618 4
a636 1
	return 1;
@
