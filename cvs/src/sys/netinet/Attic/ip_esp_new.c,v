head	1.57;
access;
symbols
	SMP_SYNC_A:1.57
	SMP_SYNC_B:1.57
	UBC_SYNC_A:1.57
	UBC_SYNC_B:1.57
	SMP:1.57.0.2
	kame_19991208:1.54
	OPENBSD_2_6:1.46.0.2
	OPENBSD_2_6_BASE:1.46
	OPENBSD_2_5:1.40.0.2
	OPENBSD_2_5_BASE:1.40
	OPENBSD_2_4:1.24.0.2
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9;
locks; strict;
comment	@ * @;


1.57
date	2000.01.27.08.09.10;	author angelos;	state dead;
branches;
next	1.56;

1.56
date	99.12.26.20.46.13;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	99.12.09.20.22.03;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	99.12.08.02.26.18;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	99.12.07.07.37.40;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	99.12.06.23.09.11;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	99.12.06.22.33.29;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	99.12.06.08.55.03;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	99.12.06.07.14.35;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	99.12.04.23.20.21;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	99.10.29.02.10.01;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	99.10.06.22.27.57;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	99.06.30.17.23.59;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	99.06.18.07.24.03;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	99.05.16.21.48.35;	author niklas;	state Exp;
branches;
next	1.42;

1.42
date	99.05.12.22.58.47;	author ho;	state Exp;
branches;
next	1.41;

1.41
date	99.05.12.21.11.42;	author ho;	state Exp;
branches;
next	1.40;

1.40
date	99.03.24.17.00.45;	author niklas;	state Exp;
branches;
next	1.39;

1.39
date	99.02.25.20.23.02;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	99.02.25.20.14.40;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	99.02.25.18.43.42;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	99.02.24.23.45.49;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	99.02.24.23.07.19;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	99.02.24.22.33.02;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	99.02.17.20.39.17;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	99.02.16.23.58.00;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	99.02.12.00.46.10;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	99.01.11.22.52.09;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	99.01.11.05.12.30;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	99.01.08.21.40.26;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.11.25.09.56.51;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	98.11.25.02.01.27;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	98.11.25.01.02.59;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	98.08.01.08.35.12;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	98.07.30.08.41.20;	author provos;	state Exp;
branches;
next	1.22;

1.22
date	98.06.11.14.17.22;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	98.06.03.09.50.21;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	98.05.24.22.56.29;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	98.05.18.21.10.43;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	98.05.05.08.54.48;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	98.03.07.21.30.24;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	98.02.22.01.23.32;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	98.01.21.18.43.33;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.11.24.19.14.14;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.11.18.09.09.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.11.18.00.12.15;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.11.15.00.07.08;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.11.04.09.11.11;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.10.02.02.31.04;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.09.30.03.18.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.29.22.09.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.09.28.22.57.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.09.24.18.39.40;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	97.09.24.00.05.34;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	97.09.23.21.42.21;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.08.26.12.02.49;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	97.07.11.23.37.57;	author provos;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@/*	$OpenBSD: ip_esp_new.c,v 1.56 1999/12/26 20:46:13 angelos Exp $	*/

/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * RFC 2406.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <machine/cpu.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>

#include <sys/socketvar.h>
#include <net/raw_cb.h>

#ifdef INET6
#include <netinet6/in6.h>
#endif /* INET6 */

#include <netinet/ip_ipsp.h>
#include <netinet/ip_esp.h>
#include <net/pfkeyv2.h>

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
#endif

extern struct auth_hash auth_hash_hmac_md5_96;
extern struct auth_hash auth_hash_hmac_sha1_96;
extern struct auth_hash auth_hash_hmac_ripemd_160_96;

struct auth_hash *esp_new_hash[] = {
    &auth_hash_hmac_md5_96,
    &auth_hash_hmac_sha1_96,
    &auth_hash_hmac_ripemd_160_96
};

extern struct enc_xform enc_xform_des;
extern struct enc_xform enc_xform_3des;
extern struct enc_xform enc_xform_blf;
extern struct enc_xform enc_xform_cast5;
extern struct enc_xform enc_xform_skipjack;

struct enc_xform *esp_new_xform[] = {
    &enc_xform_des,
    &enc_xform_3des,
    &enc_xform_blf,
    &enc_xform_cast5,
    &enc_xform_skipjack,
};

/*
 * esp_new_attach() is called from the transformation initialization code.
 */

int
esp_new_attach()
{
    return 0;
}

/*
 * esp_new_init() is called when an SPI is being set up.
 */

int
esp_new_init(struct tdb *tdbp, struct xformsw *xsp, struct ipsecinit *ii)
{
    struct enc_xform *txform = NULL;
    struct auth_hash *thash = NULL;
    int i;

    /* Check whether the encryption algorithm is supported */
    for (i = sizeof(esp_new_xform) / sizeof(esp_new_xform[0]) - 1;
	 i >= 0; i--) 
      if (ii->ii_encalg == esp_new_xform[i]->type)
	break;

    if (i < 0) 
    {
	DPRINTF(("esp_new_init(): unsupported encryption algorithm %d specified\n", ii->ii_encalg));
        return EINVAL;
    }

    txform = esp_new_xform[i];

    if (ii->ii_enckeylen < txform->minkey)
    {
	DPRINTF(("esp_new_init(): keylength %d too small (min length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->minkey, txform->name));
	return EINVAL;
    }
    
    if (ii->ii_enckeylen > txform->maxkey)
    {
	DPRINTF(("esp_new_init(): keylength %d too large (max length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->maxkey, txform->name));
	return EINVAL;
    }

    if (ii->ii_authalg)
    {
	for (i = sizeof(esp_new_hash) / sizeof(esp_new_hash[0]) - 1;
	     i >= 0; i--) 
	  if (ii->ii_authalg == esp_new_hash[i]->type)
	    break;

	if (i < 0) 
	{
	    DPRINTF(("esp_new_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
	    return EINVAL;
	}

	thash = esp_new_hash[i];

	if (ii->ii_authkeylen != thash->keysize)
	{
	    DPRINTF(("esp_new_init(): keylength %d doesn't match algorithm %s keysize (%d)\n", ii->ii_authkeylen, thash->name, thash->keysize));
	    return EINVAL;
	}
    
    	tdbp->tdb_authalgxform = thash;

	DPRINTF(("esp_new_init(): initialized TDB with hash algorithm %s\n",
		 thash->name));
    }
    
    tdbp->tdb_xform = xsp;
    tdbp->tdb_encalgxform = txform;
    tdbp->tdb_bitmap = 0;
    tdbp->tdb_rpl = AH_HMAC_INITIAL_RPL;

    DPRINTF(("esp_new_init(): initialized TDB with enc algorithm %s\n",
	     txform->name));

    tdbp->tdb_ivlen = txform->ivmask;

    /* Initialize the IV */
    get_random_bytes(tdbp->tdb_iv, tdbp->tdb_ivlen);

    if (txform->setkey)
	txform->setkey(&tdbp->tdb_key, ii->ii_enckey, ii->ii_enckeylen);

    if (thash)
    {
	/* Precompute the I and O pads of the HMAC */
	for (i = 0; i < ii->ii_authkeylen; i++)
	  ii->ii_authkey[i] ^= HMAC_IPAD_VAL;

	MALLOC(tdbp->tdb_ictx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
	bzero(tdbp->tdb_ictx, thash->ctxsize);
	thash->Init(tdbp->tdb_ictx);
	thash->Update(tdbp->tdb_ictx, ii->ii_authkey, ii->ii_authkeylen);
	thash->Update(tdbp->tdb_ictx, hmac_ipad_buffer,
		      HMAC_BLOCK_LEN - ii->ii_authkeylen);
	 
	for (i = 0; i < ii->ii_authkeylen; i++)
	  ii->ii_authkey[i] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);

	MALLOC(tdbp->tdb_octx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
	bzero(tdbp->tdb_octx, thash->ctxsize);
	thash->Init(tdbp->tdb_octx);
	thash->Update(tdbp->tdb_octx, ii->ii_authkey, ii->ii_authkeylen);
	thash->Update(tdbp->tdb_octx, hmac_opad_buffer,
		      HMAC_BLOCK_LEN - ii->ii_authkeylen);
    }

    return 0;
}

int
esp_new_zeroize(struct tdb *tdbp)
{
    if (tdbp->tdb_key && tdbp->tdb_encalgxform &&
        tdbp->tdb_encalgxform->zerokey)
      tdbp->tdb_encalgxform->zerokey(&tdbp->tdb_key);

    if (tdbp->tdb_ictx)
    {
	if (tdbp->tdb_authalgxform)
	  bzero(tdbp->tdb_ictx, tdbp->tdb_authalgxform->ctxsize);
	FREE(tdbp->tdb_ictx, M_XDATA);
	tdbp->tdb_ictx = NULL;
    }

    if (tdbp->tdb_octx)
    {
	if (tdbp->tdb_authalgxform)
	  bzero(tdbp->tdb_octx, tdbp->tdb_authalgxform->ctxsize);
	FREE(tdbp->tdb_octx, M_XDATA);
	tdbp->tdb_octx = NULL;
    }

    return 0;
}

#define MAXBUFSIZ (AH_ALEN_MAX > ESP_MAX_IVS ? AH_ALEN_MAX : ESP_MAX_IVS)

struct mbuf *
esp_new_input(struct mbuf *m, struct tdb *tdb, int skip, int protoff)
{
    struct auth_hash *esph = (struct auth_hash *) tdb->tdb_authalgxform;
    struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
    int ohlen, oplen, plen, alen, ilen, i, blks, rest, count, off, roff;
    u_char iv[MAXBUFSIZ], niv[MAXBUFSIZ], blk[ESP_MAX_BLKS], *lblk;
    u_char *idat, *odat, *ivp, *ivn;
    struct mbuf *mi, *mo, *m1;
    union authctx ctx;
    u_int32_t btsx;

    ohlen = skip + ESP_NEW_FLENGTH;
    blks = espx->blocksize;

    if (esph)
      alen = AH_HMAC_HASHLEN;
    else
      alen = 0;

    /* Skip the IP header, IP options, SPI, Replay, IV, and any Auth Data */
    plen = m->m_pkthdr.len - (skip + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen +
	   alen);
    if ((plen & (blks - 1)) || (plen <= 0))
    {
	DPRINTF(("esp_new_input(): payload not a multiple of %d octets, SA %s/%08x\n", blks, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_badilen++;
	m_freem(m);
	return NULL;
    }

    /* Auth covers SPI + SN + IV */
    oplen = plen + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; 

    /* Replay window checking */
    if (tdb->tdb_wnd > 0)
    {
	m_copydata(m, skip + offsetof(struct esp_new, esp_rpl),
		   sizeof(u_int32_t), (unsigned char *) &btsx);
	btsx = ntohl(btsx);

	switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl), tdb->tdb_wnd,
				    &(tdb->tdb_bitmap)))
	{
	    case 0: /* All's well */
		break;

	    case 1:
		DPRINTF(("esp_new_input(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		espstat.esps_wrap++;
		m_freem(m);
		return NULL;

	    case 2:
	    case 3:
		DPRINTF(("esp_new_input(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		espstat.esps_replay++;
		m_freem(m);
		return NULL;

	    default:
		DPRINTF(("esp_new_input(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		espstat.esps_replay++;
		m_freem(m);
		return NULL;
	}
    }

    /* Update the counters */
    tdb->tdb_cur_bytes += m->m_pkthdr.len - ohlen - alen;
    espstat.esps_ibytes += m->m_pkthdr.len - ohlen - alen;

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	m_freem(m);
	return NULL;
    }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;       /* Turn off checking */
    }

    /* 
     * Skip forward to the beginning of the ESP header. If we run out
     * of mbufs in the process, the check inside the following while()
     * loop will catch it.
     */
    for (mo = m, i = 0; mo && i + mo->m_len <= skip; mo = mo->m_next)
      i += mo->m_len;

    off = skip - i;

    /* Preserve these for later processing */
    roff = off;
    m1 = mo;

    /* Verify the authenticator */
    if (esph)
    {
	bcopy(tdb->tdb_ictx, &ctx, esph->ctxsize);

	/* Copy the authentication data */
	m_copydata(m, m->m_pkthdr.len - alen, alen, iv);

	while (oplen > 0)
	{
	    if (mo == NULL)
	    {
		DPRINTF(("esp_new_input(): bad mbuf chain, SA %s/%08x\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		espstat.esps_hdrops++;
		m_freem(m);
		return NULL;
	    }

	    count = min(mo->m_len - off, oplen);
	    esph->Update(&ctx, mtod(mo, unsigned char *) + off, count);
	    oplen -= count;
	    off = 0;
	    mo = mo->m_next;
	}

	esph->Final(niv, &ctx);
	bcopy(tdb->tdb_octx, &ctx, esph->ctxsize);
	esph->Update(&ctx, niv, esph->hashsize);
	esph->Final(niv, &ctx);

	if (bcmp(niv, iv, AH_HMAC_HASHLEN))
	{
	    DPRINTF(("esp_new_input(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_badauth++;
	    m_freem(m);
	    return NULL;
	}
    }

    oplen = plen;

    /* Find beginning of encrypted data (actually, the IV) */
    mi = m1;
    ilen = mi->m_len - roff - 2 * sizeof(u_int32_t);
    while (ilen <= 0)
    {
	mi = mi->m_next;
	if (mi == NULL)
	{
	    DPRINTF(("esp_new_input(): bad mbuf chain, SA %s/%08x\n",
		     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_hdrops++;
	    m_freem(m);
	    return NULL;
	}

	ilen += mi->m_len;
    }

    idat = mtod(mi, unsigned char *) + (mi->m_len - ilen);
    m_copydata(mi, mi->m_len - ilen, tdb->tdb_ivlen, iv);

    /* Now skip over the IV */
    ilen -= tdb->tdb_ivlen;
    while (ilen <= 0)
    {
	mi = mi->m_next;
	if (mi == NULL)
	{
	    DPRINTF(("esp_new_input(): bad mbuf chain, SA %s/%08x\n",
		     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_hdrops++;
	    m_freem(m);
	    return NULL;
	}

	ilen += mi->m_len;
    }

    /*
     * Remove the ESP header and IV from the mbuf.
     */
    if (roff == 0) 
    {
	/* The ESP header was conveniently at the beginning of the mbuf */
	m_adj(m1, 2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
	if (!(m1->m_flags & M_PKTHDR))
	  m->m_pkthdr.len -= (2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
    }
    else
      if (roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen >= m1->m_len)
      {
	  /*
	   * Part or all of the ESP header is at the end of this mbuf, so first
	   * let's remove the remainder of the ESP header from the
	   * beginning of the remainder of the mbuf chain, if any.
	   */
	  if (roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen > m1->m_len)
	  {
	      /* Adjust the next mbuf by the remainder */
	      m_adj(m1->m_next, roff + 2 * sizeof(u_int32_t) +
		    tdb->tdb_ivlen - m1->m_len);

	      /* The second mbuf is guaranteed not to have a pkthdr... */
	      m->m_pkthdr.len -= (roff + 2 * sizeof(u_int32_t) +
				  tdb->tdb_ivlen - m1->m_len);
	  }

	  /* Now, let's unlink the mbuf chain for a second...*/
	  mo = m1->m_next;
	  m1->m_next = NULL;

	  /* ...and trim the end of the first part of the chain...sick */
	  m_adj(m1, -(m1->m_len - roff));
	  if (!(m1->m_flags & M_PKTHDR))
	    m->m_pkthdr.len -= (m1->m_len - roff);

	  /* Finally, let's relink */
	  m1->m_next = mo;
      }
      else
      {
	  /* 
	   * The ESP header lies in the "middle" of the mbuf...do an
	   * overlapping copy of the remainder of the mbuf over the ESP
	   * header.
	   */
	  bcopy(mtod(m1, u_char *) + roff + 2 * sizeof(u_int32_t) +
		tdb->tdb_ivlen,
		mtod(m1, u_char *) + roff,
		m1->m_len - (roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen));
	  m1->m_len -= (2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
	  m->m_pkthdr.len -= (2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
      }

    /* Point to the encrypted data */
    idat = mtod(mi, unsigned char *) + (mi->m_len - ilen);

    /*
     * At this point:
     *   plen is # of encapsulated payload octets
     *   ilen is # of octets left in this mbuf
     *   idat is first encapsulated payload octed in this mbuf
     *   same for olen and odat
     *   ivp points to the IV, ivn buffers the next IV.
     *   mi points to the first mbuf
     *
     * From now on until the end of the mbuf chain:
     *   . move the next eight octets of the chain into ivn
     *   . decrypt idat and xor with ivp
     *   . swap ivp and ivn.
     *   . repeat
     */

    ivp = iv;
    ivn = niv;
    rest = ilen % blks;
    while (plen > 0)		/* while not done */
    {
	if (ilen < blks) 
	{
	    if (rest)
	    {
		bcopy(idat, blk, rest);
		odat = idat;
	    }

	    do {
		mi = (mo = mi)->m_next;
		if (mi == NULL)
		{
		    DPRINTF(("esp_new_input(): bad mbuf chain, SA %s/%08x\n",
			     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    espstat.esps_hdrops++;
		    m_freem(m);
		    return NULL;
		}
	    } while (mi->m_len == 0);

	    if (mi->m_len < blks - rest)
	    {
		if ((mi = m_pullup(mi, blks - rest)) == NULL) 
		{
		    DPRINTF(("esp_new_input(): m_pullup() failed, SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    m_freem(m);
		    espstat.esps_hdrops++;
		    return NULL;
		}
		/* 
		 * m_pullup was not called at the beginning of the chain
		 * but might return a new mbuf, link it into the chain.
		 */
		mo->m_next = mi;
	    }
		    
	    ilen = mi->m_len;
	    idat = mtod(mi, u_char *);

	    if (rest)
	    {
		bcopy(idat, blk + rest, blks - rest);
		bcopy(blk, ivn, blks);
		    
		espx->decrypt(tdb, blk);

		for (i = 0; i < blks; i++)
		    blk[i] ^= ivp[i];

		ivp = ivn;
		ivn = (ivp == iv) ? niv : iv;

		bcopy(blk, odat, rest);
		bcopy(blk + rest, idat, blks - rest);

		lblk = blk;   /* last block touched */
		
		idat += blks - rest;
		ilen -= blks - rest;
		plen -= blks;
	    }

	    rest = ilen % blks;
	}

	while (ilen >= blks && plen > 0)
	{
	    bcopy(idat, ivn, blks);

	    espx->decrypt(tdb, idat);

	    for (i = 0; i < blks; i++)
		idat[i] ^= ivp[i];

	    ivp = ivn;
	    ivn = (ivp == iv) ? niv : iv;

	    lblk = idat;   /* last block touched */
	    idat += blks;

	    ilen -= blks;
	    plen -= blks;
	}
    }

    /* Save last block (end of padding), if it was in-place decrypted */
    if (lblk != blk)
      bcopy(lblk, blk, blks);

    /*
     * Now, the entire chain has been decrypted. As a side effect,
     * blk[blks - 1] contains the next protocol, and blk[blks - 2] contains
     * the amount of padding the original chain had. Chop off the
     * appropriate parts of the chain, and return.
     * Verify correct decryption by checking the last padding bytes.
     */

    if (blk[blks - 2] + 2 + alen > m->m_pkthdr.len - skip -
	2 * sizeof(u_int32_t) - tdb->tdb_ivlen)
    {
	DPRINTF(("esp_new_input(): invalid padding length %d for packet in SA %s/%08x\n", blk[blks - 2], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_badilen++;
	m_freem(m);
	return NULL;
    }

    if ((blk[blks - 2] != blk[blks - 3]) && (blk[blks - 2] != 0))
    {
	DPRINTF(("esp_new_input(): decryption failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_badenc++;
	m_freem(m);
	return NULL;
    } 

    /* Trim the mbuf chain to remove the trailing authenticator */
    m_adj(m, - blk[blks - 2] - 2 - alen);

    /* Restore the Next Protocol field */
    m_copyback(m, protoff, 1, &blk[blks - 1]);

    return m;
}

int
esp_new_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
	       int protoff)
{
    struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
    struct auth_hash *esph = (struct auth_hash *) tdb->tdb_authalgxform;
    u_char iv[ESP_MAX_IVS], blk[ESP_MAX_BLKS], auth[AH_ALEN_MAX];
    int i, ilen, ohlen, rlen, plen, padding, rest, blks, alen;
    struct mbuf *mi, *mo = (struct mbuf *) NULL;
    u_char *pad, *idat, *odat, *ivp;
    struct esp_new *esp;
    union authctx ctx;

    blks = espx->blocksize;
    ohlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen;
    rlen = m->m_pkthdr.len - skip; /* Raw payload length */
    padding = ((blks - ((rlen + 2) % blks)) % blks) + 2;
    plen = rlen + padding; /* Padded payload length */

    if (esph)
      alen = AH_HMAC_HASHLEN;
    else
      alen = 0;

    espstat.esps_output++;

    /* Check for replay counter wrap-around in automatic (not manual) keying */
    if ((tdb->tdb_rpl == 0) && (tdb->tdb_wnd > 0))
    {
	DPRINTF(("esp_new_output(): SA %s/%0x8 should have expired\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	espstat.esps_wrap++;
	return ENOBUFS;
    }

#ifdef INET
    /* In IPv4, check for max packet size violations. Not needed in IPv6. */
    if (tdb->tdb_dst.sa.sa_family == AF_INET)
      if (skip + ohlen + rlen + padding + alen > IP_MAXPACKET)
      {
	  DPRINTF(("esp_new_output(): packet in SA %s/%0x8 got too big\n",
		   ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	  m_freem(m);
	  espstat.esps_toobig++;
	  return EMSGSIZE;
      }
#endif /* INET */

    /* Update the counters */
    tdb->tdb_cur_bytes += m->m_pkthdr.len - skip;
    espstat.esps_obytes += m->m_pkthdr.len - skip;

    /* Hard byte expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	m_freem(m);
	return EINVAL;
    }

    /* Soft byte expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;     /* Turn off checking */
    }

    /*
     * Loop through mbuf chain; if we find an M_EXT mbuf with 
     * more than one reference, replace the rest of the chain. 
     */
    mi = m;
    while (mi != NULL && 
	   (!(mi->m_flags & M_EXT) || 
	    (mi->m_ext.ext_ref == NULL &&
	     mclrefcnt[mtocl(mi->m_ext.ext_buf)] <= 1)))
    {
        mo = mi;
        mi = mi->m_next;
    }
     
    if (mi != NULL)
    {
        /* Replace the rest of the mbuf chain. */
        struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);
      
        if (n == NULL)
        {
	    espstat.esps_hdrops++;
	    m_freem(m);
	    return ENOBUFS;
        }

        if (mo != NULL)
	  mo->m_next = n;
        else
	  m = n;

        m_freem(mi);
    }

    /* Inject ESP header */
    mo = m_inject(m, skip, ohlen, M_WAITOK);
    if (mo == NULL)
    {
	DPRINTF(("esp_new_output(): failed to inject ESP header for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	espstat.esps_wrap++;
	return ENOBUFS;
    }

    /* Initialize ESP header */
    esp = mtod(mo, struct esp_new *);
    esp->esp_spi = tdb->tdb_spi;
    esp->esp_rpl = htonl(tdb->tdb_rpl++);

    /*
     * We can cheat and use bcopy() instead of m_copyback() for the
     * second copy below, because m_inject() is guaranteed to fit the
     * ESP header in one mbuf.
     */
    bcopy(tdb->tdb_iv, iv, tdb->tdb_ivlen);
    bcopy(iv, esp->esp_iv, tdb->tdb_ivlen);

    /* Add padding */
    pad = (u_char *) m_pad(m, padding + alen, 0);
    if (pad == NULL)
    {
        DPRINTF(("esp_new_output(): m_pad() failed for SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
      	return ENOBUFS;
    }

    /* Self-describing padding */
    for (ilen = 0; ilen < padding - 2; ilen++)
      pad[ilen] = ilen + 1;

    /* Fix padding length and Next Protocol in padding itself */
    pad[padding - 2] = padding - 2;
    m_copydata(m, protoff, 1, &pad[padding - 1]);

    /* Fix Next Protocol in IPv4/IPv6 header */
    ilen = IPPROTO_ESP;
    m_copyback(m, protoff, 1, (u_char *) &ilen);

    mi = mo;

    /* If it's just the ESP header, just skip to the next mbuf */
    if (mi->m_len == ohlen)
    {
	mi = mi->m_next;
	ilen = mi->m_len;
	idat = mtod(mi, u_char *);
    }
    else
    {  /* There's data at the end of this mbuf, skip over ESP header */
	ilen = mi->m_len - ohlen;
	idat = mtod(mi, u_char *) + ohlen;
    }

    /* Authenticate the ESP header */
    if (esph)
    {
	bcopy(tdb->tdb_ictx, &ctx, esph->ctxsize);
	esph->Update(&ctx, (unsigned char *) esp, 
		     2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
    }

    /* Encrypt the payload */
    ivp = iv;
    rest = ilen % blks;
    while (plen > 0)		/* while not done */
    {
	if (ilen < blks) 
	{
	    if (rest)
	    {
	        if (ivp == blk)
		{
		    bcopy(blk, iv, blks);
		    ivp = iv;
		}

		bcopy(idat, blk, rest);
		odat = idat;
	    }

	    do {
		mi = (mo = mi)->m_next;
		if (mi == NULL)
		{
		    DPRINTF(("esp_new_output(): bad mbuf chain, SA %s/%08x\n",
			     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    espstat.esps_hdrops++;
		    m_freem(m);
		    return EINVAL;
		}
	    } while (mi->m_len == 0);

	    if (mi->m_len < blks - rest)
	    {
		if ((mi = m_pullup(mi, blks - rest)) == NULL)
		{
		    DPRINTF(("esp_new_output(): m_pullup() failed, SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    m_freem(m);
		    espstat.esps_hdrops++;
		    return ENOBUFS;
		}
		/* 
		 * m_pullup was not called at the beginning of the chain
		 * but might return a new mbuf, link it into the chain.
		 */
		mo->m_next = mi;
	    }
		    
	    ilen = mi->m_len;
	    idat = mtod(mi, u_char *);

	    if (rest)
	    {
		bcopy(idat, blk + rest, blks - rest);
		    
		for (i = 0; i < blks; i++)
		  blk[i] ^= ivp[i];

		espx->encrypt(tdb, blk);

		if (esph)
		  esph->Update(&ctx, blk, blks);

		ivp = blk;

		bcopy(blk, odat, rest);
		bcopy(blk + rest, idat, blks - rest);
		
		idat += blks - rest;
		ilen -= blks - rest;
		plen -= blks;
	    }

	    rest = ilen % blks;
	}

	while (ilen >= blks && plen > 0)
	{
	    for (i = 0; i < blks; i++)
	      idat[i] ^= ivp[i];

	    espx->encrypt(tdb, idat);

	    if (esph)
	      esph->Update(&ctx, idat, blks);

	    ivp = idat;
	    idat += blks;

	    ilen -= blks;
	    plen -= blks;
	}
    }

    /* Put in authentication data */
    if (esph)
    {
	esph->Final(auth, &ctx);
	bcopy(tdb->tdb_octx, &ctx, esph->ctxsize);
	esph->Update(&ctx, auth, esph->hashsize);
	esph->Final(auth, &ctx);

	/* Copy the final authenticator -- cheat and use bcopy() again */
	bcopy(auth, pad + padding, alen);
    }
    
    /* Save the last encrypted block, to be used as the next IV */
    bcopy(ivp, tdb->tdb_iv, tdb->tdb_ivlen);

    *mp = m;

    return 0;
}

/*
 * return 0 on success
 * return 1 for counter == 0
 * return 2 for very old packet
 * return 3 for packet within current window but already received
 */
int
checkreplaywindow32(u_int32_t seq, u_int32_t initial, u_int32_t *lastseq,
		    u_int32_t window, u_int32_t *bitmap)
{
    u_int32_t diff;

    seq -= initial;

    if (seq == 0)
      return 1;

    if (seq > *lastseq - initial)
    {
	diff = seq - (*lastseq - initial);
	if (diff < window)
	  *bitmap = ((*bitmap) << diff) | 1;
	else
	  *bitmap = 1;
	*lastseq = seq + initial;
	return 0;
    }

    diff = *lastseq - initial - seq;
    if (diff >= window)
    {
	espstat.esps_wrap++;
	return 2;
    }
    if ((*bitmap) & (((u_int32_t) 1) << diff))
    {
	espstat.esps_replay++;
	return 3;
    }

    *bitmap |= (((u_int32_t) 1) << diff);
    return 0;
}

@


1.56
log
@Correctly initialize loop variables when not doing authentication with
ESP (bug reported by provos@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.55 1999/12/09 20:22:03 angelos Exp $	*/
@


1.55
log
@Fix comment typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.54 1999/12/08 02:26:18 angelos Exp $	*/
d342 14
a362 14

	/* 
	 * Skip forward to the beginning of the ESP header. If we run out
	 * of mbufs in the process, the check inside the following while()
	 * loop will catch it.
	 */
	for (mo = m, i = 0; mo && i + mo->m_len <= skip; mo = mo->m_next)
	  i += mo->m_len;

	off = skip - i;

	/* Preserve these for later processing */
	roff = off;
	m1 = mo;
@


1.54
log
@AH finished, a couple of cosmetic changes in ESP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.53 1999/12/07 07:37:40 angelos Exp $	*/
d351 1
a351 1
	 * Skip forward to the begining of the ESP header. If we run out
d441 1
a441 1
	/* The ESP header was conveniently at the begining of the mbuf */
d452 1
a452 1
	   * begining of the remainder of the mbuf chain, if any.
@


1.53
log
@Missing "else"...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.52 1999/12/06 23:09:11 angelos Exp $	*/
a664 34
    /*
     * Loop through mbuf chain; if we find an M_EXT mbuf with 
     * more than one reference, replace the rest of the chain. 
     */
    mi = m;
    while (mi != NULL && 
	   (!(mi->m_flags & M_EXT) || 
	    (mi->m_ext.ext_ref == NULL &&
	     mclrefcnt[mtocl(mi->m_ext.ext_buf)] <= 1)))
    {
        mo = mi;
        mi = mi->m_next;
    }
     
    if (mi != NULL)
    {
        /* Replace the rest of the mbuf chain. */
        struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);
      
        if (n == NULL)
        {
	    espstat.esps_hdrops++;
	    m_freem(m);
	    return ENOBUFS;
        }

        if (mo != NULL)
	  mo->m_next = n;
        else
	  m = n;

        m_freem(mi);
    }

d708 34
@


1.52
log
@Keep statistics in default case as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.51 1999/12/06 22:33:29 angelos Exp $	*/
d366 1
a366 1
	    if (mo == 0)
a445 30
    if (roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen >= m1->m_len)
    {
	/*
	 * Part or all of the ESP header is at the end of this mbuf, so first
	 * let's remove the remainder of the ESP header from the
	 * begining of the remainder of the mbuf chain, if any.
	 */
	if (roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen > m1->m_len)
	{
	    /* Adjust the next mbuf by the remainder */
	    m_adj(m1->m_next, roff + 2 * sizeof(u_int32_t) +
		  tdb->tdb_ivlen - m1->m_len);

	    /* The second mbuf is guaranteed not to have a pkthdr... */
	    m->m_pkthdr.len -= roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen -
			       m1->m_len;
	}

	/* Now, let's unlink the mbuf chain for a second...*/
	mo = m1->m_next;
	m1->m_next = NULL;

	/* ...and trim the end of the first part of the chain...sick */
	m_adj(m1, -(m1->m_len - roff));
	if (!(m1->m_flags & M_PKTHDR))
	  m->m_pkthdr.len -= (m1->m_len - roff);

	/* Finally, let's relink */
	m1->m_next = mo;
    }
d447 44
a490 13
    {
	/* 
	 * The ESP header lies in the "middle" of the mbuf...do an
	 * overlapping copy of the remainder of the mbuf over the ESP
	 * header.
	 */
	bcopy(mtod(m1, u_char *) + roff + 2 * sizeof(u_int32_t) +
	      tdb->tdb_ivlen,
	      mtod(m1, u_char *) + roff,
	      m1->m_len - (roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen));
	m1->m_len -= (2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
	m->m_pkthdr.len -= (2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
    }
@


1.51
log
@Don't do m_adj() if it's not really needed (minor optimization,
doesn't correctness)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.50 1999/12/06 08:55:03 angelos Exp $	*/
d314 1
@


1.50
log
@Simplify include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.49 1999/12/06 07:14:35 angelos Exp $	*/
d445 30
d476 13
a488 38
      if (roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen > m1->m_len)
      {
	  /*
	   * Part of the ESP header is at the end of this mbuf, so first
	   * let's remove the remainder of the ESP header from the
	   * begining of the remainder of the mbuf chain.
	   */
	  m_adj(m1->m_next, roff + 2 * sizeof(u_int32_t) +
		tdb->tdb_ivlen - m1->m_len);
	  m->m_pkthdr.len -= roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen -
			     m1->m_len;

	  /* Now, let's unlink the mbuf chain for a second...*/
	  mo = m1->m_next;
	  m1->m_next = NULL;

	  /* ...and trim the end of the first part of the chain...sick */
	  m_adj(m1, -(m1->m_len - roff));
	  if (!(m1->m_flags & M_PKTHDR))
	    m->m_pkthdr.len -= (m1->m_len - roff);

	  /* Finally, let's relink */
	  m1->m_next = mo;
      }
      else
      {
	  /* 
	   * The ESP header lies in the "middle" of the mbuf...do an
	   * overlapping copy of the remainder of the mbuf over the ESP
	   * header.
	   */
	  bcopy(mtod(m1, u_char *) + roff + 2 * sizeof(u_int32_t) +
		tdb->tdb_ivlen,
		mtod(m1, u_char *) + roff,
		m1->m_len - (roff + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen));
	  m1->m_len -= (2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
	  m->m_pkthdr.len -= (2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
      }
@


1.49
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.48 1999/12/04 23:20:21 angelos Exp $	*/
a60 3
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
d66 1
a66 4
#include <netinet6/ip6.h>
#include <netinet6/in6_pcb.h>
#include <netinet6/ip6_var.h>
#include <netinet6/icmp6.h>
a68 1
#include <netinet/ip_icmp.h>
@


1.48
log
@Address independence, IPv6 support, and the -local flag in ipsecadm is
no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.47 1999/10/29 02:10:01 angelos Exp $	*/
d68 7
d86 4
d236 1
a236 1
	    tdbp->tdb_encalgxform->zerokey(&tdbp->tdb_key);
d257 1
d260 1
a260 1
esp_new_input(struct mbuf *m, struct tdb *tdb)
d262 1
d264 2
a265 6
    struct auth_hash *esph = (struct auth_hash *) tdb->tdb_authalgxform;
    u_char iv[ESP_MAX_IVS], niv[ESP_MAX_IVS];
    u_char blk[ESP_MAX_BLKS], *lblk, opts[40];
    int ohlen, oplen, plen, alen, ilen, i, blks, rest;
    int count, off, errc;
    struct mbuf *mi, *mo;
d267 2
a268 2
    struct esp_new *esp;
    struct ip *ip, ipo;
a269 5
    union authctx ctx;
    u_char buf[AH_ALEN_MAX], buf2[AH_ALEN_MAX];
#if INET6
    struct ipv6 *ipv6, ipv6o;
#endif /* INET6 */
d271 1
d279 4
a282 1
    if (m->m_len < sizeof(struct ip))
d284 4
a287 6
	if ((m = m_pullup(m, sizeof(struct ip))) == NULL)
	{
	    DPRINTF(("esp_new_input(): (possibly too short) packet dropped\n"));
	    espstat.esps_hdrops++;
	    return NULL;
	}
d290 2
a291 2
    ip = mtod(m, struct ip *);
    ohlen = (ip->ip_hl << 2) + ESP_NEW_FLENGTH;
d293 2
a294 2
    /* Make sure the IP header, any IP options, and the ESP header are here */
    if (m->m_len < ohlen + blks)
d296 27
a322 5
	if ((m = m_pullup(m, ohlen + blks)) == NULL)
	{
            DPRINTF(("esp_new_input(): m_pullup() failed\n"));
	    espstat.esps_hdrops++;
            return NULL;
a323 2

	ip = mtod(m, struct ip *);
d327 2
a328 2
    tdb->tdb_cur_bytes += ip->ip_len - ohlen - alen;
    espstat.esps_ibytes += ip->ip_len - ohlen - alen;
d348 1
a348 41
    esp = (struct esp_new *) ((u_int8_t *) ip + (ip->ip_hl << 2));
    ipo = *ip;

    /* Replay window checking */
    if (tdb->tdb_wnd > 0)
    {
	btsx = ntohl(esp->esp_rpl);
	if ((errc = checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl), tdb->tdb_wnd,
					&(tdb->tdb_bitmap))) != 0)
	{
	    switch(errc)
	    {
		case 1:
		    DPRINTF(("esp_new_input(): replay counter wrapped for packets from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(esp->esp_spi)));
		    espstat.esps_wrap++;
		    break;

		case 2:
	        case 3:
		    DPRINTF(("esp_new_input(): duplicate packet received from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(esp->esp_spi)));
		    espstat.esps_replay++;
		    break;
	    }

	    m_freem(m);
	    return NULL;
	}
    }

    /* Skip the IP header, IP options, SPI, SN and IV and minus Auth Data */
    plen = m->m_pkthdr.len - (ip->ip_hl << 2) - 2 * sizeof(u_int32_t) - 
	   tdb->tdb_ivlen - alen;

    if ((plen & (blks - 1)) || (plen <= 0))
    {
	DPRINTF(("esp_new_input(): payload not a multiple of %d octets for packet from %s to %s, spi %08x\n", blks, inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_badilen++;
	m_freem(m);
	return NULL;
    }

a352 4
	/* Auth covers SPI + SN + IV */
	oplen = plen + 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; 
	off = (ip->ip_hl << 2);

d354 1
a354 1
	m_copydata(m, m->m_pkthdr.len - alen, alen, buf);
d356 13
a368 1
	mo = m;
d374 2
a375 1
		DPRINTF(("esp_new_input(): bad mbuf chain for packet from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(esp->esp_spi)));
d388 1
a388 1
	esph->Final(buf2, &ctx);
d390 2
a391 2
	esph->Update(&ctx, buf2, esph->hashsize);
	esph->Final(buf2, &ctx);
d393 1
a393 1
	if (bcmp(buf2, buf, AH_HMAC_HASHLEN))
d395 1
a395 1
	    DPRINTF(("esp_new_input(): authentication failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(esp->esp_spi)));
a402 2
    ilen = m->m_len - (ip->ip_hl << 2) - 2 * sizeof(u_int32_t);
    idat = mtod(m, unsigned char *) + (ip->ip_hl << 2) + 2 * sizeof(u_int32_t);
d404 22
a425 1
    bcopy(idat, iv, tdb->tdb_ivlen);
d427 64
a490 1
    idat += tdb->tdb_ivlen;
d492 2
a493 1
    mi = m;
d528 2
a529 1
		    DPRINTF(("esp_new_input(): bad mbuf chain, SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d601 1
a601 4
    /* Save the options */
    m_copydata(m, sizeof(struct ip), (ipo.ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) opts);

d613 2
a614 1
    if (blk[blks - 2] + 2 + alen > m->m_pkthdr.len - (ip->ip_hl << 2) - 2 * sizeof(u_int32_t) - tdb->tdb_ivlen)
d616 1
a616 1
	DPRINTF(("esp_new_input(): invalid padding length %d for packet from %s to %s, spi %08x\n", blk[blks - 2], inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
d624 2
a625 1
	DPRINTF(("esp_new_input(): decryption failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
d630 2
a631 2
    m_adj(m, - blk[blks - 2] - 2 - alen);		/* Old type padding */
    m_adj(m, 2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
d633 2
a634 27
    if (m->m_len < (ipo.ip_hl << 2))
    {
	m = m_pullup(m, (ipo.ip_hl << 2));
	if (m == NULL)
	{
	    DPRINTF(("esp_new_input(): m_pullup() failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_hdrops++;
	    return NULL;
	}
    }

    ip = mtod(m, struct ip *);
    ipo.ip_p = blk[blks - 1];
    ipo.ip_id = htons(ipo.ip_id);
    ipo.ip_off = 0;
    ipo.ip_len += (ipo.ip_hl << 2) -  2 * sizeof(u_int32_t) - tdb->tdb_ivlen -
		  blk[blks - 2] - 2 - alen;

    ipo.ip_len = htons(ipo.ip_len);
    ipo.ip_sum = 0;
    *ip = ipo;

    /* Copy the options back */
    m_copyback(m, sizeof(struct ip), (ipo.ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) opts);

    ip->ip_sum = in_cksum(m, (ip->ip_hl << 2));
d640 2
a641 1
esp_new_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp)
d645 2
a646 3
    struct ip *ip, ipo;
    int i, ilen, ohlen, nh, rlen, plen, padding, rest;
    struct esp_new espo;
d649 1
a649 1
    u_char iv[ESP_MAX_IVS], blk[ESP_MAX_BLKS], auth[AH_ALEN_MAX], opts[40];
d651 1
a651 2
    int iphlen, blks, alen;
    
d653 4
d673 1
a673 1
	    mclrefcnt[mtocl(mi->m_ext.ext_buf)] <= 1)))
d699 2
a700 10
    m = m_pullup(m, sizeof (struct ip));   /* Get IP header in one mbuf */
    if (m == NULL)
    {
        DPRINTF(("esp_new_output(): m_pullup() failed, SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_hdrops++;
	return ENOBUFS;
    }

    if (tdb->tdb_rpl == 0)
d709 12
a720 2
    espo.esp_spi = tdb->tdb_spi;
    espo.esp_rpl = htonl(tdb->tdb_rpl++);
a721 3
    ip = mtod(m, struct ip *);
    iphlen = (ip->ip_hl << 2);
    
d723 2
a724 2
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);
    espstat.esps_obytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);
d726 1
a726 1
    /* Hard expiration */
d736 1
a736 1
    /* Notify on expiration */
d744 3
a746 4
    /*
     * If options are present, pullup the IP header, the options.
     */
    if (iphlen != sizeof(struct ip))
d748 4
a751 14
	m = m_pullup(m, iphlen + 8);
	if (m == NULL)
	{
	    DPRINTF(("esp_new_input(): m_pullup() failed for SA %s/%08x\n",
		     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_hdrops++;
	    return ENOBUFS;
	}

	ip = mtod(m, struct ip *);

	/* Keep the options */
	m_copydata(m, sizeof(struct ip), iphlen - sizeof(struct ip), 
		   (caddr_t) opts);
d754 4
a757 2
    ilen = ntohs(ip->ip_len);    /* Size of the packet */
    ohlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen;
d759 7
a765 14
    ipo = *ip;
    nh = ipo.ip_p;

    /* Raw payload length */
    rlen = ilen - iphlen; 
    padding = ((blks - ((rlen + 2) % blks)) % blks) + 2;
    if (iphlen + ohlen + rlen + padding + alen > IP_MAXPACKET)
    {
	DPRINTF(("esp_new_output(): packet in SA %s/%0x8 got too big\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	espstat.esps_toobig++;
        return EMSGSIZE;
    }
d767 1
d776 3
a778 3
    /* Self describing padding */
    for (i = 0; i < padding - 2; i++)
      pad[i] = i + 1;
d780 1
d782 5
a786 1
    pad[padding - 1] = nh;
d788 1
a788 4
    mi = m;
    plen = rlen + padding;
    ilen = m->m_len - iphlen;
    idat = mtod(m, u_char *) + iphlen;
d790 12
a801 2
    bcopy(tdb->tdb_iv, iv, tdb->tdb_ivlen);
    bcopy(tdb->tdb_iv, espo.esp_iv, tdb->tdb_ivlen);
d803 1
a803 1
    /* Authenticate the esp header */
d807 2
a808 2
	esph->Update(&ctx, (unsigned char *) &espo, 
		  2 * sizeof(u_int32_t) + tdb->tdb_ivlen);
a811 1

d822 2
a823 2
			bcopy(blk, iv, blks);
			ivp = iv;
d866 1
a866 1
		    blk[i] ^= ivp[i];
d871 1
a871 1
		    esph->Update(&ctx, blk, blks);
d889 1
a889 1
		idat[i] ^= ivp[i];
d894 1
a894 1
		esph->Update(&ctx, idat, blks);
d912 1
a912 1
	/* Copy the final authenticator */
d915 1
a915 27

    /*
     * Done with encryption. Let's wedge in the ESP header
     * and send it out.
     */

    M_PREPEND(m, ohlen, M_DONTWAIT);
    if (m == NULL)
    {
        DPRINTF(("esp_new_output(): M_PREPEND failed, SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
        return ENOBUFS;
    }

    m = m_pullup(m, iphlen + ohlen);
    if (m == NULL)
    {
        DPRINTF(("esp_new_output(): m_pullup() failed, SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_hdrops++;
        return ENOBUFS;
    }

    /* Fix the length and the next protocol, copy back and off we go */
    ipo.ip_len = htons(iphlen + ohlen + rlen + padding + alen);
    ipo.ip_p = IPPROTO_ESP;

a918 10
    m_copyback(m, 0, sizeof(struct ip), (caddr_t) &ipo);

    /* Copy options, if existing */
    if (iphlen != sizeof(struct ip))
      m_copyback(m, sizeof(struct ip), iphlen - sizeof(struct ip),
		 (caddr_t) opts);

    /* Copy in the esp header */
    m_copyback(m, iphlen, ohlen, (caddr_t) &espo);
	
d922 1
a922 2
}	

@


1.47
log
@Get rid of unnecessary third argument in *_output routines of IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.46 1999/10/06 22:27:57 jason Exp $	*/
d39 1
a39 2
 * Based on draft-ietf-ipsec-esp-v2-00.txt and
 * draft-ietf-ipsec-ciph-{des,3des}-{derived,expiv}-00.txt
d263 3
@


1.46
log
@M_EXT isn't the only test for a cluster any more: also test ext_ref
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.45 1999/06/30 17:23:59 deraadt Exp $	*/
d585 1
a585 2
esp_new_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb,
	       struct mbuf **mp)
@


1.45
log
@remove final low-level crypto knowledge from base ipsec code
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.44 1999/06/18 07:24:03 deraadt Exp $	*/
d615 2
a616 1
	    mclrefcnt[mtocl(mi->m_ext.ext_buf)] <= 1))
@


1.44
log
@split out transforms; some debugging done but there may still be bugs in
the new key init/zero functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.43 1999/05/16 21:48:35 niklas Exp $	*/
d262 1
a262 5
    union {
	 MD5_CTX md5ctx;
	 SHA1_CTX sha1ctx;
	 RMD160_CTX rmd160ctx;
    } ctx;
d596 1
a596 5
    union {
	 MD5_CTX md5ctx;
	 SHA1_CTX sha1ctx;
	 RMD160_CTX rmd160ctx;
    } ctx;
@


1.43
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.42 1999/05/12 22:58:47 ho Exp $	*/
d80 8
a87 37
extern void des_ecb3_encrypt(caddr_t, caddr_t, caddr_t, caddr_t, caddr_t, int);
extern void des_ecb_encrypt(caddr_t, caddr_t, caddr_t, int);
extern void des_set_key(caddr_t, caddr_t);

static void des1_encrypt(struct tdb *, u_int8_t *);
static void des3_encrypt(struct tdb *, u_int8_t *);
static void blf_encrypt(struct tdb *, u_int8_t *);
static void cast5_encrypt(struct tdb *, u_int8_t *);
static void skipjack_encrypt(struct tdb *, u_int8_t *);
static void des1_decrypt(struct tdb *, u_int8_t *);
static void des3_decrypt(struct tdb *, u_int8_t *);
static void blf_decrypt(struct tdb *, u_int8_t *);
static void cast5_decrypt(struct tdb *, u_int8_t *);
static void skipjack_decrypt(struct tdb *, u_int8_t *);

struct auth_hash esp_new_hash[] = {
     { SADB_AALG_MD5HMAC96, "HMAC-MD5-96", 
       MD5HMAC96_KEYSIZE, AH_MD5_ALEN,
       sizeof(MD5_CTX),
       (void (*) (void *)) MD5Init, 
       (void (*) (void *, u_int8_t *, u_int16_t)) MD5Update, 
       (void (*) (u_int8_t *, void *)) MD5Final 
     },
     { SADB_AALG_SHA1HMAC96, "HMAC-SHA1-96",
       SHA1HMAC96_KEYSIZE, AH_SHA1_ALEN,
       sizeof(SHA1_CTX),
       (void (*) (void *)) SHA1Init, 
       (void (*) (void *, u_int8_t *, u_int16_t)) SHA1Update, 
       (void (*) (u_int8_t *, void *)) SHA1Final 
     },
     { SADB_AALG_X_RIPEMD160HMAC96, "HMAC-RIPEMD-160-96",
       RIPEMD160HMAC96_KEYSIZE, AH_RMD160_ALEN,
       sizeof(RMD160_CTX),
       (void (*)(void *)) RMD160Init, 
       (void (*)(void *, u_int8_t *, u_int16_t)) RMD160Update, 
       (void (*)(u_int8_t *, void *)) RMD160Final 
     }
d90 12
a101 31
struct enc_xform esp_new_xform[] = {
     { SADB_EALG_DESCBC, "Data Encryption Standard (DES)",
       ESP_DES_BLKS, ESP_DES_IVS,
       8, 8, 8,
       des1_encrypt,
       des1_decrypt 
     },
     { SADB_EALG_3DESCBC, "Triple DES (3DES)",
       ESP_3DES_BLKS, ESP_3DES_IVS,
       24, 24, 8,
       des3_encrypt,
       des3_decrypt 
     },
     { SADB_EALG_X_BLF, "Blowfish",
       ESP_BLF_BLKS, ESP_BLF_IVS,
       5, BLF_MAXKEYLEN, 8,
       blf_encrypt,
       blf_decrypt 
     },
     { SADB_EALG_X_CAST, "CAST",
       ESP_CAST_BLKS, ESP_CAST_IVS,
       5, 16, 8,
       cast5_encrypt,
       cast5_decrypt 
     },
     { SADB_EALG_X_SKIPJACK, "Skipjack",
       ESP_SKIPJACK_BLKS, ESP_SKIPJACK_IVS,
       10, 10, 8,
       skipjack_encrypt,
       skipjack_decrypt 
     }
a103 62
static void
des1_encrypt(struct tdb *tdb, u_int8_t *blk)
{
    des_ecb_encrypt(blk, blk, tdb->tdb_key, 1);
}

static void
des1_decrypt(struct tdb *tdb, u_int8_t *blk)
{
    des_ecb_encrypt(blk, blk, tdb->tdb_key, 0);
}

static void
des3_encrypt(struct tdb *tdb, u_int8_t *blk)
{
    des_ecb3_encrypt(blk, blk, tdb->tdb_key, tdb->tdb_key + 128,
		     tdb->tdb_key + 256, 1);
}

static void
des3_decrypt(struct tdb *tdb, u_int8_t *blk)
{
    des_ecb3_encrypt(blk, blk, tdb->tdb_key + 256, tdb->tdb_key + 128,
		     tdb->tdb_key, 0);
}

static void
blf_encrypt(struct tdb *tdb, u_int8_t *blk)
{
    blf_ecb_encrypt((blf_ctx *) tdb->tdb_key, blk, 8);
}

static void
blf_decrypt(struct tdb *tdb, u_int8_t *blk)
{
    blf_ecb_decrypt((blf_ctx *) tdb->tdb_key, blk, 8);
}

static void
cast5_encrypt(struct tdb *tdb, u_int8_t *blk)
{
    cast_encrypt((cast_key *) tdb->tdb_key, blk, blk);
}

static void
cast5_decrypt(struct tdb *tdb, u_int8_t *blk)
{
    cast_decrypt((cast_key *) tdb->tdb_key, blk, blk);
}

static void
skipjack_encrypt(struct tdb *tdb, u_int8_t *blk)
{
    skipjack_forwards(blk, blk, (u_int8_t **) tdb->tdb_key);
}

static void
skipjack_decrypt(struct tdb *tdb, u_int8_t *blk)
{
    skipjack_backwards(blk, blk, (u_int8_t **) tdb->tdb_key);
}

d126 1
a126 1
    for (i = sizeof(esp_new_xform) / sizeof(struct enc_xform) - 1;
d128 1
a128 1
      if (ii->ii_encalg == esp_new_xform[i].type)
d137 1
a137 1
    txform = &esp_new_xform[i];
d153 1
a153 1
	for (i = sizeof(esp_new_hash) / sizeof(struct auth_hash) - 1;
d155 1
a155 1
	  if (ii->ii_authalg == esp_new_hash[i].type)
d164 1
a164 1
	thash = &esp_new_hash[i];
d191 2
a192 39
    switch (ii->ii_encalg)
    {
	case SADB_EALG_DESCBC:
	    MALLOC(tdbp->tdb_key, u_int8_t *, 128, M_XDATA, M_WAITOK);
	    bzero(tdbp->tdb_key, 128);
	    des_set_key(ii->ii_enckey, tdbp->tdb_key);
	    break;

	case SADB_EALG_3DESCBC:
	    MALLOC(tdbp->tdb_key, u_int8_t *, 384, M_XDATA, M_WAITOK);
	    bzero(tdbp->tdb_key, 384);
	    des_set_key(ii->ii_enckey, tdbp->tdb_key);
	    des_set_key(ii->ii_enckey + 8, tdbp->tdb_key + 128);
	    des_set_key(ii->ii_enckey + 16, tdbp->tdb_key + 256);
	    break;

        case SADB_EALG_X_BLF:
	    MALLOC(tdbp->tdb_key, u_int8_t *, sizeof(blf_ctx),
		   M_XDATA, M_WAITOK);
	    bzero(tdbp->tdb_key, sizeof(blf_ctx));
	    blf_key((blf_ctx *) tdbp->tdb_key, ii->ii_enckey,
		    ii->ii_enckeylen);
	    break;

        case SADB_EALG_X_CAST:
	    MALLOC(tdbp->tdb_key, u_int8_t *, sizeof(cast_key),
		   M_XDATA, M_WAITOK);
	    bzero(tdbp->tdb_key, sizeof(cast_key));
	    cast_setkey((cast_key *) tdbp->tdb_key, ii->ii_enckey,
			ii->ii_enckeylen);
	    break;

        case SADB_EALG_X_SKIPJACK:
	    MALLOC(tdbp->tdb_key, u_int8_t *, 10 * sizeof(u_int8_t *),
		   M_XDATA, M_WAITOK);
	    bzero(tdbp->tdb_key, 10 * sizeof(u_int8_t *));
	    subkey_table_gen(ii->ii_enckey, (u_int8_t **) tdbp->tdb_key);
	    break;
    }
d224 3
a226 43
    int k;

    if (tdbp->tdb_encalgxform && tdbp->tdb_key &&
	tdbp->tdb_encalgxform->type == SADB_EALG_X_SKIPJACK)
      for (k = 0; k < 10; k++)
	if (((u_int8_t **)tdbp->tdb_key)[k] != NULL)
	{
	    bzero(((u_int8_t **)tdbp->tdb_key)[k], 0x100);
            FREE(((u_int8_t **)tdbp->tdb_key)[k], M_XDATA);
	}

    if (tdbp->tdb_key)
    {
	if (tdbp->tdb_encalgxform)
	  switch (tdbp->tdb_encalgxform->type)
	  {
	      case SADB_EALG_DESCBC:
		  k = 128;
		  break;

	      case SADB_EALG_3DESCBC:
		  k = 384;
		  break;

	      case SADB_EALG_X_BLF:
		  k = sizeof(blf_ctx);
		  break;

	      case SADB_EALG_X_CAST:
		  k = sizeof(cast_key);
		  break;

	      case SADB_EALG_X_SKIPJACK:
		  /* Not really necessary, we have bzero'ed it */

	      default:
		  k = 0;
	  }

	bzero(tdbp->tdb_key, k);
	FREE(tdbp->tdb_key, M_XDATA);
	tdbp->tdb_key = NULL;
    }
@


1.42
log
@Follow local indentation style.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.41 1999/05/12 21:11:42 ho Exp $	*/
d498 1
a498 1
	tdb_delete(tdb, 0);
d869 1
a869 1
	tdb_delete(tdb, 0);
@


1.41
log
@Fix problem with data corruption for retransmitted TCP packets
in an IPSec ESP tunnel. OpenBSD PR 819.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.40 1999/03/24 17:00:45 niklas Exp $	*/
d784 1
a784 1
    struct mbuf *mi, *mo = (struct mbuf *)NULL;
d804 1
a804 1
     * Loop through mbuf chain; if we find an M_EXT mbuf with
d812 2
a813 2
      mo = mi;
      mi = mi->m_next;
d818 2
a819 2
      /* Replace the rest of the mbuf chain. */
      struct mbuf *n = m_copym2 (mi, 0, M_COPYALL, M_DONTWAIT);
d821 6
a826 6
      if (n == NULL)
      {
	espstat.esps_hdrops++;
	m_freem(m);
	return ENOBUFS;
      }
d828 4
a831 4
      if (mo != NULL)
	mo->m_next = n;
      else
	m = n;
d833 1
a833 1
      m_freem(mi);
@


1.40
log
@Implement lifetime expiration notifications.  Fix some typos.  Remove statics.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.39 1999/02/25 20:23:02 angelos Exp $	*/
d784 1
a784 1
    struct mbuf *mi, *mo;
d802 33
@


1.39
log
@Skipjack key bzero'ing case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.38 1999/02/25 20:14:40 angelos Exp $	*/
d497 1
a497 3
/* XXX
   encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d507 1
a507 3
/* XXX
   encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
d835 1
a835 3
/* XXX
   encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d845 1
a845 3
/* XXX
        encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
@


1.38
log
@Bzero key information before free'ing it, just for paranoia's sake.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.37 1999/02/25 18:43:42 angelos Exp $	*/
d402 3
@


1.37
log
@Be a bit more paranoid before free'ing memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.36 1999/02/24 23:45:49 angelos Exp $	*/
d377 4
a380 1
          FREE(((u_int8_t **)tdbp->tdb_key)[k], M_XDATA);
d384 24
d414 2
d422 2
@


1.36
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.35 1999/02/24 23:07:19 deraadt Exp $	*/
d371 1
a371 3
    if (tdbp->tdb_encalgxform && tdbp->tdb_encalgxform->type == SADB_EALG_X_SKIPJACK)
    {
        int k;
d373 4
a376 1
        for (k = 0; k < 10; k++)
a377 1
    }
@


1.35
log
@add skipjack support back
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.34 1999/02/24 22:33:02 angelos Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
a766 1
    {
a767 2
      DPRINTF(("esp_new_output(): using hash algorithm: %s\n", esph->name));
    } 
@


1.34
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.32 1999/02/16 23:58:00 angelos Exp $	*/
d86 1
d91 1
d141 6
d200 12
d330 7
d369 8
@


1.33
log
@ipsec skipjack, based on free .fi code (some .gov type will test this for me)
@
text
@a65 1
#include <net/encap.h>
d70 1
a70 1
#include <netinet/ip_ah.h>
a77 1
extern void encap_sendnotify(int, struct tdb *, void *);
d82 12
a93 14
static void des1_encrypt(void *, u_int8_t *);
static void des3_encrypt(void *, u_int8_t *);
static void blf_encrypt(void *, u_int8_t *);
static void cast5_encrypt(void *, u_int8_t *);
static void skipjack_encrypt(void *, u_int8_t *);
static void des1_decrypt(void *, u_int8_t *);
static void des3_decrypt(void *, u_int8_t *);
static void blf_decrypt(void *, u_int8_t *);
static void cast5_decrypt(void *, u_int8_t *);
static void skipjack_decrypt(void *, u_int8_t *);

struct esp_hash esp_new_hash[] = {
     { ALG_AUTH_MD5, "HMAC-MD5-96", 
       AH_MD5_ALEN,
d99 2
a100 2
     { ALG_AUTH_SHA1, "HMAC-SHA1-96",
       AH_SHA1_ALEN,
d106 2
a107 2
     { ALG_AUTH_RMD160, "HMAC-RIPEMD-160-96",
       AH_RMD160_ALEN,
d115 2
a116 2
struct esp_xform esp_new_xform[] = {
     { ALG_ENC_DES, "Data Encryption Standard (DES)",
d118 1
a118 1
       8, 8, 8 | 1,
d122 1
a122 1
     { ALG_ENC_3DES, "Triple DES (3DES)",
d124 1
a124 1
       24, 24, 8 | 1,
d128 1
a128 1
     { ALG_ENC_BLF, "Blowfish",
d130 1
a130 1
       5, BLF_MAXKEYLEN, 8 | 1,
d134 1
a134 1
     { ALG_ENC_CAST, "CAST",
d136 1
a136 1
       5, 16, 8 | 1,
a138 6
     },
     { ALG_ENC_CAST, "Skipjack",
       ESP_SKIPJACK_BLKS, ESP_SKIPJACK_IVS,
       10, 10, 8 | 1,
       skipjack_encrypt,
       skipjack_decrypt 
d143 1
a143 8
des1_encrypt(void *pxd, u_int8_t *blk)
{
     struct esp_new_xdata *xd = pxd;
     des_ecb_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]), 1);
}

static void
des1_decrypt(void *pxd, u_int8_t *blk)
d145 1
a145 2
     struct esp_new_xdata *xd = pxd;
     des_ecb_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]), 0);
d149 1
a149 1
des3_encrypt(void *pxd, u_int8_t *blk)
d151 1
a151 4
     struct esp_new_xdata *xd = pxd;
     des_ecb3_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]),
		      (caddr_t) (xd->edx_eks[1]),
		      (caddr_t) (xd->edx_eks[2]), 1);
d155 1
a155 1
des3_decrypt(void *pxd, u_int8_t *blk)
d157 2
a158 4
     struct esp_new_xdata *xd = pxd;
     des_ecb3_encrypt(blk, blk, (caddr_t) (xd->edx_eks[2]),
		      (caddr_t) (xd->edx_eks[1]),
		      (caddr_t) (xd->edx_eks[0]), 0);
d162 1
a162 1
blf_encrypt(void *pxd, u_int8_t *blk)
d164 2
a165 3
     struct esp_new_xdata *xd = pxd;
     Blowfish_encipher(&xd->edx_bks, (u_int32_t *) blk,
		       (u_int32_t *) (blk + 4));
d169 1
a169 1
blf_decrypt(void *pxd, u_int8_t *blk)
d171 1
a171 3
     struct esp_new_xdata *xd = pxd;
     Blowfish_decipher(&xd->edx_bks, (u_int32_t *) blk,
		       (u_int32_t *) (blk + 4));
d175 1
a175 1
cast5_encrypt(void *pxd, u_int8_t *blk)
d177 1
a177 2
     struct esp_new_xdata *xd = pxd;
     cast_encrypt(&xd->edx_cks, blk, blk);
d181 1
a181 1
cast5_decrypt(void *pxd, u_int8_t *blk)
d183 1
a183 2
     struct esp_new_xdata *xd = pxd;
     cast_decrypt(&xd->edx_cks, blk, blk);
d187 1
a187 1
skipjack_encrypt(void *pxd, u_int8_t *blk)
d189 1
a189 9
     struct esp_new_xdata *xd = pxd;
     skipjack_forwards(blk, blk, xd->edx_sks);
}

static void
skipjack_decrypt(void *pxd, u_int8_t *blk)
{
     struct esp_new_xdata *xd = pxd;
     skipjack_backwards(blk, blk, xd->edx_sks);
a193 1
 * It just returns.
a198 1
    DPRINTF(("esp_new_attach(): setting up\n"));
d203 1
a203 3
 * esp_new_init() is called when an SPI is being set up. It interprets the
 * encap_msghdr present in m, and sets up the transformation data, in
 * this case, the encryption and decryption key schedules
d207 1
a207 1
esp_new_init(struct tdb *tdbp, struct xformsw *xsp, struct mbuf *m)
d209 3
a211 17
    struct esp_new_xdata *xd;
    struct esp_new_xencap txd;
    struct encap_msghdr *em;
    struct esp_xform *txform;
    struct esp_hash *thash;
    caddr_t buffer = NULL;
    u_int32_t rk[14];
    int blocklen, i;

    if (m->m_len < ENCAP_MSG_FIXED_LEN)
    {
    	if ((m = m_pullup(m, ENCAP_MSG_FIXED_LEN)) == NULL)
    	{
	    DPRINTF(("esp_new_init(): m_pullup failed\n"));
	    return ENOBUFS;
	}
    }
d213 5
a217 9
    em = mtod(m, struct encap_msghdr *);
    if (em->em_msglen - EMT_SETSPI_FLEN <= ESP_NEW_XENCAP_LEN)
    {
	DPRINTF(("esp_new_init(): initialization failed\n"));
	return EINVAL;
    }

    /* Just copy the standard fields */
    m_copydata(m, EMT_SETSPI_FLEN, ESP_NEW_XENCAP_LEN, (caddr_t) &txd);
a218 4
    /* Check whether the encryption algorithm is supported */
    for (i = sizeof(esp_new_xform) / sizeof(struct esp_xform) - 1; i >= 0; i--) 
	if (txd.edx_enc_algorithm == esp_new_xform[i].type)
	      break;
d221 1
a221 1
	DPRINTF(("esp_new_init(): unsupported encryption algorithm %d specified\n", txd.edx_enc_algorithm));
a225 2
    DPRINTF(("esp_new_init(): initialized TDB with enc algorithm %d: %s\n",
	     txd.edx_enc_algorithm, esp_new_xform[i].name));
d227 1
a227 2
    /* Check whether the authentication algorithm is supported */
    if (txd.edx_flags & ESP_NEW_FLAG_AUTH) 
d229 17
a245 4
        for (i = sizeof(esp_new_hash) / sizeof(struct esp_hash) - 1; i >= 0;
	     i--) 
	    if (txd.edx_hash_algorithm == esp_new_hash[i].type)
	      break;
d248 2
a249 2
	    DPRINTF(("esp_new_init(): unsupported authentication algorithm %d specified\n", txd.edx_hash_algorithm));
            return EINVAL;
a251 3
	DPRINTF(("esp_new_init(): initialized TDB with hash algorithm %d: %s\n",
		 txd.edx_hash_algorithm, esp_new_hash[i].name));
        blocklen = HMAC_BLOCK_LEN;
a252 1
      }
d254 7
a260 7
    if (txd.edx_ivlen + txd.edx_confkeylen + txd.edx_authkeylen + 
	EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN != em->em_msglen)
    {
	if (encdebug)
	  DPRINTF(("esp_new_init(): message length (%d) doesn't match\n", em->em_msglen));
	return EINVAL;
    }
d262 2
a263 16
    /* Check the IV length */
    if (((txd.edx_ivlen == 0) && !(txform->ivmask&1)) ||
	((txd.edx_ivlen != 0) && (
	     !(txd.edx_ivlen & txform->ivmask) ||
	     (txd.edx_ivlen & (txd.edx_ivlen - 1)))))
    {
	DPRINTF(("esp_new_init(): unsupported IV length %d\n", txd.edx_ivlen));
	return EINVAL;
    }

    /* Check the key length */
    if (txd.edx_confkeylen < txform->minkey || 
	txd.edx_confkeylen > txform->maxkey)
    {
	DPRINTF(("esp_new_init(): bad key length %d\n", txd.edx_confkeylen));
	return EINVAL;
d265 5
d271 2
a272 7
    MALLOC(tdbp->tdb_xdata, caddr_t, sizeof(struct esp_new_xdata),
	   M_XDATA, M_WAITOK);
    if (tdbp->tdb_xdata == NULL)
    {
        DPRINTF(("esp_new_init(): MALLOC() failed\n"));
        return ENOBUFS;
    }
d274 1
a274 2
    bzero(tdbp->tdb_xdata, sizeof(struct esp_new_xdata));
    xd = (struct esp_new_xdata *) tdbp->tdb_xdata;
d276 2
a277 2
    /* Pointer to the transform */
    tdbp->tdb_xform = xsp;
d279 1
a279 22
    xd->edx_ivlen = txd.edx_ivlen;
    xd->edx_enc_algorithm = txd.edx_enc_algorithm;
    xd->edx_wnd = txd.edx_wnd;
    xd->edx_flags = txd.edx_flags;
    xd->edx_hash_algorithm = txd.edx_hash_algorithm;
    xd->edx_bitmap = 0;
    xd->edx_xform = txform;

    /* Pass name of enc algorithm for kernfs */
    tdbp->tdb_confname = xd->edx_xform->name;

    /* Replay counters are mandatory, even without auth */
    xd->edx_rpl = AH_HMAC_INITIAL_RPL;

    /* Copy the IV */
    m_copydata(m, EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN, xd->edx_ivlen,
	       (caddr_t) xd->edx_iv);

    /* Copy the key material */
    m_copydata(m, EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + xd->edx_ivlen,
	       txd.edx_confkeylen, (caddr_t) rk);
    switch (xd->edx_enc_algorithm)
d281 4
a284 2
	case ALG_ENC_DES:
	    des_set_key((caddr_t) rk, (caddr_t) (xd->edx_eks[0]));
d287 6
a292 4
	case ALG_ENC_3DES:
	    des_set_key((caddr_t) rk, (caddr_t) (xd->edx_eks[0]));
	    des_set_key((caddr_t) (rk + 2), (caddr_t) (xd->edx_eks[1]));
	    des_set_key((caddr_t) (rk + 4), (caddr_t) (xd->edx_eks[2]));
d294 7
a300 2
        case ALG_ENC_BLF:
	    blf_key(&xd->edx_bks, (caddr_t) rk, txd.edx_confkeylen);
d302 7
a308 5
        case ALG_ENC_CAST:
	    cast_setkey(&xd->edx_cks, (caddr_t) rk, txd.edx_confkeylen);
	    break;
        case ALG_ENC_SKIPJACK:
	    subkey_table_gen((caddr_t) rk, xd->edx_sks);
d312 1
a312 1
    if (txd.edx_flags & ESP_NEW_FLAG_AUTH)
a313 35
	xd->edx_hash = thash;

	/* Pass name of auth algorithm for kernfs */
	tdbp->tdb_authname = xd->edx_hash->name;

	DPRINTF(("esp_new_init(): using %d bytes of authentication key\n",
		 txd.edx_authkeylen));

	MALLOC(buffer, caddr_t, 
	       txd.edx_authkeylen < blocklen ? blocklen : txd.edx_authkeylen,
	       M_TEMP, M_WAITOK);
	if (buffer == NULL)
	{
	    DPRINTF(("esp_new_init(): MALLOC() failed\n"));
	    free(tdbp->tdb_xdata, M_XDATA);
	    return ENOBUFS;
	}

	bzero(buffer, txd.edx_authkeylen < blocklen ? 
	      blocklen : txd.edx_authkeylen);

	/* Copy the key to the buffer */
	m_copydata(m, EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + xd->edx_ivlen +
		   txd.edx_confkeylen, txd.edx_authkeylen, buffer);

	/* Shorten the key if necessary */
	if (txd.edx_authkeylen > blocklen)
	{
	    xd->edx_hash->Init(&(xd->edx_ictx));
	    xd->edx_hash->Update(&(xd->edx_ictx), buffer, txd.edx_authkeylen);
	    bzero(buffer, txd.edx_authkeylen < blocklen ? 
		  blocklen : txd.edx_authkeylen);
	    xd->edx_hash->Final(buffer, &(xd->edx_ictx));
	}

d315 2
a316 2
	for (i = 0; i < blocklen; i++)
	  buffer[i] ^= HMAC_IPAD_VAL;
d318 6
a323 2
	xd->edx_hash->Init(&(xd->edx_ictx));
	xd->edx_hash->Update(&(xd->edx_ictx), buffer, blocklen);
d325 2
a326 2
	for (i = 0; i < blocklen; i++)
	  buffer[i] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);
d328 6
a333 5
	xd->edx_hash->Init(&(xd->edx_octx));
	xd->edx_hash->Update(&(xd->edx_octx), buffer, blocklen);

	bzero(buffer, blocklen);
	free(buffer, M_TEMP);
a335 3
    bzero(rk, 14 * sizeof(u_int32_t));		/* paranoid */
    bzero(ipseczeroes, IPSEC_ZEROES_SIZE);	/* paranoid */

d342 5
a346 1
    struct esp_new_xdata *xd = (struct esp_new_xdata *) tdbp->tdb_xdata;
d348 4
a351 6
    DPRINTF(("esp_new_zeroize(): freeing memory\n"));
    if (xd->edx_enc_algorithm == ALG_ENC_SKIPJACK) {
	int k;

	for (k = 0; k < 10; k++)
	    free(xd->edx_sks[k], M_TEMP);
d354 1
a354 1
    if (tdbp->tdb_xdata)
d356 2
a357 2
      	FREE(tdbp->tdb_xdata, M_XDATA);
	tdbp->tdb_xdata = NULL;
d359 1
d367 2
a371 1
    struct esp_new_xdata *xd;
d385 1
a385 1
    xd = (struct esp_new_xdata *) tdb->tdb_xdata;
d387 1
a387 3
    blks = xd->edx_xform->blocksize;

    if (xd->edx_flags & ESP_NEW_FLAG_AUTH)
d418 26
d448 1
a448 1
    if (xd->edx_wnd >= 0)
d451 2
a452 2
	if ((errc = checkreplaywindow32(btsx, 0, &(xd->edx_rpl), xd->edx_wnd,
					&(xd->edx_bitmap))) != 0)
d457 1
a457 1
		    DPRINTF(("esp_new_input(): replay counter wrapped for packets from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi)));
d463 1
a463 1
		    DPRINTF(("esp_new_input(): duplicate packet received, %x->%x spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi)));
d475 1
a475 1
	   xd->edx_ivlen - alen;
d479 1
a479 1
	DPRINTF(("esp_new_input(): payload not a multiple of %d octets for packet from %x to %x, spi %08x\n", blks, ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d485 1
a485 1
    if (xd->edx_flags & ESP_NEW_FLAG_AUTH) 
d487 1
a487 1
	bcopy(&(xd->edx_ictx), &ctx, xd->edx_hash->ctxsize);
d490 1
a490 1
	oplen = plen + 2 * sizeof(u_int32_t) + xd->edx_ivlen; 
d502 1
a502 1
		DPRINTF(("esp_new_input(): bad mbuf chain for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi)));
d509 1
a509 1
	    xd->edx_hash->Update(&ctx, mtod(mo, unsigned char *) + off, count);
d515 4
a518 4
	xd->edx_hash->Final(buf2, &ctx);
	bcopy(&(xd->edx_octx), &ctx, xd->edx_hash->ctxsize);
	xd->edx_hash->Update(&ctx, buf2, xd->edx_hash->hashsize);
	xd->edx_hash->Final(buf2, &ctx);
d522 1
a522 1
	    DPRINTF(("esp_new_input(): authentication failed for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi)));
d533 4
a536 15
    if (xd->edx_ivlen == 0)		/* Derived IV in use */
    {
	bcopy((u_char *) &esp->esp_rpl, iv, sizeof(esp->esp_rpl));
	iv[4] = ~iv[0];
	iv[5] = ~iv[1];
	iv[6] = ~iv[2];
	iv[7] = ~iv[3];
    }
    else
    {
	bcopy(idat, iv, xd->edx_ivlen);
	ilen -= xd->edx_ivlen;
	idat += xd->edx_ivlen;
    }
    
d572 1
a572 1
		    DPRINTF(("esp_new_input(): bad mbuf chain, SA %x/%08x\n", tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d583 1
a583 1
		    DPRINTF(("esp_new_input(): m_pullup() failed, SA %x/%08x\n", tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d603 1
a603 1
		xd->edx_xform->decrypt(xd, blk);
d628 1
a628 1
	    xd->edx_xform->decrypt(xd, idat);
d649 1
a649 1
        bcopy(lblk, blk, blks);
d659 1
a659 1
    if ((xd->edx_flags & ESP_NEW_FLAG_NPADDING) == 0)
d661 5
a665 13
        if (blk[blks - 2] + 2 + alen > m->m_pkthdr.len - (ip->ip_hl << 2) - 2 * sizeof(u_int32_t) - xd->edx_ivlen)
        {
	    DPRINTF(("esp_new_input(): invalid padding length %d for packet from %x to %x, SA %x/%08x\n", blk[blks - 2], ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
	    espstat.esps_badilen++;
	    m_freem(m);
	    return NULL;
	}
        if ((blk[blks - 2] != blk[blks - 3]) && (blk[blks - 2] != 0))
	{
	    DPRINTF(("esp_new_input(): decryption failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
	    m_freem(m);
	    return NULL;
	} 
d667 1
a667 3
      	m_adj(m, - blk[blks - 2] - 2 - alen);		/* Old type padding */
    }
    else
d669 4
a672 23
        if (blk[blks - 2] + 1 + alen > m->m_pkthdr.len - (ip->ip_hl << 2) - 2 * sizeof(u_int32_t) - xd->edx_ivlen)
        {
	    DPRINTF(("esp_new_input(): invalid padding length %d for packet from %x to %x, SA %x/%08x\n", blk[blks - 2], ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
	    espstat.esps_badilen++;
	    m_freem(m);
	    return NULL;
	}
	if (blk[blks - 2] == 0)
	{
	    DPRINTF(("esp_new_input(): decryption failed for packet from %x to %x, SA %x/%08x -- peer is probably using old style padding\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
	    m_freem(m);
	    return NULL;
	}
	else
	  if ((blk[blks - 2] != 1) && (blk[blks - 2] != blk[blks - 3] + 1))
          {
	      DPRINTF(("esp_new_input(): decryption failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
              m_freem(m);
              return NULL;
          }

      	m_adj(m, - blk[blks - 2] - 1 - alen);
    }
d674 2
a675 1
    m_adj(m, 2 * sizeof(u_int32_t) + xd->edx_ivlen);
d682 1
a682 1
	    DPRINTF(("esp_new_input(): m_pullup() failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d692 2
a693 5
    ipo.ip_len += (ipo.ip_hl << 2) -  2 * sizeof(u_int32_t) - xd->edx_ivlen -
		  blk[blks - 2] - 1 - alen;

    if ((xd->edx_flags & ESP_NEW_FLAG_NPADDING) == 0)
      ipo.ip_len -= 1;
a704 46
    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) + 
	                  blk[blks - 2] + 1 + alen;
    espstat.esps_ibytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) + 
                           blk[blks - 2] + 1 + alen;

    if ((xd->edx_flags & ESP_NEW_FLAG_NPADDING) == 0)
    {
	tdb->tdb_cur_bytes++;
	espstat.esps_ibytes++;
    }

    /* Notify on expiration */
    if (tdb->tdb_flags & TDBF_SOFT_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_soft_packets)
      {
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	  tdb->tdb_flags &= ~TDBF_SOFT_PACKETS;
      }
      else
	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
	  {
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;
	  }
    }

    if (tdb->tdb_flags & TDBF_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_exp_packets)
      {
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	  tdb_delete(tdb, 0);
      }
      else
	if (tdb->tdb_flags & TDBF_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)
	  {
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	      tdb_delete(tdb, 0);
	  }
    }

d712 2
a713 1
    struct esp_new_xdata *xd;
d727 1
a727 3
    xd = (struct esp_new_xdata *) tdb->tdb_xdata;

    blks = xd->edx_xform->blocksize;
d729 1
a729 1
    if (xd->edx_flags & ESP_NEW_FLAG_AUTH)
d732 1
a732 1
      DPRINTF(("esp_new_output(): using hash algorithm: %s\n", xd->edx_hash->name));
d742 2
a743 2
        DPRINTF(("esp_new_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d748 1
a748 1
    if (xd->edx_rpl == 0)
d750 2
a751 2
	DPRINTF(("esp_new_output(): SA %x/%0x8 should have expired\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d758 1
a758 1
    espo.esp_rpl = htonl(xd->edx_rpl++);
d763 26
d797 2
a798 2
	    DPRINTF(("esp_new_input(): m_pullup() failed for SA %x/%08x\n",
		     tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d811 1
a811 1
    ohlen = 2 * sizeof(u_int32_t) + xd->edx_ivlen;
d819 4
a822 3
    if (iphlen + ohlen + rlen + padding + alen > IP_MAXPACKET) {
	DPRINTF(("esp_new_output(): packet in SA %x/%0x8 got too big\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d831 2
a832 2
        DPRINTF(("esp_new_output(): m_pad() failed for SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d840 1
a840 5
    if (xd->edx_flags & ESP_NEW_FLAG_NPADDING)
      pad[padding - 2] = padding - 1;
    else
      pad[padding - 2] = padding - 2;

d848 2
a849 13
    if (xd->edx_ivlen == 0)
    {
	bcopy((u_char *) &espo.esp_rpl, iv, 4);
	iv[4] = ~iv[0];
	iv[5] = ~iv[1];
	iv[6] = ~iv[2];
	iv[7] = ~iv[3];
    } 
    else
    {
	bcopy(xd->edx_iv, iv, xd->edx_ivlen);
	bcopy(xd->edx_iv, espo.esp_iv, xd->edx_ivlen);
    }
d852 1
a852 1
    if (xd->edx_flags & ESP_NEW_FLAG_AUTH)
d854 3
a856 3
	bcopy(&(xd->edx_ictx), &ctx, xd->edx_hash->ctxsize);
	xd->edx_hash->Update(&ctx, (unsigned char *) &espo, 
		  2 * sizeof(u_int32_t) + xd->edx_ivlen);
d883 2
a884 1
		    DPRINTF(("esp_new_output(): bad mbuf chain, SA %x/%08x\n", tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d895 1
a895 1
		    DPRINTF(("esp_new_output(): m_pullup() failed, SA %x/%08x\n", tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d917 1
a917 1
		xd->edx_xform->encrypt(xd, blk);
d919 2
a920 2
		if (xd->edx_flags & ESP_NEW_FLAG_AUTH)
		    xd->edx_hash->Update(&ctx, blk, blks);
d940 1
a940 1
	    xd->edx_xform->encrypt(xd, idat);
d942 2
a943 2
	    if (xd->edx_flags & ESP_NEW_FLAG_AUTH)
		xd->edx_hash->Update(&ctx, idat, blks);
d954 1
a954 1
    if (xd->edx_flags & ESP_NEW_FLAG_AUTH)
d956 4
a959 4
	xd->edx_hash->Final(auth, &ctx);
	bcopy(&(xd->edx_octx), &ctx, xd->edx_hash->ctxsize);
	xd->edx_hash->Update(&ctx, auth, xd->edx_hash->hashsize);
	xd->edx_hash->Final(auth, &ctx);
d973 2
a974 2
        DPRINTF(("esp_new_output(): M_PREPEND failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d981 2
a982 2
        DPRINTF(("esp_new_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d992 1
a992 1
    bcopy(ivp, xd->edx_iv, xd->edx_ivlen);
a1005 38
    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += rlen + padding;
    espstat.esps_obytes += rlen + padding;

    /* Notify on expiration */
    if (tdb->tdb_flags & TDBF_SOFT_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_soft_packets)
      {
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	  tdb->tdb_flags &= ~TDBF_SOFT_PACKETS;
      }
      else
	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
	  {
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;
	  }
    }

    if (tdb->tdb_flags & TDBF_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_exp_packets)
      {
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	  tdb_delete(tdb, 0);
      }
      else
	if (tdb->tdb_flags & TDBF_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)
	  {
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	      tdb_delete(tdb, 0);
	  }
    }

d1053 1
@


1.32
log
@Fix a padding check bug in the experimental-padding. iliya@@ericom.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.31 1999/02/12 00:46:10 deraadt Exp $	*/
d88 1
d93 1
d143 6
d214 14
d388 3
d456 2
d459 7
@


1.31
log
@angelos cannot spell small words
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.30 1999/01/11 22:52:09 deraadt Exp $	*/
d756 1
a756 1
	  if (blk[blks - 2] != blk[blks - 3] + 1)
@


1.30
log
@remove panic() calls, consistent error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.28 1999/01/08 21:40:26 deraadt Exp $	*/
d124 1
a124 1
     { ALG_ENC_3DES, "Tripple DES (3DES)",
@


1.29
log
@panic prints a newline for you, don't do it in the panic string
@
text
@a71 1
#include <sys/syslog.h>
d248 1
a248 2
	if (encdebug)
	  log(LOG_WARNING, "esp_new_init(): initialization failed\n");
d261 1
a261 2
	if (encdebug)
	  log(LOG_WARNING, "esp_new_init(): unsupported encryption algorithm %d specified\n", txd.edx_enc_algorithm);
d278 1
a278 2
            if (encdebug)
                log(LOG_WARNING, "esp_new_init(): unsupported authentication algorithm %d specified\n", txd.edx_hash_algorithm);
d292 1
a292 1
	  log(LOG_WARNING, "esp_new_init(): message length (%d) doesn't match\n", em->em_msglen);
d302 1
a302 3
	if (encdebug)
	  log(LOG_WARNING, "esp_new_init(): unsupported IV length %d\n",
	      txd.edx_ivlen);
d310 1
a310 3
	if (encdebug)
	  log(LOG_WARNING, "esp_new_init(): bad key length %d\n",
	      txd.edx_confkeylen);
d489 1
a489 1
            espstat.esps_hdrops++;
d509 1
a509 2
		    if (encdebug)
		      log(LOG_ERR, "esp_new_input(): replay counter wrapped for packets from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi));
d515 1
a515 2
		    if (encdebug) 
		      log(LOG_WARNING, "esp_new_input(): duplicate packet received, %x->%x spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi));
d553 6
a558 1
	      panic("esp_new_input(): m_copydata (copy)");
d574 1
a574 2
	    if (encdebug)
	      log(LOG_ALERT, "esp_new_input(): authentication failed for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi));
d634 6
a639 1
		    panic("esp_new_input(): bad chain (i)");
d646 2
a647 2
		    DPRINTF(("esp_new_input(): m_pullup() failed, SA %x/%08x\n",
			       tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d733 1
a733 2
	    if (encdebug)
	      log(LOG_ALERT, "esp_new_input(): decryption failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d751 1
a751 2
	    if (encdebug)
	      log(LOG_ALERT, "esp_new_input(): decryption failed for packet from %x to %x, SA %x/%08x -- peer is probably using old style padding\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d758 1
a758 2
	      if (encdebug)
                log(LOG_ALERT, "esp_new_input(): decryption failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d774 1
d885 1
d891 2
a892 3
	if (encdebug)
          log(LOG_ALERT, "esp_new_output(): SA %x/%0x8 should have expired\n",
	      tdb->tdb_dst, ntohl(tdb->tdb_spi));
d914 1
d935 2
a936 4
	if (encdebug)
            log(LOG_ALERT,
		"esp_new_output(): packet in SA %x/%0x8 got too big\n",
		tdb->tdb_dst, ntohl(tdb->tdb_spi));
d1011 6
a1016 1
		    panic("esp_new_output(): bad chain (i)");
d1023 3
a1025 2
		    DPRINTF(("esp_new_output(): m_pullup() failed, SA %x/%08x\n",
			       tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d1111 1
@


1.28
log
@do not use random bits when not necessary, remove 8-byte block dependence
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.27 1998/11/25 09:56:51 niklas Exp $	*/
d640 1
a640 1
		    panic("esp_new_input(): bad chain (i)\n");
d1015 1
a1015 1
		    panic("esp_new_output(): bad chain (i)\n");
@


1.27
log
@Better error code for too large packets
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.26 1998/11/25 02:01:27 niklas Exp $	*/
d181 1
a181 1
     Blowfish_encipher(&xd->edx_bks, (u_int32_t *)blk,
d189 1
a189 1
     Blowfish_decipher(&xd->edx_bks, (u_int32_t *)blk,
d717 2
a718 2
     * blk[7] contains the next protocol, and blk[6] contains the
     * amount of padding the original chain had. Chop off the
d725 1
a725 1
        if (blk[6] + 2 + alen > m->m_pkthdr.len - (ip->ip_hl << 2) - 2 * sizeof(u_int32_t) - xd->edx_ivlen)
d727 1
a727 1
	    DPRINTF(("esp_new_input(): invalid padding length %d for packet from %x to %x, SA %x/%08x\n", blk[6], ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d732 1
a732 1
        if ((blk[6] != blk[5]) && (blk[6] != 0))
d740 1
a740 1
      	m_adj(m, - blk[6] - 2 - alen);		/* Old type padding */
d744 1
a744 1
        if (blk[6] + 1 + alen > m->m_pkthdr.len - (ip->ip_hl << 2) - 2 * sizeof(u_int32_t) - xd->edx_ivlen)
d746 1
a746 1
	    DPRINTF(("esp_new_input(): invalid padding length %d for packet from %x to %x, SA %x/%08x\n", blk[6], ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d751 1
a751 1
	if (blk[6] == 0)
d759 1
a759 1
	  if (blk[6] != blk[5] + 1)
d767 1
a767 1
      	m_adj(m, - blk[6] - 1 - alen);
d783 1
a783 1
    ipo.ip_p = blk[7];
d787 1
a787 1
		  blk[6] - 1 - alen;
d805 1
a805 1
	                  blk[6] + 1 + alen;
d807 1
a807 1
                           blk[6] + 1 + alen;
d946 1
a946 1
    pad = (u_char *) m_pad(m, padding + alen);
@


1.26
log
@Add checks of packets getting to big after transforms.
Also make sure some more error conditions get told to the caller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.25 1998/11/25 01:02:59 niklas Exp $	*/
d943 1
a943 1
        return ENOBUFS;
@


1.25
log
@Tell caller of error condition
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.24 1998/08/01 08:35:12 provos Exp $	*/
d936 9
@


1.24
log
@more careful error handling, some simplification and beautification.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.23 1998/07/30 08:41:20 provos Exp $	*/
d898 1
a898 1
	return NULL;
@


1.23
log
@fixing a stupid bug I introduced when trying to improve the encryption
performance by avoiding unnecessary copies. There was a problem when two
subsequent mbufs were != 0 mod blocksize and the next < blocksize, so we
lost the rest of the last mbuf as IV.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.22 1998/06/11 14:17:22 provos Exp $	*/
a504 1

d551 1
a551 1
	/* Auth covers SPI + SN + IV*/
d555 3
d559 1
a565 1

a567 26
	    if (oplen == 0) 
	    {
		/* Get the authentication data */
		if (mo->m_len - off - count >= alen)
		  bcopy(mtod(mo, unsigned char *) + off + count, buf, alen);
		else 
		{
		    int olen = alen, tmp = 0;
		      
		    mi = mo;
		    off += count;
		      
		    while (mi != NULL && olen > 0) 
		    {
			count = min(mi->m_len - off, olen);
			bcopy(mtod(mi, unsigned char *) + off, buf + tmp,
			      count);
			  
			off = 0;
			tmp += count;
			olen -= count;
			mi = mi->m_next;
		    }
		}
	    }
		   
d669 1
a669 1
		for (i=0; i<blks; i++)
d694 1
a694 1
	    for (i=0; i<blks; i++)
d1031 1
a1031 1
		for (i=0; i<blks; i++)
d1054 1
a1054 1
	    for (i=0; i<blks; i++)
@


1.22
log
@fix a mbuf chain corruption which happened when m_pullup was called on an
mbuf in the middle of the chain and had to MGET a new one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.21 1998/06/03 09:50:21 provos Exp $	*/
d1017 6
@


1.21
log
@cleanup debug printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.20 1998/05/24 22:56:29 provos Exp $	*/
d662 1
a662 1
		mi = mi->m_next;
d676 5
d883 1
a883 1
    struct mbuf *mi;
d1022 1
a1022 1
		mi = mi->m_next;
d1035 5
@


1.20
log
@allow the use of blowfish and cast encryption with implicit iv
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.19 1998/05/18 21:10:43 provos Exp $	*/
d74 6
d215 1
a215 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("esp_new_attach(): setting up\n");
#endif /* ENCDEBUG */
d241 1
a241 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_new_init(): m_pullup failed\n");
#endif /* ENCDEBUG */
d269 2
a270 5
#ifdef ENCDEBUG
    if (encdebug)
      printf("esp_new_init(): initialized TDB with enc algorithm %d: %s\n",
	     txd.edx_enc_algorithm, esp_new_xform[i].name);
#endif /* ENCDEBUG */
d286 2
a287 5
#ifdef ENCDEBUG
        if (encdebug)
            printf("esp_new_init(): initialized TDB with hash algorithm %d: %s\n",
		   txd.edx_hash_algorithm, esp_new_hash[i].name);
#endif /* ENCDEBUG */
d326 1
a326 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_init(): MALLOC() failed\n");
#endif /* ENCDEBUG */
d383 2
a384 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_init(): using %d bytes of authentication key\n",
		 txd.edx_authkeylen);
#endif
d391 1
a391 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_new_init(): MALLOC() failed\n");
#endif /* ENCDEBUG */
d439 1
a439 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("esp_new_zeroize(): freeing memory\n");
#endif ENCDEBUG
d482 1
a482 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_new_input(): (possibly too short) packet dropped\n");
#endif /* ENCDEBUG */
d496 1
a496 4
#ifdef ENCDEBUG
            if (encdebug)
              printf("esp_new_input(): m_pullup() failed\n");
#endif /* ENCDEBUG */
d542 1
a542 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_input(): payload not a multiple of %d octets for packet from %x to %x, spi %08x\n", blks, ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d671 2
a672 5
#ifdef ENCDEBUG
		    if (encdebug)
			printf("esp_new_input(): m_pullup() failed, SA %x/%08x\n",
			       tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d746 1
a746 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_new_input(): invalid padding length %d for packet from %x to %x, SA %x/%08x\n", blk[6], ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */	    
d765 1
a765 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_new_input(): invalid padding length %d for packet from %x to %x, SA %x/%08x\n", blk[6], ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */	    
d796 1
a796 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_new_input(): m_pullup() failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d895 1
a895 5
#ifdef ENCDEBUG
      if (encdebug)
	printf("esp_new_output(): using hash algorithm: %s\n",
	       xd->edx_hash->name);
#endif /* ENCDEBUG */
d905 2
a906 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d934 2
a935 5
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_new_input(): m_pullup() failed for SA %x/%08x\n",
		     tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d959 2
a960 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_output(): m_pad() failed for SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d1026 2
a1027 5
#ifdef ENCDEBUG
		    if (encdebug)
			printf("esp_new_output(): m_pullup() failed, SA %x/%08x\n",
			       tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d1098 2
a1099 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_output(): M_PREPEND failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d1106 2
a1107 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
@


1.19
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.18 1998/05/05 08:54:48 provos Exp $	*/
d127 1
a127 1
       5, BLF_MAXKEYLEN, 8,
d133 1
a133 1
       5, 16, 8,
@


1.18
log
@check for invalid padding length, reported by Dan McDonald (Sun Microsystems)
<danmcd@@eng.sun.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.17 1998/03/07 21:30:24 provos Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
d74 1
a74 1
extern void encap_sendnotify(int, struct tdb *);
d878 1
a878 1
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d885 1
a885 1
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d894 1
a894 1
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d901 1
a901 1
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d1201 1
a1201 1
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d1208 1
a1208 1
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d1217 1
a1217 1
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d1224 1
a1224 1
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
@


1.17
log
@improve performance by avoiding unnecessary copies.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.16 1998/02/22 01:23:32 niklas Exp $	*/
d558 1
a558 1
    if (plen & (blks - 1))
d768 10
d790 10
@


1.16
log
@Changes made for GCC 2.8 -Wall pleasures
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.15 1998/01/21 18:43:33 provos Exp $	*/
d464 3
a466 2
    u_char iv[ESP_MAX_IVS], niv[ESP_MAX_IVS], blk[ESP_MAX_BLKS], opts[40];
    int ohlen, oplen, plen, alen, ilen, olen, i, blks;
d470 1
a470 1
    u_char *idat, *odat;
d513 1
a513 1
              printf("esp_old_input(): m_pullup() failed\n");
d557 1
d651 1
a651 4
    olen = ilen;
    odat = idat;
    mi = mo = m;
    i = 0;
d659 2
a660 2
     *   iv contains the IV.
     *   mi and mo point to the first mbuf
d663 3
a665 5
     *   . move the next eight octets of the chain into blk[]
     *     (ilen, idat, and mi are adjusted accordingly)
     *     and save it back into iv[]
     *   . decrypt blk[], xor with iv[], put back into chain
     *     (olen, odat, amd mo are adjusted accordingly)
d669 3
d674 1
a674 1
	while (ilen == 0)	/* we exhausted previous mbuf */
d676 11
a686 3
	    mi = mi->m_next;
	    if (mi == NULL)
	      panic("esp_new_input(): bad chain (i)\n");
d688 14
d703 1
a703 2
	    idat = (u_char *) mi->m_data;
	}
d705 6
a710 3
	blk[i] = niv[i] = *idat++;
	i++;
	ilen--;
d712 2
a713 3
	if (i == blks)
	{
    	    xd->edx_xform->decrypt(xd, blk);
d715 2
a716 7
	    for (i=0; i<8; i++)
	    {
		while (olen == 0)
		{
		    mo = mo->m_next;
		    if (mo == NULL)
		      panic("esp_new_input(): bad chain (o)\n");
d718 2
a719 3
		    olen = mo->m_len;
		    odat = (u_char *)mo->m_data;
		}
d721 5
a725 4
		*odat = blk[i] ^ iv[i];
		iv[i] = niv[i];
		blk[i] = *odat++; /* needed elsewhere */
		olen--;
d728 1
a728 1
	    i = 0;
d731 18
a748 1
	plen--;
d755 3
d889 1
a889 1
    int i, ilen, olen, ohlen, nh, rlen, plen, padding;
d891 3
a893 3
    struct mbuf *mi, *mo;
    u_char *pad, *idat, *odat;
    u_char iv[ESP_3DES_IVS], blk[ESP_3DES_IVS], auth[AH_ALEN_MAX], opts[40];
d1001 1
a1001 1
    mi = mo = m;
d1003 2
a1004 3
    ilen = olen = m->m_len - iphlen;
    idat = odat = mtod(m, u_char *) + iphlen;
    i = 0;
d1030 2
d1034 1
a1034 1
	while (ilen == 0)	/* we exhausted previous mbuf */
d1036 5
a1040 3
	    mi = mi->m_next;
	    if (mi == NULL)
	      panic("esp_new_output(): bad chain (i)\n");
d1042 19
d1062 15
a1076 2
	    idat = (u_char *) mi->m_data;
	}
d1078 2
a1079 1
	blk[i] = *idat++ ^ iv[i];
d1081 4
a1084 2
	i++;
	ilen--;
d1086 4
a1089 1
	if (i == blks)
d1091 4
a1094 1
	    xd->edx_xform->encrypt(xd, blk);
d1097 1
a1097 1
		xd->edx_hash->Update(&ctx, blk, blks);
d1099 2
a1100 11
	    for (i = 0; i < blks; i++)
	    {
		while (olen == 0)
		{
		    mo = mo->m_next;
		    if (mo == NULL)
		      panic("esp_new_output(): bad chain (o)\n");

		    olen = mo->m_len;
		    odat = (u_char *)mo->m_data;
		}
d1102 2
a1103 5
		*odat++ = blk[i];
		iv[i] = blk[i];
		olen--;
	    }
	    i = 0;
a1104 2

	plen--;
d1140 1
a1140 1
	  printf("esp_old_output(): m_pullup() failed, SA %x/%08x\n",
d1151 1
a1151 1
    bcopy(blk, xd->edx_iv, xd->edx_ivlen);
@


1.15
log
@rcvif not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.14 1997/11/24 19:14:14 provos Exp $	*/
d811 1
d824 2
a825 1
    
d827 1
d840 1
d1104 1
d1117 2
a1118 1
    
d1120 1
d1133 1
@


1.14
log
@add ripemd-160 as authentication function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.13 1997/11/18 09:09:45 deraadt Exp $	*/
a470 1
    struct ifnet *rcvif;
a487 10

    rcvif = m->m_pkthdr.rcvif;
    if (rcvif == NULL)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_input(): receive interface is NULL!!!\n");
#endif /* ENCDEBUG */
	rcvif = &enc_softc;
    }
@


1.13
log
@fix 3DES, style changes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.12 1997/11/18 00:12:15 provos Exp $	*/
d96 7
d477 1
d866 1
@


1.12
log
@make old style padding default again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.11 1997/11/15 00:07:08 deraadt Exp $	*/
d86 3
a88 3
       (void (*)(void *))MD5Init, 
       (void (*)(void *, u_int8_t *, u_int16_t))MD5Update, 
       (void (*)(u_int8_t *, void *))MD5Final 
d93 3
a95 3
       (void (*)(void *))SHA1Init, 
       (void (*)(void *, u_int8_t *, u_int16_t))SHA1Update, 
       (void (*)(u_int8_t *, void *))SHA1Final 
d144 1
a144 1
     des_ecb3_encrypt(blk, blk, (caddr_t) (xd->edx_eks[2]),
d146 1
a146 1
		      (caddr_t) (xd->edx_eks[0]), 1);
d163 1
a163 1
		       (u_int32_t *)(blk+4));
d171 1
a171 1
		       (u_int32_t *)(blk+4));
d218 1
a219 1
    u_int32_t rk[14];
d245 1
a245 1
    for (i=sizeof(esp_new_xform)/sizeof(struct esp_xform)-1; i >= 0; i--) 
d265 2
a266 1
        for (i=sizeof(esp_new_hash)/sizeof(struct esp_hash)-1; i >= 0; i--) 
d297 1
a297 1
	     (txd.edx_ivlen & (txd.edx_ivlen-1)))))
d457 2
d460 2
a461 2
    struct ip *ip, ipo;
    u_char iv[ESP_MAX_IVS], niv[ESP_MAX_IVS], blk[ESP_MAX_BLKS], opts[40];
d465 1
a465 2
    int ohlen, oplen, plen, alen, ilen, olen, i, blks;
    int count, off, errc;
a466 1
    struct mbuf *mi, *mo;
d473 1
a473 1
    xd = (struct esp_new_xdata *)tdb->tdb_xdata;
d556 2
a557 2
    /* Skip the IP header, IP options, SPI, SN and IV and minus Auth Data*/
    plen = m->m_pkthdr.len - (ip->ip_hl << 2) - 2 * sizeof (u_int32_t) - 
@


1.11
log
@fix memory management errors
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.10 1997/11/04 09:11:11 provos Exp $	*/
d730 1
a730 1
    if (xd->edx_flags & ESP_NEW_FLAG_OPADDING)
d785 1
a785 1
    if (xd->edx_flags & ESP_NEW_FLAG_OPADDING)
d805 1
a805 1
    if (xd->edx_flags & ESP_NEW_FLAG_OPADDING)
d953 3
a955 1
    if (xd->edx_flags & ESP_NEW_FLAG_OPADDING)
a956 2
    else
      pad[padding - 2] = padding - 1;
@


1.10
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.9 1997/10/02 02:31:04 deraadt Exp $	*/
d444 5
a448 1
    FREE(tdbp->tdb_xdata, M_XDATA);
@


1.9
log
@conditional error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.8 1997/09/30 03:18:04 deraadt Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
d73 115
d215 2
d218 2
a219 2
    int blocklen, i, enc_keylen, auth_keylen;
    u_int32_t rk[6];
d245 4
a248 1
    switch (txd.edx_enc_algorithm)
d250 6
a255 2
        case ALG_ENC_DES:
        case ALG_ENC_3DES:
d257 3
a259 3
            if (encdebug)
              printf("esp_new_init(): initialized TDB with enc algorithm %d\n",
                     txd.edx_enc_algorithm);
a260 1
            break;
d262 10
a271 3
        default:
	    if (encdebug)
              log(LOG_WARNING, "esp_new_init(): unsupported encryption algorithm %d specified\n", txd.edx_enc_algorithm);
d273 1
a273 1
    }
a274 6
    /* Check whether the authentication algorithm is supported */
    if (txd.edx_flags & ESP_NEW_FLAG_AUTH)
      switch (txd.edx_hash_algorithm)
      {
          case ALG_AUTH_MD5:
          case ALG_AUTH_SHA1:
d276 3
a278 2
              if (encdebug)
                printf("esp_new_init(): initialized TDB with hash algorithm %d\n", txd.edx_hash_algorithm);
d280 2
a281 7
	      blocklen = HMAC_BLOCK_LEN;
              break;

          default:
	      if (encdebug)
                log(LOG_WARNING, "esp_new_init(): unsupported authentication algorithm %d specified\n", txd.edx_enc_algorithm);
              return EINVAL;
d284 2
a285 2
    if (txd.edx_ivlen + txd.edx_keylen + EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN
	!= em->em_msglen)
d292 5
a296 1
    switch (txd.edx_enc_algorithm)
d298 5
a302 8
	case ALG_ENC_DES:
	    if ((txd.edx_ivlen != 0) && (txd.edx_ivlen != 8))
	    {
		if (encdebug)
	       	  log(LOG_WARNING, "esp_new_init(): unsupported IV length %d\n",
		      txd.edx_ivlen);
		return EINVAL;
	    }
d304 8
a311 30
	    if (txd.edx_keylen < 8)
	    {
		if (encdebug)
		  log(LOG_WARNING, "esp_new_init(): bad key length\n",
		      txd.edx_keylen);
		return EINVAL;
	    }

	    enc_keylen = 8;
	    break;

	case ALG_ENC_3DES:
            if ((txd.edx_ivlen != 0) && (txd.edx_ivlen != 8))
            {
		if (encdebug)
                  log(LOG_WARNING, "esp_new_init(): unsupported IV length %d\n",
                      txd.edx_ivlen);
                return EINVAL;
            }

            if (txd.edx_keylen < 24)
            {
		if (encdebug)
                  log(LOG_WARNING, "esp_new_init(): bad key length\n",
                      txd.edx_keylen);
                return EINVAL;
            }

	    enc_keylen = 24;
            break;
d337 4
d349 3
a354 4
	    /* Copy the key material */
	    m_copydata(m, EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + xd->edx_ivlen,
		       enc_keylen, (caddr_t) rk);

a358 4
	    /* Copy the key material */
	    m_copydata(m, EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + xd->edx_ivlen,
		       enc_keylen, (caddr_t) rk);

d363 6
d373 4
a376 1
	auth_keylen = txd.edx_keylen - enc_keylen;
d381 1
a381 1
		 auth_keylen);
d385 1
a385 1
	       auth_keylen < blocklen ? blocklen : auth_keylen,
d397 2
a398 1
	bzero(buffer, auth_keylen < blocklen ? blocklen : auth_keylen);
d402 1
a402 1
		   enc_keylen, auth_keylen, buffer);
d405 1
a405 1
	if (auth_keylen > blocklen)
d407 5
a411 18
	    switch (xd->edx_hash_algorithm)
	    {
		case ALG_AUTH_MD5:
		    MD5Init(&(xd->edx_md5_ictx));
		    MD5Update(&(xd->edx_md5_ictx), buffer, auth_keylen);
		    bzero(buffer, 
			  auth_keylen < blocklen ? blocklen : auth_keylen);
		    MD5Final(buffer, &(xd->edx_md5_ictx));
		    break;

		case ALG_AUTH_SHA1:
		    SHA1Init(&(xd->edx_sha1_ictx));
		    SHA1Update(&(xd->edx_sha1_ictx), buffer, auth_keylen);
		    bzero(buffer,
			  auth_keylen < blocklen ? blocklen : auth_keylen);
		    SHA1Final(buffer, &(xd->edx_sha1_ictx));
		    break;
	    }
d418 2
a419 12
	switch (xd->edx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		MD5Init(&(xd->edx_md5_ictx));
		MD5Update(&(xd->edx_md5_ictx), buffer, blocklen);
		break;

	    case ALG_AUTH_SHA1:
		SHA1Init(&(xd->edx_sha1_ictx));
		SHA1Update(&(xd->edx_sha1_ictx), buffer, blocklen);
		break;
	}
d424 2
a425 12
	switch (xd->edx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		MD5Init(&(xd->edx_md5_octx));
		MD5Update(&(xd->edx_md5_octx), buffer, blocklen);
		break;

	    case ALG_AUTH_SHA1:
		SHA1Init(&(xd->edx_sha1_octx));
		SHA1Update(&(xd->edx_sha1_octx), buffer, blocklen);
		break;
	}
d431 1
a431 1
    bzero(rk, 6 * sizeof(u_int32_t));		/* paranoid */
d454 1
a454 1
    u_char iv[ESP_3DES_IVS], niv[ESP_3DES_IVS], blk[ESP_3DES_BLKS], opts[40];
d462 4
a465 2
    MD5_CTX md5ctx;
    SHA1_CTX sha1ctx;
d470 1
a470 18
    switch (xd->edx_enc_algorithm)
    {
	case ALG_ENC_DES:
	    blks = ESP_DES_BLKS;
	    break;

	case ALG_ENC_3DES:
	    blks = ESP_3DES_BLKS;
	    break;

	default:
	    if (encdebug)
              log(LOG_ALERT,
                  "esp_new_input(): unsupported algorithm %d in SA %x/%08x\n",
                  xd->edx_enc_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
            m_freem(m);
            return NULL;
    }
d473 1
a473 15
    { 
	switch (xd->edx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
	    case ALG_AUTH_SHA1:
		alen = AH_HMAC_HASHLEN;
		break;

	    default:
		if (encdebug)
		  log(LOG_ALERT, "esp_new_input(): unsupported algorithm %d in SA %x/%08x\n", xd->edx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
		m_freem(m);
		return NULL;
	}
    } 
d567 1
a567 10
	switch (xd->edx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		md5ctx = xd->edx_md5_ictx;
		break;
	      
	    case ALG_AUTH_SHA1:
		sha1ctx = xd->edx_sha1_ictx;
		break;
	}
d581 1
a581 13
	    switch (xd->edx_hash_algorithm)
	    {
		case ALG_AUTH_MD5:
		    MD5Update(&md5ctx, mtod(mo, unsigned char *) + off, 
			      count);
		    break;

		case ALG_AUTH_SHA1:
		    SHA1Update(&sha1ctx, mtod(mo, unsigned char *) + off, 
			       count);
		    break;
	    }

d613 4
a616 16
	switch (xd->edx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		MD5Final(buf2, &md5ctx);
		md5ctx = xd->edx_md5_octx;
		MD5Update(&md5ctx, buf2, AH_MD5_ALEN);
		MD5Final(buf2, &md5ctx);
		break;

	    case ALG_AUTH_SHA1:
		SHA1Final(buf2, &sha1ctx);
		sha1ctx = xd->edx_sha1_octx;
		SHA1Update(&sha1ctx, buf2, AH_SHA1_ALEN);
		SHA1Final(buf2, &sha1ctx);
		break;
	}
d688 1
a688 12
	    switch (xd->edx_enc_algorithm)
	    {
		case ALG_ENC_DES:
	    	    des_ecb_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]), 0);
		    break;

		case ALG_ENC_3DES:
		    des_ecb3_encrypt(blk, blk, (caddr_t) (xd->edx_eks[2]),
                             	     (caddr_t) (xd->edx_eks[1]),
                             	     (caddr_t) (xd->edx_eks[0]), 0);
		    break;
	    }
d850 4
a853 2
    MD5_CTX md5ctx;
    SHA1_CTX sha1ctx;
d858 1
a858 18
    switch (xd->edx_enc_algorithm)
    {
        case ALG_ENC_DES:
            blks = ESP_DES_BLKS;
            break;

        case ALG_ENC_3DES:
            blks = ESP_3DES_BLKS;
            break;

        default:
	    if (encdebug)
              log(LOG_ALERT,
                  "esp_new_output(): unsupported algorithm %d in SA %x/%08x\n",
                  xd->edx_enc_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
            m_freem(m);
            return NULL;
    }
d862 1
a862 5
	switch (xd->edx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
	    case ALG_AUTH_SHA1:
		alen = AH_HMAC_HASHLEN;
d864 3
a866 3
		if (encdebug)
		  printf("esp_new_output(): using hash algorithm %d\n",
			 xd->edx_hash_algorithm);
a867 8
		break;

	    default:
		if (encdebug)
		  log(LOG_ALERT, "esp_new_output(): unsupported algorithm %d in SA %x/%08x\n", xd->edx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
		m_freem(m);
		return NULL;
	}
d979 3
a981 14
	switch (xd->edx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		md5ctx = xd->edx_md5_ictx;
		MD5Update(&md5ctx, (unsigned char *) &espo, 
			  2 * sizeof(u_int32_t) + xd->edx_ivlen);
		break;

	    case ALG_AUTH_SHA1:
		sha1ctx = xd->edx_sha1_ictx;
		SHA1Update(&sha1ctx, (unsigned char *) &espo, 
			   2 * sizeof(u_int32_t) + xd->edx_ivlen);
		break;
	}
d1005 1
a1005 12
	    switch (xd->edx_enc_algorithm)
	    {
		case ALG_ENC_DES:
	    	    des_ecb_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]), 1);
		    break;

		case ALG_ENC_3DES:
                    des_ecb3_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]),
                            	     (caddr_t) (xd->edx_eks[1]),
                             	     (caddr_t) (xd->edx_eks[2]), 1);
		    break;
	    }
d1008 1
a1008 10
	      switch (xd->edx_hash_algorithm)
	      {
		  case ALG_AUTH_MD5:
		      MD5Update(&md5ctx, blk, blks);
		      break;

		  case ALG_AUTH_SHA1:
		      SHA1Update(&sha1ctx, blk, blks);
		      break;
	      }
d1035 4
a1038 16
	switch (xd->edx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		MD5Final(auth, &md5ctx);
		md5ctx = xd->edx_md5_octx;
		MD5Update(&md5ctx, auth, AH_MD5_ALEN);
		MD5Final(auth, &md5ctx);
		break;

	    case ALG_AUTH_SHA1:
		SHA1Final(auth, &sha1ctx);
		sha1ctx = xd->edx_sha1_octx;
		SHA1Update(&sha1ctx, auth, AH_SHA1_ALEN);
		SHA1Final(auth, &sha1ctx);
		break;
	}
@


1.8
log
@do the 3-DES key setup right, will ya?
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.6 1997/09/28 22:57:47 deraadt Exp $	*/
d115 2
a116 1
	log(LOG_WARNING, "esp_new_init(): initialization failed\n");
d136 2
a137 1
            log(LOG_WARNING, "esp_new_init(): unsupported encryption algorithm %d specified\n", txd.edx_enc_algorithm);
d155 2
a156 1
              log(LOG_WARNING, "esp_new_init(): unsupported authentication algorithm %d specified\n", txd.edx_enc_algorithm);
d163 2
a164 2
	log(LOG_WARNING, "esp_new_init(): message length (%d) doesn't match\n",
	    em->em_msglen);
d173 3
a175 2
	       	log(LOG_WARNING, "esp_new_init(): unsupported IV length %d\n",
		    txd.edx_ivlen);
d181 3
a183 2
		log(LOG_WARNING, "esp_new_init(): bad key length\n",
		    txd.edx_keylen);
d193 3
a195 2
                log(LOG_WARNING, "esp_new_init(): unsupported IV length %d\n",
                    txd.edx_ivlen);
d201 3
a203 2
                log(LOG_WARNING, "esp_new_init(): bad key length\n",
                    txd.edx_keylen);
d400 4
a403 3
            log(LOG_ALERT,
                "esp_new_input(): unsupported algorithm %d in SA %x/%08x\n",
                xd->edx_enc_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d418 2
a419 2
		log(LOG_ALERT, "esp_new_input(): unsupported algorithm %d in SA %x/%08x\n", xd->edx_hash_algorithm, tdb->tdb_dst, 
		    ntohl(tdb->tdb_spi));
d483 2
a484 1
		    log(LOG_ERR, "esp_new_input(): replay counter wrapped for packets from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi));
d490 2
a491 1
		    log(LOG_WARNING, "esp_new_input(): duplicate packet received, %x->%x spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi));
d603 2
a604 2
	    log(LOG_ALERT,
		"esp_new_input(): authentication failed for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi));
d724 2
a725 1
	    log(LOG_ALERT, "esp_new_input(): decryption failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d736 2
a737 1
	    log(LOG_ALERT, "esp_new_input(): decryption failed for packet from %x to %x, SA %x/%08x -- peer is probably using old style padding\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d744 2
a745 1
              log(LOG_ALERT, "esp_new_input(): decryption failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d861 4
a864 3
            log(LOG_ALERT,
                "esp_new_output(): unsupported algorithm %d in SA %x/%08x\n",
                xd->edx_enc_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d884 2
a885 1
		log(LOG_ALERT, "esp_new_output(): unsupported algorithm %d in SA %x/%08x\n", xd->edx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d908 3
a910 2
        log(LOG_ALERT, "esp_new_output(): SA %x/%0x8 should have expired\n",
	    tdb->tdb_dst, ntohl(tdb->tdb_spi));
@


1.7
log
@brain dead sanity tests corrected
@
text
@d251 2
a252 2
	    des_set_key((caddr_t) rk + 2, (caddr_t) (xd->edx_eks[1]));
	    des_set_key((caddr_t) rk + 4, (caddr_t) (xd->edx_eks[2]));
@


1.6
log
@log() needs a \n
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.5 1997/09/24 18:39:40 angelos Exp $	*/
d712 1
a712 1
        if (blk[6] != blk[5])
d730 1
a730 1
	  if ((blk[6] == 0) || (blk[6] != blk[5] + 1))
@


1.5
log
@New style self-describing padding in use.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.4 1997/09/24 00:05:34 angelos Exp $	*/
d115 1
a115 1
	log(LOG_WARNING, "esp_new_init(): initialization failed");
d135 1
a135 1
            log(LOG_WARNING, "esp_new_init(): unsupported encryption algorithm %d specified", txd.edx_enc_algorithm);
d153 1
a153 1
              log(LOG_WARNING, "esp_new_init(): unsupported authentication algorithm %d specified", txd.edx_enc_algorithm);
d160 1
a160 1
	log(LOG_WARNING, "esp_new_init(): message length (%d) doesn't match",
d170 1
a170 1
	       	log(LOG_WARNING, "esp_new_init(): unsupported IV length %d",
d177 1
a177 1
		log(LOG_WARNING, "esp_new_init(): bad key length",
d188 1
a188 1
                log(LOG_WARNING, "esp_new_init(): unsupported IV length %d",
d195 1
a195 1
                log(LOG_WARNING, "esp_new_init(): bad key length",
d394 1
a394 1
                "esp_new_input(): unsupported algorithm %d in SA %x/%08x",
d410 1
a410 3
		log(LOG_ALERT,
		    "esp_new_input(): unsupported algorithm %d in SA %x/%08x",
		    xd->edx_hash_algorithm, tdb->tdb_dst, 
d481 1
a481 1
		    log(LOG_WARNING, "esp_new_input(): duplicate packet received, %x->%x spi %08x", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi));
d594 1
a594 1
		"esp_new_input(): authentication failed for packet from %x to %x, spi %08x", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi));
d849 1
a849 1
                "esp_new_output(): unsupported algorithm %d in SA %x/%08x",
d870 1
a870 3
		log(LOG_ALERT,
		    "esp_new_output(): unsupported algorithm %d in SA %x/%08x",
		    xd->edx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d893 1
a893 1
        log(LOG_ALERT, "esp_new_output(): SA %x/%0x8 should have expired",
@


1.4
log
@Cosmetic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.3 1997/09/23 21:42:21 angelos Exp $	*/
d709 1
d712 30
a741 1
    m_adj(m, - blk[6] - 2 - alen);
d762 5
a766 1
		  blk[6] - 2 - alen;
d780 1
a780 1
	                  blk[6] + 2 + alen;
d782 7
a788 1
                           blk[6] + 2 + alen;
d954 10
a963 2
    pad[padding-2] = padding - 2;
    pad[padding-1] = nh;
@


1.3
log
@AH changes, after interoperating at the ANX bakeoff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.2 1997/08/26 12:02:49 provos Exp $	*/
a182 1

a200 1

d496 1
a496 1
    if (plen & (blks -1))
d512 1
a512 1
		md5ctx = xd->edx_md5_ictx;;
a592 1

a694 1

d947 1
d1139 2
a1140 1
checkreplaywindow32(u_int32_t seq, u_int32_t initial, u_int32_t *lastseq, u_int32_t window, u_int32_t *bitmap)
@


1.2
log
@new esp: encryption, authentication and replay protection +
tiny bug fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.1 1997/07/11 23:37:57 provos Exp $	*/
d228 4
d240 3
a242 3
	     /* Copy the key material */
	     m_copydata(m, EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + xd->edx_ivlen,
			enc_keylen, (caddr_t) rk);
d244 2
a245 2
	     des_set_key((caddr_t) rk, (caddr_t) (xd->edx_eks[0]));
	     break;
d248 8
a255 8
	     /* Copy the key material */
	     m_copydata(m, EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + xd->edx_ivlen,
			enc_keylen, (caddr_t) rk);

	     des_set_key((caddr_t) rk, (caddr_t) (xd->edx_eks[0]));
	     des_set_key((caddr_t) rk + 2, (caddr_t) (xd->edx_eks[1]));
	     des_set_key((caddr_t) rk + 4, (caddr_t) (xd->edx_eks[2]));
	     break;
a257 5
    /* Replay counters are mandatory, even without auth */
    xd->edx_rpl = AH_HMAC_INITIAL_RPL;
    xd->edx_wnd = txd.edx_wnd;
    xd->edx_bitmap = 0;

d260 1
a260 1
	 auth_keylen = txd.edx_keylen - xd->edx_ivlen - enc_keylen;
a261 6
	 /* Or larger ? XXX */
	 MALLOC(buffer, caddr_t, 
		auth_keylen < blocklen ? blocklen : auth_keylen,
		M_TEMP, M_WAITOK);
	 if (buffer == NULL)
	 {
d263 13
a275 2
	      if (encdebug)
		   printf("esp_new_init(): MALLOC() failed\n");
d277 36
a312 32
	      free(tdbp->tdb_xdata, M_XDATA);
	      return ENOBUFS;
	 }

	 bzero(buffer, auth_keylen < blocklen ? blocklen : auth_keylen);

	 /* Copy the key to the buffer */
	 m_copydata(m, EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + xd->edx_ivlen +
		    enc_keylen, auth_keylen, buffer);

	 /* Shorten the key if necessary */
	 if (auth_keylen > blocklen)
	 {
	      switch (xd->edx_hash_algorithm)
	      {
	      case ALG_AUTH_MD5:
		   MD5Init(&(xd->edx_md5_ictx));
		   MD5Update(&(xd->edx_md5_ictx), buffer, auth_keylen);
		   bzero(buffer, 
			 auth_keylen < blocklen ? blocklen : auth_keylen);
		   MD5Final(buffer, &(xd->edx_md5_ictx));
		   break;

	      case ALG_AUTH_SHA1:
		   SHA1Init(&(xd->edx_sha1_ictx));
		   SHA1Update(&(xd->edx_sha1_ictx), buffer, auth_keylen);
		   bzero(buffer,
			 auth_keylen < blocklen ? blocklen : auth_keylen);
		   SHA1Final(buffer, &(xd->edx_sha1_ictx));
		   break;
	      }
	 }
d314 12
a325 16
	 /* Precompute the I and O pads of the HMAC */
	 for (i = 0; i < blocklen; i++)
	      buffer[i] ^= HMAC_IPAD_VAL;

	 switch (xd->edx_hash_algorithm)
	 {
	 case ALG_AUTH_MD5:
	      MD5Init(&(xd->edx_md5_ictx));
	      MD5Update(&(xd->edx_md5_ictx), buffer, blocklen);
	      break;

	 case ALG_AUTH_SHA1:
	      SHA1Init(&(xd->edx_sha1_ictx));
	      SHA1Update(&(xd->edx_sha1_ictx), buffer, blocklen);
	      break;
	 }
d327 2
a328 2
	 for (i = 0; i < blocklen; i++)
	      buffer[i] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);
d330 12
a341 12
	 switch (xd->edx_hash_algorithm)
	 {
	 case ALG_AUTH_MD5:
	      MD5Init(&(xd->edx_md5_octx));
	      MD5Update(&(xd->edx_md5_octx), buffer, blocklen);
	      break;

	 case ALG_AUTH_SHA1:
	      SHA1Init(&(xd->edx_sha1_octx));
	      SHA1Update(&(xd->edx_sha1_octx), buffer, blocklen);
	      break;
	 }
d343 2
a344 2
	 bzero(buffer, blocklen);
	 free(buffer, M_TEMP);
d404 18
a421 17
	 switch (xd->edx_hash_algorithm)
	 {
	 case ALG_AUTH_MD5:
	 case ALG_AUTH_SHA1:
	      alen = AH_HMAC_HASHLEN;
	      break;

	 default:
	      log(LOG_ALERT,
		  "esp_new_input(): unsupported algorithm %d in SA %x/%08x",
		  xd->edx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
	      m_freem(m);
	      return NULL;
	 }
    } else
	 alen = 0;
    
d496 1
a496 1
    plen = m->m_pkthdr.len - (ip->ip_hl << 2) - 2*sizeof (u_int32_t) - 
d511 5
a515 5
	 switch (xd->edx_hash_algorithm)
	 {
	 case ALG_AUTH_MD5:
	      md5ctx = xd->edx_md5_ictx;;
	      break;
d517 4
a520 14
	 case ALG_AUTH_SHA1:
	      sha1ctx = xd->edx_sha1_ictx;
	      break;
	 }

         /* Auth covers SPI + SN + IV*/
	 oplen = plen + 2*sizeof(u_int32_t) + xd->edx_ivlen; 
	 off = (ip->ip_hl << 2);

	 mo = m;
	 while (oplen > 0)
	 {
	      if (mo == 0)
		   panic("esp_new_input(): m_copydata (copy)");
d522 18
a539 1
	      count = min(mo->m_len - off, oplen);
d541 5
a545 10
	      switch (xd->edx_hash_algorithm)
	      {
	      case ALG_AUTH_MD5:
		   MD5Update(&md5ctx, mtod(mo, unsigned char *) + off, count);
		   break;

	      case ALG_AUTH_SHA1:
		   SHA1Update(&sha1ctx, mtod(mo, unsigned char *) + off, count);
		   break;
	      }
d547 26
a572 24
	      oplen -= count;
	      if (oplen == 0) 
	      {
		   /* Get the authentication data */
		   if (mo->m_len - off - count >= alen)
			bcopy(mtod(mo, unsigned char *) + off + count, buf, alen);
		   else 
		   {
			int olen = alen, tmp = 0;

			mi = mo;
			off += count;

			while (mi != NULL && olen > 0) {
			     count = min(mi->m_len - off, olen);
			     bcopy(mtod(mi, unsigned char *) + off, buf + tmp, count);

			     off = 0;
			     tmp += count;
			     olen -= count;
			     mi = mi->m_next;
			}
		   }
	      }
d574 30
a603 30
	      off = 0;
	      mo = mo->m_next;
	 }

	 switch (xd->edx_hash_algorithm)
	 {
	 case ALG_AUTH_MD5:
	      MD5Final(buf2, &md5ctx);
	      md5ctx = xd->edx_md5_octx;
	      MD5Update(&md5ctx, buf2, AH_MD5_ALEN);
	      MD5Final(buf2, &md5ctx);
	      break;

	 case ALG_AUTH_SHA1:
	      SHA1Final(buf2, &sha1ctx);
	      sha1ctx = xd->edx_sha1_octx;
	      SHA1Update(&sha1ctx, buf2, AH_SHA1_ALEN);
	      SHA1Final(buf2, &sha1ctx);
	      break;
	 }


	 if (bcmp(buf2, buf, AH_HMAC_HASHLEN))
	 {
	      log(LOG_ALERT,
		  "esp_new_input(): authentication failed for packet from %x to %x, spi %08x", ip->ip_src, ip->ip_dst, ntohl(esp->esp_spi));
	      espstat.esps_badauth++;
	      m_freem(m);
	      return NULL;
	 }
d607 2
a608 2
    ilen = m->m_len - (ip->ip_hl << 2) - 2*sizeof(u_int32_t);
    idat = mtod(m, unsigned char *) + (ip->ip_hl << 2) + 2*sizeof(u_int32_t);
d612 5
a616 5
	 bcopy((u_char *)&esp->esp_rpl, iv, sizeof(esp->esp_rpl));
	 iv[4] = ~iv[0];
	 iv[5] = ~iv[1];
	 iv[6] = ~iv[2];
	 iv[7] = ~iv[3];
d620 3
a622 3
	 bcopy(idat, iv, xd->edx_ivlen);
	 ilen -= xd->edx_ivlen;
	 idat += xd->edx_ivlen;
d624 1
a624 1

d657 1
a657 1
	    idat = (u_char *)mi->m_data;
a703 1

d716 1
a716 1
    m_adj(m, 2*sizeof(u_int32_t) + xd->edx_ivlen);
d735 1
a735 1
    ipo.ip_len += (ipo.ip_hl << 2) -  2*sizeof(u_int32_t) - xd->edx_ivlen -
d788 1
a788 1
		 struct mbuf **mp)
d823 5
a827 5
	 switch (xd->edx_hash_algorithm)
	 {
	 case ALG_AUTH_MD5:
	 case ALG_AUTH_SHA1:
	      alen = AH_HMAC_HASHLEN;
d829 3
a831 3
	      if (encdebug)
		   printf("esp_new_output(): using hash algorithm %d\n",
			  xd->edx_hash_algorithm);
d833 1
a833 1
	      break;
d835 10
a844 9
	 default:
	      log(LOG_ALERT,
		  "esp_new_output(): unsupported algorithm %d in SA %x/%08x",
		  xd->edx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
	      m_freem(m);
	      return NULL;
	 }
    } else
	 alen = 0;
d852 3
a854 3
	 if (encdebug)
	      printf("esp_new_output(): m_pullup() failed, SA %x/%08x\n",
		     tdb->tdb_dst, ntohl(tdb->tdb_spi));
d856 1
a856 1
	 return ENOBUFS;
d883 3
a885 3
	     if (encdebug)
		  printf("esp_new_input(): m_pullup() failed for SA %x/%08x\n",
			 tdb->tdb_dst, ntohl(tdb->tdb_spi));
d887 1
a887 1
	     return ENOBUFS;
d898 1
a898 1
    ohlen = 2*sizeof (u_int32_t) + xd->edx_ivlen;
d929 7
a935 6
	 bcopy((u_char *)&espo.esp_rpl, iv, 4);
	 iv[4] = ~iv[0];
	 iv[5] = ~iv[1];
	 iv[6] = ~iv[2];
	 iv[7] = ~iv[3];
    } else
d937 2
a938 2
	 bcopy(xd->edx_iv, iv, xd->edx_ivlen);
	 bcopy(xd->edx_iv, espo.esp_iv, xd->edx_ivlen);
d944 13
a956 13
	 switch (xd->edx_hash_algorithm)
	 {
	 case ALG_AUTH_MD5:
	      md5ctx = xd->edx_md5_ictx;
	      MD5Update(&md5ctx, (unsigned char *)&espo, 
			2*sizeof(u_int32_t) + xd->edx_ivlen);
	      break;
	 case ALG_AUTH_SHA1:
	      sha1ctx = xd->edx_sha1_ictx;
	      SHA1Update(&sha1ctx, (unsigned char *)&espo, 
			 2*sizeof(u_int32_t) + xd->edx_ivlen);
	      break;
	 }
d970 1
a970 1
	    idat = (u_char *)mi->m_data;
d994 3
a996 3
		 switch (xd->edx_hash_algorithm)
		 {
		 case ALG_AUTH_MD5:
d999 2
a1000 1
		 case ALG_AUTH_SHA1:
d1003 1
a1003 1
		 }
d1030 19
a1048 17
	 switch (xd->edx_hash_algorithm)
	 {
	 case ALG_AUTH_MD5:
	      MD5Final(auth, &md5ctx);
	      md5ctx = xd->edx_md5_octx;
	      MD5Update(&md5ctx, auth, AH_MD5_ALEN);
	      MD5Final(auth, &md5ctx);
	      break;
	 case ALG_AUTH_SHA1:
	      SHA1Final(auth, &sha1ctx);
	      sha1ctx = xd->edx_sha1_octx;
	      SHA1Update(&sha1ctx, auth, AH_SHA1_ALEN);
	      SHA1Final(auth, &sha1ctx);
	      break;
	 }
	 /* Copy the final authenticator */
	 bcopy(auth, pad+padding, alen);
d1161 1
d1173 1
@


1.1
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_new.c,v 1.11 1997/07/01 22:12:49 provos Exp $	*/
d27 2
a28 1
 * Based on draft-ietf-ipsec-esp-des-md5-03.txt.
d61 1
d64 1
d69 5
d79 1
a79 1
      printf("ah_new_attach(): setting up\n");
a92 1
#if 0
d97 2
d113 1
a113 1
    if (em->em_msglen - EMT_SETSPI <= ESP_NEW_XENCAP_LEN)
d122 1
a122 1
    /* Check wether the encryption algorithm is supported */
d139 1
a139 1
    /* Check whether the encryption algorithm is supported */
d147 1
a147 1
                printf("esp_new_init(): initialized TDB with hash algorithm %d\n", txd.edx_enc_algorithm);
d149 1
d153 1
a153 1
              log(LOG_WARNING, "esp_old_init(): unsupported encryption algorithm %d specified", txd.edx_enc_algorithm);
d165 40
a204 1
    /* XXX Check the IV lengths */
a216 13
    /* Or larger ? XXX */
    MALLOC(buffer, caddr_t, txd.edx_keylen, M_TEMP, M_WAITOK);
    if (buffer == NULL)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_init(): MALLOC() failed\n");
#endif /* ENCDEBUG */
	free(tdbp->tdb_xdata, M_XDATA);
	return ENOBUFS;
    }

    bzero(buffer, txd.edx_keylen);
a222 1
#if 0
d224 1
d226 2
d229 5
a233 4
    /* Fix the IV */
    if (txd.edx_ivlen)
      bcopy(txd.edx_ivv, xd->edx_iv, ESPDESMD5_IVS);
    else
d235 18
a252 21
	for (len = 0; len < ESPDESMD5_KEYSZ; len++)
	  buf[len] = txd.edx_initiator ? ESPDESMD5_IPADI :
		   ESPDESMD5_IPADR;

	MD5Init(&ctx);
	MD5Update(&ctx, buf, ESPDESMD5_KEYSZ);
	MD5Update(&ctx, txd.edx_key, txd.edx_keylen);
	MD5Final(buf, &ctx);
	bcopy(buf, xd->edx_iv, ESPDESMD5_IVS);
    }

    /* DES key */

    MD5Init(&ctx);
    for (len = 0; len < ESPDESMD5_KEYSZ; len++)
      buf[len] = txd.edx_initiator ? ESPDESMD5_DPADI : ESPDESMD5_DPADR;
	 
    MD5Update(&ctx, buf, ESPDESMD5_KEYSZ);
    MD5Update(&ctx, txd.edx_key, txd.edx_keylen);
    MD5Final(buf, &ctx);
    des_set_key((caddr_t)buf, (caddr_t)(xd->edx_eks));
d254 4
a257 1
    /* HMAC contexts */
d259 3
a261 3
    MD5Init(&ctx);
    for (len = 0; len < ESPDESMD5_KEYSZ; len++)
      buf[len] = txd.edx_initiator ? ESPDESMD5_HPADI : ESPDESMD5_HPADR;
d263 62
a324 3
    MD5Update(&ctx, buf, ESPDESMD5_KEYSZ);
    MD5Update(&ctx, txd.edx_key, txd.edx_keylen);
    MD5Final(buf, &ctx);
d326 12
a337 1
    bzero(buf + ESPDESMD5_ALEN, ESPDESMD5_KEYSZ - ESPDESMD5_ALEN);
d339 3
a341 2
    for (len = 0; len < ESPDESMD5_KEYSZ; len++)
      buf[len] ^= ESPDESMD5_IPAD_VAL;
d343 2
a344 12
    MD5Init(&ctx);
    MD5Update(&ctx, buf, ESPDESMD5_KEYSZ);
    xd->edx_ictx = ctx;

    for (len = 0; len < ESPDESMD5_KEYSZ; len++)
      buf[len] ^= (ESPDESMD5_IPAD_VAL ^ ESPDESMD5_OPAD_VAL);

    MD5Init(&ctx);
    MD5Update(&ctx, buf, ESPDESMD5_KEYSZ);
    xd->edx_octx = ctx;
	
    /* Replay counter */
a345 19
    for (len = 0; len < ESPDESMD5_KEYSZ; len++)
      buf[len] = txd.edx_initiator ? ESPDESMD5_RPADI : 
	ESPDESMD5_RPADR;

    MD5Init(&ctx);
    MD5Update(&ctx, buf, ESPDESMD5_KEYSZ);
    MD5Update(&ctx, txd.edx_key, txd.edx_keylen);
    MD5Final(buf, &ctx);
    bcopy(buf, (unsigned char *)&(xd->edx_rpl), ESPDESMD5_RPLENGTH);
    xd->edx_initial = xd->edx_rpl - 1;

    bzero(&ctx, sizeof(MD5_CTX));

    bzero(buffer, txd.edx_keylen); /* fix XXX */
    free(buffer, M_TEMP);
#endif
    
    bzero(ipseczeroes, IPSEC_ZEROES_SIZE);	/* paranoid */
#endif
a363 1
#if 0
d366 1
a366 2
    u_char iv[8], niv[8], blk[8], auth[ESPDESMD5_ALEN];
    u_char iauth[ESPDESMD5_ALEN];
d368 1
a368 1
    struct esp *esp;
d370 3
a372 3
    int plen, ilen, olen, i, authp, oplen, errc;
    u_int32_t rplc, tbitmap, trpl;
    u_char padsize, nextproto;
d374 3
a376 1
    MD5_CTX ctx;
d380 38
d428 13
d442 20
a462 1
    esp = (struct esp *)(ip + 1);
d464 30
a493 3
    plen = m->m_pkthdr.len - sizeof (struct ip) - sizeof (u_int32_t) - 
	   xd->edx_ivlen;
    if (plen & 07)
d497 1
a497 1
	  printf("esp_new_input(): payload not a multiple of 8 octets\n");
d504 93
d598 10
a607 9
    ilen = m->m_len - sizeof (struct ip) - ESPDESMD5_IVS - sizeof(u_int32_t);
    idat = mtod(m, unsigned char *) + sizeof (struct ip) + sizeof(u_int32_t) +
	   ESPDESMD5_IVS;

    if (xd->edx_ivlen == 0)		/* KeyIV in use */
    {
	bcopy(xd->edx_iv, iv, ESPDESMD5_IVS);
	ilen += ESPDESMD5_IVS;
	idat -= ESPDESMD5_IVS;
d610 5
a614 1
      bcopy(idat - ESPDESMD5_IVS, iv, ESPDESMD5_IVS);
a619 6
    authp = 0;

    ctx = xd->edx_ictx;

    MD5Update(&ctx, (unsigned char *)&(tdb->tdb_spi), sizeof(u_int32_t));
    MD5Update(&ctx, iv, ESPDESMD5_IVS);
d646 1
d655 1
a655 1
	if (i == 8)
d657 13
a669 1
	    des_ecb_encrypt(blk, blk, (caddr_t)(xd->edx_eks), 0);
d677 1
d681 1
d687 1
a689 48
	    if (plen < ESPDESMD5_ALEN)
	    {
		bcopy(blk, auth + authp, ESPDESMD5_DESBLK);
		authp += ESPDESMD5_DESBLK;
	    }
	    else
	    {
		if (plen == ESPDESMD5_ALEN + 1)
		{
		    nextproto = blk[7];
		    padsize = blk[6];
		}
		else
		  if (plen + 7 == oplen)
		  {
		      tbitmap = xd->edx_bitmap; /* Save it */
		      trpl = xd->edx_rpl;
		      rplc = ntohl(*((u_int32_t *)blk));
		      if ((errc = checkreplaywindow32(rplc, xd->edx_initial, &(xd->edx_rpl), xd->edx_wnd, &(xd->edx_bitmap))) != 0)
		      {
			  switch (errc)
			  {
			      case 1:
#ifdef ENCDEBUG
				  printf("esp_new_input: replay counter wrapped\n");
#endif
				  espstat.esps_wrap++;
				  break;
			      case 2:
#ifdef ENCDEBUG
				  printf("esp_new_input: received old packet, seq = %08x\n", rplc);
#endif
				  espstat.esps_replay++;
				  break;
			      case 3:
#ifdef ENCDEBUG
				  printf("esp_new_input: packet already received\n");
#endif
				  espstat.esps_replay++;
				  break;
			  }
			  m_freem(m);
			  return NULL;
		      }
		  }

		MD5Update(&ctx, blk, ESPDESMD5_DESBLK);
	    }
d695 5
d701 4
a704 1
     * Now, the entire chain has been decrypted.
d707 2
a708 20
    MD5Final(iauth, &ctx);
    ctx = xd->edx_octx;
    MD5Update(&ctx, iauth, ESPDESMD5_ALEN);
    MD5Final(iauth, &ctx);

    if (bcmp(auth, iauth, ESPDESMD5_ALEN))
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_input: bad auth\n");
#endif
	xd->edx_rpl = trpl;
	xd->edx_bitmap = tbitmap;  /* Restore */
	espstat.esps_badauth++;
	m_freem(m);
	return NULL;
    }

    m_adj(m, - padsize - 2 - 234893289);
    m_adj(m, 4 + xd->edx_ivlen + ESPDESMD5_RPLENGTH);
d710 1
a710 1
    if (m->m_len < sizeof (struct ip))
d712 1
a712 1
	m = m_pullup(m, sizeof (struct ip));
d715 4
a718 2
	    xd->edx_rpl = trpl;
	    xd->edx_bitmap = tbitmap;
d724 1
a724 1
    ipo.ip_p = nextproto;
d727 2
a728 2
    ipo.ip_len += sizeof (struct ip) - ESPDESMD5_RPLENGTH - 4 - xd->edx_ivlen -
		  padsize - 2 - ESPDESMD5_ALEN;
d732 6
a737 1
    ip->ip_sum = in_cksum(m, sizeof (struct ip));
d741 33
a773 2
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) + padsize +
		          2 + ESPDESMD5_ALEN;
a774 1
#endif
a781 1
#if 0
d785 2
a786 3
    u_int32_t rplc;
    u_int32_t spi;
    struct mbuf *mi, *mo, *ms;
d788 4
a791 3
    u_char iv[ESPDESMD5_IVS], blk[8], auth[ESPDESMD5_ALEN], opts[40];
    MD5_CTX ctx;
    int iphlen;
d793 44
d838 1
d841 20
a860 1
      return ENOBUFS;
d863 1
a863 2
    spi = tdb->tdb_spi;
    iphlen = ip->ip_hl << 2;
d866 1
a866 2
     * If options are present, pullup the IP header, the options
     * and one DES block (8 bytes) of data.
d872 8
a879 1
	  return ENOBUFS;
d884 2
a885 2
	bcopy(mtod(m, u_char *) + sizeof(struct ip), opts,
	      iphlen - sizeof(struct ip));
a887 1
    xd = (struct esp_new_xdata *)tdb->tdb_xdata;
d889 1
a889 1
    ohlen = sizeof (u_int32_t) + xd->edx_ivlen; /* size of plaintext ESP */
a890 10
    if (xd->edx_rpl == xd->edx_initial)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_new_output: replay counter wrapped\n");
#endif
	espstat.esps_wrap++;
	return EHOSTDOWN;   /* XXX */
    }
	
d895 2
a896 3
    rlen = ESPDESMD5_RPLENGTH + ilen - iphlen; 

    padding = ((8 - ((rlen + 2) % 8)) % 8) + 2;
d898 1
a898 1
    pad = (u_char *)m_pad(m, padding);
d900 8
a907 1
      return ENOBUFS;
d912 5
a916 1
    plen = rlen + padding + ESPDESMD5_ALEN;
d918 8
a925 14
    ctx = xd->edx_ictx;  /* Get inner padding cached */

    bcopy(xd->edx_iv, iv, ESPDESMD5_IVS);

    MD5Update(&ctx, (u_char *)&spi, sizeof(u_int32_t));
    MD5Update(&ctx, iv, ESPDESMD5_IVS);
    rplc = htonl(xd->edx_rpl);
    MD5Update(&ctx, (unsigned char *)&rplc, ESPDESMD5_RPLENGTH);
    xd->edx_rpl++;

    mi = m;

    /* MD5 the data */
    while (mi != NULL)
d927 2
a928 6
	if (mi == m)
	  MD5Update(&ctx, (u_char *)mi->m_data + iphlen,
		    mi->m_len - iphlen);
	else
	  MD5Update(&ctx, (u_char *)mi->m_data, mi->m_len);
	mi = mi->m_next;
d931 2
a932 17
    MD5Final(auth, &ctx);
    ctx = xd->edx_octx;
    MD5Update(&ctx, auth, ESPDESMD5_ALEN);
    MD5Final(auth, &ctx);   /* That's the authenticator */

    /* 
     * This routine is different from espdes_output() in that
     * here we construct the whole packet before starting encrypting.
     */

    m = m_pullup(m, iphlen + ESPDESMD5_RPLENGTH + 
		 sizeof(u_int32_t) + xd->edx_ivlen);
    if (m == NULL)
      return ENOBUFS;

    /* Copy data if necessary */
    if (m->m_len - iphlen)
d934 13
a946 7
	ms = m_copym(m, iphlen, m->m_len - iphlen, M_DONTWAIT);
	if (ms == NULL)
	  return ENOBUFS;
	
	ms->m_next = m->m_next;
	m->m_next = ms;
	m->m_len = iphlen;
a947 17
	
    /* Copy SPI, IV (or not) and replay counter */
    bcopy((caddr_t)&spi, mtod(m, caddr_t) + iphlen, sizeof (u_int32_t));
    bcopy((caddr_t)iv,  mtod(m, caddr_t) + iphlen + sizeof (u_int32_t),
	  xd->edx_ivlen);
    bcopy((caddr_t)&rplc, mtod(m, caddr_t) + iphlen + sizeof(u_int32_t) +
	  xd->edx_ivlen, ESPDESMD5_RPLENGTH);

    /* Adjust the length accordingly */
    m->m_len += sizeof(u_int32_t) + ESPDESMD5_RPLENGTH + xd->edx_ivlen;
    m->m_pkthdr.len += sizeof(u_int32_t) + ESPDESMD5_RPLENGTH + 
		       xd->edx_ivlen;

    /* Let's append the authenticator too */
    MGET(ms, M_DONTWAIT, MT_DATA);
    if (ms == NULL)
      return ENOBUFS;
d949 1
a949 11
    bcopy(auth, mtod(ms, u_char *), ESPDESMD5_ALEN);
    ms->m_len = ESPDESMD5_ALEN;

    m_cat(m, ms);
    m->m_pkthdr.len += ESPDESMD5_ALEN;  /* Adjust length */
	
    ilen = olen = m->m_len - iphlen - sizeof(u_int32_t) - xd->edx_ivlen;
    idat = odat = mtod(m, u_char *) + iphlen + sizeof(u_int32_t) 
	   + xd->edx_ivlen;
    i = 0;
    mi = mo = m;
d958 1
d968 1
a968 1
	if (i == 8)   /* We have full block */
d970 25
a994 2
	    des_ecb_encrypt(blk, blk, (caddr_t)(xd->edx_eks), 1);
	    for (i = 0; i < 8; i++)
d1001 1
d1005 1
d1016 48
a1063 2
    if (xd->edx_ivlen != 0)
      bcopy(iv, xd->edx_iv, ESPDESMD5_IVS); /* New IV */
d1066 1
a1066 2
    ipo.ip_len = htons(iphlen + ohlen + rlen + padding +
		       ESPDESMD5_ALEN);
d1068 13
a1080 1
    bcopy((caddr_t)&ipo, mtod(m, caddr_t), sizeof(struct ip));
d1082 2
a1083 5
    /* Copy back the options, if existing */
    if (iphlen != sizeof(struct ip))
      bcopy(opts, mtod(m, caddr_t) + sizeof(struct ip),
	    iphlen - sizeof(struct ip));
    
d1087 30
a1117 2
    *mp = m;
#endif
@

