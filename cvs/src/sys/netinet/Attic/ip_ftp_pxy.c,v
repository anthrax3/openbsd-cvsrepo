head	1.15;
access;
symbols
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	UBC_SYNC_A:1.15
	UBC_SYNC_B:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.15
date	2001.05.30.02.12.31;	author deraadt;	state dead;
branches;
next	1.14;

1.14
date	2001.05.08.19.58.01;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.17.22.54.20;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.17.04.47.14;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.10.05.50.26;	author kjell;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.12.21.32.39;	author kjell;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.05.05.35.27;	author kjell;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.13.23.40.18;	author kjell;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.16.22.34.19;	author kjell;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.01.19.29.58;	author kjell;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.12.15.05.20.22;	author kjell;	state Exp;
branches;
next	1.4;

1.4
date	99.02.05.05.58.52;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.09.15.09.51.18;	author pattonme;	state Exp;
branches;
next	1.2;

1.2
date	98.02.17.01.39.04;	author dgregor;	state Exp;
branches;
next	1.1;

1.1
date	98.01.26.04.10.42;	author dgregor;	state Exp;
branches;
next	;

1.6.2.1
date	2000.02.20.11.57.26;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.05.14.22.40.10;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.07.04.10.54.47;	author niklas;	state dead;
branches;
next	;


desc
@@


1.15
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ip_ftp_pxy.c,v 1.14 2001/05/08 19:58:01 fgsch Exp $	*/

/*
 * Simple FTP transparent proxy for in-kernel use.  For use with the NAT
 * code.
 *
 * $IPFilter: ip_ftp_pxy.c,v 2.7.2.21 2001/01/17 13:30:52 darrenr Exp $
 */
#if SOLARIS && defined(_KERNEL)
extern	kmutex_t	ipf_rw;
#endif

#define	isdigit(x)	((x) >= '0' && (x) <= '9')
#define	isupper(x)	(((unsigned)(x) >= 'A') && ((unsigned)(x) <= 'Z'))
#define	islower(x)	(((unsigned)(x) >= 'a') && ((unsigned)(x) <= 'z'))
#define	isalpha(x)	(isupper(x) || islower(x))
#define	toupper(x)	(isupper(x) ? (x) : (x) - 'a' + 'A')

#define	IPF_FTP_PROXY

#define	IPF_MINPORTLEN	18
#define	IPF_MAXPORTLEN	30
#define	IPF_MIN227LEN	39
#define	IPF_MAX227LEN	51
#define	IPF_FTPBUFSZ	96	/* This *MUST* be >= 53! */


int ippr_ftp_client __P((fr_info_t *, ip_t *, nat_t *, ftpinfo_t *, int));
int ippr_ftp_complete __P((char *, size_t));
int ippr_ftp_in __P((fr_info_t *, ip_t *, ap_session_t *, nat_t *));
int ippr_ftp_init __P((void));
int ippr_ftp_new __P((fr_info_t *, ip_t *, ap_session_t *, nat_t *));
int ippr_ftp_out __P((fr_info_t *, ip_t *, ap_session_t *, nat_t *));
int ippr_ftp_pasv __P((fr_info_t *, ip_t *, nat_t *, ftpside_t *, int));
int ippr_ftp_port __P((fr_info_t *, ip_t *, nat_t *, ftpside_t *, int));
int ippr_ftp_process __P((fr_info_t *, ip_t *, nat_t *, ftpinfo_t *, int));
int ippr_ftp_server __P((fr_info_t *, ip_t *, nat_t *, ftpinfo_t *, int));
int ippr_ftp_valid __P((char *, size_t));
u_short ippr_ftp_atoi __P((char **));

static	frentry_t	natfr;
int	ippr_ftp_pasvonly = 0;
int	ippr_ftp_insecure = 0;


/*
 * Initialize local structures.
 */
int ippr_ftp_init()
{
	bzero((char *)&natfr, sizeof(natfr));
	natfr.fr_ref = 1;
	natfr.fr_flags = FR_INQUE|FR_PASS|FR_QUICK|FR_KEEPSTATE;
	return 0;
}


int ippr_ftp_new(fin, ip, aps, nat)
fr_info_t *fin;
ip_t *ip;
ap_session_t *aps;
nat_t *nat;
{
	ftpinfo_t *ftp;
	ftpside_t *f;

	KMALLOC(ftp, ftpinfo_t *);
	if (ftp == NULL)
		return -1;
	aps->aps_data = ftp;
	aps->aps_psiz = sizeof(ftpinfo_t);

	bzero((char *)ftp, sizeof(*ftp));
	f = &ftp->ftp_side[0];
	f->ftps_rptr = f->ftps_buf;
	f->ftps_wptr = f->ftps_buf;
	f = &ftp->ftp_side[1];
	f->ftps_rptr = f->ftps_buf;
	f->ftps_wptr = f->ftps_buf;
	return 0;
}


int ippr_ftp_port(fin, ip, nat, f, dlen)
fr_info_t *fin;
ip_t *ip;
nat_t *nat;
ftpside_t *f;
int dlen;
{
	tcphdr_t *tcp, tcph, *tcp2 = &tcph;
	char newbuf[IPF_FTPBUFSZ], *s;
	u_short a5, a6, sp, dp;
	u_int a1, a2, a3, a4;
	struct in_addr swip;
	size_t nlen, olen;
	fr_info_t fi;
	int inc, off;
	nat_t *ipn;
	mb_t *m;
#if	SOLARIS
	mb_t *m1;
#endif

	tcp = (tcphdr_t *)fin->fin_dp;
	/*
	 * Check for client sending out PORT message.
	 */
	if (dlen < IPF_MINPORTLEN)
		return 0;
	off = fin->fin_hlen + (tcp->th_off << 2);
	/*
	 * Skip the PORT command + space
	 */
	s = f->ftps_rptr + 5;
	/*
	 * Pick out the address components, two at a time.
	 */
	a1 = ippr_ftp_atoi(&s);
	if (!s)
		return 0;
	a2 = ippr_ftp_atoi(&s);
	if (!s)
		return 0;
	/*
	 * check that IP address in the PORT/PASV reply is the same as the
	 * sender of the command - prevents using PORT for port scanning.
	 */
	a1 <<= 16;
	a1 |= a2;
	if (a1 != ntohl(nat->nat_inip.s_addr))
		return 0;

	a5 = ippr_ftp_atoi(&s);
	if (!s)
		return 0;
	if (*s == ')')
		s++;

	/*
	 * check for CR-LF at the end.
	 */
	if (*s == '\n')
		s--;
	if ((*s == '\r') && (*(s + 1) == '\n')) {
		s += 2;
		a6 = a5 & 0xff;
	} else
		return 0;
	a5 >>= 8;
	a5 &= 0xff;
	/*
	 * Calculate new address parts for PORT command
	 */
	a1 = ntohl(ip->ip_src.s_addr);
	a2 = (a1 >> 16) & 0xff;
	a3 = (a1 >> 8) & 0xff;
	a4 = a1 & 0xff;
	a1 >>= 24;
	olen = s - f->ftps_rptr;
	/* DO NOT change this to sprintf! */
	(void) sprintf(newbuf, "%s %u,%u,%u,%u,%u,%u\r\n",
		       "PORT", a1, a2, a3, a4, a5, a6);

	nlen = strlen(newbuf);
	inc = nlen - olen;
	if ((inc + ip->ip_len) > 65535)
		return 0;

#if SOLARIS
	m = fin->fin_qfm;
	for (m1 = m; m1->b_cont; m1 = m1->b_cont)
		;
	if ((inc > 0) && (m1->b_datap->db_lim - m1->b_wptr < inc)) {
		mblk_t *nm;

		/* alloc enough to keep same trailer space for lower driver */
		nm = allocb(nlen, BPRI_MED);
		PANIC((!nm),("ippr_ftp_out: allocb failed"));

		nm->b_band = m1->b_band;
		nm->b_wptr += nlen;

		m1->b_wptr -= olen;
		PANIC((m1->b_wptr < m1->b_rptr),
		      ("ippr_ftp_out: cannot handle fragmented data block"));

		linkb(m1, nm);
	} else {
		if (m1->b_datap->db_struiolim == m1->b_wptr)
			m1->b_datap->db_struiolim += inc;
		m1->b_datap->db_struioflag &= ~STRUIO_IP;
		m1->b_wptr += inc;
	}
	copyin_mblk(m, off, nlen, newbuf);
#else
	m = *((mb_t **)fin->fin_mp);
	if (inc < 0)
		m_adj(m, inc);
	/* the mbuf chain will be extended if necessary by m_copyback() */
	m_copyback(m, off, nlen, newbuf);
# ifdef	M_PKTHDR
	if (!(m->m_flags & M_PKTHDR))
		m->m_pkthdr.len += inc;
# endif
#endif
	if (inc != 0) {
#if SOLARIS || defined(__sgi)
		register u_32_t	sum1, sum2;

		sum1 = ip->ip_len;
		sum2 = ip->ip_len + inc;

		/* Because ~1 == -2, We really need ~1 == -1 */
		if (sum1 > sum2)
			sum2--;
		sum2 -= sum1;
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);

		fix_outcksum(&ip->ip_sum, sum2);
#endif
		ip->ip_len += inc;
	}

	/*
	 * Add skeleton NAT entry for connection which will come back the
	 * other way.
	 */
	sp = htons(a5 << 8 | a6);
	/*
	 * Don't allow the PORT command to specify a port < 1024 due to
	 * security crap.
	 */
	if (ntohs(sp) < 1024)
		return 0;
	/*
	 * The server may not make the connection back from port 20, but
	 * it is the most likely so use it here to check for a conflicting
	 * mapping.
	 */
	dp = htons(fin->fin_data[1] - 1);
	ipn = nat_outlookup(fin->fin_ifp, IPN_TCP, nat->nat_p, nat->nat_inip,
			    ip->ip_dst, (dp << 16) | sp, 0);
	if (ipn == NULL) {
		int slen;

		slen = ip->ip_len;
		ip->ip_len = fin->fin_hlen + sizeof(*tcp2);
		bcopy((char *)fin, (char *)&fi, sizeof(fi));
		bzero((char *)tcp2, sizeof(*tcp2));
		tcp2->th_win = htons(8192);
		tcp2->th_sport = sp;
		tcp2->th_off = 5;
		tcp2->th_dport = 0; /* XXX - don't specify remote port */
		fi.fin_data[0] = ntohs(sp);
		fi.fin_data[1] = 0;
		fi.fin_dlen = sizeof(*tcp2);
		fi.fin_dp = (char *)tcp2;
		fi.fin_fr = &natfr;
		swip = ip->ip_src;
		fi.fin_fi.fi_saddr = nat->nat_inip.s_addr;
		ip->ip_src = nat->nat_inip;
		ipn = nat_new(nat->nat_ptr, ip, &fi, IPN_TCP|FI_W_DPORT,
			      NAT_OUTBOUND);
		if (ipn != NULL) {
			ipn->nat_age = fr_defnatage;
			(void) fr_addstate(ip, &fi, FI_W_DPORT);
		}
		ip->ip_len = slen;
		ip->ip_src = swip;
	}
	return APR_INC(inc);
}


int ippr_ftp_client(fin, ip, nat, ftp, dlen)
fr_info_t *fin;
nat_t *nat;
ftpinfo_t *ftp;
ip_t *ip;
int dlen;
{
	char *rptr, *wptr, cmd[6], c;
	ftpside_t *f;
	int inc, i;

	inc = 0;
	f = &ftp->ftp_side[0];
	rptr = f->ftps_rptr;
	wptr = f->ftps_wptr;

	for (i = 0; (i < 5) && (i < dlen); i++) {
		c = rptr[i];
		if (isalpha(c)) {
			cmd[i] = toupper(c);
		} else {
			cmd[i] = c;
		}
	}
	cmd[i] = '\0';

	if ((ftp->ftp_passok == 0) && !strncmp(cmd, "USER ", 5))
		 ftp->ftp_passok = 1;
	else if ((ftp->ftp_passok == 2) && !strncmp(cmd, "PASS ", 5))
		 ftp->ftp_passok = 3;
	else if ((ftp->ftp_passok == 4) && !ippr_ftp_pasvonly &&
		 !strncmp(cmd, "PORT ", 5)) {
		inc = ippr_ftp_port(fin, ip, nat, f, dlen);
	} else if (ippr_ftp_insecure && !ippr_ftp_pasvonly &&
		   !strncmp(cmd, "PORT ", 5)) {
		inc = ippr_ftp_port(fin, ip, nat, f, dlen);
	}

	while ((*rptr++ != '\n') && (rptr < wptr))
		;
	f->ftps_rptr = rptr;
	return inc;
}


int ippr_ftp_pasv(fin, ip, nat, f, dlen)
fr_info_t *fin;
ip_t *ip;
nat_t *nat;
ftpside_t *f;
int dlen;
{
	tcphdr_t *tcp, tcph, *tcp2 = &tcph;
	struct in_addr swip, swip2;
	u_short a5, a6, sp, dp;
	u_int a1, a2, a3, a4;
	fr_info_t fi;
	nat_t *ipn;
	int inc;
	char *s;

	/*
	 * Check for PASV reply message.
	 */
	if (dlen < IPF_MIN227LEN)
		return 0;
	else if (strncmp(f->ftps_rptr, "227 Entering Passive Mode", 25))
		return 0;

	tcp = (tcphdr_t *)fin->fin_dp;

	/*
	 * Skip the PORT command + space
	 */
	s = f->ftps_rptr + 25;
	while (*s && !isdigit(*s))
		s++;
	/*
	 * Pick out the address components, two at a time.
	 */
	a1 = ippr_ftp_atoi(&s);
	if (!s)
		return 0;
	a2 = ippr_ftp_atoi(&s);
	if (!s)
		return 0;

	/*
	 * check that IP address in the PORT/PASV reply is the same as the
	 * sender of the command - prevents using PORT for port scanning.
	 */
	a1 <<= 16;
	a1 |= a2;
	if (a1 != ntohl(nat->nat_oip.s_addr))
		return 0;

	a5 = ippr_ftp_atoi(&s);
	if (!s)
		return 0;

	if (*s == ')')
		s++;
	if (*s == '\n')
		s--;
	/*
	 * check for CR-LF at the end.
	 */
	if ((*s == '\r') && (*(s + 1) == '\n')) {
		s += 2;
		a6 = a5 & 0xff;
	} else
		return 0;
	a5 >>= 8;
	/*
	 * Calculate new address parts for 227 reply
	 */
	a1 = ntohl(ip->ip_src.s_addr);
	a2 = (a1 >> 16) & 0xff;
	a3 = (a1 >> 8) & 0xff;
	a4 = a1 & 0xff;
	a1 >>= 24;
	inc = 0;
#if 0
	olen = s - f->ftps_rptr;
	(void) sprintf(newbuf, "%s %u,%u,%u,%u,%u,%u\r\n",
		       "227 Entering Passive Mode", a1, a2, a3, a4, a5, a6);
	nlen = strlen(newbuf);
	inc = nlen - olen;
	if ((inc + ip->ip_len) > 65535)
		return 0;

#if SOLARIS
	m = fin->fin_qfm;
	for (m1 = m; m1->b_cont; m1 = m1->b_cont)
		;
	if ((inc > 0) && (m1->b_datap->db_lim - m1->b_wptr < inc)) {
		mblk_t *nm;

		/* alloc enough to keep same trailer space for lower driver */
		nm = allocb(nlen, BPRI_MED);
		PANIC((!nm),("ippr_ftp_out: allocb failed"));

		nm->b_band = m1->b_band;
		nm->b_wptr += nlen;

		m1->b_wptr -= olen;
		PANIC((m1->b_wptr < m1->b_rptr),
		      ("ippr_ftp_out: cannot handle fragmented data block"));

		linkb(m1, nm);
	} else {
		m1->b_wptr += inc;
	}
	/*copyin_mblk(m, off, nlen, newbuf);*/
#else /* SOLARIS */
	m = *((mb_t **)fin->fin_mp);
	if (inc < 0)
		m_adj(m, inc);
	/* the mbuf chain will be extended if necessary by m_copyback() */
	/*m_copyback(m, off, nlen, newbuf);*/
#endif /* SOLARIS */
	if (inc != 0) {
#if SOLARIS || defined(__sgi)
		register u_32_t	sum1, sum2;

		sum1 = ip->ip_len;
		sum2 = ip->ip_len + inc;

		/* Because ~1 == -2, We really need ~1 == -1 */
		if (sum1 > sum2)
			sum2--;
		sum2 -= sum1;
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);

		fix_outcksum(&ip->ip_sum, sum2);
#endif /* SOLARIS || defined(__sgi) */
		ip->ip_len += inc;
	}
#endif /* 0 */

	/*
	 * Add skeleton NAT entry for connection which will come back the
	 * other way.
	 */
	sp = 0;
	dp = htons(fin->fin_data[1] - 1);
	ipn = nat_outlookup(fin->fin_ifp, IPN_TCP, nat->nat_p, nat->nat_inip,
			    ip->ip_dst, (dp << 16) | sp, 0);
	if (ipn == NULL) {
		int slen;

		slen = ip->ip_len;
		ip->ip_len = fin->fin_hlen + sizeof(*tcp2);
		bcopy((char *)fin, (char *)&fi, sizeof(fi));
		bzero((char *)tcp2, sizeof(*tcp2));
		tcp2->th_win = htons(8192);
		tcp2->th_sport = 0;		/* XXX - fake it for nat_new */
		tcp2->th_off = 5;
		fi.fin_data[1] = a5 << 8 | a6;
		fi.fin_dlen = sizeof(*tcp2);
		tcp2->th_dport = htons(fi.fin_data[1]);
		fi.fin_data[0] = 0;
		fi.fin_dp = (char *)tcp2;
		fi.fin_fr = &natfr;
		swip = ip->ip_src;
		swip2 = ip->ip_dst;
		fi.fin_fi.fi_daddr = ip->ip_src.s_addr;
		fi.fin_fi.fi_saddr = nat->nat_inip.s_addr;
		ip->ip_dst = ip->ip_src;
		ip->ip_src = nat->nat_inip;
		ipn = nat_new(nat->nat_ptr, ip, &fi, IPN_TCP|FI_W_SPORT,
			      NAT_OUTBOUND);
		if (ipn != NULL) {
			ipn->nat_age = fr_defnatage;
			(void) fr_addstate(ip, &fi, FI_W_SPORT);
		}
		ip->ip_len = slen;
		ip->ip_src = swip;
		ip->ip_dst = swip2;
	}
	return inc;
}


int ippr_ftp_server(fin, ip, nat, ftp, dlen)
fr_info_t *fin;
ip_t *ip;
nat_t *nat;
ftpinfo_t *ftp;
int dlen;
{
	char *rptr, *wptr;
	ftpside_t *f;
	int inc;

	inc = 0;
	f = &ftp->ftp_side[1];
	rptr = f->ftps_rptr;
	wptr = f->ftps_wptr;

	if ((ftp->ftp_passok == 1) && !strncmp(rptr, "331", 3))
		 ftp->ftp_passok = 2;
	else if (((ftp->ftp_passok == 3) || (ftp->ftp_passok == 1)) &&
		 !strncmp(rptr, "230", 3)) {
		ftp->ftp_passok = 4;
	} else if ((ftp->ftp_passok == 3) && !strncmp(rptr, "530", 3))
		ftp->ftp_passok = 0;
	else if ((ftp->ftp_passok == 4) && !strncmp(rptr, "227 ", 4)) {
		inc = ippr_ftp_pasv(fin, ip, nat, f, dlen);
	} else if (ippr_ftp_insecure && !strncmp(rptr, "227 ", 4)) {
		inc = ippr_ftp_pasv(fin, ip, nat, f, dlen);
	}
	while ((*rptr++ != '\n') && (rptr < wptr))
		;
	f->ftps_rptr = rptr;
	return inc;
}


/*
 * Look to see if the buffer starts with something which we recognise as
 * being the correct syntax for the FTP protocol.
 */
int ippr_ftp_valid(buf, len)
char *buf;
size_t len;
{
	register char *s, c;
	register size_t i = len;

	if (i < 5)
		return 2;
	s = buf;
	c = *s++;
	i--;

	if (isdigit(c)) {
		c = *s++;
		i--;
		if (isdigit(c)) {
			c = *s++;
			i--;
			if (isdigit(c)) {
				c = *s++;
				i--;
				if ((c != '-') && (c != ' '))
					return 1;
			} else
				return 1;
		} else
			return 1;
	} else if (isalpha(c)) {
		c = *s++;
		i--;
		if (isalpha(c)) {
			c = *s++;
			i--;
			if (isalpha(c)) {
				c = *s++;
				i--;
				if (isalpha(c)) {
					c = *s++;
					i--;
					if ((c != ' ') && (c != '\r'))
						return 1;
				} else if ((c != ' ') && (c != '\r'))
					return 1;
			} else
				return 1;
		} else
			return 1;
	} else
		return 1;
	for (; i; i--) {
		c = *s++;
		if (c == '\n')
			return 0;
	}
	return 2;
}


int ippr_ftp_process(fin, ip, nat, ftp, rv)
fr_info_t *fin;
ip_t *ip;
nat_t *nat;
ftpinfo_t *ftp;
int rv;
{
	int mlen, len, off, inc, i, sel;
	char *rptr, *wptr;
	ftpside_t *f, *t;
	tcphdr_t *tcp;
	mb_t *m;

	tcp = (tcphdr_t *)fin->fin_dp;
	off = fin->fin_hlen + (tcp->th_off << 2);

#if	SOLARIS
	m = fin->fin_qfm;
#else
	m = *((mb_t **)fin->fin_mp);
#endif

#if	SOLARIS
	mlen = msgdsize(m) - off;
#else
	mlen = mbufchainlen(m) - off;
#endif

	t = &ftp->ftp_side[1 - rv];
	f = &ftp->ftp_side[rv];
	if (!mlen) {
		if (!t->ftps_seq ||
		    (int)ntohl(tcp->th_ack) - (int)t->ftps_seq > 0)
			t->ftps_seq = ntohl(tcp->th_ack);
		f->ftps_len = 0;
		return 0;
	}

	inc = 0;
	rptr = f->ftps_rptr;
	wptr = f->ftps_wptr;

	sel = nat->nat_aps->aps_sel[1 - rv];
	if (rv)
		i = nat->nat_aps->aps_ackoff[sel];
	else
		i = nat->nat_aps->aps_seqoff[sel];
	/*
	 * XXX - Ideally, this packet should get dropped because we now know
	 * that it is out of order (and there is no real danger in doing so
	 * apart from causing packets to go through here ordered).
	 */
	if (f->ftps_len + f->ftps_seq == ntohl(tcp->th_seq))
		f->ftps_seq = ntohl(tcp->th_seq);
	else if (ntohl(tcp->th_seq) + i != f->ftps_seq) {
		return APR_ERR(-1);
	}
	f->ftps_len = mlen;

	while (mlen > 0) {
		len = MIN(mlen, FTP_BUFSZ / 2);

#if	SOLARIS
		copyout_mblk(m, off, len, wptr);
#else
		m_copydata(m, off, len, wptr);
#endif
		mlen -= len;
		off += len;
		wptr += len;
		f->ftps_wptr = wptr;
		if (f->ftps_junk == 2)
			f->ftps_junk = ippr_ftp_valid(rptr, wptr - rptr);

		while ((f->ftps_junk == 0) && (wptr > rptr)) {
			f->ftps_junk = ippr_ftp_valid(rptr, wptr - rptr);
			if (f->ftps_junk == 0) {
				len = wptr - rptr;
				f->ftps_rptr = rptr;
				if (rv)
					inc += ippr_ftp_server(fin, ip, nat,
							       ftp, len);
				else
					inc += ippr_ftp_client(fin, ip, nat,
							       ftp, len);
				rptr = f->ftps_rptr;
			}
		}

		while ((f->ftps_junk == 1) && (rptr < wptr)) {
			while ((rptr < wptr) && (*rptr != '\r'))
				rptr++;

			if (*rptr == '\r') {
				if (rptr + 1 < wptr) {
					if (*(rptr + 1) == '\n') {
						rptr += 2;
						f->ftps_junk = 0;
					} else
						rptr++;
				} else
					break;
			}
		}
		f->ftps_rptr = rptr;

		if (rptr == wptr) {
			rptr = wptr = f->ftps_buf;
		} else {
			if ((wptr > f->ftps_buf + FTP_BUFSZ / 2)) {
				i = wptr - rptr;
				if ((rptr == f->ftps_buf) ||
				    (wptr - rptr > FTP_BUFSZ / 2)) {
					f->ftps_junk = 1;
					rptr = wptr = f->ftps_buf;
				} else {
					bcopy(rptr, f->ftps_buf, i);
					wptr = f->ftps_buf + i;
					rptr = f->ftps_buf;
				}
			}
			f->ftps_rptr = rptr;
			f->ftps_wptr = wptr;
		}
	}

	t->ftps_seq = ntohl(tcp->th_ack);
	f->ftps_rptr = rptr;
	f->ftps_wptr = wptr;
	return APR_INC(inc);
}


int ippr_ftp_out(fin, ip, aps, nat)
fr_info_t *fin;
ip_t *ip;
ap_session_t *aps;
nat_t *nat;
{
	ftpinfo_t *ftp;

	ftp = aps->aps_data;
	if (ftp == NULL)
		return 0;
	return ippr_ftp_process(fin, ip, nat, ftp, 0);
}


int ippr_ftp_in(fin, ip, aps, nat)
fr_info_t *fin;
ip_t *ip;
ap_session_t *aps;
nat_t *nat;
{
	ftpinfo_t *ftp;

	ftp = aps->aps_data;
	if (ftp == NULL)
		return 0;
	return ippr_ftp_process(fin, ip, nat, ftp, 1);
}


/*
 * ippr_ftp_atoi - implement a version of atoi which processes numbers in
 * pairs separated by commas (which are expected to be in the range 0 - 255),
 * returning a 16 bit number combining either side of the , as the MSB and
 * LSB.
 */
u_short ippr_ftp_atoi(ptr)
char **ptr;
{
	register char *s = *ptr, c;
	register u_char i = 0, j = 0;

	while ((c = *s++) && isdigit(c)) {
		i *= 10;
		i += c - '0';
	}
	if (c != ',') {
		*ptr = NULL;
		return 0;
	}
	while ((c = *s++) && isdigit(c)) {
		j *= 10;
		j += c - '0';
	}
	*ptr = s;
	i &= 0xff;
	j &= 0xff;
	return (i << 8) | j;
}
@


1.14
log
@IPfilter 3.4.17; kjell@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ftp_pxy.c,v 1.13 2001/03/17 22:54:20 beck Exp $	*/
@


1.13
log
@Handle ftp services that don't ask for a password, only a username.
This appears to be allowed by RFC and is apparently used by some
banks in the netherlands (shudder).
Patch courtesy Ramses de Beer <rbdebeer@@yahoo.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ftp_pxy.c,v 1.12 2001/01/17 04:47:14 fgsch Exp $	*/
d7 1
a7 1
 * $IPFilter: ip_ftp_pxy.c,v 2.7.2.20 2000/12/02 00:15:06 darrenr Exp $
d518 5
a522 6
	else if ((ftp->ftp_passok == 1) && !strncmp(rptr, "230", 3))
		 ftp->ftp_passok = 4;
	else if ((ftp->ftp_passok == 3) && !strncmp(rptr, "230", 3))
		 ftp->ftp_passok = 4;
	else if ((ftp->ftp_passok == 3) && !strncmp(rptr, "530", 3))
		 ftp->ftp_passok = 0;
@


1.12
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d518 2
@


1.11
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ftp_pxy.c,v 1.10 2000/04/12 21:32:39 kjell Exp $	*/
d6 2
d25 1
a25 1
#define	IPF_FTPBUFSZ	MAX(96,IPF_MAX227LEN)	/* This *MUST* be >= 51! */
d28 3
d34 6
a39 6
int ippr_ftp_in __P((fr_info_t *, ip_t *, ap_session_t *, nat_t *));
int ippr_ftp_portmsg __P((fr_info_t *, ip_t *, nat_t *));
int ippr_ftp_pasvmsg __P((fr_info_t *, ip_t *, nat_t *));
int ippr_ftp_complete __P((char *, size_t, char *));

u_short ipf_ftp_atoi __P((char **));
d43 1
a57 70
int ippr_ftp_complete(buf, len, cbuf)
char *buf, *cbuf;
size_t len;
{
	register char *s, c;
	register size_t i;

	if (len < 5)
		return -1;
	s = buf;
	c = *s++;
	i = len - 1;

	if (isdigit(c)) {
		c = *s++;
		i--;
		if (isdigit(c)) {
			c = *s++;
			i--;
			if (isdigit(c)) {
				c = *s++;
				i--;
				if (c != '-' && c != ' ')
					return -1;
			} else
				return -1;
		} else
			return -1;
	} else if (isalpha(c)) {
		cbuf[0] = toupper(c);
		c = *s++;
		i--;
		if (isalpha(c)) {
			cbuf[1] = toupper(c);
			c = *s++;
			i--;
			if (isalpha(c)) {
				cbuf[2] = toupper(c);
				c = *s++;
				i--;
				if (isalpha(c)) {
					cbuf[3] = toupper(c);
					c = *s++;
					cbuf[4] = c;
					i--;
					if (c != ' ')
						return -1;
				} else
					return -1;
			} else
				return -1;
		} else
			return -1;
	} else
		return -1;

	for (; i && (c = *s); i--, s++) {
		if ((c == '\r') && (i != 2))
			return -1;
		if ((c == '\n') && (i != 1))
			return -1;
		else if ((i == 2) && (c != '\r'))
			return -1;
		else if ((i == 1) && (c != '\n'))
			return -1;
	}
	return i;
}


d65 1
d73 7
a79 1
	ftp->ftp_passok = 0;
d84 1
a84 30
/*
 * ipf_ftp_atoi - implement a version of atoi which processes numbers in
 * pairs separated by commas (which are expected to be in the range 0 - 255),
 * returning a 16 bit number combining either side of the , as the MSB and
 * LSB.
 */
u_short ipf_ftp_atoi(ptr)
char **ptr;
{
	register char *s = *ptr, c;
	register u_char i = 0, j = 0;

	while ((c = *s++) && isdigit(c)) {
		i *= 10;
		i += c - '0';
	}
	if (c != ',') {
		*ptr = NULL;
		return 0;
	}
	while ((c = *s++) && isdigit(c)) {
		j *= 10;
		j += c - '0';
	}
	*ptr = s;
	return (i << 8) | j;
}


int ippr_ftp_portmsg(fin, ip, nat)
d88 2
a90 1
	char portbuf[IPF_FTPBUFSZ], newbuf[IPF_FTPBUFSZ], *s, cmd[6];
d92 1
a92 1
	size_t nlen = 0, dlen, olen;
d96 1
a96 2
	int off, inc = 0;
	ftpinfo_t *ftp;
d98 1
a105 42
	bzero(portbuf, sizeof(portbuf));
	off = (ip->ip_hl << 2) + (tcp->th_off << 2);

#if	SOLARIS
	m = fin->fin_qfm;

	dlen = msgdsize(m) - off;
	if (dlen > 0)
		copyout_mblk(m, off, MIN(sizeof(portbuf), dlen), portbuf);
#else
	m = *(mb_t **)fin->fin_mp;

	dlen = mbufchainlen(m) - off;
	if (dlen > 0)
		m_copydata(m, off, MIN(sizeof(portbuf), dlen), portbuf);
#endif
	if (dlen <= 0)
		return 0;
	bzero(cmd, sizeof(cmd));
	portbuf[sizeof(portbuf) - 1] = '\0';
	*newbuf = '\0';

	/*
	 * Check that a user is progressing through the login ok.
	 */
	if (ippr_ftp_complete(portbuf, dlen, cmd))
		return 0;

	ftp = nat->nat_aps->aps_data;
	switch (ftp->ftp_passok)
	{
	case 0 :
		if (!strncmp(cmd, "USER ", 5))
			ftp->ftp_passok = 1;
		break;
	case 2 :
		if (!strncmp(cmd, "PASS ", 5))
			ftp->ftp_passok = 3;
		break;
	}
	if (ftp->ftp_passok != 4)
		return 0;
d109 1
a109 4
	if (!ippr_ftp_pasvonly && !strncmp(cmd, "PORT ", 5)) { 
		if (dlen < IPF_MINPORTLEN)
			return 0;
	} else
d111 1
a111 1

d115 1
a115 1
	s = portbuf + 5;
d119 1
a119 1
	a1 = ipf_ftp_atoi(&s);
d122 1
a122 1
	a2 = ipf_ftp_atoi(&s);
a124 1

d134 1
a134 1
	a5 = ipf_ftp_atoi(&s);
d151 1
d160 1
a160 1
	olen = s - portbuf;
d167 3
d171 1
d197 1
d202 4
d220 1
a220 1
		fix_outcksum(&ip->ip_sum, sum2, 0);
d243 1
a243 1
			    ip->ip_dst, (dp << 16) | sp);
d245 4
d253 1
d257 1
d259 1
d261 1
d269 1
d272 1
a272 1
	return inc;
d276 1
a276 1
int ippr_ftp_out(fin, ip, aps, nat)
d278 2
d281 1
a281 2
ap_session_t *aps;
nat_t *nat;
d283 35
a317 1
	return ippr_ftp_portmsg(fin, ip, nat);
d321 1
a321 1
int ippr_ftp_pasvmsg(fin, ip, nat)
d325 2
d328 1
a328 3
	char portbuf[IPF_FTPBUFSZ], newbuf[IPF_FTPBUFSZ], *s, cmd[6];
	int off, olen, dlen, nlen = 0, inc = 0;
	tcphdr_t tcph, *tcp2 = &tcph;
d330 1
a330 1
	u_short a5, a6, dp, sp;
a331 2
	ftpinfo_t *ftp;
	tcphdr_t *tcp;
d334 2
a335 52
	mb_t *m;
#if	SOLARIS
	mb_t *m1;
#endif

	tcp = (tcphdr_t *)fin->fin_dp;
	off = (ip->ip_hl << 2) + (tcp->th_off << 2);
	m = *(mb_t **)fin->fin_mp;
	bzero(portbuf, sizeof(portbuf));

#if	SOLARIS
	m = fin->fin_qfm;

	dlen = msgdsize(m) - off;
	if (dlen > 0)
		copyout_mblk(m, off, MIN(sizeof(portbuf), dlen), portbuf);
#else
	dlen = mbufchainlen(m) - off;
	if (dlen > 0)
		m_copydata(m, off, MIN(sizeof(portbuf), dlen), portbuf);
#endif
	if (dlen <= 0)
		return 0;
	bzero(cmd, sizeof(cmd));
	portbuf[sizeof(portbuf) - 1] = '\0';
	*newbuf = '\0';

	/*
	 * Check that a user is progressing through the login ok.
	 * Don't put the switch in one common function because one side
	 * should only see numeric responses and the other commands.
	 */

	ftp = nat->nat_aps->aps_data;
	switch (ftp->ftp_passok)
	{
	case 1 :
		if (!strncmp(portbuf, "331", 3))
			ftp->ftp_passok = 2;
		else if (!strncmp(portbuf, "530", 3))
			ftp->ftp_passok = 0;
		break;
	case 3 :
		if (!strncmp(portbuf, "230", 3))
			ftp->ftp_passok = 4;
		break;
	default :
		break;
	}

	if (ippr_ftp_complete(portbuf, dlen, cmd) || (ftp->ftp_passok != 4))
		return 0;
d340 3
a342 6
	if (!strncmp(portbuf, "227 ", 4)) {
		if (dlen < IPF_MIN227LEN)
			return 0;
		else if (strncmp(portbuf, "227 Entering Passive Mode", 25))
			return 0;
	} else
d344 3
d350 1
a350 1
	s = portbuf + 25;
d356 1
a356 1
	a1 = ipf_ftp_atoi(&s);
d359 1
a359 1
	a2 = ipf_ftp_atoi(&s);
d372 1
a372 1
	a5 = ipf_ftp_atoi(&s);
d397 3
a399 1
	olen = s - portbuf;
a401 1

d404 3
d408 1
d429 3
a431 2
	copyin_mblk(m, off, nlen, newbuf);
#else
d435 2
a436 2
	m_copyback(m, off, nlen, newbuf);
#endif
d450 2
a451 2
		fix_outcksum(&ip->ip_sum, sum2, 0);
#endif
d454 1
d463 1
a463 1
			    ip->ip_dst, (dp << 16) | sp);
d465 4
d473 5
a477 3
		fi.fin_data[0] = a5 << 8 | a6;
		tcp2->th_dport = htons(fi.fin_data[0]);
		fi.fin_data[1] = 0;
d479 1
d482 2
d492 1
d500 245
d751 20
d772 16
a787 1
	return ippr_ftp_pasvmsg(fin, ip, nat);
@


1.10
log
@FTP Proxy changes introduced in 3.3.12 were too agressive. Tone down
a bit. posted to ipf list by darrenr@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ftp_pxy.c,v 1.9 2000/04/05 05:35:27 kjell Exp $	*/
d12 4
a15 1
#define	isupper(x)	((unsigned)((x) - 'A') <= 'Z' - 'A')
d32 1
a32 1
int ippr_ftp_complete __P((char *, size_t));
d52 2
a53 2
int ippr_ftp_complete(buf, len)
char *buf;
d80 2
a81 1
	} else if (isupper(c)) {
d84 2
a85 1
		if (isupper(c)) {
d88 2
a89 1
			if (isupper(c)) {
d92 2
a93 1
				if (isupper(c)) {
d95 1
d175 1
a175 1
	char portbuf[IPF_FTPBUFSZ], newbuf[IPF_FTPBUFSZ], *s;
d207 1
a207 1
	if (dlen == 0)
d209 1
d216 1
a216 1
	if (ippr_ftp_complete(portbuf, dlen))
d223 1
a223 1
		if (!strncmp(portbuf, "USER ", 5))
d227 1
a227 1
		if (!strncmp(portbuf, "PASS ", 5))
d236 1
a236 1
	if (!ippr_ftp_pasvonly && !strncmp(portbuf, "PORT ", 5)) { 
d403 1
a403 1
	char portbuf[IPF_FTPBUFSZ], newbuf[IPF_FTPBUFSZ], *s;
d434 1
a434 1
	if (dlen == 0)
d436 1
d463 1
a463 1
	if (ippr_ftp_complete(portbuf, dlen) || (ftp->ftp_passok != 4))
@


1.9
log
@Update to ipf 3.3.12. Most fixes relate to hardening of
in-kernel ftp proxy. See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ftp_pxy.c,v 1.8 2000/03/13 23:40:18 kjell Exp $	*/
d20 1
a20 3
#define	IPF_FTPBUFSZ	MAX(68,IPF_MAX227LEN)	/* This *MUST* be >= 51! */
			/* 68 is chosen as the minimum datagram size for */
			/* an unfragmented packet */
d209 1
d435 1
a435 2
	if (ippr_ftp_complete(portbuf, dlen))
		return 0;
d442 1
a442 1
		else if (!strncmp(portbuf, "520", 3))
d453 1
a453 1
	if (ftp->ftp_passok != 4)
d455 1
@


1.8
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
d20 3
d26 1
d31 1
d36 1
d51 84
d169 1
a169 1
	char portbuf[IPF_MAXPORTLEN + 1], newbuf[IPF_MAXPORTLEN + 1], *s;
d176 1
d205 24
a228 1
	if (!strncmp(portbuf, "PORT ", 5)) { 
d283 1
d344 6
d395 1
a395 1
	char portbuf[IPF_MAX227LEN + 1], newbuf[IPF_MAX227LEN + 1], *s;
d401 1
d431 29
@


1.7
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@@


1.6
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.6.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ftp_pxy.c,v 1.7 2000/02/16 22:34:19 kjell Exp $	*/
@


1.6.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ftp_pxy.c,v 1.13 2001/03/17 22:54:20 beck Exp $	*/
a5 2
 *
 * $IPFilter: ip_ftp_pxy.c,v 2.7.2.20 2000/12/02 00:15:06 darrenr Exp $
a11 4
#define	isupper(x)	(((unsigned)(x) >= 'A') && ((unsigned)(x) <= 'Z'))
#define	islower(x)	(((unsigned)(x) >= 'a') && ((unsigned)(x) <= 'z'))
#define	isalpha(x)	(isupper(x) || islower(x))
#define	toupper(x)	(isupper(x) ? (x) : (x) - 'a' + 'A')
a18 1
#define	IPF_FTPBUFSZ	96	/* This *MUST* be >= 53! */
a20 3
int ippr_ftp_client __P((fr_info_t *, ip_t *, nat_t *, ftpinfo_t *, int));
int ippr_ftp_complete __P((char *, size_t));
int ippr_ftp_in __P((fr_info_t *, ip_t *, ap_session_t *, nat_t *));
a21 1
int ippr_ftp_new __P((fr_info_t *, ip_t *, ap_session_t *, nat_t *));
d23 5
a27 6
int ippr_ftp_pasv __P((fr_info_t *, ip_t *, nat_t *, ftpside_t *, int));
int ippr_ftp_port __P((fr_info_t *, ip_t *, nat_t *, ftpside_t *, int));
int ippr_ftp_process __P((fr_info_t *, ip_t *, nat_t *, ftpinfo_t *, int));
int ippr_ftp_server __P((fr_info_t *, ip_t *, nat_t *, ftpinfo_t *, int));
int ippr_ftp_valid __P((char *, size_t));
u_short ippr_ftp_atoi __P((char **));
a29 2
int	ippr_ftp_pasvonly = 0;
int	ippr_ftp_insecure = 0;
d44 8
a51 5
int ippr_ftp_new(fin, ip, aps, nat)
fr_info_t *fin;
ip_t *ip;
ap_session_t *aps;
nat_t *nat;
d53 2
a54 2
	ftpinfo_t *ftp;
	ftpside_t *f;
d56 14
a69 14
	KMALLOC(ftp, ftpinfo_t *);
	if (ftp == NULL)
		return -1;
	aps->aps_data = ftp;
	aps->aps_psiz = sizeof(ftpinfo_t);

	bzero((char *)ftp, sizeof(*ftp));
	f = &ftp->ftp_side[0];
	f->ftps_rptr = f->ftps_buf;
	f->ftps_wptr = f->ftps_buf;
	f = &ftp->ftp_side[1];
	f->ftps_rptr = f->ftps_buf;
	f->ftps_wptr = f->ftps_buf;
	return 0;
d73 1
a73 1
int ippr_ftp_port(fin, ip, nat, f, dlen)
a76 2
ftpside_t *f;
int dlen;
d78 1
d80 1
a80 1
	char newbuf[IPF_FTPBUFSZ], *s;
d84 1
a84 1
	size_t nlen, olen;
a85 1
	int inc, off;
d93 24
a116 4
	/*
	 * Check for client sending out PORT message.
	 */
	if (dlen < IPF_MINPORTLEN)
d118 1
a118 1
	off = fin->fin_hlen + (tcp->th_off << 2);
d122 1
a122 1
	s = f->ftps_rptr + 5;
d126 1
a126 1
	a1 = ippr_ftp_atoi(&s);
d129 1
a129 1
	a2 = ippr_ftp_atoi(&s);
d132 1
d142 1
a142 1
	a5 = ippr_ftp_atoi(&s);
a158 1
	a5 &= 0xff;
d167 1
a167 2
	olen = s - f->ftps_rptr;
	/* DO NOT change this to sprintf! */
a172 3
	if ((inc + ip->ip_len) > 65535)
		return 0;

a173 1
	m = fin->fin_qfm;
a198 1
	m = *((mb_t **)fin->fin_mp);
a202 4
# ifdef	M_PKTHDR
	if (!(m->m_flags & M_PKTHDR))
		m->m_pkthdr.len += inc;
# endif
d217 1
a217 1
		fix_outcksum(&ip->ip_sum, sum2);
a227 6
	 * Don't allow the PORT command to specify a port < 1024 due to
	 * security crap.
	 */
	if (ntohs(sp) < 1024)
		return 0;
	/*
d234 1
a234 1
			    ip->ip_dst, (dp << 16) | sp, 0);
a235 4
		int slen;

		slen = ip->ip_len;
		ip->ip_len = fin->fin_hlen + sizeof(*tcp2);
a239 1
		tcp2->th_off = 5;
a242 1
		fi.fin_dlen = sizeof(*tcp2);
a243 1
		fi.fin_fr = &natfr;
a244 1
		fi.fin_fi.fi_saddr = nat->nat_inip.s_addr;
a251 1
		ip->ip_len = slen;
d254 1
a254 1
	return APR_INC(inc);
d258 1
a258 1
int ippr_ftp_client(fin, ip, nat, ftp, dlen)
d260 2
a262 3
ftpinfo_t *ftp;
ip_t *ip;
int dlen;
d264 1
a264 35
	char *rptr, *wptr, cmd[6], c;
	ftpside_t *f;
	int inc, i;

	inc = 0;
	f = &ftp->ftp_side[0];
	rptr = f->ftps_rptr;
	wptr = f->ftps_wptr;

	for (i = 0; (i < 5) && (i < dlen); i++) {
		c = rptr[i];
		if (isalpha(c)) {
			cmd[i] = toupper(c);
		} else {
			cmd[i] = c;
		}
	}
	cmd[i] = '\0';

	if ((ftp->ftp_passok == 0) && !strncmp(cmd, "USER ", 5))
		 ftp->ftp_passok = 1;
	else if ((ftp->ftp_passok == 2) && !strncmp(cmd, "PASS ", 5))
		 ftp->ftp_passok = 3;
	else if ((ftp->ftp_passok == 4) && !ippr_ftp_pasvonly &&
		 !strncmp(cmd, "PORT ", 5)) {
		inc = ippr_ftp_port(fin, ip, nat, f, dlen);
	} else if (ippr_ftp_insecure && !ippr_ftp_pasvonly &&
		   !strncmp(cmd, "PORT ", 5)) {
		inc = ippr_ftp_port(fin, ip, nat, f, dlen);
	}

	while ((*rptr++ != '\n') && (rptr < wptr))
		;
	f->ftps_rptr = rptr;
	return inc;
d268 1
a268 1
int ippr_ftp_pasv(fin, ip, nat, f, dlen)
a271 2
ftpside_t *f;
int dlen;
d273 3
a275 1
	tcphdr_t *tcp, tcph, *tcp2 = &tcph;
d277 1
a277 1
	u_short a5, a6, sp, dp;
d279 1
d282 12
a293 2
	int inc;
	char *s;
d295 9
a303 4
	/*
	 * Check for PASV reply message.
	 */
	if (dlen < IPF_MIN227LEN)
d305 9
a313 1
	else if (strncmp(f->ftps_rptr, "227 Entering Passive Mode", 25))
a314 3

	tcp = (tcphdr_t *)fin->fin_dp;

d318 1
a318 1
	s = f->ftps_rptr + 25;
d324 1
a324 1
	a1 = ippr_ftp_atoi(&s);
d327 1
a327 1
	a2 = ippr_ftp_atoi(&s);
d340 1
a340 1
	a5 = ippr_ftp_atoi(&s);
d365 1
a365 3
	inc = 0;
#if 0
	olen = s - f->ftps_rptr;
d368 1
a370 3
	if ((inc + ip->ip_len) > 65535)
		return 0;

a371 1
	m = fin->fin_qfm;
d392 2
a393 3
	/*copyin_mblk(m, off, nlen, newbuf);*/
#else /* SOLARIS */
	m = *((mb_t **)fin->fin_mp);
d397 2
a398 2
	/*m_copyback(m, off, nlen, newbuf);*/
#endif /* SOLARIS */
d412 2
a413 2
		fix_outcksum(&ip->ip_sum, sum2);
#endif /* SOLARIS || defined(__sgi) */
a415 1
#endif /* 0 */
d424 1
a424 1
			    ip->ip_dst, (dp << 16) | sp, 0);
a425 4
		int slen;

		slen = ip->ip_len;
		ip->ip_len = fin->fin_hlen + sizeof(*tcp2);
d430 3
a432 5
		tcp2->th_off = 5;
		fi.fin_data[1] = a5 << 8 | a6;
		fi.fin_dlen = sizeof(*tcp2);
		tcp2->th_dport = htons(fi.fin_data[1]);
		fi.fin_data[0] = 0;
a433 1
		fi.fin_fr = &natfr;
a435 2
		fi.fin_fi.fi_daddr = ip->ip_src.s_addr;
		fi.fin_fi.fi_saddr = nat->nat_inip.s_addr;
a443 1
		ip->ip_len = slen;
a450 247
int ippr_ftp_server(fin, ip, nat, ftp, dlen)
fr_info_t *fin;
ip_t *ip;
nat_t *nat;
ftpinfo_t *ftp;
int dlen;
{
	char *rptr, *wptr;
	ftpside_t *f;
	int inc;

	inc = 0;
	f = &ftp->ftp_side[1];
	rptr = f->ftps_rptr;
	wptr = f->ftps_wptr;

	if ((ftp->ftp_passok == 1) && !strncmp(rptr, "331", 3))
		 ftp->ftp_passok = 2;
	else if ((ftp->ftp_passok == 1) && !strncmp(rptr, "230", 3))
		 ftp->ftp_passok = 4;
	else if ((ftp->ftp_passok == 3) && !strncmp(rptr, "230", 3))
		 ftp->ftp_passok = 4;
	else if ((ftp->ftp_passok == 3) && !strncmp(rptr, "530", 3))
		 ftp->ftp_passok = 0;
	else if ((ftp->ftp_passok == 4) && !strncmp(rptr, "227 ", 4)) {
		inc = ippr_ftp_pasv(fin, ip, nat, f, dlen);
	} else if (ippr_ftp_insecure && !strncmp(rptr, "227 ", 4)) {
		inc = ippr_ftp_pasv(fin, ip, nat, f, dlen);
	}
	while ((*rptr++ != '\n') && (rptr < wptr))
		;
	f->ftps_rptr = rptr;
	return inc;
}


/*
 * Look to see if the buffer starts with something which we recognise as
 * being the correct syntax for the FTP protocol.
 */
int ippr_ftp_valid(buf, len)
char *buf;
size_t len;
{
	register char *s, c;
	register size_t i = len;

	if (i < 5)
		return 2;
	s = buf;
	c = *s++;
	i--;

	if (isdigit(c)) {
		c = *s++;
		i--;
		if (isdigit(c)) {
			c = *s++;
			i--;
			if (isdigit(c)) {
				c = *s++;
				i--;
				if ((c != '-') && (c != ' '))
					return 1;
			} else
				return 1;
		} else
			return 1;
	} else if (isalpha(c)) {
		c = *s++;
		i--;
		if (isalpha(c)) {
			c = *s++;
			i--;
			if (isalpha(c)) {
				c = *s++;
				i--;
				if (isalpha(c)) {
					c = *s++;
					i--;
					if ((c != ' ') && (c != '\r'))
						return 1;
				} else if ((c != ' ') && (c != '\r'))
					return 1;
			} else
				return 1;
		} else
			return 1;
	} else
		return 1;
	for (; i; i--) {
		c = *s++;
		if (c == '\n')
			return 0;
	}
	return 2;
}


int ippr_ftp_process(fin, ip, nat, ftp, rv)
fr_info_t *fin;
ip_t *ip;
nat_t *nat;
ftpinfo_t *ftp;
int rv;
{
	int mlen, len, off, inc, i, sel;
	char *rptr, *wptr;
	ftpside_t *f, *t;
	tcphdr_t *tcp;
	mb_t *m;

	tcp = (tcphdr_t *)fin->fin_dp;
	off = fin->fin_hlen + (tcp->th_off << 2);

#if	SOLARIS
	m = fin->fin_qfm;
#else
	m = *((mb_t **)fin->fin_mp);
#endif

#if	SOLARIS
	mlen = msgdsize(m) - off;
#else
	mlen = mbufchainlen(m) - off;
#endif

	t = &ftp->ftp_side[1 - rv];
	f = &ftp->ftp_side[rv];
	if (!mlen) {
		if (!t->ftps_seq ||
		    (int)ntohl(tcp->th_ack) - (int)t->ftps_seq > 0)
			t->ftps_seq = ntohl(tcp->th_ack);
		f->ftps_len = 0;
		return 0;
	}

	inc = 0;
	rptr = f->ftps_rptr;
	wptr = f->ftps_wptr;

	sel = nat->nat_aps->aps_sel[1 - rv];
	if (rv)
		i = nat->nat_aps->aps_ackoff[sel];
	else
		i = nat->nat_aps->aps_seqoff[sel];
	/*
	 * XXX - Ideally, this packet should get dropped because we now know
	 * that it is out of order (and there is no real danger in doing so
	 * apart from causing packets to go through here ordered).
	 */
	if (f->ftps_len + f->ftps_seq == ntohl(tcp->th_seq))
		f->ftps_seq = ntohl(tcp->th_seq);
	else if (ntohl(tcp->th_seq) + i != f->ftps_seq) {
		return APR_ERR(-1);
	}
	f->ftps_len = mlen;

	while (mlen > 0) {
		len = MIN(mlen, FTP_BUFSZ / 2);

#if	SOLARIS
		copyout_mblk(m, off, len, wptr);
#else
		m_copydata(m, off, len, wptr);
#endif
		mlen -= len;
		off += len;
		wptr += len;
		f->ftps_wptr = wptr;
		if (f->ftps_junk == 2)
			f->ftps_junk = ippr_ftp_valid(rptr, wptr - rptr);

		while ((f->ftps_junk == 0) && (wptr > rptr)) {
			f->ftps_junk = ippr_ftp_valid(rptr, wptr - rptr);
			if (f->ftps_junk == 0) {
				len = wptr - rptr;
				f->ftps_rptr = rptr;
				if (rv)
					inc += ippr_ftp_server(fin, ip, nat,
							       ftp, len);
				else
					inc += ippr_ftp_client(fin, ip, nat,
							       ftp, len);
				rptr = f->ftps_rptr;
			}
		}

		while ((f->ftps_junk == 1) && (rptr < wptr)) {
			while ((rptr < wptr) && (*rptr != '\r'))
				rptr++;

			if (*rptr == '\r') {
				if (rptr + 1 < wptr) {
					if (*(rptr + 1) == '\n') {
						rptr += 2;
						f->ftps_junk = 0;
					} else
						rptr++;
				} else
					break;
			}
		}
		f->ftps_rptr = rptr;

		if (rptr == wptr) {
			rptr = wptr = f->ftps_buf;
		} else {
			if ((wptr > f->ftps_buf + FTP_BUFSZ / 2)) {
				i = wptr - rptr;
				if ((rptr == f->ftps_buf) ||
				    (wptr - rptr > FTP_BUFSZ / 2)) {
					f->ftps_junk = 1;
					rptr = wptr = f->ftps_buf;
				} else {
					bcopy(rptr, f->ftps_buf, i);
					wptr = f->ftps_buf + i;
					rptr = f->ftps_buf;
				}
			}
			f->ftps_rptr = rptr;
			f->ftps_wptr = wptr;
		}
	}

	t->ftps_seq = ntohl(tcp->th_ack);
	f->ftps_rptr = rptr;
	f->ftps_wptr = wptr;
	return APR_INC(inc);
}


int ippr_ftp_out(fin, ip, aps, nat)
fr_info_t *fin;
ip_t *ip;
ap_session_t *aps;
nat_t *nat;
{
	ftpinfo_t *ftp;

	ftp = aps->aps_data;
	if (ftp == NULL)
		return 0;
	return ippr_ftp_process(fin, ip, nat, ftp, 0);
}


a456 20
	ftpinfo_t *ftp;

	ftp = aps->aps_data;
	if (ftp == NULL)
		return 0;
	return ippr_ftp_process(fin, ip, nat, ftp, 1);
}


/*
 * ippr_ftp_atoi - implement a version of atoi which processes numbers in
 * pairs separated by commas (which are expected to be in the range 0 - 255),
 * returning a 16 bit number combining either side of the , as the MSB and
 * LSB.
 */
u_short ippr_ftp_atoi(ptr)
char **ptr;
{
	register char *s = *ptr, c;
	register u_char i = 0, j = 0;
d458 1
a458 16
	while ((c = *s++) && isdigit(c)) {
		i *= 10;
		i += c - '0';
	}
	if (c != ',') {
		*ptr = NULL;
		return 0;
	}
	while ((c = *s++) && isdigit(c)) {
		j *= 10;
		j += c - '0';
	}
	*ptr = s;
	i &= 0xff;
	j &= 0xff;
	return (i << 8) | j;
@


1.6.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ftp_pxy.c,v 1.6.2.2 2001/05/14 22:40:10 niklas Exp $	*/
@


1.5
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
@


1.4
log
@ipf 3.2.10; work by kjell
@
text
@d1 2
a2 2
/*	$OpenBSD: ip_ftp_pxy.c,v 1.3 1998/09/15 09:51:18 pattonme Exp $
 * $Id: ip_ftp_pxy.c,v 1.3 1998/09/15 09:51:18 pattonme Exp $
d20 1
a20 1
int ippr_ftp_init __P((fr_info_t *, ip_t *, ap_session_t *, nat_t *));
d23 3
a25 2
int ippr_ftp_portmsg __P((fr_info_t *, ip_t *, nat_t *nat));
int ippr_ftp_pasvmsg __P((fr_info_t *, ip_t *, tcphdr_t *, nat_t *));
d28 2
d32 1
a32 1
 * FTP application proxy initialization.
d34 1
a34 5
int ippr_ftp_init(fin, ip, aps, nat)
fr_info_t *fin;
ip_t *ip;
ap_session_t *aps;
nat_t *nat;
d36 3
a38 4
	tcphdr_t *tcp = (tcphdr_t *)fin->fin_dp;

	aps->aps_sport = tcp->th_sport;
	aps->aps_dport = tcp->th_dport;
d78 3
a80 1
	int off, olen, dlen, nlen = 0, inc = 0;
a81 1
	tcphdr_t *tcp, tcph, *tcp2 = &tcph;
d83 1
a83 1
	u_short a5, a6, sp, dp;
d92 1
a93 1
	m = *(mb_t **)fin->fin_mp;
d99 2
a100 2
	bzero(portbuf, sizeof(portbuf));
	copyout_mblk(m, off, MIN(sizeof(portbuf), dlen), portbuf);
d102 2
d105 2
a106 2
	bzero(portbuf, sizeof(portbuf));
	m_copydata(m, off, MIN(sizeof(portbuf), dlen), portbuf);
d108 2
a111 1

d133 3
a135 3
	* check that IP address in the PORT/PASV reply is the same as the
	* sender of the command - prevents using PORT for port scanning.
	*/
d144 2
d150 4
a153 2
	if (((*s == '\r') && (*(s + 1) == '\n')) ||
	    ((*(s - 1) == '\r') && (*s == '\n')))
d155 1
a155 1
	else
d166 2
a167 2
	olen = s - portbuf + 1;
	(void) sprintf(newbuf, "%s %d,%d,%d,%d,%d,%d\r\n",
d191 3
d203 1
a203 1
	if (inc) {
d216 1
a216 1
		fix_outcksum(&ip->ip_sum, sum2);
d222 3
a224 3
	* Add skeleton NAT entry for connection which will come back the
	* other way.
	*/
d226 5
d232 2
a233 2
	ipn = nat_outlookup(fin->fin_ifp, IPN_TCP, nat->nat_inip, sp,
			    ip->ip_dst, dp);
d237 1
d239 3
a241 1
		tcp2->th_dport = dp;
d245 2
a246 1
		ipn = nat_new(nat->nat_ptr, ip, &fi, IPN_TCP, NAT_OUTBOUND);
d249 1
a249 2
			(void) fr_addstate(ip, &fi, FR_INQUE|FR_PASS|
						    FR_QUICK|FR_KEEPSTATE);
d267 1
a267 1
int ippr_ftp_pasvmsg(fin, ip, tcp, nat)
a269 1
tcphdr_t *tcp;
d274 3
d278 1
a278 3
	tcphdr_t tcph, *tcp2 = &tcph;
	struct in_addr swip;
	u_short a5, a6;
d286 1
d289 1
d295 2
a296 2
	bzero(portbuf, sizeof(portbuf));
	copyout_mblk(m, off, MIN(sizeof(portbuf), dlen), portbuf);
d299 2
a300 2
	bzero(portbuf, sizeof(portbuf));
	m_copydata(m, off, MIN(sizeof(portbuf), dlen), portbuf);
d302 2
a311 3
#ifndef notyet
		return 0;
#endif
a313 1

d315 2
a316 2
	* Skip the PORT command + space
	*/
d321 2
a322 2
	* Pick out the address components, two at a time.
	*/
d331 3
a333 3
	* check that IP address in the PORT/PASV reply is the same as the
	* sender of the command - prevents using PORT for port scanning.
	*/
d343 4
d348 4
a351 4
	* check for CR-LF at the end.
	*/
	if (((*s == '\r') && (*(s + 1) == '\n')) ||
	    ((*(s - 1) == '\r') && (*s == '\n')))
d353 1
a353 1
	else
d357 3
a359 3
	* Calculate new address parts for 227 reply
	*/
	a1 = ntohl(nat->nat_inip.s_addr);
d364 2
a365 2
	olen = s - portbuf + 1;
	(void) sprintf(newbuf, "%s %d,%d,%d,%d,%d,%d\r\n",
d398 1
a398 1
	if (inc) {
d411 1
a411 1
		fix_outcksum(&ip->ip_sum, sum2);
d420 26
a445 11
	bcopy((char *)fin, (char *)&fi, sizeof(fi));
	bzero((char *)tcp2, sizeof(*tcp2));
	tcp2->th_sport = htons(a5 << 8 | a6);
	fi.fin_dp = (char *)tcp2;
	swip = ip->ip_src;
	ip->ip_src = nat->nat_oip;
	ipn = nat_new(nat->nat_ptr, ip, &fi, IPN_TCP, NAT_INBOUND);
	if (ipn != NULL)
		ipn->nat_age = fr_defnatage;
	(void) fr_addstate(ip, &fi, FR_INQUE|FR_PASS|FR_QUICK|FR_KEEPSTATE);
	ip->ip_src = swip;
d449 1
a455 1
	tcphdr_t *tcp = (tcphdr_t *)fin->fin_dp;
d457 1
a457 1
	return ippr_ftp_pasvmsg(fin, ip, tcp, nat);
@


1.3
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 2
a2 2
/*	$OpenBSD$
 * $Id: ip_ftp_pxy.c,v 1.2 1998/08/31 21:45:44 pattonme Exp $
d6 3
d16 2
d20 5
a24 16
int ippr_ftp_init __P((fr_info_t *, ip_t *, tcphdr_t *,
		       ap_session_t *, nat_t *));
int ippr_ftp_in __P((fr_info_t *, ip_t *, tcphdr_t *,
		       ap_session_t *, nat_t *));
int ippr_ftp_out __P((fr_info_t *, ip_t *, tcphdr_t *,
		       ap_session_t *, nat_t *));
u_short ipf_ftp_atoi __P((char **));


int ippr_ftp_init __P((fr_info_t *, ip_t *, tcphdr_t *, ap_session_t *,
    nat_t *));
int ippr_ftp_in __P((fr_info_t *, ip_t *, tcphdr_t *, ap_session_t *,
    nat_t *));
int ippr_ftp_out __P((fr_info_t *, ip_t *, tcphdr_t *, ap_session_t *,
    nat_t *));

a27 1

d31 1
a31 1
int ippr_ftp_init(fin, ip, tcp, aps, nat)
a33 1
tcphdr_t *tcp;
d37 2
a44 27
int ippr_ftp_in(fin, ip, tcp, aps, nat)
fr_info_t *fin;
ip_t *ip;
tcphdr_t *tcp;
ap_session_t *aps;
nat_t *nat;
{
	u_32_t	sum1, sum2;
	short sel;

	if (tcp->th_sport == aps->aps_dport) {
		sum2 = (u_32_t)ntohl(tcp->th_ack);
		sel = aps->aps_sel;
		if ((aps->aps_after[!sel] > aps->aps_after[sel]) &&
			(sum2 > aps->aps_after[!sel])) {
			sel = aps->aps_sel = !sel; /* switch to other set */
		}
		if (aps->aps_seqoff[sel] && (sum2 > aps->aps_after[sel])) {
			sum1 = (u_32_t)aps->aps_seqoff[sel];
			tcp->th_ack = htonl(sum2 - sum1);
			return 2;
		}
	}
	return 0;
}


d74 1
a74 1
int ippr_ftp_out(fin, ip, tcp, aps, nat)
a76 2
tcphdr_t *tcp;
ap_session_t *aps;
d79 9
a87 13
	register u_32_t	sum1, sum2;
	char	newbuf[IPF_MAXPORTLEN+1];
	char	portbuf[IPF_MAXPORTLEN+1], *s;
	int	ch = 0, off = (ip->ip_hl << 2) + (tcp->th_off << 2);
	u_int	a1, a2, a3, a4;
	u_short	a5, a6;
	int	olen, dlen, nlen = 0, inc = 0;
	tcphdr_t tcph, *tcp2 = &tcph;
	void	*savep;
	nat_t	*ipn;
	struct	in_addr	swip;
	mb_t *m = *(mb_t **)fin->fin_mp;

d90 5
d96 1
d107 2
a108 1
	portbuf[IPF_MAXPORTLEN] = '\0';
d110 5
a114 2
	if ((dlen < IPF_MINPORTLEN) || strncmp(portbuf, "PORT ", 5))
		goto adjust_seqack;
d123 1
a123 1
	(void) ipf_ftp_atoi(&s);
d125 2
a126 2
		goto adjust_seqack;
	(void) ipf_ftp_atoi(&s);
d128 11
a138 1
		goto adjust_seqack;
d141 2
a142 1
		goto adjust_seqack;
d146 5
a150 3
	if (*s != '\n' || *(s - 1) != '\r')
		goto adjust_seqack;
	a6 = a5 & 0xff;
d161 3
a163 2
	(void) sprintf(newbuf, "PORT %d,%d,%d,%d,%d,%d\r\n",
		a1, a2, a3, a4, a5, a6);
d169 1
a169 1
	if (inc > 0) {
d173 1
a173 1
		nm = allocb(nlen + m1->b_datap->db_lim - m1->b_wptr, BPRI_MED);
d180 2
a181 1
		PANIC((m1->b_wptr < m1->b_rptr),("ippr_ftp_out: cannot handle fragmented data block"));
d196 185
a393 1
	ch = 1;
d399 1
a399 2
	savep = fin->fin_dp;
	fin->fin_dp = (char *)tcp2;
d402 1
a402 1
	tcp2->th_dport = htons(20);
d404 3
a406 2
	ip->ip_src = nat->nat_inip;
	if ((ipn = nat_new(nat->nat_ptr, ip, fin, IPN_TCP, NAT_OUTBOUND)))
d408 1
a408 1
	(void) fr_addstate(ip, fin, FR_INQUE|FR_PASS|FR_QUICK|FR_KEEPSTATE);
d410 2
a411 1
	fin->fin_dp = (char *)savep;
d413 7
a419 18
adjust_seqack:
	if (tcp->th_dport == aps->aps_dport) {
		sum2 = (u_32_t)ntohl(tcp->th_seq);
		off = aps->aps_sel;
		if ((aps->aps_after[!off] > aps->aps_after[off]) &&
			(sum2 > aps->aps_after[!off])) {
			off = aps->aps_sel = !off; /* switch to other set */
		}
		if (aps->aps_seqoff[off]) {
			sum1 = (u_32_t)aps->aps_after[off] -
			       aps->aps_seqoff[off];
			if (sum2 > sum1) {
				sum1 = (u_32_t)aps->aps_seqoff[off];
				sum2 += sum1;
				tcp->th_seq = htonl(sum2);
				ch = 1;
			}
		}
d421 1
a421 6
		if (inc && (sum2 > aps->aps_after[!off])) {
			aps->aps_after[!off] = sum2 + nlen - 1;
			aps->aps_seqoff[!off] = aps->aps_seqoff[off] + inc;
		}
	}
	return ch ? 2 : 0;
@


1.2
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*       $OpenBSD$       */
/*
d58 1
a58 1
	u_long	sum1, sum2;
d62 1
a62 1
		sum2 = (u_long)ntohl(tcp->th_ack);
d69 1
a69 1
			sum1 = (u_long)aps->aps_seqoff[sel];
d114 1
a114 1
	register u_long	sum1, sum2;
d130 1
a130 4
	/* skip any leading M_PROTOs */
	while(m && (MTYPE(m) != M_DATA))
		m = m->b_cont;
	PANIC((!m),("ippr_ftp_out: no M_DATA"));
d244 1
a244 1
		sum2 = (u_long)ntohl(tcp->th_seq);
d251 1
a251 1
			sum1 = (u_long)aps->aps_after[off] -
d254 1
a254 1
				sum1 = (u_long)aps->aps_seqoff[off];
@


1.1
log
@IPF 3.2.3
@
text
@d1 1
@
