head	1.12;
access;
symbols
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	UBC_SYNC_A:1.12
	UBC_SYNC_B:1.12
	SMP:1.12.0.2
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.12
date	97.07.11.23.49.17;	author provos;	state dead;
branches;
next	1.11;

1.11
date	97.07.01.22.12.43;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.06.25.07.53.22;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.06.24.20.57.25;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.06.24.20.48.40;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.06.24.12.15.20;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.06.20.05.41.48;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.02.26.03.01.03;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	97.02.24.14.06.38;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.02.22.11.34.46;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.02.21.08.42.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.07.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@obsolete.
@
text
@/*	$OpenBSD: ip_ahhmacsha1.c,v 1.11 1997/07/01 22:12:43 provos Exp $	*/

/*
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
 *
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
 *
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * Based on draft-ietf-ipsec-ah-hmac-sha-04.txt.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/socketvar.h>

#include <machine/cpu.h>
#include <machine/endian.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>
#include <net/raw_cb.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>

#include <net/encap.h>

#include <netinet/ip_ipsp.h>
#include <netinet/ip_ah.h>

/*
 * ahhmacsha1_attach() is called from the transformation initialization code.
 * It just returns.
 */

int
ahhmacsha1_attach()
{
    return 0;
}

/*
 * ahhmacsha1_init() is called when an SPI is being set up. It interprets the
 * encap_msghdr present in m, and sets up the transformation data.
 */

int
ahhmacsha1_init(struct tdb *tdbp, struct xformsw *xsp, struct mbuf *m)
{
    struct ahhmacsha1_xdata *xd;
    struct ahhmacsha1_xencap txd;
    struct encap_msghdr *em;
    int len;
	
    tdbp->tdb_xform = xsp;

    MALLOC(tdbp->tdb_xdata, caddr_t, sizeof (struct ahhmacsha1_xdata),
	   M_XDATA, M_WAITOK);
    if (tdbp->tdb_xdata == NULL)
      return ENOBUFS;
    bzero(tdbp->tdb_xdata, sizeof (struct ahhmacsha1_xdata));
    bzero(&txd, sizeof(struct ahhmacsha1_xencap));
    xd = (struct ahhmacsha1_xdata *)tdbp->tdb_xdata;

    em = mtod(m, struct encap_msghdr *);
    if (em->em_msglen - EMT_SETSPI_FLEN > sizeof (struct ahhmacsha1_xencap))
    {
	free((caddr_t)tdbp->tdb_xdata, M_XDATA);
	tdbp->tdb_xdata = NULL;
	return EINVAL;
    }
	
    m_copydata(m, EMT_SETSPI_FLEN, em->em_msglen - EMT_SETSPI_FLEN, 
	       (caddr_t)&txd);

    xd->amx_rpl = 1;
    xd->amx_alen = txd.amx_alen;
    xd->amx_bitmap = 0;
    xd->amx_wnd = txd.amx_wnd;
	
    SHA1Init(&(xd->amx_ictx));
    SHA1Init(&(xd->amx_octx));
	
    for (len = 0; len < AHHMACSHA1_KMAX; len++)
      txd.amx_key[len] ^= HMACSHA1_IPAD_VAL;

    SHA1Update(&(xd->amx_ictx), txd.amx_key, AHHMACSHA1_KMAX);

    for (len = 0; len < AHHMACSHA1_KMAX; len++)
      txd.amx_key[len] ^= (HMACSHA1_IPAD_VAL ^ HMACSHA1_OPAD_VAL);

    SHA1Update(&(xd->amx_octx), txd.amx_key, AHHMACSHA1_KMAX);
    bzero(&txd, sizeof(struct ahhmacsha1_xencap));
    bzero(ipseczeroes, IPSEC_ZEROES_SIZE);	/* paranoid */

    return 0;
}

/*
 * Free memory
 */

int
ahhmacsha1_zeroize(struct tdb *tdbp)
{
    FREE(tdbp->tdb_xdata, M_XDATA);
    return 0;
}

/*
 * ahhmacsha1_input() gets called to verify that an input packet
 * passes authentication.
 */

extern struct ifnet loif;

struct mbuf *
ahhmacsha1_input(struct mbuf *m, struct tdb *tdb)
{
    struct ahhmacsha1_xdata *xd;
    struct ip *ip, ipo;
    struct ah *ah;
    struct ahhmacsha1 aho, *ahp;
    struct ifnet *rcvif;
    int ohlen, len, count, off, ado, errc;
    u_int64_t btsx;
    struct mbuf *m0;
    SHA1_CTX ctx; 
    u_int8_t optval;
    
    xd = (struct ahhmacsha1_xdata *)tdb->tdb_xdata;
    ohlen = sizeof (struct ip) + AH_FLENGTH + xd->amx_alen;
    if (xd->amx_wnd >= 0)
      ohlen += HMACSHA1_RPLENGTH;

    rcvif = m->m_pkthdr.rcvif;
    if (rcvif == NULL)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ahhmacsha1_input: receive interface is NULL!!!\n");
#endif
	rcvif = &loif;
    }
	
    if (m->m_len < ohlen)
    {
	if ((m = m_pullup(m, ohlen)) == NULL)
	{
	    ahstat.ahs_hdrops++;
	    return NULL;
	}
    }

    ip = mtod(m, struct ip *);

    ip = mtod(m, struct ip *);

    if ((ip->ip_hl << 2) > sizeof(struct ip))
    {
	if ((m = m_pullup(m, ohlen - sizeof (struct ip) +
			  (ip->ip_hl << 2))) == NULL)
	{
	    ahstat.ahs_hdrops++;
	    return NULL;
	}
	
	ip = mtod(m, struct ip *);
	ah = (struct ah *)((u_int8_t *)ip + (ip->ip_hl << 2));
    }
    else
      ah = (struct ah *)(ip + 1);
    ahp = (struct ahhmacsha1 *)ah;

    if (xd->amx_wnd >= 0)
      ado = HMACSHA1_RPLENGTH;
    else
      ado = 0;

    if (ah->ah_hl * sizeof(u_int32_t) != xd->amx_alen + ado)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ahhmacsha1_input: bad authenticator length\n");
#endif
	ahstat.ahs_badauthl++;
	m_freem(m);
	return NULL;
    }

    ipo = *ip;
    ipo.ip_tos = 0;
    ipo.ip_len += sizeof(struct ip);	/* adjusted in ip_intr() */
    HTONS(ipo.ip_len);
    HTONS(ipo.ip_id);
    ipo.ip_off = htons(ipo.ip_off & IP_DF);	/* XXX -- and the C bit? */
    ipo.ip_ttl = 0;
    ipo.ip_sum = 0;

    ctx = xd->amx_ictx;
    SHA1Update(&ctx, (unsigned char *)&ipo, sizeof(struct ip));

    /* Options */
    if ((ip->ip_hl << 2 > sizeof(struct ip)))
      for (off = sizeof(struct ip); off < (ip->ip_hl << 2);)
      {
	  optval = ((u_int8_t *)ip)[off];
	  switch (optval)
	  {
	      case IPOPT_EOL:
	          SHA1Update(&ctx, ipseczeroes, 1);
		  off = ip->ip_hl << 2;
		  break;

	      case IPOPT_NOP:
	          SHA1Update(&ctx, ipseczeroes, 1);
		  off++;
		  break;
		  
	      case IPOPT_SECURITY:
	      case 133:
	      case 134:
		  optval = ((u_int8_t *)ip)[off + 1];
		  SHA1Update(&ctx, (u_int8_t *)ip + off, optval);
		  off += optval;
		  break;
		  
	      default:
		  optval = ((u_int8_t *)ip)[off + 1];
		  SHA1Update(&ctx, ipseczeroes, optval);
		  off += optval;
		  break;
	  }
      }

    if (xd->amx_wnd >= 0)
      SHA1Update(&ctx, (unsigned char *)ahp, 
		 AH_FLENGTH + HMACSHA1_RPLENGTH);
    else
      SHA1Update(&ctx, (unsigned char *)ahp, AH_FLENGTH);
    SHA1Update(&ctx, ipseczeroes, xd->amx_alen);

    /*
     * Code shamelessly stolen from m_copydata
     */
    off = ohlen;
    len = m->m_pkthdr.len - off;
    m0 = m;
	
    while (off > 0)
    {
	if (m0 == 0)
	  panic("ahhmacsha1_input: m_copydata (off)");
	if (off < m0->m_len)
	  break;
	off -= m0->m_len;
	m0 = m0->m_next;
    }

    while (len > 0)
    {
	if (m0 == 0)
	  panic("ahhmacsha1_input: m_copydata (copy)");
	count = min(m0->m_len - off, len);
	SHA1Update(&ctx, mtod(m0, unsigned char *) + off, count);
	len -= count;
	off = 0;
	m0 = m0->m_next;
    }

    SHA1Final((unsigned char *)(&(aho.ah_data[0])), &ctx);
    ctx = xd->amx_octx;
    SHA1Update(&ctx, (unsigned char *)(&(aho.ah_data[0])), 
	       HMACSHA1_HASHLEN);
    SHA1Final((unsigned char *)(&(aho.ah_data[0])), &ctx);

    if (bcmp(aho.ah_data, ah->ah_data + ado, xd->amx_alen))
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ahhmacsha1_input: bad auth\n"); /* XXX */
#endif
	ahstat.ahs_badauth++;
	m_freem(m);
	return NULL;
    }
	
    if (xd->amx_wnd >= 0)
    {
	btsx = ntohq(ahp->ah_rpl);
	if ((errc = checkreplaywindow64(btsx, &(xd->amx_rpl), 
					xd->amx_wnd, &(xd->amx_bitmap)))
	    != 0)
	{
	    switch(errc)
	    {
		case 1:
#ifdef ENCDEBUG
		    printf("ahhmacsha1_input: replay counter wrapped\n");
#endif
		    ahstat.ahs_wrap++;
		    break;
		case 2:
#ifdef ENCDEBUG
		    printf("ahhmacsha1_input: received old packet\n");
#endif
		    ahstat.ahs_replay++;
		    break;
		case 3:
#ifdef ENCDEBUG
		    printf("ahhmacsha1_input: packet already received\n");
#endif
		    ahstat.ahs_replay++;
		    break;
	    }
	    m_freem(m);
	    return NULL;
	}
    }
	
    ipo = *ip;
    ipo.ip_p = ah->ah_nh;

    m->m_len -= (ohlen - sizeof(struct ip));
    m->m_data += (ohlen - sizeof(struct ip));
    m->m_pkthdr.len -= (ohlen - sizeof(struct ip));
    m->m_pkthdr.rcvif = rcvif;	/* this should not be necessary */

    ip = mtod(m, struct ip *);
    *ip = ipo;
    ip->ip_len = htons(ip->ip_len - ohlen + 2 * sizeof (struct ip));
    HTONS(ip->ip_id);
    HTONS(ip->ip_off);
    ip->ip_sum = 0;
    ip->ip_sum = in_cksum(m, sizeof (struct ip));

    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);

    return m;
}


#define AHXPORT 

int
ahhmacsha1_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb, 
		  struct mbuf **mp)
{
    struct ahhmacsha1_xdata *xd;
    struct ip *ip, ipo;
    struct ah *ah;
    struct ahhmacsha1 *ahp, aho;
    register int len, off, count;
    register struct mbuf *m0;
    SHA1_CTX ctx;
    int ilen, ohlen;
	
    ahstat.ahs_output++;
    m = m_pullup(m, sizeof (struct ip));
    if (m == NULL)
      return ENOBUFS;
	
    ip = mtod(m, struct ip *);
	
    xd = (struct ahhmacsha1_xdata *)tdb->tdb_xdata;

    ilen = ntohs(ip->ip_len);

#ifdef AHXPORT
    ohlen = AH_FLENGTH + xd->amx_alen;
#else
    ohlen = sizeof (struct ip) + AH_FLENGTH + xd->amx_alen;
#endif
    if (xd->amx_wnd >= 0)
      ohlen += HMACSHA1_RPLENGTH;

    ipo.ip_v = IPVERSION;
    ipo.ip_hl = 5;
    ipo.ip_tos = 0;
    ipo.ip_len = htons(ohlen + ilen);
    ipo.ip_id = ip->ip_id;
    ipo.ip_off = htons(ntohs(ip->ip_off) & IP_DF);
    ipo.ip_ttl = 0;
    ipo.ip_p = IPPROTO_AH;
    ipo.ip_sum = 0;
#ifdef AHXPORT
    ipo.ip_src = ip->ip_src;
    ipo.ip_dst = ip->ip_dst;
    aho.ah_nh = ip->ip_p;
#else
    ipo.ip_src = gw->sen_ipsp_src;
    ipo.ip_dst = gw->sen_ipsp_dst;
    aho.ah_nh = IPPROTO_IP4;
#endif
    aho.ah_hl = (xd->amx_alen >> 2);
    if (xd->amx_wnd >= 0)
      aho.ah_hl += (HMACSHA1_RPLENGTH / sizeof(u_int32_t));
    aho.ah_rv = 0;
    aho.ah_spi = tdb->tdb_spi;

    if (xd->amx_wnd >= 0)
    {
	if (xd->amx_rpl == 0)
	{
#ifdef ENCDEBUG
	    printf("ahhmacsha1_output: key should have changed long ago\n");
#endif
	    ahstat.ahs_wrap++;
	    return NULL;
	}
    }

    aho.ah_rpl = htonq(xd->amx_rpl++);

    ctx = xd->amx_ictx;
    SHA1Update(&ctx, (unsigned char *)&ipo, sizeof (struct ip));
    if (xd->amx_wnd >= 0)
      SHA1Update(&ctx, (unsigned char *)&aho, 
		 AH_FLENGTH + HMACSHA1_RPLENGTH);
    else
      SHA1Update(&ctx, (unsigned char *)&aho, AH_FLENGTH);
    SHA1Update(&ctx, ipseczeroes, xd->amx_alen);

#ifdef AHXPORT
    off = sizeof (struct ip);
#else	
    off = 0;
#endif

    /*
     * Code shamelessly stolen from m_copydata
     */
    len = m->m_pkthdr.len - off;
	
    m0 = m;

    while (len > 0)
    {
	if (m0 == 0)
	  panic("ahhmacsha1_output: m_copydata");
	count = min(m0->m_len - off, len);
	SHA1Update(&ctx, mtod(m0, unsigned char *) + off, count);

	len -= count;
	off = 0;
	m0 = m0->m_next;
    }

    SHA1Final((unsigned char *)(&(aho.ah_data[0])), &ctx);
    ctx = xd->amx_octx;
    SHA1Update(&ctx, (unsigned char *)(&(aho.ah_data[0])), 
	       HMACSHA1_HASHLEN);
    SHA1Final((unsigned char *)(&(aho.ah_data[0])), &ctx);

    ipo.ip_tos = ip->ip_tos;
    ipo.ip_id = ip->ip_id;
    ipo.ip_off = ip->ip_off;
    ipo.ip_ttl = ip->ip_ttl;
/*	ipo.ip_len = ntohs(ipo.ip_len); */
	
    M_PREPEND(m, ohlen, M_DONTWAIT);
    if (m == NULL)
      return ENOBUFS;

    m = m_pullup(m, ohlen + sizeof (struct ip));
    if (m == NULL)
      return ENOBUFS;
	
    ip = mtod(m, struct ip *);
    ah = (struct ah *)(ip + 1);
    ahp = (struct ahhmacsha1 *)ah; 
    *ip = ipo;
    ah->ah_nh = aho.ah_nh;
    ah->ah_hl = aho.ah_hl;
    ah->ah_rv = aho.ah_rv;
    ah->ah_spi = aho.ah_spi;
    if (xd->amx_wnd >= 0)
    {
	ahp->ah_rpl = aho.ah_rpl;
	bcopy((unsigned char *)(&(aho.ah_data[0])), 
	      ahp->ah_data, xd->amx_alen);
    }
    else
      bcopy((unsigned char *)(&(aho.ah_data[0])), 
	    ah->ah_data, xd->amx_alen);

    *mp = m;
	
    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ip->ip_len - (ip->ip_hl << 2) - AH_FLENGTH -
		          xd->amx_alen;
    if (xd->amx_wnd >= 0)
      tdb->tdb_cur_bytes -= HMACSHA1_RPLENGTH;

    return 0;
}
@


1.11
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ahhmacsha1.c,v 1.10 1997/06/25 07:53:22 provos Exp $	*/
@


1.10
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ahhmacsha1.c,v 1.9 1997/06/24 20:57:25 provos Exp $	*/
d380 2
a381 1
ahhmacsha1_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb, struct mbuf **mp)
@


1.9
log
@use ntohs instead of NTOHS for counters
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ahhmacsha1.c,v 1.8 1997/06/24 20:48:40 provos Exp $	*/
d243 4
d250 1
a250 1
		  continue;
d258 1
a258 1
		  continue;
d264 1
a264 1
		  continue;
d370 2
a371 2
    tdb->tdb_packets++;
    tdb->tdb_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);
d523 3
a525 3
    tdb->tdb_packets++;
    tdb->tdb_bytes += ip->ip_len - (ip->ip_hl << 2) - AH_FLENGTH -
		      xd->amx_alen;
d527 1
a527 1
      tdb->tdb_bytes -= HMACSHA1_RPLENGTH;
@


1.8
log
@correct AH options hashing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ahhmacsha1.c,v 1.6 1997/06/20 05:41:48 provos Exp $	*/
d367 1
a367 1
    tdb->tdb_bytes += NTOHS(ip->ip_len) - (ip->ip_hl << 2);
@


1.7
log
@handle IP options in AH + allow IP options in outgoing encapsulated packets
+ usage counters for later use with keymanagement processes
@
text
@d240 1
a240 2
	  SHA1Update(&ctx, &optval, 1);
	  switch (IPOPT_NUMBER(optval))
d244 1
d252 1
a252 1
		  SHA1Update(&ctx, (u_int8_t *)ip + off + 1, optval - 1);
d257 2
a258 2
		  SHA1Update(&ctx, &optval, 1);
		  SHA1Update(&ctx, ipseczeroes, optval - 2);
@


1.6
log
@ah-sha1 + esp-3des + indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ahhmacsha1.c,v 1.5 1997/02/26 03:01:03 angelos Exp $	*/
d161 2
a162 1
	
d188 17
a204 1
    ah = (struct ah *)(ip + 1);
d225 1
a225 1
    ipo.ip_len += sizeof (struct ip);	/* adjusted in ip_intr() */
d233 31
a263 1
    SHA1Update(&ctx, (unsigned char *)&ipo, sizeof (struct ip));
d365 4
d518 7
@


1.5
log
@I/O packet counters for IP-in-IP and AH.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ahhmacsha1.c,v 1.4 1997/02/24 14:06:38 niklas Exp $	*/
d71 1
a71 1
	return 0;
d82 45
a126 14
	struct ahhmacsha1_xdata *xd;
	struct ahhmacsha1_xencap txd;
	struct encap_msghdr *em;
	int len;
	
	tdbp->tdb_xform = xsp;

	MALLOC(tdbp->tdb_xdata, caddr_t, sizeof (struct ahhmacsha1_xdata),
	       M_XDATA, M_WAITOK);
	if (tdbp->tdb_xdata == NULL)
	  return ENOBUFS;
	bzero(tdbp->tdb_xdata, sizeof (struct ahhmacsha1_xdata));
	bzero(&txd, sizeof(struct ahhmacsha1_xencap));
	xd = (struct ahhmacsha1_xdata *)tdbp->tdb_xdata;
d128 1
a128 31
	em = mtod(m, struct encap_msghdr *);
	if (em->em_msglen - EMT_SETSPI_FLEN > sizeof (struct ahhmacsha1_xencap))
	{
		free((caddr_t)tdbp->tdb_xdata, M_XDATA);
		tdbp->tdb_xdata = NULL;
		return EINVAL;
	}
	
	m_copydata(m, EMT_SETSPI_FLEN, em->em_msglen - EMT_SETSPI_FLEN, (caddr_t)&txd);

	xd->amx_rpl = 1;
	xd->amx_alen = txd.amx_alen;
	xd->amx_bitmap = 0;
	xd->amx_wnd = txd.amx_wnd;
	
	SHA1Init(&(xd->amx_ictx));
	SHA1Init(&(xd->amx_octx));
	
	for (len = 0; len < AHHMACSHA1_KMAX; len++)
	  txd.amx_key[len] ^= HMACSHA1_IPAD_VAL;

	SHA1Update(&(xd->amx_ictx), txd.amx_key, AHHMACSHA1_KMAX);

	for (len = 0; len < AHHMACSHA1_KMAX; len++)
	  txd.amx_key[len] ^= (HMACSHA1_IPAD_VAL ^ HMACSHA1_OPAD_VAL);

	SHA1Update(&(xd->amx_octx), txd.amx_key, AHHMACSHA1_KMAX);
	bzero(&txd, sizeof(struct ahhmacsha1_xencap));
	bzero(ipseczeroes, IPSEC_ZEROES_SIZE);	/* paranoid */

	return 0;
d138 2
a139 2
	FREE(tdbp->tdb_xdata, M_XDATA);
	return 0;
d152 18
a169 18
	struct ahhmacsha1_xdata *xd;
	struct ip *ip, ipo;
	struct ah *ah;
	struct ahhmacsha1 aho, *ahp;
	struct ifnet *rcvif;
	int ohlen, len, count, off, ado, errc;
	u_int64_t btsx;
	struct mbuf *m0;
	SHA1_CTX ctx; 
	
	xd = (struct ahhmacsha1_xdata *)tdb->tdb_xdata;
	ohlen = sizeof (struct ip) + AH_FLENGTH + xd->amx_alen;
	if (xd->amx_wnd >= 0)
	  ohlen += HMACSHA1_RPLENGTH;

	rcvif = m->m_pkthdr.rcvif;
	if (rcvif == NULL)
	{
d171 2
a172 2
		if (encdebug)
		  printf("ahhmacsha1_input: receive interface is NULL!!!\n");
d174 2
a175 2
		rcvif = &loif;
	}
d177 3
a179 1
	if (m->m_len < ohlen)
d181 2
a182 5
		if ((m = m_pullup(m, ohlen)) == NULL)
		{
			ahstat.ahs_hdrops++;
			return NULL;
		}
d184 1
d186 8
a193 8
	ip = mtod(m, struct ip *);
	ah = (struct ah *)(ip + 1);
	ahp = (struct ahhmacsha1 *)ah;

        if (xd->amx_wnd >= 0)
          ado = HMACSHA1_RPLENGTH;
        else
          ado = 0;
d195 2
a196 2
        if (ah->ah_hl * sizeof(u_int32_t) != xd->amx_alen + ado)
        {
d198 2
a199 2
                if (encdebug)
                  printf("ahhmacsha1_input: bad authenticator length\n");
d201 50
a250 39
                ahstat.ahs_badauthl++;
                m_freem(m);
                return NULL;
        }

	ipo = *ip;
	ipo.ip_tos = 0;
	ipo.ip_len += sizeof (struct ip);	/* adjusted in ip_intr() */
	HTONS(ipo.ip_len);
	HTONS(ipo.ip_id);
	ipo.ip_off = htons(ipo.ip_off & IP_DF);	/* XXX -- and the C bit? */
	ipo.ip_ttl = 0;
	ipo.ip_sum = 0;

	ctx = xd->amx_ictx;
	SHA1Update(&ctx, (unsigned char *)&ipo, sizeof (struct ip));
	if (xd->amx_wnd >= 0)
	  SHA1Update(&ctx, (unsigned char *)ahp, 
		     AH_FLENGTH + HMACSHA1_RPLENGTH);
	else
	  SHA1Update(&ctx, (unsigned char *)ahp, AH_FLENGTH);
	SHA1Update(&ctx, ipseczeroes, xd->amx_alen);

	/*
	 * Code shamelessly stolen from m_copydata
	 */
	off = ohlen;
	len = m->m_pkthdr.len - off;
	m0 = m;
	
	while (off > 0)
	{
		if (m0 == 0)
		  panic("ahhmacsha1_input: m_copydata (off)");
		if (off < m0->m_len)
		  break;
		off -= m0->m_len;
		m0 = m0->m_next;
	}
d252 5
a256 16
	while (len > 0)
	{
		if (m0 == 0)
		  panic("ahhmacsha1_input: m_copydata (copy)");
		count = min(m0->m_len - off, len);
		SHA1Update(&ctx, mtod(m0, unsigned char *) + off, count);
		len -= count;
		off = 0;
		m0 = m0->m_next;
	}

	SHA1Final((unsigned char *)(&(aho.ah_data[0])), &ctx);
	ctx = xd->amx_octx;
	SHA1Update(&ctx, (unsigned char *)(&(aho.ah_data[0])), 
		   HMACSHA1_HASHLEN);
	SHA1Final((unsigned char *)(&(aho.ah_data[0])), &ctx);
d258 2
a259 2
	if (bcmp(aho.ah_data, ah->ah_data + ado, xd->amx_alen))
	{
d261 2
a262 2
		if (encdebug)
		  printf("ahhmacsha1_input: bad auth\n"); /* XXX */
d264 11
a274 6
		ahstat.ahs_badauth++;
		m_freem(m);
		return NULL;
	}
	
	if (xd->amx_wnd >= 0)
d276 3
a278 8
	    	btsx = ntohq(ahp->ah_rpl);
		if ((errc = checkreplaywindow64(btsx, &(xd->amx_rpl), 
					       xd->amx_wnd, &(xd->amx_bitmap)))
		    != 0)
		{
			switch(errc)
			{
				case 1:
d280 1
a280 1
					printf("ahhmacsha1_input: replay counter wrapped\n");
d282 3
a284 3
					ahstat.ahs_wrap++;
					break;
				case 2:
d286 1
a286 1
					printf("ahhmacsha1_input: received old packet\n");
d288 3
a290 3
					ahstat.ahs_replay++;
					break;
				case 3:
d292 1
a292 1
					printf("ahhmacsha1_input: packet already received\n");
d294 5
a298 6
					ahstat.ahs_replay++;
					break;
			}
			m_freem(m);
			return NULL;
		}
d300 1
d302 2
a303 2
	ipo = *ip;
	ipo.ip_p = ah->ah_nh;
d305 12
a316 12
	m->m_len -= (ohlen - sizeof(struct ip));
	m->m_data += (ohlen - sizeof(struct ip));
	m->m_pkthdr.len -= (ohlen - sizeof(struct ip));
	m->m_pkthdr.rcvif = rcvif;	/* this should not be necessary */

	ip = mtod(m, struct ip *);
	*ip = ipo;
	ip->ip_len = htons(ip->ip_len - ohlen + 2 * sizeof (struct ip));
	HTONS(ip->ip_id);
	HTONS(ip->ip_off);
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m, sizeof (struct ip));
d318 1
a318 1
	return m;
d327 13
a339 13
	struct ahhmacsha1_xdata *xd;
	struct ip *ip, ipo;
	struct ah *ah;
	struct ahhmacsha1 *ahp, aho;
	register int len, off, count;
	register struct mbuf *m0;
	SHA1_CTX ctx;
	int ilen, ohlen;
	
	ahstat.ahs_output++;
	m = m_pullup(m, sizeof (struct ip));
	if (m == NULL)
	  return ENOBUFS;
d341 1
a341 1
	ip = mtod(m, struct ip *);
d343 1
a343 1
	xd = (struct ahhmacsha1_xdata *)tdb->tdb_xdata;
d345 1
a345 1
	ilen = ntohs(ip->ip_len);
d348 1
a348 1
	ohlen = AH_FLENGTH + xd->amx_alen;
d350 1
a350 1
	ohlen = sizeof (struct ip) + AH_FLENGTH + xd->amx_alen;
d352 2
a353 2
	if (xd->amx_wnd >= 0)
	  ohlen += HMACSHA1_RPLENGTH;
d355 9
a363 9
	ipo.ip_v = IPVERSION;
	ipo.ip_hl = 5;
	ipo.ip_tos = 0;
	ipo.ip_len = htons(ohlen + ilen);
	ipo.ip_id = ip->ip_id;
	ipo.ip_off = htons(ntohs(ip->ip_off) & IP_DF);
	ipo.ip_ttl = 0;
	ipo.ip_p = IPPROTO_AH;
	ipo.ip_sum = 0;
d365 3
a367 3
	ipo.ip_src = ip->ip_src;
	ipo.ip_dst = ip->ip_dst;
	aho.ah_nh = ip->ip_p;
d369 3
a371 3
	ipo.ip_src = gw->sen_ipsp_src;
	ipo.ip_dst = gw->sen_ipsp_dst;
	aho.ah_nh = IPPROTO_IP4;
d373 9
a381 7
	aho.ah_hl = (xd->amx_alen >> 2);
	if (xd->amx_wnd >= 0)
	  aho.ah_hl += (HMACSHA1_RPLENGTH / sizeof(u_int32_t));
	aho.ah_rv = 0;
	aho.ah_spi = tdb->tdb_spi;

	if (xd->amx_wnd >= 0)
a382 2
	    if (xd->amx_rpl == 0)
	    {
d384 1
a384 1
		printf("ahhmacsha1_output: key should have changed long ago\n");
d386 2
a387 3
		ahstat.ahs_wrap++;
		return NULL;
	    }
d389 1
d391 1
a391 1
        aho.ah_rpl = htonq(xd->amx_rpl++);
d393 8
a400 8
	ctx = xd->amx_ictx;
	SHA1Update(&ctx, (unsigned char *)&ipo, sizeof (struct ip));
	if (xd->amx_wnd >= 0)
	  SHA1Update(&ctx, (unsigned char *)&aho, 
		     AH_FLENGTH + HMACSHA1_RPLENGTH);
	else
	  SHA1Update(&ctx, (unsigned char *)&aho, AH_FLENGTH);
	SHA1Update(&ctx, ipseczeroes, xd->amx_alen);
d403 1
a403 1
	off = sizeof (struct ip);
d405 1
a405 1
	off = 0;
d408 13
a420 6
	/*
	 * Code shamelessly stolen from m_copydata
	 */
	len = m->m_pkthdr.len - off;
	
	m0 = m;
d422 4
a425 11
	while (len > 0)
	{
		if (m0 == 0)
		  panic("ahhmacsha1_output: m_copydata");
		count = min(m0->m_len - off, len);
		SHA1Update(&ctx, mtod(m0, unsigned char *) + off, count);

		len -= count;
		off = 0;
		m0 = m0->m_next;
	}
d427 10
a436 10
	SHA1Final((unsigned char *)(&(aho.ah_data[0])), &ctx);
	ctx = xd->amx_octx;
	SHA1Update(&ctx, (unsigned char *)(&(aho.ah_data[0])), 
		   HMACSHA1_HASHLEN);
	SHA1Final((unsigned char *)(&(aho.ah_data[0])), &ctx);

	ipo.ip_tos = ip->ip_tos;
	ipo.ip_id = ip->ip_id;
	ipo.ip_off = ip->ip_off;
	ipo.ip_ttl = ip->ip_ttl;
d439 25
a463 25
	M_PREPEND(m, ohlen, M_DONTWAIT);
	if (m == NULL)
	  return ENOBUFS;

	m = m_pullup(m, ohlen + sizeof (struct ip));
	if (m == NULL)
	  return ENOBUFS;
	
	ip = mtod(m, struct ip *);
	ah = (struct ah *)(ip + 1);
	ahp = (struct ahhmacsha1 *)ah; 
	*ip = ipo;
	ah->ah_nh = aho.ah_nh;
	ah->ah_hl = aho.ah_hl;
	ah->ah_rv = aho.ah_rv;
	ah->ah_spi = aho.ah_spi;
	if (xd->amx_wnd >= 0)
	{
	  	ahp->ah_rpl = aho.ah_rpl;
		bcopy((unsigned char *)(&(aho.ah_data[0])), 
		      ahp->ah_data, xd->amx_alen);
	}
	else
	  bcopy((unsigned char *)(&(aho.ah_data[0])), 
	        ah->ah_data, xd->amx_alen);
d465 1
a465 1
	*mp = m;
d467 1
a467 1
	return 0;
@


1.4
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d335 1
a335 1
	
@


1.3
log
@Fixed problem with authenticator length checking.
@
text
@d1 2
@


1.2
log
@-nostdinc and big endian cleanup
@
text
@d192 1
a192 1
        if (ah->ah_hl != xd->amx_alen + ado)
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d38 2
d41 1
d46 1
a55 2
#include <sys/socketvar.h>
#include <net/raw_cb.h>
@
