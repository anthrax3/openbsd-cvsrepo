head	1.19;
access;
symbols
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.6
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.8
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.10
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.19
date	2013.08.20.09.14.26;	author mpi;	state dead;
branches;
next	1.18;

1.18
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.05.21.40.38;	author dhill;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.19.12.25.12;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.09.15.48.59;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.17.10.22.06;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.16.14.28.57;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.19.06.37.37;	author itojun;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	99.12.08.06.50.18;	author itojun;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	97.09.28.23.09.55;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.03.17.14.31;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	96.06.29.20.05.42;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.04.17.08;	author chuck;	state Exp;
branches;
next	1.2;

1.2
date	96.06.21.21.35.19;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	96.06.21.15.14.35;	author chuck;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.40.07;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.8.6.1
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@tedu netnatm and ueagle(4).

ok mikeb@@, sthen@@, tedu@@ (implied), doc bits ok jmc@@
@
text
@/*      $OpenBSD: if_atm.c,v 1.18 2013/03/28 16:45:16 tedu Exp $       */

/*
 *
 * Copyright (c) 1996 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *	Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * IP <=> ATM address resolution.
 */

#if defined(INET) || defined(INET6)

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <net/if_atm.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_atm.h>

#ifdef NATM
#include <netnatm/natm.h>
#endif


#define SDL(s) ((struct sockaddr_dl *)s)

/*
 * atm_rtrequest: handle ATM rt request (in support of generic code)
 *   inputs: "req" = request code
 *           "rt" = route entry
 *           "sa" = sockaddr
 */

void
atm_rtrequest(int req, struct rtentry *rt, struct rt_addrinfo *info)
{
	struct sockaddr *gate = rt->rt_gateway;
	struct atm_pseudoioctl api;
	struct rt_addrinfo rtinfo;
#ifdef NATM
	struct sockaddr_in *sin;
	struct natmpcb *npcb = NULL;
	struct atm_pseudohdr *aph;
#endif
	static struct sockaddr_dl null_sdl = {sizeof(null_sdl), AF_LINK};

	if (rt->rt_flags & RTF_GATEWAY)   /* link level requests only */
		return;

	switch (req) {

	case RTM_RESOLVE: /* resolve: only happens when cloning */
		printf("atm_rtrequest: RTM_RESOLVE request detected?\n");
		break;

	case RTM_ADD:

		/*
		 * route added by a command (e.g. ifconfig, route, arp...).
		 *
		 * first check to see if this is not a host route, in which
		 * case we are being called via "ifconfig" to set the address.
		 */

		if ((rt->rt_flags & RTF_HOST) == 0) {
			rt_setgate(rt,rt_key(rt),(struct sockaddr *)&null_sdl, 0);
			gate = rt->rt_gateway;
			SDL(gate)->sdl_type = rt->rt_ifp->if_type;
			SDL(gate)->sdl_index = rt->rt_ifp->if_index;
			break;
		}

		if ((rt->rt_flags & RTF_CLONING) != 0) {
			printf("atm_rtrequest: cloning route detected?\n");
			break;
		}
		if (gate->sa_family != AF_LINK ||
		    gate->sa_len < sizeof(null_sdl)) {
			log(LOG_DEBUG, "atm_rtrequest: bad gateway value\n");
			break;
		}

#ifdef DIAGNOSTIC
		if (rt->rt_ifp->if_ioctl == NULL) panic("atm null ioctl");
#endif

#ifdef NATM
		/*
		 * let native ATM know we are using this VCI/VPI
		 * (i.e. reserve it)
		 */
		sin = (struct sockaddr_in *) rt_key(rt);
		if (sin->sin_family != AF_INET)
			goto failed;
		aph = (struct atm_pseudohdr *) LLADDR(SDL(gate));
		npcb = npcb_add(NULL, rt->rt_ifp, ATM_PH_VCI(aph),
						ATM_PH_VPI(aph));
		if (npcb == NULL)
			goto failed;
		npcb->npcb_flags |= NPCB_IP;
		npcb->ipaddr.s_addr = sin->sin_addr.s_addr;
		/* XXX: move npcb to llinfo when ATM ARP is ready */
		rt->rt_llinfo = (caddr_t) npcb;
		rt->rt_flags |= RTF_LLINFO;
#endif
		/*
		 * let the lower level know this circuit is active
		 */
		bcopy(LLADDR(SDL(gate)), &api.aph, sizeof(api.aph));
		api.rxhand = NULL;
		if (rt->rt_ifp->if_ioctl(rt->rt_ifp, SIOCATMENA,
							(caddr_t)&api) != 0) {
			printf("atm: couldn't add VC\n");
			goto failed;
		}

		SDL(gate)->sdl_type = rt->rt_ifp->if_type;
		SDL(gate)->sdl_index = rt->rt_ifp->if_index;

		break;

failed:
#ifdef NATM
		if (npcb) {
			npcb_free(npcb, NPCB_DESTROY);
			rt->rt_llinfo = NULL;
			rt->rt_flags &= ~RTF_LLINFO;
		}
#endif
		bzero(&rtinfo, sizeof(rtinfo));
		rtinfo.rti_flags = rt->rt_flags;
		rtinfo.rti_info[RTAX_DST] = rt_key(rt);
		rtinfo.rti_info[RTAX_NETMASK] = rt_mask(rt);

		rtrequest1(RTM_DELETE, &rtinfo, rt->rt_priority, NULL, 0);
		break;

	case RTM_DELETE:

#ifdef NATM
		/*
		 * tell native ATM we are done with this VC
		 */

		if (rt->rt_flags & RTF_LLINFO) {
			npcb_free((struct natmpcb *)rt->rt_llinfo,
								NPCB_DESTROY);
			rt->rt_llinfo = NULL;
			rt->rt_flags &= ~RTF_LLINFO;
		}
#endif
		/*
		 * tell the lower layer to disable this circuit
		 */

		bcopy(LLADDR(SDL(gate)), &api.aph, sizeof(api.aph));
		api.rxhand = NULL;
		(void)rt->rt_ifp->if_ioctl(rt->rt_ifp, SIOCATMDIS,
							(caddr_t)&api);

		break;
	}
}

/*
 * atmresolve:
 *   inputs:
 *     [1] "rt" = the link level route to use (or null if need to look one up)
 *     [2] "m" = mbuf containing the data to be sent
 *     [3] "dst" = sockaddr_in (IP) address of dest.
 *   output:
 *     [4] "desten" = ATM pseudo header which we will fill in VPI/VCI info
 *   return:
 *     0 == resolve FAILED; note that "m" gets m_freem'd in this case
 *     1 == resolve OK; desten contains result
 *
 *   XXX: will need more work if we wish to support ATMARP in the kernel,
 *   but this is enough for PVCs entered via the "route" command.
 */

int
atmresolve(struct rtentry *rt, struct mbuf *m, struct sockaddr *dst,
    struct atm_pseudohdr *desten)
{
	struct sockaddr_dl *sdl;

	if (m->m_flags & (M_BCAST|M_MCAST)) {
		log(LOG_INFO,
		    "atmresolve: BCAST/MCAST packet detected/dumped\n");
		goto bad;
	}

	if (rt == NULL) {
		rt = rtalloc1(dst, 0, m->m_pkthdr.rdomain);
		if (rt == NULL) goto bad; /* failed */
		rt->rt_refcnt--;	/* don't keep LL references */
		if ((rt->rt_flags & RTF_GATEWAY) != 0 ||
			(rt->rt_flags & RTF_LLINFO) == 0 ||
			/* XXX: are we using LLINFO? */
			rt->rt_gateway->sa_family != AF_LINK) {
				goto bad;
		}
	}

	/*
	 * note that rt_gateway is a sockaddr_dl which contains the
	 * atm_pseudohdr data structure for this route.   we currently
	 * don't need any rt_llinfo info (but will if we want to support
	 * ATM ARP [c.f. if_ether.c]).
	 */

	sdl = SDL(rt->rt_gateway);

	/*
	 * Check the address family and length is valid, the address
	 * is resolved; otherwise, try to resolve.
	 */


	if (sdl->sdl_family == AF_LINK && sdl->sdl_alen == sizeof(*desten)) {
		bcopy(LLADDR(sdl), desten, sdl->sdl_alen);
		return (1);	/* ok, go for it! */
	}

	/*
	 * we got an entry, but it doesn't have valid link address
	 * info in it (it is prob. the interface route, which has
	 * sdl_alen == 0).    dump packet.  (fall through to "bad").
	 */

bad:
	m_freem(m);
	return (0);
}
#endif /* INET */
@


1.18
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.17 2011/07/05 21:40:38 dhill Exp $       */
@


1.17
log
@ansify

ok claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.16 2010/05/07 13:33:16 claudio Exp $       */
a50 1
#include <sys/proc.h>
@


1.16
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.15 2008/05/19 12:25:12 claudio Exp $       */
d79 1
a79 4
atm_rtrequest(req, rt, info)
	int req;
	struct rtentry *rt;
	struct rt_addrinfo *info;
d226 2
a227 5
atmresolve(rt, m, dst, desten)
	struct rtentry *rt;
	struct mbuf *m;
	struct sockaddr *dst;
	struct atm_pseudohdr *desten;	/* OUT */
@


1.15
log
@Unbreak builds for kernels that have atm interfaces. Found the hard way by
Theo on an alpha ramdisk. OK deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.14 2008/05/09 15:48:59 claudio Exp $       */
d244 1
a244 1
		rt = RTALLOC1(dst, 0);
@


1.14
log
@more rtrequest() to rtrequest1() replacement.
OK henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.13 2006/06/17 10:22:06 henning Exp $       */
d86 1
a86 1
	struct rt_addrinfo info;
d177 4
a180 4
		bzero(&info, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
d182 1
a182 1
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 0);
@


1.13
log
@unbreak; from theo
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.12 2005/04/16 14:28:57 deraadt Exp $       */
d86 1
d177 6
a182 2
		rtrequest(RTM_DELETE, rt_key(rt), (struct sockaddr *)0,
			rt_mask(rt), 0, (struct rtentry **) 0, 0);
@


1.12
log
@re-register
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.11 2003/12/10 07:22:43 itojun Exp $       */
d112 1
a112 1
			rt_setgate(rt,rt_key(rt),(struct sockaddr *)&null_sdl);
d177 1
a177 1
			rt_mask(rt), 0, (struct rtentry **) 0);
@


1.11
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.10 2002/09/11 03:15:36 itojun Exp $       */
d225 4
a228 6

register struct rtentry *rt;
struct mbuf *m;
register struct sockaddr *dst;
register struct atm_pseudohdr *desten;	/* OUT */

@


1.10
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.9 2002/06/09 16:26:10 itojun Exp $       */
d81 1
a81 1
	register struct rtentry *rt;
d84 1
a84 1
	register struct sockaddr *gate = rt->rt_gateway;
@


1.9
log
@whitespace
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.8 2001/01/19 06:37:37 itojun Exp $       */
d269 1
a269 1
		return(1);	/* ok, go for it! */
d280 1
a280 1
	return(0);
@


1.8
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.7 1999/12/08 06:50:18 itojun Exp $       */
d18 1
a18 1
 *      This product includes software developed by Charles D. Cranor and 
d111 1
a111 1
		if ((rt->rt_flags & RTF_HOST) == 0) { 
d142 1
a142 1
		npcb = npcb_add(NULL, rt->rt_ifp, ATM_PH_VCI(aph), 
d144 1
a144 1
		if (npcb == NULL) 
d157 1
a157 1
		if (rt->rt_ifp->if_ioctl(rt->rt_ifp, SIOCATMENA, 
d188 1
a188 1
			npcb_free((struct natmpcb *)rt->rt_llinfo, 
d200 1
a200 1
		(void)rt->rt_ifp->if_ioctl(rt->rt_ifp, SIOCATMDIS, 
d215 1
a215 1
 *   return: 
d244 1
a244 1
		if ((rt->rt_flags & RTF_GATEWAY) != 0 || 
d253 1
a253 1
	 * note that rt_gateway is a sockaddr_dl which contains the 
@


1.8.6.1
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.8 2001/01/19 06:37:37 itojun Exp $       */
d18 1
a18 1
 *      This product includes software developed by Charles D. Cranor and
d111 1
a111 1
		if ((rt->rt_flags & RTF_HOST) == 0) {
d142 1
a142 1
		npcb = npcb_add(NULL, rt->rt_ifp, ATM_PH_VCI(aph),
d144 1
a144 1
		if (npcb == NULL)
d157 1
a157 1
		if (rt->rt_ifp->if_ioctl(rt->rt_ifp, SIOCATMENA,
d188 1
a188 1
			npcb_free((struct natmpcb *)rt->rt_llinfo,
d200 1
a200 1
		(void)rt->rt_ifp->if_ioctl(rt->rt_ifp, SIOCATMDIS,
d215 1
a215 1
 *   return:
d244 1
a244 1
		if ((rt->rt_flags & RTF_GATEWAY) != 0 ||
d253 1
a253 1
	 * note that rt_gateway is a sockaddr_dl which contains the
d269 1
a269 1
		return (1);	/* ok, go for it! */
d280 1
a280 1
	return (0);
@


1.7
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.6 1997/09/28 23:09:55 deraadt Exp $       */
d79 1
a79 1
atm_rtrequest(req, rt, sa)
d82 1
a82 1
	struct sockaddr *sa;
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.8 2001/01/19 06:37:37 itojun Exp $       */
d79 1
a79 1
atm_rtrequest(req, rt, info)
d82 1
a82 1
	struct rt_addrinfo *info;
@


1.7.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*      $OpenBSD$       */
d18 1
a18 1
 *      This product includes software developed by Charles D. Cranor and
d111 1
a111 1
		if ((rt->rt_flags & RTF_HOST) == 0) {
d142 1
a142 1
		npcb = npcb_add(NULL, rt->rt_ifp, ATM_PH_VCI(aph),
d144 1
a144 1
		if (npcb == NULL)
d157 1
a157 1
		if (rt->rt_ifp->if_ioctl(rt->rt_ifp, SIOCATMENA,
d188 1
a188 1
			npcb_free((struct natmpcb *)rt->rt_llinfo,
d200 1
a200 1
		(void)rt->rt_ifp->if_ioctl(rt->rt_ifp, SIOCATMDIS,
d215 1
a215 1
 *   return:
d244 1
a244 1
		if ((rt->rt_flags & RTF_GATEWAY) != 0 ||
d253 1
a253 1
	 * note that rt_gateway is a sockaddr_dl which contains the
d269 1
a269 1
		return (1);	/* ok, go for it! */
d280 1
a280 1
	return (0);
@


1.7.2.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d81 1
a81 1
	struct rtentry *rt;
d84 1
a84 1
	struct sockaddr *gate = rt->rt_gateway;
@


1.6
log
@more \n in log()
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.5 1996/07/03 17:14:31 chuck Exp $       */
d39 1
a39 1
#ifdef INET
@


1.5
log
@ported to FreeBSD 2.2-960612-SNAP.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.3 1996/06/29 20:07:08 chuck Exp $       */
d125 1
a125 1
			log(LOG_DEBUG, "atm_rtrequest: bad gateway value");
d235 2
a236 1
		log(LOG_INFO, "atmresolve: BCAST/MCAST packet detected/dumped");
@


1.4
log
@change:
  - change asock to rxhand and adjust all for this [esp atm_input]
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.2 1996/06/26 04:18:44 chuck Exp $       */
d240 1
a240 1
		rt = rtalloc1(dst, 0);
@


1.3
log
@fixes/new stuff:
[1] if user tries to enter in a bogus PVC don't leave it in the routing
        table ... remove it
[2] change ioctl arg to include rxso for lower layer
[3] add hooks (inside "NATM" ifdef) for native mode atm sockets so that
        they don't clash with IP PVCs.   [i am still debugging the native
        mode atm socket protosw code]
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.1 1996/06/22 01:47:41 chuck Exp $       */
d156 1
a156 1
		api.asock = NULL;
d199 1
a199 1
		api.asock = NULL;
@


1.2
log
@use correct copyright
@
text
@d1 1
a1 1
/*      $OpenBSD: if_atm.c,v 1.1 1996/06/21 15:14:35 chuck Exp $       */
d18 1
a18 1
 *      This product includes software developed by Charles D. Cranor and
d64 5
d85 6
d133 19
d155 2
d158 1
a158 1
				LLADDR(SDL(gate))) != 0) {
d160 1
a160 2
			/* XXX: do we need to do anything else to recover? */
			break;
d168 12
d182 12
d197 5
a201 2
		(void)rt->rt_ifp->if_ioctl(rt->rt_ifp, SIOCATMDIS,
				LLADDR(SDL(gate)));
@


1.1
log
@network support for ATM networks (ATM == Async Transfer Mode, not
Automatic Teller Machine).

Currently supports PVCs only (no ATM ARP either).
@
text
@d1 1
a1 1
/*      $OpenBSD: $       */
d5 1
a5 1
 * Copyright (c) 1996 Charles D. Cranor
d18 2
a19 1
 *      This product includes software developed by Charles D. Cranor.
@
