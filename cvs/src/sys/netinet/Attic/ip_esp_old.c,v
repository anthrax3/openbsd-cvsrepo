head	1.39;
access;
symbols
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	UBC_SYNC_A:1.39
	UBC_SYNC_B:1.39
	SMP:1.39.0.2
	kame_19991208:1.38
	OPENBSD_2_6:1.36.0.2
	OPENBSD_2_6_BASE:1.36
	OPENBSD_2_5:1.31.0.2
	OPENBSD_2_5_BASE:1.31
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9;
locks; strict;
comment	@ * @;


1.39
date	2000.01.27.08.09.11;	author angelos;	state dead;
branches;
next	1.38;

1.38
date	99.12.06.07.14.35;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	99.10.29.02.10.02;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	99.10.06.22.27.57;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	99.06.18.07.24.04;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	99.05.16.21.48.33;	author niklas;	state Exp;
branches;
next	1.33;

1.33
date	99.05.12.22.58.48;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	99.05.12.21.11.42;	author ho;	state Exp;
branches;
next	1.31;

1.31
date	99.03.24.17.00.46;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	99.02.25.20.14.41;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	99.02.24.23.45.50;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	99.02.24.22.33.03;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	99.02.12.00.46.11;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.01.11.22.52.10;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.01.11.05.12.30;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	99.01.08.21.40.27;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.11.25.09.56.51;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	98.11.25.02.30.59;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	98.11.25.02.01.27;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.07.30.08.41.21;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	98.06.11.14.17.23;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	98.06.03.09.50.22;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	98.05.18.21.10.45;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	98.05.05.08.54.50;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	98.03.07.21.30.26;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	98.02.22.01.23.32;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	98.02.03.19.06.29;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.01.21.18.43.34;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.11.15.00.07.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.11.04.09.11.13;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.10.02.02.31.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.01.01.17.30;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.30.03.29.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.09.28.22.57.49;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.26.12.02.50;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.07.27.23.30.36;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.07.18.18.09.55;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.07.14.08.48.46;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	97.07.11.23.37.57;	author provos;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@/*	$OpenBSD: ip_esp_old.c,v 1.38 1999/12/06 07:14:35 angelos Exp $	*/

/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * DES-CBC
 * Per RFCs 1829/1851 (Metzger & Simpson)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <machine/cpu.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>

#include <sys/socketvar.h>
#include <net/raw_cb.h>

#include <netinet/ip_icmp.h>
#include <netinet/ip_ipsp.h>
#include <netinet/ip_esp.h>
#include <net/pfkeyv2.h>
#include <dev/rndvar.h>

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

extern struct enc_xform enc_xform_des;
extern struct enc_xform enc_xform_3des;

struct enc_xform *esp_old_xform[] = {
    &enc_xform_des,
    &enc_xform_3des
};

int
esp_old_attach()
{
    return 0;
}

/*
 * esp_old_init() is called when an SPI is being set up.
 */

int
esp_old_init(struct tdb *tdbp, struct xformsw *xsp, struct ipsecinit *ii)
{
    struct enc_xform *txform = NULL;
    int i;

    /* Check whether the encryption algorithm is supported */
    for (i = sizeof(esp_old_xform) / sizeof(esp_old_xform[0]) - 1;
	 i >= 0; i--) 
      if (ii->ii_encalg == esp_old_xform[i]->type)
	break;

    if (i < 0) 
    {
	DPRINTF(("esp_old_init(): unsupported encryption algorithm %d specified\n", ii->ii_encalg));
        return EINVAL;
    }

    txform = esp_old_xform[i];

    if (ii->ii_enckeylen < txform->minkey)
    {
	DPRINTF(("esp_old_init(): keylength %d too small (min length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->minkey, txform->name));
	return EINVAL;
    }
    
    if (ii->ii_enckeylen > txform->maxkey)
    {
	DPRINTF(("esp_old_init(): keylength %d too large (max length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->maxkey, txform->name));
	return EINVAL;
    }

    tdbp->tdb_xform = xsp;
    tdbp->tdb_encalgxform = txform;

    DPRINTF(("esp_old_init(): initialized TDB with enc algorithm %s\n",
	     txform->name));

    tdbp->tdb_ivlen = txform->ivmask;
    if (tdbp->tdb_flags & TDBF_HALFIV)
      tdbp->tdb_ivlen /= 2;

    get_random_bytes(tdbp->tdb_iv, tdbp->tdb_ivlen);

    if (txform->setkey)
	txform->setkey(&tdbp->tdb_key, ii->ii_enckey, ii->ii_enckeylen);

    return 0;
}

/* Free the memory */
int
esp_old_zeroize(struct tdb *tdbp)
{
    if (tdbp->tdb_key && tdbp->tdb_encalgxform &&
        tdbp->tdb_encalgxform->zerokey)
	    tdbp->tdb_encalgxform->zerokey(&tdbp->tdb_key);

    return 0;
}

/*
 * esp_old_input() gets called to decrypt an input packet
 */
struct mbuf *
esp_old_input(struct mbuf *m, struct tdb *tdb, int skip, int protoff)
{
    struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
    struct ip *ip, ipo;
    u_char iv[ESP_3DES_IVS], niv[ESP_3DES_IVS], blk[ESP_3DES_BLKS], opts[40];
    u_char *idat, *odat, *ivp, *ivn, *lblk;
    struct esp_old *esp;
    int ohlen, plen, ilen, i, blks, rest;
    struct mbuf *mi, *mo;

    blks = espx->blocksize;

    if (m->m_len < sizeof(struct ip))
    {
	if ((m = m_pullup(m, sizeof(struct ip))) == NULL)
	{
	    DPRINTF(("esp_old_input(): m_pullup() failed\n"));
	    espstat.esps_hdrops++;
	    return NULL;
	}
    }

    ip = mtod(m, struct ip *);
    ohlen = (ip->ip_hl << 2) + ESP_OLD_FLENGTH;

    /* Make sure the IP header, any IP options, and the ESP header are here */
    if (m->m_len < ohlen + blks)
    {
	if ((m = m_pullup(m, ohlen + blks)) == NULL)
	{
            DPRINTF(("esp_old_input(): m_pullup() failed\n"));
	    espstat.esps_hdrops++;
            return NULL;
	}

	ip = mtod(m, struct ip *);
    }

    esp = (struct esp_old *) ((u_int8_t *) ip + (ip->ip_hl << 2));
    ipo = *ip;

    /* Skip the IP header, IP options, SPI and IV */
    plen = m->m_pkthdr.len - (ip->ip_hl << 2) - sizeof(u_int32_t) -
	   tdb->tdb_ivlen;
    if ((plen & (blks - 1)) || (plen <= 0))
    {
	DPRINTF(("esp_old_input(): payload not a multiple of %d octets for packet from %s to %s, spi %08x\n", blks, inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_badilen++;
	m_freem(m);
	return NULL;
    }

    /* Update the counters */
    tdb->tdb_cur_bytes += plen;
    espstat.esps_ibytes += plen;

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	  tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	  m_freem(m);
	  return NULL;
      }
    
    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	  tdb->tdb_flags &= ~TDBF_SOFT_BYTES;     /* Turn off checking */
      }

    ilen = m->m_len - (ip->ip_hl << 2) - sizeof(u_int32_t) - 4;
    idat = mtod(m, unsigned char *) + (ip->ip_hl << 2) + sizeof(u_int32_t) + 4;

    /* Get the IV */
    iv[0] = esp->esp_iv[0];
    iv[1] = esp->esp_iv[1];
    iv[2] = esp->esp_iv[2];
    iv[3] = esp->esp_iv[3];
    if (tdb->tdb_ivlen == 4)		/* Half-IV */
    {
	iv[4] = ~esp->esp_iv[0];
	iv[5] = ~esp->esp_iv[1];
	iv[6] = ~esp->esp_iv[2];
	iv[7] = ~esp->esp_iv[3];
    }
    else
    {
	iv[4] = esp->esp_iv[4];
	iv[5] = esp->esp_iv[5];
	iv[6] = esp->esp_iv[6];
	iv[7] = esp->esp_iv[7];

	/* Adjust the lengths accordingly */
	ilen -= 4;
	idat += 4;
    }

    mi = m;

    /*
     * At this point:
     *   plen is # of encapsulated payload octets
     *   ilen is # of octets left in this mbuf
     *   idat is first encapsulated payload octed in this mbuf
     *   same for olen and odat
     *   ivp points to the IV, ivn buffers the next IV.
     *   mi points to the first mbuf
     *
     * From now on until the end of the mbuf chain:
     *   . move the next eight octets of the chain into ivn
     *   . decrypt idat and xor with ivp
     *   . swap ivp and ivn.
     *   . repeat
     */

    ivp = iv;
    ivn = niv;
    rest = ilen % blks;
    while (plen > 0)		/* while not done */
    {
	if (ilen < blks) 
	{
	    if (rest)
	    {
		bcopy(idat, blk, rest);
		odat = idat;
	    }

	    do {
		mi = (mo = mi)->m_next;
		if (mi == NULL)
		{
		    DPRINTF(("esp_old_input(): bad mbuf chain, SA %s/%08x\n",
			     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    m_freem(m);
		    espstat.esps_hdrops++;
		    return NULL;
		}
	    } while (mi->m_len == 0);

	    if (mi->m_len < blks - rest)
	    {
		if ((mi = m_pullup(mi, blks - rest)) == NULL)
		{
		    DPRINTF(("esp_old_input(): m_pullup() failed, SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    espstat.esps_hdrops++;
		    return NULL;
		}
		/* 
		 * m_pullup was not called at the beginning of the chain
		 * but might return a new mbuf, link it into the chain.
		 */
		mo->m_next = mi;
	    }
		    
	    ilen = mi->m_len;
	    idat = mtod(mi, u_char *);

	    if (rest)
	    {
		bcopy(idat, blk + rest, blks - rest);
		bcopy(blk, ivn, blks);
		    
		espx->decrypt(tdb, blk);

		for (i=0; i < blks; i++)
		    blk[i] ^= ivp[i];

		ivp = ivn;
		ivn = (ivp == iv) ? niv : iv;

		bcopy(blk, odat, rest);
		bcopy(blk + rest, idat, blks - rest);

		lblk = blk;   /* last block touched */
		
		idat += blks - rest;
		ilen -= blks - rest;
		plen -= blks;
	    }

	    rest = ilen % blks;
	}

	while (ilen >= blks && plen > 0)
	{
	    bcopy(idat, ivn, blks);

	    espx->decrypt(tdb, idat);

	    for (i = 0; i < blks; i++)
		idat[i] ^= ivp[i];

	    ivp = ivn;
	    ivn = (ivp == iv) ? niv : iv;

	    lblk = idat;   /* last block touched */
	    idat += blks;

	    ilen -= blks;
	    plen -= blks;
	}
    }

    /* Save the options */
    m_copydata(m, sizeof(struct ip), (ipo.ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) opts);

    if (lblk != blk)
      bcopy(lblk, blk, blks);

    /*
     * Now, the entire chain has been decrypted. As a side effect,
     * blk[blks - 1] contains the next protocol, and blk[blks - 2] contains
     * the amount of padding the original chain had. Chop off the
     * appropriate parts of the chain, and return.
     * We cannot verify the decryption here (as in ip_esp_new.c), since
     * the padding may be random.
     */
    
    if (blk[blks - 2] + 2 > m->m_pkthdr.len - (ip->ip_hl << 2) -
	sizeof(u_int32_t) - tdb->tdb_ivlen)
    {
	DPRINTF(("esp_old_input(): invalid padding length %d for packet from %s to %s, spi %08x\n", blk[blks - 2], inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_badilen++;
	m_freem(m);
	return NULL;
    }

    m_adj(m, - blk[blks - 2] - 2);
    m_adj(m, sizeof(u_int32_t) + tdb->tdb_ivlen);

    if (m->m_len < (ipo.ip_hl << 2))
    {
	m = m_pullup(m, (ipo.ip_hl << 2));
	if (m == NULL)
	{
	    DPRINTF(("esp_old_input(): m_pullup() failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_hdrops++;
	    return NULL;
	}
    }

    ip = mtod(m, struct ip *);
    ipo.ip_p = blk[blks - 1];
    ipo.ip_id = htons(ipo.ip_id);
    ipo.ip_off = 0;
    ipo.ip_len += (ipo.ip_hl << 2) - sizeof(u_int32_t) - tdb->tdb_ivlen -
		  blk[blks - 2] - 2;
    ipo.ip_len = htons(ipo.ip_len);
    ipo.ip_sum = 0;
    *ip = ipo;

    /* Copy the options back */
    m_copyback(m, sizeof(struct ip), (ipo.ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) opts);

    ip->ip_sum = in_cksum(m, (ip->ip_hl << 2));

    return m;
}

int
esp_old_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
	       int protoff)
{
    struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
    struct ip *ip, ipo;
    int i, ilen, ohlen, nh, rlen, plen, padding, rest;
    u_int32_t spi;
    struct mbuf *mi, *mo = (struct mbuf *) NULL;
    u_char *pad, *idat, *odat, *ivp;
    u_char iv[ESP_3DES_IVS], blk[ESP_3DES_IVS], opts[40];
    int iphlen, blks;

    blks = espx->blocksize;

    espstat.esps_output++;

    /*
     * Loop through mbuf chain; if we find an M_EXT mbuf with 
     * more than one reference, replace the rest of the chain. 
     */
    mi = m;
    while (mi != NULL && 
	   (!(mi->m_flags & M_EXT) || 
	    (mi->m_ext.ext_ref == NULL &&
	    mclrefcnt[mtocl(mi->m_ext.ext_buf)] <= 1)))
    {
        mo = mi;
        mi = mi->m_next;
    }
     
    if (mi != NULL)
    {
        /* Replace the rest of the mbuf chain. */
        struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);
      
        if (n == NULL)
        {
	    espstat.esps_hdrops++;
	    m_freem(m);
	    return ENOBUFS;
        }

        if (mo != NULL)
	  mo->m_next = n;
        else
	  m = n;

        m_freem(mi);
    }

    m = m_pullup(m, sizeof(struct ip));
    if (m == NULL)
    {
        DPRINTF(("esp_old_output(): m_pullup() failed for SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_hdrops++;
        return ENOBUFS;
    }

    ip = mtod(m, struct ip *);
    spi = tdb->tdb_spi;
    iphlen = (ip->ip_hl << 2);

    /*
     * If options are present, pullup the IP header and the options.
     */
    if (iphlen != sizeof(struct ip))
    {
	m = m_pullup(m, iphlen);
	if (m == NULL)
        {
	    DPRINTF(("esp_old_output(): m_pullup() failed for SA %s/%08x\n",
		     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_hdrops++;
	    return ENOBUFS;
	}

	ip = mtod(m, struct ip *);

	/* Keep the options */
	m_copydata(m, sizeof(struct ip), iphlen - sizeof(struct ip),
		   (caddr_t) opts);
    }
    
    ilen = ntohs(ip->ip_len);
    ohlen = sizeof(u_int32_t) + tdb->tdb_ivlen;

    ipo = *ip;
    nh = ipo.ip_p;

    /* Raw payload length  */
    rlen = ilen - iphlen;
    padding = ((blks - ((rlen + 2) % blks)) % blks) + 2;
    if (iphlen + ohlen + rlen + padding > IP_MAXPACKET)
    {
	DPRINTF(("esp_old_output(): packet in SA %s/%0x8 got too big\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	espstat.esps_toobig++;
        return EMSGSIZE;
    }

    /* Update the counters */
    tdb->tdb_cur_bytes += rlen;
    espstat.esps_obytes += rlen;

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	m_freem(m);
	return EINVAL;
    }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;     /* Turn off checking */
    }

    pad = (u_char *) m_pad(m, padding, 1);
    if (pad == NULL)
    {
	DPRINTF(("esp_old_output(): m_pad() failed for SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
      	return ENOBUFS;
    }

    pad[padding - 2] = padding - 2;
    pad[padding - 1] = nh;

    plen = rlen + padding;
    mi = m;
    ilen = m->m_len - iphlen;
    idat = mtod(m, u_char *) + iphlen;

    /*
     * We are now ready to encrypt the payload. 
     */

    iv[0] = tdb->tdb_iv[0];
    iv[1] = tdb->tdb_iv[1];
    iv[2] = tdb->tdb_iv[2];
    iv[3] = tdb->tdb_iv[3];

    if (tdb->tdb_ivlen == 4)	/* Half-IV */
    {
	iv[4] = ~tdb->tdb_iv[0];
	iv[5] = ~tdb->tdb_iv[1];
	iv[6] = ~tdb->tdb_iv[2];
	iv[7] = ~tdb->tdb_iv[3];
    }
    else
    {
	iv[4] = tdb->tdb_iv[4];
	iv[5] = tdb->tdb_iv[5];
	iv[6] = tdb->tdb_iv[6];
	iv[7] = tdb->tdb_iv[7];
    }

    ivp = iv;
    rest = ilen % blks;
    while (plen > 0)		/* while not done */
    {
	if (ilen < blks)	/* we exhausted previous mbuf */
	{
	    if (rest)
	    {
		if (ivp == blk)
		{    
			bcopy(blk, iv, blks);
			ivp = iv;
		}

		bcopy(idat, blk, rest);
		odat = idat;
	    }

	    do {
		mi = (mo = mi)->m_next;
		if (mi == NULL)
		{
		    DPRINTF(("esp_old_output(): bad mbuf chain, SA %s/%08x\n",
			     ipsp_address(tdb->tdb_dst),
			     ntohl(tdb->tdb_spi)));
		    m_freem(m);
		    return EINVAL;
		}
	    } while (mi->m_len == 0);

	    if (mi->m_len < blks - rest)
	    {
		if ((mi = m_pullup(mi, blks - rest)) == NULL)
		{
		    DPRINTF(("esp_old_output(): m_pullup() failed, SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    m_freem(m);
		    espstat.esps_hdrops++;
		    return ENOBUFS;
		}
		/* 
		 * m_pullup was not called at the beginning of the chain
		 * but might return a new mbuf, link it into the chain.
		 */
		mo->m_next = mi;
	    }
		    
	    ilen = mi->m_len;
	    idat = (u_char *) mi->m_data;
	    if (rest)
	    {
		bcopy(idat, blk + rest, blks - rest);
		    
		for (i=0; i<blks; i++)
		    blk[i] ^= ivp[i];

		espx->encrypt(tdb, blk);

		ivp = blk;

		bcopy(blk, odat, rest);
		bcopy(blk + rest, idat, blks - rest);
		
		idat += blks - rest;
		ilen -= blks - rest;
		plen -= blks;
	    }

	    rest = ilen % blks;
	}

	while (ilen >= blks && plen > 0)
	{
	    for (i = 0; i < blks; i++)
		idat[i] ^= ivp[i];

	    espx->encrypt(tdb, idat);

	    ivp = idat;
	    idat += blks;

	    ilen -= blks;
	    plen -= blks;
	}
    }

    /*
     * Done with encryption. Let's wedge in the ESP header
     * and send it out.
     */

    M_PREPEND(m, ohlen, M_DONTWAIT);
    if (m == NULL)
    {
	DPRINTF(("esp_old_output(): M_PREPEND failed, SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
        return ENOBUFS;
    }

    m = m_pullup(m, iphlen + ohlen);
    if (m == NULL)
    {
        DPRINTF(("esp_old_output(): m_pullup() failed, SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_hdrops++;
        return ENOBUFS;
    }

    ipo.ip_len = htons(iphlen + ohlen + rlen + padding);
    ipo.ip_p = IPPROTO_ESP;

    iv[0] = tdb->tdb_iv[0];
    iv[1] = tdb->tdb_iv[1];
    iv[2] = tdb->tdb_iv[2];
    iv[3] = tdb->tdb_iv[3];

    if (tdb->tdb_ivlen == 8)
    {
	iv[4] = tdb->tdb_iv[4];
	iv[5] = tdb->tdb_iv[5];
	iv[6] = tdb->tdb_iv[6];
	iv[7] = tdb->tdb_iv[7];
    }

    /* Save the last encrypted block, to be used as the next IV */
    bcopy(ivp, tdb->tdb_iv, tdb->tdb_ivlen);

    m_copyback(m, 0, sizeof(struct ip), (caddr_t) &ipo);

    /* Copy options, if existing */
    if (iphlen != sizeof(struct ip))
      m_copyback(m, sizeof(struct ip), iphlen - sizeof(struct ip),
		 (caddr_t) opts);

    m_copyback(m, iphlen, sizeof(u_int32_t), (caddr_t) &spi);
    m_copyback(m, iphlen + sizeof(u_int32_t), tdb->tdb_ivlen, (caddr_t) iv);
	
    *mp = m;

    return 0;
}	
	
/*
 *
 *
 * m_pad(m, n) pads <m> with <n> bytes at the end. The packet header
 * length is updated, and a pointer to the first byte of the padding
 * (which is guaranteed to be all in one mbuf) is returned. The third
 * argument specifies whether we need randompadding or not.
 *
 */

caddr_t
m_pad(struct mbuf *m, int n, int randompadding)
{
    register struct mbuf *m0, *m1;
    register int len, pad;
    caddr_t retval;
    u_int8_t dat;
	
    if (n <= 0)			/* no stupid arguments */
    {
	DPRINTF(("m_pad(): pad length invalid (%d)\n", n));
        return NULL;
    }

    len = m->m_pkthdr.len;
    pad = n;

    m0 = m;

    while (m0->m_len < len)
    {
	len -= m0->m_len;
	m0 = m0->m_next;
    }

    if (m0->m_len != len)
    {
	DPRINTF(("m_pad(): length mismatch (should be %d instead of %d)\n",
		 m->m_pkthdr.len, m->m_pkthdr.len + m0->m_len - len));
	m_freem(m);
	return NULL;
    }

    if ((m0->m_flags & M_EXT) ||
	(m0->m_data + m0->m_len + pad >= &(m0->m_dat[MLEN])))
    {
	/*
	 * Add an mbuf to the chain
	 */

	MGET(m1, M_DONTWAIT, MT_DATA);
	if (m1 == 0)
	{
	    m_freem(m0);
	    DPRINTF(("m_pad(): cannot append\n"));
	    return NULL;
	}

	m0->m_next = m1;
	m0 = m1;
	m0->m_len = 0;
    }

    retval = m0->m_data + m0->m_len;
    m0->m_len += pad;
    m->m_pkthdr.len += pad;

    if (randompadding)
      for (len = 0; len < n; len++)
      {
	  get_random_bytes((void *) &dat, sizeof(u_int8_t));
	  retval[len] = len + dat;
      }

    return retval;
}
@


1.38
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.37 1999/10/29 02:10:02 angelos Exp $	*/
@


1.37
log
@Get rid of unnecessary third argument in *_output routines of IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.36 1999/10/06 22:27:57 jason Exp $	*/
d164 1
a164 1
esp_old_input(struct mbuf *m, struct tdb *tdb)
d431 2
a432 1
esp_old_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp)
@


1.36
log
@M_EXT isn't the only test for a cluster any more: also test ext_ref
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.35 1999/06/18 07:24:04 deraadt Exp $	*/
d431 1
a431 2
esp_old_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb,
	      struct mbuf **mp)
@


1.35
log
@split out transforms; some debugging done but there may still be bugs in
the new key init/zero functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.34 1999/05/16 21:48:33 niklas Exp $	*/
d454 2
a455 1
	    mclrefcnt[mtocl(mi->m_ext.ext_buf)] <= 1))
@


1.34
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.33 1999/05/12 22:58:48 ho Exp $	*/
d81 6
a86 22
extern void des_ecb3_encrypt(caddr_t, caddr_t, caddr_t, caddr_t, caddr_t, int);
extern void des_ecb_encrypt(caddr_t, caddr_t, caddr_t, int);
extern void des_set_key(caddr_t, caddr_t);

static void des1_encrypt(struct tdb *, u_int8_t *);
static void des3_encrypt(struct tdb *, u_int8_t *);
static void des1_decrypt(struct tdb *, u_int8_t *);
static void des3_decrypt(struct tdb *, u_int8_t *);

struct enc_xform esp_old_xform[] = {
     { SADB_EALG_DESCBC, "Data Encryption Standard (DES)",
       ESP_DES_BLKS, ESP_DES_IVS,
       8, 8, 8,
       des1_encrypt,
       des1_decrypt 
     },
     { SADB_EALG_3DESCBC, "Triple DES (3DES)",
       ESP_3DES_BLKS, ESP_3DES_IVS,
       24, 24, 8,
       des3_encrypt,
       des3_decrypt 
     }
a88 26
static void
des1_encrypt(struct tdb *tdb, u_int8_t *blk)
{
    des_ecb_encrypt(blk, blk, tdb->tdb_key, 1);
}

static void
des1_decrypt(struct tdb *tdb, u_int8_t *blk)
{
    des_ecb_encrypt(blk, blk, tdb->tdb_key, 0);
}

static void
des3_encrypt(struct tdb *tdb, u_int8_t *blk)
{
    des_ecb3_encrypt(blk, blk, tdb->tdb_key, tdb->tdb_key + 128,
		     tdb->tdb_key + 256, 1);
}

static void
des3_decrypt(struct tdb *tdb, u_int8_t *blk)
{
    des_ecb3_encrypt(blk, blk, tdb->tdb_key + 256, tdb->tdb_key + 128,
	             tdb->tdb_key, 0);
}

d106 1
a106 1
    for (i = sizeof(esp_old_xform) / sizeof(struct enc_xform) - 1;
d108 1
a108 1
      if (ii->ii_encalg == esp_old_xform[i].type)
d117 1
a117 1
    txform = &esp_old_xform[i];
d143 2
a144 16
    switch (ii->ii_encalg)
    {
	case SADB_EALG_DESCBC:
	    MALLOC(tdbp->tdb_key, u_int8_t *, 128, M_XDATA, M_WAITOK);
	    bzero(tdbp->tdb_key, 128);
	    des_set_key(ii->ii_enckey, tdbp->tdb_key);
	    break;

	case SADB_EALG_3DESCBC:
	    MALLOC(tdbp->tdb_key, u_int8_t *, 384, M_XDATA, M_WAITOK);
	    bzero(tdbp->tdb_key, 384);
	    des_set_key(ii->ii_enckey, tdbp->tdb_key);
	    des_set_key(ii->ii_enckey + 8, tdbp->tdb_key + 128);
	    des_set_key(ii->ii_enckey + 16, tdbp->tdb_key + 256);
	    break;
    }
d153 3
a155 13
    if (tdbp->tdb_key)
    {
	if (tdbp->tdb_encalgxform)
	  switch (tdbp->tdb_encalgxform->type)
	  {
	      case SADB_EALG_DESCBC:
		  bzero(tdbp->tdb_key, 128);
		  break;

	      case SADB_EALG_3DESCBC:
		  bzero(tdbp->tdb_key, 384);
		  break;
	  }
a156 4
	FREE(tdbp->tdb_key, M_XDATA);
	tdbp->tdb_key = NULL;
    }
    
@


1.33
log
@Follow local indentation style.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.32 1999/05/12 21:11:42 ho Exp $	*/
d295 1
a295 1
	  tdb_delete(tdb, 0);
d611 1
a611 1
	tdb_delete(tdb, 0);
@


1.32
log
@Fix problem with data corruption for retransmitted TCP packets
in an IPSec ESP tunnel. OpenBSD PR 819.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.31 1999/03/24 17:00:46 niklas Exp $	*/
d508 1
a508 1
    struct mbuf *mi, *mo = (struct mbuf *)NULL;
d526 2
a527 2
      mo = mi;
      mi = mi->m_next;
d532 2
a533 2
      /* Replace the rest of the mbuf chain. */
      struct mbuf *n = m_copym2 (mi, 0, M_COPYALL, M_DONTWAIT);
d535 11
a545 11
      if (n == NULL)
      {
	espstat.esps_hdrops++;
	m_freem(m);
	return ENOBUFS;
      }

      if (mo != NULL)
	mo->m_next = n;
      else
	m = n;
d547 1
a547 1
      m_freem(mi);
@


1.31
log
@Implement lifetime expiration notifications.  Fix some typos.  Remove statics.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.30 1999/02/25 20:14:41 angelos Exp $	*/
d508 1
a508 1
    struct mbuf *mi, *mo;
d516 33
@


1.30
log
@Bzero key information before free'ing it, just for paranoia's sake.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.29 1999/02/24 23:45:50 angelos Exp $	*/
d294 1
a294 3
/* XXX
   encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d304 1
a304 3
/* XXX
   encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
d577 1
a577 3
/* XXX
   encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d587 1
a587 3
/* XXX
   encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
@


1.29
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.28 1999/02/24 22:33:03 angelos Exp $	*/
d211 12
@


1.28
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.27 1999/02/12 00:46:11 deraadt Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
@


1.27
log
@angelos cannot spell small words
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.26 1999/01/11 22:52:10 deraadt Exp $	*/
a65 1
#include <net/encap.h>
d70 1
d83 4
a86 1
extern int encap_sendnotify(int, struct tdb *, void *);
d88 2
a89 7
static void des1_encrypt(void *, u_int8_t *);
static void des3_encrypt(void *, u_int8_t *);
static void des1_decrypt(void *, u_int8_t *);
static void des3_decrypt(void *, u_int8_t *);

struct esp_xform esp_old_xform[] = {
     { ALG_ENC_DES, "Data Encryption Standard (DES)",
d91 1
a91 1
       8, 8, 8 | 4,
d95 1
a95 1
     { ALG_ENC_3DES, "Triple DES (3DES)",
d97 1
a97 1
       24, 24, 8 | 4,
d104 1
a104 1
des1_encrypt(void *pxd, u_int8_t *blk)
d106 1
a106 2
     struct esp_old_xdata *xd = pxd;
     des_ecb_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]), 1);
d110 1
a110 1
des1_decrypt(void *pxd, u_int8_t *blk)
d112 1
a112 2
     struct esp_old_xdata *xd = pxd;
     des_ecb_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]), 0);
d116 1
a116 1
des3_encrypt(void *pxd, u_int8_t *blk)
d118 2
a119 4
     struct esp_old_xdata *xd = pxd;
     des_ecb3_encrypt(blk, blk, (caddr_t) (xd->edx_eks[2]),
		      (caddr_t) (xd->edx_eks[1]),
		      (caddr_t) (xd->edx_eks[0]), 1);
d123 1
a123 1
des3_decrypt(void *pxd, u_int8_t *blk)
d125 2
a126 4
     struct esp_old_xdata *xd = pxd;
     des_ecb3_encrypt(blk, blk, (caddr_t) (xd->edx_eks[2]),
		      (caddr_t) (xd->edx_eks[1]),
		      (caddr_t) (xd->edx_eks[0]), 0);
a131 1
    DPRINTF(("esp_old_attach(): setting up\n"));
d136 1
a136 3
 * esp_old_init() is called when an SPI is being set up. It interprets the
 * encap_msghdr present in m, and sets up the transformation data, in
 * this case, the encryption and decryption key schedules
d140 1
a140 1
esp_old_init(struct tdb *tdbp, struct xformsw *xsp, struct mbuf *m)
d142 1
a142 5
    struct esp_old_xdata *xd;
    struct esp_old_xencap xenc;
    struct encap_msghdr *em;
    struct esp_xform *txform;
    u_int32_t rk[6];
d145 5
a149 15
    if (m->m_len < ENCAP_MSG_FIXED_LEN)
    {
	if ((m = m_pullup(m, ENCAP_MSG_FIXED_LEN)) == NULL)
	{
	    DPRINTF(("esp_old_init(): m_pullup failed\n"));
	    return ENOBUFS;
	}
    }

    em = mtod(m, struct encap_msghdr *);
    if (em->em_msglen - EMT_SETSPI_FLEN <= ESP_OLD_XENCAP_LEN)
    {
	DPRINTF(("esp_old_init(): initialization failed\n"));
	return EINVAL;
    }
a150 7
    /* Just copy the standard fields */
    m_copydata(m, EMT_SETSPI_FLEN, ESP_OLD_XENCAP_LEN, (caddr_t) &xenc);

    /* Check whether the encryption algorithm is supported */
    for (i=sizeof(esp_old_xform)/sizeof(struct esp_xform)-1; i >= 0; i--) 
	if (xenc.edx_enc_algorithm == esp_old_xform[i].type)
	      break;
d153 1
a153 1
	DPRINTF(("esp_old_init(): unsupported encryption algorithm %d specified\n", xenc.edx_enc_algorithm));
a157 2
    DPRINTF(("esp_old_init(): initialized TDB with enc algorithm %d: %s\n",
	     xenc.edx_enc_algorithm, esp_old_xform[i].name));
d159 1
a159 2
    if (xenc.edx_ivlen + xenc.edx_keylen + EMT_SETSPI_FLEN +
	ESP_OLD_XENCAP_LEN != em->em_msglen)
d161 1
a161 2
	DPRINTF(("esp_old_init(): message length (%d) doesn't match\n",
		 em->em_msglen));
d164 2
a165 14

    /* Check the IV length */
    if (((xenc.edx_ivlen == 0) && !(txform->ivmask&1)) ||
	((xenc.edx_ivlen != 0) && (
	     !(xenc.edx_ivlen & txform->ivmask) ||
	     (xenc.edx_ivlen & (xenc.edx_ivlen-1)))))
    {
	DPRINTF(("esp_old_init(): unsupported IV length %d\n",
		 xenc.edx_ivlen));
	return EINVAL;
    }

    /* Check the key length */
    if (xenc.edx_keylen < txform->minkey || xenc.edx_keylen > txform->maxkey)
d167 1
a167 1
	DPRINTF(("esp_old_init(): bad key length %d\n", xenc.edx_keylen));
a170 12
    MALLOC(tdbp->tdb_xdata, caddr_t, sizeof(struct esp_old_xdata),
	   M_XDATA, M_WAITOK);
    if (tdbp->tdb_xdata == NULL)
    {
	DPRINTF(("esp_old_init(): MALLOC() failed\n"));
      	return ENOBUFS;
    }

    bzero(tdbp->tdb_xdata, sizeof(struct esp_old_xdata));
    xd = (struct esp_old_xdata *) tdbp->tdb_xdata;

    /* Pointer to the transform */
d172 1
d174 2
a175 3
    xd->edx_ivlen = xenc.edx_ivlen;
    xd->edx_xform = txform;
    xd->edx_enc_algorithm = xenc.edx_enc_algorithm;
d177 3
a179 2
    /* Pass name of enc algorithm for kernfs */
    tdbp->tdb_confname = xd->edx_xform->name;
d181 1
a181 3
    /* Copy the IV */
    m_copydata(m, EMT_SETSPI_FLEN + ESP_OLD_XENCAP_LEN, xd->edx_ivlen,
	       (caddr_t) xd->edx_iv);
d183 1
a183 5
    /* Copy the key material */
    m_copydata(m, EMT_SETSPI_FLEN + ESP_OLD_XENCAP_LEN + xd->edx_ivlen,
	       xenc.edx_keylen, (caddr_t) rk);

    switch (xd->edx_enc_algorithm)
d185 4
a188 2
	case ALG_ENC_DES:
	    des_set_key((caddr_t) rk, (caddr_t) (xd->edx_eks[0]));
d191 6
a196 4
	case ALG_ENC_3DES:
	    des_set_key((caddr_t) rk, (caddr_t) (xd->edx_eks[0]));
	    des_set_key((caddr_t) (rk + 2), (caddr_t) (xd->edx_eks[1]));
	    des_set_key((caddr_t) (rk + 4), (caddr_t) (xd->edx_eks[2]));
a199 4
    bzero(rk, 6 * sizeof(u_int32_t));		/* paranoid */

    bzero(ipseczeroes, IPSEC_ZEROES_SIZE);	/* paranoid */

d207 1
a207 2
    DPRINTF(("esp_old_zeroize(): freeing memory\n"));
    if (tdbp->tdb_xdata)
d209 2
a210 2
       	FREE(tdbp->tdb_xdata, M_XDATA);
	tdbp->tdb_xdata = NULL;
d212 1
d222 1
a222 1
    struct esp_old_xdata *xd;
d230 1
a230 3
    xd = (struct esp_old_xdata *) tdb->tdb_xdata;

    blks = xd->edx_xform->blocksize;
a258 1

d263 1
a263 1
	   xd->edx_ivlen;
d266 1
a266 1
	DPRINTF(("esp_old_input(): payload not a multiple of %d octets for packet from %x to %x, spi %08x\n", blks, ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d272 26
d306 1
a306 1
    if (xd->edx_ivlen == 4)		/* Half-IV */
d360 2
a361 2
		    DPRINTF(("esp_old_input(): bad mbuf chain, SA %x/%08x\n",
			     tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d372 1
a372 1
		    DPRINTF(("esp_old_input(): m_pullup() failed, SA %x/%08x\n", tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d391 1
a391 1
		xd->edx_xform->decrypt(xd, blk);
d393 1
a393 1
		for (i=0; i<blks; i++)
d416 1
a416 1
	    xd->edx_xform->decrypt(xd, idat);
d437 1
a437 1
	bcopy(lblk, blk, blks);
d448 2
a449 2
    if (blk[blks - 2] + 2 > m->m_pkthdr.len - (ip->ip_hl << 2) - sizeof(u_int32_t) -
	xd->edx_ivlen)
d451 1
a451 1
	DPRINTF(("esp_old_input(): invalid padding length %d for packet from %x to %x, SA %x/%08x\n", blk[blks - 2], ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d458 1
a458 1
    m_adj(m, 4 + xd->edx_ivlen);
d465 1
a465 1
	    DPRINTF(("esp_old_input(): m_pullup() failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d475 1
a475 1
    ipo.ip_len += (ipo.ip_hl << 2) - sizeof(u_int32_t) - xd->edx_ivlen -
a486 40
    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) +
			  blk[blks - 2] + 2;
    espstat.esps_ibytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) +
			   blk[blks - 2] + 2;

    /* Notify on expiration */
    if (tdb->tdb_flags & TDBF_SOFT_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_soft_packets)
      {
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	  tdb->tdb_flags &= ~TDBF_SOFT_PACKETS;
      }
      else
	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
	  {
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;
	  }
    }

    if (tdb->tdb_flags & TDBF_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_exp_packets)
      {
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	  tdb_delete(tdb, 0);
      }
      else
	if (tdb->tdb_flags & TDBF_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)
	  {
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	      tdb_delete(tdb, 0);
	  }
    }
    
d494 1
a494 1
    struct esp_old_xdata *xd;
d503 1
a503 3
    xd = (struct esp_old_xdata *) tdb->tdb_xdata;

    blks = xd->edx_xform->blocksize;
d510 2
a511 2
        DPRINTF(("esp_old_output(): m_pullup() failed for SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d528 2
a529 2
	    DPRINTF(("esp_old_output(): m_pullup() failed for SA %x/%08x\n",
		     tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d542 1
a542 1
    ohlen = sizeof(u_int32_t) + xd->edx_ivlen;
d550 4
a553 3
    if (iphlen + ohlen + rlen + padding > IP_MAXPACKET) {
	DPRINTF(("esp_old_output(): packet in SA %x/%0x8 got too big\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d559 26
d588 2
a589 2
	DPRINTF(("esp_old_output(): m_pad() failed for SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d605 11
a615 11
    iv[0] = xd->edx_iv[0];
    iv[1] = xd->edx_iv[1];
    iv[2] = xd->edx_iv[2];
    iv[3] = xd->edx_iv[3];

    if (xd->edx_ivlen == 4)	/* Half-IV */
    {
	iv[4] = ~xd->edx_iv[0];
	iv[5] = ~xd->edx_iv[1];
	iv[6] = ~xd->edx_iv[2];
	iv[7] = ~xd->edx_iv[3];
d619 4
a622 4
	iv[4] = xd->edx_iv[4];
	iv[5] = xd->edx_iv[5];
	iv[6] = xd->edx_iv[6];
	iv[7] = xd->edx_iv[7];
d647 3
a649 2
		    DPRINTF(("esp_old_output(): bad mbuf chain, SA %x/%08x\n",
			     tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d659 1
a659 1
		    DPRINTF(("esp_old_output(): m_pullup() failed, SA %x/%08x\n", tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d680 1
a680 1
		xd->edx_xform->encrypt(xd, blk);
d700 1
a700 1
	    xd->edx_xform->encrypt(xd, idat);
d718 2
a719 2
	DPRINTF(("esp_old_output(): M_PREPEND failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d726 2
a727 2
        DPRINTF(("esp_old_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d735 11
a745 11
    iv[0] = xd->edx_iv[0];
    iv[1] = xd->edx_iv[1];
    iv[2] = xd->edx_iv[2];
    iv[3] = xd->edx_iv[3];

    if (xd->edx_ivlen == 8)
    {
	iv[4] = xd->edx_iv[4];
	iv[5] = xd->edx_iv[5];
	iv[6] = xd->edx_iv[6];
	iv[7] = xd->edx_iv[7];
d749 1
a749 1
    bcopy(ivp, xd->edx_iv, xd->edx_ivlen);
d759 1
a759 1
    m_copyback(m, iphlen + sizeof(u_int32_t), xd->edx_ivlen, (caddr_t) iv);
a761 38

    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += rlen + padding;
    espstat.esps_obytes += rlen + padding;

    /* Notify on expiration */
    if (tdb->tdb_flags & TDBF_SOFT_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_soft_packets)
      {
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	  tdb->tdb_flags &= ~TDBF_SOFT_PACKETS;
      }
      else
	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
	  {
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;
	  }
    }

    if (tdb->tdb_flags & TDBF_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_exp_packets)
      {
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	  tdb_delete(tdb, 0);
      }
      else
	if (tdb->tdb_flags & TDBF_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)
	  {
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	      tdb_delete(tdb, 0);
	  }
    }
@


1.26
log
@remove panic() calls, consistent error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.24 1999/01/08 21:40:27 deraadt Exp $	*/
d97 1
a97 1
     { ALG_ENC_3DES, "Tripple DES (3DES)",
@


1.25
log
@panic prints a newline for you, don't do it in the panic string
@
text
@a71 1
#include <sys/syslog.h>
d172 1
a172 2
	if (encdebug)
	  log(LOG_WARNING, "esp_old_init(): initialization failed\n");
d185 1
a185 2
	if (encdebug)
	  log(LOG_WARNING, "esp_old_init(): unsupported encryption algorithm %d specified\n", xenc.edx_enc_algorithm);
d196 2
a197 2
	if (encdebug)
	  log(LOG_WARNING, "esp_old_init(): message length (%d) doesn't match\n", em->em_msglen);
d207 2
a208 3
	if (encdebug)
	  log(LOG_WARNING, "esp_old_init(): unsupported IV length %d\n",
	      xenc.edx_ivlen);
d215 1
a215 3
	if (encdebug)
	  log(LOG_WARNING, "esp_old_init(): bad key length %d\n",
	      xenc.edx_keylen);
d318 1
a318 1
            espstat.esps_hdrops++;
d401 7
a407 1
		    panic("esp_old_input(): bad chain (i)");
d414 1
a414 2
		    DPRINTF(("esp_old_input(): m_pullup() failed, SA %x/%08x\n",
			     tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d508 1
d596 1
d614 1
d635 2
a636 4
	if (encdebug)
            log(LOG_ALERT,
		"esp_old_output(): packet in SA %x/%0x8 got too big\n",
		tdb->tdb_dst, ntohl(tdb->tdb_spi));
d703 6
a708 1
		    panic("esp_old_output(): bad chain (i)");
d715 3
a717 2
		    DPRINTF(("esp_old_output(): m_pullup() failed, SA %x/%08x\n",
			     tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d784 1
@


1.24
log
@do not use random bits when not necessary, remove 8-byte block dependence
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.23 1998/11/25 09:56:51 niklas Exp $	*/
d407 1
a407 1
		    panic("esp_old_input(): bad chain (i)\n");
d703 1
a703 1
		    panic("esp_old_output(): bad chain (i)\n");
@


1.23
log
@Better error code for too large packets
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.22 1998/11/25 02:30:59 niklas Exp $	*/
d461 1
a461 1
	    for (i=0; i<blks; i++)
d484 2
a485 2
     * blk[7] contains the next protocol, and blk[6] contains the
     * amount of padding the original chain had. Chop off the
d491 1
a491 1
    if (blk[6] + 2 > m->m_pkthdr.len - (ip->ip_hl << 2) - sizeof(u_int32_t) -
d494 1
a494 1
	DPRINTF(("esp_old_input(): invalid padding length %d for packet from %x to %x, SA %x/%08x\n", blk[6], ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d500 1
a500 1
    m_adj(m, -blk[6] - 2);
d514 1
a514 1
    ipo.ip_p = blk[7];
d518 1
a518 1
		  blk[6] - 2;
d531 4
a534 2
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) + blk[6] + 2;
    espstat.esps_ibytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) + blk[6] + 2;
d642 1
a642 1
    pad = (u_char *) m_pad(m, padding);
d747 1
a747 1
	    for (i=0; i<blks; i++)
d858 2
a859 1
 * (which is guaranteed to be all in one mbuf) is returned.
d864 1
a864 1
m_pad(struct mbuf *m, int n)
d920 6
a925 5
    for (len = 0; len < n; len++)
    {
	get_random_bytes((void *) &dat, sizeof(u_int8_t));
	retval[len] = len + dat;
    }
@


1.22
log
@typo in diagnostic
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.21 1998/11/25 02:01:27 niklas Exp $	*/
d637 1
a637 1
        return ENOBUFS;
@


1.21
log
@Add checks of packets getting to big after transforms.
Also make sure some more error conditions get told to the caller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.20 1998/07/30 08:41:21 provos Exp $	*/
d407 1
a407 1
		    panic("esp_old_output(): bad chain (i)\n");
@


1.20
log
@fixing a stupid bug I introduced when trying to improve the encryption
performance by avoiding unnecessary copies. There was a problem when two
subsequent mbufs were != 0 mod blocksize and the next < blocksize, so we
lost the rest of the last mbuf as IV.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.19 1998/06/11 14:17:23 provos Exp $	*/
d627 2
a628 1
    rlen = ilen - iphlen; /* raw payload length  */
d630 9
@


1.19
log
@fix a mbuf chain corruption which happened when m_pullup was called on an
mbuf in the middle of the chain and had to MGET a new one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.18 1998/06/03 09:50:22 provos Exp $	*/
d678 6
@


1.18
log
@cleanup debug printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.17 1998/05/18 21:10:45 provos Exp $	*/
d299 1
a299 1
    struct mbuf *mi;
d405 1
a405 1
		mi = mi->m_next;
d419 5
d578 1
a578 1
    struct mbuf *mi;
d683 1
a683 1
		mi = mi->m_next;
d696 5
@


1.17
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.16 1998/05/05 08:54:50 provos Exp $	*/
d74 6
d141 1
a141 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("esp_old_attach(): setting up\n");
#endif /* ENCDEBUG */
d165 1
a165 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_old_init(): m_pullup failed\n");
#endif /* ENCDEBUG */
d193 2
a194 5
#ifdef ENCDEBUG
    if (encdebug)
      printf("esp_old_init(): initialized TDB with enc algorithm %d: %s\n",
	     xenc.edx_enc_algorithm, esp_old_xform[i].name);
#endif /* ENCDEBUG */
d229 1
a229 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_old_init(): MALLOC() failed\n");
#endif /* ENCDEBUG */
d278 1
a278 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("esp_old_zeroize(): freeing memory\n");
#endif /* ENCDEBUG */
d309 1
a309 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_old_input(): m_pullup() failed\n");
#endif /* ENCDEBUG */
d323 1
a323 4
#ifdef ENCDEBUG
            if (encdebug)
              printf("esp_old_input(): m_pullup() failed\n");
#endif /* ENCDEBUG */
d340 1
a340 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_old_input(): payload not a multiple of %d octets for packet from %x to %x, spi %08x\n", blks, ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d414 2
a415 5
#ifdef ENCDEBUG
		    if (encdebug)
			printf("esp_old_input(): m_pullup() failed, SA %x/%08x\n",
			       tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d489 1
a489 4
#ifdef ENCDEBUG
        if (encdebug)
	  printf("esp_old_input(): invalid padding length %d for packet from %x to %x, SA %x/%08x\n", blk[6], ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d503 1
a503 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_old_input(): m_pullup() failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d587 2
a588 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_old_output(): m_pullup() failed for SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d604 2
a605 5
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("esp_old_output(): m_pullup() failed for SA %x/%08x\n",
		     tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d628 2
a629 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_old_output(): m_pad() failed for SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d687 2
a688 5
#ifdef ENCDEBUG
		    if (encdebug)
			printf("esp_old_output(): m_pullup() failed, SA %x/%08x\n",
			       tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d740 2
a741 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_old_output(): M_PREPEND failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d748 2
a749 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_old_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d844 1
a844 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("m_pad(): pad length invalid (%d)\n", n);
#endif /* ENCDEBUG */
d861 2
a862 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("m_pad(): length mismatch (should be %d instead of %d)\n",
		 m->m_pkthdr.len, m->m_pkthdr.len + m0->m_len - len);
#endif /* ENCDEBUG */
d878 1
a878 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("m_pad(): cannot append\n");
#endif /* ENCDEBUG */
@


1.16
log
@check for invalid padding length, reported by Dan McDonald (Sun Microsystems)
<danmcd@@eng.sun.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.15 1998/03/07 21:30:26 provos Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
d78 1
a78 1
extern int encap_sendnotify(int, struct tdb *);
d561 1
a561 1
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d568 1
a568 1
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d577 1
a577 1
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d584 1
a584 1
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d839 1
a839 1
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d846 1
a846 1
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d855 1
a855 1
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d862 1
a862 1
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
@


1.15
log
@improve performance by avoiding unnecessary copies.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.14 1998/02/22 01:23:32 niklas Exp $	*/
d347 1
a347 1
    if (plen & (blks - 1))
d500 12
@


1.14
log
@Changes made for GCC 2.8 -Wall pleasures
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.13 1998/02/03 19:06:29 deraadt Exp $	*/
d299 1
a299 1
    u_char *idat, *odat;
d301 2
a302 2
    int ohlen, plen, ilen, olen, i, blks;
    struct mbuf *mi, *mo;
d385 1
a385 4
    olen = ilen;
    odat = idat;
    mi = mo = m;
    i = 0;
d393 2
a394 2
     *   iv contains the IV.
     *   mi and mo point to the first mbuf
d397 3
a399 5
     *   . move the next eight octets of the chain into blk[]
     *     (ilen, idat, and mi are adjusted accordingly)
     *     and save it back into iv[]
     *   . decrypt blk[], xor with iv[], put back into chain
     *     (olen, odat, amd mo are adjusted accordingly)
d403 3
d408 1
a408 1
	while (ilen == 0)	/* we exhausted previous mbuf */
d410 11
a420 3
	    mi = mi->m_next;
	    if (mi == NULL)
	      panic("esp_old_input(): bad chain (i)\n");
d422 14
d437 1
a437 2
	    idat = (u_char *) mi->m_data;
	}
d439 6
a444 3
	blk[i] = niv[i] = *idat++;
	i++;
	ilen--;
d446 2
a447 3
	if (i == blks)
	{
	    xd->edx_xform->decrypt(xd, blk);
d449 2
a450 7
	    for (i = 0; i < blks; i++)
	    {
		while (olen == 0)
		{
		    mo = mo->m_next;
		    if (mo == NULL)
		      panic("esp_old_input(): bad chain (o)\n");
d452 2
a453 3
		    olen = mo->m_len;
		    odat = (u_char *) mo->m_data;
		}
d455 5
a459 4
		*odat = blk[i] ^ iv[i];
		iv[i] = niv[i];
		blk[i] = *odat++; /* needed elsewhere */
		olen--;
d462 1
a462 1
	    i = 0;
d465 18
a482 1
	plen--;
d489 3
d580 1
a580 1
    int i, ilen, olen, ohlen, nh, rlen, plen, padding;
d582 2
a583 2
    struct mbuf *mi, *mo;
    u_char *pad, *idat, *odat;
d655 3
a657 4
    mi = mo = m;
    ilen = olen = m->m_len - iphlen;
    idat = odat = mtod(m, u_char *) + iphlen;
    i = 0;
d683 2
d687 1
a687 1
	while (ilen == 0)	/* we exhausted previous mbuf */
d689 5
a693 3
	    mi = mi->m_next;
	    if (mi == NULL)
	      panic("esp_old_output(): bad chain (i)\n");
d695 19
d716 10
a725 1
	}
d727 2
a728 1
	blk[i] = *idat++ ^ iv[i];
d730 4
a733 2
	i++;
	ilen--;
d735 4
a738 1
	if (i == blks)
d740 2
a741 1
	    xd->edx_xform->encrypt(xd, blk);
d743 1
a743 7
	    for (i = 0; i < blks; i++)
	    {
		while (olen == 0)
		{
		    mo = mo->m_next;
		    if (mo == NULL)
		      panic("esp_old_output(): bad chain (o)\n");
d745 2
a746 3
		    olen = mo->m_len;
		    odat = (u_char *) mo->m_data;
		}
d748 2
a749 6
		*odat++ = blk[i];
		iv[i] = blk[i];
		olen--;
	    }

	    i = 0;
a750 2

	plen--;
d797 1
a797 1
    bcopy(blk, xd->edx_iv, xd->edx_ivlen);
@


1.13
log
@bad types; wileyc@@sekiya.twics.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.12 1998/01/21 18:43:34 provos Exp $	*/
d504 1
d517 2
a518 1
    
d520 1
d533 2
a534 1
	    
d757 1
d770 2
a771 1
    
d773 1
d786 1
@


1.12
log
@rcvif not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.11 1997/11/15 00:07:09 deraadt Exp $	*/
d72 1
a72 1
extern encap_sendnotify(int, struct tdb *);
@


1.11
log
@fix memory management errors
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.10 1997/11/04 09:11:13 provos Exp $	*/
a300 1
    struct ifnet *rcvif;
a306 10

    rcvif = m->m_pkthdr.rcvif;
    if (rcvif == NULL)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_old_input(): receive interface is NULL!!!\n");
#endif /* ENCDEBUG */
	rcvif = &enc_softc;
    }
@


1.10
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.9 1997/10/02 02:31:05 deraadt Exp $	*/
d282 5
a286 1
    FREE(tdbp->tdb_xdata, M_XDATA);
@


1.9
log
@conditional error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.8 1997/10/01 01:17:30 deraadt Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
d74 52
d148 1
d150 1
d176 4
a179 1
    switch (xenc.edx_enc_algorithm)
d181 6
a186 2
        case ALG_ENC_DES:
        case ALG_ENC_3DES:
d188 3
a190 3
            if (encdebug)
              printf("esp_old_init(): initialized TDB with enc algorithm %d\n",
                     xenc.edx_enc_algorithm);
a191 7
            break;

        default:
	    if (encdebug)
              log(LOG_WARNING, "esp_old_init(): unsupported encryption algorithm %d specified\n", xenc.edx_enc_algorithm);
            return EINVAL;
    }
d201 5
a205 1
    switch (xenc.edx_enc_algorithm)
d207 5
a211 8
	case ALG_ENC_DES:
	    if ((xenc.edx_ivlen != 4) && (xenc.edx_ivlen != 8))
	    {
		if (encdebug)
	       	  log(LOG_WARNING, "esp_old_init(): unsupported IV length %d\n",
		      xenc.edx_ivlen);
		return EINVAL;
	    }
d213 7
a219 28
	    if (xenc.edx_keylen != 8)
	    {
		if (encdebug)
		  log(LOG_WARNING, "esp_old_init(): bad key length\n",
		      xenc.edx_keylen);
		return EINVAL;
	    }

	    break;

	case ALG_ENC_3DES:
            if ((xenc.edx_ivlen != 4) && (xenc.edx_ivlen != 8))
            {
		if (encdebug)
                  log(LOG_WARNING, "esp_old_init(): unsupported IV length %d\n",
                      xenc.edx_ivlen);
                return EINVAL;
            }

            if (xenc.edx_keylen != 24)
            {
		if (encdebug)
                  log(LOG_WARNING, "esp_old_init(): bad key length\n",
                      xenc.edx_keylen);
                return EINVAL;
            }

            break;
d240 1
d243 3
d303 1
a303 18
    switch (xd->edx_enc_algorithm)
    {
	case ALG_ENC_DES:
	    blks = ESP_DES_BLKS;
	    break;

	case ALG_ENC_3DES:
	    blks = ESP_3DES_BLKS;
	    break;

	default:
	    if (encdebug)
              log(LOG_ALERT,
                  "esp_old_input(): unsupported algorithm %d in SA %x/%08x\n",
                  xd->edx_enc_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
            m_freem(m);
            return NULL;
    }
d433 1
a433 12
	    switch (xd->edx_enc_algorithm)
	    {
		case ALG_ENC_DES:
	    	    des_ecb_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]), 0);
		    break;

		case ALG_ENC_3DES:
		    des_ecb3_encrypt(blk, blk, (caddr_t) (xd->edx_eks[2]),
                             	     (caddr_t) (xd->edx_eks[1]),
                             	     (caddr_t) (xd->edx_eks[0]), 0);
		    break;
	    }
d556 1
a556 18
    switch (xd->edx_enc_algorithm)
    {
        case ALG_ENC_DES:
            blks = ESP_DES_BLKS;
            break;

        case ALG_ENC_3DES:
            blks = ESP_3DES_BLKS;
            break;

        default:
	    if (encdebug)
              log(LOG_ALERT,
                  "esp_old_output(): unsupported algorithm %d in SA %x/%08x\n",
                  xd->edx_enc_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
            m_freem(m);
            return NULL;
    }
d670 1
a670 12
	    switch (xd->edx_enc_algorithm)
	    {
		case ALG_ENC_DES:
	    	    des_ecb_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]), 1);
		    break;

		case ALG_ENC_3DES:
                    des_ecb3_encrypt(blk, blk, (caddr_t) (xd->edx_eks[0]),
                            	     (caddr_t) (xd->edx_eks[1]),
                             	     (caddr_t) (xd->edx_eks[2]), 1);
		    break;
	    }
@


1.8
log
@verify decryption by checking last padding bytes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.7 1997/09/30 03:29:50 deraadt Exp $	*/
d109 2
a110 1
	log(LOG_WARNING, "esp_old_init(): initialization failed\n");
d130 2
a131 1
            log(LOG_WARNING, "esp_old_init(): unsupported encryption algorithm %d specified\n", xenc.edx_enc_algorithm);
d138 2
a139 2
	log(LOG_WARNING, "esp_old_init(): message length (%d) doesn't match\n",
	    em->em_msglen);
d148 3
a150 2
	       	log(LOG_WARNING, "esp_old_init(): unsupported IV length %d\n",
		    xenc.edx_ivlen);
d156 3
a158 2
		log(LOG_WARNING, "esp_old_init(): bad key length\n",
		    xenc.edx_keylen);
d167 3
a169 2
                log(LOG_WARNING, "esp_old_init(): unsupported IV length %d\n",
                    xenc.edx_ivlen);
d175 3
a177 2
                log(LOG_WARNING, "esp_old_init(): bad key length\n",
                    xenc.edx_keylen);
d272 4
a275 3
            log(LOG_ALERT,
                "esp_old_input(): unsupported algorithm %d in SA %x/%08x\n",
                xd->edx_enc_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d454 2
a455 1
     * Verify correct decryption by checking the last padding bytes.
a457 7
    if ((blk[6] != blk[5]) && (blk[6] != 0))
    {
	log(LOG_ALERT, "esp_old_input(): decryption failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, ntohl(tdb->tdb_spi));
	m_freem(m);
	return NULL;
    }

d553 4
a556 3
            log(LOG_ALERT,
                "esp_old_output(): unsupported algorithm %d in SA %x/%08x\n",
                xd->edx_enc_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
@


1.7
log
@same as for ip_esp_new.c, and indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.6 1997/09/28 22:57:49 deraadt Exp $	*/
d447 1
d449 7
@


1.6
log
@log() needs a \n
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.5 1997/08/26 12:02:50 provos Exp $	*/
d214 2
a215 2
	    des_set_key((caddr_t) rk + 2, (caddr_t) (xd->edx_eks[1]));
	    des_set_key((caddr_t) rk + 4, (caddr_t) (xd->edx_eks[2]));
@


1.5
log
@new esp: encryption, authentication and replay protection +
tiny bug fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.4 1997/07/27 23:30:36 niklas Exp $	*/
d109 1
a109 1
	log(LOG_WARNING, "esp_old_init(): initialization failed");
d129 1
a129 1
            log(LOG_WARNING, "esp_old_init(): unsupported encryption algorithm %d specified", xenc.edx_enc_algorithm);
d136 1
a136 1
	log(LOG_WARNING, "esp_old_init(): message length (%d) doesn't match",
d146 1
a146 1
	       	log(LOG_WARNING, "esp_old_init(): unsupported IV length %d",
d153 1
a153 1
		log(LOG_WARNING, "esp_old_init(): bad key length",
d163 1
a163 1
                log(LOG_WARNING, "esp_old_init(): unsupported IV length %d",
d170 1
a170 1
                log(LOG_WARNING, "esp_old_init(): bad key length",
d267 1
a267 1
                "esp_old_input(): unsupported algorithm %d in SA %x/%08x",
d545 1
a545 1
                "esp_old_output(): unsupported algorithm %d in SA %x/%08x",
@


1.4
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.3 1997/07/18 18:09:55 provos Exp $	*/
a312 1
	esp = (struct esp_old *) ((u_int8_t *) ip + (ip->ip_hl << 2));
d314 2
a315 2
    else
      esp = (struct esp_old *) (ip + 1);
@


1.3
log
@enablespi/disablespi in encap + print spi's in hostorder
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.2 1997/07/14 08:48:46 provos Exp $	*/
d68 2
d487 29
d762 29
@


1.2
log
@global byte counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.1 1997/07/11 23:37:57 provos Exp $	*/
d266 1
a266 1
                xd->edx_enc_algorithm, tdb->tdb_dst, tdb->tdb_spi);
d325 1
a325 1
	  printf("esp_old_input(): payload not a multiple of %d octets for packet from %x to %x, spi %08x\n", blks, ipo.ip_src, ipo.ip_dst, tdb->tdb_spi);
d458 1
a458 1
	      printf("esp_old_input(): m_pullup() failed for packet from %x to %x, SA %x/%08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_dst, tdb->tdb_spi);
d516 1
a516 1
                xd->edx_enc_algorithm, tdb->tdb_dst, tdb->tdb_spi);
d529 1
a529 1
		 tdb->tdb_dst, tdb->tdb_spi);
d549 1
a549 1
		     tdb->tdb_dst, tdb->tdb_spi);
d576 1
a576 1
		 tdb->tdb_dst, tdb->tdb_spi);
d680 1
a680 1
		 tdb->tdb_dst, tdb->tdb_spi);
d691 1
a691 1
		 tdb->tdb_dst, tdb->tdb_spi);
@


1.1
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp_old.c,v 1.9 1997/07/01 22:12:48 provos Exp $	*/
d483 1
d730 1
d753 7
a759 1
      return NULL;
@

