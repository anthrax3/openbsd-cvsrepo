head	1.20;
access;
symbols
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	UBC_SYNC_A:1.20
	UBC_SYNC_B:1.20
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.17.0.4
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	SMP:1.14.0.2
	SMP_BASE:1.14
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.20
date	2001.05.30.02.12.34;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2001.05.08.19.58.02;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.17.04.47.15;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.05.05.35.27;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.13.23.40.18;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.16.22.34.19;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.01.19.29.58;	author kjell;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	99.12.15.05.20.22;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.02.05.05.58.53;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.09.15.09.51.18;	author pattonme;	state Exp;
branches;
next	1.9;

1.9
date	98.02.17.01.39.05;	author dgregor;	state Exp;
branches;
next	1.8;

1.8
date	98.01.26.04.10.44;	author dgregor;	state Exp;
branches;
next	1.7;

1.7
date	97.06.23.19.03.50;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.18.06.10.07;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.02.11.22.23.27;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.08.07.33.29;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.18.05.01.06;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.05.10.21.38.18;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.25.05.41.46;	author dm;	state Exp;
branches;
next	;

1.14.2.1
date	2000.02.20.11.57.27;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2001.05.14.22.40.12;	author niklas;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2001.07.04.10.54.56;	author niklas;	state dead;
branches;
next	;


desc
@@


1.20
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ip_nat.h,v 1.19 2001/05/08 19:58:02 fgsch Exp $	*/

/*
 * Copyright (C) 1995-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 *
 * @@(#)ip_nat.h	1.5 2/4/96
 * $IPFilter: ip_nat.h,v 2.17.2.15 2001/04/06 13:47:35 darrenr Exp $
 */

#ifndef	__IP_NAT_H__
#define	__IP_NAT_H__

#ifndef SOLARIS
#define SOLARIS (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
#endif

#if defined(__STDC__) || defined(__GNUC__)
#define	SIOCADNAT	_IOW('r', 60, struct ipnat *)
#define	SIOCRMNAT	_IOW('r', 61, struct ipnat *)
#define	SIOCGNATS	_IOWR('r', 62, struct natstat *)
#define	SIOCGNATL	_IOWR('r', 63, struct natlookup *)
#else
#define	SIOCADNAT	_IOW(r, 60, struct ipnat *)
#define	SIOCRMNAT	_IOW(r, 61, struct ipnat *)
#define	SIOCGNATS	_IOWR(r, 62, struct natstat *)
#define	SIOCGNATL	_IOWR(r, 63, struct natlookup *)
#endif

#undef	LARGE_NAT	/* define this if you're setting up a system to NAT
			 * LARGE numbers of networks/hosts - i.e. in the
			 * hundreds or thousands.  In such a case, you should
			 * also change the RDR_SIZE and NAT_SIZE below to more
			 * appropriate sizes.  The figures below were used for
			 * a setup with 1000-2000 networks to NAT.
			 */
#define	NAT_SIZE	127
#define	RDR_SIZE	127
#define	HOSTMAP_SIZE	127
#define	NAT_TABLE_SZ	127
#ifdef	LARGE_NAT
#undef	NAT_SIZE
#undef	RDR_SIZE
#undef	NAT_TABLE_SZ
#undef	HOSTMAP_SIZE	127
#define	NAT_SIZE	2047
#define	RDR_SIZE	2047
#define	NAT_TABLE_SZ	16383
#define	HOSTMAP_SIZE	8191
#endif
#ifndef	APR_LABELLEN
#define	APR_LABELLEN	16
#endif
#define	NAT_HW_CKSUM	0x80000000

#define	DEF_NAT_AGE	1200     /* 10 minutes (600 seconds) */

struct ap_session;

typedef	struct	nat	{
	u_long	nat_age;
	int	nat_flags;
	u_32_t	nat_sumd[2];
	u_32_t	nat_ipsumd;
	void	*nat_data;
	struct	ap_session	*nat_aps;		/* proxy session */
	struct	frentry	*nat_fr;	/* filter rule ptr if appropriate */
	struct	in_addr	nat_inip;
	struct	in_addr	nat_outip;
	struct	in_addr	nat_oip;	/* other ip */
	U_QUAD_T	nat_pkts;
	U_QUAD_T	nat_bytes;
	u_short	nat_oport;		/* other port */
	u_short	nat_inport;
	u_short	nat_outport;
	u_short	nat_use;
	u_char	nat_tcpstate[2];
	u_char	nat_p;			/* protocol for NAT */
	struct	ipnat	*nat_ptr;	/* pointer back to the rule */
	struct	hostmap	*nat_hm;
	struct	nat	*nat_next;
	struct	nat	*nat_hnext[2];
	struct	nat	**nat_phnext[2];
	void	*nat_ifp;
	int	nat_dir;
	char	nat_ifname[IFNAMSIZ];
#if SOLARIS || defined(__sgi)
	kmutex_t	nat_lock;
#endif
} nat_t;

typedef	struct	ipnat	{
	struct	ipnat	*in_next;
	struct	ipnat	*in_rnext;
	struct	ipnat	**in_prnext;
	struct	ipnat	*in_mnext;
	struct	ipnat	**in_pmnext;
	void	*in_ifp;
	void	*in_apr;
	u_long	in_space;
	u_int	in_use;
	u_int	in_hits;
	struct	in_addr	in_nextip;
	u_short	in_pnext;
	u_short	in_ippip;	/* IP #'s per IP# */
	u_32_t	in_flags;	/* From here to in_dport must be reflected */
	u_short	in_spare;
	u_short	in_ppip;	/* ports per IP */
	u_short	in_port[2];	/* correctly in IPN_CMPSIZ */
	struct	in_addr	in_in[2];
	struct	in_addr	in_out[2];
	struct	in_addr	in_src[2];
	struct	frtuc	in_tuc;
	int	in_redir; /* 0 if it's a mapping, 1 if it's a hard redir */
	char	in_ifname[IFNAMSIZ];
	char	in_plabel[APR_LABELLEN];	/* proxy label */
	char	in_p;	/* protocol */
} ipnat_t;

#define	in_pmin		in_port[0]	/* Also holds static redir port */
#define	in_pmax		in_port[1]
#define	in_nip		in_nextip.s_addr
#define	in_inip		in_in[0].s_addr
#define	in_inmsk	in_in[1].s_addr
#define	in_outip	in_out[0].s_addr
#define	in_outmsk	in_out[1].s_addr
#define	in_srcip	in_src[0].s_addr
#define	in_srcmsk	in_src[1].s_addr
#define	in_scmp		in_tuc.ftu_scmp
#define	in_dcmp		in_tuc.ftu_dcmp
#define	in_stop		in_tuc.ftu_stop
#define	in_dtop		in_tuc.ftu_dtop
#define	in_sport	in_tuc.ftu_sport
#define	in_dport	in_tuc.ftu_dport

#define	NAT_OUTBOUND	0
#define	NAT_INBOUND	1

#define	NAT_MAP		0x01
#define	NAT_REDIRECT	0x02
#define	NAT_BIMAP	(NAT_MAP|NAT_REDIRECT)
#define	NAT_MAPBLK	0x04
/* 0x100 reserved for FI_W_SPORT */
/* 0x200 reserved for FI_W_DPORT */
/* 0x400 reserved for FI_W_SADDR */
/* 0x800 reserved for FI_W_DADDR */
/* 0x1000 reserved for FI_W_NEWFR */

#define	MAPBLK_MINPORT	1024	/* don't use reserved ports for src port */
#define	USABLE_PORTS	(65536 - MAPBLK_MINPORT)

#define	IPN_CMPSIZ	(sizeof(ipnat_t) - offsetof(ipnat_t, in_flags))

typedef	struct	natlookup {
	struct	in_addr	nl_inip;
	struct	in_addr	nl_outip;
	struct	in_addr	nl_realip;
	int	nl_flags;
	u_short	nl_inport;
	u_short	nl_outport;
	u_short	nl_realport;
} natlookup_t;


typedef struct  nat_save    {
	void	*ipn_next;
	struct	nat	ipn_nat;
	struct	ipnat	ipn_ipnat;
	struct	frentry ipn_fr;
	int	ipn_dsize;
	char	ipn_data[4];
} nat_save_t;

#define	ipn_rule	ipn_nat.nat_fr

typedef	struct	natget	{
	void	*ng_ptr;
	int	ng_sz;
} natget_t;


typedef	struct	hostmap	{
	struct	hostmap	*hm_next;
	struct	hostmap	**hm_pnext;
	struct	ipnat	*hm_ipnat;
	struct	in_addr	hm_realip;
	struct	in_addr	hm_mapip;
	int	hm_ref;
} hostmap_t;


typedef	struct	natstat	{
	u_long	ns_mapped[2];
	u_long	ns_rules;
	u_long	ns_added;
	u_long	ns_expire;
	u_long	ns_inuse;
	u_long	ns_logged;
	u_long	ns_logfail;
	u_long	ns_memfail;
	u_long	ns_badnat;
	nat_t	**ns_table[2];
	ipnat_t	*ns_list;
	void	*ns_apslist;
	u_int	ns_nattab_sz;
	u_int	ns_rultab_sz;
	u_int	ns_rdrtab_sz;
	nat_t	*ns_instances;
	u_int	ns_wilds;
} natstat_t;

#define	IPN_ANY		0x000
#define	IPN_TCP		0x001
#define	IPN_UDP		0x002
#define	IPN_TCPUDP	(IPN_TCP|IPN_UDP)
#define	IPN_DELETE	0x004
#define	IPN_ICMPERR	0x008
#define	IPN_RF		(IPN_TCPUDP|IPN_DELETE|IPN_ICMPERR)
#define	IPN_AUTOPORTMAP	0x010
#define	IPN_IPRANGE	0x020
#define	IPN_USERFLAGS	(IPN_TCPUDP|IPN_AUTOPORTMAP|IPN_IPRANGE|IPN_SPLIT|\
			 IPN_ROUNDR|IPN_FILTER|IPN_NOTSRC|IPN_NOTDST)
#define	IPN_FILTER	0x040
#define	IPN_SPLIT	0x080
#define	IPN_ROUNDR	0x100
#define	IPN_NOTSRC	0x080000
#define	IPN_NOTDST	0x100000
#define	IPN_FRAG	0x200000


typedef	struct	natlog {
	struct	in_addr	nl_origip;
	struct	in_addr	nl_outip;
	struct	in_addr	nl_inip;
	u_short	nl_origport;
	u_short	nl_outport;
	u_short	nl_inport;
	u_short	nl_type;
	int	nl_rule;
	U_QUAD_T	nl_pkts;
	U_QUAD_T	nl_bytes;
	u_char	nl_p;
} natlog_t;


#define	NL_NEWMAP	NAT_MAP
#define	NL_NEWRDR	NAT_REDIRECT
#define	NL_NEWBIMAP	NAT_BIMAP
#define	NL_NEWBLOCK	NAT_MAPBLK
#define	NL_FLUSH	0xfffe
#define	NL_EXPIRE	0xffff

#define	NAT_HASH_FN(k,l,m)	(((k) + ((k) >> 12) + l) % (m))

#define	LONG_SUM(in)	(((in) & 0xffff) + ((in) >> 16))

#define	CALC_SUMD(s1, s2, sd) { \
			    (s1) = ((s1) & 0xffff) + ((s1) >> 16); \
			    (s2) = ((s2) & 0xffff) + ((s2) >> 16); \
			    /* Do it twice */ \
			    (s1) = ((s1) & 0xffff) + ((s1) >> 16); \
			    (s2) = ((s2) & 0xffff) + ((s2) >> 16); \
			    /* Because ~1 == -2, We really need ~1 == -1 */ \
			    if ((s1) > (s2)) (s2)--; \
			    (sd) = (s2) - (s1); \
			    (sd) = ((sd) & 0xffff) + ((sd) >> 16); }


extern	u_int	ipf_nattable_sz;
extern	u_int	ipf_natrules_sz;
extern	u_int	ipf_rdrrules_sz;
extern	int	fr_nat_lock;
extern	void	ip_natsync __P((void *));
extern	u_long	fr_defnatage;
extern	u_long	fr_defnaticmpage;
extern	nat_t	**nat_table[2];
extern	nat_t	*nat_instances;
extern	ipnat_t	**nat_rules;
extern	ipnat_t	**rdr_rules;
extern	natstat_t	nat_stats;
#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD_version >= 300003)
extern	int	nat_ioctl __P((caddr_t, u_long, int));
#else
extern	int	nat_ioctl __P((caddr_t, int, int));
#endif
extern	int	nat_init __P((void));
extern	nat_t	*nat_new __P((ipnat_t *, ip_t *, fr_info_t *, u_int, int));
extern	nat_t	*nat_outlookup __P((void *, u_int, u_int, struct in_addr,
				 struct in_addr, u_32_t, int));
extern	nat_t	*nat_inlookup __P((void *, u_int, u_int, struct in_addr,
				struct in_addr, u_32_t, int));
extern	nat_t	*nat_maplookup __P((void *, u_int, struct in_addr,
				struct in_addr));
extern	nat_t	*nat_lookupredir __P((natlookup_t *));
extern	nat_t	*nat_icmplookup __P((ip_t *, fr_info_t *, int));
extern	nat_t	*nat_icmp __P((ip_t *, fr_info_t *, u_int *, int));
extern	void	nat_insert __P((nat_t *));

extern	int	nat_clearlist __P((void));

extern	int	ip_natout __P((ip_t *, fr_info_t *));
extern	int	ip_natin __P((ip_t *, fr_info_t *));
extern	void	ip_natunload __P((void)), ip_natexpire __P((void));
extern	void	nat_log __P((struct nat *, u_int));
extern	void	fix_incksum __P((u_short *, u_32_t));
extern	void	fix_outcksum __P((u_short *, u_32_t));
extern	void	fix_datacksum __P((u_short *, u_32_t));

#endif /* __IP_NAT_H__ */
@


1.19
log
@IPfilter 3.4.17; kjell@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.h,v 1.18 2001/01/17 04:47:15 fgsch Exp $	*/
@


1.18
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d11 1
a11 1
 * $IPFilter: ip_nat.h,v 2.17.2.14 2000/11/18 03:58:04 darrenr Exp $
d231 1
@


1.17
log
@Update to ipf 3.3.12. Most fixes relate to hardening of
in-kernel ftp proxy. See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.h,v 1.16 2000/03/13 23:40:18 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1995-1998 by Darren Reed.
d11 1
a11 1
 * $IPFilter: ip_nat.h,v 2.1.2.4 2000/03/15 13:57:03 darrenr Exp $
d22 4
a25 8
#define	SIOCADNAT	_IOW('r', 80, struct ipnat)
#define	SIOCRMNAT	_IOW('r', 81, struct ipnat)
#define	SIOCGNATS	_IOR('r', 82, struct natstat)
#define	SIOCGNATL	_IOWR('r', 83, struct natlookup)
#define SIOCGFRST	_IOR('r', 84, struct ipfrstat)
#define SIOCGIPST	_IOR('r', 85, struct ips_stat)
#define	SIOCFLNAT	_IOWR('r', 86, int)
#define	SIOCCNATL	_IOWR('r', 87, int)
d27 4
a30 8
#define	SIOCADNAT	_IOW(r, 80, struct ipnat)
#define	SIOCRMNAT	_IOW(r, 81, struct ipnat)
#define	SIOCGNATS	_IOR(r, 82, struct natstat)
#define	SIOCGNATL	_IOWR(r, 83, struct natlookup)
#define SIOCGFRST	_IOR(r, 84, struct ipfrstat)
#define SIOCGIPST	_IOR(r, 85, struct ips_stat)
#define	SIOCFLNAT	_IOWR(r, 86, int)
#define	SIOCCNATL	_IOWR(r, 87, int)
d42 1
d48 1
d52 1
d83 1
d86 1
a86 1
	struct	nat	**nat_hstart[2];
d89 4
d98 1
d100 1
d108 3
a111 2
	u_short	in_ippip;	/* IP #'s per IP# */
	u_short	in_flags;	/* From here to in_dport must be reflected */
d116 1
a120 1
	u_short	in_dport;
d132 6
d146 5
d167 28
d203 2
d212 1
d215 3
a217 3
#define	IPN_ANY		0x00
#define	IPN_TCP		0x01
#define	IPN_UDP		0x02
d219 2
a220 2
#define	IPN_DELETE	0x04
#define	IPN_ICMPERR	0x08
d222 9
a230 3
#define	IPN_AUTOPORTMAP	0x10
#define	IPN_RANGE	0x20
#define	IPN_USERFLAGS	(IPN_TCPUDP|IPN_AUTOPORTMAP|IPN_RANGE)
d250 3
d255 1
a255 1
#define	NAT_HASH_FN(k,m)	(((k) + ((k) >> 12)) % (m))
d274 1
d283 1
a283 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a287 1
extern	void	nat_ifdetach __P((struct ifnet *));
d291 1
a291 1
				 struct in_addr, u_32_t));
d293 1
a293 1
				struct in_addr, u_32_t));
d297 5
a301 2
extern	nat_t	*nat_icmpinlookup __P((ip_t *, fr_info_t *));
extern	nat_t	*nat_icmpin __P((ip_t *, fr_info_t *, u_int *));
d307 3
a309 2
extern	void	fix_incksum __P((u_short *, u_32_t, int));
extern	void	fix_outcksum __P((u_short *, u_32_t, int));
@


1.16
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d11 1
a11 1
 * $IPFilter: ip_nat.h,v 2.1.2.3 2000/01/24 12:44:24 darrenr Exp $
d66 2
d74 2
a75 2
	void	*nat_aps;		/* proxy session */
	frentry_t	*nat_fr;	/* filter rule ptr if appropriate */
@


1.15
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@@


1.14
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.14.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.h,v 1.15 2000/02/16 22:34:19 kjell Exp $	*/
@


1.14.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.h,v 1.18 2001/01/17 04:47:15 fgsch Exp $	*/
d4 1
a4 1
 * Copyright (C) 1995-2000 by Darren Reed.
d11 1
a11 1
 * $IPFilter: ip_nat.h,v 2.17.2.14 2000/11/18 03:58:04 darrenr Exp $
d22 8
a29 4
#define	SIOCADNAT	_IOW('r', 60, struct ipnat *)
#define	SIOCRMNAT	_IOW('r', 61, struct ipnat *)
#define	SIOCGNATS	_IOWR('r', 62, struct natstat *)
#define	SIOCGNATL	_IOWR('r', 63, struct natlookup *)
d31 8
a38 4
#define	SIOCADNAT	_IOW(r, 60, struct ipnat *)
#define	SIOCRMNAT	_IOW(r, 61, struct ipnat *)
#define	SIOCGNATS	_IOWR(r, 62, struct natstat *)
#define	SIOCGNATL	_IOWR(r, 63, struct natlookup *)
a49 1
#define	HOSTMAP_SIZE	127
a54 1
#undef	HOSTMAP_SIZE	127
a57 1
#define	HOSTMAP_SIZE	8191
a65 2
struct ap_session;

d72 2
a73 2
	struct	ap_session	*nat_aps;		/* proxy session */
	struct	frentry	*nat_fr;	/* filter rule ptr if appropriate */
a85 1
	struct	hostmap	*nat_hm;
d88 1
a88 1
	struct	nat	**nat_phnext[2];
a90 4
	char	nat_ifname[IFNAMSIZ];
#if SOLARIS || defined(__sgi)
	kmutex_t	nat_lock;
#endif
a95 1
	struct	ipnat	**in_prnext;
a96 1
	struct	ipnat	**in_pmnext;
d104 1
d106 1
a106 3
	u_32_t	in_flags;	/* From here to in_dport must be reflected */
	u_short	in_spare;
	u_short	in_ppip;	/* ports per IP */
a110 1
	struct	frtuc	in_tuc;
d115 1
a126 6
#define	in_scmp		in_tuc.ftu_scmp
#define	in_dcmp		in_tuc.ftu_dcmp
#define	in_stop		in_tuc.ftu_stop
#define	in_dtop		in_tuc.ftu_dtop
#define	in_sport	in_tuc.ftu_sport
#define	in_dport	in_tuc.ftu_dport
a134 5
/* 0x100 reserved for FI_W_SPORT */
/* 0x200 reserved for FI_W_DPORT */
/* 0x400 reserved for FI_W_SADDR */
/* 0x800 reserved for FI_W_DADDR */
/* 0x1000 reserved for FI_W_NEWFR */
a150 28

typedef struct  nat_save    {
	void	*ipn_next;
	struct	nat	ipn_nat;
	struct	ipnat	ipn_ipnat;
	struct	frentry ipn_fr;
	int	ipn_dsize;
	char	ipn_data[4];
} nat_save_t;

#define	ipn_rule	ipn_nat.nat_fr

typedef	struct	natget	{
	void	*ng_ptr;
	int	ng_sz;
} natget_t;


typedef	struct	hostmap	{
	struct	hostmap	*hm_next;
	struct	hostmap	**hm_pnext;
	struct	ipnat	*hm_ipnat;
	struct	in_addr	hm_realip;
	struct	in_addr	hm_mapip;
	int	hm_ref;
} hostmap_t;


a158 2
	u_long	ns_memfail;
	u_long	ns_badnat;
a165 1
	u_int	ns_wilds;
d168 3
a170 3
#define	IPN_ANY		0x000
#define	IPN_TCP		0x001
#define	IPN_UDP		0x002
d172 2
a173 2
#define	IPN_DELETE	0x004
#define	IPN_ICMPERR	0x008
d175 3
a177 9
#define	IPN_AUTOPORTMAP	0x010
#define	IPN_IPRANGE	0x020
#define	IPN_USERFLAGS	(IPN_TCPUDP|IPN_AUTOPORTMAP|IPN_IPRANGE|IPN_SPLIT|\
			 IPN_ROUNDR|IPN_FILTER|IPN_NOTSRC|IPN_NOTDST)
#define	IPN_FILTER	0x040
#define	IPN_SPLIT	0x080
#define	IPN_ROUNDR	0x100
#define	IPN_NOTSRC	0x080000
#define	IPN_NOTDST	0x100000
a196 3
#define	NL_NEWBIMAP	NAT_BIMAP
#define	NL_NEWBLOCK	NAT_MAPBLK
#define	NL_FLUSH	0xfffe
d199 1
a199 1
#define	NAT_HASH_FN(k,l,m)	(((k) + ((k) >> 12) + l) % (m))
a217 1
extern	int	fr_nat_lock;
d226 1
a226 1
#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD_version >= 300003)
d231 1
d235 1
a235 1
				 struct in_addr, u_32_t, int));
d237 1
a237 1
				struct in_addr, u_32_t, int));
d241 2
a242 5
extern	nat_t	*nat_icmplookup __P((ip_t *, fr_info_t *, int));
extern	nat_t	*nat_icmp __P((ip_t *, fr_info_t *, u_int *, int));
extern	void	nat_insert __P((nat_t *));

extern	int	nat_clearlist __P((void));
d248 2
a249 3
extern	void	fix_incksum __P((u_short *, u_32_t));
extern	void	fix_outcksum __P((u_short *, u_32_t));
extern	void	fix_datacksum __P((u_short *, u_32_t));
@


1.14.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.h,v 1.14.2.2 2001/05/14 22:40:12 niklas Exp $	*/
@


1.13
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d11 1
a11 1
 * $Id: ip_nat.h,v 2.1.2.2 1999/11/28 11:01:51 darrenr Exp $
d191 1
@


1.12
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.h,v 1.11 1999/02/05 05:58:53 deraadt Exp $       */
d10 1
a10 1
 * $Id: ip_nat.h,v 1.11 1999/02/05 05:58:53 deraadt Exp $
d40 18
a57 1
#define	NAT_SIZE	367
d61 3
d68 1
a68 1
	u_32_t	nat_sumd;
d72 1
d82 2
a83 1
	u_char	nat_state[2];
d94 5
a98 3
	void	*in_ifp;			/* interface pointer */
	void	*in_apr;			/* proxy structure ptr */
	u_int	in_space;
d100 1
d103 4
a106 2
	u_short	in_flags;
	u_short	in_port[2];
d109 1
d124 2
d133 1
d135 4
a138 1
#define IPN_CMPSIZ      (sizeof(ipnat_t) - offsetof(ipnat_t, in_flags))
d161 4
d170 1
a170 1
#define	IPN_TCPUDP	0x03
d173 4
d197 3
d201 15
d219 5
a223 1
extern	nat_t	*nat_table[2][NAT_SIZE];
d230 8
a237 5
extern	nat_t	*nat_new __P((ipnat_t *, ip_t *, fr_info_t *, u_short, int));
extern	nat_t	*nat_outlookup __P((void *, int, struct in_addr, u_short,
				 struct in_addr, u_short));
extern	nat_t	*nat_inlookup __P((void *, int, struct in_addr, u_short,
				struct in_addr, u_short));
a238 2
extern	nat_t	*nat_lookupmapip __P((void *, int, struct in_addr, u_short,
				   struct in_addr, u_short));
d240 1
a240 1
extern	nat_t	*nat_icmpin __P((ip_t *, fr_info_t *, int *));
d242 2
a243 2
extern	int	ip_natout __P((ip_t *, int, fr_info_t *));
extern	int	ip_natin __P((ip_t *, int, fr_info_t *));
d245 3
a247 3
extern	void	nat_log __P((struct nat *, u_short));
extern	void	fix_incksum __P((u_short *, u_32_t));
extern	void	fix_outcksum __P((u_short *, u_32_t));
@


1.11
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.h,v 1.10 1998/09/15 09:51:18 pattonme Exp $       */
d10 1
a10 1
 * $Id: ip_nat.h,v 1.10 1998/09/15 09:51:18 pattonme Exp $
d165 1
@


1.10
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_nat.h,v 1.9 1998/02/17 01:39:05 dgregor Exp $       */
d3 1
a3 1
 * Copyright (C) 1995-1997 by Darren Reed.
d10 1
a10 1
 * $Id$
d51 1
d57 1
a57 1
	u_short	nat_oport;	/* other port */
d62 1
a62 1
	struct	ipnat	*nat_ptr;
d72 2
a73 2
	void	*in_ifp;
	void	*in_apr;
d104 1
a104 2
#define	IPN_CMPSIZ	(sizeof(struct in_addr) * 4 + sizeof(u_short) * 3 + \
			 sizeof(int) + IFNAMSIZ + APR_LABELLEN + sizeof(char))
d126 1
@


1.9
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*       $OpenBSD$       */
d10 1
a10 1
 * $Id: ip_nat.h,v 1.8 1998/01/26 04:10:44 dgregor Exp $
d48 2
a49 2
	u_long	nat_sumd;
	u_long	nat_ipsumd;
d179 3
a181 2
extern	void	fix_incksum __P((u_short *, u_long));
extern	void	fix_outcksum __P((u_short *, u_long));
@


1.8
log
@IPF 3.2.3
@
text
@d1 1
d10 1
a10 1
 * $Id: ip_nat.h,v 2.0.2.23.2.1 1997/11/05 11:08:18 darrenr Exp $
@


1.7
log
@merge in 3.1.11
@
text
@a0 1
/*	$OpenBSD: ip_nat.h,v 1.6 1997/04/18 06:10:07 niklas Exp $	*/
d2 1
a2 1
 * (C)opyright 1995 by Darren Reed.
d9 1
a9 1
 * $DRId: ip_nat.h,v 2.0.1.9 1997/03/20 10:20:50 darrenr Exp $
d12 1
a12 1
#ifndef	__IP_NAT_H_
a27 1

d40 3
d49 1
d53 2
d64 2
d71 1
d82 3
d95 2
a96 2
#define	NAT_INBOUND	0
#define	NAT_OUTBOUND	1
d98 3
a100 2
#define	NAT_MAP		0
#define	NAT_REDIRECT	1
d103 1
a103 1
			 sizeof(int) + IFNAMSIZ)
d108 2
d112 1
d117 1
d121 2
d127 53
a179 16
#define	IPN_ANY		0
#define	IPN_TCP		1
#define	IPN_UDP		2
#define	IPN_TCPUDP	3

extern nat_t *nat_table[2][NAT_SIZE];
extern int nat_ioctl __P((caddr_t, u_long, int));
extern nat_t *nat_outlookup __P((int, struct in_addr, u_short, struct in_addr,
				 u_short));
extern nat_t *nat_inlookup __P((int, struct in_addr, u_short, struct in_addr,
				 u_short));
extern nat_t *nat_lookupredir __P((natlookup_t *));
extern int ip_natout __P((ip_t *, int, fr_info_t *));
extern int ip_natin __P((ip_t *, int, fr_info_t *));
extern void ip_natunload __P((void));
extern void ip_natexpire __P((void));
@


1.6
log
@Use the right types on 64-bit machines
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_nat.h,v 1.5 1997/02/11 22:23:27 kstailey Exp $	*/
d10 1
a10 1
 * Id: ip_nat.h,v 2.0.1.7 1997/01/30 12:39:41 darrenr Exp
d44 2
a45 1
	int	nat_age;
d92 1
a92 1
			 sizeof(int))
@


1.5
log
@IPF 1.3.7
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d115 1
a115 1
extern int nat_ioctl __P((caddr_t, int, int));
@


1.4
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d1 1
d10 1
a10 1
 * $Id: ip_nat.h,v 1.3 1996/07/18 05:01:06 dm Exp $
d27 3
d37 2
d44 1
a44 3
	struct	nat	*nat_next;
	u_short	nat_use;
	short	nat_age;
d46 1
d53 6
d64 4
a68 1
	u_short	in_pnext;
a71 2
	struct	in_addr	in_nextip;
	int	in_space;
d90 2
a91 1
#define	IPN_CMPSIZ	(sizeof(struct in_addr) * 4 + sizeof(u_short) * 2)
d105 1
a105 1
	nat_t	***ns_table;
d114 1
d116 4
a119 2
extern nat_t *nat_lookupoutip __P((ipnat_t *, ip_t *, tcphdr_t *));
extern nat_t *nat_lookupinip __P((struct in_addr, u_short));
d121 2
a122 2
extern void ip_natout __P((ip_t *, int, fr_info_t *));
extern void ip_natin __P((ip_t *, int, fr_info_t *));
@


1.3
log
@ipfilter 3.1.0
@
text
@d9 1
a9 1
 * $Id: ip_nat.h,v 1.2 1996/07/04 13:15:42 darrenr Exp $
d101 8
a108 3
extern int nat_ioctl();
extern nat_t *nat_lookupoutip(), *nat_lookupinip(), *nat_lookupredir();
extern void ip_natout(), ip_natin(), ip_natunload(), ip_natexpire();
@


1.2
log
@ipfilter 3.0.4
@
text
@d9 1
d24 2
d31 2
@


1.1
log
@IP filter 3.0.1
@
text
@d8 1
a8 1
 * @@(#)ip_nat.h	1.3 1/12/96
d22 1
d27 1
d39 2
d55 1
d59 1
a59 1
#define	in_pmin		in_port[0]
d67 6
d75 7
d97 1
a97 1
extern nat_t *nat_lookupoutip(), *nat_lookupinip();
@
