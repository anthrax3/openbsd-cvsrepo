head	1.37;
access;
symbols
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	UBC_SYNC_A:1.37
	UBC_SYNC_B:1.37
	SMP:1.37.0.2
	kame_19991208:1.33
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.25.0.2
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10;
locks; strict;
comment	@ * @;


1.37
date	2000.01.27.08.09.09;	author angelos;	state dead;
branches;
next	1.36;

1.36
date	2000.01.09.23.42.37;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	99.12.15.07.07.59;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	99.12.09.20.22.03;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	99.12.08.07.07.27;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	99.12.08.06.16.56;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	99.12.08.02.26.18;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	99.12.07.08.58.00;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	99.12.06.07.14.35;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	99.10.29.02.10.01;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	99.06.30.17.23.59;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.05.16.21.48.31;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	99.03.24.17.00.44;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	99.02.25.20.14.36;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	99.02.24.23.45.47;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	99.02.24.22.32.59;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	99.01.11.22.52.09;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.11.25.09.56.50;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	98.11.25.02.01.27;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	98.06.03.09.50.18;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	98.05.18.21.10.33;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	98.02.22.01.23.30;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	98.01.21.18.43.32;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.11.24.19.14.12;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.11.18.09.09.43;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.11.15.00.07.07;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.11.04.09.11.01;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.10.02.02.31.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.09.28.22.57.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.09.23.21.42.20;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	97.08.26.12.02.48;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.07.27.23.30.34;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.07.24.01.37.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.18.18.09.52;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.07.14.08.48.45;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.07.12.14.57.01;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	97.07.11.23.37.55;	author provos;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@/*	$OpenBSD: ip_ah_new.c,v 1.36 2000/01/09 23:42:37 angelos Exp $	*/

/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * Based on RFC 2085.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/socketvar.h>
#include <machine/cpu.h>
#include <machine/endian.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>
#include <net/raw_cb.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>

#ifdef INET6
#include <netinet6/in6.h>
#include <netinet6/ip6.h>
#endif /* INET6 */

#include <netinet/ip_ipsp.h>
#include <netinet/ip_ah.h>
#include <net/pfkeyv2.h>

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
#endif

extern struct auth_hash auth_hash_hmac_md5_96;
extern struct auth_hash auth_hash_hmac_sha1_96;
extern struct auth_hash auth_hash_hmac_ripemd_160_96;

struct auth_hash *ah_new_hash[] = {
    &auth_hash_hmac_md5_96,
    &auth_hash_hmac_sha1_96,
    &auth_hash_hmac_ripemd_160_96
};

/*
 * ah_new_attach() is called from the transformation initialization code
 */
int
ah_new_attach()
{
    return 0;
}

/*
 * ah_new_init() is called when an SPI is being set up.
 */

int
ah_new_init(struct tdb *tdbp, struct xformsw *xsp, struct ipsecinit *ii)
{
    struct auth_hash *thash = NULL;
    int i;

    for (i = sizeof(ah_new_hash) / sizeof(ah_new_hash[0]) - 1; i >= 0; i--)
      if (ii->ii_authalg == ah_new_hash[i]->type)
	break;

    if (i < 0) 
    {
	DPRINTF(("ah_new_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
	return EINVAL;
    }

    thash = ah_new_hash[i];

    if (ii->ii_authkeylen != thash->keysize)
    {
	DPRINTF(("ah_new_init(): keylength %d doesn't match algorithm %s keysize (%d)\n", ii->ii_authkeylen, thash->name, thash->keysize));
	return EINVAL;
    }

    tdbp->tdb_xform = xsp;
    tdbp->tdb_authalgxform = thash;
    tdbp->tdb_bitmap = 0;
    tdbp->tdb_rpl = AH_HMAC_INITIAL_RPL;

    DPRINTF(("ah_new_init(): initialized TDB with hash algorithm %s\n",
	     thash->name));

    /* Precompute the I and O pads of the HMAC */
    for (i = 0; i < ii->ii_authkeylen; i++)
      ii->ii_authkey[i] ^= HMAC_IPAD_VAL;

    MALLOC(tdbp->tdb_ictx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
    bzero(tdbp->tdb_ictx, thash->ctxsize);
    thash->Init(tdbp->tdb_ictx);
    thash->Update(tdbp->tdb_ictx, ii->ii_authkey, ii->ii_authkeylen);
    thash->Update(tdbp->tdb_ictx, hmac_ipad_buffer,
		  HMAC_BLOCK_LEN - ii->ii_authkeylen);

    for (i = 0; i < ii->ii_authkeylen; i++)
      ii->ii_authkey[i] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);

    MALLOC(tdbp->tdb_octx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
    bzero(tdbp->tdb_octx, thash->ctxsize);
    thash->Init(tdbp->tdb_octx);
    thash->Update(tdbp->tdb_octx, ii->ii_authkey, ii->ii_authkeylen);
    thash->Update(tdbp->tdb_octx, hmac_opad_buffer,
		  HMAC_BLOCK_LEN - ii->ii_authkeylen);

    bzero(ipseczeroes, IPSEC_ZEROES_SIZE);	/* paranoid */

    return 0;
}

/* Free memory */
int
ah_new_zeroize(struct tdb *tdbp)
{
    if (tdbp->tdb_ictx)
    {
	if (tdbp->tdb_authalgxform)
	  bzero(tdbp->tdb_ictx, tdbp->tdb_authalgxform->ctxsize);

	FREE(tdbp->tdb_ictx, M_XDATA);
	tdbp->tdb_ictx = NULL;
    }

    if (tdbp->tdb_octx)
    {
	if (tdbp->tdb_authalgxform)
	  bzero(tdbp->tdb_octx, tdbp->tdb_authalgxform->ctxsize);

	FREE(tdbp->tdb_octx, M_XDATA);
	tdbp->tdb_octx = NULL;
    }

    return 0;
}

/*
 * ah_new_input() gets called to verify that an input packet
 * passes authentication
 */

struct mbuf *
ah_new_input(struct mbuf *m, struct tdb *tdb, int skip, int protoff)
{
    struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    unsigned char calcauth[AH_MAX_HASHLEN];
    int len, count, off, roff;
    struct mbuf *m0, *m1;
    unsigned char *ptr;
    union authctx ctx;
    struct ah_new ah;
    
#ifdef INET
    struct ip ipo;
#endif /* INET */

#ifdef INET6
    struct ip6_ext *ip6e;
    struct ip6_hdr ip6;
    int last;
#endif /* INET6 */

    /* Save the AH header, we use it throughout */
    m_copydata(m, skip, sizeof(ah), (unsigned char *) &ah);

    /* Replay window checking */
    if (tdb->tdb_wnd > 0)
    {
	switch (checkreplaywindow32(ntohl(ah.ah_rpl), 0, &(tdb->tdb_rpl),
				    tdb->tdb_wnd, &(tdb->tdb_bitmap)))
	{
	    case 0: /* All's well */
		break;

	    case 1:
		DPRINTF(("ah_new_input(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_wrap++;
		m_freem(m);
		return NULL;

	    case 2:
	    case 3:
		DPRINTF(("ah_new_input(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_replay++;
		m_freem(m);
		return NULL;

	    default:
                DPRINTF(("ah_new_input(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_replay++;
                m_freem(m);
                return NULL;
	}
    }

    /* Verify AH header length */
    if (ah.ah_hl * sizeof(u_int32_t) != AH_HMAC_HASHLEN + AH_HMAC_RPLENGTH)
    {
	DPRINTF(("ah_new_input(): bad authenticator length %d for packet in SA %s/%08x\n", ah.ah_hl * sizeof(u_int32_t), ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_badauthl++;
	m_freem(m);
	return NULL;
    }

    /* Update the counters */
    tdb->tdb_cur_bytes += (m->m_pkthdr.len - skip -
			   ah.ah_hl * sizeof(u_int32_t));
    ahstat.ahs_ibytes += (m->m_pkthdr.len - skip -
			  ah.ah_hl * sizeof(u_int32_t));

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	  tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	  m_freem(m);
	  return NULL;
      }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;     /* Turn off checking */
    }

    bcopy(tdb->tdb_ictx, &ctx, ahx->ctxsize);

    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    /*
	     * This is the least painful way of dealing with IPv4 header
	     * and option processing -- just make sure they're in
	     * contiguous memory.
	     */
	    m = m_pullup(m, skip);
	    if (m == NULL)
	    {
		DPRINTF(("ah_new_input(): m_pullup() failed, SA %s/%08x\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_hdrops++;
		return NULL;
	    }

	    ptr = mtod(m, unsigned char *) + sizeof(struct ip);

	    bcopy(mtod(m, unsigned char *), (unsigned char *) &ipo,
		  sizeof(struct ip));

	    ipo.ip_tos = 0;
	    ipo.ip_len += skip;     /* adjusted in ip_intr() */
	    HTONS(ipo.ip_len);
	    HTONS(ipo.ip_id);
	    ipo.ip_off = 0;
	    ipo.ip_ttl = 0;
	    ipo.ip_sum = 0;

	    /* Include IP header in authenticator computation */
	    ahx->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));

	    /* IPv4 option processing */
	    for (off = sizeof(struct ip); off < skip;)
	    {
		switch (ptr[off])
		{
		    case IPOPT_EOL:
			ahx->Update(&ctx, ptr + off, 1);
			off = skip;  /* End the loop */
			break;

		    case IPOPT_NOP:
			ahx->Update(&ctx, ptr + off, 1);
			off++;
			break;

		    case IPOPT_SECURITY:	/* 0x82 */
		    case 0x85:	/* Extended security */
		    case 0x86:	/* Commercial security */
		    case 0x94:	/* Router alert */
		    case 0x95:	/* RFC1770 */
			ahx->Update(&ctx, ptr + off, ptr[off + 1]);
			/* Sanity check for zero-length options */
			if (ptr[off + 1] == 0)
			{
			    DPRINTF(("ah_new_input(): illegal zero-length IPv4 option %d in SA %s/%08x\n", ptr[off], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			    ahstat.ahs_hdrops++;
			    m_freem(m);
			    return NULL;
			}

			off += ptr[off + 1];
			break;

		    default:
			ahx->Update(&ctx, ipseczeroes, ptr[off + 1]);
			off += ptr[off + 1];
			break;
		}

		/* Sanity check */
		if (off > skip)
		{
		    DPRINTF(("ah_new_input(): malformed IPv4 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    ahstat.ahs_hdrops++;
		    m_freem(m);
		    return NULL;
		}
	    }

	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:  /* Ugly... */
	    /* Copy and "cook" (later on) the IPv6 header */
	    m_copydata(m, 0, sizeof(ip6), (unsigned char *) &ip6);

	    /* We don't do IPv6 Jumbograms */
	    if (ip6.ip6_plen == 0)
	    {
		DPRINTF(("ah_new_input(): unsupported IPv6 jumbogram in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_hdrops++;
		m_freem(m);
		return NULL;
	    }

	    ip6.ip6_flow = 0;
	    ip6.ip6_hlim = 0;
	    ip6.ip6_vfc &= ~IPV6_VERSION_MASK;
	    ip6.ip6_vfc |= IPV6_VERSION;

	    /* Include IPv6 header in authenticator computation */
	    ahx->Update(&ctx, (unsigned char *) &ip6, sizeof(ip6));

	    /* Let's deal with the remaining headers (if any) */
	    if (skip - sizeof(struct ip6_hdr) > 0)
	    {
		if (m->m_len <= skip)
		{
		    MALLOC(ptr, unsigned char *, skip - sizeof(struct ip6_hdr),
			   M_XDATA, M_WAITOK);

		    /* Copy all the protocol headers after the IPv6 header */
		    m_copydata(m, sizeof(struct ip6_hdr),
			       skip - sizeof(struct ip6_hdr), ptr);
		}
		else
		  ptr = mtod(m, unsigned char *) + sizeof(struct ip6_hdr);
	    }
	    else
	      break;

	    off = ip6.ip6_nxt & 0xff; /* Next header type */

	    for (len = 0; len < skip - sizeof(struct ip6_hdr);)
	      switch (off)
	      {
		  case IPPROTO_HOPOPTS:
		  case IPPROTO_DSTOPTS:
		      ip6e = (struct ip6_ext *) (ptr + len);

		      /*
		       * Process the mutable/immutable options -- borrows
		       * heavily from the KAME code.
		       */
		      for (last = len, count = len + sizeof(struct ip6_ext);
			   count < len + ((ip6e->ip6e_len + 1) << 3);)
		      {
			  if (ptr[count] == IP6OPT_PAD1)
			  {
			      count++;
			      continue;
			  }

			  /* Sanity check */
			  if (count + sizeof(struct ip6_ext) > len +
			      ((ip6e->ip6e_len + 1) << 3))
			  {
			      DPRINTF(("ah_new_input(): malformed IPv6 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			      ahstat.ahs_hdrops++;
			      m_freem(m);

			      /* Free, if we allocated */
			      if (m->m_len < skip)
			      {
				  FREE(ptr, M_XDATA);
				  ptr = NULL;
			      }
			      return NULL;
			  }

			  /*
			   * If mutable option, calculate authenticator
			   * for all immutable fields so far, then include
			   * a zeroed-out version of this option.
			   */
			  if (ptr[count] & IP6OPT_MUTABLE)
			  {
			      /* Calculate immutables */
			      ahx->Update(&ctx, ptr + last,
					  count + sizeof(struct ip6_ext) -
					  last);
			      last = count + ptr[count + 1] +
				     sizeof(struct ip6_ext);

			      /* Calculate "zeroed-out" immutables */
			      ahx->Update(&ctx, ipseczeroes, ptr[count + 1] -
					  sizeof(struct ip6_ext));
			  }
			  
			  count += ptr[count + 1] + sizeof(struct ip6_ext);

			  /* Sanity check */
			  if (count > skip - sizeof(struct ip6_hdr))
			  {
			      DPRINTF(("ah_new_input(): malformed IPv6 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			      ahstat.ahs_hdrops++;
			      m_freem(m);

			      /* Free, if we allocated */
			      if (m->m_len < skip)
			      {
				  FREE(ptr, M_XDATA);
				  ptr = NULL;
			      }
			      return NULL;
			  }
		      }

		      /* Include any trailing immutable options */
		      ahx->Update(&ctx, ptr + last,
				  len + ((ip6e->ip6e_len + 1) << 3) - last);

		      len += ((ip6e->ip6e_len + 1) << 3); /* Advance */
		      off = ip6e->ip6e_nxt;
		      break;

		  case IPPROTO_ROUTING:
		      ip6e = (struct ip6_ext *) (ptr + len);
		      ahx->Update(&ctx, ptr + len, (ip6e->ip6e_len + 1) << 3);
		      len += ((ip6e->ip6e_len + 1) << 3); /* Advance */
		      off = ip6e->ip6e_nxt;
		      break;

		  default:
		      DPRINTF(("ah_new_input(): unexpected IPv6 header type %d in SA %s/%08x\n", off, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));   
		      len = skip - sizeof(struct ip6_hdr);
		      break;
	      }

	    /* Free, if we allocated */
	    if (m->m_len < skip)
	    {
		FREE(ptr, M_XDATA);
		ptr = NULL;
	    }

	    break;
#endif /* INET6 */

	default:
	    DPRINTF(("ah_new_input(): unsupported protocol family %d in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    return NULL;
    }

    /* Record the beginning of the AH header */
    for (len = 0, m1 = m; m1 && (len + m1->m_len <= skip); m1 = m1->m_next)
      len += m1->m_len;

    if (m1 == NULL)
    {
	DPRINTF(("ah_new_input(): bad mbuf chain for packet in SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_hdrops++;
	m_freem(m);
	return NULL;
    }
    else
      roff = skip - len;

    /* Skip the AH header */
    for (len = 0, m0 = m1;
	 m0 && (len + m0->m_len <= AH_NEW_FLENGTH + roff);
	 m0 = m0->m_next)
      len += m0->m_len;

    if (m0 == NULL)
    {
	DPRINTF(("ah_new_input(): bad mbuf chain for packet in SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_hdrops++;
	m_freem(m);
	return NULL;
    }
    else
      off = (AH_NEW_FLENGTH + roff) - len;

    /* Include the AH header (minus the authenticator) in the computation */
    ahx->Update(&ctx, (unsigned char *) &ah, AH_NEW_FLENGTH - AH_HMAC_HASHLEN);

    /* All-zeroes for the authenticator */
    ahx->Update(&ctx, ipseczeroes, AH_HMAC_HASHLEN);

    /* Amount of data to be verified */
    len = m->m_pkthdr.len - skip - AH_NEW_FLENGTH;

    /* Loop through the mbuf chain computing the HMAC */
    while (len > 0)
    {
	if (m0 == NULL)
	{
	    DPRINTF(("ah_new_input(): bad mbuf chain for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    return NULL;
	}

	count = min(m0->m_len - off, len);

	ahx->Update(&ctx, mtod(m0, unsigned char *) + off, count);

	len -= count;
	off = 0;
	m0 = m0->m_next;
    }

    /* Finish HMAC computation */
    ahx->Final(calcauth, &ctx);
    bcopy(tdb->tdb_octx, &ctx, ahx->ctxsize);
    ahx->Update(&ctx, calcauth, ahx->hashsize);
    ahx->Final(calcauth, &ctx);

    /* Verify */
    if (bcmp(&(ah.ah_data), calcauth, AH_HMAC_HASHLEN))
    {
	DPRINTF(("ah_new_input(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_badauth++;
	m_freem(m);
	return NULL;
    }

    /* Fix the Next Protocol field */
    m_copyback(m, protoff, 1, (u_char *) &(ah.ah_nh));

    /*
     * Remove the AH header from the mbuf.
     */
    if (roff == 0) 
    {
	/* The AH header was conveniently at the beginning of the mbuf */
	m_adj(m1, AH_NEW_FLENGTH);
	if (!(m1->m_flags & M_PKTHDR))
	  m->m_pkthdr.len -= AH_NEW_FLENGTH;
    }
    else
      if (roff + AH_NEW_FLENGTH >= m1->m_len)
      {
	  /*
	   * Part or all of the AH header is at the end of this mbuf, so first
	   * let's remove the remainder of the AH header from the
	   * beginning of the remainder of the mbuf chain, if any.
	   */
	  if (roff + AH_NEW_FLENGTH > m1->m_len)
	  {
	      /* Adjust the next mbuf by the remainder */
	      m_adj(m1->m_next, roff + AH_NEW_FLENGTH - m1->m_len);

	      /* The second mbuf is guaranteed not to have a pkthdr... */
	      m->m_pkthdr.len -= (roff + AH_NEW_FLENGTH - m1->m_len);
	  }

	  /* Now, let's unlink the mbuf chain for a second...*/
	  m0 = m1->m_next;
	  m1->m_next = NULL;

	  /* ...and trim the end of the first part of the chain...sick */
	  m_adj(m1, -(m1->m_len - roff));
	  if (!(m1->m_flags & M_PKTHDR))
	    m->m_pkthdr.len -= (m1->m_len - roff);

	  /* Finally, let's relink */
	  m1->m_next = m0;
      }
      else
      {
	  /* 
	   * The AH header lies in the "middle" of the mbuf...do an
	   * overlapping copy of the remainder of the mbuf over the ESP
	   * header.
	   */
	  bcopy(mtod(m1, u_char *) + roff + AH_NEW_FLENGTH,
		mtod(m1, u_char *) + roff,
		m1->m_len - (roff + AH_NEW_FLENGTH));
	  m1->m_len -= AH_NEW_FLENGTH;
	  m->m_pkthdr.len -= AH_NEW_FLENGTH;
      }

    return m;
}

int
ah_new_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
	      int protoff)
{
    struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    unsigned char calcauth[AH_MAX_HASHLEN];
    int len, off, count;
    unsigned char *ptr;
    struct ah_new *ah;
    union authctx ctx;
    struct mbuf *mo;

#ifdef INET
    struct ip ipo;
#endif /* INET */

#ifdef INET6
    struct ip6_ext *ip6e;
    struct ip6_hdr ip6;
    int last;
#endif /* INET6 */

    ahstat.ahs_output++;

    /* Check for replay counter wrap-around in automatic (not manual) keying */
    if ((tdb->tdb_rpl == 0) && (tdb->tdb_wnd > 0))
    {
	DPRINTF(("ah_new_output(): SA %s/%08x should have expired\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_wrap++;
	return NULL;
    }

#ifdef INET
    if (AH_NEW_FLENGTH + m->m_pkthdr.len > IP_MAXPACKET)
    {
	DPRINTF(("ah_new_output(): packet in SA %s/%08x got too big\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_toobig++;
        return EMSGSIZE;
    }
#endif /* INET  */

    /* Update the counters */
    tdb->tdb_cur_bytes += m->m_pkthdr.len - skip;
    ahstat.ahs_obytes += m->m_pkthdr.len - skip;

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	  tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	  m_freem(m);
	  return EINVAL;
      }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;      /* Turn off checking */
    }

    /*
     * Loop through mbuf chain; if we find an M_EXT mbuf with 
     * more than one reference, replace the rest of the chain.
     * This may not be strictly necessary for AH packets, if we were
     * careful with the rest of our processing (and made a lot of
     * assumptions about the layout of the packets/mbufs).
     */
    (*mp) = m;
    while ((*mp) != NULL && 
	   (!((*mp)->m_flags & M_EXT) || 
	    ((*mp)->m_ext.ext_ref == NULL &&
	     mclrefcnt[mtocl((*mp)->m_ext.ext_buf)] <= 1)))
    {
        mo = (*mp);
        (*mp) = (*mp)->m_next;
    }
     
    if ((*mp) != NULL)
    {
        /* Replace the rest of the mbuf chain. */
        struct mbuf *n = m_copym2((*mp), 0, M_COPYALL, M_DONTWAIT);
      
        if (n == NULL)
        {
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    return ENOBUFS;
        }

        if (mo != NULL)
	  mo->m_next = n;
        else
	  m = n;

        m_freem((*mp));
	(*mp) = NULL;
    }

    bcopy(tdb->tdb_ictx, (caddr_t) &ctx, ahx->ctxsize);

    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    /*
	     * This is the most painless way of dealing with IPv4 header
	     * and option processing -- just make sure they're in
	     * contiguous memory.
	     */
	    m = m_pullup(m, skip);
	    if (m == NULL)
	    {
		DPRINTF(("ah_new_output(): m_pullup() failed, SA %s/%08x\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_hdrops++;
		return ENOBUFS;
	    }

	    ptr = mtod(m, unsigned char *) + sizeof(struct ip);

	    bcopy(mtod(m, unsigned char *), (unsigned char *) &ipo,
		  sizeof(struct ip));

	    ipo.ip_tos = 0;
	    ipo.ip_off = 0;
	    ipo.ip_ttl = 0;
	    ipo.ip_sum = 0;
	    ipo.ip_p = IPPROTO_AH;
	    ipo.ip_len = htons(ntohs(ipo.ip_len) + AH_NEW_FLENGTH);

	    /* 
	     * If we have a loose or strict routing option, we are
	     * supposed to use the last address in it as the
	     * destination address in the authenticated IPv4 header.
	     *
	     * Note that this is an issue only with the output routine;
	     * we will correctly process (in the AH input routine) incoming
	     * packets with these options without special consideration.
	     *
	     * We assume that the IP header contains the next hop's address,
	     * and that the last entry in the option is the final
	     * destination's address.
	     */
	    if (skip > sizeof(struct ip))
	    {
		for (off = sizeof(struct ip); off < skip;)
		{
		    /* First sanity check for zero-length options */
		    if ((ptr[off] != IPOPT_EOL) && (ptr[off] != IPOPT_NOP) &&
			(ptr[off + 1] == 0))
		    {
			DPRINTF(("ah_new_output(): illegal zero-length IPv4 option %d in SA %s/%08x\n", ptr[off], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			ahstat.ahs_hdrops++;
			m_freem(m);
			return EMSGSIZE;
		    }

		    switch (ptr[off])
		    {
			case IPOPT_LSRR:
			case IPOPT_SSRR:
			    /* Sanity check for length */
			    if (ptr[off + 1] < 2 + sizeof(struct in_addr))
			    {
				DPRINTF(("ah_new_output(): malformed LSRR or SSRR IPv4 option header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
				ahstat.ahs_hdrops++;
				m_freem(m);
				return EMSGSIZE;
			    }

			    bcopy(ptr + off + ptr[off + 1] -
				  sizeof(struct in_addr),
				  &(ipo.ip_dst), sizeof(struct in_addr));
			    off = skip;
			    break;

			case IPOPT_EOL:
			    off = skip;
			    break;

			case IPOPT_NOP:
			    off++;
			    break;

			default:  /* Some other option, just skip it */
			    off += ptr[off + 1];
			    break;
		    }

		    /* Sanity check */
		    if (off > skip)
		    {
			DPRINTF(("ah_new_output(): malformed IPv4 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			ahstat.ahs_hdrops++;
			m_freem(m);
			return EMSGSIZE;
		    }
		}
	    }

	    /* Include IP header in authenticator computation */
	    ahx->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));

	    /* IPv4 option processing */
	    for (off = sizeof(struct ip); off < skip;)
	    {
		switch (ptr[off])
		{
		    case IPOPT_EOL:
			ahx->Update(&ctx, ptr + off, 1);
			off = skip;  /* End the loop */
			break;

		    case IPOPT_NOP:
			ahx->Update(&ctx, ptr + off, 1);
			off++;
			break;

		    case IPOPT_SECURITY:	/* 0x82 */
		    case 0x85:	/* Extended security */
		    case 0x86:	/* Commercial security */
		    case 0x94:	/* Router alert */
		    case 0x95:	/* RFC1770 */
			ahx->Update(&ctx, ptr + off, ptr[off + 1]);
			off += ptr[off + 1];
			break;

		    default:
			ahx->Update(&ctx, ipseczeroes, ptr[off + 1]);
			off += ptr[off + 1];
			break;
		}

		/* Sanity check */
		if (off > skip)
		{
		    DPRINTF(("ah_new_output(): malformed IPv4 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    ahstat.ahs_hdrops++;
		    m_freem(m);
		    return EMSGSIZE;
		}
	    }
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    /* Copy and "cook" the IPv6 header */
	    m_copydata(m, 0, sizeof(ip6), (unsigned char *) &ip6);

	    /* We don't do IPv6 Jumbograms */
	    if (ip6.ip6_plen == 0)
	    {
		DPRINTF(("ah_new_output(): unsupported IPv6 jumbogram in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_hdrops++;
		m_freem(m);
		return EMSGSIZE;
	    }

	    ip6.ip6_flow = 0;
	    ip6.ip6_hlim = 0;
	    ip6.ip6_vfc &= ~IPV6_VERSION_MASK;
	    ip6.ip6_vfc |= IPV6_VERSION;

	    /*
	     * Note that here we assume that on output, the IPv6 header
	     * and any Type0 Routing Header present have been made to look
	     * like the will at the destination. Note that this is a
	     * different assumption than we made for IPv4 (because of 
	     * different option processing in IPv4 and IPv6, and different
	     * code paths from IPv4/IPv6 to here).
	     */

	    /* Include IPv6 header in authenticator computation */
	    ahx->Update(&ctx, (unsigned char *) &ip6, sizeof(ip6));

	    /* Let's deal with the remaining headers (if any) */
	    if (skip - sizeof(struct ip6_hdr) > 0)
	    {
		if (m->m_len <= skip)
		{
		    MALLOC(ptr, unsigned char *,
			   skip - sizeof(struct ip6_hdr), M_XDATA, M_WAITOK);

		    /* Copy all the protocol headers after the IPv6 header */
		    m_copydata(m, sizeof(struct ip6_hdr),
			       skip - sizeof(struct ip6_hdr), ptr);
		}
		else
		  ptr = mtod(m, unsigned char *) + sizeof(struct ip6_hdr);
	    }
	    else
	      break; /* Done */

	    off = ip6.ip6_nxt & 0xff; /* Next header type */
	    for (len = 0; len < skip - sizeof(struct ip6_hdr);)
	      switch (off)
	      {
		  case IPPROTO_HOPOPTS:
		  case IPPROTO_DSTOPTS:
		      ip6e = (struct ip6_ext *) (ptr + len);

		      /*
		       * Process the mutable/immutable options -- borrows
		       * heavily from the KAME code.
		       */
		      for (last = len, count = len + sizeof(struct ip6_ext);
			   count < len + ((ip6e->ip6e_len + 1) << 3);)
		      {
			  if (ptr[count] == IP6OPT_PAD1)
			  {
			      count++;
			      continue;
			  }

			  /* Sanity check */
			  if (count + sizeof(struct ip6_ext) > len +
			      ((ip6e->ip6e_len + 1) << 3))
			  {
			      DPRINTF(("ah_new_output(): malformed IPv6 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			      ahstat.ahs_hdrops++;
			      m_freem(m);

			      /* Free, if we allocated */
			      if (m->m_len < skip)
				FREE(ptr, M_XDATA);
			      return EMSGSIZE;
			  }

			  /*
			   * If mutable option, calculate authenticator
			   * for all immutable fields so far, then include
			   * a zeroed-out version of this option.
			   */
			  if (ptr[count] & IP6OPT_MUTABLE)
			  {
			      /* Calculate immutables */
			      ahx->Update(&ctx, ptr + last, count + 2 - last);
			      last = count + ptr[count + 1];

			      /* Calculate "zeroed-out" immutables */
			      ahx->Update(&ctx, ipseczeroes,
					  ptr[count + 1] - 2);
			  }
			  
			  count += ptr[count + 1];

			  /* Sanity check */
			  if (count > skip - sizeof(struct ip6_hdr))
			  {
			      DPRINTF(("ah_new_output(): malformed IPv6 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			      ahstat.ahs_hdrops++;
			      m_freem(m);

			      /* Free, if we allocated */
			      if (m->m_len < skip)
				FREE(ptr, M_XDATA);
			      return EMSGSIZE;
			  }
		      }

		      /* Include any trailing immutable options */
		      ahx->Update(&ctx, ptr + last,
				  len + ((ip6e->ip6e_len + 1) << 3) - last);

		      len += ((ip6e->ip6e_len + 1) << 3); /* Advance */
		      off = ip6e->ip6e_nxt;
		      break;

		  case IPPROTO_ROUTING:
		      ip6e = (struct ip6_ext *) (ptr + len);
		      ahx->Update(&ctx, ptr + len, (ip6e->ip6e_len + 1) << 3);
		      len += ((ip6e->ip6e_len + 1) << 3); /* Advance */
		      off = ip6e->ip6e_nxt;
		      break;
	      }
	    
	    /* Free, if we allocated */
	    if (m->m_len < skip)
	    {
		FREE(ptr, M_XDATA);
		ptr = NULL;
	    }

	    break;
#endif /* INET6 */

	default:
	    DPRINTF(("ah_new_output(): unsupported protocol family %d in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_nopf++;
	    m_freem(m);
	    return EPFNOSUPPORT;
    }

    /* Inject AH header */
    (*mp) = m_inject(m, skip, AH_NEW_FLENGTH, M_WAITOK);
    if ((*mp) == NULL)
    {
	DPRINTF(("ah_new_output(): failed to inject AH header for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_wrap++;
	return ENOBUFS;
    }

    /*
     * The AH header is guaranteed by m_inject() to be in contiguous memory,
     * at the beginning of the returned mbuf.
     */
    ah = mtod((*mp), struct ah_new *);
    
    /* Initialize the AH header */
    m_copydata(m, protoff, 1, &(ah->ah_nh)); /* Save Next Protocol field */
    ah->ah_hl = ((AH_HMAC_RPLENGTH + AH_HMAC_HASHLEN) >> 2);
    ah->ah_rv = 0;
    ah->ah_spi = tdb->tdb_spi;
    ah->ah_rpl = htonl(tdb->tdb_rpl++);

    /* Update the Next Protocol field in the IP header */
    len = IPPROTO_AH;
    m_copyback(m, protoff, 1, (unsigned char *) &len);

    /* Include the header AH in the authenticator computation */
    ahx->Update(&ctx, (unsigned char *) ah, AH_NEW_FLENGTH - AH_HMAC_HASHLEN);
    ahx->Update(&ctx, ipseczeroes, AH_HMAC_HASHLEN);

    /* Calculate the authenticator over the rest of the packet */
    len = m->m_pkthdr.len - (skip + AH_NEW_FLENGTH);
    off = AH_NEW_FLENGTH;

    while (len > 0)
    {
	if ((*mp) == 0)
	{
	    DPRINTF(("ah_new_output(): bad mbuf chain for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    (*mp) = NULL;
	    return EMSGSIZE;
	}

	count = min((*mp)->m_len - off, len);

	ahx->Update(&ctx, mtod((*mp), unsigned char *) + off, count);

	len -= count;
	off = 0;
	(*mp) = (*mp)->m_next;
    }

    /* Finish computing the authenticator */
    ahx->Final(calcauth, &ctx);
    bcopy(tdb->tdb_octx, &ctx, ahx->ctxsize);
    ahx->Update(&ctx, calcauth, ahx->hashsize);
    ahx->Final(calcauth, &ctx);

    /* Copy the authenticator */
    bcopy(calcauth, ah->ah_data, AH_HMAC_HASHLEN);

    *mp = m;
	
    return 0;
}
@


1.36
log
@Add ingress ACL for IPsec: after being processed, IPsec packets are
matched against a list of acceptable packet classes, if
sysctl variable net.inet.ip.ipsec-acl is set to 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.35 1999/12/15 07:07:59 itojun Exp $	*/
@


1.35
log
@do not overwrite traffic class portion when filling in IPv6 version field.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.34 1999/12/09 20:22:03 angelos Exp $	*/
d1056 1
a1056 1
	    ahstat.ahs_hdrops++;
@


1.34
log
@Fix comment typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.33 1999/12/08 07:07:27 angelos Exp $	*/
d386 2
a387 1
	    ip6.ip6_vfc = IPV6_VERSION; /* This resets some bitfields */
d928 2
a929 1
	    ip6.ip6_vfc = IPV6_VERSION; /* This resets some bitfields */
@


1.33
log
@Type in sizeofs
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.32 1999/12/08 06:16:56 angelos Exp $	*/
d524 1
a524 1
    /* Record the begining of the AH header */
d608 1
a608 1
	/* The AH header was conveniently at the begining of the mbuf */
d619 1
a619 1
	   * begining of the remainder of the mbuf chain, if any.
d1071 1
a1071 1
     * at the begining of the returned mbuf.
@


1.32
log
@IPv6 header handling, improve IPv4 option handling support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.31 1999/12/08 02:26:18 angelos Exp $	*/
d457 1
a457 1
					  count + sizeof(struct ip6e_ext) -
d460 1
a460 1
				     sizeof(struct ip6e_ext);
@


1.31
log
@AH finished, a couple of cosmetic changes in ESP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.30 1999/12/07 08:58:00 angelos Exp $	*/
d202 1
a206 1
    unsigned char *ptr;
d210 6
d289 1
a289 1
	     * This is the most painless way of dealing with IPv4 header
d339 9
d356 9
d371 144
a514 1
	    /* XXX */
d666 1
a671 1
    unsigned char *ptr;
d675 6
d796 70
d898 9
d913 137
@


1.30
log
@New ah_new_input(), protocol-independent processing (still lacking
IPv6-specific protocol header processing).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.29 1999/12/06 07:14:35 angelos Exp $	*/
d207 1
a207 1
    struct ip *ipo;
d296 1
a296 1
	    ptr = mtod(m, unsigned char *);
d298 13
a310 9
	    ipo = (struct ip *) ptr;
	    ipo->ip_tos = 0;
	    ipo->ip_len += skip;     /* adjusted in ip_intr() */
	    HTONS(ipo->ip_len);
	    HTONS(ipo->ip_id);
	    ipo->ip_off = 0;
	    ipo->ip_ttl = 0;
	    ipo->ip_sum = 0;
	    ahx->Update(&ctx, ptr, sizeof(struct ip));
a354 1
	    
d497 3
a499 3
    struct ip *ip, ipo;
    struct ah_new aho, *ah;
    register int len, off, count, ilen;
d501 6
a506 2
    u_int8_t optval;
    u_char opts[40];
d509 3
a511 2
    m = m_pullup(m, sizeof(struct ip));
    if (m == NULL)
d513 1
a513 1
	DPRINTF(("ah_new_output(): m_pullup() failed, SA %s/%08x\n",
d515 3
a517 2
	ahstat.ahs_hdrops++;
      	return ENOBUFS;
d519 3
a521 4
	
    ip = mtod(m, struct ip *);
	
    if ((ip->ip_hl << 2) > sizeof(struct ip))
d523 5
a527 10
        if ((m = m_pullup(m, ip->ip_hl << 2)) == NULL)
        {
            DPRINTF(("ah_new_output(): m_pullup() failed, SA %s/%08x\n",
		     ipsp_address(tdb->tdb_dst),
		     ntohl(tdb->tdb_spi)));
            ahstat.ahs_hdrops++;
            return ENOBUFS;
        }

        ip = mtod(m, struct ip *);
d529 1
d532 2
a533 2
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);
    ahstat.ahs_obytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);
d553 28
a580 3
    /* Save options */
    m_copydata(m, sizeof(struct ip), (ip->ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) opts);
d582 4
a585 1
    ilen = ntohs(ip->ip_len);
d587 2
a588 7
    if (AH_NEW_FLENGTH + ilen > IP_MAXPACKET)
    {
	DPRINTF(("ah_new_output(): packet in SA %s/%08x got too big\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_toobig++;
        return EMSGSIZE;
d591 1
a591 18
    ipo.ip_v = IPVERSION;
    ipo.ip_hl = ip->ip_hl;
    ipo.ip_tos = 0;
    ipo.ip_len = htons(AH_NEW_FLENGTH + ilen);
    ipo.ip_id = ip->ip_id;
    ipo.ip_off = 0;
    ipo.ip_ttl = 0;
    ipo.ip_p = IPPROTO_AH;
    ipo.ip_sum = 0;
    ipo.ip_src = ip->ip_src;
    ipo.ip_dst = ip->ip_dst;

    bzero(&aho, sizeof(struct ah_new));

    aho.ah_nh = ip->ip_p;
    aho.ah_hl = ((AH_HMAC_RPLENGTH + AH_HMAC_HASHLEN) >> 2);
    aho.ah_rv = 0;
    aho.ah_spi = tdb->tdb_spi;
d593 1
a593 1
    if (tdb->tdb_rpl == 0)
d595 15
a609 6
	DPRINTF(("ah_new_output(): SA %s/%08x should have expired\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_wrap++;
	return NULL;
    }
d611 1
a611 1
    aho.ah_rpl = htonl(tdb->tdb_rpl++);
d613 2
a614 2
    bcopy(tdb->tdb_ictx, (caddr_t)&ctx, ahx->ctxsize);
    ahx->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));
d616 6
a621 9
    /* Options */
    if ((ip->ip_hl << 2) > sizeof(struct ip))
      for (off = sizeof(struct ip); off < (ip->ip_hl << 2);)
      {
          optval = ((u_int8_t *) ip)[off];
          switch (optval)
          {
              case IPOPT_EOL:
		  ahx->Update(&ctx, ipseczeroes, 1);
d623 2
a624 2
                  off = ip->ip_hl << 2;
                  break;
d626 9
a634 2
              case IPOPT_NOP:
                  ahx->Update(&ctx, ipseczeroes, 1);
d636 4
a639 2
                  off++;
                  break;
d641 8
a648 4
              case IPOPT_SECURITY:
              case 133:
              case 134:
                  optval = ((u_int8_t *) ip)[off + 1];
d650 8
a657 1
		  ahx->Update(&ctx, (u_int8_t *) ip + off, optval);
d659 3
a661 2
                  off += optval;
                  break;
d663 6
a668 2
              default:
                  optval = ((u_int8_t *) ip)[off + 1];
d670 9
a678 1
		  ahx->Update(&ctx, ipseczeroes, optval);
d680 16
a695 4
                  off += optval;
                  break;
          }
      }
d697 3
a699 3
    ahx->Update(&ctx, (unsigned char *) &aho, AH_NEW_FLENGTH);

    off = ip->ip_hl << 2;
d701 3
a703 6
    /*
     * Code shamelessly stolen from m_copydata
     */
    len = m->m_pkthdr.len - off;
	
    *mp = m;
d709 1
a709 1
	    DPRINTF(("ah_new_output(): bad mbuf chain for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
d712 1
d718 1
a718 1
	ahx->Update(&ctx, mtod(*mp, unsigned char *) + off, count);
d722 1
a722 24
	*mp = (*mp)->m_next;
    }

    *mp = NULL;

    ipo.ip_tos = ip->ip_tos;
    ipo.ip_id = ip->ip_id;
    ipo.ip_off = ip->ip_off;
    ipo.ip_ttl = ip->ip_ttl;
/*  ipo.ip_len = ntohs(ipo.ip_len); */
	
    M_PREPEND(m, AH_NEW_FLENGTH, M_DONTWAIT);
    if (m == NULL)
    {
        DPRINTF(("ah_new_output(): M_PREPEND() failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
        return ENOBUFS;
    }

    m = m_pullup(m, AH_NEW_FLENGTH + (ipo.ip_hl << 2));
    if (m == NULL)
    {
	DPRINTF(("ah_new_output(): m_pullup() failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_hdrops++;
        return ENOBUFS;
a723 12
	
    ip = mtod(m, struct ip *);
    ah = (struct ah_new *) ((u_int8_t *) ip + (ipo.ip_hl << 2));
    *ip = ipo;
    ah->ah_nh = aho.ah_nh;
    ah->ah_hl = aho.ah_hl;
    ah->ah_rv = aho.ah_rv;
    ah->ah_spi = aho.ah_spi;
    ah->ah_rpl = aho.ah_rpl;

    /* Restore the options */
    bcopy(opts, (caddr_t) (ip + 1), (ip->ip_hl << 2) - sizeof(struct ip));
d726 1
a726 1
    ahx->Final(opts, &ctx);
d728 2
a729 2
    ahx->Update(&ctx, opts, ahx->hashsize);
    ahx->Final(opts, &ctx);
d732 1
a732 1
    bcopy(opts, ah->ah_data, AH_HMAC_HASHLEN);
@


1.29
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.28 1999/10/29 02:10:01 angelos Exp $	*/
a52 1

d64 5
a68 4
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
d80 4
d95 1
a95 2
 * ah_new_attach() is called from the transformation initialization code.
 * It just returns.
a96 1

d192 1
a192 1
 * passes authentication.
d199 3
a201 5
    struct ip *ip, ipo;
    struct ah_new *aho, *ah;
    int ohlen, len, count, off, errc;
    u_int32_t btsx;
    struct mbuf *m0;
d203 6
a208 2
    u_int8_t optval;
    u_char buffer[40];
d210 2
a211 2
    aho = (struct ah_new *) buffer;
    ohlen = sizeof(struct ip) + AH_NEW_FLENGTH;
d213 2
a214 1
    if (m->m_len < ohlen)
d216 2
a217 1
	if ((m = m_pullup(m, ohlen)) == NULL)
d219 2
a220 7
	    ahstat.ahs_hdrops++;
	    DPRINTF(("ah_new_input(): (possibly too short) packet dropped\n"));
	    return NULL;
	}
    }

    ip = mtod(m, struct ip *);
d222 18
a239 9
    /* Adjust, if options are present */
    if ((ip->ip_hl << 2) > sizeof(struct ip))
    {
	if ((m = m_pullup(m, ohlen - sizeof (struct ip) +
			  (ip->ip_hl << 2))) == NULL)
	{
	    DPRINTF(("ah_new_input(): m_pullup() failed\n"));
	    ahstat.ahs_hdrops++;
	    return NULL;
a240 4
	
	ip = mtod(m, struct ip *);
	ah = (struct ah_new *) ((u_int8_t *) ip + (ip->ip_hl << 2));
	ohlen += ((ip->ip_hl << 2) - sizeof(struct ip));
a241 2
    else
      ah = (struct ah_new *) (ip + 1);
d243 2
a244 1
    if (ah->ah_hl * sizeof(u_int32_t) != AH_HMAC_HASHLEN + AH_HMAC_RPLENGTH)
d246 1
a246 1
	DPRINTF(("ah_new_input(): bad authenticator length for packet from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(ah->ah_spi)));
d253 4
a256 4
    tdb->tdb_cur_bytes += ip->ip_len - (ip->ip_hl << 2) -
			  ah->ah_hl * sizeof(u_int32_t);
    ahstat.ahs_ibytes += ip->ip_len - (ip->ip_hl << 2) -
			 ah->ah_hl * sizeof(u_int32_t);
d276 3
a278 2
    /* Replay window checking */
    if (tdb->tdb_wnd > 0)
d280 9
a288 5
	btsx = ntohl(ah->ah_rpl);
	if ((errc = checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl), tdb->tdb_wnd,
					&(tdb->tdb_bitmap))) != 0)
	{
	    switch(errc)
d290 4
a293 10
		case 1:
		    DPRINTF(("ah_new_input(): replay counter wrapped for packets from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(ah->ah_spi)));
		    ahstat.ahs_wrap++;
		    break;

		case 2:
	        case 3:
		    DPRINTF(("ah_new_input(): duplicate packet received from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(ah->ah_spi)));
		    ahstat.ahs_replay++;
		    break;
d296 1
a296 4
	    m_freem(m);
	    return NULL;
	}
    }
d298 9
a306 8
    ipo = *ip;
    ipo.ip_tos = 0;
    ipo.ip_len += (ip->ip_hl << 2);     /* adjusted in ip_intr() */
    HTONS(ipo.ip_len);
    HTONS(ipo.ip_id);
    ipo.ip_off = 0;
    ipo.ip_ttl = 0;
    ipo.ip_sum = 0;
d308 30
a337 2
    bcopy(tdb->tdb_ictx, &ctx, ahx->ctxsize);
    ahx->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));
d339 2
a340 9
    /* Options */
    if ((ip->ip_hl << 2) > sizeof(struct ip))
      for (off = sizeof(struct ip); off < (ip->ip_hl << 2);)
      {
	  optval = ((u_int8_t *) ip)[off];
	  switch (optval)
	  {
	      case IPOPT_EOL:
		  ahx->Update(&ctx, ipseczeroes, 1);
d342 3
a344 2
		  off = ip->ip_hl << 2;
		  break;
d346 7
a352 2
	      case IPOPT_NOP:
		  ahx->Update(&ctx, ipseczeroes, 1);
d354 3
a356 2
		  off++;
		  break;
d358 10
a367 4
	      case IPOPT_SECURITY:
	      case 133:
	      case 134:
		  optval = ((u_int8_t *) ip)[off + 1];
d369 16
a384 7
		  ahx->Update(&ctx, (u_int8_t *) ip + off, optval);

		  off += optval;
		  break;

	      default:
		  optval = ((u_int8_t *) ip)[off + 1];
d386 2
a387 1
		  ahx->Update(&ctx, ipseczeroes, optval);
d389 1
a389 6
		  off += optval;
		  break;
	  }
      }

    ahx->Update(&ctx, (unsigned char *) ah, AH_NEW_FLENGTH - AH_HMAC_HASHLEN);
d392 2
a393 23
    /*
     * Code shamelessly stolen from m_copydata
     */
    off = ohlen;
    len = m->m_pkthdr.len - off;
    m0 = m;
	
    while (off > 0)
    {
	if (m0 == 0)
	{
	    DPRINTF(("ah_new_input(): bad mbuf chain for packet from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(ah->ah_spi)));
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    return NULL;
	}

	if (off < m0->m_len)
	  break;

	off -= m0->m_len;
	m0 = m0->m_next;
    }
d395 1
d398 1
a398 1
	if (m0 == 0)
d400 1
a400 1
	    DPRINTF(("ah_new_input(): bad mbuf chain for packet from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(ah->ah_spi)));
d415 2
a416 1
    ahx->Final((unsigned char *) (aho->ah_data), &ctx);
d418 2
a419 2
    ahx->Update(&ctx, (unsigned char *) (aho->ah_data), ahx->hashsize);
    ahx->Final((unsigned char *) (aho->ah_data), &ctx);
d421 2
a422 1
    if (bcmp(aho->ah_data, ah->ah_data, AH_HMAC_HASHLEN))
d424 1
a424 1
	DPRINTF(("ah_new_input(): authentication failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ip->ip_src), inet_ntoa4(ip->ip_dst), ntohl(ah->ah_spi)));
a428 22
	
    ipo = *ip;
    ipo.ip_p = ah->ah_nh;

    /* Save options */
    m_copydata(m, sizeof(struct ip), (ip->ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) buffer);

    m->m_len -= AH_NEW_FLENGTH;
    m->m_data += AH_NEW_FLENGTH;
    m->m_pkthdr.len -= AH_NEW_FLENGTH;

    ip = mtod(m, struct ip *);
    *ip = ipo;
    ip->ip_len = htons(ip->ip_len - AH_NEW_FLENGTH + (ip->ip_hl << 2));
    HTONS(ip->ip_id);
    HTONS(ip->ip_off);
    ip->ip_sum = 0;

    /* Copy the options back */
    m_copyback(m, sizeof(struct ip), (ip->ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) buffer);
d430 55
a484 1
    ip->ip_sum = in_cksum(m, (ip->ip_hl << 2));
@


1.28
log
@Get rid of unnecessary third argument in *_output routines of IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.27 1999/06/30 17:23:59 deraadt Exp $	*/
d194 1
a194 1
ah_new_input(struct mbuf *m, struct tdb *tdb)
d435 2
a436 1
ah_new_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp)
@


1.27
log
@remove final low-level crypto knowledge from base ipsec code
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.26 1999/05/16 21:48:31 niklas Exp $	*/
d435 1
a435 2
ah_new_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb, 
	      struct mbuf **mp)
@


1.26
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.25 1999/03/24 17:00:44 niklas Exp $	*/
d80 8
a87 22
struct auth_hash ah_new_hash[] = {
     { SADB_AALG_MD5HMAC96, "HMAC-MD5-96", 
       MD5HMAC96_KEYSIZE, AH_MD5_ALEN,
       sizeof(MD5_CTX),
       (void (*)(void *)) MD5Init, 
       (void (*)(void *, u_int8_t *, u_int16_t)) MD5Update, 
       (void (*)(u_int8_t *, void *)) MD5Final 
     },
     { SADB_AALG_SHA1HMAC96, "HMAC-SHA1-96",
       SHA1HMAC96_KEYSIZE, AH_SHA1_ALEN,
       sizeof(SHA1_CTX),
       (void (*)(void *)) SHA1Init, 
       (void (*)(void *, u_int8_t *, u_int16_t)) SHA1Update, 
       (void (*)(u_int8_t *, void *)) SHA1Final 
     },
     { SADB_AALG_X_RIPEMD160HMAC96, "HMAC-RIPEMD-160-96",
       RIPEMD160HMAC96_KEYSIZE, AH_RMD160_ALEN,
       sizeof(RMD160_CTX),
       (void (*)(void *)) RMD160Init, 
       (void (*)(void *, u_int8_t *, u_int16_t)) RMD160Update, 
       (void (*)(u_int8_t *, void *)) RMD160Final 
     }
d111 2
a112 3
    for (i = sizeof(ah_new_hash) / sizeof(struct auth_hash) - 1;
	 i >= 0; i--) 
      if (ii->ii_authalg == ah_new_hash[i].type)
d121 1
a121 1
    thash = &ah_new_hash[i];
d202 1
a202 5
    union {
	 MD5_CTX md5ctx; 
	 SHA1_CTX sha1ctx;
	 RMD160_CTX rmd160ctx;
    } ctx;
d442 1
a442 5
    union {
	 MD5_CTX md5ctx;
	 SHA1_CTX sha1ctx;
	 RMD160_CTX rmd160ctx;
    } ctx;
@


1.25
log
@Implement lifetime expiration notifications.  Fix some typos.  Remove statics.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.24 1999/02/25 20:14:36 angelos Exp $	*/
d277 1
a277 1
	  tdb_delete(tdb, 0);
d504 1
a504 1
	  tdb_delete(tdb, 0);
@


1.24
log
@Bzero key information before free'ing it, just for paranoia's sake.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.23 1999/02/24 23:45:47 angelos Exp $	*/
d276 1
a276 3
/* XXX
   encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d286 1
a286 3
/* XXX
   encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
d503 1
a503 3
/* XXX
   encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d513 1
a513 3
/* XXX
   encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
@


1.23
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.22 1999/02/24 22:32:59 angelos Exp $	*/
d184 3
d193 3
@


1.22
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.21 1999/01/11 22:52:09 deraadt Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
a521 2

    DPRINTF(("ah_new_output(): using hash algorithm %s\n", ahx->name));
@


1.21
log
@remove panic() calls, consistent error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.20 1998/11/25 09:56:50 niklas Exp $	*/
a67 2
#include <net/encap.h>

d70 1
d78 3
a80 5
extern void encap_sendnotify(int, struct tdb *, void *);

struct ah_hash ah_new_hash[] = {
     { ALG_AUTH_MD5, "HMAC-MD5-96", 
       AH_MD5_ALEN,
d86 2
a87 2
     { ALG_AUTH_SHA1, "HMAC-SHA1-96",
       AH_SHA1_ALEN,
d93 2
a94 2
     { ALG_AUTH_RMD160, "HMAC-RIPEMD-160-96",
       AH_RMD160_ALEN,
a109 1
    DPRINTF(("ah_new_attach(): setting up\n"));
d114 1
a114 2
 * ah_new_init() is called when an SPI is being set up. It interprets the
 * encap_msghdr present in m, and sets up the transformation data.
d118 1
a118 1
ah_new_init(struct tdb *tdbp, struct xformsw *xsp, struct mbuf *m)
d120 2
a121 15
    struct ah_new_xdata *xd;
    struct ah_new_xencap txd;
    struct encap_msghdr *em;
    struct ah_hash *thash;
    caddr_t buffer = NULL;
    int blocklen, i;

    if (m->m_len < ENCAP_MSG_FIXED_LEN)
    {
        if ((m = m_pullup(m, ENCAP_MSG_FIXED_LEN)) == NULL)
        {
	    DPRINTF(("ah_new_init(): m_pullup failed\n"));
            return ENOBUFS;
        }
    }
d123 4
a126 6
    em = mtod(m, struct encap_msghdr *);
    if (em->em_msglen - EMT_SETSPI_FLEN <= AH_NEW_XENCAP_LEN)
    {
	DPRINTF(("ah_new_init() initialization failed\n"));
	return EINVAL;
    }
a127 7
    /* Just copy the standard fields */
    m_copydata(m, EMT_SETSPI_FLEN, AH_NEW_XENCAP_LEN, (caddr_t) &txd);

    /* Check whether the hash algorithm is supported */
    for (i = sizeof(ah_new_hash) / sizeof(struct ah_hash) - 1; i >= 0; i--) 
	if (txd.amx_hash_algorithm == ah_new_hash[i].type)
	      break;
d130 1
a130 1
	DPRINTF(("ah_new_init(): unsupported authentication algorithm %d specified\n", txd.amx_hash_algorithm));
d133 1
a133 2
    DPRINTF(("ah_new_init(): initalized TDB with hash algorithm %d: %s\n",
	     txd.amx_hash_algorithm, ah_new_hash[i].name));
a134 1
    blocklen = HMAC_BLOCK_LEN;
d136 1
a136 1
    if (txd.amx_keylen + EMT_SETSPI_FLEN + AH_NEW_XENCAP_LEN != em->em_msglen)
d138 1
a138 2
	DPRINTF(("ah_new_init(): message length (%d) doesn't match\n",
		 em->em_msglen));
a141 37
    MALLOC(tdbp->tdb_xdata, caddr_t, sizeof(struct ah_new_xdata),
	   M_XDATA, M_WAITOK);
    if (tdbp->tdb_xdata == NULL)
    {
	DPRINTF(("ah_new_init(): MALLOC failed\n"));
      	return ENOBUFS;
    }

    MALLOC(buffer, caddr_t,
	   (txd.amx_keylen < blocklen ? blocklen : txd.amx_keylen),
	   M_TEMP, M_WAITOK);
    if (buffer == NULL)
    {
        DPRINTF(("ah_new_init(): MALLOC failed\n"));
	free(tdbp->tdb_xdata, M_XDATA);
        return ENOBUFS;
    }

    bzero(buffer, (txd.amx_keylen < blocklen ? blocklen : txd.amx_keylen));
    bzero(tdbp->tdb_xdata, sizeof(struct ah_new_xdata));
    xd = (struct ah_new_xdata *) tdbp->tdb_xdata;

    /* Copy the key to the buffer */
    m_copydata(m, EMT_SETSPI_FLEN + AH_NEW_XENCAP_LEN, txd.amx_keylen, buffer);

    xd->amx_hash = thash;
    /* Shorten the key if necessary */
    if (txd.amx_keylen > blocklen)
    {
	xd->amx_hash->Init(&(xd->amx_ictx));
	xd->amx_hash->Update(&(xd->amx_ictx), buffer, txd.amx_keylen);
	bzero(buffer,
	      (txd.amx_keylen < blocklen ? blocklen : txd.amx_keylen));
	xd->amx_hash->Final(buffer, &(xd->amx_ictx));
    }

    /* Pointer to the transform */
d143 3
d147 2
a148 7
    /* Pass name of auth algorithm for kernfs */
    tdbp->tdb_authname = xd->amx_hash->name;

    xd->amx_hash_algorithm = txd.amx_hash_algorithm;
    xd->amx_rpl = AH_HMAC_INITIAL_RPL;
    xd->amx_wnd = txd.amx_wnd;
    xd->amx_bitmap = 0;
d151 2
a152 5
    for (i = 0; i < blocklen; i++)
      buffer[i] ^= HMAC_IPAD_VAL;

    xd->amx_hash->Init(&(xd->amx_ictx));
    xd->amx_hash->Update(&(xd->amx_ictx), buffer, blocklen);
d154 16
a169 8
    for (i = 0; i < blocklen; i++)
      buffer[i] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);

    xd->amx_hash->Init(&(xd->amx_octx));
    xd->amx_hash->Update(&(xd->amx_octx), buffer, blocklen);

    bzero(buffer, blocklen);			/* paranoid */
    free(buffer, M_TEMP);
d180 1
a180 2
    DPRINTF(("ah_new_zeroize(): freeing memory\n"));
    if (tdbp->tdb_xdata)
d182 2
a183 2
    	FREE(tdbp->tdb_xdata, M_XDATA);
	tdbp->tdb_xdata = NULL;
d185 7
d203 1
a203 1
    struct ah_new_xdata *xd;
a217 3

    xd = (struct ah_new_xdata *) tdb->tdb_xdata;

d252 1
a252 1
	DPRINTF(("ah_new_input(): bad authenticator length for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi)));
d258 28
d287 1
a287 1
    if (xd->amx_wnd >= 0)
d290 2
a291 2
	if ((errc = checkreplaywindow32(btsx, 0, &(xd->amx_rpl), xd->amx_wnd,
					&(xd->amx_bitmap))) != 0)
d296 1
a296 1
		    DPRINTF(("ah_new_input(): replay counter wrapped for packets from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi)));
d302 1
a302 1
		    DPRINTF(("ah_new_input(): duplicate packet received, %x->%x spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi)));
d321 2
a322 2
    bcopy(&(xd->amx_ictx), &ctx, xd->amx_hash->ctxsize);
    xd->amx_hash->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));
d332 1
a332 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, 1);
d338 1
a338 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, 1);
d348 1
a348 1
		  xd->amx_hash->Update(&ctx, (u_int8_t *) ip + off, optval);
d356 1
a356 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, optval);
d363 2
a364 3
    xd->amx_hash->Update(&ctx, (unsigned char *) ah, AH_NEW_FLENGTH -
			 AH_HMAC_HASHLEN);
    xd->amx_hash->Update(&ctx, ipseczeroes, AH_HMAC_HASHLEN);
d377 1
a377 1
	    DPRINTF(("ah_new_input(): bad mbuf chain for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi)));
d394 1
a394 1
	    DPRINTF(("ah_new_input(): bad mbuf chain for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi)));
d402 1
a402 1
	xd->amx_hash->Update(&ctx, mtod(m0, unsigned char *) + off, count);
d409 4
a412 5
    xd->amx_hash->Final((unsigned char *) (aho->ah_data), &ctx);
    bcopy(&(xd->amx_octx), &ctx, xd->amx_hash->ctxsize);
    xd->amx_hash->Update(&ctx, (unsigned char *) (aho->ah_data),
			 xd->amx_hash->hashsize);
    xd->amx_hash->Final((unsigned char *) (aho->ah_data), &ctx);
d416 1
a416 15
	DPRINTF(("ah_new_input(): authentication failed for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi)));
#ifdef ENCDEBUG
	if (encdebug)
	{
	    printf("Received authenticator: ");
	    for (off = 0; off < AH_HMAC_HASHLEN; off++)
	      printf("%02x ", ah->ah_data[off]);
	    printf("\n");

	    printf("Computed authenticator: ");
	    for (off = 0; off < AH_HMAC_HASHLEN; off++)
	      printf("%02x ", aho->ah_data[off]);
	    printf("\n");
	}
#endif
a445 38
    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);
    ahstat.ahs_ibytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);

    /* Notify on expiration */
    if (tdb->tdb_flags & TDBF_SOFT_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_soft_packets)
      {
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	  tdb->tdb_flags &= ~TDBF_SOFT_PACKETS;
      }
      else
	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
	  {
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;
	  }
    }

    if (tdb->tdb_flags & TDBF_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_exp_packets)
      {
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	  tdb_delete(tdb, 0);
      }
      else
	if (tdb->tdb_flags & TDBF_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)
	  {
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	      tdb_delete(tdb, 0);
	  }
    }

d453 1
a453 1
    struct ah_new_xdata *xd;
d456 1
a456 2
    register int len, off, count;
    register struct mbuf *m0;
a461 1
    int ilen, ohlen;
d463 1
a463 1
    u_char buffer[AH_ALEN_MAX], opts[40];
d469 2
a470 2
	DPRINTF(("ah_new_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
a476 2
    xd = (struct ah_new_xdata *) tdb->tdb_xdata;

d481 3
a483 2
            DPRINTF(("ah_new_output(): m_pullup() failed, SA &x/%08x\n",
		     tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d491 26
d521 1
a521 1
    DPRINTF(("ah_new_output(): using hash algorithm %s\n", xd->amx_hash->name));
d525 4
a528 4
    ohlen = AH_NEW_FLENGTH;
    if (ohlen + ilen > IP_MAXPACKET) {
	DPRINTF(("ah_new_output(): packet in SA %x/%0x8 got too big\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d537 1
a537 1
    ipo.ip_len = htons(ohlen + ilen);
d553 1
a553 1
    if (xd->amx_rpl == 0)
d555 2
a556 2
	DPRINTF(("ah_new_output(): SA %x/%0x8 should have expired\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d562 1
a562 1
    aho.ah_rpl = htonl(xd->amx_rpl++);
d564 2
a565 2
    bcopy((caddr_t)&(xd->amx_ictx), (caddr_t)&ctx, xd->amx_hash->ctxsize);
    xd->amx_hash->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));
d575 1
a575 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, 1);
d581 1
a581 1
                  xd->amx_hash->Update(&ctx, ipseczeroes, 1);
d591 1
a591 1
		  xd->amx_hash->Update(&ctx, (u_int8_t *) ip + off, optval);
d599 1
a599 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, optval);
d606 1
a606 1
    xd->amx_hash->Update(&ctx, (unsigned char *) &aho, AH_NEW_FLENGTH);
d615 1
a615 1
    m0 = m;
d619 1
a619 1
	if (m0 == 0)
d621 1
a621 1
	    DPRINTF(("ah_new_output(): bad mbuf chain for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d627 1
a627 1
	count = min(m0->m_len - off, len);
d629 1
a629 1
	xd->amx_hash->Update(&ctx, mtod(m0, unsigned char *) + off, count);
d633 1
a633 1
	m0 = m0->m_next;
d636 2
d644 1
a644 1
    M_PREPEND(m, ohlen, M_DONTWAIT);
d647 1
a647 1
        DPRINTF(("ah_new_output(): M_PREPEND() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d651 1
a651 1
    m = m_pullup(m, ohlen + (ipo.ip_hl << 2));
d654 1
a654 1
	DPRINTF(("ah_new_output(): m_pullup() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d668 2
a669 4
    xd->amx_hash->Final(buffer, &ctx);
    bcopy(&(xd->amx_octx), &ctx, xd->amx_hash->ctxsize);
    xd->amx_hash->Update(&ctx, buffer, xd->amx_hash->hashsize);
    xd->amx_hash->Final(buffer, &ctx);
d671 5
a675 3
    /* Restore the options */
    m_copyback(m, sizeof(struct ip), (ip->ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) opts);
d678 1
a678 1
    bcopy(buffer, ah->ah_data, AH_HMAC_HASHLEN);
a681 39
    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) - 
			  AH_NEW_FLENGTH;
    ahstat.ahs_obytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) - AH_NEW_FLENGTH;

    /* Notify on expiration */
    if (tdb->tdb_flags & TDBF_SOFT_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_soft_packets)
      {
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	  tdb->tdb_flags &= ~TDBF_SOFT_PACKETS;
      }
      else
	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
	  {
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;
	  }
    }

    if (tdb->tdb_flags & TDBF_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_exp_packets)
      {
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	  tdb_delete(tdb, 0);
      }
      else
	if (tdb->tdb_flags & TDBF_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)
	  {
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	      tdb_delete(tdb, 0);
	  }
    }

@


1.20
log
@Better error code for too large packets
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.19 1998/11/25 02:01:27 niklas Exp $	*/
a71 1
#include <sys/syslog.h>
d144 1
a144 2
	if (encdebug)
	  log(LOG_WARNING, "ah_new_init() initialization failed\n");
d157 1
a157 2
	if (encdebug)
	  log(LOG_WARNING, "ah_new_init(): unsupported authentication algorithm %d specified\n", txd.amx_hash_algorithm);
d167 2
a168 3
	if (encdebug)
	  log(LOG_WARNING, "ah_new_init(): message length (%d) doesn't match\n",
	      em->em_msglen);
d329 1
a329 2
		    if (encdebug)
		      log(LOG_ERR, "ah_new_input(): replay counter wrapped for packets from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
d335 1
a335 2
		    if (encdebug)
		      log(LOG_WARNING, "ah_new_input(): duplicate packet received, %x->%x spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
d410 6
a415 1
	  panic("ah_new_input(): m_copydata (off)");
d427 6
a432 1
	  panic("ah_new_input(): m_copydata (copy)");
d451 1
a451 2
	if (encdebug)
	  log(LOG_ALERT, "ah_new_input(): authentication failed for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
d560 1
d591 2
a592 4
	if (encdebug)
            log(LOG_ALERT,
		"ah_new_output(): packet in SA %x/%0x8 got too big\n",
		tdb->tdb_dst, ntohl(tdb->tdb_spi));
d619 2
a620 3
	if (encdebug)
          log(LOG_ALERT, "ah_new_output(): SA %x/%0x8 should have expired\n",
	      tdb->tdb_dst, ntohl(tdb->tdb_spi));
d684 7
a690 1
	  panic("ah_new_output(): m_copydata");
d717 1
@


1.19
log
@Add checks of packets getting to big after transforms.
Also make sure some more error conditions get told to the caller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.18 1998/06/03 09:50:18 provos Exp $	*/
d593 1
a593 1
        return ENOBUFS;
@


1.18
log
@cleanup debug printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.17 1998/05/18 21:10:33 provos Exp $	*/
d571 1
a571 1
            return NULL;
d586 9
@


1.17
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.16 1998/02/22 01:23:30 niklas Exp $	*/
d74 6
d114 1
a114 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("ah_new_attach(): setting up\n");
#endif /* ENCDEBUG */
d137 1
a137 4
#ifdef ENCDEBUG
            if (encdebug)
              printf("ah_new_init(): m_pullup failed\n");
#endif /* ENCDEBUG */
d163 2
a164 5
#ifdef ENCDEBUG
    if (encdebug)
      printf("ah_new_init(): initalized TDB with hash algorithm %d: %s\n",
	     txd.amx_hash_algorithm, ah_new_hash[i].name);
#endif /* ENCDEBUG */
d180 1
a180 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_new_init(): MALLOC failed\n");
#endif /* ENCDEBUG */
d189 1
a189 4
#ifdef ENCDEBUG
        if (encdebug)
          printf("ah_new_init(): MALLOC failed\n");
#endif /* ENCDEBUG */
d248 1
a248 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("ah_new_zeroize(): freeing memory\n");
#endif /* ENCDEBUG */
d290 1
a290 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("ah_new_input(): (possibly too short) packet dropped\n");
#endif /* ENCDEBUG */
d303 1
a303 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("ah_new_input(): m_pullup() failed\n");
#endif /* ENCDEBUG */
d317 1
a317 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_new_input(): bad authenticator length for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
#endif /* ENCDEBUG */
d555 2
a556 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_new_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d568 2
a569 5
#ifdef ENCDEBUG
            if (encdebug)
              printf("ah_new_output(): m_pullup() failed, SA &x/%08x\n",
                     tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d581 1
a581 5
#ifdef ENCDEBUG
    if (encdebug)
      printf("ah_new_output(): using hash algorithm %s\n",
	     xd->amx_hash->name);
#endif /* ENCDEBUG */
d618 1
a618 1
    bcopy(&(xd->amx_ictx), &ctx, xd->amx_hash->ctxsize);
d693 1
a693 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_new_output(): M_PREPEND() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d700 1
a700 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_new_output(): m_pullup() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
@


1.16
log
@Changes made for GCC 2.8 -Wall pleasures
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.15 1998/01/21 18:43:32 provos Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
d74 1
a74 1
extern void encap_sendnotify(int, struct tdb *);
d523 1
a523 1
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d530 1
a530 1
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d539 1
a539 1
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d546 1
a546 1
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d775 1
a775 1
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d782 1
a782 1
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d791 1
a791 1
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d798 1
a798 1
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
@


1.15
log
@rcvif not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.14 1997/11/24 19:14:12 provos Exp $	*/
d514 1
d527 2
a528 1
    
d530 1
d543 1
d766 1
d779 2
a780 1
    
d782 1
d795 1
@


1.14
log
@add ripemd-160 as authentication function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.13 1997/11/18 09:09:43 deraadt Exp $	*/
a273 1
    struct ifnet *rcvif;
a290 10
    rcvif = m->m_pkthdr.rcvif;
    if (rcvif == NULL)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_new_input(): receive interface is NULL!!!\n");
#endif /* ENCDEBUG */
	rcvif = &enc_softc;
    }
	
a492 1
    m->m_pkthdr.rcvif = rcvif;	/* this should not be necessary */
@


1.13
log
@fix 3DES, style changes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.12 1997/11/15 00:07:07 deraadt Exp $	*/
d84 7
d281 1
d568 1
@


1.12
log
@fix memory management errors
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.11 1997/11/04 09:11:01 provos Exp $	*/
d74 3
a76 3
       (void (*)(void *))MD5Init, 
       (void (*)(void *, u_int8_t *, u_int16_t))MD5Update, 
       (void (*)(u_int8_t *, void *))MD5Final 
d81 3
a83 3
       (void (*)(void *))SHA1Init, 
       (void (*)(void *, u_int8_t *, u_int16_t))SHA1Update, 
       (void (*)(u_int8_t *, void *))SHA1Final 
d141 1
a141 1
    for (i=sizeof(ah_new_hash)/sizeof(struct ah_hash)-1; i >= 0; i--) 
@


1.11
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.10 1997/10/02 02:31:03 deraadt Exp $	*/
d248 5
a252 1
    FREE(tdbp->tdb_xdata, M_XDATA);
@


1.10
log
@conditional error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.9 1997/09/28 22:57:44 deraadt Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
d70 17
d113 1
d140 5
a144 2
    /* Check whether the hash algorithm is supposed */
    switch (txd.amx_hash_algorithm)
d146 4
a149 2
	case ALG_AUTH_MD5:
	case ALG_AUTH_SHA1:
d151 3
a153 3
	    if (encdebug)
	      printf("ah_new_init(): initalized TDB with hash algorithm %d\n",
		     txd.amx_hash_algorithm);
d155 2
a156 8
	    blocklen = HMAC_BLOCK_LEN;
	    break;

	default:
	    if (encdebug)
	      log(LOG_WARNING, "ah_new_init(): unsupported authentication algorithm %d specified\n", txd.amx_hash_algorithm);
	    return EINVAL;
    }
d197 1
d201 5
a205 18
	switch (txd.amx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		MD5Init(&(xd->amx_md5_ictx));
		MD5Update(&(xd->amx_md5_ictx), buffer, txd.amx_keylen);
		bzero(buffer,
		      (txd.amx_keylen < blocklen ? blocklen : txd.amx_keylen));
		MD5Final(buffer, &(xd->amx_md5_ictx));
		break;

	    case ALG_AUTH_SHA1:
                SHA1Init(&(xd->amx_sha1_ictx));
                SHA1Update(&(xd->amx_sha1_ictx), buffer, txd.amx_keylen);
                bzero(buffer,
                      (txd.amx_keylen < blocklen ? blocklen : txd.amx_keylen));
                SHA1Final(buffer, &(xd->amx_sha1_ictx));
		break;
	}
d211 3
d223 2
a224 12
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    MD5Init(&(xd->amx_md5_ictx));
	    MD5Update(&(xd->amx_md5_ictx), buffer, blocklen);
	    break;

	case ALG_AUTH_SHA1:
	    SHA1Init(&(xd->amx_sha1_ictx));
	    SHA1Update(&(xd->amx_sha1_ictx), buffer, blocklen);
	    break;
    }
d229 2
a230 12
    switch (xd->amx_hash_algorithm)
    {
        case ALG_AUTH_MD5:
            MD5Init(&(xd->amx_md5_octx));
            MD5Update(&(xd->amx_md5_octx), buffer, blocklen);
            break;

        case ALG_AUTH_SHA1:
            SHA1Init(&(xd->amx_sha1_octx));
            SHA1Update(&(xd->amx_sha1_octx), buffer, blocklen);
            break;
    }
d267 4
a270 2
    MD5_CTX md5ctx; 
    SHA1_CTX sha1ctx;
a277 15
    switch (xd->amx_hash_algorithm)
    {
        case ALG_AUTH_MD5:
        case ALG_AUTH_SHA1:
            break;

        default:
	    if (encdebug)
              log(LOG_ALERT,
                  "ah_new_input(): unsupported algorithm %d in SA %x/%08x\n",
                  xd->amx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
            m_freem(m);
            return NULL;
    }

d374 2
a375 12
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    md5ctx = xd->amx_md5_ictx;
	    MD5Update(&md5ctx, (unsigned char *) &ipo, sizeof(struct ip));
	    break;

        case ALG_AUTH_SHA1:
	    sha1ctx = xd->amx_sha1_ictx;
	    SHA1Update(&sha1ctx, (unsigned char *) &ipo, sizeof(struct ip));
	    break;  
    }
d385 1
a385 10
		  switch (xd->amx_hash_algorithm)
		  {
		      case ALG_AUTH_MD5:
		  	  MD5Update(&md5ctx, ipseczeroes, 1);
			  break;

		      case ALG_AUTH_SHA1:
			  SHA1Update(&sha1ctx, ipseczeroes, 1);
			  break;
		  }
d391 1
a391 10
		  switch (xd->amx_hash_algorithm)
		  {
		      case ALG_AUTH_MD5:
		  	  MD5Update(&md5ctx, ipseczeroes, 1);
			  break;

		      case ALG_AUTH_SHA1:
		  	  SHA1Update(&sha1ctx, ipseczeroes, 1);
			  break;
		  }
d401 1
a401 10
		  switch (xd->amx_hash_algorithm)
		  {
		      case ALG_AUTH_MD5:
		  	  MD5Update(&md5ctx, (u_int8_t *) ip + off, optval);
			  break;

		      case ALG_AUTH_SHA1:
			  SHA1Update(&sha1ctx, (u_int8_t *) ip + off, optval);
			  break;
		  }
d409 1
a409 10
		  switch (xd->amx_hash_algorithm)
		  {
		      case ALG_AUTH_MD5:
		  	  MD5Update(&md5ctx, ipseczeroes, optval);
			  break;

		      case ALG_AUTH_SHA1:
		  	  SHA1Update(&sha1ctx, ipseczeroes, optval);
			  break;
		  }
d416 3
a418 14
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
    	    MD5Update(&md5ctx, (unsigned char *) ah, AH_NEW_FLENGTH -
		      AH_HMAC_HASHLEN);
    	    MD5Update(&md5ctx, ipseczeroes, AH_HMAC_HASHLEN);
	    break;

	case ALG_AUTH_SHA1:
    	    SHA1Update(&sha1ctx, (unsigned char *) ah, AH_NEW_FLENGTH -
		       AH_HMAC_HASHLEN);
    	    SHA1Update(&sha1ctx, ipseczeroes, AH_HMAC_HASHLEN);
	    break;
    }
d446 1
a446 10
	switch (xd->amx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		MD5Update(&md5ctx, mtod(m0, unsigned char *) + off, count);
		break;

	    case ALG_AUTH_SHA1:
		SHA1Update(&sha1ctx, mtod(m0, unsigned char *) + off, count);
		break;
	}
d453 5
a457 18
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
    	    MD5Final((unsigned char *) (aho->ah_data), &md5ctx);
    	    md5ctx = xd->amx_md5_octx;
    	    MD5Update(&md5ctx, (unsigned char *) (aho->ah_data),
		      AH_MD5_ALEN);
    	    MD5Final((unsigned char *) (aho->ah_data), &md5ctx);
	    break;

	case ALG_AUTH_SHA1:
    	    SHA1Final((unsigned char *) (aho->ah_data), &sha1ctx);
    	    sha1ctx = xd->amx_sha1_octx;
    	    SHA1Update(&sha1ctx, (unsigned char *) (aho->ah_data),
		       AH_SHA1_ALEN);
    	    SHA1Final((unsigned char *) (aho->ah_data), &sha1ctx);
	    break;
    }
d553 4
a556 2
    MD5_CTX md5ctx;
    SHA1_CTX sha1ctx;
a596 4
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	case ALG_AUTH_SHA1:
d598 3
a600 3
	    if (encdebug)
	      printf("ah_new_output(): using hash algorithm %d\n",
		     xd->amx_hash_algorithm);
a601 10
	    break;

	default:
	    if (encdebug)
              log(LOG_ALERT,
                  "ah_new_output(): unsupported algorithm %d in SA %x/%08x\n",
                  xd->amx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
            m_freem(m);
            return NULL;
    }
d638 2
a639 12
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
    	    md5ctx = xd->amx_md5_ictx;
    	    MD5Update(&md5ctx, (unsigned char *) &ipo, sizeof(struct ip));
	    break;

	case ALG_AUTH_SHA1:
    	    sha1ctx = xd->amx_sha1_ictx;
    	    SHA1Update(&sha1ctx, (unsigned char *) &ipo, sizeof(struct ip));
	    break;
    }
d649 1
a649 10
                  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, ipseczeroes, 1);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, ipseczeroes, 1);
                          break;
                  }
d655 1
a655 10
                  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, ipseczeroes, 1);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, ipseczeroes, 1);
                          break;
                  }
d665 1
a665 10
                  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, (u_int8_t *) ip + off, optval);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, (u_int8_t *) ip + off, optval);
                          break;
                  }
d673 1
a673 10
                  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, ipseczeroes, optval);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, ipseczeroes, optval);
                          break;
                  }
d680 1
a680 10
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    MD5Update(&md5ctx, (unsigned char *) &aho, AH_NEW_FLENGTH);
	    break;

	case ALG_AUTH_SHA1:
	    SHA1Update(&sha1ctx, (unsigned char *) &aho, AH_NEW_FLENGTH);
	    break;
    }
d697 1
a697 10
	switch (xd->amx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		MD5Update(&md5ctx, mtod(m0, unsigned char *) + off, count);
	 	break;

	    case ALG_AUTH_SHA1:
		SHA1Update(&sha1ctx, mtod(m0, unsigned char *) + off, count);
		break;
	}
d739 4
a742 16
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    MD5Final(buffer, &md5ctx);
	    md5ctx = xd->amx_md5_octx;
	    MD5Update(&md5ctx, buffer, AH_MD5_ALEN);
	    MD5Final(buffer, &md5ctx);
	    break;

	case ALG_AUTH_SHA1:
	    SHA1Final(buffer, &sha1ctx);
	    sha1ctx = xd->amx_sha1_octx;
	    SHA1Update(&sha1ctx, buffer, AH_SHA1_ALEN);
	    SHA1Final(buffer, &sha1ctx);
	    break;
    }
@


1.9
log
@log() needs a \n
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.8 1997/09/23 21:42:20 angelos Exp $	*/
d110 2
a111 1
	log(LOG_WARNING, "ah_new_init() initialization failed\n");
d132 2
a133 1
	    log(LOG_WARNING, "ah_new_init(): unsupported authentication algorithm %d specified\n", txd.amx_hash_algorithm);
d139 3
a141 2
	log(LOG_WARNING, "ah_new_init(): message length (%d) doesn't match\n",
	    em->em_msglen);
d291 4
a294 3
            log(LOG_ALERT,
                "ah_new_input(): unsupported algorithm %d in SA %x/%08x\n",
                xd->amx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d368 2
a369 1
		    log(LOG_ERR, "ah_new_input(): replay counter wrapped for packets from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
d375 2
a376 1
		    log(LOG_WARNING, "ah_new_input(): duplicate packet received, %x->%x spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
d561 2
a562 2
	log(LOG_ALERT,
	    "ah_new_input(): authentication failed for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
d707 4
a710 3
            log(LOG_ALERT,
                "ah_new_output(): unsupported algorithm %d in SA %x/%08x\n",
                xd->amx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d740 3
a742 2
        log(LOG_ALERT, "ah_new_output(): SA %x/%0x8 should have expired\n",
	    tdb->tdb_dst, ntohl(tdb->tdb_spi));
@


1.8
log
@AH changes, after interoperating at the ANX bakeoff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.7 1997/08/26 12:02:48 provos Exp $	*/
d110 1
a110 1
	log(LOG_WARNING, "ah_new_init() initialization failed");
d131 1
a131 1
	    log(LOG_WARNING, "ah_new_init(): unsupported authentication algorithm %d specified", txd.amx_hash_algorithm);
d137 1
a137 1
	log(LOG_WARNING, "ah_new_init(): message length (%d) doesn't match",
d289 1
a289 1
                "ah_new_input(): unsupported algorithm %d in SA %x/%08x",
d370 1
a370 1
		    log(LOG_WARNING, "ah_new_input(): duplicate packet received, %x->%x spi %08x", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
d556 1
a556 1
	    "ah_new_input(): authentication failed for packet from %x to %x, spi %08x", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
d702 1
a702 1
                "ah_new_output(): unsupported algorithm %d in SA %x/%08x",
d733 1
a733 1
        log(LOG_ALERT, "ah_new_output(): SA %x/%0x8 should have expired",
@


1.7
log
@new esp: encryption, authentication and replay protection +
tiny bug fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.6 1997/07/27 23:30:34 niklas Exp $	*/
d343 1
a343 1
    if (ah->ah_hl * sizeof(u_int32_t) != AH_HMAC_HASHLEN)
d385 1
a385 1
    ipo.ip_off = htons(ipo.ip_off & IP_DF);     /* XXX -- and the C bit? */
d403 1
a403 1
    if ((ip->ip_hl << 2 > sizeof(struct ip)))
a491 1

a552 1

d557 14
d717 1
a717 1
    ipo.ip_off = htons(ntohs(ip->ip_off) & IP_DF);
d727 1
a727 1
    aho.ah_hl = (AH_HMAC_HASHLEN >> 2);
@


1.6
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.5 1997/07/24 01:37:10 deraadt Exp $	*/
d370 1
a370 1
		    log(LOG_WARNING, "ahhmachmd5_input(): duplicate packet received, %x->%x spi %08x", ip->ip_src, ip->ip_dst, ntohl(ah->ah_spi));
@


1.5
log
@network byte order for counters
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.4 1997/07/18 18:09:52 provos Exp $	*/
d64 2
d594 29
d923 2
a924 1
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) - AH_NEW_FLENGTH;
d926 29
@


1.4
log
@enablespi/disablespi in encap + print spi's in hostorder
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.3 1997/07/14 08:48:45 provos Exp $	*/
d892 2
a893 2
    tdb->tdb_cur_bytes += ip->ip_len - (ip->ip_hl << 2) - AH_NEW_FLENGTH;
    ahstat.ahs_obytes += ip->ip_len - (ip->ip_hl << 2) - AH_NEW_FLENGTH;
@


1.3
log
@global byte counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.2 1997/07/12 14:57:01 provos Exp $	*/
d288 1
a288 1
                xd->amx_hash_algorithm, tdb->tdb_dst, tdb->tdb_spi);
d345 1
a345 1
	  printf("ah_new_input(): bad authenticator length for packet from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ah->ah_spi);
d362 1
a362 1
		    log(LOG_ERR, "ah_new_input(): replay counter wrapped for packets from %x to %x, spi %08x\n", ip->ip_src, ip->ip_dst, ah->ah_spi);
d368 1
a368 1
		    log(LOG_WARNING, "ahhmachmd5_input(): duplicate packet received, %x->%x spi %08x", ip->ip_src, ip->ip_dst, ah->ah_spi);
d556 1
a556 1
	    "ah_new_input(): authentication failed for packet from %x to %x, spi %08x", ip->ip_src, ip->ip_dst, ah->ah_spi);
d617 1
a617 1
		 tdb->tdb_dst, tdb->tdb_spi);
d633 1
a633 1
                     tdb->tdb_dst, tdb->tdb_spi);
d660 1
a660 1
                xd->amx_hash_algorithm, tdb->tdb_dst, tdb->tdb_spi);
d691 1
a691 1
	    tdb->tdb_dst, tdb->tdb_spi);
d840 1
a840 1
	  printf("ah_new_output(): M_PREPEND() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_spi);
d850 1
a850 1
	  printf("ah_new_output(): m_pullup() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_spi);
@


1.2
log
@fixed tiny bug in pad values and hmac inner hash lengths. should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.1 1997/07/11 23:37:55 provos Exp $	*/
d590 1
d893 1
@


1.1
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_new.c,v 1.13 1997/07/01 22:12:42 provos Exp $	*/
d220 1
a220 1
      buffer[i] ^= (HMAC_IPAD_VAL ^ HMAC_IPAD_VAL);
d539 1
a539 1
		      AH_HMAC_HASHLEN);
d547 1
a547 1
		       AH_HMAC_HASHLEN);
@
