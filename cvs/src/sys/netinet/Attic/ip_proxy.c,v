head	1.14;
access;
symbols
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	UBC_SYNC_A:1.14
	UBC_SYNC_B:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2001.05.30.02.12.35;	author deraadt;	state dead;
branches;
next	1.13;

1.13
date	2001.01.30.04.23.56;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.17.04.47.15;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.10.05.50.26;	author kjell;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.16.21.47.16;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.05.05.35.27;	author kjell;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.13.23.40.18;	author kjell;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.16.22.34.19;	author kjell;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.01.19.29.59;	author kjell;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.12.15.05.20.22;	author kjell;	state Exp;
branches;
next	1.4;

1.4
date	99.02.05.05.58.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.09.15.09.51.18;	author pattonme;	state Exp;
branches;
next	1.2;

1.2
date	98.02.17.01.39.06;	author dgregor;	state Exp;
branches;
next	1.1;

1.1
date	98.01.26.04.10.45;	author dgregor;	state Exp;
branches;
next	;

1.6.2.1
date	2000.02.20.11.57.28;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.03.24.09.09.37;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.05.14.22.40.13;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.07.04.10.54.57;	author niklas;	state dead;
branches;
next	;


desc
@@


1.14
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ip_proxy.c,v 1.13 2001/01/30 04:23:56 kjell Exp $	*/

/*
 * Copyright (C) 1997-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#if !defined(lint)
static const char rcsid[] = "@@(#)$IPFilter: ip_proxy.c,v 2.9.2.1 2000/05/06 12:30:50 darrenr Exp $";
#endif

#if defined(__FreeBSD__) && defined(KERNEL) && !defined(_KERNEL)
# define	_KERNEL
#endif

#include <sys/errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/file.h>
#if !defined(__FreeBSD_version)  
# include <sys/ioctl.h>      
#endif
#include <sys/fcntl.h>
#include <sys/uio.h>
#if !defined(_KERNEL) && !defined(KERNEL)
# include <stdio.h>
# include <string.h>
# include <stdlib.h>
#endif
#ifndef	linux
# include <sys/protosw.h>
#endif
#include <sys/socket.h>
#if defined(_KERNEL)
# if !defined(linux)
#  include <sys/systm.h>
# else
#  include <linux/string.h>
# endif
#endif
#if !defined(__SVR4) && !defined(__svr4__)
# ifndef linux
#  include <sys/mbuf.h>
# endif
#else
# include <sys/byteorder.h>
# ifdef _KERNEL
#  include <sys/dditypes.h>
# endif
# include <sys/stream.h>
# include <sys/kmem.h>
#endif
#if __FreeBSD__ > 2
# include <sys/queue.h>
#endif
#include <net/if.h>
#ifdef sun
# include <net/af.h>
#endif
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#ifndef linux
# include <netinet/ip_var.h>
#endif
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_fil_compat.h>
#include <netinet/tcpip.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_state.h>
#if (__FreeBSD_version >= 300000)
# include <sys/malloc.h>
#endif


#ifndef MIN
#define MIN(a,b)        (((a)<(b))?(a):(b))
#endif

static ap_session_t *appr_new_session __P((aproxy_t *, ip_t *,
					   fr_info_t *, nat_t *));
static int appr_fixseqack __P((fr_info_t *, ip_t *, ap_session_t *, int ));


#define	AP_SESS_SIZE	53

#if defined(_KERNEL) && !defined(linux)
#include <netinet/ip_ftp_pxy.c>
#include <netinet/ip_rcmd_pxy.c>
#include <netinet/ip_raudio_pxy.c>
#endif

ap_session_t	*ap_sess_tab[AP_SESS_SIZE];
ap_session_t	*ap_sess_list = NULL;
aproxy_t	*ap_proxylist = NULL;
aproxy_t	ap_proxies[] = {
#ifdef	IPF_FTP_PROXY
	{ NULL, "ftp", (char)IPPROTO_TCP, 0, 0, ippr_ftp_init, NULL,
	  ippr_ftp_new, ippr_ftp_in, ippr_ftp_out },
#endif
#ifdef	IPF_RCMD_PROXY
	{ NULL, "rcmd", (char)IPPROTO_TCP, 0, 0, ippr_rcmd_init, NULL,
	  ippr_rcmd_new, NULL, ippr_rcmd_out },
#endif
#ifdef	IPF_RAUDIO_PROXY
	{ NULL, "raudio", (char)IPPROTO_TCP, 0, 0, ippr_raudio_init, NULL,
	  ippr_raudio_new, ippr_raudio_in, ippr_raudio_out },
#endif
	{ NULL, "", '\0', 0, 0, NULL, NULL }
};


int appr_add(ap)
aproxy_t *ap;
{
	aproxy_t *a;

	for (a = ap_proxies; a->apr_p; a++)
		if ((a->apr_p == ap->apr_p) &&
		    !strncmp(a->apr_label, ap->apr_label,
			     sizeof(ap->apr_label)))
			return -1;

	for (a = ap_proxylist; a->apr_p; a = a->apr_next)
		if ((a->apr_p == ap->apr_p) &&
		    !strncmp(a->apr_label, ap->apr_label,
			     sizeof(ap->apr_label)))
			return -1;
	ap->apr_next = ap_proxylist;
	ap_proxylist = ap;
	return (*ap->apr_init)();
}


int appr_del(ap)
aproxy_t *ap;
{
	aproxy_t *a, **app;

	for (app = &ap_proxylist; (a = *app); app = &a->apr_next)
		if (a == ap) {
			if (ap->apr_ref != 0)
				return 1;
			*app = a->apr_next;
			return 0;
		}
	return -1;
}


int appr_ok(ip, tcp, nat)
ip_t *ip;
tcphdr_t *tcp;
ipnat_t *nat;
{
	aproxy_t *apr = nat->in_apr;
	u_short dport = nat->in_dport;

	if (!apr || (apr->apr_flags & APR_DELETE) ||
	    (ip->ip_p != apr->apr_p))
		return 0;
	if ((tcp && (tcp->th_dport != dport)) || (!tcp && dport))
		return 0;
	return 1;
}


/*
 * Allocate a new application proxy structure and fill it in with the
 * relevant details.  call the init function once complete, prior to
 * returning.
 */
static ap_session_t *appr_new_session(apr, ip, fin, nat)
aproxy_t *apr;
ip_t *ip;
fr_info_t *fin;
nat_t *nat;
{
	register ap_session_t *aps;

	if (!apr || (apr->apr_flags & APR_DELETE) || (ip->ip_p != apr->apr_p))
		return NULL;

	KMALLOC(aps, ap_session_t *);
	if (!aps)
		return NULL;
	bzero((char *)aps, sizeof(*aps));
	aps->aps_p = ip->ip_p;
	aps->aps_data = NULL;
	aps->aps_apr = apr;
	aps->aps_psiz = 0;
	if (apr->apr_new != NULL)
		if ((*apr->apr_new)(fin, ip, aps, nat) == -1) {
			KFREE(aps);
			return NULL;
		}
	aps->aps_nat = nat;
	aps->aps_next = ap_sess_list;
	ap_sess_list = aps;
	return aps;
}


/*
 * check to see if a packet should be passed through an active proxy routine
 * if one has been setup for it.
 */
int appr_check(ip, fin, nat)
ip_t *ip;
fr_info_t *fin;
nat_t *nat;
{
	ap_session_t *aps;
	aproxy_t *apr;
	tcphdr_t *tcp = NULL;
	u_32_t sum;
	short rv;
	int err;

	if (nat->nat_aps == NULL)
		nat->nat_aps = appr_new_session(nat->nat_ptr->in_apr, ip,
						fin, nat);
	aps = nat->nat_aps;
	if ((aps != NULL) && (aps->aps_p == ip->ip_p)) {
		if (ip->ip_p == IPPROTO_TCP) {
			tcp = (tcphdr_t *)fin->fin_dp;
			/*
			 * verify that the checksum is correct.  If not, then
			 * don't do anything with this packet.
			 */
#if SOLARIS && defined(_KERNEL)
			sum = fr_tcpsum(fin->fin_qfm, ip, tcp);
#else
			sum = fr_tcpsum(*(mb_t **)fin->fin_mp, ip, tcp);
#endif
			if (sum != tcp->th_sum) {
				frstats[fin->fin_out].fr_tcpbad++;
				return -1;
			}
		}

		apr = aps->aps_apr;
		err = 0;
		if (fin->fin_out != 0) {
			if (apr->apr_outpkt != NULL)
				err = (*apr->apr_outpkt)(fin, ip, aps, nat);
		} else {
			if (apr->apr_inpkt != NULL)
				err = (*apr->apr_inpkt)(fin, ip, aps, nat);
		}

		rv = APR_EXIT(err);
		if (rv == -1)
			return rv;

		if (tcp != NULL) {
			err = appr_fixseqack(fin, ip, aps, APR_INC(err));
#if SOLARIS && defined(_KERNEL)
			tcp->th_sum = fr_tcpsum(fin->fin_qfm, ip, tcp);
#else
			tcp->th_sum = fr_tcpsum(*(mb_t **)fin->fin_mp, ip, tcp);
#endif
		}
		aps->aps_bytes += ip->ip_len;
		aps->aps_pkts++;
		return 1;
	}
	return 0;
}


aproxy_t *appr_match(pr, name)
u_int pr;
char *name;
{
	aproxy_t *ap;

	for (ap = ap_proxies; ap->apr_p; ap++)
		if ((ap->apr_p == pr) &&
		    !strncmp(name, ap->apr_label, sizeof(ap->apr_label))) {
			ap->apr_ref++;
			return ap;
		}

	for (ap = ap_proxylist; ap; ap = ap->apr_next)
		if ((ap->apr_p == pr) &&
		    !strncmp(name, ap->apr_label, sizeof(ap->apr_label))) {
			ap->apr_ref++;
			return ap;
		}
	return NULL;
}


void appr_free(ap)
aproxy_t *ap;
{
	ap->apr_ref--;
}


void aps_free(aps)
ap_session_t *aps;
{
	ap_session_t *a, **ap;

	if (!aps)
		return;

	for (ap = &ap_sess_list; (a = *ap); ap = &a->aps_next)
		if (a == aps) {
			*ap = a->aps_next;
			break;
		}

	if ((aps->aps_data != NULL) && (aps->aps_psiz != 0))
		KFREES(aps->aps_data, aps->aps_psiz);
	KFREE(aps);
}


static int appr_fixseqack(fin, ip, aps, inc)
fr_info_t *fin;
ip_t *ip;
ap_session_t *aps;
int inc;
{
	int sel, ch = 0, out, nlen;
	u_32_t seq1, seq2;
	tcphdr_t *tcp;

	tcp = (tcphdr_t *)fin->fin_dp;
	out = fin->fin_out;
	nlen = ip->ip_len;
	nlen -= (ip->ip_hl << 2) + (tcp->th_off << 2);

	if (out != 0) {
		seq1 = (u_32_t)ntohl(tcp->th_seq);
		sel = aps->aps_sel[out];

		/* switch to other set ? */
		if ((aps->aps_seqmin[!sel] > aps->aps_seqmin[sel]) &&
		    (seq1 > aps->aps_seqmin[!sel]))
			sel = aps->aps_sel[out] = !sel;

		if (aps->aps_seqoff[sel]) {
			seq2 = aps->aps_seqmin[sel] - aps->aps_seqoff[sel];
			if (seq1 > seq2) {
				seq2 = aps->aps_seqoff[sel];
				seq1 += seq2;
				tcp->th_seq = htonl(seq1);
				ch = 1;
			}
		}

		if (inc && (seq1 > aps->aps_seqmin[!sel])) {
			aps->aps_seqmin[!sel] = seq1 + nlen - 1;
			aps->aps_seqoff[!sel] = aps->aps_seqoff[sel] + inc;
		}

		/***/

		seq1 = ntohl(tcp->th_ack);
		sel = aps->aps_sel[1 - out];

		/* switch to other set ? */
		if ((aps->aps_ackmin[!sel] > aps->aps_ackmin[sel]) &&
		    (seq1 > aps->aps_ackmin[!sel]))
			sel = aps->aps_sel[1 - out] = !sel;

		if (aps->aps_ackoff[sel] && (seq1 > aps->aps_ackmin[sel])) {
			seq2 = aps->aps_ackoff[sel];
			tcp->th_ack = htonl(seq1 - seq2);
			ch = 1;
		}
	} else {
		seq1 = ntohl(tcp->th_seq);
		sel = aps->aps_sel[out];

		/* switch to other set ? */
		if ((aps->aps_ackmin[!sel] > aps->aps_ackmin[sel]) &&
		    (seq1 > aps->aps_ackmin[!sel]))
			sel = aps->aps_sel[out] = !sel;

		if (aps->aps_ackoff[sel]) {
			seq2 = aps->aps_ackmin[sel] -
			       aps->aps_ackoff[sel];
			if (seq1 > seq2) {
				seq2 = aps->aps_ackoff[sel];
				seq1 += seq2;
				tcp->th_seq = htonl(seq1);
				ch = 1;
			}
		}

		if (inc && (seq1 > aps->aps_ackmin[!sel])) {
			aps->aps_ackmin[!sel] = seq1 + nlen - 1;
			aps->aps_ackoff[!sel] = aps->aps_ackoff[sel] + inc;
		}

		/***/

		seq1 = ntohl(tcp->th_ack);
		sel = aps->aps_sel[1 - out];

		/* switch to other set ? */
		if ((aps->aps_seqmin[!sel] > aps->aps_seqmin[sel]) &&
		    (seq1 > aps->aps_seqmin[!sel]))
			sel = aps->aps_sel[1 - out] = !sel;

		if (aps->aps_seqoff[sel] && (seq1 > aps->aps_seqmin[sel])) {
			seq2 = aps->aps_seqoff[sel];
			tcp->th_ack = htonl(seq1 - seq2);
			ch = 1;
		}
	}
	return ch ? 2 : 0;
}


int appr_init()
{
	aproxy_t *ap;
	int err = 0;

	for (ap = ap_proxies; ap->apr_p; ap++) {
		err = (*ap->apr_init)();
		if (err != 0)
			break;
	}
	return err;
}


void appr_unload()
{
	aproxy_t *ap;

	for (ap = ap_proxies; ap->apr_p; ap++)
		if (ap->apr_fini)
			(*ap->apr_fini)();
	for (ap = ap_proxylist; ap; ap = ap->apr_next)
		if (ap->apr_fini)
			(*ap->apr_fini)();
}
@


1.13
log
@re-add local ipf changes that were whacked in the 3.4.16 merge. userland to follow
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_proxy.c,v 1.12 2001/01/17 04:47:15 fgsch Exp $	*/
@


1.12
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 1
a73 1
#include "netinet/ip_compat.h"
d75 4
a78 4
#include "netinet/ip_fil.h"
#include "netinet/ip_proxy.h"
#include "netinet/ip_nat.h"
#include "netinet/ip_state.h"
d96 3
a98 3
#include "netinet/ip_ftp_pxy.c"
#include "netinet/ip_rcmd_pxy.c"
#include "netinet/ip_raudio_pxy.c"
@


1.11
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_proxy.c,v 1.10 2000/06/16 21:47:16 provos Exp $	*/
d4 1
a4 1
 * Copyright (C) 1997-1998 by Darren Reed.
d11 1
a11 1
static const char rcsid[] = "@@(#)$IPFilter: ip_proxy.c,v 2.2.2.4 2000/03/15 13:57:53 darrenr Exp $";
d73 1
a73 1
#include <netinet/ip_fil_compat.h>
d75 4
a78 4
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_state.h>
d96 3
a98 3
#include <netinet/ip_ftp_pxy.c>
#include <netinet/ip_rcmd_pxy.c>
#include <netinet/ip_raudio_pxy.c>
d103 1
d106 1
a106 1
	{ "ftp", (char)IPPROTO_TCP, 0, 0, ippr_ftp_init, NULL,
d110 1
a110 1
	{ "rcmd", (char)IPPROTO_TCP, 0, 0, ippr_rcmd_init, NULL,
d114 1
a114 1
	{ "raudio", (char)IPPROTO_TCP, 0, 0, ippr_raudio_init, NULL,
d117 1
a117 1
	{ "", '\0', 0, 0, NULL, NULL }
d121 38
d225 1
d260 4
d265 1
a265 1
			err = appr_fixseqack(fin, ip, aps, err);
d274 1
a274 1
		return 2;
d276 1
a276 1
	return -1;
d292 7
d324 3
a326 5
	if (a) {
		if ((aps->aps_data != NULL) && (aps->aps_psiz != 0))
			KFREES(aps->aps_data, aps->aps_psiz);
		KFREE(aps);
	}
d448 3
@


1.10
log
@take MIN/MAX from param.h, okay theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_proxy.c,v 1.9 2000/04/05 05:35:27 kjell Exp $	*/
d81 5
@


1.9
log
@Update to ipf 3.3.12. Most fixes relate to hardening of
in-kernel ftp proxy. See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_proxy.c,v 1.8 2000/03/13 23:40:18 kjell Exp $	*/
a80 5
#endif


#ifndef MIN
#define MIN(a,b)        (((a)<(b))?(a):(b))
@


1.8
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d11 1
a11 1
static const char rcsid[] = "@@(#)$IPFilter: ip_proxy.c,v 2.2.2.3 2000/02/29 22:47:17 darrenr Exp $";
d105 2
a106 2
	{ "ftp", (char)IPPROTO_TCP, 0, 0, ippr_ftp_init, NULL, NULL,
	  ippr_ftp_in, ippr_ftp_out },
a156 1
	aps->aps_next = ap_sess_list;
d161 7
a168 4
	aps->aps_nat = nat;
	nat->nat_aps = aps;
	if (apr->apr_new != NULL)
		(void) (*apr->apr_new)(fin, ip, aps, nat);
@


1.7
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@d11 1
a11 1
static const char rcsid[] = "@@(#)$IPFilter: ip_proxy.c,v 2.2.2.1 1999/09/19 12:18:19 darrenr Exp $";
d105 1
a105 1
	{ "ftp", (char)IPPROTO_TCP, 0, 0, ippr_ftp_init, NULL,
d109 2
a110 2
	{ "rcmd", (char)IPPROTO_TCP, 0, 0, ippr_rcmd_init, ippr_rcmd_new,
	  NULL, ippr_rcmd_out },
d113 1
a113 1
	{ "raudio", (char)IPPROTO_TCP, 0, 0, ippr_raudio_init,
d389 10
@


1.6
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.6.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_proxy.c,v 1.7 2000/02/16 22:34:19 kjell Exp $	*/
@


1.6.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d11 1
a11 1
static const char rcsid[] = "@@(#)$IPFilter: ip_proxy.c,v 2.2.2.3 2000/02/29 22:47:17 darrenr Exp $";
d105 1
a105 1
	{ "ftp", (char)IPPROTO_TCP, 0, 0, ippr_ftp_init, NULL, NULL,
d109 2
a110 2
	{ "rcmd", (char)IPPROTO_TCP, 0, 0, ippr_rcmd_init, NULL,
	  ippr_rcmd_new, NULL, ippr_rcmd_out },
d113 1
a113 1
	{ "raudio", (char)IPPROTO_TCP, 0, 0, ippr_raudio_init, NULL,
a388 10
}


void appr_unload()
{
	aproxy_t *ap;

	for (ap = ap_proxies; ap->apr_p; ap++)
		if (ap->apr_fini)
			(*ap->apr_fini)();
@


1.6.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_proxy.c,v 1.13 2001/01/30 04:23:56 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1997-2000 by Darren Reed.
d11 1
a11 1
static const char rcsid[] = "@@(#)$IPFilter: ip_proxy.c,v 2.9.2.1 2000/05/06 12:30:50 darrenr Exp $";
a102 1
aproxy_t	*ap_proxylist = NULL;
d105 2
a106 2
	{ NULL, "ftp", (char)IPPROTO_TCP, 0, 0, ippr_ftp_init, NULL,
	  ippr_ftp_new, ippr_ftp_in, ippr_ftp_out },
d109 1
a109 1
	{ NULL, "rcmd", (char)IPPROTO_TCP, 0, 0, ippr_rcmd_init, NULL,
d113 1
a113 1
	{ NULL, "raudio", (char)IPPROTO_TCP, 0, 0, ippr_raudio_init, NULL,
d116 1
a116 1
	{ NULL, "", '\0', 0, 0, NULL, NULL }
a119 38
int appr_add(ap)
aproxy_t *ap;
{
	aproxy_t *a;

	for (a = ap_proxies; a->apr_p; a++)
		if ((a->apr_p == ap->apr_p) &&
		    !strncmp(a->apr_label, ap->apr_label,
			     sizeof(ap->apr_label)))
			return -1;

	for (a = ap_proxylist; a->apr_p; a = a->apr_next)
		if ((a->apr_p == ap->apr_p) &&
		    !strncmp(a->apr_label, ap->apr_label,
			     sizeof(ap->apr_label)))
			return -1;
	ap->apr_next = ap_proxylist;
	ap_proxylist = ap;
	return (*ap->apr_init)();
}


int appr_del(ap)
aproxy_t *ap;
{
	aproxy_t *a, **app;

	for (app = &ap_proxylist; (a = *app); app = &a->apr_next)
		if (a == ap) {
			if (ap->apr_ref != 0)
				return 1;
			*app = a->apr_next;
			return 0;
		}
	return -1;
}


d157 1
d162 3
d166 1
a166 7
		if ((*apr->apr_new)(fin, ip, aps, nat) == -1) {
			KFREE(aps);
			return NULL;
		}
	aps->aps_nat = nat;
	aps->aps_next = ap_sess_list;
	ap_sess_list = aps;
a183 1
	short rv;
a217 4
		rv = APR_EXIT(err);
		if (rv == -1)
			return rv;

d219 1
a219 1
			err = appr_fixseqack(fin, ip, aps, APR_INC(err));
d228 1
a228 1
		return 1;
d230 1
a230 1
	return 0;
a245 7

	for (ap = ap_proxylist; ap; ap = ap->apr_next)
		if ((ap->apr_p == pr) &&
		    !strncmp(name, ap->apr_label, sizeof(ap->apr_label))) {
			ap->apr_ref++;
			return ap;
		}
d271 5
a275 3
	if ((aps->aps_data != NULL) && (aps->aps_psiz != 0))
		KFREES(aps->aps_data, aps->aps_psiz);
	KFREE(aps);
a396 3
		if (ap->apr_fini)
			(*ap->apr_fini)();
	for (ap = ap_proxylist; ap; ap = ap->apr_next)
@


1.6.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_proxy.c,v 1.6.2.3 2001/05/14 22:40:13 niklas Exp $	*/
@


1.5
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ip_proxy.c,v 2.2.2.1 1999/09/19 12:18:19 darrenr Exp $";
@


1.4
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_proxy.c,v 1.3 1998/09/15 09:51:18 pattonme Exp $       */
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id: ip_proxy.c,v 1.3 1998/09/15 09:51:18 pattonme Exp $";
d22 3
a24 1
#include <sys/ioctl.h>
d49 3
a51 1
# include <sys/dditypes.h>
d72 1
a72 5
#if defined(__OpenBSD__)
# include <netinet/ip_fil_compat.h>
#else
# include <netinet/ip_compat.h>
#endif
d78 4
d87 3
a89 2
static ap_session_t *ap_new_session __P((aproxy_t *, ip_t *,
					 fr_info_t *, nat_t *));
d96 2
d104 10
a113 1
	{ "ftp", (char)IPPROTO_TCP, 0, 0, ippr_ftp_init, ippr_ftp_in, ippr_ftp_out },
d119 1
a119 1
int ap_ok(ip, tcp, nat)
d127 1
a127 1
	if (!apr || (apr && (apr->apr_flags & APR_DELETE)) ||
d141 1
a141 1
static ap_session_t *ap_new_session(apr, ip, fin, nat)
a147 3
	tcphdr_t *tcp;
	u_short dport;
	u_int hv;
d149 1
a149 2
	if (!apr || (apr && (apr->apr_flags & APR_DELETE)) ||
	    (ip->ip_p != apr->apr_p))
d152 1
a152 18
	if (!(fin->fin_fi.fi_fl & FI_TCPUDP))
		tcp = NULL;
	else
		tcp = (tcphdr_t *)fin->fin_dp;
	dport = nat->nat_ptr->in_dport;

	if ((tcp && (tcp->th_dport != dport)) || (!tcp && dport))
		return NULL;

	hv = ip->ip_src.s_addr ^ ip->ip_dst.s_addr;
	hv *= 651733;
	if (tcp) {
		hv ^= (tcp->th_sport + tcp->th_dport);
		hv *= 5;
	}
	hv %= AP_SESS_SIZE;

	KMALLOC(aps, ap_session_t *, sizeof(*aps));
d156 1
a156 3
	aps->aps_apr = apr;
	aps->aps_src = ip->ip_src;
	aps->aps_dst = ip->ip_dst;
a157 4
	if (tcp) {
		aps->aps_sport = tcp->th_sport;
		aps->aps_dport = tcp->th_dport;
	}
d159 1
a160 2
	aps->aps_hnext = ap_sess_tab[hv];
	aps->aps_next = ap_sess_list;
a162 1
	aps->aps_hv = hv;
d164 2
a165 2
	ap_sess_tab[hv] = aps;
	(void) (*apr->apr_init)(fin, ip, aps, nat);
d174 1
a174 1
int ap_check(ip, fin, nat)
d185 5
a189 2
	if ((aps = nat->nat_aps) ||
	    (aps = ap_new_session(nat->nat_ptr->in_apr, ip, fin, nat))) {
d197 1
a197 1
			sum = fr_tcpsum(fin->fin_qfm, ip, tcp, ip->ip_len);
d199 1
a199 2
			sum = fr_tcpsum(*(mb_t **)fin->fin_mp,
					ip, tcp, ip->ip_len);
d201 1
a201 1
			if (tcp->th_sum != sum) {
d209 2
a210 2
		if (fin->fin_out) {
			if (apr->apr_outpkt)
d213 1
a213 1
			if (apr->apr_inpkt)
d218 1
a218 1
			err = ap_fixseqack(fin, ip, aps, err);
d220 1
a220 2
			tcp->th_sum = fr_tcpsum(fin->fin_qfm, ip, tcp,
					        ip->ip_len);
d222 1
a222 2
			tcp->th_sum = fr_tcpsum(*(mb_t **)fin->fin_mp, ip,
						tcp, ip->ip_len);
d233 2
a234 2
aproxy_t *ap_match(pr, name)
u_char pr;
d249 1
a249 1
void ap_free(ap)
a259 1
	u_int hv;
a263 8
	hv = aps->aps_hv;

	for (ap = ap_sess_tab + hv; (a = *ap); ap = &a->aps_hnext)
		if (a == aps) {
			*ap = a->aps_hnext;
			break;
		}

d271 1
a271 1
		if (aps->aps_data && aps->aps_psiz)
d278 1
a278 1
int ap_fixseqack(fin, ip, aps, inc)
d374 14
@


1.3
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_proxy.c,v 1.2 1998/02/17 01:39:06 dgregor Exp $       */
d3 1
a3 1
 * Copyright (C) 1997 by Darren Reed.
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id$";
a16 5
#if !defined(_KERNEL) && !defined(KERNEL)
# include <stdio.h>
# include <string.h>
# include <stdlib.h>
#endif
d25 5
d83 1
a83 2
static ap_session_t *ap_find __P((ip_t *, tcphdr_t *));
static ap_session_t *ap_new_session __P((aproxy_t *, ip_t *, tcphdr_t *,
a84 2
static int ap_matchsrcdst __P((ap_session_t *, struct in_addr,
			       struct in_addr, void *, u_short, u_short));
d94 1
a119 53
static int
ap_matchsrcdst(aps, src, dst, tcp, sport, dport)
ap_session_t *aps;
struct in_addr src, dst;
void *tcp;
u_short sport, dport;
{
	if (aps->aps_dst.s_addr == dst.s_addr) {
		if ((aps->aps_src.s_addr == src.s_addr) &&
		    (!tcp || ((sport == aps->aps_sport) &&
		     (dport == aps->aps_dport))))
			return 1;
	} else if (aps->aps_dst.s_addr == src.s_addr) {
		if ((aps->aps_src.s_addr == dst.s_addr) &&
		    (!tcp || ((sport == aps->aps_dport) &&
		     (dport == aps->aps_sport))))
			return 1;
	}
	return 0;
}


static ap_session_t *ap_find(ip, tcp)
ip_t *ip;
tcphdr_t *tcp;
{
	register u_char p = ip->ip_p;
	register ap_session_t *aps;
	register u_short sp, dp;
	register u_long hv;
	struct in_addr src, dst;

	src = ip->ip_src, dst = ip->ip_dst;
	sp = dp = 0;			/* XXX gcc -Wunitialized */

	hv = ip->ip_src.s_addr ^ ip->ip_dst.s_addr;
	hv *= 651733;
	if (tcp) {
		sp = tcp->th_sport;
		dp = tcp->th_dport;
		hv ^= (sp + dp);
		hv *= 5;
	}
	hv %= AP_SESS_SIZE;

	for (aps = ap_sess_tab[hv]; aps; aps = aps->aps_next)
		if ((aps->aps_p == p) &&
		    ap_matchsrcdst(aps, src, dst, tcp, sp, dp))
			break;
	return aps;
}


d125 1
a125 1
static ap_session_t *ap_new_session(apr, ip, tcp, fin, nat)
a127 1
tcphdr_t *tcp;
d132 1
d134 1
a134 1
	u_long hv;
d139 5
d145 1
a164 1
	aps->aps_tout = 1200;	/* XXX */
d171 6
a176 1
	aps->aps_next = ap_sess_tab[hv];
d178 1
a178 1
	(void) (*apr->apr_init)(fin, ip, tcp, aps, nat);
d187 1
a187 1
int ap_check(ip, tcp, fin, nat)
a188 1
tcphdr_t *tcp;
d194 1
d198 2
a199 5
	if (!(fin->fin_fi.fi_fl & FI_TCPUDP))
		tcp = NULL;

	if ((aps = ap_find(ip, tcp)) ||
	    (aps = ap_new_session(nat->nat_ptr->in_apr, ip, tcp, fin, nat))) {
d201 1
a215 2
			fr_tcp_age(&aps->aps_tout, aps->aps_state, ip, fin,
				   tcp->th_sport == aps->aps_sport);
d222 1
a222 2
				err = (*apr->apr_outpkt)(fin, ip, tcp,
							 aps, nat);
d225 1
a225 2
				err = (*apr->apr_inpkt)(fin, ip, tcp,
							aps, nat);
d227 3
a229 1
		if (err == 2) {
d231 2
a232 2
			tcp->th_sum = fr_tcpsum(fin->fin_qfm, ip,
						tcp, ip->ip_len);
a236 1
			err = 0;
d238 3
a240 1
		return err;
d272 25
a296 3
	if (aps->aps_data && aps->aps_psiz)
		KFREES(aps->aps_data, aps->aps_psiz);
	KFREE(aps);
d300 5
a304 1
void ap_unload()
d306 67
a372 2
	ap_session_t *aps;
	int i;
d374 3
a376 4
	for (i = 0; i < AP_SESS_SIZE; i++)
		while ((aps = ap_sess_tab[i])) {
			ap_sess_tab[i] = aps->aps_next;
			aps_free(aps);
a377 1
}
d379 1
d381 2
a382 4
void ap_expire()
{
	ap_session_t *aps, **apsp;
	int i;
d384 9
a392 9
	for (i = 0; i < AP_SESS_SIZE; i++)
		for (apsp = &ap_sess_tab[i]; (aps = *apsp); ) {
			aps->aps_tout--;
			if (!aps->aps_tout) {
				ap_sess_tab[i] = aps->aps_next;
				aps_free(aps);
				*apsp = aps->aps_next;
			} else
				apsp = &aps->aps_next;
d394 2
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*       $OpenBSD$       */
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id: ip_proxy.c,v 1.1 1998/01/26 04:10:45 dgregor Exp $";
d68 5
a72 1
#include "ip_fil_compat.h"
d74 4
a77 4
#include "ip_fil.h"
#include "ip_proxy.h"
#include "ip_nat.h"
#include "ip_state.h"
d86 3
d93 1
a93 1
#include "netinet/ip_ftp_pxy.c"
d122 22
d148 4
a152 4
	register u_long hv;
	register u_short sp, dp;
	register ap_session_t *aps;
	register u_char p = ip->ip_p;
d169 2
a170 8
		    IPPAIR(aps->aps_src, aps->aps_dst, src, dst)) {
			if (tcp) {
				if (PAIRS(aps->aps_sport, aps->aps_dport,
					  sp, dp))
					break;
			} else
				break;
		}
d240 1
d253 7
a259 2
			if (tcp->th_sum != fr_tcpsum(*(mb_t **)fin->fin_mp,
						     ip, tcp, ip->ip_len)) {
d279 4
d285 1
@


1.1
log
@IPF 3.2.3
@
text
@d1 1
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id: ip_proxy.c,v 2.0.2.11.2.6 1997/11/28 00:41:25 darrenr Exp $";
@
