head	1.13;
access;
symbols
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	UBC_SYNC_A:1.13
	UBC_SYNC_B:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2001.05.30.02.12.32;	author deraadt;	state dead;
branches;
next	1.12;

1.12
date	2001.05.08.19.58.01;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.25.12.03.11;	author gluk;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.30.04.23.56;	author kjell;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.17.04.47.14;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.13.23.40.18;	author kjell;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.16.22.34.19;	author kjell;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.01.19.29.58;	author kjell;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.12.15.05.20.22;	author kjell;	state Exp;
branches;
next	1.4;

1.4
date	99.02.05.05.58.52;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.09.15.09.51.18;	author pattonme;	state Exp;
branches;
next	1.2;

1.2
date	98.02.17.01.39.04;	author dgregor;	state Exp;
branches;
next	1.1;

1.1
date	98.01.26.04.10.43;	author dgregor;	state Exp;
branches;
next	;

1.6.2.1
date	2000.02.20.11.57.26;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.05.14.22.40.12;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.07.04.10.54.53;	author niklas;	state dead;
branches;
next	;


desc
@@


1.13
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ip_log.c,v 1.12 2001/05/08 19:58:01 fgsch Exp $	*/

/*
 * Copyright (C) 1997-2001 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 *
 * $IPFilter: ip_log.c,v 2.5.2.3 2001/04/03 15:45:49 darrenr Exp $
 */
#include <sys/param.h>
#if defined(KERNEL) && !defined(_KERNEL)
# define       _KERNEL
#endif
#if defined(__NetBSD__) && (NetBSD >= 199905) && !defined(IPFILTER_LKM)
# include "opt_ipfilter_log.h"
#endif
#ifdef  __FreeBSD__
# if defined(_KERNEL) && !defined(IPFILTER_LKM)
#  if defined(__FreeBSD_version) && (__FreeBSD_version >= 300000)
#   include "opt_ipfilter.h"
#  endif
# else
#  ifdef KLD_MODULE
#   include <osreldate.h>
#  endif
# endif
#endif
#ifdef	IPFILTER_LOG
# ifndef SOLARIS
#  define SOLARIS (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
# endif
# ifndef _KERNEL
#  include <stdio.h>
#  include <string.h>
#  include <stdlib.h>
#  include <ctype.h>
# endif
# include <sys/errno.h>
# include <sys/types.h>
# include <sys/file.h>
# if __FreeBSD_version >= 220000 && defined(_KERNEL)
#  include <sys/fcntl.h>
#  include <sys/filio.h>
# else
#  include <sys/ioctl.h>
# endif
# include <sys/time.h>
# if defined(_KERNEL)
#  include <sys/systm.h>
# endif
# include <sys/uio.h>
# if !SOLARIS
#  if (NetBSD > 199609) || (OpenBSD > 199603) || (__FreeBSD_version >= 300000)
#   include <sys/dirent.h>
#  else
#   include <sys/dir.h>
#  endif
#  include <sys/mbuf.h>
# else
#  include <sys/filio.h>
#  include <sys/cred.h>
#  include <sys/ddi.h>
#  include <sys/sunddi.h>
#  include <sys/ksynch.h>
#  include <sys/kmem.h>
#  include <sys/mkdev.h>
#  include <sys/dditypes.h>
#  include <sys/cmn_err.h>
# endif
# include <sys/protosw.h>
# include <sys/socket.h>

# include <net/if.h>
# ifdef sun
#  include <net/af.h>
# endif
# if __FreeBSD_version >= 300000
#  include <net/if_var.h>
# endif
# include <net/route.h>
# include <netinet/in.h>
# ifdef __sgi
#  include <sys/ddi.h>
#  ifdef IFF_DRVRLOCK /* IRIX6 */
#   include <sys/hashing.h>
#  endif
# endif
# if !(defined(__sgi) && !defined(IFF_DRVRLOCK)) /*IRIX<6*/
#  include <netinet/in_var.h>
# endif
# include <netinet/in_systm.h>
# include <netinet/ip.h>
# include <netinet/tcp.h>
# include <netinet/udp.h>
# include <netinet/ip_icmp.h>
# include <netinet/ip_var.h>
# ifndef _KERNEL
#  include <syslog.h>
# endif
# include <netinet/ip_fil_compat.h>
# include <netinet/tcpip.h>
# include <netinet/ip_fil.h>
# include <netinet/ip_proxy.h>
# include <netinet/ip_nat.h>
# include <netinet/ip_frag.h>
# include <netinet/ip_state.h>
# include <netinet/ip_auth.h>
# if (__FreeBSD_version >= 300000)
#  include <sys/malloc.h>
# endif

# ifndef MIN
#  define	MIN(a,b)	(((a)<(b))?(a):(b))
# endif


# if SOLARIS || defined(__sgi)
extern	kmutex_t	ipl_mutex;
#  if SOLARIS
extern	kcondvar_t	iplwait;
#  endif
# endif

iplog_t	**iplh[IPL_LOGMAX+1], *iplt[IPL_LOGMAX+1], *ipll[IPL_LOGMAX+1];
size_t	iplused[IPL_LOGMAX+1];
static fr_info_t	iplcrc[IPL_LOGMAX+1];


/*
 * Initialise log buffers & pointers.  Also iniialised the CRC to a local
 * secret for use in calculating the "last log checksum".
 */
void ipflog_init()
{
	int	i;

	for (i = IPL_LOGMAX; i >= 0; i--) {
		iplt[i] = NULL;
		ipll[i] = NULL;
		iplh[i] = &iplt[i];
		iplused[i] = 0;
		bzero((char *)&iplcrc[i], sizeof(iplcrc[i]));
	}
}


/*
 * ipflog
 * Create a log record for a packet given that it has been triggered by a
 * rule (or the default setting).  Calculate the transport protocol header
 * size using predetermined size of a couple of popular protocols and thus
 * how much data to copy into the log, including part of the data body if
 * requested.
 */
int ipflog(flags, ip, fin, m)
u_int flags;
ip_t *ip;
fr_info_t *fin;
mb_t *m;
{
	ipflog_t ipfl;
	register size_t mlen, hlen;
	size_t sizes[2];
	void *ptrs[2];
	int types[2];
	u_char p;
# if SOLARIS
	ill_t *ifp = fin->fin_ifp;
# else
	struct ifnet *ifp = fin->fin_ifp;
# endif

	/*
	 * calculate header size.
	 */
	hlen = fin->fin_hlen;
	if (fin->fin_off == 0) {
		p = fin->fin_fi.fi_p;
		if (p == IPPROTO_TCP)
			hlen += MIN(sizeof(tcphdr_t), fin->fin_dlen);
		else if (p == IPPROTO_UDP)
			hlen += MIN(sizeof(udphdr_t), fin->fin_dlen);
		else if (p == IPPROTO_ICMP) {
			struct icmp *icmp;

			icmp = (struct icmp *)fin->fin_dp;
	 
			/*
			 * For ICMP, if the packet is an error packet, also
			 * include the information about the packet which
			 * caused the error.
			 */
			switch (icmp->icmp_type)
			{
			case ICMP_UNREACH :
			case ICMP_SOURCEQUENCH :
			case ICMP_REDIRECT :
			case ICMP_TIMXCEED :
			case ICMP_PARAMPROB :
				hlen += MIN(sizeof(struct icmp) + 8,
					    fin->fin_dlen);
				break;
			default :
				hlen += MIN(sizeof(struct icmp),
					    fin->fin_dlen);
				break;
			}
		}
	}
	/*
	 * Get the interface number and name to which this packet is
	 * currently associated.
	 */
# if SOLARIS
	ipfl.fl_unit = (u_char)ifp->ill_ppa;
	bcopy(ifp->ill_name, ipfl.fl_ifname, MIN(ifp->ill_name_length, 4));
	mlen = (flags & FR_LOGBODY) ? MIN(msgdsize(m) - hlen, 128) : 0;
# else
#  if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199603)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
	strncpy(ipfl.fl_ifname, ifp->if_xname, IFNAMSIZ);
#  else
	ipfl.fl_unit = (u_char)ifp->if_unit;
	if ((ipfl.fl_ifname[0] = ifp->if_name[0]))
		if ((ipfl.fl_ifname[1] = ifp->if_name[1]))
			if ((ipfl.fl_ifname[2] = ifp->if_name[2]))
				ipfl.fl_ifname[3] = ifp->if_name[3];
#  endif
	mlen = (flags & FR_LOGBODY) ? MIN(fin->fin_plen - hlen, 128) : 0;
# endif
	ipfl.fl_plen = (u_char)mlen;
	ipfl.fl_hlen = (u_char)hlen;
	ipfl.fl_rule = fin->fin_rule;
	ipfl.fl_group = fin->fin_group;
	if (fin->fin_fr != NULL)
		ipfl.fl_loglevel = fin->fin_fr->fr_loglevel;
	else
		ipfl.fl_loglevel = 0xffff;
	ipfl.fl_flags = flags;
	ptrs[0] = (void *)&ipfl;
	sizes[0] = sizeof(ipfl);
	types[0] = 0;
# if SOLARIS
	/*
	 * Are we copied from the mblk or an aligned array ?
	 */
	if (ip == (ip_t *)m->b_rptr) {
		ptrs[1] = m;
		sizes[1] = hlen + mlen;
		types[1] = 1;
	} else {
		ptrs[1] = ip;
		sizes[1] = hlen + mlen;
		types[1] = 0;
	}
# else
	ptrs[1] = m;
	sizes[1] = hlen + mlen;
	types[1] = 1;
# endif
	return ipllog(IPL_LOGIPF, fin, ptrs, sizes, types, 2);
}


/*
 * ipllog
 */
int ipllog(dev, fin, items, itemsz, types, cnt)
int dev;
fr_info_t *fin;
void **items;
size_t *itemsz;
int *types, cnt;
{
	caddr_t buf, s;
	iplog_t *ipl;
	size_t len;
	int i;
 
	/*
	 * Check to see if this log record has a CRC which matches the last
	 * record logged.  If it does, just up the count on the previous one
	 * rather than create a new one.
	 */
	MUTEX_ENTER(&ipl_mutex);
	if (fin != NULL) {
		if ((ipll[dev] != NULL) &&
		    bcmp((char *)fin, (char *)&iplcrc[dev], FI_CSIZE) == 0) {
			ipll[dev]->ipl_count++;
			MUTEX_EXIT(&ipl_mutex);
			return 1;
		}
		bcopy((char *)fin, (char *)&iplcrc[dev], FI_CSIZE);
	} else
		bzero((char *)&iplcrc[dev], FI_CSIZE);
	MUTEX_EXIT(&ipl_mutex);

	/*
	 * Get the total amount of data to be logged.
	 */
	for (i = 0, len = sizeof(iplog_t); i < cnt; i++)
		len += itemsz[i];

	/*
	 * check that we have space to record this information and can
	 * allocate that much.
	 */
	KMALLOCS(buf, caddr_t, len);
	if (!buf)
		return 0;
	MUTEX_ENTER(&ipl_mutex);
	if ((iplused[dev] + len) > IPLLOGSIZE) {
		MUTEX_EXIT(&ipl_mutex);
		KFREES(buf, len);
		return 0;
	}
	iplused[dev] += len;
	MUTEX_EXIT(&ipl_mutex);

	/*
	 * advance the log pointer to the next empty record and deduct the
	 * amount of space we're going to use.
	 */
	ipl = (iplog_t *)buf;
	ipl->ipl_magic = IPL_MAGIC;
	ipl->ipl_count = 1;
	ipl->ipl_next = NULL;
	ipl->ipl_dsize = len;
# if SOLARIS || defined(sun)
	uniqtime((struct timeval *)&ipl->ipl_sec);
# else
#  if BSD >= 199306 || defined(__FreeBSD__) || defined(__sgi)
	microtime((struct timeval *)&ipl->ipl_sec);
#  endif
# endif

	/*
	 * Loop through all the items to be logged, copying each one to the
	 * buffer.  Use bcopy for normal data or the mb_t copyout routine.
	 */
	for (i = 0, s = buf + sizeof(*ipl); i < cnt; i++) {
		if (types[i] == 0)
			bcopy(items[i], s, itemsz[i]);
		else if (types[i] == 1) {
# if SOLARIS
			copyout_mblk(items[i], 0, itemsz[i], s);
# else
			m_copydata(items[i], 0, itemsz[i], s);
# endif
		}
		s += itemsz[i];
	}
	MUTEX_ENTER(&ipl_mutex);
	ipll[dev] = ipl;
	*iplh[dev] = ipl;
	iplh[dev] = &ipl->ipl_next;
# if SOLARIS
	cv_signal(&iplwait);
	mutex_exit(&ipl_mutex);
# else
	MUTEX_EXIT(&ipl_mutex);
	wakeup(&iplh[dev]);
# endif
	return 1;
}


int ipflog_read(unit, uio)
minor_t unit;
struct uio *uio;
{
	size_t dlen, copied;
	int error = 0;
	iplog_t *ipl;
# if defined(_KERNEL) && !SOLARIS
	int s;
# endif

	/*
	 * Sanity checks.  Make sure the minor # is valid and we're copying
	 * a valid chunk of data.
	 */
	if (IPL_LOGMAX < unit)
		return ENXIO;
	if (!uio->uio_resid)
		return 0;
	if (uio->uio_resid < sizeof(iplog_t))
		return EINVAL;
 
	/*
	 * Lock the log so we can snapshot the variables.  Wait for a signal
	 * if the log is empty.
	 */
	SPL_NET(s);
	MUTEX_ENTER(&ipl_mutex);

	while (!iplused[unit] || !iplt[unit]) {
# if SOLARIS && defined(_KERNEL)
		if (!cv_wait_sig(&iplwait, &ipl_mutex)) {
			MUTEX_EXIT(&ipl_mutex);
			return EINTR;
		}
# else
		MUTEX_EXIT(&ipl_mutex);
		error = SLEEP(&iplh[unit], "ipl sleep");
		if (error) {
			SPL_X(s);
			return error;
		}
		MUTEX_ENTER(&ipl_mutex);
# endif /* SOLARIS */
	}

# if BSD >= 199306 || defined(__FreeBSD__)
	uio->uio_rw = UIO_READ;
# endif

	for (copied = 0; (ipl = iplt[unit]); copied += dlen) {
		dlen = ipl->ipl_dsize;
		if (dlen > uio->uio_resid)
			break;
		/*
		 * Don't hold the mutex over the uiomove call.
		 */
		MUTEX_EXIT(&ipl_mutex);
		SPL_X(s);
		error = UIOMOVE((caddr_t)ipl, dlen, UIO_READ, uio);
		if (error) {
			SPL_NET(s);
			MUTEX_ENTER(&ipl_mutex);
			break;
		}
		SPL_NET(s);
		MUTEX_ENTER(&ipl_mutex);
		iplused[unit] -= dlen;
		iplt[unit] = ipl->ipl_next;
		KFREES((caddr_t)ipl, dlen);
	}
	if (!iplt[unit]) {
		iplused[unit] = 0;
		iplh[unit] = &iplt[unit];
		ipll[unit] = NULL;
	}

	MUTEX_EXIT(&ipl_mutex);
	SPL_X(s);
	return error;
}


int ipflog_clear(unit)
minor_t unit;
{
	iplog_t *ipl;
	int used;

	MUTEX_ENTER(&ipl_mutex);
	while ((ipl = iplt[unit])) {
		iplt[unit] = ipl->ipl_next;
		KFREES((caddr_t)ipl, ipl->ipl_dsize);
	}
	iplh[unit] = &iplt[unit];
	ipll[unit] = NULL;
	used = iplused[unit];
	iplused[unit] = 0;
	bzero((char *)&iplcrc[unit], FI_CSIZE);
	MUTEX_EXIT(&ipl_mutex);
	return used;
}
#endif /* IPFILTER_LOG */
@


1.12
log
@IPfilter 3.4.17; kjell@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_log.c,v 1.11 2001/03/25 12:03:11 gluk Exp $	*/
@


1.11
log
@Protect KFREES by splnet and rearrange pointers. This fix interrupt
race between ipllog() and ipflog_read() which caused a memory leak
and "Data modified on freelist" error.

fgsch@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_log.c,v 1.10 2001/01/30 04:23:56 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1997-2000 by Darren Reed.
d10 1
a10 1
 * $IPFilter: ip_log.c,v 2.5.2.2 2000/08/13 03:50:41 darrenr Exp $
d50 1
a50 1
# if defined(_KERNEL) && !defined(linux)
d60 1
a60 3
#  ifndef linux
#   include <sys/mbuf.h>
#  endif
d72 1
a72 3
# ifndef linux
#  include <sys/protosw.h>
# endif
d90 1
a90 1
# if !defined(linux) && !(defined(__sgi) && !defined(IFF_DRVRLOCK)) /*IRIX<6*/
d98 1
a98 3
# ifndef linux
#  include <netinet/ip_var.h>
# endif
a128 3
# ifdef	linux
static struct wait_queue *iplwait[IPL_LOGMAX+1];
# endif
a224 1
#   ifndef linux
a225 1
#   endif
d331 1
a331 1
# if SOLARIS || defined(sun) || defined(linux)
a363 3
#  ifdef linux
	wake_up_interruptible(&iplwait[dev]);
#  else
a364 1
#  endif
d389 1
a389 2
	if ((uio->uio_resid < sizeof(iplog_t)) ||
	    (uio->uio_resid > IPLLOGSIZE))
a405 5
#  ifdef linux
		interruptible_sleep_on(&iplwait[unit]);
		if (current->signal & ~current->blocked)
			return -EINTR;
#  else
a406 1
		SPL_X(s);
d408 2
a409 1
		if (error)
d411 1
a411 1
		SPL_NET(s);
a412 1
#  endif /* linux */
a448 5
# ifdef 	linux
	if (!error)
		return (int)copied;
	return -error;
# else
a449 1
# endif
@


1.10
log
@re-add local ipf changes that were whacked in the 3.4.16 merge. userland to follow
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_log.c,v 1.9 2001/01/17 04:47:14 fgsch Exp $	*/
a448 2
		iplt[unit] = ipl->ipl_next;
		iplused[unit] -= dlen;
a454 3
			ipl->ipl_next = iplt[unit];
			iplt[unit] = ipl;
			iplused[unit] += dlen;
a456 1
		KFREES((caddr_t)ipl, dlen);
d459 3
@


1.9
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 1
a108 1
# include "netinet/ip_compat.h"
d110 6
a115 6
# include "netinet/ip_fil.h"
# include "netinet/ip_proxy.h"
# include "netinet/ip_nat.h"
# include "netinet/ip_frag.h"
# include "netinet/ip_state.h"
# include "netinet/ip_auth.h"
@


1.8
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d4 1
a4 1
 * Copyright (C) 1997-1998 by Darren Reed.
d10 1
a10 1
 * $IPFilter: ip_log.c,v 2.1.2.2 1999/09/21 11:55:44 darrenr Exp $
a20 1
#  include <sys/osreldate.h>
d25 3
a27 1
#  include <osreldate.h>
d108 1
a108 1
# include <netinet/ip_fil_compat.h>
d110 6
a115 6
# include <netinet/ip_fil.h>
# include <netinet/ip_proxy.h>
# include <netinet/ip_nat.h>
# include <netinet/ip_frag.h>
# include <netinet/ip_state.h>
# include <netinet/ip_auth.h>
d134 1
a134 1
fr_info_t	iplcrc[IPL_LOGMAX+1];
d177 1
d188 3
a190 2
	if ((ip->ip_off & IP_OFFMASK) == 0) {
		if (ip->ip_p == IPPROTO_TCP)
d192 1
a192 1
		else if (ip->ip_p == IPPROTO_UDP)
d194 2
a195 2
		else if (ip->ip_p == IPPROTO_ICMP) {
			struct	icmp	*icmp;
d197 1
a197 1
			icmp = (struct icmp *)((char *)ip + hlen);
d242 1
a242 1
	mlen = (flags & FR_LOGBODY) ? MIN(ip->ip_len - hlen, 128) : 0;
@


1.7
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@@


1.6
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.6.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_log.c,v 1.7 2000/02/16 22:34:19 kjell Exp $	*/
@


1.6.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_log.c,v 1.11 2001/03/25 12:03:11 gluk Exp $	*/
d4 1
a4 1
 * Copyright (C) 1997-2000 by Darren Reed.
d10 1
a10 1
 * $IPFilter: ip_log.c,v 2.5.2.2 2000/08/13 03:50:41 darrenr Exp $
d21 1
d26 1
a26 3
#  ifdef KLD_MODULE
#   include <osreldate.h>
#  endif
d133 1
a133 1
static fr_info_t	iplcrc[IPL_LOGMAX+1];
a175 1
	u_char p;
d186 2
a187 3
	if (fin->fin_off == 0) {
		p = fin->fin_fi.fi_p;
		if (p == IPPROTO_TCP)
d189 1
a189 1
		else if (p == IPPROTO_UDP)
d191 2
a192 2
		else if (p == IPPROTO_ICMP) {
			struct icmp *icmp;
d194 1
a194 1
			icmp = (struct icmp *)fin->fin_dp;
d239 1
a239 1
	mlen = (flags & FR_LOGBODY) ? MIN(fin->fin_plen - hlen, 128) : 0;
d446 2
d454 3
d459 1
a461 3
		iplused[unit] -= dlen;
		iplt[unit] = ipl->ipl_next;
		KFREES((caddr_t)ipl, dlen);
@


1.6.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_log.c,v 1.6.2.2 2001/05/14 22:40:12 niklas Exp $	*/
@


1.5
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d10 1
a10 1
 * $Id: ip_log.c,v 2.1.2.2 1999/09/21 11:55:44 darrenr Exp $
@


1.4
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_log.c,v 1.3 1998/09/15 09:51:18 pattonme Exp $       */
d9 1
a9 1
 * $Id: ip_log.c,v 1.3 1998/09/15 09:51:18 pattonme Exp $
d11 17
a31 11

# if defined(KERNEL) && !defined(_KERNEL)
#  define       _KERNEL
# endif
# ifdef  __FreeBSD__
#  if defined(_KERNEL) && !defined(IPFILTER_LKM)
#   include <sys/osreldate.h>
#  else
#   include <osreldate.h>
#  endif
# endif
a39 1
# include <sys/param.h>
d53 1
a53 1
#  if (NetBSD > 199609) || (OpenBSD > 199603)
d106 1
a106 5
# if defined(__OpenBSD__)
#  include <netinet/ip_fil_compat.h>
# else
#  include <netinet/ip_compat.h>
# endif
d114 4
d130 3
a132 4
iplog_t	**iplh[IPL_LOGMAX+1], *iplt[IPL_LOGMAX+1];
int	iplused[IPL_LOGMAX+1];
u_long	iplcrc[IPL_LOGMAX+1];
u_long	iplcrcinit;
a143 1
	struct	timeval	tv;
d148 1
d151 1
a152 6
# if BSD >= 199306 || defined(__FreeBSD__) || defined(__sgi)
	microtime(&tv);
# else
	uniqtime(&tv);
# endif
	iplcrcinit = tv.tv_sec ^ (tv.tv_usec << 8) ^ tv.tv_usec;
d171 1
a171 2
	register int mlen, hlen;
	u_long crc;
d194 1
a194 1
	
d196 4
a199 4
			* For ICMP, if the packet is an error packet, also
			* include the information about the packet which
			* caused the error.
			*/
d244 4
d252 1
a252 1
#if SOLARIS
d265 1
a265 1
#else
d269 2
a270 3
#endif
	crc = (ipf_cksum((u_short *)fin, FI_CSIZE) << 8) + iplcrcinit;
	return ipllog(IPL_LOGIPF, crc, ptrs, sizes, types, 2);
d277 1
a277 1
int ipllog(dev, crc, items, itemsz, types, cnt)
d279 1
a279 1
u_long crc;
d284 1
d286 2
a287 2
	caddr_t buf, s;
	int len, i;
d294 5
a298 4
	if (crc) {
		MUTEX_ENTER(&ipl_mutex);
		if ((iplcrc[dev] == crc) && *iplh[dev]) {
			(*iplh[dev])->ipl_count++;
d302 4
a305 3
		iplcrc[dev] = crc;
		MUTEX_EXIT(&ipl_mutex);
	}
d317 1
a317 1
	KMALLOC(buf, caddr_t, len);
d363 1
d382 1
a382 1
int unit;
d385 2
a387 1
	int error = 0, dlen, copied;
d396 1
a396 1
	if ((IPL_LOGMAX < unit) || (unit < 0))
d440 1
a440 1
		if (dlen + sizeof(iplog_t) > uio->uio_resid)
d446 1
d449 7
a455 3
		error = UIOMOVE((caddr_t)ipl, ipl->ipl_dsize, UIO_READ, uio);
		KFREES((caddr_t)ipl, ipl->ipl_dsize);
		if (error)
d457 2
a460 1
		iplused[unit] -= dlen;
d462 1
a462 1
	if (!ipl) {
d465 1
d468 3
a470 5
	if (!error) {
		MUTEX_EXIT(&ipl_mutex);
		SPL_X(s);
	}
#ifdef 	linux
d472 1
a472 1
		return copied;
d474 1
a474 1
#else
d476 1
a476 1
#endif
d481 1
a481 1
int unit;
d492 1
d495 1
a495 1
	iplcrc[unit] = 0;
@


1.3
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_log.c,v 1.2 1998/02/17 01:39:04 dgregor Exp $       */
d3 1
a3 1
 * Copyright (C) 1997 by Darren Reed.
d9 1
a9 1
 * $Id: ip_log.c,v 1.2 1998/08/31 20:50:00 pattonme Exp $
d187 30
a216 23
	if (ip->ip_p == IPPROTO_TCP)
		hlen += MIN(sizeof(tcphdr_t), fin->fin_dlen);
	else if (ip->ip_p == IPPROTO_UDP)
		hlen += MIN(sizeof(udphdr_t), fin->fin_dlen);
	else if (ip->ip_p == IPPROTO_ICMP) {
		struct	icmp	*icmp = (struct icmp *)((char *)ip + hlen);
 
		/*
		 * For ICMP, if the packet is an error packet, also include
		 * the information about the packet which caused the error.
		 */
		switch (icmp->icmp_type)
		{
		case ICMP_UNREACH :
		case ICMP_SOURCEQUENCH :
		case ICMP_REDIRECT :
		case ICMP_TIMXCEED :
		case ICMP_PARAMPROB :
			hlen += MIN(sizeof(struct icmp) + 8, fin->fin_dlen);
			break;
		default :
			hlen += MIN(sizeof(struct icmp), fin->fin_dlen);
			break;
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*       $OpenBSD$       */
d9 1
a9 1
 * $Id: ip_log.c,v 1.1 1998/01/26 04:10:43 dgregor Exp $
d101 5
a105 1
# include "netinet/ip_fil_compat.h"
d107 6
a112 6
# include "netinet/ip_fil.h"
# include "netinet/ip_proxy.h"
# include "netinet/ip_nat.h"
# include "netinet/ip_frag.h"
# include "netinet/ip_state.h"
# include "netinet/ip_auth.h"
d129 1
a129 1
#ifdef	linux
d131 1
a131 1
#endif
d468 1
d477 1
@


1.1
log
@IPF 3.2.3
@
text
@d1 1
d9 1
a9 1
 * $Id: ip_log.c,v 2.0.2.13.2.3 1997/11/20 12:41:40 darrenr Exp $
@
