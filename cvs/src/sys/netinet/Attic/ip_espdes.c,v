head	1.10;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	UBC_SYNC_A:1.10
	UBC_SYNC_B:1.10
	SMP:1.10.0.2
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.10
date	97.07.11.23.49.19;	author provos;	state dead;
branches;
next	1.9;

1.9
date	97.07.01.22.12.48;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.06.25.07.53.26;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.06.24.20.57.28;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.06.24.12.15.23;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.06.21.00.09.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.20.05.41.51;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.02.26.20.53.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.02.24.14.06.40;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.07.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@obsolete.
@
text
@/*	$OpenBSD: ip_espdes.c,v 1.9 1997/07/01 22:12:48 provos Exp $	*/

/*
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
 *
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
 *
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * DES-CBC
 * Per RFC1829 (Metzger & Simpson, 1995)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <machine/cpu.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>

#include <sys/socketvar.h>
#include <net/raw_cb.h>
#include <net/encap.h>

#include <netinet/ip_icmp.h>
#include <netinet/ip_ipsp.h>
#include <netinet/ip_esp.h>
#include <dev/rndvar.h>

extern struct ifnet loif;

extern void des_ecb_encrypt(caddr_t, caddr_t, caddr_t, int);
extern void des_set_key(caddr_t, caddr_t);

int
espdes_attach()
{
    return 0;
}

/*
 * espdes_init() is called when an SPI is being set up. It interprets the
 * encap_msghdr present in m, and sets up the transformation data, in
 * this case, the encryption and decryption key schedules
 */

int
espdes_init(struct tdb *tdbp, struct xformsw *xsp, struct mbuf *m)
{
    struct espdes_xdata *xd;
    struct encap_msghdr *em;
    u_int32_t rk[2];

    tdbp->tdb_xform = xsp;

    m = m_pullup(m, ESP_ULENGTH);
    if (m == NULL)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("espdes_init: can't pull up %d bytes\n", ESP_ULENGTH);
#endif ENCDEBUG
	return ENOBUFS;
    }

    MALLOC(tdbp->tdb_xdata, caddr_t, sizeof (struct espdes_xdata),
	   M_XDATA, M_WAITOK);
    if (tdbp->tdb_xdata == NULL)
      return ENOBUFS;
    bzero(tdbp->tdb_xdata, sizeof (struct espdes_xdata));
    xd = (struct espdes_xdata *)tdbp->tdb_xdata;

    em = mtod(m, struct encap_msghdr *);
    if (em->em_msglen - EMT_SETSPI_FLEN != ESP_ULENGTH)
    {
	free((caddr_t)tdbp->tdb_xdata, M_XDATA);
	tdbp->tdb_xdata = NULL;
	return EINVAL;
    }

    m_copydata(m, EMT_SETSPI_FLEN, ESP_ULENGTH, (caddr_t)xd);

    rk[0] = xd->edx_eks[0][0];	/* some overloading doesn't hurt */
    rk[1] = xd->edx_eks[0][1];	/* XXX -- raw-major order */

    des_set_key((caddr_t)rk, (caddr_t)(xd->edx_eks));
    rk[0] = rk[1] = 0;		/* zeroize! */

    return 0;
}

int
espdes_zeroize(struct tdb *tdbp)
{
    FREE(tdbp->tdb_xdata, M_XDATA);
    return 0;
}


struct mbuf *
espdes_input(struct mbuf *m, struct tdb *tdb)
{
    struct espdes_xdata *xd;
    struct ip *ip, ipo;
    u_char iv[8], niv[8], blk[8];
    u_char *idat, *odat;
    struct esp *esp;
    struct ifnet *rcvif;
    int ohlen, plen, ilen, olen, i;
    struct mbuf *mi, *mo;

    xd = (struct espdes_xdata *)tdb->tdb_xdata;
    ohlen = sizeof (struct ip) + ESP_FLENGTH;

    rcvif = m->m_pkthdr.rcvif;
    if (rcvif == NULL)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("espdes_input: receive interface is NULL!!!\n");
#endif ENCDEBUG
	rcvif = &loif;
    }

    ip = mtod(m, struct ip *);
    ipo = *ip;
    esp = (struct esp *)(ip + 1);

    plen = m->m_pkthdr.len - sizeof (struct ip) - sizeof (u_int32_t) - xd->edx_ivlen;
    if (plen & 07)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("espdes_input: payload not a multiple of 8 octets\n");
#endif ENCDEBUG
	espstat.esps_badilen++;
	m_freem(m);
	return NULL;
    }

    ilen = m->m_len - sizeof (struct ip) - 8;
    idat = mtod(m, unsigned char *) + sizeof (struct ip) + 8;

    iv[0] = esp->esp_iv[0];
    iv[1] = esp->esp_iv[1];
    iv[2] = esp->esp_iv[2];
    iv[3] = esp->esp_iv[3];
    if (xd->edx_ivlen == 4)
    {
	iv[4] = ~esp->esp_iv[0];
	iv[5] = ~esp->esp_iv[1];
	iv[6] = ~esp->esp_iv[2];
	iv[7] = ~esp->esp_iv[3];
    }
    else
    {
	iv[4] = esp->esp_iv[4];
	iv[5] = esp->esp_iv[5];
	iv[6] = esp->esp_iv[6];
	iv[7] = esp->esp_iv[7];

	ilen -= 4;
	idat += 4;
    }

    olen = ilen;
    odat = idat;
    mi = mo = m;
    i = 0;

    /*
     * At this point:
     *   plen is # of encapsulated payload octets
     *   ilen is # of octets left in this mbuf
     *   idat is first encapsulated payload octed in this mbuf
     *   same for olen and odat
     *   iv contains the IV.
     *   mi and mo point to the first mbuf
     *
     * From now on until the end of the mbuf chain:
     *   . move the next eight octets of the chain into blk[]
     *     (ilen, idat, and mi are adjusted accordingly)
     *     and save it back into iv[]
     *   . decrypt blk[], xor with iv[], put back into chain
     *     (olen, odat, amd mo are adjusted accordingly)
     *   . repeat
     */

    while (plen > 0)		/* while not done */
    {
	while (ilen == 0)	/* we exhausted previous mbuf */
	{
	    mi = mi->m_next;
	    if (mi == NULL)
	      panic("espdes_input: bad chain (i)\n");
	    ilen = mi->m_len;
	    idat = (u_char *)mi->m_data;
	}

	blk[i] = niv[i] = *idat++;
	i++;
	ilen--;

	if (i == 8)
	{
	    des_ecb_encrypt(blk, blk, (caddr_t)(xd->edx_eks), 0);
	    for (i=0; i<8; i++)
	    {
		while (olen == 0)
		{
		    mo = mo->m_next;
		    if (mo == NULL)
		      panic("espdes_input: bad chain (o)\n");
		    olen = mo->m_len;
		    odat = (u_char *)mo->m_data;
		}
		*odat = blk[i] ^ iv[i];
		iv[i] = niv[i];
		blk[i] = *odat++; /* needed elsewhere */
		olen--;
	    }
	    i = 0;
	}

	plen--;
    }

    /*
     * Now, the entire chain has been decrypted. As a side effect,
     * blk[7] contains the next protocol, and blk[6] contains the
     * amount of padding the original chain had. Chop off the
     * appropriate parts of the chain, and return.
     */

    m_adj(m, -blk[6] - 2);
    m_adj(m, 4 + xd->edx_ivlen);
    if (m->m_len < sizeof (struct ip))
    {
	m = m_pullup(m, sizeof (struct ip));
	if (m == NULL)
	{
	    return NULL;
	}
    }

    ip = mtod(m, struct ip *);
    ipo.ip_p = blk[7];
    ipo.ip_id = htons(ipo.ip_id);
    ipo.ip_off = 0;
    ipo.ip_len += sizeof (struct ip) - 4 - xd->edx_ivlen - blk[6] - 2;
    ipo.ip_len = htons(ipo.ip_len);
    ipo.ip_sum = 0;
    *ip = ipo;
    ip->ip_sum = in_cksum(m, sizeof (struct ip));

    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) + blk[6] + 2;

    return m;
}

int
espdes_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb,
	      struct mbuf **mp)
{
    struct espdes_xdata *xd;
    struct ip *ip, ipo;
    int i, ilen, olen, ohlen, nh, rlen, plen, padding;
    u_int32_t spi;
    struct mbuf *mi, *mo;
    u_char *pad, *idat, *odat;
    u_char iv[8], blk[8], opts[40];
    int iphlen;

    espstat.esps_output++;
    m = m_pullup(m, sizeof (struct ip));
    if (m == NULL)
      return ENOBUFS;

    ip = mtod(m, struct ip *);
    spi = tdb->tdb_spi;
    iphlen = ip->ip_hl << 2;

    /*
     * If options are present, pullup the IP header, the options
     * and one DES block (8 bytes) of data.
     */
    if (iphlen != sizeof(struct ip))
    {
	m = m_pullup(m, iphlen + 8);
	if (m == NULL)
	  return ENOBUFS;

	ip = mtod(m, struct ip *);

	/* Keep the options */
	bcopy(mtod(m, u_char *) + sizeof(struct ip), opts,
	      iphlen - sizeof(struct ip));
    }
    
    xd = (struct espdes_xdata *)tdb->tdb_xdata;
    ilen = ntohs(ip->ip_len);
    ohlen = sizeof (u_int32_t) + xd->edx_ivlen;

    ipo = *ip;
    nh = ipo.ip_p;

    rlen = ilen - iphlen; /* raw payload length  */
    padding = ((8 - ((rlen + 2) % 8)) % 8) + 2;

    pad = (u_char *)m_pad(m, padding);
    if (pad == NULL)
      return ENOBUFS;

    pad[padding-2] = padding - 2;
    pad[padding-1] = nh;

    plen = rlen + padding;
    mi = mo = m;
    ilen = olen = m->m_len - iphlen;
    idat = odat = mtod(m, u_char *) + iphlen;
    i = 0;

    /*
     * We are now ready to encrypt the payload. 
     */

    xd->edx_ivl++;
	
    iv[0] = xd->edx_iv[0];
    iv[1] = xd->edx_iv[1];
    iv[2] = xd->edx_iv[2];
    iv[3] = xd->edx_iv[3];
    if (xd->edx_ivlen == 4)
    {
	iv[4] = ~xd->edx_iv[0];
	iv[5] = ~xd->edx_iv[1];
	iv[6] = ~xd->edx_iv[2];
	iv[7] = ~xd->edx_iv[3];
    }
    else
    {
	iv[4] = xd->edx_iv[4];
	iv[5] = xd->edx_iv[5];
	iv[6] = xd->edx_iv[6];
	iv[7] = xd->edx_iv[7];
    }

    while (plen > 0)		/* while not done */
    {
	while (ilen == 0)	/* we exhausted previous mbuf */
	{
	    mi = mi->m_next;
	    if (mi == NULL)
	      panic("espdes_output: bad chain (i)\n");
	    ilen = mi->m_len;
	    idat = (u_char *)mi->m_data;
	}

	blk[i] = *idat++ ^ iv[i];
		
	i++;
	ilen--;

	if (i == 8)
	{
	    des_ecb_encrypt(blk, blk, (caddr_t)(xd->edx_eks), 1);
	    for (i = 0; i < 8; i++)
	    {
		while (olen == 0)
		{
		    mo = mo->m_next;
		    if (mo == NULL)
		      panic("espdes_output: bad chain (o)\n");
		    olen = mo->m_len;
		    odat = (u_char *)mo->m_data;
		}
		*odat++ = blk[i];
		iv[i] = blk[i];
		olen--;
	    }
	    i = 0;
	}

	plen--;
    }

    /*
     * Done with encryption. Let's wedge in the ESP header
     * and send it out.
     */

    M_PREPEND(m, ohlen, M_DONTWAIT);
    if (m == NULL)
      return ENOBUFS;

    m = m_pullup(m, iphlen + ohlen);
    if (m == NULL)
      return ENOBUFS;

    ipo.ip_len = htons(iphlen + ohlen + rlen + padding);
    ipo.ip_p = IPPROTO_ESP;

    iv[0] = xd->edx_iv[0];
    iv[1] = xd->edx_iv[1];
    iv[2] = xd->edx_iv[2];
    iv[3] = xd->edx_iv[3];
    if (xd->edx_ivlen == 8)
    {
	iv[4] = xd->edx_iv[4];
	iv[5] = xd->edx_iv[5];
	iv[6] = xd->edx_iv[6];
	iv[7] = xd->edx_iv[7];
    }

    bcopy((caddr_t)&ipo, mtod(m, caddr_t), sizeof(struct ip));

    /* Copy options, if existing */
    if (iphlen != sizeof(struct ip))
      bcopy(opts, mtod(m, caddr_t) + sizeof(struct ip),
	    iphlen - sizeof(struct ip));

    bcopy((caddr_t)&spi, mtod(m, caddr_t) + iphlen, sizeof(u_int32_t));
    bcopy((caddr_t)iv,  mtod(m, caddr_t) + iphlen +
	  sizeof (u_int32_t), xd->edx_ivlen);
	
    *mp = m;

    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += rlen + padding;

    return 0;
}	
	


/*
 *
 *
 * m_pad(m, n) pads <m> with <n> bytes at the end. The packet header
 * length is updated, and a pointer to the first byte of the padding
 * (which is guaranteed to be all in one mbuf) is returned.
 *
 */

caddr_t
m_pad(struct mbuf *m, int n)
{
    register int len, pad;
    register struct mbuf *m0, *m1;
    caddr_t retval;
    u_char dat;
	
    if (n <= 0)			/* no stupid arguments */
      return NULL;

    len = m->m_pkthdr.len;
    pad = n;

    m0 = m;

    while (m0->m_len < len)
    {
	len -= m0->m_len;
	m0 = m0->m_next;
    }

    if (m0->m_len != len)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("m_pad: length mismatch (should be %d instead of %d\n",
		 m->m_pkthdr.len, m->m_pkthdr.len + m0->m_len - len);
#endif ENCDEBUG
	m_freem(m);
	return NULL;
    }

    if ((m0->m_flags & M_EXT) ||
	(m0->m_data + m0->m_len + pad >= &(m0->m_dat[MLEN])))
    {
	/*
	 * Add an mbuf to the chain
	 */

	MGET(m1, M_DONTWAIT, MT_DATA);
	if (m1 == 0)
	{
	    m_freem(m0);
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("m_pad: cannot append\n");
#endif ENCDEBUG
	    return NULL;
	}
	m0->m_next = m1;
	m0 = m1;
	m0->m_len = 0;
    }

    retval = m0->m_data + m0->m_len;
    m0->m_len += pad;
    m->m_pkthdr.len += pad;

    for (len = 0; len < n; len++)
    {
	get_random_bytes((void *)&dat, sizeof(dat));
	retval[len] = len + dat;
    }

    return retval;
}
@


1.9
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_espdes.c,v 1.8 1997/06/25 07:53:26 provos Exp $	*/
@


1.8
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_espdes.c,v 1.7 1997/06/24 20:57:28 provos Exp $	*/
d297 2
a298 1
espdes_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb, struct mbuf **mp)
@


1.7
log
@use ntohs instead of NTOHS for counters
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_espdes.c,v 1.6 1997/06/24 12:15:23 provos Exp $	*/
d290 2
a291 2
    tdb->tdb_packets++;
    tdb->tdb_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) + blk[6] + 2;
d463 2
a464 2
    tdb->tdb_packets++;
    tdb->tdb_bytes += rlen + padding;
@


1.6
log
@handle IP options in AH + allow IP options in outgoing encapsulated packets
+ usage counters for later use with keymanagement processes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_espdes.c,v 1.5 1997/06/21 00:09:18 deraadt Exp $	*/
d291 1
a291 1
    tdb->tdb_bytes += NTOHS(ip->ip_len) - (ip->ip_hl << 2) + blk[6] + 2;
@


1.5
log
@u_int32_t changes, need testing
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_espdes.c,v 1.4 1997/06/20 05:41:51 provos Exp $	*/
d289 4
d305 2
a306 1
    u_char iv[8], blk[8];
d315 19
a333 1
	
d341 1
a341 1
    rlen = ilen - sizeof (struct ip); /* raw payload length  */
d353 2
a354 2
    ilen = olen = m->m_len - sizeof (struct ip);
    idat = odat = mtod(m, u_char *) + sizeof (struct ip);
d401 1
a401 1
	    for (i=0; i<8; i++)
d430 1
a430 1
    m = m_pullup(m, sizeof(struct ip) + xd->edx_ivlen + sizeof(u_int32_t));
d434 1
a434 1
    ipo.ip_len = htons(sizeof (struct ip) + ohlen + rlen + padding);
d449 10
a458 4
    bcopy((caddr_t)&ipo, mtod(m, caddr_t), sizeof (struct ip));
    bcopy((caddr_t)&spi, mtod(m, caddr_t) + sizeof (struct ip), sizeof (u_int32_t));
    bcopy((caddr_t)iv,  mtod(m, caddr_t) + sizeof (struct ip) +
	sizeof (u_int32_t), xd->edx_ivlen);
d461 5
@


1.4
log
@ah-sha1 + esp-3des + indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_espdes.c,v 1.3 1997/02/26 20:53:16 deraadt Exp $	*/
d85 1
a85 1
    u_long rk[2];
d162 1
a162 1
    plen = m->m_pkthdr.len - sizeof (struct ip) - sizeof (u_long) - xd->edx_ivlen;
d298 1
a298 1
    u_long spi;
d313 1
a313 1
    ohlen = sizeof (u_long) + xd->edx_ivlen;
d407 1
a407 1
    m = m_pullup(m, sizeof(struct ip) + xd->edx_ivlen + sizeof(u_long));
d427 3
a429 2
    bcopy((caddr_t)&spi, mtod(m, caddr_t) + sizeof (struct ip), sizeof (u_long));
    bcopy((caddr_t)iv,  mtod(m, caddr_t) + sizeof (struct ip) + sizeof (u_long), xd->edx_ivlen);
@


1.3
log
@count input/output packets for esp
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_espdes.c,v 1.2 1997/02/24 14:06:40 niklas Exp $	*/
a67 7
extern MD5_CTX IP4_ctx;

extern int ticks;
#ifdef EXT_CLOCK
extern int clock_count;
#endif

d71 1
a71 1
	return 0;
d83 9
a91 9
	struct espdes_xdata *xd;
	struct encap_msghdr *em;
	u_long rk[2];

	tdbp->tdb_xform = xsp;

	m = m_pullup(m, ESP_ULENGTH);
	if (m == NULL)
	{
d93 2
a94 2
		if (encdebug)
		  printf("espdes_init: can't pull up %d bytes\n", ESP_ULENGTH);
d96 2
a97 17
		return ENOBUFS;
	}

	MALLOC(tdbp->tdb_xdata, caddr_t, sizeof (struct espdes_xdata),
	       M_XDATA, M_WAITOK);
	if (tdbp->tdb_xdata == NULL)
	  return ENOBUFS;
	bzero(tdbp->tdb_xdata, sizeof (struct espdes_xdata));
	xd = (struct espdes_xdata *)tdbp->tdb_xdata;

	em = mtod(m, struct encap_msghdr *);
	if (em->em_msglen - EMT_SETSPI_FLEN != ESP_ULENGTH)
	{
		free((caddr_t)tdbp->tdb_xdata, M_XDATA);
		tdbp->tdb_xdata = NULL;
		return EINVAL;
	}
d99 16
a114 1
	m_copydata(m, EMT_SETSPI_FLEN, ESP_ULENGTH, (caddr_t)xd);
d116 2
a117 2
	rk[0] = xd->edx_eks[0][0];	/* some overloading doesn't hurt */
	rk[1] = xd->edx_eks[0][1];	/* XXX -- raw-major order */
d119 2
a120 2
	des_set_key((caddr_t)rk, (caddr_t)(xd->edx_eks));
	rk[0] = rk[1] = 0;		/* zeroize! */
d122 1
a122 1
	return 0;
d128 2
a129 2
	FREE(tdbp->tdb_xdata, M_XDATA);
	return 0;
d136 15
a150 15
	struct espdes_xdata *xd;
	struct ip *ip, ipo;
	u_char iv[8], niv[8], blk[8];
	u_char *idat, *odat;
	struct esp *esp;
	struct ifnet *rcvif;
	int ohlen, plen, ilen, olen, i;
	struct mbuf *mi, *mo;

	xd = (struct espdes_xdata *)tdb->tdb_xdata;
	ohlen = sizeof (struct ip) + ESP_FLENGTH;

	rcvif = m->m_pkthdr.rcvif;
	if (rcvif == NULL)
	{
d152 2
a153 2
		if (encdebug)
		  printf("espdes_input: receive interface is NULL!!!\n");
d155 2
a156 6
		rcvif = &loif;
	}

	ip = mtod(m, struct ip *);
	ipo = *ip;
	esp = (struct esp *)(ip + 1);
d158 7
a164 3
	plen = m->m_pkthdr.len - sizeof (struct ip) - sizeof (u_long) - xd->edx_ivlen;
	if (plen & 07)
	{
d166 2
a167 2
		if (encdebug)
		  printf("espdes_input: payload not a multiple of 8 octets\n");
d169 74
a242 56
		espstat.esps_badilen++;
		m_freem(m);
		return NULL;
	}

	ilen = m->m_len - sizeof (struct ip) - 8;
	idat = mtod(m, unsigned char *) + sizeof (struct ip) + 8;

	iv[0] = esp->esp_iv[0];
	iv[1] = esp->esp_iv[1];
	iv[2] = esp->esp_iv[2];
	iv[3] = esp->esp_iv[3];
	if (xd->edx_ivlen == 4)
	{
		iv[4] = ~esp->esp_iv[0];
		iv[5] = ~esp->esp_iv[1];
		iv[6] = ~esp->esp_iv[2];
		iv[7] = ~esp->esp_iv[3];
	}
	else
	{
		iv[4] = esp->esp_iv[4];
		iv[5] = esp->esp_iv[5];
		iv[6] = esp->esp_iv[6];
		iv[7] = esp->esp_iv[7];

		ilen -= 4;
		idat += 4;
	}

	olen = ilen;
	odat = idat;
	mi = mo = m;
	i = 0;

	/*
	 * At this point:
	 *   plen is # of encapsulated payload octets
	 *   ilen is # of octets left in this mbuf
	 *   idat is first encapsulated payload octed in this mbuf
	 *   same for olen and odat
	 *   iv contains the IV.
	 *   mi and mo point to the first mbuf
	 *
	 * From now on until the end of the mbuf chain:
	 *   . move the next eight octets of the chain into blk[]
	 *     (ilen, idat, and mi are adjusted accordingly)
	 *     and save it back into iv[]
	 *   . decrypt blk[], xor with iv[], put back into chain
	 *     (olen, odat, amd mo are adjusted accordingly)
	 *   . repeat
	 */

	while (plen > 0)		/* while not done */
	{
		while (ilen == 0)	/* we exhausted previous mbuf */
d244 5
a248 5
			mi = mi->m_next;
			if (mi == NULL)
			  panic("espdes_input: bad chain (i)\n");
			ilen = mi->m_len;
			idat = (u_char *)mi->m_data;
d250 24
a273 39

		blk[i] = niv[i] = *idat++;
		i++;
		ilen--;

		if (i == 8)
		{
			des_ecb_encrypt(blk, blk, (caddr_t)(xd->edx_eks), 0);
			for (i=0; i<8; i++)
			{
				while (olen == 0)
				{
					mo = mo->m_next;
					if (mo == NULL)
					  panic("espdes_input: bad chain (o)\n");
					olen = mo->m_len;
					odat = (u_char *)mo->m_data;
				}
				*odat = blk[i] ^ iv[i];
				iv[i] = niv[i];
				blk[i] = *odat++; /* needed elsewhere */
				olen--;
			}
			i = 0;
		}

		plen--;
	}

	/*
	 * Now, the entire chain has been decrypted. As a side effect,
	 * blk[7] contains the next protocol, and blk[6] contains the
	 * amount of padding the original chain had. Chop off the
	 * appropriate parts of the chain, and return.
	 */

	m_adj(m, -blk[6] - 2);
	m_adj(m, 4 + xd->edx_ivlen);
	if (m->m_len < sizeof (struct ip))
d275 1
a275 5
		m = m_pullup(m, sizeof (struct ip));
		if (m == NULL)
		{
			return NULL;
		}
d277 1
d279 9
a287 9
	ip = mtod(m, struct ip *);
	ipo.ip_p = blk[7];
	ipo.ip_id = htons(ipo.ip_id);
	ipo.ip_off = 0;
	ipo.ip_len += sizeof (struct ip) - 4 - xd->edx_ivlen - blk[6] - 2;
	ipo.ip_len = htons(ipo.ip_len);
	ipo.ip_sum = 0;
	*ip = ipo;
	ip->ip_sum = in_cksum(m, sizeof (struct ip));
d289 1
a289 1
	return m;
d295 12
a306 12
	struct espdes_xdata *xd;
	struct ip *ip, ipo;
	int i, ilen, olen, ohlen, nh, rlen, plen, padding;
	u_long spi;
	struct mbuf *mi, *mo;
	u_char *pad, *idat, *odat;
	u_char iv[8], blk[8];

	espstat.esps_output++;
	m = m_pullup(m, sizeof (struct ip));
	if (m == NULL)
	  return ENOBUFS;
d308 2
a309 2
	ip = mtod(m, struct ip *);
	spi = tdb->tdb_spi;
d311 26
a336 22
	xd = (struct espdes_xdata *)tdb->tdb_xdata;
	ilen = ntohs(ip->ip_len);
	ohlen = sizeof (u_long) + xd->edx_ivlen;

	ipo = *ip;
	nh = ipo.ip_p;

	rlen = ilen - sizeof (struct ip); /* raw payload length  */
        padding = ((8 - ((rlen + 2) % 8)) % 8) + 2;

	pad = (u_char *)m_pad(m, padding);
	if (pad == NULL)
	  return ENOBUFS;

	pad[padding-2] = padding - 2;
	pad[padding-1] = nh;

	plen = rlen + padding;
	mi = mo = m;
	ilen = olen = m->m_len - sizeof (struct ip);
	idat = odat = mtod(m, u_char *) + sizeof (struct ip);
	i = 0;
d338 1
a338 5
	/*
	 * We are now ready to encrypt the payload. 
	 */

	xd->edx_ivl++;
d340 28
a367 17
	iv[0] = xd->edx_iv[0];
	iv[1] = xd->edx_iv[1];
	iv[2] = xd->edx_iv[2];
	iv[3] = xd->edx_iv[3];
	if (xd->edx_ivlen == 4)
	{
		iv[4] = ~xd->edx_iv[0];
		iv[5] = ~xd->edx_iv[1];
		iv[6] = ~xd->edx_iv[2];
		iv[7] = ~xd->edx_iv[3];
	}
	else
	{
		iv[4] = xd->edx_iv[4];
		iv[5] = xd->edx_iv[5];
		iv[6] = xd->edx_iv[6];
		iv[7] = xd->edx_iv[7];
d370 1
a370 12
	while (plen > 0)		/* while not done */
	{
		while (ilen == 0)	/* we exhausted previous mbuf */
		{
			mi = mi->m_next;
			if (mi == NULL)
			  panic("espdes_output: bad chain (i)\n");
			ilen = mi->m_len;
			idat = (u_char *)mi->m_data;
		}

		blk[i] = *idat++ ^ iv[i];
d372 2
a373 2
		i++;
		ilen--;
d375 6
a380 1
		if (i == 8)
d382 5
a386 16
			des_ecb_encrypt(blk, blk, (caddr_t)(xd->edx_eks), 1);
			for (i=0; i<8; i++)
			{
				while (olen == 0)
				{
					mo = mo->m_next;
					if (mo == NULL)
					  panic("espdes_output: bad chain (o)\n");
					olen = mo->m_len;
					odat = (u_char *)mo->m_data;
				}
				*odat++ = blk[i];
				iv[i] = blk[i];
				olen--;
			}
			i = 0;
d388 41
a428 35

		plen--;
	}

	/*
	 * Done with encryption. Let's wedge in the ESP header
	 * and send it out.
	 */

	M_PREPEND(m, ohlen, M_DONTWAIT);
	if (m == NULL)
	  return ENOBUFS;

	m = m_pullup(m, sizeof(struct ip) + xd->edx_ivlen + sizeof(u_long));
	if (m == NULL)
	  return ENOBUFS;

	ipo.ip_len = htons(sizeof (struct ip) + ohlen + rlen + padding);
	ipo.ip_p = IPPROTO_ESP;

	iv[0] = xd->edx_iv[0];
	iv[1] = xd->edx_iv[1];
	iv[2] = xd->edx_iv[2];
	iv[3] = xd->edx_iv[3];
	if (xd->edx_ivlen == 8)
	{
		iv[4] = xd->edx_iv[4];
		iv[5] = xd->edx_iv[5];
		iv[6] = xd->edx_iv[6];
		iv[7] = xd->edx_iv[7];
	}

	bcopy((caddr_t)&ipo, mtod(m, caddr_t), sizeof (struct ip));
	bcopy((caddr_t)&spi, mtod(m, caddr_t) + sizeof (struct ip), sizeof (u_long));
	bcopy((caddr_t)iv,  mtod(m, caddr_t) + sizeof (struct ip) + sizeof (u_long), xd->edx_ivlen);
d430 2
a431 2
	*mp = m;
	return 0;
d448 4
a451 4
	register int len, pad;
	register struct mbuf *m0, *m1;
	caddr_t retval;
	u_char dat;
d453 2
a454 2
	if (n <= 0)			/* no stupid arguments */
	  return NULL;
d456 2
a457 2
	len = m->m_pkthdr.len;
	pad = n;
d459 1
a459 1
	m0 = m;
d461 5
a465 5
	while (m0->m_len < len)
	{
		len -= m0->m_len;
		m0 = m0->m_next;
	}
d467 2
a468 2
	if (m0->m_len != len)
	{
d470 3
a472 3
		if (encdebug)
		  printf("m_pad: length mismatch (should be %d instead of %d\n",
			 m->m_pkthdr.len, m->m_pkthdr.len + m0->m_len - len);
d474 10
a483 3
		m_freem(m);
		return NULL;
	}
d485 2
a486 2
	if ((m0->m_flags & M_EXT) ||
	    (m0->m_data + m0->m_len + pad >= &(m0->m_dat[MLEN])))
d488 1
a488 8
		/*
		 * Add an mbuf to the chain
		 */

		MGET(m1, M_DONTWAIT, MT_DATA);
		if (m1 == 0)
		{
			m_freem(m0);
d490 2
a491 2
			if (encdebug)
			  printf("m_pad: cannot append\n");
d493 1
a493 15
			return NULL;
		}
		m0->m_next = m1;
		m0 = m1;
		m0->m_len = 0;
	}

	retval = m0->m_data + m0->m_len;
	m0->m_len += pad;
	m->m_pkthdr.len += pad;

	for (len = 0; len < n; len++)
	{
		get_random_bytes((void *)&dat, sizeof(dat));
	  	retval[len] = len + dat;
d495 14
d510 1
a510 1
	return retval;
@


1.2
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d310 1
a310 1

@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 2
@
