head	1.22;
access;
symbols
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	UBC_SYNC_A:1.22
	UBC_SYNC_B:1.22
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2001.05.30.02.12.30;	author deraadt;	state dead;
branches;
next	1.21;

1.21
date	2001.05.08.19.58.01;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.30.04.22.24;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.17.04.47.13;	author fgsch;	state dead;
branches;
next	1.18;

1.18
date	2000.08.10.05.50.26;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.16.21.47.16;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.01.06.16.47;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.05.05.35.27;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.13.23.40.18;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.16.22.34.18;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.01.19.29.58;	author kjell;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.12.15.05.20.21;	author kjell;	state Exp;
branches;
next	1.10;

1.10
date	99.02.05.05.58.51;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.09.15.09.51.18;	author pattonme;	state Exp;
branches;
next	1.8;

1.8
date	98.02.17.01.39.03;	author dgregor;	state Exp;
branches;
next	1.7;

1.7
date	98.01.26.04.10.40;	author dgregor;	state Exp;
branches;
next	1.6;

1.6
date	97.06.23.19.03.49;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.02.13.05.54.16;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.02.13.05.09.33;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.02.11.22.23.18;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.10.08.07.33.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.07.18.05.01.00;	author dm;	state Exp;
branches;
next	;

1.12.2.1
date	2000.02.20.11.57.25;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.05.14.22.40.10;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.07.04.10.54.45;	author niklas;	state dead;
branches;
next	;


desc
@@


1.22
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ip_fil_compat.h,v 1.21 2001/05/08 19:58:01 fgsch Exp $	*/

/*
 * Copyright (C) 1993-2001 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 *
 * @@(#)ip_compat.h	1.8 1/14/96
 * $IPFilter: ip_compat.h,v 2.26.2.11 2001/04/03 14:13:35 darrenr Exp $
 */

#ifndef	__IP_COMPAT_H__
#define	__IP_COMPAT_H__

#ifndef	__P
# ifdef	__STDC__
#  define	__P(x)  x
# else
#  define	__P(x)  ()
# endif
#endif
#ifndef	__STDC__
# undef		const
# define	const
#endif

#ifndef	SOLARIS
#define	SOLARIS	(defined(sun) && (defined(__svr4__) || defined(__SVR4)))
#endif
#if SOLARIS2 >= 8
# ifndef	USE_INET6
#  define	USE_INET6
# endif
#endif

#if defined(_KERNEL) || defined(KERNEL) || defined(__KERNEL__)
# undef	KERNEL
# undef	_KERNEL
# undef 	__KERNEL__
# define	KERNEL
# define	_KERNEL
# define 	__KERNEL__
#endif

#if defined(__SVR4) || defined(__svr4__) || defined(__sgi)
#define index   strchr
# if !defined(KERNEL)
#  define	bzero(a,b)	memset(a,0,b)
#  define	bcmp		memcmp
#  define	bcopy(a,b,c)	memmove(b,a,c)
# endif
#endif

#ifndef offsetof
#define offsetof(t,m) (int)((&((t *)0L)->m))
#endif

#if defined(__sgi) || defined(bsdi)
struct  ether_addr {
        u_char  ether_addr_octet[6];
};
#endif

#if defined(__sgi) && !defined(IPFILTER_LKM)
# ifdef __STDC__
#  define IPL_EXTERN(ep) ipfilter##ep
# else
#  define IPL_EXTERN(ep) ipfilter/**/ep
# endif
#else
# ifdef __STDC__
#  define IPL_EXTERN(ep) ipl##ep
# else
#  define IPL_EXTERN(ep) ipl/**/ep
# endif
#endif

#ifdef	linux
# include <sys/sysmacros.h>
#endif
#if	SOLARIS
# define	MTYPE(m)	((m)->b_datap->db_type)
# include	<sys/isa_defs.h>
# include	<sys/ioccom.h>
# include	<sys/sysmacros.h>
# include	<sys/kmem.h>
/*
 * because Solaris 2 defines these in two places :-/
 */
# undef	IPOPT_EOL
# undef	IPOPT_NOP
# undef	IPOPT_LSRR
# undef	IPOPT_RR
# undef	IPOPT_SSRR
# ifndef	KERNEL
#  define	_KERNEL
#  undef	RES_INIT
#  if SOLARIS2 >= 8
#   include <netinet/ip6.h>
#  endif
#  include <inet/common.h>
#  include <inet/ip.h>
#  include <inet/ip_ire.h>
#  undef	_KERNEL
# else /* _KERNEL */
#  if SOLARIS2 >= 8
#   include <netinet/ip6.h>
#  endif
#  include <inet/common.h>
#  include <inet/ip.h>
#  include <inet/ip_ire.h>
# endif /* _KERNEL */
# if SOLARIS2 >= 8
#  include <inet/ip_if.h>
#  include <netinet/ip6.h>
#  define	ipif_local_addr	ipif_lcl_addr
/* Only defined in private include file */
#  ifndef	V4_PART_OF_V6
#   define	V4_PART_OF_V6(v6)	v6.s6_addr32[3]
#  endif
# endif
#else
# if !defined(__sgi)
typedef	 int	minor_t;
#endif
#endif /* SOLARIS */
#define	IPMINLEN(i, h)	((i)->ip_len >= ((i)->ip_hl * 4 + sizeof(struct h)))

#if defined(__FreeBSD__) && (__FreeBSD__ >= 5) && defined(_KERNEL)
# include <machine/in_cksum.h>
#endif

#ifndef	IP_OFFMASK
#define	IP_OFFMASK	0x1fff
#endif

#if	BSD > 199306
# define	USE_QUAD_T
# define	U_QUAD_T	u_quad_t
# define	QUAD_T		quad_t
#else /* BSD > 199306 */
# define	U_QUAD_T	u_long
# define	QUAD_T		long
#endif /* BSD > 199306 */


/*
 * These operating systems already take care of the problem for us.
 */
#if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__) || \
    defined(__sgi)
typedef u_int32_t       u_32_t;
# if defined(_KERNEL) && !defined(IPFILTER_LKM)
#  if defined(__NetBSD_Version__) && (__NetBSD_Version__ >= 104110000)
#   include "opt_inet.h"
#  endif
#  if defined(__FreeBSD_version) && (__FreeBSD_version >= 400000) && \
      !defined(KLD_MODULE)
#   include "opt_inet6.h"
#  endif
#  ifdef INET6
#   define USE_INET6
#  endif
# endif
#else
/*
 * Really, any arch where sizeof(long) != sizeof(int).
 */
# if defined(__alpha__) || defined(__alpha) || defined(_LP64)
typedef unsigned int    u_32_t;
# else
#  if SOLARIS2 >= 6
typedef	uint32_t	u_32_t;
#  else
typedef unsigned int	u_32_t;
#  endif
# endif
#endif /* __NetBSD__ || __OpenBSD__ || __FreeBSD__ || __sgi */

#ifdef	USE_INET6
# if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__)
#  include <netinet/ip6.h>
#  ifdef	_KERNEL
#   include <netinet6/ip6_var.h>
#  endif
typedef	struct ip6_hdr	ip6_t;
# endif
union	i6addr	{
	u_32_t	i6[4];
	struct	in_addr	in4;
	struct	in6_addr in6;
};
#else
union	i6addr	{
	u_32_t	i6[4];
	struct	in_addr	in4;
};
#endif

#define	IP6CMP(a,b)	bcmp((char *)&(a), (char *)&(b), sizeof(a))
#define	IP6EQ(a,b)	(bcmp((char *)&(a), (char *)&(b), sizeof(a)) == 0)
#define	IP6NEQ(a,b)	(bcmp((char *)&(a), (char *)&(b), sizeof(a)) != 0)

#ifndef	MAX
#define	MAX(a,b)	(((a) > (b)) ? (a) : (b))
#endif

/*
 * Security Options for Intenet Protocol (IPSO) as defined in RFC 1108.
 *
 * Basic Option
 *
 * 00000001   -   (Reserved 4)
 * 00111101   -   Top Secret
 * 01011010   -   Secret
 * 10010110   -   Confidential
 * 01100110   -   (Reserved 3)
 * 11001100   -   (Reserved 2)
 * 10101011   -   Unclassified
 * 11110001   -   (Reserved 1)
 */
#define	IPSO_CLASS_RES4		0x01
#define	IPSO_CLASS_TOPS		0x3d
#define	IPSO_CLASS_SECR		0x5a
#define	IPSO_CLASS_CONF		0x96
#define	IPSO_CLASS_RES3		0x66
#define	IPSO_CLASS_RES2		0xcc
#define	IPSO_CLASS_UNCL		0xab
#define	IPSO_CLASS_RES1		0xf1

#define	IPSO_AUTH_GENSER	0x80
#define	IPSO_AUTH_ESI		0x40
#define	IPSO_AUTH_SCI		0x20
#define	IPSO_AUTH_NSA		0x10
#define	IPSO_AUTH_DOE		0x08
#define	IPSO_AUTH_UN		0x06
#define	IPSO_AUTH_FTE		0x01

/*
 * IP option #defines
 */
/*#define	IPOPT_RR	7 */
#define	IPOPT_ZSU	10	/* ZSU */
#define	IPOPT_MTUP	11	/* MTUP */
#define	IPOPT_MTUR	12	/* MTUR */
#define	IPOPT_ENCODE	15	/* ENCODE */
/*#define	IPOPT_TS	68 */
#define	IPOPT_TR	82	/* TR */
/*#define	IPOPT_SECURITY	130 */
/*#define	IPOPT_LSRR	131 */
#define	IPOPT_E_SEC	133	/* E-SEC */
#define	IPOPT_CIPSO	134	/* CIPSO */
/*#define	IPOPT_SATID	136 */
#ifndef	IPOPT_SID
# define	IPOPT_SID	IPOPT_SATID
#endif
/*#define	IPOPT_SSRR	137 */
#define	IPOPT_ADDEXT	147	/* ADDEXT */
#define	IPOPT_VISA	142	/* VISA */
#define	IPOPT_IMITD	144	/* IMITD */
#define	IPOPT_EIP	145	/* EIP */
#define	IPOPT_FINN	205	/* FINN */


#if defined(__FreeBSD__) && (defined(KERNEL) || defined(_KERNEL))
# ifdef IPFILTER_LKM
#  include <osreldate.h>
#  define       ACTUALLY_LKM_NOT_KERNEL
# else
#  include <sys/osreldate.h>
# endif
# if __FreeBSD__ < 3
#  include <machine/spl.h>
# else
#  if __FreeBSD__ == 3
#   if defined(IPFILTER_LKM) && !defined(ACTUALLY_LKM_NOT_KERNEL)
#    define	ACTUALLY_LKM_NOT_KERNEL
#   endif
#  endif
# endif
#endif /* __FreeBSD__ && KERNEL */

/*
 * Build some macros and #defines to enable the same code to compile anywhere
 * Well, that's the idea, anyway :-)
 */
#if !SOLARIS || (SOLARIS2 < 6) || !defined(KERNEL)
# define	ATOMIC_INCL		ATOMIC_INC
# define	ATOMIC_INC64		ATOMIC_INC
# define	ATOMIC_INC32		ATOMIC_INC
# define	ATOMIC_INC16		ATOMIC_INC
# define	ATOMIC_DECL		ATOMIC_DEC
# define	ATOMIC_DEC64		ATOMIC_DEC
# define	ATOMIC_DEC32		ATOMIC_DEC
# define	ATOMIC_DEC16		ATOMIC_DEC
#endif
#ifdef __sgi
# define  hz HZ
# include <sys/ksynch.h>
# define	IPF_LOCK_PL	plhi
# include <sys/sema.h>
#undef kmutex_t
typedef struct {
	lock_t *l;
	int pl;
} kmutex_t;
# undef	MUTEX_INIT
# undef	MUTEX_DESTROY
#endif
#ifdef KERNEL
# if SOLARIS
#  if SOLARIS2 >= 6
#   include <sys/atomic.h>
#   if SOLARIS2 == 6
#    define	ATOMIC_INCL(x)		atomic_add_long((uint32_t*)&(x), 1)
#    define	ATOMIC_DECL(x)		atomic_add_long((uint32_t*)&(x), -1)
#   else
#    define	ATOMIC_INCL(x)		atomic_add_long(&(x), 1)
#    define	ATOMIC_DECL(x)		atomic_add_long(&(x), -1)
#   endif
#   define	ATOMIC_INC64(x)		atomic_add_64((uint64_t*)&(x), 1)
#   define	ATOMIC_INC32(x)		atomic_add_32((uint32_t*)&(x), 1)
#   define	ATOMIC_INC16(x)		atomic_add_16((uint16_t*)&(x), 1)
#   define	ATOMIC_DEC64(x)		atomic_add_64((uint64_t*)&(x), -1)
#   define	ATOMIC_DEC32(x)		atomic_add_32((uint32_t*)&(x), -1)
#   define	ATOMIC_DEC16(x)		atomic_add_16((uint16_t*)&(x), -1)
#  else
#   define	ATOMIC_INC(x)		{ mutex_enter(&ipf_rw); (x)++; \
					  mutex_exit(&ipf_rw); }
#   define	ATOMIC_DEC(x)		{ mutex_enter(&ipf_rw); (x)--; \
					  mutex_exit(&ipf_rw); }
#  endif
#  define	MUTEX_ENTER(x)		mutex_enter(x)
#  if 1
#   define	KRWLOCK_T		krwlock_t
#   define	READ_ENTER(x)		rw_enter(x, RW_READER)
#   define	WRITE_ENTER(x)		rw_enter(x, RW_WRITER)
#   define	RW_UPGRADE(x)		{ if (rw_tryupgrade(x) == 0) { \
					      rw_exit(x); \
					      rw_enter(x, RW_WRITER); } \
					}
#   define	MUTEX_DOWNGRADE(x)	rw_downgrade(x)
#   define	RWLOCK_INIT(x, y, z)	rw_init((x), (y), RW_DRIVER, (z))
#   define	RWLOCK_EXIT(x)		rw_exit(x)
#   define	RW_DESTROY(x)		rw_destroy(x)
#  else
#   define	KRWLOCK_T		kmutex_t
#   define	READ_ENTER(x)		mutex_enter(x)
#   define	WRITE_ENTER(x)		mutex_enter(x)
#   define	MUTEX_DOWNGRADE(x)	;
#   define	RWLOCK_INIT(x, y, z)	mutex_init((x), (y), MUTEX_DRIVER, (z))
#   define	RWLOCK_EXIT(x)		mutex_exit(x)
#   define	RW_DESTROY(x)		mutex_destroy(x)
#  endif
#  define	MUTEX_INIT(x, y, z)	mutex_init((x), (y), MUTEX_DRIVER, (z))
#  define	MUTEX_DESTROY(x)	mutex_destroy(x)
#  define	MUTEX_EXIT(x)	mutex_exit(x)
#  define	MTOD(m,t)	(t)((m)->b_rptr)
#  define	IRCOPY(a,b,c)	copyin((caddr_t)(a), (caddr_t)(b), (c))
#  define	IWCOPY(a,b,c)	copyout((caddr_t)(a), (caddr_t)(b), (c))
#  define	IRCOPYPTR	ircopyptr
#  define	IWCOPYPTR	iwcopyptr
#  define	FREE_MB_T(m)	freemsg(m)
#  define	SPL_NET(x)	;
#  define	SPL_IMP(x)	;
#  undef	SPL_X
#  define	SPL_X(x)	;
#  ifdef sparc
#   define	ntohs(x)	(x)
#   define	ntohl(x)	(x)
#   define	htons(x)	(x)
#   define	htonl(x)	(x)
#  endif /* sparc */
#  define	KMALLOC(a,b)	(a) = (b)kmem_alloc(sizeof(*(a)), KM_NOSLEEP)
#  define	KMALLOCS(a,b,c)	(a) = (b)kmem_alloc((c), KM_NOSLEEP)
#  define	GET_MINOR(x)	getminor(x)
typedef	struct	qif	{
	struct	qif	*qf_next;
	ill_t	*qf_ill;
	kmutex_t	qf_lock;
	void	*qf_iptr;
	void	*qf_optr;
	queue_t	*qf_in;
	queue_t	*qf_out;
	struct	qinit	*qf_wqinfo;
	struct	qinit	*qf_rqinfo;
	struct	qinit	qf_wqinit;
	struct	qinit	qf_rqinit;
	mblk_t	*qf_m;	/* These three fields are for passing data up from */
	queue_t	*qf_q;	/* fr_qin and fr_qout to the packet processing. */
	size_t	qf_off;
	size_t	qf_len;	/* this field is used for in ipfr_fastroute */
	char	qf_name[8];
	/*
	 * in case the ILL has disappeared...
	 */
	size_t	qf_hl;	/* header length */
	int	qf_sap;
} qif_t;
extern	ill_t	*get_unit __P((char *, int));
#  define	GETUNIT(n, v)	get_unit(n, v)
#  define	IFNAME(x)	((ill_t *)x)->ill_name
# else /* SOLARIS */
#  if defined(__sgi)
#   define	ATOMIC_INC(x)		{ MUTEX_ENTER(&ipf_rw); \
					  (x)++; MUTEX_EXIT(&ipf_rw); }
#   define	ATOMIC_DEC(x)		{ MUTEX_ENTER(&ipf_rw); \
					  (x)--; MUTEX_EXIT(&ipf_rw); }
#   define	MUTEX_ENTER(x)		(x)->pl = LOCK((x)->l, IPF_LOCK_PL);
#   define	KRWLOCK_T		kmutex_t
#   define	READ_ENTER(x)		MUTEX_ENTER(x)
#   define	WRITE_ENTER(x)		MUTEX_ENTER(x)
#   define	RW_UPGRADE(x)		;
#   define	MUTEX_DOWNGRADE(x)	;
#   define	RWLOCK_EXIT(x)		MUTEX_EXIT(x)
#   define	MUTEX_EXIT(x)		UNLOCK((x)->l, (x)->pl);
#   define	MUTEX_INIT(x,y,z)	(x)->l = LOCK_ALLOC((uchar_t)-1, IPF_LOCK_PL, (lkinfo_t *)-1, KM_NOSLEEP)
#   define	MUTEX_DESTROY(x)	LOCK_DEALLOC((x)->l)
#  else /* __sgi */
#   define	ATOMIC_INC(x)		(x)++
#   define	ATOMIC_DEC(x)		(x)--
#   define	MUTEX_ENTER(x)		;
#   define	READ_ENTER(x)		;
#   define	WRITE_ENTER(x)		;
#   define	RW_UPGRADE(x)		;
#   define	MUTEX_DOWNGRADE(x)	;
#   define	RWLOCK_EXIT(x)		;
#   define	MUTEX_EXIT(x)		;
#   define	MUTEX_INIT(x,y,z)	;
#   define	MUTEX_DESTROY(x)	;
#  endif /* __sgi */
#  ifndef linux
#   define	FREE_MB_T(m)	m_freem(m)
#   define	MTOD(m,t)	mtod(m,t)
#   define	IRCOPY(a,b,c)	(bcopy((a), (b), (c)), 0)
#   define	IWCOPY(a,b,c)	(bcopy((a), (b), (c)), 0)
#   define	IRCOPYPTR	ircopyptr
#   define	IWCOPYPTR	iwcopyptr
#  endif /* !linux */
# endif /* SOLARIS */

# ifdef sun
#  if !SOLARIS
#   include	<sys/kmem_alloc.h>
#   define	GETUNIT(n, v)	ifunit(n, IFNAMSIZ)
#   define	IFNAME(x)	((struct ifnet *)x)->if_name
#  endif
# else
#  ifndef	linux
#   define	GETUNIT(n, v)	ifunit(n)
#   if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
        (defined(OpenBSD) && (OpenBSD >= 199603))
#    define	IFNAME(x)	((struct ifnet *)x)->if_xname
#   else
#    define	IFNAME(x)	((struct ifnet *)x)->if_name
#   endif
#  endif
# endif /* sun */

# if defined(sun) && !defined(linux) || defined(__sgi)
#  define	UIOMOVE(a,b,c,d)	uiomove((caddr_t)a,b,c,d)
#  define	SLEEP(id, n)	sleep((id), PZERO+1)
#  define	WAKEUP(id)	wakeup(id)
#  define	KFREE(x)	kmem_free((char *)(x), sizeof(*(x)))
#  define	KFREES(x,s)	kmem_free((char *)(x), (s))
#  if !SOLARIS
extern	void	m_copydata __P((struct mbuf *, int, int, caddr_t));
extern	void	m_copyback __P((struct mbuf *, int, int, caddr_t));
#  endif
#  ifdef __sgi
#   include <sys/kmem.h>
#   include <sys/ddi.h>
#   define	KMALLOC(a,b)	(a) = (b)kmem_alloc(sizeof(*(a)), KM_NOSLEEP)
#   define	KMALLOCS(a,b,c)	(a) = (b)kmem_alloc((c), KM_NOSLEEP)
#   define	GET_MINOR(x)	getminor(x)
#  else
#   if !SOLARIS
#    define	KMALLOC(a,b)	(a) = (b)new_kmem_alloc(sizeof(*(a)), \
							KMEM_NOSLEEP)
#    define	KMALLOCS(a,b,c)	(a) = (b)new_kmem_alloc((c), KMEM_NOSLEEP)
#   endif /* SOLARIS */
#  endif /* __sgi */
# endif /* sun && !linux */
# ifndef	GET_MINOR
#  define	GET_MINOR(x)	minor(x)
# endif
# if (BSD >= 199306) || defined(__FreeBSD__)
#  include <vm/vm.h>
#  if !defined(__FreeBSD__) || (defined (__FreeBSD__) && __FreeBSD__>=3)
#   include <vm/vm_extern.h>
#   include <sys/proc.h>
extern	vm_map_t	kmem_map;
#  else /* !__FreeBSD__ || (__FreeBSD__ && __FreeBSD__>=3) */
#   include <vm/vm_kern.h>
#  endif /* !__FreeBSD__ || (__FreeBSD__ && __FreeBSD__>=3) */
#  ifdef	M_PFIL
#   define	KMALLOC(a, b)	MALLOC((a), b, sizeof(*(a)), M_PFIL, M_NOWAIT)
#   define	KMALLOCS(a, b, c)	MALLOC((a), b, (c), M_PFIL, M_NOWAIT)
#   define	KFREE(x)	FREE((x), M_PFIL)
#   define	KFREES(x,s)	FREE((x), M_PFIL)
#  else
#   define	KMALLOC(a, b)	MALLOC((a), b, sizeof(*(a)), M_TEMP, M_NOWAIT)
#   define	KMALLOCS(a, b, c)	MALLOC((a), b, (c), M_TEMP, M_NOWAIT)
#   define	KFREE(x)	FREE((x), M_TEMP)
#   define	KFREES(x,s)	FREE((x), M_TEMP)
#  endif /* M_PFIL */
#  define	UIOMOVE(a,b,c,d)	uiomove(a,b,d)
#  define	SLEEP(id, n)	tsleep((id), PPAUSE|PCATCH, n, 0)
#  define	WAKEUP(id)	wakeup(id)
# endif /* BSD */
# if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199407))
#  define	SPL_NET(x)	x = splsoftnet()
#  define	SPL_X(x)	(void) splx(x)
# else
#  if !SOLARIS && !defined(linux)
#   define	SPL_IMP(x)	x = splimp()
#   define	SPL_NET(x)	x = splnet()
#   define	SPL_X(x)	(void) splx(x)
#  endif
# endif /* NetBSD && (NetBSD <= 1991011) && (NetBSD >= 199407) */
# define	PANIC(x,y)	if (x) panic y
#else /* KERNEL */
# define	SLEEP(x,y)	;
# define	WAKEUP(x)	;
# define	PANIC(x,y)	;
# define	ATOMIC_INC(x)	(x)++
# define	ATOMIC_DEC(x)	(x)--
# define	MUTEX_ENTER(x)	;
# define	READ_ENTER(x)	;
# define	MUTEX_INIT(x,y,z)	;
# define	MUTEX_DESTROY(x)	;
# define	WRITE_ENTER(x)	;
# define	RW_UPGRADE(x)	;
# define	MUTEX_DOWNGRADE(x)	;
# define	RWLOCK_EXIT(x)	;
# define	MUTEX_EXIT(x)	;
# define	SPL_NET(x)	;
# define	SPL_IMP(x)	;
# undef		SPL_X
# define	SPL_X(x)	;
# define	KMALLOC(a,b)	(a) = (b)malloc(sizeof(*a))
# define	KMALLOCS(a,b,c)	(a) = (b)malloc(c)
# define	KFREE(x)	free(x)
# define	KFREES(x,s)	free(x)
# define	GETUNIT(x, v)	get_unit(x,v)
# define	IRCOPY(a,b,c)	(bcopy((a), (b), (c)), 0)
# define	IWCOPY(a,b,c)	(bcopy((a), (b), (c)), 0)
# define	IRCOPYPTR	ircopyptr
# define	IWCOPYPTR	iwcopyptr
#endif /* KERNEL */

#if SOLARIS
typedef mblk_t mb_t;
# if SOLARIS2 >= 7
#  ifdef lint
#   define ALIGN32(ptr)    (ptr ? 0L : 0L)
#   define ALIGN16(ptr)    (ptr ? 0L : 0L)
#  else
#   define ALIGN32(ptr)    (ptr)
#   define ALIGN16(ptr)    (ptr)
#  endif
# endif
#else
# ifdef	linux
#  ifndef kernel
typedef struct mb {
	struct mb *next;
	u_int len;
	u_char *data;
} mb_t;
#  else
typedef struct sk_buff mb_t;
#  endif
# else
typedef struct mbuf mb_t;
# endif
#endif /* SOLARIS */

#if defined(linux) || defined(__sgi)
/*
 * These #ifdef's are here mainly for linux, but who knows, they may
 * not be in other places or maybe one day linux will grow up and some
 * of these will turn up there too.
 */
#ifndef	ICMP_MINLEN
# define	ICMP_MINLEN	8
#endif
#ifndef	ICMP_UNREACH
# define	ICMP_UNREACH	ICMP_DEST_UNREACH
#endif
#ifndef	ICMP_SOURCEQUENCH
# define	ICMP_SOURCEQUENCH	ICMP_SOURCE_QUENCH
#endif
#ifndef	ICMP_TIMXCEED
# define	ICMP_TIMXCEED	ICMP_TIME_EXCEEDED
#endif
#ifndef	ICMP_PARAMPROB
# define	ICMP_PARAMPROB	ICMP_PARAMETERPROB
#endif
#ifndef ICMP_TSTAMP
# define	ICMP_TSTAMP	ICMP_TIMESTAMP
#endif
#ifndef ICMP_TSTAMPREPLY
# define	ICMP_TSTAMPREPLY	ICMP_TIMESTAMPREPLY
#endif
#ifndef ICMP_IREQ
# define	ICMP_IREQ	ICMP_INFO_REQUEST
#endif
#ifndef ICMP_IREQREPLY
# define	ICMP_IREQREPLY	ICMP_INFO_REPLY
#endif
#ifndef	ICMP_MASKREQ
# define	ICMP_MASKREQ	ICMP_ADDRESS
#endif
#ifndef ICMP_MASKREPLY
# define	ICMP_MASKREPLY	ICMP_ADDRESSREPLY
#endif
#ifndef	IPVERSION
# define	IPVERSION	4
#endif
#ifndef	IPOPT_MINOFF
# define	IPOPT_MINOFF	4
#endif
#ifndef	IPOPT_COPIED
# define	IPOPT_COPIED(x)	((x)&0x80)
#endif
#ifndef	IPOPT_EOL
# define	IPOPT_EOL	0
#endif
#ifndef	IPOPT_NOP
# define	IPOPT_NOP	1
#endif
#ifndef	IP_MF
# define	IP_MF	((u_short)0x2000)
#endif
#ifndef	ETHERTYPE_IP
# define	ETHERTYPE_IP	((u_short)0x0800)
#endif
#ifndef	TH_FIN
# define	TH_FIN	0x01
#endif
#ifndef	TH_SYN
# define	TH_SYN	0x02
#endif
#ifndef	TH_RST
# define	TH_RST	0x04
#endif
#ifndef	TH_PUSH
# define	TH_PUSH	0x08
#endif
#ifndef	TH_ACK
# define	TH_ACK	0x10
#endif
#ifndef	TH_URG
# define	TH_URG	0x20
#endif
#ifndef	IPOPT_EOL
# define	IPOPT_EOL	0
#endif
#ifndef	IPOPT_NOP
# define	IPOPT_NOP	1
#endif
#ifndef	IPOPT_RR
# define	IPOPT_RR	7
#endif
#ifndef	IPOPT_TS
# define	IPOPT_TS	68
#endif
#ifndef	IPOPT_SECURITY
# define	IPOPT_SECURITY	130
#endif
#ifndef	IPOPT_LSRR
# define	IPOPT_LSRR	131
#endif
#ifndef	IPOPT_SATID
# define	IPOPT_SATID	136
#endif
#ifndef	IPOPT_SSRR
# define	IPOPT_SSRR	137
#endif
#ifndef	IPOPT_SECUR_UNCLASS
# define	IPOPT_SECUR_UNCLASS	((u_short)0x0000)
#endif
#ifndef	IPOPT_SECUR_CONFID
# define	IPOPT_SECUR_CONFID	((u_short)0xf135)
#endif
#ifndef	IPOPT_SECUR_EFTO
# define	IPOPT_SECUR_EFTO	((u_short)0x789a)
#endif
#ifndef	IPOPT_SECUR_MMMM
# define	IPOPT_SECUR_MMMM	((u_short)0xbc4d)
#endif
#ifndef	IPOPT_SECUR_RESTR
# define	IPOPT_SECUR_RESTR	((u_short)0xaf13)
#endif
#ifndef	IPOPT_SECUR_SECRET
# define	IPOPT_SECUR_SECRET	((u_short)0xd788)
#endif
#ifndef IPOPT_SECUR_TOPSECRET
# define	IPOPT_SECUR_TOPSECRET	((u_short)0x6bc5)
#endif
#ifndef IPOPT_OLEN
# define	IPOPT_OLEN	1
#endif
#endif /* linux || __sgi */

#ifdef	linux
#include <linux/in_systm.h>
/*
 * TCP States
 */
#define	TCPS_CLOSED		0	/* closed */
#define	TCPS_LISTEN		1	/* listening for connection */
#define	TCPS_SYN_SENT		2	/* active, have sent syn */
#define	TCPS_SYN_RECEIVED	3	/* have send and received syn */
/* states < TCPS_ESTABLISHED are those where connections not established */
#define	TCPS_ESTABLISHED	4	/* established */
#define	TCPS_CLOSE_WAIT		5	/* rcvd fin, waiting for close */
/* states > TCPS_CLOSE_WAIT are those where user has closed */
#define	TCPS_FIN_WAIT_1		6	/* have closed, sent fin */
#define	TCPS_CLOSING		7	/* closed xchd FIN; await FIN ACK */
#define	TCPS_LAST_ACK		8	/* had fin and close; await FIN ACK */
/* states > TCPS_CLOSE_WAIT && < TCPS_FIN_WAIT_2 await ACK of FIN */
#define	TCPS_FIN_WAIT_2		9	/* have closed, fin is acked */
#define	TCPS_TIME_WAIT		10	/* in 2*msl quiet wait after close */

/*
 * file flags.
 */
#ifdef WRITE
#define	FWRITE	WRITE
#define	FREAD	READ
#else
#define	FWRITE	_IOC_WRITE
#define	FREAD	_IOC_READ
#endif
/*
 * mbuf related problems.
 */
#define	mtod(m,t)	(t)((m)->data)
#define	m_len		len
#define	m_next		next

#ifdef	IP_DF
#undef	IP_DF
#endif
#define	IP_DF		0x4000

typedef	struct	{
	__u16	th_sport;
	__u16	th_dport;
	__u32	th_seq;
	__u32	th_ack;
# if defined(__i386__) || defined(__MIPSEL__) || defined(__alpha__) ||\
    defined(vax)
	__u8	th_res:4;
	__u8	th_off:4;
#else
	__u8	th_off:4;
	__u8	th_res:4;
#endif
	__u8	th_flags;
	__u16	th_win;
	__u16	th_sum;
	__u16	th_urp;
} tcphdr_t;

typedef	struct	{
	__u16	uh_sport;
	__u16	uh_dport;
	__u16	uh_ulen;
	__u16	uh_sum;
} udphdr_t;

typedef	struct	{
# if defined(__i386__) || defined(__MIPSEL__) || defined(__alpha__) ||\
    defined(vax)
	__u8	ip_hl:4;
	__u8	ip_v:4;
# else
	__u8	ip_v:4;
	__u8	ip_hl:4;
# endif
	__u8	ip_tos;
	__u16	ip_len;
	__u16	ip_id;
	__u16	ip_off;
	__u8	ip_ttl;
	__u8	ip_p;
	__u16	ip_sum;
	struct	in_addr	ip_src;
	struct	in_addr	ip_dst;
} ip_t;

/*
 * Structure of an icmp header.
 */
typedef struct icmp {
	__u8	icmp_type;		/* type of message, see below */
	__u8	icmp_code;		/* type sub code */
	__u16	icmp_cksum;		/* ones complement cksum of struct */
	union {
		__u8	ih_pptr;		/* ICMP_PARAMPROB */
		struct	in_addr	ih_gwaddr;	/* ICMP_REDIRECT */
		struct	ih_idseq {
			__u16	icd_id;
			__u16	icd_seq;
		} ih_idseq;
		int ih_void;
	} icmp_hun;
# define	icmp_pptr	icmp_hun.ih_pptr
# define	icmp_gwaddr	icmp_hun.ih_gwaddr
# define	icmp_id		icmp_hun.ih_idseq.icd_id
# define	icmp_seq	icmp_hun.ih_idseq.icd_seq
# define	icmp_void	icmp_hun.ih_void
	union {
		struct id_ts {
			n_time its_otime;
			n_time its_rtime;
			n_time its_ttime;
		} id_ts;
		struct id_ip  {
			ip_t idi_ip;
			/* options and then 64 bits of data */
		} id_ip;
		u_long	id_mask;
		char	id_data[1];
	} icmp_dun;
# define	icmp_otime	icmp_dun.id_ts.its_otime
# define	icmp_rtime	icmp_dun.id_ts.its_rtime
# define	icmp_ttime	icmp_dun.id_ts.its_ttime
# define	icmp_ip		icmp_dun.id_ip.idi_ip
# define	icmp_mask	icmp_dun.id_mask
# define	icmp_data	icmp_dun.id_data
} icmphdr_t;

# ifndef LINUX_IPOVLY
#  define LINUX_IPOVLY
struct ipovly {
	caddr_t	ih_next, ih_prev;	/* for protocol sequence q's */
	u_char	ih_x1;			/* (unused) */
	u_char	ih_pr;			/* protocol */
	short	ih_len;			/* protocol length */
	struct	in_addr ih_src;		/* source internet address */
	struct	in_addr ih_dst;		/* destination internet address */
};
# endif

typedef struct  {
	__u8	ether_dhost[6];
	__u8	ether_shost[6];
	__u16	ether_type;
} ether_header_t;

typedef	struct	uio	{
	int	uio_resid;
	int	uio_rw;
	caddr_t	uio_buf;
} uio_t;

# define	UIO_READ	0
# define	UIO_WRITE	1
# define	UIOMOVE(a, b, c, d)	uiomove(a,b,c,d)

/*
 * For masking struct ifnet onto struct device
 */
# define	if_name	name

# ifdef	KERNEL
#  define	GETUNIT(x, v)	dev_get(x)
#  define	FREE_MB_T(m)	kfree_skb(m, FREE_WRITE)
#  define	uniqtime	do_gettimeofday
#  undef INT_MAX
#  undef UINT_MAX
#  undef LONG_MAX
#  undef ULONG_MAX
#  include <linux/netdevice.h>
#  define	SPL_X(x)
#  define	SPL_NET(x)
#  define	SPL_IMP(x)
 
#  define	bcmp(a,b,c)	memcmp(a,b,c)
#  define	bcopy(a,b,c)	memcpy(b,a,c)
#  define	bzero(a,c)	memset(a,0,c)

#  define	UNITNAME(n)	dev_get((n))

#  define	KMALLOC(a,b)	(a) = (b)kmalloc(sizeof(*(a)), GFP_ATOMIC)
#  define	KMALLOCS(a,b,c)	(a) = (b)kmalloc((c), GFP_ATOMIC)
#  define	KFREE(x)	kfree_s((x), sizeof(*(x)))
#  define	KFREES(x,s)	kfree_s((x), (s))
#define IRCOPY(const void *a, void *b, size_t c)	{ \
	int error; \

	error = verify_area(VERIFY_READ, a ,c); \
	if (!error) \
		memcpy_fromfs(b, a, c); \
	return error; \
}
static inline int IWCOPY(const void *a, void *b, size_t c)
{
	int error;

	error = verify_area(VERIFY_WRITE, b, c);
	if (!error)
		memcpy_tofs(b, a, c);
	return error;
}
static inline int IRCOPYPTR(const void *a, void *b, size_t c) {
	caddr_t ca;
	int	error;

	error = verify_area(VERIFY_READ, a ,sizeof(ca));
	if (!error) {
		memcpy_fromfs(ca, a, sizeof(ca));
		error = verify_area(VERIFY_READ, ca , c);
		if (!error)
			memcpy_fromfs(b, ca, c);
	}
	return error;
}
static inline int IWCOPYPTR(const void *a, void *b, size_t c) {
	caddr_t ca;
	int	error;


	error = verify_area(VERIFY_READ, b ,sizeof(ca));
	if (!error) {
		memcpy_fromfs(ca, b, sizeof(ca));
		error = verify_area(VERIFY_WRITE, ca, c);
		if (!error)
			memcpy_tofs(ca, a, c);
	}
	return error;
}
# else
#  define	__KERNEL__
#  undef INT_MAX
#  undef UINT_MAX
#  undef LONG_MAX
#  undef ULONG_MAX
#  define	s8 __s8
#  define	u8 __u8
#  define	s16 __s16
#  define	u16 __u16
#  define	s32 __s32
#  define	u32 __u32
#  include <linux/netdevice.h>
#  undef	__KERNEL__
# endif
# define	ifnet	device
#else
typedef	struct	tcphdr	tcphdr_t;
typedef	struct	udphdr	udphdr_t;
typedef	struct	icmp	icmphdr_t;
typedef	struct	ip	ip_t;
typedef	struct	ether_header	ether_header_t;
#endif /* linux */
typedef	struct	tcpiphdr	tcpiphdr_t;

#if defined(hpux) || defined(linux)
struct	ether_addr	{
	char	ether_addr_octet[6];
};
#endif

/*
 * XXX - This is one of those *awful* hacks which nobody likes
 */
#ifdef	ultrix
#define	A_A
#else
#define	A_A	&
#endif

#ifndef	ICMP_ROUTERADVERT
# define	ICMP_ROUTERADVERT	9
#endif
#ifndef	ICMP_ROUTERSOLICIT
# define	ICMP_ROUTERSOLICIT	10
#endif
#undef	ICMP_MAX_UNREACH
#define	ICMP_MAX_UNREACH	14
#undef	ICMP_MAXTYPE
#define	ICMP_MAXTYPE		18
/*
 * ICMP error replies have an IP header (20 bytes), 8 bytes of ICMP data,
 * another IP header and then 64 bits of data, totalling 56.  Of course,
 * the last 64 bits is dependant on that being available.
 */
#define	ICMPERR_ICMPHLEN	8
#define	ICMPERR_IPICMPHLEN	(20 + 8)
#define	ICMPERR_MINPKTLEN	(20 + 8 + 20)
#define	ICMPERR_MAXPKTLEN	(20 + 8 + 20 + 8)
#define	ICMP6ERR_MINPKTLEN	(40 + 8)
#define	ICMP6ERR_IPICMPHLEN	(40 + 8 + 40)

/*
 * ECN is a new addition to TCP - RFC 2481
 */
#ifndef TH_ECN
# define	TH_ECN	0x40
#endif
#ifndef TH_CWR
# define	TH_CWR	0x80
#endif
#define	TH_ECNALL	(TH_ECN|TH_CWR)

#define	TCPF_ALL (TH_FIN|TH_SYN|TH_RST|TH_PUSH|TH_ACK|TH_URG|TH_ECN|TH_CWR)

#endif	/* __IP_COMPAT_H__ */
@


1.21
log
@IPfilter 3.4.17; kjell@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.20 2001/01/30 04:22:24 kjell Exp $	*/
@


1.20
log
@change ip_compat.h to ip_fil_compat.h for clarity. Impending ipf merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (C) 1993-2000 by Darren Reed.
d11 1
a11 1
 * $IPFilter: ip_compat.h,v 2.26.2.9 2001/01/14 14:58:01 darrenr Exp $
d513 1
a513 1
# if defined(NetBSD) && NetBSD <= 1991011 && NetBSD >= 199407
d522 1
a522 1
# endif /* NetBSD && NetBSD <= 1991011 && NetBSD >= 199407 */
@


1.19
log
@IPF 3.4.15. (IPv6 not working yet).

Note: before building the userland part you need to do make includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.18 2000/08/10 05:50:26 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d11 1
a11 1
 * $IPFilter: ip_compat.h,v 2.1.2.6 2000/04/25 16:21:11 darrenr Exp $
d32 5
d116 3
a118 1
#  define	ipif_local_addr		ipif_lcl_addr
d120 3
a122 1
#  define	V4_PART_OF_V6(v6)	v6.s6_addr32[3]
d131 4
d148 1
d155 12
d174 5
a178 1
typedef unsigned long   u_32_t;
d182 24
d268 6
d276 6
a281 3
# endif
# if defined(IPFILTER_LKM) && !defined(ACTUALLY_LKM_NOT_KERNEL)
#  define	ACTUALLY_LKM_NOT_KERNEL
d289 23
d314 17
a330 1
#  define	ATOMIC_INC(x)		{ mutex_enter(&ipf_rw); (x)++; \
d332 1
a332 1
#  define	ATOMIC_DEC(x)		{ mutex_enter(&ipf_rw); (x)--; \
d334 1
d357 2
d361 4
a364 2
#  define	IRCOPY(a,b,c)	copyin((a), (b), (c))
#  define	IWCOPY(a,b,c)	copyout((a), (b), (c))
d400 1
d402 2
a403 2
extern	ill_t	*get_unit __P((char *));
#  define	GETUNIT(n)	get_unit((n))
a406 9
#   define  hz HZ
#   include <sys/ksynch.h>
#   define	IPF_LOCK_PL	plhi
#   include <sys/sema.h>
#undef kmutex_t
typedef struct {
	lock_t *l;
	int pl;
} kmutex_t;
d417 4
a420 2
#   define	RWLOCK_EXIT(x)	MUTEX_EXIT(x)
#   define	MUTEX_EXIT(x)	UNLOCK((x)->l, (x)->pl);
d425 3
a427 3
#   define	READ_ENTER(x)	;
#   define	WRITE_ENTER(x)	;
#   define	RW_UPGRADE(x)	;
d429 4
a432 2
#   define	RWLOCK_EXIT(x)	;
#   define	MUTEX_EXIT(x)	;
d437 4
a440 2
#   define	IRCOPY(a,b,c)	bcopy((a), (b), (c))
#   define	IWCOPY(a,b,c)	bcopy((a), (b), (c))
d447 1
a447 1
#   define	GETUNIT(n)	ifunit((n), IFNAMSIZ)
d452 1
a452 1
#   define	GETUNIT(n)	ifunit((n))
d454 1
a454 1
	(defined(OpenBSD) && (OpenBSD >= 199603))
d532 2
d547 5
a551 3
# define	GETUNIT(x)	get_unit(x)
# define	IRCOPY(a,b,c)	bcopy((a), (b), (c))
# define	IWCOPY(a,b,c)	bcopy((a), (b), (c))
d873 1
a873 1
#  define	GETUNIT(x)	dev_get(x)
d895 44
a938 10
#  define	IRCOPY(a,b,c)	{ \
				 error = verify_area(VERIFY_READ, (a) ,(c)); \
				 if (!error) \
					memcpy_fromfs((b), (a), (c)); \
				}
#  define	IWCOPY(a,b,c)	{ \
				 error = verify_area(VERIFY_WRITE, (b), (c)); \
				 if (!error) \
					memcpy_tofs((b), (a), (c)); \
				}
d985 4
d998 15
@


1.18
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.17 2000/06/16 21:47:16 provos Exp $	*/
@


1.17
log
@take MIN/MAX from param.h, okay theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.16 2000/05/01 06:16:47 kjell Exp $	*/
d151 4
@


1.16
log
@Update to ipfilter 3.3.13. This should be the last of the 3.3.x releases.
This patch fixes mostly ICMP timeout problems, as the ftp proxy
changes were imported previously.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.15 2000/04/05 05:35:27 kjell Exp $	*/
a150 4

#ifndef	MAX
#define	MAX(a,b)	(((a) > (b)) ? (a) : (b))
#endif
@


1.15
log
@Update to ipf 3.3.12. Most fixes relate to hardening of
in-kernel ftp proxy. See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d11 1
a11 1
 * $IPFilter: ip_compat.h,v 2.1.2.5 2000/02/15 08:02:43 darrenr Exp $
d213 1
a213 1
#if defined(__FreeBSD__) && defined(KERNEL)
@


1.14
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@@


1.13
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@@


1.12
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@d11 1
a11 1
 * $IPFilter: ip_compat.h,v 2.1.2.3 1999/11/18 13:55:26 darrenr Exp $
d95 3
d103 3
d111 3
a113 3
#  include <netinet/ip6.h>
#  include <inet/ip6.h>
#  define	ipif_local_addr	ipif_lcl_addr
d296 1
d343 1
d348 6
@


1.12.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.13 2000/02/16 22:34:18 kjell Exp $	*/
d11 1
a11 1
 * $IPFilter: ip_compat.h,v 2.1.2.5 2000/02/15 08:02:43 darrenr Exp $
a94 3
#  if SOLARIS2 >= 8
#   include <netinet/ip6.h>
#  endif
a99 3
#  if SOLARIS2 >= 8
#   include <netinet/ip6.h>
#  endif
d105 3
a107 3
#  define	ipif_local_addr		ipif_lcl_addr
/* Only defined in private include file */
#  define	V4_PART_OF_V6(v6)	v6.s6_addr32[3]
a289 1
#  define	IFNAME(x)	((ill_t *)x)->ill_name
a335 1
#   define	IFNAME(x)	((struct ifnet *)x)->if_name
a339 6
#   if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))
#    define	IFNAME(x)	((struct ifnet *)x)->if_xname
#   else
#    define	IFNAME(x)	((struct ifnet *)x)->if_name
#   endif
@


1.12.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.20 2001/01/30 04:22:24 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-2000 by Darren Reed.
d11 1
a11 1
 * $IPFilter: ip_compat.h,v 2.26.2.9 2001/01/14 14:58:01 darrenr Exp $
a31 5
#if SOLARIS2 >= 8
# ifndef	USE_INET6
#  define	USE_INET6
# endif
#endif
d111 1
a111 3
#  include <inet/ip_if.h>
#  include <netinet/ip6.h>
#  define	ipif_local_addr	ipif_lcl_addr
d113 1
a113 3
#  ifndef	V4_PART_OF_V6
#   define	V4_PART_OF_V6(v6)	v6.s6_addr32[3]
#  endif
a121 4
#if defined(__FreeBSD__) && (__FreeBSD__ >= 5) && defined(_KERNEL)
# include <machine/in_cksum.h>
#endif

a134 1

a140 12
# if defined(_KERNEL) && !defined(IPFILTER_LKM)
#  if defined(__NetBSD_Version__) && (__NetBSD_Version__ >= 104110000)
#   include "opt_inet.h"
#  endif
#  if defined(__FreeBSD_version) && (__FreeBSD_version >= 400000) && \
      !defined(KLD_MODULE)
#   include "opt_inet6.h"
#  endif
#  ifdef INET6
#   define USE_INET6
#  endif
# endif
d148 1
a148 5
#  if SOLARIS2 >= 6
typedef	uint32_t	u_32_t;
#  else
typedef unsigned int	u_32_t;
#  endif
a151 24
#ifdef	USE_INET6
# if defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__)
#  include <netinet/ip6.h>
#  ifdef	_KERNEL
#   include <netinet6/ip6_var.h>
#  endif
typedef	struct ip6_hdr	ip6_t;
# endif
union	i6addr	{
	u_32_t	i6[4];
	struct	in_addr	in4;
	struct	in6_addr in6;
};
#else
union	i6addr	{
	u_32_t	i6[4];
	struct	in_addr	in4;
};
#endif

#define	IP6CMP(a,b)	bcmp((char *)&(a), (char *)&(b), sizeof(a))
#define	IP6EQ(a,b)	(bcmp((char *)&(a), (char *)&(b), sizeof(a)) == 0)
#define	IP6NEQ(a,b)	(bcmp((char *)&(a), (char *)&(b), sizeof(a)) != 0)

d213 1
a213 7
#if defined(__FreeBSD__) && (defined(KERNEL) || defined(_KERNEL))
# ifdef IPFILTER_LKM
#  include <osreldate.h>
#  define       ACTUALLY_LKM_NOT_KERNEL
# else
#  include <sys/osreldate.h>
# endif
d216 3
a218 6
# else
#  if __FreeBSD__ == 3
#   if defined(IPFILTER_LKM) && !defined(ACTUALLY_LKM_NOT_KERNEL)
#    define	ACTUALLY_LKM_NOT_KERNEL
#   endif
#  endif
a225 23
#if !SOLARIS || (SOLARIS2 < 6) || !defined(KERNEL)
# define	ATOMIC_INCL		ATOMIC_INC
# define	ATOMIC_INC64		ATOMIC_INC
# define	ATOMIC_INC32		ATOMIC_INC
# define	ATOMIC_INC16		ATOMIC_INC
# define	ATOMIC_DECL		ATOMIC_DEC
# define	ATOMIC_DEC64		ATOMIC_DEC
# define	ATOMIC_DEC32		ATOMIC_DEC
# define	ATOMIC_DEC16		ATOMIC_DEC
#endif
#ifdef __sgi
# define  hz HZ
# include <sys/ksynch.h>
# define	IPF_LOCK_PL	plhi
# include <sys/sema.h>
#undef kmutex_t
typedef struct {
	lock_t *l;
	int pl;
} kmutex_t;
# undef	MUTEX_INIT
# undef	MUTEX_DESTROY
#endif
d228 1
a228 17
#  if SOLARIS2 >= 6
#   include <sys/atomic.h>
#   if SOLARIS2 == 6
#    define	ATOMIC_INCL(x)		atomic_add_long((uint32_t*)&(x), 1)
#    define	ATOMIC_DECL(x)		atomic_add_long((uint32_t*)&(x), -1)
#   else
#    define	ATOMIC_INCL(x)		atomic_add_long(&(x), 1)
#    define	ATOMIC_DECL(x)		atomic_add_long(&(x), -1)
#   endif
#   define	ATOMIC_INC64(x)		atomic_add_64((uint64_t*)&(x), 1)
#   define	ATOMIC_INC32(x)		atomic_add_32((uint32_t*)&(x), 1)
#   define	ATOMIC_INC16(x)		atomic_add_16((uint16_t*)&(x), 1)
#   define	ATOMIC_DEC64(x)		atomic_add_64((uint64_t*)&(x), -1)
#   define	ATOMIC_DEC32(x)		atomic_add_32((uint32_t*)&(x), -1)
#   define	ATOMIC_DEC16(x)		atomic_add_16((uint16_t*)&(x), -1)
#  else
#   define	ATOMIC_INC(x)		{ mutex_enter(&ipf_rw); (x)++; \
d230 1
a230 1
#   define	ATOMIC_DEC(x)		{ mutex_enter(&ipf_rw); (x)--; \
a231 1
#  endif
a253 2
#  define	MUTEX_INIT(x, y, z)	mutex_init((x), (y), MUTEX_DRIVER, (z))
#  define	MUTEX_DESTROY(x)	mutex_destroy(x)
d256 2
a257 4
#  define	IRCOPY(a,b,c)	copyin((caddr_t)(a), (caddr_t)(b), (c))
#  define	IWCOPY(a,b,c)	copyout((caddr_t)(a), (caddr_t)(b), (c))
#  define	IRCOPYPTR	ircopyptr
#  define	IWCOPYPTR	iwcopyptr
a292 1
	int	qf_sap;
d294 2
a295 2
extern	ill_t	*get_unit __P((char *, int));
#  define	GETUNIT(n, v)	get_unit(n, v)
d299 9
d318 2
a319 4
#   define	RWLOCK_EXIT(x)		MUTEX_EXIT(x)
#   define	MUTEX_EXIT(x)		UNLOCK((x)->l, (x)->pl);
#   define	MUTEX_INIT(x,y,z)	(x)->l = LOCK_ALLOC((uchar_t)-1, IPF_LOCK_PL, (lkinfo_t *)-1, KM_NOSLEEP)
#   define	MUTEX_DESTROY(x)	LOCK_DEALLOC((x)->l)
d324 3
a326 3
#   define	READ_ENTER(x)		;
#   define	WRITE_ENTER(x)		;
#   define	RW_UPGRADE(x)		;
d328 2
a329 4
#   define	RWLOCK_EXIT(x)		;
#   define	MUTEX_EXIT(x)		;
#   define	MUTEX_INIT(x,y,z)	;
#   define	MUTEX_DESTROY(x)	;
d334 2
a335 4
#   define	IRCOPY(a,b,c)	(bcopy((a), (b), (c)), 0)
#   define	IWCOPY(a,b,c)	(bcopy((a), (b), (c)), 0)
#   define	IRCOPYPTR	ircopyptr
#   define	IWCOPYPTR	iwcopyptr
d342 1
a342 1
#   define	GETUNIT(n, v)	ifunit(n, IFNAMSIZ)
d347 1
a347 1
#   define	GETUNIT(n, v)	ifunit(n)
d349 1
a349 1
        (defined(OpenBSD) && (OpenBSD >= 199603))
a426 2
# define	MUTEX_INIT(x,y,z)	;
# define	MUTEX_DESTROY(x)	;
d440 3
a442 5
# define	GETUNIT(x, v)	get_unit(x,v)
# define	IRCOPY(a,b,c)	(bcopy((a), (b), (c)), 0)
# define	IWCOPY(a,b,c)	(bcopy((a), (b), (c)), 0)
# define	IRCOPYPTR	ircopyptr
# define	IWCOPYPTR	iwcopyptr
d764 1
a764 1
#  define	GETUNIT(x, v)	dev_get(x)
d786 10
a795 44
#define IRCOPY(const void *a, void *b, size_t c)	{ \
	int error; \

	error = verify_area(VERIFY_READ, a ,c); \
	if (!error) \
		memcpy_fromfs(b, a, c); \
	return error; \
}
static inline int IWCOPY(const void *a, void *b, size_t c)
{
	int error;

	error = verify_area(VERIFY_WRITE, b, c);
	if (!error)
		memcpy_tofs(b, a, c);
	return error;
}
static inline int IRCOPYPTR(const void *a, void *b, size_t c) {
	caddr_t ca;
	int	error;

	error = verify_area(VERIFY_READ, a ,sizeof(ca));
	if (!error) {
		memcpy_fromfs(ca, a, sizeof(ca));
		error = verify_area(VERIFY_READ, ca , c);
		if (!error)
			memcpy_fromfs(b, ca, c);
	}
	return error;
}
static inline int IWCOPYPTR(const void *a, void *b, size_t c) {
	caddr_t ca;
	int	error;


	error = verify_area(VERIFY_READ, b ,sizeof(ca));
	if (!error) {
		memcpy_fromfs(ca, b, sizeof(ca));
		error = verify_area(VERIFY_WRITE, ca, c);
		if (!error)
			memcpy_tofs(ca, a, c);
	}
	return error;
}
a841 4
#undef	ICMP_MAX_UNREACH
#define	ICMP_MAX_UNREACH	14
#undef	ICMP_MAXTYPE
#define	ICMP_MAXTYPE		18
a850 15
#define	ICMP6ERR_MINPKTLEN	(40 + 8)
#define	ICMP6ERR_IPICMPHLEN	(40 + 8 + 40)

/*
 * ECN is a new addition to TCP - RFC 2481
 */
#ifndef TH_ECN
# define	TH_ECN	0x40
#endif
#ifndef TH_CWR
# define	TH_CWR	0x80
#endif
#define	TH_ECNALL	(TH_ECN|TH_CWR)

#define	TCPF_ALL (TH_FIN|TH_SYN|TH_RST|TH_PUSH|TH_ACK|TH_URG|TH_ECN|TH_CWR)
@


1.12.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.12.2.2 2001/05/14 22:40:10 niklas Exp $	*/
@


1.11
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d11 1
a11 1
 * $Id: ip_compat.h,v 2.1.2.3 1999/11/18 13:55:26 darrenr Exp $
@


1.10
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_fil_compat.h,v 1.9 1998/09/15 09:51:18 pattonme Exp $ */
d10 1
a10 1
 * $Id: ip_fil_compat.h,v 1.1 1999/01/28 23:17:40 cgrant Exp $
a20 1
#  define	const
d23 4
d79 1
d103 9
d138 1
a138 1
# if defined(__alpha__) || defined(__alpha)
d230 4
d262 2
a263 1
#  define	KMALLOC(a,b,c)	(a) = (b)kmem_alloc((c), KM_NOSLEEP)
d279 2
a280 2
	int	qf_off;
	int	qf_len;	/* this field is used for in ipfr_fastroute */
d285 1
a285 1
	int	qf_hl;	/* header length */
d291 1
d308 1
d318 1
d355 2
a356 1
#   define	KMALLOC(a,b,c)	(a) = (b)kmem_alloc((c), KM_NOSLEEP)
d360 3
a362 1
#    define	KMALLOC(a,b,c)	(a) = (b)new_kmem_alloc((c), KMEM_NOSLEEP)
d379 2
a380 1
#   define	KMALLOC(a, b, c)	MALLOC((a), b, (c), M_PFIL, M_NOWAIT)
d384 2
a385 1
#   define	KMALLOC(a, b, c)	MALLOC((a), b, (c), M_TEMP, M_NOWAIT)
d413 1
d421 2
a422 1
# define	KMALLOC(a,b,c)	(a) = (b)malloc(c)
d432 9
d659 1
a660 1
	__u8	ip_v:4;
d767 2
a768 1
#  define	KMALLOC(a,b,c)	(a) = (b)kmalloc((c), GFP_ATOMIC)
d832 4
a835 2
#define       ICMPERR_MINPKTLEN       (20 + 8 + 20)
#define       ICMPERR_MAXPKTLEN       (20 + 8 + 20 + 8)
@


1.9
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*       $OpenBSD: ip_fil_compat.h,v 1.8 1998/02/17 01:39:03 dgregor Exp $ */
d3 1
a3 1
 * Copyright (C) 1993-1997 by Darren Reed.
d10 1
a10 1
 * $Id$
d29 4
a32 1
#if defined(_KERNEL) && !defined(KERNEL)
a33 2
#endif
#if defined(KERNEL) && !defined(_KERNEL)
a34 2
#endif
#if!defined(__KERNEL__) && defined(KERNEL)
d40 1
a40 1
# if !defined(_KERNEL)
d47 4
d87 1
a87 1
# ifndef	_KERNEL
d213 17
a229 4
#  define	READ_ENTER(x)		rw_enter(x, RW_READER)
#  define	WRITE_ENTER(x)		rw_enter(x, RW_WRITER)
#  define	MUTEX_DOWNGRADE(x)	rw_downgrade(x)
#  define	RWLOCK_EXIT(x)	rw_exit(x)
d281 1
a281 1
#  define	ATOMIC_INC(x)		{ MUTEX_ENTER(&ipf_rw); \
d283 1
a283 1
#  define	ATOMIC_DEC(x)		{ MUTEX_ENTER(&ipf_rw); \
d286 1
d406 7
d414 1
d549 1
d571 1
d574 4
d585 4
a588 1
#define	IP_DF		0x8000
d640 3
a642 3
	u_char	icmp_type;		/* type of message, see below */
	u_char	icmp_code;		/* type sub code */
	u_short	icmp_cksum;		/* ones complement cksum of struct */
d644 5
a648 5
		u_char ih_pptr;			/* ICMP_PARAMPROB */
		struct in_addr ih_gwaddr;	/* ICMP_REDIRECT */
		struct ih_idseq {
			n_short	icd_id;
			n_short	icd_seq;
d789 7
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*       $OpenBSD$       */
d10 1
a10 1
 * $Id: ip_fil_compat.h,v 1.7 1998/01/26 04:10:40 dgregor Exp $
d127 1
a127 1
#endif /* __NetBSD__ || __OpenBSD__ || __FreeBSD__ */
d205 9
a213 1
#  define	MUTEX_ENTER(x)	mutex_enter(x)
d265 9
a273 1
#   define	MUTEX_ENTER(x)	(x)->pl = LOCK((x)->l, IPF_LOCK_PL);
d276 7
a282 1
#   define	MUTEX_ENTER(x)	;
d365 2
d368 4
d401 3
d715 6
d755 1
@


1.7
log
@IPF 3.2.3
@
text
@d1 1
d10 1
a10 1
 * $Id: ip_compat.h,v 2.0.2.31.2.8 1997/12/02 13:42:52 darrenr Exp $
@


1.6
log
@merge in 3.1.11
@
text
@a0 1
/*	$OpenBSD: ip_fil_compat.h,v 1.5 1997/02/13 05:54:16 kstailey Exp $	*/
d2 1
a2 1
 * (C)opyright 1993, 1994, 1995 by Darren Reed.
d9 1
a9 1
 * $DRId: ip_compat.h,v 2.0.1.4 1997/02/04 14:24:25 darrenr Exp $
d12 11
a22 2
#ifndef	__IP_FIL_COMPAT_H_
#define	__IP_FIL_COMPAT_H__
d27 43
d71 25
a95 2
#define	MTYPE(m)	((m)->b_datap->db_type)
#endif
d102 26
d188 10
d202 1
a202 1
#ifdef _KERNEL
d209 53
a261 3
# else
#  define	MUTEX_ENTER(x)	;
#  define	MUTEX_EXIT(x)	;
d263 1
d267 1
a267 1
#  endif
d271 1
a271 3
#  if defined(__svr4__) || defined(__SVR4)
#   define	GETUNIT(n)	get_unit((n))
#  else
d276 3
a278 1
#  define	GETUNIT(n)	ifunit((n))
d281 2
a282 2
# if defined(sun) && !defined(linux)
#  define	UIOMOVE(a,b,c,d)	uiomove(a,b,c,d)
d284 1
d286 9
a294 31
#  if SOLARIS
typedef	struct	qif	{
	struct	qif	*qf_next;
	ill_t	*qf_ill;
	kmutex_t	qf_lock;
	void	*qf_iptr;
	void	*qf_optr;
	queue_t	*qf_in;
	queue_t	*qf_out;
	void	*qf_wqinfo;
	void	*qf_rqinfo;
	int	(*qf_inp)();
	int	(*qf_outp)();
	mblk_t	*qf_m;
	int	qf_len;
	char	qf_name[8];
	/*
	 * in case the ILL has disappeared...
	 */
	int	qf_hl;	/* header length */
} qif_t;
#   define	SPLNET(x)	;
#   undef	SPLX
#   define	SPLX(x)		;
#   ifdef	sparc
#    define	ntohs(x)	(x)
#    define	ntohl(x)	(x)
#    define	htons(x)	(x)
#    define	htonl(x)	(x)
#   endif
#   define	KMALLOC(x)	kmem_alloc((x), KM_NOSLEEP)
d297 4
a300 2
#   define	KMALLOC(x)	new_kmem_alloc((x), KMEM_NOSLEEP)
#  endif /* __svr4__ */
d305 1
a305 1
# if BSD >= 199306 || defined(__FreeBSD__)
d307 1
a307 1
#  if !defined(__FreeBSD__)
d311 1
a311 1
#  else
d313 1
a313 6
#  endif /* __FreeBSD__ */
/*
** #  define	KMALLOC(x)	kmem_alloc(kmem_map, (x))
** #  define	KFREE(x)	kmem_free(kmem_map, (vm_offset_t)(x), \
					  sizeof(*(x)))
*/
d315 1
a315 1
#   define	KMALLOC(x)	malloc((x), M_PFIL, M_NOWAIT)
d317 1
d319 1
a319 1
#   define	KMALLOC(x)	malloc((x), M_TEMP, M_NOWAIT)
d321 2
a322 1
#  endif
d325 1
d327 3
a329 2
# if defined(NetBSD1_0) && (NetBSD1_0 > 1)
#  define	SPLNET(x)	x = splsoftnet()
d331 4
a334 3
#  if !SOLARIS
#   define	SPLNET(x)	x = splnet()
#   define	SPLX(x)		(void) splx(x)
d336 22
a357 1
# endif
d359 4
a362 10
# ifndef	linux
#  define	MUTEX_ENTER(x)	;
#  define	MUTEX_EXIT(x)	;
#  define	SPLNET(x)	;
#  define	SPLX(x)		;
#  define	KMALLOC(x)	malloc(x)
#  define	KFREE(x)	free(x)
#  define	GETUNIT(x)	(x)
#  define	IRCOPY(a,b,c)	bcopy((a), (b), (c))
#  define	IWCOPY(a,b,c)	bcopy((a), (b), (c))
d364 1
a364 1
#endif /* KERNEL */
d366 7
a372 1
#ifdef linux
d374 2
d377 2
d380 2
d383 41
a423 1

d425 2
d428 2
d431 2
d434 2
d437 2
d440 83
d529 8
a536 1
	__u8	th_x;
d547 1
a547 1
	__u16	uh_sun;
d573 1
a573 1
struct icmp {
d610 1
a610 1
};
d612 2
d622 1
d624 15
a638 2
# define	SPLX(x)		(void)
# define	SPLNET(x)	(void)
d640 4
a643 5
# define	bcopy(a,b,c)	memmove(b,a,c)
# define	bcmp(a,b,c)	memcmp(a,b,c)

# define	UNITNAME(n)	dev_get((n))
# define	ifnet	device
d645 24
a668 5
# define	KMALLOC(x)	kmalloc((x), GFP_ATOMIC)
# define	KFREE(x)	kfree_s((x), sizeof(*(x)))
# define	IRCOPY(a,b,c)	{ \
				 error = verify_area(VERIFY_READ, \
						     (b) ,sizeof((b))); \
d672 2
a673 3
# define	IWCOPY(a,b,c)	{ \
				 error = verify_area(VERIFY_WRITE, \
						     (b) ,sizeof((b))); \
d677 10
d692 1
d694 1
d696 22
a717 1
#endif	/* __IP__FIL_COMPAT_H__ */
@


1.5
log
@back out prev. change
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.4 1997/02/13 05:09:33 kstailey Exp $	*/
d10 1
a10 1
 * Id: ip_compat.h,v 2.0.1.4 1997/02/04 14:24:25 darrenr Exp
a15 4
#ifdef _KERNEL			/* XXX */
#define IPFILTER_LOG
#endif /* _KERNEL */

d187 1
a187 1
# if (defined(NetBSD1_0) && (NetBSD1_0 > 1))
@


1.4
log
@make SPLNET() do splsoftnet()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_fil_compat.h,v 1.3 1997/02/11 22:23:18 kstailey Exp $	*/
d195 1
a195 5
#   ifdef __OpenBSD__
#    define	SPLNET(x)	x = splsoftnet()
#   else
#    define	SPLNET(x)	x = splnet()
#   endif /* __OpenBSD__ */
@


1.3
log
@IPF 1.3.7
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a91 1

d191 1
a191 1
# if defined(NetBSD1_0) && (NetBSD1_0 > 1)
d195 5
a199 1
#   define	SPLNET(x)	x = splnet()
@


1.2
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d1 1
d9 2
a10 2
 * @@(#)ip_fil_compat.h	1.8 1/14/96
 * $OpenBSD: ip_fil_compat.h,v 1.1 1996/07/18 05:01:00 dm Exp $
d13 6
a18 2
#ifndef	__IP_COMPAT_H_
#define	__IP_COMPAT_H__
d23 3
d36 61
a139 1
	char	qf_name[8];
d142 3
d159 1
a159 1
#   define	KMALLOC(x)	kmem_alloc((x), KM_SLEEP)
d162 1
a162 1
#   define	KMALLOC(x)	new_kmem_alloc((x), KMEM_SLEEP)
d177 3
a179 2
#  define	KMALLOC(x)	kmem_alloc(kmem_map, (x))
#  define	KFREE(x)	kmem_free(kmem_map, (vm_offset_t)(x), \
d181 8
d201 11
a211 9
# define	MUTEX_ENTER(x)	;
# define	MUTEX_EXIT(x)	;
# define	SPLNET(x)	;
# define	SPLX(x)		;
# define	KMALLOC(x)	malloc(x)
# define	KFREE(x)	free(x)
# define	GETUNIT(x)	(x)
# define	IRCOPY(a,b,c)	bcopy((a), (b), (c))
# define	IWCOPY(a,b,c)	bcopy((a), (b), (c))
a218 3
# define	icmp	icmphdr
# define	icmp_type	type
# define	icmp_code	code
d262 2
a263 2
	__u32	ip_src;
	__u32	ip_dst;
d266 51
d343 1
d347 1
a347 1
#endif	/* __IP_COMPAT_H__ */
@


1.1
log
@ipfilter 3.1.0
@
text
@d9 1
a9 1
 * $Id: ip_fil_compat.h,v 1.1.1.1 1996/06/23 07:27:15 darrenr Exp $
@
