head	1.27;
access;
symbols
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	UBC_SYNC_A:1.27
	UBC_SYNC_B:1.27
	SMP:1.27.0.2
	kame_19991208:1.26
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.27
date	2000.01.27.08.09.09;	author angelos;	state dead;
branches;
next	1.26;

1.26
date	99.12.06.07.14.35;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	99.10.29.02.10.01;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	99.06.30.17.23.59;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.05.16.21.48.32;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.03.24.17.00.45;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.02.25.20.14.38;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	99.02.24.23.45.48;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	99.02.24.22.33.00;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	99.01.11.22.52.09;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.11.25.09.56.50;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	98.11.25.02.01.26;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	98.06.03.09.50.19;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	98.05.18.21.10.34;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	98.03.18.10.16.27;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	98.02.22.01.23.31;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	98.01.21.18.43.33;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.11.15.00.07.07;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.11.07.08.27.29;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.11.04.09.11.02;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.10.02.02.31.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.09.28.22.57.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.27.23.30.35;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.07.24.01.37.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.18.18.09.53;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.07.14.08.48.45;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	97.07.11.23.37.55;	author provos;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@/*	$OpenBSD: ip_ah_old.c,v 1.26 1999/12/06 07:14:35 angelos Exp $	*/

/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 *	
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * Authentication Header Processing
 * Per RFCs 1828/1852 (Metzger & Simpson)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <machine/cpu.h>

#include <net/if.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>

#include <sys/socketvar.h>
#include <net/raw_cb.h>

#include <netinet/ip_ipsp.h>
#include <netinet/ip_ah.h>
#include <net/pfkeyv2.h>

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

extern struct auth_hash auth_hash_key_md5;
extern struct auth_hash auth_hash_key_sha1;

struct auth_hash *ah_old_hash[] = {
    &auth_hash_key_md5,
    &auth_hash_key_sha1,
};

/*
 * ah_old_attach() is called from the transformation initialization code.
 */

int
ah_old_attach()
{
    return 0;
}

/*
 * ah_old_init() is called when an SPI is being set up.
 */

int
ah_old_init(struct tdb *tdbp, struct xformsw *xsp, struct ipsecinit *ii)
{
    struct auth_hash *thash = NULL;
    int i;

    /* Check whether the hash algorithm is supported */
    for (i = sizeof(ah_old_hash) / sizeof(ah_old_hash[0]) - 1; i >= 0; i--)
      if (ii->ii_authalg == ah_old_hash[i]->type)
	      break;

    if (i < 0) 
    {
	DPRINTF(("ah_old_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
	return EINVAL;
    }

    thash = ah_old_hash[i];

    DPRINTF(("ah_old_init(): initalized TDB with hash algorithm %s\n",
	     thash->name));

    tdbp->tdb_xform = xsp;
    tdbp->tdb_authalgxform = thash;

    tdbp->tdb_amxkeylen = ii->ii_authkeylen;
    MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen,
	   M_XDATA, M_WAITOK);

    bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);

    MALLOC(tdbp->tdb_ictx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
    bzero(tdbp->tdb_ictx, thash->ctxsize);
    thash->Init(tdbp->tdb_ictx);
    thash->Update(tdbp->tdb_ictx, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
    thash->Final(NULL, tdbp->tdb_ictx);

    bzero(ipseczeroes, IPSEC_ZEROES_SIZE);	/* paranoid */

    return 0;
}

/*
 * Free memory
 */

int
ah_old_zeroize(struct tdb *tdbp)
{
    if (tdbp->tdb_amxkey)
    {
	bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
	FREE(tdbp->tdb_amxkey, M_XDATA);
	tdbp->tdb_amxkey = NULL;
    }
    
    if (tdbp->tdb_ictx)
    {
	if (tdbp->tdb_authalgxform)
	  bzero(tdbp->tdb_ictx, tdbp->tdb_authalgxform->ctxsize);

    	FREE(tdbp->tdb_ictx, M_XDATA);
	tdbp->tdb_ictx = NULL;
    }

    return 0;
}

/*
 * ah_old_input() gets called to verify that an input packet
 * passes authentication.
 */

struct mbuf *
ah_old_input(struct mbuf *m, struct tdb *tdb, int skip, int protoff)
{
    struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    struct ip *ip, ipo;
    struct ah_old *ah, *aho;
    int ohlen, len, count, off, alen;
    struct mbuf *m0;
    union authctx_old ctx;
    u_int8_t optval;
    u_char buffer[40];

    aho = (struct ah_old *) buffer;
    alen = ahx->hashsize;
    ohlen = sizeof(struct ip) + AH_OLD_FLENGTH + alen;

    if (m->m_len < ohlen)
    {
	if ((m = m_pullup(m, ohlen)) == NULL)
	{
	    DPRINTF(("ah_old_input(): m_pullup() failed\n"));
	    ahstat.ahs_hdrops++;
	    return NULL;
	}
    }

    ip = mtod(m, struct ip *);

    if ((ip->ip_hl << 2) > sizeof(struct ip))
    {
	if ((m = m_pullup(m, ohlen - sizeof (struct ip) +
			  (ip->ip_hl << 2))) == NULL)
	{
	    DPRINTF(("ah_old_input(): m_pullup() failed\n"));
	    ahstat.ahs_hdrops++;
	    return NULL;
	}
	
	ip = mtod(m, struct ip *);
	ah = (struct ah_old *)((u_int8_t *) ip + (ip->ip_hl << 2));
	ohlen += ((ip->ip_hl << 2) - sizeof(struct ip));
    }
    else
      ah = (struct ah_old *) (ip + 1);

    /* Update the counters */
    tdb->tdb_cur_bytes += ip->ip_len - (ip->ip_hl << 2);
    ahstat.ahs_ibytes += ip->ip_len - (ip->ip_hl << 2);

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	  m_freem(m);
	  tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	  return NULL;
      }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	  tdb->tdb_flags &= ~TDBF_SOFT_BYTES;   /* Turn off checking */
      }

    ipo = *ip;
    ipo.ip_tos = 0;
    ipo.ip_len += (ip->ip_hl << 2);	/* adjusted in ip_intr() */
    HTONS(ipo.ip_len);
    HTONS(ipo.ip_id);
    ipo.ip_off = htons(ipo.ip_off & IP_DF);	/* XXX -- and the C bit? */
    ipo.ip_ttl = 0;
    ipo.ip_sum = 0;

    bcopy(tdb->tdb_ictx, &ctx, ahx->ctxsize);
    ahx->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));

    /* Options */
    if ((ip->ip_hl << 2) > sizeof(struct ip))
      for (off = sizeof(struct ip); off < (ip->ip_hl << 2);)
      {
	  optval = ((u_int8_t *) ip)[off];
	  switch (optval)
	  {
	      case IPOPT_EOL:
		  ahx->Update(&ctx, ipseczeroes, 1);

		  off = ip->ip_hl << 2;
		  break;

	      case IPOPT_NOP:
		  ahx->Update(&ctx, ipseczeroes, 1);

		  off++;
		  break;

	      case IPOPT_SECURITY:
	      case 133:
	      case 134:
		  optval = ((u_int8_t *) ip)[off + 1];

		  ahx->Update(&ctx, (u_int8_t *) ip + off, optval);

		  off += optval;
		  break;

	      default:
		  optval = ((u_int8_t *) ip)[off + 1];

		  ahx->Update(&ctx, ipseczeroes, optval);

		  off += optval;
		  break;
	  }
      }
    
    
    ahx->Update(&ctx, (unsigned char *) ah, AH_OLD_FLENGTH);
    ahx->Update(&ctx, ipseczeroes, alen);

    /*
     * Code shamelessly stolen from m_copydata
     */
    off = ohlen;
    len = m->m_pkthdr.len - off;
    m0 = m;
	
    while (off > 0)
    {
	if (m0 == 0)
	{
	    DPRINTF(("ah_old_input(): bad mbuf chain for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    return NULL;
	}

	if (off < m0->m_len)
	  break;

	off -= m0->m_len;
	m0 = m0->m_next;
    }

    while (len > 0)
    {
	if (m0 == 0)
	{
	    DPRINTF(("ah_old_input(): bad mbuf chain for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    return NULL;
	}
	
	count = min(m0->m_len - off, len);

	ahx->Update(&ctx, mtod(m0, unsigned char *) + off, count);

	len -= count;
	off = 0;
	m0 = m0->m_next;
    }

    ahx->Update(&ctx, (unsigned char *) tdb->tdb_amxkey, tdb->tdb_amxkeylen);
    ahx->Final((unsigned char *) (aho->ah_data), &ctx);

    if (bcmp(aho->ah_data, ah->ah_data, alen))
    {
	ahstat.ahs_badauth++;
	m_freem(m);
	return NULL;
    }
	
    ipo = *ip;
    ipo.ip_p = ah->ah_nh;

    /* Save options */
    m_copydata(m, sizeof(struct ip), (ip->ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) buffer);

    m->m_len -= (AH_OLD_FLENGTH + alen);
    m->m_data += (AH_OLD_FLENGTH + alen);
    m->m_pkthdr.len -= (AH_OLD_FLENGTH + alen);

    ip = mtod(m, struct ip *);
    *ip = ipo;
    ip->ip_len = htons(ip->ip_len - AH_OLD_FLENGTH - alen + (ip->ip_hl << 2));
    HTONS(ip->ip_id);
    HTONS(ip->ip_off);
    ip->ip_sum = 0;

    /* Copy the options back */
    m_copyback(m, sizeof(struct ip), (ip->ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) buffer);

    ip->ip_sum = in_cksum(m, (ip->ip_hl << 2));

    return m;
}

int
ah_old_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
	      int protoff)
{
    struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    struct ip *ip, ipo;
    struct ah_old *ah, aho;
    register int len, off, count;
    register struct mbuf *m0;
    union authctx_old ctx;
    int ilen, ohlen, alen;
    u_int8_t optval;
    u_char opts[40];

    alen = ahx->hashsize;

    ahstat.ahs_output++;
    m = m_pullup(m, sizeof(struct ip));
    if (m == NULL)
    {
	DPRINTF(("ah_old_output(): m_pullup() failed, SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_hdrops++;
      	return ENOBUFS;
    }

    ip = mtod(m, struct ip *);
	
    /* Update the counters */
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) -
			  AH_OLD_FLENGTH - alen;
    ahstat.ahs_obytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) -
			 AH_OLD_FLENGTH - alen;

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	m_freem(m);
	return EINVAL;
    }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	  tdb->tdb_flags &= ~TDBF_SOFT_BYTES;     /* Turn off checking */
      }

    if ((ip->ip_hl << 2) > sizeof(struct ip))
    {
	if ((m = m_pullup(m, ip->ip_hl << 2)) == NULL)
	{
	    DPRINTF(("ah_old_output(): m_pullup() failed, SA %s/%08x\n",
		     ipsp_address(tdb->tdb_dst),
		     ntohl(tdb->tdb_spi)));
	    ahstat.ahs_hdrops++;
	    return ENOBUFS;
	}
	
	ip = mtod(m, struct ip *);
    }

    /* Save the options */
    m_copydata(m, sizeof(struct ip), (ip->ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) opts);

    ilen = ntohs(ip->ip_len);

    ohlen = AH_OLD_FLENGTH + alen;
    if (ohlen + ilen > IP_MAXPACKET)
    {
	DPRINTF(("ah_old_output(): packet in SA %s/%0x8 got too big\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_toobig++;
        return EMSGSIZE;
    }
	
    ipo.ip_v = IPVERSION;
    ipo.ip_hl = ip->ip_hl;
    ipo.ip_tos = 0;
    ipo.ip_len = htons(ohlen + ilen);
    ipo.ip_id = ip->ip_id;
    ipo.ip_off = htons(ntohs(ip->ip_off) & IP_DF);
    ipo.ip_ttl = 0;
    ipo.ip_p = IPPROTO_AH;
    ipo.ip_sum = 0;
    ipo.ip_src = ip->ip_src;
    ipo.ip_dst = ip->ip_dst;

    aho.ah_nh = ip->ip_p;
    aho.ah_hl = alen >> 2;
    aho.ah_rv = 0;
    aho.ah_spi = tdb->tdb_spi;

    bcopy(tdb->tdb_ictx, &ctx, ahx->ctxsize);
    ahx->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));

    /* Options */
    if ((ip->ip_hl << 2) > sizeof(struct ip))
      for (off = sizeof(struct ip); off < (ip->ip_hl << 2);)
      {
	  optval = ((u_int8_t *) ip)[off];
	  switch (optval)
	  {
              case IPOPT_EOL:
		  ahx->Update(&ctx, ipseczeroes, 1);

                  off = ip->ip_hl << 2;
                  break;

              case IPOPT_NOP:
		  ahx->Update(&ctx, ipseczeroes, 1);

                  off++;
                  break;

              case IPOPT_SECURITY:
              case 133:
              case 134:
                  optval = ((u_int8_t *) ip)[off + 1];

		  ahx->Update(&ctx, (u_int8_t *) ip + off, optval);

                  off += optval;
                  break;

              default:
                  optval = ((u_int8_t *) ip)[off + 1];

		  ahx->Update(&ctx, ipseczeroes, optval);

                  off += optval;
                  break;
          }
      }

    ahx->Update(&ctx, (unsigned char *) &aho, AH_OLD_FLENGTH);
    ahx->Update(&ctx, ipseczeroes, alen);

    /* Skip the IP header and any options */
    off = ip->ip_hl << 2;

    /*
     * Code shamelessly stolen from m_copydata
     */
    len = m->m_pkthdr.len - off;
	
    m0 = m;

    while (len > 0)
    {
	if (m0 == 0)
	{
	    DPRINTF(("ah_old_output(): M_PREPEND() failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	    m_freem(m);
	    return NULL;
	}
	
	count = min(m0->m_len - off, len);

	ahx->Update(&ctx, mtod(m0, unsigned char *) + off, count);

	len -= count;
	off = 0;
	m0 = m0->m_next;
    }

    ahx->Update(&ctx, (unsigned char *) tdb->tdb_amxkey, tdb->tdb_amxkeylen);

    ipo.ip_tos = ip->ip_tos;
    ipo.ip_id = ip->ip_id;
    ipo.ip_off = ip->ip_off;
    ipo.ip_ttl = ip->ip_ttl;
/*  ipo.ip_len = ntohs(ipo.ip_len); */
	
    M_PREPEND(m, ohlen, M_DONTWAIT);
    if (m == NULL)
    {
	DPRINTF(("ah_old_output(): M_PREPEND() failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
        return ENOBUFS;
    }

    m = m_pullup(m, ohlen + (ipo.ip_hl << 2));
    if (m == NULL)
    {
	DPRINTF(("ah_old_output(): m_pullup() failed for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo.ip_src), inet_ntoa4(ipo.ip_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_hdrops++;
        return ENOBUFS;
    }

    ip = mtod(m, struct ip *);
    ah = (struct ah_old *) ((u_int8_t *) ip + (ipo.ip_hl << 2));
    *ip = ipo;
    ah->ah_nh = aho.ah_nh;
    ah->ah_hl = aho.ah_hl;
    ah->ah_rv = aho.ah_rv;
    ah->ah_spi = aho.ah_spi;

    /* Restore the options */
    m_copyback(m, sizeof(struct ip), (ip->ip_hl << 2) - sizeof(struct ip),
	       (caddr_t) opts);

    ahx->Final(ah->ah_data, &ctx);

    *mp = m;

    return 0;
}
@


1.26
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.25 1999/10/29 02:10:01 angelos Exp $	*/
@


1.25
log
@Get rid of unnecessary third argument in *_output routines of IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.24 1999/06/30 17:23:59 deraadt Exp $	*/
d176 1
a176 1
ah_old_input(struct mbuf *m, struct tdb *tdb)
d378 2
a379 1
ah_old_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp)
@


1.24
log
@remove final low-level crypto knowledge from base ipsec code
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.23 1999/05/16 21:48:32 niklas Exp $	*/
d378 1
a378 2
ah_old_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb,
  	      struct mbuf **mp)
@


1.23
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.22 1999/03/24 17:00:45 niklas Exp $	*/
d80 6
a85 15
struct auth_hash ah_old_hash[] = {
     { SADB_AALG_X_MD5, "Keyed MD5", 
       0, AH_MD5_ALEN,
       sizeof(MD5_CTX),
       (void (*)(void *))MD5Init, 
       (void (*)(void *, u_int8_t *, u_int16_t))MD5Update, 
       (void (*)(u_int8_t *, void *))MD5Final 
     },
     { SADB_AALG_X_SHA1, "Keyed SHA1",
       0, AH_SHA1_ALEN,
       sizeof(SHA1_CTX),
       (void (*)(void *))SHA1Init, 
       (void (*)(void *, u_int8_t *, u_int16_t))SHA1Update, 
       (void (*)(u_int8_t *, void *))SHA1Final 
     }
d109 2
a110 2
    for (i = sizeof(ah_old_hash) / sizeof(struct auth_hash) - 1; i >= 0; i--) 
      if (ii->ii_authalg == ah_old_hash[i].type)
d119 1
a119 1
    thash = &ah_old_hash[i];
d183 1
a183 4
    union {
	 MD5_CTX md5ctx; 
	 SHA1_CTX sha1ctx;
    } ctx;
d386 1
a386 4
    union {
	 MD5_CTX md5ctx;
	 SHA1_CTX sha1ctx;
    } ctx;
@


1.22
log
@Implement lifetime expiration notifications.  Fix some typos.  Remove statics.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.21 1999/02/25 20:14:38 angelos Exp $	*/
d242 1
a242 1
	  tdb_delete(tdb, 0);
d431 1
a431 1
	tdb_delete(tdb, 0);
@


1.21
log
@Bzero key information before free'ing it, just for paranoia's sake.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.20 1999/02/24 23:45:48 angelos Exp $	*/
d240 1
a240 3
/* XXX
   encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d250 1
a250 3
/* XXX
   encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
d430 1
a430 3
/* XXX
   encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d440 1
a440 3
/* XXX
   encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
@


1.20
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.19 1999/02/24 22:33:00 angelos Exp $	*/
d162 1
d169 3
@


1.19
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.18 1999/01/11 22:52:09 deraadt Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
@


1.18
log
@remove panic() calls, consistent error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.17 1998/11/25 09:56:50 niklas Exp $	*/
a66 1
#include <net/encap.h>
d70 1
d78 3
a80 5
extern void encap_sendnotify(int, struct tdb *, void *);

struct ah_hash ah_old_hash[] = {
     { ALG_AUTH_MD5, "Keyed MD5", 
       AH_MD5_ALEN,
d86 2
a87 2
     { ALG_AUTH_SHA1, "Keyed SHA1",
       AH_SHA1_ALEN,
a101 1
    DPRINTF(("ah_old_attach(): setting up\n"));
d106 1
a106 2
 * ah_old_init() is called when an SPI is being set up. It interprets the
 * encap_msghdr present in m, and sets up the transformation data.
d110 1
a110 1
ah_old_init(struct tdb *tdbp, struct xformsw *xsp, struct mbuf *m)
d112 1
a112 4
    struct ah_old_xencap xenc;
    struct ah_old_xdata *xd;
    struct encap_msghdr *em;
    struct ah_hash *thash;
a114 19
    if (m->m_len < ENCAP_MSG_FIXED_LEN)
    {
        if ((m = m_pullup(m, ENCAP_MSG_FIXED_LEN)) == NULL)
        {
            DPRINTF(("ah_old_init(): m_pullup failed\n"));
            return ENOBUFS;
        }
    }

    em = mtod(m, struct encap_msghdr *);
    if (em->em_msglen - EMT_SETSPI_FLEN <= AH_OLD_XENCAP_LEN)
    {
	DPRINTF(("ah_old_init(): initialization failed\n"));
	return EINVAL;
    }

    /* Just copy the standard fields */
    m_copydata(m, EMT_SETSPI_FLEN, AH_OLD_XENCAP_LEN, (caddr_t) &xenc);

d116 2
a117 2
    for (i=sizeof(ah_old_hash)/sizeof(struct ah_hash)-1; i >= 0; i--) 
	if (xenc.amx_hash_algorithm == ah_old_hash[i].type)
d119 1
d122 1
a122 2
	DPRINTF(("ah_old_init(): unsupported authentication algorithm %d specified\n", xenc.amx_hash_algorithm));
	m_freem(m);
a125 2
    DPRINTF(("ah_old_init(): initalized TDB with hash algorithm %d: %s\n",
	     xenc.amx_hash_algorithm, ah_old_hash[i].name));
d128 2
a129 14
    if (xenc.amx_keylen + EMT_SETSPI_FLEN + AH_OLD_XENCAP_LEN != em->em_msglen)
    {
	DPRINTF(("ah_old_init(): message length (%d) doesn't match\n",
		 em->em_msglen));
	return EINVAL;
    }

    MALLOC(tdbp->tdb_xdata, caddr_t, sizeof(struct ah_old_xdata) +
	   xenc.amx_keylen, M_XDATA, M_WAITOK);
    if (tdbp->tdb_xdata == NULL)
    {
	DPRINTF(("ah_old_init(): MALLOC() failed\n"));
      	return ENOBUFS;
    }
a130 4
    bzero(tdbp->tdb_xdata, sizeof(struct ah_old_xdata) + xenc.amx_keylen);
    xd = (struct ah_old_xdata *) tdbp->tdb_xdata;

    /* Pointer to the transform */
d132 1
d134 11
a144 14
    xd->amx_keylen = xenc.amx_keylen;
    xd->amx_hash_algorithm = xenc.amx_hash_algorithm;
    xd->amx_hash = thash;

    /* Pass name of auth algorithm for kernfs */
    tdbp->tdb_authname = xd->amx_hash->name;

    /* Copy the key material */
    m_copydata(m, EMT_SETSPI_FLEN + AH_OLD_XENCAP_LEN, xd->amx_keylen,
	       (caddr_t) xd->amx_key);

    xd->amx_hash->Init(&(xd->amx_ctx));
    xd->amx_hash->Update(&(xd->amx_ctx), xd->amx_key, xd->amx_keylen);
    xd->amx_hash->Final(NULL, &(xd->amx_ctx));
d158 1
a158 2
    DPRINTF(("ah_old_zeroize(): freeing memory\n"));
    if (tdbp->tdb_xdata)
d160 2
a161 2
    	FREE(tdbp->tdb_xdata, M_XDATA);
	tdbp->tdb_xdata = NULL;
d163 7
d181 1
a181 1
    struct ah_old_xdata *xd;
d194 1
a194 5

    xd = (struct ah_old_xdata *) tdb->tdb_xdata;

    alen = xd->amx_hash->hashsize;

d226 26
d261 2
a262 2
    bcopy(&(xd->amx_ctx), &ctx, xd->amx_hash->ctxsize);
    xd->amx_hash->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));
d272 1
a272 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, 1);
d278 1
a278 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, 1);
d288 1
a288 1
		  xd->amx_hash->Update(&ctx, (u_int8_t *) ip + off, optval);
d296 1
a296 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, optval);
d304 2
a305 2
    xd->amx_hash->Update(&ctx, (unsigned char *) ah, AH_OLD_FLENGTH);
    xd->amx_hash->Update(&ctx, ipseczeroes, alen);
d318 1
a318 1
	    DPRINTF(("ah_old_input(): bad mbuf chain for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d335 1
a335 1
	    DPRINTF(("ah_old_input(): bad mbuf chain for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d343 1
a343 1
	xd->amx_hash->Update(&ctx, mtod(m0, unsigned char *) + off, count);
d350 2
a351 2
    xd->amx_hash->Update(&ctx, (unsigned char *) xd->amx_key, xd->amx_keylen);
    xd->amx_hash->Final((unsigned char *) (aho->ah_data), &ctx);
a383 38
    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);
    ahstat.ahs_ibytes += ntohs(ip->ip_len) - (ip->ip_hl << 2);

    /* Notify on expiration */
    if (tdb->tdb_flags & TDBF_SOFT_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_soft_packets)
      {
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	  tdb->tdb_flags &= ~TDBF_SOFT_PACKETS;
      }
      else
	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
	  {
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;
	  }
    }

    if (tdb->tdb_flags & TDBF_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_exp_packets)
      {
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	  tdb_delete(tdb, 0);
      }
      else
	if (tdb->tdb_flags & TDBF_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)
	  {
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	      tdb_delete(tdb, 0);
	  }
    }

d391 1
a391 1
    struct ah_old_xdata *xd;
d404 2
d410 2
a411 2
	DPRINTF(("ah_old_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d418 27
a444 1
    xd = (struct ah_old_xdata *) tdb->tdb_xdata;
d450 3
a452 2
	    DPRINTF(("ah_old_output(): m_pullup() failed, SA &x/%08x\n",
		     tdb->tdb_dst, ntohl(tdb->tdb_spi)));
a459 2
    alen = xd->amx_hash->hashsize;

d467 4
a470 3
    if (ohlen + ilen > IP_MAXPACKET) {
	DPRINTF(("ah_old_output(): packet in SA %x/%0x8 got too big\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi)));
d493 2
a494 2
    bcopy(&(xd->amx_ctx), &ctx, xd->amx_hash->ctxsize);
    xd->amx_hash->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));
d504 1
a504 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, 1);
d510 1
a510 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, 1);
d520 1
a520 1
		  xd->amx_hash->Update(&ctx, (u_int8_t *) ip + off, optval);
d528 1
a528 1
		  xd->amx_hash->Update(&ctx, ipseczeroes, optval);
d535 2
a536 2
    xd->amx_hash->Update(&ctx, (unsigned char *) &aho, AH_OLD_FLENGTH);
    xd->amx_hash->Update(&ctx, ipseczeroes, alen);
d552 1
a552 1
	    DPRINTF(("ah_old_output(): M_PREPEND() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d559 1
a559 1
	xd->amx_hash->Update(&ctx, mtod(m0, unsigned char *) + off, count);
d566 1
a566 1
    xd->amx_hash->Update(&ctx, (unsigned char *) xd->amx_key, xd->amx_keylen);
d577 1
a577 1
	DPRINTF(("ah_old_output(): M_PREPEND() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d584 1
a584 1
	DPRINTF(("ah_old_output(): m_pullup() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi)));
d601 1
a601 1
    xd->amx_hash->Final(ah->ah_data, &ctx);
a603 40

    /* Update the counters */
    tdb->tdb_cur_packets++;
    tdb->tdb_cur_bytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) -
			  AH_OLD_FLENGTH - alen;
    ahstat.ahs_obytes += ntohs(ip->ip_len) - (ip->ip_hl << 2) -
			 AH_OLD_FLENGTH - alen;

    /* Notify on expiration */
    if (tdb->tdb_flags & TDBF_SOFT_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_soft_packets)
      {
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	  tdb->tdb_flags &= ~TDBF_SOFT_PACKETS;
      }
      else
	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
	  {
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	      tdb->tdb_flags &= ~TDBF_SOFT_BYTES;
	  }
    }

    if (tdb->tdb_flags & TDBF_PACKETS)
    {
      if (tdb->tdb_cur_packets >= tdb->tdb_exp_packets)
      {
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	  tdb_delete(tdb, 0);
      }
      else
	if (tdb->tdb_flags & TDBF_BYTES)
	  if (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)
	  {
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	      tdb_delete(tdb, 0);
	  }
    }
@


1.17
log
@Better error code for too large packets
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.16 1998/11/25 02:01:26 niklas Exp $	*/
a70 1
#include <sys/syslog.h>
d134 1
a134 2
	if (encdebug)
	  log(LOG_WARNING, "ah_old_init(): initialization failed\n");
d147 1
a147 3
	if (encdebug)
	  log(LOG_WARNING, "ah_old_init(): unsupported authentication algorithm %d specified\n",
	      xenc.amx_hash_algorithm);
d151 1
d158 2
a159 3
	if (encdebug)
	  log(LOG_WARNING, "ah_old_init(): message length (%d) doesn't match\n",
	    em->em_msglen);
d335 6
a340 1
	  panic("ah_old_input(): m_copydata (off)");
d352 7
a358 2
	  panic("ah_old_input(): m_copydata (copy)");

a372 2
	if (encdebug)
	  log(LOG_ALERT, "ah_old_input(): authentication failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi));
d466 1
d497 2
a498 4
	if (encdebug)
            log(LOG_ALERT,
		"ah_old_output(): packet in SA %x/%0x8 got too big\n",
		tdb->tdb_dst, ntohl(tdb->tdb_spi));
d579 6
a584 1
	  panic("ah_old_output(): m_copydata()");
d613 1
@


1.16
log
@Add checks of packets getting to big after transforms.
Also make sure some more error conditions get told to the caller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.15 1998/06/03 09:50:19 provos Exp $	*/
d498 1
a498 1
        return ENOBUFS;
@


1.15
log
@cleanup debug printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.14 1998/05/18 21:10:34 provos Exp $	*/
d476 1
a476 1
	    return NULL;
d491 9
@


1.14
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.12 1998/02/22 01:23:31 niklas Exp $	*/
d73 6
d105 1
a105 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("ah_old_attach(): setting up\n");
#endif /* ENCDEBUG */
d127 1
a127 4
#ifdef ENCDEBUG
            if (encdebug)
              printf("ah_old_init(): m_pullup failed\n");
#endif /* ENCDEBUG */
d155 2
a156 5
#ifdef ENCDEBUG
    if (encdebug)
      printf("ah_old_init(): initalized TDB with hash algorithm %d: %s\n",
	     xenc.amx_hash_algorithm, ah_old_hash[i].name);
#endif /* ENCDEBUG */
d171 1
a171 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_old_init(): MALLOC() failed\n");
#endif /* ENCDEBUG */
d208 1
a208 4
#ifdef ENCDEBUG
    if (encdebug)
      printf("ah_old_zeroize(): freeing memory\n");
#endif /* ENCDEBUG */
d249 1
a249 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("ah_old_input(): m_pullup() failed\n");
#endif /* ENCDEBUG */
d262 1
a262 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("ah_old_input(): m_pullup() failed\n");
#endif /* ENCDEBUG */
d460 2
a461 5
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_old_output(): m_pullup() failed, SA %x/%08x\n",
		 tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d473 2
a474 5
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("ah_old_output(): m_pullup() failed, SA &x/%08x\n",
		     tdb->tdb_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d588 1
a588 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_old_output(): M_PREPEND() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
d595 1
a595 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_old_output(): m_pullup() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi));
#endif /* ENCDEBUG */
@


1.13
log
@Fix tunnel mode input processing (use ip4_input instead of ipe4_input),
fix some old code leftovers in ah_new_input (adjust to variable hash length),
avoid double ip encapsulation in tunnel mode. Problems reportd by
Petr Novak <petr@@internet.cz>.
@
text
@d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
d73 1
a73 1
extern void encap_sendnotify(int, struct tdb *);
d423 1
a423 1
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d430 1
a430 1
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d439 1
a439 1
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d446 1
a446 1
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d654 1
a654 1
	  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d661 1
a661 1
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d670 1
a670 1
	  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d677 1
a677 1
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
@


1.12
log
@Changes made for GCC 2.8 -Wall pleasures
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.11 1998/01/21 18:43:33 provos Exp $	*/
d336 1
a336 1
    xd->amx_hash->Update(&ctx, ipseczeroes, AH_MD5_ALEN);
@


1.11
log
@rcvif not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.10 1997/11/15 00:07:07 deraadt Exp $	*/
d414 1
d427 2
a428 1
    
d430 1
d443 1
d645 1
d658 2
a659 1
    
d661 1
d674 1
@


1.10
log
@fix memory management errors
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah_old.c,v 1.9 1997/11/07 08:27:29 niklas Exp $	*/
a230 1
    struct ifnet *rcvif;
a247 10
    rcvif = m->m_pkthdr.rcvif;
    if (rcvif == NULL)
    {
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_old_input(): receive interface is NULL!\n");
#endif /* ENCDEBUG */
	rcvif = &enc_softc;
    }
	
a392 1
    m->m_pkthdr.rcvif = rcvif;	/* this should not be necessary */
@


1.9
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d212 5
a216 1
    FREE(tdbp->tdb_xdata, M_XDATA);
@


1.8
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
@


1.7
log
@conditional error logging
@
text
@d11 5
a15 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
d68 17
d110 2
d137 4
a140 1
    switch (xenc.amx_hash_algorithm)
d142 6
a147 2
	case ALG_AUTH_MD5:
	case ALG_AUTH_SHA1:
d149 3
a151 3
	    if (encdebug)
	      printf("ah_old_init(): initialized TDB with hash algorithm %d\n",
		     xenc.amx_hash_algorithm);
d153 1
a153 8
	    break;

	default:
	    if (encdebug)
	      log(LOG_WARNING, "ah_old_init(): unsupported authentication algorithm %d specified\n", xenc.amx_hash_algorithm);
	    m_freem(m);
	    return EINVAL;
    }
d182 4
d191 3
a193 15
    /* Save us some time in processing */
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    MD5Init(&(xd->amx_md5_ctx));
	    MD5Update(&(xd->amx_md5_ctx), xd->amx_key, xd->amx_keylen);
	    MD5Final(NULL, &(xd->amx_md5_ctx));
	    break;

	case ALG_AUTH_SHA1:
	    SHA1Init(&(xd->amx_sha1_ctx));
	    SHA1Update(&(xd->amx_sha1_ctx), xd->amx_key, xd->amx_keylen);
	    SHA1Final(NULL, &(xd->amx_sha1_ctx));
	    break;
    }
d229 4
a232 2
    MD5_CTX md5ctx; 
    SHA1_CTX sha1ctx;
d240 1
a240 18
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    alen = AH_MD5_ALEN;
	    break;

	case ALG_AUTH_SHA1:
	    alen = AH_SHA1_ALEN;
	    break;

	default:
	    if (encdebug)
	      log(LOG_ALERT,
		  "ah_old_input(): unsupported algorithm %d in SA %x/%08x\n",
		  xd->amx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
	    m_freem(m);
	    return NULL;
    }
d298 2
a299 12
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    md5ctx = xd->amx_md5_ctx;
	    MD5Update(&md5ctx, (unsigned char *) &ipo, sizeof(struct ip));
	    break;

	case ALG_AUTH_SHA1:
	    sha1ctx = xd->amx_sha1_ctx;
	    SHA1Update(&sha1ctx, (unsigned char *) &ipo, sizeof(struct ip));
	    break;
    }
d309 1
a309 10
		  switch (xd->amx_hash_algorithm)
		  {
		      case ALG_AUTH_MD5:
			  MD5Update(&md5ctx, ipseczeroes, 1);
			  break;

		      case ALG_AUTH_SHA1:
			  SHA1Update(&sha1ctx, ipseczeroes, 1);
			  break;
		  }
d315 1
a315 10
		  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, ipseczeroes, 1);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, ipseczeroes, 1);
                          break;
                  }
d325 1
a325 10
		  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, (u_int8_t *) ip + off, optval);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, (u_int8_t *) ip + off, optval);
                          break;
                  }
d333 1
a333 10
		  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, ipseczeroes, optval);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, ipseczeroes, optval);
                          break;
                  }
d341 2
a342 12
    switch (xd->amx_hash_algorithm)
    {
        case ALG_AUTH_MD5:
            MD5Update(&md5ctx, (unsigned char *) ah, AH_OLD_FLENGTH);
	    MD5Update(&md5ctx, ipseczeroes, AH_MD5_ALEN);
            break;

        case ALG_AUTH_SHA1:
            SHA1Update(&sha1ctx, (unsigned char *) ah, AH_OLD_FLENGTH);
	    SHA1Update(&sha1ctx, ipseczeroes, AH_SHA1_ALEN);
            break;
    }
d370 1
a370 9
	switch (xd->amx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		MD5Update(&md5ctx, mtod(m0, unsigned char *) + off, count);
		break;

	    case ALG_AUTH_SHA1:
		SHA1Update(&sha1ctx, mtod(m0, unsigned char *) + off, count);
	}
d377 2
a378 12
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    MD5Update(&md5ctx, (unsigned char *) xd->amx_key, xd->amx_keylen);
	    MD5Final((unsigned char *) (aho->ah_data), &md5ctx);
	    break;

	case ALG_AUTH_SHA1:
	    SHA1Update(&sha1ctx, (unsigned char *) xd->amx_key, xd->amx_keylen);
	    SHA1Final((unsigned char *) (aho->ah_data), &sha1ctx);
	    break;
    }
d460 4
a463 2
    MD5_CTX md5ctx;
    SHA1_CTX sha1ctx;
d500 1
a500 18
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    alen = AH_MD5_ALEN;
	    break;

	case ALG_AUTH_SHA1:
	    alen = AH_SHA1_ALEN;
	    break;

	default:
	    if (encdebug)
	      log(LOG_ALERT,
                  "ah_old_output(): unsupported algorithm %d in SA %x/%08x\n",
                  xd->amx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
            m_freem(m);
            return NULL;
    }
d527 2
a528 12
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    md5ctx = xd->amx_md5_ctx;
	    MD5Update(&md5ctx, (unsigned char *) &ipo, sizeof(struct ip));
	    break;

	case ALG_AUTH_SHA1:
	    sha1ctx = xd->amx_sha1_ctx;
	    SHA1Update(&sha1ctx, (unsigned char *) &ipo, sizeof(struct ip));
	    break;
    }
d538 1
a538 10
                  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, ipseczeroes, 1);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, ipseczeroes, 1);
                          break;
                  }
d544 1
a544 10
                  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, ipseczeroes, 1);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, ipseczeroes, 1);
                          break;
                  }
d554 1
a554 10
                  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, (u_int8_t *) ip + off, optval);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, (u_int8_t *) ip + off, optval);
                          break;
                  }
d562 1
a562 10
                  switch (xd->amx_hash_algorithm)
                  {
                      case ALG_AUTH_MD5:
                          MD5Update(&md5ctx, ipseczeroes, optval);
                          break;

                      case ALG_AUTH_SHA1:
                          SHA1Update(&sha1ctx, ipseczeroes, optval);
                          break;
                  }
d569 2
a570 12
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    MD5Update(&md5ctx, (unsigned char *) &aho, AH_OLD_FLENGTH);
            MD5Update(&md5ctx, ipseczeroes, alen);
            break;

	case ALG_AUTH_SHA1:
	    SHA1Update(&sha1ctx, (unsigned char *) &aho, AH_OLD_FLENGTH);
	    SHA1Update(&sha1ctx, ipseczeroes, alen);
	    break;
    }
d588 1
a588 10
	switch (xd->amx_hash_algorithm)
	{
	    case ALG_AUTH_MD5:
		MD5Update(&md5ctx, mtod(m0, unsigned char *) + off, count);
		break;

	    case ALG_AUTH_SHA1:
		SHA1Update(&sha1ctx, mtod(m0, unsigned char *) + off, count);
		break;
	}
d595 1
a595 10
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    MD5Update(&md5ctx, (unsigned char *) xd->amx_key, xd->amx_keylen);
	    break;

	case ALG_AUTH_SHA1:
	    SHA1Update(&sha1ctx, (unsigned char *) xd->amx_key, xd->amx_keylen);
	    break;
    }
d635 1
a635 10
    switch (xd->amx_hash_algorithm)
    {
	case ALG_AUTH_MD5:
	    MD5Final(ah->ah_data, &md5ctx);
	    break;

	case ALG_AUTH_SHA1:
	    SHA1Final(ah->ah_data, &sha1ctx);
	    break;
    }
@


1.6
log
@log() needs a \n
@
text
@d105 2
a106 1
	log(LOG_WARNING, "ah_old_init(): initialization failed\n");
d126 2
a127 1
	    log(LOG_WARNING, "ah_old_init(): unsupported authentication algorithm %d specified\n", xenc.amx_hash_algorithm);
d134 2
a135 1
	log(LOG_WARNING, "ah_old_init(): message length (%d) doesn't match\n",
d234 4
a237 3
	    log(LOG_ALERT,
		"ah_old_input(): unsupported algorithm %d in SA %x/%08x\n",
		xd->amx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
d456 2
a457 1
	log(LOG_ALERT, "ah_old_input(): authentication failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi));
d583 4
a586 3
	    log(LOG_ALERT,
                "ah_old_output(): unsupported algorithm %d in SA %x/%08x\n",
                xd->amx_hash_algorithm, tdb->tdb_dst, ntohl(tdb->tdb_spi));
@


1.5
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d105 1
a105 1
	log(LOG_WARNING, "ah_old_init(): initialization failed");
d125 1
a125 1
	    log(LOG_WARNING, "ah_old_init(): unsupported authentication algorithm %d specified", xenc.amx_hash_algorithm);
d132 1
a132 1
	log(LOG_WARNING, "ah_old_init(): message length (%d) doesn't match",
d232 1
a232 1
		"ah_old_input(): unsupported algorithm %d in SA %x/%08x",
d452 1
a452 1
	log(LOG_ALERT, "ah_old_input(): authentication failed for packet from %x to %x, spi %08x", ipo.ip_src, ipo.ip_dst, ntohl(tdb->tdb_spi));
d579 1
a579 1
                "ah_old_output(): unsupported algorithm %d in SA %x/%08x",
@


1.4
log
@network byte order for counters
@
text
@d62 2
d488 29
d811 29
@


1.3
log
@enablespi/disablespi in encap + print spi's in hostorder
@
text
@d776 4
a779 2
    tdb->tdb_cur_bytes += ip->ip_len - (ip->ip_hl << 2) - AH_OLD_FLENGTH - alen;
    ahstat.ahs_obytes += ip->ip_len - (ip->ip_hl << 2) - AH_OLD_FLENGTH - alen;
@


1.2
log
@global byte counters.
@
text
@d231 1
a231 1
		xd->amx_hash_algorithm, tdb->tdb_dst, tdb->tdb_spi);
d450 1
a450 1
	log(LOG_ALERT, "ah_old_input(): authentication failed for packet from %x to %x, spi %08x", ipo.ip_src, ipo.ip_dst, tdb->tdb_spi);
d511 1
a511 1
		 tdb->tdb_dst, tdb->tdb_spi);
d527 1
a527 1
		     tdb->tdb_dst, tdb->tdb_spi);
d549 1
a549 1
                xd->amx_hash_algorithm, tdb->tdb_dst, tdb->tdb_spi);
d734 1
a734 1
	  printf("ah_old_output(): M_PREPEND() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_spi);
d744 1
a744 1
	  printf("ah_old_output(): m_pullup() failed for packet from %x to %x, spi %08x\n", ipo.ip_src, ipo.ip_dst, tdb->tdb_spi);
@


1.1
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d484 1
d777 1
@

