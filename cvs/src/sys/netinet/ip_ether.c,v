head	1.86;
access;
symbols
	OPENBSD_6_2:1.86.0.4
	OPENBSD_6_2_BASE:1.86
	OPENBSD_6_1:1.84.0.4
	OPENBSD_6_1_BASE:1.84
	OPENBSD_6_0:1.80.0.6
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.80.0.2
	OPENBSD_5_9_BASE:1.80
	OPENBSD_5_8:1.78.0.4
	OPENBSD_5_8_BASE:1.78
	OPENBSD_5_7:1.70.0.2
	OPENBSD_5_7_BASE:1.70
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.65.0.4
	OPENBSD_5_5_BASE:1.65
	OPENBSD_5_4:1.62.0.4
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.62.0.2
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.58.0.6
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.4
	OPENBSD_5_0:1.58.0.2
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.51.0.10
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.6
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.51.0.4
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.51.0.2
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.50.0.4
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.48.0.4
	OPENBSD_3_9_BASE:1.48
	OPENBSD_3_8:1.48.0.2
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.47.0.2
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.46.0.4
	OPENBSD_3_6_BASE:1.46
	SMP_SYNC_A:1.46
	SMP_SYNC_B:1.46
	OPENBSD_3_5:1.46.0.2
	OPENBSD_3_5_BASE:1.46
	OPENBSD_3_4:1.45.0.2
	OPENBSD_3_4_BASE:1.45
	UBC_SYNC_A:1.44
	OPENBSD_3_3:1.43.0.2
	OPENBSD_3_3_BASE:1.43
	OPENBSD_3_2:1.40.0.2
	OPENBSD_3_2_BASE:1.40
	OPENBSD_3_1:1.38.0.2
	OPENBSD_3_1_BASE:1.38
	UBC_SYNC_B:1.41
	UBC:1.36.0.2
	UBC_BASE:1.36
	OPENBSD_3_0:1.35.0.2
	OPENBSD_3_0_BASE:1.35
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.4;
locks; strict;
comment	@ * @;


1.86
date	2017.06.19.17.58.49;	author bluhm;	state Exp;
branches;
next	1.85;
commitid	o1URxEJIRKTXxlGk;

1.85
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.84;
commitid	00hB28wQPwG5Ysk0;

1.84
date	2017.03.07.23.35.06;	author jca;	state Exp;
branches;
next	1.83;
commitid	PgAFt411fYnb1Ztm;

1.83
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.82;
commitid	3e3CkrbYekyVOcxy;

1.82
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.81;
commitid	pVtptbHA3yk4jSpN;

1.81
date	2016.09.24.14.51.37;	author naddy;	state Exp;
branches;
next	1.80;
commitid	B9MFucENkVbjvRxm;

1.80
date	2015.12.02.08.47.00;	author claudio;	state Exp;
branches;
next	1.79;
commitid	bBZq0t5zueGnkAtX;

1.79
date	2015.11.07.12.42.19;	author mpi;	state Exp;
branches;
next	1.78;
commitid	3n9C29EcvMo1935D;

1.78
date	2015.07.31.15.38.10;	author rzalamena;	state Exp;
branches;
next	1.77;
commitid	0pILqLThEynfCWvM;

1.77
date	2015.07.29.00.04.03;	author rzalamena;	state Exp;
branches;
next	1.76;
commitid	9x7oePEcDKgC05vn;

1.76
date	2015.07.20.21.16.39;	author rzalamena;	state Exp;
branches;
next	1.75;
commitid	t2fhFUpUuj89g4Sj;

1.75
date	2015.07.15.17.33.48;	author deraadt;	state Exp;
branches;
next	1.74;
commitid	ouqXOLuJ594YIl89;

1.74
date	2015.07.02.09.40.03;	author mpi;	state Exp;
branches;
next	1.73;
commitid	eKXa0TkOIth1tkBS;

1.73
date	2015.06.23.09.42.23;	author mpi;	state Exp;
branches;
next	1.72;
commitid	p9JxIlTsQMWvTdAT;

1.72
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.71;
commitid	h7z8lokZ0dFyuWpg;

1.71
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.70;
commitid	c7ei8kPelCOOwHXy;

1.70
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.69;
commitid	zhW8jJrfVCoAthrR;

1.69
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.68;
commitid	uzzBR7hz9ncd4O6G;

1.68
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.67;
commitid	DQakU8LLWV6Iwx84;

1.67
date	2014.07.14.12.18.30;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	2OCwVynZCRfrPdg3;

1.66
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2013.12.31.03.24.44;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2013.11.06.17.08.57;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2013.01.14.23.06.09;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.60;

1.60
date	2012.10.05.12.29.15;	author camield;	state Exp;
branches;
next	1.59;

1.59
date	2012.09.26.14.53.23;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.04.20.42.15;	author dhill;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.13.22.15.59;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2010.10.28.16.36.16;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.54;

1.54
date	2010.05.11.09.36.07;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.21.14.08.14;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.20.19.37.40;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.31.03.52.19;	author pascoe;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.17.12.06.16;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.03.14.51.05;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2003.08.14.19.00.12;	author jason;	state Exp;
branches;
next	1.44;

1.44
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.06.11.54.06;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.06.09.43.35;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2002.10.15.14.52.46;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.09.00.58.32;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.24.19.26.14;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.29.08.20.50;	author itojun;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.07.27.15.48.38;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.27.03.49.53;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.26.04.29.05;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.25.05.11.58;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.25.02.54.44;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.23.16.15.56;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.19.00.48.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.08.03.53.45;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.27.11.52.21;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.07.20.52.13;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.06.02.50.02;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.03.21.38.38;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.03.19.45.03;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.02.08.28.20;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.01.20.19.24;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.01.20.14.26;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.01.00.14.14;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.31.08.32.17;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.31.08.28.47;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.31.05.43.07;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.15.22.40.30;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.09.03.09.10;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.31.18.18.56;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.30.22.55.33;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.19.03.20.58;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.18.21.37.29;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.11.16.28.49;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.10.07.33.44;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.07.21.59.34;	author angelos;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.12.25.07.25.25;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.12.06.07.14.35;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.11.04.05.16.32;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.10.29.02.00.23;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.10.28.03.08.34;	author angelos;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.40.09;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.54.42;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	;

1.36.2.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.86
log
@When dealing with mbuf pointers passed down as function parameters,
bugs could easily result in use-after-free or double free.  Introduce
m_freemp() which automatically resets the pointer before freeing
it.  So we have less dangling pointers in the kernel.
OK krw@@ mpi@@ claudio@@
@
text
@/*	$OpenBSD: ip_ether.c,v 1.85 2017/04/14 20:46:31 bluhm Exp $  */
/*
 * The author of this code is Angelos D. Keromytis (kermit@@adk.gr)
 *
 * This code was written by Angelos D. Keromytis for OpenBSD in October 1999.
 *
 * Copyright (C) 1999-2001 Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * Ethernet-inside-IP processing (RFC3378).
 */

#include "bridge.h"
#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/bpf.h>
#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>

#include <netinet/ip_ether.h>
#include <netinet/if_ether.h>

#include <net/if_gif.h>

#if NBRIDGE > 0
#include <net/if_bridge.h>
#endif
#ifdef MPLS
#include <netmpls/mpls.h>
#endif
#if NPF > 0
#include <net/pfvar.h>
#endif

#include "bpfilter.h"

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

#if NBRIDGE > 0
void	etherip_decap(struct mbuf *, int);
#endif
#ifdef MPLS
void	mplsip_decap(struct mbuf *, int);
#endif
struct gif_softc	*etherip_getgif(struct mbuf *);

/*
 * We can control the acceptance of EtherIP packets by altering the sysctl
 * net.inet.etherip.allow value. Zero means drop them, all else is acceptance.
 */
int etherip_allow = 0;

struct etheripstat etheripstat;

/*
 * etherip_input gets called when we receive an encapsulated packet.
 */
int
etherip_input(struct mbuf **mp, int *offp, int proto, int af)
{
	switch (proto) {
#if NBRIDGE > 0
	case IPPROTO_ETHERIP:
		/* If we do not accept EtherIP explicitly, drop. */
		if (!etherip_allow && ((*mp)->m_flags & (M_AUTH|M_CONF)) == 0) {
			DPRINTF(("etherip_input(): dropped due to policy\n"));
			etheripstat.etherips_pdrops++;
			m_freemp(mp);
			return IPPROTO_DONE;
		}
		etherip_decap(*mp, *offp);
		return IPPROTO_DONE;
#endif
#ifdef MPLS
	case IPPROTO_MPLS:
		mplsip_decap(*mp, *offp);
		return IPPROTO_DONE;
#endif
	default:
		DPRINTF(("etherip_input(): dropped, unhandled protocol\n"));
		etheripstat.etherips_pdrops++;
		m_freemp(mp);
		return IPPROTO_DONE;
	}
}

#if NBRIDGE > 0
void
etherip_decap(struct mbuf *m, int iphlen)
{
	struct etherip_header eip;
	struct gif_softc *sc;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();

	etheripstat.etherips_ipackets++;

	/*
	 * Make sure there's at least an ethernet header's and an EtherIP
	 * header's of worth of data after the outer IP header.
	 */
	if (m->m_pkthdr.len < iphlen + sizeof(struct ether_header) +
	    sizeof(struct etherip_header)) {
		DPRINTF(("etherip_input(): encapsulated packet too short\n"));
		etheripstat.etherips_hdrops++;
		m_freem(m);
		return;
	}

	/* Verify EtherIP version number */
	m_copydata(m, iphlen, sizeof(struct etherip_header), (caddr_t)&eip);
	if (eip.eip_ver == ETHERIP_VERSION) {
		/* Correct */
	} else {
		DPRINTF(("etherip_input(): received EtherIP version number "
		    "%d not suppoorted\n", eip.eip_ver));
		etheripstat.etherips_adrops++;
		m_freem(m);
		return;
	}

	/* Finally, the pad value must be zero. */
	if (eip.eip_pad) {
		DPRINTF(("etherip_input(): received EtherIP invalid "
		    "pad value\n"));
		etheripstat.etherips_adrops++;
		m_freem(m);
		return;
	}

	/* Make sure the ethernet header at least is in the first mbuf. */
	if (m->m_len < iphlen + sizeof(struct ether_header) +
	    sizeof(struct etherip_header)) {
		if ((m = m_pullup(m, iphlen + sizeof(struct ether_header) +
		    sizeof(struct etherip_header))) == NULL) {
			DPRINTF(("etherip_input(): m_pullup() failed\n"));
			etheripstat.etherips_adrops++;
			return;
		}
	}

	sc = etherip_getgif(m);
	if (sc == NULL)
		return;
	if (sc->gif_if.if_bridgeport == NULL) {
		DPRINTF(("etherip_input(): interface not part of bridge\n"));
		etheripstat.etherips_noifdrops++;
		m_freem(m);
		return;
	}

	/* Chop off the `outer' IP and EtherIP headers and reschedule. */
	m_adj(m, iphlen + sizeof(struct etherip_header));

	/* Statistics */
	etheripstat.etherips_ibytes += m->m_pkthdr.len;

	/* Reset the flags based on the inner packet */
	m->m_flags &= ~(M_BCAST|M_MCAST|M_AUTH|M_CONF|M_PROTO1);

#if NPF > 0
	pf_pkt_addr_changed(m);
#endif

	ml_enqueue(&ml, m);
	if_input(&sc->gif_if, &ml);
}
#endif

#ifdef MPLS
void
mplsip_decap(struct mbuf *m, int iphlen)
{
	struct gif_softc *sc;

	etheripstat.etherips_ipackets++;

	/*
	 * Make sure there's at least one MPLS label worth of data after
	 * the outer IP header.
	 */
	if (m->m_pkthdr.len < iphlen + sizeof(struct shim_hdr)) {
		DPRINTF(("mplsip_input(): encapsulated packet too short\n"));
		etheripstat.etherips_hdrops++;
		m_freem(m);
		return;
	}

	/* Make sure the mpls label at least is in the first mbuf. */
	if (m->m_len < iphlen + sizeof(struct shim_hdr)) {
		if ((m = m_pullup(m, iphlen + sizeof(struct shim_hdr))) ==
		    NULL) {
			DPRINTF(("mplsip_input(): m_pullup() failed\n"));
			etheripstat.etherips_adrops++;
			return;
		}
	}

	sc = etherip_getgif(m);
	if (sc == NULL)
		return;

	/* Chop off the `outer' IP header and reschedule. */
	m_adj(m, iphlen);

	/* Statistics */
	etheripstat.etherips_ibytes += m->m_pkthdr.len;

	/* Reset the flags based */
	m->m_flags &= ~(M_BCAST|M_MCAST);

#if NBPFILTER > 0
	if (sc->gif_if.if_bpf)
		bpf_mtap_af(sc->gif_if.if_bpf, AF_MPLS, m, BPF_DIRECTION_IN);
#endif

	m->m_pkthdr.ph_ifidx = sc->gif_if.if_index;
	m->m_pkthdr.ph_rtableid = sc->gif_if.if_rdomain;
#if NPF > 0
	pf_pkt_addr_changed(m);
#endif

	mpls_input(m);
}
#endif

struct gif_softc *
etherip_getgif(struct mbuf *m)
{
	union sockaddr_union ssrc, sdst;
	struct gif_softc *sc;
	u_int8_t v;

	/* Copy the addresses for use later. */
	memset(&ssrc, 0, sizeof(ssrc));
	memset(&sdst, 0, sizeof(sdst));

	v = *mtod(m, u_int8_t *);
	switch (v >> 4) {
	case 4:
		ssrc.sa.sa_len = sdst.sa.sa_len = sizeof(struct sockaddr_in);
		ssrc.sa.sa_family = sdst.sa.sa_family = AF_INET;
		m_copydata(m, offsetof(struct ip, ip_src),
		    sizeof(struct in_addr),
		    (caddr_t) &ssrc.sin.sin_addr);
		m_copydata(m, offsetof(struct ip, ip_dst),
		    sizeof(struct in_addr),
		    (caddr_t) &sdst.sin.sin_addr);
		break;
#ifdef INET6
	case 6:
		ssrc.sa.sa_len = sdst.sa.sa_len = sizeof(struct sockaddr_in6);
		ssrc.sa.sa_family = sdst.sa.sa_family = AF_INET6;
		m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
		    sizeof(struct in6_addr),
		    (caddr_t) &ssrc.sin6.sin6_addr);
		m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		    sizeof(struct in6_addr),
		    (caddr_t) &sdst.sin6.sin6_addr);
		break;
#endif /* INET6 */
	default:
		DPRINTF(("etherip_input(): invalid protocol %d\n", v));
		m_freem(m);
		etheripstat.etherips_hdrops++;
		return NULL;
	}

	/* Find appropriate gif(4) interface */
	LIST_FOREACH(sc, &gif_softc_list, gif_list) {
		if ((sc->gif_psrc == NULL) ||
		    (sc->gif_pdst == NULL) ||
		    !(sc->gif_if.if_flags & (IFF_UP|IFF_RUNNING)))
			continue;

		if (!memcmp(sc->gif_psrc, &sdst, sc->gif_psrc->sa_len) &&
		    !memcmp(sc->gif_pdst, &ssrc, sc->gif_pdst->sa_len))
			break;
	}

	/* None found. */
	if (sc == NULL) {
		DPRINTF(("etherip_input(): no interface found\n"));
		etheripstat.etherips_noifdrops++;
		m_freem(m);
		return NULL;
	}

	return sc;
}

int
etherip_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int proto)
{
	struct ip *ipo;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif /* INET6 */
	struct etherip_header eip;
	ushort hlen;

	/* Some address family sanity checks. */
	if ((tdb->tdb_src.sa.sa_family != 0) &&
	    (tdb->tdb_src.sa.sa_family != AF_INET) &&
	    (tdb->tdb_src.sa.sa_family != AF_INET6)) {
		DPRINTF(("etherip_output(): IP in protocol-family <%d> "
		    "attempted, aborting", tdb->tdb_src.sa.sa_family));
		etheripstat.etherips_adrops++;
		m_freem(m);
		return EINVAL;
	}

	if ((tdb->tdb_dst.sa.sa_family != AF_INET) &&
	    (tdb->tdb_dst.sa.sa_family != AF_INET6)) {
		DPRINTF(("etherip_output(): IP in protocol-family <%d> "
		    "attempted, aborting", tdb->tdb_dst.sa.sa_family));
		etheripstat.etherips_adrops++;
		m_freem(m);
		return EINVAL;
	}

	if (tdb->tdb_dst.sa.sa_family != tdb->tdb_src.sa.sa_family) {
		DPRINTF(("etherip_output(): mismatch in tunnel source and "
		    "destination address protocol families (%d/%d), aborting",
		    tdb->tdb_src.sa.sa_family, tdb->tdb_dst.sa.sa_family));
		etheripstat.etherips_adrops++;
		m_freem(m);
		return EINVAL;
	}

	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		hlen = sizeof(struct ip);
		break;
#ifdef INET6
	case AF_INET6:
		hlen = sizeof(struct ip6_hdr);
		break;
#endif /* INET6 */
	default:
		DPRINTF(("etherip_output(): unsupported tunnel protocol "
		    "family <%d>, aborting", tdb->tdb_dst.sa.sa_family));
		etheripstat.etherips_adrops++;
		m_freem(m);
		return EINVAL;
	}

	if (proto == IPPROTO_ETHERIP)
		/* Don't forget the EtherIP header. */
		hlen += sizeof(struct etherip_header);

	M_PREPEND(m, hlen, M_DONTWAIT);
	if (m == NULL) {
		DPRINTF(("etherip_output(): M_PREPEND failed\n"));
		etheripstat.etherips_adrops++;
		return ENOBUFS;
	}

	/*
	 * Normalize mbuf so that it can be reinjected into higherlevel
	 * output functions (alignment also required in this function).
	 */
	if ((long)mtod(m, caddr_t) & 0x03) {
		int off = (long)mtod(m, caddr_t) & 0x03;
		if (M_LEADINGSPACE(m) < off)
			panic("etherip_output: no space for align fixup");
		m->m_data -= off;
		memmove(mtod(m, caddr_t), mtod(m, caddr_t) + off, m->m_len);
	}

	/* Statistics */
	etheripstat.etherips_opackets++;
	etheripstat.etherips_obytes += m->m_pkthdr.len - hlen;

	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		ipo = mtod(m, struct ip *);

		ipo->ip_v = IPVERSION;
		ipo->ip_hl = 5;
		ipo->ip_len = htons(m->m_pkthdr.len);
		ipo->ip_ttl = ip_defttl;
		ipo->ip_p = proto;
		ipo->ip_tos = 0;
		ipo->ip_off = 0;
		ipo->ip_sum = 0;
		ipo->ip_id = htons(ip_randomid());

		/*
		 * We should be keeping tunnel soft-state and send back
		 * ICMPs as needed.
		 */

		ipo->ip_src = tdb->tdb_src.sin.sin_addr;
		ipo->ip_dst = tdb->tdb_dst.sin.sin_addr;
		break;
#ifdef INET6
	case AF_INET6:
		ip6 = mtod(m, struct ip6_hdr *);

		ip6->ip6_flow = 0;
		ip6->ip6_nxt = proto;
		ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
		ip6->ip6_vfc |= IPV6_VERSION;
		ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
		ip6->ip6_hlim = ip_defttl;
		ip6->ip6_dst = tdb->tdb_dst.sin6.sin6_addr;
		ip6->ip6_src = tdb->tdb_src.sin6.sin6_addr;
		break;
#endif /* INET6 */
	}

	if (proto == IPPROTO_ETHERIP) {
		/*
		 * OpenBSD developers convinced IETF folk to create a
		 * "version 3" protocol which would solve a byte order
		 * problem -- our discussion placed "3" into the first byte.
		 * They knew we were starting to deploy this.  When IETF
		 * published the standard this had changed to a nibble...
		 * but they failed to inform us.  Awesome.
		 * 
		 * We will transition step by step to the new model.
		 */
		eip.eip_ver = ETHERIP_VERSION;
		eip.eip_res = 0;
		eip.eip_pad = 0;
		m_copyback(m, hlen - sizeof(struct etherip_header),
		    sizeof(struct etherip_header), &eip, M_NOWAIT);
	}

	*mp = m;

	return 0;
}

int
etherip_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case ETHERIPCTL_ALLOW:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &etherip_allow));
	case ETHERIPCTL_STATS:
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &etheripstat, sizeof(etheripstat)));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


1.85
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.84 2017/03/07 23:35:06 jca Exp $  */
d100 1
a100 1
			m_freem(*mp);
d114 1
a114 1
		m_freem(*mp);
@


1.84
log
@Rename struct etheripstat members for consistency, move them all to 64bits

Will make transition to percpu counters easier.  ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.83 2017/01/29 19:58:47 bluhm Exp $  */
d91 1
a91 1
etherip_input(struct mbuf **mp, int *offp, int proto)
@


1.83
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.82 2017/01/25 17:34:31 bluhm Exp $  */
d99 1
a99 1
			etheripstat.etherip_pdrops++;
d113 1
a113 1
		etheripstat.etherip_pdrops++;
d127 1
a127 1
	etheripstat.etherip_ipackets++;
d136 1
a136 1
		etheripstat.etherip_hdrops++;
d148 1
a148 1
		etheripstat.etherip_adrops++;
d157 1
a157 1
		etheripstat.etherip_adrops++;
d168 1
a168 1
			etheripstat.etherip_adrops++;
d178 1
a178 1
		etheripstat.etherip_noifdrops++;
d187 1
a187 1
	etheripstat.etherip_ibytes += m->m_pkthdr.len;
d207 1
a207 1
	etheripstat.etherip_ipackets++;
d215 1
a215 1
		etheripstat.etherip_hdrops++;
d225 1
a225 1
			etheripstat.etherip_adrops++;
d238 1
a238 1
	etheripstat.etherip_ibytes += m->m_pkthdr.len;
d296 1
a296 1
		etheripstat.etherip_hdrops++;
d315 1
a315 1
		etheripstat.etherip_noifdrops++;
d339 1
a339 1
		etheripstat.etherip_adrops++;
d348 1
a348 1
		etheripstat.etherip_adrops++;
d357 1
a357 1
		etheripstat.etherip_adrops++;
d374 1
a374 1
		etheripstat.etherip_adrops++;
d386 1
a386 1
		etheripstat.etherip_adrops++;
d403 2
a404 2
	etheripstat.etherip_opackets++;
	etheripstat.etherip_obytes += m->m_pkthdr.len - hlen;
@


1.82
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.81 2016/09/24 14:51:37 naddy Exp $  */
a88 1
 * Only a wrapper for the IPv4 case.
a89 34
void
etherip_input(struct mbuf *m, int iphlen, int proto)
{
	struct ip *ip;

	ip = mtod(m, struct ip *);

	switch (ip->ip_p) {
#if NBRIDGE > 0
	case IPPROTO_ETHERIP:
		/* If we do not accept EtherIP explicitly, drop. */
		if (!etherip_allow && (m->m_flags & (M_AUTH|M_CONF)) == 0) {
			DPRINTF(("etherip_input(): dropped due to policy\n"));
			etheripstat.etherip_pdrops++;
			m_freem(m);
			return;
		}
		etherip_decap(m, iphlen);
		return;
#endif
#ifdef MPLS
	case IPPROTO_MPLS:
		mplsip_decap(m, iphlen);
		return;
#endif
	default:
		DPRINTF(("etherip_input(): dropped, unhandled protocol\n"));
		etheripstat.etherip_pdrops++;
		m_freem(m);
		return;
	}
}

#ifdef INET6
d91 1
a91 1
etherip_input6(struct mbuf **mp, int *offp, int proto)
d98 1
a98 1
			DPRINTF(("etherip_input6(): dropped due to policy\n"));
d112 1
a112 1
		DPRINTF(("etherip_input6(): dropped, unhandled protocol\n"));
a117 1
#endif
@


1.81
log
@ANSIfy netinet/; from David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.80 2015/12/02 08:47:00 claudio Exp $  */
d92 1
a92 1
etherip_input(struct mbuf *m, ...)
a94 2
	va_list ap;
	int iphlen;
a96 4

	va_start(ap, m);
	iphlen = va_arg(ap, int);
	va_end(ap);
@


1.80
log
@Rework the MPLS handling. Remove the lookup loops since nothing is using
them and they make everything so much harder with no gain. Remove the
ifp argument from mpls_input since it is not needed. On the input side
the lookup side is modified a bit when it comes to BOS handling.
Tested in a L3VPN setup with ldpd and bgpd. Commiting now so we can move
on with cleaning up rt_ifp usage. If this breaks L2VPN I will fix it once
reported. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.79 2015/11/07 12:42:19 mpi Exp $  */
d510 2
a511 5
etherip_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp, *newp;
	size_t *oldlenp, newlen;
@


1.79
log
@Use input handlers for bridge(4).

This allows more flexible configurations with vlan(4) and bridge(4) on
top of the same physical interface.  In particular it allows to not feed
VLAN tagget packets into a bridge(4).

Fix regression reported by Armin Wolfermann on bugs@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.78 2015/07/31 15:38:10 rzalamena Exp $  */
d296 1
a296 1
	mpls_input(&sc->gif_if, m);
@


1.78
log
@Removed uninitialized pointer usage, we didn't need to use it there anyway.

Thanks to Patrick Wild for noticing that!

ok mpi@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.77 2015/07/29 00:04:03 rzalamena Exp $  */
d167 1
a167 1
	int s;
a233 10
#if NBPFILTER > 0
	if (sc->gif_if.if_bpf)
		bpf_mtap_af(sc->gif_if.if_bpf, AF_LINK, m, BPF_DIRECTION_IN);
#endif

	/*
	 * Tap the packet off here for a bridge. bridge_input() returns
	 * NULL if it has consumed the packet.  In the case of gif's,
	 * bridge_input() returns non-NULL when an error occurs.
	 */
a236 10
	m->m_pkthdr.ph_ifidx = sc->gif_if.if_index;
	m->m_pkthdr.ph_rtableid = sc->gif_if.if_rdomain;
	if (m->m_flags & (M_BCAST|M_MCAST))
		sc->gif_if.if_imcasts++;

	s = splnet();
	m = bridge_input(&sc->gif_if, m);
	splx(s);
	if (m == NULL)
		return;
d238 2
a239 3
	etheripstat.etherip_noifdrops++;
	m_freem(m);
	return;
@


1.77
log
@Don't use mpls_input() as input handler anymore and instead call it
directly. Also protect non mp-safe functions while at it.

ok mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.76 2015/07/20 21:16:39 rzalamena Exp $  */
a268 9

	/*
	 * Avoid going through all the code if the interface doesn't have
	 * the appropriate flag.
	 */
	if ((sc->gif_if.if_xflags & IFXF_MPLS) == 0) {
		m_freem(m);
		return;
	}
@


1.76
log
@Kill NETISR_MPLS, from now on we will use interface input handlers to deal
with MPLS packets.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.75 2015/07/15 17:33:48 deraadt Exp $  */
a268 2
	int s;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
d270 4
d326 1
a326 5
	ml_enqueue(&ml, m);

	s = splnet();
	if_input(&sc->gif_if, &ml);
	splx(s);
@


1.75
log
@rename mbuf ** parameter from m to mp, to match other similar code
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.74 2015/07/02 09:40:03 mpi Exp $  */
d269 7
d324 1
a324 2
	if (niq_enqueue(&mplsintrq, m) != 0) {
		etheripstat.etherip_qfull++;
d326 3
a328 3
		DPRINTF(("mplsip_input(): packet dropped because of full "
		    "queue\n"));
	}
@


1.74
log
@By design if_input_process() needs to hold a reference on the receiving
ifp in order to access its ifih handlers.

So get rid of if_get() in the various ifih handlers we know the ifp is
live at this point.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.73 2015/06/23 09:42:23 mpi Exp $  */
d132 1
a132 1
etherip_input6(struct mbuf **m, int *offp, int proto)
d138 1
a138 1
		if (!etherip_allow && ((*m)->m_flags & (M_AUTH|M_CONF)) == 0) {
d141 1
a141 1
			m_freem(*m);
d144 1
a144 1
		etherip_decap(*m, *offp);
d149 1
a149 1
		mplsip_decap(*m, *offp);
d155 1
a155 1
		m_freem(*m);
@


1.73
log
@Adapt bridge(4) to the new if_input() framework.

Move bridge_input() outside of ether_input() in order to duplicate packets
flowing through a bridge port before applying any transformation on mbufs.

This saves a various m_adj(9)/M_PREPEND(9) dances and remove the bridge(4)
hack from vlan(4).

Tested by mxb <mxb AT alumni DOT chalmers DOT se> and kettenis@@

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.72 2015/06/16 11:09:40 mpi Exp $  */
d253 1
a253 1
	m = bridge_input(m);
@


1.72
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.71 2015/04/10 13:58:20 dlg Exp $  */
a164 1
	struct ether_header eh;
a230 3
	/* Copy ethernet header */
	m_copydata(m, 0, sizeof(eh), (void *) &eh);

d232 1
a232 8
	m->m_flags &= ~(M_BCAST|M_MCAST|M_AUTH|M_CONF);
	if (eh.ether_dhost[0] & 1) {
		if (memcmp(etherbroadcastaddr, eh.ether_dhost,
		    sizeof(etherbroadcastaddr)) == 0)
			m->m_flags |= M_BCAST;
		else
			m->m_flags |= M_MCAST;
	}
a238 3
	/* Trim the beginning of the mbuf, to remove the ethernet header. */
	m_adj(m, sizeof(struct ether_header));

d253 1
a253 1
	m = bridge_input(&sc->gif_if, &eh, m);
@


1.71
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.70 2014/12/19 17:14:40 tedu Exp $  */
d261 1
a261 1
	m->m_pkthdr.rcvif = &sc->gif_if;
d325 1
a325 1
	m->m_pkthdr.rcvif = &sc->gif_if;
@


1.70
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.69 2014/09/14 14:17:26 jsg Exp $  */
a282 2
	struct ifqueue *ifq;
	int s;
d331 1
a331 5
	ifq = &mplsintrq;
	s = splnet();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
a332 1
		splx(s);
a335 1
		return;
a336 4
	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_MPLS);
	splx(s);
	return;
@


1.69
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.68 2014/07/22 11:06:10 mpi Exp $  */
a42 1
#ifdef INET
a46 1
#endif /* INET */
a86 1
#ifdef INET
a128 1
#endif
a364 1
#ifdef INET
a374 1
#endif /* INET */
a419 1
#ifdef INET
a420 1
#endif /* INET */
a456 1
#ifdef INET
a459 1
#endif /* INET */
a500 1
#ifdef INET
a521 1
#endif /* INET */
@


1.68
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.67 2014/07/14 12:18:30 deraadt Exp $  */
a35 1
#include <sys/proc.h>
@


1.67
log
@In the next step, stop accepting the nibble-swapped protocol for 5.6.
This completes the transition.  A cvs log and diff will tell the story
of why we went through this.
with david.dahlberg@@fkie.fraunhofer.de and claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.66 2014/04/14 09:06:42 mpi Exp $  */
a45 1
#include <netinet/in_systm.h>
@


1.66
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.65 2014/01/09 06:29:06 tedu Exp $  */
d192 1
a192 1
	if (eip.eip_ver == ETHERIP_VERSION && eip.eip_oldver == 0) {
a193 11
	} else if (eip.eip_oldver == ETHERIP_VERSION && eip.eip_ver == 0) {
		/*
		 * OpenBSD developers convinced IETF folk to create a
		 * "version 3" protocol which would solve a byte order
		 * problem -- our discussion placed "3" into the first byte.
		 * They knew we were starting to deploy this.  When IETF
		 * published the standard this had changed to a nibble...
		 * but they failed to inform us.  Awesome.
		 *
		 * For backwards compat, for a while, we must accept either.
		 */
d564 1
a564 1
		eip.eip_oldver = 0;
@


1.65
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.64 2013/12/31 03:24:44 tedu Exp $  */
d279 1
a279 1
	m->m_pkthdr.rdomain = sc->gif_if.if_rdomain;
d345 1
a345 1
	m->m_pkthdr.rdomain = sc->gif_if.if_rdomain;
@


1.64
log
@bcopy -> memcpy. reviewed with one fix from matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.63 2013/11/06 17:08:57 deraadt Exp $  */
d255 2
a256 2
		if (bcmp((caddr_t) etherbroadcastaddr,
		    (caddr_t)eh.ether_dhost, sizeof(etherbroadcastaddr)) == 0)
d377 2
a378 2
	bzero(&ssrc, sizeof(ssrc));
	bzero(&sdst, sizeof(sdst));
d420 2
a421 2
		if (!bcmp(sc->gif_psrc, &sdst, sc->gif_psrc->sa_len) &&
		    !bcmp(sc->gif_pdst, &ssrc, sc->gif_pdst->sa_len))
@


1.63
log
@See previous commit.  This is the next step in the process.  The code now
accepts either format, but we start using the IETF bits.  Hopefully we
get a mail later again from David Dahlberg reminding us to remove the
legacy acceptance.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.62 2013/01/14 23:06:09 deraadt Exp $  */
d516 1
a516 1
		bcopy(mtod(m, caddr_t) + off, mtod(m, caddr_t), m->m_len);
@


1.62
log
@after OpenBSD requested a etherip rev 3 to solve a byte order weakness, and
worked with them to define a specific format, ietf quietly changed their
mind and did something different.
First step of transitioning over two release -- accept both types, but
continue sending old format.
pointed out by david.dahlberg@@fkie.fraunhofer.de
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.61 2012/10/05 17:17:04 camield Exp $  */
d574 2
a575 2
		eip.eip_ver = 0;
		eip.eip_oldver = ETHERIP_VERSION;
@


1.61
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.60 2012/10/05 12:29:15 camield Exp $  */
d192 14
a205 1
	if ((eip.eip_ver & ETHERIP_VER_VERS_MASK) != ETHERIP_VERSION) {
a212 13
	/*
	 * Note that the other potential failure of the above check is that the
	 * second nibble of the EtherIP header (the reserved part) is not
	 * zero; this is also invalid protocol behaviour.
	 */
	if (eip.eip_ver & ETHERIP_VER_RSVD_MASK) {
		DPRINTF(("etherip_input(): received EtherIP invalid EtherIP "
		    "header (reserved field non-zero\n"));
		etheripstat.etherip_adrops++;
		m_freem(m);
		return;
	}

d564 12
a575 2
		/* Set the version number */
		eip.eip_ver = ETHERIP_VERSION & ETHERIP_VER_VERS_MASK;
@


1.60
log
@missing include for pf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.59 2012/09/26 14:53:23 markus Exp $  */
d236 1
a236 1
	if (sc->gif_if.if_bridge == NULL) {
@


1.59
log
@add M_ZEROIZE as an mbuf flag, so copied PFKEY messages (with embedded keys)
are cleared as well; from hshoexer@@, feedback and ok bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.58 2011/07/04 20:42:15 dhill Exp $  */
d62 3
@


1.58
log
@No need to check proto == IPPROTO_ETHERIP
fix two typos (protcol -> protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.57 2011/04/13 22:15:59 markus Exp $  */
d250 1
a250 1
	m->m_flags &= ~(M_BCAST|M_MCAST|M_AUTH|M_CONF|M_AUTH_AH);
@


1.57
log
@add missing #include "pf.h" for NPF; ok mikeb, claudio, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.56 2010/10/28 16:36:16 claudio Exp $  */
d125 1
a125 1
		DPRINTF(("etherip_input(): dropped, unhandled protcol \n"));
d141 1
a141 2
		if (proto == IPPROTO_ETHERIP && !etherip_allow &&
		    ((*m)->m_flags & (M_AUTH|M_CONF)) == 0) {
d156 1
a156 1
		DPRINTF(("etherip_input6(): dropped, unhandled protcol \n"));
@


1.56
log
@Normalize mbuf after prepending space for the header since the data
in the mbuf my be improperly aligned. Whenever a function is
reinjecting packets from low level output functions into high level
output functions (like ip_output) it must be guaranteed that the
mbuf data is properliy aligned.
OK blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.55 2010/07/02 02:40:16 blambert Exp $  */
d30 1
@


1.55
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.54 2010/05/11 09:36:07 claudio Exp $  */
d502 12
@


1.54
log
@Massiv cleanup of the gif(4) mess. Move encapsulation into gif_output()
where it is not necessary to guess protocols by looking at the first nibble.
in_gif_output() will encapsulate the packet but not send it. Because of
etherip support and the way the bridge works a minimal hack is needed in
gif_start() to ensure that the bridged packets are encapsulated as well.
This actually started with the idea to add MPLS support but that turned out
to be not as simple as in the gre(4) case.
Tested by myself (IP, IPv6, etherip, MPLS), sthen@@ (IP, IPv6), naddy (IPv6)
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.53 2010/04/20 22:05:43 tedu Exp $  */
d553 1
a553 1
		    sizeof(struct etherip_header), &eip);
@


1.53
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.52 2009/11/21 14:08:14 claudio Exp $  */
d38 1
d40 1
a41 1
#include <net/bpf.h>
d53 4
d58 4
a61 1
#include <net/if_gif.h>
a62 1
#include "gif.h"
d71 8
d87 1
d89 2
a90 4
 * etherip_input gets called when we receive an encapsulated packet,
 * either because we got it at a real interface, or because AH or ESP
 * were being used in tunnel mode (in which case the rcvif element will
 * contain the address of the encX interface associated with the tunnel.
a91 1

d95 2
a96 2
	union sockaddr_union ssrc, sdst;
	struct ether_header eh;
a97 3
	struct etherip_header eip;
	u_int8_t v;
	va_list ap;
d99 1
a99 6
#if NGIF > 0
	struct gif_softc *sc;
#if NBRIDGE > 0
	int s;
#endif /* NBRIDGE */
#endif /* NGIF */
d105 20
a124 5
	etheripstat.etherip_ipackets++;

	/* If we do not accept EtherIP explicitly, drop. */
	if (!etherip_allow && (m->m_flags & (M_AUTH|M_CONF)) == 0) {
		DPRINTF(("etherip_input(): dropped due to policy\n"));
d129 45
d191 1
a191 1
		    "%d not suppoorted\n", (v >> 4) & 0xff));
d230 143
d407 1
a407 1
		return /* EAFNOSUPPORT */;
a409 20
	/* Chop off the `outer' IP and EtherIP headers and reschedule. */
	m_adj(m, iphlen + sizeof(struct etherip_header));

	/* Statistics */
	etheripstat.etherip_ibytes += m->m_pkthdr.len;

	/* Copy ethernet header */
	m_copydata(m, 0, sizeof(eh), (void *) &eh);

	/* Reset the flags based on the inner packet */
	m->m_flags &= ~(M_BCAST|M_MCAST|M_AUTH|M_CONF|M_AUTH_AH);
	if (eh.ether_dhost[0] & 1) {
		if (bcmp((caddr_t) etherbroadcastaddr,
		    (caddr_t)eh.ether_dhost, sizeof(etherbroadcastaddr)) == 0)
			m->m_flags |= M_BCAST;
		else
			m->m_flags |= M_MCAST;
	}

#if NGIF > 0
d418 1
a418 2
		    !bcmp(sc->gif_pdst, &ssrc, sc->gif_pdst->sa_len) &&
		    sc->gif_if.if_bridge != NULL)
d427 1
a427 1
		return;
a428 18
#if NBPFILTER > 0
	if (sc->gif_if.if_bpf)
		bpf_mtap_af(sc->gif_if.if_bpf, AF_LINK, m, BPF_DIRECTION_IN);
#endif

	/* Trim the beginning of the mbuf, to remove the ethernet header. */
	m_adj(m, sizeof(struct ether_header));

#if NBRIDGE > 0
	/*
	 * Tap the packet off here for a bridge. bridge_input() returns
	 * NULL if it has consumed the packet.  In the case of gif's,
	 * bridge_input() returns non-NULL when an error occurs.
	 */
	m->m_pkthdr.rcvif = &sc->gif_if;
	m->m_pkthdr.rdomain = sc->gif_if.if_rdomain;
	if (m->m_flags & (M_BCAST|M_MCAST))
		sc->gif_if.if_imcasts++;
d430 1
a430 11
	s = splnet();
	m = bridge_input(&sc->gif_if, &eh, m);
	splx(s);
	if (m == NULL)
		return;
#endif /* NBRIDGE */
#endif /* NGIF */

	etheripstat.etherip_noifdrops++;
	m_freem(m);
	return;
d434 1
a434 2
etherip_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
	       int protoff)
a438 1

a441 1

a442 1
	struct mbuf *m0;
d493 7
a499 12
	/* Don't forget the EtherIP header. */
	hlen += sizeof(struct etherip_header);

	if (!(m->m_flags & M_PKTHDR)) {
		DPRINTF(("etherip_output(): mbuf is not a header\n"));
		m_freem(m);
		return (ENOBUFS);
	}

	MGETHDR(m0, M_DONTWAIT, MT_DATA);
	if (m0 == NULL) {
		DPRINTF(("etherip_output(): M_GETHDR failed\n"));
a500 1
		m_freem(m);
a502 5
	M_MOVE_PKTHDR(m0, m);
	m0->m_next = m;
	m0->m_len = hlen;
	m0->m_pkthdr.len += hlen;
	m = m0;
d517 1
a517 1
		ipo->ip_p = IPPROTO_ETHERIP;
d537 1
a537 1
		ip6->ip6_nxt = IPPROTO_ETHERIP;
d548 7
a554 5
	/* Set the version number */
	eip.eip_ver = ETHERIP_VERSION & ETHERIP_VER_VERS_MASK;
	eip.eip_pad = 0;
	m_copyback(m, hlen - sizeof(struct etherip_header),
	    sizeof(struct etherip_header), &eip);
@


1.52
log
@Add a way to bind the tunnel endpoint of a gif/gre interface into a
different rdomain than the default one. This allows to do MPLS VPNs
without the MPLS madness.  OK deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.51 2007/12/14 18:33:41 deraadt Exp $  */
d35 1
@


1.51
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.50 2007/02/20 19:37:40 claudio Exp $  */
d256 1
@


1.50
log
@Fix the bpf hook in etherip_input() by using the right address family and
moving the m_adj() down to prevent so that the ethernet header is preserved.
This fixes tcpdump on bridged gif(4) interfaces. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.49 2006/03/25 22:41:48 djm Exp $  */
d428 5
@


1.49
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.48 2005/07/31 03:52:19 pascoe Exp $  */
a219 3
	/* Trim the beginning of the mbuf, to remove the ethernet header. */
	m_adj(m, sizeof(struct ether_header));

d243 1
a243 2
		bpf_mtap_af(sc->gif_if.if_bpf, sdst.sa.sa_family, m,
		    BPF_DIRECTION_IN);
d245 3
@


1.48
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.47 2004/11/17 12:06:16 markus Exp $  */
d246 2
a247 1
		bpf_mtap_af(sc->gif_if.if_bpf, sdst.sa.sa_family, m);
@


1.47
log
@ip6_plen does not include the size of the ipv6 header; ok itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.46 2003/12/03 14:51:05 markus Exp $  */
d245 2
a246 11
	if (sc->gif_if.if_bpf) {
		struct mbuf m0;
		u_int32_t af = sdst.sa.sa_family;

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *)&af;

		bpf_mtap(sc->gif_if.if_bpf, &m0);
	}
@


1.46
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.45 2003/08/14 19:00:12 jason Exp $  */
d403 1
a403 1
		ip6->ip6_plen = htons(m->m_pkthdr.len);
@


1.45
log
@m_copyback()'s 4th arg is const void *, nuke (caddr_t) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.44 2003/05/03 01:43:07 itojun Exp $  */
d89 1
a89 1
	int i;
d225 4
a228 4
	for (i = 0; i < ngif; i++) {
		if ((gif_softc[i].gif_psrc == NULL) ||
		    (gif_softc[i].gif_pdst == NULL) ||
		    !(gif_softc[i].gif_if.if_flags & (IFF_UP|IFF_RUNNING)))
d231 3
a233 3
		if (!bcmp(gif_softc[i].gif_psrc, &sdst, gif_softc[i].gif_psrc->sa_len) &&
		    !bcmp(gif_softc[i].gif_pdst, &ssrc, gif_softc[i].gif_pdst->sa_len) &&
		    gif_softc[i].gif_if.if_bridge != NULL)
d238 1
a238 1
	if (i >= ngif) {
d245 1
a245 1
	if (gif_softc[i].gif_if.if_bpf) {
d254 1
a254 1
		bpf_mtap(gif_softc[i].gif_if.if_bpf, &m0);
d264 1
a264 1
	m->m_pkthdr.rcvif = &gif_softc[i].gif_if;
d266 1
a266 1
		gif_softc[i].gif_if.if_imcasts++;
d269 1
a269 1
	m = bridge_input(&gif_softc[i].gif_if, &eh, m);
@


1.44
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.43 2003/03/06 11:54:06 markus Exp $  */
d415 1
a415 1
	    sizeof(struct etherip_header), (caddr_t)&eip);
@


1.43
log
@set ip6_nxt to IPPROTO_ETHERIP; ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.42 2003/03/06 09:43:35 markus Exp $  */
d249 1
@


1.42
log
@bpf_mtap incoming proto 97 traffic; ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.41 2002/10/15 14:52:46 jason Exp $  */
d399 1
@


1.41
log
@Note that this is based on RFC3378.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.40 2002/06/09 16:26:10 itojun Exp $  */
d39 1
d55 1
d244 12
@


1.40
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.39 2002/06/09 00:58:32 angelos Exp $  */
d26 1
a26 1
 * Ethernet-inside-IP processing
@


1.39
log
@Set/clear M_AUTH_AH.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.38 2002/03/24 19:26:14 niklas Exp $  */
d8 1
a8 1
 *	
d12 1
a12 1
 * modification of this software. 
d72 1
a72 1
 * were being used in tunnel mode (in which case the rcvif element will 
d371 1
a371 1
		/* 
@


1.38
log
@m_freem(NULL) bad style, ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.37 2002/03/15 18:19:52 millert Exp $  */
d209 1
a209 1
	m->m_flags &= ~(M_BCAST|M_MCAST|M_AUTH|M_CONF);
@


1.37
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.36 2001/11/29 08:20:50 itojun Exp $  */
a157 1
			m_freem(m);
@


1.36
log
@etherip_output() is called from in_gif.c, therefore is outside of #ifdef IPSEC
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.35 2001/07/27 15:48:38 itojun Exp $  */
a76 1
#if __STDC__
a77 5
#else
etherip_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.36.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.36 2001/11/29 08:20:50 itojun Exp $  */
d77 1
d79 5
d164 1
d216 1
a216 1
	m->m_flags &= ~(M_BCAST|M_MCAST|M_AUTH|M_CONF|M_AUTH_AH);
@


1.36.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.36.2.1 2002/06/11 03:31:36 art Exp $  */
d8 1
a8 1
 *
d12 1
a12 1
 * modification of this software.
d26 1
a26 1
 * Ethernet-inside-IP processing (RFC3378).
d72 1
a72 1
 * were being used in tunnel mode (in which case the rcvif element will
d371 1
a371 1
		/*
@


1.36.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$  */
a38 1
#include <net/bpf.h>
a53 1
#include "bpfilter.h"
a241 13
#if NBPFILTER > 0
	if (gif_softc[i].gif_if.if_bpf) {
		struct mbuf m0;
		u_int32_t af = sdst.sa.sa_family;

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *)&af;

		bpf_mtap(gif_softc[i].gif_if.if_bpf, &m0);
	}
#endif
a384 1
		ip6->ip6_nxt = IPPROTO_ETHERIP;
@


1.35
log
@variable name "gif" is way too generic - use "gif_softc".  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.34 2001/06/27 03:49:53 angelos Exp $  */
a272 1
#ifdef IPSEC
a411 1
#endif /* IPSEC */
@


1.34
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.33 2001/06/26 04:29:05 angelos Exp $  */
d231 3
a233 2
		if ((gif[i].gif_psrc == NULL) || (gif[i].gif_pdst == NULL) ||
		    !(gif[i].gif_if.if_flags & (IFF_UP|IFF_RUNNING)))
d236 3
a238 3
		if (!bcmp(gif[i].gif_psrc, &sdst, gif[i].gif_psrc->sa_len) &&
		    !bcmp(gif[i].gif_pdst, &ssrc, gif[i].gif_pdst->sa_len) &&
		    gif[i].gif_if.if_bridge != NULL)
d256 1
a256 1
	m->m_pkthdr.rcvif = &gif[i].gif_if;
d258 1
a258 1
		gif[i].gif_if.if_imcasts++;
d261 1
a261 1
	m = bridge_input(&gif[i].gif_if, &eh, m);
@


1.33
log
@More KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.32 2001/06/25 05:11:58 angelos Exp $  */
d353 1
a353 1
	M_COPY_PKTHDR(m0, m);
@


1.32
log
@Copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.31 2001/06/25 02:54:44 angelos Exp $  */
d128 2
a129 1
		DPRINTF(("etherip_input(): received EtherIP version number %d not suppoorted\n", (v >> 4) & 0xff));
d141 2
a142 1
		DPRINTF(("etherip_input(): received EtherIP invalid EtherIP header (reserved field non-zero\n"));
d150 2
a151 1
		DPRINTF(("etherip_input(): received EtherIP invalid pad value\n"));
d169 1
a169 1
	/* Copy the addresses for use later */
d179 2
a180 1
		m_copydata(m, offsetof(struct ip, ip_src), sizeof(struct in_addr),
d182 2
a183 1
		m_copydata(m, offsetof(struct ip, ip_dst), sizeof(struct in_addr),
d225 1
a225 1
	/* Trim the beginning of the mbuf, to remove the ethernet header */
d241 1
a241 1
	/* None found */
d289 1
a289 1
	/* Some address family sanity checks */
d293 2
a294 2
		DPRINTF(("etherip_output(): IP in protocol-family <%d> attempted, aborting",
		    tdb->tdb_src.sa.sa_family));
d302 2
a303 2
		DPRINTF(("etherip_output(): IP in protocol-family <%d> attempted, aborting",
		    tdb->tdb_dst.sa.sa_family));
d310 2
a311 1
		DPRINTF(("etherip_output(): mismatch in tunnel source and destination address protocol families (%d/%d), aborting",
d330 2
a331 2
		DPRINTF(("etherip_output(): unsupported tunnel protocol family <%d>, aborting",
		    tdb->tdb_dst.sa.sa_family));
d337 1
a337 1
	/* Don't forget the EtherIP header */
d427 2
a428 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &etherip_allow));
@


1.31
log
@Don't double-clear M_PKTHDR/tags.
@
text
@d1 1
a1 2
/*	$OpenBSD: ip_ether.c,v 1.30 2001/06/23 16:15:56 fgsch Exp $  */

d7 1
a7 1
 * Copyright (C) 1999 by Angelos D. Keromytis.
d9 1
a9 1
 * Permission to use, copy, and modify this software without fee
@


1.30
log
@Remove unneeded ip_id convertions.
Instead of using HTONS macro in some places, use htons directly in the
struct member and save us a few bytes.
Fix comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.29 2001/06/19 00:48:22 deraadt Exp $  */
a351 2
	m_tag_init(m);
	m->m_flags &= ~M_PKTHDR;
@


1.29
log
@mop up after angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.28 2001/06/08 03:53:45 angelos Exp $  */
d373 1
a373 2
		ipo->ip_id = ip_randomid();
		HTONS(ipo->ip_id);
@


1.28
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.27 2001/05/27 11:52:21 angelos Exp $  */
d33 1
@


1.27
log
@Reset pkthdr on old mbuf head.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.26 2001/04/06 04:42:08 csapuntz Exp $  */
a32 2
#include <sys/systm.h>
#include <sys/malloc.h>
a33 1
#include <sys/domain.h>
a34 2
#include <sys/time.h>
#include <sys/kernel.h>
a38 1
#include <net/netisr.h>
a44 1
#include <netinet/in_var.h>
a47 1
#include <netinet/ip_ipsp.h>
a49 1
#include <dev/rndvar.h>
@


1.26
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.25 2001/02/07 20:52:13 mickey Exp $  */
d360 2
@


1.25
log
@allow gif-less compile
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.24 2001/02/06 02:50:02 jason Exp $  */
a67 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.24
log
@- bridge_input() expects to be called at splnet(), not splsoftnet()
- add a bit more debugging (controlled by ENCDEBUG and encdebug)
- turn off several more m_flags that may have been set by the higher layers
(so any sharing of mbuf's in the return direction doesn't confuse the upper
layers)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.23 2001/02/03 21:38:38 jason Exp $  */
a106 1
#endif /* NGIF */
d110 1
@


1.23
log
@- define and use EtherIP version 3 (2 byte padded header instead of the
single byte header used in V2), and drop support for V2.
- that done, remove some of the buffer copies that were used as alignment shims
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.22 2001/02/03 19:45:03 jason Exp $  */
d108 3
d208 1
d223 2
a224 1
	m->m_flags &= ~(M_BCAST|M_MCAST);
d266 2
d269 1
d346 6
@


1.22
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.21 2001/02/02 08:28:20 jason Exp $  */
d100 1
a100 2
	struct mbuf *mrest, *m0;
	int iphlen, clen;
d156 8
a230 26
	/* Copy out the first MHLEN bytes of data to ensure correct alignment */
	MGETHDR(m0, M_DONTWAIT, MT_DATA);
	if (m0 == NULL) {
		m_freem(m);
		etheripstat.etherip_adrops++;
		return;
	}
	M_COPY_PKTHDR(m0, m);
	clen = min(MHLEN, m->m_pkthdr.len);
	if (m->m_pkthdr.len == clen)
		mrest = NULL;
	else {
		mrest = m_split(m, clen, M_DONTWAIT);
		if (mrest == NULL) {
			m_freem(m);
			m_freem(m0);
			etheripstat.etherip_adrops++;
			return;
		}
	}
	m0->m_next = mrest;
	m0->m_len = clen;
	m_copydata(m, 0, clen, mtod(m0, caddr_t));
	m_freem(m);
	m = m0;

d398 1
@


1.21
log
@a quick checkpoint:
- add a struct etherip_header (will make switching protocol versions a bit easier and give a base for aligning things correctly)
- fix the version/reserved field checking for good this time
- don't need to m_copydata to grab the first byte of an mbuf that you know has t
hat byte
- m_adj() instead of homebrew
- fix M_MCAST/M_BCAST setting (cut/pasto)
- if_imcasts was being updated on the wrong interface
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.20 2001/02/01 20:19:24 jason Exp $  */
d94 2
a95 2
struct mbuf *m;
va_dcl
d98 7
a104 7
    union sockaddr_union ssrc, sdst;
    struct ether_header eh;
    struct mbuf *mrest, *m0;
    int iphlen, clen;
    struct etherip_header eip;
    u_int8_t v;
    va_list ap;
d107 1
a107 1
    int i;
d110 34
a143 14
    va_start(ap, m);
    iphlen = va_arg(ap, int);
    va_end(ap);

    etheripstat.etherip_ipackets++;

    /* If we do not accept EtherIP explicitly, drop. */
    if (!etherip_allow && (m->m_flags & (M_AUTH|M_CONF)) == 0)
    {
	DPRINTF(("etherip_input(): dropped due to policy\n"));
	etheripstat.etherip_pdrops++;
	m_freem(m);
	return;
    }
d145 11
a155 12
    /*
     * Make sure there's at least an ethernet header's and an EtherIP header's
     * worth of worth of data after the outer IP header.
     */
    if (m->m_pkthdr.len < iphlen + sizeof(struct ether_header) +
	sizeof(struct etherip_header))
    {
	DPRINTF(("etherip_input(): encapsulated packet too short\n"));
	etheripstat.etherip_hdrops++;
	m_freem(m);
	return;
    }
d157 11
a167 9
    /* Verify EtherIP version number */
    m_copydata(m, iphlen, sizeof(struct etherip_header), (caddr_t)&eip);
    if ((eip.eip_ver & ETHERIP_VER_VERS_MASK) != ETHERIP_VERSION)
    {
	DPRINTF(("etherip_input(): received EtherIP version number %d not suppoorted\n", (v >> 4) & 0xff));
	etheripstat.etherip_adrops++;
	m_freem(m);
	return;
    }
d169 3
a171 12
    /*
     * Note that the other potential failure of the above check is that the
     * second nibble of the EtherIP header (the reserved part) is not
     * zero; this is also invalid protocol behaviour.
     */
    if (eip.eip_ver & ETHERIP_VER_RSVD_MASK)
    {
	DPRINTF(("etherip_input(): received EtherIP invalid EtherIP header (reserved field non-zero\n"));
	etheripstat.etherip_adrops++;
	m_freem(m);
	return;
    }
d173 2
a174 21
    /* Make sure the ethernet header at least is in the first mbuf. */
    if (m->m_len < iphlen + sizeof(struct ether_header) +
      sizeof(struct etherip_header))
    {
	if ((m = m_pullup(m, iphlen + sizeof(struct ether_header) +
	  sizeof(struct etherip_header))) == NULL)
	{
	    DPRINTF(("etherip_input(): m_pullup() failed\n"));
	    etheripstat.etherip_adrops++;
	    m_freem(m);
	    return;
	}
    }

    /* Copy the addresses for use later */
    bzero(&ssrc, sizeof(ssrc));
    bzero(&sdst, sizeof(sdst));

    v = *mtod(m, u_int8_t *);
    switch (v >> 4)
    {
d177 7
a183 7
	    ssrc.sa.sa_len = sdst.sa.sa_len = sizeof(struct sockaddr_in);
	    ssrc.sa.sa_family = sdst.sa.sa_family = AF_INET;
	    m_copydata(m, offsetof(struct ip, ip_src), sizeof(struct in_addr),
		       (caddr_t) &ssrc.sin.sin_addr);
	    m_copydata(m, offsetof(struct ip, ip_dst), sizeof(struct in_addr),
		       (caddr_t) &sdst.sin.sin_addr);
	    break;
d187 9
a195 9
	    ssrc.sa.sa_len = sdst.sa.sa_len = sizeof(struct sockaddr_in6);
	    ssrc.sa.sa_family = sdst.sa.sa_family = AF_INET6;
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
		       sizeof(struct in6_addr),
		       (caddr_t) &ssrc.sin6.sin6_addr);
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		       sizeof(struct in6_addr),
		       (caddr_t) &sdst.sin6.sin6_addr);
	    break;
d198 51
a248 52
	    m_freem(m);
	    etheripstat.etherip_hdrops++;
	    return /* EAFNOSUPPORT */;
    }

    /* Chop off the `outer' IP and EtherIP headers and reschedule. */
    m_adj(m, iphlen + sizeof(struct etherip_header));

    /* Statistics */
    etheripstat.etherip_ibytes += m->m_pkthdr.len;

    /* Copy ethernet header */
    m_copydata(m, 0, sizeof(eh), (void *) &eh);

    m->m_flags &= ~(M_BCAST|M_MCAST);
    if (eh.ether_dhost[0] & 1)
    {
	if (bcmp((caddr_t) etherbroadcastaddr, (caddr_t) eh.ether_dhost,
	  sizeof(etherbroadcastaddr)) == 0)
	    m->m_flags |= M_BCAST;
	else
	    m->m_flags |= M_MCAST;
    }

    /* Trim the beginning of the mbuf, to remove the ethernet header */
    m_adj(m, sizeof(struct ether_header));

    /* Copy out the first MHLEN bytes of data to ensure correct alignment */
    MGETHDR(m0, M_DONTWAIT, MT_DATA);
    if (m0 == NULL) {
	    m_freem(m);
	    etheripstat.etherip_adrops++;
	    return;
    }
    M_COPY_PKTHDR(m0, m);
    clen = min(MHLEN, m->m_pkthdr.len);
    if (m->m_pkthdr.len == clen)
      mrest = NULL;
    else {
	mrest = m_split(m, clen, M_DONTWAIT);
	if (mrest == NULL) {
	    m_freem(m);
	    m_freem(m0);
	    etheripstat.etherip_adrops++;
	    return;
	}
    }
    m0->m_next = mrest;
    m0->m_len = clen;
    m_copydata(m, 0, clen, mtod(m0, caddr_t));
    m_freem(m);
    m = m0;
d251 19
a269 21
    /* Find appropriate gif(4) interface */
    for (i = 0; i < ngif; i++)
    {
	if ((gif[i].gif_psrc == NULL) || (gif[i].gif_pdst == NULL) ||
	    !(gif[i].gif_if.if_flags & (IFF_UP|IFF_RUNNING)))
	  continue;

	if (!bcmp(gif[i].gif_psrc, &sdst, gif[i].gif_psrc->sa_len) &&
	    !bcmp(gif[i].gif_pdst, &ssrc, gif[i].gif_pdst->sa_len) &&
	    gif[i].gif_if.if_bridge != NULL)
	  break;
    }

    /* None found */
    if (i >= ngif)
    {
	DPRINTF(("etherip_input(): no interface found\n"));
        etheripstat.etherip_noifdrops++;
	m_freem(m);
	return;
    }
d272 11
a282 11
    /*
     * Tap the packet off here for a bridge. bridge_input() returns
     * NULL if it has consumed the packet.  In the case of gif's,
     * bridge_input() returns non-NULL when an error occurs.
     */
    m->m_pkthdr.rcvif = &gif[i].gif_if;
    if (m->m_flags & (M_BCAST|M_MCAST))
      gif[i].gif_if.if_imcasts++;
    m = bridge_input(&gif[i].gif_if, &eh, m);
    if (m == NULL)
      return;
d286 3
a288 3
    etheripstat.etherip_noifdrops++;
    m_freem(m);
    return;
d297 1
a297 1
    struct ip *ipo;
d301 1
a301 1
    struct ip6_hdr *ip6;
d304 23
a326 23
    struct etherip_header eip;
    struct mbuf *m0;
    ushort hlen;

    /* Some address family sanity checks */
    if ((tdb->tdb_src.sa.sa_family != 0) &&
        (tdb->tdb_src.sa.sa_family != AF_INET) &&
	(tdb->tdb_src.sa.sa_family != AF_INET6))
    {
        DPRINTF(("etherip_output(): IP in protocol-family <%d> attempted, aborting", tdb->tdb_src.sa.sa_family));
	etheripstat.etherip_adrops++;
        m_freem(m);
        return EINVAL;
    }

    if ((tdb->tdb_dst.sa.sa_family != AF_INET) &&
	(tdb->tdb_dst.sa.sa_family != AF_INET6))
    {
	DPRINTF(("etherip_output(): IP in protocol-family <%d> attempted, aborting", tdb->tdb_dst.sa.sa_family));
	etheripstat.etherip_adrops++;
	m_freem(m);
	return EINVAL;
    }
d328 7
a334 7
    if (tdb->tdb_dst.sa.sa_family != tdb->tdb_src.sa.sa_family)
    {
	DPRINTF(("etherip_output(): mismatch in tunnel source and destination address protocol families (%d/%d), aborting", tdb->tdb_src.sa.sa_family, tdb->tdb_dst.sa.sa_family));
	etheripstat.etherip_adrops++;
	m_freem(m);
	return EINVAL;
    }
d336 1
a336 2
    switch (tdb->tdb_dst.sa.sa_family)
    {
d339 2
a340 2
	    hlen = sizeof(struct ip);
	    break;
d344 2
a345 2
	    hlen = sizeof(struct ip6_hdr);
	    break;
d348 26
a373 25
	    DPRINTF(("etherip_output(): unsupported tunnel protocol family <%d>, aborting", tdb->tdb_dst.sa.sa_family));
	    etheripstat.etherip_adrops++;
	    m_freem(m);
	    return EINVAL;
    }

    /* Don't forget the EtherIP header */
    hlen += sizeof(struct etherip_header);

    MGETHDR(m0, M_DONTWAIT, MT_DATA);
    if (m0 == NULL) {
	DPRINTF(("etherip_output(): M_GETHDR failed\n"));
	etheripstat.etherip_adrops++;
	m_freem(m);
      	return ENOBUFS;
    }
    M_COPY_PKTHDR(m0, m);
    m0->m_next = m;
    m0->m_len = hlen;
    m0->m_pkthdr.len += hlen;
    m = m0;

    /* Statistics */
    etheripstat.etherip_opackets++;
    etheripstat.etherip_obytes += m->m_pkthdr.len - hlen;
d375 1
a375 2
    switch (tdb->tdb_dst.sa.sa_family)
    {
d378 1
a378 1
	    ipo = mtod(m, struct ip *);
d380 19
a398 19
	    ipo->ip_v = IPVERSION;
	    ipo->ip_hl = 5;
	    ipo->ip_len = htons(m->m_pkthdr.len);
	    ipo->ip_ttl = ip_defttl;
	    ipo->ip_p = IPPROTO_ETHERIP;
	    ipo->ip_tos = 0;
	    ipo->ip_off = 0;
	    ipo->ip_sum = 0;
	    ipo->ip_id = ip_randomid();
	    HTONS(ipo->ip_id);

	    /* 
	     * We should be keeping tunnel soft-state and send back
	     * ICMPs as needed.
	     */

	    ipo->ip_src = tdb->tdb_src.sin.sin_addr;
	    ipo->ip_dst = tdb->tdb_dst.sin.sin_addr;
	    break;
d402 1
a402 1
	    ip6 = mtod(m, struct ip6_hdr *);
d404 8
a411 8
	    ip6->ip6_flow = 0;
            ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
            ip6->ip6_vfc |= IPV6_VERSION;
            ip6->ip6_plen = htons(m->m_pkthdr.len);
            ip6->ip6_hlim = ip_defttl;
            ip6->ip6_dst = tdb->tdb_dst.sin6.sin6_addr;
            ip6->ip6_src = tdb->tdb_src.sin6.sin6_addr;
	    break;
d413 1
a413 1
    }
d415 4
a418 4
    /* Set the version number */
    eip.eip_ver = ETHERIP_VERSION & ETHERIP_VER_VERS_MASK;
    m_copyback(m, hlen - sizeof(struct etherip_header),
	sizeof(struct etherip_header), (caddr_t)&eip);
d420 1
a420 1
    *mp = m;
d422 1
a422 1
    return 0;
d427 5
a431 2
etherip_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
	       void *newp, size_t newlen)
d433 3
a435 3
    /* All sysctl names at this level are terminal. */
    if (namelen != 1)
      return (ENOTDIR);
d437 1
a437 2
    switch (name[0]) 
    {
d439 1
a439 1
	    return (sysctl_int(oldp, oldlenp, newp, newlen, &etherip_allow));
d441 3
a443 3
	    return (ENOPROTOOPT);
    }
    /* NOTREACHED */
@


1.20
log
@grr, don't forget to change the reserved field to the upper 4 bits of the header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.19 2001/02/01 20:14:26 jason Exp $  */
d102 1
d126 2
a127 2
     * Make sure there's at least an ethernet header's plus one byte
     * (EtherIP header) worth of data after the outer IP header.
d130 1
a130 1
	sizeof(u_int8_t))
d139 2
a140 2
    m_copydata(m, iphlen, sizeof(u_int8_t), &v);
    if ((v & ETHERIP_VERSION_MASK) != ETHERIP_VERSION)
d142 14
a155 13
	/*
	 * Note that the other potential failure of the above check is that the
	 * second nibble of the EtherIP header (the reserved part) is not
	 * zero; this is also invalid protocol behaviour.
	 */
	if (v & ETHERIP_RSVD_MASK)
	{
	    DPRINTF(("etherip_input(): received invalid EtherIP header (reserved field non-zero\n"));
	}
	else
	{
	    DPRINTF(("etherip_input(): received EtherIP version number %d not suppoorted\n", (v >> 4) & 0xff));
	}
d162 2
a163 1
    if (m->m_len < iphlen + sizeof(struct ether_header) + sizeof(u_int8_t))
d166 1
a166 1
			  sizeof(u_int8_t))) == 0)
d179 1
a179 1
    m_copydata(m, 0, sizeof(u_int8_t), &v);
d211 1
a211 3
    m->m_len -= (iphlen + sizeof(u_int8_t));
    m->m_pkthdr.len -= (iphlen + sizeof(u_int8_t));
    m->m_data += (iphlen + sizeof(u_int8_t));
d226 1
a226 1
	    m->m_flags |= M_BCAST;
a228 3
    if (m->m_flags & (M_BCAST|M_MCAST))
      m->m_pkthdr.rcvif->if_imcasts++;

d284 2
a285 2
     * NULL if it has consumed the packet, otherwise, it
     * gets processed as normal.
d288 2
d314 1
a316 1
    u_int8_t v;
d366 1
a366 1
    hlen += sizeof(u_int8_t);
d427 3
a429 2
    v = ETHERIP_VERSION & ETHERIP_VERSION_MASK;
    m_copyback(m, hlen - sizeof(u_int8_t), sizeof(u_int8_t), &v);
@


1.19
log
@according to the draft-housley-etherip-01, the version is in the low order
4 bits of the header
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.18 2001/02/01 00:14:14 jason Exp $  */
d139 2
a140 1
    if ((v & ETHERIP_VERSION_MASK) != ETHERIP_VERSION) {
d146 1
a146 1
	if (v & 0x0f)
@


1.18
log
@Ok, more alignment fallout (caused by a single byte header interspersed with
nicely aligned headers)...  Copy the first MHLEN worth of data into a new
buffer and rebuild the mbuf to make sure that the protocol data is nicely
aligned.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.17 2001/01/31 08:32:17 jason Exp $  */
d139 1
a139 2
    if (v != (ETHERIP_VERSION << 4))
    {
d426 1
a426 1
    v = (ETHERIP_VERSION << 4) & 0xf0;
@


1.17
log
@it's obviously bed time... really avoid mbuf lossage if MGETHDR fails
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.16 2001/01/31 08:28:47 jason Exp $  */
d100 2
a101 1
    int iphlen;
d233 26
@


1.16
log
@oops, avoid mbuf lossage if MGETHDR fails
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.15 2001/01/31 05:43:07 jason Exp $  */
d345 1
a345 1
	m_free(m);
@


1.15
log
@Allocate a new mbuf for the header info (struct ip + one, stupid, byte).
This works around the fact that M_PREPEND() with a non-word sized length
can leave m->m_data pointing to a non-word aligned address.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.14 2001/01/15 22:40:30 angelos Exp $  */
d345 1
@


1.14
log
@Careful with bitmasks (henric@@aimnet.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.13 2001/01/09 03:09:10 angelos Exp $  */
d287 1
d341 3
a343 5
    /* Get enough space for a header */
    M_PREPEND(m, hlen, M_DONTWAIT);
    if (m == 0)
    {
	DPRINTF(("etherip_output(): M_PREPEND of size %d failed\n", hlen));
d347 5
d362 1
a362 1
	
@


1.13
log
@One-byte EtherIP header, per the relevant draft (soon to be RFC).

		* * NOTE * *
    This breaks backward compatibility with 2.7 and 2.8 bridges.
		* * NOTE * *
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.12 2000/12/31 18:18:56 angelos Exp $  */
d145 1
a145 1
	if (v & 0xffff)
d151 1
a151 1
	    DPRINTF(("etherip_input(): received EtherIP version number %d not suppoorted\n", (v >> 4) & 0xffff));
d395 1
a395 1
    v = (ETHERIP_VERSION << 4) & 0xffff0000;
@


1.12
log
@Fix non-NGIF case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.11 2000/12/30 22:55:33 angelos Exp $  */
d124 2
a125 2
     * Remove the outer IP header, make sure there's at least an
     * ethernet header's worth of data in there. 
d127 2
a128 1
    if (m->m_pkthdr.len < iphlen + sizeof(struct ether_header))
d136 22
d159 1
a159 1
    if (m->m_len < iphlen + sizeof(struct ether_header))
d161 2
a162 1
	if ((m = m_pullup(m, iphlen + sizeof(struct ether_header))) == 0)
d175 1
a175 1
    m_copydata(m, 0, 1, &v);
d206 4
a209 4
    /* Chop off the `outer' header and reschedule. */
    m->m_len -= iphlen;
    m->m_pkthdr.len -= iphlen;
    m->m_data += iphlen;
d288 1
d337 3
d393 4
@


1.11
log
@Use gif* instead of enc* for the bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.10 2000/09/19 03:20:58 angelos Exp $  */
d100 1
a100 1
    int iphlen, i;
d103 4
@


1.10
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.9 2000/04/18 21:37:29 angelos Exp $  */
d60 3
d70 4
d98 1
d100 2
a101 1
    int iphlen;
a118 9
    /* If there's no interface associated, drop now. */
    if (m->m_pkthdr.rcvif == 0 || m->m_pkthdr.rcvif->if_bridge == 0)
    {
	DPRINTF(("etherip_input(): input interface or bridge unknown\n"));
	etheripstat.etherip_noifdrops++;
	m_freem(m);
	return;
    }
    
d143 34
a176 4
    /*
     * Interface pointer is already in first mbuf; chop off the 
     * `outer' header and reschedule.
     */
d178 1
d200 1
a200 1
	m->m_pkthdr.rcvif->if_imcasts++;
d205 23
d230 1
a230 2
     * Tap the packet off here for a bridge, if configured and
     * active for this interface.  bridge_input returns
d234 6
a239 7
    if (m->m_pkthdr.rcvif->if_bridge)
    {
	m = bridge_input(m->m_pkthdr.rcvif, &eh, m);
	if (m == NULL)
	  return;
    }
#endif
d241 1
@


1.9
log
@Remove the ethernet header from the mbuf before passing it on to
bridge_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.8 2000/04/11 16:28:49 angelos Exp $  */
a156 4

    /* tdbi is only set in ESP or AH, if next protocol is UDP or TCP */
    if (m->m_flags & (M_CONF|M_AUTH))
	m->m_pkthdr.tdbi = NULL;
@


1.8
log
@Don't add an extra 20 bytes to ip_len, m_pkthdr.len is already updated
by M_PREPEND.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.7 2000/04/10 07:33:44 angelos Exp $  */
d171 1
d174 3
@


1.7
log
@Oops on sanity logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.6 2000/01/07 21:59:34 angelos Exp $  */
d276 1
a276 1
	    ipo->ip_len = htons(m->m_pkthdr.len + sizeof(struct ip));
@


1.6
log
@Remove unnecessary include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.5 1999/12/25 07:25:25 angelos Exp $  */
d210 2
a211 2
        ((tdb->tdb_src.sa.sa_family != AF_INET) ||
	 (tdb->tdb_src.sa.sa_family != AF_INET6)))
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.26 2001/04/06 04:42:08 csapuntz Exp $  */
a59 3
#include <net/if_gif.h>

#include "gif.h"
d87 2
a88 2
	struct mbuf *m;
	va_dcl
d91 18
a108 6
	union sockaddr_union ssrc, sdst;
	struct ether_header eh;
	int iphlen;
	struct etherip_header eip;
	u_int8_t v;
	va_list ap;
d110 20
a129 108
#if NGIF > 0
	int i;
#if NBRIDGE > 0
	int s;
#endif /* NBRIDGE */
#endif /* NGIF */

	va_start(ap, m);
	iphlen = va_arg(ap, int);
	va_end(ap);

	etheripstat.etherip_ipackets++;

	/* If we do not accept EtherIP explicitly, drop. */
	if (!etherip_allow && (m->m_flags & (M_AUTH|M_CONF)) == 0) {
		DPRINTF(("etherip_input(): dropped due to policy\n"));
		etheripstat.etherip_pdrops++;
		m_freem(m);
		return;
	}

	/*
	 * Make sure there's at least an ethernet header's and an EtherIP
	 * header's of worth of data after the outer IP header.
	 */
	if (m->m_pkthdr.len < iphlen + sizeof(struct ether_header) +
	    sizeof(struct etherip_header)) {
		DPRINTF(("etherip_input(): encapsulated packet too short\n"));
		etheripstat.etherip_hdrops++;
		m_freem(m);
		return;
	}

	/* Verify EtherIP version number */
	m_copydata(m, iphlen, sizeof(struct etherip_header), (caddr_t)&eip);
	if ((eip.eip_ver & ETHERIP_VER_VERS_MASK) != ETHERIP_VERSION) {
		DPRINTF(("etherip_input(): received EtherIP version number %d not suppoorted\n", (v >> 4) & 0xff));
		etheripstat.etherip_adrops++;
		m_freem(m);
		return;
	}

	/*
	 * Note that the other potential failure of the above check is that the
	 * second nibble of the EtherIP header (the reserved part) is not
	 * zero; this is also invalid protocol behaviour.
	 */
	if (eip.eip_ver & ETHERIP_VER_RSVD_MASK) {
		DPRINTF(("etherip_input(): received EtherIP invalid EtherIP header (reserved field non-zero\n"));
		etheripstat.etherip_adrops++;
		m_freem(m);
		return;
	}

	/* Finally, the pad value must be zero. */
	if (eip.eip_pad) {
		DPRINTF(("etherip_input(): received EtherIP invalid pad value\n"));
		etheripstat.etherip_adrops++;
		m_freem(m);
		return;
	}

	/* Make sure the ethernet header at least is in the first mbuf. */
	if (m->m_len < iphlen + sizeof(struct ether_header) +
	    sizeof(struct etherip_header)) {
		if ((m = m_pullup(m, iphlen + sizeof(struct ether_header) +
		    sizeof(struct etherip_header))) == NULL) {
			DPRINTF(("etherip_input(): m_pullup() failed\n"));
			etheripstat.etherip_adrops++;
			m_freem(m);
			return;
		}
	}

	/* Copy the addresses for use later */
	bzero(&ssrc, sizeof(ssrc));
	bzero(&sdst, sizeof(sdst));

	v = *mtod(m, u_int8_t *);
	switch (v >> 4) {
#ifdef INET
	case 4:
		ssrc.sa.sa_len = sdst.sa.sa_len = sizeof(struct sockaddr_in);
		ssrc.sa.sa_family = sdst.sa.sa_family = AF_INET;
		m_copydata(m, offsetof(struct ip, ip_src), sizeof(struct in_addr),
		    (caddr_t) &ssrc.sin.sin_addr);
		m_copydata(m, offsetof(struct ip, ip_dst), sizeof(struct in_addr),
		    (caddr_t) &sdst.sin.sin_addr);
		break;
#endif /* INET */
#ifdef INET6
	case 6:
		ssrc.sa.sa_len = sdst.sa.sa_len = sizeof(struct sockaddr_in6);
		ssrc.sa.sa_family = sdst.sa.sa_family = AF_INET6;
		m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
		    sizeof(struct in6_addr),
		    (caddr_t) &ssrc.sin6.sin6_addr);
		m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		    sizeof(struct in6_addr),
		    (caddr_t) &sdst.sin6.sin6_addr);
		break;
#endif /* INET6 */
	default:
		DPRINTF(("etherip_input(): invalid protocol %d\n", v));
		m_freem(m);
		etheripstat.etherip_hdrops++;
		return /* EAFNOSUPPORT */;
	}
d131 42
a172 42
	/* Chop off the `outer' IP and EtherIP headers and reschedule. */
	m_adj(m, iphlen + sizeof(struct etherip_header));

	/* Statistics */
	etheripstat.etherip_ibytes += m->m_pkthdr.len;

	/* Copy ethernet header */
	m_copydata(m, 0, sizeof(eh), (void *) &eh);

	/* Reset the flags based on the inner packet */
	m->m_flags &= ~(M_BCAST|M_MCAST|M_AUTH|M_CONF);
	if (eh.ether_dhost[0] & 1) {
		if (bcmp((caddr_t) etherbroadcastaddr,
		    (caddr_t)eh.ether_dhost, sizeof(etherbroadcastaddr)) == 0)
			m->m_flags |= M_BCAST;
		else
			m->m_flags |= M_MCAST;
	}

	/* Trim the beginning of the mbuf, to remove the ethernet header */
	m_adj(m, sizeof(struct ether_header));

#if NGIF > 0
	/* Find appropriate gif(4) interface */
	for (i = 0; i < ngif; i++) {
		if ((gif[i].gif_psrc == NULL) || (gif[i].gif_pdst == NULL) ||
		    !(gif[i].gif_if.if_flags & (IFF_UP|IFF_RUNNING)))
			continue;

		if (!bcmp(gif[i].gif_psrc, &sdst, gif[i].gif_psrc->sa_len) &&
		    !bcmp(gif[i].gif_pdst, &ssrc, gif[i].gif_pdst->sa_len) &&
		    gif[i].gif_if.if_bridge != NULL)
			break;
	}

	/* None found */
	if (i >= ngif) {
		DPRINTF(("etherip_input(): no interface found\n"));
		etheripstat.etherip_noifdrops++;
		m_freem(m);
		return;
	}
d175 9
a183 12
	/*
	 * Tap the packet off here for a bridge. bridge_input() returns
	 * NULL if it has consumed the packet.  In the case of gif's,
	 * bridge_input() returns non-NULL when an error occurs.
	 */
	m->m_pkthdr.rcvif = &gif[i].gif_if;
	if (m->m_flags & (M_BCAST|M_MCAST))
		gif[i].gif_if.if_imcasts++;

	s = splnet();
	m = bridge_input(&gif[i].gif_if, &eh, m);
	splx(s);
d185 3
a187 3
		return;
#endif /* NBRIDGE */
#endif /* NGIF */
d189 2
a190 3
	etheripstat.etherip_noifdrops++;
	m_freem(m);
	return;
d199 1
a199 1
	struct ip *ipo;
d203 1
a203 1
	struct ip6_hdr *ip6;
d206 1
a206 14
	struct etherip_header eip;
	struct mbuf *m0;
	ushort hlen;

	/* Some address family sanity checks */
	if ((tdb->tdb_src.sa.sa_family != 0) &&
	    (tdb->tdb_src.sa.sa_family != AF_INET) &&
	    (tdb->tdb_src.sa.sa_family != AF_INET6)) {
		DPRINTF(("etherip_output(): IP in protocol-family <%d> attempted, aborting",
		    tdb->tdb_src.sa.sa_family));
		etheripstat.etherip_adrops++;
		m_freem(m);
		return EINVAL;
	}
d208 19
a226 8
	if ((tdb->tdb_dst.sa.sa_family != AF_INET) &&
	    (tdb->tdb_dst.sa.sa_family != AF_INET6)) {
		DPRINTF(("etherip_output(): IP in protocol-family <%d> attempted, aborting",
		    tdb->tdb_dst.sa.sa_family));
		etheripstat.etherip_adrops++;
		m_freem(m);
		return EINVAL;
	}
d228 7
a234 7
	if (tdb->tdb_dst.sa.sa_family != tdb->tdb_src.sa.sa_family) {
		DPRINTF(("etherip_output(): mismatch in tunnel source and destination address protocol families (%d/%d), aborting",
		    tdb->tdb_src.sa.sa_family, tdb->tdb_dst.sa.sa_family));
		etheripstat.etherip_adrops++;
		m_freem(m);
		return EINVAL;
	}
d236 2
a237 1
	switch (tdb->tdb_dst.sa.sa_family) {
d240 2
a241 2
		hlen = sizeof(struct ip);
		break;
d245 2
a246 2
		hlen = sizeof(struct ip6_hdr);
		break;
d249 18
a266 32
		DPRINTF(("etherip_output(): unsupported tunnel protocol family <%d>, aborting",
		    tdb->tdb_dst.sa.sa_family));
		etheripstat.etherip_adrops++;
		m_freem(m);
		return EINVAL;
	}

	/* Don't forget the EtherIP header */
	hlen += sizeof(struct etherip_header);

	if (!(m->m_flags & M_PKTHDR)) {
		DPRINTF(("etherip_output(): mbuf is not a header\n"));
		m_freem(m);
		return (ENOBUFS);
	}

	MGETHDR(m0, M_DONTWAIT, MT_DATA);
	if (m0 == NULL) {
		DPRINTF(("etherip_output(): M_GETHDR failed\n"));
		etheripstat.etherip_adrops++;
		m_freem(m);
		return ENOBUFS;
	}
	M_COPY_PKTHDR(m0, m);
	m0->m_next = m;
	m0->m_len = hlen;
	m0->m_pkthdr.len += hlen;
	m = m0;

	/* Statistics */
	etheripstat.etherip_opackets++;
	etheripstat.etherip_obytes += m->m_pkthdr.len - hlen;
d268 2
a269 1
	switch (tdb->tdb_dst.sa.sa_family) {
d272 21
a292 21
		ipo = mtod(m, struct ip *);

		ipo->ip_v = IPVERSION;
		ipo->ip_hl = 5;
		ipo->ip_len = htons(m->m_pkthdr.len);
		ipo->ip_ttl = ip_defttl;
		ipo->ip_p = IPPROTO_ETHERIP;
		ipo->ip_tos = 0;
		ipo->ip_off = 0;
		ipo->ip_sum = 0;
		ipo->ip_id = ip_randomid();
		HTONS(ipo->ip_id);

		/* 
		 * We should be keeping tunnel soft-state and send back
		 * ICMPs as needed.
		 */

		ipo->ip_src = tdb->tdb_src.sin.sin_addr;
		ipo->ip_dst = tdb->tdb_dst.sin.sin_addr;
		break;
d296 1
a296 1
		ip6 = mtod(m, struct ip6_hdr *);
d298 8
a305 8
		ip6->ip6_flow = 0;
		ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
		ip6->ip6_vfc |= IPV6_VERSION;
		ip6->ip6_plen = htons(m->m_pkthdr.len);
		ip6->ip6_hlim = ip_defttl;
		ip6->ip6_dst = tdb->tdb_dst.sin6.sin6_addr;
		ip6->ip6_src = tdb->tdb_src.sin6.sin6_addr;
		break;
d307 1
a307 7
	}

	/* Set the version number */
	eip.eip_ver = ETHERIP_VERSION & ETHERIP_VER_VERS_MASK;
	eip.eip_pad = 0;
	m_copyback(m, hlen - sizeof(struct etherip_header),
	    sizeof(struct etherip_header), (caddr_t)&eip);
d309 1
a309 1
	*mp = m;
d311 1
a311 1
	return 0;
d316 2
a317 5
etherip_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp, *newp;
	size_t *oldlenp, newlen;
d319 3
a321 3
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);
d323 2
a324 1
	switch (name[0]) {
d326 1
a326 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &etherip_allow));
d328 3
a330 3
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$  */
d8 1
a8 1
 * Copyright (C) 1999-2001 Angelos D. Keromytis.
d10 1
a10 1
 * Permission to use, copy, and modify this software with or without fee
d34 1
d36 1
d38 2
d44 1
d51 1
d55 1
d58 1
d137 1
a137 2
		DPRINTF(("etherip_input(): received EtherIP version number "
		    "%d not suppoorted\n", (v >> 4) & 0xff));
d149 1
a149 2
		DPRINTF(("etherip_input(): received EtherIP invalid EtherIP "
		    "header (reserved field non-zero\n"));
d157 1
a157 2
		DPRINTF(("etherip_input(): received EtherIP invalid "
		    "pad value\n"));
d175 1
a175 1
	/* Copy the addresses for use later. */
d185 1
a185 2
		m_copydata(m, offsetof(struct ip, ip_src),
		    sizeof(struct in_addr),
d187 1
a187 2
		m_copydata(m, offsetof(struct ip, ip_dst),
		    sizeof(struct in_addr),
d229 1
a229 1
	/* Trim the beginning of the mbuf, to remove the ethernet header. */
d245 1
a245 1
	/* None found. */
d293 1
a293 1
	/* Some address family sanity checks. */
d297 2
a298 2
		DPRINTF(("etherip_output(): IP in protocol-family <%d> "
		    "attempted, aborting", tdb->tdb_src.sa.sa_family));
d306 2
a307 2
		DPRINTF(("etherip_output(): IP in protocol-family <%d> "
		    "attempted, aborting", tdb->tdb_dst.sa.sa_family));
d314 1
a314 2
		DPRINTF(("etherip_output(): mismatch in tunnel source and "
		    "destination address protocol families (%d/%d), aborting",
d333 2
a334 2
		DPRINTF(("etherip_output(): unsupported tunnel protocol "
		    "family <%d>, aborting", tdb->tdb_dst.sa.sa_family));
d340 1
a340 1
	/* Don't forget the EtherIP header. */
d356 1
a356 1
	M_MOVE_PKTHDR(m0, m);
d379 2
a380 1
		ipo->ip_id = htons(ip_randomid());
d431 1
a431 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &etherip_allow));
@


1.6.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.6.2.2 2001/07/04 10:54:42 niklas Exp $  */
d231 2
a232 3
		if ((gif_softc[i].gif_psrc == NULL) ||
		    (gif_softc[i].gif_pdst == NULL) ||
		    !(gif_softc[i].gif_if.if_flags & (IFF_UP|IFF_RUNNING)))
d235 3
a237 3
		if (!bcmp(gif_softc[i].gif_psrc, &sdst, gif_softc[i].gif_psrc->sa_len) &&
		    !bcmp(gif_softc[i].gif_pdst, &ssrc, gif_softc[i].gif_pdst->sa_len) &&
		    gif_softc[i].gif_if.if_bridge != NULL)
d255 1
a255 1
	m->m_pkthdr.rcvif = &gif_softc[i].gif_if;
d257 1
a257 1
		gif_softc[i].gif_if.if_imcasts++;
d260 1
a260 1
	m = bridge_input(&gif_softc[i].gif_if, &eh, m);
@


1.6.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$  */
d273 1
d413 1
@


1.6.2.5
log
@Merge in -current from roughly a week ago
@
text
@d77 1
d79 5
@


1.6.2.6
log
@Sync the SMP branch with 3.3
@
text
@d8 1
a8 1
 *
d12 1
a12 1
 * modification of this software.
d26 1
a26 1
 * Ethernet-inside-IP processing (RFC3378).
a38 1
#include <net/bpf.h>
a53 1
#include "bpfilter.h"
d72 1
a72 1
 * were being used in tunnel mode (in which case the rcvif element will
d158 1
d210 1
a210 1
	m->m_flags &= ~(M_BCAST|M_MCAST|M_AUTH|M_CONF|M_AUTH_AH);
a242 12
#if NBPFILTER > 0
	if (gif_softc[i].gif_if.if_bpf) {
		struct mbuf m0;
		u_int32_t af = sdst.sa.sa_family;

		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *)&af;

		bpf_mtap(gif_softc[i].gif_if.if_bpf, &m0);
	}
#endif
d372 1
a372 1
		/*
a385 1
		ip6->ip6_nxt = IPPROTO_ETHERIP;
@


1.6.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.6.2.6 2003/03/28 00:06:54 niklas Exp $  */
a248 1
		m0.m_flags = 0;
@


1.6.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$  */
d89 1
a89 1
	struct gif_softc *sc;
d225 4
a228 4
	LIST_FOREACH(sc, &gif_softc_list, gif_list) {
		if ((sc->gif_psrc == NULL) ||
		    (sc->gif_pdst == NULL) ||
		    !(sc->gif_if.if_flags & (IFF_UP|IFF_RUNNING)))
d231 3
a233 3
		if (!bcmp(sc->gif_psrc, &sdst, sc->gif_psrc->sa_len) &&
		    !bcmp(sc->gif_pdst, &ssrc, sc->gif_pdst->sa_len) &&
		    sc->gif_if.if_bridge != NULL)
d238 1
a238 1
	if (sc == NULL) {
d245 1
a245 1
	if (sc->gif_if.if_bpf) {
d254 1
a254 1
		bpf_mtap(sc->gif_if.if_bpf, &m0);
d264 1
a264 1
	m->m_pkthdr.rcvif = &sc->gif_if;
d266 1
a266 1
		sc->gif_if.if_imcasts++;
d269 1
a269 1
	m = bridge_input(&sc->gif_if, &eh, m);
d415 1
a415 1
	    sizeof(struct etherip_header), &eip);
@


1.5
log
@Support v4 and v6 destination TDBs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.4 1999/12/06 07:14:35 angelos Exp $  */
a36 1
#include <sys/protosw.h>
a37 1
#include <sys/errno.h>
a40 1
#include <machine/cpu.h>
d46 1
d53 1
a53 4
#include <netinet/ip_icmp.h>

#include <sys/socketvar.h>
#include <net/raw_cb.h>
@


1.4
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.3 1999/11/04 05:16:32 jason Exp $  */
d170 1
a170 1
	if (bcmp((caddr_t)etherbroadcastaddr, (caddr_t)eh.ether_dhost,
d203 1
d205 1
a205 1
    ushort ilen;
d207 7
a213 1
    /* Check that the source address, if present, is from AF_INET */
d215 2
a216 1
        (tdb->tdb_src.sa.sa_family != AF_INET))
d218 1
a218 2
        DPRINTF(("etherip_output(): IP in protocol-family <%d> attempted, aborting"
, tdb->tdb_src.sa.sa_family));
d224 2
a225 2
    /* Check that the destination address is AF_INET */
    if (tdb->tdb_dst.sa.sa_family != AF_INET)
d233 26
a258 2
    etheripstat.etherip_opackets++;
    ilen = m->m_pkthdr.len;
d260 2
a261 1
    M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
d264 1
a264 1
	DPRINTF(("etherip_output(): M_PREPEND failed\n"));
d269 9
a277 1
    ipo = mtod(m, struct ip *);
d279 34
a312 15
    ipo->ip_v = IPVERSION;
    ipo->ip_hl = 5;
    ipo->ip_len = htons(ilen + sizeof(struct ip));
    ipo->ip_ttl = ip_defttl;
    ipo->ip_p = IPPROTO_ETHERIP;
    ipo->ip_tos = 0;
    ipo->ip_off = 0;
    ipo->ip_sum = 0;
    ipo->ip_id = ip_randomid();
    HTONS(ipo->ip_id);

    /* We should be keeping tunnel soft-state and send back ICMPs if needed. */

    ipo->ip_src = tdb->tdb_src.sin.sin_addr;
    ipo->ip_dst = tdb->tdb_dst.sin.sin_addr;
a315 1
    etheripstat.etherip_obytes += ntohs(ipo->ip_len) - (ipo->ip_hl << 2);
@


1.3
log
@Do a little preprocessing on the incoming mbuf: set the MCAST/BCAST m_flag
as appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.2 1999/10/29 02:00:23 angelos Exp $  */
d200 2
a201 1
etherip_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp)
@


1.2
log
@Queue on the bridge interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ether.c,v 1.1 1999/10/28 03:08:34 angelos Exp $  */
d167 12
a185 1

@


1.1
log
@Add Ethernet-IP encapsulation handling.
@
text
@d1 1
a1 1
/*	$OpenBSD$  */
d30 1
d64 1
d84 1
a84 1
 * contain the address of the encapX interface associated with the tunnel.
d96 2
a97 2
    struct ifqueue *ifq = NULL;
    int iphlen, s;
d115 9
a127 1

d160 2
d163 1
a163 1
    /* tdbi is only set in ESP or ESP, if next protocol is udp or tcp */
d167 1
d169 4
a172 5
     * Interface pointer stays the same; if no IPsec processing has
     * been done (or will be done), this will point to a normal 
     * interface. Otherwise, it'll point to an encap interface, which
     * will allow a packet filter to distinguish between secure and
     * untrusted packets.
d175 1
a175 5
    /* XXX Queue on the right bridge interface. */
    ifq = &ipintrq;

    s = splimp();			/* isn't it already? */
    if (IF_QFULL(ifq))
d177 3
a179 7
	IF_DROP(ifq);
	m_freem(m);
	etheripstat.etherip_qfull++;
	splx(s);

	DPRINTF(("etherip_input(): packet dropped because of full queue\n"));
	return;
d181 1
d183 1
a183 3
    IF_ENQUEUE(ifq, m);
    schednetisr(NETISR_IP);
    splx(s);
d189 1
a189 2
etherip_output(struct mbuf *m, struct sockaddr_encap *gw, struct tdb *tdb, 
	       struct mbuf **mp)
d194 11
d238 1
a238 3
    /*
     * We should be keeping tunnel soft-state and send back ICMPs if needed.
     */
@

