head	1.119;
access;
symbols
	OPENBSD_6_1_BASE:1.119
	OPENBSD_6_0:1.118.0.4
	OPENBSD_6_0_BASE:1.118
	OPENBSD_5_9:1.116.0.2
	OPENBSD_5_9_BASE:1.116
	OPENBSD_5_8:1.113.0.4
	OPENBSD_5_8_BASE:1.113
	OPENBSD_5_7:1.108.0.2
	OPENBSD_5_7_BASE:1.108
	OPENBSD_5_6:1.107.0.4
	OPENBSD_5_6_BASE:1.107
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.98.0.2
	OPENBSD_5_4_BASE:1.98
	OPENBSD_5_3:1.97.0.2
	OPENBSD_5_3_BASE:1.97
	OPENBSD_5_2:1.96.0.6
	OPENBSD_5_2_BASE:1.96
	OPENBSD_5_1_BASE:1.96
	OPENBSD_5_1:1.96.0.4
	OPENBSD_5_0:1.96.0.2
	OPENBSD_5_0_BASE:1.96
	OPENBSD_4_9:1.93.0.2
	OPENBSD_4_9_BASE:1.93
	OPENBSD_4_8:1.90.0.2
	OPENBSD_4_8_BASE:1.90
	OPENBSD_4_7:1.87.0.2
	OPENBSD_4_7_BASE:1.87
	OPENBSD_4_6:1.87.0.4
	OPENBSD_4_6_BASE:1.87
	OPENBSD_4_5:1.86.0.2
	OPENBSD_4_5_BASE:1.86
	OPENBSD_4_4:1.85.0.2
	OPENBSD_4_4_BASE:1.85
	OPENBSD_4_3:1.81.0.2
	OPENBSD_4_3_BASE:1.81
	OPENBSD_4_2:1.80.0.2
	OPENBSD_4_2_BASE:1.80
	OPENBSD_4_1:1.79.0.8
	OPENBSD_4_1_BASE:1.79
	OPENBSD_4_0:1.79.0.6
	OPENBSD_4_0_BASE:1.79
	OPENBSD_3_9:1.79.0.4
	OPENBSD_3_9_BASE:1.79
	OPENBSD_3_8:1.79.0.2
	OPENBSD_3_8_BASE:1.79
	OPENBSD_3_7:1.75.0.2
	OPENBSD_3_7_BASE:1.75
	OPENBSD_3_6:1.71.0.2
	OPENBSD_3_6_BASE:1.71
	SMP_SYNC_A:1.70
	SMP_SYNC_B:1.70
	OPENBSD_3_5:1.65.0.2
	OPENBSD_3_5_BASE:1.65
	OPENBSD_3_4:1.58.0.2
	OPENBSD_3_4_BASE:1.58
	UBC_SYNC_A:1.54
	OPENBSD_3_3:1.54.0.2
	OPENBSD_3_3_BASE:1.54
	OPENBSD_3_2:1.53.0.2
	OPENBSD_3_2_BASE:1.53
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	UBC_SYNC_B:1.53
	UBC:1.44.0.2
	UBC_BASE:1.44
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9_BASE:1.34
	OPENBSD_2_9:1.34.0.4
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	SMP:1.29.0.2
	SMP_BASE:1.29
	kame_19991208:1.25
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.119
date	2017.02.09.15.19.32;	author jca;	state Exp;
branches;
next	1.118;
commitid	Hew5AYIxyEp5lNbI;

1.118
date	2016.07.19.21.28.43;	author bluhm;	state Exp;
branches;
next	1.117;
commitid	LnJozgpQEDsQdhuu;

1.117
date	2016.06.13.21.24.43;	author bluhm;	state Exp;
branches;
next	1.116;
commitid	t4rQrmZwTmcYiFNW;

1.116
date	2015.12.05.10.52.26;	author tedu;	state Exp;
branches
	1.116.2.1;
next	1.115;
commitid	e5lGxAXE14M3fHuG;

1.115
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.114;
commitid	xFxvBxiFybIsZNMc;

1.114
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.113;
commitid	Cr0DVA7exR1t2zXg;

1.113
date	2015.07.13.23.11.37;	author bluhm;	state Exp;
branches
	1.113.4.1;
next	1.112;
commitid	aprEzwQVYRUBnZbh;

1.112
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.111;
commitid	J4OPNuggl4DOKGzM;

1.111
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.110;
commitid	h7z8lokZ0dFyuWpg;

1.110
date	2015.06.07.01.25.27;	author krw;	state Exp;
branches;
next	1.109;
commitid	7yzARhkDkBsYwsVv;

1.109
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.108;
commitid	p4LJxGKbi0BU2cG6;

1.108
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches
	1.108.2.1;
next	1.107;
commitid	zhW8jJrfVCoAthrR;

1.107
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches
	1.107.4.1;
next	1.106;
commitid	DQakU8LLWV6Iwx84;

1.106
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.105;

1.105
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.104;

1.104
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.103;

1.103
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.102;

1.102
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.101;

1.101
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.100;

1.100
date	2013.10.19.10.38.55;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2013.08.12.21.57.16;	author bluhm;	state Exp;
branches;
next	1.98;

1.98
date	2013.06.03.16.57.06;	author bluhm;	state Exp;
branches;
next	1.97;

1.97
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.96;

1.96
date	2011.05.13.14.31.17;	author oga;	state Exp;
branches;
next	1.95;

1.95
date	2011.04.24.19.36.54;	author bluhm;	state Exp;
branches;
next	1.94;

1.94
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2011.01.07.17.50.42;	author bluhm;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.24.02.59.45;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.08.08.34.42;	author claudio;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.89;

1.89
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.28.08.32.41;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2008.09.03.12.51.39;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2008.07.03.15.46.24;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.28.13.26.38;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.12.15.13.47;	author jsing;	state Exp;
branches;
next	1.82;

1.82
date	2008.06.12.15.08.47;	author jsing;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.24.12.59.28;	author jmc;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2005.06.30.08.51.31;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2005.05.24.00.02.37;	author fgont;	state Exp;
branches;
next	1.77;

1.77
date	2005.04.25.17.55.52;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2005.04.05.20.27.35;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2005.02.27.13.22.56;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2004.10.28.19.22.52;	author mcbride;	state Exp;
branches;
next	1.73;

1.73
date	2004.10.06.14.33.07;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2004.09.16.13.14.28;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2004.06.20.18.16.50;	author itojun;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.08.19.47.24;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.05.11.56.50;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2004.05.31.20.04.44;	author brad;	state Exp;
branches;
next	1.67;

1.67
date	2004.05.07.14.42.27;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.26.18.12.25;	author frantzen;	state Exp;
branches;
next	1.65;

1.65
date	2004.02.16.21.51.03;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2004.02.10.10.30.24;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.31.19.40.10;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.22.14.38.28;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.15.17.04.59;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.14.13.38.21;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.09.07.40.25;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.29.00.35.18;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.25.15.27.29;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.09.16.26.11;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.07.16.18.02;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.16.14.10.51;	author kjc;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.08.03.49.58;	author provos;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.01.22.29.29;	author provos;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.05.17.03.11;	author provos;	state Exp;
branches;
next	1.46;

1.46
date	2002.01.14.19.58.18;	author provos;	state Exp;
branches;
next	1.45;

1.45
date	2002.01.14.03.11.55;	author provos;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.24.19.29.07;	author deraadt;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2001.06.25.01.59.29;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.25.00.11.58;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.23.07.14.32;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.23.06.03.12;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.23.05.36.08;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.23.03.10.21;	author provos;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.08.03.53.46;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.05.02.31.36;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.31.16.27.08;	author provos;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.25.09.41.03;	author provos;	state Exp;
branches
	1.34.4.1;
next	1.33;

1.33
date	2000.09.20.17.00.22;	author provos;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.18.22.06.38;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.05.21.57.41;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.21.21.42.13;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.07.00.57.54;	author itojun;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	99.12.21.17.49.28;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	99.12.15.16.37.20;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	99.12.10.17.51.10;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	99.12.02.16.31.17;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.11.15.05.50.59;	author hugh;	state Exp;
branches;
next	1.22;

1.22
date	99.11.04.11.24.24;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	99.07.06.20.17.53;	author cmetz;	state Exp;
branches;
next	1.20;

1.20
date	99.07.06.20.14.06;	author cmetz;	state Exp;
branches;
next	1.19;

1.19
date	99.07.03.02.16.51;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.07.02.21.22.13;	author cmetz;	state Exp;
branches;
next	1.17;

1.17
date	99.07.02.20.39.08;	author cmetz;	state Exp;
branches;
next	1.16;

1.16
date	99.01.11.02.01.36;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.11.25.05.44.37;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.11.25.05.20.51;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.11.18.21.13.06;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	98.11.17.19.23.02;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	98.10.28.21.34.33;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	98.05.18.21.11.06;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	98.02.03.19.06.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.11.24.07.28.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.26.20.02.33;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.06.19.10.49.05;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.12.06.36.57;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.09.12.06.19.56;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.03.14.08.06.57;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.22.30.46;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches;
next	;

1.29.2.1
date	2000.03.02.07.04.43;	author niklas;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2001.05.14.22.40.15;	author niklas;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2001.07.04.10.55.07;	author niklas;	state Exp;
branches;
next	1.29.2.4;

1.29.2.4
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.29.2.5;

1.29.2.5
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.29.2.6;

1.29.2.6
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.29.2.7;

1.29.2.7
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.29.2.8;

1.29.2.8
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.29.2.9;

1.29.2.9
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.29.2.10;

1.29.2.10
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	1.29.2.11;

1.29.2.11
date	2004.06.08.21.07.29;	author niklas;	state Exp;
branches;
next	;

1.34.4.1
date	2001.06.06.22.35.11;	author jason;	state Exp;
branches;
next	;

1.44.2.1
date	2002.01.31.22.55.45;	author niklas;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.44.2.4;

1.44.2.4
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;

1.107.4.1
date	2015.07.13.23.12.13;	author bluhm;	state Exp;
branches;
next	;
commitid	I8vGaclDuzTIIHaE;

1.108.2.1
date	2015.07.13.23.11.55;	author bluhm;	state Exp;
branches;
next	;
commitid	Okw501z9sZJgttzV;

1.113.4.1
date	2016.07.21.14.31.29;	author tedu;	state Exp;
branches;
next	;
commitid	MLuylNuqysbESCPO;

1.116.2.1
date	2016.07.14.02.56.15;	author tedu;	state Exp;
branches;
next	;
commitid	0mSmzl4NTWthAxT7;


desc
@@


1.119
log
@percpu counters for TCP stats

ok mpi@@ bluhm@@
@
text
@/*	$OpenBSD: tcp_output.c,v 1.118 2016/07/19 21:28:43 bluhm Exp $	*/
/*	$NetBSD: tcp_output.c,v 1.16 1997/06/03 16:17:09 kml Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/kernel.h>

#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#define	TCPOUTFLAGS
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>
#include <netinet/tcp_debug.h>

#ifdef notyet
extern struct mbuf *m_copypack();
#endif

#ifdef TCP_SACK
extern int tcprexmtthresh;
#endif

#ifdef TCP_SACK
#ifdef TCP_SACK_DEBUG
void tcp_print_holes(struct tcpcb *tp);

void
tcp_print_holes(struct tcpcb *tp)
{
	struct sackhole *p = tp->snd_holes;
	if (p == NULL)
		return;
	printf("Hole report: start--end dups rxmit\n");
	while (p) {
		printf("%x--%x d %d r %x\n", p->start, p->end, p->dups,
		    p->rxmit);
		p = p->next;
	}
	printf("\n");
}
#endif /* TCP_SACK_DEBUG */

/*
 * Returns pointer to a sackhole if there are any pending retransmissions;
 * NULL otherwise.
 */
struct sackhole *
tcp_sack_output(struct tcpcb *tp)
{
	struct sackhole *p;

	if (!tp->sack_enable)
		return (NULL);
	p = tp->snd_holes;
	while (p) {
#ifndef TCP_FACK
		if (p->dups >= tcprexmtthresh && SEQ_LT(p->rxmit, p->end)) {
#else
		/* In FACK, if p->dups is less than tcprexmtthresh, but
		 * snd_fack advances more than tcprextmtthresh * tp->t_maxseg,
		 * tcp_input() will try fast retransmit. This forces output.
		 */
		if ((p->dups >= tcprexmtthresh ||
		     tp->t_dupacks == tcprexmtthresh) &&
		    SEQ_LT(p->rxmit, p->end)) {
#endif /* TCP_FACK */
			if (SEQ_LT(p->rxmit, tp->snd_una)) {/* old SACK hole */
				p = p->next;
				continue;
			}
#ifdef TCP_SACK_DEBUG
			if (p)
				tcp_print_holes(tp);
#endif
			return (p);
		}
		p = p->next;
	}
	return (NULL);
}

/*
 * After a timeout, the SACK list may be rebuilt.  This SACK information
 * should be used to avoid retransmitting SACKed data.  This function
 * traverses the SACK list to see if snd_nxt should be moved forward.
 */

void
tcp_sack_adjust(struct tcpcb *tp)
{
	struct sackhole *cur = tp->snd_holes;
	if (cur == NULL)
		return; /* No holes */
	if (SEQ_GEQ(tp->snd_nxt, tp->rcv_lastsack))
		return; /* We're already beyond any SACKed blocks */
	/*
	 * Two cases for which we want to advance snd_nxt:
	 * i) snd_nxt lies between end of one hole and beginning of another
	 * ii) snd_nxt lies between end of last hole and rcv_lastsack
	 */
	while (cur->next) {
		if (SEQ_LT(tp->snd_nxt, cur->end))
			return;
		if (SEQ_GEQ(tp->snd_nxt, cur->next->start))
			cur = cur->next;
		else {
			tp->snd_nxt = cur->next->start;
			return;
		}
	}
	if (SEQ_LT(tp->snd_nxt, cur->end))
		return;
	tp->snd_nxt = tp->rcv_lastsack;
	return;
}
#endif /* TCP_SACK */

/*
 * Tcp output routine: figure out what should be sent and send it.
 */
int
tcp_output(struct tcpcb *tp)
{
	struct socket *so = tp->t_inpcb->inp_socket;
	long len, win, txmaxseg;
	int off, flags, error;
	struct mbuf *m;
	struct tcphdr *th;
	u_int32_t optbuf[howmany(MAX_TCPOPTLEN, sizeof(u_int32_t))];
	u_char *opt = (u_char *)optbuf;
	unsigned int optlen, hdrlen, packetlen;
	int idle, sendalot = 0;
#ifdef TCP_SACK
	int i, sack_rxmit = 0;
	struct sackhole *p;
	int maxburst = TCP_MAXBURST;
#endif
#ifdef TCP_SIGNATURE
	unsigned int sigoff;
#endif /* TCP_SIGNATURE */
#ifdef TCP_ECN
	int needect;
#endif

	if (tp->t_flags & TF_BLOCKOUTPUT) {
		tp->t_flags |= TF_NEEDOUTPUT;
		return (0);
	} else
		tp->t_flags &= ~TF_NEEDOUTPUT;

#if defined(TCP_SACK) && defined(TCP_SIGNATURE) && defined(DIAGNOSTIC)
	if (tp->sack_enable && (tp->t_flags & TF_SIGNATURE))
		return (EINVAL);
#endif /* defined(TCP_SACK) && defined(TCP_SIGNATURE) && defined(DIAGNOSTIC) */

	/*
	 * Determine length of data that should be transmitted,
	 * and flags that will be used.
	 * If there is some data or critical controls (SYN, RST)
	 * to send, then transmit; otherwise, investigate further.
	 */
	idle = (tp->t_flags & TF_LASTIDLE) || (tp->snd_max == tp->snd_una);
	if (idle && (tcp_now - tp->t_rcvtime) >= tp->t_rxtcur)
		/*
		 * We have been idle for "a while" and no acks are
		 * expected to clock out any data we send --
		 * slow start to get ack "clock" running again.
		 */
		tp->snd_cwnd = 2 * tp->t_maxseg;

	/* remember 'idle' for next invocation of tcp_output */
	if (idle && soissending(so)) {
		tp->t_flags |= TF_LASTIDLE;
		idle = 0;
	} else
		tp->t_flags &= ~TF_LASTIDLE;

again:
#ifdef TCP_SACK
	/*
	 * If we've recently taken a timeout, snd_max will be greater than
	 * snd_nxt.  There may be SACK information that allows us to avoid
	 * resending already delivered data.  Adjust snd_nxt accordingly.
	 */
	if (tp->sack_enable && SEQ_LT(tp->snd_nxt, tp->snd_max))
		tcp_sack_adjust(tp);
#endif
	off = tp->snd_nxt - tp->snd_una;
#if defined(TCP_SACK) && defined(TCP_FACK)
	/* Normally, sendable data is limited by off < tp->snd_cwnd.
	 * But in FACK, sendable data is limited by snd_awnd < snd_cwnd,
	 * regardless of offset.
	 */
	if (tp->sack_enable && (tp->t_dupacks > tcprexmtthresh))
		win = tp->snd_wnd;
	else
#endif
	win = ulmin(tp->snd_wnd, tp->snd_cwnd);

	flags = tcp_outflags[tp->t_state];

#ifdef TCP_SACK
	/*
	 * Send any SACK-generated retransmissions.  If we're explicitly trying
	 * to send out new data (when sendalot is 1), bypass this function.
	 * If we retransmit in fast recovery mode, decrement snd_cwnd, since
	 * we're replacing a (future) new transmission with a retransmission
	 * now, and we previously incremented snd_cwnd in tcp_input().
	 */
	if (tp->sack_enable && !sendalot) {
		if (tp->t_dupacks >= tcprexmtthresh &&
		    (p = tcp_sack_output(tp))) {
			off = p->rxmit - tp->snd_una;
			sack_rxmit = 1;
			/* Coalesce holes into a single retransmission */
			len = min(tp->t_maxseg, p->end - p->rxmit);
#ifndef TCP_FACK
			/* in FACK, hold snd_cwnd constant during recovery */
			if (SEQ_LT(tp->snd_una, tp->snd_last))
				tp->snd_cwnd -= tp->t_maxseg;
#endif
		}
	}
#endif /* TCP_SACK */

	sendalot = 0;
	/*
	 * If in persist timeout with window of 0, send 1 byte.
	 * Otherwise, if window is small but nonzero
	 * and timer expired, we will send what we can
	 * and go to transmit state.
	 */
	if (tp->t_force) {
		if (win == 0) {
			/*
			 * If we still have some data to send, then
			 * clear the FIN bit.  Usually this would
			 * happen below when it realizes that we
			 * aren't sending all the data.  However,
			 * if we have exactly 1 byte of unset data,
			 * then it won't clear the FIN bit below,
			 * and if we are in persist state, we wind
			 * up sending the packet without recording
			 * that we sent the FIN bit.
			 *
			 * We can't just blindly clear the FIN bit,
			 * because if we don't have any more data
			 * to send then the probe will be the FIN
			 * itself.
			 */
			if (off < so->so_snd.sb_cc)
				flags &= ~TH_FIN;
			win = 1;
		} else {
			TCP_TIMER_DISARM(tp, TCPT_PERSIST);
			tp->t_rxtshift = 0;
		}
	}

#ifdef TCP_SACK
	if (!sack_rxmit) {
#endif
	len = ulmin(so->so_snd.sb_cc, win) - off;

#if defined(TCP_SACK) && defined(TCP_FACK)
	/*
	 * If we're in fast recovery (SEQ_GT(tp->snd_last, tp->snd_una)), and
	 * amount of outstanding data (snd_awnd) is >= snd_cwnd, then
	 * do not send data (like zero window conditions)
	 */
	if (tp->sack_enable && len && SEQ_GT(tp->snd_last, tp->snd_una) &&
	    (tp->snd_awnd >= tp->snd_cwnd))
		len = 0;
#endif /* TCP_FACK */
#ifdef TCP_SACK
	}
#endif

	if (len < 0) {
		/*
		 * If FIN has been sent but not acked,
		 * but we haven't been called to retransmit,
		 * len will be -1.  Otherwise, window shrank
		 * after we sent into it.  If window shrank to 0,
		 * cancel pending retransmit, pull snd_nxt back
		 * to (closed) window, and set the persist timer
		 * if it isn't already going.  If the window didn't
		 * close completely, just wait for an ACK.
		 */
		len = 0;
		if (win == 0) {
			TCP_TIMER_DISARM(tp, TCPT_REXMT);
			tp->t_rxtshift = 0;
			tp->snd_nxt = tp->snd_una;
			if (TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0)
				tcp_setpersist(tp);
		}
	}

        /*
         * Never send more than half a buffer full.  This insures that we can
         * always keep 2 packets on the wire, no matter what SO_SNDBUF is, and
         * therefore acks will never be delayed unless we run out of data to
         * transmit.
         */
	txmaxseg = ulmin(so->so_snd.sb_hiwat / 2, tp->t_maxseg);

	if (len > txmaxseg) {
		len = txmaxseg;
		sendalot = 1;
	}
	if (off + len < so->so_snd.sb_cc)
		flags &= ~TH_FIN;

	win = sbspace(&so->so_rcv);

	/*
	 * Sender silly window avoidance.  If connection is idle
	 * and can send all data, a maximum segment,
	 * at least a maximum default-size segment do it,
	 * or are forced, do it; otherwise don't bother.
	 * If peer's buffer is tiny, then send
	 * when window is at least half open.
	 * If retransmitting (possibly after persist timer forced us
	 * to send into a small window), then must resend.
	 */
	if (len) {
		if (len == txmaxseg)
			goto send;
		if ((idle || (tp->t_flags & TF_NODELAY)) &&
		    len + off >= so->so_snd.sb_cc && !soissending(so) &&
		    (tp->t_flags & TF_NOPUSH) == 0)
			goto send;
		if (tp->t_force)
			goto send;
		if (len >= tp->max_sndwnd / 2 && tp->max_sndwnd > 0)
			goto send;
		if (SEQ_LT(tp->snd_nxt, tp->snd_max))
			goto send;
#ifdef TCP_SACK
		if (sack_rxmit)
			goto send;
#endif
	}

	/*
	 * Compare available window to amount of window
	 * known to peer (as advertised window less
	 * next expected input).  If the difference is at least two
	 * max size segments, or at least 50% of the maximum possible
	 * window, then want to send a window update to peer.
	 */
	if (win > 0) {
		/*
		 * "adv" is the amount we can increase the window,
		 * taking into account that we are limited by
		 * TCP_MAXWIN << tp->rcv_scale.
		 */
		long adv = lmin(win, (long)TCP_MAXWIN << tp->rcv_scale) -
			(tp->rcv_adv - tp->rcv_nxt);

		if (adv >= (long) (2 * tp->t_maxseg))
			goto send;
		if (2 * adv >= (long) so->so_rcv.sb_hiwat)
			goto send;
	}

	/*
	 * Send if we owe peer an ACK.
	 */
	if (tp->t_flags & TF_ACKNOW)
		goto send;
	if (flags & (TH_SYN|TH_RST))
		goto send;
	if (SEQ_GT(tp->snd_up, tp->snd_una))
		goto send;
	/*
	 * If our state indicates that FIN should be sent
	 * and we have not yet done so, or we're retransmitting the FIN,
	 * then we need to send.
	 */
	if (flags & TH_FIN &&
	    ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
		goto send;
#ifdef TCP_SACK
	/*
	 * In SACK, it is possible for tcp_output to fail to send a segment
	 * after the retransmission timer has been turned off.  Make sure
	 * that the retransmission timer is set.
	 */
	if (SEQ_GT(tp->snd_max, tp->snd_una) &&
	    TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
	    TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
		TCP_TIMER_ARM(tp, TCPT_REXMT, tp->t_rxtcur);
		return (0);
	}
#endif /* TCP_SACK */

	/*
	 * TCP window updates are not reliable, rather a polling protocol
	 * using ``persist'' packets is used to insure receipt of window
	 * updates.  The three ``states'' for the output side are:
	 *	idle			not doing retransmits or persists
	 *	persisting		to move a small or zero window
	 *	(re)transmitting	and thereby not persisting
	 *
	 * tp->t_timer[TCPT_PERSIST]
	 *	is set when we are in persist state.
	 * tp->t_force
	 *	is set when we are called to send a persist packet.
	 * tp->t_timer[TCPT_REXMT]
	 *	is set when we are retransmitting
	 * The output side is idle when both timers are zero.
	 *
	 * If send window is too small, there is data to transmit, and no
	 * retransmit or persist is pending, then go to persist state.
	 * If nothing happens soon, send when timer expires:
	 * if window is nonzero, transmit what we can,
	 * otherwise force out a byte.
	 */
	if (so->so_snd.sb_cc && TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
	    TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
		tp->t_rxtshift = 0;
		tcp_setpersist(tp);
	}

	/*
	 * No reason to send a segment, just return.
	 */
	return (0);

send:
	/*
	 * Before ESTABLISHED, force sending of initial options
	 * unless TCP set not to do any options.
	 * NOTE: we assume that the IP/TCP header plus TCP options
	 * always fit in a single mbuf, leaving room for a maximum
	 * link header, i.e.
	 *	max_linkhdr + sizeof(network header) + sizeof(struct tcphdr +
	 *		optlen <= MHLEN
	 */
	optlen = 0;

	switch (tp->pf) {
	case 0:	/*default to PF_INET*/
	case PF_INET:
		hdrlen = sizeof(struct ip) + sizeof(struct tcphdr);
		break;
#ifdef INET6
	case PF_INET6:
		hdrlen = sizeof(struct ip6_hdr) + sizeof(struct tcphdr);
		break;
#endif /* INET6 */
	default:
		return (EPFNOSUPPORT);
	}

	if (flags & TH_SYN) {
		tp->snd_nxt = tp->iss;
		if ((tp->t_flags & TF_NOOPT) == 0) {
			u_int16_t mss;

			opt[0] = TCPOPT_MAXSEG;
			opt[1] = 4;
			mss = htons((u_int16_t) tcp_mss(tp, 0));
			memcpy(opt + 2, &mss, sizeof(mss));
			optlen = 4;

			if (flags & TH_ACK)
				tcp_mss_update(tp);
#ifdef TCP_SACK
			/*
			 * If this is the first SYN of connection (not a SYN
			 * ACK), include SACK_PERMIT_HDR option.  If this is a
			 * SYN ACK, include SACK_PERMIT_HDR option if peer has
			 * already done so.
			 */
			if (tp->sack_enable && ((flags & TH_ACK) == 0 ||
			    (tp->t_flags & TF_SACK_PERMIT))) {
				*((u_int32_t *) (opt + optlen)) =
				    htonl(TCPOPT_SACK_PERMIT_HDR);
				optlen += 4;
			}
#endif

			if ((tp->t_flags & TF_REQ_SCALE) &&
			    ((flags & TH_ACK) == 0 ||
			    (tp->t_flags & TF_RCVD_SCALE))) {
				*((u_int32_t *) (opt + optlen)) = htonl(
					TCPOPT_NOP << 24 |
					TCPOPT_WINDOW << 16 |
					TCPOLEN_WINDOW << 8 |
					tp->request_r_scale);
				optlen += 4;
			}
		}
	}

	/*
	 * Send a timestamp and echo-reply if this is a SYN and our side
	 * wants to use timestamps (TF_REQ_TSTMP is set) or both our side
	 * and our peer have sent timestamps in our SYN's.
	 */
	if ((tp->t_flags & (TF_REQ_TSTMP|TF_NOOPT)) == TF_REQ_TSTMP &&
	     (flags & TH_RST) == 0 &&
	    ((flags & (TH_SYN|TH_ACK)) == TH_SYN ||
	     (tp->t_flags & TF_RCVD_TSTMP))) {
		u_int32_t *lp = (u_int32_t *)(opt + optlen);

		/* Form timestamp option as shown in appendix A of RFC 1323. */
		*lp++ = htonl(TCPOPT_TSTAMP_HDR);
		*lp++ = htonl(tcp_now + tp->ts_modulate);
		*lp   = htonl(tp->ts_recent);
		optlen += TCPOLEN_TSTAMP_APPA;

		/* Set receive buffer autosizing timestamp. */
		if (tp->rfbuf_ts == 0)
			tp->rfbuf_ts = tcp_now;

	}

#ifdef TCP_SIGNATURE
	if (tp->t_flags & TF_SIGNATURE) {
		u_int8_t *bp = (u_int8_t *)(opt + optlen);

		/* Send signature option */
		*(bp++) = TCPOPT_SIGNATURE;
		*(bp++) = TCPOLEN_SIGNATURE;
		sigoff = optlen + 2;

		{
			unsigned int i;

			for (i = 0; i < 16; i++)
				*(bp++) = 0;
		}


		/* Pad options list to the next 32 bit boundary and
		 * terminate it.
		 */
		*bp++ = TCPOPT_NOP;
		*bp++ = TCPOPT_NOP;

		optlen += TCPOLEN_SIGLEN;
	}
#endif /* TCP_SIGNATURE */

#ifdef TCP_SACK
	/*
	 * Send SACKs if necessary.  This should be the last option processed.
	 * Only as many SACKs are sent as are permitted by the maximum options
	 * size.  No more than three SACKs are sent.
	 */
	if (tp->sack_enable && tp->t_state == TCPS_ESTABLISHED &&
	    (tp->t_flags & (TF_SACK_PERMIT|TF_NOOPT)) == TF_SACK_PERMIT &&
	    tp->rcv_numsacks) {
		u_int32_t *lp = (u_int32_t *)(opt + optlen);
		u_int32_t *olp = lp++;
		int count = 0;  /* actual number of SACKs inserted */
		int maxsack = (MAX_TCPOPTLEN - (optlen + 4))/TCPOLEN_SACK;

		tcpstat_inc(tcps_sack_snd_opts);
		maxsack = min(maxsack, TCP_MAX_SACK);
		for (i = 0; (i < tp->rcv_numsacks && count < maxsack); i++) {
			struct sackblk sack = tp->sackblks[i];
			if (sack.start == 0 && sack.end == 0)
				continue;
			*lp++ = htonl(sack.start);
			*lp++ = htonl(sack.end);
			count++;
		}
		*olp = htonl(TCPOPT_SACK_HDR|(TCPOLEN_SACK*count+2));
		optlen += TCPOLEN_SACK*count + 4; /* including leading NOPs */
	}
#endif /* TCP_SACK */

#ifdef DIAGNOSTIC
	if (optlen > MAX_TCPOPTLEN)
		panic("tcp_output: options too long");
#endif /* DIAGNOSTIC */

	hdrlen += optlen;

	/*
	 * Adjust data length if insertion of options will
	 * bump the packet length beyond the t_maxopd length.
	 */
	if (len > tp->t_maxopd - optlen) {
		len = tp->t_maxopd - optlen;
		sendalot = 1;
		flags &= ~TH_FIN;
	 }

#ifdef DIAGNOSTIC
	if (max_linkhdr + hdrlen > MCLBYTES)
		panic("tcphdr too big");
#endif

	/*
	 * Grab a header mbuf, attaching a copy of data to
	 * be transmitted, and initialize the header from
	 * the template for sends on this connection.
	 */
	if (len) {
		if (tp->t_force && len == 1)
			tcpstat_inc(tcps_sndprobe);
		else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) {
			tcpstat_pkt(tcps_sndrexmitpack, tcps_sndrexmitbyte,
			    len);
		} else {
			tcpstat_pkt(tcps_sndpack, tcps_sndbyte, len);
		}
#ifdef notyet
		if ((m = m_copypack(so->so_snd.sb_mb, off,
		    (int)len, max_linkhdr + hdrlen)) == 0) {
			error = ENOBUFS;
			goto out;
		}
		/*
		 * m_copypack left space for our hdr; use it.
		 */
		m->m_len += hdrlen;
		m->m_data -= hdrlen;
#else
		MGETHDR(m, M_DONTWAIT, MT_HEADER);
		if (m != NULL && max_linkhdr + hdrlen > MHLEN) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_freem(m);
				m = NULL;
			}
		}
		if (m == NULL) {
			error = ENOBUFS;
			goto out;
		}
		m->m_data += max_linkhdr;
		m->m_len = hdrlen;
		if (len <= M_TRAILINGSPACE(m)) {
			m_copydata(so->so_snd.sb_mb, off, (int) len,
			    mtod(m, caddr_t) + hdrlen);
			m->m_len += len;
		} else {
			m->m_next = m_copym(so->so_snd.sb_mb, off, (int) len,
			    M_NOWAIT);
			if (m->m_next == 0) {
				(void) m_free(m);
				error = ENOBUFS;
				goto out;
			}
		}
		if (so->so_snd.sb_mb->m_flags & M_PKTHDR)
			m->m_pkthdr.ph_loopcnt =
			    so->so_snd.sb_mb->m_pkthdr.ph_loopcnt;
#endif
		/*
		 * If we're sending everything we've got, set PUSH.
		 * (This will keep happy those implementations which only
		 * give data to the user when a buffer fills or
		 * a PUSH comes in.)
		 */
		if (off + len == so->so_snd.sb_cc && !soissending(so))
			flags |= TH_PUSH;
	} else {
		if (tp->t_flags & TF_ACKNOW)
			tcpstat_inc(tcps_sndacks);
		else if (flags & (TH_SYN|TH_FIN|TH_RST))
			tcpstat_inc(tcps_sndctrl);
		else if (SEQ_GT(tp->snd_up, tp->snd_una))
			tcpstat_inc(tcps_sndurg);
		else
			tcpstat_inc(tcps_sndwinup);

		MGETHDR(m, M_DONTWAIT, MT_HEADER);
		if (m != NULL && max_linkhdr + hdrlen > MHLEN) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_freem(m);
				m = NULL;
			}
		}
		if (m == NULL) {
			error = ENOBUFS;
			goto out;
		}
		m->m_data += max_linkhdr;
		m->m_len = hdrlen;
	}
	m->m_pkthdr.ph_ifidx = 0;
	m->m_pkthdr.len = hdrlen + len;

	if (!tp->t_template)
		panic("tcp_output");
#ifdef DIAGNOSTIC
	if (tp->t_template->m_len != hdrlen - optlen)
		panic("tcp_output: template len != hdrlen - optlen");
#endif /* DIAGNOSTIC */
	memcpy(mtod(m, caddr_t), mtod(tp->t_template, caddr_t),
	    tp->t_template->m_len);
	th = (struct tcphdr *)(mtod(m, caddr_t) + tp->t_template->m_len -
		sizeof(struct tcphdr));

	/*
	 * Fill in fields, remembering maximum advertised
	 * window for use in delaying messages about window sizes.
	 * If resending a FIN, be sure not to use a new sequence number.
	 */
	if ((flags & TH_FIN) && (tp->t_flags & TF_SENTFIN) &&
	    (tp->snd_nxt == tp->snd_max))
		tp->snd_nxt--;
	/*
	 * If we are doing retransmissions, then snd_nxt will
	 * not reflect the first unsent octet.  For ACK only
	 * packets, we do not want the sequence number of the
	 * retransmitted packet, we want the sequence number
	 * of the next unsent octet.  So, if there is no data
	 * (and no SYN or FIN), use snd_max instead of snd_nxt
	 * when filling in ti_seq.  But if we are in persist
	 * state, snd_max might reflect one byte beyond the
	 * right edge of the window, so use snd_nxt in that
	 * case, since we know we aren't doing a retransmission.
	 * (retransmit and persist are mutually exclusive...)
	 */
	if (len || (flags & (TH_SYN|TH_FIN)) || TCP_TIMER_ISARMED(tp, TCPT_PERSIST))
		th->th_seq = htonl(tp->snd_nxt);
	else
		th->th_seq = htonl(tp->snd_max);

#ifdef TCP_SACK
	if (sack_rxmit) {
		/*
		 * If sendalot was turned on (due to option stuffing), turn it
		 * off. Properly set th_seq field.  Advance the ret'x pointer
		 * by len.
		 */
		if (sendalot)
			sendalot = 0;
		th->th_seq = htonl(p->rxmit);
		p->rxmit += len;
#if defined(TCP_SACK) && defined(TCP_FACK)
		tp->retran_data += len;
#endif /* TCP_FACK */
		tcpstat_pkt(tcps_sack_rexmits, tcps_sack_rexmit_bytes, len);
	}
#endif /* TCP_SACK */

	th->th_ack = htonl(tp->rcv_nxt);
	if (optlen) {
		memcpy(th + 1, opt, optlen);
		th->th_off = (sizeof (struct tcphdr) + optlen) >> 2;
	}
#ifdef TCP_ECN
	if (tcp_do_ecn) {
		/*
		 * if we have received congestion experienced segs,
		 * set ECE bit.
		 */
		if (tp->t_flags & TF_RCVD_CE) {
			flags |= TH_ECE;
			tcpstat_inc(tcps_ecn_sndece);
		}
		if (!(tp->t_flags & TF_DISABLE_ECN)) {
			/*
			 * if this is a SYN seg, set ECE and CWR.
			 * set only ECE for SYN-ACK if peer supports ECN.
			 */
			if ((flags & (TH_SYN|TH_ACK)) == TH_SYN)
				flags |= (TH_ECE|TH_CWR);
			else if ((tp->t_flags & TF_ECN_PERMIT) &&
				 (flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK))
				flags |= TH_ECE;
		}
		/*
		 * if we have reduced the congestion window, notify
		 * the peer by setting CWR bit.
		 */
		if ((tp->t_flags & TF_ECN_PERMIT) &&
		    (tp->t_flags & TF_SEND_CWR)) {
			flags |= TH_CWR;
			tp->t_flags &= ~TF_SEND_CWR;
			tcpstat_inc(tcps_ecn_sndcwr);
		}
	}
#endif
	th->th_flags = flags;

	/*
	 * Calculate receive window.  Don't shrink window,
	 * but avoid silly window syndrome.
	 */
	if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
		win = 0;
	if (win > (long)TCP_MAXWIN << tp->rcv_scale)
		win = (long)TCP_MAXWIN << tp->rcv_scale;
	if (win < (long)(int32_t)(tp->rcv_adv - tp->rcv_nxt))
		win = (long)(int32_t)(tp->rcv_adv - tp->rcv_nxt);
	if (flags & TH_RST)
		win = 0;
	th->th_win = htons((u_int16_t) (win>>tp->rcv_scale));
	if (SEQ_GT(tp->snd_up, tp->snd_nxt)) {
		u_int32_t urp = tp->snd_up - tp->snd_nxt;
		if (urp > IP_MAXPACKET)
			urp = IP_MAXPACKET;
		th->th_urp = htons((u_int16_t)urp);
		th->th_flags |= TH_URG;
	} else
		/*
		 * If no urgent pointer to send, then we pull
		 * the urgent pointer to the left edge of the send window
		 * so that it doesn't drift into the send window on sequence
		 * number wraparound.
		 */
		tp->snd_up = tp->snd_una;		/* drag it along */

#ifdef TCP_SIGNATURE
	if (tp->t_flags & TF_SIGNATURE) {
		int iphlen;
		union sockaddr_union src, dst;
		struct tdb *tdb;

		bzero(&src, sizeof(union sockaddr_union));
		bzero(&dst, sizeof(union sockaddr_union));

		switch (tp->pf) {
		case 0:	/*default to PF_INET*/
		case AF_INET:
			iphlen = sizeof(struct ip);
			src.sa.sa_len = sizeof(struct sockaddr_in);
			src.sa.sa_family = AF_INET;
			src.sin.sin_addr = mtod(m, struct ip *)->ip_src;
			dst.sa.sa_len = sizeof(struct sockaddr_in);
			dst.sa.sa_family = AF_INET;
			dst.sin.sin_addr = mtod(m, struct ip *)->ip_dst;
			break;
#ifdef INET6
		case AF_INET6:
			iphlen = sizeof(struct ip6_hdr);
			src.sa.sa_len = sizeof(struct sockaddr_in6);
			src.sa.sa_family = AF_INET6;
			src.sin6.sin6_addr = mtod(m, struct ip6_hdr *)->ip6_src;
			dst.sa.sa_len = sizeof(struct sockaddr_in6);
			dst.sa.sa_family = AF_INET6;
			dst.sin6.sin6_addr = mtod(m, struct ip6_hdr *)->ip6_dst;
			break;
#endif /* INET6 */
		}

		tdb = gettdbbysrcdst(rtable_l2(tp->t_inpcb->inp_rtableid),
		    0, &src, &dst, IPPROTO_TCP);
		if (tdb == NULL) {
			m_freem(m);
			return (EPERM);
		}

		if (tcp_signature(tdb, tp->pf, m, th, iphlen, 0,
		    mtod(m, caddr_t) + hdrlen - optlen + sigoff) < 0) {
			m_freem(m);
			return (EINVAL);
		}
	}
#endif /* TCP_SIGNATURE */

	/* Defer checksumming until later (ip_output() or hardware) */
	m->m_pkthdr.csum_flags |= M_TCP_CSUM_OUT;

	/*
	 * In transmit state, time the transmission and arrange for
	 * the retransmit.  In persist state, just set snd_max.
	 */
	if (tp->t_force == 0 || TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
		tcp_seq startseq = tp->snd_nxt;

		/*
		 * Advance snd_nxt over sequence space of this segment.
		 */
		if (flags & (TH_SYN|TH_FIN)) {
			if (flags & TH_SYN)
				tp->snd_nxt++;
			if (flags & TH_FIN) {
				tp->snd_nxt++;
				tp->t_flags |= TF_SENTFIN;
			}
		}
#ifdef TCP_SACK
		if (tp->sack_enable) {
			if (sack_rxmit && (p->rxmit != tp->snd_nxt)) {
				goto timer;
			}
		}
#endif
		tp->snd_nxt += len;
		if (SEQ_GT(tp->snd_nxt, tp->snd_max)) {
			tp->snd_max = tp->snd_nxt;
			/*
			 * Time this transmission if not a retransmission and
			 * not currently timing anything.
			 */
			if (tp->t_rtttime == 0) {
				tp->t_rtttime = tcp_now;
				tp->t_rtseq = startseq;
				tcpstat_inc(tcps_segstimed);
			}
		}

		/*
		 * Set retransmit timer if not currently set,
		 * and not doing an ack or a keep-alive probe.
		 * Initial value for retransmit timer is smoothed
		 * round-trip time + 2 * round-trip time variance.
		 * Initialize shift counter which is used for backoff
		 * of retransmit time.
		 */
#ifdef TCP_SACK
 timer:
		if (tp->sack_enable && sack_rxmit &&
		    TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
		    tp->snd_nxt != tp->snd_max) {
			TCP_TIMER_ARM(tp, TCPT_REXMT, tp->t_rxtcur);
			if (TCP_TIMER_ISARMED(tp, TCPT_PERSIST)) {
				TCP_TIMER_DISARM(tp, TCPT_PERSIST);
				tp->t_rxtshift = 0;
			}
		}
#endif

		if (TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
		    tp->snd_nxt != tp->snd_una) {
			TCP_TIMER_ARM(tp, TCPT_REXMT, tp->t_rxtcur);
			if (TCP_TIMER_ISARMED(tp, TCPT_PERSIST)) {
				TCP_TIMER_DISARM(tp, TCPT_PERSIST);
				tp->t_rxtshift = 0;
			}
		}

		if (len == 0 && so->so_snd.sb_cc &&
		    TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
		    TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
			/*
			 * Avoid a situation where we do not set persist timer
			 * after a zero window condition. For example:
			 * 1) A -> B: packet with enough data to fill the window
			 * 2) B -> A: ACK for #1 + new data (0 window
			 *    advertisement)
			 * 3) A -> B: ACK for #2, 0 len packet
			 *
			 * In this case, A will not activate the persist timer,
			 * because it chose to send a packet. Unless tcp_output
			 * is called for some other reason (delayed ack timer,
			 * another input packet from B, socket syscall), A will
			 * not send zero window probes.
			 *
			 * So, if you send a 0-length packet, but there is data
			 * in the socket buffer, and neither the rexmt or
			 * persist timer is already set, then activate the
			 * persist timer.
			 */
			tp->t_rxtshift = 0;
			tcp_setpersist(tp);
		}
	} else
		if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
			tp->snd_max = tp->snd_nxt + len;

	tcp_update_sndspace(tp);

	/*
	 * Trace.
	 */
	if (so->so_options & SO_DEBUG)
		tcp_trace(TA_OUTPUT, tp->t_state, tp, mtod(m, caddr_t), 0,
			len);

	/*
	 * Fill in IP length and desired time to live and
	 * send to IP level.  There should be a better way
	 * to handle ttl and tos; we could keep them in
	 * the template, but need a way to checksum without them.
	 */

#ifdef TCP_ECN
	/*
	 * if peer is ECN capable, set the ECT bit in the IP header.
	 * but don't set ECT for a pure ack, a retransmit or a window probe.
	 */
	needect = 0;
	if (tcp_do_ecn && (tp->t_flags & TF_ECN_PERMIT)) {
		if (len == 0 || SEQ_LT(tp->snd_nxt, tp->snd_max) ||
		    (tp->t_force && len == 1)) {
			/* don't set ECT */
		} else {
			needect = 1;
			tcpstat_inc(tcps_ecn_sndect);
		}
	}
#endif

	/* force routing table */
	m->m_pkthdr.ph_rtableid = tp->t_inpcb->inp_rtableid;

#if NPF > 0
	m->m_pkthdr.pf.inp = tp->t_inpcb;
#endif

	switch (tp->pf) {
	case 0:	/*default to PF_INET*/
	case AF_INET:
		{
			struct ip *ip;

			ip = mtod(m, struct ip *);
			ip->ip_len = htons(m->m_pkthdr.len);
			packetlen = m->m_pkthdr.len;
			ip->ip_ttl = tp->t_inpcb->inp_ip.ip_ttl;
			ip->ip_tos = tp->t_inpcb->inp_ip.ip_tos;
#ifdef TCP_ECN
			if (needect)
				ip->ip_tos |= IPTOS_ECN_ECT0;
#endif
		}
		error = ip_output(m, tp->t_inpcb->inp_options,
			&tp->t_inpcb->inp_route,
			(ip_mtudisc ? IP_MTUDISC : 0), NULL, tp->t_inpcb, 0);
		break;
#ifdef INET6
	case AF_INET6:
		{
			struct ip6_hdr *ip6;

			ip6 = mtod(m, struct ip6_hdr *);
			ip6->ip6_plen = m->m_pkthdr.len -
				sizeof(struct ip6_hdr);
			packetlen = m->m_pkthdr.len;
			ip6->ip6_nxt = IPPROTO_TCP;
			ip6->ip6_hlim = in6_selecthlim(tp->t_inpcb);
#ifdef TCP_ECN
			if (needect)
				ip6->ip6_flow |= htonl(IPTOS_ECN_ECT0 << 20);
#endif
		}
		error = ip6_output(m, tp->t_inpcb->inp_outputopts6,
			  &tp->t_inpcb->inp_route6,
			  0, NULL, tp->t_inpcb);
		break;
#endif /* INET6 */
	}

#if defined(TCP_SACK) && defined(TCP_FACK)
	/* Update snd_awnd to reflect the new data that was sent.  */
	tp->snd_awnd = tcp_seq_subtract(tp->snd_max, tp->snd_fack) +
		tp->retran_data;
#endif /* defined(TCP_SACK) && defined(TCP_FACK) */

	if (error) {
out:
		if (error == ENOBUFS) {
			/*
			 * If the interface queue is full, or IP cannot
			 * get an mbuf, trigger TCP slow start.
			 */
			tp->snd_cwnd = tp->t_maxseg;
			return (0);
		}
		if (error == EMSGSIZE) {
			/*
			 * ip_output() will have already fixed the route
			 * for us.  tcp_mtudisc() will, as its last action,
			 * initiate retransmission, so it is important to
			 * not do so here.
			 */
			tcp_mtudisc(tp->t_inpcb, -1);
			return (0);
		}
		if (error == EACCES)	/* translate pf(4) error for userland */
			error = EHOSTUNREACH;
		if ((error == EHOSTUNREACH || error == ENETDOWN) &&
		    TCPS_HAVERCVDSYN(tp->t_state)) {
			tp->t_softerror = error;
			return (0);
		}

		/* Restart the delayed ACK timer, if necessary. */
		if (tp->t_flags & TF_DELACK)
			TCP_RESTART_DELACK(tp);

		return (error);
	}

	if (packetlen > tp->t_pmtud_mtu_sent)
		tp->t_pmtud_mtu_sent = packetlen;

	tcpstat_inc(tcps_sndtotal);
	if (tp->t_flags & TF_DELACK)
		tcpstat_inc(tcps_delack);

	/*
	 * Data sent (as far as we can tell).
	 * If this advertises a larger window than any other segment,
	 * then remember the size of the advertised window.
	 * Any pending ACK has now been sent.
	 */
	if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
		tp->rcv_adv = tp->rcv_nxt + win;
	tp->last_ack_sent = tp->rcv_nxt;
	tp->t_flags &= ~TF_ACKNOW;
	TCP_CLEAR_DELACK(tp);
#if defined(TCP_SACK)
	if (sendalot && --maxburst)
#else
	if (sendalot)
#endif
		goto again;
	return (0);
}

void
tcp_setpersist(struct tcpcb *tp)
{
	int t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> (1 + TCP_RTT_BASE_SHIFT);
	int nticks;

	if (TCP_TIMER_ISARMED(tp, TCPT_REXMT))
		panic("tcp_output REXMT");
	/*
	 * Start/restart persistence timer.
	 */
	if (t < tp->t_rttmin)
		t = tp->t_rttmin;
	TCPT_RANGESET(nticks, t * tcp_backoff[tp->t_rxtshift],
	    TCPTV_PERSMIN, TCPTV_PERSMAX);
	TCP_TIMER_ARM(tp, TCPT_PERSIST, nticks);
	if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
		tp->t_rxtshift++;
}
@


1.118
log
@Plug an mbuf leak in the error path of tcp signature in tcp_output().
OK claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.117 2016/06/13 21:24:43 bluhm Exp $	*/
d644 1
a644 1
		tcpstat.tcps_sack_snd_opts++;
d688 1
a688 1
			tcpstat.tcps_sndprobe++;
d690 2
a691 2
			tcpstat.tcps_sndrexmitpack++;
			tcpstat.tcps_sndrexmitbyte += len;
d693 1
a693 2
			tcpstat.tcps_sndpack++;
			tcpstat.tcps_sndbyte += len;
d748 1
a748 1
			tcpstat.tcps_sndacks++;
d750 1
a750 1
			tcpstat.tcps_sndctrl++;
d752 1
a752 1
			tcpstat.tcps_sndurg++;
d754 1
a754 1
			tcpstat.tcps_sndwinup++;
d825 1
a825 2
		tcpstat.tcps_sack_rexmits++;
		tcpstat.tcps_sack_rexmit_bytes += len;
d842 1
a842 1
			tcpstat.tcps_ecn_sndece++;
d863 1
a863 1
			tcpstat.tcps_ecn_sndcwr++;
d983 1
a983 1
				tcpstat.tcps_segstimed++;
d1074 1
a1074 1
			tcpstat.tcps_ecn_sndect++;
d1173 1
a1173 1
	tcpstat.tcps_sndtotal++;
d1175 1
a1175 1
		tcpstat.tcps_delack++;
@


1.117
log
@On localhost a user program may create a socket splicing loop.
After writing data into this loop, it was spinning forever causing
a kernel hang.  Detect the loop by counting how often the same mbuf
is spliced.  If that happens 128 times, assume that there is a loop
and abort the splicing with ELOOP.
Bug found by tedu@@;  OK tedu@@ millert@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.116 2015/12/05 10:52:26 tedu Exp $	*/
d934 2
a935 1
		if (tdb == NULL)
d937 1
d940 2
a941 1
		    mtod(m, caddr_t) + hdrlen - optlen + sigoff) < 0)
d943 1
@


1.116
log
@upgrade tcp/ip to use the latest in C89 technology: memcpy.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.115 2015/10/24 16:08:48 mpi Exp $	*/
d735 3
@


1.116.2.1
log
@backport splice loop fix:
On localhost a user program may create a socket splicing loop.
After writing data into this loop, it was spinning forever causing
a kernel hang.  Detect the loop by counting how often the same mbuf
is spliced.  If that happens 128 times, assume that there is a loop
and abort the splicing with ELOOP.
Bug found by tedu@@;  OK tedu@@ millert@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.116 2015/12/05 10:52:26 tedu Exp $	*/
a734 3
		if (so->so_snd.sb_mb->m_flags & M_PKTHDR)
			m->m_pkthdr.ph_loopcnt =
			    so->so_snd.sb_mb->m_pkthdr.ph_loopcnt;
@


1.115
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.114 2015/09/11 08:17:06 claudio Exp $	*/
d547 1
a547 1
			bcopy((caddr_t)&mss, (caddr_t)(opt + 2), sizeof(mss));
d778 2
a779 2
	bcopy(mtod(tp->t_template, caddr_t), mtod(m, caddr_t),
		tp->t_template->m_len);
d830 1
a830 1
		bcopy((caddr_t)opt, (caddr_t)(th + 1), optlen);
@


1.114
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.113 2015/07/13 23:11:37 bluhm Exp $	*/
d1111 1
a1111 1
			ip6->ip6_hlim = in6_selecthlim(tp->t_inpcb, NULL);
@


1.113
log
@Avoid a situation where we do not set the tcp persist timer after
a zero window condition.  If you send a 0-length packet, but there
is data is the socket buffer, and neither the rexmt or persist timer
is already set, then activate the persist timer.
From FreeBSD revision 284941; OK deraadt@@ markus@@ mikeb@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.112 2015/06/30 15:30:17 mpi Exp $	*/
d1119 1
a1119 1
			  0, NULL, NULL, tp->t_inpcb);
@


1.113.4.1
log
@I forgot to commit the 5.8 version of the splice fix.
Reminded by Florian Riehm
backport splice loop fix:
On localhost a user program may create a socket splicing loop.
After writing data into this loop, it was spinning forever causing
a kernel hang.  Detect the loop by counting how often the same mbuf
is spliced.  If that happens 128 times, assume that there is a loop
and abort the splicing with ELOOP.
Bug found by tedu@@;  OK tedu@@ millert@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.113 2015/07/13 23:11:37 bluhm Exp $	*/
a734 3
		if (so->so_snd.sb_mb->m_flags & M_PKTHDR)
			m->m_pkthdr.ph_loopcnt =
			    so->so_snd.sb_mb->m_pkthdr.ph_loopcnt;
@


1.112
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.111 2015/06/16 11:09:40 mpi Exp $	*/
d1010 26
@


1.111
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.110 2015/06/07 01:25:27 krw Exp $	*/
d727 2
a728 1
			m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
@


1.110
log
@Replace a bunch of == 0 with == NULL in pointer tests. Nuke some
annoying trailing, leading and embedded whitespace. No change to
.o files.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.109 2015/03/14 03:38:52 jsg Exp $	*/
d768 1
a768 1
	m->m_pkthdr.rcvif = (struct ifnet *)0;
@


1.109
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.108 2014/12/19 17:14:40 tedu Exp $	*/
d45 4
a48 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d112 1
a112 1
	if (p == 0)
d158 1
a158 1
        	p = p->next;
d303 1
a303 1
    		}
d521 1
a521 1
	 * 		optlen <= MHLEN
d1106 1
a1106 1
			/* 
d1109 1
a1109 1
			 */ 
d1137 1
a1137 1
	
d1140 1
a1140 1
	
@


1.108
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.107 2014/07/22 11:06:10 mpi Exp $	*/
a81 1
#include <net/if.h>
@


1.108.2.1
log
@Avoid a situation where we do not set the tcp persist timer after
a zero window condition.  If you send a 0-length packet, but there
is data is the socket buffer, and neither the rexmt or persist timer
is already set, then activate the persist timer.
From FreeBSD revision 284941; OK deraadt@@ markus@@ mikeb@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.108 2014/12/19 17:14:40 tedu Exp $	*/
a1009 26
		}

		if (len == 0 && so->so_snd.sb_cc &&
		    TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
		    TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
			/*
			 * Avoid a situation where we do not set persist timer
			 * after a zero window condition. For example:
			 * 1) A -> B: packet with enough data to fill the window
			 * 2) B -> A: ACK for #1 + new data (0 window
			 *    advertisement)
			 * 3) A -> B: ACK for #2, 0 len packet
			 *
			 * In this case, A will not activate the persist timer,
			 * because it chose to send a packet. Unless tcp_output
			 * is called for some other reason (delayed ack timer,
			 * another input packet from B, socket syscall), A will
			 * not send zero window probes.
			 *
			 * So, if you send a 0-length packet, but there is data
			 * in the socket buffer, and neither the rexmt or
			 * persist timer is already set, then activate the
			 * persist timer.
			 */
			tp->t_rxtshift = 0;
			tcp_setpersist(tp);
@


1.107
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.106 2014/04/21 12:22:26 henning Exp $	*/
a527 1
#ifdef INET
a530 1
#endif /* INET */
a906 1
#ifdef INET
a915 1
#endif /* INET */
a1056 1
#ifdef INET
a1074 1
#endif /* INET */
@


1.107.4.1
log
@Avoid a situation where we do not set the tcp persist timer after
a zero window condition.  If you send a 0-length packet, but there
is data is the socket buffer, and neither the rexmt or persist timer
is already set, then activate the persist timer.
From FreeBSD revision 284941; OK deraadt@@ markus@@ mikeb@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.107 2014/07/22 11:06:10 mpi Exp $	*/
a1013 26
		}

		if (len == 0 && so->so_snd.sb_cc &&
		    TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
		    TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
			/*
			 * Avoid a situation where we do not set persist timer
			 * after a zero window condition. For example:
			 * 1) A -> B: packet with enough data to fill the window
			 * 2) B -> A: ACK for #1 + new data (0 window
			 *    advertisement)
			 * 3) A -> B: ACK for #2, 0 len packet
			 *
			 * In this case, A will not activate the persist timer,
			 * because it chose to send a packet. Unless tcp_output
			 * is called for some other reason (delayed ack timer,
			 * another input packet from B, socket syscall), A will
			 * not send zero window probes.
			 *
			 * So, if you send a 0-length packet, but there is data
			 * in the socket buffer, and neither the rexmt or
			 * persist timer is already set, then activate the
			 * persist timer.
			 */
			tp->t_rxtshift = 0;
			tcp_setpersist(tp);
@


1.106
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.104 2014/04/07 10:04:17 mpi Exp $	*/
a84 1
#include <netinet/in_systm.h>
@


1.105
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1079 1
a1079 1
			(ip_mtudisc ? IP_MTUDISC : 0), NULL, tp->t_inpcb);
@


1.104
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.102 2014/03/27 13:27:28 mpi Exp $	*/
d1053 2
a1054 2
	/* force routing domain */
	m->m_pkthdr.rdomain = tp->t_inpcb->inp_rtableid;
@


1.103
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.101 2013/10/24 11:31:43 mpi Exp $	*/
d1079 1
a1079 3
			(ip_mtudisc ? IP_MTUDISC : 0) |
				  (so->so_options & SO_DONTROUTE),
			(void *)NULL, tp->t_inpcb);
d1100 1
a1100 2
			  (so->so_options & SO_DONTROUTE), NULL, NULL,
			  tp->t_inpcb);
@


1.102
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d1079 3
a1081 1
			(ip_mtudisc ? IP_MTUDISC : 0), NULL, tp->t_inpcb);
d1102 2
a1103 1
			  0, NULL, NULL, tp->t_inpcb);
@


1.101
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.100 2013/10/19 10:38:55 henning Exp $	*/
d1079 1
a1079 3
			(ip_mtudisc ? IP_MTUDISC : 0) |
				  (so->so_options & SO_DONTROUTE),
			(void *)NULL, tp->t_inpcb);
d1100 1
a1100 2
			  (so->so_options & SO_DONTROUTE), NULL, NULL,
			  tp->t_inpcb);
@


1.100
log
@make in_proto_cksum_out not rely on the pseudo header checksum to be
already there, just compute it - it's dirt cheap. since that happens
very late in ip_output, the rest of the stack doesn't have to care about
checksums at all any more, if something needs to be checksummed, just
set the flag on the pkthdr mbuf to indicate so.
stop pre-computing the pseudo header checksum and incrementally updating it
in the tcp and udp stacks.
ok lteo florian
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.98 2013/06/03 16:57:06 bluhm Exp $	*/
a96 5

#ifdef INET6
#include <netinet6/tcpipv6.h>
#include <netinet6/in6_var.h>
#endif /* INET6 */
@


1.99
log
@Add the TCP socket option TCP_NOPUSH to delay sending the stream.
This is useful to aggregate data in the kernel from multiple sources
like writes and socket splicing.  It avoids sending small packets.
From FreeBSD via David Hill; OK mikeb@@ henning@@
@
text
@d950 2
a951 22
	/*
	 * Put TCP length in extended header, and then
	 * checksum extended header and data.
	 */
	switch (tp->pf) {
	case 0:	/*default to PF_INET*/
#ifdef INET
	case AF_INET:
		/* Defer checksumming until later (ip_output() or hardware) */
		m->m_pkthdr.csum_flags |= M_TCP_CSUM_OUT;
		if (len + optlen)
			th->th_sum = in_cksum_addword(th->th_sum,
			    htons((u_int16_t)(len + optlen)));
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		th->th_sum = in6_cksum(m, IPPROTO_TCP, sizeof(struct ip6_hdr),
			hdrlen - sizeof(struct ip6_hdr) + len);
		break;
#endif /* INET6 */
	}
@


1.98
log
@Link pf states and socket inpcbs together more tightly.  The linking
was only done when a packet traveled up the stack from pf to
tcp_input().  Now also link the state and inpcb when the packet is
going down from tcp_output() to pf.  As a consequence, divert-reply
states where the initial SYN does not get an answer, can be handled
more correctly.

This change is part of a larger diff that has been backed out in
2011.  Bring the feature back in small steps to see when bad things
start to happen.

OK henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.97 2012/09/20 10:25:03 blambert Exp $	*/
d418 3
a420 2
		if ((idle || tp->t_flags & TF_NODELAY) &&
		    len + off >= so->so_snd.sb_cc && !soissending(so))
@


1.97
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.96 2011/05/13 14:31:17 oga Exp $	*/
d71 2
d1079 4
@


1.96
log
@Revert the pf->socket linking diff.

at least krw@@, pirofti@@ and todd@@ have been seeing panics (todd and krw
with xxxterm not sure about pirofti) involving pool corruption while
using this commit.

krw and todd confirm that this backout fixes the problem.

ok blambert@@ krw@@, todd@@ henning@@ and kettenis@@

	    Double link between pf states and sockets.  Henning has
	    already implemented half of it.  The additional part is: -
	    The pf state lookup for outgoing packets is optimized by
	    using mbuf->inp->state.
	    - For incomming tcp, udp, raw, raw6 packets the socket
	    lookup always is optimized by using mbuf->state->inp.
	    - All protocols establish the link for incomming packets.
	    - All protocols set the inp in the mbuf for outgoing packets.
	      This allows the linkage beginning with the first packet
	      for outgoing connections.
	    - In case of divert states, delete the state when the socket
	      closes.  Otherwise new connections could match on old
	      states instead of being diverted to the listen socket.
	    ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.95 2011/04/24 19:36:54 bluhm Exp $	*/
a935 2
		/* XXX gettdbbysrcdst() should really be called at spltdb(). */
		/* XXX this is splsoftnet(), currently they are the same. */
@


1.95
log
@Double link between pf states and sockets.  Henning has already
implemented half of it.  The additional part is:
- The pf state lookup for outgoing packets is optimized by using
  mbuf->inp->state.
- For incomming tcp, udp, raw, raw6 packets the socket lookup always
  is optimized by using mbuf->state->inp.
- All protocols establish the link for incomming packets.
- All protocols set the inp in the mbuf for outgoing packets.
  This allows the linkage beginning with the first packet for
  outgoing connections.
- In case of divert states, delete the state when the socket closes.
  Otherwise new connections could match on old states instead of
  being diverted to the listen socket.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.94 2011/04/05 18:01:21 henning Exp $	*/
a100 2
#include "pf.h"

a1078 4

#if NPF > 0
	m->m_pkthdr.pf.inp = tp->t_inpcb;
#endif
@


1.94
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.93 2011/01/07 17:50:42 bluhm Exp $	*/
d101 2
d1081 4
@


1.93
log
@Add socket option SO_SPLICE to splice together two TCP sockets.
The data received on the source socket will automatically be sent
on the drain socket.  This allows to write relay daemons with zero
data copy.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.92 2010/09/24 02:59:45 claudio Exp $	*/
d958 1
a958 1
		m->m_pkthdr.csum_flags |= M_TCPV4_CSUM_OUT;
@


1.92
log
@TCP send and recv buffer scaling.
Send buffer is scaled by not accounting unacknowledged on the wire
data against the buffer limit. Receive buffer scaling is done similar
to FreeBSD -- measure the delay * bandwith product and base the
buffer on that. The problem is that our RTT measurment is coarse
so it overshoots on low delay links. This does not matter that much
since the recvbuffer is almost always empty.
Add a back pressure mechanism to control the amount of memory
assigned to socketbuffers that kicks in when 80% of the cluster
pool is used.
Increases the download speed from 300kB/s to 4.4MB/s on ftp.eu.openbsd.org.

Based on work by markus@@ and djm@@.

OK dlg@@, henning@@, put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.91 2010/09/08 08:34:42 claudio Exp $	*/
d230 6
@


1.91
log
@Return EACCES when pf_test() blocks a packet in ip_output(). This allows
ip_forward() to know the difference between blocked packets and those that
can't be forwarded (EHOSTUNREACH). Only in the latter case an ICMP should
be sent. In the other callers of ip_output() change the error back to
EHOSTUNREACH since userland may not expect EACCES on a sendto().
OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.90 2010/07/09 16:58:06 reyk Exp $	*/
d596 5
d1037 2
@


1.90
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.89 2010/07/03 04:44:51 guenther Exp $	*/
d1141 2
@


1.89
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.88 2010/05/28 08:32:41 kettenis Exp $	*/
d927 2
a928 1
		tdb = gettdbbysrcdst(0, &src, &dst, IPPROTO_TCP);
@


1.88
log
@Make sure the temporary buffer used to generate tcp options is properly
aligned, otherwise we lose on strict alignment architecture.  Should fix
problems with gcc4 compiled bsd.rd's that people see on sparc64.

ok millert@@, beck@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.87 2009/06/05 00:05:22 claudio Exp $	*/
d1064 1
a1064 1
	m->m_pkthdr.rdomain = tp->t_inpcb->inp_rdomain;
@


1.87
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.86 2008/09/03 12:51:39 henning Exp $	*/
d215 2
a216 1
	u_char opt[MAX_TCPOPTLEN];
@


1.86
log
@do not set the pkthdr mbuf state key pointer to the state key saved in the
pcb. the state key ptr in the pcb is the one that had to be used by pf
outbound. but by convention the state key pointer in the pkthdr is the one
used INbound, so pf follows its reverse pointer to find the sk to use,
and since a reverse doesn't exist for locally terminated connections the
reverse pointer is null and thus the whole game a noop.
note that this only affects packets FROM local udp/tcp sockets, for the
other direction everything works as expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.85 2008/07/03 15:46:24 henning Exp $	*/
d1061 3
@


1.85
log
@link pf state keys to tcp pcbs and vice versa.
when we first do a pcb lookup and we have a pointer to a pf state key
in the mbuf header, store the state key pointer in the pcb and a pointer
to the pcb we just found in the state key. when either the state key
or the pcb is removed, clear the pointers.
on subsequent packets inbound we can skip the pcb lookup and just use the
pointer from the state key.
on subsequent packets outbound we can skip the state key lookup and use
the pointer from the pcb.
about 8% speedup with 100 concurrent tcp sessions, should help much more
with more tcp sessions.
ok markus ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.84 2008/06/28 13:26:38 markus Exp $	*/
a763 1
	m->m_pkthdr.pf.statekey = tp->t_inpcb->inp_pf_sk;
@


1.84
log
@no EOL between tcpsig and sack headers; ok jsing, frantzen
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.83 2008/06/12 15:13:47 jsing Exp $	*/
d764 1
@


1.83
log
@Remove some crazy #if mess.

ok markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.82 2008/06/12 15:08:47 jsing Exp $	*/
d618 1
a618 1
		*bp++ = TCPOPT_EOL;
@


1.82
log
@ANSIfy function definitions.

ok markus@@ mcbride@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.80 2007/06/01 00:52:38 henning Exp $	*/
a220 2
#endif
#if defined(TCP_SACK)
a293 1
#if 0
a294 1
#endif
@


1.81
log
@some spelling fixes from Martynas Venckus
@
text
@d208 1
a208 2
tcp_output(tp)
	struct tcpcb *tp;
@


1.80
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.79 2005/06/30 08:51:31 markus Exp $	*/
d1190 1
a1190 1
	 * Start/restart persistance timer.
@


1.79
log
@implement PMTU checks from
        http://www.gont.com.ar/drafts/icmp-attacks-against-tcp.html
i.e. don't act on ICMP-need-frag immediately if adhoc checks on the
advertised mtu fail.  the mtu update is delayed until a tcp retransmit
happens.  initial patch by Fernando Gont, tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.78 2005/05/24 00:02:37 fgont Exp $	*/
d1109 2
a1110 1
			  (so->so_options & SO_DONTROUTE), NULL, NULL);
@


1.78
log
@Ignore ICMP Source Quench messages meant for TCP connections. (Details in
http://www.gont.com.ar/drafts/icmp-attacks-against-tcp.html)
ok markus frantzen
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.77 2005/04/25 17:55:52 brad Exp $	*/
d217 1
a217 1
	unsigned int optlen, hdrlen;
d1076 1
d1099 1
d1152 4
@


1.77
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.76 2005/04/05 20:27:35 markus Exp $	*/
d1121 5
a1125 1
			tcp_quench(tp->t_inpcb, 0);
@


1.76
log
@add tcp sack stats, similar to freebsd; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.75 2005/02/27 13:22:56 markus Exp $	*/
d950 1
a950 1
		m->m_pkthdr.csum |= M_TCPV4_CSUM_OUT;
@


1.75
log
@1. tcp_xmit_timer(): remove extra rtt decrement (t_rtttime is 0-based
   while t_rtt was 1-based), update callers
2. define and use TCP_RTT_BASE_SHIFT instead of the hardcoded 2.
3. add missing shifts when t_srtt/t_rttvar are used.
4. update the comments: t_srtt uses 5 bits of fraction (not 3)
   and t_rttvar uses 4 bits
5. remove obsolete/unused macros TCP_RTT_SCALE and TCP_RTTVAR_SCALE
6. make sure rttmin is not > TCPTV_REXMTMAX
parts from netbsd, ok mcbride, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.74 2004/10/28 19:22:52 mcbride Exp $	*/
d643 1
d821 2
@


1.74
log
@Modulate tcp_now by a random amount on a per-connection basis.

ok markus@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.73 2004/10/06 14:33:07 markus Exp $	*/
d1170 1
a1170 1
	int t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
@


1.73
log
@set the congestion window to two segments (instead of only one), this matches
the window size he have when entering the established state. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.72 2004/09/16 13:14:28 markus Exp $	*/
d597 1
a597 1
		*lp++ = htonl(tcp_now);
@


1.72
log
@don't send partial segments if SS_ISSENDING is set, remember
TF_LASTIDLE across invocations of tcp_output (from freebsd);
ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.71 2004/06/20 18:16:50 itojun Exp $	*/
d251 1
a251 1
		tp->snd_cwnd = tp->t_maxseg;
@


1.71
log
@remove #ifdef TUBA
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.70 2004/06/08 19:47:24 markus Exp $	*/
d244 1
a244 1
	idle = (tp->snd_max == tp->snd_una);
d252 8
d415 1
a415 1
		    len + off >= so->so_snd.sb_cc)
d739 1
a739 1
		if (off + len == so->so_snd.sb_cc)
@


1.70
log
@factor out md5 code; ok+tests henning@@, djm@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.69 2004/06/05 11:56:50 markus Exp $	*/
a95 5
#ifdef TUBA
#include <netiso/iso.h>
#include <netiso/tuba_table.h>
#endif

a1098 6
#ifdef TUBA
	case AF_ISO:
		if (tp->t_tuba_pcb)
			error = tuba_output(m, tp);
		break;
#endif /* TUBA */
@


1.69
log
@set m_pkthdr.len early; ok mcbride, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.68 2004/05/31 20:04:44 brad Exp $	*/
a105 4
#ifdef TCP_SIGNATURE
#include <crypto/md5.h>
#endif /* TCP_SIGNATURE */

d890 1
a890 1
		MD5_CTX ctx;
d901 1
d912 1
d923 1
a923 1
		/* XXX gettdbbysrcdst() should really be called at spltdb().      */
d929 2
a930 58
		MD5Init(&ctx);

		switch (tp->pf) {
		case 0:	/*default to PF_INET*/
#ifdef INET
		case AF_INET:
			{
				struct ippseudo ippseudo;
				struct ipovly *ipovly;

				ipovly = mtod(m, struct ipovly *);

				ippseudo.ippseudo_src = ipovly->ih_src;
				ippseudo.ippseudo_dst = ipovly->ih_dst;
				ippseudo.ippseudo_pad = 0;
				ippseudo.ippseudo_p   = IPPROTO_TCP;
				ippseudo.ippseudo_len = ntohs(ipovly->ih_len) + len +
				    optlen;
				ippseudo.ippseudo_len = htons(ippseudo.ippseudo_len);
				MD5Update(&ctx, (char *)&ippseudo,
				    sizeof(struct ippseudo));
			}
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			{
				struct ip6_hdr_pseudo ip6pseudo;
				struct ip6_hdr *ip6;

				ip6 = mtod(m, struct ip6_hdr *);
				bzero(&ip6pseudo, sizeof(ip6pseudo));
				ip6pseudo.ip6ph_src = ip6->ip6_src;
				ip6pseudo.ip6ph_dst = ip6->ip6_dst;
				in6_clearscope(&ip6pseudo.ip6ph_src);
				in6_clearscope(&ip6pseudo.ip6ph_dst);
				ip6pseudo.ip6ph_nxt = IPPROTO_TCP;
				ip6pseudo.ip6ph_len =
				    htonl(sizeof(struct tcphdr) + len + optlen);
 
				MD5Update(&ctx, (char *)&ip6pseudo,
				    sizeof(ip6pseudo));
			}
			break;
#endif /* INET6 */
		}

		{
			u_int16_t thsum = th->th_sum;

			/* RFC 2385 requires th_sum == 0 */
			th->th_sum = 0;
			MD5Update(&ctx, (char *)th, sizeof(struct tcphdr));
			th->th_sum = thsum;
		}

		if (len && m_apply(m, hdrlen, len, tcp_signature_apply,
		    (caddr_t)&ctx))
a931 3

		MD5Update(&ctx, tdb->tdb_amxkey, tdb->tdb_amxkeylen);
		MD5Final(mtod(m, caddr_t) + hdrlen - optlen + sigoff, &ctx);
@


1.68
log
@work around an LP64 problem where we report an excessively large window
due to incorrect mixing of types.

From NetBSD

ok cedric@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.67 2004/05/07 14:42:27 millert Exp $	*/
d768 1
a1012 1
		m->m_pkthdr.len = hdrlen + len;
a1103 1
	m->m_pkthdr.len = hdrlen + len;
@


1.67
log
@Replace RSA-derived md5 code with code derived from Colin Plumb's PD version.
This moves md5.c out of libkern and into sys/crypto where it belongs (as
requested by markus@@).  Note that md5.c is still mandatory (dev/rnd.c uses it).
Verified with IPsec + hmac-md5 and tcp md5sig. OK henning@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.66 2004/04/26 18:12:25 frantzen Exp $	*/
d871 2
a872 2
	if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
		win = (long)(tp->rcv_adv - tp->rcv_nxt);
@


1.66
log
@- allow the user to force the TCP mss below the fail-safe 216 with a low
interface MTU.
- break a tcp_output() -> tcp_mtudisc() -> tcp_output() infinite recursion
when the TCP mss ends up larger than the interface MTU (when the if_mtu is
smaller than the tcp header).  connections will still stall
feedback from itojun@@, claudio@@ and provos and testing from beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.65 2004/02/16 21:51:03 markus Exp $	*/
d107 1
a107 1
#include <sys/md5k.h>
@


1.65
log
@don't allocate a cluster if the header fits into a mbuf;
ok itojun@@, henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.64 2004/02/10 10:30:24 markus Exp $	*/
d1193 1
a1193 1
			tcp_mtudisc(tp->t_inpcb, 0);
@


1.64
log
@check TF_SIGNATURE when calculating the mss; add TCPOLEN_SIGLEN and
avoid magic constants; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.63 2004/01/31 19:40:10 markus Exp $	*/
d708 1
a708 1
		if (m != NULL) {
d721 1
a721 1
		if (len <= MCLBYTES - hdrlen - max_linkhdr) {
d753 1
a753 1
		if (m != NULL) {
@


1.63
log
@!sack_disable -> sack_enable; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.62 2004/01/22 14:38:28 markus Exp $	*/
a618 1
		optlen += TCPOLEN_SIGNATURE;
d625 2
a626 1
		optlen += 2;
@


1.62
log
@add gettdbbysrcdst(), just like gettdb(), but compares tdb_src as well; ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.61 2004/01/15 17:04:59 markus Exp $	*/
d146 2
a147 1
	if (tp->sack_disable)
d243 1
a243 1
	if (!tp->sack_disable && (tp->t_flags & TF_SIGNATURE))
d268 1
a268 1
	if (!tp->sack_disable && SEQ_LT(tp->snd_nxt, tp->snd_max))
d277 1
a277 1
	if (!tp->sack_disable && (tp->t_dupacks > tcprexmtthresh))
d293 1
a293 1
	if (!tp->sack_disable && !sendalot) {
d356 1
a356 1
	if (!tp->sack_disable && len && SEQ_GT(tp->snd_last, tp->snd_una) &&
d564 1
a564 1
			if (!tp->sack_disable && ((flags & TH_ACK) == 0 ||
d636 1
a636 1
	if (!tp->sack_disable && tp->t_state == TCPS_ESTABLISHED &&
d1038 1
a1038 1
		if (!tp->sack_disable) {
d1068 1
a1068 1
		if (!tp->sack_disable && sack_rxmit &&
@


1.61
log
@es tanzt das KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.60 2004/01/14 13:38:21 markus Exp $	*/
d893 1
a893 1
		union sockaddr_union sa;
d896 2
a897 1
		bzero(&sa, sizeof(union sockaddr_union));
d903 6
a908 3
			sa.sa.sa_len = sizeof(struct sockaddr_in);
			sa.sa.sa_family = AF_INET;
			sa.sin.sin_addr = mtod(m, struct ip *)->ip_dst;
d913 6
a918 3
			sa.sa.sa_len = sizeof(struct sockaddr_in6);
			sa.sa.sa_family = AF_INET6;
			sa.sin6.sin6_addr = mtod(m, struct ip6_hdr *)->ip6_dst;
d923 1
a923 1
		/* XXX gettdb() should really be called at spltdb().      */
d925 1
a925 1
		tdb = gettdb(0, &sa, IPPROTO_TCP);
@


1.60
log
@syncache+ipv6 support for TCP_SIGNATURE; with itojun; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.59 2003/12/10 07:22:43 itojun Exp $	*/
d942 1
a942 1
					sizeof(struct ippseudo));
d979 1
a979 1
				(caddr_t)&ctx))
@


1.59
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.58 2003/07/09 22:03:16 itojun Exp $	*/
d103 1
d938 1
a938 1
				ippseudo.ippseudo_len = ipovly->ih_len + len +
d940 1
a942 3
				MD5Update(&ctx, mtod(m, caddr_t) +
					sizeof(struct ip),
					sizeof(struct tcphdr));
d949 2
a950 1
				static int printed = 0;
d952 12
a963 5
				if (!printed) {
					printf("error: TCP MD5 support for "
						"IPv6 not yet implemented.\n");
					printed = 1;
				}
d967 9
@


1.58
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.57 2003/06/09 07:40:25 itojun Exp $	*/
d216 1
a216 1
	register struct tcpcb *tp;
d218 2
a219 2
	register struct socket *so = tp->t_inpcb->inp_socket;
	register long len, win, txmaxseg;
d221 2
a222 2
	register struct mbuf *m;
	register struct tcphdr *th;
@


1.57
log
@backout following:
>use m_pulldown not m_pullup2.  fix some bugs in IPv6 tcp_trace().

PR 3283 fixed (confirmed)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.56 2003/06/02 23:28:14 millert Exp $	*/
d1107 1
a1107 1
			ip->ip_len = m->m_pkthdr.len;
@


1.56
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.55 2003/05/29 00:35:18 itojun Exp $	*/
d1070 3
a1072 14
	if (so->so_options & SO_DEBUG) {
		/* TCP template does not fill ip version, so fill it in here */
		struct ip *sip;
		sip = mtod(m, struct ip *);
		switch (tp->pf) {
		case AF_INET:
			sip->ip_v = 4;
			break;
		case AF_INET6:
			sip->ip_v = 6;
			break;
		}
		tcp_trace(TA_OUTPUT, tp->t_state, tp, m, 0, len);
	}
@


1.55
log
@use m_pulldown not m_pullup2.  fix some bugs in IPv6 tcp_trace().
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.54 2003/01/25 15:27:29 markus Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.54
log
@don't send more than half of the send buffer space limit in
one tcp segment, improves performance of tcp over interfaces
with large mtu (e.g. lo0); based on similar change in netbsd;
ok djm, henning, henric, millert, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.53 2002/08/28 15:43:03 pefo Exp $	*/
d1074 14
a1087 3
	if (so->so_options & SO_DEBUG)
		tcp_trace(TA_OUTPUT, tp->t_state, tp, mtod(m, caddr_t), 0,
			len);
@


1.53
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.52 2002/06/09 16:26:11 itojun Exp $	*/
d223 1
a223 1
	register long len, win;
d386 11
a396 2
	if (len > tp->t_maxseg) {
		len = tp->t_maxseg;
d415 1
a415 1
		if (len == tp->t_maxseg)
@


1.52
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.51 2002/06/07 16:18:02 itojun Exp $	*/
d1114 1
a1114 1
			0, tp->t_inpcb);
@


1.51
log
@avoid is_ipv6 construct.  a step towards IPv4-less kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.50 2002/05/16 14:10:51 kjc Exp $	*/
d37 1
a37 1
 * 
d41 1
a41 1
 * 
d56 1
a56 1
 * 
d68 1
a68 1
 * 
d193 2
a194 2
	/* 
	 * Two cases for which we want to advance snd_nxt:  
d201 1
a201 1
		if (SEQ_GEQ(tp->snd_nxt, cur->next->start)) 
d288 1
a288 1
	/* 
d292 1
a292 1
	 * we're replacing a (future) new transmission with a retransmission 
d353 2
a354 2
	/* 
	 * If we're in fast recovery (SEQ_GT(tp->snd_last, tp->snd_una)), and 
d358 2
a359 2
	if (!tp->sack_disable && len && SEQ_GT(tp->snd_last, tp->snd_una) && 
	    (tp->snd_awnd >= tp->snd_cwnd)) 
d431 1
a431 1
		/* 
d464 1
a464 1
	 * In SACK, it is possible for tcp_output to fail to send a segment 
d551 4
a554 4
			/* 
			 * If this is the first SYN of connection (not a SYN 
			 * ACK), include SACK_PERMIT_HDR option.  If this is a 
			 * SYN ACK, include SACK_PERMIT_HDR option if peer has 
d564 1
a564 1
	 
d577 1
a577 1
 
d579 1
a579 1
	 * Send a timestamp and echo-reply if this is a SYN and our side 
d588 1
a588 1
 
d614 1
a614 1
		/* Pad options list to the next 32 bit boundary and 
d657 1
a657 1
 
d778 1
a778 1
	if ((flags & TH_FIN) && (tp->t_flags & TF_SENTFIN) && 
d801 4
a804 4
		/* 
		 * If sendalot was turned on (due to option stuffing), turn it 
		 * off. Properly set th_seq field.  Advance the ret'x pointer 
		 * by len.  
d984 1
a984 1
  		th->th_sum = in6_cksum(m, IPPROTO_TCP, sizeof(struct ip6_hdr),
d1121 1
a1121 1
			
d1148 1
a1148 1
		tp->retran_data;                
@


1.50
log
@bring in ECN support from KAME.
it consists of
 - ECN support in TCP
 - tunnel-egress and fragment reassembly rules in layer-3 not to lose
   congestion info at tunnel-egress and fragment reassembly

to enable ECN in TCP, build a kernel with TCP_ECN, and then,
turn it on by "sysctl -w net.inet.tcp.ecn=1".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.49 2002/03/08 03:49:58 provos Exp $	*/
d1120 1
a1120 1
			struct ip6_hdr *ipv6;
d1122 2
a1123 2
			ipv6 = mtod(m, struct ip6_hdr *);
			ipv6->ip6_plen = m->m_pkthdr.len -
d1125 2
a1126 2
			ipv6->ip6_nxt = IPPROTO_TCP;
			ipv6->ip6_hlim = in6_selecthlim(tp->t_inpcb, NULL);
d1129 1
a1129 1
				ipv6->ip6_flow |= htonl(IPTOS_ECN_ECT0 << 20);
@


1.49
log
@use timeout(9) to schedule TCP timers.  this avoid traversing all
tcp connections during tcp_slowtimo.  apdapted from thorpej@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.48 2002/03/01 22:29:29 provos Exp $	*/
d240 3
d821 33
d1077 17
d1105 4
d1127 4
@


1.48
log
@remove tcp_fasttimo and convert delayed acks to the timeout(9) API instead.
adapated from netbsd.  okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.47 2002/02/05 17:03:11 provos Exp $	*/
d81 1
d253 1
a253 1
	if (idle && tp->t_idle >= tp->t_rxtcur)
d986 2
a987 2
			if (tp->t_rtt == 0) {
				tp->t_rtt = 1;
@


1.47
log
@when retransmitting a segment after FIN has been sent don't set FIN
unless we are transmitting the last of our data. report from
jishac@@grc.nasa.gov; pr/2368
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.46 2002/01/14 19:58:18 provos Exp $	*/
d1110 5
d1118 2
d1130 2
a1131 1
	tp->t_flags &= ~(TF_ACKNOW|TF_DELACK);
@


1.46
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.45 2002/01/14 03:11:55 provos Exp $	*/
d386 1
a386 1
	if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
@


1.45
log
@use macros to manage tcp timers; based on netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.44 2001/11/24 19:29:07 deraadt Exp $	*/
d122 2
d125 1
a125 2
tcp_print_holes(tp)
struct tcpcb *tp;
d132 2
a133 2
		printf("%x--%x d %d r %x\n",  p->start, p->end, p->dups,
                    p->rxmit);
d145 1
a145 2
tcp_sack_output(tp)
register struct tcpcb *tp;
d149 1
a149 1
		return 0;
d171 1
a171 1
			return p;
d175 1
a175 1
	return 0;
d183 1
d185 1
a185 2
tcp_sack_adjust(tp)
	struct tcpcb *tp;
d188 1
a188 1
	if (cur == 0)
@


1.44
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.43 2001/06/25 01:59:29 angelos Exp $	*/
d338 1
a338 1
			tp->t_timer[TCPT_PERSIST] = 0;
d375 1
a375 1
			tp->t_timer[TCPT_REXMT] = 0;
d378 1
a378 1
			if (tp->t_timer[TCPT_PERSIST] == 0)
d465 3
a467 3
	    tp->t_timer[TCPT_REXMT] == 0 &&
	    tp->t_timer[TCPT_PERSIST] == 0) {
		tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
d494 2
a495 2
	if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
	    tp->t_timer[TCPT_PERSIST] == 0) {
d790 1
a790 1
	if (len || (flags & (TH_SYN|TH_FIN)) || tp->t_timer[TCPT_PERSIST])
d957 1
a957 1
	if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) {
d1003 1
a1003 1
		    tp->t_timer[TCPT_REXMT] == 0 &&
d1005 3
a1007 3
			tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
			if (tp->t_timer[TCPT_PERSIST]) {
				tp->t_timer[TCPT_PERSIST] = 0;
d1013 1
a1013 1
		if (tp->t_timer[TCPT_REXMT] == 0 &&
d1015 3
a1017 3
			tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
			if (tp->t_timer[TCPT_PERSIST]) {
				tp->t_timer[TCPT_PERSIST] = 0;
d1134 1
a1134 2
tcp_setpersist(tp)
	register struct tcpcb *tp;
d1136 2
a1137 1
	register int t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
d1139 1
a1139 1
	if (tp->t_timer[TCPT_REXMT])
d1146 1
a1146 2
	TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
	    t * tcp_backoff[tp->t_rxtshift],
d1148 1
@


1.44.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.46 2002/01/14 19:58:18 provos Exp $	*/
a121 2
void tcp_print_holes(struct tcpcb *tp);

d123 2
a124 1
tcp_print_holes(struct tcpcb *tp)
d131 2
a132 2
		printf("%x--%x d %d r %x\n", p->start, p->end, p->dups,
		    p->rxmit);
d144 2
a145 1
tcp_sack_output(struct tcpcb *tp)
d149 1
a149 1
		return (NULL);
d171 1
a171 1
			return (p);
d175 1
a175 1
	return (NULL);
a182 1

d184 2
a185 1
tcp_sack_adjust(struct tcpcb *tp)
d188 1
a188 1
	if (cur == NULL)
d338 1
a338 1
			TCP_TIMER_DISARM(tp, TCPT_PERSIST);
d375 1
a375 1
			TCP_TIMER_DISARM(tp, TCPT_REXMT);
d378 1
a378 1
			if (TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0)
d465 3
a467 3
	    TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
	    TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
		TCP_TIMER_ARM(tp, TCPT_REXMT, tp->t_rxtcur);
d494 2
a495 2
	if (so->so_snd.sb_cc && TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
	    TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
d790 1
a790 1
	if (len || (flags & (TH_SYN|TH_FIN)) || TCP_TIMER_ISARMED(tp, TCPT_PERSIST))
d957 1
a957 1
	if (tp->t_force == 0 || TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
d1003 1
a1003 1
		    TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
d1005 3
a1007 3
			TCP_TIMER_ARM(tp, TCPT_REXMT, tp->t_rxtcur);
			if (TCP_TIMER_ISARMED(tp, TCPT_PERSIST)) {
				TCP_TIMER_DISARM(tp, TCPT_PERSIST);
d1013 1
a1013 1
		if (TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
d1015 3
a1017 3
			TCP_TIMER_ARM(tp, TCPT_REXMT, tp->t_rxtcur);
			if (TCP_TIMER_ISARMED(tp, TCPT_PERSIST)) {
				TCP_TIMER_DISARM(tp, TCPT_PERSIST);
d1134 2
a1135 1
tcp_setpersist(struct tcpcb *tp)
d1137 1
a1137 2
	int t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
	int nticks;
d1139 1
a1139 1
	if (TCP_TIMER_ISARMED(tp, TCPT_REXMT))
d1146 2
a1147 1
	TCPT_RANGESET(nticks, t * tcp_backoff[tp->t_rxtshift],
a1148 1
	TCP_TIMER_ARM(tp, TCPT_PERSIST, nticks);
@


1.44.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.44.2.1 2002/01/31 22:55:45 niklas Exp $	*/
a80 1
#include <sys/kernel.h>
a238 3
#ifdef TCP_ECN
	int needect;
#endif
d252 1
a252 1
	if (idle && (tcp_now - tp->t_rcvtime) >= tp->t_rxtcur)
d386 1
a386 1
	if (off + len < so->so_snd.sb_cc)
a816 33
#ifdef TCP_ECN
	if (tcp_do_ecn) {
		/*
		 * if we have received congestion experienced segs,
		 * set ECE bit.
		 */
		if (tp->t_flags & TF_RCVD_CE) {
			flags |= TH_ECE;
			tcpstat.tcps_ecn_sndece++;
		}
		if (!(tp->t_flags & TF_DISABLE_ECN)) {
			/*
			 * if this is a SYN seg, set ECE and CWR.
			 * set only ECE for SYN-ACK if peer supports ECN.
			 */
			if ((flags & (TH_SYN|TH_ACK)) == TH_SYN)
				flags |= (TH_ECE|TH_CWR);
			else if ((tp->t_flags & TF_ECN_PERMIT) &&
				 (flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK))
				flags |= TH_ECE;
		}
		/*
		 * if we have reduced the congestion window, notify
		 * the peer by setting CWR bit.
		 */
		if ((tp->t_flags & TF_ECN_PERMIT) &&
		    (tp->t_flags & TF_SEND_CWR)) {
			flags |= TH_CWR;
			tp->t_flags &= ~TF_SEND_CWR;
			tcpstat.tcps_ecn_sndcwr++;
		}
	}
#endif
d985 2
a986 2
			if (tp->t_rtttime == 0) {
				tp->t_rtttime = tcp_now;
a1039 17
#ifdef TCP_ECN
	/*
	 * if peer is ECN capable, set the ECT bit in the IP header.
	 * but don't set ECT for a pure ack, a retransmit or a window probe.
	 */
	needect = 0;
	if (tcp_do_ecn && (tp->t_flags & TF_ECN_PERMIT)) {
		if (len == 0 || SEQ_LT(tp->snd_nxt, tp->snd_max) ||
		    (tp->t_force && len == 1)) {
			/* don't set ECT */
		} else {
			needect = 1;
			tcpstat.tcps_ecn_sndect++;
		}
	}
#endif

a1050 4
#ifdef TCP_ECN
			if (needect)
				ip->ip_tos |= IPTOS_ECN_ECT0;
#endif
d1062 1
a1062 1
			struct ip6_hdr *ip6;
d1064 2
a1065 2
			ip6 = mtod(m, struct ip6_hdr *);
			ip6->ip6_plen = m->m_pkthdr.len -
d1067 2
a1068 6
			ip6->ip6_nxt = IPPROTO_TCP;
			ip6->ip6_hlim = in6_selecthlim(tp->t_inpcb, NULL);
#ifdef TCP_ECN
			if (needect)
				ip6->ip6_flow |= htonl(IPTOS_ECN_ECT0 << 20);
#endif
a1109 5

		/* Restart the delayed ACK timer, if necessary. */
		if (tp->t_flags & TF_DELACK)
			TCP_RESTART_DELACK(tp);

a1112 2
	if (tp->t_flags & TF_DELACK)
		tcpstat.tcps_delack++;
d1123 1
a1123 2
	tp->t_flags &= ~TF_ACKNOW;
	TCP_CLEAR_DELACK(tp);
@


1.44.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.44.2.2 2002/06/11 03:31:37 art Exp $	*/
d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
d193 2
a194 2
	/*
	 * Two cases for which we want to advance snd_nxt:
d201 1
a201 1
		if (SEQ_GEQ(tp->snd_nxt, cur->next->start))
d288 1
a288 1
	/*
d292 1
a292 1
	 * we're replacing a (future) new transmission with a retransmission
d353 2
a354 2
	/*
	 * If we're in fast recovery (SEQ_GT(tp->snd_last, tp->snd_una)), and
d358 2
a359 2
	if (!tp->sack_disable && len && SEQ_GT(tp->snd_last, tp->snd_una) &&
	    (tp->snd_awnd >= tp->snd_cwnd))
d431 1
a431 1
		/*
d464 1
a464 1
	 * In SACK, it is possible for tcp_output to fail to send a segment
d551 4
a554 4
			/*
			 * If this is the first SYN of connection (not a SYN
			 * ACK), include SACK_PERMIT_HDR option.  If this is a
			 * SYN ACK, include SACK_PERMIT_HDR option if peer has
d564 1
a564 1

d577 1
a577 1

d579 1
a579 1
	 * Send a timestamp and echo-reply if this is a SYN and our side
d588 1
a588 1

d614 1
a614 1
		/* Pad options list to the next 32 bit boundary and
d657 1
a657 1

d778 1
a778 1
	if ((flags & TH_FIN) && (tp->t_flags & TF_SENTFIN) &&
d801 4
a804 4
		/*
		 * If sendalot was turned on (due to option stuffing), turn it
		 * off. Properly set th_seq field.  Advance the ret'x pointer
		 * by len.
d984 1
a984 1
		th->th_sum = in6_cksum(m, IPPROTO_TCP, sizeof(struct ip6_hdr),
d1114 1
a1114 1
			(void *)NULL, tp->t_inpcb);
d1121 1
a1121 1

d1148 1
a1148 1
		tp->retran_data;
@


1.44.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d223 1
a223 1
	register long len, win, txmaxseg;
d386 2
a387 11

        /*
         * Never send more than half a buffer full.  This insures that we can
         * always keep 2 packets on the wire, no matter what SO_SNDBUF is, and
         * therefore acks will never be delayed unless we run out of data to
         * transmit.
         */
	txmaxseg = ulmin(so->so_snd.sb_hiwat / 2, tp->t_maxseg);

	if (len > txmaxseg) {
		len = txmaxseg;
d406 1
a406 1
		if (len == txmaxseg)
@


1.43
log
@Always defer output TCP checksumming until ip_output() (or hardware,
if it exists). Cuts down on code a bit, and we don't need to look at
the routing entry at TCP. Based on NetBSD. UDP case to follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.42 2001/06/25 00:11:58 angelos Exp $	*/
d1105 2
a1106 2
		if ((error == EHOSTUNREACH || error == ENETDOWN)
		    && TCPS_HAVERCVDSYN(tp->t_state)) {
@


1.42
log
@Use in_cksum_phdr() rather than in_cksum() -- from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.41 2001/06/23 07:14:32 angelos Exp $	*/
a228 2
	struct route *ro;
	struct ifnet *ifp;
a846 16
	/* Put TCP length in pseudo-header */
	switch (tp->pf) {
	case 0:	/*default to PF_INET*/
#ifdef INET
	case AF_INET:
		if (len + optlen)
			mtod(m, struct ipovly *)->ih_len = htons((u_int16_t)(
				sizeof (struct tcphdr) + optlen + len));
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		break;
#endif /* INET6 */
	}

d895 2
a896 1
				ippseudo.ippseudo_len = ipovly->ih_len;
d937 5
a941 23
		/*
		 * If we know our route, and the interface supports TCPv4
		 * checksumming, only compute the pseudoheader.
		 */
		ro = &tp->t_inpcb->inp_route;
		if (ro->ro_rt && (ro->ro_rt->rt_flags & RTF_UP)) {
			ifp = ro->ro_rt->rt_ifp;
			if ((ifp->if_capabilities & IFCAP_CSUM_TCPv4) &&
			    ifp->if_bridge == NULL) {
				struct ipovly *ipov;

				ipov = mtod(m, struct ipovly *);
				m->m_pkthdr.csum |= M_TCPV4_CSUM_OUT;
				tcpstat.tcps_outhwcsum++;
				th->th_sum = in_cksum_phdr(ipov->ih_src.s_addr,
				    ipov->ih_dst.s_addr,
				    htons(sizeof(struct tcphdr) + len +
					optlen + IPPROTO_TCP));
				break;
			}
		}

		th->th_sum = in_cksum(m, (int)(hdrlen + len));
@


1.41
log
@Likewise, only use outgoing TCP/UDP hardware checksumming if the
interface is not in bridge mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.40 2001/06/23 06:03:12 angelos Exp $	*/
d963 3
d968 4
a971 1
				th->th_sum = in_cksum(m, (int)hdrlen);
@


1.40
log
@Keep stats on TCP/UDP hardware checksumming.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.39 2001/06/23 05:36:08 angelos Exp $	*/
d961 2
a962 1
			if (ifp->if_capabilities & IFCAP_CSUM_TCPv4) {
@


1.39
log
@TCP/UDP hardware checksumming. Untested, since txp dies when it tries
to compute the checksums. Still, it shouldn't affect anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.38 2001/06/23 03:10:21 provos Exp $	*/
d963 1
@


1.38
log
@fix up mtu for routes and ongoing tcp connection when if mtu changes
from FreeBSD; fixes pr/1878
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.37 2001/06/08 03:53:46 angelos Exp $	*/
d83 1
d229 2
d954 14
@


1.37
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.36 2001/06/05 02:31:36 deraadt Exp $	*/
d1103 10
@


1.36
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.35 2001/05/31 16:27:08 provos Exp $	*/
a76 1
#include <sys/malloc.h>
a80 2
#include <sys/errno.h>
#include <sys/domain.h>
@


1.35
log
@Two fixes from Stevens via davidg@@freebsd, bug report by
armin@@wolfermann.org

- set the persist timer so that connections in CLOSING state timeout
- honor keep-alive timer in CLOSING state.

Fixes the problem in simulaneous close situation where connections
would never leave the CLOSING state and stay arround indefinitly.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.34 2000/09/25 09:41:03 provos Exp $	*/
d36 37
a72 1
 *	@@(#)tcp_output.c	8.3 (Berkeley) 12/30/93
a73 12

/*
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.34
log
@on expiry of pmtu route, retry higher mtu. okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.33 2000/09/20 17:00:22 provos Exp $	*/
d346 4
a349 4
		 * cancel pending retransmit and pull snd_nxt
		 * back to (closed) window.  We will enter persist
		 * state below.  If the window didn't close completely,
		 * just wait for an ACK.
d354 1
d356 2
@


1.34.4.1
log
@Pull in patch from current:
Fix (provos):
Two fixes from Stevens via davidg@@freebsd, bug report by
armin@@wolfermann.org

- set the persist timer so that connections in CLOSING state timeout
- honor keep-alive timer in CLOSING state.

Fixes the problem in simulaneous close situation where connections
would never leave the CLOSING state and stay arround indefinitly.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.35 2001/05/31 16:27:08 provos Exp $	*/
d346 4
a349 4
		 * cancel pending retransmit, pull snd_nxt back
		 * to (closed) window, and set the persist timer
		 * if it isn't already going.  If the window didn't
		 * close completely, just wait for an ACK.
a353 1
			tp->t_rxtshift = 0;
a354 2
			if (tp->t_timer[TCPT_PERSIST] == 0)
				tcp_setpersist(tp);
@


1.33
log
@correctly calculate mss
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.32 2000/09/18 22:06:38 provos Exp $	*/
d515 1
a515 2
			mss = htons((u_int16_t) tcp_mss(tp, flags & TH_ACK ? 
							tp->t_maxopd : 0));
@


1.32
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.31 2000/09/05 21:57:41 provos Exp $	*/
d515 2
a516 1
			mss = htons((u_int16_t) tcp_mss(tp, 0));
d519 3
@


1.31
log
@various fixes to SACK and FACK from adesai@@cisco.com, tomh@@tomh.org and
osuga@@mml.yrp.nttdocomo.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.30 2000/02/21 21:42:13 provos Exp $	*/
d1036 3
a1038 1
			&tp->t_inpcb->inp_route, so->so_options & SO_DONTROUTE,
@


1.30
log
@TCP SACK fixes via Tom Henderson (tomh@@cs.berkeley.edu):
- tcp_sack_adjust() was completely rewritten, since it was erroneously
referencing receiver side sequence numbers and comparing with sender
side sequence numbers (thanks to Arun Desai (adesai@@cisco.com) who
discovered the problem)
- in tcp_output(), moved assignment of sendalot=0 to the piece of code
immediately following the search for sack-eligible retransmissions
(bug identified by Arun Desai).
- tcp_input() was not clearing t_dupacks if fewer than three dupacks arrived
between acks of new data. (bug identified by Gaurav Banga (gaurav@@netapp.com))
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.29 2000/01/07 00:57:54 itojun Exp $	*/
d130 1
d132 9
d248 9
d270 2
a271 1
		if ((p = tcp_sack_output(tp))) {
@


1.29
log
@s/memset/bzero/
From: Michael Shalayeff <mickey@@lucifier.dial-up.user.akula.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.28 1999/12/21 17:49:28 provos Exp $	*/
d155 19
a173 12
	int i;

	for (i = 0; i < tp->rcv_numsacks; i++) {
		if (SEQ_LT(tp->snd_nxt, tp->sackblks[i].start))
			break;
		if (SEQ_LEQ(tp->sackblks[i].end, tp->snd_nxt))
			continue;
		if (tp->sackblks[i].start == 0 && tp->sackblks[i].end == 0)
			continue;
		/* snd_nxt must be in middle of block of SACKed data */
		tp->snd_nxt = tp->sackblks[i].end;
		break;
d175 4
d196 1
a196 1
	int idle, sendalot;
a227 1
	sendalot = 0;
a240 6
	/*
	 * If in persist timeout with window of 0, send 1 byte.
	 * Otherwise, if window is small but nonzero
	 * and timer expired, we will send what we can
	 * and go to transmit state.
	 */
d267 7
@


1.29.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d155 12
a166 19
	struct sackhole *cur = tp->snd_holes;
	if (cur == 0)
		return; /* No holes */
	if (SEQ_GEQ(tp->snd_nxt, tp->rcv_lastsack))
		return; /* We're already beyond any SACKed blocks */
	/* 
	 * Two cases for which we want to advance snd_nxt:  
	 * i) snd_nxt lies between end of one hole and beginning of another
	 * ii) snd_nxt lies between end of last hole and rcv_lastsack
	 */
	while (cur->next) {
		if (SEQ_LT(tp->snd_nxt, cur->end))
			return;
		if (SEQ_GEQ(tp->snd_nxt, cur->next->start)) 
			cur = cur->next;
		else {
			tp->snd_nxt = cur->next->start;
			return;
		}
a167 4
	if (SEQ_LT(tp->snd_nxt, cur->end))
		return;
	tp->snd_nxt = tp->rcv_lastsack;
	return;
d185 1
a185 1
	int idle, sendalot = 0;
d217 1
d231 6
a262 7
	sendalot = 0;
	/*
	 * If in persist timeout with window of 0, send 1 byte.
	 * Otherwise, if window is small but nonzero
	 * and timer expired, we will send what we can
	 * and go to transmit state.
	 */
@


1.29.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.34 2000/09/25 09:41:03 provos Exp $	*/
a129 1
#ifndef TCP_FACK
a130 9
#else
		/* In FACK, if p->dups is less than tcprexmtthresh, but
		 * snd_fack advances more than tcprextmtthresh * tp->t_maxseg,
		 * tcp_input() will try fast retransmit. This forces output.
		 */
		if ((p->dups >= tcprexmtthresh ||
		     tp->t_dupacks == tcprexmtthresh) &&
		    SEQ_LT(p->rxmit, p->end)) {
#endif /* TCP_FACK */
a237 9
#if defined(TCP_SACK) && defined(TCP_FACK)
	/* Normally, sendable data is limited by off < tp->snd_cwnd.
	 * But in FACK, sendable data is limited by snd_awnd < snd_cwnd,
	 * regardless of offset.
	 */
	if (!tp->sack_disable && (tp->t_dupacks > tcprexmtthresh))
		win = tp->snd_wnd;
	else
#endif
d251 1
a251 2
		if (tp->t_dupacks >= tcprexmtthresh &&
		    (p = tcp_sack_output(tp))) {
a497 3

			if (flags & TH_ACK)
				tcp_mss_update(tp);
d1016 1
a1016 3
			&tp->t_inpcb->inp_route,
			(ip_mtudisc ? IP_MTUDISC : 0) |
				  (so->so_options & SO_DONTROUTE),
@


1.29.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.29.2.2 2001/05/14 22:40:15 niklas Exp $	*/
d36 1
a36 37
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
d39 12
d53 1
d58 2
a61 1
#include <net/if.h>
d346 4
a349 4
		 * cancel pending retransmit, pull snd_nxt back
		 * to (closed) window, and set the persist timer
		 * if it isn't already going.  If the window didn't
		 * close completely, just wait for an ACK.
a353 1
			tp->t_rxtshift = 0;
a354 2
			if (tp->t_timer[TCPT_PERSIST] == 0)
				tcp_setpersist(tp);
d822 16
d886 1
a886 2
				ippseudo.ippseudo_len = ipovly->ih_len + len +
				    optlen;
d927 1
a927 5
		/* Defer checksumming until later (ip_output() or hardware) */
		m->m_pkthdr.csum |= M_TCPV4_CSUM_OUT;
		if (len + optlen)
			th->th_sum = in_cksum_addword(th->th_sum,
			    htons((u_int16_t)(len + optlen)));
a1078 10
			return (0);
		}
		if (error == EMSGSIZE) {
			/*
			 * ip_output() will have already fixed the route
			 * for us.  tcp_mtudisc() will, as its last action,
			 * initiate retransmission, so it is important to
			 * not do so here.
			 */
			tcp_mtudisc(tp->t_inpcb, 0);
@


1.29.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1105 2
a1106 2
		if ((error == EHOSTUNREACH || error == ENETDOWN) &&
		    TCPS_HAVERCVDSYN(tp->t_state)) {
@


1.29.2.5
log
@Merge in trunk
@
text
@a121 2
void tcp_print_holes(struct tcpcb *tp);

d123 2
a124 1
tcp_print_holes(struct tcpcb *tp)
d131 2
a132 2
		printf("%x--%x d %d r %x\n", p->start, p->end, p->dups,
		    p->rxmit);
d144 2
a145 1
tcp_sack_output(struct tcpcb *tp)
d149 1
a149 1
		return (NULL);
d171 1
a171 1
			return (p);
d175 1
a175 1
	return (NULL);
a182 1

d184 2
a185 1
tcp_sack_adjust(struct tcpcb *tp)
d188 1
a188 1
	if (cur == NULL)
d338 1
a338 1
			TCP_TIMER_DISARM(tp, TCPT_PERSIST);
d375 1
a375 1
			TCP_TIMER_DISARM(tp, TCPT_REXMT);
d378 1
a378 1
			if (TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0)
d386 1
a386 1
	if (off + len < so->so_snd.sb_cc)
d465 3
a467 3
	    TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
	    TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
		TCP_TIMER_ARM(tp, TCPT_REXMT, tp->t_rxtcur);
d494 2
a495 2
	if (so->so_snd.sb_cc && TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
	    TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
d790 1
a790 1
	if (len || (flags & (TH_SYN|TH_FIN)) || TCP_TIMER_ISARMED(tp, TCPT_PERSIST))
d957 1
a957 1
	if (tp->t_force == 0 || TCP_TIMER_ISARMED(tp, TCPT_PERSIST) == 0) {
d1003 1
a1003 1
		    TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
d1005 3
a1007 3
			TCP_TIMER_ARM(tp, TCPT_REXMT, tp->t_rxtcur);
			if (TCP_TIMER_ISARMED(tp, TCPT_PERSIST)) {
				TCP_TIMER_DISARM(tp, TCPT_PERSIST);
d1013 1
a1013 1
		if (TCP_TIMER_ISARMED(tp, TCPT_REXMT) == 0 &&
d1015 3
a1017 3
			TCP_TIMER_ARM(tp, TCPT_REXMT, tp->t_rxtcur);
			if (TCP_TIMER_ISARMED(tp, TCPT_PERSIST)) {
				TCP_TIMER_DISARM(tp, TCPT_PERSIST);
a1109 5

		/* Restart the delayed ACK timer, if necessary. */
		if (tp->t_flags & TF_DELACK)
			TCP_RESTART_DELACK(tp);

a1112 2
	if (tp->t_flags & TF_DELACK)
		tcpstat.tcps_delack++;
d1123 1
a1123 2
	tp->t_flags &= ~TF_ACKNOW;
	TCP_CLEAR_DELACK(tp);
d1134 2
a1135 1
tcp_setpersist(struct tcpcb *tp)
d1137 1
a1137 2
	int t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
	int nticks;
d1139 1
a1139 1
	if (TCP_TIMER_ISARMED(tp, TCPT_REXMT))
d1146 2
a1147 1
	TCPT_RANGESET(nticks, t * tcp_backoff[tp->t_rxtshift],
a1148 1
	TCP_TIMER_ARM(tp, TCPT_PERSIST, nticks);
@


1.29.2.6
log
@Merge in -current from roughly a week ago
@
text
@a80 1
#include <sys/kernel.h>
d252 1
a252 1
	if (idle && (tcp_now - tp->t_rcvtime) >= tp->t_rxtcur)
d985 2
a986 2
			if (tp->t_rtttime == 0) {
				tp->t_rtttime = tcp_now;
@


1.29.2.7
log
@Sync the SMP branch with 3.3
@
text
@d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
d193 2
a194 2
	/*
	 * Two cases for which we want to advance snd_nxt:
d201 1
a201 1
		if (SEQ_GEQ(tp->snd_nxt, cur->next->start))
d223 1
a223 1
	register long len, win, txmaxseg;
a239 3
#ifdef TCP_ECN
	int needect;
#endif
d285 1
a285 1
	/*
d289 1
a289 1
	 * we're replacing a (future) new transmission with a retransmission
d350 2
a351 2
	/*
	 * If we're in fast recovery (SEQ_GT(tp->snd_last, tp->snd_una)), and
d355 2
a356 2
	if (!tp->sack_disable && len && SEQ_GT(tp->snd_last, tp->snd_una) &&
	    (tp->snd_awnd >= tp->snd_cwnd))
d383 2
a384 11

        /*
         * Never send more than half a buffer full.  This insures that we can
         * always keep 2 packets on the wire, no matter what SO_SNDBUF is, and
         * therefore acks will never be delayed unless we run out of data to
         * transmit.
         */
	txmaxseg = ulmin(so->so_snd.sb_hiwat / 2, tp->t_maxseg);

	if (len > txmaxseg) {
		len = txmaxseg;
d403 1
a403 1
		if (len == txmaxseg)
d428 1
a428 1
		/*
d461 1
a461 1
	 * In SACK, it is possible for tcp_output to fail to send a segment
d548 4
a551 4
			/*
			 * If this is the first SYN of connection (not a SYN
			 * ACK), include SACK_PERMIT_HDR option.  If this is a
			 * SYN ACK, include SACK_PERMIT_HDR option if peer has
d561 1
a561 1

d574 1
a574 1

d576 1
a576 1
	 * Send a timestamp and echo-reply if this is a SYN and our side
d585 1
a585 1

d611 1
a611 1
		/* Pad options list to the next 32 bit boundary and
d654 1
a654 1

d775 1
a775 1
	if ((flags & TH_FIN) && (tp->t_flags & TF_SENTFIN) &&
d798 4
a801 4
		/*
		 * If sendalot was turned on (due to option stuffing), turn it
		 * off. Properly set th_seq field.  Advance the ret'x pointer
		 * by len.
a817 33
#ifdef TCP_ECN
	if (tcp_do_ecn) {
		/*
		 * if we have received congestion experienced segs,
		 * set ECE bit.
		 */
		if (tp->t_flags & TF_RCVD_CE) {
			flags |= TH_ECE;
			tcpstat.tcps_ecn_sndece++;
		}
		if (!(tp->t_flags & TF_DISABLE_ECN)) {
			/*
			 * if this is a SYN seg, set ECE and CWR.
			 * set only ECE for SYN-ACK if peer supports ECN.
			 */
			if ((flags & (TH_SYN|TH_ACK)) == TH_SYN)
				flags |= (TH_ECE|TH_CWR);
			else if ((tp->t_flags & TF_ECN_PERMIT) &&
				 (flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK))
				flags |= TH_ECE;
		}
		/*
		 * if we have reduced the congestion window, notify
		 * the peer by setting CWR bit.
		 */
		if ((tp->t_flags & TF_ECN_PERMIT) &&
		    (tp->t_flags & TF_SEND_CWR)) {
			flags |= TH_CWR;
			tp->t_flags &= ~TF_SEND_CWR;
			tcpstat.tcps_ecn_sndcwr++;
		}
	}
#endif
d948 1
a948 1
		th->th_sum = in6_cksum(m, IPPROTO_TCP, sizeof(struct ip6_hdr),
a1040 17
#ifdef TCP_ECN
	/*
	 * if peer is ECN capable, set the ECT bit in the IP header.
	 * but don't set ECT for a pure ack, a retransmit or a window probe.
	 */
	needect = 0;
	if (tcp_do_ecn && (tp->t_flags & TF_ECN_PERMIT)) {
		if (len == 0 || SEQ_LT(tp->snd_nxt, tp->snd_max) ||
		    (tp->t_force && len == 1)) {
			/* don't set ECT */
		} else {
			needect = 1;
			tcpstat.tcps_ecn_sndect++;
		}
	}
#endif

a1051 4
#ifdef TCP_ECN
			if (needect)
				ip->ip_tos |= IPTOS_ECN_ECT0;
#endif
d1057 1
a1057 1
			(void *)NULL, tp->t_inpcb);
d1063 4
a1066 4
			struct ip6_hdr *ip6;

			ip6 = mtod(m, struct ip6_hdr *);
			ip6->ip6_plen = m->m_pkthdr.len -
d1068 2
a1069 6
			ip6->ip6_nxt = IPPROTO_TCP;
			ip6->ip6_hlim = in6_selecthlim(tp->t_inpcb, NULL);
#ifdef TCP_ECN
			if (needect)
				ip6->ip6_flow |= htonl(IPTOS_ECN_ECT0 << 20);
#endif
d1087 1
a1087 1
		tp->retran_data;
@


1.29.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.29.2.7 2003/03/28 00:06:54 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d1074 3
a1076 14
	if (so->so_options & SO_DEBUG) {
		/* TCP template does not fill ip version, so fill it in here */
		struct ip *sip;
		sip = mtod(m, struct ip *);
		switch (tp->pf) {
		case AF_INET:
			sip->ip_v = 4;
			break;
		case AF_INET6:
			sip->ip_v = 6;
			break;
		}
		tcp_trace(TA_OUTPUT, tp->t_state, tp, m, 0, len);
	}
@


1.29.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a102 1
#include <netinet6/in6_var.h>
d145 1
a145 2

	if (!tp->sack_enable)
d216 1
a216 1
	struct tcpcb *tp;
d218 2
a219 2
	struct socket *so = tp->t_inpcb->inp_socket;
	long len, win, txmaxseg;
d221 2
a222 2
	struct mbuf *m;
	struct tcphdr *th;
d241 1
a241 1
	if (tp->sack_enable && (tp->t_flags & TF_SIGNATURE))
d266 1
a266 1
	if (tp->sack_enable && SEQ_LT(tp->snd_nxt, tp->snd_max))
d275 1
a275 1
	if (tp->sack_enable && (tp->t_dupacks > tcprexmtthresh))
d291 1
a291 1
	if (tp->sack_enable && !sendalot) {
d354 1
a354 1
	if (tp->sack_enable && len && SEQ_GT(tp->snd_last, tp->snd_una) &&
d562 1
a562 1
			if (tp->sack_enable && ((flags & TH_ACK) == 0 ||
d634 1
a634 1
	if (tp->sack_enable && tp->t_state == TCPS_ESTABLISHED &&
d892 1
a892 1
		union sockaddr_union src, dst;
d895 1
a895 2
		bzero(&src, sizeof(union sockaddr_union));
		bzero(&dst, sizeof(union sockaddr_union));
d901 3
a903 6
			src.sa.sa_len = sizeof(struct sockaddr_in);
			src.sa.sa_family = AF_INET;
			src.sin.sin_addr = mtod(m, struct ip *)->ip_src;
			dst.sa.sa_len = sizeof(struct sockaddr_in);
			dst.sa.sa_family = AF_INET;
			dst.sin.sin_addr = mtod(m, struct ip *)->ip_dst;
d908 3
a910 6
			src.sa.sa_len = sizeof(struct sockaddr_in6);
			src.sa.sa_family = AF_INET6;
			src.sin6.sin6_addr = mtod(m, struct ip6_hdr *)->ip6_src;
			dst.sa.sa_len = sizeof(struct sockaddr_in6);
			dst.sa.sa_family = AF_INET6;
			dst.sin6.sin6_addr = mtod(m, struct ip6_hdr *)->ip6_dst;
d915 1
a915 1
		/* XXX gettdbbysrcdst() should really be called at spltdb().      */
d917 1
a917 1
		tdb = gettdbbysrcdst(0, &src, &dst, IPPROTO_TCP);
d937 1
a937 1
				ippseudo.ippseudo_len = ntohs(ipovly->ih_len) + len +
a938 1
				ippseudo.ippseudo_len = htons(ippseudo.ippseudo_len);
d940 4
a943 1
				    sizeof(struct ippseudo));
d950 1
a950 2
				struct ip6_hdr_pseudo ip6pseudo;
				struct ip6_hdr *ip6;
d952 5
a956 12
				ip6 = mtod(m, struct ip6_hdr *);
				bzero(&ip6pseudo, sizeof(ip6pseudo));
				ip6pseudo.ip6ph_src = ip6->ip6_src;
				ip6pseudo.ip6ph_dst = ip6->ip6_dst;
				in6_clearscope(&ip6pseudo.ip6ph_src);
				in6_clearscope(&ip6pseudo.ip6ph_dst);
				ip6pseudo.ip6ph_nxt = IPPROTO_TCP;
				ip6pseudo.ip6ph_len =
				    htonl(sizeof(struct tcphdr) + len + optlen);
 
				MD5Update(&ctx, (char *)&ip6pseudo,
				    sizeof(ip6pseudo));
a961 9
		{
			u_int16_t thsum = th->th_sum;

			/* RFC 2385 requires th_sum == 0 */
			th->th_sum = 0;
			MD5Update(&ctx, (char *)th, sizeof(struct tcphdr));
			th->th_sum = thsum;
		}

d963 1
a963 1
		    (caddr_t)&ctx))
d1014 1
a1014 1
		if (tp->sack_enable) {
d1044 1
a1044 1
		if (tp->sack_enable && sack_rxmit &&
d1070 14
a1083 3
	if (so->so_options & SO_DEBUG)
		tcp_trace(TA_OUTPUT, tp->t_state, tp, mtod(m, caddr_t), 0,
			len);
d1118 1
a1118 1
			ip->ip_len = htons(m->m_pkthdr.len);
@


1.29.2.10
log
@Merge with the trunk
@
text
@d107 1
a107 1
#include <crypto/md5.h>
d619 1
d626 1
a626 2

		optlen += TCPOLEN_SIGLEN;
d708 1
a708 1
		if (m != NULL && max_linkhdr + hdrlen > MHLEN) {
d721 1
a721 1
		if (len <= M_TRAILINGSPACE(m)) {
d753 1
a753 1
		if (m != NULL && max_linkhdr + hdrlen > MHLEN) {
a767 1
	m->m_pkthdr.len = hdrlen + len;
d871 2
a872 2
	if (win < (long)(int32_t)(tp->rcv_adv - tp->rcv_nxt))
		win = (long)(int32_t)(tp->rcv_adv - tp->rcv_nxt);
d1012 1
d1104 1
d1193 1
a1193 1
			tcp_mtudisc(tp->t_inpcb, -1);
@


1.29.2.11
log
@sync to head
@
text
@d106 4
d894 1
a894 1
		int iphlen;
a904 1
			iphlen = sizeof(struct ip);
a914 1
			iphlen = sizeof(struct ip6_hdr);
d925 1
a925 1
		/* XXX gettdbbysrcdst() should really be called at spltdb(). */
d931 58
a988 2
		if (tcp_signature(tdb, tp->pf, m, th, iphlen, 0,
		    mtod(m, caddr_t) + hdrlen - optlen + sigoff) < 0)
d990 3
@


1.28
log
@option TCP_NEWRENO goes away, its the default case for TCP_SACK if
SACK is disabled for the connection or via sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.27 1999/12/15 16:37:20 provos Exp $	*/
d810 1
a810 1
		memset(&sa, 0, sizeof(union sockaddr_union));
@


1.27
log
@never go into persist mode if there are still segments to be retransmitted.
set retransmit timer again if it was cleared, that can happen in SACK when
there are no elligble SACK holes to be retransmitted and the receiver window
is full.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.26 1999/12/10 17:51:10 itojun Exp $	*/
d190 1
a190 1
#if defined(TCP_SACK) || defined(TCP_NEWRENO)
d1064 1
a1064 1
#if defined(TCP_SACK) || defined(TCP_NEWRENO)
@


1.26
log
@sync DIAGNOSTIC code with reality.  we always get cluster mbuf so
max_linkhdr + hdrlen <= MCLBYTES is safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.25 1999/12/08 06:50:20 itojun Exp $	*/
d402 13
@


1.25
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.24 1999/12/02 16:31:17 deraadt Exp $	*/
d593 1
a593 1
	if (max_linkhdr + hdrlen > MHLEN)
@


1.24
log
@typo; gbayley@@ausmac.net
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.23 1999/11/15 05:50:59 hugh Exp $	*/
d443 2
a444 2
	 *	max_linkhdr + sizeof(network header) + sizeof(struct tcphdr) +
	 *		optlen <= MHLEN
a447 1
#if defined(INET) && defined(INET6)
d449 1
a449 4
#else /* defined(INET) && defined(INET6) */
	switch (0) {
#endif /* defined(INET) && defined(INET6) */
	case 0:		/* If tp->pf is 0, then assume IPv4 unless not avail */
d457 1
a457 1
		hdrlen = sizeof(struct ipv6) + sizeof(struct tcphdr);
d625 7
d638 1
a638 1
		if (len <= MHLEN - hdrlen - max_linkhdr) {
d670 7
a775 1
#if defined(INET) && defined(INET6)
d777 1
a777 4
#else /* defined(INET) && defined(INET6) */
	switch (0) {
#endif /* defined(INET) && defined(INET6) */
	case 0:
d799 2
a800 6
#if defined(INET) && defined(INET6)
		switch(tp->pf) {
#else /* defined(INET) && defined(INET6) */
		switch (0) {
#endif /* defined(INET) && defined(INET6) */
		case 0:
d812 1
a812 1
			sa.sin6.sin6_addr = mtod(m, struct ipv6 *)->ipv6_dst;
d825 2
a826 6
#if defined(INET) && defined(INET6)
		switch(tp->pf) {
#else /* defined(INET) && defined(INET6) */
		switch (0) {
#endif /* defined(INET) && defined(INET6) */
		case 0:
a875 1
#if defined(INET) && defined(INET6)
d877 1
a877 4
#else /* defined(INET) && defined(INET6) */
	switch (0) {
#endif /* defined(INET) && defined(INET6) */
	case 0:
d885 3
a887 2
  		th->th_sum = in6_cksum(m, IPPROTO_TCP, hdrlen + len,
			sizeof(struct ipv6));
a978 1
#if defined(INET) && defined(INET6)
d980 1
a980 4
#else /* defined(INET) && defined(INET6) */
	switch (0) {
#endif /* defined(INET) && defined(INET6) */
	case 0:
a990 1

d999 1
a999 1
			struct ipv6 *ipv6;
d1001 9
a1009 8
			ipv6->ipv6_length = m->m_pkthdr.len -
				sizeof(struct ipv6);
			ipv6->ipv6_nexthdr = IPPROTO_TCP;
		}

		error = ipv6_output(m, &tp->t_inpcb->inp_route6,
			(so->so_options & SO_DONTROUTE), NULL, NULL,
			tp->t_inpcb->inp_socket);
@


1.23
log
@Fix tcp retransmit/persist timers, provos@@ OK.

Adapted from NetBSD:
    Fix a retransmission bug introduced by the Brakmo and Peterson
    RTO estimation changes.  Under some circumstances it would
    return a value of 0, while the old Van Jacobson RTO code would
    return a minimum of 3.  This would result in 12 retransmissions,
    each 1 second apart.  This takes care of those instances, and
    ensures that t_rttmin is used everywhere as a lower bound.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.22 1999/11/04 11:24:24 ho Exp $	*/
d816 1
a816 1
		 * XXX this is splsoftnet(), currently they are the same. */
@


1.22
log
@Add comment about gettdb() and spl level.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.21 1999/07/06 20:17:53 cmetz Exp $	*/
d1080 2
@


1.21
log
@Added support for TCP MD5 option (RFC 2385).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.19 1999/07/03 02:16:51 deraadt Exp $	*/
d815 2
@


1.20
log
@Fixed compilation problems when INET6 is enabled.
@
text
@d86 4
d193 8
d524 27
d784 87
@


1.19
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.18 1999/07/02 21:22:13 cmetz Exp $	*/
d763 2
a764 1
  		th->th_sum = in6_cksum(m, IPPROTO_TCP, hdrlen + len);
@


1.18
log
@Fixed a #ifdef defined()... typo that turned into a compilation failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.17 1999/07/02 20:39:08 cmetz Exp $	*/
d437 1
a437 1
	switch(tp->pf) {
d439 1
a439 1
	switch(0) {
d728 1
a728 1
	switch(tp->pf) {
d730 1
a730 1
	switch(0) {
d856 1
a856 1
	switch(tp->pf) {
d858 1
a858 1
	switch(0) {
@


1.17
log
@Significant cleanups in the way TCP is made to handle multiple network
protocols.

"struct tcpiphdr" is now gone from much of the code, as are separate pointers
for ti and ti6. The result is fewer variables, which is generally a good thing.

Simple if(is_ipv6) ... else ... tests are gone in favor of a
switch(protocol family), which allows future new protocols to be added easily.
This also makes it possible for someone so inclined to re-implement TUBA (TCP
over CLNP?) and do it right instead of the kluged way it was done in 4.4.

The TCP header template is now referenced through a mbuf rather than done
through a data pointer and dtom()ed as needed. This is partly because dtom() is
evil and partly because max_linkhdr + IPv6 + TCP + MSS/TS/SACK opts won't fit
inside a packet header mbuf, so we need to grab a cluster for that (which the
code now does, if needed).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.16 1999/01/11 02:01:36 deraadt Exp $	*/
d436 1
a436 1
#ifdef defined(INET) && defined(INET6)
d727 1
a727 1
#ifdef defined(INET) && defined(INET6)
d750 1
a750 1
#ifdef defined(INET) && defined(INET6)
d855 1
a855 1
#ifdef defined(INET) && defined(INET6)
@


1.16
log
@netinet merge of NRL stuff. some indent and shrinkage needed; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.15 1998/11/25 05:44:37 millert Exp $	*/
a94 6
#define MAX_TCPOPTLEN	40	/* need 40 at least for 3 SACKs + TIMESTAMP */
#else
#define MAX_TCPOPTLEN	32	/* max # bytes that go in options */
#endif

#ifdef TCP_SACK
a177 1
	register struct tcpiphdr *ti;
a178 3
#ifdef INET6
	register struct tcpipv6hdr *ti6 = NULL;
#endif /* INET6 */
d431 2
a432 8
	 *	max_linkhdr + sizeof (struct tcpiphdr) + optlen <= MHLEN
	 */
#ifdef INET6
        /*
	 * For IPv6, this has changed to be:
	 *      max_linkhdr + sizeof(struct tcphdr) + optlen + 
	 *           sizeof(struct ipv6)  <= MHLEN
	 * This MIGHT be harder...
a433 1
#endif /* INET6 */
d435 12
d448 3
a450 3
	if (tp->pf == PF_INET6)  /* if tp->pf is 0, then assume IPv4. */
	  hdrlen = sizeof(struct tcphdr) + sizeof(struct ipv6);
	else
d452 4
a455 1
	hdrlen = sizeof (struct tcpiphdr);
d540 5
a635 4
#ifdef INET6
	if (tp->pf == PF_INET6) {
		ti6 = mtod(m, struct tcpipv6hdr *);
		ti = NULL;
d637 10
a646 20
		if (!tp->t_template)
			panic("tcp_output");

		bcopy((caddr_t)tp->t_template, (caddr_t)ti6,
			sizeof (struct tcpipv6hdr));

		th = &ti6->ti6_t;
	} else
#endif /* INET6 */
	{
		ti = mtod(m, struct tcpiphdr *);

		if (tp->t_template == 0)
			panic("tcp_output");

		bcopy((caddr_t)tp->t_template, (caddr_t)ti,
		      sizeof (struct tcpiphdr));

		th = &ti->ti_t;
	};
d726 20
d750 11
d762 3
a764 5
	if (tp->pf == PF_INET6) {
	  th->th_sum = in6_cksum(m, IPPROTO_TCP,
				 sizeof(struct tcphdr) + optlen + len,
				 sizeof(struct ipv6));
	} else
a765 5
	{
		if (len + optlen)
			ti->ti_len = htons((u_int16_t)(sizeof (struct tcphdr) +
				optlen + len));
		ti->ti_sum = in_cksum(m, (int)(hdrlen + len));
d844 2
a845 6
#if INET6
		tcp_trace(TA_OUTPUT, tp->t_state, tp,
		    (tp->pf == AF_INET6) ? (struct tcpiphdr *)ti6 : ti, 0, len);
#else
	tcp_trace(TA_OUTPUT, tp->t_state, tp, ti, 0, len);
#endif
d854 23
a876 5
#ifdef TUBA
	if (tp->t_tuba_pcb)
		error = tuba_output(m, tp);
	else
#endif
d878 8
a885 2
	if (tp->pf == PF_INET6) {
	  ((struct ipv6 *)ti6)->ipv6_length = m->m_pkthdr.len - sizeof(struct ipv6);
d887 12
a898 5
	  /* Following fields are already grabbed from the tcp_template. */
	  /* ((struct ipv6 *)ti6)->ipv6_versfl   = ntohl(0x60000000);
	  ((struct ipv6 *)ti6)->ipv6_nexthdr  = IPPROTO_TCP;
	  ((struct ipv6 *)ti6)->ipv6_hoplimit = 
	    tp->t_inpcb->inp_ipv6.ipv6_hoplimit;*/
a899 9
	  error = ipv6_output(m, &tp->t_inpcb->inp_route6, (so->so_options & SO_DONTROUTE), NULL, NULL, tp->t_inpcb->inp_socket);
	} else
#endif /* INET6 */
    {
	((struct ip *)ti)->ip_len = m->m_pkthdr.len;
	((struct ip *)ti)->ip_ttl = tp->t_inpcb->inp_ip.ip_ttl;	/* XXX */
	((struct ip *)ti)->ip_tos = tp->t_inpcb->inp_ip.ip_tos;	/* XXX */
	error = ip_output(m, tp->t_inpcb->inp_options, &tp->t_inpcb->inp_route,
	    so->so_options & SO_DONTROUTE, 0, tp->t_inpcb);
d902 4
a905 4
        tp->snd_awnd = tcp_seq_subtract(tp->snd_max, tp->snd_fack) +
            tp->retran_data;                
#endif
    }
@


1.15
log
@more min vs. ulmin/lmin fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.14 1998/11/25 05:20:51 millert Exp $	*/
d39 12
d59 1
d82 4
d185 4
d443 8
d452 5
d633 25
a657 4
	ti = mtod(m, struct tcpiphdr *);
	if (tp->t_template == 0)
		panic("tcp_output");
	bcopy((caddr_t)tp->t_template, (caddr_t)ti, sizeof (struct tcpiphdr));
d681 1
a681 1
		ti->ti_seq = htonl(tp->snd_nxt);
d683 2
a684 1
		ti->ti_seq = htonl(tp->snd_max);
d694 1
a694 1
		ti->ti_seq = htonl(p->rxmit);
d702 1
a702 1
	ti->ti_ack = htonl(tp->rcv_nxt);
d704 2
a705 2
		bcopy((caddr_t)opt, (caddr_t)(ti + 1), optlen);
		ti->ti_off = (sizeof (struct tcphdr) + optlen) >> 2;
d707 2
a708 1
	ti->ti_flags = flags;
d721 1
a721 1
	ti->ti_win = htons((u_int16_t) (win>>tp->rcv_scale));
d726 2
a727 2
		ti->ti_urp = htons((u_int16_t)urp);
		ti->ti_flags |= TH_URG;
d741 13
a753 4
	if (len + optlen)
		ti->ti_len = htons((u_int16_t)(sizeof (struct tcphdr) +
		    optlen + len));
	ti->ti_sum = in_cksum(m, (int)(hdrlen + len));
d831 6
a836 1
		tcp_trace(TA_OUTPUT, tp->t_state, tp, ti, 0);
d850 13
a866 1
#if BSD >= 43
a868 4
#else
	error = ip_output(m, (struct mbuf *)0, &tp->t_inpcb->inp_route, 
	    so->so_options & SO_DONTROUTE);
#endif
@


1.14
log
@Must use lmin() not min() when comparing longs.  Fixes alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.13 1998/11/18 21:13:06 provos Exp $	*/
d205 1
a205 1
	win = min(tp->snd_wnd, tp->snd_cwnd);
d270 1
a270 1
	len = lmin(so->so_snd.sb_cc, win) - off;
d353 1
a353 1
		long adv = min(win, (long)TCP_MAXWIN << tp->rcv_scale) -
@


1.13
log
@64-bit clean up
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.12 1998/11/17 19:23:02 provos Exp $	*/
d270 1
a270 1
	len = min(so->so_snd.sb_cc, win) - off;
@


1.12
log
@NewReno, SACK and FACK support for TCP, adapted from code for BSDI
by Hari Balakrishnan (hari@@lcs.mit.edu), Tom Henderson (tomh@@cs.berkeley.edu)
and Venkat Padmanabhan (padmanab@@cs.berkeley.edu) as part of the
Daedalus research group at the University of California,
(http://daedalus.cs.berkeley.edu). [I was able to do this on time spent
at the Center for Information Technology Integration (citi.umich.edu)]
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.11 1998/10/28 21:34:33 provos Exp $	*/
d443 1
a443 1
				*((u_long *) (opt + optlen)) =
d489 2
a490 2
		u_long *lp = (u_long *) (opt + optlen);
		u_long *olp = lp++;
d495 1
a495 1
		for (i=0; (i < tp->rcv_numsacks && count < maxsack); i++) {
@


1.11
log
@- fix three bugs pointed out in Stevens, i.a. updating timestamps correctly
- fix a 4.4bsd-lite2 bug, when tcp options are present the maximum segment
size is not updated correctly, so that fast recovery forces out a segment
which is split in two segments by tcp_output(), the fix is adpated from
FreeBSD, the effective mss is recorded after option negotiation in 3way
handshake.
[I was able to fix this on time spent at Center for Information Technology
Integration (citi.umich.edu)]
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.10 1998/05/18 21:11:06 provos Exp $	*/
d73 3
d77 3
d81 74
d171 7
d195 9
d214 26
d267 18
a284 5
	if (win < so->so_snd.sb_cc) {
		len = win - off;
		flags &= ~TH_FIN;
	} else
		len = so->so_snd.sb_cc - off;
d292 4
a295 4
		 * calcel pending retransmit, pull snd_nxt back
		 * to (closed) window, and set the persist timer
		 * if it isn't already running.  If the window
		 * didn't close completely, just wait for an ACK.
a299 1
			tp->t_rxtshift = 0;
a300 2
			if (tp->t_timer[TCPT_PERSIST] == 0)
				tcp_setpersist(tp);
a304 1
		flags &= ~TH_FIN;
d307 2
d334 4
d434 14
d480 28
d629 17
d707 7
d736 13
d790 5
d821 3
d825 1
@


1.10
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.9 1998/02/03 19:06:30 deraadt Exp $	*/
d197 1
a197 1
		if (len >= tp->max_sndwnd / 2)
d333 1
a333 1
	 * bump the packet length beyond the t_maxseg length.
d335 2
a336 2
	if (len > tp->t_maxseg - optlen) {
		len = tp->t_maxseg - optlen;
@


1.9
log
@bad types; wileyc@@sekiya.twics.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.8 1997/11/24 07:28:33 deraadt Exp $	*/
d569 1
a569 1
	    so->so_options & SO_DONTROUTE, 0);
@


1.8
log
@Add missing (implied) int to a variable declaration; thorpej
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.7 1997/08/26 20:02:33 deraadt Exp $	*/
d609 1
a609 1
	register t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
@


1.7
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.6 1997/06/19 10:49:05 deraadt Exp $	*/
d89 1
a89 1
	unsigned optlen, hdrlen;
@


1.6
log
@ensure urgent is within window; TCP/IP Illustrated Vol 2, checked by Andreas.Gunnarsson@@emw.ericsson.se
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.5 1996/09/12 06:36:57 tholo Exp $	*/
d309 1
a309 1
 	}
d311 1
a311 1
 	/*
d315 4
a318 4
 	 */
 	if ((tp->t_flags & (TF_REQ_TSTMP|TF_NOOPT)) == TF_REQ_TSTMP &&
 	     (flags & TH_RST) == 0 &&
 	    ((flags & (TH_SYN|TH_ACK)) == TH_SYN ||
d322 6
a327 6
 		/* Form timestamp option as shown in appendix A of RFC 1323. */
 		*lp++ = htonl(TCPOPT_TSTAMP_HDR);
 		*lp++ = htonl(tcp_now);
 		*lp   = htonl(tp->ts_recent);
 		optlen += TCPOLEN_TSTAMP_APPA;
 	}
d329 1
a329 1
 	hdrlen += optlen;
d342 1
a342 1
 	if (max_linkhdr + hdrlen > MHLEN)
@


1.5
log
@Close TCP receive window when we cannot receive data; suggested by Darren
Reed.  Also make a conditional easier to read.
@
text
@d1 2
a2 2
/*	$OpenBSD: tcp_output.c,v 1.4 1996/09/12 06:19:56 tholo Exp $	*/
/*	$NetBSD: tcp_output.c,v 1.14 1996/02/13 23:43:53 christos Exp $	*/
d470 4
a473 1
		ti->ti_urp = htons((u_int16_t)(tp->snd_up - tp->snd_nxt));
@


1.4
log
@TCP Persist handling; from 4.4BSD Lite2 (via NetBSD PR 2335)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.3 1996/03/14 08:06:57 tholo Exp $	*/
d430 2
a431 2
	if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
	    tp->snd_nxt == tp->snd_max)
d466 2
@


1.3
log
@Fix from Lite2
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_output.c,v 1.2 1996/03/03 22:30:46 niklas Exp $	*/
d157 4
a160 4
		 * cancel pending retransmit and pull snd_nxt
		 * back to (closed) window.  We will enter persist
		 * state below.  If the window didn't close completely,
		 * just wait for an ACK.
d165 1
d167 2
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d332 1
a332 1
	 if (len > tp->t_maxseg - optlen) {
d334 1
a335 1
		sendalot = 1;
d383 5
a387 2
			if (m->m_next == 0)
				len = 0;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tcp_output.c,v 1.13 1995/04/13 20:09:23 cgd Exp $	*/
d63 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
