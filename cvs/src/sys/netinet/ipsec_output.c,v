head	1.68;
access;
symbols
	OPENBSD_6_2:1.68.0.2
	OPENBSD_6_2_BASE:1.68
	OPENBSD_6_1:1.65.0.4
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.62.0.4
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.61.0.2
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.44.0.6
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.43.0.4
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.41.0.6
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.2
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.39.0.6
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.33.0.6
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.33.0.4
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.25
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	SMP:1.7.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.68
date	2017.05.18.10.56.45;	author bluhm;	state Exp;
branches;
next	1.67;
commitid	end8oXU4pM3sNkRR;

1.67
date	2017.05.16.12.24.02;	author mpi;	state Exp;
branches;
next	1.66;
commitid	SAe3SQ48vKH6r5FL;

1.66
date	2017.04.06.14.25.18;	author dhill;	state Exp;
branches;
next	1.65;
commitid	wQ62gtwo3RyrRKTK;

1.65
date	2017.01.20.04.22.58;	author mpi;	state Exp;
branches;
next	1.64;
commitid	9nOt5A88b001xOMi;

1.64
date	2016.10.11.22.08.01;	author mikeb;	state Exp;
branches;
next	1.63;
commitid	MMJsNVDKqcPcpIjS;

1.63
date	2016.09.13.19.56.55;	author markus;	state Exp;
branches;
next	1.62;
commitid	MhzOL3PcQJk4ZhiI;

1.62
date	2016.02.28.16.16.10;	author mikeb;	state Exp;
branches;
next	1.61;
commitid	HW8HjoD0Bbrq076v;

1.61
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.60;
commitid	Cr0DVA7exR1t2zXg;

1.60
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	ncpqEGjDtSFuLAgn;

1.59
date	2015.06.11.15.59.17;	author mikeb;	state Exp;
branches;
next	1.58;
commitid	m5XqNI2MUatfnThg;

1.58
date	2015.04.17.11.04.02;	author mikeb;	state Exp;
branches;
next	1.57;
commitid	6glXvFR7NxzCcdRd;

1.57
date	2015.04.14.14.20.01;	author mikeb;	state Exp;
branches;
next	1.56;
commitid	70u0dWUlToMcLCnj;

1.56
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	VK3ncyiP3NS1N4Sy;

1.55
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.54;
commitid	zhW8jJrfVCoAthrR;

1.54
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.53;
commitid	ZqXwxwmeo3l29NOg;

1.53
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.52;
commitid	DQakU8LLWV6Iwx84;

1.52
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2013.08.03.12.45.41;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.28.23.10.06;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.45;

1.45
date	2012.09.18.09.24.45;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2011.03.05.01.53.16;	author bluhm;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2008.08.26.12.19.01;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2008.08.21.23.05.30;	author bluhm;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.28.17.16.39;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2007.02.08.15.25.30;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.19.11.31.10;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.05.09.17.12;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.12.09.39.54;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.24.16.09.37;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.26.04.32.38;	author ho;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.21.23.11.39;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.19.19.15.13;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.01.18.29.28;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.19.22.03.46;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.09.16.26.11;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.19.21.11.22;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.06.22.52.10;	author angelos;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.08.08.15.07.04;	author jjbg;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.05.16.45.55;	author jjbg;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.26.04.17.57;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.25.05.11.59;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.24.18.22.47;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.08.03.13.15;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.30.12.29.04;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.29.01.19.37;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.28.05.30.29;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.27.00.39.43;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.22.23.38.34;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.20.08.34.27;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.11.17.20.11;	author aaron;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.04.14.00.30.59;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.28.20.03.06;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.15.06.31.00;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.19.08.38.59;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.19.03.20.59;	author angelos;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.40.14;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.55.02;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;

1.28.2.1
date	2005.02.19.22.53.58;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2005.02.19.21.32.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.68
log
@The function name ip4_input() is confusing as it also handles IPv6
packets.  This is the IP in IP protocol input function, so call it
ipip_input().  Rename the existing ipip_input() to ipip_input_gif()
as it is the input function used by the gif interface.  Pass the
address family to make it consistent with pr_input.  Use __func__
in debug print and panic messages.  Move all ipip prototypes to the
ip_ipip.h header file.
OK dhill@@ mpi@@
@
text
@/*	$OpenBSD: ipsec_output.c,v 1.67 2017/05/16 12:24:02 mpi Exp $ */
/*
 * The author of this code is Angelos D. Keromytis (angelos@@cis.upenn.edu)
 *
 * Copyright (c) 2000-2001 Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#include <netinet/udp.h>
#include <netinet/ip_ipip.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/ip_ipcomp.h>
#include <crypto/xform.h>

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

int	udpencap_enable = 1;	/* enabled by default */
int	udpencap_port = 4500;	/* triggers decapsulation */

/*
 * Loop over a tdb chain, taking into consideration protocol tunneling. The
 * fourth argument is set if the first encapsulation header is already in
 * place.
 */
int
ipsp_process_packet(struct mbuf *m, struct tdb *tdb, int af, int tunalready)
{
	int hlen, off, error;
	struct mbuf *mp;
#ifdef INET6
	struct ip6_ext ip6e;
	int nxt;
	int dstopt = 0;
#endif

	int setdf = 0;
	struct ip *ip;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif /* INET6 */

#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	/* Check that the transform is allowed by the administrator. */
	if ((tdb->tdb_sproto == IPPROTO_ESP && !esp_enable) ||
	    (tdb->tdb_sproto == IPPROTO_AH && !ah_enable) ||
	    (tdb->tdb_sproto == IPPROTO_IPCOMP && !ipcomp_enable)) {
		DPRINTF(("ipsp_process_packet(): IPsec outbound packet "
		    "dropped due to policy (check your sysctls)\n"));
		m_freem(m);
		return EHOSTUNREACH;
	}

	/* Sanity check. */
	if (!tdb->tdb_xform) {
		DPRINTF(("ipsp_process_packet(): uninitialized TDB\n"));
		m_freem(m);
		return EHOSTUNREACH;
	}

	/* Check if the SPI is invalid. */
	if (tdb->tdb_flags & TDBF_INVALID) {
		DPRINTF(("ipsp_process_packet(): attempt to use invalid "
		    "SA %s/%08x/%u\n", ipsp_address(&tdb->tdb_dst, buf,
		    sizeof(buf)), ntohl(tdb->tdb_spi), tdb->tdb_sproto));
		m_freem(m);
		return ENXIO;
	}

	/* Check that the network protocol is supported */
	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		break;

#ifdef INET6
	case AF_INET6:
		break;
#endif /* INET6 */

	default:
		DPRINTF(("ipsp_process_packet(): attempt to use "
		    "SA %s/%08x/%u for protocol family %d\n",
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi), tdb->tdb_sproto,
		    tdb->tdb_dst.sa.sa_family));
		m_freem(m);
		return ENXIO;
	}

	/*
	 * Register first use if applicable, setup relevant expiration timer.
	 */
	if (tdb->tdb_first_use == 0) {
		tdb->tdb_first_use = time_second;
		if (tdb->tdb_flags & TDBF_FIRSTUSE)
			timeout_add_sec(&tdb->tdb_first_tmo,
			    tdb->tdb_exp_first_use);
		if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
			timeout_add_sec(&tdb->tdb_sfirst_tmo,
			    tdb->tdb_soft_first_use);
	}

	/*
	 * Check for tunneling if we don't have the first header in place.
	 * When doing Ethernet-over-IP, we are handed an already-encapsulated
	 * frame, so we don't need to re-encapsulate.
	 */
	if (tunalready == 0) {
		/*
		 * If the target protocol family is different, we know we'll be
		 * doing tunneling.
		 */
		if (af == tdb->tdb_dst.sa.sa_family) {
			if (af == AF_INET)
				hlen = sizeof(struct ip);

#ifdef INET6
			if (af == AF_INET6)
				hlen = sizeof(struct ip6_hdr);
#endif /* INET6 */

			/* Bring the network header in the first mbuf. */
			if (m->m_len < hlen) {
				if ((m = m_pullup(m, hlen)) == NULL)
					return ENOBUFS;
			}

			if (af == AF_INET) {
				ip = mtod(m, struct ip *);

				/*
				 * This is not a bridge packet, remember if we
				 * had IP_DF.
				 */
				setdf = ip->ip_off & htons(IP_DF);
			}

#ifdef INET6
			if (af == AF_INET6)
				ip6 = mtod(m, struct ip6_hdr *);
#endif /* INET6 */
		}

		/* Do the appropriate encapsulation, if necessary. */
		if ((tdb->tdb_dst.sa.sa_family != af) || /* PF mismatch */
		    (tdb->tdb_flags & TDBF_TUNNELING) || /* Tunneling needed */
		    (tdb->tdb_xform->xf_type == XF_IP4) || /* ditto */
		    ((tdb->tdb_dst.sa.sa_family == AF_INET) &&
		     (tdb->tdb_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
		     (tdb->tdb_dst.sin.sin_addr.s_addr != ip->ip_dst.s_addr)) ||
#ifdef INET6
		    ((tdb->tdb_dst.sa.sa_family == AF_INET6) &&
		     (!IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr)) &&
		     (!IN6_ARE_ADDR_EQUAL(&tdb->tdb_dst.sin6.sin6_addr,
		      &ip6->ip6_dst))) ||
#endif /* INET6 */
		    0) {
			/* Fix IPv4 header checksum and length. */
			if (af == AF_INET) {
				if (m->m_len < sizeof(struct ip))
					if ((m = m_pullup(m,
					    sizeof(struct ip))) == NULL)
						return ENOBUFS;

				ip = mtod(m, struct ip *);
				ip->ip_len = htons(m->m_pkthdr.len);
				ip->ip_sum = 0;
				ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
			}

#ifdef INET6
			/* Fix IPv6 header payload length. */
			if (af == AF_INET6) {
				if (m->m_len < sizeof(struct ip6_hdr))
					if ((m = m_pullup(m,
					    sizeof(struct ip6_hdr))) == NULL)
						return ENOBUFS;

				if (m->m_pkthdr.len - sizeof(*ip6) >
				    IPV6_MAXPACKET) {
					/* No jumbogram support. */
					m_freem(m);
					return ENXIO;	/*?*/
				}
				ip6 = mtod(m, struct ip6_hdr *);
				ip6->ip6_plen = htons(m->m_pkthdr.len
				    - sizeof(*ip6));
			}
#endif /* INET6 */

			/* Encapsulate -- the last two arguments are unused. */
			error = ipip_output(m, tdb, &mp, 0, 0);
			if ((mp == NULL) && (!error))
				error = EFAULT;
			if (error) {
				m_freem(mp);
				return error;
			}

			m = mp;
			mp = NULL;

			if (tdb->tdb_dst.sa.sa_family == AF_INET && setdf) {
				if (m->m_len < sizeof(struct ip))
					if ((m = m_pullup(m,
					    sizeof(struct ip))) == NULL)
						return ENOBUFS;

				ip = mtod(m, struct ip *);
				ip->ip_off |= htons(IP_DF);
			}

			/* Remember that we appended a tunnel header. */
			tdb->tdb_flags |= TDBF_USEDTUNNEL;
		}

		/* We may be done with this TDB */
		if (tdb->tdb_xform->xf_type == XF_IP4)
			return ipsp_process_done(m, tdb);
	} else {
		/*
		 * If this is just an IP-IP TDB and we're told there's
		 * already an encapsulation header, move on.
		 */
		if (tdb->tdb_xform->xf_type == XF_IP4)
			return ipsp_process_done(m, tdb);
	}

	/* Extract some information off the headers. */
	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		ip = mtod(m, struct ip *);
		hlen = ip->ip_hl << 2;
		off = offsetof(struct ip, ip_p);
		break;

#ifdef INET6
	case AF_INET6:
		ip6 = mtod(m, struct ip6_hdr *);
		hlen = sizeof(struct ip6_hdr);
		off = offsetof(struct ip6_hdr, ip6_nxt);
		nxt = ip6->ip6_nxt;
		/*
		 * chase mbuf chain to find the appropriate place to
		 * put AH/ESP/IPcomp header.
		 *	IPv6 hbh dest1 rthdr ah* [esp* dest2 payload]
		 */
		do {
			switch (nxt) {
			case IPPROTO_AH:
			case IPPROTO_ESP:
			case IPPROTO_IPCOMP:
				/*
				 * we should not skip security header added
				 * beforehand.
				 */
				goto exitip6loop;

			case IPPROTO_HOPOPTS:
			case IPPROTO_DSTOPTS:
			case IPPROTO_ROUTING:
				/*
				 * if we see 2nd destination option header,
				 * we should stop there.
				 */
				if (nxt == IPPROTO_DSTOPTS && dstopt)
					goto exitip6loop;

				if (nxt == IPPROTO_DSTOPTS) {
					/*
					 * seen 1st or 2nd destination option.
					 * next time we see one, it must be 2nd.
					 */
					dstopt = 1;
				} else if (nxt == IPPROTO_ROUTING) {
					/*
					 * if we see destionation option next
					 * time, it must be dest2.
					 */
					dstopt = 2;
				}

				/* skip this header */
				m_copydata(m, hlen, sizeof(ip6e),
				    (caddr_t)&ip6e);
				nxt = ip6e.ip6e_nxt;
				off = hlen + offsetof(struct ip6_ext, ip6e_nxt);
				/*
				 * we will never see nxt == IPPROTO_AH
				 * so it is safe to omit AH case.
				 */
				hlen += (ip6e.ip6e_len + 1) << 3;
				break;
			default:
				goto exitip6loop;
			}
		} while (hlen < m->m_pkthdr.len);
	exitip6loop:;
		break;
#endif /* INET6 */
	}

	/* Non expansion policy for IPCOMP */
	if (tdb->tdb_sproto == IPPROTO_IPCOMP) {
		if ((m->m_pkthdr.len - hlen) < tdb->tdb_compalgxform->minlen) {
			/* No need to compress, leave the packet untouched */
			ipcompstat.ipcomps_minlen++;
			return ipsp_process_done(m, tdb);
		}
	}

	/* Invoke the IPsec transform. */
	return (*(tdb->tdb_xform->xf_output))(m, tdb, NULL, hlen, off);
}

/*
 * Called by the IPsec output transform callbacks, to transmit the packet
 * or do further processing, as necessary.
 */
int
ipsp_process_done(struct mbuf *m, struct tdb *tdb)
{
	struct ip *ip;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif /* INET6 */
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
	int roff;

	tdb->tdb_last_used = time_second;

	if ((tdb->tdb_flags & TDBF_UDPENCAP) != 0) {
		struct mbuf *mi;
		struct udphdr *uh;
		int iphlen;

		if (!udpencap_enable || !udpencap_port) {
			m_freem(m);
			return ENXIO;
		}

		switch (tdb->tdb_dst.sa.sa_family) {
		case AF_INET:
			iphlen = sizeof(struct ip);
			break;
#ifdef INET6
		case AF_INET6:
			iphlen = sizeof(struct ip6_hdr);
			break;
#endif /* INET6 */
		default:
			m_freem(m);
			DPRINTF(("ipsp_process_done(): unknown protocol family "
			    "(%d)\n", tdb->tdb_dst.sa.sa_family));
			return ENXIO;
		}

		mi = m_makespace(m, iphlen, sizeof(struct udphdr), &roff);
		if (mi == NULL) {
			m_freem(m);
			return ENOMEM;
		}
		uh = (struct udphdr *)(mtod(mi, caddr_t) + roff);
		uh->uh_sport = uh->uh_dport = htons(udpencap_port);
		if (tdb->tdb_udpencap_port)
			uh->uh_dport = tdb->tdb_udpencap_port;

		uh->uh_ulen = htons(m->m_pkthdr.len - iphlen);
		uh->uh_sum = 0;
#ifdef INET6
		if (tdb->tdb_dst.sa.sa_family == AF_INET6)
			m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
#endif /* INET6 */
		espstat.esps_udpencout++;
	}

	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		/* Fix the header length, for AH processing. */
		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
		if ((tdb->tdb_flags & TDBF_UDPENCAP) != 0)
			ip->ip_p = IPPROTO_UDP;
		break;

#ifdef INET6
	case AF_INET6:
		/* Fix the header length, for AH processing. */
		if (m->m_pkthdr.len < sizeof(*ip6)) {
			m_freem(m);
			return ENXIO;
		}
		if (m->m_pkthdr.len - sizeof(*ip6) > IPV6_MAXPACKET) {
			/* No jumbogram support. */
			m_freem(m);
			return ENXIO;
		}
		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
		if ((tdb->tdb_flags & TDBF_UDPENCAP) != 0)
			ip6->ip6_nxt = IPPROTO_UDP;
		break;
#endif /* INET6 */

	default:
		m_freem(m);
		DPRINTF(("ipsp_process_done(): unknown protocol family (%d)\n",
		    tdb->tdb_dst.sa.sa_family));
		return ENXIO;
	}

	/*
	 * Add a record of what we've done or what needs to be done to the
	 * packet.
	 */
	mtag = m_tag_get(PACKET_TAG_IPSEC_OUT_DONE, sizeof(struct tdb_ident),
	    M_NOWAIT);
	if (mtag == NULL) {
		m_freem(m);
		DPRINTF(("ipsp_process_done(): could not allocate packet "
		    "tag\n"));
		return ENOMEM;
	}

	tdbi = (struct tdb_ident *)(mtag + 1);
	tdbi->dst = tdb->tdb_dst;
	tdbi->proto = tdb->tdb_sproto;
	tdbi->spi = tdb->tdb_spi;
	tdbi->rdomain = tdb->tdb_rdomain;

	m_tag_prepend(m, mtag);

	/* If there's another (bundled) TDB to apply, do so. */
	if (tdb->tdb_onext)
		return ipsp_process_packet(m, tdb->tdb_onext,
		    tdb->tdb_dst.sa.sa_family, 0);

#if NPF > 0
	/* Add pf tag if requested. */
	pf_tag_packet(m, tdb->tdb_tag, -1);
	pf_pkt_addr_changed(m);
#endif

	/*
	 * We're done with IPsec processing, transmit the packet using the
	 * appropriate network protocol (IP or IPv6). SPD lookup will be
	 * performed again there.
	 */
	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		return (ip_output(m, NULL, NULL, IP_RAWOUTPUT, NULL, NULL, 0));

#ifdef INET6
	case AF_INET6:
		/*
		 * We don't need massage, IPv6 header fields are always in
		 * net endian.
		 */
		return (ip6_output(m, NULL, NULL, 0, NULL, NULL));
#endif /* INET6 */
	}
	return EINVAL; /* Not reached. */
}

ssize_t
ipsec_hdrsz(struct tdb *tdbp)
{
	ssize_t adjust;

	switch (tdbp->tdb_sproto) {
	case IPPROTO_IPIP:
		adjust = 0;
		break;

	case IPPROTO_ESP:
		if (tdbp->tdb_encalgxform == NULL)
			return (-1);

		/* Header length */
		adjust = 2 * sizeof(u_int32_t) + tdbp->tdb_ivlen;
		if (tdbp->tdb_flags & TDBF_UDPENCAP)
			adjust += sizeof(struct udphdr);
		/* Authenticator */
		if (tdbp->tdb_authalgxform != NULL)
			adjust += tdbp->tdb_authalgxform->authsize;
		/* Padding */
		adjust += MAX(4, tdbp->tdb_encalgxform->blocksize);
		break;

	case IPPROTO_AH:
		if (tdbp->tdb_authalgxform == NULL)
			return (-1);

		adjust = AH_FLENGTH + sizeof(u_int32_t);
		adjust += tdbp->tdb_authalgxform->authsize;
		break;

	default:
		return (-1);
	}

	if (!(tdbp->tdb_flags & TDBF_TUNNELING) &&
	    !(tdbp->tdb_flags & TDBF_USEDTUNNEL))
		return (adjust);

	switch (tdbp->tdb_dst.sa.sa_family) {
	case AF_INET:
		adjust += sizeof(struct ip);
		break;
#ifdef INET6
	case AF_INET6:
		adjust += sizeof(struct ip6_hdr);
		break;
#endif /* INET6 */
	}

	return (adjust);
}

void
ipsec_adjust_mtu(struct mbuf *m, u_int32_t mtu)
{
	struct tdb_ident *tdbi;
	struct tdb *tdbp;
	struct m_tag *mtag;
	ssize_t adjust;

	NET_ASSERT_LOCKED();

	for (mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_DONE, NULL); mtag;
	     mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_DONE, mtag)) {
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdbp = gettdb(tdbi->rdomain, tdbi->spi, &tdbi->dst,
		    tdbi->proto);
		if (tdbp == NULL)
			break;

		if ((adjust = ipsec_hdrsz(tdbp)) == -1)
			break;

		mtu -= adjust;
		tdbp->tdb_mtu = mtu;
		tdbp->tdb_mtutimeout = time_second + ip_mtudisc_timeout;
		DPRINTF(("ipsec_adjust_mtu: "
		    "spi %08x mtu %d adjust %ld mbuf %p\n",
		    ntohl(tdbp->tdb_spi), tdbp->tdb_mtu,
		    adjust, m));
	}
}
@


1.67
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.66 2017/04/06 14:25:18 dhill Exp $ */
d45 1
a45 1
#include <netinet/ip_ipsp.h>
@


1.66
log
@Replace bcopy with a simple assignment where both variables are
properly aligned and sockaddr_union fields, or with memcpy when
the memory doesn't overlap.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.65 2017/01/20 04:22:58 mpi Exp $ */
d571 1
a571 1
	splsoftassert(IPL_SOFTNET);
@


1.65
log
@Kill recursive splsofnet()/splx() dances.

Tested by Hrvoje Popovski, ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.64 2016/10/11 22:08:01 mikeb Exp $ */
d469 1
a469 1
	bcopy(&tdb->tdb_dst, &tdbi->dst, sizeof(union sockaddr_union));
@


1.64
log
@Rename 'i' to 'hlen' for greater readability;  ok millert, naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.63 2016/09/13 19:56:55 markus Exp $ */
a569 1
	int s;
d571 1
a571 1
	s = splsoftnet();
a591 2

	splx(s);
@


1.63
log
@avoid extensive mbuf allocation for IPsec by replacing m_inject(4)
with m_makespace(4) from freebsd; ok mpi@@, bluhm@@, mikeb@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.62 2016/02/28 16:16:10 mikeb Exp $ */
d68 1
a68 1
	int i, off, error;
d157 1
a157 1
				i = sizeof(struct ip);
d161 1
a161 1
				i = sizeof(struct ip6_hdr);
d165 2
a166 2
			if (m->m_len < i) {
				if ((m = m_pullup(m, i)) == NULL)
d191 2
a192 2
			(tdb->tdb_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
			(tdb->tdb_dst.sin.sin_addr.s_addr != ip->ip_dst.s_addr)) ||
d195 3
a197 3
			(!IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr)) &&
			(!IN6_ARE_ADDR_EQUAL(&tdb->tdb_dst.sin6.sin6_addr,
			    &ip6->ip6_dst))) ||
d275 1
a275 1
		i = ip->ip_hl << 2;
d282 1
a282 1
		i = sizeof(struct ip6_hdr);
d326 2
a327 1
				m_copydata(m, i, sizeof(ip6e), (caddr_t)&ip6e);
d329 1
a329 1
				off = i + offsetof(struct ip6_ext, ip6e_nxt);
d334 1
a334 1
				i += (ip6e.ip6e_len + 1) << 3;
d339 1
a339 1
		} while (i < m->m_pkthdr.len);
d347 1
a347 1
		if ((m->m_pkthdr.len - i) < tdb->tdb_compalgxform->minlen) {
d355 1
a355 1
	return (*(tdb->tdb_xform->xf_output))(m, tdb, NULL, i, off);
@


1.62
log
@When IPsec UDP encapsulation is used for IPv6, the stack should
construct an IPv6 packet instead of an IPv4.

Diff from Patrick Wildt <patrick at blueri ! se> with input from
bluhm@@; ok mpi, bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.61 2015/09/11 08:17:06 claudio Exp $ */
a364 1

a367 1

d370 1
d400 1
a400 1
		mi = m_inject(m, iphlen, sizeof(struct udphdr), M_DONTWAIT);
d405 1
a405 1
		uh = mtod(mi, struct udphdr *);
@


1.61
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.60 2015/07/15 22:16:42 deraadt Exp $ */
d378 1
d384 18
a401 2
		mi = m_inject(m, sizeof(struct ip), sizeof(struct udphdr),
		    M_DONTWAIT);
d411 1
a411 1
		uh->uh_ulen = htons(m->m_pkthdr.len - sizeof(struct ip));
d413 4
@


1.60
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.59 2015/06/11 15:59:17 mikeb Exp $ */
d481 1
a481 1
		return (ip6_output(m, NULL, NULL, 0, NULL, NULL, NULL));
@


1.59
log
@Move away from using hzto(9);  OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.58 2015/04/17 11:04:02 mikeb Exp $ */
d238 1
a238 4
				if (mp)	{
					m_freem(mp);
					mp = NULL;
				}
@


1.58
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.57 2015/04/14 14:20:01 mikeb Exp $ */
a67 1
	struct timeval tv;
a136 4

		tv.tv_usec = 0;

		tv.tv_sec = tdb->tdb_first_use + tdb->tdb_exp_first_use;
d138 2
a139 4
			timeout_add(&tdb->tdb_first_tmo,
			    hzto(&tv));

		tv.tv_sec = tdb->tdb_first_use + tdb->tdb_soft_first_use;
d141 2
a142 2
			timeout_add(&tdb->tdb_sfirst_tmo,
			    hzto(&tv));
@


1.57
log
@make ipsp_address thread safe;  ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.56 2015/01/24 00:29:06 deraadt Exp $ */
d448 2
a449 8
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		mtag = m_tag_get(PACKET_TAG_IPSEC_OUT_DONE,
		    sizeof(struct tdb_ident),
		    M_NOWAIT);
	else
		mtag = m_tag_get(PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED,
		    sizeof(struct tdb_ident), M_NOWAIT);

@


1.56
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.55 2014/12/19 17:14:40 tedu Exp $ */
d83 4
d107 2
a108 2
		    "SA %s/%08x/%u\n", ipsp_address(tdb->tdb_dst),
		    ntohl(tdb->tdb_spi), tdb->tdb_sproto));
d126 3
a128 2
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi),
		    tdb->tdb_sproto, tdb->tdb_dst.sa.sa_family));
d584 1
a584 1
		    "spi %08x mtu %d adjust %d mbuf %p\n",
@


1.55
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.54 2014/09/08 06:24:13 jsg Exp $ */
d33 1
a33 4

#if NPF > 0
#include <net/pfvar.h>
#endif
d40 3
a42 2
#ifdef INET6
#endif /* INET6 */
@


1.54
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.53 2014/07/22 11:06:10 mpi Exp $ */
a37 1
#ifdef INET
a41 1
#endif /* INET */
a43 3
#ifndef INET
#include <netinet/in.h>
#endif
a78 1
#ifdef INET
a80 1
#endif /* INET */
a112 1
#ifdef INET
a114 1
#endif /* INET */
a159 1
#ifdef INET
a161 1
#endif /* INET */
a173 1
#ifdef INET
a182 1
#endif /* INET */
a193 1
#ifdef INET
a196 1
#endif /* INET */
a203 1
#ifdef INET
a215 1
#endif /* INET */
a251 1
#ifdef INET
a260 1
#endif
a279 1
#ifdef INET
a284 1
#endif /* INET */
a370 1
#ifdef INET
a371 1
#endif /* INET */
a406 1
#ifdef INET
a413 1
#endif /* INET */
a484 1
#ifdef INET
a486 1
#endif /* INET */
a541 1
#ifdef INET
a544 1
#endif /* INET */
@


1.53
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.52 2014/04/21 12:22:26 henning Exp $ */
a32 1
#include <net/route.h>
@


1.52
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.51 2014/04/21 11:10:54 henning Exp $ */
a40 1
#include <netinet/in_systm.h>
@


1.51
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.49 2013/08/03 12:45:41 markus Exp $ */
d514 1
a514 1
		return (ip_output(m, NULL, NULL, IP_RAWOUTPUT, NULL, NULL));
@


1.50
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d514 1
a514 1
		return ip_output(m, (void *)NULL, (void *)NULL, IP_RAWOUTPUT, (void *)NULL, (void *)NULL);
d523 1
a523 1
		return ip6_output(m, NULL, NULL, 0, NULL, NULL, NULL);
@


1.49
log
@unbreak PMTU-discovery for AES-GCM; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.48 2013/04/10 08:50:59 mpi Exp $ */
a50 1
#include <netinet6/in6_var.h>
@


1.48
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.47 2013/03/28 23:10:06 tedu Exp $ */
d552 1
a552 1
		adjust += tdbp->tdb_encalgxform->blocksize;
@


1.47
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.46 2012/09/20 10:25:03 blambert Exp $ */
a377 2
			extern struct ipcompstat ipcompstat;

@


1.46
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.45 2012/09/18 09:24:45 markus Exp $ */
d30 1
@


1.45
log
@remove the SADB_X_SAFLAGS_{HALFIV,RANDOMPADDING,NOREPLAY} pfkey-API (not set
anywhere) as well as the matching TDBF_{HALFIV,RANDOMPADDING,NOREPLAY} code.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.44 2011/03/05 01:53:16 bluhm Exp $ */
d597 1
a597 1
	s = spltdb();
@


1.44
log
@The function pf_tag_packet() never fails.  Remove a redundant check
and make it void.
ok henning@@, markus@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.43 2010/07/09 16:58:06 reyk Exp $ */
d546 1
a546 4
		if (tdbp->tdb_flags & TDBF_NOREPLAY)
			adjust = sizeof(u_int32_t) + tdbp->tdb_ivlen;
		else
			adjust = 2 * sizeof(u_int32_t) + tdbp->tdb_ivlen;
d560 1
a560 4
		if (!(tdbp->tdb_flags & TDBF_NOREPLAY))
			adjust = AH_FLENGTH + sizeof(u_int32_t);
		else
			adjust = AH_FLENGTH;
@


1.43
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.42 2010/01/10 12:43:07 markus Exp $ */
d504 1
a504 2
	if (pf_tag_packet(m, tdb->tdb_tag, -1))
		DPRINTF(("failed to tag ipsec packet\n"));
@


1.42
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.41 2008/08/26 12:19:01 henning Exp $ */
d493 1
d609 2
a610 1
		tdbp = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
@


1.41
log
@we need to call pf_pkt_addr_changed here too. found by david
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.40 2008/08/21 23:05:30 bluhm Exp $ */
d554 1
a554 1
			adjust += AH_HMAC_HASHLEN;
@


1.40
log
@Assign the ip and ip6 pointers in ipsp_process_packet() only if a
header of the matching address family is available.  Especially do
not read ip->ip_off from an IPv6 packet header.
ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.39 2007/06/01 00:52:38 henning Exp $ */
d505 1
@


1.39
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.38 2007/05/28 17:16:39 henning Exp $ */
d188 2
a189 1
			ip = mtod(m, struct ip *);
d191 6
a196 5
			/*
			 * This is not a bridge packet, remember if we
			 * had IP_DF.
			 */
			setdf = ip->ip_off & htons(IP_DF);
d200 2
a201 1
			ip6 = mtod(m, struct ip6_hdr *);
@


1.38
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.37 2007/02/08 15:25:30 itojun Exp $ */
d521 1
a521 1
		return ip6_output(m, NULL, NULL, 0, NULL, NULL);
@


1.37
log
@- AH: when computing crypto checksum for output, massage source-routing
  header.
- ipsec_input: fix mistake in IPv6 next-header chasing.
- ipsec_output: look for the position to insert AH more carefully.
- ip6_output: enable use of AH with extension headers.
  avoid tunnellinng when source-routing header is present.

ok by deraad, naddy, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.36 2006/12/19 11:31:10 itojun Exp $ */
d500 1
a500 1
	if (pf_tag_packet(m, NULL, tdb->tdb_tag, -1))
@


1.36
log
@TDBF_USEDTUNNEL flag manipulation was inside #ifdef INET.  it applies
to INET6 too, so move it outside.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.35 2006/12/05 09:17:12 markus Exp $ */
d80 5
d311 56
@


1.35
log
@do not install pmtu routes for transport mode SAs, as they do not
the dest IP; PMTU debugging support; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.34 2006/11/24 13:52:14 reyk Exp $ */
d273 1
a276 1
#endif
@


1.34
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.33 2005/04/12 09:39:54 markus Exp $ */
d553 4
@


1.33
log
@handle PMTU for ipip SAs, too; ok hshoexer, cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.32 2004/09/24 16:09:37 markus Exp $ */
d23 2
d34 4
d436 6
@


1.32
log
@pmtu support for udpencap; ok hshoexer, ho
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.31 2004/06/26 04:32:38 ho Exp $ */
d460 4
@


1.31
log
@Default enable udpencap. Add 'disable' sysctl to sysctl.conf. markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.30 2004/06/21 23:50:37 tholo Exp $ */
d469 2
@


1.31.2.1
log
@MFC:
Fix by markus@@

pmtu support for udpencap

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.31 2004/06/26 04:32:38 ho Exp $ */
a468 2
		if (tdbp->tdb_flags & TDBF_UDPENCAP)
			adjust += sizeof(struct udphdr);
@


1.30
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.29 2004/06/21 23:11:39 markus Exp $ */
d60 1
a60 1
int	udpencap_enable = 0;	/* disabled by default */
@


1.29
log
@don't send UDP encapsulated packets w/o UDP header if encap is disabled; ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.28 2003/12/02 23:16:29 markus Exp $ */
d134 1
a134 5
		int pri;

		pri = splhigh();
		tdb->tdb_first_use = time.tv_sec;
		splx(pri);
d337 1
a337 1
	tdb->tdb_last_used = time.tv_sec;
d534 1
a534 1
		tdbp->tdb_mtutimeout = time.tv_sec + ip_mtudisc_timeout;
@


1.28
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.27 2003/07/09 22:03:16 itojun Exp $ */
d343 1
a343 2
	if (udpencap_enable && udpencap_port &&
	    (tdb->tdb_flags & TDBF_UDPENCAP) != 0) {
d347 4
@


1.28.2.1
log
@MFC:
Fix by markus@@

pmtu support for udpencap

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.28 2003/12/02 23:16:29 markus Exp $ */
a469 2
		if (tdbp->tdb_flags & TDBF_UDPENCAP)
			adjust += sizeof(struct udphdr);
@


1.27
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.26 2003/02/19 19:15:13 jason Exp $ */
d47 1
d60 3
d343 21
d370 2
d389 2
@


1.26
log
@add a counter for times ipcomp is skipped because the packet is below the
minimum compression threshold.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.25 2002/08/28 15:43:03 pefo Exp $ */
d183 1
a183 1
			setdf = ntohs(ip->ip_off) & IP_DF;
d265 1
a265 3
				NTOHS(ip->ip_off);
				ip->ip_off |= IP_DF;
				HTONS(ip->ip_off);
a410 3
		NTOHS(ip->ip_len);
		NTOHS(ip->ip_off);

@


1.25
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.24 2002/07/01 18:29:28 angelos Exp $ */
d309 2
d312 1
@


1.24
log
@Move mtod() after the m_pullup() --- noted by sam@@errno.com (who seems
to be going over the IPsec code with a magnifying glass)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.23 2002/06/19 22:03:46 angelos Exp $ */
d413 1
a413 1
		return ip_output(m, NULL, NULL, IP_RAWOUTPUT, NULL, NULL);
@


1.23
log
@Remove redundant address family check -- sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.22 2002/06/09 16:26:11 itojun Exp $ */
a258 1
				ip = mtod(m, struct ip *);
d264 1
@


1.22
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.21 2002/02/19 21:11:22 miod Exp $ */
d342 2
a343 4
		if (tdb->tdb_dst.sa.sa_family == AF_INET) {
			ip = mtod(m, struct ip *);
			ip->ip_len = htons(m->m_pkthdr.len);
		}
d350 8
a357 12
		if (tdb->tdb_dst.sa.sa_family == AF_INET6) {
			if (m->m_pkthdr.len < sizeof(*ip6)) {
				m_freem(m);
				return ENXIO;
			}
			if (m->m_pkthdr.len - sizeof(*ip6) > IPV6_MAXPACKET) {
				/* No jumbogram support. */
				m_freem(m);
				return ENXIO;	/*?*/
			}
			ip6 = mtod(m, struct ip6_hdr *);
			ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
d359 2
@


1.21
log
@IPsec is written ``IPsec'', not ``IPSec''.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.20 2001/12/06 22:52:10 angelos Exp $ */
d237 1
a237 1
				ip6->ip6_plen = htons(m->m_pkthdr.len 
d264 1
a264 1
		    
d448 1
a448 1
		if (tdbp->tdb_authalgxform != NULL) 
d499 1
a499 1
	
@


1.20
log
@Use hzto() to handle overflow of (hz * timeout) cases --- when using
extremely long SA expirations.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.19 2001/08/08 15:07:04 jjbg Exp $ */
d83 1
a83 1
		DPRINTF(("ipsp_process_packet(): IPSec outbound packet "
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.20 2001/12/06 22:52:10 angelos Exp $ */
d83 1
a83 1
		DPRINTF(("ipsp_process_packet(): IPsec outbound packet "
@


1.20.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.20.2.1 2002/06/11 03:31:37 art Exp $ */
d237 1
a237 1
				ip6->ip6_plen = htons(m->m_pkthdr.len
d259 1
d264 1
a264 2

				ip = mtod(m, struct ip *);
d342 4
a345 2
		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
d352 12
a363 3
		if (m->m_pkthdr.len < sizeof(*ip6)) {
			m_freem(m);
			return ENXIO;
a364 7
		if (m->m_pkthdr.len - sizeof(*ip6) > IPV6_MAXPACKET) {
			/* No jumbogram support. */
			m_freem(m);
			return ENXIO;
		}
		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
d417 1
a417 1
		return ip_output(m, (void *)NULL, (void *)NULL, IP_RAWOUTPUT, (void *)NULL, (void *)NULL);
d448 1
a448 1
		if (tdbp->tdb_authalgxform != NULL)
d499 1
a499 1

@


1.20.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a308 2
			extern struct ipcompstat ipcompstat;

a309 1
			ipcompstat.ipcomps_minlen++;
@


1.19
log
@Remove IPCOMP option, it's now part of IPSEC option. You still need to
enable ipcomp via sysctl to use it. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.18 2001/07/05 16:45:55 jjbg Exp $ */
d67 1
d130 3
d134 5
d141 3
a143 1
			    hz * tdb->tdb_exp_first_use);
d146 1
a146 1
			    hz * tdb->tdb_soft_first_use);
@


1.18
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.17 2001/06/26 04:17:57 angelos Exp $ */
a294 1
#ifdef IPCOMP
a301 1
#endif /* IPCOMP */
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.16 2001/06/25 05:11:59 angelos Exp $ */
d50 1
d80 2
a81 1
	    (tdb->tdb_sproto == IPPROTO_AH && !ah_enable)) {
d294 10
@


1.16
log
@Copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.15 2001/06/24 18:22:47 provos Exp $ */
d66 2
a67 2
    int i, off, error;
    struct mbuf *mp;
d70 2
a71 2
    int setdf = 0;
    struct ip *ip;
d74 30
a103 31
    struct ip6_hdr *ip6;
#endif /* INET6 */

    /* Check that the transform is allowed by the administrator */
    if ((tdb->tdb_sproto == IPPROTO_ESP && !esp_enable) ||
	(tdb->tdb_sproto == IPPROTO_AH && !ah_enable))
    {
	DPRINTF(("ipsp_process_packet(): IPSec outbound packet dropped due to policy (check your sysctls)\n"));
	m_freem(m);
	return EHOSTUNREACH;
    }

    /* Sanity check */
    if (!tdb->tdb_xform)
    {
	DPRINTF(("ipsp_process_packet(): uninitialized TDB\n"));
	m_freem(m);
	return EHOSTUNREACH;
    }

    /* Check if the SPI is invalid */
    if (tdb->tdb_flags & TDBF_INVALID)
    {
	DPRINTF(("ipsp_process_packet(): attempt to use invalid SA %s/%08x/%u\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi), tdb->tdb_sproto));
	m_freem(m);
	return ENXIO;
    }

    /* Check that the network protocol is supported */
    switch (tdb->tdb_dst.sa.sa_family)
    {
d106 1
a106 1
	    break;
d111 1
a111 1
	    break;
d115 8
a122 22
	    DPRINTF(("ipsp_process_packet(): attempt to use SA %s/%08x/%u for protocol family %d\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi), tdb->tdb_sproto, tdb->tdb_dst.sa.sa_family));
	    m_freem(m);
	    return ENXIO;
    }

    /* Register first use if applicable, setup relevant expiration timer */
    if (tdb->tdb_first_use == 0)
    {
	tdb->tdb_first_use = time.tv_sec;
	if (tdb->tdb_flags & TDBF_FIRSTUSE)
	    timeout_add(&tdb->tdb_first_tmo, hz * tdb->tdb_exp_first_use);
	if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
	    timeout_add(&tdb->tdb_sfirst_tmo, hz * tdb->tdb_soft_first_use);
    }

    /*
     * Check for tunneling if we don't have the first header in place.
     * When doing Ethernet-over-IP, we are handed an already-encapsulated
     * frame, so we don't need to re-encapsulate.
     */
    if (tunalready == 0)
    {
d124 1
a124 2
	 * If the target protocol family is different, we know we'll be
	 * doing tunneling.
d126 21
a146 2
	if (af == tdb->tdb_dst.sa.sa_family)
	{
d148 2
a149 2
	    if (af == AF_INET)
	      i = sizeof(struct ip);
d153 2
a154 2
	    if (af == AF_INET6)
	      i = sizeof(struct ip6_hdr);
d157 5
a161 6
	    /* Bring the network header in the first mbuf */
	    if (m->m_len < i)
	    {
		if ((m = m_pullup(m, i)) == NULL)
		  return ENOBUFS;
	    }
d164 1
a164 9
	    ip = mtod(m, struct ip *);
	    /* This is not a bridge packet, remember if we had IP_DF */
	    setdf = ntohs(ip->ip_off) & IP_DF;
#endif /* INET */

#ifdef INET6
	    ip6 = mtod(m, struct ip6_hdr *);
#endif /* INET6 */
	}
d166 5
a170 30
	/* Do the appropriate encapsulation, if necessary */
	if ((tdb->tdb_dst.sa.sa_family != af) || /* PF mismatch */
	    (tdb->tdb_flags & TDBF_TUNNELING) || /* Tunneling requested */
	    (tdb->tdb_xform->xf_type == XF_IP4) || /* ditto */
#ifdef INET
	    ((tdb->tdb_dst.sa.sa_family == AF_INET) &&
	     (tdb->tdb_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
	     (tdb->tdb_dst.sin.sin_addr.s_addr != ip->ip_dst.s_addr)) ||
#endif /* INET */
#ifdef INET6
	    ((tdb->tdb_dst.sa.sa_family == AF_INET6) &&
	     (!IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr)) &&
	     (!IN6_ARE_ADDR_EQUAL(&tdb->tdb_dst.sin6.sin6_addr,
				  &ip6->ip6_dst))) ||
#endif /* INET6 */
	    0)
	{
#ifdef INET
	    /* Fix IPv4 header checksum and length */
	    if (af == AF_INET)
	    {
		if (m->m_len < sizeof(struct ip))
		  if ((m = m_pullup(m, sizeof(struct ip))) == NULL)
		    return ENOBUFS;

		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
                ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	    }
d174 1
a174 15
	    /* Fix IPv6 header payload length */
	    if (af == AF_INET6)
	    {
		if (m->m_len < sizeof(struct ip6_hdr))
		  if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL)
		    return ENOBUFS;

		if (m->m_pkthdr.len - sizeof(*ip6) > IPV6_MAXPACKET) {
		    /* no jumbogram support */
		    m_freem(m);
		    return ENXIO;	/*?*/
		}
		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
	    }
a175 11

	    /* Encapsulate -- the last two arguments are unused */
	    error = ipip_output(m, tdb, &mp, 0, 0);
	    if ((mp == NULL) && (!error))
	      error = EFAULT;
	    if (error)
	    {
		if (mp)
		{
		    m_freem(mp);
		    mp = NULL;
d178 73
a250 12
		return error;
	    }

	    m = mp;
	    mp = NULL;

#ifdef INET
	    if (tdb->tdb_dst.sa.sa_family == AF_INET && setdf) {
	      	    ip = mtod(m, struct ip *);
		    if (m->m_len < sizeof(struct ip))
			    if ((m = m_pullup(m, sizeof(struct ip))) == NULL)
				    return ENOBUFS;
d252 4
a255 4
		    NTOHS(ip->ip_off);
		    ip->ip_off |= IP_DF;
		    HTONS(ip->ip_off);
	    }
d257 2
a258 2
	    /* Remember that we appended a tunnel header */
	    tdb->tdb_flags |= TDBF_USEDTUNNEL;
d260 12
d274 2
a275 17
	/* We may be done with this TDB */
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  return ipsp_process_done(m, tdb);
    }
    else
    {
	/*
	 * If this is just an IP-IP TDB and we're told there's already an
	 * encapsulation header, move on.
	 */
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  return ipsp_process_done(m, tdb);
    }

    /* Extract some information off the headers */
    switch (tdb->tdb_dst.sa.sa_family)
    {
d278 4
a281 4
	    ip = mtod(m, struct ip *);
	    i = ip->ip_hl << 2;
	    off = offsetof(struct ip, ip_p);
	    break;
d286 4
a289 4
	    ip6 = mtod(m, struct ip6_hdr *);
	    i = sizeof(struct ip6_hdr);
	    off = offsetof(struct ip6_hdr, ip6_nxt);
	    break;
d291 1
a291 1
    }
d293 2
a294 2
    /* Invoke the IPsec transform */
    return (*(tdb->tdb_xform->xf_output))(m, tdb, NULL, i, off);
d305 1
a305 1
    struct ip *ip;
d309 1
a309 1
    struct ip6_hdr *ip6;
d312 2
a313 2
    struct tdb_ident *tdbi;
    struct m_tag *mtag;
d315 1
a315 1
    tdb->tdb_last_used = time.tv_sec;
d317 1
a317 2
    switch (tdb->tdb_dst.sa.sa_family)
    {
d320 6
a325 7
	    /* Fix the header length, for AH processing */
	    if (tdb->tdb_dst.sa.sa_family == AF_INET)
	    {
		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
	    }
	    break;
d330 13
a342 11
	    /* Fix the header length, for AH processing */
	    if (tdb->tdb_dst.sa.sa_family == AF_INET6)
	    {
		if (m->m_pkthdr.len < sizeof(*ip6)) {
		    m_freem(m);
		    return ENXIO;
		}
		if (m->m_pkthdr.len - sizeof(*ip6) > IPV6_MAXPACKET) {
		    /* no jumbogram support */
		    m_freem(m);
		    return ENXIO;	/*?*/
d344 1
a344 5

		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
	    }
	    break;
d348 43
a390 43
	    m_freem(m);
	    DPRINTF(("ipsp_process_done(): unknown protocol family (%d)\n",
		     tdb->tdb_dst.sa.sa_family));
	    return ENXIO;
    }

    /*
     * Add a record of what we've done or what needs to be done to the
     * packet.
     */
    if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
      mtag = m_tag_get(PACKET_TAG_IPSEC_OUT_DONE, sizeof(struct tdb_ident),
		       M_NOWAIT);
    else
      mtag = m_tag_get(PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED,
		       sizeof(struct tdb_ident), M_NOWAIT);

    if (mtag == NULL)
    {
	m_freem(m);
	DPRINTF(("ipsp_process_done(): could not allocate packet tag\n"));
	return ENOMEM;
    }

    tdbi = (struct tdb_ident *)(mtag + 1);
    bcopy(&tdb->tdb_dst, &tdbi->dst, sizeof(union sockaddr_union));
    tdbi->proto = tdb->tdb_sproto;
    tdbi->spi = tdb->tdb_spi;

    m_tag_prepend(m, mtag);

    /* If there's another (bundled) TDB to apply, do so */
    if (tdb->tdb_onext)
      return ipsp_process_packet(m, tdb->tdb_onext, tdb->tdb_dst.sa.sa_family,
				 0);

    /*
     * We're done with IPsec processing, transmit the packet using the
     * appropriate network protocol (IP or IPv6). SPD lookup will be
     * performed again there.
     */
    switch (tdb->tdb_dst.sa.sa_family)
    {
d393 2
a394 2
	    NTOHS(ip->ip_len);
	    NTOHS(ip->ip_off);
d396 1
a396 1
	    return ip_output(m, NULL, NULL, IP_RAWOUTPUT, NULL, NULL);
d401 5
a405 5
	    /*
	     * We don't need massage, IPv6 header fields are always in
	     * net endian
	     */
	    return ip6_output(m, NULL, NULL, 0, NULL, NULL);
d407 2
a408 4
    }

    /* Not reached */
    return EINVAL;
@


1.15
log
@path mtu discovery for ipsec.  on receiving a need fragment icmp match
against active tdb and store the ipsec header size corrected mtu
@
text
@d1 1
a1 2
/*	$OpenBSD: ipsec_output.c,v 1.14 2001/06/08 03:13:15 angelos Exp $ */

d5 1
a5 1
 * Copyright (c) 2000 Angelos D. Keromytis.
d7 1
a7 1
 * Permission to use, copy, and modify this software without fee
@


1.14
log
@Trim include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.13 2001/05/30 12:29:04 angelos Exp $ */
d51 1
d71 1
d164 2
d240 16
d414 86
@


1.13
log
@Update to match prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.12 2001/05/29 01:19:37 angelos Exp $ */
a25 1
#include <sys/malloc.h>
a27 1
#include <sys/errno.h>
@


1.12
log
@Record last use time for SAs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.11 2001/05/28 05:30:29 angelos Exp $ */
d66 1
a66 2
ipsp_process_packet(struct mbuf *m, struct tdb *tdb, int af, int tunalready,
		    struct tdb *tdb2)
d222 1
a222 1
	    error = ipip_output(m, tdb, &mp, 0, 0, NULL);
d242 1
a242 1
	  return ipsp_process_done(m, tdb, tdb2);
d251 1
a251 1
	  return ipsp_process_done(m, tdb, tdb2);
d275 1
a275 1
    return (*(tdb->tdb_xform->xf_output))(m, tdb, NULL, i, off, tdb2);
d283 1
a283 1
ipsp_process_done(struct mbuf *m, struct tdb *tdb, struct tdb *tdb2)
d367 1
a367 5
				 0, tdb2);

    /* Otherwise, if there's a secondary TDB to apply, do so */
    if (tdb2)
      return ipsp_process_packet(m, tdb2, tdb->tdb_dst.sa.sa_family, 0, NULL);
@


1.11
log
@Don't use IPV6_ENCAPSULATED, tags are used instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.10 2001/05/27 00:39:43 angelos Exp $ */
d296 2
@


1.10
log
@New tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.9 2001/05/22 23:38:34 angelos Exp $ */
d393 1
a393 1
	    return ip6_output(m, NULL, NULL, IPV6_ENCAPSULATED, NULL, NULL);
@


1.9
log
@Add an IPSEC_NEEDED tag if SKIPCRYPTO is set in the TDB
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.8 2001/05/20 08:34:27 angelos Exp $ */
d343 1
a343 1
      mtag = m_tag_get(PACKET_TAG_IPSEC_DONE, sizeof(struct tdb_ident),
d346 2
a347 2
      mtag = m_tag_get(PACKET_TAG_IPSEC_NEEDED, sizeof(struct tdb_ident),
		       M_NOWAIT);
@


1.8
log
@Record outgoing SA processing, do loop detection.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.7 2001/05/11 17:20:11 aaron Exp $ */
d338 11
a348 3
    /* Add a record of what we've done to the packet */
    mtag = m_tag_get(PACKET_TAG_IPSEC_DONE, sizeof(struct tdb_ident),
		     M_NOWAIT);
d355 1
@


1.7
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.6 2001/04/14 00:30:59 angelos Exp $ */
d294 3
d338 16
d375 1
a375 2
	    return ip_output(m, NULL, NULL, IP_ENCAPSULATED | IP_RAWOUTPUT,
			     NULL, NULL);
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d159 1
a159 1
		if ((m = m_pullup(m, i)) == 0)
d194 1
a194 1
		  if ((m = m_pullup(m, sizeof(struct ip))) == 0)
d209 1
a209 1
		  if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0)
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$ */
d6 1
a6 1
 * Copyright (c) 2000-2001 Angelos D. Keromytis.
d8 1
a8 1
 * Permission to use, copy, and modify this software with or without fee
d26 1
d29 1
a52 1
#include <crypto/xform.h>
d66 2
a67 1
ipsp_process_packet(struct mbuf *m, struct tdb *tdb, int af, int tunalready)
d69 2
a70 2
	int i, off, error;
	struct mbuf *mp;
d73 1
a73 2
	int setdf = 0;
	struct ip *ip;
d76 1
a76 1
	struct ip6_hdr *ip6;
d79 28
a106 27
	/* Check that the transform is allowed by the administrator. */
	if ((tdb->tdb_sproto == IPPROTO_ESP && !esp_enable) ||
	    (tdb->tdb_sproto == IPPROTO_AH && !ah_enable)) {
		DPRINTF(("ipsp_process_packet(): IPSec outbound packet "
		    "dropped due to policy (check your sysctls)\n"));
		m_freem(m);
		return EHOSTUNREACH;
	}

	/* Sanity check. */
	if (!tdb->tdb_xform) {
		DPRINTF(("ipsp_process_packet(): uninitialized TDB\n"));
		m_freem(m);
		return EHOSTUNREACH;
	}

	/* Check if the SPI is invalid. */
	if (tdb->tdb_flags & TDBF_INVALID) {
		DPRINTF(("ipsp_process_packet(): attempt to use invalid "
		    "SA %s/%08x/%u\n", ipsp_address(tdb->tdb_dst),
		    ntohl(tdb->tdb_spi), tdb->tdb_sproto));
		m_freem(m);
		return ENXIO;
	}

	/* Check that the network protocol is supported */
	switch (tdb->tdb_dst.sa.sa_family) {
d109 1
a109 1
		break;
d114 1
a114 1
		break;
d118 22
a139 8
		DPRINTF(("ipsp_process_packet(): attempt to use "
		    "SA %s/%08x/%u for protocol family %d\n",
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi),
		    tdb->tdb_sproto, tdb->tdb_dst.sa.sa_family));
		m_freem(m);
		return ENXIO;
	}

d141 2
a142 1
	 * Register first use if applicable, setup relevant expiration timer.
d144 18
a161 9
	if (tdb->tdb_first_use == 0) {
		tdb->tdb_first_use = time.tv_sec;
		if (tdb->tdb_flags & TDBF_FIRSTUSE)
			timeout_add(&tdb->tdb_first_tmo,
			    hz * tdb->tdb_exp_first_use);
		if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
			timeout_add(&tdb->tdb_sfirst_tmo,
			    hz * tdb->tdb_soft_first_use);
	}
a162 11
	/*
	 * Check for tunneling if we don't have the first header in place.
	 * When doing Ethernet-over-IP, we are handed an already-encapsulated
	 * frame, so we don't need to re-encapsulate.
	 */
	if (tunalready == 0) {
		/*
		 * If the target protocol family is different, we know we'll be
		 * doing tunneling.
		 */
		if (af == tdb->tdb_dst.sa.sa_family) {
d164 1
a164 2
			if (af == AF_INET)
				i = sizeof(struct ip);
d168 1
a168 2
			if (af == AF_INET6)
				i = sizeof(struct ip6_hdr);
d170 1
d172 17
a188 6
			/* Bring the network header in the first mbuf. */
			if (m->m_len < i) {
				if ((m = m_pullup(m, i)) == NULL)
					return ENOBUFS;
			}

d190 6
a195 1
			ip = mtod(m, struct ip *);
d197 5
a201 5
			/*
			 * This is not a bridge packet, remember if we
			 * had IP_DF.
			 */
			setdf = ntohs(ip->ip_off) & IP_DF;
d205 15
a219 1
			ip6 = mtod(m, struct ip6_hdr *);
d221 11
d234 2
a235 78
		/* Do the appropriate encapsulation, if necessary. */
		if ((tdb->tdb_dst.sa.sa_family != af) || /* PF mismatch */
		    (tdb->tdb_flags & TDBF_TUNNELING) || /* Tunneling needed */
		    (tdb->tdb_xform->xf_type == XF_IP4) || /* ditto */
#ifdef INET
		    ((tdb->tdb_dst.sa.sa_family == AF_INET) &&
			(tdb->tdb_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
			(tdb->tdb_dst.sin.sin_addr.s_addr != ip->ip_dst.s_addr)) ||
#endif /* INET */
#ifdef INET6
		    ((tdb->tdb_dst.sa.sa_family == AF_INET6) &&
			(!IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr)) &&
			(!IN6_ARE_ADDR_EQUAL(&tdb->tdb_dst.sin6.sin6_addr,
			    &ip6->ip6_dst))) ||
#endif /* INET6 */
		    0) {
#ifdef INET
			/* Fix IPv4 header checksum and length. */
			if (af == AF_INET) {
				if (m->m_len < sizeof(struct ip))
					if ((m = m_pullup(m,
					    sizeof(struct ip))) == NULL)
						return ENOBUFS;

				ip = mtod(m, struct ip *);
				ip->ip_len = htons(m->m_pkthdr.len);
				ip->ip_sum = 0;
				ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
			}
#endif /* INET */

#ifdef INET6
			/* Fix IPv6 header payload length. */
			if (af == AF_INET6) {
				if (m->m_len < sizeof(struct ip6_hdr))
					if ((m = m_pullup(m,
					    sizeof(struct ip6_hdr))) == NULL)
						return ENOBUFS;

				if (m->m_pkthdr.len - sizeof(*ip6) >
				    IPV6_MAXPACKET) {
					/* No jumbogram support. */
					m_freem(m);
					return ENXIO;	/*?*/
				}
				ip6 = mtod(m, struct ip6_hdr *);
				ip6->ip6_plen = htons(m->m_pkthdr.len 
				    - sizeof(*ip6));
			}
#endif /* INET6 */

			/* Encapsulate -- the last two arguments are unused. */
			error = ipip_output(m, tdb, &mp, 0, 0);
			if ((mp == NULL) && (!error))
				error = EFAULT;
			if (error) {
				if (mp)	{
					m_freem(mp);
					mp = NULL;
				}
				return error;
			}

			m = mp;
			mp = NULL;

#ifdef INET
			if (tdb->tdb_dst.sa.sa_family == AF_INET && setdf) {
				ip = mtod(m, struct ip *);
				if (m->m_len < sizeof(struct ip))
					if ((m = m_pullup(m,
					    sizeof(struct ip))) == NULL)
						return ENOBUFS;
		    
				NTOHS(ip->ip_off);
				ip->ip_off |= IP_DF;
				HTONS(ip->ip_off);
			}
d237 2
a238 15
			/* Remember that we appended a tunnel header. */
			tdb->tdb_flags |= TDBF_USEDTUNNEL;
#endif
		}

		/* We may be done with this TDB */
		if (tdb->tdb_xform->xf_type == XF_IP4)
			return ipsp_process_done(m, tdb);
	} else {
		/*
		 * If this is just an IP-IP TDB and we're told there's
		 * already an encapsulation header, move on.
		 */
		if (tdb->tdb_xform->xf_type == XF_IP4)
			return ipsp_process_done(m, tdb);
d241 17
a257 2
	/* Extract some information off the headers. */
	switch (tdb->tdb_dst.sa.sa_family) {
d260 4
a263 4
		ip = mtod(m, struct ip *);
		i = ip->ip_hl << 2;
		off = offsetof(struct ip, ip_p);
		break;
d268 4
a271 4
		ip6 = mtod(m, struct ip6_hdr *);
		i = sizeof(struct ip6_hdr);
		off = offsetof(struct ip6_hdr, ip6_nxt);
		break;
d273 1
a273 1
	}
d275 2
a276 2
	/* Invoke the IPsec transform. */
	return (*(tdb->tdb_xform->xf_output))(m, tdb, NULL, i, off);
d284 1
a284 1
ipsp_process_done(struct mbuf *m, struct tdb *tdb)
d287 1
a287 1
	struct ip *ip;
d291 1
a291 1
	struct ip6_hdr *ip6;
d294 2
a295 6
	struct tdb_ident *tdbi;
	struct m_tag *mtag;

	tdb->tdb_last_used = time.tv_sec;

	switch (tdb->tdb_dst.sa.sa_family) {
d298 7
a304 6
		/* Fix the header length, for AH processing. */
		if (tdb->tdb_dst.sa.sa_family == AF_INET) {
			ip = mtod(m, struct ip *);
			ip->ip_len = htons(m->m_pkthdr.len);
		}
		break;
d309 6
a314 13
		/* Fix the header length, for AH processing. */
		if (tdb->tdb_dst.sa.sa_family == AF_INET6) {
			if (m->m_pkthdr.len < sizeof(*ip6)) {
				m_freem(m);
				return ENXIO;
			}
			if (m->m_pkthdr.len - sizeof(*ip6) > IPV6_MAXPACKET) {
				/* No jumbogram support. */
				m_freem(m);
				return ENXIO;	/*?*/
			}
			ip6 = mtod(m, struct ip6_hdr *);
			ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
d316 10
a325 1
		break;
d329 22
a350 43
		m_freem(m);
		DPRINTF(("ipsp_process_done(): unknown protocol family (%d)\n",
		    tdb->tdb_dst.sa.sa_family));
		return ENXIO;
	}

	/*
	 * Add a record of what we've done or what needs to be done to the
	 * packet.
	 */
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		mtag = m_tag_get(PACKET_TAG_IPSEC_OUT_DONE,
		    sizeof(struct tdb_ident),
		    M_NOWAIT);
	else
		mtag = m_tag_get(PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED,
		    sizeof(struct tdb_ident), M_NOWAIT);

	if (mtag == NULL) {
		m_freem(m);
		DPRINTF(("ipsp_process_done(): could not allocate packet "
		    "tag\n"));
		return ENOMEM;
	}

	tdbi = (struct tdb_ident *)(mtag + 1);
	bcopy(&tdb->tdb_dst, &tdbi->dst, sizeof(union sockaddr_union));
	tdbi->proto = tdb->tdb_sproto;
	tdbi->spi = tdb->tdb_spi;

	m_tag_prepend(m, mtag);

	/* If there's another (bundled) TDB to apply, do so. */
	if (tdb->tdb_onext)
		return ipsp_process_packet(m, tdb->tdb_onext,
		    tdb->tdb_dst.sa.sa_family, 0);

	/*
	 * We're done with IPsec processing, transmit the packet using the
	 * appropriate network protocol (IP or IPv6). SPD lookup will be
	 * performed again there.
	 */
	switch (tdb->tdb_dst.sa.sa_family) {
d353 2
a354 2
		NTOHS(ip->ip_len);
		NTOHS(ip->ip_off);
d356 2
a357 1
		return ip_output(m, NULL, NULL, IP_RAWOUTPUT, NULL, NULL);
d362 5
a366 5
		/*
		 * We don't need massage, IPv6 header fields are always in
		 * net endian.
		 */
		return ip6_output(m, NULL, NULL, 0, NULL, NULL);
d368 1
a368 86
	}
	return EINVAL; /* Not reached. */
}

ssize_t
ipsec_hdrsz(struct tdb *tdbp)
{
	ssize_t adjust;

	switch (tdbp->tdb_sproto) {
	case IPPROTO_ESP:
		if (tdbp->tdb_encalgxform == NULL)
			return (-1);

		/* Header length */
		if (tdbp->tdb_flags & TDBF_NOREPLAY)
			adjust = sizeof(u_int32_t) + tdbp->tdb_ivlen;
		else
			adjust = 2 * sizeof(u_int32_t) + tdbp->tdb_ivlen;
		/* Authenticator */
		if (tdbp->tdb_authalgxform != NULL) 
			adjust += AH_HMAC_HASHLEN;
		/* Padding */
		adjust += tdbp->tdb_encalgxform->blocksize;
		break;

	case IPPROTO_AH:
		if (tdbp->tdb_authalgxform == NULL)
			return (-1);

		if (!(tdbp->tdb_flags & TDBF_NOREPLAY))
			adjust = AH_FLENGTH + sizeof(u_int32_t);
		else
			adjust = AH_FLENGTH;
		adjust += tdbp->tdb_authalgxform->authsize;
		break;

	default:
		return (-1);
	}

	if (!(tdbp->tdb_flags & TDBF_TUNNELING) &&
	    !(tdbp->tdb_flags & TDBF_USEDTUNNEL))
		return (adjust);

	switch (tdbp->tdb_dst.sa.sa_family) {
#ifdef INET
	case AF_INET:
		adjust += sizeof(struct ip);
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		adjust += sizeof(struct ip6_hdr);
		break;
#endif /* INET6 */
	}

	return (adjust);
}

void
ipsec_adjust_mtu(struct mbuf *m, u_int32_t mtu)
{
	struct tdb_ident *tdbi;
	struct tdb *tdbp;
	struct m_tag *mtag;
	ssize_t adjust;
	int s;

	s = spltdb();
	
	for (mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_DONE, NULL); mtag;
	     mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_DONE, mtag)) {
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdbp = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
		if (tdbp == NULL)
			break;

		if ((adjust = ipsec_hdrsz(tdbp)) == -1)
			break;

		mtu -= adjust;
		tdbp->tdb_mtu = mtu;
		tdbp->tdb_mtutimeout = time.tv_sec + ip_mtudisc_timeout;
	}
d370 2
a371 1
	splx(s);
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.7.2.2 2001/07/04 10:55:02 niklas Exp $ */
a49 1
#include <netinet/ip_ipcomp.h>
d79 1
a79 2
	    (tdb->tdb_sproto == IPPROTO_AH && !ah_enable) ||
	    (tdb->tdb_sproto == IPPROTO_IPCOMP && !ipcomp_enable)) {
a290 8
	}

	/* Non expansion policy for IPCOMP */
	if (tdb->tdb_sproto == IPPROTO_IPCOMP) {
		if ((m->m_pkthdr.len - i) < tdb->tdb_compalgxform->minlen) {
			/* No need to compress, leave the packet untouched */
			return ipsp_process_done(m, tdb);
		}
@


1.7.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a66 1
	struct timeval tv;
d82 1
a82 1
		DPRINTF(("ipsp_process_packet(): IPsec outbound packet "
a128 3
		int pri;

		pri = splhigh();
a129 5
		splx(pri);

		tv.tv_usec = 0;

		tv.tv_sec = tdb->tdb_first_use + tdb->tdb_exp_first_use;
d132 1
a132 3
			    hzto(&tv));

		tv.tv_sec = tdb->tdb_first_use + tdb->tdb_soft_first_use;
d135 1
a135 1
			    hzto(&tv));
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d237 1
a237 1
				ip6->ip6_plen = htons(m->m_pkthdr.len
d259 1
d264 1
a264 2

				ip = mtod(m, struct ip *);
a308 2
			extern struct ipcompstat ipcompstat;

a309 1
			ipcompstat.ipcomps_minlen++;
d342 4
a345 2
		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
d352 12
a363 8
		if (m->m_pkthdr.len < sizeof(*ip6)) {
			m_freem(m);
			return ENXIO;
		}
		if (m->m_pkthdr.len - sizeof(*ip6) > IPV6_MAXPACKET) {
			/* No jumbogram support. */
			m_freem(m);
			return ENXIO;
a364 2
		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
d417 1
a417 1
		return ip_output(m, (void *)NULL, (void *)NULL, IP_RAWOUTPUT, (void *)NULL, (void *)NULL);
d448 1
a448 1
		if (tdbp->tdb_authalgxform != NULL)
d499 1
a499 1

@


1.7.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a46 1
#include <netinet/udp.h>
a58 3
int	udpencap_enable = 0;	/* disabled by default */
int	udpencap_port = 4500;	/* triggers decapsulation */

d183 1
a183 1
			setdf = ip->ip_off & htons(IP_DF);
d265 3
a267 1
				ip->ip_off |= htons(IP_DF);
a340 21
	if (udpencap_enable && udpencap_port &&
	    (tdb->tdb_flags & TDBF_UDPENCAP) != 0) {
		struct mbuf *mi;
		struct udphdr *uh;

		mi = m_inject(m, sizeof(struct ip), sizeof(struct udphdr),
		    M_DONTWAIT);
		if (mi == NULL) {
			m_freem(m);
			return ENOMEM;
		}
		uh = mtod(mi, struct udphdr *);
		uh->uh_sport = uh->uh_dport = htons(udpencap_port);
		if (tdb->tdb_udpencap_port)
			uh->uh_dport = tdb->tdb_udpencap_port;

		uh->uh_ulen = htons(m->m_pkthdr.len - sizeof(struct ip));
		uh->uh_sum = 0;
		espstat.esps_udpencout++;
	}

a346 2
		if ((tdb->tdb_flags & TDBF_UDPENCAP) != 0)
			ip->ip_p = IPPROTO_UDP;
a363 2
		if ((tdb->tdb_flags & TDBF_UDPENCAP) != 0)
			ip6->ip6_nxt = IPPROTO_UDP;
d413 3
@


1.6
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.5 2001/04/06 04:42:08 csapuntz Exp $ */
d159 1
a159 1
		if ((m = m_pullup(m, i)) == 0)
d194 1
a194 1
		  if ((m = m_pullup(m, sizeof(struct ip))) == 0)
d209 1
a209 1
		  if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0)
@


1.5
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.4 2001/03/28 20:03:06 angelos Exp $ */
d66 2
a67 1
ipsp_process_packet(struct mbuf *m, struct tdb *tdb, int af, int tunalready)
d223 1
a223 1
	    error = ipip_output(m, tdb, &mp, 0, 0);
d243 1
a243 1
	  return ipsp_process_done(m, tdb);
d252 1
a252 1
	  return ipsp_process_done(m, tdb);
d276 1
a276 1
    return (*(tdb->tdb_xform->xf_output))(m, tdb, NULL, i, off);
d284 1
a284 1
ipsp_process_done(struct mbuf *m, struct tdb *tdb)
d337 6
a342 2
      return ipsp_process_packet(m, tdb->tdb_onext,
				 tdb->tdb_onext->tdb_dst.sa.sa_family, 0);
@


1.4
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.3 2001/03/15 06:31:00 mickey Exp $ */
a57 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.3
log
@convert SA expirations to the new timeouts.
simplifies expirations handling a lot.
tdb_exp_timeout and tdb_soft_timeout are made
consistant throughout the code to be a relative time offsets,
just like first_use timeouts.
tested on singlehost isakmpd setup.
lots of dangling spaces and tabs removed.
angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.2 2000/09/19 08:38:59 angelos Exp $ */
d196 3
a198 2
		if ((m = m_pullup(m, sizeof(struct ip))) == 0)
		  return ENOBUFS;
d211 2
a212 1
		if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0)
@


1.2
log
@SA bundles.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_output.c,v 1.1 2000/09/19 03:20:59 angelos Exp $ */
d11 1
a11 1
 * modification of this software. 
d130 4
a133 1
	tdb_expiration(tdb, TDBEXP_TIMEOUT);
@


1.1
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d332 5
@

