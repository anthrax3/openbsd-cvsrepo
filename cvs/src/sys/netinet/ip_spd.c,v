head	1.91;
access;
symbols
	OPENBSD_6_1:1.91.0.2
	OPENBSD_6_1_BASE:1.91
	OPENBSD_6_0:1.88.0.6
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.88.0.2
	OPENBSD_5_9_BASE:1.88
	OPENBSD_5_8:1.86.0.4
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.72.0.4
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.64.0.4
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.64.0.2
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.6
	OPENBSD_5_0:1.63.0.4
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.60.0.2
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.59.0.6
	OPENBSD_4_6_BASE:1.59
	OPENBSD_4_5:1.59.0.2
	OPENBSD_4_5_BASE:1.59
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.54.0.2
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.53.0.4
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.53.0.2
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.51.0.6
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.51.0.4
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.51.0.2
	OPENBSD_3_7_BASE:1.51
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	SMP_SYNC_A:1.48
	SMP_SYNC_B:1.48
	OPENBSD_3_5:1.47.0.6
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.47.0.4
	OPENBSD_3_4_BASE:1.47
	UBC_SYNC_A:1.47
	OPENBSD_3_3:1.47.0.2
	OPENBSD_3_3_BASE:1.47
	OPENBSD_3_2:1.46.0.2
	OPENBSD_3_2_BASE:1.46
	OPENBSD_3_1:1.44.0.2
	OPENBSD_3_1_BASE:1.44
	UBC_SYNC_B:1.46
	UBC:1.40.0.4
	UBC_BASE:1.40
	OPENBSD_3_0:1.40.0.2
	OPENBSD_3_0_BASE:1.40
	SMP:1.19.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.91
date	2016.09.27.12.32.26;	author fcambus;	state Exp;
branches;
next	1.90;
commitid	n9yNr5Kq5yeJnW1O;

1.90
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.89;
commitid	RlO92XR575sygHqm;

1.89
date	2016.09.06.00.04.15;	author dlg;	state Exp;
branches;
next	1.88;
commitid	UqrCCAsrdk9XuY5o;

1.88
date	2015.10.07.10.50.35;	author mpi;	state Exp;
branches;
next	1.87;
commitid	hPrd2a6fiZdlN2yP;

1.87
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.86;
commitid	PcRGyy4jlpJbKkXz;

1.86
date	2015.07.17.18.31.08;	author blambert;	state Exp;
branches;
next	1.85;
commitid	WEUQfMsVq6mbe3cF;

1.85
date	2015.05.23.12.38.53;	author markus;	state Exp;
branches;
next	1.84;
commitid	Mgx7ewWJ5ueyVCxt;

1.84
date	2015.04.30.20.12.33;	author millert;	state Exp;
branches;
next	1.83;
commitid	F8Q32G10IHXDh2HD;

1.83
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.82;
commitid	2c41FFL8044mZVko;

1.82
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.81;
commitid	bQi1IVHgugweH5gs;

1.81
date	2015.04.13.16.50.43;	author mikeb;	state Exp;
branches;
next	1.80;
commitid	fp2esFha19oHvzH7;

1.80
date	2015.04.13.16.48.01;	author mikeb;	state Exp;
branches;
next	1.79;
commitid	oA7CWTJPEeh3MwNg;

1.79
date	2015.04.13.16.45.52;	author mikeb;	state Exp;
branches;
next	1.78;
commitid	3C62OTk3mwJg0NNx;

1.78
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.77;
commitid	p4LJxGKbi0BU2cG6;

1.77
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.76;
commitid	zhW8jJrfVCoAthrR;

1.76
date	2014.11.25.13.10.03;	author mpi;	state Exp;
branches;
next	1.75;
commitid	NGBbDDWXFXkKytPH;

1.75
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.74;
commitid	w0MRp28dmfD1ZzO8;

1.74
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.73;
commitid	6AYfDT0Lpez1LFQp;

1.73
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.72;
commitid	HQcmytntiCJTHORs;

1.72
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.71;
commitid	DQakU8LLWV6Iwx84;

1.71
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.70;

1.70
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.68;

1.68
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2013.05.14.14.29.08;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.11.12.06.25;	author mpi;	state Exp;
branches;
next	1.65;

1.65
date	2013.03.28.23.10.06;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.28.01.44.57;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.02.03.58.48;	author david;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.15.18.20.23;	author chl;	state Exp;
branches;
next	1.59;

1.59
date	2009.01.27.22.40.10;	author bluhm;	state Exp;
branches;
next	1.58;

1.58
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.57;

1.57
date	2008.07.22.09.26.39;	author bluhm;	state Exp;
branches;
next	1.56;

1.56
date	2008.06.11.18.20.54;	author blambert;	state Exp;
branches;
next	1.55;

1.55
date	2008.05.09.15.48.59;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.01.18.49.28;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.17.18.07.36;	author jfb;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.21.20.44.54;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.14.20.10.04;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2002.11.12.13.38.41;	author dhartmei;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2002.05.31.02.42.22;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.18.04.46.29;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.23.01.33.07;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.23.00.39.48;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2002.01.02.20.35.40;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.24.16.22.08;	author angelos;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	2001.08.21.06.48.55;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.15.09.50.12;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.06.18.46.16;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.27.05.35.51;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.27.04.44.03;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.27.04.41.32;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.27.01.34.07;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.26.23.30.59;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.26.19.57.49;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.26.19.49.29;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.26.19.01.27;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.26.18.56.30;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.26.18.34.40;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.26.03.52.42;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.25.05.11.59;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.24.21.50.51;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.08.03.13.14;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.07.16.19.47;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.30.12.22.15;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.30.10.59.03;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.05.00.31.20;	author angelos;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.04.23.10.00.09;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.14.00.30.59;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.10.21.52.38;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.28.20.03.06;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.15.22.43.03;	author bjc;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.28.08.24.53;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.28.05.27.37;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.28.04.16.57;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.14.18.33.32;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.14.05.13.10;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.17.04.16.19;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.18.20.35.21;	author chris;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.10.14.06.23.52;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.29.19.46.26;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.27.07.28.24;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.20.19.13.18;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.19.03.20.59;	author angelos;	state Exp;
branches;
next	;

1.6.2.1
date	2000.12.14.05.37.46;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.12.14.18.53.45;	author jason;	state Exp;
branches;
next	;

1.19.2.1
date	2001.05.14.22.40.13;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.07.04.10.54.58;	author niklas;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.40.4.1
date	2002.01.31.22.55.45;	author niklas;	state Exp;
branches;
next	1.40.4.2;

1.40.4.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.40.4.3;

1.40.4.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.40.4.4;

1.40.4.4
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;

1.46.2.1
date	2003.03.14.04.48.07;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.91
log
@Remove empty #ifdef and #ifndef blocks

OK natano@@
@
text
@/* $OpenBSD: ip_spd.c,v 1.90 2016/09/15 02:00:18 dlg Exp $ */
/*
 * The author of this code is Angelos D. Keromytis (angelos@@cis.upenn.edu)
 *
 * Copyright (c) 2000-2001 Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/kernel.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/pool.h>
#include <sys/timeout.h>

#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_ipsp.h>
#include <net/pfkeyv2.h>

int	ipsp_acquire_sa(struct ipsec_policy *, union sockaddr_union *,
	    union sockaddr_union *, struct sockaddr_encap *, struct mbuf *);
struct	ipsec_acquire *ipsp_pending_acquire(struct ipsec_policy *,
	    union sockaddr_union *);
void	ipsp_delete_acquire(void *);

#ifdef ENCDEBUG
#define	DPRINTF(x)	if (encdebug) printf x
#else
#define	DPRINTF(x)
#endif

struct pool ipsec_policy_pool;
struct pool ipsec_acquire_pool;
int ipsec_policy_pool_initialized = 0;
int ipsec_acquire_pool_initialized = 0;

struct radix_node_head **spd_tables;
unsigned int spd_table_max;

struct radix_node_head *
spd_table_get(unsigned int rtableid)
{
	unsigned int rdomain;

	if (spd_tables == NULL)
		return (NULL);

	rdomain = rtable_l2(rtableid);
	if (rdomain > spd_table_max)
		return (NULL);

	return (spd_tables[rdomain]);
}

struct radix_node_head *
spd_table_add(unsigned int rtableid)
{
	struct radix_node_head *rnh = NULL;
	unsigned int rdomain;
	void *p;

	rdomain = rtable_l2(rtableid);
	if (spd_tables == NULL || rdomain > spd_table_max) {
		if ((p = mallocarray(rdomain + 1, sizeof(*rnh),
		    M_RTABLE, M_NOWAIT|M_ZERO)) == NULL)
			return (NULL);

		if (spd_tables != NULL) {
			bcopy(spd_tables, p, sizeof(*rnh) * (spd_table_max+1));
			free(spd_tables, M_RTABLE, 0);
		}
		spd_tables = p;
		spd_table_max = rdomain;
	}

	if (spd_tables[rdomain] == NULL) {
		if (rn_inithead((void **)&rnh,
		    offsetof(struct sockaddr_encap, sen_type)) == 0)
			rnh = NULL;
		spd_tables[rdomain] = rnh;
	}

	return (spd_tables[rdomain]);
}

/*
 * Lookup at the SPD based on the headers contained on the mbuf. The second
 * argument indicates what protocol family the header at the beginning of
 * the mbuf is. hlen is the offset of the transport protocol header
 * in the mbuf.
 *
 * Return combinations (of return value and in *error):
 * - NULL/0 -> no IPsec required on packet
 * - NULL/-EINVAL -> silently drop the packet
 * - NULL/errno -> drop packet and return error
 * or a pointer to a TDB (and 0 in *error).
 *
 * In the case of incoming flows, only the first three combinations are
 * returned.
 */
struct tdb *
ipsp_spd_lookup(struct mbuf *m, int af, int hlen, int *error, int direction,
    struct tdb *tdbp, struct inpcb *inp, u_int32_t ipsecflowinfo)
{
	struct radix_node_head *rnh;
	struct radix_node *rn;
	union sockaddr_union sdst, ssrc;
	struct sockaddr_encap *ddst, dst;
	struct ipsec_policy *ipo;
	struct ipsec_ids *ids = NULL;
	int signore = 0, dignore = 0;
	u_int rdomain = rtable_l2(m->m_pkthdr.ph_rtableid);

	/*
	 * If there are no flows in place, there's no point
	 * continuing with the SPD lookup.
	 */
	if (!ipsec_in_use && inp == NULL) {
		*error = 0;
		return NULL;
	}

	/*
	 * If an input packet is destined to a BYPASS socket, just accept it.
	 */
	if ((inp != NULL) && (direction == IPSP_DIRECTION_IN) &&
	    (inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS) &&
	    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS) &&
	    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS)) {
		*error = 0;
		return NULL;
	}

	memset(&dst, 0, sizeof(dst));
	memset(&sdst, 0, sizeof(union sockaddr_union));
	memset(&ssrc, 0, sizeof(union sockaddr_union));
	ddst = (struct sockaddr_encap *)&dst;
	ddst->sen_family = PF_KEY;
	ddst->sen_len = SENT_LEN;

	switch (af) {
	case AF_INET:
		if (hlen < sizeof (struct ip) || m->m_pkthdr.len < hlen) {
			*error = EINVAL;
			return NULL;
		}
		ddst->sen_direction = direction;
		ddst->sen_type = SENT_IP4;

		m_copydata(m, offsetof(struct ip, ip_src),
		    sizeof(struct in_addr), (caddr_t) &(ddst->sen_ip_src));
		m_copydata(m, offsetof(struct ip, ip_dst),
		    sizeof(struct in_addr), (caddr_t) &(ddst->sen_ip_dst));
		m_copydata(m, offsetof(struct ip, ip_p), sizeof(u_int8_t),
		    (caddr_t) &(ddst->sen_proto));

		sdst.sin.sin_family = ssrc.sin.sin_family = AF_INET;
		sdst.sin.sin_len = ssrc.sin.sin_len =
		    sizeof(struct sockaddr_in);
		ssrc.sin.sin_addr = ddst->sen_ip_src;
		sdst.sin.sin_addr = ddst->sen_ip_dst;

		/*
		 * If TCP/UDP, extract the port numbers to use in the lookup.
		 */
		switch (ddst->sen_proto) {
		case IPPROTO_UDP:
		case IPPROTO_TCP:
			/* Make sure there's enough data in the packet. */
			if (m->m_pkthdr.len < hlen + 2 * sizeof(u_int16_t)) {
				*error = EINVAL;
				return NULL;
			}

			/*
			 * Luckily, the offset of the src/dst ports in
			 * both the UDP and TCP headers is the same (first
			 * two 16-bit values in the respective headers),
			 * so we can just copy them.
			 */
			m_copydata(m, hlen, sizeof(u_int16_t),
			    (caddr_t) &(ddst->sen_sport));
			m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			    (caddr_t) &(ddst->sen_dport));
			break;

		default:
			ddst->sen_sport = 0;
			ddst->sen_dport = 0;
		}

		break;

#ifdef INET6
	case AF_INET6:
		if (hlen < sizeof (struct ip6_hdr) || m->m_pkthdr.len < hlen) {
			*error = EINVAL;
			return NULL;
		}
		ddst->sen_type = SENT_IP6;
		ddst->sen_ip6_direction = direction;

		m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
		    sizeof(struct in6_addr),
		    (caddr_t) &(ddst->sen_ip6_src));
		m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		    sizeof(struct in6_addr),
		    (caddr_t) &(ddst->sen_ip6_dst));
		m_copydata(m, offsetof(struct ip6_hdr, ip6_nxt),
		    sizeof(u_int8_t),
		    (caddr_t) &(ddst->sen_ip6_proto));

		sdst.sin6.sin6_family = ssrc.sin6.sin6_family = AF_INET6;
		sdst.sin6.sin6_len = ssrc.sin6.sin6_len =
		    sizeof(struct sockaddr_in6);
		in6_recoverscope(&ssrc.sin6, &ddst->sen_ip6_src);
		in6_recoverscope(&sdst.sin6, &ddst->sen_ip6_dst);

		/*
		 * If TCP/UDP, extract the port numbers to use in the lookup.
		 */
		switch (ddst->sen_ip6_proto) {
		case IPPROTO_UDP:
		case IPPROTO_TCP:
			/* Make sure there's enough data in the packet. */
			if (m->m_pkthdr.len < hlen + 2 * sizeof(u_int16_t)) {
				*error = EINVAL;
				return NULL;
			}

			/*
			 * Luckily, the offset of the src/dst ports in
			 * both the UDP and TCP headers is the same
			 * (first two 16-bit values in the respective
			 * headers), so we can just copy them.
			 */
			m_copydata(m, hlen, sizeof(u_int16_t),
			    (caddr_t) &(ddst->sen_ip6_sport));
			m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			    (caddr_t) &(ddst->sen_ip6_dport));
			break;

		default:
			ddst->sen_ip6_sport = 0;
			ddst->sen_ip6_dport = 0;
		}

		break;
#endif /* INET6 */

	default:
		*error = EAFNOSUPPORT;
		return NULL;
	}

	/* Actual SPD lookup. */
	if ((rnh = spd_table_get(rdomain)) == NULL ||
	    (rn = rn_match((caddr_t)&dst, rnh)) == NULL) {
		/*
		 * Return whatever the socket requirements are, there are no
		 * system-wide policies.
		 */
		*error = 0;
		return ipsp_spd_inp(m, af, hlen, error, direction,
		    tdbp, inp, NULL);
	}
	ipo = (struct ipsec_policy *)rn;

	switch (ipo->ipo_type) {
	case IPSP_PERMIT:
		*error = 0;
		return ipsp_spd_inp(m, af, hlen, error, direction, tdbp,
		    inp, ipo);

	case IPSP_DENY:
		*error = EHOSTUNREACH;
		return NULL;

	case IPSP_IPSEC_USE:
	case IPSP_IPSEC_ACQUIRE:
	case IPSP_IPSEC_REQUIRE:
	case IPSP_IPSEC_DONTACQ:
		/* Nothing more needed here. */
		break;

	default:
		*error = EINVAL;
		return NULL;
	}

	/* Check for non-specific destination in the policy. */
	switch (ipo->ipo_dst.sa.sa_family) {
	case AF_INET:
		if ((ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_ANY) ||
		    (ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_BROADCAST))
			dignore = 1;
		break;

#ifdef INET6
	case AF_INET6:
		if ((IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr)) ||
		    (memcmp(&ipo->ipo_dst.sin6.sin6_addr, &in6mask128,
		    sizeof(in6mask128)) == 0))
			dignore = 1;
		break;
#endif /* INET6 */
	}

	/* Likewise for source. */
	switch (ipo->ipo_src.sa.sa_family) {
	case AF_INET:
		if (ipo->ipo_src.sin.sin_addr.s_addr == INADDR_ANY)
			signore = 1;
		break;

#ifdef INET6
	case AF_INET6:
		if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_src.sin6.sin6_addr))
			signore = 1;
		break;
#endif /* INET6 */
	}

	/* Do we have a cached entry ? If so, check if it's still valid. */
	if ((ipo->ipo_tdb) && (ipo->ipo_tdb->tdb_flags & TDBF_INVALID)) {
		TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
		    ipo_tdb_next);
		ipo->ipo_tdb = NULL;
	}

	/* Outgoing packet policy check. */
	if (direction == IPSP_DIRECTION_OUT) {
		/*
		 * If the packet is destined for the policy-specified
		 * gateway/endhost, and the socket has the BYPASS
		 * option set, skip IPsec processing.
		 */
		if ((inp != NULL) &&
		    (inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS) &&
		    (inp->inp_seclevel[SL_ESP_NETWORK] ==
			IPSEC_LEVEL_BYPASS) &&
		    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS)) {
			/* Direct match. */
			if (dignore ||
			    !memcmp(&sdst, &ipo->ipo_dst, sdst.sa.sa_len)) {
				*error = 0;
				return NULL;
			}
		}

		if (ipsecflowinfo)
			ids = ipsp_ids_lookup(ipsecflowinfo);

		/* Check that the cached TDB (if present), is appropriate. */
		if (ipo->ipo_tdb) {
			if ((ipo->ipo_last_searched <= ipsec_last_added) ||
			    (ipo->ipo_sproto != ipo->ipo_tdb->tdb_sproto) ||
			    memcmp(dignore ? &sdst : &ipo->ipo_dst,
			    &ipo->ipo_tdb->tdb_dst,
			    ipo->ipo_tdb->tdb_dst.sa.sa_len))
				goto nomatchout;

			if (!ipsp_aux_match(ipo->ipo_tdb,
			    ids ? ids : ipo->ipo_ids,
			    &ipo->ipo_addr, &ipo->ipo_mask))
				goto nomatchout;

			/* Cached entry is good. */
			*error = 0;
			return ipsp_spd_inp(m, af, hlen, error, direction,
			    tdbp, inp, ipo);

  nomatchout:
			/* Cached TDB was not good. */
			TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
			    ipo_tdb_next);
			ipo->ipo_tdb = NULL;
			ipo->ipo_last_searched = 0;
		}

		/*
		 * If no SA has been added since the last time we did a
		 * lookup, there's no point searching for one. However, if the
		 * destination gateway is left unspecified (or is all-1's),
		 * always lookup since this is a generic-match rule
		 * (otherwise, we can have situations where SAs to some
		 * destinations exist but are not used, possibly leading to an
		 * explosion in the number of acquired SAs).
		 */
		if (ipo->ipo_last_searched <= ipsec_last_added)	{
			/* "Touch" the entry. */
			if (dignore == 0)
				ipo->ipo_last_searched = time_second;

			/* Find an appropriate SA from the existing ones. */
			ipo->ipo_tdb =
			    gettdbbydst(rdomain,
				dignore ? &sdst : &ipo->ipo_dst,
				ipo->ipo_sproto,
				ids ? ids: ipo->ipo_ids,
				&ipo->ipo_addr, &ipo->ipo_mask);
			if (ipo->ipo_tdb) {
				TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head,
				    ipo, ipo_tdb_next);
				*error = 0;
				return ipsp_spd_inp(m, af, hlen, error,
				    direction, tdbp, inp, ipo);
			}
		}

		/* So, we don't have an SA -- just a policy. */
		switch (ipo->ipo_type) {
		case IPSP_IPSEC_REQUIRE:
			/* Acquire SA through key management. */
			if (ipsp_acquire_sa(ipo,
			    dignore ? &sdst : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, m) != 0) {
				*error = EACCES;
				return NULL;
			}

			/* FALLTHROUGH */
		case IPSP_IPSEC_DONTACQ:
			*error = -EINVAL; /* Silently drop packet. */
			return NULL;

		case IPSP_IPSEC_ACQUIRE:
			/* Acquire SA through key management. */
			ipsp_acquire_sa(ipo, dignore ? &sdst : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, NULL);

			/* FALLTHROUGH */
		case IPSP_IPSEC_USE:
			*error = 0;
			return ipsp_spd_inp(m, af, hlen, error, direction,
			    tdbp, inp, ipo);
		}
	} else { /* IPSP_DIRECTION_IN */
		if (tdbp != NULL) {
			/* Direct match in the cache. */
			if (ipo->ipo_tdb == tdbp) {
				*error = 0;
				return ipsp_spd_inp(m, af, hlen, error,
				    direction, tdbp, inp, ipo);
			}

			if (memcmp(dignore ? &ssrc : &ipo->ipo_dst,
			    &tdbp->tdb_src, tdbp->tdb_src.sa.sa_len) ||
			    (ipo->ipo_sproto != tdbp->tdb_sproto))
				goto nomatchin;

			/* Match source/dest IDs. */
			if (ipo->ipo_ids)
				if (tdbp->tdb_ids == NULL ||
				    !ipsp_ids_match(ipo->ipo_ids, tdbp->tdb_ids))
					goto nomatchin;

			/* Add it to the cache. */
			if (ipo->ipo_tdb)
				TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head,
				    ipo, ipo_tdb_next);
			ipo->ipo_tdb = tdbp;
			TAILQ_INSERT_TAIL(&tdbp->tdb_policy_head, ipo,
			    ipo_tdb_next);
			*error = 0;
			return ipsp_spd_inp(m, af, hlen, error, direction,
			    tdbp, inp, ipo);

  nomatchin: /* Nothing needed here, falling through */
	;
		}

		/* Check whether cached entry applies. */
		if (ipo->ipo_tdb) {
			/*
			 * We only need to check that the correct
			 * security protocol and security gateway are
			 * set; IDs will be the same since the cached
			 * entry is linked on this policy.
			 */
			if (ipo->ipo_sproto == ipo->ipo_tdb->tdb_sproto &&
			    !memcmp(&ipo->ipo_tdb->tdb_src,
			    dignore ? &ssrc : &ipo->ipo_dst,
			    ipo->ipo_tdb->tdb_src.sa.sa_len))
				goto skipinputsearch;

			/* Not applicable, unlink. */
			TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
			    ipo_tdb_next);
			ipo->ipo_last_searched = 0;
			ipo->ipo_tdb = NULL;
		}

		/* Find whether there exists an appropriate SA. */
		if (ipo->ipo_last_searched <= ipsec_last_added)	{
			if (dignore == 0)
				ipo->ipo_last_searched = time_second;

			ipo->ipo_tdb =
			    gettdbbysrc(rdomain,
				dignore ? &ssrc : &ipo->ipo_dst,
				ipo->ipo_sproto, ipo->ipo_ids,
				&ipo->ipo_addr, &ipo->ipo_mask);
			if (ipo->ipo_tdb)
				TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head,
				    ipo, ipo_tdb_next);
		}
  skipinputsearch:

		switch (ipo->ipo_type) {
		case IPSP_IPSEC_REQUIRE:
			/* If appropriate SA exists, don't acquire another. */
			if (ipo->ipo_tdb) {
				*error = -EINVAL;
				return NULL;
			}

			/* Acquire SA through key management. */
			if ((*error = ipsp_acquire_sa(ipo,
			    dignore ? &ssrc : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, m)) != 0)
				return NULL;

			/* FALLTHROUGH */
		case IPSP_IPSEC_DONTACQ:
			/* Drop packet. */
			*error = -EINVAL;
			return NULL;

		case IPSP_IPSEC_ACQUIRE:
			/* If appropriate SA exists, don't acquire another. */
			if (ipo->ipo_tdb) {
				*error = 0;
				return ipsp_spd_inp(m, af, hlen, error,
				    direction, tdbp, inp, ipo);
			}

			/* Acquire SA through key management. */
			ipsp_acquire_sa(ipo, dignore ? &ssrc : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, NULL);

			/* FALLTHROUGH */
		case IPSP_IPSEC_USE:
			*error = 0;
			return ipsp_spd_inp(m, af, hlen, error, direction,
			    tdbp, inp, ipo);
		}
	}

	/* Shouldn't ever get this far. */
	*error = EINVAL;
	return NULL;
}

/*
 * Delete a policy from the SPD.
 */
int
ipsec_delete_policy(struct ipsec_policy *ipo)
{
	struct ipsec_acquire *ipa;
	struct radix_node_head *rnh;
	struct radix_node *rn = (struct radix_node *)ipo;
	int err = 0;

	if (--ipo->ipo_ref_count > 0)
		return 0;

	/* Delete from SPD. */
	if ((rnh = spd_table_get(ipo->ipo_rdomain)) == NULL ||
	    rn_delete(&ipo->ipo_addr, &ipo->ipo_mask, rnh, rn) == NULL)
		return (ESRCH);

	if (ipo->ipo_tdb != NULL)
		TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
		    ipo_tdb_next);

	while ((ipa = TAILQ_FIRST(&ipo->ipo_acquires)) != NULL)
		ipsp_delete_acquire(ipa);

	TAILQ_REMOVE(&ipsec_policy_head, ipo, ipo_list);

	if (ipo->ipo_ids)
		ipsp_ids_free(ipo->ipo_ids);

	ipsec_in_use--;

	pool_put(&ipsec_policy_pool, ipo);

	return err;
}

/*
 * Delete a pending IPsec acquire record.
 */
void
ipsp_delete_acquire(void *v)
{
	struct ipsec_acquire *ipa = v;

	timeout_del(&ipa->ipa_timeout);
	TAILQ_REMOVE(&ipsec_acquire_head, ipa, ipa_next);
	if (ipa->ipa_policy != NULL)
		TAILQ_REMOVE(&ipa->ipa_policy->ipo_acquires, ipa,
		    ipa_ipo_next);
	pool_put(&ipsec_acquire_pool, ipa);
}

/*
 * Find out if there's an ACQUIRE pending.
 * XXX Need a better structure.
 */
struct ipsec_acquire *
ipsp_pending_acquire(struct ipsec_policy *ipo, union sockaddr_union *gw)
{
	struct ipsec_acquire *ipa;

	TAILQ_FOREACH (ipa, &ipo->ipo_acquires, ipa_ipo_next) {
		if (!memcmp(gw, &ipa->ipa_addr, gw->sa.sa_len))
			return ipa;
	}

	return NULL;
}

/*
 * Signal key management that we need an SA.
 * XXX For outgoing policies, we could try to hold on to the mbuf.
 */
int
ipsp_acquire_sa(struct ipsec_policy *ipo, union sockaddr_union *gw,
    union sockaddr_union *laddr, struct sockaddr_encap *ddst, struct mbuf *m)
{
	struct ipsec_acquire *ipa;

	/* Check whether request has been made already. */
	if ((ipa = ipsp_pending_acquire(ipo, gw)) != NULL)
		return 0;

	/* Add request in cache and proceed. */
	if (ipsec_acquire_pool_initialized == 0) {
		ipsec_acquire_pool_initialized = 1;
		pool_init(&ipsec_acquire_pool, sizeof(struct ipsec_acquire),
		    0, IPL_SOFTNET, 0, "ipsec acquire", NULL);
	}

	ipa = pool_get(&ipsec_acquire_pool, PR_NOWAIT|PR_ZERO);
	if (ipa == NULL)
		return ENOMEM;

	bcopy(gw, &ipa->ipa_addr, sizeof(union sockaddr_union));

	timeout_set(&ipa->ipa_timeout, ipsp_delete_acquire, ipa);

	ipa->ipa_info.sen_len = ipa->ipa_mask.sen_len = SENT_LEN;
	ipa->ipa_info.sen_family = ipa->ipa_mask.sen_family = PF_KEY;

	/* Just copy the right information. */
	switch (ipo->ipo_addr.sen_type) {
	case SENT_IP4:
		ipa->ipa_info.sen_type = ipa->ipa_mask.sen_type = SENT_IP4;
		ipa->ipa_info.sen_direction = ipo->ipo_addr.sen_direction;
		ipa->ipa_mask.sen_direction = ipo->ipo_mask.sen_direction;

		if (ipsp_is_unspecified(ipo->ipo_dst)) {
			ipa->ipa_info.sen_ip_src = ddst->sen_ip_src;
			ipa->ipa_mask.sen_ip_src.s_addr = INADDR_BROADCAST;

			ipa->ipa_info.sen_ip_dst = ddst->sen_ip_dst;
			ipa->ipa_mask.sen_ip_dst.s_addr = INADDR_BROADCAST;
		} else {
			ipa->ipa_info.sen_ip_src = ipo->ipo_addr.sen_ip_src;
			ipa->ipa_mask.sen_ip_src = ipo->ipo_mask.sen_ip_src;

			ipa->ipa_info.sen_ip_dst = ipo->ipo_addr.sen_ip_dst;
			ipa->ipa_mask.sen_ip_dst = ipo->ipo_mask.sen_ip_dst;
		}

		ipa->ipa_info.sen_proto = ipo->ipo_addr.sen_proto;
		ipa->ipa_mask.sen_proto = ipo->ipo_mask.sen_proto;

		if (ipo->ipo_addr.sen_proto) {
			ipa->ipa_info.sen_sport = ipo->ipo_addr.sen_sport;
			ipa->ipa_mask.sen_sport = ipo->ipo_mask.sen_sport;

			ipa->ipa_info.sen_dport = ipo->ipo_addr.sen_dport;
			ipa->ipa_mask.sen_dport = ipo->ipo_mask.sen_dport;
		}
		break;

#ifdef INET6
	case SENT_IP6:
		ipa->ipa_info.sen_type = ipa->ipa_mask.sen_type = SENT_IP6;
		ipa->ipa_info.sen_ip6_direction =
		    ipo->ipo_addr.sen_ip6_direction;
		ipa->ipa_mask.sen_ip6_direction =
		    ipo->ipo_mask.sen_ip6_direction;

		if (ipsp_is_unspecified(ipo->ipo_dst)) {
			ipa->ipa_info.sen_ip6_src = ddst->sen_ip6_src;
			ipa->ipa_mask.sen_ip6_src = in6mask128;

			ipa->ipa_info.sen_ip6_dst = ddst->sen_ip6_dst;
			ipa->ipa_mask.sen_ip6_dst = in6mask128;
		} else {
			ipa->ipa_info.sen_ip6_src = ipo->ipo_addr.sen_ip6_src;
			ipa->ipa_mask.sen_ip6_src = ipo->ipo_mask.sen_ip6_src;

			ipa->ipa_info.sen_ip6_dst = ipo->ipo_addr.sen_ip6_dst;
			ipa->ipa_mask.sen_ip6_dst = ipo->ipo_mask.sen_ip6_dst;
		}

		ipa->ipa_info.sen_ip6_proto = ipo->ipo_addr.sen_ip6_proto;
		ipa->ipa_mask.sen_ip6_proto = ipo->ipo_mask.sen_ip6_proto;

		if (ipo->ipo_mask.sen_ip6_proto) {
			ipa->ipa_info.sen_ip6_sport =
			    ipo->ipo_addr.sen_ip6_sport;
			ipa->ipa_mask.sen_ip6_sport =
			    ipo->ipo_mask.sen_ip6_sport;
			ipa->ipa_info.sen_ip6_dport =
			    ipo->ipo_addr.sen_ip6_dport;
			ipa->ipa_mask.sen_ip6_dport =
			    ipo->ipo_mask.sen_ip6_dport;
		}
		break;
#endif /* INET6 */

	default:
		pool_put(&ipsec_acquire_pool, ipa);
		return 0;
	}

	timeout_add_sec(&ipa->ipa_timeout, ipsec_expire_acquire);

	TAILQ_INSERT_TAIL(&ipsec_acquire_head, ipa, ipa_next);
	TAILQ_INSERT_TAIL(&ipo->ipo_acquires, ipa, ipa_ipo_next);
	ipa->ipa_policy = ipo;

	/* PF_KEYv2 notification message. */
	return pfkeyv2_acquire(ipo, gw, laddr, &ipa->ipa_seq, ddst);
}

/*
 * Deal with PCB security requirements.
 */
struct tdb *
ipsp_spd_inp(struct mbuf *m, int af, int hlen, int *error, int direction,
    struct tdb *tdbp, struct inpcb *inp, struct ipsec_policy *ipo)
{
	/* Sanity check. */
	if (inp == NULL)
		goto justreturn;

	/* We only support IPSEC_LEVEL_BYPASS or IPSEC_LEVEL_AVAIL */

	if (inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS &&
	    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS &&
	    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS)
		goto justreturn;

	if (inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_AVAIL &&
	    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_AVAIL &&
	    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_AVAIL)
		goto justreturn;

	*error = -EINVAL;
	return NULL;

 justreturn:
	if (ipo != NULL)
		return ipo->ipo_tdb;
	else
		return NULL;
}

/*
 * Find a pending ACQUIRE record based on its sequence number.
 * XXX Need to use a better data structure.
 */
struct ipsec_acquire *
ipsec_get_acquire(u_int32_t seq)
{
	struct ipsec_acquire *ipa;

	TAILQ_FOREACH (ipa, &ipsec_acquire_head, ipa_next)
		if (ipa->ipa_seq == seq)
			return ipa;

	return NULL;
}
@


1.90
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.89 2016/09/06 00:04:15 dlg Exp $ */
a40 4

#ifdef INET6
#endif /* INET6 */

@


1.89
log
@pool_setipl for various netinet and netinet6 bits

thank you to everyone who helped reviewed these diffs

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.88 2015/10/07 10:50:35 mpi Exp $ */
d672 1
a672 2
		    0, 0, 0, "ipsec acquire", NULL);
		pool_setipl(&ipsec_acquire_pool, IPL_SOFTNET);
@


1.88
log
@Initialize the routing table before domains.

The routing table is not an optional component of the network stack
and initializing it inside the "routing domain" requires some ugly
introspection in the domain interface.

This put the rtable* layer at the same level of the if* level.  These
two subsystem are organized around the two global data structure used
in the network stack:

- the global &ifnet list, to be used in process context only, and
- the routing table which can be read in interrupt context.

This change makes the rtable_* layer domain-aware and extends the
"struct domain" such that INET, INET6 and MPLS can specify the length
of the binary key used in lookups.  This allows us to keep, or move
towards, AF-free route and rtable layers.

While here stop the madness and pass the size of the maximum key length
in *byte* to rn_inithead0().

ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.87 2015/09/10 17:52:05 claudio Exp $ */
d673 1
@


1.87
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.86 2015/07/17 18:31:08 blambert Exp $ */
a85 1
	extern struct domain pfkeydomain;
d105 2
a106 1
		if (rn_inithead((void **)&rnh, pfkeydomain.dom_rtoffset) == 0)
@


1.86
log
@manage spd entries by using the radix api directly instead of
reaching around through the routing table

original diff by myself, much improved by mikeb@@ and mpi@@

ok and testing mikeb@@ mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.85 2015/05/23 12:38:53 markus Exp $ */
d244 2
a245 2
		in6_recoverscope(&ssrc.sin6, &ddst->sen_ip6_src, NULL);
		in6_recoverscope(&sdst.sin6, &ddst->sen_ip6_dst, NULL);
@


1.85
log
@introduce ipsec-id bundles and use them for ipsecflowinfo,
fixes rekeying for l2tp/ipsec against multiple windows clients
and saves memory (for many SAs to same peers); feedback and ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.84 2015/04/30 20:12:33 millert Exp $ */
d29 1
d65 49
d133 2
a134 1
	struct rtentry *rt;
d285 2
a286 2
	rt = rtalloc((struct sockaddr *)&dst, RT_REPORT|RT_RESOLVE, rdomain);
	if (rt == NULL) {
d295 1
a295 18

	/* Sanity check. */
	if ((rt->rt_gateway == NULL) ||
	    (((struct sockaddr_encap *)rt->rt_gateway)->sen_type !=
		SENT_IPSP)) {
		rtfree(rt);
		*error = EHOSTUNREACH;
		DPRINTF(("ip_spd_lookup: no gateway in SPD entry!"));
		return NULL;
	}

	ipo = ((struct sockaddr_encap *)(rt->rt_gateway))->sen_ipsp;
	rtfree(rt);
	if (ipo == NULL) {
		*error = EHOSTUNREACH;
		DPRINTF(("ip_spd_lookup: no policy attached to SPD entry!"));
		return NULL;
	}
a588 1
	struct rt_addrinfo info;
d590 2
d598 3
a600 7
	memset(&info, 0, sizeof(info));
	info.rti_info[RTAX_DST] = (struct sockaddr *)&ipo->ipo_addr;
	info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&ipo->ipo_mask;

	/* XXX other tables? */
	err = rtrequest1(RTM_DELETE, &info, RTP_DEFAULT, NULL,
	    ipo->ipo_rdomain);
@


1.84
log
@Merge two identical if() statements in ipsp_acquire_sa().  The
change in ip_spd.c 1.59 makes it appear that there is a cut & pasto.
OK mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.83 2015/04/16 19:24:13 markus Exp $ */
d87 1
a87 2
	struct ipsec_ref *dstid = NULL, *srcid = NULL;
	struct tdb *tdbin = NULL;
d345 2
a346 11
		/*
		 * Fetch the incoming TDB based on the SPI passed
		 * in ipsecflow and use it's dstid when looking
		 * up the outgoing TDB.
		 */
		if (ipsecflowinfo &&
		   (tdbin = gettdb(rdomain, ipsecflowinfo, &ssrc,
		    ipo->ipo_sproto)) != NULL) {
			srcid = tdbin->tdb_dstid;
			dstid = tdbin->tdb_srcid;
		}
d358 1
a358 2
			    srcid ? srcid : ipo->ipo_srcid,
			    dstid ? dstid : ipo->ipo_dstid,
d394 1
a394 2
				srcid ? srcid : ipo->ipo_srcid,
				dstid ? dstid : ipo->ipo_dstid,
d446 4
a449 13
			/* Match source ID. */
			if (ipo->ipo_srcid) {
				if (tdbp->tdb_dstid == NULL ||
				    !ipsp_ref_match(ipo->ipo_srcid,
					tdbp->tdb_dstid))
					goto nomatchin;
			}

			/* Match destination ID. */
			if (ipo->ipo_dstid) {
				if (tdbp->tdb_srcid == NULL ||
				    !ipsp_ref_match(ipo->ipo_dstid,
					tdbp->tdb_srcid))
a450 1
			}
d496 2
a497 3
				ipo->ipo_sproto, ipo->ipo_srcid,
				ipo->ipo_dstid, &ipo->ipo_addr,
				&ipo->ipo_mask);
d580 2
a581 4
	if (ipo->ipo_srcid)
		ipsp_reffree(ipo->ipo_srcid);
	if (ipo->ipo_dstid)
		ipsp_reffree(ipo->ipo_dstid);
@


1.83
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.82 2015/04/14 12:22:15 mikeb Exp $ */
d690 3
a695 1
		}
a696 4
		if (ipsp_is_unspecified(ipo->ipo_dst)) {
			ipa->ipa_info.sen_ip_dst = ddst->sen_ip_dst;
			ipa->ipa_mask.sen_ip_dst.s_addr = INADDR_BROADCAST;
		} else {
d724 3
a729 1
		}
a730 4
		if (ipsp_is_unspecified(ipo->ipo_dst)) {
			ipa->ipa_info.sen_ip6_dst = ddst->sen_ip6_dst;
			ipa->ipa_mask.sen_ip6_dst = in6mask128;
		} else {
@


1.82
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.81 2015/04/13 16:50:43 mikeb Exp $ */
a48 1
void	ipsec_update_policy(struct inpcb *, struct ipsec_policy *, int, int);
d586 8
a593 9
	if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET)) {
		memset(&info, 0, sizeof(info));
		info.rti_info[RTAX_DST] = (struct sockaddr *)&ipo->ipo_addr;
		info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&ipo->ipo_mask;

		/* XXX other tables? */
		err = rtrequest1(RTM_DELETE, &info, RTP_DEFAULT, NULL,
		    ipo->ipo_rdomain);
	}
d608 1
a608 2
	if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
		ipsec_in_use--;
a615 99
 * Add a policy to the SPD.
 */
struct ipsec_policy *
ipsec_add_policy(struct inpcb *inp, int af, int direction)
{
	struct ipsec_policy *ipon;

	if (ipsec_policy_pool_initialized == 0) {
		ipsec_policy_pool_initialized = 1;
		pool_init(&ipsec_policy_pool, sizeof(struct ipsec_policy),
		    0, 0, 0, "ipsec policy", NULL);
	}

	ipon = pool_get(&ipsec_policy_pool, PR_NOWAIT|PR_ZERO);
	if (ipon == NULL)
		return NULL;

	ipon->ipo_ref_count = 1;
	ipon->ipo_flags |= IPSP_POLICY_SOCKET;

	ipon->ipo_type = IPSP_IPSEC_REQUIRE; /* XXX */

	/* XXX
	 * We should actually be creating a linked list of
	 * policies (for tunnel/transport and ESP/AH), as needed.
	 */
	ipon->ipo_sproto = IPPROTO_ESP;
	ipon->ipo_rdomain = rtable_l2(inp->inp_rtableid);

	TAILQ_INIT(&ipon->ipo_acquires);
	TAILQ_INSERT_HEAD(&ipsec_policy_head, ipon, ipo_list);

	ipsec_update_policy(inp, ipon, af, direction);

	return ipon;
}

/*
 * Update a PCB-attached policy.
 */
void
ipsec_update_policy(struct inpcb *inp, struct ipsec_policy *ipon, int af,
    int direction)
{
	ipon->ipo_addr.sen_len = ipon->ipo_mask.sen_len = SENT_LEN;
	ipon->ipo_addr.sen_family = ipon->ipo_mask.sen_family = PF_KEY;
	ipon->ipo_src.sa.sa_family = ipon->ipo_dst.sa.sa_family = af;

	switch (af) {
	case AF_INET:
		ipon->ipo_addr.sen_type = ipon->ipo_mask.sen_type = SENT_IP4;
		ipon->ipo_addr.sen_ip_src = inp->inp_laddr;
		ipon->ipo_addr.sen_ip_dst = inp->inp_faddr;
		ipon->ipo_addr.sen_sport = inp->inp_lport;
		ipon->ipo_addr.sen_dport = inp->inp_fport;
		ipon->ipo_addr.sen_proto =
		    inp->inp_socket->so_proto->pr_protocol;
		ipon->ipo_addr.sen_direction = direction;

		ipon->ipo_mask.sen_ip_src.s_addr = 0xffffffff;
		ipon->ipo_mask.sen_ip_dst.s_addr = 0xffffffff;
		ipon->ipo_mask.sen_sport = ipon->ipo_mask.sen_dport = 0xffff;
		ipon->ipo_mask.sen_proto = 0xff;
		ipon->ipo_mask.sen_direction = direction;

		ipon->ipo_src.sa.sa_len = sizeof(struct sockaddr_in);
		ipon->ipo_dst.sa.sa_len = sizeof(struct sockaddr_in);
		ipon->ipo_src.sin.sin_addr = inp->inp_laddr;
		ipon->ipo_dst.sin.sin_addr = inp->inp_faddr;
		break;

	case AF_INET6:
#ifdef INET6
		ipon->ipo_addr.sen_type = ipon->ipo_mask.sen_type = SENT_IP6;
		ipon->ipo_addr.sen_ip6_src = inp->inp_laddr6;
		ipon->ipo_addr.sen_ip6_dst = inp->inp_faddr6;
		ipon->ipo_addr.sen_ip6_sport = inp->inp_lport;
		ipon->ipo_addr.sen_ip6_dport = inp->inp_fport;
		ipon->ipo_addr.sen_ip6_proto =
		    inp->inp_socket->so_proto->pr_protocol;
		ipon->ipo_addr.sen_ip6_direction = direction;

		ipon->ipo_mask.sen_ip6_src = in6mask128;
		ipon->ipo_mask.sen_ip6_dst = in6mask128;
		ipon->ipo_mask.sen_ip6_sport = 0xffff;
		ipon->ipo_mask.sen_ip6_dport = 0xffff;
		ipon->ipo_mask.sen_ip6_proto = 0xff;
		ipon->ipo_mask.sen_ip6_direction = direction;

		ipon->ipo_src.sa.sa_len = sizeof(struct sockaddr_in6);
		ipon->ipo_dst.sa.sa_len = sizeof(struct sockaddr_in6);
		ipon->ipo_src.sin6.sin6_addr = inp->inp_laddr6;
		ipon->ipo_dst.sin6.sin6_addr = inp->inp_faddr6;
#endif /* INET6 */
		break;
	}
}

/*
a657 7
	/*
	 * ACQUIRE on local sockets is restricted to avoid abuse of
	 * authentication keys that the IKE daemon has already loaded.
	 */
	if (ipo->ipo_flags & IPSP_POLICY_SOCKET)
		return EINVAL;

a776 5
	struct ipsec_policy sipon;
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
	struct tdb *tdb = NULL;

d781 5
a785 7
	/* Verify that we need to check for socket policy. */
	if ((inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS ||
	    inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_NONE) &&
	    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS ||
	    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_NONE) &&
	    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS ||
	    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_NONE))
d788 3
a790 225
	switch (direction) {
	case IPSP_DIRECTION_IN:
		/*
		 * Some further checking: if the socket has specified
		 * that it will accept unencrypted traffic, don't
		 * bother checking any further -- just accept the packet.
		 */
		if ((inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_AVAIL ||
		    inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_USE) &&
		    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_AVAIL ||
		    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_USE) &&
		    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_AVAIL ||
		    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_USE))
			goto justreturn;

		/* Initialize socket policy if unset. */
		if (inp->inp_ipo == NULL) {
			inp->inp_ipo = ipsec_add_policy(inp, af,
			    IPSP_DIRECTION_OUT);
			if (inp->inp_ipo == NULL) {
				*error = ENOBUFS;
				return NULL;
			}
		}

		/*
		 * So we *must* have protected traffic. Let's see what
		 * we have received then.
		 */
		if (inp->inp_tdb_in != NULL) {
			if (inp->inp_tdb_in == tdbp)
				goto justreturn; /* We received packet under a
						  * previously-accepted TDB. */

			/*
			 * We should be receiving protected traffic, and
			 * have an SA in place, but packet was received
			 * unprotected. Simply discard.
			 */
			if (tdbp == NULL) {
				*error = -EINVAL;
				return NULL;
			}

			/* Update, since we may need all the relevant info. */
			ipsec_update_policy(inp, inp->inp_ipo, af,
			    IPSP_DIRECTION_OUT);

			/*
			 * Check that the TDB the packet was received under
			 * is acceptable under the socket policy. If so,
			 * accept the packet; otherwise, discard.
			 */
			if (tdbp->tdb_sproto == inp->inp_ipo->ipo_sproto &&
			    !memcmp(&tdbp->tdb_src, &inp->inp_ipo->ipo_dst,
			    SA_LEN(&tdbp->tdb_src.sa)) &&
			    ipsp_aux_match(tdbp, inp->inp_ipo->ipo_srcid,
			    inp->inp_ipo->ipo_dstid, &inp->inp_ipo->ipo_addr,
			    &inp->inp_ipo->ipo_mask))
				goto justreturn;
			else {
				*error = -EINVAL;
				return NULL;
			}
		} else {
			/* Update, since we may need all the relevant info. */
			ipsec_update_policy(inp, inp->inp_ipo, af,
			    IPSP_DIRECTION_OUT);

			/*
			 * If the packet was received under an SA, see if
			 * it's acceptable under socket policy. If it is,
			 * accept the packet.
			 */
			if (tdbp != NULL &&
			    tdbp->tdb_sproto == inp->inp_ipo->ipo_sproto &&
			    !memcmp(&tdbp->tdb_src, &inp->inp_ipo->ipo_dst,
			    SA_LEN(&tdbp->tdb_src.sa)) &&
			    ipsp_aux_match(tdbp, inp->inp_ipo->ipo_srcid,
			    inp->inp_ipo->ipo_dstid, &inp->inp_ipo->ipo_addr,
			    &inp->inp_ipo->ipo_mask))
				goto justreturn;

			/*
			 * If the packet was not received under an SA, or
			 * if the SA it was received under is not acceptable,
			 * see if we already have an acceptable SA
			 * established. If we do, discard packet.
			 */
			if (inp->inp_ipo->ipo_last_searched <=
			    ipsec_last_added) {
				inp->inp_ipo->ipo_last_searched = time_second;

				/* Do we have an SA already established ? */
				if (gettdbbysrc(rtable_l2(inp->inp_rtableid),
				    &inp->inp_ipo->ipo_dst,
				    inp->inp_ipo->ipo_sproto,
				    inp->inp_ipo->ipo_srcid,
				    inp->inp_ipo->ipo_dstid,
				    &inp->inp_ipo->ipo_addr,
				    &inp->inp_ipo->ipo_mask) != NULL) {
					*error = -EINVAL;
					return NULL;
				}
				/* Fall through */
			}

			/*
			 * If we don't have an appropriate SA, acquire one
			 * and discard the packet.
			 */
			ipsp_acquire_sa(inp->inp_ipo, &inp->inp_ipo->ipo_dst,
			    &inp->inp_ipo->ipo_src, &inp->inp_ipo->ipo_addr, m);
			*error = -EINVAL;
			return NULL;
		}

		break;

	case IPSP_DIRECTION_OUT:
		/* Do we have a cached entry ? */
		if (inp->inp_tdb_out != NULL) {
			/*
			 * If we also have to apply a different TDB as
			 * a result of a system-wide policy, add a tag
			 * to the packet.
			 */
			if (ipo != NULL && m != NULL &&
			    ipo->ipo_tdb != NULL &&
			    ipo->ipo_tdb != inp->inp_tdb_out) {
				tdb = inp->inp_tdb_out;
				goto tagandreturn;
			} else
				return inp->inp_tdb_out;
		}

		/*
		 * We need to either find an SA with the appropriate
		 * characteristics and link it to the PCB, or acquire
		 * one.
		 */
		/* XXX Only support one policy/protocol for now. */
		if (inp->inp_ipo != NULL) {
			if (inp->inp_ipo->ipo_last_searched <=
			    ipsec_last_added) {
				inp->inp_ipo->ipo_last_searched = time_second;

				/* Update, just in case. */
				ipsec_update_policy(inp, inp->inp_ipo, af,
				    IPSP_DIRECTION_OUT);

				tdb = gettdbbydst(rtable_l2(inp->inp_rtableid),
				    &inp->inp_ipo->ipo_dst,
				    inp->inp_ipo->ipo_sproto,
				    inp->inp_ipo->ipo_srcid,
				    inp->inp_ipo->ipo_dstid,
				    &inp->inp_ipo->ipo_addr,
				    &inp->inp_ipo->ipo_mask);
			}
		} else {
			/*
			 * Construct a pseudo-policy, with just the necessary
			 * fields.
			 */
			ipsec_update_policy(inp, &sipon, af,
			    IPSP_DIRECTION_OUT);

			tdb = gettdbbydst(rtable_l2(inp->inp_rtableid),
			    &sipon.ipo_dst, IPPROTO_ESP, NULL, NULL,
			    &sipon.ipo_addr, &sipon.ipo_mask);
		}

		/* If we found an appropriate SA... */
		if (tdb != NULL) {
			tdb_add_inp(tdb, inp, 0); /* Latch onto PCB. */

			if (ipo != NULL && ipo->ipo_tdb != NULL &&
			    ipo->ipo_tdb != inp->inp_tdb_out && m != NULL)
				goto tagandreturn;
			else
				return tdb;
		} else {
			/* Do we need to acquire one ? */
			switch (inp->inp_seclevel[SL_ESP_TRANS]) {
			case IPSEC_LEVEL_BYPASS:
			case IPSEC_LEVEL_AVAIL:
				/* No need to do anything. */
				goto justreturn;
			case IPSEC_LEVEL_USE:
			case IPSEC_LEVEL_REQUIRE:
			case IPSEC_LEVEL_UNIQUE:
				/* Initialize socket policy if unset. */
				if (inp->inp_ipo == NULL) {
					inp->inp_ipo = ipsec_add_policy(inp, af, IPSP_DIRECTION_OUT);
					if (inp->inp_ipo == NULL) {
						*error = ENOBUFS;
						return NULL;
					}
				}

				/* Acquire a new SA. */
				if ((*error = ipsp_acquire_sa(inp->inp_ipo,
				    &inp->inp_ipo->ipo_dst,
				    &inp->inp_ipo->ipo_src,
				    &inp->inp_ipo->ipo_addr, m)) == 0)
					*error = -EINVAL;

				return NULL;
			default:
				DPRINTF(("ipsp_spd_inp: unknown sock security"
				    " level %d",
				    inp->inp_seclevel[SL_ESP_TRANS]));
				*error = -EINVAL;
				return NULL;
			}
		}
		break;

	default:  /* Should never happen. */
		*error = -EINVAL;
		return NULL;
	}

 tagandreturn:
	if (tdb == NULL)
d793 2
a794 15
	mtag = m_tag_get(PACKET_TAG_IPSEC_PENDING_TDB,
	    sizeof (struct tdb_ident), M_NOWAIT);
	if (mtag == NULL) {
		*error = ENOMEM;
		return NULL;
	}

	tdbi = (struct tdb_ident *)(mtag + 1);
	tdbi->spi = ipo->ipo_tdb->tdb_spi;
	tdbi->proto = ipo->ipo_tdb->tdb_sproto;
	tdbi->rdomain = rtable_l2(inp->inp_rtableid);
	bcopy(&ipo->ipo_tdb->tdb_dst, &tdbi->dst,
	    ipo->ipo_tdb->tdb_dst.sa.sa_len);
	m_tag_prepend(m, mtag);
	return tdb;
@


1.81
log
@Perform IPsec bypass check on a socket before performing TDB lookups.
OK markus, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.80 2015/04/13 16:48:01 mikeb Exp $ */
a370 1
			    ipo->ipo_local_cred, NULL,
d408 1
a408 2
				ipo->ipo_local_cred, &ipo->ipo_addr,
				&ipo->ipo_mask);
d495 2
a496 3
			 * set; credentials/IDs will be the same,
			 * since the cached entry is linked on this
			 * policy.
a608 4
	if (ipo->ipo_local_cred)
		ipsp_reffree(ipo->ipo_local_cred);
	if (ipo->ipo_local_auth)
		ipsp_reffree(ipo->ipo_local_auth);
d761 2
a762 6
	 * If this is a socket policy, it has to have authentication
	 * information accompanying it --- can't tell key mgmt. to
	 * "find" it for us. This avoids abusing key mgmt. to authenticate
	 * on an application's behalf, even if the application doesn't
	 * have/know (and shouldn't) the appropriate authentication
	 * material (passphrase, private key, etc.)
d764 1
a764 2
	if (ipo->ipo_flags & IPSP_POLICY_SOCKET &&
	    ipo->ipo_local_auth == NULL)
d960 3
a962 3
			    ipsp_aux_match(tdbp, inp->inp_ipo->ipo_srcid, 
			    inp->inp_ipo->ipo_dstid, NULL, NULL,
			    &inp->inp_ipo->ipo_addr, &inp->inp_ipo->ipo_mask))
d983 2
a984 2
			    inp->inp_ipo->ipo_dstid, NULL, NULL,
			    &inp->inp_ipo->ipo_addr, &inp->inp_ipo->ipo_mask))
a1059 1
				    inp->inp_ipo->ipo_local_cred,
d1072 2
a1073 2
			    &sipon.ipo_dst, IPPROTO_ESP, NULL,
			    NULL, NULL, &sipon.ipo_addr, &sipon.ipo_mask);
@


1.80
log
@Rename gettdbbyaddr to gettdbbydst;  OK markus, hshoexer, mpi
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.79 2015/04/13 16:45:52 mikeb Exp $ */
a329 11
		 * Fetch the incoming TDB based on the SPI passed
		 * in ipsecflow and use it's dstid when looking
		 * up the outgoing TDB.
		 */
		if (ipsecflowinfo &&
		   (tdbin = gettdb(rdomain, ipsecflowinfo, &ssrc,
		    ipo->ipo_sproto)) != NULL) {
			srcid = tdbin->tdb_dstid;
			dstid = tdbin->tdb_srcid;
		}
		/*
d345 12
@


1.79
log
@Remove unused arguments from gettdb* functions;  OK markus, hshoexer, mpi
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.78 2015/03/14 03:38:52 jsg Exp $ */
d403 1
a403 1
			    gettdbbyaddr(rdomain,
d1066 1
a1066 1
				tdb = gettdbbyaddr(rtable_l2(inp->inp_rtableid),
d1083 1
a1083 1
			tdb = gettdbbyaddr(rtable_l2(inp->inp_rtableid),
@


1.78
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.77 2014/12/19 17:14:40 tedu Exp $ */
d408 2
a409 2
				ipo->ipo_local_cred, m, af,
				&ipo->ipo_addr, &ipo->ipo_mask);
d522 1
a522 1
				ipo->ipo_dstid, m, af, &ipo->ipo_addr,
d1013 1
a1013 1
				    inp->inp_ipo->ipo_dstid, m, af,
d1071 1
a1071 1
				    inp->inp_ipo->ipo_local_cred, m, af,
d1085 1
a1085 2
			    NULL, NULL, m, af, &sipon.ipo_addr,
			    &sipon.ipo_mask);
@


1.77
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.76 2014/11/25 13:10:03 mpi Exp $ */
a32 1
#include <net/if.h>
@


1.76
log
@The proliferation of "struct route" in all its flavors didn't make
any good to our network stack.

The most visible effect is the maze of #ifdef's and casts.  But the
real problem is the very fragile way of checking if a (cached) route
entry is still valid or not.  What should we do if the route jumped
to another ifaddr or if its gateway has been changed?

This change start the dance of "struct route" & friends removal by
sending the completly useless "struct route_enc" to the bucket.

Tweak & ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.75 2014/11/01 21:40:39 mpi Exp $ */
a36 1
#ifdef INET
a40 1
#endif /* INET */
a42 3
#ifndef INET
#include <netinet/in.h>
#endif
a121 1
#ifdef INET
a172 1
#endif /* INET */
a289 1
#ifdef INET
a294 1
#endif /* INET */
a307 1
#ifdef INET
a311 1
#endif /* INET */
a675 1
#ifdef INET
a694 1
#endif /* INET */
a802 1
#ifdef INET
a834 1
#endif /* INET */
@


1.75
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.74 2014/10/14 09:52:26 mpi Exp $ */
d90 1
a90 1
	struct route_enc re0, *re = &re0;
d92 1
a92 1
	struct sockaddr_encap *ddst;
d119 1
a119 1
	memset(re, 0, sizeof(struct route_enc));
d122 1
a122 1
	ddst = (struct sockaddr_encap *) &re->re_dst;
a242 3
	/* Set the rdomain that was obtained from the mbuf */
	re->re_tableid = rdomain;

d244 2
a245 3
	re->re_rt = rtalloc((struct sockaddr *)&re->re_dst,
	    RT_REPORT|RT_RESOLVE, re->re_tableid);
	if (re->re_rt == NULL) {
d256 2
a257 2
	if ((re->re_rt->rt_gateway == NULL) ||
	    (((struct sockaddr_encap *) re->re_rt->rt_gateway)->sen_type !=
d259 1
a259 1
		rtfree(re->re_rt);
d265 2
a266 2
	ipo = ((struct sockaddr_encap *) (re->re_rt->rt_gateway))->sen_ipsp;
	rtfree(re->re_rt);
@


1.74
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.73 2014/09/27 12:26:16 mpi Exp $ */
d247 2
a248 2
	re->re_rt = rtalloc1((struct sockaddr *)&re->re_dst, RT_REPORT,
	    re->re_tableid);
@


1.73
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.72 2014/07/22 11:06:10 mpi Exp $ */
d263 1
a263 1
		RTFREE(re->re_rt);
d270 1
a270 1
	RTFREE(re->re_rt);
@


1.72
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.71 2014/04/14 09:06:42 mpi Exp $ */
d247 2
a248 1
	rtalloc((struct route *) re);
@


1.71
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.70 2014/01/09 06:29:06 tedu Exp $ */
a38 1
#include <netinet/in_systm.h>
@


1.70
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.69 2013/10/24 11:31:43 mpi Exp $ */
d98 1
a98 1
	u_int rdomain = rtable_l2(m->m_pkthdr.rdomain);
@


1.69
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.68 2013/10/23 15:12:42 mpi Exp $ */
d120 3
a122 3
	bzero((caddr_t) re, sizeof(struct route_enc));
	bzero((caddr_t) &sdst, sizeof(union sockaddr_union));
	bzero((caddr_t) &ssrc, sizeof(union sockaddr_union));
d312 2
a313 2
		    (bcmp(&ipo->ipo_dst.sin6.sin6_addr, &in6mask128,
			sizeof(in6mask128)) == 0))
d368 1
a368 1
			    !bcmp(&sdst, &ipo->ipo_dst, sdst.sa.sa_len)) {
d378 3
a380 3
			    bcmp(dignore ? &sdst : &ipo->ipo_dst,
				&ipo->ipo_tdb->tdb_dst,
				ipo->ipo_tdb->tdb_dst.sa.sa_len))
d471 1
a471 1
			if (bcmp(dignore ? &ssrc : &ipo->ipo_dst,
d517 3
a519 3
			    !bcmp(&ipo->ipo_tdb->tdb_src,
				dignore ? &ssrc : &ipo->ipo_dst,
				ipo->ipo_tdb->tdb_src.sa.sa_len))
d606 1
a606 1
		bzero(&info, sizeof(info));
d767 1
a767 1
		if (!bcmp(gw, &ipa->ipa_addr, gw->sa.sa_len))
d989 5
a993 8
			    !bcmp(&tdbp->tdb_src, &inp->inp_ipo->ipo_dst,
				SA_LEN(&tdbp->tdb_src.sa)) &&
			    ipsp_aux_match(tdbp,
				inp->inp_ipo->ipo_srcid, 
				inp->inp_ipo->ipo_dstid,
				NULL, NULL,
				&inp->inp_ipo->ipo_addr,
				&inp->inp_ipo->ipo_mask))
d1011 5
a1015 8
			    !bcmp(&tdbp->tdb_src, &inp->inp_ipo->ipo_dst,
				SA_LEN(&tdbp->tdb_src.sa)) &&
			    ipsp_aux_match(tdbp,
				inp->inp_ipo->ipo_srcid,
				inp->inp_ipo->ipo_dstid,
				NULL, NULL,
				&inp->inp_ipo->ipo_addr,
				&inp->inp_ipo->ipo_mask))
@


1.68
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.67 2013/05/14 14:29:08 mpi Exp $ */
a48 1
#include <netinet6/in6_var.h>
@


1.67
log
@Fix build with ENCDEBUG defined.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.66 2013/04/11 12:06:25 mpi Exp $ */
a42 1
#include <netinet/in_var.h>
@


1.66
log
@Remove the extern keyword from function declarations, document
sysctl declarations, move variables and functions used in only
one place in their corresponding file. No functional change.

No objection from markus@@, ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.65 2013/03/28 23:10:06 tedu Exp $ */
d41 1
@


1.65
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.64 2012/07/16 18:05:36 markus Exp $ */
d54 7
@


1.64
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.63 2010/09/28 01:44:57 deraadt Exp $ */
d31 1
@


1.63
log
@missing PR_NOWAIT
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.62 2010/07/09 16:58:06 reyk Exp $ */
d82 1
a82 1
    struct tdb *tdbp, struct inpcb *inp)
d88 2
d339 11
d377 2
a378 1
			    ipo->ipo_srcid, ipo->ipo_dstid,
d414 4
a417 2
				ipo->ipo_sproto, ipo->ipo_srcid,
				ipo->ipo_dstid, ipo->ipo_local_cred, m, af,
@


1.62
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.61 2010/07/02 03:58:48 david Exp $ */
d784 1
a784 1
	ipa = pool_get(&ipsec_acquire_pool, PR_ZERO);
@


1.61
log
@don't reference an item after it has been returned to the pool
an 8 year old bug exposed by recent uvm changes

ok thib@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.60 2010/01/15 18:20:23 chl Exp $ */
d89 1
d235 3
d398 2
a399 1
			    gettdbbyaddr(dignore ? &sdst : &ipo->ipo_dst,
d512 2
a513 1
			    gettdbbysrc(dignore ? &ssrc : &ipo->ipo_dst,
d588 2
a589 1
		err = rtrequest1(RTM_DELETE, &info, RTP_DEFAULT, NULL, 0);
d645 1
d1012 2
a1013 1
				if (gettdbbysrc(&inp->inp_ipo->ipo_dst,
d1069 2
a1070 1
				tdb = gettdbbyaddr(&inp->inp_ipo->ipo_dst,
d1086 2
a1087 1
			tdb = gettdbbyaddr(&sipon.ipo_dst, IPPROTO_ESP, NULL,
d1157 1
@


1.60
log
@Replace pool_get() + bzero() with pool_get(..., PR_ZERO).

With input from oga@@ and krw@@

ok oga@@ krw@@ thib@@ markus@@ mk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.59 2009/01/27 22:40:10 bluhm Exp $ */
a601 2
	pool_put(&ipsec_policy_pool, ipo);

d604 2
@


1.59
log
@In IPsec acquire mode, if the flow was configured for the "any"
network 0.0.0.0/0 or ::/0, the SA was established for the IP address
in the packet instead of the network in the flow.  That means the
SA was not negotiated for the network 0.0.0.0 with mask 0 but for
the remote IP with mask 255.255.255.255.  This SA did not match the
flow and did not work.

To differentiate between general flows that are used to trigger
specific host-to-host SAs and flows for matching network SAs, the
if condition only uses the ipo->ipo_dst field now.  For a flow
without peer, an SA must be negotiated for each host-to-host
combination.  Otherwise, if a peer exists at the flow, the kernel
acquires one SA for the whole network.

tested by todd@@,  ok hshoexer@@, angelos@@, todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.58 2008/09/10 14:01:23 blambert Exp $ */
d624 1
a624 1
	ipon = pool_get(&ipsec_policy_pool, PR_NOWAIT);
a627 2
	bzero(ipon, sizeof(struct ipsec_policy));

d776 1
a776 1
	ipa = pool_get(&ipsec_acquire_pool, 0);
a779 1
	bzero(ipa, sizeof(struct ipsec_acquire));
@


1.58
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.57 2008/07/22 09:26:39 bluhm Exp $ */
d798 1
a798 3
		if (ipo->ipo_mask.sen_ip_src.s_addr == INADDR_ANY ||
		    ipo->ipo_addr.sen_ip_src.s_addr == INADDR_ANY ||
		    ipsp_is_unspecified(ipo->ipo_dst)) {
d806 1
a806 3
		if (ipo->ipo_mask.sen_ip_dst.s_addr == INADDR_ANY ||
		    ipo->ipo_addr.sen_ip_dst.s_addr == INADDR_ANY ||
		    ipsp_is_unspecified(ipo->ipo_dst)) {
d835 1
a835 3
		if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_mask.sen_ip6_src) ||
		    IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_addr.sen_ip6_src) ||
		    ipsp_is_unspecified(ipo->ipo_dst)) {
d843 1
a843 3
		if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_mask.sen_ip6_dst) ||
		    IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_addr.sen_ip6_dst) ||
		    ipsp_is_unspecified(ipo->ipo_dst)) {
@


1.57
log
@Assign the struct size to sin6_len instead of sin6_family.
ok hshoexer claudio mpf henning
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.56 2008/06/11 18:20:54 blambert Exp $ */
d880 1
a880 1
	timeout_add(&ipa->ipa_timeout, ipsec_expire_acquire * hz);
@


1.56
log
@0 -> PR_NOWAIT (which is defined as 0) in pool_get
as an aid to readability

ok and thinko-catching henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.55 2008/05/09 15:48:59 claudio Exp $ */
d192 1
a192 1
		sdst.sin6.sin6_len = ssrc.sin6.sin6_family =
@


1.55
log
@more rtrequest() to rtrequest1() replacement.
OK henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.54 2007/09/01 18:49:28 henning Exp $ */
d624 1
a624 1
	ipon = pool_get(&ipsec_policy_pool, 0);
@


1.54
log
@since the
MGET* macros were changed to function calls, there wasn't any
need for the pool declarations and the inclusion of pool.h
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.53 2007/02/14 00:53:48 jsg Exp $ */
d568 1
d576 4
a579 5
	if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
		err = rtrequest(RTM_DELETE, (struct sockaddr *) &ipo->ipo_addr,
		    (struct sockaddr *) 0,
		    (struct sockaddr *) &ipo->ipo_mask,
		    0, (struct rtentry **) 0, 0);	/* XXX other tables? */
d581 3
@


1.53
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.52 2006/06/16 16:49:40 henning Exp $ */
d30 1
@


1.52
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.51 2005/02/17 18:07:36 jfb Exp $ */
d417 1
a417 1
			/* Fall through */
d427 1
a427 1
			/* Fall through */
d530 1
a530 1
			/* Fall through */
d548 1
a548 1
			/* Fall through */
@


1.51
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.50 2004/06/21 23:50:37 tholo Exp $ */
d578 1
a578 1
		    0, (struct rtentry **) 0);
@


1.50
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.49 2004/06/21 20:44:54 itojun Exp $ */
d67 1
a67 1
 * the mbuf is. hlen is the the offset of the transport protocol header
@


1.49
log
@make it possble to use IPsec over link-local address (policy table uses
sin6_scope_id, IPsec porion uses embedded form).  beck ok
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.48 2004/04/14 20:10:04 markus Exp $ */
d389 1
a389 1
				ipo->ipo_last_searched = time.tv_sec;
d503 1
a503 1
				ipo->ipo_last_searched = time.tv_sec;
d1008 1
a1008 1
				inp->inp_ipo->ipo_last_searched = time.tv_sec;
d1061 1
a1061 1
				inp->inp_ipo->ipo_last_searched = time.tv_sec;
@


1.48
log
@simpler ipsp_aux_match() API; ok henning, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.47 2002/11/12 13:38:41 dhartmei Exp $ */
d193 2
a194 2
		ssrc.sin6.sin6_addr = ddst->sen_ip6_src;
		sdst.sin6.sin6_addr = ddst->sen_ip6_dst;
@


1.47
log
@Check for undersized IP header, found by jbm@@, ok angelos@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.46 2002/06/09 16:26:10 itojun Exp $ */
d358 4
a361 6
			if (!ipsp_aux_match(ipo->ipo_tdb->tdb_srcid,
			    ipo->ipo_srcid, ipo->ipo_tdb->tdb_dstid,
			    ipo->ipo_dstid, ipo->ipo_tdb->tdb_local_cred,
			    ipo->ipo_local_cred, NULL, NULL,
			    &ipo->ipo_tdb->tdb_filter, &ipo->ipo_addr,
			    &ipo->ipo_tdb->tdb_filtermask, &ipo->ipo_mask))
d967 4
a970 4
			    ipsp_aux_match(tdbp->tdb_srcid,
				inp->inp_ipo->ipo_srcid, tdbp->tdb_dstid,
				inp->inp_ipo->ipo_dstid, NULL, NULL,
				NULL, NULL, &tdbp->tdb_filter,
a971 1
				&tdbp->tdb_filtermask,
d992 5
a996 5
			    ipsp_aux_match(tdbp->tdb_srcid,
				inp->inp_ipo->ipo_srcid, tdbp->tdb_dstid,
				inp->inp_ipo->ipo_dstid, NULL, NULL,
				NULL, NULL, &tdbp->tdb_filter,
				&inp->inp_ipo->ipo_addr, &tdbp->tdb_filtermask,
@


1.46
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.45 2002/05/31 02:42:22 angelos Exp $ */
d119 4
d173 4
@


1.46.2.1
log
@Pull patch from current:
Fix by dhartmei@@
Check for undersized IP header, found by jbm@@.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.47 2002/11/12 13:38:41 dhartmei Exp $ */
a118 4
		if (hlen < sizeof (struct ip) || m->m_pkthdr.len < hlen) {
			*error = EINVAL;
			return NULL;
		}
a168 4
		if (hlen < sizeof (struct ip6_hdr) || m->m_pkthdr.len < hlen) {
			*error = EINVAL;
			return NULL;
		}
@


1.45
log
@Per-socket policies and authentication. Finally.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.44 2002/02/18 04:46:29 angelos Exp $ */
d469 1
a469 1
  	;
@


1.44
log
@Search the correct ACQUIRE list --- shifflett@@nps.navy.mil
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.43 2002/01/23 01:33:07 art Exp $ */
d28 2
d243 1
d251 1
d350 7
a356 23
			/* Match source ID. */
			if (ipo->ipo_srcid) {
				if (ipo->ipo_tdb->tdb_srcid == NULL ||
				    !ipsp_ref_match(ipo->ipo_srcid,
					ipo->ipo_tdb->tdb_srcid))
					goto nomatchout;
			}

			/* Match destination ID. */
			if (ipo->ipo_dstid) {
				if (ipo->ipo_tdb->tdb_dstid == NULL ||
				    !ipsp_ref_match(ipo->ipo_dstid,
					ipo->ipo_tdb->tdb_dstid))
					goto nomatchout;
			}

			/* Match local credentials used. */
			if (ipo->ipo_local_cred) {
				if (ipo->ipo_tdb->tdb_local_cred == NULL ||
				    !ipsp_ref_match(ipo->ipo_local_cred, 
					ipo->ipo_tdb->tdb_local_cred))
					goto nomatchout;
			}
d388 3
a390 1
				ipo, m, af);
d501 3
a503 1
				ipo, m, af);
d564 3
d590 1
a590 1
		ipsp_reffree(ipo->ipo_local_cred);
d594 2
a595 1
	ipsec_in_use--;
a599 1
#ifdef notyet
d604 1
a604 2
ipsec_add_policy(struct sockaddr_encap *dst, struct sockaddr_encap *mask,
    union sockaddr_union *sdst, int type, int sproto)
a605 1
	struct sockaddr_encap encapgw;
a618 1
	bzero((caddr_t) &encapgw, sizeof(struct sockaddr_encap));
d620 2
a621 12
	encapgw.sen_len = SENT_LEN;
	encapgw.sen_family = PF_KEY;
	encapgw.sen_type = SENT_IPSP;
	encapgw.sen_ipsp = ipon;

	if (rtrequest(RTM_ADD, (struct sockaddr *) dst,
	    (struct sockaddr *) &encapgw, (struct sockaddr *) mask,
	    RTF_UP | RTF_GATEWAY | RTF_STATIC, (struct rtentry **) 0) != 0) {
		DPRINTF(("ipsec_add_policy: failed to add policy\n"));
		pool_put(&ipsec_policy_pool, ipon);
		return NULL;
	}
d623 1
a623 1
	ipsec_in_use++;
d625 5
a629 5
	bcopy(dst, &ipon->ipo_addr, sizeof(struct sockaddr_encap));
	bcopy(mask, &ipon->ipo_mask, sizeof(struct sockaddr_encap));
	bcopy(sdst, &ipon->ipo_dst, sizeof(union sockaddr_union));
	ipon->ipo_sproto = sproto;
	ipon->ipo_type = type;
d634 2
d638 63
a700 1
#endif
d736 2
a737 2
 * Signal key management that we need an SA. If we're given an mbuf, store
 * it and retransmit the packet if/when we have an SA in place.
d744 12
a755 3
#ifdef INET6
	int i;
#endif
d833 1
a833 2
			for (i = 0; i < 16; i++)
				ipa->ipa_mask.sen_ip6_src.s6_addr8[i] = 0xff;
d843 1
a843 2
			for (i = 0; i < 16; i++)
				ipa->ipa_mask.sen_ip6_dst.s6_addr8[i] = 0xff;
d887 267
a1153 1
	/* XXX */
@


1.43
log
@It looks like there has been one crack smoking and a few cut and pastes.
PR_FREEHEADER should not be set in pool_init by the caller. It shouldn't
be set in pool_init at all. Besides, it's going away soon anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.42 2002/01/23 00:39:48 art Exp $ */
d850 1
a850 1
	TAILQ_FOREACH (ipa, &ipsec_acquire_head, ipa_ipo_next)
@


1.42
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.41 2002/01/02 20:35:40 deraadt Exp $ */
d618 1
a618 1
		    0, 0, PR_FREEHEADER, "ipsec policy", NULL);
d710 1
a710 1
		    0, 0, PR_FREEHEADER, "ipsec acquire", NULL);
@


1.41
log
@at least ; required after label or case; openbsd@@davidkrause.com
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.40 2001/09/24 16:22:08 angelos Exp $ */
d618 1
a618 2
		    0, 0, PR_FREEHEADER, "ipsec policy", 0, NULL, NULL,
		    M_IPSEC_POLICY);
d710 1
a710 2
		    0, 0, PR_FREEHEADER, "ipsec acquire", 0, NULL,
		    NULL, M_IPSEC_POLICY);		
@


1.40
log
@Reset the error return value if the cached TDB matches the
policy. Pointed out by jdmcbride@@iol.ie
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.39 2001/08/21 06:48:55 angelos Exp $ */
d479 1
@


1.40.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.43 2002/01/23 01:33:07 art Exp $ */
a478 1
  	;
d617 2
a618 1
		    0, 0, 0, "ipsec policy", NULL);
d710 2
a711 1
		    0, 0, 0, "ipsec acquire", NULL);
@


1.40.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.40.4.1 2002/01/31 22:55:45 niklas Exp $ */
a27 2
#include <sys/socketvar.h>
#include <sys/protosw.h>
a240 1
		DPRINTF(("ip_spd_lookup: no gateway in SPD entry!"));
a247 1
		DPRINTF(("ip_spd_lookup: no policy attached to SPD entry!"));
d346 23
a368 7
			if (!ipsp_aux_match(ipo->ipo_tdb->tdb_srcid,
			    ipo->ipo_srcid, ipo->ipo_tdb->tdb_dstid,
			    ipo->ipo_dstid, ipo->ipo_tdb->tdb_local_cred,
			    ipo->ipo_local_cred, NULL, NULL,
			    &ipo->ipo_tdb->tdb_filter, &ipo->ipo_addr,
			    &ipo->ipo_tdb->tdb_filtermask, &ipo->ipo_mask))
				goto nomatchout;
d400 1
a400 3
				ipo->ipo_sproto, ipo->ipo_srcid,
				ipo->ipo_dstid, ipo->ipo_local_cred, m, af,
				&ipo->ipo_addr, &ipo->ipo_mask);
d511 1
a511 3
				ipo->ipo_sproto, ipo->ipo_srcid,
				ipo->ipo_dstid, m, af, &ipo->ipo_addr,
				&ipo->ipo_mask);
a571 3
	if (--ipo->ipo_ref_count > 0)
		return 0;

d595 1
a595 1
		ipsp_reffree(ipo->ipo_local_auth);
d599 1
a599 2
	if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
		ipsec_in_use--;
d604 1
d609 2
a610 1
ipsec_add_policy(struct inpcb *inp, int af, int direction)
d612 1
d626 6
d633 7
a639 2
	ipon->ipo_ref_count = 1;
	ipon->ipo_flags |= IPSP_POLICY_SOCKET;
d641 1
a641 1
	ipon->ipo_type = IPSP_IPSEC_REQUIRE; /* XXX */
d643 5
a647 5
	/* XXX
	 * We should actually be creating a linked list of
	 * policies (for tunnel/transport and ESP/AH), as needed.
	 */
	ipon->ipo_sproto = IPPROTO_ESP;
a651 2
	ipsec_update_policy(inp, ipon, af, direction);

d654 1
a654 63

/*
 * Update a PCB-attached policy.
 */
void
ipsec_update_policy(struct inpcb *inp, struct ipsec_policy *ipon, int af,
    int direction)
{
	ipon->ipo_addr.sen_len = ipon->ipo_mask.sen_len = SENT_LEN;
	ipon->ipo_addr.sen_family = ipon->ipo_mask.sen_family = PF_KEY;
	ipon->ipo_src.sa.sa_family = ipon->ipo_dst.sa.sa_family = af;

	switch (af) {
	case AF_INET:
#ifdef INET
		ipon->ipo_addr.sen_type = ipon->ipo_mask.sen_type = SENT_IP4;
		ipon->ipo_addr.sen_ip_src = inp->inp_laddr;
		ipon->ipo_addr.sen_ip_dst = inp->inp_faddr;
		ipon->ipo_addr.sen_sport = inp->inp_lport;
		ipon->ipo_addr.sen_dport = inp->inp_fport;
		ipon->ipo_addr.sen_proto =
		    inp->inp_socket->so_proto->pr_protocol;
		ipon->ipo_addr.sen_direction = direction;

		ipon->ipo_mask.sen_ip_src.s_addr = 0xffffffff;
		ipon->ipo_mask.sen_ip_dst.s_addr = 0xffffffff;
		ipon->ipo_mask.sen_sport = ipon->ipo_mask.sen_dport = 0xffff;
		ipon->ipo_mask.sen_proto = 0xff;
		ipon->ipo_mask.sen_direction = direction;

		ipon->ipo_src.sa.sa_len = sizeof(struct sockaddr_in);
		ipon->ipo_dst.sa.sa_len = sizeof(struct sockaddr_in);
		ipon->ipo_src.sin.sin_addr = inp->inp_laddr;
		ipon->ipo_dst.sin.sin_addr = inp->inp_faddr;
#endif /* INET */
		break;

	case AF_INET6:
#ifdef INET6
		ipon->ipo_addr.sen_type = ipon->ipo_mask.sen_type = SENT_IP6;
		ipon->ipo_addr.sen_ip6_src = inp->inp_laddr6;
		ipon->ipo_addr.sen_ip6_dst = inp->inp_faddr6;
		ipon->ipo_addr.sen_ip6_sport = inp->inp_lport;
		ipon->ipo_addr.sen_ip6_dport = inp->inp_fport;
		ipon->ipo_addr.sen_ip6_proto =
		    inp->inp_socket->so_proto->pr_protocol;
		ipon->ipo_addr.sen_ip6_direction = direction;

		ipon->ipo_mask.sen_ip6_src = in6mask128;
		ipon->ipo_mask.sen_ip6_dst = in6mask128;
		ipon->ipo_mask.sen_ip6_sport = 0xffff;
		ipon->ipo_mask.sen_ip6_dport = 0xffff;
		ipon->ipo_mask.sen_ip6_proto = 0xff;
		ipon->ipo_mask.sen_ip6_direction = direction;

		ipon->ipo_src.sa.sa_len = sizeof(struct sockaddr_in6);
		ipon->ipo_dst.sa.sa_len = sizeof(struct sockaddr_in6);
		ipon->ipo_src.sin6.sin6_addr = inp->inp_laddr6;
		ipon->ipo_dst.sin6.sin6_addr = inp->inp_faddr6;
#endif /* INET6 */
		break;
	}
}
d690 2
a691 2
 * Signal key management that we need an SA.
 * XXX For outgoing policies, we could try to hold on to the mbuf.
d698 3
a700 12

	/*
	 * If this is a socket policy, it has to have authentication
	 * information accompanying it --- can't tell key mgmt. to
	 * "find" it for us. This avoids abusing key mgmt. to authenticate
	 * on an application's behalf, even if the application doesn't
	 * have/know (and shouldn't) the appropriate authentication
	 * material (passphrase, private key, etc.)
	 */
	if (ipo->ipo_flags & IPSP_POLICY_SOCKET &&
	    ipo->ipo_local_auth == NULL)
		return EINVAL;
d778 2
a779 1
			ipa->ipa_mask.sen_ip6_src = in6mask128;
d789 2
a790 1
			ipa->ipa_mask.sen_ip6_dst = in6mask128;
d834 1
a834 267
	struct ipsec_policy sipon;
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
	struct tdb *tdb = NULL;

	/* Sanity check. */
	if (inp == NULL)
		goto justreturn;

	/* Verify that we need to check for socket policy. */
	if ((inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS ||
	    inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_NONE) &&
	    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS ||
	    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_NONE) &&
	    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS ||
	    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_NONE))
		goto justreturn;

	switch (direction) {
	case IPSP_DIRECTION_IN:
		/*
		 * Some further checking: if the socket has specified
		 * that it will accept unencrypted traffic, don't
		 * bother checking any further -- just accept the packet.
		 */
		if ((inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_AVAIL ||
		    inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_USE) &&
		    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_AVAIL ||
		    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_USE) &&
		    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_AVAIL ||
		    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_USE))
			goto justreturn;

		/* Initialize socket policy if unset. */
		if (inp->inp_ipo == NULL) {
			inp->inp_ipo = ipsec_add_policy(inp, af,
			    IPSP_DIRECTION_OUT);
			if (inp->inp_ipo == NULL) {
				*error = ENOBUFS;
				return NULL;
			}
		}

		/*
		 * So we *must* have protected traffic. Let's see what
		 * we have received then.
		 */
		if (inp->inp_tdb_in != NULL) {
			if (inp->inp_tdb_in == tdbp)
				goto justreturn; /* We received packet under a
						  * previously-accepted TDB. */

			/*
			 * We should be receiving protected traffic, and
			 * have an SA in place, but packet was received
			 * unprotected. Simply discard.
			 */
			if (tdbp == NULL) {
				*error = -EINVAL;
				return NULL;
			}

			/* Update, since we may need all the relevant info. */
			ipsec_update_policy(inp, inp->inp_ipo, af,
			    IPSP_DIRECTION_OUT);

			/*
			 * Check that the TDB the packet was received under
			 * is acceptable under the socket policy. If so,
			 * accept the packet; otherwise, discard.
			 */
			if (tdbp->tdb_sproto == inp->inp_ipo->ipo_sproto &&
			    !bcmp(&tdbp->tdb_src, &inp->inp_ipo->ipo_dst,
				SA_LEN(&tdbp->tdb_src.sa)) &&
			    ipsp_aux_match(tdbp->tdb_srcid,
				inp->inp_ipo->ipo_srcid, tdbp->tdb_dstid,
				inp->inp_ipo->ipo_dstid, NULL, NULL,
				NULL, NULL, &tdbp->tdb_filter,
				&inp->inp_ipo->ipo_addr,
				&tdbp->tdb_filtermask,
				&inp->inp_ipo->ipo_mask))
				goto justreturn;
			else {
				*error = -EINVAL;
				return NULL;
			}
		} else {
			/* Update, since we may need all the relevant info. */
			ipsec_update_policy(inp, inp->inp_ipo, af,
			    IPSP_DIRECTION_OUT);

			/*
			 * If the packet was received under an SA, see if
			 * it's acceptable under socket policy. If it is,
			 * accept the packet.
			 */
			if (tdbp != NULL &&
			    tdbp->tdb_sproto == inp->inp_ipo->ipo_sproto &&
			    !bcmp(&tdbp->tdb_src, &inp->inp_ipo->ipo_dst,
				SA_LEN(&tdbp->tdb_src.sa)) &&
			    ipsp_aux_match(tdbp->tdb_srcid,
				inp->inp_ipo->ipo_srcid, tdbp->tdb_dstid,
				inp->inp_ipo->ipo_dstid, NULL, NULL,
				NULL, NULL, &tdbp->tdb_filter,
				&inp->inp_ipo->ipo_addr, &tdbp->tdb_filtermask,
				&inp->inp_ipo->ipo_mask))
				goto justreturn;

			/*
			 * If the packet was not received under an SA, or
			 * if the SA it was received under is not acceptable,
			 * see if we already have an acceptable SA
			 * established. If we do, discard packet.
			 */
			if (inp->inp_ipo->ipo_last_searched <=
			    ipsec_last_added) {
				inp->inp_ipo->ipo_last_searched = time.tv_sec;

				/* Do we have an SA already established ? */
				if (gettdbbysrc(&inp->inp_ipo->ipo_dst,
				    inp->inp_ipo->ipo_sproto,
				    inp->inp_ipo->ipo_srcid,
				    inp->inp_ipo->ipo_dstid, m, af,
				    &inp->inp_ipo->ipo_addr,
				    &inp->inp_ipo->ipo_mask) != NULL) {
					*error = -EINVAL;
					return NULL;
				}
				/* Fall through */
			}

			/*
			 * If we don't have an appropriate SA, acquire one
			 * and discard the packet.
			 */
			ipsp_acquire_sa(inp->inp_ipo, &inp->inp_ipo->ipo_dst,
			    &inp->inp_ipo->ipo_src, &inp->inp_ipo->ipo_addr, m);
			*error = -EINVAL;
			return NULL;
		}

		break;

	case IPSP_DIRECTION_OUT:
		/* Do we have a cached entry ? */
		if (inp->inp_tdb_out != NULL) {
			/*
			 * If we also have to apply a different TDB as
			 * a result of a system-wide policy, add a tag
			 * to the packet.
			 */
			if (ipo != NULL && m != NULL &&
			    ipo->ipo_tdb != NULL &&
			    ipo->ipo_tdb != inp->inp_tdb_out) {
				tdb = inp->inp_tdb_out;
				goto tagandreturn;
			} else
				return inp->inp_tdb_out;
		}

		/*
		 * We need to either find an SA with the appropriate
		 * characteristics and link it to the PCB, or acquire
		 * one.
		 */
		/* XXX Only support one policy/protocol for now. */
		if (inp->inp_ipo != NULL) {
			if (inp->inp_ipo->ipo_last_searched <=
			    ipsec_last_added) {
				inp->inp_ipo->ipo_last_searched = time.tv_sec;

				/* Update, just in case. */
				ipsec_update_policy(inp, inp->inp_ipo, af,
				    IPSP_DIRECTION_OUT);

				tdb = gettdbbyaddr(&inp->inp_ipo->ipo_dst,
				    inp->inp_ipo->ipo_sproto,
				    inp->inp_ipo->ipo_srcid,
				    inp->inp_ipo->ipo_dstid,
				    inp->inp_ipo->ipo_local_cred, m, af,
				    &inp->inp_ipo->ipo_addr,
				    &inp->inp_ipo->ipo_mask);
			}
		} else {
			/*
			 * Construct a pseudo-policy, with just the necessary
			 * fields.
			 */
			ipsec_update_policy(inp, &sipon, af,
			    IPSP_DIRECTION_OUT);

			tdb = gettdbbyaddr(&sipon.ipo_dst, IPPROTO_ESP, NULL,
			    NULL, NULL, m, af, &sipon.ipo_addr,
			    &sipon.ipo_mask);
		}

		/* If we found an appropriate SA... */
		if (tdb != NULL) {
			tdb_add_inp(tdb, inp, 0); /* Latch onto PCB. */

			if (ipo != NULL && ipo->ipo_tdb != NULL &&
			    ipo->ipo_tdb != inp->inp_tdb_out && m != NULL)
				goto tagandreturn;
			else
				return tdb;
		} else {
			/* Do we need to acquire one ? */
			switch (inp->inp_seclevel[SL_ESP_TRANS]) {
			case IPSEC_LEVEL_BYPASS:
			case IPSEC_LEVEL_AVAIL:
				/* No need to do anything. */
				goto justreturn;
			case IPSEC_LEVEL_USE:
			case IPSEC_LEVEL_REQUIRE:
			case IPSEC_LEVEL_UNIQUE:
				/* Initialize socket policy if unset. */
				if (inp->inp_ipo == NULL) {
					inp->inp_ipo = ipsec_add_policy(inp, af, IPSP_DIRECTION_OUT);
					if (inp->inp_ipo == NULL) {
						*error = ENOBUFS;
						return NULL;
					}
				}

				/* Acquire a new SA. */
				if ((*error = ipsp_acquire_sa(inp->inp_ipo,
				    &inp->inp_ipo->ipo_dst,
				    &inp->inp_ipo->ipo_src,
				    &inp->inp_ipo->ipo_addr, m)) == 0)
					*error = -EINVAL;

				return NULL;
			default:
				DPRINTF(("ipsp_spd_inp: unknown sock security"
				    " level %d",
				    inp->inp_seclevel[SL_ESP_TRANS]));
				*error = -EINVAL;
				return NULL;
			}
		}
		break;

	default:  /* Should never happen. */
		*error = -EINVAL;
		return NULL;
	}

 tagandreturn:
	if (tdb == NULL)
		goto justreturn;

	mtag = m_tag_get(PACKET_TAG_IPSEC_PENDING_TDB,
	    sizeof (struct tdb_ident), M_NOWAIT);
	if (mtag == NULL) {
		*error = ENOMEM;
		return NULL;
	}

	tdbi = (struct tdb_ident *)(mtag + 1);
	tdbi->spi = ipo->ipo_tdb->tdb_spi;
	tdbi->proto = ipo->ipo_tdb->tdb_sproto;
	bcopy(&ipo->ipo_tdb->tdb_dst, &tdbi->dst,
	    ipo->ipo_tdb->tdb_dst.sa.sa_len);
	m_tag_prepend(m, mtag);
	return tdb;

 justreturn:
d850 1
a850 1
	TAILQ_FOREACH (ipa, &ipsec_acquire_head, ipa_next)
@


1.40.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.40.4.2 2002/06/11 03:31:37 art Exp $ */
d469 1
a469 1
	;
@


1.40.4.4
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a118 4
		if (hlen < sizeof (struct ip) || m->m_pkthdr.len < hlen) {
			*error = EINVAL;
			return NULL;
		}
a168 4
		if (hlen < sizeof (struct ip6_hdr) || m->m_pkthdr.len < hlen) {
			*error = EINVAL;
			return NULL;
		}
@


1.39
log
@When the outgoing socket has BYPASS set, don't bother calling the
PCB-checking routine.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.38 2001/08/15 09:50:12 niklas Exp $ */
d371 1
@


1.38
log
@bcmp done wrong, detected at bakeoff.  Hint: always use
relational operators when using *cmp APIs in conditional expressions.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.37 2001/08/06 18:46:16 angelos Exp $ */
d330 2
a331 2
			if (!bcmp(&sdst, &ipo->ipo_dst, sdst.sa.sa_len) ||
			    dignore) {
d333 1
a333 2
				return ipsp_spd_inp(m, af, hlen, error,
				    direction, tdbp, inp, ipo);
@


1.37
log
@Don't drop packets if we're using an ACQUIRE policy and some error
occurs while notifying key mgmt; also, always check for new TDBs for
policies where the destination gateway is left unspecified (end-to-end
IPsec case), to avoid asking for new SAs from key mgmt.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.36 2001/06/27 05:35:51 angelos Exp $ */
d287 1
a287 1
			sizeof(in6mask128))))
@


1.36
log
@Use TAILQ_FOREACH() instead of hand-crafted for loops.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.35 2001/06/27 04:44:03 angelos Exp $ */
d394 2
a395 1
			ipo->ipo_last_searched = time.tv_sec;
d428 2
a429 6
			if (ipsp_acquire_sa(ipo,
			    dignore ? &sdst : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, NULL) != 0) {
				*error = EACCES;
				return NULL;
			}
d491 2
a492 2
			    !bcmp(&ipo->ipo_tdb->tdb_src
				, dignore ? &ssrc : &ipo->ipo_dst,
d499 1
d505 2
a506 1
			ipo->ipo_last_searched = time.tv_sec; /* "touch" */
d546 2
a547 4
			if ((*error = ipsp_acquire_sa(ipo,
			    dignore ? &ssrc : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, NULL)) != 0)
				return NULL;
@


1.35
log
@When determining whether there's a pending acquire wrt a policy, look
at the acquires associated with the policy only.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.34 2001/06/27 04:41:32 angelos Exp $ */
d684 1
a684 2
	for (ipa = TAILQ_FIRST(&ipo->ipo_acquires); ipa;
	    ipa = TAILQ_NEXT(ipa, ipa_next)) {
d854 1
a854 2
	for (ipa = TAILQ_FIRST(&ipsec_acquire_head); ipa;
	    ipa = TAILQ_NEXT(ipa, ipa_next))
@


1.34
log
@Attach IPsec acquire state to policy entries, and relevant cleanups.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.33 2001/06/27 01:34:07 angelos Exp $ */
d680 1
a680 1
ipsp_pending_acquire(union sockaddr_union *gw)
d684 1
a684 1
	for (ipa = TAILQ_FIRST(&ipsec_acquire_head); ipa;
d707 1
a707 1
	if ((ipa = ipsp_pending_acquire(gw)) != NULL)
@


1.33
log
@Don't cache packets that hit policies -- we'll do that at the PCB for
local packets.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.32 2001/06/26 23:30:59 angelos Exp $ */
d571 1
d574 1
a574 1
	/* Delete */
d581 1
a581 1
	if (ipo->ipo_tdb)
d585 3
d652 1
d669 3
d724 1
d823 1
d825 2
@


1.32
log
@Use the ACQUIRE sequence number to "wake up" acquire state kept and
cause retransmission of outgoing packets. Also, only store outgoing
packets -- just drop incoming packets that cause an SA
acquisition. Some comment fixup.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.31 2001/06/26 19:57:49 angelos Exp $ */
d223 1
a223 1
	/* Actual SPD lookup */
d317 1
a317 1
	/* Outgoing packet SPD lookup. */
a663 2
	if (ipa->ipa_packet)
		m_freem(ipa->ipa_packet);
a667 52
 * Clear possibly pending ACQUIRE records.
 */
void
ipsp_clear_acquire(struct tdb *tdb)
{
	struct ipsec_acquire *ipa;

	ipa = ipsec_get_acquire(tdb->tdb_seq);
	if (ipa == NULL)
		return;

	/* Just delete and return if no pending packet. */
	if (ipa->ipa_packet == NULL) {
		ipsp_delete_acquire(ipa);
		return;
	}

	/* Retransmit last packet. */
	switch (ipa->ipa_info.sen_type) {
#ifdef INET
	case SENT_IP4:
	{
		struct ip *ip;

		ip = mtod(ipa->ipa_packet, struct ip *);

		if (ipa->ipa_packet->m_len < sizeof(struct ip))
			break;

		/* Same as in ip_output() -- massage the header. */
		ip->ip_len = htons((u_short) ip->ip_len);
		ip->ip_off = htons((u_short) ip->ip_off);

		ipsp_process_packet(ipa->ipa_packet, tdb, AF_INET, 0);
		ipa->ipa_packet = NULL;
		break;
	}
#endif /* INET */

#ifdef INET6
	case SENT_IP6:
		ipsp_process_packet(ipa->ipa_packet, tdb, AF_INET6, 0);
		ipa->ipa_packet = NULL;
		break;
#endif /* INET6 */
	}

	/* Delete. */
	ipsp_delete_acquire(ipa);
}

/*
d699 1
a699 12
	if ((ipa = ipsp_pending_acquire(gw)) != NULL) {
		if ((ipo->ipo_addr.sen_type == SENT_IP4 &&
		    ipo->ipo_addr.sen_direction == IPSP_DIRECTION_OUT) ||
		    (ipo->ipo_addr.sen_type == SENT_IP6 &&
		    ipo->ipo_addr.sen_ip6_direction == IPSP_DIRECTION_OUT)) {
			if (ipa->ipa_packet != NULL && m != NULL) {
				m_freem(ipa->ipa_packet);
				ipa->ipa_packet = m_copym2(m, 0, M_COPYALL,
				    M_DONTWAIT);
			}
		}

a700 1
	}
a812 7
	/*
	 * Store the packet for eventual retransmission -- failure is not
	 * catastrophic.
	 */
	if (m != NULL)
		ipa->ipa_packet = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);

d821 14
a848 14
}

/*
 * Deal with PCB security requirements.
 */
struct tdb *
ipsp_spd_inp(struct mbuf *m, int af, int hlen, int *error, int direction,
    struct tdb *tdbp, struct inpcb *inp, struct ipsec_policy *ipo)
{
	/* XXX */
	if (ipo != NULL)
		return ipo->ipo_tdb;
	else
		return NULL;
@


1.31
log
@ifdef out some currently unused code
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.30 2001/06/26 19:49:29 angelos Exp $ */
d96 3
a98 1
	/* If an input packet is destined to a BYPASS socket, just accept it. */
d133 3
a135 1
		/* If TCP/UDP, extract the port numbers to use in the lookup */
d139 1
a139 1
			/* Make sure there's enough data in the packet */
d186 3
a188 1
		/* If TCP/UDP, extract the port numbers to use in the lookup */
d192 1
a192 1
			/* Make sure there's enough data in the packet */
d235 1
a235 1
	/* Sanity check */
d265 1
a265 1
		/* Nothing more needed here */
d329 1
a329 1
			/* Direct match */
d363 1
a363 1
			/* Match local credentials used */
d371 1
a371 1
			/* Cached entry is good */
d376 1
a376 1
			/* Cached TDB was not good */
d634 4
a637 5
	    RTF_UP | RTF_GATEWAY | RTF_STATIC,
	    (struct rtentry **) 0) != 0) {
	    DPRINTF(("ipsec_add_policy: failed to add policy\n"));
	    pool_put(&ipsec_policy_pool, ipon);
	    return NULL;
d655 1
a655 1
 * Delete a pending ACQUIRE record.
a675 2
	struct ifqueue *ifq;
	int s;
d694 1
a694 10
		switch (ipa->ipa_info.sen_direction) {
		case IPSP_DIRECTION_OUT:
			ip = mtod(ipa->ipa_packet, struct ip *);

			if (ipa->ipa_packet->m_len < sizeof(struct ip))
				break;

			 /* Same as in ip_output() -- massage the header. */
			ip->ip_len = htons((u_short) ip->ip_len);
			ip->ip_off = htons((u_short) ip->ip_off);
d696 1
a696 2
			ipsp_process_packet(ipa->ipa_packet, tdb, AF_INET, 0);
			ipa->ipa_packet = NULL;
d699 7
a705 14
		case IPSP_DIRECTION_IN:
			ifq = &ipintrq;
			s = splimp();
			if (IF_QFULL(ifq)) {
				IF_DROP(ifq);
				splx(s);
				break;
			}
			IF_ENQUEUE(ifq, ipa->ipa_packet);
			ipa->ipa_packet = NULL;
			schednetisr(NETISR_IP);
			splx(s);
			break;
		}
a706 1
	break;
d711 2
a712 20
		switch (ipa->ipa_info.sen_ip6_direction) {
		case IPSP_DIRECTION_OUT:
			ipsp_process_packet(ipa->ipa_packet, tdb, AF_INET6, 0);
			ipa->ipa_packet = NULL;
			break;

		case IPSP_DIRECTION_IN:
			ifq = &ip6intrq;
			s = splimp();
			if (IF_QFULL(ifq)) {
				IF_DROP(ifq);
				splx(s);
				break;
			}
			IF_ENQUEUE(ifq, ipa->ipa_packet);
			ipa->ipa_packet = NULL;
			schednetisr(NETISR_IPV6);
			splx(s);
			break;
		}
d731 1
a731 1
	     ipa = TAILQ_NEXT(ipa, ipa_next)) {
d754 9
a762 4
		if (ipa->ipa_packet && m) {
			m_freem(ipa->ipa_packet);
			ipa->ipa_packet = m_copym2(m, 0, M_COPYALL,
			    M_DONTWAIT);
d903 1
a903 1
	     ipa = TAILQ_NEXT(ipa, ipa_next))
@


1.30
log
@Rewrite ipsp_clear_acquire() to be more readable, after all the KNF'ing
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.29 2001/06/26 19:01:27 angelos Exp $ */
d596 1
d647 1
@


1.29
log
@Use pool(9) for IPsec acquires too.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.28 2001/06/26 18:56:30 angelos Exp $ */
d672 12
a683 4
	while ((ipa = ipsp_pending_acquire(&tdb->tdb_dst)) != NULL) {
		/* Retransmit */
		if (ipa->ipa_packet) {
			switch (ipa->ipa_info.sen_type) {
d685 26
a710 43
			case SENT_IP4:
			{
				struct ip *ip;

				switch (ipa->ipa_info.sen_direction) {
				case IPSP_DIRECTION_OUT:
					ip = mtod(ipa->ipa_packet,
					    struct ip *);

					if (ipa->ipa_packet->m_len <
					    sizeof(struct ip))
						break;

					/*
					 * Same as in ip_output() --
                                         * massage the header.
					 */
					ip->ip_len =
					    htons((u_short) ip->ip_len);
					ip->ip_off =
					    htons((u_short) ip->ip_off);
					ipa->ipa_packet->m_flags &=
					    ~(M_MCAST | M_BCAST);

					ipsp_process_packet(ipa->ipa_packet,
					    tdb, AF_INET, 0);
					ipa->ipa_packet = NULL;
					break;

				case IPSP_DIRECTION_IN:
					ifq = &ipintrq;
					s = splimp();
					if (IF_QFULL(ifq)) {
						IF_DROP(ifq);
						splx(s);
						break;
					}
					IF_ENQUEUE(ifq, ipa->ipa_packet);
					ipa->ipa_packet = NULL;
					schednetisr(NETISR_IP);
					splx(s);
					break;
				}
d712 4
d717 3
d723 13
a735 24
			case SENT_IP6:
				switch (ipa->ipa_info.sen_ip6_direction) {
				case IPSP_DIRECTION_OUT:
					ipa->ipa_packet->m_flags &=
					    ~(M_BCAST | M_MCAST);
					ipsp_process_packet(ipa->ipa_packet,
					    tdb, AF_INET6, 0);
					ipa->ipa_packet = NULL;
					break;

				case IPSP_DIRECTION_IN:
					ifq = &ip6intrq;
					s = splimp();
					if (IF_QFULL(ifq)) {
						IF_DROP(ifq);
						splx(s);
						break;
					}
					IF_ENQUEUE(ifq, ipa->ipa_packet);
					ipa->ipa_packet = NULL;
					schednetisr(NETISR_IPV6);
					splx(s);
					break;
				}
a736 1
#endif /* INET6 */
d738 5
d744 3
d748 2
a749 2
		ipsp_delete_acquire(ipa);
	}
@


1.28
log
@Use pool(9) for IPsec policy structures.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.27 2001/06/26 18:34:40 angelos Exp $ */
d58 1
d60 1
d659 1
a659 1
	FREE(ipa, M_IPSEC_POLICY);
d782 1
a782 2
		union sockaddr_union *laddr, struct sockaddr_encap *ddst,
		struct mbuf *m)
d800 9
a808 3
	/* Add request in cache and proceed */
	MALLOC(ipa, struct ipsec_acquire *, sizeof(struct ipsec_acquire),
	    M_IPSEC_POLICY, M_DONTWAIT);
d819 1
a819 1
	/* Just copy the right information */
d907 1
a907 1
		FREE(ipa, M_IPSEC_POLICY);
d915 1
a915 1
	if (m)
d921 1
a921 1
	/* PF_KEYv2 notification message */
d950 1
a950 1
	if (ipo)
@


1.27
log
@Keep the PFKEY sequence number at the TDB, plus a little bit of KNF
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.26 2001/06/26 03:52:42 angelos Exp $ */
d57 3
d587 1
a587 1
	FREE(ipo, M_IPSEC_POLICY);
d599 1
a599 1
		 union sockaddr_union *sdst, int type, int sproto)
d604 8
a611 2
	MALLOC(ipon, struct ipsec_policy *, sizeof(struct ipsec_policy),
	    M_IPSEC_POLICY, M_NOWAIT);
d628 1
a628 1
	    FREE(ipon, M_IPSEC_POLICY);
@


1.26
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.25 2001/06/25 05:11:59 angelos Exp $ */
d402 2
a403 1
			if (ipsp_acquire_sa(ipo, dignore ? &sdst : &ipo->ipo_dst,
d416 2
a417 1
			if (ipsp_acquire_sa(ipo, dignore ? &sdst : &ipo->ipo_dst,
d483 2
a484 1
			    !bcmp(&ipo->ipo_tdb->tdb_src, dignore ? &ssrc : &ipo->ipo_dst,
d570 2
a571 1
		TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo, ipo_tdb_next);
d679 3
a681 2
					/* Same as in ip_output() --
                                         *  massage the header.
a682 1

@


1.25
log
@Copyright.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.24 2001/06/24 21:50:51 mickey Exp $ */
d52 1
a52 1
#define DPRINTF(x)	if (encdebug) printf x
d54 1
a54 1
#define DPRINTF(x)
d74 1
a74 1
		struct tdb *tdbp, struct inpcb *inp)
d76 14
a89 15
    struct route_enc re0, *re = &re0;
    union sockaddr_union sdst, ssrc;
    struct sockaddr_encap *ddst;
    struct ipsec_policy *ipo;
    int signore = 0, dignore = 0;

    /*
     * If there are no flows in place, there's no point
     * continuing with the SPD lookup.
     */
    if (!ipsec_in_use && inp == NULL)
    {
	*error = 0;
	return NULL;
    }
d91 8
a98 9
    /* If an input packet is destined to a BYPASS socket, just accept it */
    if ((inp != NULL) && (direction == IPSP_DIRECTION_IN) &&
	(inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS) &&
	(inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS) &&
	(inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS))
    {
	*error = 0;
	return NULL;
    }
d100 6
a105 6
    bzero((caddr_t) re, sizeof(struct route_enc));
    bzero((caddr_t) &sdst, sizeof(union sockaddr_union));
    bzero((caddr_t) &ssrc, sizeof(union sockaddr_union));
    ddst = (struct sockaddr_encap *) &re->re_dst;
    ddst->sen_family = PF_KEY;
    ddst->sen_len = SENT_LEN;
d107 1
a107 2
    switch (af)
    {
d110 15
a124 2
	    ddst->sen_direction = direction;
	    ddst->sen_type = SENT_IP4;
d126 2
a127 15
	    m_copydata(m, offsetof(struct ip, ip_src),
		       sizeof(struct in_addr), (caddr_t) &(ddst->sen_ip_src));
	    m_copydata(m, offsetof(struct ip, ip_dst),
		       sizeof(struct in_addr), (caddr_t) &(ddst->sen_ip_dst));
	    m_copydata(m, offsetof(struct ip, ip_p), sizeof(u_int8_t),
		       (caddr_t) &(ddst->sen_proto));

	    sdst.sin.sin_family = ssrc.sin.sin_family = AF_INET;
	    sdst.sin.sin_len = ssrc.sin.sin_len = sizeof(struct sockaddr_in);
	    ssrc.sin.sin_addr = ddst->sen_ip_src;
	    sdst.sin.sin_addr = ddst->sen_ip_dst;

	    /* If TCP/UDP, extract the port numbers to use in the lookup */
	    switch (ddst->sen_proto)
	    {
d130 17
a146 17
		    /* Make sure there's enough data in the packet */
		    if (m->m_pkthdr.len < hlen + 2 * sizeof(u_int16_t))
		    {
			*error = EINVAL;
			return NULL;
		    }

		    /*
		     * Luckily, the offset of the src/dst ports in both the UDP
		     * and TCP headers is the same (first two 16-bit values
		     * in the respective headers), so we can just copy them.
		     */
		    m_copydata(m, hlen, sizeof(u_int16_t),
			       (caddr_t) &(ddst->sen_sport));
		    m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			       (caddr_t) &(ddst->sen_dport));
		    break;
d149 3
a151 3
		    ddst->sen_sport = 0;
		    ddst->sen_dport = 0;
	    }
d153 1
a153 1
	    break;
d158 18
a175 2
	    ddst->sen_type = SENT_IP6;
	    ddst->sen_ip6_direction = direction;
d177 2
a178 18
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
		       sizeof(struct in6_addr),
		       (caddr_t) &(ddst->sen_ip6_src));
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		       sizeof(struct in6_addr),
		       (caddr_t) &(ddst->sen_ip6_dst));
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_nxt), sizeof(u_int8_t),
		       (caddr_t) &(ddst->sen_ip6_proto));

	    sdst.sin6.sin6_family = ssrc.sin6.sin6_family = AF_INET6;
	    sdst.sin6.sin6_len = ssrc.sin6.sin6_family =
				sizeof(struct sockaddr_in6);
	    ssrc.sin6.sin6_addr = ddst->sen_ip6_src;
	    sdst.sin6.sin6_addr = ddst->sen_ip6_dst;

	    /* If TCP/UDP, extract the port numbers to use in the lookup */
	    switch (ddst->sen_ip6_proto)
	    {
d181 17
a197 17
		    /* Make sure there's enough data in the packet */
		    if (m->m_pkthdr.len < hlen + 2 * sizeof(u_int16_t))
		    {
			*error = EINVAL;
			return NULL;
		    }

		    /*
		     * Luckily, the offset of the src/dst ports in both the UDP
		     * and TCP headers is the same (first two 16-bit values
		     * in the respective headers), so we can just copy them.
		     */
		    m_copydata(m, hlen, sizeof(u_int16_t),
			       (caddr_t) &(ddst->sen_ip6_sport));
		    m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			       (caddr_t) &(ddst->sen_ip6_dport));
		    break;
d200 3
a202 3
		    ddst->sen_ip6_sport = 0;
		    ddst->sen_ip6_dport = 0;
	    }
d204 1
a204 1
	    break;
d208 24
a231 3
	    *error = EAFNOSUPPORT;
	    return NULL;
    }
d233 1
a233 13
    /* Actual SPD lookup */
    rtalloc((struct route *) re);
    if (re->re_rt == NULL)
    {
	*error = 0;
	return NULL; /* Nothing found -- means no IPsec needed */
    }

    /* Sanity check */
    if ((re->re_rt->rt_gateway == NULL) ||
	(((struct sockaddr_encap *) re->re_rt->rt_gateway)->sen_type !=
	 SENT_IPSP))
    {
d235 4
a238 11
	*error = EHOSTUNREACH;
	return NULL;
    }

    ipo = ((struct sockaddr_encap *) (re->re_rt->rt_gateway))->sen_ipsp;
    RTFREE(re->re_rt);
    if (ipo == NULL)
    {
	*error = EHOSTUNREACH;
	return NULL;
    }
d240 1
a240 2
    switch (ipo->ipo_type)
    {
d242 3
a244 2
	    *error = 0;
	    return NULL;
d247 2
a248 2
	    *error = EHOSTUNREACH;
	    return NULL;
d254 2
a255 2
	    /* Nothing more needed here */
	    break;
d258 3
a260 3
	    *error = EINVAL;
	    return NULL;
    }
d262 2
a263 3
    /* Check for non-specific destination in the policy. */
    switch (ipo->ipo_dst.sa.sa_family)
    {
d266 4
a269 4
	    if ((ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_ANY) ||
		(ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_BROADCAST))
	      dignore = 1;
	    break;
d274 5
a278 5
	    if ((IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr)) ||
		(bcmp(&ipo->ipo_dst.sin6.sin6_addr, &in6mask128,
		       sizeof(in6mask128))))
	      dignore = 1;
	    break;
d280 1
a280 1
    }
d282 2
a283 3
    /* Likewise for source. */
    switch (ipo->ipo_src.sa.sa_family)
    {
d286 3
a288 3
	    if (ipo->ipo_src.sin.sin_addr.s_addr == INADDR_ANY)
	      signore = 1;
	    break;
d293 3
a295 3
	    if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_src.sin6.sin6_addr))
	      signore = 1;
	    break;
d297 1
a297 1
    }
d299 5
a303 25
    /* Do we have a cached entry ? If so, check if it's still valid. */
    if ((ipo->ipo_tdb) && (ipo->ipo_tdb->tdb_flags & TDBF_INVALID))
    {
	TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo, ipo_tdb_next);
	ipo->ipo_tdb = NULL;
    }

    /* Outgoing packet SPD lookup */
    if (direction == IPSP_DIRECTION_OUT)
    {
	/*
	 * If the packet is destined for the policy-specified gateway/endhost,
	 * and the socket has the BYPASS option set, skip IPsec processing.
	 */
	if ((inp != NULL) &&
	    (inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS) &&
	    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS) &&
	    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS))
	{
	    /* Direct match */
	    if (!bcmp(&sdst, &ipo->ipo_dst, sdst.sa.sa_len) || dignore)
	    {
		*error = 0;
		return NULL;
	    }
d306 20
a325 33
	/* Check that the cached TDB (if present), is appropriate */
	if (ipo->ipo_tdb)
	{
	    if ((ipo->ipo_last_searched <= ipsec_last_added) ||
		(ipo->ipo_sproto != ipo->ipo_tdb->tdb_sproto) ||
		bcmp(dignore ? &sdst : &ipo->ipo_dst, &ipo->ipo_tdb->tdb_dst,
		     ipo->ipo_tdb->tdb_dst.sa.sa_len))
	      goto nomatchout;

	    /* Match source ID */
	    if (ipo->ipo_srcid)
	    {
		if (ipo->ipo_tdb->tdb_srcid == NULL ||
		    !ipsp_ref_match(ipo->ipo_srcid, ipo->ipo_tdb->tdb_srcid))
		  goto nomatchout;
	    }

	    /* Match destination ID */
	    if (ipo->ipo_dstid)
	    {
		if (ipo->ipo_tdb->tdb_dstid == NULL ||
		    !ipsp_ref_match(ipo->ipo_dstid, ipo->ipo_tdb->tdb_dstid))
		  goto nomatchout;
	    }

	    /* Match local credentials used */
	    if (ipo->ipo_local_cred)
	    {
		if (ipo->ipo_tdb->tdb_local_cred == NULL ||
		    !ipsp_ref_match(ipo->ipo_local_cred, 
				    ipo->ipo_tdb->tdb_local_cred))
		  goto nomatchout;
	    }
d327 36
a362 1
	    return ipo->ipo_tdb; /* Cached entry is good, we're done */
d365 6
a370 5
	    /* Cached TDB was not good */
	    TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo, ipo_tdb_next);
	    ipo->ipo_tdb = NULL;
	    ipo->ipo_last_searched = 0;
	}
d372 25
a396 24
	/*
	 * If no SA has been added since the last time we did a
	 * lookup, there's no point searching for one. However, if the
	 * destination gateway is left unspecified (or is all-1's),
	 * always lookup since this is a generic-match rule
	 * (otherwise, we can have situations where SAs to some
	 * destinations exist but are not used, possibly leading to an
	 * explosion in the number of acquired SAs).
	 */
	if (ipo->ipo_last_searched <= ipsec_last_added)
	{
	    ipo->ipo_last_searched = time.tv_sec; /* "touch" the entry */

	    /* Find an appropriate SA from among the existing SAs */
	    ipo->ipo_tdb = gettdbbyaddr(dignore ? &sdst : &ipo->ipo_dst,
					ipo, m, af);
	    if (ipo->ipo_tdb)
	    {
		TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head, ipo,
				  ipo_tdb_next);
		*error = 0;
		return ipo->ipo_tdb;
	    }
	}
d398 14
a411 17
	/* So, we don't have an SA -- just a policy */
	switch (ipo->ipo_type)
	{
	    case IPSP_IPSEC_REQUIRE:
		/* Acquire SA through key management */
		if (ipsp_acquire_sa(ipo, dignore ? &sdst : &ipo->ipo_dst,
				    signore ? NULL : &ipo->ipo_src,
				    ddst, m) != 0)
                {
                    *error = EACCES;
		    return NULL;
                }

		/* Fall through */
	    case IPSP_IPSEC_DONTACQ:
		*error = -EINVAL; /* Silently drop packet */
		return NULL;
d413 54
a466 25
	    case IPSP_IPSEC_ACQUIRE:
		/* Acquire SA through key management */
		if (ipsp_acquire_sa(ipo, dignore ? &sdst : &ipo->ipo_dst,
				    signore ? NULL : &ipo->ipo_src,
				    ddst, NULL) != 0)
                {
                    *error = EACCES;
		    return NULL;
                }

		/* Fall through */
	    case IPSP_IPSEC_USE:
		*error = 0;  /* Let packet through */
		return NULL;
	}
    }
    else /* IPSP_DIRECTION_IN */
    {
	if (tdbp != NULL)
	{
	    if (ipo->ipo_tdb == tdbp)
	    {
		*error = 0; /* Accept packet */
		return NULL;
	    }
d468 2
a469 28
	    if (bcmp(dignore ? &ssrc : &ipo->ipo_dst, &tdbp->tdb_src,
		     tdbp->tdb_src.sa.sa_len) ||
		(ipo->ipo_sproto != tdbp->tdb_sproto))
	      goto nomatchin;

	    /* Match source ID */
	    if (ipo->ipo_srcid)
	    {
		if (tdbp->tdb_dstid == NULL ||
		    !ipsp_ref_match(ipo->ipo_srcid, tdbp->tdb_dstid))
		  goto nomatchin;
	    }

	    /* Match destination ID */
	    if (ipo->ipo_dstid)
	    {
		if (tdbp->tdb_srcid == NULL ||
		    !ipsp_ref_match(ipo->ipo_dstid, tdbp->tdb_srcid))
		  goto nomatchin;
	    }

	    /* Add it to the cache */
	    if (ipo->ipo_tdb)
	      TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo, ipo_tdb_next);
	    ipo->ipo_tdb = tdbp;
	    TAILQ_INSERT_TAIL(&tdbp->tdb_policy_head, ipo, ipo_tdb_next);
	    *error = 0;
	    return NULL;
d471 19
a489 2
  nomatchin: /* Nothing needed here, falling through */
	}
d491 11
a501 29
	/* Check whether cached entry applies */
	if (ipo->ipo_tdb)
	{
	    /*
	     * We only need to check that the correct security protocol and
	     * security gateway are set; credentials/IDs will be the same,
	     * since the cached entry is linked on this policy.
	     */
	    if (ipo->ipo_sproto == ipo->ipo_tdb->tdb_sproto &&
		!bcmp(&ipo->ipo_tdb->tdb_src, dignore ? &ssrc : &ipo->ipo_dst,
		      ipo->ipo_tdb->tdb_src.sa.sa_len))
	      goto skipinputsearch;

	    /* Not applicable, unlink */
	    TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo, ipo_tdb_next);
	    ipo->ipo_tdb = NULL;
	}

	/* Find whether there exists an appropriate SA */
	if (ipo->ipo_last_searched <= ipsec_last_added)
	{
	    ipo->ipo_last_searched = time.tv_sec; /* "touch" */

	    ipo->ipo_tdb = gettdbbysrc(dignore ? &ssrc : &ipo->ipo_dst,
				       ipo, m, af);
	    if (ipo->ipo_tdb)
	      TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head, ipo,
				ipo_tdb_next);
	}
d504 19
a522 22
	switch (ipo->ipo_type)
	{
	    case IPSP_IPSEC_REQUIRE:
	        /* If an appropriate SA exists, don't acquire another */
		if (ipo->ipo_tdb)
		{
		    *error = -EINVAL;
		    return NULL;
		}

		/* Acquire SA through key management */
		if ((*error = ipsp_acquire_sa(ipo,
					      dignore ? &ssrc : &ipo->ipo_dst,
					      signore ? NULL : &ipo->ipo_src,
					      ddst, m)) != 0)
		  return NULL;

		/* Fall through */
	    case IPSP_IPSEC_DONTACQ:
		/* Drop packet */
		*error = -EINVAL;
		return NULL;
d524 20
a543 26
	    case IPSP_IPSEC_ACQUIRE:
	        /* If an appropriate SA exists, don't acquire another */
		if (ipo->ipo_tdb)
		{
		    *error = 0;
		    return NULL;
		}

		/* Acquire SA through key management */
		if ((*error = ipsp_acquire_sa(ipo,
					      dignore ? &ssrc : &ipo->ipo_dst,
					      signore ? NULL : &ipo->ipo_src,
					      ddst, NULL)) != 0)
		  return NULL;

		/* Fall through */
	    case IPSP_IPSEC_USE:
		/*
		 * It doesn't matter what protection it had (if any),
		 * just accept it -- equivalent to PERMIT for input.
		 * This means we can't say that we want in incoming
		 * packet to be unprotected -- at least not directly;
		 * we can always have a DENY policy for ESP/AH packets.
		 */
		*error = 0;
		return NULL;
a544 1
    }
d546 3
a548 3
    /* Shouldn't ever get this far */
    *error = EINVAL;
    return NULL;
d557 1
a557 1
    int err = 0;
d559 6
a564 20
    /* Delete */
    if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
      err = rtrequest(RTM_DELETE, (struct sockaddr *) &ipo->ipo_addr,
		      (struct sockaddr *) 0,
		      (struct sockaddr *) &ipo->ipo_mask,
		      0, (struct rtentry **) 0);

    if (ipo->ipo_tdb)
      TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo, ipo_tdb_next);

    TAILQ_REMOVE(&ipsec_policy_head, ipo, ipo_list);

    if (ipo->ipo_srcid)
      ipsp_reffree(ipo->ipo_srcid);
    if (ipo->ipo_dstid)
      ipsp_reffree(ipo->ipo_dstid);
    if (ipo->ipo_local_cred)
      ipsp_reffree(ipo->ipo_local_cred);
    if (ipo->ipo_local_auth)
      ipsp_reffree(ipo->ipo_local_cred);
d566 13
a578 1
    FREE(ipo, M_IPSEC_POLICY);
d580 1
a580 1
    ipsec_in_use--;
d582 3
a584 1
    return err;
d594 2
a595 2
    struct sockaddr_encap encapgw;
    struct ipsec_policy *ipon;
d597 21
a617 22
    MALLOC(ipon, struct ipsec_policy *, sizeof(struct ipsec_policy),
	   M_IPSEC_POLICY, M_NOWAIT);
    if (ipon == NULL)
      return NULL;

    bzero(ipon, sizeof(struct ipsec_policy));
    bzero((caddr_t) &encapgw, sizeof(struct sockaddr_encap));

    encapgw.sen_len = SENT_LEN;
    encapgw.sen_family = PF_KEY;
    encapgw.sen_type = SENT_IPSP;
    encapgw.sen_ipsp = ipon;

    if (rtrequest(RTM_ADD, (struct sockaddr *) dst,
		  (struct sockaddr *) &encapgw, (struct sockaddr *) mask,
		  RTF_UP | RTF_GATEWAY | RTF_STATIC,
		  (struct rtentry **) 0) != 0)
    {
        DPRINTF(("ipsec_add_policy: failed to add policy\n"));
	FREE(ipon, M_IPSEC_POLICY);
	return NULL;
    }
d619 1
a619 1
    ipsec_in_use++;
d621 5
a625 5
    bcopy(dst, &ipon->ipo_addr, sizeof(struct sockaddr_encap));
    bcopy(mask, &ipon->ipo_mask, sizeof(struct sockaddr_encap));
    bcopy(sdst, &ipon->ipo_dst, sizeof(union sockaddr_union));
    ipon->ipo_sproto = sproto;
    ipon->ipo_type = type;
d627 1
a627 1
    TAILQ_INSERT_HEAD(&ipsec_policy_head, ipon, ipo_list);
d629 1
a629 1
    return ipon;
d638 1
a638 1
    struct ipsec_acquire *ipa = v;
d640 5
a644 5
    timeout_del(&ipa->ipa_timeout);
    TAILQ_REMOVE(&ipsec_acquire_head, ipa, ipa_next);
    if (ipa->ipa_packet)
      m_freem(ipa->ipa_packet);
    FREE(ipa, M_IPSEC_POLICY);
d653 8
a660 12
    struct ipsec_acquire *ipa;
    struct ifqueue *ifq;
    int s;

    while ((ipa = ipsp_pending_acquire(&tdb->tdb_dst)) != NULL)
    {

	/* Retransmit */
	if (ipa->ipa_packet)
	{
	    switch (ipa->ipa_info.sen_type)
	    {
d662 45
a706 38
		case SENT_IP4:
		{
		    struct ip *ip;

		    switch (ipa->ipa_info.sen_direction)
		    {
			case IPSP_DIRECTION_OUT:
			    ip = mtod(ipa->ipa_packet, struct ip *);
			    if (ipa->ipa_packet->m_len < sizeof(struct ip))
			      break;

			    /* Same as in ip_output() -- massage the header */
			    ip->ip_len = htons((u_short) ip->ip_len);
			    ip->ip_off = htons((u_short) ip->ip_off);
			    ipa->ipa_packet->m_flags &= ~(M_MCAST | M_BCAST);

			    ipsp_process_packet(ipa->ipa_packet, tdb,
						AF_INET, 0);
			    ipa->ipa_packet = NULL;
			    break;

			case IPSP_DIRECTION_IN:
			    ifq = &ipintrq;
			    s = splimp();
			    if (IF_QFULL(ifq))
			    {
				IF_DROP(ifq);
				splx(s);
				break;
			    }
			    IF_ENQUEUE(ifq, ipa->ipa_packet);
			    ipa->ipa_packet = NULL;
			    schednetisr(NETISR_IP);
			    splx(s);
			    break;
		    }
		}
		 break;
d710 24
a733 17
		case SENT_IP6:
		    switch (ipa->ipa_info.sen_ip6_direction)
		    {
			case IPSP_DIRECTION_OUT:
			    ipa->ipa_packet->m_flags &= ~(M_BCAST | M_MCAST);
			    ipsp_process_packet(ipa->ipa_packet, tdb,
						AF_INET6, 0);
			    ipa->ipa_packet = NULL;
			    break;

			case IPSP_DIRECTION_IN:
			    ifq = &ip6intrq;
			    s = splimp();
			    if (IF_QFULL(ifq))
			    {
				IF_DROP(ifq);
				splx(s);
a734 8
			    }
			    IF_ENQUEUE(ifq, ipa->ipa_packet);
			    ipa->ipa_packet = NULL;
			    schednetisr(NETISR_IPV6);
			    splx(s);
			    break;
		    }
		    break;
d736 4
a739 1
	    }
a740 3

	ipsp_delete_acquire(ipa);
    }
d750 1
a750 1
    struct ipsec_acquire *ipa;
d752 5
a756 7
    for (ipa = TAILQ_FIRST(&ipsec_acquire_head);
	 ipa;
	 ipa = TAILQ_NEXT(ipa, ipa_next))
    {
	if (!bcmp(gw, &ipa->ipa_addr, gw->sa.sa_len))
	  return ipa;
    }
d758 1
a758 1
    return NULL;
d770 1
a770 1
    struct ipsec_acquire *ipa;
d772 1
a772 1
    int i;
d775 26
a800 28
    /* Check whether request has been made already. */
    if ((ipa = ipsp_pending_acquire(gw)) != NULL)
    {
	if (ipa->ipa_packet && m)
	{
	    m_freem(ipa->ipa_packet);
	    ipa->ipa_packet = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);
	}

	return 0;
    }

    /* Add request in cache and proceed */
    MALLOC(ipa, struct ipsec_acquire *, sizeof(struct ipsec_acquire),
	   M_IPSEC_POLICY, M_DONTWAIT);
    if (ipa == NULL)
      return ENOMEM;

    bzero(ipa, sizeof(struct ipsec_acquire));
    bcopy(gw, &ipa->ipa_addr, sizeof(union sockaddr_union));
    timeout_set(&ipa->ipa_timeout, ipsp_delete_acquire, ipa);

    ipa->ipa_info.sen_len = ipa->ipa_mask.sen_len = SENT_LEN;
    ipa->ipa_info.sen_family = ipa->ipa_mask.sen_family = PF_KEY;

    /* Just copy the right information */
    switch (ipo->ipo_addr.sen_type)
    {
d803 35
a837 42
	    ipa->ipa_info.sen_type = ipa->ipa_mask.sen_type = SENT_IP4;
	    ipa->ipa_info.sen_direction = ipo->ipo_addr.sen_direction;
	    ipa->ipa_mask.sen_direction = ipo->ipo_mask.sen_direction;

	    if (ipo->ipo_mask.sen_ip_src.s_addr == INADDR_ANY ||
		ipo->ipo_addr.sen_ip_src.s_addr == INADDR_ANY ||
		ipsp_is_unspecified(ipo->ipo_dst))
	    {
		ipa->ipa_info.sen_ip_src = ddst->sen_ip_src;
		ipa->ipa_mask.sen_ip_src.s_addr = INADDR_BROADCAST;
	    }
	    else
	    {
		ipa->ipa_info.sen_ip_src = ipo->ipo_addr.sen_ip_src;
		ipa->ipa_mask.sen_ip_src = ipo->ipo_mask.sen_ip_src;
	    }

	    if (ipo->ipo_mask.sen_ip_dst.s_addr == INADDR_ANY ||
		ipo->ipo_addr.sen_ip_dst.s_addr == INADDR_ANY ||
		ipsp_is_unspecified(ipo->ipo_dst))
	    {
		ipa->ipa_info.sen_ip_dst = ddst->sen_ip_dst;
		ipa->ipa_mask.sen_ip_dst.s_addr = INADDR_BROADCAST;
	    }
	    else
	    {
		ipa->ipa_info.sen_ip_dst = ipo->ipo_addr.sen_ip_dst;
		ipa->ipa_mask.sen_ip_dst = ipo->ipo_mask.sen_ip_dst;
	    }

	    ipa->ipa_info.sen_proto = ipo->ipo_addr.sen_proto;
	    ipa->ipa_mask.sen_proto = ipo->ipo_mask.sen_proto;

	    if (ipo->ipo_addr.sen_proto)
	    {
		ipa->ipa_info.sen_sport = ipo->ipo_addr.sen_sport;
		ipa->ipa_mask.sen_sport = ipo->ipo_mask.sen_sport;

		ipa->ipa_info.sen_dport = ipo->ipo_addr.sen_dport;
		ipa->ipa_mask.sen_dport = ipo->ipo_mask.sen_dport;
	    }
	    break;
d842 42
a883 43
	    ipa->ipa_info.sen_type = ipa->ipa_mask.sen_type = SENT_IP6;
	    ipa->ipa_info.sen_ip6_direction = ipo->ipo_addr.sen_ip6_direction;
	    ipa->ipa_mask.sen_ip6_direction = ipo->ipo_mask.sen_ip6_direction;

	    if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_mask.sen_ip6_src) ||
		IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_addr.sen_ip6_src) ||
		ipsp_is_unspecified(ipo->ipo_dst))
	    {
		ipa->ipa_info.sen_ip6_src = ddst->sen_ip6_src;
		for (i = 0; i < 16; i++)
		  ipa->ipa_mask.sen_ip6_src.s6_addr8[i] = 0xff;
	    }
	    else
	    {
		ipa->ipa_info.sen_ip6_src = ipo->ipo_addr.sen_ip6_src;
		ipa->ipa_mask.sen_ip6_src = ipo->ipo_mask.sen_ip6_src;
	    }

	    if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_mask.sen_ip6_dst) ||
		IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_addr.sen_ip6_dst) ||
		ipsp_is_unspecified(ipo->ipo_dst))
	    {
		ipa->ipa_info.sen_ip6_dst = ddst->sen_ip6_dst;
		for (i = 0; i < 16; i++)
		  ipa->ipa_mask.sen_ip6_dst.s6_addr8[i] = 0xff;
	    }
	    else
	    {
		ipa->ipa_info.sen_ip6_dst = ipo->ipo_addr.sen_ip6_dst;
		ipa->ipa_mask.sen_ip6_dst = ipo->ipo_mask.sen_ip6_dst;
	    }

	    ipa->ipa_info.sen_ip6_proto = ipo->ipo_addr.sen_ip6_proto;
	    ipa->ipa_mask.sen_ip6_proto = ipo->ipo_mask.sen_ip6_proto;

	    if (ipo->ipo_mask.sen_ip6_proto)
	    {
		ipa->ipa_info.sen_ip6_sport = ipo->ipo_addr.sen_ip6_sport;
		ipa->ipa_mask.sen_ip6_sport = ipo->ipo_mask.sen_ip6_sport;
		ipa->ipa_info.sen_ip6_dport = ipo->ipo_addr.sen_ip6_dport;
		ipa->ipa_mask.sen_ip6_dport = ipo->ipo_mask.sen_ip6_dport;
	    }
	    break;
d887 3
a889 10
	    FREE(ipa, M_IPSEC_POLICY);
	    return 0;
    }

    /*
     * Store the packet for eventual retransmission -- failure is not
     * catastrophic.
     */
    if (m)
      ipa->ipa_packet = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);
d891 6
a896 2
    timeout_add(&ipa->ipa_timeout, ipsec_expire_acquire * hz);
    TAILQ_INSERT_TAIL(&ipsec_acquire_head, ipa, ipa_next);
d898 5
a902 2
    /* PF_KEYv2 notification message */
    return pfkeyv2_acquire(ipo, gw, laddr, &ipa->ipa_seq, ddst);
d912 1
a912 1
    struct ipsec_acquire *ipa;
d914 4
a917 5
    for (ipa = TAILQ_FIRST(&ipsec_acquire_head);
	 ipa;
	 ipa = TAILQ_NEXT(ipa, ipa_next))
      if (ipa->ipa_seq == seq)
	return ipa;
d919 15
a933 1
    return NULL;
@


1.24
log
@use new timeouts for spd expirations; ho@@ ok
@
text
@d1 1
a1 2
/* $OpenBSD: ip_spd.c,v 1.23 2001/06/08 03:13:14 angelos Exp $ */

d5 1
a5 1
 * Copyright (c) 2000 Angelos D. Keromytis.
d7 1
a7 1
 * Permission to use, copy, and modify this software without fee
@


1.23
log
@Trim include files.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.22 2001/06/07 16:19:47 angelos Exp $ */
d11 1
a11 1
 * modification of this software. 
d648 1
a648 1
ipsp_delete_acquire(struct ipsec_acquire *ipa)
d650 3
a753 28
 * Expire old acquire requests to key management.
 */
void
ipsp_acquire_expirations(void *arg)
{
    struct ipsec_acquire *ipa;

    for (ipa = TAILQ_FIRST(&ipsec_acquire_head);
	 ipa;
	 ipa = TAILQ_FIRST(&ipsec_acquire_head))
    {
	if (ipa->ipa_expire <= time.tv_sec)
	  ipsp_delete_acquire(ipa); /* Delete */
	else
	{
	    /* Schedule us for another expiration */
	    timeout(ipsp_acquire_expirations, (void *) NULL,
		    hz * (ipa->ipa_expire - time.tv_sec));
	    return;
	}
    }

    /* If there's no request pending, we don't need to schedule us */

    return;
}

/*
d807 1
d920 1
a920 1
    ipa->ipa_expire = time.tv_sec + ipsec_expire_acquire;
a921 4

    if (TAILQ_FIRST(&ipsec_acquire_head) == ipa)
      timeout(ipsp_acquire_expirations, (void *) NULL,
	      hz * (ipa->ipa_expire - time.tv_sec));
@


1.22
log
@Simplify SPD logic (and correct some input cases).
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.21 2001/05/30 12:22:15 angelos Exp $ */
a25 1
#include <sys/malloc.h>
a27 1
#include <sys/errno.h>
a28 3
#include <sys/queue.h>

#include <machine/cpu.h>
d49 1
a50 2

#include <netinet/ip_ipsp.h>
@


1.21
log
@Match prototype.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.20 2001/05/30 10:59:03 angelos Exp $ */
a234 1
	DPRINTF(("ipsp_spd_lookup(): no gw, or gw data not IPSP\n"));
a243 1
	DPRINTF(("ipsp_spd_lookup(): no policy present\n"));
d270 1
a270 5
    /*
     * Check for non-specific destination in the policy. If a specific
     * destination was specified, use that -- otherwise, use the relevant
     * information from the packet.
     */
d275 2
a276 9
	    if ((ipo->ipo_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
		(ipo->ipo_dst.sin.sin_addr.s_addr != INADDR_BROADCAST))
	    {
		if (direction == IPSP_DIRECTION_OUT)
		  bcopy(&ipo->ipo_dst, &sdst, sizeof(union sockaddr_union));
		else
		  bcopy(&ipo->ipo_dst, &ssrc, sizeof(union sockaddr_union));
	    }
	    else
d283 2
a284 2
	    if ((!IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr)) &&
		(!bcmp(&ipo->ipo_dst.sin6.sin6_addr, &in6mask128,
a285 7
	    {
		if (direction == IPSP_DIRECTION_OUT)
		  bcopy(&ipo->ipo_dst, &sdst, sizeof(union sockaddr_union));
		else
		  bcopy(&ipo->ipo_dst, &ssrc, sizeof(union sockaddr_union));
	    }
	    else
d291 1
d296 2
a297 9
	    if (ipo->ipo_src.sin.sin_addr.s_addr != INADDR_ANY)
	    {
		if (direction == IPSP_DIRECTION_OUT)
		  bcopy(&ipo->ipo_src, &ssrc, sizeof(union sockaddr_union));
		else
		  bcopy(&ipo->ipo_src, &sdst, sizeof(union sockaddr_union));
	    }
            else
              signore = 1;
d303 2
a304 9
	    if (!IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_src.sin6.sin6_addr))
	    {
		if (direction == IPSP_DIRECTION_OUT)
		  bcopy(&ipo->ipo_src, &ssrc, sizeof(union sockaddr_union));
		else
		  bcopy(&ipo->ipo_src, &sdst, sizeof(union sockaddr_union));
	    }
            else
              signore = 1;
d329 1
a329 1
	    if (bcmp(&sdst, &ipo->ipo_dst, sdst.sa.sa_len) == 0)
a333 27

	    /* Same-host */
	    switch (ipo->ipo_dst.sa.sa_family)
	    {
#ifdef INET
		case AF_INET:
		    if ((ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_ANY) ||
			(ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_BROADCAST))
		    {
			*error = 0;
			return NULL;
		    }
		    break;
#endif /* INET */

#ifdef INET6
		case AF_INET6:
		    if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr) ||
			!bcmp(&ipo->ipo_dst.sin6.sin6_addr, &in6mask128,
			      sizeof(in6mask128)))
		    {
			*error = 0;
			return NULL;
		    }
		    break;
#endif /* INET6 */
	    }
d339 8
a346 2
	    if (bcmp(&sdst, &ipo->ipo_tdb->tdb_dst, sdst.sa.sa_len) ||
		(ipo->ipo_last_searched <= ipsec_last_added))
d348 4
a351 4
		TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
			     ipo_tdb_next);
		ipo->ipo_tdb = NULL;
		ipo->ipo_last_searched = 0;
d353 6
a358 1
		/* Fall through to acquisition of TDB */
d360 3
a362 1
	    else
d364 4
a367 1
		return ipo->ipo_tdb; /* Cached entry is good, we're done */
d369 8
d388 1
a388 30
	if (
#ifdef INET
	    ((ipo->ipo_dst.sa.sa_family == AF_INET) &&
	     (ipo->ipo_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
	     (ipo->ipo_dst.sin.sin_addr.s_addr != INADDR_BROADCAST)) ||
#endif /* INET */
#ifdef INET6
	    ((ipo->ipo_dst.sa.sa_family == AF_INET6) &&
	     !IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr) &&
	     bcmp(&ipo->ipo_dst.sin6.sin6_addr, &in6mask128,
		  sizeof(in6mask128))) ||
#endif /* INET6 */
	    0)
	{
	    if (ipo->ipo_last_searched <= ipsec_last_added)
	    {
		ipo->ipo_last_searched = time.tv_sec; /* "touch" the entry */

		/* Find an appropriate SA from among the existing SAs */
		ipo->ipo_tdb = gettdbbyaddr(&sdst, ipo, m, af);
		if (ipo->ipo_tdb)
		{
		    TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head, ipo,
				      ipo_tdb_next);
		    *error = 0;
		    return ipo->ipo_tdb;
		}
	    }
	}
	else
d393 2
a394 1
	    ipo->ipo_tdb = gettdbbyaddr(&sdst, ipo, m, af);
d409 2
a410 1
		if (ipsp_acquire_sa(ipo, &sdst, signore ? NULL : &ssrc,
a417 1

d424 2
a425 1
		if (ipsp_acquire_sa(ipo, &sdst, signore ? NULL : &ssrc,
a432 1

d440 42
a481 5
	/* Check the cached entry */
	if ((ipo->ipo_tdb) &&
	    (((ipo->ipo_tdb->tdb_src.sa.sa_family != 0) &&
	      bcmp(&ssrc, &ipo->ipo_tdb->tdb_src, ssrc.sa.sa_len)) ||
	     (ipo->ipo_last_searched <= ipsec_last_added)))
d483 11
a495 1
	    ipo->ipo_last_searched = 0;
d498 2
a499 1
	switch (ipo->ipo_type)
d501 1
a501 8
	    case IPSP_IPSEC_DONTACQ:
		/* Does protection match stated policy ? */
		if (tdbp && ipsp_match_policy(tdbp, ipo, m, af))
		{
		    /* Accept packet */
		    *error = 0;
		    return NULL;
		}
d503 7
a509 3
		/* Silently drop packet */
		*error = EHOSTUNREACH;
		return NULL;
d511 2
d514 1
a514 8
		if (tdbp && ipsp_match_policy(tdbp, ipo, m, af))
		{
		    /* Accept packet */
		    *error = 0;
		    return NULL;
		}

		/* If we have a cached entry, just discard the packet */
d517 1
a517 1
		    *error = EHOSTUNREACH;
a520 21
		/*
		 * Find whether there exists an appropriate SA. If so, drop
		 * the packet. Otherwise, try to acquire one (from below).
		 *
		 * If no SA has been added since the last time we did a lookup,
		 * there's no point searching for one.
		 */
		if (ipo->ipo_last_searched <= ipsec_last_added)
		{
		    ipo->ipo_last_searched = time.tv_sec; /* "touch" */

		    if ((ipo->ipo_tdb = gettdbbysrc(&ssrc, ipo,
						    m, af)) != NULL)
		    {
			TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head, ipo,
					  ipo_tdb_next);
			*error = EHOSTUNREACH;
			return NULL;
		    }
		}

d522 3
a524 2
		if ((*error = ipsp_acquire_sa(ipo, &ssrc,
					      dignore ? NULL : &sdst,
d528 3
a533 11
	    case IPSP_IPSEC_USE:
		/*
		 * It doesn't matter what protection it had (if any),
		 * just accept it -- equivalent to PERMIT for input.
		 * This means we can't say that we want in incoming
		 * packet to be unprotected -- at least not directly;
		 * we can always have a DENY policy for ESP/AH packets.
		 */
		*error = 0;
		return NULL;

d535 1
a535 6
                /*
                 * We don't check for policy match, since we would
                 * accept clear-text packets as well.
                 */

		/* If we have a cached entry, just accept the packet */
a541 21
		/*
		 * Find whether there exists an appropriate SA. If so, accept
		 * the packet. Otherwise, try to acquire one (from below).
		 *
		 * If no SA has been added since the last time we did a lookup,
		 * there's no point searching for one.
		 */
		if (ipo->ipo_last_searched <= ipsec_last_added)
		{
		    ipo->ipo_last_searched = time.tv_sec; /* "touch" */

		    if ((ipo->ipo_tdb = gettdbbysrc(&ssrc, ipo,
						   m, af)) != NULL)
		    {
			TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head, ipo,
					  ipo_tdb_next);
			*error = 0;
			return NULL;
		    }
		}

d543 3
a545 2
		if ((*error = ipsp_acquire_sa(ipo, &ssrc,
                                              dignore ? NULL : &sdst,
d549 9
a557 1
		/* Just accept the packet */
a565 128
}


/*
 * See if a specific SA satisfies stated policy. Return 0 if false, 1 (or
 * non-zero) otherwise.
 */
int
ipsp_match_policy(struct tdb *tdb, struct ipsec_policy *ipo,
		  struct mbuf *m, int af)
{
    union sockaddr_union peer;
    int pflag = 0;

    switch (ipo->ipo_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    if (ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_ANY)
	      pflag = 1;
	    else
	      if (ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_BROADCAST)
		pflag = 2;
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr))
		pflag = 1;
	    else
	      if (!bcmp(&ipo->ipo_dst.sin6.sin6_addr, &in6mask128,
			sizeof(in6mask128)))
		pflag = 2;
	    break;
#endif /* INET6 */

	case 0: /* Just in case */
	    pflag = 1;
	    break;

	default:
	    return 0; /* Unknown/unsupported network protocol */
    }

    if (pflag == 0)
    {
        bcopy(&ipo->ipo_dst, &peer, sizeof(union sockaddr_union));
    }
    else
      if (pflag == 1)
      {
	  bzero(&peer, sizeof(union sockaddr_union));

	  /* Need to copy the source address from the packet */
	  switch (af)
	  {
#ifdef INET
	      case AF_INET:
		  peer.sin.sin_family = AF_INET;
		  peer.sin.sin_len = sizeof(struct sockaddr_in);
		  m_copydata(m, offsetof(struct ip, ip_src),
			     sizeof(struct in_addr),
			     (caddr_t) &peer.sin.sin_addr);
		  break;
#endif /* INET */

#ifdef INET6
	      case AF_INET6:
		  peer.sin6.sin6_family = AF_INET6;
		  peer.sin6.sin6_len = sizeof(struct sockaddr_in6);
		  m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
			     sizeof(struct in6_addr),
			     (caddr_t) &peer.sin6.sin6_addr);
		  break;
#endif /* INET6 */

	      default:
		  return 0; /* Unknown/unsupported network protocol */
	  }
      }

    /*
     * Does the packet use the right security protocol and is coming from
     * the right peer ?
     */
    if (tdb->tdb_sproto == ipo->ipo_sproto)
    {
	/*
	 * We accept any peer that has a valid SA with us -- this means
	 * we depend on the higher-level (key mgmt.) protocol to enforce
	 * policy.
	 */
	if (pflag == 2)
	  return 1;

	if (bcmp(&tdb->tdb_src, &peer, tdb->tdb_src.sa.sa_len))
	{
	    switch (tdb->tdb_src.sa.sa_family)
	    {
#ifdef INET
		case AF_INET:
		    if (tdb->tdb_src.sin.sin_addr.s_addr == INADDR_ANY)
		      return 1;
		    else
		      return 0;
#endif /* INET */

#ifdef INET6
		case AF_INET6:
		    if (IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_src.sin6.sin6_addr))
		      return 1;
		    else
		      return 0;
#endif /* INET6 */

		case 0:
		    return 1;

		default:
		    return 0;
	    }
	}
	else
	  return 1;
    }

    return 0;
@


1.20
log
@Correctly free information attached to the policy.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.19 2001/05/05 00:31:20 angelos Exp $ */
d895 1
a895 1
						AF_INET, 0, NULL);
d925 1
a925 1
						AF_INET6, 0, NULL);
@


1.19
log
@Check that SAs also match on the credentials and the IDs. This means
that flows with different source/destination ID requirements will
cause different SAs to be established by IKE (or whatever other
protocol). Also, use the new data types for allocated memory.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.18 2001/04/23 10:00:09 art Exp $ */
d786 1
a786 1
      FREE(ipo->ipo_srcid, M_CREDENTIALS);
d788 1
a788 1
      FREE(ipo->ipo_dstid, M_CREDENTIALS);
d790 3
a792 1
      FREE(ipo->ipo_local_cred, M_CREDENTIALS);
@


1.19.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.17 2001/04/14 00:30:59 angelos Exp $ */
d443 1
a443 1
		ipo->ipo_tdb = gettdbbyaddr(&sdst, ipo->ipo_sproto, m, af);
d458 1
a458 1
	    ipo->ipo_tdb = gettdbbyaddr(&sdst, ipo->ipo_sproto, m, af);
d556 2
a557 2
		    if ((ipo->ipo_tdb = gettdbbysrc(&ssrc, ipo->ipo_sproto,
						   m, af)) != NULL)
d610 1
a610 1
		    if ((ipo->ipo_tdb = gettdbbysrc(&ssrc, ipo->ipo_sproto,
d771 1
a771 1
    int err;
d774 5
a778 3
    err = rtrequest(RTM_DELETE, (struct sockaddr *) &ipo->ipo_addr,
		    (struct sockaddr *) 0, (struct sockaddr *) &ipo->ipo_mask,
		    0, (struct rtentry **) 0);
d784 1
d786 1
a786 1
      FREE(ipo->ipo_srcid, M_TEMP);
d788 6
a793 2
      FREE(ipo->ipo_dstid, M_TEMP);
    FREE(ipo, M_TDB);
d809 2
a810 2
    MALLOC(ipon, struct ipsec_policy *, sizeof(struct ipsec_policy), M_TDB,
	   M_NOWAIT);
d828 1
a828 1
	FREE(ipon, M_TDB);
d854 1
a854 1
    FREE(ipa, M_TDB);
d903 1
d933 1
d1027 1
a1027 1
	   M_TDB, M_DONTWAIT);
d1048 1
a1048 1
		ipo->ipo_dst.sa.sa_family == 0)
d1061 1
a1061 1
		ipo->ipo_dst.sa.sa_family == 0)
d1094 1
a1094 1
		ipo->ipo_dst.sa.sa_family == 0)
d1108 1
a1108 1
		ipo->ipo_dst.sa.sa_family == 0)
d1134 1
a1134 1
	    FREE(ipa, M_TDB);
@


1.19.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d6 1
a6 1
 * Copyright (c) 2000-2001 Angelos D. Keromytis.
d8 1
a8 1
 * Permission to use, copy, and modify this software with or without fee
d11 1
a11 1
 * modification of this software.
d26 1
d29 1
d31 3
d54 2
a56 1
#include <net/pfkeyv2.h>
d59 1
a59 1
#define	DPRINTF(x)	if (encdebug) printf x
d61 1
a61 1
#define	DPRINTF(x)
a63 5
struct pool ipsec_policy_pool;
struct pool ipsec_acquire_pool;
int ipsec_policy_pool_initialized = 0;
int ipsec_acquire_pool_initialized = 0;

d81 1
a81 1
    struct tdb *tdbp, struct inpcb *inp)
d83 15
a97 5
	struct route_enc re0, *re = &re0;
	union sockaddr_union sdst, ssrc;
	struct sockaddr_encap *ddst;
	struct ipsec_policy *ipo;
	int signore = 0, dignore = 0;
d99 9
a107 8
	/*
	 * If there are no flows in place, there's no point
	 * continuing with the SPD lookup.
	 */
	if (!ipsec_in_use && inp == NULL) {
		*error = 0;
		return NULL;
	}
d109 6
a114 17
	/*
	 * If an input packet is destined to a BYPASS socket, just accept it.
	 */
	if ((inp != NULL) && (direction == IPSP_DIRECTION_IN) &&
	    (inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS) &&
	    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS) &&
	    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS)) {
		*error = 0;
		return NULL;
	}

	bzero((caddr_t) re, sizeof(struct route_enc));
	bzero((caddr_t) &sdst, sizeof(union sockaddr_union));
	bzero((caddr_t) &ssrc, sizeof(union sockaddr_union));
	ddst = (struct sockaddr_encap *) &re->re_dst;
	ddst->sen_family = PF_KEY;
	ddst->sen_len = SENT_LEN;
d116 2
a117 1
	switch (af) {
d120 2
a121 15
		ddst->sen_direction = direction;
		ddst->sen_type = SENT_IP4;

		m_copydata(m, offsetof(struct ip, ip_src),
		    sizeof(struct in_addr), (caddr_t) &(ddst->sen_ip_src));
		m_copydata(m, offsetof(struct ip, ip_dst),
		    sizeof(struct in_addr), (caddr_t) &(ddst->sen_ip_dst));
		m_copydata(m, offsetof(struct ip, ip_p), sizeof(u_int8_t),
		    (caddr_t) &(ddst->sen_proto));

		sdst.sin.sin_family = ssrc.sin.sin_family = AF_INET;
		sdst.sin.sin_len = ssrc.sin.sin_len =
		    sizeof(struct sockaddr_in);
		ssrc.sin.sin_addr = ddst->sen_ip_src;
		sdst.sin.sin_addr = ddst->sen_ip_dst;
d123 15
a137 4
		/*
		 * If TCP/UDP, extract the port numbers to use in the lookup.
		 */
		switch (ddst->sen_proto) {
d140 17
a156 17
			/* Make sure there's enough data in the packet. */
			if (m->m_pkthdr.len < hlen + 2 * sizeof(u_int16_t)) {
				*error = EINVAL;
				return NULL;
			}

			/*
			 * Luckily, the offset of the src/dst ports in
			 * both the UDP and TCP headers is the same (first
			 * two 16-bit values in the respective headers),
			 * so we can just copy them.
			 */
			m_copydata(m, hlen, sizeof(u_int16_t),
			    (caddr_t) &(ddst->sen_sport));
			m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			    (caddr_t) &(ddst->sen_dport));
			break;
d159 3
a161 3
			ddst->sen_sport = 0;
			ddst->sen_dport = 0;
		}
d163 1
a163 1
		break;
d168 2
a169 18
		ddst->sen_type = SENT_IP6;
		ddst->sen_ip6_direction = direction;

		m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
		    sizeof(struct in6_addr),
		    (caddr_t) &(ddst->sen_ip6_src));
		m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		    sizeof(struct in6_addr),
		    (caddr_t) &(ddst->sen_ip6_dst));
		m_copydata(m, offsetof(struct ip6_hdr, ip6_nxt),
		    sizeof(u_int8_t),
		    (caddr_t) &(ddst->sen_ip6_proto));

		sdst.sin6.sin6_family = ssrc.sin6.sin6_family = AF_INET6;
		sdst.sin6.sin6_len = ssrc.sin6.sin6_family =
		    sizeof(struct sockaddr_in6);
		ssrc.sin6.sin6_addr = ddst->sen_ip6_src;
		sdst.sin6.sin6_addr = ddst->sen_ip6_dst;
d171 18
a188 4
		/*
		 * If TCP/UDP, extract the port numbers to use in the lookup.
		 */
		switch (ddst->sen_ip6_proto) {
d191 17
a207 17
			/* Make sure there's enough data in the packet. */
			if (m->m_pkthdr.len < hlen + 2 * sizeof(u_int16_t)) {
				*error = EINVAL;
				return NULL;
			}

			/*
			 * Luckily, the offset of the src/dst ports in
			 * both the UDP and TCP headers is the same
			 * (first two 16-bit values in the respective
			 * headers), so we can just copy them.
			 */
			m_copydata(m, hlen, sizeof(u_int16_t),
			    (caddr_t) &(ddst->sen_ip6_sport));
			m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			    (caddr_t) &(ddst->sen_ip6_dport));
			break;
d210 3
a212 3
			ddst->sen_ip6_sport = 0;
			ddst->sen_ip6_dport = 0;
		}
d214 1
a214 1
		break;
d218 22
a239 3
		*error = EAFNOSUPPORT;
		return NULL;
	}
d241 8
a248 27
	/* Actual SPD lookup. */
	rtalloc((struct route *) re);
	if (re->re_rt == NULL) {
		/*
		 * Return whatever the socket requirements are, there are no
		 * system-wide policies.
		 */
		*error = 0;
		return ipsp_spd_inp(m, af, hlen, error, direction,
		    tdbp, inp, NULL);
	}

	/* Sanity check. */
	if ((re->re_rt->rt_gateway == NULL) ||
	    (((struct sockaddr_encap *) re->re_rt->rt_gateway)->sen_type !=
		SENT_IPSP)) {
		RTFREE(re->re_rt);
		*error = EHOSTUNREACH;
		return NULL;
	}

	ipo = ((struct sockaddr_encap *) (re->re_rt->rt_gateway))->sen_ipsp;
	RTFREE(re->re_rt);
	if (ipo == NULL) {
		*error = EHOSTUNREACH;
		return NULL;
	}
d250 2
a251 1
	switch (ipo->ipo_type) {
d253 2
a254 3
		*error = 0;
		return ipsp_spd_inp(m, af, hlen, error, direction, tdbp,
		    inp, ipo);
d257 2
a258 2
		*error = EHOSTUNREACH;
		return NULL;
d264 2
a265 2
		/* Nothing more needed here. */
		break;
d268 11
a278 6
		*error = EINVAL;
		return NULL;
	}

	/* Check for non-specific destination in the policy. */
	switch (ipo->ipo_dst.sa.sa_family) {
d281 11
a291 4
		if ((ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_ANY) ||
		    (ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_BROADCAST))
			dignore = 1;
		break;
d296 12
a307 5
		if ((IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr)) ||
		    (bcmp(&ipo->ipo_dst.sin6.sin6_addr, &in6mask128,
			sizeof(in6mask128))))
			dignore = 1;
		break;
d309 1
a309 1
	}
d311 2
a312 2
	/* Likewise for source. */
	switch (ipo->ipo_src.sa.sa_family) {
d315 10
a324 3
		if (ipo->ipo_src.sin.sin_addr.s_addr == INADDR_ANY)
			signore = 1;
		break;
d329 10
a338 3
		if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_src.sin6.sin6_addr))
			signore = 1;
		break;
d340 54
d396 6
a401 2
	/* Do we have a cached entry ? If so, check if it's still valid. */
	if ((ipo->ipo_tdb) && (ipo->ipo_tdb->tdb_flags & TDBF_INVALID)) {
d403 1
a403 1
		    ipo_tdb_next);
d405 8
d415 35
a449 19
	/* Outgoing packet policy check. */
	if (direction == IPSP_DIRECTION_OUT) {
		/*
		 * If the packet is destined for the policy-specified
		 * gateway/endhost, and the socket has the BYPASS
		 * option set, skip IPsec processing.
		 */
		if ((inp != NULL) &&
		    (inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS) &&
		    (inp->inp_seclevel[SL_ESP_NETWORK] ==
			IPSEC_LEVEL_BYPASS) &&
		    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS)) {
			/* Direct match. */
			if (!bcmp(&sdst, &ipo->ipo_dst, sdst.sa.sa_len) ||
			    dignore) {
				*error = 0;
				return ipsp_spd_inp(m, af, hlen, error,
				    direction, tdbp, inp, ipo);
			}
d451 5
d457 28
a484 44
		/* Check that the cached TDB (if present), is appropriate. */
		if (ipo->ipo_tdb) {
			if ((ipo->ipo_last_searched <= ipsec_last_added) ||
			    (ipo->ipo_sproto != ipo->ipo_tdb->tdb_sproto) ||
			    bcmp(dignore ? &sdst : &ipo->ipo_dst,
				&ipo->ipo_tdb->tdb_dst,
				ipo->ipo_tdb->tdb_dst.sa.sa_len))
				goto nomatchout;

			/* Match source ID. */
			if (ipo->ipo_srcid) {
				if (ipo->ipo_tdb->tdb_srcid == NULL ||
				    !ipsp_ref_match(ipo->ipo_srcid,
					ipo->ipo_tdb->tdb_srcid))
					goto nomatchout;
			}

			/* Match destination ID. */
			if (ipo->ipo_dstid) {
				if (ipo->ipo_tdb->tdb_dstid == NULL ||
				    !ipsp_ref_match(ipo->ipo_dstid,
					ipo->ipo_tdb->tdb_dstid))
					goto nomatchout;
			}

			/* Match local credentials used. */
			if (ipo->ipo_local_cred) {
				if (ipo->ipo_tdb->tdb_local_cred == NULL ||
				    !ipsp_ref_match(ipo->ipo_local_cred, 
					ipo->ipo_tdb->tdb_local_cred))
					goto nomatchout;
			}

			/* Cached entry is good. */
			return ipsp_spd_inp(m, af, hlen, error, direction,
			    tdbp, inp, ipo);

  nomatchout:
			/* Cached TDB was not good. */
			TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
			    ipo_tdb_next);
			ipo->ipo_tdb = NULL;
			ipo->ipo_last_searched = 0;
		}
d486 8
a493 25
		/*
		 * If no SA has been added since the last time we did a
		 * lookup, there's no point searching for one. However, if the
		 * destination gateway is left unspecified (or is all-1's),
		 * always lookup since this is a generic-match rule
		 * (otherwise, we can have situations where SAs to some
		 * destinations exist but are not used, possibly leading to an
		 * explosion in the number of acquired SAs).
		 */
		if (ipo->ipo_last_searched <= ipsec_last_added)	{
			/* "Touch" the entry. */
			ipo->ipo_last_searched = time.tv_sec;

			/* Find an appropriate SA from the existing ones. */
			ipo->ipo_tdb =
			    gettdbbyaddr(dignore ? &sdst : &ipo->ipo_dst,
				ipo, m, af);
			if (ipo->ipo_tdb) {
				TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head,
				    ipo, ipo_tdb_next);
				*error = 0;
				return ipsp_spd_inp(m, af, hlen, error,
				    direction, tdbp, inp, ipo);
			}
		}
d495 1
a495 15
		/* So, we don't have an SA -- just a policy. */
		switch (ipo->ipo_type) {
		case IPSP_IPSEC_REQUIRE:
			/* Acquire SA through key management. */
			if (ipsp_acquire_sa(ipo,
			    dignore ? &sdst : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, m) != 0) {
				*error = EACCES;
				return NULL;
			}

			/* Fall through */
		case IPSP_IPSEC_DONTACQ:
			*error = -EINVAL; /* Silently drop packet. */
			return NULL;
d497 17
a513 8
		case IPSP_IPSEC_ACQUIRE:
			/* Acquire SA through key management. */
			if (ipsp_acquire_sa(ipo,
			    dignore ? &sdst : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, NULL) != 0) {
				*error = EACCES;
				return NULL;
			}
d515 9
a523 5
			/* Fall through */
		case IPSP_IPSEC_USE:
			*error = 0;
			return ipsp_spd_inp(m, af, hlen, error, direction,
			    tdbp, inp, ipo);
a524 40
	} else { /* IPSP_DIRECTION_IN */
		if (tdbp != NULL) {
			/* Direct match in the cache. */
			if (ipo->ipo_tdb == tdbp) {
				*error = 0;
				return ipsp_spd_inp(m, af, hlen, error,
				    direction, tdbp, inp, ipo);
			}

			if (bcmp(dignore ? &ssrc : &ipo->ipo_dst,
			    &tdbp->tdb_src, tdbp->tdb_src.sa.sa_len) ||
			    (ipo->ipo_sproto != tdbp->tdb_sproto))
				goto nomatchin;

			/* Match source ID. */
			if (ipo->ipo_srcid) {
				if (tdbp->tdb_dstid == NULL ||
				    !ipsp_ref_match(ipo->ipo_srcid,
					tdbp->tdb_dstid))
					goto nomatchin;
			}

			/* Match destination ID. */
			if (ipo->ipo_dstid) {
				if (tdbp->tdb_srcid == NULL ||
				    !ipsp_ref_match(ipo->ipo_dstid,
					tdbp->tdb_srcid))
					goto nomatchin;
			}

			/* Add it to the cache. */
			if (ipo->ipo_tdb)
				TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head,
				    ipo, ipo_tdb_next);
			ipo->ipo_tdb = tdbp;
			TAILQ_INSERT_TAIL(&tdbp->tdb_policy_head, ipo,
			    ipo_tdb_next);
			*error = 0;
			return ipsp_spd_inp(m, af, hlen, error, direction,
			    tdbp, inp, ipo);
d526 10
a535 1
  nomatchin: /* Nothing needed here, falling through */
d538 5
a542 19
		/* Check whether cached entry applies. */
		if (ipo->ipo_tdb) {
			/*
			 * We only need to check that the correct
			 * security protocol and security gateway are
			 * set; credentials/IDs will be the same,
			 * since the cached entry is linked on this
			 * policy.
			 */
			if (ipo->ipo_sproto == ipo->ipo_tdb->tdb_sproto &&
			    !bcmp(&ipo->ipo_tdb->tdb_src
				, dignore ? &ssrc : &ipo->ipo_dst,
				ipo->ipo_tdb->tdb_src.sa.sa_len))
				goto skipinputsearch;

			/* Not applicable, unlink. */
			TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
			    ipo_tdb_next);
			ipo->ipo_tdb = NULL;
d545 19
a563 10
		/* Find whether there exists an appropriate SA. */
		if (ipo->ipo_last_searched <= ipsec_last_added)	{
			ipo->ipo_last_searched = time.tv_sec; /* "touch" */

			ipo->ipo_tdb =
			    gettdbbysrc(dignore ? &ssrc : &ipo->ipo_dst,
				ipo, m, af);
			if (ipo->ipo_tdb)
				TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head,
				    ipo, ipo_tdb_next);
a564 1
  skipinputsearch:
d566 19
a584 19
		switch (ipo->ipo_type) {
		case IPSP_IPSEC_REQUIRE:
			/* If appropriate SA exists, don't acquire another. */
			if (ipo->ipo_tdb) {
				*error = -EINVAL;
				return NULL;
			}

			/* Acquire SA through key management. */
			if ((*error = ipsp_acquire_sa(ipo,
			    dignore ? &ssrc : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, m)) != 0)
				return NULL;

			/* Fall through */
		case IPSP_IPSEC_DONTACQ:
			/* Drop packet. */
			*error = -EINVAL;
			return NULL;
d586 12
a597 13
		case IPSP_IPSEC_ACQUIRE:
			/* If appropriate SA exists, don't acquire another. */
			if (ipo->ipo_tdb) {
				*error = 0;
				return ipsp_spd_inp(m, af, hlen, error,
				    direction, tdbp, inp, ipo);
			}

			/* Acquire SA through key management. */
			if ((*error = ipsp_acquire_sa(ipo,
			    dignore ? &ssrc : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, NULL)) != 0)
				return NULL;
d599 16
a614 2
			/* Fall through */
		case IPSP_IPSEC_USE:
d616 2
a617 2
			return ipsp_spd_inp(m, af, hlen, error, direction,
			    tdbp, inp, ipo);
d619 10
d630 1
d632 3
a634 3
	/* Shouldn't ever get this far. */
	*error = EINVAL;
	return NULL;
d637 1
d639 2
a640 1
 * Delete a policy from the SPD.
d643 2
a644 1
ipsec_delete_policy(struct ipsec_policy *ipo)
d646 55
a700 2
	struct ipsec_acquire *ipa;
	int err = 0;
d702 51
a752 6
	/* Delete from SPD. */
	if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
		err = rtrequest(RTM_DELETE, (struct sockaddr *) &ipo->ipo_addr,
		    (struct sockaddr *) 0,
		    (struct sockaddr *) &ipo->ipo_mask,
		    0, (struct rtentry **) 0);
d754 7
a760 3
	if (ipo->ipo_tdb != NULL)
		TAILQ_REMOVE(&ipo->ipo_tdb->tdb_policy_head, ipo,
		    ipo_tdb_next);
d762 2
a763 2
	while ((ipa = TAILQ_FIRST(&ipo->ipo_acquires)) != NULL)
		ipsp_delete_acquire(ipa);
d765 7
a771 1
	TAILQ_REMOVE(&ipsec_policy_head, ipo, ipo_list);
d773 4
a776 8
	if (ipo->ipo_srcid)
		ipsp_reffree(ipo->ipo_srcid);
	if (ipo->ipo_dstid)
		ipsp_reffree(ipo->ipo_dstid);
	if (ipo->ipo_local_cred)
		ipsp_reffree(ipo->ipo_local_cred);
	if (ipo->ipo_local_auth)
		ipsp_reffree(ipo->ipo_local_cred);
d778 2
a779 1
	pool_put(&ipsec_policy_pool, ipo);
d781 7
a787 1
	ipsec_in_use--;
d789 1
a789 1
	return err;
a791 1
#ifdef notyet
d797 1
a797 1
    union sockaddr_union *sdst, int type, int sproto)
d799 2
a800 2
	struct sockaddr_encap encapgw;
	struct ipsec_policy *ipon;
d802 24
a825 6
	if (ipsec_policy_pool_initialized == 0) {
		ipsec_policy_pool_initialized = 1;
		pool_init(&ipsec_policy_pool, sizeof(struct ipsec_policy),
		    0, 0, PR_FREEHEADER, "ipsec policy", 0, NULL, NULL,
		    M_IPSEC_POLICY);
	}
d827 5
a831 3
	ipon = pool_get(&ipsec_policy_pool, 0);
	if (ipon == NULL)
		return NULL;
d833 1
a833 2
	bzero(ipon, sizeof(struct ipsec_policy));
	bzero((caddr_t) &encapgw, sizeof(struct sockaddr_encap));
d835 2
a836 12
	encapgw.sen_len = SENT_LEN;
	encapgw.sen_family = PF_KEY;
	encapgw.sen_type = SENT_IPSP;
	encapgw.sen_ipsp = ipon;

	if (rtrequest(RTM_ADD, (struct sockaddr *) dst,
	    (struct sockaddr *) &encapgw, (struct sockaddr *) mask,
	    RTF_UP | RTF_GATEWAY | RTF_STATIC, (struct rtentry **) 0) != 0) {
		DPRINTF(("ipsec_add_policy: failed to add policy\n"));
		pool_put(&ipsec_policy_pool, ipon);
		return NULL;
	}
d838 11
a848 1
	ipsec_in_use++;
d850 57
a906 5
	bcopy(dst, &ipon->ipo_addr, sizeof(struct sockaddr_encap));
	bcopy(mask, &ipon->ipo_mask, sizeof(struct sockaddr_encap));
	bcopy(sdst, &ipon->ipo_dst, sizeof(union sockaddr_union));
	ipon->ipo_sproto = sproto;
	ipon->ipo_type = type;
d908 29
a936 2
	TAILQ_INIT(&ipon->ipo_acquires);
	TAILQ_INSERT_HEAD(&ipsec_policy_head, ipon, ipo_list);
d938 2
a939 1
	return ipon;
a940 1
#endif
d943 1
a943 1
 * Delete a pending IPsec acquire record.
d946 1
a946 1
ipsp_delete_acquire(void *v)
d948 16
a963 1
	struct ipsec_acquire *ipa = v;
d965 3
a967 6
	timeout_del(&ipa->ipa_timeout);
	TAILQ_REMOVE(&ipsec_acquire_head, ipa, ipa_next);
	if (ipa->ipa_policy != NULL)
		TAILQ_REMOVE(&ipa->ipa_policy->ipo_acquires, ipa,
		    ipa_ipo_next);
	pool_put(&ipsec_acquire_pool, ipa);
d975 1
a975 1
ipsp_pending_acquire(struct ipsec_policy *ipo, union sockaddr_union *gw)
d977 1
a977 1
	struct ipsec_acquire *ipa;
d979 7
a985 4
	TAILQ_FOREACH (ipa, &ipo->ipo_acquires, ipa_ipo_next) {
		if (!bcmp(gw, &ipa->ipa_addr, gw->sa.sa_len))
			return ipa;
	}
d987 1
a987 1
	return NULL;
d996 2
a997 1
    union sockaddr_union *laddr, struct sockaddr_encap *ddst, struct mbuf *m)
d999 1
a999 1
	struct ipsec_acquire *ipa;
d1001 1
a1001 1
	int i;
d1004 7
a1010 10
	/* Check whether request has been made already. */
	if ((ipa = ipsp_pending_acquire(ipo, gw)) != NULL)
		return 0;

	/* Add request in cache and proceed. */
	if (ipsec_acquire_pool_initialized == 0) {
		ipsec_acquire_pool_initialized = 1;
		pool_init(&ipsec_acquire_pool, sizeof(struct ipsec_acquire),
		    0, 0, PR_FREEHEADER, "ipsec acquire", 0, NULL,
		    NULL, M_IPSEC_POLICY);		
d1013 2
a1014 6
	ipa = pool_get(&ipsec_acquire_pool, 0);
	if (ipa == NULL)
		return ENOMEM;

	bzero(ipa, sizeof(struct ipsec_acquire));
	bcopy(gw, &ipa->ipa_addr, sizeof(union sockaddr_union));
d1016 15
a1030 7
	timeout_set(&ipa->ipa_timeout, ipsp_delete_acquire, ipa);

	ipa->ipa_info.sen_len = ipa->ipa_mask.sen_len = SENT_LEN;
	ipa->ipa_info.sen_family = ipa->ipa_mask.sen_family = PF_KEY;

	/* Just copy the right information. */
	switch (ipo->ipo_addr.sen_type) {
d1033 42
a1074 35
		ipa->ipa_info.sen_type = ipa->ipa_mask.sen_type = SENT_IP4;
		ipa->ipa_info.sen_direction = ipo->ipo_addr.sen_direction;
		ipa->ipa_mask.sen_direction = ipo->ipo_mask.sen_direction;

		if (ipo->ipo_mask.sen_ip_src.s_addr == INADDR_ANY ||
		    ipo->ipo_addr.sen_ip_src.s_addr == INADDR_ANY ||
		    ipsp_is_unspecified(ipo->ipo_dst)) {
			ipa->ipa_info.sen_ip_src = ddst->sen_ip_src;
			ipa->ipa_mask.sen_ip_src.s_addr = INADDR_BROADCAST;
		} else {
			ipa->ipa_info.sen_ip_src = ipo->ipo_addr.sen_ip_src;
			ipa->ipa_mask.sen_ip_src = ipo->ipo_mask.sen_ip_src;
		}

		if (ipo->ipo_mask.sen_ip_dst.s_addr == INADDR_ANY ||
		    ipo->ipo_addr.sen_ip_dst.s_addr == INADDR_ANY ||
		    ipsp_is_unspecified(ipo->ipo_dst)) {
			ipa->ipa_info.sen_ip_dst = ddst->sen_ip_dst;
			ipa->ipa_mask.sen_ip_dst.s_addr = INADDR_BROADCAST;
		} else {
			ipa->ipa_info.sen_ip_dst = ipo->ipo_addr.sen_ip_dst;
			ipa->ipa_mask.sen_ip_dst = ipo->ipo_mask.sen_ip_dst;
		}

		ipa->ipa_info.sen_proto = ipo->ipo_addr.sen_proto;
		ipa->ipa_mask.sen_proto = ipo->ipo_mask.sen_proto;

		if (ipo->ipo_addr.sen_proto) {
			ipa->ipa_info.sen_sport = ipo->ipo_addr.sen_sport;
			ipa->ipa_mask.sen_sport = ipo->ipo_mask.sen_sport;

			ipa->ipa_info.sen_dport = ipo->ipo_addr.sen_dport;
			ipa->ipa_mask.sen_dport = ipo->ipo_mask.sen_dport;
		}
		break;
d1079 43
a1121 42
		ipa->ipa_info.sen_type = ipa->ipa_mask.sen_type = SENT_IP6;
		ipa->ipa_info.sen_ip6_direction =
		    ipo->ipo_addr.sen_ip6_direction;
		ipa->ipa_mask.sen_ip6_direction =
		    ipo->ipo_mask.sen_ip6_direction;

		if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_mask.sen_ip6_src) ||
		    IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_addr.sen_ip6_src) ||
		    ipsp_is_unspecified(ipo->ipo_dst)) {
			ipa->ipa_info.sen_ip6_src = ddst->sen_ip6_src;
			for (i = 0; i < 16; i++)
				ipa->ipa_mask.sen_ip6_src.s6_addr8[i] = 0xff;
		} else {
			ipa->ipa_info.sen_ip6_src = ipo->ipo_addr.sen_ip6_src;
			ipa->ipa_mask.sen_ip6_src = ipo->ipo_mask.sen_ip6_src;
		}

		if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_mask.sen_ip6_dst) ||
		    IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_addr.sen_ip6_dst) ||
		    ipsp_is_unspecified(ipo->ipo_dst)) {
			ipa->ipa_info.sen_ip6_dst = ddst->sen_ip6_dst;
			for (i = 0; i < 16; i++)
				ipa->ipa_mask.sen_ip6_dst.s6_addr8[i] = 0xff;
		} else {
			ipa->ipa_info.sen_ip6_dst = ipo->ipo_addr.sen_ip6_dst;
			ipa->ipa_mask.sen_ip6_dst = ipo->ipo_mask.sen_ip6_dst;
		}

		ipa->ipa_info.sen_ip6_proto = ipo->ipo_addr.sen_ip6_proto;
		ipa->ipa_mask.sen_ip6_proto = ipo->ipo_mask.sen_ip6_proto;

		if (ipo->ipo_mask.sen_ip6_proto) {
			ipa->ipa_info.sen_ip6_sport =
			    ipo->ipo_addr.sen_ip6_sport;
			ipa->ipa_mask.sen_ip6_sport =
			    ipo->ipo_mask.sen_ip6_sport;
			ipa->ipa_info.sen_ip6_dport =
			    ipo->ipo_addr.sen_ip6_dport;
			ipa->ipa_mask.sen_ip6_dport =
			    ipo->ipo_mask.sen_ip6_dport;
		}
		break;
d1125 17
a1141 9
		pool_put(&ipsec_acquire_pool, ipa);
		return 0;
	}

	timeout_add(&ipa->ipa_timeout, ipsec_expire_acquire * hz);

	TAILQ_INSERT_TAIL(&ipsec_acquire_head, ipa, ipa_next);
	TAILQ_INSERT_TAIL(&ipo->ipo_acquires, ipa, ipa_ipo_next);
	ipa->ipa_policy = ipo;
d1143 2
a1144 16
	/* PF_KEYv2 notification message. */
	return pfkeyv2_acquire(ipo, gw, laddr, &ipa->ipa_seq, ddst);
}

/*
 * Deal with PCB security requirements.
 */
struct tdb *
ipsp_spd_inp(struct mbuf *m, int af, int hlen, int *error, int direction,
    struct tdb *tdbp, struct inpcb *inp, struct ipsec_policy *ipo)
{
	/* XXX */
	if (ipo != NULL)
		return ipo->ipo_tdb;
	else
		return NULL;
d1154 1
a1154 1
	struct ipsec_acquire *ipa;
d1156 5
a1160 3
	TAILQ_FOREACH (ipa, &ipsec_acquire_head, ipa_ipo_next)
		if (ipa->ipa_seq == seq)
			return ipa;
d1162 1
a1162 1
	return NULL;
@


1.19.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.19.2.2 2001/07/04 10:54:58 niklas Exp $ */
d287 1
a287 1
			sizeof(in6mask128)) == 0))
d330 2
a331 2
			if (dignore ||
			    !bcmp(&sdst, &ipo->ipo_dst, sdst.sa.sa_len)) {
d333 2
a334 1
				return NULL;
a371 1
			*error = 0;
d394 1
a394 2
			if (dignore == 0)
				ipo->ipo_last_searched = time.tv_sec;
d427 6
a432 2
			ipsp_acquire_sa(ipo, dignore ? &sdst : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, NULL);
d494 2
a495 2
			    !bcmp(&ipo->ipo_tdb->tdb_src,
				dignore ? &ssrc : &ipo->ipo_dst,
a501 1
			ipo->ipo_last_searched = 0;
d507 1
a507 2
			if (dignore == 0)
				ipo->ipo_last_searched = time.tv_sec;
d547 4
a550 2
			ipsp_acquire_sa(ipo, dignore ? &ssrc : &ipo->ipo_dst,
			    signore ? NULL : &ipo->ipo_src, ddst, NULL);
@


1.19.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a478 1
  	;
d617 2
a618 1
		    0, 0, 0, "ipsec policy", NULL);
d710 2
a711 1
		    0, 0, 0, "ipsec acquire", NULL);
d851 1
a851 1
	TAILQ_FOREACH (ipa, &ipsec_acquire_head, ipa_next)
@


1.19.2.5
log
@Sync the SMP branch with 3.3
@
text
@a27 2
#include <sys/socketvar.h>
#include <sys/protosw.h>
a116 4
		if (hlen < sizeof (struct ip) || m->m_pkthdr.len < hlen) {
			*error = EINVAL;
			return NULL;
		}
a166 4
		if (hlen < sizeof (struct ip6_hdr) || m->m_pkthdr.len < hlen) {
			*error = EINVAL;
			return NULL;
		}
a240 1
		DPRINTF(("ip_spd_lookup: no gateway in SPD entry!"));
a247 1
		DPRINTF(("ip_spd_lookup: no policy attached to SPD entry!"));
d346 23
a368 7
			if (!ipsp_aux_match(ipo->ipo_tdb->tdb_srcid,
			    ipo->ipo_srcid, ipo->ipo_tdb->tdb_dstid,
			    ipo->ipo_dstid, ipo->ipo_tdb->tdb_local_cred,
			    ipo->ipo_local_cred, NULL, NULL,
			    &ipo->ipo_tdb->tdb_filter, &ipo->ipo_addr,
			    &ipo->ipo_tdb->tdb_filtermask, &ipo->ipo_mask))
				goto nomatchout;
d400 1
a400 3
				ipo->ipo_sproto, ipo->ipo_srcid,
				ipo->ipo_dstid, ipo->ipo_local_cred, m, af,
				&ipo->ipo_addr, &ipo->ipo_mask);
d479 1
a479 1
	;
d511 1
a511 3
				ipo->ipo_sproto, ipo->ipo_srcid,
				ipo->ipo_dstid, m, af, &ipo->ipo_addr,
				&ipo->ipo_mask);
a571 3
	if (--ipo->ipo_ref_count > 0)
		return 0;

d595 1
a595 1
		ipsp_reffree(ipo->ipo_local_auth);
d599 1
a599 2
	if (!(ipo->ipo_flags & IPSP_POLICY_SOCKET))
		ipsec_in_use--;
d604 1
d609 2
a610 1
ipsec_add_policy(struct inpcb *inp, int af, int direction)
d612 1
d626 1
d628 12
a639 2
	ipon->ipo_ref_count = 1;
	ipon->ipo_flags |= IPSP_POLICY_SOCKET;
d641 1
a641 1
	ipon->ipo_type = IPSP_IPSEC_REQUIRE; /* XXX */
d643 5
a647 5
	/* XXX
	 * We should actually be creating a linked list of
	 * policies (for tunnel/transport and ESP/AH), as needed.
	 */
	ipon->ipo_sproto = IPPROTO_ESP;
a651 2
	ipsec_update_policy(inp, ipon, af, direction);

d654 1
a654 63

/*
 * Update a PCB-attached policy.
 */
void
ipsec_update_policy(struct inpcb *inp, struct ipsec_policy *ipon, int af,
    int direction)
{
	ipon->ipo_addr.sen_len = ipon->ipo_mask.sen_len = SENT_LEN;
	ipon->ipo_addr.sen_family = ipon->ipo_mask.sen_family = PF_KEY;
	ipon->ipo_src.sa.sa_family = ipon->ipo_dst.sa.sa_family = af;

	switch (af) {
	case AF_INET:
#ifdef INET
		ipon->ipo_addr.sen_type = ipon->ipo_mask.sen_type = SENT_IP4;
		ipon->ipo_addr.sen_ip_src = inp->inp_laddr;
		ipon->ipo_addr.sen_ip_dst = inp->inp_faddr;
		ipon->ipo_addr.sen_sport = inp->inp_lport;
		ipon->ipo_addr.sen_dport = inp->inp_fport;
		ipon->ipo_addr.sen_proto =
		    inp->inp_socket->so_proto->pr_protocol;
		ipon->ipo_addr.sen_direction = direction;

		ipon->ipo_mask.sen_ip_src.s_addr = 0xffffffff;
		ipon->ipo_mask.sen_ip_dst.s_addr = 0xffffffff;
		ipon->ipo_mask.sen_sport = ipon->ipo_mask.sen_dport = 0xffff;
		ipon->ipo_mask.sen_proto = 0xff;
		ipon->ipo_mask.sen_direction = direction;

		ipon->ipo_src.sa.sa_len = sizeof(struct sockaddr_in);
		ipon->ipo_dst.sa.sa_len = sizeof(struct sockaddr_in);
		ipon->ipo_src.sin.sin_addr = inp->inp_laddr;
		ipon->ipo_dst.sin.sin_addr = inp->inp_faddr;
#endif /* INET */
		break;

	case AF_INET6:
#ifdef INET6
		ipon->ipo_addr.sen_type = ipon->ipo_mask.sen_type = SENT_IP6;
		ipon->ipo_addr.sen_ip6_src = inp->inp_laddr6;
		ipon->ipo_addr.sen_ip6_dst = inp->inp_faddr6;
		ipon->ipo_addr.sen_ip6_sport = inp->inp_lport;
		ipon->ipo_addr.sen_ip6_dport = inp->inp_fport;
		ipon->ipo_addr.sen_ip6_proto =
		    inp->inp_socket->so_proto->pr_protocol;
		ipon->ipo_addr.sen_ip6_direction = direction;

		ipon->ipo_mask.sen_ip6_src = in6mask128;
		ipon->ipo_mask.sen_ip6_dst = in6mask128;
		ipon->ipo_mask.sen_ip6_sport = 0xffff;
		ipon->ipo_mask.sen_ip6_dport = 0xffff;
		ipon->ipo_mask.sen_ip6_proto = 0xff;
		ipon->ipo_mask.sen_ip6_direction = direction;

		ipon->ipo_src.sa.sa_len = sizeof(struct sockaddr_in6);
		ipon->ipo_dst.sa.sa_len = sizeof(struct sockaddr_in6);
		ipon->ipo_src.sin6.sin6_addr = inp->inp_laddr6;
		ipon->ipo_dst.sin6.sin6_addr = inp->inp_faddr6;
#endif /* INET6 */
		break;
	}
}
d690 2
a691 2
 * Signal key management that we need an SA.
 * XXX For outgoing policies, we could try to hold on to the mbuf.
d698 3
a700 12

	/*
	 * If this is a socket policy, it has to have authentication
	 * information accompanying it --- can't tell key mgmt. to
	 * "find" it for us. This avoids abusing key mgmt. to authenticate
	 * on an application's behalf, even if the application doesn't
	 * have/know (and shouldn't) the appropriate authentication
	 * material (passphrase, private key, etc.)
	 */
	if (ipo->ipo_flags & IPSP_POLICY_SOCKET &&
	    ipo->ipo_local_auth == NULL)
		return EINVAL;
d778 2
a779 1
			ipa->ipa_mask.sen_ip6_src = in6mask128;
d789 2
a790 1
			ipa->ipa_mask.sen_ip6_dst = in6mask128;
d834 1
a834 267
	struct ipsec_policy sipon;
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
	struct tdb *tdb = NULL;

	/* Sanity check. */
	if (inp == NULL)
		goto justreturn;

	/* Verify that we need to check for socket policy. */
	if ((inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS ||
	    inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_NONE) &&
	    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS ||
	    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_NONE) &&
	    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS ||
	    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_NONE))
		goto justreturn;

	switch (direction) {
	case IPSP_DIRECTION_IN:
		/*
		 * Some further checking: if the socket has specified
		 * that it will accept unencrypted traffic, don't
		 * bother checking any further -- just accept the packet.
		 */
		if ((inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_AVAIL ||
		    inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_USE) &&
		    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_AVAIL ||
		    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_USE) &&
		    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_AVAIL ||
		    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_USE))
			goto justreturn;

		/* Initialize socket policy if unset. */
		if (inp->inp_ipo == NULL) {
			inp->inp_ipo = ipsec_add_policy(inp, af,
			    IPSP_DIRECTION_OUT);
			if (inp->inp_ipo == NULL) {
				*error = ENOBUFS;
				return NULL;
			}
		}

		/*
		 * So we *must* have protected traffic. Let's see what
		 * we have received then.
		 */
		if (inp->inp_tdb_in != NULL) {
			if (inp->inp_tdb_in == tdbp)
				goto justreturn; /* We received packet under a
						  * previously-accepted TDB. */

			/*
			 * We should be receiving protected traffic, and
			 * have an SA in place, but packet was received
			 * unprotected. Simply discard.
			 */
			if (tdbp == NULL) {
				*error = -EINVAL;
				return NULL;
			}

			/* Update, since we may need all the relevant info. */
			ipsec_update_policy(inp, inp->inp_ipo, af,
			    IPSP_DIRECTION_OUT);

			/*
			 * Check that the TDB the packet was received under
			 * is acceptable under the socket policy. If so,
			 * accept the packet; otherwise, discard.
			 */
			if (tdbp->tdb_sproto == inp->inp_ipo->ipo_sproto &&
			    !bcmp(&tdbp->tdb_src, &inp->inp_ipo->ipo_dst,
				SA_LEN(&tdbp->tdb_src.sa)) &&
			    ipsp_aux_match(tdbp->tdb_srcid,
				inp->inp_ipo->ipo_srcid, tdbp->tdb_dstid,
				inp->inp_ipo->ipo_dstid, NULL, NULL,
				NULL, NULL, &tdbp->tdb_filter,
				&inp->inp_ipo->ipo_addr,
				&tdbp->tdb_filtermask,
				&inp->inp_ipo->ipo_mask))
				goto justreturn;
			else {
				*error = -EINVAL;
				return NULL;
			}
		} else {
			/* Update, since we may need all the relevant info. */
			ipsec_update_policy(inp, inp->inp_ipo, af,
			    IPSP_DIRECTION_OUT);

			/*
			 * If the packet was received under an SA, see if
			 * it's acceptable under socket policy. If it is,
			 * accept the packet.
			 */
			if (tdbp != NULL &&
			    tdbp->tdb_sproto == inp->inp_ipo->ipo_sproto &&
			    !bcmp(&tdbp->tdb_src, &inp->inp_ipo->ipo_dst,
				SA_LEN(&tdbp->tdb_src.sa)) &&
			    ipsp_aux_match(tdbp->tdb_srcid,
				inp->inp_ipo->ipo_srcid, tdbp->tdb_dstid,
				inp->inp_ipo->ipo_dstid, NULL, NULL,
				NULL, NULL, &tdbp->tdb_filter,
				&inp->inp_ipo->ipo_addr, &tdbp->tdb_filtermask,
				&inp->inp_ipo->ipo_mask))
				goto justreturn;

			/*
			 * If the packet was not received under an SA, or
			 * if the SA it was received under is not acceptable,
			 * see if we already have an acceptable SA
			 * established. If we do, discard packet.
			 */
			if (inp->inp_ipo->ipo_last_searched <=
			    ipsec_last_added) {
				inp->inp_ipo->ipo_last_searched = time.tv_sec;

				/* Do we have an SA already established ? */
				if (gettdbbysrc(&inp->inp_ipo->ipo_dst,
				    inp->inp_ipo->ipo_sproto,
				    inp->inp_ipo->ipo_srcid,
				    inp->inp_ipo->ipo_dstid, m, af,
				    &inp->inp_ipo->ipo_addr,
				    &inp->inp_ipo->ipo_mask) != NULL) {
					*error = -EINVAL;
					return NULL;
				}
				/* Fall through */
			}

			/*
			 * If we don't have an appropriate SA, acquire one
			 * and discard the packet.
			 */
			ipsp_acquire_sa(inp->inp_ipo, &inp->inp_ipo->ipo_dst,
			    &inp->inp_ipo->ipo_src, &inp->inp_ipo->ipo_addr, m);
			*error = -EINVAL;
			return NULL;
		}

		break;

	case IPSP_DIRECTION_OUT:
		/* Do we have a cached entry ? */
		if (inp->inp_tdb_out != NULL) {
			/*
			 * If we also have to apply a different TDB as
			 * a result of a system-wide policy, add a tag
			 * to the packet.
			 */
			if (ipo != NULL && m != NULL &&
			    ipo->ipo_tdb != NULL &&
			    ipo->ipo_tdb != inp->inp_tdb_out) {
				tdb = inp->inp_tdb_out;
				goto tagandreturn;
			} else
				return inp->inp_tdb_out;
		}

		/*
		 * We need to either find an SA with the appropriate
		 * characteristics and link it to the PCB, or acquire
		 * one.
		 */
		/* XXX Only support one policy/protocol for now. */
		if (inp->inp_ipo != NULL) {
			if (inp->inp_ipo->ipo_last_searched <=
			    ipsec_last_added) {
				inp->inp_ipo->ipo_last_searched = time.tv_sec;

				/* Update, just in case. */
				ipsec_update_policy(inp, inp->inp_ipo, af,
				    IPSP_DIRECTION_OUT);

				tdb = gettdbbyaddr(&inp->inp_ipo->ipo_dst,
				    inp->inp_ipo->ipo_sproto,
				    inp->inp_ipo->ipo_srcid,
				    inp->inp_ipo->ipo_dstid,
				    inp->inp_ipo->ipo_local_cred, m, af,
				    &inp->inp_ipo->ipo_addr,
				    &inp->inp_ipo->ipo_mask);
			}
		} else {
			/*
			 * Construct a pseudo-policy, with just the necessary
			 * fields.
			 */
			ipsec_update_policy(inp, &sipon, af,
			    IPSP_DIRECTION_OUT);

			tdb = gettdbbyaddr(&sipon.ipo_dst, IPPROTO_ESP, NULL,
			    NULL, NULL, m, af, &sipon.ipo_addr,
			    &sipon.ipo_mask);
		}

		/* If we found an appropriate SA... */
		if (tdb != NULL) {
			tdb_add_inp(tdb, inp, 0); /* Latch onto PCB. */

			if (ipo != NULL && ipo->ipo_tdb != NULL &&
			    ipo->ipo_tdb != inp->inp_tdb_out && m != NULL)
				goto tagandreturn;
			else
				return tdb;
		} else {
			/* Do we need to acquire one ? */
			switch (inp->inp_seclevel[SL_ESP_TRANS]) {
			case IPSEC_LEVEL_BYPASS:
			case IPSEC_LEVEL_AVAIL:
				/* No need to do anything. */
				goto justreturn;
			case IPSEC_LEVEL_USE:
			case IPSEC_LEVEL_REQUIRE:
			case IPSEC_LEVEL_UNIQUE:
				/* Initialize socket policy if unset. */
				if (inp->inp_ipo == NULL) {
					inp->inp_ipo = ipsec_add_policy(inp, af, IPSP_DIRECTION_OUT);
					if (inp->inp_ipo == NULL) {
						*error = ENOBUFS;
						return NULL;
					}
				}

				/* Acquire a new SA. */
				if ((*error = ipsp_acquire_sa(inp->inp_ipo,
				    &inp->inp_ipo->ipo_dst,
				    &inp->inp_ipo->ipo_src,
				    &inp->inp_ipo->ipo_addr, m)) == 0)
					*error = -EINVAL;

				return NULL;
			default:
				DPRINTF(("ipsp_spd_inp: unknown sock security"
				    " level %d",
				    inp->inp_seclevel[SL_ESP_TRANS]));
				*error = -EINVAL;
				return NULL;
			}
		}
		break;

	default:  /* Should never happen. */
		*error = -EINVAL;
		return NULL;
	}

 tagandreturn:
	if (tdb == NULL)
		goto justreturn;

	mtag = m_tag_get(PACKET_TAG_IPSEC_PENDING_TDB,
	    sizeof (struct tdb_ident), M_NOWAIT);
	if (mtag == NULL) {
		*error = ENOMEM;
		return NULL;
	}

	tdbi = (struct tdb_ident *)(mtag + 1);
	tdbi->spi = ipo->ipo_tdb->tdb_spi;
	tdbi->proto = ipo->ipo_tdb->tdb_sproto;
	bcopy(&ipo->ipo_tdb->tdb_dst, &tdbi->dst,
	    ipo->ipo_tdb->tdb_dst.sa.sa_len);
	m_tag_prepend(m, mtag);
	return tdb;

 justreturn:
@


1.19.2.6
log
@Merge with the trunk
@
text
@d358 6
a363 4
			if (!ipsp_aux_match(ipo->ipo_tdb,
			    ipo->ipo_srcid, ipo->ipo_dstid,
			    ipo->ipo_local_cred, NULL,
			    &ipo->ipo_addr, &ipo->ipo_mask))
d969 4
a972 4
			    ipsp_aux_match(tdbp,
				inp->inp_ipo->ipo_srcid, 
				inp->inp_ipo->ipo_dstid,
				NULL, NULL,
d974 1
d995 5
a999 5
			    ipsp_aux_match(tdbp,
				inp->inp_ipo->ipo_srcid,
				inp->inp_ipo->ipo_dstid,
				NULL, NULL,
				&inp->inp_ipo->ipo_addr,
@


1.18
log
@Missing splx in error handling.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.17 2001/04/14 00:30:59 angelos Exp $ */
d443 1
a443 1
		ipo->ipo_tdb = gettdbbyaddr(&sdst, ipo->ipo_sproto, m, af);
d458 1
a458 1
	    ipo->ipo_tdb = gettdbbyaddr(&sdst, ipo->ipo_sproto, m, af);
d556 2
a557 2
		    if ((ipo->ipo_tdb = gettdbbysrc(&ssrc, ipo->ipo_sproto,
						   m, af)) != NULL)
d610 1
a610 1
		    if ((ipo->ipo_tdb = gettdbbysrc(&ssrc, ipo->ipo_sproto,
d771 1
a771 1
    int err;
d774 5
a778 3
    err = rtrequest(RTM_DELETE, (struct sockaddr *) &ipo->ipo_addr,
		    (struct sockaddr *) 0, (struct sockaddr *) &ipo->ipo_mask,
		    0, (struct rtentry **) 0);
d784 1
d786 1
a786 1
      FREE(ipo->ipo_srcid, M_TEMP);
d788 6
a793 2
      FREE(ipo->ipo_dstid, M_TEMP);
    FREE(ipo, M_TDB);
d809 2
a810 2
    MALLOC(ipon, struct ipsec_policy *, sizeof(struct ipsec_policy), M_TDB,
	   M_NOWAIT);
d828 1
a828 1
	FREE(ipon, M_TDB);
d854 1
a854 1
    FREE(ipa, M_TDB);
d1027 1
a1027 1
	   M_TDB, M_DONTWAIT);
d1048 1
a1048 1
		ipo->ipo_dst.sa.sa_family == 0)
d1061 1
a1061 1
		ipo->ipo_dst.sa.sa_family == 0)
d1094 1
a1094 1
		ipo->ipo_dst.sa.sa_family == 0)
d1108 1
a1108 1
		ipo->ipo_dst.sa.sa_family == 0)
d1134 1
a1134 1
	    FREE(ipa, M_TDB);
@


1.17
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.16 2001/04/10 21:52:38 provos Exp $ */
d896 1
d926 1
@


1.16
log
@allow host-to-host negotiations if no gateway has been specified.
from angelos@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.15 2001/04/06 04:42:08 csapuntz Exp $ */
d886 1
a886 1
						AF_INET, 0);
d915 1
a915 1
						AF_INET6, 0);
@


1.15
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.14 2001/03/28 20:03:06 angelos Exp $ */
d1038 2
a1039 1
		ipo->ipo_addr.sen_ip_src.s_addr == INADDR_ANY)
d1051 2
a1052 1
		ipo->ipo_addr.sen_ip_dst.s_addr == INADDR_ANY)
d1084 2
a1085 1
		IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_addr.sen_ip6_src))
d1098 2
a1099 1
		IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_addr.sen_ip6_dst))
@


1.14
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.13 2001/03/15 22:43:03 bjc Exp $ */
a61 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.13
log
@include <machine/cpu.h>, since schednetisr needs to do a splsoftnet
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.12 2001/02/28 08:24:53 angelos Exp $ */
d97 1
a97 1
    if (!ipsec_in_use)
d409 1
d414 3
a416 1
	      return ipo->ipo_tdb; /* Cached entry is good, we're done */
d516 1
@


1.12
log
@Pretty.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.11 2001/02/28 05:27:37 angelos Exp $ */
d32 2
@


1.11
log
@Handle failures more gracefully.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.10 2001/02/28 04:16:57 angelos Exp $ */
d454 2
a457 1
	    ipo->ipo_last_searched = time.tv_sec;
d1010 1
d1019 2
d1025 1
@


1.10
log
@Keep the last packet sent or received that matched an SPD entry, and
retransmit if we eventually have an SA setup for that policy.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.9 2000/12/14 18:33:32 angelos Exp $ */
d875 1
a875 4
			    {
				m_freem(ipa->ipa_packet);
				break;
			    }
d893 1
a893 1
				m_freem(ipa->ipa_packet);
d896 1
d922 1
a922 1
				m_freem(ipa->ipa_packet);
d925 1
d1004 5
a1008 3
	if (ipa->ipa_packet)
	  m_freem(ipa->ipa_packet);
	ipa->ipa_packet = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);
@


1.9
log
@Compile in non-INET6 kernels.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.8 2000/12/14 05:13:10 angelos Exp $ */
d35 1
d42 1
d401 2
a402 1
	    if (bcmp(&sdst, &ipo->ipo_tdb->tdb_dst, sdst.sa.sa_len))
a447 1
		    ipo->ipo_last_searched = 0;
d456 1
a461 1
		ipo->ipo_last_searched = 0;
d472 1
a472 1
				    ddst) != 0)
d487 1
a487 1
				    ddst) != 0)
d503 4
a506 2
	if ((ipo->ipo_tdb) && (ipo->ipo_tdb->tdb_src.sa.sa_family != 0) &&
	    bcmp(&ssrc, &ipo->ipo_tdb->tdb_src, ssrc.sa.sa_len))
a557 1
			ipo->ipo_last_searched = 0;
d566 1
a566 1
					      ddst)) != 0)
a611 1
			ipo->ipo_last_searched = 0;
d620 1
a620 1
					      ddst)) != 0)
d836 105
d953 1
a953 5
	{
	    /* Remove from the list and free */
	    TAILQ_REMOVE(&ipsec_acquire_head, ipa, ipa_next);
	    FREE(ipa, M_TDB);
	}
d969 22
a990 1
 * Signal key management that we need an SA.
d994 2
a995 1
		union sockaddr_union *laddr, struct sockaddr_encap *ddst)
d1002 2
a1003 7
    /*
     * Check whether request has been made already.
     * XXX We need a more scalable data structure instead of a list.
     */
    for (ipa = TAILQ_FIRST(&ipsec_acquire_head);
	 ipa;
	 ipa = TAILQ_NEXT(ipa, ipa_next))
d1005 4
a1008 3
	/* Already in process */
	if (!bcmp(gw, &ipa->ipa_addr, gw->sa.sa_len))
	  return 0;
d1053 2
a1054 11
	    if (ipo->ipo_mask.sen_proto)
	    {
		ipa->ipa_info.sen_proto = ipo->ipo_addr.sen_proto;
		ipa->ipa_mask.sen_proto = ipo->ipo_mask.sen_proto;
	    }
	    else
	    {
		ipa->ipa_info.sen_proto = ddst->sen_proto;
		if (ddst->sen_proto)
		  ipa->ipa_mask.sen_proto = 0xff;
	    }
d1056 1
a1056 1
	    if (ipo->ipo_mask.sen_sport)
a1059 7
	    }
	    else
	    {
		ipa->ipa_info.sen_sport = ddst->sen_sport;
		if (ddst->sen_sport)
		  ipa->ipa_mask.sen_sport = 0xffff;
	    }
a1060 2
	    if (ipo->ipo_mask.sen_dport)
	    {
a1063 7
	    else
	    {
		ipa->ipa_info.sen_dport = ddst->sen_dport;
		if (ddst->sen_dport)
		  ipa->ipa_mask.sen_dport = 0xffff;
	    }
	    
d1099 3
a1103 12
		ipa->ipa_info.sen_ip6_proto = ipo->ipo_addr.sen_ip6_proto;
		ipa->ipa_mask.sen_ip6_proto = ipo->ipo_mask.sen_ip6_proto;
	    }
	    else
	    {
		ipa->ipa_info.sen_ip6_proto = ddst->sen_ip6_proto;
		if (ddst->sen_ip6_proto)
		  ipa->ipa_mask.sen_ip6_proto = 0xff;
	    }

	    if (ipo->ipo_mask.sen_ip6_sport)
	    {
a1105 10
	    }
	    else
	    {
		ipa->ipa_info.sen_ip6_sport = ddst->sen_ip6_sport;
		if (ddst->sen_ip6_sport)
		  ipa->ipa_mask.sen_ip6_sport = 0xffff;
	    }

	    if (ipo->ipo_mask.sen_ip6_dport)
	    {
a1108 7
	    else
	    {
		ipa->ipa_info.sen_ip6_dport = ddst->sen_ip6_dport;
		if (ddst->sen_ip6_dport)
		  ipa->ipa_mask.sen_ip6_dport = 0xffff;
	    }

d1117 7
d1135 4
@


1.8
log
@Always look for a suitable TDB if the gateway is left unspecified.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.7 2000/11/17 04:16:19 angelos Exp $ */
d420 3
a422 1
	if (((ipo->ipo_dst.sa.sa_family == AF_INET) &&
d425 2
d430 3
a432 1
		  sizeof(in6mask128))))
@


1.7
log
@All-1s addresses as policy destinations is also reserved for future
use (policy discovery).
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.6 2000/10/18 20:35:21 chris Exp $ */
d412 7
a418 2
	 * If no SA has been added since the last time we did a lookup,
	 * there's no point searching for one.
d420 7
a426 1
	if (ipo->ipo_last_searched <= ipsec_last_added)
d428 3
a430 1
	    ipo->ipo_last_searched = time.tv_sec; /* "touch" the entry */
d432 14
@


1.6
log
@Fix compile error if lacking -DINET6
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.5 2000/10/14 06:23:52 angelos Exp $ */
d281 2
a282 1
	    if (ipo->ipo_dst.sin.sin_addr.s_addr != INADDR_ANY)
d296 3
a298 1
	    if (!IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr))
d373 2
a374 1
		    if (ipo->ipo_dst.sin.sin_addr.s_addr == INADDR_ANY)
d384 3
a386 1
		    if (IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr))
d617 3
d626 5
a630 1
	      pflag = 1;
d647 7
a653 6
    {
	bzero(&peer, sizeof(union sockaddr_union));

	/* Need to copy the source address from the packet */
	switch (af)
	{
d655 7
a661 7
	    case AF_INET:
		peer.sin.sin_family = AF_INET;
		peer.sin.sin_len = sizeof(struct sockaddr_in);
		m_copydata(m, offsetof(struct ip, ip_src),
			   sizeof(struct in_addr),
			   (caddr_t) &peer.sin.sin_addr);
		break;
d665 7
a671 7
	    case AF_INET6:
		peer.sin6.sin6_family = AF_INET6;
		peer.sin6.sin6_len = sizeof(struct sockaddr_in6);
		m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
			   sizeof(struct in6_addr),
			   (caddr_t) &peer.sin6.sin6_addr);
		break;
d674 4
a677 4
	    default:
	        return 0; /* Unknown/unsupported network protocol */
	}
    }
d685 8
@


1.6.2.1
log
@Pull in patch from current:
Fix (angelos):
Always look for a suitable TDB if the gateway is left unspecified.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.6 2000/10/18 20:35:21 chris Exp $ */
d406 2
a407 7
	 * If no SA has been added since the last time we did a
	 * lookup, there's no point searching for one. However, if the
	 * destination gateway is left unspecified (or is all-1's),
	 * always lookup since this is a generic-match rule
	 * (otherwise, we can have situations where SAs to some
	 * destinations exist but are not used, possibly leading to an
	 * explosion in the number of acquired SAs).
d409 1
a409 7
	if (((ipo->ipo_dst.sa.sa_family == AF_INET) &&
	     (ipo->ipo_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
	     (ipo->ipo_dst.sin.sin_addr.s_addr != INADDR_BROADCAST)) ||
	    ((ipo->ipo_dst.sa.sa_family == AF_INET6) &&
	     !IN6_IS_ADDR_UNSPECIFIED(&ipo->ipo_dst.sin6.sin6_addr) &&
	     bcmp(&ipo->ipo_dst.sin6.sin6_addr, &in6mask128,
		  sizeof(in6mask128))))
d411 1
a411 3
	    if (ipo->ipo_last_searched <= ipsec_last_added)
	    {
		ipo->ipo_last_searched = time.tv_sec; /* "touch" the entry */
a412 14
		/* Find an appropriate SA from among the existing SAs */
		ipo->ipo_tdb = gettdbbyaddr(&sdst, ipo->ipo_sproto, m, af);
		if (ipo->ipo_tdb)
		{
		    TAILQ_INSERT_TAIL(&ipo->ipo_tdb->tdb_policy_head, ipo,
				      ipo_tdb_next);
		    *error = 0;
		    ipo->ipo_last_searched = 0;
		    return ipo->ipo_tdb;
		}
	    }
	}
	else
	{
@


1.6.2.2
log
@Pull in patch from current:
Fix (angelos):
Compile in non-INET6 kernels.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.6.2.1 2000/12/14 05:37:46 jason Exp $ */
d414 1
a414 3
	if (
#ifdef INET
	    ((ipo->ipo_dst.sa.sa_family == AF_INET) &&
a416 2
#endif /* INET */
#ifdef INET6
d420 1
a420 3
		  sizeof(in6mask128))) ||
#endif /* INET6 */
	    0)
@


1.5
log
@ASKPOLICY message; used by key management to inquire about policy
triggering an ACQUIRE.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.4 2000/09/29 19:46:26 angelos Exp $ */
d818 1
d820 1
@


1.4
log
@Make sure there's enough data on the mbuf for the TCP/UDP ports (if
applicable) -- bug located thanks to a crashdump from HJungheim@@vpnet.com
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.3 2000/09/27 07:28:24 angelos Exp $ */
d87 1
a87 1
    int ignore = 0;
d288 2
d302 2
d320 1
a320 1
              ignore = 1;
d334 1
a334 1
              ignore = 1;
d430 2
a431 1
		if (ipsp_acquire_sa(ipo, &sdst, ignore ? NULL : &ssrc) != 0)
d445 2
a446 1
		if (ipsp_acquire_sa(ipo, &sdst, ignore ? NULL : &ssrc) != 0)
d523 2
a524 1
                                              ignore ? NULL : &sdst)) != 0)
d578 2
a579 1
                                              ignore ? NULL : &sdst)) != 0)
d815 1
a815 1
		union sockaddr_union *laddr)
d818 1
d839 151
d998 15
a1012 1
    return pfkeyv2_acquire(ipo, gw, laddr);
@


1.3
log
@Fix checking for incoming packets when the remote gateway has been
fully specified in the flow.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.2 2000/09/20 19:13:18 angelos Exp $ */
d140 7
d191 7
@


1.2
log
@Add IDENTITY payloads to flow establishment (and cleanup accordingly)
-- this will address one of itojun's question on how are IDs for IKE
to be determined (need to add support for this to ipsecadm).
@
text
@d1 1
a1 1
/* $OpenBSD: ip_spd.c,v 1.1 2000/09/19 03:20:59 angelos Exp $ */
d341 1
a341 1
	    if (bcmp(&sdst, &ipo->ipo_dst, sizeof(union sockaddr_union)) == 0)
d375 1
a375 2
	    if (bcmp(&sdst, &ipo->ipo_tdb->tdb_dst,
		     sizeof(union sockaddr_union)))
d442 2
a443 2
	if ((ipo->ipo_tdb) &&
	    bcmp(&ssrc, &ipo->ipo_tdb->tdb_src, sizeof(union sockaddr_union)))
d608 3
a610 1
      bcopy(&ipo->ipo_dst, &peer, sizeof(union sockaddr_union));
d647 32
a678 3
    if ((tdb->tdb_sproto == ipo->ipo_sproto) &&
	(!bcmp(&tdb->tdb_src, &peer, sizeof(union sockaddr_union))))
      return 1;
d806 1
a806 1
	if (!bcmp(gw, &ipa->ipa_addr, sizeof(union sockaddr_union)))
@


1.1
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d670 4
@

