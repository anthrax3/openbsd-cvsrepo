head	1.164;
access;
symbols
	OPENBSD_6_1:1.163.0.4
	OPENBSD_6_1_BASE:1.163
	OPENBSD_6_0:1.151.0.6
	OPENBSD_6_0_BASE:1.151
	OPENBSD_5_9:1.151.0.2
	OPENBSD_5_9_BASE:1.151
	OPENBSD_5_8:1.136.0.4
	OPENBSD_5_8_BASE:1.136
	OPENBSD_5_7:1.132.0.2
	OPENBSD_5_7_BASE:1.132
	OPENBSD_5_6:1.123.0.4
	OPENBSD_5_6_BASE:1.123
	OPENBSD_5_5:1.114.0.4
	OPENBSD_5_5_BASE:1.114
	OPENBSD_5_4:1.102.0.2
	OPENBSD_5_4_BASE:1.102
	OPENBSD_5_3:1.96.0.2
	OPENBSD_5_3_BASE:1.96
	OPENBSD_5_2:1.95.0.2
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.94
	OPENBSD_5_1:1.94.0.4
	OPENBSD_5_0:1.94.0.2
	OPENBSD_5_0_BASE:1.94
	OPENBSD_4_9:1.92.0.2
	OPENBSD_4_9_BASE:1.92
	OPENBSD_4_8:1.91.0.2
	OPENBSD_4_8_BASE:1.91
	OPENBSD_4_7:1.87.0.2
	OPENBSD_4_7_BASE:1.87
	OPENBSD_4_6:1.84.0.4
	OPENBSD_4_6_BASE:1.84
	OPENBSD_4_5:1.82.0.2
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.81.0.2
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.79.0.2
	OPENBSD_4_3_BASE:1.79
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.72.0.2
	OPENBSD_4_1_BASE:1.72
	OPENBSD_4_0:1.71.0.2
	OPENBSD_4_0_BASE:1.71
	OPENBSD_3_9:1.69.0.2
	OPENBSD_3_9_BASE:1.69
	OPENBSD_3_8:1.68.0.2
	OPENBSD_3_8_BASE:1.68
	OPENBSD_3_7:1.66.0.2
	OPENBSD_3_7_BASE:1.66
	OPENBSD_3_6:1.65.0.2
	OPENBSD_3_6_BASE:1.65
	SMP_SYNC_A:1.64
	SMP_SYNC_B:1.64
	OPENBSD_3_5:1.62.0.2
	OPENBSD_3_5_BASE:1.62
	OPENBSD_3_4:1.61.0.2
	OPENBSD_3_4_BASE:1.61
	UBC_SYNC_A:1.59
	OPENBSD_3_3:1.57.0.2
	OPENBSD_3_3_BASE:1.57
	OPENBSD_3_2:1.53.0.2
	OPENBSD_3_2_BASE:1.53
	OPENBSD_3_1:1.47.0.2
	OPENBSD_3_1_BASE:1.47
	UBC_SYNC_B:1.53
	UBC:1.42.0.4
	UBC_BASE:1.42
	OPENBSD_3_0:1.42.0.2
	OPENBSD_3_0_BASE:1.42
	OPENBSD_2_9_BASE:1.33
	OPENBSD_2_9:1.33.0.2
	OPENBSD_2_8:1.30.0.2
	OPENBSD_2_8_BASE:1.30
	OPENBSD_2_7:1.20.0.4
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.2
	SMP_BASE:1.20
	kame_19991208:1.19
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.164
date	2017.04.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.163;
commitid	4O5LUh13nIhVt6oZ;

1.163
date	2017.02.07.22.30.16;	author jmatthew;	state Exp;
branches;
next	1.162;
commitid	zOHrIfL0Sj9leJjB;

1.162
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.161;
commitid	3e3CkrbYekyVOcxy;

1.161
date	2017.01.26.13.03.47;	author bluhm;	state Exp;
branches;
next	1.160;
commitid	wBlwxPiTlfo8m7xr;

1.160
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.159;
commitid	pVtptbHA3yk4jSpN;

1.159
date	2016.12.20.18.33.43;	author bluhm;	state Exp;
branches;
next	1.158;
commitid	xiXE7MGPpVXw2TS3;

1.158
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.157;
commitid	QqHqT2WhCBWqYgGJ;

1.157
date	2016.11.28.14.14.39;	author mpi;	state Exp;
branches;
next	1.156;
commitid	6k4TK07Jp4xe3PKg;

1.156
date	2016.11.16.12.48.19;	author bluhm;	state Exp;
branches;
next	1.155;
commitid	n2RvgM2Tgp3821dQ;

1.155
date	2016.11.16.12.21.46;	author bluhm;	state Exp;
branches;
next	1.154;
commitid	EvKrV7faDiEzI4Jd;

1.154
date	2016.11.14.03.51.53;	author dlg;	state Exp;
branches;
next	1.153;
commitid	Khqq96MLd95C1Z1s;

1.153
date	2016.11.09.09.04.48;	author mpi;	state Exp;
branches;
next	1.152;
commitid	zv2B8XroCnaWYTvP;

1.152
date	2016.08.22.15.37.23;	author mpi;	state Exp;
branches;
next	1.151;
commitid	S0vYMPQvKRgA9JxA;

1.151
date	2015.12.09.09.27.40;	author mpi;	state Exp;
branches;
next	1.150;
commitid	1YVTO7Z5j7IINidX;

1.150
date	2015.12.03.21.11.53;	author sashan;	state Exp;
branches;
next	1.149;
commitid	nhuzteWvIf6uiITt;

1.149
date	2015.12.02.16.35.53;	author bluhm;	state Exp;
branches;
next	1.148;
commitid	i3XNpYhaQ8QndxLo;

1.148
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.147;
commitid	Hf3C2AvfIXmCAmHE;

1.147
date	2015.12.01.21.26.43;	author mpi;	state Exp;
branches;
next	1.146;
commitid	XfTOZsoiIJCcV93d;

1.146
date	2015.11.21.11.26.59;	author mpi;	state Exp;
branches;
next	1.145;
commitid	eT3TygmWx8QZ2MFs;

1.145
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.144;
commitid	7wrRch1SS813fOcY;

1.144
date	2015.10.22.10.31.02;	author mpi;	state Exp;
branches;
next	1.143;
commitid	SZ5NuPSxHMi9vpoS;

1.143
date	2015.10.19.12.10.05;	author mpi;	state Exp;
branches;
next	1.142;
commitid	PaTczkH5eq9sS4jy;

1.142
date	2015.10.19.12.02.11;	author mpi;	state Exp;
branches;
next	1.141;
commitid	hGJjXZuv8NWVWGWT;

1.141
date	2015.09.23.08.49.46;	author mpi;	state Exp;
branches;
next	1.140;
commitid	24xqlqpNt9NPeWH3;

1.140
date	2015.09.11.15.12.29;	author bluhm;	state Exp;
branches;
next	1.139;
commitid	WiOHVoKXV2bal1nI;

1.139
date	2015.09.10.12.10.52;	author dlg;	state Exp;
branches;
next	1.138;
commitid	q1hEUbxxteajAS44;

1.138
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.137;
commitid	RRi5waWu1LaKRicG;

1.137
date	2015.08.14.18.07.28;	author bluhm;	state Exp;
branches;
next	1.136;
commitid	mu9yDScTa557hRQD;

1.136
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.135;
commitid	h7z8lokZ0dFyuWpg;

1.135
date	2015.06.07.01.25.27;	author krw;	state Exp;
branches;
next	1.134;
commitid	7yzARhkDkBsYwsVv;

1.134
date	2015.05.19.14.16.35;	author mpi;	state Exp;
branches;
next	1.133;
commitid	0tPZas123sINv4Vm;

1.133
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.132;
commitid	hN5bFCE56DrAjl99;

1.132
date	2015.02.05.03.01.03;	author mpi;	state Exp;
branches;
next	1.131;
commitid	DhkSbioeq059UWqq;

1.131
date	2015.01.28.22.10.13;	author mpi;	state Exp;
branches;
next	1.130;
commitid	qWMiETGHDs7AwODS;

1.130
date	2015.01.26.11.38.37;	author mpi;	state Exp;
branches;
next	1.129;
commitid	4QI0UcDYcdBMTh1W;

1.129
date	2014.12.22.11.05.53;	author mpi;	state Exp;
branches;
next	1.128;
commitid	ZiNnf658AJiR4Tll;

1.128
date	2014.12.08.10.51.00;	author mpi;	state Exp;
branches;
next	1.127;
commitid	OytlsHKQQEAcUSnu;

1.127
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.126;
commitid	t9FBKDfc4VDxpEy2;

1.126
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.125;
commitid	w0MRp28dmfD1ZzO8;

1.125
date	2014.09.30.08.26.15;	author mpi;	state Exp;
branches;
next	1.124;
commitid	5HxRmnLUedxtAARO;

1.124
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.123;
commitid	uzzBR7hz9ncd4O6G;

1.123
date	2014.07.13.13.57.56;	author mpi;	state Exp;
branches;
next	1.122;
commitid	FZhOOMqcipIfV1hC;

1.122
date	2014.05.07.08.09.33;	author mpi;	state Exp;
branches;
next	1.121;

1.121
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.118;

1.118
date	2014.03.21.10.44.42;	author mpi;	state Exp;
branches;
next	1.117;

1.117
date	2014.03.20.11.22.15;	author benno;	state Exp;
branches;
next	1.116;

1.116
date	2014.03.13.01.22.54;	author jsg;	state Exp;
branches;
next	1.115;

1.115
date	2014.03.11.10.28.55;	author mpi;	state Exp;
branches;
next	1.114;

1.114
date	2014.01.19.05.01.50;	author claudio;	state Exp;
branches
	1.114.4.1;
next	1.113;

1.113
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.112;

1.112
date	2013.12.31.03.24.44;	author tedu;	state Exp;
branches;
next	1.111;

1.111
date	2013.11.26.11.27.41;	author henning;	state Exp;
branches;
next	1.110;

1.110
date	2013.11.17.10.07.32;	author bluhm;	state Exp;
branches;
next	1.109;

1.109
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches;
next	1.108;

1.108
date	2013.10.21.12.27.11;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2013.10.20.11.03.01;	author phessler;	state Exp;
branches;
next	1.106;

1.106
date	2013.08.21.09.05.22;	author mpi;	state Exp;
branches;
next	1.105;

1.105
date	2013.08.13.09.52.53;	author mpi;	state Exp;
branches;
next	1.104;

1.104
date	2013.08.08.14.59.22;	author mpi;	state Exp;
branches;
next	1.103;

1.103
date	2013.08.08.14.29.28;	author mpi;	state Exp;
branches;
next	1.102;

1.102
date	2013.06.17.02.31.37;	author lteo;	state Exp;
branches;
next	1.101;

1.101
date	2013.06.05.15.22.32;	author bluhm;	state Exp;
branches;
next	1.100;

1.100
date	2013.06.05.02.25.05;	author lteo;	state Exp;
branches;
next	1.99;

1.99
date	2013.05.03.09.35.20;	author mpi;	state Exp;
branches;
next	1.98;

1.98
date	2013.04.24.10.17.08;	author mpi;	state Exp;
branches;
next	1.97;

1.97
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2012.09.18.12.35.51;	author blambert;	state Exp;
branches;
next	1.95;

1.95
date	2012.04.13.09.38.32;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2011.07.06.01.57.37;	author dlg;	state Exp;
branches;
next	1.93;

1.93
date	2011.04.04.16.33.52;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.13.09.59.32;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2010.07.09.15.44.20;	author claudio;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.89;

1.89
date	2010.05.07.13.33.16;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.87;

1.87
date	2010.02.09.13.23.39;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2009.06.09.11.52.54;	author sthen;	state Exp;
branches;
next	1.83;

1.83
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2008.09.10.09.10.55;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.08.18.56.12;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2008.05.09.15.48.59;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2008.02.05.22.57.31;	author mpf;	state Exp;
branches;
next	1.78;

1.78
date	2007.12.13.20.00.53;	author reyk;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.24.12.59.28;	author jmc;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.11.11.29.35;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.27.19.55.13;	author dlg;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.09.14.35.25;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.72;

1.72
date	2007.01.03.18.39.56;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2005.10.17.08.43.34;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2005.07.31.03.30.55;	author pascoe;	state Exp;
branches;
next	1.67;

1.67
date	2005.06.30.08.51.31;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2005.01.18.22.25.38;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2004.06.22.07.35.20;	author cedric;	state Exp;
branches;
next	1.64;

1.64
date	2004.06.06.16.49.09;	author cedric;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.26.01.47.24;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2004.02.15.11.16.08;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.14.05.58.36;	author dhartmei;	state Exp;
branches;
next	1.58;

1.58
date	2003.05.03.21.16.30;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.56;

1.56
date	2003.02.01.19.34.06;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2003.01.31.17.27.03;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.31.17.23.34;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2002.06.10.09.13.26;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.08.21.53.53;	author jasoni;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.07.23.59.19;	author jasoni;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.24.21.53.08;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2002.01.21.05.33.14;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.12.00.51.59;	author ericj;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.05.00.20.45;	author nordin;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.04.16.52.03;	author dhartmei;	state Exp;
branches
	1.42.4.1;
next	1.41;

1.41
date	2001.07.04.05.52.16;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.01.23.04.44;	author dhartmei;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.29.18.08.39;	author provos;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.19.00.48.23;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.08.03.53.46;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.05.02.31.35;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.20.08.35.10;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.11.17.20.11;	author aaron;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.28.20.03.03;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.07.20.57.20;	author brian;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.11.19.12.22;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.17.22.33.51;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.10.15.16.02;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.10.14.24.33;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.09.14.39.46;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.26.01.02.25;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2000.09.25.09.41.02;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	2000.09.20.19.11.09;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.20.17.02.39;	author provos;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.18.22.06.37;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.15.11.07.32;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	99.12.28.07.43.40;	author itojun;	state Exp;
branches
	1.20.2.1
	1.20.4.1;
next	1.19;

1.19
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	99.09.26.23.59.15;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.09.23.07.20.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.01.08.11.35.09;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.01.08.01.04.17;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.12.31.12.55.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.12.31.12.40.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.12.31.12.27.11;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.12.31.11.50.13;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.05.27.20.28.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.05.18.21.10.48;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	98.01.06.01.38.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.05.15.05.41;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.11.22.23.23;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.05.09.14.33.32;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.15.20.23;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.22.30.35;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.22.42.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches;
next	;

1.20.2.1
date	2001.05.14.22.40.11;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.07.04.10.54.48;	author niklas;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.20.2.8;

1.20.2.8
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.20.2.9;

1.20.2.9
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.20.2.10;

1.20.2.10
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.20.2.11;

1.20.2.11
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.20.2.12;

1.20.2.12
date	2004.06.07.20.41.39;	author niklas;	state Exp;
branches;
next	;

1.20.4.1
date	2000.05.29.18.24.03;	author jason;	state Exp;
branches;
next	;

1.42.4.1
date	2002.01.31.22.55.45;	author niklas;	state Exp;
branches;
next	1.42.4.2;

1.42.4.2
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.42.4.3;

1.42.4.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.42.4.4;

1.42.4.4
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;

1.53.2.1
date	2003.02.01.13.01.30;	author henning;	state Exp;
branches;
next	;

1.114.4.1
date	2014.03.30.13.15.04;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.164
log
@When building counter memory in preparation to copy to userland, always
zero the buffers first.  All the current objects appear to be safe,
however future changes might introduce structure pads.
Discussed with guenther, ok bluhm
@
text
@/*	$OpenBSD: ip_icmp.c,v 1.163 2017/02/07 22:30:16 jmatthew Exp $	*/
/*	$NetBSD: ip_icmp.c,v 1.19 1996/02/13 23:42:22 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#include "carp.h"
#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_var.h>
#include <netinet/icmp_var.h>

#if NCARP > 0
#include <net/if_types.h>
#include <netinet/ip_carp.h>
#endif

#if NPF > 0
#include <net/pfvar.h>
#endif

/*
 * ICMP routines: error generation, receive packet processing, and
 * routines to turnaround packets back to the originator, and
 * host table maintenance routines.
 */

#ifdef ICMPPRINTFS
int	icmpprintfs = 0;	/* Settable from ddb */
#endif

/* values controllable via sysctl */
int	icmpmaskrepl = 0;
int	icmpbmcastecho = 0;
int	icmptstamprepl = 1;
int	icmperrppslim = 100;
int	icmp_rediraccept = 0;
int	icmp_redirtimeout = 10 * 60;

static int icmperrpps_count = 0;
static struct timeval icmperrppslim_last;

static struct rttimer_queue *icmp_redirect_timeout_q = NULL;
struct cpumem *icmpcounters;

int *icmpctl_vars[ICMPCTL_MAXID] = ICMPCTL_VARS;

void icmp_mtudisc_timeout(struct rtentry *, struct rttimer *);
int icmp_ratelimit(const struct in_addr *, const int, const int);
void icmp_redirect_timeout(struct rtentry *, struct rttimer *);
int icmp_input_if(struct ifnet *, struct mbuf **, int *, int);
int icmp_sysctl_icmpstat(void *, size_t *, void *);

void
icmp_init(void)
{
	icmpcounters = counters_alloc(icps_ncounters);
	/*
	 * This is only useful if the user initializes redirtimeout to
	 * something other than zero.
	 */
	if (icmp_redirtimeout != 0) {
		icmp_redirect_timeout_q =
		    rt_timer_queue_create(icmp_redirtimeout);
	}
}

struct mbuf *
icmp_do_error(struct mbuf *n, int type, int code, u_int32_t dest, int destmtu)
{
	struct ip *oip = mtod(n, struct ip *), *nip;
	unsigned oiplen = oip->ip_hl << 2;
	struct icmp *icp;
	struct mbuf *m;
	unsigned icmplen, mblen;

#ifdef ICMPPRINTFS
	if (icmpprintfs)
		printf("icmp_error(%x, %d, %d)\n", oip, type, code);
#endif
	if (type != ICMP_REDIRECT)
		icmpstat_inc(icps_error);
	/*
	 * Don't send error if not the first fragment of message.
	 * Don't error if the old packet protocol was ICMP
	 * error message, only known informational types.
	 */
	if (oip->ip_off & htons(IP_OFFMASK))
		goto freeit;
	if (oip->ip_p == IPPROTO_ICMP && type != ICMP_REDIRECT &&
	    n->m_len >= oiplen + ICMP_MINLEN &&
	    !ICMP_INFOTYPE(((struct icmp *)
	    ((caddr_t)oip + oiplen))->icmp_type)) {
		icmpstat_inc(icps_oldicmp);
		goto freeit;
	}
	/* Don't send error in response to a multicast or broadcast packet */
	if (n->m_flags & (M_BCAST|M_MCAST))
		goto freeit;

	/*
	 * First, do a rate limitation check.
	 */
	if (icmp_ratelimit(&oip->ip_src, type, code)) {
		icmpstat_inc(icps_toofreq);
		goto freeit;
	}

	/*
	 * Now, formulate icmp message
	 */
	icmplen = oiplen + min(8, ntohs(oip->ip_len));
	/*
	 * Defend against mbuf chains shorter than oip->ip_len:
	 */
	mblen = 0;
	for (m = n; m && (mblen < icmplen); m = m->m_next)
		mblen += m->m_len;
	icmplen = min(mblen, icmplen);

	/*
	 * As we are not required to return everything we have,
	 * we return whatever we can return at ease.
	 *
	 * Note that ICMP datagrams longer than 576 octets are out of spec
	 * according to RFC1812;
	 */

	KASSERT(ICMP_MINLEN <= MCLBYTES);

	if (icmplen + ICMP_MINLEN > MCLBYTES)
		icmplen = MCLBYTES - ICMP_MINLEN - sizeof (struct ip);

	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m && (sizeof (struct ip) + icmplen + ICMP_MINLEN > MHLEN)) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
			m = NULL;
		}
	}
	if (m == NULL)
		goto freeit;
	/* keep in same rtable */
	m->m_pkthdr.ph_rtableid = n->m_pkthdr.ph_rtableid;
	m->m_len = icmplen + ICMP_MINLEN;
	if ((m->m_flags & M_EXT) == 0)
		MH_ALIGN(m, m->m_len);
	icp = mtod(m, struct icmp *);
	if ((u_int)type > ICMP_MAXTYPE)
		panic("icmp_error");
	icmpstat_inc(icps_outhist + type);
	icp->icmp_type = type;
	if (type == ICMP_REDIRECT)
		icp->icmp_gwaddr.s_addr = dest;
	else {
		icp->icmp_void = 0;
		/*
		 * The following assignments assume an overlay with the
		 * zeroed icmp_void field.
		 */
		if (type == ICMP_PARAMPROB) {
			icp->icmp_pptr = code;
			code = 0;
		} else if (type == ICMP_UNREACH &&
		    code == ICMP_UNREACH_NEEDFRAG && destmtu)
			icp->icmp_nextmtu = htons(destmtu);
	}

	icp->icmp_code = code;
	m_copydata(n, 0, icmplen, (caddr_t)&icp->icmp_ip);

	/*
	 * Now, copy old ip header (without options)
	 * in front of icmp message.
	 */
	if ((m->m_flags & M_EXT) == 0 &&
	    m->m_data - sizeof(struct ip) < m->m_pktdat)
		panic("icmp len");
	m->m_data -= sizeof(struct ip);
	m->m_len += sizeof(struct ip);
	m->m_pkthdr.len = m->m_len;
	m->m_pkthdr.ph_ifidx = n->m_pkthdr.ph_ifidx;
	nip = mtod(m, struct ip *);
	/* ip_v set in ip_output */
	nip->ip_hl = sizeof(struct ip) >> 2;
	nip->ip_tos = 0;
	nip->ip_len = htons(m->m_len);
	/* ip_id set in ip_output */
	nip->ip_off = 0;
	/* ip_ttl set in icmp_reflect */
	nip->ip_p = IPPROTO_ICMP;
	nip->ip_src = oip->ip_src;
	nip->ip_dst = oip->ip_dst;

	/* move PF_GENERATED to new packet, if existent XXX preserve more? */
	if (n->m_pkthdr.pf.flags & PF_TAG_GENERATED)
		m->m_pkthdr.pf.flags |= PF_TAG_GENERATED;

	m_freem(n);
	return (m);

freeit:
	m_freem(n);
	return (NULL);
}

/*
 * Generate an error packet of type error
 * in response to bad packet ip.
 *
 * The ip packet inside has ip_off and ip_len in host byte order.
 */
void
icmp_error(struct mbuf *n, int type, int code, u_int32_t dest, int destmtu)
{
	struct mbuf *m;

	m = icmp_do_error(n, type, code, dest, destmtu);
	if (m != NULL)
		if (!icmp_reflect(m, NULL, NULL))
			icmp_send(m, NULL);
}

/*
 * Process a received ICMP message.
 */
int
icmp_input(struct mbuf **mp, int *offp, int proto)
{
	struct ifnet *ifp;

	ifp = if_get((*mp)->m_pkthdr.ph_ifidx);
	if (ifp == NULL) {
		m_freem(*mp);
		return IPPROTO_DONE;
	}

	proto = icmp_input_if(ifp, mp, offp, proto);
	if_put(ifp);
	return proto;
}

int
icmp_input_if(struct ifnet *ifp, struct mbuf **mp, int *offp, int proto)
{
	struct mbuf *m = *mp;
	int hlen = *offp;
	struct icmp *icp;
	struct ip *ip = mtod(m, struct ip *);
	struct sockaddr_in sin;
	int icmplen, i, code;
	struct in_ifaddr *ia;
	void (*ctlfunc)(int, struct sockaddr *, u_int, void *);
	struct mbuf *opts;

	/*
	 * Locate icmp structure in mbuf, and check
	 * that not corrupted and of at least minimum length.
	 */
	icmplen = ntohs(ip->ip_len) - hlen;
#ifdef ICMPPRINTFS
	if (icmpprintfs) {
		char dst[INET_ADDRSTRLEN], src[INET_ADDRSTRLEN];

		inet_ntop(AF_INET, &ip->ip_dst, dst, sizeof(dst));
		inet_ntop(AF_INET, &ip->ip_src, src, sizeof(src));

		printf("icmp_input from %s to %s, len %d\n", src, dst, icmplen);
	}
#endif
	if (icmplen < ICMP_MINLEN) {
		icmpstat_inc(icps_tooshort);
		goto freeit;
	}
	i = hlen + min(icmplen, ICMP_ADVLENMIN);
	if (m->m_len < i && (m = m_pullup(m, i)) == NULL) {
		icmpstat_inc(icps_tooshort);
		return IPPROTO_DONE;
	}
	ip = mtod(m, struct ip *);
	if (in4_cksum(m, 0, hlen, icmplen)) {
		icmpstat_inc(icps_checksum);
		goto freeit;
	}

	icp = (struct icmp *)(mtod(m, caddr_t) + hlen);
#ifdef ICMPPRINTFS
	/*
	 * Message type specific processing.
	 */
	if (icmpprintfs)
		printf("icmp_input, type %d code %d\n", icp->icmp_type,
		    icp->icmp_code);
#endif
	if (icp->icmp_type > ICMP_MAXTYPE)
		goto raw;
#if NPF > 0
	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) {
		switch (icp->icmp_type) {
		/*
		 * These ICMP types map to other connections.  They must be
		 * delivered to pr_ctlinput() also for diverted connections.
		 */
		case ICMP_UNREACH:
		case ICMP_TIMXCEED:
		case ICMP_PARAMPROB:
		case ICMP_SOURCEQUENCH:
			break;
		 /*
		  * Although pf_icmp_mapping() considers redirects belonging
		  * to a diverted connection, we must process it here anyway.
		  */
		case ICMP_REDIRECT:
			break;
		default:
			goto raw;
		}
	}
#endif /* NPF */
	icmpstat_inc(icps_inhist + icp->icmp_type);
	code = icp->icmp_code;
	switch (icp->icmp_type) {

	case ICMP_UNREACH:
		switch (code) {
		case ICMP_UNREACH_NET:
		case ICMP_UNREACH_HOST:
		case ICMP_UNREACH_PROTOCOL:
		case ICMP_UNREACH_PORT:
		case ICMP_UNREACH_SRCFAIL:
			code += PRC_UNREACH_NET;
			break;

		case ICMP_UNREACH_NEEDFRAG:
			code = PRC_MSGSIZE;
			break;

		case ICMP_UNREACH_NET_UNKNOWN:
		case ICMP_UNREACH_NET_PROHIB:
		case ICMP_UNREACH_TOSNET:
			code = PRC_UNREACH_NET;
			break;

		case ICMP_UNREACH_HOST_UNKNOWN:
		case ICMP_UNREACH_ISOLATED:
		case ICMP_UNREACH_HOST_PROHIB:
		case ICMP_UNREACH_TOSHOST:
		case ICMP_UNREACH_FILTER_PROHIB:
		case ICMP_UNREACH_HOST_PRECEDENCE:
		case ICMP_UNREACH_PRECEDENCE_CUTOFF:
			code = PRC_UNREACH_HOST;
			break;

		default:
			goto badcode;
		}
		goto deliver;

	case ICMP_TIMXCEED:
		if (code > 1)
			goto badcode;
		code += PRC_TIMXCEED_INTRANS;
		goto deliver;

	case ICMP_PARAMPROB:
		if (code > 1)
			goto badcode;
		code = PRC_PARAMPROB;
		goto deliver;

	case ICMP_SOURCEQUENCH:
		if (code)
			goto badcode;
		code = PRC_QUENCH;
	deliver:
		/* Free packet atttributes */
		if (m->m_flags & M_PKTHDR)
			m_tag_delete_chain(m);

		/*
		 * Problem with datagram; advise higher level routines.
		 */
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp) ||
		    icp->icmp_ip.ip_hl < (sizeof(struct ip) >> 2)) {
			icmpstat_inc(icps_badlen);
			goto freeit;
		}
		if (IN_MULTICAST(icp->icmp_ip.ip_dst.s_addr))
			goto badcode;
#ifdef INET6
		/* Get more contiguous data for a v6 in v4 ICMP message. */
		if (icp->icmp_ip.ip_p == IPPROTO_IPV6) {
			if (icmplen < ICMP_V6ADVLENMIN ||
			    icmplen < ICMP_V6ADVLEN(icp)) {
				icmpstat_inc(icps_badlen);
				goto freeit;
			} else {
				if ((m = m_pullup(m, (ip->ip_hl << 2) +
				    ICMP_V6ADVLEN(icp))) == NULL) {
					icmpstat_inc(icps_tooshort);
					return IPPROTO_DONE;
				}
				ip = mtod(m, struct ip *);
				icp = (struct icmp *)
				    (m->m_data + (ip->ip_hl << 2));
			}
		}
#endif /* INET6 */
#ifdef ICMPPRINTFS
		if (icmpprintfs)
			printf("deliver to protocol %d\n", icp->icmp_ip.ip_p);
#endif
		memset(&sin, 0, sizeof(sin));
		sin.sin_family = AF_INET;
		sin.sin_len = sizeof(struct sockaddr_in);
		sin.sin_addr = icp->icmp_ip.ip_dst;
#if NCARP > 0
		if (ifp->if_type == IFT_CARP &&
		    carp_lsdrop(m, AF_INET, &sin.sin_addr.s_addr,
		    &ip->ip_dst.s_addr))
			goto freeit;
#endif
		/*
		 * XXX if the packet contains [IPv4 AH TCP], we can't make a
		 * notification to TCP layer.
		 */
		ctlfunc = inetsw[ip_protox[icp->icmp_ip.ip_p]].pr_ctlinput;
		if (ctlfunc)
			(*ctlfunc)(code, sintosa(&sin), m->m_pkthdr.ph_rtableid,
			    &icp->icmp_ip);
		break;

	badcode:
		icmpstat_inc(icps_badcode);
		break;

	case ICMP_ECHO:
		if (!icmpbmcastecho &&
		    (m->m_flags & (M_MCAST | M_BCAST)) != 0) {
			icmpstat_inc(icps_bmcastecho);
			break;
		}
		icp->icmp_type = ICMP_ECHOREPLY;
		goto reflect;

	case ICMP_TSTAMP:
		if (icmptstamprepl == 0)
			break;

		if (!icmpbmcastecho &&
		    (m->m_flags & (M_MCAST | M_BCAST)) != 0) {
			icmpstat_inc(icps_bmcastecho);
			break;
		}
		if (icmplen < ICMP_TSLEN) {
			icmpstat_inc(icps_badlen);
			break;
		}
		icp->icmp_type = ICMP_TSTAMPREPLY;
		icp->icmp_rtime = iptime();
		icp->icmp_ttime = icp->icmp_rtime;	/* bogus, do later! */
		goto reflect;

	case ICMP_MASKREQ:
		if (icmpmaskrepl == 0)
			break;
		if (icmplen < ICMP_MASKLEN) {
			icmpstat_inc(icps_badlen);
			break;
		}
		/*
		 * We are not able to respond with all ones broadcast
		 * unless we receive it over a point-to-point interface.
		 */
		memset(&sin, 0, sizeof(sin));
		sin.sin_family = AF_INET;
		sin.sin_len = sizeof(struct sockaddr_in);
		if (ip->ip_dst.s_addr == INADDR_BROADCAST ||
		    ip->ip_dst.s_addr == INADDR_ANY)
			sin.sin_addr = ip->ip_src;
		else
			sin.sin_addr = ip->ip_dst;
		if (ifp == NULL)
			break;
		ia = ifatoia(ifaof_ifpforaddr(sintosa(&sin), ifp));
		if (ia == NULL)
			break;
		icp->icmp_type = ICMP_MASKREPLY;
		icp->icmp_mask = ia->ia_sockmask.sin_addr.s_addr;
		if (ip->ip_src.s_addr == 0) {
			if (ifp->if_flags & IFF_BROADCAST) {
				if (ia->ia_broadaddr.sin_addr.s_addr)
					ip->ip_src = ia->ia_broadaddr.sin_addr;
				else
					ip->ip_src.s_addr = INADDR_BROADCAST;
			}
			else if (ifp->if_flags & IFF_POINTOPOINT)
				ip->ip_src = ia->ia_dstaddr.sin_addr;
		}
reflect:
#if NCARP > 0
		if (ifp->if_type == IFT_CARP &&
		    carp_lsdrop(m, AF_INET, &ip->ip_src.s_addr,
		    &ip->ip_dst.s_addr))
			goto freeit;
#endif
		/* Free packet atttributes */
		if (m->m_flags & M_PKTHDR)
			m_tag_delete_chain(m);

		icmpstat_inc(icps_reflect);
		icmpstat_inc(icps_outhist + icp->icmp_type);
		if (!icmp_reflect(m, &opts, NULL))
			icmp_send(m, opts);
		return IPPROTO_DONE;

	case ICMP_REDIRECT:
	{
		struct sockaddr_in sdst;
		struct sockaddr_in sgw;
		struct sockaddr_in ssrc;
		struct rtentry *newrt = NULL;

		/* Free packet atttributes */
		if (m->m_flags & M_PKTHDR)
			m_tag_delete_chain(m);
		if (icmp_rediraccept == 0 || ipforwarding == 1)
			goto freeit;
		if (code > 3)
			goto badcode;
		if (icmplen < ICMP_ADVLENMIN || icmplen < ICMP_ADVLEN(icp) ||
		    icp->icmp_ip.ip_hl < (sizeof(struct ip) >> 2)) {
			icmpstat_inc(icps_badlen);
			break;
		}
		/*
		 * Short circuit routing redirects to force
		 * immediate change in the kernel's routing
		 * tables.  The message is also handed to anyone
		 * listening on a raw socket (e.g. the routing
		 * daemon for use in updating its tables).
		 */
		memset(&sdst, 0, sizeof(sdst));
		memset(&sgw, 0, sizeof(sgw));
		memset(&ssrc, 0, sizeof(ssrc));
		sdst.sin_family = sgw.sin_family = ssrc.sin_family = AF_INET;
		sdst.sin_len = sgw.sin_len = ssrc.sin_len = sizeof(sdst);
		memcpy(&sdst.sin_addr, &icp->icmp_ip.ip_dst,
		    sizeof(sdst.sin_addr));
		memcpy(&sgw.sin_addr, &icp->icmp_gwaddr,
		    sizeof(sgw.sin_addr));
		memcpy(&ssrc.sin_addr, &ip->ip_src,
		    sizeof(ssrc.sin_addr));

#ifdef	ICMPPRINTFS
		if (icmpprintfs) {
			char gw[INET_ADDRSTRLEN], dst[INET_ADDRSTRLEN];

			inet_ntop(AF_INET, &icp->icmp_gwaddr, gw, sizeof(gw));
			inet_ntop(AF_INET, &icp->icmp_ip.ip_dst,
			    dst, sizeof(dst));

			printf("redirect dst %s to %s\n", dst, gw);
		}
#endif

#if NCARP > 0
		if (ifp->if_type == IFT_CARP &&
		    carp_lsdrop(m, AF_INET, &sdst.sin_addr.s_addr,
		    &ip->ip_dst.s_addr))
			goto freeit;
#endif
		rtredirect(sintosa(&sdst), sintosa(&sgw),
		    sintosa(&ssrc), &newrt, m->m_pkthdr.ph_rtableid);
		if (newrt != NULL && icmp_redirtimeout != 0) {
			(void)rt_timer_add(newrt, icmp_redirect_timeout,
			    icmp_redirect_timeout_q, m->m_pkthdr.ph_rtableid);
		}
		if (newrt != NULL)
			rtfree(newrt);
		pfctlinput(PRC_REDIRECT_HOST, sintosa(&sdst));
		break;
	}
	/*
	 * No kernel processing for the following;
	 * just fall through to send to raw listener.
	 */
	case ICMP_ECHOREPLY:
	case ICMP_ROUTERADVERT:
	case ICMP_ROUTERSOLICIT:
	case ICMP_TSTAMPREPLY:
	case ICMP_IREQREPLY:
	case ICMP_MASKREPLY:
	case ICMP_TRACEROUTE:
	case ICMP_DATACONVERR:
	case ICMP_MOBILE_REDIRECT:
	case ICMP_IPV6_WHEREAREYOU:
	case ICMP_IPV6_IAMHERE:
	case ICMP_MOBILE_REGREQUEST:
	case ICMP_MOBILE_REGREPLY:
	case ICMP_PHOTURIS:
	default:
		break;
	}

raw:
	return rip_input(mp, offp, proto);

freeit:
	m_freem(m);
	return IPPROTO_DONE;
}

/*
 * Reflect the ip packet back to the source
 */
int
icmp_reflect(struct mbuf *m, struct mbuf **op, struct in_ifaddr *ia)
{
	struct ip *ip = mtod(m, struct ip *);
	struct mbuf *opts = NULL;
	struct sockaddr_in sin;
	struct rtentry *rt = NULL;
	int optlen = (ip->ip_hl << 2) - sizeof(struct ip);
	u_int rtableid;

	if (!in_canforward(ip->ip_src) &&
	    ((ip->ip_src.s_addr & IN_CLASSA_NET) !=
	    htonl(IN_LOOPBACKNET << IN_CLASSA_NSHIFT))) {
		m_freem(m);		/* Bad return address */
		return (EHOSTUNREACH);
	}

#if NPF > 0
	pf_pkt_addr_changed(m);
#endif
	rtableid = m->m_pkthdr.ph_rtableid;

	/*
	 * If the incoming packet was addressed directly to us,
	 * use dst as the src for the reply.  For broadcast, use
	 * the address which corresponds to the incoming interface.
	 */
	if (ia == NULL) {
		memset(&sin, 0, sizeof(sin));
		sin.sin_len = sizeof(sin);
		sin.sin_family = AF_INET;
		sin.sin_addr = ip->ip_dst;

		rt = rtalloc(sintosa(&sin), 0, rtableid);
		if (rtisvalid(rt) &&
		    ISSET(rt->rt_flags, RTF_LOCAL|RTF_BROADCAST))
			ia = ifatoia(rt->rt_ifa);
	}

	/*
	 * The following happens if the packet was not addressed to us.
	 * Use the new source address and do a route lookup. If it fails
	 * drop the packet as there is no path to the host.
	 */
	if (ia == NULL) {
		rtfree(rt);

		memset(&sin, 0, sizeof(sin));
		sin.sin_len = sizeof(sin);
		sin.sin_family = AF_INET;
		sin.sin_addr = ip->ip_src;

		/* keep packet in the original virtual instance */
		rt = rtalloc(sintosa(&sin), RT_RESOLVE, rtableid);
		if (rt == NULL) {
			ipstat_inc(ips_noroute);
			m_freem(m);
			return (EHOSTUNREACH);
		}

		ia = ifatoia(rt->rt_ifa);
	}

	ip->ip_dst = ip->ip_src;
	ip->ip_ttl = MAXTTL;

	/* It is safe to dereference ``ia'' iff ``rt'' is valid. */
	ip->ip_src = ia->ia_addr.sin_addr;
	rtfree(rt);

	if (optlen > 0) {
		u_char *cp;
		int opt, cnt;
		u_int len;

		/*
		 * Retrieve any source routing from the incoming packet;
		 * add on any record-route or timestamp options.
		 */
		cp = (u_char *) (ip + 1);
		if (op && (opts = ip_srcroute(m)) == NULL &&
		    (opts = m_gethdr(M_DONTWAIT, MT_HEADER))) {
			opts->m_len = sizeof(struct in_addr);
			mtod(opts, struct in_addr *)->s_addr = 0;
		}
		if (op && opts) {
#ifdef ICMPPRINTFS
			if (icmpprintfs)
				printf("icmp_reflect optlen %d rt %d => ",
				    optlen, opts->m_len);
#endif
			for (cnt = optlen; cnt > 0; cnt -= len, cp += len) {
				opt = cp[IPOPT_OPTVAL];
				if (opt == IPOPT_EOL)
					break;
				if (opt == IPOPT_NOP)
					len = 1;
				else {
					if (cnt < IPOPT_OLEN + sizeof(*cp))
						break;
					len = cp[IPOPT_OLEN];
					if (len < IPOPT_OLEN + sizeof(*cp) ||
					    len > cnt)
						break;
				}
				/*
				 * Should check for overflow, but it
				 * "can't happen"
				 */
				if (opt == IPOPT_RR || opt == IPOPT_TS ||
				    opt == IPOPT_SECURITY) {
					memcpy(mtod(opts, caddr_t) +
					    opts->m_len, cp, len);
					opts->m_len += len;
				}
			}
			/* Terminate & pad, if necessary */
			if ((cnt = opts->m_len % 4) != 0)
				for (; cnt < 4; cnt++) {
					*(mtod(opts, caddr_t) + opts->m_len) =
					    IPOPT_EOL;
					opts->m_len++;
				}
#ifdef ICMPPRINTFS
			if (icmpprintfs)
				printf("%d\n", opts->m_len);
#endif
		}
		ip_stripoptions(m);
	}
	m->m_flags &= ~(M_BCAST|M_MCAST);
	if (op)
		*op = opts;

	return (0);
}

/*
 * Send an icmp packet back to the ip level
 */
void
icmp_send(struct mbuf *m, struct mbuf *opts)
{
	struct ip *ip = mtod(m, struct ip *);
	int hlen;
	struct icmp *icp;

	hlen = ip->ip_hl << 2;
	icp = (struct icmp *)(mtod(m, caddr_t) + hlen);
	icp->icmp_cksum = 0;
	m->m_pkthdr.csum_flags = M_ICMP_CSUM_OUT;
#ifdef ICMPPRINTFS
	if (icmpprintfs) {
		char dst[INET_ADDRSTRLEN], src[INET_ADDRSTRLEN];

		inet_ntop(AF_INET, &ip->ip_dst, dst, sizeof(dst));
		inet_ntop(AF_INET, &ip->ip_src, src, sizeof(src));

		printf("icmp_send dst %s src %s\n", dst, src);
	}
#endif
	if (opts != NULL)
		m = ip_insertoptions(m, opts, &hlen);

	ip_send(m);
}

u_int32_t
iptime(void)
{
	struct timeval atv;
	u_long t;

	microtime(&atv);
	t = (atv.tv_sec % (24*60*60)) * 1000 + atv.tv_usec / 1000;
	return (htonl(t));
}

int
icmp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	int error;

	NET_ASSERT_LOCKED();

	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case ICMPCTL_REDIRTIMEOUT:

		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmp_redirtimeout);
		if (icmp_redirect_timeout_q != NULL) {
			if (icmp_redirtimeout == 0) {
				rt_timer_queue_destroy(icmp_redirect_timeout_q);
				icmp_redirect_timeout_q = NULL;
			} else
				rt_timer_queue_change(icmp_redirect_timeout_q,
				    icmp_redirtimeout);
		} else if (icmp_redirtimeout > 0) {
			icmp_redirect_timeout_q =
			    rt_timer_queue_create(icmp_redirtimeout);
		}
		break;

	case ICMPCTL_STATS:
		error = icmp_sysctl_icmpstat(oldp, oldlenp, newp);
		break;

	default:
		if (name[0] < ICMPCTL_MAXID) {
			error = sysctl_int_arr(icmpctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen);
			break;
		}
		error = ENOPROTOOPT;
		break;
	}

	return (error);
}

int
icmp_sysctl_icmpstat(void *oldp, size_t *oldlenp, void *newp)
{
	uint64_t counters[icps_ncounters];
	struct icmpstat icmpstat;
	u_long *words = (u_long *)&icmpstat;
	int i;

	CTASSERT(sizeof(icmpstat) == (nitems(counters) * sizeof(u_long)));
	memset(&icmpstat, 0, sizeof icmpstat);
	counters_read(icmpcounters, counters, nitems(counters));

	for (i = 0; i < nitems(counters); i++)
		words[i] = (u_long)counters[i];

	return (sysctl_rdstruct(oldp, oldlenp, newp,
	    &icmpstat, sizeof(icmpstat)));
}

struct rtentry *
icmp_mtudisc_clone(struct in_addr dst, u_int rtableid)
{
	struct sockaddr_in sin;
	struct rtentry *rt;
	int error;

	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_len = sizeof(sin);
	sin.sin_addr = dst;

	rt = rtalloc(sintosa(&sin), RT_RESOLVE, rtableid);

	/* Check if the route is actually usable */
	if (!rtisvalid(rt) || (rt->rt_flags & (RTF_REJECT|RTF_BLACKHOLE))) {
		rtfree(rt);
		return (NULL);
	}

	/* If we didn't get a host route, allocate one */
	if ((rt->rt_flags & RTF_HOST) == 0) {
		struct rtentry *nrt;
		struct rt_addrinfo info;
		struct sockaddr_rtlabel sa_rl;

		memset(&info, 0, sizeof(info));
		info.rti_ifa = rt->rt_ifa;
		info.rti_flags = RTF_GATEWAY | RTF_HOST | RTF_DYNAMIC;
		info.rti_info[RTAX_DST] = sintosa(&sin);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_LABEL] =
		    rtlabel_id2sa(rt->rt_labelid, &sa_rl);

		error = rtrequest(RTM_ADD, &info, rt->rt_priority, &nrt,
		    rtableid);
		if (error) {
			rtfree(rt);
			return (NULL);
		}
		nrt->rt_rmx = rt->rt_rmx;
		rtfree(rt);
		rt = nrt;
	}
	error = rt_timer_add(rt, icmp_mtudisc_timeout, ip_mtudisc_timeout_q,
	    rtableid);
	if (error) {
		rtfree(rt);
		return (NULL);
	}

	return (rt);
}

/* Table of common MTUs: */
static const u_short mtu_table[] = {
	65535, 65280, 32000, 17914, 9180, 8166,
	4352, 2002, 1492, 1006, 508, 296, 68, 0
};

void
icmp_mtudisc(struct icmp *icp, u_int rtableid)
{
	struct rtentry *rt;
	struct ifnet *ifp;
	u_long mtu = ntohs(icp->icmp_nextmtu);  /* Why a long?  IPv6 */

	rt = icmp_mtudisc_clone(icp->icmp_ip.ip_dst, rtableid);
	if (rt == NULL)
		return;

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL) {
		rtfree(rt);
		return;
	}

	if (mtu == 0) {
		int i = 0;

		mtu = ntohs(icp->icmp_ip.ip_len);
		/* Some 4.2BSD-based routers incorrectly adjust the ip_len */
		if (mtu > rt->rt_rmx.rmx_mtu && rt->rt_rmx.rmx_mtu != 0)
			mtu -= (icp->icmp_ip.ip_hl << 2);

		/* If we still can't guess a value, try the route */
		if (mtu == 0) {
			mtu = rt->rt_rmx.rmx_mtu;

			/* If no route mtu, default to the interface mtu */

			if (mtu == 0)
				mtu = ifp->if_mtu;
		}

		for (i = 0; i < nitems(mtu_table); i++)
			if (mtu > mtu_table[i]) {
				mtu = mtu_table[i];
				break;
			}
	}

	/*
	 * XXX:   RTV_MTU is overloaded, since the admin can set it
	 *	  to turn off PMTU for a route, and the kernel can
	 *	  set it to indicate a serious problem with PMTU
	 *	  on a route.  We should be using a separate flag
	 *	  for the kernel to indicate this.
	 */
	if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0) {
		if (mtu < 296 || mtu > ifp->if_mtu)
			rt->rt_rmx.rmx_locks |= RTV_MTU;
		else if (rt->rt_rmx.rmx_mtu > mtu || rt->rt_rmx.rmx_mtu == 0)
			rt->rt_rmx.rmx_mtu = mtu;
	}

	if_put(ifp);
	rtfree(rt);
}

void
icmp_mtudisc_timeout(struct rtentry *rt, struct rttimer *r)
{
	struct ifnet *ifp;

	NET_ASSERT_LOCKED();

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL)
		return;

	if ((rt->rt_flags & (RTF_DYNAMIC|RTF_HOST)) == (RTF_DYNAMIC|RTF_HOST)) {
		void (*ctlfunc)(int, struct sockaddr *, u_int, void *);
		struct sockaddr_in sin;

		sin = *satosin(rt_key(rt));

		rtdeletemsg(rt, ifp, r->rtt_tableid);

		/* Notify TCP layer of increased Path MTU estimate */
		ctlfunc = inetsw[ip_protox[IPPROTO_TCP]].pr_ctlinput;
		if (ctlfunc)
			(*ctlfunc)(PRC_MTUINC, sintosa(&sin),
			    r->rtt_tableid, NULL);
	} else {
		if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0)
			rt->rt_rmx.rmx_mtu = 0;
	}

	if_put(ifp);
}

/*
 * Perform rate limit check.
 * Returns 0 if it is okay to send the icmp packet.
 * Returns 1 if the router SHOULD NOT send this icmp packet due to rate
 * limitation.
 *
 * XXX per-destination/type check necessary?
 */
int
icmp_ratelimit(const struct in_addr *dst, const int type, const int code)
{
	/* PPS limit */
	if (!ppsratecheck(&icmperrppslim_last, &icmperrpps_count,
	    icmperrppslim))
		return 1;	/* The packet is subject to rate limit */
	return 0;	/* okay to send */
}

void
icmp_redirect_timeout(struct rtentry *rt, struct rttimer *r)
{
	struct ifnet *ifp;

	NET_ASSERT_LOCKED();

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL)
		return;

	if ((rt->rt_flags & (RTF_DYNAMIC|RTF_HOST)) == (RTF_DYNAMIC|RTF_HOST)) {
		rtdeletemsg(rt, ifp, r->rtt_tableid);
	}

	if_put(ifp);
}

int
icmp_do_exthdr(struct mbuf *m, u_int16_t class, u_int8_t ctype, void *buf,
    size_t len)
{
	struct ip *ip = mtod(m, struct ip *);
	int hlen, off;
	struct mbuf *n;
	struct icmp *icp;
	struct icmp_ext_hdr *ieh;
	struct {
		struct icmp_ext_hdr	ieh;
		struct icmp_ext_obj_hdr	ieo;
	} hdr;

	hlen = ip->ip_hl << 2;
	icp = (struct icmp *)(mtod(m, caddr_t) + hlen);
	if (icp->icmp_type != ICMP_TIMXCEED && icp->icmp_type != ICMP_UNREACH &&
	    icp->icmp_type != ICMP_PARAMPROB)
		/* exthdr not supported */
		return (0);

	if (icp->icmp_length != 0)
		/* exthdr already present, giving up */
		return (0);

	/* the actual offset starts after the common ICMP header */
	hlen += ICMP_MINLEN;
	/* exthdr must start on a word boundary */
	off = roundup(ntohs(ip->ip_len) - hlen, sizeof(u_int32_t));
	/* ... and at an offset of ICMP_EXT_OFFSET or bigger */
	off = max(off, ICMP_EXT_OFFSET);
	icp->icmp_length = off / sizeof(u_int32_t);

	memset(&hdr, 0, sizeof(hdr));
	hdr.ieh.ieh_version = ICMP_EXT_HDR_VERSION;
	hdr.ieo.ieo_length = htons(sizeof(struct icmp_ext_obj_hdr) + len);
	hdr.ieo.ieo_cnum = class;
	hdr.ieo.ieo_ctype = ctype;

	if (m_copyback(m, hlen + off, sizeof(hdr), &hdr, M_NOWAIT) ||
	    m_copyback(m, hlen + off + sizeof(hdr), len, buf, M_NOWAIT)) {
		m_freem(m);
		return (ENOBUFS);
	}

	/* calculate checksum */
	n = m_getptr(m, hlen + off, &off);
	if (n == NULL)
		panic("icmp_do_exthdr: m_getptr failure");
	ieh = (struct icmp_ext_hdr *)(mtod(n, caddr_t) + off);
	ieh->ieh_cksum = in4_cksum(n, 0, off, sizeof(hdr) + len);

	ip->ip_len = htons(m->m_pkthdr.len);

	return (0);
}
@


1.163
log
@Use percpu counters for icmp

ok dlg@@ a while ago
some input from jca@@ who wrote the same diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.162 2017/01/29 19:58:47 bluhm Exp $	*/
d932 1
a932 1

@


1.162
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.161 2017/01/26 13:03:47 bluhm Exp $	*/
d124 1
a124 1
struct	icmpstat icmpstat;
d132 1
d137 1
d162 1
a162 1
		icmpstat.icps_error++;
d174 1
a174 1
		icmpstat.icps_oldicmp++;
d185 1
a185 1
		icmpstat.icps_toofreq++;
d232 1
a232 1
	icmpstat.icps_outhist[type]++;
d353 1
a353 1
		icmpstat.icps_tooshort++;
d358 1
a358 1
		icmpstat.icps_tooshort++;
d363 1
a363 1
		icmpstat.icps_checksum++;
d401 1
a401 1
	icmpstat.icps_inhist[icp->icmp_type]++;
d466 1
a466 1
			icmpstat.icps_badlen++;
d476 1
a476 1
				icmpstat.icps_badlen++;
d481 1
a481 1
					icmpstat.icps_tooshort++;
d515 1
a515 1
		icmpstat.icps_badcode++;
d521 1
a521 1
			icmpstat.icps_bmcastecho++;
d533 1
a533 1
			icmpstat.icps_bmcastecho++;
d537 1
a537 1
			icmpstat.icps_badlen++;
d549 1
a549 1
			icmpstat.icps_badlen++;
d592 2
a593 2
		icmpstat.icps_reflect++;
		icmpstat.icps_outhist[icp->icmp_type]++;
d614 1
a614 1
			icmpstat.icps_badlen++;
d907 1
a907 6
		if (newp != NULL) {
			error = EPERM;
			break;
		}
		error = sysctl_struct(oldp, oldlenp, newp, newlen,
		    &icmpstat, sizeof(icmpstat));
d923 18
@


1.161
log
@Reduce the difference between struct protosw and ip6protosw.  The
IPv4 pr_ctlinput functions did return a void pointer that was always
NULL and never used.  Make all functions void like in the IPv6 case.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.160 2017/01/25 17:34:31 bluhm Exp $	*/
d131 1
a131 1
void icmp_input_if(struct ifnet *, struct mbuf *, int, int);
d306 2
a307 2
void
icmp_input(struct mbuf *m, int hlen, int proto)
d311 1
a311 1
	ifp = if_get(m->m_pkthdr.ph_ifidx);
d313 2
a314 2
		m_freem(m);
		return;
d317 1
a317 1
	icmp_input_if(ifp, m, hlen, proto);
d319 1
d322 2
a323 2
void
icmp_input_if(struct ifnet *ifp, struct mbuf *m, int hlen, int proto)
d325 2
d357 1
a357 1
		return;
d480 1
a480 1
					return;
d594 1
a594 1
		return;
d686 1
a686 2
	rip_input(m, hlen, proto);
	return;
d690 1
@


1.160
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.159 2016/12/20 18:33:43 bluhm Exp $	*/
d329 1
a329 1
	void *(*ctlfunc)(int, struct sockaddr *, u_int, void *);
d1056 1
a1056 1
		void *(*ctlfunc)(int, struct sockaddr *, u_int, void *);
@


1.159
log
@A NET_LOCK() was is missing in tcp_sysctl() which shows up as spl
softnet assert failures.  It is better to place the lock into
net_sysctl() where all the protocol sysctls are called via pr_sysctl.
As calling sysctl(2) is in the slow path, doing fine grained locking
has no benefit.  Many sysctl cases copy out a struct.  Having a
lock around that keeps the struct consistent.  Put assertions in
the protocol sysctls that need it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.158 2016/12/19 08:36:49 mpi Exp $	*/
d131 1
a131 1
void icmp_input_if(struct ifnet *, struct mbuf *, int);
d307 1
a307 1
icmp_input(struct mbuf *m, ...)
a309 6
	int hlen;
	va_list ap;

	va_start(ap, m);
	hlen = va_arg(ap, int);
	va_end(ap);
d317 1
a317 1
	icmp_input_if(ifp, m, hlen);
d322 1
a322 1
icmp_input_if(struct ifnet *ifp, struct mbuf *m, int hlen)
d683 1
a683 1
	rip_input(m);
@


1.158
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.157 2016/11/28 14:14:39 mpi Exp $	*/
d881 3
a883 1
	int s, error;
a888 1
	NET_LOCK(s);
a924 1
	NET_UNLOCK(s);
@


1.157
log
@Explicitly initialize rti_ifa when automagically adding a route.

This will allow to strengthen checks when userland adds a route.

ok phessler@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.156 2016/11/16 12:48:19 bluhm Exp $	*/
d887 1
a887 1
	s = splsoftnet();
d924 1
a924 1
	splx(s);
d1055 1
a1055 1
	splsoftassert(IPL_SOFTNET);
d1105 1
a1105 1
	splsoftassert(IPL_SOFTNET);
@


1.156
log
@Bring icmp6_mtudisc_clone() in line with icmp_mtudisc_clone().  The
IPv4 dynamic route inherits the priority.  Only clone from a valid
IPv6 route.  Do not use splsoftnet() in IPv6.  Some stylistic changes
to make the functions similar.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.155 2016/11/16 12:21:46 bluhm Exp $	*/
d957 1
@


1.155
log
@Inherit route label when creating dynamic routes for path MTU.
From Rivo Nurges; OK claudio@@ mpi@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.154 2016/11/14 03:51:53 dlg Exp $	*/
d963 2
a964 1
		error = rtrequest(RTM_ADD, &info, RTP_DEFAULT, &nrt, rtableid);
@


1.154
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the ipstat struct.

ipstat_inc(ips_foo) replaces ipstat.ips_foo++ for the actual updates.
ipstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the ipstat struct for now.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.153 2016/11/09 09:04:48 mpi Exp $	*/
d954 1
d957 1
d960 2
a961 1
		info.rti_flags = RTF_GATEWAY | RTF_HOST | RTF_DYNAMIC;
@


1.153
log
@Do not call splsoftnet() recursively, this won't work with a lock.

Timers configured via rt_timer_add(9) always run at IPL_SOFTNET, so
assert that rather than calling splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.152 2016/08/22 15:37:23 mpi Exp $	*/
d754 1
a754 1
			ipstat.ips_noroute++;
@


1.152
log
@Do not dereference ``rt->rt_ifa'' after calling rtfree(9).

This could result in a use after free if the route entry was holding
the last reference of the address descriptor.

ok jca@@, bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.151 2015/12/09 09:27:40 mpi Exp $	*/
d1049 2
a1050 1
	int s;
a1061 1
		s = splsoftnet();
a1068 1
		splx(s);
d1099 2
a1100 1
	int s;
a1106 1
		s = splsoftnet();
a1107 1
		splx(s);
@


1.151
log
@Always pass a valid interface pointer to rtdeletemsg().

This will allows for stricter checks inside rtdeletemsg() and it should be
up to the caller to decide if the route needs to be deleted or not.

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.150 2015/12/03 21:11:53 sashan Exp $	*/
d705 1
a705 1
	struct rtentry *rt;
a735 1
		rtfree(rt);
d744 2
a759 1
		rtfree(rt);
d763 3
d767 1
a767 1
	ip->ip_ttl = MAXTTL;
@


1.150
log
@ip_send()/ip6_send() allow PF to send response packet in ipsoftnet task.
this avoids current recursion to pf_test() function. the change also
switches icmp_error()/icmp6_error() to use ip_send()/ip6_send() so
they are safe for PF.

The idea comes from Markus Friedl. bluhm, mikeb and mpi helped me
a lot to get it into shape.

OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.149 2015/12/02 16:35:53 bluhm Exp $	*/
d1045 6
a1050 2
	if (rt == NULL)
		panic("icmp_mtudisc_timeout:  bad route to timeout");
d1052 1
a1052 2
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) ==
	    (RTF_DYNAMIC | RTF_HOST)) {
a1054 1
		int s;
d1059 1
a1059 1
		rtdeletemsg(rt, NULL, r->rtt_tableid);
d1067 1
a1067 1
	} else
d1070 3
d1096 2
a1097 2
	if (rt == NULL)
		panic("icmp_redirect_timeout:  bad route to timeout");
d1099 3
a1101 3
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) ==
	    (RTF_DYNAMIC | RTF_HOST)) {
		int s;
d1103 1
d1105 1
a1105 1
		rtdeletemsg(rt, NULL, r->rtt_tableid);
d1108 2
@


1.149
log
@When destroying an interface, we have to wait until all references
are not used anymore.  This has to be done before any interface
fields become invalid.
As the route delete request cannot call if_get() anymore, pass down
the interface.  Split rtrequest_delete() into a separate function
that may take an existing inteface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.148 2015/12/02 13:29:26 claudio Exp $	*/
d857 4
a860 1
	ip_output(m, opts, NULL, 0, NULL, NULL, 0);
@


1.148
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.147 2015/12/01 21:26:43 mpi Exp $	*/
d1054 1
a1054 1
		rtdeletemsg(rt, r->rtt_tableid);
d1096 1
a1096 1
		rtdeletemsg(rt, r->rtt_tableid);
@


1.147
log
@Kill redundant or unused arguments in rtredirect().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.146 2015/11/21 11:26:59 mpi Exp $	*/
d751 1
a751 1
		rt = rtalloc(sintosa(&sin), RT_REPORT|RT_RESOLVE, rtableid);
d936 1
a936 1
	rt = rtalloc(sintosa(&sin), RT_REPORT|RT_RESOLVE, rtableid);
@


1.146
log
@Use if_get() rather than dereferencing rt_ifp directly.

Inputs from and ok florian@@, ok sthen@@, visa@@, sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.145 2015/10/30 09:39:42 bluhm Exp $	*/
d655 2
a656 3
		rtredirect(sintosa(&sdst), sintosa(&sgw), NULL,
		    RTF_GATEWAY | RTF_HOST, sintosa(&ssrc),
		    &newrt, m->m_pkthdr.ph_rtableid);
@


1.145
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.144 2015/10/22 10:31:02 mpi Exp $	*/
d984 1
d991 6
d1012 1
a1012 1
				mtu = rt->rt_ifp->if_mtu;
a1028 1

d1030 1
a1030 1
		if (mtu < 296 || mtu > rt->rt_ifp->if_mtu)
d1032 1
a1032 2
		else if (rt->rt_rmx.rmx_mtu > mtu ||
		    rt->rt_rmx.rmx_mtu == 0)
d1036 1
@


1.144
log
@Do not dereference ``ia_ifp'' when we already have an ``ifp'' pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.143 2015/10/19 12:10:05 mpi Exp $	*/
d955 1
a955 1
		error = rtrequest1(RTM_ADD, &info, RTP_DEFAULT, &nrt, rtableid);
@


1.143
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add a missing ``rtableid'' check in in_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.142 2015/10/19 12:02:11 mpi Exp $	*/
d573 1
a573 1
			if (ia->ia_ifp->if_flags & IFF_BROADCAST) {
d579 1
a579 1
			else if (ia->ia_ifp->if_flags & IFF_POINTOPOINT)
@


1.142
log
@Sync rtisvalid(9) check for local route entries with r1.257 of
net/ip_input.c
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.141 2015/09/23 08:49:46 mpi Exp $	*/
a937 2
	if (rt == NULL)
		return (NULL);
d940 1
a940 2
	if (rt->rt_flags & (RTF_REJECT | RTF_BLACKHOLE) ||
	    (rt->rt_flags & RTF_UP) == 0) {
a945 1

@


1.141
log
@Always increment rt_use inside rtalloc(9) instead of doing it in some
specific places.

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.140 2015/09/11 15:12:29 bluhm Exp $	*/
d734 4
a737 5
		if (rt != NULL) {
			if (rt->rt_flags & (RTF_LOCAL|RTF_BROADCAST))
				ia = ifatoia(rt->rt_ifa);
			rtfree(rt);
		}
@


1.140
log
@When pf modifies a TCP packet, it sets the M_TCP_CSUM_OUT flag in
the mbuf packet header.  If the packet and is later dropped in
ip6_forward(), the TCP mbuf is copied and passed to icmp6_error().
IPv6 uses m_copym() and M_PREPEND() which preserve the packet header.
The inherited M_TCP_CSUM_OUT flag generates ICMP6 packets with an
incorrect checksum.  So reset the csum_flags when packets are
generated by icmp6_reflect() or icmp6_redirect_output().

IPv4 does m_copydata() into a fresh mbuf.  There m_inithdr() clears
the packet header, so the problem does not occur.  But setting the
csum_flags explicitly also makes sense for icmp_send().  Do not or
M_ICMP_CSUM_OUT to a value that is 0 because of some function calls
before.

OK mpi@@ lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.139 2015/09/10 12:10:52 dlg Exp $	*/
a760 1
		rt->rt_use++;
@


1.139
log
@if_put after if_get in icmp input.

instead of chasing all the ways out of icmp_input, rename it to
icmp_input_if and call it from a wrapper that gets the ifp and puts
it after icmp_input_if call.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.138 2015/09/01 21:24:04 bluhm Exp $	*/
d849 1
a849 1
	m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;
@


1.138
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.137 2015/08/14 18:07:28 bluhm Exp $	*/
d131 1
d310 1
a310 6
	struct icmp *icp;
	struct ip *ip = mtod(m, struct ip *);
	struct sockaddr_in sin;
	int icmplen, i, code, hlen;
	struct in_ifaddr *ia;
	void *(*ctlfunc)(int, struct sockaddr *, u_int, void *);
a311 1
	struct mbuf *opts;
d318 19
a336 2
	if (ifp == NULL)
		goto freeit;
@


1.137
log
@Replace sockaddr casts with the proper satosin() or satosin6() calls.
From David Hill;  OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.136 2015/06/16 11:09:40 mpi Exp $	*/
d1037 1
a1037 1
		struct sockaddr_in sa;
d1040 1
a1040 1
		sa = *satosin(rt_key(rt));
d1048 1
a1048 1
			(*ctlfunc)(PRC_MTUINC,(struct sockaddr *)&sa,
@


1.136
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.135 2015/06/07 01:25:27 krw Exp $	*/
d1040 1
a1040 1
		sa = *(struct sockaddr_in *)rt_key(rt);
@


1.135
log
@Replace a bunch of == 0 with == NULL in pointer tests. Nuke some
annoying trailing, leading and embedded whitespace. No change to
.o files.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.134 2015/05/19 14:16:35 mpi Exp $	*/
d260 1
a260 1
	m->m_pkthdr.rcvif = n->m_pkthdr.rcvif;
d322 3
a324 1
	ifp = m->m_pkthdr.rcvif;
@


1.134
log
@Do not leak a rtentry if it is unusable.

Found by The Brainy Code Scanner from Maxime Villard.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.133 2015/05/13 10:42:46 jsg Exp $	*/
d554 1
a554 1
		if (ia == 0)
d932 1
a932 1
	    	rtfree(rt);
d979 1
a979 1
	if (rt == 0)
d1108 1
a1108 1
	
@


1.133
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.132 2015/02/05 03:01:03 mpi Exp $	*/
d931 2
a932 1
	    (rt->rt_flags & RTF_UP) == 0)
d934 1
@


1.132
log
@Convert various rtrequest1(RTM_DELETE,...) calls to rtdeletemsg(9).

This unify some code and notify userland for free.

blambert@@ agrees, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.131 2015/01/28 22:10:13 mpi Exp $	*/
d690 1
a690 1
	struct mbuf *opts = 0;
@


1.131
log
@Revert rtdeletemsg conversion.  It was not ok'd, I misunderstood bluhm@@'s
email.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.130 2015/01/26 11:38:37 mpi Exp $	*/
a1033 1
		struct rt_addrinfo info;
a1035 6
		memset(&info, 0, sizeof(info));
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_flags = rt->rt_flags;   

d1039 1
a1039 2
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    r->rtt_tableid);
a1077 1
		struct rt_addrinfo info;
a1079 6
		memset(&info, 0, sizeof(info));
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_flags = rt->rt_flags;   

d1081 1
a1081 2
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 
		    r->rtt_tableid);
@


1.130
log
@Call rtdeletemsg(9) instead of rerolling its code.  As a bonus you'll
get userland notification for free.

ok blambert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.129 2014/12/22 11:05:53 mpi Exp $	*/
d1034 1
d1037 6
d1046 2
a1047 1
		rtdeletemsg(rt, r->rtt_tableid);
d1086 1
d1089 6
d1096 2
a1097 1
		rtdeletemsg(rt, r->rtt_tableid);
@


1.129
log
@Make sure rtrequest1(9) is called under splsoftnet().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.128 2014/12/08 10:51:00 mpi Exp $	*/
a1033 1
		struct rt_addrinfo info;
a1035 6
		memset(&info, 0, sizeof(info));
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_flags = rt->rt_flags;   

d1039 1
a1039 2
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    r->rtt_tableid);
a1077 1
		struct rt_addrinfo info;
a1079 6
		memset(&info, 0, sizeof(info));
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_flags = rt->rt_flags;   

d1081 1
a1081 2
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 
		    r->rtt_tableid);
@


1.128
log
@Do not use a "struct route" when a "struct rtentry" is enough.

ok millert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.127 2014/12/05 15:50:04 mpi Exp $	*/
d1029 1
d1035 1
d1044 2
d1054 1
d1083 1
d1087 1
d1095 1
d1098 1
@


1.127
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.126 2014/11/01 21:40:38 mpi Exp $	*/
d916 1
a916 2
	struct sockaddr_in *sin;
	struct route ro;
d920 4
a923 6
	memset(&ro, 0, sizeof(ro));
	ro.ro_tableid = rtableid;
	sin = satosin(&ro.ro_dst);
	sin->sin_family = AF_INET;
	sin->sin_len = sizeof(*sin);
	sin->sin_addr = dst;
d925 1
a925 1
	rt = rtalloc(&ro.ro_dst, RT_REPORT|RT_RESOLVE, rtableid);
d941 1
a941 1
		info.rti_info[RTAX_DST] = sintosa(sin);
@


1.126
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.125 2014/09/30 08:26:15 mpi Exp $	*/
d82 1
@


1.125
log
@Do not use the global list of IPv4 addresses in icmp_reflect()...

...but the routing table!

Note that this lookup is redundant with the one done in in_ouraddr()
and we should be able to save this information instead of redoing a
lookup if we need to send an error message.

ok kspillner@@, bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.124 2014/09/14 14:17:26 jsg Exp $	*/
d718 1
a718 1
		rt = rtalloc1(sintosa(&sin), 0, rtableid);
d738 1
a738 1
		rt = rtalloc1(sintosa(&sin), RT_REPORT, rtableid);
d927 1
a927 1
	rt = rtalloc1(&ro.ro_dst, RT_REPORT, rtableid);
@


1.124
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.123 2014/07/13 13:57:56 mpi Exp $	*/
a688 1
	struct in_addr t;
d690 2
d693 1
d705 2
a706 2
	t = ip->ip_dst;
	ip->ip_dst = ip->ip_src;
d713 10
a722 10
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (ia->ia_ifp->if_rdomain !=
			    rtable_l2(m->m_pkthdr.ph_rtableid))
				continue;
			if (t.s_addr == ia->ia_addr.sin_addr.s_addr)
				break;
			if ((ia->ia_ifp->if_flags & IFF_BROADCAST) &&
			    ia->ia_broadaddr.sin_addr.s_addr != 0 &&
			    t.s_addr == ia->ia_broadaddr.sin_addr.s_addr)
				break;
d725 1
d732 4
a735 9
		struct sockaddr_in *dst;
		struct route ro;

		memset(&ro, 0, sizeof(ro));
		ro.ro_tableid = m->m_pkthdr.ph_rtableid;
		dst = satosin(&ro.ro_dst);
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = ip->ip_src;
d738 2
a739 3
		ro.ro_rt = rtalloc1(&ro.ro_dst, RT_REPORT,
		     m->m_pkthdr.ph_rtableid);
		if (ro.ro_rt == 0) {
d745 3
a747 3
		ia = ifatoia(ro.ro_rt->rt_ifa);
		ro.ro_rt->rt_use++;
		RTFREE(ro.ro_rt);
d750 2
a751 2
	t = ia->ia_addr.sin_addr;
	ip->ip_src = t;
@


1.123
log
@Stop using old n_time, n_long and n_short types in netinet headers.

ok deraadt@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.122 2014/05/07 08:09:33 mpi Exp $	*/
a78 1
#include <sys/proc.h>
@


1.122
log
@Remove some m->m_pkthdr.rcvif dereference to help for upcoming
receiving pointer -> index conversion.  No functional change.

ok chrisz@@, jca@@, mikeb@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.121 2014/04/21 12:22:26 henning Exp $	*/
d146 1
a146 1
icmp_do_error(struct mbuf *n, int type, int code, n_long dest, int destmtu)
d292 1
a292 1
icmp_error(struct mbuf *n, int type, int code, n_long dest, int destmtu)
d852 1
a852 1
n_time
@


1.121
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.120 2014/04/21 11:10:54 henning Exp $	*/
d308 1
d322 2
d486 1
a486 1
		if (m->m_pkthdr.rcvif->if_type == IFT_CARP &&
d551 1
a551 1
		if (m->m_pkthdr.rcvif == NULL)
d553 1
a553 2
		ia = ifatoia(ifaof_ifpforaddr(sintosa(&sin),
		    m->m_pkthdr.rcvif));
d570 1
a570 1
		if (m->m_pkthdr.rcvif->if_type == IFT_CARP &&
d636 1
a636 1
		if (m->m_pkthdr.rcvif->if_type == IFT_CARP &&
@


1.120
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.118 2014/03/21 10:44:42 mpi Exp $	*/
d847 1
a847 1
	ip_output(m, opts, NULL, 0, NULL, NULL);
@


1.119
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d847 1
a847 1
	(void)ip_output(m, opts, (void *)NULL, 0, (void *)NULL, (void *)NULL);
@


1.118
log
@rt_timer* spring cleanup.

Rename and document rt_timer_count() into rt_timer_queue_count() to
be consistent with the other functions.  Remove unused argument from
rt_timer_queue_destroy(), clean the definitions and finally use the
same order in NAME and DESCRIPTION as requested by jmc@@.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.117 2014/03/20 11:22:15 benno Exp $	*/
d221 2
a222 2
	/* keep in same domain and rtable (the latter is a bit unclear) */
	m->m_pkthdr.rdomain = n->m_pkthdr.rdomain;
d494 1
a494 1
			(*ctlfunc)(code, sintosa(&sin), m->m_pkthdr.rdomain,
d641 1
a641 1
		    &newrt, m->m_pkthdr.rdomain);
d644 1
a644 1
			    icmp_redirect_timeout_q, m->m_pkthdr.rdomain);
d712 1
a712 1
			    rtable_l2(m->m_pkthdr.rdomain))
d732 1
a732 1
		ro.ro_tableid = m->m_pkthdr.rdomain;
d740 1
a740 1
		     m->m_pkthdr.rdomain);
@


1.117
log
@revert rev. 1.115

  In case imcp_reflect() is called without a given source address
  do not try to find a matching address by iterating over a global
  list and always use the routing table.

This breaks icmp echo replies (and maybe more) on machines with >1 ip
"reverting is safer and make it clear that this function needs more love"
ok florian@@, mpi@@ for the revert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.116 2014/03/13 01:22:54 jsg Exp $	*/
d879 1
a879 2
				rt_timer_queue_destroy(icmp_redirect_timeout_q,
				    TRUE);
@


1.116
log
@fix buffer overflows in icmp redirect handling introduced in rev 1.106
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.115 2014/03/11 10:28:55 mpi Exp $	*/
d705 19
@


1.115
log
@In case imcp_reflect() is called without a given source address
do not try to find a matching address by iterating over a global
list and always use the routing table.

Idea from claudio@@, moral support from henning@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.114 2014/01/19 05:01:50 claudio Exp $	*/
d614 6
a619 3
		memcpy(&sdst.sin_addr, &icp->icmp_ip.ip_dst, sizeof(sdst));
		memcpy(&sgw.sin_addr, &icp->icmp_gwaddr, sizeof(sgw));
		memcpy(&ssrc.sin_addr, &ip->ip_src, sizeof(ssrc));
@


1.114
log
@Start counting droped icmp errors because the rate limit is exceeded.
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.113 2014/01/09 06:29:06 tedu Exp $	*/
a701 19
	 * If the incoming packet was addressed directly to us,
	 * use dst as the src for the reply.  For broadcast, use
	 * the address which corresponds to the incoming interface.
	 */
	if (ia == NULL) {
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (ia->ia_ifp->if_rdomain !=
			    rtable_l2(m->m_pkthdr.rdomain))
				continue;
			if (t.s_addr == ia->ia_addr.sin_addr.s_addr)
				break;
			if ((ia->ia_ifp->if_flags & IFF_BROADCAST) &&
			    ia->ia_broadaddr.sin_addr.s_addr != 0 &&
			    t.s_addr == ia->ia_broadaddr.sin_addr.s_addr)
				break;
		}
	}
	/*
	 * The following happens if the packet was not addressed to us.
@


1.114.4.1
log
@apply OpenBSD 5.5 errata 1: Memory corruption happens during
ICMP reflection handling. ICMP reflection is disabled by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.114 2014/01/19 05:01:50 claudio Exp $	*/
d614 3
a616 6
		memcpy(&sdst.sin_addr, &icp->icmp_ip.ip_dst,
		    sizeof(sdst.sin_addr));
		memcpy(&sgw.sin_addr, &icp->icmp_gwaddr,
		    sizeof(sgw.sin_addr));
		memcpy(&ssrc.sin_addr, &ip->ip_src,
		    sizeof(ssrc.sin_addr));
@


1.113
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.112 2013/12/31 03:24:44 tedu Exp $	*/
d181 4
a184 2
	if (icmp_ratelimit(&oip->ip_src, type, code))
		goto freeit;	/* XXX stat */
@


1.112
log
@bcopy -> memcpy. reviewed with one fix from matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.111 2013/11/26 11:27:41 henning Exp $	*/
d476 1
a476 1
		bzero(&sin, sizeof(sin));
d538 1
a538 1
		bzero(&sin, sizeof(sin));
d607 3
a609 3
		bzero(&sdst, sizeof(sdst));
		bzero(&sgw, sizeof(sgw));
		bzero(&ssrc, sizeof(ssrc));
d726 1
a726 1
		bzero((caddr_t) &ro, sizeof(ro));
d918 1
a918 1
	bzero(&ro, sizeof(ro));
d940 1
a940 1
		bzero(&info, sizeof(info));
d1035 1
a1035 1
		bzero(&info, sizeof(info));
d1082 1
a1082 1
		bzero(&info, sizeof(info));
d1126 1
a1126 1
	bzero(&hdr, sizeof(hdr));
@


1.111
log
@instead of calculating the icmp checksum here, just set the flag that
it is needed and the lower parts of the stack will take care of it.
fixes a cksum bug in a rather constructed case and is just the right thing
to do now. ok mpi naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.109 2013/11/11 09:15:34 mpi Exp $	*/
d612 3
a614 3
		bcopy(&icp->icmp_ip.ip_dst, &sdst.sin_addr, sizeof(sdst));
		bcopy(&icp->icmp_gwaddr, &sgw.sin_addr, sizeof(sgw));
		bcopy(&ip->ip_src, &ssrc.sin_addr, sizeof(ssrc));
d792 2
a793 3
					bcopy((caddr_t)cp,
					    mtod(opts, caddr_t) + opts->m_len,
					    len);
@


1.110
log
@Instead of stripping the IP options manually in icmp_reflect(),
just call ip_stripoptions().  Remove an unneeded parameter and
adjust the ip length in ip_stripoptions().
from FreeBSD; OK deraadt@@ henninh@@ lteo@@
@
text
@d820 1
a820 2
 * Send an icmp packet back to the ip level,
 * after supplying a checksum.
d832 1
a832 1
	icp->icmp_cksum = in4_cksum(m, 0, hlen, ntohs(ip->ip_len) - hlen);
@


1.109
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.108 2013/10/21 12:27:11 deraadt Exp $	*/
d810 1
a810 12
		/*
		 * Now strip out original options by copying rest of first
		 * mbuf's data back, and adjust the IP length.
		 */
		ip->ip_len = htons(ntohs(ip->ip_len) - optlen);
		ip->ip_hl = sizeof(struct ip) >> 2;
		m->m_len -= optlen;
		if (m->m_flags & M_PKTHDR)
			m->m_pkthdr.len -= optlen;
		optlen += sizeof(struct ip);
		bcopy((caddr_t)ip + optlen, (caddr_t)(ip + 1),
		    m->m_len - sizeof(struct ip));
@


1.108
log
@There are gasps of shock!  Add a pmtu delay sysctl BUTTON for netinet6,
making the code the same as netinet4 along the way.
ok bluhm phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.107 2013/10/20 11:03:01 phessler Exp $	*/
d326 1
a326 1
		char buf[4 * sizeof("123")];
d328 4
a331 3
		strlcpy(buf, inet_ntoa(ip->ip_dst), sizeof buf);
		printf("icmp_input from %s to %s, len %d\n",
		    inet_ntoa(ip->ip_src), buf, icmplen);
d618 5
a622 3
			char buf[4 * sizeof("123")];
			strlcpy(buf, inet_ntoa(icp->icmp_ip.ip_dst),
			    sizeof buf);
d624 1
a624 2
			printf("redirect dst %s to %s\n",
			    buf, inet_ntoa(icp->icmp_gwaddr));
d847 4
a850 1
		char buf[4 * sizeof("123")];
d852 1
a852 3
		strlcpy(buf, inet_ntoa(ip->ip_dst), sizeof buf);
		printf("icmp_send dst %s src %s\n",
		    buf, inet_ntoa(ip->ip_src));
@


1.107
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.106 2013/08/21 09:05:22 mpi Exp $	*/
a1075 1

d1079 2
a1080 4
		return 1;

	/*okay to send*/
	return 0;
d1128 1
a1128 1
	/* the actuall offset starts after the common ICMP header */
@


1.106
log
@Stop using static variables in ICMP. While this is perfectly ok for
the moment because there might be at most one caller at a time, it
wont be so as soon as this part of the network stack is run in
parallel.

While here also reduce the difference with the icmp6 code adding a
redirect route.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.105 2013/08/13 09:52:53 mpi Exp $	*/
d725 1
d929 1
@


1.105
log
@When net.inet.ip.sourceroute is enable, store the source route
of incoming IPv4 packets with the SSRR or LSRR header option in
a m_tag rather than in a single static entry.

Use a new m_tag type, PACKET_TAG_SRCROUTE, for this and bump
PACKET_TAG_MAXSIZE accordingly.

Adapted from FreeBSD r135274 with inputs from bluhm@@.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.104 2013/08/08 14:59:22 mpi Exp $	*/
a299 4
struct sockaddr_in icmpsrc = { sizeof (struct sockaddr_in), AF_INET };
static struct sockaddr_in icmpdst = { sizeof (struct sockaddr_in), AF_INET };
static struct sockaddr_in icmpgw = { sizeof (struct sockaddr_in), AF_INET };

d308 2
a309 2
	int icmplen;
	int i;
a311 2
	int code;
	int hlen;
a312 1
	struct rtentry *rt;
d475 4
a478 1
		icmpsrc.sin_addr = icp->icmp_ip.ip_dst;
d481 1
a481 1
		    carp_lsdrop(m, AF_INET, &icmpsrc.sin_addr.s_addr,
d491 1
a491 1
			(*ctlfunc)(code, sintosa(&icmpsrc), m->m_pkthdr.rdomain,
d537 3
d542 1
a542 1
			icmpdst.sin_addr = ip->ip_src;
d544 1
a544 1
			icmpdst.sin_addr = ip->ip_dst;
d547 1
a547 1
		ia = ifatoia(ifaof_ifpforaddr(sintosa(&icmpdst),
d581 6
d606 9
a614 2
		icmpgw.sin_addr = ip->ip_src;
		icmpdst.sin_addr = icp->icmp_gwaddr;
d625 1
a625 1
		icmpsrc.sin_addr = icp->icmp_ip.ip_dst;
d628 1
a628 1
		    carp_lsdrop(m, AF_INET, &icmpsrc.sin_addr.s_addr,
d632 5
a636 7
		rt = NULL;
		rtredirect(sintosa(&icmpsrc), sintosa(&icmpdst),
		    (struct sockaddr *)0, RTF_GATEWAY | RTF_HOST,
		    sintosa(&icmpgw), (struct rtentry **)&rt,
		    m->m_pkthdr.rdomain);
		if (rt != NULL && icmp_redirtimeout != 0) {
			(void)rt_timer_add(rt, icmp_redirect_timeout,
d639 3
a641 3
		if (rt != NULL)
			rtfree(rt);
		pfctlinput(PRC_REDIRECT_HOST, sintosa(&icmpsrc));
d643 1
a643 1

@


1.104
log
@Constify the table of common MTUs and use nitems(), no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.103 2013/08/08 14:29:28 mpi Exp $	*/
d748 1
a748 1
		if (op && (opts = ip_srcroute()) == 0 &&
@


1.103
log
@Change MTU discovery functions to not abuse the global icmpsrc variable
to pass the destination address of the route to clone.

ok markus@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.102 2013/06/17 02:31:37 lteo Exp $	*/
d962 6
a973 7
	/* Table of common MTUs: */

	static u_short mtu_table[] = {
		65535, 65280, 32000, 17914, 9180, 8166,
		4352, 2002, 1492, 1006, 508, 296, 68, 0
	};

a986 1

d996 1
a996 1
		for (i = 0; i < sizeof(mtu_table) / sizeof(mtu_table[0]); i++)
@


1.102
log
@In icmp_do_exthdr(), calculate the ICMP extension header checksums with
in4_cksum() instead of in_cksum().  This gets rid of the clunky
m_data/m_len dance, which was described as "disgusting" in the original
comments. :)

Tested on a small MPLS test network (since icmp_do_exthdr() is currently
only used by MPLS code, specifically mpls_do_error()).

ok bluhm henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.101 2013/06/05 15:22:32 bluhm Exp $	*/
d910 1
a910 1
icmp_mtudisc_clone(struct sockaddr *dst, u_int rtableid)
d912 2
d917 8
a924 2
	rt = rtalloc1(dst, RT_REPORT, rtableid);
	if (rt == 0)
d939 1
a939 1
		info.rti_info[RTAX_DST] = dst;
a965 1
	struct sockaddr *dst = sintosa(&icmpsrc);
d975 1
a975 1
	rt = icmp_mtudisc_clone(dst, rtableid);
@


1.101
log
@If an ICMP packet gets diverted to a raw IP socket, if must not be
consumed by icmp_input().  As an exception, control packets that
belong to a connection to a local socket must go to pr_ctlinput().
Add a switch over the ICMP type to handle that.
OK markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.100 2013/06/05 02:25:05 lteo Exp $	*/
d1138 2
a1139 7
	/* this is disgusting, in_cksum() is stupid */
	n->m_data += off;
	n->m_len -= off;
	ieh = mtod(n, struct icmp_ext_hdr *);
	ieh->ieh_cksum = in_cksum(n, sizeof(hdr) + len);
	n->m_data -= off;
	n->m_len += off;
@


1.100
log
@Calculate ICMP checksums with in4_cksum() which lets us get rid of the
clunky m_data/m_len dance needed by in_cksum().

Tested on amd64, hppa, i386, loongson, macppc, sgi, and sparc64.

Thanks to blambert@@, bluhm@@, and henning@@ for help and feedback;
abieber@@ for testing this diff independently on macppc; krw@@ for access
to his hppa, sgi, and sparc64 test systems at t2k13; nick@@ for helping
me figure out Ken's hppa so that I can test this diff. :)

ok blambert bluhm henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.99 2013/05/03 09:35:20 mpi Exp $	*/
d366 23
@


1.99
log
@Document which gobal variables are used for sysctl(8), add static to
gobals used only in this file and explain that the printf/debug
variable must be settable by ddb.

ok henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.98 2013/04/24 10:17:08 mpi Exp $	*/
d350 1
a350 4
	m->m_len -= hlen;
	m->m_data += hlen;
	icp = mtod(m, struct icmp *);
	if (in_cksum(m, icmplen)) {
a353 2
	m->m_len += hlen;
	m->m_data -= hlen;
d355 1
d806 1
a806 3
	m->m_data += hlen;
	m->m_len -= hlen;
	icp = mtod(m, struct icmp *);
d808 1
a808 3
	icp->icmp_cksum = in_cksum(m, ntohs(ip->ip_len) - hlen);
	m->m_data -= hlen;
	m->m_len += hlen;
@


1.98
log
@Instead of having various extern declarations for protocol variables,
declare them once in their corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.97 2013/04/10 08:50:59 mpi Exp $	*/
d108 5
a115 3
#ifdef ICMPPRINTFS
int	icmpprintfs = 0;
#endif
a116 2
int	icmperrpps_count = 0;
struct timeval icmperrppslim_last;
d119 4
@


1.97
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.96 2012/09/18 12:35:51 blambert Exp $	*/
a126 5

/* from ip_input.c */
extern	u_char ip_protox[];

extern	struct protosw inetsw[];
@


1.96
log
@sysctl calls shouldn't clobber route timers without spl protection

the spl call in the icmp case may be too aggressive, but better safe
than sorry

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.95 2012/04/13 09:38:32 deraadt Exp $	*/
d128 3
a317 2
	extern u_char ip_protox[];
	extern int ipforwarding;
a1010 1
		extern u_char ip_protox[];
@


1.95
log
@unneccessary casts to unsigned; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.94 2011/07/06 01:57:37 dlg Exp $	*/
d844 1
d850 1
d852 1
a852 2
	case ICMPCTL_REDIRTIMEOUT: {
		int error;
d868 1
a868 1
		return (error);
d870 7
d878 1
a878 6
	}
	case ICMPCTL_STATS:
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &icmpstat, sizeof(icmpstat)));
d880 7
a886 4
		if (name[0] < ICMPCTL_MAXID)
			return (sysctl_int_arr(icmpctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (ENOPROTOOPT);
d888 3
a890 1
	/* NOTREACHED */
@


1.94
log
@allow /31s on broadcast interfaces (eg ethernet) to work as per rfc3021.
the issue in our kernel was the broadcast address calculated on the /31
caused a ton of checks for use of broadcast addresses to kick in and
prevent one of the two addresses on the /31 from being used.

this diff basically detects if a /31 has been configured and doesnt
configure a broadcast address for it, which makes the ips usable
for normal traffic.

i wrote this so i could interoperate with "carrier" network gear
better, and sthen wants it so he can conserve address space use.

the further special casing of broadcast address handling was from claudio@@

ok claudio@@ markus@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.93 2011/04/04 16:33:52 claudio Exp $	*/
d789 1
a789 1
		    (unsigned)(m->m_len - sizeof(struct ip)));
@


1.93
log
@Do not accept ICMP redirects when acting as router (ipforwarding = 1).
Same logic is already implemented in netinet6
OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.92 2010/09/13 09:59:32 claudio Exp $	*/
d536 6
a541 2
			if (ia->ia_ifp->if_flags & IFF_BROADCAST)
				ip->ip_src = ia->ia_broadaddr.sin_addr;
d681 1
@


1.92
log
@Change icmp_reflect() so that it does not call icmp_send directly. This
allows other users (like MPLS) use this function instead of rolling a own
version. Implement icmp_do_exthdr() to attach an RFC 4884 extension header
to an ICMP error produced by icmp_do_error().
"best to get it in." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.91 2010/07/09 15:44:20 claudio Exp $	*/
d316 1
d562 1
a562 1
		if (icmp_rediraccept == 0)
@


1.91
log
@Add the rtableid to struct rttimer and therefor  make it available to
the callback functions. This fixes a problem where dynamic routes in
different tables would not get deleted because the callback was doing
the remove on the wrong table.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.90 2010/07/03 04:44:51 guenther Exp $	*/
d294 2
a295 1
		icmp_reflect(m);
d319 1
d513 4
a520 4
		if (icmplen < ICMP_MASKLEN) {
			icmpstat.icps_badlen++;
			break;
		}
d553 2
a554 1
		icmp_reflect(m);
d643 2
a644 2
void
icmp_reflect(struct mbuf *m)
a646 1
	struct in_ifaddr *ia;
d654 2
a655 2
		m_freem(m);	/* Bad return address */
		goto done;	/* ip_output() will check for broadcast */
d668 11
a678 8
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (ia->ia_ifp->if_rdomain != rtable_l2(m->m_pkthdr.rdomain))
			continue;
		if (t.s_addr == ia->ia_addr.sin_addr.s_addr)
			break;
		if ((ia->ia_ifp->if_flags & IFF_BROADCAST) &&
		    t.s_addr == ia->ia_broadaddr.sin_addr.s_addr)
			break;
d685 1
a685 1
	if (ia == (struct in_ifaddr *)0) {
d701 1
a701 1
			goto done;
d723 1
a723 1
		if ((opts = ip_srcroute()) == 0 &&
d728 1
a728 1
		if (opts) {
d786 4
a789 4
	icmp_send(m, opts);
done:
	if (opts)
		(void)m_free(opts);
d1059 62
@


1.90
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.89 2010/05/07 13:33:16 claudio Exp $	*/
d600 1
a600 1
			    icmp_redirect_timeout_q);
d910 2
a911 1
	error = rt_timer_add(rt, icmp_mtudisc_timeout, ip_mtudisc_timeout_q);
a982 1
/* XXX only handles table 0 right now */
d1002 2
a1003 2
		/* XXX this needs the rtableid */
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 0);
d1008 2
a1009 1
			(*ctlfunc)(PRC_MTUINC,(struct sockaddr *)&sa, 0, NULL);
a1035 1
/* XXX only handles table 0 right now */
d1051 2
a1052 1
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 0);
@


1.89
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.88 2010/04/20 22:05:43 tedu Exp $	*/
d1002 1
@


1.88
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.87 2010/02/09 13:23:39 claudio Exp $	*/
d691 1
a691 1
		ro.ro_rt = rtalloc1(&ro.ro_dst, 1,
d881 1
a881 1
	rt = rtalloc1(dst, 1, rtableid);
@


1.87
log
@Before cloning a route to change the MTU check that the route we clone from
is valid and usable (reject and blackholes are not conidered usable).
TCP has this nasty behaviour to clone routes to disable PMTU and this combined
with dynamic routing resulted in dead sessions when there was a default reject
route installed.
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.86 2009/11/13 20:54:05 claudio Exp $	*/
d79 1
@


1.86
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.85 2009/11/03 10:59:04 claudio Exp $	*/
d882 5
@


1.85
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.84 2009/06/09 11:52:54 sthen Exp $	*/
d311 1
a311 1
	void *(*ctlfunc)(int, struct sockaddr *, void *);
d472 2
a473 1
			(*ctlfunc)(code, sintosa(&icmpsrc), &icp->icmp_ip);
d984 1
a984 1
		void *(*ctlfunc)(int, struct sockaddr *, void *);
d1001 1
a1001 1
			(*ctlfunc)(PRC_MTUINC,(struct sockaddr *)&sa, NULL);
@


1.84
log
@By default, don't accept IPv4 ICMP redirects. This behaviour can be
changed with a sysctl, so note it in sysctl.conf. v6 needs further
testing following discussions on the tech mailing list; rainer@@ points
out possible interactions with neighbour discovery which need to be
investigated first.

"go ahead on the v4 part" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.83 2009/06/05 00:05:22 claudio Exp $	*/
a591 1
		/* XXX rdomain vs. rtable */
d665 1
a665 1
		if (ia->ia_ifp->if_rdomain != m->m_pkthdr.rdomain)
d688 1
a688 1
		/* keep packet in the original VRF instance */
@


1.83
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.82 2008/09/10 09:10:55 henning Exp $	*/
d116 1
a116 1
int	icmp_rediraccept = 1;
@


1.82
log
@icmp_reflect reuses mbufs. call pf_pkt_addr_changed to clear the state
key stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.81 2008/06/08 18:56:12 claudio Exp $	*/
d216 2
d592 1
d595 2
a596 1
		    sintosa(&icmpgw), (struct rtentry **)&rt);
d666 2
d689 3
a691 1
		rtalloc(&ro);
a873 1
/* XXX only handles table 0 right now */
d875 1
a875 1
icmp_mtudisc_clone(struct sockaddr *dst)
d880 1
a880 1
	rt = rtalloc1(dst, 1, 0);
d895 1
a895 1
		error = rtrequest1(RTM_ADD, &info, rt->rt_priority, &nrt, 0);
d914 1
a914 1
icmp_mtudisc(struct icmp *icp)
d927 1
a927 1
	rt = icmp_mtudisc_clone(dst);
@


1.81
log
@When adding PMTU related routes to the table inherit the priority form the
parent instead of using RTP_DEFAULT. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.80 2008/05/09 15:48:59 claudio Exp $	*/
d72 1
d97 4
d650 4
@


1.80
log
@more rtrequest() to rtrequest1() replacement.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.79 2008/02/05 22:57:31 mpf Exp $	*/
d879 1
a879 1
		error = rtrequest1(RTM_ADD, &info, RTP_DEFAULT, &nrt, 0);
@


1.79
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.78 2007/12/13 20:00:53 reyk Exp $	*/
d872 1
d874 6
a879 4
		error = rtrequest((int) RTM_ADD, dst,
		    (struct sockaddr *) rt->rt_gateway,
		    (struct sockaddr *) 0,
		    RTF_GATEWAY | RTF_HOST | RTF_DYNAMIC, &nrt, 0);
d971 7
d980 1
a980 2
		rtrequest((int) RTM_DELETE, (struct sockaddr *)rt_key(rt),
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0, 0);
d1020 9
a1028 2
		rtrequest((int) RTM_DELETE, (struct sockaddr *)rt_key(rt),
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0, 0);
@


1.78
log
@implement sysctls to report IP, TCP, UDP, and ICMP statistics and
change netstat to use them instead of accessing kvm for it. more
protocols will be added later.

discussed with deraadt@@ claudio@@ gilles@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.77 2007/11/24 12:59:28 jmc Exp $	*/
a454 1
		    m->m_pkthdr.rcvif->if_flags & IFF_LINK0 &&
a531 1
		    m->m_pkthdr.rcvif->if_flags & IFF_LINK0 &&
a579 1
		    m->m_pkthdr.rcvif->if_flags & IFF_LINK0 &&
@


1.77
log
@some spelling fixes from Martynas Venckus
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.76 2007/06/11 11:29:35 henning Exp $	*/
d845 5
@


1.76
log
@there was code inside #if NPF > 0, but pf.h was not included, so it did
not get build. the code looks at flags that used to be in mbuf tags, now
they are in the mbuf header, so we can check them unconditionally.
problem spotted by Daniel Roethlisberger <daniel@@roe.ch>, ok ryan markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.75 2007/05/27 19:55:13 dlg Exp $	*/
d261 1
a261 1
	/* move PF_GENERATED to new packet, if existant XXX preserve more? */
@


1.75
log
@remove static from icmp_redirect_timeout

"commit it" art@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.74 2007/05/09 14:35:25 deraadt Exp $	*/
a144 3
#if NPF > 0
	struct pf_mtag	*mtag;
#endif
d260 1
a260 1
#if NPF > 0
d262 3
a264 6
	if ((mtag = pf_find_mtag(n)) != NULL &&
	    mtag->flags & PF_TAG_GENERATED) {
		mtag = pf_get_tag(m);
		mtag->flags |= PF_TAG_GENERATED;
	}
#endif
@


1.74
log
@totally unused legacy variable; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.73 2007/03/18 23:23:17 mpf Exp $	*/
d120 1
a120 1
static void icmp_redirect_timeout(struct rtentry *, struct rttimer *);
d1008 1
a1008 1
static void
@


1.73
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.72 2007/01/03 18:39:56 claudio Exp $	*/
a297 1
struct sockaddr_in icmpmask = { 8, 0 };
@


1.72
log
@Remove two "unused" mbuf tag functions and kill the superfluous argument
to the m_tag_delete_chain() function.
m_tag_free() and m_tag_unlink() are only used by m_tag_delete() and I see
no need to have these functions around.
m_tag_delete_chain() has a second argument to specifiy a starting point
from where the chain should be deleted. This feature is never used and is
more complex because it is not possible to remove a SLIST element without
doing a list walk. Instead use SLIST_FIRST() and SLIST_REMOVE_HEAD() to
remove all items from the list. OK dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.71 2006/06/16 16:49:40 henning Exp $	*/
d71 2
d91 5
d460 7
d538 7
d587 7
@


1.71
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.70 2006/03/05 21:48:56 miod Exp $	*/
d417 1
a417 1
			m_tag_delete_chain(m, NULL);
d526 1
a526 1
			m_tag_delete_chain(m, NULL);
d536 1
a536 1
			m_tag_delete_chain(m, NULL);
@


1.70
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.69 2005/10/17 08:43:34 henning Exp $	*/
d833 2
d841 1
a841 1
	rt = rtalloc1(dst, 1);
d853 1
a853 1
		    RTF_GATEWAY | RTF_HOST | RTF_DYNAMIC, &nrt);
d934 1
d948 1
a948 1
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
d980 1
d989 1
a989 1
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
@


1.69
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.68 2005/07/31 03:30:55 pascoe Exp $	*/
d634 1
a634 1
	for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
@


1.68
log
@Change the API for icmp_do_error so that it takes the mtu directly, rather
than a pointer to struct ifnet containing it.

Saves a 448 byte stack allocation in ip_forward which previously faked up
a struct ifnet just for this purpose.

idea ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.67 2005/06/30 08:51:31 markus Exp $	*/
a136 1
	struct m_tag *mtag;
d138 3
d256 6
a261 5
	/* move PF_GENERATED m_tag to new packet, if it exists */
	mtag = m_tag_find(n, PACKET_TAG_PF_GENERATED, NULL);
	if (mtag != NULL) {
		m_tag_unlink(n, mtag);
		m_tag_prepend(m, mtag);
d263 1
a263 1

@


1.67
log
@implement PMTU checks from
        http://www.gont.com.ar/drafts/icmp-attacks-against-tcp.html
i.e. don't act on ICMP-need-frag immediately if adhoc checks on the
advertised mtu fail.  the mtu update is delayed until a tcp retransmit
happens.  initial patch by Fernando Gont, tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.66 2005/01/18 22:25:38 claudio Exp $	*/
d131 1
a131 2
icmp_do_error(struct mbuf *n, int type, int code, n_long dest,
    struct ifnet *destifp)
d225 2
a226 2
		    code == ICMP_UNREACH_NEEDFRAG && destifp)
			icp->icmp_nextmtu = htons(destifp->if_mtu);
d276 1
a276 2
icmp_error(struct mbuf *n, int type, int code, n_long dest,
    struct ifnet *destifp)
d280 1
a280 1
	m = icmp_do_error(n, type, code, dest, destifp);
@


1.66
log
@Use correct source address for ICMP errors generated from packets that were
not addressed to the machine. If the destination is not a local address do a
route lookup for the original source address and use the returned interface
address. This solves problems seen on interfaces with multiple networks
defined.  OK henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.65 2004/06/22 07:35:20 cedric Exp $	*/
d287 1
a287 1
static struct sockaddr_in icmpsrc = { sizeof (struct sockaddr_in), AF_INET };
@


1.65
log
@Pull the plug on source-based routing until remaining bugs are eradicated.
No need to reconfig kernel or rebuild userland stuff.
requested deraadt@@, help beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.64 2004/06/06 16:49:09 cedric Exp $	*/
d630 2
a631 3
	 * use dst as the src for the reply.  Otherwise (broadcast
	 * or anonymous), use the address which corresponds
	 * to the incoming interface.
a639 4
	icmpdst.sin_addr = t;
	if ((ia == (struct in_ifaddr *)0) && (m->m_pkthdr.rcvif != NULL))
		ia = ifatoia(ifaof_ifpforaddr(sintosa(&icmpdst),
		    m->m_pkthdr.rcvif));
d641 3
a643 2
	 * The following happens if the packet was not addressed to us,
	 * and was received on an interface with no IP address.
d653 1
a653 1
		dst->sin_addr = t;
@


1.64
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.63 2004/04/26 01:47:24 deraadt Exp $	*/
d567 1
a567 1
		    (struct sockaddr *)&rt_defmask4, RTF_GATEWAY | RTF_HOST,
d853 1
a853 1
		    sroute_clone_mask4(rt_mask(rt), NULL),
@


1.63
log
@minor cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.62 2004/02/15 11:16:08 markus Exp $	*/
d567 1
a567 1
		    (struct sockaddr *)0, RTF_GATEWAY | RTF_HOST,
d853 1
a853 1
		    (struct sockaddr *) 0,
@


1.62
log
@switch to sysctl_int_arr(); ok itojun, henning, miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.61 2003/07/09 22:03:16 itojun Exp $	*/
d644 1
a644 1
					      m->m_pkthdr.rcvif));
d650 1
a650 1
	        struct sockaddr_in *dst;
d668 2
a669 2
                RTFREE(ro.ro_rt);
        }
d881 4
a884 2
	static u_short mtu_table[] = {65535, 65280, 32000, 17914, 9180, 8166,
				      4352, 2002, 1492, 1006, 508, 296, 68, 0};
@


1.61
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.60 2003/06/02 23:28:14 millert Exp $	*/
d109 2
a805 17
	case ICMPCTL_TSTAMPREPL:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmptstamprepl));
	case ICMPCTL_MASKREPL:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmpmaskrepl));
	case ICMPCTL_BMCASTECHO:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmpbmcastecho));
	case ICMPCTL_ERRPPSLIMIT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmperrppslim));
		break;
	case ICMPCTL_REDIRACCEPT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmp_rediraccept));
		break;
d828 3
@


1.60
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.59 2003/05/14 05:58:36 dhartmei Exp $	*/
d150 1
a150 1
	if (oip->ip_off & IP_OFFMASK)
d172 1
a172 1
	icmplen = oiplen + min(8, oip->ip_len);
a227 2
	HTONS(oip->ip_off);
	HTONS(oip->ip_len);
d246 1
a246 1
	nip->ip_len = m->m_len;
d298 1
a298 1
	int icmplen = ip->ip_len;
d316 1
a425 1
		NTOHS(icp->icmp_ip.ip_len);
a524 1
		ip->ip_len += hlen;	/* since ip_input deducts this */
d736 1
a736 1
		ip->ip_len -= optlen;
d768 1
a768 1
	icp->icmp_cksum = in_cksum(m, ip->ip_len - hlen);
d903 1
a903 1
		mtu = icp->icmp_ip.ip_len; /* NTOHS happened in deliver: */
@


1.59
log
@Remove redundant assignment. Found by Julien Bordet. ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.58 2003/05/03 21:16:30 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.58
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.57 2003/02/12 14:41:07 jason Exp $	*/
a235 1
	nip = &icp->icmp_ip;
@


1.57
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.56 2003/02/01 19:34:06 henning Exp $	*/
d327 1
a327 1
		strcpy(buf, inet_ntoa(ip->ip_dst));
d563 2
a564 1
			strcpy(buf, inet_ntoa(icp->icmp_ip.ip_dst));
d783 1
a783 1
		strcpy(buf, inet_ntoa(ip->ip_dst));
@


1.56
log
@quite some KNF & ANSI

ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.55 2003/01/31 17:27:03 deraadt Exp $	*/
d111 1
@


1.55
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.54 2003/01/31 17:23:34 henning Exp $	*/
d49 4
a52 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d119 1
a119 1
icmp_init()
d127 1
a127 1
			rt_timer_queue_create(icmp_redirtimeout);
d132 2
a133 5
icmp_do_error(n, type, code, dest, destifp)
	struct mbuf *n;
	int type, code;
	n_long dest;
	struct ifnet *destifp;
d156 3
a158 2
	  n->m_len >= oiplen + ICMP_MINLEN &&
	  !ICMP_INFOTYPE(((struct icmp *)((caddr_t)oip + oiplen))->icmp_type)) {
d169 2
a170 4
	if (icmp_ratelimit(&oip->ip_src, type, code)) {
		/* XXX stat */
		goto freeit;
	}
d281 2
a282 5
icmp_error(n, type, code, dest, destifp)
	struct mbuf *n;
	int type, code;
	n_long dest;
	struct ifnet *destifp;
d324 1
a324 1
		char buf[4*sizeof "123"];
d328 1
a328 1
			inet_ntoa(ip->ip_src), buf, icmplen);
d446 2
a447 1
				icp = (struct icmp *)(m->m_data + (ip->ip_hl << 2));
d561 1
a561 1
			char buf[4 * sizeof "123"];
d575 1
a575 1
			 		 icmp_redirect_timeout_q);
d616 1
a616 2
icmp_reflect(m)
	struct mbuf *m;
d626 1
a626 1
	     htonl(IN_LOOPBACKNET << IN_CLASSA_NSHIFT))) {
d696 3
a698 3
		    if (icmpprintfs)
			    printf("icmp_reflect optlen %d rt %d => ",
				optlen, opts->m_len);
d700 33
a732 32
		    for (cnt = optlen; cnt > 0; cnt -= len, cp += len) {
			    opt = cp[IPOPT_OPTVAL];
			    if (opt == IPOPT_EOL)
				    break;
			    if (opt == IPOPT_NOP)
				    len = 1;
			    else {
				    if (cnt < IPOPT_OLEN + sizeof(*cp))
					    break;
				    len = cp[IPOPT_OLEN];
				    if (len < IPOPT_OLEN + sizeof(*cp) ||
				        len > cnt)
					    break;
			    }
			    /*
			     * Should check for overflow, but it "can't happen"
			     */
			    if (opt == IPOPT_RR || opt == IPOPT_TS ||
				opt == IPOPT_SECURITY) {
				    bcopy((caddr_t)cp,
					mtod(opts, caddr_t) + opts->m_len, len);
				    opts->m_len += len;
			    }
		    }
		    /* Terminate & pad, if necessary */
		    if ((cnt = opts->m_len % 4) != 0) {
			    for (; cnt < 4; cnt++) {
				    *(mtod(opts, caddr_t) + opts->m_len) =
					IPOPT_EOL;
				    opts->m_len++;
			    }
		    }
d734 2
a735 2
		    if (icmpprintfs)
			    printf("%d\n", opts->m_len);
d749 1
a749 1
			 (unsigned)(m->m_len - sizeof(struct ip)));
d763 1
a763 3
icmp_send(m, opts)
	struct mbuf *m;
	struct mbuf *opts;
d779 1
a779 1
		char buf[4 * sizeof "123"];
d786 1
a786 1
	(void) ip_output(m, opts, (void *)NULL, 0, (void *)NULL, (void *)NULL);
d790 1
a790 1
iptime()
d801 2
a802 7
icmp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
d811 2
a812 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &icmptstamprepl));
d814 2
a815 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &icmpmaskrepl));
d817 2
a818 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &icmpbmcastecho));
d831 1
a831 1
			    &icmp_redirtimeout);
d837 1
a837 1
			} else {
a839 1
			}
d891 1
a891 2
icmp_mtudisc(icp)
	struct icmp *icp;
d944 1
a944 1
			 rt->rt_rmx.rmx_mtu == 0)
d952 1
a952 3
icmp_mtudisc_timeout(rt, r)
	struct rtentry *rt;
	struct rttimer *r;
d970 2
a971 2
	} else {
		if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0) {
a972 2
		}
	}
d984 1
a984 4
icmp_ratelimit(dst, type, code)
	const struct in_addr *dst;
	const int type;			/* not used at this moment */
	const int code;			/* not used at this moment */
d989 1
a989 2
	    icmperrppslim)) {
		/* The packet is subject to rate limit */
a990 1
	}
d997 1
a997 3
icmp_redirect_timeout(rt, r)
	struct rtentry *rt;
	struct rttimer *r;
@


1.54
log
@plug a mbuf leak

debugging session w/ dhartmei@@ and lots of testing help from Jun <pilot at
monkey.org>

ok theo daniel angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.53 2002/08/28 15:43:03 pefo Exp $	*/
d343 1
a343 1
	if (m->m_len < i && (m = m_pullup(m, i)) == NULL)  {
d671 4
a674 5
		if (ro.ro_rt == 0)
		{
		    ipstat.ips_noroute++;
		    m_freem(m);
		    goto done;
@


1.53
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.52 2002/06/10 09:13:26 itojun Exp $	*/
d674 1
@


1.53.2.1
log
@MFC: plug mbuf leak
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.53 2002/08/28 15:43:03 pefo Exp $	*/
a673 1
		    m_freem(m);
@


1.52
log
@prevent mbuf leak on icmp_do_error() failure.

NOTE: under 4.4BSD mbuf coding discipline, once you pass mbuf to a function
like f(m), you no longer have ownership of the mbuf.  the mbuf will always
be freed by the called function f().  by keeping the programming rule
you have less chance of memory leak.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.51 2002/06/09 16:26:10 itojun Exp $	*/
d794 1
a794 1
	(void) ip_output(m, opts, NULL, 0, NULL, NULL);
@


1.51
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.50 2002/06/08 21:53:53 jasoni Exp $	*/
d270 1
a295 1
	m_freem(n);
@


1.50
log
@Break up icmp_error() so we can have the icmp error mbuf returned
instead of it being sent to ip_output().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.49 2002/06/07 23:59:19 jasoni Exp $	*/
d37 1
a37 1
 * 
d41 1
a41 1
 * 
d56 1
a56 1
 * 
d68 1
a68 1
 * 
d121 2
a122 2
	/* 
	 * This is only useful if the user initializes redirtimeout to 
d126 1
a126 1
		icmp_redirect_timeout_q = 
d170 1
a170 1
 	 */
d180 1
a180 1
 	/*
d223 1
a223 1
		/* 
d385 1
a385 1
				
d442 1
a442 1
			if (icmplen < ICMP_V6ADVLENMIN || 
d501 1
a501 1
		
d671 1
a671 1
		if (ro.ro_rt == 0) 
d724 1
a724 1
			    if (opt == IPOPT_RR || opt == IPOPT_TS || 
d874 1
a874 1
    
d876 1
a876 1
    
d880 1
a880 1
		error = rtrequest((int) RTM_ADD, dst, 
d882 1
a882 1
		    (struct sockaddr *) 0, 
d908 1
a908 1
	
d911 1
a911 1
	static u_short mtu_table[] = {65535, 65280, 32000, 17914, 9180, 8166, 
d955 1
a955 1
		else if (rt->rt_rmx.rmx_mtu > mtu || 
d970 1
a970 1
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) == 
d1024 1
a1024 1
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) == 
@


1.49
log
@kill register; ok with itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.48 2002/05/24 21:53:08 deraadt Exp $	*/
d131 2
a132 8
/*
 * Generate an error packet of type error
 * in response to bad packet ip.
 *
 * The ip packet inside has ip_off and ip_len in host byte order.
 */
void
icmp_error(n, type, code, dest, destifp)
d269 2
a270 1
	icmp_reflect(m);
d273 22
@


1.48
log
@add net.inet.icmp.tstamprepl sysctl for timestamp control; jason@@ackley.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.47 2002/03/15 18:19:52 millert Exp $	*/
d144 3
a146 3
	register struct ip *oip = mtod(n, struct ip *), *nip;
	register unsigned oiplen = oip->ip_hl << 2;
	register struct icmp *icp;
d292 2
a293 2
	register struct icmp *icp;
	register struct ip *ip = mtod(m, struct ip *);
d295 1
a295 1
	register int i;
d608 2
a609 2
	register struct ip *ip = mtod(m, struct ip *);
	register struct in_ifaddr *ia;
d670 1
a670 1
		register u_char *cp;
d753 1
a753 1
	register struct mbuf *m;
d756 3
a758 3
	register struct ip *ip = mtod(m, struct ip *);
	register int hlen;
	register struct icmp *icp;
@


1.47
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.46 2002/03/14 01:27:11 millert Exp $	*/
d101 1
d468 3
d806 2
@


1.46
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.45 2002/01/21 05:33:14 itojun Exp $	*/
a288 1
#if __STDC__
a289 5
#else
icmp_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.45
log
@remove couple of #if 0'ed portion we will never use
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.44 2002/01/12 00:51:59 ericj Exp $	*/
d111 3
a113 3
void icmp_mtudisc_timeout __P((struct rtentry *, struct rttimer *));
int icmp_ratelimit __P((const struct in_addr *, const int, const int));
static void icmp_redirect_timeout __P((struct rtentry *, struct rttimer *));
d302 1
a302 1
	void *(*ctlfunc) __P((int, struct sockaddr *, void *));
d955 1
a955 1
		void *(*ctlfunc) __P((int, struct sockaddr *, void *));
@


1.44
log
@
add rediraccept and redirtimeout sysctl's.
rediraccept allows one to ignore ICMP_REDIRECT
redirtimeout sets a timeout on the routing entries pretaining to
ICMP_REDIRECT, this timeout is defaulted to 10 minutes. (same as ipv6)
From NetBSD.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.43 2002/01/05 00:20:45 nordin Exp $	*/
a370 26
#if 0 /*NRL INET6*/
			if (icp->icmp_nextmtu) {
				extern int ipv6_trans_mtu
				    __P((struct mbuf **, int, int));
				struct mbuf *m0 = m;

				/*
				 * Do cool v4-related path MTU, for now,
				 * only v6-in-v4 can handle it.
				 */
				if (icmplen >= ICMP_V6ADVLENMIN &&
				    icmplen >= ICMP_V6ADVLEN(icp) &&
				    icp->icmp_ip.ip_p == IPPROTO_IPV6) {
					/*
					 * ipv6_trans_mtu returns 1 if
					 * the mbuf is still intact.
					 */
					if (ipv6_trans_mtu(&m0,icp->icmp_nextmtu,
					    hlen + ICMP_V6ADVLEN(icp))) {
						m = m0;
						goto raw;
					} else
						return;
				}
			}
#endif /* INET6 */
@


1.43
log
@Avoid using an uninitialized variable. dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.42 2001/07/04 16:52:03 dhartmei Exp $	*/
d107 3
d113 1
d117 13
d307 1
d558 2
d586 1
d589 7
a595 1
		    sintosa(&icmpgw), (struct rtentry **)0);
d842 26
d1024 14
@


1.42
log
@handle m->m_pkthdr.rcvif == NULL; temporarily ok deraadt@@; pending itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.41 2001/07/04 05:52:16 angelos Exp $	*/
d511 4
a514 3
		if (m->m_pkthdr.rcvif != NULL)
			ia = ifatoia(ifaof_ifpforaddr(sintosa(&icmpdst),
			    m->m_pkthdr.rcvif));
@


1.42.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.45 2002/01/21 05:33:14 itojun Exp $	*/
a106 3
int	icmp_rediraccept = 1;
int	icmp_redirtimeout = 10 * 60;
static struct rttimer_queue *icmp_redirect_timeout_q = NULL;
a109 1
static void icmp_redirect_timeout __P((struct rtentry *, struct rttimer *));
a112 13
void
icmp_init()
{
	/* 
	 * This is only useful if the user initializes redirtimeout to 
	 * something other than zero.
	 */
	if (icmp_redirtimeout != 0) {
		icmp_redirect_timeout_q = 
			rt_timer_queue_create(icmp_redirtimeout);
	}
}

a289 1
	struct rtentry *rt;
d353 26
d511 3
a513 4
		if (m->m_pkthdr.rcvif == NULL)
			break;
		ia = ifatoia(ifaof_ifpforaddr(sintosa(&icmpdst),
		    m->m_pkthdr.rcvif));
a538 2
		if (icmp_rediraccept == 0)
			goto freeit;
a564 1
		rt = NULL;
d567 1
a567 7
		    sintosa(&icmpgw), (struct rtentry **)&rt);
		if (rt != NULL && icmp_redirtimeout != 0) {
			(void)rt_timer_add(rt, icmp_redirect_timeout,
			 		 icmp_redirect_timeout_q);
		}
		if (rt != NULL)
			rtfree(rt);
a813 26
	case ICMPCTL_REDIRACCEPT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmp_rediraccept));
		break;
	case ICMPCTL_REDIRTIMEOUT: {
		int error;

		error = sysctl_int(oldp, oldlenp, newp, newlen,
			    &icmp_redirtimeout);
		if (icmp_redirect_timeout_q != NULL) {
			if (icmp_redirtimeout == 0) {
				rt_timer_queue_destroy(icmp_redirect_timeout_q,
				    TRUE);
				icmp_redirect_timeout_q = NULL;
			} else {
				rt_timer_queue_change(icmp_redirect_timeout_q,
				    icmp_redirtimeout);
			}
		} else if (icmp_redirtimeout > 0) {
			icmp_redirect_timeout_q =
			    rt_timer_queue_create(icmp_redirtimeout);
		}
		return (error);

		break;
	}
a969 14
}

static void
icmp_redirect_timeout(rt, r)
	struct rtentry *rt;
	struct rttimer *r;
{
	if (rt == NULL)
		panic("icmp_redirect_timeout:  bad route to timeout");
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) == 
	    (RTF_DYNAMIC | RTF_HOST)) {
		rtrequest((int) RTM_DELETE, (struct sockaddr *)rt_key(rt),
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
	}
@


1.42.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.42.4.1 2002/01/31 22:55:45 niklas Exp $	*/
a100 1
int	icmptstamprepl = 1;
d111 3
a113 3
void icmp_mtudisc_timeout(struct rtentry *, struct rttimer *);
int icmp_ratelimit(const struct in_addr *, const int, const int);
static void icmp_redirect_timeout(struct rtentry *, struct rttimer *);
d130 8
a137 2
struct mbuf *
icmp_do_error(n, type, code, dest, destifp)
d143 3
a145 3
	struct ip *oip = mtod(n, struct ip *), *nip;
	unsigned oiplen = oip->ip_hl << 2;
	struct icmp *icp;
d274 1
a274 2

	return (m);
a277 22
	return (NULL);
}

/*
 * Generate an error packet of type error
 * in response to bad packet ip.
 *
 * The ip packet inside has ip_off and ip_len in host byte order.
 */
void
icmp_error(n, type, code, dest, destifp)
	struct mbuf *n;
	int type, code;
	n_long dest;
	struct ifnet *destifp;
{
	struct mbuf *m;

	m = icmp_do_error(n, type, code, dest, destifp);
	if (m != NULL)
		icmp_reflect(m);
	m_freem(n);
d289 1
d291 5
d297 2
a298 2
	struct icmp *icp;
	struct ip *ip = mtod(m, struct ip *);
d300 1
a300 1
	int i;
d302 1
a302 1
	void *(*ctlfunc)(int, struct sockaddr *, void *);
a472 3
		if (icmptstamprepl == 0)
			break;

d610 2
a611 2
	struct ip *ip = mtod(m, struct ip *);
	struct in_ifaddr *ia;
d672 1
a672 1
		u_char *cp;
d755 1
a755 1
	struct mbuf *m;
d758 3
a760 3
	struct ip *ip = mtod(m, struct ip *);
	int hlen;
	struct icmp *icp;
a807 2
	case ICMPCTL_TSTAMPREPL:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &icmptstamprepl));
d955 1
a955 1
		void *(*ctlfunc)(int, struct sockaddr *, void *);
@


1.42.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.42.4.2 2002/06/11 03:31:36 art Exp $	*/
d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
d121 2
a122 2
	/*
	 * This is only useful if the user initializes redirtimeout to
d126 1
a126 1
		icmp_redirect_timeout_q =
d170 1
a170 1
	 */
d180 1
a180 1
	/*
d223 1
a223 1
		/*
a269 1
	m_freem(n);
d295 1
d385 1
a385 1

d442 1
a442 1
			if (icmplen < ICMP_V6ADVLENMIN ||
d501 1
a501 1

d671 1
a671 1
		if (ro.ro_rt == 0)
d724 1
a724 1
			    if (opt == IPOPT_RR || opt == IPOPT_TS ||
d794 1
a794 1
	(void) ip_output(m, opts, (void *)NULL, 0, (void *)NULL, (void *)NULL);
d874 1
a874 1

d876 1
a876 1

d880 1
a880 1
		error = rtrequest((int) RTM_ADD, dst,
d882 1
a882 1
		    (struct sockaddr *) 0,
d908 1
a908 1

d911 1
a911 1
	static u_short mtu_table[] = {65535, 65280, 32000, 17914, 9180, 8166,
d955 1
a955 1
		else if (rt->rt_rmx.rmx_mtu > mtu ||
d970 1
a970 1
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) ==
d1024 1
a1024 1
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) ==
@


1.42.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 4
a52 4
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
a110 1
struct	icmpstat icmpstat;
d119 1
a119 1
icmp_init(void)
d127 1
a127 1
		    rt_timer_queue_create(icmp_redirtimeout);
d132 5
a136 2
icmp_do_error(struct mbuf *n, int type, int code, n_long dest,
    struct ifnet *destifp)
d159 2
a160 3
	    n->m_len >= oiplen + ICMP_MINLEN &&
	    !ICMP_INFOTYPE(((struct icmp *)
	    ((caddr_t)oip + oiplen))->icmp_type)) {
d171 4
a174 2
	if (icmp_ratelimit(&oip->ip_src, type, code))
		goto freeit;	/* XXX stat */
d239 1
d285 5
a289 2
icmp_error(struct mbuf *n, int type, int code, n_long dest,
    struct ifnet *destifp)
d331 1
a331 1
		char buf[4 * sizeof("123")];
d333 1
a333 1
		strlcpy(buf, inet_ntoa(ip->ip_dst), sizeof buf);
d335 1
a335 1
		    inet_ntoa(ip->ip_src), buf, icmplen);
d343 1
a343 1
	if (m->m_len < i && (m = m_pullup(m, i)) == NULL) {
d453 1
a453 2
				icp = (struct icmp *)
				    (m->m_data + (ip->ip_hl << 2));
d567 2
a568 3
			char buf[4 * sizeof("123")];
			strlcpy(buf, inet_ntoa(icp->icmp_ip.ip_dst),
			    sizeof buf);
d581 1
a581 1
			    icmp_redirect_timeout_q);
d622 2
a623 1
icmp_reflect(struct mbuf *m)
d633 1
a633 1
	    htonl(IN_LOOPBACKNET << IN_CLASSA_NSHIFT))) {
d671 4
a674 4
		if (ro.ro_rt == 0) {
			ipstat.ips_noroute++;
			m_freem(m);
			goto done;
d703 3
a705 3
			if (icmpprintfs)
				printf("icmp_reflect optlen %d rt %d => ",
				    optlen, opts->m_len);
d707 32
a738 33
			for (cnt = optlen; cnt > 0; cnt -= len, cp += len) {
				opt = cp[IPOPT_OPTVAL];
				if (opt == IPOPT_EOL)
					break;
				if (opt == IPOPT_NOP)
					len = 1;
				else {
					if (cnt < IPOPT_OLEN + sizeof(*cp))
						break;
					len = cp[IPOPT_OLEN];
					if (len < IPOPT_OLEN + sizeof(*cp) ||
					    len > cnt)
						break;
				}
				/*
				 * Should check for overflow, but it
				 * "can't happen"
				 */
				if (opt == IPOPT_RR || opt == IPOPT_TS ||
				    opt == IPOPT_SECURITY) {
					bcopy((caddr_t)cp,
					    mtod(opts, caddr_t) + opts->m_len,
					    len);
					opts->m_len += len;
				}
			}
			/* Terminate & pad, if necessary */
			if ((cnt = opts->m_len % 4) != 0)
				for (; cnt < 4; cnt++) {
					*(mtod(opts, caddr_t) + opts->m_len) =
					    IPOPT_EOL;
					opts->m_len++;
				}
d740 2
a741 2
			if (icmpprintfs)
				printf("%d\n", opts->m_len);
d755 1
a755 1
		    (unsigned)(m->m_len - sizeof(struct ip)));
d769 3
a771 1
icmp_send(struct mbuf *m, struct mbuf *opts)
d787 1
a787 1
		char buf[4 * sizeof("123")];
d789 1
a789 1
		strlcpy(buf, inet_ntoa(ip->ip_dst), sizeof buf);
d794 1
a794 1
	(void)ip_output(m, opts, (void *)NULL, 0, (void *)NULL, (void *)NULL);
d798 1
a798 1
iptime(void)
d809 7
a815 2
icmp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
d824 1
a824 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmptstamprepl));
d826 1
a826 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmpmaskrepl));
d828 1
a828 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmpbmcastecho));
d841 1
a841 1
		    &icmp_redirtimeout);
d847 1
a847 1
			} else
d850 1
d902 2
a903 1
icmp_mtudisc(struct icmp *icp)
d956 1
a956 1
		    rt->rt_rmx.rmx_mtu == 0)
d964 3
a966 1
icmp_mtudisc_timeout(struct rtentry *rt, struct rttimer *r)
d984 2
a985 2
	} else
		if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0)
d987 2
d1000 4
a1003 1
icmp_ratelimit(const struct in_addr *dst, const int type, const int code)
d1008 2
a1009 1
	    icmperrppslim))
d1011 1
d1018 3
a1020 1
icmp_redirect_timeout(struct rtentry *rt, struct rttimer *r)
@


1.41
log
@Explicitly list the new ICMP codes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.40 2001/07/01 23:04:44 dhartmei Exp $	*/
d511 3
a513 2
		ia = ifatoia(ifaof_ifpforaddr(sintosa(&icmpdst),
		    m->m_pkthdr.rcvif));
d636 1
a636 1
	if (ia == (struct in_ifaddr *)0)
@


1.40
log
@tag packets generated by pf (return-rst, return-icmp) so they are not filtered, use existing icmp_error() and ip_output(). ok dugsong@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.39 2001/06/29 18:08:39 provos Exp $	*/
d580 8
@


1.39
log
@saner checking in icmp_error; from NetBSD with work by dug and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.38 2001/06/19 00:48:23 deraadt Exp $	*/
d130 1
d251 6
@


1.38
log
@mop up after angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.37 2001/06/08 03:53:46 angelos Exp $	*/
d129 2
a130 2
	struct mbuf *m, m0;
	unsigned icmplen;
d143 1
a143 1
	if (oip->ip_off &~ (IP_MF|IP_DF))
d166 22
d189 7
a197 1
	icmplen = oiplen + min(8, oip->ip_len);
d199 2
a200 1
	MH_ALIGN(m, m->m_len);
d222 2
d225 1
a225 1
	bcopy((caddr_t)oip, (caddr_t)&icp->icmp_ip, icmplen);
a226 8
	nip->ip_off = htons(nip->ip_off);
	nip->ip_len = htons(nip->ip_len);

	m0.m_next = NULL;			/* correct nip->ip_sum */
	m0.m_data = (char *)nip;
	m0.m_len = nip->ip_hl << 2;
	nip->ip_sum = 0;
	nip->ip_sum = in_cksum(&m0, nip->ip_hl << 2);
d232 2
a233 1
	if (m->m_data - sizeof(struct ip) < m->m_pktdat)
d240 3
a242 2
	bcopy((caddr_t)oip, (caddr_t)nip, sizeof(struct ip));
	nip->ip_off = htons(nip->ip_off);
d244 3
a246 1
	nip->ip_hl = sizeof(struct ip) >> 2;
d248 2
a249 1
	nip->ip_tos = 0;
@


1.37
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.36 2001/06/05 02:31:35 deraadt Exp $	*/
d76 1
@


1.36
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.35 2001/05/20 08:35:10 angelos Exp $	*/
a75 2
#include <sys/systm.h>
#include <sys/malloc.h>
a78 5
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/proc.h>

#include <vm/vm.h>
a90 2

#include <machine/stdarg.h>
@


1.35
log
@Use packet tags instead of tdbi.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.34 2001/05/11 17:20:11 aaron Exp $	*/
d36 37
a72 1
 *	@@(#)ip_icmp.c	8.2 (Berkeley) 1/4/94
a73 12

/*
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.34
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.33 2001/03/28 20:03:03 angelos Exp $	*/
d369 4
a372 7
		/*
		 * Free packet atttributes. XXX
		 */
		if ((m->m_flags & M_PKTHDR) && (m->m_pkthdr.tdbi)) {
		    free(m->m_pkthdr.tdbi, M_TEMP);
		    m->m_pkthdr.tdbi = NULL;
		}
d473 4
a476 7
		/*
		 * Free packet atttributes. XXX
		 */
		if ((m->m_flags & M_PKTHDR) && (m->m_pkthdr.tdbi)) {
		    free(m->m_pkthdr.tdbi, M_TEMP);
		    m->m_pkthdr.tdbi = NULL;
		}
d484 3
a486 7
		/*
		 * Free packet atttributes. XXX
		 */
		if ((m->m_flags & M_PKTHDR) && (m->m_pkthdr.tdbi)) {
		    free(m->m_pkthdr.tdbi, M_TEMP);
		    m->m_pkthdr.tdbi = NULL;
		}
@


1.33
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.32 2001/03/07 20:57:20 brian Exp $	*/
d262 1
a262 1
	if (m->m_len < i && (m = m_pullup(m, i)) == 0)  {
d395 2
a396 2
				if (!(m = m_pullup(m, (ip->ip_hl << 2) +
				    ICMP_V6ADVLEN(icp)))) {
@


1.32
log
@Remove a bogus rtfree(); PR 1706
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.31 2000/12/11 19:12:22 provos Exp $	*/
d370 7
d476 7
d490 7
d591 1
a591 2
	 * and was received on an interface with no IP address (like an
	 * enc interface).
@


1.31
log
@turn off path mtu when icmp needfrag messages get blocked, okay itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.30 2000/10/17 22:33:51 provos Exp $	*/
a770 1
			rtfree(nrt);
@


1.30
log
@icmp rate limiting defaults to 100pps
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.29 2000/10/10 15:16:02 provos Exp $	*/
d750 2
a751 3
void
icmp_mtudisc(icp)
	struct icmp *icp;
d754 1
a754 5
	struct sockaddr *dst = sintosa(&icmpsrc);
	u_long mtu = ntohs(icp->icmp_nextmtu);  /* Why a long?  IPv6 */
	int    error;
	
	/* Table of common MTUs: */
a755 3
	static u_short mtu_table[] = {65535, 65280, 32000, 17914, 9180, 8166, 
				      4352, 2002, 1492, 1006, 508, 296, 68, 0};
    
d758 1
a758 1
		return;
d772 1
a772 1
			return;
d781 21
a802 1
	}
d846 1
a846 2
	if (rt)
		rtfree(rt);
@


1.29
log
@verify payload of the icmp need fragment message at the tcp layer. okay itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.28 2000/10/10 14:24:33 itojun Exp $	*/
d88 1
a88 1
int	icmperrppslim;
@


1.28
log
@bring in icmp rate limitation code.
make icmp6 rate limitation to latest (uses ppsratecheck only).
(sync with netbsd)
TODO: tcp SYN rate limit?
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.27 2000/10/09 14:39:46 provos Exp $	*/
a73 1
#include <netinet/in_pcb.h>
a91 1
void icmp_mtudisc __P((struct icmp *));
a402 2
		if (code == PRC_MSGSIZE && ip_mtudisc)
			icmp_mtudisc(icp);
a757 1
	extern struct inpcbtable tcbtable;
a763 3
	if (!in_pcbconnected(&tcbtable, sintosa(&icmpsrc)))
		return;

@


1.27
log
@check if we have a tcb connected to the destination quoted in the icmp need
fragment message when doing path mtu discovery. okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.26 2000/09/26 01:02:25 angelos Exp $	*/
d89 3
d95 1
d140 9
d150 1
a150 1
	 * First, formulate icmp message
d744 4
d872 26
@


1.26
log
@Update to previous fix on ICMP messages coming on unnumbered
interfaces: rather than picking *some* non-loopback IP address,
do a routing lookup and use as source IP address the address of the
outgoing interface. A nice side effect of this is that ICMPs generated
as a result of packets received over IPsec will, in the common case,
end up going back over IPsec (depends on what the SPD looks like of
course). Thanks to fcusack@@fcusack.com for testing and commenting on
this.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.25 2000/09/25 09:41:02 provos Exp $	*/
d74 1
d745 2
a746 1

d752 3
@


1.25
log
@on expiry of pmtu route, retry higher mtu. okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.24 2000/09/20 19:11:09 angelos Exp $	*/
a531 1
        struct ifnet *ifp;
d557 1
a557 1
		    m->m_pkthdr.rcvif));
d560 2
a561 1
	 * and was received on an interface with no IP address.
d564 19
a582 7
		for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
                        struct in_addr addr = ia->ia_addr.sin_addr;
                        INADDR_TO_IFP(addr, ifp);
                        if ((ifp == NULL) || (ifp->if_flags & IFF_LOOPBACK))
                                continue;
                        break;
                }
d584 1
@


1.24
log
@Don't use LOOPBACK addresses when trying to determine source address
to use in locally-generated ICMP messages (thanks to fcusack@@fcusack.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.23 2000/09/20 17:02:39 provos Exp $	*/
d820 5
d827 5
@


1.23
log
@remove unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.22 2000/09/18 22:06:37 provos Exp $	*/
d532 1
d563 9
a571 2
	if (ia == (struct in_ifaddr *)0)
		ia = in_ifaddr.tqh_first;
@


1.22
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.21 2000/05/15 11:07:32 itojun Exp $	*/
a88 6
#if 0
static int	ip_next_mtu __P((int, int));
#else
/*static*/ int	ip_next_mtu __P((int, int));
#endif

a800 38
}

/*
 * Return the next larger or smaller MTU plateau (table from RFC 1191)
 * given current value MTU.  If DIR is less than zero, a larger plateau
 * is returned; otherwise, a smaller value is returned.
 */
int
ip_next_mtu(mtu, dir)	/* XXX */
	int mtu;
	int dir;
{
	static u_short mtutab[] = {
		65535, 32000, 17914, 8166, 4352, 2002, 1492, 1006, 508, 296,
		68, 0
	};
	int i;

	for (i = 0; i < (sizeof mtutab) / (sizeof mtutab[0]); i++) {
		if (mtu >= mtutab[i])
			break;
	}

	if (dir < 0) {
		if (i == 0) {
			return 0;
		} else {
			return mtutab[i - 1];
		}
	} else {
		if (mtutab[i] == 0) {
			return 0;
		} else if(mtu > mtutab[i]) {
			return mtutab[i];
		} else {
			return mtutab[i + 1];
		}
	}
@


1.21
log
@parse IPv4 options more carefully.  make boundary checks against every
steps (including option type/length field - there were no checks, seems to
me 4.4BSD bug)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.20 1999/12/28 07:43:40 itojun Exp $	*/
d95 3
d397 2
d719 144
@


1.20
log
@remove unused part of kame patch from the tree.  openbsd does not pass
"proto" around as xx_input argument.
(sync with kame change)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.19 1999/12/08 06:50:19 itojun Exp $	*/
d597 2
d600 2
a601 1
				    if (len <= 0 || len > cnt)
@


1.20.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.33 2001/03/28 20:03:03 angelos Exp $	*/
a87 3
int	icmperrppslim = 100;
int	icmperrpps_count = 0;
struct timeval icmperrppslim_last;
d89 5
a93 2
void icmp_mtudisc_timeout __P((struct rtentry *, struct rttimer *));
int icmp_ratelimit __P((const struct in_addr *, const int, const int));
a137 1

d139 1
a139 9
	 * First, do a rate limitation check.
 	 */
	if (icmp_ratelimit(&oip->ip_src, type, code)) {
		/* XXX stat */
		goto freeit;
	}

	/*
	 * Now, formulate icmp message
a360 7
		 * Free packet atttributes. XXX
		 */
		if ((m->m_flags & M_PKTHDR) && (m->m_pkthdr.tdbi)) {
		    free(m->m_pkthdr.tdbi, M_TEMP);
		    m->m_pkthdr.tdbi = NULL;
		}
		/*
a459 7
		/*
		 * Free packet atttributes. XXX
		 */
		if ((m->m_flags & M_PKTHDR) && (m->m_pkthdr.tdbi)) {
		    free(m->m_pkthdr.tdbi, M_TEMP);
		    m->m_pkthdr.tdbi = NULL;
		}
a466 7
		/*
		 * Free packet atttributes. XXX
		 */
		if ((m->m_flags & M_PKTHDR) && (m->m_pkthdr.tdbi)) {
		    free(m->m_pkthdr.tdbi, M_TEMP);
		    m->m_pkthdr.tdbi = NULL;
		}
d558 1
a558 1
					      m->m_pkthdr.rcvif));
d563 2
a564 22
	if (ia == (struct in_ifaddr *)0) {
	        struct sockaddr_in *dst;
		struct route ro;

		bzero((caddr_t) &ro, sizeof(ro));
		dst = satosin(&ro.ro_dst);
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = t;

		rtalloc(&ro);
		if (ro.ro_rt == 0) 
		{
		    ipstat.ips_noroute++;
		    goto done;
		}

		ia = ifatoia(ro.ro_rt->rt_ifa);
		ro.ro_rt->rt_use++;
                RTFREE(ro.ro_rt);
        }

a596 2
				    if (cnt < IPOPT_OLEN + sizeof(*cp))
					    break;
d598 1
a598 2
				    if (len < IPOPT_OLEN + sizeof(*cp) ||
				        len > cnt)
a706 4
	case ICMPCTL_ERRPPSLIMIT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmperrppslim));
		break;
a710 152
}

struct rtentry *
icmp_mtudisc_clone(struct sockaddr *dst)
{
	struct rtentry *rt;
	int error;

	rt = rtalloc1(dst, 1);
	if (rt == 0)
		return (NULL);
    
	/* If we didn't get a host route, allocate one */
    
	if ((rt->rt_flags & RTF_HOST) == 0) {
		struct rtentry *nrt;

		error = rtrequest((int) RTM_ADD, dst, 
		    (struct sockaddr *) rt->rt_gateway,
		    (struct sockaddr *) 0, 
		    RTF_GATEWAY | RTF_HOST | RTF_DYNAMIC, &nrt);
		if (error) {
			rtfree(rt);
			return (NULL);
		}
		nrt->rt_rmx = rt->rt_rmx;
		rtfree(rt);
		rt = nrt;
	}
	error = rt_timer_add(rt, icmp_mtudisc_timeout, ip_mtudisc_timeout_q);
	if (error) {
		rtfree(rt);
		return (NULL);
	}

	return (rt);
}

void
icmp_mtudisc(icp)
	struct icmp *icp;
{
	struct rtentry *rt;
	struct sockaddr *dst = sintosa(&icmpsrc);
	u_long mtu = ntohs(icp->icmp_nextmtu);  /* Why a long?  IPv6 */
	
	/* Table of common MTUs: */

	static u_short mtu_table[] = {65535, 65280, 32000, 17914, 9180, 8166, 
				      4352, 2002, 1492, 1006, 508, 296, 68, 0};

	rt = icmp_mtudisc_clone(dst);
	if (rt == 0)
		return;

	if (mtu == 0) {
		int i = 0;

		mtu = icp->icmp_ip.ip_len; /* NTOHS happened in deliver: */
		/* Some 4.2BSD-based routers incorrectly adjust the ip_len */
		if (mtu > rt->rt_rmx.rmx_mtu && rt->rt_rmx.rmx_mtu != 0)
			mtu -= (icp->icmp_ip.ip_hl << 2);

		/* If we still can't guess a value, try the route */

		if (mtu == 0) {
			mtu = rt->rt_rmx.rmx_mtu;

			/* If no route mtu, default to the interface mtu */

			if (mtu == 0)
				mtu = rt->rt_ifp->if_mtu;
		}

		for (i = 0; i < sizeof(mtu_table) / sizeof(mtu_table[0]); i++)
			if (mtu > mtu_table[i]) {
				mtu = mtu_table[i];
				break;
			}
	}

	/*
	 * XXX:   RTV_MTU is overloaded, since the admin can set it
	 *	  to turn off PMTU for a route, and the kernel can
	 *	  set it to indicate a serious problem with PMTU
	 *	  on a route.  We should be using a separate flag
	 *	  for the kernel to indicate this.
	 */

	if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0) {
		if (mtu < 296 || mtu > rt->rt_ifp->if_mtu)
			rt->rt_rmx.rmx_locks |= RTV_MTU;
		else if (rt->rt_rmx.rmx_mtu > mtu || 
			 rt->rt_rmx.rmx_mtu == 0)
			rt->rt_rmx.rmx_mtu = mtu;
	}

	rtfree(rt);
}

void
icmp_mtudisc_timeout(rt, r)
	struct rtentry *rt;
	struct rttimer *r;
{
	if (rt == NULL)
		panic("icmp_mtudisc_timeout:  bad route to timeout");
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) == 
	    (RTF_DYNAMIC | RTF_HOST)) {
		void *(*ctlfunc) __P((int, struct sockaddr *, void *));
		extern u_char ip_protox[];
		struct sockaddr_in sa;

		sa = *(struct sockaddr_in *)rt_key(rt);
		rtrequest((int) RTM_DELETE, (struct sockaddr *)rt_key(rt),
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);

		/* Notify TCP layer of increased Path MTU estimate */
		ctlfunc = inetsw[ip_protox[IPPROTO_TCP]].pr_ctlinput;
		if (ctlfunc)
			(*ctlfunc)(PRC_MTUINC,(struct sockaddr *)&sa, NULL);
	} else {
		if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0) {
			rt->rt_rmx.rmx_mtu = 0;
		}
	}
}

/*
 * Perform rate limit check.
 * Returns 0 if it is okay to send the icmp packet.
 * Returns 1 if the router SHOULD NOT send this icmp packet due to rate
 * limitation.
 *
 * XXX per-destination/type check necessary?
 */
int
icmp_ratelimit(dst, type, code)
	const struct in_addr *dst;
	const int type;			/* not used at this moment */
	const int code;			/* not used at this moment */
{

	/* PPS limit */
	if (!ppsratecheck(&icmperrppslim_last, &icmperrpps_count,
	    icmperrppslim)) {
		/* The packet is subject to rate limit */
		return 1;
	}

	/*okay to send*/
	return 0;
@


1.20.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 37
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
d39 12
d53 1
d57 5
d75 2
d113 2
a114 3
	struct mbuf *m;
	struct m_tag *mtag;
	unsigned icmplen, mblen;
d127 1
a127 1
	if (oip->ip_off & IP_OFFMASK)
a149 22
	icmplen = oiplen + min(8, oip->ip_len);
 	/*
	 * Defend against mbuf chains shorter than oip->ip_len:
	 */
	mblen = 0;
	for (m = n; m && (mblen < icmplen); m = m->m_next)
		mblen += m->m_len;
	icmplen = min(mblen, icmplen);

	/*
	 * As we are not required to return everything we have,
	 * we return whatever we can return at ease.
	 *
	 * Note that ICMP datagrams longer than 576 octets are out of spec
	 * according to RFC1812;
	 */

	KASSERT(ICMP_MINLEN <= MCLBYTES);

	if (icmplen + ICMP_MINLEN > MCLBYTES)
		icmplen = MCLBYTES - ICMP_MINLEN - sizeof (struct ip);

a150 7
	if (m && (sizeof (struct ip) + icmplen + ICMP_MINLEN > MHLEN)) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
			m = NULL;
		}
	}
d153 1
d155 1
a155 2
	if ((m->m_flags & M_EXT) == 0)
		MH_ALIGN(m, m->m_len);
a176 2
	HTONS(oip->ip_off);
	HTONS(oip->ip_len);
d178 1
a178 1
	m_copydata(n, 0, icmplen, (caddr_t)&icp->icmp_ip);
d180 8
d193 1
a193 2
	if ((m->m_flags & M_EXT) == 0 &&
	    m->m_data - sizeof(struct ip) < m->m_pktdat)
d200 3
a202 1
	/* ip_v set in ip_output */
d204 1
a205 13
	nip->ip_len = m->m_len;
	/* ip_id set in ip_output */
	nip->ip_off = 0;
	/* ip_ttl set in icmp_reflect */
	nip->ip_p = IPPROTO_ICMP;
	nip->ip_src = oip->ip_src;
	nip->ip_dst = oip->ip_dst;
	/* move PF_GENERATED m_tag to new packet, if it exists */
	mtag = m_tag_find(n, PACKET_TAG_PF_GENERATED, NULL);
	if (mtag != NULL) {
		m_tag_unlink(n, mtag);
		m_tag_prepend(m, mtag);
	}
d262 1
a262 1
	if (m->m_len < i && (m = m_pullup(m, i)) == NULL)  {
d369 7
a375 4
		/* Free packet atttributes */
		if (m->m_flags & M_PKTHDR)
			m_tag_delete_chain(m, NULL);

d395 2
a396 2
				if ((m = m_pullup(m, (ip->ip_hl << 2) +
				    ICMP_V6ADVLEN(icp))) == NULL) {
d476 7
a482 4
		/* Free packet atttributes */
		if (m->m_flags & M_PKTHDR)
			m_tag_delete_chain(m, NULL);

d490 7
a496 3
		/* Free packet atttributes */
		if (m->m_flags & M_PKTHDR)
			m_tag_delete_chain(m, NULL);
@


1.20.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.20.2.2 2001/07/04 10:54:48 niklas Exp $	*/
d511 2
a512 3
		if (m->m_pkthdr.rcvif != NULL)
			ia = ifatoia(ifaof_ifpforaddr(sintosa(&icmpdst),
			    m->m_pkthdr.rcvif));
a579 8
	case ICMP_TRACEROUTE:
	case ICMP_DATACONVERR:
	case ICMP_MOBILE_REDIRECT:
	case ICMP_IPV6_WHEREAREYOU:
	case ICMP_IPV6_IAMHERE:
	case ICMP_MOBILE_REGREQUEST:
	case ICMP_MOBILE_REGREPLY:
	case ICMP_PHOTURIS:
d627 1
a627 1
	if ((ia == (struct in_ifaddr *)0) && (m->m_pkthdr.rcvif != NULL))
@


1.20.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a106 3
int	icmp_rediraccept = 1;
int	icmp_redirtimeout = 10 * 60;
static struct rttimer_queue *icmp_redirect_timeout_q = NULL;
a109 1
static void icmp_redirect_timeout __P((struct rtentry *, struct rttimer *));
a112 13
void
icmp_init()
{
	/* 
	 * This is only useful if the user initializes redirtimeout to 
	 * something other than zero.
	 */
	if (icmp_redirtimeout != 0) {
		icmp_redirect_timeout_q = 
			rt_timer_queue_create(icmp_redirtimeout);
	}
}

a289 1
	struct rtentry *rt;
d353 26
d511 3
a513 4
		if (m->m_pkthdr.rcvif == NULL)
			break;
		ia = ifatoia(ifaof_ifpforaddr(sintosa(&icmpdst),
		    m->m_pkthdr.rcvif));
a538 2
		if (icmp_rediraccept == 0)
			goto freeit;
a564 1
		rt = NULL;
d567 1
a567 7
		    sintosa(&icmpgw), (struct rtentry **)&rt);
		if (rt != NULL && icmp_redirtimeout != 0) {
			(void)rt_timer_add(rt, icmp_redirect_timeout,
			 		 icmp_redirect_timeout_q);
		}
		if (rt != NULL)
			rtfree(rt);
a813 26
	case ICMPCTL_REDIRACCEPT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmp_rediraccept));
		break;
	case ICMPCTL_REDIRTIMEOUT: {
		int error;

		error = sysctl_int(oldp, oldlenp, newp, newlen,
			    &icmp_redirtimeout);
		if (icmp_redirect_timeout_q != NULL) {
			if (icmp_redirtimeout == 0) {
				rt_timer_queue_destroy(icmp_redirect_timeout_q,
				    TRUE);
				icmp_redirect_timeout_q = NULL;
			} else {
				rt_timer_queue_change(icmp_redirect_timeout_q,
				    icmp_redirtimeout);
			}
		} else if (icmp_redirtimeout > 0) {
			icmp_redirect_timeout_q =
			    rt_timer_queue_create(icmp_redirtimeout);
		}
		return (error);

		break;
	}
a969 14
}

static void
icmp_redirect_timeout(rt, r)
	struct rtentry *rt;
	struct rttimer *r;
{
	if (rt == NULL)
		panic("icmp_redirect_timeout:  bad route to timeout");
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) == 
	    (RTF_DYNAMIC | RTF_HOST)) {
		rtrequest((int) RTM_DELETE, (struct sockaddr *)rt_key(rt),
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
	}
@


1.20.2.5
log
@Merge in -current from roughly a week ago
@
text
@d111 3
a113 3
void icmp_mtudisc_timeout(struct rtentry *, struct rttimer *);
int icmp_ratelimit(const struct in_addr *, const int, const int);
static void icmp_redirect_timeout(struct rtentry *, struct rttimer *);
d289 1
d291 5
d302 1
a302 1
	void *(*ctlfunc)(int, struct sockaddr *, void *);
d955 1
a955 1
		void *(*ctlfunc)(int, struct sockaddr *, void *);
@


1.20.2.6
log
@Sync the SMP branch with 3.3
@
text
@d37 1
a37 1
 *
d41 1
a41 1
 *
d49 4
a52 4
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
d56 1
a56 1
 *
d68 1
a68 1
 *
a100 1
int	icmptstamprepl = 1;
a109 1
struct	icmpstat icmpstat;
d118 1
a118 1
icmp_init(void)
d120 2
a121 2
	/*
	 * This is only useful if the user initializes redirtimeout to
d125 2
a126 2
		icmp_redirect_timeout_q =
		    rt_timer_queue_create(icmp_redirtimeout);
d130 16
a145 7
struct mbuf *
icmp_do_error(struct mbuf *n, int type, int code, n_long dest,
    struct ifnet *destifp)
{
	struct ip *oip = mtod(n, struct ip *), *nip;
	unsigned oiplen = oip->ip_hl << 2;
	struct icmp *icp;
d164 2
a165 3
	    n->m_len >= oiplen + ICMP_MINLEN &&
	    !ICMP_INFOTYPE(((struct icmp *)
	    ((caddr_t)oip + oiplen))->icmp_type)) {
d175 5
a179 3
	 */
	if (icmp_ratelimit(&oip->ip_src, type, code))
		goto freeit;	/* XXX stat */
d185 1
a185 1
	/*
d228 1
a228 1
		/*
d274 1
a274 3

	m_freem(n);
	return (m);
a277 18
	return (NULL);
}

/*
 * Generate an error packet of type error
 * in response to bad packet ip.
 *
 * The ip packet inside has ip_off and ip_len in host byte order.
 */
void
icmp_error(struct mbuf *n, int type, int code, n_long dest,
    struct ifnet *destifp)
{
	struct mbuf *m;

	m = icmp_do_error(n, type, code, dest, destifp);
	if (m != NULL)
		icmp_reflect(m);
d291 2
a292 2
	struct icmp *icp;
	struct ip *ip = mtod(m, struct ip *);
d294 1
a294 1
	int i;
d313 1
a313 1
		char buf[4 * sizeof("123")];
d317 1
a317 1
		    inet_ntoa(ip->ip_src), buf, icmplen);
d325 1
a325 1
	if (m->m_len < i && (m = m_pullup(m, i)) == NULL) {
d367 1
a367 1

d424 1
a424 1
			if (icmplen < ICMP_V6ADVLENMIN ||
d435 1
a435 2
				icp = (struct icmp *)
				    (m->m_data + (ip->ip_hl << 2));
a466 3
		if (icmptstamprepl == 0)
			break;

d480 1
a480 1

d546 1
a546 1
			char buf[4 * sizeof("123")];
d560 1
a560 1
			    icmp_redirect_timeout_q);
d601 2
a602 1
icmp_reflect(struct mbuf *m)
d604 2
a605 2
	struct ip *ip = mtod(m, struct ip *);
	struct in_ifaddr *ia;
d612 1
a612 1
	    htonl(IN_LOOPBACKNET << IN_CLASSA_NSHIFT))) {
d650 4
a653 4
		if (ro.ro_rt == 0) {
			ipstat.ips_noroute++;
			m_freem(m);
			goto done;
d666 1
a666 1
		u_char *cp;
d682 3
a684 3
			if (icmpprintfs)
				printf("icmp_reflect optlen %d rt %d => ",
				    optlen, opts->m_len);
d686 32
a717 33
			for (cnt = optlen; cnt > 0; cnt -= len, cp += len) {
				opt = cp[IPOPT_OPTVAL];
				if (opt == IPOPT_EOL)
					break;
				if (opt == IPOPT_NOP)
					len = 1;
				else {
					if (cnt < IPOPT_OLEN + sizeof(*cp))
						break;
					len = cp[IPOPT_OLEN];
					if (len < IPOPT_OLEN + sizeof(*cp) ||
					    len > cnt)
						break;
				}
				/*
				 * Should check for overflow, but it
				 * "can't happen"
				 */
				if (opt == IPOPT_RR || opt == IPOPT_TS ||
				    opt == IPOPT_SECURITY) {
					bcopy((caddr_t)cp,
					    mtod(opts, caddr_t) + opts->m_len,
					    len);
					opts->m_len += len;
				}
			}
			/* Terminate & pad, if necessary */
			if ((cnt = opts->m_len % 4) != 0)
				for (; cnt < 4; cnt++) {
					*(mtod(opts, caddr_t) + opts->m_len) =
					    IPOPT_EOL;
					opts->m_len++;
				}
d719 2
a720 2
			if (icmpprintfs)
				printf("%d\n", opts->m_len);
d734 1
a734 1
		    (unsigned)(m->m_len - sizeof(struct ip)));
d748 7
a754 5
icmp_send(struct mbuf *m, struct mbuf *opts)
{
	struct ip *ip = mtod(m, struct ip *);
	int hlen;
	struct icmp *icp;
d766 1
a766 1
		char buf[4 * sizeof("123")];
d773 1
a773 1
	(void)ip_output(m, opts, (void *)NULL, 0, (void *)NULL, (void *)NULL);
d777 1
a777 1
iptime(void)
d788 7
a794 2
icmp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
a801 3
	case ICMPCTL_TSTAMPREPL:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmptstamprepl));
d803 1
a803 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmpmaskrepl));
d805 1
a805 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &icmpbmcastecho));
d818 1
a818 1
		    &icmp_redirtimeout);
d824 1
a824 1
			} else
d827 1
d851 1
a851 1

d853 1
a853 1

d857 1
a857 1
		error = rtrequest((int) RTM_ADD, dst,
d859 1
a859 1
		    (struct sockaddr *) 0,
d879 2
a880 1
icmp_mtudisc(struct icmp *icp)
d885 1
a885 1

d888 1
a888 1
	static u_short mtu_table[] = {65535, 65280, 32000, 17914, 9180, 8166,
d932 2
a933 2
		else if (rt->rt_rmx.rmx_mtu > mtu ||
		    rt->rt_rmx.rmx_mtu == 0)
d941 3
a943 1
icmp_mtudisc_timeout(struct rtentry *rt, struct rttimer *r)
d947 1
a947 1
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) ==
d961 2
a962 2
	} else
		if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0)
d964 2
d977 4
a980 1
icmp_ratelimit(const struct in_addr *dst, const int type, const int code)
d985 2
a986 1
	    icmperrppslim))
d988 1
d995 3
a997 1
icmp_redirect_timeout(struct rtentry *rt, struct rttimer *r)
d1001 1
a1001 1
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) ==
@


1.20.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.20.2.6 2003/03/28 00:06:54 niklas Exp $	*/
d327 1
a327 1
		strlcpy(buf, inet_ntoa(ip->ip_dst), sizeof buf);
d563 1
a563 2
			strlcpy(buf, inet_ntoa(icp->icmp_ip.ip_dst),
			    sizeof buf);
d782 1
a782 1
		strlcpy(buf, inet_ntoa(ip->ip_dst), sizeof buf);
@


1.20.2.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d236 1
@


1.20.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.20.2.8 2003/05/16 00:29:44 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.20.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d150 1
a150 1
	if (oip->ip_off & htons(IP_OFFMASK))
d172 1
a172 1
	icmplen = oiplen + min(8, ntohs(oip->ip_len));
d228 2
d248 1
a248 1
	nip->ip_len = htons(m->m_len);
d300 1
a300 1
	int icmplen;
a317 1
	icmplen = ntohs(ip->ip_len) - hlen;
d427 1
d527 1
d739 1
a739 1
		ip->ip_len = htons(ntohs(ip->ip_len) - optlen);
d771 1
a771 1
	icp->icmp_cksum = in_cksum(m, ntohs(ip->ip_len) - hlen);
d906 1
a906 1
		mtu = ntohs(icp->icmp_ip.ip_len);
@


1.20.2.11
log
@Merge with the trunk
@
text
@a108 2
int *icmpctl_vars[ICMPCTL_MAXID] = ICMPCTL_VARS;

d642 1
a642 1
		    m->m_pkthdr.rcvif));
d648 1
a648 1
		struct sockaddr_in *dst;
d666 2
a667 2
		RTFREE(ro.ro_rt);
	}
d804 17
a842 3
		if (name[0] < ICMPCTL_MAXID)
			return (sysctl_int_arr(icmpctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
d893 2
a894 4
	static u_short mtu_table[] = {
		65535, 65280, 32000, 17914, 9180, 8166,
		4352, 2002, 1492, 1006, 508, 296, 68, 0
	};
@


1.20.2.12
log
@sync to head
@
text
@d567 1
a567 1
		    (struct sockaddr *)&rt_defmask4, RTF_GATEWAY | RTF_HOST,
d853 1
a853 1
		    sroute_clone_mask4(rt_mask(rt), NULL),
@


1.20.4.1
log
@Pull in patch from current:
Errata:
Parse IPv4 options more carefully. It is not yet clear if this can even be
used to crash the machine remote or locally.
Fix (itojun):
parse IPv4 options more carefully.  make boundary checks against every
steps (including option type/length field - there were no checks, seems to
me 4.4BSD bug)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.21 2000/05/15 11:07:32 itojun Exp $	*/
a596 2
				    if (cnt < IPOPT_OLEN + sizeof(*cp))
					    break;
d598 1
a598 2
				    if (len < IPOPT_OLEN + sizeof(*cp) ||
				        len > cnt)
@


1.19
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.18 1999/09/26 23:59:15 deraadt Exp $	*/
a74 6
#if 0 /*KAME IPSEC*/
#include <netinet6/ipsec.h>
#include <netkey/key.h>
#include <netkey/key_debug.h>
#endif

a219 1
	int proto;
a232 1
	proto = va_arg(ap, int);
a275 7
#if 0 /*KAME IPSEC*/
	/* drop it if it does not match the policy */
	if (ipsec4_in_reject(m, NULL)) {
		ipsecstat.in_polvio++;
		goto freeit;
	}
#endif
a496 3
#if 0 /*KAME IPSEC*/
		key_sa_routechange((struct sockaddr *)&icmpsrc);
#endif
d514 1
a514 1
	rip_input(m, hlen, proto);
a673 3
#if 0 /*KAME IPSEC*/
	m->m_pkthdr.rcvif = NULL;
#endif /*IPSEC*/
@


1.18
log
@the mbuf copy was still being modified; now totally correct that.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.17 1999/09/23 07:20:35 deraadt Exp $	*/
d75 6
d95 6
d226 1
d240 1
d284 7
d308 1
a308 1
#ifdef INET6
d409 4
d512 3
d532 1
a532 1
	rip_input(m, 0);
d692 3
@


1.17
log
@fix same-interface-out-as-in and packet gets corrupted bug noted by
james@@oaktree.co.uk by re-working icmp embedded-packet code so that
ip_forward() m_copy()-aliased packet can be forwarded to ip_output and
icmp_error() safely, because no packet tweaking is needed before
calling icmp_error()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.16 1999/01/08 11:35:09 deraadt Exp $	*/
a162 2
	HTONS(oip->ip_off);
	HTONS(oip->ip_len);
d165 2
d186 1
@


1.16
log
@IPV6 pieces; NRL
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.15 1999/01/08 01:04:17 deraadt Exp $	*/
d94 2
d121 1
a121 1
	if (ntohs(oip->ip_off) &~ (IP_MF|IP_DF))
d138 1
a138 1
	icmplen = oiplen + min(8, ntohs(oip->ip_len));
d163 2
a166 1
	nip->ip_len = htons((u_int16_t)(ntohs(nip->ip_len) + oiplen));
@


1.15
log
@rip_input() should be called with a 0 terminator; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.14 1998/12/31 12:55:46 deraadt Exp $	*/
d39 12
d274 37
a310 11
			case ICMP_UNREACH_NET:
			case ICMP_UNREACH_HOST:
			case ICMP_UNREACH_PROTOCOL:
			case ICMP_UNREACH_PORT:
			case ICMP_UNREACH_SRCFAIL:
				code += PRC_UNREACH_NET;
				break;

			case ICMP_UNREACH_NEEDFRAG:
				code = PRC_MSGSIZE;
				break;
d312 15
a326 15
			case ICMP_UNREACH_NET_UNKNOWN:
			case ICMP_UNREACH_NET_PROHIB:
			case ICMP_UNREACH_TOSNET:
				code = PRC_UNREACH_NET;
				break;

			case ICMP_UNREACH_HOST_UNKNOWN:
			case ICMP_UNREACH_ISOLATED:
			case ICMP_UNREACH_HOST_PROHIB:
			case ICMP_UNREACH_TOSHOST:
			case ICMP_UNREACH_FILTER_PROHIB:
			case ICMP_UNREACH_HOST_PRECEDENCE:
			case ICMP_UNREACH_PRECEDENCE_CUTOFF:
				code = PRC_UNREACH_HOST;
				break;
d328 2
a329 2
			default:
				goto badcode;
d361 18
@


1.14
log
@one last fix for byte order.  now all architectures return the same correct icmp packets
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.13 1998/12/31 12:40:34 deraadt Exp $	*/
d444 1
a444 1
	rip_input(m);
@


1.13
log
@look at that, correct nested ip checksums...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.12 1998/12/31 12:27:11 deraadt Exp $	*/
d151 1
a151 1
	nip->ip_len = htons((u_int16_t)(nip->ip_len + oiplen));
@


1.12
log
@XXX marker for where nested ip ip_sum should be re-build (but it is not in an mbuf, grr
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.11 1998/12/31 11:50:13 deraadt Exp $	*/
d93 1
a93 1
	register struct mbuf *m;
d152 7
a158 2
	/* XXX should correct nip->ip_sum */
	
@


1.11
log
@icmp_error() is now getting packets which are completely in network byte order
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.10 1998/05/27 20:28:35 deraadt Exp $	*/
d152 2
a153 1

@


1.10
log
@for icmpbmcastecho, block all of them
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.9 1998/05/18 21:10:48 provos Exp $	*/
d107 1
a107 1
	if (oip->ip_off &~ (IP_MF|IP_DF))
d124 1
a124 1
	icmplen = oiplen + min(8,oip->ip_len);
@


1.9
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.8 1998/01/06 01:38:36 deraadt Exp $	*/
d333 1
a333 2
		    (m->m_flags & (M_MCAST | M_BCAST)) != 0 &&
		    IN_MULTICAST(ntohl(ip->ip_dst.s_addr))) {
d342 1
a342 2
		    (m->m_flags & (M_MCAST | M_BCAST)) != 0 &&
		    IN_MULTICAST(ntohl(ip->ip_dst.s_addr))) {
@


1.8
log
@net.inet.icmp.bmcastecho: do not smurf to smurfing broadcast packets
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.7 1997/06/05 15:05:41 deraadt Exp $	*/
d600 1
a600 1
	(void) ip_output(m, opts, NULL, 0, NULL);
@


1.7
log
@ICMP_MASKLEN -> icmpstat.icps_badlen++; koji@@math.human.nagoya-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_icmp.c,v 1.6 1997/02/11 22:23:23 kstailey Exp $	*/
d72 1
d332 6
d342 6
d631 2
@


1.6
log
@IPF 1.3.7
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d351 2
a352 1
		if (icmplen < ICMP_MASKLEN)
d354 1
@


1.5
log
@revert icmp len fix, since i experience 'icmp len'
panics replying to udp.
@
text
@d277 3
@


1.4
log
@from NetBSD PR#2296:
Laine Stump: some icmp destination unreachable packets contain garbage.
@
text
@d123 1
a123 1
	icmplen = oiplen + oip->ip_len;
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d123 1
a123 1
	icmplen = oiplen + min(8, oip->ip_len);
@


1.2
log
@add inet_ntoa() to the kernel. use it to log nicer messages. idea from freebsd
@
text
@d1 2
a2 1
/*	$NetBSD: ip_icmp.c,v 1.18 1995/06/12 00:47:39 mycroft Exp $	*/
d47 4
d60 1
d63 2
d183 7
a189 3
icmp_input(m, hlen)
	register struct mbuf *m;
	int hlen;
d196 1
a196 1
	void (*ctlfunc) __P((int, struct sockaddr *, struct ip *));
d199 6
d318 2
a319 1
		if (ctlfunc = inetsw[ip_protox[icp->icmp_ip.ip_p]].pr_ctlinput)
d439 1
a439 1
	struct mbuf *opts = 0, *ip_srcroute();
d520 1
a520 1
		    if (cnt = opts->m_len % 4) {
@


1.1
log
@Initial revision
@
text
@d193 7
a199 4
	if (icmpprintfs)
		printf("icmp_input from %x to %x, len %d\n",
			ntohl(ip->ip_src.s_addr), ntohl(ip->ip_dst.s_addr),
			icmplen);
d373 7
a379 3
		if (icmpprintfs)
			printf("redirect dst %x to %x\n", icp->icmp_ip.ip_dst,
				icp->icmp_gwaddr);
d555 7
a561 2
	if (icmpprintfs)
		printf("icmp_send dst %x src %x\n", ip->ip_dst, ip->ip_src);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
