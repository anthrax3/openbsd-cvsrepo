head	1.97;
access;
symbols
	OPENBSD_6_1:1.97.0.2
	OPENBSD_6_1_BASE:1.97
	OPENBSD_6_0:1.86.0.4
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.85.0.2
	OPENBSD_5_9_BASE:1.85
	OPENBSD_5_8:1.84.0.4
	OPENBSD_5_8_BASE:1.84
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.74.0.4
	OPENBSD_5_6_BASE:1.74
	OPENBSD_5_5:1.67.0.4
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.66.0.2
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.62.0.2
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.61.0.2
	OPENBSD_5_2_BASE:1.61
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.4
	OPENBSD_5_0:1.60.0.2
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.40.0.6
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.40.0.4
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.37.0.4
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.32.0.4
	OPENBSD_3_6_BASE:1.32
	SMP_SYNC_A:1.32
	SMP_SYNC_B:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.26
	UBC:1.24.0.4
	UBC_BASE:1.24
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.4
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.4
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.2
	SMP_BASE:1.20
	kame_19991208:1.19
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.97
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.96;
commitid	ZsxSSZJSFxZH81LL;

1.96
date	2017.03.03.15.48.02;	author bluhm;	state Exp;
branches;
next	1.95;
commitid	LtQeAWkATeJFPv2t;

1.95
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.94;
commitid	UBL7uwpXqTP4EWIu;

1.94
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.93;
commitid	3e3CkrbYekyVOcxy;

1.93
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.92;
commitid	pVtptbHA3yk4jSpN;

1.92
date	2017.01.23.16.31.24;	author bluhm;	state Exp;
branches;
next	1.91;
commitid	9EAe7cRTLFNc3XTC;

1.91
date	2017.01.10.09.01.18;	author mpi;	state Exp;
branches;
next	1.90;
commitid	xP9gcRskiS0BKnO6;

1.90
date	2016.12.19.09.22.24;	author rzalamena;	state Exp;
branches;
next	1.89;
commitid	5iifwOyfMyS6GiDF;

1.89
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.88;
commitid	QqHqT2WhCBWqYgGJ;

1.88
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.87;
commitid	wuzpseLx3Ntn9R7b;

1.87
date	2016.11.14.03.51.53;	author dlg;	state Exp;
branches;
next	1.86;
commitid	Khqq96MLd95C1Z1s;

1.86
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.85;
commitid	Z6e4eqr6FuYFPnlL;

1.85
date	2015.12.03.14.55.18;	author vgross;	state Exp;
branches;
next	1.84;
commitid	DukW6jeSHPpp8ZFD;

1.84
date	2015.07.28.12.22.07;	author bluhm;	state Exp;
branches;
next	1.83;
commitid	HopFqP0BfcI2KM6j;

1.83
date	2015.07.15.23.09.59;	author deraadt;	state Exp;
branches;
next	1.82;
commitid	cwKl3KenPYIhBsNV;

1.82
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	ncpqEGjDtSFuLAgn;

1.81
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.80;
commitid	J4OPNuggl4DOKGzM;

1.80
date	2015.06.07.01.25.27;	author krw;	state Exp;
branches;
next	1.79;
commitid	7yzARhkDkBsYwsVv;

1.79
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	VK3ncyiP3NS1N4Sy;

1.78
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.77;
commitid	t9FBKDfc4VDxpEy2;

1.77
date	2014.11.09.22.05.08;	author bluhm;	state Exp;
branches;
next	1.76;
commitid	SqTYB83QZLRauhYQ;

1.76
date	2014.10.14.09.55.44;	author mpi;	state Exp;
branches;
next	1.75;
commitid	8H7cejP4S3KGbzuh;

1.75
date	2014.08.14.08.22.38;	author mpi;	state Exp;
branches;
next	1.74;
commitid	vlb8w9hmS6iNy3Wt;

1.74
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.73;
commitid	DQakU8LLWV6Iwx84;

1.73
date	2014.06.02.10.41.40;	author mpi;	state Exp;
branches;
next	1.72;
commitid	yfgvgIAYmnruV6um;

1.72
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.70;

1.70
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.69;

1.69
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.68;

1.68
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2013.12.20.02.04.08;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.65;

1.65
date	2013.04.02.18.27.47;	author bluhm;	state Exp;
branches;
next	1.64;

1.64
date	2013.03.31.11.18.35;	author bluhm;	state Exp;
branches;
next	1.63;

1.63
date	2013.03.30.12.15.29;	author bluhm;	state Exp;
branches;
next	1.62;

1.62
date	2012.10.21.13.06.03;	author benno;	state Exp;
branches;
next	1.61;

1.61
date	2012.03.17.10.16.41;	author dlg;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.04.17.35.01;	author yasuoka;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2011.05.13.14.31.16;	author oga;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.28.09.56.27;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2011.04.28.07.11.58;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2011.04.24.19.36.54;	author bluhm;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.19.03.47.29;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.14.08.15.26;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2011.04.04.13.26.46;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2011.04.03.16.09.09;	author blambert;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.08.08.34.42;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2008.10.23.22.22.44;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.14.02.17.27;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.09.02.52.15;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2008.05.02.06.49.32;	author ckuethe;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.25.18.04.44;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.29.20.42.27;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.27.04.55.28;	author mcbride;	state Exp;
branches;
next	1.36;

1.36
date	2005.01.14.14.51.28;	author mcbride;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.08.16.37.11;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.25.21.42.08;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.24.01.25.42;	author mcbride;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.21.14.57.19;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.27.22.52.17;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.15.16.43.10;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.09.16.26.11;	author itojun;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.23.16.15.56;	author fgsch;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	2001.06.08.03.53.46;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.05.02.31.35;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.19.03.20.59;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	99.12.19.02.54.29;	author itojun;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	99.09.23.07.20.35;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.06.07.07.22.26;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.04.20.23.04.54;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.04.20.20.06.12;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.01.11.02.01.34;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.01.08.21.51.23;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	98.12.26.12.35.12;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	98.12.15.02.26.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.05.18.21.11.04;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.07.24.00.31.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.30.22.41.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.26.01.23.44;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.08.14.20.19.20;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.15.07.24.42;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.03.14.08.28.58;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.03.04.08.21.52;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.22.30.43;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.50.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches;
next	;

1.20.2.1
date	2001.05.14.22.40.14;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.07.04.10.55.03;	author niklas;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	;

1.24.4.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.24.4.2;

1.24.4.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.24.4.3;

1.24.4.3
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;

1.26.2.1
date	2003.03.14.04.49.40;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.97
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@/*	$OpenBSD: raw_ip.c,v 1.96 2017/03/03 15:48:02 bluhm Exp $	*/
/*	$NetBSD: raw_ip.c,v 1.25 1996/02/18 18:58:33 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/socketvar.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_mroute.h>
#include <netinet/ip_var.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_icmp.h>

#include <net/pfvar.h>

#include "pf.h"

struct inpcbtable rawcbtable;

/*
 * Nominal space allocated to a raw ip socket.
 */
#define	RIPSNDQ		8192
#define	RIPRCVQ		8192

/*
 * Raw interface to IP protocol.
 */

/*
 * Initialize raw connection block q.
 */
void
rip_init(void)
{

	in_pcbinit(&rawcbtable, 1);
}

struct sockaddr_in ripsrc = { sizeof(ripsrc), AF_INET };

int
rip_input(struct mbuf **mp, int *offp, int proto)
{
	struct mbuf *m = *mp;
	struct ip *ip = mtod(m, struct ip *);
	struct inpcb *inp, *last = NULL;
	struct mbuf *opts = NULL;
	struct counters_ref ref;
	uint64_t *counters;

	ripsrc.sin_addr = ip->ip_src;
	TAILQ_FOREACH(inp, &rawcbtable.inpt_queue, inp_queue) {
		if (inp->inp_socket->so_state & SS_CANTRCVMORE)
			continue;
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			continue;
#endif
		if (rtable_l2(inp->inp_rtableid) !=
		    rtable_l2(m->m_pkthdr.ph_rtableid))
			continue;

		if (inp->inp_ip.ip_p && inp->inp_ip.ip_p != ip->ip_p)
			continue;
#if NPF > 0
		if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) {
			struct pf_divert *divert;

			/* XXX rdomain support */
			if ((divert = pf_find_divert(m)) == NULL)
				continue;
			if (!divert->addr.v4.s_addr)
				goto divert_reply;
			if (inp->inp_laddr.s_addr != divert->addr.v4.s_addr)
				continue;
		} else
 divert_reply:
#endif
		if (inp->inp_laddr.s_addr &&
		    inp->inp_laddr.s_addr != ip->ip_dst.s_addr)
			continue;
		if (inp->inp_faddr.s_addr &&
		    inp->inp_faddr.s_addr != ip->ip_src.s_addr)
			continue;
		if (last) {
			struct mbuf *n;

			if ((n = m_copym(m, 0, M_COPYALL, M_NOWAIT)) != NULL) {
				if (last->inp_flags & INP_CONTROLOPTS ||
				    last->inp_socket->so_options & SO_TIMESTAMP)
					ip_savecontrol(last, &opts, ip, n);
				if (sbappendaddr(&last->inp_socket->so_rcv,
				    sintosa(&ripsrc), n, opts) == 0) {
					/* should notify about lost packet */
					m_freem(n);
					m_freem(opts);
				} else
					sorwakeup(last->inp_socket);
				opts = NULL;
			}
		}
		last = inp;
	}
	if (last) {
		if (last->inp_flags & INP_CONTROLOPTS ||
		    last->inp_socket->so_options & SO_TIMESTAMP)
			ip_savecontrol(last, &opts, ip, m);
		if (sbappendaddr(&last->inp_socket->so_rcv, sintosa(&ripsrc), m,
		    opts) == 0) {
			m_freem(m);
			m_freem(opts);
		} else
			sorwakeup(last->inp_socket);
	} else {
		if (ip->ip_p != IPPROTO_ICMP)
			icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_PROTOCOL, 0, 0);
		else
			m_freem(m);

		counters = counters_enter(&ref, ipcounters);
		counters[ips_noproto]++;
		counters[ips_delivered]--;
		counters_leave(&ref, ipcounters);
	}
	return IPPROTO_DONE;
}

/*
 * Generate IP header and pass packet to ip_output.
 * Tack on options user may have setup with control call.
 */
int
rip_output(struct mbuf *m, struct socket *so, struct sockaddr *dstaddr,
    struct mbuf *control)
{
	struct ip *ip;
	struct inpcb *inp;
	int flags, error;

	inp = sotoinpcb(so);
	flags = IP_ALLOWBROADCAST;

	/*
	 * If the user handed us a complete IP packet, use it.
	 * Otherwise, allocate an mbuf for a header and fill it in.
	 */
	if ((inp->inp_flags & INP_HDRINCL) == 0) {
		if ((m->m_pkthdr.len + sizeof(struct ip)) > IP_MAXPACKET) {
			m_freem(m);
			return (EMSGSIZE);
		}
		M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
		if (!m)
			return (ENOBUFS);
		ip = mtod(m, struct ip *);
		ip->ip_tos = inp->inp_ip.ip_tos;
		ip->ip_off = htons(0);
		ip->ip_p = inp->inp_ip.ip_p;
		ip->ip_len = htons(m->m_pkthdr.len);
		ip->ip_src = inp->inp_laddr;
		ip->ip_dst = satosin(dstaddr)->sin_addr;
		ip->ip_ttl = inp->inp_ip.ip_ttl ? inp->inp_ip.ip_ttl : MAXTTL;
	} else {
		if (m->m_pkthdr.len > IP_MAXPACKET) {
			m_freem(m);
			return (EMSGSIZE);
		}
		if (m->m_pkthdr.len < sizeof(struct ip)) {
			m_freem(m);
			return (EINVAL);
		}
		ip = mtod(m, struct ip *);
		/*
		 * don't allow both user specified and setsockopt options,
		 * and don't allow packet length sizes that will crash
		 */
		if ((ip->ip_hl != (sizeof (*ip) >> 2) && inp->inp_options) ||
		    ntohs(ip->ip_len) > m->m_pkthdr.len ||
		    ntohs(ip->ip_len) < ip->ip_hl << 2) {
			m_freem(m);
			return (EINVAL);
		}
		if (ip->ip_id == 0) {
			ip->ip_id = htons(ip_randomid());
		}
		/* XXX prevent ip_output from overwriting header fields */
		flags |= IP_RAWOUTPUT;
		ipstat_inc(ips_rawout);
	}
#ifdef INET6
	/*
	 * A thought:  Even though raw IP shouldn't be able to set IPv6
	 *             multicast options, if it does, the last parameter to
	 *             ip_output should be guarded against v6/v4 problems.
	 */
#endif
	/* force routing table */
	m->m_pkthdr.ph_rtableid = inp->inp_rtableid;

#if NPF > 0
	if (inp->inp_socket->so_state & SS_ISCONNECTED &&
	    ip->ip_p != IPPROTO_ICMP)
		m->m_pkthdr.pf.inp = inp;
#endif

	error = ip_output(m, inp->inp_options, &inp->inp_route, flags,
	    inp->inp_moptions, inp, 0);
	if (error == EACCES)	/* translate pf(4) error for userland */
		error = EHOSTUNREACH;
	return (error);
}

/*
 * Raw IP socket option processing.
 */
int
rip_ctloutput(int op, struct socket *so, int level, int optname,
    struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	int error = 0;
	int dir;

	if (level != IPPROTO_IP) {
		if (op == PRCO_SETOPT)
			(void) m_free(m);
		return (EINVAL);
	}

	switch (optname) {

	case IP_HDRINCL:
		error = 0;
		if (op == PRCO_SETOPT) {
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				inp->inp_flags |= INP_HDRINCL;
			else
				inp->inp_flags &= ~INP_HDRINCL;
			m_free(m);
		} else {
			m->m_len = sizeof(int);
			*mtod(m, int *) = inp->inp_flags & INP_HDRINCL;
		}
		return (error);

	case IP_DIVERTFL:
		switch (op) {
		case PRCO_SETOPT:
			if (m == NULL || m->m_len < sizeof (int)) {
				error = EINVAL;
				break;
			}
			dir = *mtod(m, int *);
			if (inp->inp_divertfl > 0)
				error = ENOTSUP;
			else if ((dir & IPPROTO_DIVERT_RESP) ||
				   (dir & IPPROTO_DIVERT_INIT))
				inp->inp_divertfl = dir;
			else 
				error = EINVAL;

			break;

		case PRCO_GETOPT:
			m->m_len = sizeof(int);
			*mtod(m, int *) = inp->inp_divertfl;
			break;

		default:
			error = EINVAL;
			break;
		}

		if (op == PRCO_SETOPT)
			(void)m_free(m);
		return (error);

	case MRT_INIT:
	case MRT_DONE:
	case MRT_ADD_VIF:
	case MRT_DEL_VIF:
	case MRT_ADD_MFC:
	case MRT_DEL_MFC:
	case MRT_VERSION:
	case MRT_ASSERT:
	case MRT_API_SUPPORT:
	case MRT_API_CONFIG:
#ifdef MROUTING
		switch (op) {
		case PRCO_SETOPT:
			error = ip_mrouter_set(so, optname, m);
			break;
		case PRCO_GETOPT:
			error = ip_mrouter_get(so, optname, m);
			break;
		default:
			error = EINVAL;
			break;
		}
		return (error);
#else
		if (op == PRCO_SETOPT)
			m_free(m);
		return (EOPNOTSUPP);
#endif
	}
	return (ip_ctloutput(op, so, level, optname, m));
}

u_long	rip_sendspace = RIPSNDQ;
u_long	rip_recvspace = RIPRCVQ;

/*ARGSUSED*/
int
rip_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control, struct proc *p)
{
	struct inpcb *inp = sotoinpcb(so);
	int error = 0;

	NET_ASSERT_LOCKED();

	if (req == PRU_CONTROL)
		return (in_control(so, (u_long)m, (caddr_t)nam,
		    (struct ifnet *)control));

	if (inp == NULL) {
		error = EINVAL;
		goto release;
	}

	switch (req) {

	case PRU_DISCONNECT:
		if ((so->so_state & SS_ISCONNECTED) == 0) {
			error = ENOTCONN;
			break;
		}
		/* FALLTHROUGH */
	case PRU_ABORT:
		soisdisconnected(so);
		/* FALLTHROUGH */
	case PRU_DETACH:
		if (inp == NULL)
			panic("rip_detach");
#ifdef MROUTING
		if (so == ip_mrouter[inp->inp_rtableid])
			ip_mrouter_done(so);
#endif
		in_pcbdetach(inp);
		break;

	case PRU_BIND:
	    {
		struct sockaddr_in *addr = mtod(nam, struct sockaddr_in *);

		if (nam->m_len != sizeof(*addr)) {
			error = EINVAL;
			break;
		}
		if (addr->sin_family != AF_INET) {
			error = EADDRNOTAVAIL;
			break;
		}
		if (!((so->so_options & SO_BINDANY) ||
		    addr->sin_addr.s_addr == INADDR_ANY ||
		    addr->sin_addr.s_addr == INADDR_BROADCAST ||
		    in_broadcast(addr->sin_addr, inp->inp_rtableid) ||
		    ifa_ifwithaddr(sintosa(addr), inp->inp_rtableid))) {
			error = EADDRNOTAVAIL;
			break;
		}
		inp->inp_laddr = addr->sin_addr;
		break;
	    }
	case PRU_CONNECT:
	    {
		struct sockaddr_in *addr = mtod(nam, struct sockaddr_in *);

		if (nam->m_len != sizeof(*addr)) {
			error = EINVAL;
			break;
		}
		if (addr->sin_family != AF_INET) {
			error = EAFNOSUPPORT;
			break;
		}
		inp->inp_faddr = addr->sin_addr;
		soisconnected(so);
		break;
	    }

	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	/*
	 * Mark the connection as being incapable of further input.
	 */
	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	/*
	 * Ship a packet out.  The appropriate raw output
	 * routine handles any massaging necessary.
	 */
	case PRU_SEND:
	    {
		struct sockaddr_in dst;

		memset(&dst, 0, sizeof(dst));
		dst.sin_family = AF_INET;
		dst.sin_len = sizeof(dst);
		if (so->so_state & SS_ISCONNECTED) {
			if (nam) {
				error = EISCONN;
				break;
			}
			dst.sin_addr = inp->inp_faddr;
		} else {
			if (nam == NULL) {
				error = ENOTCONN;
				break;
			}
			dst.sin_addr =
			    mtod(nam, struct sockaddr_in *)->sin_addr;
		}
#ifdef IPSEC
		/* XXX Find an IPsec TDB */
#endif
		error = rip_output(m, so, sintosa(&dst), NULL);
		m = NULL;
		break;
	    }

	case PRU_SENSE:
		/*
		 * stat: don't bother with a blocksize.
		 */
		return (0);

	/*
	 * Not supported.
	 */
	case PRU_RCVOOB:
	case PRU_RCVD:
	case PRU_LISTEN:
	case PRU_ACCEPT:
	case PRU_SENDOOB:
		error = EOPNOTSUPP;
		break;

	case PRU_SOCKADDR:
		in_setsockaddr(inp, nam);
		break;

	case PRU_PEERADDR:
		in_setpeeraddr(inp, nam);
		break;

	default:
		panic("rip_usrreq");
	}
release:
	m_freem(m);
	return (error);
}

int
rip_attach(struct socket *so, int proto)
{
	struct inpcb *inp;
	int error;

	if (so->so_pcb)
		panic("rip_attach");
	if ((so->so_state & SS_PRIV) == 0)
		return EACCES;
	if (proto < 0 || proto >= IPPROTO_MAX)
		return EPROTONOSUPPORT;

	if ((error = soreserve(so, rip_sendspace, rip_recvspace)) ||
	    (error = in_pcballoc(so, &rawcbtable))) {
		return error;
	}
	inp = sotoinpcb(so);
	inp->inp_ip.ip_p = proto;
	return 0;
}
@


1.96
log
@Convert the variable argument list of the pr_output functions to
fixed parameters.
OK mpi@@ claudio@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.95 2017/02/01 20:59:47 dhill Exp $	*/
d406 1
a406 1
	if (inp == NULL && req != PRU_ATTACH) {
a412 19
	case PRU_ATTACH:
		if (inp)
			panic("rip_attach");
		if ((so->so_state & SS_PRIV) == 0) {
			error = EACCES;
			break;
		}
		if ((long)nam < 0 || (long)nam >= IPPROTO_MAX) {
			error = EPROTONOSUPPORT;
			break;
		}
		if ((error = soreserve(so, rip_sendspace, rip_recvspace)) ||
		    (error = in_pcballoc(so, &rawcbtable))) {
			break;
		}
		inp = sotoinpcb(so);
		inp->inp_ip.ip_p = (long)nam;
		break;

d547 22
@


1.95
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.94 2017/01/29 19:58:47 bluhm Exp $	*/
d210 2
a211 1
rip_output(struct mbuf *m, ...)
a212 2
	struct socket *so;
	u_long dst;
a215 6
	va_list ap;

	va_start(ap, m);
	so = va_arg(ap, struct socket *);
	dst = va_arg(ap, u_long);
	va_end(ap);
d238 1
a238 1
		ip->ip_dst.s_addr = dst;
d508 1
a508 1
		u_int32_t dst;
d510 3
d518 1
a518 1
			dst = inp->inp_faddr.s_addr;
d524 2
a525 1
			dst = mtod(nam, struct sockaddr_in *)->sin_addr.s_addr;
d530 1
a530 1
		error = rip_output(m, so, dst);
@


1.94
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.93 2017/01/25 17:34:31 bluhm Exp $	*/
d302 1
a302 1
    struct mbuf **mp)
d310 1
a310 1
			(void) m_free(*mp);
d319 1
a319 1
			if (*mp == NULL || (*mp)->m_len < sizeof (int))
d321 1
a321 1
			else if (*mtod(*mp, int *))
d325 1
a325 1
			m_free(*mp);
d327 2
a328 3
			*mp = m_get(M_WAIT, M_SOOPTS);
			(*mp)->m_len = sizeof(int);
			*mtod(*mp, int *) = inp->inp_flags & INP_HDRINCL;
d335 1
a335 1
			if (*mp == NULL || (*mp)->m_len < sizeof (int)) {
d339 1
a339 1
			dir = *mtod(*mp, int *);
d351 2
a352 3
			*mp = m_get(M_WAIT, M_SOOPTS);
			(*mp)->m_len = sizeof(int);
			*mtod(*mp, int *) = inp->inp_divertfl;
d361 1
a361 1
			(void)m_free(*mp);
d377 1
a377 1
			error = ip_mrouter_set(so, optname, mp);
d380 1
a380 1
			error = ip_mrouter_get(so, optname, mp);
d389 1
a389 1
			m_free(*mp);
d393 1
a393 1
	return (ip_ctloutput(op, so, level, optname, mp));
@


1.93
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.92 2017/01/23 16:31:24 bluhm Exp $	*/
d118 2
a119 2
void
rip_input(struct mbuf *m, int hlen, int proto)
d121 1
d202 1
@


1.92
log
@The function raw_input() has not been called since netiso has been
removed in 2004.  The comment about raw_input() above rip_input()
was added in 1981, but it is wrong since 1992.  After that it has
been copied to rip6_input().  (*pr_input)() is never called with
the parameters (mbuf, sockproto, sockaddr, sockaddr).
So retire raw_input().
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.91 2017/01/10 09:01:18 mpi Exp $	*/
d119 1
a119 1
rip_input(struct mbuf *m, ...)
@


1.91
log
@Remove NULL checks before m_free(9), it deals with it.

ok bluhm@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.90 2016/12/19 09:22:24 rzalamena Exp $	*/
a117 5
/*
 * Setup generic address and protocol structures
 * for raw_input routine, then pass them along with
 * mbuf chain.
 */
@


1.90
log
@Extend the multicast sockets and multicast hash table support to multiple
domains. This is one step towards supporting to run more than one multicast
socket in different domains at the same time.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.89 2016/12/19 08:36:49 mpi Exp $	*/
d328 1
a328 2
			if (*mp)
				(void)m_free(*mp);
@


1.89
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.88 2016/11/21 09:09:06 mpi Exp $	*/
d458 2
a459 2
		if (so == ip_mrouter)
			ip_mrouter_done();
@


1.88
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.87 2016/11/14 03:51:53 dlg Exp $	*/
d413 1
a413 1
	splsoftassert(IPL_SOFTNET);
@


1.87
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the ipstat struct.

ipstat_inc(ips_foo) replaces ipstat.ips_foo++ for the actual updates.
ipstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the ipstat struct for now.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.86 2016/03/07 18:44:00 naddy Exp $	*/
d412 2
a413 1
	int s;
a436 1
		s = splsoftnet();
a438 1
			splx(s);
a440 1
		splx(s);
@


1.86
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.85 2015/12/03 14:55:18 vgross Exp $	*/
d129 2
d200 5
a204 2
		ipstat.ips_noproto++;
		ipstat.ips_delivered--;
d275 1
a275 1
		ipstat.ips_rawout++;
@


1.85
log
@Remove broadcast matching from ifa_ifwithaddr(), use in_broadcast() where
required.

ok bluhm@@ mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.84 2015/07/28 12:22:07 bluhm Exp $	*/
d110 1
a110 1
rip_init()
@


1.84
log
@Implement pf divert-reply for raw sockets.  Note that an empty
divert->addr means that the rule has a divert-reply option.  With
divert-to the divert->addr is always set.  The divert-reply rules
should compare the original packet with the socket addresses.  So
skip the step that compares the inp->inp_laddr with the empty
divert->addr.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.83 2015/07/15 23:09:59 deraadt Exp $	*/
d476 1
@


1.83
log
@use mp for the name of a variable of type struct mbuf **, rather than m
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.82 2015/07/15 22:16:42 deraadt Exp $	*/
d151 2
d156 1
@


1.82
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.81 2015/06/30 15:30:17 mpi Exp $	*/
d297 1
a297 1
    struct mbuf **m)
d305 1
a305 1
			(void) m_free(*m);
d314 1
a314 1
			if (*m == NULL || (*m)->m_len < sizeof (int))
d316 1
a316 1
			else if (*mtod(*m, int *))
d320 2
a321 2
			if (*m)
				(void)m_free(*m);
d323 3
a325 3
			*m = m_get(M_WAIT, M_SOOPTS);
			(*m)->m_len = sizeof(int);
			*mtod(*m, int *) = inp->inp_flags & INP_HDRINCL;
d332 1
a332 1
			if (*m == NULL || (*m)->m_len < sizeof (int)) {
d336 1
a336 1
			dir = *mtod(*m, int *);
d348 3
a350 3
			*m = m_get(M_WAIT, M_SOOPTS);
			(*m)->m_len = sizeof(int);
			*mtod(*m, int *) = inp->inp_divertfl;
d359 1
a359 1
			(void)m_free(*m);
d375 1
a375 1
			error = ip_mrouter_set(so, optname, m);
d378 1
a378 1
			error = ip_mrouter_get(so, optname, m);
d387 1
a387 1
			m_free(*m);
d391 1
a391 1
	return (ip_ctloutput(op, so, level, optname, m));
@


1.81
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.80 2015/06/07 01:25:27 krw Exp $	*/
d172 1
a172 2
					if (opts)
						m_freem(opts);
d187 1
a187 2
			if (opts)
				m_freem(opts);
d304 1
a304 1
		if (op == PRCO_SETOPT && *m)
d358 1
a358 1
		if (op == PRCO_SETOPT && *m)
d386 1
a386 1
		if (op == PRCO_SETOPT && *m)
d566 1
a566 2
	if (m != NULL)
		m_freem(m);
@


1.80
log
@Replace a bunch of == 0 with == NULL in pointer tests. Nuke some
annoying trailing, leading and embedded whitespace. No change to
.o files.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.79 2015/01/24 00:29:06 deraadt Exp $	*/
d164 1
a164 1
			if ((n = m_copy(m, 0, (int)M_COPYALL)) != NULL) {
@


1.79
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.78 2014/12/05 15:50:04 mpi Exp $	*/
d45 4
a48 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d316 1
a316 1
			if (*m == 0 || (*m)->m_len < sizeof (int))
d334 1
a334 1
			if (*m == 0 || (*m)->m_len < sizeof (int)) {
d451 1
a451 1
		if (inp == 0)
@


1.78
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.77 2014/11/09 22:05:08 bluhm Exp $	*/
a80 1
#include <net/pfvar.h>
d89 2
@


1.77
log
@To implement transparent relays for connectionless protocols, the
pf the state has to vanish immediately when the relay closes the
socket.  To make this work reliably, the linkage between state and
socket must be established with the first packet.  This packet could
be incomming or outgoing.
Link the pf state in the socket layer earlier.  This makes all tests
in /usr/src/regress/sys/net/pf_divert pass.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.76 2014/10/14 09:55:44 mpi Exp $	*/
d79 1
@


1.76
log
@Don't check for an empty list of interfaces.  This is never true even if
you don't have a physical interface on your machine, so why rawip should
be more clever^Wparanoid than the others?

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.75 2014/08/14 08:22:38 mpi Exp $	*/
d278 6
@


1.75
log
@Kill MRT_{ADD,DEL}_BW_UPCALL interfaces and the bandwidth monitoring
code that comes with them.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.74 2014/07/22 11:06:10 mpi Exp $	*/
d460 1
a460 1
		if (TAILQ_EMPTY(&ifnet) || addr->sin_family != AF_INET) {
a479 4
			break;
		}
		if (TAILQ_EMPTY(&ifnet)) {
			error = EADDRNOTAVAIL;
@


1.74
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.73 2014/06/02 10:41:40 mpi Exp $	*/
a365 2
	case MRT_ADD_BW_UPCALL:
	case MRT_DEL_BW_UPCALL:
@


1.73
log
@Simply use ifa_ifwithaddr() to check if the binding address is on the
system.  This function checks for unicast and broadcast addresses, so
there is no need to do two lookups instead of one.

Inputs & ok jca@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.72 2014/04/21 12:22:26 henning Exp $	*/
a82 1
#include <netinet/in_systm.h>
@


1.72
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.70 2014/04/07 10:04:17 mpi Exp $	*/
d468 3
a470 3
		    addr->sin_addr.s_addr == 0 ||
		    in_iawithaddr(addr->sin_addr, inp->inp_rtableid) ||
		    in_broadcast(addr->sin_addr, NULL, inp->inp_rtableid))) {
@


1.71
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d281 1
a281 1
	    inp->inp_moptions, inp);
@


1.70
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.68 2014/03/27 13:27:28 mpi Exp $	*/
d138 1
a138 1
		    rtable_l2(m->m_pkthdr.rdomain))
d277 2
a278 2
	/* force routing domain */
	m->m_pkthdr.rdomain = inp->inp_rtableid;
@


1.69
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.67 2013/12/20 02:04:08 krw Exp $	*/
d221 1
a221 1
	flags = (so->so_options & SO_DONTROUTE) | IP_ALLOWBROADCAST;
@


1.68
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d221 1
a221 1
	flags = IP_ALLOWBROADCAST;
@


1.67
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.66 2013/04/10 08:50:59 mpi Exp $	*/
d221 1
a221 1
	flags = (so->so_options & SO_DONTROUTE) | IP_ALLOWBROADCAST;
@


1.66
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.65 2013/04/02 18:27:47 bluhm Exp $	*/
d130 1
a130 1
	CIRCLEQ_FOREACH(inp, &rawcbtable.inpt_queue, inp_queue) {
@


1.65
log
@Use macros sotoinpcb() and intotcpcb() instead of casts.  Use NULL
instead of 0 for pointers.  No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.64 2013/03/31 11:18:35 bluhm Exp $	*/
d402 1
a402 3
#ifdef MROUTING
	extern struct socket *ip_mrouter;
#endif
@


1.64
log
@The call to in_pcballoc() in user request attach was handled in
three different ways.  Use the same code in udp_usrreq() and
rip_usrreq() and rip6_usrreq(). This also fixes a pcb and socket
leak in udp_usrreq() in case soreserve() fails.  Put an splsoftassert()
into in_pcballoc() for safety.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.63 2013/03/30 12:15:29 bluhm Exp $	*/
d434 1
a434 1
		inp = (struct inpcb *)so->so_pcb;
@


1.63
log
@Restrict protocol numbers for raw sockets to the range from 0 to 255.
OK deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.62 2012/10/21 13:06:03 benno Exp $	*/
d399 1
d401 1
a401 1
	struct inpcb *inp = sotoinpcb(so);
d427 1
d429 2
a430 1
		    (error = in_pcballoc(so, &rawcbtable)))
d432 2
@


1.62
log
@Add the IP_DIVERTFL socket option on divert(4) sockets to control
which packets (as in direction) of the traffic will be diverted
through the divert socket.
ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.61 2012/03/17 10:16:41 dlg Exp $	*/
d420 4
@


1.61
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.60 2011/07/04 17:35:01 yasuoka Exp $	*/
d295 2
a296 1
	int error;
d322 33
@


1.60
log
@Fix to be able to bind a raw socket to 0.0.0.0.  It had been broken after
1.54.

ok claudio@@ sosososo henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.59 2011/07/04 06:54:49 claudio Exp $	*/
d221 1
a221 1
	flags = (so->so_options & (SO_DONTROUTE|SO_JUMBO)) | IP_ALLOWBROADCAST;
@


1.59
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.58 2011/05/13 14:31:16 oga Exp $	*/
d422 1
a422 3
		if (TAILQ_EMPTY(&ifnet) ||
		    addr->sin_family != AF_INET ||
		    addr->sin_addr.s_addr == 0) {
d427 3
a429 2
		     in_iawithaddr(addr->sin_addr, inp->inp_rtableid) ||
		     in_broadcast(addr->sin_addr, NULL, inp->inp_rtableid))) {
@


1.58
log
@Revert the pf->socket linking diff.

at least krw@@, pirofti@@ and todd@@ have been seeing panics (todd and krw
with xxxterm not sure about pirofti) involving pool corruption while
using this commit.

krw and todd confirm that this backout fixes the problem.

ok blambert@@ krw@@, todd@@ henning@@ and kettenis@@

	    Double link between pf states and sockets.  Henning has
	    already implemented half of it.  The additional part is: -
	    The pf state lookup for outgoing packets is optimized by
	    using mbuf->inp->state.
	    - For incomming tcp, udp, raw, raw6 packets the socket
	    lookup always is optimized by using mbuf->state->inp.
	    - All protocols establish the link for incomming packets.
	    - All protocols set the inp in the mbuf for outgoing packets.
	      This allows the linkage beginning with the first packet
	      for outgoing connections.
	    - In case of divert states, delete the state when the socket
	      closes.  Otherwise new connections could match on old
	      states instead of being diverted to the listen socket.
	    ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.57 2011/04/28 09:56:27 claudio Exp $	*/
d150 1
a150 1
			if (inp->inp_laddr.s_addr != divert->addr.ipv4.s_addr)
@


1.57
log
@Make in_broadcast() rdomain aware. Mostly mechanical change.
This fixes the problem of binding sockets to broadcast IPs in other
rdomains.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.56 2011/04/28 07:11:58 claudio Exp $	*/
a159 10
#if NPF > 0
		if (m->m_pkthdr.pf.statekey && !inp->inp_pf_sk &&
		    !((struct pf_state_key *)m->m_pkthdr.pf.statekey)->inp &&
		    (inp->inp_socket->so_state & SS_ISCONNECTED) &&
		    ip->ip_p != IPPROTO_ICMP) {
			((struct pf_state_key *)m->m_pkthdr.pf.statekey)->inp =
			    inp;
			inp->inp_pf_sk = m->m_pkthdr.pf.statekey;
		}
#endif
a279 5
#if NPF > 0
	if (inp->inp_socket->so_state & SS_ISCONNECTED &&
	    ip->ip_p != IPPROTO_ICMP)
		m->m_pkthdr.pf.inp = inp;
#endif
@


1.56
log
@Similar to the in_pcb.c change allow raw sockets to be bound to the
local network boradcast. While there kill some leftover AF_IMPLINK
checks.
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.55 2011/04/24 19:36:54 bluhm Exp $	*/
d445 1
a445 1
		     in_broadcast(addr->sin_addr, NULL))) {
@


1.55
log
@Double link between pf states and sockets.  Henning has already
implemented half of it.  The additional part is:
- The pf state lookup for outgoing packets is optimized by using
  mbuf->inp->state.
- For incomming tcp, udp, raw, raw6 packets the socket lookup always
  is optimized by using mbuf->state->inp.
- All protocols establish the link for incomming packets.
- All protocols set the inp in the mbuf for outgoing packets.
  This allows the linkage beginning with the first packet for
  outgoing connections.
- In case of divert states, delete the state when the socket closes.
  Otherwise new connections could match on old states instead of
  being diverted to the listen socket.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.54 2011/04/19 03:47:29 dlg Exp $	*/
d437 9
a445 7
		if ((TAILQ_EMPTY(&ifnet)) ||
		    ((addr->sin_family != AF_INET) &&
		     (addr->sin_family != AF_IMPLINK)) ||
		    (addr->sin_addr.s_addr &&
		     (!(so->so_options & SO_BINDANY) &&
		     in_iawithaddr(addr->sin_addr, inp->inp_rtableid) ==
		     NULL))) {
d464 1
a464 2
		if ((addr->sin_family != AF_INET) &&
		     (addr->sin_family != AF_IMPLINK)) {
@


1.54
log
@reintroduce using the RB tree for local address lookups. this is
confusing because both addresses and broadcast addresses are put
into the tree.

there are two types of local address lookup. the first is when the
socket layer wants a local address, the second is in ip_input when
the kernel is figuring out the packet is for it to process or
forward.

ip_input considers local addresses and broadcast addresses as local,
however, the handling of broadcast addresses is different depending
on whether ip_directedbcast is set. if if ip_directbcast is unset
then a packet coming in on any interface to any of the systems
broadcast addresses is considered local, otherwise the broadcast
packet must exist on the interface it was received on.

the code also needs to consider classful broadcast addresses so we
can continue some legacy applications (eg, netbooting old sparcs
that use rarp and bootparam requests to classful broadcast addresses
as per PR6382). this diff maintains that support, but restricts it
to packets that are broadcast on the link layer (eg, ethernet
broadcasted packets), and it only looks up addresses on the local
interface. we now only support classful broadcast addresses on local
interfaces to avoid weird side effects with packets routed to us.

the ip4 socket layer does lookups for local addresses with a wrapper
around the global address tree that rejects matches against broadcast
addresses. we now no longer support bind sockets to broadcast
addresses, no matter what the value of ip_directedbcast is.

ok henning@@
testing (and possibly ok) claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.53 2011/04/14 08:15:26 claudio Exp $	*/
d160 10
d290 5
@


1.53
log
@Backout the in_iawithaddr() -> ifa_ifwithaddr() change.
There is a massive issue with broadcast addrs because ifa_ifwithaddr()
handles them differently then in_iawithaddr().
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.52 2011/04/04 13:26:46 henning Exp $	*/
d427 2
a428 2
		     in_iawithaddr(addr->sin_addr, NULL, inp->inp_rtableid) ==
		     0))) {
@


1.52
log
@in_iawithaddr -> ifawithaddr
the latter is now much faster and the former becomes a wrapper + compat hacks
around the latter in a bit.
ok dlg sthen and "ah hai" from various in various bars here
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.51 2011/04/03 16:09:09 blambert Exp $	*/
d427 2
a428 1
		    !ifa_ifwithaddr(sintosa(addr), inp->inp_rtableid)))) {
@


1.51
log
@Don't attempt to enqueue mbufs on sockets marked as SS_CANTRCVMORE, as
was done earlier for routing sockets.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.50 2010/09/08 08:34:42 claudio Exp $	*/
d427 1
a427 2
		     in_iawithaddr(addr->sin_addr, NULL, inp->inp_rtableid) ==
		     0))) {
@


1.50
log
@Return EACCES when pf_test() blocks a packet in ip_output(). This allows
ip_forward() to know the difference between blocked packets and those that
can't be forwarded (EHOSTUNREACH). Only in the latter case an ICMP should
be sent. In the other callers of ip_output() change the error back to
EHOSTUNREACH since userland may not expect EACCES on a sendto().
OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.49 2010/07/03 04:44:51 guenther Exp $	*/
d131 2
@


1.49
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.48 2009/11/03 10:59:04 claudio Exp $	*/
d210 1
a210 1
	int flags;
d278 5
a282 2
	return (ip_output(m, inp->inp_options, &inp->inp_route, flags,
	    inp->inp_moptions, inp));
@


1.48
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.47 2009/06/05 00:05:22 claudio Exp $	*/
d135 2
a136 1
		if (inp->inp_rdomain != rtable_l2(m->m_pkthdr.rdomain))
d276 1
a276 1
	m->m_pkthdr.rdomain = inp->inp_rdomain;
d422 1
a422 1
		     in_iawithaddr(addr->sin_addr, NULL, inp->inp_rdomain) ==
@


1.47
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.46 2008/10/23 22:22:44 deraadt Exp $	*/
d135 1
a135 1
		if (inp->inp_rdomain != m->m_pkthdr.rdomain)
@


1.46
log
@use the correct idiom for NFOO things which come from "foo.h" files
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.45 2008/06/14 02:17:27 jsing Exp $	*/
d135 3
d144 1
d274 3
d421 2
a422 1
		     in_iawithaddr(addr->sin_addr, NULL) == 0))) {
@


1.45
log
@Include "pf.h" so we get NPF.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.43 2008/05/09 02:52:15 markus Exp $	*/
d137 1
a137 1
#if NPF
@


1.44
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d91 2
@


1.43
log
@Add SO_BINDANY socket option from BSD/OS.

The option allows a socket to be bound to addresses which are not
local to the machine.  In order to receive packets for these addresses
SO_BINDANY needs to be combined with matching outgoing pf(4) divert
rules, see pf.conf(5).

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.42 2008/05/09 02:44:54 markus Exp $	*/
d348 1
a348 1
    struct mbuf *control)
@


1.42
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.41 2008/05/02 06:49:32 ckuethe Exp $	*/
d411 2
a412 1
		     ifa_ifwithaddr(sintosa(addr)) == 0)) {
@


1.41
log
@Make the SO_TIMESTAMP sockopt work. When set, this allows the user to
get a timestamp of when the datagram was accepted (by udp(4), for
example) rather than having to take a timestamp with gettimeofday(2)
when recv(2) returns - possibly several hundreds of microseconds later.
May be of use to those interested in precision network timing schemes
or QoS for media applications. Tested on alpha, amd64, i386 and sparc64.
manpage suggestions from jmc, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.40 2006/11/25 18:04:44 claudio Exp $	*/
d80 1
d135 10
@


1.40
log
@Remove unneeded branch, no need to check if opts is != NULL just set it to
NULL in any case.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.39 2006/05/29 20:42:27 claudio Exp $	*/
d144 2
a145 1
				if (last->inp_flags & INP_CONTROLOPTS)
d161 2
a162 1
		if (last->inp_flags & INP_CONTROLOPTS)
@


1.39
log
@Make savecontrol functions more generic and use them now for raw IP too.
Additionally add the IP_RECVIF option which returns the interface a packet
was received on. OK markus@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.38 2006/03/05 21:48:57 miod Exp $	*/
d154 1
a154 2
				if (opts)
					opts = NULL;
@


1.38
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.37 2005/05/27 04:55:28 mcbride Exp $	*/
d123 2
a124 2
	struct inpcb *inp;
	struct socket *last = 0;
d142 1
d144 4
a147 3
				if (sbappendaddr(&last->so_rcv,
				    sintosa(&ripsrc), n,
				    (struct mbuf *)0) == 0)
d150 6
a155 2
				else
					sorwakeup(last);
d158 1
a158 1
		last = inp->inp_socket;
d161 4
a164 2
		if (sbappendaddr(&last->so_rcv, sintosa(&ripsrc), m,
		    (struct mbuf *)0) == 0)
d166 4
a169 2
		else
			sorwakeup(last);
d264 2
a265 5
rip_ctloutput(op, so, level, optname, m)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **m;
d335 2
a336 4
rip_usrreq(so, req, m, nam, control)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
d345 1
a345 1
			(struct ifnet *)control));
@


1.37
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.36 2005/01/14 14:51:28 mcbride Exp $	*/
d390 1
a390 1
		if ((ifnet.tqh_first == 0) ||
d409 1
a409 1
		if (ifnet.tqh_first == 0) {
@


1.36
log
@Add kernel support for Protocol Independant Multicast (PIM)
Information: http://netweb.usc.edu/pim/

From Pavlin Radoslavov <pavlin@@icir.org>

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.35 2004/12/08 16:37:11 henning Exp $	*/
d190 1
a190 1
	flags = (so->so_options & SO_DONTROUTE) | IP_ALLOWBROADCAST;
@


1.35
log
@allow ToS to be set on raw ip sockets
From: "Esben Norby (ST/LMD)" <esben.norby@@ericsson.com>
ok hshoexer markus millert
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.34 2004/11/25 21:42:08 markus Exp $	*/
d297 4
@


1.34
log
@use ttl from setsockopt(), similar to bsd/os; ok henning, mcbride, fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.33 2004/11/24 01:25:42 mcbride Exp $	*/
d205 1
a205 1
		ip->ip_tos = 0;
@


1.33
log
@Multicast routing cleanup from Pavlin Radoslavov
- sync ip_mroute.c with NetBSD
- import some FreeBSD changes to MFC entry handling
- set im->im_vif correctly when sending IGMPMSG_WRONGVIF
- increment mrtstat.mrts_upcalls correctly
- return error from get_sg_cnt() if there is no matching forwarding entry

ok henning@@ brad@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.32 2003/12/21 14:57:19 markus Exp $	*/
d211 1
a211 1
		ip->ip_ttl = MAXTTL;
@


1.32
log
@use CIRCLEQ* for pcb's; ok deraadt, henning, mcbride, with help from canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.31 2003/12/10 07:22:43 itojun Exp $	*/
d300 1
a300 1
			error = ip_mrouter_set(optname, so, m);
d303 1
a303 1
			error = ip_mrouter_get(optname, so, m);
@


1.31
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.30 2003/07/09 22:03:16 itojun Exp $	*/
d127 1
a127 3
	for (inp = rawcbtable.inpt_queue.cqh_first;
	    inp != (struct inpcb *)&rawcbtable.inpt_queue;
	    inp = inp->inp_queue.cqe_next) {
@


1.30
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.29 2003/06/02 23:28:14 millert Exp $	*/
d122 2
a123 2
	register struct ip *ip = mtod(m, struct ip *);
	register struct inpcb *inp;
d181 2
a182 2
	register struct ip *ip;
	register struct inpcb *inp;
d262 2
a263 2
	register struct inpcb *inp = sotoinpcb(so);
	register int error;
d327 1
a327 1
	register struct socket *so;
d331 2
a332 2
	register int error = 0;
	register struct inpcb *inp = sotoinpcb(so);
d438 1
a438 1
		register u_int32_t dst;
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.28 2003/05/27 22:52:17 itojun Exp $	*/
d208 1
a208 1
		ip->ip_off = 0;
d210 1
a210 1
		ip->ip_len = m->m_pkthdr.len;
d219 1
a219 1
		if (m->m_pkthdr.len < sizeof (struct ip)) {
a223 2
		NTOHS(ip->ip_len);
		NTOHS(ip->ip_off);
d229 2
a230 2
		    ip->ip_len > m->m_pkthdr.len ||
		    ip->ip_len < ip->ip_hl << 2) {
@


1.28
log
@don't use M_WAIT here.  we could be in splnet, and caller may not be
xx_usrreq.  henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.27 2003/02/15 16:43:10 markus Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.27
log
@rip_output: make sure a full ip header is passed for INP_HDRINCL; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.26 2002/06/09 16:26:11 itojun Exp $	*/
d207 3
a209 1
		M_PREPEND(m, sizeof(struct ip), M_WAIT);
@


1.26
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.25 2002/03/15 18:19:52 millert Exp $	*/
d220 4
@


1.26.2.1
log
@Pull patch from current:
Fix by markus@@
rip_output: make sure a full ip header is passed for INP_HDRINCL.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.27 2003/02/15 16:43:10 markus Exp $	*/
a219 4
		}
		if (m->m_pkthdr.len < sizeof (struct ip)) {
			m_freem(m);
			return (EINVAL);
@


1.25
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.24 2001/06/23 16:15:56 fgsch Exp $	*/
d37 1
a37 1
 * 
d41 1
a41 1
 * 
d56 1
a56 1
 * 
d68 1
a68 1
 * 
@


1.24
log
@Remove unneeded ip_id convertions.
Instead of using HTONS macro in some places, use htons directly in the
struct member and save us a few bytes.
Fix comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.23 2001/06/08 03:53:46 angelos Exp $	*/
a123 1
#if __STDC__
a124 5
#else
rip_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
a180 1
#if __STDC__
a181 5
#else
rip_output(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.24.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.24 2001/06/23 16:15:56 fgsch Exp $	*/
d124 1
d126 5
d187 1
d189 5
@


1.24.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.24.4.1 2002/06/11 03:31:37 art Exp $	*/
d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
@


1.24.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a219 4
		}
		if (m->m_pkthdr.len < sizeof (struct ip)) {
			m_freem(m);
			return (EINVAL);
@


1.23
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.22 2001/06/05 02:31:35 deraadt Exp $	*/
d247 1
a247 2
			ip->ip_id = ip_randomid();
			HTONS(ip->ip_id);
@


1.22
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.21 2000/09/19 03:20:59 angelos Exp $	*/
d76 1
a76 1
#include <sys/malloc.h>
a80 2
#include <sys/errno.h>
#include <sys/systm.h>
a92 2

#include <machine/stdarg.h>
@


1.21
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.20 1999/12/19 02:54:29 itojun Exp $	*/
d36 37
a72 1
 *	@@(#)raw_ip.c	8.2 (Berkeley) 1/4/94
a73 12

/*
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.20
log
@disallow AF mismatch on inbound.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.19 1999/09/23 07:20:35 deraadt Exp $	*/
a71 4
#ifdef IPSEC
extern int     	check_ipsec_policy  __P((struct inpcb *, u_int32_t));
#endif

d447 1
a447 1
		if (!(error = check_ipsec_policy(inp, dst)))
@


1.20.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.21 2000/09/19 03:20:59 angelos Exp $	*/
d72 4
d451 1
a451 1
		/* XXX Find an IPsec TDB */
@


1.20.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.20.2.1 2001/05/14 22:40:14 niklas Exp $	*/
d36 1
a36 37
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
d39 12
d52 1
a52 1
#include <sys/systm.h>
d57 2
d72 2
d227 2
a228 1
			ip->ip_id = htons(ip_randomid());
@


1.20.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d124 1
d126 5
d187 1
d189 5
@


1.20.2.4
log
@Sync the SMP branch with 3.3
@
text
@d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
a219 4
		}
		if (m->m_pkthdr.len < sizeof (struct ip)) {
			m_freem(m);
			return (EINVAL);
@


1.20.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.20.2.4 2003/03/28 00:06:54 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d207 1
a207 3
		M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
		if (!m)
			return (ENOBUFS);
@


1.20.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d122 2
a123 2
	struct ip *ip = mtod(m, struct ip *);
	struct inpcb *inp;
d127 3
a129 1
	CIRCLEQ_FOREACH(inp, &rawcbtable.inpt_queue, inp_queue) {
d181 2
a182 2
	struct ip *ip;
	struct inpcb *inp;
d208 1
a208 1
		ip->ip_off = htons(0);
d210 1
a210 1
		ip->ip_len = htons(m->m_pkthdr.len);
d219 1
a219 1
		if (m->m_pkthdr.len < sizeof(struct ip)) {
d224 2
d231 2
a232 2
		    ntohs(ip->ip_len) > m->m_pkthdr.len ||
		    ntohs(ip->ip_len) < ip->ip_hl << 2) {
d264 2
a265 2
	struct inpcb *inp = sotoinpcb(so);
	int error;
d329 1
a329 1
	struct socket *so;
d333 2
a334 2
	int error = 0;
	struct inpcb *inp = sotoinpcb(so);
d440 1
a440 1
		u_int32_t dst;
@


1.19
log
@fix same-interface-out-as-in and packet gets corrupted bug noted by
james@@oaktree.co.uk by re-working icmp embedded-packet code so that
ip_forward() m_copy()-aliased packet can be forwarded to ip_output and
icmp_error() safely, because no packet tweaking is needed before
calling icmp_error()
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.18 1999/06/07 07:22:26 deraadt Exp $	*/
d124 4
@


1.18
log
@return a ICMP_UNREACH_PROTOCOL for protocols we do not support; discussion with cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.17 1999/04/20 23:04:54 niklas Exp $	*/
a156 1
		/* Perhaps should send an ICMP protocol unreachable here. */
@


1.17
log
@messup, learn to test *all* variants of compile options when
altering the logic round such.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.16 1999/04/20 20:06:12 niklas Exp $	*/
d70 1
d153 4
a156 1
		m_freem(m);
@


1.16
log
@Merge MROUTING and IPSEC wrt handling of IP-in-IP tunnelled packets.
Fix a panic case in the MROUTING code too.  Drop M_TUNNEL support, nothing
ever uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.15 1999/01/11 02:01:34 deraadt Exp $	*/
d66 1
a69 4

#ifdef MROUTING
#include <netinet/ip_mroute.h>
#endif
@


1.15
log
@netinet merge of NRL stuff. some indent and shrinkage needed; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.14 1999/01/08 21:51:23 provos Exp $	*/
a66 1
#include <netinet/ip_mroute.h>
d69 4
@


1.14
log
@dont call ip_randomid() in htons().
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.13 1998/12/26 12:35:12 provos Exp $	*/
d39 12
d99 2
a100 1
struct	sockaddr_in ripsrc = { sizeof(ripsrc), AF_INET };
d153 1
d231 7
@


1.13
log
@make ip_id random but ensure that ids dont repeat for some period.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.12 1998/12/15 02:26:35 deraadt Exp $	*/
d209 4
a212 2
		if (ip->ip_id == 0)
			ip->ip_id = htons(ip_randomid());
@


1.12
log
@check for valid ip_hl too; route@@infonexus.com
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.11 1998/05/18 21:11:04 provos Exp $	*/
d210 1
a210 1
			ip->ip_id = htons(ip_id++);
@


1.11
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.10 1997/07/24 00:31:14 deraadt Exp $	*/
d204 2
a205 1
		    ip->ip_len > m->m_pkthdr.len) {
@


1.10
log
@cmd is a u_long
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.9 1997/01/30 22:41:59 deraadt Exp $	*/
d59 4
d215 1
a215 1
	    inp->inp_moptions));
d419 3
@


1.9
log
@for IP_HDRINCL option, use ip_len/ip_off in network order; lidl@@va.pubnix.com
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.8 1997/01/26 01:23:44 tholo Exp $	*/
d299 1
a299 1
		return (in_control(so, (long)m, (caddr_t)nam,
@


1.8
log
@Make ip_len and ip_off unsigned values; don't transmit or accept packets
larger than the maximum IP packet size.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.7 1996/08/14 20:19:20 deraadt Exp $	*/
d193 2
@


1.7
log
@restrict some raw ip packets that may crash ip_output(); from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.5 1996/03/14 08:28:58 tholo Exp $	*/
d174 4
d188 4
@


1.6
log
@Fix bogosity in import of Lite2 fix
@
text
@a157 1
	struct mbuf *opts;
a182 1
		opts = inp->inp_options;
d185 9
a195 1
		opts = NULL;
d200 2
a201 1
	return (ip_output(m, opts, &inp->inp_route, flags, inp->inp_moptions));
@


1.5
log
@From Lite2; improve handling of socket options on raw datagrams and multi-
cast routing commands
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.4 1996/03/04 08:21:52 niklas Exp $	*/
a261 17

	default:
		if (optname >= MRT_INIT) {
#ifdef MROUTING
			if (op == PRCO_SETOPT) {
				error = ip_mrouter_cmd(optname, so, *m);
				if (*m)
					(void)m_free(*m);
			} else
				error = EINVAL;
			return (error);
#else
			if (op == PRCO_SETOPT && *m)
				(void)m_free(*m);
			return (EOPNOTSUPP);
#endif
		}
@


1.4
log
@From NetBSD: Fix PR/2095 options MROUTING did not compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip.c,v 1.3 1996/03/03 22:30:43 niklas Exp $	*/
d208 1
a208 3
#ifdef MROUTING
	int error;
#endif
d211 2
a212 2
		if (m != 0 && *m != 0)
			(void)m_free(*m);
d219 9
a227 8
		if (op == PRCO_SETOPT || op == PRCO_GETOPT) {
			if (m == 0 || *m == 0 || (*m)->m_len < sizeof (int))
				return (EINVAL);
			if (op == PRCO_SETOPT) {
				if (*mtod(*m, int *))
					inp->inp_flags |= INP_HDRINCL;
				else
					inp->inp_flags &= ~INP_HDRINCL;
d229 4
a232 5
			} else {
				(*m)->m_len = sizeof (int);
				*mtod(*m, int *) = inp->inp_flags & INP_HDRINCL;
			}
			return (0);
d234 1
a234 1
		break;
d262 17
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: raw_ip.c,v 1.24 1996/02/13 23:43:29 christos Exp $	*/
d208 3
@


1.2
log
@from netbsd:
make netinet work on systems where pointers and longs are 64 bits
(like the alpha).  Biggest problem: IP headers were overlayed with
structure which included pointers, and which therefore didn't overlay
properly on 64-bit machines.  Solution: instead of threading pointers
through IP header overlays, add a "queue element" structure to do
the threading, and point it at the ip headers.
@
text
@d1 2
a2 1
/*	$NetBSD: raw_ip.c,v 1.22 1995/11/30 16:42:18 pk Exp $	*/
d57 3
d80 1
a80 1
	in_pcbinit(&rawcbtable);
d90 4
a93 1
rip_input(m)
d95 2
d116 1
a116 1
			if (n = m_copy(m, 0, (int)M_COPYALL)) {
d146 8
a153 2
rip_output(m, so, dst)
	register struct mbuf *m;
a155 1
{
d157 1
a157 1
	register struct inpcb *inp = sotoinpcb(so);
d159 10
a168 1
	int flags = (so->so_options & SO_DONTROUTE) | IP_ALLOWBROADCAST;
a207 1
	register int error;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: raw_ip.c,v 1.21 1995/06/18 20:01:15 cgd Exp $	*/
d258 9
d408 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
