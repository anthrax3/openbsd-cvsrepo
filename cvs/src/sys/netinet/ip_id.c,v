head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.14
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.12
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.10
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.4
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.16
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.14
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.10
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.12
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.10
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.6
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.10
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.23;
commitid	Z1vcFtHO8wRH0yRt;

1.23
date	2011.03.31.10.36.42;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.09.07.07.17;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.15.04.55.25;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.15.04.52.23;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.15.04.36.31;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.02.21.38.18;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.02.21.29.07;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.29.03.37.26;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.27.19.59.11;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.22.04.37.20;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.12.06.57.12;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.12.02.50.44;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.12.02.03.27;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.10.07.21.00;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.21.04.06.39;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.08.03.53.46;	author angelos;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.06.04.19.57.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.08.26.13.37.01;	author provos;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	98.12.26.12.35.12;	author provos;	state Exp;
branches;
next	;

1.2.4.1
date	2001.07.04.10.54.48;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@/*	$OpenBSD: ip_id.c,v 1.23 2011/03/31 10:36:42 jasper Exp $ */

/*
 * Copyright (c) 2008 Theo de Raadt, Ryan McBride
 * 
 * Slightly different algorithm from the one designed by
 * Matthew Dillon <dillon@@backplane.com> for The DragonFly Project
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Random ip sequence number generator.  Use the system PRNG to shuffle
 * the 65536 entry ID space.  We reshuffle the ID we pick out of the array
 * into the previous 32767 cells, providing an guarantee that an ID will not
 * be reused for at least 32768 calls.
 */
#include <sys/param.h>
#include <sys/systm.h>

static u_int16_t ip_shuffle[65536];
static int isindex = 0;

u_int16_t ip_randomid(void);

/*
 * Return a random IP id.  Shuffle the new value we get into the previous half
 * of the ip_shuffle ring (-32767 or swap with ourself), to avoid duplicates
 * occuring too quickly but also still be random.
 *
 * 0 is a special IP ID -- don't return it.
 */
u_int16_t
ip_randomid(void)
{
	static int ipid_initialized;
	u_int16_t si, r;
	int i, i2;

	if (!ipid_initialized) {
		ipid_initialized = 1;

		/*
		 * Initialize with a random permutation. Do so using Knuth
		 * which avoids the exchange in the Durstenfeld shuffle.
		 * (See "The Art of Computer Programming, Vol 2" 3rd ed, pg. 145).
		 *
		 * Even if our PRNG is imperfect at boot time, we have deferred
		 * doing this until the first packet being sent and now must
		 * generate an ID.
		 */
		for (i = 0; i < nitems(ip_shuffle); ++i) {
			i2 = arc4random_uniform(i + 1);
			ip_shuffle[i] = ip_shuffle[i2];
			ip_shuffle[i2] = i;
		}
	}

	do {
		arc4random_buf(&si, sizeof(si));
		i = isindex & 0xFFFF;
		i2 = (isindex - (si & 0x7FFF)) & 0xFFFF;
		r = ip_shuffle[i];
		ip_shuffle[i] = ip_shuffle[i2];
		ip_shuffle[i2] = r;
		isindex++;
	} while (r == 0);

	return (r);
}
@


1.23
log
@- use nitems(); no binary change

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_id.c,v 1.22 2008/06/09 07:07:17 djm Exp $ */
d29 1
a29 1
#include <dev/rndvar.h>
@


1.22
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_id.c,v 1.21 2008/03/15 04:55:25 djm Exp $ */
d62 1
a62 1
		for (i = 0; i < sizeof(ip_shuffle)/sizeof(ip_shuffle[0]); ++i) {
@


1.21
log
@revert - I'm a dumbfuck who doesn't know his own API
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_id.c,v 1.19 2008/03/15 04:36:31 djm Exp $ */
d70 1
a70 1
		arc4random_bytes(&si, sizeof(si));
@


1.20
log
@off by one at end of array
@
text
@d62 1
a62 1
		for (i = 0; i < sizeof(ip_shuffle)/sizeof(*ip_shuffle)-1; ++i) {
@


1.19
log
@Because the ip_id code initialisation is a specific case of shuffling
a set of incrementing integers (and not an arbitrary set of values) it
is possible to populate the array as we shuffle it in a single forward
pass. Clever optimisation from didickman AT gmail.com;
ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_id.c,v 1.18 2008/03/02 21:38:18 deraadt Exp $ */
d62 1
a62 1
		for (i = 0; i < sizeof(ip_shuffle)/sizeof(ip_shuffle[0]); ++i) {
@


1.18
log
@because arc4random_uniform is being used, the modulo bias is taken care of
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_id.c,v 1.17 2008/03/02 21:29:07 djm Exp $ */
d54 7
a60 3
		 * Initialize using a Durstenfeld shuffle. Even if our PRNG
		 * is imperfect at boot time, we have deferred doing this until
		 * the first packet being sent and now must generate an ID.
d62 1
a62 3
		for (i = 0; i < sizeof(ip_shuffle)/sizeof(ip_shuffle[0]); ++i)
			ip_shuffle[i] = i;
		for (i = sizeof(ip_shuffle)/sizeof(ip_shuffle[0]); --i; ) {
a63 1
			r = ip_shuffle[i];
d65 1
a65 1
			ip_shuffle[i2] = r;
@


1.17
log
@Add a arc4random_uniform() that returns a uniformly distributed number
in the range 0 <= x < upper_bound

Please use this new API instead of "arc4random() % upper_bound", as it
avoids the "modulo bias" that favours small results when upper_bound is
not a power of two.

feedback deraadt@@ mcbride@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_id.c,v 1.16 2008/02/29 03:37:26 deraadt Exp $ */
a60 1
			/* disregard the modulo bias because it is small */
@


1.16
log
@replacement algorithm.  initialize a 64K-short buffer using Durstenfeld
shuffle. Upon allocation, swap-permute the new value to a random slot in
the 0..32K-1 th entry of the buffer as we move forward, ensuring randomness
but also satisfying the non-repeating property we need.  Also avoid the value
of 0, since IP ID's of 0 are special.  Inspired by Dillon's implementation.
We believe this is easier to read though, initializes with less bias, handles
the ID of 0 properly, and wins speed tests.
Thanks a lot to mcbride and djm for doing a bunch of statistical and speed
analysis, and comments from nordin
ok mcbride djm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_id.c,v 1.15 2007/11/26 09:28:33 martynas Exp $ */
d62 1
a62 1
			i2 = arc4random() % (i + 1);
@


1.15
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.14 2007/05/27 19:59:11 dlg Exp $ */
d4 16
a19 27
 * Copyright 1998 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Theo de Raadt <deraadt@@openbsd.org> came up with the idea of using
 * such a mathematical system to generate more random (yet non-repeating)
 * ids to solve the resolver/named problem.  But Niels designed the
 * actual system based on the constraints.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d23 4
a26 17
 * seed = random 15bit
 * n = prime, g0 = generator to n,
 * j = random so that gcd(j,n-1) == 1
 * g = g0^j mod n will be a generator again.
 *
 * X[0] = random seed.
 * X[n] = a*X[n-1]+b mod m is a Linear Congruential Generator
 * with a = 7^(even random) mod m,
 *      b = random with gcd(b,m) == 1
 *      m = 31104 and a maximal period of m-1.
 *
 * The transaction id is determined by:
 * id[n] = seed xor (g^X[n] mod n)
 *
 * Effectively the id is restricted to the lower 15 bits, thus
 * yielding two different cycles by toggling the msb on and off.
 * This avoids reuse issues caused by reseeding.
a27 1

a28 2
#include <sys/kernel.h>

d31 2
a32 22
#define RU_OUT  180		/* Time after wich will be reseeded */
#define RU_MAX	30000		/* Uniq cycle, avoid blackjack prediction */
#define RU_GEN	2		/* Starting generator */
#define RU_N	32749		/* RU_N-1 = 2*2*3*2729 */
#define RU_AGEN	7		/* determine ru_a as RU_AGEN^(2*rand) */
#define RU_M	31104		/* RU_M = 2^7*3^5 - don't change */

#define PFAC_N 3
const static u_int16_t pfacts[PFAC_N] = {
	2,
	3,
	2729
};

static u_int16_t ru_x;
static u_int16_t ru_seed, ru_seed2;
static u_int16_t ru_a, ru_b;
static u_int16_t ru_g;
static u_int16_t ru_counter = 0;
static u_int16_t ru_msb = 0;
static long ru_reseed;
static u_int32_t tmp;		/* Storage for unused random */
a33 2
u_int16_t pmod(u_int16_t, u_int16_t, u_int16_t);
void ip_initid(void);
d37 3
a39 26
 * Do a fast modular exponation, returned value will be in the range
 * of 0 - (mod-1)
 */

u_int16_t
pmod(u_int16_t gen, u_int16_t expo, u_int16_t mod)
{
	u_int16_t s, t, u;

	s = 1;
	t = gen;
	u = expo;

	while (u) {
		if (u & 1)
			s = (s*t) % mod;
		u >>= 1;
		t = (t*t) % mod;
	}
	return (s);
}

/*
 * Initializes the seed and chooses a suitable generator. Also toggles
 * the msb flag. The msb flag is used to generate two distinct
 * cycles of random numbers and thus avoiding reuse of ids.
d41 1
a41 2
 * This function is called from id_randomid() when needed, an
 * application does not have to worry about it.
a42 45
void
ip_initid(void)
{
	u_int16_t j, i;
	int noprime = 1;

	ru_x = ((tmp = arc4random()) & 0xFFFF) % RU_M;

	/* 15 bits of random seed */
	ru_seed = (tmp >> 16) & 0x7FFF;
	ru_seed2 = arc4random() & 0x7FFF;

	/* Determine the LCG we use */
	ru_b = ((tmp = arc4random()) & 0xfffe) | 1;
	ru_a = pmod(RU_AGEN, (tmp >> 16) & 0xfffe, RU_M);
	while (ru_b % 3 == 0)
		ru_b += 2;

	j = (tmp = arc4random()) % RU_N;
	tmp = tmp >> 16;

	/*
	 * Do a fast gcd(j,RU_N-1), so we can find a j with
	 * gcd(j, RU_N-1) == 1, giving a new generator for
	 * RU_GEN^j mod RU_N
	 */

	while (noprime) {
		for (i = 0; i < PFAC_N; i++)
			if (j % pfacts[i] == 0)
				break;

		if (i >= PFAC_N)
			noprime = 0;
		else
			j = (j+1) % RU_N;
	}

	ru_g = pmod(RU_GEN,j,RU_N);
	ru_counter = 0;

	ru_reseed = time_second + RU_OUT;
	ru_msb = ru_msb == 0x8000 ? 0 : 0x8000;
}

d46 22
a67 20
	int i, n;

	if (ru_counter >= RU_MAX || time_second > ru_reseed)
		ip_initid();

#if 0
	if (!tmp)
		tmp = arc4random();

	/* Skip a random number of ids */
	n = tmp & 0x3; tmp = tmp >> 2;
	if (ru_counter + n >= RU_MAX)
		ip_initid();
#else
	n = 0;
#endif

	for (i = 0; i <= n; i++)
		/* Linear Congruential Generator */
		ru_x = (ru_a * ru_x + ru_b) % RU_M;
d69 9
a77 1
	ru_counter += i;
d79 1
a79 1
	return (ru_seed ^ pmod(ru_g,ru_seed2 + ru_x, RU_N)) | ru_msb;
@


1.14
log
@remove more static to avoid confusing the profiler (and maybe ddb too)

prodded by art@@ ja ja claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.13 2004/06/21 23:50:37 tholo Exp $ */
d109 1
a109 1
 * Initalizes the seed and chooses a suitable generator. Also toggles
@


1.13
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.12 2004/03/22 04:37:20 deraadt Exp $ */
d81 2
a82 2
static u_int16_t pmod(u_int16_t, u_int16_t, u_int16_t);
static void ip_initid(void);
d90 1
a90 1
static u_int16_t
d116 1
a116 1
static void
@


1.12
log
@spelling; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.11 2003/12/12 06:57:12 itojun Exp $ */
d157 1
a157 1
	ru_reseed = time.tv_sec + RU_OUT;
d166 1
a166 1
	if (ru_counter >= RU_MAX || time.tv_sec > ru_reseed)
@


1.11
log
@niels kindly dropped clause 3/4 from the license.  tnx!
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.10 2003/12/12 02:50:44 itojun Exp $ */
d48 1
a48 1
 * Effectivly the id is restricted to the lower 15 bits, thus
@


1.10
log
@previous commit included bad hunk.  sorry
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.9 2003/12/12 02:03:27 itojun Exp $ */
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@no need to call arc4random() if we don't skip numbers in ip_randomid().
from markus
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.8 2003/12/10 07:21:00 itojun Exp $ */
d78 1
a78 1
static u_int16_t ru_seed;
d131 1
@


1.8
log
@correct non-repetitive ID code, based on comments from niels provos.
- seed2 is necessary, but use it as "seed2 + x" not "seed2 ^ x".
- skipping number is not needed, so disable it for 16bit generator (makes
  the repetition period to 30000)
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.7 2003/09/21 04:06:39 itojun Exp $ */
d78 1
a78 1
static u_int16_t ru_seed, ru_seed2;
a130 1
	ru_seed2 = arc4random() & 0x7FFF;
d173 1
a176 1
#if 0
@


1.7
log
@"exp" is a reserved symbol under gcc3/posix.  mcbride ok
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.6 2002/03/15 18:19:52 millert Exp $ */
d177 1
d182 3
d192 1
a192 1
	return (ru_seed ^ pmod(ru_g,ru_seed2 ^ ru_x,RU_N)) | ru_msb;
@


1.6
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.5 2002/03/14 01:27:11 millert Exp $ */
d96 1
a96 1
pmod(u_int16_t gen, u_int16_t exp, u_int16_t mod)
d102 1
a102 1
	u = exp;
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.4 2001/06/08 03:53:46 angelos Exp $ */
a94 1
#ifdef __STDC__
a96 5
#else
static u_int16_t
pmod(gen, exp, mod)
	u_int16_t gen, exp, mod;
#endif
@


1.4
log
@Cut down on include files.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.3 2001/06/04 19:57:22 mickey Exp $ */
d86 3
a88 3
static u_int16_t pmod __P((u_int16_t, u_int16_t, u_int16_t));
static void ip_initid __P((void));
u_int16_t ip_randomid __P((void));
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.4 2001/06/08 03:53:46 angelos Exp $ */
d86 3
a88 3
static u_int16_t pmod(u_int16_t, u_int16_t, u_int16_t);
static void ip_initid(void);
u_int16_t ip_randomid(void);
d95 1
d98 5
@


1.3
log
@use faster arc4random() for small amounts fo data, some spaces; niels ok
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.2 1999/08/26 13:37:01 provos Exp $ */
a58 1
#include <sys/time.h>
@


1.2
log
@add an inner xor to make prediction attacks against the ids harder, due
to an attack pointed out by David Wagner.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.1 1998/12/26 12:35:12 provos Exp $ */
d38 1
a38 1
/* 
d46 1
a46 1
 * with a = 7^(even random) mod m, 
d64 1
a64 1
#define RU_OUT  180             /* Time after wich will be reseeded */
d68 2
a69 2
#define RU_AGEN	7               /* determine ru_a as RU_AGEN^(2*rand) */
#define RU_M	31104           /* RU_M = 2^7*3^5 - don't change */
d73 1
a73 1
	2, 
d85 1
a85 1
static u_int32_t tmp;                /* Storage for unused random */
d120 2
a121 2
/* 
 * Initalizes the seed and chooses a suitable generator. Also toggles 
d125 1
a125 1
 * This function is called from id_randomid() when needed, an 
d128 1
a128 1
static void 
d134 1
a134 2
	get_random_bytes((void *) &tmp, sizeof(tmp));
	ru_x = (tmp & 0xFFFF) % RU_M;
d138 1
a138 4
	get_random_bytes((void *) &tmp, sizeof(tmp));
	ru_seed2 = tmp & 0x7FFF;

	get_random_bytes((void *) &tmp, sizeof(tmp));
d141 1
a141 1
	ru_b = (tmp & 0xfffe) | 1;
d144 3
a146 4
	  ru_b += 2;
	
	get_random_bytes((void *) &tmp, sizeof(tmp));
	j = tmp % RU_N;
d149 1
a149 1
	/* 
d156 2
a157 2
		for (i=0; i<PFAC_N; i++)
			if (j%pfacts[i] == 0)
d160 1
a160 1
		if (i>=PFAC_N)
d162 1
a162 1
		else 
d170 1
a170 1
	ru_msb = ru_msb == 0x8000 ? 0 : 0x8000; 
d176 1
a176 1
        int i, n;
d182 1
a182 1
		get_random_bytes((void *) &tmp, sizeof(tmp));
d187 1
a187 1
                ip_initid();
d190 2
a191 2
	        /* Linear Congruential Generator */
	        ru_x = (ru_a*ru_x + ru_b) % RU_M;
@


1.2.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_id.c,v 1.2 1999/08/26 13:37:01 provos Exp $ */
d38 1
a38 1
/*
d46 1
a46 1
 * with a = 7^(even random) mod m,
d59 1
d64 1
a64 1
#define RU_OUT  180		/* Time after wich will be reseeded */
d68 2
a69 2
#define RU_AGEN	7		/* determine ru_a as RU_AGEN^(2*rand) */
#define RU_M	31104		/* RU_M = 2^7*3^5 - don't change */
d73 1
a73 1
	2,
d85 1
a85 1
static u_int32_t tmp;		/* Storage for unused random */
d120 2
a121 2
/*
 * Initalizes the seed and chooses a suitable generator. Also toggles
d125 1
a125 1
 * This function is called from id_randomid() when needed, an
d128 1
a128 1
static void
d134 2
a135 1
	ru_x = ((tmp = arc4random()) & 0xFFFF) % RU_M;
d139 4
a142 1
	ru_seed2 = arc4random() & 0x7FFF;
d145 1
a145 1
	ru_b = ((tmp = arc4random()) & 0xfffe) | 1;
d148 4
a151 3
		ru_b += 2;

	j = (tmp = arc4random()) % RU_N;
d154 1
a154 1
	/*
d161 2
a162 2
		for (i = 0; i < PFAC_N; i++)
			if (j % pfacts[i] == 0)
d165 1
a165 1
		if (i >= PFAC_N)
d167 1
a167 1
		else
d175 1
a175 1
	ru_msb = ru_msb == 0x8000 ? 0 : 0x8000;
d181 1
a181 1
	int i, n;
d187 1
a187 1
		tmp = arc4random();
d192 1
a192 1
		ip_initid();
d195 2
a196 2
		/* Linear Congruential Generator */
		ru_x = (ru_a * ru_x + ru_b) % RU_M;
@


1.2.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d86 3
a88 3
static u_int16_t pmod(u_int16_t, u_int16_t, u_int16_t);
static void ip_initid(void);
u_int16_t ip_randomid(void);
d95 1
d98 5
@


1.2.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d20 5
d96 1
a96 1
pmod(u_int16_t gen, u_int16_t expo, u_int16_t mod)
d102 1
a102 1
	u = expo;
a173 1
#if 0
a180 3
#else
	n = 0;
#endif
d188 1
a188 1
	return (ru_seed ^ pmod(ru_g,ru_seed2 + ru_x, RU_N)) | ru_msb;
@


1.2.4.4
log
@Merge with the trunk
@
text
@d48 1
a48 1
 * Effectively the id is restricted to the lower 15 bits, thus
@


1.1
log
@make ip_id random but ensure that ids dont repeat for some period.
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.7 1997/07/25 20:30:08 mickey Exp $ */
d79 1
a79 1
static u_int16_t ru_seed;
d139 2
d200 1
a200 1
	return (ru_seed ^ pmod(ru_g,ru_x,RU_N)) | ru_msb;
@

