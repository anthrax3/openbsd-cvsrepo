head	1.55;
access;
symbols
	OPENBSD_6_0:1.44.0.8
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	UBC_SYNC_B:1.9
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.55
date	2017.02.17.14.49.03;	author bluhm;	state Exp;
branches;
next	1.54;
commitid	QKiswVgKhevSzhnN;

1.54
date	2017.02.09.00.43.58;	author bluhm;	state Exp;
branches;
next	1.53;
commitid	1tp8P9UZgQI9hvVk;

1.53
date	2017.02.07.18.18.16;	author bluhm;	state Exp;
branches;
next	1.52;
commitid	d6u53XQpFaxImDPZ;

1.52
date	2017.02.07.17.25.46;	author patrick;	state Exp;
branches;
next	1.51;
commitid	dMJlqKWYCJoMV7JN;

1.51
date	2017.02.07.15.10.48;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	7vg8X7gfUc0w7Qc8;

1.50
date	2017.01.09.17.56.37;	author visa;	state Exp;
branches;
next	1.49;
commitid	gOVNRJbv3PaOxKMO;

1.49
date	2016.12.24.11.17.35;	author mpi;	state Exp;
branches;
next	1.48;
commitid	iyPxPn1zFcxxUjDC;

1.48
date	2016.09.24.14.51.37;	author naddy;	state Exp;
branches;
next	1.47;
commitid	B9MFucENkVbjvRxm;

1.47
date	2016.09.13.19.56.55;	author markus;	state Exp;
branches;
next	1.46;
commitid	MhzOL3PcQJk4ZhiI;

1.46
date	2016.08.18.06.01.10;	author dlg;	state Exp;
branches;
next	1.45;
commitid	sj9BHgtTdUyjSwjG;

1.45
date	2016.08.15.11.35.25;	author dlg;	state Exp;
branches;
next	1.44;
commitid	CgCan1eMToI9G3qa;

1.44
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	ncpqEGjDtSFuLAgn;

1.43
date	2015.06.15.13.26.48;	author mikeb;	state Exp;
branches;
next	1.42;
commitid	yrlpywXU7XivLY49;

1.42
date	2015.04.17.11.04.01;	author mikeb;	state Exp;
branches;
next	1.41;
commitid	6glXvFR7NxzCcdRd;

1.41
date	2015.04.14.14.20.01;	author mikeb;	state Exp;
branches;
next	1.40;
commitid	70u0dWUlToMcLCnj;

1.40
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.39;
commitid	p4LJxGKbi0BU2cG6;

1.39
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.38;
commitid	zhW8jJrfVCoAthrR;

1.38
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.37;
commitid	t9FBKDfc4VDxpEy2;

1.37
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.36;
commitid	Z1vcFtHO8wRH0yRt;

1.36
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.35;
commitid	DQakU8LLWV6Iwx84;

1.35
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.34;
commitid	B4dZSbxas1X1IpXI;

1.34
date	2014.07.09.09.30.49;	author henning;	state Exp;
branches;
next	1.33;
commitid	Nnxg8ONtI4Ep9pUb;

1.33
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2013.05.14.14.29.08;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2013.04.11.12.06.25;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2013.02.14.16.22.34;	author mikeb;	state Exp;
branches;
next	1.29;

1.29
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.07.02.57.25;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.29.21.28.37;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2008.09.15.21.46.01;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.06.02.18.38;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.20.13.36.28;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.31.03.52.19;	author pascoe;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.25.21.54.54;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.26.17.34.16;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.14.19.00.12;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.02.20.09.26;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.31.20.52.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.31.17.16.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.18.18.47.40;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.12.10.11.39;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.05.23.20.53;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.20.03.49.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.18.23.06.57;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.18.22.48.16;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.18.22.26.12;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.18.19.28.05;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.05.12.08.52;	author jjbg;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Using ipcomp(4) with IPv6 transport mode failed with protocol family
not supported.  A break in the af switch statement was missing since
revision 1.1 from 2001.
OK visa@@ deraadt@@
@
text
@/* $OpenBSD: ip_ipcomp.c,v 1.54 2017/02/09 00:43:58 bluhm Exp $ */

/*
 * Copyright (c) 2001 Jean-Jacques Bernard-Gundol (jj@@wabbitt.org)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* IP payload compression protocol (IPComp), see RFC 2393 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif				/* INET6 */

#include <netinet/ip_ipsp.h>
#include <netinet/ip_ipcomp.h>
#include <net/pfkeyv2.h>
#include <net/if_enc.h>

#include <crypto/cryptodev.h>
#include <crypto/xform.h>

#include "bpfilter.h"

void ipcomp_output_cb(struct cryptop *);
void ipcomp_input_cb(struct cryptop *);

#ifdef ENCDEBUG
#define DPRINTF(x)      if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

struct ipcompstat ipcompstat;

/*
 * ipcomp_attach() is called from the transformation code
 */
int
ipcomp_attach(void)
{
	return 0;
}

/*
 * ipcomp_init() is called when an CPI is being set up.
 */
int
ipcomp_init(struct tdb *tdbp, struct xformsw *xsp, struct ipsecinit *ii)
{
	struct comp_algo *tcomp = NULL;
	struct cryptoini cric;

	switch (ii->ii_compalg) {
	case SADB_X_CALG_DEFLATE:
		tcomp = &comp_algo_deflate;
		break;
	case SADB_X_CALG_LZS:
		tcomp = &comp_algo_lzs;
		break;

	default:
		DPRINTF(("ipcomp_init(): unsupported compression algorithm %d specified\n",
		    ii->ii_compalg));
		return EINVAL;
	}

	tdbp->tdb_compalgxform = tcomp;

	DPRINTF(("ipcomp_init(): initialized TDB with ipcomp algorithm %s\n",
	    tcomp->name));

	tdbp->tdb_xform = xsp;

	/* Initialize crypto session */
	memset(&cric, 0, sizeof(cric));
	cric.cri_alg = tdbp->tdb_compalgxform->type;

	return crypto_newsession(&tdbp->tdb_cryptoid, &cric, 0);
}

/*
 * ipcomp_zeroize() used when IPCA is deleted
 */
int
ipcomp_zeroize(struct tdb *tdbp)
{
	int err;

	err = crypto_freesession(tdbp->tdb_cryptoid);
	tdbp->tdb_cryptoid = 0;
	return err;
}

/*
 * ipcomp_input() gets called to uncompress an input packet
 */
int
ipcomp_input(struct mbuf *m, struct tdb *tdb, int skip, int protoff)
{
	struct comp_algo *ipcompx = (struct comp_algo *) tdb->tdb_compalgxform;
	struct tdb_crypto *tc;
	int hlen;

	struct cryptodesc *crdc = NULL;
	struct cryptop *crp;

	hlen = IPCOMP_HLENGTH;

	/* Get crypto descriptors */
	crp = crypto_getreq(1);
	if (crp == NULL) {
		m_freem(m);
		DPRINTF(("ipcomp_input(): failed to acquire crypto descriptors\n"));
		ipcompstat.ipcomps_crypto++;
		return ENOBUFS;
	}
	/* Get IPsec-specific opaque pointer */
	tc = malloc(sizeof(*tc), M_XDATA, M_NOWAIT | M_ZERO);
	if (tc == NULL) {
		m_freem(m);
		crypto_freereq(crp);
		DPRINTF(("ipcomp_input(): failed to allocate tdb_crypto\n"));
		ipcompstat.ipcomps_crypto++;
		return ENOBUFS;
	}
	crdc = &crp->crp_desc[0];

	crdc->crd_skip = skip + hlen;
	crdc->crd_len = m->m_pkthdr.len - (skip + hlen);
	crdc->crd_inject = skip;

	/* Decompression operation */
	crdc->crd_alg = ipcompx->type;

	/* Crypto operation descriptor */
	crp->crp_ilen = m->m_pkthdr.len - (skip + hlen);
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t)m;
	crp->crp_callback = ipcomp_input_cb;
	crp->crp_sid = tdb->tdb_cryptoid;
	crp->crp_opaque = (caddr_t)tc;

	/* These are passed as-is to the callback */
	tc->tc_skip = skip;
	tc->tc_protoff = protoff;
	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = IPPROTO_IPCOMP;
	tc->tc_rdomain = tdb->tdb_rdomain;
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

	return crypto_dispatch(crp);
}

/*
 * IPComp input callback, called directly by the crypto driver
 */
void
ipcomp_input_cb(struct cryptop *crp)
{
	int s, skip, protoff, roff, hlen = IPCOMP_HLENGTH, clen;
	u_int8_t nproto;
	struct mbuf *m, *m1, *mo;
	struct tdb_crypto *tc;
	struct tdb *tdb;
	struct ipcomp  *ipcomp;
	caddr_t addr;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	tc = (struct tdb_crypto *) crp->crp_opaque;
	skip = tc->tc_skip;
	protoff = tc->tc_protoff;

	m = (struct mbuf *) crp->crp_buf;
	if (m == NULL) {
		/* Shouldn't happen... */
		free(tc, M_XDATA, 0);
		crypto_freereq(crp);
		ipcompstat.ipcomps_crypto++;
		DPRINTF(("ipcomp_input_cb(): bogus returned buffer from crypto\n"));
		return;
	}

	NET_LOCK(s);

	tdb = gettdb(tc->tc_rdomain, tc->tc_spi, &tc->tc_dst, tc->tc_proto);
	if (tdb == NULL) {
		free(tc, M_XDATA, 0);
		ipcompstat.ipcomps_notdb++;
		DPRINTF(("ipcomp_input_cb(): TDB expired while in crypto"));
		goto baddone;
	}

	/* update the counters */
	tdb->tdb_cur_bytes += m->m_pkthdr.len - (skip + hlen);
	ipcompstat.ipcomps_ibytes += m->m_pkthdr.len - (skip + hlen);

	/* Hard expiration */
	if ((tdb->tdb_flags & TDBF_BYTES) &&
	    (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)) {
		free(tc, M_XDATA, 0);
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
		goto baddone;
	}
	/* Notify on soft expiration */
	if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	    (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES;	/* Turn off checking */
	}

	/* Check for crypto errors */
	if (crp->crp_etype) {
		if (crp->crp_etype == EAGAIN) {
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
			NET_UNLOCK(s);
			crypto_dispatch(crp);
			return;
		}
		free(tc, M_XDATA, 0);
		ipcompstat.ipcomps_noxform++;
		DPRINTF(("ipcomp_input_cb(): crypto error %d\n",
		    crp->crp_etype));
		goto baddone;
	}
	free(tc, M_XDATA, 0);

	/* Length of data after processing */
	clen = crp->crp_olen;

	/* In case it's not done already, adjust the size of the mbuf chain */
	m->m_pkthdr.len = clen + hlen + skip;

	if ((m->m_len < skip + hlen) && (m = m_pullup(m, skip + hlen)) == 0) {
		goto baddone;
	}

	/* Find the beginning of the IPCOMP header */
	m1 = m_getptr(m, skip, &roff);
	if (m1 == NULL) {
		ipcompstat.ipcomps_hdrops++;
		DPRINTF(("ipcomp_input_cb(): bad mbuf chain, IPCA %s/%08x\n",
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		goto baddone;
	}
	/* Keep the next protocol field */
	addr = (caddr_t) mtod(m, struct ip *) + skip;
	ipcomp = (struct ipcomp *) addr;
	nproto = ipcomp->ipcomp_nh;

	/* Remove the IPCOMP header from the mbuf */
	if (roff == 0) {
		/* The IPCOMP header is at the beginning of m1 */
		m_adj(m1, hlen);
		if (!(m1->m_flags & M_PKTHDR))
			m->m_pkthdr.len -= hlen;
	} else if (roff + hlen >= m1->m_len) {
		if (roff + hlen > m1->m_len) {
			/* Adjust the next mbuf by the remainder */
			m_adj(m1->m_next, roff + hlen - m1->m_len);

			/*
			 * The second mbuf is guaranteed not to have a
			 * pkthdr...
			 */
			m->m_pkthdr.len -= (roff + hlen - m1->m_len);
		}
		/* Now, let's unlink the mbuf chain for a second... */
		mo = m1->m_next;
		m1->m_next = NULL;

		/* ...and trim the end of the first part of the chain...sick */
		m_adj(m1, -(m1->m_len - roff));
		if (!(m1->m_flags & M_PKTHDR))
			m->m_pkthdr.len -= (m1->m_len - roff);

		/* Finally, let's relink */
		m1->m_next = mo;
	} else {
		bcopy(mtod(m1, u_char *) + roff + hlen,
		    mtod(m1, u_char *) + roff,
		    m1->m_len - (roff + hlen));
		m1->m_len -= hlen;
		m->m_pkthdr.len -= hlen;
	}

	/* Release the crypto descriptors */
	crypto_freereq(crp);

	/* Restore the Next Protocol field */
	m_copyback(m, protoff, sizeof(u_int8_t), &nproto, M_NOWAIT);

	/* Back to generic IPsec input processing */
	ipsec_common_input_cb(m, tdb, skip, protoff);
	NET_UNLOCK(s);
	return;

baddone:
	NET_UNLOCK(s);

	m_freem(m);

	crypto_freereq(crp);
}

/*
 * IPComp output routine, called by ipsp_process_packet()
 */
int
ipcomp_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
    int protoff)
{
	struct comp_algo *ipcompx = (struct comp_algo *) tdb->tdb_compalgxform;
	int             hlen;
	struct cryptodesc *crdc = NULL;
	struct cryptop *crp;
	struct tdb_crypto *tc;
	struct mbuf    *mi;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif
#if NBPFILTER > 0
	struct ifnet *encif;

	if ((encif = enc_getif(0, tdb->tdb_tap)) != NULL) {
		encif->if_opackets++;
		encif->if_obytes += m->m_pkthdr.len;

		if (encif->if_bpf) {
			struct enchdr hdr;

			memset(&hdr, 0, sizeof(hdr));

			hdr.af = tdb->tdb_dst.sa.sa_family;
			hdr.spi = tdb->tdb_spi;

			bpf_mtap_hdr(encif->if_bpf, (char *)&hdr,
			    ENC_HDRLEN, m, BPF_DIRECTION_OUT, NULL);
		}
	}
#endif
	hlen = IPCOMP_HLENGTH;

	ipcompstat.ipcomps_output++;

	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		/* Check for IPv4 maximum packet size violations */
		/*
		 * Since compression is going to reduce the size, no need to
		 * worry
		 */
		if (m->m_pkthdr.len + hlen > IP_MAXPACKET) {
			DPRINTF(("ipcomp_output(): packet in IPCA %s/%08x "
			    "got too big\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			m_freem(m);
			ipcompstat.ipcomps_toobig++;
			return EMSGSIZE;
		}
		break;

#ifdef INET6
	case AF_INET6:
		/* Check for IPv6 maximum packet size violations */
		if (m->m_pkthdr.len + hlen > IPV6_MAXPACKET) {
			DPRINTF(("ipcomp_output(): packet in IPCA %s/%08x "
			    "got too big\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			m_freem(m);
			ipcompstat.ipcomps_toobig++;
			return EMSGSIZE;
		}
		break;
#endif /* INET6 */

	default:
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol "
		    "family %d, IPCA %s/%08x\n", tdb->tdb_dst.sa.sa_family,
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		m_freem(m);
		ipcompstat.ipcomps_nopf++;
		return EPFNOSUPPORT;
	}

	/* Update the counters */

	tdb->tdb_cur_bytes += m->m_pkthdr.len - skip;
	ipcompstat.ipcomps_obytes += m->m_pkthdr.len - skip;

	/* Hard byte expiration */
	if ((tdb->tdb_flags & TDBF_BYTES) &&
	    (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes)) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
		m_freem(m);
		return EINVAL;
	}
	/* Soft byte expiration */
	if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	    (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES;	/* Turn off checking */
	}
	/*
	 * Loop through mbuf chain; if we find a readonly mbuf,
	 * copy the packet.
	 */
	mi = m;
	while (mi != NULL && !M_READONLY(mi))
		mi = mi->m_next;

	if (mi != NULL) {
		struct mbuf *n = m_dup_pkt(m, 0, M_DONTWAIT);

		if (n == NULL) {
			DPRINTF(("ipcomp_output(): bad mbuf chain, IPCA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			ipcompstat.ipcomps_hdrops++;
			m_freem(m);
			return ENOBUFS;
		}

		m_freem(m);
		m = n;
	}
	/* Ok now, we can pass to the crypto processing */

	/* Get crypto descriptors */
	crp = crypto_getreq(1);
	if (crp == NULL) {
		m_freem(m);
		DPRINTF(("ipcomp_output(): failed to acquire crypto descriptors\n"));
		ipcompstat.ipcomps_crypto++;
		return ENOBUFS;
	}
	crdc = &crp->crp_desc[0];

	/* Compression descriptor */
	crdc->crd_skip = skip;
	crdc->crd_len = m->m_pkthdr.len - skip;
	crdc->crd_flags = CRD_F_COMP;
	crdc->crd_inject = skip;

	/* Compression operation */
	crdc->crd_alg = ipcompx->type;

	/* IPsec-specific opaque crypto info */
	tc = malloc(sizeof(*tc), M_XDATA, M_NOWAIT | M_ZERO);
	if (tc == NULL) {
		m_freem(m);
		crypto_freereq(crp);
		DPRINTF(("ipcomp_output(): failed to allocate tdb_crypto\n"));
		ipcompstat.ipcomps_crypto++;
		return ENOBUFS;
	}

	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = tdb->tdb_sproto;
	tc->tc_skip = skip;
	tc->tc_rdomain = tdb->tdb_rdomain;
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

	/* Crypto operation descriptor */
	crp->crp_ilen = m->m_pkthdr.len;	/* Total input length */
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t)m;
	crp->crp_callback = ipcomp_output_cb;
	crp->crp_opaque = (caddr_t)tc;
	crp->crp_sid = tdb->tdb_cryptoid;

	return crypto_dispatch(crp);
}

/*
 * IPComp output callback, called directly from the crypto driver
 */
void
ipcomp_output_cb(struct cryptop *crp)
{
	struct tdb_crypto *tc;
	struct tdb *tdb;
	struct mbuf *m, *mo;
	int s, skip, rlen, roff;
	u_int16_t cpi;
	struct ip *ip;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif
	struct ipcomp  *ipcomp;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	tc = (struct tdb_crypto *) crp->crp_opaque;
	skip = tc->tc_skip;
	rlen = crp->crp_ilen - skip;

	m = (struct mbuf *) crp->crp_buf;
	if (m == NULL) {
		/* Shouldn't happen... */
		free(tc, M_XDATA, 0);
		crypto_freereq(crp);
		ipcompstat.ipcomps_crypto++;
		DPRINTF(("ipcomp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		return;
	}

	NET_LOCK(s);

	tdb = gettdb(tc->tc_rdomain, tc->tc_spi, &tc->tc_dst, tc->tc_proto);
	if (tdb == NULL) {
		free(tc, M_XDATA, 0);
		ipcompstat.ipcomps_notdb++;
		DPRINTF(("ipcomp_output_cb(): TDB expired while in crypto\n"));
		goto baddone;
	}

	/* Check for crypto errors. */
	if (crp->crp_etype) {
		if (crp->crp_etype == EAGAIN) {
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
			NET_UNLOCK(s);
			crypto_dispatch(crp);
			return;
		}
		free(tc, M_XDATA, 0);
		ipcompstat.ipcomps_noxform++;
		DPRINTF(("ipcomp_output_cb(): crypto error %d\n",
		    crp->crp_etype));
		goto baddone;
	}
	free(tc, M_XDATA, 0);

	/* Check sizes. */
	if (rlen < crp->crp_olen) {
		/* Compression was useless, we have lost time. */
		crypto_freereq(crp);
		if (ipsp_process_done(m, tdb))
			ipcompstat.ipcomps_outfail++;
		NET_UNLOCK(s);
		return;
	}

	/* Inject IPCOMP header */
	mo = m_makespace(m, skip, IPCOMP_HLENGTH, &roff);
	if (mo == NULL) {
		DPRINTF(("ipcomp_output_cb(): failed to inject IPCOMP header "
		    "for IPCA %s/%08x\n", ipsp_address(&tdb->tdb_dst, buf,
		     sizeof(buf)), ntohl(tdb->tdb_spi)));
		ipcompstat.ipcomps_wrap++;
		goto baddone;
	}

	/* Initialize the IPCOMP header */
	ipcomp = (struct ipcomp *)(mtod(mo, caddr_t) + roff);
	memset(ipcomp, 0, sizeof(struct ipcomp));
	cpi = (u_int16_t) ntohl(tdb->tdb_spi);
	ipcomp->ipcomp_cpi = htons(cpi);

	/* m_pullup before ? */
	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		ip = mtod(m, struct ip *);
		ipcomp->ipcomp_nh = ip->ip_p;
		ip->ip_p = IPPROTO_IPCOMP;
		break;
#ifdef INET6
	case AF_INET6:
		ip6 = mtod(m, struct ip6_hdr *);
		ipcomp->ipcomp_nh = ip6->ip6_nxt;
		ip6->ip6_nxt = IPPROTO_IPCOMP;
		break;
#endif
	default:
		DPRINTF(("ipcomp_output_cb(): unsupported protocol family %d, "
		    "IPCA %s/%08x\n", tdb->tdb_dst.sa.sa_family,
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		ipcompstat.ipcomps_nopf++;
		goto baddone;
		break;
	}

	/* Release the crypto descriptor. */
	crypto_freereq(crp);

	if (ipsp_process_done(m, tdb))
		ipcompstat.ipcomps_outfail++;
	NET_UNLOCK(s);
	return;

baddone:
	NET_UNLOCK(s);

	m_freem(m);

	crypto_freereq(crp);
}
@


1.54
log
@Put back a return that I have removed by accident.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.53 2017/02/07 18:18:16 bluhm Exp $ */
d414 1
@


1.53
log
@IPsec packets could be dropped unaccounted if output after crypto
failed.  Add a counter for that case.
OK dhill@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.52 2017/02/07 17:25:46 patrick Exp $ */
d336 1
@


1.52
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.51 2017/02/07 15:10:48 bluhm Exp $ */
d582 2
a583 2
		ipsp_process_done(m, tdb);
		/* XXX missing counter if ipsp_process_done() drops packet */
d631 2
a632 2
	ipsp_process_done(m, tdb);
	/* XXX missing error counter if ipsp_process_done() drops packet */
@


1.51
log
@The return code of crp_callback is never checked, so it is not
useful to propagate the error.  When an error occurs in an asynchronous
network path, incrementing a counter is the right thing.  There are
four places where an error is not accounted, just add a comment for
now.
OK mpi@@ visa@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.50 2017/01/09 17:56:37 visa Exp $ */
d161 1
a161 1
	crdc = crp->crp_desc;
d477 1
a477 1
	crdc = crp->crp_desc;
@


1.50
log
@Grab the NET_LOCK() in ipcomp input callback.

OK mikeb@@ mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.49 2016/12/24 11:17:35 mpi Exp $ */
d59 2
a60 2
int ipcomp_output_cb(struct cryptop *);
int ipcomp_input_cb(struct cryptop *);
d192 1
a192 1
int
d195 1
a195 1
	int error, s, skip, protoff, roff, hlen = IPCOMP_HLENGTH, clen;
d217 1
a217 1
		return (EINVAL);
a226 1
		error = EPERM;
a239 1
		error = ENXIO;
d256 2
a257 1
			return crypto_dispatch(crp);
a262 1
		error = crp->crp_etype;
a273 1
		error = ENOBUFS;
a283 1
		error = EINVAL;
d334 1
a334 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff);
a335 1
	return error;
a342 2

	return error;
d518 1
a518 1
int
d524 1
a524 1
	int error, s, skip, rlen, roff;
d547 1
a547 1
		return (EINVAL);
a556 1
		error = EPERM;
d567 2
a568 1
			return crypto_dispatch(crp);
a573 1
		error = crp->crp_etype;
d582 2
a583 1
		error = ipsp_process_done(m, tdb);
d585 1
a585 1
		return error;
a594 1
		error = ENOBUFS;
a623 1
		error = EPFNOSUPPORT;
d631 2
a632 1
	error = ipsp_process_done(m, tdb);
d634 1
a634 1
	return error;
a641 2

	return error;
@


1.49
log
@Grab the NET_LOCK() before calling ipsp_process_done() as it ends up
in ip_output().

Found the hardway by and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.48 2016/09/24 14:51:37 naddy Exp $ */
d220 1
a220 1
	s = splsoftnet();
d257 1
a257 1
			splx(s);
d339 1
a339 1
	splx(s);
d343 1
a343 1
	splx(s);
@


1.48
log
@ANSIfy netinet/; from David Hill
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.47 2016/09/13 19:56:55 markus Exp $ */
d557 1
a557 1
	s = splsoftnet();
d574 1
a574 1
			splx(s);
d591 1
a591 1
		splx(s);
d641 1
a641 1
	splx(s);
d645 1
a645 1
	splx(s);
@


1.47
log
@avoid extensive mbuf allocation for IPsec by replacing m_inject(4)
with m_makespace(4) from freebsd; ok mpi@@, bluhm@@, mikeb@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.46 2016/08/18 06:01:10 dlg Exp $ */
d83 1
a83 4
ipcomp_init(tdbp, xsp, ii)
	struct tdb     *tdbp;
	struct xformsw *xsp;
	struct ipsecinit *ii;
d120 1
a120 2
ipcomp_zeroize(tdbp)
	struct tdb *tdbp;
d133 1
a133 5
ipcomp_input(m, tdb, skip, protoff)
	struct mbuf    *m;
	struct tdb     *tdb;
	int             skip;
	int             protoff;
d356 2
a357 6
ipcomp_output(m, tdb, mp, skip, protoff)
	struct mbuf    *m;
	struct tdb     *tdb;
	struct mbuf   **mp;
	int             skip;
	int             protoff;
@


1.46
log
@fix panics caused by replacing m_copym2 with m_dup_pkt.

m_copym2 is fine duplicating an arbitrary chain of mbufs, while
m_dup_pkt wants to dup a packet with proper headers in the first
mbuf. ipsec copied the tail of an mbuf if any of the clusters are
shared or readonly, and swapped that tail with the result of m_copym2.

m_dup_pkt panics cos of that.

this makes ipsec duplicate the whole packet if any of the chain is
readonly.

found by naddy@@ and mlarkin@@
this fix is from visa@@ who told me to commit it cos he's afk (sleeping)
tested by naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.45 2016/08/15 11:35:25 dlg Exp $ */
d543 1
a543 1
	int error, s, skip, rlen;
d608 1
a608 1
	mo = m_inject(m, skip, IPCOMP_HLENGTH, M_DONTWAIT);
d619 1
a619 1
	ipcomp = mtod(mo, struct ipcomp *);
@


1.45
log
@replace the last uses of m_copym2 with m_dup_pkt.

ok mpi@@ visa@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.44 2015/07/15 22:16:42 deraadt Exp $ */
d376 1
a376 1
	struct mbuf    *mi, *mo;
d465 1
a465 1
	 * replace the rest of the chain.
a466 1
	mo = NULL;
d468 1
a468 2
	while (mi != NULL && !M_READONLY(mi)) {
		mo = mi;
a469 1
	}
d472 1
a472 2
		/* Replace the rest of the mbuf chain. */
		struct mbuf    *n = m_dup_pkt(mi, 0, M_DONTWAIT);
a481 4
		if (mo != NULL)
			mo->m_next = n;
		else
			m = n;
d483 2
a484 1
		m_freem(mi);
@


1.44
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.43 2015/06/15 13:26:48 mikeb Exp $ */
d476 1
a476 1
		struct mbuf    *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);
@


1.43
log
@Use proper argument type for crp_callback functions; no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.42 2015/04/17 11:04:01 mikeb Exp $ */
d353 1
a353 2
	if (m)
		m_freem(m);
d666 1
a666 2
	if (m)
		m_freem(m);
@


1.42
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.41 2015/04/14 14:20:01 mikeb Exp $ */
d59 2
a60 2
int ipcomp_output_cb(void *);
int ipcomp_input_cb(void *);
d181 2
a182 2
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) ipcomp_input_cb;
d184 1
a184 1
	crp->crp_opaque = (caddr_t) tc;
d201 1
a201 2
ipcomp_input_cb(op)
	void *op;
a206 1
	struct cryptop *crp;
a213 2
	crp = (struct cryptop *) op;

d534 3
a536 3
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) ipcomp_output_cb;
	crp->crp_opaque = (caddr_t) tc;
d546 1
a546 2
ipcomp_output_cb(cp)
	void *cp;
a547 1
	struct cryptop *crp = (struct cryptop *) cp;
@


1.41
log
@make ipsp_address thread safe;  ok mpi
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.40 2015/03/14 03:38:52 jsg Exp $ */
a174 2
	tc->tc_ptr = 0;

d350 1
a350 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff, NULL);
@


1.40
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.39 2014/12/19 17:14:40 tedu Exp $ */
d214 3
d299 2
a300 1
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d384 3
d419 3
a421 2
			DPRINTF(("ipcomp_output(): packet in IPCA %s/%08x got too big\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d432 3
a434 2
			DPRINTF(("ipcomp_output(): packet in IPCA %s/%08x got too big\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d442 3
a444 2
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n",
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst),
d487 2
a488 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d566 3
d627 2
a628 2
		    "for IPCA %s/%08x\n",
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d656 2
a657 2
		    "IPCA %s/%08x\n",
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst),
@


1.39
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.38 2014/12/05 15:50:04 mpi Exp $ */
a55 2

#include <lib/libz/zlib.h>
@


1.38
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.37 2014/11/18 02:37:31 tedu Exp $ */
a40 1
#ifdef INET
a43 1
#endif				/* INET */
a45 3
#ifndef INET
#include <netinet/in.h>
#endif
a406 1
#ifdef INET
a420 1
#endif /* INET */
a551 1
#ifdef INET
a552 1
#endif
a629 1
#ifdef INET
a634 1
#endif /* INET */
@


1.37
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.36 2014/07/22 11:06:10 mpi Exp $ */
d38 1
@


1.36
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.35 2014/07/12 18:44:23 tedu Exp $ */
a38 2

#include <dev/rndvar.h>
@


1.35
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.34 2014/07/09 09:30:49 henning Exp $ */
a43 1
#include <netinet/in_systm.h>
@


1.34
log
@bpf code surgery / shuffling / simplification.
the various bpf_mtap_* are very similiar, they differ in what (and to some
extent how) they prepend something, and what copy function they pass to
bpf_catchpacket.
use an internal _bpf_mtap as "backend" for bpf_mtap and friends.
extend bpf_mtap_hdr so that it covers all common cases:
if dlen is 0, nothing gets prepended.
copy function can be given, if NULL the default bpf_mcopy is used.
adjust the existing bpf_mtap_hdr users to pass a NULL ptr for the copy fn.
re-implement bpf_mtap_af as simple wrapper for bpf_mtap_hdr.
re-implement bpf_mtap_ether using bpf_map_hdr
re-implement bpf_mtap_pflog as trivial bpf_mtap_hdr wrapper
ok bluhm benno
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.32 2013/05/14 14:29:08 mpi Exp $ */
d233 1
a233 1
		free(tc, M_XDATA);
d244 1
a244 1
		free(tc, M_XDATA);
d258 1
a258 1
		free(tc, M_XDATA);
d280 1
a280 1
		free(tc, M_XDATA);
d287 1
a287 1
	free(tc, M_XDATA);
d576 1
a576 1
		free(tc, M_XDATA);
d588 1
a588 1
		free(tc, M_XDATA);
d604 1
a604 1
		free(tc, M_XDATA);
d611 1
a611 1
	free(tc, M_XDATA);
@


1.33
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d405 1
a405 1
			    ENC_HDRLEN, m, BPF_DIRECTION_OUT);
@


1.32
log
@Fix build with ENCDEBUG defined.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.31 2013/04/11 12:06:25 mpi Exp $ */
d122 1
a122 1
	bzero(&cric, sizeof(cric));
d399 1
a399 1
			bzero (&hdr, sizeof(hdr));
d635 1
a635 1
	bzero(ipcomp, sizeof(struct ipcomp));
@


1.31
log
@Remove the extern keyword from function declarations, document
sysctl declarations, move variables and functions used in only
one place in their corresponding file. No functional change.

No objection from markus@@, ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.30 2013/02/14 16:22:34 mikeb Exp $ */
d46 1
@


1.30
log
@Merge of an original work by markus@@ and gerhard@@ to increase
the anti-replay window size to 2100 entries; plus small ESN
related improvements.  ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.29 2012/09/20 10:25:03 blambert Exp $ */
d66 3
@


1.29
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.28 2011/07/07 02:57:25 deraadt Exp $ */
a115 1
	tdbp->tdb_bitmap = 0;
@


1.28
log
@Replace the cruddy old sys/net/zlib.[ch].  We now use the sys/lib/libz
code.  Missing chunks of the API are imported from the libc version,
with a few #ifdef's to port it into the kernel environment.

The bootblocks already used the newer code, and should encounter no
surprises since there are so few changes to the existing files. In
the kernel, ipcomp and kernel ppp are changed to the new API.
ipcomp has been tested.

ok tedu the brave
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.27 2010/07/09 16:58:06 reyk Exp $ */
d237 1
a237 1
	s = spltdb();
d581 1
a581 1
	s = spltdb();
@


1.27
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.26 2010/07/02 02:40:16 blambert Exp $ */
a60 1
#include <crypto/deflate.h>
d62 2
@


1.26
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.25 2010/07/01 02:09:45 reyk Exp $ */
d198 1
d238 1
a238 1
	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
d530 1
d582 1
a582 1
	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
@


1.25
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.24 2010/06/29 21:28:37 reyk Exp $ */
d349 1
a349 1
	m_copyback(m, protoff, sizeof(u_int8_t), &nproto);
@


1.24
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.23 2008/09/15 21:46:01 chl Exp $ */
d387 1
a387 1
	if ((encif = enc_getif(0)) != NULL) {
@


1.23
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok mpf@@ looks good mk@@ ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.22 2007/10/06 02:18:38 krw Exp $ */
d385 1
a385 1
	struct ifnet   *ifn = &(encif[0].sc_if);
d387 3
a389 2
	if (ifn->if_bpf) {
		struct enchdr   hdr;
d391 2
a392 1
		bzero(&hdr, sizeof(hdr));
d394 1
a394 2
		hdr.af = tdb->tdb_dst.sa.sa_family;
		hdr.spi = tdb->tdb_spi;
d396 6
a401 2
		bpf_mtap_hdr(ifn->if_bpf, (char *)&hdr, ENC_HDRLEN, m,
		    BPF_DIRECTION_OUT);
@


1.22
log
@Oops. Forgot to do FREE -> free when I did MALLOC -> malloc.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.21 2007/10/03 10:52:11 krw Exp $ */
a212 2
	struct cryptodesc *crd;
	struct comp_algo *ipcompx;
a219 1
	crd = crp->crp_desc;
a244 1
	ipcompx = (struct comp_algo *) tdb->tdb_compalgxform;
@


1.21
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.20 2006/03/25 22:41:48 djm Exp $ */
d231 1
a231 1
		FREE(tc, M_XDATA);
d242 1
a242 1
		FREE(tc, M_XDATA);
d257 1
a257 1
		FREE(tc, M_XDATA);
d279 1
a279 1
		FREE(tc, M_XDATA);
d286 1
a286 1
	FREE(tc, M_XDATA);
d569 1
a569 1
		FREE(tc, M_XDATA);
d581 1
a581 1
		FREE(tc, M_XDATA);
d597 1
a597 1
		FREE(tc, M_XDATA);
d604 1
a604 1
	FREE(tc, M_XDATA);
@


1.20
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.19 2005/12/20 13:36:28 markus Exp $ */
d166 1
a166 2
	MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
	    M_XDATA, M_NOWAIT);
a173 1
	bzero(tc, sizeof(struct tdb_crypto));
d516 1
a516 2
	MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
	    M_XDATA, M_NOWAIT);
a523 1
	bzero(tc, sizeof(struct tdb_crypto));
@


1.19
log
@use M_READONLY when trying to find out whether we have to copy
the mbuf before encryption.  otherwise mbufs with M_EXT but w/o M_CLUSTER
get modified; ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.18 2005/07/31 03:52:19 pascoe Exp $ */
d401 2
a402 1
		bpf_mtap_hdr(ifn->if_bpf, (char *)&hdr, ENC_HDRLEN, m);
@


1.18
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.17 2004/11/25 21:54:54 markus Exp $ */
d467 2
a468 2
	 * Loop through mbuf chain; if we find an M_EXT mbuf with
	 * more than one reference, replace the rest of the chain.
d472 1
a472 2
	while (mi != NULL &&
	    (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi))) {
@


1.17
log
@resolve conflict between M_TUNNEL and M_ANYCAST6, remove M_COMP (it's
only set and never read), update documentation; ok fgsch, deraadt, millert
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.16 2004/06/26 17:34:16 markus Exp $ */
d390 2
d393 1
a393 3
#if NBPFILTER > 0
	{
		struct ifnet   *ifn;
a394 1
		struct mbuf     m1;
d401 1
a401 8
		m1.m_next = m;
		m1.m_len = ENC_HDRLEN;
		m1.m_data = (char *) &hdr;

		ifn = &(encif[0].sc_if);

		if (ifn->if_bpf)
			bpf_mtap(ifn->if_bpf, &m1);
@


1.16
log
@only add ipcomp headers if we've actually compressed the payload; with jfb@@
ok hshoexer, jfb
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.15 2003/08/14 19:00:12 jason Exp $ */
a400 1
		hdr.flags |= M_COMP;
@


1.15
log
@m_copyback()'s 4th arg is const void *, nuke (caddr_t) casts.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.14 2003/04/02 20:09:26 millert Exp $ */
a385 2
	u_int8_t        prot;
	u_int16_t       cpi;
a389 7
	struct ipcomp  *ipcomp;
#ifdef INET
	struct ip      *ip;
#endif
#ifdef INET6
	struct ip6_hdr *ip6;
#endif
a412 1

a504 49
	/* Inject IPCOMP header */
	mo = m_inject(m, skip, hlen, M_DONTWAIT);
	if (mo == NULL) {
		DPRINTF(("ipcomp_output(): failed to inject IPCOMP header for IPCA %s/%08x\n",
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		ipcompstat.ipcomps_wrap++;
		return ENOBUFS;
	}
	ipcomp = mtod(mo, struct ipcomp *);

	/* Initialize the IPCOMP header */

	bzero(ipcomp, sizeof(struct ipcomp));

	cpi = (u_int16_t) ntohl(tdb->tdb_spi);
	ipcomp->ipcomp_cpi = htons(cpi);

	/* m_pullup before ? */

	switch (tdb->tdb_dst.sa.sa_family) {
#ifdef INET
	case AF_INET:
		ip = mtod(m, struct ip *);
		ipcomp->ipcomp_nh = ip->ip_p;
		break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
		ip6 = mtod(m, struct ip6_hdr *);
		ipcomp->ipcomp_nh = ip6->ip6_nxt;
		break;
#endif

	default:
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n",
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst),
		    ntohl(tdb->tdb_spi)));
		m_freem(m);
		ipcompstat.ipcomps_nopf++;
		return EPFNOSUPPORT;
		break;
	}

	/* Fix Next Protocol in IPv4/IPv6 header */
	prot = IPPROTO_IPCOMP;
	m_copyback(m, protoff, sizeof(u_int8_t), &prot);

d518 2
a519 2
	crdc->crd_skip = skip + hlen;
	crdc->crd_len = m->m_pkthdr.len - (skip + hlen);
d521 1
a521 1
	crdc->crd_inject = skip + hlen;
d540 1
a540 1
	tc->tc_skip = skip + hlen;
d564 1
a564 1
	struct mbuf *m;
d566 1
d573 1
d628 18
a645 1
	/* Adjust the length in the IP header. */
d650 2
a651 1
		ip->ip_len = htons(m->m_pkthdr.len);
a653 1

d657 2
a658 1
		ip6->ip6_plen = htons(m->m_pkthdr.len) - sizeof(struct ip6_hdr);
d660 1
a660 2
#endif /* INET6 */

d662 2
a663 3
		m_freem(m);
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol "
		    "family %d, IPCA %s/%08x\n",
a665 1
		crypto_freereq(crp);
d667 2
a668 2
		splx(s);
		return EPFNOSUPPORT;
@


1.14
log
@o sanity check mbuf earlier.
o return errno, not NULL.
o add some missing error values
o proper crypto_freereq() in ip_ipcomp.c
From Patrick Latifi; OK angelos@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.13 2003/03/31 20:52:06 millert Exp $ */
d355 1
a355 1
	m_copyback(m, protoff, sizeof(u_int8_t), (u_int8_t *) & nproto);
d562 1
a562 1
	m_copyback(m, protoff, sizeof(u_int8_t), (u_char *) & prot);
@


1.13
log
@Avoid using FREEd data when we get a crypto error; Patrick Latifi
Also move the session ID reset into the crp_etype == EAGAIN case
(noticed by angelos@@).  OK jason@@ and angelos@@
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.12 2003/03/31 17:16:56 millert Exp $ */
d229 1
d231 8
d262 2
a263 3
		splx(s);
		m_freem(m);
		return ENXIO;
a289 10
	/* Shouldn't happen... */
	if (m == NULL) {
		ipcompstat.ipcomps_crypto++;
		DPRINTF(("ipcomp_input_cb(): bogus returned buffer from crypto\n"));
		error = EINVAL;
		goto baddone;
	}
	/* Release the crypto descriptors */
	crypto_freereq(crp);

d296 2
a297 1
	if ((m->m_len < skip + hlen) && (m = m_pullup(m, skip + hlen)) == 0)
d299 1
a304 1
		splx(s);
d307 2
a308 2
		m_freem(m);
		return EINVAL;
d351 3
d367 1
a632 1
	m = (struct mbuf *) crp->crp_buf;
d636 11
d654 1
a675 9
	/* Shouldn't happen... */
	if (m == NULL) {
		ipcompstat.ipcomps_crypto++;
		DPRINTF(("ipcomp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		error = EINVAL;
		goto baddone;
	}

d723 1
@


1.12
log
@Add missing splx; Patrick Latifi
jason@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.11 2003/02/18 18:47:40 jason Exp $ */
a233 1
	FREE(tc, M_XDATA);
d235 1
d238 1
d250 1
a265 3
		/* Reset the session ID */
		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;
d267 3
d273 1
d280 2
a645 4
		/* Reset session ID */
		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;

d647 3
a652 1

d657 1
d659 2
a660 2
	} else
		FREE(tc, M_XDATA);
@


1.11
log
@missed in lzs addition: allow LZS as an comp type
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.10 2003/02/12 14:41:07 jason Exp $ */
d251 1
d700 1
@


1.10
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.9 2002/09/12 10:11:39 ho Exp $ */
d99 3
a101 2

		/* Only deflate is implemented */
@


1.9
log
@Fix max packet size check. Noticed by <j@@pureftpd.org>. jjbg@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.8 2002/07/05 23:20:53 angelos Exp $ */
d71 2
@


1.8
log
@Free crp_opaque only after we've determined we're not going to
re-submit it. From sam@@errno.com
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.7 2002/06/20 03:49:02 deraadt Exp $ */
d373 1
a373 1
	int             rblen, ralen, hlen;
a410 1
	rblen = m->m_pkthdr.len - skip;	/* Raw payload length before comp. */
d423 1
a423 1
		if (skip + hlen + ralen > IP_MAXPACKET) {
d436 1
a436 1
		if (skip + hlen + ralen > IPV6_MAXPACKET) {
@


1.7
log
@minor indent cleanup while reading code
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.6 2002/06/18 23:06:57 angelos Exp $ */
a628 1
	FREE(tc, M_XDATA);
d630 1
d647 1
d652 3
a654 1
	}
@


1.6
log
@Style.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.5 2002/06/18 22:48:16 angelos Exp $ */
d319 3
a321 3
		         * The second mbuf is guaranteed not to have a
		         * pkthdr...
		         */
d337 2
a338 2
		      mtod(m1, u_char *) + roff,
		      m1->m_len - (roff + hlen));
d475 3
a477 3
         * Loop through mbuf chain; if we find an M_EXT mbuf with
         * more than one reference, replace the rest of the chain.
         */
d481 1
a481 1
	       (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi))) {
d576 1
a576 1
	       M_XDATA, M_NOWAIT);
@


1.5
log
@Initialize mo to NULL, for good measure -- sam@@errno.com
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.4 2002/06/18 22:26:12 angelos Exp $ */
d101 1
a101 2
		DPRINTF(
		    ("ipcomp_init(): unsupported compression algorithm %d specified\n",
d158 1
a158 2
		DPRINTF(
		    ("ipcomp_input(): failed to acquire crypto descriptors\n"));
d268 2
a269 3
		DPRINTF(

		    ("ipcomp_input_cb(): crypto error %d\n", crp->crp_etype));
d276 1
a276 3
		DPRINTF(
		    ("ipcomp_input_cb(): bogus returned buffer from crypto\n")
		    );
d425 1
a425 2
			DPRINTF(
			    ("ipcomp_output(): packet in IPCA %s/%08x got too big\n",
d438 1
a438 2
			DPRINTF(
			    ("ipcomp_output(): packet in IPCA %s/%08x got too big\n",
d447 1
a447 2
		DPRINTF(
		    ("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n",
d491 1
a491 2
			DPRINTF(
			    ("ipcomp_output(): bad mbuf chain, IPCA %s/%08x\n",
d507 1
a507 2
		DPRINTF(
		    ("ipcomp_output(): failed to inject IPCOMP header for IPCA %s/%08x\n",
d540 1
a540 2
		DPRINTF(
		    ("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n",
d559 1
a559 3
		DPRINTF(
		    ("ipcomp_output(): failed to acquire crypto descriptors\n"
		    ));
@


1.4
log
@Missing freeing of crp, from sam@@errno.com
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.3 2002/06/18 19:28:05 angelos Exp $ */
d486 1
@


1.3
log
@Fix double-free.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.2 2002/06/09 16:26:10 itojun Exp $ */
d658 1
a661 1

a682 1

d699 1
d704 1
a704 1
		m_freem(m);
@


1.2
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.1 2001/07/05 12:08:52 jjbg Exp $ */
d647 2
a648 1
	/* Check for crypto errors */
d667 2
a668 3
		DPRINTF(
		    ("ipcomp_output_cb(): bogus returned buffer from crypto\n"
		    ));
d672 2
a673 1
	/* Check sizes */
d675 1
a675 2
		/* compression was useless, we have lost time */
		FREE(tc, M_XDATA);
d682 1
a682 1
	/* Adjust the length in the IP header */
d700 2
a701 2
		DPRINTF(
		    ("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n",
d710 1
a710 1
	/* Release the crypto descriptor */
@


1.1
log
@IPComp. Just like for deflate earlier, it won't be compiled until everything
is in the tree
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d231 1
a231 1
	
d341 1
a341 1
		bcopy(mtod(m1, u_char *) + roff + hlen, 
d455 2
a456 2
		    ("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n", 
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst), 
d499 1
a499 1
			    ("ipcomp_output(): bad mbuf chain, IPCA %s/%08x\n", 
d550 2
a551 2
		    ("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n", 
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst), 
d658 1
a658 1
		DPRINTF(("ipcomp_output_cb(): crypto error %d\n", 
d701 2
a702 2
		    ("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n", 
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst), 
@


1.1.6.1
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.1 2001/07/05 12:08:52 jjbg Exp $ */
d101 2
a102 1
		DPRINTF(("ipcomp_init(): unsupported compression algorithm %d specified\n",
d159 2
a160 1
		DPRINTF(("ipcomp_input(): failed to acquire crypto descriptors\n"));
d231 1
a231 1

d270 3
a272 2
		DPRINTF(("ipcomp_input_cb(): crypto error %d\n",
		    crp->crp_etype));
d279 3
a281 1
		DPRINTF(("ipcomp_input_cb(): bogus returned buffer from crypto\n"));
d324 3
a326 3
			 * The second mbuf is guaranteed not to have a
			 * pkthdr...
			 */
d341 3
a343 3
		bcopy(mtod(m1, u_char *) + roff + hlen,
		    mtod(m1, u_char *) + roff,
		    m1->m_len - (roff + hlen));
d378 1
a378 1
	int             hlen;
d416 1
d429 3
a431 2
		if (m->m_pkthdr.len + hlen > IP_MAXPACKET) {
			DPRINTF(("ipcomp_output(): packet in IPCA %s/%08x got too big\n",
d443 3
a445 2
		if (m->m_pkthdr.len + hlen > IPV6_MAXPACKET) {
			DPRINTF(("ipcomp_output(): packet in IPCA %s/%08x got too big\n",
d454 3
a456 2
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n",
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst),
d483 3
a485 4
	 * Loop through mbuf chain; if we find an M_EXT mbuf with
	 * more than one reference, replace the rest of the chain.
	 */
	mo = NULL;
d488 1
a488 1
	    (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi))) {
d498 2
a499 1
			DPRINTF(("ipcomp_output(): bad mbuf chain, IPCA %s/%08x\n",
d515 2
a516 1
		DPRINTF(("ipcomp_output(): failed to inject IPCOMP header for IPCA %s/%08x\n",
d549 3
a551 2
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n",
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst),
d569 3
a571 1
		DPRINTF(("ipcomp_output(): failed to acquire crypto descriptors\n"));
d588 1
a588 1
	    M_XDATA, M_NOWAIT);
d641 1
a642 1
		FREE(tc, M_XDATA);
d647 1
a647 2

	/* Check for crypto errors. */
a656 2

		FREE(tc, M_XDATA);
d658 1
a658 1
		DPRINTF(("ipcomp_output_cb(): crypto error %d\n",
d660 1
d662 1
a662 3
	} else
		FREE(tc, M_XDATA);

d666 3
a668 2
		DPRINTF(("ipcomp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
d672 1
a672 2

	/* Check sizes. */
d674 2
a675 1
		/* Compression was useless, we have lost time. */
d682 2
a683 1
	/* Adjust the length in the IP header. */
d700 4
a704 5
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol "
		    "family %d, IPCA %s/%08x\n",
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst),
		    ntohl(tdb->tdb_spi)));
		crypto_freereq(crp);
d710 1
a710 1
	/* Release the crypto descriptor. */
@


1.1.6.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a71 2
struct ipcompstat ipcompstat;

d97 2
a98 3
	case SADB_X_CALG_LZS:
		tcomp = &comp_algo_lzs;
		break;
a225 1

a226 8
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		ipcompstat.ipcomps_crypto++;
		DPRINTF(("ipcomp_input_cb(): bogus returned buffer from crypto\n"));
		return (EINVAL);
	}
d231 1
a232 1
		FREE(tc, M_XDATA);
a234 1
		error = EPERM;
a245 1
		FREE(tc, M_XDATA);
d248 2
a249 2
		error = ENXIO;
		goto baddone;
d260 3
a263 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
a266 1
		FREE(tc, M_XDATA);
d273 9
a281 1
	FREE(tc, M_XDATA);
d289 1
a289 2
	if ((m->m_len < skip + hlen) && (m = m_pullup(m, skip + hlen)) == 0) {
		error = ENOBUFS;
a290 1
	}
d296 1
d299 2
a300 2
		error = EINVAL;
		goto baddone;
a342 3
	/* Release the crypto descriptors */
	crypto_freereq(crp);

a355 1

d621 1
a624 11
	m = (struct mbuf *) crp->crp_buf;
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		ipcompstat.ipcomps_crypto++;
		DPRINTF(("ipcomp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		return (EINVAL);
	}

a631 1
		error = EPERM;
d637 4
a641 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d645 1
d650 10
a659 1
		error = crp->crp_etype;
a661 1
	FREE(tc, M_XDATA);
a695 1
		splx(s);
a708 1

@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1.4.2
log
@Sync the SMP branch with 3.3
@
text
@a71 2
struct ipcompstat ipcompstat;

d97 2
a98 3
	case SADB_X_CALG_LZS:
		tcomp = &comp_algo_lzs;
		break;
d101 2
a102 1
		DPRINTF(("ipcomp_init(): unsupported compression algorithm %d specified\n",
d159 2
a160 1
		DPRINTF(("ipcomp_input(): failed to acquire crypto descriptors\n"));
d231 1
a231 1

d270 3
a272 2
		DPRINTF(("ipcomp_input_cb(): crypto error %d\n",
		    crp->crp_etype));
d279 3
a281 1
		DPRINTF(("ipcomp_input_cb(): bogus returned buffer from crypto\n"));
d324 3
a326 3
			 * The second mbuf is guaranteed not to have a
			 * pkthdr...
			 */
d341 3
a343 3
		bcopy(mtod(m1, u_char *) + roff + hlen,
		    mtod(m1, u_char *) + roff,
		    m1->m_len - (roff + hlen));
d378 1
a378 1
	int             hlen;
d416 1
d429 3
a431 2
		if (m->m_pkthdr.len + hlen > IP_MAXPACKET) {
			DPRINTF(("ipcomp_output(): packet in IPCA %s/%08x got too big\n",
d443 3
a445 2
		if (m->m_pkthdr.len + hlen > IPV6_MAXPACKET) {
			DPRINTF(("ipcomp_output(): packet in IPCA %s/%08x got too big\n",
d454 3
a456 2
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n",
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst),
d483 3
a485 4
	 * Loop through mbuf chain; if we find an M_EXT mbuf with
	 * more than one reference, replace the rest of the chain.
	 */
	mo = NULL;
d488 1
a488 1
	    (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi))) {
d498 2
a499 1
			DPRINTF(("ipcomp_output(): bad mbuf chain, IPCA %s/%08x\n",
d515 2
a516 1
		DPRINTF(("ipcomp_output(): failed to inject IPCOMP header for IPCA %s/%08x\n",
d549 3
a551 2
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol family %d, IPCA %s/%08x\n",
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst),
d569 3
a571 1
		DPRINTF(("ipcomp_output(): failed to acquire crypto descriptors\n"));
d588 1
a588 1
	    M_XDATA, M_NOWAIT);
d641 1
a642 1
		FREE(tc, M_XDATA);
d647 1
a647 2

	/* Check for crypto errors. */
a656 2

		FREE(tc, M_XDATA);
d658 1
a658 1
		DPRINTF(("ipcomp_output_cb(): crypto error %d\n",
d660 1
d662 1
a662 3
	} else
		FREE(tc, M_XDATA);

d666 3
a668 2
		DPRINTF(("ipcomp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
d672 1
a672 2

	/* Check sizes. */
d674 2
a675 1
		/* Compression was useless, we have lost time. */
d682 2
a683 1
	/* Adjust the length in the IP header. */
d700 4
a704 5
		DPRINTF(("ipcomp_output(): unknown/unsupported protocol "
		    "family %d, IPCA %s/%08x\n",
		    tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst),
		    ntohl(tdb->tdb_spi)));
		crypto_freereq(crp);
d710 1
a710 1
	/* Release the crypto descriptor. */
@


1.1.4.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/* $OpenBSD: ip_ipcomp.c,v 1.1.4.2 2003/03/28 00:06:54 niklas Exp $ */
a228 1

a229 8
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		ipcompstat.ipcomps_crypto++;
		DPRINTF(("ipcomp_input_cb(): bogus returned buffer from crypto\n"));
		return (EINVAL);
	}
d234 1
a235 1
		FREE(tc, M_XDATA);
a237 1
		error = EPERM;
a248 1
		FREE(tc, M_XDATA);
d251 2
a252 2
		error = ENXIO;
		goto baddone;
d263 3
a266 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
a269 1
		FREE(tc, M_XDATA);
d276 9
a284 1
	FREE(tc, M_XDATA);
d292 1
a292 2
	if ((m->m_len < skip + hlen) && (m = m_pullup(m, skip + hlen)) == 0) {
		error = ENOBUFS;
a293 1
	}
d299 1
d302 2
a303 2
		error = EINVAL;
		goto baddone;
a345 3
	/* Release the crypto descriptors */
	crypto_freereq(crp);

a358 1

d624 1
a627 11
	m = (struct mbuf *) crp->crp_buf;
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		ipcompstat.ipcomps_crypto++;
		DPRINTF(("ipcomp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		return (EINVAL);
	}

a634 1
		error = EPERM;
d640 4
a644 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d648 1
d653 10
a662 1
		error = crp->crp_etype;
a664 1
	FREE(tc, M_XDATA);
a698 1
		splx(s);
a711 1

@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d355 1
a355 1
	m_copyback(m, protoff, sizeof(u_int8_t), &nproto);
d562 1
a562 1
	m_copyback(m, protoff, sizeof(u_int8_t), &prot);
@


