head	1.232;
access;
symbols
	OPENBSD_6_1:1.232.0.4
	OPENBSD_6_1_BASE:1.232
	OPENBSD_6_0:1.216.0.4
	OPENBSD_6_0_BASE:1.216
	OPENBSD_5_9:1.208.0.2
	OPENBSD_5_9_BASE:1.208
	OPENBSD_5_8:1.204.0.4
	OPENBSD_5_8_BASE:1.204
	OPENBSD_5_7:1.196.0.2
	OPENBSD_5_7_BASE:1.196
	OPENBSD_5_6:1.189.0.4
	OPENBSD_5_6_BASE:1.189
	OPENBSD_5_5:1.174.0.4
	OPENBSD_5_5_BASE:1.174
	OPENBSD_5_4:1.164.0.2
	OPENBSD_5_4_BASE:1.164
	OPENBSD_5_3:1.153.0.2
	OPENBSD_5_3_BASE:1.153
	OPENBSD_5_2:1.149.0.2
	OPENBSD_5_2_BASE:1.149
	OPENBSD_5_1_BASE:1.145
	OPENBSD_5_1:1.145.0.4
	OPENBSD_5_0:1.145.0.2
	OPENBSD_5_0_BASE:1.145
	OPENBSD_4_9:1.138.0.2
	OPENBSD_4_9_BASE:1.138
	OPENBSD_4_8:1.136.0.2
	OPENBSD_4_8_BASE:1.136
	OPENBSD_4_7:1.133.0.2
	OPENBSD_4_7_BASE:1.133
	OPENBSD_4_6:1.130.0.4
	OPENBSD_4_6_BASE:1.130
	OPENBSD_4_5:1.126.0.2
	OPENBSD_4_5_BASE:1.126
	OPENBSD_4_4:1.124.0.2
	OPENBSD_4_4_BASE:1.124
	OPENBSD_4_3:1.115.0.2
	OPENBSD_4_3_BASE:1.115
	OPENBSD_4_2:1.114.0.2
	OPENBSD_4_2_BASE:1.114
	OPENBSD_4_1:1.112.0.2
	OPENBSD_4_1_BASE:1.112
	OPENBSD_4_0:1.110.0.2
	OPENBSD_4_0_BASE:1.110
	OPENBSD_3_9:1.106.0.2
	OPENBSD_3_9_BASE:1.106
	OPENBSD_3_8:1.104.0.2
	OPENBSD_3_8_BASE:1.104
	OPENBSD_3_7:1.102.0.4
	OPENBSD_3_7_BASE:1.102
	OPENBSD_3_6:1.102.0.2
	OPENBSD_3_6_BASE:1.102
	SMP_SYNC_A:1.100
	SMP_SYNC_B:1.100
	OPENBSD_3_5:1.99.0.2
	OPENBSD_3_5_BASE:1.99
	OPENBSD_3_4:1.91.0.2
	OPENBSD_3_4_BASE:1.91
	UBC_SYNC_A:1.87
	OPENBSD_3_3:1.86.0.4
	OPENBSD_3_3_BASE:1.86
	OPENBSD_3_2:1.86.0.2
	OPENBSD_3_2_BASE:1.86
	OPENBSD_3_1:1.76.0.2
	OPENBSD_3_1_BASE:1.76
	UBC_SYNC_B:1.86
	UBC:1.74.0.4
	UBC_BASE:1.74
	OPENBSD_3_0:1.74.0.2
	OPENBSD_3_0_BASE:1.74
	OPENBSD_2_9_BASE:1.56
	OPENBSD_2_9:1.56.0.2
	OPENBSD_2_8:1.51.0.2
	OPENBSD_2_8_BASE:1.51
	OPENBSD_2_7:1.40.0.2
	OPENBSD_2_7_BASE:1.40
	SMP:1.38.0.2
	SMP_BASE:1.38
	kame_19991208:1.29
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.25.0.2
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.232
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.231;
commitid	ZsxSSZJSFxZH81LL;

1.231
date	2017.02.05.16.23.38;	author jca;	state Exp;
branches;
next	1.230;
commitid	b4PzKhPOLWkSDY9t;

1.230
date	2017.01.31.10.24.41;	author jca;	state Exp;
branches;
next	1.229;
commitid	A2smg1VkYafec3DU;

1.229
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.228;
commitid	3e3CkrbYekyVOcxy;

1.228
date	2017.01.26.13.03.47;	author bluhm;	state Exp;
branches;
next	1.227;
commitid	wBlwxPiTlfo8m7xr;

1.227
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.226;
commitid	pVtptbHA3yk4jSpN;

1.226
date	2016.12.19.15.47.19;	author mpi;	state Exp;
branches;
next	1.225;
commitid	xfCbE6Pg35TUdksM;

1.225
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.224;
commitid	QqHqT2WhCBWqYgGJ;

1.224
date	2016.12.10.13.22.57;	author patrick;	state Exp;
branches;
next	1.223;
commitid	AwQHbrTSgwzKT1Yu;

1.223
date	2016.11.28.10.49.35;	author mpi;	state Exp;
branches;
next	1.222;
commitid	2swT1x7nLrt69SAx;

1.222
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.221;
commitid	wuzpseLx3Ntn9R7b;

1.221
date	2016.11.18.02.53.47;	author dlg;	state Exp;
branches;
next	1.220;
commitid	VkivwyRVzetroSYM;

1.220
date	2016.11.03.18.42.35;	author mikeb;	state Exp;
branches;
next	1.219;
commitid	EBZUPIsRv9n7ejJ8;

1.219
date	2016.09.03.13.46.57;	author reyk;	state Exp;
branches;
next	1.218;
commitid	3QjHFZLzmkdTcUlc;

1.218
date	2016.08.16.22.21.17;	author vgross;	state Exp;
branches;
next	1.217;
commitid	t6hSs1Di1O3UTldP;

1.217
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.216;
commitid	nbCHuHn2E9uBfKJT;

1.216
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.215;
commitid	Cm0qxR09oTCkXjXZ;

1.215
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.214;
commitid	jodmGXAB42f8N6nf;

1.214
date	2016.06.28.11.22.53;	author jca;	state Exp;
branches;
next	1.213;
commitid	b8kkhQdRBcxyPeL0;

1.213
date	2016.06.18.10.36.13;	author vgross;	state Exp;
branches;
next	1.212;
commitid	r16P5gVURcjZa76o;

1.212
date	2016.06.15.16.06.35;	author vgross;	state Exp;
branches;
next	1.211;
commitid	jXwHf474T8yjFZGT;

1.211
date	2016.06.15.15.16.47;	author vgross;	state Exp;
branches;
next	1.210;
commitid	ERu696jtl2fmHR8D;

1.210
date	2016.03.23.15.50.36;	author vgross;	state Exp;
branches;
next	1.209;
commitid	iMWKOVeEybjVAEfv;

1.209
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.208;
commitid	Z6e4eqr6FuYFPnlL;

1.208
date	2015.12.03.14.05.28;	author bluhm;	state Exp;
branches;
next	1.207;
commitid	Qo1JIwCdJHaA2LFI;

1.207
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.206;
commitid	sTEWfQrcV5GjIWc0;

1.206
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.205;
commitid	PcRGyy4jlpJbKkXz;

1.205
date	2015.08.14.18.07.28;	author bluhm;	state Exp;
branches;
next	1.204;
commitid	mu9yDScTa557hRQD;

1.204
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.203;
commitid	ncpqEGjDtSFuLAgn;

1.203
date	2015.07.08.08.48.34;	author mpi;	state Exp;
branches;
next	1.202;
commitid	PeSgmtaVq0R4a133;

1.202
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.201;
commitid	J4OPNuggl4DOKGzM;

1.201
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.200;
commitid	h7z8lokZ0dFyuWpg;

1.200
date	2015.06.05.21.41.43;	author krw;	state Exp;
branches;
next	1.199;
commitid	qjorRKalwtScKJAH;

1.199
date	2015.05.23.12.38.53;	author markus;	state Exp;
branches;
next	1.198;
commitid	Mgx7ewWJ5ueyVCxt;

1.198
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.197;
commitid	2c41FFL8044mZVko;

1.197
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.196;
commitid	bQi1IVHgugweH5gs;

1.196
date	2015.03.04.11.10.55;	author mpi;	state Exp;
branches;
next	1.195;
commitid	qKIbFOrY1lWEYrPI;

1.195
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.194;
commitid	t9FBKDfc4VDxpEy2;

1.194
date	2014.11.25.12.13.59;	author mpi;	state Exp;
branches;
next	1.193;
commitid	LpEdzfLT6nCsyYTb;

1.193
date	2014.11.20.14.51.42;	author krw;	state Exp;
branches;
next	1.192;
commitid	dOUqRDzYiPQXkCLL;

1.192
date	2014.11.20.11.05.19;	author mpi;	state Exp;
branches;
next	1.191;
commitid	uo0PiO5ELdW7V3PO;

1.191
date	2014.11.09.22.05.08;	author bluhm;	state Exp;
branches;
next	1.190;
commitid	SqTYB83QZLRauhYQ;

1.190
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.189;
commitid	uzzBR7hz9ncd4O6G;

1.189
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.188;
commitid	DQakU8LLWV6Iwx84;

1.188
date	2014.07.12.21.06.34;	author yasuoka;	state Exp;
branches;
next	1.187;
commitid	LARYP0a27ik2w0nd;

1.187
date	2014.07.11.13.15.34;	author bluhm;	state Exp;
branches;
next	1.186;
commitid	ViJ6P85Sj939uDH4;

1.186
date	2014.06.23.22.48.33;	author deraadt;	state Exp;
branches;
next	1.185;
commitid	PkmGShjByqbHDsA7;

1.185
date	2014.06.23.11.51.42;	author yasuoka;	state Exp;
branches;
next	1.184;
commitid	nfHnF5QVBDrgwlbA;

1.184
date	2014.04.23.12.25.35;	author mpi;	state Exp;
branches;
next	1.183;

1.183
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.182;

1.182
date	2014.04.18.10.48.29;	author jca;	state Exp;
branches;
next	1.181;

1.181
date	2014.04.16.13.04.38;	author mpi;	state Exp;
branches;
next	1.180;

1.180
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.179;

1.179
date	2014.04.07.19.51.15;	author chrisz;	state Exp;
branches;
next	1.178;

1.178
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.177;

1.177
date	2014.04.06.17.40.36;	author chrisz;	state Exp;
branches;
next	1.176;

1.176
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.175;

1.175
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.174;

1.174
date	2014.01.24.18.54.58;	author henning;	state Exp;
branches;
next	1.173;

1.173
date	2014.01.23.23.51.29;	author henning;	state Exp;
branches;
next	1.172;

1.172
date	2013.12.20.02.04.08;	author krw;	state Exp;
branches;
next	1.171;

1.171
date	2013.11.22.07.59.09;	author mpi;	state Exp;
branches;
next	1.170;

1.170
date	2013.10.20.11.03.01;	author phessler;	state Exp;
branches;
next	1.169;

1.169
date	2013.10.19.10.38.55;	author henning;	state Exp;
branches;
next	1.168;

1.168
date	2013.10.17.16.27.44;	author bluhm;	state Exp;
branches;
next	1.167;

1.167
date	2013.10.13.10.10.04;	author reyk;	state Exp;
branches;
next	1.166;

1.166
date	2013.09.06.18.35.16;	author bluhm;	state Exp;
branches;
next	1.165;

1.165
date	2013.07.31.15.41.52;	author mikeb;	state Exp;
branches;
next	1.164;

1.164
date	2013.06.09.22.03.06;	author yasuoka;	state Exp;
branches;
next	1.163;

1.163
date	2013.06.01.16.22.05;	author bluhm;	state Exp;
branches;
next	1.162;

1.162
date	2013.05.31.13.15.53;	author bluhm;	state Exp;
branches;
next	1.161;

1.161
date	2013.05.17.09.04.30;	author mpi;	state Exp;
branches;
next	1.160;

1.160
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.159;

1.159
date	2013.04.04.19.23.39;	author bluhm;	state Exp;
branches;
next	1.158;

1.158
date	2013.04.02.18.27.47;	author bluhm;	state Exp;
branches;
next	1.157;

1.157
date	2013.03.31.11.18.35;	author bluhm;	state Exp;
branches;
next	1.156;

1.156
date	2013.03.31.00.59.52;	author bluhm;	state Exp;
branches;
next	1.155;

1.155
date	2013.03.29.13.16.14;	author bluhm;	state Exp;
branches;
next	1.154;

1.154
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.153;

1.153
date	2013.02.16.14.34.52;	author bluhm;	state Exp;
branches;
next	1.152;

1.152
date	2013.01.17.11.43.06;	author bluhm;	state Exp;
branches;
next	1.151;

1.151
date	2012.09.28.16.06.20;	author markus;	state Exp;
branches;
next	1.150;

1.150
date	2012.09.17.20.01.26;	author yasuoka;	state Exp;
branches;
next	1.149;

1.149
date	2012.07.17.03.18.57;	author yasuoka;	state Exp;
branches;
next	1.148;

1.148
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.147;

1.147
date	2012.04.04.04.31.38;	author yasuoka;	state Exp;
branches;
next	1.146;

1.146
date	2012.03.17.10.16.41;	author dlg;	state Exp;
branches;
next	1.145;

1.145
date	2011.07.08.18.30.17;	author yasuoka;	state Exp;
branches;
next	1.144;

1.144
date	2011.05.13.14.31.17;	author oga;	state Exp;
branches;
next	1.143;

1.143
date	2011.05.04.16.05.49;	author blambert;	state Exp;
branches;
next	1.142;

1.142
date	2011.04.28.09.56.27;	author claudio;	state Exp;
branches;
next	1.141;

1.141
date	2011.04.24.19.36.54;	author bluhm;	state Exp;
branches;
next	1.140;

1.140
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.139;

1.139
date	2011.04.03.16.09.09;	author blambert;	state Exp;
branches;
next	1.138;

1.138
date	2010.09.24.14.50.30;	author hsuenaga;	state Exp;
branches;
next	1.137;

1.137
date	2010.09.08.08.34.42;	author claudio;	state Exp;
branches;
next	1.136;

1.136
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.135;

1.135
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.134;

1.134
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.133;

1.133
date	2010.03.11.00.24.58;	author sthen;	state Exp;
branches;
next	1.132;

1.132
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.131;

1.131
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.130;

1.130
date	2009.06.08.23.07.08;	author sthen;	state Exp;
branches;
next	1.129;

1.129
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.128;

1.128
date	2009.06.03.18.22.44;	author naddy;	state Exp;
branches;
next	1.127;

1.127
date	2009.06.02.15.32.19;	author blambert;	state Exp;
branches;
next	1.126;

1.126
date	2008.10.13.14.02.20;	author henning;	state Exp;
branches;
next	1.125;

1.125
date	2008.09.03.12.51.39;	author henning;	state Exp;
branches;
next	1.124;

1.124
date	2008.07.16.09.00.44;	author henning;	state Exp;
branches;
next	1.123;

1.123
date	2008.06.14.22.15.30;	author jsing;	state Exp;
branches;
next	1.122;

1.122
date	2008.06.14.19.54.09;	author jsing;	state Exp;
branches;
next	1.121;

1.121
date	2008.05.24.19.48.32;	author thib;	state Exp;
branches;
next	1.120;

1.120
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.119;

1.119
date	2008.05.15.19.40.38;	author markus;	state Exp;
branches;
next	1.118;

1.118
date	2008.05.09.02.56.36;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.116;

1.116
date	2008.05.02.06.49.32;	author ckuethe;	state Exp;
branches;
next	1.115;

1.115
date	2007.12.13.20.00.53;	author reyk;	state Exp;
branches;
next	1.114;

1.114
date	2007.06.11.11.29.35;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.27.20.17.05;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.111;

1.111
date	2006.11.27.11.00.12;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2006.07.17.12.16.36;	author claudio;	state Exp;
branches;
next	1.109;

1.109
date	2006.06.15.10.12.36;	author pascoe;	state Exp;
branches;
next	1.108;

1.108
date	2006.05.29.20.42.27;	author claudio;	state Exp;
branches;
next	1.107;

1.107
date	2006.05.16.12.39.21;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2006.01.13.10.11.23;	author mpf;	state Exp;
branches;
next	1.105;

1.105
date	2005.10.17.08.43.34;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2005.05.27.04.55.28;	author mcbride;	state Exp;
branches;
next	1.103;

1.103
date	2005.04.25.17.55.52;	author brad;	state Exp;
branches;
next	1.102;

1.102
date	2004.08.10.20.11.04;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2004.06.14.05.24.04;	author mcbride;	state Exp;
branches;
next	1.100;

1.100
date	2004.04.14.05.34.15;	author itojun;	state Exp;
branches;
next	1.99;

1.99
date	2004.03.21.20.58.10;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2004.02.17.12.07.45;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2004.01.07.09.56.13;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2003.12.21.14.57.19;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.94;

1.94
date	2003.12.08.07.07.36;	author mcbride;	state Exp;
branches;
next	1.93;

1.93
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2003.11.04.21.43.16;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.90;

1.90
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.89;

1.89
date	2003.05.30.01.09.16;	author itojun;	state Exp;
branches;
next	1.88;

1.88
date	2003.05.29.00.32.59;	author itojun;	state Exp;
branches;
next	1.87;

1.87
date	2003.05.12.00.48.52;	author jason;	state Exp;
branches;
next	1.86;

1.86
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.85;

1.85
date	2002.08.19.02.31.02;	author itojun;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.28.09.15.12;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.26.17.38.12;	author angelos;	state Exp;
branches;
next	1.82;

1.82
date	2002.06.26.16.37.58;	author angelos;	state Exp;
branches;
next	1.81;

1.81
date	2002.06.25.00.21.58;	author angelos;	state Exp;
branches;
next	1.80;

1.80
date	2002.06.25.00.21.32;	author angelos;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.20.03.49.02;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.09.16.26.11;	author itojun;	state Exp;
branches;
next	1.77;

1.77
date	2002.05.31.04.43.26;	author angelos;	state Exp;
branches;
next	1.76;

1.76
date	2002.03.15.18.19.53;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.74;

1.74
date	2001.06.25.02.06.40;	author angelos;	state Exp;
branches
	1.74.4.1;
next	1.73;

1.73
date	2001.06.25.00.11.58;	author angelos;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.24.23.01.59;	author angelos;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.24.22.50.59;	author angelos;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.23.18.54.44;	author angelos;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.23.16.15.56;	author fgsch;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.23.07.14.32;	author angelos;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.23.06.03.13;	author angelos;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.23.05.36.08;	author angelos;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.23.03.42.10;	author angelos;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.23.02.27.11;	author angelos;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.19.00.48.23;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2001.06.08.03.53.47;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	2001.06.05.02.31.37;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2001.05.27.03.13.30;	author angelos;	state Exp;
branches;
next	1.59;

1.59
date	2001.05.27.00.39.27;	author angelos;	state Exp;
branches;
next	1.58;

1.58
date	2001.05.20.08.35.12;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	2001.05.11.17.20.12;	author aaron;	state Exp;
branches;
next	1.56;

1.56
date	2001.03.28.20.03.07;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.06.18.34.17;	author aaron;	state Exp;
branches;
next	1.54;

1.54
date	2001.02.16.16.17.31;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2001.02.16.16.00.54;	author itojun;	state Exp;
branches;
next	1.52;

1.52
date	2000.12.11.08.04.56;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2000.10.13.17.58.37;	author itojun;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2000.10.11.09.14.13;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2000.09.22.17.51.46;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2000.09.19.03.21.00;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2000.07.27.06.29.09;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2000.07.27.04.05.27;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2000.06.18.17.32.48;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2000.06.13.11.47.24;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2000.06.13.10.29.44;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.13.10.26.43;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.13.10.12.00;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2000.04.09.17.43.02;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2000.02.18.05.21.01;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.07.06.09.09;	author itojun;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2000.01.07.16.34.10;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.04.10.38.36;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2000.01.04.04.17.39;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	99.12.31.22.07.44;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	99.12.21.15.41.08;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	99.12.19.02.52.21;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	99.12.17.22.47.05;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	99.12.12.10.59.41;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	99.11.04.11.24.24;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	99.09.23.07.20.35;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.06.06.23.34.20;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.03.27.21.04.20;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	99.03.24.02.59.06;	author cmetz;	state Exp;
branches;
next	1.23;

1.23
date	99.02.17.00.14.26;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.02.04.16.05.02;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.01.15.12.01.07;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.01.11.16.05.46;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.01.11.02.01.36;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.01.07.06.05.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.12.31.11.16.55;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.12.28.23.54.58;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.05.18.21.11.12;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	98.01.24.18.21.39;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.09.07.02.19.24;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.08.09.23.36.28;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.24.00.31.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.06.27.02.23.22;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.02.16.04.42.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.26.01.23.46;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.07.05.20.42.18;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.15.09.03.12;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.23.34.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.29.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.22.30.51;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.50.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.13;	author deraadt;	state Exp;
branches;
next	;

1.38.2.1
date	2000.02.20.11.57.31;	author niklas;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2001.05.14.22.40.15;	author niklas;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2001.07.04.10.55.12;	author niklas;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.38.2.5;

1.38.2.5
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.38.2.6;

1.38.2.6
date	2003.05.13.19.36.18;	author ho;	state Exp;
branches;
next	1.38.2.7;

1.38.2.7
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.38.2.8;

1.38.2.8
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.38.2.9;

1.38.2.9
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.51.2.1
date	2001.03.06.19.29.17;	author jason;	state Exp;
branches;
next	;

1.74.4.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.74.4.2;

1.74.4.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.74.4.3;

1.74.4.3
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.232
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@/*	$OpenBSD: udp_usrreq.c,v 1.231 2017/02/05 16:23:38 jca Exp $	*/
/*	$NetBSD: udp_usrreq.c,v 1.28 1996/03/16 23:54:03 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>
#include <sys/domain.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_media.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>

#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#include <netinet/ip_esp.h>
#endif

#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet6/ip6_var.h>
#include <netinet6/ip6protosw.h>
#endif /* INET6 */

#include "pf.h"
#if NPF > 0
#include <net/pfvar.h>
#endif

#ifdef PIPEX 
#include <netinet/if_ether.h>
#include <net/pipex.h>
#endif

#include "vxlan.h"
#if NVXLAN > 0
#include <net/if_vxlan.h>
#endif

/*
 * UDP protocol implementation.
 * Per RFC 768, August, 1980.
 */
int	udpcksum = 1;

u_int	udp_sendspace = 9216;		/* really max datagram size */
u_int	udp_recvspace = 40 * (1024 + sizeof(struct sockaddr_in));
					/* 40 1K datagrams */

int *udpctl_vars[UDPCTL_MAXID] = UDPCTL_VARS;

struct	inpcbtable udbtable;
struct	cpumem *udpcounters;

int	udp_output(struct inpcb *, struct mbuf *, struct mbuf *, struct mbuf *);
void	udp_notify(struct inpcb *, int);
int	udp_sysctl_udpstat(void *, size_t *, void *);

#ifndef	UDB_INITIAL_HASH_SIZE
#define	UDB_INITIAL_HASH_SIZE	128
#endif

void
udp_init(void)
{
	udpcounters = counters_alloc(udps_ncounters);
	in_pcbinit(&udbtable, UDB_INITIAL_HASH_SIZE);
}

int
udp_input(struct mbuf **mp, int *offp, int proto)
{
	struct mbuf *m = *mp;
	int iphlen = *offp;
	struct ip *ip;
	struct udphdr *uh;
	struct inpcb *inp = NULL;
	struct mbuf *opts = NULL;
	struct ip save_ip;
	int len;
	u_int16_t savesum;
	union {
		struct sockaddr sa;
		struct sockaddr_in sin;
#ifdef INET6
		struct sockaddr_in6 sin6;
#endif /* INET6 */
	} srcsa, dstsa;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif /* INET6 */
#ifdef IPSEC
	struct m_tag *mtag;
	struct tdb_ident *tdbi;
	struct tdb *tdb;
	int error, protoff;
#endif /* IPSEC */
#if defined(IPSEC) || defined(PIPEX)
	u_int32_t ipsecflowinfo = 0;
#endif /* define(IPSEC) || defined(PIPEX) */

	udpstat_inc(udps_ipackets);

	switch (mtod(m, struct ip *)->ip_v) {
	case 4:
		ip = mtod(m, struct ip *);
#ifdef INET6
		ip6 = NULL;
#endif /* INET6 */
		srcsa.sa.sa_family = AF_INET;
#ifdef IPSEC
		protoff = offsetof(struct ip, ip_p);
#endif /* IPSEC */
		break;
#ifdef INET6
	case 6:
		ip = NULL;
		ip6 = mtod(m, struct ip6_hdr *);
		srcsa.sa.sa_family = AF_INET6;
#ifdef IPSEC
		protoff = offsetof(struct ip6_hdr, ip6_nxt);
#endif /* IPSEC */
		break;
#endif /* INET6 */
	default:
		goto bad;
	}

	IP6_EXTHDR_GET(uh, struct udphdr *, m, iphlen, sizeof(struct udphdr));
	if (!uh) {
		udpstat_inc(udps_hdrops);
		return IPPROTO_DONE;
	}

	/* Check for illegal destination port 0 */
	if (uh->uh_dport == 0) {
		udpstat_inc(udps_noport);
		goto bad;
	}

	/*
	 * Make mbuf data length reflect UDP length.
	 * If not enough data to reflect UDP length, drop.
	 */
	len = ntohs((u_int16_t)uh->uh_ulen);
	if (ip) {
		if (m->m_pkthdr.len - iphlen != len) {
			if (len > (m->m_pkthdr.len - iphlen) ||
			    len < sizeof(struct udphdr)) {
				udpstat_inc(udps_badlen);
				goto bad;
			}
			m_adj(m, len - (m->m_pkthdr.len - iphlen));
		}
	}
#ifdef INET6
	else if (ip6) {
		/* jumbograms */
		if (len == 0 && m->m_pkthdr.len - iphlen > 0xffff)
			len = m->m_pkthdr.len - iphlen;
		if (len != m->m_pkthdr.len - iphlen) {
			udpstat_inc(udps_badlen);
			goto bad;
		}
	}
#endif
	else /* shouldn't happen */
		goto bad;

	/*
	 * Save a copy of the IP header in case we want restore it
	 * for sending an ICMP error message in response.
	 */
	if (ip)
		save_ip = *ip;

#ifdef INET6
	if (ip6) {
		/* Be proactive about malicious use of IPv4 mapped address */
		if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
		    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
			/* XXX stat */
			goto bad;
		}
	}
#endif /* INET6 */

	/*
	 * Checksum extended UDP header and data.
	 * from W.R.Stevens: check incoming udp cksums even if
	 *	udpcksum is not set.
	 */
	savesum = uh->uh_sum;
	if (uh->uh_sum == 0) {
		udpstat_inc(udps_nosum);
#ifdef INET6
		/*
		 * In IPv6, the UDP checksum is ALWAYS used.
		 */
		if (ip6)
			goto bad;
#endif /* INET6 */
	} else {
		if ((m->m_pkthdr.csum_flags & M_UDP_CSUM_IN_OK) == 0) {
			if (m->m_pkthdr.csum_flags & M_UDP_CSUM_IN_BAD) {
				udpstat_inc(udps_badsum);
				goto bad;
			}
			udpstat_inc(udps_inswcsum);

			if (ip)
				uh->uh_sum = in4_cksum(m, IPPROTO_UDP,
				    iphlen, len);
#ifdef INET6
			else if (ip6)
				uh->uh_sum = in6_cksum(m, IPPROTO_UDP,
				    iphlen, len);
#endif /* INET6 */
			if (uh->uh_sum != 0) {
				udpstat_inc(udps_badsum);
				goto bad;
			}
		}
	}

#ifdef IPSEC
	if (udpencap_enable && udpencap_port &&
#if NPF > 0
	    !(m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) &&
#endif
	    uh->uh_dport == htons(udpencap_port)) {
		u_int32_t spi;
		int skip = iphlen + sizeof(struct udphdr);

		if (m->m_pkthdr.len - skip < sizeof(u_int32_t)) {
			/* packet too short */
			m_freem(m);
			return IPPROTO_DONE;
		}
		m_copydata(m, skip, sizeof(u_int32_t), (caddr_t) &spi);
		/*
		 * decapsulate if the SPI is not zero, otherwise pass
		 * to userland
		 */
		if (spi != 0) {
			if ((m = m_pullup(m, skip)) == NULL) {
				udpstat_inc(udps_hdrops);
				return IPPROTO_DONE;
			}

			/* remove the UDP header */
			bcopy(mtod(m, u_char *),
			    mtod(m, u_char *) + sizeof(struct udphdr), iphlen);
			m_adj(m, sizeof(struct udphdr));
			skip -= sizeof(struct udphdr);

			espstat.esps_udpencin++;
			ipsec_common_input(m, skip, protoff,
			    srcsa.sa.sa_family, IPPROTO_ESP, 1);
			return IPPROTO_DONE;
		}
	}
#endif

	switch (srcsa.sa.sa_family) {
	case AF_INET:
		bzero(&srcsa, sizeof(struct sockaddr_in));
		srcsa.sin.sin_len = sizeof(struct sockaddr_in);
		srcsa.sin.sin_family = AF_INET;
		srcsa.sin.sin_port = uh->uh_sport;
		srcsa.sin.sin_addr = ip->ip_src;

		bzero(&dstsa, sizeof(struct sockaddr_in));
		dstsa.sin.sin_len = sizeof(struct sockaddr_in);
		dstsa.sin.sin_family = AF_INET;
		dstsa.sin.sin_port = uh->uh_dport;
		dstsa.sin.sin_addr = ip->ip_dst;
		break;
#ifdef INET6
	case AF_INET6:
		bzero(&srcsa, sizeof(struct sockaddr_in6));
		srcsa.sin6.sin6_len = sizeof(struct sockaddr_in6);
		srcsa.sin6.sin6_family = AF_INET6;
		srcsa.sin6.sin6_port = uh->uh_sport;
#if 0 /*XXX inbound flowinfo */
		srcsa.sin6.sin6_flowinfo = htonl(0x0fffffff) & ip6->ip6_flow;
#endif
		/* KAME hack: recover scopeid */
		in6_recoverscope(&srcsa.sin6, &ip6->ip6_src);

		bzero(&dstsa, sizeof(struct sockaddr_in6));
		dstsa.sin6.sin6_len = sizeof(struct sockaddr_in6);
		dstsa.sin6.sin6_family = AF_INET6;
		dstsa.sin6.sin6_port = uh->uh_dport;
#if 0 /*XXX inbound flowinfo */
		dstsa.sin6.sin6_flowinfo = htonl(0x0fffffff) & ip6->ip6_flow;
#endif
		/* KAME hack: recover scopeid */
		in6_recoverscope(&dstsa.sin6, &ip6->ip6_dst);
		break;
#endif /* INET6 */
	}

#if NVXLAN > 0
	if (vxlan_enable > 0 &&
#if NPF > 0
	    !(m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) &&
#endif
	    vxlan_lookup(m, uh, iphlen, &srcsa.sa, &dstsa.sa) != 0)
		return IPPROTO_DONE;
#endif

	if (m->m_flags & (M_BCAST|M_MCAST)) {
		struct inpcb *last;
		/*
		 * Deliver a multicast or broadcast datagram to *all* sockets
		 * for which the local and remote addresses and ports match
		 * those of the incoming datagram.  This allows more than
		 * one process to receive multi/broadcasts on the same port.
		 * (This really ought to be done for unicast datagrams as
		 * well, but that would cause problems with existing
		 * applications that open both address-specific sockets and
		 * a wildcard socket listening to the same port -- they would
		 * end up receiving duplicates of every unicast datagram.
		 * Those applications open the multiple sockets to overcome an
		 * inadequacy of the UDP socket interface, but for backwards
		 * compatibility we avoid the problem here rather than
		 * fixing the interface.  Maybe 4.5BSD will remedy this?)
		 */

		iphlen += sizeof(struct udphdr);

		/*
		 * Locate pcb(s) for datagram.
		 * (Algorithm copied from raw_intr().)
		 */
		last = NULL;
		TAILQ_FOREACH(inp, &udbtable.inpt_queue, inp_queue) {
			if (inp->inp_socket->so_state & SS_CANTRCVMORE)
				continue;
#ifdef INET6
			/* don't accept it if AF does not match */
			if (ip6 && !(inp->inp_flags & INP_IPV6))
				continue;
			if (!ip6 && (inp->inp_flags & INP_IPV6))
				continue;
#endif
			if (rtable_l2(inp->inp_rtableid) !=
			    rtable_l2(m->m_pkthdr.ph_rtableid))
				continue;
			if (inp->inp_lport != uh->uh_dport)
				continue;
#ifdef INET6
			if (ip6) {
				if (inp->inp_ip6_minhlim &&
				    inp->inp_ip6_minhlim > ip6->ip6_hlim)
					continue;
				if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
					if (!IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6,
					    &ip6->ip6_dst))
						continue;
			} else
#endif /* INET6 */
			{
				if (inp->inp_ip_minttl &&
				    inp->inp_ip_minttl > ip->ip_ttl)
					continue;

				if (inp->inp_laddr.s_addr != INADDR_ANY) {
					if (inp->inp_laddr.s_addr !=
					    ip->ip_dst.s_addr)
						continue;
				}
			}
#ifdef INET6
			if (ip6) {
				if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
					if (!IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6,
					    &ip6->ip6_src) ||
					    inp->inp_fport != uh->uh_sport)
						continue;
			} else
#endif /* INET6 */
			if (inp->inp_faddr.s_addr != INADDR_ANY) {
				if (inp->inp_faddr.s_addr !=
				    ip->ip_src.s_addr ||
				    inp->inp_fport != uh->uh_sport)
					continue;
			}

			if (last != NULL) {
				struct mbuf *n;

				n = m_copym(m, 0, M_COPYALL, M_NOWAIT);
				if (n != NULL) {
#ifdef INET6
					if (ip6 && (last->inp_flags &
					    IN6P_CONTROLOPTS ||
					    last->inp_socket->so_options &
					    SO_TIMESTAMP))
						ip6_savecontrol(last, n, &opts);
#endif /* INET6 */
					if (ip && (last->inp_flags &
					    INP_CONTROLOPTS ||
					    last->inp_socket->so_options &
					    SO_TIMESTAMP))
						ip_savecontrol(last, &opts,
						    ip, n);

					m_adj(n, iphlen);
					if (sbappendaddr(
					    &last->inp_socket->so_rcv,
					    &srcsa.sa, n, opts) == 0) {
						m_freem(n);
						m_freem(opts);
						udpstat_inc(udps_fullsock);
					} else
						sorwakeup(last->inp_socket);
					opts = NULL;
				}
			}
			last = inp;
			/*
			 * Don't look for additional matches if this one does
			 * not have either the SO_REUSEPORT or SO_REUSEADDR
			 * socket options set.  This heuristic avoids searching
			 * through all pcbs in the common case of a non-shared
			 * port.  It assumes that an application will never
			 * clear these options after setting them.
			 */
			if ((last->inp_socket->so_options & (SO_REUSEPORT |
			    SO_REUSEADDR)) == 0)
				break;
		}

		if (last == NULL) {
			/*
			 * No matching pcb found; discard datagram.
			 * (No need to send an ICMP Port Unreachable
			 * for a broadcast or multicast datgram.)
			 */
			udpstat_inc(udps_noportbcast);
			goto bad;
		}

#ifdef INET6
		if (ip6 && (last->inp_flags & IN6P_CONTROLOPTS ||
		    last->inp_socket->so_options & SO_TIMESTAMP))
			ip6_savecontrol(last, m, &opts);
#endif /* INET6 */
		if (ip && (last->inp_flags & INP_CONTROLOPTS ||
		    last->inp_socket->so_options & SO_TIMESTAMP))
			ip_savecontrol(last, &opts, ip, m);

		m_adj(m, iphlen);
		if (sbappendaddr(&last->inp_socket->so_rcv,
		    &srcsa.sa, m, opts) == 0) {
			udpstat_inc(udps_fullsock);
			goto bad;
		}
		sorwakeup(last->inp_socket);
		return IPPROTO_DONE;
	}
	/*
	 * Locate pcb for datagram.
	 */
#if NPF > 0 && 0  /* currently disabled */
	inp = pf_inp_lookup(m);
#endif
	if (inp == NULL) {
#ifdef INET6
		if (ip6)
			inp = in6_pcbhashlookup(&udbtable, &ip6->ip6_src,
			    uh->uh_sport, &ip6->ip6_dst, uh->uh_dport,
			    m->m_pkthdr.ph_rtableid);
		else
#endif /* INET6 */
		inp = in_pcbhashlookup(&udbtable, ip->ip_src, uh->uh_sport,
		    ip->ip_dst, uh->uh_dport, m->m_pkthdr.ph_rtableid);
	}
	if (inp == 0) {
		int	inpl_reverse = 0;
		if (m->m_pkthdr.pf.flags & PF_TAG_TRANSLATE_LOCALHOST)
			inpl_reverse = 1;
		udpstat_inc(udps_pcbhashmiss);
#ifdef INET6
		if (ip6) {
			inp = in6_pcblookup_listen(&udbtable,
			    &ip6->ip6_dst, uh->uh_dport, inpl_reverse, m,
			    m->m_pkthdr.ph_rtableid);
		} else
#endif /* INET6 */
		inp = in_pcblookup_listen(&udbtable,
		    ip->ip_dst, uh->uh_dport, inpl_reverse, m,
		    m->m_pkthdr.ph_rtableid);
		if (inp == 0) {
			udpstat_inc(udps_noport);
			if (m->m_flags & (M_BCAST | M_MCAST)) {
				udpstat_inc(udps_noportbcast);
				goto bad;
			}
#ifdef INET6
			if (ip6) {
				uh->uh_sum = savesum;
				icmp6_error(m, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_NOPORT,0);
			} else
#endif /* INET6 */
			{
				*ip = save_ip;
				uh->uh_sum = savesum;
				icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_PORT,
				    0, 0);
			}
			return IPPROTO_DONE;
		}
	}
	KASSERT(sotoinpcb(inp->inp_socket) == inp);

#ifdef INET6
	if (ip6 && inp->inp_ip6_minhlim &&
	    inp->inp_ip6_minhlim > ip6->ip6_hlim) {
		goto bad;
	} else
#endif
	if (ip && inp->inp_ip_minttl &&
	    inp->inp_ip_minttl > ip->ip_ttl) {
		goto bad;
	}

#if NPF > 0
	if (inp->inp_socket->so_state & SS_ISCONNECTED)
		pf_inp_link(m, inp);
#endif

#ifdef IPSEC
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
	if (mtag != NULL) {
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->rdomain, tdbi->spi,
		    &tdbi->dst, tdbi->proto);
	} else
		tdb = NULL;
	ipsp_spd_lookup(m, srcsa.sa.sa_family, iphlen, &error,
	    IPSP_DIRECTION_IN, tdb, inp, 0);
	if (error) {
		udpstat_inc(udps_nosec);
		goto bad;
	}
	/* create ipsec options while we know that tdb cannot be modified */
	if (tdb && tdb->tdb_ids)
		ipsecflowinfo = tdb->tdb_ids->id_flow;
#endif /*IPSEC */

	opts = NULL;
#ifdef INET6
	if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS ||
	    inp->inp_socket->so_options & SO_TIMESTAMP))
		ip6_savecontrol(inp, m, &opts);
#endif /* INET6 */
	if (ip && (inp->inp_flags & INP_CONTROLOPTS ||
	    inp->inp_socket->so_options & SO_TIMESTAMP))
		ip_savecontrol(inp, &opts, ip, m);
#ifdef INET6
	if (ip6 && (inp->inp_flags & IN6P_RECVDSTPORT)) {
		struct mbuf **mp = &opts;

		while (*mp)
			mp = &(*mp)->m_next;
		*mp = sbcreatecontrol((caddr_t)&uh->uh_dport, sizeof(u_int16_t),
		    IPV6_RECVDSTPORT, IPPROTO_IPV6);
	}
#endif /* INET6 */
	if (ip && (inp->inp_flags & INP_RECVDSTPORT)) {
		struct mbuf **mp = &opts;

		while (*mp)
			mp = &(*mp)->m_next;
		*mp = sbcreatecontrol((caddr_t)&uh->uh_dport, sizeof(u_int16_t),
		    IP_RECVDSTPORT, IPPROTO_IP);
	}
#ifdef IPSEC
	if (ipsecflowinfo && (inp->inp_flags & INP_IPSECFLOWINFO)) {
		struct mbuf **mp = &opts;

		while (*mp)
			mp = &(*mp)->m_next;
		*mp = sbcreatecontrol((caddr_t)&ipsecflowinfo,
		    sizeof(u_int32_t), IP_IPSECFLOWINFO, IPPROTO_IP);
	}
#endif
#ifdef PIPEX
	if (pipex_enable && inp->inp_pipex) {
		struct pipex_session *session;
		int off = iphlen + sizeof(struct udphdr);
		if ((session = pipex_l2tp_lookup_session(m, off)) != NULL) {
			if ((m = pipex_l2tp_input(m, off, session,
			    ipsecflowinfo)) == NULL) {
				m_freem(opts);
				/* the packet is handled by PIPEX */
				return IPPROTO_DONE;
			}
		}
	}
#endif

	iphlen += sizeof(struct udphdr);
	m_adj(m, iphlen);
	if (sbappendaddr(&inp->inp_socket->so_rcv, &srcsa.sa, m, opts) == 0) {
		udpstat_inc(udps_fullsock);
		goto bad;
	}
	sorwakeup(inp->inp_socket);
	return IPPROTO_DONE;
bad:
	m_freem(m);
	m_freem(opts);
	return IPPROTO_DONE;
}

/*
 * Notify a udp user of an asynchronous error;
 * just wake up so that he can collect error status.
 */
void
udp_notify(struct inpcb *inp, int errno)
{
	inp->inp_socket->so_error = errno;
	sorwakeup(inp->inp_socket);
	sowwakeup(inp->inp_socket);
}

#ifdef INET6
void
udp6_ctlinput(int cmd, struct sockaddr *sa, u_int rdomain, void *d)
{
	struct udphdr uh;
	struct sockaddr_in6 sa6;
	struct ip6_hdr *ip6;
	struct mbuf *m;
	int off;
	void *cmdarg;
	struct ip6ctlparam *ip6cp = NULL;
	struct udp_portonly {
		u_int16_t uh_sport;
		u_int16_t uh_dport;
	} *uhp;
	void (*notify)(struct inpcb *, int) = udp_notify;

	if (sa == NULL)
		return;
	if (sa->sa_family != AF_INET6 ||
	    sa->sa_len != sizeof(struct sockaddr_in6))
		return;

	if ((unsigned)cmd >= PRC_NCMDS)
		return;
	if (PRC_IS_REDIRECT(cmd))
		notify = in_rtchange, d = NULL;
	else if (cmd == PRC_HOSTDEAD)
		d = NULL;
	else if (cmd == PRC_MSGSIZE)
		; /* special code is present, see below */
	else if (inet6ctlerrmap[cmd] == 0)
		return;

	/* if the parameter is from icmp6, decode it. */
	if (d != NULL) {
		ip6cp = (struct ip6ctlparam *)d;
		m = ip6cp->ip6c_m;
		ip6 = ip6cp->ip6c_ip6;
		off = ip6cp->ip6c_off;
		cmdarg = ip6cp->ip6c_cmdarg;
	} else {
		m = NULL;
		ip6 = NULL;
		cmdarg = NULL;
		/* XXX: translate addresses into internal form */
		sa6 = *satosin6(sa);
		if (in6_embedscope(&sa6.sin6_addr, &sa6, NULL)) {
			/* should be impossible */
			return;
		}
	}

	if (ip6cp && ip6cp->ip6c_finaldst) {
		bzero(&sa6, sizeof(sa6));
		sa6.sin6_family = AF_INET6;
		sa6.sin6_len = sizeof(sa6);
		sa6.sin6_addr = *ip6cp->ip6c_finaldst;
		/* XXX: assuming M is valid in this case */
		sa6.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.ph_ifidx,
		    ip6cp->ip6c_finaldst);
		if (in6_embedscope(ip6cp->ip6c_finaldst, &sa6, NULL)) {
			/* should be impossible */
			return;
		}
	} else {
		/* XXX: translate addresses into internal form */
		sa6 = *satosin6(sa);
		if (in6_embedscope(&sa6.sin6_addr, &sa6, NULL)) {
			/* should be impossible */
			return;
		}
	}

	if (ip6) {
		/*
		 * XXX: We assume that when IPV6 is non NULL,
		 * M and OFF are valid.
		 */
		struct sockaddr_in6 sa6_src;

		/* check if we can safely examine src and dst ports */
		if (m->m_pkthdr.len < off + sizeof(*uhp))
			return;

		bzero(&uh, sizeof(uh));
		m_copydata(m, off, sizeof(*uhp), (caddr_t)&uh);

		bzero(&sa6_src, sizeof(sa6_src));
		sa6_src.sin6_family = AF_INET6;
		sa6_src.sin6_len = sizeof(sa6_src);
		sa6_src.sin6_addr = ip6->ip6_src;
		sa6_src.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.ph_ifidx,
		    &ip6->ip6_src);
		if (in6_embedscope(&sa6_src.sin6_addr, &sa6_src, NULL)) {
			/* should be impossible */
			return;
		}

		if (cmd == PRC_MSGSIZE) {
			int valid = 0;

			/*
			 * Check to see if we have a valid UDP socket
			 * corresponding to the address in the ICMPv6 message
			 * payload.
			 */
			if (in6_pcbhashlookup(&udbtable, &sa6.sin6_addr,
			    uh.uh_dport, &sa6_src.sin6_addr, uh.uh_sport,
			    rdomain))
				valid = 1;
#if 0
			/*
			 * As the use of sendto(2) is fairly popular,
			 * we may want to allow non-connected pcb too.
			 * But it could be too weak against attacks...
			 * We should at least check if the local address (= s)
			 * is really ours.
			 */
			else if (in6_pcblookup_listen(&udbtable,
			    &sa6_src.sin6_addr, uh.uh_sport, 0,
			    rdomain))
				valid = 1;
#endif

			/*
			 * Depending on the value of "valid" and routing table
			 * size (mtudisc_{hi,lo}wat), we will:
			 * - recalculate the new MTU and create the
			 *   corresponding routing entry, or
			 * - ignore the MTU change notification.
			 */
			icmp6_mtudisc_update((struct ip6ctlparam *)d, valid);

			/*
			 * regardless of if we called icmp6_mtudisc_update(),
			 * we need to call in6_pcbnotify(), to notify path
			 * MTU change to the userland (2292bis-02), because
			 * some unconnected sockets may share the same
			 * destination and want to know the path MTU.
			 */
		}

		(void) in6_pcbnotify(&udbtable, &sa6, uh.uh_dport,
		    &sa6_src, uh.uh_sport, rdomain, cmd, cmdarg, notify);
	} else {
		(void) in6_pcbnotify(&udbtable, &sa6, 0,
		    &sa6_any, 0, rdomain, cmd, cmdarg, notify);
	}
}
#endif

void
udp_ctlinput(int cmd, struct sockaddr *sa, u_int rdomain, void *v)
{
	struct ip *ip = v;
	struct udphdr *uhp;
	struct in_addr faddr;
	struct inpcb *inp;
	void (*notify)(struct inpcb *, int) = udp_notify;
	int errno;

	if (sa == NULL)
		return;
	if (sa->sa_family != AF_INET ||
	    sa->sa_len != sizeof(struct sockaddr_in))
		return;
	faddr = satosin(sa)->sin_addr;
	if (faddr.s_addr == INADDR_ANY)
		return;

	if ((unsigned)cmd >= PRC_NCMDS)
		return;
	errno = inetctlerrmap[cmd];
	if (PRC_IS_REDIRECT(cmd))
		notify = in_rtchange, ip = 0;
	else if (cmd == PRC_HOSTDEAD)
		ip = 0;
	else if (errno == 0)
		return;
	if (ip) {
		uhp = (struct udphdr *)((caddr_t)ip + (ip->ip_hl << 2));

#ifdef IPSEC
		/* PMTU discovery for udpencap */
		if (cmd == PRC_MSGSIZE && ip_mtudisc && udpencap_enable &&
		    udpencap_port && uhp->uh_sport == htons(udpencap_port)) {
			udpencap_ctlinput(cmd, sa, rdomain, v);
			return;
		}
#endif
		inp = in_pcbhashlookup(&udbtable,
		    ip->ip_dst, uhp->uh_dport, ip->ip_src, uhp->uh_sport,
		    rdomain);
		if (inp && inp->inp_socket != NULL)
			notify(inp, errno);
	} else
		in_pcbnotifyall(&udbtable, sa, rdomain, errno, notify);
}

int
udp_output(struct inpcb *inp, struct mbuf *m, struct mbuf *addr,
    struct mbuf *control)
{
	struct sockaddr_in *sin = NULL;
	struct udpiphdr *ui;
	u_int32_t ipsecflowinfo = 0;
	struct sockaddr_in src_sin;
	int len = m->m_pkthdr.len;
	struct in_addr *laddr;
	int error = 0;

#ifdef DIAGNOSTIC
	if ((inp->inp_flags & INP_IPV6) != 0)
		panic("IPv6 inpcb to %s", __func__);
#endif

	/*
	 * Compute the packet length of the IP header, and
	 * punt if the length looks bogus.
	 */
	if ((len + sizeof(struct udpiphdr)) > IP_MAXPACKET) {
		error = EMSGSIZE;
		goto release;
	}

	memset(&src_sin, 0, sizeof(src_sin));

	if (control) {
		u_int clen;
		struct cmsghdr *cm;
		caddr_t cmsgs;

		/*
		 * XXX: Currently, we assume all the optional information is
		 * stored in a single mbuf.
		 */
		if (control->m_next) {
			error = EINVAL;
			goto release;
		}

		clen = control->m_len;
		cmsgs = mtod(control, caddr_t);
		do {
			if (clen < CMSG_LEN(0)) {
				error = EINVAL;
				goto release;
			}
			cm = (struct cmsghdr *)cmsgs;
			if (cm->cmsg_len < CMSG_LEN(0) ||
			    CMSG_ALIGN(cm->cmsg_len) > clen) {
				error = EINVAL;
				goto release;
			}
#ifdef IPSEC
			if ((inp->inp_flags & INP_IPSECFLOWINFO) != 0 &&
			    cm->cmsg_len == CMSG_LEN(sizeof(ipsecflowinfo)) &&
			    cm->cmsg_level == IPPROTO_IP &&
			    cm->cmsg_type == IP_IPSECFLOWINFO) {
				ipsecflowinfo = *(u_int32_t *)CMSG_DATA(cm);
			} else
#endif
			if (cm->cmsg_len == CMSG_LEN(sizeof(struct in_addr)) &&
			    cm->cmsg_level == IPPROTO_IP &&
			    cm->cmsg_type == IP_SENDSRCADDR) {
				memcpy(&src_sin.sin_addr, CMSG_DATA(cm),
				    sizeof(struct in_addr));
				src_sin.sin_family = AF_INET;
				src_sin.sin_len = sizeof(src_sin);
				/* no check on reuse when sin->sin_port == 0 */
				if ((error = in_pcbaddrisavail(inp, &src_sin,
				    0, curproc)))
					goto release;
			}
			clen -= CMSG_ALIGN(cm->cmsg_len);
			cmsgs += CMSG_ALIGN(cm->cmsg_len);
		} while (clen);
	}

	if (addr) {
		sin = mtod(addr, struct sockaddr_in *);

		if (addr->m_len != sizeof(*sin)) {
			error = EINVAL;
			goto release;
		}
		if (sin->sin_family != AF_INET) {
			error = EAFNOSUPPORT;
			goto release;
		}
		if (sin->sin_port == 0) {
			error = EADDRNOTAVAIL;
			goto release;
		}

		if (inp->inp_faddr.s_addr != INADDR_ANY) {
			error = EISCONN;
			goto release;
		}

		error = in_pcbselsrc(&laddr, sin, inp);
		if (error)
			goto release;

		if (inp->inp_lport == 0) {
			error = in_pcbbind(inp, NULL, curproc);
			if (error)
				goto release;
		}

		if (src_sin.sin_len > 0 &&
		    src_sin.sin_addr.s_addr != INADDR_ANY &&
		    src_sin.sin_addr.s_addr != inp->inp_laddr.s_addr) {
			src_sin.sin_port = inp->inp_lport;
			if (inp->inp_laddr.s_addr != INADDR_ANY &&
			    (error =
			    in_pcbaddrisavail(inp, &src_sin, 0, curproc)))
				goto release;
			laddr = &src_sin.sin_addr;
		}
	} else {
		if (inp->inp_faddr.s_addr == INADDR_ANY) {
			error = ENOTCONN;
			goto release;
		}
		laddr = &inp->inp_laddr;
	}

	/*
	 * Calculate data length and get a mbuf
	 * for UDP and IP headers.
	 */
	M_PREPEND(m, sizeof(struct udpiphdr), M_DONTWAIT);
	if (m == NULL) {
		error = ENOBUFS;
		goto bail;
	}

	/*
	 * Fill in mbuf with extended UDP header
	 * and addresses and length put into network format.
	 */
	ui = mtod(m, struct udpiphdr *);
	bzero(ui->ui_x1, sizeof ui->ui_x1);
	ui->ui_pr = IPPROTO_UDP;
	ui->ui_len = htons((u_int16_t)len + sizeof (struct udphdr));
	ui->ui_src = *laddr;
	ui->ui_dst = sin ? sin->sin_addr : inp->inp_faddr;
	ui->ui_sport = inp->inp_lport;
	ui->ui_dport = sin ? sin->sin_port : inp->inp_fport;
	ui->ui_ulen = ui->ui_len;
	((struct ip *)ui)->ip_len = htons(sizeof (struct udpiphdr) + len);
	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;
	((struct ip *)ui)->ip_tos = inp->inp_ip.ip_tos;
	if (udpcksum)
		m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;

	udpstat_inc(udps_opackets);

	/* force routing table */
	m->m_pkthdr.ph_rtableid = inp->inp_rtableid;

#if NPF > 0
	if (inp->inp_socket->so_state & SS_ISCONNECTED)
		m->m_pkthdr.pf.inp = inp;
#endif

	error = ip_output(m, inp->inp_options, &inp->inp_route,
	    (inp->inp_socket->so_options & SO_BROADCAST), inp->inp_moptions,
	    inp, ipsecflowinfo);
	if (error == EACCES)	/* translate pf(4) error for userland */
		error = EHOSTUNREACH;

bail:
	m_freem(control);
	return (error);

release:
	m_freem(m);
	goto bail;
}

/*ARGSUSED*/
int
udp_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *addr,
    struct mbuf *control, struct proc *p)
{
	struct inpcb *inp;
	int error = 0;

	NET_ASSERT_LOCKED();

	if (req == PRU_CONTROL) {
#ifdef INET6
		if (sotopf(so) == PF_INET6)
			return (in6_control(so, (u_long)m, (caddr_t)addr,
			    (struct ifnet *)control));
		else
#endif /* INET6 */
			return (in_control(so, (u_long)m, (caddr_t)addr,
			    (struct ifnet *)control));
	}

	inp = sotoinpcb(so);
	if (inp == NULL) {
		error = EINVAL;
		goto release;
	}

	/*
	 * Note: need to block udp_input while changing
	 * the udp pcb queue and/or pcb addresses.
	 */
	switch (req) {

	case PRU_DETACH:
		in_pcbdetach(inp);
		break;

	case PRU_BIND:
		error = in_pcbbind(inp, addr, p);
		break;

	case PRU_LISTEN:
		error = EOPNOTSUPP;
		break;

	case PRU_CONNECT:
#ifdef INET6
		if (inp->inp_flags & INP_IPV6) {
			if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6)) {
				error = EISCONN;
				break;
			}
			error = in6_pcbconnect(inp, addr);
		} else
#endif /* INET6 */
		{
			if (inp->inp_faddr.s_addr != INADDR_ANY) {
				error = EISCONN;
				break;
			}
			error = in_pcbconnect(inp, addr);
		}

		if (error == 0)
			soisconnected(so);
		break;

	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	case PRU_ACCEPT:
		error = EOPNOTSUPP;
		break;

	case PRU_DISCONNECT:
#ifdef INET6
		if (inp->inp_flags & INP_IPV6) {
			if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6)) {
				error = ENOTCONN;
				break;
			}
		} else
#endif /* INET6 */
		{
			if (inp->inp_faddr.s_addr == INADDR_ANY) {
				error = ENOTCONN;
				break;
			}
		}

#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			inp->inp_laddr6 = in6addr_any;
		else
#endif /* INET6 */
			inp->inp_laddr.s_addr = INADDR_ANY;
		in_pcbdisconnect(inp);

		so->so_state &= ~SS_ISCONNECTED;		/* XXX */
		break;

	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	case PRU_SEND:
#ifdef PIPEX
		if (inp->inp_pipex) {
			struct pipex_session *session;

			if (addr != NULL) 
				session =
				    pipex_l2tp_userland_lookup_session(m,
					mtod(addr, struct sockaddr *));
			else
#ifdef INET6
			if (inp->inp_flags & INP_IPV6)
				session =
				    pipex_l2tp_userland_lookup_session_ipv6(
					m, inp->inp_faddr6);
			else
#endif
				session =
				    pipex_l2tp_userland_lookup_session_ipv4(
					m, inp->inp_faddr);
			if (session != NULL)
				if ((m = pipex_l2tp_userland_output(
				    m, session)) == NULL) {
					error = ENOMEM;
					goto release;
				}
		}
#endif

#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			error = udp6_output(inp, m, addr, control);
		else
#endif
			error = udp_output(inp, m, addr, control);
		return (error);

	case PRU_ABORT:
		soisdisconnected(so);
		in_pcbdetach(inp);
		break;

	case PRU_SOCKADDR:
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			in6_setsockaddr(inp, addr);
		else
#endif /* INET6 */
			in_setsockaddr(inp, addr);
		break;

	case PRU_PEERADDR:
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			in6_setpeeraddr(inp, addr);
		else
#endif /* INET6 */
			in_setpeeraddr(inp, addr);
		break;

	case PRU_SENSE:
		/*
		 * stat: don't bother with a blocksize.
		 */
		/*
		 * Perhaps Path MTU might be returned for a connected
		 * UDP socket in this case.
		 */
		return (0);

	case PRU_SENDOOB:
	case PRU_FASTTIMO:
	case PRU_SLOWTIMO:
	case PRU_PROTORCV:
	case PRU_PROTOSEND:
		error =  EOPNOTSUPP;
		break;

	case PRU_RCVD:
	case PRU_RCVOOB:
		return (EOPNOTSUPP);	/* do not free mbuf's */

	default:
		panic("udp_usrreq");
	}

release:
	m_freem(control);
	m_freem(m);
	return (error);
}

int
udp_attach(struct socket *so, int proto)
{
	int error;

	if (so->so_pcb != NULL)
		return EINVAL;

	if ((error = soreserve(so, udp_sendspace, udp_recvspace)) ||
	    (error = in_pcballoc(so, &udbtable)))
		return error;
#ifdef INET6
	if (sotoinpcb(so)->inp_flags & INP_IPV6)
		sotoinpcb(so)->inp_ipv6.ip6_hlim = ip6_defhlim;
	else
#endif /* INET6 */
		sotoinpcb(so)->inp_ip.ip_ttl = ip_defttl;
	return 0;
}

/*
 * Sysctl for udp variables.
 */
int
udp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case UDPCTL_BADDYNAMIC:
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    baddynamicports.udp, sizeof(baddynamicports.udp)));

	case UDPCTL_ROOTONLY:
		if (newp && securelevel > 0)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    rootonlyports.udp, sizeof(rootonlyports.udp)));

	case UDPCTL_STATS:
		if (newp != NULL)
			return (EPERM);

		return (udp_sysctl_udpstat(oldp, oldlenp, newp));

	default:
		if (name[0] < UDPCTL_MAXID)
			return (sysctl_int_arr(udpctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}

int
udp_sysctl_udpstat(void *oldp, size_t *oldlenp, void *newp)
{
	uint64_t counters[udps_ncounters];
	struct udpstat udpstat;
	u_long *words = (u_long *)&udpstat;
	int i;

	CTASSERT(sizeof(udpstat) == (nitems(counters) * sizeof(u_long)));

	counters_read(udpcounters, counters, nitems(counters));

	for (i = 0; i < nitems(counters); i++)
		words[i] = (u_long)counters[i];

	return (sysctl_rdstruct(oldp, oldlenp, newp,
	    &udpstat, sizeof(udpstat)));
}
@


1.231
log
@Always allocate counters memory using type M_COUNTERS.

This makes the API simpler, and is probably more useful than spreading
counters memory other several types, making it harder to track.

Prodded by mpi, ok mpi@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.230 2017/01/31 10:24:41 jca Exp $	*/
d1118 1
a1118 1
	if (inp == NULL && req != PRU_ATTACH) {
a1128 16
	case PRU_ATTACH:
		if (inp != NULL) {
			error = EINVAL;
			break;
		}
		if ((error = soreserve(so, udp_sendspace, udp_recvspace)) ||
		    (error = in_pcballoc(so, &udbtable)))
			break;
#ifdef INET6
		if (sotoinpcb(so)->inp_flags & INP_IPV6)
			sotoinpcb(so)->inp_ipv6.ip6_hlim = ip6_defhlim;
		else
#endif /* INET6 */
			sotoinpcb(so)->inp_ip.ip_ttl = ip_defttl;
		break;

d1292 20
@


1.230
log
@Use CTASSERT instead of KASSERT for a few sysctl that use the counters API

ok dlg@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.229 2017/01/29 19:58:47 bluhm Exp $	*/
d146 1
a146 1
	udpcounters = counters_alloc(udps_ncounters, M_COUNTERS);
@


1.229
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.228 2017/01/26 13:03:47 bluhm Exp $	*/
d1355 1
a1355 1
	KASSERT(sizeof(udpstat) == (nitems(counters) * sizeof(u_long)));
@


1.228
log
@Reduce the difference between struct protosw and ip6protosw.  The
IPv4 pr_ctlinput functions did return a void pointer that was always
NULL and never used.  Make all functions void like in the IPv6 case.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.227 2017/01/25 17:34:31 bluhm Exp $	*/
a149 1
#ifdef INET6
d151 1
a151 1
udp6_input(struct mbuf **mp, int *offp, int proto)
d154 1
a154 9

	udp_input(m, *offp, proto);
	return IPPROTO_DONE;
}
#endif

void
udp_input(struct mbuf *m, int iphlen, int proto)
{
d212 1
a212 1
		return;
d318 1
a318 1
			return;
d328 1
a328 1
				return;
d340 1
a340 1
			return;
d390 1
a390 1
		return;
d542 1
a542 1
		return;
d595 1
a595 1
			return;
d680 2
a681 1
				return; /* the packet is handled by PIPEX */
d694 1
a694 1
	return;
d698 1
@


1.227
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.226 2016/12/19 15:47:19 mpi Exp $	*/
d872 1
a872 1
void *
d883 1
a883 1
		return NULL;
d886 1
a886 1
		return NULL;
d889 1
a889 1
		return NULL;
d892 1
a892 1
		return NULL;
d899 1
a899 1
		return NULL;
d908 1
a908 1
			return (NULL);
a917 1
	return (NULL);
@


1.226
log
@Remove redundant splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.225 2016/12/19 08:36:49 mpi Exp $	*/
d162 1
a162 1
udp_input(struct mbuf *m, ...)
d169 1
a169 2
	int iphlen, len;
	va_list ap;
a189 4

	va_start(ap, m);
	iphlen = va_arg(ap, int);
	va_end(ap);
@


1.225
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.224 2016/12/10 13:22:57 patrick Exp $	*/
a1031 1
			int s = splsoftnet();
a1032 1
			splx(s);
@


1.224
log
@Pass the correct offset of the next protocol field for the given IP
version to the upper layers.  The stack will set this field to IPIP
later on, so make sure it doesn't overwrite the packet in the wrong
location.

ok bluhm@@ deraadt@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.223 2016/11/28 10:49:35 mpi Exp $	*/
d1119 1
a1119 1
	splsoftassert(IPL_SOFTNET);
@


1.223
log
@Allow to build kernels without IPSEC but with PIPEX.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.222 2016/11/21 09:09:06 mpi Exp $	*/
d186 1
a186 1
	int error;
d205 3
d214 3
d352 1
a352 1
			ipsec_common_input(m, skip, offsetof(struct ip, ip_p),
@


1.222
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.221 2016/11/18 02:53:47 dlg Exp $	*/
d187 2
d190 1
a190 1
#endif /* IPSEC */
@


1.221
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the udpstat struct.

udpstat_inc(udps_foo) replaces udpstat.udps_foo++ for the actual
updates. udpstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the udpstat struct for
now.

ok mpi@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.220 2016/11/03 18:42:35 mikeb Exp $	*/
d1110 2
a1111 1
	int s;
a1123 1
	s = splsoftnet();
a1259 1
		splx(s);
a1292 1
		splx(s);
a1304 1
		splx(s);
a1311 1
	splx(s);
@


1.220
log
@Remove obsolete vxlan_lookup return value handling

With input from reyk@@, OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.219 2016/09/03 13:46:57 reyk Exp $	*/
d133 1
a133 1
struct	udpstat udpstat;
d137 1
d146 1
d194 1
a194 1
	udpstat.udps_ipackets++;
d217 1
a217 1
		udpstat.udps_hdrops++;
d223 1
a223 1
		udpstat.udps_noport++;
d236 1
a236 1
				udpstat.udps_badlen++;
d248 1
a248 1
			udpstat.udps_badlen++;
d281 1
a281 1
		udpstat.udps_nosum++;
d292 1
a292 1
				udpstat.udps_badsum++;
d295 1
a295 1
			udpstat.udps_inswcsum++;
d306 1
a306 1
				udpstat.udps_badsum++;
d333 1
a333 1
				udpstat.udps_hdrops++;
d502 1
a502 1
						udpstat.udps_fullsock++;
d528 1
a528 1
			udpstat.udps_noportbcast++;
d544 1
a544 1
			udpstat.udps_fullsock++;
d571 1
a571 1
		++udpstat.udps_pcbhashmiss;
d583 1
a583 1
			udpstat.udps_noport++;
d585 1
a585 1
				udpstat.udps_noportbcast++;
d633 1
a633 1
		udpstat.udps_nosec++;
d695 1
a695 1
		udpstat.udps_fullsock++;
d1078 1
a1078 1
	udpstat.udps_opackets++;
d1346 2
a1347 2
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &udpstat, sizeof(udpstat)));
d1356 19
@


1.219
log
@Add support for a multipoint-to-multipoint mode in vxlan(4).  In this
mode, vxlan(4) must be configured to accept any virtual network
identifier with "vnetid any" and added to a bridge(4) or switch(4).
This way the driver will dynamically learn the tunnel endpoints and
their vnetids for the responses and can be used to dynamically bridge
between VXLANs.  It is also being used in combination with switch(4)
and the OpenFlow tunnel classifiers.

With input from yasuoka@@ goda@@
OK deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.218 2016/08/16 22:21:17 vgross Exp $	*/
d393 1
a393 5
	    (error = vxlan_lookup(m, uh, iphlen, &srcsa.sa, &dstsa.sa)) != 0) {
		if (error == -1) {
			udpstat.udps_hdrops++;
			m_freem(m);
		}
a394 1
	}
@


1.218
log
@Add IP_SENDSRCADDR cmsg for UDP sockets. As suggested by sthen@@,
IP_SENDSRCADDR == IP_RECVDSTADDR.

OK sthen@@ jca@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.217 2016/08/04 20:46:24 vgross Exp $	*/
d176 1
a176 1
	} srcsa;
d356 6
d374 10
d393 1
a393 1
	    (error = vxlan_lookup(m, uh, iphlen, &srcsa.sa)) != 0) {
@


1.217
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.216 2016/07/22 11:14:41 mpi Exp $	*/
d912 1
d931 2
d966 13
a978 1
				break;
a979 1
#endif
d1016 11
@


1.216
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.214 2016/06/28 11:22:53 jca Exp $	*/
d992 1
a992 2
		error = in_selectsrc(&laddr, sin, inp->inp_moptions,
		    &inp->inp_route, &inp->inp_laddr, inp->inp_rtableid);
@


1.215
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@d992 2
a993 1
		error = in_pcbselsrc(&laddr, sin, inp);
@


1.214
log
@Add UDP unicast and multicast support for IP_MINTTL/IPV6_MINHOPCOUNT

Requested by renato@@, ok blumh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.213 2016/06/18 10:36:13 vgross Exp $	*/
d992 1
a992 2
		error = in_selectsrc(&laddr, sin, inp->inp_moptions,
		    &inp->inp_route, &inp->inp_laddr, inp->inp_rtableid);
@


1.213
log
@Add net.inet.{tcp,udp}.rootonly sysctl, to mark which ports
cannot be bound to by non-root users.

Ok millert@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.212 2016/06/15 16:06:35 vgross Exp $	*/
d428 3
d437 3
a439 2
			if (inp->inp_laddr.s_addr != INADDR_ANY) {
				if (inp->inp_laddr.s_addr != ip->ip_dst.s_addr)
d441 6
d592 11
@


1.212
log
@Fix typo from rebase : extra parenthese
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.211 2016/06/15 15:16:47 vgross Exp $	*/
d1278 6
@


1.211
log
@Move the cmsg handling code on top of udp_output(), to make
IP_SENDSRCADDR introduction easier.

Ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.210 2016/03/23 15:50:36 vgross Exp $	*/
d937 1
a937 1
			if ((inp->inp_flags & INP_IPSECFLOWINFO) != 0) &&
@


1.210
log
@Merge in_pcbbind() and in6_pcbbind(), and change every call to
in6_pcbbind() into in_pcbbind().

Ok jca@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.209 2016/03/07 18:44:00 naddy Exp $	*/
d909 41
a990 39
#ifdef IPSEC
	if (control && (inp->inp_flags & INP_IPSECFLOWINFO) != 0) {
		u_int clen;
		struct cmsghdr *cm;
		caddr_t cmsgs;

		/*
		 * XXX: Currently, we assume all the optional information is stored
		 * in a single mbuf.
		 */
		if (control->m_next) {
			error = EINVAL;
			goto release;
		}

		clen = control->m_len;
		cmsgs = mtod(control, caddr_t);
		do {
			if (clen < CMSG_LEN(0)) {
				error = EINVAL;
				goto release;
			}
			cm = (struct cmsghdr *)cmsgs;
			if (cm->cmsg_len < CMSG_LEN(0) ||
			    CMSG_ALIGN(cm->cmsg_len) > clen) {
				error = EINVAL;
				goto release;
			}
			if (cm->cmsg_len == CMSG_LEN(sizeof(ipsecflowinfo)) &&
			    cm->cmsg_level == IPPROTO_IP &&
			    cm->cmsg_type == IP_IPSECFLOWINFO) {
				ipsecflowinfo = *(u_int32_t *)CMSG_DATA(cm);
				break;
			}
			clen -= CMSG_ALIGN(cm->cmsg_len);
			cmsgs += CMSG_ALIGN(cm->cmsg_len);
		} while (clen);
	}
#endif
@


1.209
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.208 2015/12/03 14:05:28 bluhm Exp $	*/
d1097 1
a1097 6
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			error = in6_pcbbind(inp, addr, p);
		else
#endif
			error = in_pcbbind(inp, addr, p);
@


1.208
log
@To avoid that the stack manipules the pf statekeys directly, introduce
pf_inp_...() lookup, link and unlink functions as an interface.
Locking can be added to them later.  Remove the first linking at
the beginning of tcp_input() and udp_input() as it is not necessary.
It will be done later anyway.  That code was a relict, from the
time before I had added the second linking.
Input from mikeb@@ and sashan@@;  OK sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.207 2015/09/11 07:42:35 claudio Exp $	*/
d143 1
a143 1
udp_init()
@


1.207
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.206 2015/09/10 17:52:05 claudio Exp $	*/
d530 2
a531 6
#if 0
	if (m->m_pkthdr.pf.statekey) {
		inp = m->m_pkthdr.pf.statekey->inp;
		if (inp && inp->inp_pf_sk)
			KASSERT(m->m_pkthdr.pf.statekey == inp->inp_pf_sk);
	}
a542 6
#if NPF > 0
		if (m->m_pkthdr.pf.statekey && inp) {
			m->m_pkthdr.pf.statekey->inp = inp;
			inp->inp_pf_sk = m->m_pkthdr.pf.statekey;
		}
#endif
d584 2
a585 7
	if (m->m_pkthdr.pf.statekey && !m->m_pkthdr.pf.statekey->inp &&
	    !inp->inp_pf_sk && (inp->inp_socket->so_state & SS_ISCONNECTED)) {
		m->m_pkthdr.pf.statekey->inp = inp;
		inp->inp_pf_sk = m->m_pkthdr.pf.statekey;
	}
	/* The statekey has finished finding the inp, it is no longer needed. */
	m->m_pkthdr.pf.statekey = NULL;
@


1.206
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.205 2015/08/14 18:07:28 bluhm Exp $	*/
d745 1
a745 1
		if (in6_embedscope(&sa6.sin6_addr, &sa6, NULL, NULL)) {
d759 1
a759 1
		if (in6_embedscope(ip6cp->ip6c_finaldst, &sa6, NULL, NULL)) {
d766 1
a766 1
		if (in6_embedscope(&sa6.sin6_addr, &sa6, NULL, NULL)) {
d792 1
a792 1
		if (in6_embedscope(&sa6_src.sin6_addr, &sa6_src, NULL, NULL)) {
@


1.205
log
@Replace sockaddr casts with the proper satosin() or satosin6() calls.
From David Hill;  OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.204 2015/07/15 22:16:42 deraadt Exp $	*/
d367 1
a367 1
		(void)in6_recoverscope(&srcsa.sin6, &ip6->ip6_src, NULL);
@


1.204
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.203 2015/07/08 08:48:34 mpi Exp $	*/
d744 1
a744 1
		sa6 = *(struct sockaddr_in6 *)sa;
d765 1
a765 1
		sa6 = *(struct sockaddr_in6 *)sa;
@


1.203
log
@Pass an interface index instead of a pointer to in6_addr2scopeid().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.202 2015/06/30 15:30:17 mpi Exp $	*/
d478 1
a478 2
						if (opts)
							m_freem(opts);
d666 1
a666 2
				if (opts)
					m_freem(opts);
d683 1
a683 2
	if (opts)
		m_freem(opts);
d1050 1
a1050 2
	if (control)
		m_freem(control);
d1276 2
a1277 5
	if (control) {
		m_freem(control);
	}
	if (m)
		m_freem(m);
@


1.202
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.201 2015/06/16 11:09:40 mpi Exp $	*/
d760 2
a761 2
		sa6.sin6_scope_id = in6_addr2scopeid(
		    if_get(m->m_pkthdr.ph_ifidx), ip6cp->ip6c_finaldst);
d793 2
a794 2
		sa6_src.sin6_scope_id = in6_addr2scopeid(
		    if_get(m->m_pkthdr.ph_ifidx), &ip6->ip6_src);
@


1.201
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.200 2015/06/05 21:41:43 krw Exp $	*/
d457 2
a458 1
				if ((n = m_copy(m, 0, M_COPYALL)) != NULL) {
@


1.200
log
@Try harder to avoid (very unlikely) NULL pointer de-ref by tweaking
code to use sotopf() like tcp_usrreq() does. Also following
tcp_usrreq(), put more stuff under splsoftnet. And as a result
in-line code in udp_detach() and nuke udp_detach().

Most ideas from and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.199 2015/05/23 12:38:53 markus Exp $	*/
d759 2
a760 2
		sa6.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.rcvif,
		    ip6cp->ip6c_finaldst);
d792 2
a793 2
		sa6_src.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.rcvif,
		    &ip6->ip6_src);
@


1.199
log
@introduce ipsec-id bundles and use them for ipsecflowinfo,
fixes rekeying for l2tp/ipsec against multiple windows clients
and saves memory (for many SAs to same peers); feedback and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.198 2015/04/16 19:24:13 markus Exp $	*/
d78 1
a135 1
void	udp_detach(struct inpcb *);
d1066 1
a1066 1
	struct inpcb *inp = sotoinpcb(so);
d1072 1
a1072 1
		if (inp->inp_flags & INP_IPV6)
d1080 3
d1087 1
a1098 1
		s = splsoftnet();
d1100 1
a1100 2
		    (error = in_pcballoc(so, &udbtable))) {
			splx(s);
a1101 2
		}
		splx(s);
d1111 1
a1111 1
		udp_detach(inp);
a1114 1
		s = splsoftnet();
a1120 1
		splx(s);
a1133 1
			s = splsoftnet();
a1134 1
			splx(s);
a1141 1
			s = splsoftnet();
a1142 1
			splx(s);
a1172 1
		s = splsoftnet();
a1180 1
		splx(s);
d1219 1
a1219 1
			return (udp6_output(inp, m, addr, control));
a1220 3
			return (udp_output(inp, m, addr, control));
#else
		return (udp_output(inp, m, addr, control));
d1222 3
d1228 1
a1228 1
		udp_detach(inp);
d1257 1
d1270 1
d1278 1
a1284 9
}

void
udp_detach(struct inpcb *inp)
{
	int s = splsoftnet();

	in_pcbdetach(inp);
	splx(s);
@


1.198
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.197 2015/04/14 12:22:15 mikeb Exp $	*/
d618 2
a619 2
	if (tdb)
		ipsecflowinfo = tdb->tdb_spi;
@


1.197
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.196 2015/03/04 11:10:55 mpi Exp $	*/
a616 24

	/* Latch SA only if the socket is connected */
	if (inp->inp_tdb_in != tdb &&
	    (inp->inp_socket->so_state & SS_ISCONNECTED)) {
		if (tdb) {
			tdb_add_inp(tdb, inp, 1);
			if (inp->inp_ipo == NULL) {
				inp->inp_ipo = ipsec_add_policy(inp,
				    srcsa.sa.sa_family, IPSP_DIRECTION_OUT);
				if (inp->inp_ipo == NULL) {
					goto bad;
				}
			}
			if (inp->inp_ipo->ipo_dstid == NULL &&
			    tdb->tdb_srcid != NULL) {
				inp->inp_ipo->ipo_dstid = tdb->tdb_srcid;
				tdb->tdb_srcid->ref_count++;
			}
		} else { /* Just reset */
			TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp,
			    inp_tdb_in_next);
			inp->inp_tdb_in = NULL;
		}
	}
a619 1

@


1.196
log
@Do not check if the interface index matches the scope when all we want
is to clear the damn embedded scope.

At this point the receiving interface should not matter and will in the
future be cleared to prevent such layer violations.

This prevent exporting addresses with embedded scope to userland.

Found the hardway by and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.195 2014/12/05 15:50:04 mpi Exp $	*/
a633 12
			}
			if (inp->inp_ipsec_remotecred == NULL &&
			    tdb->tdb_remote_cred != NULL) {
				inp->inp_ipsec_remotecred =
				    tdb->tdb_remote_cred;
				tdb->tdb_remote_cred->ref_count++;
			}
			if (inp->inp_ipsec_remoteauth == NULL &&
			    tdb->tdb_remote_auth != NULL) {
				inp->inp_ipsec_remoteauth =
				    tdb->tdb_remote_auth;
				tdb->tdb_remote_auth->ref_count++;
@


1.195
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.194 2014/11/25 12:13:59 mpi Exp $	*/
d176 1
a176 1
	} srcsa, dstsa;
a355 6

		bzero(&dstsa, sizeof(struct sockaddr_in));
		dstsa.sin.sin_len = sizeof(struct sockaddr_in);
		dstsa.sin.sin_family = AF_INET;
		dstsa.sin.sin_port = uh->uh_dport;
		dstsa.sin.sin_addr = ip->ip_dst;
d367 1
a367 10
		(void)in6_recoverscope(&srcsa.sin6, &ip6->ip6_src,
		    m->m_pkthdr.rcvif);

		bzero(&dstsa, sizeof(struct sockaddr_in6));
		dstsa.sin6.sin6_len = sizeof(struct sockaddr_in6);
		dstsa.sin6.sin6_family = AF_INET6;
		dstsa.sin6.sin6_port = uh->uh_dport;
		/* KAME hack: recover scopeid */
		(void)in6_recoverscope(&dstsa.sin6, &ip6->ip6_dst,
		    m->m_pkthdr.rcvif);
@


1.194
log
@unifdef -USCOPEDROUTING, no object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.193 2014/11/20 14:51:42 krw Exp $	*/
d80 1
@


1.193
log
@Yet more #include de-duplication.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.192 2014/11/20 11:05:19 mpi Exp $	*/
a797 1
#ifndef SCOPEDROUTING
a801 1
#endif
a811 1
#ifndef SCOPEDROUTING
a815 1
#endif
a818 1
#ifndef SCOPEDROUTING
a822 1
#endif
a844 1
#ifndef SCOPEDROUTING
a848 1
#endif
@


1.192
log
@In TCP and UDP layers do not (ab)use the receiving interface to check
for a multicast/broadcast destination address.

These checks have already been done in the Ethernet and IP layers and
the mbuf(9) should contain all the required information at this point.
But since we cannot trust this spaghetti stack, be paranoid and make
sure to set the flags in the IP input routines.

Use explicit comments, requested by deraadt@@.  ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.191 2014/11/09 22:05:08 bluhm Exp $	*/
a97 3
#ifndef INET
#include <netinet/in.h>
#endif
@


1.191
log
@To implement transparent relays for connectionless protocols, the
pf the state has to vanish immediately when the relay closes the
socket.  To make this work reliably, the linkage between state and
socket must be established with the first packet.  This packet could
be incomming or outgoing.
Link the pf state in the socket layer earlier.  This makes all tests
in /usr/src/regress/sys/net/pf_divert pass.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.190 2014/09/14 14:17:26 jsg Exp $	*/
d403 1
a403 10
#ifdef INET6
	if ((ip6 && IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) ||
	    (ip && IN_MULTICAST(ip->ip_dst.s_addr)) ||
	    (ip && in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif,
	    m->m_pkthdr.ph_rtableid))) {
#else /* INET6 */
	if (IN_MULTICAST(ip->ip_dst.s_addr) ||
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif,
		m->m_pkthdr.ph_rtableid)) {
#endif /* INET6 */
@


1.190
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.189 2014/07/22 11:06:10 mpi Exp $	*/
d620 5
d1110 5
@


1.189
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.188 2014/07/12 21:06:34 yasuoka Exp $	*/
a76 1
#include <sys/proc.h>
@


1.188
log
@Resize the pcb hashtable automatically.  The table size will be doubled
when the number of the hash entries reaches 75% of the table size.

ok dlg henning, 'commit in' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.187 2014/07/11 13:15:34 bluhm Exp $	*/
a84 1
#include <netinet/in_systm.h>
@


1.187
log
@There is a use-after-free somewhere in the code that links the pf
state to the socket pcb.  Add an additional assert to narrow down
the panics.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.186 2014/06/23 22:48:33 deraadt Exp $	*/
d142 2
a143 2
#ifndef	UDBHASHSIZE
#define	UDBHASHSIZE	128
a144 1
int	udbhashsize = UDBHASHSIZE;
d149 1
a149 1
	in_pcbinit(&udbtable, udbhashsize);
@


1.186
log
@repair ramdisk builds
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.185 2014/06/23 11:51:42 yasuoka Exp $	*/
d560 1
a560 1
	if (m->m_pkthdr.pf.statekey)
d562 3
@


1.185
log
@Fix compile without IPSEC.

Pointed out by Ivan Solonin.
ok henning mpi jca
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.184 2014/04/23 12:25:35 mpi Exp $	*/
a188 1
#endif /* IPSEC */
d191 1
@


1.184
log
@Don't use varargs for udp_output() and sync the argument order with
udp6_output().

ok henning@@, reyk@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.183 2014/04/21 12:22:26 henning Exp $	*/
d189 1
a191 1
#endif /* IPSEC */
@


1.183
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.181 2014/04/16 13:04:38 mpi Exp $	*/
d138 3
a140 2
void udp_detach(struct inpcb *);
void udp_notify(struct inpcb *, int);
d142 1
a142 1
#ifndef UDBHASHSIZE
d968 2
a969 1
udp_output(struct mbuf *m, ...)
a970 2
	struct inpcb *inp;
	struct mbuf *addr, *control;
a976 7
	va_list ap;

	va_start(ap, m);
	inp = va_arg(ap, struct inpcb *);
	addr = va_arg(ap, struct mbuf *);
	control = va_arg(ap, struct mbuf *);
	va_end(ap);
d980 1
a980 1
		panic("IPv6 inpcb to udp_output");
d1290 1
a1290 1
			return (udp_output(m, inp, addr, control));
d1292 1
a1292 1
		return (udp_output(m, inp, addr, control));
@


1.182
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@d1114 2
a1115 2
	    (inp->inp_socket->so_options & SO_BROADCAST) | IP_IPSECFLOW,
	    inp->inp_moptions, inp, ipsecflowinfo);
@


1.181
log
@Merge in_fixaddr() into in_selectsrc() in order to prepare for
IP_SENDSRCADDR support.  This reduces the differences with the
IPv6 version and kill some comments that are no longer true.

ok jca@@, chrisz@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.180 2014/04/14 09:06:42 mpi Exp $	*/
d1020 3
a1022 5
		laddr = in_selectsrc(sin, inp->inp_moptions, &inp->inp_route,
		    &inp->inp_laddr, &error, inp->inp_rtableid);
		if (laddr == NULL) {
			if (error == 0)
				error = EADDRNOTAVAIL;
a1023 1
		}
@


1.180
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.179 2014/04/07 19:51:15 chrisz Exp $	*/
d975 1
a975 1
	struct in_addr laddr = { INADDR_ANY };
d1001 1
d1006 9
d1019 6
a1024 1
		if ((error = in_fixaddr(inp, sin, &laddr)))
d1026 1
d1032 2
a1033 1
			if (error) goto release;
d1040 1
a1040 2
		if (laddr.s_addr == INADDR_ANY)
			laddr = inp->inp_laddr;
d1100 1
a1100 1
	ui->ui_src = laddr;
@


1.179
log
@In udp_output() also use the correct source address in case of an unbound socket.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.178 2014/04/07 10:04:17 mpi Exp $	*/
d409 1
a409 1
	    m->m_pkthdr.rdomain))) {
d412 2
a413 1
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif, m->m_pkthdr.rdomain)) {
d450 1
a450 1
			    rtable_l2(m->m_pkthdr.rdomain))
d567 1
a567 1
			    m->m_pkthdr.rdomain);
d571 1
a571 1
		    ip->ip_dst, uh->uh_dport, m->m_pkthdr.rdomain);
d588 1
a588 1
			    m->m_pkthdr.rdomain);
d593 1
a593 1
		    m->m_pkthdr.rdomain);
d1097 2
a1098 2
	/* force routing domain */
	m->m_pkthdr.rdomain = inp->inp_rtableid;
@


1.178
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.175 2014/03/27 13:27:28 mpi Exp $	*/
d1022 2
@


1.177
log
@get rid of expensive temporary connect in udp_output().

Also fixes a possible memory leak where m doesn't get freed in bail case.

"lets do it like this" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.176 2014/03/28 08:33:51 sthen Exp $	*/
d1098 2
a1099 2
	    (inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST))
	    |IP_IPSECFLOW, inp->inp_moptions, inp, ipsecflowinfo);
@


1.176
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.174 2014/01/24 18:54:58 henning Exp $	*/
d970 1
d974 2
a975 2
	struct in_addr laddr;
	int s = 0, error = 0;
d999 5
a1003 1
		laddr = inp->inp_laddr;
d1008 6
a1013 6
		/*
		 * Must block input while temporarily connected.
		 */
		s = splsoftnet();
		error = in_pcbconnect(inp, addr);
		if (error) {
d1015 1
a1015 1
			goto release;
d1036 1
a1036 1
			goto bail;
d1044 1
a1044 1
				goto bail;
d1050 1
a1050 1
				goto bail;
d1081 2
a1082 2
	ui->ui_src = inp->inp_laddr;
	ui->ui_dst = inp->inp_faddr;
d1084 1
a1084 1
	ui->ui_dport = inp->inp_fport;
a1103 5
	if (addr) {
		inp->inp_laddr = laddr;
		in_pcbdisconnect(inp);
		splx(s);
	}
d1110 1
a1110 3
	if (control)
		m_freem(control);
	return (error);
@


1.175
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d1093 2
a1094 2
	    (inp->inp_socket->so_options & SO_BROADCAST) | IP_IPSECFLOW,
	    inp->inp_moptions, inp, ipsecflowinfo);
@


1.174
log
@clearing the _CSUM_IN_OK flags is now utterly pointless, was only done for
statistics sideeffects before. ok lteo naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.171 2013/11/22 07:59:09 mpi Exp $	*/
d1093 2
a1094 2
	    (inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST))
	    |IP_IPSECFLOW, inp->inp_moptions, inp, ipsecflowinfo);
@


1.173
log
@since the cksum rewrite the counters for hardware checksummed packets
are are lie, since the software engine emulates hardware offloading
and that is later indistinguishable. so kill the hw cksummed counters.
introduce software checksummed packet counters instead.
tcp/udp handles ip & ipvshit, ip cksum covered, 6 has no ip layer cksum.
as before we still have a miscounting bug for inbound with pf on, to be
fixed in the next step.
found by, prodding & ok naddy
@
text
@d311 1
a311 3
		} else
			/* XXXHB20140123 */
			m->m_pkthdr.csum_flags &= ~M_UDP_CSUM_IN_OK;
@


1.172
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@a294 1
				udpstat.udps_inhwcsum++;
d297 1
d311 2
a312 1
		} else {
a313 2
			udpstat.udps_inhwcsum++;
		}
@


1.171
log
@Remove unused proc argument in in6_control().

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.170 2013/10/20 11:03:01 phessler Exp $	*/
d441 1
a441 1
		CIRCLEQ_FOREACH(inp, &udbtable.inpt_queue, inp_queue) {
@


1.170
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.169 2013/10/19 10:38:55 henning Exp $	*/
d1131 1
a1131 1
			    (struct ifnet *)control, 0));
@


1.169
log
@make in_proto_cksum_out not rely on the pseudo header checksum to be
already there, just compute it - it's dirt cheap. since that happens
very late in ip_output, the rest of the stack doesn't have to care about
checksums at all any more, if something needs to be checksummed, just
set the flag on the pkthdr mbuf to indicate so.
stop pre-computing the pseudo header checksum and incrementally updating it
in the tcp and udp stacks.
ok lteo florian
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.167 2013/10/13 10:10:04 reyk Exp $	*/
d568 2
a569 1
			    uh->uh_sport, &ip6->ip6_dst, uh->uh_dport);
d589 2
a590 1
			    &ip6->ip6_dst, uh->uh_dport, inpl_reverse, m);
d875 2
a876 1
			    uh.uh_dport, &sa6_src.sin6_addr, uh.uh_sport))
d887 2
a888 1
			    &sa6_src.sin6_addr, uh.uh_sport, 0);
d911 1
a911 1
		    &sa6_src, uh.uh_sport, cmd, cmdarg, notify);
d914 1
a914 1
		    &sa6_any, 0, cmd, cmdarg, notify);
@


1.168
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@a1079 12

	/*
	 * Compute the pseudo-header checksum; defer further checksumming
	 * until ip_output() or hardware (if it exists).
	 */
	if (udpcksum) {
		m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
		ui->ui_sum = in_cksum_phdr(ui->ui_src.s_addr,
		    ui->ui_dst.s_addr, htons((u_int16_t)len +
		    sizeof (struct udphdr) + IPPROTO_UDP));
	} else
		ui->ui_sum = 0;
d1083 2
@


1.167
log
@Import vxlan(4), the virtual extensible local area network tunnel
interface.  VXLAN is a UDP-based tunnelling protocol for overlaying
virtualized layer 2 networks over layer 3 networks. The implementation
is based on draft-mahalingam-dutt-dcops-vxlan-04 and has been tested
with other implementations in the wild.

put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.166 2013/09/06 18:35:16 bluhm Exp $	*/
d103 1
@


1.166
log
@In one core dump the pointers to socket, inpcb, tcpcb on the stack
of tcp_input() and tcp_output() were very inconsistent.  Especially
the so->so_pcb is NULL which can only happen after the inp has been
detached.  The whole issue looks similar to the old panic:
pool_do_get(inpcbpl): free list modified.
http://marc.info/?l=openbsd-bugs&m=132630237316970&w=2

To get more information, add some asserts that guarantee the
consistency of the socket, inpcb, tcpcb linking.  They should trigger
when an inp is taken from the pcb hashes after it has been freed.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.165 2013/07/31 15:41:52 mikeb Exp $	*/
d81 1
d117 5
d392 14
@


1.165
log
@Move bridge_broadcast and subsequently all IPsec SPD lookup code out
of the IPL_NET.  pf_test should be no longer called under IPL_NET as
well.  The problem became evident after the related issue was brought
up by David Hill <dhill at mindcry ! org>.

With input from and OK mpi.  Tested by David and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.164 2013/06/09 22:03:06 yasuoka Exp $	*/
d595 1
@


1.164
log
@Increment udpstat.udps_nosec and tcpstat.tcps_rcvnosec in case packet is
dropped by IPsec security policy.

input from and ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.163 2013/06/01 16:22:05 bluhm Exp $	*/
d181 1
a181 1
	int error, s;
a602 1
	s = splnet();
a612 1
		splx(s);
a624 1
					splx(s);
a654 1
	splx(s);
@


1.163
log
@Pass the routing domain to IPv6 pr_ctlinput() like in IPv4.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.162 2013/05/31 13:15:53 bluhm Exp $	*/
d613 1
@


1.162
log
@The function rip6_ctlinput() claims that sa6_src is constant to
allow the assingment of &sa6_any.  But rip6_ctlinput() could not
guarantee that as it casted away the const attribute when it passes
the pointer to in6_pcbnotify().  Replace sockaddr with const
sockaddr_in6 in the in6_pcbnotify() parameters.  This reduces the
number of casts.  Also adjust in6_pcbhashlookup() to handle the
const attribute correctly.
Input and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.161 2013/05/17 09:04:30 mpi Exp $	*/
d740 1
a740 1
udp6_ctlinput(int cmd, struct sockaddr *sa, void *d)
@


1.161
log
@Move an extern declaration into its corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.160 2013/04/10 08:50:59 mpi Exp $	*/
d887 2
a888 3
		(void) in6_pcbnotify(&udbtable, (struct sockaddr *)&sa6,
		    uh.uh_dport, (struct sockaddr *)&sa6_src,
		    uh.uh_sport, cmd, cmdarg, notify);
d890 2
a891 2
		(void) in6_pcbnotify(&udbtable, (struct sockaddr *)&sa6, 0,
		    (struct sockaddr *)&sa6_any, 0, cmd, cmdarg, notify);
@


1.160
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.159 2013/04/04 19:23:39 bluhm Exp $	*/
a137 3

/* from in_pcb.c */
extern	struct baddynamicports baddynamicports;
@


1.159
log
@Merge the duplicate IPv4 and IPv6 checksum checking code in udp_input()
into one block.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.158 2013/04/02 18:27:47 bluhm Exp $	*/
d102 1
a103 2

extern int ip6_defhlim;
a906 1
	extern int inetctlerrmap[];
@


1.158
log
@Use macros sotoinpcb() and intotcpcb() instead of casts.  Use NULL
instead of 0 for pointers.  No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.157 2013/03/31 11:18:35 bluhm Exp $	*/
a261 6
	/*
	 * Checksum extended UDP header and data.
	 * from W.R.Stevens: check incoming udp cksums even if
	 *	udpcksum is not set.
	 */
	savesum = uh->uh_sum;
d270 2
d273 9
d285 1
a285 2
		if (uh->uh_sum == 0) {
			udpstat.udps_nosum++;
d287 2
a288 1
		}
d296 9
a304 2
			if ((uh->uh_sum = in6_cksum(m, IPPROTO_UDP,
			    iphlen, len))) {
d312 1
a312 23
	} else
#endif /* INET6 */
	if (uh->uh_sum) {
		if ((m->m_pkthdr.csum_flags & M_UDP_CSUM_IN_OK) == 0) {
			if (m->m_pkthdr.csum_flags & M_UDP_CSUM_IN_BAD) {
				udpstat.udps_badsum++;
				udpstat.udps_inhwcsum++;
				m_freem(m);
				return;
			}

			if ((uh->uh_sum = in4_cksum(m, IPPROTO_UDP,
			    iphlen, len))) {
				udpstat.udps_badsum++;
				m_freem(m);
				return;
			}
		} else {
			m->m_pkthdr.csum_flags &= ~M_UDP_CSUM_IN_OK;
			udpstat.udps_inhwcsum++;
		}
	} else
		udpstat.udps_nosum++;
@


1.157
log
@The call to in_pcballoc() in user request attach was handled in
three different ways.  Use the same code in udp_usrreq() and
rip_usrreq() and rip6_usrreq(). This also fixes a pcb and socket
leak in udp_usrreq() in case soreserve() fails.  Put an splsoftassert()
into in_pcballoc() for safety.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.156 2013/03/31 00:59:52 bluhm Exp $	*/
d1163 2
a1164 3
		if (((struct inpcb *)so->so_pcb)->inp_flags & INP_IPV6)
			((struct inpcb *) so->so_pcb)->inp_ipv6.ip6_hlim =
			    ip6_defhlim;
d1167 1
a1167 1
			((struct inpcb *) so->so_pcb)->inp_ip.ip_ttl = ip_defttl;
@


1.156
log
@Do not transfer diverted packets into IPsec processing.  They should
reach the socket that the user has specified in pf.conf.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.155 2013/03/29 13:16:14 bluhm Exp $	*/
d1156 5
a1160 1
		error = in_pcballoc(so, &udbtable);
a1161 5
		if (error)
			break;
		error = soreserve(so, udp_sendspace, udp_recvspace);
		if (error)
			break;
@


1.155
log
@Declare struct pf_state_key in the mbuf and in_pcb header files to
avoid ugly casts.
OK krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.154 2013/03/14 11:18:37 mpi Exp $	*/
d326 3
@


1.154
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.153 2013/02/16 14:34:52 bluhm Exp $	*/
d552 1
a552 1
		inp = ((struct pf_state_key *)m->m_pkthdr.pf.statekey)->inp;
d565 1
a565 2
			((struct pf_state_key *)m->m_pkthdr.pf.statekey)->inp =
			    inp;
@


1.153
log
@Fix a bug in udp socket splicing in case a packet gets diverted and
spliced and routed to loopback.  The content of the pf header in
the mbuf was keeping the divert information on its way.  Reinitialize
the whole packet header of the mbuf and remove the mbuf tags when
the packet gets spliced.
OK claudio@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.152 2013/01/17 11:43:06 bluhm Exp $	*/
a106 5
#include "faith.h"
#if NFAITH > 0
#include <net/if_types.h>
#endif

a153 10

#if NFAITH > 0
	if (m->m_pkthdr.rcvif) {
		if (m->m_pkthdr.rcvif->if_type == IFT_FAITH) {
			/* XXX send icmp6 host/port unreach? */
			m_freem(m);
			return IPPROTO_DONE;
		}
	}
#endif
@


1.152
log
@After finding the socket's inp by using the pf's statekey, reset
the pointer to the statekey in the mbuf.
When an UDP socket is spliced, pf would use this key during ip_output()
although the packet went through two sockets in the meantime.  Reset
the mbuf's statekey in tcp_input() and udp_input() to eliminate the
pointer to pf lingering in the socket buffers.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.151 2012/09/28 16:06:20 markus Exp $	*/
d624 1
a624 5
	/*
	 * The statekey has finished finding the inp, it is no longer needed.
	 * If UDP socket splicing is used, the statekey will confuse pf when
	 * the same packet goes through ip_output().  So reset the statekey.
	 */
@


1.151
log
@free the control message in udp_input() if the packet is passed to pipex
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.150 2012/09/17 20:01:26 yasuoka Exp $	*/
d622 9
@


1.150
log
@add IPV6_RECVDSTPORT socket option, which enables us to get original
(= before divert) destination port of a UDP packet.  The way to use
this option is same as IP_RECVDSTPORT.

from UMEZAWA Takeshi
tweaks from jmc; ok henning bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.149 2012/07/17 03:18:57 yasuoka Exp $	*/
d725 3
a727 1
			    ipsecflowinfo)) == NULL)
d729 1
@


1.149
log
@use IPsec flowinfo on pipex(4) to select the IPsec tunnel for sending
L2TP packets.

ok markus henning
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.148 2012/07/16 18:05:36 markus Exp $	*/
d691 10
@


1.148
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.147 2012/04/04 04:31:38 yasuoka Exp $	*/
a199 1
	struct mbuf *iopts = NULL;
d201 1
d676 3
a678 3
	if (tdb && (inp->inp_flags & INP_IPSECFLOWINFO))
		iopts = sbcreatecontrol((caddr_t)&tdb->tdb_spi,
		    sizeof(tdb->tdb_spi), IP_IPSECFLOWINFO, IPPROTO_IP);
d700 7
a706 3
	if (iopts) {
		iopts->m_next = opts;
		opts = iopts; /* prepend */
d714 2
a715 1
			if ((m = pipex_l2tp_input(m, off, session)) == NULL)
@


1.147
log
@pipex hook in udp_usrreq() mistakenly assumed that `inp' is connected.
It could not use the destination address properly, so it failed to
find the pipex session.  This bug caused LCP keepalive failures on some
clients.

found and tested by sebastia@@ and mxb at alumni.chalmers.se.
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.146 2012/03/17 10:16:41 dlg Exp $	*/
d200 1
d633 1
a633 1
	    IPSP_DIRECTION_IN, tdb, inp);
d675 4
d699 6
d957 1
d1004 40
d1089 2
a1090 2
	    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
	    inp->inp_moptions, inp);
@


1.146
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.145 2011/07/08 18:30:17 yasuoka Exp $	*/
d1200 6
@


1.145
log
@Include PIPEX in kernel by default.  And add new sysctl variable
`net.pipex.enable' to enable PIPEX.   By default, pipex is disabled
and it will not process packets from wire.  Update man pages and
update HOWTO_PIPEX_NPPPD.txt for testers.

discussed with dlg@@, ok deraadt@@ mcbride@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.144 2011/05/13 14:31:17 oga Exp $	*/
d1037 1
a1037 2
	    inp->inp_socket->so_options &
	    (SO_DONTROUTE | SO_BROADCAST | SO_JUMBO),
@


1.144
log
@Revert the pf->socket linking diff.

at least krw@@, pirofti@@ and todd@@ have been seeing panics (todd and krw
with xxxterm not sure about pirofti) involving pool corruption while
using this commit.

krw and todd confirm that this backout fixes the problem.

ok blambert@@ krw@@, todd@@ henning@@ and kettenis@@

	    Double link between pf states and sockets.  Henning has
	    already implemented half of it.  The additional part is: -
	    The pf state lookup for outgoing packets is optimized by
	    using mbuf->inp->state.
	    - For incomming tcp, udp, raw, raw6 packets the socket
	    lookup always is optimized by using mbuf->state->inp.
	    - All protocols establish the link for incomming packets.
	    - All protocols set the inp in the mbuf for outgoing packets.
	      This allows the linkage beginning with the first packet
	      for outgoing connections.
	    - In case of divert states, delete the state when the socket
	      closes.  Otherwise new connections could match on old
	      states instead of being diverted to the listen socket.
	    ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.143 2011/05/04 16:05:49 blambert Exp $	*/
d695 1
a695 1
	if (inp->inp_pipex) {
@


1.143
log
@Collapse m_pullup and m_pullup2 into a single function, as they're
essentially identical; the only difference being that m_pullup2 is
capable of handling mbuf clusters, but called m_pullup for shorter
lengths (!).

testing dlg@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.142 2011/04/28 09:56:27 claudio Exp $	*/
d564 1
a564 1
#if NPF > 0
a621 9
#if NPF > 0
	if (m->m_pkthdr.pf.statekey && !inp->inp_pf_sk &&
	    !((struct pf_state_key *)m->m_pkthdr.pf.statekey)->inp &&
	    (inp->inp_socket->so_state & SS_ISCONNECTED)) {
		((struct pf_state_key *)m->m_pkthdr.pf.statekey)->inp = inp;
		inp->inp_pf_sk = m->m_pkthdr.pf.statekey;
	}
#endif

a1035 4
#if NPF > 0
	if (inp->inp_socket->so_state & SS_ISCONNECTED)
		m->m_pkthdr.pf.inp = inp;
#endif
@


1.142
log
@Make in_broadcast() rdomain aware. Mostly mechanical change.
This fixes the problem of binding sockets to broadcast IPs in other
rdomains.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.141 2011/04/24 19:36:54 bluhm Exp $	*/
d355 1
a355 1
			if ((m = m_pullup2(m, skip)) == NULL) {
@


1.141
log
@Double link between pf states and sockets.  Henning has already
implemented half of it.  The additional part is:
- The pf state lookup for outgoing packets is optimized by using
  mbuf->inp->state.
- For incomming tcp, udp, raw, raw6 packets the socket lookup always
  is optimized by using mbuf->state->inp.
- All protocols establish the link for incomming packets.
- All protocols set the inp in the mbuf for outgoing packets.
  This allows the linkage beginning with the first packet for
  outgoing connections.
- In case of divert states, delete the state when the socket closes.
  Otherwise new connections could match on old states instead of
  being diverted to the listen socket.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.140 2011/04/05 18:01:21 henning Exp $	*/
d415 2
a416 1
	    (ip && in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif))) {
d419 1
a419 1
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif)) {
@


1.140
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.139 2011/04/03 16:09:09 blambert Exp $	*/
d563 1
a563 1
#if 0
d621 9
d1044 4
@


1.139
log
@Don't attempt to enqueue mbufs on sockets marked as SS_CANTRCVMORE, as
was done earlier for routing sockets.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.138 2010/09/24 14:50:30 hsuenaga Exp $	*/
d1020 1
a1020 1
		m->m_pkthdr.csum_flags |= M_UDPV4_CSUM_OUT;
@


1.138
log
@Add L2TP support to PIPEX.
We can use IPv6 address as outer header of L2TP.

Kernel ABI is changed. You must update npppd.

OK @@claudio, yasuoka@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.137 2010/09/08 08:34:42 claudio Exp $	*/
d445 2
@


1.137
log
@Return EACCES when pf_test() blocks a packet in ip_output(). This allows
ip_forward() to know the difference between blocked packets and those that
can't be forwarded (EHOSTUNREACH). Only in the latter case an ICMP should
be sent. In the other callers of ip_output() change the error back to
EHOSTUNREACH since userland may not expect EACCES on a sendto().
OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.136 2010/07/09 16:58:06 reyk Exp $	*/
d117 5
d691 10
d1195 22
@


1.136
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.135 2010/07/03 04:44:51 guenther Exp $	*/
d1022 2
@


1.135
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.134 2010/04/20 22:05:43 tedu Exp $	*/
d619 2
a620 1
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
@


1.134
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.133 2010/03/11 00:24:58 sthen Exp $	*/
d447 2
a448 1
			if (inp->inp_rdomain != rtable_l2(m->m_pkthdr.rdomain))
d1015 1
a1015 1
	m->m_pkthdr.rdomain = inp->inp_rdomain;
@


1.133
log
@unbreak the build with a custom kernel config including "pseudo-device
faith 1", noticed by Andris Kadar.  ok kettenis@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.132 2009/11/13 20:54:05 claudio Exp $	*/
d77 1
@


1.132
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.131 2009/11/03 10:59:04 claudio Exp $	*/
d107 3
@


1.131
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.130 2009/06/08 23:07:08 sthen Exp $	*/
d867 1
a867 1
udp_ctlinput(int cmd, struct sockaddr *sa, void *v)
d902 1
a902 1
			udpencap_ctlinput(cmd, sa, v);
d908 1
a908 1
		    /* XXX */ 0);
d912 1
a912 1
		in_pcbnotifyall(&udbtable, sa, errno, notify);
@


1.130
log
@remove stray * from comment, probably a rewrapping artefact
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.129 2009/06/05 00:05:22 claudio Exp $	*/
d443 1
a443 1
			if (inp->inp_rdomain != m->m_pkthdr.rdomain)
@


1.129
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.128 2009/06/03 18:22:44 naddy Exp $	*/
d512 1
a512 1
			 * port.  It * assumes that an application will never
@


1.128
log
@add the basic infrastructure to take advantage of TCP and UDP receive
checksum offload over IPv6; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.127 2009/06/02 15:32:19 blambert Exp $	*/
d443 2
d563 1
a563 1
		    ip->ip_dst, uh->uh_dport);
d584 2
a585 1
		    ip->ip_dst, uh->uh_dport, inpl_reverse, m);
d907 2
a908 1
		    ip->ip_dst, uhp->uh_dport, ip->ip_src, uhp->uh_sport);
d1008 4
@


1.127
log
@0 -> NULL

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.126 2008/10/13 14:02:20 henning Exp $	*/
d289 15
a303 3
		if ((uh->uh_sum = in6_cksum(m, IPPROTO_UDP, iphlen, len))) {
			udpstat.udps_badsum++;
			goto bad;
@


1.126
log
@disable the pcb linking for udp for the moment since there is some weird
bug with IPv6 in some circumstances. we'll find it one day...
lots of debugging dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.125 2008/09/03 12:51:39 henning Exp $	*/
d957 1
a957 1
	if (m == 0) {
@


1.125
log
@do not set the pkthdr mbuf state key pointer to the state key saved in the
pcb. the state key ptr in the pcb is the one that had to be used by pf
outbound. but by convention the state key pointer in the pkthdr is the one
used INbound, so pf follows its reverse pointer to find the sk to use,
and since a reverse doesn't exist for locally terminated connections the
reverse pointer is null and thus the whole game a noop.
note that this only affects packets FROM local udp/tcp sockets, for the
other direction everything works as expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.124 2008/07/16 09:00:44 henning Exp $	*/
d537 1
a537 1
#if NPF > 0
@


1.124
log
@link udp pcbs to pf states, same as done for tcp already
ok markus, also tested david sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.123 2008/06/14 22:15:30 jsing Exp $	*/
a990 1
	m->m_pkthdr.pf.statekey = inp->inp_pf_sk;
@


1.123
log
@Include "faith.h" in order to get NFAITH. Also clean up NFAITH conditionals
whilst we're here.

ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.122 2008/06/14 19:54:09 jsing Exp $	*/
d108 5
d171 1
a171 1
	struct inpcb *inp;
d537 21
a557 8
#ifdef INET6
	if (ip6)
		inp = in6_pcbhashlookup(&udbtable, &ip6->ip6_src, uh->uh_sport,
		    &ip6->ip6_dst, uh->uh_dport);
	else
#endif /* INET6 */
	inp = in_pcbhashlookup(&udbtable, ip->ip_src, uh->uh_sport,
	    ip->ip_dst, uh->uh_dport);
d991 1
@


1.122
log
@ANSIfy function definitions.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.120 2008/05/23 15:51:12 thib Exp $	*/
d106 2
d146 1
a146 1
#if defined(NFAITH) && 0 < NFAITH
@


1.121
log
@Remove {tcp/udp}6_usrreq(); Since the normal ones now
take a proc argument, theres no need for these, since
they are just wrappers.

OK claudio@@
@
text
@d140 1
a140 3
udp6_input(mp, offp, proto)
	struct mbuf **mp;
	int *offp, proto;
d665 1
a665 3
udp_notify(inp, errno)
	struct inpcb *inp;
	int errno;
d674 1
a674 4
udp6_ctlinput(cmd, sa, d)
	int cmd;
	struct sockaddr *sa;
	void *d;
d832 1
a832 4
udp_ctlinput(cmd, sa, v)
	int cmd;
	struct sockaddr *sa;
	void *v;
d996 2
a997 5
udp_usrreq(so, req, m, addr, control, p)
	struct socket *so;
	int req;
	struct mbuf *m, *addr, *control;
	struct proc *p;
d1200 1
a1200 2
udp_detach(inp)
	struct inpcb *inp;
d1212 2
a1213 7
udp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
@


1.120
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.119 2008/05/15 19:40:38 markus Exp $	*/
a1002 14

#ifdef INET6
/*ARGSUSED*/
int
udp6_usrreq(so, req, m, addr, control, p)
	struct socket *so;
	int req;
	struct mbuf *m, *addr, *control;
	struct proc *p;
{

	return udp_usrreq(so, req, m, addr, control, p);
}
#endif
@


1.119
log
@divert for ipv6; ok henning, pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.118 2008/05/09 02:56:36 markus Exp $	*/
d1014 1
a1014 1
	return udp_usrreq(so, req, m, addr, control);
d1020 1
a1020 1
udp_usrreq(so, req, m, addr, control)
d1024 1
d1080 1
a1080 1
			error = in6_pcbbind(inp, addr);
d1083 1
a1083 1
			error = in_pcbbind(inp, addr);
@


1.118
log
@IP_RECVDSTPORT, allows you to get the destination port of UDP datagrams
for pf(4) diverted packets; based on patch by Scot Loach; ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.117 2008/05/09 02:44:54 markus Exp $	*/
d548 1
a548 1
			    &ip6->ip6_dst, uh->uh_dport, inpl_reverse);
@


1.117
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.116 2008/05/02 06:49:32 ckuethe Exp $	*/
d639 8
@


1.116
log
@Make the SO_TIMESTAMP sockopt work. When set, this allows the user to
get a timestamp of when the datagram was accepted (by udp(4), for
example) rather than having to take a timestamp with gettimeofday(2)
when recv(2) returns - possibly several hundreds of microseconds later.
May be of use to those interested in precision network timing schemes
or QoS for media applications. Tested on alpha, amd64, i386 and sparc64.
manpage suggestions from jmc, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.115 2007/12/13 20:00:53 reyk Exp $	*/
d552 1
a552 1
		    ip->ip_dst, uh->uh_dport, inpl_reverse);
@


1.115
log
@implement sysctls to report IP, TCP, UDP, and ICMP statistics and
change netstat to use them instead of accessing kvm for it. more
protocols will be added later.

discussed with deraadt@@ claudio@@ gilles@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.114 2007/06/11 11:29:35 henning Exp $	*/
d462 3
a464 1
					    IN6P_CONTROLOPTS))
d468 3
a470 1
					    INP_CONTROLOPTS))
d512 2
a513 1
		if (ip6 && (last->inp_flags & IN6P_CONTROLOPTS))
d516 2
a517 1
		if (ip && (last->inp_flags & INP_CONTROLOPTS))
d632 2
a633 1
	if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS))
d636 2
a637 1
	if (ip && (inp->inp_flags & INP_CONTROLOPTS))
@


1.114
log
@there was code inside #if NPF > 0, but pf.h was not included, so it did
not get build. the code looks at flags that used to be in mbuf tags, now
they are in the mbuf header, so we can check them unconditionally.
problem spotted by Daniel Roethlisberger <daniel@@roe.ch>, ok ryan markus
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.113 2007/05/27 20:17:05 dlg Exp $	*/
d1239 7
@


1.113
log
@-static
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.112 2006/12/09 01:12:28 itojun Exp $	*/
d536 1
a536 5
#if NPF > 0
		struct pf_mtag *t;

		if ((t = pf_find_mtag(m)) != NULL &&
		    t->flags & PF_TAG_TRANSLATE_LOCALHOST)
a537 1
#endif
@


1.112
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.111 2006/11/27 11:00:12 claudio Exp $	*/
d121 2
a122 2
static	void udp_detach(struct inpcb *);
static	void udp_notify(struct inpcb *, int);
d655 1
a655 1
static void
d1214 1
a1214 1
static void
@


1.111
log
@The current implementation to handle control options is broken as soon as
SO_REUSEADDR and multicast/broadcast comes into play. Model the ip_savecontrol
handling after the rip_input version which works.
Problem found by Simon Kelley. OK henning@@ michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.110 2006/07/17 12:16:36 claudio Exp $	*/
d463 1
a463 2
						ip6_savecontrol(last, &opts,
						    ip6, n);
d467 2
a468 2
						ip_savecontrol(last, &opts, ip,
						    n);
d509 1
a509 1
			ip6_savecontrol(last, &opts, ip6, m);
d632 1
a632 1
		ip6_savecontrol(inp, &opts, ip6, m);
@


1.110
log
@Call ip_savecontrol() in the multicast codepath of udp_input() similar to
the INET6 code. With this it is possible to use e.g. IP_RECVIF to get the
incomming interface. SOCK_RAW is not affected by this.
Problem found and fixed by Michele 'mydecay' Marchetto. OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.109 2006/06/15 10:12:36 pascoe Exp $	*/
d167 1
a167 1
	struct mbuf *opts = 0;
d394 1
a394 1
		struct socket *last;
d437 1
a437 2
				if (inp->inp_laddr.s_addr !=
				    ip->ip_dst.s_addr)
a459 1
					opts = NULL;
d461 9
a469 5
					if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS))
						ip6_savecontrol(inp, &opts, ip6, n);
#endif /* INET6 */
					if (ip && (inp->inp_flags & INP_CONTROLOPTS))
						ip_savecontrol(inp, &opts, ip, n);
d472 2
a473 1
					if (sbappendaddr(&last->so_rcv,
d480 1
a480 1
						sorwakeup(last);
d484 1
a484 1
			last = inp->inp_socket;
d493 2
a494 1
			if ((last->so_options&(SO_REUSEPORT|SO_REUSEADDR)) == 0)
a507 1
		opts = NULL;
d509 2
a510 2
		if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS))
			ip6_savecontrol(inp, &opts, ip6, m);
d512 2
a513 2
		if (ip && (inp->inp_flags & INP_CONTROLOPTS))
			ip_savecontrol(inp, &opts, ip, m);
d516 1
a516 1
		if (sbappendaddr(&last->so_rcv,
d521 1
a521 1
		sorwakeup(last);
@


1.109
log
@Make number of varargs passed to ip_output match reality.

henning@@ claudio@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.108 2006/05/29 20:42:27 claudio Exp $	*/
d466 3
d509 3
@


1.108
log
@Make savecontrol functions more generic and use them now for raw IP too.
Additionally add the IP_RECVIF option which returns the interface a packet
was received on. OK markus@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.107 2006/05/16 12:39:21 markus Exp $	*/
d966 1
a966 1
	    inp->inp_moptions, inp, (void *)NULL);
@


1.107
log
@- pcbflags is not modified in pcb_(dis)connect, so there's no
  need to save/restore it.
- inp->inp_laddr should be set _before_ calling pcb_disconnect().
  otherwise pcb_disconnect() calls pcb_rehash() with the old laddr.
  [ currently this is not a problem since the hash ignores laddr ]
tested by pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.106 2006/01/13 10:11:23 mpf Exp $	*/
a122 1
static	struct mbuf *udp_saveopt(caddr_t, int, int);
d626 2
a627 2
	if (ip && (inp->inp_flags & INP_CONTROLOPTS)) {
		struct mbuf **mp = &opts;
a628 23
		if (inp->inp_flags & INP_RECVDSTADDR) {
			*mp = udp_saveopt((caddr_t) &ip->ip_dst,
			    sizeof(struct in_addr), IP_RECVDSTADDR);
			if (*mp)
				mp = &(*mp)->m_next;
		}
#ifdef notyet
		/* options were tossed above */
		if (inp->inp_flags & INP_RECVOPTS) {
			*mp = udp_saveopt((caddr_t) opts_deleted_above,
			    sizeof(struct in_addr), IP_RECVOPTS);
			if (*mp)
				mp = &(*mp)->m_next;
		}
		/* ip_srcroute doesn't do what we want here, need to fix */
		if (inp->inp_flags & INP_RECVRETOPTS) {
			*mp = udp_saveopt((caddr_t) ip_srcroute(),
			    sizeof(struct in_addr), IP_RECVRETOPTS);
			if (*mp)
				mp = &(*mp)->m_next;
		}
#endif
	}
a640 25
}

/*
 * Create a "control" mbuf containing the specified data
 * with the specified type for presentation with a datagram.
 */
struct mbuf *
udp_saveopt(p, size, type)
	caddr_t p;
	int size;
	int type;
{
	struct cmsghdr *cp;
	struct mbuf *m;

	if ((m = m_get(M_DONTWAIT, MT_CONTROL)) == NULL)
		return ((struct mbuf *) NULL);
	cp = (struct cmsghdr *) mtod(m, struct cmsghdr *);
	bcopy(p, CMSG_DATA(cp), size);
	size = CMSG_LEN(size);
	m->m_len = size;
	cp->cmsg_len = size;
	cp->cmsg_level = IPPROTO_IP;
	cp->cmsg_type = type;
	return (m);
@


1.106
log
@Path MTU discovery for NAT-T.
OK markus@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.105 2005/10/17 08:43:34 henning Exp $	*/
a929 1
	int pcbflags = 0;
a951 6
		/*
		 * Save current PCB flags because they may change during
		 * temporary connection.
		 */
		pcbflags = inp->inp_flags;

d1019 1
a1020 2
		inp->inp_flags = pcbflags;
		inp->inp_laddr = laddr;
a1170 1
		in_pcbdisconnect(inp);
d1177 1
@


1.105
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.104 2005/05/27 04:55:28 mcbride Exp $	*/
d902 9
d917 1
a917 1
	return NULL;
@


1.104
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.103 2005/04/25 17:55:52 brad Exp $	*/
d528 8
d540 1
a540 2
			    &ip6->ip6_dst, uh->uh_dport, m_tag_find(m,
			    PACKET_TAG_PF_TRANSLATE_LOCALHOST, NULL) != NULL);
d544 1
a544 2
		    ip->ip_dst, uh->uh_dport, m_tag_find(m,
		    PACKET_TAG_PF_TRANSLATE_LOCALHOST, NULL) != NULL);
@


1.103
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.102 2004/08/10 20:11:04 markus Exp $	*/
d1005 2
a1006 1
	    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
@


1.102
log
@replace in_pcbnotify with in_pcbhashlookup and avoid looping over
all connections; ok dhartmei, canacar, mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.101 2004/06/14 05:24:04 mcbride Exp $	*/
d292 2
a293 2
		if ((m->m_pkthdr.csum & M_UDP_CSUM_IN_OK) == 0) {
			if (m->m_pkthdr.csum & M_UDP_CSUM_IN_BAD) {
d307 1
a307 1
			m->m_pkthdr.csum &= ~M_UDP_CSUM_IN_OK;
d993 1
a993 1
		m->m_pkthdr.csum |= M_UDPV4_CSUM_OUT;
@


1.101
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.100 2004/04/14 05:34:15 itojun Exp $	*/
d870 2
d881 3
d896 4
a899 2
		(void) in_pcbnotify(&udbtable, sa, uhp->uh_dport, ip->ip_src,
		    uhp->uh_sport, errno, notify);
@


1.100
log
@with IPv6, udp checksum is mandatory.  henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.99 2004/03/21 20:58:10 markus Exp $	*/
d837 1
a837 1
			 * - recalcurate the new MTU and create the
@


1.99
log
@fix udp checksum verification if ip options are present;
report from Pyun via dhartmei@@; ok mcbride@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.98 2004/02/17 12:07:45 markus Exp $	*/
d281 4
d547 1
@


1.98
log
@switch to sysctl_int_arr(); ok henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.97 2004/01/07 09:56:13 markus Exp $	*/
d296 2
a297 6
			bzero(((struct ipovly *)ip)->ih_x1,
			    sizeof ((struct ipovly *)ip)->ih_x1);
			((struct ipovly *)ip)->ih_len = uh->uh_ulen;

			if ((uh->uh_sum = in_cksum(m, len +
			    sizeof (struct ip))) != 0) {
@


1.97
log
@in_pcbnotify() now returns number of matches.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.96 2003/12/21 14:57:19 markus Exp $	*/
d112 6
a1017 4
u_int	udp_sendspace = 9216;		/* really max datagram size */
u_int	udp_recvspace = 40 * (1024 + sizeof(struct sockaddr_in));
					/* 40 1K datagrams */

a1265 2
	case UDPCTL_CHECKSUM:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &udpcksum));
a1268 4
	case UDPCTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,&udp_recvspace));
	case UDPCTL_SENDSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,&udp_sendspace));
d1270 3
@


1.96
log
@use CIRCLEQ* for pcb's; ok deraadt, henning, mcbride, with help from canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.95 2003/12/10 07:22:43 itojun Exp $	*/
d884 1
a884 1
		in_pcbnotify(&udbtable, sa, uhp->uh_dport, ip->ip_src,
@


1.95
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.94 2003/12/08 07:07:36 mcbride Exp $	*/
d413 1
a413 3
		for (inp = udbtable.inpt_queue.cqh_first;
		    inp != (struct inpcb *)&udbtable.inpt_queue;
		    inp = inp->inp_queue.cqe_next) {
@


1.94
log
@Mbuf tag tcp and udp packets which are translated to localhost, and
use the the presence of this tag to reverse the match order in
in{6}_pcblookup_listen(). Some daemons (such as portmap) do a double
bind, binding to both * and localhost in order to differentiate local
from non-local connections, and potentially granting more privilege to
local ones. This change ensures that redirected connections to localhost
do not appear local to such a daemon.

Bulk of changes from dhartmei@@, some changes markus@@

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.93 2003/12/02 23:16:29 markus Exp $	*/
d159 3
a161 3
	register struct ip *ip;
	register struct udphdr *uh;
	register struct inpcb *inp;
d663 1
a663 1
	register int size;
d666 1
a666 1
	register struct cmsghdr *cp;
d687 1
a687 1
	register struct inpcb *inp;
d704 1
a704 1
	register struct ip6_hdr *ip6;
d863 2
a864 2
	register struct ip *ip = v;
	register struct udphdr *uhp;
d896 1
a896 1
	register struct inpcb *inp;
d898 2
a899 2
	register struct udpiphdr *ui;
	register int len = m->m_pkthdr.len;
@


1.93
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.92 2003/11/04 21:43:16 markus Exp $	*/
d528 2
a529 1
			    &ip6->ip6_dst, uh->uh_dport);
d533 2
a534 1
		    ip->ip_dst, uh->uh_dport);
d825 1
a825 1
			    &sa6_src.sin6_addr, uh.uh_sport))
@


1.92
log
@add in(6)_pcblookup_listen() and replace all calls to in_pcblookup()
with either in(6)_pcbhashlookup() or in(6)_pcblookup_listen();
in_pcblookup is now only used by bind(2); speeds up pcb lookup for
listening sockets; from Claudio Jeker
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.91 2003/07/09 22:03:16 itojun Exp $	*/
d92 5
d306 36
@


1.91
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.90 2003/06/02 23:28:15 millert Exp $	*/
d486 2
a487 4
			inp = in_pcblookup(&udbtable,
			    (struct in_addr *)&(ip6->ip6_src),
			    uh->uh_sport, (struct in_addr *)&(ip6->ip6_dst),
			    uh->uh_dport, INPLOOKUP_WILDCARD | INPLOOKUP_IPV6);
d490 2
a491 2
		inp = in_pcblookup(&udbtable, &ip->ip_src, uh->uh_sport,
		    &ip->ip_dst, uh->uh_dport, INPLOOKUP_WILDCARD);
a665 1
	struct in6_addr finaldst;
d770 1
a770 1
			if (in6_pcbhashlookup(&udbtable, &finaldst,
a772 4
			else if (in_pcblookup(&udbtable, &sa6.sin6_addr,
			    uh.uh_dport, &sa6_src.sin6_addr, uh.uh_sport,
			    INPLOOKUP_IPV6))
				valid = 1;
d781 2
a782 3
			else if (in_pcblookup(&udbtable, &sa6.sin6_addr,
			    uh.uh_dport, &sa6_src.sin6_addr, uh.uh_sport,
			    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6))
@


1.90
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.89 2003/05/30 01:09:16 itojun Exp $	*/
d952 1
a952 1
	((struct ip *)ui)->ip_len = sizeof (struct udpiphdr) + len;
@


1.89
log
@missing #ifdef INET6.  fries found it
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.88 2003/05/29 00:32:59 itojun Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.88
log
@use m_pulldown instead of m_pullup2.  enable support for IPv6 jumbogram.
markus & art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.87 2003/05/12 00:48:52 jason Exp $	*/
d234 3
a236 1
	} else if (ip6) {
d244 3
a246 1
	} else /* shouldn't happen */
@


1.87
log
@Nuke a whole bunch of commons; ok tedu (still more to come *sigh*)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.86 2002/08/28 15:43:03 pefo Exp $	*/
d208 4
a211 13
	/*
	 * Strip IP options, if any; should skip this,
	 * make available to user, and use on returned packets,
	 * but we don't yet have a way to check the checksum
	 * with options still present.
	 */
	/*
	 * (contd. from above...)  Furthermore, we may want to strip options
	 * for such things as ICMP errors, where options just get in the way.
	 */
	if (ip && iphlen > sizeof (struct ip)) {
		ip_stripoptions(m, (struct mbuf *)0);
		iphlen = sizeof(struct ip);
a213 18
	/*
	 * Get IP and UDP header together in first mbuf.
	 */
	if (m->m_len < iphlen + sizeof(struct udphdr)) {
		if ((m = m_pullup2(m, iphlen + sizeof(struct udphdr))) ==
		    NULL) {
			udpstat.udps_hdrops++;
			return;
		}
#ifdef INET6
		if (ip6)
			ip6 = mtod(m, struct ip6_hdr *);
		else
#endif /* INET6 */
			ip = mtod(m, struct ip *);
	}
	uh = (struct udphdr *)(mtod(m, caddr_t) + iphlen);

d225 14
a238 3
	if (m->m_pkthdr.len - iphlen != len) {
		if (len > (m->m_pkthdr.len - iphlen) ||
		    len < sizeof(struct udphdr)) {
d242 3
a244 2
		m_adj(m, len - (m->m_pkthdr.len - iphlen));
	}
d603 1
a603 2
	if (sbappendaddr(&inp->inp_socket->so_rcv,
		&srcsa.sa, m, opts) == 0) {
@


1.86
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.85 2002/08/19 02:31:02 itojun Exp $	*/
d111 2
@


1.85
log
@be consistent with other KAME source, use "ip6" for ip6_hdr, not "ipv6".
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.84 2002/06/28 09:15:12 deraadt Exp $	*/
d973 1
a973 1
	    inp->inp_moptions, inp, NULL);
@


1.84
log
@undo recent changes; they still crash for people (dhclient this time).
This is a bullshit process.  Test your shit before you toss it into the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.79 2002/06/20 03:49:02 deraadt Exp $	*/
d172 1
a172 1
	struct ip6_hdr *ipv6;
d191 1
a191 1
		ipv6 = NULL;
d198 1
a198 1
		ipv6 = mtod(m, struct ip6_hdr *);
d231 2
a232 2
		if (ipv6)
			ipv6 = mtod(m, struct ip6_hdr *);
d272 1
a272 1
	if (ipv6) {
d274 2
a275 2
		if (IN6_IS_ADDR_V4MAPPED(&ipv6->ip6_src) ||
		    IN6_IS_ADDR_V4MAPPED(&ipv6->ip6_dst)) {
d336 1
a336 1
		srcsa.sin6.sin6_flowinfo = htonl(0x0fffffff) & ipv6->ip6_flow;
d339 1
a339 1
		(void)in6_recoverscope(&srcsa.sin6, &ipv6->ip6_src,
d347 1
a347 1
		(void)in6_recoverscope(&dstsa.sin6, &ipv6->ip6_dst,
d354 1
a354 1
	if ((ipv6 && IN6_IS_ADDR_MULTICAST(&ipv6->ip6_dst)) ||
d390 1
a390 1
			if (ipv6 && !(inp->inp_flags & INP_IPV6))
d392 1
a392 1
			if (!ipv6 && (inp->inp_flags & INP_IPV6))
d398 1
a398 1
			if (ipv6) {
d401 1
a401 1
					    &ipv6->ip6_dst))
d411 1
a411 1
			if (ipv6) {
d414 1
a414 1
					    &ipv6->ip6_src) ||
d432 2
a433 2
					if (ipv6 && (inp->inp_flags & IN6P_CONTROLOPTS))
						ip6_savecontrol(inp, &opts, ipv6, n);
d472 2
a473 2
		if (ipv6 && (inp->inp_flags & IN6P_CONTROLOPTS))
			ip6_savecontrol(inp, &opts, ipv6, m);
d488 3
a490 3
	if (ipv6)
		inp = in6_pcbhashlookup(&udbtable, &ipv6->ip6_src, uh->uh_sport,
		    &ipv6->ip6_dst, uh->uh_dport);
d498 1
a498 1
		if (ipv6) {
d500 2
a501 2
			    (struct in_addr *)&(ipv6->ip6_src),
			    uh->uh_sport, (struct in_addr *)&(ipv6->ip6_dst),
d514 1
a514 1
			if (ipv6) {
d585 2
a586 2
	if (ipv6 && (inp->inp_flags & IN6P_CONTROLOPTS))
		ip6_savecontrol(inp, &opts, ipv6, m);
@


1.83
log
@Check for associated socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.82 2002/06/26 16:37:58 angelos Exp $	*/
a115 5
#ifdef IPSEC
int udp_check_ipsec(struct mbuf *, struct inpcb *,
    union sockaddr_union *, int);
#endif /* IPSEC */

a152 72
#ifdef IPSEC
int
udp_check_ipsec(m, inp, srcsa, iphlen)
	struct mbuf *m;
	struct inpcb *inp;
	union sockaddr_union *srcsa;
	int iphlen;
{
	struct m_tag *mtag;
	struct tdb_ident *tdbi;
	struct tdb *tdb;
	int error, s;

	if (inp == NULL)
		return 0;

	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
	s = splnet();
	if (mtag != NULL) {
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
	} else
		tdb = NULL;

	ipsp_spd_lookup(m, srcsa->sa.sa_family, iphlen, &error,
	    IPSP_DIRECTION_IN, tdb, inp);
	if (error) {
		splx(s);
		return -1;
	}

	/* Latch SA only if the socket is connected. */
	if (inp->inp_tdb_in != tdb && inp->inp_socket != NULL &&
	    (inp->inp_socket->so_state & SS_ISCONNECTED)) {
		if (tdb) {
			tdb_add_inp(tdb, inp, 1);
			if (inp->inp_ipo == NULL) {
				inp->inp_ipo = ipsec_add_policy(inp,
				    srcsa->sa.sa_family, IPSP_DIRECTION_OUT);
				if (inp->inp_ipo == NULL) {
					splx(s);
					return -1;
				}
			}
			if (inp->inp_ipo->ipo_dstid == NULL &&
			    tdb->tdb_srcid != NULL) {
				inp->inp_ipo->ipo_dstid = tdb->tdb_srcid;
				tdb->tdb_srcid->ref_count++;
			}
			if (inp->inp_ipsec_remotecred == NULL &&
			    tdb->tdb_remote_cred != NULL) {
				inp->inp_ipsec_remotecred =
				    tdb->tdb_remote_cred;
				tdb->tdb_remote_cred->ref_count++;
			}
			if (inp->inp_ipsec_remoteauth == NULL &&
			    tdb->tdb_remote_auth != NULL) {
				inp->inp_ipsec_remoteauth =
				    tdb->tdb_remote_auth;
				tdb->tdb_remote_auth->ref_count++;
			}
		} else { /* Just reset */
			TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp,
			    inp_tdb_in_next);
			inp->inp_tdb_in = NULL;
		}
	}
	splx(s);
	return 0;
}
#endif /* IPSEC */

d156 3
a158 3
	struct ip *ip;
	struct udphdr *uh;
	struct inpcb *inp;
d164 7
a170 1
	union sockaddr_union srcsa, dstsa;
d174 6
a428 6
#ifdef IPSEC
				if (udp_check_ipsec(m, inp, &srcsa,
				    iphlen) == -1)
					continue;
#endif /*IPSEC */

a469 5
#ifdef IPSEC
		if (udp_check_ipsec(m, inp, &srcsa, iphlen) == -1)
			goto bad;
#endif /*IPSEC */

d530 11
a540 1
	if (udp_check_ipsec(m, inp, &srcsa, iphlen) == -1)
d542 39
@


1.82
log
@A bit more paranoid.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.81 2002/06/25 00:21:58 angelos Exp $	*/
d190 1
a190 1
	if (inp->inp_tdb_in != tdb &&
@


1.81
log
@Ifdef the function proto as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.80 2002/06/25 00:21:32 angelos Exp $	*/
d117 2
a118 1
int udp_check_ipsec(struct mbuf *, struct inpcb *, union sockaddr_union, int);
d160 1
a160 1
udp_check_ipsec(m, inp, srcsa,iphlen)
d163 1
a163 1
	union sockaddr_union srcsa;
d171 3
d181 2
a182 1
	ipsp_spd_lookup(m, srcsa.sa.sa_family, iphlen, &error,
d196 1
a196 1
				    srcsa.sa.sa_family, IPSP_DIRECTION_OUT);
d495 1
a495 1
				if (udp_check_ipsec(m, inp, srcsa,
d497 1
a497 1
					goto bad;
d542 1
a542 1
		if (udp_check_ipsec(m, inp, srcsa, iphlen) == -1)
d606 1
a606 1
	if (udp_check_ipsec(m, inp, srcsa, iphlen) == -1)
@


1.80
log
@Make udp_input() a bit more readable by farming out the IPsec input
policy checking to a separate routine. Also, add missing checks for
multicast sockets, pointed out by sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.79 2002/06/20 03:49:02 deraadt Exp $	*/
d115 2
d118 1
@


1.79
log
@minor indent cleanup while reading code
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.78 2002/06/09 16:26:11 itojun Exp $	*/
d115 1
d154 68
d225 3
a227 3
	register struct ip *ip;
	register struct udphdr *uh;
	register struct inpcb *inp;
d233 1
a233 7
	union {
		struct sockaddr sa;
		struct sockaddr_in sin;
#ifdef INET6
		struct sockaddr_in6 sin6;
#endif /* INET6 */
	} srcsa, dstsa;
a236 6
#ifdef IPSEC
	struct m_tag *mtag;
	struct tdb_ident *tdbi;
	struct tdb *tdb;
	int error, s;
#endif /* IPSEC */
d486 6
d533 5
d598 1
a598 11
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
	s = splnet();
	if (mtag != NULL) {
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
	} else
		tdb = NULL;
	ipsp_spd_lookup(m, srcsa.sa.sa_family, iphlen, &error,
	    IPSP_DIRECTION_IN, tdb, inp);
	if (error) {
		splx(s);
a599 39
	}

	/* Latch SA only if the socket is connected */
	if (inp->inp_tdb_in != tdb &&
	    (inp->inp_socket->so_state & SS_ISCONNECTED)) {
		if (tdb) {
			tdb_add_inp(tdb, inp, 1);
			if (inp->inp_ipo == NULL) {
				inp->inp_ipo = ipsec_add_policy(inp,
				    srcsa.sa.sa_family, IPSP_DIRECTION_OUT);
				if (inp->inp_ipo == NULL) {
					splx(s);
					goto bad;
				}
			}
			if (inp->inp_ipo->ipo_dstid == NULL &&
			    tdb->tdb_srcid != NULL) {
				inp->inp_ipo->ipo_dstid = tdb->tdb_srcid;
				tdb->tdb_srcid->ref_count++;
			}
			if (inp->inp_ipsec_remotecred == NULL &&
			    tdb->tdb_remote_cred != NULL) {
				inp->inp_ipsec_remotecred =
				    tdb->tdb_remote_cred;
				tdb->tdb_remote_cred->ref_count++;
			}
			if (inp->inp_ipsec_remoteauth == NULL &&
			    tdb->tdb_remote_auth != NULL) {
				inp->inp_ipsec_remoteauth =
				    tdb->tdb_remote_auth;
				tdb->tdb_remote_auth->ref_count++;
			}
		} else { /* Just reset */
			TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp,
			    inp_tdb_in_next);
			inp->inp_tdb_in = NULL;
		}
	}
	splx(s);
@


1.78
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.77 2002/05/31 04:43:26 angelos Exp $	*/
a159 1
	int len;
d161 1
a161 1
	int iphlen;
d252 1
a252 1
			len < sizeof(struct udphdr)) {
d299 1
a299 1
			      sizeof ((struct ipovly *)ip)->ih_x1);
d356 1
a356 1
	    (ip && in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif)))
d359 1
a359 1
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif))
a360 1
	{
d416 1
a416 1
			        continue;
d523 1
a523 1
					0, 0);
d531 1
a531 1
        s = splnet();
d534 1
a534 1
	        tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
d548 1
a548 1
		        tdb_add_inp(tdb, inp, 1);
d575 2
a576 2
		        TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp,
				     inp_tdb_in_next);
d580 1
a580 1
        splx(s);
d734 1
a734 1
						     ip6cp->ip6c_finaldst);
d771 1
a771 1
							 &ip6->ip6_src);
d827 2
a828 2
		     uh.uh_dport, (struct sockaddr *)&sa6_src,
		     uh.uh_sport, cmd, cmdarg, notify);
d831 1
a831 1
		     (struct sockaddr *)&sa6_any, 0, cmd, cmdarg, notify);
d905 1
a905 1
	        /*
d909 1
a909 1
                pcbflags = inp->inp_flags;
d911 1
a911 1
			laddr = inp->inp_laddr;
d963 1
a963 1
			sizeof (struct udphdr) + IPPROTO_UDP));
d972 2
a973 3
		inp->inp_socket->so_options &
		(SO_DONTROUTE | SO_BROADCAST),
		inp->inp_moptions, inp, NULL);
d978 2
a979 2
                inp->inp_flags = pcbflags;
			inp->inp_laddr = laddr;
@


1.77
log
@Socket-specific IPsec policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.76 2002/03/15 18:19:53 millert Exp $	*/
d37 1
a37 1
 * 
d41 1
a41 1
 * 
d56 1
a56 1
 * 
d68 1
a68 1
 * 
d302 1
a302 1
		
d478 1
a478 1
		if (sbappendaddr(&last->so_rcv, 
d969 1
a969 1
	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;	
d1087 1
a1087 1
#ifdef INET6 
d1121 1
a1121 1
#ifdef INET6 
@


1.76
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.75 2002/03/14 01:27:11 millert Exp $	*/
d541 4
d551 9
a559 1
			if (inp->inp_ipsec_remoteid == NULL &&
d561 1
a561 1
				inp->inp_ipsec_remoteid = tdb->tdb_srcid;
a582 4

	/* Error or otherwise drop-packet indication. */
	if (error)
		goto bad;
@


1.75
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.74 2001/06/25 02:06:40 angelos Exp $	*/
a153 1
#if __STDC__
a154 5
#else
udp_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
a866 1
#if __STDC__
a867 5
#else
udp_output(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.74
log
@Defer output checksumming until ip_output() or hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.73 2001/06/25 00:11:58 angelos Exp $	*/
d112 3
a114 3
static	void udp_detach __P((struct inpcb *));
static	void udp_notify __P((struct inpcb *, int));
static	struct mbuf *udp_saveopt __P((caddr_t, int, int));
d687 1
a687 1
	void (*notify) __P((struct inpcb *, int)) = udp_notify;
d845 1
a845 1
	void (*notify) __P((struct inpcb *, int)) = udp_notify;
@


1.74.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.74 2001/06/25 02:06:40 angelos Exp $	*/
d112 3
a114 3
static	void udp_detach(struct inpcb *);
static	void udp_notify(struct inpcb *, int);
static	struct mbuf *udp_saveopt(caddr_t, int, int);
d154 1
d156 5
a546 4
	if (error) {
		splx(s);
		goto bad;
	}
d553 1
a553 9
			if (inp->inp_ipo == NULL) {
				inp->inp_ipo = ipsec_add_policy(inp,
				    srcsa.sa.sa_family, IPSP_DIRECTION_OUT);
				if (inp->inp_ipo == NULL) {
					splx(s);
					goto bad;
				}
			}
			if (inp->inp_ipo->ipo_dstid == NULL &&
d555 1
a555 1
				inp->inp_ipo->ipo_dstid = tdb->tdb_srcid;
d577 4
d687 1
a687 1
	void (*notify)(struct inpcb *, int) = udp_notify;
d845 1
a845 1
	void (*notify)(struct inpcb *, int) = udp_notify;
d873 1
d875 5
@


1.74.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.74.4.1 2002/06/11 03:31:37 art Exp $	*/
d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
d160 1
d162 1
a162 1
	int iphlen, len;
d173 1
a173 1
	struct ip6_hdr *ip6;
d192 1
a192 1
		ip6 = NULL;
d199 1
a199 1
		ip6 = mtod(m, struct ip6_hdr *);
d232 2
a233 2
		if (ip6)
			ip6 = mtod(m, struct ip6_hdr *);
d253 1
a253 1
		    len < sizeof(struct udphdr)) {
d273 1
a273 1
	if (ip6) {
d275 2
a276 2
		if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
		    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
d300 1
a300 1
			    sizeof ((struct ipovly *)ip)->ih_x1);
d302 1
a302 1

d337 1
a337 1
		srcsa.sin6.sin6_flowinfo = htonl(0x0fffffff) & ip6->ip6_flow;
d340 1
a340 1
		(void)in6_recoverscope(&srcsa.sin6, &ip6->ip6_src,
d348 1
a348 1
		(void)in6_recoverscope(&dstsa.sin6, &ip6->ip6_dst,
d355 1
a355 1
	if ((ip6 && IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) ||
d357 1
a357 1
	    (ip && in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif))) {
d360 1
a360 1
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif)) {
d362 1
d392 1
a392 1
			if (ip6 && !(inp->inp_flags & INP_IPV6))
d394 1
a394 1
			if (!ip6 && (inp->inp_flags & INP_IPV6))
d400 1
a400 1
			if (ip6) {
d403 1
a403 1
					    &ip6->ip6_dst))
d413 1
a413 1
			if (ip6) {
d416 1
a416 1
					    &ip6->ip6_src) ||
d418 1
a418 1
						continue;
d434 2
a435 2
					if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS))
						ip6_savecontrol(inp, &opts, ip6, n);
d474 2
a475 2
		if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS))
			ip6_savecontrol(inp, &opts, ip6, m);
d478 1
a478 1
		if (sbappendaddr(&last->so_rcv,
d490 3
a492 3
	if (ip6)
		inp = in6_pcbhashlookup(&udbtable, &ip6->ip6_src, uh->uh_sport,
		    &ip6->ip6_dst, uh->uh_dport);
d500 1
a500 1
		if (ip6) {
d502 2
a503 2
			    (struct in_addr *)&(ip6->ip6_src),
			    uh->uh_sport, (struct in_addr *)&(ip6->ip6_dst),
d516 1
a516 1
			if (ip6) {
d525 1
a525 1
				    0, 0);
d533 1
a533 1
	s = splnet();
d536 1
a536 1
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
d550 1
a550 1
			tdb_add_inp(tdb, inp, 1);
d577 2
a578 2
			TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp,
			    inp_tdb_in_next);
d582 1
a582 1
	splx(s);
d587 2
a588 2
	if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS))
		ip6_savecontrol(inp, &opts, ip6, m);
d736 1
a736 1
		    ip6cp->ip6c_finaldst);
d773 1
a773 1
		    &ip6->ip6_src);
d829 2
a830 2
		    uh.uh_dport, (struct sockaddr *)&sa6_src,
		    uh.uh_sport, cmd, cmdarg, notify);
d833 1
a833 1
		    (struct sockaddr *)&sa6_any, 0, cmd, cmdarg, notify);
d907 1
a907 1
		/*
d911 1
a911 1
		pcbflags = inp->inp_flags;
d913 1
a913 1
		laddr = inp->inp_laddr;
d965 1
a965 1
		    sizeof (struct udphdr) + IPPROTO_UDP));
d969 1
a969 1
	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;
d974 3
a976 2
	    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
	    inp->inp_moptions, inp, (void *)NULL);
d981 2
a982 2
		inp->inp_flags = pcbflags;
		inp->inp_laddr = laddr;
d1087 1
a1087 1
#ifdef INET6
d1121 1
a1121 1
#ifdef INET6
@


1.74.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a110 2
struct	inpcbtable udbtable;
struct	udpstat udpstat;
@


1.73
log
@Use in_cksum_phdr() rather than in_cksum() -- from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.72 2001/06/24 23:01:59 angelos Exp $	*/
a886 2
	struct route *ro;
	struct ifnet *ifp;
d962 2
a963 1
	 * Stuff checksum and output datagram.
a964 2

	ui->ui_sum = 0;
d966 6
a971 18
		ro = &inp->inp_route;
		if (ro->ro_rt && (ro->ro_rt->rt_flags & RTF_UP)) {
			ifp = ro->ro_rt->rt_ifp;
			if ((ifp->if_capabilities & IFCAP_CSUM_UDPv4) &&
			    ifp->if_bridge == NULL) {
				m->m_pkthdr.csum |= M_UDPV4_CSUM_OUT;
				udpstat.udps_outhwcsum++;
				ui->ui_sum = in_cksum_phdr(ui->ui_src.s_addr,
				    ui->ui_dst.s_addr, htons((u_int16_t)len +
					sizeof (struct udphdr) + IPPROTO_UDP));
				goto skipudpcsum;
			}
		}
		if ((ui->ui_sum = in_cksum(m, sizeof (struct udpiphdr) +
		    len)) == 0)
			ui->ui_sum = 0xffff;
 skipudpcsum:
	}
@


1.72
log
@Remove printfs, fix comment typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.71 2001/06/24 22:50:59 angelos Exp $	*/
d976 3
a978 2
				ui->ui_sum = in_cksum(m,
				    sizeof(struct udpiphdr));
@


1.71
log
@Save tdb_remote_auth on the PCB on latching; also save information on
UDP PCB's if the socket is connected.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.70 2001/06/23 18:54:44 angelos Exp $	*/
a126 1

a209 2
		printf("udp_input: received unknown IP version %d",
		    mtod(m, struct ip *)->ip_v);
d721 1
a721 2
			/* should be impossbile */
			printf("udp6_ctlinput: in6_embedscope failed\n");
d737 1
a737 2
			/* should be impossbile */
			printf("udp6_ctlinput: in6_embedscope failed\n");
d746 1
a746 2
			/* should be impossbile */
			printf("udp6_ctlinput: in6_embedscope failed\n");
d774 1
a774 2
			/* should be impossbile */
			printf("udp6_ctlinput: in6_embedscope failed\n");
a1231 1
		printf("udp control data unexpectedly retained\n");
@


1.70
log
@Clear the checksum flags after verification. Also, don't count
checksum errors as hardware checksum packets as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.69 2001/06/23 16:15:56 fgsch Exp $	*/
d550 29
a579 2

	/* No SA latching done for UDP. */
@


1.69
log
@Remove unneeded ip_id convertions.
Instead of using HTONS macro in some places, use htons directly in the
struct member and save us a few bytes.
Fix comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.68 2001/06/23 07:14:32 angelos Exp $	*/
a300 4
			bzero(((struct ipovly *)ip)->ih_x1,
			      sizeof ((struct ipovly *)ip)->ih_x1);
			((struct ipovly *)ip)->ih_len = uh->uh_ulen;
		
d308 4
d318 2
a319 1
		} else
d321 1
a321 1
			
@


1.68
log
@Likewise, only use outgoing TCP/UDP hardware checksumming if the
interface is not in bridge mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.67 2001/06/23 06:03:13 angelos Exp $	*/
a530 1
				HTONS(ip->ip_id);
@


1.67
log
@Keep stats on TCP/UDP hardware checksumming.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.66 2001/06/23 05:36:08 angelos Exp $	*/
d952 2
a953 1
			if (ifp->if_capabilities & IFCAP_CSUM_UDPv4) {
@


1.66
log
@TCP/UDP hardware checksumming. Untested, since txp dies when it tries
to compute the checksums. Still, it shouldn't affect anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.65 2001/06/23 03:42:10 angelos Exp $	*/
d305 1
a305 3
			if (m->m_pkthdr.csum & M_UDP_CSUM_IN_BAD ||
			    (uh->uh_sum = in_cksum(m, len +
						   sizeof (struct ip))) != 0) {
d307 1
d311 10
a320 1
		}
d954 1
@


1.65
log
@Initialize only if no hardware checksumming.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.64 2001/06/23 02:27:11 angelos Exp $	*/
d859 2
d941 10
d954 1
@


1.64
log
@TCP, UDP, IPv4 input hardware checksumming processing; also IPv4
output hardware checksumming. Not tested yet, but should be done
tonight.

Remain to be solved: interactions with bridge, TCP/UDP output
checksumming, interactions of TCP/UDP checksumming with routing
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.63 2001/06/19 00:48:23 deraadt Exp $	*/
d300 4
a303 3
		bzero(((struct ipovly *)ip)->ih_x1,
		    sizeof ((struct ipovly *)ip)->ih_x1);
		((struct ipovly *)ip)->ih_len = uh->uh_ulen;
a304 1
		if ((m->m_pkthdr.csum & M_UDP_CSUM_IN_OK) == 0) {
@


1.63
log
@mop up after angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.62 2001/06/08 03:53:47 angelos Exp $	*/
d303 9
a311 4
		if ((uh->uh_sum = in_cksum(m, len + sizeof (struct ip))) != 0) {
			udpstat.udps_badsum++;
			m_freem(m);
			return;
@


1.62
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.61 2001/06/05 02:31:37 deraadt Exp $	*/
d76 1
@


1.61
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.60 2001/05/27 03:13:30 angelos Exp $	*/
a75 1
#include <sys/malloc.h>
a79 6
#include <sys/errno.h>
#include <sys/stat.h>
#include <sys/systm.h>
#include <sys/proc.h>

#include <vm/vm.h>
a94 6
#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#endif

#include <machine/stdarg.h>

a98 4
#include <netinet/ip6.h>
#include <netinet6/in6_var.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
@


1.60
log
@Remove unnecessary comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.59 2001/05/27 00:39:27 angelos Exp $	*/
d36 37
a72 1
 *	@@(#)udp_usrreq.c	8.4 (Berkeley) 1/21/94
a73 12

/*
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.59
log
@Use the new IPsec tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.58 2001/05/20 08:35:12 angelos Exp $	*/
d531 1
a531 1
	/* No SA latching done for UDP */
d533 1
a533 1
	/* Error or otherwise drop-packet indication */
a1115 3
#ifdef IPSEC
	    /* XXX Find IPsec TDB */
#endif
@


1.58
log
@Use packet tags instead of tdbi.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.57 2001/05/11 17:20:12 aaron Exp $	*/
d520 1
a520 1
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_DONE, NULL);
@


1.57
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.56 2001/03/28 20:03:07 angelos Exp $	*/
d175 1
d520 1
a520 2
	tdbi = (struct tdb_ident *) m->m_pkthdr.tdbi;

d522 2
a523 3
        if (tdbi == NULL)
                tdb = NULL;
        else
d525 2
a526 1

d528 1
a528 1
			IPSP_DIRECTION_IN, tdb, inp);
@


1.56
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.55 2001/03/06 18:34:17 aaron Exp $	*/
d226 2
a227 1
		if ((m = m_pullup2(m, iphlen + sizeof(struct udphdr))) == 0) {
@


1.55
log
@Move the test for bogus packet length in udp_output() closer to the top of
the function. Previously it was possible for us to get stuck in splsoftnet()
under certain situations. Bug reported by hunter@@dg.net.ua, fix by me ok'd
by deraadt@@, provos@@, angelos@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.54 2001/02/16 16:17:31 itojun Exp $	*/
a96 2
#define PI_MAGIC 0xdeadbeef  /* XXX the horror! */

a177 4

	tdbi = (struct tdb_ident *) m->m_pkthdr.tdbi;
	if (tdbi == (void *) PI_MAGIC)
	        tdbi = NULL;
a227 4
#ifdef IPSEC
			if (tdbi)
			        free(tdbi, M_TEMP);
#endif /* IPSEC */
a295 4
#ifdef IPSEC
			if (tdbi)
			        free(tdbi, M_TEMP);
#endif /* IPSEC */
a468 4
#ifdef IPSEC
		if (tdbi)
		        free(tdbi, M_TEMP);
#endif /* IPSEC */
a512 4
#ifdef IPSEC
			if (tdbi)
			        free(tdbi, M_TEMP);
#endif /* IPSEC */
a517 1
#define PI_MAGIC 0xdeadbeef  /* XXX the horror! */
a518 2
	if (tdbi == (void *) PI_MAGIC)
	        tdbi = NULL;
d530 1
a530 3
	if (tdbi)
	        free(tdbi, M_TEMP);
	tdbi = NULL;
a577 4
#ifdef IPSEC
	if (tdbi)
	        free(tdbi, M_TEMP);
#endif /* IPSEC */
@


1.54
log
@remove IPv6 case from udp_output.  now we have separate udp6_output.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.53 2001/02/16 16:00:54 itojun Exp $	*/
d890 9
a933 9
	}

	/*
	 * Compute the packet length of the IP header, and
	 * punt if the length looks bogus.
	 */
	if ((len + sizeof(struct udpiphdr)) > IP_MAXPACKET) {
		error = EMSGSIZE;
		goto release;
@


1.53
log
@pull in new pcb notification code from kame.  better handling of scope address.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.52 2000/12/11 08:04:56 itojun Exp $	*/
a876 6
#ifdef INET6
	register struct in6_addr laddr6;
	int v6packet = 0;
	struct sockaddr_in6 *sin6 = NULL;
	struct ip6_pktopts opt, *stickyopt = NULL;
#endif /* INET6 */
d885 3
a887 13
#ifdef INET6
	v6packet = (inp->inp_flags & INP_IPV6);
#endif

#ifdef INET6
	stickyopt = inp->inp_outputopts6;
	if (control && v6packet) {
		error = ip6_setpktoptions(control, &opt,
		    ((inp->inp_socket->so_state & SS_PRIV) != 0));
		if (error != 0)
			goto release;
		inp->inp_outputopts6 = &opt;
	}
a890 4
#ifdef INET6
		sin6 = mtod(addr, struct sockaddr_in6 *);
#endif

a896 5
#ifdef INET6
	        if (inp->inp_flags & INP_IPV6)
			laddr6 = inp->inp_laddr6;
		else
#endif /* INET6 */
d898 1
a898 8
#ifdef INET6
		if (((inp->inp_flags & INP_IPV6) &&
		    !IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6)) ||
		    (inp->inp_faddr.s_addr != INADDR_ANY))
#else /* INET6 */
		if (inp->inp_faddr.s_addr != INADDR_ANY)
#endif /* INET6 */
		{
d912 1
a912 8
#ifdef INET6
	        if (((inp->inp_flags & INP_IPV6) && 
		    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6)) ||
		    (inp->inp_faddr.s_addr == INADDR_ANY))
#else /* INET6 */
		if (inp->inp_faddr.s_addr == INADDR_ANY)
#endif /* INET6 */
		{
a920 8
#ifdef INET6
	/*
	 * Handles IPv4-mapped IPv6 address because temporary connect sets
	 * the right flag.
	 */
	M_PREPEND(m, v6packet ? (sizeof(struct udphdr) +
	    sizeof(struct ip6_hdr)) : sizeof(struct udpiphdr), M_DONTWAIT);
#else /* INET6 */
a921 1
#endif /* INET6 */
d940 29
a968 117
#ifdef INET6
	if (v6packet) {
		struct ip6_hdr *ipv6 = mtod(m, struct ip6_hdr *);
		struct udphdr *uh = (struct udphdr *)(mtod(m, caddr_t) +
		    sizeof(struct ip6_hdr));
		int payload = sizeof(struct ip6_hdr);
		struct in6_addr *laddr;
		struct ifnet *oifp = NULL;
		int flags;
		struct sockaddr_in6 tmp;

		ipv6->ip6_flow = htonl(0x60000000) |
		    (inp->inp_ipv6.ip6_flow & htonl(0x0fffffff)); 

		ipv6->ip6_nxt = IPPROTO_UDP;
		if (sin6)
			tmp = *sin6;
		else {
			bzero(&tmp, sizeof(tmp));
			tmp.sin6_family = AF_INET6;
			tmp.sin6_len = sizeof(struct sockaddr_in6);
			tmp.sin6_addr = inp->inp_faddr6;
		}
		/* KAME hack: embed scopeid */
		if (in6_embedscope(&ipv6->ip6_dst, &tmp, inp, &oifp) != 0) {
			error = EINVAL;
			goto release;
		}

		ipv6->ip6_hlim = in6_selecthlim(inp, oifp);
		if (sin6) {	/*XXX*/
			laddr = in6_selectsrc(sin6, inp->inp_outputopts6,
					      inp->inp_moptions6,
					      &inp->inp_route6,
					      &inp->inp_laddr6, &error);
			if (laddr == NULL) {
				if (error == 0)
					error = EADDRNOTAVAIL;
				goto release;
			}
		} else
			laddr = &inp->inp_laddr6;

		ipv6->ip6_src = *laddr;

		ipv6->ip6_plen = (u_short)len + sizeof(struct udphdr);

		uh->uh_sport = inp->inp_lport;
		uh->uh_dport = inp->inp_fport;
		uh->uh_ulen = htons(ipv6->ip6_plen);
		uh->uh_sum = 0;

		flags = 0;
#ifdef IN6P_MINMTU
		if (inp->inp_flags & IN6P_MINMTU)
			flags |= IPV6_MINMTU;
#endif

		/* 
		 * Always calculate udp checksum for IPv6 datagrams
		 */
		if (!(uh->uh_sum = in6_cksum(m, IPPROTO_UDP,
		    payload, len + sizeof(struct udphdr))))
			uh->uh_sum = 0xffff;

		error = ip6_output(m, inp->inp_outputopts6, &inp->inp_route6, 
		    flags, inp->inp_moptions6, NULL);
	} else
#endif /* INET6 */
	{
		ui = mtod(m, struct udpiphdr *);
		bzero(ui->ui_x1, sizeof ui->ui_x1);
		ui->ui_pr = IPPROTO_UDP;
		ui->ui_len = htons((u_int16_t)len + sizeof (struct udphdr));
		ui->ui_src = inp->inp_laddr;
		ui->ui_dst = inp->inp_faddr;
		ui->ui_sport = inp->inp_lport;
		ui->ui_dport = inp->inp_fport;
		ui->ui_ulen = ui->ui_len;

		/*
		 * Stuff checksum and output datagram.
		 */

		ui->ui_sum = 0;
		if (udpcksum) {
			if ((ui->ui_sum = in_cksum(m, sizeof (struct udpiphdr) +
			    len)) == 0)
				ui->ui_sum = 0xffff;
		}
		((struct ip *)ui)->ip_len = sizeof (struct udpiphdr) + len;
#ifdef INET6
		/*
		 *  For now, we use the default values for ttl and tos for 
		 *  v4 packets sent using a v6 pcb.  We probably want to
		 *  later allow v4 setsockopt operations on a v6 socket to 
		 *  modify the ttl and tos for v4 packets sent using
		 *  the mapped address format.  We really ought to
		 *  save the v4 ttl and v6 hoplimit in separate places 
		 *  instead of craming both in the inp_hu union.
		 */
		if (inp->inp_flags & INP_IPV6) {
			((struct ip *)ui)->ip_ttl = ip_defttl;
			((struct ip *)ui)->ip_tos = 0;	  
		} else
#endif /* INET6 */
		{
			((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;	
			((struct ip *)ui)->ip_tos = inp->inp_ip.ip_tos;
		}

		udpstat.udps_opackets++;
		error = ip_output(m, inp->inp_options, &inp->inp_route,
			inp->inp_socket->so_options &
			(SO_DONTROUTE | SO_BROADCAST),
			inp->inp_moptions, inp, NULL);
	}
a973 5
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			inp->inp_laddr6 = laddr6;
	        else
#endif
d977 1
a977 5
	if (control) {
#ifdef INET6
		if (v6packet)
			inp->inp_outputopts6 = stickyopt;
#endif
a978 1
	}
d983 1
a983 5
	if (control) {
#ifdef INET6
		if (v6packet)
			inp->inp_outputopts6 = stickyopt;
#endif
a984 1
	}
@


1.52
log
@nuke #ifdef TCP6 (no longer supported).
validate ICMPv6 too big messages (pmtud) based on pcb.  we accept
certain amount of non-validated ones, as IPv6 mandates ICMPv6 (so even for
traffic from unconnected pcb, we need pmtud).
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.51 2000/10/13 17:58:37 itojun Exp $	*/
a659 1
	struct udphdr *uhp;
d662 1
a662 1
	struct ip6_hdr *ip6;
d665 2
a666 1
	struct in6_addr s;
d668 4
d674 1
a674 1
	if (!sa)
d693 1
a693 1
		struct ip6ctlparam *ip6cp = (struct ip6ctlparam *)d;
d697 1
a697 10

		/* translate addresses into internal form */
		bcopy(ip6cp->ip6c_finaldst, &finaldst, sizeof(finaldst));
		if (IN6_IS_ADDR_LINKLOCAL(&finaldst)) {
			finaldst.s6_addr16[1] =
			    htons(m->m_pkthdr.rcvif->if_index);
		}
		bcopy(&ip6->ip6_src, &s, sizeof(s));
		if (IN6_IS_ADDR_LINKLOCAL(&s))
			s.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);
d701 10
d713 26
a738 4
	/* translate addresses into internal form */
	sa6 = *(struct sockaddr_in6 *)sa;
	if (IN6_IS_ADDR_LINKLOCAL(&sa6.sin6_addr) && m && m->m_pkthdr.rcvif)
		sa6.sin6_addr.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);
d745 1
d748 1
a748 1
		if (m->m_pkthdr.len < off + sizeof(uh))
d751 16
a766 9
		if (m->m_len < off + sizeof(uh)) {
			/*
			 * this should be rare case,
			 * so we compromise on this copy...
			 */
			m_copydata(m, off, sizeof(uh), (caddr_t)&uh);
			uhp = &uh;
		} else
			uhp = (struct udphdr *)(mtod(m, caddr_t) + off);
d770 1
d776 7
a782 3
			if (in_pcblookup(&udbtable, &finaldst, uhp->uh_dport,
			    &s, uhp->uh_sport, INPLOOKUP_IPV6))
				valid++;
d791 2
a792 2
			else if (in_pcblookup(&udbtable, &finaldst,
			    uhp->uh_dport, &s, uhp->uh_sport,
d794 1
a794 1
				valid++;
d798 5
a802 4
			 * Now that we've validated that we are actually
			 * communicating with the host indicated in the ICMPv6
			 * message, recalculate the new MTU, and create the
			 * corresponding routing entry.
d806 7
a812 1
			return;
d816 2
a817 1
		    uhp->uh_dport, &s, uhp->uh_sport, cmd, notify);
d820 1
a820 1
		    &zeroin6_addr, 0, cmd, notify);
d837 1
a837 1
	if (!sa)
d996 1
d1001 1
a1001 1
	  
d1040 6
d1054 1
a1054 2
		    inp->inp_socket->so_options & SO_DONTROUTE,
		    inp->inp_moptions6, NULL);
@


1.51
log
@validate mbuf chain length on *_ctlinput.  remote node may be able to
transmit a truncated icmp6 packet and panic the system.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.50 2000/10/11 09:14:13 itojun Exp $	*/
d125 1
a125 1
#if defined(INET6) && !defined(TCP6)
d653 1
a653 1
#if defined(INET6) && !defined(TCP6)
d660 2
d666 3
d670 1
a670 1
	if (sa == NULL)
d672 2
a673 1
	if (sa->sa_family != AF_INET6)
d676 12
a687 1
	/* decode parameter from icmp6. */
d690 1
a691 1
		m = ip6cp->ip6c_m;
d693 14
a706 2
	} else
		return;
a711 1
	sa = (struct sockaddr *)&sa6;
d713 61
a773 1
	(void)udp_ctlinput(cmd, sa, (void *)ip6);
d789 6
a803 22
	if (sa == NULL)
		return NULL;
#ifdef INET6
	if (sa->sa_family == AF_INET6) {
		if (ip) {
			struct ip6_hdr *ip6 = (struct ip6_hdr *)ip;
		
			/* XXX we assume that the mbuf is sane enough */

			uhp = (struct udphdr *)((caddr_t)ip6 + sizeof(*ip6));
#if 0 /*XXX*/
			in6_pcbnotify(&udbtable, sa, uhp->uh_dport,
			    &(ip6->ip6_src), uhp->uh_sport, cmd, udp_notify);
#endif
		} else {
#if 0 /*XXX*/
			in6_pcbnotify(&udbtable, sa, 0,
			    (struct in6_addr *)&in6addr_any, 0, cmd, udp_notify);
#endif
		}
	} else
#endif /* INET6 */
d1089 1
a1089 1
#if defined(INET6) && !defined(TCP6)
d1098 1
@


1.51.2.1
log
@Pull in patch from current:
Fix (aaron):
Move the test for bogus packet length in udp_output() closer to the top of
the function. Previously it was possible for us to get stuck in splsoftnet()
under certain situations. Bug reported by hunter@@dg.net.ua, fix by me ok'd
by deraadt@@, provos@@, angelos@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.51 2000/10/13 17:58:37 itojun Exp $	*/
a785 9
	/*
	 * Compute the packet length of the IP header, and
	 * punt if the length looks bogus.
	 */
	if ((len + sizeof(struct udpiphdr)) > IP_MAXPACKET) {
		error = EMSGSIZE;
		goto release;
	}

d853 9
@


1.50
log
@nuke inp_flags bits for controlling IPv4 mapped address.
we don't support IPv4 mapped address,
and there are inconsistent bit manipulation code so it's safer to nuke them.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.49 2000/09/22 17:51:46 angelos Exp $	*/
d696 1
a696 1
	register struct udphdr *uh;
d715 1
a715 1
			struct ip6_hdr *ipv6 = (struct ip6_hdr *)ip;
d717 3
a719 1
			uh = (struct udphdr *)((caddr_t)ipv6 + sizeof(struct ip6_hdr));
d721 2
a722 2
			in6_pcbnotify(&udbtable, sa, uh->uh_dport,
			    &(ipv6->ip6_src), uh->uh_sport, cmd, udp_notify);
d733 3
a735 3
		uh = (struct udphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		in_pcbnotify(&udbtable, sa, uh->uh_dport, ip->ip_src,
		    uh->uh_sport, errno, notify);
@


1.49
log
@Move the PI_MAGIC define outside the INET6 ifdef block (doh!)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.48 2000/09/19 03:21:00 angelos Exp $	*/
d770 1
a770 2
	v6packet = ((inp->inp_flags & INP_IPV6) &&
		    !(inp->inp_flags & INP_IPV6_MAPPED));
d791 1
a791 2
		 * temporary connection, particularly the INP_IPV6_UNDEC
		 * flag.
d926 1
a926 2
		    (inp->inp_flags & INP_IPV6_MCAST)?inp->inp_moptions6:NULL,
		    NULL);
d972 4
a975 14
#ifdef INET6
		if (inp->inp_flags & INP_IPV6_MCAST) {
			error = ip_output(m, inp->inp_options, &inp->inp_route,
				inp->inp_socket->so_options &
				(SO_DONTROUTE | SO_BROADCAST),
				NULL, NULL, inp->inp_socket);
		} else
#endif /* INET6 */
		{
			error = ip_output(m, inp->inp_options, &inp->inp_route,
				inp->inp_socket->so_options &
				(SO_DONTROUTE | SO_BROADCAST),
		    		inp->inp_moptions, inp, NULL);
		}
d1143 1
d1148 1
@


1.48
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.47 2000/07/27 06:29:09 itojun Exp $	*/
a93 2
#define PI_MAGIC 0xdeadbeef  /* XXX the horror! */

d96 2
@


1.47
log
@raw6/udp6 sockets are okay with :: in src.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.46 2000/07/27 04:05:27 itojun Exp $	*/
a79 2

extern int     	check_ipsec_policy  __P((struct inpcb *, u_int32_t));
d94 2
d177 7
a183 1
	struct tdb  *tdb = NULL;
a191 12
#ifdef IPSEC
	/* Save the last SA which was used to process the mbuf */
	if ((m->m_flags & (M_CONF|M_AUTH)) && m->m_pkthdr.tdbi) {
		struct tdb_ident *tdbi = m->m_pkthdr.tdbi;
		/* XXX gettdb() should really be called at spltdb().      */
		/* XXX this is splsoftnet(), currently they are the same. */
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
		free(m->m_pkthdr.tdbi, M_TEMP);
		m->m_pkthdr.tdbi = NULL;
	}
#endif /* IPSEC */

d234 4
d306 4
d483 4
d531 4
d540 21
a560 15
	/* Check if this socket requires security for incoming packets */
	if ((inp->inp_seclevel[SL_AUTH] >= IPSEC_LEVEL_REQUIRE &&
	     !(m->m_flags & M_AUTH)) ||
	    (inp->inp_seclevel[SL_ESP_TRANS] >= IPSEC_LEVEL_REQUIRE &&
	     !(m->m_flags & M_CONF))) {
#ifdef notyet
#ifdef INET6
		if (ipv6)
			ipv6_icmp_error(m, ICMPV6_BLAH, ICMPV6_BLAH, 0);
		else
#endif /* INET6 */
		icmp_error(m, ICMP_BLAH, ICMP_BLAH, 0, 0);
		m = NULL;
#endif /* notyet */
		udpstat.udps_nosec++;
a561 4
	}
	/* Use tdb_bind_out for this inp's outbound communication */
	if (tdb)
		tdb_add_inp(tdb, inp);
d605 4
d1180 1
a1180 3
		error = check_ipsec_policy(inp,0);
		if (error)
			return (error);
@


1.46
log
@be proactive about unspecified IPv6 source address.  pcb layer uses
unspecified address (::) to mean "unbounded" or "unconnected",
and can be confused by packets from outside.

use of :: as source is not documented well in IPv6 specification.

not sure if it presents a real threat.  the worst case scenario is a DoS
against TCP listening socket:
- outsider transmit TCP SYN with :: as IPv6 source
- receiving side creates TCP control block with:
	local address = my addres
	remote address = ::	(meaning "unconnected")
	state = SYN_RCVD
  note that SYN ACK will not be sent due to ip6_output() filter.
  this stays until it timeouts.
- the TCP control block prevents listening TCP control block from
  being contacted (DoS).
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.45 2000/06/18 17:32:48 itojun Exp $	*/
a287 13
			/* XXX stat */
			goto bad;
		}

		/*
		 * Be proactive about unspecified IPv6 address in source.
		 * As we use all-zero to indicate unbounded/unconnected pcb,
		 * unspecified IPv6 address can be used to confuse us.
		 *
		 * Note that packets with unspecified IPv6 destination is
		 * already dropped in ip6_input.
		 */
		if (IN6_IS_ADDR_UNSPECIFIED(&ipv6->ip6_src)) {
@


1.45
log
@sync with KAME udp6_output().  udp output logic is very different between
IPv4/v6 so the separation should make more sense.

TODO: remove IPv6 case from udp_output()
TODO: remove/comment out/#if 0 IPv4 mapped address cases
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.44 2000/06/13 11:47:24 itojun Exp $	*/
d288 13
@


1.44
log
@comment out flowinfo manipulation on inbound.  the spec is not very clear.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.43 2000/06/13 10:29:44 itojun Exp $	*/
d1168 6
d1175 1
@


1.43
log
@avoid mbuf leak on non-matching ifp/sockaddr
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.42 2000/06/13 10:26:43 itojun Exp $	*/
d333 1
d335 4
a338 11
		srcsa.sin6.sin6_addr = ipv6->ip6_src;
		if (IN6_IS_SCOPE_LINKLOCAL(&srcsa.sin6.sin6_addr))
			srcsa.sin6.sin6_addr.s6_addr16[1] = 0;
		if (m->m_pkthdr.rcvif) {
			if (IN6_IS_SCOPE_LINKLOCAL(&srcsa.sin6.sin6_addr)) {
				srcsa.sin6.sin6_scope_id =
					m->m_pkthdr.rcvif->if_index;
			} else
				srcsa.sin6.sin6_scope_id = 0;
		} else
			srcsa.sin6.sin6_scope_id = 0;
d344 3
a346 1
		dstsa.sin6.sin6_addr = ipv6->ip6_dst;
@


1.42
log
@on UDPv6 sendto, correctly set oifp.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.41 2000/06/13 10:12:00 itojun Exp $	*/
d879 4
a882 2
		if (in6_embedscope(&ipv6->ip6_dst, &tmp, inp, &oifp) != 0)
			return EINVAL;
@


1.41
log
@allow link-local IPv6 addres in in6_pcbbind.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.40 2000/04/09 17:43:02 angelos Exp $	*/
d879 1
a879 1
		if (in6_embedscope(&ipv6->ip6_dst, &tmp, inp, NULL) != 0)
@


1.40
log
@Pass ip_off and ip_len in the correct byte order to icmp_error(); this
should fix the crash problems with isic, reported last week.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.39 2000/02/18 05:21:01 itojun Exp $	*/
a861 1
		struct in6_addr *faddr;
d864 1
d870 11
a880 14
		ipv6->ip6_dst = inp->inp_faddr6;
		/*
		 * If the scope of the destination is link-local,
		 * embed the interface
		 * index in the address.
		 *
		 * XXX advanced-api value overrides sin6_scope_id 
		 */
		faddr = &ipv6->ip6_dst;
		if (IN6_IS_ADDR_LINKLOCAL(faddr) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(faddr)) {
			struct ip6_pktopts *optp = inp->inp_outputopts6;
			struct in6_pktinfo *pi = NULL;
			struct ip6_moptions *mopt = NULL;
a881 26
			/*
			 * XXX Boundary check is assumed to be already done in
			 * ip6_setpktoptions().
			 */
			if (optp && (pi = optp->ip6po_pktinfo) &&
			    pi->ipi6_ifindex) {
				faddr->s6_addr16[1] = htons(pi->ipi6_ifindex);
				oifp = ifindex2ifnet[pi->ipi6_ifindex];
			}
			else if (IN6_IS_ADDR_MULTICAST(faddr) &&
				 (mopt = inp->inp_moptions6) &&
				 mopt->im6o_multicast_ifp) {
				oifp = mopt->im6o_multicast_ifp;
				faddr->s6_addr16[1] = oifp->if_index;
			} else if (sin6 && sin6->sin6_scope_id) {
				/* boundary check */
				if (sin6->sin6_scope_id < 0 
				    || if_index < sin6->sin6_scope_id) {
					error = ENXIO;  /* XXX EINVAL? */
					goto release;
				}
				/* XXX */
				faddr->s6_addr16[1] =
					htons(sin6->sin6_scope_id & 0xffff);
			}
		}
@


1.39
log
@fix alignment problem in ancillary data (alpha).

only ipv6 tools (which touches ancillary data) are affected.

From: =?iso-8859-1?Q?G=F6ran_Bengtson?= <goeran@@cdg.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.38 2000/02/07 06:09:09 itojun Exp $	*/
a523 1
				HTONS(ip->ip_len);
a524 1
				HTONS(ip->ip_off);
@


1.38
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.37 2000/01/07 16:34:10 angelos Exp $	*/
d621 1
a621 1
	size += sizeof(*cp);
@


1.38.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.39 2000/02/18 05:21:01 itojun Exp $	*/
d621 1
a621 1
	size = CMSG_LEN(size);
@


1.38.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.56 2001/03/28 20:03:07 angelos Exp $	*/
d80 2
d125 1
a125 1
#ifdef INET6
d177 1
a177 3
	struct tdb_ident *tdbi;
	struct tdb *tdb;
	int error, s;
d186 12
a332 1
#if 0 /*XXX inbound flowinfo */
d334 11
a344 4
#endif
		/* KAME hack: recover scopeid */
		(void)in6_recoverscope(&srcsa.sin6, &ipv6->ip6_src,
		    m->m_pkthdr.rcvif);
d350 1
a350 3
		/* KAME hack: recover scopeid */
		(void)in6_recoverscope(&dstsa.sin6, &ipv6->ip6_dst,
		    m->m_pkthdr.rcvif);
d524 1
d526 1
d536 15
a550 16
	tdbi = (struct tdb_ident *) m->m_pkthdr.tdbi;

        s = splnet();
        if (tdbi == NULL)
                tdb = NULL;
        else
	        tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);

	ipsp_spd_lookup(m, srcsa.sa.sa_family, iphlen, &error,
			IPSP_DIRECTION_IN, tdb, inp);
        splx(s);

	/* No SA latching done for UDP */

	/* Error or otherwise drop-packet indication */
	if (error)
d552 4
d643 1
a643 1
#ifdef INET6
a649 1
	struct udphdr uh;
d651 1
a651 1
	register struct ip6_hdr *ip6;
a653 8
	void *cmdarg;
	struct ip6ctlparam *ip6cp = NULL;
	struct in6_addr finaldst;
	struct udp_portonly {
		u_int16_t uh_sport;
		u_int16_t uh_dport;
	} *uhp;
	void (*notify) __P((struct inpcb *, int)) = udp_notify;
d657 1
a657 13
	if (sa->sa_family != AF_INET6 ||
	    sa->sa_len != sizeof(struct sockaddr_in6))
		return;

	if ((unsigned)cmd >= PRC_NCMDS)
		return;
	if (PRC_IS_REDIRECT(cmd))
		notify = in_rtchange, d = NULL;
	else if (cmd == PRC_HOSTDEAD)
		d = NULL;
	else if (cmd == PRC_MSGSIZE)
		; /* special code is present, see below */
	else if (inet6ctlerrmap[cmd] == 0)
d660 1
a660 1
	/* if the parameter is from icmp6, decode it. */
d662 2
a663 1
		ip6cp = (struct ip6ctlparam *)d;
a664 1
		ip6 = ip6cp->ip6c_ip6;
d666 2
a667 42
		cmdarg = ip6cp->ip6c_cmdarg;
	} else {
		m = NULL;
		ip6 = NULL;
		cmdarg = NULL;
		/* XXX: translate addresses into internal form */
		sa6 = *(struct sockaddr_in6 *)sa;
#ifndef SCOPEDROUTING
		if (in6_embedscope(&sa6.sin6_addr, &sa6, NULL, NULL)) {
			/* should be impossbile */
			printf("udp6_ctlinput: in6_embedscope failed\n");
			return;
		}
#endif
	}

	if (ip6cp && ip6cp->ip6c_finaldst) {
		bzero(&sa6, sizeof(sa6));
		sa6.sin6_family = AF_INET6;
		sa6.sin6_len = sizeof(sa6);
		sa6.sin6_addr = *ip6cp->ip6c_finaldst;
		/* XXX: assuming M is valid in this case */
		sa6.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.rcvif,
						     ip6cp->ip6c_finaldst);
#ifndef SCOPEDROUTING
		if (in6_embedscope(ip6cp->ip6c_finaldst, &sa6, NULL, NULL)) {
			/* should be impossbile */
			printf("udp6_ctlinput: in6_embedscope failed\n");
			return;
		}
#endif
	} else {
		/* XXX: translate addresses into internal form */
		sa6 = *(struct sockaddr_in6 *)sa;
#ifndef SCOPEDROUTING
		if (in6_embedscope(&sa6.sin6_addr, &sa6, NULL, NULL)) {
			/* should be impossbile */
			printf("udp6_ctlinput: in6_embedscope failed\n");
			return;
		}
#endif
	}
d669 5
a673 74
	if (ip6) {
		/*
		 * XXX: We assume that when IPV6 is non NULL,
		 * M and OFF are valid.
		 */
		struct sockaddr_in6 sa6_src;

		/* check if we can safely examine src and dst ports */
		if (m->m_pkthdr.len < off + sizeof(*uhp))
			return;

		bzero(&uh, sizeof(uh));
		m_copydata(m, off, sizeof(*uhp), (caddr_t)&uh);

		bzero(&sa6_src, sizeof(sa6_src));
		sa6_src.sin6_family = AF_INET6;
		sa6_src.sin6_len = sizeof(sa6_src);
		sa6_src.sin6_addr = ip6->ip6_src;
		sa6_src.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.rcvif,
							 &ip6->ip6_src);
#ifndef SCOPEDROUTING
		if (in6_embedscope(&sa6_src.sin6_addr, &sa6_src, NULL, NULL)) {
			/* should be impossbile */
			printf("udp6_ctlinput: in6_embedscope failed\n");
			return;
		}
#endif

		if (cmd == PRC_MSGSIZE) {
			int valid = 0;

			/*
			 * Check to see if we have a valid UDP socket
			 * corresponding to the address in the ICMPv6 message
			 * payload.
			 */
			if (in6_pcbhashlookup(&udbtable, &finaldst,
			    uh.uh_dport, &sa6_src.sin6_addr, uh.uh_sport))
				valid = 1;
			else if (in_pcblookup(&udbtable, &sa6.sin6_addr,
			    uh.uh_dport, &sa6_src.sin6_addr, uh.uh_sport,
			    INPLOOKUP_IPV6))
				valid = 1;
#if 0
			/*
			 * As the use of sendto(2) is fairly popular,
			 * we may want to allow non-connected pcb too.
			 * But it could be too weak against attacks...
			 * We should at least check if the local address (= s)
			 * is really ours.
			 */
			else if (in_pcblookup(&udbtable, &sa6.sin6_addr,
			    uh.uh_dport, &sa6_src.sin6_addr, uh.uh_sport,
			    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6))
				valid = 1;
#endif

			/*
			 * Depending on the value of "valid" and routing table
			 * size (mtudisc_{hi,lo}wat), we will:
			 * - recalcurate the new MTU and create the
			 *   corresponding routing entry, or
			 * - ignore the MTU change notification.
			 */
			icmp6_mtudisc_update((struct ip6ctlparam *)d, valid);

			/*
			 * regardless of if we called icmp6_mtudisc_update(),
			 * we need to call in6_pcbnotify(), to notify path
			 * MTU change to the userland (2292bis-02), because
			 * some unconnected sockets may share the same
			 * destination and want to know the path MTU.
			 */
		}
d675 1
a675 7
		(void) in6_pcbnotify(&udbtable, (struct sockaddr *)&sa6,
		     uh.uh_dport, (struct sockaddr *)&sa6_src,
		     uh.uh_sport, cmd, cmdarg, notify);
	} else {
		(void) in6_pcbnotify(&udbtable, (struct sockaddr *)&sa6, 0,
		     (struct sockaddr *)&sa6_any, 0, cmd, cmdarg, notify);
	}
d686 1
a686 1
	register struct udphdr *uhp;
a690 6
	if (sa == NULL)
		return NULL;
	if (sa->sa_family != AF_INET ||
	    sa->sa_len != sizeof(struct sockaddr_in))
		return NULL;

d700 20
d721 3
a723 3
		uhp = (struct udphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		in_pcbnotify(&udbtable, sa, uhp->uh_dport, ip->ip_src,
		    uhp->uh_sport, errno, notify);
d745 6
d759 3
a761 3
#ifdef DIAGNOSTIC
	if ((inp->inp_flags & INP_IPV6) != 0)
		panic("IPv6 inpcb to udp_output");
d764 8
a771 7
	/*
	 * Compute the packet length of the IP header, and
	 * punt if the length looks bogus.
	 */
	if ((len + sizeof(struct udpiphdr)) > IP_MAXPACKET) {
		error = EMSGSIZE;
		goto release;
d773 1
d776 4
d782 2
a783 1
		 * temporary connection.
d787 5
d793 8
a800 1
		if (inp->inp_faddr.s_addr != INADDR_ANY) {
d814 8
a821 1
		if (inp->inp_faddr.s_addr == INADDR_ANY) {
d830 8
d839 1
d846 9
d858 72
a929 9
	ui = mtod(m, struct udpiphdr *);
	bzero(ui->ui_x1, sizeof ui->ui_x1);
	ui->ui_pr = IPPROTO_UDP;
	ui->ui_len = htons((u_int16_t)len + sizeof (struct udphdr));
	ui->ui_src = inp->inp_laddr;
	ui->ui_dst = inp->inp_faddr;
	ui->ui_sport = inp->inp_lport;
	ui->ui_dport = inp->inp_fport;
	ui->ui_ulen = ui->ui_len;
d931 28
a958 3
	/*
	 * Stuff checksum and output datagram.
	 */
d960 47
a1006 15
	ui->ui_sum = 0;
	if (udpcksum) {
		if ((ui->ui_sum = in_cksum(m, sizeof (struct udpiphdr) +
		    len)) == 0)
			ui->ui_sum = 0xffff;
	}
	((struct ip *)ui)->ip_len = sizeof (struct udpiphdr) + len;
	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;	
	((struct ip *)ui)->ip_tos = inp->inp_ip.ip_tos;

	udpstat.udps_opackets++;
	error = ip_output(m, inp->inp_options, &inp->inp_route,
		inp->inp_socket->so_options &
		(SO_DONTROUTE | SO_BROADCAST),
		inp->inp_moptions, inp, NULL);
d1012 5
d1020 5
a1024 1
	if (control)
d1026 1
d1031 5
a1035 1
	if (control)
d1037 1
d1045 1
a1045 1
#ifdef INET6
a1053 1

a1172 1
		{
a1176 1
		}
d1197 3
a1199 1
	    /* XXX Find IPsec TDB */
a1200 6
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			return (udp6_output(inp, m, addr, control));
		else
			return (udp_output(m, inp, addr, control));
#else
a1201 1
#endif
@


1.38.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.38.2.2 2001/05/14 22:40:15 niklas Exp $	*/
d36 1
a36 37
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
d39 12
d52 1
a52 1
#include <sys/systm.h>
d57 6
d78 6
d88 4
d119 1
a174 1
	struct m_tag *mtag;
d202 2
d226 1
a226 2
		if ((m = m_pullup2(m, iphlen + sizeof(struct udphdr))) ==
		    NULL) {
d290 7
a296 21
		if ((m->m_pkthdr.csum & M_UDP_CSUM_IN_OK) == 0) {
			if (m->m_pkthdr.csum & M_UDP_CSUM_IN_BAD) {
				udpstat.udps_badsum++;
				udpstat.udps_inhwcsum++;
				m_freem(m);
				return;
			}

			bzero(((struct ipovly *)ip)->ih_x1,
			      sizeof ((struct ipovly *)ip)->ih_x1);
			((struct ipovly *)ip)->ih_len = uh->uh_ulen;
		
			if ((uh->uh_sum = in_cksum(m, len +
			    sizeof (struct ip))) != 0) {
				udpstat.udps_badsum++;
				m_freem(m);
				return;
			}
		} else {
			m->m_pkthdr.csum &= ~M_UDP_CSUM_IN_OK;
			udpstat.udps_inhwcsum++;
d508 1
d518 2
a519 1
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
d521 3
a523 2
	if (mtag != NULL) {
		tdbi = (struct tdb_ident *)(mtag + 1);
d525 1
a525 2
	} else
		tdb = NULL;
d527 2
a528 1
	    IPSP_DIRECTION_IN, tdb, inp);
d530 1
a530 29
	/* Latch SA only if the socket is connected */
	if (inp->inp_tdb_in != tdb &&
	    (inp->inp_socket->so_state & SS_ISCONNECTED)) {
		if (tdb) {
		        tdb_add_inp(tdb, inp, 1);
			if (inp->inp_ipsec_remoteid == NULL &&
			    tdb->tdb_srcid != NULL) {
				inp->inp_ipsec_remoteid = tdb->tdb_srcid;
				tdb->tdb_srcid->ref_count++;
			}
			if (inp->inp_ipsec_remotecred == NULL &&
			    tdb->tdb_remote_cred != NULL) {
				inp->inp_ipsec_remotecred =
				    tdb->tdb_remote_cred;
				tdb->tdb_remote_cred->ref_count++;
			}
			if (inp->inp_ipsec_remoteauth == NULL &&
			    tdb->tdb_remote_auth != NULL) {
				inp->inp_ipsec_remoteauth =
				    tdb->tdb_remote_auth;
				tdb->tdb_remote_auth->ref_count++;
			}
		} else { /* Just reset */
		        TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp,
				     inp_tdb_in_next);
			inp->inp_tdb_in = NULL;
		}
	}
        splx(s);
d532 1
a532 1
	/* Error or otherwise drop-packet indication. */
d675 2
a676 1
			/* should be impossible */
d692 2
a693 1
			/* should be impossible */
d702 2
a703 1
			/* should be impossible */
d731 2
a732 1
			/* should be impossible */
d920 1
a920 2
	 * Compute the pseudo-header checksum; defer further checksumming
	 * until ip_output() or hardware (if it exists).
d922 2
d925 4
a928 6
		m->m_pkthdr.csum |= M_UDPV4_CSUM_OUT;
		ui->ui_sum = in_cksum_phdr(ui->ui_src.s_addr,
		    ui->ui_dst.s_addr, htons((u_int16_t)len +
			sizeof (struct udphdr) + IPPROTO_UDP));
	} else
		ui->ui_sum = 0;
d1115 3
d1178 1
@


1.38.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 3
a114 3
static	void udp_detach(struct inpcb *);
static	void udp_notify(struct inpcb *, int);
static	struct mbuf *udp_saveopt(caddr_t, int, int);
d154 1
d156 5
d687 1
a687 1
	void (*notify)(struct inpcb *, int) = udp_notify;
d845 1
a845 1
	void (*notify)(struct inpcb *, int) = udp_notify;
d873 1
d875 5
@


1.38.2.5
log
@Sync the SMP branch with 3.3
@
text
@d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
d160 1
d162 1
a162 1
	int iphlen, len;
d173 1
a173 1
	struct ip6_hdr *ip6;
d192 1
a192 1
		ip6 = NULL;
d199 1
a199 1
		ip6 = mtod(m, struct ip6_hdr *);
d232 2
a233 2
		if (ip6)
			ip6 = mtod(m, struct ip6_hdr *);
d253 1
a253 1
		    len < sizeof(struct udphdr)) {
d273 1
a273 1
	if (ip6) {
d275 2
a276 2
		if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
		    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
d300 1
a300 1
			    sizeof ((struct ipovly *)ip)->ih_x1);
d302 1
a302 1

d337 1
a337 1
		srcsa.sin6.sin6_flowinfo = htonl(0x0fffffff) & ip6->ip6_flow;
d340 1
a340 1
		(void)in6_recoverscope(&srcsa.sin6, &ip6->ip6_src,
d348 1
a348 1
		(void)in6_recoverscope(&dstsa.sin6, &ip6->ip6_dst,
d355 1
a355 1
	if ((ip6 && IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) ||
d357 1
a357 1
	    (ip && in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif))) {
d360 1
a360 1
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif)) {
d362 1
d392 1
a392 1
			if (ip6 && !(inp->inp_flags & INP_IPV6))
d394 1
a394 1
			if (!ip6 && (inp->inp_flags & INP_IPV6))
d400 1
a400 1
			if (ip6) {
d403 1
a403 1
					    &ip6->ip6_dst))
d413 1
a413 1
			if (ip6) {
d416 1
a416 1
					    &ip6->ip6_src) ||
d418 1
a418 1
						continue;
d434 2
a435 2
					if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS))
						ip6_savecontrol(inp, &opts, ip6, n);
d474 2
a475 2
		if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS))
			ip6_savecontrol(inp, &opts, ip6, m);
d478 1
a478 1
		if (sbappendaddr(&last->so_rcv,
d490 3
a492 3
	if (ip6)
		inp = in6_pcbhashlookup(&udbtable, &ip6->ip6_src, uh->uh_sport,
		    &ip6->ip6_dst, uh->uh_dport);
d500 1
a500 1
		if (ip6) {
d502 2
a503 2
			    (struct in_addr *)&(ip6->ip6_src),
			    uh->uh_sport, (struct in_addr *)&(ip6->ip6_dst),
d516 1
a516 1
			if (ip6) {
d525 1
a525 1
				    0, 0);
d533 1
a533 1
	s = splnet();
d536 1
a536 1
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
a540 4
	if (error) {
		splx(s);
		goto bad;
	}
d546 2
a547 10
			tdb_add_inp(tdb, inp, 1);
			if (inp->inp_ipo == NULL) {
				inp->inp_ipo = ipsec_add_policy(inp,
				    srcsa.sa.sa_family, IPSP_DIRECTION_OUT);
				if (inp->inp_ipo == NULL) {
					splx(s);
					goto bad;
				}
			}
			if (inp->inp_ipo->ipo_dstid == NULL &&
d549 1
a549 1
				inp->inp_ipo->ipo_dstid = tdb->tdb_srcid;
d565 2
a566 2
			TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp,
			    inp_tdb_in_next);
d570 5
a574 1
	splx(s);
d579 2
a580 2
	if (ip6 && (inp->inp_flags & IN6P_CONTROLOPTS))
		ip6_savecontrol(inp, &opts, ip6, m);
d728 1
a728 1
		    ip6cp->ip6c_finaldst);
d765 1
a765 1
		    &ip6->ip6_src);
d821 2
a822 2
		    uh.uh_dport, (struct sockaddr *)&sa6_src,
		    uh.uh_sport, cmd, cmdarg, notify);
d825 1
a825 1
		    (struct sockaddr *)&sa6_any, 0, cmd, cmdarg, notify);
d899 1
a899 1
		/*
d903 1
a903 1
		pcbflags = inp->inp_flags;
d905 1
a905 1
		laddr = inp->inp_laddr;
d957 1
a957 1
		    sizeof (struct udphdr) + IPPROTO_UDP));
d961 1
a961 1
	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;
d966 3
a968 2
	    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
	    inp->inp_moptions, inp, (void *)NULL);
d973 2
a974 2
		inp->inp_flags = pcbflags;
		inp->inp_laddr = laddr;
d1079 1
a1079 1
#ifdef INET6
d1113 1
a1113 1
#ifdef INET6
@


1.38.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.38.2.5 2003/03/28 00:06:55 niklas Exp $	*/
a110 2
struct	inpcbtable udbtable;
struct	udpstat udpstat;
@


1.38.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.38.2.6 2003/05/13 19:36:18 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d208 30
a237 4
	IP6_EXTHDR_GET(uh, struct udphdr *, m, iphlen, sizeof(struct udphdr));
	if (!uh) {
		udpstat.udps_hdrops++;
		return;
d239 1
d252 3
a254 16
	if (ip) {
		if (m->m_pkthdr.len - iphlen != len) {
			if (len > (m->m_pkthdr.len - iphlen) ||
			    len < sizeof(struct udphdr)) {
				udpstat.udps_badlen++;
				goto bad;
			}
			m_adj(m, len - (m->m_pkthdr.len - iphlen));
		}
	}
#ifdef INET6
	else if (ip6) {
		/* jumbograms */
		if (len == 0 && m->m_pkthdr.len - iphlen > 0xffff)
			len = m->m_pkthdr.len - iphlen;
		if (len != m->m_pkthdr.len - iphlen) {
d258 1
a259 4
#endif
	else /* shouldn't happen */
		goto bad;

d618 2
a619 1
	if (sbappendaddr(&inp->inp_socket->so_rcv, &srcsa.sa, m, opts) == 0) {
@


1.38.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a91 5
#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#include <netinet/ip_esp.h>
#endif

d154 3
a156 3
	struct ip *ip;
	struct udphdr *uh;
	struct inpcb *inp;
a301 36
#ifdef IPSEC
	if (udpencap_enable && udpencap_port &&
	    uh->uh_dport == htons(udpencap_port)) {
		u_int32_t spi;
		int skip = iphlen + sizeof(struct udphdr);

		if (m->m_pkthdr.len - skip < sizeof(u_int32_t)) {
			/* packet too short */
			m_freem(m);
			return;
		}
		m_copydata(m, skip, sizeof(u_int32_t), (caddr_t) &spi);
		/*
		 * decapsulate if the SPI is not zero, otherwise pass
		 * to userland
		 */
		if (spi != 0) {
			if ((m = m_pullup2(m, skip)) == NULL) {
				udpstat.udps_hdrops++;
				return;
			}

			/* remove the UDP header */
			bcopy(mtod(m, u_char *),
			    mtod(m, u_char *) + sizeof(struct udphdr), iphlen);
			m_adj(m, sizeof(struct udphdr));
			skip -= sizeof(struct udphdr);

			espstat.esps_udpencin++;
			ipsec_common_input(m, skip, offsetof(struct ip, ip_p),
			    srcsa.sa.sa_family, IPPROTO_ESP, 1);
			return;
		}
	}
#endif

d372 3
a374 1
		CIRCLEQ_FOREACH(inp, &udbtable.inpt_queue, inp_queue) {
d486 4
a489 3
			inp = in6_pcblookup_listen(&udbtable,
			    &ip6->ip6_dst, uh->uh_dport, m_tag_find(m,
			    PACKET_TAG_PF_TRANSLATE_LOCALHOST, NULL) != NULL);
d492 2
a493 3
		inp = in_pcblookup_listen(&udbtable,
		    ip->ip_dst, uh->uh_dport, m_tag_find(m,
		    PACKET_TAG_PF_TRANSLATE_LOCALHOST, NULL) != NULL);
d622 1
a622 1
	int size;
d625 1
a625 1
	struct cmsghdr *cp;
d646 1
a646 1
	struct inpcb *inp;
d663 1
a663 1
	struct ip6_hdr *ip6;
d668 1
d773 1
a773 1
			if (in6_pcbhashlookup(&udbtable, &sa6.sin6_addr,
d776 4
d788 3
a790 2
			else if (in6_pcblookup_listen(&udbtable,
			    &sa6_src.sin6_addr, uh.uh_sport, 0);
d828 2
a829 2
	struct ip *ip = v;
	struct udphdr *uhp;
d851 1
a851 1
		(void) in_pcbnotify(&udbtable, sa, uhp->uh_dport, ip->ip_src,
d861 1
a861 1
	struct inpcb *inp;
d863 2
a864 2
	struct udpiphdr *ui;
	int len = m->m_pkthdr.len;
d952 1
a952 1
	((struct ip *)ui)->ip_len = htons(sizeof (struct udpiphdr) + len);
@


1.38.2.9
log
@Merge with the trunk
@
text
@a111 6
u_int	udp_sendspace = 9216;		/* really max datagram size */
u_int	udp_recvspace = 40 * (1024 + sizeof(struct sockaddr_in));
					/* 40 1K datagrams */

int *udpctl_vars[UDPCTL_MAXID] = UDPCTL_VARS;

a274 4
		if (uh->uh_sum == 0) {
			udpstat.udps_nosum++;
			goto bad;
		}
d290 6
a295 2
			if ((uh->uh_sum = in4_cksum(m, IPPROTO_UDP,
			    iphlen, len))) {
a540 1
				uh->uh_sum = savesum;
d1012 4
d1264 2
d1269 4
a1273 3
		if (name[0] < UDPCTL_MAXID)
			return (sysctl_int_arr(udpctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
@


1.37
log
@Early check for destination port 0 (itojun@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.36 2000/01/04 10:38:36 itojun Exp $	*/
d90 1
a90 1
#include <netinet6/ip6.h>
d93 1
a93 1
#include <netinet6/icmp6.h>
@


1.36
log
@keep paren match.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.35 2000/01/04 04:17:39 itojun Exp $	*/
d250 6
@


1.35
log
@remove support for v4 mapped address completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.34 1999/12/31 22:07:44 itojun Exp $	*/
d352 1
a352 1
	    (ip && in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif))) {
d355 1
a355 1
	    in_broadcast(ip->ip_dst, m->m_pkthdr.rcvif)) {
d357 1
@


1.34
log
@be sure to cleanup "opts" pointer on multicast udp packet reception.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.33 1999/12/21 15:41:08 itojun Exp $	*/
a95 9
#ifndef CREATE_IPV6_MAPPED
#define CREATE_IPV6_MAPPED(a6, a4) \
do { \
	bzero(&(a6), sizeof(a6));			\
	(a6).s6_addr[10] = (a6).s6_addr[11] = 0xff;	\
	*(u_int32_t *)&(a6).s6_addr[12] = (a4);		\
} while (0)
#endif

a96 1

a174 1
	struct sockaddr_in6 src_v4mapped;
a314 8
#ifdef INET6
		bzero(&src_v4mapped, sizeof(struct sockaddr_in6));
		src_v4mapped.sin6_len = sizeof(struct sockaddr_in6);
		src_v4mapped.sin6_family = AF_INET6;
		src_v4mapped.sin6_port = uh->uh_sport;
		CREATE_IPV6_MAPPED(src_v4mapped.sin6_addr, ip->ip_src.s_addr);
#endif /* INET6 */

a432 10
#ifdef INET6							 
					/*
					 * This cruft is needed in (the rare)
					 * case I deliver a {multi,broad}cast
					 * IPv4 packet to an AF_INET6 socket.
					 */
					    ((((struct inpcb *)last->so_pcb)->inp_flags
					    & INP_IPV6) && ip) ?
					    (struct sockaddr *)&src_v4mapped :
#endif /* INET6 */
a472 9
#ifdef INET6
	        /*
		 * This cruft is needed in (the rare) case I
		 * deliver a {multi,broad}cast IPv4 packet to
		 * an AF_INET6 socket.
		 */
		    ((((struct inpcb *)last->so_pcb)->inp_flags & INP_IPV6) && ip) ?
		    (struct sockaddr *)&src_v4mapped :
#endif /* INET6 */
a584 8
#ifdef INET6
	    /*
	     * This cruft is needed to deliver a IPv4 packet to
	     * an AF_INET6 socket.
	     */
	    ((((struct inpcb *)inp->inp_socket->so_pcb)->inp_flags & INP_IPV6)
	    && ip) ? (struct sockaddr *)&src_v4mapped : 
#endif /* INET6 */
@


1.33
log
@be paranoid about malicious use of v4 mapped addr on v6 packet.
malicious party may try to use v4 mapped addr as source/dest to
confuse tcp/udp layer, or to bypass security checks,
for example, naive stack can mistakingly think a packet with
src = ::ffff:127.0.0.1 is from local node.

(sync with kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.32 1999/12/19 02:52:21 itojun Exp $	*/
d464 2
d469 1
@


1.32
log
@reject AF mismatch for inbonud multicast traffic.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.31 1999/12/17 22:47:05 itojun Exp $	*/
d290 7
@


1.31
log
@do not accept IPv4 traffic by AF_INET6 socket.  IPv4 mapped address is
bad for access controls.
(quickhack fix, need sysctl/setsockopt knob to enable this functionality)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.30 1999/12/12 10:59:41 itojun Exp $	*/
d396 7
a406 2
				if (!(inp->inp_flags & INP_IPV6))
					continue;
a416 5
			} else {
#ifdef INET6
				if (inp->inp_flags & INP_IPV6)
					continue;	/*XXX*/
#endif
a431 5
			} else {
#ifdef INET6
				if (inp->inp_flags & INP_IPV6)
					continue;	/*XXX*/
#endif
@


1.30
log
@fix IPv6 advanced API (RFC2292) for udp socket.
TODO: ditto for raw and tcp socket
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.29 1999/12/08 06:50:20 itojun Exp $	*/
d412 5
d432 5
@


1.29
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.28 1999/11/04 11:24:24 ho Exp $	*/
d240 4
a243 7
#ifdef INET6
	if (ip)
#endif /* INET6 */
		if (iphlen > sizeof (struct ip)) {
			ip_stripoptions(m, (struct mbuf *)0);
			iphlen = sizeof(struct ip);
		}
d387 1
a387 3
		m->m_len -= iphlen;
		m->m_pkthdr.len -= iphlen;
		m->m_data += iphlen;
d433 1
d435 2
a436 6
#if 0 /*XXX*/
					if (ipv6)
						opts = ipv6_headertocontrol(m, iphlen, ((struct inpcb *)last->so_pcb)->inp_flags);
#else
						opts = NULL;
#endif
d438 1
d450 1
a450 1
					    &srcsa.sa, n, (struct mbuf *)0) == 0) {
d480 1
d482 2
a483 7
#if 0 /*XXX*/
		if (ipv6)
			opts = ipv6_headertocontrol(m, iphlen,
			    ((struct inpcb *)last->so_pcb)->inp_flags);
#else
			opts = NULL;
#endif
d485 1
d496 1
a496 1
		    &srcsa.sa, m, (struct mbuf *)0) == 0) {
d574 6
a579 1
	if (inp->inp_flags & INP_CONTROLOPTS) {
a581 12
#ifdef INET6
		if (ipv6) {
#if 0 /*XXX*/
			if (inp->inp_flags & INP_IPV6)
				opts = ipv6_headertocontrol(m, iphlen,
				    inp->inp_flags);
#else
			opts = NULL;
#endif
		} else
			if (ip)
#endif /* INET6 */
d606 1
a606 4
	m->m_len -= iphlen;
	m->m_pkthdr.len -= iphlen;
	m->m_data += iphlen;

a771 1
	struct ifnet *forceif = NULL;
d773 1
d783 15
a797 4
#ifndef INET6
	if (control)
		m_freem(control);		/* XXX */
#endif /* INET6 */
d841 1
a841 1
		    (inp->inp_faddr.s_addr == INADDR_ANY)) {
d843 1
a843 1
		if (inp->inp_faddr.s_addr == INADDR_ANY) {
d845 1
a858 6
	v6packet = ((inp->inp_flags & INP_IPV6) &&
		    !(inp->inp_flags & INP_IPV6_MAPPED));

	if (!v6packet && control)
		m_freem(control);

a959 8
		if (control) {
#if 0 /*XXX*/
			if ((error = ipv6_controltoheader(&m, control,
			    &forceif, &payload)))
				goto release;
#endif
		}

d967 1
a967 1
		error = ip6_output(m, NULL, &inp->inp_route6, 
d970 1
a970 1
		    &forceif);
d1017 1
a1017 1
		if (inp->inp_flags & INP_IPV6_MCAST)
d1022 1
a1022 1
		else
d1024 1
d1029 1
d1040 2
a1041 2
#endif /* INET6 */
		inp->inp_laddr = laddr;
d1044 7
d1055 7
@


1.28
log
@Add comment about gettdb() and spl level.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.27 1999/09/23 07:20:35 deraadt Exp $	*/
d87 4
a90 2
#include <netinet6/in6.h>
#include <netinet6/ipv6.h>
d92 12
a103 2
#include <netinet6/ipv6_var.h>
#include <netinet6/ipv6_icmp.h>
d105 1
a105 1
extern int ipv6_defhoplmt;
d135 23
d184 1
a184 1
	struct ipv6 *ipv6;
d220 1
a220 1
		ipv6 = mtod(m, struct ipv6 *);
d258 1
a258 1
			ipv6 = mtod(m, struct ipv6 *);
d296 1
a296 1
		if ((uh->uh_sum = in6_cksum(m, IPPROTO_UDP, len, iphlen))) {
d342 12
a353 2
		srcsa.sin6.sin6_flowinfo = htonl(0x0fffffff) & ipv6->ipv6_versfl;
		srcsa.sin6.sin6_addr = ipv6->ipv6_src;
d359 1
a359 1
		dstsa.sin6.sin6_addr = ipv6->ipv6_dst;
d365 1
a365 1
	if ((ipv6 && IN6_IS_ADDR_MULTICAST(&ipv6->ipv6_dst)) ||
d409 1
a409 1
					    &ipv6->ipv6_dst))
d422 1
a422 1
					    &ipv6->ipv6_src) ||
d439 1
d442 3
d488 1
d492 3
d518 2
a519 2
		inp = in6_pcbhashlookup(&udbtable, &ipv6->ipv6_src, uh->uh_sport,
		    &ipv6->ipv6_dst, uh->uh_dport);
d529 2
a530 2
			    (struct in_addr *)&(ipv6->ipv6_src),
			    uh->uh_sport, (struct in_addr *)&(ipv6->ipv6_dst),
d542 5
a546 8
			*ip = save_ip;
			HTONS(ip->ip_id);
			uh->uh_sum = savesum;
#ifdef INET6
			if (ipv6)
				ipv6_icmp_error(m, ICMPV6_UNREACH,
				    ICMPV6_UNREACH_PORT,0);
			else
d548 9
a556 1
			icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_PORT, 0, 0);
d589 1
d593 3
d687 36
d744 2
d749 1
a749 1
			struct ipv6 *ipv6 = (struct ipv6 *)ip;
d751 2
a752 1
			uh = (struct udphdr *)((caddr_t)ipv6 + sizeof(struct ipv6));
d754 4
a757 2
			    &(ipv6->ipv6_src), uh->uh_sport, cmd, udp_notify);
		} else
d760 2
d793 1
d809 4
d823 1
a823 1
		else  
d829 1
a829 1
		    (inp->inp_faddr.s_addr != INADDR_ANY)) {
d831 1
a831 1
		if (inp->inp_faddr.s_addr != INADDR_ANY) {
d833 1
d874 1
a874 1
	    sizeof(struct ipv6)) : sizeof(struct udpiphdr), M_DONTWAIT);
d898 1
a898 1
		struct ipv6 *ipv6 = mtod(m, struct ipv6 *);
d900 5
a904 2
		    sizeof(struct ipv6));
		int payload = sizeof(struct ipv6);
d906 2
a907 2
		ipv6->ipv6_versfl = htonl(0x60000000) |
		    (inp->inp_ipv6.ipv6_versfl & htonl(0x0fffffff)); 
d909 59
a967 5
		ipv6->ipv6_hoplimit = inp->inp_ipv6.ipv6_hoplimit;
		ipv6->ipv6_nexthdr = IPPROTO_UDP;
		ipv6->ipv6_src = inp->inp_laddr6;
		ipv6->ipv6_dst = inp->inp_faddr6;
		ipv6->ipv6_length = (u_short)len + sizeof(struct udphdr);
d971 1
a971 1
		uh->uh_ulen = htons(ipv6->ipv6_length);
d974 2
a975 1
		if (control)
d979 2
d985 2
a986 2
		if (!(uh->uh_sum = in6_cksum(m, IPPROTO_UDP, len +
		    sizeof(struct udphdr), payload))) 
d989 1
a989 1
		error = ipv6_output(m, &inp->inp_route6, 
d992 1
a992 1
		    forceif, inp->inp_socket);
d1075 13
d1134 2
a1135 2
			((struct inpcb *) so->so_pcb)->inp_ipv6.ipv6_hoplimit =
			    ipv6_defhoplmt;
d1147 6
a1152 1
		error = in_pcbbind(inp, addr);
d1167 3
d1172 1
d1177 4
a1181 3
		s = splsoftnet();
		error = in_pcbconnect(inp, addr);
		splx(s);
d1239 6
a1244 1
		in_setsockaddr(inp, addr);
d1248 6
a1253 1
		in_setpeeraddr(inp, addr);
@


1.27
log
@fix same-interface-out-as-in and packet gets corrupted bug noted by
james@@oaktree.co.uk by re-working icmp embedded-packet code so that
ip_forward() m_copy()-aliased packet can be forwarded to ip_output and
icmp_error() safely, because no packet tweaking is needed before
calling icmp_error()
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.26 1999/06/06 23:34:20 deraadt Exp $	*/
d166 2
@


1.26
log
@avoid a future problem inside an #ifdef notyet
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.25 1999/03/27 21:04:20 provos Exp $	*/
a487 1
			HTONS(ip->ip_len);
a488 1
			HTONS(ip->ip_off);
@


1.25
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.24 1999/03/24 02:59:06 cmetz Exp $	*/
d516 1
@


1.24
log
@Reworked udp_output() to minimize the number of if() statements needed to get
packets out. Also had the nice side effect of fewer blocks now move around by
ifdefs, which makes it more readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.23 1999/02/17 00:14:26 deraadt Exp $	*/
d79 2
d152 3
d162 10
d502 22
@


1.23
log
@inet6 indent
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.22 1999/02/04 16:05:02 deraadt Exp $	*/
d771 1
a771 1
		goto release;
d779 5
a795 1
        }
d797 11
a807 3
	/*
	 * Stuff checksum and output datagram.
	 */
d809 13
a821 1
	if (!v6packet) {
d823 4
a826 26
	ui->ui_sum = 0;
	if (udpcksum) {
		if ((ui->ui_sum = in_cksum(m, sizeof (struct udpiphdr) +
		    len)) == 0)
			ui->ui_sum = 0xffff;
	}
	((struct ip *)ui)->ip_len = sizeof (struct udpiphdr) + len;
#ifdef INET6
	/*
	 *  For now, we use the default values for ttl and tos for 
	 *  v4 packets sent using a v6 pcb.  We probably want to
	 *  later allow v4 setsockopt operations on a v6 socket to 
	 *  modify the ttl and tos for v4 packets sent using
	 *  the mapped address format.  We really ought to
	 *  save the v4 ttl and v6 hoplimit in separate places 
	 *  instead of craming both in the inp_hu union.
	 */
	if (inp->inp_flags & INP_IPV6) {
		((struct ip *)ui)->ip_ttl = ip_defttl;
		((struct ip *)ui)->ip_tos = 0;	  
	} else
#endif /* INET6 */
	{
		((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;	/* XXX */
		((struct ip *)ui)->ip_tos = inp->inp_ip.ip_tos;	/* XXX */
	}
d828 1
a828 3
	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;	/* XXX */
	((struct ip *)ui)->ip_tos = inp->inp_ip.ip_tos;	/* XXX */
	udpstat.udps_opackets++;
a829 6
	if (v6packet)
		error = ipv6_output(m, &inp->inp_route6, 
		    inp->inp_socket->so_options & SO_DONTROUTE,
		    (inp->inp_flags & INP_IPV6_MCAST)?inp->inp_moptions6:NULL,
		    forceif, inp->inp_socket);
	else
d831 5
a835 4
		    error = ip_output(m, inp->inp_options, &inp->inp_route,
		    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
		    NULL, NULL, inp->inp_socket);
	else
d837 5
a841 3
		error = ip_output(m, inp->inp_options, &inp->inp_route,
		    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
		    inp->inp_moptions, inp);
@


1.22
log
@report on no udp checksum
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.21 1999/01/15 12:01:07 niklas Exp $	*/
d173 2
a174 1
		printf("udp_input: received unknown IP version %d", mtod(m, struct ip *)->ip_v);
d189 1
a189 1
        if (ip)
d191 4
a194 4
	if (iphlen > sizeof (struct ip)) {
		ip_stripoptions(m, (struct mbuf *)0);
		iphlen = sizeof(struct ip);
	}
d263 36
a298 36
	  case AF_INET:
	    bzero(&srcsa, sizeof(struct sockaddr_in));
	    srcsa.sin.sin_len = sizeof(struct sockaddr_in);
	    srcsa.sin.sin_family = AF_INET;
	    srcsa.sin.sin_port = uh->uh_sport;
	    srcsa.sin.sin_addr = ip->ip_src;

#ifdef INET6
	    bzero(&src_v4mapped, sizeof(struct sockaddr_in6));
	    src_v4mapped.sin6_len = sizeof(struct sockaddr_in6);
	    src_v4mapped.sin6_family = AF_INET6;
	    src_v4mapped.sin6_port = uh->uh_sport;
	    CREATE_IPV6_MAPPED(src_v4mapped.sin6_addr, ip->ip_src.s_addr);
#endif /* INET6 */

	    bzero(&dstsa, sizeof(struct sockaddr_in));
	    dstsa.sin.sin_len = sizeof(struct sockaddr_in);
	    dstsa.sin.sin_family = AF_INET;
	    dstsa.sin.sin_port = uh->uh_dport;
	    dstsa.sin.sin_addr = ip->ip_dst;
	    break;
#ifdef INET6
	  case AF_INET6:
	    bzero(&srcsa, sizeof(struct sockaddr_in6));
	    srcsa.sin6.sin6_len = sizeof(struct sockaddr_in6);
	    srcsa.sin6.sin6_family = AF_INET6;
	    srcsa.sin6.sin6_port = uh->uh_sport;
	    srcsa.sin6.sin6_flowinfo = htonl(0x0fffffff) & ipv6->ipv6_versfl;
	    srcsa.sin6.sin6_addr = ipv6->ipv6_src;

	    bzero(&dstsa, sizeof(struct sockaddr_in6));
	    dstsa.sin6.sin6_len = sizeof(struct sockaddr_in6);
	    dstsa.sin6.sin6_family = AF_INET6;
	    dstsa.sin6.sin6_port = uh->uh_dport;
	    dstsa.sin6.sin6_addr = ipv6->ipv6_dst;
	    break;
d346 2
a347 1
					if (!IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, &ipv6->ipv6_dst))
d359 3
a361 1
					if (!IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6, &ipv6->ipv6_src) || inp->inp_fport != uh->uh_sport)
d382 8
a389 4
					/* This cruft is needed in (the rare) case I deliver a {multi,broad}cast
					IPv4 packet to an AF_INET6 socket. */
					((((struct inpcb *)last->so_pcb)->inp_flags & INP_IPV6) && ip) ?
					(struct sockaddr *)&src_v4mapped : 
d391 1
a391 1
							&srcsa.sa, n, (struct mbuf *)0) == 0) {
d423 2
a424 1
			opts = ipv6_headertocontrol(m, iphlen, ((struct inpcb *)last->so_pcb)->inp_flags);
d428 7
a434 4
	        /* This cruft is needed in (the rare) case I deliver a
		   {multi,broad}cast IPv4 packet to an AF_INET6 socket. */
	       ((((struct inpcb *)last->so_pcb)->inp_flags & INP_IPV6) && ip) ?
		(struct sockaddr *)&src_v4mapped :
d436 1
a436 1
				&srcsa.sa, m, (struct mbuf *)0) == 0) {
d449 1
a449 1
			&ipv6->ipv6_dst, uh->uh_dport);
d458 4
a461 3
			inp = in_pcblookup(&udbtable, (struct in_addr *)&(ipv6->ipv6_src),
				uh->uh_sport, (struct in_addr *)&(ipv6->ipv6_dst),
				uh->uh_dport, INPLOOKUP_WILDCARD | INPLOOKUP_IPV6);
d479 2
a480 1
				ipv6_icmp_error(m, ICMPV6_UNREACH,ICMPV6_UNREACH_PORT,0);
d494 2
a495 1
				opts = ipv6_headertocontrol(m, iphlen, inp->inp_flags);
d529 6
a534 3
	/* This cruft is needed to deliver a IPv4 packet to an AF_INET6 socket. */
	((((struct inpcb *)inp->inp_socket->so_pcb)->inp_flags & INP_IPV6) && ip) ?
	(struct sockaddr *)&src_v4mapped : 
d610 2
a611 2
	  if (ip) {
	        struct ipv6 *ipv6 = (struct ipv6 *)ip;
d613 6
a618 4
		uh = (struct udphdr *)((caddr_t)ipv6 + sizeof(struct ipv6));
		in6_pcbnotify(&udbtable, sa, uh->uh_dport, &(ipv6->ipv6_src), uh->uh_sport, cmd, udp_notify);
	  } else
	        in6_pcbnotify(&udbtable, sa, 0, (struct in6_addr *)&in6addr_any, 0, cmd, udp_notify);
d674 1
a674 1
		  laddr6 = inp->inp_laddr6;
d677 1
a677 1
		laddr = inp->inp_laddr;
d680 2
a681 2
		     !IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
		    || (inp->inp_faddr.s_addr != INADDR_ANY)) {
d700 2
a701 2
		     IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6))
		    || (inp->inp_faddr.s_addr == INADDR_ANY)) {
d722 1
a722 1
	  m_freem(control);
d724 2
a725 1
	M_PREPEND(m, v6packet ? (sizeof(struct udphdr) + sizeof(struct ipv6)) : sizeof(struct udpiphdr), M_DONTWAIT);
d749 4
a752 3
	  struct ipv6 *ipv6 = mtod(m, struct ipv6 *);
	  struct udphdr *uh = (struct udphdr *)(mtod(m, caddr_t) + sizeof(struct ipv6));
          int payload = sizeof(struct ipv6);
d754 2
a755 1
	  ipv6->ipv6_versfl = htonl(0x60000000) | (inp->inp_ipv6.ipv6_versfl & htonl(0x0fffffff)); 
d757 34
a790 32
	  ipv6->ipv6_hoplimit = inp->inp_ipv6.ipv6_hoplimit;
	  ipv6->ipv6_nexthdr = IPPROTO_UDP;
	  ipv6->ipv6_src = inp->inp_laddr6;
	  ipv6->ipv6_dst = inp->inp_faddr6;
	  ipv6->ipv6_length = (u_short)len + sizeof(struct udphdr);
	  
	  uh->uh_sport = inp->inp_lport;
	  uh->uh_dport = inp->inp_fport;
	  uh->uh_ulen = htons(ipv6->ipv6_length);
	  uh->uh_sum = 0;

	  if (control)
	    if ((error = ipv6_controltoheader(&m, control, &forceif, &payload)))
	      goto release;

	  /* 
	   * Always calculate udp checksum for IPv6 datagrams
	   */
	  if (!(uh->uh_sum = in6_cksum(m, IPPROTO_UDP, len + sizeof(struct udphdr), payload))) 
	    uh->uh_sum = 0xffff;
	} else {    
#endif /* INET6 */
	ui = mtod(m, struct udpiphdr *);
	bzero(ui->ui_x1, sizeof ui->ui_x1);
	ui->ui_pr = IPPROTO_UDP;
	ui->ui_len = htons((u_int16_t)len + sizeof (struct udphdr));
	ui->ui_src = inp->inp_laddr;
	ui->ui_dst = inp->inp_faddr;
	ui->ui_sport = inp->inp_lport;
	ui->ui_dport = inp->inp_fport;
	ui->ui_ulen = ui->ui_len;
#ifdef INET6
a791 1
#endif /* INET6 */
d801 3
a803 2
	    if ((ui->ui_sum = in_cksum(m, sizeof (struct udpiphdr) + len)) == 0)
		ui->ui_sum = 0xffff;
d817 3
a819 9
	  ((struct ip *)ui)->ip_ttl = ip_defttl;
	  ((struct ip *)ui)->ip_tos = 0;	  
	} else {
#endif /* INET6 */
  	((struct ip *)ui)->ip_ttl = inp->inp_ip.ip_ttl;	/* XXX */
  	((struct ip *)ui)->ip_tos = inp->inp_ip.ip_tos;	/* XXX */
#ifdef INET6
	};
	};
d821 5
d831 9
a839 4
	  error = ipv6_output(m, &inp->inp_route6, 
	    inp->inp_socket->so_options & SO_DONTROUTE,
	    (inp->inp_flags & INP_IPV6_MCAST)?inp->inp_moptions6:NULL,
            forceif, inp->inp_socket);
d841 4
a844 9
	  if (inp->inp_flags & INP_IPV6_MCAST)
	    error = ip_output(m, inp->inp_options, &inp->inp_route,
	       inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
 	       NULL, NULL, inp->inp_socket);
	  else
#endif /* INET6 */
	error = ip_output(m, inp->inp_options, &inp->inp_route,
	    inp->inp_socket->so_options & (SO_DONTROUTE | SO_BROADCAST),
	    inp->inp_moptions, inp);
d852 1
a852 1
		  inp->inp_laddr6 = laddr6;
d882 4
a885 4
	  if (inp->inp_flags & INP_IPV6)
	        return (in6_control(so, (u_long)m, (caddr_t)addr,
			(struct ifnet *)control, 0));
	  else
d887 2
a888 2
		return (in_control(so, (u_long)m, (caddr_t)addr,
			(struct ifnet *)control));
d915 2
a916 2
		  ((struct inpcb *) so->so_pcb)->inp_ipv6.ipv6_hoplimit =
		    ipv6_defhoplmt;
d919 1
a919 1
		((struct inpcb *) so->so_pcb)->inp_ip.ip_ttl = ip_defttl;
d939 4
a942 4
		  if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6)) {
		        error = EISCONN;
			break;
		  }
d945 5
a949 4
		if (inp->inp_faddr.s_addr != INADDR_ANY) {
			error = EISCONN;
			break;
		}
d968 4
a971 4
		  if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6)) {
		        error = ENOTCONN;
			break;
		  }
d974 5
a978 4
		if (inp->inp_faddr.s_addr == INADDR_ANY) {
			error = ENOTCONN;
			break;
		}
d983 1
a983 1
		  inp->inp_laddr6 = in6addr_any;
d986 2
a987 1
		inp->inp_laddr.s_addr = INADDR_ANY;
@


1.21
log
@IN_MULTICAST takes network order addresses
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.20 1999/01/11 16:05:46 niklas Exp $	*/
d240 7
a246 7
	  /*
	   * In IPv6, the UDP checksum is ALWAYS used.
	   */
	  if ((uh->uh_sum = in6_cksum(m, IPPROTO_UDP, len, iphlen))) {
	    udpstat.udps_badsum++;
	    goto bad;
	  }
d258 2
a259 1
	}
@


1.20
log
@Use bzero instead of memset in the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.19 1999/01/11 02:01:36 deraadt Exp $	*/
d302 1
a302 1
	    (ip && IN_MULTICAST(ntohl(ip->ip_dst.s_addr))) ||
@


1.19
log
@netinet merge of NRL stuff. some indent and shrinkage needed; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.18 1999/01/07 06:05:05 deraadt Exp $	*/
d262 1
a262 1
	    memset(&srcsa, 0, sizeof(struct sockaddr_in));
d269 1
a269 1
	    memset(&src_v4mapped, 0, sizeof(struct sockaddr_in6));
d276 1
a276 1
	    memset(&dstsa, 0, sizeof(struct sockaddr_in));
d284 1
a284 1
	    memset(&srcsa, 0, sizeof(struct sockaddr_in6));
d291 1
a291 1
	    memset(&dstsa, 0, sizeof(struct sockaddr_in6));
@


1.18
log
@in_pcblookup() now takes ptr to both ip address arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.17 1998/12/31 11:16:55 deraadt Exp $	*/
d39 12
d84 11
a100 1
struct	sockaddr_in udp_in = { sizeof(udp_in), AF_INET };
d139 11
d157 20
d183 7
a197 1
	ip = mtod(m, struct ip *);
d199 1
a199 1
		if ((m = m_pullup(m, iphlen + sizeof(struct udphdr))) == 0) {
d203 6
a208 1
		ip = mtod(m, struct ip *);
d210 1
a210 1
	uh = (struct udphdr *)((caddr_t)ip + iphlen);
d217 3
a219 2
	if (ip->ip_len != len) {
		if (len > ip->ip_len || len < sizeof(struct udphdr)) {
d223 1
a223 2
		m_adj(m, len - ip->ip_len);
		/* ip->ip_len = len; */
d229 2
a230 1
	save_ip = *ip;
d238 11
d260 45
d307 1
a324 5
		/*
		 * Construct sockaddr format source address.
		 */
		udp_in.sin_port = uh->uh_sport;
		udp_in.sin_addr = ip->ip_src;
d339 9
d353 7
d371 4
d376 7
a382 2
						sintosa(&udp_in), n,
						(struct mbuf *)0) == 0) {
d411 13
a423 2
		if (sbappendaddr(&last->so_rcv, sintosa(&udp_in), m,
		    (struct mbuf *)0) == 0) {
d433 6
d443 7
d463 5
a472 6
	/*
	 * Construct sockaddr format source address.
	 * Stuff source address and datagram in user buffer.
	 */
	udp_in.sin_port = uh->uh_sport;
	udp_in.sin_addr = ip->ip_src;
d476 7
d510 8
a517 2
	if (sbappendaddr(&inp->inp_socket->so_rcv, sintosa(&udp_in), m,
	    opts) == 0) {
d589 11
d625 6
d638 1
d641 1
d644 12
d657 5
d663 1
d677 5
d683 1
d692 13
d706 1
d725 30
d764 3
d771 3
d780 21
d804 13
d824 6
d855 7
a861 1
	if (req == PRU_CONTROL)
d864 1
d888 6
d912 8
d940 8
d954 5
d992 4
@


1.17
log
@mangle uh_sum as before, but recover it for icmp errors
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.16 1998/12/28 23:54:58 deraadt Exp $	*/
d284 2
a285 2
		inp = in_pcblookup(&udbtable, ip->ip_src, uh->uh_sport,
		    ip->ip_dst, uh->uh_dport, INPLOOKUP_WILDCARD);
@


1.16
log
@ensure the ip packet embedded inside an icmp packet has correct ip_len,
ip_off, ip_id. for udp, also correct uh_sum.  ip_sum is still set to 0;
(all this debugged using nmap)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.15 1998/05/18 21:11:12 provos Exp $	*/
d116 1
d172 1
d177 1
a177 1
		if (in_cksum(m, len + sizeof (struct ip)) != 0) {
d296 1
@


1.15
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.14 1998/01/24 18:21:39 mickey Exp $	*/
d175 1
a175 1
		if ((uh->uh_sum = in_cksum(m, len + sizeof (struct ip))) != 0) {
d291 3
@


1.14
log
@sysctl for def sizes for tcp/udp send/recv queues
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.13 1997/09/07 02:19:24 deraadt Exp $	*/
d66 4
d508 1
a508 1
	    inp->inp_moptions);
d618 5
@


1.13
log
@for broadcast/multicast packets, correct m_pkthdr.len on the way up to the socket; drochner@@zelz26.zel.kfa-juelich.de
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.12 1997/08/09 23:36:28 millert Exp $	*/
d519 2
a520 2
u_long	udp_sendspace = 9216;		/* really max datagram size */
u_long	udp_recvspace = 40 * (1024 + sizeof(struct sockaddr_in));
d693 4
@


1.12
log
@The list of tcp/udp ports not to allocate dynamically is now
a bitmask configurable via sysctl([38]).  The default values
have not changed.  If one wants to change the list it should
be done early on in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.11 1997/07/24 00:31:15 deraadt Exp $	*/
d202 4
a205 2
		m->m_len -= sizeof (struct udpiphdr);
		m->m_data += sizeof (struct udpiphdr);
@


1.11
log
@cmd is a u_long
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.10 1997/06/27 02:23:22 deraadt Exp $	*/
d85 3
d688 3
@


1.10
log
@udp icmp errors had ip_len 20 bytes too large; stevens p774; koji@@math.human.nagoya-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.9 1997/02/16 04:42:50 deraadt Exp $	*/
d530 1
a530 1
		return (in_control(so, (long)m, (caddr_t)addr,
@


1.9
log
@udp packets less than min udp packet length are bad; davem@@jenolan.rutgers.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.8 1997/01/26 01:23:46 tholo Exp $	*/
a281 1
			ip->ip_len += iphlen;
@


1.8
log
@Make ip_len and ip_off unsigned values; don't transmit or accept packets
larger than the maximum IP packet size.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.7 1996/07/05 20:42:18 deraadt Exp $	*/
d146 1
a146 1
		if (len > ip->ip_len) {
@


1.7
log
@release temporary binding if M_PREPEND fails; netbsd pr#2605; tegge@@idt.unit.no; improved by me
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.6 1996/05/15 09:03:12 mickey Exp $	*/
d461 9
@


1.6
log
@let udpcksum control generation, but not cheking of udp cksums.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.4 1996/04/21 22:29:03 deraadt Exp $	*/
d460 1
a460 1
		goto release;
d493 1
@


1.5
log
@udpcksum should never be off in the modern world
@
text
@d161 2
d164 1
a164 1
	if (udpcksum && uh->uh_sum) {
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_usrreq.c,v 1.3 1996/03/03 22:30:51 niklas Exp $	*/
a71 1
#ifndef	COMPAT_42
a72 3
#else
int	udpcksum = 0;		/* XXX */
#endif
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: udp_usrreq.c,v 1.27 1996/02/13 23:44:32 christos Exp $	*/
d247 1
a247 1
			if ((last->so_options&(SO_REUSEPORT|SO_REUSEADDR) == 0))
@


1.2
log
@from netbsd:
make netinet work on systems where pointers and longs are 64 bits
(like the alpha).  Biggest problem: IP headers were overlayed with
structure which included pointers, and which therefore didn't overlay
properly on 64-bit machines.  Solution: instead of threading pointers
through IP header overlays, add a "queue element" structure to do
the threading, and point it at the ip headers.
@
text
@d1 2
a2 1
/*	$NetBSD: udp_usrreq.c,v 1.25 1995/11/21 01:07:46 cgd Exp $	*/
d47 5
d66 2
a78 1
struct	inpcb *udp_last_inpcb = 0;
d84 5
d93 1
a93 1
	in_pcbinit(&udbtable);
d97 7
a103 3
udp_input(m, iphlen)
	register struct mbuf *m;
	int iphlen;
d111 6
d170 1
a170 1
		if (uh->uh_sum = in_cksum(m, len + sizeof (struct ip))) {
d271 4
a274 7
	inp = udp_last_inpcb;
	if (inp == 0 ||
	    inp->inp_lport != uh->uh_dport ||
	    inp->inp_fport != uh->uh_sport ||
	    inp->inp_faddr.s_addr != ip->ip_src.s_addr ||
	    inp->inp_laddr.s_addr != ip->ip_dst.s_addr) {
		udpstat.udpps_pcbcachemiss++;
a287 1
		udp_last_inpcb = inp;
d378 2
a379 2
void
udp_ctlinput(cmd, sa, ip)
d382 1
a382 1
	register struct ip *ip;
d384 1
a385 1
	extern struct in_addr zeroin_addr;
d391 1
a391 1
		return;
d398 1
a398 1
		return;
d405 1
d409 8
a416 1
udp_output(inp, m, addr, control)
a417 1
	register struct mbuf *m;
a418 1
{
d422 8
a429 1
	int s, error = 0;
d602 1
a602 1
		return (udp_output(inp, m, addr, control));
a654 2
	if (inp == udp_last_inpcb)
		udp_last_inpcb = 0;
d662 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: udp_usrreq.c,v 1.24 1995/08/12 23:59:42 mycroft Exp $	*/
d145 2
a146 3
		((struct ipovly *)ip)->ih_next = 0;
		((struct ipovly *)ip)->ih_prev = 0;
		((struct ipovly *)ip)->ih_x1 = 0;
d439 1
a439 2
	ui->ui_next = ui->ui_prev = 0;
	ui->ui_x1 = 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
