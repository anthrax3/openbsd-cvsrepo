head	1.226;
access;
symbols
	OPENBSD_6_1:1.220.0.4
	OPENBSD_6_1_BASE:1.220
	OPENBSD_6_0:1.214.0.8
	OPENBSD_6_0_BASE:1.214
	OPENBSD_5_9:1.214.0.2
	OPENBSD_5_9_BASE:1.214
	OPENBSD_5_8:1.214.0.4
	OPENBSD_5_8_BASE:1.214
	OPENBSD_5_7:1.203.0.2
	OPENBSD_5_7_BASE:1.203
	OPENBSD_5_6:1.197.0.4
	OPENBSD_5_6_BASE:1.197
	OPENBSD_5_5:1.193.0.4
	OPENBSD_5_5_BASE:1.193
	OPENBSD_5_4:1.190.0.2
	OPENBSD_5_4_BASE:1.190
	OPENBSD_5_3:1.185.0.2
	OPENBSD_5_3_BASE:1.185
	OPENBSD_5_2:1.183.0.6
	OPENBSD_5_2_BASE:1.183
	OPENBSD_5_1_BASE:1.183
	OPENBSD_5_1:1.183.0.4
	OPENBSD_5_0:1.183.0.2
	OPENBSD_5_0_BASE:1.183
	OPENBSD_4_9:1.181.0.4
	OPENBSD_4_9_BASE:1.181
	OPENBSD_4_8:1.181.0.2
	OPENBSD_4_8_BASE:1.181
	OPENBSD_4_7:1.179.0.2
	OPENBSD_4_7_BASE:1.179
	OPENBSD_4_6:1.177.0.4
	OPENBSD_4_6_BASE:1.177
	OPENBSD_4_5:1.175.0.2
	OPENBSD_4_5_BASE:1.175
	OPENBSD_4_4:1.171.0.2
	OPENBSD_4_4_BASE:1.171
	OPENBSD_4_3:1.170.0.2
	OPENBSD_4_3_BASE:1.170
	OPENBSD_4_2:1.168.0.4
	OPENBSD_4_2_BASE:1.168
	OPENBSD_4_1:1.168.0.2
	OPENBSD_4_1_BASE:1.168
	OPENBSD_4_0:1.165.0.4
	OPENBSD_4_0_BASE:1.165
	OPENBSD_3_9:1.165.0.2
	OPENBSD_3_9_BASE:1.165
	OPENBSD_3_8:1.163.0.2
	OPENBSD_3_8_BASE:1.163
	OPENBSD_3_7:1.160.0.2
	OPENBSD_3_7_BASE:1.160
	OPENBSD_3_6:1.159.0.2
	OPENBSD_3_6_BASE:1.159
	SMP_SYNC_A:1.158
	SMP_SYNC_B:1.158
	OPENBSD_3_5:1.156.0.2
	OPENBSD_3_5_BASE:1.156
	OPENBSD_3_4:1.152.0.2
	OPENBSD_3_4_BASE:1.152
	UBC_SYNC_A:1.152
	OPENBSD_3_3:1.150.0.2
	OPENBSD_3_3_BASE:1.150
	OPENBSD_3_2:1.149.0.2
	OPENBSD_3_2_BASE:1.149
	OPENBSD_3_1:1.146.0.2
	OPENBSD_3_1_BASE:1.146
	UBC_SYNC_B:1.149
	UBC:1.144.0.2
	UBC_BASE:1.144
	OPENBSD_3_0:1.143.0.2
	OPENBSD_3_0_BASE:1.143
	OPENBSD_2_9_BASE:1.113
	OPENBSD_2_9:1.113.0.2
	OPENBSD_2_8:1.101.0.2
	OPENBSD_2_8_BASE:1.101
	OPENBSD_2_7:1.83.0.2
	OPENBSD_2_7_BASE:1.83
	SMP:1.79.0.2
	SMP_BASE:1.79
	kame_19991208:1.59
	OPENBSD_2_6:1.54.0.2
	OPENBSD_2_6_BASE:1.54
	OPENBSD_2_5:1.40.0.2
	OPENBSD_2_5_BASE:1.40
	OPENBSD_2_4:1.27.0.2
	OPENBSD_2_4_BASE:1.27
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.226
date	2017.08.11.21.24.20;	author mpi;	state Exp;
branches;
next	1.225;
commitid	qO4hXiGM2yDTtiTI;

1.225
date	2017.06.26.09.08.00;	author patrick;	state Exp;
branches;
next	1.224;
commitid	NtgTc1MKjIY88boF;

1.224
date	2017.05.18.10.56.45;	author bluhm;	state Exp;
branches;
next	1.223;
commitid	end8oXU4pM3sNkRR;

1.223
date	2017.05.16.12.24.01;	author mpi;	state Exp;
branches;
next	1.222;
commitid	SAe3SQ48vKH6r5FL;

1.222
date	2017.05.06.15.55.15;	author bluhm;	state Exp;
branches;
next	1.221;
commitid	oZPMTPCNR1fRELhK;

1.221
date	2017.05.05.11.04.18;	author bluhm;	state Exp;
branches;
next	1.220;
commitid	e7lFBlOrOiuLgJ3F;

1.220
date	2017.02.14.09.51.46;	author mpi;	state Exp;
branches;
next	1.219;
commitid	jVIvlg7Y1Cznv5CF;

1.219
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.218;
commitid	QqHqT2WhCBWqYgGJ;

1.218
date	2016.11.15.09.48.03;	author mpi;	state Exp;
branches;
next	1.217;
commitid	2jB8qdHsoVGjoLLI;

1.217
date	2016.09.20.14.01.04;	author mikeb;	state Exp;
branches;
next	1.216;
commitid	V2jtSZ1E1lNMMVIo;

1.216
date	2016.09.19.18.09.22;	author tedu;	state Exp;
branches;
next	1.215;
commitid	dVNJNNJZJ5eqAvDA;

1.215
date	2016.09.15.03.37.09;	author dlg;	state Exp;
branches;
next	1.214;
commitid	7p87LlYGjhDvSGxy;

1.214
date	2015.05.23.12.38.53;	author markus;	state Exp;
branches;
next	1.213;
commitid	Mgx7ewWJ5ueyVCxt;

1.213
date	2015.04.17.11.04.01;	author mikeb;	state Exp;
branches;
next	1.212;
commitid	6glXvFR7NxzCcdRd;

1.212
date	2015.04.17.10.08.07;	author mikeb;	state Exp;
branches;
next	1.211;
commitid	6jVHv86FAfOHbA0Y;

1.211
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.210;
commitid	2c41FFL8044mZVko;

1.210
date	2015.04.14.14.20.01;	author mikeb;	state Exp;
branches;
next	1.209;
commitid	70u0dWUlToMcLCnj;

1.209
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.208;
commitid	bQi1IVHgugweH5gs;

1.208
date	2015.04.13.16.52.26;	author mikeb;	state Exp;
branches;
next	1.207;
commitid	tJLPBOgj3MW9Jej9;

1.207
date	2015.04.13.16.48.01;	author mikeb;	state Exp;
branches;
next	1.206;
commitid	oA7CWTJPEeh3MwNg;

1.206
date	2015.04.13.16.45.52;	author mikeb;	state Exp;
branches;
next	1.205;
commitid	3C62OTk3mwJg0NNx;

1.205
date	2015.04.10.12.31.55;	author dlg;	state Exp;
branches;
next	1.204;
commitid	qSPGYuJC0QLMDFDG;

1.204
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.203;
commitid	p4LJxGKbi0BU2cG6;

1.203
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.202;
commitid	VK3ncyiP3NS1N4Sy;

1.202
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.201;
commitid	zhW8jJrfVCoAthrR;

1.201
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.200;
commitid	zM5ckwX4kwwmipG0;

1.200
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.199;
commitid	Z1vcFtHO8wRH0yRt;

1.199
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.198;
commitid	uzzBR7hz9ncd4O6G;

1.198
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.197;
commitid	ZqXwxwmeo3l29NOg;

1.197
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.196;
commitid	DQakU8LLWV6Iwx84;

1.196
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.195;
commitid	B4dZSbxas1X1IpXI;

1.195
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.194;
commitid	EF98ch02VpFassUi;

1.194
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.193;

1.193
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.192;

1.192
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches;
next	1.191;

1.191
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.190;

1.190
date	2013.07.04.09.48.48;	author mpi;	state Exp;
branches;
next	1.189;

1.189
date	2013.04.11.12.06.25;	author mpi;	state Exp;
branches;
next	1.188;

1.188
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.187;

1.187
date	2013.04.09.08.35.38;	author mpi;	state Exp;
branches;
next	1.186;

1.186
date	2013.03.28.23.10.05;	author tedu;	state Exp;
branches;
next	1.185;

1.185
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.184;

1.184
date	2012.09.18.09.24.45;	author markus;	state Exp;
branches;
next	1.183;

1.183
date	2011.05.11.07.37.04;	author blambert;	state Exp;
branches;
next	1.182;

1.182
date	2011.03.31.10.36.42;	author jasper;	state Exp;
branches;
next	1.181;

1.181
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.180;

1.180
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.179;

1.179
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches;
next	1.178;

1.178
date	2009.08.12.00.13.43;	author martynas;	state Exp;
branches;
next	1.177;

1.177
date	2009.06.02.21.28.36;	author blambert;	state Exp;
branches;
next	1.176;

1.176
date	2009.06.02.11.05.09;	author oga;	state Exp;
branches;
next	1.175;

1.175
date	2009.02.16.00.31.25;	author dlg;	state Exp;
branches;
next	1.174;

1.174
date	2008.10.22.23.04.45;	author mpf;	state Exp;
branches;
next	1.173;

1.173
date	2008.09.15.21.46.01;	author chl;	state Exp;
branches;
next	1.172;

1.172
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.171;

1.171
date	2008.04.18.06.42.20;	author djm;	state Exp;
branches;
next	1.170;

1.170
date	2007.10.29.16.19.23;	author chl;	state Exp;
branches;
next	1.169;

1.169
date	2007.10.09.01.49.30;	author krw;	state Exp;
branches;
next	1.168;

1.168
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.167;

1.167
date	2007.01.18.20.00.19;	author henning;	state Exp;
branches;
next	1.166;

1.166
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.165;

1.165
date	2006.01.13.10.11.23;	author mpf;	state Exp;
branches;
next	1.164;

1.164
date	2005.11.24.12.08.16;	author pedro;	state Exp;
branches;
next	1.163;

1.163
date	2005.05.28.15.10.07;	author ho;	state Exp;
branches;
next	1.162;

1.162
date	2005.05.27.19.33.56;	author hshoexer;	state Exp;
branches;
next	1.161;

1.161
date	2005.04.21.08.56.24;	author hshoexer;	state Exp;
branches;
next	1.160;

1.160
date	2004.11.19.10.11.52;	author hshoexer;	state Exp;
branches;
next	1.159;

1.159
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.158;

1.158
date	2004.04.14.20.10.04;	author markus;	state Exp;
branches;
next	1.157;

1.157
date	2004.03.31.10.21.37;	author henning;	state Exp;
branches;
next	1.156;

1.156
date	2004.02.15.12.44.24;	author markus;	state Exp;
branches;
next	1.155;

1.155
date	2004.01.27.09.29.22;	author markus;	state Exp;
branches;
next	1.154;

1.154
date	2004.01.22.14.38.28;	author markus;	state Exp;
branches;
next	1.153;

1.153
date	2003.12.02.23.16.28;	author markus;	state Exp;
branches;
next	1.152;

1.152
date	2003.05.09.14.59.19;	author deraadt;	state Exp;
branches;
next	1.151;

1.151
date	2003.05.06.07.28.39;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2002.11.19.18.34.41;	author jason;	state Exp;
branches;
next	1.149;

1.149
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.148;

1.148
date	2002.06.09.04.22.40;	author angelos;	state Exp;
branches;
next	1.147;

1.147
date	2002.05.31.02.41.08;	author angelos;	state Exp;
branches;
next	1.146;

1.146
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.145;

1.145
date	2002.02.23.22.16.13;	author angelos;	state Exp;
branches;
next	1.144;

1.144
date	2001.12.05.10.00.46;	author deraadt;	state Exp;
branches
	1.144.2.1;
next	1.143;

1.143
date	2001.10.03.02.08.41;	author angelos;	state Exp;
branches;
next	1.142;

1.142
date	2001.09.05.19.22.23;	author deraadt;	state Exp;
branches;
next	1.141;

1.141
date	2001.08.08.15.07.04;	author jjbg;	state Exp;
branches;
next	1.140;

1.140
date	2001.07.05.16.45.54;	author jjbg;	state Exp;
branches;
next	1.139;

1.139
date	2001.06.27.02.32.58;	author angelos;	state Exp;
branches;
next	1.138;

1.138
date	2001.06.27.01.34.07;	author angelos;	state Exp;
branches;
next	1.137;

1.137
date	2001.06.26.18.34.39;	author angelos;	state Exp;
branches;
next	1.136;

1.136
date	2001.06.26.03.52.40;	author angelos;	state Exp;
branches;
next	1.135;

1.135
date	2001.06.25.05.11.58;	author angelos;	state Exp;
branches;
next	1.134;

1.134
date	2001.06.24.23.11.45;	author provos;	state Exp;
branches;
next	1.133;

1.133
date	2001.06.24.21.14.33;	author angelos;	state Exp;
branches;
next	1.132;

1.132
date	2001.06.23.04.39.34;	author angelos;	state Exp;
branches;
next	1.131;

1.131
date	2001.06.23.04.01.57;	author angelos;	state Exp;
branches;
next	1.130;

1.130
date	2001.06.08.03.13.14;	author angelos;	state Exp;
branches;
next	1.129;

1.129
date	2001.06.07.16.19.47;	author angelos;	state Exp;
branches;
next	1.128;

1.128
date	2001.06.05.11.31.31;	author angelos;	state Exp;
branches;
next	1.127;

1.127
date	2001.06.05.09.21.38;	author angelos;	state Exp;
branches;
next	1.126;

1.126
date	2001.06.05.06.38.07;	author angelos;	state Exp;
branches;
next	1.125;

1.125
date	2001.06.04.18.38.12;	author mickey;	state Exp;
branches;
next	1.124;

1.124
date	2001.06.01.08.18.27;	author angelos;	state Exp;
branches;
next	1.123;

1.123
date	2001.06.01.07.56.46;	author angelos;	state Exp;
branches;
next	1.122;

1.122
date	2001.05.30.16.43.11;	author angelos;	state Exp;
branches;
next	1.121;

1.121
date	2001.05.30.11.15.37;	author angelos;	state Exp;
branches;
next	1.120;

1.120
date	2001.05.30.10.56.46;	author angelos;	state Exp;
branches;
next	1.119;

1.119
date	2001.05.29.01.17.24;	author angelos;	state Exp;
branches;
next	1.118;

1.118
date	2001.05.29.01.03.00;	author angelos;	state Exp;
branches;
next	1.117;

1.117
date	2001.05.27.05.16.32;	author angelos;	state Exp;
branches;
next	1.116;

1.116
date	2001.05.22.02.55.49;	author angelos;	state Exp;
branches;
next	1.115;

1.115
date	2001.05.21.03.02.19;	author angelos;	state Exp;
branches;
next	1.114;

1.114
date	2001.05.05.00.31.19;	author angelos;	state Exp;
branches;
next	1.113;

1.113
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.112;

1.112
date	2001.03.28.20.34.03;	author angelos;	state Exp;
branches;
next	1.111;

1.111
date	2001.03.28.20.03.04;	author angelos;	state Exp;
branches;
next	1.110;

1.110
date	2001.03.27.14.45.22;	author art;	state Exp;
branches;
next	1.109;

1.109
date	2001.03.15.06.30.59;	author mickey;	state Exp;
branches;
next	1.108;

1.108
date	2001.03.13.01.23.18;	author angelos;	state Exp;
branches;
next	1.107;

1.107
date	2001.03.04.20.34.00;	author angelos;	state Exp;
branches;
next	1.106;

1.106
date	2001.02.28.04.16.57;	author angelos;	state Exp;
branches;
next	1.105;

1.105
date	2000.12.28.21.34.03;	author angelos;	state Exp;
branches;
next	1.104;

1.104
date	2000.12.24.04.18.05;	author angelos;	state Exp;
branches;
next	1.103;

1.103
date	2000.12.18.16.45.32;	author angelos;	state Exp;
branches;
next	1.102;

1.102
date	2000.12.15.06.24.03;	author provos;	state Exp;
branches;
next	1.101;

1.101
date	2000.09.19.08.38.59;	author angelos;	state Exp;
branches;
next	1.100;

1.100
date	2000.09.19.03.20.58;	author angelos;	state Exp;
branches;
next	1.99;

1.99
date	2000.08.03.08.31.39;	author angelos;	state Exp;
branches;
next	1.98;

1.98
date	2000.08.03.08.29.55;	author angelos;	state Exp;
branches;
next	1.97;

1.97
date	2000.08.03.08.12.33;	author angelos;	state Exp;
branches;
next	1.96;

1.96
date	2000.06.19.03.43.15;	author itojun;	state Exp;
branches;
next	1.95;

1.95
date	2000.06.18.19.48.54;	author angelos;	state Exp;
branches;
next	1.94;

1.94
date	2000.06.18.19.10.07;	author angelos;	state Exp;
branches;
next	1.93;

1.93
date	2000.06.18.19.05.46;	author angelos;	state Exp;
branches;
next	1.92;

1.92
date	2000.06.18.05.54.37;	author angelos;	state Exp;
branches;
next	1.91;

1.91
date	2000.06.06.04.49.29;	author angelos;	state Exp;
branches;
next	1.90;

1.90
date	2000.06.01.06.11.08;	author angelos;	state Exp;
branches;
next	1.89;

1.89
date	2000.06.01.05.46.12;	author angelos;	state Exp;
branches;
next	1.88;

1.88
date	2000.06.01.05.33.08;	author angelos;	state Exp;
branches;
next	1.87;

1.87
date	2000.06.01.05.08.42;	author angelos;	state Exp;
branches;
next	1.86;

1.86
date	2000.06.01.04.38.34;	author angelos;	state Exp;
branches;
next	1.85;

1.85
date	2000.06.01.04.24.26;	author angelos;	state Exp;
branches;
next	1.84;

1.84
date	2000.06.01.04.02.32;	author angelos;	state Exp;
branches;
next	1.83;

1.83
date	2000.04.19.03.37.35;	author angelos;	state Exp;
branches;
next	1.82;

1.82
date	2000.03.28.07.04.02;	author angelos;	state Exp;
branches;
next	1.81;

1.81
date	2000.03.28.06.58.14;	author angelos;	state Exp;
branches;
next	1.80;

1.80
date	2000.03.17.10.25.22;	author angelos;	state Exp;
branches;
next	1.79;

1.79
date	2000.02.09.04.19.19;	author itojun;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2000.02.07.06.09.09;	author itojun;	state Exp;
branches;
next	1.77;

1.77
date	2000.01.27.08.09.12;	author angelos;	state Exp;
branches;
next	1.76;

1.76
date	2000.01.21.03.15.05;	author angelos;	state Exp;
branches;
next	1.75;

1.75
date	2000.01.13.05.30.11;	author angelos;	state Exp;
branches;
next	1.74;

1.74
date	2000.01.13.00.34.31;	author angelos;	state Exp;
branches;
next	1.73;

1.73
date	2000.01.11.03.10.04;	author angelos;	state Exp;
branches;
next	1.72;

1.72
date	2000.01.11.01.39.10;	author angelos;	state Exp;
branches;
next	1.71;

1.71
date	2000.01.11.01.03.22;	author angelos;	state Exp;
branches;
next	1.70;

1.70
date	2000.01.11.00.44.32;	author angelos;	state Exp;
branches;
next	1.69;

1.69
date	2000.01.10.06.59.22;	author angelos;	state Exp;
branches;
next	1.68;

1.68
date	2000.01.10.05.35.09;	author angelos;	state Exp;
branches;
next	1.67;

1.67
date	2000.01.10.04.37.42;	author angelos;	state Exp;
branches;
next	1.66;

1.66
date	2000.01.10.04.30.52;	author angelos;	state Exp;
branches;
next	1.65;

1.65
date	2000.01.10.04.16.52;	author angelos;	state Exp;
branches;
next	1.64;

1.64
date	2000.01.10.01.19.16;	author angelos;	state Exp;
branches;
next	1.63;

1.63
date	2000.01.09.23.02.15;	author angelos;	state Exp;
branches;
next	1.62;

1.62
date	99.12.27.03.05.52;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	99.12.25.07.09.42;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	99.12.25.04.48.16;	author angelos;	state Exp;
branches;
next	1.59;

1.59
date	99.12.08.06.06.43;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	99.12.06.07.14.36;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	99.12.05.22.09.18;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	99.12.04.23.20.21;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	99.11.04.11.20.05;	author ho;	state Exp;
branches;
next	1.54;

1.54
date	99.09.03.13.52.34;	author ho;	state Exp;
branches;
next	1.53;

1.53
date	99.08.10.11.35.26;	author ho;	state Exp;
branches;
next	1.52;

1.52
date	99.08.05.21.58.15;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	99.07.17.00.41.52;	author niklas;	state Exp;
branches;
next	1.50;

1.50
date	99.07.15.14.46.05;	author niklas;	state Exp;
branches;
next	1.49;

1.49
date	99.07.15.14.15.41;	author niklas;	state Exp;
branches;
next	1.48;

1.48
date	99.07.06.20.54.03;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	99.07.06.20.17.52;	author cmetz;	state Exp;
branches;
next	1.46;

1.46
date	99.06.07.07.20.38;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	99.06.04.22.40.36;	author provos;	state Exp;
branches;
next	1.44;

1.44
date	99.05.23.09.04.46;	author niklas;	state Exp;
branches;
next	1.43;

1.43
date	99.05.20.12.52.35;	author niklas;	state Exp;
branches;
next	1.42;

1.42
date	99.05.16.21.48.35;	author niklas;	state Exp;
branches;
next	1.41;

1.41
date	99.05.14.23.36.18;	author niklas;	state Exp;
branches;
next	1.40;

1.40
date	99.04.12.03.17.09;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	99.03.27.21.04.19;	author provos;	state Exp;
branches;
next	1.38;

1.38
date	99.03.24.17.00.47;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	99.03.04.21.51.27;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	99.03.04.20.30.36;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	99.02.25.22.37.29;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	99.02.25.20.21.07;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	99.02.24.23.45.51;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	99.02.24.22.33.05;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	99.01.11.22.52.10;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.11.16.08.02.59;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	98.11.16.08.00.43;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	98.11.16.04.06.45;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.10.13.06.49.46;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	98.05.18.21.10.57;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	98.05.17.16.52.56;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	98.02.22.01.23.33;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	97.11.04.09.11.15;	author provos;	state Exp;
branches;
next	1.22;

1.22
date	97.10.02.02.31.06;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.10.01.02.34.06;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.09.28.22.57.50;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.09.23.21.42.21;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	97.07.28.18.55.33;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	97.07.27.23.30.36;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.07.24.01.45.29;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.07.18.18.09.56;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.07.15.23.11.10;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.07.11.23.37.58;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	97.07.02.06.58.42;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.07.01.22.12.51;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.06.25.07.53.28;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.06.24.12.15.25;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.06.21.00.09.19;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.20.05.41.53;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.02.24.14.06.42;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.02.21.09.35.03;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	97.02.21.08.42.32;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.02.21.08.26.08;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.02.21.02.54.26;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.08.00;	author deraadt;	state Exp;
branches;
next	;

1.79.2.1
date	2000.03.24.09.09.37;	author niklas;	state Exp;
branches;
next	1.79.2.2;

1.79.2.2
date	2001.05.14.22.40.11;	author niklas;	state Exp;
branches;
next	1.79.2.3;

1.79.2.3
date	2001.07.04.10.54.51;	author niklas;	state Exp;
branches;
next	1.79.2.4;

1.79.2.4
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.79.2.5;

1.79.2.5
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.79.2.6;

1.79.2.6
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.79.2.7;

1.79.2.7
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.79.2.8;

1.79.2.8
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.79.2.9;

1.79.2.9
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.79.2.10;

1.79.2.10
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.144.2.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.144.2.2;

1.144.2.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.144.2.3;

1.144.2.3
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.226
log
@Remove NET_LOCK()'s argument.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@/*	$OpenBSD: ip_ipsp.c,v 1.225 2017/06/26 09:08:00 patrick Exp $	*/
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr),
 * Niels Provos (provos@@physnet.uni-hamburg.de) and
 * Niklas Hallqvist (niklas@@appli.se).
 *
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis and Niklas Hallqvist.
 *
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 * Copyright (c) 1999 Niklas Hallqvist.
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include "pf.h"
#include "pfsync.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/ip_ipip.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#if NPFSYNC > 0
#include <net/if_pfsync.h>
#endif

#include <netinet/ip_ipsp.h>
#include <net/pfkeyv2.h>

#ifdef DDB
#include <ddb/db_output.h>
void tdb_hashstats(void);
#endif

#ifdef ENCDEBUG
#define	DPRINTF(x)	if (encdebug) printf x
#else
#define	DPRINTF(x)
#endif

void		tdb_rehash(void);
void		tdb_timeout(void *v);
void		tdb_firstuse(void *v);
void		tdb_soft_timeout(void *v);
void		tdb_soft_firstuse(void *v);
int		tdb_hash(u_int, u_int32_t, union sockaddr_union *, u_int8_t);

int ipsec_in_use = 0;
u_int64_t ipsec_last_added = 0;

struct ipsec_policy_head ipsec_policy_head =
    TAILQ_HEAD_INITIALIZER(ipsec_policy_head);
struct ipsec_acquire_head ipsec_acquire_head =
    TAILQ_HEAD_INITIALIZER(ipsec_acquire_head);

u_int32_t ipsec_ids_next_flow = 1;	/* may not be zero */
int ipsec_ids_idle = 100;		/* keep free ids for 100s */
struct ipsec_ids_tree ipsec_ids_tree;
struct ipsec_ids_flows ipsec_ids_flows;

void ipsp_ids_timeout(void *);
static inline int ipsp_ids_cmp(const struct ipsec_ids *,
    const struct ipsec_ids *);
static inline int ipsp_ids_flow_cmp(const struct ipsec_ids *,
    const struct ipsec_ids *);
RBT_PROTOTYPE(ipsec_ids_tree, ipsec_ids, id_node_flow, ipsp_ids_cmp);
RBT_PROTOTYPE(ipsec_ids_flows, ipsec_ids, id_node_id, ipsp_ids_flow_cmp);
RBT_GENERATE(ipsec_ids_tree, ipsec_ids, id_node_flow, ipsp_ids_cmp);
RBT_GENERATE(ipsec_ids_flows, ipsec_ids, id_node_id, ipsp_ids_flow_cmp);

/*
 * This is the proper place to define the various encapsulation transforms.
 */

struct xformsw xformsw[] = {
#ifdef IPSEC
{
  .xf_type	= XF_IP4,
  .xf_flags	= 0,
  .xf_name	= "IPv4 Simple Encapsulation",
  .xf_attach	= ipe4_attach,
  .xf_init	= ipe4_init,
  .xf_zeroize	= ipe4_zeroize,
  .xf_input	= ipe4_input,
  .xf_output	= ipip_output,
},
{
  .xf_type	= XF_AH,
  .xf_flags	= XFT_AUTH,
  .xf_name	= "IPsec AH",
  .xf_attach	= ah_attach,
  .xf_init	= ah_init,
  .xf_zeroize	= ah_zeroize,
  .xf_input	= ah_input,
  .xf_output	= ah_output,
},
{
  .xf_type	= XF_ESP,
  .xf_flags	= XFT_CONF|XFT_AUTH,
  .xf_name	= "IPsec ESP",
  .xf_attach	= esp_attach,
  .xf_init	= esp_init,
  .xf_zeroize	= esp_zeroize,
  .xf_input	= esp_input,
  .xf_output	= esp_output,
},
{
  .xf_type	= XF_IPCOMP,
  .xf_flags	= XFT_COMP,
  .xf_name	= "IPcomp",
  .xf_attach	= ipcomp_attach,
  .xf_init	= ipcomp_init,
  .xf_zeroize	= ipcomp_zeroize,
  .xf_input	= ipcomp_input,
  .xf_output	= ipcomp_output,
},
#endif /* IPSEC */
#ifdef TCP_SIGNATURE
{
  .xf_type	= XF_TCPSIGNATURE,
  .xf_flags	= XFT_AUTH,
  .xf_name	= "TCP MD5 Signature Option, RFC 2385",
  .xf_attach	= tcp_signature_tdb_attach,
  .xf_init	= tcp_signature_tdb_init,
  .xf_zeroize	= tcp_signature_tdb_zeroize,
  .xf_input	= tcp_signature_tdb_input,
  .xf_output	= tcp_signature_tdb_output,
}
#endif /* TCP_SIGNATURE */
};

struct xformsw *xformswNXFORMSW = &xformsw[nitems(xformsw)];

#define	TDB_HASHSIZE_INIT	32

static SIPHASH_KEY tdbkey;
static struct tdb **tdbh = NULL;
static struct tdb **tdbdst = NULL;
static struct tdb **tdbsrc = NULL;
static u_int tdb_hashmask = TDB_HASHSIZE_INIT - 1;
static int tdb_count;

/*
 * Our hashing function needs to stir things with a non-zero random multiplier
 * so we cannot be DoS-attacked via choosing of the data to hash.
 */
int
tdb_hash(u_int rdomain, u_int32_t spi, union sockaddr_union *dst,
    u_int8_t proto)
{
	SIPHASH_CTX ctx;

	SipHash24_Init(&ctx, &tdbkey);
	SipHash24_Update(&ctx, &rdomain, sizeof(rdomain));
	SipHash24_Update(&ctx, &spi, sizeof(spi));
	SipHash24_Update(&ctx, &proto, sizeof(proto));
	SipHash24_Update(&ctx, dst, dst->sa.sa_len);

	return (SipHash24_End(&ctx) & tdb_hashmask);
}

/*
 * Reserve an SPI; the SA is not valid yet though.  We use 0 as
 * an error return value.
 */
u_int32_t
reserve_spi(u_int rdomain, u_int32_t sspi, u_int32_t tspi,
    union sockaddr_union *src, union sockaddr_union *dst,
    u_int8_t sproto, int *errval)
{
	struct tdb *tdbp, *exists;
	u_int32_t spi;
	int nums;

	NET_ASSERT_LOCKED();

	/* Don't accept ranges only encompassing reserved SPIs. */
	if (sproto != IPPROTO_IPCOMP &&
	    (tspi < sspi || tspi <= SPI_RESERVED_MAX)) {
		(*errval) = EINVAL;
		return 0;
	}
	if (sproto == IPPROTO_IPCOMP && (tspi < sspi ||
	    tspi <= CPI_RESERVED_MAX ||
	    tspi >= CPI_PRIVATE_MIN)) {
		(*errval) = EINVAL;
		return 0;
	}

	/* Limit the range to not include reserved areas. */
	if (sspi <= SPI_RESERVED_MAX)
		sspi = SPI_RESERVED_MAX + 1;

	/* For IPCOMP the CPI is only 16 bits long, what a good idea.... */

	if (sproto == IPPROTO_IPCOMP) {
		u_int32_t t;
		if (sspi >= 0x10000)
			sspi = 0xffff;
		if (tspi >= 0x10000)
			tspi = 0xffff;
		if (sspi > tspi) {
			t = sspi; sspi = tspi; tspi = t;
		}
	}

	if (sspi == tspi)   /* Asking for a specific SPI. */
		nums = 1;
	else
		nums = 100;  /* Arbitrarily chosen */

	/* allocate ahead of time to avoid potential sleeping race in loop */
	tdbp = tdb_alloc(rdomain);

	while (nums--) {
		if (sspi == tspi)  /* Specific SPI asked. */
			spi = tspi;
		else    /* Range specified */
			spi = sspi + arc4random_uniform(tspi - sspi);

		/* Don't allocate reserved SPIs.  */
		if (spi >= SPI_RESERVED_MIN && spi <= SPI_RESERVED_MAX)
			continue;
		else
			spi = htonl(spi);

		/* Check whether we're using this SPI already. */
		exists = gettdb(rdomain, spi, dst, sproto);
		if (exists)
			continue;


		tdbp->tdb_spi = spi;
		memcpy(&tdbp->tdb_dst.sa, &dst->sa, dst->sa.sa_len);
		memcpy(&tdbp->tdb_src.sa, &src->sa, src->sa.sa_len);
		tdbp->tdb_sproto = sproto;
		tdbp->tdb_flags |= TDBF_INVALID; /* Mark SA invalid for now. */
		tdbp->tdb_satype = SADB_SATYPE_UNSPEC;
		puttdb(tdbp);

		/* Setup a "silent" expiration (since TDBF_INVALID's set). */
		if (ipsec_keep_invalid > 0) {
			tdbp->tdb_flags |= TDBF_TIMER;
			tdbp->tdb_exp_timeout = ipsec_keep_invalid;
			timeout_add_sec(&tdbp->tdb_timer_tmo,
			    ipsec_keep_invalid);
		}

		return spi;
	}

	(*errval) = EEXIST;
	tdb_free(tdbp);
	return 0;
}

/*
 * An IPSP SAID is really the concatenation of the SPI found in the
 * packet, the destination address of the packet and the IPsec protocol.
 * When we receive an IPSP packet, we need to look up its tunnel descriptor
 * block, based on the SPI in the packet and the destination address (which
 * is really one of our addresses if we received the packet!
 */
struct tdb *
gettdb(u_int rdomain, u_int32_t spi, union sockaddr_union *dst, u_int8_t proto)
{
	u_int32_t hashval;
	struct tdb *tdbp;

	NET_ASSERT_LOCKED();

	if (tdbh == NULL)
		return (struct tdb *) NULL;

	hashval = tdb_hash(rdomain, spi, dst, proto);

	for (tdbp = tdbh[hashval]; tdbp != NULL; tdbp = tdbp->tdb_hnext)
		if ((tdbp->tdb_spi == spi) && (tdbp->tdb_sproto == proto) &&
		    (tdbp->tdb_rdomain == rdomain) &&
		    !memcmp(&tdbp->tdb_dst, dst, dst->sa.sa_len))
			break;

	return tdbp;
}

/*
 * Same as gettdb() but compare SRC as well, so we
 * use the tdbsrc[] hash table.  Setting spi to 0
 * matches all SPIs.
 */
struct tdb *
gettdbbysrcdst(u_int rdomain, u_int32_t spi, union sockaddr_union *src,
    union sockaddr_union *dst, u_int8_t proto)
{
	u_int32_t hashval;
	struct tdb *tdbp;
	union sockaddr_union su_null;

	if (tdbsrc == NULL)
		return (struct tdb *) NULL;

	hashval = tdb_hash(rdomain, 0, src, proto);

	for (tdbp = tdbsrc[hashval]; tdbp != NULL; tdbp = tdbp->tdb_snext)
		if (tdbp->tdb_sproto == proto &&
		    (spi == 0 || tdbp->tdb_spi == spi) &&
		    (tdbp->tdb_rdomain == rdomain) &&
		    ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
		    (tdbp->tdb_dst.sa.sa_family == AF_UNSPEC ||
		    !memcmp(&tdbp->tdb_dst, dst, dst->sa.sa_len)) &&
		    !memcmp(&tdbp->tdb_src, src, src->sa.sa_len))
			break;

	if (tdbp != NULL)
		return (tdbp);

	memset(&su_null, 0, sizeof(su_null));
	su_null.sa.sa_len = sizeof(struct sockaddr);
	hashval = tdb_hash(rdomain, 0, &su_null, proto);

	for (tdbp = tdbsrc[hashval]; tdbp != NULL; tdbp = tdbp->tdb_snext)
		if (tdbp->tdb_sproto == proto &&
		    (spi == 0 || tdbp->tdb_spi == spi) &&
		    (tdbp->tdb_rdomain == rdomain) &&
		    ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
		    (tdbp->tdb_dst.sa.sa_family == AF_UNSPEC ||
		    !memcmp(&tdbp->tdb_dst, dst, dst->sa.sa_len)) &&
		    tdbp->tdb_src.sa.sa_family == AF_UNSPEC)
			break;

	return (tdbp);
}

/*
 * Check that IDs match. Return true if so. The t* range of
 * arguments contains information from TDBs; the p* range of
 * arguments contains information from policies or already
 * established TDBs.
 */
int
ipsp_aux_match(struct tdb *tdb,
    struct ipsec_ids *ids,
    struct sockaddr_encap *pfilter,
    struct sockaddr_encap *pfiltermask)
{
	if (ids != NULL)
		if (tdb->tdb_ids == NULL ||
		    !ipsp_ids_match(tdb->tdb_ids, ids))
			return 0;

	/* Check for filter matches. */
	if (pfilter != NULL && pfiltermask != NULL &&
	    tdb->tdb_filter.sen_type) {
		/*
		 * XXX We should really be doing a subnet-check (see
		 * whether the TDB-associated filter is a subset
		 * of the policy's. For now, an exact match will solve
		 * most problems (all this will do is make every
		 * policy get its own SAs).
		 */
		if (memcmp(&tdb->tdb_filter, pfilter,
		    sizeof(struct sockaddr_encap)) ||
		    memcmp(&tdb->tdb_filtermask, pfiltermask,
		    sizeof(struct sockaddr_encap)))
			return 0;
	}

	return 1;
}

/*
 * Get an SA given the remote address, the security protocol type, and
 * the desired IDs.
 */
struct tdb *
gettdbbydst(u_int rdomain, union sockaddr_union *dst, u_int8_t sproto,
    struct ipsec_ids *ids,
    struct sockaddr_encap *filter, struct sockaddr_encap *filtermask)
{
	u_int32_t hashval;
	struct tdb *tdbp;

	if (tdbdst == NULL)
		return (struct tdb *) NULL;

	hashval = tdb_hash(rdomain, 0, dst, sproto);

	for (tdbp = tdbdst[hashval]; tdbp != NULL; tdbp = tdbp->tdb_dnext)
		if ((tdbp->tdb_sproto == sproto) &&
		    (tdbp->tdb_rdomain == rdomain) &&
		    ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
		    (!memcmp(&tdbp->tdb_dst, dst, dst->sa.sa_len))) {
			/* Do IDs match ? */
			if (!ipsp_aux_match(tdbp, ids, filter, filtermask))
				continue;
			break;
		}

	return tdbp;
}

/*
 * Get an SA given the source address, the security protocol type, and
 * the desired IDs.
 */
struct tdb *
gettdbbysrc(u_int rdomain, union sockaddr_union *src, u_int8_t sproto,
    struct ipsec_ids *ids,
    struct sockaddr_encap *filter, struct sockaddr_encap *filtermask)
{
	u_int32_t hashval;
	struct tdb *tdbp;

	if (tdbsrc == NULL)
		return (struct tdb *) NULL;

	hashval = tdb_hash(rdomain, 0, src, sproto);

	for (tdbp = tdbsrc[hashval]; tdbp != NULL; tdbp = tdbp->tdb_snext)
		if ((tdbp->tdb_sproto == sproto) &&
		    (tdbp->tdb_rdomain == rdomain) &&
		    ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
		    (!memcmp(&tdbp->tdb_src, src, src->sa.sa_len))) {
			/* Check whether IDs match */
			if (!ipsp_aux_match(tdbp, ids, filter,
			    filtermask))
				continue;
			break;
		}

	return tdbp;
}

#if DDB

#define NBUCKETS 16
void
tdb_hashstats(void)
{
	int i, cnt, buckets[NBUCKETS];
	struct tdb *tdbp;

	if (tdbh == NULL) {
		db_printf("no tdb hash table\n");
		return;
	}

	memset(buckets, 0, sizeof(buckets));
	for (i = 0; i <= tdb_hashmask; i++) {
		cnt = 0;
		for (tdbp = tdbh[i]; cnt < NBUCKETS - 1 && tdbp != NULL;
		    tdbp = tdbp->tdb_hnext)
			cnt++;
		buckets[cnt]++;
	}

	db_printf("tdb cnt\t\tbucket cnt\n");
	for (i = 0; i < NBUCKETS; i++)
		if (buckets[i] > 0)
			db_printf("%d%s\t\t%d\n", i, i == NBUCKETS - 1 ?
			    "+" : "", buckets[i]);
}
#endif	/* DDB */

int
tdb_walk(u_int rdomain, int (*walker)(struct tdb *, void *, int), void *arg)
{
	int i, rval = 0;
	struct tdb *tdbp, *next;

	NET_ASSERT_LOCKED();

	if (tdbh == NULL)
		return ENOENT;

	for (i = 0; i <= tdb_hashmask; i++)
		for (tdbp = tdbh[i]; rval == 0 && tdbp != NULL; tdbp = next) {
			next = tdbp->tdb_hnext;

			if (rdomain != tdbp->tdb_rdomain)
				continue;

			if (i == tdb_hashmask && next == NULL)
				rval = walker(tdbp, (void *)arg, 1);
			else
				rval = walker(tdbp, (void *)arg, 0);
		}

	return rval;
}

/*
 * Called at splsoftclock().
 */
void
tdb_timeout(void *v)
{
	struct tdb *tdb = v;

	if (!(tdb->tdb_flags & TDBF_TIMER))
		return;

	NET_LOCK();
	/* If it's an "invalid" TDB do a silent expiration. */
	if (!(tdb->tdb_flags & TDBF_INVALID))
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb);
	NET_UNLOCK();
}

void
tdb_firstuse(void *v)
{
	struct tdb *tdb = v;

	if (!(tdb->tdb_flags & TDBF_SOFT_FIRSTUSE))
		return;

	NET_LOCK();
	/* If the TDB hasn't been used, don't renew it. */
	if (tdb->tdb_first_use != 0)
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb);
	NET_UNLOCK();
}

void
tdb_soft_timeout(void *v)
{
	struct tdb *tdb = v;

	if (!(tdb->tdb_flags & TDBF_SOFT_TIMER))
		return;

	NET_LOCK();
	/* Soft expirations. */
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_TIMER;
	NET_UNLOCK();
}

void
tdb_soft_firstuse(void *v)
{
	struct tdb *tdb = v;

	if (!(tdb->tdb_flags & TDBF_SOFT_FIRSTUSE))
		return;

	NET_LOCK();
	/* If the TDB hasn't been used, don't renew it. */
	if (tdb->tdb_first_use != 0)
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
	NET_UNLOCK();
}

void
tdb_rehash(void)
{
	struct tdb **new_tdbh, **new_tdbdst, **new_srcaddr, *tdbp, *tdbnp;
	u_int i, old_hashmask = tdb_hashmask;
	u_int32_t hashval;

	NET_ASSERT_LOCKED();

	tdb_hashmask = (tdb_hashmask << 1) | 1;

	arc4random_buf(&tdbkey, sizeof(tdbkey));
	new_tdbh = mallocarray(tdb_hashmask + 1, sizeof(struct tdb *), M_TDB,
	    M_WAITOK | M_ZERO);
	new_tdbdst = mallocarray(tdb_hashmask + 1, sizeof(struct tdb *), M_TDB,
	    M_WAITOK | M_ZERO);
	new_srcaddr = mallocarray(tdb_hashmask + 1, sizeof(struct tdb *), M_TDB,
	    M_WAITOK | M_ZERO);

	for (i = 0; i <= old_hashmask; i++) {
		for (tdbp = tdbh[i]; tdbp != NULL; tdbp = tdbnp) {
			tdbnp = tdbp->tdb_hnext;
			hashval = tdb_hash(tdbp->tdb_rdomain,
			    tdbp->tdb_spi, &tdbp->tdb_dst,
			    tdbp->tdb_sproto);
			tdbp->tdb_hnext = new_tdbh[hashval];
			new_tdbh[hashval] = tdbp;
		}

		for (tdbp = tdbdst[i]; tdbp != NULL; tdbp = tdbnp) {
			tdbnp = tdbp->tdb_dnext;
			hashval = tdb_hash(tdbp->tdb_rdomain,
			    0, &tdbp->tdb_dst,
			    tdbp->tdb_sproto);
			tdbp->tdb_dnext = new_tdbdst[hashval];
			new_tdbdst[hashval] = tdbp;
		}

		for (tdbp = tdbsrc[i]; tdbp != NULL; tdbp = tdbnp) {
			tdbnp = tdbp->tdb_snext;
			hashval = tdb_hash(tdbp->tdb_rdomain,
			    0, &tdbp->tdb_src,
			    tdbp->tdb_sproto);
			tdbp->tdb_snext = new_srcaddr[hashval];
			new_srcaddr[hashval] = tdbp;
		}
	}

	free(tdbh, M_TDB, 0);
	tdbh = new_tdbh;

	free(tdbdst, M_TDB, 0);
	tdbdst = new_tdbdst;

	free(tdbsrc, M_TDB, 0);
	tdbsrc = new_srcaddr;
}

/*
 * Add TDB in the hash table.
 */
void
puttdb(struct tdb *tdbp)
{
	u_int32_t hashval;

	NET_ASSERT_LOCKED();

	if (tdbh == NULL) {
		arc4random_buf(&tdbkey, sizeof(tdbkey));
		tdbh = mallocarray(tdb_hashmask + 1, sizeof(struct tdb *),
		    M_TDB, M_WAITOK | M_ZERO);
		tdbdst = mallocarray(tdb_hashmask + 1, sizeof(struct tdb *),
		    M_TDB, M_WAITOK | M_ZERO);
		tdbsrc = mallocarray(tdb_hashmask + 1, sizeof(struct tdb *),
		    M_TDB, M_WAITOK | M_ZERO);
	}

	hashval = tdb_hash(tdbp->tdb_rdomain, tdbp->tdb_spi,
	    &tdbp->tdb_dst, tdbp->tdb_sproto);

	/*
	 * Rehash if this tdb would cause a bucket to have more than
	 * two items and if the number of tdbs exceed 10% of the
	 * bucket count.  This number is arbitratily chosen and is
	 * just a measure to not keep rehashing when adding and
	 * removing tdbs which happens to always end up in the same
	 * bucket, which is not uncommon when doing manual keying.
	 */
	if (tdbh[hashval] != NULL && tdbh[hashval]->tdb_hnext != NULL &&
	    tdb_count * 10 > tdb_hashmask + 1) {
		tdb_rehash();
		hashval = tdb_hash(tdbp->tdb_rdomain, tdbp->tdb_spi,
		    &tdbp->tdb_dst, tdbp->tdb_sproto);
	}

	tdbp->tdb_hnext = tdbh[hashval];
	tdbh[hashval] = tdbp;

	hashval = tdb_hash(tdbp->tdb_rdomain, 0, &tdbp->tdb_dst,
	    tdbp->tdb_sproto);
	tdbp->tdb_dnext = tdbdst[hashval];
	tdbdst[hashval] = tdbp;

	hashval = tdb_hash(tdbp->tdb_rdomain, 0, &tdbp->tdb_src,
	    tdbp->tdb_sproto);
	tdbp->tdb_snext = tdbsrc[hashval];
	tdbsrc[hashval] = tdbp;

	tdb_count++;

	ipsec_last_added = time_second;
}

void
tdb_unlink(struct tdb *tdbp)
{
	struct tdb *tdbpp;
	u_int32_t hashval;

	NET_ASSERT_LOCKED();

	if (tdbh == NULL)
		return;

	hashval = tdb_hash(tdbp->tdb_rdomain, tdbp->tdb_spi,
	    &tdbp->tdb_dst, tdbp->tdb_sproto);

	if (tdbh[hashval] == tdbp) {
		tdbh[hashval] = tdbp->tdb_hnext;
	} else {
		for (tdbpp = tdbh[hashval]; tdbpp != NULL;
		    tdbpp = tdbpp->tdb_hnext) {
			if (tdbpp->tdb_hnext == tdbp) {
				tdbpp->tdb_hnext = tdbp->tdb_hnext;
				break;
			}
		}
	}

	tdbp->tdb_hnext = NULL;

	hashval = tdb_hash(tdbp->tdb_rdomain, 0, &tdbp->tdb_dst,
	    tdbp->tdb_sproto);

	if (tdbdst[hashval] == tdbp) {
		tdbdst[hashval] = tdbp->tdb_dnext;
	} else {
		for (tdbpp = tdbdst[hashval]; tdbpp != NULL;
		    tdbpp = tdbpp->tdb_dnext) {
			if (tdbpp->tdb_dnext == tdbp) {
				tdbpp->tdb_dnext = tdbp->tdb_dnext;
				break;
			}
		}
	}

	tdbp->tdb_dnext = NULL;

	hashval = tdb_hash(tdbp->tdb_rdomain, 0, &tdbp->tdb_src,
	    tdbp->tdb_sproto);

	if (tdbsrc[hashval] == tdbp) {
		tdbsrc[hashval] = tdbp->tdb_snext;
	}
	else {
		for (tdbpp = tdbsrc[hashval]; tdbpp != NULL;
		    tdbpp = tdbpp->tdb_snext) {
			if (tdbpp->tdb_snext == tdbp) {
				tdbpp->tdb_snext = tdbp->tdb_snext;
				break;
			}
		}
	}

	tdbp->tdb_snext = NULL;
	tdb_count--;
}

void
tdb_delete(struct tdb *tdbp)
{
	NET_ASSERT_LOCKED();

	tdb_unlink(tdbp);
	tdb_free(tdbp);
}

/*
 * Allocate a TDB and initialize a few basic fields.
 */
struct tdb *
tdb_alloc(u_int rdomain)
{
	struct tdb *tdbp;

	tdbp = malloc(sizeof(*tdbp), M_TDB, M_WAITOK | M_ZERO);

	TAILQ_INIT(&tdbp->tdb_policy_head);

	/* Record establishment time. */
	tdbp->tdb_established = time_second;

	/* Save routing domain */
	tdbp->tdb_rdomain = rdomain;

	/* Initialize timeouts. */
	timeout_set_proc(&tdbp->tdb_timer_tmo, tdb_timeout, tdbp);
	timeout_set_proc(&tdbp->tdb_first_tmo, tdb_firstuse, tdbp);
	timeout_set_proc(&tdbp->tdb_stimer_tmo, tdb_soft_timeout, tdbp);
	timeout_set_proc(&tdbp->tdb_sfirst_tmo, tdb_soft_firstuse, tdbp);

	return tdbp;
}

void
tdb_free(struct tdb *tdbp)
{
	struct ipsec_policy *ipo;

	if (tdbp->tdb_xform) {
		(*(tdbp->tdb_xform->xf_zeroize))(tdbp);
		tdbp->tdb_xform = NULL;
	}

#if NPFSYNC > 0
	/* Cleanup pfsync references */
	pfsync_delete_tdb(tdbp);
#endif

	/* Cleanup SPD references. */
	for (ipo = TAILQ_FIRST(&tdbp->tdb_policy_head); ipo;
	    ipo = TAILQ_FIRST(&tdbp->tdb_policy_head))	{
		TAILQ_REMOVE(&tdbp->tdb_policy_head, ipo, ipo_tdb_next);
		ipo->ipo_tdb = NULL;
		ipo->ipo_last_searched = 0; /* Force a re-search. */
	}

	/* Remove expiration timeouts. */
	tdbp->tdb_flags &= ~(TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE | TDBF_TIMER |
	    TDBF_SOFT_TIMER);
	timeout_del(&tdbp->tdb_timer_tmo);
	timeout_del(&tdbp->tdb_first_tmo);
	timeout_del(&tdbp->tdb_stimer_tmo);
	timeout_del(&tdbp->tdb_sfirst_tmo);

	if (tdbp->tdb_ids) {
		ipsp_ids_free(tdbp->tdb_ids);
		tdbp->tdb_ids = NULL;
	}

#if NPF > 0
	if (tdbp->tdb_tag) {
		pf_tag_unref(tdbp->tdb_tag);
		tdbp->tdb_tag = 0;
	}
#endif

	if ((tdbp->tdb_onext) && (tdbp->tdb_onext->tdb_inext == tdbp))
		tdbp->tdb_onext->tdb_inext = NULL;

	if ((tdbp->tdb_inext) && (tdbp->tdb_inext->tdb_onext == tdbp))
		tdbp->tdb_inext->tdb_onext = NULL;

	free(tdbp, M_TDB, 0);
}

/*
 * Do further initializations of a TDB.
 */
int
tdb_init(struct tdb *tdbp, u_int16_t alg, struct ipsecinit *ii)
{
	struct xformsw *xsp;
	int err;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	for (xsp = xformsw; xsp < xformswNXFORMSW; xsp++) {
		if (xsp->xf_type == alg) {
			err = (*(xsp->xf_init))(tdbp, xsp, ii);
			return err;
		}
	}

	DPRINTF(("tdb_init(): no alg %d for spi %08x, addr %s, proto %d\n",
	    alg, ntohl(tdbp->tdb_spi), ipsp_address(&tdbp->tdb_dst, buf,
	    sizeof(buf)), tdbp->tdb_sproto));

	return EINVAL;
}

#ifdef ENCDEBUG
/* Return a printable string for the address. */
const char *
ipsp_address(union sockaddr_union *sa, char *buf, socklen_t size)
{
	switch (sa->sa.sa_family) {
	case AF_INET:
		return inet_ntop(AF_INET, &sa->sin.sin_addr,
		    buf, (size_t)size);

#ifdef INET6
	case AF_INET6:
		return inet_ntop(AF_INET6, &sa->sin6.sin6_addr,
		    buf, (size_t)size);
#endif /* INET6 */

	default:
		return "(unknown address family)";
	}
}
#endif /* ENCDEBUG */

/* Check whether an IP{4,6} address is unspecified. */
int
ipsp_is_unspecified(union sockaddr_union addr)
{
	switch (addr.sa.sa_family) {
	case AF_INET:
		if (addr.sin.sin_addr.s_addr == INADDR_ANY)
			return 1;
		else
			return 0;

#ifdef INET6
	case AF_INET6:
		if (IN6_IS_ADDR_UNSPECIFIED(&addr.sin6.sin6_addr))
			return 1;
		else
			return 0;
#endif /* INET6 */

	case 0: /* No family set. */
	default:
		return 1;
	}
}

int
ipsp_ids_match(struct ipsec_ids *a, struct ipsec_ids *b)
{
	return a == b;
}

struct ipsec_ids *
ipsp_ids_insert(struct ipsec_ids *ids)
{
	struct ipsec_ids *found;
	u_int32_t start_flow;

	found = RBT_INSERT(ipsec_ids_tree, &ipsec_ids_tree, ids);
	if (found) {
		/* if refcount was zero, then timeout is running */
		if (found->id_refcount++ == 0)
			timeout_del(&found->id_timeout);
		DPRINTF(("%s: ids %p count %d\n", __func__,
		    found, found->id_refcount));
		return found;
	}
	ids->id_flow = start_flow = ipsec_ids_next_flow;
	if (++ipsec_ids_next_flow == 0)
		ipsec_ids_next_flow = 1;
	while (RBT_INSERT(ipsec_ids_flows, &ipsec_ids_flows, ids) != NULL) {
		ids->id_flow = ipsec_ids_next_flow;
		if (++ipsec_ids_next_flow == 0)
			ipsec_ids_next_flow = 1;
		if (ipsec_ids_next_flow == start_flow) {
			DPRINTF(("ipsec_ids_next_flow exhausted %u\n",
			    ipsec_ids_next_flow));
			return NULL;
		}
	}
	ids->id_refcount = 1;
	DPRINTF(("%s: new ids %p flow %u\n", __func__, ids, ids->id_flow));
	timeout_set_proc(&ids->id_timeout, ipsp_ids_timeout, ids);
	return ids;
}

struct ipsec_ids *
ipsp_ids_lookup(u_int32_t ipsecflowinfo)
{
	struct ipsec_ids	key;

	key.id_flow = ipsecflowinfo;
	return RBT_FIND(ipsec_ids_flows, &ipsec_ids_flows, &key);
}

/* free ids only from delayed timeout */
void
ipsp_ids_timeout(void *arg)
{
	struct ipsec_ids *ids = arg;

	DPRINTF(("%s: ids %p count %d\n", __func__, ids, ids->id_refcount));
	KASSERT(ids->id_refcount == 0);

	NET_LOCK();
	RBT_REMOVE(ipsec_ids_tree, &ipsec_ids_tree, ids);
	RBT_REMOVE(ipsec_ids_flows, &ipsec_ids_flows, ids);
	free(ids->id_local, M_CREDENTIALS, 0);
	free(ids->id_remote, M_CREDENTIALS, 0);
	free(ids, M_CREDENTIALS, 0);
	NET_UNLOCK();
}

/* decrements refcount, actual free happens in timeout */
void
ipsp_ids_free(struct ipsec_ids *ids)
{
	/*
	 * If the refcount becomes zero, then a timeout is started. This
	 * timeout must be cancelled if refcount is increased from zero.
	 */
	DPRINTF(("%s: ids %p count %d\n", __func__, ids, ids->id_refcount));
	KASSERT(ids->id_refcount > 0);
	if (--ids->id_refcount == 0)
		timeout_add_sec(&ids->id_timeout, ipsec_ids_idle);
}

static int
ipsp_id_cmp(struct ipsec_id *a, struct ipsec_id *b)
{
	if (a->type > b->type)
		return 1;
	if (a->type < b->type)
		return -1;
	if (a->len > b->len)
		return 1;
	if (a->len < b->len)
		return -1;
	return memcmp(a + 1, b + 1, a->len);
}

static inline int
ipsp_ids_cmp(const struct ipsec_ids *a, const struct ipsec_ids *b)
{
	int ret;

	ret = ipsp_id_cmp(a->id_remote, b->id_remote);
	if (ret != 0)
		return ret;
	return ipsp_id_cmp(a->id_local, b->id_local);
}

static inline int
ipsp_ids_flow_cmp(const struct ipsec_ids *a, const struct ipsec_ids *b)
{
	if (a->id_flow > b->id_flow)
		return 1;
	if (a->id_flow < b->id_flow)
		return -1;
	return 0;
}
@


1.225
log
@Split a part of tdb_delete() into tdb_unlink() so that we can remove
a TDB from the hash table without actually free()ing it.  That way we
can modify the TDB and then put it back in using puttdb().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.224 2017/05/18 10:56:45 bluhm Exp $	*/
a538 1
	int s;
d543 1
a543 1
	NET_LOCK(s);
d548 1
a548 1
	NET_UNLOCK(s);
a554 1
	int s;
d559 1
a559 1
	NET_LOCK(s);
d564 1
a564 1
	NET_UNLOCK(s);
a570 1
	int s;
d575 1
a575 1
	NET_LOCK(s);
d579 1
a579 1
	NET_UNLOCK(s);
a585 1
	int s;
d590 1
a590 1
	NET_LOCK(s);
d595 1
a595 1
	NET_UNLOCK(s);
a991 1
	int s;
d996 1
a996 1
	NET_LOCK(s);
d1002 1
a1002 1
	NET_UNLOCK(s);
@


1.224
log
@The function name ip4_input() is confusing as it also handles IPv6
packets.  This is the IP in IP protocol input function, so call it
ipip_input().  Rename the existing ipip_input() to ipip_input_gif()
as it is the input function used by the gif interface.  Pass the
address family to make it consistent with pr_input.  Use __func__
in debug print and panic messages.  Move all ipip prototypes to the
ip_ipip.h header file.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.223 2017/05/16 12:24:01 mpi Exp $	*/
d717 1
a717 1
tdb_delete(struct tdb *tdbp)
d778 9
a787 1
	tdb_count--;
@


1.223
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.222 2017/05/06 15:55:15 bluhm Exp $	*/
d57 1
@


1.222
log
@Convert the xformsw definition to C99 style initializer.  Also fix
the function declaration of ipe4_input() and avoid a wrong cast.
OK mikeb@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.221 2017/05/05 11:04:18 bluhm Exp $	*/
d214 1
a214 1
	splsoftassert(IPL_SOFTNET);
d309 1
a309 1
	splsoftassert(IPL_SOFTNET);
d510 1
a510 1
	splsoftassert(IPL_SOFTNET);
d608 1
a608 1
	splsoftassert(IPL_SOFTNET);
d667 1
a667 1
	splsoftassert(IPL_SOFTNET);
d721 1
a721 1
	splsoftassert(IPL_SOFTNET);
@


1.221
log
@Expand SA_LEN(), there is no benefit for using the macro in the
kernel.  It was only used in IPsec sources.  No binary change
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.220 2017/02/14 09:51:46 mpi Exp $	*/
d116 40
a155 13
	{ XF_IP4,	     0,               "IPv4 Simple Encapsulation",
	  ipe4_attach,       ipe4_init,       ipe4_zeroize,
	  (int (*)(struct mbuf *, struct tdb *, int, int))ipe4_input,
	  ipip_output, },
	{ XF_AH,	 XFT_AUTH,	    "IPsec AH",
	  ah_attach,	ah_init,   ah_zeroize,
	  ah_input,	 	ah_output, },
	{ XF_ESP,	 XFT_CONF|XFT_AUTH, "IPsec ESP",
	  esp_attach,	esp_init,  esp_zeroize,
	  esp_input,	esp_output, },
	{ XF_IPCOMP,	XFT_COMP, "IPcomp",
	  ipcomp_attach,    ipcomp_init, ipcomp_zeroize,
	  ipcomp_input,     ipcomp_output, },
d158 10
a167 4
	{ XF_TCPSIGNATURE,	 XFT_AUTH, "TCP MD5 Signature Option, RFC 2385",
	  tcp_signature_tdb_attach, 	tcp_signature_tdb_init,
	  tcp_signature_tdb_zeroize,	tcp_signature_tdb_input,
	  tcp_signature_tdb_output, }
@


1.220
log
@Get rid of recursive splsoftnet()/splx() dances and convert a timeout to
the timeout_set_proc(9) variant to take the NET_LOCK().

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.219 2016/12/19 08:36:49 mpi Exp $	*/
d163 1
a163 1
	SipHash24_Update(&ctx, dst, SA_LEN(&dst->sa));
d240 2
a241 2
		memcpy(&tdbp->tdb_dst.sa, &dst->sa, SA_LEN(&dst->sa));
		memcpy(&tdbp->tdb_src.sa, &src->sa, SA_LEN(&src->sa));
d286 1
a286 1
		    !memcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)))
d316 2
a317 2
		    !memcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa))) &&
		    !memcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa)))
d333 1
a333 1
		    !memcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa))) &&
d398 1
a398 1
		    (!memcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)))) {
d429 1
a429 1
		    (!memcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa)))) {
@


1.219
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.218 2016/11/15 09:48:03 mpi Exp $	*/
d179 3
a181 1
	int nums, s;
a233 1
		s = splsoftnet();
a234 2
		splx(s);

a268 2
 *
 * Caller is responsible for setting at least splsoftnet().
d276 2
a470 3
/*
 * Caller is responsible for setting at least splsoftnet().
 */
d477 2
a567 3
/*
 * Caller is responsible for splsoftnet().
 */
d575 2
d633 2
a634 1
	int s = splsoftnet();
a679 2

	splx(s);
a681 3
/*
 * Caller is responsible to set at least splsoftnet().
 */
d687 2
a688 1
	int s;
a692 2
	s = splsoftnet();

a745 2

	splx(s);
d936 1
a936 1
	timeout_set(&ids->id_timeout, ipsp_ids_timeout, ids);
d958 2
a959 1
	s = splsoftnet();
d965 1
a965 1
	splx(s);
@


1.218
log
@TDB timers need a context process, so convert them to timeout_set_proc(9).

ok phessler@@, bluhm@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.217 2016/09/20 14:01:04 mikeb Exp $	*/
d512 1
a512 1
	s = splsoftnet();
d517 1
a517 1
	splx(s);
d529 1
a529 1
	s = splsoftnet();
d534 1
a534 1
	splx(s);
d546 1
a546 1
	s = splsoftnet();
d550 1
a550 1
	splx(s);
d562 1
a562 1
	s = splsoftnet();
d567 1
a567 1
	splx(s);
@


1.217
log
@Sprinkle splsoftnets in TDB timeout callbacks; ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.216 2016/09/19 18:09:22 tedu Exp $	*/
d777 4
a780 4
	timeout_set(&tdbp->tdb_timer_tmo, tdb_timeout, tdbp);
	timeout_set(&tdbp->tdb_first_tmo, tdb_firstuse, tdbp);
	timeout_set(&tdbp->tdb_stimer_tmo, tdb_soft_timeout, tdbp);
	timeout_set(&tdbp->tdb_sfirst_tmo, tdb_soft_firstuse, tdbp);
@


1.216
log
@convert bcopy to memcpy. from david hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.215 2016/09/15 03:37:09 dlg Exp $	*/
d507 1
d512 1
d517 1
d524 1
d529 1
d534 1
d541 1
d546 1
d550 1
d557 1
d562 1
d567 1
@


1.215
log
@move from RB macros to RBT functions

shaves a bunch of bytes off kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.214 2015/05/23 12:38:53 markus Exp $	*/
d241 2
a242 2
		bcopy(&dst->sa, &tdbp->tdb_dst.sa, SA_LEN(&dst->sa));
		bcopy(&src->sa, &tdbp->tdb_src.sa, SA_LEN(&src->sa));
@


1.214
log
@introduce ipsec-id bundles and use them for ipsecflowinfo,
fixes rekeying for l2tp/ipsec against multiple windows clients
and saves memory (for many SAs to same peers); feedback and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.213 2015/04/17 11:04:01 mikeb Exp $	*/
d101 8
a108 6
static int ipsp_ids_cmp(struct ipsec_ids *, struct ipsec_ids *);
static int ipsp_ids_flow_cmp(struct ipsec_ids *, struct ipsec_ids *);
RB_PROTOTYPE(ipsec_ids_tree, ipsec_ids, id_node_flow, ipsp_ids_cmp);
RB_PROTOTYPE(ipsec_ids_flows, ipsec_ids, id_node_id, ipsp_ids_flow_cmp);
RB_GENERATE(ipsec_ids_tree, ipsec_ids, id_node_flow, ipsp_ids_cmp);
RB_GENERATE(ipsec_ids_flows, ipsec_ids, id_node_id, ipsp_ids_flow_cmp);
d910 1
a910 1
	found = RB_INSERT(ipsec_ids_tree, &ipsec_ids_tree, ids);
d922 1
a922 1
	while (RB_INSERT(ipsec_ids_flows, &ipsec_ids_flows, ids) != NULL) {
d944 1
a944 1
	return RB_FIND(ipsec_ids_flows, &ipsec_ids_flows, &key);
d957 2
a958 2
	RB_REMOVE(ipsec_ids_tree, &ipsec_ids_tree, ids);
	RB_REMOVE(ipsec_ids_flows, &ipsec_ids_flows, ids);
d993 2
a994 2
static int
ipsp_ids_cmp(struct ipsec_ids *a, struct ipsec_ids *b)
d1004 2
a1005 2
static int
ipsp_ids_flow_cmp(struct ipsec_ids *a, struct ipsec_ids *b)
@


1.213
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.212 2015/04/17 10:08:07 mikeb Exp $	*/
d95 13
d347 1
a347 2
    struct ipsec_ref *psrcid,
    struct ipsec_ref *pdstid,
d351 3
a353 8
	if (psrcid != NULL)
		if (tdb->tdb_srcid == NULL ||
		    !ipsp_ref_match(tdb->tdb_srcid, psrcid))
			return 0;

	if (pdstid != NULL)
		if (tdb->tdb_dstid == NULL ||
		    !ipsp_ref_match(tdb->tdb_dstid, pdstid))
d382 1
a382 1
    struct ipsec_ref *srcid, struct ipsec_ref *dstid,
d399 1
a399 2
			if (!ipsp_aux_match(tdbp, srcid, dstid, filter,
			    filtermask))
d413 1
a413 1
    struct ipsec_ref *srcid, struct ipsec_ref *dstid,
d430 1
a430 1
			if (!ipsp_aux_match(tdbp, dstid, srcid, filter,
d802 3
a804 8
	if (tdbp->tdb_srcid) {
		ipsp_reffree(tdbp->tdb_srcid);
		tdbp->tdb_srcid = NULL;
	}

	if (tdbp->tdb_dstid) {
		ipsp_reffree(tdbp->tdb_dstid);
		tdbp->tdb_dstid = NULL;
d896 50
a945 1
/* Free reference-counted structure. */
d947 1
a947 1
ipsp_reffree(struct ipsec_ref *ipr)
d949 40
a988 8
#ifdef DIAGNOSTIC
	if (ipr->ref_count <= 0)
		printf("ipsp_reffree: illegal reference count %d for "
		    "object %p (len = %d, malloctype = %d)\n",
		    ipr->ref_count, ipr, ipr->ref_len, ipr->ref_malloctype);
#endif
	if (--ipr->ref_count <= 0)
		free(ipr, ipr->ref_malloctype, 0);
d991 2
a992 3
/* Return true if the two structures match. */
int
ipsp_ref_match(struct ipsec_ref *ref1, struct ipsec_ref *ref2)
d994 7
a1000 4
	if (ref1->ref_type != ref2->ref_type ||
	    ref1->ref_len != ref2->ref_len ||
	    memcmp(ref1 + 1, ref2 + 1, ref1->ref_len))
		return 0;
d1002 8
a1009 1
	return 1;
@


1.212
log
@Remove unused ipsp_parse_headers that was supposed to parse packets
returned by IPsec-enabled NICs;  OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.211 2015/04/16 19:24:13 markus Exp $	*/
a906 30
}

/* Mark a TDB as TDBF_SKIPCRYPTO. */
void
ipsp_skipcrypto_mark(struct tdb_ident *tdbi)
{
	struct tdb *tdb;
	int s = splsoftnet();

	tdb = gettdb(tdbi->rdomain, tdbi->spi, &tdbi->dst, tdbi->proto);
	if (tdb != NULL) {
		tdb->tdb_flags |= TDBF_SKIPCRYPTO;
		tdb->tdb_last_marked = time_second;
	}
	splx(s);
}

/* Unmark a TDB as TDBF_SKIPCRYPTO. */
void
ipsp_skipcrypto_unmark(struct tdb_ident *tdbi)
{
	struct tdb *tdb;
	int s = splsoftnet();

	tdb = gettdb(tdbi->rdomain, tdbi->spi, &tdbi->dst, tdbi->proto);
	if (tdb != NULL) {
		tdb->tdb_flags &= ~TDBF_SKIPCRYPTO;
		tdb->tdb_last_marked = time_second;
	}
	splx(s);
@


1.211
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.210 2015/04/14 14:20:01 mikeb Exp $	*/
a949 218

#ifdef notyet
/*
 * Go down a chain of IPv4/IPv6/ESP/AH/IPiP chains creating an tag for each
 * IPsec header encountered. The offset where the first header, as well
 * as its type are given to us.
 */
struct m_tag *
ipsp_parse_headers(struct mbuf *m, int off, u_int8_t proto)
{
	int ipv4sa = 0, s, esphlen = 0, trail = 0, i;
	SLIST_HEAD(packet_tags, m_tag) tags;
	unsigned char lasteight[8];
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
	struct tdb *tdb;

	struct ip iph;

#ifdef INET6
	struct in6_addr ip6_dst;
#endif /* INET6 */

	/* We have to start with a known network protocol. */
	if (proto != IPPROTO_IPV4 && proto != IPPROTO_IPV6)
		return NULL;

	SLIST_INIT(&tags);

	while (1) {
		switch (proto) {
		case IPPROTO_IPV4: /* Also IPPROTO_IPIP */
		{
			/*
			 * Save the IP header (we need both the
			 * address and ip_hl).
			 */
			m_copydata(m, off, sizeof(struct ip), (caddr_t) &iph);
			ipv4sa = 1;
			proto = iph.ip_p;
			off += iph.ip_hl << 2;
			break;
		}

#ifdef INET6
		case IPPROTO_IPV6:
		{
			int nxtp, l;

			/* Copy the IPv6 address. */
			m_copydata(m, off + offsetof(struct ip6_hdr, ip6_dst),
			    sizeof(struct ip6_hdr), (caddr_t) &ip6_dst);
			ipv4sa = 0;

			/*
			 * Go down the chain of headers until we encounter a
			 * non-option.
			 */
			for (l = ip6_nexthdr(m, off, proto, &nxtp); l != -1;
			    l = ip6_nexthdr(m, off, proto, &nxtp)) {
				off += l;
				proto = nxtp;

				/* Construct a tag. */
				if (nxtp == IPPROTO_AH)	{
					mtag = m_tag_get(PACKET_TAG_IPSEC_IN_CRYPTO_DONE,
					    sizeof(struct tdb_ident),
					    M_NOWAIT);

					if (mtag == NULL)
						return SLIST_FIRST(&tags);

					tdbi = (struct tdb_ident *) (mtag + 1);
					memset(tdbi, 0, sizeof(struct tdb_ident));

					m_copydata(m, off + sizeof(u_int32_t),
					    sizeof(u_int32_t),
					    (caddr_t) &tdbi->spi);

					tdbi->proto = IPPROTO_AH;
					tdbi->dst.sin6.sin6_family = AF_INET6;
					tdbi->dst.sin6.sin6_len =
					    sizeof(struct sockaddr_in6);
					tdbi->dst.sin6.sin6_addr = ip6_dst;
					tdbi->rdomain =
					    rtable_l2(m->m_pkthdr.ph_rtableid);
					SLIST_INSERT_HEAD(&tags,
					    mtag, m_tag_link);
				}
				else
					if (nxtp == IPPROTO_IPV6)
						m_copydata(m, off +
						    offsetof(struct ip6_hdr,
							ip6_dst),
						    sizeof(struct ip6_hdr),
						    (caddr_t) &ip6_dst);
			}
			break;
		}
#endif /* INET6 */

		case IPPROTO_ESP:
		/* Verify that this has been decrypted. */
		{
			union sockaddr_union su;
			u_int32_t spi;

			m_copydata(m, off, sizeof(u_int32_t), (caddr_t) &spi);
			memset(&su, 0, sizeof(union sockaddr_union));

			s = splsoftnet();

			if (ipv4sa) {
				su.sin.sin_family = AF_INET;
				su.sin.sin_len = sizeof(struct sockaddr_in);
				su.sin.sin_addr = iph.ip_dst;
			}

#ifdef INET6
			if (!ipv4sa) {
				su.sin6.sin6_family = AF_INET6;
				su.sin6.sin6_len = sizeof(struct sockaddr_in6);
				su.sin6.sin6_addr = ip6_dst;
			}
#endif /* INET6 */

			tdb = gettdb(spi, &su, IPPROTO_ESP);
			if (tdb == NULL) {
				splx(s);
				return SLIST_FIRST(&tags);
			}

			/* How large is the ESP header ? We use this later. */
			esphlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen;

			/* Update the length of trailing ESP authenticators. */
			if (tdb->tdb_authalgxform)
				trail += tdb->tdb_authalgxform->authsize;

			splx(s);

			/* Copy the last 10 bytes. */
			m_copydata(m, m->m_pkthdr.len - trail - 8, 8,
			    lasteight);

			/* Verify the self-describing padding values. */
			if (lasteight[6] != 0) {
				if (lasteight[6] != lasteight[5])
					return SLIST_FIRST(&tags);

				for (i = 4; lasteight[i + 1] != 1 && i >= 0;
				    i--)
					if (lasteight[i + 1] !=
					    lasteight[i] + 1)
						return SLIST_FIRST(&tags);
			}
		}
		/* FALLTHROUGH */
		case IPPROTO_AH:
			mtag = m_tag_get(PACKET_TAG_IPSEC_IN_CRYPTO_DONE,
			    sizeof(struct tdb_ident), M_NOWAIT);
			if (mtag == NULL)
				return SLIST_FIRST(&tags);

			tdbi = (struct tdb_ident *) (mtag + 1);
			memset(tdbi, 0, sizeof(struct tdb_ident));

			/* Get SPI off the relevant header. */
			if (proto == IPPROTO_AH)
				m_copydata(m, off + sizeof(u_int32_t),
				    sizeof(u_int32_t), (caddr_t) &tdbi->spi);
			else /* IPPROTO_ESP */
				m_copydata(m, off, sizeof(u_int32_t),
				    (caddr_t) &tdbi->spi);

			tdbi->proto = proto; /* AH or ESP */
			tdbi->rdomain = rtable_l2(m->m_pkthdr.ph_rtableid);

			/* Last network header was IPv4. */
			if (ipv4sa) {
				tdbi->dst.sin.sin_family = AF_INET;
				tdbi->dst.sin.sin_len =
				    sizeof(struct sockaddr_in);
				tdbi->dst.sin.sin_addr = iph.ip_dst;
			}

#ifdef INET6
			/* Last network header was IPv6. */
			if (!ipv4sa) {
				tdbi->dst.sin6.sin6_family = AF_INET6;
				tdbi->dst.sin6.sin6_len =
				    sizeof(struct sockaddr_in6);
				tdbi->dst.sin6.sin6_addr = ip6_dst;
			}
#endif /* INET6 */

			SLIST_INSERT_HEAD(&tags, mtag, m_tag_link);

			/* Update next protocol/header and header offset. */
			if (proto == IPPROTO_AH) {
				u_int8_t foo[2];

				m_copydata(m, off, 2 * sizeof(u_int8_t), foo);
				proto = foo[0];
				off += (foo[1] + 2) << 2;
			} else {/* IPPROTO_ESP */
				/* Initialized in IPPROTO_ESP case. */
				off += esphlen;
				proto = lasteight[7];
			}
			break;

		default:
			return SLIST_FIRST(&tags); /* We're done. */
		}
	}
}
#endif /* notyet */
@


1.210
log
@make ipsp_address thread safe;  ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.209 2015/04/14 12:22:15 mikeb Exp $	*/
a747 4
	/* Init Incoming SA-Binding Queues. */
	TAILQ_INIT(&tdbp->tdb_inp_out);
	TAILQ_INIT(&tdbp->tdb_inp_in);

a768 1
	struct inpcb *inp;
a779 13
	/* Cleanup inp references. */
	for (inp = TAILQ_FIRST(&tdbp->tdb_inp_in); inp;
	    inp = TAILQ_FIRST(&tdbp->tdb_inp_in)) {
		TAILQ_REMOVE(&tdbp->tdb_inp_in, inp, inp_tdb_in_next);
		inp->inp_tdb_in = NULL;
	}

	for (inp = TAILQ_FIRST(&tdbp->tdb_inp_out); inp;
	    inp = TAILQ_FIRST(&tdbp->tdb_inp_out)) {
		TAILQ_REMOVE(&tdbp->tdb_inp_out, inp, inp_tdb_out_next);
		inp->inp_tdb_out = NULL;
	}

a845 62
}

/*
 * Check which transformations are required.
 */
u_int8_t
get_sa_require(struct inpcb *inp)
{
	u_int8_t sareq = 0;

	if (inp != NULL) {
		sareq |= inp->inp_seclevel[SL_AUTH] >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_AUTH : 0;
		sareq |= inp->inp_seclevel[SL_ESP_TRANS] >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_CONF : 0;
		sareq |= inp->inp_seclevel[SL_ESP_NETWORK] >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_TUNNEL : 0;
	} else {
		/*
		 * Code left for documentation purposes, these
		 * conditions are always evaluated to false.
		 */
		sareq |= IPSEC_AUTH_LEVEL_DEFAULT >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_AUTH : 0;
		sareq |= IPSEC_ESP_TRANS_LEVEL_DEFAULT >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_CONF : 0;
		sareq |= IPSEC_ESP_NETWORK_LEVEL_DEFAULT >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_TUNNEL : 0;
	}

	return (sareq);
}

/*
 * Add an inpcb to the list of inpcb which reference this tdb directly.
 */
void
tdb_add_inp(struct tdb *tdb, struct inpcb *inp, int inout)
{
	if (inout) {
		if (inp->inp_tdb_in) {
			if (inp->inp_tdb_in == tdb)
				return;

			TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp,
			    inp_tdb_in_next);
		}

		inp->inp_tdb_in = tdb;
		TAILQ_INSERT_TAIL(&tdb->tdb_inp_in, inp, inp_tdb_in_next);
	} else {
		if (inp->inp_tdb_out) {
			if (inp->inp_tdb_out == tdb)
				return;

			TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out, inp,
			    inp_tdb_out_next);
		}

		inp->inp_tdb_out = tdb;
		TAILQ_INSERT_TAIL(&tdb->tdb_inp_out, inp, inp_tdb_out_next);
	}
@


1.209
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.208 2015/04/13 16:52:26 mikeb Exp $	*/
d848 3
d860 2
a861 2
	    alg, ntohl(tdbp->tdb_spi), ipsp_address(tdbp->tdb_dst),
	    tdbp->tdb_sproto));
d931 1
a931 1
ipsp_address(union sockaddr_union sa)
d933 1
a933 8
	static char ipspbuf[4][INET6_ADDRSTRLEN];
	static int ipspround = 0;
	char *buf;

	ipspround = (ipspround + 1) % 4;
	buf = ipspbuf[ipspround];

	switch (sa.sa.sa_family) {
d935 2
a936 2
		return inet_ntop(AF_INET, &sa.sin.sin_addr,
		    buf, INET_ADDRSTRLEN);
d940 2
a941 2
		return inet_ntop(AF_INET6, &sa.sin6.sin6_addr,
		    buf, INET6_ADDRSTRLEN);
@


1.208
log
@Make filter argument to ipsp_aux_match optional like the rest of them.
OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.207 2015/04/13 16:48:01 mikeb Exp $	*/
d327 4
a330 4
 * Check that credentials and IDs match. Return true if so. The t*
 * range of arguments contains information from TDBs; the p*
 * range of arguments contains information from policies or
 * already established TDBs.
a335 2
    struct ipsec_ref *plcred,
    struct ipsec_ref *prcred,
a348 10
	if (plcred != NULL)
		if (tdb->tdb_local_cred == NULL ||
		   !ipsp_ref_match(tdb->tdb_local_cred, plcred))
			return 0;

	if (prcred != NULL)
		if (tdb->tdb_remote_cred == NULL ||
		    !ipsp_ref_match(tdb->tdb_remote_cred, prcred))
			return 0;

d376 1
a376 2
    struct ipsec_ref *local_cred, struct sockaddr_encap *filter,
    struct sockaddr_encap *filtermask)
d391 3
a393 3
			/* Do IDs and local credentials match ? */
			if (!ipsp_aux_match(tdbp, srcid, dstid,
			    local_cred, NULL, filter, filtermask))
d424 2
a425 2
			if (!ipsp_aux_match(tdbp, dstid, srcid, NULL, NULL,
			    filter, filtermask))
a813 10
	if (tdbp->tdb_local_auth) {
		ipsp_reffree(tdbp->tdb_local_auth);
		tdbp->tdb_local_auth = NULL;
	}

	if (tdbp->tdb_remote_auth) {
		ipsp_reffree(tdbp->tdb_remote_auth);
		tdbp->tdb_remote_auth = NULL;
	}

a821 10
	}

	if (tdbp->tdb_local_cred) {
		ipsp_reffree(tdbp->tdb_local_cred);
		tdbp->tdb_local_cred = NULL;
	}

	if (tdbp->tdb_remote_cred) {
		ipsp_reffree(tdbp->tdb_remote_cred);
		tdbp->tdb_remote_cred = NULL;
@


1.207
log
@Rename gettdbbyaddr to gettdbbydst;  OK markus, hshoexer, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.206 2015/04/13 16:45:52 mikeb Exp $	*/
d362 2
a363 1
	if (tdb->tdb_filter.sen_type) {
@


1.206
log
@Remove unused arguments from gettdb* functions;  OK markus, hshoexer, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.205 2015/04/10 12:31:55 dlg Exp $	*/
d129 1
a129 1
static struct tdb **tdbaddr = NULL;
d385 1
a385 1
gettdbbyaddr(u_int rdomain, union sockaddr_union *dst, u_int8_t sproto,
d393 1
a393 1
	if (tdbaddr == NULL)
d398 1
a398 1
	for (tdbp = tdbaddr[hashval]; tdbp != NULL; tdbp = tdbp->tdb_anext)
d568 1
a568 1
	struct tdb **new_tdbh, **new_tdbaddr, **new_srcaddr, *tdbp, *tdbnp;
d577 1
a577 1
	new_tdbaddr = mallocarray(tdb_hashmask + 1, sizeof(struct tdb *), M_TDB,
d592 2
a593 2
		for (tdbp = tdbaddr[i]; tdbp != NULL; tdbp = tdbnp) {
			tdbnp = tdbp->tdb_anext;
d597 2
a598 2
			tdbp->tdb_anext = new_tdbaddr[hashval];
			new_tdbaddr[hashval] = tdbp;
d614 2
a615 2
	free(tdbaddr, M_TDB, 0);
	tdbaddr = new_tdbaddr;
d634 1
a634 1
		tdbaddr = mallocarray(tdb_hashmask + 1, sizeof(struct tdb *),
d663 2
a664 2
	tdbp->tdb_anext = tdbaddr[hashval];
	tdbaddr[hashval] = tdbp;
d691 2
a695 1
	s = splsoftnet();
d713 2
a714 2
	if (tdbaddr[hashval] == tdbp) {
		tdbaddr[hashval] = tdbp->tdb_anext;
d716 4
a719 4
		for (tdbpp = tdbaddr[hashval]; tdbpp != NULL;
		    tdbpp = tdbpp->tdb_anext) {
			if (tdbpp->tdb_anext == tdbp) {
				tdbpp->tdb_anext = tdbp->tdb_anext;
d724 2
@


1.205
log
@replace the guts of tdb_hash with SipHash24

tested by (including some statistical measurement) and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.204 2015/03/14 03:38:52 jsg Exp $	*/
d387 2
a388 2
    struct ipsec_ref *local_cred, struct mbuf *m, int af,
    struct sockaddr_encap *filter, struct sockaddr_encap *filtermask)
d420 1
a420 2
    struct mbuf *m, int af, struct sockaddr_encap *filter,
    struct sockaddr_encap *filtermask)
@


1.204
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.203 2015/01/24 00:29:06 deraadt Exp $	*/
d127 1
d142 1
a142 22
	static u_int32_t mult1 = 0, mult2 = 0;
	u_int8_t *ptr = (u_int8_t *) dst;
	int i, shift;
	u_int64_t hash;
	int val32 = 0;

	while (mult1 == 0)
		mult1 = arc4random();
	while (mult2 == 0)
		mult2 = arc4random();

	hash = (spi ^ proto ^ rdomain) * mult1;
	for (i = 0; i < SA_LEN(&dst->sa); i++) {
		val32 = (val32 << 8) | ptr[i];
		if (i % 4 == 3) {
			hash ^= val32 * mult2;
			val32 = 0;
		}
	}

	if (i % 4 != 0)
		hash ^= val32 * mult2;
d144 5
a148 3
	shift = ffs(tdb_hashmask + 1);
	while ((hash & ~tdb_hashmask) != 0)
		hash = (hash >> shift) ^ (hash & tdb_hashmask);
d150 1
a150 1
	return hash;
d575 1
d632 1
@


1.203
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.202 2014/12/19 17:14:40 tedu Exp $	*/
a67 1
#include <crypto/xform.h>
@


1.202
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.201 2014/12/09 07:05:06 doug Exp $	*/
d51 6
a64 8

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>

#ifdef INET6
#endif /* INET6 */
@


1.201
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.200 2014/11/18 02:37:31 tedu Exp $	*/
a59 1
#ifdef INET
a63 1
#endif /* INET */
a65 3
#ifndef INET
#include <netinet/in.h>
#endif
a986 1
#ifdef INET
a989 1
#endif /* INET */
a1007 1
#ifdef INET
a1012 1
#endif /* INET */
a1099 1
#ifdef INET
a1100 1
#endif /* INET */
a1113 1
#ifdef INET
a1125 1
#endif /* INET */
a1194 1
#ifdef INET
a1199 1
#endif /* INET */
a1260 1
#ifdef INET
a1267 1
#endif /* INET */
@


1.200
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.199 2014/09/14 14:17:26 jsg Exp $	*/
d601 1
a601 1
	new_tdbh = malloc(sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB,
d603 1
a603 1
	new_tdbaddr = malloc(sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB,
d605 1
a605 1
	new_srcaddr = malloc(sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB,
d657 1
a657 3
		tdbh = malloc(sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB,
		    M_WAITOK | M_ZERO);
		tdbaddr = malloc(sizeof(struct tdb *) * (tdb_hashmask + 1),
d659 3
a661 1
		tdbsrc = malloc(sizeof(struct tdb *) * (tdb_hashmask + 1),
@


1.199
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.198 2014/09/08 06:24:13 jsg Exp $	*/
a75 1
#include <dev/rndvar.h>
@


1.198
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.197 2014/07/22 11:06:10 mpi Exp $	*/
a47 1
#include <sys/proc.h>
@


1.197
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.196 2014/07/12 18:44:23 tedu Exp $	*/
a51 1
#include <net/route.h>
@


1.196
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.195 2014/07/08 17:19:26 deraadt Exp $	*/
a63 1
#include <netinet/in_systm.h>
@


1.195
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.194 2014/04/14 09:06:42 mpi Exp $	*/
d641 1
a641 1
	free(tdbh, M_TDB);
d644 1
a644 1
	free(tdbaddr, M_TDB);
d647 1
a647 1
	free(tdbsrc, M_TDB);
d895 1
a895 1
	free(tdbp, M_TDB);
d1052 1
a1052 1
		free(ipr, ipr->ref_malloctype);
@


1.194
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.193 2014/01/09 06:29:06 tedu Exp $	*/
d44 1
a48 1
#include <sys/sysctl.h>
@


1.193
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.192 2013/11/11 09:15:34 mpi Exp $	*/
d1185 1
a1185 1
					    rtable_l2(m->m_pkthdr.rdomain);
d1278 1
a1278 1
			tdbi->rdomain = rtable_l2(m->m_pkthdr.rdomain);
@


1.192
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.191 2013/10/24 11:31:43 mpi Exp $	*/
d302 1
a302 1
		    !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)))
d332 2
a333 2
		    !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa))) &&
		    !bcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa)))
d339 1
a339 1
	bzero(&su_null, sizeof(su_null));
d349 1
a349 1
		    !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa))) &&
d400 1
a400 1
		if (bcmp(&tdb->tdb_filter, pfilter,
d402 1
a402 1
		    bcmp(&tdb->tdb_filtermask, pfiltermask,
d432 1
a432 1
		    (!bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)))) {
d465 1
a465 1
		    (!bcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa)))) {
d490 1
a490 1
	bzero (buckets, sizeof(buckets));
d1091 1
a1091 1
	    bcmp(ref1 + 1, ref2 + 1, ref1->ref_len))
d1173 1
a1173 1
					bzero(tdbi, sizeof(struct tdb_ident));
d1208 1
a1208 1
			bzero(&su, sizeof(union sockaddr_union));
d1267 1
a1267 1
			bzero(tdbi, sizeof(struct tdb_ident));
@


1.191
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.190 2013/07/04 09:48:48 mpi Exp $	*/
a983 15
/* Return a printable string for the IPv4 address. */
char *
inet_ntoa4(struct in_addr ina)
{
	static char buf[4][4 * sizeof "123" + 4];
	unsigned char *ucp = (unsigned char *) &ina;
	static int i = 3;

	i = (i + 1) % 4;
	snprintf(buf[i], sizeof buf[0], "%d.%d.%d.%d",
	    ucp[0] & 0xff, ucp[1] & 0xff,
	    ucp[2] & 0xff, ucp[3] & 0xff);
	return (buf[i]);
}

d985 1
a985 1
char *
d988 7
d998 2
a999 1
		return inet_ntoa4(sa.sin.sin_addr);
d1004 2
a1005 1
		return ip6_sprintf(&sa.sin6.sin6_addr);
@


1.190
log
@These functions are only used in debug code, so put them under
ifdef ENCDEBUG to make sure we don't use them elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.189 2013/04/11 12:06:25 mpi Exp $	*/
a73 1
#include <netinet6/in6_var.h>
@


1.189
log
@Remove the extern keyword from function declarations, document
sysctl declarations, move variables and functions used in only
one place in their corresponding file. No functional change.

No objection from markus@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.188 2013/04/10 08:50:59 mpi Exp $	*/
d984 1
d1019 1
@


1.188
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.187 2013/04/09 08:35:38 mpi Exp $	*/
a92 1
u_int8_t	get_sa_require(struct inpcb *);
a136 2

unsigned char ipseczeroes[IPSEC_ZEROES_SIZE]; /* zeroes! */
@


1.187
log
@Remove read-only ipsec variables and directly use defines instead.

ok mikeb@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.186 2013/03/28 23:10:05 tedu Exp $	*/
d67 1
a100 1
extern int encdebug;
@


1.186
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.185 2012/09/20 10:25:03 blambert Exp $	*/
a99 5
extern int	ipsec_auth_default_level;
extern int	ipsec_esp_trans_default_level;
extern int	ipsec_esp_network_default_level;
extern int	ipsec_ipcomp_default_level;

d941 5
a945 1
		sareq |= ipsec_auth_default_level >= IPSEC_LEVEL_USE ?
d947 1
a947 1
		sareq |= ipsec_esp_trans_default_level >= IPSEC_LEVEL_USE ?
d949 1
a949 1
		sareq |= ipsec_esp_network_default_level >= IPSEC_LEVEL_USE ?
@


1.185
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.184 2012/09/18 09:24:45 markus Exp $	*/
d49 1
@


1.184
log
@remove the SADB_X_SAFLAGS_{HALFIV,RANDOMPADDING,NOREPLAY} pfkey-API (not set
anywhere) as well as the matching TDBF_{HALFIV,RANDOMPADDING,NOREPLAY} code.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.183 2011/05/11 07:37:04 blambert Exp $	*/
d255 1
a255 1
		s = spltdb();
d294 1
a294 1
 * Caller is responsible for setting at least spltdb().
d516 1
a516 1
 * Caller is responsible for setting at least spltdb().
d602 1
a602 1
 * Caller is responsible for spltdb().
d666 1
a666 1
	int s = spltdb();
d716 1
a716 1
 * Caller is responsible to set at least spltdb().
d731 1
a731 1
	s = spltdb();
d1068 1
a1068 1
	int s = spltdb();
d1083 1
a1083 1
	int s = spltdb();
d1218 1
a1218 1
			s = spltdb();
@


1.183
log
@Pre-allocate memory to avoid sleeping after performing a lookup, which
may lead to a race.

ok markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.182 2011/03/31 10:36:42 jasper Exp $	*/
d1243 1
a1243 16
			if (tdb->tdb_flags & TDBF_NOREPLAY)
				esphlen = sizeof(u_int32_t) + tdb->tdb_ivlen;
			else
				esphlen = 2 * sizeof(u_int32_t) +
				    tdb->tdb_ivlen;

			/*
			 * Verify decryption. If the SA is using
			 * random padding (as the "old" ESP SAs were
			 * bound to do, there's nothing we can do to
			 * see if the payload has been decrypted.
			 */
			if (tdb->tdb_flags & TDBF_RANDOMPADDING) {
				splx(s);
				return SLIST_FIRST(&tags);
			}
@


1.182
log
@- use nitems(); no binary change

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.181 2010/07/09 16:58:06 reyk Exp $	*/
d200 1
a200 1
	struct tdb *tdbp;
d239 3
d256 1
a256 1
		tdbp = gettdb(rdomain, spi, dst, sproto);
d259 1
a259 1
		if (tdbp != (struct tdb *) NULL)
a261 1
		tdbp = tdb_alloc(rdomain);
d283 1
@


1.181
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.180 2010/04/20 22:05:43 tedu Exp $	*/
d141 1
a141 1
struct xformsw *xformswNXFORMSW = &xformsw[sizeof(xformsw)/sizeof(xformsw[0])];
@


1.180
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.179 2010/01/10 12:43:07 markus Exp $	*/
d97 1
a97 1
int		tdb_hash(u_int32_t, union sockaddr_union *, u_int8_t);
d158 2
a159 1
tdb_hash(u_int32_t spi, union sockaddr_union *dst, u_int8_t proto)
d172 1
a172 1
	hash = (spi ^ proto) * mult1;
d196 3
a198 2
reserve_spi(u_int32_t sspi, u_int32_t tspi, union sockaddr_union *src,
    union sockaddr_union *dst, u_int8_t sproto, int *errval)
d253 1
a253 1
		tdbp = gettdb(spi, dst, sproto);
d259 1
a259 1
		tdbp = tdb_alloc();
d294 1
a294 1
gettdb(u_int32_t spi, union sockaddr_union *dst, u_int8_t proto)
d302 1
a302 1
	hashval = tdb_hash(spi, dst, proto);
d306 1
d319 1
a319 1
gettdbbysrcdst(u_int32_t spi, union sockaddr_union *src,
d329 1
a329 1
	hashval = tdb_hash(0, src, proto);
d334 1
d346 1
a346 1
	hashval = tdb_hash(0, &su_null, proto);
d351 1
d420 1
a420 1
gettdbbyaddr(union sockaddr_union *dst, u_int8_t sproto,
d431 1
a431 1
	hashval = tdb_hash(0, dst, sproto);
d435 1
d453 1
a453 1
gettdbbysrc(union sockaddr_union *src, u_int8_t sproto,
d464 1
a464 1
	hashval = tdb_hash(0, src, sproto);
d468 1
d516 1
a516 1
tdb_walk(int (*walker)(struct tdb *, void *, int), void *arg)
d527 4
d620 2
a621 1
			hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst,
d629 2
a630 1
			hashval = tdb_hash(0, &tdbp->tdb_dst,
d638 2
a639 1
			hashval = tdb_hash(0, &tdbp->tdb_src,
d674 2
a675 1
	hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst, tdbp->tdb_sproto);
d688 2
a689 2
		hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst,
		    tdbp->tdb_sproto);
d695 2
a696 1
	hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);
d700 2
a701 1
	hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);
d725 2
a726 1
	hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst, tdbp->tdb_sproto);
d743 2
a744 1
	hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);
d758 2
a759 1
	hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);
d785 1
a785 1
tdb_alloc(void)
d800 3
d1067 1
a1067 1
	tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
d1082 1
a1082 1
	tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
d1189 2
d1298 1
@


1.179
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.178 2009/08/12 00:13:43 martynas Exp $	*/
d47 1
@


1.178
log
@don't confuse chars with strings;  ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.177 2009/06/02 21:28:36 blambert Exp $	*/
d1233 1
a1233 1
				trail += AH_HMAC_HASHLEN;
@


1.177
log
@Shuffle function declarations a bit; ipsp_kern doesn't actually exist,
and tdb_hash is only used in ip_ipsp.c, so there's no need to declare
it as extern in ip_ipsp.h

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.176 2009/06/02 11:05:09 oga Exp $	*/
d499 1
a499 1
			db_printf("%d%c\t\t%d\n", i, i == NBUCKETS - 1 ?
@


1.176
log
@Fix an off-by-one in the ddb-only debugging function tdb_hashstats.

when we check if a hash chain is over 15 long, we would access one past
the end of the array. change the static array size to a define because
it makes this checking easier to verify.

Found by Parfait.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.175 2009/02/16 00:31:25 dlg Exp $	*/
a89 1
int		ipsp_kern(int, char **, int);
d96 1
@


1.175
log
@pfsync v5, mostly written at n2k9, but based on work done at n2k8.

WARNING: THIS BREAKS COMPATIBILITY WITH THE PREVIOUS VERSION OF PFSYNC

this is a new variant of the protocol and a large reworking of the
pfsync code to address some performance issues. the single largest
benefit comes from having multiple pfsync messages of different
types handled in a single packet. pfsyncs handling of pf states is
highly optimised now, along with packet parsing and construction.

huggz for beck@@ for testing.
huge thanks to mcbride@@ for his help during development and for
finding all the bugs during the initial tests.
thanks to peter sutton for letting me get credit for this work.

ok beck@@ mcbride@@ "good." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.174 2008/10/22 23:04:45 mpf Exp $	*/
d474 2
d479 1
a479 1
	int i, cnt, buckets[16];
d490 1
a490 1
		for (tdbp = tdbh[i]; cnt < 16 && tdbp != NULL;
d497 1
a497 1
	for (i = 0; i < 16; i++)
d499 2
a500 2
			db_printf("%d%c\t\t%d\n", i, i == 15 ? "+" : "",
			    buckets[i]);
@


1.174
log
@#if INET  => #ifdef INET
#if INET6 => #ifdef INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.173 2008/09/15 21:46:01 chl Exp $	*/
d41 1
d56 4
d796 5
@


1.173
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok mpf@@ looks good mk@@ ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.172 2008/09/10 14:01:23 blambert Exp $	*/
d968 1
a968 1
#if INET
d973 1
a973 1
#if INET6
@


1.172
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.171 2008/04/18 06:42:20 djm Exp $	*/
a703 1
		tdbpp = tdbp;
a709 1
				tdbpp = tdbp;
a719 1
		tdbpp = tdbp;
a725 1
				tdbpp = tdbp;
a733 1
		tdbpp = tdbp;
a740 1
				tdbpp = tdbp;
@


1.171
log
@use arc4random_uniform() for random number requests that are not a
power of two.

use arc4random_bytes() when requesting more than a word of PRNG
output.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.170 2007/10/29 16:19:23 chl Exp $	*/
d265 2
a266 2
			timeout_add(&tdbp->tdb_timer_tmo,
			    hz * ipsec_keep_invalid);
@


1.170
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.169 2007/10/09 01:49:30 krw Exp $	*/
d235 1
a235 1
			spi = sspi + (arc4random() % (tspi - sspi));
@


1.169
log
@MALLOC+bzero -> malloc+M_ZERO. Don't forget FREE->free this time.

As with many of the last commits, looked at by chl@@ in an earlier
version.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.168 2007/02/14 00:53:48 jsg Exp $	*/
d1027 1
a1027 1
		FREE(ipr, ipr->ref_malloctype);
@


1.168
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.167 2007/01/18 20:00:19 henning Exp $	*/
d591 6
a596 10
	MALLOC(new_tdbh, struct tdb **,
	    sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);
	MALLOC(new_tdbaddr, struct tdb **,
	    sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);
	MALLOC(new_srcaddr, struct tdb **,
	    sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);

	bzero(new_tdbh, sizeof(struct tdb *) * (tdb_hashmask + 1));
	bzero(new_tdbaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));
	bzero(new_srcaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));
d624 1
a624 1
	FREE(tdbh, M_TDB);
d627 1
a627 1
	FREE(tdbaddr, M_TDB);
d630 1
a630 1
	FREE(tdbsrc, M_TDB);
d644 6
a649 13
		MALLOC(tdbh, struct tdb **,
		    sizeof(struct tdb *) * (tdb_hashmask + 1),
		    M_TDB, M_WAITOK);
		MALLOC(tdbaddr, struct tdb **,
		    sizeof(struct tdb *) * (tdb_hashmask + 1),
		    M_TDB, M_WAITOK);
		MALLOC(tdbsrc, struct tdb **,
		    sizeof(struct tdb *) * (tdb_hashmask + 1),
		    M_TDB, M_WAITOK);

		bzero(tdbh, sizeof(struct tdb *) * (tdb_hashmask + 1));
		bzero(tdbaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));
		bzero(tdbsrc, sizeof(struct tdb *) * (tdb_hashmask + 1));
d767 1
a767 2
	MALLOC(tdbp, struct tdb *, sizeof(struct tdb), M_TDB, M_WAITOK);
	bzero((caddr_t) tdbp, sizeof(struct tdb));
d870 1
a870 1
	FREE(tdbp, M_TDB);
@


1.167
log
@allow kernels with TCP_SIGNATURE (aka tcp md5sig), but without IPSEC to
compile and work. need to register pfkey whenever tcp md5 or ipsec is
defined, and the various ipsec encapsulations only if ipsec is defined.
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.166 2006/11/24 13:52:14 reyk Exp $	*/
d1259 1
a1259 1
		/* Fall through. */
@


1.166
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.165 2006/01/13 10:11:23 mpf Exp $	*/
d112 1
d126 1
@


1.165
log
@Path MTU discovery for NAT-T.
OK markus@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.164 2005/11/24 12:08:16 pedro Exp $	*/
d40 2
d51 4
d866 7
@


1.164
log
@Remove kernfs, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.163 2005/05/28 15:10:07 ho Exp $	*/
a295 1
#ifdef TCP_SIGNATURE
a340 1
#endif
@


1.163
log
@Add SA replay counter synchronization to pfsync(4). Required for IPsec
failover gateways. ok mcbride@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.162 2005/05/27 19:33:56 hshoexer Exp $	*/
a94 1
u_int32_t kernfs_epoch = 0;
a782 1
	tdbp->tdb_epoch = kernfs_epoch - 1;
a893 376

#ifdef KERNFS
/*
 * Print TDB information on a buffer.
 */
int
ipsp_print_tdb(struct tdb *tdb, char *buffer, size_t buflen)
{
	struct ctlname ipspflags[] = {
		{ "unique", TDBF_UNIQUE },
		{ "invalid", TDBF_INVALID },
		{ "halfiv", TDBF_HALFIV },
		{ "pfs", TDBF_PFS },
		{ "tunneling", TDBF_TUNNELING },
		{ "noreplay", TDBF_NOREPLAY },
		{ "random padding", TDBF_RANDOMPADDING },
		{ "skipcrypto", TDBF_SKIPCRYPTO },
		{ "usedtunnel", TDBF_USEDTUNNEL },
		{ "udpencap", TDBF_UDPENCAP },
	};
	int l, i, k, n;

	if (buflen == 0)
		return 0;

	n = snprintf(buffer, buflen,
	    "SPI = %08x, Destination = %s, Sproto = %u\n"
	    "\tEstablished %d seconds ago\n"
	    "\tSource = %s",
	    ntohl(tdb->tdb_spi), ipsp_address(tdb->tdb_dst), tdb->tdb_sproto,
	    time_second - tdb->tdb_established,
	    ipsp_address(tdb->tdb_src));
	if (n < 0 || n >= buflen)
		return 0;
	l = n;

	if (tdb->tdb_proxy.sa.sa_family) {
		n = snprintf(buffer + l, buflen - l,
		    ", Proxy = %s", ipsp_address(tdb->tdb_proxy));
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	n = snprintf(buffer + l, buflen - l, "\n");
	if (n < 0 || n >= buflen - l)
		return l;
	l += n;

	if (tdb->tdb_mtu && tdb->tdb_mtutimeout > time_second) {
		n = snprintf(buffer + l, buflen - l,
		    "\tMTU: %d, expires in %llu seconds\n",
		    tdb->tdb_mtu, tdb->tdb_mtutimeout - time_second);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	if (tdb->tdb_local_cred) {
		n = snprintf(buffer + l, buflen - l,
		    "\tLocal credential type %d\n",
		    ((struct ipsec_ref *) tdb->tdb_local_cred)->ref_type);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	if (tdb->tdb_remote_cred) {
		n = snprintf(buffer + l, buflen - l,
		    "\tRemote credential type %d\n",
		    ((struct ipsec_ref *) tdb->tdb_remote_cred)->ref_type);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	if (tdb->tdb_local_auth) {
		n = snprintf(buffer + l, buflen - l,
		    "\tLocal auth type %d\n",
		    ((struct ipsec_ref *) tdb->tdb_local_auth)->ref_type);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	if (tdb->tdb_remote_auth) {
		n = snprintf(buffer + l, buflen - l,
		    "\tRemote auth type %d\n",
		    ((struct ipsec_ref *) tdb->tdb_remote_auth)->ref_type);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	n = snprintf(buffer + l, buflen - l,
	    "\tFlags (%08x) = <", tdb->tdb_flags);
	if (n < 0 || n >= buflen - l)
		return l;
	l += n;

	if ((tdb->tdb_flags & ~(TDBF_TIMER | TDBF_BYTES | TDBF_ALLOCATIONS |
	    TDBF_FIRSTUSE | TDBF_SOFT_TIMER | TDBF_SOFT_BYTES |
	    TDBF_SOFT_FIRSTUSE | TDBF_SOFT_ALLOCATIONS)) == 0) {
		n = snprintf(buffer + l, buflen - l, "none>\n");
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	} else {
		for (k = 0, i = 0;
		    k < sizeof(ipspflags) / sizeof(struct ctlname); k++) {
			if (tdb->tdb_flags & ipspflags[k].ctl_type) {
				n = snprintf(buffer + l, buflen - l,
				    "%s,", ipspflags[k].ctl_name);
				if (n < 0 || n >= buflen - l)
					return l;
				l += n;
				i = 1;
			}
		}

		/* If we added flags, remove trailing comma. */
		if (i)
			l--;
		n = snprintf(buffer + l, buflen - l, ">\n");
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	n = snprintf(buffer + l, buflen - l,
	    "\tCrypto ID: %llu\n", tdb->tdb_cryptoid);
	if (n < 0 || n >= buflen - l)
		return l;
	l += n;

	if (tdb->tdb_udpencap_port) {
		n = snprintf(buffer + l, buflen - l,
		    "\tudpencap_port = <%u>\n", ntohs(tdb->tdb_udpencap_port));
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	if (tdb->tdb_xform) {
		n = snprintf(buffer + l, buflen - l,
		    "\txform = <%s>\n",
		    tdb->tdb_xform->xf_name);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	if (tdb->tdb_encalgxform) {
		n = snprintf(buffer + l, buflen - l,
		    "\t\tEncryption = <%s>\n",
		    tdb->tdb_encalgxform->name);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_authalgxform) {
		n = snprintf(buffer + l, buflen - l,
		    "\t\tAuthentication = <%s>\n",
		    tdb->tdb_authalgxform->name);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_compalgxform) {
		n = snprintf(buffer + l, buflen - l,
		    "\t\tCompression = <%s>\n",
		    tdb->tdb_compalgxform->name);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_onext) {
		n = snprintf(buffer + l, buflen - l,
		    "\tNext SA: SPI = %08x, Destination = %s, Sproto = %u\n",
		    ntohl(tdb->tdb_onext->tdb_spi),
		    ipsp_address(tdb->tdb_onext->tdb_dst),
		    tdb->tdb_onext->tdb_sproto);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_inext) {
		n = snprintf(buffer + l, buflen - l,
		    "\tPrevious SA: SPI = %08x, "
		    "Destination = %s, Sproto = %u\n",
		    ntohl(tdb->tdb_inext->tdb_spi),
		    ipsp_address(tdb->tdb_inext->tdb_dst),
		    tdb->tdb_inext->tdb_sproto);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	n = snprintf(buffer + l, buflen - l,
	    "\t%llu bytes processed by this SA\n",
	    tdb->tdb_cur_bytes);
	if (n < 0 || n >= buflen - l)
		return l;
	l += n;

	if (tdb->tdb_last_used) {
		n = snprintf(buffer + l, buflen - l,
		    "\tLast used %llu seconds ago\n",
		    time_second - tdb->tdb_last_used);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	if (tdb->tdb_last_marked) {
		n = snprintf(buffer + l, buflen - l,
		    "\tLast marked/unmarked %llu seconds ago\n",
		    time_second - tdb->tdb_last_marked);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}

	n = snprintf(buffer + l, buflen - l,
	    "\tExpirations:\n");
	if (n < 0 || n >= buflen - l)
		return l;
	l += n;

	if (tdb->tdb_flags & TDBF_TIMER) {
		n = snprintf(buffer + l, buflen - l,
		    "\t\tHard expiration(1) in %llu seconds\n",
		    tdb->tdb_established + tdb->tdb_exp_timeout - time_second);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_flags & TDBF_SOFT_TIMER) {
		n = snprintf(buffer + l, buflen - l,
		    "\t\tSoft expiration(1) in %llu seconds\n",
		    tdb->tdb_established + tdb->tdb_soft_timeout -
		    time_second);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_flags & TDBF_BYTES) {
		n = snprintf(buffer + l, buflen - l,
		    "\t\tHard expiration after %llu bytes\n",
		    tdb->tdb_exp_bytes);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_flags & TDBF_SOFT_BYTES) {
		n = snprintf(buffer + l, buflen - l,
		    "\t\tSoft expiration after %llu bytes\n",
		    tdb->tdb_soft_bytes);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_flags & TDBF_ALLOCATIONS) {
		n = snprintf(buffer + l, buflen - l,
		    "\t\tHard expiration after %u flows\n",
		    tdb->tdb_exp_allocations);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS) {
		n = snprintf(buffer + l, buflen - l,
		    "\t\tSoft expiration after %u flows\n",
		    tdb->tdb_soft_allocations);
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	if (tdb->tdb_flags & TDBF_FIRSTUSE) {
		if (tdb->tdb_first_use) {
			n = snprintf(buffer + l, buflen - l,
			    "\t\tHard expiration(2) in %llu seconds\n",
			    (tdb->tdb_first_use + tdb->tdb_exp_first_use) -
			    time_second);
			if (n < 0 || n >= buflen - l)
				return l;
			l += n;
		} else {
			n = snprintf(buffer + l, buflen - l,
			    "\t\tHard expiration in %llu seconds "
			    "after first use\n",
			    tdb->tdb_exp_first_use);
			if (n < 0 || n >= buflen - l)
				return l;
			l += n;
		}
	}

	if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE) {
		if (tdb->tdb_first_use) {
			n = snprintf(buffer + l, buflen - l,
			    "\t\tSoft expiration(2) in %llu seconds\n",
			    (tdb->tdb_first_use + tdb->tdb_soft_first_use) -
			    time_second);
			if (n < 0 || n >= buflen - l)
				return l;
			l += n;
		} else {
			n = snprintf(buffer + l, buflen - l,
			    "\t\tSoft expiration in %llu seconds "
			    "after first use\n", tdb->tdb_soft_first_use);
			if (n < 0 || n >= buflen - l)
				return l;
			l += n;
		}
	}

	if (!(tdb->tdb_flags &
	    (TDBF_TIMER | TDBF_SOFT_TIMER | TDBF_BYTES |
	    TDBF_SOFT_ALLOCATIONS | TDBF_ALLOCATIONS |
	    TDBF_SOFT_BYTES | TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE))) {
		n = snprintf(buffer + l, buflen - l, "\t\t(none)\n");
		if (n < 0 || n >= buflen - l)
			return l;
		l += n;
	}
	n = snprintf(buffer + l, buflen - l, "\n");
	if (n < 0 || n >= buflen - l)
		return l;
	l += n;

	return l;
}

/*
 * Used by kernfs.
 */
int
ipsp_kern(int off, char **bufp, int len)
{
	static char buffer[IPSEC_KERNFS_BUFSIZE];
	struct tdb *tdb;
	int i, s, l;

	if (bufp == NULL)
		return 0;

	bzero(buffer, IPSEC_KERNFS_BUFSIZE);
	*bufp = buffer;

	if (off == 0) {
		kernfs_epoch++;
		l = snprintf(buffer, sizeof buffer,
		    "Hashmask: %d, policy entries: %d\n",
		    tdb_hashmask, ipsec_in_use);
		if (l < 0 || l >= sizeof buffer)
			return 0;
		return l;
	}

	if (tdbh == NULL)
		return 0;

	for (i = 0; i <= tdb_hashmask; i++) {
		s = spltdb();
		for (tdb = tdbh[i]; tdb; tdb = tdb->tdb_hnext) {
			if (tdb->tdb_epoch != kernfs_epoch) {
				tdb->tdb_epoch = kernfs_epoch;
				l = ipsp_print_tdb(tdb, buffer, sizeof buffer);
				splx(s);
				return l;
			}
		}
		splx(s);
	}
	return 0;
}
#endif /* KERNFS */
@


1.162
log
@long overdue snprintf cleanup in kernfs related code
ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.161 2005/04/21 08:56:24 hshoexer Exp $	*/
a78 4
#ifdef __GNUC__
#define	INLINE	static __inline
#endif

d144 1
a144 1
INLINE int
@


1.161
log
@handle return value of snprintf correctly

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.160 2004/11/19 10:11:52 hshoexer Exp $	*/
d920 1
a920 1
	int l, i, k;
d922 4
a925 1
	snprintf(buffer, buflen,
d932 3
a934 1
	l = strlen(buffer);
d937 1
a937 1
		snprintf(buffer + l, buflen - l,
d939 8
a946 4
		l += strlen(buffer + l);
	}
	snprintf(buffer + l, buflen - l, "\n");
	l += strlen(buffer + l);
d949 1
a949 1
		snprintf(buffer + l, buflen - l,
d952 3
a954 1
		l += strlen(buffer + l);
d958 1
a958 1
		snprintf(buffer + l, buflen - l,
d961 3
a963 1
		l += strlen(buffer + l);
d967 1
a967 1
		snprintf(buffer + l, buflen - l,
d970 3
a972 1
		l += strlen(buffer + l);
d976 1
a976 1
		snprintf(buffer + l, buflen - l,
d979 3
a981 1
		l += strlen(buffer + l);
d985 1
a985 1
		snprintf(buffer + l, buflen - l,
d988 3
a990 1
		l += strlen(buffer + l);
d993 1
a993 1
	snprintf(buffer + l, buflen - l,
d995 3
a997 1
	l += strlen(buffer + l);
d1002 4
a1005 2
		snprintf(buffer + l, buflen - l, "none>\n");
		l += strlen(buffer + l);
d1010 1
a1010 1
				snprintf(buffer + l, buflen - l,
d1012 3
a1014 1
				l += strlen(buffer + l);
d1022 4
a1025 2
		snprintf(buffer + l, buflen - l, ">\n");
		l += strlen(buffer + l);
d1028 1
a1028 1
	snprintf(buffer + l, buflen - l,
d1030 3
a1032 1
	l += strlen(buffer + l);
d1035 1
a1035 1
		snprintf(buffer + l, buflen - l,
d1037 3
a1039 1
		l += strlen(buffer + l);
d1043 1
a1043 1
		snprintf(buffer + l, buflen - l,
d1046 3
a1048 1
		l += strlen(buffer + l);
d1052 1
a1052 1
		snprintf(buffer + l, buflen - l,
d1055 3
a1057 1
		l += strlen(buffer + l);
d1060 1
a1060 1
		snprintf(buffer + l, buflen - l,
d1063 3
a1065 1
		l += strlen(buffer + l);
d1068 1
a1068 1
		snprintf(buffer + l, buflen - l,
d1071 3
a1073 1
		l += strlen(buffer + l);
d1076 1
a1076 1
		snprintf(buffer + l, buflen - l,
d1081 3
a1083 1
		l += strlen(buffer + l);
d1086 1
a1086 1
		snprintf(buffer + l, buflen - l,
d1092 3
a1094 1
		l += strlen(buffer + l);
d1096 1
a1096 1
	snprintf(buffer + l, buflen - l,
d1099 3
a1101 1
	l += strlen(buffer + l);
d1104 1
a1104 1
		snprintf(buffer + l, buflen - l,
d1107 3
a1109 1
		l += strlen(buffer + l);
d1113 1
a1113 1
		snprintf(buffer + l, buflen - l,
d1116 3
a1118 1
		l += strlen(buffer + l);
d1121 1
a1121 1
	snprintf(buffer + l, buflen - l,
d1123 3
a1125 1
	l += strlen(buffer + l);
d1128 1
a1128 1
		snprintf(buffer + l, buflen -l,
d1131 3
a1133 1
		l += strlen(buffer + l);
d1136 1
a1136 1
		snprintf(buffer + l, buflen -l,
d1140 3
a1142 1
		l += strlen(buffer + l);
d1145 1
a1145 1
		snprintf(buffer + l, buflen -l,
d1148 3
a1150 1
		l += strlen(buffer + l);
d1153 1
a1153 1
		snprintf(buffer + l, buflen -l,
d1156 3
a1158 1
		l += strlen(buffer + l);
d1161 1
a1161 1
		snprintf(buffer + l, buflen -l,
d1164 3
a1166 1
		l += strlen(buffer + l);
d1169 1
a1169 1
		snprintf(buffer + l, buflen -l,
d1172 3
a1174 1
		l += strlen(buffer + l);
d1178 1
a1178 1
			snprintf(buffer + l, buflen -l,
d1182 3
a1184 1
			l += strlen(buffer + l);
d1186 1
a1186 1
			snprintf(buffer + l, buflen -l,
d1190 3
a1192 1
			l += strlen(buffer + l);
d1198 1
a1198 1
			snprintf(buffer + l, buflen -l,
d1202 3
a1204 1
			l += strlen(buffer + l);
d1206 1
a1206 1
			snprintf(buffer + l, buflen -l,
d1209 3
a1211 1
			l += strlen(buffer + l);
d1219 9
a1227 5
		snprintf(buffer + l, buflen -l, "\t\t(none)\n");
		l += strlen(buffer + l);
	}
	snprintf(buffer + l, buflen -l, "\n");
	l += strlen(buffer + l);
@


1.160
log
@Plug memory leak.  Found by pat@@.  Thanks!

ok myself markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.159 2004/06/21 23:50:37 tholo Exp $	*/
d1178 2
@


1.159
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.158 2004/04/14 20:10:04 markus Exp $	*/
d294 2
a295 3
		if ((tdbp->tdb_spi == spi) &&
		    !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)) &&
		    (tdbp->tdb_sproto == proto))
a702 1
	struct ipsec_policy *ipo;
a703 1
	struct inpcb *inp;
d763 41
d866 1
a866 1
		tdbp->tdb_local_cred = NULL;
a875 33
	tdb_count--;

	splx(s);
}

/*
 * Allocate a TDB and initialize a few basic fields.
 */
struct tdb *
tdb_alloc(void)
{
	struct tdb *tdbp;

	MALLOC(tdbp, struct tdb *, sizeof(struct tdb), M_TDB, M_WAITOK);
	bzero((caddr_t) tdbp, sizeof(struct tdb));

	/* Init Incoming SA-Binding Queues. */
	TAILQ_INIT(&tdbp->tdb_inp_out);
	TAILQ_INIT(&tdbp->tdb_inp_in);

	TAILQ_INIT(&tdbp->tdb_policy_head);

	/* Record establishment time. */
	tdbp->tdb_established = time_second;
	tdbp->tdb_epoch = kernfs_epoch - 1;

	/* Initialize timeouts. */
	timeout_set(&tdbp->tdb_timer_tmo, tdb_timeout, tdbp);
	timeout_set(&tdbp->tdb_first_tmo, tdb_firstuse, tdbp);
	timeout_set(&tdbp->tdb_stimer_tmo, tdb_soft_timeout, tdbp);
	timeout_set(&tdbp->tdb_sfirst_tmo, tdb_soft_firstuse, tdbp);

	return tdbp;
@


1.158
log
@simpler ipsp_aux_match() API; ok henning, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.157 2004/03/31 10:21:37 henning Exp $	*/
d693 1
a693 1
	ipsec_last_added = time.tv_sec;
d861 1
a861 1
	tdbp->tdb_established = time.tv_sec;
d922 1
a922 1
	    time.tv_sec - tdb->tdb_established,
d934 1
a934 1
	if (tdb->tdb_mtu && tdb->tdb_mtutimeout > time.tv_sec) {
d937 1
a937 1
		    tdb->tdb_mtu, tdb->tdb_mtutimeout - time.tv_sec);
d1056 1
a1056 1
		    time.tv_sec - tdb->tdb_last_used);
d1063 1
a1063 1
		    time.tv_sec - tdb->tdb_last_marked);
d1074 1
a1074 1
		    tdb->tdb_established + tdb->tdb_exp_timeout - time.tv_sec);
d1081 1
a1081 1
		    time.tv_sec);
d1113 1
a1113 1
			    time.tv_sec);
d1129 1
a1129 1
			    time.tv_sec);
d1339 1
a1339 1
		tdb->tdb_last_marked = time.tv_sec;
d1354 1
a1354 1
		tdb->tdb_last_marked = time.tv_sec;
@


1.157
log
@in gettdbbysrcdst(), allow matching with either src or dst beeing a wildcard
(emtpy) entry
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.156 2004/02/15 12:44:24 markus Exp $	*/
d357 7
a363 6
ipsp_aux_match(struct ipsec_ref *tsrcid, struct ipsec_ref *psrcid,
    struct ipsec_ref *tdstid, struct ipsec_ref *pdstid,
    struct ipsec_ref *tlcred, struct ipsec_ref *plcred,
    struct ipsec_ref *trcred, struct ipsec_ref *prcred,
    struct sockaddr_encap *tfilter, struct sockaddr_encap *pfilter,
    struct sockaddr_encap *tfiltermask, struct sockaddr_encap *pfiltermask)
d366 2
a367 1
		if (tsrcid == NULL || !ipsp_ref_match(tsrcid, psrcid))
d371 2
a372 1
		if (tdstid == NULL || !ipsp_ref_match(tdstid, pdstid))
d376 2
a377 1
		if (tlcred == NULL || !ipsp_ref_match(tlcred, plcred))
d381 2
a382 1
		if (trcred == NULL || !ipsp_ref_match(trcred, prcred))
d386 1
a386 1
	if (tfilter->sen_type) {
d394 4
a397 3
		if (bcmp(tfilter, pfilter, sizeof(struct sockaddr_encap)) ||
		    bcmp(tfiltermask, pfiltermask,
			sizeof(struct sockaddr_encap)))
d427 2
a428 4
			if (!ipsp_aux_match(tdbp->tdb_srcid, srcid,
			    tdbp->tdb_dstid, dstid, tdbp->tdb_local_cred,
			    local_cred, NULL, NULL, &tdbp->tdb_filter, filter,
			    &tdbp->tdb_filtermask, filtermask))
d459 2
a460 4
			if (!ipsp_aux_match(tdbp->tdb_srcid, dstid,
			    tdbp->tdb_dstid, srcid, NULL, NULL, NULL, NULL,
			    &tdbp->tdb_filter, filter, &tdbp->tdb_filtermask,
			    filtermask))
@


1.156
log
@check TDBF_INVALID for TCP MD5 SA lookups; ok mcbride, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.155 2004/01/27 09:29:22 markus Exp $	*/
d314 1
d325 2
a326 1
		    !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)) &&
d330 17
a346 1
	return tdbp;
@


1.155
log
@in gettdbbysrcdst(): hash by SRC and lookup SA in the tdbsrc[] hash table
with hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.154 2004/01/22 14:38:28 markus Exp $	*/
d321 3
a323 1
		if ((spi == 0 || tdbp->tdb_spi == spi) &&
d325 1
a325 2
		    !bcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa)) &&
		    (tdbp->tdb_sproto == proto))
@


1.154
log
@add gettdbbysrcdst(), just like gettdb(), but compares tdb_src as well; ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.153 2003/12/02 23:16:28 markus Exp $	*/
d304 3
a306 1
 * Same as gettdb() but compare SRC as well.
d315 1
a315 1
	if (tdbh == NULL)
d318 1
a318 1
	hashval = tdb_hash(spi, dst, proto);
d320 2
a321 2
	for (tdbp = tdbh[hashval]; tdbp != NULL; tdbp = tdbp->tdb_hnext)
		if ((tdbp->tdb_spi == spi) &&
@


1.153
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.152 2003/05/09 14:59:19 deraadt Exp $	*/
d301 27
@


1.152
log
@string cleaning; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.151 2003/05/06 07:28:39 deraadt Exp $	*/
d863 1
d949 6
@


1.151
log
@string cleaning; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.150 2002/11/19 18:34:41 jason Exp $	*/
d866 1
a866 1
	l = snprintf(buffer, buflen,
d873 1
d875 2
a876 2
	if (tdb->tdb_proxy.sa.sa_family)
		l += snprintf(buffer + l, buflen - l,
d878 4
a881 1
	l += snprintf(buffer + l, buflen - l, "\n");
d883 2
a884 2
	if (tdb->tdb_mtu && tdb->tdb_mtutimeout > time.tv_sec)
		l += snprintf(buffer + l, buflen - l,
d887 2
d890 2
a891 2
	if (tdb->tdb_local_cred)
		l += snprintf(buffer + l, buflen - l,
d894 2
d897 2
a898 2
	if (tdb->tdb_remote_cred)
		l += snprintf(buffer + l, buflen - l,
d901 2
d904 2
a905 2
	if (tdb->tdb_local_auth)
		l += snprintf(buffer + l, buflen - l,
d908 2
d911 2
a912 2
	if (tdb->tdb_remote_auth)
		l += snprintf(buffer + l, buflen - l,
d915 2
d918 1
a918 1
	l += snprintf(buffer + l, buflen - l,
d920 1
d924 4
a927 3
	    TDBF_SOFT_FIRSTUSE | TDBF_SOFT_ALLOCATIONS)) == 0)
		l += snprintf(buffer + l, buflen - l, "none>\n");
	else {
d931 1
a931 1
				l += snprintf(buffer + l, buflen - l,
d933 1
d941 2
a942 1
		l += snprintf(buffer + l, buflen - l, ">\n");
d945 1
a945 1
	l += snprintf(buffer + l, buflen - l,
d947 1
d949 2
a950 2
	if (tdb->tdb_xform)
		l += snprintf(buffer + l, buflen - l,
d953 2
d956 2
a957 2
	if (tdb->tdb_encalgxform)
		l += snprintf(buffer + l, buflen - l,
d960 4
a963 3

	if (tdb->tdb_authalgxform)
		l += snprintf(buffer + l, buflen - l,
d966 4
a969 3

	if (tdb->tdb_compalgxform)
		l += snprintf(buffer + l, buflen - l,
d972 4
a975 3

	if (tdb->tdb_onext)
		l += snprintf(buffer + l, buflen - l,
d980 4
a983 3

	if (tdb->tdb_inext)
		l += snprintf(buffer + l, buflen - l,
d989 3
a991 2

	l += snprintf(buffer + l, buflen - l,
d994 1
d996 2
a997 2
	if (tdb->tdb_last_used)
		l += snprintf(buffer + l, buflen - l,
d1000 2
d1003 2
a1004 2
	if (tdb->tdb_last_marked)
		l += snprintf(buffer + l, buflen - l,
d1007 2
d1010 1
a1010 1
	l += snprintf(buffer + l, buflen - l,
d1012 1
d1014 2
a1015 2
	if (tdb->tdb_flags & TDBF_TIMER)
		l += snprintf(buffer + l, buflen -l,
d1018 4
a1021 3

	if (tdb->tdb_flags & TDBF_SOFT_TIMER)
		l += snprintf(buffer + l, buflen -l,
d1025 4
a1028 3

	if (tdb->tdb_flags & TDBF_BYTES)
		l += snprintf(buffer + l, buflen -l,
d1031 4
a1034 3

	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
		l += snprintf(buffer + l, buflen -l,
d1037 4
a1040 3

	if (tdb->tdb_flags & TDBF_ALLOCATIONS)
		l += snprintf(buffer + l, buflen -l,
d1043 4
a1046 3

	if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS)
		l += snprintf(buffer + l, buflen -l,
d1049 2
a1050 1

d1052 2
a1053 2
		if (tdb->tdb_first_use)
			l += snprintf(buffer + l, buflen -l,
d1057 3
a1059 2
		else
			l += snprintf(buffer + l, buflen -l,
d1063 2
d1068 2
a1069 2
		if (tdb->tdb_first_use)
			l += snprintf(buffer + l, buflen -l,
d1073 3
a1075 2
		else
			l += snprintf(buffer + l, buflen -l,
d1078 2
d1084 7
a1090 5
		TDBF_SOFT_ALLOCATIONS | TDBF_ALLOCATIONS |
		TDBF_SOFT_BYTES | TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE)))
		l += snprintf(buffer + l, buflen -l, "\t\t(none)\n");

	l += snprintf(buffer + l, buflen -l, "\n");
@


1.150
log
@Use queue.h macros
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.149 2002/06/09 16:26:10 itojun Exp $	*/
d851 1
a851 1
ipsp_print_tdb(struct tdb *tdb, char *buffer)
a852 1
	int l, i, k;
d864 1
d866 7
a872 7
	l = sprintf(buffer,  "SPI = %08x, Destination = %s, Sproto = %u\n",
	    ntohl(tdb->tdb_spi), ipsp_address(tdb->tdb_dst), tdb->tdb_sproto);

	l += sprintf(buffer + l, "\tEstablished %d seconds ago\n",
	    time.tv_sec - tdb->tdb_established);

	l += sprintf(buffer + l, "\tSource = %s", ipsp_address(tdb->tdb_src));
d875 3
a877 4
		l += sprintf(buffer + l, ", Proxy = %s\n",
		    ipsp_address(tdb->tdb_proxy));
	else
		l += sprintf(buffer + l, "\n");
d880 2
a881 1
		l += sprintf(buffer + l, "\tMTU: %d, expires in %llu seconds\n",
d885 2
a886 1
		l += sprintf(buffer + l, "\tLocal credential type %d\n",
d890 2
a891 1
		l += sprintf(buffer + l, "\tRemote credential type %d\n",
d895 2
a896 1
		l += sprintf(buffer + l, "\tLocal auth type %d\n",
d900 2
a901 1
		l += sprintf(buffer + l, "\tRemote auth type %d\n",
d904 2
a905 1
	l += sprintf(buffer + l, "\tFlags (%08x) = <", tdb->tdb_flags);
d910 1
a910 1
		l += sprintf(buffer + l, "none>\n");
d915 2
a916 2
				l += sprintf(buffer + l, "%s,",
				    ipspflags[k].ctl_name);
d924 1
a924 1
		l += sprintf(buffer + l, ">\n");
d927 2
a928 1
	l += sprintf(buffer + l, "\tCrypto ID: %llu\n", tdb->tdb_cryptoid);
d931 2
a932 1
		l += sprintf(buffer + l, "\txform = <%s>\n",
d936 2
a937 1
		l += sprintf(buffer + l, "\t\tEncryption = <%s>\n",
d941 2
a942 1
		l += sprintf(buffer + l, "\t\tAuthentication = <%s>\n",
d946 2
a947 1
		l += sprintf(buffer + l, "\t\tCompression = <%s>\n",
d951 1
a951 1
		l += sprintf(buffer + l,
d958 2
a959 1
		l += sprintf(buffer + l, "\tPrevious SA: SPI = %08x, "
d965 2
a966 1
	l += sprintf(buffer + l, "\t%llu bytes processed by this SA\n",
d970 2
a971 1
		l += sprintf(buffer + l, "\tLast used %llu seconds ago\n",
d975 1
a975 1
		l += sprintf(buffer + l,
d979 2
a980 1
	l += sprintf(buffer + l, "\tExpirations:\n");
d983 1
a983 1
		l += sprintf(buffer + l,
d988 1
a988 1
		l += sprintf(buffer + l,
d994 1
a994 1
		l += sprintf(buffer + l,
d999 1
a999 1
		l += sprintf(buffer + l,
d1004 1
a1004 1
		l += sprintf(buffer + l,
d1009 1
a1009 1
		l += sprintf(buffer + l,
d1015 1
a1015 1
			l += sprintf(buffer + l,
d1020 1
a1020 1
			l += sprintf(buffer + l,
d1028 1
a1028 1
			l += sprintf(buffer + l,
d1033 1
a1033 1
			l += sprintf(buffer + l,
d1042 1
a1042 1
		l += sprintf(buffer + l, "\t\t(none)\n");
d1044 1
a1044 1
	l += sprintf(buffer + l, "\n");
d1067 2
a1068 1
		l = sprintf(buffer, "Hashmask: %d, policy entries: %d\n",
d1081 1
a1081 1
				l = ipsp_print_tdb(tdb, buffer);
d1159 2
a1160 1
	sprintf(buf[i], "%d.%d.%d.%d", ucp[0] & 0xff, ucp[1] & 0xff,
@


1.149
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.148 2002/06/09 04:22:40 angelos Exp $	*/
d1325 1
a1325 1
						return tags.slh_first;
d1384 1
a1384 1
				return tags.slh_first;
d1402 1
a1402 1
				return tags.slh_first;
d1418 1
a1418 1
					return tags.slh_first;
d1424 1
a1424 1
						return tags.slh_first;
d1432 1
a1432 1
				return tags.slh_first;
d1484 1
a1484 1
			return tags.slh_first; /* We're done. */
@


1.148
log
@Comment out currently-unused code (it's there for the ethernet-ipsec
cards, none of which we support at the moment).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.147 2002/05/31 02:41:08 angelos Exp $	*/
d194 1
a194 1
	if (sproto != IPPROTO_IPCOMP && 
d1216 1
a1216 1
 
d1231 1
a1231 1
 
@


1.147
log
@Move some common code to separate routines; also, fix the problem of
using the same SA for different traffic classes. Now, different SAs
will be renegotiated as needed.

XXX It's a sub-optimal (but correct) solution, as it looks for an
exact match -- it should be checking for subset/subnet. One of these
days...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.146 2002/03/14 01:27:11 millert Exp $	*/
d1240 13
d1488 1
a1488 12

/* Return true if the two structures match. */
int
ipsp_ref_match(struct ipsec_ref *ref1, struct ipsec_ref *ref2)
{
	if (ref1->ref_type != ref2->ref_type ||
	    ref1->ref_len != ref2->ref_len ||
	    bcmp(ref1 + 1, ref2 + 1, ref1->ref_len))
		return 0;

	return 1;
}
@


1.146
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.145 2002/02/23 22:16:13 angelos Exp $	*/
d303 48
d355 4
a358 2
gettdbbyaddr(union sockaddr_union *dst, struct ipsec_policy *ipo,
    struct mbuf *m, int af)
d366 1
a366 1
	hashval = tdb_hash(0, dst, ipo->ipo_sproto);
d369 1
a369 1
		if ((tdbp->tdb_sproto == ipo->ipo_sproto) &&
d372 6
a377 39
			/*
			 * If the IDs are not set, this was probably a
			 * manually-keyed SA, so it can be used for
			 * any type of traffic.
			 */
			if (tdbp->tdb_srcid != NULL) {
				if (ipo->ipo_srcid != NULL &&
				    !ipsp_ref_match(ipo->ipo_srcid,
					tdbp->tdb_srcid))
					continue;
				/* Otherwise, this is fine. */
			}

			if (tdbp->tdb_dstid != NULL) {
				if (ipo->ipo_dstid != NULL &&
				    !ipsp_ref_match(ipo->ipo_dstid,
					tdbp->tdb_dstid))
					continue;
				/* Otherwise, this is fine. */
			}

			/* Check for credential matches. */
			if (tdbp->tdb_local_cred != NULL) {
				if (ipo->ipo_local_cred != NULL &&
				    !ipsp_ref_match(ipo->ipo_local_cred,
					tdbp->tdb_local_cred))
					continue;
			} else if (ipo->ipo_local_cred != NULL)
				continue; /* If no credential was used
					   * in the TDB, try to
					   * establish a new SA with
					   * the given credential,
					   * since some type of access
					   * control may be done on
					   * the other side based on
					   * that credential.
					   */

			/* XXX Check for filter matches. */
d389 4
a392 2
gettdbbysrc(union sockaddr_union *src, struct ipsec_policy *ipo,
    struct mbuf *m, int af)
d400 1
a400 1
	hashval = tdb_hash(0, src, ipo->ipo_sproto);
d403 1
a403 1
		if ((tdbp->tdb_sproto == ipo->ipo_sproto) &&
d406 6
a411 22
			/*
			 * If the IDs are not set, this was probably a
			 * manually-keyed SA, so it can be used for
			 * any type of traffic.
			 */
			if (tdbp->tdb_srcid != NULL) {
				if (ipo->ipo_dstid != NULL &&
				    !ipsp_ref_match(ipo->ipo_dstid,
					tdbp->tdb_srcid))
					continue;
				/* Otherwise, this is fine. */
			}

			if (tdbp->tdb_dstid != NULL) {
				if (ipo->ipo_srcid != NULL &&
				    !ipsp_ref_match(ipo->ipo_srcid,
					tdbp->tdb_dstid))
					continue;
				/* Otherwise, this is fine. */
			}

			/* XXX Check for filter matches. */
@


1.145
log
@Print compression algorithm name too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.144 2001/12/05 10:00:46 deraadt Exp $	*/
d83 7
a89 7
int		ipsp_kern __P((int, char **, int));
u_int8_t	get_sa_require  __P((struct inpcb *));
void		tdb_rehash __P((void));
void		tdb_timeout __P((void *v));
void		tdb_firstuse __P((void *v));
void		tdb_soft_timeout __P((void *v));
void		tdb_soft_firstuse __P((void *v));
@


1.144
log
@KNF whack
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.143 2001/10/03 02:08:41 angelos Exp $	*/
d932 4
@


1.144.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.144 2001/12/05 10:00:46 deraadt Exp $	*/
d83 7
a89 7
int		ipsp_kern(int, char **, int);
u_int8_t	get_sa_require(struct inpcb *);
void		tdb_rehash(void);
void		tdb_timeout(void *v);
void		tdb_firstuse(void *v);
void		tdb_soft_timeout(void *v);
void		tdb_soft_firstuse(void *v);
a302 48
 * Check that credentials and IDs match. Return true if so. The t*
 * range of arguments contains information from TDBs; the p*
 * range of arguments contains information from policies or
 * already established TDBs.
 */
int
ipsp_aux_match(struct ipsec_ref *tsrcid, struct ipsec_ref *psrcid,
    struct ipsec_ref *tdstid, struct ipsec_ref *pdstid,
    struct ipsec_ref *tlcred, struct ipsec_ref *plcred,
    struct ipsec_ref *trcred, struct ipsec_ref *prcred,
    struct sockaddr_encap *tfilter, struct sockaddr_encap *pfilter,
    struct sockaddr_encap *tfiltermask, struct sockaddr_encap *pfiltermask)
{
	if (psrcid != NULL)
		if (tsrcid == NULL || !ipsp_ref_match(tsrcid, psrcid))
			return 0;

	if (pdstid != NULL)
		if (tdstid == NULL || !ipsp_ref_match(tdstid, pdstid))
			return 0;

	if (plcred != NULL)
		if (tlcred == NULL || !ipsp_ref_match(tlcred, plcred))
			return 0;

	if (prcred != NULL)
		if (trcred == NULL || !ipsp_ref_match(trcred, prcred))
			return 0;

	/* Check for filter matches. */
	if (tfilter->sen_type) {
		/*
		 * XXX We should really be doing a subnet-check (see
		 * whether the TDB-associated filter is a subset
		 * of the policy's. For now, an exact match will solve
		 * most problems (all this will do is make every
		 * policy get its own SAs).
		 */
		if (bcmp(tfilter, pfilter, sizeof(struct sockaddr_encap)) ||
		    bcmp(tfiltermask, pfiltermask,
			sizeof(struct sockaddr_encap)))
			return 0;
	}

	return 1;
}

/*
d307 2
a308 4
gettdbbyaddr(union sockaddr_union *dst, u_int8_t sproto,
    struct ipsec_ref *srcid, struct ipsec_ref *dstid,
    struct ipsec_ref *local_cred, struct mbuf *m, int af,
    struct sockaddr_encap *filter, struct sockaddr_encap *filtermask)
d316 1
a316 1
	hashval = tdb_hash(0, dst, sproto);
d319 1
a319 1
		if ((tdbp->tdb_sproto == sproto) &&
d322 39
a360 6
			/* Do IDs and local credentials match ? */
			if (!ipsp_aux_match(tdbp->tdb_srcid, srcid,
			    tdbp->tdb_dstid, dstid, tdbp->tdb_local_cred,
			    local_cred, NULL, NULL, &tdbp->tdb_filter, filter,
			    &tdbp->tdb_filtermask, filtermask))
				continue;
d372 2
a373 4
gettdbbysrc(union sockaddr_union *src, u_int8_t sproto,
    struct ipsec_ref *srcid, struct ipsec_ref *dstid,
    struct mbuf *m, int af, struct sockaddr_encap *filter,
    struct sockaddr_encap *filtermask)
d381 1
a381 1
	hashval = tdb_hash(0, src, sproto);
d384 1
a384 1
		if ((tdbp->tdb_sproto == sproto) &&
d387 22
a408 6
			/* Check whether IDs match */
			if (!ipsp_aux_match(tdbp->tdb_srcid, dstid,
			    tdbp->tdb_dstid, srcid, NULL, NULL, NULL, NULL,
			    &tdbp->tdb_filter, filter, &tdbp->tdb_filtermask,
			    filtermask))
				continue;
a932 4
	if (tdb->tdb_compalgxform)
		l += sprintf(buffer + l, "\t\tCompression = <%s>\n",
		    tdb->tdb_compalgxform->name);

a1232 13
/* Return true if the two structures match. */
int
ipsp_ref_match(struct ipsec_ref *ref1, struct ipsec_ref *ref2)
{
	if (ref1->ref_type != ref2->ref_type ||
	    ref1->ref_len != ref2->ref_len ||
	    bcmp(ref1 + 1, ref2 + 1, ref1->ref_len))
		return 0;

	return 1;
}

#ifdef notyet
d1468 12
a1479 1
#endif /* notyet */
@


1.144.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.144.2.1 2002/06/11 03:31:36 art Exp $	*/
d194 1
a194 1
	if (sproto != IPPROTO_IPCOMP &&
d1216 1
a1216 1

d1231 1
a1231 1

@


1.144.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d851 1
a851 1
ipsp_print_tdb(struct tdb *tdb, char *buffer, size_t buflen)
d853 1
a864 1
	int l, i, k;
d866 16
a881 20
	snprintf(buffer, buflen,
	    "SPI = %08x, Destination = %s, Sproto = %u\n"
	    "\tEstablished %d seconds ago\n"
	    "\tSource = %s",
	    ntohl(tdb->tdb_spi), ipsp_address(tdb->tdb_dst), tdb->tdb_sproto,
	    time.tv_sec - tdb->tdb_established,
	    ipsp_address(tdb->tdb_src));
	l = strlen(buffer);

	if (tdb->tdb_proxy.sa.sa_family) {
		snprintf(buffer + l, buflen - l,
		    ", Proxy = %s", ipsp_address(tdb->tdb_proxy));
		l += strlen(buffer + l);
	}
	snprintf(buffer + l, buflen - l, "\n");
	l += strlen(buffer + l);

	if (tdb->tdb_mtu && tdb->tdb_mtutimeout > time.tv_sec) {
		snprintf(buffer + l, buflen - l,
		    "\tMTU: %d, expires in %llu seconds\n",
a882 2
		l += strlen(buffer + l);
	}
d884 2
a885 3
	if (tdb->tdb_local_cred) {
		snprintf(buffer + l, buflen - l,
		    "\tLocal credential type %d\n",
a886 2
		l += strlen(buffer + l);
	}
d888 2
a889 3
	if (tdb->tdb_remote_cred) {
		snprintf(buffer + l, buflen - l,
		    "\tRemote credential type %d\n",
a890 2
		l += strlen(buffer + l);
	}
d892 2
a893 3
	if (tdb->tdb_local_auth) {
		snprintf(buffer + l, buflen - l,
		    "\tLocal auth type %d\n",
a894 2
		l += strlen(buffer + l);
	}
d896 2
a897 3
	if (tdb->tdb_remote_auth) {
		snprintf(buffer + l, buflen - l,
		    "\tRemote auth type %d\n",
a898 2
		l += strlen(buffer + l);
	}
d900 1
a900 3
	snprintf(buffer + l, buflen - l,
	    "\tFlags (%08x) = <", tdb->tdb_flags);
	l += strlen(buffer + l);
d904 3
a906 4
	    TDBF_SOFT_FIRSTUSE | TDBF_SOFT_ALLOCATIONS)) == 0) {
		snprintf(buffer + l, buflen - l, "none>\n");
		l += strlen(buffer + l);
	} else {
d910 2
a911 3
				snprintf(buffer + l, buflen - l,
				    "%s,", ipspflags[k].ctl_name);
				l += strlen(buffer + l);
d919 1
a919 2
		snprintf(buffer + l, buflen - l, ">\n");
		l += strlen(buffer + l);
d922 1
a922 3
	snprintf(buffer + l, buflen - l,
	    "\tCrypto ID: %llu\n", tdb->tdb_cryptoid);
	l += strlen(buffer + l);
d924 2
a925 3
	if (tdb->tdb_xform) {
		snprintf(buffer + l, buflen - l,
		    "\txform = <%s>\n",
a926 2
		l += strlen(buffer + l);
	}
d928 2
a929 3
	if (tdb->tdb_encalgxform) {
		snprintf(buffer + l, buflen - l,
		    "\t\tEncryption = <%s>\n",
d931 3
a933 5
		l += strlen(buffer + l);
	}
	if (tdb->tdb_authalgxform) {
		snprintf(buffer + l, buflen - l,
		    "\t\tAuthentication = <%s>\n",
d935 3
a937 5
		l += strlen(buffer + l);
	}
	if (tdb->tdb_compalgxform) {
		snprintf(buffer + l, buflen - l,
		    "\t\tCompression = <%s>\n",
d939 3
a941 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_onext) {
		snprintf(buffer + l, buflen - l,
d946 3
a948 5
		l += strlen(buffer + l);
	}
	if (tdb->tdb_inext) {
		snprintf(buffer + l, buflen - l,
		    "\tPrevious SA: SPI = %08x, "
d953 2
a954 4
		l += strlen(buffer + l);
	}
	snprintf(buffer + l, buflen - l,
	    "\t%llu bytes processed by this SA\n",
a955 1
	l += strlen(buffer + l);
d957 2
a958 3
	if (tdb->tdb_last_used) {
		snprintf(buffer + l, buflen - l,
		    "\tLast used %llu seconds ago\n",
a959 2
		l += strlen(buffer + l);
	}
d961 2
a962 2
	if (tdb->tdb_last_marked) {
		snprintf(buffer + l, buflen - l,
a964 2
		l += strlen(buffer + l);
	}
d966 1
a966 3
	snprintf(buffer + l, buflen - l,
	    "\tExpirations:\n");
	l += strlen(buffer + l);
d968 2
a969 2
	if (tdb->tdb_flags & TDBF_TIMER) {
		snprintf(buffer + l, buflen -l,
d972 3
a974 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_SOFT_TIMER) {
		snprintf(buffer + l, buflen -l,
d978 3
a980 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_BYTES) {
		snprintf(buffer + l, buflen -l,
d983 3
a985 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_SOFT_BYTES) {
		snprintf(buffer + l, buflen -l,
d988 3
a990 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_ALLOCATIONS) {
		snprintf(buffer + l, buflen -l,
d993 3
a995 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS) {
		snprintf(buffer + l, buflen -l,
d998 1
a998 2
		l += strlen(buffer + l);
	}
d1000 2
a1001 2
		if (tdb->tdb_first_use) {
			snprintf(buffer + l, buflen -l,
d1005 2
a1006 3
			l += strlen(buffer + l);
		} else {
			snprintf(buffer + l, buflen -l,
a1009 2
			l += strlen(buffer + l);
		}
d1013 2
a1014 2
		if (tdb->tdb_first_use) {
			snprintf(buffer + l, buflen -l,
d1018 2
a1019 3
			l += strlen(buffer + l);
		} else {
			snprintf(buffer + l, buflen -l,
a1021 2
			l += strlen(buffer + l);
		}
d1026 5
a1030 7
	    TDBF_SOFT_ALLOCATIONS | TDBF_ALLOCATIONS |
	    TDBF_SOFT_BYTES | TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE))) {
		snprintf(buffer + l, buflen -l, "\t\t(none)\n");
		l += strlen(buffer + l);
	}
	snprintf(buffer + l, buflen -l, "\n");
	l += strlen(buffer + l);
d1053 1
a1053 2
		l = snprintf(buffer, sizeof buffer,
		    "Hashmask: %d, policy entries: %d\n",
d1066 1
a1066 1
				l = ipsp_print_tdb(tdb, buffer, sizeof buffer);
d1144 1
a1144 2
	snprintf(buf[i], sizeof buf[0], "%d.%d.%d.%d",
	    ucp[0] & 0xff, ucp[1] & 0xff,
d1325 1
a1325 1
						return SLIST_FIRST(&tags);
d1384 1
a1384 1
				return SLIST_FIRST(&tags);
d1402 1
a1402 1
				return SLIST_FIRST(&tags);
d1418 1
a1418 1
					return SLIST_FIRST(&tags);
d1424 1
a1424 1
						return SLIST_FIRST(&tags);
d1432 1
a1432 1
				return SLIST_FIRST(&tags);
d1484 1
a1484 1
			return SLIST_FIRST(&tags); /* We're done. */
@


1.143
log
@If the TDB doesn't have an attached src/dst ID, it can be used for any
type of traffic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.142 2001/09/05 19:22:23 deraadt Exp $	*/
d84 1
a84 1
u_int8_t       	get_sa_require  __P((struct inpcb *));
d111 1
a111 1
	{ XF_IP4,	         0,               "IPv4 Simple Encapsulation",
d431 1
a431 1
		     tdbp = tdbp->tdb_hnext)
d493 1
a493 1
        /* If the TDB hasn't been used, don't renew it. */
d668 1
a668 1
		     tdbpp = tdbpp->tdb_hnext) {
d686 1
a686 1
		     tdbpp = tdbpp->tdb_anext) {
d703 1
a703 1
		     tdbpp = tdbpp->tdb_snext) {
d721 1
a721 1
	     inp = TAILQ_FIRST(&tdbp->tdb_inp_in)) {
d727 1
a727 1
	     inp = TAILQ_FIRST(&tdbp->tdb_inp_out)) {
d734 1
a734 1
	     ipo = TAILQ_FIRST(&tdbp->tdb_policy_head))	{
d851 10
a860 11

	struct ctlname ipspflags[] = { \
				       { "unique", TDBF_UNIQUE }, \
				       { "invalid", TDBF_INVALID }, \
				       { "halfiv", TDBF_HALFIV }, \
				       { "pfs", TDBF_PFS }, \
				       { "tunneling", TDBF_TUNNELING }, \
				       { "noreplay", TDBF_NOREPLAY }, \
				       { "random padding", TDBF_RANDOMPADDING }, \
				       { "skipcrypto", TDBF_SKIPCRYPTO }, \
				       { "usedtunnel", TDBF_USEDTUNNEL }, \
d1138 1
a1138 1
            ucp[2] & 0xff, ucp[3] & 0xff);
d1294 1
a1294 1
			     l = ip6_nexthdr(m, off, proto, &nxtp)) {
@


1.142
log
@use %ll instead of %q
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.141 2001/08/08 15:07:04 jjbg Exp $	*/
d333 1
a333 2
			} else if (ipo->ipo_srcid != NULL)
				continue;
d341 1
a341 2
			} else if (ipo->ipo_dstid != NULL)
				continue;
d398 1
a398 2
			} else if (ipo->ipo_dstid != NULL)
				continue;
d406 1
a406 2
			} else if (ipo->ipo_srcid != NULL)
				continue;
@


1.141
log
@Remove IPCOMP option, it's now part of IPSEC option. You still need to
enable ipcomp via sysctl to use it. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.140 2001/07/05 16:45:54 jjbg Exp $	*/
d883 1
a883 1
		l += sprintf(buffer + l, "\tMTU: %d, expires in %qu seconds\n",
d924 1
a924 1
	l += sprintf(buffer + l, "\tCrypto ID: %qu\n", tdb->tdb_cryptoid);
d952 1
a952 1
	l += sprintf(buffer + l, "\t%qu bytes processed by this SA\n",
d956 1
a956 1
		l += sprintf(buffer + l, "\tLast used %qu seconds ago\n",
d961 1
a961 1
		    "\tLast marked/unmarked %qu seconds ago\n",
d968 1
a968 1
		    "\t\tHard expiration(1) in %qu seconds\n",
d973 1
a973 1
		    "\t\tSoft expiration(1) in %qu seconds\n",
d979 1
a979 1
		    "\t\tHard expiration after %qu bytes\n",
d984 1
a984 1
		    "\t\tSoft expiration after %qu bytes\n",
d1000 1
a1000 1
			    "\t\tHard expiration(2) in %qu seconds\n",
d1005 1
a1005 1
			    "\t\tHard expiration in %qu seconds "
d1013 1
a1013 1
			    "\t\tSoft expiration(2) in %qu seconds\n",
d1018 1
a1018 1
			    "\t\tSoft expiration in %qu seconds "
@


1.140
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.139 2001/06/27 02:32:58 angelos Exp $	*/
a120 1
#ifdef IPCOMP
a123 1
#endif /* IPCOMP */
@


1.139
log
@Minor nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.138 2001/06/27 01:34:07 angelos Exp $	*/
d94 1
d121 5
d196 8
a203 1
	if (tspi < sspi || tspi <= SPI_RESERVED_MAX) {
d211 13
@


1.138
log
@Don't cache packets that hit policies -- we'll do that at the PCB for
local packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.137 2001/06/26 18:34:39 angelos Exp $	*/
d199 1
a199 1
	if (sspi == tspi)   /* Asking for a specific SPI */
d205 1
a205 1
		if (sspi == tspi)  /* Specific SPI asked */
d216 1
a216 1
		/* Check whether we're using this SPI already */
d234 1
a234 1
		/* Setup a "silent" expiration (since TDBF_INVALID's set) */
d299 3
a301 2
			 * If the IDs are not set, this was probably a manually-keyed
			 * SA, so it can be used for any type of traffic.
d308 1
a308 1
				/* Otherwise, this is fine */
d317 1
a317 1
				/* Otherwise, this is fine */
d321 1
a321 1
			/* Check for credential matches */
d338 1
a338 1
			/* XXX Check for filter matches */
d366 3
a368 2
			 * If the IDs are not set, this was probably a manually-keyed
			 * SA, so it can be used for any type of traffic.
d375 1
a375 1
				/* Otherwise, this is fine */
d384 1
a384 1
				/* Otherwise, this is fine */
d388 1
a388 1
			/* XXX Check for filter matches */
d473 1
a473 1
        /* If the TDB hasn't been used, don't renew it */
d487 1
a487 1
	/* Soft expirations */
d500 1
a500 1
	/* If the TDB hasn't been used, don't renew it */
d518 2
a519 2
	MALLOC(new_tdbh, struct tdb **, sizeof(struct tdb *) * (tdb_hashmask + 1),
	    M_TDB, M_WAITOK);
d540 2
a541 1
			hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);
d548 2
a549 1
			hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);
d593 6
a598 5
	 * Rehash if this tdb would cause a bucket to have more than two items
	 * and if the number of tdbs exceed 10% of the bucket count.  This
	 * number is arbitratily chosen and is just a measure to not keep rehashing
	 * when adding and removing tdbs which happens to always end up in the
	 * same bucket, which is not uncommon when doing manual keying.
d699 1
a699 1
	/* Cleanup inp references */
d712 1
a712 1
	/* Cleanup SPD references */
d717 1
a717 1
		ipo->ipo_last_searched = 0; /* Force a re-search */
d720 1
a720 1
	/* Remove expiration timeouts.  */
d781 1
a781 1
	/* Init Incoming SA-Binding Queues */
d787 1
a787 1
	/* Record establishment time */
d791 1
a791 1
	/* Initialize timeouts */
d1164 1
a1164 1
	case 0: /* No family set */
d1237 1
a1237 1
	/* We have to start with a known network protocol */
d1279 1
a1279 1
				/* Construct a tag */
d1316 1
a1316 1
		/* Verify that this has been decrypted */
d1376 1
a1376 1
			/* Verify the self-describing padding values */
d1388 1
a1388 1
		/* Fall through */
d1398 1
a1398 1
			/* Get SPI off the relevant header */
d1419 1
a1419 1
			/* Last network header was IPv6 */
d1438 1
a1438 1
				/* Initialized in IPPROTO_ESP case */
d1445 1
a1445 1
			return tags.slh_first; /* done */
@


1.137
log
@Keep the PFKEY sequence number at the TDB, plus a little bit of KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.136 2001/06/26 03:52:40 angelos Exp $	*/
d183 1
a183 1
    union sockaddr_union *dst, u_int8_t sproto, int *errval, u_int32_t seq)
d189 1
a189 1
	/* Don't accept ranges only encompassing reserved SPIs.  */
d195 1
a195 1
	/* Limit the range to not include reserved areas.  */
d230 1
a230 1
		tdbp->tdb_flags |= TDBF_INVALID; /* Mark SA invalid for now */
a231 1
		tdbp->tdb_seq = seq;
d238 2
a239 1
			timeout_add(&tdbp->tdb_timer_tmo, hz * ipsec_keep_invalid);
a806 5

			/* Clear possible pending acquires */
			if (!err)
				ipsp_clear_acquire(tdbp);

@


1.136
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.135 2001/06/25 05:11:58 angelos Exp $	*/
d183 1
a183 1
    union sockaddr_union *dst, u_int8_t sproto, int *errval)
d232 1
@


1.135
log
@Copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.134 2001/06/24 23:11:45 provos Exp $	*/
d74 1
a74 1
#define DPRINTF(x)	if (encdebug) printf x
d76 1
a76 1
#define DPRINTF(x)
d80 1
a80 1
#define INLINE static __inline
d110 10
a119 10
    { XF_IP4,	         0,               "IPv4 Simple Encapsulation",
      ipe4_attach,       ipe4_init,       ipe4_zeroize,
      (int (*)(struct mbuf *, struct tdb *, int, int))ipe4_input,
      ipip_output, },
    { XF_AH,	 XFT_AUTH,	    "IPsec AH",
      ah_attach,	ah_init,   ah_zeroize,
      ah_input,	 	ah_output, },
    { XF_ESP,	 XFT_CONF|XFT_AUTH, "IPsec ESP",
      esp_attach,	esp_init,  esp_zeroize,
      esp_input,	esp_output, },
d121 4
a124 4
    { XF_TCPSIGNATURE,	 XFT_AUTH, "TCP MD5 Signature Option, RFC 2385",
      tcp_signature_tdb_attach, 	tcp_signature_tdb_init,
      tcp_signature_tdb_zeroize,	tcp_signature_tdb_input,
      tcp_signature_tdb_output, }
d132 2
a133 1
#define TDB_HASHSIZE_INIT 32
d147 19
a165 28
    static u_int32_t mult1 = 0, mult2 = 0;
    u_int8_t *ptr = (u_int8_t *) dst;
    int i, shift;
    u_int64_t hash;
    int val32 = 0;

    while (mult1 == 0)
	mult1 = arc4random();
    while (mult2 == 0)
	mult2 = arc4random();

    hash = (spi ^ proto) * mult1;
    for (i = 0; i < SA_LEN(&dst->sa); i++)
    {
	val32 = (val32 << 8) | ptr[i];
	if (i % 4 == 3)
	{
	    hash ^= val32 * mult2;
	    val32 = 0;
	}
    }

    if (i % 4 != 0)
	hash ^= val32 * mult2;

    shift = ffs(tdb_hashmask + 1);
    while ((hash & ~tdb_hashmask) != 0)
      hash = (hash >> shift) ^ (hash & tdb_hashmask);
d167 8
a174 1
    return hash;
d183 1
a183 1
	    union sockaddr_union *dst, u_int8_t sproto, int *errval)
d185 3
a187 10
    struct tdb *tdbp;
    u_int32_t spi;
    int nums, s;

    /* Don't accept ranges only encompassing reserved SPIs.  */
    if (tspi < sspi || tspi <= SPI_RESERVED_MAX)
    {
	(*errval) = EINVAL;
	return 0;
    }
d189 5
a193 21
    /* Limit the range to not include reserved areas.  */
    if (sspi <= SPI_RESERVED_MAX)
      sspi = SPI_RESERVED_MAX + 1;

    if (sspi == tspi)   /* Asking for a specific SPI */
      nums = 1;
    else
      nums = 100;  /* Arbitrarily chosen */

    while (nums--)
    {
	if (sspi == tspi)  /* Specific SPI asked */
	  spi = tspi;
	else    /* Range specified */
	  spi = sspi + (arc4random() % (tspi - sspi));

	/* Don't allocate reserved SPIs.  */
	if (spi >= SPI_RESERVED_MIN && spi <= SPI_RESERVED_MAX)
	  continue;
	else
	  spi = htonl(spi);
d195 3
a197 4
	/* Check whether we're using this SPI already */
	s = spltdb();
	tdbp = gettdb(spi, dst, sproto);
	splx(s);
d199 4
a202 2
	if (tdbp != (struct tdb *) NULL)
	  continue;
d204 36
a239 1
	tdbp = tdb_alloc();
d241 1
a241 14
	tdbp->tdb_spi = spi;
	bcopy(&dst->sa, &tdbp->tdb_dst.sa, SA_LEN(&dst->sa));
	bcopy(&src->sa, &tdbp->tdb_src.sa, SA_LEN(&src->sa));
	tdbp->tdb_sproto = sproto;
	tdbp->tdb_flags |= TDBF_INVALID;       /* Mark SA as invalid for now */
	tdbp->tdb_satype = SADB_SATYPE_UNSPEC;
	puttdb(tdbp);

	/* Setup a "silent" expiration (since TDBF_INVALID's set) */
	if (ipsec_keep_invalid > 0)
	{
		tdbp->tdb_flags |= TDBF_TIMER;
		tdbp->tdb_exp_timeout = ipsec_keep_invalid;
		timeout_add(&tdbp->tdb_timer_tmo, hz * ipsec_keep_invalid);
d244 2
a245 5
	return spi;
    }

    (*errval) = EEXIST;
    return 0;
d260 2
a261 2
    u_int32_t hashval;
    struct tdb *tdbp;
d263 2
a264 2
    if (tdbh == NULL)
      return (struct tdb *) NULL;
d266 1
a266 1
    hashval = tdb_hash(spi, dst, proto);
d268 5
a272 5
    for (tdbp = tdbh[hashval]; tdbp != NULL; tdbp = tdbp->tdb_hnext)
      if ((tdbp->tdb_spi == spi) &&
	  !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)) &&
	  (tdbp->tdb_sproto == proto))
	break;
d274 1
a274 1
    return tdbp;
d283 1
a283 1
	     struct mbuf *m, int af)
d285 5
a289 2
    u_int32_t hashval;
    struct tdb *tdbp;
d291 1
a291 2
    if (tdbaddr == NULL)
      return (struct tdb *) NULL;
d293 7
a299 56
    hashval = tdb_hash(0, dst, ipo->ipo_sproto);

    for (tdbp = tdbaddr[hashval]; tdbp != NULL; tdbp = tdbp->tdb_anext)
      if ((tdbp->tdb_sproto == ipo->ipo_sproto) &&
	  ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
	  (!bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa))))
      {
	  /*
	   * If the IDs are not set, this was probably a manually-keyed
	   * SA, so it can be used for any type of traffic.
	   */
	  if (tdbp->tdb_srcid != NULL)
	  {
	      if (ipo->ipo_srcid != NULL)
	      {
		  if (!ipsp_ref_match(ipo->ipo_srcid, tdbp->tdb_srcid))
		    continue;
	      }

	      /* Otherwise, this is fine */
	  }
	  else
	    if (ipo->ipo_srcid != NULL)
	      continue;

	  if (tdbp->tdb_dstid != NULL)
	  {
	      if (ipo->ipo_dstid != NULL)
	      {
		  if (!ipsp_ref_match(ipo->ipo_dstid, tdbp->tdb_dstid))
		    continue;
	      }

	      /* Otherwise, this is fine */
	  }
	  else
	    if (ipo->ipo_dstid != NULL)
	      continue;

	  /* Check for credential matches */
	  if (tdbp->tdb_local_cred != NULL)
	  {
	      if (ipo->ipo_local_cred != NULL)
	      {
		  if (!ipsp_ref_match(ipo->ipo_local_cred,
				      tdbp->tdb_local_cred))
		    continue;
	      }
	  }
	  else
	    if (ipo->ipo_local_cred != NULL)
	      continue; /* If no credential was used in the TDB, try
			 * to establish a new SA with the given
			 * credential, since some type of access control
			 * may be done on the other side based on that
			 * credential.
d301 34
d336 3
a338 3
	  /* XXX Check for filter matches */
	  break;
      }
d340 1
a340 1
    return tdbp;
d349 1
a349 1
	    struct mbuf *m, int af)
d351 2
a352 2
    u_int32_t hashval;
    struct tdb *tdbp;
d354 2
a355 2
    if (tdbsrc == NULL)
      return (struct tdb *) NULL;
d357 1
a357 42
    hashval = tdb_hash(0, src, ipo->ipo_sproto);

    for (tdbp = tdbsrc[hashval]; tdbp != NULL; tdbp = tdbp->tdb_snext)
      if ((tdbp->tdb_sproto == ipo->ipo_sproto) &&
	  ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
	  (!bcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa))))
      {
	  /*
	   * If the IDs are not set, this was probably a manually-keyed
	   * SA, so it can be used for any type of traffic.
	   */
	  if (tdbp->tdb_srcid != NULL)
	  {
	      if (ipo->ipo_dstid != NULL)
	      {
		  if (!ipsp_ref_match(ipo->ipo_dstid, tdbp->tdb_srcid))
		    continue;
	      }

	      /* Otherwise, this is fine */
	  }
	  else
	    if (ipo->ipo_dstid != NULL)
	      continue;

	  if (tdbp->tdb_dstid != NULL)
	  {
	      if (ipo->ipo_srcid != NULL)
	      {
		  if (!ipsp_ref_match(ipo->ipo_srcid, tdbp->tdb_dstid))
		    continue;
	      }

	      /* Otherwise, this is fine */
	  }
	  else
	    if (ipo->ipo_srcid != NULL)
	      continue;

	  /* XXX Check for filter matches */
	  break;
      }
d359 31
a389 1
    return tdbp;
d396 16
a411 2
    int i, cnt, buckets[16];
    struct tdb *tdbp;
d413 5
a417 19
    if (tdbh == NULL)
    {
	db_printf("no tdb hash table\n");
	return;
    }

    bzero (buckets, sizeof(buckets));
    for (i = 0; i <= tdb_hashmask; i++)
    {
	cnt = 0;
	for (tdbp = tdbh[i]; cnt < 16 && tdbp != NULL; tdbp = tdbp->tdb_hnext)
	  cnt++;
	buckets[cnt]++;
    }

    db_printf("tdb cnt\t\tbucket cnt\n");
    for (i = 0; i < 16; i++)
      if (buckets[i] > 0)
	db_printf("%d%c\t\t%d\n", i, i == 15 ? "+" : "", buckets[i]);
d427 2
a428 2
    int i, rval = 0;
    struct tdb *tdbp, *next;
d430 2
a431 2
    if (tdbh == NULL)
        return ENOENT;
d433 8
a440 9
    for (i = 0; i <= tdb_hashmask; i++)
      for (tdbp = tdbh[i]; rval == 0 && tdbp != NULL; tdbp = next)
      {
	  next = tdbp->tdb_hnext;
	  if (i == tdb_hashmask && next == NULL)
	    rval = walker(tdbp, (void *)arg, 1);
	  else
	    rval = walker(tdbp, (void *)arg, 0);
      }
d442 1
a442 1
    return rval;
d509 40
a548 44
    struct tdb **new_tdbh, **new_tdbaddr, **new_srcaddr, *tdbp, *tdbnp;
    u_int i, old_hashmask = tdb_hashmask;
    u_int32_t hashval;

    tdb_hashmask = (tdb_hashmask << 1) | 1;

    MALLOC(new_tdbh, struct tdb **, sizeof(struct tdb *) * (tdb_hashmask + 1),
	   M_TDB, M_WAITOK);
    MALLOC(new_tdbaddr, struct tdb **,
	   sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);
    MALLOC(new_srcaddr, struct tdb **,
	   sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);

    bzero(new_tdbh, sizeof(struct tdb *) * (tdb_hashmask + 1));
    bzero(new_tdbaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));
    bzero(new_srcaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));

    for (i = 0; i <= old_hashmask; i++)
    {
	for (tdbp = tdbh[i]; tdbp != NULL; tdbp = tdbnp)
	{
	    tdbnp = tdbp->tdb_hnext;
	    hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst,
			       tdbp->tdb_sproto);
	    tdbp->tdb_hnext = new_tdbh[hashval];
	    new_tdbh[hashval] = tdbp;
	}

	for (tdbp = tdbaddr[i]; tdbp != NULL; tdbp = tdbnp)
	{
	    tdbnp = tdbp->tdb_anext;
	    hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);
	    tdbp->tdb_anext = new_tdbaddr[hashval];
	    new_tdbaddr[hashval] = tdbp;
	}

	for (tdbp = tdbsrc[i]; tdbp != NULL; tdbp = tdbnp)
	{
	    tdbnp = tdbp->tdb_snext;
	    hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);
	    tdbp->tdb_snext = new_srcaddr[hashval];
	    new_srcaddr[hashval] = tdbp;
	}
    }
d550 2
a551 2
    FREE(tdbh, M_TDB);
    tdbh = new_tdbh;
d553 2
a554 2
    FREE(tdbaddr, M_TDB);
    tdbaddr = new_tdbaddr;
d556 2
a557 2
    FREE(tdbsrc, M_TDB);
    tdbsrc = new_srcaddr;
d566 18
a583 2
    u_int32_t hashval;
    int s = spltdb();
a584 29
    if (tdbh == NULL)
    {
	MALLOC(tdbh, struct tdb **, sizeof(struct tdb *) * (tdb_hashmask + 1),
	       M_TDB, M_WAITOK);
	MALLOC(tdbaddr, struct tdb **,
	       sizeof(struct tdb *) * (tdb_hashmask + 1),
	       M_TDB, M_WAITOK);
	MALLOC(tdbsrc, struct tdb **,
	       sizeof(struct tdb *) * (tdb_hashmask + 1),
	       M_TDB, M_WAITOK);

	bzero(tdbh, sizeof(struct tdb *) * (tdb_hashmask + 1));
	bzero(tdbaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));
	bzero(tdbsrc, sizeof(struct tdb *) * (tdb_hashmask + 1));
    }

    hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst, tdbp->tdb_sproto);

    /*
     * Rehash if this tdb would cause a bucket to have more than two items
     * and if the number of tdbs exceed 10% of the bucket count.  This
     * number is arbitratily chosen and is just a measure to not keep rehashing
     * when adding and removing tdbs which happens to always end up in the
     * same bucket, which is not uncommon when doing manual keying.
     */
    if (tdbh[hashval] != NULL && tdbh[hashval]->tdb_hnext != NULL &&
	tdb_count * 10 > tdb_hashmask + 1)
    {
	tdb_rehash();
a585 1
    }
d587 16
a602 2
    tdbp->tdb_hnext = tdbh[hashval];
    tdbh[hashval] = tdbp;
d604 3
a606 3
    hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);
    tdbp->tdb_anext = tdbaddr[hashval];
    tdbaddr[hashval] = tdbp;
d608 3
a610 3
    hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);
    tdbp->tdb_snext = tdbsrc[hashval];
    tdbsrc[hashval] = tdbp;
d612 1
a612 1
    tdb_count++;
d614 1
a614 1
    ipsec_last_added = time.tv_sec;
d616 1
a616 1
    splx(s);
d625 27
a651 138
    struct ipsec_policy *ipo;
    struct tdb *tdbpp;
    struct inpcb *inp;
    u_int32_t hashval;
    int s;

    if (tdbh == NULL)
      return;

    hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst, tdbp->tdb_sproto);

    s = spltdb();
    if (tdbh[hashval] == tdbp)
    {
	tdbpp = tdbp;
	tdbh[hashval] = tdbp->tdb_hnext;
    }
    else
      for (tdbpp = tdbh[hashval]; tdbpp != NULL; tdbpp = tdbpp->tdb_hnext)
	if (tdbpp->tdb_hnext == tdbp)
	{
	    tdbpp->tdb_hnext = tdbp->tdb_hnext;
	    tdbpp = tdbp;
	    break;
	}

    tdbp->tdb_hnext = NULL;

    hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);

    if (tdbaddr[hashval] == tdbp)
    {
	tdbpp = tdbp;
	tdbaddr[hashval] = tdbp->tdb_anext;
    }
    else
      for (tdbpp = tdbaddr[hashval]; tdbpp != NULL; tdbpp = tdbpp->tdb_anext)
	if (tdbpp->tdb_anext == tdbp)
	{
	    tdbpp->tdb_anext = tdbp->tdb_anext;
	    tdbpp = tdbp;
	    break;
	}

    hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);

    if (tdbsrc[hashval] == tdbp)
    {
	tdbpp = tdbp;
	tdbsrc[hashval] = tdbp->tdb_snext;
    }
    else
      for (tdbpp = tdbsrc[hashval]; tdbpp != NULL; tdbpp = tdbpp->tdb_snext)
	if (tdbpp->tdb_snext == tdbp)
	{
	    tdbpp->tdb_snext = tdbp->tdb_snext;
	    tdbpp = tdbp;
	    break;
	}

    tdbp->tdb_snext = NULL;

    if (tdbp->tdb_xform)
    {
      	(*(tdbp->tdb_xform->xf_zeroize))(tdbp);
	tdbp->tdb_xform = NULL;
    }

    /* Cleanup inp references */
    for (inp = TAILQ_FIRST(&tdbp->tdb_inp_in); inp;
	 inp = TAILQ_FIRST(&tdbp->tdb_inp_in))
    {
        TAILQ_REMOVE(&tdbp->tdb_inp_in, inp, inp_tdb_in_next);
	inp->inp_tdb_in = NULL;
    }

    for (inp = TAILQ_FIRST(&tdbp->tdb_inp_out); inp;
	 inp = TAILQ_FIRST(&tdbp->tdb_inp_out))
    {
        TAILQ_REMOVE(&tdbp->tdb_inp_out, inp, inp_tdb_out_next);
	inp->inp_tdb_out = NULL;
    }

    /* Cleanup SPD references */
    for (ipo = TAILQ_FIRST(&tdbp->tdb_policy_head); ipo;
	 ipo = TAILQ_FIRST(&tdbp->tdb_policy_head))
    {
	TAILQ_REMOVE(&tdbp->tdb_policy_head, ipo, ipo_tdb_next);
	ipo->ipo_tdb = NULL;
	ipo->ipo_last_searched = 0; /* Force a re-search */
    }

    /* Remove expiration timeouts.  */
    tdbp->tdb_flags &= ~(TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE | TDBF_TIMER |
			 TDBF_SOFT_TIMER);
    timeout_del(&tdbp->tdb_timer_tmo);
    timeout_del(&tdbp->tdb_first_tmo);
    timeout_del(&tdbp->tdb_stimer_tmo);
    timeout_del(&tdbp->tdb_sfirst_tmo);

    if (tdbp->tdb_local_auth)
    {
	ipsp_reffree(tdbp->tdb_local_auth);
	tdbp->tdb_local_auth = NULL;
    }

    if (tdbp->tdb_remote_auth)
    {
	ipsp_reffree(tdbp->tdb_remote_auth);
	tdbp->tdb_remote_auth = NULL;
    }

    if (tdbp->tdb_srcid)
    {
	ipsp_reffree(tdbp->tdb_srcid);
	tdbp->tdb_srcid = NULL;
    }

    if (tdbp->tdb_dstid)
    {
	ipsp_reffree(tdbp->tdb_dstid);
	tdbp->tdb_dstid = NULL;
    }

    if (tdbp->tdb_local_cred)
    {
	ipsp_reffree(tdbp->tdb_local_cred);
	tdbp->tdb_local_cred = NULL;
    }

    if (tdbp->tdb_remote_cred)
    {
	ipsp_reffree(tdbp->tdb_remote_cred);
	tdbp->tdb_local_cred = NULL;
    }

    if ((tdbp->tdb_onext) && (tdbp->tdb_onext->tdb_inext == tdbp))
      tdbp->tdb_onext->tdb_inext = NULL;
d653 1
a653 2
    if ((tdbp->tdb_inext) && (tdbp->tdb_inext->tdb_onext == tdbp))
      tdbp->tdb_inext->tdb_onext = NULL;
d655 15
a669 2
    FREE(tdbp, M_TDB);
    tdb_count--;
d671 91
a761 1
    splx(s);
d800 2
a801 2
    struct xformsw *xsp;
    int err;
d803 7
a809 15
    for (xsp = xformsw; xsp < xformswNXFORMSW; xsp++)
      if (xsp->xf_type == alg)
      {
	  err = (*(xsp->xf_init))(tdbp, xsp, ii);

	  /* Clear possible pending acquires */
	  if (!err)
	    ipsp_clear_acquire(tdbp);

	  return err;
      }

    DPRINTF(("tdb_init(): no alg %d for spi %08x, addr %s, proto %d\n",
	     alg, ntohl(tdbp->tdb_spi), ipsp_address(tdbp->tdb_dst),
	     tdbp->tdb_sproto));
d811 9
a819 1
    return EINVAL;
d824 1
a824 1
 * Used by kernfs.
d827 1
a827 1
ipsp_kern(int off, char **bufp, int len)
d829 1
a829 45
    static char buffer[IPSEC_KERNFS_BUFSIZE];
    struct tdb *tdb;
    int l, i, s, k;

    struct ctlname ipspflags[] = { \
				   { "unique", TDBF_UNIQUE }, \
				   { "invalid", TDBF_INVALID }, \
				   { "halfiv", TDBF_HALFIV }, \
				   { "pfs", TDBF_PFS }, \
				   { "tunneling", TDBF_TUNNELING }, \
				   { "noreplay", TDBF_NOREPLAY }, \
				   { "random padding", TDBF_RANDOMPADDING }, \
				   { "skipcrypto", TDBF_SKIPCRYPTO }, \
				   { "usedtunnel", TDBF_USEDTUNNEL }, \
				};

    if (bufp == NULL)
      return 0;

    bzero(buffer, IPSEC_KERNFS_BUFSIZE);
    *bufp = buffer;

    if (off == 0)
    {
        kernfs_epoch++;
        l = sprintf(buffer, "Hashmask: %d, policy entries: %d\n", tdb_hashmask,
                    ipsec_in_use);
       return l;
    }

    if (tdbh == NULL)
      return 0;

    for (i = 0; i <= tdb_hashmask; i++)
    {
        s = spltdb();
	for (tdb = tdbh[i]; tdb; tdb = tdb->tdb_hnext)
	  if (tdb->tdb_epoch != kernfs_epoch)
	  {
	      tdb->tdb_epoch = kernfs_epoch;

	      l = sprintf(buffer,
			  "SPI = %08x, Destination = %s, Sproto = %u\n",
			  ntohl(tdb->tdb_spi),
			  ipsp_address(tdb->tdb_dst), tdb->tdb_sproto);
d831 14
a844 2
	      l += sprintf(buffer + l, "\tEstablished %d seconds ago\n",
			   time.tv_sec - tdb->tdb_established);
d846 2
a847 2
	      l += sprintf(buffer + l, "\tSource = %s",
			   ipsp_address(tdb->tdb_src));
d849 3
a851 1
	      if (tdb->tdb_proxy.sa.sa_family)
d853 2
a854 2
			     ipsp_address(tdb->tdb_proxy));
	      else
d857 25
a881 24
	      if (tdb->tdb_mtu && tdb->tdb_mtutimeout > time.tv_sec)
		l += sprintf(buffer + l,
			     "\tMTU: %d, expires in %qu seconds\n",
			      tdb->tdb_mtu, tdb->tdb_mtutimeout - time.tv_sec);

	      if (tdb->tdb_local_cred)
		l += sprintf(buffer + l, "\tLocal credential type %d\n", ((struct ipsec_ref *) tdb->tdb_local_cred)->ref_type);

	      if (tdb->tdb_remote_cred)
		l += sprintf(buffer + l, "\tRemote credential type %d\n", ((struct ipsec_ref *) tdb->tdb_remote_cred)->ref_type);

	      if (tdb->tdb_local_auth)
		l += sprintf(buffer + l, "\tLocal auth type %d\n", ((struct ipsec_ref *) tdb->tdb_local_auth)->ref_type);

	      if (tdb->tdb_remote_auth)
		l += sprintf(buffer + l, "\tRemote auth type %d\n", ((struct ipsec_ref *) tdb->tdb_remote_auth)->ref_type);

	      l += sprintf(buffer + l, "\tFlags (%08x) = <", tdb->tdb_flags);

	      if ((tdb->tdb_flags & ~(TDBF_TIMER | TDBF_BYTES |
				      TDBF_ALLOCATIONS | TDBF_FIRSTUSE |
				      TDBF_SOFT_TIMER | TDBF_SOFT_BYTES |
				      TDBF_SOFT_FIRSTUSE |
				      TDBF_SOFT_ALLOCATIONS)) == 0)
d883 1
a883 3
	      else
	      {
		  /* We can reuse variable 'i' here, since we're not looping */
d885 7
a891 11
		     k < sizeof(ipspflags) / sizeof(struct ctlname); k++)
		  if (tdb->tdb_flags & ipspflags[k].ctl_type)
		  {
		      l += sprintf(buffer + l, "%s,", ipspflags[k].ctl_name);
		      i = 1;
		  }

		  if (i) /* If we added flags, remove trailing comma */
		    l--;
		  l += sprintf(buffer + l, ">\n");
	      }
d893 5
a897 1
	      l += sprintf(buffer + l, "\tCrypto ID: %qu\n", tdb->tdb_cryptoid);
d899 3
a901 1
	      if (tdb->tdb_xform)
d903 1
a903 1
			     tdb->tdb_xform->xf_name);
d905 1
a905 1
	      if (tdb->tdb_encalgxform)
d907 1
a907 1
			     tdb->tdb_encalgxform->name);
d909 1
a909 1
	      if (tdb->tdb_authalgxform)
d911 1
a911 9
			     tdb->tdb_authalgxform->name);

	      if (tdb->tdb_onext)
		l += sprintf(buffer + l,
			     "\tNext SA: SPI = %08x, "
			     "Destination = %s, Sproto = %u\n",
			     ntohl(tdb->tdb_onext->tdb_spi),
			     ipsp_address(tdb->tdb_onext->tdb_dst),
			     tdb->tdb_onext->tdb_sproto);
d913 1
a913 1
	      if (tdb->tdb_inext)
d915 11
a925 5
			     "\tPrevious SA: SPI = %08x, "
			     "Destination = %s, Sproto = %u\n",
			     ntohl(tdb->tdb_inext->tdb_spi),
			     ipsp_address(tdb->tdb_inext->tdb_dst),
			     tdb->tdb_inext->tdb_sproto);
d927 2
a928 2
	      l += sprintf(buffer + l, "\t%qu bytes processed by this SA\n",
			 tdb->tdb_cur_bytes);
d930 1
a930 1
	      if (tdb->tdb_last_used)
d932 1
a932 1
			     time.tv_sec - tdb->tdb_last_used);
d934 4
a937 4
	      if (tdb->tdb_last_marked)
		l += sprintf(buffer + l, 
			     "\tLast marked/unmarked %qu seconds ago\n",
			     time.tv_sec - tdb->tdb_last_marked);
d939 1
a939 1
	      l += sprintf(buffer + l, "\tExpirations:\n");
d941 1
a941 1
	      if (tdb->tdb_flags & TDBF_TIMER)
d943 2
a944 3
			     "\t\tHard expiration(1) in %qu seconds\n",
			     tdb->tdb_established + tdb->tdb_exp_timeout -
			     time.tv_sec);
d946 1
a946 1
	      if (tdb->tdb_flags & TDBF_SOFT_TIMER)
d948 3
a950 3
			     "\t\tSoft expiration(1) in %qu seconds\n",
			     tdb->tdb_established + tdb->tdb_soft_timeout -
			     time.tv_sec);
d952 1
a952 1
	      if (tdb->tdb_flags & TDBF_BYTES)
d954 2
a955 2
			     "\t\tHard expiration after %qu bytes\n",
			     tdb->tdb_exp_bytes);
d957 1
a957 1
	      if (tdb->tdb_flags & TDBF_SOFT_BYTES)
d959 2
a960 2
			     "\t\tSoft expiration after %qu bytes\n",
			     tdb->tdb_soft_bytes);
d962 1
a962 1
	      if (tdb->tdb_flags & TDBF_ALLOCATIONS)
d964 2
a965 2
			     "\t\tHard expiration after %u flows\n",
			     tdb->tdb_exp_allocations);
d967 1
a967 1
	      if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS)
d969 2
a970 2
			     "\t\tSoft expiration after %u flows\n",
			     tdb->tdb_soft_allocations);
d972 29
a1000 32
	      if (tdb->tdb_flags & TDBF_FIRSTUSE)
	      {
		  if (tdb->tdb_first_use)
		    l += sprintf(buffer + l,
				 "\t\tHard expiration(2) in %qu seconds\n",
				 (tdb->tdb_first_use +
				  tdb->tdb_exp_first_use) - time.tv_sec);
		  else
		    l += sprintf(buffer + l,
				 "\t\tHard expiration in %qu seconds "
				 "after first use\n",
				 tdb->tdb_exp_first_use);
	      }

	      if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
	      {
		  if (tdb->tdb_first_use)
		    l += sprintf(buffer + l,
				 "\t\tSoft expiration(2) in %qu seconds\n",
				 (tdb->tdb_first_use +
				  tdb->tdb_soft_first_use) - time.tv_sec);
		  else
		    l += sprintf(buffer + l,
				 "\t\tSoft expiration in %qu seconds "
				 "after first use\n",
				 tdb->tdb_soft_first_use);
	      }

	      if (!(tdb->tdb_flags &
		    (TDBF_TIMER | TDBF_SOFT_TIMER | TDBF_BYTES |
		     TDBF_SOFT_ALLOCATIONS | TDBF_ALLOCATIONS |
		     TDBF_SOFT_BYTES | TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE)))
d1003 1
a1003 1
	      l += sprintf(buffer + l, "\n");
d1005 42
a1046 6
	      splx(s);
	      return l;
	  }
	splx(s);
    }
    return 0;
d1056 1
a1056 1
    u_int8_t sareq = 0;
d1058 15
a1072 18
    if (inp != NULL)
    {
	sareq |= inp->inp_seclevel[SL_AUTH] >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_AUTH : 0;
	sareq |= inp->inp_seclevel[SL_ESP_TRANS] >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_CONF : 0;
	sareq |= inp->inp_seclevel[SL_ESP_NETWORK] >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_TUNNEL : 0;
    }
    else
    {
	sareq |= ipsec_auth_default_level >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_AUTH : 0;
	sareq |= ipsec_esp_trans_default_level >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_CONF : 0;
	sareq |= ipsec_esp_network_default_level >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_TUNNEL : 0;
    }
d1074 1
a1074 1
    return (sareq);
d1083 23
a1105 27
    if (inout)
    {
        if (inp->inp_tdb_in)
        {
	    if (inp->inp_tdb_in == tdb)
              return;

	    TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp, inp_tdb_in_next);
        }

        inp->inp_tdb_in = tdb;
        TAILQ_INSERT_TAIL(&tdb->tdb_inp_in, inp, inp_tdb_in_next);
    }
    else
    {
        if (inp->inp_tdb_out)
        {
	    if (inp->inp_tdb_out == tdb)
              return;

	    TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out, inp,
			 inp_tdb_out_next);
        }

        inp->inp_tdb_out = tdb;
        TAILQ_INSERT_TAIL(&tdb->tdb_inp_out, inp, inp_tdb_out_next);
    }
d1112 3
a1114 3
    static char buf[4][4 * sizeof "123" + 4];
    unsigned char *ucp = (unsigned char *) &ina;
    static int i = 3;
d1116 2
a1117 2
    i = (i + 1) % 4;
    sprintf(buf[i], "%d.%d.%d.%d", ucp[0] & 0xff, ucp[1] & 0xff,
d1119 1
a1119 1
    return (buf[i]);
d1126 1
a1126 2
    switch (sa.sa.sa_family)
    {
d1129 1
a1129 1
	    return inet_ntoa4(sa.sin.sin_addr);
d1134 1
a1134 1
	    return ip6_sprintf(&sa.sin6.sin6_addr);
d1138 2
a1139 2
	    return "(unknown address family)";
    }
d1146 1
a1146 2
    switch (addr.sa.sa_family)
    {
d1149 4
a1152 4
	    if (addr.sin.sin_addr.s_addr == INADDR_ANY)
	      return 1;
	    else
	      return 0;
d1157 4
a1160 4
	    if (IN6_IS_ADDR_UNSPECIFIED(&addr.sin6.sin6_addr))
	      return 1;
	    else
	      return 0;
d1165 2
a1166 2
	    return 1;
    }
d1174 4
a1177 2
    if (ipr->ref_count <= 0)
      printf("ipsp_reffree: illegal reference count %d for object %p (len = %d, malloctype = %d)\n", ipr->ref_count, ipr, ipr->ref_len, ipr->ref_malloctype);
d1179 2
a1180 2
    if (--ipr->ref_count <= 0)
      FREE(ipr, ipr->ref_malloctype);
d1187 2
a1188 2
    struct tdb *tdb;
    int s = spltdb();
d1190 6
a1195 7
    tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
    if (tdb != NULL)
    {
	tdb->tdb_flags |= TDBF_SKIPCRYPTO;
	tdb->tdb_last_marked = time.tv_sec;
    }
    splx(s);
d1202 2
a1203 2
    struct tdb *tdb;
    int s = spltdb();
d1205 6
a1210 7
    tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
    if (tdb != NULL)
    {
	tdb->tdb_flags &= ~TDBF_SKIPCRYPTO;
	tdb->tdb_last_marked = time.tv_sec;
    }
    splx(s);
d1221 6
a1226 6
    int ipv4sa = 0, s, esphlen = 0, trail = 0, i;
    SLIST_HEAD(packet_tags, m_tag) tags;
    unsigned char lasteight[8];
    struct tdb_ident *tdbi;
    struct m_tag *mtag;
    struct tdb *tdb;
d1229 1
a1229 1
    struct ip iph;
d1233 1
a1233 1
    struct in6_addr ip6_dst;
d1236 8
a1243 10
    /* We have to start with a known network protocol */
    if (proto != IPPROTO_IPV4 && proto != IPPROTO_IPV6)
      return NULL;

    SLIST_INIT(&tags);

    while (1)
    {
	switch (proto)
	{
d1245 12
a1256 9
	    case IPPROTO_IPV4: /* Also IPPROTO_IPIP */
	    {
		/* Save the IP header (we need both the address and ip_hl) */
		m_copydata(m, off, sizeof(struct ip), (caddr_t) &iph);
		ipv4sa = 1;
		proto = iph.ip_p;
		off += iph.ip_hl << 2;
		break;
	    }
d1260 1
a1260 15
	    case IPPROTO_IPV6:
	    {
		int nxtp, l;

		/* Copy the IPv6 address */
		m_copydata(m, off + offsetof(struct ip6_hdr, ip6_dst),
			   sizeof(struct ip6_hdr), (caddr_t) &ip6_dst);
		ipv4sa = 0;

		/*
		 * Go down the chain of headers until we encounter a
		 * non-option.
		 */
		for (l = ip6_nexthdr(m, off, proto, &nxtp); l != -1;
		     l = ip6_nexthdr(m, off, proto, &nxtp))
d1262 1
a1262 2
		    off += l;
		    proto = nxtp;
d1264 4
a1267 7
		    /* Construct a tag */
		    if (nxtp == IPPROTO_AH)
		    {
			mtag = m_tag_get(PACKET_TAG_IPSEC_IN_CRYPTO_DONE,
					 sizeof(struct tdb_ident), M_NOWAIT);
			if (mtag == NULL)
			  return tags.slh_first;
d1269 42
a1310 14
			tdbi = (struct tdb_ident *) (mtag + 1);
			bzero(tdbi, sizeof(struct tdb_ident));
			m_copydata(m, off + sizeof(u_int32_t),
				   sizeof(u_int32_t), (caddr_t) &tdbi->spi);
			tdbi->proto = IPPROTO_AH;
			tdbi->dst.sin6.sin6_family = AF_INET6;
			tdbi->dst.sin6.sin6_len = sizeof(struct sockaddr_in6);
			tdbi->dst.sin6.sin6_addr = ip6_dst;
			SLIST_INSERT_HEAD(&tags, mtag, m_tag_link);
		    }
		    else
		      if (nxtp == IPPROTO_IPV6)
			m_copydata(m, off + offsetof(struct ip6_hdr, ip6_dst),
				   sizeof(struct ip6_hdr), (caddr_t) &ip6_dst);
a1311 2
		break;
	    }
d1314 1
a1314 1
	    case IPPROTO_ESP:
d1317 2
a1318 2
		    union sockaddr_union su;
		    u_int32_t spi;
d1320 2
a1321 2
		    m_copydata(m, off, sizeof(u_int32_t), (caddr_t) &spi);
		    bzero(&su, sizeof(union sockaddr_union));
d1323 1
a1323 1
		    s = spltdb();
d1326 5
a1330 6
		    if (ipv4sa)
		    {
			su.sin.sin_family = AF_INET;
			su.sin.sin_len = sizeof(struct sockaddr_in);
			su.sin.sin_addr = iph.ip_dst;
		    }
d1334 5
a1338 6
		    if (!ipv4sa)
		    {
			su.sin6.sin6_family = AF_INET6;
			su.sin6.sin6_len = sizeof(struct sockaddr_in6);
			su.sin6.sin6_addr = ip6_dst;
		    }
d1341 27
a1367 6
		    tdb = gettdb(spi, &su, IPPROTO_ESP);
		    if (tdb == NULL)
		    {
			splx(s);
			return tags.slh_first;
		    }
a1368 13
		    /* How large is the ESP header ? We use this later */
		    if (tdb->tdb_flags & TDBF_NOREPLAY)
		      esphlen = sizeof(u_int32_t) + tdb->tdb_ivlen;
		    else
		      esphlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen;

		    /*
		     * Verify decryption. If the SA is using random padding
		     * (as the "old" ESP SAs were bound to do, there's nothing
		     * we can do to see if the payload has been decrypted.
		     */
		    if (tdb->tdb_flags & TDBF_RANDOMPADDING)
		    {
a1369 2
			return tags.slh_first;
		    }
d1371 15
a1385 19
		    /* Update the length of trailing ESP authenticators */
		    if (tdb->tdb_authalgxform)
		      trail += AH_HMAC_HASHLEN;

		    splx(s);

		    /* Copy the last 10 bytes */
		    m_copydata(m, m->m_pkthdr.len - trail - 8, 8, lasteight);

		    /* Verify the self-describing padding values */
		    if (lasteight[6] != 0)
		    {
			if (lasteight[6] != lasteight[5])
			  return tags.slh_first;

			for (i = 4; lasteight[i + 1] != 1 && i >= 0; i--)
			  if (lasteight[i + 1] != lasteight[i] + 1)
			    return tags.slh_first;
		    }
d1388 16
a1403 15
	    case IPPROTO_AH:
		mtag = m_tag_get(PACKET_TAG_IPSEC_IN_CRYPTO_DONE,
				 sizeof(struct tdb_ident), M_NOWAIT);
		if (mtag == NULL)
		  return tags.slh_first;

		tdbi = (struct tdb_ident *) (mtag + 1);
		bzero(tdbi, sizeof(struct tdb_ident));

		/* Get SPI off the relevant header */
		if (proto == IPPROTO_AH)
		  m_copydata(m, off + sizeof(u_int32_t), sizeof(u_int32_t),
			     (caddr_t) &tdbi->spi);
		else /* IPPROTO_ESP */
		  m_copydata(m, off, sizeof(u_int32_t), (caddr_t) &tdbi->spi);
d1405 1
a1405 1
		tdbi->proto = proto; /* We can get here for AH or ESP */
d1408 7
a1414 7
		/* Last network header was IPv4 */
		if (ipv4sa)
		{
		    tdbi->dst.sin.sin_family = AF_INET;
		    tdbi->dst.sin.sin_len = sizeof(struct sockaddr_in);
		    tdbi->dst.sin.sin_addr = iph.ip_dst;
		}
d1418 7
a1424 7
		/* Last network header was IPv6 */
		if (!ipv4sa)
		{
		    tdbi->dst.sin6.sin6_family = AF_INET6;
		    tdbi->dst.sin6.sin6_len = sizeof(struct sockaddr_in6);
		    tdbi->dst.sin6.sin6_addr = ip6_dst;
		}
d1427 1
a1427 1
		SLIST_INSERT_HEAD(&tags, mtag, m_tag_link);
d1429 13
a1441 4
		/* Update next protocol/header and header offset */
		if (proto == IPPROTO_AH)
		{
		    u_int8_t foo[2];
d1443 2
a1444 9
		    m_copydata(m, off, 2 * sizeof(u_int8_t), foo);
		    proto = foo[0];
		    off += (foo[1] + 2) << 2;
		}
		else /* IPPROTO_ESP */
		{
		    /* Initialized in IPPROTO_ESP case */
		    off += esphlen;
		    proto = lasteight[7];
a1445 4
		break;

	    default:
		return tags.slh_first; /* done */
a1446 1
    }
d1453 4
a1456 4
    if (ref1->ref_type != ref2->ref_type ||
	ref1->ref_len != ref2->ref_len ||
	bcmp(ref1 + 1, ref2 + 1, ref1->ref_len))
      return 0;
d1458 1
a1458 1
    return 1;
a1459 1

@


1.134
log
@print mtu of tdb if discovered
@
text
@d1 1
a1 2
/*	$OpenBSD: ip_ipsp.c,v 1.133 2001/06/24 21:14:33 angelos Exp $	*/

d22 1
d24 1
a24 1
 * Permission to use, copy, and modify this software without fee
@


1.133
log
@Print TDBF_USEDTUNNEL in ipsp_kern()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.132 2001/06/23 04:39:34 angelos Exp $	*/
d928 5
@


1.132
log
@Having to update queue(3) for DLIST_* is a major PITA; thus, just use
SLIST and be done with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.131 2001/06/23 04:01:57 angelos Exp $	*/
d884 1
@


1.131
log
@Use DLIST for tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.130 2001/06/08 03:13:14 angelos Exp $	*/
d1266 1
a1266 1
    DLIST_HEAD(packet_tags, m_tag) tags;
d1284 1
a1284 1
    DLIST_INIT(&tags);
d1328 1
a1328 1
			  return tags.dh_first;
d1338 1
a1338 1
			DLIST_INSERT_HEAD(&tags, mtag, m_tag_link);
d1382 1
a1382 1
			return tags.dh_first;
d1399 1
a1399 1
			return tags.dh_first;
d1415 1
a1415 1
			  return tags.dh_first;
d1419 1
a1419 1
			    return tags.dh_first;
d1427 1
a1427 1
		  return tags.dh_first;
d1461 1
a1461 1
		DLIST_INSERT_HEAD(&tags, mtag, m_tag_link);
d1481 1
a1481 1
		return tags.dh_first; /* done */
@


1.130
log
@Trim include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.129 2001/06/07 16:19:47 angelos Exp $	*/
d1266 1
a1266 1
    LIST_HEAD(packet_tags, m_tag) tags;
d1284 1
a1284 1
    LIST_INIT(&tags);
d1328 1
a1328 1
			  return tags.lh_first;
d1338 1
a1338 1
			LIST_INSERT_HEAD(&tags, mtag, m_tag_link);
d1382 1
a1382 1
			return tags.lh_first;
d1399 1
a1399 1
			return tags.lh_first;
d1415 1
a1415 1
			  return tags.lh_first;
d1419 1
a1419 1
			    return tags.lh_first;
d1427 1
a1427 1
		  return tags.lh_first;
d1461 1
a1461 1
		LIST_INSERT_HEAD(&tags, mtag, m_tag_link);
d1481 1
a1481 1
		return tags.lh_first; /* done */
@


1.129
log
@Simplify SPD logic (and correct some input cases).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.128 2001/06/05 11:31:31 angelos Exp $	*/
a40 2
#include <sys/systm.h>
#include <sys/malloc.h>
a42 1
#include <sys/errno.h>
a43 1
#include <sys/queue.h>
a51 1
#include <netinet/ip_var.h>
d63 1
a64 3

#include <netinet/ip_ipsp.h>

a65 1

@


1.128
log
@That DPRINTF() is not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.127 2001/06/05 09:21:38 angelos Exp $	*/
d318 1
a318 5
		  if ((tdbp->tdb_srcid->ref_type !=
		       ipo->ipo_srcid->ref_type) ||
		      (tdbp->tdb_srcid->ref_len != ipo->ipo_srcid->ref_len) ||
		      (bcmp(tdbp->tdb_srcid + 1, ipo->ipo_srcid + 1,
			    ipo->ipo_srcid->ref_len)))
d332 1
a332 5
		  if ((tdbp->tdb_dstid->ref_type !=
		       ipo->ipo_dstid->ref_type) ||
		      (tdbp->tdb_dstid->ref_len != ipo->ipo_dstid->ref_len) ||
		      (bcmp(tdbp->tdb_dstid + 1, ipo->ipo_dstid + 1,
			    ipo->ipo_dstid->ref_len)))
d347 2
a348 6
		  if ((tdbp->tdb_local_cred->ref_type !=
		       ipo->ipo_local_cred->ref_type) ||
		      (tdbp->tdb_local_cred->ref_len !=
		       ipo->ipo_local_cred->ref_len) ||
		      (bcmp(tdbp->tdb_local_cred + 1, ipo->ipo_local_cred + 1,
			    ipo->ipo_local_cred->ref_len)))
d395 1
a395 1
	      if (ipo->ipo_srcid != NULL)
d397 1
a397 5
		  if ((tdbp->tdb_srcid->ref_type !=
		       ipo->ipo_srcid->ref_type) ||
		      (tdbp->tdb_srcid->ref_len != ipo->ipo_srcid->ref_len) ||
		      (bcmp(tdbp->tdb_srcid + 1, ipo->ipo_srcid + 1,
			    ipo->ipo_srcid->ref_len)))
d404 1
a404 1
	    if (ipo->ipo_srcid != NULL)
d409 1
a409 1
	      if (ipo->ipo_dstid != NULL)
d411 1
a411 5
		  if ((tdbp->tdb_dstid->ref_type !=
		       ipo->ipo_dstid->ref_type) ||
		      (tdbp->tdb_dstid->ref_len != ipo->ipo_dstid->ref_len) ||
		      (bcmp(tdbp->tdb_dstid + 1, ipo->ipo_dstid + 1,
			    ipo->ipo_dstid->ref_len)))
d418 1
a418 1
	    if (ipo->ipo_dstid != NULL)
a420 23
	  /* Check for credential matches */
	  if (tdbp->tdb_local_cred != NULL)
	  {
	      if (ipo->ipo_local_cred != NULL)
	      {
		  if ((tdbp->tdb_local_cred->ref_type !=
		       ipo->ipo_local_cred->ref_type) ||
		      (tdbp->tdb_local_cred->ref_len !=
		       ipo->ipo_local_cred->ref_len) ||
		      (bcmp(tdbp->tdb_local_cred, ipo->ipo_local_cred + 1,
			    ipo->ipo_local_cred->ref_len)))
		    continue;
	      }
	  }
	  else
	    if (ipo->ipo_local_cred != NULL)
	      continue; /* If no credential was used in the TDB, try
			 * to establish a new SA with the given
			 * credential, since some type of access control
			 * may be done on the other side based on that
			 * credential.
			 */

d1493 13
@


1.127
log
@Clear acquires only if TDB was established correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.126 2001/06/05 06:38:07 angelos Exp $	*/
a1198 3

    DPRINTF(("tdb_add_inp: tdb: %p, inp: %p, direction: %s\n", tdb, inp,
	     inout ? "in" : "out"));
@


1.126
log
@Correct credential matching logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.125 2001/06/04 18:38:12 mickey Exp $	*/
d902 2
a903 1
	  ipsp_clear_acquire(tdbp);
@


1.125
log
@use a faster arc4random() for random spi generation; angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.124 2001/06/01 08:18:27 angelos Exp $	*/
a362 7
	      else
		continue; /* If no credential was used in the TDB, try
			   * to establish a new SA with the given
			   * credential, since some type of access control
			   * may be done on the other side based on that
			   * credential.
			   */
d366 6
a371 1
	      continue;
a453 7
	      else
		continue; /* If no credential was used in the TDB, try
			   * to establish a new SA with the given
			   * credential, since some type of access control
			   * may be done on the other side based on that
			   * credential.
			   */
d457 6
a462 1
	      continue;
@


1.124
log
@Merge two m_copydata() calls into one, and (hopefully) correct the
self-describing padding verification.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.123 2001/06/01 07:56:46 angelos Exp $	*/
d219 1
a219 4
	{
	    get_random_bytes((void *) &spi, sizeof(spi));
	    spi = sspi + (spi % (tspi - sspi));
	}
@


1.123
log
@ipsp_parse_headers() goes down a list of IPv4/IPv6/AH/ESP headers and
creates a tag for each of the ESP/AH headers. This will be used by
IPsec-aware NIC device drivers that need to notify IPsec that crypto
processing has already been done.

There is an excessive amount of m_copydata() calls used by this
routine, but there's no way around it that I can think of.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.122 2001/05/30 16:43:11 angelos Exp $	*/
d1472 9
a1480 3
		    for (i = 5; lasteight[i + 1] != 0 && i >= 0; i--)
		      if (lasteight[i + 1] != lasteight[i] + 1)
			return tags.lh_first;
d1492 1
d1526 5
a1530 4
		    m_copydata(m, off, sizeof(u_int8_t), (caddr_t) &proto);
		    m_copydata(m, off + sizeof(u_int8_t), sizeof(u_int8_t),
			       (caddr_t) &s);
		    off += (s + 2) << 2;
d1534 1
@


1.122
log
@IPSP_IDENTITY_MBOX -> IPSP_IDENTITY_FQDN, and print type of creds/auth
in kernfs
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.121 2001/05/30 11:15:37 angelos Exp $	*/
d1315 220
@


1.121
log
@Free remote authentication material on TDB free.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.120 2001/05/30 10:56:46 angelos Exp $	*/
d984 12
@


1.120
log
@Free local auth on TDB free.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.119 2001/05/29 01:17:24 angelos Exp $	*/
d820 6
@


1.119
log
@Keep track of when a TDB was last marked/unmared as SKIPCRYPTO, and
print the relevant information on KERNFS.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.118 2001/05/29 01:03:00 angelos Exp $	*/
d815 6
@


1.118
log
@Add ipsp_skipcrypto_{mark,unmark}()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.117 2001/05/27 05:16:32 angelos Exp $	*/
d1030 9
d1270 4
a1273 1
      tdb->tdb_flags |= TDBF_SKIPCRYPTO;
d1286 4
a1289 1
      tdb->tdb_flags &= ~TDBF_SKIPCRYPTO;
@


1.117
log
@ipsp_copy_ident() no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.116 2001/05/22 02:55:49 angelos Exp $	*/
d1250 26
@


1.116
log
@Simplify option printing. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.115 2001/05/21 03:02:19 angelos Exp $	*/
a1209 22
}

/* Copy a struct tdb_ident structure */
void *
ipsp_copy_ident(void *arg)
{
    struct tdb_ident *tdbii, *tdbi;

    tdbi = (struct tdb_ident *) arg;

    /*
     * Allocate new structure. If we fail, just return NULL -- the
     * new packet will be treated as if it was not protected.
     */
    MALLOC(tdbii, struct tdb_ident *, sizeof(struct tdb_ident), M_TEMP,
	   M_NOWAIT);
    if (tdbii == NULL)
      return NULL;
    bcopy(&tdbi->dst, &tdbii->dst, sizeof(union sockaddr_union));
    tdbii->proto = tdbi->proto;
    tdbii->spi = tdbi->spi;
    return (void *) tdbii;
@


1.115
log
@Use a reference-counted structure for IPsec IDs and credentials, so we
can cheaply keep copies of them at the PCB. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.114 2001/05/05 00:31:19 angelos Exp $	*/
d48 1
d909 1
d918 12
a929 1
    int l, i, s;
d984 3
a986 3
		  i = 0;

		  if (tdb->tdb_flags & TDBF_UNIQUE)
d988 1
a988 6
		      if (i)
			l += sprintf(buffer + l, ", ");
		      else
			i = 1;

		      l += sprintf(buffer + l, "unique");
d992 2
a993 60
		  if (tdb->tdb_flags & TDBF_INVALID)
		  {
		      if (i)
			l += sprintf(buffer + l, ", ");
		      else
			i = 1;

		      l += sprintf(buffer + l, "invalid");
		  }

		  if (tdb->tdb_flags & TDBF_HALFIV)
		  {
		      if (i)
			l += sprintf(buffer + l, ", ");
		      else
			i = 1;

		      l += sprintf(buffer + l, "halfiv");
		  }

		  if (tdb->tdb_flags & TDBF_PFS)
		  {
		      if (i)
			l += sprintf(buffer + l, ", ");
		      else
			i = 1;

		      l += sprintf(buffer + l, "pfs");
		  }

		  if (tdb->tdb_flags & TDBF_TUNNELING)
		  {
		      if (i)
			l += sprintf(buffer + l, ", ");
		      else
			i = 1;

		      l += sprintf(buffer + l, "tunneling");
		  }

		  if (tdb->tdb_flags & TDBF_NOREPLAY)
		  {
		      if (i)
			l += sprintf(buffer + l, ", ");
		      else
			i = 1;

		      l += sprintf(buffer + l, "noreplay");
		  }

		  if (tdb->tdb_flags & TDBF_RANDOMPADDING)
		  {
		      if (i)
			l += sprintf(buffer + l, ", ");
		      else
			i = 1;

		      l += sprintf(buffer + l, "random padding");
		  }

d1107 1
@


1.114
log
@Check that SAs also match on the credentials and the IDs. This means
that flows with different source/destination ID requirements will
cause different SAs to be established by IKE (or whatever other
protocol). Also, use the new data types for allocated memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.113 2001/04/06 04:42:08 csapuntz Exp $	*/
d320 5
a324 4
		  if ((tdbp->tdb_srcid_type != ipo->ipo_srcid_type) ||
		      (tdbp->tdb_srcid_len != ipo->ipo_srcid_len) ||
		      (bcmp(tdbp->tdb_srcid, ipo->ipo_srcid,
			    ipo->ipo_srcid_len)))
d338 5
a342 4
		  if ((tdbp->tdb_dstid_type != ipo->ipo_dstid_type) ||
		      (tdbp->tdb_dstid_len != ipo->ipo_dstid_len) ||
		      (bcmp(tdbp->tdb_dstid, ipo->ipo_dstid,
			    ipo->ipo_dstid_len)))
d357 6
a362 5
		  if ((tdbp->tdb_local_cred_type !=
		       ipo->ipo_local_cred_type) ||
		      (tdbp->tdb_local_cred_len != ipo->ipo_local_cred_len) ||
		      (bcmp(tdbp->tdb_local_cred, ipo->ipo_local_cred,
			    ipo->ipo_local_cred_len)))
d413 5
a417 4
		  if ((tdbp->tdb_srcid_type != ipo->ipo_srcid_type) ||
		      (tdbp->tdb_srcid_len != ipo->ipo_srcid_len) ||
		      (bcmp(tdbp->tdb_srcid, ipo->ipo_srcid,
			    ipo->ipo_srcid_len)))
d431 5
a435 4
		  if ((tdbp->tdb_dstid_type != ipo->ipo_dstid_type) ||
		      (tdbp->tdb_dstid_len != ipo->ipo_dstid_len) ||
		      (bcmp(tdbp->tdb_dstid, ipo->ipo_dstid,
			    ipo->ipo_dstid_len)))
d450 6
a455 5
		  if ((tdbp->tdb_local_cred_type !=
		       ipo->ipo_local_cred_type) ||
		      (tdbp->tdb_local_cred_len != ipo->ipo_local_cred_len) ||
		      (bcmp(tdbp->tdb_local_cred, ipo->ipo_local_cred,
			    ipo->ipo_local_cred_len)))
d817 1
a817 1
      	FREE(tdbp->tdb_srcid, M_CREDENTIALS);
d823 1
a823 1
      	FREE(tdbp->tdb_dstid, M_CREDENTIALS);
d829 1
a829 1
	FREE(tdbp->tdb_local_cred, M_CREDENTIALS);
d835 1
a835 1
	FREE(tdbp->tdb_remote_cred, M_CREDENTIALS);
d1283 1
a1283 1
/* Check whether an IP{4,6} address is unspecified */
d1309 12
@


1.113
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.112 2001/03/28 20:34:03 angelos Exp $	*/
d296 2
a297 1
gettdbbyaddr(union sockaddr_union *dst, u_int8_t proto, struct mbuf *m, int af)
d305 1
a305 1
    hashval = tdb_hash(0, dst, proto);
d308 1
a308 1
      if ((tdbp->tdb_sproto == proto) &&
d316 33
a348 2
	  if ((tdbp->tdb_srcid == NULL) && (tdbp->tdb_dstid == NULL))
	    break;
d350 23
a372 3
	  /* Sanity */
	  if ((m == NULL) || (af == 0))
	    continue;
d374 1
a374 1
	  /* XXX Check the IDs ? */
d386 2
a387 1
gettdbbysrc(union sockaddr_union *src, u_int8_t proto, struct mbuf *m, int af)
d395 1
a395 1
    hashval = tdb_hash(0, src, proto);
d398 1
a398 1
      if ((tdbp->tdb_sproto == proto) &&
d406 57
a462 2
	  if ((tdbp->tdb_srcid == NULL) && (tdbp->tdb_dstid == NULL))
	    break;
d464 1
a464 1
	  /* XXX Check the IDs ? */
d811 1
a811 1
      	FREE(tdbp->tdb_srcid, M_XDATA);
d817 1
a817 1
      	FREE(tdbp->tdb_dstid, M_XDATA);
d821 1
a821 1
    if (tdbp->tdb_src_credentials)
d823 2
a824 2
	FREE(tdbp->tdb_src_credentials, M_XDATA);
	tdbp->tdb_src_credentials = NULL;
d827 1
a827 1
    if (tdbp->tdb_dst_credentials)
d829 2
a830 2
	FREE(tdbp->tdb_dst_credentials, M_XDATA);
	tdbp->tdb_dst_credentials = NULL;
d1275 28
@


1.112
log
@tdb_inp -> (tdb_inp_in, tdb_inp_out)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.111 2001/03/28 20:03:04 angelos Exp $	*/
a83 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.111
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.110 2001/03/27 14:45:22 art Exp $	*/
d753 2
a754 1
	TAILQ_INIT(&tdbp->tdb_inp);
@


1.110
log
@Fix a problem with how TDB timeouts were used in pfkeyv2.
When we allocated a tdb we did a timeout_add before a timeout_set.
This was a problem in itself, but it shouldn't hurt too much.
What did hurt was that we did a timeout_set after the timeout_add,
timeout_set marked the timeout as not being on the timeout list and if we
did a timeout_del (or timeout_add) later (before the timeout fired) we
ended up with a chunk of freed memory on the timeout queue or maybe
even dangling pointers (or a circular list).

This should probably cure the timeout queue corruption some people were
seeing lately.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.109 2001/03/15 06:30:59 mickey Exp $	*/
a321 7
	  /* We only grok addresses */
	  if (((tdbp->tdb_srcid_type != SADB_IDENTTYPE_PREFIX) &&
	       (tdbp->tdb_dstid_type != SADB_IDENTTYPE_CONNECTION)) ||
	      ((tdbp->tdb_dstid_type != SADB_IDENTTYPE_PREFIX) &&
	       (tdbp->tdb_dstid_type != SADB_IDENTTYPE_CONNECTION)))
	    continue;

a359 7
	  /* We only grok addresses */
	  if (((tdbp->tdb_srcid_type != SADB_IDENTTYPE_PREFIX) &&
	       (tdbp->tdb_dstid_type != SADB_IDENTTYPE_CONNECTION)) ||
	      ((tdbp->tdb_dstid_type != SADB_IDENTTYPE_PREFIX) &&
	       (tdbp->tdb_dstid_type != SADB_IDENTTYPE_CONNECTION)))
	    continue;

d674 9
a682 2
    for (inp = TAILQ_FIRST(&tdbp->tdb_inp); inp;
	 inp = TAILQ_FIRST(&tdbp->tdb_inp))
d684 2
a685 2
        TAILQ_REMOVE(&tdbp->tdb_inp, inp, inp_tdb_next);
	inp->inp_tdb = NULL;
d717 7
a723 1
    if (tdbp->tdb_credentials)
d725 2
a726 2
	FREE(tdbp->tdb_credentials, M_XDATA);
	tdbp->tdb_credentials = NULL;
a965 4
	      if (tdb->tdb_interface)
		l += sprintf(buffer + l, "\tAssociated interface = <%s>\n",
			     ((struct ifnet *) tdb->tdb_interface)->if_xname);

d1081 1
a1081 1
tdb_add_inp(struct tdb *tdb, struct inpcb *inp)
d1083 1
a1083 1
    if (inp->inp_tdb)
d1085 7
a1091 2
	if (inp->inp_tdb == tdb)
          return;
d1093 2
a1094 1
	TAILQ_REMOVE(&inp->inp_tdb->tdb_inp, inp, inp_tdb_next);
d1096 10
d1107 3
a1109 2
    inp->inp_tdb = tdb;
    TAILQ_INSERT_TAIL(&tdb->tdb_inp, inp, inp_tdb_next);
d1111 2
a1112 1
    DPRINTF(("tdb_add_inp: tdb: %p, inp: %p\n", tdb, inp));
d1148 22
@


1.109
log
@convert SA expirations to the new timeouts.
simplifies expirations handling a lot.
tdb_exp_timeout and tdb_soft_timeout are made
consistant throughout the code to be a relative time offsets,
just like first_use timeouts.
tested on singlehost isakmpd setup.
lots of dangling spaces and tabs removed.
angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.108 2001/03/13 01:23:18 angelos Exp $	*/
d241 1
a241 2
	MALLOC(tdbp, struct tdb *, sizeof(struct tdb), M_TDB, M_WAITOK);
	bzero((caddr_t) tdbp, sizeof(struct tdb));
a248 2
	tdbp->tdb_established = time.tv_sec;
	tdbp->tdb_epoch = kernfs_epoch - 1;
a250 6
	/* Initialize timeouts */
	timeout_set(&tdbp->tdb_timer_tmo, tdb_timeout, tdbp);
	timeout_set(&tdbp->tdb_first_tmo, tdb_firstuse, tdbp);
	timeout_set(&tdbp->tdb_stimer_tmo, tdb_soft_timeout, tdbp);
	timeout_set(&tdbp->tdb_sfirst_tmo, tdb_soft_firstuse, tdbp);

d743 30
a772 1
 * Initialize a TDB structure.
a778 15

    /* Record establishment time */
    tdbp->tdb_established = time.tv_sec;
    tdbp->tdb_epoch = kernfs_epoch - 1;

    /* Initialize timeouts */
    timeout_set(&tdbp->tdb_timer_tmo, tdb_timeout, tdbp);
    timeout_set(&tdbp->tdb_first_tmo, tdb_firstuse, tdbp);
    timeout_set(&tdbp->tdb_stimer_tmo, tdb_soft_timeout, tdbp);
    timeout_set(&tdbp->tdb_sfirst_tmo, tdb_soft_firstuse, tdbp);

    /* Init Incoming SA-Binding Queues */
    TAILQ_INIT(&tdbp->tdb_inp);

    TAILQ_INIT(&tdbp->tdb_policy_head);
@


1.108
log
@Force a new search for an SA if the latched one is deleted.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.107 2001/03/04 20:34:00 angelos Exp $	*/
d5 1
a5 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr), 
d27 1
a27 1
 * modification of this software. 
d97 4
a110 3
struct expclusterlist_head expclusterlist =
    TAILQ_HEAD_INITIALIZER(expclusterlist);
struct explist_head explist = TAILQ_HEAD_INITIALIZER(explist);
d123 1
a123 1
      (int (*)(struct mbuf *, struct tdb *, int, int))ipe4_input, 
d141 1
a141 1
unsigned char ipseczeroes[IPSEC_ZEROES_SIZE]; /* zeroes! */ 
d226 1
a226 1
	  
d243 1
a243 1
	
d254 6
d264 2
a265 2
		tdbp->tdb_exp_timeout = time.tv_sec + ipsec_keep_invalid;
		tdb_expiration(tdbp, TDBEXP_EARLY | TDBEXP_TIMEOUT);
d276 1
a276 1
 * An IPSP SAID is really the concatenation of the SPI found in the 
d296 1
a296 1
      if ((tdbp->tdb_spi == spi) && 
d448 1
a448 1
handle_expirations(void *arg)
d450 1
a450 1
    struct tdb *tdb;
d452 2
a453 24
    for (tdb = TAILQ_FIRST(&explist);
	 tdb && tdb->tdb_timeout <= time.tv_sec;
	 tdb = TAILQ_FIRST(&explist))
    {
	/* Hard expirations first */
	if ((tdb->tdb_flags & TDBF_TIMER) &&
	    (tdb->tdb_exp_timeout <= time.tv_sec))
	{
	    /* If it's an "invalid" TDB do a silent expiration. */
	    if (!(tdb->tdb_flags & TDBF_INVALID))
	      pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	    tdb_delete(tdb, 0);
	    continue;
	}
	else
	  if ((tdb->tdb_flags & TDBF_FIRSTUSE) &&
	      (tdb->tdb_first_use + tdb->tdb_exp_first_use <= time.tv_sec))
	  {
              /* If the TDB hasn't been used, don't renew it */
              if (tdb->tdb_first_use != 0)
	        pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	      tdb_delete(tdb, 0);
	      continue;
	  }
d455 4
a458 25
	/* Soft expirations */
	if ((tdb->tdb_flags & TDBF_SOFT_TIMER) &&
	    (tdb->tdb_soft_timeout <= time.tv_sec))
	{
	    pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	    tdb->tdb_flags &= ~TDBF_SOFT_TIMER;
	    tdb_expiration(tdb, TDBEXP_EARLY);
	}
	else
	  if ((tdb->tdb_flags & TDBF_SOFT_FIRSTUSE) &&
	      (tdb->tdb_first_use + tdb->tdb_soft_first_use <=
	       time.tv_sec))
	  {
              /* If the TDB hasn't been used, don't renew it */
              if (tdb->tdb_first_use != 0)
	        pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	      tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
	      tdb_expiration(tdb, TDBEXP_EARLY);
	  }
    }

    /* If any tdb is left on the expiration queue, set the timer.  */
    if (tdb)
      timeout(handle_expirations, (void *) NULL, 
	      hz * (tdb->tdb_timeout - time.tv_sec));
a460 3
/*
 * Ensure the tdb is in the right place in the expiration list.
 */
d462 1
a462 1
tdb_expiration(struct tdb *tdb, int flags)
d464 1
a464 4
    struct tdb *t, *former_expirer, *next_expirer;
    int will_be_first, sole_reason, early;
    u_int64_t next_timeout = 0;
    int s = spltdb();
d466 2
a467 15
    /* Find the earliest expiration.  */
    if ((tdb->tdb_flags & TDBF_FIRSTUSE) && tdb->tdb_first_use != 0 &&
	(next_timeout == 0 ||
	 next_timeout > tdb->tdb_first_use + tdb->tdb_exp_first_use))
      next_timeout = tdb->tdb_first_use + tdb->tdb_exp_first_use;
    if ((tdb->tdb_flags & TDBF_SOFT_FIRSTUSE) && tdb->tdb_first_use != 0 &&
	(next_timeout == 0 ||
	 next_timeout > tdb->tdb_first_use + tdb->tdb_soft_first_use))
      next_timeout = tdb->tdb_first_use + tdb->tdb_soft_first_use;
    if ((tdb->tdb_flags & TDBF_TIMER) &&
	(next_timeout == 0 || next_timeout > tdb->tdb_exp_timeout))
      next_timeout = tdb->tdb_exp_timeout;
    if ((tdb->tdb_flags & TDBF_SOFT_TIMER) &&
	(next_timeout == 0 || next_timeout > tdb->tdb_soft_timeout))
      next_timeout = tdb->tdb_soft_timeout;
d469 5
a473 6
    /* No change?  */
    if (next_timeout == tdb->tdb_timeout)
    {
	splx(s);
	return;
    }
d475 4
a478 12
    /*
     * Find out some useful facts: Will our tdb be first to expire?
     * Was our tdb the sole reason for the old timeout?
     */
    former_expirer = TAILQ_FIRST(&expclusterlist);
    next_expirer = TAILQ_NEXT(tdb, tdb_explink);
    will_be_first = (next_timeout != 0 &&
		     (former_expirer == NULL ||
		      next_timeout < former_expirer->tdb_timeout));
    sole_reason = (tdb == former_expirer &&
		   (next_expirer == NULL ||
		    tdb->tdb_timeout != next_expirer->tdb_timeout));
d480 2
a481 8
    /*
     * We need to untimeout if either:
     * - there is an expiration pending and the new timeout is earlier than
     *   what already exists or
     * - the existing first expiration is due to our old timeout value solely
     */
    if ((former_expirer != NULL && will_be_first) || sole_reason)
      untimeout(handle_expirations, (void *) NULL);
d483 4
a486 12
    /*
     * We need to timeout if we've been asked to and if either
     * - our tdb has a timeout and no former expiration exist or
     * - the new timeout is earlier than what already exists or
     * - the existing first expiration is due to our old timeout value solely
     *   and another expiration is in the pipe.
     */
    if ((flags & TDBEXP_TIMEOUT) &&
	(will_be_first || (sole_reason && next_expirer != NULL)))
      timeout(handle_expirations, (void *) NULL,
	      hz * ((will_be_first ? next_timeout :
		     next_expirer->tdb_timeout) - time.tv_sec));
d488 4
a491 13
    /* Our old position, if any, is not relevant anymore.  */
    if (tdb->tdb_timeout != 0)
    {
        if (tdb->tdb_expnext.tqe_prev != NULL)
	{
	    if (next_expirer && tdb->tdb_timeout == next_expirer->tdb_timeout)
	      TAILQ_INSERT_BEFORE(tdb, next_expirer, tdb_expnext);
	    TAILQ_REMOVE(&expclusterlist, tdb, tdb_expnext);
	    tdb->tdb_expnext.tqe_prev = NULL;
	}

	TAILQ_REMOVE(&explist, tdb, tdb_explink);
    }
d493 2
a494 7
    tdb->tdb_timeout = next_timeout;

    if (next_timeout == 0)
    {
	splx(s);
	return;
    }
d496 4
a499 93
    /*
     * Search front-to-back if we believe we will end up early, otherwise
     * back-to-front.
     */
    early = will_be_first || (flags & TDBEXP_EARLY);
    for (t = (early ? TAILQ_FIRST(&expclusterlist) :
	      TAILQ_LAST(&expclusterlist, expclusterlist_head));
	 t != NULL && (early ? (t->tdb_timeout <= next_timeout) : 
		       (t->tdb_timeout > next_timeout));
	 t = (early ? TAILQ_NEXT(t, tdb_expnext) :
	      TAILQ_PREV(t, expclusterlist_head, tdb_expnext)))
      ;
    if (t == (early ? TAILQ_FIRST(&expclusterlist) : NULL))
    {
	/* We are to become the first expiration.  */
	TAILQ_INSERT_HEAD(&expclusterlist, tdb, tdb_expnext);
	TAILQ_INSERT_HEAD(&explist, tdb, tdb_explink);
    }
    else
    {
	if (early)
	  t = (t ? TAILQ_PREV(t, expclusterlist_head, tdb_expnext) :
	       TAILQ_LAST(&expclusterlist, expclusterlist_head));
	if (TAILQ_NEXT(t, tdb_expnext))
	  TAILQ_INSERT_BEFORE(TAILQ_NEXT(t, tdb_expnext), tdb, tdb_explink);
	else
	  TAILQ_INSERT_TAIL(&explist, tdb, tdb_explink);
	if (t->tdb_timeout < next_timeout)
	  TAILQ_INSERT_AFTER(&expclusterlist, t, tdb, tdb_expnext);
    }

#ifdef DIAGNOSTIC
    /*
     * Check various invariants.
     */
    if (tdb->tdb_expnext.tqe_prev != NULL)
    {
	t = TAILQ_FIRST(&expclusterlist);
	if (t != tdb && t->tdb_timeout >= tdb->tdb_timeout)
	  panic("tdb_expiration: "
		"expclusterlist first link out of order (%p, %p)",
		tdb, t);
	t = TAILQ_PREV(tdb, expclusterlist_head, tdb_expnext);
	if (t != NULL && t->tdb_timeout >= tdb->tdb_timeout)
	  panic("tdb_expiration: "
		"expclusterlist prev link out of order (%p, %p)",
		tdb, t);
	else if (t == NULL && tdb != TAILQ_FIRST(&expclusterlist))
	  panic("tdb_expiration: "
		"expclusterlist first link out of order (%p, %p)",
		tdb, TAILQ_FIRST(&expclusterlist));
	t = TAILQ_NEXT(tdb, tdb_expnext);
	if (t != NULL && t->tdb_timeout <= tdb->tdb_timeout)
	  panic("tdb_expiration: "
		"expclusterlist next link out of order (%p, %p)",
		tdb, t);
	else if (t == NULL &&
		 tdb != TAILQ_LAST(&expclusterlist, expclusterlist_head))
	  panic("tdb_expiration: "
		"expclusterlist last link out of order (%p, %p)",
		tdb, TAILQ_LAST(&expclusterlist, expclusterlist_head));
	t = TAILQ_LAST(&expclusterlist, expclusterlist_head);
	if (t != tdb && t->tdb_timeout <= tdb->tdb_timeout)
	  panic("tdb_expiration: "
		"expclusterlist last link out of order (%p, %p)",
		tdb, t);
    }

    t = TAILQ_FIRST(&explist);
    if (t != NULL && t->tdb_timeout > tdb->tdb_timeout)
      panic("tdb_expiration: explist first link out of order (%p, %p)", tdb,
	    t);

    t = TAILQ_PREV(tdb, explist_head, tdb_explink);
    if (t != NULL && t->tdb_timeout > tdb->tdb_timeout)
      panic("tdb_expiration: explist prev link out of order (%p, %p)", tdb, t);
    else if (t == NULL && tdb != TAILQ_FIRST(&explist))
      panic("tdb_expiration: explist first link out of order (%p, %p)", tdb,
	    TAILQ_FIRST(&explist));

    t = TAILQ_NEXT(tdb, tdb_explink);
    if (t != NULL && t->tdb_timeout < tdb->tdb_timeout)
      panic("tdb_expiration: explist next link out of order (%p, %p)", tdb, t);
    else if (t == NULL && tdb != TAILQ_LAST(&explist, explist_head))
      panic("tdb_expiration: explist last link out of order (%p, %p)", tdb,
	    TAILQ_LAST(&explist, explist_head));

    t = TAILQ_LAST(&explist, explist_head);
    if (t != tdb && t->tdb_timeout < tdb->tdb_timeout)
      panic("tdb_expiration: explist last link out of order (%p, %p)", tdb, t);
#endif

    splx(s);
d589 1
a589 1
    
d626 1
a626 1
tdb_delete(struct tdb *tdbp, int expflags)
d713 7
a719 7
    /* Remove us from the expiration lists.  */
    if (tdbp->tdb_timeout != 0)
    {
        tdbp->tdb_flags &= ~(TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE | TDBF_TIMER |
			     TDBF_SOFT_TIMER);
	tdb_expiration(tdbp, expflags);
    }
d764 6
d786 1
a786 1
    DPRINTF(("tdb_init(): no alg %d for spi %08x, addr %s, proto %d\n", 
d816 1
a816 1
    
d935 1
a935 1
		l += sprintf(buffer + l, "\txform = <%s>\n", 
d968 1
a968 1
	    
d974 3
a976 2
			     tdb->tdb_exp_timeout - time.tv_sec);
	    
d980 3
a982 2
			     tdb->tdb_soft_timeout - time.tv_sec);
	    
d987 1
a987 1
	    
d997 1
a997 1
	    
d1054 1
a1054 1
       
d1057 1
a1057 1
	sareq |= inp->inp_seclevel[SL_AUTH] >= IPSEC_LEVEL_USE ? 
d1066 1
a1066 1
	sareq |= ipsec_auth_default_level >= IPSEC_LEVEL_USE ? 
d1068 1
a1068 1
	sareq |= ipsec_esp_trans_default_level >= IPSEC_LEVEL_USE ? 
d1070 1
a1070 1
	sareq |= ipsec_esp_network_default_level >= IPSEC_LEVEL_USE ? 
d1073 1
a1073 1
    
d1104 1
a1104 1
 
@


1.107
log
@Store peer's credentials in TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.106 2001/02/28 04:16:57 angelos Exp $	*/
d891 1
@


1.106
log
@Keep the last packet sent or received that matched an SPD entry, and
retransmit if we eventually have an SA setup for that policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.105 2000/12/28 21:34:03 angelos Exp $	*/
d911 6
@


1.105
log
@Remove unused and confusing reporting line.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.104 2000/12/24 04:18:05 angelos Exp $	*/
a323 4
	  /* Not sure how to deal with half-set IDs...just skip the SA */
	  if ((tdbp->tdb_srcid == NULL) || (tdbp->tdb_dstid == NULL))
	    continue;

a368 4
	  /* Not sure how to deal with half-set IDs...just skip the SA */
	  if ((tdbp->tdb_srcid == NULL) || (tdbp->tdb_dstid == NULL))
	    continue;

d932 1
d945 8
a952 1
	return (*(xsp->xf_init))(tdbp, xsp, ii);
@


1.104
log
@Extra argument in the function to tdb_walk(), indicating last TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.103 2000/12/18 16:45:32 angelos Exp $	*/
a1133 3
	      l += sprintf(buffer + l, "\t%u flows have used this SA\n",
			   tdb->tdb_cur_allocations);
	    
@


1.103
log
@Minor sanity check.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.102 2000/12/15 06:24:03 provos Exp $	*/
d424 1
a424 1
tdb_walk(int (*walker)(struct tdb *, void *), void *arg)
d436 4
a439 1
	  rval = walker(tdbp, (void *)arg);
@


1.102
log
@send expire messages also for sa's that do not have been used.
okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.101 2000/09/19 08:38:59 angelos Exp $	*/
d333 4
@


1.101
log
@SA bundles.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.100 2000/09/19 03:20:58 angelos Exp $	*/
d454 2
a455 5
	    /*
             * If it's an "invalid" TDB or one that hasn't been used
             * before, do a silent expiration.
             */
	    if ((!(tdb->tdb_flags & TDBF_INVALID)) && tdb->tdb_first_use)
d475 1
a475 3
            /* If the TDB hasn't been used, don't renew it */
            if (tdb->tdb_first_use != 0)
	      pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
@


1.100
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.99 2000/08/03 08:31:39 angelos Exp $	*/
d919 6
d1111 16
@


1.99
log
@Don't even need to reset ip_sum, if we're not going to compute it here
but in ip_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.98 2000/08/03 08:29:55 angelos Exp $	*/
d9 2
a10 2
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
a43 1
#include <sys/protosw.h>
a44 1
#include <sys/socketvar.h>
d47 1
a47 1
#include <sys/proc.h>
d55 1
a57 1
#include <netinet/ip_var.h>
a69 2
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
a70 1
#include <crypto/crypto.h>
a95 1
int		check_ipsec_policy  __P((struct inpcb *, void *));
d104 1
d110 4
d143 3
a145 1
static struct tdb **tdbh = NULL, *tdb_bypass = NULL;
d150 2
a151 1
 * Check which transformations are required.
d153 2
a154 2
u_int8_t
get_sa_require(struct inpcb *inp)
d156 5
a160 23
    u_int8_t sareq = 0;
       
    if (inp != NULL)
    {
	sareq |= inp->inp_seclevel[SL_AUTH] >= IPSEC_LEVEL_USE ? 
		 NOTIFY_SATYPE_AUTH : 0;
	sareq |= inp->inp_seclevel[SL_ESP_TRANS] >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_CONF : 0;
	sareq |= inp->inp_seclevel[SL_ESP_NETWORK] >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_TUNNEL : 0;
    }
    else
    {
	sareq |= ipsec_auth_default_level >= IPSEC_LEVEL_USE ? 
		 NOTIFY_SATYPE_AUTH : 0;
	sareq |= ipsec_esp_trans_default_level >= IPSEC_LEVEL_USE ? 
		 NOTIFY_SATYPE_CONF : 0;
	sareq |= ipsec_esp_network_default_level >= IPSEC_LEVEL_USE ? 
		 NOTIFY_SATYPE_TUNNEL : 0;
    }
    
    return (sareq);
}
d162 4
a165 15
/*
 * Check the socket policy and request a new SA with a key management
 * daemon. Sometimes inp does not contain the destination address;
 * in that case use dst.
 */
int
check_ipsec_policy(struct inpcb *inp, void *daddr)
{
    struct route_enc re0, *re = &re0;
    struct sockaddr_encap *dst, *gw;
    u_int8_t sa_require, sa_have;
    struct tdb tdb2, *tdb = NULL;
    union sockaddr_union sunion;
    struct socket *so;
    int error, i, s;
d167 2
a168 9
    if (inp == NULL || ((so = inp->inp_socket) == 0))
      return (EINVAL);

    /* If IPsec is not required just use what we got */
    if (!(sa_require = inp->inp_secrequire))
      return 0;

    s = spltdb();
    if (!inp->inp_tdb)
d170 2
a171 6
	bzero((caddr_t) re, sizeof(*re));
	dst = (struct sockaddr_encap *) &re->re_dst;
	dst->sen_family = PF_KEY;

#ifdef INET6
	if (inp->inp_flags & INP_IPV6)
d173 2
a174 88
	    dst->sen_len = SENT_IP6_LEN;
	    dst->sen_type = SENT_IP6;
	    dst->sen_ip6_src = inp->inp_laddr6;
	    if (inp->inp_faddr6.s6_addr)
	      dst->sen_ip6_dst = inp->inp_faddr6;
	    else
	      dst->sen_ip6_dst =  (*((struct in6_addr *) daddr));

	    dst->sen_ip6_proto = so->so_proto->pr_protocol;

	    switch (dst->sen_ip6_proto)
	    {
		case IPPROTO_UDP:
		case IPPROTO_TCP:
		    dst->sen_ip6_sport = htons(inp->inp_lport);
		    dst->sen_ip6_dport = htons(inp->inp_fport);
		    break;

		default:
		    dst->sen_ip6_sport = 0;
		    dst->sen_ip6_dport = 0;
	    }
	}
#endif /* INET6 */

#ifdef INET
	if (!(inp->inp_flags & INP_IPV6))
	{
	    dst->sen_len = SENT_IP4_LEN;
	    dst->sen_type = SENT_IP4;
	    dst->sen_ip_src = inp->inp_laddr;

	    if (inp->inp_faddr.s_addr)
	      dst->sen_ip_dst = inp->inp_faddr;
	    else
	      dst->sen_ip_dst = (*((struct in_addr *) daddr));

	    dst->sen_proto = so->so_proto->pr_protocol;

	    switch (dst->sen_proto)
	    {
		case IPPROTO_UDP:
		case IPPROTO_TCP:
		    dst->sen_sport = htons(inp->inp_lport);
		    dst->sen_dport = htons(inp->inp_fport);
		    break;

		default:
		    dst->sen_sport = 0;
		    dst->sen_dport = 0;
	    }
	}
#endif /* INET */

	/* Try to find a flow */
	rtalloc((struct route *) re);

	if (re->re_rt != NULL)
	{
	    gw = (struct sockaddr_encap *) (re->re_rt->rt_gateway);

#ifdef INET
	    if (gw->sen_type == SENT_IPSP)
	    {
		bzero(&sunion, sizeof(sunion));
	        sunion.sin.sin_family = AF_INET;
		sunion.sin.sin_len = sizeof(struct sockaddr_in);
		sunion.sin.sin_addr = gw->sen_ipsp_dst;
	      
		tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, &sunion,
					    gw->sen_ipsp_sproto);
	    }
#endif /* INET */

#ifdef INET6
	    if (gw->sen_type == SENT_IPSP6)
	    {
		bzero(&sunion, sizeof(sunion));
	        sunion.sin6.sin6_family = AF_INET6;
		sunion.sin6.sin6_len = sizeof(struct sockaddr_in6);
		sunion.sin6.sin6_addr = gw->sen_ipsp6_dst;
	      
		tdb = (struct tdb *) gettdb(gw->sen_ipsp6_spi, &sunion,
					    gw->sen_ipsp6_sproto);
	    }
#endif /* INET6 */

	    RTFREE(re->re_rt);
a176 2
    else
      tdb = inp->inp_tdb;
d178 2
a179 4
    if (tdb)
      SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdb);
    else
      sa_have = 0;
d181 3
a183 1
    splx(s);
d185 1
a185 123
    /* Check if our requirements are met */
    if (!(sa_require & ~sa_have))
      return 0;

    error = i = 0;

    inp->inp_secresult = SR_WAIT;

    /* If necessary try to notify keymanagement three times */
    while (i < 3)
    {
	switch (dst->sen_type)
	{
#ifdef INET
	    case SENT_IP4:
		DPRINTF(("ipsec: send SA request (%d), remote IPv4 address: %s, SA type: %d\n", i + 1, inet_ntoa4(dst->sen_ip_dst), sa_require));
		break;
#endif /* INET */

#ifdef INET6
	    case SENT_IP6:
		DPRINTF(("ipsec: send SA request (%d), remote IPv6 address: %s, SA type: %d\n", i + 1, ip6_sprintf(&dst->sen_ip6_dst), sa_require));
		break;
#endif /* INET6 */

	    default:
		DPRINTF(("ipsec: unsupported protocol family %d, cannot notify kkey management\n", dst->sen_type));
		return EPFNOSUPPORT;
	}

	/* Initialize TDB for PF_KEY notification */
	bzero(&tdb2, sizeof(tdb2));
	tdb2.tdb_satype = get_sa_require(inp);

#ifdef INET
	if (!(inp->inp_flags & INP_IPV6))
	{
	    tdb2.tdb_src.sin.sin_family = AF_INET;
	    tdb2.tdb_src.sin.sin_len = sizeof(struct sockaddr_in);
	    tdb2.tdb_src.sin.sin_addr = inp->inp_laddr;

	    tdb2.tdb_dst.sin.sin_family = AF_INET;
	    tdb2.tdb_dst.sin.sin_len = sizeof(struct sockaddr_in);
	    tdb2.tdb_dst.sin.sin_addr = inp->inp_faddr;
	}
#endif /* INET */

#ifdef INET6
	if (inp->inp_flags & INP_IPV6)
	{
	    tdb2.tdb_src.sin6.sin6_family = AF_INET6;
	    tdb2.tdb_src.sin6.sin6_len = sizeof(struct sockaddr_in6);
	    tdb2.tdb_src.sin6.sin6_addr = inp->inp_laddr6;

	    tdb2.tdb_dst.sin6.sin6_family = AF_INET6;
	    tdb2.tdb_dst.sin6.sin6_len = sizeof(struct sockaddr_in6);
	    tdb2.tdb_dst.sin6.sin6_addr = inp->inp_faddr6;
	}
#endif /* INET6 */

	error = ipsp_acquire_sa(&tdb2);
	if (error)
	  return error;

	/* 
	 * Wait for the keymanagement daemon to establich a new SA,
	 * even on error check again, perhaps some other process
	 * already established the necessary SA.
	 */
	error = tsleep((caddr_t)inp, PSOCK|PCATCH, "ipsecnotify", 30*hz);
	DPRINTF(("check_ipsec: sleep %d\n", error));

	if (error && error != EWOULDBLOCK)
	  break;

	/* 
	 * A Key Management daemon returned an apropriate SA back
	 * to the kernel, the kernel noted that state in the waiting
	 * socket.
	 */
	if (inp->inp_secresult == SR_SUCCESS)
	  return (0);

	/*
	 * Key Management returned a permanent failure, we do not
	 * need to retry again.
	 *
	 * XXX when more than one key management daemon is available
	 * XXX we can not do that.
	 */
	if (inp->inp_secresult == SR_FAILED)
	  break;

	i++;
    }

    return (error ? error : EWOULDBLOCK);
}

/*
 * Add an inpcb to the list of inpcb which reference this tdb directly.
 */
void
tdb_add_inp(struct tdb *tdb, struct inpcb *inp)
{
    int s = spltdb();

    if (inp->inp_tdb)
    {
	if (inp->inp_tdb == tdb)
	{
	    splx(s);
	    return;
	}

	TAILQ_REMOVE(&inp->inp_tdb->tdb_inp, inp, inp_tdb_next);
    }

    inp->inp_tdb = tdb;
    TAILQ_INSERT_TAIL(&tdb->tdb_inp, inp, inp_tdb_next);
    splx(s);

    DPRINTF(("tdb_add_inp: tdb: %p, inp: %p\n", tdb, inp));
d189 2
a190 3
 * Reserve an SPI; the SA is not valid yet though.  We use SPI_LOCAL_USE as
 * an error return value.  It'll not be a problem that we also use that
 * for demand-keying as that is manually specified.
d214 1
a214 1
      nums = 100;  /* XXX figure out some good value */
d227 1
a227 2
	if (spi == SPI_LOCAL_USE ||
	    (spi >= SPI_RESERVED_MIN && spi <= SPI_RESERVED_MAX))
a268 38
 * Our hashing function needs to stir things with a non-zero random multiplier
 * so we cannot be DoS-attacked via choosing of the data to hash.
 */
INLINE int
tdb_hash(u_int32_t spi, union sockaddr_union *dst, u_int8_t proto)
{
    static u_int32_t mult1 = 0, mult2 = 0;
    u_int8_t *ptr = (u_int8_t *) dst;
    int i, shift;
    u_int64_t hash;
    int val32 = 0;

    while (mult1 == 0)
	mult1 = arc4random();
    while (mult2 == 0)
	mult2 = arc4random();

    hash = (spi ^ proto) * mult1;
    for (i = 0; i < SA_LEN(&dst->sa); i++)
    {
	val32 = (val32 << 8) | ptr[i];
	if (i % 4 == 3)
	{
	    hash ^= val32 * mult2;
	    val32 = 0;
	}
    }
    if (i % 4 != 0)
	hash ^= val32 * mult2;

    shift = ffs(tdb_hashmask + 1);
    while ((hash & ~tdb_hashmask) != 0)
      hash = (hash >> shift) ^ (hash & tdb_hashmask);

    return hash;
}

/*
a281 34
    int s;

    if (spi == 0 && proto == 0)
    {
	/*
	 * tdb_bypass; a placeholder for bypass flows, allocate on
	 * first pass.
	 */
	if (tdb_bypass == NULL)
	{
	    s = spltdb();
	    MALLOC(tdb_bypass, struct tdb *, sizeof(struct tdb), M_TDB,
		   M_WAITOK);
	    tdb_count++;
	    splx(s);

	    bzero(tdb_bypass, sizeof(struct tdb));
	    tdb_bypass->tdb_satype = SADB_X_SATYPE_BYPASS;
	    tdb_bypass->tdb_established = time.tv_sec;
	    tdb_bypass->tdb_epoch = kernfs_epoch - 1;
	    tdb_bypass->tdb_flags = 0;

#ifdef INET
	    tdb_bypass->tdb_dst.sa.sa_family = AF_INET;
#elif INET6
	    tdb_bypass->tdb_dst.sa.sa_family = AF_INET6;
#endif

	    TAILQ_INIT(&tdb_bypass->tdb_bind_in);
	    TAILQ_INIT(&tdb_bypass->tdb_inp);
	}

	return tdb_bypass;
    }
d297 90
d429 5
a433 5
	for (tdbp = tdbh[i]; rval == 0 && tdbp != NULL; tdbp = next)
	{
	    next = tdbp->tdb_hnext;
	    rval = walker(tdbp, (void *)arg);
	}
a437 12
struct flow *
get_flow(void)
{
    struct flow *flow;

    MALLOC(flow, struct flow *, sizeof(struct flow), M_TDB, M_WAITOK);
    bzero(flow, sizeof(struct flow));

    ipsec_in_use++;
    return flow;
}

d454 5
a458 2
	    /* If it's an "invalid" TDB, do a silent expiration */
	    if (!(tdb->tdb_flags & TDBF_INVALID))
d460 1
a460 1
	    tdb_delete(tdb, 0, 0);
d467 4
a470 2
	      pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	      tdb_delete(tdb, 0, 0);
d478 3
a480 1
	    pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
d489 3
a491 1
	      pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
a513 10
    /*
     * If this is the local use SPI, this is an SPD entry, so don't setup any
     * timers.
     */
    if (ntohl(tdb->tdb_spi) == SPI_LOCAL_USE)
    {
	splx(s);
	return;
    }

d518 1
a518 1
	next_timeout = tdb->tdb_first_use + tdb->tdb_exp_first_use;
d522 1
a522 1
	next_timeout = tdb->tdb_first_use + tdb->tdb_soft_first_use;
d525 1
a525 1
	next_timeout = tdb->tdb_exp_timeout;
d528 1
a528 1
	next_timeout = tdb->tdb_soft_timeout;
d533 2
a534 2
      splx(s);
      return;
d582 1
d590 2
a591 2
      splx(s);
      return;
d661 1
d666 1
d673 1
d680 1
a689 56
 * Caller is responsible for setting at least spltdb().
 */
struct flow *
find_flow(union sockaddr_union *src, union sockaddr_union *srcmask,
	  union sockaddr_union *dst, union sockaddr_union *dstmask,
	  u_int8_t proto, struct tdb *tdb, int ingress)
{
    struct flow *flow;

    if (ingress)
      flow = tdb->tdb_access;
    else
      flow = tdb->tdb_flow;

    for (; flow; flow = flow->flow_next)
      if (!bcmp(&src->sa, &flow->flow_src.sa, SA_LEN(&src->sa)) &&
	  !bcmp(&dst->sa, &flow->flow_dst.sa, SA_LEN(&dst->sa)) &&
	  !bcmp(&srcmask->sa, &flow->flow_srcmask.sa, SA_LEN(&srcmask->sa)) &&
	  !bcmp(&dstmask->sa, &flow->flow_dstmask.sa, SA_LEN(&dstmask->sa)) &&
	  (proto == flow->flow_proto))
	return flow;

    return (struct flow *) NULL;
}

/*
 * Caller is responsible for setting at least spltdb().
 */
struct flow *
find_global_flow(union sockaddr_union *src, union sockaddr_union *srcmask,
		 union sockaddr_union *dst, union sockaddr_union *dstmask,
		 u_int8_t proto)
{
    struct flow *flow;
    struct tdb *tdb;
    int i;

    if (tdbh == NULL)
      return (struct flow *) NULL;

    if (tdb_bypass != NULL)
      if ((flow = find_flow(src, srcmask, dst, dstmask, proto,
			    tdb_bypass, FLOW_EGRESS)) != (struct flow *) NULL)
	return flow;

    for (i = 0; i <= tdb_hashmask; i++)
    {
	for (tdb = tdbh[i]; tdb != NULL; tdb = tdb->tdb_hnext)
	  if ((flow = find_flow(src, srcmask, dst, dstmask, proto,
				tdb, FLOW_EGRESS)) != (struct flow *) NULL)
	    return flow;
    }
    return (struct flow *) NULL;
}

/*
d695 1
a695 1
    struct tdb **new_tdbh, *tdbp, *tdbnp;
d700 1
d703 5
d709 3
d713 26
a738 7
      for (tdbp = tdbh[i]; tdbp != NULL; tdbp = tdbnp)
      {
	  tdbnp = tdbp->tdb_hnext;
      	  hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst, tdbp->tdb_sproto);
	  tdbp->tdb_hnext = new_tdbh[hashval];
	  new_tdbh[hashval] = tdbp;
      }
d742 6
d763 7
d771 2
d790 1
a792 3
    tdb_count++;
    splx(s);
}
d794 7
a800 16
/*
 * Caller is responsible for setting at least spltdb().
 */
void
put_flow(struct flow *flow, struct tdb *tdb, int ingress)
{
    if (ingress)
    {
	flow->flow_next = tdb->tdb_access;
	tdb->tdb_access = flow;
    }
    else
    {
	flow->flow_next = tdb->tdb_flow;
	tdb->tdb_flow = flow;
    }
d802 1
a802 2
    if (flow->flow_next)
      flow->flow_next->flow_prev = flow;
d804 1
a804 3
    flow->flow_sa = tdb;
    flow->flow_prev = (struct flow *) NULL;
}
d806 1
a806 25
/*
 * Caller is responsible for setting at least spltdb().
 */
void
delete_flow(struct flow *flow, struct tdb *tdb, int ingress)
{
    if (tdb)
    {
	if (ingress && (tdb->tdb_access == flow))
	    tdb->tdb_access = flow->flow_next;
	else
	  if (!ingress && (tdb->tdb_flow == flow))
	    tdb->tdb_flow = flow->flow_next;

	if (flow->flow_prev)
	  flow->flow_prev->flow_next = flow->flow_next;

	if (flow->flow_next)
	  flow->flow_next->flow_prev = flow->flow_prev;
    }

    if (!ingress)
      ipsec_in_use--;

    FREE(flow, M_TDB);
d813 1
a813 1
tdb_delete(struct tdb *tdbp, int delchain, int expflags)
d815 2
a816 1
    struct tdb *tdbpp, *tdbpn;
d818 1
a818 1
    u_int32_t hashval = tdbp->tdb_sproto + tdbp->tdb_spi;
a820 8
    /* When deleting the bypass tdb, skip the hash table code. */
    if (tdbp == tdb_bypass && tdbp != NULL)
    {
	s = spltdb();
	delchain = 0;
	goto skip_hash;
    }

d843 1
a843 19
 skip_hash:
    /*
     * If there was something before us in the chain pointing to us,
     * make it point nowhere.
     */
    if ((tdbp->tdb_inext) &&
	(tdbp->tdb_inext->tdb_onext == tdbp))
      tdbp->tdb_inext->tdb_onext = NULL;

    /* 
     * If there was something after us in the chain pointing to us,
     * make it point nowhere.
     */
    if ((tdbp->tdb_onext) &&
	(tdbp->tdb_onext->tdb_inext == tdbp))
      tdbp->tdb_onext->tdb_inext = NULL;
    
    tdbpn = tdbp->tdb_onext;
    tdbp->tdb_inext = tdbp->tdb_onext = NULL;
d845 1
a845 1
    if (tdbp->tdb_xform)
d847 2
a848 2
      	(*(tdbp->tdb_xform->xf_zeroize))(tdbp);
	tdbp->tdb_xform = NULL;
d850 8
d859 1
a859 2
    while (tdbp->tdb_access)
      delete_flow(tdbp->tdb_access, tdbp, FLOW_INGRESS);
d861 1
a861 1
    while (tdbp->tdb_flow)
d863 6
a868 10
        /* Delete the flow and the routing entry that goes with it. */ 
        struct sockaddr_encap encapdst, encapnetmask;

        bzero(&encapdst, sizeof(struct sockaddr_encap));
        bzero(&encapnetmask, sizeof(struct sockaddr_encap));

        encapdst.sen_family = PF_KEY;
        encapnetmask.sen_family = PF_KEY;

	switch (tdbp->tdb_flow->flow_src.sa.sa_family)
d870 3
a872 54
	    case AF_INET:
		encapdst.sen_len = SENT_IP4_LEN;
		encapdst.sen_type = SENT_IP4;
		encapdst.sen_ip_src = tdbp->tdb_flow->flow_src.sin.sin_addr;
		encapdst.sen_ip_dst = tdbp->tdb_flow->flow_dst.sin.sin_addr;
		encapdst.sen_proto = tdbp->tdb_flow->flow_proto;
		encapdst.sen_sport = tdbp->tdb_flow->flow_src.sin.sin_port;
		encapdst.sen_dport = tdbp->tdb_flow->flow_dst.sin.sin_port;

		encapnetmask.sen_ip_src = tdbp->tdb_flow->flow_srcmask.sin.sin_addr;
		encapnetmask.sen_ip_dst = tdbp->tdb_flow->flow_dstmask.sin.sin_addr;

		/* Mask transport protocol and ports if applicable */
		if (tdbp->tdb_flow->flow_proto)
		{
		    encapnetmask.sen_proto = 0xff;
		    if (tdbp->tdb_flow->flow_src.sin.sin_port)
		      encapnetmask.sen_sport = 0xffff;
		    if (tdbp->tdb_flow->flow_dst.sin.sin_port)
		      encapnetmask.sen_dport = 0xffff;
		}
		break;

#if INET6
	    case AF_INET6:
		encapdst.sen_len = SENT_IP6_LEN;
		encapdst.sen_type = SENT_IP6;
		encapdst.sen_ip6_src = tdbp->tdb_flow->flow_src.sin6.sin6_addr;
		encapdst.sen_ip6_dst = tdbp->tdb_flow->flow_dst.sin6.sin6_addr;
		encapdst.sen_ip6_proto = tdbp->tdb_flow->flow_proto;
		encapdst.sen_ip6_sport = tdbp->tdb_flow->flow_src.sin6.sin6_port;
		encapdst.sen_ip6_dport = tdbp->tdb_flow->flow_dst.sin6.sin6_port;

		encapnetmask.sen_ip6_src = tdbp->tdb_flow->flow_srcmask.sin6.sin6_addr;
		encapnetmask.sen_ip6_dst = tdbp->tdb_flow->flow_dstmask.sin6.sin6_addr;

		/* Mask transport protocol and ports if applicable */
		if (tdbp->tdb_flow->flow_proto)
		{
		    encapnetmask.sen_ip6_proto = 0xff;
		    if (tdbp->tdb_flow->flow_src.sin6.sin6_port)
		      encapnetmask.sen_ip6_sport = 0xffff;
		    if (tdbp->tdb_flow->flow_dst.sin6.sin6_port)
		      encapnetmask.sen_ip6_dport = 0xffff;
		}
		break;
#endif /* INET6 */

	    default:
#ifdef DIAGNOSTIC
		panic("tdb_delete(): SA %s/%08x/%d has flow of unknown type %d", ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi), tdbp->tdb_sproto, tdbp->tdb_flow->flow_src.sa.sa_family);
#endif /* DIAGNOSTIC */		
		delete_flow(tdbp->tdb_flow, tdbp, FLOW_EGRESS);
		continue;
d875 1
a875 3
	/* Always the same type for address and netmask */
	encapnetmask.sen_len = encapdst.sen_len;
	encapnetmask.sen_type = encapdst.sen_type;
d877 1
a877 11
        rtrequest(RTM_DELETE, (struct sockaddr *) &encapdst,
                  (struct sockaddr *) 0,
                  (struct sockaddr *) &encapnetmask,
                  0, (struct rtentry **) 0);

        delete_flow(tdbp->tdb_flow, tdbp, FLOW_EGRESS);
    }

    /* Cleanup SA-Bindings */
    for (tdbpp = TAILQ_FIRST(&tdbp->tdb_bind_in); tdbpp;
	 tdbpp = TAILQ_FIRST(&tdbp->tdb_bind_in))
d879 2
a880 2
        TAILQ_REMOVE(&tdbpp->tdb_bind_in, tdbpp, tdb_bind_in_next);
	tdbpp->tdb_bind_out = NULL;
d891 7
a897 2
    if (tdbp->tdb_bind_out)
      TAILQ_REMOVE(&tdbp->tdb_bind_out->tdb_bind_in, tdbp, tdb_bind_in_next);
a918 4
    /* If we're deleting the bypass tdb, reset the variable. */
    if (tdbp == tdb_bypass)
      tdb_bypass = NULL;

a921 3
    if (delchain && tdbpn)
      tdb_delete(tdbpn, delchain, expflags);

a937 1
    TAILQ_INIT(&tdbp->tdb_bind_in);
d940 2
d960 1
a960 2
    struct flow *flow;
    struct tdb *tdb, *tdbp;
d963 1
a963 4
    if (off == 0)
      kernfs_epoch++;
    
    if (bufp == NULL || tdbh == NULL)
d967 1
d969 7
a975 1
    *bufp = buffer;
d977 3
a1109 43
	      if (tdb->tdb_bind_out)
		l += sprintf(buffer + l,
			     "\tBound SA: SPI = %08x, "
			     "Destination = %s, Sproto = %u\n",
			     ntohl(tdb->tdb_bind_out->tdb_spi),
			     ipsp_address(tdb->tdb_bind_out->tdb_dst),
			     tdb->tdb_bind_out->tdb_sproto);
	      for (i = 0, tdbp = TAILQ_FIRST(&tdb->tdb_bind_in); tdbp;
		   tdbp = TAILQ_NEXT(tdbp, tdb_bind_in_next))
		i++;

	      if (i > 0)
		l += sprintf(buffer + l,
			     "\tReferenced by %d incoming SA%s\n",
			     i, i == 1 ? "" : "s");

	      if (tdb->tdb_onext)
		l += sprintf(buffer + l,
			     "\tNext SA: SPI = %08x, "
			     "Destination = %s, Sproto = %u\n",
			     ntohl(tdb->tdb_onext->tdb_spi),
			     ipsp_address(tdb->tdb_onext->tdb_dst),
			     tdb->tdb_onext->tdb_sproto);

	      if (tdb->tdb_inext)
		l += sprintf(buffer + l,
			     "\tPrevious SA: SPI = %08x, "
			     "Destination = %s, Sproto = %u\n",
			     ntohl(tdb->tdb_inext->tdb_spi),
			     ipsp_address(tdb->tdb_inext->tdb_dst),
			     tdb->tdb_inext->tdb_sproto);

	      for (i = 0, flow = tdb->tdb_flow; flow; flow = flow->flow_next)
		i++;

	      l+= sprintf(buffer + l, "\tCurrently used by %d flows\n", i);

	      for (i = 0, flow = tdb->tdb_access; flow; flow = flow->flow_next)
		i++;

	      l+= sprintf(buffer + l,
			  "\t%d ingress flows specified\n", i);

a1191 31
char *
inet_ntoa4(struct in_addr ina)
{
    static char buf[4][4 * sizeof "123" + 4];
    unsigned char *ucp = (unsigned char *) &ina;
    static int i = 3;
 
    i = (i + 1) % 4;
    sprintf(buf[i], "%d.%d.%d.%d", ucp[0] & 0xff, ucp[1] & 0xff,
            ucp[2] & 0xff, ucp[3] & 0xff);
    return (buf[i]);
}

char *
ipsp_address(union sockaddr_union sa)
{
    switch (sa.sa.sa_family)
    {
	case AF_INET:
	    return inet_ntoa4(sa.sin.sin_addr);

#if INET6
	case AF_INET6:
	    return ip6_sprintf(&sa.sin6.sin6_addr);
#endif /* INET6 */

	default:
	    return "(unknown address family)";
    }
}

d1193 1
a1193 3
 * Loop over a tdb chain, taking into consideration protocol tunneling. The
 * fourth argument is set if the first encapsulation header is already in
 * place.
d1195 2
a1196 2
int
ipsp_process_packet(struct mbuf *m, struct tdb *tdb, int af, int tunalready)
d1198 3
a1200 13
    int i, off, error;
    struct mbuf *mp;

#ifdef INET
    struct ip *ip;
#endif /* INET */
#ifdef INET6
    struct ip6_hdr *ip6;
#endif /* INET6 */

    /* Check that the transform is allowed by the administrator */
    if ((tdb->tdb_sproto == IPPROTO_ESP && !esp_enable) ||
	(tdb->tdb_sproto == IPPROTO_AH && !ah_enable))
d1202 6
a1207 156
	DPRINTF(("ipsp_process_packet(): IPSec outbound packet dropped due to policy\n"));
	m_freem(m);
	return EHOSTUNREACH;
    }

    /* Sanity check */
    if (!tdb->tdb_xform)
    {
	DPRINTF(("ipsp_process_packet(): uninitialized TDB\n"));
	m_freem(m);
	return EHOSTUNREACH;
    }

    /* Check if the SPI is invalid */
    if (tdb->tdb_flags & TDBF_INVALID)
    {
	DPRINTF(("ipsp_process_packet(): attempt to use invalid SA %s/%08x/%u\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi), tdb->tdb_sproto));
	m_freem(m);
	return ENXIO;
    }

    /* Check that the network protocol is supported */
    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    break;
#endif /* INET6 */

	default:
	    DPRINTF(("ipsp_process_packet(): attempt to use SA %s/%08x/%u for protocol family %d\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi), tdb->tdb_sproto, tdb->tdb_dst.sa.sa_family));
	    m_freem(m);
	    return ENXIO;
    }

    /* Register first use if applicable, setup relevant expiration timer */
    if (tdb->tdb_first_use == 0)
    {
	tdb->tdb_first_use = time.tv_sec;
	tdb_expiration(tdb, TDBEXP_TIMEOUT);
    }

    /*
     * Check for tunneling if we don't have the first header in place.
     * When doing Ethernet-over-IP, we are handed an already-encapsulated
     * frame, so we don't need to re-encapsulate.
     */
    if (tunalready == 0)
    {
	/*
	 * If the target protocol family is different, we know we'll be
	 * doing tunneling.
	 */
	if (af == tdb->tdb_dst.sa.sa_family)
	{
#ifdef INET
	    if (af == AF_INET)
	      i = sizeof(struct ip);
#endif /* INET */

#ifdef INET6
	    if (af == AF_INET6)
	      i = sizeof(struct ip6_hdr);
#endif /* INET6 */

	    /* Bring the network header in the first mbuf */
	    if (m->m_len < i)
	    {
		if ((m = m_pullup(m, i)) == 0)
		  return ENOBUFS;
	    }

#ifdef INET
	    ip = mtod(m, struct ip *);
#endif /* INET */

#ifdef INET6
	    ip6 = mtod(m, struct ip6_hdr *);
#endif /* INET6 */
	}

	/* Do the appropriate encapsulation, if necessary */
	if ((tdb->tdb_dst.sa.sa_family != af) || /* PF mismatch */
	    (tdb->tdb_flags & TDBF_TUNNELING) || /* Tunneling requested */
	    (tdb->tdb_xform->xf_type == XF_IP4) || /* ditto */
#ifdef INET
	    ((tdb->tdb_dst.sa.sa_family == AF_INET) &&
	     (tdb->tdb_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
	     (tdb->tdb_dst.sin.sin_addr.s_addr != ip->ip_dst.s_addr)) ||
#endif /* INET */
#ifdef INET6
	    ((tdb->tdb_dst.sa.sa_family == AF_INET6) &&
	     (!IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr)) &&
	     (!IN6_ARE_ADDR_EQUAL(&tdb->tdb_dst.sin6.sin6_addr,
				  &ip6->ip6_dst))) ||
#endif /* INET6 */
	    0)
	{
#ifdef INET
	    /* Fix IPv4 header checksum and length */
	    if (af == AF_INET)
	    {
		if ((m = m_pullup(m, sizeof(struct ip))) == 0)
		  return ENOBUFS;

		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
                ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	    }
#endif /* INET */

#ifdef INET6
	    /* Fix IPv6 header payload length */
	    if (af == AF_INET6)
	    {
		if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0)
		    return ENOBUFS;

		if (m->m_pkthdr.len - sizeof(*ip6) > IPV6_MAXPACKET) {
		    /* no jumbogram support */
		    m_freem(m);
		    return ENXIO;	/*?*/
		}
		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
	    }
#endif /* INET6 */

	    /* Encapsulate -- the last two arguments are unused */
	    error = ipip_output(m, tdb, &mp, 0, 0);
	    if ((mp == NULL) && (!error))
	      error = EFAULT;
	    if (error)
	    {
		if (mp)
		{
		    m_freem(mp);
		    mp = NULL;
		}

		return error;
	    }

	    m = mp;
	    mp = NULL;
	}

	/* We may be done with this TDB */
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  return ipsp_process_done(m, tdb);
d1211 6
a1216 6
	/*
	 * If this is just an IP-IP TDB and we're told there's already an
	 * encapsulation header, move on.
	 */
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  return ipsp_process_done(m, tdb);
d1218 2
a1219 23

    /* Extract some information off the headers */
    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    ip = mtod(m, struct ip *);
	    i = ip->ip_hl << 2;
	    off = offsetof(struct ip, ip_p);
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    ip6 = mtod(m, struct ip6_hdr *);
	    i = sizeof(struct ip6_hdr);
	    off = offsetof(struct ip6_hdr, ip6_nxt);
	    break;
#endif /* INET6 */
    }

    /* Invoke the IPsec transform */
    return (*(tdb->tdb_xform->xf_output))(m, tdb, NULL, i, off);
d1223 1
a1223 2
 * Called by the IPsec output transform callbacks, to transmit the packet
 * or do further processing, as necessary.
d1225 2
a1226 2
int
ipsp_process_done(struct mbuf *m, struct tdb *tdb)
d1228 1
a1228 9
#ifdef INET
    struct ip *ip;
#endif /* INET */

#ifdef INET6
    struct ip6_hdr *ip6;
#endif /* INET6 */

    switch (tdb->tdb_dst.sa.sa_family)
d1230 2
a1231 10
#ifdef INET
	case AF_INET:
	    /* Fix the header length, for AH processing */
	    if (tdb->tdb_dst.sa.sa_family == AF_INET)
	    {
		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
	    }
	    break;
#endif /* INET */
d1233 1
a1233 25
#ifdef INET6
	case AF_INET6:
	    /* Fix the header length, for AH processing */
	    if (tdb->tdb_dst.sa.sa_family == AF_INET6)
	    {
		if (m->m_pkthdr.len < sizeof(*ip6)) {
		    m_freem(m);
		    return ENXIO;
		}
		if (m->m_pkthdr.len - sizeof(*ip6) > IPV6_MAXPACKET) {
		    /* no jumbogram support */
		    m_freem(m);
		    return ENXIO;	/*?*/
		}
		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6));
	    }
	    break;
#endif /* INET6 */

	default:
	    m_freem(m);
	    DPRINTF(("ipsp_process_done(): unknown protocol family (%d)\n",
		     tdb->tdb_dst.sa.sa_family));
	    return ENXIO;
d1236 2
a1237 4
    /* If there's another TDB to apply, do so. */
    if (tdb->tdb_onext)
      return ipsp_process_packet(m, tdb->tdb_onext,
				 tdb->tdb_onext->tdb_dst.sa.sa_family, 0);
d1239 2
a1240 10
    /*
     * If we're done with IPsec processing, transmit the packet using the
     * appropriate network protocol (IP or IPv6).
     */
    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    NTOHS(ip->ip_len);
	    NTOHS(ip->ip_off);
d1242 12
a1253 16
	    return ip_output(m, NULL, NULL, IP_ENCAPSULATED | IP_RAWOUTPUT,
			     NULL, NULL);
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    /*
	     * we don't need massage, IPv6 header fields are always in
	     * net endian
	     */
	    return ip6_output(m, NULL, NULL, IPV6_ENCAPSULATED, NULL, NULL);
#endif /* INET6 */
    }

    /* Not reached */
    return EINVAL;
d1256 3
a1258 14
/*
 * Lookup at the SPD based on the headers contained on the mbuf. The second
 * argument indicates what protocol family the header at the beginning of
 * the mbuf is. hlen is the the offset of the transport protocol header
 * in the mbuf.
 *
 * Return combinations (of return value and in *error):
 * - NULL/0 -> no IPsec required on packet
 * - NULL/-EINVAL -> silently drop the packet
 * - NULL/errno -> drop packet and return error
 * or a valid TDB value.
 */
struct tdb *
ipsp_spd_lookup(struct mbuf *m, int af, int hlen, int *error)
d1260 1
a1260 24
    struct sockaddr_encap *ddst, *gw;
    struct route_enc re0, *re = &re0;
    union sockaddr_union sunion;
    struct tdb *tdb, tdb2;

    /*
     * If there are no flows in place, there's no point
     * continuing with the SPD lookup.
     */
    if (!ipsec_in_use)
    {
	*error = 0;
	return NULL;
    }

    bzero((caddr_t) re, sizeof(*re));
    ddst = (struct sockaddr_encap *) &re->re_dst;
    ddst->sen_family = PF_KEY;

    /*
     * Do an SPD lookup -- this code should probably be moved
     * to a separate function.
     */
    switch (af)
d1262 1
a1262 1
#ifdef INET
d1264 1
a1264 31
	    ddst->sen_len = SENT_IP4_LEN;
	    ddst->sen_type = SENT_IP4;
	    m_copydata(m, offsetof(struct ip, ip_src),
		       sizeof(struct in_addr), (caddr_t) &(ddst->sen_ip_src));
	    m_copydata(m, offsetof(struct ip, ip_dst),
		       sizeof(struct in_addr), (caddr_t) &(ddst->sen_ip_dst));
	    m_copydata(m, offsetof(struct ip, ip_p), sizeof(u_int8_t),
		       (caddr_t) &(ddst->sen_proto));

	    /* If TCP/UDP, extract the port numbers to use in the lookup */
	    switch (ddst->sen_proto)
	    {
		case IPPROTO_UDP:
		case IPPROTO_TCP:
		    /*
		     * Luckily, the offset of the src/dst ports in both the UDP
		     * and TCP headers is the same (first two 16-bit values
		     * in the respective headers), so we can just copy them.
		     */
		    m_copydata(m, hlen, sizeof(u_int16_t),
			       (caddr_t) &(ddst->sen_sport));
		    m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			       (caddr_t) &(ddst->sen_dport));
		    break;

		default:
		    ddst->sen_sport = 0;
		    ddst->sen_dport = 0;
	    }

	    break;
d1267 1
a1267 1
#ifdef INET6
d1269 1
a1269 33
	    ddst->sen_len = SENT_IP6_LEN;
	    ddst->sen_type = SENT_IP6;
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
		       sizeof(struct in6_addr),
		       (caddr_t) &(ddst->sen_ip6_src));
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		       sizeof(struct in6_addr),
		       (caddr_t) &(ddst->sen_ip6_dst));
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_nxt), sizeof(u_int8_t),
		       (caddr_t) &(ddst->sen_ip6_proto));

	    /* If TCP/UDP, extract the port numbers to use in the lookup */
	    switch (ddst->sen_ip6_proto)
	    {
		case IPPROTO_UDP:
		case IPPROTO_TCP:
		    /*
		     * Luckily, the offset of the src/dst ports in both the UDP
		     * and TCP headers is the same (first two 16-bit values
		     * in the respective headers), so we can just copy them.
		     */
		    m_copydata(m, hlen, sizeof(u_int16_t),
			       (caddr_t) &(ddst->sen_ip6_sport));
		    m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			       (caddr_t) &(ddst->sen_ip6_dport));
		    break;

		default:
		    ddst->sen_ip6_sport = 0;
		    ddst->sen_ip6_dport = 0;
	    }

	    break;
d1273 1
a1273 2
	    *error = EAFNOSUPPORT;
	    return NULL;
a1274 243

    /* Actual SPD lookup */
    rtalloc((struct route *) re);
    if (re->re_rt == NULL)
    {
	*error = 0;
	return NULL; /* Nothing found */
    }

    bzero(&sunion, sizeof(sunion));
    gw = (struct sockaddr_encap *) (re->re_rt->rt_gateway);

    /* Sanity check */
    if (gw == NULL || ((gw->sen_type != SENT_IPSP) &&
		       (gw->sen_type != SENT_IPSP6)))
    {
	DPRINTF(("ipsp_spd_lookup(): no gw, or gw data not IPSP (%d)\n",
		 gw->sen_type));

	if (re->re_rt)
	  RTFREE(re->re_rt);
	*error = EHOSTUNREACH;
	return NULL;
    }

    /*
     * There might be a specific route, that tells us to avoid
     * doing IPsec; this is useful for specific routes that we
     * don't want to have IPsec applied on, like the key
     * management ports.
     */
    switch (gw->sen_type)
    {
#ifdef INET
	case SENT_IPSP:
	    if ((gw->sen_ipsp_sproto == 0) && (gw->sen_ipsp_spi == 0) &&
		(gw->sen_ipsp_dst.s_addr == 0))
	    {
		*error = 0;
		return NULL;
	    }

	    sunion.sin.sin_family = AF_INET;
	    sunion.sin.sin_len = sizeof(struct sockaddr_in);
	    sunion.sin.sin_addr = gw->sen_ipsp_dst;
	    tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, &sunion,
					gw->sen_ipsp_sproto);
	    break;
#endif /* INET */

#ifdef INET6
	case SENT_IPSP6:
	    if ((gw->sen_ipsp6_sproto == 0) && (gw->sen_ipsp6_spi == 0) &&
		IN6_IS_ADDR_UNSPECIFIED(&gw->sen_ipsp6_dst))
	    {
		*error = 0;
		return NULL;
	    }

	    sunion.sin6.sin6_family = AF_INET6;
	    sunion.sin6.sin6_len = sizeof(struct sockaddr_in6);
	    sunion.sin6.sin6_addr = gw->sen_ipsp6_dst;
	    tdb = (struct tdb *) gettdb(gw->sen_ipsp6_spi, &sunion,
					gw->sen_ipsp6_sproto);
	    break;
#endif /* INET6 */

	default:
	    *error = EAFNOSUPPORT;
	    return NULL;
    }

    /*
     * At this point we have an IPSP "gateway" (tunnel) spec.
     * Use the destination of the tunnel and the SPI to
     * look up the necessary Tunnel Control Block. Look it up,
     * and then pass it, along with the packet and the gw,
     * to the appropriate transformation.
     */
    /* tdb lookup is found up there */

    /* Bypass the SA acquisition if that is what we want. */
    if (tdb && tdb->tdb_satype == SADB_X_SATYPE_BYPASS)
    {
	*error = 0;
	return NULL;
    }

    /* 
     * For VPNs, a route with a reserved SPI is used to
     * indicate the need for an SA when none is established.
     */
    if (((ntohl(gw->sen_ipsp_spi) == SPI_LOCAL_USE) &&
	 (gw->sen_type == SENT_IPSP)) ||
	((ntohl(gw->sen_ipsp6_spi) == SPI_LOCAL_USE) &&
	 (gw->sen_type == SENT_IPSP6)))
    {
	if (tdb == NULL)
	{
	    /* We will just use system defaults. */
	    tdb = &tdb2;
	    bzero(&tdb2, sizeof(tdb2));

	    /* Default entry is for ESP */
	    tdb2.tdb_satype = SADB_SATYPE_ESP;
	}

	*error = ipsp_acquire_sa(tdb);
	if (*error == 0)
	  *error = -EINVAL; /* Silently drop the packet */
	return NULL;
    }

    /* Couldn't find the TDB */
    if (tdb == NULL)
    {
#ifdef INET
	if (gw->sen_type == SENT_IPSP)
	  DPRINTF(("ipsp_spd_lookup(): non-existant TDB for SA %s/%08x/%u\n",
		   inet_ntoa4(gw->sen_ipsp_dst), ntohl(gw->sen_ipsp_spi),
		   gw->sen_ipsp_sproto));
#endif /* INET */

#ifdef INET6
	if (gw->sen_type == SENT_IPSP6)
	  DPRINTF(("ipsp_spd_lookup(): non-existant TDB for SA %s/%08x/%u\n",
		   ip6_sprintf(&gw->sen_ipsp6_dst), ntohl(gw->sen_ipsp6_spi),
		   gw->sen_ipsp6_sproto));
#endif /* INET6 */	  

	*error = EHOSTUNREACH;
	return NULL;
    }

    /* Done, IPsec processing necessary */
    *error = 0;
    return tdb;
}

/*
 * Use PFKEY to acquire an SA.
 */
int
ipsp_acquire_sa(struct tdb *tdb)
{
    /* Check whether Perfect Forward Secrect is required */
    if (ipsec_require_pfs)
      tdb->tdb_flags |= TDBF_PFS;
    else
      tdb->tdb_flags &= ~TDBF_PFS;

    /* Initialize expirations */
    if (ipsec_soft_allocations > 0) 
      tdb->tdb_soft_allocations = ipsec_soft_allocations;
    else
      tdb->tdb_soft_allocations = 0;

    if (ipsec_exp_allocations > 0)
      tdb->tdb_exp_allocations = ipsec_exp_allocations;
    else
      tdb->tdb_exp_allocations = 0;

    if (ipsec_soft_bytes > 0)
      tdb->tdb_soft_bytes = ipsec_soft_bytes;
    else
      tdb->tdb_soft_bytes = 0;

    if (ipsec_exp_bytes > 0)
      tdb->tdb_exp_bytes = ipsec_exp_bytes;
    else
      tdb->tdb_exp_bytes = 0;

    if (ipsec_soft_timeout > 0)
      tdb->tdb_soft_timeout = ipsec_soft_timeout;
    else
      tdb->tdb_soft_timeout = 0;

    if (ipsec_exp_timeout > 0)
      tdb->tdb_exp_timeout = ipsec_exp_timeout;
    else
      tdb->tdb_exp_timeout = 0;

    if (ipsec_soft_first_use > 0)
      tdb->tdb_soft_first_use = ipsec_soft_first_use;
    else
      tdb->tdb_soft_first_use = 0;

    if (ipsec_exp_first_use > 0)
      tdb->tdb_exp_first_use = ipsec_exp_first_use;
    else
      tdb->tdb_exp_first_use = 0;

    /* 
     * If we don't have an existing desired encryption
     * algorithm, use the default.
     */
    if ((tdb->tdb_encalgxform == NULL) &&
	(tdb->tdb_satype & NOTIFY_SATYPE_CONF))
    {
	if (!strncasecmp(ipsec_def_enc, "des", sizeof("des")))
	  tdb->tdb_encalgxform = &enc_xform_des;
	else
	  if (!strncasecmp(ipsec_def_enc, "3des",
			   sizeof("3des")))
	    tdb->tdb_encalgxform = &enc_xform_3des;
	  else
	    if (!strncasecmp(ipsec_def_enc, "blowfish",
			     sizeof("blowfish")))
	      tdb->tdb_encalgxform = &enc_xform_blf;
	    else
	      if (!strncasecmp(ipsec_def_enc, "cast128",
			       sizeof("cast128")))
		tdb->tdb_encalgxform = &enc_xform_cast5;
	      else
		if (!strncasecmp(ipsec_def_enc, "skipjack",
				 sizeof("skipjack")))
		  tdb->tdb_encalgxform = &enc_xform_skipjack;
    }

    /*
     * If we don't have an existing desired authentication
     * algorithm, use the default.
     */
    if ((tdb->tdb_authalgxform == NULL) && 
	(tdb->tdb_satype & NOTIFY_SATYPE_AUTH))
    {
	if (!strncasecmp(ipsec_def_auth, "hmac-md5",
			 sizeof("hmac-md5")))
	  tdb->tdb_authalgxform = &auth_hash_hmac_md5_96;
	else
	  if (!strncasecmp(ipsec_def_auth, "hmac-sha1",
			   sizeof("hmac-sha1")))
	    tdb->tdb_authalgxform = &auth_hash_hmac_sha1_96;
	  else
	    if (!strncasecmp(ipsec_def_auth, "hmac-ripemd160",
			     sizeof("hmac_ripemd160")))
	      tdb->tdb_authalgxform = &auth_hash_hmac_ripemd_160_96;
    }

    /* XXX Initialize src_id/dst_id */

    /* PF_KEYv2 notification message */
    return pfkeyv2_acquire(tdb, 0);
@


1.98
log
@Avoid unnecessary call to in_cksum().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.97 2000/08/03 08:12:33 angelos Exp $	*/
a1919 1
            ip->ip_sum = 0;
@


1.97
log
@Zeroize ip_sum before computing checksum (just general paranoia).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.96 2000/06/19 03:43:15 itojun Exp $	*/
a1920 1
	    ip->ip_sum = in_cksum(m, ip->ip_hl << 2); /* Fix checksum */
@


1.96
log
@IPv6 IPsec, outbound direction.

restriction: if there's any extension header (except fragment)
and outbound packet matches tdb, we can't encrypt it.
packet will not go out of the node (dropped).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.95 2000/06/18 19:48:54 angelos Exp $	*/
d1771 1
d1920 1
@


1.95
log
@Correct function declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.94 2000/06/18 19:10:07 angelos Exp $	*/
d1780 1
a1780 1
		  return ENOBUFS;
d1782 5
d1788 1
a1788 1
		ip6->ip6_plen = htons(m->m_pkthdr.len);
d1882 9
d1892 1
a1892 1
		ip6->ip6_plen = htons(m->m_pkthdr.len);
d1927 5
a1931 6
	    ip6 = mtod(m, struct ip6_hdr *);
	    NTOHS(ip6->ip6_plen);

	    /* XXX ip6_output() has to honor those two flags... */
	    return ip6_output(m, NULL, NULL, IP_ENCAPSULATED | IP_RAWOUTPUT,
			      NULL, NULL);
d2100 2
d2117 2
d2134 1
a2134 2
    tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, &sunion,
				gw->sen_ipsp_sproto);
@


1.94
log
@Pull in the right header for ip6_sprintf(), fix argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.93 2000/06/18 19:05:46 angelos Exp $	*/
d621 1
a621 1
tdb_hashstats()
@


1.93
log
@Use ip6_sprintf() rather than the home-cooked inet6_ntoa4()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.92 2000/06/18 05:54:37 angelos Exp $	*/
d66 1
d332 1
a332 1
		DPRINTF(("ipsec: send SA request (%d), remote IPv6 address: %s, SA type: %d\n", i + 1, ip6_sprintf(dst->sen_ip6_dst), sa_require));
d1629 1
a1629 1
	    return ip6_sprintf(sa.sin6.sin6_addr);
d2165 1
a2165 1
		   ip6_sprintf(gw->sen_ipsp6_dst), ntohl(gw->sen_ipsp6_spi),
@


1.92
log
@Print++
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.91 2000/06/06 04:49:29 angelos Exp $	*/
a39 4
/*
 * IPSP Processing
 */

d331 1
a331 1
		DPRINTF(("ipsec: send SA request (%d), remote IPv6 address: %s, SA type: %d\n", i + 1, inet6_ntoa4(dst->sen_ip6_dst), sa_require));
a1617 16
#ifdef INET6
char *
inet6_ntoa4(struct in6_addr ina)
{
    static char buf[4][8 * sizeof "abcd" + 8];
    unsigned char *ucp = (unsigned char *) &ina;
    static int i = 3;

    i = (i + 1) % 4;
    sprintf(buf[i], "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
	    ucp[0] & 0xff, ucp[1] & 0xff, ucp[2] & 0xff, ucp[3] & 0xff,
	    ucp[4] & 0xff, ucp[5] & 0xff, ucp[6] & 0xff, ucp[7] & 0xff);
    return (buf[i]);
}
#endif /* INET6 */

d1628 1
a1628 1
	    return inet6_ntoa4(sa.sin6.sin6_addr);
d2164 1
a2164 1
		   inet6_ntoa4(gw->sen_ipsp6_dst), ntohl(gw->sen_ipsp6_spi),
@


1.91
log
@Get rid of tdb_ref, keep indirect pointer to TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.90 2000/06/01 06:11:08 angelos Exp $	*/
d1646 1
a1646 1
#if 0 /*INET6*/
d1648 1
a1648 1
	    return inet_ntoa6(sa.sin6.sin6_addr);
@


1.90
log
@Fix the German's comment typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.89 2000/06/01 05:46:12 angelos Exp $	*/
a1047 1
    tdbp->tdb_ref++;
a1113 7
    /* If it's still referenced, go on */
    if (--tdbp->tdb_ref > 0)
    {
	tdbp->tdb_flags |= TDBF_INVALID;
	return;
    }

a1466 3

	      l += sprintf(buffer + l, "\tCurrently referenced %d time%s\n",
			   tdb->tdb_ref, tdb->tdb_ref == 1 ? "" : "s");
@


1.89
log
@Should learn how to count...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.88 2000/06/01 05:33:08 angelos Exp $	*/
d152 1
a152 1
 * Check which transformationes are required
@


1.88
log
@Oops, remove bogus comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.87 2000/06/01 05:08:42 angelos Exp $	*/
d1116 1
a1116 1
    if (tdbp->tdb_ref-- > 0)
@


1.87
log
@Beautify a little bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.86 2000/06/01 04:38:34 angelos Exp $	*/
d1115 7
d1305 2
a1306 8
    /* Don't always delete TDBs as they may be referenced by something else */
    if (--tdbp->tdb_ref <= 0)
    {
      	FREE(tdbp, M_TDB);
    	tdb_count--;
    }
    else
      tdbp->tdb_flags |= TDBF_INVALID;
d1315 1
a1315 1
 * Run once, from system boot.
@


1.86
log
@Use ipsp_spd_lookup() in ip_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.85 2000/06/01 04:24:26 angelos Exp $	*/
a153 1

d388 1
a443 1

a567 1

a653 1

a687 1

a934 1

a960 1

a990 1

d1015 3
a1055 1

a1079 1

d1104 3
d1313 3
d1341 1
a1341 1
 * Used by kernfs
@


1.85
log
@ipsp_acquire_sa()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.84 2000/06/01 04:02:32 angelos Exp $	*/
d184 1
a184 1
 * daemon. Sometime the inp does not contain the destination address;
@


1.84
log
@ipsp_spd_lookup()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.83 2000/04/19 03:37:35 angelos Exp $	*/
d201 1
a201 1
    /* If IPSEC is not required just use what we got */
d347 1
a347 70
	sa_require = get_sa_require(inp);

	/* Check for PFS */
	if (ipsec_require_pfs)
	  tdb2.tdb_flags |= TDBF_PFS;

	/* Initialize expirations */
	if (ipsec_soft_allocations > 0)
	  tdb2.tdb_soft_allocations = ipsec_soft_allocations;

	if (ipsec_exp_allocations > 0)
	  tdb2.tdb_exp_allocations = ipsec_exp_allocations;

	if (ipsec_soft_bytes > 0)
	  tdb2.tdb_soft_bytes = ipsec_soft_bytes;

	if (ipsec_exp_bytes > 0)
	  tdb2.tdb_exp_bytes = ipsec_exp_bytes;

	if (ipsec_soft_timeout > 0)
	  tdb2.tdb_soft_timeout = ipsec_soft_timeout;

	if (ipsec_exp_timeout > 0)
	  tdb2.tdb_exp_timeout = ipsec_exp_timeout;

	if (ipsec_soft_first_use > 0)
	  tdb2.tdb_soft_first_use = ipsec_soft_first_use;

	if (ipsec_exp_first_use > 0)
	  tdb2.tdb_exp_first_use = ipsec_exp_first_use;

	if (sa_require & NOTIFY_SATYPE_CONF)
	{
	    tdb2.tdb_satype = SADB_SATYPE_ESP;

	    if (!strncasecmp(ipsec_def_enc, "des", sizeof("des")))
	      tdb2.tdb_encalgxform = &enc_xform_des;
	    else
	      if (!strncasecmp(ipsec_def_enc, "3des", sizeof("3des")))
		tdb2.tdb_encalgxform = &enc_xform_3des;
	      else
		if (!strncasecmp(ipsec_def_enc, "blowfish", sizeof("blowfish")))
		  tdb2.tdb_encalgxform = &enc_xform_blf;
		else
		  if (!strncasecmp(ipsec_def_enc, "cast128", sizeof("cast128")))
		    tdb2.tdb_encalgxform = &enc_xform_cast5;
		  else
		    if (!strncasecmp(ipsec_def_enc, "skipjack",
				     sizeof("skipjack")))
		      tdb2.tdb_encalgxform = &enc_xform_skipjack;
	}

	if (tdb2.tdb_satype & NOTIFY_SATYPE_AUTH)
	{
	    if (!(sa_require & NOTIFY_SATYPE_CONF))
	      tdb2.tdb_satype = SADB_SATYPE_AH;

	    if (!strncasecmp(ipsec_def_auth, "hmac-md5", sizeof("hmac-md5")))
	      tdb2.tdb_authalgxform = &auth_hash_hmac_md5_96;
	    else
	      if (!strncasecmp(ipsec_def_auth, "hmac-sha1",
			       sizeof("hmac-sha1")))
		tdb2.tdb_authalgxform = &auth_hash_hmac_sha1_96;
	      else
		if (!strncasecmp(ipsec_def_auth, "hmac-ripemd160",
				 sizeof("hmac_ripemd160")))
		  tdb2.tdb_authalgxform = &auth_hash_hmac_ripemd_160_96;
	}

	/* XXX Initialize src_id/dst_id */
d375 2
a376 2
	/* Send PF_KEYv2 Notify */
	if ((error = pfkeyv2_acquire(&tdb2, 0)) != 0)
d2175 3
a2177 101
	/* Check whether Perfect Forward Secrect is required */
	if (ipsec_require_pfs)
	  tdb->tdb_flags |= TDBF_PFS;
	else
	  tdb->tdb_flags &= ~TDBF_PFS;

	/* Initialize expirations */
	if (ipsec_soft_allocations > 0) 
	  tdb->tdb_soft_allocations = ipsec_soft_allocations;
	else
	  tdb->tdb_soft_allocations = 0;

	if (ipsec_exp_allocations > 0)
	  tdb->tdb_exp_allocations = ipsec_exp_allocations;
	else
	  tdb->tdb_exp_allocations = 0;

	if (ipsec_soft_bytes > 0)
	  tdb->tdb_soft_bytes = ipsec_soft_bytes;
	else
	  tdb->tdb_soft_bytes = 0;

	if (ipsec_exp_bytes > 0)
	  tdb->tdb_exp_bytes = ipsec_exp_bytes;
	else
	  tdb->tdb_exp_bytes = 0;

	if (ipsec_soft_timeout > 0)
	  tdb->tdb_soft_timeout = ipsec_soft_timeout;
	else
	  tdb->tdb_soft_timeout = 0;

	if (ipsec_exp_timeout > 0)
	  tdb->tdb_exp_timeout = ipsec_exp_timeout;
	else
	  tdb->tdb_exp_timeout = 0;

	if (ipsec_soft_first_use > 0)
	  tdb->tdb_soft_first_use = ipsec_soft_first_use;
	else
	  tdb->tdb_soft_first_use = 0;

	if (ipsec_exp_first_use > 0)
	  tdb->tdb_exp_first_use = ipsec_exp_first_use;
	else
	  tdb->tdb_exp_first_use = 0;

	/* 
	 * If we don't have an existing desired encryption
	 * algorithm, use the default.
	 */
	if ((tdb->tdb_encalgxform == NULL) &&
	    (tdb->tdb_satype & NOTIFY_SATYPE_CONF))
	{
	    if (!strncasecmp(ipsec_def_enc, "des", sizeof("des")))
	      tdb->tdb_encalgxform = &enc_xform_des;
	    else
	      if (!strncasecmp(ipsec_def_enc, "3des",
			       sizeof("3des")))
		tdb->tdb_encalgxform = &enc_xform_3des;
	      else
		if (!strncasecmp(ipsec_def_enc, "blowfish",
				 sizeof("blowfish")))
		  tdb->tdb_encalgxform = &enc_xform_blf;
		else
		  if (!strncasecmp(ipsec_def_enc, "cast128",
				   sizeof("cast128")))
		    tdb->tdb_encalgxform = &enc_xform_cast5;
		  else
		    if (!strncasecmp(ipsec_def_enc, "skipjack",
				     sizeof("skipjack")))
		      tdb->tdb_encalgxform = &enc_xform_skipjack;
	}

	/*
	 * If we don't have an existing desired authentication
	 * algorithm, use the default.
	 */
	if ((tdb->tdb_authalgxform == NULL) && 
	    (tdb->tdb_satype & NOTIFY_SATYPE_AUTH))
	{
	    if (!strncasecmp(ipsec_def_auth, "hmac-md5",
			     sizeof("hmac-md5")))
	      tdb->tdb_authalgxform = &auth_hash_hmac_md5_96;
	    else
	      if (!strncasecmp(ipsec_def_auth, "hmac-sha1",
			       sizeof("hmac-sha1")))
		tdb->tdb_authalgxform = &auth_hash_hmac_sha1_96;
	      else
		if (!strncasecmp(ipsec_def_auth, "hmac-ripemd160",
				 sizeof("hmac_ripemd160")))
		  tdb->tdb_authalgxform = &auth_hash_hmac_ripemd_160_96;
	}

	/* XXX Initialize src_id/dst_id */

	/* PF_KEYv2 notification message */
	if ((*error = pfkeyv2_acquire(tdb, 0)) != 0)
	  return NULL;

	*error = -EINVAL; /* Hack alert... */
d2205 106
@


1.83
log
@tdb_ref should be signed, this avoid a problem with flushing the TDB
table causing repeated allocations of bypass TDBs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.82 2000/03/28 07:04:02 angelos Exp $	*/
d2022 350
@


1.82
log
@Allow authentication-only ESP (must have broken it in the previous
round of commits).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.81 2000/03/28 06:58:14 angelos Exp $	*/
d562 1
a562 1
	
d1086 1
d1381 1
@


1.81
log
@Set the protocol family in the destination address of bypass flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.80 2000/03/17 10:25:22 angelos Exp $	*/
d1403 1
a1403 1
    
@


1.80
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.79 2000/02/09 04:19:19 itojun Exp $	*/
d648 27
a674 7
      /* tdb_bypass; a placeholder for bypass flows, allocate on first pass */
      if (tdb_bypass == NULL)
      {
	s = spltdb();
	MALLOC(tdb_bypass, struct tdb *, sizeof(struct tdb), M_TDB, M_WAITOK);
	tdb_count++;
	splx(s);
d676 1
a676 9
	bzero(tdb_bypass, sizeof(struct tdb));
	tdb_bypass->tdb_satype = SADB_X_SATYPE_BYPASS;
	tdb_bypass->tdb_established = time.tv_sec;
	tdb_bypass->tdb_epoch = kernfs_epoch - 1;
	tdb_bypass->tdb_flags = 0;
	TAILQ_INIT(&tdb_bypass->tdb_bind_in);
	TAILQ_INIT(&tdb_bypass->tdb_inp);
      }
      return tdb_bypass;
@


1.79
log
@don't need netinet6/in6.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.78 2000/02/07 06:09:09 itojun Exp $	*/
d63 1
d78 3
a118 20
u_int8_t hmac_ipad_buffer[64] = {
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36 };

u_int8_t hmac_opad_buffer[64] = {
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C };

d126 1
a126 1
      (struct mbuf * (*)(struct mbuf *, struct tdb *, int, int))ipe4_input, 
d1108 1
d1169 1
a1169 1
    struct tdb *tdbpp;
d1199 1
d1202 2
d1207 1
a1207 1
     * make it point nowhere
d1215 1
a1215 1
     * make it point nowhere
d1221 3
a1223 2
    tdbpp = tdbp->tdb_onext;
    
d1225 4
a1228 1
      (*(tdbp->tdb_xform->xf_zeroize))(tdbp);
d1321 1
d1342 4
a1345 1
      FREE(tdbp->tdb_srcid, M_XDATA);
d1348 4
a1351 1
      FREE(tdbp->tdb_dstid, M_XDATA);
d1357 8
a1364 2
    FREE(tdbp, M_TDB);
    tdb_count--;
d1366 2
a1367 2
    if (delchain && tdbpp)
      tdb_delete(tdbpp, delchain, expflags);
d1528 5
d1727 1
a1727 2
ipsp_process_packet(struct mbuf *m, struct mbuf **mp, struct tdb *tdb, int *af,
		    int tunalready)
d1729 2
a1730 2
    int i, error, off;
    struct tdb *t;
a1734 1

d1739 24
a1762 8
    for (t = tdb; t != NULL; t = t->tdb_onext)
      if ((t->tdb_sproto == IPPROTO_ESP && !esp_enable) ||
	  (t->tdb_sproto == IPPROTO_AH && !ah_enable))
      {
	  DPRINTF(("ipsp_process_packet(): IPSec outbound packet dropped due to policy\n"));
	  m_freem(m);
	  return EHOSTUNREACH;
      }
d1764 2
a1765 1
    while (tdb && tdb->tdb_xform)
d1767 4
a1770 7
	/* Check if the SPI is invalid */
	if (tdb->tdb_flags & TDBF_INVALID)
	{
	    DPRINTF(("ipsp_process_packet(): attempt to use invalid SA %s/%08x/%u\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi), tdb->tdb_sproto));
	    m_freem(m);
	    return ENXIO;
	}
d1772 3
a1774 8
#ifndef INET6
	/* Sanity check */
	if (tdb->tdb_dst.sa.sa_family != AF_INET)
	{
	    DPRINTF(("ipsp_process_packet(): attempt to use SA %s/%08x/%u for protocol family %d\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi), tdb->tdb_sproto, tdb->tdb_dst.sa.sa_family));
	    m_freem(m);
	    return ENXIO;
	}
d1777 1
a1777 4
#ifndef INET
	/* Sanity check */
	if (tdb->tdb_dst.sa.sa_family != AF_INET6)
	{
d1781 1
a1781 2
	}
#endif /* INET */
d1783 6
a1788 6
	/* Register first use, setup expiration timer */
	if (tdb->tdb_first_use == 0)
	{
	    tdb->tdb_first_use = time.tv_sec;
	    tdb_expiration(tdb, TDBEXP_TIMEOUT);
	}
d1790 12
a1801 2
	/* Check for tunneling if we don't have the first header in place */
	if (tunalready == 0)
a1802 2
	    if ((*af) == tdb->tdb_dst.sa.sa_family)
	    {
d1804 2
a1805 2
		if ((*af) == AF_INET)
		  i = sizeof(struct ip);
d1809 2
a1810 2
		if ((*af) == AF_INET6)
		  i = sizeof(struct ip6_hdr);
d1813 6
a1818 5
		if (m->m_len < i)
		{
		    if ((m = m_pullup(m, i)) == 0)
		      return ENOBUFS;
		}
d1821 1
a1821 1
		ip = mtod(m, struct ip *);
d1825 1
a1825 1
		ip6 = mtod(m, struct ip6_hdr *);
d1827 1
a1827 1
	    }
d1829 4
a1832 3
	    if ((tdb->tdb_dst.sa.sa_family != (*af)) ||
		((tdb->tdb_flags & TDBF_TUNNELING) &&
		 (tdb->tdb_xform->xf_type != XF_IP4)) ||
d1834 3
a1836 3
		((tdb->tdb_dst.sa.sa_family == AF_INET) &&
		 (tdb->tdb_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
		 (tdb->tdb_dst.sin.sin_addr.s_addr != ip->ip_dst.s_addr)) ||
d1839 4
a1842 4
		((tdb->tdb_dst.sa.sa_family == AF_INET6) &&
		 (!IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr)) &&
		 (!IN6_ARE_ADDR_EQUAL(&tdb->tdb_dst.sin6.sin6_addr,
				      &ip6->ip6_dst))) ||
d1844 5
a1848 1
		0)
d1850 7
a1856 7
#ifdef INET
		/* Fix IPv4 header checksum and length */
		if ((*af) == AF_INET)
		{
		    ip->ip_len = htons(m->m_pkthdr.len);
		    ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
		}
d1860 9
a1868 3
		/* Fix IPv6 header payload length */
		if ((*af) == AF_INET6)
		  ip6->ip6_plen = htons(m->m_pkthdr.len);
d1871 7
a1877 5
		/* Encapsulate -- the last two arguments are unused */
		error = ipip_output(m, tdb, mp, 0, 0);
		if (((*mp) == NULL) && (!error))
		  error = EFAULT;
		if (error)
d1879 2
a1880 6
		    if (*mp)
		    {
		      	m_freem(*mp);
			*mp = NULL;
		    }
		    return error;
d1883 1
a1883 3
		*af = tdb->tdb_dst.sa.sa_family;
		m = *mp;
		*mp = NULL;
d1885 3
a1888 3
	else
	{
	    tunalready = 0;
d1890 17
a1906 4
	    if (tdb->tdb_xform->xf_type == XF_IP4)
	      continue;
	}
    
d1908 1
a1908 2
	if (tdb->tdb_dst.sa.sa_family == AF_INET)
	{
d1912 1
a1912 7

	    if (tdb->tdb_xform->xf_type == XF_IP4)
	    {
		ip->ip_len = htons(m->m_pkthdr.len);
		ip->ip_sum = in_cksum(m, i);
	    }
	}
d1916 1
a1916 2
	if (tdb->tdb_dst.sa.sa_family == AF_INET6)
	{
d1920 1
a1920 2
	    ip6->ip6_plen = htons(m->m_pkthdr.len);
	}
d1922 16
a1937 10
    
	error = (*(tdb->tdb_xform->xf_output))(m, tdb, mp, i, off);
	if ((*mp) == NULL)
	  error = EFAULT;
	if (error)
	{
	    if (*mp)
	      m_freem(*mp);
	    return error;
	}
d1939 3
a1941 3
	m = *mp;
	*mp = NULL;
	tdb = tdb->tdb_onext;
d1943 2
d1946 8
a1953 6
	/* Fix the header length, for AH processing */
	if ((*af) == AF_INET)
	{
	    ip = mtod(m, struct ip *);
	    ip->ip_len = htons(m->m_pkthdr.len);
	}
d1957 8
a1964 6
	/* Fix the header length, for AH processing */
	if ((*af) == AF_INET6)
	{
	    ip6 = mtod(m, struct ip6_hdr *);
	    ip6->ip6_plen = htons(m->m_pkthdr.len);
	}
d1966 6
d1974 11
d1986 18
a2003 5
    /* Fix checksum */
    if ((*af) == AF_INET)
    {
	ip = mtod(m, struct ip *);
	ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
a2004 1
#endif /* INET */
d2006 2
a2007 2
    *mp = m;
    return 0;
@


1.79.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a62 1
#include <netinet/ip_var.h>
a76 3
#include <crypto/crypto.h>
#include <crypto/xform.h>

d115 20
d142 1
a142 1
      (int (*)(struct mbuf *, struct tdb *, int, int))ipe4_input, 
a1123 1
    tdbp->tdb_ref++;
d1184 1
a1184 1
    struct tdb *tdbpp, *tdbpn;
a1213 1
	    break;
a1215 2
    tdbp->tdb_hnext = NULL;

d1219 1
a1219 1
     * make it point nowhere.
d1227 1
a1227 1
     * make it point nowhere.
d1233 2
a1234 3
    tdbpn = tdbp->tdb_onext;
    tdbp->tdb_inext = tdbp->tdb_onext = NULL;

d1236 1
a1236 4
    {
      	(*(tdbp->tdb_xform->xf_zeroize))(tdbp);
	tdbp->tdb_xform = NULL;
    }
a1328 1

d1349 1
a1349 4
    {
      	FREE(tdbp->tdb_srcid, M_XDATA);
	tdbp->tdb_srcid = NULL;
    }
d1352 1
a1352 4
    {
      	FREE(tdbp->tdb_dstid, M_XDATA);
	tdbp->tdb_dstid = NULL;
    }
d1358 2
a1359 8
    /* Don't always delete TDBs as they may be referenced by something else */
    if (--tdbp->tdb_ref <= 0)
    {
      	FREE(tdbp, M_TDB);
    	tdb_count--;
    }
    else
      tdbp->tdb_flags |= TDBF_INVALID;
d1361 2
a1362 2
    if (delchain && tdbpn)
      tdb_delete(tdbpn, delchain, expflags);
a1522 5
	      l += sprintf(buffer + l, "\tCrypto ID: %qu\n", tdb->tdb_cryptoid);

	      l += sprintf(buffer + l, "\tCurrently referenced %d time%s\n",
			   tdb->tdb_ref, tdb->tdb_ref == 1 ? "" : "s");

d1717 2
a1718 1
ipsp_process_packet(struct mbuf *m, struct tdb *tdb, int af, int tunalready)
d1720 2
a1721 2
    int i, off, error;
    struct mbuf *mp;
d1726 1
d1731 8
a1738 8
    /* Check that the transform is allowed by the administrator */
    if ((tdb->tdb_sproto == IPPROTO_ESP && !esp_enable) ||
	(tdb->tdb_sproto == IPPROTO_AH && !ah_enable))
    {
	DPRINTF(("ipsp_process_packet(): IPSec outbound packet dropped due to policy\n"));
	m_freem(m);
	return EHOSTUNREACH;
    }
d1740 1
a1740 2
    /* Sanity check */
    if (!tdb->tdb_xform)
d1742 7
a1748 4
	DPRINTF(("ipsp_process_packet(): uninitialized TDB\n"));
	m_freem(m);
	return EHOSTUNREACH;
    }
d1750 8
a1757 19
    /* Check if the SPI is invalid */
    if (tdb->tdb_flags & TDBF_INVALID)
    {
	DPRINTF(("ipsp_process_packet(): attempt to use invalid SA %s/%08x/%u\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi), tdb->tdb_sproto));
	m_freem(m);
	return ENXIO;
    }

    /* Check that the network protocol is supported */
    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    break;
d1760 4
a1763 1
	default:
d1767 2
a1768 1
    }
d1770 6
a1775 6
    /* Register first use if applicable, setup relevant expiration timer */
    if (tdb->tdb_first_use == 0)
    {
	tdb->tdb_first_use = time.tv_sec;
	tdb_expiration(tdb, TDBEXP_TIMEOUT);
    }
d1777 2
a1778 12
    /*
     * Check for tunneling if we don't have the first header in place.
     * When doing Ethernet-over-IP, we are handed an already-encapsulated
     * frame, so we don't need to re-encapsulate.
     */
    if (tunalready == 0)
    {
	/*
	 * If the target protocol family is different, we know we'll be
	 * doing tunneling.
	 */
	if (af == tdb->tdb_dst.sa.sa_family)
d1780 2
d1783 2
a1784 2
	    if (af == AF_INET)
	      i = sizeof(struct ip);
d1788 2
a1789 2
	    if (af == AF_INET6)
	      i = sizeof(struct ip6_hdr);
d1792 5
a1796 6
	    /* Bring the network header in the first mbuf */
	    if (m->m_len < i)
	    {
		if ((m = m_pullup(m, i)) == 0)
		  return ENOBUFS;
	    }
d1799 1
a1799 1
	    ip = mtod(m, struct ip *);
d1803 1
a1803 1
	    ip6 = mtod(m, struct ip6_hdr *);
d1805 1
a1805 1
	}
d1807 3
a1809 4
	/* Do the appropriate encapsulation, if necessary */
	if ((tdb->tdb_dst.sa.sa_family != af) || /* PF mismatch */
	    (tdb->tdb_flags & TDBF_TUNNELING) || /* Tunneling requested */
	    (tdb->tdb_xform->xf_type == XF_IP4) || /* ditto */
d1811 3
a1813 3
	    ((tdb->tdb_dst.sa.sa_family == AF_INET) &&
	     (tdb->tdb_dst.sin.sin_addr.s_addr != INADDR_ANY) &&
	     (tdb->tdb_dst.sin.sin_addr.s_addr != ip->ip_dst.s_addr)) ||
d1816 4
a1819 4
	    ((tdb->tdb_dst.sa.sa_family == AF_INET6) &&
	     (!IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr)) &&
	     (!IN6_ARE_ADDR_EQUAL(&tdb->tdb_dst.sin6.sin6_addr,
				  &ip6->ip6_dst))) ||
d1821 2
a1822 2
	    0)
	{
d1824 6
a1829 10
	    /* Fix IPv4 header checksum and length */
	    if (af == AF_INET)
	    {
		if ((m = m_pullup(m, sizeof(struct ip))) == 0)
		  return ENOBUFS;

		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	    }
d1833 3
a1835 9
	    /* Fix IPv6 header payload length */
	    if (af == AF_INET6)
	    {
		if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0)
		  return ENOBUFS;

		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len);
	    }
d1838 5
a1842 7
	    /* Encapsulate -- the last two arguments are unused */
	    error = ipip_output(m, tdb, &mp, 0, 0);
	    if ((mp == NULL) && (!error))
	      error = EFAULT;
	    if (error)
	    {
		if (mp)
d1844 6
a1849 2
		    m_freem(mp);
		    mp = NULL;
d1852 3
a1854 1
		return error;
d1856 4
d1861 2
a1862 2
	    m = mp;
	    mp = NULL;
d1864 1
a1864 18

	/* We may be done with this TDB */
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  return ipsp_process_done(m, tdb);
    }
    else
    {
	/*
	 * If this is just an IP-IP TDB and we're told there's already an
	 * encapsulation header, move on.
	 */
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  return ipsp_process_done(m, tdb);
    }

    /* Extract some information off the headers */
    switch (tdb->tdb_dst.sa.sa_family)
    {
d1866 2
a1867 1
	case AF_INET:
d1871 7
a1877 1
	    break;
d1881 2
a1882 1
	case AF_INET6:
d1886 2
a1887 1
	    break;
d1889 10
a1898 1
    }
d1900 3
a1902 3
    /* Invoke the IPsec transform */
    return (*(tdb->tdb_xform->xf_output))(m, tdb, NULL, i, off);
}
a1903 7
/*
 * Called by the IPsec output transform callbacks, to transmit the packet
 * or do further processing, as necessary.
 */
int
ipsp_process_done(struct mbuf *m, struct tdb *tdb)
{
d1905 6
a1910 1
    struct ip *ip;
d1914 6
a1919 1
    struct ip6_hdr *ip6;
d1921 1
d1923 3
a1925 1
    switch (tdb->tdb_dst.sa.sa_family)
d1927 2
a1928 27
#ifdef INET
	case AF_INET:
	    /* Fix the header length, for AH processing */
	    if (tdb->tdb_dst.sa.sa_family == AF_INET)
	    {
		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
	    }
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    /* Fix the header length, for AH processing */
	    if (tdb->tdb_dst.sa.sa_family == AF_INET6)
	    {
		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len);
	    }
	    break;
#endif /* INET6 */

	default:
	    m_freem(m);
	    DPRINTF(("ipsp_process_done(): unknown protocol family (%d)\n",
		     tdb->tdb_dst.sa.sa_family));
	    return ENXIO;
a1929 20

    /* If there's another TDB to apply, do so. */
    if (tdb->tdb_onext)
      return ipsp_process_packet(m, tdb->tdb_onext,
				 tdb->tdb_onext->tdb_dst.sa.sa_family, 0);

    /*
     * If we're done with IPsec processing, transmit the packet using the
     * appropriate network protocol (IP or IPv6).
     */
    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    NTOHS(ip->ip_len);
	    NTOHS(ip->ip_off);
	    ip->ip_sum = in_cksum(m, ip->ip_hl << 2); /* Fix checksum */

	    return ip_output(m, NULL, NULL, IP_ENCAPSULATED | IP_RAWOUTPUT,
			     NULL, NULL);
d1932 2
a1933 13
#ifdef INET6
	case AF_INET6:
	    ip6 = mtod(m, struct ip6_hdr *);
	    NTOHS(ip6->ip6_plen);

	    /* XXX ip6_output() has to honor those two flags... */
	    return ip6_output(m, NULL, NULL, IP_ENCAPSULATED | IP_RAWOUTPUT,
			      NULL, NULL);
#endif /* INET6 */
    }

    /* Not reached */
    return EINVAL;
@


1.79.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.113 2001/04/06 04:42:08 csapuntz Exp $	*/
d5 1
a5 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr),
d9 2
a10 2
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
d27 1
a27 1
 * modification of this software.
d40 4
d48 1
d50 1
d53 1
a53 1
#include <sys/queue.h>
a60 1
#include <netinet/ip_var.h>
d63 1
a69 1
#include <netinet6/in6_var.h>
d75 2
d78 1
d94 4
d104 1
a105 4
void		tdb_timeout __P((void *v));
void		tdb_firstuse __P((void *v));
void		tdb_soft_timeout __P((void *v));
void		tdb_soft_firstuse __P((void *v));
a112 1
u_int64_t ipsec_last_added = 0;
d115 3
a117 4
struct ipsec_policy_head ipsec_policy_head =
    TAILQ_HEAD_INITIALIZER(ipsec_policy_head);
struct ipsec_acquire_head ipsec_acquire_head =
    TAILQ_HEAD_INITIALIZER(ipsec_acquire_head);
d126 1
a126 1
      (int (*)(struct mbuf *, struct tdb *, int, int))ipe4_input,
d144 1
a144 1
unsigned char ipseczeroes[IPSEC_ZEROES_SIZE]; /* zeroes! */
d147 1
a147 3
static struct tdb **tdbh = NULL;
static struct tdb **tdbaddr = NULL;
static struct tdb **tdbsrc = NULL;
d152 34
a185 2
 * Our hashing function needs to stir things with a non-zero random multiplier
 * so we cannot be DoS-attacked via choosing of the data to hash.
d187 2
a188 2
INLINE int
tdb_hash(u_int32_t spi, union sockaddr_union *dst, u_int8_t proto)
d190 130
a319 5
    static u_int32_t mult1 = 0, mult2 = 0;
    u_int8_t *ptr = (u_int8_t *) dst;
    int i, shift;
    u_int64_t hash;
    int val32 = 0;
d321 1
a321 4
    while (mult1 == 0)
	mult1 = arc4random();
    while (mult2 == 0)
	mult2 = arc4random();
d323 2
a324 2
    hash = (spi ^ proto) * mult1;
    for (i = 0; i < SA_LEN(&dst->sa); i++)
d326 107
a432 2
	val32 = (val32 << 8) | ptr[i];
	if (i % 4 == 3)
d434 7
a440 2
	    hash ^= val32 * mult2;
	    val32 = 0;
d442 35
d479 21
a499 2
    if (i % 4 != 0)
	hash ^= val32 * mult2;
d501 3
a503 3
    shift = ffs(tdb_hashmask + 1);
    while ((hash & ~tdb_hashmask) != 0)
      hash = (hash >> shift) ^ (hash & tdb_hashmask);
d505 1
a505 1
    return hash;
d509 3
a511 2
 * Reserve an SPI; the SA is not valid yet though.  We use 0 as
 * an error return value.
d513 1
d536 1
a536 1
      nums = 100;  /* Arbitrarily chosen */
d547 1
a547 1

d549 2
a550 1
	if (spi >= SPI_RESERVED_MIN && spi <= SPI_RESERVED_MAX)
d562 4
a565 3

	tdbp = tdb_alloc();

d572 2
d580 2
a581 2
		tdbp->tdb_exp_timeout = ipsec_keep_invalid;
		timeout_add(&tdbp->tdb_timer_tmo, hz * ipsec_keep_invalid);
d592 39
a630 1
 * An IPSP SAID is really the concatenation of the SPI found in the
d638 1
d644 22
d673 1
a673 1
      if ((tdbp->tdb_spi == spi) &&
a680 72
/*
 * Get an SA given the remote address, the security protocol type, and
 * the desired IDs.
 */
struct tdb *
gettdbbyaddr(union sockaddr_union *dst, u_int8_t proto, struct mbuf *m, int af)
{
    u_int32_t hashval;
    struct tdb *tdbp;

    if (tdbaddr == NULL)
      return (struct tdb *) NULL;

    hashval = tdb_hash(0, dst, proto);

    for (tdbp = tdbaddr[hashval]; tdbp != NULL; tdbp = tdbp->tdb_anext)
      if ((tdbp->tdb_sproto == proto) &&
	  ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
	  (!bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa))))
      {
	  /*
	   * If the IDs are not set, this was probably a manually-keyed
	   * SA, so it can be used for any type of traffic.
	   */
	  if ((tdbp->tdb_srcid == NULL) && (tdbp->tdb_dstid == NULL))
	    break;

	  /* Sanity */
	  if ((m == NULL) || (af == 0))
	    continue;

	  /* XXX Check the IDs ? */
	  break;
      }

    return tdbp;
}

/*
 * Get an SA given the source address, the security protocol type, and
 * the desired IDs.
 */
struct tdb *
gettdbbysrc(union sockaddr_union *src, u_int8_t proto, struct mbuf *m, int af)
{
    u_int32_t hashval;
    struct tdb *tdbp;

    if (tdbsrc == NULL)
      return (struct tdb *) NULL;

    hashval = tdb_hash(0, src, proto);

    for (tdbp = tdbsrc[hashval]; tdbp != NULL; tdbp = tdbp->tdb_snext)
      if ((tdbp->tdb_sproto == proto) &&
	  ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
	  (!bcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa))))
      {
	  /*
	   * If the IDs are not set, this was probably a manually-keyed
	   * SA, so it can be used for any type of traffic.
	   */
	  if ((tdbp->tdb_srcid == NULL) && (tdbp->tdb_dstid == NULL))
	    break;

	  /* XXX Check the IDs ? */
	  break;
      }

    return tdbp;
}

d683 1
a683 1
tdb_hashstats(void)
d713 1
d715 1
a715 1
tdb_walk(int (*walker)(struct tdb *, void *, int), void *arg)
d724 5
a728 8
      for (tdbp = tdbh[i]; rval == 0 && tdbp != NULL; tdbp = next)
      {
	  next = tdbp->tdb_hnext;
	  if (i == tdb_hashmask && next == NULL)
	    rval = walker(tdbp, (void *)arg, 1);
	  else
	    rval = walker(tdbp, (void *)arg, 0);
      }
d733 12
d748 1
d750 1
a750 1
tdb_timeout(void *v)
d752 1
a752 1
	struct tdb *tdb = v;
d754 22
a775 2
	if (!(tdb->tdb_flags & TDBF_TIMER))
		return;
d777 23
a799 4
	/* If it's an "invalid" TDB do a silent expiration. */
	if (!(tdb->tdb_flags & TDBF_INVALID))
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb);
d802 3
d806 1
a806 1
tdb_firstuse(void *v)
d808 124
a931 1
	struct tdb *tdb = v;
d933 56
a988 2
	if (!(tdb->tdb_flags & TDBF_SOFT_FIRSTUSE))
		return;
d990 1
a990 4
        /* If the TDB hasn't been used, don't renew it */
	if (tdb->tdb_first_use != 0)
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb);
d993 8
a1000 2
void
tdb_soft_timeout(void *v)
d1002 1
a1002 1
	struct tdb *tdb = v;
d1004 4
a1007 2
	if (!(tdb->tdb_flags & TDBF_SOFT_TIMER))
		return;
d1009 9
a1017 3
	/* Soft expirations */
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_TIMER;
d1020 8
a1027 2
void
tdb_soft_firstuse(void *v)
d1029 6
a1034 1
	struct tdb *tdb = v;
d1036 4
a1039 2
	if (!(tdb->tdb_flags & TDBF_SOFT_FIRSTUSE))
		return;
d1041 8
a1048 4
	/* If the TDB hasn't been used, don't renew it */
	if (tdb->tdb_first_use != 0)
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
d1054 1
d1058 1
a1058 1
    struct tdb **new_tdbh, **new_tdbaddr, **new_srcaddr, *tdbp, *tdbnp;
a1062 1

a1064 5
    MALLOC(new_tdbaddr, struct tdb **,
	   sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);
    MALLOC(new_srcaddr, struct tdb **,
	   sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);

a1065 3
    bzero(new_tdbaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));
    bzero(new_srcaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));

d1067 7
a1073 27
    {
	for (tdbp = tdbh[i]; tdbp != NULL; tdbp = tdbnp)
	{
	    tdbnp = tdbp->tdb_hnext;
	    hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst,
			       tdbp->tdb_sproto);
	    tdbp->tdb_hnext = new_tdbh[hashval];
	    new_tdbh[hashval] = tdbp;
	}

	for (tdbp = tdbaddr[i]; tdbp != NULL; tdbp = tdbnp)
	{
	    tdbnp = tdbp->tdb_anext;
	    hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);
	    tdbp->tdb_anext = new_tdbaddr[hashval];
	    new_tdbaddr[hashval] = tdbp;
	}

	for (tdbp = tdbsrc[i]; tdbp != NULL; tdbp = tdbnp)
	{
	    tdbnp = tdbp->tdb_snext;
	    hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);
	    tdbp->tdb_snext = new_srcaddr[hashval];
	    new_srcaddr[hashval] = tdbp;
	}
    }

a1075 6

    FREE(tdbaddr, M_TDB);
    tdbaddr = new_tdbaddr;

    FREE(tdbsrc, M_TDB);
    tdbsrc = new_srcaddr;
a1077 3
/*
 * Add TDB in the hash table.
 */
a1087 7
	MALLOC(tdbaddr, struct tdb **,
	       sizeof(struct tdb *) * (tdb_hashmask + 1),
	       M_TDB, M_WAITOK);
	MALLOC(tdbsrc, struct tdb **,
	       sizeof(struct tdb *) * (tdb_hashmask + 1),
	       M_TDB, M_WAITOK);

a1088 2
	bzero(tdbaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));
	bzero(tdbsrc, sizeof(struct tdb *) * (tdb_hashmask + 1));
d1092 1
a1092 1

a1105 1

d1108 4
d1113 3
a1115 7
    hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);
    tdbp->tdb_anext = tdbaddr[hashval];
    tdbaddr[hashval] = tdbp;

    hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);
    tdbp->tdb_snext = tdbsrc[hashval];
    tdbsrc[hashval] = tdbp;
d1117 13
a1129 1
    tdb_count++;
d1131 2
a1132 1
    ipsec_last_added = time.tv_sec;
d1134 2
a1135 1
    splx(s);
d1139 1
a1139 1
 * Caller is responsible to set at least spltdb().
d1141 1
d1143 1
a1143 1
tdb_delete(struct tdb *tdbp)
d1145 25
a1169 2
    struct ipsec_policy *ipo;
    struct tdb *tdbpp;
d1171 1
a1171 1
    u_int32_t hashval;
d1174 8
d1197 1
a1197 35
	    tdbpp->tdb_hnext = tdbp->tdb_hnext;
	    tdbpp = tdbp;
	    break;
	}

    tdbp->tdb_hnext = NULL;

    hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);

    if (tdbaddr[hashval] == tdbp)
    {
	tdbpp = tdbp;
	tdbaddr[hashval] = tdbp->tdb_anext;
    }
    else
      for (tdbpp = tdbaddr[hashval]; tdbpp != NULL; tdbpp = tdbpp->tdb_anext)
	if (tdbpp->tdb_anext == tdbp)
	{
	    tdbpp->tdb_anext = tdbp->tdb_anext;
	    tdbpp = tdbp;
	    break;
	}

    hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);

    if (tdbsrc[hashval] == tdbp)
    {
	tdbpp = tdbp;
	tdbsrc[hashval] = tdbp->tdb_snext;
    }
    else
      for (tdbpp = tdbsrc[hashval]; tdbpp != NULL; tdbpp = tdbpp->tdb_snext)
	if (tdbpp->tdb_snext == tdbp)
	{
	    tdbpp->tdb_snext = tdbp->tdb_snext;
d1202 21
a1222 1
    tdbp->tdb_snext = NULL;
d1230 4
a1233 3
    /* Cleanup inp references */
    for (inp = TAILQ_FIRST(&tdbp->tdb_inp_in); inp;
	 inp = TAILQ_FIRST(&tdbp->tdb_inp_in))
d1235 77
a1311 2
        TAILQ_REMOVE(&tdbp->tdb_inp_in, inp, inp_tdb_in_next);
	inp->inp_tdb_in = NULL;
d1314 3
a1316 2
    for (inp = TAILQ_FIRST(&tdbp->tdb_inp_out); inp;
	 inp = TAILQ_FIRST(&tdbp->tdb_inp_out))
d1318 2
a1319 2
        TAILQ_REMOVE(&tdbp->tdb_inp_out, inp, inp_tdb_out_next);
	inp->inp_tdb_out = NULL;
d1322 3
a1324 3
    /* Cleanup SPD references */
    for (ipo = TAILQ_FIRST(&tdbp->tdb_policy_head); ipo;
	 ipo = TAILQ_FIRST(&tdbp->tdb_policy_head))
d1326 2
a1327 3
	TAILQ_REMOVE(&tdbp->tdb_policy_head, ipo, ipo_tdb_next);
	ipo->ipo_tdb = NULL;
	ipo->ipo_last_searched = 0; /* Force a re-search */
d1330 10
a1339 7
    /* Remove expiration timeouts.  */
    tdbp->tdb_flags &= ~(TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE | TDBF_TIMER |
			 TDBF_SOFT_TIMER);
    timeout_del(&tdbp->tdb_timer_tmo);
    timeout_del(&tdbp->tdb_first_tmo);
    timeout_del(&tdbp->tdb_stimer_tmo);
    timeout_del(&tdbp->tdb_sfirst_tmo);
d1353 3
a1355 5
    if (tdbp->tdb_src_credentials)
    {
	FREE(tdbp->tdb_src_credentials, M_XDATA);
	tdbp->tdb_src_credentials = NULL;
    }
d1357 2
a1358 1
    if (tdbp->tdb_dst_credentials)
d1360 2
a1361 2
	FREE(tdbp->tdb_dst_credentials, M_XDATA);
	tdbp->tdb_dst_credentials = NULL;
d1363 2
d1366 2
a1367 9
    if ((tdbp->tdb_onext) && (tdbp->tdb_onext->tdb_inext == tdbp))
      tdbp->tdb_onext->tdb_inext = NULL;

    if ((tdbp->tdb_inext) && (tdbp->tdb_inext->tdb_onext == tdbp))
      tdbp->tdb_inext->tdb_onext = NULL;

    FREE(tdbp, M_TDB);
    tdb_count--;

a1370 33
/*
 * Allocate a TDB and initialize a few basic fields.
 */
struct tdb *
tdb_alloc(void)
{
	struct tdb *tdbp;

	MALLOC(tdbp, struct tdb *, sizeof(struct tdb), M_TDB, M_WAITOK);
	bzero((caddr_t) tdbp, sizeof(struct tdb));

	/* Init Incoming SA-Binding Queues */
	TAILQ_INIT(&tdbp->tdb_inp_out);
	TAILQ_INIT(&tdbp->tdb_inp_in);

	TAILQ_INIT(&tdbp->tdb_policy_head);

	/* Record establishment time */
	tdbp->tdb_established = time.tv_sec;
	tdbp->tdb_epoch = kernfs_epoch - 1;

	/* Initialize timeouts */
	timeout_set(&tdbp->tdb_timer_tmo, tdb_timeout, tdbp);
	timeout_set(&tdbp->tdb_first_tmo, tdb_firstuse, tdbp);
	timeout_set(&tdbp->tdb_stimer_tmo, tdb_soft_timeout, tdbp);
	timeout_set(&tdbp->tdb_sfirst_tmo, tdb_soft_firstuse, tdbp);

	return tdbp;
}

/*
 * Do further initializations of a TDB.
 */
d1375 8
a1382 1
    int err;
d1386 1
a1386 2
      {
	  err = (*(xsp->xf_init))(tdbp, xsp, ii);
d1388 1
a1388 7
	  /* Clear possible pending acquires */
	  ipsp_clear_acquire(tdbp);

	  return err;
      }

    DPRINTF(("tdb_init(): no alg %d for spi %08x, addr %s, proto %d\n",
d1391 1
a1391 1

d1396 1
a1396 1
 * Used by kernfs.
d1402 2
a1403 1
    struct tdb *tdb;
d1406 4
a1409 1
    if (bufp == NULL)
d1413 1
d1415 1
a1415 12

    if (off == 0)
    {
        kernfs_epoch++;
        l = sprintf(buffer, "Hashmask: %d, policy entries: %d\n", tdb_hashmask,
                    ipsec_in_use);
       return l;
    }

    if (tdbh == NULL)
      return 0;

d1530 3
d1534 1
a1534 1
		l += sprintf(buffer + l, "\txform = <%s>\n",
d1545 20
d1581 14
d1597 1
a1597 1

d1603 2
a1604 3
			     tdb->tdb_established + tdb->tdb_exp_timeout -
			     time.tv_sec);

d1608 2
a1609 3
			     tdb->tdb_established + tdb->tdb_soft_timeout -
			     time.tv_sec);

d1614 1
a1614 1

d1624 1
a1624 1

d1674 47
d1722 3
a1724 1
 * Check which transformations are required.
d1726 2
a1727 2
u_int8_t
get_sa_require(struct inpcb *inp)
d1729 26
a1754 1
    u_int8_t sareq = 0;
d1756 2
a1757 1
    if (inp != NULL)
d1759 3
a1761 6
	sareq |= inp->inp_seclevel[SL_AUTH] >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_AUTH : 0;
	sareq |= inp->inp_seclevel[SL_ESP_TRANS] >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_CONF : 0;
	sareq |= inp->inp_seclevel[SL_ESP_NETWORK] >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_TUNNEL : 0;
d1763 3
a1765 1
    else
d1767 14
a1780 6
	sareq |= ipsec_auth_default_level >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_AUTH : 0;
	sareq |= ipsec_esp_trans_default_level >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_CONF : 0;
	sareq |= ipsec_esp_network_default_level >= IPSEC_LEVEL_USE ?
		 NOTIFY_SATYPE_TUNNEL : 0;
d1783 6
a1788 2
    return (sareq);
}
d1790 6
a1795 7
/*
 * Add an inpcb to the list of inpcb which reference this tdb directly.
 */
void
tdb_add_inp(struct tdb *tdb, struct inpcb *inp, int inout)
{
    if (inout)
d1797 85
a1881 4
        if (inp->inp_tdb_in)
        {
	    if (inp->inp_tdb_in == tdb)
              return;
d1883 2
a1884 2
	    TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp, inp_tdb_in_next);
        }
d1886 7
a1892 2
        inp->inp_tdb_in = tdb;
        TAILQ_INSERT_TAIL(&tdb->tdb_inp_in, inp, inp_tdb_in_next);
d1896 7
a1902 4
        if (inp->inp_tdb_out)
        {
	    if (inp->inp_tdb_out == tdb)
              return;
d1904 10
a1913 3
	    TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out, inp,
			 inp_tdb_out_next);
        }
d1915 7
a1921 2
        inp->inp_tdb_out = tdb;
        TAILQ_INSERT_TAIL(&tdb->tdb_inp_out, inp, inp_tdb_out_next);
d1924 2
a1925 2
    DPRINTF(("tdb_add_inp: tdb: %p, inp: %p, direction: %s\n", tdb, inp,
	     inout ? "in" : "out"));
d1928 6
a1933 3
/* Return a printable string for the IPv4 address. */
char *
inet_ntoa4(struct in_addr ina)
d1935 3
a1937 3
    static char buf[4][4 * sizeof "123" + 4];
    unsigned char *ucp = (unsigned char *) &ina;
    static int i = 3;
d1939 3
a1941 5
    i = (i + 1) % 4;
    sprintf(buf[i], "%d.%d.%d.%d", ucp[0] & 0xff, ucp[1] & 0xff,
            ucp[2] & 0xff, ucp[3] & 0xff);
    return (buf[i]);
}
d1943 1
a1943 5
/* Return a printable string for the address. */
char *
ipsp_address(union sockaddr_union sa)
{
    switch (sa.sa.sa_family)
d1945 1
a1945 1
#if INET
d1947 7
a1953 1
	    return inet_ntoa4(sa.sin.sin_addr);
d1956 1
a1956 1
#if INET6
d1958 7
a1964 1
	    return ip6_sprintf(&sa.sin6.sin6_addr);
d1968 4
a1971 1
	    return "(unknown address family)";
a1972 7
}

/* Copy a struct tdb_ident structure */
void *
ipsp_copy_ident(void *arg)
{
    struct tdb_ident *tdbii, *tdbi;
d1974 4
a1977 1
    tdbi = (struct tdb_ident *) arg;
d1980 2
a1981 2
     * Allocate new structure. If we fail, just return NULL -- the
     * new packet will be treated as if it was not protected.
d1983 25
a2007 8
    MALLOC(tdbii, struct tdb_ident *, sizeof(struct tdb_ident), M_TEMP,
	   M_NOWAIT);
    if (tdbii == NULL)
      return NULL;
    bcopy(&tdbi->dst, &tdbii->dst, sizeof(union sockaddr_union));
    tdbii->proto = tdbi->proto;
    tdbii->spi = tdbi->spi;
    return (void *) tdbii;
@


1.79.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
a22 1
 * Copyright (c) 2001, Angelos D. Keromytis.
d24 1
a24 1
 * Permission to use, copy, and modify this software with or without fee
d41 2
d45 1
d47 1
a47 1
#include <sys/sysctl.h>
d55 1
d67 2
d70 1
a70 1
#include <net/pfkeyv2.h>
d72 1
d81 1
a81 1
#define	DPRINTF(x)	if (encdebug) printf x
d83 1
a83 1
#define	DPRINTF(x)
d87 1
a87 1
#define	INLINE	static __inline
d117 10
a126 10
	{ XF_IP4,	         0,               "IPv4 Simple Encapsulation",
	  ipe4_attach,       ipe4_init,       ipe4_zeroize,
	  (int (*)(struct mbuf *, struct tdb *, int, int))ipe4_input,
	  ipip_output, },
	{ XF_AH,	 XFT_AUTH,	    "IPsec AH",
	  ah_attach,	ah_init,   ah_zeroize,
	  ah_input,	 	ah_output, },
	{ XF_ESP,	 XFT_CONF|XFT_AUTH, "IPsec ESP",
	  esp_attach,	esp_init,  esp_zeroize,
	  esp_input,	esp_output, },
d128 4
a131 4
	{ XF_TCPSIGNATURE,	 XFT_AUTH, "TCP MD5 Signature Option, RFC 2385",
	  tcp_signature_tdb_attach, 	tcp_signature_tdb_init,
	  tcp_signature_tdb_zeroize,	tcp_signature_tdb_input,
	  tcp_signature_tdb_output, }
d139 1
a139 2
#define	TDB_HASHSIZE_INIT	32

d153 28
a180 22
	static u_int32_t mult1 = 0, mult2 = 0;
	u_int8_t *ptr = (u_int8_t *) dst;
	int i, shift;
	u_int64_t hash;
	int val32 = 0;

	while (mult1 == 0)
		mult1 = arc4random();
	while (mult2 == 0)
		mult2 = arc4random();

	hash = (spi ^ proto) * mult1;
	for (i = 0; i < SA_LEN(&dst->sa); i++) {
		val32 = (val32 << 8) | ptr[i];
		if (i % 4 == 3) {
			hash ^= val32 * mult2;
			val32 = 0;
		}
	}

	if (i % 4 != 0)
		hash ^= val32 * mult2;
d182 1
a182 5
	shift = ffs(tdb_hashmask + 1);
	while ((hash & ~tdb_hashmask) != 0)
		hash = (hash >> shift) ^ (hash & tdb_hashmask);

	return hash;
d191 1
a191 1
    union sockaddr_union *dst, u_int8_t sproto, int *errval)
d193 10
a202 3
	struct tdb *tdbp;
	u_int32_t spi;
	int nums, s;
d204 24
a227 5
	/* Don't accept ranges only encompassing reserved SPIs. */
	if (tspi < sspi || tspi <= SPI_RESERVED_MAX) {
		(*errval) = EINVAL;
		return 0;
	}
d229 4
a232 3
	/* Limit the range to not include reserved areas. */
	if (sspi <= SPI_RESERVED_MAX)
		sspi = SPI_RESERVED_MAX + 1;
d234 2
a235 4
	if (sspi == tspi)   /* Asking for a specific SPI. */
		nums = 1;
	else
		nums = 100;  /* Arbitrarily chosen */
d237 1
a237 37
	while (nums--) {
		if (sspi == tspi)  /* Specific SPI asked. */
			spi = tspi;
		else    /* Range specified */
			spi = sspi + (arc4random() % (tspi - sspi));

		/* Don't allocate reserved SPIs.  */
		if (spi >= SPI_RESERVED_MIN && spi <= SPI_RESERVED_MAX)
			continue;
		else
			spi = htonl(spi);

		/* Check whether we're using this SPI already. */
		s = spltdb();
		tdbp = gettdb(spi, dst, sproto);
		splx(s);

		if (tdbp != (struct tdb *) NULL)
			continue;

		tdbp = tdb_alloc();

		tdbp->tdb_spi = spi;
		bcopy(&dst->sa, &tdbp->tdb_dst.sa, SA_LEN(&dst->sa));
		bcopy(&src->sa, &tdbp->tdb_src.sa, SA_LEN(&src->sa));
		tdbp->tdb_sproto = sproto;
		tdbp->tdb_flags |= TDBF_INVALID; /* Mark SA invalid for now. */
		tdbp->tdb_satype = SADB_SATYPE_UNSPEC;
		puttdb(tdbp);

		/* Setup a "silent" expiration (since TDBF_INVALID's set). */
		if (ipsec_keep_invalid > 0) {
			tdbp->tdb_flags |= TDBF_TIMER;
			tdbp->tdb_exp_timeout = ipsec_keep_invalid;
			timeout_add(&tdbp->tdb_timer_tmo,
			    hz * ipsec_keep_invalid);
		}
d239 14
a252 1
		return spi;
d255 5
a259 2
	(*errval) = EEXIST;
	return 0;
d274 2
a275 2
	u_int32_t hashval;
	struct tdb *tdbp;
d277 2
a278 2
	if (tdbh == NULL)
		return (struct tdb *) NULL;
d280 1
a280 1
	hashval = tdb_hash(spi, dst, proto);
d282 5
a286 5
	for (tdbp = tdbh[hashval]; tdbp != NULL; tdbp = tdbp->tdb_hnext)
		if ((tdbp->tdb_spi == spi) &&
		    !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)) &&
		    (tdbp->tdb_sproto == proto))
			break;
d288 1
a288 1
	return tdbp;
d296 1
a296 2
gettdbbyaddr(union sockaddr_union *dst, struct ipsec_policy *ipo,
    struct mbuf *m, int af)
d298 2
a299 5
	u_int32_t hashval;
	struct tdb *tdbp;

	if (tdbaddr == NULL)
		return (struct tdb *) NULL;
d301 2
a302 1
	hashval = tdb_hash(0, dst, ipo->ipo_sproto);
d304 21
a324 47
	for (tdbp = tdbaddr[hashval]; tdbp != NULL; tdbp = tdbp->tdb_anext)
		if ((tdbp->tdb_sproto == ipo->ipo_sproto) &&
		    ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
		    (!bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)))) {
			/*
			 * If the IDs are not set, this was probably a
			 * manually-keyed SA, so it can be used for
			 * any type of traffic.
			 */
			if (tdbp->tdb_srcid != NULL) {
				if (ipo->ipo_srcid != NULL &&
				    !ipsp_ref_match(ipo->ipo_srcid,
					tdbp->tdb_srcid))
					continue;
				/* Otherwise, this is fine. */
			} else if (ipo->ipo_srcid != NULL)
				continue;

			if (tdbp->tdb_dstid != NULL) {
				if (ipo->ipo_dstid != NULL &&
				    !ipsp_ref_match(ipo->ipo_dstid,
					tdbp->tdb_dstid))
					continue;
				/* Otherwise, this is fine. */
			} else if (ipo->ipo_dstid != NULL)
				continue;

			/* Check for credential matches. */
			if (tdbp->tdb_local_cred != NULL) {
				if (ipo->ipo_local_cred != NULL &&
				    !ipsp_ref_match(ipo->ipo_local_cred,
					tdbp->tdb_local_cred))
					continue;
			} else if (ipo->ipo_local_cred != NULL)
				continue; /* If no credential was used
					   * in the TDB, try to
					   * establish a new SA with
					   * the given credential,
					   * since some type of access
					   * control may be done on
					   * the other side based on
					   * that credential.
					   */

			/* XXX Check for filter matches. */
			break;
		}
d326 1
a326 1
	return tdbp;
d334 1
a334 2
gettdbbysrc(union sockaddr_union *src, struct ipsec_policy *ipo,
    struct mbuf *m, int af)
d336 2
a337 5
	u_int32_t hashval;
	struct tdb *tdbp;

	if (tdbsrc == NULL)
		return (struct tdb *) NULL;
d339 2
a340 1
	hashval = tdb_hash(0, src, ipo->ipo_sproto);
d342 17
a358 30
	for (tdbp = tdbsrc[hashval]; tdbp != NULL; tdbp = tdbp->tdb_snext)
		if ((tdbp->tdb_sproto == ipo->ipo_sproto) &&
		    ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
		    (!bcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa)))) {
			/*
			 * If the IDs are not set, this was probably a
			 * manually-keyed SA, so it can be used for
			 * any type of traffic.
			 */
			if (tdbp->tdb_srcid != NULL) {
				if (ipo->ipo_dstid != NULL &&
				    !ipsp_ref_match(ipo->ipo_dstid,
					tdbp->tdb_srcid))
					continue;
				/* Otherwise, this is fine. */
			} else if (ipo->ipo_dstid != NULL)
				continue;

			if (tdbp->tdb_dstid != NULL) {
				if (ipo->ipo_srcid != NULL &&
				    !ipsp_ref_match(ipo->ipo_srcid,
					tdbp->tdb_dstid))
					continue;
				/* Otherwise, this is fine. */
			} else if (ipo->ipo_srcid != NULL)
				continue;

			/* XXX Check for filter matches. */
			break;
		}
d360 1
a360 1
	return tdbp;
d367 2
a368 16
	int i, cnt, buckets[16];
	struct tdb *tdbp;

	if (tdbh == NULL) {
		db_printf("no tdb hash table\n");
		return;
	}

	bzero (buckets, sizeof(buckets));
	for (i = 0; i <= tdb_hashmask; i++) {
		cnt = 0;
		for (tdbp = tdbh[i]; cnt < 16 && tdbp != NULL;
		     tdbp = tdbp->tdb_hnext)
			cnt++;
		buckets[cnt]++;
	}
d370 19
a388 5
	db_printf("tdb cnt\t\tbucket cnt\n");
	for (i = 0; i < 16; i++)
		if (buckets[i] > 0)
			db_printf("%d%c\t\t%d\n", i, i == 15 ? "+" : "",
			    buckets[i]);
d398 2
a399 2
	int i, rval = 0;
	struct tdb *tdbp, *next;
d401 2
a402 2
	if (tdbh == NULL)
		return ENOENT;
d404 9
a412 8
	for (i = 0; i <= tdb_hashmask; i++)
		for (tdbp = tdbh[i]; rval == 0 && tdbp != NULL; tdbp = next) {
			next = tdbp->tdb_hnext;
			if (i == tdb_hashmask && next == NULL)
				rval = walker(tdbp, (void *)arg, 1);
			else
				rval = walker(tdbp, (void *)arg, 0);
		}
d414 1
a414 1
	return rval;
d442 1
a442 1
        /* If the TDB hasn't been used, don't renew it. */
d456 1
a456 1
	/* Soft expirations. */
d469 1
a469 1
	/* If the TDB hasn't been used, don't renew it. */
d481 44
a524 42
	struct tdb **new_tdbh, **new_tdbaddr, **new_srcaddr, *tdbp, *tdbnp;
	u_int i, old_hashmask = tdb_hashmask;
	u_int32_t hashval;

	tdb_hashmask = (tdb_hashmask << 1) | 1;

	MALLOC(new_tdbh, struct tdb **,
	    sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);
	MALLOC(new_tdbaddr, struct tdb **,
	    sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);
	MALLOC(new_srcaddr, struct tdb **,
	    sizeof(struct tdb *) * (tdb_hashmask + 1), M_TDB, M_WAITOK);

	bzero(new_tdbh, sizeof(struct tdb *) * (tdb_hashmask + 1));
	bzero(new_tdbaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));
	bzero(new_srcaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));

	for (i = 0; i <= old_hashmask; i++) {
		for (tdbp = tdbh[i]; tdbp != NULL; tdbp = tdbnp) {
			tdbnp = tdbp->tdb_hnext;
			hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst,
			    tdbp->tdb_sproto);
			tdbp->tdb_hnext = new_tdbh[hashval];
			new_tdbh[hashval] = tdbp;
		}

		for (tdbp = tdbaddr[i]; tdbp != NULL; tdbp = tdbnp) {
			tdbnp = tdbp->tdb_anext;
			hashval = tdb_hash(0, &tdbp->tdb_dst,
			    tdbp->tdb_sproto);
			tdbp->tdb_anext = new_tdbaddr[hashval];
			new_tdbaddr[hashval] = tdbp;
		}

		for (tdbp = tdbsrc[i]; tdbp != NULL; tdbp = tdbnp) {
			tdbnp = tdbp->tdb_snext;
			hashval = tdb_hash(0, &tdbp->tdb_src,
			    tdbp->tdb_sproto);
			tdbp->tdb_snext = new_srcaddr[hashval];
			new_srcaddr[hashval] = tdbp;
		}
	}
d526 2
a527 2
	FREE(tdbh, M_TDB);
	tdbh = new_tdbh;
d529 2
a530 2
	FREE(tdbaddr, M_TDB);
	tdbaddr = new_tdbaddr;
d532 2
a533 2
	FREE(tdbsrc, M_TDB);
	tdbsrc = new_srcaddr;
d542 2
a543 18
	u_int32_t hashval;
	int s = spltdb();

	if (tdbh == NULL) {
		MALLOC(tdbh, struct tdb **,
		    sizeof(struct tdb *) * (tdb_hashmask + 1),
		    M_TDB, M_WAITOK);
		MALLOC(tdbaddr, struct tdb **,
		    sizeof(struct tdb *) * (tdb_hashmask + 1),
		    M_TDB, M_WAITOK);
		MALLOC(tdbsrc, struct tdb **,
		    sizeof(struct tdb *) * (tdb_hashmask + 1),
		    M_TDB, M_WAITOK);

		bzero(tdbh, sizeof(struct tdb *) * (tdb_hashmask + 1));
		bzero(tdbaddr, sizeof(struct tdb *) * (tdb_hashmask + 1));
		bzero(tdbsrc, sizeof(struct tdb *) * (tdb_hashmask + 1));
	}
d545 29
d575 1
d577 2
a578 17
	/*
	 * Rehash if this tdb would cause a bucket to have more than
	 * two items and if the number of tdbs exceed 10% of the
	 * bucket count.  This number is arbitratily chosen and is
	 * just a measure to not keep rehashing when adding and
	 * removing tdbs which happens to always end up in the same
	 * bucket, which is not uncommon when doing manual keying.
	 */
	if (tdbh[hashval] != NULL && tdbh[hashval]->tdb_hnext != NULL &&
	    tdb_count * 10 > tdb_hashmask + 1) {
		tdb_rehash();
		hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst,
		    tdbp->tdb_sproto);
	}

	tdbp->tdb_hnext = tdbh[hashval];
	tdbh[hashval] = tdbp;
d580 3
a582 3
	hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);
	tdbp->tdb_anext = tdbaddr[hashval];
	tdbaddr[hashval] = tdbp;
d584 3
a586 3
	hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);
	tdbp->tdb_snext = tdbsrc[hashval];
	tdbsrc[hashval] = tdbp;
d588 1
a588 1
	tdb_count++;
d590 1
a590 1
	ipsec_last_added = time.tv_sec;
d592 1
a592 1
	splx(s);
d601 126
a726 25
	struct ipsec_policy *ipo;
	struct tdb *tdbpp;
	struct inpcb *inp;
	u_int32_t hashval;
	int s;

	if (tdbh == NULL)
		return;

	hashval = tdb_hash(tdbp->tdb_spi, &tdbp->tdb_dst, tdbp->tdb_sproto);

	s = spltdb();
	if (tdbh[hashval] == tdbp) {
		tdbpp = tdbp;
		tdbh[hashval] = tdbp->tdb_hnext;
	} else {
		for (tdbpp = tdbh[hashval]; tdbpp != NULL;
		     tdbpp = tdbpp->tdb_hnext) {
			if (tdbpp->tdb_hnext == tdbp) {
				tdbpp->tdb_hnext = tdbp->tdb_hnext;
				tdbpp = tdbp;
				break;
			}
		}
	}
d728 2
a729 1
	tdbp->tdb_hnext = NULL;
d731 2
a732 1
	hashval = tdb_hash(0, &tdbp->tdb_dst, tdbp->tdb_sproto);
d734 1
a734 107
	if (tdbaddr[hashval] == tdbp) {
		tdbpp = tdbp;
		tdbaddr[hashval] = tdbp->tdb_anext;
	} else {
		for (tdbpp = tdbaddr[hashval]; tdbpp != NULL;
		     tdbpp = tdbpp->tdb_anext) {
			if (tdbpp->tdb_anext == tdbp) {
				tdbpp->tdb_anext = tdbp->tdb_anext;
				tdbpp = tdbp;
				break;
			}
		}
	}

	hashval = tdb_hash(0, &tdbp->tdb_src, tdbp->tdb_sproto);

	if (tdbsrc[hashval] == tdbp) {
		tdbpp = tdbp;
		tdbsrc[hashval] = tdbp->tdb_snext;
	}
	else {
		for (tdbpp = tdbsrc[hashval]; tdbpp != NULL;
		     tdbpp = tdbpp->tdb_snext) {
			if (tdbpp->tdb_snext == tdbp) {
				tdbpp->tdb_snext = tdbp->tdb_snext;
				tdbpp = tdbp;
				break;
			}
		}
	}

	tdbp->tdb_snext = NULL;

	if (tdbp->tdb_xform) {
		(*(tdbp->tdb_xform->xf_zeroize))(tdbp);
		tdbp->tdb_xform = NULL;
	}

	/* Cleanup inp references. */
	for (inp = TAILQ_FIRST(&tdbp->tdb_inp_in); inp;
	     inp = TAILQ_FIRST(&tdbp->tdb_inp_in)) {
		TAILQ_REMOVE(&tdbp->tdb_inp_in, inp, inp_tdb_in_next);
		inp->inp_tdb_in = NULL;
	}

	for (inp = TAILQ_FIRST(&tdbp->tdb_inp_out); inp;
	     inp = TAILQ_FIRST(&tdbp->tdb_inp_out)) {
		TAILQ_REMOVE(&tdbp->tdb_inp_out, inp, inp_tdb_out_next);
		inp->inp_tdb_out = NULL;
	}

	/* Cleanup SPD references. */
	for (ipo = TAILQ_FIRST(&tdbp->tdb_policy_head); ipo;
	     ipo = TAILQ_FIRST(&tdbp->tdb_policy_head))	{
		TAILQ_REMOVE(&tdbp->tdb_policy_head, ipo, ipo_tdb_next);
		ipo->ipo_tdb = NULL;
		ipo->ipo_last_searched = 0; /* Force a re-search. */
	}

	/* Remove expiration timeouts. */
	tdbp->tdb_flags &= ~(TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE | TDBF_TIMER |
	    TDBF_SOFT_TIMER);
	timeout_del(&tdbp->tdb_timer_tmo);
	timeout_del(&tdbp->tdb_first_tmo);
	timeout_del(&tdbp->tdb_stimer_tmo);
	timeout_del(&tdbp->tdb_sfirst_tmo);

	if (tdbp->tdb_local_auth) {
		ipsp_reffree(tdbp->tdb_local_auth);
		tdbp->tdb_local_auth = NULL;
	}

	if (tdbp->tdb_remote_auth) {
		ipsp_reffree(tdbp->tdb_remote_auth);
		tdbp->tdb_remote_auth = NULL;
	}

	if (tdbp->tdb_srcid) {
		ipsp_reffree(tdbp->tdb_srcid);
		tdbp->tdb_srcid = NULL;
	}

	if (tdbp->tdb_dstid) {
		ipsp_reffree(tdbp->tdb_dstid);
		tdbp->tdb_dstid = NULL;
	}

	if (tdbp->tdb_local_cred) {
		ipsp_reffree(tdbp->tdb_local_cred);
		tdbp->tdb_local_cred = NULL;
	}

	if (tdbp->tdb_remote_cred) {
		ipsp_reffree(tdbp->tdb_remote_cred);
		tdbp->tdb_local_cred = NULL;
	}

	if ((tdbp->tdb_onext) && (tdbp->tdb_onext->tdb_inext == tdbp))
		tdbp->tdb_onext->tdb_inext = NULL;

	if ((tdbp->tdb_inext) && (tdbp->tdb_inext->tdb_onext == tdbp))
		tdbp->tdb_inext->tdb_onext = NULL;

	FREE(tdbp, M_TDB);
	tdb_count--;

	splx(s);
d748 1
a748 1
	/* Init Incoming SA-Binding Queues. */
d754 1
a754 1
	/* Record establishment time. */
d758 1
a758 1
	/* Initialize timeouts. */
d773 7
a779 2
	struct xformsw *xsp;
	int err;
d781 5
a785 6
	for (xsp = xformsw; xsp < xformswNXFORMSW; xsp++) {
		if (xsp->xf_type == alg) {
			err = (*(xsp->xf_init))(tdbp, xsp, ii);
			return err;
		}
	}
d787 3
a789 3
	DPRINTF(("tdb_init(): no alg %d for spi %08x, addr %s, proto %d\n",
	    alg, ntohl(tdbp->tdb_spi), ipsp_address(tdbp->tdb_dst),
	    tdbp->tdb_sproto));
d791 1
a791 1
	return EINVAL;
a793 1
#ifdef KERNFS
d795 1
a795 1
 * Print TDB information on a buffer.
d798 1
a798 1
ipsp_print_tdb(struct tdb *tdb, char *buffer)
d800 33
a832 16
	int l, i, k;

	struct ctlname ipspflags[] = { \
				       { "unique", TDBF_UNIQUE }, \
				       { "invalid", TDBF_INVALID }, \
				       { "halfiv", TDBF_HALFIV }, \
				       { "pfs", TDBF_PFS }, \
				       { "tunneling", TDBF_TUNNELING }, \
				       { "noreplay", TDBF_NOREPLAY }, \
				       { "random padding", TDBF_RANDOMPADDING }, \
				       { "skipcrypto", TDBF_SKIPCRYPTO }, \
				       { "usedtunnel", TDBF_USEDTUNNEL }, \
	};

	l = sprintf(buffer,  "SPI = %08x, Destination = %s, Sproto = %u\n",
	    ntohl(tdb->tdb_spi), ipsp_address(tdb->tdb_dst), tdb->tdb_sproto);
d834 2
a835 2
	l += sprintf(buffer + l, "\tEstablished %d seconds ago\n",
	    time.tv_sec - tdb->tdb_established);
d837 2
a838 1
	l += sprintf(buffer + l, "\tSource = %s", ipsp_address(tdb->tdb_src));
d840 1
a840 1
	if (tdb->tdb_proxy.sa.sa_family)
d842 2
a843 2
		    ipsp_address(tdb->tdb_proxy));
	else
d846 7
a852 25
	if (tdb->tdb_mtu && tdb->tdb_mtutimeout > time.tv_sec)
		l += sprintf(buffer + l, "\tMTU: %d, expires in %qu seconds\n",
		    tdb->tdb_mtu, tdb->tdb_mtutimeout - time.tv_sec);

	if (tdb->tdb_local_cred)
		l += sprintf(buffer + l, "\tLocal credential type %d\n",
		    ((struct ipsec_ref *) tdb->tdb_local_cred)->ref_type);

	if (tdb->tdb_remote_cred)
		l += sprintf(buffer + l, "\tRemote credential type %d\n",
		    ((struct ipsec_ref *) tdb->tdb_remote_cred)->ref_type);

	if (tdb->tdb_local_auth)
		l += sprintf(buffer + l, "\tLocal auth type %d\n",
		    ((struct ipsec_ref *) tdb->tdb_local_auth)->ref_type);

	if (tdb->tdb_remote_auth)
		l += sprintf(buffer + l, "\tRemote auth type %d\n",
		    ((struct ipsec_ref *) tdb->tdb_remote_auth)->ref_type);

	l += sprintf(buffer + l, "\tFlags (%08x) = <", tdb->tdb_flags);

	if ((tdb->tdb_flags & ~(TDBF_TIMER | TDBF_BYTES | TDBF_ALLOCATIONS |
	    TDBF_FIRSTUSE | TDBF_SOFT_TIMER | TDBF_SOFT_BYTES |
	    TDBF_SOFT_FIRSTUSE | TDBF_SOFT_ALLOCATIONS)) == 0)
d854 78
a931 15
	else {
		for (k = 0, i = 0;
		    k < sizeof(ipspflags) / sizeof(struct ctlname); k++) {
			if (tdb->tdb_flags & ipspflags[k].ctl_type) {
				l += sprintf(buffer + l, "%s,",
				    ipspflags[k].ctl_name);
				i = 1;
			}
		}

		/* If we added flags, remove trailing comma. */
		if (i)
			l--;
		l += sprintf(buffer + l, ">\n");
	}
d933 1
a933 1
	l += sprintf(buffer + l, "\tCrypto ID: %qu\n", tdb->tdb_cryptoid);
d935 1
a935 1
	if (tdb->tdb_xform)
d937 1
a937 1
		    tdb->tdb_xform->xf_name);
d939 1
a939 1
	if (tdb->tdb_encalgxform)
d941 1
a941 1
		    tdb->tdb_encalgxform->name);
d943 1
a943 1
	if (tdb->tdb_authalgxform)
d945 1
a945 1
		    tdb->tdb_authalgxform->name);
d947 1
a947 1
	if (tdb->tdb_onext)
d949 5
a953 18
		    "\tNext SA: SPI = %08x, Destination = %s, Sproto = %u\n",
		    ntohl(tdb->tdb_onext->tdb_spi),
		    ipsp_address(tdb->tdb_onext->tdb_dst),
		    tdb->tdb_onext->tdb_sproto);

	if (tdb->tdb_inext)
		l += sprintf(buffer + l, "\tPrevious SA: SPI = %08x, "
		    "Destination = %s, Sproto = %u\n",
		    ntohl(tdb->tdb_inext->tdb_spi),
		    ipsp_address(tdb->tdb_inext->tdb_dst),
		    tdb->tdb_inext->tdb_sproto);

	l += sprintf(buffer + l, "\t%qu bytes processed by this SA\n",
	    tdb->tdb_cur_bytes);

	if (tdb->tdb_last_used)
		l += sprintf(buffer + l, "\tLast used %qu seconds ago\n",
		    time.tv_sec - tdb->tdb_last_used);
d955 1
a955 1
	if (tdb->tdb_last_marked)
d957 8
a964 2
		    "\tLast marked/unmarked %qu seconds ago\n",
		    time.tv_sec - tdb->tdb_last_marked);
d966 1
a966 1
	l += sprintf(buffer + l, "\tExpirations:\n");
d968 1
a968 1
	if (tdb->tdb_flags & TDBF_TIMER)
d970 3
a972 2
		    "\t\tHard expiration(1) in %qu seconds\n",
		    tdb->tdb_established + tdb->tdb_exp_timeout - time.tv_sec);
d974 1
a974 1
	if (tdb->tdb_flags & TDBF_SOFT_TIMER)
d976 3
a978 3
		    "\t\tSoft expiration(1) in %qu seconds\n",
		    tdb->tdb_established + tdb->tdb_soft_timeout -
		    time.tv_sec);
d980 1
a980 1
	if (tdb->tdb_flags & TDBF_BYTES)
d982 2
a983 2
		    "\t\tHard expiration after %qu bytes\n",
		    tdb->tdb_exp_bytes);
d985 1
a985 1
	if (tdb->tdb_flags & TDBF_SOFT_BYTES)
d987 2
a988 2
		    "\t\tSoft expiration after %qu bytes\n",
		    tdb->tdb_soft_bytes);
d990 1
a990 1
	if (tdb->tdb_flags & TDBF_ALLOCATIONS)
d992 2
a993 2
		    "\t\tHard expiration after %u flows\n",
		    tdb->tdb_exp_allocations);
d995 1
a995 1
	if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS)
d997 2
a998 27
		    "\t\tSoft expiration after %u flows\n",
		    tdb->tdb_soft_allocations);

	if (tdb->tdb_flags & TDBF_FIRSTUSE) {
		if (tdb->tdb_first_use)
			l += sprintf(buffer + l,
			    "\t\tHard expiration(2) in %qu seconds\n",
			    (tdb->tdb_first_use + tdb->tdb_exp_first_use) -
			    time.tv_sec);
		else
			l += sprintf(buffer + l,
			    "\t\tHard expiration in %qu seconds "
			    "after first use\n",
			    tdb->tdb_exp_first_use);
	}

	if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE) {
		if (tdb->tdb_first_use)
			l += sprintf(buffer + l,
			    "\t\tSoft expiration(2) in %qu seconds\n",
			    (tdb->tdb_first_use + tdb->tdb_soft_first_use) -
			    time.tv_sec);
		else
			l += sprintf(buffer + l,
			    "\t\tSoft expiration in %qu seconds "
			    "after first use\n", tdb->tdb_soft_first_use);
	}
d1000 32
a1031 4
	if (!(tdb->tdb_flags &
	    (TDBF_TIMER | TDBF_SOFT_TIMER | TDBF_BYTES |
		TDBF_SOFT_ALLOCATIONS | TDBF_ALLOCATIONS |
		TDBF_SOFT_BYTES | TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE)))
d1034 1
a1034 1
	l += sprintf(buffer + l, "\n");
d1036 6
a1041 1
	return l;
a1044 42
 * Used by kernfs.
 */
int
ipsp_kern(int off, char **bufp, int len)
{
	static char buffer[IPSEC_KERNFS_BUFSIZE];
	struct tdb *tdb;
	int i, s, l;

	if (bufp == NULL)
		return 0;

	bzero(buffer, IPSEC_KERNFS_BUFSIZE);
	*bufp = buffer;

	if (off == 0) {
		kernfs_epoch++;
		l = sprintf(buffer, "Hashmask: %d, policy entries: %d\n",
		    tdb_hashmask, ipsec_in_use);
		return l;
	}

	if (tdbh == NULL)
		return 0;

	for (i = 0; i <= tdb_hashmask; i++) {
		s = spltdb();
		for (tdb = tdbh[i]; tdb; tdb = tdb->tdb_hnext) {
			if (tdb->tdb_epoch != kernfs_epoch) {
				tdb->tdb_epoch = kernfs_epoch;
				l = ipsp_print_tdb(tdb, buffer);
				splx(s);
				return l;
			}
		}
		splx(s);
	}
	return 0;
}
#endif /* KERNFS */

/*
d1050 1
a1050 1
	u_int8_t sareq = 0;
d1052 18
a1069 15
	if (inp != NULL) {
		sareq |= inp->inp_seclevel[SL_AUTH] >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_AUTH : 0;
		sareq |= inp->inp_seclevel[SL_ESP_TRANS] >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_CONF : 0;
		sareq |= inp->inp_seclevel[SL_ESP_NETWORK] >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_TUNNEL : 0;
	} else {
		sareq |= ipsec_auth_default_level >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_AUTH : 0;
		sareq |= ipsec_esp_trans_default_level >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_CONF : 0;
		sareq |= ipsec_esp_network_default_level >= IPSEC_LEVEL_USE ?
		    NOTIFY_SATYPE_TUNNEL : 0;
	}
d1071 1
a1071 1
	return (sareq);
d1080 27
a1106 19
	if (inout) {
		if (inp->inp_tdb_in) {
			if (inp->inp_tdb_in == tdb)
				return;

			TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in, inp,
			    inp_tdb_in_next);
		}

		inp->inp_tdb_in = tdb;
		TAILQ_INSERT_TAIL(&tdb->tdb_inp_in, inp, inp_tdb_in_next);
	} else {
		if (inp->inp_tdb_out) {
			if (inp->inp_tdb_out == tdb)
				return;

			TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out, inp,
			    inp_tdb_out_next);
		}
d1108 2
a1109 3
		inp->inp_tdb_out = tdb;
		TAILQ_INSERT_TAIL(&tdb->tdb_inp_out, inp, inp_tdb_out_next);
	}
d1116 3
a1118 3
	static char buf[4][4 * sizeof "123" + 4];
	unsigned char *ucp = (unsigned char *) &ina;
	static int i = 3;
d1120 2
a1121 2
	i = (i + 1) % 4;
	sprintf(buf[i], "%d.%d.%d.%d", ucp[0] & 0xff, ucp[1] & 0xff,
d1123 1
a1123 1
	return (buf[i]);
d1130 2
a1131 1
	switch (sa.sa.sa_family) {
d1134 1
a1134 1
		return inet_ntoa4(sa.sin.sin_addr);
d1139 1
a1139 27
		return ip6_sprintf(&sa.sin6.sin6_addr);
#endif /* INET6 */

	default:
		return "(unknown address family)";
	}
}

/* Check whether an IP{4,6} address is unspecified. */
int
ipsp_is_unspecified(union sockaddr_union addr)
{
	switch (addr.sa.sa_family) {
#ifdef INET
	case AF_INET:
		if (addr.sin.sin_addr.s_addr == INADDR_ANY)
			return 1;
		else
			return 0;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
		if (IN6_IS_ADDR_UNSPECIFIED(&addr.sin6.sin6_addr))
			return 1;
		else
			return 0;
a1141 1
	case 0: /* No family set. */
d1143 2
a1144 2
		return 1;
	}
d1147 20
a1166 290
/* Free reference-counted structure. */
void
ipsp_reffree(struct ipsec_ref *ipr)
{
#ifdef DIAGNOSTIC
	if (ipr->ref_count <= 0)
		printf("ipsp_reffree: illegal reference count %d for "
		    "object %p (len = %d, malloctype = %d)\n",
		    ipr->ref_count, ipr, ipr->ref_len, ipr->ref_malloctype);
#endif
	if (--ipr->ref_count <= 0)
		FREE(ipr, ipr->ref_malloctype);
}

/* Mark a TDB as TDBF_SKIPCRYPTO. */
void
ipsp_skipcrypto_mark(struct tdb_ident *tdbi)
{
	struct tdb *tdb;
	int s = spltdb();
 
	tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
	if (tdb != NULL) {
		tdb->tdb_flags |= TDBF_SKIPCRYPTO;
		tdb->tdb_last_marked = time.tv_sec;
	}
	splx(s);
}

/* Unmark a TDB as TDBF_SKIPCRYPTO. */
void
ipsp_skipcrypto_unmark(struct tdb_ident *tdbi)
{
	struct tdb *tdb;
	int s = spltdb();
 
	tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
	if (tdb != NULL) {
		tdb->tdb_flags &= ~TDBF_SKIPCRYPTO;
		tdb->tdb_last_marked = time.tv_sec;
	}
	splx(s);
}

/*
 * Go down a chain of IPv4/IPv6/ESP/AH/IPiP chains creating an tag for each
 * IPsec header encountered. The offset where the first header, as well
 * as its type are given to us.
 */
struct m_tag *
ipsp_parse_headers(struct mbuf *m, int off, u_int8_t proto)
{
	int ipv4sa = 0, s, esphlen = 0, trail = 0, i;
	SLIST_HEAD(packet_tags, m_tag) tags;
	unsigned char lasteight[8];
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
	struct tdb *tdb;

#ifdef INET
	struct ip iph;
#endif /* INET */

#ifdef INET6
	struct in6_addr ip6_dst;
#endif /* INET6 */

	/* We have to start with a known network protocol. */
	if (proto != IPPROTO_IPV4 && proto != IPPROTO_IPV6)
		return NULL;

	SLIST_INIT(&tags);

	while (1) {
		switch (proto) {
#ifdef INET
		case IPPROTO_IPV4: /* Also IPPROTO_IPIP */
		{
			/*
			 * Save the IP header (we need both the
			 * address and ip_hl).
			 */
			m_copydata(m, off, sizeof(struct ip), (caddr_t) &iph);
			ipv4sa = 1;
			proto = iph.ip_p;
			off += iph.ip_hl << 2;
			break;
		}
#endif /* INET */

#ifdef INET6
		case IPPROTO_IPV6:
		{
			int nxtp, l;

			/* Copy the IPv6 address. */
			m_copydata(m, off + offsetof(struct ip6_hdr, ip6_dst),
			    sizeof(struct ip6_hdr), (caddr_t) &ip6_dst);
			ipv4sa = 0;

			/*
			 * Go down the chain of headers until we encounter a
			 * non-option.
			 */
			for (l = ip6_nexthdr(m, off, proto, &nxtp); l != -1;
			     l = ip6_nexthdr(m, off, proto, &nxtp)) {
				off += l;
				proto = nxtp;

				/* Construct a tag. */
				if (nxtp == IPPROTO_AH)	{
					mtag = m_tag_get(PACKET_TAG_IPSEC_IN_CRYPTO_DONE,
					    sizeof(struct tdb_ident),
					    M_NOWAIT);

					if (mtag == NULL)
						return tags.slh_first;

					tdbi = (struct tdb_ident *) (mtag + 1);
					bzero(tdbi, sizeof(struct tdb_ident));

					m_copydata(m, off + sizeof(u_int32_t),
					    sizeof(u_int32_t),
					    (caddr_t) &tdbi->spi);

					tdbi->proto = IPPROTO_AH;
					tdbi->dst.sin6.sin6_family = AF_INET6;
					tdbi->dst.sin6.sin6_len =
					    sizeof(struct sockaddr_in6);
					tdbi->dst.sin6.sin6_addr = ip6_dst;
					SLIST_INSERT_HEAD(&tags,
					    mtag, m_tag_link);
				}
				else
					if (nxtp == IPPROTO_IPV6)
						m_copydata(m, off +
						    offsetof(struct ip6_hdr,
							ip6_dst),
						    sizeof(struct ip6_hdr),
						    (caddr_t) &ip6_dst);
			}
			break;
		}
#endif /* INET6 */

		case IPPROTO_ESP:
		/* Verify that this has been decrypted. */
		{
			union sockaddr_union su;
			u_int32_t spi;

			m_copydata(m, off, sizeof(u_int32_t), (caddr_t) &spi);
			bzero(&su, sizeof(union sockaddr_union));

			s = spltdb();

#ifdef INET
			if (ipv4sa) {
				su.sin.sin_family = AF_INET;
				su.sin.sin_len = sizeof(struct sockaddr_in);
				su.sin.sin_addr = iph.ip_dst;
			}
#endif /* INET */

#ifdef INET6
			if (!ipv4sa) {
				su.sin6.sin6_family = AF_INET6;
				su.sin6.sin6_len = sizeof(struct sockaddr_in6);
				su.sin6.sin6_addr = ip6_dst;
			}
#endif /* INET6 */

			tdb = gettdb(spi, &su, IPPROTO_ESP);
			if (tdb == NULL) {
				splx(s);
				return tags.slh_first;
			}

			/* How large is the ESP header ? We use this later. */
			if (tdb->tdb_flags & TDBF_NOREPLAY)
				esphlen = sizeof(u_int32_t) + tdb->tdb_ivlen;
			else
				esphlen = 2 * sizeof(u_int32_t) +
				    tdb->tdb_ivlen;

			/*
			 * Verify decryption. If the SA is using
			 * random padding (as the "old" ESP SAs were
			 * bound to do, there's nothing we can do to
			 * see if the payload has been decrypted.
			 */
			if (tdb->tdb_flags & TDBF_RANDOMPADDING) {
				splx(s);
				return tags.slh_first;
			}

			/* Update the length of trailing ESP authenticators. */
			if (tdb->tdb_authalgxform)
				trail += AH_HMAC_HASHLEN;

			splx(s);

			/* Copy the last 10 bytes. */
			m_copydata(m, m->m_pkthdr.len - trail - 8, 8,
			    lasteight);

			/* Verify the self-describing padding values. */
			if (lasteight[6] != 0) {
				if (lasteight[6] != lasteight[5])
					return tags.slh_first;

				for (i = 4; lasteight[i + 1] != 1 && i >= 0;
				    i--)
					if (lasteight[i + 1] !=
					    lasteight[i] + 1)
						return tags.slh_first;
			}
		}
		/* Fall through. */
		case IPPROTO_AH:
			mtag = m_tag_get(PACKET_TAG_IPSEC_IN_CRYPTO_DONE,
			    sizeof(struct tdb_ident), M_NOWAIT);
			if (mtag == NULL)
				return tags.slh_first;

			tdbi = (struct tdb_ident *) (mtag + 1);
			bzero(tdbi, sizeof(struct tdb_ident));

			/* Get SPI off the relevant header. */
			if (proto == IPPROTO_AH)
				m_copydata(m, off + sizeof(u_int32_t),
				    sizeof(u_int32_t), (caddr_t) &tdbi->spi);
			else /* IPPROTO_ESP */
				m_copydata(m, off, sizeof(u_int32_t),
				    (caddr_t) &tdbi->spi);

			tdbi->proto = proto; /* AH or ESP */

#ifdef INET
			/* Last network header was IPv4. */
			if (ipv4sa) {
				tdbi->dst.sin.sin_family = AF_INET;
				tdbi->dst.sin.sin_len =
				    sizeof(struct sockaddr_in);
				tdbi->dst.sin.sin_addr = iph.ip_dst;
			}
#endif /* INET */

#ifdef INET6
			/* Last network header was IPv6. */
			if (!ipv4sa) {
				tdbi->dst.sin6.sin6_family = AF_INET6;
				tdbi->dst.sin6.sin6_len =
				    sizeof(struct sockaddr_in6);
				tdbi->dst.sin6.sin6_addr = ip6_dst;
			}
#endif /* INET6 */

			SLIST_INSERT_HEAD(&tags, mtag, m_tag_link);

			/* Update next protocol/header and header offset. */
			if (proto == IPPROTO_AH) {
				u_int8_t foo[2];

				m_copydata(m, off, 2 * sizeof(u_int8_t), foo);
				proto = foo[0];
				off += (foo[1] + 2) << 2;
			} else {/* IPPROTO_ESP */
				/* Initialized in IPPROTO_ESP case. */
				off += esphlen;
				proto = lasteight[7];
			}
			break;

		default:
			return tags.slh_first; /* We're done. */
		}
	}
}

/* Return true if the two structures match. */
int
ipsp_ref_match(struct ipsec_ref *ref1, struct ipsec_ref *ref2)
{
	if (ref1->ref_type != ref2->ref_type ||
	    ref1->ref_len != ref2->ref_len ||
	    bcmp(ref1 + 1, ref2 + 1, ref1->ref_len))
		return 0;

	return 1;
@


1.79.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.79.2.3 2001/07/04 10:54:51 niklas Exp $	*/
a93 1
extern int	ipsec_ipcomp_default_level;
a119 3
	{ XF_IPCOMP,	XFT_COMP, "IPcomp",
	  ipcomp_attach,    ipcomp_init, ipcomp_zeroize,
	  ipcomp_input,     ipcomp_output, },
d190 1
a190 8
	if (sproto != IPPROTO_IPCOMP && 
	    (tspi < sspi || tspi <= SPI_RESERVED_MAX)) {
		(*errval) = EINVAL;
		return 0;
	}
	if (sproto == IPPROTO_IPCOMP && (tspi < sspi ||
	    tspi <= CPI_RESERVED_MAX ||
	    tspi >= CPI_PRIVATE_MIN)) {
a198 13
	/* For IPCOMP the CPI is only 16 bits long, what a good idea.... */

	if (sproto == IPPROTO_IPCOMP) {
		u_int32_t t;
		if (sspi >= 0x10000)
			sspi = 0xffff;
		if (tspi >= 0x10000)
			tspi = 0xffff;
		if (sspi > tspi) {
			t = sspi; sspi = tspi; tspi = t;
		}
	}

d309 2
a310 1
			}
d318 2
a319 1
			}
d376 2
a377 1
			}
d385 2
a386 1
			}
d859 1
a859 1
		l += sprintf(buffer + l, "\tMTU: %d, expires in %llu seconds\n",
d900 1
a900 1
	l += sprintf(buffer + l, "\tCrypto ID: %llu\n", tdb->tdb_cryptoid);
d928 1
a928 1
	l += sprintf(buffer + l, "\t%llu bytes processed by this SA\n",
d932 1
a932 1
		l += sprintf(buffer + l, "\tLast used %llu seconds ago\n",
d937 1
a937 1
		    "\tLast marked/unmarked %llu seconds ago\n",
d944 1
a944 1
		    "\t\tHard expiration(1) in %llu seconds\n",
d949 1
a949 1
		    "\t\tSoft expiration(1) in %llu seconds\n",
d955 1
a955 1
		    "\t\tHard expiration after %llu bytes\n",
d960 1
a960 1
		    "\t\tSoft expiration after %llu bytes\n",
d976 1
a976 1
			    "\t\tHard expiration(2) in %llu seconds\n",
d981 1
a981 1
			    "\t\tHard expiration in %llu seconds "
d989 1
a989 1
			    "\t\tSoft expiration(2) in %llu seconds\n",
d994 1
a994 1
			    "\t\tSoft expiration in %llu seconds "
@


1.79.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
a84 1
u_int8_t	get_sa_require  __P((struct inpcb *));
d111 1
a111 1
	{ XF_IP4,	     0,               "IPv4 Simple Encapsulation",
d431 1
a431 1
		    tdbp = tdbp->tdb_hnext)
d493 1
a493 1
	/* If the TDB hasn't been used, don't renew it. */
d668 1
a668 1
		    tdbpp = tdbpp->tdb_hnext) {
d686 1
a686 1
		    tdbpp = tdbpp->tdb_anext) {
d703 1
a703 1
		    tdbpp = tdbpp->tdb_snext) {
d721 1
a721 1
	    inp = TAILQ_FIRST(&tdbp->tdb_inp_in)) {
d727 1
a727 1
	    inp = TAILQ_FIRST(&tdbp->tdb_inp_out)) {
d734 1
a734 1
	    ipo = TAILQ_FIRST(&tdbp->tdb_policy_head))	{
d851 11
a861 10
	struct ctlname ipspflags[] = {
		{ "unique", TDBF_UNIQUE },
		{ "invalid", TDBF_INVALID },
		{ "halfiv", TDBF_HALFIV },
		{ "pfs", TDBF_PFS },
		{ "tunneling", TDBF_TUNNELING },
		{ "noreplay", TDBF_NOREPLAY },
		{ "random padding", TDBF_RANDOMPADDING },
		{ "skipcrypto", TDBF_SKIPCRYPTO },
		{ "usedtunnel", TDBF_USEDTUNNEL },
a933 4
	if (tdb->tdb_compalgxform)
		l += sprintf(buffer + l, "\t\tCompression = <%s>\n",
		    tdb->tdb_compalgxform->name);

d1139 1
a1139 1
	    ucp[2] & 0xff, ucp[3] & 0xff);
d1295 1
a1295 1
			    l = ip6_nexthdr(m, off, proto, &nxtp)) {
@


1.79.2.6
log
@Merge in -current from roughly a week ago
@
text
@d83 7
a89 7
int		ipsp_kern(int, char **, int);
u_int8_t	get_sa_require(struct inpcb *);
void		tdb_rehash(void);
void		tdb_timeout(void *v);
void		tdb_firstuse(void *v);
void		tdb_soft_timeout(void *v);
void		tdb_soft_firstuse(void *v);
@


1.79.2.7
log
@Sync the SMP branch with 3.3
@
text
@d194 1
a194 1
	if (sproto != IPPROTO_IPCOMP &&
a302 48
 * Check that credentials and IDs match. Return true if so. The t*
 * range of arguments contains information from TDBs; the p*
 * range of arguments contains information from policies or
 * already established TDBs.
 */
int
ipsp_aux_match(struct ipsec_ref *tsrcid, struct ipsec_ref *psrcid,
    struct ipsec_ref *tdstid, struct ipsec_ref *pdstid,
    struct ipsec_ref *tlcred, struct ipsec_ref *plcred,
    struct ipsec_ref *trcred, struct ipsec_ref *prcred,
    struct sockaddr_encap *tfilter, struct sockaddr_encap *pfilter,
    struct sockaddr_encap *tfiltermask, struct sockaddr_encap *pfiltermask)
{
	if (psrcid != NULL)
		if (tsrcid == NULL || !ipsp_ref_match(tsrcid, psrcid))
			return 0;

	if (pdstid != NULL)
		if (tdstid == NULL || !ipsp_ref_match(tdstid, pdstid))
			return 0;

	if (plcred != NULL)
		if (tlcred == NULL || !ipsp_ref_match(tlcred, plcred))
			return 0;

	if (prcred != NULL)
		if (trcred == NULL || !ipsp_ref_match(trcred, prcred))
			return 0;

	/* Check for filter matches. */
	if (tfilter->sen_type) {
		/*
		 * XXX We should really be doing a subnet-check (see
		 * whether the TDB-associated filter is a subset
		 * of the policy's. For now, an exact match will solve
		 * most problems (all this will do is make every
		 * policy get its own SAs).
		 */
		if (bcmp(tfilter, pfilter, sizeof(struct sockaddr_encap)) ||
		    bcmp(tfiltermask, pfiltermask,
			sizeof(struct sockaddr_encap)))
			return 0;
	}

	return 1;
}

/*
d307 2
a308 4
gettdbbyaddr(union sockaddr_union *dst, u_int8_t sproto,
    struct ipsec_ref *srcid, struct ipsec_ref *dstid,
    struct ipsec_ref *local_cred, struct mbuf *m, int af,
    struct sockaddr_encap *filter, struct sockaddr_encap *filtermask)
d316 1
a316 1
	hashval = tdb_hash(0, dst, sproto);
d319 1
a319 1
		if ((tdbp->tdb_sproto == sproto) &&
d322 39
a360 6
			/* Do IDs and local credentials match ? */
			if (!ipsp_aux_match(tdbp->tdb_srcid, srcid,
			    tdbp->tdb_dstid, dstid, tdbp->tdb_local_cred,
			    local_cred, NULL, NULL, &tdbp->tdb_filter, filter,
			    &tdbp->tdb_filtermask, filtermask))
				continue;
d372 2
a373 4
gettdbbysrc(union sockaddr_union *src, u_int8_t sproto,
    struct ipsec_ref *srcid, struct ipsec_ref *dstid,
    struct mbuf *m, int af, struct sockaddr_encap *filter,
    struct sockaddr_encap *filtermask)
d381 1
a381 1
	hashval = tdb_hash(0, src, sproto);
d384 1
a384 1
		if ((tdbp->tdb_sproto == sproto) &&
d387 22
a408 6
			/* Check whether IDs match */
			if (!ipsp_aux_match(tdbp->tdb_srcid, dstid,
			    tdbp->tdb_dstid, srcid, NULL, NULL, NULL, NULL,
			    &tdbp->tdb_filter, filter, &tdbp->tdb_filtermask,
			    filtermask))
				continue;
d1213 1
a1213 1

d1228 1
a1228 1

a1236 13
/* Return true if the two structures match. */
int
ipsp_ref_match(struct ipsec_ref *ref1, struct ipsec_ref *ref2)
{
	if (ref1->ref_type != ref2->ref_type ||
	    ref1->ref_len != ref2->ref_len ||
	    bcmp(ref1 + 1, ref2 + 1, ref1->ref_len))
		return 0;

	return 1;
}

#ifdef notyet
d1309 1
a1309 1
						return SLIST_FIRST(&tags);
d1368 1
a1368 1
				return SLIST_FIRST(&tags);
d1386 1
a1386 1
				return SLIST_FIRST(&tags);
d1402 1
a1402 1
					return SLIST_FIRST(&tags);
d1408 1
a1408 1
						return SLIST_FIRST(&tags);
d1416 1
a1416 1
				return SLIST_FIRST(&tags);
d1468 1
a1468 1
			return SLIST_FIRST(&tags); /* We're done. */
d1472 12
a1483 1
#endif /* notyet */
@


1.79.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.79.2.7 2003/03/28 00:06:54 niklas Exp $	*/
d851 1
a851 1
ipsp_print_tdb(struct tdb *tdb, char *buffer, size_t buflen)
d853 1
a864 1
	int l, i, k;
d866 16
a881 20
	snprintf(buffer, buflen,
	    "SPI = %08x, Destination = %s, Sproto = %u\n"
	    "\tEstablished %d seconds ago\n"
	    "\tSource = %s",
	    ntohl(tdb->tdb_spi), ipsp_address(tdb->tdb_dst), tdb->tdb_sproto,
	    time.tv_sec - tdb->tdb_established,
	    ipsp_address(tdb->tdb_src));
	l = strlen(buffer);

	if (tdb->tdb_proxy.sa.sa_family) {
		snprintf(buffer + l, buflen - l,
		    ", Proxy = %s", ipsp_address(tdb->tdb_proxy));
		l += strlen(buffer + l);
	}
	snprintf(buffer + l, buflen - l, "\n");
	l += strlen(buffer + l);

	if (tdb->tdb_mtu && tdb->tdb_mtutimeout > time.tv_sec) {
		snprintf(buffer + l, buflen - l,
		    "\tMTU: %d, expires in %llu seconds\n",
a882 2
		l += strlen(buffer + l);
	}
d884 2
a885 3
	if (tdb->tdb_local_cred) {
		snprintf(buffer + l, buflen - l,
		    "\tLocal credential type %d\n",
a886 2
		l += strlen(buffer + l);
	}
d888 2
a889 3
	if (tdb->tdb_remote_cred) {
		snprintf(buffer + l, buflen - l,
		    "\tRemote credential type %d\n",
a890 2
		l += strlen(buffer + l);
	}
d892 2
a893 3
	if (tdb->tdb_local_auth) {
		snprintf(buffer + l, buflen - l,
		    "\tLocal auth type %d\n",
a894 2
		l += strlen(buffer + l);
	}
d896 2
a897 3
	if (tdb->tdb_remote_auth) {
		snprintf(buffer + l, buflen - l,
		    "\tRemote auth type %d\n",
a898 2
		l += strlen(buffer + l);
	}
d900 1
a900 3
	snprintf(buffer + l, buflen - l,
	    "\tFlags (%08x) = <", tdb->tdb_flags);
	l += strlen(buffer + l);
d904 3
a906 4
	    TDBF_SOFT_FIRSTUSE | TDBF_SOFT_ALLOCATIONS)) == 0) {
		snprintf(buffer + l, buflen - l, "none>\n");
		l += strlen(buffer + l);
	} else {
d910 2
a911 3
				snprintf(buffer + l, buflen - l,
				    "%s,", ipspflags[k].ctl_name);
				l += strlen(buffer + l);
d919 1
a919 2
		snprintf(buffer + l, buflen - l, ">\n");
		l += strlen(buffer + l);
d922 1
a922 3
	snprintf(buffer + l, buflen - l,
	    "\tCrypto ID: %llu\n", tdb->tdb_cryptoid);
	l += strlen(buffer + l);
d924 2
a925 3
	if (tdb->tdb_xform) {
		snprintf(buffer + l, buflen - l,
		    "\txform = <%s>\n",
a926 2
		l += strlen(buffer + l);
	}
d928 2
a929 3
	if (tdb->tdb_encalgxform) {
		snprintf(buffer + l, buflen - l,
		    "\t\tEncryption = <%s>\n",
d931 3
a933 5
		l += strlen(buffer + l);
	}
	if (tdb->tdb_authalgxform) {
		snprintf(buffer + l, buflen - l,
		    "\t\tAuthentication = <%s>\n",
d935 3
a937 5
		l += strlen(buffer + l);
	}
	if (tdb->tdb_compalgxform) {
		snprintf(buffer + l, buflen - l,
		    "\t\tCompression = <%s>\n",
d939 3
a941 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_onext) {
		snprintf(buffer + l, buflen - l,
d946 3
a948 5
		l += strlen(buffer + l);
	}
	if (tdb->tdb_inext) {
		snprintf(buffer + l, buflen - l,
		    "\tPrevious SA: SPI = %08x, "
d953 2
a954 4
		l += strlen(buffer + l);
	}
	snprintf(buffer + l, buflen - l,
	    "\t%llu bytes processed by this SA\n",
a955 1
	l += strlen(buffer + l);
d957 2
a958 3
	if (tdb->tdb_last_used) {
		snprintf(buffer + l, buflen - l,
		    "\tLast used %llu seconds ago\n",
a959 2
		l += strlen(buffer + l);
	}
d961 2
a962 2
	if (tdb->tdb_last_marked) {
		snprintf(buffer + l, buflen - l,
a964 2
		l += strlen(buffer + l);
	}
d966 1
a966 3
	snprintf(buffer + l, buflen - l,
	    "\tExpirations:\n");
	l += strlen(buffer + l);
d968 2
a969 2
	if (tdb->tdb_flags & TDBF_TIMER) {
		snprintf(buffer + l, buflen -l,
d972 3
a974 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_SOFT_TIMER) {
		snprintf(buffer + l, buflen -l,
d978 3
a980 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_BYTES) {
		snprintf(buffer + l, buflen -l,
d983 3
a985 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_SOFT_BYTES) {
		snprintf(buffer + l, buflen -l,
d988 3
a990 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_ALLOCATIONS) {
		snprintf(buffer + l, buflen -l,
d993 3
a995 4
		l += strlen(buffer + l);
	}
	if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS) {
		snprintf(buffer + l, buflen -l,
d998 1
a998 2
		l += strlen(buffer + l);
	}
d1000 2
a1001 2
		if (tdb->tdb_first_use) {
			snprintf(buffer + l, buflen -l,
d1005 2
a1006 3
			l += strlen(buffer + l);
		} else {
			snprintf(buffer + l, buflen -l,
a1009 2
			l += strlen(buffer + l);
		}
d1013 2
a1014 2
		if (tdb->tdb_first_use) {
			snprintf(buffer + l, buflen -l,
d1018 2
a1019 3
			l += strlen(buffer + l);
		} else {
			snprintf(buffer + l, buflen -l,
a1021 2
			l += strlen(buffer + l);
		}
d1026 5
a1030 7
	    TDBF_SOFT_ALLOCATIONS | TDBF_ALLOCATIONS |
	    TDBF_SOFT_BYTES | TDBF_FIRSTUSE | TDBF_SOFT_FIRSTUSE))) {
		snprintf(buffer + l, buflen -l, "\t\t(none)\n");
		l += strlen(buffer + l);
	}
	snprintf(buffer + l, buflen -l, "\n");
	l += strlen(buffer + l);
d1053 1
a1053 2
		l = snprintf(buffer, sizeof buffer,
		    "Hashmask: %d, policy entries: %d\n",
d1066 1
a1066 1
				l = ipsp_print_tdb(tdb, buffer, sizeof buffer);
d1144 1
a1144 2
	snprintf(buf[i], sizeof buf[0], "%d.%d.%d.%d",
	    ucp[0] & 0xff, ucp[1] & 0xff,
@


1.79.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a301 29
#ifdef TCP_SIGNATURE
/*
 * Same as gettdb() but compare SRC as well, so we
 * use the tdbsrc[] hash table.  Setting spi to 0
 * matches all SPIs.
 */
struct tdb *
gettdbbysrcdst(u_int32_t spi, union sockaddr_union *src,
    union sockaddr_union *dst, u_int8_t proto)
{
	u_int32_t hashval;
	struct tdb *tdbp;

	if (tdbsrc == NULL)
		return (struct tdb *) NULL;

	hashval = tdb_hash(0, src, proto);

	for (tdbp = tdbsrc[hashval]; tdbp != NULL; tdbp = tdbp->tdb_snext)
		if ((spi == 0 || tdbp->tdb_spi == spi) &&
		    !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa)) &&
		    !bcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa)) &&
		    (tdbp->tdb_sproto == proto))
			break;

	return tdbp;
}
#endif

a862 1
		{ "udpencap", TDBF_UDPENCAP },
a947 6

	if (tdb->tdb_udpencap_port) {
		snprintf(buffer + l, buflen - l,
		    "\tudpencap_port = <%u>\n", ntohs(tdb->tdb_udpencap_port));
		l += strlen(buffer + l);
	}
@


1.79.2.10
log
@Merge with the trunk
@
text
@a313 1
	union sockaddr_union su_null;
d321 4
a324 6
		if (tdbp->tdb_sproto == proto &&
		    (spi == 0 || tdbp->tdb_spi == spi) &&
		    ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
		    (tdbp->tdb_dst.sa.sa_family == AF_UNSPEC ||
		    !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa))) &&
		    !bcmp(&tdbp->tdb_src, src, SA_LEN(&src->sa)))
d327 1
a327 17
	if (tdbp != NULL)
		return (tdbp);

	bzero(&su_null, sizeof(su_null));
	su_null.sa.sa_len = sizeof(struct sockaddr);
	hashval = tdb_hash(0, &su_null, proto);

	for (tdbp = tdbsrc[hashval]; tdbp != NULL; tdbp = tdbp->tdb_snext)
		if (tdbp->tdb_sproto == proto &&
		    (spi == 0 || tdbp->tdb_spi == spi) &&
		    ((tdbp->tdb_flags & TDBF_INVALID) == 0) &&
		    (tdbp->tdb_dst.sa.sa_family == AF_UNSPEC ||
		    !bcmp(&tdbp->tdb_dst, dst, SA_LEN(&dst->sa))) &&
		    tdbp->tdb_src.sa.sa_family == AF_UNSPEC)
			break;

	return (tdbp);
d338 6
a343 7
ipsp_aux_match(struct tdb *tdb,
    struct ipsec_ref *psrcid,
    struct ipsec_ref *pdstid,
    struct ipsec_ref *plcred,
    struct ipsec_ref *prcred,
    struct sockaddr_encap *pfilter,
    struct sockaddr_encap *pfiltermask)
d346 1
a346 2
		if (tdb->tdb_srcid == NULL ||
		    !ipsp_ref_match(tdb->tdb_srcid, psrcid))
d350 1
a350 2
		if (tdb->tdb_dstid == NULL ||
		    !ipsp_ref_match(tdb->tdb_dstid, pdstid))
d354 1
a354 2
		if (tdb->tdb_local_cred == NULL ||
		   !ipsp_ref_match(tdb->tdb_local_cred, plcred))
d358 1
a358 2
		if (tdb->tdb_remote_cred == NULL ||
		    !ipsp_ref_match(tdb->tdb_remote_cred, prcred))
d362 1
a362 1
	if (tdb->tdb_filter.sen_type) {
d370 3
a372 4
		if (bcmp(&tdb->tdb_filter, pfilter,
		    sizeof(struct sockaddr_encap)) ||
		    bcmp(&tdb->tdb_filtermask, pfiltermask,
		    sizeof(struct sockaddr_encap)))
d402 4
a405 2
			if (!ipsp_aux_match(tdbp, srcid, dstid,
			    local_cred, NULL, filter, filtermask))
d436 4
a439 2
			if (!ipsp_aux_match(tdbp, dstid, srcid, NULL, NULL,
			    filter, filtermask))
@


1.78
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.77 2000/01/27 08:09:12 angelos Exp $	*/
a68 1
#include <netinet6/in6.h>
@


1.77
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.76 2000/01/21 03:15:05 angelos Exp $	*/
d66 3
a68 1
#include <netinet6/in6.h>
@


1.76
log
@Rename the ip4_* routines to ipip_*, make it so GIF tunnels are not
affected by net.inet.ipip.allow (the sysctl formerly known as
net.inet.ip4.allow), rename the VIF ipip_input to ipip_mroute_input.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.75 2000/01/13 05:30:11 angelos Exp $	*/
d143 6
a148 13
    { XF_OLD_AH,         XFT_AUTH,	 "Keyed Authentication, RFC 1828/1852",
      ah_old_attach,     ah_old_init,     ah_old_zeroize,
      ah_old_input,      ah_old_output, },
    { XF_OLD_ESP,        XFT_CONF,        "Simple Encryption, RFC 1829/1851",
      esp_old_attach,    esp_old_init,    esp_old_zeroize,
      esp_old_input,     esp_old_output, },
    { XF_NEW_AH,	 XFT_AUTH,	  "HMAC Authentication",
      ah_new_attach,	 ah_new_init,     ah_new_zeroize,
      ah_new_input,	 ah_new_output, },
    { XF_NEW_ESP,	 XFT_CONF|XFT_AUTH,
      "Encryption + Authentication + Replay Protection",
      esp_new_attach,	 esp_new_init,  esp_new_zeroize,
      esp_new_input,	 esp_new_output, },
d1497 20
@


1.75
log
@Print number of ingress flows in /kern/ipsec
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.74 2000/01/13 00:34:31 angelos Exp $	*/
d142 1
a142 1
      ipe4_output, },
d1825 1
a1825 1
		error = ipe4_output(m, tdb, mp, 0, 0);
@


1.74
log
@put_flow(), find_flow(), and delete_flow() get a third argument (for
ingress or egress flow)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.73 2000/01/11 03:10:04 angelos Exp $	*/
d1561 6
@


1.73
log
@Correct sa_require handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.72 2000/01/11 01:39:10 angelos Exp $	*/
d1022 1
a1022 1
	  u_int8_t proto, struct tdb *tdb)
d1026 6
a1031 1
    for (flow = tdb->tdb_flow; flow; flow = flow->flow_next)
d1059 2
a1060 2
      if ((flow = find_flow(src, srcmask, dst, dstmask, proto, tdb_bypass))
	  != (struct flow *) NULL)
d1066 2
a1067 2
	  if ((flow = find_flow(src, srcmask, dst, dstmask, proto, tdb)) !=
	      (struct flow *) NULL)
d1139 1
a1139 1
put_flow(struct flow *flow, struct tdb *tdb)
d1141 10
a1150 2
    flow->flow_next = tdb->tdb_flow;
    flow->flow_prev = (struct flow *) NULL;
d1152 2
a1153 1
    tdb->tdb_flow = flow;
d1156 1
a1156 3

    if (flow->flow_next)
      flow->flow_next->flow_prev = flow;
d1164 1
a1164 1
delete_flow(struct flow *flow, struct tdb *tdb)
d1168 4
a1171 2
	if (tdb->tdb_flow == flow)
	{
d1173 6
a1178 9
	    if (tdb->tdb_flow)
	      tdb->tdb_flow->flow_prev = (struct flow *) NULL;
	}
	else
	{
	    flow->flow_prev->flow_next = flow->flow_next;
	    if (flow->flow_next)
	      flow->flow_next->flow_prev = flow->flow_prev;
	}
d1181 3
a1183 1
    ipsec_in_use--;
d1245 1
a1245 1
      delete_flow(tdbp->tdb_access, tdbp);
d1312 1
a1312 1
		delete_flow(tdbp->tdb_flow, tdbp);
d1325 1
a1325 1
        delete_flow(tdbp->tdb_flow, tdbp);
@


1.72
log
@Fix check for sen_type.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.71 2000/01/11 01:03:22 angelos Exp $	*/
d369 1
a369 1
	tdb2.tdb_satype = get_sa_require(inp);
d400 1
a400 1
	if (tdb2.tdb_satype & NOTIFY_SATYPE_CONF)
d402 2
d423 3
@


1.71
log
@Use default values when requesting dynamic VPNs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.70 2000/01/11 00:44:32 angelos Exp $	*/
d351 1
a351 1
	    case SENT_IPSP:
d357 1
a357 1
	    case SENT_IPSP6:
@


1.70
log
@Only use defaults if they have sane values.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.69 2000/01/10 06:59:22 angelos Exp $	*/
d371 1
a371 1
	/* Always require PFS */
@


1.69
log
@Add 10 new ipsec-related sysctl variables...they are currently under
net.inet.ip; perhaps they should be moved under net.inet.ipsec or some
such.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.68 2000/01/10 05:35:09 angelos Exp $	*/
d376 23
a398 8
	tdb2.tdb_soft_allocations = ipsec_soft_allocations;
	tdb2.tdb_exp_allocations = ipsec_exp_allocations;
	tdb2.tdb_soft_bytes = ipsec_soft_bytes;
	tdb2.tdb_exp_bytes = ipsec_exp_bytes;
	tdb2.tdb_soft_timeout = ipsec_soft_timeout;
	tdb2.tdb_exp_timeout = ipsec_exp_timeout;
	tdb2.tdb_soft_first_use = ipsec_soft_first_use;
	tdb2.tdb_exp_first_use = ipsec_exp_first_use;
@


1.68
log
@Some more code for dealing with socket IPsec options.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.67 2000/01/10 04:37:42 angelos Exp $	*/
d372 2
a373 1
	tdb2.tdb_flags |= TDBF_PFS; /* XXX Make this configurable */
d375 42
a416 6
	/*
	 * XXX Initialize:
	 * XXX - Lifetime values
	 * XXX - encalgxform/authalgxform
	 * XXX from sysctl-controlled defaults
	 */
@


1.67
log
@Only setup an expiration for embryonic SAs if
net.inet.ip.ipsec-invalid-life >=0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.66 2000/01/10 04:30:52 angelos Exp $	*/
d368 40
a407 1
	/* XXX */
@


1.66
log
@Add net.inet.ip.ipsec-invalid-life, default value 60 seconds; the
amount of time embryonic SAs will be kept before they have to be
initialized by key management (this only affects automated key
management).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.65 2000/01/10 04:16:52 angelos Exp $	*/
d503 7
a509 4
	tdbp->tdb_flags |= TDBF_TIMER;
	tdbp->tdb_exp_timeout = time.tv_sec + ipsec_keep_invalid;
	tdb_expiration(tdbp, TDBEXP_EARLY | TDBEXP_TIMEOUT);
	
@


1.65
log
@1) Setup a silent TDB expiration for embryonic SAs.
2) Fix check_ipsec_policy() to deal with v6 PCBs.
3) Fix ACL protocol check.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.64 2000/01/10 01:19:16 angelos Exp $	*/
d213 1
a213 1
    struct sockaddr_encap *dst *gw;
d371 1
a371 1
	if ((error = pfkeyv2_acquire(tdb2, 0)) != 0)
@


1.64
log
@Free ACL when deleting TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.63 2000/01/09 23:02:15 angelos Exp $	*/
d67 1
a67 1
#include <netinet6/ip6.h>
d99 1
a99 1
int		check_ipsec_policy  __P((struct inpcb *, u_int32_t));
d206 1
a206 1
 * daemon. Sometime the inp does not contain the destination address
a208 2

/* XXX Make IPv6 compliant */
d210 1
a210 1
check_ipsec_policy(struct inpcb *inp, u_int32_t daddr)
d212 4
a217 3
    struct route_enc re0, *re = &re0;
    struct sockaddr_encap *dst; 
    u_int8_t sa_require, sa_have;
a218 1
    struct tdb *tdb = NULL;
d233 3
a235 7
	dst->sen_len = SENT_IP4_LEN;
	dst->sen_type = SENT_IP4;
	dst->sen_ip_src = inp->inp_laddr;
	dst->sen_ip_dst.s_addr = inp->inp_faddr.s_addr ? 
	  inp->inp_faddr.s_addr : daddr;
	dst->sen_proto = so->so_proto->pr_protocol;
	switch (dst->sen_proto)
d237 22
a258 8
	  case IPPROTO_UDP:
	  case IPPROTO_TCP:
	    dst->sen_sport = htons(inp->inp_lport);
	    dst->sen_dport = htons(inp->inp_fport);
	    break;
	  default:
	    dst->sen_sport = 0;
	    dst->sen_dport = 0;
d260 31
a290 1
    
d293 1
a293 1
    
a295 2
	    struct sockaddr_encap *gw;
	    
d297 2
a298 1
	    
d309 15
d326 2
a327 1
    } else
d334 1
d350 1
d354 1
d367 7
a373 3
	/* Send notify */
	/* XXX PF_KEYv2 Notify */
	 
d391 1
d394 4
a397 2
	 * need to retry again. XXX - when more than one key
	 * management daemon is available we can not do that.
d401 1
a410 2

/* XXX Make IPv6 compliant */
d423 1
d426 1
d462 1
a462 1
      nums = 50;  /* XXX figure out some good value */
d502 4
a505 1
	/* XXX Should set up a silent expiration for this */
d685 3
a687 1
	    pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
a727 1

a730 1
    u_int64_t next_timeout = 0;
d733 1
@


1.63
log
@Ports in network order...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.62 1999/12/27 03:05:52 angelos Exp $	*/
d1063 3
@


1.62
log
@Print associated interface, if present.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.61 1999/12/25 07:09:42 angelos Exp $	*/
d245 2
a246 2
	    dst->sen_sport = inp->inp_lport;
	    dst->sen_dport = inp->inp_fport;
@


1.61
log
@Change some function prototypes, dont unnecessarily initialize some
variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.60 1999/12/25 04:48:16 angelos Exp $	*/
d1337 4
@


1.60
log
@Move the IPsec packet-processing loop to a separate routine, so we can
reuse it in ip6_output and the bridge. The policy-lookup code will
probably follow suit in a separate routine sometime soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.59 1999/12/08 06:06:43 itojun Exp $	*/
a1621 2
		    i = ip->ip_hl << 2;
		    off = offsetof(struct ip, ip_p);
d1628 1
a1628 5
		{
		    ip6->ip6_plen = htons(m->m_pkthdr.len);
		    i = sizeof(struct ip6_hdr);
		    off = offsetof(struct ip6_hdr, ip6_nxt);
		}
d1631 3
a1633 3
		/* Encapsulate */
		error = ipe4_output(m, tdb, mp, i, off);
		if ((*mp) == NULL)
d1638 4
a1641 1
		      m_freem(*mp);
@


1.59
log
@comment out call to inet_ntoa6() as we don't have the code yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.58 1999/12/06 07:14:36 angelos Exp $	*/
a47 1
#include <sys/domain.h>
a51 1
#include <sys/time.h>
d58 1
d63 6
a68 3
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
a69 1
#include <net/raw_cb.h>
d89 4
d1502 228
@


1.58
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.57 1999/12/05 22:09:18 angelos Exp $	*/
d1489 1
a1489 1
#if INET6
d1491 1
a1491 1
	    return inet_ntoa6(sa.sin6.s6_addr);
@


1.57
log
@Fix an INET6 dependency (niklas@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.56 1999/12/04 23:20:21 angelos Exp $	*/
d136 1
a136 1
      (struct mbuf * (*)(struct mbuf *, struct tdb *))ipe4_input, 
@


1.56
log
@Address independence, IPv6 support, and the -local flag in ipsecadm is
no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.55 1999/11/04 11:20:05 ho Exp $	*/
d295 1
d299 5
d1465 1
a1465 1
#if INET6
@


1.55
log
@Add tdb for IPsec bypass flows. gettdb() should be called at spltdb().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.54 1999/09/03 13:52:34 ho Exp $	*/
d205 1
d289 10
a298 3
	/* XXX address */
	DPRINTF(("ipsec: send SA request (%d), remote ip: %s, SA type: %d\n",
		 i + 1, inet_ntoa4(dst->sen_ip_dst), sa_require));
d337 1
a1060 1
        encapdst.sen_len = SENT_IP4_LEN;
d1062 1
a1062 6
        encapdst.sen_type = SENT_IP4;
        encapdst.sen_ip_src = tdbp->tdb_flow->flow_src.sin.sin_addr;
        encapdst.sen_ip_dst = tdbp->tdb_flow->flow_dst.sin.sin_addr;
        encapdst.sen_proto = tdbp->tdb_flow->flow_proto;
        encapdst.sen_sport = tdbp->tdb_flow->flow_src.sin.sin_port;
        encapdst.sen_dport = tdbp->tdb_flow->flow_dst.sin.sin_port;
d1064 61
a1124 14
        encapnetmask.sen_len = SENT_IP4_LEN;
        encapnetmask.sen_family = PF_KEY;
        encapnetmask.sen_type = SENT_IP4;
        encapnetmask.sen_ip_src = tdbp->tdb_flow->flow_srcmask.sin.sin_addr;
        encapnetmask.sen_ip_dst = tdbp->tdb_flow->flow_dstmask.sin.sin_addr;

        if (tdbp->tdb_flow->flow_proto)
        {
            encapnetmask.sen_proto = 0xff;
            if (tdbp->tdb_flow->flow_src.sin.sin_port)
              encapnetmask.sen_sport = 0xffff;
            if (tdbp->tdb_flow->flow_dst.sin.sin_port)
              encapnetmask.sen_dport = 0xffff;
        }
d1449 1
a1449 1
    static char buf[4][4 * sizeof "123"];
d1459 16
d1484 2
a1485 1
	    /* XXX Add AF_INET6 support here */
@


1.54
log
@inet_ntoa4 should manage 4-calls, not just 2
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.53 1999/08/10 11:35:26 ho Exp $	*/
d164 1
a164 1
static struct tdb **tdbh = NULL;
d362 1
a362 1
    int nums;
d398 5
a402 1
	if (gettdb(spi, dst, sproto) != (struct tdb *) NULL)
d471 2
d482 21
a507 1
    s = spltdb();
a512 1
    splx(s);
d866 5
d895 1
a895 1
    bzero(new_tdbh, sizeof(struct tdbh *) * (tdb_hashmask + 1));
d995 8
d1022 1
d1115 4
@


1.53
log
@Add tdb_satype (PF_KEY SADB_SATYPE_<XXX>) to struct tdb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.52 1999/08/05 21:58:15 ho Exp $	*/
d1358 1
a1358 1
    static int i = 1;
d1360 1
a1360 1
    i = (i + 1) % 2;
@


1.52
log
@Add tdb_walk. tdb_delete() should clean up routes when deleting flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.51 1999/07/17 00:41:52 niklas Exp $	*/
d409 1
@


1.51
log
@A good hashing function for IPsec SAs that should remove the risks
of running out of memory when adding SPIs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.50 1999/07/15 14:46:05 niklas Exp $	*/
d520 23
d1005 38
a1042 1
	delete_flow(tdbp->tdb_flow, tdbp);
@


1.50
log
@Protect better against rehashing make the kernel run out of resources
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.48 1999/07/06 20:54:03 ho Exp $	*/
d429 1
a429 1
    static u_int32_t seed1 = 0, seed2 = 0;
d431 8
a438 2
    int i;
    u_int32_t hash, val32 = 0;
d440 1
a440 6
    if (!seed1) {
	seed1 = arc4random ();
	seed2 = arc4random ();
    }

    hash = spi ^ proto;
d446 1
a446 1
	    hash ^= val32;
d451 5
a455 1
	hash ^= val32;
d457 1
a457 1
    return (((hash >> 16) ^ seed1) * (hash ^ seed2)) & tdb_hashmask;
d516 1
a516 1
	db_printf("%d%c\tne\t\%d\n", i, i == 15 ? "+" : "", buckets[i]);
@


1.49
log
@From angelos@@, edits by me, demand keying for PF_KEY
@
text
@d77 5
d88 4
d166 1
d423 33
d466 1
a466 2
    u_int8_t *ptr = (u_int8_t *) dst;
    u_int32_t hashval = proto + spi;
d468 1
a468 1
    int i, s;
d473 1
a473 4
    for (i = 0; i < SA_LEN(&dst->sa); i++)
      hashval += ptr[i];
    
    hashval &= tdb_hashmask;
d486 29
d830 1
a830 2
    u_int i, j, new_hashmask = (tdb_hashmask << 1) | 1;
    u_int8_t *ptr;
d833 2
a834 1
    MALLOC(new_tdbh, struct tdb **, sizeof(struct tdb *) * (new_hashmask + 1),
d836 4
a839 3
    bzero(new_tdbh, sizeof(struct tdbh *) * (new_hashmask + 1));
    for (i = 0; i <= tdb_hashmask; i++)
      for (tdbp = tdbh[i]; tdbp != NULL; tdbp = tdbnp) {
d841 1
a841 5
      	  hashval = tdbp->tdb_sproto + tdbp->tdb_spi;
	  ptr = (u_int8_t *) &tdbp->tdb_dst;
	  for (j = 0; j < SA_LEN(&tdbp->tdb_dst.sa); j++)
	    hashval += ptr[j];
	  hashval &= new_hashmask;
a845 1
    tdb_hashmask = new_hashmask;
d852 1
a852 2
    u_int8_t *ptr = (u_int8_t *) &tdbp->tdb_dst;
    u_int32_t hashsum = tdbp->tdb_sproto + tdbp->tdb_spi, hashval, i;
d855 2
a856 1
    if (tdbh == NULL) {
d862 1
a862 2
    for (i = 0; i < SA_LEN(&tdbp->tdb_dst.sa); i++)
      hashsum += ptr[i];
d864 10
a873 3
    hashval = hashsum & tdb_hashmask;
    /* Rehash if this tdb would cause a bucket to have more than two items. */
    if (tdbh[hashval] != NULL && tdbh[hashval]->tdb_hnext != NULL) {
d875 1
a875 1
	hashval = hashsum & tdb_hashmask;
d879 1
a930 1
    u_int8_t *ptr = (u_int8_t *) &tdbp->tdb_dst;
d933 1
a933 1
    u_int32_t hashval = tdbp->tdb_sproto + tdbp->tdb_spi, i;
d939 1
a939 4
    for (i = 0; i < SA_LEN(&tdbp->tdb_dst.sa); i++)
      hashval += ptr[i];

    hashval &= tdb_hashmask;
d1012 1
@


1.48
log
@ipsec_in_use could get out of sync. (Also niklas@@. angelos@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.47 1999/07/06 20:17:52 cmetz Exp $	*/
d246 2
a247 1
	    if (gw->sen_type == SENT_IPSP) {
d341 3
a343 3
 * Reserve an SPI; the SA is not valid yet though. Zero is reserved as
 * an error return value. If tspi is not zero, we try to allocate that
 * SPI.
d354 2
a355 1
    if (tspi <= 255)   /* We don't reserve 0 < SPI <= 255 */
d357 1
a357 1
	(*errval) = EEXIST;
d360 6
a365 2
    
    if ((sspi == tspi) && (sspi != 0))   /* Asking for a specific SPI */
d372 3
a374 1
	if (tspi != 0) /* SPIRANGE was defined */
d376 2
a377 7
	    if (sspi == tspi)  /* Specific SPI asked */
	      spi = tspi;
	    else    /* Range specified */
	    {
		get_random_bytes((void *) &spi, sizeof(spi));
		spi = sspi + (spi % (tspi - sspi));
	    }
a378 2
	else  /* Some SPI */
	  get_random_bytes((void *) &spi, sizeof(spi));
d380 3
a382 1
	if (spi <= 255) /* Don't allocate SPI <= 255, they're reserved */
d526 10
d553 2
a554 1
    if (next_timeout == tdb->tdb_timeout) {
d650 2
a651 1
    if (tdb->tdb_expnext.tqe_prev != NULL) {
@


1.47
log
@Added support for TCP MD5 option (RFC 2385).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.46 1999/06/07 07:20:38 angelos Exp $	*/
d452 1
d838 1
a894 1
    {
a895 2
	ipsec_in_use--;
    }
@


1.46
log
@Fix use of uninitialized TDB hash table in tdb_delete(), introduced
along with the dynamically-resized TDB table (report and fix
suggestion by henric@@ncal.verio.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.45 1999/06/04 22:40:36 provos Exp $	*/
d142 6
@


1.45
log
@forgot to zero sunion
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.44 1999/05/23 09:04:46 niklas Exp $	*/
d149 1
a149 1
static struct tdb **tdbh;
d842 3
@


1.44
log
@SA hash table resizing
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.43 1999/05/20 12:52:35 niklas Exp $	*/
d241 1
@


1.43
log
@Fix a bug where the ordered expiration list could get out of order.  Add
invariant checking of the lists when DIAGNOSTIC compiled.  Extend the
critical region to cover all of tdb_expiration so the tdb won't
disappear behind our back.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.42 1999/05/16 21:48:35 niklas Exp $	*/
d86 1
d148 4
d418 3
d424 1
a424 1
    hashval %= TDB_HASHMOD;
d427 1
a427 1
    for (tdbp = tdbh[hashval]; tdbp; tdbp = tdbp->tdb_hnext)
d718 4
a721 1
    for (i = 0; i < TDB_HASHMOD; i++)
d723 1
a723 1
	for (tdb = tdbh[i]; tdb; tdb = tdb->tdb_hnext)
d731 31
d766 8
a773 2
    u_int32_t hashval = tdbp->tdb_sproto + tdbp->tdb_spi, i;
    int s;
d776 1
a776 1
      hashval += ptr[i];
d778 6
a783 2
    hashval %= TDB_HASHMOD;
    s = spltdb();
d845 1
a845 1
    hashval %= TDB_HASHMOD;
d965 1
a965 1
    if (bufp == NULL)
d972 1
a972 1
    for (i = 0; i < TDB_HASHMOD; i++)
@


1.42
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.41 1999/05/14 23:36:18 niklas Exp $	*/
d97 1
a97 1
struct explist_head explist = LIST_HEAD_INITIALIZER(explist);
d449 1
a449 1
    for (tdb = LIST_FIRST(&explist);
d451 1
a451 1
	 tdb = LIST_FIRST(&explist))
d498 1
d504 2
a505 1
    int will_be_first, sole_reason, early, s;
d524 2
a525 1
    if (next_timeout == tdb->tdb_timeout)
d527 1
a527 2

    s = spltdb();
d530 1
a530 1
     * Find out some useful facts: Will we our tdb be first to expire?
d534 1
a534 1
    next_expirer = LIST_NEXT(tdb, tdb_explink);
d567 1
a567 1
        if (tdb->tdb_expnext.tqe_prev)
d574 1
a574 1
	LIST_REMOVE(tdb, tdb_explink);
d590 1
a590 1
    for (t = (early ? former_expirer :
d592 2
a593 2
	 t && (early ? (t->tdb_timeout <= next_timeout) : 
	       (t->tdb_timeout > next_timeout));
d597 1
a597 1
    if (early ? t == TAILQ_FIRST(&expclusterlist) : !t)
d601 1
a601 1
	LIST_INSERT_HEAD(&explist, tdb, tdb_explink);
d608 4
a613 1
	LIST_INSERT_AFTER(t, tdb, tdb_explink);
d615 57
@


1.41
log
@A new scalable IPsec SA expiration model.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.40 1999/04/12 03:17:09 deraadt Exp $	*/
d192 1
a192 1
    int error, i;
d201 2
a202 1
	
d236 3
a238 3
	      sunion.sin.sin_family = AF_INET;
	      sunion.sin.sin_len = sizeof(struct sockaddr_in);
	      sunion.sin.sin_addr = gw->sen_ipsp_dst;
d240 2
a241 2
	      tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, &sunion,
					  gw->sen_ipsp_sproto);
d248 5
a252 4
    if (tdb) {
	SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdb);
    } else
	sa_have = 0;
d309 8
a316 4
	if (inp->inp_tdb) {
		if (inp->inp_tdb == tdb)
			return;
		TAILQ_REMOVE(&inp->inp_tdb->tdb_inp, inp, inp_tdb_next);
d318 5
a322 2
	inp->inp_tdb = tdb;
	TAILQ_INSERT_TAIL(&tdb->tdb_inp, inp, inp_tdb_next);
d324 1
a324 1
	DPRINTF(("tdb_add_inp: tdb: %p, inp: %p\n", tdb, inp));
d411 1
a411 1
    int i;
d418 1
d424 2
a425 1
	
d440 4
d448 1
a448 1
    
d458 1
a458 1
	    tdb_delete(tdb, 0);
d466 1
a466 1
	      tdb_delete(tdb, 0);
d476 1
a476 1
	    tdb_expiration(tdb, 1);
d485 1
a485 1
	      tdb_expiration(tdb, 1);
d499 1
a499 1
tdb_expiration(struct tdb *tdb, int early)
d502 2
a503 1
    struct tdb *t;
d525 37
d567 2
a568 4
	    if (LIST_NEXT(tdb, tdb_explink) &&
		tdb->tdb_timeout == LIST_NEXT(tdb, tdb_explink)->tdb_timeout)
	      TAILQ_INSERT_BEFORE(tdb, LIST_NEXT(tdb, tdb_explink),
				  tdb_expnext);
d575 2
d578 2
d581 1
d584 1
a584 1
     * Search fron-to-back if we believe we will end up early, otherwise
d587 2
a588 2
    tdb->tdb_timeout = next_timeout;
    for (t = (early ? TAILQ_FIRST(&expclusterlist) :
d597 1
a597 5
	/*
	 * We are to become the first expiration, remove old timer, if any.
	 */
	if (TAILQ_FIRST(&expclusterlist))
	  untimeout(handle_expirations, (void *) NULL);
d610 1
a610 2
    timeout(handle_expirations, (void *) NULL,
	    hz * (next_timeout - time.tv_sec));
d613 4
d635 4
d649 6
a654 5
      for (tdb = tdbh[i]; tdb; tdb = tdb->tdb_hnext)
	if ((flow = find_flow(src, srcmask, dst, dstmask, proto, tdb)) !=
	    (struct flow *) NULL)
	  return flow;

d663 1
d669 1
d672 1
d675 4
d693 4
d719 2
a720 2
int
tdb_delete(struct tdb *tdbp, int delchain)
d726 1
d733 1
d792 1
d795 3
a797 10
        if (tdbp->tdb_expnext.tqe_prev)
	{
	    if (LIST_NEXT(tdbp, tdb_explink) &&
		tdbp->tdb_timeout == LIST_NEXT(tdbp, tdb_explink)->tdb_timeout)
	      TAILQ_INSERT_BEFORE(tdbp, LIST_NEXT(tdbp, tdb_explink),
				  tdb_expnext);
	    TAILQ_REMOVE(&expclusterlist, tdbp, tdb_expnext);
	    tdbp->tdb_expnext.tqe_prev = NULL;
	}
	LIST_REMOVE(tdbp, tdb_explink);
d809 2
a810 3
      return tdb_delete(tdbpp, delchain);
    else
      return 0;
d846 1
a846 1
    int l, i;
d859 6
a864 4
      for (tdb = tdbh[i]; tdb; tdb = tdb->tdb_hnext)
	if (tdb->tdb_epoch != kernfs_epoch)
	{
	    tdb->tdb_epoch = kernfs_epoch;
d866 36
a901 28
	    l = sprintf(buffer, "SPI = %08x, Destination = %s, Sproto = %u\n",
			ntohl(tdb->tdb_spi),
			ipsp_address(tdb->tdb_dst), tdb->tdb_sproto);

	    l += sprintf(buffer + l, "\tEstablished %d seconds ago\n",
			 time.tv_sec - tdb->tdb_established);

	    l += sprintf(buffer + l, "\tSource = %s",
			 ipsp_address(tdb->tdb_src));

	    if (tdb->tdb_proxy.sa.sa_family)
	      l += sprintf(buffer + l, ", Proxy = %s\n",
			   ipsp_address(tdb->tdb_proxy));
	    else
	      l += sprintf(buffer + l, "\n");

	    l += sprintf(buffer + l, "\tFlags (%08x) = <", tdb->tdb_flags);

	    if ((tdb->tdb_flags & ~(TDBF_TIMER | TDBF_BYTES |
				    TDBF_ALLOCATIONS | TDBF_FIRSTUSE |
				    TDBF_SOFT_TIMER | TDBF_SOFT_BYTES |
				    TDBF_SOFT_FIRSTUSE |
				    TDBF_SOFT_ALLOCATIONS)) == 0)
	      l += sprintf(buffer + l, "none>\n");
	    else
	    {
		/* We can reuse variable 'i' here, since we're not looping */
		i = 0;
d903 1
a903 5
		if (tdb->tdb_flags & TDBF_UNIQUE)
		{
		    if (i)
		      l += sprintf(buffer + l, ", ");
		    else
d905 1
d907 54
a960 10
		    l += sprintf(buffer + l, "unique");
		    i = 1;
		}

		if (tdb->tdb_flags & TDBF_INVALID)
		{
		    if (i)
		      l += sprintf(buffer + l, ", ");
		    else
		      i = 1;
d962 10
a971 2
		    l += sprintf(buffer + l, "invalid");
		}
d973 4
a976 6
		if (tdb->tdb_flags & TDBF_HALFIV)
		{
		    if (i)
		      l += sprintf(buffer + l, ", ");
		    else
		      i = 1;
d978 7
a984 2
		    l += sprintf(buffer + l, "halfiv");
		}
d986 7
a992 6
		if (tdb->tdb_flags & TDBF_PFS)
		{
		    if (i)
		      l += sprintf(buffer + l, ", ");
		    else
		      i = 1;
d994 2
a995 2
		    l += sprintf(buffer + l, "pfs");
		}
d997 1
a997 59
		if (tdb->tdb_flags & TDBF_TUNNELING)
		{
		    if (i)
		      l += sprintf(buffer + l, ", ");
		    else
		      i = 1;

		    l += sprintf(buffer + l, "tunneling");
		}

		l += sprintf(buffer + l, ">\n");
	    }

	    if (tdb->tdb_xform)
	      l += sprintf(buffer + l, "\txform = <%s>\n", 
			   tdb->tdb_xform->xf_name);

	    if (tdb->tdb_encalgxform)
	      l += sprintf(buffer + l, "\t\tEncryption = <%s>\n",
			   tdb->tdb_encalgxform->name);

	    if (tdb->tdb_authalgxform)
	      l += sprintf(buffer + l, "\t\tAuthentication = <%s>\n",
			   tdb->tdb_authalgxform->name);

	    if (tdb->tdb_bind_out)
	      l += sprintf(buffer + l,
			   "\tBound SA: SPI = %08x, "
			   "Destination = %s, Sproto = %u\n",
			   ntohl(tdb->tdb_bind_out->tdb_spi),
			   ipsp_address(tdb->tdb_bind_out->tdb_dst),
			   tdb->tdb_bind_out->tdb_sproto);
	    for (i = 0, tdbp = TAILQ_FIRST(&tdb->tdb_bind_in); tdbp;
		 tdbp = TAILQ_NEXT(tdbp, tdb_bind_in_next))
	      i++;

	    if (i > 0)
	      l += sprintf(buffer + l,
			   "\tReferenced by %d incoming SA%s\n",
			   i, i == 1 ? "" : "s");

	    if (tdb->tdb_onext)
	      l += sprintf(buffer + l,
			   "\tNext SA: SPI = %08x, "
			   "Destination = %s, Sproto = %u\n",
			   ntohl(tdb->tdb_onext->tdb_spi),
			   ipsp_address(tdb->tdb_onext->tdb_dst),
			   tdb->tdb_onext->tdb_sproto);

	    if (tdb->tdb_inext)
	      l += sprintf(buffer + l,
			   "\tPrevious SA: SPI = %08x, "
			   "Destination = %s, Sproto = %u\n",
			   ntohl(tdb->tdb_inext->tdb_spi),
			   ipsp_address(tdb->tdb_inext->tdb_dst),
			   tdb->tdb_inext->tdb_sproto);

	    for (i = 0, flow = tdb->tdb_flow; flow; flow = flow->flow_next)
	      i++;
d999 2
a1000 4
	    l+= sprintf(buffer + l, "\tCurrently used by %d flows\n", i);

	    l += sprintf(buffer + l, "\t%u flows have used this SA\n",
			 tdb->tdb_cur_allocations);
d1002 1
a1002 1
	    l += sprintf(buffer + l, "\t%qu bytes processed by this SA\n",
d1005 1
a1005 1
	    l += sprintf(buffer + l, "\tExpirations:\n");
d1007 4
a1010 4
	    if (tdb->tdb_flags & TDBF_TIMER)
	      l += sprintf(buffer + l,
			   "\t\tHard expiration(1) in %qu seconds\n",
			   tdb->tdb_exp_timeout - time.tv_sec);
d1012 4
a1015 4
	    if (tdb->tdb_flags & TDBF_SOFT_TIMER)
	      l += sprintf(buffer + l,
			   "\t\tSoft expiration(1) in %qu seconds\n",
			   tdb->tdb_soft_timeout - time.tv_sec);
d1017 4
a1020 3
	    if (tdb->tdb_flags & TDBF_BYTES)
	      l += sprintf(buffer + l, "\t\tHard expiration after %qu bytes\n",
			   tdb->tdb_exp_bytes);
d1022 4
a1025 13
	    if (tdb->tdb_flags & TDBF_SOFT_BYTES)
	      l += sprintf(buffer + l, "\t\tSoft expiration after %qu bytes\n",
			   tdb->tdb_soft_bytes);

	    if (tdb->tdb_flags & TDBF_ALLOCATIONS)
	      l += sprintf(buffer + l,
			   "\t\tHard expiration after %u flows\n",
			   tdb->tdb_exp_allocations);
	    
	    if (tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS)
	      l += sprintf(buffer + l,
			   "\t\tSoft expiration after %u flows\n",
			   tdb->tdb_soft_allocations);
d1027 1
a1027 3
	    if (tdb->tdb_flags & TDBF_FIRSTUSE)
	    {
		if (tdb->tdb_first_use)
d1029 4
a1032 4
			     "\t\tHard expiration(2) in %qu seconds\n",
			     (tdb->tdb_first_use + tdb->tdb_exp_first_use) -
			     time.tv_sec);
		else
d1034 2
a1035 3
			     "\t\tHard expiration in %qu seconds after first "
			     "use\n", tdb->tdb_exp_first_use);
	    }
d1037 33
a1069 12
	    if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
	    {
	        if (tdb->tdb_first_use)
		  l += sprintf(buffer + l,
			       "\t\tSoft expiration(2) in %qu seconds\n",
			       (tdb->tdb_first_use + tdb->tdb_soft_first_use) -
			       time.tv_sec);
	        else
		  l += sprintf(buffer + l,
			       "\t\tSoft expiration in %qu seconds after first "
			       "use\n", tdb->tdb_soft_first_use);
	    }
d1071 1
a1071 5
	    if (!(tdb->tdb_flags & (TDBF_TIMER | TDBF_SOFT_TIMER | TDBF_BYTES |
				    TDBF_SOFT_ALLOCATIONS | TDBF_ALLOCATIONS |
				    TDBF_SOFT_BYTES | TDBF_FIRSTUSE |
				    TDBF_SOFT_FIRSTUSE)))
	      l += sprintf(buffer + l, "\t\t(none)\n");
d1073 5
a1077 5
	    l += sprintf(buffer + l, "\n");
	    
	    return l;
	}
    
@


1.40
log
@move encdebug to a useful place
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.39 1999/03/27 21:04:19 provos Exp $	*/
d5 3
a7 2
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
 * Niels Provos (provos@@physnet.uni-hamburg.de).
d18 1
a18 1
 * Additional features in 1999 by Angelos D. Keromytis.
d20 1
a20 1
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
d22 2
a23 1
 *	
d95 4
a428 13
struct expiration *
get_expiration(void)
{
    struct expiration *exp;
    
    MALLOC(exp, struct expiration *, sizeof(struct expiration), M_TDB,
	   M_WAITOK);

    bzero(exp, sizeof(struct expiration));
    
    return exp;
}

a429 25
cleanup_expirations(union sockaddr_union *dst, u_int32_t spi, u_int8_t sproto)
{
    struct expiration *exp, *nexp;

    for (exp = explist; exp; exp = (exp ? exp->exp_next : explist))
      if (!bcmp(&exp->exp_dst, dst, SA_LEN(&dst->sa)) &&
	  (exp->exp_spi == spi) && (exp->exp_sproto == sproto))
      {
	  /* Link previous to next */
	  if (exp->exp_prev == (struct expiration *) NULL)
	    explist = exp->exp_next;
	  else
	    exp->exp_prev->exp_next = exp->exp_next;
	  
	  /* Link next (if it exists) to previous */
	  if (exp->exp_next != (struct expiration *) NULL)
	    exp->exp_next->exp_prev = exp->exp_prev;

	  nexp = exp;
	  exp = exp->exp_prev;
	  FREE(nexp, M_TDB);
      }
}

void 
a431 1
    struct expiration *exp;
d434 3
a436 4
    if (explist == (struct expiration *) NULL)
      return;
    
    while (1)
a437 18
	exp = explist;

	if (exp == (struct expiration *) NULL)
	  return;
	else
	  if (exp->exp_timeout > time.tv_sec)
	    break;
	
	/* Advance pointer */
	explist = explist->exp_next;
	if (explist)
	  explist->exp_prev = NULL;
	
	tdb = gettdb(exp->exp_spi, &exp->exp_dst, exp->exp_sproto);
	free(exp, M_TDB);
	if (tdb == (struct tdb *) NULL)
	  continue;			/* TDB is gone, ignore this */
	
d461 1
d470 1
d474 2
a475 1
    if (explist)
d477 1
a477 1
	      hz * (explist->exp_timeout - time.tv_sec));
d480 3
d484 1
a484 1
put_expiration(struct expiration *exp)
d486 25
a510 4
    struct expiration *expt;
    int reschedflag = 0;
    
    if (exp == (struct expiration *) NULL)
d512 10
a521 2
	DPRINTF(("put_expiration(): NULL argument\n"));
	return;
d523 17
a539 2
    
    if (explist == (struct expiration *) NULL)
d541 7
a547 2
	explist = exp;
	reschedflag = 1;
a549 27
      if (explist->exp_timeout > exp->exp_timeout)
      {
	  exp->exp_next = explist;
	  explist->exp_prev = exp;
	  explist = exp;
	  reschedflag = 2;
      }
      else
      {
	  for (expt = explist; expt->exp_next; expt = expt->exp_next)
	    if (expt->exp_next->exp_timeout > exp->exp_timeout)
	    {
		expt->exp_next->exp_prev = exp;
		exp->exp_next = expt->exp_next;
		expt->exp_next = exp;
		exp->exp_prev = expt;
		break;
	    }

	  if (expt->exp_next == (struct expiration *) NULL)
	  {
	      expt->exp_next = exp;
	      exp->exp_prev = expt;
	  }
      }

    switch (reschedflag)
d551 6
a556 13
	case 1:
	    timeout(handle_expirations, (void *) NULL, 
		    hz * (explist->exp_timeout - time.tv_sec));
	    break;
	    
	case 2:
	    untimeout(handle_expirations, (void *) NULL);
	    timeout(handle_expirations, (void *) NULL,
		    hz * (explist->exp_timeout - time.tv_sec));
	    break;
	    
	default:
	    break;
d558 2
d564 1
a564 1
	  union sockaddr_union * dst, union sockaddr_union *dstmask,
d719 13
a731 3
    /* removal of a larval SA should not remove the mature SA's expirations */
    if ((tdbp->tdb_flags & TDBF_INVALID) == 0)
      cleanup_expirations(&tdbp->tdb_dst, tdbp->tdb_spi, tdbp->tdb_sproto);
@


1.39
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.38 1999/03/24 17:00:47 niklas Exp $	*/
d89 1
a89 1
int encdebug = 0;
@


1.38
log
@Implement lifetime expiration notifications.  Fix some typos.  Remove statics.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.37 1999/03/04 21:51:27 deraadt Exp $	*/
d187 1
d195 2
a196 11

    bzero((caddr_t) re, sizeof(*re));
    dst = (struct sockaddr_encap *) &re->re_dst;
    dst->sen_family = PF_KEY;
    dst->sen_len = SENT_IP4_LEN;
    dst->sen_type = SENT_IP4;
    dst->sen_ip_src = inp->inp_laddr;
    dst->sen_ip_dst.s_addr = inp->inp_faddr.s_addr ? 
			     inp->inp_faddr.s_addr : daddr;
    dst->sen_proto = so->so_proto->pr_protocol;
    switch (dst->sen_proto)
d198 13
a210 2
	case IPPROTO_UDP:
	case IPPROTO_TCP:
d214 1
a214 1
	default:
d217 1
a217 1
    }
d219 2
a220 2
    /* Try to find a flow */
    rtalloc((struct route *) re);
d222 5
a226 11
    if (re->re_rt != NULL)
    {
	struct tdb *tdb;
	struct sockaddr_encap *gw;
		
	gw = (struct sockaddr_encap *) (re->re_rt->rt_gateway);

	if (gw->sen_type == SENT_IPSP) {
	    sunion.sin.sin_family = AF_INET;
	    sunion.sin.sin_len = sizeof(struct sockaddr_in);
	    sunion.sin.sin_addr = gw->sen_ipsp_dst;
d228 17
a244 2
	    tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, &sunion,
					gw->sen_ipsp_sproto);
d246 3
a248 13
	    SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdb);
	}
	else 
	  sa_have = 0;
	
	RTFREE(re->re_rt);
	
	/* Check if our requirements are met */
	if (!(sa_require & ~sa_have))
	  return 0;
    }
    else
      sa_have = 0;
d295 18
d682 1
d730 18
d775 4
d798 1
a798 1
    struct tdb *tdb;
d911 16
@


1.37
log
@be more careful with freeing TDBs
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.36 1999/03/04 20:30:36 deraadt Exp $	*/
d474 1
a474 3
/* XXX
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d482 1
a482 3
/* XXX
   encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
*/
d491 1
a491 3
/* XXX
   encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
d499 1
a499 3
/* XXX
   encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
*/
d709 3
a711 1
    cleanup_expirations(&tdbp->tdb_dst, tdbp->tdb_spi, tdbp->tdb_sproto);
d831 1
a831 1
		    l += sprintf(buffer + l, "halviv");
@


1.36
log
@more paranoid maintenance
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.35 1999/02/25 22:37:29 angelos Exp $	*/
d466 1
d468 1
a468 4
	{
	    free(exp, M_TDB);
	    continue;			/* TDB is gone, ignore this */
	}
d478 1
d488 1
a509 2

	free(exp, M_TDB);
@


1.35
log
@Prettier reporting, report number of flows in use per SA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.34 1999/02/25 20:21:07 angelos Exp $	*/
a671 1
    struct flow *flow;
d713 1
a713 1
    for (flow = tdbp->tdb_flow; flow; flow = tdbp->tdb_flow)
d715 1
a715 1
	delete_flow(flow, tdbp);
@


1.34
log
@Print more information in /kern/ipsec
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.33 1999/02/24 23:45:51 angelos Exp $	*/
d763 1
d894 4
a897 3
	    if (tdb->tdb_flow)
	      l+= sprintf(buffer + l,
			  "\tCurrently used by at least one flow\n");
d899 4
a902 1
	    l += sprintf(buffer + l, "\t\tCurrently %qu bytes processed\n",
a903 3
	    
	    l += sprintf(buffer + l, "\t\t%u flows processed so far\n",
			 tdb->tdb_cur_allocations);
@


1.33
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.32 1999/02/24 22:33:05 angelos Exp $	*/
d894 2
a895 1
	      l+= sprintf(buffer + l, "\tUsed by at least one flow\n");
d897 6
a922 5
	    if ((tdb->tdb_flags & TDBF_BYTES) ||
		(tdb->tdb_flags & TDBF_SOFT_BYTES))
	    l += sprintf(buffer + l, "\t\tCurrently %qu bytes processed\n",
			 tdb->tdb_cur_bytes);
	    
a932 5
	    if ((tdb->tdb_flags & TDBF_ALLOCATIONS) ||
		(tdb->tdb_flags & TDBF_SOFT_ALLOCATIONS))
	      l += sprintf(buffer + l, "\t\tCurrently %u flows processed\n",
			   tdb->tdb_cur_allocations);
	    
d946 11
a956 10
	    if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE) {
	      if (tdb->tdb_first_use)
		l += sprintf(buffer + l,
			     "\t\tSoft expiration(2) in %qu seconds\n",
			     (tdb->tdb_first_use + tdb->tdb_soft_first_use) -
			     time.tv_sec);
	      else
		l += sprintf(buffer + l,
			     "\t\tSoft expiration in %qu seconds after first "
			     "use\n", tdb->tdb_soft_first_use);
@


1.32
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.31 1999/01/11 22:52:10 deraadt Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
@


1.31
log
@remove panic() calls, consistent error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.30 1998/11/16 08:02:59 niklas Exp $	*/
d65 1
a65 1
#include <net/encap.h>
a71 1
#include <sys/syslog.h>
a78 1
int		tdb_init __P((struct tdb *, struct mbuf *));
a81 1
extern void	encap_sendnotify __P((int, struct tdb *, void *));
d88 1
d91 19
d120 1
a120 1
    { XF_OLD_AH,         XFT_AUTH,	  "Keyed Authentication, RFC 1828/1852",
d146 1
a146 1
	u_int8_t sareq = 0;
d148 20
a167 17
	if (inp != NULL) {
		sareq |= inp->inp_seclevel[SL_AUTH] >= IPSEC_LEVEL_USE ? 
			NOTIFY_SATYPE_AUTH : 0;
		sareq |= inp->inp_seclevel[SL_ESP_TRANS] >= IPSEC_LEVEL_USE ?
			NOTIFY_SATYPE_CONF : 0;
		sareq |= inp->inp_seclevel[SL_ESP_NETWORK] >= IPSEC_LEVEL_USE ?
			NOTIFY_SATYPE_TUNNEL : 0;
	} else {
		sareq |= ipsec_auth_default_level >= IPSEC_LEVEL_USE ? 
			NOTIFY_SATYPE_AUTH : 0;
		sareq |= ipsec_esp_trans_default_level >= IPSEC_LEVEL_USE ? 
			NOTIFY_SATYPE_CONF : 0;
		sareq |= ipsec_esp_network_default_level >= IPSEC_LEVEL_USE ? 
			NOTIFY_SATYPE_TUNNEL : 0;
	}

	return (sareq);
d179 25
a203 24
	struct socket *so;
	struct route_enc re0, *re = &re0;
	struct sockaddr_encap *dst; 
	struct tdb tmptdb;
	u_int8_t sa_require, sa_have;
	int error, i;

	if (inp == NULL || ((so=inp->inp_socket) == 0))
		return (EINVAL);

	/* If IPSEC is not required just use what we got */
	if (!(sa_require = inp->inp_secrequire))
		return 0;

	bzero((caddr_t) re, sizeof(*re));
	dst = (struct sockaddr_encap *) &re->re_dst;
	dst->sen_family = AF_ENCAP;
	dst->sen_len = SENT_IP4_LEN;
	dst->sen_type = SENT_IP4;
	dst->sen_ip_src = inp->inp_laddr;
	dst->sen_ip_dst.s_addr = inp->inp_faddr.s_addr ? 
		inp->inp_faddr.s_addr : daddr;
	dst->sen_proto = so->so_proto->pr_protocol;
	switch (dst->sen_proto) {
d206 3
a208 3
		dst->sen_sport = inp->inp_lport;
		dst->sen_dport = inp->inp_fport;
		break;
d210 23
a232 2
		dst->sen_sport = 0;
		dst->sen_dport = 0;
d234 11
d246 1
a246 2
	/* Try to find a flow */
	rtalloc((struct route *) re);
d248 11
a258 43
	if (re->re_rt != NULL) {
		struct tdb *tdb;
		struct sockaddr_encap *gw;
		
		gw = (struct sockaddr_encap *) (re->re_rt->rt_gateway);
	     
		if (gw->sen_type == SENT_IPSP) {
			tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, 
						    gw->sen_ipsp_dst,
						    gw->sen_ipsp_sproto);

			SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdb);
		} else 
			sa_have = 0;

		RTFREE(re->re_rt);

		/* Check if our requirements are met */
		if (!(sa_require & ~sa_have))
			return 0;
	} else
		sa_have = 0;

	error = i = 0;

	inp->inp_secresult = SR_WAIT;

	/* If necessary try to notify keymanagement three times */
	while (i < 3) {
	        DPRINTF(("ipsec: send SA request (%d), remote ip: %0x, SA type: %d\n", i+1, dst->sen_ip_dst, sa_require));

		/* Send notify */
		bzero((caddr_t) &tmptdb, sizeof(tmptdb));
		tmptdb.tdb_src = dst->sen_ip_src;
		tmptdb.tdb_dst = dst->sen_ip_dst;
		/*
		 * When we already have an insufficient SA, we need to
		 * establish a new SA which combines the required
		 * attributes and the already existant. This can go
		 * once we can do socket specific keying.
		 */
		tmptdb.tdb_satype = sa_require | sa_have;
		encap_sendnotify(NOTIFY_REQUEST_SA, &tmptdb, inp); 
d260 26
a285 27
		/* 
		 * Wait for the keymanagement daemon to establich a new SA,
		 * even on error check again, perhaps some other process
		 * already established the necessary SA.
		 */
		error = tsleep((caddr_t)inp, PSOCK|PCATCH, "ipsecnotify", 30*hz);

	        DPRINTF(("check_ipsec: sleep %d\n", error));

		if (error && error != EWOULDBLOCK)
			break;
		/* 
		 * A Key Management daemon returned an apropriate SA back
		 * to the kernel, the kernel noted that state in the waiting
		 * socket.
		 */
		if (inp->inp_secresult == SR_SUCCESS)
			return (0);
		/*
		 * Key Management returned a permanent failure, we do not
		 * need to retry again. XXX - when more than one key
		 * management daemon is available we can not do that.
		 */
		if (inp->inp_secresult == SR_FAILED)
			break;
		i++;
	}
d287 1
a287 1
	return (error ? error : EWOULDBLOCK);
d293 1
a293 1
 * SPI. SPIs less than 255 are reserved, so we check for those too.
d297 2
a298 1
reserve_spi(u_int32_t tspi, struct in_addr src, u_int8_t proto, int *errval)
d301 8
a308 1
    u_int32_t spi = tspi;		/* Don't change */
d310 6
a315 1
    while (1)
d317 1
a317 5
	while (ntohl(spi) <= 255)		/* Get a new SPI */
	  get_random_bytes((void *) &spi, sizeof(spi));
	
	/* Check whether we're using this SPI already */
	if (gettdb(spi, src, proto) != (struct tdb *) NULL)
d319 3
a321 1
	    if (tspi != 0)		/* If one was proposed, report error */
d323 2
a324 2
		(*errval) = EEXIST;
	      	return 0;
d326 8
d335 3
a337 3
	    spi = 0;
	    continue;
	}
d339 2
a340 8
	MALLOC(tdbp, struct tdb *, sizeof(*tdbp), M_TDB, M_WAITOK);
	if (tdbp == NULL)
	{
	    (*errval) = ENOBUFS;
	    return 0;
	} 

	bzero((caddr_t) tdbp, sizeof(*tdbp));
d343 5
a347 3
	tdbp->tdb_dst = src;
	tdbp->tdb_sproto = proto;
	tdbp->tdb_flags |= TDBF_INVALID;
a348 1
	
d350 2
d355 3
d369 1
a369 1
gettdb(u_int32_t spi, struct in_addr dst, u_int8_t proto)
d371 2
a372 1
    int hashval;
d374 7
a380 3
	
    hashval = (spi + dst.s_addr + proto) % TDB_HASHMOD;
	
d382 3
a384 2
      if ((tdbp->tdb_spi == spi) && (tdbp->tdb_dst.s_addr == dst.s_addr)
	  && (tdbp->tdb_sproto == proto))
a395 3
    if (flow == (struct flow *) NULL)
      return (struct flow *) NULL;

a407 2
    if (exp == (struct expiration *) NULL)
      return (struct expiration *) NULL;
d415 1
a415 1
cleanup_expirations(struct in_addr dst, u_int32_t spi, u_int8_t sproto)
d418 3
a420 3
    
    for (exp = explist; exp; exp = exp ? exp->exp_next : explist)
      if ((exp->exp_dst.s_addr == dst.s_addr) &&
d432 1
a432 1
	 
d435 1
a435 1
	  free(nexp, M_TDB);
d463 1
a463 1
	tdb = gettdb(exp->exp_spi, exp->exp_dst, exp->exp_sproto);
d470 3
a472 2
	/* Soft expirations */
	if (tdb->tdb_flags & TDBF_SOFT_TIMER)
d474 8
a481 1
	  if (tdb->tdb_soft_timeout <= time.tv_sec)
d483 4
a486 2
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
	      tdb->tdb_flags &= ~TDBF_SOFT_TIMER;
a487 9
	  else
	    if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
	      if (tdb->tdb_first_use + tdb->tdb_soft_first_use <=
		  time.tv_sec)
	      {
		  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb, NULL);
		  tdb->tdb_flags &= ~TDBF_SOFT_FIRSTUSE;
	      }
	}
d489 3
a491 2
	/* Hard expirations */
	if (tdb->tdb_flags & TDBF_TIMER)
d493 9
a501 1
	  if (tdb->tdb_exp_timeout <= time.tv_sec)
d503 4
a506 2
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
	      tdb_delete(tdb, 0);
a507 9
	  else
	    if (tdb->tdb_flags & TDBF_FIRSTUSE)
	      if (tdb->tdb_first_use + tdb->tdb_exp_first_use <=
		  time.tv_sec)
	      {
		  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb, NULL);
		  tdb_delete(tdb, 0);
	      }
	}
d580 3
a582 3
find_flow(struct in_addr src, struct in_addr srcmask, struct in_addr dst,
	  struct in_addr dstmask, u_int8_t proto, u_int16_t sport,
	  u_int16_t dport, struct tdb *tdb)
d587 5
a591 6
      if ((src.s_addr == flow->flow_src.s_addr) &&
	  (dst.s_addr == flow->flow_dst.s_addr) &&
	  (srcmask.s_addr == flow->flow_srcmask.s_addr) &&
	  (dstmask.s_addr == flow->flow_dstmask.s_addr) &&
	  (proto == flow->flow_proto) &&
	  (sport == flow->flow_sport) && (dport == flow->flow_dport))
d598 3
a600 3
find_global_flow(struct in_addr src, struct in_addr srcmask,
		 struct in_addr dst, struct in_addr dstmask,
		 u_int8_t proto, u_int16_t sport, u_int16_t dport)
d608 2
a609 2
	if ((flow = find_flow(src, srcmask, dst, dstmask, proto, sport,
			      dport, tdb)) != (struct flow *) NULL)
d618 2
a619 1
    int hashval;
d621 4
a624 2
    hashval = ((tdbp->tdb_sproto + tdbp->tdb_spi + tdbp->tdb_dst.s_addr)
	       % TDB_HASHMOD);
d646 1
a646 1
    if (tdb->tdb_flow == flow)
d648 12
a659 9
	tdb->tdb_flow = flow->flow_next;
	if (tdb->tdb_flow)
	  tdb->tdb_flow->flow_prev = (struct flow *) NULL;
    }
    else
    {
	flow->flow_prev->flow_next = flow->flow_next;
	if (flow->flow_next)
	  flow->flow_next->flow_prev = flow->flow_prev;
d668 1
d671 4
a674 1
    int hashval;
d676 1
a676 2
    hashval = ((tdbp->tdb_sproto + tdbp->tdb_spi + tdbp->tdb_dst.s_addr)
	       % TDB_HASHMOD);
d691 6
a696 5
    if (tdbp != tdbpp)
      return EINVAL;		/* Should never happen */

    /* If there was something before us in the chain, make it point nowhere */
    if (tdbp->tdb_inext)
d699 6
a704 2
    /* If there was something after us in the chain, make it point nowhere */
    if (tdbp->tdb_onext)
d706 1
a706 1

d708 1
a708 1

d713 12
a724 1
      delete_flow(flow, tdbp);
a725 2
    cleanup_expirations(tdbp->tdb_dst, tdbp->tdb_spi, tdbp->tdb_sproto);
    
d735 1
a735 1
tdb_init(struct tdb *tdbp, struct mbuf *m)
a736 2
    int alg;
    struct encap_msghdr *em;
a737 3
	
    em = mtod(m, struct encap_msghdr *);
    alg = em->em_alg;
a740 1

d745 1
a745 1
	return (*(xsp->xf_init))(tdbp, xsp, m);
d747 3
a749 2
    DPRINTF(("tdb_init(): no alg %d for spi %08x, addr %x, proto %d\n", 
	    alg, ntohl(tdbp->tdb_spi), tdbp->tdb_dst.s_addr, tdbp->tdb_sproto));
a761 1
    struct flow *fl;
d781 4
a784 4
			ntohl(tdb->tdb_spi), inet_ntoa(tdb->tdb_dst),
			tdb->tdb_sproto);
	    
	    l += sprintf(buffer + l, "\testablished %d seconds ago\n",
d786 76
a861 4
	   
	    l += sprintf(buffer + l, "\tsrc = %s, flags = %08x, SAtype = %u\n",
			 inet_ntoa(tdb->tdb_src), tdb->tdb_flags,
			 tdb->tdb_satype);
a865 2
	    else
	      l += sprintf(buffer + l, "\txform = <(null)>\n");
d867 7
a873 11
	    if (tdb->tdb_confname)
	      l += sprintf(buffer + l, "\t\tencryption = <%s>\n",
			   tdb->tdb_confname);
	    if (tdb->tdb_authname)
	      l += sprintf(buffer + l, "\t\tauthentication = <%s>\n",
			   tdb->tdb_authname);

	    l += sprintf(buffer + l, "\tOSrc = %s", inet_ntoa(tdb->tdb_osrc));
	    
	    l += sprintf(buffer + l, " ODst = %s, TTL = %u\n",
			 inet_ntoa(tdb->tdb_odst), tdb->tdb_ttl);
d877 1
a877 1
			   "\tNext (on output) SA: SPI = %08x, "
d880 1
a880 1
			   inet_ntoa(tdb->tdb_onext->tdb_dst),
d885 1
a885 1
			   "\tNext (on input) SA: SPI = %08x, "
d888 1
a888 1
			   inet_ntoa(tdb->tdb_inext->tdb_dst),
d891 3
a893 9
	    /* XXX We can reuse variable i, we're not going to loop again */
	    for (i = 0, fl = tdb->tdb_flow; fl; fl = fl->flow_next)
	      i++;

	    l += sprintf(buffer + l,
			 "\t%u flows counted "
			 "(use netstat -r for  more information)\n",
			 i);
	    
d914 2
d919 1
a919 1
	    if (tdb->tdb_flags & TDBF_PACKETS)
d921 2
a922 2
			   "\t\tHard expiration after %qu packets\n",
			   tdb->tdb_exp_packets);
d924 1
a924 1
	    if (tdb->tdb_flags & TDBF_SOFT_PACKETS)
d926 2
a927 2
			   "\t\tSoft expiration after %qu packets\n",
			   tdb->tdb_soft_packets);
d929 4
a932 2
	    l += sprintf(buffer + l, "\t\tCurrently %qu packets processed\n",
			 tdb->tdb_cur_packets);
d934 3
a936 2
	    if (tdb->tdb_flags & TDBF_FIRSTUSE) {
	      if (tdb->tdb_first_use)
d941 1
a941 1
	      else
d960 1
a960 1
				    TDBF_SOFT_PACKETS | TDBF_PACKETS |
d971 30
@


1.30
log
@Please GCC
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.29 1998/11/16 08:00:43 niklas Exp $	*/
d74 6
d225 1
a225 5
#ifdef ENCDEBUG
	        if (encdebug)
		        printf("ipsec: send SA request (%d), remote ip: %0x, SA type: %d\n",
			       i+1, dst->sen_ip_dst, sa_require);
#endif /* ENCDEBUG */
d247 1
a247 4
#ifdef ENCDEBUG
		if (encdebug)
		        printf("check_ipsec: sleep %d\n", error);
#endif /* ENCDEBUG */
d483 1
a483 4
#ifdef ENCDEBUG
	if (encdebug)
	  log(LOG_WARNING, "put_expiration(): NULL argument\n");
#endif /* ENCDEBUG */	
d689 2
a690 3
    if (encdebug)
      log(LOG_ERR, "tdb_init(): no alg %d for spi %08x, addr %x, proto %d\n", 
	  alg, ntohl(tdbp->tdb_spi), tdbp->tdb_dst.s_addr, tdbp->tdb_sproto);
@


1.29
log
@Break long lines.  Use correct format for expiry times
Present "first use" expirations correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.28 1998/11/16 04:06:45 deraadt Exp $	*/
d817 1
a817 1
	    if (tdb->tdb_flags & TDBF_FIRSTUSE)
d827 1
d829 1
a829 1
	    if (tdb->tdb_flags & TDBF_SOFT_FIRSTUSE)
d839 1
@


1.28
log
@SPIs are kept in network byte order
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.27 1998/10/13 06:49:46 niklas Exp $	*/
d757 6
a762 1
	      l += sprintf(buffer + l, "\tNext (on output) SA: SPI = %08x, Destination = %s, Sproto = %u\n", ntohl(tdb->tdb_onext->tdb_spi), inet_ntoa(tdb->tdb_onext->tdb_dst), tdb->tdb_onext->tdb_sproto);
d765 6
a770 1
	      l += sprintf(buffer + l, "\tNext (on input) SA: SPI = %08x, Destination = %s, Sproto = %u\n", ntohl(tdb->tdb_inext->tdb_spi), inet_ntoa(tdb->tdb_inext->tdb_dst), tdb->tdb_inext->tdb_sproto);
d776 4
a779 1
	    l += sprintf(buffer + l, "\t%u flows counted (use netstat -r for  more information)\n", i);
d784 2
a785 1
	      l += sprintf(buffer + l, "\t\tHard expiration(1) in %u seconds\n",
d789 2
a790 1
	      l += sprintf(buffer + l, "\t\tSoft expiration(1) in %u seconds\n",
d818 10
a827 4
	      l += sprintf(buffer + l, "\t\tHard expiration(2) in %u seconds\n",
			   (tdb->tdb_established + tdb->tdb_exp_first_use) -
			   time.tv_sec);
	    
d829 9
a837 3
	      l += sprintf(buffer + l, "\t\tSoft expiration(2) in %u seconds\n",
			   (tdb->tdb_established + tdb->tdb_soft_first_use) -
			   time.tv_sec);
@


1.27
log
@Remove NULL deref condition
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.26 1998/05/18 21:10:57 provos Exp $	*/
d286 1
a286 1
	while (spi <= 255)		/* Get a new SPI */
@


1.26
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.24 1998/02/22 01:23:33 niklas Exp $	*/
d381 1
a381 1
    for (exp = explist; exp; exp = exp->exp_next)
@


1.25
log
@fix tdb_delete() when using SPI chains.
@
text
@a0 1

d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
d51 1
d74 9
a82 2
int	tdb_init __P((struct tdb *, struct mbuf *));
int	ipsp_kern __P((int, char **, int));
a86 1
extern void encap_sendnotify(int, struct tdb *);
d116 155
d437 1
a437 1
	      encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d445 1
a445 1
		  encap_sendnotify(NOTIFY_SOFT_EXPIRE, tdb);
d455 1
a455 1
	      encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
d463 1
a463 1
		  encap_sendnotify(NOTIFY_HARD_EXPIRE, tdb);
@


1.24
log
@Changes made for GCC 2.8 -Wall pleasures
@
text
@d2 1
a2 1
/*	$OpenBSD: ip_ipsp.c,v 1.23 1997/11/04 09:11:15 provos Exp $	*/
d484 4
@


1.23
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d2 1
a2 1
/*	$OpenBSD: ip_ipsp.c,v 1.22 1997/10/02 02:31:06 deraadt Exp $	*/
d267 1
d281 2
a282 1
	
d285 1
d299 1
@


1.22
log
@conditional error logging
@
text
@d1 2
a2 1
/*	$OpenBSD: ip_ipsp.c,v 1.21 1997/10/01 02:34:06 deraadt Exp $	*/
d13 5
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
d568 7
@


1.21
log
@should report unsigned quantities
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.20 1997/09/28 22:57:50 deraadt Exp $	*/
d513 3
a515 2
    log(LOG_ERR, "tdb_init(): no alg %d for spi %08x, addr %x, proto %d\n", 
	alg, ntohl(tdbp->tdb_spi), tdbp->tdb_dst.s_addr, tdbp->tdb_sproto);
d570 1
a570 1
	      l += sprintf(buffer + l, "\tNext (on output) SA: SPI = %08x, Destination = %s, Sproto = %u\n", tdb->tdb_onext->tdb_spi, inet_ntoa(tdb->tdb_onext->tdb_dst), tdb->tdb_onext->tdb_sproto);
d573 1
a573 1
	      l += sprintf(buffer + l, "\tNext (on input) SA: SPI = %08x, Destination = %s, Sproto = %u\n", tdb->tdb_inext->tdb_spi, inet_ntoa(tdb->tdb_inext->tdb_dst), tdb->tdb_inext->tdb_sproto);
@


1.20
log
@log() needs a \n
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.19 1997/09/23 21:42:21 angelos Exp $	*/
d546 1
a546 1
	    l = sprintf(buffer, "SPI = %08x, Destination = %s, Sproto = %d\n",
d553 1
a553 1
	    l += sprintf(buffer + l, "\tsrc = %s, flags = %08x, SAtype = %d\n",
d565 1
a565 1
	    l += sprintf(buffer + l, " ODst = %s, TTL = %d\n",
d569 1
a569 1
	      l += sprintf(buffer + l, "\tNext (on output) SA: SPI = %08x, Destination = %s, Sproto = %d\n", tdb->tdb_onext->tdb_spi, inet_ntoa(tdb->tdb_onext->tdb_dst), tdb->tdb_onext->tdb_sproto);
d572 1
a572 1
	      l += sprintf(buffer + l, "\tNext (on input) SA: SPI = %08x, Destination = %s, Sproto = %d\n", tdb->tdb_inext->tdb_spi, inet_ntoa(tdb->tdb_inext->tdb_dst), tdb->tdb_inext->tdb_sproto);
d578 1
a578 1
	    l += sprintf(buffer + l, "\t%d flows counted (use netstat -r for  more information)\n", i);
d583 1
a583 1
	      l += sprintf(buffer + l, "\t\tHard expiration(1) in %d seconds\n",
d587 1
a587 1
	      l += sprintf(buffer + l, "\t\tSoft expiration(1) in %d seconds\n",
d591 1
a591 1
	      l += sprintf(buffer + l, "\t\tHard expiration after %qd bytes\n",
d595 1
a595 1
	      l += sprintf(buffer + l, "\t\tSoft expiration after %qd bytes\n",
d598 1
a598 1
	    l += sprintf(buffer + l, "\t\tCurrently %qd bytes processed\n",
d603 1
a603 1
			   "\t\tHard expiration after %qd packets\n",
d608 1
a608 1
			   "\t\tSoft expiration after %qd packets\n",
d611 1
a611 1
	    l += sprintf(buffer + l, "\t\tCurrently %qd packets processed\n",
d615 1
a615 1
	      l += sprintf(buffer + l, "\t\tHard expiration(2) in %d seconds\n",
d620 1
a620 1
	      l += sprintf(buffer + l, "\t\tSoft expiration(2) in %d seconds\n",
@


1.19
log
@AH changes, after interoperating at the ANX bakeoff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.18 1997/07/28 18:55:33 provos Exp $	*/
d310 1
a310 1
	  log(LOG_WARNING, "put_expiration(): NULL argument");
d513 2
a514 2
    log(LOG_ERR, "tdb_init(): no alg %d for spi %08x, addr %x, proto %d", alg,
	ntohl(tdbp->tdb_spi), tdbp->tdb_dst.s_addr, tdbp->tdb_sproto);
@


1.18
log
@make it compile
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.17 1997/07/27 23:30:36 niklas Exp $	*/
d591 2
a592 1
	      l += sprintf(buffer + l, "\t\tHard expiration after %qd bytes (currently %qd bytes processed)\n", tdb->tdb_exp_bytes, tdb->tdb_cur_bytes);
d595 5
a599 1
	      l += sprintf(buffer + l, "\t\tSoft expiration after %qd bytes (currently %qd bytes processed)\n", tdb->tdb_soft_bytes, tdb->tdb_cur_bytes);
d602 3
a604 1
	      l += sprintf(buffer + l, "\t\tHard expiration after %qd packets (currently %qd packets processed)\n", tdb->tdb_exp_packets, tdb->tdb_cur_packets);
d607 6
a612 1
	      l += sprintf(buffer + l, "\t\tSoft expiration after %qd packets (currently %qd packets processed)\n", tdb->tdb_soft_packets, tdb->tdb_cur_packets);
@


1.17
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.16 1997/07/24 01:45:29 deraadt Exp $	*/
d310 1
a310 1
	  log(LOG_WARN, "put_expiration(): NULL argument");
@


1.16
log
@bail properly if malloc fails
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.15 1997/07/18 18:09:56 provos Exp $	*/
d67 3
d143 2
a144 1

d189 176
d483 3
a485 1
 
d504 5
d515 1
a515 5

    /* Record establishment time */
    tdbp->tdb_established = time.tv_sec;

    m_freem(m);
d520 1
a520 1
 * XXX This should change to something cleaner.
d525 98
@


1.15
log
@enablespi/disablespi in encap + print spi's in hostorder
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.14 1997/07/15 23:11:10 provos Exp $	*/
a129 1
	    spi = 0;
d131 1
@


1.14
log
@flags for tunnels and replacing existing routes, sysctl! + tiny bug fix
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.13 1997/07/11 23:37:58 provos Exp $	*/
d327 1
a327 1
	tdbp->tdb_spi, tdbp->tdb_dst.s_addr, tdbp->tdb_sproto);
@


1.13
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.12 1997/07/02 06:58:42 provos Exp $	*/
d238 2
@


1.12
log
@fix neglected _FLEN's + reserve_spi + output reserved spi's without alg.
correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.11 1997/07/01 22:12:51 provos Exp $	*/
d61 1
d66 1
a66 3
#ifdef ENCDEBUG
int encdebug = 1;
#endif
d77 13
a89 26
    { XF_AHMD5,	         XFT_AUTH,	  "Keyed MD5 Authentication",
      ahmd5_attach,      ahmd5_init,      ahmd5_zeroize,
      ahmd5_input,       ahmd5_output, },
    { XF_AHSHA1,         XFT_AUTH,	  "Keyed SHA1 Authentication",
      ahsha1_attach,     ahsha1_init,     ahsha1_zeroize,
      ahsha1_input,      ahsha1_output, },
    { XF_ESPDES,         XFT_CONF,        "DES-CBC Encryption",
      espdes_attach,     espdes_init,     espdes_zeroize,
      espdes_input,      espdes_output, },
    { XF_ESP3DES,        XFT_CONF,        "3DES-CBC Encryption",
      esp3des_attach,    esp3des_init,    esp3des_zeroize,
      esp3des_input,     esp3des_output, },
    { XF_AHHMACMD5,	 XFT_AUTH,	  "HMAC MD5 Authentication",
      ahhmacmd5_attach,	 ahhmacmd5_init,  ahhmacmd5_zeroize,
      ahhmacmd5_input,	 ahhmacmd5_output, },
    { XF_AHHMACSHA1,	 XFT_AUTH,	  "HMAC SHA1 Authentication",
      ahhmacsha1_attach, ahhmacsha1_init, ahhmacsha1_zeroize,
      ahhmacsha1_input,	 ahhmacsha1_output, },
    { XF_ESPDESMD5,	 XFT_CONF|XFT_AUTH,     
      "DES-CBC Encryption + MD5 Authentication",
      espdesmd5_attach,	 espdesmd5_init,  espdesmd5_zeroize,
      espdesmd5_input,	 espdesmd5_output, },
    { XF_ESP3DESMD5,	 XFT_CONF|XFT_AUTH,     
      "3DES-CBC Encryption + MD5 Authentication",
      esp3desmd5_attach, esp3desmd5_init, esp3desmd5_zeroize,
      esp3desmd5_input,	 esp3desmd5_output, },
a95 2
static char *ipspkernfs = NULL;
int ipspkernfs_dirty = 1;
d104 1
a104 1
reserve_spi(u_int32_t tspi, struct in_addr src, int *errval)
d112 1
a112 1
	  get_random_bytes((void *)&spi, sizeof(spi));
d115 1
a115 1
	if (gettdb(spi, src) != (struct tdb *) NULL)
d134 1
a134 1
	bzero((caddr_t)tdbp, sizeof(*tdbp));
d138 1
d149 4
a152 4
 * packet and the destination address of the packet. When we receive
 * an IPSP packet, we need to look up its tunnel descriptor block, 
 * based on the SPI in the packet and the destination address (which is
 * really one of our addresses if we received the packet!
d156 1
a156 1
gettdb(u_int32_t spi, struct in_addr dst)
d161 1
a161 1
    hashval = (spi+dst.s_addr) % TDB_HASHMOD;
d164 2
a165 1
      if ((tdbp->tdb_spi == spi) && (tdbp->tdb_dst.s_addr == dst.s_addr))
d171 51
d227 2
a228 1
    hashval = ((tdbp->tdb_spi + tdbp->tdb_dst.s_addr) % TDB_HASHMOD);
d231 29
d261 1
a261 1
    ipspkernfs_dirty = 1;
d268 1
d271 2
a272 1
    hashval = ((tdbp->tdb_spi + tdbp->tdb_dst.s_addr) % TDB_HASHMOD);
d289 5
a293 2
	
    ipspkernfs_dirty = 1;
d299 3
d303 1
d324 2
a325 5
#ifdef ENCDEBUG
    if (encdebug)
      printf("tdbinit: no alg %d for spi %x, addr %x\n", alg, tdbp->tdb_spi,
	     ntohl(tdbp->tdb_dst.s_addr));
#endif
d329 1
a329 1
    
d340 1
a340 59
    struct tdb *tdbp;
    int i, k;
    char *b;

    if (off != 0)
      return 0;

    if ((!ipspkernfs_dirty) && (ipspkernfs))
    {
	*bufp = ipspkernfs;
	return strlen(ipspkernfs);
    }
    else
      ipspkernfs_dirty = 0;

    if (ipspkernfs)
    {
      	FREE(ipspkernfs, M_XDATA);
	ipspkernfs = NULL;
    }

    for (i = 0, k = 0; i < TDB_HASHMOD; i++)
      for (tdbp = tdbh[i]; tdbp != (struct tdb *) NULL; tdbp = tdbp->tdb_hnext)
      {
	  /* Being paranoid to avoid buffer overflows */

	  if (tdbp->tdb_xform)
            k += 126 + strlen(tdbp->tdb_xform->xf_name);
	  else
	    k += 60;
      }

    if (k == 0)
      return 0;

    MALLOC(ipspkernfs, char *, k + 1, M_XDATA, M_DONTWAIT);
    if (!ipspkernfs)
      return 0;

    for (i = 0, k = 0; i < TDB_HASHMOD; i++)
      for (tdbp = tdbh[i]; tdbp != (struct tdb *) NULL; tdbp = tdbp->tdb_hnext)
      {
	  b = (char *)&(tdbp->tdb_dst.s_addr);
	  if (!tdbp->tdb_xform)
	    k += sprintf(ipspkernfs + k, "SPI=%x, destination=%d.%d.%d.%d\n",
			 tdbp->tdb_spi, ((int)b[0] & 0xff), ((int)b[1] & 0xff), ((int)b[2] & 0xff), ((int)b[3] & 0xff));
	  else
	    k += sprintf(ipspkernfs + k, 
		         "SPI=%x, destination=%d.%d.%d.%d\n algorithm=%d (%s)\n next SPI=%x, previous SPI=%x\n", 
		         ntohl(tdbp->tdb_spi), ((int)b[0] & 0xff), ((int)b[1] & 0xff), 
		         ((int)b[2] & 0xff), ((int)b[3] & 0xff), 
		         tdbp->tdb_xform->xf_type, tdbp->tdb_xform->xf_name,
		         (tdbp->tdb_onext ? ntohl(tdbp->tdb_onext->tdb_spi) : 0),
		         (tdbp->tdb_inext ? ntohl(tdbp->tdb_inext->tdb_spi) : 0));
      }

    ipspkernfs[k] = '\0';
    *bufp = ipspkernfs;
    return strlen(ipspkernfs);
@


1.11
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.10 1997/06/25 07:53:28 provos Exp $	*/
d120 1
a120 1
reserve_spi(u_int32_t tspi, struct in_addr src)
d134 5
a138 2
	      return 0;
	    
d145 4
a148 1
	  return 0;
d223 4
a226 1
    (*(tdbp->tdb_xform->xf_zeroize))(tdbp);
d293 4
a296 1
          k += 126 + strlen(tdbp->tdb_xform->xf_name);
d310 11
a320 7
	  k += sprintf(ipspkernfs + k, 
		       "SPI=%x, destination=%d.%d.%d.%d\n algorithm=%d (%s)\n next SPI=%x, previous SPI=%x\n", 
		       ntohl(tdbp->tdb_spi), ((int)b[0] & 0xff), ((int)b[1] & 0xff), 
		       ((int)b[2] & 0xff), ((int)b[3] & 0xff), 
		       tdbp->tdb_xform->xf_type, tdbp->tdb_xform->xf_name,
		       (tdbp->tdb_onext ? ntohl(tdbp->tdb_onext->tdb_spi) : 0),
		       (tdbp->tdb_inext ? ntohl(tdbp->tdb_inext->tdb_spi) : 0));
@


1.10
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.9 1997/06/24 12:15:25 provos Exp $	*/
d74 2
a75 2
    { XF_IP4,		0,		"IPv4 Simple Encapsulation",
      ipe4_attach,		ipe4_init,	ipe4_zeroize,
d78 26
a103 24
    { XF_AHMD5,		XFT_AUTH,	"Keyed MD5 Authentication",
      ahmd5_attach,		ahmd5_init,	ahmd5_zeroize,
      ahmd5_input,		ahmd5_output, },
    { XF_AHSHA1,		XFT_AUTH,	"Keyed SHA1 Authentication",
      ahsha1_attach,		ahsha1_init,	ahsha1_zeroize,
      ahsha1_input,		ahsha1_output, },
    { XF_ESPDES,		XFT_CONF,	"DES-CBC Encryption",
      espdes_attach,	espdes_init,	espdes_zeroize,
      espdes_input,	espdes_output, },
    { XF_ESP3DES,		XFT_CONF,	"3DES-CBC Encryption",
      esp3des_attach,	esp3des_init,	esp3des_zeroize,
      esp3des_input,	esp3des_output, },
    { XF_AHHMACMD5,		XFT_AUTH,	"HMAC MD5 Authentication",
      ahhmacmd5_attach,	ahhmacmd5_init,	ahhmacmd5_zeroize,
      ahhmacmd5_input,	ahhmacmd5_output, },
    { XF_AHHMACSHA1,	XFT_AUTH,	"HMAC SHA1 Authentication",
      ahhmacsha1_attach,	ahhmacsha1_init, ahhmacsha1_zeroize,
      ahhmacsha1_input,	ahhmacsha1_output, },
    { XF_ESPDESMD5,		XFT_CONF|XFT_AUTH,     "DES-CBC Encryption + MD5 Authentication",
      espdesmd5_attach,	espdesmd5_init,	espdesmd5_zeroize,
      espdesmd5_input,	espdesmd5_output, },
    { XF_ESP3DESMD5,	XFT_CONF|XFT_AUTH,     "3DES-CBC Encryption + MD5 Authentication",
      esp3desmd5_attach,	esp3desmd5_init,	esp3desmd5_zeroize,
      esp3desmd5_input,	esp3desmd5_output, },
d116 1
a116 1
 * SPI.
d127 1
a127 1
	while (spi == 0)		/* Get a new SPI */
d252 3
a284 4
          if (tdbp->tdb_rcvif)
            k += strlen(tdbp->tdb_rcvif->if_xname);
          else
            k += 4;
d299 1
a299 1
		       "SPI=%x, destination=%d.%d.%d.%d, interface=%s\n algorithm=%d (%s)\n next SPI=%x, previous SPI=%x\n", 
a301 1
		       (tdbp->tdb_rcvif ? tdbp->tdb_rcvif->if_xname : "none"),
@


1.9
log
@handle IP options in AH + allow IP options in outgoing encapsulated packets
+ usage counters for later use with keymanagement processes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.8 1997/06/21 00:09:19 deraadt Exp $	*/
d60 2
d76 2
a77 1
      (struct mbuf * (*)(struct mbuf *, struct tdb *))ipe4_input,		ipe4_output, },
d112 43
d181 1
d185 1
d239 2
a240 1
      printf("tdbinit: no alg %d for spi %x, addr %x\n", alg, tdbp->tdb_spi, ntohl(tdbp->tdb_dst.s_addr));
d242 4
a245 1
	
a248 1

@


1.8
log
@u_int32_t changes, need testing
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.7 1997/06/20 05:41:53 provos Exp $	*/
d93 1
a93 1
    { XF_ESPDESMD5,		XFT_CONF,     "DES-CBC Encryption + MD5 Authentication",
d96 1
a96 1
    { XF_ESP3DESMD5,	XFT_CONF,     "3DES-CBC Encryption + MD5 Authentication",
@


1.7
log
@ah-sha1 + esp-3des + indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipsp.c,v 1.6 1997/02/24 14:06:42 niklas Exp $	*/
d117 1
a117 1
gettdb(u_long spi, struct in_addr dst)
@


1.6
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 27
a98 21
{ XF_IP4,		0,		"IPv4 Simple Encapsulation",
  ipe4_attach,		ipe4_init,	ipe4_zeroize,
  (struct mbuf * (*)(struct mbuf *, struct tdb *))ipe4_input,		ipe4_output, },
{ XF_AHMD5,		XFT_AUTH,	"Keyed MD5 Authentication",
  ahmd5_attach,		ahmd5_init,	ahmd5_zeroize,
  ahmd5_input,		ahmd5_output, },
{ XF_ESPDES,		XFT_CONF,	"DES-CBC Encryption",
  espdes_attach,	espdes_init,	espdes_zeroize,
  espdes_input,	espdes_output, },
{ XF_AHHMACMD5,		XFT_AUTH,	"HMAC MD5 Authentication",
  ahhmacmd5_attach,	ahhmacmd5_init,	ahhmacmd5_zeroize,
  ahhmacmd5_input,	ahhmacmd5_output, },
{ XF_AHHMACSHA1,	XFT_AUTH,	"HMAC SHA1 Authentication",
  ahhmacsha1_attach,	ahhmacsha1_init, ahhmacsha1_zeroize,
  ahhmacsha1_input,	ahhmacsha1_output, },
{ XF_ESPDESMD5,		XFT_CONF,     "DES-CBC Encryption + MD5 Authentication",
  espdesmd5_attach,	espdesmd5_init,	espdesmd5_zeroize,
  espdesmd5_input,	espdesmd5_output, },
{ XF_ESP3DESMD5,	XFT_CONF,     "3DES-CBC Encryption + MD5 Authentication",
  esp3desmd5_attach,	esp3desmd5_init,	esp3desmd5_zeroize,
  esp3desmd5_input,	esp3desmd5_output, },
d119 2
a120 2
	int hashval;
	struct tdb *tdbp;
d122 1
a122 1
	hashval = (spi+dst.s_addr) % TDB_HASHMOD;
d124 3
a126 3
	for (tdbp = tdbh[hashval]; tdbp; tdbp = tdbp->tdb_hnext)
	  if ((tdbp->tdb_spi == spi) && (tdbp->tdb_dst.s_addr == dst.s_addr))
	    break;
d128 1
a128 1
	return tdbp;
d134 5
a138 5
	int hashval;
	hashval = ((tdbp->tdb_spi + tdbp->tdb_dst.s_addr) % TDB_HASHMOD);
	tdbp->tdb_hnext = tdbh[hashval];
	tdbh[hashval] = tdbp;
	ipspkernfs_dirty = 1;
d144 2
a145 2
	struct tdb *tdbpp;
	int hashval;
d147 1
a147 1
	hashval = ((tdbp->tdb_spi + tdbp->tdb_dst.s_addr) % TDB_HASHMOD);
d149 8
a156 1
	if (tdbh[hashval] == tdbp)
d158 2
a159 2
		tdbpp = tdbp;
		tdbh[hashval] = tdbp->tdb_hnext;
d161 12
a172 19
	else
	  for (tdbpp = tdbh[hashval]; tdbpp != NULL; tdbpp = tdbpp->tdb_hnext)
	    if (tdbpp->tdb_hnext == tdbp)
	    {
		tdbpp->tdb_hnext = tdbp->tdb_hnext;
		tdbpp = tdbp;
	    }

	if (tdbp != tdbpp)
	  return EINVAL;		/* Should never happen */
	
	ipspkernfs_dirty = 1;
	tdbpp = tdbp->tdb_onext;
	(*(tdbp->tdb_xform->xf_zeroize))(tdbp);
	FREE(tdbp, M_TDB);
	if (delchain && tdbpp)
	  return tdb_delete(tdbpp, delchain);
	else
	  return 0;
d178 10
a187 10
	int alg;
	struct encap_msghdr *em;
	struct xformsw *xsp;
	
	em = mtod(m, struct encap_msghdr *);
	alg = em->em_alg;

	for (xsp = xformsw; xsp < xformswNXFORMSW; xsp++)
	  if (xsp->xf_type == alg)
	    return (*(xsp->xf_init))(tdbp, xsp, m);
d190 2
a191 2
	if (encdebug)
	  printf("tdbinit: no alg %d for spi %x, addr %x\n", alg, tdbp->tdb_spi, ntohl(tdbp->tdb_dst.s_addr));
d194 2
a195 2
	m_freem(m);
	return EINVAL;
d247 7
a253 7
		"SPI=%x, destination=%d.%d.%d.%d, interface=%s\n algorithm=%d (%s)\n next SPI=%x, previous SPI=%x\n", 
		ntohl(tdbp->tdb_spi), ((int)b[0] & 0xff), ((int)b[1] & 0xff), 
		((int)b[2] & 0xff), ((int)b[3] & 0xff), 
		(tdbp->tdb_rcvif ? tdbp->tdb_rcvif->if_xname : "none"),
		tdbp->tdb_xform->xf_type, tdbp->tdb_xform->xf_name,
		(tdbp->tdb_onext ? ntohl(tdbp->tdb_onext->tdb_spi) : 0),
		(tdbp->tdb_inext ? ntohl(tdbp->tdb_inext->tdb_spi) : 0));
@


1.5
log
@Removed no longer necessary cautionary comment.
@
text
@d1 2
d59 3
@


1.4
log
@-nostdinc and big endian cleanup
@
text
@a63 2
 * CAUTION: the human-readable string should be LESS than 200 bytes if the
 * kernfs is to work properly.
@


1.3
log
@Fixed error introduced with last patch.
@
text
@a53 1
#define IPSEC_IPSP_C
a54 1
#undef IPSEC_IPSP_C
@


1.2
log
@Removed some of the ugliness in ipsp_kern().
@
text
@a98 1
static int ipspkernfs_len = 0;
d205 1
a205 1
	return ipspkernfs_len;
a234 2
    ipspkernfs_len = k + 1;

d251 1
a251 1
    return ipspkernfs_len;
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d183 4
a186 1
	printf("tdbinit: no alg %d for spi %x, addr %x\n", alg, tdbp->tdb_spi, ntohl(tdbp->tdb_dst.s_addr));
d198 1
a198 1
    char *b, buf[512];
d222 5
a226 12
	  if (strlen(tdbp->tdb_xform->xf_name) >= 200)
	    return 0;

	  b = (char *)&(tdbp->tdb_dst.s_addr);
	  k += sprintf(buf, 
		"SPI=%x, destination=%d.%d.%d.%d, interface=%s\n algorithm=%d (%s)\n next SPI=%x, previous SPI=%x\n", 
		ntohl(tdbp->tdb_spi), ((int)b[0] & 0xff), ((int)b[1] & 0xff), 
		((int)b[2] & 0xff), ((int)b[3] & 0xff), 
		(tdbp->tdb_rcvif ? tdbp->tdb_rcvif->if_xname : "none"),
		tdbp->tdb_xform->xf_type, tdbp->tdb_xform->xf_name,
		(tdbp->tdb_onext ? ntohl(tdbp->tdb_onext->tdb_spi) : 0),
		(tdbp->tdb_inext ? ntohl(tdbp->tdb_inext->tdb_spi) : 0));
@
