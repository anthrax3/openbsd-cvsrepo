head	1.86;
access;
symbols
	OPENBSD_6_2:1.86.0.2
	OPENBSD_6_2_BASE:1.86
	OPENBSD_6_1:1.72.0.4
	OPENBSD_6_1_BASE:1.72
	OPENBSD_6_0:1.69.0.4
	OPENBSD_6_0_BASE:1.69
	OPENBSD_5_9:1.68.0.2
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.48.0.6
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.4
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.2
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.8
	OPENBSD_5_0:1.47.0.6
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.47.0.4
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.43.0.4
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.41.0.2
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.39.0.4
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.33.0.4
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.22.0.4
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.27
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.2
	SMP_BASE:1.2;
locks; strict;
comment	@ * @;


1.86
date	2017.07.05.11.34.10;	author bluhm;	state Exp;
branches;
next	1.85;
commitid	ucK3UpuZ104FN3VS;

1.85
date	2017.06.20.11.12.13;	author bluhm;	state Exp;
branches;
next	1.84;
commitid	hmkIwC7Ma691pjPM;

1.84
date	2017.06.19.17.58.49;	author bluhm;	state Exp;
branches;
next	1.83;
commitid	o1URxEJIRKTXxlGk;

1.83
date	2017.06.11.19.59.57;	author bluhm;	state Exp;
branches;
next	1.82;
commitid	9ordvCOHOW1W22fS;

1.82
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.81;
commitid	p51F2KIwIJB1dU8P;

1.81
date	2017.05.28.13.59.05;	author bluhm;	state Exp;
branches;
next	1.80;
commitid	n6F7pzRQRf00Vp3t;

1.80
date	2017.05.26.16.27.25;	author bluhm;	state Exp;
branches;
next	1.79;
commitid	dvtWSo0gSEEOxOF1;

1.79
date	2017.05.26.15.56.51;	author bluhm;	state Exp;
branches;
next	1.78;
commitid	NvePLHeFbp3RBHlP;

1.78
date	2017.05.18.10.56.45;	author bluhm;	state Exp;
branches;
next	1.77;
commitid	end8oXU4pM3sNkRR;

1.77
date	2017.05.06.15.55.15;	author bluhm;	state Exp;
branches;
next	1.76;
commitid	oZPMTPCNR1fRELhK;

1.76
date	2017.05.04.17.58.46;	author bluhm;	state Exp;
branches;
next	1.75;
commitid	Q1XaPbKgEyYyAOP7;

1.75
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.74;
commitid	Gef6NNDxonzfVaq2;

1.74
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.73;
commitid	00hB28wQPwG5Ysk0;

1.73
date	2017.04.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.72;
commitid	4O5LUh13nIhVt6oZ;

1.72
date	2017.03.10.07.29.25;	author jca;	state Exp;
branches;
next	1.71;
commitid	wuugeUzB7oK5I9QF;

1.71
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.70;
commitid	3e3CkrbYekyVOcxy;

1.70
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.69;
commitid	pVtptbHA3yk4jSpN;

1.69
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.68;
commitid	Z6e4eqr6FuYFPnlL;

1.68
date	2016.01.22.11.14.58;	author jsg;	state Exp;
branches;
next	1.67;
commitid	FeUpYqyFOpdNB9Tr;

1.67
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.66;
commitid	sTEWfQrcV5GjIWc0;

1.66
date	2015.09.09.20.19.26;	author dlg;	state Exp;
branches;
next	1.65;
commitid	3GNbX9P75fNnL0cO;

1.65
date	2015.08.24.22.04.06;	author mpi;	state Exp;
branches;
next	1.64;
commitid	49WO8IzfTZahOvtp;

1.64
date	2015.08.14.18.07.28;	author bluhm;	state Exp;
branches;
next	1.63;
commitid	mu9yDScTa557hRQD;

1.63
date	2015.07.16.16.12.15;	author mpi;	state Exp;
branches;
next	1.62;
commitid	STtcOm1B3VSMXz2h;

1.62
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	ncpqEGjDtSFuLAgn;

1.61
date	2015.07.15.17.33.48;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	ouqXOLuJ594YIl89;

1.60
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.59;
commitid	h7z8lokZ0dFyuWpg;

1.59
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.58;
commitid	hN5bFCE56DrAjl99;

1.58
date	2015.04.14.14.20.01;	author mikeb;	state Exp;
branches;
next	1.57;
commitid	70u0dWUlToMcLCnj;

1.57
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.56;
commitid	c7ei8kPelCOOwHXy;

1.56
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.55;
commitid	zhW8jJrfVCoAthrR;

1.55
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.54;
commitid	t9FBKDfc4VDxpEy2;

1.54
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.53;
commitid	uzzBR7hz9ncd4O6G;

1.53
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.52;
commitid	DQakU8LLWV6Iwx84;

1.52
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.50;

1.50
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2013.10.17.16.27.44;	author bluhm;	state Exp;
branches;
next	1.48;

1.48
date	2012.03.15.16.37.11;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.11.09.36.07;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.28.23.23.54;	author chl;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2008.11.26.16.08.17;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.10.09.57.51;	author todd;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.10.15.34.22;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.13.09.01.59;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.25.15.49.35;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.31.03.52.19;	author pascoe;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.17.12.06.16;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.21.20.44.54;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.31.17.27.03;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.05.23.12.19;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.05.23.11.09;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.10.18.04.55;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.16.14.10.51;	author kjc;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.06.20.14.53;	author angelos;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.08.19.06.31.56;	author angelos;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.07.04.23.14.55;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.26.04.29.05;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.25.05.11.58;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.19.00.48.23;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.08.03.53.46;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.30.12.22.57;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.11.17.20.11;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.14.00.30.59;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.28.20.03.04;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.28.01.24.55;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.19.03.20.58;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.04.00.26.58;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.04.00.26.07;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.03.17.31.20;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.03.08.24.17;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.03.07.55.48;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.20.04.19.11;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.21.03.16.24;	author angelos;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.01.21.03.15.05;	author angelos;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.14.22.40.11;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.07.04.10.54.50;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2001.12.13.18.37.05;	author jason;	state Exp;
branches;
next	;

1.22.2.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.86
log
@The IP in IP input function strips the outer header and reinserts
the inner IP packet into the internet queue.  The IPv6 local delivery
code has a loop to deal with header chains.  The idea is to use
this loop and avoid the queueing and rescheduling.  The IPsec packet
will be processed in a single flow.
Merge the IP deliver loop from both IP versions into a single
ip_deliver() function that can handle both addresss families.  This
allows to process an IP in IP header like a normal extension header.
If af != AF_UNSPEC, we are already in a deliver loop and have the
kernel look.  Then we can just return the next protocol.  Otherwise
we enqueue.  The dequeue thread has the kernel lock and starts an
IP delivery loop.
OK mpi@@
@
text
@/*	$OpenBSD: ip_ipip.c,v 1.85 2017/06/20 11:12:13 bluhm Exp $ */
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * IP-inside-IP processing
 */

#include "bpfilter.h"
#include "gif.h"
#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/if_var.h>
#include <net/route.h>
#include <net/netisr.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/ip_ecn.h>
#include <netinet/ip_ipip.h>

#ifdef MROUTING
#include <netinet/ip_mroute.h>
#endif

#if NPF > 0
#include <net/pfvar.h>
#endif

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

/*
 * We can control the acceptance of IP4 packets by altering the sysctl
 * net.inet.ipip.allow value.  Zero means drop them, all else is acceptance.
 */
int ipip_allow = 0;

struct cpumem *ipipcounters;

void
ipip_init(void)
{
	ipipcounters = counters_alloc(ipips_ncounters);
}

/*
 * Really only a wrapper for ipip_input_if(), for use with pr_input.
 */
int
ipip_input(struct mbuf **mp, int *offp, int nxt, int af)
{
	struct ifnet *ifp;

	/* If we do not accept IP-in-IP explicitly, drop.  */
	if (!ipip_allow && ((*mp)->m_flags & (M_AUTH|M_CONF)) == 0) {
		DPRINTF(("%s: dropped due to policy\n", __func__));
		ipipstat_inc(ipips_pdrops);
		m_freemp(mp);
		return IPPROTO_DONE;
	}

	ifp = if_get((*mp)->m_pkthdr.ph_ifidx);
	if (ifp == NULL) {
		m_freemp(mp);
		return IPPROTO_DONE;
	}
	nxt = ipip_input_if(mp, offp, nxt, af, ifp);
	if_put(ifp);

	return nxt;
}

/*
 * ipip_input gets called when we receive an IP{46} encapsulated packet,
 * either because we got it at a real interface, or because AH or ESP
 * were being used in tunnel mode (in which case the ph_ifidx element
 * will contain the index of the encX interface associated with the
 * tunnel.
 */

int
ipip_input_if(struct mbuf **mp, int *offp, int proto, int oaf,
    struct ifnet *ifp)
{
	struct mbuf *m = *mp;
	struct sockaddr_in *sin;
	struct ip *ip;
#ifdef INET6
	struct sockaddr_in6 *sin6;
	struct ip6_hdr *ip6;
#endif
	int mode, hlen;
	u_int8_t itos, otos;
	sa_family_t iaf;

	ipipstat_inc(ipips_ipackets);

	switch (oaf) {
	case AF_INET:
		hlen = sizeof(struct ip);
		break;
#ifdef INET6
	case AF_INET6:
		hlen = sizeof(struct ip6_hdr);
		break;
#endif
	default:
		unhandled_af(oaf);
	}

	/* Bring the IP header in the first mbuf, if not there already */
	if (m->m_len < hlen) {
		if ((m = *mp = m_pullup(m, hlen)) == NULL) {
			DPRINTF(("%s: m_pullup() failed\n", __func__));
			ipipstat_inc(ipips_hdrops);
			goto bad;
		}
	}

	/* Keep outer ecn field. */
	switch (oaf) {
	case AF_INET:
		ip = mtod(m, struct ip *);
		otos = ip->ip_tos;
		break;
#ifdef INET6
	case AF_INET6:
		ip6 = mtod(m, struct ip6_hdr *);
		otos = (ntohl(ip6->ip6_flow) >> 20) & 0xff;
		break;
#endif
	}

	/* Remove outer IP header */
	KASSERT(*offp > 0);
	m_adj(m, *offp);
	*offp = 0;
	ip = NULL;
#ifdef INET6
	ip6 = NULL;
#endif

	switch (proto) {
	case IPPROTO_IPV4:
		hlen = sizeof(struct ip);
		break;

#ifdef INET6
	case IPPROTO_IPV6:
		hlen = sizeof(struct ip6_hdr);
		break;
#endif
	default:
		ipipstat_inc(ipips_family);
		goto bad;
	}

	/* Sanity check */
	if (m->m_pkthdr.len < hlen) {
		ipipstat_inc(ipips_hdrops);
		goto bad;
	}

	/*
	 * Bring the inner header into the first mbuf, if not there already.
	 */
	if (m->m_len < hlen) {
		if ((m = *mp = m_pullup(m, hlen)) == NULL) {
			DPRINTF(("%s: m_pullup() failed\n", __func__));
			ipipstat_inc(ipips_hdrops);
			goto bad;
		}
	}

	/*
	 * RFC 1853 specifies that the inner TTL should not be touched on
	 * decapsulation. There's no reason this comment should be here, but
	 * this is as good as any a position.
	 */

	/* Some sanity checks in the inner IP header */
	switch (proto) {
    	case IPPROTO_IPV4:
		iaf = AF_INET;
		ip = mtod(m, struct ip *);
		hlen = ip->ip_hl << 2;
		if (m->m_pkthdr.len < hlen) {
			ipipstat_inc(ipips_hdrops);
			goto bad;
		}
		itos = ip->ip_tos;
		mode = m->m_flags & (M_AUTH|M_CONF) ?
		    ECN_ALLOWED_IPSEC : ECN_ALLOWED;
		if (!ip_ecn_egress(mode, &otos, &ip->ip_tos)) {
			DPRINTF(("%s: ip_ecn_egress() failed\n", __func__));
			ipipstat_inc(ipips_pdrops);
			goto bad;
		}
		/* re-calculate the checksum if ip_tos was changed */
		if (itos != ip->ip_tos) {
			ip->ip_sum = 0;
			ip->ip_sum = in_cksum(m, hlen);
		}
		break;
#ifdef INET6
    	case IPPROTO_IPV6:
		iaf = AF_INET6;
		ip6 = mtod(m, struct ip6_hdr *);
		itos = (ntohl(ip6->ip6_flow) >> 20) & 0xff;
		if (!ip_ecn_egress(ECN_ALLOWED, &otos, &itos)) {
			DPRINTF(("%s: ip_ecn_egress() failed\n", __func__));
			ipipstat_inc(ipips_pdrops);
			goto bad;
		}
		ip6->ip6_flow &= ~htonl(0xff << 20);
		ip6->ip6_flow |= htonl((u_int32_t) itos << 20);
		break;
#endif
	}

	/* Check for local address spoofing. */
	if (!(ifp->if_flags & IFF_LOOPBACK) && ipip_allow != 2) {
		struct sockaddr_storage ss;
		struct rtentry *rt;

		memset(&ss, 0, sizeof(ss));

		if (ip) {
			sin = (struct sockaddr_in *)&ss;
			sin->sin_family = AF_INET;
			sin->sin_len = sizeof(*sin);
			sin->sin_addr = ip->ip_src;
#ifdef INET6
		} else if (ip6) {
			sin6 = (struct sockaddr_in6 *)&ss;
			sin6->sin6_family = AF_INET6;
			sin6->sin6_len = sizeof(*sin6);
			sin6->sin6_addr = ip6->ip6_src;
#endif /* INET6 */
		}
		rt = rtalloc(sstosa(&ss), 0, m->m_pkthdr.ph_rtableid);
		if ((rt != NULL) && (rt->rt_flags & RTF_LOCAL)) {
			ipipstat_inc(ipips_spoof);
			rtfree(rt);
			goto bad;
 		}
		rtfree(rt);
	}

	/* Statistics */
	ipipstat_add(ipips_ibytes, m->m_pkthdr.len - hlen);

#if NBPFILTER > 0 && NGIF > 0
	if (ifp->if_type == IFT_GIF && ifp->if_bpf != NULL)
		bpf_mtap_af(ifp->if_bpf, iaf, m, BPF_DIRECTION_IN);
#endif
#if NPF > 0
	pf_pkt_addr_changed(m);
#endif

	/*
	 * Interface pointer stays the same; if no IPsec processing has
	 * been done (or will be done), this will point to a normal
	 * interface. Otherwise, it'll point to an enc interface, which
	 * will allow a packet filter to distinguish between secure and
	 * untrusted packets.
	 */

	switch (proto) {
	case IPPROTO_IPV4:
		return ip_input_if(mp, offp, proto, oaf, ifp);
#ifdef INET6
	case IPPROTO_IPV6:
		return ip6_input_if(mp, offp, proto, oaf, ifp);
#endif
	}
 bad:
	m_freemp(mp);
	return IPPROTO_DONE;
}

int
ipip_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int dummy,
    int dummy2)
{
	u_int8_t tp, otos;

	u_int8_t itos;
	struct ip *ipo;

#ifdef INET6
	struct ip6_hdr *ip6, *ip6o;
#endif /* INET6 */
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	/* XXX Deal with empty TDB source/destination addresses. */

	m_copydata(m, 0, 1, &tp);
	tp = (tp >> 4) & 0xff;  /* Get the IP version number. */

	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		if (tdb->tdb_src.sa.sa_family != AF_INET ||
		    tdb->tdb_src.sin.sin_addr.s_addr == INADDR_ANY ||
		    tdb->tdb_dst.sin.sin_addr.s_addr == INADDR_ANY) {

			DPRINTF(("%s: unspecified tunnel endpoind "
			    "address in SA %s/%08x\n", __func__,
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));

			ipipstat_inc(ipips_unspec);
			m_freem(m);
			*mp = NULL;
			return EINVAL;
		}

		M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
		if (m == NULL) {
			DPRINTF(("%s: M_PREPEND failed\n", __func__));
			ipipstat_inc(ipips_hdrops);
			*mp = NULL;
			return ENOBUFS;
		}

		ipo = mtod(m, struct ip *);

		ipo->ip_v = IPVERSION;
		ipo->ip_hl = 5;
		ipo->ip_len = htons(m->m_pkthdr.len);
		ipo->ip_ttl = ip_defttl;
		ipo->ip_sum = 0;
		ipo->ip_src = tdb->tdb_src.sin.sin_addr;
		ipo->ip_dst = tdb->tdb_dst.sin.sin_addr;

		/*
		 * We do the htons() to prevent snoopers from determining our
		 * endianness.
		 */
		ipo->ip_id = htons(ip_randomid());

		/* If the inner protocol is IP... */
		if (tp == IPVERSION) {
			/* Save ECN notification */
			m_copydata(m, sizeof(struct ip) +
			    offsetof(struct ip, ip_tos),
			    sizeof(u_int8_t), (caddr_t) &itos);

			ipo->ip_p = IPPROTO_IPIP;

			/*
			 * We should be keeping tunnel soft-state and
			 * send back ICMPs if needed.
			 */
			m_copydata(m, sizeof(struct ip) +
			    offsetof(struct ip, ip_off),
			    sizeof(u_int16_t), (caddr_t) &ipo->ip_off);
			ipo->ip_off = ntohs(ipo->ip_off);
			ipo->ip_off &= ~(IP_DF | IP_MF | IP_OFFMASK);
			ipo->ip_off = htons(ipo->ip_off);
		}
#ifdef INET6
		else if (tp == (IPV6_VERSION >> 4)) {
			u_int32_t itos32;

			/* Save ECN notification. */
			m_copydata(m, sizeof(struct ip) +
			    offsetof(struct ip6_hdr, ip6_flow),
			    sizeof(u_int32_t), (caddr_t) &itos32);
			itos = ntohl(itos32) >> 20;
			ipo->ip_p = IPPROTO_IPV6;
			ipo->ip_off = 0;
		}
#endif /* INET6 */
		else {
			m_freem(m);
			*mp = NULL;
			ipipstat_inc(ipips_family);
			return EAFNOSUPPORT;
		}

		otos = 0;
		ip_ecn_ingress(ECN_ALLOWED, &otos, &itos);
		ipo->ip_tos = otos;
		break;

#ifdef INET6
	case AF_INET6:
		if (IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr) ||
		    tdb->tdb_src.sa.sa_family != AF_INET6 ||
		    IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_src.sin6.sin6_addr)) {

			DPRINTF(("%s: unspecified tunnel endpoind "
			    "address in SA %s/%08x\n", __func__,
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));

			ipipstat_inc(ipips_unspec);
			m_freem(m);
			*mp = NULL;
			return ENOBUFS;
		}

		/* If the inner protocol is IPv6, clear link local scope */
		if (tp == (IPV6_VERSION >> 4)) {
			/* scoped address handling */
			ip6 = mtod(m, struct ip6_hdr *);
			if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
				ip6->ip6_src.s6_addr16[1] = 0;
			if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
				ip6->ip6_dst.s6_addr16[1] = 0;
		}

		M_PREPEND(m, sizeof(struct ip6_hdr), M_DONTWAIT);
		if (m == NULL) {
			DPRINTF(("%s: M_PREPEND failed\n", __func__));
			ipipstat_inc(ipips_hdrops);
			*mp = NULL;
			return ENOBUFS;
		}

		/* Initialize IPv6 header */
		ip6o = mtod(m, struct ip6_hdr *);
		ip6o->ip6_flow = 0;
		ip6o->ip6_vfc &= ~IPV6_VERSION_MASK;
		ip6o->ip6_vfc |= IPV6_VERSION;
		ip6o->ip6_plen = htons(m->m_pkthdr.len - sizeof(*ip6o));
		ip6o->ip6_hlim = ip_defttl;
		in6_embedscope(&ip6o->ip6_src, &tdb->tdb_src.sin6, NULL);
		in6_embedscope(&ip6o->ip6_dst, &tdb->tdb_dst.sin6, NULL);

		if (tp == IPVERSION) {
			/* Save ECN notification */
			m_copydata(m, sizeof(struct ip6_hdr) +
			    offsetof(struct ip, ip_tos), sizeof(u_int8_t),
			    (caddr_t) &itos);

			/* This is really IPVERSION. */
			ip6o->ip6_nxt = IPPROTO_IPIP;
		}
		else
			if (tp == (IPV6_VERSION >> 4)) {
				u_int32_t itos32;

				/* Save ECN notification. */
				m_copydata(m, sizeof(struct ip6_hdr) +
				    offsetof(struct ip6_hdr, ip6_flow),
				    sizeof(u_int32_t), (caddr_t) &itos32);
				itos = ntohl(itos32) >> 20;

				ip6o->ip6_nxt = IPPROTO_IPV6;
			} else {
				m_freem(m);
				*mp = NULL;
				ipipstat_inc(ipips_family);
				return EAFNOSUPPORT;
			}

		otos = 0;
		ip_ecn_ingress(ECN_ALLOWED, &otos, &itos);
		ip6o->ip6_flow |= htonl((u_int32_t) otos << 20);
		break;
#endif /* INET6 */

	default:
		DPRINTF(("%s: unsupported protocol family %d\n", __func__,
		    tdb->tdb_dst.sa.sa_family));
		m_freem(m);
		*mp = NULL;
		ipipstat_inc(ipips_family);
		return EAFNOSUPPORT;
	}

	ipipstat_inc(ipips_opackets);
	*mp = m;

	if (tdb->tdb_dst.sa.sa_family == AF_INET) {
		if (tdb->tdb_xform->xf_type == XF_IP4)
			tdb->tdb_cur_bytes +=
			    m->m_pkthdr.len - sizeof(struct ip);

		ipipstat_add(ipips_obytes, m->m_pkthdr.len - sizeof(struct ip));
	}

#ifdef INET6
	if (tdb->tdb_dst.sa.sa_family == AF_INET6) {
		if (tdb->tdb_xform->xf_type == XF_IP4)
			tdb->tdb_cur_bytes +=
			    m->m_pkthdr.len - sizeof(struct ip6_hdr);

		ipipstat_add(ipips_obytes,
		    m->m_pkthdr.len - sizeof(struct ip6_hdr));
	}
#endif /* INET6 */

	return 0;
}

#ifdef IPSEC
int
ipe4_attach(void)
{
	return 0;
}

int
ipe4_init(struct tdb *tdbp, struct xformsw *xsp, struct ipsecinit *ii)
{
	tdbp->tdb_xform = xsp;
	return 0;
}

int
ipe4_zeroize(struct tdb *tdbp)
{
	return 0;
}

int
ipe4_input(struct mbuf *m, struct tdb *tdb, int hlen, int proto)
{
	/* This is a rather serious mistake, so no conditional printing. */
	printf("ipe4_input(): should never be called\n");
	m_freem(m);
	return EINVAL;
}
#endif	/* IPSEC */

int
ipip_sysctl_ipipstat(void *oldp, size_t *oldlenp, void *newp)
{
	struct ipipstat ipipstat;

	CTASSERT(sizeof(ipipstat) == (ipips_ncounters * sizeof(uint64_t)));
	memset(&ipipstat, 0, sizeof ipipstat);
	counters_read(ipipcounters, (uint64_t *)&ipipstat, ipips_ncounters);
	return (sysctl_rdstruct(oldp, oldlenp, newp,
	    &ipipstat, sizeof(ipipstat)));
}

int
ipip_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case IPIPCTL_ALLOW:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ipip_allow));
	case IPIPCTL_STATS:
		return (ipip_sysctl_ipipstat(oldp, oldlenp, newp));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


1.85
log
@Do not use the interface pointer after if_put().  Rename ipip_input_gif()
to ipip_input_if() and always pass the ifp.  Only dump the packet
to bpf if we are called with a gif(4) interface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.84 2017/06/19 17:58:49 bluhm Exp $ */
d319 1
a319 3
		ipv4_input(ifp, m);
		*mp = NULL;
		return IPPROTO_DONE;
d322 1
a322 3
		ipv6_input(ifp, m);
		*mp = NULL;
		return IPPROTO_DONE;
@


1.84
log
@When dealing with mbuf pointers passed down as function parameters,
bugs could easily result in use-after-free or double free.  Introduce
m_freemp() which automatically resets the pointer before freeing
it.  So we have less dangling pointers in the kernel.
OK krw@@ mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.83 2017/06/11 19:59:57 bluhm Exp $ */
d42 2
d53 1
a69 2
#include "bpfilter.h"

d95 1
a95 1
 * Really only a wrapper for ipip_input_gif(), for use with pr_input.
d98 1
a98 1
ipip_input(struct mbuf **mp, int *offp, int proto, int af)
d100 2
d110 9
a118 1
	return ipip_input_gif(mp, offp, proto, af, NULL);
d130 2
a131 2
ipip_input_gif(struct mbuf **mp, int *offp, int proto, int oaf,
    struct ifnet *gifp)
a134 1
	struct ifnet *ifp;
d237 1
a237 2
			m_freem(m);
			return IPPROTO_DONE;
d270 1
a270 3
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (((ifp == NULL) || !(ifp->if_flags & IFF_LOOPBACK)) &&
	    ipip_allow != 2) {
a273 2
		if_put(ifp);

a295 2
 	} else {
		if_put(ifp);
d301 3
a303 3
#if NBPFILTER > 0
	if (gifp && gifp->if_bpf)
		bpf_mtap_af(gifp->if_bpf, iaf, m, BPF_DIRECTION_IN);
@


1.83
log
@Use a common 'goto bad' style and set mp to NULL after freeing it
in ipip_input_gif().  This prevents a use-after-free if there is a
bug in the IP input functions.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.82 2017/05/30 07:50:37 mpi Exp $ */
d103 1
a103 1
		m_freem(*mp);
d327 1
a327 2
	m_freem(*mp);
	*mp = NULL;
@


1.82
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.81 2017/05/28 13:59:05 bluhm Exp $ */
d154 1
a154 1
			return IPPROTO_DONE;
d193 1
a193 2
		m_freem(m);
		return IPPROTO_DONE;
d199 1
a199 2
		m_freem(m);
		return IPPROTO_DONE;
d209 1
a209 1
			return IPPROTO_DONE;
d236 1
a236 2
			m_freem(m);
			return IPPROTO_DONE;
d252 1
a252 2
			m_freem(m);
			return IPPROTO_DONE;
a286 1
			m_freem(m);
d288 1
a288 1
			return IPPROTO_DONE;
d317 2
a318 1
		break;
d322 2
a323 1
		break;
a324 2
	default:
		panic("%s: should never reach here", __func__);
d326 3
a328 1

@


1.81
log
@Call bpf_mtap_af() a bit earlier in ipip_input().  This prepares
upcoming diffs, no functional change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.80 2017/05/26 16:27:25 bluhm Exp $ */
a124 1
	struct niqueue *ifq = NULL;
d321 1
a321 1
		ifq = &ipintrq;
d325 1
a325 1
		ifq = &ip6intrq;
a331 5
	if (niq_enqueue(ifq, m) != 0) {
		ipipstat_inc(ipips_qfull);
		DPRINTF(("%s: packet dropped because of full queue\n",
		    __func__));
	}
@


1.80
log
@In IPIP input rename the variable ipo to ip as it is used for inner
and outer header.  Reset values depending on the the mbuf when the
mbuf is adjusted.  Check the length of the inner IP header with the
correct size in case of IPv6.  Check the IPv4 header size including
IP options.  For the IPIP statistics the inner header length has
to be subtracted from the packet size as the outer header has already
been stripped off.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.79 2017/05/26 15:56:51 bluhm Exp $ */
d225 1
d250 1
d304 8
a322 1
		iaf = AF_INET;
a326 1
		iaf = AF_INET6;
a331 8

#if NBPFILTER > 0
	if (gifp && gifp->if_bpf)
		bpf_mtap_af(gifp->if_bpf, iaf, m, BPF_DIRECTION_IN);
#endif
#if NPF > 0
	pf_pkt_addr_changed(m);
#endif
@


1.79
log
@Instead of looking at the IP version of the header, use the outer
address family passed to ipip_input().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.78 2017/05/18 10:56:45 bluhm Exp $ */
a122 1
	int iphlen = *offp;
d126 1
a126 1
	struct ip *ipo;
d162 2
a163 2
		ipo = mtod(m, struct ip *);
		otos = ipo->ip_tos;
d174 7
a180 8
	m_adj(m, iphlen);

	/* Sanity check */
	if (m->m_pkthdr.len < sizeof(struct ip)) {
		ipipstat_inc(ipips_hdrops);
		m_freem(m);
		return IPPROTO_DONE;
	}
d198 7
d225 8
a232 5
		ipo = mtod(m, struct ip *);
#ifdef INET6
		ip6 = NULL;
#endif
		itos = ipo->ip_tos;
d235 1
a235 1
		if (!ip_ecn_egress(mode, &otos, &ipo->ip_tos)) {
d242 3
a244 6
		if (itos != ipo->ip_tos) {
			hlen = ipo->ip_hl << 2;
			if (m->m_pkthdr.len >= hlen) {
				ipo->ip_sum = 0;
				ipo->ip_sum = in_cksum(m, hlen);
			}
a248 1
		ipo = NULL;
a260 5
	default:
		ipo = NULL;
#ifdef INET6
		ip6 = NULL;
#endif
d274 1
a274 1
		if (ipo) {
d278 1
a278 1
			sin->sin_addr = ipo->ip_src;
d300 1
a300 1
	ipipstat_add(ipips_ibytes, m->m_pkthdr.len - iphlen);
@


1.78
log
@The function name ip4_input() is confusing as it also handles IPv6
packets.  This is the IP in IP protocol input function, so call it
ipip_input().  Rename the existing ipip_input() to ipip_input_gif()
as it is the input function used by the gif interface.  Pass the
address family to make it consistent with pr_input.  Use __func__
in debug print and panic messages.  Move all ipip prototypes to the
ip_ipip.h header file.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.77 2017/05/06 15:55:15 bluhm Exp $ */
a133 1
	u_int8_t v;
d138 2
a139 4
	m_copydata(m, 0, 1, &v);

	switch (v >> 4) {
	case 4:
d143 1
a143 1
	case 6:
d148 1
a148 3
		ipipstat_inc(ipips_family);
		m_freem(m);
		return IPPROTO_DONE;
a159 1

d161 2
a162 2
	switch (v >> 4) {
	case 4:
d167 1
a167 1
	case 6:
a171 2
	default:
		panic("%s: should never reach here", __func__);
@


1.77
log
@Convert the xformsw definition to C99 style initializer.  Also fix
the function declaration of ipe4_input() and avoid a wrong cast.
OK mikeb@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.76 2017/05/04 17:58:46 bluhm Exp $ */
d61 1
a66 3
#include <netinet/ip_ipsp.h>
#include <netinet/ip_ipip.h>

d94 1
a94 1
 * Really only a wrapper for ipip_input(), for use with pr_input.
d97 1
a97 1
ip4_input(struct mbuf **mp, int *offp, int proto, int af)
d101 1
a101 1
		DPRINTF(("ip4_input(): dropped due to policy\n"));
d107 1
a107 1
	return ipip_input(mp, offp, NULL, proto);
d119 2
a120 1
ipip_input(struct mbuf **mp, int *offp, struct ifnet *gifp, int proto)
d135 1
a135 1
	sa_family_t af;
d159 1
a159 1
			DPRINTF(("ipip_input(): m_pullup() failed\n"));
d179 1
a179 1
		panic("ipip_input: should never reach here");
d213 1
a213 1
			DPRINTF(("ipip_input(): m_pullup() failed\n"));
d236 1
a236 1
			DPRINTF(("ipip_input(): ip_ecn_egress() failed"));
d256 1
a256 1
			DPRINTF(("ipip_input(): ip_ecn_egress() failed"));
d322 1
a322 1
		af = AF_INET;
d327 1
a327 1
		af = AF_INET6;
d331 1
a331 1
		panic("ipip_input: should never reach here");
d336 1
a336 1
		bpf_mtap_af(gifp->if_bpf, af, m, BPF_DIRECTION_IN);
d344 2
a345 2
		DPRINTF(("ipip_input(): packet dropped because of full "
		    "queue\n"));
d377 2
a378 2
			DPRINTF(("ipip_output(): unspecified tunnel endpoind "
			    "address in SA %s/%08x\n",
d390 1
a390 1
			DPRINTF(("ipip_output(): M_PREPEND failed\n"));
d463 2
a464 2
			DPRINTF(("ipip_output(): unspecified tunnel endpoind "
			    "address in SA %s/%08x\n",
d486 1
a486 1
			DPRINTF(("ipip_output(): M_PREPEND failed\n"));
d536 1
a536 1
		DPRINTF(("ipip_output(): unsupported protocol family %d\n",
@


1.76
log
@If m is not a continuous mbuf cluster, m_pullup() in pr_input may
change the pointer.  Then *mp keeps the invalid pointer and it might
be used.  Fix the potential use after free and also reset *mp in
other places to have less dangling pointers to freed mbufs.
OK mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.75 2017/05/04 15:00:24 bluhm Exp $ */
d590 2
a591 2
void
ipe4_input(struct mbuf *m, int hlen, int proto)
d596 1
@


1.75
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.74 2017/04/14 20:46:31 bluhm Exp $ */
d159 1
a159 1
		if ((m = m_pullup(m, hlen)) == NULL) {
d213 1
a213 1
		if ((m = m_pullup(m, hlen)) == NULL) {
@


1.74
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.73 2017/04/05 13:35:18 deraadt Exp $ */
d297 1
a297 2
		rt = rtalloc((struct sockaddr *)&ss, 0,
		    m->m_pkthdr.ph_rtableid);
@


1.73
log
@When building counter memory in preparation to copy to userland, always
zero the buffers first.  All the current objects appear to be safe,
however future changes might introduce structure pads.
Discussed with guenther, ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.72 2017/03/10 07:29:25 jca Exp $ */
d99 1
a99 1
ip4_input(struct mbuf **mp, int *offp, int proto)
@


1.72
log
@percpu counters for ip_ipip.c

ok bluhm@@ dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.71 2017/01/29 19:58:47 bluhm Exp $ */
d606 1
@


1.71
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.70 2017/01/25 17:34:31 bluhm Exp $ */
d87 7
a93 1
struct ipipstat ipipstat;
d104 1
a104 1
		ipipstat.ipips_pdrops++;
d138 1
a138 1
	ipipstat.ipips_ipackets++;
d152 1
a152 1
		ipipstat.ipips_family++;
d161 1
a161 1
			ipipstat.ipips_hdrops++;
d188 1
a188 1
		ipipstat.ipips_hdrops++;
d204 1
a204 1
		ipipstat.ipips_family++;
d215 1
a215 1
			ipipstat.ipips_hdrops++;
d238 1
a238 1
			ipipstat.ipips_pdrops++;
d258 1
a258 1
			ipipstat.ipips_pdrops++;
d300 1
a300 1
			ipipstat.ipips_spoof++;
d311 1
a311 1
	ipipstat.ipips_ibytes += m->m_pkthdr.len - iphlen;
d345 1
a345 1
		ipipstat.ipips_qfull++;
d384 1
a384 1
			ipipstat.ipips_unspec++;
d393 1
a393 1
			ipipstat.ipips_hdrops++;
d450 1
a450 1
			ipipstat.ipips_family++;
d470 1
a470 1
			ipipstat.ipips_unspec++;
d489 1
a489 1
			ipipstat.ipips_hdrops++;
d527 1
a527 1
				ipipstat.ipips_family++;
d542 1
a542 1
		ipipstat.ipips_family++;
d546 1
a546 1
	ipipstat.ipips_opackets++;
d554 1
a554 1
		ipipstat.ipips_obytes += m->m_pkthdr.len - sizeof(struct ip);
d563 2
a564 2
		ipipstat.ipips_obytes +=
		    m->m_pkthdr.len - sizeof(struct ip6_hdr);
d601 11
d623 1
a623 4
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &ipipstat, sizeof(ipipstat)));
@


1.70
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.69 2016/03/07 18:44:00 naddy Exp $ */
a88 1
#ifdef INET6
d90 1
a90 1
 * Really only a wrapper for ipip_input(), for use with IPv6.
d93 1
a93 1
ip4_input6(struct mbuf **mp, int *offp, int proto)
d97 1
a97 1
		DPRINTF(("ip4_input6(): dropped due to policy\n"));
d103 1
a103 24
	ipip_input(*mp, *offp, NULL, proto);
	return IPPROTO_DONE;
}
#endif /* INET6 */

/*
 * Really only a wrapper for ipip_input(), for use with IPv4.
 */
void
ip4_input(struct mbuf *m, int iphlen, int proto)
{
	struct ip *ip;

	/* If we do not accept IP-in-IP explicitly, drop.  */
	if (!ipip_allow && (m->m_flags & (M_AUTH|M_CONF)) == 0) {
		DPRINTF(("ip4_input(): dropped due to policy\n"));
		ipipstat.ipips_pdrops++;
		m_freem(m);
		return;
	}

	ip = mtod(m, struct ip *);

	ipip_input(m, iphlen, NULL, ip->ip_p);
d114 2
a115 2
void
ipip_input(struct mbuf *m, int iphlen, struct ifnet *gifp, int proto)
d117 2
d148 1
a148 1
		return /* EAFNOSUPPORT */;
d156 1
a156 1
			return;
d184 1
a184 1
		return;
d200 1
a200 1
		return; /* EAFNOSUPPORT */
d210 1
a210 1
			return;
d234 1
a234 1
			return;
d254 1
a254 1
			return;
d297 1
a297 1
			return;
a341 1
		return;
d343 1
@


1.69
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.68 2016/01/22 11:14:58 jsg Exp $ */
d113 1
a113 1
ip4_input(struct mbuf *m, ...)
a115 2
	va_list ap;
	int iphlen;
a124 4
	va_start(ap, m);
	iphlen = va_arg(ap, int);
	va_end(ap);

d608 1
a608 1
ipe4_input(struct mbuf *m, ...)
@


1.68
log
@add a missing if_put() to ipip_input()
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.67 2015/09/11 07:42:35 claudio Exp $ */
d595 1
a595 1
ipe4_attach()
@


1.67
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.66 2015/09/09 20:19:26 dlg Exp $ */
d296 3
a298 2
	if (((ifp = if_get(m->m_pkthdr.ph_ifidx)) == NULL ||
	    !(ifp->if_flags & IFF_LOOPBACK)) && ipip_allow != 2) {
d328 3
a330 1
 	}
@


1.66
log
@if_put after if_get

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.65 2015/08/24 22:04:06 mpi Exp $ */
d520 2
a521 2
		in6_embedscope(&ip6o->ip6_src, &tdb->tdb_src.sin6, NULL, NULL);
		in6_embedscope(&ip6o->ip6_dst, &tdb->tdb_dst.sin6, NULL, NULL);
@


1.65
log
@Check for a RTF_LOCAL entry instead of iterating on the global list
of interfaces.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.64 2015/08/14 18:07:28 bluhm Exp $ */
d300 2
@


1.64
log
@Replace sockaddr casts with the proper satosin() or satosin6() calls.
From David Hill;  OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.63 2015/07/16 16:12:15 mpi Exp $ */
a148 1
	struct ifaddr *ifa;
a150 1
	u_int rdomain;
d298 10
a307 18
		rdomain = rtable_l2(m->m_pkthdr.ph_rtableid);
		TAILQ_FOREACH(ifp, &ifnet, if_list) {
			if (ifp->if_rdomain != rdomain)
				continue;
			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
				if (ipo) {
					if (ifa->ifa_addr->sa_family !=
					    AF_INET)
						continue;

					sin = satosin(ifa->ifa_addr); 
					if (sin->sin_addr.s_addr ==
					    ipo->ip_src.s_addr)	{
						ipipstat.ipips_spoof++;
						m_freem(m);
						return;
					}
				}
d309 5
a313 14
				if (ip6) {
					if (ifa->ifa_addr->sa_family !=
					    AF_INET6)
						continue;

					sin6 = satosin6(ifa->ifa_addr);
					if (IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr,
					    &ip6->ip6_src)) {
						ipipstat.ipips_spoof++;
						m_freem(m);
						return;
					}

				}
a314 1
			}
d316 10
a325 1
	}
@


1.63
log
@Expand ancient NTOHL/NTOHS/HTONS/HTONL macros.

ok guenther@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.62 2015/07/15 22:16:42 deraadt Exp $ */
d310 1
a310 2
					sin = (struct sockaddr_in *)
					    ifa->ifa_addr;
d324 1
a324 2
					sin6 = (struct sockaddr_in6 *)
					    ifa->ifa_addr;
@


1.62
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.61 2015/07/15 17:33:48 deraadt Exp $ */
d460 1
a460 1
			NTOHS(ipo->ip_off);
d462 1
a462 1
			HTONS(ipo->ip_off);
@


1.61
log
@rename mbuf ** parameter from m to mp, to match other similar code
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.60 2015/06/16 11:09:40 mpi Exp $ */
d626 1
a626 2
	if (m)
		m_freem(m);
@


1.60
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.59 2015/05/13 10:42:46 jsg Exp $ */
d94 1
a94 1
ip4_input6(struct mbuf **m, int *offp, int proto)
d97 1
a97 1
	if (!ipip_allow && ((*m)->m_flags & (M_AUTH|M_CONF)) == 0) {
d100 1
a100 1
		m_freem(*m);
d104 1
a104 1
	ipip_input(*m, *offp, NULL, proto);
@


1.59
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.58 2015/04/14 14:20:01 mikeb Exp $ */
d139 3
a141 2
 * were being used in tunnel mode (in which case the rcvif element will
 * contain the address of the encX interface associated with the tunnel.
d298 2
a299 3
	if ((m->m_pkthdr.rcvif == NULL ||
	    !(m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK)) &&
	    ipip_allow != 2) {
@


1.58
log
@make ipsp_address thread safe;  ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.57 2015/04/10 13:58:20 dlg Exp $ */
d421 1
a421 1
		if (m == 0) {
d517 1
a517 1
		if (m == 0) {
@


1.57
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.56 2014/12/19 17:14:40 tedu Exp $ */
d394 3
d411 2
a412 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d497 2
a498 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
@


1.56
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.55 2014/12/05 15:50:04 mpi Exp $ */
d149 1
a149 1
	struct ifqueue *ifq = NULL;
d156 1
a156 2
	int isr;
	int mode, hlen, s;
a353 1
		isr = NETISR_IP;
a358 1
		isr = NETISR_IPV6;
d374 1
a374 4
	s = splnet();			/* isn't it already? */
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
a375 3

		splx(s);

a379 5

	IF_ENQUEUE(ifq, m);
	schednetisr(isr);
	splx(s);
	return;
@


1.55
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.54 2014/09/14 14:17:26 jsg Exp $ */
a108 1
#ifdef INET
a134 1
#endif /* INET */
a166 1
#ifdef INET
a169 1
#endif /* INET */
a192 1
#ifdef INET
a196 1
#endif /* INET */
a217 1
#ifdef INET
a220 1
#endif /* INET */
a251 1
#ifdef INET
a274 1
#endif /* INET */
a276 1
#ifdef INET
a277 1
#endif
a290 1
#ifdef INET
a291 1
#endif
a305 1
#ifdef INET
a319 1
#endif /* INET */
a352 1
#ifdef INET
a357 1
#endif
a401 1
#ifdef INET
a403 1
#endif /* INET */
a414 1
#ifdef INET
a497 1
#endif /* INET */
a542 1
#ifdef INET
a552 1
#endif /* INET */
a587 1
#ifdef INET
a594 1
#endif /* INET */
@


1.54
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.53 2014/07/22 11:06:10 mpi Exp $ */
d51 1
@


1.53
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.52 2014/04/14 09:06:42 mpi Exp $ */
a47 1
#include <sys/proc.h>
@


1.52
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.51 2013/10/24 11:31:43 mpi Exp $ */
a56 1
#include <netinet/in_systm.h>
@


1.51
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.50 2013/10/23 15:12:42 mpi Exp $ */
d316 1
a316 1
		rdomain = rtable_l2(m->m_pkthdr.rdomain);
@


1.50
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.49 2013/10/17 16:27:44 bluhm Exp $ */
a68 4

#ifdef INET6
#include <netinet6/in6_var.h>
#endif
@


1.49
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.48 2012/03/15 16:37:11 markus Exp $ */
a59 1
#include <netinet/in_var.h>
@


1.48
log
@improve IPsec/ENC interaction:
- ipip_input() recalculate the IP header checksum if the tos bits
  are changed after decapsulation. Otherwise these packets are
  dropped later in the stack.
- ip_ecn_egress(): do not drop packets for IPsec if the outter
  packet of a Tunnel has the ECN-CE bit set (Congestion Experienced)
  and the inner packet does not indicate support ECN.
- remove unused ip6_ecn_ingress(), ip6_ecn_egress() code
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.47 2010/05/11 09:36:07 claudio Exp $ */
d70 4
@


1.47
log
@Massiv cleanup of the gif(4) mess. Move encapsulation into gif_output()
where it is not necessary to guess protocols by looking at the first nibble.
in_gif_output() will encapsulate the packet but not send it. Because of
etherip support and the way the bridge works a minimal hack is needed in
gif_start() to ensure that the bridged packets are encapsulated as well.
This actually started with the idea to add MPLS support but that turned out
to be not as simple as in the gre(4) case.
Tested by myself (IP, IPv6, etherip, MPLS), sthen@@ (IP, IPv6), naddy (IPv6)
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.46 2010/04/20 22:05:43 tedu Exp $ */
a158 1
	u_int8_t itos;
d161 2
a162 2
	int hlen, s;
	u_int8_t otos;
d268 6
a273 1
		if (!ip_ecn_egress(ECN_ALLOWED, &otos, &ipo->ip_tos)) {
d277 8
d295 2
@


1.46
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.45 2010/01/28 23:23:54 chl Exp $ */
d106 1
a106 1
	ipip_input(*m, *offp, NULL);
d118 1
d134 3
a136 1
	ipip_input(m, iphlen, NULL);
d148 1
a148 1
ipip_input(struct mbuf *m, int iphlen, struct ifnet *gifp)
d158 1
a158 1
	struct ip6_hdr *ip6 = NULL;
d162 1
d165 1
a165 1
	int hlen, s;
d173 1
a173 1
        case 4:
d178 1
a178 1
        case 6:
d182 1
a182 1
        default:
a196 1
	ipo = mtod(m, struct ip *);
d202 1
d208 2
a209 1
		otos = (ntohl(mtod(m, struct ip6_hdr *)->ip6_flow) >> 20) & 0xff;
d226 1
a226 3
	m_copydata(m, 0, 1, &v);

	switch (v >> 4) {
d228 1
a228 1
        case 4:
d234 1
a234 1
        case 6:
d245 1
a245 1
	 * Bring the inner IP header in the first mbuf, if not there already.
d262 1
a262 1
	switch (v >> 4) {
d264 5
a268 2
    	case 4:
                ipo = mtod(m, struct ip *);
d273 1
a273 1
                break;
d276 5
a280 2
    	case 6:
                ip6 = (struct ip6_hdr *) ipo;
d288 1
a288 1
                break;
d291 6
a296 1
		panic("ipip_input: should never reach here");
d314 2
a315 2
					sin = (struct sockaddr_in *) ifa->ifa_addr;

a323 1

d330 4
a333 3
					sin6 = (struct sockaddr_in6 *) ifa->ifa_addr;

					if (IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr, &ip6->ip6_src)) {
d356 1
a356 1
	switch (v >> 4) {
d358 1
a358 1
	case 4:
d361 1
d365 1
a365 1
	case 6:
d368 1
d377 1
a377 2
		bpf_mtap_af(gifp->if_bpf, ifq == &ipintrq ? AF_INET : AF_INET6,
		    m, BPF_DIRECTION_IN);
@


1.45
log
@Remove dead assignment and newly created unused variable.

Found by LLVM/Clang Static Analyzer.

ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.44 2009/11/03 10:59:04 claudio Exp $ */
d48 1
@


1.44
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.43 2009/06/05 00:05:22 claudio Exp $ */
a156 1
	u_int8_t nxt;
a261 1
                nxt = ipo->ip_p;
a270 1
                nxt = ip6->ip6_nxt;
@


1.43
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.42 2008/11/26 16:08:17 henning Exp $ */
d151 1
d291 1
d293 1
a293 1
			if (ifp->if_rdomain != m->m_pkthdr.rdomain)
@


1.42
log
@call pf_pkt_addr_changed() when we do encapsulate
fixes v6-over-v4 gifs wrt pf chatter about state linking mismatches
ok jsing claudio, tested by Ant La Porte <ant at ukbsd.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.41 2008/06/10 09:57:51 todd Exp $ */
d291 2
@


1.41
log
@encapsulating v4 in v6 IPSec should not be so fun,
do not process v4 headers as v6, 255 TTL + icmp (0x01) = ff01:: suddenly, eww!
debugged with bluhm@@, verified by grunk@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.40 2007/12/14 18:33:41 deraadt Exp $ */
d42 2
d72 4
d361 3
@


1.40
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.39 2007/02/10 15:34:22 claudio Exp $ */
d499 9
a507 6
		/* scoped address handling */
		ip6 = mtod(m, struct ip6_hdr *);
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = 0;
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = 0;
@


1.39
log
@Cleanup, kill dead code and unused arguments. Mostly stuff that is computed
and passed around but never used. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.38 2006/12/13 09:01:59 itojun Exp $ */
d636 5
@


1.38
log
@use IN6_IS_SCOPE_EMBED to check kernel-internal form addresses
(s6_addr16[1] filled)
ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.37 2006/04/25 15:49:35 claudio Exp $ */
d377 2
a378 2
ipip_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
    int protoff)
@


1.37
log
@Remove virtual tunnel support from the mrouting code. The virtual tunnel
code breaks multicast on gif(4) interfaces and it is far better to configure
a real gif(4) tunnel instead of a multicast tunnel as the latter is almost
not manageable. OK norby@@, mblamer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.36 2006/03/25 22:41:48 djm Exp $ */
d501 1
a501 1
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
d503 1
a503 1
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
@


1.36
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.35 2006/03/05 21:48:56 miod Exp $ */
a186 9

#ifdef MROUTING
	if (ipo->ip_v == IPVERSION && ipo->ip_p == IPPROTO_IPV4) {
		if (IN_MULTICAST(((struct ip *)((char *) ipo + iphlen))->ip_dst.s_addr)) {
			ipip_mroute_input (m, iphlen);
			return;
		}
	}
#endif /* MROUTING */
@


1.35
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.34 2006/03/04 22:40:16 brad Exp $ */
d363 1
a363 1
		    m);
@


1.34
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.33 2005/07/31 03:52:19 pascoe Exp $ */
d293 2
a294 4
		for (ifp = ifnet.tqh_first; ifp != 0;
		     ifp = ifp->if_list.tqe_next) {
			for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
			     ifa = ifa->ifa_list.tqe_next) {
@


1.33
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.32 2004/11/17 12:06:16 markus Exp $ */
d368 1
a368 1
	s = splimp();			/* isn't it already? */
@


1.32
log
@ip6_plen does not include the size of the ipv6 header; ok itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.31 2004/06/21 20:44:54 itojun Exp $ */
d363 3
a365 16
	if (gifp && gifp->if_bpf) {
		struct mbuf m0;
		u_int af;

		if (ifq == &ipintrq)
			af = AF_INET;
		else
			af = AF_INET6;

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *)&af;

		bpf_mtap(gifp->if_bpf, &m0);
	}
@


1.31
log
@make it possble to use IPsec over link-local address (policy table uses
sin6_scope_id, IPsec porion uses embedded form).  beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.30 2003/12/10 07:22:43 itojun Exp $ */
d543 1
a543 1
		ip6o->ip6_plen = htons(m->m_pkthdr.len);
@


1.30
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.29 2003/05/03 01:43:07 itojun Exp $ */
d545 2
a546 2
		ip6o->ip6_dst = tdb->tdb_dst.sin6.sin6_addr;
		ip6o->ip6_src = tdb->tdb_src.sin6.sin6_addr;
@


1.29
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.28 2003/01/31 17:27:03 deraadt Exp $ */
d140 3
a142 3
	register struct sockaddr_in *sin;
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
d146 1
a146 1
	register struct sockaddr_in6 *sin6;
@


1.28
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.27 2002/07/05 23:12:19 angelos Exp $ */
d372 1
@


1.27
log
@Also, return EAFNOSUPPORT instead of ENOBUFS. Both this and the
previous commit where noted by sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.26 2002/07/05 23:11:09 angelos Exp $ */
d217 1
a217 1
	if (m->m_pkthdr.len < sizeof(struct ip))  {
@


1.26
log
@Bump ipips_family in ipipstat in all cases where EAFNOSUPPORT is returned.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.25 2002/06/10 18:04:55 itojun Exp $ */
d588 1
a588 1
		return ENOBUFS;
@


1.25
log
@correct tcpdump on gif interface (inbound).  reported by fries
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.24 2002/06/09 16:26:10 itojun Exp $ */
d496 1
d572 1
@


1.24
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.23 2002/05/16 14:10:51 kjc Exp $ */
d91 1
a91 1
	/* If we do not accept IPv4 explicitly, drop.  */
d114 1
a114 1
	/* If we do not accept IPv4 explicitly, drop.  */
a165 1

d172 1
d198 1
d200 1
a200 1
	if ((v >> 4) == 4)
d202 1
a203 1

d205 1
a205 1
	if ((v >> 4) == 6)
d207 1
d209 3
d237 4
d260 1
a260 1
	/* Some sanity checks in the inner IPv4 header */
a271 1

d285 2
d345 1
d347 1
a347 1
	if (ipo) {
d350 2
a351 3
	}
#endif /* INET */

d353 1
a353 1
	if (ip6) {
d356 4
a360 1
#endif /* INET6 */
d367 1
a367 1
		if (ipo)
@


1.23
log
@bring in ECN support from KAME.
it consists of
 - ECN support in TCP
 - tunnel-egress and fragment reassembly rules in layer-3 not to lose
   congestion info at tunnel-egress and fragment reassembly

to enable ECN in TCP, build a kernel with TCP_ECN, and then,
turn it on by "sysctl -w net.inet.tcp.ecn=1".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.22 2001/12/06 20:14:53 angelos Exp $ */
d4 1
a4 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
d25 1
a25 1
 * modification of this software. 
d133 1
a133 1
 * were being used in tunnel mode (in which case the rcvif element will 
d167 1
a167 1
#ifdef INET6   
d323 1
a323 1
    
d329 1
a329 1
	 * been done (or will be done), this will point to a normal 
d397 1
a397 1
#ifdef INET6    
@


1.22
log
@Sanity check on inner IP header in IP-in-IP encapsulation; could be
exploited to crash systems that allowed IP-in-IP protocol
(sysctl -w net.inet.ipip.allow=1)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.21 2001/08/19 06:31:56 angelos Exp $ */
d257 4
a260 1
		ip_ecn_egress(ECN_ALLOWED, &otos, &ipo->ip_tos);
d269 4
a272 1
		ip_ecn_egress(ECN_ALLOWED, &otos, &itos);
@


1.22.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.22 2001/12/06 20:14:53 angelos Exp $ */
d257 1
a257 4
		if (!ip_ecn_egress(ECN_ALLOWED, &otos, &ipo->ip_tos)) {
			m_freem(m);
			return;
		}
d266 1
a266 4
		if (!ip_ecn_egress(ECN_ALLOWED, &otos, &itos)) {
			m_freem(m);
			return;
		}
@


1.22.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.22.2.1 2002/06/11 03:31:36 art Exp $ */
d4 1
a4 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
d25 1
a25 1
 * modification of this software.
d91 1
a91 1
	/* If we do not accept IP-in-IP explicitly, drop.  */
d114 1
a114 1
	/* If we do not accept IP-in-IP explicitly, drop.  */
d133 1
a133 1
 * were being used in tunnel mode (in which case the rcvif element will
d166 2
a167 1
#ifdef INET6
a172 1
		ipipstat.ipips_family++;
a197 1
	switch (v >> 4) {
d199 1
a199 1
	case 4:
a200 1
		break;
d202 1
d204 1
a204 1
	case 6:
a205 1
		break;
a206 3
	default:
		panic("ipip_input: should never reach here");
	}
a231 4
	default:
		ipipstat.ipips_family++;
		m_freem(m);
		return; /* EAFNOSUPPORT */
d251 1
a251 1
	/* Some sanity checks in the inner IP header */
d263 1
a276 2
	default:
		panic("ipip_input: should never reach here");
d323 1
a323 1

d329 1
a329 1
	 * been done (or will be done), this will point to a normal
a334 1
	switch (v >> 4) {
d336 1
a336 1
	case 4:
d339 3
a341 2
		break;
#endif
d343 1
a343 1
	case 6:
a345 4
		break;
#endif
	default:
		panic("ipip_input: should never reach here");
d347 1
d354 1
a354 1
		if (ifq == &ipintrq)
d397 1
a397 1
#ifdef INET6
a482 1
			ipipstat.ipips_family++;
a557 1
				ipipstat.ipips_family++;
d573 1
a573 1
		return EAFNOSUPPORT;
@


1.22.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d217 1
a217 1
	if (m->m_pkthdr.len < sizeof(struct ip)) {
a371 1
		m0.m_flags = 0;
@


1.21
log
@Pass the interface (if any) to ipip_input(), so it can be used in
BPF. Closes PR 2000.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.20 2001/07/04 23:14:55 espie Exp $ */
d210 7
@


1.21.2.1
log
@Pull in patch from current:
Fix (angelos):
Sanity check on inner IP header in IP-in-IP encapsulation; could be
exploited to crash systems that allowed IP-in-IP protocol
(sysctl -w net.inet.ipip.allow=1)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.21 2001/08/19 06:31:56 angelos Exp $ */
a209 7

	/* Sanity check */
	if (m->m_pkthdr.len < sizeof(struct ip))  {
		ipipstat.ipips_hdrops++;
		m_freem(m);
		return;
	}
@


1.20
log
@Make preprocessor happier, don't give it untasty tokens at end of input.
Ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.19 2001/06/26 04:29:05 angelos Exp $ */
d51 1
d68 2
d99 1
a99 1
	ipip_input(*m, *offp);
d126 1
a126 1
	ipip_input(m, iphlen);
d138 1
a138 1
ipip_input(struct mbuf *m, int iphlen)
a224 4

        default:
		m_freem(m);
		return /* EAFNOSUPPORT */;
d335 18
@


1.19
log
@More KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.18 2001/06/25 05:11:58 angelos Exp $ */
d192 1
a192 1
#endif MROUTING
@


1.18
log
@Copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.17 2001/06/19 00:48:23 deraadt Exp $ */
d88 9
a96 6
    /* If we do not accept IPv4 explicitly, drop.  */
    if (!ipip_allow && ((*m)->m_flags & (M_AUTH|M_CONF)) == 0)
    {
	DPRINTF(("ip4_input6(): dropped due to policy\n"));
	ipipstat.ipips_pdrops++;
	m_freem(*m);
a97 4
    }

    ipip_input(*m, *offp);
    return IPPROTO_DONE;
d108 2
a109 2
    va_list ap;
    int iphlen;
d111 7
a117 8
    /* If we do not accept IPv4 explicitly, drop.  */
    if (!ipip_allow && (m->m_flags & (M_AUTH|M_CONF)) == 0)
    {
	DPRINTF(("ip4_input(): dropped due to policy\n"));
	ipipstat.ipips_pdrops++;
	m_freem(m);
	return;
    }
d119 3
a121 3
    va_start(ap, m);
    iphlen = va_arg(ap, int);
    va_end(ap);
d123 1
a123 1
    ipip_input(m, iphlen);
d137 5
a141 5
    register struct sockaddr_in *sin;
    register struct ifnet *ifp;
    register struct ifaddr *ifa;
    struct ifqueue *ifq = NULL;
    struct ip *ipo;
d143 3
a145 3
    register struct sockaddr_in6 *sin6;
    struct ip6_hdr *ip6 = NULL;
    u_int8_t itos;
d147 5
a151 5
    u_int8_t nxt;
    int isr;
    u_int8_t otos;
    u_int8_t v;
    int hlen, s;
d153 1
a153 1
    ipipstat.ipips_ipackets++;
d155 1
a155 1
    m_copydata(m, 0, 1, &v);
d157 1
a157 2
    switch (v >> 4)
    {
d160 2
a161 2
            hlen = sizeof(struct ip);
            break;
d166 2
a167 2
            hlen = sizeof(struct ip6_hdr);
            break;
d170 11
a180 12
            m_freem(m);
            return /* EAFNOSUPPORT */;
    }

    /* Bring the IP header in the first mbuf, if not there already */
    if (m->m_len < hlen)
    {
	if ((m = m_pullup(m, hlen)) == NULL)
	{
	    DPRINTF(("ipip_input(): m_pullup() failed\n"));
	    ipipstat.ipips_hdrops++;
	    return;
a181 1
    }
d183 1
a183 1
    ipo = mtod(m, struct ip *);
d186 5
a190 6
    if (ipo->ip_v == IPVERSION && ipo->ip_p == IPPROTO_IPV4)
    {
	if (IN_MULTICAST(((struct ip *)((char *) ipo + iphlen))->ip_dst.s_addr))
	{
	    ipip_mroute_input (m, iphlen);
	    return;
a191 1
    }
d194 1
a194 2
    /* keep outer ecn field */

d196 2
a197 2
    if ((v >> 4) == 4)
      otos = ipo->ip_tos;
d201 2
a202 2
    if ((v >> 4) == 6)
      otos = (ntohl(mtod(m, struct ip6_hdr *)->ip6_flow) >> 20) & 0xff;
d205 2
a206 2
    /* Remove outer IP header */
    m_adj(m, iphlen);
d208 1
a208 1
    m_copydata(m, 0, 1, &v);
d210 1
a210 2
    switch (v >> 4)
    {
d213 2
a214 2
            hlen = sizeof(struct ip);
            break;
d219 2
a220 2
            hlen = sizeof(struct ip6_hdr);
            break;
d224 23
a246 24
            m_freem(m);
            return /* EAFNOSUPPORT */;
    }

    /* Bring the inner IP header in the first mbuf, if not there already */
    if (m->m_len < hlen)
    {
	if ((m = m_pullup(m, hlen)) == NULL)
	{
	    DPRINTF(("ipip_input(): m_pullup() failed\n"));
	    ipipstat.ipips_hdrops++;
	    return;
	}
    }

    /*
     * RFC 1853 specifies that the inner TTL should not be touched on
     * decapsulation. There's no reason this comment should be here, but
     * this is as good as any a position.
     */

    /* Some sanity checks in the inner IPv4 header */
    switch (v >> 4)
    {
d265 1
a265 1
    }
d267 23
a289 27
    /* Check for local address spoofing. */
    if ((m->m_pkthdr.rcvif == NULL ||
	!(m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK)) &&
	ipip_allow != 2)
    {
        for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
	{
	    for (ifa = ifp->if_addrlist.tqh_first;
		 ifa != 0;
		 ifa = ifa->ifa_list.tqe_next)
	    {
#ifdef INET
		if (ipo)
		{
		    if (ifa->ifa_addr->sa_family != AF_INET)
		      continue;

		    sin = (struct sockaddr_in *) ifa->ifa_addr;

		    if (sin->sin_addr.s_addr == ipo->ip_src.s_addr)
		    {
			DPRINTF(("ipip_input(): possible local address spoofing detected on packet from %s to %s (%s->%s)\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst)));
			ipipstat.ipips_spoof++;
			m_freem(m);
			return;
		    }
		}
d293 12
a304 13
		if (ip6)
		{
		    if (ifa->ifa_addr->sa_family != AF_INET6)
		      continue;

		    sin6 = (struct sockaddr_in6 *) ifa->ifa_addr;

		    if (IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr, &ip6->ip6_src))
		    {
			DPRINTF(("ipip_input(): possible local address spoofing detected on packet\n"));
			m_freem(m);
			return;
		    }
d306 3
a309 2
#endif /* INET6 */
	    }
a310 1
    }
d312 10
a321 2
    /* Statistics */
    ipipstat.ipips_ibytes += m->m_pkthdr.len - iphlen;
d323 5
a327 14
    /*
     * Interface pointer stays the same; if no IPsec processing has
     * been done (or will be done), this will point to a normal 
     * interface. Otherwise, it'll point to an enc interface, which
     * will allow a packet filter to distinguish between secure and
     * untrusted packets.
     */

#ifdef INET
    if (ipo)
    {
	ifq = &ipintrq;
	isr = NETISR_IP;
    }
d331 4
a334 5
    if (ip6)
    {
	ifq = &ip6intrq;
	isr = NETISR_IPV6;
    }
d337 7
a343 6
    s = splimp();			/* isn't it already? */
    if (IF_QFULL(ifq))
    {
	IF_DROP(ifq);
	m_freem(m);
	ipipstat.ipips_qfull++;
d345 7
a352 2

	DPRINTF(("ipip_input(): packet dropped because of full queue\n"));
a353 7
    }

    IF_ENQUEUE(ifq, m);
    schednetisr(isr);
    splx(s);

    return;
d358 1
a358 1
	    int protoff)
d360 1
a360 1
    u_int8_t tp, otos;
d363 2
a364 2
    u_int8_t itos;
    struct ip *ipo;
d368 1
a368 1
    struct ip6_hdr *ip6, *ip6o;
d371 1
a371 2
    /* Deal with empty TDB source/destination addresses */
    /* XXX */
d373 2
a374 2
    m_copydata(m, 0, 1, &tp);
    tp = (tp >> 4) & 0xff;  /* Get the IP version number */
d376 1
a376 2
    switch (tdb->tdb_dst.sa.sa_family)
    {
d379 7
a385 10
	    if ((tdb->tdb_src.sa.sa_family != AF_INET) ||
		(tdb->tdb_src.sin.sin_addr.s_addr == INADDR_ANY) ||
		(tdb->tdb_dst.sin.sin_addr.s_addr == INADDR_ANY))
	    {
		DPRINTF(("ipip_output(): unspecified tunnel endpoind address in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ipipstat.ipips_unspec++;
		m_freem(m);
		*mp = NULL;
		return EINVAL;
	    }
d387 5
a391 8
	    M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
	    if (m == 0)
	    {
		DPRINTF(("ipip_output(): M_PREPEND failed\n"));
		ipipstat.ipips_hdrops++;
		*mp = NULL;
		return ENOBUFS;
	    }
d393 7
a399 1
	    ipo = mtod(m, struct ip *);
d401 1
a401 20
	    ipo->ip_v = IPVERSION;
	    ipo->ip_hl = 5;
	    ipo->ip_len = htons(m->m_pkthdr.len);
	    ipo->ip_ttl = ip_defttl;
	    ipo->ip_sum = 0;
	    ipo->ip_src = tdb->tdb_src.sin.sin_addr;
	    ipo->ip_dst = tdb->tdb_dst.sin.sin_addr;

	    /*
	     * We do the htons() to prevent snoopers from determining our
	     * endianness.
	     */
	    ipo->ip_id = htons(ip_randomid());

	    /* If the inner protocol is IP */
	    if (tp == IPVERSION)
	    {
		/* Save ECN notification */
		m_copydata(m, sizeof(struct ip) + offsetof(struct ip, ip_tos),
			   sizeof(u_int8_t), (caddr_t) &itos);
d403 7
a409 1
		ipo->ip_p = IPPROTO_IPIP;
d412 2
a413 2
		 * We should be keeping tunnel soft-state and send back ICMPs
		 * if needed.
d415 22
a436 6
		m_copydata(m, sizeof(struct ip) + offsetof(struct ip, ip_off),
			   sizeof(u_int16_t), (caddr_t) &ipo->ip_off);
                NTOHS(ipo->ip_off);
                ipo->ip_off &= ~(IP_DF | IP_MF | IP_OFFMASK);
                HTONS(ipo->ip_off);
	    }
d438 11
a448 12
	    else if (tp == (IPV6_VERSION >> 4))
	    {
		u_int32_t itos32;
		/* Save ECN notification */
		m_copydata(m, sizeof(struct ip) +
			   offsetof(struct ip6_hdr, ip6_flow),
			   sizeof(u_int32_t), (caddr_t) &itos32);
		itos = ntohl(itos32) >> 20;

		ipo->ip_p = IPPROTO_IPV6;
		ipo->ip_off = 0;
	    }
d450 5
a454 6
	    else
	    {
		m_freem(m);
		*mp = NULL;
		return EAFNOSUPPORT;
	    }
d456 4
a459 4
	    otos = 0;
	    ip_ecn_ingress(ECN_ALLOWED, &otos, &itos);
	    ipo->ip_tos = otos;
	    break;
d464 53
a516 10
	    if (IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr) ||
		(tdb->tdb_src.sa.sa_family != AF_INET6) ||
		IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_src.sin6.sin6_addr))
	    {
		DPRINTF(("ipip_output(): unspecified tunnel endpoind address in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ipipstat.ipips_unspec++;
		m_freem(m);
		*mp = NULL;
		return ENOBUFS;
	    }
d518 18
a535 15
	    /* scoped address handling */
	    ip6 = mtod(m, struct ip6_hdr *);
	    if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = 0;
	    if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = 0;

	    M_PREPEND(m, sizeof(struct ip6_hdr), M_DONTWAIT);
	    if (m == 0)
	    {
		DPRINTF(("ipip_output(): M_PREPEND failed\n"));
		ipipstat.ipips_hdrops++;
		*mp = NULL;
		return ENOBUFS;
	    }
d537 3
a539 35
	    /* Initialize IPv6 header */
	    ip6o = mtod(m, struct ip6_hdr *);
	    ip6o->ip6_flow = 0;
	    ip6o->ip6_vfc &= ~IPV6_VERSION_MASK;
	    ip6o->ip6_vfc |= IPV6_VERSION;
	    ip6o->ip6_plen = htons(m->m_pkthdr.len);
	    ip6o->ip6_hlim = ip_defttl;
	    ip6o->ip6_dst = tdb->tdb_dst.sin6.sin6_addr;
	    ip6o->ip6_src = tdb->tdb_src.sin6.sin6_addr;

#ifdef INET
	    if (tp == IPVERSION)
	    {
		/* Save ECN notification */
		m_copydata(m, sizeof(struct ip6_hdr) +
			   offsetof(struct ip, ip_tos), sizeof(u_int8_t),
			   (caddr_t) &itos);

		ip6o->ip6_nxt = IPPROTO_IPIP; /* This is really IPVERSION */
	    }
	    else
#endif /* INET */
	    if (tp == (IPV6_VERSION >> 4))
	    {
		u_int32_t itos32;
		/* Save ECN notification */
		m_copydata(m, sizeof(struct ip6_hdr) +
			   offsetof(struct ip6_hdr, ip6_flow),
			   sizeof(u_int32_t), (caddr_t) &itos32);
		itos = ntohl(itos32) >> 20;

		ip6o->ip6_nxt = IPPROTO_IPV6;
	    }
	    else
	    {
d542 3
a544 2
		return EAFNOSUPPORT;
	    }
d546 2
a547 5
	    otos = 0;
	    ip_ecn_ingress(ECN_ALLOWED, &otos, &itos);
	    ip6o->ip6_flow |= htonl((u_int32_t) otos << 20);
	    break;
#endif /* INET6 */
d549 5
a553 18
	default:
	    DPRINTF(("ipip_output(): unsupported protocol family %d\n",
		     tdb->tdb_dst.sa.sa_family));
	    m_freem(m);
	    *mp = NULL;
	    ipipstat.ipips_family++;
	    return ENOBUFS;
    }

    ipipstat.ipips_opackets++;

    *mp = m;

#ifdef INET
    if (tdb->tdb_dst.sa.sa_family == AF_INET)
    {
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  tdb->tdb_cur_bytes += m->m_pkthdr.len - sizeof(struct ip);
d555 2
a556 2
	ipipstat.ipips_obytes += m->m_pkthdr.len - sizeof(struct ip);
    }
d560 4
a563 4
    if (tdb->tdb_dst.sa.sa_family == AF_INET6)
    {
	if (tdb->tdb_xform->xf_type == XF_IP4)
	  tdb->tdb_cur_bytes += m->m_pkthdr.len - sizeof(struct ip6_hdr);
d565 3
a567 2
	ipipstat.ipips_obytes += m->m_pkthdr.len - sizeof(struct ip6_hdr);
    }
d570 1
a570 1
    return 0;
a573 1

d577 1
a577 1
    return 0;
d583 2
a584 2
    tdbp->tdb_xform = xsp;
    return 0;
d590 1
a590 1
    return 0;
d596 4
a599 4
    /* This is a rather serious mistake, so no conditional printing */
    printf("ipe4_input(): should never be called\n");
    if (m)
      m_freem(m);
d604 2
a605 7
ipip_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
@


1.17
log
@mop up after angelos
@
text
@d1 1
a1 2
/*	$OpenBSD: ip_ipip.c,v 1.16 2001/06/08 03:53:46 angelos Exp $ */

d20 3
a22 2
 *	
 * Permission to use, copy, and modify this software without fee
@


1.16
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.15 2001/05/30 12:22:57 angelos Exp $ */
a41 1

d43 1
@


1.15
log
@Match prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.14 2001/05/11 17:20:11 aaron Exp $ */
a43 2
#include <sys/systm.h>
#include <sys/malloc.h>
a44 2
#include <sys/domain.h>
#include <sys/protosw.h>
a45 3
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
a46 1
#include <machine/cpu.h>
a57 1
#include <netinet/ip_icmp.h>
a63 3
#include <sys/socketvar.h>
#include <net/raw_cb.h>

a65 1
#include <dev/rndvar.h>
@


1.14
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.13 2001/04/14 00:30:59 angelos Exp $ */
d389 1
a389 1
	    int protoff, struct tdb *tdb2)
@


1.13
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.12 2001/04/06 04:42:08 csapuntz Exp $ */
d193 1
a193 1
	if ((m = m_pullup(m, hlen)) == 0)
d253 1
a253 1
	if ((m = m_pullup(m, hlen)) == 0)
@


1.12
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.11 2001/03/28 20:03:04 angelos Exp $ */
d389 1
a389 1
	    int protoff)
@


1.11
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.10 2001/02/28 01:24:55 angelos Exp $ */
a83 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.10
log
@If net.inet.ipip.allow is set to 2, don't check for loopback address
spoofing of encapsulated packets (useful for single-machinet testing
of isakmpd)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.9 2000/09/19 03:20:58 angelos Exp $ */
a89 2
#define PI_MAGIC 0xdeadbeef   /* XXX */

a104 5
    void *tdbi = (*m)->m_pkthdr.tdbi;
    
    if (tdbi == (void *) PI_MAGIC)
      tdbi = NULL;

a109 2
	if (tdbi)
	  free(tdbi, M_TEMP);
a127 4
    void *tdbi = m->m_pkthdr.tdbi;

    if (tdbi == (void *) PI_MAGIC)
      tdbi = NULL;
a133 2
	if (tdbi)
	  free(tdbi, M_TEMP);
a170 1
    void *tdbi = m->m_pkthdr.tdbi;
a173 3
    if (tdbi == (void *) PI_MAGIC)
      tdbi = NULL;

a189 2
	    if (tdbi)
	      free(tdbi, M_TEMP);
a200 2
	    if (tdbi)
	      free(tdbi, M_TEMP);
a211 6
	    if (tdbi)
	    {
		free(tdbi, M_TEMP);
		m->m_pkthdr.tdbi = NULL;
	    }

d230 1
a230 1
    /* Remove outter IP header */
a249 2
	    if (tdbi)
	      free(tdbi, M_TEMP);
a259 2
	    if (tdbi)
	      free(tdbi, M_TEMP);
a316 2
			if (tdbi)
			  free(tdbi, M_TEMP);
a333 2
			if (tdbi)
			  free(tdbi, M_TEMP);
a375 2
	if (tdbi)
	  free(tdbi, M_TEMP);
d435 1
a435 1
	    
@


1.9
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.8 2000/08/04 00:26:58 angelos Exp $ */
d328 3
a330 2
    if (m->m_pkthdr.rcvif == NULL ||
	!(m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK))
@


1.8
log
@One parenthesis too many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.7 2000/08/04 00:26:07 angelos Exp $ */
d8 2
a9 2
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
d90 2
d107 5
d117 2
d137 4
d147 2
d186 1
d190 3
d209 2
d222 2
a223 1
	    m_freem(m);
d235 6
d279 2
d291 2
d349 2
d368 2
a382 4
    /* tdbi is only set in ESP or AH, if the next protocol is UDP or TCP */
    if (m->m_flags & (M_CONF|M_AUTH))
      m->m_pkthdr.tdbi = NULL;

d412 2
@


1.7
log
@Worked out the logic (thanks to pt98asp@@student.hk-r.se and
pt98kfr@@student.hk-r.se -- I still don't know why rev1.5 didn't
work).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.6 2000/08/03 17:31:20 angelos Exp $ */
d472 1
a472 1
                ipo->ip_off &= ~(IP_DF | IP_MF | IP_OFFMASK));
@


1.6
log
@Back to the submitted patch -- this needs more investigation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.5 2000/08/03 08:24:17 angelos Exp $ */
d471 3
a473 2
                ipo->ip_off = htons(ipo->ip_off & ~(IP_DF | IP_MF |
                                                    IP_OFFMASK));
@


1.5
log
@In fact, this is the correct behaviour (or I'm going crazy).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.4 2000/08/03 07:55:48 angelos Exp $ */
d471 2
a472 2
                ipo->ip_off = htons(ntohs(ipo->ip_off) & ~(IP_DF | IP_MF |
                                                           IP_OFFMASK));
@


1.4
log
@Correct handling of ip_off (askk@@rsn.hk-r.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.3 2000/06/20 04:19:11 itojun Exp $ */
d471 2
a472 2
                ipo->ip_off = ntohs(ipo->ip_off) & ~(IP_DF | IP_MF |
                                                     IP_OFFMASK);
@


1.3
log
@try to cope with AH6 with scoped address case better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.2 2000/01/21 03:16:24 angelos Exp $ */
d471 2
a472 1
		ipo->ip_off &= ~(IP_DF | IP_MF | IP_OFFMASK);
@


1.2
log
@Typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.1 2000/01/21 03:15:05 angelos Exp $ */
d407 1
a407 1
    struct ip6_hdr *ip6o;
d512 7
@


1.2.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.13 2001/04/14 00:30:59 angelos Exp $ */
d8 2
a9 2
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
d86 4
d201 1
d231 1
a231 1
    /* Remove outer IP header */
d296 2
a297 3
    if ((m->m_pkthdr.rcvif == NULL ||
	!(m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK)) &&
	ipip_allow != 2)
d347 4
d397 1
a397 1
	    int protoff, struct tdb *tdb2)
d407 1
a407 1
    struct ip6_hdr *ip6, *ip6o;
d439 1
a439 1

d471 1
a471 3
                NTOHS(ipo->ip_off);
                ipo->ip_off &= ~(IP_DF | IP_MF | IP_OFFMASK);
                HTONS(ipo->ip_off);
a511 7

	    /* scoped address handling */
	    ip6 = mtod(m, struct ip6_hdr *);
	    if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = 0;
	    if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = 0;
@


1.2.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$ */
d21 2
a22 3
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
d42 1
d45 1
d47 2
d50 3
d54 1
d66 1
d73 3
d78 1
d101 8
a108 7
	/* If we do not accept IPv4 explicitly, drop.  */
	if (!ipip_allow && ((*m)->m_flags & (M_AUTH|M_CONF)) == 0) {
		DPRINTF(("ip4_input6(): dropped due to policy\n"));
		ipipstat.ipips_pdrops++;
		m_freem(*m);
		return IPPROTO_DONE;
	}
d110 2
a111 2
	ipip_input(*m, *offp);
	return IPPROTO_DONE;
d122 2
a123 2
	va_list ap;
	int iphlen;
d125 8
a132 7
	/* If we do not accept IPv4 explicitly, drop.  */
	if (!ipip_allow && (m->m_flags & (M_AUTH|M_CONF)) == 0) {
		DPRINTF(("ip4_input(): dropped due to policy\n"));
		ipipstat.ipips_pdrops++;
		m_freem(m);
		return;
	}
d134 3
a136 3
	va_start(ap, m);
	iphlen = va_arg(ap, int);
	va_end(ap);
d138 1
a138 1
	ipip_input(m, iphlen);
d152 5
a156 5
	register struct sockaddr_in *sin;
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
	struct ifqueue *ifq = NULL;
	struct ip *ipo;
d158 3
a160 3
	register struct sockaddr_in6 *sin6;
	struct ip6_hdr *ip6 = NULL;
	u_int8_t itos;
d162 5
a166 5
	u_int8_t nxt;
	int isr;
	u_int8_t otos;
	u_int8_t v;
	int hlen, s;
d168 1
a168 1
	ipipstat.ipips_ipackets++;
d170 1
a170 1
	m_copydata(m, 0, 1, &v);
d172 2
a173 1
	switch (v >> 4) {
d176 2
a177 2
		hlen = sizeof(struct ip);
		break;
d182 2
a183 2
		hlen = sizeof(struct ip6_hdr);
		break;
d186 12
a197 2
		m_freem(m);
		return /* EAFNOSUPPORT */;
d199 1
d201 1
a201 10
	/* Bring the IP header in the first mbuf, if not there already */
	if (m->m_len < hlen) {
		if ((m = m_pullup(m, hlen)) == NULL) {
			DPRINTF(("ipip_input(): m_pullup() failed\n"));
			ipipstat.ipips_hdrops++;
			return;
		}
	}

	ipo = mtod(m, struct ip *);
d204 6
a209 5
	if (ipo->ip_v == IPVERSION && ipo->ip_p == IPPROTO_IPV4) {
		if (IN_MULTICAST(((struct ip *)((char *) ipo + iphlen))->ip_dst.s_addr)) {
			ipip_mroute_input (m, iphlen);
			return;
		}
d211 1
d214 2
a215 1
	/* Keep outer ecn field. */
d217 2
a218 2
	if ((v >> 4) == 4)
		otos = ipo->ip_tos;
d222 2
a223 2
	if ((v >> 4) == 6)
		otos = (ntohl(mtod(m, struct ip6_hdr *)->ip6_flow) >> 20) & 0xff;
d226 2
a227 2
	/* Remove outer IP header */
	m_adj(m, iphlen);
d229 1
a229 1
	m_copydata(m, 0, 1, &v);
d231 2
a232 1
	switch (v >> 4) {
d235 2
a236 2
		hlen = sizeof(struct ip);
		break;
d241 2
a242 2
		hlen = sizeof(struct ip6_hdr);
		break;
d246 24
a269 23
		m_freem(m);
		return /* EAFNOSUPPORT */;
	}

	/*
	 * Bring the inner IP header in the first mbuf, if not there already.
	 */
	if (m->m_len < hlen) {
		if ((m = m_pullup(m, hlen)) == NULL) {
			DPRINTF(("ipip_input(): m_pullup() failed\n"));
			ipipstat.ipips_hdrops++;
			return;
		}
	}

	/*
	 * RFC 1853 specifies that the inner TTL should not be touched on
	 * decapsulation. There's no reason this comment should be here, but
	 * this is as good as any a position.
	 */

	/* Some sanity checks in the inner IPv4 header */
	switch (v >> 4) {
d288 1
a288 1
	}
d290 27
a316 23
	/* Check for local address spoofing. */
	if ((m->m_pkthdr.rcvif == NULL ||
	    !(m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK)) &&
	    ipip_allow != 2) {
		for (ifp = ifnet.tqh_first; ifp != 0;
		     ifp = ifp->if_list.tqe_next) {
			for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
			     ifa = ifa->ifa_list.tqe_next) {
#ifdef INET
				if (ipo) {
					if (ifa->ifa_addr->sa_family !=
					    AF_INET)
						continue;

					sin = (struct sockaddr_in *) ifa->ifa_addr;

					if (sin->sin_addr.s_addr ==
					    ipo->ip_src.s_addr)	{
						ipipstat.ipips_spoof++;
						m_freem(m);
						return;
					}
				}
d320 13
a332 12
				if (ip6) {
					if (ifa->ifa_addr->sa_family !=
					    AF_INET6)
						continue;

					sin6 = (struct sockaddr_in6 *) ifa->ifa_addr;

					if (IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr, &ip6->ip6_src)) {
						ipipstat.ipips_spoof++;
						m_freem(m);
						return;
					}
d334 1
a334 1
				}
d336 1
a336 2
			}
		}
d338 1
d340 2
a341 10
	/* Statistics */
	ipipstat.ipips_ibytes += m->m_pkthdr.len - iphlen;

	/*
	 * Interface pointer stays the same; if no IPsec processing has
	 * been done (or will be done), this will point to a normal 
	 * interface. Otherwise, it'll point to an enc interface, which
	 * will allow a packet filter to distinguish between secure and
	 * untrusted packets.
	 */
d343 14
a356 5
#ifdef INET
	if (ipo) {
		ifq = &ipintrq;
		isr = NETISR_IP;
	}
d360 5
a364 4
	if (ip6) {
		ifq = &ip6intrq;
		isr = NETISR_IPV6;
	}
d367 6
a372 5
	s = splimp();			/* isn't it already? */
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
		ipipstat.ipips_qfull++;
d374 1
a374 1
		splx(s);
d376 7
a382 4
		DPRINTF(("ipip_input(): packet dropped because of full "
		    "queue\n"));
		return;
	}
d384 1
a384 4
	IF_ENQUEUE(ifq, m);
	schednetisr(isr);
	splx(s);
	return;
d389 1
a389 1
    int protoff)
d391 1
a391 1
	u_int8_t tp, otos;
d394 2
a395 2
	u_int8_t itos;
	struct ip *ipo;
d399 1
a399 1
	struct ip6_hdr *ip6, *ip6o;
d402 2
a403 1
	/* XXX Deal with empty TDB source/destination addresses. */
d405 2
a406 2
	m_copydata(m, 0, 1, &tp);
	tp = (tp >> 4) & 0xff;  /* Get the IP version number. */
d408 2
a409 1
	switch (tdb->tdb_dst.sa.sa_family) {
d412 10
a421 7
		if (tdb->tdb_src.sa.sa_family != AF_INET ||
		    tdb->tdb_src.sin.sin_addr.s_addr == INADDR_ANY ||
		    tdb->tdb_dst.sin.sin_addr.s_addr == INADDR_ANY) {

			DPRINTF(("ipip_output(): unspecified tunnel endpoind "
			    "address in SA %s/%08x\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d423 8
a430 5
			ipipstat.ipips_unspec++;
			m_freem(m);
			*mp = NULL;
			return EINVAL;
		}
d432 1
a432 7
		M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
		if (m == 0) {
			DPRINTF(("ipip_output(): M_PREPEND failed\n"));
			ipipstat.ipips_hdrops++;
			*mp = NULL;
			return ENOBUFS;
		}
d434 20
a453 1
		ipo = mtod(m, struct ip *);
d455 1
a455 7
		ipo->ip_v = IPVERSION;
		ipo->ip_hl = 5;
		ipo->ip_len = htons(m->m_pkthdr.len);
		ipo->ip_ttl = ip_defttl;
		ipo->ip_sum = 0;
		ipo->ip_src = tdb->tdb_src.sin.sin_addr;
		ipo->ip_dst = tdb->tdb_dst.sin.sin_addr;
d458 2
a459 2
		 * We do the htons() to prevent snoopers from determining our
		 * endianness.
d461 6
a466 22
		ipo->ip_id = htons(ip_randomid());

		/* If the inner protocol is IP... */
		if (tp == IPVERSION) {
			/* Save ECN notification */
			m_copydata(m, sizeof(struct ip) +
			    offsetof(struct ip, ip_tos),
			    sizeof(u_int8_t), (caddr_t) &itos);

			ipo->ip_p = IPPROTO_IPIP;

			/*
			 * We should be keeping tunnel soft-state and
			 * send back ICMPs if needed.
			 */
			m_copydata(m, sizeof(struct ip) +
			    offsetof(struct ip, ip_off),
			    sizeof(u_int16_t), (caddr_t) &ipo->ip_off);
			NTOHS(ipo->ip_off);
			ipo->ip_off &= ~(IP_DF | IP_MF | IP_OFFMASK);
			HTONS(ipo->ip_off);
		}
d468 12
a479 11
		else if (tp == (IPV6_VERSION >> 4)) {
			u_int32_t itos32;

			/* Save ECN notification. */
			m_copydata(m, sizeof(struct ip) +
			    offsetof(struct ip6_hdr, ip6_flow),
			    sizeof(u_int32_t), (caddr_t) &itos32);
			itos = ntohl(itos32) >> 20;
			ipo->ip_p = IPPROTO_IPV6;
			ipo->ip_off = 0;
		}
d481 6
a486 5
		else {
			m_freem(m);
			*mp = NULL;
			return EAFNOSUPPORT;
		}
d488 4
a491 4
		otos = 0;
		ip_ecn_ingress(ECN_ALLOWED, &otos, &itos);
		ipo->ip_tos = otos;
		break;
d496 10
a505 7
		if (IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_dst.sin6.sin6_addr) ||
		    tdb->tdb_src.sa.sa_family != AF_INET6 ||
		    IN6_IS_ADDR_UNSPECIFIED(&tdb->tdb_src.sin6.sin6_addr)) {

			DPRINTF(("ipip_output(): unspecified tunnel endpoind "
			    "address in SA %s/%08x\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d507 15
a521 5
			ipipstat.ipips_unspec++;
			m_freem(m);
			*mp = NULL;
			return ENOBUFS;
		}
d523 39
a561 14
		/* scoped address handling */
		ip6 = mtod(m, struct ip6_hdr *);
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = 0;
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = 0;

		M_PREPEND(m, sizeof(struct ip6_hdr), M_DONTWAIT);
		if (m == 0) {
			DPRINTF(("ipip_output(): M_PREPEND failed\n"));
			ipipstat.ipips_hdrops++;
			*mp = NULL;
			return ENOBUFS;
		}
d563 4
a566 42
		/* Initialize IPv6 header */
		ip6o = mtod(m, struct ip6_hdr *);
		ip6o->ip6_flow = 0;
		ip6o->ip6_vfc &= ~IPV6_VERSION_MASK;
		ip6o->ip6_vfc |= IPV6_VERSION;
		ip6o->ip6_plen = htons(m->m_pkthdr.len);
		ip6o->ip6_hlim = ip_defttl;
		ip6o->ip6_dst = tdb->tdb_dst.sin6.sin6_addr;
		ip6o->ip6_src = tdb->tdb_src.sin6.sin6_addr;

#ifdef INET
		if (tp == IPVERSION) {
			/* Save ECN notification */
			m_copydata(m, sizeof(struct ip6_hdr) +
			    offsetof(struct ip, ip_tos), sizeof(u_int8_t),
			    (caddr_t) &itos);

			/* This is really IPVERSION. */
			ip6o->ip6_nxt = IPPROTO_IPIP;
		}
		else
#endif /* INET */
			if (tp == (IPV6_VERSION >> 4)) {
				u_int32_t itos32;

				/* Save ECN notification. */
				m_copydata(m, sizeof(struct ip6_hdr) +
				    offsetof(struct ip6_hdr, ip6_flow),
				    sizeof(u_int32_t), (caddr_t) &itos32);
				itos = ntohl(itos32) >> 20;

				ip6o->ip6_nxt = IPPROTO_IPV6;
			} else {
				m_freem(m);
				*mp = NULL;
				return EAFNOSUPPORT;
			}

		otos = 0;
		ip_ecn_ingress(ECN_ALLOWED, &otos, &itos);
		ip6o->ip6_flow |= htonl((u_int32_t) otos << 20);
		break;
d570 17
a586 16
		DPRINTF(("ipip_output(): unsupported protocol family %d\n",
		    tdb->tdb_dst.sa.sa_family));
		m_freem(m);
		*mp = NULL;
		ipipstat.ipips_family++;
		return ENOBUFS;
	}

	ipipstat.ipips_opackets++;
	*mp = m;

#ifdef INET
	if (tdb->tdb_dst.sa.sa_family == AF_INET) {
		if (tdb->tdb_xform->xf_type == XF_IP4)
			tdb->tdb_cur_bytes +=
			    m->m_pkthdr.len - sizeof(struct ip);
d588 2
a589 2
		ipipstat.ipips_obytes += m->m_pkthdr.len - sizeof(struct ip);
	}
d593 4
a596 4
	if (tdb->tdb_dst.sa.sa_family == AF_INET6) {
		if (tdb->tdb_xform->xf_type == XF_IP4)
			tdb->tdb_cur_bytes +=
			    m->m_pkthdr.len - sizeof(struct ip6_hdr);
d598 2
a599 3
		ipipstat.ipips_obytes +=
		    m->m_pkthdr.len - sizeof(struct ip6_hdr);
	}
d602 1
a602 1
	return 0;
d606 1
d610 1
a610 1
	return 0;
d616 2
a617 2
	tdbp->tdb_xform = xsp;
	return 0;
d623 1
a623 1
	return 0;
d629 4
a632 4
	/* This is a rather serious mistake, so no conditional printing. */
	printf("ipe4_input(): should never be called\n");
	if (m)
		m_freem(m);
d637 7
a643 2
ipip_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
@


1.2.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.2.2.2 2001/07/04 10:54:50 niklas Exp $ */
a50 1
#include <net/bpf.h>
a66 2
#include "bpfilter.h"

d96 1
a96 1
	ipip_input(*m, *offp, NULL);
d123 1
a123 1
	ipip_input(m, iphlen, NULL);
d135 1
a135 1
ipip_input(struct mbuf *m, int iphlen, struct ifnet *gifp)
d192 1
a192 1
#endif /* MROUTING */
d222 4
a335 18

#if NBPFILTER > 0
	if (gifp && gifp->if_bpf) {
		struct mbuf m0;
		u_int af;

		if (ipo)
			af = AF_INET;
		else
			af = AF_INET6;

		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char *)&af;

		bpf_mtap(gifp->if_bpf, &m0);
	}
#endif
@


1.2.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a209 7

	/* Sanity check */
	if (m->m_pkthdr.len < sizeof(struct ip))  {
		ipipstat.ipips_hdrops++;
		m_freem(m);
		return;
	}
@


1.2.2.5
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
d25 1
a25 1
 * modification of this software.
d91 1
a91 1
	/* If we do not accept IP-in-IP explicitly, drop.  */
d114 1
a114 1
	/* If we do not accept IP-in-IP explicitly, drop.  */
d133 1
a133 1
 * were being used in tunnel mode (in which case the rcvif element will
d166 2
a167 1
#ifdef INET6
a172 1
		ipipstat.ipips_family++;
a197 1
	switch (v >> 4) {
d199 1
a199 1
	case 4:
a200 1
		break;
d202 1
d204 1
a204 1
	case 6:
a205 1
		break;
a206 3
	default:
		panic("ipip_input: should never reach here");
	}
d212 1
a212 1
	if (m->m_pkthdr.len < sizeof(struct ip)) {
a231 4
	default:
		ipipstat.ipips_family++;
		m_freem(m);
		return; /* EAFNOSUPPORT */
d251 1
a251 1
	/* Some sanity checks in the inner IP header */
d257 1
a257 4
		if (!ip_ecn_egress(ECN_ALLOWED, &otos, &ipo->ip_tos)) {
			m_freem(m);
			return;
		}
d260 1
d266 1
a266 4
		if (!ip_ecn_egress(ECN_ALLOWED, &otos, &itos)) {
			m_freem(m);
			return;
		}
a270 2
	default:
		panic("ipip_input: should never reach here");
d317 1
a317 1

d323 1
a323 1
	 * been done (or will be done), this will point to a normal
a328 1
	switch (v >> 4) {
d330 1
a330 1
	case 4:
d333 3
a335 2
		break;
#endif
d337 1
a337 1
	case 6:
a339 4
		break;
#endif
	default:
		panic("ipip_input: should never reach here");
d341 1
d348 1
a348 1
		if (ifq == &ipintrq)
d391 1
a391 1
#ifdef INET6
a476 1
			ipipstat.ipips_family++;
a551 1
				ipipstat.ipips_family++;
d567 1
a567 1
		return EAFNOSUPPORT;
@


1.2.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ipip.c,v 1.2.2.5 2003/03/28 00:06:54 niklas Exp $ */
a371 1
		m0.m_flags = 0;
@


1.2.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d140 3
a142 3
	struct sockaddr_in *sin;
	struct ifnet *ifp;
	struct ifaddr *ifa;
d146 1
a146 1
	struct sockaddr_in6 *sin6;
@


1.1
log
@Rename the ip4_* routines to ipip_*, make it so GIF tunnels are not
affected by net.inet.ipip.allow (the sysctl formerly known as
net.inet.ip4.allow), rename the VIF ipip_input to ipip_mroute_input.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d189 1
a189 1
        default
@

