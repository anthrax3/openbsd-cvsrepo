head	1.69;
access;
symbols
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.54.0.6
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.31.0.12
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.10
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.8
	OPENBSD_5_0:1.31.0.6
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.26.0.10
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.6
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.4
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.22.0.6
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.16
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.69
date	2017.06.19.17.58.49;	author bluhm;	state Exp;
branches;
next	1.68;
commitid	o1URxEJIRKTXxlGk;

1.68
date	2017.05.16.12.24.01;	author mpi;	state Exp;
branches;
next	1.67;
commitid	SAe3SQ48vKH6r5FL;

1.67
date	2017.05.04.17.58.46;	author bluhm;	state Exp;
branches;
next	1.66;
commitid	Q1XaPbKgEyYyAOP7;

1.66
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.65;
commitid	00hB28wQPwG5Ysk0;

1.65
date	2017.04.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	4O5LUh13nIhVt6oZ;

1.64
date	2017.02.05.16.23.38;	author jca;	state Exp;
branches
	1.64.4.1;
next	1.63;
commitid	b4PzKhPOLWkSDY9t;

1.63
date	2017.01.31.10.24.41;	author jca;	state Exp;
branches;
next	1.62;
commitid	A2smg1VkYafec3DU;

1.62
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.61;
commitid	3e3CkrbYekyVOcxy;

1.61
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.60;
commitid	pVtptbHA3yk4jSpN;

1.60
date	2017.01.04.04.56.24;	author dlg;	state Exp;
branches;
next	1.59;
commitid	OWwrUHDwnT4PcuTU;

1.59
date	2016.12.19.09.22.24;	author rzalamena;	state Exp;
branches;
next	1.58;
commitid	5iifwOyfMyS6GiDF;

1.58
date	2016.12.16.12.24.43;	author rzalamena;	state Exp;
branches;
next	1.57;
commitid	E9uaTCf8VzoD0rzm;

1.57
date	2016.12.14.17.15.56;	author rzalamena;	state Exp;
branches;
next	1.56;
commitid	bQkmhqSlN4pfU8Bn;

1.56
date	2016.12.05.15.31.43;	author mpi;	state Exp;
branches;
next	1.55;
commitid	AOtklk1hjZFcYx3o;

1.55
date	2016.11.28.11.12.45;	author mpi;	state Exp;
branches;
next	1.54;
commitid	pr5LCKF5IZsR2oy7;

1.54
date	2015.11.11.10.01.46;	author mpi;	state Exp;
branches;
next	1.53;
commitid	r0fBjQTx4oDDv9YH;

1.53
date	2015.09.13.17.47.07;	author mpi;	state Exp;
branches;
next	1.52;
commitid	UGlgU3YxVY6ARPqz;

1.52
date	2015.09.11.19.31.38;	author dlg;	state Exp;
branches;
next	1.51;
commitid	kakftgfNUQmZFr4m;

1.51
date	2015.09.10.13.19.25;	author dlg;	state Exp;
branches;
next	1.50;
commitid	BlN705c5vqDlLn2i;

1.50
date	2015.08.28.00.03.54;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	NdgfPIGUgJxQPnT7;

1.49
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.48;
commitid	h7z8lokZ0dFyuWpg;

1.48
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.47;
commitid	cYQY7jiay4SydLhD;

1.47
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.46;
commitid	Vq8oSnWLkf7dyy0N;

1.46
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.45;
commitid	Z1vcFtHO8wRH0yRt;

1.45
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.44;
commitid	uzzBR7hz9ncd4O6G;

1.44
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.43;
commitid	ZqXwxwmeo3l29NOg;

1.43
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.42;
commitid	DQakU8LLWV6Iwx84;

1.42
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.41;
commitid	B4dZSbxas1X1IpXI;

1.41
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	EF98ch02VpFassUi;

1.40
date	2014.05.12.09.15.00;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2013.11.28.10.16.44;	author mpi;	state Exp;
branches;
next	1.35;

1.35
date	2013.10.18.09.04.02;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2013.10.14.11.07.42;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2013.05.02.11.54.10;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.13.01.26.28;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.15.13.28.23;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.15.13.23.53;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.15.11.35.54;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.14.18.33.40;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.13.20.47.57;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.20.19.00.35;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.27.20.05.37;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.19.06.40.01;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.23.01.59.10;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.21.26.33;	author jakob;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.06.08.03.53.45;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.24.04.07.51;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.11.17.20.11;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.25.19.05.43;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.12.28.07.17.38;	author itojun;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.05.18.21.10.24;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.02.05.15.48.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.22.30.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.40.07;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.54.29;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;

1.64.4.1
date	2017.05.11.11.22.30;	author bluhm;	state Exp;
branches;
next	;
commitid	UOML1QegyPMXydTL;


desc
@@


1.69
log
@When dealing with mbuf pointers passed down as function parameters,
bugs could easily result in use-after-free or double free.  Introduce
m_freemp() which automatically resets the pointer before freeing
it.  So we have less dangling pointers in the kernel.
OK krw@@ mpi@@ claudio@@
@
text
@/*	$OpenBSD: igmp.c,v 1.68 2017/05/16 12:24:01 mpi Exp $	*/
/*	$NetBSD: igmp.c,v 1.15 1996/02/13 23:41:25 christos Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1988 Stephen Deering.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)igmp.c	8.2 (Berkeley) 5/3/95
 */

/*
 * Internet Group Management Protocol (IGMP) routines.
 *
 * Written by Steve Deering, Stanford, May 1988.
 * Modified by Rosen Sharma, Stanford, Aug 1994.
 * Modified by Bill Fenner, Xerox PARC, Feb 1995.
 *
 * MULTICAST Revision: 1.3
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/systm.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_var.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/igmp.h>
#include <netinet/igmp_var.h>

#include <sys/stdarg.h>

#define IP_MULTICASTOPTS	0

int *igmpctl_vars[IGMPCTL_MAXID] = IGMPCTL_VARS;

int		igmp_timers_are_running;
static struct router_info *rti_head;
static struct mbuf *router_alert;
struct cpumem *igmpcounters;

void igmp_checktimer(struct ifnet *);
void igmp_sendpkt(struct ifnet *, struct in_multi *, int, in_addr_t);
int rti_fill(struct in_multi *);
struct router_info * rti_find(struct ifnet *);
int igmp_input_if(struct ifnet *, struct mbuf **, int *, int, int);
int igmp_sysctl_igmpstat(void *, size_t *, void *);

void
igmp_init(void)
{
	struct ipoption *ra;

	igmp_timers_are_running = 0;
	rti_head = 0;

	igmpcounters = counters_alloc(igps_ncounters);
	router_alert = m_get(M_DONTWAIT, MT_DATA);
	if (router_alert == NULL) {
		printf("%s: no mbuf\n", __func__);
		return;
	}

	/*
	 * Construct a Router Alert option (RAO) to use in report
	 * messages as required by RFC2236.  This option has the
	 * following format:
	 *
	 *	| 10010100 | 00000100 |  2 octet value  |
	 *
	 * where a value of "0" indicates that routers shall examine
	 * the packet.
	 */
	ra = mtod(router_alert, struct ipoption *);
	ra->ipopt_dst.s_addr = INADDR_ANY;
	ra->ipopt_list[0] = IPOPT_RA;
	ra->ipopt_list[1] = 0x04;
	ra->ipopt_list[2] = 0x00;
	ra->ipopt_list[3] = 0x00;
	router_alert->m_len = sizeof(ra->ipopt_dst) + ra->ipopt_list[1];
}

/* Return -1 for error. */
int
rti_fill(struct in_multi *inm)
{
	struct router_info *rti;

	for (rti = rti_head; rti != 0; rti = rti->rti_next) {
		if (rti->rti_ifidx == inm->inm_ifidx) {
			inm->inm_rti = rti;
			if (rti->rti_type == IGMP_v1_ROUTER)
				return (IGMP_v1_HOST_MEMBERSHIP_REPORT);
			else
				return (IGMP_v2_HOST_MEMBERSHIP_REPORT);
		}
	}

	rti = (struct router_info *)malloc(sizeof(struct router_info),
					   M_MRTABLE, M_NOWAIT);
	if (rti == NULL)
		return (-1);
	rti->rti_ifidx = inm->inm_ifidx;
	rti->rti_type = IGMP_v2_ROUTER;
	rti->rti_next = rti_head;
	rti_head = rti;
	inm->inm_rti = rti;
	return (IGMP_v2_HOST_MEMBERSHIP_REPORT);
}

struct router_info *
rti_find(struct ifnet *ifp)
{
	struct router_info *rti;

	for (rti = rti_head; rti != 0; rti = rti->rti_next) {
		if (rti->rti_ifidx == ifp->if_index)
			return (rti);
	}

	rti = (struct router_info *)malloc(sizeof(struct router_info),
					   M_MRTABLE, M_NOWAIT);
	if (rti == NULL)
		return (NULL);
	rti->rti_ifidx = ifp->if_index;
	rti->rti_type = IGMP_v2_ROUTER;
	rti->rti_next = rti_head;
	rti_head = rti;
	return (rti);
}

void
rti_delete(struct ifnet *ifp)
{
	struct router_info *rti, **prti = &rti_head;

	for (rti = rti_head; rti != 0; rti = rti->rti_next) {
		if (rti->rti_ifidx == ifp->if_index) {
			*prti = rti->rti_next;
			free(rti, M_MRTABLE, sizeof(*rti));
			break;
		}
		prti = &rti->rti_next;
	}
}

int
igmp_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct ifnet *ifp;

	igmpstat_inc(igps_rcv_total);

	ifp = if_get((*mp)->m_pkthdr.ph_ifidx);
	if (ifp == NULL) {
		m_freemp(mp);
		return IPPROTO_DONE;
	}

	proto = igmp_input_if(ifp, mp, offp, proto, af);
	if_put(ifp);
	return proto;
}

int
igmp_input_if(struct ifnet *ifp, struct mbuf **mp, int *offp, int proto, int af)
{
	struct mbuf *m = *mp;
	int iphlen = *offp;
	struct ip *ip = mtod(m, struct ip *);
	struct igmp *igmp;
	int igmplen;
	int minlen;
	struct ifmaddr *ifma;
	struct in_multi *inm;
	struct router_info *rti;
	struct in_ifaddr *ia;
	int timer;

	igmplen = ntohs(ip->ip_len) - iphlen;

	/*
	 * Validate lengths
	 */
	if (igmplen < IGMP_MINLEN) {
		igmpstat_inc(igps_rcv_tooshort);
		m_freem(m);
		return IPPROTO_DONE;
	}
	minlen = iphlen + IGMP_MINLEN;
	if ((m->m_flags & M_EXT || m->m_len < minlen) &&
	    (m = *mp = m_pullup(m, minlen)) == NULL) {
		igmpstat_inc(igps_rcv_tooshort);
		return IPPROTO_DONE;
	}

	/*
	 * Validate checksum
	 */
	m->m_data += iphlen;
	m->m_len -= iphlen;
	igmp = mtod(m, struct igmp *);
	if (in_cksum(m, igmplen)) {
		igmpstat_inc(igps_rcv_badsum);
		m_freem(m);
		return IPPROTO_DONE;
	}
	m->m_data -= iphlen;
	m->m_len += iphlen;
	ip = mtod(m, struct ip *);

	switch (igmp->igmp_type) {

	case IGMP_HOST_MEMBERSHIP_QUERY:
		igmpstat_inc(igps_rcv_queries);

		if (ifp->if_flags & IFF_LOOPBACK)
			break;

		if (igmp->igmp_code == 0) {
			rti = rti_find(ifp);
			if (rti == NULL) {
				m_freem(m);
				return IPPROTO_DONE;
			}
			rti->rti_type = IGMP_v1_ROUTER;
			rti->rti_age = 0;

			if (ip->ip_dst.s_addr != INADDR_ALLHOSTS_GROUP) {
				igmpstat_inc(igps_rcv_badqueries);
				m_freem(m);
				return IPPROTO_DONE;
			}

			/*
			 * Start the timers in all of our membership records
			 * for the interface on which the query arrived,
			 * except those that are already running and those
			 * that belong to a "local" group (224.0.0.X).
			 */
			TAILQ_FOREACH(ifma, &ifp->if_maddrlist, ifma_list) {
				if (ifma->ifma_addr->sa_family != AF_INET)
					continue;
				inm = ifmatoinm(ifma);
				if (inm->inm_timer == 0 &&
				    !IN_LOCAL_GROUP(inm->inm_addr.s_addr)) {
					inm->inm_state = IGMP_DELAYING_MEMBER;
					inm->inm_timer = IGMP_RANDOM_DELAY(
					    IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ);
					igmp_timers_are_running = 1;
				}
			}
		} else {
			if (!IN_MULTICAST(ip->ip_dst.s_addr)) {
				igmpstat_inc(igps_rcv_badqueries);
				m_freem(m);
				return IPPROTO_DONE;
			}

			timer = igmp->igmp_code * PR_FASTHZ / IGMP_TIMER_SCALE;
			if (timer == 0)
				timer = 1;

			/*
			 * Start the timers in all of our membership records
			 * for the interface on which the query arrived,
			 * except those that are already running and those
			 * that belong to a "local" group (224.0.0.X).  For
			 * timers already running, check if they need to be
			 * reset.
			 */
			TAILQ_FOREACH(ifma, &ifp->if_maddrlist, ifma_list) {
				if (ifma->ifma_addr->sa_family != AF_INET)
					continue;
				inm = ifmatoinm(ifma);
				if (!IN_LOCAL_GROUP(inm->inm_addr.s_addr) &&
				    (ip->ip_dst.s_addr == INADDR_ALLHOSTS_GROUP ||
				     ip->ip_dst.s_addr == inm->inm_addr.s_addr)) {
					switch (inm->inm_state) {
					case IGMP_DELAYING_MEMBER:
						if (inm->inm_timer <= timer)
							break;
						/* FALLTHROUGH */
					case IGMP_IDLE_MEMBER:
					case IGMP_LAZY_MEMBER:
					case IGMP_AWAKENING_MEMBER:
						inm->inm_state =
						    IGMP_DELAYING_MEMBER;
						inm->inm_timer =
						    IGMP_RANDOM_DELAY(timer);
						igmp_timers_are_running = 1;
						break;
					case IGMP_SLEEPING_MEMBER:
						inm->inm_state =
						    IGMP_AWAKENING_MEMBER;
						break;
					}
				}
			}
		}

		break;

	case IGMP_v1_HOST_MEMBERSHIP_REPORT:
		igmpstat_inc(igps_rcv_reports);

		if (ifp->if_flags & IFF_LOOPBACK)
			break;

		if (!IN_MULTICAST(igmp->igmp_group.s_addr) ||
		    igmp->igmp_group.s_addr != ip->ip_dst.s_addr) {
			igmpstat_inc(igps_rcv_badreports);
			m_freem(m);
			return IPPROTO_DONE;
		}

		/*
		 * KLUDGE: if the IP source address of the report has an
		 * unspecified (i.e., zero) subnet number, as is allowed for
		 * a booting host, replace it with the correct subnet number
		 * so that a process-level multicast routing daemon can
		 * determine which subnet it arrived from.  This is necessary
		 * to compensate for the lack of any way for a process to
		 * determine the arrival interface of an incoming packet.
		 */
		if ((ip->ip_src.s_addr & IN_CLASSA_NET) == 0) {
			IFP_TO_IA(ifp, ia);
			if (ia)
				ip->ip_src.s_addr = ia->ia_net;
		}

		/*
		 * If we belong to the group being reported, stop
		 * our timer for that group.
		 */
		IN_LOOKUP_MULTI(igmp->igmp_group, ifp, inm);
		if (inm != NULL) {
			inm->inm_timer = 0;
			igmpstat_inc(igps_rcv_ourreports);

			switch (inm->inm_state) {
			case IGMP_IDLE_MEMBER:
			case IGMP_LAZY_MEMBER:
			case IGMP_AWAKENING_MEMBER:
			case IGMP_SLEEPING_MEMBER:
				inm->inm_state = IGMP_SLEEPING_MEMBER;
				break;
			case IGMP_DELAYING_MEMBER:
				if (inm->inm_rti->rti_type == IGMP_v1_ROUTER)
					inm->inm_state = IGMP_LAZY_MEMBER;
				else
					inm->inm_state = IGMP_SLEEPING_MEMBER;
				break;
			}
		}

		break;

	case IGMP_v2_HOST_MEMBERSHIP_REPORT:
#ifdef MROUTING
		/*
		 * Make sure we don't hear our own membership report.  Fast
		 * leave requires knowing that we are the only member of a
		 * group.
		 */
		IFP_TO_IA(ifp, ia);
		if (ia && ip->ip_src.s_addr == ia->ia_addr.sin_addr.s_addr)
			break;
#endif

		igmpstat_inc(igps_rcv_reports);

		if (ifp->if_flags & IFF_LOOPBACK)
			break;

		if (!IN_MULTICAST(igmp->igmp_group.s_addr) ||
		    igmp->igmp_group.s_addr != ip->ip_dst.s_addr) {
			igmpstat_inc(igps_rcv_badreports);
			m_freem(m);
			return IPPROTO_DONE;
		}

		/*
		 * KLUDGE: if the IP source address of the report has an
		 * unspecified (i.e., zero) subnet number, as is allowed for
		 * a booting host, replace it with the correct subnet number
		 * so that a process-level multicast routing daemon can
		 * determine which subnet it arrived from.  This is necessary
		 * to compensate for the lack of any way for a process to
		 * determine the arrival interface of an incoming packet.
		 */
		if ((ip->ip_src.s_addr & IN_CLASSA_NET) == 0) {
#ifndef MROUTING
			IFP_TO_IA(ifp, ia);
#endif
			if (ia)
				ip->ip_src.s_addr = ia->ia_net;
		}

		/*
		 * If we belong to the group being reported, stop
		 * our timer for that group.
		 */
		IN_LOOKUP_MULTI(igmp->igmp_group, ifp, inm);
		if (inm != NULL) {
			inm->inm_timer = 0;
			igmpstat_inc(igps_rcv_ourreports);

			switch (inm->inm_state) {
			case IGMP_DELAYING_MEMBER:
			case IGMP_IDLE_MEMBER:
			case IGMP_AWAKENING_MEMBER:
				inm->inm_state = IGMP_LAZY_MEMBER;
				break;
			case IGMP_LAZY_MEMBER:
			case IGMP_SLEEPING_MEMBER:
				break;
			}
		}

		break;

	}

	/*
	 * Pass all valid IGMP packets up to any process(es) listening
	 * on a raw IGMP socket.
	 */
	return rip_input(mp, offp, proto, af);
}

void
igmp_joingroup(struct in_multi *inm)
{
	struct ifnet* ifp;
	int i;

	ifp = if_get(inm->inm_ifidx);

	inm->inm_state = IGMP_IDLE_MEMBER;

	if (!IN_LOCAL_GROUP(inm->inm_addr.s_addr) &&
	    ifp && (ifp->if_flags & IFF_LOOPBACK) == 0) {
		if ((i = rti_fill(inm)) == -1)
			goto out;

		igmp_sendpkt(ifp, inm, i, 0);
		inm->inm_state = IGMP_DELAYING_MEMBER;
		inm->inm_timer = IGMP_RANDOM_DELAY(
		    IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ);
		igmp_timers_are_running = 1;
	} else
		inm->inm_timer = 0;

out:
	if_put(ifp);
}

void
igmp_leavegroup(struct in_multi *inm)
{
	struct ifnet* ifp;

	ifp = if_get(inm->inm_ifidx);

	switch (inm->inm_state) {
	case IGMP_DELAYING_MEMBER:
	case IGMP_IDLE_MEMBER:
		if (!IN_LOCAL_GROUP(inm->inm_addr.s_addr) &&
		    ifp && (ifp->if_flags & IFF_LOOPBACK) == 0)
			if (inm->inm_rti->rti_type != IGMP_v1_ROUTER)
				igmp_sendpkt(ifp, inm,
				    IGMP_HOST_LEAVE_MESSAGE,
				    INADDR_ALLROUTERS_GROUP);
		break;
	case IGMP_LAZY_MEMBER:
	case IGMP_AWAKENING_MEMBER:
	case IGMP_SLEEPING_MEMBER:
		break;
	}
	if_put(ifp);
}

void
igmp_fasttimo(void)
{
	struct ifnet *ifp;

	NET_ASSERT_LOCKED();

	/*
	 * Quick check to see if any work needs to be done, in order
	 * to minimize the overhead of fasttimo processing.
	 */
	if (!igmp_timers_are_running)
		return;

	igmp_timers_are_running = 0;
	TAILQ_FOREACH(ifp, &ifnet, if_list)
		igmp_checktimer(ifp);
}


void
igmp_checktimer(struct ifnet *ifp)
{
	struct in_multi *inm;
	struct ifmaddr *ifma;

	NET_ASSERT_LOCKED();

	TAILQ_FOREACH(ifma, &ifp->if_maddrlist, ifma_list) {
		if (ifma->ifma_addr->sa_family != AF_INET)
			continue;
		inm = ifmatoinm(ifma);
		if (inm->inm_timer == 0) {
			/* do nothing */
		} else if (--inm->inm_timer == 0) {
			if (inm->inm_state == IGMP_DELAYING_MEMBER) {
				if (inm->inm_rti->rti_type == IGMP_v1_ROUTER)
					igmp_sendpkt(ifp, inm,
					    IGMP_v1_HOST_MEMBERSHIP_REPORT, 0);
				else
					igmp_sendpkt(ifp, inm,
					    IGMP_v2_HOST_MEMBERSHIP_REPORT, 0);
				inm->inm_state = IGMP_IDLE_MEMBER;
			}
		} else {
			igmp_timers_are_running = 1;
		}
	}
}

void
igmp_slowtimo(void)
{
	struct router_info *rti;

	NET_ASSERT_LOCKED();

	for (rti = rti_head; rti != 0; rti = rti->rti_next) {
		if (rti->rti_type == IGMP_v1_ROUTER &&
		    ++rti->rti_age >= IGMP_AGE_THRESHOLD) {
			rti->rti_type = IGMP_v2_ROUTER;
		}
	}
}

void
igmp_sendpkt(struct ifnet *ifp, struct in_multi *inm, int type,
    in_addr_t addr)
{
	struct mbuf *m;
	struct igmp *igmp;
	struct ip *ip;
	struct ip_moptions imo;

	MGETHDR(m, M_DONTWAIT, MT_HEADER);
	if (m == NULL)
		return;

	/*
	 * Assume max_linkhdr + sizeof(struct ip) + IGMP_MINLEN
	 * is smaller than mbuf size returned by MGETHDR.
	 */
	m->m_data += max_linkhdr;
	m->m_len = sizeof(struct ip) + IGMP_MINLEN;
	m->m_pkthdr.len = sizeof(struct ip) + IGMP_MINLEN;

	ip = mtod(m, struct ip *);
	ip->ip_tos = 0;
	ip->ip_len = htons(sizeof(struct ip) + IGMP_MINLEN);
	ip->ip_off = 0;
	ip->ip_p = IPPROTO_IGMP;
	ip->ip_src.s_addr = INADDR_ANY;
	if (addr) {
		ip->ip_dst.s_addr = addr;
	} else {
		ip->ip_dst = inm->inm_addr;
	}

	m->m_data += sizeof(struct ip);
	m->m_len -= sizeof(struct ip);
	igmp = mtod(m, struct igmp *);
	igmp->igmp_type = type;
	igmp->igmp_code = 0;
	igmp->igmp_group = inm->inm_addr;
	igmp->igmp_cksum = 0;
	igmp->igmp_cksum = in_cksum(m, IGMP_MINLEN);
	m->m_data -= sizeof(struct ip);
	m->m_len += sizeof(struct ip);

	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;
	imo.imo_ifidx = inm->inm_ifidx;
	imo.imo_ttl = 1;

	/*
	 * Request loopback of the report if we are acting as a multicast
	 * router, so that the process-level routing daemon can hear it.
	 */
#ifdef MROUTING
	imo.imo_loop = (ip_mrouter[ifp->if_rdomain] != NULL);
#else
	imo.imo_loop = 0;
#endif /* MROUTING */

	ip_output(m, router_alert, NULL, IP_MULTICASTOPTS, &imo, NULL, 0);

	igmpstat_inc(igps_snd_reports);
}

/*
 * Sysctl for igmp variables.
 */
int
igmp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case IGMPCTL_STATS:
		if (newp != NULL)
			return (EPERM);
		return (igmp_sysctl_igmpstat(oldp, oldlenp, newp));
	default:
		if (name[0] < IGMPCTL_MAXID)
			return (sysctl_int_arr(igmpctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}

int
igmp_sysctl_igmpstat(void *oldp, size_t *oldlenp, void *newp)
{
	uint64_t counters[igps_ncounters];
	struct igmpstat igmpstat;
	u_long *words = (u_long *)&igmpstat;
	int i;

	CTASSERT(sizeof(igmpstat) == (nitems(counters) * sizeof(u_long)));
	memset(&igmpstat, 0, sizeof igmpstat);
	counters_read(igmpcounters, counters, nitems(counters));

	for (i = 0; i < nitems(counters); i++)
		words[i] = (u_long)counters[i];

	return (sysctl_rdstruct(oldp, oldlenp, newp,
	    &igmpstat, sizeof(igmpstat)));
}
@


1.68
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.67 2017/05/04 17:58:46 bluhm Exp $	*/
d220 1
a220 1
		m_freem(*mp);
@


1.67
log
@If m is not a continuous mbuf cluster, m_pullup() in pr_input may
change the pointer.  Then *mp keeps the invalid pointer and it might
be used.  Fix the potential use after free and also reset *mp in
other places to have less dangling pointers to freed mbufs.
OK mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.66 2017/04/14 20:46:31 bluhm Exp $	*/
d553 1
a553 1
	splsoftassert(IPL_SOFTNET);
d574 1
a574 1
	splsoftassert(IPL_SOFTNET);
d603 1
a603 1
	splsoftassert(IPL_SOFTNET);
@


1.66
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.65 2017/04/05 13:35:18 deraadt Exp $	*/
d256 1
a256 1
	    (m = m_pullup(m, minlen)) == NULL) {
@


1.65
log
@When building counter memory in preparation to copy to userland, always
zero the buffers first.  All the current objects appear to be safe,
however future changes might introduce structure pads.
Discussed with guenther, ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.64 2017/02/05 16:23:38 jca Exp $	*/
d110 1
a110 1
int igmp_input_if(struct ifnet *, struct mbuf **, int *, int);
d212 1
a212 1
igmp_input(struct mbuf **mp, int *offp, int proto)
d224 1
a224 1
	proto = igmp_input_if(ifp, mp, offp, proto);
d230 1
a230 1
igmp_input_if(struct ifnet *ifp, struct mbuf **mp, int *offp, int proto)
d493 1
a493 1
	return rip_input(mp, offp, proto);
@


1.64
log
@Always allocate counters memory using type M_COUNTERS.

This makes the API simpler, and is probably more useful than spreading
counters memory other several types, making it harder to track.

Prodded by mpi, ok mpi@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.63 2017/01/31 10:24:41 jca Exp $	*/
d710 1
a710 1

@


1.64.4.1
log
@If m is not a continuous mbuf cluster, m_pullup() in pr_input may
change the pointer.  Then *mp keeps the invalid pointer and it might
be used.  Fix the potential use after free in igmp_input_if() and
icmp_input_if().  As the input buffers normally deal with mbuf
clusters, the use after free should not happen.
OK mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.64 2017/02/05 16:23:38 jca Exp $	*/
d256 1
a256 1
	    (m = *mp = m_pullup(m, minlen)) == NULL) {
@


1.63
log
@Use CTASSERT instead of KASSERT for a few sysctl that use the counters API

ok dlg@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.62 2017/01/29 19:58:47 bluhm Exp $	*/
d121 1
a121 1
	igmpcounters = counters_alloc(igps_ncounters, M_COUNTERS);
@


1.62
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.61 2017/01/25 17:34:31 bluhm Exp $	*/
d709 1
a709 1
	KASSERT(sizeof(igmpstat) == (nitems(counters) * sizeof(u_long)));
@


1.61
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.60 2017/01/04 04:56:24 dlg Exp $	*/
d110 1
a110 1
void igmp_input_if(struct ifnet *, struct mbuf *, int, int);
d211 2
a212 2
void
igmp_input(struct mbuf *m, int iphlen, int proto)
d218 1
a218 1
	ifp = if_get(m->m_pkthdr.ph_ifidx);
d220 2
a221 2
		m_freem(m);
		return;
d224 1
a224 1
	igmp_input_if(ifp, m, iphlen, proto);
d226 1
d229 2
a230 2
void
igmp_input_if(struct ifnet *ifp, struct mbuf *m, int iphlen, int proto)
d232 2
d252 1
a252 1
		return;
d258 1
a258 1
		return;
d270 1
a270 1
		return;
d288 1
a288 1
				return;
d296 1
a296 1
				return;
d321 1
a321 1
				return;
d378 1
a378 1
			return;
d444 1
a444 1
			return;
d493 1
a493 1
	rip_input(m, iphlen, proto);
@


1.60
log
@convert igmp_stat into per-cpu counters

it follows the same pattern used in previous conversions.

from Dimitris Papastamos (thank you).

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.59 2016/12/19 09:22:24 rzalamena Exp $	*/
d110 1
a110 1
void igmp_input_if(struct ifnet *, struct mbuf *, int);
d212 1
a212 1
igmp_input(struct mbuf *m, ...)
a213 1
	int iphlen;
a214 5
	va_list ap;

	va_start(ap, m);
	iphlen = va_arg(ap, int);
	va_end(ap);
d224 1
a224 1
	igmp_input_if(ifp, m, iphlen);
d229 1
a229 1
igmp_input_if(struct ifnet *ifp, struct mbuf *m, int iphlen)
d490 1
a490 1
	rip_input(m);
@


1.59
log
@Extend the multicast sockets and multicast hash table support to multiple
domains. This is one step towards supporting to run more than one multicast
socket in different domains at the same time.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.58 2016/12/16 12:24:43 rzalamena Exp $	*/
d104 1
a104 1
struct igmpstat igmpstat;
d111 1
d121 1
d222 1
a222 1
	++igmpstat.igps_rcv_total;
d253 1
a253 1
		++igmpstat.igps_rcv_tooshort;
d260 1
a260 1
		++igmpstat.igps_rcv_tooshort;
d271 1
a271 1
		++igmpstat.igps_rcv_badsum;
d282 1
a282 1
		++igmpstat.igps_rcv_queries;
d297 1
a297 1
				++igmpstat.igps_rcv_badqueries;
d322 1
a322 1
				++igmpstat.igps_rcv_badqueries;
d372 1
a372 1
		++igmpstat.igps_rcv_reports;
d379 1
a379 1
			++igmpstat.igps_rcv_badreports;
d406 1
a406 1
			++igmpstat.igps_rcv_ourreports;
d438 1
a438 1
		++igmpstat.igps_rcv_reports;
d445 1
a445 1
			++igmpstat.igps_rcv_badreports;
d474 1
a474 1
			++igmpstat.igps_rcv_ourreports;
d676 1
a676 1
	++igmpstat.igps_snd_reports;
d694 1
a694 2
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &igmpstat, sizeof(igmpstat)));
d702 19
@


1.58
log
@Move the if_get/if_put to the caller of igmp_sendpkt so we avoid having
to do this lookup twice.

Suggested by and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.57 2016/12/14 17:15:56 rzalamena Exp $	*/
d667 1
a667 1
	imo.imo_loop = (ip_mrouter != NULL);
@


1.57
log
@Set the rtableid for new mbufs when sending packets in igmp_sendpkt().

ok mikeb@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.56 2016/12/05 15:31:43 mpi Exp $	*/
d107 1
a107 1
void igmp_sendpkt(struct in_multi *, int, in_addr_t);
d512 1
a512 1
		igmp_sendpkt(inm, i, 0);
d537 2
a538 1
				igmp_sendpkt(inm, IGMP_HOST_LEAVE_MESSAGE,
d586 1
a586 1
					igmp_sendpkt(inm,
d589 1
a589 1
					igmp_sendpkt(inm,
d615 2
a616 1
igmp_sendpkt(struct in_multi *inm, int type, in_addr_t addr)
a617 1
	struct ifnet *ifp;
a622 3
	if ((ifp = if_get(inm->inm_ifidx)) == NULL)
		return;

d624 1
a624 2
	if (m == NULL) {
		if_put(ifp);
a625 1
	}
a672 1
	if_put(ifp);
@


1.56
log
@Remove recursive splsoftnet()s in ioctl(2) path.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.55 2016/11/28 11:12:45 mpi Exp $	*/
d616 1
d622 3
d626 2
a627 1
	if (m == NULL)
d629 2
d662 1
d677 1
@


1.55
log
@Assert that every slow/fast timeout routine is called at IPL_SOFTNET.

This removes multipe recursive splsoftnet()/splx() dances.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.54 2015/11/11 10:01:46 mpi Exp $	*/
d501 1
a501 1
	int i, s;
a503 1
	s = splsoftnet();
a520 1
	splx(s);
a527 1
	int s;
a529 1
	s = splsoftnet();
a544 1
	splx(s);
@


1.54
log
@Store an interface index instead of a pointer that's never dereferenced.

Get rid of an if_ref()/if_put() dance.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.53 2015/09/13 17:47:07 mpi Exp $	*/
d557 2
a558 1
	int s;
a566 1
	s = splsoftnet();
a569 1
	splx(s);
a606 1
	int s;
d608 2
a609 1
	s = splsoftnet();
a615 1
	splx(s);
@


1.53
log
@if_put() after if_get().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.52 2015/09/11 19:31:38 dlg Exp $	*/
d152 1
a152 1
		if (rti->rti_ifp->if_index == inm->inm_ifidx) {
d165 1
a165 1
	rti->rti_ifp = if_get(inm->inm_ifidx);
d179 1
a179 1
		if (rti->rti_ifp == ifp)
d187 1
a187 1
	rti->rti_ifp = if_ref(ifp);
d200 1
a200 2
		if (rti->rti_ifp == ifp) {
			if_put(ifp);
d227 1
a227 1
	
d512 1
a512 1
		
@


1.52
log
@if_put after if_get in igmp_joingroup

ok mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.51 2015/09/10 13:19:25 dlg Exp $	*/
d551 1
@


1.51
log
@move the guts of igmp_input into a igmp_input_if function and call
it with the reference from if_get held so we can if_put it easly
after the guts have run.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.50 2015/08/28 00:03:54 deraadt Exp $	*/
d511 3
a513 4
		if ((i = rti_fill(inm)) == -1) {
			splx(s);
			return;
		}
d521 2
d524 1
@


1.50
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.49 2015/06/16 11:09:40 mpi Exp $	*/
d110 1
d187 1
a187 1
	rti->rti_ifp = ifp;
d201 1
a214 9
	struct ip *ip = mtod(m, struct ip *);
	struct igmp *igmp;
	int igmplen;
	int minlen;
	struct ifmaddr *ifma;
	struct in_multi *inm;
	struct router_info *rti;
	struct in_ifaddr *ia;
	int timer;
a222 2
	igmplen = ntohs(ip->ip_len) - iphlen;

d228 19
@


1.49
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.48 2014/12/17 09:57:13 mpi Exp $	*/
d201 1
a201 1
			free(rti, M_MRTABLE, 0);
@


1.48
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.47 2014/12/17 09:45:59 mpi Exp $	*/
d212 1
a212 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d231 6
@


1.47
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.46 2014/11/18 02:37:31 tedu Exp $	*/
d645 1
a645 1
	imo.imo_multicast_ttl = 1;
d652 1
a652 1
	imo.imo_multicast_loop = (ip_mrouter != NULL);
d654 1
a654 1
	imo.imo_multicast_loop = 0;
@


1.46
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.45 2014/09/14 14:17:26 jsg Exp $	*/
d644 1
a644 1
	imo.imo_multicast_ifp = if_get(inm->inm_ifidx);
@


1.45
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.44 2014/09/08 06:24:13 jsg Exp $	*/
a93 1
#include <dev/rndvar.h>
@


1.44
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.43 2014/07/22 11:06:10 mpi Exp $	*/
a82 1
#include <sys/proc.h>
@


1.43
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.42 2014/07/12 18:44:23 tedu Exp $	*/
a87 1
#include <net/route.h>
@


1.42
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.41 2014/07/08 17:19:26 deraadt Exp $	*/
a91 1
#include <netinet/in_systm.h>
@


1.41
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.40 2014/05/12 09:15:00 mpi Exp $	*/
d205 1
a205 1
			free(rti, M_MRTABLE);
@


1.40
log
@Includes a router altert option (RAO) in IGMP packets.   Without this
option, required by the RFC2236, some L3 switches do not examine the
packets.

Based on FreeBSD's r14622 via Florian Riehm on tech@@. ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.39 2014/04/21 12:22:26 henning Exp $	*/
d80 1
@


1.39
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.38 2014/04/21 11:10:54 henning Exp $	*/
d106 1
d117 10
d129 8
a136 1
	 * To avoid byte-swapping the same value over and over again.
d138 7
a144 2
	igmp_timers_are_running = 0;
	rti_head = 0;
d660 1
a660 1
	ip_output(m, NULL, NULL, IP_MULTICASTOPTS, &imo, NULL, 0);
@


1.38
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.36 2013/11/28 10:16:44 mpi Exp $	*/
d637 1
a637 1
	ip_output(m, NULL, NULL, IP_MULTICASTOPTS, &imo, NULL);
@


1.37
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d637 1
a637 2
	ip_output(m, (struct mbuf *)0, (struct route *)0, IP_MULTICASTOPTS,
	    &imo, (void *)NULL);
@


1.36
log
@Change the way protocol multicast addresses are linked to an interface.

Instead of linking multicast records to the first configured address of
the corresponding protocol, making this address and its position in the
global list special, add them to a new list directly linked to the
interface descriptor.

This new multicast address list is similar to the address list, all its
elements contain a protocol agnostic part.  This design allows us to
be able to join a multicast group without necessarily having a configured
address.  That means IPv6 multicast kludges are no longer needed.

Another benefit is to be able to add and remove an IP address from an
interface without worrying about multicast records.  That means that the
global IPv4 list is no longer needed since the first configured address
of an interface is no longer special.

This new list might also be extended in the future to contain the
link-layer addresses used to configure hardware filters.

Tested by sthen@@ and weerd@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.35 2013/10/18 09:04:02 mpi Exp $	*/
d131 1
a131 1
		if (rti->rti_ifp == inm->inm_ifp) {
d144 1
a144 1
	rti->rti_ifp = inm->inm_ifp;
d465 5
a469 1
	int i, s = splsoftnet();
d474 1
a474 2
	    inm->inm_ifp &&
	    (inm->inm_ifp->if_flags & IFF_LOOPBACK) == 0) {
d492 2
d495 2
a496 1
	int s = splsoftnet();
d502 1
a502 2
		    inm->inm_ifp &&
		    (inm->inm_ifp->if_flags & IFF_LOOPBACK) == 0)
d624 1
a624 1
	imo.imo_multicast_ifp = inm->inm_ifp;
@


1.35
log
@Abstract the fact that IPv4 muticast records are linked to the
interface descriptor throught the first configured address in the
global list, this will help reducing the size of future diffs.

No object change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.34 2013/10/14 11:07:42 mpi Exp $	*/
d86 1
d197 1
d271 4
a274 1
			IN_FOREACH_MULTI(ia, ifp, inm) {
d302 4
a305 1
			IN_FOREACH_MULTI(ia, ifp, inm) {
d490 2
d507 1
d535 1
a535 1
	struct in_ifaddr *ia;
d539 4
a542 1
	IN_FOREACH_MULTI(ia, ifp, inm) {
@


1.34
log
@Change the macros used to iterate over the multicast records of an
interface to not depend on the global list of addresses.

For IPv4 the IP_TO_IA() macro still depends on the global list of
addresses because we want to be sure to grab the first configured
address of an interface, where the records are linked.

Tested by sthen@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.33 2013/05/02 11:54:10 mpi Exp $	*/
d130 1
a130 1
		if (rti->rti_ifp == inm->inm_ia->ia_ifp) {
d143 1
a143 1
	rti->rti_ifp = inm->inm_ia->ia_ifp;
d462 2
a463 2
	    inm->inm_ia->ia_ifp &&
	    (inm->inm_ia->ia_ifp->if_flags & IFF_LOOPBACK) == 0) {
d486 2
a487 2
		    inm->inm_ia->ia_ifp &&
		    (inm->inm_ia->ia_ifp->if_flags & IFF_LOOPBACK) == 0)
d605 1
a605 1
	imo.imo_multicast_ifp = inm->inm_ia->ia_ifp;
@


1.33
log
@tedu broken Resource Reservation Protocol code that was ifdef RSVP_ISI.

ok deraadt@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.32 2013/04/10 08:50:59 mpi Exp $	*/
d107 1
a196 1
	struct in_multistep step;
d269 2
a270 4
			IN_FIRST_MULTI(step, inm);
			while (inm != NULL) {
				if (inm->inm_ia->ia_ifp == ifp &&
				    inm->inm_timer == 0 &&
a276 1
				IN_NEXT_MULTI(step, inm);
d297 2
a298 4
			IN_FIRST_MULTI(step, inm);
			while (inm != NULL) {
				if (inm->inm_ia->ia_ifp == ifp &&
				    !IN_LOCAL_GROUP(inm->inm_addr.s_addr) &&
a320 1
				IN_NEXT_MULTI(step, inm);
d502 1
a502 2
	struct in_multi *inm;
	struct in_multistep step;
d514 15
a528 2
	IN_FIRST_MULTI(step, inm);
	while (inm != NULL) {
a543 1
		IN_NEXT_MULTI(step, inm);
a544 1
	splx(s);
@


1.32
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.31 2010/04/20 22:05:43 tedu Exp $	*/
d603 1
a603 3
#ifdef RSVP_ISI
	imo.imo_multicast_vif = -1;
#endif
@


1.31
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.30 2010/01/13 01:26:28 henning Exp $	*/
a565 3
#ifdef MROUTING
	extern struct socket *ip_mrouter;
#endif /* MROUTING */
@


1.30
log
@let's admit it's not 1992 any more. CIDR is around for a long time, even
that router vendor doesn't default to classful routing any more, and there
really is no point in having a classful netmask and a subnetmask to split
it. we still do classful guesses on the netmask if it isn't supplied by
userland, but that's about it.
i decided to keep ia_netmask and kill ia_subnetmask which makes this diff
bigish, the classful ia_netmask wasn't really used all that much. the real
changes are in in.c, the rest is mostly s/ia_subnetmask/ia_netmask.
ok claudio dlg ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.29 2009/12/15 13:28:23 jsing Exp $	*/
d82 1
@


1.29
log
@Ensure that the interface is valid before trying to access its flags.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.28 2009/12/15 13:23:53 jsing Exp $	*/
d356 1
a356 1
				ip->ip_src.s_addr = ia->ia_subnet;
d424 1
a424 1
				ip->ip_src.s_addr = ia->ia_subnet;
@


1.28
log
@Ansify function declarations.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.27 2009/12/15 11:35:54 jsing Exp $	*/
d467 1
@


1.27
log
@Ensure that the interface is not null before trying to access its flags.
Fixes PR6274.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.25 2007/12/13 20:47:57 millert Exp $	*/
d111 1
a111 1
igmp_init()
d123 1
a123 2
rti_fill(inm)
	struct in_multi *inm;
d150 1
a150 2
rti_find(ifp)
	struct ifnet *ifp;
d171 1
a171 2
rti_delete(ifp)
	struct ifnet *ifp;
d460 1
a460 2
igmp_joingroup(inm)
	struct in_multi *inm;
d483 1
a483 2
igmp_leavegroup(inm)
	struct in_multi *inm;
d504 1
a504 1
igmp_fasttimo()
d542 1
a542 1
igmp_slowtimo()
d558 1
a558 4
igmp_sendpkt(inm, type, addr)
	struct in_multi *inm;
	int type;
	in_addr_t addr;
@


1.26
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d495 1
@


1.25
log
@Add missing license.  This file is 4.4BSD-derived with WIDE changes.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.24 2007/07/20 19:00:35 claudio Exp $	*/
d82 1
d100 2
d628 26
@


1.24
log
@Remove inm_ifp from struct in_multi -- caching struct ifnet is dangerous
because interfaces may disappear without notice causing use after free bugs.
Instead use the inm_ia->ia_ifp as a hint, struct in_ifaddr correctly tracks
removals of interfaces and invalidates ia_ifp in such cases.
looks good henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.23 2007/05/27 20:05:37 dlg Exp $	*/
d3 64
@


1.23
log
@-static
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.22 2005/09/19 06:40:01 krw Exp $	*/
d62 1
a62 1
		if (rti->rti_ifp == inm->inm_ifp) {
d75 1
a75 1
	rti->rti_ifp = inm->inm_ifp;
d206 1
a206 1
				if (inm->inm_ifp == ifp &&
d237 1
a237 1
				if (inm->inm_ifp == ifp &&
d404 1
a404 1
	    (inm->inm_ifp->if_flags & IFF_LOOPBACK) == 0) {
d428 1
a428 1
		    (inm->inm_ifp->if_flags & IFF_LOOPBACK) == 0)
d542 1
a542 1
	imo.imo_multicast_ifp = inm->inm_ifp;
@


1.22
log
@A few 'demon' -> 'daemon'.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.21 2004/05/23 01:59:10 deraadt Exp $	*/
d40 2
a41 2
static int rti_fill(struct in_multi *);
static struct router_info * rti_find(struct ifnet *);
d55 1
a55 1
static int
d83 1
a83 1
static struct router_info *
@


1.21
log
@missing splx; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.20 2004/01/03 14:08:53 espie Exp $	*/
d549 1
a549 1
	 * router, so that the process-level routing demon can hear it.
@


1.20
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.19 2003/12/10 07:22:43 itojun Exp $	*/
d405 2
a406 1
		if ((i = rti_fill(inm)) == -1)
d408 1
@


1.19
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.18 2003/07/09 22:03:16 itojun Exp $	*/
d31 1
a31 1
#include <machine/stdarg.h>
@


1.18
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.17 2003/02/12 14:41:07 jason Exp $	*/
d59 1
a59 1
	register struct router_info *rti;
d87 1
a87 1
	register struct router_info *rti;
d124 6
a129 6
	register int iphlen;
	register struct ifnet *ifp = m->m_pkthdr.rcvif;
	register struct ip *ip = mtod(m, struct ip *);
	register struct igmp *igmp;
	register int igmplen;
	register int minlen;
d133 1
a133 1
	register struct in_ifaddr *ia;
d441 1
a441 1
	register struct in_multi *inm;
d479 1
a479 1
	register struct router_info *rti;
@


1.17
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.16 2002/08/28 15:43:03 pefo Exp $	*/
d143 1
a143 1
	igmplen = ip->ip_len;
d519 1
a519 1
	ip->ip_len = sizeof(struct ip) + IGMP_MINLEN;
@


1.16
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.15 2002/06/09 16:26:10 itojun Exp $	*/
d37 1
@


1.15
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.14 2002/03/15 18:19:52 millert Exp $	*/
d555 1
a555 1
	    &imo, NULL);
@


1.14
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.13 2002/03/14 01:27:11 millert Exp $	*/
d427 2
a428 2
 				igmp_sendpkt(inm, IGMP_HOST_LEAVE_MESSAGE, 
 				    INADDR_ALLROUTERS_GROUP);
d495 1
a495 1
 	in_addr_t addr;
d522 5
a526 5
 	if (addr) {
 		ip->ip_dst.s_addr = addr;
 	} else {
 		ip->ip_dst = inm->inm_addr;
 	}
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.12 2001/11/06 21:26:33 jakob Exp $	*/
a120 1
#if __STDC__
a121 5
#else
igmp_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.12
log
@send igmp v2 leave messages to allrouters address (PR#2164)
patch based on parts from NetBSD submitted by goeran@@cdg.chalmers.se
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.11 2001/06/08 03:53:45 angelos Exp $	*/
d38 3
a40 3
void igmp_sendpkt __P((struct in_multi *, int, in_addr_t));
static int rti_fill __P((struct in_multi *));
static struct router_info * rti_find __P((struct ifnet *));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.12 2001/11/06 21:26:33 jakob Exp $	*/
d38 3
a40 3
void igmp_sendpkt(struct in_multi *, int, in_addr_t);
static int rti_fill(struct in_multi *);
static struct router_info * rti_find(struct ifnet *);
d121 1
d123 5
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.12.2.1 2002/06/11 03:31:36 art Exp $	*/
d427 2
a428 2
				igmp_sendpkt(inm, IGMP_HOST_LEAVE_MESSAGE,
				    INADDR_ALLROUTERS_GROUP);
d495 1
a495 1
	in_addr_t addr;
d522 5
a526 5
	if (addr) {
		ip->ip_dst.s_addr = addr;
	} else {
		ip->ip_dst = inm->inm_addr;
	}
d555 1
a555 1
	    &imo, (void *)NULL);
@


1.12.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 1
struct igmpstat igmpstat;
@


1.11
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.10 2001/05/24 04:07:51 angelos Exp $	*/
d38 1
a38 1
void igmp_sendpkt __P((struct in_multi *, int));
d412 1
a412 1
		igmp_sendpkt(inm, i);
d433 2
a434 1
				igmp_sendpkt(inm, IGMP_HOST_LEAVE_MESSAGE);
d467 1
a467 1
					    IGMP_v1_HOST_MEMBERSHIP_REPORT);
d470 1
a470 1
					    IGMP_v2_HOST_MEMBERSHIP_REPORT);
d498 1
a498 1
igmp_sendpkt(inm, type)
d501 1
d528 5
a532 1
	ip->ip_dst = inm->inm_addr;
@


1.10
log
@Check return values (tedu@@heorot.stanford.edu)
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.9 2001/05/11 17:20:11 aaron Exp $	*/
a17 1
#include <sys/systm.h>
@


1.9
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.8 2000/04/25 19:05:43 aaron Exp $	*/
d54 1
d73 2
d96 2
d191 4
d405 1
a405 1
	int s = splsoftnet();
d411 3
a413 1
		igmp_sendpkt(inm, rti_fill(inm));
@


1.8
log
@Avoid divide-by-zero; from FreeBSD PR/8990 and NetBSD PR/6541. Use the same fix
for now, at least until we determine if there is a more correct one.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.7 1999/12/28 07:17:38 itojun Exp $	*/
d156 1
a156 1
	    (m = m_pullup(m, minlen)) == 0) {
@


1.7
log
@remove non-effective kame patch.  openbsd ip_input() passes
different thing to the upper-layers than other KAME/*BSD does
(additional NULL pointer and "0"), so live with that.

(sync with kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.6 1999/12/08 06:50:19 itojun Exp $	*/
d221 2
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.8 2000/04/25 19:05:43 aaron Exp $	*/
a220 2
			if (timer == 0)
				timer = 1;
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.7.2.1 2001/05/14 22:40:07 niklas Exp $	*/
d18 1
a53 1
/* Return -1 for error. */
a71 2
	if (rti == NULL)
		return (-1);
a92 2
	if (rti == NULL)
		return (NULL);
d156 1
a156 1
	    (m = m_pullup(m, minlen)) == NULL) {
a185 4
			if (rti == NULL) {
				m_freem(m);
				return;
			}
d396 1
a396 1
	int i, s = splsoftnet();
d402 1
a402 3
		if ((i = rti_fill(inm)) == -1)
			return;
		igmp_sendpkt(inm, i);
@


1.7.2.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
void igmp_sendpkt __P((struct in_multi *, int, in_addr_t));
d412 1
a412 1
		igmp_sendpkt(inm, i, 0);
d433 1
a433 2
 				igmp_sendpkt(inm, IGMP_HOST_LEAVE_MESSAGE, 
 				    INADDR_ALLROUTERS_GROUP);
d466 1
a466 1
					    IGMP_v1_HOST_MEMBERSHIP_REPORT, 0);
d469 1
a469 1
					    IGMP_v2_HOST_MEMBERSHIP_REPORT, 0);
d497 1
a497 1
igmp_sendpkt(inm, type, addr)
a499 1
 	in_addr_t addr;
d526 1
a526 5
 	if (addr) {
 		ip->ip_dst.s_addr = addr;
 	} else {
 		ip->ip_dst = inm->inm_addr;
 	}
@


1.7.2.4
log
@Merge in -current from roughly a week ago
@
text
@d38 3
a40 3
void igmp_sendpkt(struct in_multi *, int, in_addr_t);
static int rti_fill(struct in_multi *);
static struct router_info * rti_find(struct ifnet *);
d121 1
d123 5
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@a36 1
struct igmpstat igmpstat;
d427 2
a428 2
				igmp_sendpkt(inm, IGMP_HOST_LEAVE_MESSAGE,
				    INADDR_ALLROUTERS_GROUP);
d495 1
a495 1
	in_addr_t addr;
d522 5
a526 5
	if (addr) {
		ip->ip_dst.s_addr = addr;
	} else {
		ip->ip_dst = inm->inm_addr;
	}
d555 1
a555 1
	    &imo, (void *)NULL);
@


1.7.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d31 1
a31 1
#include <sys/stdarg.h>
d59 1
a59 1
	struct router_info *rti;
d87 1
a87 1
	struct router_info *rti;
d124 6
a129 6
	int iphlen;
	struct ifnet *ifp = m->m_pkthdr.rcvif;
	struct ip *ip = mtod(m, struct ip *);
	struct igmp *igmp;
	int igmplen;
	int minlen;
d133 1
a133 1
	struct in_ifaddr *ia;
d143 1
a143 1
	igmplen = ntohs(ip->ip_len) - iphlen;
d441 1
a441 1
	struct in_multi *inm;
d479 1
a479 1
	struct router_info *rti;
d519 1
a519 1
	ip->ip_len = htons(sizeof(struct ip) + IGMP_MINLEN);
@


1.7.2.7
log
@Merge with the trunk
@
text
@d405 1
a405 2
		if ((i = rti_fill(inm)) == -1) {
			splx(s);
a406 1
		}
@


1.6
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.5 1999/08/08 00:43:00 niklas Exp $	*/
a4 29
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
a124 1
	int proto;
a139 1
	proto = va_arg(ap, int);
d387 1
a387 2
	rip_input(m, iphlen, proto);
	return;
a541 3
#if 0 /*KAME IPSEC*/
	m->m_pkthdr.rcvif = NULL;
#endif /*IPSEC*/
@


1.5
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.4 1998/05/18 21:10:24 provos Exp $	*/
d5 29
d154 1
d170 1
d418 2
a419 1
	rip_input(m);
d574 3
@


1.4
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.3 1997/02/05 15:48:21 deraadt Exp $	*/
d98 16
@


1.3
log
@use arc4random()
@
text
@d1 1
a1 1
/*	$OpenBSD: igmp.c,v 1.2 1996/03/03 22:30:26 niklas Exp $	*/
d527 1
a527 1
	    &imo);
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: igmp.c,v 1.14 1995/08/12 23:59:31 mycroft Exp $	*/
d18 1
d31 2
d39 2
d100 8
a107 2
igmp_input(m, iphlen)
	register struct mbuf *m;
a108 1
{
d119 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
