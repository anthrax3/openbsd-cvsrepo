head	1.311;
access;
symbols
	OPENBSD_6_1:1.304.0.4
	OPENBSD_6_1_BASE:1.304
	OPENBSD_6_0:1.293.0.4
	OPENBSD_6_0_BASE:1.293
	OPENBSD_5_9:1.287.0.2
	OPENBSD_5_9_BASE:1.287
	OPENBSD_5_8:1.264.0.4
	OPENBSD_5_8_BASE:1.264
	OPENBSD_5_7:1.247.0.2
	OPENBSD_5_7_BASE:1.247
	OPENBSD_5_6:1.233.0.4
	OPENBSD_5_6_BASE:1.233
	OPENBSD_5_5:1.222.0.4
	OPENBSD_5_5_BASE:1.222
	OPENBSD_5_4:1.209.0.2
	OPENBSD_5_4_BASE:1.209
	OPENBSD_5_3:1.198.0.2
	OPENBSD_5_3_BASE:1.198
	OPENBSD_5_2:1.195.0.2
	OPENBSD_5_2_BASE:1.195
	OPENBSD_5_1_BASE:1.194
	OPENBSD_5_1:1.194.0.2
	OPENBSD_5_0:1.189.0.2
	OPENBSD_5_0_BASE:1.189
	OPENBSD_4_9:1.180.0.2
	OPENBSD_4_9_BASE:1.180
	OPENBSD_4_8:1.177.0.2
	OPENBSD_4_8_BASE:1.177
	OPENBSD_4_7:1.174.0.2
	OPENBSD_4_7_BASE:1.174
	OPENBSD_4_6:1.171.0.4
	OPENBSD_4_6_BASE:1.171
	OPENBSD_4_5:1.169.0.2
	OPENBSD_4_5_BASE:1.169
	OPENBSD_4_4:1.167.0.2
	OPENBSD_4_4_BASE:1.167
	OPENBSD_4_3:1.162.0.2
	OPENBSD_4_3_BASE:1.162
	OPENBSD_4_2:1.147.0.2
	OPENBSD_4_2_BASE:1.147
	OPENBSD_4_1:1.132.0.2
	OPENBSD_4_1_BASE:1.132
	OPENBSD_4_0:1.130.0.2
	OPENBSD_4_0_BASE:1.130
	OPENBSD_3_9:1.119.0.2
	OPENBSD_3_9_BASE:1.119
	OPENBSD_3_8:1.109.0.2
	OPENBSD_3_8_BASE:1.109
	OPENBSD_3_7:1.104.0.2
	OPENBSD_3_7_BASE:1.104
	OPENBSD_3_6:1.62.0.2
	OPENBSD_3_6_BASE:1.62
	SMP_SYNC_A:1.60
	SMP_SYNC_B:1.58
	OPENBSD_3_5:1.44.0.2
	OPENBSD_3_5_BASE:1.44
	SMP:1.35.0.2;
locks; strict;
comment	@ * @;


1.311
date	2017.05.28.12.47.24;	author mpi;	state Exp;
branches;
next	1.310;
commitid	422EjxONeq6JrEUF;

1.310
date	2017.05.27.21.55.52;	author bluhm;	state Exp;
branches;
next	1.309;
commitid	3LzEIrgsQBypB5s1;

1.309
date	2017.05.04.17.58.46;	author bluhm;	state Exp;
branches;
next	1.308;
commitid	Q1XaPbKgEyYyAOP7;

1.308
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.307;
commitid	00hB28wQPwG5Ysk0;

1.307
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.306;
commitid	zztPc3QpQPdWwQ6h;

1.306
date	2017.04.09.17.57.58;	author dhill;	state Exp;
branches;
next	1.305;
commitid	eRsveMbENOTEvu0s;

1.305
date	2017.04.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.304;
commitid	4O5LUh13nIhVt6oZ;

1.304
date	2017.03.23.14.12.46;	author bluhm;	state Exp;
branches;
next	1.303;
commitid	U5EDrCL99VK1yXLK;

1.303
date	2017.03.17.17.06.25;	author mpi;	state Exp;
branches;
next	1.302;
commitid	xlqzkINBcZE6vQcn;

1.302
date	2017.02.20.06.29.42;	author jca;	state Exp;
branches;
next	1.301;
commitid	z4VhCYQTCyPI8KSQ;

1.301
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.300;
commitid	3e3CkrbYekyVOcxy;

1.300
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.299;
commitid	pVtptbHA3yk4jSpN;

1.299
date	2017.01.23.11.37.29;	author mpi;	state Exp;
branches;
next	1.298;
commitid	F6oNrr9LCLUSAxgA;

1.298
date	2016.12.20.14.30.52;	author mpi;	state Exp;
branches;
next	1.297;
commitid	d6abO7If3L0YmVNI;

1.297
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.296;
commitid	QqHqT2WhCBWqYgGJ;

1.296
date	2016.11.20.11.40.58;	author mpi;	state Exp;
branches;
next	1.295;
commitid	3UWH2O8lhF8HTUbi;

1.295
date	2016.10.25.07.21.02;	author yasuoka;	state Exp;
branches;
next	1.294;
commitid	bIjoLULyGIy8m1PG;

1.294
date	2016.10.04.13.54.32;	author mpi;	state Exp;
branches;
next	1.293;
commitid	QtKIaSOt6xUiLgI5;

1.293
date	2016.07.25.16.44.04;	author benno;	state Exp;
branches;
next	1.292;
commitid	SFUxeHnw3UBJZKgn;

1.292
date	2016.07.19.16.08.46;	author mpi;	state Exp;
branches;
next	1.291;
commitid	qhqDWlHYC2rbHKDC;

1.291
date	2016.06.06.07.01.37;	author mpi;	state Exp;
branches;
next	1.290;
commitid	mnLuUpnr9sCjxcYm;

1.290
date	2016.05.30.12.56.16;	author mpi;	state Exp;
branches;
next	1.289;
commitid	w2c3aw3HqpCfD4Ru;

1.289
date	2016.05.18.03.46.03;	author dlg;	state Exp;
branches;
next	1.288;
commitid	q5zkugIMulsP5tHa;

1.288
date	2016.04.13.11.41.15;	author mpi;	state Exp;
branches;
next	1.287;
commitid	Xo6g1xk26RWDGcjJ;

1.287
date	2016.02.23.01.39.14;	author dlg;	state Exp;
branches;
next	1.286;
commitid	jBer7f94lwmNypE0;

1.286
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.285;
commitid	5qLGnZtXVLeqUvHc;

1.285
date	2016.01.12.09.22.01;	author mpi;	state Exp;
branches;
next	1.284;
commitid	SbAMQd4riaejalc4;

1.284
date	2015.12.19.11.19.35;	author mpi;	state Exp;
branches;
next	1.283;
commitid	fCX5KuNn3hpGxa6Z;

1.283
date	2015.12.03.16.27.32;	author mpi;	state Exp;
branches;
next	1.282;
commitid	wK6td35Fr7xdNzh3;

1.282
date	2015.11.18.13.53.59;	author mpi;	state Exp;
branches;
next	1.281;
commitid	ZQMHTobXPzXsynNo;

1.281
date	2015.11.12.05.46.45;	author dlg;	state Exp;
branches;
next	1.280;
commitid	kBAeY0Sgq84h2AmH;

1.280
date	2015.11.02.15.56.46;	author mpi;	state Exp;
branches;
next	1.279;
commitid	pQnlkAiMLUEKilkH;

1.279
date	2015.11.02.15.05.23;	author mpi;	state Exp;
branches;
next	1.278;
commitid	aK60XMOKqPFfSdCc;

1.278
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.277;
commitid	G2nTzngqgXpQqcJB;

1.277
date	2015.10.22.13.30.29;	author mpi;	state Exp;
branches;
next	1.276;
commitid	EHE1hTlKKSkaEqck;

1.276
date	2015.10.14.13.59.31;	author jsg;	state Exp;
branches;
next	1.275;
commitid	y5l6W5EA5y0viFqu;

1.275
date	2015.10.05.19.05.09;	author uebayasi;	state Exp;
branches;
next	1.274;
commitid	KaQeg2gqRFHdXmok;

1.274
date	2015.10.05.15.52.46;	author uebayasi;	state Exp;
branches;
next	1.273;
commitid	Jb3hy8KXZkqIykJt;

1.273
date	2015.09.28.08.36.24;	author mpi;	state Exp;
branches;
next	1.272;
commitid	wT9nmVgN3CsJH8u1;

1.272
date	2015.09.27.04.27.57;	author dlg;	state Exp;
branches;
next	1.271;
commitid	QfPlOSXMm3i6wGe4;

1.271
date	2015.09.12.20.51.35;	author dlg;	state Exp;
branches;
next	1.270;
commitid	sB3szoaa6BCFEQ98;

1.270
date	2015.09.12.09.57.20;	author dlg;	state Exp;
branches;
next	1.269;
commitid	D1q0jpDRnZdzwDYi;

1.269
date	2015.09.12.09.36.31;	author dlg;	state Exp;
branches;
next	1.268;
commitid	jA52IBAgeyYOiSB9;

1.268
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.267;
commitid	Cr0DVA7exR1t2zXg;

1.267
date	2015.09.10.16.41.30;	author mikeb;	state Exp;
branches;
next	1.266;
commitid	Dj2db8t0KelqURhl;

1.266
date	2015.09.10.15.09.16;	author dlg;	state Exp;
branches;
next	1.265;
commitid	IRH1E8PP0gNH68k5;

1.265
date	2015.09.10.13.32.19;	author dlg;	state Exp;
branches;
next	1.264;
commitid	JbEzJsyDrWqOW57C;

1.264
date	2015.07.02.09.40.03;	author mpi;	state Exp;
branches
	1.264.4.1;
next	1.263;
commitid	eKXa0TkOIth1tkBS;

1.263
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.262;
commitid	fE8TgA9vpwdUU5Wy;

1.262
date	2015.06.29.10.32.29;	author dlg;	state Exp;
branches;
next	1.261;
commitid	rqyNfIORa1UIJQnb;

1.261
date	2015.06.24.09.40.55;	author mpi;	state Exp;
branches;
next	1.260;
commitid	MVWrtktB46JRxFWT;

1.260
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.259;
commitid	h7z8lokZ0dFyuWpg;

1.259
date	2015.06.08.13.40.48;	author mpi;	state Exp;
branches;
next	1.258;
commitid	HBw1Z8jFgWtpRSr4;

1.258
date	2015.06.02.09.38.24;	author mpi;	state Exp;
branches;
next	1.257;
commitid	9P4LdKlfMy8SaZ0b;

1.257
date	2015.05.21.09.17.53;	author mpi;	state Exp;
branches;
next	1.256;
commitid	9XeSA2lcQ3MjEdm6;

1.256
date	2015.05.15.11.53.06;	author claudio;	state Exp;
branches;
next	1.255;
commitid	cCD2n7Cc79Kk6xSC;

1.255
date	2015.05.15.10.09.23;	author mpi;	state Exp;
branches;
next	1.254;
commitid	CJg5eNPoLtOoLGIT;

1.254
date	2015.04.28.14.51.50;	author mpi;	state Exp;
branches;
next	1.253;
commitid	7clLdkXI39KFOgvT;

1.253
date	2015.04.22.06.44.17;	author mpi;	state Exp;
branches;
next	1.252;
commitid	3LaHb9bBeHAf3R8W;

1.252
date	2015.04.21.09.35.32;	author mpi;	state Exp;
branches;
next	1.251;
commitid	PptJQGeUHomKVDAJ;

1.251
date	2015.04.15.15.16.17;	author mpi;	state Exp;
branches;
next	1.250;
commitid	PusA1zyWKpwQQ6dp;

1.250
date	2015.04.15.15.14.37;	author mpi;	state Exp;
branches;
next	1.249;
commitid	YUSOcBpJeNXoa36I;

1.249
date	2015.04.07.10.46.20;	author mpi;	state Exp;
branches;
next	1.248;
commitid	m3c6YErI0cVMQeYc;

1.248
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.247;
commitid	p4LJxGKbi0BU2cG6;

1.247
date	2015.03.04.10.59.52;	author mpi;	state Exp;
branches;
next	1.246;
commitid	D0H4KFTYLLe1DmFv;

1.246
date	2015.02.11.04.29.29;	author mpi;	state Exp;
branches;
next	1.245;
commitid	PmAAFUik5QhGs6pQ;

1.245
date	2015.01.21.11.20.48;	author mpi;	state Exp;
branches;
next	1.244;
commitid	8R8ig0RVEsD3SKrD;

1.244
date	2015.01.08.10.55.45;	author mpi;	state Exp;
branches;
next	1.243;
commitid	Cjb59W7atbeOh2IO;

1.243
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.242;
commitid	zhW8jJrfVCoAthrR;

1.242
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.241;
commitid	cYQY7jiay4SydLhD;

1.241
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.240;
commitid	Vq8oSnWLkf7dyy0N;

1.240
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.239;
commitid	t9FBKDfc4VDxpEy2;

1.239
date	2014.11.20.15.55.04;	author tedu;	state Exp;
branches;
next	1.238;
commitid	dQlDAqnjJpCZ1ssk;

1.238
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.237;
commitid	Z1vcFtHO8wRH0yRt;

1.237
date	2014.11.03.11.43.47;	author gerhard;	state Exp;
branches;
next	1.236;
commitid	DBXtFodhoX01AXXL;

1.236
date	2014.10.07.08.47.28;	author mpi;	state Exp;
branches;
next	1.235;
commitid	YwQD6dPTFjvxMtlw;

1.235
date	2014.09.28.14.26.42;	author reyk;	state Exp;
branches;
next	1.234;
commitid	Pl2nuIB0xYgbzXmS;

1.234
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.233;
commitid	ZqXwxwmeo3l29NOg;

1.233
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.232;
commitid	DQakU8LLWV6Iwx84;

1.232
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.231;
commitid	B4dZSbxas1X1IpXI;

1.231
date	2014.07.09.09.30.49;	author henning;	state Exp;
branches;
next	1.230;
commitid	Nnxg8ONtI4Ep9pUb;

1.230
date	2014.06.30.07.02.22;	author mpi;	state Exp;
branches;
next	1.229;
commitid	L17b5YBt1oJsQGtY;

1.229
date	2014.04.30.10.04.33;	author mpi;	state Exp;
branches;
next	1.228;

1.228
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.227;

1.227
date	2014.04.20.14.54.39;	author henning;	state Exp;
branches;
next	1.226;

1.226
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.225;

1.225
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.224;

1.224
date	2014.03.21.13.48.28;	author mpi;	state Exp;
branches;
next	1.223;

1.223
date	2014.03.18.10.47.34;	author mpi;	state Exp;
branches;
next	1.222;

1.222
date	2014.02.13.10.31.42;	author mpi;	state Exp;
branches;
next	1.221;

1.221
date	2014.02.07.22.22.37;	author stsp;	state Exp;
branches;
next	1.220;

1.220
date	2014.01.22.09.35.20;	author mpi;	state Exp;
branches;
next	1.219;

1.219
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.218;

1.218
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.217;

1.217
date	2013.11.28.09.36.37;	author mpi;	state Exp;
branches;
next	1.216;

1.216
date	2013.11.21.16.16.08;	author mpi;	state Exp;
branches;
next	1.215;

1.215
date	2013.10.28.12.33.32;	author mpi;	state Exp;
branches;
next	1.214;

1.214
date	2013.10.20.11.03.01;	author phessler;	state Exp;
branches;
next	1.213;

1.213
date	2013.10.19.16.09.53;	author bluhm;	state Exp;
branches;
next	1.212;

1.212
date	2013.10.19.09.23.59;	author bluhm;	state Exp;
branches;
next	1.211;

1.211
date	2013.10.17.16.27.43;	author bluhm;	state Exp;
branches;
next	1.210;

1.210
date	2013.08.12.06.24.28;	author bluhm;	state Exp;
branches;
next	1.209;

1.209
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.208;

1.208
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.207;

1.207
date	2013.06.18.09.23.33;	author mpi;	state Exp;
branches;
next	1.206;

1.206
date	2013.06.03.17.19.40;	author yasuoka;	state Exp;
branches;
next	1.205;

1.205
date	2013.06.02.15.03.32;	author yasuoka;	state Exp;
branches;
next	1.204;

1.204
date	2013.03.28.23.10.05;	author tedu;	state Exp;
branches;
next	1.203;

1.203
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.202;

1.202
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.201;

1.201
date	2013.03.26.13.19.26;	author mpi;	state Exp;
branches;
next	1.200;

1.200
date	2013.03.25.14.40.56;	author mpi;	state Exp;
branches;
next	1.199;

1.199
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.198;

1.198
date	2012.10.08.18.48.25;	author camield;	state Exp;
branches;
next	1.197;

1.197
date	2012.09.19.16.14.01;	author blambert;	state Exp;
branches;
next	1.196;

1.196
date	2012.09.19.15.31.23;	author henning;	state Exp;
branches;
next	1.195;

1.195
date	2012.04.11.17.42.53;	author mikeb;	state Exp;
branches;
next	1.194;

1.194
date	2011.11.19.13.54.53;	author mikeb;	state Exp;
branches;
next	1.193;

1.193
date	2011.10.30.20.38.55;	author mpf;	state Exp;
branches;
next	1.192;

1.192
date	2011.10.24.17.48.31;	author camield;	state Exp;
branches;
next	1.191;

1.191
date	2011.10.16.21.07.19;	author mpf;	state Exp;
branches;
next	1.190;

1.190
date	2011.09.06.16.00.22;	author mpf;	state Exp;
branches;
next	1.189;

1.189
date	2011.07.08.19.07.18;	author henning;	state Exp;
branches;
next	1.188;

1.188
date	2011.07.04.03.13.53;	author mpf;	state Exp;
branches;
next	1.187;

1.187
date	2011.07.04.00.37.00;	author mpf;	state Exp;
branches;
next	1.186;

1.186
date	2011.07.03.17.55.25;	author dhill;	state Exp;
branches;
next	1.185;

1.185
date	2011.07.03.17.37.48;	author claudio;	state Exp;
branches;
next	1.184;

1.184
date	2011.05.04.16.05.49;	author blambert;	state Exp;
branches;
next	1.183;

1.183
date	2011.04.29.12.36.31;	author mpf;	state Exp;
branches;
next	1.182;

1.182
date	2011.04.04.14.25.16;	author mikeb;	state Exp;
branches;
next	1.181;

1.181
date	2011.03.08.22.53.28;	author mpf;	state Exp;
branches;
next	1.180;

1.180
date	2010.12.21.14.59.14;	author claudio;	state Exp;
branches;
next	1.179;

1.179
date	2010.11.26.12.25.52;	author otto;	state Exp;
branches;
next	1.178;

1.178
date	2010.08.26.13.28.15;	author claudio;	state Exp;
branches;
next	1.177;

1.177
date	2010.08.02.10.30.00;	author matthew;	state Exp;
branches;
next	1.176;

1.176
date	2010.07.20.15.36.03;	author matthew;	state Exp;
branches;
next	1.175;

1.175
date	2010.04.25.17.38.53;	author mpf;	state Exp;
branches;
next	1.174;

1.174
date	2010.01.13.01.26.28;	author henning;	state Exp;
branches;
next	1.173;

1.173
date	2010.01.12.01.40.30;	author mpf;	state Exp;
branches;
next	1.172;

1.172
date	2010.01.12.01.02.02;	author claudio;	state Exp;
branches;
next	1.171;

1.171
date	2009.06.17.20.17.19;	author mpf;	state Exp;
branches;
next	1.170;

1.170
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.169;

1.169
date	2008.10.28.23.07.12;	author mpf;	state Exp;
branches;
next	1.168;

1.168
date	2008.09.03.08.37.51;	author mpf;	state Exp;
branches;
next	1.167;

1.167
date	2008.06.14.21.46.22;	author reyk;	state Exp;
branches;
next	1.166;

1.166
date	2008.06.13.23.29.31;	author mpf;	state Exp;
branches;
next	1.165;

1.165
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.164;

1.164
date	2008.05.07.05.14.21;	author claudio;	state Exp;
branches;
next	1.163;

1.163
date	2008.05.06.15.12.00;	author mcbride;	state Exp;
branches;
next	1.162;

1.162
date	2008.02.20.22.11.53;	author mpf;	state Exp;
branches;
next	1.161;

1.161
date	2008.02.05.22.57.30;	author mpf;	state Exp;
branches;
next	1.160;

1.160
date	2008.01.02.03.33.18;	author brad;	state Exp;
branches;
next	1.159;

1.159
date	2007.12.14.18.33.40;	author deraadt;	state Exp;
branches;
next	1.158;

1.158
date	2007.11.27.11.34.18;	author claudio;	state Exp;
branches;
next	1.157;

1.157
date	2007.11.26.17.26.25;	author chl;	state Exp;
branches;
next	1.156;

1.156
date	2007.11.22.02.04.14;	author henning;	state Exp;
branches;
next	1.155;

1.155
date	2007.11.22.01.21.40;	author mpf;	state Exp;
branches;
next	1.154;

1.154
date	2007.11.16.05.08.39;	author djm;	state Exp;
branches;
next	1.153;

1.153
date	2007.10.29.16.19.23;	author chl;	state Exp;
branches;
next	1.152;

1.152
date	2007.10.27.23.08.35;	author mpf;	state Exp;
branches;
next	1.151;

1.151
date	2007.09.24.11.17.20;	author claudio;	state Exp;
branches;
next	1.150;

1.150
date	2007.09.18.18.56.02;	author markus;	state Exp;
branches;
next	1.149;

1.149
date	2007.09.18.09.18.04;	author mpf;	state Exp;
branches;
next	1.148;

1.148
date	2007.09.03.06.10.54;	author joel;	state Exp;
branches;
next	1.147;

1.147
date	2007.06.23.16.15.26;	author reyk;	state Exp;
branches;
next	1.146;

1.146
date	2007.06.14.19.31.17;	author reyk;	state Exp;
branches;
next	1.145;

1.145
date	2007.06.13.04.55.49;	author claudio;	state Exp;
branches;
next	1.144;

1.144
date	2007.06.01.02.42.59;	author mpf;	state Exp;
branches;
next	1.143;

1.143
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.142;

1.142
date	2007.06.01.00.07.13;	author mpf;	state Exp;
branches;
next	1.141;

1.141
date	2007.05.29.18.21.19;	author claudio;	state Exp;
branches;
next	1.140;

1.140
date	2007.05.28.06.31.01;	author mcbride;	state Exp;
branches;
next	1.139;

1.139
date	2007.05.27.20.11.44;	author dlg;	state Exp;
branches;
next	1.138;

1.138
date	2007.05.26.17.13.31;	author jason;	state Exp;
branches;
next	1.137;

1.137
date	2007.05.06.12.20.04;	author henning;	state Exp;
branches;
next	1.136;

1.136
date	2007.05.04.12.39.39;	author henning;	state Exp;
branches;
next	1.135;

1.135
date	2007.03.27.21.58.16;	author mpf;	state Exp;
branches;
next	1.134;

1.134
date	2007.03.25.18.26.23;	author mpf;	state Exp;
branches;
next	1.133;

1.133
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.132;

1.132
date	2006.12.13.09.01.59;	author itojun;	state Exp;
branches
	1.132.2.1;
next	1.131;

1.131
date	2006.11.16.13.12.43;	author henning;	state Exp;
branches;
next	1.130;

1.130
date	2006.08.31.12.37.31;	author mcbride;	state Exp;
branches
	1.130.2.1;
next	1.129;

1.129
date	2006.08.28.17.29.53;	author mcbride;	state Exp;
branches;
next	1.128;

1.128
date	2006.08.16.09.40.52;	author mpf;	state Exp;
branches;
next	1.127;

1.127
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2006.06.02.19.53.12;	author mpf;	state Exp;
branches;
next	1.125;

1.125
date	2006.05.22.23.25.15;	author krw;	state Exp;
branches;
next	1.124;

1.124
date	2006.05.18.12.39.23;	author mpf;	state Exp;
branches;
next	1.123;

1.123
date	2006.03.26.14.54.01;	author camield;	state Exp;
branches;
next	1.122;

1.122
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.121;

1.121
date	2006.03.23.14.18.55;	author mcbride;	state Exp;
branches;
next	1.120;

1.120
date	2006.03.22.14.37.44;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2006.01.28.23.47.20;	author mpf;	state Exp;
branches;
next	1.118;

1.118
date	2005.11.29.09.57.44;	author mpf;	state Exp;
branches;
next	1.117;

1.117
date	2005.11.29.02.59.42;	author jolan;	state Exp;
branches;
next	1.116;

1.116
date	2005.11.27.16.22.45;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2005.11.27.10.58.06;	author mpf;	state Exp;
branches;
next	1.114;

1.114
date	2005.11.27.10.48.59;	author mcbride;	state Exp;
branches;
next	1.113;

1.113
date	2005.11.04.08.11.54;	author mcbride;	state Exp;
branches;
next	1.112;

1.112
date	2005.10.31.01.40.54;	author pascoe;	state Exp;
branches;
next	1.111;

1.111
date	2005.10.24.14.31.26;	author mcbride;	state Exp;
branches;
next	1.110;

1.110
date	2005.09.29.19.39.41;	author mpf;	state Exp;
branches;
next	1.109;

1.109
date	2005.08.31.04.49.21;	author mcbride;	state Exp;
branches
	1.109.2.1;
next	1.108;

1.108
date	2005.07.31.03.52.19;	author pascoe;	state Exp;
branches;
next	1.107;

1.107
date	2005.06.19.18.17.02;	author pascoe;	state Exp;
branches;
next	1.106;

1.106
date	2005.05.27.08.33.25;	author mpf;	state Exp;
branches;
next	1.105;

1.105
date	2005.04.20.23.00.41;	author mpf;	state Exp;
branches;
next	1.104;

1.104
date	2005.03.15.15.51.27;	author mcbride;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2005.03.13.18.26.29;	author pat;	state Exp;
branches;
next	1.102;

1.102
date	2005.03.05.13.33.49;	author mpf;	state Exp;
branches;
next	1.101;

1.101
date	2005.03.01.19.04.56;	author mcbride;	state Exp;
branches;
next	1.100;

1.100
date	2005.02.28.00.26.47;	author mcbride;	state Exp;
branches;
next	1.99;

1.99
date	2005.02.08.13.42.27;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2005.02.07.08.58.37;	author mcbride;	state Exp;
branches;
next	1.97;

1.97
date	2005.02.07.04.50.51;	author mcbride;	state Exp;
branches;
next	1.96;

1.96
date	2005.02.07.04.14.39;	author pascoe;	state Exp;
branches;
next	1.95;

1.95
date	2005.01.29.10.06.16;	author mcbride;	state Exp;
branches;
next	1.94;

1.94
date	2005.01.18.23.26.52;	author mpf;	state Exp;
branches;
next	1.93;

1.93
date	2005.01.06.21.45.35;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2005.01.06.09.29.21;	author mcbride;	state Exp;
branches;
next	1.91;

1.91
date	2005.01.06.00.46.58;	author pascoe;	state Exp;
branches;
next	1.90;

1.90
date	2005.01.06.00.41.51;	author pascoe;	state Exp;
branches;
next	1.89;

1.89
date	2005.01.04.10.30.00;	author pascoe;	state Exp;
branches;
next	1.88;

1.88
date	2004.12.22.06.04.33;	author pascoe;	state Exp;
branches;
next	1.87;

1.87
date	2004.12.19.23.44.03;	author mcbride;	state Exp;
branches;
next	1.86;

1.86
date	2004.12.19.03.25.37;	author mcbride;	state Exp;
branches;
next	1.85;

1.85
date	2004.12.18.00.52.21;	author pascoe;	state Exp;
branches;
next	1.84;

1.84
date	2004.12.17.21.40.04;	author mpf;	state Exp;
branches;
next	1.83;

1.83
date	2004.12.17.12.42.01;	author pascoe;	state Exp;
branches;
next	1.82;

1.82
date	2004.12.17.06.47.00;	author mcbride;	state Exp;
branches;
next	1.81;

1.81
date	2004.12.15.18.40.09;	author mcbride;	state Exp;
branches;
next	1.80;

1.80
date	2004.12.15.14.13.06;	author pat;	state Exp;
branches;
next	1.79;

1.79
date	2004.12.10.23.13.52;	author mcbride;	state Exp;
branches;
next	1.78;

1.78
date	2004.12.10.22.35.17;	author mcbride;	state Exp;
branches;
next	1.77;

1.77
date	2004.12.08.17.06.12;	author pat;	state Exp;
branches;
next	1.76;

1.76
date	2004.12.08.08.16.44;	author mcbride;	state Exp;
branches;
next	1.75;

1.75
date	2004.12.08.07.05.18;	author mcbride;	state Exp;
branches;
next	1.74;

1.74
date	2004.12.08.06.57.55;	author mcbride;	state Exp;
branches;
next	1.73;

1.73
date	2004.12.07.20.38.47;	author mcbride;	state Exp;
branches;
next	1.72;

1.72
date	2004.11.30.00.17.18;	author mcbride;	state Exp;
branches;
next	1.71;

1.71
date	2004.11.28.03.14.03;	author mcbride;	state Exp;
branches;
next	1.70;

1.70
date	2004.11.17.06.07.39;	author mcbride;	state Exp;
branches;
next	1.69;

1.69
date	2004.11.16.18.13.02;	author mcbride;	state Exp;
branches;
next	1.68;

1.68
date	2004.10.28.20.34.20;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2004.10.06.03.56.08;	author mcbride;	state Exp;
branches;
next	1.66;

1.66
date	2004.10.05.18.08.41;	author mcbride;	state Exp;
branches;
next	1.65;

1.65
date	2004.09.18.16.15.53;	author mcbride;	state Exp;
branches;
next	1.64;

1.64
date	2004.09.18.06.51.49;	author mcbride;	state Exp;
branches;
next	1.63;

1.63
date	2004.09.16.22.32.46;	author mcbride;	state Exp;
branches;
next	1.62;

1.62
date	2004.08.31.05.31.39;	author mcbride;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2004.06.24.19.35.25;	author tholo;	state Exp;
branches;
next	1.60;

1.60
date	2004.06.10.17.00.06;	author mcbride;	state Exp;
branches;
next	1.59;

1.59
date	2004.06.10.16.55.37;	author mcbride;	state Exp;
branches;
next	1.58;

1.58
date	2004.05.31.21.16.57;	author mpf;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.30.23.03.34;	author pvalchev;	state Exp;
branches;
next	1.56;

1.56
date	2004.05.29.08.44.21;	author mcbride;	state Exp;
branches;
next	1.55;

1.55
date	2004.05.29.04.33.27;	author mcbride;	state Exp;
branches;
next	1.54;

1.54
date	2004.05.25.02.32.07;	author jolan;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.24.18.54.47;	author mcbride;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.16.02.06.10;	author mcbride;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.16.00.24.45;	author mcbride;	state Exp;
branches;
next	1.50;

1.50
date	2004.05.13.08.21.18;	author mcbride;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.13.05.49.06;	author mcbride;	state Exp;
branches;
next	1.48;

1.48
date	2004.05.13.00.04.20;	author mcbride;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.10.02.18.52;	author mcbride;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.08.02.53.03;	author mcbride;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.28.00.28.43;	author mcbride;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.26.17.47.20;	author markus;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2004.03.26.08.31.58;	author mcbride;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.24.06.54.04;	author mcbride;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.24.06.13.56;	author mcbride;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.22.04.54.18;	author mcbride;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.20.11.01.35;	author mcbride;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.18.20.46.16;	author mcbride;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.10.21.36.47;	author mcbride;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.05.12.25.56;	author mcbride;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.18.12.22.39;	author markus;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2004.01.15.15.47.05;	author dhartmei;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.13.07.23.43;	author mcbride;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.06.14.40.33;	author grange;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.03.14.57.09;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.16.17.51.50;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.14.08.17.46;	author mcbride;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.09.08.56.55;	author mcbride;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.07.23.38.48;	author mcbride;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.07.22.04.46;	author mcbride;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.07.21.32.47;	author mcbride;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.05.06.39.48;	author mcbride;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.04.21.30.44;	author mcbride;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.04.18.10.41;	author mcbride;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.04.17.16.24;	author mcbride;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.04.03.19.22;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.04.02.52.40;	author mcbride;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.03.05.09.39;	author mcbride;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.03.03.19.27;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.03.00.55.57;	author mcbride;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.02.16.15.58;	author mcbride;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.31.09.00.32;	author mcbride;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.27.20.57.59;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.27.06.23.57;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.27.06.13.43;	author mcbride;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.25.12.06.59;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.23.23.00.37;	author mcbride;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.22.14.56.54;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.20.06.57.29;	author mcbride;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.20.03.01.01;	author mcbride;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.20.00.43.58;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.19.03.58.25;	author david;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.17.21.04.58;	author mcbride;	state Exp;
branches;
next	;

1.35.2.1
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2004.06.13.08.50.18;	author niklas;	state Exp;
branches;
next	;

1.44.2.1
date	2004.05.27.18.23.31;	author brad;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2004.11.06.02.37.03;	author brad;	state Exp;
branches;
next	;

1.62.2.1
date	2004.11.06.02.30.00;	author brad;	state Exp;
branches;
next	;

1.104.2.1
date	2005.12.18.04.24.05;	author brad;	state Exp;
branches;
next	;

1.109.2.1
date	2005.12.16.23.47.44;	author brad;	state Exp;
branches;
next	;

1.130.2.1
date	2007.04.30.20.40.25;	author ckuethe;	state Exp;
branches;
next	;

1.132.2.1
date	2007.04.30.20.39.44;	author ckuethe;	state Exp;
branches;
next	;

1.264.4.1
date	2016.02.08.21.57.46;	author bluhm;	state Exp;
branches;
next	1.264.4.2;
commitid	vOs7sTAbPIKohifz;

1.264.4.2
date	2016.02.09.17.24.15;	author bluhm;	state Exp;
branches;
next	;
commitid	SqCXEzkugz0qVfj5;


desc
@@


1.311
log
@Leaving IP multicast group requires the NET_LOCK().

Grab the lock before calling carpdetach().

ok bluhm@@
@
text
@/*	$OpenBSD: ip_carp.c,v 1.310 2017/05/27 21:55:52 bluhm Exp $	*/

/*
 * Copyright (c) 2002 Michael Shalayeff. All rights reserved.
 * Copyright (c) 2003 Ryan McBride. All rights reserved.
 * Copyright (c) 2006-2008 Marco Pfatschbacher. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * TODO:
 *	- iface reconfigure
 *	- support for hardware checksum calculations;
 *
 */

#include "ether.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/timeout.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/sysctl.h>
#include <sys/syslog.h>
#include <sys/refcnt.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/netisr.h>

#include <crypto/sha1.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/if_ether.h>
#include <netinet/ip_ipsp.h>

#include <net/if_dl.h>

#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet/icmp6.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/nd6.h>
#include <netinet6/in6_ifattach.h>
#endif

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include "vlan.h"
#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

#include <netinet/ip_carp.h>

struct carp_mc_entry {
	LIST_ENTRY(carp_mc_entry)	mc_entries;
	union {
		struct ether_multi	*mcu_enm;
	} mc_u;
	struct sockaddr_storage		mc_addr;
};
#define	mc_enm	mc_u.mcu_enm

enum { HMAC_ORIG=0, HMAC_NOV6LL=1, HMAC_MAX=2 };

struct carp_vhost_entry {
	SRPL_ENTRY(carp_vhost_entry) vhost_entries;
	struct refcnt vhost_refcnt;

	struct carp_softc *parent_sc;
	int vhe_leader;
	int vhid;
	int advskew;
	enum { INIT = 0, BACKUP, MASTER }	state;
	struct timeout ad_tmo;	/* advertisement timeout */
	struct timeout md_tmo;	/* master down timeout */
	struct timeout md6_tmo;	/* master down timeout */

	u_int64_t vhe_replay_cookie;

	/* authentication */
#define CARP_HMAC_PAD	64
	unsigned char vhe_pad[CARP_HMAC_PAD];
	SHA1_CTX vhe_sha1[HMAC_MAX];

	u_int8_t vhe_enaddr[ETHER_ADDR_LEN];
};

void	carp_vh_ref(void *, void *);
void	carp_vh_unref(void *, void *);

struct srpl_rc carp_vh_rc =
    SRPL_RC_INITIALIZER(carp_vh_ref, carp_vh_unref, NULL);

struct carp_softc {
	struct arpcom sc_ac;
#define	sc_if		sc_ac.ac_if
#define	sc_carpdev	sc_ac.ac_if.if_carpdev
	void *ah_cookie;
	void *lh_cookie;
	struct ip_moptions sc_imo;
#ifdef INET6
	struct ip6_moptions sc_im6o;
#endif /* INET6 */

	SRPL_ENTRY(carp_softc) sc_list;
	struct refcnt sc_refcnt;

	int sc_suppress;
	int sc_bow_out;
	int sc_demote_cnt;

	int sc_sendad_errors;
#define CARP_SENDAD_MAX_ERRORS(sc) (3 * (sc)->sc_vhe_count)
	int sc_sendad_success;
#define CARP_SENDAD_MIN_SUCCESS(sc) (3 * (sc)->sc_vhe_count)

	char sc_curlladdr[ETHER_ADDR_LEN];

	SRPL_HEAD(, carp_vhost_entry) carp_vhosts;
	int sc_vhe_count;
	u_int8_t sc_vhids[CARP_MAXNODES];
	u_int8_t sc_advskews[CARP_MAXNODES];
	u_int8_t sc_balancing;

	int sc_naddrs;
	int sc_naddrs6;
	int sc_advbase;		/* seconds */

	/* authentication */
	unsigned char sc_key[CARP_KEY_LEN];

	u_int32_t sc_hashkey[2];
	u_int32_t sc_lsmask;		/* load sharing mask */
	int sc_lscount;			/* # load sharing interfaces (max 32) */
	int sc_delayed_arp;		/* delayed ARP request countdown */
	int sc_realmac;			/* using real mac */

	struct in_addr sc_peer;

	LIST_HEAD(__carp_mchead, carp_mc_entry)	carp_mc_listhead;
	struct carp_vhost_entry *cur_vhe; /* current active vhe */
};

void	carp_sc_ref(void *, void *);
void	carp_sc_unref(void *, void *);

struct srpl_rc carp_sc_rc =
    SRPL_RC_INITIALIZER(carp_sc_ref, carp_sc_unref, NULL);

int carp_opts[CARPCTL_MAXID] = { 0, 1, 0, LOG_CRIT };	/* XXX for now */
struct cpumem *carpcounters;

int	carp_send_all_recur = 0;

struct carp_if {
	struct srpl vhif_vrs;
};

#define	CARP_LOG(l, sc, s)						\
	do {								\
		if (carp_opts[CARPCTL_LOG] >= l) {			\
			if (sc)						\
				log(l, "%s: ",				\
				    (sc)->sc_if.if_xname);		\
			else						\
				log(l, "carp: ");			\
			addlog s;					\
			addlog("\n");					\
		}							\
	} while (0)

void	carp_hmac_prepare(struct carp_softc *);
void	carp_hmac_prepare_ctx(struct carp_vhost_entry *, u_int8_t);
void	carp_hmac_generate(struct carp_vhost_entry *, u_int32_t *,
	    unsigned char *, u_int8_t);
int	carp_hmac_verify(struct carp_vhost_entry *, u_int32_t *,
	    unsigned char *);
int	carp_input(struct ifnet *, struct mbuf *, void *);
void	carp_proto_input_c(struct ifnet *, struct mbuf *,
	    struct carp_header *, int, sa_family_t);
int	carp_proto_input_if(struct ifnet *, struct mbuf **, int *, int);
#ifdef INET6
int	carp6_proto_input_if(struct ifnet *, struct mbuf **, int *, int);
#endif
void	carpattach(int);
void	carpdetach(struct carp_softc *);
int	carp_prepare_ad(struct mbuf *, struct carp_vhost_entry *,
	    struct carp_header *);
void	carp_send_ad_all(void);
void	carp_vhe_send_ad_all(struct carp_softc *);
void	carp_timer_ad(void *);
void	carp_send_ad(struct carp_vhost_entry *);
void	carp_send_arp(struct carp_softc *);
void	carp_timer_down(void *);
void	carp_master_down(struct carp_vhost_entry *);
int	carp_ioctl(struct ifnet *, u_long, caddr_t);
int	carp_vhids_ioctl(struct carp_softc *, struct carpreq *);
int	carp_check_dup_vhids(struct carp_softc *, struct carp_if *,
	    struct carpreq *);
void	carp_ifgroup_ioctl(struct ifnet *, u_long, caddr_t);
void	carp_ifgattr_ioctl(struct ifnet *, u_long, caddr_t);
void	carp_start(struct ifnet *);
void	carp_setrun_all(struct carp_softc *, sa_family_t);
void	carp_setrun(struct carp_vhost_entry *, sa_family_t);
void	carp_set_state_all(struct carp_softc *, int);
void	carp_set_state(struct carp_vhost_entry *, int);
void	carp_multicast_cleanup(struct carp_softc *);
int	carp_set_ifp(struct carp_softc *, struct ifnet *);
void	carp_set_enaddr(struct carp_softc *);
void	carp_set_vhe_enaddr(struct carp_vhost_entry *);
void	carp_addr_updated(void *);
int	carp_set_addr(struct carp_softc *, struct sockaddr_in *);
int	carp_join_multicast(struct carp_softc *);
#ifdef INET6
void	carp_send_na(struct carp_softc *);
int	carp_set_addr6(struct carp_softc *, struct sockaddr_in6 *);
int	carp_join_multicast6(struct carp_softc *);
#endif
int	carp_clone_create(struct if_clone *, int);
int	carp_clone_destroy(struct ifnet *);
int	carp_ether_addmulti(struct carp_softc *, struct ifreq *);
int	carp_ether_delmulti(struct carp_softc *, struct ifreq *);
void	carp_ether_purgemulti(struct carp_softc *);
int	carp_group_demote_count(struct carp_softc *);
void	carp_update_lsmask(struct carp_softc *);
int	carp_new_vhost(struct carp_softc *, int, int);
void	carp_destroy_vhosts(struct carp_softc *);
void	carp_del_all_timeouts(struct carp_softc *);

struct if_clone carp_cloner =
    IF_CLONE_INITIALIZER("carp", carp_clone_create, carp_clone_destroy);

#define carp_cksum(_m, _l)	((u_int16_t)in_cksum((_m), (_l)))
#define CARP_IFQ_PRIO	6

void
carp_hmac_prepare(struct carp_softc *sc)
{
	struct carp_vhost_entry *vhe;
	u_int8_t i;

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */

	SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts, vhost_entries) {
		for (i = 0; i < HMAC_MAX; i++) {
			carp_hmac_prepare_ctx(vhe, i);
		}
	}
}

void
carp_hmac_prepare_ctx(struct carp_vhost_entry *vhe, u_int8_t ctx)
{
	struct carp_softc *sc = vhe->parent_sc;

	u_int8_t version = CARP_VERSION, type = CARP_ADVERTISEMENT;
	u_int8_t vhid = vhe->vhid & 0xff;
	SHA1_CTX sha1ctx;
	u_int32_t kmd[5];
	struct ifaddr *ifa;
	int i, found;
	struct in_addr last, cur, in;
#ifdef INET6
	struct in6_addr last6, cur6, in6;
#endif /* INET6 */

	/* compute ipad from key */
	memset(vhe->vhe_pad, 0, sizeof(vhe->vhe_pad));
	bcopy(sc->sc_key, vhe->vhe_pad, sizeof(sc->sc_key));
	for (i = 0; i < sizeof(vhe->vhe_pad); i++)
		vhe->vhe_pad[i] ^= 0x36;

	/* precompute first part of inner hash */
	SHA1Init(&vhe->vhe_sha1[ctx]);
	SHA1Update(&vhe->vhe_sha1[ctx], vhe->vhe_pad, sizeof(vhe->vhe_pad));
	SHA1Update(&vhe->vhe_sha1[ctx], (void *)&version, sizeof(version));
	SHA1Update(&vhe->vhe_sha1[ctx], (void *)&type, sizeof(type));

	/* generate a key for the arpbalance hash, before the vhid is hashed */
	if (vhe->vhe_leader) {
		bcopy(&vhe->vhe_sha1[ctx], &sha1ctx, sizeof(sha1ctx));
		SHA1Final((unsigned char *)kmd, &sha1ctx);
		sc->sc_hashkey[0] = kmd[0] ^ kmd[1];
		sc->sc_hashkey[1] = kmd[2] ^ kmd[3];
	}

	/* the rest of the precomputation */
	if (!sc->sc_realmac && vhe->vhe_leader &&
	    memcmp(sc->sc_ac.ac_enaddr, vhe->vhe_enaddr, ETHER_ADDR_LEN) != 0)
		SHA1Update(&vhe->vhe_sha1[ctx], sc->sc_ac.ac_enaddr,
		    ETHER_ADDR_LEN);

	SHA1Update(&vhe->vhe_sha1[ctx], (void *)&vhid, sizeof(vhid));

	/* Hash the addresses from smallest to largest, not interface order */
	cur.s_addr = 0;
	do {
		found = 0;
		last = cur;
		cur.s_addr = 0xffffffff;
		TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET)
				continue;
			in.s_addr = ifatoia(ifa)->ia_addr.sin_addr.s_addr;
			if (ntohl(in.s_addr) > ntohl(last.s_addr) &&
			    ntohl(in.s_addr) < ntohl(cur.s_addr)) {
				cur.s_addr = in.s_addr;
				found++;
			}
		}
		if (found)
			SHA1Update(&vhe->vhe_sha1[ctx],
			    (void *)&cur, sizeof(cur));
	} while (found);
#ifdef INET6
	memset(&cur6, 0x00, sizeof(cur6));
	do {
		found = 0;
		last6 = cur6;
		memset(&cur6, 0xff, sizeof(cur6));
		TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			in6 = ifatoia6(ifa)->ia_addr.sin6_addr;
			if (IN6_IS_SCOPE_EMBED(&in6)) {
				if (ctx == HMAC_NOV6LL)
					continue;
				in6.s6_addr16[1] = 0;
			}
			if (memcmp(&in6, &last6, sizeof(in6)) > 0 &&
			    memcmp(&in6, &cur6, sizeof(in6)) < 0) {
				cur6 = in6;
				found++;
			}
		}
		if (found)
			SHA1Update(&vhe->vhe_sha1[ctx],
			    (void *)&cur6, sizeof(cur6));
	} while (found);
#endif /* INET6 */

	/* convert ipad to opad */
	for (i = 0; i < sizeof(vhe->vhe_pad); i++)
		vhe->vhe_pad[i] ^= 0x36 ^ 0x5c;
}

void
carp_hmac_generate(struct carp_vhost_entry *vhe, u_int32_t counter[2],
    unsigned char md[20], u_int8_t ctx)
{
	SHA1_CTX sha1ctx;

	/* fetch first half of inner hash */
	bcopy(&vhe->vhe_sha1[ctx], &sha1ctx, sizeof(sha1ctx));

	SHA1Update(&sha1ctx, (void *)counter, sizeof(vhe->vhe_replay_cookie));
	SHA1Final(md, &sha1ctx);

	/* outer hash */
	SHA1Init(&sha1ctx);
	SHA1Update(&sha1ctx, vhe->vhe_pad, sizeof(vhe->vhe_pad));
	SHA1Update(&sha1ctx, md, 20);
	SHA1Final(md, &sha1ctx);
}

int
carp_hmac_verify(struct carp_vhost_entry *vhe, u_int32_t counter[2],
    unsigned char md[20])
{
	unsigned char md2[20];
	u_int8_t i;

	for (i = 0; i < HMAC_MAX; i++) { 
		carp_hmac_generate(vhe, counter, md2, i);
		if (!timingsafe_bcmp(md, md2, sizeof(md2)))
			return (0);
	}
	return (1);
}

int
carp_proto_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct ifnet *ifp;

	ifp = if_get((*mp)->m_pkthdr.ph_ifidx);
	if (ifp == NULL) {
		m_freem(*mp);
		return IPPROTO_DONE;
	}

	proto = carp_proto_input_if(ifp, mp, offp, proto);
	if_put(ifp);
	return proto;
}

/*
 * process input packet.
 * we have rearranged checks order compared to the rfc,
 * but it seems more efficient this way or not possible otherwise.
 */
int
carp_proto_input_if(struct ifnet *ifp, struct mbuf **mp, int *offp, int proto)
{
	struct mbuf *m = *mp;
	struct ip *ip = mtod(m, struct ip *);
	struct carp_softc *sc = NULL;
	struct carp_header *ch;
	int iplen, len, ismulti;

	carpstat_inc(carps_ipackets);

	if (!carp_opts[CARPCTL_ALLOW]) {
		m_freem(m);
		return IPPROTO_DONE;
	}

	ismulti = IN_MULTICAST(ip->ip_dst.s_addr);

	/* check if received on a valid carp interface */
	if (!(ifp->if_type == IFT_CARP ||
	    (ifp->if_type != IFT_CARP && !ismulti && ifp->if_carp != NULL))) {
		carpstat_inc(carps_badif);
		CARP_LOG(LOG_INFO, sc,
		    ("packet received on non-carp interface: %s",
		     ifp->if_xname));
		m_freem(m);
		return IPPROTO_DONE;
	}

	/* verify that the IP TTL is 255.  */
	if (ip->ip_ttl != CARP_DFLTTL) {
		carpstat_inc(carps_badttl);
		CARP_LOG(LOG_NOTICE, sc, ("received ttl %d != %d on %s",
		    ip->ip_ttl, CARP_DFLTTL, ifp->if_xname));
		m_freem(m);
		return IPPROTO_DONE;
	}

	/*
	 * verify that the received packet length is
	 * equal to the CARP header
	 */
	iplen = ip->ip_hl << 2;
	len = iplen + sizeof(*ch);
	if (len > m->m_pkthdr.len) {
		carpstat_inc(carps_badlen);
		CARP_LOG(LOG_INFO, sc, ("packet too short %d on %s",
		    m->m_pkthdr.len, ifp->if_xname));
		m_freem(m);
		return IPPROTO_DONE;
	}

	if ((m = *mp = m_pullup(m, len)) == NULL) {
		carpstat_inc(carps_hdrops);
		return IPPROTO_DONE;
	}
	ip = mtod(m, struct ip *);
	ch = (struct carp_header *)(mtod(m, caddr_t) + iplen);

	/* verify the CARP checksum */
	m->m_data += iplen;
	if (carp_cksum(m, len - iplen)) {
		carpstat_inc(carps_badsum);
		CARP_LOG(LOG_INFO, sc, ("checksum failed on %s",
		    ifp->if_xname));
		m_freem(m);
		return IPPROTO_DONE;
	}
	m->m_data -= iplen;

	carp_proto_input_c(ifp, m, ch, ismulti, AF_INET);
	return IPPROTO_DONE;
}

#ifdef INET6
int
carp6_proto_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct ifnet *ifp;

	ifp = if_get((*mp)->m_pkthdr.ph_ifidx);
	if (ifp == NULL) {
		m_freem(*mp);
		return IPPROTO_DONE;
	}

	proto = carp6_proto_input_if(ifp, mp, offp, proto);
	if_put(ifp);
	return proto;
}

int
carp6_proto_input_if(struct ifnet *ifp, struct mbuf **mp, int *offp, int proto)
{
	struct mbuf *m = *mp;
	struct carp_softc *sc = NULL;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct carp_header *ch;
	u_int len;

	carpstat_inc(carps_ipackets6);

	if (!carp_opts[CARPCTL_ALLOW]) {
		m_freem(m);
		return IPPROTO_DONE;
	}

	/* check if received on a valid carp interface */
	if (ifp->if_type != IFT_CARP) {
		carpstat_inc(carps_badif);
		CARP_LOG(LOG_INFO, sc, ("packet received on non-carp interface: %s",
		    ifp->if_xname));
		m_freem(m);
		return IPPROTO_DONE;
	}

	/* verify that the IP TTL is 255 */
	if (ip6->ip6_hlim != CARP_DFLTTL) {
		carpstat_inc(carps_badttl);
		CARP_LOG(LOG_NOTICE, sc, ("received ttl %d != %d on %s",
		    ip6->ip6_hlim, CARP_DFLTTL, ifp->if_xname));
		m_freem(m);
		return IPPROTO_DONE;
	}

	/* verify that we have a complete carp packet */
	len = m->m_len;
	if ((m = *mp = m_pullup(m, *offp + sizeof(*ch))) == NULL) {
		carpstat_inc(carps_badlen);
		CARP_LOG(LOG_INFO, sc, ("packet size %u too small", len));
		return IPPROTO_DONE;
	}
	ch = (struct carp_header *)(mtod(m, caddr_t) + *offp);

	/* verify the CARP checksum */
	m->m_data += *offp;
	if (carp_cksum(m, sizeof(*ch))) {
		carpstat_inc(carps_badsum);
		CARP_LOG(LOG_INFO, sc, ("checksum failed, on %s",
		    ifp->if_xname));
		m_freem(m);
		return IPPROTO_DONE;
	}
	m->m_data -= *offp;

	carp_proto_input_c(ifp, m, ch, 1, AF_INET6);
	return IPPROTO_DONE;
}
#endif /* INET6 */

void
carp_proto_input_c(struct ifnet *ifp, struct mbuf *m, struct carp_header *ch,
    int ismulti, sa_family_t af)
{
	struct carp_softc *sc;
	struct carp_vhost_entry *vhe;
	struct timeval sc_tv, ch_tv;
	struct carp_if *cif;

	if (ifp->if_type == IFT_CARP)
		cif = (struct carp_if *)ifp->if_carpdev->if_carp;
	else
		cif = (struct carp_if *)ifp->if_carp;

	KERNEL_ASSERT_LOCKED(); /* touching vhif_vrs + carp_vhosts */
	SRPL_FOREACH_LOCKED(sc, &cif->vhif_vrs, sc_list) {
		if (af == AF_INET &&
		    ismulti != IN_MULTICAST(sc->sc_peer.s_addr))
			continue;
		SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts, vhost_entries) {
			if (vhe->vhid == ch->carp_vhid)
				goto found;
		}
	}
 found:

	if (!sc || (sc->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
	    (IFF_UP|IFF_RUNNING)) {
		carpstat_inc(carps_badvhid);
		m_freem(m);
		return;
	}

	getmicrotime(&sc->sc_if.if_lastchange);
	sc->sc_if.if_ipackets++;
	sc->sc_if.if_ibytes += m->m_pkthdr.len;

	/* verify the CARP version. */
	if (ch->carp_version != CARP_VERSION) {
		carpstat_inc(carps_badver);
		sc->sc_if.if_ierrors++;
		CARP_LOG(LOG_NOTICE, sc, ("invalid version %d != %d",
		    ch->carp_version, CARP_VERSION));
		m_freem(m);
		return;
	}

	/* verify the hash */
	if (carp_hmac_verify(vhe, ch->carp_counter, ch->carp_md)) {
		carpstat_inc(carps_badauth);
		sc->sc_if.if_ierrors++;
		CARP_LOG(LOG_INFO, sc, ("incorrect hash"));
		m_freem(m);
		return;
	}

	if (!memcmp(&vhe->vhe_replay_cookie, ch->carp_counter,
	    sizeof(ch->carp_counter))) {
		/* Do not log duplicates from non simplex interfaces */
		if (sc->sc_carpdev->if_flags & IFF_SIMPLEX) {
			carpstat_inc(carps_badauth);
			sc->sc_if.if_ierrors++;
			CARP_LOG(LOG_WARNING, sc,
			    ("replay or network loop detected"));
		}
		m_freem(m);
		return;
	}

	sc_tv.tv_sec = sc->sc_advbase;
	sc_tv.tv_usec = vhe->advskew * 1000000 / 256;
	ch_tv.tv_sec = ch->carp_advbase;
	ch_tv.tv_usec = ch->carp_advskew * 1000000 / 256;

	switch (vhe->state) {
	case INIT:
		break;
	case MASTER:
		/*
		 * If we receive an advertisement from a master who's going to
		 * be more frequent than us, and whose demote count is not higher
		 * than ours, go into BACKUP state. If his demote count is lower,
		 * also go into BACKUP.
		 */
		if (((timercmp(&sc_tv, &ch_tv, >) ||
		    timercmp(&sc_tv, &ch_tv, ==)) &&
		    (ch->carp_demote <= carp_group_demote_count(sc))) ||
		    ch->carp_demote < carp_group_demote_count(sc)) {
			timeout_del(&vhe->ad_tmo);
			carp_set_state(vhe, BACKUP);
			carp_setrun(vhe, 0);
		}
		break;
	case BACKUP:
		/*
		 * If we're pre-empting masters who advertise slower than us,
		 * and do not have a better demote count, treat them as down.
		 * 
		 */
		if (carp_opts[CARPCTL_PREEMPT] &&
		    timercmp(&sc_tv, &ch_tv, <) &&
		    ch->carp_demote >= carp_group_demote_count(sc)) {
			carp_master_down(vhe);
			break;
		}

		/*
		 * Take over masters advertising with a higher demote count,
		 * regardless of CARPCTL_PREEMPT.
		 */ 
		if (ch->carp_demote > carp_group_demote_count(sc)) {
			carp_master_down(vhe);
			break;
		}

		/*
		 *  If the master is going to advertise at such a low frequency
		 *  that he's guaranteed to time out, we'd might as well just
		 *  treat him as timed out now.
		 */
		sc_tv.tv_sec = sc->sc_advbase * 3;
		if (sc->sc_advbase && timercmp(&sc_tv, &ch_tv, <)) {
			carp_master_down(vhe);
			break;
		}

		/*
		 * Otherwise, we reset the counter and wait for the next
		 * advertisement.
		 */
		carp_setrun(vhe, af);
		break;
	}

	m_freem(m);
	return;
}

int
carp_sysctl_carpstat(void *oldp, size_t *oldlenp, void *newp)
{
	struct carpstats carpstat;

	CTASSERT(sizeof(carpstat) == (carps_ncounters * sizeof(uint64_t)));
	memset(&carpstat, 0, sizeof carpstat);
	counters_read(carpcounters, (uint64_t *)&carpstat, carps_ncounters);
	return (sysctl_rdstruct(oldp, oldlenp, newp,
	    &carpstat, sizeof(carpstat)));
}

int
carp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case CARPCTL_STATS:
		return (carp_sysctl_carpstat(oldp, oldlenp, newp));
	default:
		if (name[0] <= 0 || name[0] >= CARPCTL_MAXID)
			return (ENOPROTOOPT);
		return sysctl_int(oldp, oldlenp, newp, newlen,
		    &carp_opts[name[0]]);
	}
}

/*
 * Interface side of the CARP implementation.
 */

/* ARGSUSED */
void
carpattach(int n)
{
	struct ifg_group	*ifg;

	if ((ifg = if_creategroup("carp")) != NULL)
		ifg->ifg_refcnt++;	/* keep around even if empty */
	if_clone_attach(&carp_cloner);
	carpcounters = counters_alloc(carps_ncounters);
}

int
carp_clone_create(struct if_clone *ifc, int unit)
{
	struct carp_softc *sc;
	struct ifnet *ifp;

	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!sc)
		return (ENOMEM);

	refcnt_init(&sc->sc_refcnt);
	
	SRPL_INIT(&sc->carp_vhosts);
	sc->sc_vhe_count = 0;
	if (carp_new_vhost(sc, 0, 0)) {
		free(sc, M_DEVBUF, sizeof(*sc));
		return (ENOMEM);
	}

	sc->sc_suppress = 0;
	sc->sc_advbase = CARP_DFLTINTV;
	sc->sc_naddrs = sc->sc_naddrs6 = 0;
#ifdef INET6
	sc->sc_im6o.im6o_hlim = CARP_DFLTTL;
#endif /* INET6 */
	sc->sc_imo.imo_membership = (struct in_multi **)malloc(
	    (sizeof(struct in_multi *) * IP_MIN_MEMBERSHIPS), M_IPMOPTS,
	    M_WAITOK|M_ZERO);
	sc->sc_imo.imo_max_memberships = IP_MIN_MEMBERSHIPS;

	LIST_INIT(&sc->carp_mc_listhead);
	ifp = &sc->sc_if;
	ifp->if_softc = sc;
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name,
	    unit);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = carp_ioctl;
	ifp->if_start = carp_start;
	ifp->if_xflags = IFXF_CLONED;
	IFQ_SET_MAXLEN(&ifp->if_snd, 1);
	if_attach(ifp);
	ether_ifattach(ifp);
	ifp->if_type = IFT_CARP;
	ifp->if_sadl->sdl_type = IFT_CARP;
	ifp->if_output = carp_output;
	ifp->if_priority = IF_CARP_DEFAULT_PRIORITY;
	ifp->if_link_state = LINK_STATE_INVALID;

	/* Hook carp_addr_updated to cope with address and route changes. */
	sc->ah_cookie = hook_establish(sc->sc_if.if_addrhooks, 0,
	    carp_addr_updated, sc);

	return (0);
}

int
carp_new_vhost(struct carp_softc *sc, int vhid, int advskew)
{
	struct carp_vhost_entry *vhe, *vhe0;

	vhe = malloc(sizeof(*vhe), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (vhe == NULL)
		return (ENOMEM);

	refcnt_init(&vhe->vhost_refcnt);
	carp_sc_ref(NULL, sc); /* give a sc ref to the vhe */
	vhe->parent_sc = sc;
	vhe->vhid = vhid;
	vhe->advskew = advskew;
	vhe->state = INIT;
	timeout_set_proc(&vhe->ad_tmo, carp_timer_ad, vhe);
	timeout_set_proc(&vhe->md_tmo, carp_timer_down, vhe);
	timeout_set_proc(&vhe->md6_tmo, carp_timer_down, vhe);

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */

	/* mark the first vhe as leader */
	if (SRPL_EMPTY_LOCKED(&sc->carp_vhosts)) {
		vhe->vhe_leader = 1;
		SRPL_INSERT_HEAD_LOCKED(&carp_vh_rc, &sc->carp_vhosts,
		    vhe, vhost_entries);
		sc->sc_vhe_count = 1;
		return (0);
	}

	SRPL_FOREACH_LOCKED(vhe0, &sc->carp_vhosts, vhost_entries) {
		if (SRPL_NEXT_LOCKED(vhe0, vhost_entries) == NULL)
			break;
	}

	SRPL_INSERT_AFTER_LOCKED(&carp_vh_rc, vhe0, vhe, vhost_entries);
	sc->sc_vhe_count++;

	return (0);
}

int
carp_clone_destroy(struct ifnet *ifp)
{
	struct carp_softc *sc = ifp->if_softc;
	int s;

	NET_LOCK(s);
	carpdetach(sc);
	NET_UNLOCK(s);

	ether_ifdetach(ifp);
	if_detach(ifp);
	carp_destroy_vhosts(ifp->if_softc);
	refcnt_finalize(&sc->sc_refcnt, "carpdtor");
	free(sc->sc_imo.imo_membership, M_IPMOPTS, 0);
	free(sc, M_DEVBUF, sizeof(*sc));
	return (0);
}

void
carp_del_all_timeouts(struct carp_softc *sc)
{
	struct carp_vhost_entry *vhe;

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */
	SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts, vhost_entries) {
		timeout_del(&vhe->ad_tmo);
		timeout_del(&vhe->md_tmo);
		timeout_del(&vhe->md6_tmo);
	}
}

void
carpdetach(struct carp_softc *sc)
{
	struct ifnet *ifp0;
	struct carp_if *cif;

	carp_del_all_timeouts(sc);

	if (sc->sc_demote_cnt)
		carp_group_demote_adj(&sc->sc_if, -sc->sc_demote_cnt, "detach");
	sc->sc_suppress = 0;
	sc->sc_sendad_errors = 0;

	carp_set_state_all(sc, INIT);
	sc->sc_if.if_flags &= ~IFF_UP;
	carp_setrun_all(sc, 0);
	carp_multicast_cleanup(sc);

	if (sc->ah_cookie != NULL)
		hook_disestablish(sc->sc_if.if_addrhooks, sc->ah_cookie);

	ifp0 = sc->sc_carpdev;
	if (ifp0 == NULL)
		return;

	KERNEL_ASSERT_LOCKED(); /* touching vhif_vrs */

	cif = (struct carp_if *)ifp0->if_carp;

	/* Restore previous input handler. */
	if_ih_remove(ifp0, carp_input, cif);

	if (sc->lh_cookie != NULL)
		hook_disestablish(ifp0->if_linkstatehooks, sc->lh_cookie);

	SRPL_REMOVE_LOCKED(&carp_sc_rc, &cif->vhif_vrs, sc,
	    carp_softc, sc_list);
	if (SRPL_EMPTY_LOCKED(&cif->vhif_vrs)) {
		ifpromisc(ifp0, 0);
		ifp0->if_carp = NULL;
		free(cif, M_IFADDR, sizeof(*cif));
	}
	sc->sc_carpdev = NULL;
}

/* Detach an interface from the carp. */
void
carp_ifdetach(struct ifnet *ifp0)
{
	struct carp_softc *sc, *nextsc;
	struct carp_if *cif = (struct carp_if *)ifp0->if_carp;

	KERNEL_ASSERT_LOCKED(); /* touching vhif_vrs */

	SRPL_FOREACH_SAFE_LOCKED(sc, &cif->vhif_vrs, sc_list, nextsc)
		carpdetach(sc); /* this can free cif */
}

void
carp_destroy_vhosts(struct carp_softc *sc)
{
	/* XXX bow out? */
	struct carp_vhost_entry *vhe;

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */

	while ((vhe = SRPL_FIRST_LOCKED(&sc->carp_vhosts)) != NULL) {
		SRPL_REMOVE_LOCKED(&carp_vh_rc, &sc->carp_vhosts, vhe,
		    carp_vhost_entry, vhost_entries);
		carp_vh_unref(NULL, vhe); /* drop last ref */
	}
	sc->sc_vhe_count = 0;
}

int
carp_prepare_ad(struct mbuf *m, struct carp_vhost_entry *vhe,
    struct carp_header *ch)
{
	if (!vhe->vhe_replay_cookie) {
		arc4random_buf(&vhe->vhe_replay_cookie,
		    sizeof(vhe->vhe_replay_cookie));
	}

	bcopy(&vhe->vhe_replay_cookie, ch->carp_counter,
	    sizeof(ch->carp_counter));

	/*
	 * For the time being, do not include the IPv6 linklayer addresses
	 * in the HMAC.
	 */
	carp_hmac_generate(vhe, ch->carp_counter, ch->carp_md, HMAC_NOV6LL);

	return (0);
}

void
carp_send_ad_all(void)
{
	struct ifnet *ifp0;
	struct carp_if *cif;
	struct carp_softc *vh;

	KERNEL_ASSERT_LOCKED(); /* touching vhif_vrs */

	if (carp_send_all_recur > 0)
		return;
	++carp_send_all_recur;
	TAILQ_FOREACH(ifp0, &ifnet, if_list) {
		if (ifp0->if_carp == NULL || ifp0->if_type == IFT_CARP)
			continue;

		cif = (struct carp_if *)ifp0->if_carp;
		SRPL_FOREACH_LOCKED(vh, &cif->vhif_vrs, sc_list) {
			if ((vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
			    (IFF_UP|IFF_RUNNING)) {
				carp_vhe_send_ad_all(vh);
			}
		}
	}
	--carp_send_all_recur;
}

void
carp_vhe_send_ad_all(struct carp_softc *sc)
{
	struct carp_vhost_entry *vhe;

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */

	SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts, vhost_entries) {
		if (vhe->state == MASTER)
			carp_send_ad(vhe);
	}
}

void
carp_timer_ad(void *v)
{
	int s;

	NET_LOCK(s);
	carp_send_ad(v);
	NET_UNLOCK(s);
}

void
carp_send_ad(struct carp_vhost_entry *vhe)
{
	struct carp_header ch;
	struct timeval tv;
	struct carp_softc *sc = vhe->parent_sc;
	struct carp_header *ch_ptr;
	struct mbuf *m;
	int error, len, advbase, advskew;
	struct ifaddr *ifa;
	struct sockaddr sa;

	NET_ASSERT_LOCKED();

	if (sc->sc_carpdev == NULL) {
		sc->sc_if.if_oerrors++;
		return;
	}

	/* bow out if we've gone to backup (the carp interface is going down) */
	if (sc->sc_bow_out) {
		advbase = 255;
		advskew = 255;
	} else {
		advbase = sc->sc_advbase;
		advskew = vhe->advskew;
		tv.tv_sec = advbase;
		if (advbase == 0 && advskew == 0)
			tv.tv_usec = 1 * 1000000 / 256;
		else
			tv.tv_usec = advskew * 1000000 / 256;
	}

	ch.carp_version = CARP_VERSION;
	ch.carp_type = CARP_ADVERTISEMENT;
	ch.carp_vhid = vhe->vhid;
	ch.carp_demote = carp_group_demote_count(sc) & 0xff;
	ch.carp_advbase = advbase;
	ch.carp_advskew = advskew;
	ch.carp_authlen = 7;	/* XXX DEFINE */
	ch.carp_cksum = 0;

	sc->cur_vhe = vhe; /* we need the vhe later on the output path */

	if (sc->sc_naddrs) {
		struct ip *ip;

		MGETHDR(m, M_DONTWAIT, MT_HEADER);
		if (m == NULL) {
			sc->sc_if.if_oerrors++;
			carpstat_inc(carps_onomem);
			/* XXX maybe less ? */
			goto retry_later;
		}
		len = sizeof(*ip) + sizeof(ch);
		m->m_pkthdr.len = len;
		m->m_pkthdr.ph_ifidx = 0;
		m->m_pkthdr.ph_rtableid = sc->sc_if.if_rdomain;
		m->m_pkthdr.pf.prio = CARP_IFQ_PRIO;
		m->m_len = len;
		MH_ALIGN(m, m->m_len);
		ip = mtod(m, struct ip *);
		ip->ip_v = IPVERSION;
		ip->ip_hl = sizeof(*ip) >> 2;
		ip->ip_tos = IPTOS_LOWDELAY;
		ip->ip_len = htons(len);
		ip->ip_id = htons(ip_randomid());
		ip->ip_off = htons(IP_DF);
		ip->ip_ttl = CARP_DFLTTL;
		ip->ip_p = IPPROTO_CARP;
		ip->ip_sum = 0;

		memset(&sa, 0, sizeof(sa));
		sa.sa_family = AF_INET;
		/* Prefer addresses on the parent interface as source for AD. */
		ifa = ifaof_ifpforaddr(&sa, sc->sc_carpdev);
		if (ifa == NULL)
			ifa = ifaof_ifpforaddr(&sa, &sc->sc_if);
		KASSERT(ifa != NULL);
		ip->ip_src.s_addr = ifatoia(ifa)->ia_addr.sin_addr.s_addr;
		ip->ip_dst.s_addr = sc->sc_peer.s_addr;
		if (IN_MULTICAST(ip->ip_dst.s_addr))
			m->m_flags |= M_MCAST;

		ch_ptr = (struct carp_header *)(ip + 1);
		bcopy(&ch, ch_ptr, sizeof(ch));
		if (carp_prepare_ad(m, vhe, ch_ptr))
			goto retry_later;

		m->m_data += sizeof(*ip);
		ch_ptr->carp_cksum = carp_cksum(m, len - sizeof(*ip));
		m->m_data -= sizeof(*ip);

		getmicrotime(&sc->sc_if.if_lastchange);
		sc->sc_if.if_opackets++;
		sc->sc_if.if_obytes += len;
		carpstat_inc(carps_opackets);

		error = ip_output(m, NULL, NULL, IP_RAWOUTPUT, &sc->sc_imo,
		    NULL, 0);
		if (error) {
			if (error == ENOBUFS)
				carpstat_inc(carps_onomem);
			else
				CARP_LOG(LOG_WARNING, sc,
				    ("ip_output failed: %d", error));
			sc->sc_if.if_oerrors++;
			if (sc->sc_sendad_errors < INT_MAX)
				sc->sc_sendad_errors++;
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS(sc))
				carp_group_demote_adj(&sc->sc_if, 1,
				    "> snderrors");
			sc->sc_sendad_success = 0;
		} else {
			if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS(sc)) {
				if (++sc->sc_sendad_success >=
				    CARP_SENDAD_MIN_SUCCESS(sc)) {
					carp_group_demote_adj(&sc->sc_if, -1,
					    "< snderrors");
					sc->sc_sendad_errors = 0;
				}
			} else
				sc->sc_sendad_errors = 0;
		}
		if (vhe->vhe_leader) {
			if (sc->sc_delayed_arp > 0)
				sc->sc_delayed_arp--;
			if (sc->sc_delayed_arp == 0) {
				carp_send_arp(sc);
				sc->sc_delayed_arp = -1;
			}
		}
	}
#ifdef INET6
	if (sc->sc_naddrs6) {
		struct ip6_hdr *ip6;

		MGETHDR(m, M_DONTWAIT, MT_HEADER);
		if (m == NULL) {
			sc->sc_if.if_oerrors++;
			carpstat_inc(carps_onomem);
			/* XXX maybe less ? */
			goto retry_later;
		}
		len = sizeof(*ip6) + sizeof(ch);
		m->m_pkthdr.len = len;
		m->m_pkthdr.ph_ifidx = 0;
		m->m_pkthdr.pf.prio = CARP_IFQ_PRIO;
		m->m_pkthdr.ph_rtableid = sc->sc_if.if_rdomain;
		m->m_len = len;
		MH_ALIGN(m, m->m_len);
		m->m_flags |= M_MCAST;
		ip6 = mtod(m, struct ip6_hdr *);
		memset(ip6, 0, sizeof(*ip6));
		ip6->ip6_vfc |= IPV6_VERSION;
		ip6->ip6_hlim = CARP_DFLTTL;
		ip6->ip6_nxt = IPPROTO_CARP;

		/* set the source address */
		memset(&sa, 0, sizeof(sa));
		sa.sa_family = AF_INET6;
		/* Prefer addresses on the parent interface as source for AD. */
		ifa = ifaof_ifpforaddr(&sa, sc->sc_carpdev);
		if (ifa == NULL)
			ifa = ifaof_ifpforaddr(&sa, &sc->sc_if);
		KASSERT(ifa != NULL);
		bcopy(ifatoia6(ifa)->ia_addr.sin6_addr.s6_addr,
		    &ip6->ip6_src, sizeof(struct in6_addr));
		/* set the multicast destination */

		ip6->ip6_dst.s6_addr16[0] = htons(0xff02);
		ip6->ip6_dst.s6_addr16[1] = htons(sc->sc_carpdev->if_index);
		ip6->ip6_dst.s6_addr8[15] = 0x12;

		ch_ptr = (struct carp_header *)(ip6 + 1);
		bcopy(&ch, ch_ptr, sizeof(ch));
		if (carp_prepare_ad(m, vhe, ch_ptr))
			goto retry_later;

		m->m_data += sizeof(*ip6);
		ch_ptr->carp_cksum = carp_cksum(m, len - sizeof(*ip6));
		m->m_data -= sizeof(*ip6);

		getmicrotime(&sc->sc_if.if_lastchange);
		sc->sc_if.if_opackets++;
		sc->sc_if.if_obytes += len;
		carpstat_inc(carps_opackets6);

		error = ip6_output(m, NULL, NULL, 0, &sc->sc_im6o, NULL);
		if (error) {
			if (error == ENOBUFS)
				carpstat_inc(carps_onomem);
			else
				CARP_LOG(LOG_WARNING, sc,
				    ("ip6_output failed: %d", error));
			sc->sc_if.if_oerrors++;
			if (sc->sc_sendad_errors < INT_MAX)
				sc->sc_sendad_errors++;
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS(sc))
				carp_group_demote_adj(&sc->sc_if, 1,
					    "> snd6errors");
			sc->sc_sendad_success = 0;
		} else {
			if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS(sc)) {
				if (++sc->sc_sendad_success >=
				    CARP_SENDAD_MIN_SUCCESS(sc)) {
					carp_group_demote_adj(&sc->sc_if, -1,
					    "< snd6errors");
					sc->sc_sendad_errors = 0;
				}
			} else
				sc->sc_sendad_errors = 0;
		}
	}
#endif /* INET6 */

retry_later:
	sc->cur_vhe = NULL;
	if (advbase != 255 || advskew != 255)
		timeout_add(&vhe->ad_tmo, tvtohz(&tv));
}

/*
 * Broadcast a gratuitous ARP request containing
 * the virtual router MAC address for each IP address
 * associated with the virtual router.
 */
void
carp_send_arp(struct carp_softc *sc)
{
	struct ifaddr *ifa;
	in_addr_t in;

	TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {

		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;

		in = ifatoia(ifa)->ia_addr.sin_addr.s_addr;
		arprequest(&sc->sc_if, &in, &in, sc->sc_ac.ac_enaddr);
		DELAY(1000);	/* XXX */
	}
}

#ifdef INET6
void
carp_send_na(struct carp_softc *sc)
{
	struct ifaddr *ifa;
	struct in6_addr *in6;
	static struct in6_addr mcast = IN6ADDR_LINKLOCAL_ALLNODES_INIT;

	TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {

		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		in6 = &ifatoia6(ifa)->ia_addr.sin6_addr;
		nd6_na_output(&sc->sc_if, &mcast, in6,
		    ND_NA_FLAG_OVERRIDE |
		    (ip6_forwarding ? ND_NA_FLAG_ROUTER : 0), 1, NULL);
		DELAY(1000);	/* XXX */
	}
}
#endif /* INET6 */

void
carp_update_lsmask(struct carp_softc *sc)
{
	struct carp_vhost_entry *vhe;
	int count;

	if (sc->sc_balancing == CARP_BAL_NONE)
		return;

	sc->sc_lsmask = 0;
	count = 0;

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */
	SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts, vhost_entries) {
		if (vhe->state == MASTER && count < sizeof(sc->sc_lsmask) * 8)
			sc->sc_lsmask |= 1 << count;
		count++;
	}
	sc->sc_lscount = count;
	CARP_LOG(LOG_DEBUG, sc, ("carp_update_lsmask: %x", sc->sc_lsmask));
}

int
carp_iamatch(struct ifnet *ifp)
{
	struct carp_softc *sc = ifp->if_softc;
	struct carp_vhost_entry *vhe;
	struct srp_ref sr;
	int match = 0;

	vhe = SRPL_FIRST(&sr, &sc->carp_vhosts);
	if (vhe->state == MASTER)
		match = 1;
	SRPL_LEAVE(&sr);

	return (match);
}

#ifdef INET6
int
carp_iamatch6(struct ifnet *ifp)
{
	struct carp_softc *sc = ifp->if_softc;
	struct carp_vhost_entry *vhe = SRPL_FIRST_LOCKED(&sc->carp_vhosts);

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */

	if (vhe->state == MASTER)
		return (1);

	return (0);
}
#endif /* INET6 */

struct ifnet *
carp_ourether(void *v, u_int8_t *ena)
{
	struct carp_if *cif = (struct carp_if *)v;
	struct carp_softc *vh;

	KERNEL_ASSERT_LOCKED(); /* touching vhif_vrs + carp_vhosts */

	SRPL_FOREACH_LOCKED(vh, &cif->vhif_vrs, sc_list) {
		struct carp_vhost_entry *vhe;
		if ((vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			continue;
		vhe = SRPL_FIRST_LOCKED(&vh->carp_vhosts);
		if ((vhe->state == MASTER || vh->sc_balancing >= CARP_BAL_IP) &&
		    !memcmp(ena, vh->sc_ac.ac_enaddr, ETHER_ADDR_LEN))
			return (&vh->sc_if);
	}
	return (NULL);
}

int
carp_vhe_match(struct carp_softc *sc, uint8_t *ena)
{
	struct carp_vhost_entry *vhe;
	struct srp_ref sr;
	int match = 0;

	vhe = SRPL_FIRST(&sr, &sc->carp_vhosts);
	match = (vhe->state == MASTER || sc->sc_balancing >= CARP_BAL_IP) &&
	    !memcmp(ena, sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN);
	SRPL_LEAVE(&sr);

	return (match);
}

int
carp_input(struct ifnet *ifp0, struct mbuf *m, void *cookie)
{
	struct ether_header *eh;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct carp_if *cif;
	struct carp_softc *sc;
	struct srp_ref sr;

#if NVLAN > 0
	/*
	 * If the underlying interface removed the VLAN header itself,
	 * it's not for us.
	 */
	if (ISSET(m->m_flags, M_VLANTAG))
		return (0);
#endif

	eh = mtod(m, struct ether_header *);
	cif = (struct carp_if *)cookie;
	KASSERT(cif == (struct carp_if *)ifp0->if_carp);

	SRPL_FOREACH(sc, &sr, &cif->vhif_vrs, sc_list) {
		if ((sc->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			continue;

		if (carp_vhe_match(sc, eh->ether_dhost))
			break;
	}

	if (sc == NULL) {
		SRPL_LEAVE(&sr);

		if (!ETHER_IS_MULTICAST(eh->ether_dhost))
			return (0);

		/*
		 * XXX Should really check the list of multicast addresses
		 * for each CARP interface _before_ copying.
		 */
		SRPL_FOREACH(sc, &sr, &cif->vhif_vrs, sc_list) {
			struct mbuf *m0;

			if (!(sc->sc_if.if_flags & IFF_UP))
				continue;

			m0 = m_dup_pkt(m, ETHER_ALIGN, M_DONTWAIT);
			if (m0 == NULL)
				continue;

			ml_init(&ml);
			ml_enqueue(&ml, m0);

			if_input(&sc->sc_if, &ml);
		}
		SRPL_LEAVE(&sr);

		return (0);
	}

	/*
	 * Clear mcast if received on a carp IP balanced address.
	 */
	if (sc->sc_balancing == CARP_BAL_IP &&
	    ETHER_IS_MULTICAST(eh->ether_dhost))
		*(eh->ether_dhost) &= ~0x01;

	ml_enqueue(&ml, m);
	if_input(&sc->sc_if, &ml);
	SRPL_LEAVE(&sr);

	return (1);
}

int
carp_lsdrop(struct mbuf *m, sa_family_t af, u_int32_t *src, u_int32_t *dst)
{
	struct ifnet *ifp;
	struct carp_softc *sc;
	int match = 1;
	u_int32_t fold;

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	KASSERT(ifp != NULL);

	sc = ifp->if_softc;
	if (sc->sc_balancing == CARP_BAL_NONE)
		goto done;
	/*
	 * Never drop carp advertisements.
	 * XXX Bad idea to pass all broadcast / multicast traffic?
	 */
	if (m->m_flags & (M_BCAST|M_MCAST))
		goto done;

	fold = src[0] ^ dst[0];
#ifdef INET6
	if (af == AF_INET6) {
		int i;
		for (i = 1; i < 4; i++)
			fold ^= src[i] ^ dst[i];
	}
#endif
	if (sc->sc_lscount == 0) /* just to be safe */
		match = 0;
	else
		match = (1 << (ntohl(fold) % sc->sc_lscount)) & sc->sc_lsmask;

done:
	if_put(ifp);
	return (!match);
}

void
carp_timer_down(void *v)
{
	int s;

	NET_LOCK(s);
	carp_master_down(v);
	NET_UNLOCK(s);
}

void
carp_master_down(struct carp_vhost_entry *vhe)
{
	struct carp_softc *sc = vhe->parent_sc;

	NET_ASSERT_LOCKED();

	switch (vhe->state) {
	case INIT:
		printf("%s: master_down event in INIT state\n",
		    sc->sc_if.if_xname);
		break;
	case MASTER:
		break;
	case BACKUP:
		carp_set_state(vhe, MASTER);
		carp_send_ad(vhe);
		if (sc->sc_balancing == CARP_BAL_NONE && vhe->vhe_leader) {
			carp_send_arp(sc);
			/* Schedule a delayed ARP to deal w/ some L3 switches */
			sc->sc_delayed_arp = 2;
#ifdef INET6
			carp_send_na(sc);
#endif /* INET6 */
		}
		carp_setrun(vhe, 0);
		carpstat_inc(carps_preempt);
		break;
	}
}

void
carp_setrun_all(struct carp_softc *sc, sa_family_t af)
{
	struct carp_vhost_entry *vhe;

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhost */
	SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts, vhost_entries) {
		carp_setrun(vhe, af);
	}
}

/*
 * When in backup state, af indicates whether to reset the master down timer
 * for v4 or v6. If it's set to zero, reset the ones which are already pending.
 */
void
carp_setrun(struct carp_vhost_entry *vhe, sa_family_t af)
{
	struct timeval tv;
	struct carp_softc *sc = vhe->parent_sc;

	if (sc->sc_carpdev == NULL) {
		sc->sc_if.if_flags &= ~IFF_RUNNING;
		carp_set_state_all(sc, INIT);
		return;
	}

	if (memcmp(((struct arpcom *)sc->sc_carpdev)->ac_enaddr,
	    sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN) == 0)
		sc->sc_realmac = 1;
	else
		sc->sc_realmac = 0;

	if (sc->sc_if.if_flags & IFF_UP && vhe->vhid > 0 &&
	    (sc->sc_naddrs || sc->sc_naddrs6) && !sc->sc_suppress) {
		sc->sc_if.if_flags |= IFF_RUNNING;
	} else {
		sc->sc_if.if_flags &= ~IFF_RUNNING;
		return;
	}

	switch (vhe->state) {
	case INIT:
		carp_set_state(vhe, BACKUP);
		carp_setrun(vhe, 0);
		break;
	case BACKUP:
		timeout_del(&vhe->ad_tmo);
		tv.tv_sec = 3 * sc->sc_advbase;
		if (sc->sc_advbase == 0 && vhe->advskew == 0)
			tv.tv_usec = 3 * 1000000 / 256;
		else if (sc->sc_advbase == 0)
			tv.tv_usec = 3 * vhe->advskew * 1000000 / 256;
		else
			tv.tv_usec = vhe->advskew * 1000000 / 256;
		if (vhe->vhe_leader)
			sc->sc_delayed_arp = -1;
		switch (af) {
		case AF_INET:
			timeout_add(&vhe->md_tmo, tvtohz(&tv));
			break;
#ifdef INET6
		case AF_INET6:
			timeout_add(&vhe->md6_tmo, tvtohz(&tv));
			break;
#endif /* INET6 */
		default:
			if (sc->sc_naddrs)
				timeout_add(&vhe->md_tmo, tvtohz(&tv));
			if (sc->sc_naddrs6)
				timeout_add(&vhe->md6_tmo, tvtohz(&tv));
			break;
		}
		break;
	case MASTER:
		tv.tv_sec = sc->sc_advbase;
		if (sc->sc_advbase == 0 && vhe->advskew == 0)
			tv.tv_usec = 1 * 1000000 / 256;
		else
			tv.tv_usec = vhe->advskew * 1000000 / 256;
		timeout_add(&vhe->ad_tmo, tvtohz(&tv));
		break;
	}
}

void
carp_multicast_cleanup(struct carp_softc *sc)
{
	struct ip_moptions *imo = &sc->sc_imo;
#ifdef INET6
	struct ip6_moptions *im6o = &sc->sc_im6o;
#endif
	u_int16_t n = imo->imo_num_memberships;

	/* Clean up our own multicast memberships */
	while (n-- > 0) {
		if (imo->imo_membership[n] != NULL) {
			in_delmulti(imo->imo_membership[n]);
			imo->imo_membership[n] = NULL;
		}
	}
	imo->imo_num_memberships = 0;
	imo->imo_ifidx = 0;

#ifdef INET6
	while (!LIST_EMPTY(&im6o->im6o_memberships)) {
		struct in6_multi_mship *imm =
		    LIST_FIRST(&im6o->im6o_memberships);

		LIST_REMOVE(imm, i6mm_chain);
		in6_leavegroup(imm);
	}
	im6o->im6o_ifidx = 0;
#endif

	/* And any other multicast memberships */
	carp_ether_purgemulti(sc);
}

int
carp_set_ifp(struct carp_softc *sc, struct ifnet *ifp0)
{
	struct carp_if *cif, *ncif = NULL;
	struct carp_softc *vr, *last = NULL, *after = NULL;
	int myself = 0, error = 0;

	KASSERT(ifp0 != sc->sc_carpdev);
	KERNEL_ASSERT_LOCKED(); /* touching vhif_vrs */

	if ((ifp0->if_flags & IFF_MULTICAST) == 0)
		return (EADDRNOTAVAIL);

	if (ifp0->if_type == IFT_CARP)
		return (EINVAL);

	if (ifp0->if_carp == NULL) {
		ncif = malloc(sizeof(*cif), M_IFADDR, M_NOWAIT|M_ZERO);
		if (ncif == NULL)
			return (ENOBUFS);
		if ((error = ifpromisc(ifp0, 1))) {
			free(ncif, M_IFADDR, sizeof(*ncif));
			return (error);
		}

		SRPL_INIT(&ncif->vhif_vrs);
	} else {
		cif = (struct carp_if *)ifp0->if_carp;
		if (carp_check_dup_vhids(sc, cif, NULL))
			return (EINVAL);
	}

	/* detach from old interface */
	if (sc->sc_carpdev != NULL)
		carpdetach(sc);

	/* attach carp interface to physical interface */
	if (ncif != NULL)
		ifp0->if_carp = (caddr_t)ncif;
	sc->sc_carpdev = ifp0;
	sc->sc_if.if_capabilities = ifp0->if_capabilities &
	    IFCAP_CSUM_MASK;
	cif = (struct carp_if *)ifp0->if_carp;
	SRPL_FOREACH_LOCKED(vr, &cif->vhif_vrs, sc_list) {
		struct carp_vhost_entry *vrhead, *schead;
		last = vr;

		if (vr == sc)
			myself = 1;

		vrhead = SRPL_FIRST_LOCKED(&vr->carp_vhosts);
		schead = SRPL_FIRST_LOCKED(&sc->carp_vhosts);
		if (vrhead->vhid < schead->vhid)
			after = vr;
	}

	if (!myself) {
		/* We're trying to keep things in order */
		if (last == NULL) {
			SRPL_INSERT_HEAD_LOCKED(&carp_sc_rc, &cif->vhif_vrs,
			    sc, sc_list);
		} else if (after == NULL) {
			SRPL_INSERT_AFTER_LOCKED(&carp_sc_rc, last,
			    sc, sc_list);
		} else {
			SRPL_INSERT_AFTER_LOCKED(&carp_sc_rc, after,
			    sc, sc_list);
		}
	}
	if (sc->sc_naddrs || sc->sc_naddrs6)
		sc->sc_if.if_flags |= IFF_UP;
	carp_set_enaddr(sc);

	sc->lh_cookie = hook_establish(ifp0->if_linkstatehooks, 1,
	    carp_carpdev_state, ifp0);

	/* Change input handler of the physical interface. */
	if_ih_insert(ifp0, carp_input, cif);

	carp_carpdev_state(ifp0);

	return (0);
}

void
carp_set_vhe_enaddr(struct carp_vhost_entry *vhe)
{
	struct carp_softc *sc = vhe->parent_sc;

	if (vhe->vhid != 0 && sc->sc_carpdev) {
		if (vhe->vhe_leader && sc->sc_balancing == CARP_BAL_IP)
			vhe->vhe_enaddr[0] = 1;
		else
			vhe->vhe_enaddr[0] = 0;
		vhe->vhe_enaddr[1] = 0;
		vhe->vhe_enaddr[2] = 0x5e;
		vhe->vhe_enaddr[3] = 0;
		vhe->vhe_enaddr[4] = 1;
		vhe->vhe_enaddr[5] = vhe->vhid;
	} else
		memset(vhe->vhe_enaddr, 0, ETHER_ADDR_LEN);
}

void
carp_set_enaddr(struct carp_softc *sc)
{
	struct carp_vhost_entry *vhe;

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */
	SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts, vhost_entries)
		carp_set_vhe_enaddr(vhe);

	vhe = SRPL_FIRST_LOCKED(&sc->carp_vhosts);

	/*
	 * Use the carp lladdr if the running one isn't manually set.
	 * Only compare static parts of the lladdr.
	 */
	if ((memcmp(sc->sc_ac.ac_enaddr + 1, vhe->vhe_enaddr + 1,
	    ETHER_ADDR_LEN - 2) == 0) ||
	    (!sc->sc_ac.ac_enaddr[0] && !sc->sc_ac.ac_enaddr[1] &&
	    !sc->sc_ac.ac_enaddr[2] && !sc->sc_ac.ac_enaddr[3] &&
	    !sc->sc_ac.ac_enaddr[4] && !sc->sc_ac.ac_enaddr[5]))
		bcopy(vhe->vhe_enaddr, sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN);

	/* Make sure the enaddr has changed before further twiddling. */
	if (memcmp(sc->sc_ac.ac_enaddr, sc->sc_curlladdr, ETHER_ADDR_LEN) != 0) {
		bcopy(sc->sc_ac.ac_enaddr, LLADDR(sc->sc_if.if_sadl),
		    ETHER_ADDR_LEN);
		bcopy(sc->sc_ac.ac_enaddr, sc->sc_curlladdr, ETHER_ADDR_LEN);
#ifdef INET6
		/*
		 * (re)attach a link-local address which matches
		 * our new MAC address.
		 */
		if (sc->sc_naddrs6)
			in6_ifattach_linklocal(&sc->sc_if, NULL);
#endif
		carp_set_state_all(sc, INIT);
		carp_setrun_all(sc, 0);
	}
}

void
carp_addr_updated(void *v)
{
	struct carp_softc *sc = (struct carp_softc *) v;
	struct ifaddr *ifa;
	int new_naddrs = 0, new_naddrs6 = 0;

	TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET)
			new_naddrs++;
#ifdef INET6
		else if (ifa->ifa_addr->sa_family == AF_INET6)
			new_naddrs6++;
#endif /* INET6 */
	}

	/* We received address changes from if_addrhooks callback */
	if (new_naddrs != sc->sc_naddrs || new_naddrs6 != sc->sc_naddrs6) {

		sc->sc_naddrs = new_naddrs;
		sc->sc_naddrs6 = new_naddrs6;

		/* Re-establish multicast membership removed by in_control */
		if (IN_MULTICAST(sc->sc_peer.s_addr)) {
			if (!in_hasmulti(&sc->sc_peer, &sc->sc_if)) {
				struct in_multi **imm =
				    sc->sc_imo.imo_membership;
				u_int16_t maxmem =
				    sc->sc_imo.imo_max_memberships;

				memset(&sc->sc_imo, 0, sizeof(sc->sc_imo));
				sc->sc_imo.imo_membership = imm;
				sc->sc_imo.imo_max_memberships = maxmem;

				if (sc->sc_carpdev != NULL && sc->sc_naddrs > 0)
					carp_join_multicast(sc);
			}
		}

		if (sc->sc_naddrs == 0 && sc->sc_naddrs6 == 0) {
			sc->sc_if.if_flags &= ~IFF_UP;
			carp_set_state_all(sc, INIT);
		} else
			carp_hmac_prepare(sc);
	}

	carp_setrun_all(sc, 0);
}

int
carp_set_addr(struct carp_softc *sc, struct sockaddr_in *sin)
{
	struct in_addr *in = &sin->sin_addr;
	int error;

	KASSERT(sc->sc_carpdev != NULL);

	/* XXX is this necessary? */
	if (in->s_addr == INADDR_ANY) {
		carp_setrun_all(sc, 0);
		return (0);
	}

	if (sc->sc_naddrs == 0 && (error = carp_join_multicast(sc)) != 0)
		return (error);

	carp_set_state_all(sc, INIT);

	return (0);
}

int
carp_join_multicast(struct carp_softc *sc)
{
	struct ip_moptions *imo = &sc->sc_imo;
	struct in_multi *imm;
	struct in_addr addr;

	if (!IN_MULTICAST(sc->sc_peer.s_addr))
		return (0);

	addr.s_addr = sc->sc_peer.s_addr;
	if ((imm = in_addmulti(&addr, &sc->sc_if)) == NULL)
		return (ENOBUFS);

	imo->imo_membership[0] = imm;
	imo->imo_num_memberships = 1;
	imo->imo_ifidx = sc->sc_if.if_index;
	imo->imo_ttl = CARP_DFLTTL;
	imo->imo_loop = 0;
	return (0);
}


#ifdef INET6
int
carp_set_addr6(struct carp_softc *sc, struct sockaddr_in6 *sin6)
{
	int error;

	KASSERT(sc->sc_carpdev != NULL);

	if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
		carp_setrun_all(sc, 0);
		return (0);
	}

	if (sc->sc_naddrs6 == 0 && (error = carp_join_multicast6(sc)) != 0)
		return (error);

	carp_set_state_all(sc, INIT);

	return (0);
}

int
carp_join_multicast6(struct carp_softc *sc)
{
	struct in6_multi_mship *imm, *imm2;
	struct ip6_moptions *im6o = &sc->sc_im6o;
	struct sockaddr_in6 addr6;
	int error;

	/* Join IPv6 CARP multicast group */
	memset(&addr6, 0, sizeof(addr6));
	addr6.sin6_family = AF_INET6;
	addr6.sin6_len = sizeof(addr6);
	addr6.sin6_addr.s6_addr16[0] = htons(0xff02);
	addr6.sin6_addr.s6_addr16[1] = htons(sc->sc_if.if_index);
	addr6.sin6_addr.s6_addr8[15] = 0x12;
	if ((imm = in6_joingroup(&sc->sc_if,
	    &addr6.sin6_addr, &error)) == NULL) {
		return (error);
	}
	/* join solicited multicast address */
	memset(&addr6.sin6_addr, 0, sizeof(addr6.sin6_addr));
	addr6.sin6_addr.s6_addr16[0] = htons(0xff02);
	addr6.sin6_addr.s6_addr16[1] = htons(sc->sc_if.if_index);
	addr6.sin6_addr.s6_addr32[1] = 0;
	addr6.sin6_addr.s6_addr32[2] = htonl(1);
	addr6.sin6_addr.s6_addr32[3] = 0;
	addr6.sin6_addr.s6_addr8[12] = 0xff;
	if ((imm2 = in6_joingroup(&sc->sc_if,
	    &addr6.sin6_addr, &error)) == NULL) {
		in6_leavegroup(imm);
		return (error);
	}

	/* apply v6 multicast membership */
	im6o->im6o_ifidx = sc->sc_if.if_index;
	if (imm)
		LIST_INSERT_HEAD(&im6o->im6o_memberships, imm,
		    i6mm_chain);
	if (imm2)
		LIST_INSERT_HEAD(&im6o->im6o_memberships, imm2,
		    i6mm_chain);

	return (0);
}

#endif /* INET6 */

int
carp_ioctl(struct ifnet *ifp, u_long cmd, caddr_t addr)
{
	struct proc *p = curproc;	/* XXX */
	struct carp_softc *sc = ifp->if_softc;
	struct carp_vhost_entry *vhe;
	struct carpreq carpr;
	struct ifaddr *ifa = (struct ifaddr *)addr;
	struct ifreq *ifr = (struct ifreq *)addr;
	struct ifnet *ifp0 = sc->sc_carpdev;
	int i, error = 0;

	switch (cmd) {
	case SIOCSIFADDR:
		if (ifp0 == NULL)
			return (EINVAL);

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			sc->sc_if.if_flags |= IFF_UP;
			error = carp_set_addr(sc, satosin(ifa->ifa_addr));
			break;
#ifdef INET6
		case AF_INET6:
			sc->sc_if.if_flags |= IFF_UP;
			error = carp_set_addr6(sc, satosin6(ifa->ifa_addr));
			break;
#endif /* INET6 */
		default:
			error = EAFNOSUPPORT;
			break;
		}
		break;

	case SIOCSIFFLAGS:
		KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */
		vhe = SRPL_FIRST_LOCKED(&sc->carp_vhosts);
		if (vhe->state != INIT && !(ifr->ifr_flags & IFF_UP)) {
			carp_del_all_timeouts(sc);

			/* we need the interface up to bow out */
			sc->sc_if.if_flags |= IFF_UP;
			sc->sc_bow_out = 1;
			carp_vhe_send_ad_all(sc);
			sc->sc_bow_out = 0;

			sc->sc_if.if_flags &= ~IFF_UP;
			carp_set_state_all(sc, INIT);
			carp_setrun_all(sc, 0);
		} else if (vhe->state == INIT && (ifr->ifr_flags & IFF_UP)) {
			sc->sc_if.if_flags |= IFF_UP;
			carp_setrun_all(sc, 0);
		}
		break;

	case SIOCSVH:
		KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */
		vhe = SRPL_FIRST_LOCKED(&sc->carp_vhosts);
		if ((error = suser(p, 0)) != 0)
			break;
		if ((error = copyin(ifr->ifr_data, &carpr, sizeof carpr)))
			break;
		error = 1;
		if (carpr.carpr_carpdev[0] != '\0' &&
		    (ifp0 = ifunit(carpr.carpr_carpdev)) == NULL)
			return (EINVAL);
		if (carpr.carpr_peer.s_addr == 0)
			sc->sc_peer.s_addr = INADDR_CARP_GROUP;
		else
			sc->sc_peer.s_addr = carpr.carpr_peer.s_addr;
		if (ifp0 != sc->sc_carpdev) {
			if ((error = carp_set_ifp(sc, ifp0)))
				return (error);
		}
		if (vhe->state != INIT && carpr.carpr_state != vhe->state) {
			switch (carpr.carpr_state) {
			case BACKUP:
				timeout_del(&vhe->ad_tmo);
				carp_set_state_all(sc, BACKUP);
				carp_setrun_all(sc, 0);
				break;
			case MASTER:
				KERNEL_ASSERT_LOCKED();
				/* touching carp_vhosts */
				SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts,
				    vhost_entries)
					carp_master_down(vhe);
				break;
			default:
				break;
			}
		}
		if ((error = carp_vhids_ioctl(sc, &carpr)))
			return (error);
		if (carpr.carpr_advbase >= 0) {
			if (carpr.carpr_advbase > 255) {
				error = EINVAL;
				break;
			}
			sc->sc_advbase = carpr.carpr_advbase;
			error--;
		}
		if (memcmp(sc->sc_advskews, carpr.carpr_advskews,
		    sizeof(sc->sc_advskews))) {
			i = 0;
			KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */
			SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts,
			    vhost_entries)
				vhe->advskew = carpr.carpr_advskews[i++];
			bcopy(carpr.carpr_advskews, sc->sc_advskews,
			    sizeof(sc->sc_advskews));
		}
		if (sc->sc_balancing != carpr.carpr_balancing) {
			if (carpr.carpr_balancing > CARP_BAL_MAXID) {
				error = EINVAL;
				break;
			}
			sc->sc_balancing = carpr.carpr_balancing;
			carp_set_enaddr(sc);
			carp_update_lsmask(sc);
		}
		bcopy(carpr.carpr_key, sc->sc_key, sizeof(sc->sc_key));
		if (error > 0)
			error = EINVAL;
		else {
			error = 0;
			carp_hmac_prepare(sc);
			carp_setrun_all(sc, 0);
		}
		break;

	case SIOCGVH:
		memset(&carpr, 0, sizeof(carpr));
		if (ifp0 != NULL)
			strlcpy(carpr.carpr_carpdev, ifp0->if_xname, IFNAMSIZ);
		i = 0;
		KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */
		SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts, vhost_entries) {
			carpr.carpr_vhids[i] = vhe->vhid;
			carpr.carpr_advskews[i] = vhe->advskew;
			carpr.carpr_states[i] = vhe->state;
			i++;
		}
		carpr.carpr_advbase = sc->sc_advbase;
		carpr.carpr_balancing = sc->sc_balancing;
		if (suser(p, 0) == 0)
			bcopy(sc->sc_key, carpr.carpr_key,
			    sizeof(carpr.carpr_key));
		carpr.carpr_peer.s_addr = sc->sc_peer.s_addr;
		error = copyout(&carpr, ifr->ifr_data, sizeof(carpr));
		break;

	case SIOCADDMULTI:
		error = carp_ether_addmulti(sc, ifr);
		break;

	case SIOCDELMULTI:
		error = carp_ether_delmulti(sc, ifr);
		break;
	case SIOCAIFGROUP:
	case SIOCDIFGROUP:
		if (sc->sc_demote_cnt)
			carp_ifgroup_ioctl(ifp, cmd, addr);
		break;
	case SIOCSIFGATTR:
		carp_ifgattr_ioctl(ifp, cmd, addr);
		break;
	default:
		error = ENOTTY;
	}

	if (memcmp(sc->sc_ac.ac_enaddr, sc->sc_curlladdr, ETHER_ADDR_LEN) != 0)
		carp_set_enaddr(sc);
	return (error);
}

int
carp_check_dup_vhids(struct carp_softc *sc, struct carp_if *cif,
    struct carpreq *carpr)
{
	struct carp_softc *vr;
	struct carp_vhost_entry *vhe, *vhe0;
	int i;

	KERNEL_ASSERT_LOCKED(); /* touching vhif_vrs + carp_vhosts */

	SRPL_FOREACH_LOCKED(vr, &cif->vhif_vrs, sc_list) {
		if (vr == sc)
			continue;
		SRPL_FOREACH_LOCKED(vhe, &vr->carp_vhosts, vhost_entries) {
			if (carpr) {
				for (i = 0; carpr->carpr_vhids[i]; i++) {
					if (vhe->vhid == carpr->carpr_vhids[i])
						return (EINVAL);
				}
			}
			SRPL_FOREACH_LOCKED(vhe0, &sc->carp_vhosts,
			    vhost_entries) {
				if (vhe->vhid == vhe0->vhid)
					return (EINVAL);
			}
		}
	}
	return (0);
}

int
carp_vhids_ioctl(struct carp_softc *sc, struct carpreq *carpr)
{
	int i, j;
	u_int8_t taken_vhids[256];

	if (carpr->carpr_vhids[0] == 0 ||
	    !memcmp(sc->sc_vhids, carpr->carpr_vhids, sizeof(sc->sc_vhids)))
		return (0);

	memset(taken_vhids, 0, sizeof(taken_vhids));
	for (i = 0; carpr->carpr_vhids[i]; i++) {
		if (taken_vhids[carpr->carpr_vhids[i]])
			return (EINVAL);
		taken_vhids[carpr->carpr_vhids[i]] = 1;

		if (sc->sc_carpdev) {
			struct carp_if *cif;
			cif = (struct carp_if *)sc->sc_carpdev->if_carp;
			if (carp_check_dup_vhids(sc, cif, carpr))
				return (EINVAL);
		}
		if (carpr->carpr_advskews[i] >= 255)
			return (EINVAL);
	}
	/* set sane balancing defaults */
	if (i <= 1)
		carpr->carpr_balancing = CARP_BAL_NONE;
	else if (carpr->carpr_balancing == CARP_BAL_NONE &&
	    sc->sc_balancing == CARP_BAL_NONE)
		carpr->carpr_balancing = CARP_BAL_IP;

	/* destroy all */
	carp_del_all_timeouts(sc);
	carp_destroy_vhosts(sc);
	memset(sc->sc_vhids, 0, sizeof(sc->sc_vhids));

	/* sort vhosts list by vhid */
	for (j = 1; j <= 255; j++) {
		for (i = 0; carpr->carpr_vhids[i]; i++) {
			if (carpr->carpr_vhids[i] != j)
				continue;
			if (carp_new_vhost(sc, carpr->carpr_vhids[i],
			    carpr->carpr_advskews[i]))
				return (ENOMEM);
			sc->sc_vhids[i] = carpr->carpr_vhids[i];
			sc->sc_advskews[i] = carpr->carpr_advskews[i];
		}
	}
	carp_set_enaddr(sc);
	carp_set_state_all(sc, INIT);
	return (0);
}

void
carp_ifgroup_ioctl(struct ifnet *ifp, u_long cmd, caddr_t addr)
{
	struct ifgroupreq *ifgr = (struct ifgroupreq *)addr;
	struct ifg_list	*ifgl;
	int *dm, adj;

	if (!strcmp(ifgr->ifgr_group, IFG_ALL))
		return;
	adj = ((struct carp_softc *)ifp->if_softc)->sc_demote_cnt;
	if (cmd == SIOCDIFGROUP)
		adj = adj * -1;

	TAILQ_FOREACH(ifgl, &ifp->if_groups, ifgl_next)
		if (!strcmp(ifgl->ifgl_group->ifg_group, ifgr->ifgr_group)) {
			dm = &ifgl->ifgl_group->ifg_carp_demoted;
			if (*dm + adj >= 0)
				*dm += adj;
			else
				*dm = 0;
		}
}

void
carp_ifgattr_ioctl(struct ifnet *ifp, u_long cmd, caddr_t addr)
{
	struct ifgroupreq *ifgr = (struct ifgroupreq *)addr;
	struct carp_softc *sc = ifp->if_softc;

	if (ifgr->ifgr_attrib.ifg_carp_demoted > 0 && (sc->sc_if.if_flags &
	    (IFF_UP|IFF_RUNNING)) == (IFF_UP|IFF_RUNNING))
		carp_vhe_send_ad_all(sc);
}

void
carp_start(struct ifnet *ifp)
{
	struct carp_softc *sc = ifp->if_softc;
	struct mbuf *m;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif /* NBPFILTER > 0 */

		if ((ifp->if_carpdev->if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING)) {
			ifp->if_oerrors++;
			m_freem(m);
			continue;
		}

		/*
		 * Do not leak the multicast address when sending
		 * advertisements in 'ip' and 'ip-stealth' balacing
		 * modes.
		 */
		if (sc->sc_balancing == CARP_BAL_IP ||
		    sc->sc_balancing == CARP_BAL_IPSTEALTH) {
			struct ether_header *eh;
			uint8_t *esrc;

			eh = mtod(m, struct ether_header *);
			esrc = ((struct arpcom*)ifp->if_carpdev)->ac_enaddr;;
			memcpy(eh->ether_shost, esrc, sizeof(eh->ether_shost));
		}

		if (if_enqueue(ifp->if_carpdev, m)) {
			ifp->if_oerrors++;
			continue;
		}
		ifp->if_opackets++;
	}
}

int
carp_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *sa,
    struct rtentry *rt)
{
	struct carp_softc *sc = ((struct carp_softc *)ifp->if_softc);
	struct carp_vhost_entry *vhe;
	struct srp_ref sr;
	int ismaster;

	KASSERT(sc->sc_carpdev != NULL);

	if (sc->cur_vhe == NULL) {
		vhe = SRPL_FIRST(&sr, &sc->carp_vhosts);
		ismaster = (vhe->state == MASTER);
		SRPL_LEAVE(&sr);
	} else {
		ismaster = (sc->cur_vhe->state == MASTER);
	}

	if ((sc->sc_balancing == CARP_BAL_NONE && !ismaster)) {
		m_freem(m);
		return (ENETUNREACH);
	}

	return (ether_output(ifp, m, sa, rt));
}

void
carp_set_state_all(struct carp_softc *sc, int state)
{
	struct carp_vhost_entry *vhe;

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */

	SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts, vhost_entries) {
		if (vhe->state == state)
			continue;

		carp_set_state(vhe, state);
	}
}

void
carp_set_state(struct carp_vhost_entry *vhe, int state)
{
	struct carp_softc *sc = vhe->parent_sc;
	static const char *carp_states[] = { CARP_STATES };
	int loglevel;
	struct carp_vhost_entry *vhe0;

	KASSERT(vhe->state != state);

	if (vhe->state == INIT || state == INIT)
		loglevel = LOG_WARNING;
	else
		loglevel = LOG_CRIT;

	if (sc->sc_vhe_count > 1)
		CARP_LOG(loglevel, sc,
		    ("state transition (vhid %d): %s -> %s", vhe->vhid,
		    carp_states[vhe->state], carp_states[state]));
	else
		CARP_LOG(loglevel, sc,
		    ("state transition: %s -> %s",
		    carp_states[vhe->state], carp_states[state]));

	vhe->state = state;
	carp_update_lsmask(sc);

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */

	sc->sc_if.if_link_state = LINK_STATE_INVALID;
	SRPL_FOREACH_LOCKED(vhe0, &sc->carp_vhosts, vhost_entries) {
		/*
		 * Link must be up if at least one vhe is in state MASTER to
		 * bring or keep route up.
		 */
		if (vhe0->state == MASTER) {
			sc->sc_if.if_link_state = LINK_STATE_UP;
			break;
		} else if (vhe0->state == BACKUP) {
			sc->sc_if.if_link_state = LINK_STATE_DOWN;
		}
	}
	if_link_state_change(&sc->sc_if);
}

void
carp_group_demote_adj(struct ifnet *ifp, int adj, char *reason)
{
	struct ifg_list	*ifgl;
	int *dm, need_ad;
	struct carp_softc *nil = NULL;

	if (ifp->if_type == IFT_CARP) {
		dm = &((struct carp_softc *)ifp->if_softc)->sc_demote_cnt;
		if (*dm + adj >= 0)
			*dm += adj;
		else
			*dm = 0;
	}

	need_ad = 0;
	TAILQ_FOREACH(ifgl, &ifp->if_groups, ifgl_next) {
		if (!strcmp(ifgl->ifgl_group->ifg_group, IFG_ALL))
			continue;
		dm = &ifgl->ifgl_group->ifg_carp_demoted;

		if (*dm + adj >= 0)
			*dm += adj;
		else
			*dm = 0;

		if (adj > 0 && *dm == 1)
			need_ad = 1;
		CARP_LOG(LOG_ERR, nil,
		    ("%s demoted group %s by %d to %d (%s)",
		    ifp->if_xname, ifgl->ifgl_group->ifg_group,
		    adj, *dm, reason));
	}
	if (need_ad)
		carp_send_ad_all();
}

int
carp_group_demote_count(struct carp_softc *sc)
{
	struct ifg_list	*ifgl;
	int count = 0;

	TAILQ_FOREACH(ifgl, &sc->sc_if.if_groups, ifgl_next)
		count += ifgl->ifgl_group->ifg_carp_demoted;

	if (count == 0 && sc->sc_demote_cnt)
		count = sc->sc_demote_cnt;

	return (count > 255 ? 255 : count);
}

void
carp_carpdev_state(void *v)
{
	struct carp_if *cif;
	struct carp_softc *sc;
	struct ifnet *ifp0 = v;

	if (ifp0->if_type == IFT_CARP)
		return;

	cif = (struct carp_if *)ifp0->if_carp;

	KERNEL_ASSERT_LOCKED(); /* touching vhif_vrs */

	SRPL_FOREACH_LOCKED(sc, &cif->vhif_vrs, sc_list) {
		int suppressed = sc->sc_suppress;

		if (sc->sc_carpdev->if_link_state == LINK_STATE_DOWN ||
		    !(sc->sc_carpdev->if_flags & IFF_UP)) {
			sc->sc_if.if_flags &= ~IFF_RUNNING;
			carp_del_all_timeouts(sc);
			carp_set_state_all(sc, INIT);
			sc->sc_suppress = 1;
			carp_setrun_all(sc, 0);
			if (!suppressed)
				carp_group_demote_adj(&sc->sc_if, 1, "carpdev");
		} else if (suppressed) {
			carp_set_state_all(sc, INIT);
			sc->sc_suppress = 0;
			carp_setrun_all(sc, 0);
			carp_group_demote_adj(&sc->sc_if, -1, "carpdev");
		}
	}
}

int
carp_ether_addmulti(struct carp_softc *sc, struct ifreq *ifr)
{
	struct ifnet *ifp0;
	struct carp_mc_entry *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;

	ifp0 = sc->sc_carpdev;
	if (ifp0 == NULL)
		return (EINVAL);

	error = ether_addmulti(ifr, (struct arpcom *)&sc->sc_ac);
	if (error != ENETRESET)
		return (error);

	/*
	 * This is new multicast address.  We have to tell parent
	 * about it.  Also, remember this multicast address so that
	 * we can delete them on unconfigure.
	 */
	mc = malloc(sizeof(*mc), M_DEVBUF, M_NOWAIT);
	if (mc == NULL) {
		error = ENOMEM;
		goto alloc_failed;
	}

	/*
	 * As ether_addmulti() returns ENETRESET, following two
	 * statement shouldn't fail.
	 */
	(void)ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &sc->sc_ac, mc->mc_enm);
	memcpy(&mc->mc_addr, &ifr->ifr_addr, ifr->ifr_addr.sa_len);
	LIST_INSERT_HEAD(&sc->carp_mc_listhead, mc, mc_entries);

	error = (*ifp0->if_ioctl)(ifp0, SIOCADDMULTI, (caddr_t)ifr);
	if (error != 0)
		goto ioctl_failed;

	return (error);

 ioctl_failed:
	LIST_REMOVE(mc, mc_entries);
	free(mc, M_DEVBUF, sizeof(*mc));
 alloc_failed:
	(void)ether_delmulti(ifr, (struct arpcom *)&sc->sc_ac);

	return (error);
}

int
carp_ether_delmulti(struct carp_softc *sc, struct ifreq *ifr)
{
	struct ifnet *ifp0;
	struct ether_multi *enm;
	struct carp_mc_entry *mc;
	u_int8_t addrlo[ETHER_ADDR_LEN], addrhi[ETHER_ADDR_LEN];
	int error;

	ifp0 = sc->sc_carpdev;
	if (ifp0 == NULL)
		return (EINVAL);

	/*
	 * Find a key to lookup carp_mc_entry.  We have to do this
	 * before calling ether_delmulti for obvious reason.
	 */
	if ((error = ether_multiaddr(&ifr->ifr_addr, addrlo, addrhi)) != 0)
		return (error);
	ETHER_LOOKUP_MULTI(addrlo, addrhi, &sc->sc_ac, enm);
	if (enm == NULL)
		return (EINVAL);

	LIST_FOREACH(mc, &sc->carp_mc_listhead, mc_entries)
		if (mc->mc_enm == enm)
			break;

	/* We won't delete entries we didn't add */
	if (mc == NULL)
		return (EINVAL);

	error = ether_delmulti(ifr, (struct arpcom *)&sc->sc_ac);
	if (error != ENETRESET)
		return (error);

	/* We no longer use this multicast address.  Tell parent so. */
	error = (*ifp0->if_ioctl)(ifp0, SIOCDELMULTI, (caddr_t)ifr);
	if (error == 0) {
		/* And forget about this address. */
		LIST_REMOVE(mc, mc_entries);
		free(mc, M_DEVBUF, sizeof(*mc));
	} else
		(void)ether_addmulti(ifr, (struct arpcom *)&sc->sc_ac);
	return (error);
}

/*
 * Delete any multicast address we have asked to add from parent
 * interface.  Called when the carp is being unconfigured.
 */
void
carp_ether_purgemulti(struct carp_softc *sc)
{
	struct ifnet *ifp0 = sc->sc_carpdev;		/* Parent. */
	struct carp_mc_entry *mc;
	union {
		struct ifreq ifreq;
		struct {
			char ifr_name[IFNAMSIZ];
			struct sockaddr_storage ifr_ss;
		} ifreq_storage;
	} u;
	struct ifreq *ifr = &u.ifreq;

	if (ifp0 == NULL)
		return;

	memcpy(ifr->ifr_name, ifp0->if_xname, IFNAMSIZ);
	while ((mc = LIST_FIRST(&sc->carp_mc_listhead)) != NULL) {
		memcpy(&ifr->ifr_addr, &mc->mc_addr, mc->mc_addr.ss_len);
		(void)(*ifp0->if_ioctl)(ifp0, SIOCDELMULTI, (caddr_t)ifr);
		LIST_REMOVE(mc, mc_entries);
		free(mc, M_DEVBUF, sizeof(*mc));
	}
}

void
carp_vh_ref(void *null, void *v)
{
	struct carp_vhost_entry *vhe = v;

	refcnt_take(&vhe->vhost_refcnt);
}

void
carp_vh_unref(void *null, void *v)
{
	struct carp_vhost_entry *vhe = v;

	if (refcnt_rele(&vhe->vhost_refcnt)) {
		carp_sc_unref(NULL, vhe->parent_sc);
		free(vhe, M_DEVBUF, sizeof(*vhe));
	}
}

void
carp_sc_ref(void *null, void *s)
{
	struct carp_softc *sc = s;

	refcnt_take(&sc->sc_refcnt);
}

void
carp_sc_unref(void *null, void *s)
{
	struct carp_softc *sc = s;

	refcnt_rele_wake(&sc->sc_refcnt);
}
@


1.310
log
@Fix the carp mode 'balancing ip-stealth'.  Set the link state UP
if at least one vhid is in state MASTER.
from Florian Riehm; OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.309 2017/05/04 17:58:46 bluhm Exp $	*/
d873 1
d875 1
d877 2
@


1.309
log
@If m is not a continuous mbuf cluster, m_pullup() in pr_input may
change the pointer.  Then *mp keeps the invalid pointer and it might
be used.  Fix the potential use after free and also reset *mp in
other places to have less dangling pointers to freed mbufs.
OK mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.308 2017/04/14 20:46:31 bluhm Exp $	*/
d2365 1
d2386 1
a2386 3
	/* only the master vhe creates link state messages */
	if (!vhe->vhe_leader)
		return;
d2388 12
a2399 10
	switch (state) {
	case BACKUP:
		sc->sc_if.if_link_state = LINK_STATE_DOWN;
		break;
	case MASTER:
		sc->sc_if.if_link_state = LINK_STATE_UP;
		break;
	default:
		sc->sc_if.if_link_state = LINK_STATE_INVALID;
		break;
@


1.308
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.307 2017/04/11 14:43:49 dhill Exp $	*/
d490 1
a490 1
	if ((m = m_pullup(m, len)) == NULL) {
d565 1
a565 1
	if ((m = m_pullup(m, *offp + sizeof(*ch))) == NULL) {
@


1.307
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.306 2017/04/09 17:57:58 dhill Exp $	*/
d418 1
a418 1
carp_proto_input(struct mbuf **mp, int *offp, int proto)
d514 1
a514 1
carp6_proto_input(struct mbuf **mp, int *offp, int proto)
@


1.306
log
@Use mallocarray to allocate multicast group memberships.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.305 2017/04/05 13:35:18 deraadt Exp $	*/
d798 2
a799 2
	sc->sc_imo.imo_membership = (struct in_multi **)mallocarray(
	    IP_MIN_MEMBERSHIPS, sizeof(struct in_multi *), M_IPMOPTS,
@


1.305
log
@When building counter memory in preparation to copy to userland, always
zero the buffers first.  All the current objects appear to be safe,
however future changes might introduce structure pads.
Discussed with guenther, ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.304 2017/03/23 14:12:46 bluhm Exp $	*/
d798 2
a799 2
	sc->sc_imo.imo_membership = (struct in_multi **)malloc(
	    (sizeof(struct in_multi *) * IP_MIN_MEMBERSHIPS), M_IPMOPTS,
@


1.304
log
@Replace manual loop with SRPL_FOREACH_SAFE_LOCKED macro.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.303 2017/03/17 17:06:25 mpi Exp $	*/
d732 1
@


1.303
log
@carp(4) code is always executed in the 'softnet' thread, so remove
unneeded splnet()/splx() dance.

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.302 2017/02/20 06:29:42 jca Exp $	*/
d950 1
a950 3
	for (sc = SRPL_FIRST_LOCKED(&cif->vhif_vrs); sc != NULL; sc = nextsc) {
		nextsc = SRPL_NEXT_LOCKED(sc, sc_list);

a951 1
	}
@


1.302
log
@carp(4) percpu counters

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.301 2017/01/29 19:58:47 bluhm Exp $	*/
a900 1
	int s;
a927 1
	s = splnet();
a938 1
	splx(s);
a1679 1
	int s;
a1752 1
	s = splnet();
a1753 1
	splx(s);
@


1.301
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.300 2017/01/25 17:34:31 bluhm Exp $	*/
d187 1
a187 1
struct carpstats carpstats;
d447 1
a447 1
	carpstats.carps_ipackets++;
d459 1
a459 1
		carpstats.carps_badif++;
d469 1
a469 1
		carpstats.carps_badttl++;
d483 1
a483 1
		carpstats.carps_badlen++;
d491 1
a491 1
		carpstats.carps_hdrops++;
d500 1
a500 1
		carpstats.carps_badsum++;
d538 1
a538 1
	carpstats.carps_ipackets6++;
d547 1
a547 1
		carpstats.carps_badif++;
d556 1
a556 1
		carpstats.carps_badttl++;
d566 1
a566 1
		carpstats.carps_badlen++;
d575 1
a575 1
		carpstats.carps_badsum++;
d616 1
a616 1
		carpstats.carps_badvhid++;
d627 1
a627 1
		carpstats.carps_badver++;
d637 1
a637 1
		carpstats.carps_badauth++;
d648 1
a648 1
			carpstats.carps_badauth++;
d727 11
d747 1
a747 4
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &carpstats, sizeof(carpstats)));
d769 1
d1097 1
a1097 1
			carpstats.carps_onomem++;
d1143 1
a1143 1
		carpstats.carps_opackets++;
d1149 1
a1149 1
				carpstats.carps_onomem++;
d1187 1
a1187 1
			carpstats.carps_onomem++;
d1233 1
a1233 1
		carpstats.carps_opackets6++;
d1238 1
a1238 1
				carpstats.carps_onomem++;
d1553 1
a1553 1
		carpstats.carps_preempt++;
@


1.300
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.299 2017/01/23 11:37:29 mpi Exp $	*/
d217 4
a220 1
void	carp_proto_input_if(struct ifnet *, struct mbuf *, int);
d417 2
a418 2
void
carp_proto_input(struct mbuf *m, int hlen, int proto)
d422 1
a422 1
	ifp = if_get(m->m_pkthdr.ph_ifidx);
d424 2
a425 2
		m_freem(m);
		return;
d428 1
a428 1
	carp_proto_input_if(ifp, m, hlen);
d430 1
d438 2
a439 2
void
carp_proto_input_if(struct ifnet *ifp, struct mbuf *m, int hlen)
d441 1
d451 1
a451 1
		return;
d464 1
a464 1
		return;
d473 1
a473 1
		return;
d487 1
a487 1
		return;
d492 1
a492 1
		return;
d504 1
a504 1
		return;
d509 1
a512 2
int	carp6_proto_input_if(struct ifnet *, struct mbuf *, int *);

a515 1
	struct mbuf *m = *mp;
a516 1
	int rv;
d518 1
a518 1
	ifp = if_get(m->m_pkthdr.ph_ifidx);
d520 2
a521 2
		m_freem(m);
		return (IPPROTO_DONE);
d524 1
a524 1
	rv = carp6_proto_input_if(ifp, m, offp);
d526 1
a526 2

	return (rv);
d530 1
a530 1
carp6_proto_input_if(struct ifnet *ifp, struct mbuf *m, int *offp)
d532 1
d542 1
a542 1
		return (IPPROTO_DONE);
d551 1
a551 1
		return (IPPROTO_DONE);
d560 1
a560 1
		return (IPPROTO_DONE);
d568 1
a568 1
		return (IPPROTO_DONE);
d579 1
a579 1
		return (IPPROTO_DONE);
d584 1
a584 1
	return (IPPROTO_DONE);
@


1.299
log
@Flag pseudo-interfaces as such in order to call add_net_randomness()
only once per packet.

Fix a regression introduced when if_input() started to be called by
every pseudo-driver.

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.298 2016/12/20 14:30:52 mpi Exp $	*/
d415 1
a415 1
carp_proto_input(struct mbuf *m, ...)
a417 6
	int hlen;
	va_list ap;

	va_start(ap, m);
	hlen = va_arg(ap, int);
	va_end(ap);
@


1.298
log
@Prevent grabing the NET_LOCK() twice in the ioctl(2) and input path.

While here remove two redundant splsoftnet()/splx() dances.

inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.297 2016/12/19 08:36:49 mpi Exp $	*/
d805 1
@


1.297
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.296 2016/11/20 11:40:58 mpi Exp $	*/
d224 2
a225 1
void	carp_send_ad(void *);
d227 2
a228 1
void	carp_master_down(void *);
d836 3
a838 3
	timeout_set_proc(&vhe->ad_tmo, carp_send_ad, vhe);
	timeout_set_proc(&vhe->md_tmo, carp_master_down, vhe);
	timeout_set_proc(&vhe->md6_tmo, carp_master_down, vhe);
d1032 11
a1042 1
carp_send_ad(void *v)
a1045 1
	struct carp_vhost_entry *vhe = v;
a1047 1

d1049 1
a1049 1
	int error, len, advbase, advskew, s;
d1053 2
a1059 2
	NET_LOCK(s);

a1258 1
	NET_UNLOCK(s);
a1272 1
	int s = splsoftnet();
a1282 1
	splx(s);
a1291 1
	int s = splsoftnet();
a1303 1
	splx(s);
d1512 11
a1522 1
carp_master_down(void *v)
a1523 1
	struct carp_vhost_entry *vhe = v;
d1525 2
@


1.296
log
@Rename SRPL_ENTER() to SRPL_FIRST() and SRPL_NEXT() to SRPL_FOLLOW().

This allows us to introduce SRPL_NEXT() that can be used to start
iterating on an arbitrary member of an srp list, hence without calling
SRPL_ENTER().

ok dlg@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.295 2016/10/25 07:21:02 yasuoka Exp $	*/
d1048 1
a1048 1
	s = splsoftnet();
d1249 1
a1249 1
	splx(s);
@


1.295
log
@Accept CARP advertisement packets whose destination is not for multicast.
When both "carppeer" and "real mac-address" are used at once and the
BACKUP is to take over the new MASTER, the present MASTER receives
such packets.  Found by and diff from nagasaka at iij.

ok henning bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.294 2016/10/04 13:54:32 mpi Exp $	*/
d1332 1
a1332 1
	vhe = SRPL_ENTER(&sr, &sc->carp_vhosts); /* head */
d1384 1
a1384 1
	vhe = SRPL_ENTER(&sr, &sc->carp_vhosts); /* head */
d2315 1
a2315 1
		vhe = SRPL_ENTER(&sr, &sc->carp_vhosts); /* head */
@


1.294
log
@Convert timeouts that need a process context to timeout_set_proc(9).

The current reason is that rtalloc_mpath(9) inside ip_output() might
end up inserting a RTF_CLONED route and that require a write lock.

ok kettenis@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.293 2016/07/25 16:44:04 benno Exp $	*/
d456 1
a456 1
	if (!((ifp->if_type == IFT_CARP && ismulti) ||
@


1.293
log
@fix revision 1.290 of sys/netinet/ip_carp.c.

diff from jsg@@
ok deraadt@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.292 2016/07/19 16:08:46 mpi Exp $	*/
d834 3
a836 3
	timeout_set(&vhe->ad_tmo, carp_send_ad, vhe);
	timeout_set(&vhe->md_tmo, carp_master_down, vhe);
	timeout_set(&vhe->md6_tmo, carp_master_down, vhe);
@


1.292
log
@Fix the check supposed to prevent 'ip' and 'ip-stealth' balancing modes
from leaking the multicast address.

beck@@ found the hard way that this made his second CARP master use a
wrong MAC address.

This is part of a bigger diff from Florian Riehm who is currently
working on a proper solution to fix balancing modes.

ok beck@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.291 2016/06/06 07:01:37 mpi Exp $	*/
d83 1
@


1.291
log
@Get rid of the ``enaddr'' argument of carp_iamatch().

It was only checked in balancing mode, which is currently broken, and is
no longer needed.

Discusssed with bluhm@@ and Florian Riehm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.290 2016/05/30 12:56:16 mpi Exp $	*/
d2284 2
a2285 3
		if (sc->sc_balancing != CARP_BAL_IPSTEALTH &&
		    sc->sc_balancing != CARP_BAL_IP &&
		    (sc->cur_vhe && !sc->cur_vhe->vhe_leader)) {
d2290 1
a2290 1
			esrc = sc->cur_vhe->vhe_enaddr;
@


1.290
log
@Insert a hack to deal with interfaces removing the VLAN header before
the packet has been feed to the pseudo-interfaces input handlers.

To fix that without introducing a layer violation we should be able to
disable HW-vlan on parent when in use with different pseudo-interfaces.

In the case of bridge(4) for example it makes no sense to let the interface
remove the VLAN header if the kernel has to add it back for every packet.

Fix issues reported by sebastia@@ and markus@@

From dlg@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.289 2016/05/18 03:46:03 dlg Exp $	*/
d1324 1
a1324 1
carp_iamatch(struct ifnet *ifp, uint8_t *enaddr)
d1332 1
a1332 6
	if (vhe->state == MASTER) {
		if (sc->sc_balancing == CARP_BAL_IPSTEALTH ||
		    sc->sc_balancing == CARP_BAL_IP) {
		    	struct arpcom *ac = (struct arpcom *)sc->sc_carpdev;
			memcpy(enaddr, ac->ac_enaddr, ETHER_ADDR_LEN);
		}
a1333 1
	}
@


1.289
log
@rework the srp api so it takes an srp_ref struct that the caller provides.

the srp_ref struct is used to track the location of the callers
hazard pointer so later calls to srp_follow and srp_enter already
know what to clear. this in turn means most of the caveats around
using srps go away. specifically, you can now:

- switch cpus while holding an srp ref
  - ie, you can sleep while holding an srp ref
- you can take and release srp refs in any order

the original intent was to simplify use of the api when dealing
with complicated data structures. the caller now no longer has to
track the location of the srp a value was fetched from, the srp_ref
effectively does that for you.

srp lists have been refactored to use srp_refs instead of srpl_iter
structs.

this is in preparation of using srps inside the ART code. ART is a
complicated data structure, and lookups require overlapping holds
of srp references.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.288 2016/04/13 11:41:15 mpi Exp $	*/
d83 4
d1405 9
@


1.288
log
@We're always ready!  So send IFQ_SET_READY() to the bitbucket.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.287 2016/02/23 01:39:14 dlg Exp $	*/
d1324 1
a1324 1
	struct srpl_iter i;
d1327 1
a1327 1
	vhe = SRPL_ENTER(&sc->carp_vhosts, &i); /* head */
d1336 1
a1336 1
	SRPL_LEAVE(&i, vhe);
d1382 1
a1382 1
	struct srpl_iter i;
d1385 1
a1385 1
	vhe = SRPL_ENTER(&sc->carp_vhosts, &i); /* head */
d1388 1
a1388 1
	SRPL_LEAVE(&i, vhe);
d1400 1
a1400 1
	struct srpl_iter i;
d1406 1
a1406 1
	SRPL_FOREACH(sc, &cif->vhif_vrs, &i, sc_list) {
d1416 1
a1416 1
		SRPL_LEAVE(&i, sc);
d1425 1
a1425 1
		SRPL_FOREACH(sc, &cif->vhif_vrs, &i, sc_list) {
d1440 1
a1440 1
		SRPL_LEAVE(&i, sc);
d1454 1
a1454 1
	SRPL_LEAVE(&i, sc);
d2302 1
a2302 1
	struct srpl_iter i;
d2308 1
a2308 1
		vhe = SRPL_ENTER(&sc->carp_vhosts, &i); /* head */
d2310 1
a2310 1
		SRPL_LEAVE(&i, vhe);
@


1.287
log
@provide m_dup_pkt() for doing fast deep mbuf copies with a specified alignment

if a physical interface receives a multicast/broadcast packet and
has carp interfaces on it, that packet needs to be copied for
reception by each of those carp interfaces.

previously it was using m_copym2, but that doesn't respect the
alignment of the source packet. this meant the ip header in the
copies were aligned incorrectly for the network stack, which breaks
strict alignment archs.

m_dup_pkt lets carp specify that the payload needs an ETHER_ALIGN
adjustment, so the ip header inside will be aligned correctly.

reported and tested by anthony eden who hit this on armv7
i reproduced the problem on sparc64 and verified the fix on amd64
and sparc64
ok mpi@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.286 2016/01/21 11:23:48 mpi Exp $	*/
a798 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.286
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.285 2016/01/12 09:22:01 mpi Exp $	*/
d1432 1
a1432 1
			m0 = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);
@


1.285
log
@Prevent a NULL-reference if SIOCGVH is issued without carpdev argument.

Problem reported by and diff tested by Fabian Raetz, thanks!

ok benno@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.284 2015/12/19 11:19:35 mpi Exp $	*/
a1811 2
		struct in_addr mc_addr;
		struct in_multi *inm;
d1818 1
a1818 3
			mc_addr.s_addr = sc->sc_peer.s_addr;
			IN_LOOKUP_MULTI(mc_addr, &sc->sc_if, inm);
			if (inm == NULL) {
@


1.284
log
@Make carp_output() mpsafe.

This is needed in order to fully unlock ARP processing with carp(4)
interfaces as found the hardway by sthen@@.

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.283 2015/12/03 16:27:32 mpi Exp $	*/
d1656 1
a1658 3
	if (ifp0 == sc->sc_carpdev)
		return (0);

d1969 1
a1969 1
	struct ifnet *ifp0 = NULL;
d1974 1
a1974 1
		if (sc->sc_carpdev == NULL)
d2030 4
a2033 2
		if ((error = carp_set_ifp(sc, ifp0)))
			return (error);
d2093 2
a2094 3
		if (sc->sc_carpdev != NULL)
			strlcpy(carpr.carpr_carpdev, sc->sc_carpdev->if_xname,
			    IFNAMSIZ);
@


1.283
log
@Use SRPL_HEAD() and SRPL_ENTRY() to be consistent with and allow to
fallback to a SLIST.

ok dlg@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.282 2015/11/18 13:53:59 mpi Exp $	*/
d2308 2
d2311 1
a2311 1
	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */
d2313 7
a2319 1
	vhe = sc->cur_vhe ? sc->cur_vhe : SRPL_FIRST_LOCKED(&sc->carp_vhosts);
d2321 1
a2321 2
	if ((sc->sc_carpdev == NULL) ||
	    (sc->sc_balancing == CARP_BAL_NONE && vhe->state != MASTER)) {
@


1.282
log
@Make use of srp_enter()/srp_leave() in carp_iamatch() in preparation
for unlocking the ARP input path.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.281 2015/11/12 05:46:45 dlg Exp $	*/
d97 1
a97 1
	struct srpl_entry vhost_entries;
d136 1
a136 1
	struct srpl_entry sc_list;
d150 1
a150 1
	struct srpl carp_vhosts;
@


1.281
log
@IFQ_DROP means a drop because enqueue on the send q failed, not cos tx
later failed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.280 2015/11/02 15:56:46 mpi Exp $	*/
d1321 1
a1321 1
carp_iamatch(struct ifnet *ifp, uint8_t **ether_shost)
d1324 3
a1326 3
	struct carp_vhost_entry *vhe = SRPL_FIRST_LOCKED(&sc->carp_vhosts);

	KERNEL_ASSERT_LOCKED(); /* touching carp_vhosts */
d1328 1
d1333 1
a1333 1
			*ether_shost = ac->ac_enaddr;
d1335 1
a1335 1
		return (1);
d1337 1
d1339 1
a1339 1
	return (0);
@


1.280
log
@Remove leftovers from previous carp(4)-to-relayd(8) conversion diff.

Pointed by and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.279 2015/11/02 15:05:23 mpi Exp $	*/
a2270 1
			IF_DROP(&ifp->if_carpdev->if_snd);
@


1.279
log
@Retire ARP load-balacing, thanks for all the fish!

One of the keys of our MP work relies on making OpenBSD's kernel simpler!
In this case turning ARP processing MP-safe is quite complicated due to
the way carp(4) is hooked in arpinput() and nowadays you'd better run
kitchensinkd(9) anyway :)

ok bluhm@@, claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.278 2015/10/25 11:58:11 mpi Exp $	*/
a116 1
	struct sockaddr_dl vhe_sdl;	/* for IPv6 ndp balancing */
a1749 4

		vhe->vhe_sdl.sdl_family = AF_LINK;
		vhe->vhe_sdl.sdl_alen = ETHER_ADDR_LEN;
		bcopy(vhe->vhe_enaddr, vhe->vhe_sdl.sdl_data, ETHER_ADDR_LEN);
@


1.278
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.277 2015/10/22 13:30:29 mpi Exp $	*/
a238 1
u_int32_t	carp_hash(struct carp_softc *, u_char *);
a1298 35
/*
 * Originated from bridge_hash() in if_bridge.c
 */
#define	mix(a, b, c) do {						\
	a -= b; a -= c; a ^= (c >> 13);					\
	b -= c; b -= a; b ^= (a << 8);					\
	c -= a; c -= b; c ^= (b >> 13);					\
	a -= b; a -= c; a ^= (c >> 12);					\
	b -= c; b -= a; b ^= (a << 16);					\
	c -= a; c -= b; c ^= (b >> 5);					\
	a -= b; a -= c; a ^= (c >> 3);					\
	b -= c; b -= a; b ^= (a << 10);					\
	c -= a; c -= b; c ^= (b >> 15);					\
} while (0)

u_int32_t
carp_hash(struct carp_softc *sc, u_char *src)
{
	u_int32_t a = 0x9e3779b9, b = sc->sc_hashkey[0], c = sc->sc_hashkey[1];

	c += sc->sc_key[3] << 24;
	c += sc->sc_key[2] << 16;
	c += sc->sc_key[1] << 8;
	c += sc->sc_key[0];
	b += src[5] << 8;
	b += src[4];
	a += src[3] << 24;
	a += src[2] << 16;
	a += src[1] << 8;
	a += src[0];

	mix(a, b, c);
	return (c);
}

d1305 1
a1305 1
	if (!sc->sc_balancing)
d1322 1
a1322 2
carp_iamatch(struct ifnet *ifp, u_char *src, u_int8_t **sha,
    u_int8_t **ether_shost)
d1329 5
a1333 30
	if (sc->sc_balancing == CARP_BAL_ARP) {
		int lshash;
		/*
		 * We use the source MAC address to decide which virtual host
		 * should handle the request. If we're master of that virtual
		 * host, then we respond, otherwise, just drop the arp packet
		 * on the floor.
		 */

		if (sc->sc_lscount == 0) /* just to be safe */
			return (0);
		lshash = carp_hash(sc, src) % sc->sc_lscount;
		if ((1 << lshash) & sc->sc_lsmask) {
			int i = 0;
			SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts,
			    vhost_entries) {
				if (i++ == lshash)
					break;
			}
			if (vhe == NULL)
				return (0);
			*sha = vhe->vhe_enaddr;
			return (1);
		}
	} else if (sc->sc_balancing == CARP_BAL_IPSTEALTH ||
	    sc->sc_balancing == CARP_BAL_IP) {
		if (vhe->state == MASTER) {
			*ether_shost = ((struct arpcom *)sc->sc_carpdev)->
			    ac_enaddr;
			return (1);
d1335 1
a1335 3
	} else {
		if (vhe->state == MASTER)
			return (1);
d1343 1
a1343 1
carp_iamatch6(struct ifnet *ifp, u_char *src, struct sockaddr_dl **sdl)
d1350 2
a1351 31
	if (sc->sc_balancing == CARP_BAL_ARP) {
		int lshash;
		/*
		 * We use the source MAC address to decide which virtual host
		 * should handle the request. If we're master of that virtual
		 * host, then we respond, otherwise, just drop the ndp packet
		 * on the floor.
		 */

		/* can happen if optional src lladdr is not provided */
		if (src == NULL)
			return (0);
		if (sc->sc_lscount == 0) /* just to be safe */
			return (0);
		lshash = carp_hash(sc, src) % sc->sc_lscount;
		if ((1 << lshash) & sc->sc_lsmask) {
			int i = 0;
			SRPL_FOREACH_LOCKED(vhe, &sc->carp_vhosts,
			    vhost_entries) {
				if (i++ == lshash)
					break;
			}
			if (vhe == NULL)
				return (0);
			*sdl = &vhe->vhe_sdl;
			return (1);
		}
	} else {
		if (vhe->state == MASTER)
			return (1);
	}
d1370 4
a1373 14
		if (vh->sc_balancing == CARP_BAL_ARP) {
			SRPL_FOREACH_LOCKED(vhe, &vh->carp_vhosts,
			    vhost_entries)
				if (vhe->state == MASTER &&
				    !memcmp(ena, vhe->vhe_enaddr,
				    ETHER_ADDR_LEN))
					return (&vh->sc_if);
		} else {
			vhe = SRPL_FIRST_LOCKED(&vh->carp_vhosts);
			if ((vhe->state == MASTER ||
			    vh->sc_balancing >= CARP_BAL_IP) &&
			    !memcmp(ena, vh->sc_ac.ac_enaddr, ETHER_ADDR_LEN))
				return (&vh->sc_if);
		}
d1385 4
a1388 16
	if (sc->sc_balancing == CARP_BAL_ARP) {
		SRPL_FOREACH(vhe, &sc->carp_vhosts, &i, vhost_entries) {
			if (vhe->state == MASTER &&
			    !memcmp(ena, vhe->vhe_enaddr, ETHER_ADDR_LEN)) {
				match = 1;
				break;
			}
		}
		SRPL_LEAVE(&i, vhe);
	} else {
		vhe = SRPL_ENTER(&sc->carp_vhosts, &i); /* head */
		match = (vhe->state == MASTER ||
		    sc->sc_balancing >= CARP_BAL_IP) &&
		    !memcmp(ena, sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN);
		SRPL_LEAVE(&i, vhe);
	}
d1471 1
a1471 1
	if (sc->sc_balancing < CARP_BAL_IP)
d2318 1
a2318 1
	    (!sc->sc_balancing && vhe->state != MASTER)) {
@


1.277
log
@Do not pass an ``ia'' just to dereference ``ia_ifp''.

ok claudio@@, bluhm@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.276 2015/10/14 13:59:31 jsg Exp $	*/
a2099 1
			ifa->ifa_rtrequest = arp_rtrequest;
@


1.276
log
@Init a variable in the recently added carp_vhe_match() function clang
and mpi believe could be used uninitialised.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.275 2015/10/05 19:05:09 uebayasi Exp $	*/
d1358 1
a1358 1
carp_iamatch(struct in_ifaddr *ia, u_char *src, u_int8_t **sha,
d1361 1
a1361 1
	struct carp_softc *sc = ia->ia_ifp->if_softc;
@


1.275
log
@Revert if_oqdrops accounting changes done in kernel, per request from mpi@@.

(Especially adding IF_DROP() after IFQ_ENQUEUE() was completely wrong because
IFQ_ENQUEUE() already does it.  Oops.)

After this revert, the situation becomes:

- if_snd.ifq_drops is incremented in either IFQ_ENQUEUE() or IF_DROP(), but
  it is not shown to userland, and

- if_data.ifi_oqdrops is shown to userland, but it is not incremented by
  anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1486 1
a1486 1
	int match;
@


1.274
log
@Don't count IF_DROP()'ed packets as if_oerrors too.

mpi@@ plans to clean-up IF_DROP()'s, but fix consistent use of it for now.

OK dlg@@
@
text
@d2393 1
@


1.273
log
@Factors ou the route hashing code to implement Equal-Cost Multi-Path
for ART.

While here sync the two remaining mix() macros.

ok chris@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.272 2015/09/27 04:27:57 dlg Exp $	*/
a2392 1
			ifp->if_oerrors++;
@


1.272
log
@make carp_input mpsafe.

there are three data structures involved here:

the list of carp interfaces on a parent interface (struct carp_if)
is now accessed via the if_ih cookie. its lifetime is managed by
the if_ih_insert and if_ih_remove calls.

the second is the interfaces (struct carp_softc) in the list above.
these has been moved from being access via a TAILQ to an SRPL.
modifications to the list are serialised by the kernel lock.

the third is the list of vhost entries (struct carp_vhost_entry).
these used to be in a LIST on each carp_softc, but have been moved
to being accessed vian an SRPL. modifications to the list are
serialised by the kernel lock.

written at l2k15
tested by mpi@@ and hrvoje popovski
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.268 2015/09/11 08:17:06 claudio Exp $	*/
d1301 1
a1301 1
 * Based on bridge_hash() in if_bridge.c
d1303 11
a1313 12
#define	mix(a,b,c) \
	do {						\
		a -= b; a -= c; a ^= (c >> 13);		\
		b -= c; b -= a; b ^= (a << 8);		\
		c -= a; c -= b; c ^= (b >> 13);		\
		a -= b; a -= c; a ^= (c >> 12);		\
		b -= c; b -= a; b ^= (a << 16);		\
		c -= a; c -= b; c ^= (b >> 5);		\
		a -= b; a -= c; a ^= (c >> 3);		\
		b -= c; b -= a; b ^= (a << 10);		\
		c -= a; c -= b; c ^= (b >> 15);		\
	} while (0)
@


1.271
log
@consistently name the ifnet * that refers to the parent interface
ifp0, and the ifnet * that refers to the carp interface ifp.

this makes it easier for me to read. it's probably not the right
name for ifp0, but at least it's consistent.

ok sthen@@ bluhm@@ mpi@@ claudio@@
@
text
@d51 1
d97 3
a99 1
	LIST_ENTRY(carp_vhost_entry)	vhost_entries;
d120 6
d136 3
a138 1
	TAILQ_ENTRY(carp_softc) sc_list;
d151 1
a151 1
	LIST_HEAD(__carp_vhosthead, carp_vhost_entry)	carp_vhosts;
d176 6
d188 1
a188 1
	TAILQ_HEAD(, carp_softc) vhif_vrs;
d270 3
a272 1
	LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d601 2
a602 1
	TAILQ_FOREACH(sc, &cif->vhif_vrs, sc_list) {
d606 1
a606 1
		LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d772 3
a774 1
	LIST_INIT(&sc->carp_vhosts);
d826 2
d836 2
d839 1
a839 1
	if (LIST_EMPTY(&sc->carp_vhosts)) {
d841 2
a842 1
		LIST_INSERT_HEAD(&sc->carp_vhosts, vhe, vhost_entries);
d847 2
a848 2
	LIST_FOREACH(vhe0, &sc->carp_vhosts, vhost_entries)
		if (LIST_NEXT(vhe0, vhost_entries) == NULL)
d850 3
a852 1
	LIST_INSERT_AFTER(vhe0, vhe, vhost_entries);
d867 1
a869 1

d878 2
a879 1
	LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d912 4
d917 1
a917 1
	if_ih_remove(ifp0, carp_input, NULL);
d921 5
a925 5
		hook_disestablish(ifp0->if_linkstatehooks,
		    sc->lh_cookie);
	cif = (struct carp_if *)ifp0->if_carp;
	TAILQ_REMOVE(&cif->vhif_vrs, sc, sc_list);
	if (TAILQ_EMPTY(&cif->vhif_vrs)) {
d941 6
a946 3
	for (sc = TAILQ_FIRST(&cif->vhif_vrs); sc; sc = nextsc) {
		nextsc = TAILQ_NEXT(sc, sc_list);
		carpdetach(sc);
d954 3
a956 1
	struct carp_vhost_entry *vhe, *nvhe;
d958 4
a961 3
	for (vhe = LIST_FIRST(&sc->carp_vhosts); vhe != NULL; vhe = nvhe) {
		nvhe = LIST_NEXT(vhe, vhost_entries);
		free(vhe, M_DEVBUF, sizeof(*vhe));
a962 1
	LIST_INIT(&sc->carp_vhosts);
d994 2
d1004 1
a1004 1
		TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
d1019 3
a1021 1
	LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d1348 2
a1349 1
	LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d1363 3
a1365 1
	struct carp_vhost_entry *vhe = LIST_FIRST(&sc->carp_vhosts);
d1381 2
a1382 1
			LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d1411 3
a1413 1
	struct carp_vhost_entry *vhe = LIST_FIRST(&sc->carp_vhosts);
d1432 2
a1433 1
			LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d1457 3
a1459 1
	TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
d1465 2
a1466 1
			LIST_FOREACH(vhe, &vh->carp_vhosts, vhost_entries)
d1472 1
a1472 1
			vhe = LIST_FIRST(&vh->carp_vhosts);
d1483 27
a1511 1
	struct carp_softc *sc;
d1515 2
a1516 1
	struct ifnet *ifp;
d1519 11
a1529 1
	cif = (struct carp_if *)ifp0->if_carp;
d1531 2
a1532 3
	ifp = carp_ourether(cif, eh->ether_dhost);
	if (ifp == NULL && !ETHER_IS_MULTICAST(eh->ether_dhost))
		return (0);
d1534 2
a1535 3
	if (ifp == NULL) {
		struct carp_softc *vh;
		struct mbuf *m0;
d1541 4
a1544 2
		TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
			if (!(vh->sc_if.if_flags & IFF_UP))
d1546 1
d1554 1
a1554 1
			if_input(&vh->sc_if, &ml);
d1556 1
a1563 1
	sc = ifp->if_softc;
a1567 1

d1569 2
a1571 1
	if_input(ifp, &ml);
d1648 3
a1650 1
	LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d1767 1
a1767 1
	struct carp_softc *vr, *after = NULL;
d1771 2
d1791 1
a1791 1
		TAILQ_INIT(&ncif->vhif_vrs);
d1809 4
a1812 1
	TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list) {
d1815 4
a1818 2
		if (LIST_FIRST(&vr->carp_vhosts)->vhid <
		    LIST_FIRST(&sc->carp_vhosts)->vhid)
d1824 6
a1829 2
		if (after == NULL) {
			TAILQ_INSERT_TAIL(&cif->vhif_vrs, sc, sc_list);
d1831 1
a1831 1
			TAILQ_INSERT_AFTER(&cif->vhif_vrs, after,
d1843 1
a1843 1
	if_ih_insert(ifp0, carp_input, NULL);
d1880 2
a1881 1
	LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries)
d1884 1
a1884 1
	vhe = LIST_FIRST(&sc->carp_vhosts);
d2117 2
a2118 1
		vhe = LIST_FIRST(&sc->carp_vhosts);
d2138 2
a2139 1
		vhe = LIST_FIRST(&sc->carp_vhosts);
d2162 3
a2164 1
				LIST_FOREACH(vhe, &sc->carp_vhosts,
d2185 3
a2187 1
			LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries)
d2217 2
a2218 1
		LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d2265 3
a2267 1
	TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list) {
d2270 1
a2270 1
		LIST_FOREACH(vhe, &vr->carp_vhosts, vhost_entries) {
d2277 2
a2278 1
			LIST_FOREACH(vhe0, &sc->carp_vhosts, vhost_entries) {
d2430 3
a2432 1
	vhe = sc->cur_vhe ? sc->cur_vhe : LIST_FIRST(&sc->carp_vhosts);
d2448 3
a2450 1
	LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries) {
d2566 3
a2568 1
	TAILQ_FOREACH(sc, &cif->vhif_vrs, sc_list) {
d2714 35
@


1.270
log
@vhif_ifp in struct carp_ifs is set but never used. it can be trimmed.

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.269 2015/09/12 09:36:31 dlg Exp $	*/
d193 2
a194 2
int	carp_input(struct ifnet *ifp, struct mbuf *, void *);
void	carp_proto_input_c(struct ifnet *ifp, struct mbuf *,
d859 1
a859 1
	struct ifnet *ifp;
d878 2
a879 2
	ifp = sc->sc_carpdev;
	if (ifp == NULL)
d883 1
a883 1
	if_ih_remove(ifp, carp_input, NULL);
d887 1
a887 1
		hook_disestablish(ifp->if_linkstatehooks,
d889 1
a889 1
	cif = (struct carp_if *)ifp->if_carp;
d892 2
a893 2
		ifpromisc(ifp, 0);
		ifp->if_carp = NULL;
d902 1
a902 1
carp_ifdetach(struct ifnet *ifp)
d905 1
a905 1
	struct carp_if *cif = (struct carp_if *)ifp->if_carp;
d951 1
a951 1
	struct ifnet *ifp;
d958 2
a959 2
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_carp == NULL || ifp->if_type == IFT_CARP)
d962 1
a962 1
		cif = (struct carp_if *)ifp->if_carp;
d1671 1
a1671 1
carp_set_ifp(struct carp_softc *sc, struct ifnet *ifp)
d1678 1
a1678 1
	if (ifp == sc->sc_carpdev)
d1681 1
a1681 1
	if ((ifp->if_flags & IFF_MULTICAST) == 0)
d1684 1
a1684 1
	if (ifp->if_type == IFT_CARP)
d1687 1
a1687 1
	if (ifp->if_carp == NULL) {
d1691 1
a1691 1
		if ((error = ifpromisc(ifp, 1))) {
d1698 1
a1698 1
		cif = (struct carp_if *)ifp->if_carp;
d1709 3
a1711 3
		ifp->if_carp = (caddr_t)ncif;
	sc->sc_carpdev = ifp;
	sc->sc_if.if_capabilities = ifp->if_capabilities &
d1713 1
a1713 1
	cif = (struct carp_if *)ifp->if_carp;
d1735 2
a1736 2
	sc->lh_cookie = hook_establish(ifp->if_linkstatehooks, 1,
	    carp_carpdev_state, ifp);
d1739 1
a1739 1
	if_ih_insert(ifp, carp_input, NULL);
d1742 1
a1742 1
	carp_carpdev_state(ifp);
d1985 1
a1985 1
	struct ifnet *cdev = NULL;
d2039 1
a2039 1
		    (cdev = ifunit(carpr.carpr_carpdev)) == NULL)
d2045 1
a2045 1
		if ((error = carp_set_ifp(sc, cdev)))
d2440 1
a2440 1
	struct ifnet *ifp = v;
d2442 1
a2442 1
	if (ifp->if_type == IFT_CARP)
d2445 1
a2445 1
	cif = (struct carp_if *)ifp->if_carp;
d2471 1
a2471 1
	struct ifnet *ifp;
d2476 2
a2477 2
	ifp = sc->sc_carpdev;
	if (ifp == NULL)
d2504 1
a2504 1
	error = (*ifp->if_ioctl)(ifp, SIOCADDMULTI, (caddr_t)ifr);
d2522 1
a2522 1
	struct ifnet *ifp;
d2528 2
a2529 2
	ifp = sc->sc_carpdev;
	if (ifp == NULL)
d2555 1
a2555 1
	error = (*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr);
d2572 1
a2572 1
	struct ifnet *ifp = sc->sc_carpdev;		/* Parent. */
d2583 1
a2583 1
	if (ifp == NULL)
d2586 1
a2586 1
	memcpy(ifr->ifr_name, ifp->if_xname, IFNAMSIZ);
d2589 1
a2589 1
		(void)(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)ifr);
@


1.269
log
@vhif_nvrs in carp_if is used to count the number of entries in
vhif_ifs so you can tell when that list is empty.

you can use TAILQ_EMPTY to see if a list is empty though, so kill
the count and use EMPTY instead.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.268 2015/09/11 08:17:06 claudio Exp $	*/
a171 2

	struct ifnet *vhif_ifp;
a1695 1
		ncif->vhif_ifp = ifp;
@


1.268
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.267 2015/09/10 16:41:30 mikeb Exp $	*/
a171 1
	int vhif_nvrs;
d893 1
a893 1
	if (!--cif->vhif_nvrs) {
a1732 1
		cif->vhif_nvrs++;
@


1.267
log
@pass a cookie argument to interface input handlers that can be used
to pass additional context or transient data with the similar life
time.

ok mpi, suggestions, hand holding and ok from dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.266 2015/09/10 15:09:16 dlg Exp $	*/
d1177 1
a1177 1
		error = ip6_output(m, NULL, NULL, 0, &sc->sc_im6o, NULL, NULL);
@


1.266
log
@if_put after if_get.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.265 2015/09/10 13:32:19 dlg Exp $	*/
d196 1
a196 1
int	carp_input(struct ifnet *ifp, struct mbuf *);
d886 1
a886 1
	if_ih_remove(ifp, carp_input);
d1433 1
a1433 1
carp_input(struct ifnet *ifp0, struct mbuf *m)
d1744 1
a1744 1
	if_ih_insert(ifp, carp_input);
@


1.265
log
@move the if input handler list to an SRP list.

instead of having every driver that manipulates the ifih list
understand SRPLs, this moves that processing into if_ih_insert and
if_ih_remove functions.

we rely on the kernel lock to serialise the modifications to the
list.

tested by mpi@@
ok mpi@@ claudio@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.264 2015/07/02 09:40:03 mpi Exp $	*/
d197 3
a199 2
void	carp_proto_input_c(struct mbuf *, struct carp_header *, int,
	    sa_family_t);
a392 5
/*
 * process input packet.
 * we have rearranged checks order compared to the rfc,
 * but it seems more efficient this way or not possible otherwise.
 */
a395 1
	struct ip *ip = mtod(m, struct ip *);
d397 1
a397 3
	struct carp_softc *sc = NULL;
	struct carp_header *ch;
	int iplen, len, hlen, ismulti;
d410 17
d488 1
a488 1
	carp_proto_input_c(m, ch, ismulti, AF_INET);
d492 2
d499 1
a499 4
	struct carp_softc *sc = NULL;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct carp_header *ch;
	u_int len;
d507 14
d566 1
a566 1
	carp_proto_input_c(m, ch, 1, AF_INET6);
d572 2
a573 2
carp_proto_input_c(struct mbuf *m, struct carp_header *ch, int ismulti,
    sa_family_t af)
a574 1
	struct ifnet *ifp;
a579 3
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	KASSERT(ifp != NULL);

d1492 1
a1492 1
	int match;
d1500 1
a1500 1
		return (0);
d1506 1
a1506 1
		return (0);
d1517 3
a1519 2
		return (1);
	match = (1 << (ntohl(fold) % sc->sc_lscount)) & sc->sc_lsmask;
d1521 2
@


1.264
log
@By design if_input_process() needs to hold a reference on the receiving
ifp in order to access its ifih handlers.

So get rid of if_get() in the various ifih handlers we know the ifp is
live at this point.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.263 2015/06/30 13:54:42 mpi Exp $	*/
a122 1
	struct ifih *sc_ifih;
a865 1
	s = splnet();
d867 1
a867 4
	if (--sc->sc_ifih->ifih_refcnt == 0) {
		SLIST_REMOVE(&ifp->if_inputs, sc->sc_ifih, ifih, ifih_next);
		free(sc->sc_ifih, M_DEVBUF, sizeof(*sc->sc_ifih));
	}
d869 1
a1684 12
	/* Can we share an ifih between multiple carp(4) instances? */
	sc->sc_ifih = SLIST_FIRST(&ifp->if_inputs);
	if (sc->sc_ifih->ifih_input != carp_input) {
		sc->sc_ifih = malloc(sizeof(*sc->sc_ifih), M_DEVBUF, M_NOWAIT);
		if (sc->sc_ifih == NULL) {
			free(ncif, M_IFADDR, sizeof(*ncif));
			return (ENOMEM);
		}
		sc->sc_ifih->ifih_input = carp_input;
		sc->sc_ifih->ifih_refcnt = 0;
	}

a1720 1
	s = splnet();
d1722 1
a1722 2
	if (++sc->sc_ifih->ifih_refcnt == 1)
		SLIST_INSERT_HEAD(&ifp->if_inputs, sc->sc_ifih, ifih_next);
d1724 1
@


1.264.4.1
log
@Carp in OpenBSD 5.8 is affected by the same bug as vlan.  By creating,
changing and destroying carp interfaces multiple times, root could
crash the OpenBSD 5.8 kernel with ifconfig.  The reference counting
of carp_ifih in carp_set_ifp() was wrong, so a use after free was
possible.  Reordering the operations fixes it.
From markus@@; OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.264 2015/07/02 09:40:03 mpi Exp $	*/
a1657 1
	struct ifih *carp_ifih;
d1690 4
a1693 4
	carp_ifih = SLIST_FIRST(&ifp->if_inputs);
	if (carp_ifih->ifih_input != carp_input) {
		carp_ifih = malloc(sizeof(*carp_ifih), M_DEVBUF, M_NOWAIT);
		if (carp_ifih == NULL) {
d1697 2
a1698 2
		carp_ifih->ifih_input = carp_input;
		carp_ifih->ifih_refcnt = 0;
a1699 2
	/* Do not free our reference during carpdetach() */
	++carp_ifih->ifih_refcnt;
d1739 2
a1740 3
	sc->sc_ifih = carp_ifih;
	if (carp_ifih->ifih_refcnt == 1)
		SLIST_INSERT_HEAD(&ifp->if_inputs, carp_ifih, ifih_next);
@


1.264.4.2
log
@There was another bug in vlan and carp ifih refcounting.  An ifih
could be inserted twice into the the parent's list.  Then the kernel
will panic if root does an ifconfig destroy of the parent interface.
This affects OpenBSD 5.8 only.
From markus@@; OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.264.4.1 2016/02/08 21:57:46 bluhm Exp $	*/
d1661 1
a1661 1
	int myself = 0, error = 0, insert = 0;
a1699 1
		insert = 1;
d1743 1
a1743 1
	if (insert)
@


1.263
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.262 2015/06/29 10:32:29 dlg Exp $	*/
d197 1
a197 1
int	carp_input(struct mbuf *);
d1418 1
a1418 1
carp_input(struct mbuf *m)
d1424 1
a1424 8
	struct ifnet *ifp0, *ifp;

	ifp0 = if_get(m->m_pkthdr.ph_ifidx);
	KASSERT(ifp0 != NULL);
	if ((ifp0->if_flags & IFF_UP) == 0) {
		m_freem(m);
		return (1);
	}
@


1.262
log
@count if_ibytes in if_input like we do for if_ipackets.

tweaks and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.261 2015/06/24 09:40:55 mpi Exp $	*/
d2307 1
a2307 1
		if (if_output(ifp->if_carpdev, m)) {
@


1.261
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.260 2015/06/16 11:09:40 mpi Exp $	*/
a1462 2

	ifp0->if_ibytes += m->m_pkthdr.len;
@


1.260
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.259 2015/06/08 13:40:48 mpi Exp $	*/
a1458 1
			vh->sc_if.if_ipackets++;
a1477 1
	ifp->if_ipackets++;
@


1.259
log
@Move carp-related logic from ether_output() into carp_start().

ok sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.258 2015/06/02 09:38:24 mpi Exp $	*/
d402 1
a402 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d412 6
d487 1
a487 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d493 6
d553 1
a553 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d559 3
d1030 1
a1030 1
		m->m_pkthdr.rcvif = NULL;
d1120 1
a1120 1
		m->m_pkthdr.rcvif = NULL;
d1426 7
a1432 1
	ifp0 = m->m_pkthdr.rcvif;
d1486 2
a1487 1
	struct carp_softc *sc = m->m_pkthdr.rcvif->if_softc;
d1491 4
@


1.258
log
@Take carp(4) out of ether_input().

Tested by <mxb AT alumni DOT chalmers DOT se>, thanks!

ok bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.257 2015/05/21 09:17:53 mpi Exp $	*/
d748 1
a748 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
a1401 15
u_char *
carp_get_srclladdr(struct ifnet *ifp, u_char *esrc)
{
	struct carp_softc *sc = ifp->if_softc;

	if (sc->sc_balancing != CARP_BAL_IPSTEALTH &&
	    sc->sc_balancing != CARP_BAL_IP && sc->cur_vhe) {
		if (sc->cur_vhe->vhe_leader)
			return (sc->sc_ac.ac_enaddr);
		else
			return (sc->cur_vhe->vhe_enaddr);
	}
	return (esrc);
}

a2244 3
/*
 * Start output on carp interface. This function should never be called.
 */
d2248 43
a2290 3
#ifdef DEBUG
	printf("%s: start called\n", ifp->if_xname);
#endif
d2308 1
a2308 1
	return (sc->sc_carpdev->if_output(ifp, m, sa, rt));
@


1.257
log
@Correctly state the link state to INVALID when creating a carp interface.

Since vhe are allocated with M_ZERO and INIT is also defined to be 0,
carp_set_state() would result in a no-op because of the state check.

So explicitly initialize the state of a vhe to INIT and move the state
check in carp_set_state_all() to prevent similar issues in the future.

Problem and initial diff from Johan Ymerson, thanks!

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.256 2015/05/15 11:53:06 claudio Exp $	*/
d123 1
d197 1
d829 1
a844 1
	s = splnet();
d847 21
a867 11
	if (sc->sc_carpdev != NULL) {
		if (sc->lh_cookie != NULL)
			hook_disestablish(sc->sc_carpdev->if_linkstatehooks,
			    sc->lh_cookie);
		cif = (struct carp_if *)sc->sc_carpdev->if_carp;
		TAILQ_REMOVE(&cif->vhif_vrs, sc, sc_list);
		if (!--cif->vhif_nvrs) {
			ifpromisc(sc->sc_carpdev, 0);
			sc->sc_carpdev->if_carp = NULL;
			free(cif, M_IFADDR, sizeof(*cif));
		}
d1418 1
a1418 1
carp_our_mcastaddr(struct ifnet *ifp, u_int8_t *d_enaddr)
d1420 9
a1428 1
	struct carp_softc *sc = ifp->if_softc;
d1430 2
a1431 1
	if (sc->sc_balancing != CARP_BAL_IP)
a1433 15
	return (!memcmp(sc->sc_ac.ac_enaddr, d_enaddr, ETHER_ADDR_LEN));
}


int
carp_input(struct ifnet *ifp0, struct ether_header *eh0, struct mbuf *m)
{
	struct ether_header *eh;
	struct carp_if *cif = (struct carp_if *)ifp0->if_carp;
	struct ifnet *ifp;

	ifp = carp_ourether(cif, eh0->ether_dhost);
	if (ifp == NULL && (m->m_flags & (M_BCAST|M_MCAST)) == 0)
		return (1);

a1447 5
			M_PREPEND(m0, sizeof(*eh), M_DONTWAIT);
			if (m0 == NULL)
				continue;
			eh = mtod(m0, struct ether_header *);
			memmove(eh, eh0, sizeof(*eh));
d1449 4
a1452 6
			m0->m_pkthdr.rcvif = &vh->sc_if;
#if NBPFILTER > 0
			if (vh->sc_if.if_bpf)
				bpf_mtap_ether(vh->sc_if.if_bpf, m0,
				    BPF_DIRECTION_IN);
#endif
a1453 1
			ether_input_mbuf(&vh->sc_if, m0);
d1456 1
a1456 1
		return (1);
d1459 10
a1468 5
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
	if (m == NULL)
		return (0);
	eh = mtod(m, struct ether_header *);
	memmove(eh, eh0, sizeof(*eh));
d1470 1
a1470 1
	m->m_pkthdr.rcvif = ifp;
d1472 1
a1472 4
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
d1474 1
a1474 3
	ether_input_mbuf(ifp, m);

	return (0);
d1689 12
d1733 1
a1733 1
	s = splnet();
d1736 6
d2280 2
a2281 4
	if (sc->sc_carpdev != NULL &&
	    (sc->sc_balancing || vhe->state == MASTER))
		return (sc->sc_carpdev->if_output(ifp, m, sa, rt));
	else {
d2285 2
@


1.256
log
@Give carp(4) interfaces their own low priority. The change should not
change behaviour for now but will allow to share the same address with
the parent interface without major hacks.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.255 2015/05/15 10:09:23 mpi Exp $	*/
d711 1
a711 3
carp_clone_create(ifc, unit)
	struct if_clone *ifc;
	int unit;
d754 1
a758 1
	carp_set_state_all(sc, INIT);
d775 1
d2278 4
a2281 1
	LIST_FOREACH(vhe, &sc->carp_vhosts, vhost_entries)
d2283 1
d2293 2
a2294 2
	if (vhe->state == state)
		return;
@


1.255
log
@Remove a NULL check in carp_set_ifp() as we always pass a valid ifp
pointer to this function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.254 2015/04/28 14:51:50 mpi Exp $	*/
d755 1
@


1.254
log
@Make sure to overwrite sdl_type after calling ether_ifattach().

Fix a problem found by Johan Huldtgren, ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.253 2015/04/22 06:44:17 mpi Exp $	*/
d1668 2
a1669 3
	if (ifp != NULL) {
		if ((ifp->if_flags & IFF_MULTICAST) == 0)
			return (EADDRNOTAVAIL);
d1671 2
a1672 2
		if (ifp->if_type == IFT_CARP)
			return (EINVAL);
d1674 7
a1680 15
		if (ifp->if_carp == NULL) {
			ncif = malloc(sizeof(*cif), M_IFADDR, M_NOWAIT|M_ZERO);
			if (ncif == NULL)
				return (ENOBUFS);
			if ((error = ifpromisc(ifp, 1))) {
				free(ncif, M_IFADDR, sizeof(*ncif));
				return (error);
			}

			ncif->vhif_ifp = ifp;
			TAILQ_INIT(&ncif->vhif_vrs);
		} else {
			cif = (struct carp_if *)ifp->if_carp;
			if (carp_check_dup_vhids(sc, cif, NULL))
				return (EINVAL);
d1683 3
a1685 10
		/* detach from old interface */
		if (sc->sc_carpdev != NULL)
			carpdetach(sc);

		/* attach carp interface to physical interface */
		if (ncif != NULL)
			ifp->if_carp = (caddr_t)ncif;
		sc->sc_carpdev = ifp;
		sc->sc_if.if_capabilities = ifp->if_capabilities &
		    IFCAP_CSUM_MASK;
d1687 7
a1693 7
		TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list) {
			if (vr == sc)
				myself = 1;
			if (LIST_FIRST(&vr->carp_vhosts)->vhid <
			    LIST_FIRST(&sc->carp_vhosts)->vhid)
				after = vr;
		}
d1695 22
a1716 9
		if (!myself) {
			/* We're trying to keep things in order */
			if (after == NULL) {
				TAILQ_INSERT_TAIL(&cif->vhif_vrs, sc, sc_list);
			} else {
				TAILQ_INSERT_AFTER(&cif->vhif_vrs, after,
				    sc, sc_list);
			}
			cif->vhif_nvrs++;
d1718 1
a1718 11
		if (sc->sc_naddrs || sc->sc_naddrs6)
			sc->sc_if.if_flags |= IFF_UP;
		carp_set_enaddr(sc);
		s = splnet();
		sc->lh_cookie = hook_establish(ifp->if_linkstatehooks, 1,
		    carp_carpdev_state, ifp);
		carp_carpdev_state(ifp);
		splx(s);
	} else {
		carpdetach(sc);
		sc->sc_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
d1720 9
@


1.253
log
@Add the necessary glue to keep carp(4) working while other pseudo-drivers
are converted to if_input(), this time without breaking parent-less setup.

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.252 2015/04/21 09:35:32 mpi Exp $	*/
d753 1
@


1.252
log
@Revert previous.  Packets going through carp_input() but not destinated
to the carp interface would end up enqueued without being decapsulated.

Found the hard way by shten@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.251 2015/04/15 15:16:17 mpi Exp $	*/
d1419 1
a1419 1
	struct ether_header eh;
d1423 3
a1425 1
	memcpy(&eh, eh0, sizeof(eh));
d1427 1
a1427 3
	if ((ifp = carp_ourether(cif, eh0->ether_dhost)))
		;
	else if (m->m_flags & (M_BCAST|M_MCAST)) {
d1441 6
d1450 2
a1451 2
				bpf_mtap_hdr(vh->sc_if.if_bpf, (char *)&eh,
				    ETHER_HDR_LEN, m0, BPF_DIRECTION_IN, NULL);
d1454 1
a1454 1
			ether_input(m0, &eh);
d1456 1
d1460 5
a1464 2
	if (ifp == NULL)
		return (1);
d1470 1
a1470 2
		bpf_mtap_hdr(ifp->if_bpf, (char *)&eh, ETHER_HDR_LEN, m,
		    BPF_DIRECTION_IN, NULL);
d1473 1
a1473 1
	ether_input(m, &eh);
@


1.251
log
@Add the necessary glue to keep carp(4) working while other pseudo-drivers
are converted to if_input().

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.250 2015/04/15 15:14:37 mpi Exp $	*/
d1419 1
a1419 1
	struct ether_header *eh;
d1423 1
a1423 5
	M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
	if (m == NULL)
		return (-1);
	eh = mtod(m, struct ether_header *);
	memmove(eh, eh0, sizeof(*eh));
d1444 2
a1445 2
				bpf_mtap_ether(vh->sc_if.if_bpf, m,
				    BPF_DIRECTION_IN);
d1448 1
a1448 1
			ether_input_mbuf(&vh->sc_if, m0);
d1460 2
a1461 1
		bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1464 1
a1464 1
	ether_input_mbuf(ifp, m);
@


1.250
log
@Use ether_ifattach() and ether_ifdetach() when cloning/destroying an
interface instead of rewritting most of them.

This change is also needed for upcoming if_input() conversion.

As a bonus pseudo-driver attached on top of carp are now detached in
the right order.

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.249 2015/04/07 10:46:20 mpi Exp $	*/
d1419 1
a1419 1
	struct ether_header eh;
d1423 5
a1427 1
	memcpy(&eh, eh0, sizeof(eh));
d1448 2
a1449 2
				bpf_mtap_hdr(vh->sc_if.if_bpf, (char *)&eh,
				    ETHER_HDR_LEN, m0, BPF_DIRECTION_IN, NULL);
d1452 1
a1452 1
			ether_input(m0, &eh);
d1464 1
a1464 2
		bpf_mtap_hdr(ifp->if_bpf, (char *)&eh, ETHER_HDR_LEN, m,
		    BPF_DIRECTION_IN, NULL);
d1467 1
a1467 1
	ether_input(m, &eh);
@


1.249
log
@Do not pass an `ifp' argument to interface input handlers since it
might be overwritten by pseudo-drivers.

ok dlg@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.248 2015/03/14 03:38:51 jsg Exp $	*/
a747 5
	ifp->if_output = carp_output;
	ifp->if_type = IFT_CARP;
	ifp->if_addrlen = ETHER_ADDR_LEN;
	ifp->if_hdrlen = ETHER_HDR_LEN;
	ifp->if_mtu = ETHERMTU;
d751 3
a753 6

	if_alloc_sadl(ifp);
	LIST_INIT(&sc->sc_ac.ac_multiaddrs);
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, ETHER_HDR_LEN);
#endif
a799 2
	struct arpcom *ac = (struct arpcom *)ifp;
	struct ether_multi *enm;
d802 1
a802 9

	/* XXX should be converted to ether_ifattach() and ether_ifdetach() */
	for (enm = LIST_FIRST(&ac->ac_multiaddrs);
	    enm != NULL;
	    enm = LIST_FIRST(&ac->ac_multiaddrs)) {
		LIST_REMOVE(enm, enm_list);
		free(enm, M_IFMADDR, 0);
	}

@


1.248
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.247 2015/03/04 10:59:52 mpi Exp $	*/
d1466 1
a1466 1
			ether_input(&vh->sc_if, &eh, m0);
d1482 1
a1482 1
	ether_input(ifp, &eh, m);
@


1.247
log
@Explicitly fallback to a carp IP address if the parent does not have any
configured IP address when sending AD.

Previously ip_output() was doing this magic for us and ip6_output() was
failing, making it impossible to send AD if the parent did not have an
IPv6 address.

Fix a regression found the hardway by benno@@ introduced by the move to
NOINET6 by default.

ok benno@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.246 2015/02/11 04:29:29 mpi Exp $	*/
a65 1
#include <net/if_enc.h>
@


1.246
log
@Until carp(4) is converted to call ether_ifattach() and ether_ifdetach(),
reroll the loop to free its Ethernet multicast addresses when destroying
an interface.

Prevent a panic found the hard way by phessler@@

ok henning@@, pelikan@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.245 2015/01/21 11:20:48 mpi Exp $	*/
d1039 1
d1042 3
a1044 4
			ip->ip_src.s_addr = 0;
		else
			ip->ip_src.s_addr =
			    ifatoia(ifa)->ia_addr.sin_addr.s_addr;
d1126 1
d1128 5
a1132 5
		if (ifa == NULL)	/* This should never happen with IPv6 */
			memset(&ip6->ip6_src, 0, sizeof(struct in6_addr));
		else
			bcopy(ifatoia6(ifa)->ia_addr.sin6_addr.s6_addr,
			    &ip6->ip6_src, sizeof(struct in6_addr));
@


1.245
log
@Remove the code to automagically find a "carpdev".

The half-backed logic to find a parent interface before configuring an
address on a carp(4) interface is responsible for too many layers of
complexity resulting in various breakages everytime something change in
the stack.

So make carp(4) a bit less special.  It now requires a parent interface
like all the other pseudo-devices.

ok mikeb@@, dlg@@, florian@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.244 2015/01/08 10:55:45 mpi Exp $	*/
d809 2
d813 9
a821 1
	ether_ifdetach(ifp);
@


1.244
log
@Do not unconditionally set a link-local address.

carp(4) has a hack to update its Ethernet address which was also
generating the corresponding IPv6 link-local address.  Since the
removal of the NOINET6 flag, this link-local address was generated
even if no IPv6 address has been configured on the interface.

This unbreak carp setup without v6 addresses, found the hard way by
sebastia@@.

ok sebastia@@, benno@@, stsp@@, @@phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.243 2014/12/19 17:14:40 tedu Exp $	*/
a1851 1
	struct ifnet *ifp = NULL;
d1853 3
a1855 3
	struct ifaddr *ifa;
	struct in_ifaddr *ia;
	int error = 0;
a1858 4
		if (!(sc->sc_if.if_flags & IFF_UP))
			carp_set_state_all(sc, INIT);
		if (sc->sc_naddrs)
			sc->sc_if.if_flags |= IFF_UP;
a1862 31
	/* we have to do this by hand to ensure we don't match on ourselves */
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		/* and, yeah, we need a multicast-capable iface too */
		if ((ifp->if_type == IFT_CARP) ||
		    (ifp->if_flags & IFF_MULTICAST) == 0 ||
		    (ifp->if_rdomain != sc->sc_if.if_rdomain))
			continue;

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET)
				continue;

			ia = ifatoia(ifa);
			if ((in->s_addr & ia->ia_netmask) == ia->ia_net)
				goto found;
		}
	}

found:
	if (ifp == NULL)
		ifp = sc->sc_carpdev;

	if (sc->sc_carpdev != NULL && ifp != sc->sc_carpdev)
		return (EADDRNOTAVAIL);

	if ((error = carp_set_ifp(sc, ifp)))
		return (error);

	if (sc->sc_carpdev == NULL)
		return (EADDRNOTAVAIL);

a1865 3
	if (sc->sc_carpdev != NULL)
		sc->sc_if.if_flags |= IFF_UP;

d1898 3
a1900 4
	struct ifnet *ifp = sc->sc_carpdev;
	struct ifaddr *ifa;
	struct in6_ifaddr *ia6;
	int i, error = 0;
a1902 4
		if (!(sc->sc_if.if_flags & IFF_UP))
			carp_set_state_all(sc, INIT);
		if (sc->sc_naddrs6)
			sc->sc_if.if_flags |= IFF_UP;
a1906 39
	/* we have to do this by hand to ensure we don't match on ourselves */
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		/* and, yeah, we need a multicast-capable iface too */
		if ((ifp->if_type == IFT_CARP) ||
		    (ifp->if_flags & IFF_MULTICAST) == 0 ||
		    (ifp->if_rdomain != sc->sc_if.if_rdomain))
			continue;

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;

			ia6 = ifatoia6(ifa);
			for (i = 0; i < 4; i++) {
				if ((sin6->sin6_addr.s6_addr32[i] &
				    ia6->ia_prefixmask.sin6_addr.s6_addr32[i]) !=
				    (ia6->ia_addr.sin6_addr.s6_addr32[i] &
				    ia6->ia_prefixmask.sin6_addr.s6_addr32[i]))
					break;
			}

			if (i == 4)
				goto found;
		}
	}

found:
	if (ifp == NULL)
		ifp = sc->sc_carpdev;

	if (sc->sc_carpdev != NULL && ifp != sc->sc_carpdev)
		return (EADDRNOTAVAIL);

	if ((error = carp_set_ifp(sc, ifp)))
		return (error);

	if (sc->sc_carpdev == NULL)
		return (EADDRNOTAVAIL);

a1909 3
	if (sc->sc_carpdev != NULL)
		sc->sc_if.if_flags |= IFF_UP;

d1972 1
a1972 1
	int s, i, error = 0;
d1976 3
a1978 1
		s = splnet();
a1981 4
			/*
			 * emulate arp_ifinit() without doing a gratuitous arp
			 * request so that the routes are setup correctly.
			 */
a1982 1

a1995 1
		splx(s);
@


1.243
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.242 2014/12/17 09:57:13 mpi Exp $	*/
d1788 2
a1789 1
		in6_ifattach_linklocal(&sc->sc_if, NULL);
@


1.242
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.241 2014/12/17 09:45:59 mpi Exp $	*/
a58 1
#ifdef INET
a67 1
#endif
a306 1
#ifdef INET
a325 1
#endif /* INET */
a998 1
#ifdef INET
a1087 1
#endif /* INET */
a1593 1
#ifdef INET
a1596 1
#endif /* INET */
a2062 1
#ifdef INET
a2072 1
#endif /* INET */
@


1.241
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.240 2014/12/05 15:50:04 mpi Exp $	*/
d738 1
a738 1
	sc->sc_im6o.im6o_multicast_hlim = CARP_DFLTTL;
d1934 2
a1935 2
	imo->imo_multicast_ttl = CARP_DFLTTL;
	imo->imo_multicast_loop = 0;
@


1.240
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.239 2014/11/20 15:55:04 tedu Exp $	*/
d1646 1
a1646 1
	imo->imo_multicast_ifp = NULL;
d1656 1
a1656 1
	im6o->im6o_multicast_ifp = NULL;
d1933 1
a1933 1
	imo->imo_multicast_ifp = &sc->sc_if;
d2042 1
a2042 1
	im6o->im6o_multicast_ifp = &sc->sc_if;
@


1.239
log
@sizes for simple free cases. sizeof(*) and one case where len is clear.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.238 2014/11/18 02:37:31 tedu Exp $	*/
d53 1
@


1.238
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.237 2014/11/03 11:43:47 gerhard Exp $	*/
d729 1
a729 1
		free(sc, M_DEVBUF, 0);
d818 1
a818 1
	free(sc, M_DEVBUF, 0);
d865 1
a865 1
			free(cif, M_IFADDR, 0);
d893 1
a893 1
		free(vhe, M_DEVBUF, 0);
d1685 1
a1685 1
				free(ncif, M_IFADDR, 0);
d2532 1
a2532 1
	mc = malloc(sizeof(struct carp_mc_entry), M_DEVBUF, M_NOWAIT);
d2555 1
a2555 1
	free(mc, M_DEVBUF, 0);
d2602 1
a2602 1
		free(mc, M_DEVBUF, 0);
d2634 1
a2634 1
		free(mc, M_DEVBUF, 0);
@


1.237
log
@Fix kernel stack overflow by preventing carp_send_ad_all() from re-entrant
calls. Also, when adjusting demote counts, don't call carp_send_ad_all()
for every ifgroup with a demote count of 1 but rather call it only once
after adjusting the demote counts of all ifgroups.

ok bluhm@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.236 2014/10/07 08:47:28 mpi Exp $	*/
a54 3

/* for arc4random() */
#include <dev/rndvar.h>
@


1.236
log
@Do not protect the SIOCSIFADDR call by splnet().  Drivers already
raise it inside their ioctl handler (except for carp(4), what else?).

In general, global structures manipulated in the softnet codepath only
require a splsoftnet() protection when they are modified in process
(ioctl) context.

Also put some IPL_SOFNET asserts in functions accessing global structures.

Previous version diff ok mikeb@@, with inputs from and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.235 2014/09/28 14:26:42 reyk Exp $	*/
d173 2
d930 3
d945 1
d2433 1
a2433 1
	int *dm;
d2444 1
d2456 1
a2456 1
			carp_send_ad_all();
d2462 2
@


1.235
log
@Remove a limitation that ignored IPv6 link-local addresses on carp(4).
This workaround was needed when the interface link-local address was
still enabled by default to prevent immediate state transition on
interfaces without any configured addresses.  This is not needed
anymore and removing the limitation allows to use carp(4) with
addresses like fe80::2%carp0.

discussed with some
ok mpi@@ pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.234 2014/09/08 06:24:13 jsg Exp $	*/
d2061 1
a2061 1
	int i, error = 0;
d2065 1
d2090 1
@


1.234
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.233 2014/07/22 11:06:10 mpi Exp $	*/
d1810 1
a1810 2
		else if (ifa->ifa_addr->sa_family == AF_INET6 &&
		    !IN6_IS_ADDR_LINKLOCAL(&ifatoia6(ifa)->ia_addr.sin6_addr))
@


1.233
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.232 2014/07/12 18:44:23 tedu Exp $	*/
a53 1
#include <net/route.h>
@


1.232
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.231 2014/07/09 09:30:49 henning Exp $	*/
a63 1
#include <netinet/in_systm.h>
@


1.231
log
@bpf code surgery / shuffling / simplification.
the various bpf_mtap_* are very similiar, they differ in what (and to some
extent how) they prepend something, and what copy function they pass to
bpf_catchpacket.
use an internal _bpf_mtap as "backend" for bpf_mtap and friends.
extend bpf_mtap_hdr so that it covers all common cases:
if dlen is 0, nothing gets prepended.
copy function can be given, if NULL the default bpf_mcopy is used.
adjust the existing bpf_mtap_hdr users to pass a NULL ptr for the copy fn.
re-implement bpf_mtap_af as simple wrapper for bpf_mtap_hdr.
re-implement bpf_mtap_ether using bpf_map_hdr
re-implement bpf_mtap_pflog as trivial bpf_mtap_hdr wrapper
ok bluhm benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.229 2014/04/30 10:04:33 mpi Exp $	*/
d732 1
a732 1
		free(sc, M_DEVBUF);
d820 2
a821 2
	free(sc->sc_imo.imo_membership, M_IPMOPTS);
	free(sc, M_DEVBUF);
d868 1
a868 1
			free(cif, M_IFADDR);
d896 1
a896 1
		free(vhe, M_DEVBUF);
d1684 1
a1684 1
				free(ncif, M_IFADDR);
d2550 1
a2550 1
	free(mc, M_DEVBUF);
d2597 1
a2597 1
		free(mc, M_DEVBUF);
d2629 1
a2629 1
		free(mc, M_DEVBUF);
@


1.230
log
@Kill dead code, what does a negative number of addresses on a carp(4)
mean?

ok deraadt@@
@
text
@d1457 1
a1457 1
				    ETHER_HDR_LEN, m0, BPF_DIRECTION_IN);
d1473 1
a1473 1
		    BPF_DIRECTION_IN);
@


1.229
log
@Remove carp_seroute() it no longer does anything useful but mess with
your IPv4 routes.

mcbride@@ says that this function has been introduced in order to be able
to reach the MASTER node from a BACKUP node using the CARP address. The
reasons are:

1) For troubleshooting, so I can ping or otherwise monitor the MASTER
host.

2) In some cases it's undesirable (or even not possible) to run
services on other IP addresses. For example, services that only allow
you to configure 1 listening IP, or services where you wish to avoid
users connecting to anything but the MASTER server.

Sadly this function becames a horrible hack.  So if somebody thinks the
reasons explained before justify such logic, feel free to submit a
correct diff.

ok bluhm@@, henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.228 2014/04/21 12:22:26 henning Exp $	*/
a1698 18

		/* join multicast groups */
		if (sc->sc_naddrs < 0 &&
		    (error = carp_join_multicast(sc)) != 0) {
			if (ncif != NULL)
				free(ncif, M_IFADDR);
			return (error);
		}

#ifdef INET6
		if (sc->sc_naddrs6 < 0 &&
		    (error = carp_join_multicast6(sc)) != 0) {
			if (ncif != NULL)
				free(ncif, M_IFADDR);
			carp_multicast_cleanup(sc);
			return (error);
		}
#endif
@


1.228
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.227 2014/04/20 14:54:39 henning Exp $	*/
a200 1
void	carp_setroute(struct carp_softc *, int);
a397 118
void
carp_setroute(struct carp_softc *sc, int cmd)
{
	struct ifaddr *ifa;
	int s;

	/* XXX this mess needs fixing */

	s = splsoftnet();
	TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET: {
			int error;
			struct sockaddr sa;
			struct rtentry *rt;
			struct radix_node_head *rnh;
			struct radix_node *rn;
			struct rt_addrinfo info;
			int hr_otherif, nr_ourif;
			struct sockaddr_rtlabel	sa_rl;
			const char *label;

			/* Remove the existing host route, if any */
			memset(&info, 0, sizeof(info));
			info.rti_info[RTAX_DST] = ifa->ifa_addr;
			info.rti_flags = RTF_HOST;
			error = rtrequest1(RTM_DELETE, &info, RTP_CONNECTED,
			    NULL, sc->sc_if.if_rdomain);
			rt_missmsg(RTM_DELETE, &info, info.rti_flags, NULL,
			    error, sc->sc_if.if_rdomain);

			/* Check for our address on another interface */
			/* XXX cries for proper API */
			rnh = rtable_get(sc->sc_if.if_rdomain,
			    ifa->ifa_addr->sa_family);
			rn = rnh->rnh_matchaddr(ifa->ifa_addr, rnh);
			rt = (struct rtentry *)rn;
			hr_otherif = (rt && rt->rt_ifp != &sc->sc_if &&
			    rt->rt_flags & (RTF_CLONING|RTF_CLONED));

			/* Check for a network route on our interface */
			bcopy(ifa->ifa_addr, &sa, sizeof(sa));
			satosin(&sa)->sin_addr.s_addr = satosin(ifa->ifa_netmask
			    )->sin_addr.s_addr & satosin(&sa)->sin_addr.s_addr;
			rt = rt_lookup(&sa,
			    ifa->ifa_netmask, sc->sc_if.if_rdomain);
			nr_ourif = (rt && rt->rt_ifp == &sc->sc_if);

			/* Restore the route label */
			memset(&sa_rl, 0, sizeof(sa_rl));
			if (rt && rt->rt_labelid) {
				sa_rl.sr_len = sizeof(sa_rl);
				sa_rl.sr_family = AF_UNSPEC;
				label = rtlabel_id2name(rt->rt_labelid);
				if (label != NULL)
					strlcpy(sa_rl.sr_label, label,
					    sizeof(sa_rl.sr_label));
			}

			switch (cmd) {
			case RTM_ADD:
				if (hr_otherif) {
					ifa->ifa_rtrequest = NULL;
					memset(&info, 0, sizeof(info));
					info.rti_info[RTAX_DST] = ifa->ifa_addr;
					info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
					info.rti_flags = RTF_UP | RTF_HOST;
					error = rtrequest1(RTM_ADD, &info,
					    RTP_CONNECTED, NULL,
					    sc->sc_if.if_rdomain);
					rt_missmsg(RTM_ADD, &info,
					    info.rti_flags, &sc->sc_if,
					    error, sc->sc_if.if_rdomain);
				}
				if (!hr_otherif || nr_ourif || !rt) {
					if (nr_ourif && !(rt->rt_flags &
					    RTF_CLONING)) {
						memset(&info, 0, sizeof(info));
						info.rti_info[RTAX_DST] = &sa;
						info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;
						error = rtrequest1(RTM_DELETE,
						    &info, RTP_CONNECTED, NULL,
						    sc->sc_if.if_rdomain);
						rt_missmsg(RTM_DELETE, &info, info.rti_flags, NULL,
						    error, sc->sc_if.if_rdomain);
					}

					ifa->ifa_rtrequest = arp_rtrequest;

					memset(&info, 0, sizeof(info));
					info.rti_info[RTAX_DST] = &sa;
					info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
					info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;
					info.rti_info[RTAX_LABEL] =
					    (struct sockaddr *)&sa_rl;
					error = rtrequest1(RTM_ADD, &info,
					    RTP_CONNECTED, NULL, 
					    sc->sc_if.if_rdomain);
					if (error == 0)
						ifa->ifa_flags |= IFA_ROUTE;
					rt_missmsg(RTM_ADD, &info, info.rti_flags,
					    &sc->sc_if, error, sc->sc_if.if_rdomain);
				}
				break;
			case RTM_DELETE:
				break;
			default:
				break;
			}
			break;
		}
		default:
			break;
		}
	}
	splx(s);
}

a632 2
			if (vhe->vhe_leader)
				carp_setroute(sc, RTM_DELETE);
a1536 2
		if (vhe->vhe_leader)
			carp_setroute(sc, RTM_ADD);
a1577 2
		if (vhe->vhe_leader)
			carp_setroute(sc, RTM_DELETE);
a1583 2
		if (vhe->vhe_leader)
			carp_setroute(sc, RTM_DELETE);
a2152 1
				carp_setroute(sc, RTM_DELETE);
@


1.227
log
@ether_output: instead of assembling the ethernet header and then calling
carp_rewrite_lladdr to overwrite the src lladdr, get the intended src
lladdr before assembling the ethernet header.
carp_rewrite_lladdr -> carp_get_srclladdr
ok reyk claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.225 2014/03/27 10:39:23 mpi Exp $	*/
d1178 1
a1178 1
		    NULL);
@


1.226
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1522 2
a1523 2
void
carp_rewrite_lladdr(struct ifnet *ifp, u_int8_t *s_enaddr)
d1530 1
a1530 2
			bcopy((caddr_t)sc->sc_ac.ac_enaddr,
			    (caddr_t)s_enaddr, ETHER_ADDR_LEN);
d1532 1
a1532 2
			bcopy((caddr_t)sc->cur_vhe->vhe_enaddr,
			    (caddr_t)s_enaddr, ETHER_ADDR_LEN);
d1534 1
@


1.225
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.224 2014/03/21 13:48:28 mpi Exp $	*/
d1136 1
a1136 1
		m->m_pkthdr.rdomain = sc->sc_if.if_rdomain;
d1228 1
a1228 1
		m->m_pkthdr.rdomain = sc->sc_if.if_rdomain;
@


1.224
log
@Global lists of addresses are species near extinction, even carp do
not like them!

Since carp(4) interfaces do some magic tricks to find a compatible
interface if you do not specify a `carpdev' argument, make them
iterate over &ifnet instead of &in{,6}_ifaddr.

ok benno@@, mikeb@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.223 2014/03/18 10:47:34 mpi Exp $	*/
a461 1
					ifa->ifa_flags &= ~RTF_CLONING;
a486 1
					ifa->ifa_flags |= RTF_CLONING;
a2222 1
			ifa->ifa_flags |= RTF_CLONING;
@


1.223
log
@Rename rt_gettable() into rtable_get(), swap its arguments to be
coherent with the existing rtable_* functions and document it.

While here fix some other manpage glitches pointed out by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.222 2014/02/13 10:31:42 mpi Exp $	*/
d2006 3
a2008 1
	struct ifnet *ifp = sc->sc_carpdev;
d2013 1
a2013 1
	if (sin->sin_addr.s_addr == 0) {
d2023 1
a2023 1
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
d2025 8
a2032 7
		if (ia->ia_ifp != &sc->sc_if &&
		    ia->ia_ifp->if_type != IFT_CARP &&
		    (ia->ia_ifp->if_flags & IFF_MULTICAST) &&
		    ia->ia_ifp->if_rdomain == sc->sc_if.if_rdomain &&
		    (sin->sin_addr.s_addr & ia->ia_netmask) == ia->ia_net)
			break;
	}
d2034 3
a2036 6
	if (ia) {
		if (ifp) {
			if (ifp != ia->ia_ifp)
				return (EADDRNOTAVAIL);
		} else {
			ifp = ia->ia_ifp;
d2040 7
d2092 1
d2094 1
a2094 1
	int error = 0;
d2106 19
a2124 2
	TAILQ_FOREACH(ia6, &in6_ifaddr, ia_list) {
		int i;
d2126 2
a2127 6
		for (i = 0; i < 4; i++) {
			if ((sin6->sin6_addr.s6_addr32[i] &
			    ia6->ia_prefixmask.sin6_addr.s6_addr32[i]) !=
			    (ia6->ia_addr.sin6_addr.s6_addr32[i] &
			    ia6->ia_prefixmask.sin6_addr.s6_addr32[i]))
				break;
a2128 7
		/* and, yeah, we need a multicast-capable iface too */
		if (ia6->ia_ifp != &sc->sc_if &&
		    ia6->ia_ifp->if_type != IFT_CARP &&
		    (ia6->ia_ifp->if_flags & IFF_MULTICAST) &&
		    ia6->ia_ifp->if_rdomain == sc->sc_if.if_rdomain &&
		    (i == 4))
			break;
d2131 6
a2136 8
	if (ia6) {
		if (sc->sc_carpdev) {
			if (sc->sc_carpdev != ia6->ia_ifp)
				return (EADDRNOTAVAIL);
		} else {
			ifp = ia6->ia_ifp;
		}
	}
@


1.222
log
@When sending a neighbor advertisement, correctly use the carp mac
address and not the mac of the physical interface as target lladdr.

This allows us to get rid of the hack adding and removing the route to
loopback of a carp node when its status switch to master and backup
respectively.  Now the route entry will no longer be updated to use the
mac address of the physical interface of the master node as gateway.

While here send the ARP request through the carp interface for consistency.

Analysed with and ok mikeb@@, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.221 2014/02/07 22:22:37 stsp Exp $	*/
d432 2
a433 2
			rnh = rt_gettable(ifa->ifa_addr->sa_family,
			    sc->sc_if.if_rdomain);
@


1.221
log
@Make carp send IPv6 neighbour advertisements with the 'router' flag
if we're acting as router. Otherwise clients lose the default route
learned from router advertisements during carp failover.
Patch by Ole Myhre; ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.220 2014/01/22 09:35:20 mpi Exp $	*/
a511 11

#ifdef INET6
		case AF_INET6:
			if (sc->sc_balancing >= CARP_BAL_IP)
				continue;
			if (cmd == RTM_ADD)
				in6_ifaddloop(ifa);
			else
				in6_ifremloop(ifa);
			break;
#endif /* INET6 */
d1322 1
a1322 1
		arprequest(sc->sc_carpdev, &in, &in, sc->sc_ac.ac_enaddr);
d1343 1
a1343 1
		nd6_na_output(sc->sc_carpdev, &mcast, in6,
@


1.220
log
@Pass the receiving interface pointer to carp_input() instead of re-
reading it from the packet header.  While here makes carp_input()
take the same arguments as ether_input().

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.219 2014/01/13 23:03:52 bluhm Exp $	*/
d1355 2
a1356 1
		    ND_NA_FLAG_OVERRIDE, 1, NULL);
@


1.219
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.218 2014/01/09 06:29:06 tedu Exp $	*/
d1563 1
a1563 1
carp_input(struct mbuf *m, u_int8_t *shost, u_int8_t *dhost, u_int16_t etype)
d1566 1
a1566 1
	struct carp_if *cif = (struct carp_if *)m->m_pkthdr.rcvif->if_carp;
d1569 1
a1569 3
	bcopy(shost, &eh.ether_shost, sizeof(eh.ether_shost));
	bcopy(dhost, &eh.ether_dhost, sizeof(eh.ether_dhost));
	eh.ether_type = etype;
d1571 1
a1571 1
	if ((ifp = carp_ourether(cif, dhost)))
@


1.218
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.217 2013/11/28 09:36:37 mpi Exp $	*/
d2097 1
a2097 1
	struct in6_ifaddr *ia;
d2110 1
a2110 1
	TAILQ_FOREACH(ia, &in6_ifaddr, ia_list) {
d2115 3
a2117 3
			    ia->ia_prefixmask.sin6_addr.s6_addr32[i]) !=
			    (ia->ia_addr.sin6_addr.s6_addr32[i] &
			    ia->ia_prefixmask.sin6_addr.s6_addr32[i]))
d2121 4
a2124 4
		if (ia->ia_ifp != &sc->sc_if &&
		    ia->ia_ifp->if_type != IFT_CARP &&
		    (ia->ia_ifp->if_flags & IFF_MULTICAST) &&
		    ia->ia_ifp->if_rdomain == sc->sc_if.if_rdomain &&
d2129 1
a2129 1
	if (ia) {
d2131 1
a2131 1
			if (sc->sc_carpdev != ia->ia_ifp)
d2134 1
a2134 1
			ifp = ia->ia_ifp;
@


1.217
log
@Use the local variable referencing the receiving interface instead of
dereferencing the mbuf various times. No functional change.

ok mpf@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.216 2013/11/21 16:16:08 mpi Exp $	*/
d284 1
a284 1
	bzero(vhe->vhe_pad, sizeof(vhe->vhe_pad));
d305 1
a305 1
	    bcmp(sc->sc_ac.ac_enaddr, vhe->vhe_enaddr, ETHER_ADDR_LEN) != 0)
d422 1
a422 1
			bzero(&info, sizeof(info));
d448 1
a448 1
			bzero(&sa_rl, sizeof(sa_rl));
d463 1
a463 1
					bzero(&info, sizeof(info));
d477 1
a477 1
						bzero(&info, sizeof(info));
d490 1
a490 1
					bzero(&info, sizeof(info));
d730 1
a730 1
	if (!bcmp(&vhe->vhe_replay_cookie, ch->carp_counter,
d1164 1
a1164 1
		bzero(&sa, sizeof(sa));
d1246 1
a1246 1
		bzero(ip6, sizeof(*ip6));
d1252 1
a1252 1
		bzero(&sa, sizeof(sa));
d1256 1
a1256 1
			bzero(&ip6->ip6_src, sizeof(struct in6_addr));
d1520 2
a1521 1
				    !bcmp(ena, vhe->vhe_enaddr, ETHER_ADDR_LEN))
d1527 1
a1527 1
			    !bcmp(ena, vh->sc_ac.ac_enaddr, ETHER_ADDR_LEN))
d1558 1
a1558 1
	return(!bcmp(sc->sc_ac.ac_enaddr, d_enaddr, ETHER_ADDR_LEN));
d1705 1
a1705 1
	if (bcmp(((struct arpcom *)sc->sc_carpdev)->ac_enaddr,
d1920 1
a1920 1
		bzero(vhe->vhe_enaddr, ETHER_ADDR_LEN);
d1937 1
a1937 1
	if ((bcmp(sc->sc_ac.ac_enaddr + 1, vhe->vhe_enaddr + 1,
d1945 1
a1945 1
	if (bcmp(sc->sc_ac.ac_enaddr, sc->sc_curlladdr, ETHER_ADDR_LEN) != 0) {
d1996 1
a1996 1
				bzero(&sc->sc_imo, sizeof(sc->sc_imo));
d2164 1
a2164 1
	bzero(&addr6, sizeof(addr6));
d2175 1
a2175 1
	bzero(&addr6.sin6_addr, sizeof(addr6.sin6_addr));
d2305 1
a2305 1
		if (bcmp(sc->sc_advskews, carpr.carpr_advskews,
d2333 1
a2333 1
		bzero(&carpr, sizeof(carpr));
d2372 1
a2372 1
	if (bcmp(sc->sc_ac.ac_enaddr, sc->sc_curlladdr, ETHER_ADDR_LEN) != 0)
d2411 1
a2411 1
	    !bcmp(sc->sc_vhids, carpr->carpr_vhids, sizeof(sc->sc_vhids)))
d2414 1
a2414 1
	bzero(taken_vhids, sizeof(taken_vhids));
d2439 1
a2439 1
	bzero(sc->sc_vhids, sizeof(sc->sc_vhids));
@


1.216
log
@Remove unneeded include.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.215 2013/10/28 12:33:32 mpi Exp $	*/
d562 3
a564 2
		CARP_LOG(LOG_INFO, sc, ("packet received on non-carp interface: %s",
		    m->m_pkthdr.rcvif->if_xname));
d572 2
a573 2
		CARP_LOG(LOG_NOTICE, sc, ("received ttl %d != %d on %s", ip->ip_ttl,
		    CARP_DFLTTL, m->m_pkthdr.rcvif->if_xname));
d586 2
a587 2
		CARP_LOG(LOG_INFO, sc, ("packet too short %d on %s", m->m_pkthdr.len,
		    m->m_pkthdr.rcvif->if_xname));
d604 1
a604 1
		    m->m_pkthdr.rcvif->if_xname));
d618 1
d632 1
a632 1
	if (m->m_pkthdr.rcvif->if_type != IFT_CARP) {
d635 1
a635 1
		    m->m_pkthdr.rcvif->if_xname));
d643 2
a644 2
		CARP_LOG(LOG_NOTICE, sc, ("received ttl %d != %d on %s", ip6->ip6_hlim,
		    CARP_DFLTTL, m->m_pkthdr.rcvif->if_xname));
d663 1
a663 1
		    m->m_pkthdr.rcvif->if_xname));
@


1.215
log
@tedu FDDI support and the 3 flavors the driver for DEC devices, even
miod@@ cannot find two boards using the same media.

With precious punctuation review from guenther@@, thanks!

ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.214 2013/10/20 11:03:01 phessler Exp $	*/
a53 1
#include <net/if_llc.h>
@


1.214
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.213 2013/10/19 16:09:53 bluhm Exp $	*/
a59 4

#if NFDDI > 0
#include <net/if_fddi.h>
#endif
@


1.213
log
@Now carp_set_addr() and carp_set_addr6() break out of the loop after
they have found the interface address, so we can get rid of the
additional variable ia_if.  No functional change.
OK mpi@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.212 2013/10/19 09:23:59 bluhm Exp $	*/
d1244 1
a1244 1
		/* XXX m->m_pkthdr.rdomain = sc->sc_if.if_rdomain; */
d2126 1
@


1.212
log
@In carp_set_addr6() break out of the loop after the interface address
has been found.  This makes the IPv6 code work like IPv4.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.211 2013/10/17 16:27:43 bluhm Exp $	*/
d2021 1
a2021 1
	struct in_ifaddr *ia, *ia_if;
a2034 1
	ia_if = NULL;
d2041 1
a2041 2
		    (sin->sin_addr.s_addr & ia->ia_netmask) == ia->ia_net) {
			ia_if = ia;
a2042 1
		}
d2045 1
a2045 2
	if (ia_if) {
		ia = ia_if;
d2099 1
a2099 1
	struct in6_ifaddr *ia, *ia_if;
a2111 1
	ia_if = NULL;
d2126 1
a2126 2
		    (i == 4)) {
			ia_if = ia;
a2127 1
		}
d2130 1
a2130 2
	if (ia_if) {
		ia = ia_if;
@


1.211
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.210 2013/08/12 06:24:28 bluhm Exp $	*/
d2132 2
a2133 2
			if (!ia_if)
				ia_if = ia;
@


1.210
log
@In the common IPv4 and IPv6 file ip_carp.c an #ifdef INET6 was
missing.  Especially the IN6_IS_ADDR_LINKLOCAL() macro should not
be necessary in IPv4 only code.  No binary change.
OK henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.209 2013/06/20 12:03:40 mpi Exp $	*/
d81 1
@


1.209
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.208 2013/06/20 09:38:24 mpi Exp $	*/
d1972 1
d1976 1
@


1.208
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.207 2013/06/18 09:23:33 mpi Exp $	*/
d907 1
a907 1
	sc->ah_cookie = hook_establish(&sc->sc_if.if_addrhooks, 0,
d994 1
a994 1
		hook_disestablish(&sc->sc_if.if_addrhooks, sc->ah_cookie);
d997 1
a997 1
			hook_disestablish(&sc->sc_carpdev->if_linkstatehooks,
d1890 1
a1890 1
		sc->lh_cookie = hook_establish(&ifp->if_linkstatehooks, 1,
@


1.207
log
@Use TAILQ_FOREACH() instead of handrolling our own version and stop
iterating once we found a matching address.

ok mpf@@, yasuoka@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.206 2013/06/03 17:19:40 yasuoka Exp $	*/
d907 1
a907 1
	sc->ah_cookie = hook_establish(sc->sc_if.if_addrhooks, 0,
d994 1
a994 1
		hook_disestablish(sc->sc_if.if_addrhooks, sc->ah_cookie);
d997 1
a997 1
			hook_disestablish(sc->sc_carpdev->if_linkstatehooks,
d1890 1
a1890 1
		sc->lh_cookie = hook_establish(ifp->if_linkstatehooks, 1,
@


1.206
log
@fix typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.205 2013/06/02 15:03:32 yasuoka Exp $	*/
d2033 1
a2033 3
	for (ia = TAILQ_FIRST(&in_ifaddr); ia;
	    ia = TAILQ_NEXT(ia, ia_list)) {

d2039 3
a2041 4
		    (sin->sin_addr.s_addr & ia->ia_netmask) ==
		    ia->ia_net) {
			if (!ia_if)
				ia_if = ia;
@


1.205
log
@Exclude the mac address for the HMAC calculation if lladdr is the real
one so that we can use the real MAC address for carp(4) like an example
following.

  ifconfig carp0 carpdev REALIF lladdr <real interface's lladdr>

ok reyk mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.204 2013/03/28 23:10:05 tedu Exp $	*/
d2230 1
a2230 1
			 * emulate arp_ifinit() without doing a gratious arp
@


1.204
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.203 2013/03/28 16:55:27 deraadt Exp $	*/
d168 1
d308 2
a309 2
	if (vhe->vhe_leader && bcmp(sc->sc_ac.ac_enaddr, vhe->vhe_enaddr,
	    ETHER_ADDR_LEN) != 0)
d1705 6
@


1.203
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.202 2013/03/28 16:45:16 tedu Exp $	*/
d44 1
@


1.202
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.201 2013/03/26 13:19:26 mpi Exp $	*/
a49 2

#include <machine/cpu.h>
@


1.201
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.200 2013/03/25 14:40:56 mpi Exp $	*/
a39 1
#include <sys/proc.h>
@


1.200
log
@Substitute the handcrafted list of IPv6 addresses by a proper TAILQ.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.199 2013/03/22 01:41:12 tedu Exp $	*/
d897 1
a897 1
	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
@


1.199
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.198 2012/10/08 18:48:25 camield Exp $	*/
d2112 1
a2112 1
	for (ia = in6_ifaddr; ia; ia = ia->ia_next) {
@


1.198
log
@Make carp_ourether() shorter and more generic.  Only a mac address
is really needed, instead of an ethernet header and selector.

ok mikeb henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.197 2012/09/19 16:14:01 blambert Exp $	*/
d1031 1
a1031 2
	for (vhe = LIST_FIRST(&sc->carp_vhosts);
	     vhe != LIST_END(&sc->carp_vhosts); vhe = nvhe) {
@


1.197
log
@Make rt_lookup return a pointer to an rtentry struct instead of
to a radix_node struct.

The radix tree pushdown continues.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.196 2012/09/19 15:31:23 henning Exp $	*/
d1511 1
a1511 1
carp_ourether(void *v, struct ether_header *eh, int src)
a1514 6
	u_int8_t *ena;

	if (src)
		ena = (u_int8_t *)&eh->ether_shost;
	else
		ena = (u_int8_t *)&eh->ether_dhost;
d1576 1
a1576 1
	if ((ifp = carp_ourether(cif, &eh, 0)))
@


1.196
log
@inherit IFCAP_CSUM_* from the parent interface
in my tree for a while and I forgot what exactly triggered it, but in one
way or another this comes from the netbsd camp
ok benno mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.194 2011/11/19 13:54:53 mikeb Exp $	*/
d448 1
a448 1
			rt = (struct rtentry *)rt_lookup(&sa,
@


1.195
log
@fix all the suser calls which pass an incorrect p_acflag argument;
figured out by and ok guenther
@
text
@d1867 2
@


1.194
log
@Select a routing table according to the rdomain.  Allows one
to connect to the carp address when the carpdev interface has
an ip address too in the non-default rdomain.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.193 2011/10/30 20:38:55 mpf Exp $	*/
d2273 1
a2273 1
		if ((error = suser(p, p->p_acflag)) != 0)
d2355 1
a2355 1
		if (suser(p, p->p_acflag) == 0)
@


1.193
log
@In the advbase 0 case, we have to use three times
the advskew as the master down timeout.
OK henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.192 2011/10/24 17:48:31 camield Exp $	*/
d437 2
a438 1
			rnh = rt_gettable(ifa->ifa_addr->sa_family, 0);
@


1.192
log
@Lower carp demote count on interface detach, fixes a bug introduced by rev 1.175.

ok henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.191 2011/10/16 21:07:19 mpf Exp $	*/
d1735 2
@


1.191
log
@Use m_pullup() instead of IP6_EXTHDR_GET() to get the carp header
in the v6 input path. IP6_EXTHDR_GET() internally uses m_pulldown(),
which might return a pointer to a different mbuf in the chain.
In this case, carp_cksum() will be called with the wrong mbuf.
This fixes occasional checksum mismatches.
Problem found and initial fix by stsp@@
OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.190 2011/09/06 16:00:22 mpf Exp $	*/
d983 1
a983 1
		carp_group_demote_adj(&sc->sc_if, sc->sc_demote_cnt, "detach");
@


1.190
log
@Properly initialize struct carp_if (especially vhif_nvrs) with M_ZERO.
This lets carp delete IFF_PROMISC on its carpdev upon destroy.
Fix from Stefan Rinkes.
OK sthen, bluhm, deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.189 2011/07/08 19:07:18 henning Exp $	*/
d653 1
a653 2
	IP6_EXTHDR_GET(ch, struct carp_header *, m, *offp, sizeof(*ch));
	if (ch == NULL) {
d658 1
a658 1

@


1.189
log
@mark carp advertisements to be queued at priority 6. losing them is bad,
mkay? ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.188 2011/07/04 03:13:53 mpf Exp $	*/
d1823 1
a1823 1
			ncif = malloc(sizeof(*cif), M_IFADDR, M_NOWAIT);
@


1.188
log
@Don't make copy multicast packets for carp interfaces
that are not up. OK henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.187 2011/07/04 00:37:00 mpf Exp $	*/
d257 1
d1154 1
d1244 1
@


1.187
log
@Allow advbase to be set to zero, which makes it possible to run
with advertisement intervals of less than a second.
This is needed in setups where takover times < 3s are needed.
Don't use this unless you really need it. Running with
too agressive timeouts might lead to false positive
takeovers.
OK mcbride, claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.186 2011/07/03 17:55:25 dhill Exp $	*/
d1590 2
@


1.186
log
@avoid void * pointer arithmetic

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.185 2011/07/03 17:37:48 claudio Exp $	*/
d799 1
a799 1
		if (timercmp(&sc_tv, &ch_tv, <)) {
d1121 4
a1124 1
		tv.tv_usec = advskew * 1000000 / 256;
d1729 4
a1732 1
		tv.tv_usec = vhe->advskew * 1000000 / 256;
d1756 4
a1759 1
		tv.tv_usec = vhe->advskew * 1000000 / 256;
d2299 1
a2299 1
		if (carpr.carpr_advbase > 0) {
@


1.185
log
@Do not use LINK_STATE_UNKNOWN for the INIT state. LINK_STATE_UNKNOWN has
a special meaning and should only be set if the link state is not known
because it is considered as being up. Use LINK_STATE_INVALID instead.
OK mpf@@ mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.184 2011/05/04 16:05:49 blambert Exp $	*/
d599 1
a599 1
	ch = (void *)ip + iplen;
d1175 1
a1175 1
		ch_ptr = (void *)ip + sizeof(*ip);
d1264 1
a1264 1
		ch_ptr = (void *)ip6 + sizeof(*ip6);
@


1.184
log
@Collapse m_pullup and m_pullup2 into a single function, as they're
essentially identical; the only difference being that m_pullup2 is
capable of handling mbuf clusters, but called m_pullup for shorter
lengths (!).

testing dlg@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.183 2011/04/29 12:36:31 mpf Exp $	*/
d909 1
d2561 1
a2561 1
		sc->sc_if.if_link_state = LINK_STATE_UNKNOWN;
@


1.183
log
@The previous reconfiguration change broke IPv6 only setups.
The address hook was only registered for v4 addresses.
We now call hook_establish at interface creation time.
The hook is now disestablished upon interface destroy,
which plugs a tiny memleak.
While there remove redundancy in carp_set_addr6 and sync
it with carp_set_addr.
Bug noticed by todd@@. OK sthen, mikeb (on an earlier version)
OK and some hints by camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.182 2011/04/04 14:25:16 mikeb Exp $	*/
d594 1
a594 1
	if ((m = m_pullup2(m, len)) == NULL) {
@


1.182
log
@install an additional bpf hook in the carp_input so that multicast
and broadcast packets will be caught too; also we need to increment
the incoming packet counter as reminded by claudio.  ok claudio mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.181 2011/03/08 22:53:28 mpf Exp $	*/
d905 5
d992 2
a2054 8
	/*
	 * Hook if_addrhooks so that we get a callback after in_ifinit has run,
	 * to correct any inappropriate routes that it inserted.
	 */
	if (sc->ah_cookie == NULL)
		sc->ah_cookie = hook_establish(sc->sc_if.if_addrhooks, 0,
		    carp_addr_updated, sc);

d2139 1
a2139 1
	if (sc->sc_carpdev != NULL && sc->sc_naddrs6)
d2141 1
a2142 1
	carp_setrun_all(sc, 0);
@


1.181
log
@Fix a subtle carp reconfiguration problem.
Updating the HMAC from the carp_ioctl call does not see the newly
set IP address in the if_addrlist.  The only chance for carp to see
the new address is via the address-hook callback.  This change moves
the detection of address changes entirely into carp_addr_updated.
Furthermore, only call carp_hmac_prepare for the SIOCSVH case.  This
second bug was the reason why the first one went unnoticed for such
a long time.
Problem found and debugging help by camield@@.
OK camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.180 2010/12/21 14:59:14 claudio Exp $	*/
d1583 6
@


1.180
log
@Doh! Forgot to set the rdomain when sending out carp announcements.
With and OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.179 2010/11/26 12:25:52 otto Exp $	*/
d1944 1
a1944 1
				new_naddrs6++;
d1947 2
a1948 2
	/* Handle a callback after SIOCDIFADDR */
	if (new_naddrs < sc->sc_naddrs || new_naddrs6 < sc->sc_naddrs6) {
d1991 1
a2036 1
	sc->sc_naddrs++;
a2133 2
	if (!IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr))
		sc->sc_naddrs6++;
d2314 1
a2360 1
	carp_hmac_prepare(sc);
@


1.179
log
@more useful logging level for demotion adjustments
ok mcbide@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.178 2010/08/26 13:28:15 claudio Exp $	*/
d1141 1
d1231 1
@


1.178
log
@Link local multicast requires a scope (either from the src or dst address)
be more explicit and force it in dst.
OK deraadt@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.177 2010/08/02 10:30:00 matthew Exp $	*/
d2588 1
a2588 1
		CARP_LOG(LOG_NOTICE, nil,
@


1.177
log
@Prevent illegal struct casting by moving AF_INET/AF_INET6 address
family checks before calling ifatoia/ifatoia6.

ok deraadt@@, dlg@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.176 2010/07/20 15:36:03 matthew Exp $	*/
d1250 2
a1251 2
		ip6->ip6_dst.s6_addr8[0] = 0xff;
		ip6->ip6_dst.s6_addr8[1] = 0x02;
@


1.176
log
@Switch some obvious network stack MAC comparisons from bcmp() to
timingsafe_bcmp().

ok deraadt@@; committed over WPA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.175 2010/04/25 17:38:53 mpf Exp $	*/
d323 2
d326 1
a326 2
			if (ifa->ifa_addr->sa_family == AF_INET &&
			    ntohl(in.s_addr) > ntohl(last.s_addr) &&
d344 2
d352 1
a352 2
			if (ifa->ifa_addr->sa_family == AF_INET6 &&
			    memcmp(&in6, &last6, sizeof(in6)) > 0 &&
@


1.175
log
@Properly adjust group demotion counters when groups are added or
removed.  Extend carp demote logging to also show the reason for
the demote.  Return EINVAL instead of ERANGE if a carpdemote request
is out range.  Requested from otto.
OK mcbride, henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.174 2010/01/13 01:26:28 henning Exp $	*/
d395 1
a395 1
		if (!bcmp(md, md2, sizeof(md2)))
@


1.174
log
@let's admit it's not 1992 any more. CIDR is around for a long time, even
that router vendor doesn't default to classful routing any more, and there
really is no point in having a classful netmask and a subnetmask to split
it. we still do classful guesses on the netmask if it isn't supplied by
userland, but that's about it.
i decided to keep ia_netmask and kill ia_subnetmask which makes this diff
bigish, the classful ia_netmask wasn't really used all that much. the real
changes are in in.c, the rest is mostly s/ia_subnetmask/ia_netmask.
ok claudio dlg ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.173 2010/01/12 01:40:30 mpf Exp $	*/
d144 1
d974 2
a975 2
	if (sc->sc_suppress)
		carp_group_demote_adj(&sc->sc_if, -1);
a976 3

	if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS(sc))
		carp_group_demote_adj(&sc->sc_if, -1);
d1190 2
a1191 1
				carp_group_demote_adj(&sc->sc_if, 1);
d1197 2
a1198 1
					carp_group_demote_adj(&sc->sc_if, -1);
d1277 2
a1278 1
				carp_group_demote_adj(&sc->sc_if, 1);
d1284 2
a1285 1
					carp_group_demote_adj(&sc->sc_if, -1);
d2346 1
a2346 1
		if (sc->sc_suppress)
d2448 1
d2452 4
d2458 5
a2462 5
			if (cmd == SIOCAIFGROUP)
				ifgl->ifgl_group->ifg_carp_demoted++;
			else if (cmd == SIOCDIFGROUP &&
			    ifgl->ifgl_group->ifg_carp_demoted)
				ifgl->ifgl_group->ifg_carp_demoted--;
d2560 1
a2560 1
carp_group_demote_adj(struct ifnet *ifp, int adj)
d2566 8
d2586 4
a2589 2
		CARP_LOG(LOG_INFO, nil, ("%s demoted group %s to %d", ifp->if_xname,
		    ifgl->ifgl_group->ifg_group, *dm));
d2602 3
d2631 2
a2632 2
				carp_group_demote_adj(&sc->sc_if, 1);
		} else {
d2636 1
a2636 2
			if (suppressed)
				carp_group_demote_adj(&sc->sc_if, -1);
@


1.173
log
@Remove the "bump the advskew to 240 in case of errors" hack.
The demote counter can handle that.
This lets carp hosts with an identical demote count still know which
one is the designated master and prevents them from failing over
asymmetrically.
Since there is a demote handling bug in all releases prior to 4.6,
symmetric failover will only work against 4.6 (and newer) from now on.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.172 2010/01/12 01:02:02 claudio Exp $	*/
d2004 2
a2005 2
		    (sin->sin_addr.s_addr & ia->ia_subnetmask) ==
		    ia->ia_subnet) {
@


1.172
log
@Use M_ZERO in malloc instead of doing a bzeor right afterwards.
From Gleydson Soares, OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.171 2009/06/17 20:17:19 mpf Exp $	*/
d743 1
a743 4
	if (carp_group_demote_count(sc) && vhe->advskew <  240)
		sc_tv.tv_usec = 240 * 1000000 / 256;
	else
		sc_tv.tv_usec = vhe->advskew * 1000000 / 256;
d1111 1
a1111 4
		if (!carp_group_demote_count(sc) || vhe->advskew > 240)
			advskew = vhe->advskew;
		else
			advskew = 240;
@


1.171
log
@Correctly handle the carp demote counter in all input cases.
E.g. give up the MASTER status if there's a host with a lower
demote count, even if it has a higher advskew.
At the moment this shouldn't cause any change, but this is a
first step towards the removal of the
"bump the advskew to 240 in case of errors" hack,
without breaking backward compatibility.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.170 2009/06/05 00:05:22 claudio Exp $	*/
d861 1
a861 1
	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
a863 1
	bzero(sc, sizeof(*sc));
@


1.170
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.169 2008/10/28 23:07:12 mpf Exp $	*/
d756 3
a758 1
		 * be more frequent than us, go into BACKUP state.
d760 4
a763 4
		if (timercmp(&sc_tv, &ch_tv, >) ||
		    (timercmp(&sc_tv, &ch_tv, ==) &&
		    ch->carp_demote <=
		    (carp_group_demote_count(sc) & 0xff))) {
d774 2
a775 1
		 * and this one claims to be slower, treat him as down.
d777 3
a779 1
		if (carp_opts[CARPCTL_PREEMPT] && timercmp(&sc_tv, &ch_tv, <)) {
d788 1
a788 1
		if (ch->carp_demote > (carp_group_demote_count(sc) & 0xff)) {
@


1.169
log
@Do not keep retrying to send advertisements if there is
no carpdev configured.
I don't see how we can run into this at all, but let's
leave this test for a a little extra safety.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.168 2008/09/03 08:37:51 mpf Exp $	*/
d427 1
a427 1
			    NULL, 0);
d429 1
a429 1
			    error, 0);
d444 1
a444 1
			    ifa->ifa_netmask, 0);
d468 5
a472 3
					    RTP_CONNECTED, NULL, 0);
					rt_missmsg(RTM_ADD, &info, info.rti_flags,
					    &sc->sc_if, error, 0);
d480 3
a482 1
						error = rtrequest1(RTM_DELETE, &info, RTP_CONNECTED, NULL, 0);
d484 1
a484 1
						    error, 0);
d496 3
a498 1
					error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED, NULL, 0);
d502 1
a502 1
					    &sc->sc_if, error, 0);
d2005 1
@


1.168
log
@Prevent a possible overflow when the sum of all demotion counters
gets bigger than 255. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.167 2008/06/14 21:46:22 reyk Exp $	*/
a1090 2
	s = splsoftnet();

d1093 1
a1093 1
		goto retry_later;
d1095 2
@


1.167
log
@add carppeer; an option to specify a different multicast address or
even the unicast address of the remote carp peer. this especially
helps when the multicast carp advertisements are causing problems in
the network (some crappy switches don't do well with multicast), there
are conflicts with VRRP, or the policy of the network does not allow
multicast (most Internet eXchange points didn't allow carped OpenBGP
routers because of the multicast advertisements).

discussed with many
ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.166 2008/06/13 23:29:31 mpf Exp $	*/
d2580 1
a2580 1
	return (count);
@


1.166
log
@Do not log carp state transitions from or to INIT by default.
Reduces the amount of dmesg noise.
Tested and OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.165 2008/06/09 07:07:16 djm Exp $	*/
d170 2
d206 2
a207 1
void	carp_proto_input_c(struct mbuf *, struct carp_header *, sa_family_t);
d533 1
d536 1
a536 1
	int iplen, len, hlen;
d550 2
d553 2
a554 1
	if (m->m_pkthdr.rcvif->if_type != IFT_CARP) {
d603 1
a603 1
	carp_proto_input_c(m, ch, AF_INET);
d662 1
a662 1
	carp_proto_input_c(m, ch, AF_INET6);
d668 2
a669 1
carp_proto_input_c(struct mbuf *m, struct carp_header *ch, sa_family_t af)
d671 1
d675 6
d682 4
a685 2
	TAILQ_FOREACH(sc, &((struct carp_if *)
	    m->m_pkthdr.rcvif->if_carpdev->if_carp)->vhif_vrs, sc_list) {
a1138 1
		m->m_flags |= M_MCAST;
d1158 3
a1160 1
		ip->ip_dst.s_addr = INADDR_CARP_GROUP;
d1487 1
a1487 1
carp_ourether(void *v, struct ether_header *eh, u_char iftype, int src)
d1558 1
a1558 1
	if ((ifp = carp_ourether(cif, &eh, m->m_pkthdr.rcvif->if_type, 0)))
d1946 12
a1957 9
		mc_addr.s_addr = INADDR_CARP_GROUP;
		IN_LOOKUP_MULTI(mc_addr, &sc->sc_if, inm);
		if (inm == NULL) {
			struct in_multi **imm = sc->sc_imo.imo_membership;
			u_int16_t maxmem = sc->sc_imo.imo_max_memberships;

			bzero(&sc->sc_imo, sizeof(sc->sc_imo));
			sc->sc_imo.imo_membership = imm;
			sc->sc_imo.imo_max_memberships = maxmem;
d1959 3
a1961 2
			if (sc->sc_carpdev != NULL && sc->sc_naddrs > 0)
				carp_join_multicast(sc);
d2049 4
a2052 1
	addr.s_addr = INADDR_CARP_GROUP;
d2250 4
d2326 1
@


1.165
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.164 2008/05/07 05:14:21 claudio Exp $	*/
d2478 1
d2482 4
d2488 1
a2488 1
		CARP_LOG(LOG_CRIT, sc,
d2492 1
a2492 1
		CARP_LOG(LOG_CRIT, sc,
@


1.164
log
@Implement routing priorities. Every route inserted has a priority assigned
and the one route with the lowest number wins. This will be used by the
routing daemons to resolve the synchronisations issue in case of conflicts.
The nasty bits of this are in the multipath code. If no priority is specified
the kernel will choose an appropriate priority.

Looked at by a few people at n2k8 code is much older
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.163 2008/05/06 15:12:00 mcbride Exp $	*/
d1012 1
a1012 1
		arc4random_bytes(&vhe->vhe_replay_cookie,
@


1.163
log
@Use the standard syslog levels on CARP logging messages instead of
simple on/off, allowing more control over how verbose the logging is.
This also allows you to do a further level of filtering in syslog.conf
if you need to.

Also add logging of state changes, inspired by diff provided by
Brian A. Seklecki in PR 5513. These messages are logged by default.

ok henning mpf deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.162 2008/02/20 22:11:53 mpf Exp $	*/
d423 2
a424 1
			error = rtrequest1(RTM_DELETE, &info, NULL, 0);
a427 1

d464 2
a465 1
					error = rtrequest1(RTM_ADD, &info, NULL, 0);
d475 1
a475 1
						error = rtrequest1(RTM_DELETE, &info, NULL, 0);
d489 1
a489 1
					error = rtrequest1(RTM_ADD, &info, NULL, 0);
@


1.162
log
@Add my copyright.
OK mcbride@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.161 2008/02/05 22:57:30 mpf Exp $	*/
d174 1
a174 1
int carp_opts[CARPCTL_MAXID] = { 0, 1, 0, 0 };	/* XXX for now */
d184 12
a195 10
#define	CARP_LOG(sc, s)							\
	if (carp_opts[CARPCTL_LOG]) {					\
		if (sc)							\
			log(LOG_INFO, "%s: ",				\
			    (sc)->sc_if.if_xname);			\
		else							\
			log(LOG_INFO, "carp: ");			\
		addlog s;						\
		addlog("\n");						\
	}
d548 1
a548 1
		CARP_LOG(sc, ("packet received on non-carp interface: %s",
d557 1
a557 1
		CARP_LOG(sc, ("received ttl %d != %d on %s", ip->ip_ttl,
d571 1
a571 1
		CARP_LOG(sc, ("packet too short %d on %s", m->m_pkthdr.len,
d588 1
a588 1
		CARP_LOG(sc, ("checksum failed on %s",
d618 1
a618 1
		CARP_LOG(sc, ("packet received on non-carp interface: %s",
d627 1
a627 1
		CARP_LOG(sc, ("received ttl %d != %d on %s", ip6->ip6_hlim,
d638 1
a638 1
		CARP_LOG(sc, ("packet size %u too small", len));
d647 1
a647 1
		CARP_LOG(sc, ("checksum failed, on %s",
d690 1
a690 1
		CARP_LOG(sc, ("invalid version %d != %d",
d700 1
a700 1
		CARP_LOG(sc, ("incorrect hash"));
d711 2
a712 1
			CARP_LOG(sc, ("replay or network loop detected"));
d1163 2
a1164 1
				CARP_LOG(sc, ("ip_output failed: %d", error));
d1248 2
a1249 1
				CARP_LOG(sc, ("ip6_output failed: %d", error));
d1377 1
a1377 1
	CARP_LOG(sc, ("carp_update_lsmask: %x", sc->sc_lsmask));
d2476 1
d2481 9
d2530 1
a2530 1
		CARP_LOG(nil, ("%s demoted group %s to %d", ifp->if_xname,
@


1.161
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.160 2008/01/02 03:33:18 brad Exp $	*/
d6 1
@


1.160
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.159 2007/12/14 18:33:40 deraadt Exp $	*/
d110 1
a110 1
	int master;
d126 1
d155 1
a166 1

d173 1
a173 1
int carp_opts[CARPCTL_MAXID] = { 0, 1, 0, 0, 0 };	/* XXX for now */
d212 1
a212 1
int	carp_vhids_ioctl(struct carp_softc *, struct carpreq);
a221 2
int	carp_addrcount(struct carp_if *, struct ifaddr *, int);
enum	{ CARP_COUNT_MASTER, CARP_COUNT_RUNNING, CARP_COUNT_LINK0 };
d293 1
a293 1
	if (vhe->master) {
d301 1
a301 1
	if (vhe->master && bcmp(sc->sc_ac.ac_enaddr, vhe->vhe_enaddr,
d406 1
a406 1
			int count = 0, error;
a415 15
			/*
			 * Avoid screwing with the routes if there are other
			 * carp interfaces which are master and have the same
			 * address.
			 */
			if (sc->sc_carpdev != NULL &&
			    sc->sc_carpdev->if_carp != NULL) {
				count = carp_addrcount(
				    (struct carp_if *)sc->sc_carpdev->if_carp,
				    ifa, CARP_COUNT_MASTER);
				if ((cmd == RTM_ADD && count != 1) ||
				    (cmd == RTM_DELETE && count != 0))
					continue;
			}

d502 2
d737 1
a737 1
			if (vhe->master)
d892 1
a892 1
	/* mark the first vhe as master */
d894 1
a894 1
		vhe->master = 1;
d1176 1
a1176 1
		if (vhe->master) {
a1286 4
		if (carp_addrcount((struct carp_if *)sc->sc_carpdev->if_carp,
		    ifa, CARP_COUNT_LINK0))
			continue;

a1352 42
int
carp_addrcount(struct carp_if *cif, struct ifaddr *ifa0, int type)
{
	struct carp_softc *vh;
	struct ifaddr *ifa;
	int count = 0;

	TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
		switch (type) {
		case CARP_COUNT_RUNNING:
			if ((vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
			    (IFF_UP|IFF_RUNNING))
				continue;
			break;
		case CARP_COUNT_MASTER:
			if (LIST_FIRST(&vh->carp_vhosts)->state != MASTER)
				continue;
			break;
		case CARP_COUNT_LINK0:
			if (!(vh->sc_if.if_flags & IFF_LINK0) ||
			    (vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
			    (IFF_UP|IFF_RUNNING))
				continue;
			break;
		}
		TAILQ_FOREACH(ifa, &vh->sc_if.if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family == AF_INET &&
			    ifa0->ifa_addr->sa_family == AF_INET &&
			    ifatoia(ifa0)->ia_addr.sin_addr.s_addr ==
			    ifatoia(ifa)->ia_addr.sin_addr.s_addr)
				count++;
#ifdef INET6
			if (ifa->ifa_addr->sa_family == AF_INET6 &&
			    ifa0->ifa_addr->sa_family == AF_INET6 &&
			    IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa0), IFA_IN6(ifa)))
				count++;
#endif
		}
	}
	return (count);
}

a1355 2
	struct carp_softc *curvh, *vh, *sc0 = NULL;
	struct carp_if *cif;
d1357 1
a1357 6
	struct ifaddr *ifa, *ifa0 = NULL;
	int cur, last, count, found;

	if (!sc->sc_carpdev)
		return;
	cif = (struct carp_if *)sc->sc_carpdev->if_carp;
d1359 1
a1359 9
	/*
	 * Take the first IPv4 address from the LINK0 carp interface
	 * to determine the load sharing group.
	 * Fallback on the first IPv6 address.
	 */
	TAILQ_FOREACH(sc0, &cif->vhif_vrs, sc_list)
		if (sc0->sc_if.if_flags & IFF_LINK0)
			break;
	if (sc0 == NULL)
d1362 1
a1362 20
	TAILQ_FOREACH(ifa0, &sc0->sc_if.if_addrlist, ifa_list)
		if (ifa0->ifa_addr->sa_family == AF_INET)
			break;
#ifdef INET6
	if (ifa0 == NULL)
		TAILQ_FOREACH(ifa0, &sc0->sc_if.if_addrlist, ifa_list)
			if (ifa0->ifa_addr->sa_family == AF_INET6 &&
			    !IN6_IS_ADDR_LINKLOCAL(IFA_IN6(ifa0)))
				break;
#endif
	if (ifa0 == NULL)
		return;
	/*
	 * Calculate the load sharing mask w/ all carp interfaces
	 * that share the first address of the LINK0 interface.
	 * Sort by virtual host ID.
	 */
	sc0->sc_lsmask = 0;
	cur = 0;
	curvh = NULL;
a1363 35
	do {
		found = 0;
		last = cur;
		cur = 255;
		TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
			vhe = LIST_FIRST(&vh->carp_vhosts);
			if ((vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
			    (IFF_UP|IFF_RUNNING))
				continue;
			TAILQ_FOREACH(ifa, &vh->sc_if.if_addrlist, ifa_list) {
				if (ifa->ifa_addr->sa_family == AF_INET &&
				    ifa0->ifa_addr->sa_family == AF_INET &&
				    ifatoia(ifa0)->ia_addr.sin_addr.s_addr ==
				    ifatoia(ifa)->ia_addr.sin_addr.s_addr)
					break;
#ifdef INET6
				if (ifa->ifa_addr->sa_family == AF_INET6 &&
				    ifa0->ifa_addr->sa_family == AF_INET6 &&
				    IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa0), IFA_IN6(ifa)))
					break;
#endif
			}
			if (ifa && vhe->vhid > last && vhe->vhid < cur) {
				cur = vhe->vhid;
				curvh = vh;
				found++;
			}
		}
		if (found) {
			if (LIST_FIRST(&curvh->carp_vhosts)->state == MASTER &&
			    count < sizeof(sc0->sc_lsmask) * 8)
				sc0->sc_lsmask |= 1 << count;
			count++;
		}
	} while (found);
d1365 7
a1371 5
	sc0->sc_lscount = count;
	if (count == 0)
		return;

	CARP_LOG(sc, ("carp_update_lsmask: %x", sc0->sc_lsmask))
d1375 2
a1376 2
carp_iamatch(struct in_ifaddr *ia, u_char *src,
    u_int32_t *count, u_int32_t index)
d1381 2
a1382 10
	/*
	 * If the asked address is found on a LINK0 interface
	 * don't answer the arp reply unless we are MASTER on it.
	 */
	if (!(sc->sc_if.if_flags & IFF_LINK0) && sc->sc_carpdev &&
	    carp_addrcount((struct carp_if *)sc->sc_carpdev->if_carp,
	    (struct ifaddr *)ia, CARP_COUNT_LINK0))
		return (0);

	if (carp_opts[CARPCTL_ARPBALANCE]) {
d1390 1
a1390 8
		/* Count the eligible carp interfaces with this address */
		if (*count == 0)
			*count = carp_addrcount(
			    (struct carp_if *)ia->ia_ifp->if_carpdev->if_carp,
			    (struct ifaddr *)ia, CARP_COUNT_RUNNING);

		/* This should never happen, but... */
		if (*count == 0)
d1392 17
a1408 3

		if (carp_hash(sc, src) % *count == index - 1 &&
		    LIST_FIRST(&sc->carp_vhosts)->state == MASTER) {
d1421 1
a1421 1
carp_iamatch6(struct ifnet *ifp, struct ifaddr *ifa)
d1424 1
d1426 8
a1433 8
	/*
	 * If the asked address is found on a LINK0 interface
	 * don't answer the arp request unless we are MASTER on it.
	 */
	if (!(sc->sc_if.if_flags & IFF_LINK0) && sc->sc_carpdev &&
	    carp_addrcount((struct carp_if *)sc->sc_carpdev->if_carp,
	    ifa, CARP_COUNT_LINK0))
		return (0);
d1435 21
a1455 2
	if (LIST_FIRST(&sc->carp_vhosts)->state == MASTER)
		return (1);
d1474 1
a1474 2
		/* XXX need to check all vhes */
		struct carp_vhost_entry *vhe = LIST_FIRST(&vh->carp_vhosts);
d1478 12
a1489 3
		if ((vhe->state == MASTER || vh->sc_if.if_flags & IFF_LINK0)
		    && !bcmp(ena, vh->sc_ac.ac_enaddr, ETHER_ADDR_LEN))
			return (&vh->sc_if);
d1499 3
a1501 2
	if (!(ifp->if_flags & IFF_LINK1) && sc->cur_vhe) {
		if (sc->cur_vhe->master)
d1511 12
d1576 2
d1616 1
a1616 1
		if (vhe->master) {
d1625 1
a1625 1
		if (vhe->master)
d1662 1
a1662 1
		if (vhe->master)
d1670 1
a1670 1
		if (vhe->master)
d1678 1
a1678 1
		if (vhe->master)
d1842 1
a1842 1
		if (vhe->master && sc->sc_if.if_flags & IFF_LINK2)
d1851 4
a2205 3
		carp_set_enaddr(sc); /* for changes on LINK2 */
		if (ifr->ifr_flags & IFF_LINK0)
			carp_update_lsmask(sc);
d2237 1
a2237 1
		if ((error = carp_vhids_ioctl(sc, carpr)))
d2255 9
d2286 1
d2346 1
a2346 1
carp_vhids_ioctl(struct carp_softc *sc, struct carpreq carpr)
d2348 1
a2348 1
	int i;
d2351 2
a2352 2
	if (carpr.carpr_vhids[0] == 0 ||
	    !bcmp(sc->sc_vhids, carpr.carpr_vhids, sizeof(sc->sc_vhids)))
d2356 2
a2357 2
	for (i = 0; carpr.carpr_vhids[i]; i++) {
		if (taken_vhids[carpr.carpr_vhids[i]])
d2359 1
a2359 1
		taken_vhids[carpr.carpr_vhids[i]] = 1;
d2364 1
a2364 1
			if (carp_check_dup_vhids(sc, cif, &carpr))
d2367 1
a2367 1
		if (carpr.carpr_advskews[i] >= 255)
d2370 6
d2382 11
a2392 6
	for (i = 0; carpr.carpr_vhids[i]; i++) {
		if (carp_new_vhost(sc, carpr.carpr_vhids[i],
		    carpr.carpr_advskews[i]))
			return (ENOMEM);
		sc->sc_vhids[i] = carpr.carpr_vhids[i];
		sc->sc_advskews[i] = carpr.carpr_advskews[i];
d2448 2
a2449 1
	if (sc->sc_carpdev != NULL && vhe->state == MASTER)
d2478 1
a2478 1
	if (!vhe->master)
@


1.159
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.158 2007/11/27 11:34:18 claudio Exp $	*/
d2383 1
a2383 1
		error = EINVAL;
@


1.158
log
@Make carp(4) behave more like a ethernet interface by initalizing the
IPv4 interface address similar to arp_ifinit(). The main difference is
that we do not send out a gracious arp as the carp(4) is not ready to send
at that moment. This will make backup interface show up like the master ones.
OK mpf@@ earlier version OK henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.157 2007/11/26 17:26:25 chl Exp $	*/
d805 12
a816 4
	if (name[0] <= 0 || name[0] >= CARPCTL_MAXID)
		return (ENOPROTOOPT);

	return sysctl_int(oldp, oldlenp, newp, newlen, &carp_opts[name[0]]);
@


1.157
log
@MALLOC -> malloc and M_ZERO change

ok mpf@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.156 2007/11/22 02:04:14 henning Exp $	*/
d2239 7
a2245 2
			bcopy(ifa->ifa_addr, ifa->ifa_dstaddr,
			    sizeof(struct sockaddr));
@


1.156
log
@pass the carp ifp to rt_missmsg() when generating the RTM_ADD messages
so the resulting messages have ifindex set and the routing daemons can
correctly indentify that route as connected. ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.155 2007/11/22 01:21:40 mpf Exp $	*/
d887 1
a887 2
	MALLOC(vhe, struct carp_vhost_entry *, sizeof(*vhe),
	    M_DEVBUF, M_NOWAIT);
a889 1
	bzero(vhe, sizeof(*vhe));
@


1.155
log
@Factor out the virtual host portion of carp into a separate struct
that is kept in a list per carp interface.  This is the huge first
step necessary to make carp load balancing nice and easy. One carp
interface can now contain up to 32 virtual host instances.
This doesn't do anything useful yet, but here is how an ifconfig
for multiple entries now looks like:

# ifconfig carp2 carpnodes 5:0,6:100 192.168.5.88

carp2: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        lladdr 00:00:5e:00:01:05
        carp: carpdev sis0 advbase 1
                state MASTER vhid 5 advskew 0
                state BACKUP vhid 6 advskew 100
        groups: carp
        inet 192.168.5.88 netmask 0xffffff00 broadcast 192.168.5.255

OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.154 2007/11/16 05:08:39 djm Exp $	*/
d478 2
a479 2
					rt_missmsg(RTM_ADD, &info, info.rti_flags, NULL,
					    error, 0);
d504 2
a505 2
					rt_missmsg(RTM_ADD, &info, info.rti_flags, NULL,
					    error, 0);
@


1.154
log
@use arc4random_bytes() instead of multiple arc4random() calls;
ok deraadt@@ dlg@@ henric@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.153 2007/10/29 16:19:23 chl Exp $	*/
d107 21
a139 2
	enum { INIT = 0, BACKUP, MASTER }	sc_state;

d144 1
a144 1
#define CARP_SENDAD_MAX_ERRORS	3
d146 1
a146 1
#define CARP_SENDAD_MIN_SUCCESS 3
a147 1
	char sc_carplladdr[ETHER_ADDR_LEN];
d149 6
a154 2
	int sc_vhid;
	int sc_advskew;
a157 1
	u_int64_t sc_replay_cookie;
a159 1
#define CARP_HMAC_PAD	64
a160 1
	unsigned char sc_pad[CARP_HMAC_PAD];
a161 1
	SHA1_CTX sc_sha1[HMAC_MAX];
a165 3
	struct timeout sc_ad_tmo;	/* advertisement timeout */
	struct timeout sc_md_tmo;	/* master down timeout */
	struct timeout sc_md6_tmo;	/* master down timeout */
d169 1
d194 2
a195 2
void	carp_hmac_prepare_ctx(struct carp_softc *, u_int8_t);
void	carp_hmac_generate(struct carp_softc *, u_int32_t *,
d197 1
a197 1
int	carp_hmac_verify(struct carp_softc *, u_int32_t *,
d203 1
a203 1
int	carp_prepare_ad(struct mbuf *, struct carp_softc *,
d206 1
d211 3
d217 4
a220 2
void	carp_setrun(struct carp_softc *, sa_family_t);
void	carp_set_state(struct carp_softc *, int);
d226 1
d243 3
d255 1
d258 5
a262 2
	for (i=0; i < HMAC_MAX; i++)
		carp_hmac_prepare_ctx(sc, i);
d266 1
a266 1
carp_hmac_prepare_ctx(struct carp_softc *sc, u_int8_t ctx)
d268 2
d271 1
a271 1
	u_int8_t vhid = sc->sc_vhid & 0xff;
d282 4
a285 4
	bzero(sc->sc_pad, sizeof(sc->sc_pad));
	bcopy(sc->sc_key, sc->sc_pad, sizeof(sc->sc_key));
	for (i = 0; i < sizeof(sc->sc_pad); i++)
		sc->sc_pad[i] ^= 0x36;
d288 4
a291 4
	SHA1Init(&sc->sc_sha1[ctx]);
	SHA1Update(&sc->sc_sha1[ctx], sc->sc_pad, sizeof(sc->sc_pad));
	SHA1Update(&sc->sc_sha1[ctx], (void *)&version, sizeof(version));
	SHA1Update(&sc->sc_sha1[ctx], (void *)&type, sizeof(type));
d294 6
a299 4
	bcopy(&sc->sc_sha1[ctx], &sha1ctx, sizeof(sha1ctx));
	SHA1Final((unsigned char *)kmd, &sha1ctx);
	sc->sc_hashkey[0] = kmd[0] ^ kmd[1];
	sc->sc_hashkey[1] = kmd[2] ^ kmd[3];
d302 3
a304 2
	if (bcmp(sc->sc_ac.ac_enaddr, sc->sc_carplladdr, ETHER_ADDR_LEN) != 0)
		SHA1Update(&sc->sc_sha1[ctx], sc->sc_ac.ac_enaddr,
d307 1
a307 1
	SHA1Update(&sc->sc_sha1[ctx], (void *)&vhid, sizeof(vhid));
d326 1
a326 1
			SHA1Update(&sc->sc_sha1[ctx],
d351 1
a351 1
			SHA1Update(&sc->sc_sha1[ctx],
d357 2
a358 2
	for (i = 0; i < sizeof(sc->sc_pad); i++)
		sc->sc_pad[i] ^= 0x36 ^ 0x5c;
d362 1
a362 1
carp_hmac_generate(struct carp_softc *sc, u_int32_t counter[2],
d368 1
a368 1
	bcopy(&sc->sc_sha1[ctx], &sha1ctx, sizeof(sha1ctx));
d370 1
a370 1
	SHA1Update(&sha1ctx, (void *)counter, sizeof(sc->sc_replay_cookie));
d375 1
a375 1
	SHA1Update(&sha1ctx, sc->sc_pad, sizeof(sc->sc_pad));
d381 1
a381 1
carp_hmac_verify(struct carp_softc *sc, u_int32_t counter[2],
d387 2
a388 2
	for (i=0; i < HMAC_MAX; i++) { 
		carp_hmac_generate(sc, counter, md2, i);
d674 1
d678 7
a684 3
	    m->m_pkthdr.rcvif->if_carpdev->if_carp)->vhif_vrs, sc_list)
		if (sc->sc_vhid == ch->carp_vhid)
			break;
d708 1
a708 1
	if (carp_hmac_verify(sc, ch->carp_counter, ch->carp_md)) {
d716 1
a716 1
	if (!bcmp(&sc->sc_replay_cookie, ch->carp_counter,
d729 1
a729 1
	if (carp_group_demote_count(sc) && sc->sc_advskew <  240)
d732 1
a732 1
		sc_tv.tv_usec = sc->sc_advskew * 1000000 / 256;
d736 1
a736 1
	switch (sc->sc_state) {
d748 5
a752 4
			timeout_del(&sc->sc_ad_tmo);
			carp_set_state(sc, BACKUP);
			carp_setrun(sc, 0);
			carp_setroute(sc, RTM_DELETE);
d761 1
a761 1
			carp_master_down(sc);
d770 1
a770 1
			carp_master_down(sc);
d781 1
a781 1
			carp_master_down(sc);
d789 1
a789 1
		carp_setrun(sc, af);
d839 7
a847 2
	sc->sc_vhid = -1;	/* required setting */
	sc->sc_advskew = 0;
a856 4
	timeout_set(&sc->sc_ad_tmo, carp_send_ad, sc);
	timeout_set(&sc->sc_md_tmo, carp_master_down, sc);
	timeout_set(&sc->sc_md6_tmo, carp_master_down, sc);

d883 35
d925 1
d933 12
d950 1
a950 3
	timeout_del(&sc->sc_ad_tmo);
	timeout_del(&sc->sc_md_tmo);
	timeout_del(&sc->sc_md6_tmo);
d956 1
a956 1
	if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS)
d960 1
a960 1
	carp_set_state(sc, INIT);
d962 1
a962 1
	carp_setrun(sc, 0);
d995 15
d1011 2
a1012 1
carp_prepare_ad(struct mbuf *m, struct carp_softc *sc, struct carp_header *ch)
d1014 3
a1016 3
	if (!sc->sc_replay_cookie) {
		arc4random_bytes(&sc->sc_replay_cookie,
		    sizeof(sc->sc_replay_cookie));
d1019 1
a1019 1
	bcopy(&sc->sc_replay_cookie, ch->carp_counter,
d1026 1
a1026 1
	carp_hmac_generate(sc, ch->carp_counter, ch->carp_md, HMAC_NOV6LL);
d1045 3
a1047 2
			    (IFF_UP|IFF_RUNNING) && vh->sc_state == MASTER)
				carp_send_ad(vh);
d1052 10
d1068 2
a1069 1
	struct carp_softc *sc = v;
d1071 1
a1085 1
		sc->sc_bow_out = 0;
d1090 2
a1091 2
		if (!carp_group_demote_count(sc) || sc->sc_advskew > 240)
			advskew = sc->sc_advskew;
d1100 1
a1100 1
	ch.carp_vhid = sc->sc_vhid;
d1107 1
d1149 1
a1149 1
		if (carp_prepare_ad(m, sc, ch_ptr))
d1171 1
a1171 1
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS)
d1175 1
a1175 1
			if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS) {
d1177 1
a1177 1
				    CARP_SENDAD_MIN_SUCCESS) {
d1184 7
a1190 5
		if (sc->sc_delayed_arp > 0)
			sc->sc_delayed_arp--;
		if (sc->sc_delayed_arp == 0) {
			carp_send_arp(sc);
			sc->sc_delayed_arp = -1;
d1234 1
a1234 1
		if (carp_prepare_ad(m, sc, ch_ptr))
d1255 1
a1255 1
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS)
d1259 1
a1259 1
			if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS) {
d1261 1
a1261 1
				    CARP_SENDAD_MIN_SUCCESS) {
d1272 1
d1275 1
a1275 1
		timeout_add(&sc->sc_ad_tmo, tvtohz(&tv));
d1380 1
a1380 1
			if (vh->sc_state != MASTER)
d1412 1
d1457 1
d1474 2
a1475 2
			if (ifa && vh->sc_vhid > last && vh->sc_vhid < cur) {
				cur = vh->sc_vhid;
d1481 1
a1481 1
			if (curvh->sc_state == MASTER &&
d1500 1
d1530 1
a1530 1
		    sc->sc_state == MASTER) {
d1534 1
a1534 1
		if (sc->sc_state == MASTER)
d1556 1
a1556 1
	if (sc->sc_state == MASTER)
d1576 2
d1581 1
a1581 1
		if ((vh->sc_state == MASTER || vh->sc_if.if_flags & IFF_LINK0)
d1588 15
d1682 2
a1683 1
	struct carp_softc *sc = v;
d1685 1
a1685 1
	switch (sc->sc_state) {
d1693 6
a1698 5
		carp_set_state(sc, MASTER);
		carp_send_ad(sc);
		carp_send_arp(sc);
		/* Schedule a delayed ARP request to deal w/ some L3 switches */
		sc->sc_delayed_arp = 2;
d1700 1
a1700 1
		carp_send_na(sc);
d1702 4
a1705 2
		carp_setrun(sc, 0);
		carp_setroute(sc, RTM_ADD);
d1711 9
d1725 1
a1725 1
carp_setrun(struct carp_softc *sc, sa_family_t af)
d1728 1
d1732 1
a1732 1
		carp_set_state(sc, INIT);
d1736 1
a1736 1
	if (sc->sc_if.if_flags & IFF_UP && sc->sc_vhid > 0 &&
d1741 2
a1742 1
		carp_setroute(sc, RTM_DELETE);
d1746 1
a1746 1
	switch (sc->sc_state) {
d1748 4
a1751 3
		carp_set_state(sc, BACKUP);
		carp_setroute(sc, RTM_DELETE);
		carp_setrun(sc, 0);
d1754 1
a1754 1
		timeout_del(&sc->sc_ad_tmo);
d1756 3
a1758 2
		tv.tv_usec = sc->sc_advskew * 1000000 / 256;
		sc->sc_delayed_arp = -1;
d1762 1
a1762 1
			timeout_add(&sc->sc_md_tmo, tvtohz(&tv));
d1767 1
a1767 1
			timeout_add(&sc->sc_md6_tmo, tvtohz(&tv));
d1772 1
a1772 1
				timeout_add(&sc->sc_md_tmo, tvtohz(&tv));
d1774 1
a1774 1
				timeout_add(&sc->sc_md6_tmo, tvtohz(&tv));
d1780 2
a1781 2
		tv.tv_usec = sc->sc_advskew * 1000000 / 256;
		timeout_add(&sc->sc_ad_tmo, tvtohz(&tv));
d1851 2
a1852 3
			TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list)
				if (vr != sc && vr->sc_vhid == sc->sc_vhid)
					return (EINVAL);
d1885 2
a1886 1
			if (vr->sc_vhid < sc->sc_vhid)
d1916 1
a1916 1
carp_set_enaddr(struct carp_softc *sc)
d1918 5
a1922 4
	if (sc->sc_vhid != -1 && sc->sc_carpdev) {
		/* XXX detach ipv6 link-local address? */
		if (sc->sc_if.if_flags & IFF_LINK2)
			sc->sc_carplladdr[0] = 1;
d1924 6
a1929 6
			sc->sc_carplladdr[0] = 0;
		sc->sc_carplladdr[1] = 0;
		sc->sc_carplladdr[2] = 0x5e;
		sc->sc_carplladdr[3] = 0;
		sc->sc_carplladdr[4] = 1;
		sc->sc_carplladdr[5] = sc->sc_vhid;
d1931 12
a1942 1
		bzero(sc->sc_carplladdr, ETHER_ADDR_LEN);
d1948 1
a1948 1
	if ((bcmp(sc->sc_ac.ac_enaddr + 1, sc->sc_carplladdr + 1,
d1953 1
a1953 1
		bcopy(sc->sc_carplladdr, sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN);
d1967 2
a1968 2
		carp_set_state(sc, INIT);
		carp_setrun(sc, 0);
d2012 1
a2012 1
			carp_set_state(sc, INIT);
d2017 1
a2017 1
	carp_setrun(sc, 0);
d2029 1
a2029 1
			carp_set_state(sc, INIT);
d2032 1
a2032 1
		carp_setrun(sc, 0);
d2075 1
a2075 1
	carp_set_state(sc, INIT);
d2118 1
a2118 1
			carp_set_state(sc, INIT);
d2121 1
a2121 1
		carp_setrun(sc, 0);
d2170 2
a2171 2
	carp_set_state(sc, INIT);
	carp_setrun(sc, 0);
d2227 2
a2228 1
	struct carp_softc *sc = ifp->if_softc, *vr;
d2233 1
a2233 1
	int error = 0;
d2259 10
a2268 10
		if (sc->sc_state != INIT && !(ifr->ifr_flags & IFF_UP)) {
			timeout_del(&sc->sc_ad_tmo);
			timeout_del(&sc->sc_md_tmo);
			timeout_del(&sc->sc_md6_tmo);
			if (sc->sc_state == MASTER) {
				/* we need the interface up to bow out */
				sc->sc_if.if_flags |= IFF_UP;
				sc->sc_bow_out = 1;
				carp_send_ad(sc);
			}
d2270 3
a2272 3
			carp_set_state(sc, INIT);
			carp_setrun(sc, 0);
		} else if (sc->sc_state == INIT && (ifr->ifr_flags & IFF_UP)) {
d2274 1
a2274 1
			carp_setrun(sc, 0);
d2282 1
d2293 1
a2293 1
		if (sc->sc_state != INIT && carpr.carpr_state != sc->sc_state) {
d2296 3
a2298 3
				timeout_del(&sc->sc_ad_tmo);
				carp_set_state(sc, BACKUP);
				carp_setrun(sc, 0);
d2302 3
a2304 1
				carp_master_down(sc);
d2310 3
a2312 25
		if (carpr.carpr_vhid > 0 && carpr.carpr_vhid != sc->sc_vhid) {
			if (carpr.carpr_vhid > 255) {
				error = EINVAL;
				break;
			}
			if (sc->sc_carpdev) {
				struct carp_if *cif;
				cif = (struct carp_if *)sc->sc_carpdev->if_carp;
				TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list)
					if (vr != sc &&
					    vr->sc_vhid == carpr.carpr_vhid)
						return (EINVAL);
			}
			if (carpr.carpr_vhid != sc->sc_vhid) {
				sc->sc_vhid = carpr.carpr_vhid;
				carp_set_enaddr(sc);
				carp_set_state(sc, INIT);
			}
			error--;
		}
		if (carpr.carpr_advbase > 0 || carpr.carpr_advskew > 0) {
			if (carpr.carpr_advskew >= 255) {
				error = EINVAL;
				break;
			}
a2317 1
			sc->sc_advskew = carpr.carpr_advskew;
d2320 8
d2333 1
a2333 1
			carp_setrun(sc, 0);
d2342 7
a2348 2
		carpr.carpr_state = sc->sc_state;
		carpr.carpr_vhid = sc->sc_vhid;
a2349 1
		carpr.carpr_advskew = sc->sc_advskew;
d2381 70
d2476 2
a2477 3
	    (IFF_UP|IFF_RUNNING)) == (IFF_UP|IFF_RUNNING) &&
	    sc->sc_state == MASTER)
		carp_send_ad(sc);
d2496 1
d2498 3
a2500 1
	if (sc->sc_carpdev != NULL && sc->sc_state == MASTER)
d2509 1
a2509 1
carp_set_state(struct carp_softc *sc, int state)
d2511 12
a2522 1
	if (sc->sc_state == state)
d2525 1
a2525 1
	sc->sc_state = state;
d2528 4
d2600 2
a2601 4
			timeout_del(&sc->sc_ad_tmo);
			timeout_del(&sc->sc_md_tmo);
			timeout_del(&sc->sc_md6_tmo);
			carp_set_state(sc, INIT);
d2603 1
a2603 1
			carp_setrun(sc, 0);
d2607 1
a2607 1
			carp_set_state(sc, INIT);
d2609 1
a2609 1
			carp_setrun(sc, 0);
@


1.153
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.152 2007/10/27 23:08:35 mpf Exp $	*/
d911 2
a912 3
		sc->sc_replay_cookie = arc4random();
		sc->sc_replay_cookie = sc->sc_replay_cookie << 32;
		sc->sc_replay_cookie += arc4random();
@


1.152
log
@Replace the replay protection counter with a cookie.
It is unlikely we will ever get a working replay protection,
so better keep it simple and robust.
The cookie allows us to detect our own advertisements,
thus it is now easy to deal with network loops and
non-simplex interfaces.

Zero feedback by the people who wanted this fixed.
OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.151 2007/09/24 11:17:20 claudio Exp $	*/
d887 1
a887 1
			FREE(cif, M_IFADDR);
d1683 1
a1683 2
			MALLOC(ncif, struct carp_if *, sizeof(*cif),
			    M_IFADDR, M_NOWAIT);
d1687 1
a1687 1
				FREE(ncif, M_IFADDR);
d1708 1
a1708 1
				FREE(ncif, M_IFADDR);
d1716 1
a1716 1
				FREE(ncif, M_IFADDR);
d2391 1
a2391 2
	MALLOC(mc, struct carp_mc_entry *, sizeof(struct carp_mc_entry),
	    M_DEVBUF, M_NOWAIT);
d2414 1
a2414 1
	FREE(mc, M_DEVBUF);
d2461 1
a2461 1
		FREE(mc, M_DEVBUF);
d2493 1
a2493 1
		FREE(mc, M_DEVBUF);
@


1.151
log
@Fix carp(4) after the switch to dynamic imo_membership allocation.
The multicast code is still a mess but will no longer crash the box.
With input from pascoe@@ who hit the same bug.
OK markus@@, henning@@, mpf@@ (on a previous version)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.150 2007/09/18 18:56:02 markus Exp $	*/
d136 1
a136 2
	int sc_init_counter;
	u_int64_t sc_counter;
d335 1
a335 1
	SHA1Update(&sha1ctx, (void *)counter, sizeof(sc->sc_counter));
a638 1
	u_int64_t tmp_counter;
a652 42
	/*
	 * Check if our own advertisement was duplicated
	 * from a non simplex interface.
	 * XXX If there is no address on our physical interface
	 * there is no way to distinguish our ads from the ones
	 * another carp host might have sent us.
	 */
	if ((sc->sc_carpdev->if_flags & IFF_SIMPLEX) == 0) {
		struct sockaddr sa;
		struct ifaddr *ifa;

		bzero(&sa, sizeof(sa));
		sa.sa_family = af;
		ifa = ifaof_ifpforaddr(&sa, sc->sc_carpdev);

		if (ifa && af == AF_INET) {
			struct ip *ip = mtod(m, struct ip *);
			if (ip->ip_src.s_addr ==
			    ifatoia(ifa)->ia_addr.sin_addr.s_addr) {
				m_freem(m);
				return;
			}
		}
#ifdef INET6
		if (ifa && af == AF_INET6) {
			struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
			struct in6_addr in6_src, in6_found;

			in6_src = ip6->ip6_src;
			in6_found = ifatoia6(ifa)->ia_addr.sin6_addr;
			if (IN6_IS_SCOPE_EMBED(&in6_src))
				in6_src.s6_addr16[1] = 0;
			if (IN6_IS_SCOPE_EMBED(&in6_found))
				in6_found.s6_addr16[1] = 0;
			if (IN6_ARE_ADDR_EQUAL(&in6_src, &in6_found)) {
				m_freem(m);
				return;
			}
		}
#endif /* INET6 */
	}

d676 11
a686 9
	tmp_counter = ntohl(ch->carp_counter[0]);
	tmp_counter = tmp_counter<<32;
	tmp_counter += ntohl(ch->carp_counter[1]);

	/* XXX Replay protection goes here */

	sc->sc_init_counter = 0;
	sc->sc_counter = tmp_counter;

a801 1
	sc->sc_init_counter = 1;
d910 5
a914 7
	if (sc->sc_init_counter) {
		/* this could also be seconds since unix epoch */
		sc->sc_counter = arc4random();
		sc->sc_counter = sc->sc_counter << 32;
		sc->sc_counter += arc4random();
	} else
		sc->sc_counter++;
d916 2
a917 2
	ch->carp_counter[0] = htonl((sc->sc_counter>>32)&0xffffffff);
	ch->carp_counter[1] = htonl(sc->sc_counter&0xffffffff);
@


1.150
log
@allow 4095 instead of 20 multicast group memberships per socket (you need
one entry for each multicast group and interface combination). this allows
you to run OSPF with more than 10 interfaces.
adapted from freebsd; ok claudio, henning, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.149 2007/09/18 09:18:04 mpf Exp $	*/
d1877 3
d1881 2
d1969 2
a1970 1
	struct ip_moptions *imo = &sc->sc_imo, tmpimo;
a1972 1
	bzero(&tmpimo, sizeof(tmpimo));
d1974 1
a1974 2
	if ((tmpimo.imo_membership[0] =
	    in_addmulti(&addr, &sc->sc_if)) == NULL) {
a1975 1
	}
d1977 1
a1977 1
	imo->imo_membership[0] = tmpimo.imo_membership[0];
@


1.149
log
@ARP balancing has been changed to use the source MAC address
quite a while ago.  Manpage and comment update by Matthew Dempsky.
OK jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.148 2007/09/03 06:10:54 joel Exp $	*/
d849 4
d886 3
a888 1
	carpdetach(ifp->if_softc);
d891 2
a892 1
	free(ifp->if_softc, M_DEVBUF);
@


1.148
log
@Make use of the carp preempt counter to signal number of transitions of
any carp group to master status.


ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.147 2007/06/23 16:15:26 reyk Exp $	*/
d1429 4
a1432 4
		 * We use the source ip to decide which virtual host should
		 * handle the request. If we're master of that virtual host,
		 * then we respond, otherwise, just drop the arp packet on
		 * the floor.
@


1.147
log
@use a masked destination network instead of the interface ip for the
destination of the route belonging to the carp interface.

ok mpf@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.146 2007/06/14 19:31:17 reyk Exp $	*/
d1601 1
@


1.146
log
@preserve the possible route label if the route belongs to the carp
interface (ip-less parent).

tested by claudio and me
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.145 2007/06/13 04:55:49 claudio Exp $	*/
d462 1
a462 1
					info.rti_info[RTAX_DST] = ifa->ifa_addr;
@


1.145
log
@There is no need to set RTAX_NETMASK on RTF_HOST routes. RTAX_NETMASK will
be set to NULL as first in rtrequest1() for all host routes.
With and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.144 2007/06/01 02:42:59 mpf Exp $	*/
d380 2
d423 11
d465 2
@


1.144
log
@sc_carplladdr does not need to be dereferenced.
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.143 2007/06/01 00:52:38 henning Exp $	*/
a398 1
			info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;
a428 1
					info.rti_info[RTAX_NETMASK] = ifa->ifa_netmask;
@


1.143
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.142 2007/06/01 00:07:13 mpf Exp $	*/
d269 1
a269 1
	if (bcmp(sc->sc_ac.ac_enaddr, &sc->sc_carplladdr, ETHER_ADDR_LEN) != 0)
d1799 1
a1799 1
		bzero(&sc->sc_carplladdr, ETHER_ADDR_LEN);
@


1.142
log
@Remove code to create a carp(4) Token Ring lladdr.
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.141 2007/05/29 18:21:19 claudio Exp $	*/
d1153 1
a1153 1
		error = ip6_output(m, NULL, NULL, 0, &sc->sc_im6o, NULL);
@


1.141
log
@Move tokenring support to the attic where it can join the cards that where
decomissioned aeon ago. We will not miss it at all.
OK dlg@@ henning@@ and a lot of cheers by other in the room
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.140 2007/05/28 06:31:01 mcbride Exp $	*/
d1789 9
a1797 18
		if (sc->sc_carpdev->if_type == IFT_ISO88025) {
			sc->sc_carplladdr[0] = 3;
			sc->sc_carplladdr[1] = 0;
			sc->sc_carplladdr[2] = 0x40 >> (sc->sc_vhid - 1);
			sc->sc_carplladdr[3] = 0x40000 >> (sc->sc_vhid - 1);
			sc->sc_carplladdr[4] = 0;
			sc->sc_carplladdr[5] = 0;
		} else {
			if (sc->sc_if.if_flags & IFF_LINK2)
				sc->sc_carplladdr[0] = 1;
			else
				sc->sc_carplladdr[0] = 0;
			sc->sc_carplladdr[1] = 0;
			sc->sc_carplladdr[2] = 0x5e;
			sc->sc_carplladdr[3] = 0;
			sc->sc_carplladdr[4] = 1;
			sc->sc_carplladdr[5] = sc->sc_vhid;
		}
@


1.140
log
@Users of arc4random() should include dev/rndvar.h directly.

ok dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.139 2007/05/27 20:11:44 dlg Exp $	*/
a63 3
#endif
#if NTOKEN > 0
#include <net/if_token.h>
@


1.139
log
@rewrite a static inline func that simply coerces a return type of another
function as a macro.

ok reyk@@ ja ja claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.138 2007/05/26 17:13:31 jason Exp $	*/
d58 3
@


1.138
log
@one extern seems to be better than 20 for ifqmaxlen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.137 2007/05/06 12:20:04 henning Exp $	*/
d225 1
a225 5
static __inline u_int16_t
carp_cksum(struct mbuf *m, int len)
{
	return (in_cksum(m, len));
}
@


1.137
log
@do not fill RTAX_GATEWAY for RTM_DELETE, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.136 2007/05/04 12:39:39 henning Exp $	*/
a822 1
	extern int ifqmaxlen;
@


1.136
log
@make carp's routing table modification attempts (imho broken by design)
at least exhibit routing messages so it does not confuse the userland
routing daemons by routing table changes not reflected by messages on the
routing socket. effect would be bgpd using wrong nexthops for example, in
the worst case (that i actually ran into) blackholing traffic.
ok reyk claudio "looks correct" miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.135 2007/03/27 21:58:16 mpf Exp $	*/
a402 1
			info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
a444 1
						info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
@


1.135
log
@Don't pick up IPv6 link local IPs on address deletions.
This unbreaks carp reconfiguration.
OK henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.134 2007/03/25 18:26:23 mpf Exp $	*/
d371 2
d377 1
a377 1
			int count = 0;
d382 1
d401 9
a409 3
			rtrequest(RTM_DELETE, ifa->ifa_addr,
			    ifa->ifa_addr, ifa->ifa_netmask,
			    RTF_HOST, NULL, 0);
d432 8
a439 4

					rtrequest(RTM_ADD, ifa->ifa_addr,
					    ifa->ifa_addr, ifa->ifa_netmask,
					    RTF_UP | RTF_HOST, NULL, 0);
d443 9
a451 5
					    RTF_CLONING))
						rtrequest(RTM_DELETE, &sa,
						    ifa->ifa_addr,
						    ifa->ifa_netmask, 0, NULL,
						    0);
d456 6
a461 3
					if (rtrequest(RTM_ADD, ifa->ifa_addr,
					    ifa->ifa_addr, ifa->ifa_netmask, 0,
					    NULL, 0) == 0)
d463 2
@


1.134
log
@Synchronise carp advertisements on group demotion.
This reduces group failover time to a few milliseconds.
Diff from Nathanael.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.133 2007/03/18 23:23:17 mpf Exp $	*/
d1833 3
a1835 2
		else if (ifa->ifa_addr->sa_family == AF_INET6)
			new_naddrs6++;
@


1.133
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.132 2006/12/13 09:01:59 itojun Exp $	*/
d196 1
d2222 3
d2251 12
@


1.132
log
@use IN6_IS_SCOPE_EMBED to check kernel-internal form addresses
(s6_addr16[1] filled)
ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.131 2006/11/16 13:12:43 henning Exp $	*/
d129 2
d146 2
d199 2
a200 3
int	carp_addrcount(struct carp_if *, struct in_ifaddr *, int);
enum	{ CARP_COUNT_MASTER, CARP_COUNT_RUNNING };

d219 1
d272 4
d390 1
a390 1
				    ifatoia(ifa), CARP_COUNT_MASTER);
a842 1
	carp_set_enaddr(sc);
d1185 4
d1256 1
a1256 1
carp_addrcount(struct carp_if *cif, struct in_ifaddr *ia, int type)
d1263 86
a1348 4
		if ((type == CARP_COUNT_RUNNING &&
		    (vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
		    (IFF_UP|IFF_RUNNING)) ||
		    (type == CARP_COUNT_MASTER && vh->sc_state == MASTER)) {
d1351 2
a1352 1
				    ia->ia_addr.sin_addr.s_addr ==
d1354 12
a1365 1
					count++;
d1368 13
a1380 2
	}
	return (count);
d1389 9
d1406 1
a1406 1
		/* Count the elegible carp interfaces with this address */
d1410 1
a1410 1
			    ia, CARP_COUNT_RUNNING);
d1429 2
a1430 2
struct ifaddr *
carp_iamatch6(void *v, struct in6_addr *taddr)
d1432 10
a1441 3
	struct carp_if *cif = v;
	struct carp_softc *vh;
	struct ifaddr *ifa;
d1443 2
a1444 9
	TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
		TAILQ_FOREACH(ifa, &vh->sc_if.if_addrlist, ifa_list) {
			if (IN6_ARE_ADDR_EQUAL(taddr,
			    &ifatoia6(ifa)->ia_addr.sin6_addr) &&
			    ((vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
			    (IFF_UP|IFF_RUNNING)) && vh->sc_state == MASTER)
				return (ifa);
		}
	}
d1446 1
a1446 1
	return (NULL);
d1462 7
a1468 13
	switch (iftype) {
	case IFT_ETHER:
	case IFT_FDDI:
		if (ena[0] || ena[1] || ena[2] != 0x5e || ena[3] || ena[4] != 1)
			return (NULL);
		break;
	case IFT_ISO88025:
		if (ena[0] != 3 || ena[1] || ena[4] || ena[5])
			return (NULL);
		break;
	default:
		return (NULL);
		break;
a1469 8

	TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list)
		if ((vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
		    (IFF_UP|IFF_RUNNING) && vh->sc_state == MASTER &&
		    !bcmp(ena, vh->sc_ac.ac_enaddr,
		    ETHER_ADDR_LEN))
			return (&vh->sc_if);

d1484 3
a1486 1
	if (m->m_flags & (M_BCAST|M_MCAST)) {
a1503 1
	ifp = carp_ourether(cif, &eh, m->m_pkthdr.rcvif->if_type, 0);
d1520 29
d1771 1
a1771 2
	if (sc->sc_vhid == -1 || !sc->sc_carpdev) {
		bzero(&sc->sc_ac.ac_enaddr, sizeof (sc->sc_ac.ac_enaddr));
d1773 31
a1803 15
	} else if (sc->sc_carpdev && sc->sc_carpdev->if_type == IFT_ISO88025) {
		sc->sc_ac.ac_enaddr[0] = 3;
		sc->sc_ac.ac_enaddr[1] = 0;
		sc->sc_ac.ac_enaddr[2] = 0x40 >> (sc->sc_vhid - 1);
		sc->sc_ac.ac_enaddr[3] = 0x40000 >> (sc->sc_vhid - 1);
		sc->sc_ac.ac_enaddr[4] = 0;
		sc->sc_ac.ac_enaddr[5] = 0;
	} else {
		sc->sc_ac.ac_enaddr[0] = 0;
		sc->sc_ac.ac_enaddr[1] = 0;
		sc->sc_ac.ac_enaddr[2] = 0x5e;
		sc->sc_ac.ac_enaddr[3] = 0;
		sc->sc_ac.ac_enaddr[4] = 1;
		sc->sc_ac.ac_enaddr[5] = sc->sc_vhid;
	}
d1806 4
a1809 5
	if (bcmp(&sc->sc_ac.ac_enaddr, LLADDR(sc->sc_if.if_sadl),
	    sc->sc_if.if_addrlen) != 0) {
		bcopy(&sc->sc_ac.ac_enaddr,
		    LLADDR(sc->sc_if.if_sadl), sc->sc_if.if_addrlen);

d1817 2
d2093 1
a2093 1
			sc->sc_if.if_flags|= IFF_UP;
d2121 3
d2152 1
a2152 1
		if (carpr.carpr_vhid > 0) {
d2165 5
a2169 3
			sc->sc_vhid = carpr.carpr_vhid;
			carp_set_enaddr(sc);
			carp_set_state(sc, INIT);
d2225 2
d2281 2
@


1.132.2.1
log
@From mpf@@
>  Don't pick up IPv6 link local IPs on address deletions.
>  This unbreaks carp reconfiguration.
>  OK henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.132 2006/12/13 09:01:59 itojun Exp $	*/
d1675 2
a1676 3
		else if (ifa->ifa_addr->sa_family == AF_INET6 &&
		    !IN6_IS_ADDR_LINKLOCAL(&ifatoia6(ifa)->ia_addr.sin6_addr))
				new_naddrs6++;
@


1.131
log
@in carp_attach, create the "carp" interface group, so that it is always
and early in the boot process existant. needed by the rc scripts for
carp demotion on the "carp" group. this used to work because pfsync0
was always there and member of said group; it has been broken on pfsync-less
kernels for quite some time. ok mpf mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.130 2006/08/31 12:37:31 mcbride Exp $	*/
d299 1
a299 1
			if (IN6_IS_ADDR_LINKLOCAL(&in6)) {
d647 1
a647 1
			if (IN6_IS_ADDR_LINKLOCAL(&in6_src))
d649 1
a649 1
			if (IN6_IS_ADDR_LINKLOCAL(&in6_found))
@


1.130
log
@Automatically add a IPv6 link-local address to carp interfaces when the
virtual MAC address is set. Among other things, this makes route6d work
correctly on systems with carp interfaces.

In order to ensure backwards compatibility, we do not include IPv6
link-local addresses in generating the HMAC, but we accept HMACs with AND
without the link-local addresses. They will be added to the HMAC in a future
release.

In short: this change should only affect backwards compatibility for
IPv6 users who are manually adding link-local addresses on carp interfaces.

testing mtu@@ todd@@
ok mpf@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.129 2006/08/28 17:29:53 mcbride Exp $	*/
d782 4
@


1.130.2.1
log
@From mpf@@
>  Don't pick up IPv6 link local IPs on address deletions.
>  This unbreaks carp reconfiguration.
>  OK henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.130 2006/08/31 12:37:31 mcbride Exp $	*/
d1671 2
a1672 3
		else if (ifa->ifa_addr->sa_family == AF_INET6 &&
		    !IN6_IS_ADDR_LINKLOCAL(&ifatoia6(ifa)->ia_addr.sin6_addr))
				new_naddrs6++;
@


1.129
log
@Make carp see all IPv6 address additions and remove dead code in carp_ioctl()

ok mpf@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.128 2006/08/16 09:40:52 mpf Exp $	*/
d86 1
d105 2
d141 2
a142 1
	SHA1_CTX sc_sha1;
d175 1
d177 1
a177 1
	    unsigned char *);
d229 9
d256 4
a259 4
	SHA1Init(&sc->sc_sha1);
	SHA1Update(&sc->sc_sha1, sc->sc_pad, sizeof(sc->sc_pad));
	SHA1Update(&sc->sc_sha1, (void *)&version, sizeof(version));
	SHA1Update(&sc->sc_sha1, (void *)&type, sizeof(type));
d262 1
a262 1
	bcopy(&sc->sc_sha1, &sha1ctx, sizeof(sha1ctx));
d268 1
a268 1
	SHA1Update(&sc->sc_sha1, (void *)&vhid, sizeof(vhid));
d287 2
a288 1
			SHA1Update(&sc->sc_sha1, (void *)&cur, sizeof(cur));
d299 3
a301 1
			if (IN6_IS_ADDR_LINKLOCAL(&in6))
d303 1
d312 2
a313 1
			SHA1Update(&sc->sc_sha1, (void *)&cur6, sizeof(cur6));
d324 1
a324 1
    unsigned char md[20])
d329 1
a329 1
	bcopy(&sc->sc_sha1, &sha1ctx, sizeof(sha1ctx));
d346 1
d348 6
a353 3
	carp_hmac_generate(sc, counter, md2);

	return (bcmp(md, md2, sizeof(md2)));
d917 5
a921 1
	carp_hmac_generate(sc, ch->carp_counter, ch->carp_md);
d1626 1
a1626 1
	if (sc->sc_vhid == -1) {
d1628 1
d1645 14
a1658 2
	bcopy(&sc->sc_ac.ac_enaddr,
	    LLADDR(sc->sc_if.if_sadl), sc->sc_if.if_addrlen);
d1851 3
a1853 2
	sc->sc_naddrs6++;
	if (sc->sc_carpdev != NULL)
@


1.128
log
@Send out a second delayed gratuitous ARP request after
we've won the MASTER election.
This seems to be necessary w/ some wacky L3 switches,
that only learn by looking at ARP packets.
Fixes PR 5148.
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.127 2006/06/16 16:49:40 henning Exp $	*/
d1873 2
a1874 3
	struct ifaddr *ifa;
	struct ifreq *ifr;
	struct ifaliasreq *ifra;
a1877 4
	ifa = (struct ifaddr *)addr;
	ifra = (struct ifaliasreq *)addr;
	ifr = (struct ifreq *)addr;

a1892 22
			break;
#endif /* INET6 */
		default:
			error = EAFNOSUPPORT;
			break;
		}
		break;

	case SIOCAIFADDR:
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			sc->sc_if.if_flags |= IFF_UP;
			bcopy(ifa->ifa_addr, ifa->ifa_dstaddr,
			    sizeof(struct sockaddr));
			error = carp_set_addr(sc, satosin(&ifra->ifra_addr));
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			sc->sc_if.if_flags |= IFF_UP;
			error = carp_set_addr6(sc, satosin6(&ifra->ifra_addr));
@


1.127
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.126 2006/06/02 19:53:12 mpf Exp $	*/
d144 1
d1039 6
d1393 2
d1438 1
@


1.126
log
@Introduce attributes to interface groups.
As a first user, move the global carp(4) demotion counter
into the interface group. Thus we have the possibility
to define which carp interfaces are demoted together.

Put the demotion counter into the reserved field of the carp header.
With this, we can have carp act smarter if multiple errors occur.
It now always takes over other carp peers, that are advertising
with a higher demote count.  As a side effect, we can also have
group failovers without the need of running in preempt mode.
The protocol change does not break compability with older
implementations.

Collaborative work with mcbride@@

OK mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.125 2006/05/22 23:25:15 krw Exp $	*/
d367 1
a367 1
			    RTF_HOST, NULL);
d393 1
a393 1
					    RTF_UP | RTF_HOST, NULL);
d400 2
a401 1
						    ifa->ifa_netmask, 0, NULL);
d408 1
a408 1
					    NULL) == 0)
@


1.125
log
@Check for NULL cookies before calling hook_disestablish(). Just in case
the establish calls were bypassed or failed.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.124 2006/05/18 12:39:23 mpf Exp $	*/
a147 1
int carp_suppress_preempt = 0;
d185 1
d209 1
d668 1
a668 1
	if (carp_suppress_preempt && sc->sc_advskew <  240)
d684 3
a686 1
		    timercmp(&sc_tv, &ch_tv, ==)) {
d704 9
d836 1
a836 1
		carp_suppress_preempt--;
d840 1
a840 1
		carp_suppress_preempt--;
d944 1
a944 1
		if (!carp_suppress_preempt || sc->sc_advskew > 240)
d955 1
a958 1
	ch.carp_pad1 = 0;	/* must be zero */
d1024 2
a1025 5
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS) {
				carp_suppress_preempt++;
				if (carp_suppress_preempt == 1)
					carp_send_ad_all();
			}
d1031 1
a1031 1
					carp_suppress_preempt--;
d1100 2
a1101 5
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS) {
				carp_suppress_preempt++;
				if (carp_suppress_preempt == 1)
					carp_send_ad_all();
			}
d1107 1
a1107 1
					carp_suppress_preempt--;
d2025 5
a2029 1

d2038 17
d2103 36
d2162 2
a2163 5
			if (!suppressed) {
				carp_suppress_preempt++;
				if (carp_suppress_preempt == 1)
					carp_send_ad_all();
			}
d2169 1
a2169 1
				carp_suppress_preempt--;
@


1.124
log
@Add a duplicate check for our own advertisements.  This is necessary
for dumb non simplex interfaces, that receive packets they've just
sent.  Fixes bug 5121.
OK deraadt@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.123 2006/03/26 14:54:01 camield Exp $	*/
d838 3
a840 2
		hook_disestablish(sc->sc_carpdev->if_linkstatehooks,
		    sc->lh_cookie);
@


1.123
log
@if_link_state_change() is more appropriate here.

ok henning mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.122 2006/03/25 22:41:48 djm Exp $	*/
d589 42
@


1.122
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.121 2006/03/23 14:18:55 mcbride Exp $	*/
d2029 1
a2029 1
	rt_ifmsg(&sc->sc_if);
@


1.121
log
@Set a carp MAC address of 00:00:00:00:00:00 if no vhid is assigned.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.120 2006/03/22 14:37:44 henning Exp $	*/
d1311 2
a1312 1
		bpf_mtap_hdr(ifp->if_bpf, (char *)&eh, ETHER_HDR_LEN, m);
@


1.120
log
@prevent anything outside rote.c from accessing the routing table heads
directly. rather provide a rt_lookup function for regular lookups,
and a rt_gettable for those that need access to the head for some reason.
the latter cases should be revisted later probably so that nothing outside
the routing core code accesses the heads at all...
tested claudio jolan me, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.119 2006/01/28 23:47:20 mpf Exp $	*/
d1538 3
a1540 1
	if (sc->sc_carpdev && sc->sc_carpdev->if_type == IFT_ISO88025) {
@


1.119
log
@Fix hmac calculation.
Add some f's; do comparison in host byte order.
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.118 2005/11/29 09:57:44 mpf Exp $	*/
d344 1
a344 2
			struct radix_node_head *rnh =
			    rt_tables[ifa->ifa_addr->sa_family];
d369 2
d380 2
a381 2
			rn = rnh->rnh_lookup(&sa, ifa->ifa_netmask, rnh);
			rt = (struct rtentry *)rn;
@


1.118
log
@Fix IPv6 hmac calculation.
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.117 2005/11/29 02:59:42 jolan Exp $	*/
d260 1
a260 1
		cur.s_addr = 0xffffff;
d263 3
a265 2
			if (ifa->ifa_addr->sa_family == AF_INET && 
		    	    in.s_addr > last.s_addr && in.s_addr < cur.s_addr) {
@


1.117
log
@something in the eurobsdcon route-a-thon broke my simple home network
router so back out the routing stuff to pre-eurobsdcon where my machine
doesn't crash immediately.

i am happy to test diffs and report success/failures but i am not happy
to have instantaneous crashes when i reboot with a new kernel that was
compiled from pristine sources.

if you are going to be an elitist asshole then you could at least make
sure your code works.

ok and "be crass towards them" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.115 2005/11/27 10:58:06 mpf Exp $	*/
d274 1
a274 1
	memset(&cur, 0x00, sizeof(cur));
d278 1
a278 1
		memset(&cur, 0xff, sizeof(cur));
d291 1
a291 1
			SHA1Update(&sc->sc_sha1, (void *)&cur6, sizeof(in6));
@


1.116
log
@don't let anything outside route.c access the routing table heads directly,
but go through a provided wrapper.
also provide rt_lookup() instead of doing the lookup manually in many places.
ryan ok
@
text
@a341 1
			struct sockaddr_in mask;
d343 3
d369 2
a370 3
			memset(&mask, 1, sizeof(mask));
			rt = (struct rtentry *)rt_lookup(ifa->ifa_addr,
			    sintosa(&mask), 0);
d378 2
a379 3
			
			rt = (struct rtentry *)rt_lookup(&sa,
			    ifa->ifa_netmask, 0);
@


1.115
log
@Completly remove transition path INIT -> MASTER.
A bug introduced in -r 1.4 led lower priotorized hosts
switching to MASTER state for a short time at bootup,
if preemption was enabled.
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.114 2005/11/27 10:48:59 mcbride Exp $	*/
d342 1
a343 3
			struct radix_node_head *rnh =
			    rt_tables[ifa->ifa_addr->sa_family];
			struct radix_node *rn;
d367 3
a369 2
			rn = rnh->rnh_matchaddr(ifa->ifa_addr, rnh);
			rt = (struct rtentry *)rn;
d377 3
a379 2
			rn = rnh->rnh_lookup(&sa, ifa->ifa_netmask, rnh);
			rt = (struct rtentry *)rn;
@


1.114
log
@Sort the IP addresses in ascending order when doing the carp hmac; makes
alias address order on the interface irrelevant.

prodding by henning@@, ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.113 2005/11/04 08:11:54 mcbride Exp $	*/
d1368 3
a1370 13
		if (carp_opts[CARPCTL_PREEMPT] && !carp_suppress_preempt) {
			carp_set_state(sc, MASTER);
			carp_setroute(sc, RTM_ADD);
			carp_send_ad(sc);
			carp_send_arp(sc);
#ifdef INET6
			carp_send_na(sc);
#endif /* INET6 */
		} else {
			carp_set_state(sc, BACKUP);
			carp_setroute(sc, RTM_DELETE);
			carp_setrun(sc, 0);
		}
@


1.113
log
@Add carp_hash() - hash the ethernet address of the ARP request and use
the result to determine which carp interface should answer rather than
simply using the ip address.

Fixes breakage debugged by Matt Bradford <m.bradford@@isrc.qut.edu.au>

'just commit' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.112 2005/10/31 01:40:54 pascoe Exp $	*/
d227 2
a228 1
	int i;
d230 1
a230 1
	struct in6_addr in6;
d253 2
d256 16
a271 6
	TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET)
			SHA1Update(&sc->sc_sha1,
			    (void *)&ifatoia(ifa)->ia_addr.sin_addr.s_addr,
			    sizeof(struct in_addr));
	}
d274 6
a279 2
	TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET6) {
d283 6
a288 1
			SHA1Update(&sc->sc_sha1, (void *)&in6, sizeof(in6));
d290 3
a292 1
	}
@


1.112
log
@Fix a TAILQ_FOREACH where the item containing the next pointer could be
freed.

ok canacar deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.111 2005/10/24 14:31:26 mcbride Exp $	*/
d139 1
d196 1
d224 2
d243 8
d1094 36
d1177 2
a1178 3
		/* this should be a hash, like pf_hash() */
		if (ia->ia_addr.sin_addr.s_addr % *count == index - 1 &&
                    sc->sc_state == MASTER) {
@


1.111
log
@Remove redundant duplicate packet length check.

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.110 2005/09/29 19:39:41 mpf Exp $	*/
d776 2
a777 1
	struct carp_softc *sc;
d779 2
a780 1
	TAILQ_FOREACH(sc, &((struct carp_if *)ifp->if_carp)->vhif_vrs, sc_list)
d782 1
@


1.110
log
@Rework of multicast deletion code.
The previous code could wrongly delete multicast groups
on the parent interface. Now we forward only remembered
delete requests to the carpdev.
OK mcbride, mickey. "Get it in" deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.109 2005/08/31 04:49:21 mcbride Exp $	*/
a437 21
	iplen = ip->ip_hl << 2;

	if (m->m_pkthdr.len < iplen + sizeof(*ch)) {
		carpstats.carps_badlen++;
		CARP_LOG(sc, ("received len %d < %d on %s",
		    m->m_len - sizeof(struct ip), sizeof(*ch),
		    m->m_pkthdr.rcvif->if_xname));
		m_freem(m);
		return;
	}

	if (iplen + sizeof(*ch) < m->m_len) {
		if ((m = m_pullup2(m, iplen + sizeof(*ch))) == NULL) {
			carpstats.carps_hdrops++;
			/* CARP_LOG ? */
			return;
		}
		ip = mtod(m, struct ip *);
	}
	ch = (void *)ip + iplen;

d442 1
@


1.109
log
@Comment out KASSERT(mc != NULL) in carp_ether_delmulti. Because we mess with
the multicast list elsewhere, it can occur under certain conditions (PR4475).

ok deraadt@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.108 2005/07/31 03:52:19 pascoe Exp $	*/
d792 1
a792 1
/* Detach an interface from the carp.  */
d2094 10
d2113 2
a2114 13
		for (mc = LIST_FIRST(&sc->carp_mc_listhead); mc != NULL;
		    mc = LIST_NEXT(mc, mc_entries)) {
			if (mc->mc_enm == enm) {
				LIST_REMOVE(mc, mc_entries);
				FREE(mc, M_DEVBUF);
				break;
			}
		}
		/*
		 * XXX We don't actually want KASSERT(mc != NULL) here
		 * because we mess with the multicast addresses elsewhere.
		 * Clean up after release.
		 */
@


1.109.2.1
log
@MFC:
Fix by mpf@@

Completly remove transition path INIT -> MASTER.
A bug introduced in -r 1.4 led lower priotorized hosts
switching to MASTER state for a short time at bootup,
if preemption was enabled.

ok deraadt@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.109 2005/08/31 04:49:21 mcbride Exp $	*/
d1314 13
a1326 3
		carp_set_state(sc, BACKUP);
		carp_setroute(sc, RTM_DELETE);
		carp_setrun(sc, 0);
@


1.108
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.107 2005/06/19 18:17:02 pascoe Exp $	*/
d2111 5
a2115 1
		KASSERT(mc != NULL);
@


1.107
log
@Don't reflect CARP's internal state via IFF_UP (which a user can modify), use
IFF_RUNNING instead.  Also, do not blindly restore flags onto an interface when
returning to the running state.

This eliminates the possibility that the kernel will bring the interface back
up after a link state change on the physical interface, even though the user
may have done an "ifconfig carpN down" in the meantime.  Similarly two link
state down events on the physical interface in succession could result in us
never coming out of the INIT state.

The master/backup state is still reported via link state information, so
bgpd/ospfd, etc, should function as before.

This also addresses PR4238.

ok mpf@@, ok with the idea etc henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.106 2005/05/27 08:33:25 mpf Exp $	*/
d1254 2
a1255 15
	if (ifp->if_bpf) {
		/*
		 * Do the usual BPF fakery.  Note that we don't support
		 * promiscuous mode here, since it would require the
		 * drivers to know about CARP and we're not ready for
		 * that yet.
		 */
		struct mbuf m0;

		m0.m_flags = 0;
		m0.m_next = m;
		m0.m_len = ETHER_HDR_LEN;
		m0.m_data = (char *)&eh;
		bpf_mtap(ifp->if_bpf, &m0);
	}
@


1.106
log
@only access if_linkstatehooks inside splnet.
with pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.105 2005/04/20 23:00:41 mpf Exp $	*/
a117 1
	int sc_flags_backup;
a701 1
	sc->sc_flags_backup = 0;
d834 2
a835 2
			if ((vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) &&
			    vh->sc_state == MASTER)
d1317 1
a1317 1
	    (sc->sc_naddrs || sc->sc_naddrs6)) {
d2009 2
d2013 1
a2013 2
			sc->sc_flags_backup = sc->sc_if.if_flags;
			sc->sc_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
d2018 1
d2020 1
a2020 1
			if (!sc->sc_suppress) {
a2024 1
			sc->sc_suppress = 1;
a2025 1
			sc->sc_if.if_flags |= sc->sc_flags_backup;
d2027 1
d2029 1
a2029 1
			if (sc->sc_suppress)
a2030 1
			sc->sc_suppress = 0;
@


1.105
log
@Introduce if_linkstatehooks.
This converts if_link_state_change() to a generic usable
callback with dohooks().

OK henning@@, camield@@
Tested by camield@@ and Alexey E. Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.104 2005/03/15 15:51:27 mcbride Exp $	*/
d759 1
d778 1
d791 1
d1414 1
d1492 1
d1496 1
@


1.104
log
@- stop tearing down routes when the carp interface goes to backup in the
  carpdev case; block outgoing packets in carp_output() instead.
- unbreak the "bow out on 'ifconfig down'" behaviour, allows instant
  failover on graceful halt/reboot to work again.

ok mpf@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.103 2005/03/13 18:26:29 pat Exp $	*/
d109 1
d778 2
d1488 2
a1495 1

d1993 1
a1993 1
carp_carpdev_state(struct ifnet *ifp)
d1997 1
@


1.104.2.1
log
@MFC:
Fix by mpf@@

Completly remove transition path INIT -> MASTER.
A bug introduced in -r 1.4 led lower priotorized hosts
switching to MASTER state for a short time at bootup,
if preemption was enabled.

ok deraadt@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.104 2005/03/15 15:51:27 mcbride Exp $	*/
d1323 13
a1335 3
		carp_set_state(sc, BACKUP);
		carp_setroute(sc, RTM_DELETE);
		carp_setrun(sc, 0);
@


1.103
log
@fix a potential crash that could occur when CARP_LOG is being used.

ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.102 2005/03/05 13:33:49 mpf Exp $	*/
d119 1
a372 4
				if (nr_ourif)
					rtrequest(RTM_DELETE, &sa,
					    ifa->ifa_addr, ifa->ifa_netmask, 0,
					    NULL);
d857 3
a859 3
	/* bow out if we've lost our UPness or RUNNINGuiness */
	if ((sc->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
	    (IFF_UP|IFF_RUNNING)) {
d1324 2
a1330 2
			carp_set_state(sc, MASTER);
			carp_setroute(sc, RTM_ADD);
a1825 1
			sc->sc_if.if_flags &= ~IFF_UP;
d1829 4
a1832 1
			if (sc->sc_state == MASTER)
d1834 2
d1957 1
a1957 1
	struct ifnet *ifp0 = ((struct carp_softc *)ifp->if_softc)->sc_carpdev;
d1959 2
a1960 2
	if (ifp0 != NULL)
		return (ifp0->if_output(ifp, m, sa, rt));
d1963 1
a1963 1
		return (EINVAL);
@


1.102
log
@Remove code which enforces a advskew=0 for the case
that carp shares the IP addresse with its physical interface.
It's neither supported nor needed, since we have carpdev now.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.101 2005/03/01 19:04:56 mcbride Exp $	*/
d536 1
a536 2
		CARP_LOG(sc, ("packet size %u too small on %s", len,
		    m->m_pkthdr.rcvif->if_xname));
@


1.101
log
@Unbreak arp_input with carp; add back the call to carp_iamatch()
which was removed in rev 1.57. This makes arpbalance work again, and
ensures that only one carp host will reply to a given arp request.

ok mpf@@ pascoe@@ dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.100 2005/02/28 00:26:47 mcbride Exp $	*/
d1568 1
a1568 1
	int own, error = 0;
d1580 1
a1580 1
	ia_if = NULL; own = 0;
a1591 2
			if (sin->sin_addr.s_addr == ia->ia_addr.sin_addr.s_addr)
				own++;
a1617 2
	if (own)
		sc->sc_advskew = 0;
d1659 1
a1659 1
	int own, error = 0;
d1671 1
a1671 1
	ia_if = NULL; own = 0;
a1688 3
			if (IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr,
			    &ia->ia_addr.sin6_addr))
				own++;
@


1.100
log
@Remove unused variable if_flags in struct carp_softc, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.99 2005/02/08 13:42:27 markus Exp $	*/
d1123 2
a1124 2
carp_iamatch(void *v, struct in_ifaddr *ia,
    struct in_addr *isaddr, u_int8_t **enaddr)
d1126 1
a1126 4
	struct carp_if *cif = v;
	struct carp_softc *vh;
	int index, count = 0;
	struct ifaddr *ifa;
a1129 1
		 * XXX proof of concept implementation.
d1135 9
a1143 3
		count = carp_addrcount(cif, ia, CARP_COUNT_RUNNING);
		if (count == 0) {
			/* should never reach this */
a1144 1
		}
d1147 3
a1149 24
		index = isaddr->s_addr % count;
		count = 0;

		TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
			if ((vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
			    (IFF_UP|IFF_RUNNING)) {
				TAILQ_FOREACH(ifa, &vh->sc_if.if_addrlist,
				    ifa_list) {
					if (ifa->ifa_addr->sa_family ==
					    AF_INET &&
					    ia->ia_addr.sin_addr.s_addr ==
					    ifatoia(ifa)->ia_addr.sin_addr.s_addr) {
						if (count == index) {
							if (vh->sc_state ==
							    MASTER) {
								*enaddr = vh->sc_ac.ac_enaddr;
								return (1);
							} else
								return (0);
						}
						count++;
					}
				}
			}
d1152 2
a1153 8
		TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
			if ((vh->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
			    (IFF_UP|IFF_RUNNING) && ia->ia_ifp ==
			    &vh->sc_if && vh->sc_state == MASTER) {
				*enaddr = vh->sc_ac.ac_enaddr;
				return (1);
			}
		}
@


1.99
log
@build w/o INET6; ok mpf@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.98 2005/02/07 08:58:37 mcbride Exp $	*/
a107 1
	int if_flags;			/* current flags to treat UP/DOWN */
@


1.98
log
@Unrevert the changes introduced in 1.96 and accidentally removed in 1.97
with an id10t error by yours truly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.96 2005/02/07 04:14:39 pascoe Exp $	*/
d78 1
a85 1
#include <net/if_dl.h>
d1403 1
d1405 1
d1418 1
d1427 1
d1481 1
d1489 1
@


1.97
log
@Prevent carp from attaching to other carp interfaces, which the
ifp->if_flags & IFF_MULTICAST checks no longer protect against.

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.95 2005/01/29 10:06:16 mcbride Exp $	*/
d1546 34
a1847 19
			break;
#endif /* INET6 */
		default:
			error = EAFNOSUPPORT;
			break;
		}
		break;

	case SIOCDIFADDR:
		sc->sc_if.if_flags &= ~IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			sc->sc_naddrs--;
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			sc->sc_naddrs6--;
@


1.96
log
@There is no SIOCDIFADDR call into interfaces on address deletion, so
use our carp_addr_updated callback to detect deletion and reconfigure
appropriately.

ok mcbride@@
@
text
@d1443 3
a1545 34
	struct ifaddr *ifa;
	int new_naddrs = 0, new_naddrs6 = 0;

	TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET)
			new_naddrs++;
		else if (ifa->ifa_addr->sa_family == AF_INET6)
			new_naddrs6++;
	}

	/* Handle a callback after SIOCDIFADDR */
	if (new_naddrs < sc->sc_naddrs || new_naddrs6 < sc->sc_naddrs6) {
		struct in_addr mc_addr;
		struct in_multi *inm;

		sc->sc_naddrs = new_naddrs;
		sc->sc_naddrs6 = new_naddrs6;

		/* Re-establish multicast membership removed by in_control */
		mc_addr.s_addr = INADDR_CARP_GROUP;
		IN_LOOKUP_MULTI(mc_addr, &sc->sc_if, inm);
		if (inm == NULL) {
			bzero(&sc->sc_imo, sizeof(sc->sc_imo));

			if (sc->sc_carpdev != NULL && sc->sc_naddrs > 0)
				carp_join_multicast(sc);
		}

		if (sc->sc_naddrs == 0 && sc->sc_naddrs6 == 0) {
			sc->sc_if.if_flags &= ~IFF_UP;
			carp_set_state(sc, INIT);
		} else
			carp_hmac_prepare(sc);
	}
d1573 1
d1675 1
d1814 19
@


1.95
log
@Check the carpdev link state when we attach to it, makes a firewall
with an interface down avoid preempting after a reboot.

Pointed out by Stephen Marley <stephen.marley@@catwoman.cl-is.com>

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.94 2005/01/18 23:26:52 mpf Exp $	*/
d1543 34
a1842 19
			break;
#endif /* INET6 */
		default:
			error = EAFNOSUPPORT;
			break;
		}
		break;

	case SIOCDIFADDR:
		sc->sc_if.if_flags &= ~IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			sc->sc_naddrs--;
			break;
#endif /* INET */
#ifdef INET6
		case AF_INET6:
			sc->sc_naddrs6--;
@


1.94
log
@Rewriting the lladdr can now be done without using mbuf tags.
Advertisements run through the carp interface first.
So we just take the address from ifp0.
While we're there,
also remove carp_macmatch6, which isn't used anymore.

Proposed by mcbride@@
ok mcbride@@, pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.93 2005/01/06 21:45:35 deraadt Exp $	*/
d1507 1
@


1.93
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.92 2005/01/06 09:29:21 mcbride Exp $	*/
a805 3
	struct m_tag *mtag;
	struct ifnet *ifp = &sc->sc_if;

a818 11
	/* Tag packet for carp_fix_lladdr */
	mtag = m_tag_get(PACKET_TAG_CARP, sizeof(struct ifnet *), M_NOWAIT);
	if (mtag == NULL) {
		m_freem(m);
		sc->sc_if.if_oerrors++;
		carpstats.carps_onomem++;
		return (ENOMEM);
	}
	bcopy(&ifp, (caddr_t)(mtag + 1), sizeof(struct ifnet *));
	m_tag_prepend(m, mtag);

a1205 35

void *
carp_macmatch6(void *v, struct mbuf *m, struct in6_addr *taddr)
{
	struct m_tag *mtag;
	struct carp_if *cif = v;
	struct carp_softc *sc;
	struct ifaddr *ifa;


	TAILQ_FOREACH(sc, &cif->vhif_vrs, sc_list) {
		TAILQ_FOREACH(ifa, &sc->sc_if.if_addrlist, ifa_list) {
			if (IN6_ARE_ADDR_EQUAL(taddr,
			    &ifatoia6(ifa)->ia_addr.sin6_addr) &&
			    ((sc->sc_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
			    (IFF_UP|IFF_RUNNING))) {
				struct ifnet *ifp = &sc->sc_if;

				mtag = m_tag_get(PACKET_TAG_CARP,
				    sizeof(struct ifnet *), M_NOWAIT);
				if (mtag == NULL) {
					/* better a bit than nothing */
					return (sc->sc_ac.ac_enaddr);
				}
				bcopy(&ifp, (caddr_t)(mtag + 1),
				    sizeof(struct ifnet *));
				m_tag_prepend(m, mtag);

				return (sc->sc_ac.ac_enaddr);
			}
		}
	}

	return (NULL);
}
a1964 2
	if (ifp0) {
		struct m_tag *mtag;
d1966 1
a1966 16
		/* Tag packet for carp_fix_lladdr if not already tagged */
		mtag = m_tag_find(m, PACKET_TAG_CARP, NULL);
		if (mtag == NULL) {
			mtag = m_tag_get(PACKET_TAG_CARP,
			    sizeof(struct ifnet *), M_NOWAIT);
			if (mtag == NULL) {
				m_freem(m);
				((struct carp_softc *)ifp->if_softc
				    )->sc_if.if_oerrors++;
				carpstats.carps_onomem++;
				return (ENOBUFS);
			}
			bcopy(&ifp, (caddr_t)(mtag + 1),
			    sizeof(struct ifnet *));
			m_tag_prepend(m, mtag);
		}
d1968 1
a1968 1
	} else {
a1971 71
}

int
carp_fix_lladdr(struct ifnet *ifp, struct mbuf *m, struct sockaddr *sa,
    struct rtentry *rt)
{
	struct m_tag *mtag;
	struct carp_softc *sc;
	struct ifnet *carp_ifp;

	if (!sa)
		return (0);

	switch (sa->sa_family) {
#ifdef INET
	case AF_INET:
		break;
#endif /* INET */
#ifdef INET6
	case AF_INET6:
		break;
#endif /* INET6 */
	default:
		return (0);
	}

	mtag = m_tag_find(m, PACKET_TAG_CARP, NULL);
	if (mtag == NULL)
		return (0);
	bcopy(mtag + 1, &carp_ifp, sizeof(struct ifnet *));
	sc = carp_ifp->if_softc;

	/* Set the source MAC address to Virtual Router MAC Address */
	switch (sc->sc_carpdev->if_type) {
#if NETHER > 0
	case IFT_ETHER: {
			struct ether_header *eh;

			eh = mtod(m, struct ether_header *);
			bcopy(&sc->sc_ac.ac_enaddr, eh->ether_shost,
			    sizeof(eh->ether_shost));
		}
		break;
#endif
#if NFDDI > 0
	case IFT_FDDI: {
			struct fddi_header *fh;

			fh = mtod(m, struct fddi_header *);
			bcopy(&sc->sc_ac.ac_enaddr, fh->fddi_shost,
			    sizeof(fh->fddi_shost));
		}
		break;
#endif
#if NTOKEN > 0
	case IFT_ISO88025: {
			struct token_header *th;

			th = mtod(m, struct token_header *);
			bcopy(&sc->sc_ac.ac_enaddr, fh->token_shost,
			    sizeof(th->token_shost));
		}
		break;
#endif
	default:
		printf("%s: carp is not supported for this interface type\n",
		    sc->sc_carpdev->if_xname);
		return (EOPNOTSUPP);
	}

	return (0);
@


1.92
log
@Attach multicast to the carp interface for IPv6 (makes it consistent with
IPv4, and will allow us to get rid of carp_fix_lladdr() and the carp mbuf
tag later).

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.83 2004/12/17 12:42:01 pascoe Exp $	*/
d107 1
a107 1
#define	sc_carpdev 	sc_ac.ac_if.if_carpdev
d202 2
a203 2
int     carp_clone_create(struct if_clone *, int);
int     carp_clone_destroy(struct ifnet *);
d357 1
a357 1
					if (nr_ourif && !(rt->rt_flags & 
d369 1
a369 1
		 				ifa->ifa_flags |= IFA_ROUTE;
d374 1
a374 1
					rtrequest(RTM_DELETE, &sa, 
d850 1
a850 1
			     vh->sc_state == MASTER)
d1660 1
a1660 1
		sc->ah_cookie = hook_establish(sc->sc_if.if_addrhooks, 0, 
d2020 1
a2020 1
			mtag = m_tag_get(PACKET_TAG_CARP, 
d2029 1
a2029 1
			bcopy(&ifp, (caddr_t)(mtag + 1), 
@


1.91
log
@Error path cleanups for carp_output.  Use ENOBUFS instead of ENOMEM when
unable to tag a packet, and free mbuf chain on all failures.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.90 2005/01/06 00:41:51 pascoe Exp $	*/
d196 1
a196 1
int	carp_join_multicast(struct carp_softc *, struct ifnet *);
d200 1
a200 1
int	carp_join_multicast6(struct carp_softc *, struct ifnet *);
d515 1
a515 1
	if (m->m_pkthdr.rcvif->if_carp == NULL) {
a564 6
	struct carp_if *cif;

	if (m->m_pkthdr.rcvif->if_type == IFT_CARP)
		cif = (struct carp_if *) m->m_pkthdr.rcvif->if_carpdev->if_carp;
	else
		cif = (struct carp_if *) m->m_pkthdr.rcvif->if_carp;
d566 2
a567 1
	TAILQ_FOREACH(sc, &cif->vhif_vrs, sc_list)
d1517 1
a1517 1
		    (error = carp_join_multicast(sc, ifp)) != 0) {
d1524 1
a1524 1
		    (error = carp_join_multicast6(sc, ifp)) != 0) {
d1644 1
a1644 1
	if (sc->sc_naddrs == 0 && (error = carp_join_multicast(sc, ifp)) != 0)
d1667 1
a1667 1
carp_join_multicast(struct carp_softc *sc, struct ifnet *ifp)
d1745 1
a1745 1
	if (sc->sc_naddrs6 == 0 && (error = carp_join_multicast6(sc, ifp)) != 0)
d1758 1
a1758 1
carp_join_multicast6(struct carp_softc *sc, struct ifnet *ifp)
a1764 7
	/*
	 * For IPv6, we can attach to the physical interface, as
	 * there will be a link-local address there.
	 * This way we don't need a link-local address on the
	 * CARP interface.
	 */

d1770 1
a1770 1
	addr6.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
d1772 1
a1772 1
	if ((imm = in6_joingroup(ifp,
d1779 1
a1779 1
	addr6.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
d1784 1
a1784 1
	if ((imm2 = in6_joingroup(ifp,
d1791 1
a1791 1
	im6o->im6o_multicast_ifp = sc->sc_carpdev;
@


1.90
log
@Tag all packets sent via a CARP interface for link local address
substitution.

With this change and the previous ARP changes, all Ethernet packets sent
via a CARP interface should now have the virtual MAC address as the source.

ok mcbride@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.89 2005/01/04 10:30:00 pascoe Exp $	*/
d2039 1
a2039 1
				return (ENOMEM);
d2046 2
a2047 1
	} else
d2049 1
@


1.89
log
@Move processing of ARP packets for CARP addresses to the carp interface
instead of processing them in the parent interface.  This causes us to send
ARP packets on a carpdev with its virtual MAC address as the source, rather
than the parent's physical address.

Permits us to fail over cleanly when connected to devices that use the
source MAC address on a received ARP request to generate an ARP entry for
the requesting host, rather than going through the who-has/is-at procedure.

ok niklas@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.88 2004/12/22 06:04:33 pascoe Exp $	*/
d2026 19
a2044 1
	if (ifp0)
d2046 1
a2046 1
	else
@


1.88
log
@Instead of running carp_setroute synchronously, use if_addrhooks to get a
callback after in_ifinit has run.  This lets us correct any routes that
in_ifinit has incorrectly added for our interface.

Also be more explicit with the routing checks/changes that we make.  This
makes it possible to have different prefix lengths on a CARP interface and
the physical interface it is bound to.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.87 2004/12/19 23:44:03 mcbride Exp $	*/
d732 1
a732 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST | IFF_NOARP;
@


1.87
log
@#define sc_if sc_ac.ac_if, makes things a little more readable, and
kills a couple of ugly line wraps. From Max Laier.

ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.86 2004/12/19 03:25:37 mcbride Exp $	*/
d109 1
d194 1
d310 1
d332 1
a332 1
			/* Check for a route on a physical interface */
d335 10
d348 4
a351 2
				if (rt && rt->rt_ifp != &sc->sc_if &&
				    rt->rt_flags & (RTF_CLONING|RTF_CLONED)) {
d355 8
a362 1
				} else {
d366 4
a369 3
					rtrequest(RTM_ADD, ifa->ifa_addr,
					    ifa->ifa_addr, ifa->ifa_netmask,
					    0, NULL);
d373 4
a376 14
				ifa->ifa_rtrequest = NULL;
				ifa->ifa_flags &= ~RTF_CLONING;

				if (!(rt && rt->rt_ifp != &sc->sc_if &&
				    rt->rt_flags & (RTF_CLONING|RTF_CLONED))) {
					bcopy(ifa->ifa_addr, &sa, sizeof(sa));
					satosin(&sa)->sin_addr.s_addr =
					    satosin(ifa->ifa_netmask
					    )->sin_addr.s_addr &
					    satosin(&sa)->sin_addr.s_addr;

					rtrequest(cmd, &sa, ifa->ifa_addr,
					    ifa->ifa_netmask, 0, NULL);
				}
d1592 8
d1659 8
a1666 1
	carp_setrun(sc, 0);
@


1.86
log
@Make it possible for carp to work on fddi and token ring again.

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.85 2004/12/18 00:52:21 pascoe Exp $	*/
d106 2
a107 1
#define sc_carpdev sc_ac.ac_if.if_carpdev
d161 1
a161 1
			    (sc)->sc_ac.ac_if.if_xname);		\
d239 1
a239 1
	TAILQ_FOREACH(ifa, &sc->sc_ac.ac_if.if_addrlist, ifa_list) {
d247 1
a247 1
	TAILQ_FOREACH(ifa, &sc->sc_ac.ac_if.if_addrlist, ifa_list) {
d299 1
a299 1
	TAILQ_FOREACH(ifa, &sc->sc_ac.ac_if.if_addrlist, ifa_list) {
d335 1
a335 2
				if (rt && rt->rt_ifp != &sc->sc_ac.ac_if &&

d353 1
a353 1
				if (!(rt && rt->rt_ifp != &sc->sc_ac.ac_if &&
d563 1
a563 1
	if (!sc || (sc->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) !=
d570 3
a572 3
	getmicrotime(&sc->sc_ac.ac_if.if_lastchange);
	sc->sc_ac.ac_if.if_ipackets++;
	sc->sc_ac.ac_if.if_ibytes += m->m_pkthdr.len;
d577 1
a577 1
		sc->sc_ac.ac_if.if_ierrors++;
d587 1
a587 1
		sc->sc_ac.ac_if.if_ierrors++;
d715 1
a715 1
	ifp = &sc->sc_ac.ac_if;
d769 1
a769 1
	sc->sc_ac.ac_if.if_flags &= ~IFF_UP;
d799 1
a799 1
	struct ifnet *ifp = &sc->sc_ac.ac_if;
d818 1
a818 1
		sc->sc_ac.ac_if.if_oerrors++;
d841 1
a841 1
			if ((vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) &&
d864 1
a864 1
		sc->sc_ac.ac_if.if_oerrors++;
d869 2
a870 2
	if ((sc->sc_ac.ac_if.if_flags &
	    (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING)) {
d899 1
a899 1
			sc->sc_ac.ac_if.if_oerrors++;
d940 3
a942 3
		getmicrotime(&sc->sc_ac.ac_if.if_lastchange);
		sc->sc_ac.ac_if.if_opackets++;
		sc->sc_ac.ac_if.if_obytes += len;
d952 1
a952 1
			sc->sc_ac.ac_if.if_oerrors++;
d979 1
a979 1
			sc->sc_ac.ac_if.if_oerrors++;
d1020 3
a1022 3
		getmicrotime(&sc->sc_ac.ac_if.if_lastchange);
		sc->sc_ac.ac_if.if_opackets++;
		sc->sc_ac.ac_if.if_obytes += len;
d1031 1
a1031 1
			sc->sc_ac.ac_if.if_oerrors++;
d1071 1
a1071 1
	TAILQ_FOREACH(ifa, &sc->sc_ac.ac_if.if_addrlist, ifa_list) {
d1092 1
a1092 1
	TAILQ_FOREACH(ifa, &sc->sc_ac.ac_if.if_addrlist, ifa_list) {
d1115 1
a1115 1
		    (vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
d1118 1
a1118 2
			TAILQ_FOREACH(ifa, &vh->sc_ac.ac_if.if_addrlist,
			    ifa_list) {
d1157 1
a1157 1
			if ((vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
d1159 1
a1159 1
				TAILQ_FOREACH(ifa, &vh->sc_ac.ac_if.if_addrlist,
d1180 1
a1180 1
			if ((vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
d1182 1
a1182 1
			    &vh->sc_ac.ac_if && vh->sc_state == MASTER) {
d1201 1
a1201 1
		TAILQ_FOREACH(ifa, &vh->sc_ac.ac_if.if_addrlist, ifa_list) {
d1204 2
a1205 3
			    ((vh->sc_ac.ac_if.if_flags &
			    (IFF_UP|IFF_RUNNING)) == (IFF_UP|IFF_RUNNING)) &&
			    vh->sc_state == MASTER)
d1223 1
a1223 1
		TAILQ_FOREACH(ifa, &sc->sc_ac.ac_if.if_addrlist, ifa_list) {
d1226 3
a1228 3
			    ((sc->sc_ac.ac_if.if_flags &
			    (IFF_UP|IFF_RUNNING)) == (IFF_UP|IFF_RUNNING))) {
				struct ifnet *ifp = &sc->sc_ac.ac_if;
d1277 1
a1277 1
		if ((vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
d1281 1
a1281 1
			return (&vh->sc_ac.ac_if);
d1309 2
a1310 2
			m0->m_pkthdr.rcvif = &vh->sc_ac.ac_if;
			ether_input(&vh->sc_ac.ac_if, &eh, m0);
d1352 1
a1352 1
		    sc->sc_ac.ac_if.if_xname);
d1379 1
a1379 1
		sc->sc_ac.ac_if.if_flags &= ~IFF_RUNNING;
d1384 3
a1386 3
	if (sc->sc_ac.ac_if.if_flags & IFF_UP &&
	    sc->sc_vhid > 0 && (sc->sc_naddrs || sc->sc_naddrs6)) {
		sc->sc_ac.ac_if.if_flags |= IFF_RUNNING;
d1388 1
a1388 1
		sc->sc_ac.ac_if.if_flags &= ~IFF_RUNNING;
d1546 1
a1546 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1550 1
a1550 1
		sc->sc_ac.ac_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
d1576 1
a1576 1
	    LLADDR(sc->sc_ac.ac_if.if_sadl), sc->sc_ac.ac_if.if_addrlen);
d1587 1
a1587 1
		if (!(sc->sc_ac.ac_if.if_flags & IFF_UP))
d1590 1
a1590 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1601 1
a1601 1
		if (ia->ia_ifp != &sc->sc_ac.ac_if &&
d1633 1
a1633 1
		sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1652 1
a1652 1
	    in_addmulti(&addr, &sc->sc_ac.ac_if)) == NULL) {
d1658 1
a1658 1
	imo->imo_multicast_ifp = &sc->sc_ac.ac_if;
d1674 1
a1674 1
		if (!(sc->sc_ac.ac_if.if_flags & IFF_UP))
d1677 1
a1677 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1695 1
a1695 1
		if (ia->ia_ifp != &sc->sc_ac.ac_if &&
d1727 1
a1727 1
		sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1809 1
a1809 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1817 1
a1817 1
			sc->sc_ac.ac_if.if_flags|= IFF_UP;
d1831 1
a1831 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1839 1
a1839 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1850 1
a1850 1
		sc->sc_ac.ac_if.if_flags &= ~IFF_UP;
d1870 1
a1870 1
			sc->sc_ac.ac_if.if_flags &= ~IFF_UP;
d1879 1
a1879 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d2084 1
a2084 1
		sc->sc_ac.ac_if.if_link_state = LINK_STATE_DOWN;
d2087 1
a2087 1
		sc->sc_ac.ac_if.if_link_state = LINK_STATE_UP;
d2090 1
a2090 1
		sc->sc_ac.ac_if.if_link_state = LINK_STATE_UNKNOWN;
d2093 1
a2093 1
	rt_ifmsg(&sc->sc_ac.ac_if);
d2110 2
a2111 2
			sc->sc_flags_backup = sc->sc_ac.ac_if.if_flags;
			sc->sc_ac.ac_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
d2124 1
a2124 1
			sc->sc_ac.ac_if.if_flags |= sc->sc_flags_backup;
@


1.85
log
@Decrement carp_suppress_preempt when detaching an interface that has
been experiencing output errors.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.84 2004/12/17 21:40:04 mpf Exp $	*/
a720 1
	ifp->if_output = ether_output;
d722 1
d729 1
a729 1
	if_attachhead(ifp);
d1252 1
a1252 1
carp_ourether(void *v, struct ether_header *eh, int src)
d1263 11
a1273 1
	if (ena[0] || ena[1] || ena[2] != 0x5e || ena[3] || ena[4] != 1)
d1275 2
d1289 1
a1289 1
carp_input(struct ether_header *eh, struct mbuf *m)
d1291 1
d1295 5
a1299 1
	if (ETHER_IS_MULTICAST(eh->ether_dhost)) {
d1312 1
a1312 1
			ether_input(&vh->sc_ac.ac_if, eh, m0);
d1317 1
a1317 1
	ifp = carp_ourether(cif, eh, 0);
d1336 1
a1336 1
		m0.m_data = (char *)eh;
d1341 1
a1341 1
	ether_input(ifp, eh, m);
d1993 11
@


1.84
log
@Temporary fix to get IPv6 working again.
v6 advertisements are still received the old-fashioned way.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.83 2004/12/17 12:42:01 pascoe Exp $	*/
d763 4
@


1.83
log
@Reorder code in the ethernet output path, and enhance unicast address
matching in the bridge receive path to make CARP operate correctly
on physical interfaces that are participating in a bridge.

ok mcbride@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.82 2004/12/17 06:47:00 mcbride Exp $	*/
d502 1
a502 1
	if (m->m_pkthdr.rcvif->if_type != IFT_CARP) {
d552 6
d559 1
a559 2
	TAILQ_FOREACH(sc, &((struct carp_if *)
	    m->m_pkthdr.rcvif->if_carpdev->if_carp)->vhif_vrs, sc_list)
@


1.82
log
@Remember to decrement carp_suppress_preempt when detaching.

ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.81 2004/12/15 18:40:09 mcbride Exp $	*/
d1242 25
a1270 2
	struct carp_softc *vh;
	u_int8_t *ena = (u_int8_t *)&eh->ether_dhost;
d1274 1
d1278 1
a1278 1
		 * XXX Should reall check the list of multicast addresses
d1291 2
a1292 11
	if (ena[0] || ena[1] || ena[2] != 0x5e || ena[3] || ena[4] != 1)
		return (1);

	TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list)
		if ((vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
		    (IFF_UP|IFF_RUNNING) && vh->sc_state == MASTER &&
		    !bcmp(ena, vh->sc_ac.ac_enaddr,
		    ETHER_ADDR_LEN))
			break;

	if (vh == NULL)
d1295 1
a1295 1
	m->m_pkthdr.rcvif = ifp = &vh->sc_ac.ac_if;
@


1.81
log
@Add IFF_NOARP to carp interface, we want arp requests to be handled via
carp_iamatch() on the physical interface.

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.80 2004/12/15 14:13:06 pat Exp $	*/
d754 4
@


1.80
log
@* fix the multicast memberships removal
* less hardcoding in format strings for easier maintenance

mcbride ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.79 2004/12/10 23:13:52 mcbride Exp $	*/
d714 1
a714 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
@


1.79
log
@Add carp_set_enaddr(), call carp_set_state() after changing the vhid
to trigger a gratuitous arp and update arp tables on other hosts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.78 2004/12/10 22:35:17 mcbride Exp $	*/
d159 2
a160 1
			log(LOG_INFO, "%s: ", (sc)->sc_ac.ac_if.if_xname);\
d423 2
a424 2
		CARP_LOG(sc, ("received ttl %d != 255 on %s", ip->ip_ttl,
		    m->m_pkthdr.rcvif->if_xname));
d433 3
a435 2
		CARP_LOG(sc, ("received len %d < 36 on %s",
		    m->m_len - sizeof(struct ip), m->m_pkthdr.rcvif->if_xname));
d513 2
a514 2
		CARP_LOG(sc, ("received ttl %d != 255 on %s", ip6->ip6_hlim,
		    m->m_pkthdr.rcvif->if_xname));
d573 2
a574 1
		CARP_LOG(sc, ("invalid version %d", ch->carp_version));
d1402 1
d1405 5
a1409 4
	while (imo->imo_num_memberships > 0) {
		if (imo->imo_membership[--imo->imo_num_memberships] == NULL)
		in_delmulti(imo->imo_membership[imo->imo_num_memberships]);
		imo->imo_membership[imo->imo_num_memberships] = NULL;
d1411 1
a2079 1

d2190 2
a2191 2
	} ifreq;
	struct ifreq *ifr = &ifreq.ifreq;
@


1.78
log
@Rename carp_output() to carp_fix_lladdr().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.77 2004/12/08 17:06:12 pat Exp $	*/
d190 1
d724 1
a724 1
	bcopy(&sc->sc_ac.ac_enaddr, LLADDR(ifp->if_sadl), ifp->if_addrlen);
d1498 1
d1507 23
d1875 2
a1876 8
			sc->sc_ac.ac_enaddr[0] = 0;
			sc->sc_ac.ac_enaddr[1] = 0;
			sc->sc_ac.ac_enaddr[2] = 0x5e;
			sc->sc_ac.ac_enaddr[3] = 0;
			sc->sc_ac.ac_enaddr[4] = 1;
			sc->sc_ac.ac_enaddr[5] = sc->sc_vhid;
			bcopy(&sc->sc_ac.ac_enaddr,
			    LLADDR(ifp->if_sadl), ifp->if_addrlen);
d1981 2
a1982 6
			eh->ether_shost[0] = 0;
			eh->ether_shost[1] = 0;
			eh->ether_shost[2] = 0x5e;
			eh->ether_shost[3] = 0;
			eh->ether_shost[4] = 1;
			eh->ether_shost[5] = sc->sc_vhid;
d1991 2
a1992 6
			fh->fddi_shost[0] = 0;
			fh->fddi_shost[1] = 0;
			fh->fddi_shost[2] = 0x5e;
			fh->fddi_shost[3] = 0;
			fh->fddi_shost[4] = 1;
			fh->fddi_shost[5] = sc->sc_vhid;
d2001 2
a2002 6
			th->token_shost[0] = 3;
			th->token_shost[1] = 0;
			th->token_shost[2] = 0x40 >> (sc->sc_vhid - 1);
			th->token_shost[3] = 0x40000 >> (sc->sc_vhid - 1);
			th->token_shost[4] = 0;
			th->token_shost[5] = 0;
@


1.77
log
@* knf
* M_WAITOK -> M_NOWAIT
* FREE() only when necessary
* join_multicast6 for ip6 addresses

mcbride ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.76 2004/12/08 08:16:44 mcbride Exp $	*/
d797 1
a797 1
	/* Tag packet for carp_output */
d1926 1
a1926 1
carp_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *sa,
@


1.76
log
@Remove code duplication duplication. Use carpdetach() in carp_clone_destroy().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.75 2004/12/08 07:05:18 mcbride Exp $	*/
d1394 2
a1395 1
carp_multicast_cleanup(struct carp_softc *sc) {
d1436 2
a1437 2
			    M_IFADDR, M_WAITOK);
			if (!ncif)
d1460 2
a1461 1
			FREE(ncif, M_IFADDR);
d1466 4
a1469 2
		    (error = carp_join_multicast(sc, ifp)) != 0) {
			FREE(ncif, M_IFADDR);
@


1.75
log
@Merge in more fixes from a pre-carpdev diff from Chris Pascoe.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.74 2004/12/08 06:57:55 mcbride Exp $	*/
d734 1
a734 17
	struct carp_softc *sc = ifp->if_softc;
	struct carp_if *cif;

	timeout_del(&sc->sc_ad_tmo);
	timeout_del(&sc->sc_md_tmo);
	timeout_del(&sc->sc_md6_tmo);

	if (sc->sc_carpdev != NULL) {
		cif = (struct carp_if *)sc->sc_carpdev->if_carp;
		TAILQ_REMOVE(&cif->vhif_vrs, sc, sc_list);
		if (!--cif->vhif_nvrs) {
			ifpromisc(sc->sc_carpdev, 0);
			sc->sc_carpdev->if_carp = NULL;
			FREE(cif, M_IFADDR);
		}
	}

d737 1
a737 1
	free(sc, M_DEVBUF);
@


1.74
log
@Check if_type in carp_carpdev_state() to make sure we're not
dealing with a carp interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.73 2004/12/07 20:38:47 mcbride Exp $	*/
a107 1
	struct in_ifaddr *sc_ia;	/* primary iface address */
a109 1
	struct in6_ifaddr *sc_ia6;	/* primary iface address v6 */
d744 2
a745 2
		if (cif->vhif_nvrs) {

d1533 1
a1533 1
	/* we have to do it by hands to check we won't match on us */
d1620 1
a1620 1
	/* we have to do it by hands to check we won't match on us */
@


1.73
log
@Convert carp(4) to behave more like a regular interface, much in the same
style as vlan(4). carp interfaces no longer require the physical interface
to be on the same subnet as the carp interface, or even that the physical
interface has an adress at all, so CARP can now be used on /30 networks.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.72 2004/11/30 00:17:18 mcbride Exp $	*/
d2044 1
a2044 1
carp_carpdev_state(void *v)
d2046 1
a2046 1
	struct carp_if *cif = v;
d2048 5
@


1.72
log
@Use %s, not %d to print the interface name. From Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.71 2004/11/28 03:14:03 mcbride Exp $	*/
a31 1
 *	- track iface ip address changes;
d43 1
d95 9
d106 1
a107 1
	struct ifnet *sc_ifp;
d144 1
d160 1
a160 1
		if (sc) 						\
d174 1
a174 1
void	carp_input_c(struct mbuf *, struct carp_header *, sa_family_t);
d190 2
d193 1
a193 1
int	carp_del_addr(struct carp_softc *, struct sockaddr_in *);
d197 1
a197 1
int	carp_del_addr6(struct carp_softc *, struct sockaddr_in6 *);
d201 3
d297 1
a297 1
	s = splnet();
d299 70
a368 8
		if (ifa->ifa_addr->sa_family == AF_INET && sc->sc_ifp != NULL) {
			int count = carp_addrcount(
			    (struct carp_if *)sc->sc_ifp->if_carp,
			    ifatoia(ifa), CARP_COUNT_MASTER);

			if ((cmd == RTM_ADD && count == 1) ||
			    (cmd == RTM_DELETE && count == 0))
				rtinit(ifa, cmd, RTF_UP | RTF_HOST);
d370 1
d372 1
a372 1
		if (ifa->ifa_addr->sa_family == AF_INET6) {
d377 4
a381 1
#endif /* INET6 */
d392 1
a392 1
carp_input(struct mbuf *m, ...)
d412 1
a412 1
	if (m->m_pkthdr.rcvif->if_carp == NULL) {
d480 1
a480 1
	carp_input_c(m, ch, AF_INET);
d485 1
a485 1
carp6_input(struct mbuf **mp, int *offp, int proto)
d501 1
a501 1
	if (m->m_pkthdr.rcvif->if_carp == NULL) {
d540 1
a540 1
	carp_input_c(m, ch, AF_INET6);
d546 1
a546 1
carp_input_c(struct mbuf *m, struct carp_header *ch, sa_family_t af)
a548 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d552 2
a553 2
	/* verify that the VHID is valid on the receiving interface */
	TAILQ_FOREACH(sc, &((struct carp_if *)ifp->if_carp)->vhif_vrs, sc_list)
d556 1
a567 19
#if NBPFILTER > 0
	if (sc->sc_ac.ac_if.if_bpf) {
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a dummy header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer to it).
		 */
		struct mbuf m0;
		u_int32_t af0 = htonl(af);

		m0.m_next = m;
		m0.m_len = sizeof(af0);
		m0.m_data = (char *)&af0;
		bpf_mtap(sc->sc_ac.ac_if.if_bpf, &m0);
	}
#endif

d707 1
d712 1
a712 2
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = 0;
d714 1
a714 1
	ifp->if_output = looutput;
d717 7
a723 3
	ifp->if_snd.ifq_maxlen = ifqmaxlen;
	ifp->if_hdrlen = 0;
	if_attach(ifp);
d725 2
d728 1
a728 1
	bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
a737 4
	struct ip_moptions *imo = &sc->sc_imo;
#ifdef INET6
	struct ip6_moptions *im6o = &sc->sc_im6o;
#endif
d743 2
a744 2
	if (sc->sc_ifp != NULL) {
		cif = (struct carp_if *)sc->sc_ifp->if_carp;
a746 1
			ifpromisc(sc->sc_ifp, 0);
d748 1
a748 16
			/* Clear IPv4 multicast */
			in_delmulti(imo->imo_membership[--imo->imo_num_memberships]);
			imo->imo_multicast_ifp = NULL;

			/* Clear IPv6 multicast */
#ifdef INET6
			while (!LIST_EMPTY(&im6o->im6o_memberships)) {
				struct in6_multi_mship *imm =
				    LIST_FIRST(&im6o->im6o_memberships);

				LIST_REMOVE(imm, i6mm_chain);
				in6_leavegroup(imm);
			}
#endif

			sc->sc_ifp->if_carp = NULL;
d753 1
a753 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
d763 1
a763 1
	struct ifaddr *ifa;
d769 12
a780 12
	while ((ifa = TAILQ_FIRST(&sc->sc_ac.ac_if.if_addrlist)) != NULL)
		if (ifa->ifa_addr->sa_family == AF_INET) {
			struct in_ifaddr *ia = ifatoia(ifa);

			carp_del_addr(sc, &ia->ia_addr);

			/* ripped screaming from in_control(SIOCDIFADDR) */
			in_ifscrub(&sc->sc_ac.ac_if, ia);
			TAILQ_REMOVE(&sc->sc_ac.ac_if.if_addrlist,
			    ifa, ifa_list);
			TAILQ_REMOVE(&in_ifaddr, ia, ia_list);
			IFAFREE((&ia->ia_ifa));
d782 2
d837 1
a837 1
		if (ifp->if_carp == NULL)
d859 2
d864 5
d895 1
a895 1
	if (sc->sc_ia) {
d921 9
a929 1
		ip->ip_src.s_addr = sc->sc_ia->ia_addr.sin_addr.s_addr;
d975 1
a975 1
	if (sc->sc_ia6) {
d996 10
a1005 2
		bcopy(&sc->sc_ia6->ia_addr.sin6_addr, &ip6->ip6_src,
		    sizeof(struct in6_addr));
d1071 1
a1071 1
	
d1078 1
a1078 1
		arprequest(sc->sc_ifp, &in, &in, sc->sc_ac.ac_enaddr);
d1099 1
a1099 1
		nd6_na_output(sc->sc_ifp, &mcast, in6,
d1252 2
a1253 2
struct ifnet *
carp_forus(void *v, void *dhost)
d1255 1
a1255 1
	struct carp_if *cif = v;
d1257 19
a1275 1
	u_int8_t *ena = dhost;
d1278 1
a1278 1
		return (NULL);
d1283 28
a1310 2
		    !bcmp(dhost, vh->sc_ac.ac_enaddr, ETHER_ADDR_LEN))
			return (&vh->sc_ac.ac_if);
d1312 1
a1312 1
	return (NULL);
d1349 6
d1356 1
a1356 1
	    sc->sc_vhid > 0 && (sc->sc_naddrs || sc->sc_naddrs6))
d1358 1
a1358 1
	else {
d1411 108
d1522 1
a1522 2
	struct ifnet *ifp;
	struct carp_if *cif;
d1524 1
a1524 3
	struct ip_moptions *imo = &sc->sc_imo;
	struct in_addr addr;
	int own, error;
d1537 2
a1538 1
	for (ia = TAILQ_FIRST(&in_ifaddr); ia; ia = TAILQ_NEXT(ia, ia_list)) {
d1552 7
a1558 29
	if (!ia_if)
		return (EADDRNOTAVAIL);
	ia = ia_if;
	ifp = ia->ia_ifp;

	if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0 ||
	    (imo->imo_multicast_ifp && imo->imo_multicast_ifp != ifp))
		return (EADDRNOTAVAIL);

	if (imo->imo_num_memberships == 0) {
		addr.s_addr = INADDR_CARP_GROUP;
		if ((imo->imo_membership[0] = in_addmulti(&addr, ifp)) == NULL)
			return (ENOBUFS);
		imo->imo_num_memberships++;
		imo->imo_multicast_ifp = ifp;
		imo->imo_multicast_ttl = CARP_DFLTTL;
		imo->imo_multicast_loop = 0;
	}

	if (!ifp->if_carp) {

		MALLOC(cif, struct carp_if *, sizeof(*cif), M_IFADDR, M_WAITOK);
		if (!cif) {
			error = ENOBUFS;
			goto cleanup;
		}
		if ((error = ifpromisc(ifp, 1))) {
			FREE(cif, M_IFADDR);
			goto cleanup;
a1559 15

		bzero(cif, sizeof(*cif));
		cif->vhif_ifp = ifp;
		TAILQ_INIT(&cif->vhif_vrs);
		ifp->if_carp = (caddr_t)cif;

	} else {
		struct carp_softc *vr;

		cif = (struct carp_if *)ifp->if_carp;
		TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list)
			if (vr != sc && vr->sc_vhid == sc->sc_vhid) {
				error = EINVAL;
				goto cleanup;
			}
a1560 2
	sc->sc_ia = ia;
	sc->sc_ifp = ifp;
d1562 2
a1563 4
	{ /* XXX prevent endless loop if already in queue */
	struct carp_softc *vr, *after = NULL;
	int myself = 0;
	cif = (struct carp_if *)ifp->if_carp;
d1565 2
a1566 6
	TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list) {
		if (vr == sc)
			myself = 1;
		if (vr->sc_vhid < sc->sc_vhid)
			after = vr;
	}
d1568 2
a1569 10
	if (!myself) {
		/* We're trying to keep things in order */
		if (after == NULL) {
			TAILQ_INSERT_TAIL(&cif->vhif_vrs, sc, sc_list);
		} else {
			TAILQ_INSERT_AFTER(&cif->vhif_vrs, after, sc, sc_list);
		}
		cif->vhif_nvrs++;
	}
	}
d1572 3
a1574 1
	sc->sc_ac.ac_if.if_flags |= IFF_UP;
a1580 4

cleanup:
	in_delmulti(imo->imo_membership[--imo->imo_num_memberships]);
	return (error);
d1584 1
a1584 1
carp_del_addr(struct carp_softc *sc, struct sockaddr_in *sin)
d1586 2
a1587 5
	int error = 0;

	if (!--sc->sc_naddrs) {
		struct carp_if *cif = (struct carp_if *)sc->sc_ifp->if_carp;
		struct ip_moptions *imo = &sc->sc_imo;
d1589 5
a1593 10
		timeout_del(&sc->sc_ad_tmo);
		sc->sc_ac.ac_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
		sc->sc_vhid = -1;
		in_delmulti(imo->imo_membership[--imo->imo_num_memberships]);
		imo->imo_multicast_ifp = NULL;
		TAILQ_REMOVE(&cif->vhif_vrs, sc, sc_list);
		if (!--cif->vhif_nvrs) {
			sc->sc_ifp->if_carp = NULL;
			FREE(cif, M_IFADDR);
		}
d1596 6
a1601 1
	return (error);
d1604 1
d1609 1
a1609 2
	struct ifnet *ifp;
	struct carp_if *cif;
d1611 1
a1611 4
	struct ip6_moptions *im6o = &sc->sc_im6o;
	struct in6_multi_mship *imm;
	struct sockaddr_in6 addr;
	int own, error;
d1646 7
a1652 45
	if (!ia_if)
		return (EADDRNOTAVAIL);
	ia = ia_if;
	ifp = ia->ia_ifp;

	if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0 ||
	    (im6o->im6o_multicast_ifp && im6o->im6o_multicast_ifp != ifp))
		return (EADDRNOTAVAIL);

	if (!sc->sc_naddrs6) {
		im6o->im6o_multicast_ifp = ifp;

		/* join CARP multicast address */
		bzero(&addr, sizeof(addr));
		addr.sin6_family = AF_INET6;
		addr.sin6_len = sizeof(addr);
		addr.sin6_addr.s6_addr16[0] = htons(0xff02);
		addr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		addr.sin6_addr.s6_addr8[15] = 0x12;
		if ((imm = in6_joingroup(ifp, &addr.sin6_addr, &error)) == NULL)
			goto cleanup;
		LIST_INSERT_HEAD(&im6o->im6o_memberships, imm, i6mm_chain);

		/* join solicited multicast address */
		bzero(&addr.sin6_addr, sizeof(addr.sin6_addr));
		addr.sin6_addr.s6_addr16[0] = htons(0xff02);
		addr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		addr.sin6_addr.s6_addr32[1] = 0;
		addr.sin6_addr.s6_addr32[2] = htonl(1);
		addr.sin6_addr.s6_addr32[3] = sin6->sin6_addr.s6_addr32[3];
		addr.sin6_addr.s6_addr8[12] = 0xff;
		if ((imm = in6_joingroup(ifp, &addr.sin6_addr, &error)) == NULL)
			goto cleanup;
		LIST_INSERT_HEAD(&im6o->im6o_memberships, imm, i6mm_chain);
	}

	if (!ifp->if_carp) {
		MALLOC(cif, struct carp_if *, sizeof(*cif), M_IFADDR, M_WAITOK);
		if (!cif) {
			error = ENOBUFS;
			goto cleanup;
		}
		if ((error = ifpromisc(ifp, 1))) {
			FREE(cif, M_IFADDR);
			goto cleanup;
a1653 15

		bzero(cif, sizeof(*cif));
		cif->vhif_ifp = ifp;
		TAILQ_INIT(&cif->vhif_vrs);
		ifp->if_carp = (caddr_t)cif;

	} else {
		struct carp_softc *vr;

		cif = (struct carp_if *)ifp->if_carp;
		TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list)
			if (vr != sc && vr->sc_vhid == sc->sc_vhid) {
				error = EINVAL;
				goto cleanup;
			}
a1654 2
	sc->sc_ia6 = ia;
	sc->sc_ifp = ifp;
d1656 2
a1657 4
	{ /* XXX prevent endless loop if already in queue */
	struct carp_softc *vr, *after = NULL;
	int myself = 0;
	cif = (struct carp_if *)ifp->if_carp;
d1659 2
a1660 6
	TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list) {
		if (vr == sc)
			myself = 1;
		if (vr->sc_vhid < sc->sc_vhid)
			after = vr;
	}
d1662 2
a1663 10
	if (!myself) {
		/* We're trying to keep things in order */
		if (after == NULL) {
			TAILQ_INSERT_TAIL(&cif->vhif_vrs, sc, sc_list);
		} else {
			TAILQ_INSERT_AFTER(&cif->vhif_vrs, after, sc, sc_list);
		}
		cif->vhif_nvrs++;
	}
	}
d1666 2
a1667 3
	sc->sc_ac.ac_if.if_flags |= IFF_UP;
	if (own)
		sc->sc_advskew = 0;
a1671 11

cleanup:
	/* clean up multicast memberships */
	if (!sc->sc_naddrs6) {
		while (!LIST_EMPTY(&im6o->im6o_memberships)) {
			imm = LIST_FIRST(&im6o->im6o_memberships);
			LIST_REMOVE(imm, i6mm_chain);
			in6_leavegroup(imm);
		}
	}
	return (error);
d1675 1
a1675 1
carp_del_addr6(struct carp_softc *sc, struct sockaddr_in6 *sin6)
d1677 4
a1680 1
	int error = 0;
d1682 6
a1687 3
	if (!--sc->sc_naddrs6) {
		struct carp_if *cif = (struct carp_if *)sc->sc_ifp->if_carp;
		struct ip6_moptions *im6o = &sc->sc_im6o;
d1689 33
a1721 6
		timeout_del(&sc->sc_ad_tmo);
		sc->sc_ac.ac_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
		sc->sc_vhid = -1;
		while (!LIST_EMPTY(&im6o->im6o_memberships)) {
			struct in6_multi_mship *imm =
			    LIST_FIRST(&im6o->im6o_memberships);
d1723 1
a1723 12
			LIST_REMOVE(imm, i6mm_chain);
			in6_leavegroup(imm);
		}
		im6o->im6o_multicast_ifp = NULL;
		TAILQ_REMOVE(&cif->vhif_vrs, sc, sc_list);
		if (!--cif->vhif_nvrs) {
			sc->sc_ifp->if_carp = NULL;
			FREE(cif, M_IFADDR);
		}
	}

	return (error);
d1737 1
d1794 1
a1794 1
			error = carp_del_addr(sc, satosin(&ifra->ifra_addr));
d1799 1
a1799 1
			error = carp_del_addr6(sc, satosin6(&ifra->ifra_addr));
d1830 5
d1855 1
a1855 1
			if (sc->sc_ifp) {
d1857 1
a1857 1
				cif = (struct carp_if *)sc->sc_ifp->if_carp;
d1870 2
d1898 3
d1911 8
d1970 1
a1970 1
	switch (ifp->if_type) {
d2015 1
a2015 1
		    ifp->if_xname);
d2050 2
a2051 2
		if (sc->sc_ifp->if_link_state == LINK_STATE_DOWN ||
		    !(sc->sc_ifp->if_flags & IFF_UP)) {
d2073 126
@


1.71
log
@Reverse bogus sc == NULL check in CARP_LOG(), from Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.70 2004/11/17 06:07:39 mcbride Exp $	*/
d375 1
a375 1
		CARP_LOG(sc, ("packet too short %d on %d", m->m_pkthdr.len,
@


1.70
log
@Improved logging for advertisement failures: Add some carpstats.carps_onomem++
when sending advertisements fail due to ENOBUGS, and some CARP_LOG for other
failures.

From camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.69 2004/11/16 18:13:02 mcbride Exp $	*/
d150 1
a150 1
		if (sc == NULL) 					\
@


1.69
log
@Call arprequest/ether_output at splsoftnet(). From Chris Pascoe.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.68 2004/10/28 20:34:20 henning Exp $	*/
d342 1
a342 1
		CARP_LOG(sc, ("received ttl %d != 255i on %s", ip->ip_ttl,
d772 1
d810 1
a810 1
	int len, advbase, advskew, s;
d883 7
a889 1
		if (ip_output(m, NULL, NULL, IP_RAWOUTPUT, &sc->sc_imo, NULL)) {
d955 6
a960 1
		if (ip6_output(m, NULL, NULL, 0, &sc->sc_im6o, NULL)) {
@


1.68
log
@define IFT_CARP, and set if_type to that on carp interfaces instead
of hiding under IFT_PROPVIRTUAL, ryan daniel ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.67 2004/10/06 03:56:08 mcbride Exp $	*/
d987 2
a988 1

d998 1
d1008 1
d1020 1
@


1.67
log
@Unbreak tcpdump on the carp interface; variable shadowing pointed out by
Patrick Latifi (diff based on his).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.66 2004/10/05 18:08:41 mcbride Exp $	*/
d654 1
a654 1
	ifp->if_type = IFT_PROPVIRTUAL;
@


1.66
log
@Call ip_output at splsoftnet() when sending advertisements; also don't stop
sending advertisements if we can't tag the mbuf.

Problem report and fix from Chris Pascoe, thanks.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.65 2004/09/18 16:15:53 mcbride Exp $	*/
d497 1
a497 1
		u_int32_t af = htonl(af);
d500 2
a501 2
		m0.m_len = sizeof(af);
		m0.m_data = (char *)&af;
@


1.65
log
@Oops, copy a pointer to ac_if, not the first bytes of the struct itself.
Actually this doesn't matter right now, as the first bytes of struct ifnet
are a pointer to the softc, which has ac_if at the beginning and thus by
fluke the pointer is correct.

This also makes the sc to ifp conversion for carp_macmatch6().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.64 2004/09/18 06:51:49 mcbride Exp $	*/
d809 3
a811 1
	int len, advbase, advskew;
d847 1
a847 3
			if (advbase != 255 || advskew != 255)
				timeout_add(&sc->sc_ad_tmo, tvtohz(&tv));
			return;
d871 1
a871 1
			return;
d913 1
a913 3
			if (advbase != 255 || advskew != 255)
				timeout_add(&sc->sc_ad_tmo, tvtohz(&tv));
			return;
d937 1
a937 1
			return;
d971 2
@


1.64
log
@Store the carp interface ifp in PACKET_TAG_CARP instead of a pointer to
carp_softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.63 2004/09/16 22:32:46 mcbride Exp $	*/
d752 1
d774 1
a774 1
	bcopy(&sc->sc_ac.ac_if, (caddr_t)(mtag + 1), sizeof(struct ifnet *));
d1144 2
d1147 1
a1147 1
				    sizeof(struct carp_softc *), M_NOWAIT);
d1152 2
a1153 2
				bcopy(&sc, (caddr_t)(mtag + 1),
				    sizeof(struct carp_softc *));
@


1.63
log
@Clean up CARP_LOG macro and include the physical interface
that bogus packets arrive on.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.63 2004/09/16 22:30:47 mcbride Exp $	*/
d767 1
a767 2
	mtag = m_tag_get(PACKET_TAG_CARP,
	    sizeof(struct carp_softc *), M_NOWAIT);
d773 1
a773 1
	bcopy(&sc, (caddr_t)(mtag + 1), sizeof(struct carp_softc *));
d1800 1
d1821 2
a1822 2

	bcopy(mtag + 1, &sc, sizeof(struct carp_softc *));
@


1.62
log
@Prevent backup CARP hosts from replying to arp requests, fixes strangeness
with some layer-3 switches. From Bill Marquette.

ok henning@@ mickey@@ dhartmei@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.61 2004/06/24 19:35:25 tholo Exp $	*/
d148 9
a156 4
#define	CARP_LOG(s,a) if (carp_opts[CARPCTL_LOG])			\
	log(LOG_INFO, "carp: " s "\n", (a));
#define	CARP_LOG1(sc,s,a) if (carp_opts[CARPCTL_LOG])			\
	log(LOG_INFO, "%s: " s "\n", (sc)->sc_ac.ac_if.if_xname, (a));
d314 1
d333 2
a334 2
		CARP_LOG("packet received on non-carp interface: %s",
		    m->m_pkthdr.rcvif->if_xname);
d342 2
a343 1
		CARP_LOG("received ttl %d != 255", ip->ip_ttl);
d352 2
a353 2
		CARP_LOG("received len %d < 36",
		    m->m_len - sizeof(struct ip));
d375 2
a376 1
		CARP_LOG("packet too short %d", m->m_pkthdr.len);
d392 2
a393 1
		CARP_LOG("checksum failed", 0);
d407 1
d422 2
a423 2
		CARP_LOG("packet received on non-carp interface: %s",
		    m->m_pkthdr.rcvif->if_xname);
d431 2
a432 1
		CARP_LOG("received ttl %d != 255", ip6->ip6_hlim);
d442 2
a443 1
		CARP_LOG("packet size %u too small", len);
d452 2
a453 1
		CARP_LOG("checksum failed", 0);
d510 1
a510 1
		CARP_LOG1(sc, "invalid version %d", ch->carp_version);
d519 1
a519 1
		CARP_LOG("incorrect hash", 0);
@


1.62.2.1
log
@MFC:
Fix by mcbride@@

Call ip_output at splsoftnet() when sending advertisements; also don't stop
sending advertisements if we can't tag the mbuf.

Problem report and fix from Chris Pascoe, thanks.

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.62 2004/08/31 05:31:39 mcbride Exp $	*/
d796 1
a796 3
	int len, advbase, advskew, s;

	s = splsoftnet();
d832 3
a834 1
			goto retry_later;
d858 1
a858 1
			goto retry_later;
d900 3
a902 1
			goto retry_later;
d926 1
a926 1
			goto retry_later;
a959 2
retry_later:
	splx(s);
@


1.61
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.60 2004/06/10 17:00:06 mcbride Exp $	*/
d1084 1
a1084 1
			    &vh->sc_ac.ac_if) {
d1107 2
a1108 1
			    (IFF_UP|IFF_RUNNING)) == (IFF_UP|IFF_RUNNING)))
@


1.60
log
@zero the cif struct correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.59 2004/06/10 16:55:37 mcbride Exp $	*/
d470 1
a470 1
	sc->sc_ac.ac_if.if_lastchange = time;
d864 1
a864 1
		sc->sc_ac.ac_if.if_lastchange = time;
d932 1
a932 1
		sc->sc_ac.ac_if.if_lastchange = time;
@


1.59
log
@Plug a memory leak in carp_clone_destroy()

From Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.58 2004/05/31 21:16:57 mpf Exp $	*/
d1324 1
a1324 1
		bzero(cif, sizeof(cif));
d1495 1
a1495 1
		bzero(cif, sizeof(cif));
@


1.58
log
@initialize struct carp_if and let vhif_nvrs counter work. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.57 2004/05/30 23:03:34 pvalchev Exp $	*/
d696 1
@


1.57
log
@compile without INET6; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.56 2004/05/29 08:44:21 mcbride Exp $	*/
d1323 1
d1494 1
@


1.56
log
@Remove multicast addresses and promiscuous mode when destroying the
carp interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.55 2004/05/29 04:33:27 mcbride Exp $	*/
d658 1
d660 1
d677 1
d685 1
@


1.55
log
@carp_ioctl() happens after ifioctl(); check flags correctly so that
'ifconfig carp0 down' and 'ifconfig carp0 up' work as expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.55 2004/05/29 04:09:27 mcbride Exp $	*/
d657 2
d667 16
a682 1
		if (!--cif->vhif_nvrs) {
@


1.54
log
@let sc_counter wrap automatically, ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.53 2004/05/24 18:54:47 mcbride Exp $	*/
d1645 1
a1645 2
		if (sc->sc_ac.ac_if.if_flags & IFF_UP &&
		    (ifr->ifr_flags & IFF_UP) == 0) {
d1654 1
a1654 3
		}
		if (ifr->ifr_flags & IFF_UP &&
		    (sc->sc_ac.ac_if.if_flags & IFF_UP) == 0) {
a1655 1
			carp_set_state(sc, INIT);
@


1.53
log
@Check for sc->sc_ifp != NULL in carp_setroute(). Running dhclient on the
carp interface won't work, but it doesn't mean we should panic the box!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.52 2004/05/16 02:06:10 mcbride Exp $	*/
a722 2
	} else if (sc->sc_counter == 0xffffffffffffffffULL) {
		sc->sc_counter = 0;
@


1.52
log
@When we back off due to problems with the physical interface, advertise
the backoff immediately on all of the interfaces instead of waiting for
the next scheduled advertisement.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.50 2004/05/13 08:21:18 mcbride Exp $	*/
d279 1
a279 1
		if (ifa->ifa_addr->sa_family == AF_INET) {
@


1.51
log
@Remove useless test pointed out by Frank Denis <j@@pureftpd.org>.
@
text
@d164 1
d748 21
d853 1
a853 1
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS)
d855 3
d921 1
a921 1
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS)
d923 3
d1882 1
a1882 1
			if (!sc->sc_suppress)
d1884 3
@


1.50
log
@Act like our advskew is 240 when receiving packets as well as sending if
we're backing off.  Makes the backoff actually work like it's supposed to
instead of flip-flopping.  Problem pointed out by ho@@ and jakob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.49 2004/05/13 05:49:06 mcbride Exp $	*/
d516 1
a516 2
	if (sc->sc_init_counter)
		sc->sc_init_counter = 0;
@


1.49
log
@Add cloned interface destruction to carp (ifconfig carp0 destroy).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.48 2004/05/13 00:04:20 mcbride Exp $	*/
d522 4
a525 1
	sc_tv.tv_usec = sc->sc_advskew * 1000000 / 256;
d550 1
a550 2
		if (carp_opts[CARPCTL_PREEMPT] && !carp_suppress_preempt
		    && timercmp(&sc_tv, &ch_tv, <)) {
@


1.48
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.47 2004/05/10 02:18:52 mcbride Exp $	*/
d182 1
d185 1
a185 1
    IF_CLONE_INITIALIZER("carp", carp_clone_create, NULL);
d647 27
@


1.47
log
@Make sure advskew set correctly in advertisement when configured to a value
greater than 240. From Frank Denis <j@@pureftpd.org>, PR3774.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.46 2004/05/08 02:53:03 mcbride Exp $	*/
d807 1
a807 1
			   	if (++sc->sc_sendad_success >=
d872 1
a872 1
			   	if (++sc->sc_sendad_success >=
d1816 2
a1817 2
		if (sc->sc_ifp->if_link_state == LINK_STATE_DOWN || 
		    !(sc->sc_ifp->if_flags & IFF_UP)) { 
@


1.46
log
@If a carp interface has more than CARP_SENDAD_MAX_ERRORS failed
advertisements in a row, back off all the other interfaces, until
CARP_SENDAD_MIN_SUCCESS advertisements are successful.

This makes carp deal better with ip output errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.45 2004/04/28 00:28:43 mcbride Exp $	*/
d734 1
a734 1
		if (!carp_suppress_preempt)
d736 2
a737 4
		else {
			if (sc->sc_advskew < 240)
				advskew = 240;
		}
@


1.45
log
@Make carp(4) aware of its physical interface:
- If the physical interface goes down or the link goes down,
  the carp interface goes down as well.
- We treat this like the preemption holdoff with pfsync.
  So if one of the carp interfaces is known to be bad (because the
  physical interface it's associated with is bad), all the other carp
  interfaces back off: they won't preempt, and their advskew goes to 240.

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.44 2004/03/26 17:47:20 markus Exp $	*/
d111 6
d800 1
a800 1
		if (ip_output(m, NULL, NULL, IP_RAWOUTPUT, &sc->sc_imo, NULL))
d802 15
d865 1
a865 1
		if (ip6_output(m, NULL, NULL, 0, &sc->sc_im6o, NULL))
d867 15
@


1.44
log
@don't use mbuf after free; ok mcbride, deraadt, cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.43 2004/03/26 08:31:58 mcbride Exp $	*/
a87 5
#include "pfsync.h"
#if NPFSYNC > 0
extern int pfsync_sync_ok;
#endif

d109 2
d131 1
d540 1
a540 4
		if (carp_opts[CARPCTL_PREEMPT]
#if NPFSYNC > 0
		    && pfsync_sync_ok
#endif /* NPFSYNC > 0 */
d608 2
d728 1
a728 1
		if (pfsync_sync_ok)
d1102 1
a1102 5
		if (carp_opts[CARPCTL_PREEMPT]
#if NPFSYNC > 0
		    && pfsync_sync_ok
#endif /* NPFSYNC > 0 */
		    ) {
d1496 1
a1496 1
			sc->if_flags |= IFF_UP;
d1504 1
a1504 1
			sc->if_flags |= IFF_UP;
d1518 1
a1518 1
			sc->if_flags |= IFF_UP;
d1526 1
a1526 1
			sc->if_flags |= IFF_UP;
d1537 1
a1537 1
		sc->if_flags &= ~IFF_UP;
d1556 3
a1558 2
		if (sc->if_flags & IFF_UP && (ifr->ifr_flags & IFF_UP) == 0) {
			sc->if_flags &= ~IFF_UP;
d1567 3
a1569 2
		if (ifr->ifr_flags & IFF_UP && (sc->if_flags & IFF_UP) == 0) {
			sc->if_flags |= IFF_UP;
d1773 30
@


1.44.2.1
log
@MFC:
Fix by mcbride@@

Make sure advskew set correctly in advertisement when configured to a value
greater than 240. From Frank Denis <j@@pureftpd.org>, PR3774.

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.44 2004/03/26 17:47:20 markus Exp $	*/
d731 1
a731 1
		if (pfsync_sync_ok || sc->sc_advskew > 240)
d733 4
a736 2
		else
			advskew = 240;
@


1.44.2.2
log
@MFC:
Fix by mcbride@@

Call ip_output at splsoftnet() when sending advertisements; also don't stop
sending advertisements if we can't tag the mbuf.

Problem report and fix from Chris Pascoe, thanks.

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.44.2.1 2004/05/27 18:23:31 brad Exp $	*/
d722 1
a722 3
	int len, advbase, advskew, s;

	s = splsoftnet();
d758 3
a760 1
			goto retry_later;
d784 1
a784 1
			goto retry_later;
d808 3
a810 1
			goto retry_later;
d834 1
a834 1
			goto retry_later;
a849 2
retry_later:
	splx(s);
@


1.43
log
@Also raise advskew to 240 while we wait for pfsync to get it's bulk update.
This is to deal with situations where the network is not working during boot
so we become master by default - the high advskew value allows other carp
boxes to preempt us when the network finally comes up.

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.42 2004/03/24 06:54:04 mcbride Exp $	*/
d394 1
d421 1
d425 1
a425 2
		CARP_LOG("packet size %d too small", m->m_len);
		m_freem(m);
@


1.42
log
@Correct size in error message. From mickey@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.41 2004/03/24 06:13:56 mcbride Exp $	*/
d730 6
a735 1
		advskew = sc->sc_advskew;
@


1.41
log
@Disable net.inet.carp.log by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.40 2004/03/22 04:54:18 mcbride Exp $	*/
d339 1
a339 1
		CARP_LOG("received len %d < 8",
@


1.40
log
@Support for best effort bulk transfers of states when pfsync syncif is
configured.  This this allows pfsync+carp clusters to come up gracefully
without killing active connections. pfsync now prevents carp from
preempting to become master until the state table has sync'd.

ABI change, any application which use struct pf_state must be recompiled.

Reminded about this by Christian Gut. Thanks to beck@@ cedric@@ and dhartmei@@
for testing and comments.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.39 2004/03/20 11:01:35 mcbride Exp $	*/
d134 1
a134 1
int carp_opts[CARPCTL_MAXID] = { 0, 1, 0, 1, 0 };	/* XXX for now */
@


1.39
log
@Unbreak routing change handling for state changes; count addresses differently
depending on where we're calling carp_addrcount() from.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.38 2004/03/18 20:46:16 mcbride Exp $	*/
d88 5
d541 5
a545 1
		if (carp_opts[CARPCTL_PREEMPT] && timercmp(&sc_tv, &ch_tv, <)) {
d1099 5
a1103 1
		if (carp_opts[CARPCTL_PREEMPT]) {
@


1.38
log
@Allow the state to be changed explicitly via the ioctl.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.37 2004/03/10 21:36:47 mcbride Exp $	*/
d162 3
a164 1
int	carp_addrcount(struct carp_if *, struct in_ifaddr *);
d271 1
a271 1
			    ifatoia(ifa));
d885 1
a885 1
carp_addrcount(struct carp_if *cif, struct in_ifaddr *ia)
d892 4
a895 2
		if ((vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
		    (IFF_UP|IFF_RUNNING)) {
d925 1
a925 1
		count = carp_addrcount(cif, ia);
@


1.37
log
@Don't permit a negative index. Pointed out by Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.36 2004/03/05 12:25:56 mcbride Exp $	*/
a1072 1
	struct ifaddr *ifa;
d1097 1
a1097 18
#ifdef INET
			TAILQ_FOREACH(ifa, &sc->sc_ac.ac_if.if_addrlist,
			    ifa_list) {
				if (ifa->ifa_addr->sa_family == AF_INET) {
					carp_setrun(sc, AF_INET);
					break;
				}
			}
#endif /* INET */
#ifdef INET6
			TAILQ_FOREACH(ifa, &sc->sc_ac.ac_if.if_addrlist,
			    ifa_list) {
				if (ifa->ifa_addr->sa_family == AF_INET6) {
					carp_setrun(sc, AF_INET6);
					break;
				}
			}
#endif /* INET6 */
d1116 1
a1116 1
			if (timeout_pending(&sc->sc_md_tmo))
d1118 1
a1118 1
			if (timeout_pending(&sc->sc_md6_tmo))
d1563 15
@


1.36
log
@Only send route add or delete messages if it's the first identical
address being added or the last identical address being removed,
respectively.

Part of a larger diff approved by markus@@ and dhartmei@@, API changes held
back for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.35 2004/01/18 12:22:39 markus Exp $	*/
d570 1
a570 1
	if (name[0] == 0 || name[0] >= CARPCTL_MAXID)
@


1.35
log
@send RTM_IFINFO on carp state changes; with mpf@@; ok mcbride@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.34 2004/01/15 15:47:05 dhartmei Exp $	*/
d162 1
d266 9
a274 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			rtinit(ifa, cmd, RTF_UP | RTF_HOST);
d616 1
a616 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name, 
d651 2
a652 1
			TAILQ_REMOVE(&sc->sc_ac.ac_if.if_addrlist, ifa, ifa_list);
d883 22
d921 1
a921 8
		TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
			TAILQ_FOREACH(ifa, &vh->sc_ac.ac_if.if_addrlist,
			    ifa_list) {
				if (ia->ia_addr.sin_addr.s_addr ==
				    ifatoia(ifa)->ia_addr.sin_addr.s_addr)
					count++;
			}
		}
d926 1
d929 1
d932 17
a948 10
			TAILQ_FOREACH(ifa, &vh->sc_ac.ac_if.if_addrlist,
			    ifa_list) {
				if (ia->ia_addr.sin_addr.s_addr ==
				    ifatoia(ifa)->ia_addr.sin_addr.s_addr) {
					if (index == 0 &&
					    ((vh->sc_ac.ac_if.if_flags &
					    (IFF_UP|IFF_RUNNING)) ==
					    (IFF_UP|IFF_RUNNING))) {
						*enaddr = vh->sc_ac.ac_enaddr;
						return (1);
a949 1
					index--;
a952 1
		return (0);
d1740 1
a1740 1
carp_set_state(struct carp_softc *sc, int state) 
d1746 1
a1746 1
	switch(state) {
@


1.35.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.35.2.2
log
@Merge with the trunk
@
text
@a108 8
	int sc_flags_backup;
	int sc_suppress;

	int sc_sendad_errors;
#define CARP_SENDAD_MAX_ERRORS	3
	int sc_sendad_success;
#define CARP_SENDAD_MIN_SUCCESS 3

d129 1
a129 2
int carp_suppress_preempt = 0;
int carp_opts[CARPCTL_MAXID] = { 0, 1, 0, 0, 0 };	/* XXX for now */
a154 1
void	carp_send_ad_all(void);
a161 3
int	carp_addrcount(struct carp_if *, struct in_ifaddr *, int);
enum	{ CARP_COUNT_MASTER, CARP_COUNT_RUNNING };

a169 1
int     carp_clone_destroy(struct ifnet *);
d172 1
a172 1
    IF_CLONE_INITIALIZER("carp", carp_clone_create, carp_clone_destroy);
d265 2
a266 9
		if (ifa->ifa_addr->sa_family == AF_INET && sc->sc_ifp != NULL) {
			int count = carp_addrcount(
			    (struct carp_if *)sc->sc_ifp->if_carp,
			    ifatoia(ifa), CARP_COUNT_MASTER);

			if ((cmd == RTM_ADD && count == 1) ||
			    (cmd == RTM_DELETE && count == 0))
				rtinit(ifa, cmd, RTF_UP | RTF_HOST);
		}
d324 1
a324 1
		CARP_LOG("received len %d < 36",
a378 1
	u_int len;
a404 1
	len = m->m_len;
d408 2
a409 1
		CARP_LOG("packet size %u too small", len);
d495 2
a496 1
	sc->sc_init_counter = 0;
d501 1
a501 4
	if (carp_suppress_preempt && sc->sc_advskew <  240)
		sc_tv.tv_usec = 240 * 1000000 / 256;
	else
		sc_tv.tv_usec = sc->sc_advskew * 1000000 / 256;
d562 1
a562 1
	if (name[0] <= 0 || name[0] >= CARPCTL_MAXID)
a592 2
	sc->sc_flags_backup = 0;
	sc->sc_suppress = 0;
d608 1
a608 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "%s%d", ifc->ifc_name,
a625 48
int
carp_clone_destroy(struct ifnet *ifp)
{
	struct carp_softc *sc = ifp->if_softc;
	struct carp_if *cif;
	struct ip_moptions *imo = &sc->sc_imo;
#ifdef INET6
	struct ip6_moptions *im6o = &sc->sc_im6o;
#endif

	timeout_del(&sc->sc_ad_tmo);
	timeout_del(&sc->sc_md_tmo);
	timeout_del(&sc->sc_md6_tmo);

	if (sc->sc_ifp != NULL) {
		cif = (struct carp_if *)sc->sc_ifp->if_carp;
		TAILQ_REMOVE(&cif->vhif_vrs, sc, sc_list);
		if (cif->vhif_nvrs) {
			ifpromisc(sc->sc_ifp, 0);

			/* Clear IPv4 multicast */
			in_delmulti(imo->imo_membership[--imo->imo_num_memberships]);
			imo->imo_multicast_ifp = NULL;

			/* Clear IPv6 multicast */
#ifdef INET6
			while (!LIST_EMPTY(&im6o->im6o_memberships)) {
				struct in6_multi_mship *imm =
				    LIST_FIRST(&im6o->im6o_memberships);

				LIST_REMOVE(imm, i6mm_chain);
				in6_leavegroup(imm);
			}
#endif

			sc->sc_ifp->if_carp = NULL;
			FREE(cif, M_IFADDR);
		}
	}

#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
	if_detach(ifp);

	return (0);
}

d643 1
a643 2
			TAILQ_REMOVE(&sc->sc_ac.ac_if.if_addrlist,
			    ifa, ifa_list);
d669 2
a693 21
carp_send_ad_all(void)
{
	struct ifnet *ifp;
	struct carp_if *cif;
	struct carp_softc *vh;

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_carp == NULL)
			continue;

		cif = (struct carp_if *)ifp->if_carp;
		TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
			if ((vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) &&
			     vh->sc_state == MASTER)
				carp_send_ad(vh);
		}
	}
}


void
d710 1
a710 4
		if (!carp_suppress_preempt || sc->sc_advskew > 240)
			advskew = sc->sc_advskew;
		else
			advskew = 240;
d771 1
a771 1
		if (ip_output(m, NULL, NULL, IP_RAWOUTPUT, &sc->sc_imo, NULL)) {
a772 18
			if (sc->sc_sendad_errors < INT_MAX)
				sc->sc_sendad_errors++;
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS) {
				carp_suppress_preempt++;
				if (carp_suppress_preempt == 1)
					carp_send_ad_all();
			}
			sc->sc_sendad_success = 0;
		} else {
			if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS) {
				if (++sc->sc_sendad_success >=
				    CARP_SENDAD_MIN_SUCCESS) {
					carp_suppress_preempt--;
					sc->sc_sendad_errors = 0;
				}
			} else
				sc->sc_sendad_errors = 0;
		}
d821 1
a821 1
		if (ip6_output(m, NULL, NULL, 0, &sc->sc_im6o, NULL)) {
a822 18
			if (sc->sc_sendad_errors < INT_MAX)
				sc->sc_sendad_errors++;
			if (sc->sc_sendad_errors == CARP_SENDAD_MAX_ERRORS) {
				carp_suppress_preempt++;
				if (carp_suppress_preempt == 1)
					carp_send_ad_all();
			}
			sc->sc_sendad_success = 0;
		} else {
			if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS) {
				if (++sc->sc_sendad_success >=
				    CARP_SENDAD_MIN_SUCCESS) {
					carp_suppress_preempt--;
					sc->sc_sendad_errors = 0;
				}
			} else
				sc->sc_sendad_errors = 0;
		}
a873 24
carp_addrcount(struct carp_if *cif, struct in_ifaddr *ia, int type)
{
	struct carp_softc *vh;
	struct ifaddr *ifa;
	int count = 0;

	TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
		if ((type == CARP_COUNT_RUNNING &&
		    (vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
		    (IFF_UP|IFF_RUNNING)) ||
		    (type == CARP_COUNT_MASTER && vh->sc_state == MASTER)) {
			TAILQ_FOREACH(ifa, &vh->sc_ac.ac_if.if_addrlist,
			    ifa_list) {
				if (ifa->ifa_addr->sa_family == AF_INET &&
				    ia->ia_addr.sin_addr.s_addr ==
				    ifatoia(ifa)->ia_addr.sin_addr.s_addr)
					count++;
			}
		}
	}
	return (count);
}

int
d890 8
a897 1
		count = carp_addrcount(cif, ia, CARP_COUNT_RUNNING);
a901 1

a903 1
		count = 0;
d906 10
a915 17
			if ((vh->sc_ac.ac_if.if_flags & (IFF_UP|IFF_RUNNING)) ==
			    (IFF_UP|IFF_RUNNING)) {
				TAILQ_FOREACH(ifa, &vh->sc_ac.ac_if.if_addrlist,
				    ifa_list) {
					if (ifa->ifa_addr->sa_family ==
					    AF_INET &&
					    ia->ia_addr.sin_addr.s_addr ==
					    ifatoia(ifa)->ia_addr.sin_addr.s_addr) {
						if (count == index) {
							if (vh->sc_state ==
							    MASTER) {
								*enaddr = vh->sc_ac.ac_enaddr;
								return (1);
							} else
								return (0);
						}
						count++;
d917 1
d921 1
d1042 1
d1056 1
a1056 1
		if (carp_opts[CARPCTL_PREEMPT] && !carp_suppress_preempt) {
d1067 18
a1084 1
			carp_setrun(sc, 0);
d1103 1
a1103 1
			if (sc->sc_naddrs)
d1105 1
a1105 1
			if (sc->sc_naddrs6)
a1183 1
		bzero(cif, sizeof(cif));
a1353 1
		bzero(cif, sizeof(cif));
d1467 1
a1467 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1475 1
a1475 1
			sc->sc_ac.ac_if.if_flags|= IFF_UP;
d1489 1
a1489 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1497 1
a1497 1
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
d1508 1
a1508 1
		sc->sc_ac.ac_if.if_flags &= ~IFF_UP;
d1527 2
a1528 2
		if (sc->sc_state != INIT && !(ifr->ifr_flags & IFF_UP)) {
			sc->sc_ac.ac_if.if_flags &= ~IFF_UP;
d1536 4
a1539 2
		} else if (sc->sc_state == INIT && (ifr->ifr_flags & IFF_UP)) {
			sc->sc_ac.ac_if.if_flags |= IFF_UP;
a1549 15
		if (sc->sc_state != INIT && carpr.carpr_state != sc->sc_state) {
			switch (carpr.carpr_state) {
			case BACKUP:
				timeout_del(&sc->sc_ad_tmo);
				carp_set_state(sc, BACKUP);
				carp_setrun(sc, 0);
				carp_setroute(sc, RTM_DELETE);
				break;
			case MASTER:
				carp_master_down(sc);
				break;
			default:
				break;
			}
		}
d1709 1
a1709 1
carp_set_state(struct carp_softc *sc, int state)
d1715 1
a1715 1
	switch (state) {
a1726 33
}

void
carp_carpdev_state(void *v)
{
	struct carp_if *cif = v;
	struct carp_softc *sc;

	TAILQ_FOREACH(sc, &cif->vhif_vrs, sc_list) {
		if (sc->sc_ifp->if_link_state == LINK_STATE_DOWN ||
		    !(sc->sc_ifp->if_flags & IFF_UP)) {
			sc->sc_flags_backup = sc->sc_ac.ac_if.if_flags;
			sc->sc_ac.ac_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
			timeout_del(&sc->sc_ad_tmo);
			timeout_del(&sc->sc_md_tmo);
			timeout_del(&sc->sc_md6_tmo);
			carp_set_state(sc, INIT);
			carp_setrun(sc, 0);
			if (!sc->sc_suppress) {
				carp_suppress_preempt++;
				if (carp_suppress_preempt == 1)
					carp_send_ad_all();
			}
			sc->sc_suppress = 1;
		} else {
			sc->sc_ac.ac_if.if_flags |= sc->sc_flags_backup;
			carp_set_state(sc, INIT);
			carp_setrun(sc, 0);
			if (sc->sc_suppress)
				carp_suppress_preempt--;
			sc->sc_suppress = 0;
		}
	}
@


1.35.2.3
log
@sync to HEAD
@
text
@a695 1
	free(sc, M_DEVBUF);
d1323 1
a1323 1
		bzero(cif, sizeof(*cif));
d1494 1
a1494 1
		bzero(cif, sizeof(*cif));
@


1.34
log
@missing #ifdef INET6, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.33 2004/01/13 07:23:43 mcbride Exp $	*/
d161 1
d516 1
a516 1
			sc->sc_state = BACKUP;
d1023 1
a1023 1
		sc->sc_state = MASTER;
d1062 1
a1062 1
			sc->sc_state = MASTER;
d1065 1
a1065 1
			sc->sc_state = BACKUP;
d1130 1
a1130 1
			sc->sc_state = INIT;
d1228 1
a1228 1
	sc->sc_state = INIT;
d1276 1
a1276 1
			sc->sc_state = INIT;
d1398 1
a1398 1
	sc->sc_state = INIT;
d1534 1
a1534 1
			sc->sc_state = INIT;
d1539 1
a1539 1
			sc->sc_state = INIT;
d1706 21
@


1.33
log
@Add and remove IPv6 routes so when we're MASTER, we can connect to the
common address.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.32 2003/12/10 07:22:43 itojun Exp $	*/
d266 1
d273 1
@


1.32
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.31 2003/12/06 14:40:33 grange Exp $	*/
d266 6
@


1.31
log
@Mark u_int64_t constants with ULL to make gcc3 happy.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.30 2003/12/03 14:57:09 markus Exp $	*/
d1447 1
a1447 1
	register int error = 0;
d1650 1
a1650 1
			register struct ether_header *eh;
d1664 1
a1664 1
			register struct fddi_header *fh;
d1678 1
a1678 1
			register struct token_header *th;
@


1.30
log
@add support for ifconfig clone; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.29 2003/11/16 17:51:50 markus Exp $	*/
d660 1
a660 1
	} else if (sc->sc_counter == 0xffffffffffffffff) {
@


1.29
log
@compile without INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.28 2003/11/14 08:17:46 mcbride Exp $	*/
d127 2
a128 2
} *carp_softc;
int carp_number;
d168 4
a558 1

d562 2
d565 9
a573 1
carpattach(int number)
a575 1
	int i;
d579 10
a588 16
	carp_softc = malloc(number * sizeof(*carp_softc), M_DEVBUF, M_NOWAIT);
	if (!carp_softc) {
		printf("cannot alloc CARP data\n");
		return;
	}
	bzero(carp_softc, number * sizeof(*carp_softc));
	carp_number = number;

	for (i = 0; i < number; i++) {

		sc = &carp_softc[i];
		sc->sc_advbase = CARP_DFLTINTV;
		sc->sc_vhid = -1;	/* required setting */
		sc->sc_advskew = 0;
		sc->sc_init_counter = 1;
		sc->sc_naddrs = sc->sc_naddrs6 = 0;
d590 1
a590 1
		sc->sc_im6o.im6o_multicast_hlim = CARP_DFLTTL;
d593 18
a610 17
		timeout_set(&sc->sc_ad_tmo, carp_send_ad, sc);
		timeout_set(&sc->sc_md_tmo, carp_master_down, sc);
		timeout_set(&sc->sc_md6_tmo, carp_master_down, sc);

		ifp = &sc->sc_ac.ac_if;
		ifp->if_softc = sc;
		snprintf(ifp->if_xname, sizeof(ifp->if_xname), "carp%d", i);
		ifp->if_mtu = ETHERMTU;
		ifp->if_flags = 0;
		ifp->if_ioctl = carp_ioctl;
		ifp->if_output = looutput;
		ifp->if_start = carp_start;
		ifp->if_type = IFT_PROPVIRTUAL;
		ifp->if_snd.ifq_maxlen = ifqmaxlen;
		ifp->if_hdrlen = 0;
		if_attach(ifp);
		if_alloc_sadl(ifp);
d612 1
a612 1
		bpfattach(&ifp->if_bpf, ifp, DLT_LOOP, sizeof(u_int32_t));
d614 1
a614 1
	}
@


1.28
log
@Don't include KAME link-local interface ID in HMAC.

from itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.27 2003/11/09 08:56:55 mcbride Exp $	*/
d182 1
d184 1
@


1.27
log
@No need to pass an unused struct carp_softc * into carp_input_c() from
carp_input() and carp6_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.26 2003/11/08 19:17:28 jmc Exp $	*/
d182 1
d206 6
a211 4
		if (ifa->ifa_addr->sa_family == AF_INET6)
			SHA1Update(&sc->sc_sha1,
			    (void *)&ifatoia6(ifa)->ia_addr.sin6_addr,
			    sizeof(struct in6_addr));
@


1.26
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.25 2003/11/07 23:38:48 mcbride Exp $	*/
d150 1
a150 2
void	carp_input_c(struct mbuf *, struct carp_softc *,
	    struct carp_header *, sa_family_t);
a268 1
	struct carp_softc *sc;
d351 1
a351 1
	carp_input_c(m, sc, ch, AF_INET);
a357 1
	struct carp_softc *sc;
d406 1
a406 1
	carp_input_c(m, sc, ch, AF_INET6);
d412 1
a412 2
carp_input_c(struct mbuf *m, struct carp_softc *sc,
	struct carp_header *ch, sa_family_t af)
d414 1
@


1.25
log
@Check to make sure that the packet was received on a carp-enabled interface.

Pointed out by Marco Pfatschbacher, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.24 2003/11/07 22:04:46 mcbride Exp $	*/
d495 1
a495 1
		 * If we recieve an advertisement from a master who's going to
@


1.24
log
@Clean up carp_iamatch() behaviour so we don't reply to arp requests when
the interface is ifconfig'd down.

Patch from Marco Pfatschbacher
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.23 2003/11/07 21:32:47 mcbride Exp $	*/
d287 9
d368 9
@


1.23
log
@Add missing #ifdef INET6.

Courtesy of markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.22 2003/11/05 06:39:48 mcbride Exp $	*/
d864 1
a864 1
			return (1);
d892 1
d897 1
a897 1
	return (1);
@


1.22
log
@Cleanups.
- Remove error variable which is not needed.
- Add missing /* INET6 */ comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.21 2003/11/04 21:30:44 mcbride Exp $	*/
d563 1
d565 1
@


1.21
log
@Add carp_setroute(), add and remove routes when the carp(4) interface
enters and leaves MASTER state. Allows the system to connect to the common
address when it is master.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.20 2003/11/04 18:10:41 mcbride Exp $	*/
d663 1
a663 1
	int len, advbase, advskew, error;
d721 1
a721 2
		error = carp_prepare_ad(m, sc, ch_ptr);
		if (error)
d733 1
a733 2
		if ((error = ip_output(m, NULL, NULL,
		    IP_RAWOUTPUT, &sc->sc_imo, NULL)))
d771 1
a771 2
		error = carp_prepare_ad(m, sc, ch_ptr);
		if (error)
d783 1
a783 1
		if ((error = ip6_output(m, NULL, NULL, 0, &sc->sc_im6o, NULL)))
d786 1
a786 1
#endif
d950 1
a950 1
#endif
d1022 1
a1022 1
#endif
@


1.20
log
@Use MGETHDR() instead of m_gethdr()

Patch from Marco Pfatschbacher (Marco_Pfatschbacher at genua dot de)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.19 2003/11/04 17:16:24 mcbride Exp $	*/
d149 1
d248 14
d485 1
d994 1
d1014 1
d1027 1
d1030 1
d1432 2
d1454 2
@


1.19
log
@- Remove bogus function prototype
- Put the correct address family in the BPF header

Pointed out by Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.18 2003/11/04 03:19:22 mickey Exp $	*/
a671 1
	/* MGETHDR(m, M_DONTWAIT, MT_HEADER); */
d675 1
a675 1
		m = m_gethdr(M_DONTWAIT, MT_HEADER);
a723 1
	/* MGETHDR(m, M_DONTWAIT, MT_HEADER); */
d727 1
a727 1
		m = m_gethdr(M_DONTWAIT, MT_HEADER);
@


1.18
log
@kill a no longer relevant todo item
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.17 2003/11/04 02:52:40 mcbride Exp $	*/
a157 1
int	carp_sluggish(struct carp_softc *, struct carp_header *);
d414 1
a414 1
		u_int32_t af = htonl(AF_INET6);
@


1.17
log
@Some cleanups from Andrey Matveev <andrushock@@korovino.net>:
        - remove duplicate string;
        - carp_set_addr() -> carp_set_addr6() when INET6;
        - spacing police.

Oh yeah, and we can take inet6 support off the todo list.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.16 2003/11/03 05:09:39 mcbride Exp $	*/
a31 1
 *	- find a way to schednetisr() packet earlier than through inetsw[];
@


1.16
log
@Cleanups:
- missing #ifdef INET6.
- fix check for interface going down in carp_send_ad().
- fix memory leak which occurs when when ifpromisc() fails.

All from Max Laier, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.15 2003/11/03 03:19:27 deraadt Exp $	*/
a34 1
 *	- support for inet6;
a769 1
		sc->sc_ac.ac_if.if_lastchange = time;
d1442 1
a1442 1
			error = carp_set_addr(sc, satosin(&ifra->ifra_addr));
d1597 1
a1597 1
	bcopy( mtag + 1, &sc, sizeof(struct carp_softc *));
@


1.15
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.14 2003/11/03 00:55:57 mcbride Exp $	*/
d737 2
a738 1
			timeout_add(&sc->sc_ad_tmo, tvtohz(&tv));
d1011 1
d1013 1
d1129 2
a1130 1
		if ((error = ifpromisc(ifp, 1)))
d1132 1
d1299 2
a1300 1
		if ((error = ifpromisc(ifp, 1)))
d1302 1
@


1.14
log
@Some KNF cleanup. There's probably more to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.13 2003/11/02 16:15:58 mcbride Exp $	*/
d867 1
a867 1
			    		    (IFF_UP|IFF_RUNNING))) {
d901 1
a901 1
 			    ((vh->sc_ac.ac_if.if_flags &
d923 1
a923 1
 			    ((sc->sc_ac.ac_if.if_flags &
@


1.13
log
@Typo; #ifdef INET not INET6.

From Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.12 2003/10/31 09:00:32 mcbride Exp $	*/
d146 2
a147 2
void	carp_hmac_prepare (struct carp_softc *);
void	carp_hmac_generate (struct carp_softc *, u_int32_t *,
d149 1
a149 1
int	carp_hmac_verify (struct carp_softc *, u_int32_t *,
d153 2
a154 2
void	carpattach (int);
void	carpdetach (struct carp_softc *);
d157 9
a165 9
void	carp_send_ad (void *);
void	carp_send_arp (struct carp_softc *);
void	carp_master_down (void *);
int	carp_sluggish (struct carp_softc *, struct carp_header *);
int	carp_ioctl (struct ifnet *, u_long, caddr_t);
void	carp_start (struct ifnet *);
void	carp_setrun (struct carp_softc *, sa_family_t);
int	carp_set_addr (struct carp_softc *, struct sockaddr_in *);
int	carp_del_addr (struct carp_softc *, struct sockaddr_in *);
d167 3
a169 3
void	carp_send_na (struct carp_softc *);
int	carp_set_addr6 (struct carp_softc *, struct sockaddr_in6 *);
int	carp_del_addr6 (struct carp_softc *, struct sockaddr_in6 *);
d175 1
a175 1
	return in_cksum(m, len);
d207 6
a212 6
        TAILQ_FOREACH(ifa, &sc->sc_ac.ac_if.if_addrlist, ifa_list) {
                if (ifa->ifa_addr->sa_family == AF_INET6)
                        SHA1Update(&sc->sc_sha1,
                            (void *)&ifatoia6(ifa)->ia_addr.sin6_addr,
                            sizeof(struct in6_addr));
        }
d514 1
a514 1
		return ENOTDIR;
d517 1
a517 1
		return ENOPROTOOPT;
a748 1
		//ip6->ip6_plen = htons(len);
d854 1
a854 1
			return 1;
d910 1
a910 1
void * 
d1052 1
a1052 1
			if (timeout_pending(&sc->sc_md6_tmo)) 
d1081 1
a1081 1
		return 0;
d1101 1
a1101 1
		return EADDRNOTAVAIL;
d1107 1
a1107 1
		return EADDRNOTAVAIL;
d1112 1
a1112 1
			return ENOBUFS;
d1176 1
a1176 1
	return 0;
a1180 1
	
d1204 1
a1204 1
	return error;
d1225 1
a1225 1
		return 0;
d1238 1
a1238 1
				break;	
d1253 1
a1253 1
		return EADDRNOTAVAIL;
d1259 1
a1259 1
		return EADDRNOTAVAIL;
d1274 1
a1274 1
	
d1344 1
a1344 2

	return 0;
d1385 1
a1385 1
	return error;
d1500 1
a1500 1
						return EINVAL;
d1641 1
a1641 1
		return EOPNOTSUPP;
d1644 1
a1644 1
	return 0;
@


1.12
log
@Add IPv6 support to CARP.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.11 2003/10/27 20:57:59 mcbride Exp $	*/
d198 1
a198 1
#ifdef INET6
@


1.11
log
@Skew the advertisement interval correctly when we reschedule.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.10 2003/10/27 06:23:57 mcbride Exp $	*/
d82 8
d103 4
d114 1
d127 1
d151 2
d155 2
d163 1
a163 1
void	carp_setrun (struct carp_softc *);
d166 5
d198 1
d203 1
a203 1
			    sizeof(u_int32_t));
d205 9
a257 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
a262 2
	u_int64_t tmp_counter;
	struct timeval sc_tv, ch_tv;
d332 60
d417 1
a417 1
		u_int32_t af = htonl(AF_INET);
a434 13
	if (len < m->m_len) {
		if ((m = m_pullup(m, len)) == NULL) {
			carpstats.carps_hdrops++;
			sc->sc_ac.ac_if.if_ierrors++;
			/* CARP_LOG ? */
			m_freem(m);
			return;
		}
		ip = mtod(m, struct ip *);
		ch = mtod(m, struct carp_header *) + iplen;
	}
	len -= iplen;

d469 1
a469 2
		    (timercmp(&sc_tv, &ch_tv, ==) &&
		    ip->ip_src.s_addr > sc->sc_ia->ia_addr.sin_addr.s_addr)) {
d472 1
a472 1
			carp_setrun(sc);
d500 1
a500 1
		carp_setrun(sc);
d549 3
d554 1
d582 1
d608 34
d645 1
d648 1
a648 1
	struct carp_header *ch;
a649 2
	struct m_tag *mtag;
	struct ip *ip;
d664 9
a672 1
	carpstats.carps_opackets++;
d674 1
d676 2
a677 37
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m == NULL) {
		sc->sc_ac.ac_if.if_oerrors++;
		carpstats.carps_onomem++;
		/* XXX maybe less ? */
		if (advbase != 255 || advskew != 255)
			timeout_add(&sc->sc_ad_tmo, tvtohz(&tv));
		return;
	}
	len = sizeof(*ip) + sizeof(*ch);
	m->m_pkthdr.len = len;
	m->m_pkthdr.rcvif = NULL;
	m->m_len = len;
	MH_ALIGN(m, m->m_len);
	m->m_flags |= M_MCAST;
	ip = mtod(m, struct ip *);
	ip->ip_v = IPVERSION;
	ip->ip_hl = sizeof(*ip) >> 2;
	ip->ip_tos = IPTOS_LOWDELAY;
	ip->ip_len = htons(len);
	ip->ip_id = htons(ip_randomid());
	ip->ip_off = htons(IP_DF);
	ip->ip_ttl = CARP_DFLTTL;
	ip->ip_p = IPPROTO_CARP;
	ip->ip_sum = 0;
	ip->ip_src.s_addr = sc->sc_ia->ia_addr.sin_addr.s_addr;
	ip->ip_dst.s_addr = INADDR_CARP_GROUP;

	ch = (void *)ip + sizeof(*ip);
	ch->carp_version = CARP_VERSION;
	ch->carp_type = CARP_ADVERTISEMENT;
	ch->carp_vhid = sc->sc_vhid;
	ch->carp_advbase = advbase;
	ch->carp_advskew = advskew;
	ch->carp_authlen = 7;	/* XXX DEFINE */
	ch->carp_pad1 = 0;	/* must be zero */
	ch->carp_cksum = 0;
d679 33
a711 9
	if (sc->sc_init_counter) {
		/* this could also be seconds since unix epoch */
		sc->sc_counter = arc4random();
		sc->sc_counter = sc->sc_counter << 32;
		sc->sc_counter += arc4random();
	} else if (sc->sc_counter == 0xffffffffffffffff) {
		sc->sc_counter = 0;
	} else
		sc->sc_counter++;
d713 18
a730 2
	ch->carp_counter[0] = htonl((sc->sc_counter>>32)&0xffffffff);
	ch->carp_counter[1] = htonl(sc->sc_counter&0xffffffff);
d732 33
a764 1
	carp_hmac_generate(sc, ch->carp_counter, ch->carp_md);
d766 9
a774 7
	m->m_data += sizeof(*ip);
	ch->carp_cksum = carp_cksum(m, len - sizeof(*ip));
	m->m_data -= sizeof(*ip);

	sc->sc_ac.ac_if.if_lastchange = time;
	sc->sc_ac.ac_if.if_opackets++;
	sc->sc_ac.ac_if.if_obytes += len;
d776 2
a777 7
	/* Tag packet for carp_output */
	mtag = m_tag_get(PACKET_TAG_CARP, sizeof(struct carp_softc *), M_NOWAIT);
	if (mtag == NULL) {
		m_freem(m);
		sc->sc_ac.ac_if.if_oerrors++;
		error = ENOMEM;
		return;
d779 1
a779 5
	bcopy(&sc, (caddr_t)(mtag + 1), sizeof(struct carp_softc *));
	m_tag_prepend(m, mtag);

	if ((error = ip_output(m, NULL, NULL, IP_RAWOUTPUT, &sc->sc_imo, NULL)))
		sc->sc_ac.ac_if.if_oerrors++;
d807 21
d863 1
a863 1
		if (ia->ia_addr.sin_addr.s_addr ==
d890 55
d977 1
d980 4
a983 2
		sc->sc_state = MASTER;
		carp_setrun(sc);
d988 4
d993 1
a993 1
carp_setrun(struct carp_softc *sc)
d995 1
d999 1
a999 1
	    sc->sc_vhid > 0 && sc->sc_naddrs)
d1011 1
d1015 18
a1032 1
			carp_setrun(sc);
d1036 1
d1039 18
a1056 1
		timeout_add(&sc->sc_md_tmo, tvtohz(&tv));
d1081 1
a1081 1
		carp_setrun(sc);
d1123 3
a1125 4
		if (!cif || (error = ifpromisc(ifp, 1))) {
			in_delmulti(imo->imo_membership[
			    --imo->imo_num_memberships]);
			return cif? error : ENOBUFS;
d1127 2
d1140 2
a1141 3
				in_delmulti(imo->imo_membership[
				    --imo->imo_num_memberships]);
				return EINVAL;
d1175 1
a1175 1
	carp_setrun(sc);
d1178 5
d1209 184
d1410 14
a1423 1
		if (ifa->ifa_addr->sa_family != AF_INET) {
a1426 2
		sc->if_flags |= IFF_UP;
		error = carp_set_addr(sc, satosin(ifa->ifa_addr));
d1430 14
a1443 1
		if (ifra->ifra_addr.sa_family != AF_INET) {
a1446 2
		sc->if_flags |= IFF_UP;
		error = carp_set_addr(sc, satosin(&ifra->ifra_addr));
d1450 13
a1462 1
		if (ifra->ifra_addr.sa_family != AF_INET) {
a1465 2
		sc->if_flags &= ~IFF_UP;
		error = carp_del_addr(sc, satosin(&ifra->ifra_addr));
d1473 1
d1477 1
a1477 1
			carp_setrun(sc);
d1482 1
a1482 1
			carp_setrun(sc);
d1532 1
a1532 1
			carp_setrun(sc);
d1575 15
a1589 2
	if (sa && sa->sa_family != AF_INET)
		return 0;
d1593 1
a1593 1
		return 0;
@


1.10
log
@Also check if we're going down before scheduling an advertisement
when we fail to get an mbuf.

This too is courtesy of Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.9 2003/10/27 06:13:43 mcbride Exp $	*/
d530 1
d546 2
d559 1
a559 1
			timeout_add(&sc->sc_ad_tmo, hz * sc->sc_advbase);
d629 1
a629 1
		timeout_add(&sc->sc_ad_tmo, hz * sc->sc_advbase);
@


1.9
log
@Actually stop sending advertisements if we're Master and the carp(4)
interface is brought down.

Bug reported by Max Laier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.8 2003/10/25 12:06:59 markus Exp $	*/
d555 2
a556 1
		timeout_add(&sc->sc_ad_tmo, hz * sc->sc_advbase);
@


1.8
log
@precompute most of hmac; fix size for md; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.7 2003/10/23 23:00:37 mcbride Exp $	*/
d624 1
a624 1
	if (advbase)
@


1.7
log
@We want to hash the whole md, not just the size of the pointer.

Found testing CARP between sparc and sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.6 2003/10/22 14:56:54 markus Exp $	*/
d104 4
d109 2
a110 1
	u_int64_t sc_counter;
d132 1
a154 2
#define CARP_HMAC_PAD	64

d156 1
a156 2
carp_hmac_generate(struct carp_softc *sc, u_int32_t counter[2],
    unsigned char md[20])
a157 1
	SHA1_CTX sha1ctx;
a160 2

	unsigned char ipad[CARP_HMAC_PAD], opad[CARP_HMAC_PAD];
d163 12
a174 17
	/* pad keys */
	/* XXX precompute ipad/opad and store in sc */
	bzero(ipad, CARP_HMAC_PAD);
	bzero(opad, CARP_HMAC_PAD);
	bcopy(sc->sc_key, ipad, sizeof(sc->sc_key));
	bcopy(sc->sc_key, opad, sizeof(sc->sc_key));
	for (i = 0; i < CARP_HMAC_PAD; i++) {
		ipad[i] ^= 0x36;
		opad[i] ^= 0x5c;
	}

	/* inner hash */
	SHA1Init(&sha1ctx);
	SHA1Update(&sha1ctx, ipad, CARP_HMAC_PAD);
	SHA1Update(&sha1ctx, (void *)&version, sizeof(version));
	SHA1Update(&sha1ctx, (void *)&type, sizeof(type));
	SHA1Update(&sha1ctx, (void *)&vhid, sizeof(vhid));
d177 1
a177 1
			SHA1Update(&sha1ctx,
d181 15
d201 2
a202 2
	SHA1Update(&sha1ctx, opad, CARP_HMAC_PAD);
	SHA1Update(&sha1ctx, md, sizeof(*md));
d1053 1
@


1.6
log
@switch from keyed sha1 to hmac-sha1; ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.5 2003/10/20 06:57:29 mcbride Exp $	*/
d192 1
a192 1
	SHA1Update(&sha1ctx, md, sizeof(md));
@


1.5
log
@Fix endianness bug in carp_sha1_generate, hash the whole counter, and
fix some whitespace nits while we're here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.4 2003/10/20 03:01:01 mcbride Exp $	*/
d127 1
a127 1
void	carp_sha1_generate (struct carp_softc *, u_int32_t *,
d129 1
a129 1
int	carp_sha1_verify (struct carp_softc *, u_int32_t *,
d149 2
d152 2
a153 1
carp_sha1_generate(struct carp_softc *sc, u_int32_t counter[2], unsigned char md[20])
a154 1
	/* XXX this should probably use the crypto framework */
d160 15
d176 1
a176 1

a179 1
	SHA1Update(&sha1ctx, (void *)&sc->sc_key, sizeof(sc->sc_key));
d187 1
d189 4
d197 2
a198 1
carp_sha1_verify(struct carp_softc *sc, u_int32_t counter[2],  unsigned char md[20])
d202 1
a202 1
	carp_sha1_generate(sc, counter, md2);
d349 1
a349 1
	if (carp_sha1_verify(sc, ch->carp_counter, ch->carp_md)) {
d590 1
a590 1
	carp_sha1_generate(sc, ch->carp_counter, ch->carp_md);
@


1.4
log
@Stop all hosts from insisting they're master when preemption is
disabled.

bug report and fix testing david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.3 2003/10/20 00:43:58 mcbride Exp $	*/
d127 1
a127 1
void	carp_sha1_generate (struct carp_softc *, u_int32_t *, 
d155 1
d162 1
a162 2
	SHA1Update(&sha1ctx, (void *)&sc->sc_vhid, sizeof(sc->sc_vhid));
	SHA1Update(&sha1ctx, (void *)counter, sizeof(*counter));
d170 1
d368 1
a368 1
		/* 
d377 1
a377 1
		/* 
d387 1
a387 1
		
@


1.3
log
@Fix but with setting advskew, only error if _both_ advbase and advskew are
set to 0. (ifconfig sets them one at a time)

tested by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.2 2003/10/19 03:58:25 david Exp $	*/
d355 2
a356 3
		 * If we're allowing preemption, and we recieve an advertisement
		 * from a master who's going to be more frequent than us,
		 * go into BACKUP state.
d358 1
a358 2
		if (carp_opts[CARPCTL_PREEMPT] &&
		    (timercmp(&sc_tv, &ch_tv, >) ||
d360 1
a360 1
		    ip->ip_src.s_addr > sc->sc_ia->ia_addr.sin_addr.s_addr))) {
d734 1
a734 1
		if (sc->sc_advskew == 0) {
@


1.2
log
@more typos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.c,v 1.1 2003/10/17 21:04:58 mcbride Exp $	*/
d984 2
a985 2
		if (carpr.carpr_advskew > 0) {
			if (carpr.carpr_advskew >= 255 || sc->sc_advskew == 0) {
a988 4
			sc->sc_advskew = carpr.carpr_advskew;
			error--;
		}
		if (carpr.carpr_advbase > 0) {
d994 1
@


1.1
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d630 1
a630 1
		 * XXX proof of concept iplementation.
@

