head	1.73;
access;
symbols
	OPENBSD_6_1:1.73.0.2
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.72.0.4
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.57.0.4
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.53.0.6
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.47.0.12
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.10
	OPENBSD_5_0:1.47.0.8
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.47.0.6
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.47.0.4
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.44.0.6
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.38.0.4
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.35.0.4
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.34.0.2
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.25
	UBC:1.17.0.4
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.73
date	2016.11.29.10.09.57;	author reyk;	state Exp;
branches;
next	1.72;
commitid	KGFiK26819ueNC3N;

1.72
date	2016.06.28.17.18.24;	author chris;	state Exp;
branches;
next	1.71;
commitid	WyHA21HjSsNdlXF8;

1.71
date	2016.05.18.20.15.14;	author mpi;	state Exp;
branches;
next	1.70;
commitid	GXDQtPDrSoQkUAr1;

1.70
date	2016.03.30.10.13.14;	author mpi;	state Exp;
branches;
next	1.69;
commitid	xpsJgMCf9pVyesEt;

1.69
date	2016.03.16.11.48.27;	author dlg;	state Exp;
branches;
next	1.68;
commitid	hdtj5mT7a4ere0XI;

1.68
date	2016.03.14.03.48.47;	author dlg;	state Exp;
branches;
next	1.67;
commitid	MDyOaANH377seN6I;

1.67
date	2016.03.01.01.48.14;	author dlg;	state Exp;
branches;
next	1.66;
commitid	ouNuJMxsb4QCBx8e;

1.66
date	2016.01.08.13.53.24;	author mpi;	state Exp;
branches;
next	1.65;
commitid	l2mfiUCCi0ZhRviM;

1.65
date	2015.12.09.15.05.51;	author mpi;	state Exp;
branches;
next	1.64;
commitid	q2xIbZZsrU0VN6YM;

1.64
date	2015.11.24.15.27.46;	author mpi;	state Exp;
branches;
next	1.63;
commitid	OjRcqwV8iZz2NczP;

1.63
date	2015.11.13.10.18.04;	author mpi;	state Exp;
branches;
next	1.62;
commitid	Ix3hlCTAP8RCy3Dw;

1.62
date	2015.10.27.15.22.58;	author mpi;	state Exp;
branches;
next	1.61;
commitid	JMeIgKwGCP5xUxZE;

1.61
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.60;
commitid	G2nTzngqgXpQqcJB;

1.60
date	2015.09.27.16.50.40;	author stsp;	state Exp;
branches;
next	1.59;
commitid	7pQnBFgz31Qa5o3q;

1.59
date	2015.09.13.10.42.32;	author dlg;	state Exp;
branches;
next	1.58;
commitid	KU5edmiQtbtt0saW;

1.58
date	2015.09.10.07.43.18;	author mpi;	state Exp;
branches;
next	1.57;
commitid	tfsw59CAjrnA3hvX;

1.57
date	2015.06.23.13.20.17;	author mpi;	state Exp;
branches;
next	1.56;
commitid	VHA7iwrVjcqP8Q9Q;

1.56
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.55;
commitid	c7ei8kPelCOOwHXy;

1.55
date	2015.03.24.12.58.43;	author mpi;	state Exp;
branches;
next	1.54;
commitid	YRb8NP3bqoft6Ioq;

1.54
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.53;
commitid	t9FBKDfc4VDxpEy2;

1.53
date	2014.01.09.06.29.05;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2013.11.21.16.34.33;	author mikeb;	state Exp;
branches;
next	1.51;

1.51
date	2013.08.28.06.58.57;	author mpi;	state Exp;
branches;
next	1.50;

1.50
date	2013.07.04.08.22.19;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2012.10.18.00.36.22;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.02.08.13.32.50;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.12.03.41.29;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.25.21.42.02;	author mk;	state Exp;
branches;
next	1.44;

1.44
date	2008.11.08.12.54.58;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2008.10.31.21.08.33;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.30.09.39.05;	author gollo;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.16.18.23.53;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.18.09.16.14;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.16.09.24.07;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2006.06.28.12.13.24;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.28.00.20.21;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.28.06.19.58;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.23.18.21.41;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.31.16.34.57;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.22.22.46.30;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.16.21.35.37;	author naddy;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.18.21.10.14;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.14.02.02.55;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.13.08.25.44;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.13.04.51.05;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.14.21.35.00;	author todd;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.10.22.48.09;	author chris;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.08.07.59.20;	author chris;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.07.19.28.59;	author nate;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.01.05.06.24;	author kjc;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.27.06.07.47;	author kjc;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2001.06.23.21.32.26;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.09.06.14.32;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.19.06.37.38;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.28.23.56.47;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.07.18.15.47;	author chris;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.10.05.49.28;	author jason;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.08.02.22.51.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.05.16.00.34.40;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	99.01.07.09.11.52;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.27.11.06.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.03.08.09.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.48.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.22.30.25;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2000.03.24.09.09.35;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.05.14.22.40.07;	author niklas;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.07.04.10.54.29;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.11.2.8;

1.11.2.8
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.11.2.9;

1.11.2.9
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.17.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.73
log
@For virtual Ethernet drivers that don't have a technical limit of the
hardmtu, pick a value of 65435 that leaves space for some
encapsulation and almost a complete max-IP packet.  After some
discussion we picked this arbitrary value.

OK dlg@@
@
text
@/*	$OpenBSD: if_ether.h,v 1.72 2016/06/28 17:18:24 chris Exp $	*/
/*	$NetBSD: if_ether.h,v 1.22 1996/05/11 13:00:00 mycroft Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_ether.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET_IF_ETHER_H_
#define _NETINET_IF_ETHER_H_

/*
 * Some basic Ethernet constants.
 */
#define	ETHER_ADDR_LEN	6	/* Ethernet address length		*/
#define ETHER_TYPE_LEN	2	/* Ethernet type field length		*/
#define ETHER_CRC_LEN	4	/* Ethernet CRC length			*/
#define ETHER_HDR_LEN	((ETHER_ADDR_LEN * 2) + ETHER_TYPE_LEN)
#define ETHER_MIN_LEN	64	/* Minimum frame length, CRC included	*/
#define ETHER_MAX_LEN	1518	/* Maximum frame length, CRC included	*/
#define ETHER_MAX_DIX_LEN	1536	/* Maximum DIX frame length	*/

/*
 * Some Ethernet extensions.
 */
#define ETHER_VLAN_ENCAP_LEN	4	/* len of 802.1Q VLAN encapsulation */

/*
 * Mbuf adjust factor to force 32-bit alignment of IP header.
 * Drivers should do m_adj(m, ETHER_ALIGN) when setting up a
 * receive so the upper layers get the IP header properly aligned
 * past the 14-byte Ethernet header.
 */
#define ETHER_ALIGN	2	/* driver adjust for IP hdr alignment */

/*
 * The maximum supported Ethernet length and some space for encapsulation.
 */
#define ETHER_MAX_HARDMTU_LEN	65435

/*
 * Ethernet address - 6 octets
 */
struct ether_addr {
	u_int8_t ether_addr_octet[ETHER_ADDR_LEN];
};

/*
 * The length of the combined header.
 */
struct	ether_header {
	u_int8_t  ether_dhost[ETHER_ADDR_LEN];
	u_int8_t  ether_shost[ETHER_ADDR_LEN];
	u_int16_t ether_type;
};

/*
 * VLAN headers.
 */

struct  ether_vlan_header {
        u_char  evl_dhost[ETHER_ADDR_LEN];
        u_char  evl_shost[ETHER_ADDR_LEN];
        u_int16_t evl_encap_proto;
        u_int16_t evl_tag;
        u_int16_t evl_proto;
};

#define EVL_VLID_MASK	0xFFF
#define EVL_VLID_NULL	0x000
/* 0x000 and 0xfff are reserved */
#define EVL_VLID_MIN	0x001
#define EVL_VLID_MAX	0xFFE
#define EVL_VLANOFTAG(tag) ((tag) & EVL_VLID_MASK)

#define EVL_PRIO_MAX    7
#define EVL_PRIO_BITS   13
#define EVL_PRIOFTAG(tag) (((tag) >> EVL_PRIO_BITS) & 7)

#define EVL_ENCAPLEN    4       /* length in octets of encapsulation */

#include <net/ethertypes.h>

#define	ETHER_IS_MULTICAST(addr) (*(addr) & 0x01) /* is address mcast/bcast? */

#define	ETHERMTU	(ETHER_MAX_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
#define	ETHERMIN	(ETHER_MIN_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)

/*
 * Ethernet CRC32 polynomials (big- and little-endian verions).
 */
#define	ETHER_CRC_POLY_LE	0xedb88320
#define	ETHER_CRC_POLY_BE	0x04c11db6

/*
 * Ethernet Address Resolution Protocol.
 *
 * See RFC 826 for protocol description.  Structure below is adapted
 * to resolving internet addresses.  Field names used correspond to
 * RFC 826.
 */
struct	ether_arp {
	struct	 arphdr ea_hdr;			/* fixed-size header */
	u_int8_t arp_sha[ETHER_ADDR_LEN];	/* sender hardware address */
	u_int8_t arp_spa[4];			/* sender protocol address */
	u_int8_t arp_tha[ETHER_ADDR_LEN];	/* target hardware address */
	u_int8_t arp_tpa[4];			/* target protocol address */
};
#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

struct sockaddr_inarp {
	u_int8_t  sin_len;
	u_int8_t  sin_family;
	u_int16_t sin_port;
	struct	  in_addr sin_addr;
	struct	  in_addr sin_srcaddr;
	u_int16_t sin_tos;
	u_int16_t sin_other;
#define SIN_PROXY 1
};

/*
 * IP and ethernet specific routing flags
 */
#define	RTF_USETRAILERS	  RTF_PROTO1	/* use trailers */
#define	RTF_PERMANENT_ARP RTF_PROTO3    /* only manual overwrite of entry */

#ifdef _KERNEL
/*
 * Macro to map an IP multicast address to an Ethernet multicast address.
 * The high-order 25 bits of the Ethernet address are statically assigned,
 * and the low-order 23 bits are taken from the low end of the IP address.
 */
#define ETHER_MAP_IP_MULTICAST(ipaddr, enaddr)				\
	/* struct in_addr *ipaddr; */					\
	/* u_int8_t enaddr[ETHER_ADDR_LEN]; */				\
do {									\
	(enaddr)[0] = 0x01;						\
	(enaddr)[1] = 0x00;						\
	(enaddr)[2] = 0x5e;						\
	(enaddr)[3] = ((u_int8_t *)ipaddr)[1] & 0x7f;			\
	(enaddr)[4] = ((u_int8_t *)ipaddr)[2];				\
	(enaddr)[5] = ((u_int8_t *)ipaddr)[3];				\
} while (/* CONSTCOND */ 0)

/*
 * Macro to map an IPv6 multicast address to an Ethernet multicast address.
 * The high-order 16 bits of the Ethernet address are statically assigned,
 * and the low-order 32 bits are taken from the low end of the IPv6 address.
 */
#define ETHER_MAP_IPV6_MULTICAST(ip6addr, enaddr)			\
	/* struct in6_addr *ip6addr; */					\
	/* u_int8_t enaddr[ETHER_ADDR_LEN]; */				\
do {									\
	(enaddr)[0] = 0x33;						\
	(enaddr)[1] = 0x33;						\
	(enaddr)[2] = ((u_int8_t *)ip6addr)[12];			\
	(enaddr)[3] = ((u_int8_t *)ip6addr)[13];			\
	(enaddr)[4] = ((u_int8_t *)ip6addr)[14];			\
	(enaddr)[5] = ((u_int8_t *)ip6addr)[15];			\
} while (/* CONSTCOND */ 0)

#include <net/if_var.h>	/* for "struct ifnet" */

/*
 * Structure shared between the ethernet driver modules and
 * the address resolution code.  For example, each ec_softc or il_softc
 * begins with this structure.
 */
struct	arpcom {
	struct	 ifnet ac_if;			/* network-visible interface */
	u_int8_t ac_enaddr[ETHER_ADDR_LEN];	/* ethernet hardware address */
	char	 ac__pad[2];			/* pad for some machines */
	LIST_HEAD(, ether_multi) ac_multiaddrs;	/* list of multicast addrs */
	int	 ac_multicnt;			/* length of ac_multiaddrs */
	int	 ac_multirangecnt;		/* number of mcast ranges */

};

extern int arpt_keep;				/* arp resolved cache expire */
extern int arpt_down;				/* arp down cache expire */

extern u_int8_t etherbroadcastaddr[ETHER_ADDR_LEN];
extern u_int8_t etheranyaddr[ETHER_ADDR_LEN];
extern u_int8_t ether_ipmulticast_min[ETHER_ADDR_LEN];
extern u_int8_t ether_ipmulticast_max[ETHER_ADDR_LEN];

#ifdef NFSCLIENT
extern unsigned int revarp_ifidx;
#endif /* NFSCLIENT */

void	revarpinput(struct ifnet *, struct mbuf *);
void	revarprequest(struct ifnet *);
int	revarpwhoarewe(struct ifnet *, struct in_addr *, struct in_addr *);
int	revarpwhoami(struct in_addr *, struct ifnet *);

void	arpinput(struct ifnet *, struct mbuf *);
void	arprequest(struct ifnet *, u_int32_t *, u_int32_t *, u_int8_t *);
void	arpwhohas(struct arpcom *, struct in_addr *);
int	arpproxy(struct in_addr, unsigned int);
int	arpresolve(struct ifnet *, struct rtentry *, struct mbuf *,
	    struct sockaddr *, u_char *);
void	arp_rtrequest(struct ifnet *, int, struct rtentry *);

void	ether_fakeaddr(struct ifnet *);
int	ether_addmulti(struct ifreq *, struct arpcom *);
int	ether_delmulti(struct ifreq *, struct arpcom *);
int	ether_multiaddr(struct sockaddr *, u_int8_t[], u_int8_t[]);
void	ether_ifattach(struct ifnet *);
void	ether_ifdetach(struct ifnet *);
int	ether_ioctl(struct ifnet *, struct arpcom *, u_long, caddr_t);
int	ether_input(struct ifnet *, struct mbuf *, void *);
int	ether_output(struct ifnet *,
	    struct mbuf *, struct sockaddr *, struct rtentry *);
void	ether_rtrequest(struct ifnet *, int, struct rtentry *);
char	*ether_sprintf(u_char *);


/*
 * Ethernet multicast address structure.  There is one of these for each
 * multicast address or range of multicast addresses that we are supposed
 * to listen to on a particular interface.  They are kept in a linked list,
 * rooted in the interface's arpcom structure.  (This really has nothing to
 * do with ARP, or with the Internet address family, but this appears to be
 * the minimally-disrupting place to put it.)
 */
struct ether_multi {
	u_int8_t enm_addrlo[ETHER_ADDR_LEN]; /* low  or only address of range */
	u_int8_t enm_addrhi[ETHER_ADDR_LEN]; /* high or only address of range */
	u_int	 enm_refcount;		/* no. claims to this addr/range */
	LIST_ENTRY(ether_multi) enm_list;
};

/*
 * Structure used by macros below to remember position when stepping through
 * all of the ether_multi records.
 */
struct ether_multistep {
	struct ether_multi  *e_enm;
};

/*
 * Macro for looking up the ether_multi record for a given range of Ethernet
 * multicast addresses connected to a given arpcom structure.  If no matching
 * record is found, "enm" returns NULL.
 */
#define ETHER_LOOKUP_MULTI(addrlo, addrhi, ac, enm)			\
	/* u_int8_t addrlo[ETHER_ADDR_LEN]; */				\
	/* u_int8_t addrhi[ETHER_ADDR_LEN]; */				\
	/* struct arpcom *ac; */					\
	/* struct ether_multi *enm; */					\
do {									\
	for ((enm) = LIST_FIRST(&(ac)->ac_multiaddrs);			\
	    (enm) != NULL &&						\
	    (memcmp((enm)->enm_addrlo, (addrlo), ETHER_ADDR_LEN) != 0 ||\
	     memcmp((enm)->enm_addrhi, (addrhi), ETHER_ADDR_LEN) != 0);	\
		(enm) = LIST_NEXT((enm), enm_list));			\
} while (/* CONSTCOND */ 0)

/*
 * Macro to step through all of the ether_multi records, one at a time.
 * The current position is remembered in "step", which the caller must
 * provide.  ETHER_FIRST_MULTI(), below, must be called to initialize "step"
 * and get the first record.  Both macros return a NULL "enm" when there
 * are no remaining records.
 */
#define ETHER_NEXT_MULTI(step, enm)					\
	/* struct ether_multistep step; */				\
	/* struct ether_multi *enm; */					\
do {									\
	if (((enm) = (step).e_enm) != NULL)				\
		(step).e_enm = LIST_NEXT((enm), enm_list);		\
} while (/* CONSTCOND */ 0)

#define ETHER_FIRST_MULTI(step, ac, enm)				\
	/* struct ether_multistep step; */				\
	/* struct arpcom *ac; */					\
	/* struct ether_multi *enm; */					\
do {									\
	(step).e_enm = LIST_FIRST(&(ac)->ac_multiaddrs);		\
	ETHER_NEXT_MULTI((step), (enm));				\
} while (/* CONSTCOND */ 0)

u_int32_t ether_crc32_le_update(u_int32_t crc, const u_int8_t *, size_t);
u_int32_t ether_crc32_be_update(u_int32_t crc, const u_int8_t *, size_t);
u_int32_t ether_crc32_le(const u_int8_t *, size_t);
u_int32_t ether_crc32_be(const u_int8_t *, size_t);

#else /* _KERNEL */

__BEGIN_DECLS
char *ether_ntoa(struct ether_addr *);
struct ether_addr *ether_aton(const char *);
int ether_ntohost(char *, struct ether_addr *);
int ether_hostton(const char *, struct ether_addr *);
int ether_line(const char *, struct ether_addr *, char *);
__END_DECLS

#endif /* _KERNEL */
#endif /* _NETINET_IF_ETHER_H_ */
@


1.72
log
@Add sysctl for arp timers: net.inet.ip.arptimeout (expire timer for resolved
entries) and net.inet.ip.arpdown (expire timer for unresolved entries)

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.71 2016/05/18 20:15:14 mpi Exp $	*/
d61 5
@


1.71
log
@Remove some superflous if_get(9)/if_put(9) dances now that ARP input
routines are call directly by ether_input().

ok visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.70 2016/03/30 10:13:14 mpi Exp $	*/
d204 3
@


1.70
log
@Implement proxy ARP for ART based on mpath support.

Since mpath is not enabled in RAMDISK, proxy ARP won't work there either.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.69 2016/03/16 11:48:27 dlg Exp $	*/
d214 1
a214 1
void	revarpinput(struct mbuf *);
d219 1
a219 1
void	arpinput(struct mbuf *);
@


1.69
log
@macros for the null, min, and max vlan ids.

ok mpi@@ and tweaks from sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.68 2016/03/14 03:48:47 dlg Exp $	*/
a150 1
#define	RTF_ANNOUNCE	  RTF_PROTO2	/* announce new arp entry */
@


1.68
log
@move the vlan protocol definitions to the same places as the ethernet ones

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.67 2016/03/01 01:48:14 dlg Exp $	*/
d90 5
a94 1
#define EVL_VLID_MASK   0x0FFF
@


1.67
log
@enm_ac in ether_multi is set but never used. so we dont need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.66 2016/01/08 13:53:24 mpi Exp $	*/
d77 21
@


1.66
log
@Get rid of the arp and revarp input queues.

Packets of types ARP and REVARP are now processed in the softnet task,
directly from ether_input() and without holding the KERNEL_LOCK.

Tested by many, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.65 2015/12/09 15:05:51 mpi Exp $	*/
a227 1
	struct	 arpcom *enm_ac;	/* back pointer to arpcom */
@


1.65
log
@Keep all ether prototypes in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.64 2015/11/24 15:27:46 mpi Exp $	*/
a184 2
extern struct niqueue arpintrq;
extern struct niqueue rarpintrq;
d186 11
d198 1
a198 1
void	arpintr(void);
a281 11

#ifdef NFSCLIENT
extern unsigned int revarp_ifidx;
#endif /* NFSCLIENT */

void arprequest(struct ifnet *, u_int32_t *, u_int32_t *, u_int8_t *);
int arpproxy(struct in_addr, unsigned int);
void revarprequest(struct ifnet *);
int revarpwhoarewe(struct ifnet *, struct in_addr *, struct in_addr *);
int revarpwhoami(struct in_addr *, struct ifnet *);
int db_show_arptab(void);
@


1.64
log
@Merge three #ifdef _KERNEL blocks into one.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.63 2015/11/13 10:18:04 mpi Exp $	*/
d198 9
@


1.63
log
@Sore the index of the interface used for revarp instead of a pointer to
its descriptor.  Get rid of a if_ref().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.62 2015/10/27 15:22:58 mpi Exp $	*/
d91 38
a163 25
void	ether_fakeaddr(struct ifnet *);
#endif

/*
 * Ethernet Address Resolution Protocol.
 *
 * See RFC 826 for protocol description.  Structure below is adapted
 * to resolving internet addresses.  Field names used correspond to
 * RFC 826.
 */
struct	ether_arp {
	struct	 arphdr ea_hdr;			/* fixed-size header */
	u_int8_t arp_sha[ETHER_ADDR_LEN];	/* sender hardware address */
	u_int8_t arp_spa[4];			/* sender protocol address */
	u_int8_t arp_tha[ETHER_ADDR_LEN];	/* target hardware address */
	u_int8_t arp_tpa[4];			/* target protocol address */
};
#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

#ifdef _KERNEL

a179 19
#endif

struct sockaddr_inarp {
	u_int8_t  sin_len;
	u_int8_t  sin_family;
	u_int16_t sin_port;
	struct	  in_addr sin_addr;
	struct	  in_addr sin_srcaddr;
	u_int16_t sin_tos;
	u_int16_t sin_other;
#define SIN_PROXY 1
};

/*
 * IP and ethernet specific routing flags
 */
#define	RTF_USETRAILERS	  RTF_PROTO1	/* use trailers */
#define	RTF_ANNOUNCE	  RTF_PROTO2	/* announce new arp entry */
#define	RTF_PERMANENT_ARP RTF_PROTO3    /* only manual overwrite of entry */
a180 1
#ifdef	_KERNEL
d190 2
a191 2
int	arpresolve(struct ifnet *,
	    struct rtentry *, struct mbuf *, struct sockaddr *, u_char *);
d194 1
d281 1
a281 1
#else
@


1.62
log
@RIP arp_ifinit().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.61 2015/10/25 11:58:11 mpi Exp $	*/
d272 1
a272 1
extern struct ifnet *revarp_ifp;
@


1.61
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.60 2015/09/27 16:50:40 stsp Exp $	*/
a198 1
void	arp_ifinit(struct arpcom *, struct ifaddr *);
@


1.60
log
@Welcome etheranyaddr, cousin of etherbroadcastaddr.
Can be used to check if a MAC address is all zeros.
Will be used by iwm(4) soon.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.59 2015/09/13 10:42:32 dlg Exp $	*/
d200 1
a200 1
void	arp_rtrequest(int, struct rtentry *);
@


1.59
log
@queue revarps to softnet so we can defer processing to a context with
the kernel lock.

"do it" claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.58 2015/09/10 07:43:18 mpi Exp $	*/
d189 1
@


1.58
log
@Missing prototype change in previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.57 2015/06/23 13:20:17 mpi Exp $	*/
d192 1
a276 2
void revarpinput(struct mbuf *);
void in_revarpinput(struct mbuf *);
@


1.57
log
@Pass a "struct ifnet *" instead of a "struct arpcom *" to arpresolve().

Most of the ARP layer already take an ifp pointer and this makes clear
wich chunks of code are messing with ac_enaddr.

Note that our Ethernet code assume that these pointer are interchangeable
since the first element of the "struct arpcom" is a "struct ifnet".
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.56 2015/04/10 13:58:20 dlg Exp $	*/
d275 1
a275 1
int arpproxy(struct in_addr, u_int);
@


1.56
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.55 2015/03/24 12:58:43 mpi Exp $	*/
d195 1
a195 1
int	arpresolve(struct arpcom *,
@


1.55
log
@Convert hand-rolled mbuf list used to store packets until ARP
resolution is completed to ml_init(9) API.

Tested by kspillner@@, inputs & ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.54 2014/12/05 15:50:04 mpi Exp $	*/
d191 1
a191 1
extern struct ifqueue arpintrq;
@


1.54
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.53 2014/01/09 06:29:05 tedu Exp $	*/
a166 11

struct llinfo_arp {
	LIST_ENTRY(llinfo_arp) la_list;
	struct	rtentry *la_rt;
	struct	mbuf *la_hold_head;	/* packet hold queue */
	struct	mbuf *la_hold_tail;
	int	la_hold_count;		/* number of packets queued */
	long	la_asked;		/* last time we QUERIED for this addr */
};
#define MAX_HOLD_QUEUE 10
#define MAX_HOLD_TOTAL 100
@


1.53
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.52 2013/11/21 16:34:33 mikeb Exp $	*/
d150 3
@


1.52
log
@hide a bunch of structures (namely arpcom, llinfo_arp, ethernet
multicast macros and in_ifaddr) that reference ifnet in some way;
looked over by deraadt, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.51 2013/08/28 06:58:57 mpi Exp $	*/
d248 3
a250 3
	    (enm) != NULL &&			\
	    (bcmp((enm)->enm_addrlo, (addrlo), ETHER_ADDR_LEN) != 0 ||	\
	     bcmp((enm)->enm_addrhi, (addrhi), ETHER_ADDR_LEN) != 0);	\
@


1.51
log
@Remove unused argument from *rtrequest()

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.50 2013/07/04 08:22:19 mpi Exp $	*/
d149 1
d175 1
a210 1
#endif /* _KERNEL */
a276 2

#ifdef _KERNEL
@


1.50
log
@Rewrite the function used to determine if we do proxy ARP for one of
our addresses to reuse arplookup() and do only one list iteration.

Looks ok to claudio@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.49 2013/03/22 01:41:12 tedu Exp $	*/
d204 1
a204 1
void	arp_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
@


1.49
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.48 2012/10/18 00:36:22 deraadt Exp $	*/
d284 1
@


1.48
log
@Move revarp code into #ifdef NFSCLIENT; saving space on some media.
Resurrect the rather silly "unplug my network device while I am
doing nfs diskless revarp" safety code which was disabled due to
a missing "ether.h" include, found by jsg
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.47 2010/02/08 13:32:50 claudio Exp $	*/
d247 1
a247 1
	    (enm) != LIST_END(&(ac)->ac_multiaddrs) &&			\
@


1.47
log
@arpioctl() is not used sore remove it. Found by Gleydson Soares.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.46 2010/01/12 03:41:29 deraadt Exp $	*/
d279 3
a281 1
extern struct ifnet *myip_ifp;
@


1.46
log
@Unify the various fake ethernet generators as ether_fakeaddr() which
is safe for both hardware devices and virtual devices
ok mpf, kettenis, moaning and groaning and slow acceptance from mcbride
XXX should loop checking for uniqueness after new henning diff goes in
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.45 2009/10/25 21:42:02 mk Exp $	*/
a280 1
int arpioctl(u_long, caddr_t);
@


1.45
log
@Get rid of unused macro `la_timer'.

`if it is unused nuke it' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.44 2008/11/08 12:54:58 dlg Exp $	*/
d125 2
@


1.44
log
@fix macros up so they use the do { } while (/* CONSTCOND */ 0) idiom

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.43 2008/10/31 21:08:33 claudio Exp $	*/
a168 1
#define la_timer la_rt->rt_rmx.rmx_expire /* deletion time in seconds */
@


1.43
log
@Be way more strict in the number of packets allowed to be queued in the
arp layer. With a lot of input from deraadt@@.
OK dlg@@, looks good gollo@@ + deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.42 2008/10/30 09:39:05 gollo Exp $	*/
d100 1
a100 1
{									\
d107 1
a107 1
}
d117 1
a117 1
{									\
d124 1
a124 1
}
d244 1
a244 1
{									\
d250 1
a250 1
}
d259 16
a274 16
#define ETHER_NEXT_MULTI(step, enm) \
	/* struct ether_multistep step; */  \
	/* struct ether_multi *enm; */  \
{ \
	if (((enm) = (step).e_enm) != NULL) \
		(step).e_enm = LIST_NEXT((enm), enm_list); \
}

#define ETHER_FIRST_MULTI(step, ac, enm) \
	/* struct ether_multistep step; */ \
	/* struct arpcom *ac; */ \
	/* struct ether_multi *enm; */ \
{ \
	(step).e_enm = LIST_FIRST(&(ac)->ac_multiaddrs); \
	ETHER_NEXT_MULTI((step), (enm)); \
}
@


1.42
log
@Arpresolve could loose few packets during resolving an ethernet
address. This cvs commit introduces a queue that buffers a small
burst of packets and resending the packets in correct order when
the ethernet address is resolved. Code written by Armin Wolfermann
<aw@@osn.de>.

OK: claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.41 2008/10/16 18:23:53 claudio Exp $	*/
d172 1
a172 1
#define MAX_HOLD_TOTAL NMBCLUSTERS / 10
@


1.41
log
@Kill M_HASFCS, it is not used in OpenBSD. If a ethernet chip returns the
checksum in the packet it should be trimmed away by the driver and not by
driver independent code. OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.40 2008/04/18 09:16:14 djm Exp $	*/
d165 3
a167 1
	struct	mbuf *la_hold;		/* last packet until resolved/timeout */
d171 2
@


1.40
log
@extend the if_ethersubr.c crc functions to support updating a running
crc in addition to the existing "oneshot" mode and use them to replace
ieee80211_crc_update() with the new ether_crc32_le_update(). Saves 1k
kernel bss + some code.

Mark the new ether_crc32_[lb]e_update functions as __pure for a
~25x speedup (on my i386 at least).

feedback and ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.39 2007/05/16 09:24:07 dlg Exp $	*/
a89 5

/*
 * Ethernet-specific mbuf flags.
 */
#define M_HASFCS	M_LINK0	/* FCS included at end of frame */
@


1.39
log
@count the number of multicast ranges that are kept in the list of multicast
addresses in struct arpcom. this lets a nic driver easily see if it wants
allmulti behaviour, which in turn means we can clean some code up.

ok jason@@ claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.38 2006/06/28 12:13:24 claudio Exp $	*/
d290 2
@


1.38
log
@No need to add function prototypes twice to a header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.37 2006/05/28 00:20:21 brad Exp $	*/
d161 4
a164 2
	LIST_HEAD(, ether_multi) ac_multiaddrs;	/* list of ether multicast addrs */
	int	 ac_multicnt;			/* length of ac_multiaddrs list */
@


1.37
log
@- remove ETHER_MAX_LEN_JUMBO and ETHERMTU_JUMBO.
- use if_hardmtu for MTU ioctl handlers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.36 2006/03/05 21:48:56 miod Exp $	*/
a278 4
void arp_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
int arpresolve(struct arpcom *, struct rtentry *, struct mbuf *,
		    struct sockaddr *, u_char *);
void arpintr(void);
a279 1
void arp_ifinit(struct arpcom *, struct ifaddr *);
@


1.36
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.35 2005/03/28 06:19:58 tedu Exp $	*/
a47 1
#define ETHER_MAX_LEN_JUMBO	9018	/* max jumbo frame len, including CRC */
a83 1
#define	ETHERMTU_JUMBO	(ETHER_MAX_LEN_JUMBO - ETHER_HDR_LEN - ETHER_CRC_LEN)
@


1.35
log
@add some const to ether_*.  remove bonus prototypes this brought out.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.34 2004/09/23 18:21:41 brad Exp $	*/
d246 2
a247 2
	for ((enm) = (ac)->ac_multiaddrs.lh_first;			\
	    (enm) != NULL &&						\
d250 1
a250 1
		(enm) = (enm)->enm_list.le_next);			\
d265 1
a265 1
		(step).e_enm = (enm)->enm_list.le_next; \
d273 1
a273 1
	(step).e_enm = (ac)->ac_multiaddrs.lh_first; \
@


1.34
log
@add ETHER_MAX_DIX_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.33 2004/07/31 16:34:57 brad Exp $	*/
d302 1
a302 1
struct ether_addr *ether_aton(char *);
d304 2
a305 2
int ether_hostton(char *, struct ether_addr *);
int ether_line(char *, struct ether_addr *, char *);
@


1.33
log
@- formatting
- add comment
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.32 2004/06/22 22:46:30 millert Exp $	*/
d47 1
@


1.32
log
@Add M_LINK0 for net80211; OK markus@@ and mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.31 2004/06/16 21:35:37 naddy Exp $	*/
d39 1
a39 1
 * Some Ethernet constants.
d47 1
a47 1
#define	ETHER_MAX_LEN_JUMBO	9018	/* max jumbo frame len, including CRC */
d49 4
a52 1
#define	ETHER_VLAN_ENCAP_LEN	4	/* len of 802.1Q VLAN encapsulation */
d60 1
a60 1
#define	ETHER_ALIGN		2	/* driver adjust for IP hdr alignment */
@


1.31
log
@make safe for inclusion in C++ code; ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.30 2004/05/18 21:10:14 brad Exp $	*/
d88 5
@


1.30
log
@if_ether.h
add ETHER_MAX_LEN_JUMBO, ETHER_VLAN_ENCAP_LEN, ETHER_ALIGN, and
ETHERMTU_JUMBO constants.

if.h
add a few more interface capabilities flags.

Some from NetBSD, some from FreeBSD.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.29 2003/06/02 23:28:13 millert Exp $	*/
d291 1
d297 1
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.28 2003/05/14 02:02:55 itojun Exp $	*/
d47 11
a68 1

d81 1
@


1.28
log
@move ETHERTYPE_xx declarations to <net/ethertypes.h>.  meets netbsd practice.
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.27 2003/05/13 08:25:44 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.27
log
@back out.  these changes were not tested.  it might come as a surprise
to some developers, but include files are not just used by the kernel.
there are applications that pull them in as well.  this change broke
tcpdump, and who knows what else.  i've been talking for 24 hours now
about tree breakage and let this be official: I am prepared to lock the
tree entirely if need be.  YOU WILL GET OK PERMISSION FROM EVERYONE, NOT
JUST FROM ONE PERSON
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.25 2002/07/03 21:19:08 miod Exp $	*/
d69 1
a69 17
#define	ETHERTYPE_PUP		0x0200	/* PUP protocol */
#define	ETHERTYPE_IP		0x0800	/* IP protocol */
#define	ETHERTYPE_ARP		0x0806	/* address resolution protocol */
#define	ETHERTYPE_REVARP	0x8035	/* reverse addr resolution protocol */
#define	ETHERTYPE_8021Q		0x8100	/* IEEE 802.1Q VLAN tagging */
#define	ETHERTYPE_IPV6		0x86DD	/* IPv6 protocol */
#define	ETHERTYPE_PPPOEDISC	0x8863	/* PPP Over Ethernet Discovery Stage */
#define	ETHERTYPE_PPPOE		0x8864	/* PPP Over Ethernet Session Stage */
#define	ETHERTYPE_LOOPBACK	0x9000	/* used to test interfaces */

/*
 * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
 * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
 * by an ETHER type (as given above) and then the (variable-length) header.
 */
#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
#define	ETHERTYPE_NTRAILER	16
@


1.26
log
@move ethernet protocol type defs into sys/net/, as it is not just for ethernet
(FDDI, ieee1394, ...).  follows netbsd practice.
2 jasons, dhartmei, thierry ok
@
text
@d69 17
a85 1
#include <net/ethertypes.h>
@


1.25
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.24 2002/06/14 21:35:00 todd Exp $	*/
d69 1
a69 17
#define	ETHERTYPE_PUP		0x0200	/* PUP protocol */
#define	ETHERTYPE_IP		0x0800	/* IP protocol */
#define	ETHERTYPE_ARP		0x0806	/* address resolution protocol */
#define	ETHERTYPE_REVARP	0x8035	/* reverse addr resolution protocol */
#define	ETHERTYPE_8021Q		0x8100	/* IEEE 802.1Q VLAN tagging */
#define	ETHERTYPE_IPV6		0x86DD	/* IPv6 protocol */
#define	ETHERTYPE_PPPOEDISC	0x8863	/* PPP Over Ethernet Discovery Stage */
#define	ETHERTYPE_PPPOE		0x8864	/* PPP Over Ethernet Session Stage */
#define	ETHERTYPE_LOOPBACK	0x9000	/* used to test interfaces */

/*
 * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
 * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
 * by an ETHER type (as given above) and then the (variable-length) header.
 */
#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
#define	ETHERTYPE_NTRAILER	16
@


1.24
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.23 2002/06/10 22:48:09 chris Exp $	*/
d194 4
a197 4
u_int8_t etherbroadcastaddr[ETHER_ADDR_LEN];
u_int8_t ether_ipmulticast_min[ETHER_ADDR_LEN];
u_int8_t ether_ipmulticast_max[ETHER_ADDR_LEN];
struct	ifqueue arpintrq;
@


1.23
log
@Split common code which converts a multicast address to an ethernet
address from ether_addmulti() and ether_delmulti() into ether_multiaddr(),
a'la netbsd.

Also clean up some magic numbers.

itojun likes it
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.22 2002/06/09 16:26:10 itojun Exp $	*/
d47 1
a47 1
#define ETHER_CRC_LEN	4	/* Ethernet CRC lenght			*/
@


1.22
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.21 2002/06/08 07:59:20 chris Exp $	*/
d208 1
@


1.21
log
@correctness
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.20 2002/05/07 19:28:59 nate Exp $	*/
d138 1
a138 1
 * to resolving internet addresses.  Field names used correspond to 
@


1.20
log
@move ether_crc32_le to if_ethersubr.c.  Add ether_crc32_be
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.19 2002/03/14 01:27:11 millert Exp $	*/
a42 8
 * Ethernet address - 6 octets
 * this is only used by the ethers(3) functions.
 */
struct ether_addr {
	u_int8_t ether_addr_octet[6];
};

/*
d51 7
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.18 2002/03/01 05:06:24 kjc Exp $	*/
d93 6
d294 3
@


1.18
log
@sync with KAME
move the function prototype of altq_etherclassify() from
netinet/if_ether.h to altq/if_altq.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.17 2001/06/27 06:07:47 kjc Exp $	*/
d194 6
a199 6
void	arpwhohas __P((struct arpcom *, struct in_addr *));
void	arpintr __P((void));
int	arpresolve __P((struct arpcom *,
	    struct rtentry *, struct mbuf *, struct sockaddr *, u_char *));
void	arp_ifinit __P((struct arpcom *, struct ifaddr *));
void	arp_rtrequest __P((int, struct rtentry *, struct rt_addrinfo *));
d201 2
a202 2
int	ether_addmulti __P((struct ifreq *, struct arpcom *));
int	ether_delmulti __P((struct ifreq *, struct arpcom *));
d275 13
a287 13
void arp_rtrequest __P((int, struct rtentry *, struct rt_addrinfo *));
int arpresolve __P((struct arpcom *, struct rtentry *, struct mbuf *,
		    struct sockaddr *, u_char *));
void arpintr __P((void));
int arpioctl __P((u_long, caddr_t));
void arp_ifinit __P((struct arpcom *, struct ifaddr *));
void arprequest __P((struct ifnet *, u_int32_t *, u_int32_t *, u_int8_t *));
void revarpinput __P((struct mbuf *));
void in_revarpinput __P((struct mbuf *));
void revarprequest __P((struct ifnet *));
int revarpwhoarewe __P((struct ifnet *, struct in_addr *, struct in_addr *));
int revarpwhoami __P((struct in_addr *, struct ifnet *));
int db_show_arptab __P((void));
d291 5
a295 5
char *ether_ntoa __P((struct ether_addr *));
struct ether_addr *ether_aton __P((char *));
int ether_ntohost __P((char *, struct ether_addr *));
int ether_hostton __P((char *, struct ether_addr *));
int ether_line __P((char *, struct ether_addr *, char *));
@


1.17
log
@introduce the ALTQ queue macros into sys/net files.
the new model removes direct references to the fields in ifp->if_snd,
and defines the following macros to manipulate ifp->if_snd.
  IFQ_ENQUEUE(ifq, m, pktattr, err)
  IFQ_DEQUEUE(ifq, m)
  IFQ_POLL(ifq, m)
  IFQ_PURGE(ifq)
  IFQ_IS_EMPTY(ifq)

the new model also enforces some rules regarding how to use these macros.
details are descrined in
http://www.csl.sony.co.jp/~kjc/software/altq-new-design.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.16 2001/06/23 21:32:26 fgsch Exp $	*/
a287 3
#ifdef ALTQ
void altq_etherclassify(struct ifaltq *, struct mbuf *, struct altq_pktattr *);
#endif /* ALTQ */
@


1.17.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.17 2001/06/27 06:07:47 kjc Exp $	*/
d43 8
a60 7
 * Ethernet address - 6 octets
 */
struct ether_addr {
	u_int8_t ether_addr_octet[ETHER_ADDR_LEN];
};

/*
a92 6
/*
 * Ethernet CRC32 polynomials (big- and little-endian verions).
 */
#define	ETHER_CRC_POLY_LE	0xedb88320
#define	ETHER_CRC_POLY_BE	0x04c11db6

d194 6
a199 6
void	arpwhohas(struct arpcom *, struct in_addr *);
void	arpintr(void);
int	arpresolve(struct arpcom *,
	    struct rtentry *, struct mbuf *, struct sockaddr *, u_char *);
void	arp_ifinit(struct arpcom *, struct ifaddr *);
void	arp_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
d201 2
a202 2
int	ether_addmulti(struct ifreq *, struct arpcom *);
int	ether_delmulti(struct ifreq *, struct arpcom *);
d275 16
a290 16
void arp_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
int arpresolve(struct arpcom *, struct rtentry *, struct mbuf *,
		    struct sockaddr *, u_char *);
void arpintr(void);
int arpioctl(u_long, caddr_t);
void arp_ifinit(struct arpcom *, struct ifaddr *);
void arprequest(struct ifnet *, u_int32_t *, u_int32_t *, u_int8_t *);
void revarpinput(struct mbuf *);
void in_revarpinput(struct mbuf *);
void revarprequest(struct ifnet *);
int revarpwhoarewe(struct ifnet *, struct in_addr *, struct in_addr *);
int revarpwhoami(struct in_addr *, struct ifnet *);
int db_show_arptab(void);

u_int32_t ether_crc32_le(const u_int8_t *, size_t);
u_int32_t ether_crc32_be(const u_int8_t *, size_t);
d294 5
a298 5
char *ether_ntoa(struct ether_addr *);
struct ether_addr *ether_aton(char *);
int ether_ntohost(char *, struct ether_addr *);
int ether_hostton(char *, struct ether_addr *);
int ether_line(char *, struct ether_addr *, char *);
@


1.17.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.17.4.1 2002/06/11 03:31:36 art Exp $	*/
d47 1
a47 1
#define ETHER_CRC_LEN	4	/* Ethernet CRC length			*/
d138 1
a138 1
 * to resolving internet addresses.  Field names used correspond to
d194 4
a197 4
extern u_int8_t etherbroadcastaddr[ETHER_ADDR_LEN];
extern u_int8_t ether_ipmulticast_min[ETHER_ADDR_LEN];
extern u_int8_t ether_ipmulticast_max[ETHER_ADDR_LEN];
extern struct ifqueue arpintrq;
a207 1
int	ether_multiaddr(struct sockaddr *, u_int8_t[], u_int8_t[]);
@


1.17.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 17
a85 1
#include <net/ethertypes.h>
@


1.16
log
@Put some constants together and calculate max/min mtu based on those;
jason@@ ok.
This should be moved to net, tho, it's not inet specific.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.15 2001/06/09 06:14:32 angelos Exp $	*/
d288 3
@


1.15
log
@Protect from multiple inclusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.14 2001/01/19 06:37:38 itojun Exp $	*/
d51 1
a51 1
 * Structure of a Ethernet header.
d53 6
a58 11
#define	ETHER_ADDR_LEN	6

/*
 * The number of bytes in the type field.
 */
#define ETHER_TYPE_LEN	2

/*
 * The number of bytes in the trailing CRC field.
 */
#define ETHER_CRC_LEN	4
a62 1
#define ETHER_HDR_LEN	(ETHER_ADDR_LEN*2+ETHER_TYPE_LEN)
d90 2
a91 2
#define	ETHERMTU	1500
#define	ETHERMIN	(60-14)
@


1.14
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.13 2000/12/28 23:56:47 mickey Exp $	*/
d39 3
d303 2
a304 1
#endif
@


1.13
log
@export arprequest() and make it use ifnet* as the 1st arg; tested; angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.12 2000/03/07 18:15:47 chris Exp $	*/
d202 1
a202 1
void	arp_rtrequest __P((int, struct rtentry *, struct sockaddr *));
d278 1
a278 1
void arp_rtrequest __P((int, struct rtentry *, struct sockaddr *));
@


1.12
log
@add ETHERTYPE_8021Q
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.11 2000/02/10 05:49:28 jason Exp $	*/
d284 1
@


1.11
log
@add PPPoE Discovery- and Session-Stage ETHERTYPEs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.10 1999/12/08 06:50:19 itojun Exp $	*/
d52 15
d77 1
d81 1
@


1.11.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a51 15
/*
 * The number of bytes in the type field.
 */
#define ETHER_TYPE_LEN	2

/*
 * The number of bytes in the trailing CRC field.
 */
#define ETHER_CRC_LEN	4

/*
 * The length of the combined header.
 */
#define ETHER_HDR_LEN	(ETHER_ADDR_LEN*2+ETHER_TYPE_LEN)

a61 1
#define	ETHERTYPE_8021Q		0x8100	/* IEEE 802.1Q VLAN tagging */
a64 1
#define	ETHERTYPE_LOOPBACK	0x9000	/* used to test interfaces */
@


1.11.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.14 2001/01/19 06:37:38 itojun Exp $	*/
d202 1
a202 1
void	arp_rtrequest __P((int, struct rtentry *, struct rt_addrinfo *));
d278 1
a278 1
void arp_rtrequest __P((int, struct rtentry *, struct rt_addrinfo *));
a283 1
void arprequest __P((struct ifnet *, u_int32_t *, u_int32_t *, u_int8_t *));
@


1.11.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.11.2.2 2001/05/14 22:40:07 niklas Exp $	*/
a38 3
#ifndef _NETINET_IF_ETHER_H_
#define _NETINET_IF_ETHER_H_

d48 1
a48 1
 * Some Ethernet constants.
d50 11
a60 6
#define	ETHER_ADDR_LEN	6	/* Ethernet address length		*/
#define ETHER_TYPE_LEN	2	/* Ethernet type field length		*/
#define ETHER_CRC_LEN	4	/* Ethernet CRC lenght			*/
#define ETHER_HDR_LEN	((ETHER_ADDR_LEN * 2) + ETHER_TYPE_LEN)
#define ETHER_MIN_LEN	64	/* Minimum frame length, CRC included	*/
#define ETHER_MAX_LEN	1518	/* Maximum frame length, CRC included	*/
d65 1
d93 2
a94 2
#define	ETHERMTU	(ETHER_MAX_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
#define	ETHERMIN	(ETHER_MIN_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
a290 3
#ifdef ALTQ
void altq_etherclassify(struct ifaltq *, struct mbuf *, struct altq_pktattr *);
#endif /* ALTQ */
d300 1
a300 2
#endif /* _KERNEL */
#endif /* _NETINET_IF_ETHER_H_ */
@


1.11.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d288 3
@


1.11.2.5
log
@Merge in -current from roughly a week ago
@
text
@d194 6
a199 6
void	arpwhohas(struct arpcom *, struct in_addr *);
void	arpintr(void);
int	arpresolve(struct arpcom *,
	    struct rtentry *, struct mbuf *, struct sockaddr *, u_char *);
void	arp_ifinit(struct arpcom *, struct ifaddr *);
void	arp_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
d201 2
a202 2
int	ether_addmulti(struct ifreq *, struct arpcom *);
int	ether_delmulti(struct ifreq *, struct arpcom *);
d275 13
a287 13
void arp_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
int arpresolve(struct arpcom *, struct rtentry *, struct mbuf *,
		    struct sockaddr *, u_char *);
void arpintr(void);
int arpioctl(u_long, caddr_t);
void arp_ifinit(struct arpcom *, struct ifaddr *);
void arprequest(struct ifnet *, u_int32_t *, u_int32_t *, u_int8_t *);
void revarpinput(struct mbuf *);
void in_revarpinput(struct mbuf *);
void revarprequest(struct ifnet *);
int revarpwhoarewe(struct ifnet *, struct in_addr *, struct in_addr *);
int revarpwhoami(struct in_addr *, struct ifnet *);
int db_show_arptab(void);
d291 5
a295 5
char *ether_ntoa(struct ether_addr *);
struct ether_addr *ether_aton(char *);
int ether_ntohost(char *, struct ether_addr *);
int ether_hostton(char *, struct ether_addr *);
int ether_line(char *, struct ether_addr *, char *);
@


1.11.2.6
log
@Sync the SMP branch with 3.3
@
text
@d43 8
d55 1
a55 1
#define ETHER_CRC_LEN	4	/* Ethernet CRC length			*/
a60 7
 * Ethernet address - 6 octets
 */
struct ether_addr {
	u_int8_t ether_addr_octet[ETHER_ADDR_LEN];
};

/*
a92 6
/*
 * Ethernet CRC32 polynomials (big- and little-endian verions).
 */
#define	ETHER_CRC_POLY_LE	0xedb88320
#define	ETHER_CRC_POLY_BE	0x04c11db6

d133 1
a133 1
 * to resolving internet addresses.  Field names used correspond to
d189 4
a192 4
extern u_int8_t etherbroadcastaddr[ETHER_ADDR_LEN];
extern u_int8_t ether_ipmulticast_min[ETHER_ADDR_LEN];
extern u_int8_t ether_ipmulticast_max[ETHER_ADDR_LEN];
extern struct ifqueue arpintrq;
a202 1
int	ether_multiaddr(struct sockaddr *, u_int8_t[], u_int8_t[]);
a287 3

u_int32_t ether_crc32_le(const u_int8_t *, size_t);
u_int32_t ether_crc32_be(const u_int8_t *, size_t);
@


1.11.2.7
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d69 17
a85 1
#include <net/ethertypes.h>
@


1.11.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.11.2.7 2003/05/16 00:29:44 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.2.9
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a46 11
#define	ETHER_MAX_LEN_JUMBO	9018	/* max jumbo frame len, including CRC */

#define	ETHER_VLAN_ENCAP_LEN	4	/* len of 802.1Q VLAN encapsulation */

/*
 * Mbuf adjust factor to force 32-bit alignment of IP header.
 * Drivers should do m_adj(m, ETHER_ALIGN) when setting up a
 * receive so the upper layers get the IP header properly aligned
 * past the 14-byte Ethernet header.
 */
#define	ETHER_ALIGN		2	/* driver adjust for IP hdr alignment */
d58 1
a70 1
#define	ETHERMTU_JUMBO	(ETHER_MAX_LEN_JUMBO - ETHER_HDR_LEN - ETHER_CRC_LEN)
@


1.10
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.9 1999/08/08 00:43:00 niklas Exp $	*/
d63 2
@


1.9
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.8 1999/08/02 22:51:16 deraadt Exp $	*/
d93 17
@


1.8
log
@Ethernet, not 10 Mb/s Ethernet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.7 1999/05/16 00:34:40 ho Exp $	*/
d239 2
@


1.7
log
@Add support for static ARP entries that cannot be overwritten.
Ordinary static ARPs that are overwritten will no longer still be static.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.6 1999/01/07 09:11:52 deraadt Exp $	*/
d48 1
a48 1
 * Structure of a 10Mb/s Ethernet header.
@


1.6
log
@ipv6 ethertype
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.5 1996/07/27 11:06:42 deraadt Exp $	*/
d151 3
a153 2
#define	RTF_USETRAILERS	RTF_PROTO1	/* use trailers */
#define	RTF_ANNOUNCE	RTF_PROTO2	/* announce new arp entry */
@


1.5
log
@pad for machines that do not pad structs out
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.4 1996/07/03 08:09:45 deraadt Exp $	*/
d62 1
@


1.4
log
@prototype ethers(3) functions (inside !_KERNEL), pointed out in
netbsd pr#2471, jhawk@@mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ether.h,v 1.3 1996/05/22 11:48:45 deraadt Exp $	*/
d123 1
@


1.3
log
@When sending an ARP request, use the interface address for the route, rather
than the first address assigned.  This gives slightly different behaviour in
the presence of aliases.  From Bill Fenner, via Pete Bentley.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d249 8
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d2 1
a2 1
/*	$NetBSD: if_ether.h,v 1.21 1996/02/13 23:41:17 christos Exp $	*/
a122 1
	struct	 in_addr ac_ipaddr;		/* copy of ip address- XXX */
a237 1
void arpwhohas __P((struct arpcom *, struct in_addr *));
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: if_ether.h,v 1.20 1995/06/12 00:47:27 mycroft Exp $	*/
d235 18
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
