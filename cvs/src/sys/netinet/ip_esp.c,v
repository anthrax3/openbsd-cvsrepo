head	1.149;
access;
symbols
	OPENBSD_6_1:1.146.0.4
	OPENBSD_6_1_BASE:1.146
	OPENBSD_6_0:1.137.0.4
	OPENBSD_6_0_BASE:1.137
	OPENBSD_5_9:1.136.0.2
	OPENBSD_5_9_BASE:1.136
	OPENBSD_5_8:1.134.0.4
	OPENBSD_5_8_BASE:1.134
	OPENBSD_5_7:1.129.0.2
	OPENBSD_5_7_BASE:1.129
	OPENBSD_5_6:1.126.0.4
	OPENBSD_5_6_BASE:1.126
	OPENBSD_5_5:1.123.0.4
	OPENBSD_5_5_BASE:1.123
	OPENBSD_5_4:1.122.0.2
	OPENBSD_5_4_BASE:1.122
	OPENBSD_5_3:1.121.0.2
	OPENBSD_5_3_BASE:1.121
	OPENBSD_5_2:1.117.0.2
	OPENBSD_5_2_BASE:1.117
	OPENBSD_5_1_BASE:1.116
	OPENBSD_5_1:1.116.0.6
	OPENBSD_5_0:1.116.0.4
	OPENBSD_5_0_BASE:1.116
	OPENBSD_4_9:1.116.0.2
	OPENBSD_4_9_BASE:1.116
	OPENBSD_4_8:1.111.0.2
	OPENBSD_4_8_BASE:1.111
	OPENBSD_4_7:1.106.0.2
	OPENBSD_4_7_BASE:1.106
	OPENBSD_4_6:1.105.0.8
	OPENBSD_4_6_BASE:1.105
	OPENBSD_4_5:1.105.0.4
	OPENBSD_4_5_BASE:1.105
	OPENBSD_4_4:1.105.0.2
	OPENBSD_4_4_BASE:1.105
	OPENBSD_4_3:1.104.0.2
	OPENBSD_4_3_BASE:1.104
	OPENBSD_4_2:1.100.0.4
	OPENBSD_4_2_BASE:1.100
	OPENBSD_4_1:1.100.0.2
	OPENBSD_4_1_BASE:1.100
	OPENBSD_4_0:1.98.0.2
	OPENBSD_4_0_BASE:1.98
	OPENBSD_3_9:1.96.0.2
	OPENBSD_3_9_BASE:1.96
	OPENBSD_3_8:1.95.0.2
	OPENBSD_3_8_BASE:1.95
	OPENBSD_3_7:1.88.0.6
	OPENBSD_3_7_BASE:1.88
	OPENBSD_3_6:1.88.0.4
	OPENBSD_3_6_BASE:1.88
	SMP_SYNC_A:1.88
	SMP_SYNC_B:1.88
	OPENBSD_3_5:1.88.0.2
	OPENBSD_3_5_BASE:1.88
	OPENBSD_3_4:1.87.0.2
	OPENBSD_3_4_BASE:1.87
	UBC_SYNC_A:1.83
	OPENBSD_3_3:1.80.0.2
	OPENBSD_3_3_BASE:1.80
	OPENBSD_3_2:1.75.0.2
	OPENBSD_3_2_BASE:1.75
	OPENBSD_3_1:1.69.0.6
	OPENBSD_3_1_BASE:1.69
	UBC_SYNC_B:1.75
	UBC:1.69.0.4
	UBC_BASE:1.69
	OPENBSD_3_0:1.69.0.2
	OPENBSD_3_0_BASE:1.69
	OPENBSD_2_9_BASE:1.56
	OPENBSD_2_9:1.56.0.2
	OPENBSD_2_8:1.50.0.2
	OPENBSD_2_8_BASE:1.50
	OPENBSD_2_7:1.41.0.2
	OPENBSD_2_7_BASE:1.41
	SMP:1.32.0.2
	SMP_BASE:1.32
	kame_19991208:1.28
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.149
date	2017.05.30.16.07.22;	author deraadt;	state Exp;
branches;
next	1.148;
commitid	SSqL97R1n49kij1r;

1.148
date	2017.05.02.11.44.32;	author mikeb;	state Exp;
branches;
next	1.147;
commitid	wirszMgsR4O7G8R6;

1.147
date	2017.04.06.17.36.18;	author dhill;	state Exp;
branches;
next	1.146;
commitid	sUyk93YAYdV51Zxx;

1.146
date	2017.02.07.18.18.16;	author bluhm;	state Exp;
branches;
next	1.145;
commitid	d6u53XQpFaxImDPZ;

1.145
date	2017.02.07.17.25.46;	author patrick;	state Exp;
branches;
next	1.144;
commitid	dMJlqKWYCJoMV7JN;

1.144
date	2017.02.07.15.10.48;	author bluhm;	state Exp;
branches;
next	1.143;
commitid	7vg8X7gfUc0w7Qc8;

1.143
date	2017.01.09.17.10.03;	author mpi;	state Exp;
branches;
next	1.142;
commitid	6FXHyRkiplRcBK8y;

1.142
date	2016.12.24.11.17.35;	author mpi;	state Exp;
branches;
next	1.141;
commitid	iyPxPn1zFcxxUjDC;

1.141
date	2016.09.19.18.09.22;	author tedu;	state Exp;
branches;
next	1.140;
commitid	dVNJNNJZJ5eqAvDA;

1.140
date	2016.09.13.19.56.55;	author markus;	state Exp;
branches;
next	1.139;
commitid	MhzOL3PcQJk4ZhiI;

1.139
date	2016.08.18.06.01.10;	author dlg;	state Exp;
branches;
next	1.138;
commitid	sj9BHgtTdUyjSwjG;

1.138
date	2016.08.15.11.35.25;	author dlg;	state Exp;
branches;
next	1.137;
commitid	CgCan1eMToI9G3qa;

1.137
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.136;
commitid	Z6e4eqr6FuYFPnlL;

1.136
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.135;
commitid	CLwtYUTkBZ3FXV1w;

1.135
date	2015.11.03.01.50.36;	author mikeb;	state Exp;
branches;
next	1.134;
commitid	HPo8Yd5Adcuitvw4;

1.134
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.133;
commitid	ncpqEGjDtSFuLAgn;

1.133
date	2015.06.15.12.59.37;	author mikeb;	state Exp;
branches;
next	1.132;
commitid	vzPYnuEghUD7XZKx;

1.132
date	2015.06.15.12.37.37;	author mikeb;	state Exp;
branches;
next	1.131;
commitid	1m30gIbDdCTxtmn3;

1.131
date	2015.04.17.11.04.01;	author mikeb;	state Exp;
branches;
next	1.130;
commitid	6glXvFR7NxzCcdRd;

1.130
date	2015.04.14.14.20.01;	author mikeb;	state Exp;
branches;
next	1.129;
commitid	70u0dWUlToMcLCnj;

1.129
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.128;
commitid	zhW8jJrfVCoAthrR;

1.128
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.127;
commitid	t9FBKDfc4VDxpEy2;

1.127
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.126;
commitid	Z1vcFtHO8wRH0yRt;

1.126
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.125;
commitid	DQakU8LLWV6Iwx84;

1.125
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.124;
commitid	B4dZSbxas1X1IpXI;

1.124
date	2014.07.09.09.30.49;	author henning;	state Exp;
branches;
next	1.123;
commitid	Nnxg8ONtI4Ep9pUb;

1.123
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.122;

1.122
date	2013.04.11.12.06.25;	author mpi;	state Exp;
branches;
next	1.121;

1.121
date	2013.02.14.16.22.34;	author mikeb;	state Exp;
branches;
next	1.120;

1.120
date	2012.10.18.10.49.48;	author markus;	state Exp;
branches;
next	1.119;

1.119
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.118;

1.118
date	2012.09.18.09.24.45;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2012.06.29.14.48.04;	author mikeb;	state Exp;
branches;
next	1.116;

1.116
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2010.12.21.14.45.57;	author markus;	state Exp;
branches;
next	1.114;

1.114
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.113;

1.113
date	2010.09.23.16.33.48;	author mikeb;	state Exp;
branches;
next	1.112;

1.112
date	2010.09.22.13.40.05;	author mikeb;	state Exp;
branches;
next	1.111;

1.111
date	2010.07.20.15.36.03;	author matthew;	state Exp;
branches;
next	1.110;

1.110
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.109;

1.109
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.108;

1.108
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.107;

1.107
date	2010.06.29.21.28.37;	author reyk;	state Exp;
branches;
next	1.106;

1.106
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2008.06.09.07.07.17;	author djm;	state Exp;
branches;
next	1.104;

1.104
date	2007.11.19.11.03.21;	author mpf;	state Exp;
branches;
next	1.103;

1.103
date	2007.10.17.20.01.26;	author hshoexer;	state Exp;
branches;
next	1.102;

1.102
date	2007.10.06.02.18.38;	author krw;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.100;

1.100
date	2006.12.15.09.32.30;	author otto;	state Exp;
branches;
next	1.99;

1.99
date	2006.09.21.11.10.52;	author otto;	state Exp;
branches;
next	1.98;

1.98
date	2006.05.28.02.04.15;	author mcbride;	state Exp;
branches;
next	1.97;

1.97
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.96;

1.96
date	2005.12.20.13.36.28;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2005.08.05.12.16.13;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2005.08.02.10.51.47;	author djm;	state Exp;
branches;
next	1.93;

1.93
date	2005.07.31.03.52.19;	author pascoe;	state Exp;
branches;
next	1.92;

1.92
date	2005.05.28.15.10.07;	author ho;	state Exp;
branches;
next	1.91;

1.91
date	2005.05.27.18.23.18;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2005.05.25.05.47.53;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2005.05.10.13.42.11;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.87;

1.87
date	2003.08.14.19.00.12;	author jason;	state Exp;
branches;
next	1.86;

1.86
date	2003.07.24.09.59.02;	author itojun;	state Exp;
branches;
next	1.85;

1.85
date	2003.07.24.08.03.20;	author itojun;	state Exp;
branches;
next	1.84;

1.84
date	2003.07.09.18.21.16;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.82;

1.82
date	2003.04.02.20.09.26;	author millert;	state Exp;
branches;
next	1.81;

1.81
date	2003.03.31.20.52.06;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2003.02.28.21.42.56;	author jason;	state Exp;
branches;
next	1.79;

1.79
date	2003.02.21.20.50.58;	author tedu;	state Exp;
branches;
next	1.78;

1.78
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.77;

1.77
date	2003.02.01.14.11.40;	author dhartmei;	state Exp;
branches;
next	1.76;

1.76
date	2002.11.07.15.16.39;	author ho;	state Exp;
branches;
next	1.75;

1.75
date	2002.07.30.19.09.36;	author jason;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2002.07.05.23.20.53;	author angelos;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.18.23.03.26;	author angelos;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.18.22.48.16;	author angelos;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.18.19.25.48;	author angelos;	state Exp;
branches;
next	1.70;

1.70
date	2002.05.31.02.22.21;	author angelos;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.26.06.18.59;	author angelos;	state Exp;
branches
	1.69.4.1
	1.69.6.1;
next	1.68;

1.68
date	2001.06.25.05.11.58;	author angelos;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.23.18.30.38;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.13.13.42.02;	author angelos;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.08.03.13.14;	author angelos;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.05.11.10.10;	author angelos;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.01.00.09.23;	author angelos;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.30.12.29.04;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	2001.05.30.12.13.58;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2001.05.27.03.48.34;	author angelos;	state Exp;
branches;
next	1.59;

1.59
date	2001.05.17.18.41.47;	author provos;	state Exp;
branches;
next	1.58;

1.58
date	2001.05.13.15.39.27;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2001.05.12.18.09.02;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.14.00.30.59;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.28.20.03.03;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2001.03.23.04.27.33;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.15.06.30.59;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2000.11.17.04.15.42;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2000.10.09.22.20.40;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2000.09.19.03.20.58;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2000.06.18.08.23.48;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2000.06.18.03.07.25;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2000.06.15.00.30.12;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2000.06.14.04.42.10;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2000.06.06.04.49.29;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2000.06.01.05.40.41;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2000.05.15.03.36.34;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2000.04.25.02.53.45;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2000.04.06.16.08.22;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2000.03.30.06.17.56;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2000.03.29.07.19.50;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2000.03.29.07.09.57;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2000.03.28.07.04.02;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.25.04.57.51;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2000.03.21.21.00.09;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2000.03.17.10.25.22;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2000.02.07.06.09.09;	author itojun;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.01.27.08.09.09;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	99.12.09.10.13.46;	author angelos;	state dead;
branches;
next	1.29;

1.29
date	99.12.09.03.46.03;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	99.12.07.08.58.00;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	99.12.06.07.14.35;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	99.11.04.11.23.43;	author ho;	state Exp;
branches;
next	1.25;

1.25
date	99.10.29.05.21.45;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	99.07.05.20.17.06;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.05.16.21.48.33;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.05.14.23.36.17;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.04.11.19.41.37;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.04.09.22.27.53;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.03.27.21.04.19;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	99.02.24.23.45.49;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	99.02.24.22.33.01;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	98.06.10.23.57.14;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	98.05.24.22.40.12;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	98.05.18.21.10.40;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.11.04.09.11.09;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	97.10.02.02.31.04;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.09.28.22.57.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.07.27.23.30.35;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.07.18.18.09.54;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.07.11.23.37.56;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.07.01.22.12.45;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.06.25.07.53.24;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.06.21.00.09.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.20.05.41.49;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.02.26.20.53.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.02.24.14.06.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.07.53;	author deraadt;	state Exp;
branches;
next	;

1.32.2.1
date	2000.03.24.09.09.36;	author niklas;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2001.05.14.22.40.09;	author niklas;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2001.07.04.10.54.40;	author niklas;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.32.2.5;

1.32.2.5
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.32.2.6;

1.32.2.6
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.69.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.69.4.2;

1.69.4.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.69.4.3;

1.69.4.3
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;

1.69.6.1
date	2003.01.22.23.49.42;	author miod;	state Exp;
branches;
next	;

1.75.2.1
date	2002.11.08.00.08.27;	author jason;	state Exp;
branches;
next	;


desc
@@


1.149
log
@add sizes to free() calls
@
text
@/*	$OpenBSD: ip_esp.c,v 1.148 2017/05/02 11:44:32 mikeb Exp $ */
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 * Copyright (c) 2001 Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include "pfsync.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif /* INET6 */

#include <netinet/ip_ipsp.h>
#include <netinet/ip_esp.h>
#include <net/pfkeyv2.h>
#include <net/if_enc.h>

#if NPFSYNC > 0
#include <net/pfvar.h>
#include <net/if_pfsync.h>
#endif /* NPFSYNC > 0 */

#include <crypto/cryptodev.h>
#include <crypto/xform.h>

#include "bpfilter.h"

void esp_output_cb(struct cryptop *);
void esp_input_cb(struct cryptop *);

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

struct espstat espstat;

/*
 * esp_attach() is called from the transformation initialization code.
 */
int
esp_attach(void)
{
	return 0;
}

/*
 * esp_init() is called when an SPI is being set up.
 */
int
esp_init(struct tdb *tdbp, struct xformsw *xsp, struct ipsecinit *ii)
{
	struct enc_xform *txform = NULL;
	struct auth_hash *thash = NULL;
	struct cryptoini cria, crie, crin;

	if (!ii->ii_encalg && !ii->ii_authalg) {
		DPRINTF(("esp_init(): neither authentication nor encryption "
		    "algorithm given"));
		return EINVAL;
	}

	if (ii->ii_encalg) {
		switch (ii->ii_encalg) {
		case SADB_EALG_NULL:
			txform = &enc_xform_null;
			break;

		case SADB_EALG_3DESCBC:
			txform = &enc_xform_3des;
			break;

		case SADB_X_EALG_AES:
			txform = &enc_xform_aes;
			break;

		case SADB_X_EALG_AESCTR:
			txform = &enc_xform_aes_ctr;
			break;

		case SADB_X_EALG_AESGCM16:
			txform = &enc_xform_aes_gcm;
			break;

		case SADB_X_EALG_AESGMAC:
			txform = &enc_xform_aes_gmac;
			break;

		case SADB_X_EALG_CHACHA20POLY1305:
			txform = &enc_xform_chacha20_poly1305;
			break;

		case SADB_X_EALG_BLF:
			txform = &enc_xform_blf;
			break;

		case SADB_X_EALG_CAST:
			txform = &enc_xform_cast5;
			break;

		default:
			DPRINTF(("esp_init(): unsupported encryption "
			    "algorithm %d specified\n", ii->ii_encalg));
			return EINVAL;
		}

		if (ii->ii_enckeylen < txform->minkey) {
			DPRINTF(("esp_init(): keylength %d too small "
			    "(min length is %d) for algorithm %s\n",
			    ii->ii_enckeylen, txform->minkey, txform->name));
			return EINVAL;
		}

		if (ii->ii_enckeylen > txform->maxkey) {
			DPRINTF(("esp_init(): keylength %d too large "
			    "(max length is %d) for algorithm %s\n",
			    ii->ii_enckeylen, txform->maxkey, txform->name));
			return EINVAL;
		}

		if (ii->ii_encalg == SADB_X_EALG_AESGCM16 ||
		    ii->ii_encalg == SADB_X_EALG_AESGMAC) {
			switch (ii->ii_enckeylen) {
			case 20:
				ii->ii_authalg = SADB_X_AALG_AES128GMAC;
				break;
			case 28:
				ii->ii_authalg = SADB_X_AALG_AES192GMAC;
				break;
			case 36:
				ii->ii_authalg = SADB_X_AALG_AES256GMAC;
				break;
			}
			ii->ii_authkeylen = ii->ii_enckeylen;
			ii->ii_authkey = ii->ii_enckey;
		} else if (ii->ii_encalg == SADB_X_EALG_CHACHA20POLY1305) {
			ii->ii_authalg = SADB_X_AALG_CHACHA20POLY1305;
			ii->ii_authkeylen = ii->ii_enckeylen;
			ii->ii_authkey = ii->ii_enckey;
		}

		tdbp->tdb_encalgxform = txform;

		DPRINTF(("esp_init(): initialized TDB with enc algorithm %s\n",
		    txform->name));

		tdbp->tdb_ivlen = txform->ivsize;
	}

	if (ii->ii_authalg) {
		switch (ii->ii_authalg) {
		case SADB_AALG_MD5HMAC:
			thash = &auth_hash_hmac_md5_96;
			break;

		case SADB_AALG_SHA1HMAC:
			thash = &auth_hash_hmac_sha1_96;
			break;

		case SADB_X_AALG_RIPEMD160HMAC:
			thash = &auth_hash_hmac_ripemd_160_96;
			break;

		case SADB_X_AALG_SHA2_256:
			thash = &auth_hash_hmac_sha2_256_128;
			break;

		case SADB_X_AALG_SHA2_384:
			thash = &auth_hash_hmac_sha2_384_192;
			break;

		case SADB_X_AALG_SHA2_512:
			thash = &auth_hash_hmac_sha2_512_256;
			break;

		case SADB_X_AALG_AES128GMAC:
			thash = &auth_hash_gmac_aes_128;
			break;

		case SADB_X_AALG_AES192GMAC:
			thash = &auth_hash_gmac_aes_192;
			break;

		case SADB_X_AALG_AES256GMAC:
			thash = &auth_hash_gmac_aes_256;
			break;

		case SADB_X_AALG_CHACHA20POLY1305:
			thash = &auth_hash_chacha20_poly1305;
			break;

		default:
			DPRINTF(("esp_init(): unsupported authentication "
			    "algorithm %d specified\n", ii->ii_authalg));
			return EINVAL;
		}

		if (ii->ii_authkeylen != thash->keysize) {
			DPRINTF(("esp_init(): keylength %d doesn't match "
			    "algorithm %s keysize (%d)\n", ii->ii_authkeylen,
			    thash->name, thash->keysize));
			return EINVAL;
		}

		tdbp->tdb_authalgxform = thash;

		DPRINTF(("esp_init(): initialized TDB with hash algorithm %s\n",
		    thash->name));
	}

	tdbp->tdb_xform = xsp;
	tdbp->tdb_rpl = AH_HMAC_INITIAL_RPL;

	/* Initialize crypto session */
	if (tdbp->tdb_encalgxform) {
		/* Save the raw keys */
		tdbp->tdb_emxkeylen = ii->ii_enckeylen;
		tdbp->tdb_emxkey = malloc(tdbp->tdb_emxkeylen, M_XDATA,
		    M_WAITOK);
		memcpy(tdbp->tdb_emxkey, ii->ii_enckey, tdbp->tdb_emxkeylen);

		memset(&crie, 0, sizeof(crie));

		crie.cri_alg = tdbp->tdb_encalgxform->type;

		if (tdbp->tdb_authalgxform)
			crie.cri_next = &cria;
		else
			crie.cri_next = NULL;

		crie.cri_klen = ii->ii_enckeylen * 8;
		crie.cri_key = ii->ii_enckey;
		/* XXX Rounds ? */
	}

	if (tdbp->tdb_authalgxform) {
		/* Save the raw keys */
		tdbp->tdb_amxkeylen = ii->ii_authkeylen;
		tdbp->tdb_amxkey = malloc(tdbp->tdb_amxkeylen, M_XDATA,
		    M_WAITOK);
		memcpy(tdbp->tdb_amxkey, ii->ii_authkey, tdbp->tdb_amxkeylen);

		memset(&cria, 0, sizeof(cria));

		cria.cri_alg = tdbp->tdb_authalgxform->type;

		if ((tdbp->tdb_wnd > 0) && (tdbp->tdb_flags & TDBF_ESN)) {
			memset(&crin, 0, sizeof(crin));
			crin.cri_alg = CRYPTO_ESN;
			cria.cri_next = &crin;
		}

		cria.cri_klen = ii->ii_authkeylen * 8;
		cria.cri_key = ii->ii_authkey;
	}

	return crypto_newsession(&tdbp->tdb_cryptoid,
	    (tdbp->tdb_encalgxform ? &crie : &cria), 0);
}

/*
 * Paranoia.
 */
int
esp_zeroize(struct tdb *tdbp)
{
	int err;

	if (tdbp->tdb_amxkey) {
		explicit_bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
		free(tdbp->tdb_amxkey, M_XDATA, tdbp->tdb_amxkeylen);
		tdbp->tdb_amxkey = NULL;
	}

	if (tdbp->tdb_emxkey) {
		explicit_bzero(tdbp->tdb_emxkey, tdbp->tdb_emxkeylen);
		free(tdbp->tdb_emxkey, M_XDATA, tdbp->tdb_emxkeylen);
		tdbp->tdb_emxkey = NULL;
	}

	err = crypto_freesession(tdbp->tdb_cryptoid);
	tdbp->tdb_cryptoid = 0;
	return err;
}

#define MAXBUFSIZ (AH_ALEN_MAX > ESP_MAX_IVS ? AH_ALEN_MAX : ESP_MAX_IVS)

/*
 * ESP input processing, called (eventually) through the protocol switch.
 */
int
esp_input(struct mbuf *m, struct tdb *tdb, int skip, int protoff)
{
	struct auth_hash *esph = (struct auth_hash *) tdb->tdb_authalgxform;
	struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
	struct cryptodesc *crde = NULL, *crda = NULL;
	struct cryptop *crp;
	struct tdb_crypto *tc;
	int plen, alen, hlen;
	u_int32_t btsx, esn;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	/* Determine the ESP header length */
	hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; /* "new" ESP */
	alen = esph ? esph->authsize : 0;
	plen = m->m_pkthdr.len - (skip + hlen + alen);
	if (plen <= 0) {
		DPRINTF(("esp_input: invalid payload length\n"));
		espstat.esps_badilen++;
		m_freem(m);
		return EINVAL;
	}

	if (espx) {
		/*
		 * Verify payload length is multiple of encryption algorithm
		 * block size.
		 */
		if (plen & (espx->blocksize - 1)) {
			DPRINTF(("esp_input(): payload of %d octets "
			    "not a multiple of %d octets, SA %s/%08x\n",
			    plen, espx->blocksize, ipsp_address(&tdb->tdb_dst,
			    buf, sizeof(buf)), ntohl(tdb->tdb_spi)));
			espstat.esps_badilen++;
			m_freem(m);
			return EINVAL;
		}
	}

	/* Replay window checking, if appropriate -- no value commitment. */
	if (tdb->tdb_wnd > 0) {
		m_copydata(m, skip + sizeof(u_int32_t), sizeof(u_int32_t),
		    (unsigned char *) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow(tdb, btsx, &esn, 0)) {
		case 0: /* All's well */
			break;
		case 1:
			m_freem(m);
			DPRINTF(("esp_input(): replay counter wrapped"
			    " for SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			espstat.esps_wrap++;
			return EACCES;
		case 2:
			m_freem(m);
			DPRINTF(("esp_input(): old packet received"
			    " in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			return EACCES;
		case 3:
			m_freem(m);
			DPRINTF(("esp_input(): duplicate packet received"
			    " in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			return EACCES;
		default:
			m_freem(m);
			DPRINTF(("esp_input(): bogus value from"
			    " checkreplaywindow() in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			return EACCES;
		}
	}

	/* Update the counters */
	tdb->tdb_cur_bytes += m->m_pkthdr.len - skip - hlen - alen;
	espstat.esps_ibytes += m->m_pkthdr.len - skip - hlen - alen;

	/* Hard expiration */
	if ((tdb->tdb_flags & TDBF_BYTES) &&
	    (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))	{
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
		m_freem(m);
		return ENXIO;
	}

	/* Notify on soft expiration */
	if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	    (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES;       /* Turn off checking */
	}

	/* Get crypto descriptors */
	crp = crypto_getreq(esph && espx ? 2 : 1);
	if (crp == NULL) {
		m_freem(m);
		DPRINTF(("esp_input(): failed to acquire crypto descriptors\n"));
		espstat.esps_crypto++;
		return ENOBUFS;
	}

	/* Get IPsec-specific opaque pointer */
	if (esph == NULL)
		tc = malloc(sizeof(*tc), M_XDATA, M_NOWAIT | M_ZERO);
	else
		tc = malloc(sizeof(*tc) + alen, M_XDATA, M_NOWAIT | M_ZERO);
	if (tc == NULL)	{
		m_freem(m);
		crypto_freereq(crp);
		DPRINTF(("esp_input(): failed to allocate tdb_crypto\n"));
		espstat.esps_crypto++;
		return ENOBUFS;
	}

	if (esph) {
		crda = &crp->crp_desc[0];
		crde = &crp->crp_desc[1];

		/* Authentication descriptor */
		crda->crd_skip = skip;
		crda->crd_inject = m->m_pkthdr.len - alen;

		crda->crd_alg = esph->type;
		crda->crd_key = tdb->tdb_amxkey;
		crda->crd_klen = tdb->tdb_amxkeylen * 8;

		if ((tdb->tdb_wnd > 0) && (tdb->tdb_flags & TDBF_ESN)) {
			esn = htonl(esn);
			memcpy(crda->crd_esn, &esn, 4);
			crda->crd_flags |= CRD_F_ESN;
		}

		if (espx &&
		    (espx->type == CRYPTO_AES_GCM_16 ||
		     espx->type == CRYPTO_CHACHA20_POLY1305))
			crda->crd_len = hlen - tdb->tdb_ivlen;
		else
			crda->crd_len = m->m_pkthdr.len - (skip + alen);

		/* Copy the authenticator */
		m_copydata(m, m->m_pkthdr.len - alen, alen, (caddr_t)(tc + 1));
	} else
		crde = &crp->crp_desc[0];

	/* Crypto operation descriptor */
	crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t)m;
	crp->crp_callback = esp_input_cb;
	crp->crp_sid = tdb->tdb_cryptoid;
	crp->crp_opaque = (caddr_t)tc;

	/* These are passed as-is to the callback */
	tc->tc_skip = skip;
	tc->tc_protoff = protoff;
	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = tdb->tdb_sproto;
	tc->tc_rdomain = tdb->tdb_rdomain;
	tc->tc_dst = tdb->tdb_dst;

	/* Decryption descriptor */
	if (espx) {
		crde->crd_skip = skip + hlen;
		crde->crd_inject = skip + hlen - tdb->tdb_ivlen;
		crde->crd_alg = espx->type;
		crde->crd_key = tdb->tdb_emxkey;
		crde->crd_klen = tdb->tdb_emxkeylen * 8;
		/* XXX Rounds ? */

		if (crde->crd_alg == CRYPTO_AES_GMAC)
			crde->crd_len = 0;
		else
			crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
	}

	return crypto_dispatch(crp);
}

/*
 * ESP input callback, called directly by the crypto driver.
 */
void
esp_input_cb(struct cryptop *crp)
{
	u_int8_t lastthree[3], aalg[AH_HMAC_MAX_HASHLEN];
	int s, hlen, roff, skip, protoff;
	struct mbuf *m1, *mo, *m;
	struct auth_hash *esph;
	struct tdb_crypto *tc;
	struct tdb *tdb;
	u_int32_t btsx, esn;
	caddr_t ptr;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	tc = (struct tdb_crypto *) crp->crp_opaque;
	skip = tc->tc_skip;
	protoff = tc->tc_protoff;

	m = (struct mbuf *) crp->crp_buf;
	if (m == NULL) {
		/* Shouldn't happen... */
		free(tc, M_XDATA, 0);
		crypto_freereq(crp);
		espstat.esps_crypto++;
		DPRINTF(("esp_input_cb(): bogus returned buffer from crypto\n"));
		return;
	}

	NET_LOCK(s);

	tdb = gettdb(tc->tc_rdomain, tc->tc_spi, &tc->tc_dst, tc->tc_proto);
	if (tdb == NULL) {
		free(tc, M_XDATA, 0);
		espstat.esps_notdb++;
		DPRINTF(("esp_input_cb(): TDB is expired while in crypto"));
		goto baddone;
	}

	esph = (struct auth_hash *) tdb->tdb_authalgxform;

	/* Check for crypto errors */
	if (crp->crp_etype) {
		if (crp->crp_etype == EAGAIN) {
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
			NET_UNLOCK(s);
			crypto_dispatch(crp);
			return;
		}
		free(tc, M_XDATA, 0);
		espstat.esps_noxform++;
		DPRINTF(("esp_input_cb(): crypto error %d\n", crp->crp_etype));
		goto baddone;
	}

	/* If authentication was performed, check now. */
	if (esph != NULL) {
		/* Copy the authenticator from the packet */
		m_copydata(m, m->m_pkthdr.len - esph->authsize,
		    esph->authsize, aalg);

		ptr = (caddr_t) (tc + 1);

		/* Verify authenticator */
		if (timingsafe_bcmp(ptr, aalg, esph->authsize)) {
			free(tc, M_XDATA, 0);
			DPRINTF(("esp_input_cb(): authentication "
			    "failed for packet in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf,
				sizeof(buf)), ntohl(tdb->tdb_spi)));
			espstat.esps_badauth++;
			goto baddone;
		}

		/* Remove trailing authenticator */
		m_adj(m, -(esph->authsize));
	}
	free(tc, M_XDATA, 0);

	/* Replay window checking, if appropriate */
	if (tdb->tdb_wnd > 0) {
		m_copydata(m, skip + sizeof(u_int32_t), sizeof(u_int32_t),
		    (unsigned char *) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow(tdb, btsx, &esn, 1)) {
		case 0: /* All's well */
#if NPFSYNC > 0
			pfsync_update_tdb(tdb,0);
#endif
			break;

		case 1:
			DPRINTF(("esp_input_cb(): replay counter wrapped"
			    " for SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			espstat.esps_wrap++;
			goto baddone;
		case 2:
			DPRINTF(("esp_input_cb(): old packet received"
			    " in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			goto baddone;
		case 3:
			DPRINTF(("esp_input_cb(): duplicate packet received"
			    " in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			goto baddone;
		default:
			DPRINTF(("esp_input_cb(): bogus value from"
			    " checkreplaywindow() in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			goto baddone;
		}
	}

	/* Release the crypto descriptors */
	crypto_freereq(crp);

	/* Determine the ESP header length */
	hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen;

	/* Find beginning of ESP header */
	m1 = m_getptr(m, skip, &roff);
	if (m1 == NULL)	{
		espstat.esps_hdrops++;
		NET_UNLOCK(s);
		DPRINTF(("esp_input_cb(): bad mbuf chain, SA %s/%08x\n",
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		m_freem(m);
		return;
	}

	/* Remove the ESP header and IV from the mbuf. */
	if (roff == 0) {
		/* The ESP header was conveniently at the beginning of the mbuf */
		m_adj(m1, hlen);
		if (!(m1->m_flags & M_PKTHDR))
			m->m_pkthdr.len -= hlen;
	} else if (roff + hlen >= m1->m_len) {
		/*
		 * Part or all of the ESP header is at the end of this mbuf, so
		 * first let's remove the remainder of the ESP header from the
		 * beginning of the remainder of the mbuf chain, if any.
		 */
		if (roff + hlen > m1->m_len) {
			/* Adjust the next mbuf by the remainder */
			m_adj(m1->m_next, roff + hlen - m1->m_len);

			/* The second mbuf is guaranteed not to have a pkthdr */
			m->m_pkthdr.len -= (roff + hlen - m1->m_len);
		}

		/* Now, let's unlink the mbuf chain for a second...*/
		mo = m1->m_next;
		m1->m_next = NULL;

		/* ...and trim the end of the first part of the chain...sick */
		m_adj(m1, -(m1->m_len - roff));
		if (!(m1->m_flags & M_PKTHDR))
			m->m_pkthdr.len -= (m1->m_len - roff);

		/* Finally, let's relink */
		m1->m_next = mo;
	} else {
		/*
		 * The ESP header lies in the "middle" of the mbuf...do an
		 * overlapping copy of the remainder of the mbuf over the ESP
		 * header.
		 */
		memmove(mtod(m1, u_char *) + roff, 
		    mtod(m1, u_char *) + roff + hlen,
		    m1->m_len - (roff + hlen));
		m1->m_len -= hlen;
		m->m_pkthdr.len -= hlen;
	}

	/* Save the last three bytes of decrypted data */
	m_copydata(m, m->m_pkthdr.len - 3, 3, lastthree);

	/* Verify pad length */
	if (lastthree[1] + 2 > m->m_pkthdr.len - skip) {
		espstat.esps_badilen++;
		NET_UNLOCK(s);
		DPRINTF(("esp_input_cb(): invalid padding length %d for "
		    "packet in SA %s/%08x\n", lastthree[1],
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		m_freem(m);
		return;
	}

	/* Verify correct decryption by checking the last padding bytes */
	if ((lastthree[1] != lastthree[0]) && (lastthree[1] != 0)) {
		espstat.esps_badenc++;
		NET_UNLOCK(s);
		DPRINTF(("esp_input(): decryption failed for packet in "
		    "SA %s/%08x\n", ipsp_address(&tdb->tdb_dst, buf,
		    sizeof(buf)), ntohl(tdb->tdb_spi)));
		m_freem(m);
		return;
	}

	/* Trim the mbuf chain to remove the trailing authenticator and padding */
	m_adj(m, -(lastthree[1] + 2));

	/* Restore the Next Protocol field */
	m_copyback(m, protoff, sizeof(u_int8_t), lastthree + 2, M_NOWAIT);

	/* Back to generic IPsec input processing */
	ipsec_common_input_cb(m, tdb, skip, protoff);
	NET_UNLOCK(s);
	return;

 baddone:
	NET_UNLOCK(s);

	m_freem(m);

	crypto_freereq(crp);
}

/*
 * ESP output routine, called by ipsp_process_packet().
 */
int
esp_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
    int protoff)
{
	struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
	struct auth_hash *esph = (struct auth_hash *) tdb->tdb_authalgxform;
	int ilen, hlen, rlen, padding, blks, alen, roff;
	u_int32_t replay;
	struct mbuf *mi, *mo = (struct mbuf *) NULL;
	struct tdb_crypto *tc;
	unsigned char *pad;
	u_int8_t prot;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif
	struct cryptodesc *crde = NULL, *crda = NULL;
	struct cryptop *crp;
#if NBPFILTER > 0
	struct ifnet *encif;

	if ((encif = enc_getif(tdb->tdb_rdomain, tdb->tdb_tap)) != NULL) {
		encif->if_opackets++;
		encif->if_obytes += m->m_pkthdr.len;

		if (encif->if_bpf) {
			struct enchdr hdr;

			memset(&hdr, 0, sizeof(hdr));

			hdr.af = tdb->tdb_dst.sa.sa_family;
			hdr.spi = tdb->tdb_spi;
			if (espx)
				hdr.flags |= M_CONF;
			if (esph)
				hdr.flags |= M_AUTH;

			bpf_mtap_hdr(encif->if_bpf, (char *)&hdr,
			    ENC_HDRLEN, m, BPF_DIRECTION_OUT, NULL);
		}
	}
#endif

	hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen;

	rlen = m->m_pkthdr.len - skip; /* Raw payload length. */
	if (espx)
		blks = MAX(espx->blocksize, 4);
	else
		blks = 4; /* If no encryption, we have to be 4-byte aligned. */

	padding = ((blks - ((rlen + 2) % blks)) % blks) + 2;

	alen = esph ? esph->authsize : 0;
	espstat.esps_output++;

	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		/* Check for IP maximum packet size violations. */
		if (skip + hlen + rlen + padding + alen > IP_MAXPACKET)	{
			DPRINTF(("esp_output(): packet in SA %s/%08x got "
			    "too big\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			m_freem(m);
			espstat.esps_toobig++;
			return EMSGSIZE;
		}
		break;

#ifdef INET6
	case AF_INET6:
		/* Check for IPv6 maximum packet size violations. */
		if (skip + hlen + rlen + padding + alen > IPV6_MAXPACKET) {
			DPRINTF(("esp_output(): packet in SA %s/%08x got too "
			    "big\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			m_freem(m);
			espstat.esps_toobig++;
			return EMSGSIZE;
		}
		break;
#endif /* INET6 */

	default:
		DPRINTF(("esp_output(): unknown/unsupported protocol "
		    "family %d, SA %s/%08x\n", tdb->tdb_dst.sa.sa_family,
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_nopf++;
		return EPFNOSUPPORT;
	}

	/* Update the counters. */
	tdb->tdb_cur_bytes += m->m_pkthdr.len - skip;
	espstat.esps_obytes += m->m_pkthdr.len - skip;

	/* Hard byte expiration. */
	if (tdb->tdb_flags & TDBF_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
		m_freem(m);
		return EINVAL;
	}

	/* Soft byte expiration. */
	if (tdb->tdb_flags & TDBF_SOFT_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES;    /* Turn off checking. */
	}

	/*
	 * Loop through mbuf chain; if we find a readonly mbuf,
	 * copy the packet.
	 */
	mi = m;
	while (mi != NULL && !M_READONLY(mi))
		mi = mi->m_next;

	if (mi != NULL)	{
		struct mbuf *n = m_dup_pkt(m, 0, M_DONTWAIT);

		if (n == NULL) {
			DPRINTF(("esp_output(): bad mbuf chain, SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			espstat.esps_hdrops++;
			m_freem(m);
			return ENOBUFS;
		}

		m_freem(m);
		m = n;
	}

	/* Inject ESP header. */
	mo = m_makespace(m, skip, hlen, &roff);
	if (mo == NULL) {
		DPRINTF(("esp_output(): failed to inject ESP header for "
		    "SA %s/%08x\n", ipsp_address(&tdb->tdb_dst, buf,
		    sizeof(buf)), ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_hdrops++;
		return ENOBUFS;
	}

	/* Initialize ESP header. */
	memcpy(mtod(mo, caddr_t) + roff, (caddr_t) &tdb->tdb_spi,
	    sizeof(u_int32_t));
	tdb->tdb_rpl++;
	replay = htonl((u_int32_t)tdb->tdb_rpl);
	memcpy(mtod(mo, caddr_t) + roff + sizeof(u_int32_t), (caddr_t) &replay,
	    sizeof(u_int32_t));

#if NPFSYNC > 0
	pfsync_update_tdb(tdb,1);
#endif

	/*
	 * Add padding -- better to do it ourselves than use the crypto engine,
	 * although if/when we support compression, we'd have to do that.
	 */
	mo = m_makespace(m, m->m_pkthdr.len, padding + alen, &roff);
	if (mo == NULL) {
		DPRINTF(("esp_output(): m_makespace() failed for SA %s/%08x\n",
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		m_freem(m);
		return ENOBUFS;
	}
	pad = mtod(mo, caddr_t) + roff;

	/* Apply self-describing padding */
	for (ilen = 0; ilen < padding - 2; ilen++)
		pad[ilen] = ilen + 1;

	/* Fix padding length and Next Protocol in padding itself. */
	pad[padding - 2] = padding - 2;
	m_copydata(m, protoff, sizeof(u_int8_t), pad + padding - 1);

	/* Fix Next Protocol in IPv4/IPv6 header. */
	prot = IPPROTO_ESP;
	m_copyback(m, protoff, sizeof(u_int8_t), &prot, M_NOWAIT);

	/* Get crypto descriptors. */
	crp = crypto_getreq(esph && espx ? 2 : 1);
	if (crp == NULL) {
		m_freem(m);
		DPRINTF(("esp_output(): failed to acquire crypto "
		    "descriptors\n"));
		espstat.esps_crypto++;
		return ENOBUFS;
	}

	if (espx) {
		crde = &crp->crp_desc[0];
		crda = &crp->crp_desc[1];

		/* Encryption descriptor. */
		crde->crd_skip = skip + hlen;
		crde->crd_flags = CRD_F_ENCRYPT;
		crde->crd_inject = skip + hlen - tdb->tdb_ivlen;

		/* Encryption operation. */
		crde->crd_alg = espx->type;
		crde->crd_key = tdb->tdb_emxkey;
		crde->crd_klen = tdb->tdb_emxkeylen * 8;
		/* XXX Rounds ? */

		if (crde->crd_alg == CRYPTO_AES_GMAC)
			crde->crd_len = 0;
		else
			crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
	} else
		crda = &crp->crp_desc[0];

	/* IPsec-specific opaque crypto info. */
	tc = malloc(sizeof(*tc), M_XDATA, M_NOWAIT | M_ZERO);
	if (tc == NULL) {
		m_freem(m);
		crypto_freereq(crp);
		DPRINTF(("esp_output(): failed to allocate tdb_crypto\n"));
		espstat.esps_crypto++;
		return ENOBUFS;
	}

	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = tdb->tdb_sproto;
	tc->tc_rdomain = tdb->tdb_rdomain;
	tc->tc_dst = tdb->tdb_dst;

	/* Crypto operation descriptor. */
	crp->crp_ilen = m->m_pkthdr.len; /* Total input length. */
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t)m;
	crp->crp_callback = esp_output_cb;
	crp->crp_opaque = (caddr_t)tc;
	crp->crp_sid = tdb->tdb_cryptoid;

	if (esph) {
		/* Authentication descriptor. */
		crda->crd_skip = skip;
		crda->crd_inject = m->m_pkthdr.len - alen;

		/* Authentication operation. */
		crda->crd_alg = esph->type;
		crda->crd_key = tdb->tdb_amxkey;
		crda->crd_klen = tdb->tdb_amxkeylen * 8;

		if ((tdb->tdb_wnd > 0) && (tdb->tdb_flags & TDBF_ESN)) {
			u_int32_t esn;

			esn = htonl((u_int32_t)(tdb->tdb_rpl >> 32));
			memcpy(crda->crd_esn, &esn, 4);
			crda->crd_flags |= CRD_F_ESN;
		}

		if (espx &&
		    (espx->type == CRYPTO_AES_GCM_16 ||
		     espx->type == CRYPTO_CHACHA20_POLY1305))
			crda->crd_len = hlen - tdb->tdb_ivlen;
		else
			crda->crd_len = m->m_pkthdr.len - (skip + alen);
	}

	return crypto_dispatch(crp);
}

/*
 * ESP output callback, called directly by the crypto driver.
 */
void
esp_output_cb(struct cryptop *crp)
{
	struct tdb_crypto *tc;
	struct tdb *tdb;
	struct mbuf *m;
	int s;

	tc = (struct tdb_crypto *) crp->crp_opaque;

	m = (struct mbuf *) crp->crp_buf;
	if (m == NULL) {
		/* Shouldn't happen... */
		free(tc, M_XDATA, 0);
		crypto_freereq(crp);
		espstat.esps_crypto++;
		DPRINTF(("esp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		return;
	}


	NET_LOCK(s);

	tdb = gettdb(tc->tc_rdomain, tc->tc_spi, &tc->tc_dst, tc->tc_proto);
	if (tdb == NULL) {
		free(tc, M_XDATA, 0);
		espstat.esps_notdb++;
		DPRINTF(("esp_output_cb(): TDB is expired while in crypto\n"));
		goto baddone;
	}

	/* Check for crypto errors. */
	if (crp->crp_etype) {
		if (crp->crp_etype == EAGAIN) {
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
			NET_UNLOCK(s);
			crypto_dispatch(crp);
			return;
		}
		free(tc, M_XDATA, 0);
		espstat.esps_noxform++;
		DPRINTF(("esp_output_cb(): crypto error %d\n",
		    crp->crp_etype));
		goto baddone;
	}
	free(tc, M_XDATA, 0);

	/* Release crypto descriptors. */
	crypto_freereq(crp);

	/* Call the IPsec input callback. */
	if (ipsp_process_done(m, tdb))
		espstat.esps_outfail++;
	NET_UNLOCK(s);
	return;

 baddone:
	NET_UNLOCK(s);

	m_freem(m);

	crypto_freereq(crp);
}

#define SEEN_SIZE	howmany(TDB_REPLAYMAX, 32)

/*
 * return 0 on success
 * return 1 for counter == 0
 * return 2 for very old packet
 * return 3 for packet within current window but already received
 */
int
checkreplaywindow(struct tdb *tdb, u_int32_t seq, u_int32_t *seqh, int commit)
{
	u_int32_t	tl, th, wl;
	u_int32_t	packet, window = TDB_REPLAYMAX - TDB_REPLAYWASTE;
	int		idx, esn = tdb->tdb_flags & TDBF_ESN;

	tl = (u_int32_t)tdb->tdb_rpl;
	th = (u_int32_t)(tdb->tdb_rpl >> 32);

	/* Zero SN is not allowed */
	if ((esn && seq == 0 && tl <= AH_HMAC_INITIAL_RPL && th == 0) ||
	    (!esn && seq == 0))
		return (1);

	if (th == 0 && tl < window)
		window = tl;
	/* Current replay window starts here */
	wl = tl - window + 1;

	idx = (seq % TDB_REPLAYMAX) / 32;
	packet = 1 << (31 - (seq & 31));

	/*
	 * We keep the high part intact when:
	 * 1) the SN is within [wl, 0xffffffff] and the whole window is
	 *    within one subspace;
	 * 2) the SN is within [0, wl) and window spans two subspaces.
	 */
	if ((tl >= window - 1 && seq >= wl) ||
	    (tl <  window - 1 && seq <  wl)) {
		*seqh = th;
		if (seq > tl) {
			if (commit) {
				if (seq - tl > window)
					memset(tdb->tdb_seen, 0,
					    sizeof(tdb->tdb_seen));
				else {
					int i = (tl % TDB_REPLAYMAX) / 32;

					while (i != idx) {
						i = (i + 1) % SEEN_SIZE;
						tdb->tdb_seen[i] = 0;
					}
				}
				tdb->tdb_seen[idx] |= packet;
				tdb->tdb_rpl = ((u_int64_t)*seqh << 32) | seq;
			}
		} else {
			if (tl - seq >= window)
				return (2);
			if (tdb->tdb_seen[idx] & packet)
				return (3);
			if (commit)
				tdb->tdb_seen[idx] |= packet;
		}
		return (0);
	}

	/* Can't wrap if not doing ESN */
	if (!esn)
		return (2);

	/*
	 * SN is within [wl, 0xffffffff] and wl is within
	 * [0xffffffff-window, 0xffffffff].  This means we got a SN
	 * which is within our replay window, but in the previous
	 * subspace.
	 */
	if (tl < window - 1 && seq >= wl) {
		if (tdb->tdb_seen[idx] & packet)
			return (3);
		*seqh = th - 1;
		if (commit)
			tdb->tdb_seen[idx] |= packet;
		return (0);
	}

	/*
	 * SN has wrapped and the last authenticated SN is in the old
	 * subspace.
	 */
	*seqh = th + 1;
	if (*seqh == 0)		/* Don't let high bit to wrap */
		return (1);
	if (commit) {
		if (seq - tl > window)
			memset(tdb->tdb_seen, 0, sizeof(tdb->tdb_seen));
		else {
			int i = (tl % TDB_REPLAYMAX) / 32;

			while (i != idx) {
				i = (i + 1) % SEEN_SIZE;
				tdb->tdb_seen[i] = 0;
			}
		}
		tdb->tdb_seen[idx] |= packet;
		tdb->tdb_rpl = ((u_int64_t)*seqh << 32) | seq;
	}

	return (0);
}
@


1.148
log
@Switch OCF and IPsec over to the new AES

ok djm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.147 2017/04/06 17:36:18 dhill Exp $ */
d316 1
a316 1
		free(tdbp->tdb_amxkey, M_XDATA, 0);
d322 1
a322 1
		free(tdbp->tdb_emxkey, M_XDATA, 0);
@


1.147
log
@Convert bcopy to memcpy where the memory does not overlap, otherwise,
use memmove.  While here, change some previous conversions to a simple
assignment.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.146 2017/02/07 18:18:16 bluhm Exp $ */
d119 1
a119 1
			txform = &enc_xform_rijndael128;
@


1.146
log
@IPsec packets could be dropped unaccounted if output after crypto
failed.  Add a counter for that case.
OK dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.145 2017/02/07 17:25:46 patrick Exp $ */
d507 1
a507 1
	memcpy(&tc->tc_dst, &tdb->tdb_dst, sizeof(union sockaddr_union));
d710 3
a712 2
		bcopy(mtod(m1, u_char *) + roff + hlen,
		    mtod(m1, u_char *) + roff, m1->m_len - (roff + hlen));
d914 1
a914 1
	bcopy((caddr_t) &tdb->tdb_spi, mtod(mo, caddr_t) + roff,
d996 1
a996 1
	memcpy(&tc->tc_dst, &tdb->tdb_dst, sizeof(union sockaddr_union));
@


1.145
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.144 2017/02/07 15:10:48 bluhm Exp $ */
d1091 2
a1092 2
	ipsp_process_done(m, tdb);
	/* XXX missing error counter if ipsp_process_done() drops packet */
@


1.144
log
@The return code of crp_callback is never checked, so it is not
useful to propagate the error.  When an error occurs in an asynchronous
network path, incrementing a counter is the right thing.  There are
four places where an error is not accounted, just add a comment for
now.
OK mpi@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.143 2017/01/09 17:10:03 mpi Exp $ */
d464 2
a465 2
		crda = crp->crp_desc;
		crde = crda->crd_next;
d491 1
a491 1
		crde = crp->crp_desc;
d961 2
a962 2
		crde = crp->crp_desc;
		crda = crde->crd_next;
d980 1
a980 1
		crda = crp->crp_desc;
@


1.143
log
@Grab the NET_LOCK() in various callbacks.

Fix an assert reported by Hrvoje Popovski.

ok visa@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.142 2016/12/24 11:17:35 mpi Exp $ */
d72 2
a73 2
int esp_output_cb(struct cryptop *);
int esp_input_cb(struct cryptop *);
d530 1
a530 1
int
d534 1
a534 1
	int s, hlen, roff, skip, protoff, error;
d556 1
a556 1
		return (EINVAL);
a565 1
		error = EPERM;
d578 2
a579 1
			return crypto_dispatch(crp);
a583 1
		error = crp->crp_etype;
a602 1
			error = EACCES;
a629 1
			error = EACCES;
a636 1
			error = EACCES;
a643 1
			error = EACCES;
a650 1
			error = EACCES;
d670 1
a670 1
		return EINVAL;
d728 1
a728 1
		return EINVAL;
d739 1
a739 1
		return EINVAL;
d749 1
a749 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff);
d751 1
a751 1
	return (error);
a758 2

	return (error);
d1037 1
a1037 1
int
d1043 1
a1043 1
	int error, s;
d1055 1
a1055 1
		return (EINVAL);
a1065 1
		error = EPERM;
d1076 2
a1077 1
			return crypto_dispatch(crp);
a1082 1
		error = crp->crp_etype;
d1091 2
a1092 1
	error = ipsp_process_done(m, tdb);
d1094 1
a1094 1
	return error;
a1101 2

	return error;
@


1.142
log
@Grab the NET_LOCK() before calling ipsp_process_done() as it ends up
in ip_output().

Found the hardway by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.141 2016/09/19 18:09:22 tedu Exp $ */
d559 1
a559 1
	s = splsoftnet();
d578 1
a578 1
			splx(s);
d671 1
a671 1
		splx(s);
d728 1
a728 1
		splx(s);
d740 1
a740 1
		splx(s);
d756 1
a756 1
	splx(s);
d760 1
a760 1
	splx(s);
@


1.141
log
@convert bcopy to memcpy. from david hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.140 2016/09/13 19:56:55 markus Exp $ */
d1067 1
a1067 1
	s = splsoftnet();
d1084 1
a1084 1
			splx(s);
d1101 1
a1101 1
	splx(s);
d1105 1
a1105 1
	splx(s);
@


1.140
log
@avoid extensive mbuf allocation for IPsec by replacing m_inject(4)
with m_makespace(4) from freebsd; ok mpi@@, bluhm@@, mikeb@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.139 2016/08/18 06:01:10 dlg Exp $ */
d265 1
a265 1
		bcopy(ii->ii_enckey, tdbp->tdb_emxkey, tdbp->tdb_emxkeylen);
d286 1
a286 1
		bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
d477 1
a477 1
			bcopy(&esn, crda->crd_esn, 4);
d507 1
a507 1
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));
d925 1
a925 1
	bcopy((caddr_t) &replay, mtod(mo, caddr_t) + roff + sizeof(u_int32_t),
d1003 1
a1003 1
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));
d1027 1
a1027 1
			bcopy(&esn, crda->crd_esn, 4);
@


1.139
log
@fix panics caused by replacing m_copym2 with m_dup_pkt.

m_copym2 is fine duplicating an arbitrary chain of mbufs, while
m_dup_pkt wants to dup a packet with proper headers in the first
mbuf. ipsec copied the tail of an mbuf if any of the clusters are
shared or readonly, and swapped that tail with the result of m_copym2.

m_dup_pkt panics cos of that.

this makes ipsec duplicate the whole packet if any of the chain is
readonly.

found by naddy@@ and mlarkin@@
this fix is from visa@@ who told me to commit it cos he's afk (sleeping)
tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.138 2016/08/15 11:35:25 dlg Exp $ */
d778 1
a778 1
	int ilen, hlen, rlen, padding, blks, alen;
d910 1
a910 1
	mo = m_inject(m, skip, hlen, M_DONTWAIT);
d921 2
a922 1
	bcopy((caddr_t) &tdb->tdb_spi, mtod(mo, caddr_t), sizeof(u_int32_t));
d925 1
a925 1
	bcopy((caddr_t) &replay, mtod(mo, caddr_t) + sizeof(u_int32_t),
d936 1
a936 1
	mo = m_inject(m, m->m_pkthdr.len, padding + alen, M_DONTWAIT);
d938 1
a938 1
		DPRINTF(("esp_output(): m_inject failed for SA %s/%08x\n",
d944 1
a944 1
	pad = mtod(mo, u_char *);
@


1.138
log
@replace the last uses of m_copym2 with m_dup_pkt.

ok mpi@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.137 2016/03/07 18:44:00 naddy Exp $ */
d887 1
a887 1
	 * replace the rest of the chain.
a888 1
	mo = NULL;
d890 1
a890 2
	while (mi != NULL && !M_READONLY(mi)) {
		mo = mi;
a891 1
	}
d894 1
a894 2
		/* Replace the rest of the mbuf chain. */
		struct mbuf *n = m_dup_pkt(mi, 0, M_DONTWAIT);
d905 2
a906 6
		if (mo != NULL)
			mo->m_next = n;
		else
			m = n;

		m_freem(mi);
@


1.137
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.136 2015/12/09 21:41:50 naddy Exp $ */
d898 1
a898 1
		struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);
@


1.136
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.135 2015/11/03 01:50:36 mikeb Exp $ */
d87 1
a87 1
esp_attach()
@


1.135
log
@Plumb Chacha20-Poly1305 into the IPsec/ESP and PF_KEY frameworks

ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.134 2015/07/15 22:16:42 deraadt Exp $ */
a111 4
			break;

		case SADB_EALG_DESCBC:
			txform = &enc_xform_des;
@


1.134
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.133 2015/06/15 12:59:37 mikeb Exp $ */
d138 4
d185 4
d237 4
d485 3
a487 1
		if (espx && espx->type == CRYPTO_AES_GCM_16)
d1042 3
a1044 1
		if (espx && espx->type == CRYPTO_AES_GCM_16)
@


1.133
log
@No need for an extra local variable;  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.132 2015/06/15 12:37:37 mikeb Exp $ */
d752 1
a752 2
	if (m != NULL)
		m_freem(m);
d1102 1
a1102 2
	if (m != NULL)
		m_freem(m);
@


1.132
log
@Use proper argument type for crp_callback functions; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.131 2015/04/17 11:04:01 mikeb Exp $ */
d1120 1
a1120 2
checkreplaywindow(struct tdb *tdb, u_int32_t seq, u_int32_t *seqhigh,
    int commit)
d1123 1
a1123 2
	u_int32_t	seqh, packet;
	u_int32_t	window = TDB_REPLAYMAX - TDB_REPLAYWASTE;
d1150 1
a1150 1
		seqh = *seqhigh = th;
d1165 1
a1165 1
				tdb->tdb_rpl = ((u_int64_t)seqh << 32) | seq;
d1191 1
a1191 1
		seqh = *seqhigh = th - 1;
d1201 2
a1202 2
	seqh = *seqhigh = th + 1;
	if (seqh == 0)		/* Don't let high bit to wrap */
d1216 1
a1216 1
		tdb->tdb_rpl = ((u_int64_t)seqh << 32) | seq;
@


1.131
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.130 2015/04/14 14:20:01 mikeb Exp $ */
d72 2
a73 2
int esp_output_cb(void *);
int esp_input_cb(void *);
d486 2
a487 2
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) esp_input_cb;
d489 1
a489 1
	crp->crp_opaque = (caddr_t) tc;
d521 1
a521 1
esp_input_cb(void *op)
a527 1
	struct cryptop *crp;
a534 2
	crp = (struct cryptop *) op;

d1006 3
a1008 3
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) esp_output_cb;
	crp->crp_opaque = (caddr_t) tc;
d1042 1
a1042 1
esp_output_cb(void *op)
a1043 1
	struct cryptop *crp = (struct cryptop *) op;
@


1.130
log
@make ipsp_address thread safe;  ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.129 2014/12/19 17:14:40 tedu Exp $ */
a336 1
	struct m_tag *mtag;
a432 17
#ifdef notyet
	/* Find out if we've already done crypto */
	for (mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, NULL);
	     mtag != NULL;
	     mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, mtag)) {
		struct tdb_ident *tdbi;

		tdbi = (struct tdb_ident *) (mtag + 1);
		if (tdbi->proto == tdb->tdb_sproto && tdbi->spi == tdb->tdb_spi &&
		    tdbi->rdomain == tdb->tdb_rdomain && !memcmp(&tdbi->dst,
		    &tdb->tdb_dst, sizeof(union sockaddr_union)))
			break;
	}
#else
	mtag = NULL;
#endif

d443 1
a443 1
	if (esph == NULL || mtag != NULL)
a454 2
	tc->tc_ptr = (caddr_t) mtag;

d479 1
a479 3
		if (mtag == NULL)
			m_copydata(m, m->m_pkthdr.len - alen, alen,
			    (caddr_t)(tc + 1));
d514 1
a514 4
	if (mtag == NULL)
		return crypto_dispatch(crp);
	else
		return esp_input_cb(crp);
a528 1
	struct m_tag *mtag;
a540 1
	mtag = (struct m_tag *) tc->tc_ptr;
d583 16
a598 22
		/*
		 * If we have a tag, it means an IPsec-aware NIC did the
		 * verification for us.
		 */
		if (mtag == NULL) {
			/* Copy the authenticator from the packet */
			m_copydata(m, m->m_pkthdr.len - esph->authsize,
			    esph->authsize, aalg);

			ptr = (caddr_t) (tc + 1);

			/* Verify authenticator */
			if (timingsafe_bcmp(ptr, aalg, esph->authsize)) {
				free(tc, M_XDATA, 0);
				DPRINTF(("esp_input_cb(): authentication "
				    "failed for packet in SA %s/%08x\n",
				    ipsp_address(&tdb->tdb_dst, buf,
				    sizeof(buf)), ntohl(tdb->tdb_spi)));
				espstat.esps_badauth++;
				error = EACCES;
				goto baddone;
			}
d748 1
a748 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
d1038 1
a1038 4
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		return crypto_dispatch(crp);
	else
		return esp_output_cb(crp);
@


1.129
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.128 2014/12/05 15:50:04 mpi Exp $ */
d147 2
a148 1
			DPRINTF(("esp_init(): unsupported encryption algorithm %d specified\n", ii->ii_encalg));
d153 3
a155 1
			DPRINTF(("esp_init(): keylength %d too small (min length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->minkey, txform->name));
d160 3
a162 1
			DPRINTF(("esp_init(): keylength %d too large (max length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->maxkey, txform->name));
d230 2
a231 1
			DPRINTF(("esp_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
d236 3
a238 1
			DPRINTF(("esp_init(): keylength %d doesn't match algorithm %s keysize (%d)\n", ii->ii_authkeylen, thash->name, thash->keysize));
d339 3
d360 4
a363 1
			DPRINTF(("esp_input(): payload of %d octets not a multiple of %d octets, SA %s/%08x\n", plen, espx->blocksize, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d383 2
a384 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d391 2
a392 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d399 2
a400 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d407 2
a408 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d500 2
a501 1
			m_copydata(m, m->m_pkthdr.len - alen, alen, (caddr_t) (tc + 1));
d558 3
d611 2
a612 2
		 * If we have a tag, it means an IPsec-aware NIC did the verification
		 * for us.
d624 4
a627 1
				DPRINTF(("esp_input_cb(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d655 2
a656 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d663 2
a664 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d671 2
a672 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d679 2
a680 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d699 2
a700 1
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d721 1
a721 1
			/* The second mbuf is guaranteed not to have a pkthdr... */
d755 4
a758 1
		DPRINTF(("esp_input_cb(): invalid padding length %d for packet in SA %s/%08x\n", lastthree[1], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d767 3
a769 1
		DPRINTF(("esp_input(): decryption failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d811 3
a813 1

d859 2
a860 1
			    "too big\n", ipsp_address(tdb->tdb_dst),
d873 2
a874 2
			    "big\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
d884 3
a886 2
		    "family %d, SA %s/%08x\n", tdb->tdb_dst.sa.sa_family
		    , ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d929 2
a930 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d948 2
a949 2
		    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
		    ntohl(tdb->tdb_spi)));
d973 2
a974 1
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
@


1.128
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.127 2014/11/18 02:37:31 tedu Exp $ */
a48 1
#ifdef INET
a51 1
#endif /* INET */
a53 3
#ifndef INET
#include <netinet/in.h>
#endif
a817 1
#ifdef INET
a828 1
#endif /* INET */
@


1.127
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.126 2014/07/22 11:06:10 mpi Exp $ */
d46 1
@


1.126
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.125 2014/07/12 18:44:23 tedu Exp $ */
a46 2

#include <dev/rndvar.h>
@


1.125
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.124 2014/07/09 09:30:49 henning Exp $ */
a51 1
#include <netinet/in_systm.h>
@


1.124
log
@bpf code surgery / shuffling / simplification.
the various bpf_mtap_* are very similiar, they differ in what (and to some
extent how) they prepend something, and what copy function they pass to
bpf_catchpacket.
use an internal _bpf_mtap as "backend" for bpf_mtap and friends.
extend bpf_mtap_hdr so that it covers all common cases:
if dlen is 0, nothing gets prepended.
copy function can be given, if NULL the default bpf_mcopy is used.
adjust the existing bpf_mtap_hdr users to pass a NULL ptr for the copy fn.
re-implement bpf_mtap_af as simple wrapper for bpf_mtap_hdr.
re-implement bpf_mtap_ether using bpf_map_hdr
re-implement bpf_mtap_pflog as trivial bpf_mtap_hdr wrapper
ok bluhm benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.122 2013/04/11 12:06:25 mpi Exp $ */
d307 1
a307 1
		free(tdbp->tdb_amxkey, M_XDATA);
d313 1
a313 1
		free(tdbp->tdb_emxkey, M_XDATA);
d557 1
a557 1
		free(tc, M_XDATA);
d568 1
a568 1
		free(tc, M_XDATA);
d586 1
a586 1
		free(tc, M_XDATA);
d608 1
a608 1
				free(tc, M_XDATA);
d619 1
a619 1
	free(tc, M_XDATA);
d1062 1
a1062 1
		free(tc, M_XDATA);
d1075 1
a1075 1
		free(tc, M_XDATA);
d1091 1
a1091 1
		free(tc, M_XDATA);
d1098 1
a1098 1
	free(tc, M_XDATA);
@


1.123
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d806 1
a806 1
			    ENC_HDRLEN, m, BPF_DIRECTION_OUT);
@


1.122
log
@Remove the extern keyword from function declarations, document
sysctl declarations, move variables and functions used in only
one place in their corresponding file. No functional change.

No objection from markus@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.121 2013/02/14 16:22:34 mikeb Exp $ */
d258 1
a258 1
		bzero(&crie, sizeof(crie));
d279 1
a279 1
		bzero(&cria, sizeof(cria));
d284 1
a284 1
			bzero(&crin, sizeof(crin));
d432 1
a432 1
		    tdbi->rdomain == tdb->tdb_rdomain && !bcmp(&tdbi->dst,
d796 1
a796 1
			bzero (&hdr, sizeof(hdr));
d1164 1
a1164 1
					bzero(tdb->tdb_seen,
d1216 1
a1216 1
			bzero(tdb->tdb_seen, sizeof(tdb->tdb_seen));
@


1.121
log
@Merge of an original work by markus@@ and gerhard@@ to increase
the anti-replay window size to 2100 entries; plus small ESN
related improvements.  ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.120 2012/10/18 10:49:48 markus Exp $ */
d78 3
@


1.120
log
@simplify checkreplaywindow() API; make call/return code handling consistent
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.119 2012/09/20 10:25:03 blambert Exp $ */
a244 1
	tdbp->tdb_bitmap = 0;
d1116 1
a1116 27
static __inline int
checkreplay(u_int64_t *bitmap, u_int32_t diff)
{
	if (*bitmap & (1ULL << diff))
		return (1);
	return (0);
}

static __inline void
setreplay(u_int64_t *bitmap, u_int32_t diff, u_int32_t window, int wupdate)
{
	if (wupdate) {
		if (diff < window)
			*bitmap = ((*bitmap) << diff) | 1;
		else
			*bitmap = 1;
	} else
		*bitmap |= 1ULL << diff;
}

/*
 * To prevent ESN desynchronization replay distance specifies maximum
 * valid difference between the received SN and the last authenticated
 * one.  It's arbitrary chosen to be 1000 packets, meaning that only
 * up to 999 packets can be lost.
 */
#define REPLAY_DISTANCE (1000)
d1129 3
a1131 4
	u_int32_t	seqh, diff;
	u_int32_t	window = tdb->tdb_wnd;
	u_int64_t	*bitmap = &tdb->tdb_bitmap;
	int		esn = tdb->tdb_flags & TDBF_ESN;
d1137 2
a1138 1
	if (seq == 0 && tl == 0 && th == 0)
d1141 2
d1146 3
a1158 2
			if (seq - tl >= REPLAY_DISTANCE)
				return (2);
d1160 12
a1171 1
				setreplay(bitmap, seq - tl, window, 1);
d1175 3
a1177 1
			if (checkreplay(bitmap, tl - seq))
d1180 1
a1180 1
				setreplay(bitmap, tl - seq, window, 0);
d1187 1
a1187 1
		return (1);
d1196 2
a1198 4
		diff = (u_int32_t)((((u_int64_t)th << 32) | tl) -
		    (((u_int64_t)seqh << 32) | seq));
		if (checkreplay(bitmap, diff))
			return (3);
d1200 1
a1200 1
			setreplay(bitmap, diff, window, 0);
a1207 4

	if (seq - tl >= REPLAY_DISTANCE)
		return (2);

d1212 11
a1222 3
		diff = (u_int32_t)((((u_int64_t)seqh << 32) | seq) -
		    (((u_int64_t)th << 32) | tl));
		setreplay(bitmap, diff, window, 1);
@


1.119
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.118 2012/09/18 09:24:45 markus Exp $ */
d367 1
a367 2
		switch (checkreplaywindow(btsx, &tdb->tdb_rpl, tdb->tdb_wnd,
		    &tdb->tdb_bitmap, &esn, tdb->tdb_flags & TDBF_ESN, 0)) {
a369 1

d372 3
a374 1
			DPRINTF(("esp_input(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
a376 1

d378 6
a384 1
			DPRINTF(("esp_input(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d386 3
a390 1

d393 4
a396 1
			DPRINTF(("esp_input(): bogus value from checkreplaywindow() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d625 1
a625 2
		switch (checkreplaywindow(btsx, &tdb->tdb_rpl, tdb->tdb_wnd,
		    &tdb->tdb_bitmap, &esn, tdb->tdb_flags & TDBF_ESN, 1)) {
d633 3
a635 1
			DPRINTF(("esp_input_cb(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
a638 1

d640 6
d647 3
a649 1
			DPRINTF(("esp_input_cb(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
a652 1

d654 4
a657 1
			DPRINTF(("esp_input_cb(): bogus value from checkreplaywindow() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d1152 2
a1153 2
checkreplaywindow(u_int32_t seq, u_int64_t *last, u_int32_t window,
    u_int64_t *bitmap, u_int32_t *seqhigh, int esn, int commit)
d1157 3
d1161 2
a1162 2
	tl = (u_int32_t)*last;
	th = (u_int32_t)(*last >> 32);
d1185 1
a1185 1
				*last = ((u_int64_t)seqh << 32) | seq;
d1232 1
a1232 1
		*last = ((u_int64_t)seqh << 32) | seq;
@


1.118
log
@remove the SADB_X_SAFLAGS_{HALFIV,RANDOMPADDING,NOREPLAY} pfkey-API (not set
anywhere) as well as the matching TDBF_{HALFIV,RANDOMPADDING,NOREPLAY} code.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.117 2012/06/29 14:48:04 mikeb Exp $ */
d553 1
a553 1
	s = spltdb();
d1050 1
a1050 1
	s = spltdb();
@


1.117
log
@Add support for the Extended (64-bit) Sequence Number as defined
in RFC4302 and RFC4303.  Right now only software crypto engine is
capable of doing it.

Replay check was rewritten to implement algorithm described in the
Appendix A of RFC4303 and the window size was increased to 64.

Tested against OpenBSD, Linux (strongswan) and Windows.

No objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.116 2011/01/11 15:42:05 deraadt Exp $ */
a187 2
		if (tdbp->tdb_flags & TDBF_HALFIV)
			tdbp->tdb_ivlen /= 2;
d281 1
a281 2
		if ((tdbp->tdb_wnd > 0) && !(tdbp->tdb_flags & TDBF_NOREPLAY) &&
		    (tdbp->tdb_flags & TDBF_ESN)) {
d338 1
a338 5
	if (tdb->tdb_flags & TDBF_NOREPLAY)
		hlen = sizeof(u_int32_t) + tdb->tdb_ivlen; /* "old" ESP */
	else
		hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; /* "new" ESP */

d362 1
a362 1
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
d465 1
a465 2
		if ((tdb->tdb_wnd > 0) && !(tdb->tdb_flags & TDBF_NOREPLAY) &&
		    (tdb->tdb_flags & TDBF_ESN)) {
a501 12

		if (tdb->tdb_flags & TDBF_HALFIV) {
			/* Copy half-IV from packet */
			m_copydata(m, crde->crd_inject, tdb->tdb_ivlen, crde->crd_iv);

			/* Cook IV */
			for (btsx = 0; btsx < tdb->tdb_ivlen; btsx++)
				crde->crd_iv[tdb->tdb_ivlen + btsx] = ~crde->crd_iv[btsx];

			crde->crd_flags |= CRD_F_IV_EXPLICIT;
		}

d611 1
a611 1
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
d648 1
a648 4
	if (tdb->tdb_flags & TDBF_NOREPLAY)
		hlen = sizeof(u_int32_t) + tdb->tdb_ivlen; /* "old" ESP */
	else
		hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; /* "new" ESP */
d717 6
a722 8
	if (!(tdb->tdb_flags & TDBF_RANDOMPADDING)) {
		if ((lastthree[1] != lastthree[0]) && (lastthree[1] != 0)) {
			espstat.esps_badenc++;
			splx(s);
			DPRINTF(("esp_input(): decryption failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			m_freem(m);
			return EINVAL;
		}
d757 1
d790 1
a790 4
	if (tdb->tdb_flags & TDBF_NOREPLAY)
		hlen = sizeof(u_int32_t) + tdb->tdb_ivlen;
	else
		hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen;
d905 5
a909 6
	if (!(tdb->tdb_flags & TDBF_NOREPLAY)) {
		u_int32_t replay;
		tdb->tdb_rpl++;
		replay = htonl((u_int32_t)tdb->tdb_rpl);
		bcopy((caddr_t) &replay, mtod(mo, caddr_t) + sizeof(u_int32_t),
		    sizeof(u_int32_t));
d911 1
a911 1
		pfsync_update_tdb(tdb,1);
a912 1
	}
d927 3
a929 6
	/* Self-describing or random padding ? */
	if (!(tdb->tdb_flags & TDBF_RANDOMPADDING))
		for (ilen = 0; ilen < padding - 2; ilen++)
			pad[ilen] = ilen + 1;
	else
		arc4random_buf((void *) pad, padding - 2);
a957 15
		if (tdb->tdb_flags & TDBF_HALFIV) {
			/* Copy half-iv in the packet. */
			m_copyback(m, crde->crd_inject, tdb->tdb_ivlen,
			    tdb->tdb_iv, M_NOWAIT);

			/* Cook half-iv. */
			bcopy(tdb->tdb_iv, crde->crd_iv, tdb->tdb_ivlen);
			for (ilen = 0; ilen < tdb->tdb_ivlen; ilen++)
				crde->crd_iv[tdb->tdb_ivlen + ilen] =
				    ~crde->crd_iv[ilen];

			crde->crd_flags |=
			    CRD_F_IV_PRESENT | CRD_F_IV_EXPLICIT;
		}

d1004 1
a1004 2
		if ((tdb->tdb_wnd > 0) && !(tdb->tdb_flags & TDBF_NOREPLAY) &&
		    (tdb->tdb_flags & TDBF_ESN)) {
a1080 9

	/*
	 * If we're doing half-iv, keep a copy of the last few bytes of the
	 * encrypted part, for use as the next IV. Note that HALF-IV is only
	 * supposed to be used without authentication (the old ESP specs).
	 */
	if (tdb->tdb_flags & TDBF_HALFIV)
		m_copydata(m, m->m_pkthdr.len - tdb->tdb_ivlen, tdb->tdb_ivlen,
		    tdb->tdb_iv);
@


1.116
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.115 2010/12/21 14:45:57 markus Exp $ */
d104 1
a104 1
	struct cryptoini cria, crie;
d282 8
a289 1
		cria.cri_next = NULL;
d338 1
a338 1
	u_int32_t btsx;
d374 2
a375 2
		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 0)) {
d389 1
d394 1
a394 2
			DPRINTF(("esp_input(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
d472 7
d553 1
a553 1
	u_int32_t btsx;
d636 2
a637 2
		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 1)) {
d653 1
d658 1
a658 2
			DPRINTF(("esp_input_cb(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
d933 3
a935 1
		u_int32_t replay = htonl(tdb->tdb_rpl++);
d1051 9
d1155 28
d1190 2
a1191 2
checkreplaywindow32(u_int32_t seq, u_int32_t initial, u_int32_t *lastseq,
    u_int32_t window, u_int32_t *bitmap, int commit)
d1193 2
a1194 1
	u_int32_t diff, llseq, lbitmap;
d1196 2
a1197 4
	/* Just do the checking, without "committing" any changes. */
	if (commit == 0) {
		llseq = *lastseq;
		lbitmap = *bitmap;
d1199 30
a1228 2
		lastseq = &llseq;
		bitmap = &lbitmap;
d1231 3
a1233 1
	seq -= initial;
d1235 16
a1250 2
	if (seq == 0)
		return 1;
d1252 4
a1255 9
	if (seq > *lastseq - initial) {
		diff = seq - (*lastseq - initial);
		if (diff < window)
			*bitmap = ((*bitmap) << diff) | 1;
		else
			*bitmap = 1;
		*lastseq = seq + initial;
		return 0;
	}
d1257 2
a1258 5
	diff = *lastseq - initial - seq;
	if (diff >= window) {
		espstat.esps_wrap++;
		return 2;
	}
d1260 8
a1267 3
	if ((*bitmap) & (((u_int32_t) 1) << diff)) {
		espstat.esps_replay++;
		return 3;
d1270 1
a1270 2
	*bitmap |= (((u_int32_t) 1) << diff);
	return 0;
@


1.115
log
@don't leak mbuf if padding failes; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.114 2010/10/06 22:19:20 mikeb Exp $ */
d300 1
a300 1
		bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
d306 1
a306 1
		bzero(tdbp->tdb_emxkey, tdbp->tdb_emxkeylen);
@


1.114
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.113 2010/09/23 16:33:48 mikeb Exp $ */
d935 1
@


1.113
log
@remove m_pad in favor of m_inject as it's equivalent to m_inject
with an offset equal to the actual data length.

ok henning blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.112 2010/09/22 13:40:05 mikeb Exp $ */
a147 4
			break;

		case SADB_X_EALG_SKIPJACK:
			txform = &enc_xform_skipjack;
@


1.112
log
@Support for AES-GCM-16 and ENCR_NULL_AUTH_AES_GMAC in ESP as per
RFC 4106 and 4543.

Authentication hash key is set to be the same as an encryption key.

The length that is specified for the authentication hash descriptor
denotes the the length of Additional Authentication Data (AAD).
The encryption transformation descriptor length denotes the length
of the payload (to be encrypted and authenticated).

ENCR_NULL_AUTH_AES_GMAC treats all input as AAD, thus the encryption
length is set to zero.

This also fixes padding for stream ciphers, so that payload will
be 4-byte aligned.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.111 2010/07/20 15:36:03 matthew Exp $ */
d935 3
a937 3
	pad = (u_char *) m_pad(m, padding + alen);
	if (pad == NULL) {
		DPRINTF(("esp_output(): m_pad() failed for SA %s/%08x\n",
d941 1
a1181 73
}

/*
 * m_pad(m, n) pads <m> with <n> bytes at the end. The packet header
 * length is updated, and a pointer to the first byte of the padding
 * (which is guaranteed to be all in one mbuf) is returned.
 */

caddr_t
m_pad(struct mbuf *m, int n)
{
	struct mbuf *m0, *m1;
	int len, pad;
	caddr_t retval;

	if (n <= 0) {  /* No stupid arguments. */
		DPRINTF(("m_pad(): pad length invalid (%d)\n", n));
		m_freem(m);
		return NULL;
	}

	len = m->m_pkthdr.len;
	pad = n;
	m0 = m;

	while (m0->m_len < len) {
		len -= m0->m_len;
		m0 = m0->m_next;
	}

	if (m0->m_len != len) {
		DPRINTF(("m_pad(): length mismatch (should be %d instead of "
		    "%d)\n", m->m_pkthdr.len,
		    m->m_pkthdr.len + m0->m_len - len));

		m_freem(m);
		return NULL;
	}

	/* Check for zero-length trailing mbufs, and find the last one. */
	for (m1 = m0; m1->m_next; m1 = m1->m_next) {
		if (m1->m_next->m_len != 0) {
			DPRINTF(("m_pad(): length mismatch (should be %d "
			    "instead of %d)\n", m->m_pkthdr.len,
			    m->m_pkthdr.len + m1->m_next->m_len));

			m_freem(m);
			return NULL;
		}

		m0 = m1->m_next;
	}

	if ((m0->m_flags & M_EXT) ||
	    m0->m_data + m0->m_len + pad >= &(m0->m_dat[MLEN])) {
		/* Add an mbuf to the chain. */
		MGET(m1, M_DONTWAIT, MT_DATA);
		if (m1 == 0) {
			m_freem(m0);
			DPRINTF(("m_pad(): cannot append\n"));
			return NULL;
		}

		m0->m_next = m1;
		m0 = m1;
		m0->m_len = 0;
	}

	retval = m0->m_data + m0->m_len;
	m0->m_len += pad;
	m->m_pkthdr.len += pad;

	return retval;
@


1.111
log
@Switch some obvious network stack MAC comparisons from bcmp() to
timingsafe_bcmp().

ok deraadt@@; committed over WPA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.110 2010/07/09 16:58:06 reyk Exp $ */
d134 8
d169 17
d222 12
d330 2
a336 3
	struct cryptodesc *crde = NULL, *crda = NULL;
	struct cryptop *crp;

a462 1
		crda->crd_len = m->m_pkthdr.len - (skip + alen);
d469 5
a498 1
		crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
d516 5
d811 1
a811 1
		blks = espx->blocksize;
a972 1
		crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
d996 5
a1029 1
		crda->crd_len = m->m_pkthdr.len - (skip + alen);
d1036 5
@


1.110
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.109 2010/07/02 02:40:16 blambert Exp $ */
d562 1
a562 1
			if (bcmp(ptr, aalg, esph->authsize)) {
@


1.109
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.108 2010/07/01 02:09:45 reyk Exp $ */
d389 2
a390 1
		    !bcmp(&tdbi->dst, &tdb->tdb_dst, sizeof(union sockaddr_union)))
d453 1
d521 1
a521 1
	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
d738 1
a738 1
	if ((encif = enc_getif(0, tdb->tdb_tap)) != NULL) {
d968 1
d1025 1
a1025 1
	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
@


1.108
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.107 2010/06/29 21:28:37 reyk Exp $ */
d698 1
a698 1
	m_copyback(m, protoff, sizeof(u_int8_t), lastthree + 2);
d909 1
a909 1
	m_copyback(m, protoff, sizeof(u_int8_t), &prot);
d934 1
a934 1
			    tdb->tdb_iv);
@


1.107
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.106 2010/01/10 12:43:07 markus Exp $ */
d736 1
a736 1
	if ((encif = enc_getif(0)) != NULL) {
@


1.106
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.105 2008/06/09 07:07:17 djm Exp $ */
d734 1
a734 1
	struct ifnet *ifn = &(encif[0].sc_if);
d736 15
a750 2
	ifn->if_opackets++;
	ifn->if_obytes += m->m_pkthdr.len;
d752 3
a754 14
	if (ifn->if_bpf) {
		struct enchdr hdr;

		bzero (&hdr, sizeof(hdr));

		hdr.af = tdb->tdb_dst.sa.sa_family;
		hdr.spi = tdb->tdb_spi;
		if (espx)
			hdr.flags |= M_CONF;
		if (esph)
			hdr.flags |= M_AUTH;

		bpf_mtap_hdr(ifn->if_bpf, (char *)&hdr, ENC_HDRLEN, m,
		    BPF_DIRECTION_OUT);
@


1.105
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.104 2007/11/19 11:03:21 mpf Exp $ */
d186 1
a186 1
			thash = &auth_hash_hmac_sha2_256_96;
d190 1
a190 1
			thash = &auth_hash_hmac_sha2_384_96;
d194 1
a194 1
			thash = &auth_hash_hmac_sha2_512_96;
d307 1
a307 5
	if (esph)
		alen = AH_HMAC_HASHLEN;
	else
		alen = 0;

d489 1
a489 1
	u_int8_t lastthree[3], aalg[AH_HMAC_HASHLEN];
d769 1
a769 5
	if (esph)
		alen = AH_HMAC_HASHLEN;
	else
		alen = 0;

@


1.104
log
@Remove the #define ENCDEBUG that slipped through somehow.
OK hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.103 2007/10/17 20:01:26 hshoexer Exp $ */
d907 1
a907 1
		arc4random_bytes((void *) pad, padding - 2);
@


1.103
log
@Convert MALLOC/FREE to malloc/free.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.102 2007/10/06 02:18:38 krw Exp $ */
a78 1
#define ENCDEBUG
@


1.102
log
@Oops. Forgot to do FREE -> free when I did MALLOC -> malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.101 2007/10/03 10:52:11 krw Exp $ */
d79 1
d222 2
a223 2
		MALLOC(tdbp->tdb_emxkey, u_int8_t *, tdbp->tdb_emxkeylen,
		    M_XDATA, M_WAITOK);
d243 1
a243 1
		MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
d269 1
a269 1
		FREE(tdbp->tdb_amxkey, M_XDATA);
d275 1
a275 1
		FREE(tdbp->tdb_emxkey, M_XDATA);
@


1.101
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.100 2006/12/15 09:32:30 otto Exp $ */
d514 1
a514 1
		FREE(tc, M_XDATA);
d525 1
a525 1
		FREE(tc, M_XDATA);
d543 1
a543 1
		FREE(tc, M_XDATA);
d565 1
a565 1
				FREE(tc, M_XDATA);
d576 1
a576 1
	FREE(tc, M_XDATA);
d1017 1
a1017 1
		FREE(tc, M_XDATA);
d1030 1
a1030 1
		FREE(tc, M_XDATA);
d1046 1
a1046 1
		FREE(tc, M_XDATA);
d1053 1
a1053 1
	FREE(tc, M_XDATA);
@


1.100
log
@make enc(4) count; ok markus@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.99 2006/09/21 11:10:52 otto Exp $ */
d411 1
a411 2
		MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
		    M_XDATA, M_NOWAIT);
d413 1
a413 2
		MALLOC(tc, struct tdb_crypto *,
		    sizeof(struct tdb_crypto) + alen, M_XDATA, M_NOWAIT);
a421 1
	bzero(tc, sizeof(struct tdb_crypto));
d961 1
a961 2
	MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
	    M_XDATA, M_NOWAIT);
a969 1
	bzero(tc, sizeof(struct tdb_crypto));
@


1.99
log
@ugly trailing ws; from bret dot lambert at gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.98 2006/05/28 02:04:15 mcbride Exp $ */
d742 3
@


1.98
log
@Only preemptively increase the replay counter for outbound TDBs.

Another ipsec failover fix from nathanael at polymorpheus dot com.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.97 2006/03/25 22:41:48 djm Exp $ */
d107 4
a110 4
		DPRINTF(("esp_init(): neither authentication nor encryption "       
		    "algorithm given"));                                            
		return EINVAL;                                                      
	}                                 
@


1.97
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.96 2005/12/20 13:36:28 markus Exp $ */
d591 1
a591 1
			pfsync_update_tdb(tdb);
d887 1
a887 1
		pfsync_update_tdb(tdb);
@


1.96
log
@use M_READONLY when trying to find out whether we have to copy
the mbuf before encryption.  otherwise mbufs with M_EXT but w/o M_CLUSTER
get modified; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.95 2005/08/05 12:16:13 markus Exp $ */
d755 2
a756 1
		bpf_mtap_hdr(ifn->if_bpf, (char *)&hdr, ENC_HDRLEN, m);
@


1.95
log
@don't panic for SADB_ADD w/o enc/auth, with and ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.94 2005/08/02 10:51:47 djm Exp $ */
d838 2
a839 2
	 * Loop through mbuf chain; if we find an M_EXT mbuf with
	 * more than one reference, replace the rest of the chain.
d843 1
a843 2
	while (mi != NULL &&
	    (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi))) {
@


1.94
log
@use arc4random for random packet padding (largely acedemic because it is
deprecated anyway); ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.93 2005/07/31 03:52:19 pascoe Exp $ */
d105 6
@


1.93
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.92 2005/05/28 15:10:07 ho Exp $ */
d901 1
a901 1
		get_random_bytes((void *) pad, padding - 2);
@


1.92
log
@Add SA replay counter synchronization to pfsync(4). Required for IPsec
failover gateways. ok mcbride@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.91 2005/05/27 18:23:18 markus Exp $ */
d734 2
d737 1
a737 3
#if NBPFILTER > 0
	{
		struct ifnet *ifn;
a738 1
		struct mbuf m1;
d749 1
a749 9
		m1.m_flags = 0;
		m1.m_next = m;
		m1.m_len = ENC_HDRLEN;
		m1.m_data = (char *) &hdr;

		ifn = &(encif[0].sc_if);

		if (ifn->if_bpf)
			bpf_mtap(ifn->if_bpf, &m1);
@


1.91
log
@comment out unused PACKET_TAG_IPSEC_IN_CRYPTO_DONE code; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.90 2005/05/25 05:47:53 markus Exp $ */
d38 2
d54 1
d69 5
d584 3
d889 3
@


1.90
log
@AESCTR support for ESP (RFC 3686); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.89 2005/05/10 13:42:11 markus Exp $ */
a278 1
	struct tdb_ident *tdbi;
d370 1
d375 2
d382 3
@


1.89
log
@support NULL encryption for ESP; ok hshoexer, ho
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.88 2003/12/10 07:22:43 itojun Exp $ */
d116 4
d152 1
a152 4
		if (ii->ii_encalg == SADB_EALG_NULL)
			tdbp->tdb_ivlen = 0;
		else
			tdbp->tdb_ivlen = txform->blocksize;
@


1.88
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.87 2003/08/14 19:00:12 jason Exp $ */
d100 4
d148 4
a151 1
		tdbp->tdb_ivlen = txform->blocksize;
@


1.87
log
@m_copyback()'s 4th arg is const void *, nuke (caddr_t) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.86 2003/07/24 09:59:02 itojun Exp $ */
d1121 2
a1122 2
	register struct mbuf *m0, *m1;
	register int len, pad;
@


1.86
log
@conform to RFC2367 on SADB_xx naming (local name must be prefixed with
SADB_X_xx)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.85 2003/07/24 08:03:20 itojun Exp $ */
d891 1
a891 1
	m_copyback(m, protoff, sizeof(u_int8_t), (u_char *) &prot);
@


1.85
log
@hmac-sha2-{256,384,512} support in AH/ESP auth.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.84 2003/07/09 18:21:16 markus Exp $ */
d159 1
a159 1
		case SADB_AALG_RIPEMD160HMAC:
d163 1
a163 1
		case SADB_AALG_SHA2_256:
d167 1
a167 1
		case SADB_AALG_SHA2_384:
d171 1
a171 1
		case SADB_AALG_SHA2_512:
@


1.84
log
@fix whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.83 2003/05/03 01:43:07 itojun Exp $ */
d161 12
@


1.83
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.82 2003/04/02 20:09:26 millert Exp $ */
d600 12
a611 8
			/*
			 * Part or all of the ESP header is at the end of this mbuf, so
			 * first let's remove the remainder of the ESP header from the
			 * beginning of the remainder of the mbuf chain, if any.
			 */
			if (roff + hlen > m1->m_len) {
				/* Adjust the next mbuf by the remainder */
				m_adj(m1->m_next, roff + hlen - m1->m_len);
d613 3
a615 3
				/* The second mbuf is guaranteed not to have a pkthdr... */
				m->m_pkthdr.len -= (roff + hlen - m1->m_len);
			}
d617 4
a620 8
			/* Now, let's unlink the mbuf chain for a second...*/
			mo = m1->m_next;
			m1->m_next = NULL;

			/* ...and trim the end of the first part of the chain...sick */
			m_adj(m1, -(m1->m_len - roff));
			if (!(m1->m_flags & M_PKTHDR))
				m->m_pkthdr.len -= (m1->m_len - roff);
d622 2
a623 2
			/* Finally, let's relink */
			m1->m_next = mo;
@


1.82
log
@o sanity check mbuf earlier.
o return errno, not NULL.
o add some missing error values
o proper crypto_freereq() in ip_ipcomp.c
From Patrick Latifi; OK angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.81 2003/03/31 20:52:06 millert Exp $ */
d714 1
@


1.81
log
@Avoid using FREEd data when we get a crypto error; Patrick Latifi
Also move the session ID reset into the crp_etype == EAGAIN case
(noticed by angelos@@).  OK jason@@ and angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.80 2003/02/28 21:42:56 jason Exp $ */
d474 1
d476 8
a513 9
	/* Shouldn't happen... */
	if (m == NULL) {
		FREE(tc, M_XDATA);
		espstat.esps_crypto++;
		DPRINTF(("esp_input_cb(): bogus returned buffer from crypto\n"));
		error = EINVAL;
		goto baddone;
	}

a539 1

d978 1
d980 10
a1016 10
	} else
		FREE(tc, M_XDATA);

	/* Shouldn't happen... */
	if (m == NULL) {
		espstat.esps_crypto++;
		DPRINTF(("esp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		error = EINVAL;
		goto baddone;
d1018 1
@


1.80
log
@Based on several comments from tedu:
- two variables 'err' and 'error', whacked
- missing initialization in the error path for the case where an SA expired
  while off in crypto land.
- a small bit of knf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.79 2003/02/21 20:50:58 tedu Exp $ */
a490 6
		FREE(tc, M_XDATA);

		/* Reset the session ID */
		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;

d492 3
d498 1
a498 1

a993 4
		/* Reset session ID. */
		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;

d995 3
a1000 1

@


1.79
log
@kill unused variables

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.78 2003/02/12 14:41:07 jason Exp $ */
d458 1
a458 1
	int hlen, roff, skip, protoff, error;
a465 1
	int s, err = 0;
d483 1
d670 1
a670 1
	err = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
d672 1
a672 1
	return err;
d682 1
a682 1
	return error;
d991 1
@


1.78
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.77 2003/02/01 14:11:40 dhartmei Exp $ */
a459 1
	struct cryptodesc *crd;
a460 1
	struct enc_xform *espx;
a469 1
	crd = crp->crp_desc;
a487 1
	espx = (struct enc_xform *) tdb->tdb_encalgxform;
d694 1
a694 1
	int ilen, hlen, rlen, plen, padding, blks, alen;
a740 1
	plen = rlen + padding; /* Padded payload length. */
@


1.77
log
@m_pad() is expected to have free'd the mbuf if it returns NULL, so
free it in one (rare) error condition. ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.76 2002/11/07 15:16:39 ho Exp $ */
d76 2
@


1.76
log
@Check for invalid payload lengths also for NULL enc. markus@@, angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.75 2002/07/30 19:09:36 jason Exp $ */
d1120 1
@


1.75
log
@Be sure to check the integrity verifier for packets that didn't have it done
in hardware; from angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.74 2002/07/05 23:20:53 angelos Exp $ */
d277 8
d290 1
a290 2
		plen = m->m_pkthdr.len - (skip + hlen + alen);
		if ((plen & (espx->blocksize - 1)) || (plen <= 0)) {
@


1.75.2.1
log
@Pull in patch from current:
Fix (ho):
Check for invalid payload lengths also for NULL enc. markus@@, angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.75 2002/07/30 19:09:36 jason Exp $ */
a276 8
	plen = m->m_pkthdr.len - (skip + hlen + alen);
	if (plen <= 0) {
		DPRINTF(("esp_input: invalid payload length\n"));
		espstat.esps_badilen++;
		m_freem(m);
		return EINVAL;
	}

d282 2
a283 1
		if (plen & (espx->blocksize - 1)) {
@


1.74
log
@Free crp_opaque only after we've determined we're not going to
re-submit it. From sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.73 2002/06/18 23:03:26 angelos Exp $ */
d518 1
a518 1
		if (mtag != NULL) {
@


1.73
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.72 2002/06/18 22:48:16 angelos Exp $ */
a982 1
	FREE(tc, M_XDATA);
d984 1
d1001 1
d1007 2
a1008 1
	}
@


1.72
log
@Initialize mo to NULL, for good measure -- sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.71 2002/06/18 19:25:48 angelos Exp $ */
d96 2
a97 4
	if (ii->ii_encalg)
	{
		switch (ii->ii_encalg)
		{
d127 1
a127 2
		if (ii->ii_enckeylen < txform->minkey)
		{
d132 1
a132 2
		if (ii->ii_enckeylen > txform->maxkey)
		{
d147 2
a148 4
	if (ii->ii_authalg)
	{
		switch (ii->ii_authalg)
		{
d166 1
a166 2
		if (ii->ii_authkeylen != thash->keysize)
		{
d182 1
a182 2
	if (tdbp->tdb_encalgxform)
	{
d185 2
a186 2
		MALLOC(tdbp->tdb_emxkey, u_int8_t *, tdbp->tdb_emxkeylen, M_XDATA,
		    M_WAITOK);
d203 1
a203 2
	if (tdbp->tdb_authalgxform)
	{
d230 1
a230 2
	if (tdbp->tdb_amxkey)
	{
d236 1
a236 2
	if (tdbp->tdb_emxkey)
	{
d277 1
a277 2
	if (espx)
	{
d283 1
a283 2
		if ((plen & (espx->blocksize - 1)) || (plen <= 0))
		{
d292 1
a292 2
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY)))
	{
d298 1
a298 2
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 0))
		{
d328 1
a328 2
	    (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
	{
d337 1
a337 2
	    (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
	{
d345 1
a345 2
	     mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, mtag))
	{
d354 1
a354 2
	if (crp == NULL)
	{
d366 3
a368 4
		MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto) + alen,
		    M_XDATA, M_NOWAIT);
	if (tc == NULL)
	{
d379 1
a379 2
	if (esph)
	{
d395 1
a395 2
	}
	else
d414 1
a414 2
	if (espx)
	{
d419 1
a419 2
		if (tdb->tdb_flags & TDBF_HALFIV)
		{
d474 1
a474 2
	if (tdb == NULL)
	{
d485 1
a485 2
	if (crp->crp_etype)
	{
d492 1
a492 2
		if (crp->crp_etype == EAGAIN)
		{
d504 1
a504 2
	if (m == NULL)
	{
d513 1
a513 2
	if (esph != NULL)
	{
d518 1
a518 2
		if (mtag != NULL)
		{
d520 2
a521 2
			m_copydata(m, m->m_pkthdr.len - esph->authsize, esph->authsize,
			    aalg);
d526 1
a526 2
			if (bcmp(ptr, aalg, esph->authsize))
			{
d542 1
a542 2
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY)))
	{
d548 1
a548 2
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 1))
		{
d583 1
a583 2
	if (m1 == NULL)
	{
d593 1
a593 2
	if (roff == 0)
	{
d598 1
a598 4
	}
	else
		if (roff + hlen >= m1->m_len)
		{
d604 1
a604 2
			if (roff + hlen > m1->m_len)
			{
d623 11
a633 13
		}
		else
		{
			/*
			 * The ESP header lies in the "middle" of the mbuf...do an
			 * overlapping copy of the remainder of the mbuf over the ESP
			 * header.
			 */
			bcopy(mtod(m1, u_char *) + roff + hlen, mtod(m1, u_char *) + roff,
			    m1->m_len - (roff + hlen));
			m1->m_len -= hlen;
			m->m_pkthdr.len -= hlen;
		}
d639 1
a639 2
	if (lastthree[1] + 2 > m->m_pkthdr.len - skip)
	{
d648 2
a649 4
	if (!(tdb->tdb_flags & TDBF_RANDOMPADDING))
	{
		if ((lastthree[1] != lastthree[0]) && (lastthree[1] != 0))
		{
@


1.71
log
@Same as with ip_ah.c (fix unreachable reference-after-free)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.70 2002/05/31 02:22:21 angelos Exp $ */
d851 1
@


1.70
log
@Fix a DoS attack whereby an attacker could cause the replay counter to
advance with unauthenticated packets, thereby causing valid packets to
be discarded as replays. This has been sitting in my tree for a while,
and I've forgotten who it was that pointed out the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.69 2001/06/26 06:18:59 angelos Exp $ */
a497 1
	FREE(tc, M_XDATA);
d500 1
d512 2
d533 1
d558 1
d570 2
a1025 1

@


1.69
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.68 2001/06/25 05:11:58 angelos Exp $ */
d304 1
a304 1
	/* Replay window checking, if appropriate */
d311 2
a312 2
		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl), tdb->tdb_wnd,
		    &(tdb->tdb_bitmap)))
d318 1
a320 1
			m_freem(m);
a325 1
			espstat.esps_replay++;
d330 1
a332 1
			m_freem(m);
d482 1
d566 33
a782 13
	/*
	 * Check for replay counter wrap-around in automatic (not
	 * manual) keying.
	 */
	if ((!(tdb->tdb_flags & TDBF_NOREPLAY)) &&
	    (tdb->tdb_rpl == 0) && (tdb->tdb_wnd > 0)) {
		DPRINTF(("esp_output(): SA %s/%08x should have expired\n",
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_wrap++;
		return EACCES;
	}

d879 1
a879 1
		espstat.esps_wrap++;
d1091 1
a1091 1
    u_int32_t window, u_int32_t *bitmap)
d1093 10
a1102 1
	u_int32_t diff;
@


1.69.6.1
log
@Pull in patch from current:
Fix (ho):
Check for invalid payload lengths also for NULL enc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.69 2001/06/26 06:18:59 angelos Exp $ */
a287 8
	plen = m->m_pkthdr.len - (skip + hlen + alen);
	if (plen <= 0) {
		DPRINTF(("esp_input: invalid payload length\n"));
		espstat.esps_badilen++;
		m_freem(m);
		return EINVAL;
	}

d294 2
a295 1
		if (plen & (espx->blocksize - 1))
@


1.69.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.69 2001/06/26 06:18:59 angelos Exp $ */
d304 1
a304 1
	/* Replay window checking, if appropriate -- no value commitment. */
d311 2
a312 2
		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 0))
a317 1
			m_freem(m);
d320 1
d326 1
a330 1
			m_freem(m);
d333 1
a482 1
	u_int32_t btsx;
a565 33
	/* Replay window checking, if appropriate */
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY)))
	{
		m_copydata(m, skip + sizeof(u_int32_t), sizeof(u_int32_t),
		    (unsigned char *) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 1))
		{
		case 0: /* All's well */
			break;

		case 1:
			DPRINTF(("esp_input_cb(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_wrap++;
			error = EACCES;
			goto baddone;

		case 2:
		case 3:
			DPRINTF(("esp_input_cb(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			error = EACCES;
			goto baddone;

		default:
			DPRINTF(("esp_input_cb(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			error = EACCES;
			goto baddone;
		}
	}

d750 13
d859 1
a859 1
		espstat.esps_hdrops++;
d1071 1
a1071 1
    u_int32_t window, u_int32_t *bitmap, int commit)
d1073 1
a1073 10
	u_int32_t diff, llseq, lbitmap;

	/* Just do the checking, without "committing" any changes. */
	if (commit == 0) {
		llseq = *lastseq;
		lbitmap = *bitmap;

		lastseq = &llseq;
		bitmap = &lbitmap;
	}
@


1.69.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.69.4.1 2002/06/11 03:31:36 art Exp $ */
d96 4
a99 2
	if (ii->ii_encalg) {
		switch (ii->ii_encalg) {
d129 2
a130 1
		if (ii->ii_enckeylen < txform->minkey) {
d135 2
a136 1
		if (ii->ii_enckeylen > txform->maxkey) {
d151 4
a154 2
	if (ii->ii_authalg) {
		switch (ii->ii_authalg) {
d172 2
a173 1
		if (ii->ii_authkeylen != thash->keysize) {
d189 2
a190 1
	if (tdbp->tdb_encalgxform) {
d193 2
a194 2
		MALLOC(tdbp->tdb_emxkey, u_int8_t *, tdbp->tdb_emxkeylen,
		    M_XDATA, M_WAITOK);
d211 2
a212 1
	if (tdbp->tdb_authalgxform) {
d239 2
a240 1
	if (tdbp->tdb_amxkey) {
d246 2
a247 1
	if (tdbp->tdb_emxkey) {
d288 2
a289 1
	if (espx) {
d295 2
a296 1
		if ((plen & (espx->blocksize - 1)) || (plen <= 0)) {
d305 2
a306 1
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
d312 2
a313 1
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 0)) {
d343 2
a344 1
	    (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))	{
d353 2
a354 1
	    (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)) {
d362 2
a363 1
	     mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, mtag)) {
d372 2
a373 1
	if (crp == NULL) {
d385 4
a388 3
		MALLOC(tc, struct tdb_crypto *,
		    sizeof(struct tdb_crypto) + alen, M_XDATA, M_NOWAIT);
	if (tc == NULL)	{
d399 2
a400 1
	if (esph) {
d416 2
a417 1
	} else
d436 2
a437 1
	if (espx) {
d442 2
a443 1
		if (tdb->tdb_flags & TDBF_HALFIV) {
d498 3
a500 2
	if (tdb == NULL) {
		FREE(tc, M_XDATA);
d510 2
a511 3
	if (crp->crp_etype) {
		FREE(tc, M_XDATA);

d516 2
a517 1
		if (crp->crp_etype == EAGAIN) {
d529 2
a530 2
	if (m == NULL) {
		FREE(tc, M_XDATA);
d538 2
a539 1
	if (esph != NULL) {
d544 2
a545 1
		if (mtag == NULL) {
d547 2
a548 2
			m_copydata(m, m->m_pkthdr.len - esph->authsize,
			    esph->authsize, aalg);
d553 2
a554 2
			if (bcmp(ptr, aalg, esph->authsize)) {
				FREE(tc, M_XDATA);
a565 2
	FREE(tc, M_XDATA);

d567 2
a568 1
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
d574 2
a575 1
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 1)) {
d610 2
a611 1
	if (m1 == NULL)	{
d621 2
a622 1
	if (roff == 0) {
d627 4
a630 1
	} else if (roff + hlen >= m1->m_len) {
d636 2
a637 1
			if (roff + hlen > m1->m_len) {
d656 13
a668 11
	} else {
		/*
		 * The ESP header lies in the "middle" of the mbuf...do an
		 * overlapping copy of the remainder of the mbuf over the ESP
		 * header.
		 */
		bcopy(mtod(m1, u_char *) + roff + hlen,
		    mtod(m1, u_char *) + roff, m1->m_len - (roff + hlen));
		m1->m_len -= hlen;
		m->m_pkthdr.len -= hlen;
	}
d674 2
a675 1
	if (lastthree[1] + 2 > m->m_pkthdr.len - skip) {
d684 4
a687 2
	if (!(tdb->tdb_flags & TDBF_RANDOMPADDING)) {
		if ((lastthree[1] != lastthree[0]) && (lastthree[1] != 0)) {
a844 1
	mo = NULL;
d1020 2
a1022 1
		FREE(tc, M_XDATA);
a1038 1
		FREE(tc, M_XDATA);
d1044 1
a1044 2
	} else
		FREE(tc, M_XDATA);
@


1.69.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a76 2
struct espstat espstat;

a276 8
	plen = m->m_pkthdr.len - (skip + hlen + alen);
	if (plen <= 0) {
		DPRINTF(("esp_input: invalid payload length\n"));
		espstat.esps_badilen++;
		m_freem(m);
		return EINVAL;
	}

d282 2
a283 1
		if (plen & (espx->blocksize - 1)) {
d449 1
a449 1
	int s, hlen, roff, skip, protoff, error;
d451 1
d453 1
d459 1
d463 1
a468 1

a469 8
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		espstat.esps_crypto++;
		DPRINTF(("esp_input_cb(): bogus returned buffer from crypto\n"));
		return (EINVAL);
	}
a477 1
		error = EPERM;
d482 1
d486 6
a492 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d496 1
a496 1
		FREE(tc, M_XDATA);
d503 9
d538 1
d665 1
a665 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
d667 1
a667 1
	return (error);
d677 1
a677 1
	return (error);
d689 1
a689 1
	int ilen, hlen, rlen, padding, blks, alen;
a712 1
		m1.m_flags = 0;
d736 1
a977 1

a978 10
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		espstat.esps_crypto++;
		DPRINTF(("esp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		return (EINVAL);
	}

a986 1
		error = EPERM;
d992 4
a996 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d1000 1
d1007 10
a1017 1
	FREE(tc, M_XDATA);
a1112 1
		m_freem(m);
@


1.68
log
@Copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.67 2001/06/23 18:30:38 deraadt Exp $ */
d83 1
a83 1
    return 0;
d92 3
a94 36
    struct enc_xform *txform = NULL;
    struct auth_hash *thash = NULL;
    struct cryptoini cria, crie;

    if (ii->ii_encalg)
    {
	switch (ii->ii_encalg)
	{
	    case SADB_EALG_DESCBC:
		txform = &enc_xform_des;
		break;

	    case SADB_EALG_3DESCBC:
		txform = &enc_xform_3des;
		break;

	    case SADB_X_EALG_AES:
		txform = &enc_xform_rijndael128;
		break;

	    case SADB_X_EALG_BLF:
		txform = &enc_xform_blf;
		break;

	    case SADB_X_EALG_CAST:
		txform = &enc_xform_cast5;
		break;

	    case SADB_X_EALG_SKIPJACK:
		txform = &enc_xform_skipjack;
		break;

	    default:
		DPRINTF(("esp_init(): unsupported encryption algorithm %d specified\n", ii->ii_encalg));
		return EINVAL;
	}
d96 1
a96 1
	if (ii->ii_enckeylen < txform->minkey)
d98 51
a148 2
	    DPRINTF(("esp_init(): keylength %d too small (min length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->minkey, txform->name));
	    return EINVAL;
d151 1
a151 1
	if (ii->ii_enckeylen > txform->maxkey)
d153 24
a176 3
	    DPRINTF(("esp_init(): keylength %d too large (max length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->maxkey, txform->name));
	    return EINVAL;
	}
d178 1
a178 1
        tdbp->tdb_encalgxform = txform;
d180 3
a182 2
        DPRINTF(("esp_init(): initialized TDB with enc algorithm %s\n",
	         txform->name));
d184 3
a186 4
        tdbp->tdb_ivlen = txform->blocksize;
        if (tdbp->tdb_flags & TDBF_HALFIV)
          tdbp->tdb_ivlen /= 2;
    }
d188 2
a189 3
    if (ii->ii_authalg)
    {
	switch (ii->ii_authalg)
d191 18
a208 15
	    case SADB_AALG_MD5HMAC:
		thash = &auth_hash_hmac_md5_96;
		break;

	    case SADB_AALG_SHA1HMAC:
		thash = &auth_hash_hmac_sha1_96;
		break;

	    case SADB_AALG_RIPEMD160HMAC:
		thash = &auth_hash_hmac_ripemd_160_96;
		break;

	    default:
		DPRINTF(("esp_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
		return EINVAL;
d211 1
a211 1
	if (ii->ii_authkeylen != thash->keysize)
d213 12
a224 2
	    DPRINTF(("esp_init(): keylength %d doesn't match algorithm %s keysize (%d)\n", ii->ii_authkeylen, thash->name, thash->keysize));
	    return EINVAL;
d227 2
a228 51
    	tdbp->tdb_authalgxform = thash;

	DPRINTF(("esp_init(): initialized TDB with hash algorithm %s\n",
		 thash->name));
    }

    tdbp->tdb_xform = xsp;
    tdbp->tdb_bitmap = 0;
    tdbp->tdb_rpl = AH_HMAC_INITIAL_RPL;

    /* Initialize crypto session */
    if (tdbp->tdb_encalgxform)
    {
	/* Save the raw keys */
	tdbp->tdb_emxkeylen = ii->ii_enckeylen;
	MALLOC(tdbp->tdb_emxkey, u_int8_t *, tdbp->tdb_emxkeylen, M_XDATA,
	       M_WAITOK);
	bcopy(ii->ii_enckey, tdbp->tdb_emxkey, tdbp->tdb_emxkeylen);

	bzero(&crie, sizeof(crie));

	crie.cri_alg = tdbp->tdb_encalgxform->type;

	if (tdbp->tdb_authalgxform)
	  crie.cri_next = &cria;
	else
	  crie.cri_next = NULL;

	crie.cri_klen = ii->ii_enckeylen * 8;
	crie.cri_key = ii->ii_enckey;
	/* XXX Rounds ? */
    }

    if (tdbp->tdb_authalgxform)
    {
	/* Save the raw keys */
	tdbp->tdb_amxkeylen = ii->ii_authkeylen;
	MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
	       M_WAITOK);
	bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);

	bzero(&cria, sizeof(cria));

	cria.cri_alg = tdbp->tdb_authalgxform->type;
	cria.cri_next = NULL;
	cria.cri_klen = ii->ii_authkeylen * 8;
	cria.cri_key = ii->ii_authkey;
    }

    return crypto_newsession(&tdbp->tdb_cryptoid,
      (tdbp->tdb_encalgxform ? &crie : &cria), 0);
d237 15
a251 1
    int err;
d253 3
a255 17
    if (tdbp->tdb_amxkey)
    {
	bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
	FREE(tdbp->tdb_amxkey, M_XDATA);
	tdbp->tdb_amxkey = NULL;
    }

    if (tdbp->tdb_emxkey)
    {
	bzero(tdbp->tdb_emxkey, tdbp->tdb_emxkeylen);
	FREE(tdbp->tdb_emxkey, M_XDATA);
	tdbp->tdb_emxkey = NULL;
    }

    err = crypto_freesession(tdbp->tdb_cryptoid);
    tdbp->tdb_cryptoid = 0;
    return err;
d266 21
a286 21
    struct auth_hash *esph = (struct auth_hash *) tdb->tdb_authalgxform;
    struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
    struct tdb_ident *tdbi;
    struct tdb_crypto *tc;
    int plen, alen, hlen;
    struct m_tag *mtag;
    u_int32_t btsx;

    struct cryptodesc *crde = NULL, *crda = NULL;
    struct cryptop *crp;

    /* Determine the ESP header length */
    if (tdb->tdb_flags & TDBF_NOREPLAY)
      hlen = sizeof(u_int32_t) + tdb->tdb_ivlen; /* "old" ESP */
    else
      hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; /* "new" ESP */

    if (esph)
      alen = AH_HMAC_HASHLEN;
    else
      alen = 0;
d288 1
a288 8
    if (espx)
    {
	/*
	 * Verify payload length is multiple of encryption algorithm
	 * block size.
	 */
	plen = m->m_pkthdr.len - (skip + hlen + alen);
	if ((plen & (espx->blocksize - 1)) || (plen <= 0))
d290 13
a302 13
	    DPRINTF(("esp_input(): payload of %d octets not a multiple of %d octets, SA %s/%08x\n", plen, espx->blocksize, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_badilen++;
	    m_freem(m);
	    return EINVAL;
	}
    }

    /* Replay window checking, if appropriate */
    if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY)))
    {
	m_copydata(m, skip + sizeof(u_int32_t), sizeof(u_int32_t),
		   (unsigned char *) &btsx);
	btsx = ntohl(btsx);
d304 2
a305 2
	switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl), tdb->tdb_wnd,
				    &(tdb->tdb_bitmap)))
d307 30
a336 2
	    case 0: /* All's well */
		break;
d338 10
a347 3
	    case 1:
		DPRINTF(("esp_input(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		espstat.esps_wrap++;
d349 21
a369 1
		return EACCES;
d371 4
a374 4
	    case 2:
	    case 3:
		DPRINTF(("esp_input(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		espstat.esps_replay++;
d376 4
a379 1
		return EACCES;
d381 9
a389 3
	    default:
		DPRINTF(("esp_input(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		espstat.esps_replay++;
d391 26
a416 1
		return EACCES;
d418 2
a419 1
    }
d421 39
a459 75
    /* Update the counters */
    tdb->tdb_cur_bytes += m->m_pkthdr.len - skip - hlen - alen;
    espstat.esps_ibytes += m->m_pkthdr.len - skip - hlen - alen;

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb);
	m_freem(m);
	return ENXIO;
    }

    /* Notify on soft expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;       /* Turn off checking */
    }

    /* Find out if we've already done crypto */
    for (mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, NULL);
	 mtag != NULL;
	 mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, mtag))
    {
	tdbi = (struct tdb_ident *) (mtag + 1);
	if (tdbi->proto == tdb->tdb_sproto && tdbi->spi == tdb->tdb_spi &&
	    !bcmp(&tdbi->dst, &tdb->tdb_dst, sizeof(union sockaddr_union)))
	  break;
    }

    /* Get crypto descriptors */
    crp = crypto_getreq(esph && espx ? 2 : 1);
    if (crp == NULL)
    {
	m_freem(m);
	DPRINTF(("esp_input(): failed to acquire crypto descriptors\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
    }

    /* Get IPsec-specific opaque pointer */
    if (esph == NULL || mtag != NULL)
      MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
	     M_XDATA, M_NOWAIT);
    else
      MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto) + alen,
	     M_XDATA, M_NOWAIT);
    if (tc == NULL)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("esp_input(): failed to allocate tdb_crypto\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
    }

    bzero(tc, sizeof(struct tdb_crypto));
    tc->tc_ptr = (caddr_t) mtag;

    if (esph)
    {
	crda = crp->crp_desc;
	crde = crda->crd_next;

	/* Authentication descriptor */
	crda->crd_skip = skip;
	crda->crd_len = m->m_pkthdr.len - (skip + alen);
	crda->crd_inject = m->m_pkthdr.len - alen;

	crda->crd_alg = esph->type;
	crda->crd_key = tdb->tdb_amxkey;
	crda->crd_klen = tdb->tdb_amxkeylen * 8;
a460 1
	/* Copy the authenticator */
d462 3
a464 49
	  m_copydata(m, m->m_pkthdr.len - alen, alen, (caddr_t) (tc + 1));
    }
    else
      crde = crp->crp_desc;

    /* Crypto operation descriptor */
    crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
    crp->crp_flags = CRYPTO_F_IMBUF;
    crp->crp_buf = (caddr_t) m;
    crp->crp_callback = (int (*) (struct cryptop *)) esp_input_cb;
    crp->crp_sid = tdb->tdb_cryptoid;
    crp->crp_opaque = (caddr_t) tc;

    /* These are passed as-is to the callback */
    tc->tc_skip = skip;
    tc->tc_protoff = protoff;
    tc->tc_spi = tdb->tdb_spi;
    tc->tc_proto = tdb->tdb_sproto;
    bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

    /* Decryption descriptor */
    if (espx)
    {
	crde->crd_skip = skip + hlen;
	crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
	crde->crd_inject = skip + hlen - tdb->tdb_ivlen;

        if (tdb->tdb_flags & TDBF_HALFIV)
	{
	    /* Copy half-IV from packet */
	    m_copydata(m, crde->crd_inject, tdb->tdb_ivlen, crde->crd_iv);

	    /* Cook IV */
	    for (btsx = 0; btsx < tdb->tdb_ivlen; btsx++)
	      crde->crd_iv[tdb->tdb_ivlen + btsx] = ~crde->crd_iv[btsx];

	    crde->crd_flags |= CRD_F_IV_EXPLICIT;
	}

	crde->crd_alg = espx->type;
	crde->crd_key = tdb->tdb_emxkey;
	crde->crd_klen = tdb->tdb_emxkeylen * 8;
	/* XXX Rounds ? */
    }

    if (mtag == NULL)
      return crypto_dispatch(crp);
    else
      return esp_input_cb(crp);
d473 57
a529 72
    u_int8_t lastthree[3], aalg[AH_HMAC_HASHLEN];
    int hlen, roff, skip, protoff, error;
    struct mbuf *m1, *mo, *m;
    struct cryptodesc *crd;
    struct auth_hash *esph;
    struct enc_xform *espx;
    struct tdb_crypto *tc;
    struct cryptop *crp;
    struct m_tag *mtag;
    struct tdb *tdb;
    int s, err = 0;
    caddr_t ptr;

    crp = (struct cryptop *) op;
    crd = crp->crp_desc;

    tc = (struct tdb_crypto *) crp->crp_opaque;
    skip = tc->tc_skip;
    protoff = tc->tc_protoff;
    mtag = (struct m_tag *) tc->tc_ptr;
    m = (struct mbuf *) crp->crp_buf;

    s = spltdb();

    tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
    FREE(tc, M_XDATA);
    if (tdb == NULL)
    {
	espstat.esps_notdb++;
	DPRINTF(("esp_input_cb(): TDB is expired while in crypto"));
	goto baddone;
    }

    esph = (struct auth_hash *) tdb->tdb_authalgxform;
    espx = (struct enc_xform *) tdb->tdb_encalgxform;

    /* Check for crypto errors */
    if (crp->crp_etype)
    {
	/* Reset the session ID */
	if (tdb->tdb_cryptoid != 0)
	  tdb->tdb_cryptoid = crp->crp_sid;

	if (crp->crp_etype == EAGAIN)
        {
            splx(s);
	    return crypto_dispatch(crp);
        }

	espstat.esps_noxform++;
	DPRINTF(("esp_input_cb(): crypto error %d\n", crp->crp_etype));
	error = crp->crp_etype;
	goto baddone;
    }

    /* Shouldn't happen... */
    if (m == NULL)
    {
	espstat.esps_crypto++;
	DPRINTF(("esp_input_cb(): bogus returned buffer from crypto\n"));
	error = EINVAL;
	goto baddone;
    }

    /* If authentication was performed, check now. */
    if (esph != NULL)
    {
        /*
	 * If we have a tag, it means an IPsec-aware NIC did the verification
	 * for us.
	 */
	if (mtag != NULL)
d531 3
a533 12
	    /* Copy the authenticator from the packet */
	    m_copydata(m, m->m_pkthdr.len - esph->authsize, esph->authsize,
		       aalg);

	    ptr = (caddr_t) (tc + 1);

	    /* Verify authenticator */
	    if (bcmp(ptr, aalg, esph->authsize))
	    {
		DPRINTF(("esp_input_cb(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		espstat.esps_badauth++;
		error = EACCES;
a534 1
	    }
d537 136
a672 111
	/* Remove trailing authenticator */
	m_adj(m, -(esph->authsize));
    }

    /* Release the crypto descriptors */
    crypto_freereq(crp);

    /* Determine the ESP header length */
    if (tdb->tdb_flags & TDBF_NOREPLAY)
      hlen = sizeof(u_int32_t) + tdb->tdb_ivlen; /* "old" ESP */
    else
      hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; /* "new" ESP */

    /* Find beginning of ESP header */
    m1 = m_getptr(m, skip, &roff);
    if (m1 == NULL)
    {
	espstat.esps_hdrops++;
        splx(s);
	DPRINTF(("esp_input_cb(): bad mbuf chain, SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	return EINVAL;
    }

    /* Remove the ESP header and IV from the mbuf. */
    if (roff == 0)
    {
	/* The ESP header was conveniently at the beginning of the mbuf */
	m_adj(m1, hlen);
	if (!(m1->m_flags & M_PKTHDR))
	  m->m_pkthdr.len -= hlen;
    }
    else
      if (roff + hlen >= m1->m_len)
      {
	  /*
	   * Part or all of the ESP header is at the end of this mbuf, so
	   * first let's remove the remainder of the ESP header from the
	   * beginning of the remainder of the mbuf chain, if any.
	   */
	  if (roff + hlen > m1->m_len)
	  {
	      /* Adjust the next mbuf by the remainder */
	      m_adj(m1->m_next, roff + hlen - m1->m_len);

	      /* The second mbuf is guaranteed not to have a pkthdr... */
	      m->m_pkthdr.len -= (roff + hlen - m1->m_len);
	  }

	  /* Now, let's unlink the mbuf chain for a second...*/
	  mo = m1->m_next;
	  m1->m_next = NULL;

	  /* ...and trim the end of the first part of the chain...sick */
	  m_adj(m1, -(m1->m_len - roff));
	  if (!(m1->m_flags & M_PKTHDR))
	    m->m_pkthdr.len -= (m1->m_len - roff);

	  /* Finally, let's relink */
	  m1->m_next = mo;
      }
      else
      {
	  /*
	   * The ESP header lies in the "middle" of the mbuf...do an
	   * overlapping copy of the remainder of the mbuf over the ESP
	   * header.
	   */
	  bcopy(mtod(m1, u_char *) + roff + hlen, mtod(m1, u_char *) + roff,
		m1->m_len - (roff + hlen));
	  m1->m_len -= hlen;
	  m->m_pkthdr.len -= hlen;
      }

    /* Save the last three bytes of decrypted data */
    m_copydata(m, m->m_pkthdr.len - 3, 3, lastthree);

    /* Verify pad length */
    if (lastthree[1] + 2 > m->m_pkthdr.len - skip)
    {
	espstat.esps_badilen++;
        splx(s);
	DPRINTF(("esp_input_cb(): invalid padding length %d for packet in SA %s/%08x\n", lastthree[1], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	return EINVAL;
    }

    /* Verify correct decryption by checking the last padding bytes */
    if (!(tdb->tdb_flags & TDBF_RANDOMPADDING))
    {
	if ((lastthree[1] != lastthree[0]) && (lastthree[1] != 0))
	{
	    espstat.esps_badenc++;
            splx(s);
	    DPRINTF(("esp_input(): decryption failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    m_freem(m);
	    return EINVAL;
	}
    }

    /* Trim the mbuf chain to remove the trailing authenticator and padding */
    m_adj(m, -(lastthree[1] + 2));

    /* Restore the Next Protocol field */
    m_copyback(m, protoff, sizeof(u_int8_t), lastthree + 2);

    /* Back to generic IPsec input processing */
    err = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
    splx(s);
    return err;
d675 1
a675 1
    splx(s);
d677 2
a678 2
    if (m)
      m_freem(m);
d680 1
a680 1
    crypto_freereq(crp);
d682 1
a682 1
    return error;
d690 1
a690 1
	   int protoff)
d692 7
a698 7
    struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
    struct auth_hash *esph = (struct auth_hash *) tdb->tdb_authalgxform;
    int ilen, hlen, rlen, plen, padding, blks, alen;
    struct mbuf *mi, *mo = (struct mbuf *) NULL;
    struct tdb_crypto *tc;
    unsigned char *pad;
    u_int8_t prot;
d700 2
a701 2
    struct cryptodesc *crde = NULL, *crda = NULL;
    struct cryptop *crp;
d704 19
a722 4
    {
	struct ifnet *ifn;
	struct enchdr hdr;
	struct mbuf m1;
d724 9
a732 1
	bzero (&hdr, sizeof(hdr));
d734 1
a734 2
	hdr.af = tdb->tdb_dst.sa.sa_family;
	hdr.spi = tdb->tdb_spi;
d736 3
a738 3
	  hdr.flags |= M_CONF;
	if (esph)
	  hdr.flags |= M_AUTH;
d740 2
a741 3
	m1.m_next = m;
	m1.m_len = ENC_HDRLEN;
	m1.m_data = (char *) &hdr;
d743 4
a746 1
	ifn = &(encif[0].sc_if);
d748 1
a748 4
	if (ifn->if_bpf)
	  bpf_mtap(ifn->if_bpf, &m1);
    }
#endif
d750 12
a761 31
    if (tdb->tdb_flags & TDBF_NOREPLAY)
      hlen = sizeof(u_int32_t) + tdb->tdb_ivlen;
    else
      hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen;

    rlen = m->m_pkthdr.len - skip; /* Raw payload length */
    if (espx)
      blks = espx->blocksize;
    else
      blks = 4; /* If no encryption is used, we have to be 4-byte aligned */

    padding = ((blks - ((rlen + 2) % blks)) % blks) + 2;
    plen = rlen + padding; /* Padded payload length */

    if (esph)
      alen = AH_HMAC_HASHLEN;
    else
      alen = 0;

    espstat.esps_output++;

    /* Check for replay counter wrap-around in automatic (not manual) keying */
    if ((!(tdb->tdb_flags & TDBF_NOREPLAY)) &&
	(tdb->tdb_rpl == 0) && (tdb->tdb_wnd > 0))
    {
	DPRINTF(("esp_output(): SA %s/%08x should have expired\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	espstat.esps_wrap++;
	return EACCES;
    }
d763 1
a763 2
    switch (tdb->tdb_dst.sa.sa_family)
    {
d766 10
a775 10
	    /* Check for IP maximum packet size violations */
	    if (skip + hlen + rlen + padding + alen > IP_MAXPACKET)
	    {
		DPRINTF(("esp_output(): packet in SA %s/%08x got too big\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_toobig++;
		return EMSGSIZE;
	    }
	    break;
d780 10
a789 10
	    /* Check for IPv6 maximum packet size violations */
	    if (skip + hlen + rlen + padding + alen > IPV6_MAXPACKET)
	    {
		DPRINTF(("esp_output(): packet in SA %s/%08x got too big\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_toobig++;
		return EMSGSIZE;
	    }
	    break;
d793 157
a949 129
	    DPRINTF(("esp_output(): unknown/unsupported protocol family %d, SA %s/%08x\n", tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    m_freem(m);
	    espstat.esps_nopf++;
	    return EPFNOSUPPORT;
    }

    /* Update the counters */
    tdb->tdb_cur_bytes += m->m_pkthdr.len - skip;
    espstat.esps_obytes += m->m_pkthdr.len - skip;

    /* Hard byte expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	tdb_delete(tdb);
	m_freem(m);
	return EINVAL;
    }

    /* Soft byte expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;     /* Turn off checking */
    }

    /*
     * Loop through mbuf chain; if we find an M_EXT mbuf with
     * more than one reference, replace the rest of the chain.
     */
    mi = m;
    while (mi != NULL &&
	   (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi)))
    {
        mo = mi;
        mi = mi->m_next;
    }

    if (mi != NULL)
    {
        /* Replace the rest of the mbuf chain. */
        struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);

        if (n == NULL)
        {
	    DPRINTF(("esp_output(): bad mbuf chain, SA %s/%08x\n",
		     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_hdrops++;
	    m_freem(m);
	    return ENOBUFS;
        }

        if (mo != NULL)
	  mo->m_next = n;
        else
	  m = n;

        m_freem(mi);
    }

    /* Inject ESP header */
    mo = m_inject(m, skip, hlen, M_DONTWAIT);
    if (mo == NULL)
    {
	DPRINTF(("esp_output(): failed to inject ESP header for SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	espstat.esps_wrap++;
	return ENOBUFS;
    }

    /* Initialize ESP header */
    bcopy((caddr_t) &tdb->tdb_spi, mtod(mo, caddr_t), sizeof(u_int32_t));
    if (!(tdb->tdb_flags & TDBF_NOREPLAY))
    {
	u_int32_t replay = htonl(tdb->tdb_rpl++);
	bcopy((caddr_t) &replay, mtod(mo, caddr_t) + sizeof(u_int32_t),
	      sizeof(u_int32_t));
    }

    /*
     * Add padding -- better to do it ourselves than use the crypto engine,
     * although if/when we support compression, we'd have to do that.
     */
    pad = (u_char *) m_pad(m, padding + alen);
    if (pad == NULL)
    {
        DPRINTF(("esp_output(): m_pad() failed for SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
      	return ENOBUFS;
    }

    /* Self-describing padding ? */
    if (!(tdb->tdb_flags & TDBF_RANDOMPADDING))
      for (ilen = 0; ilen < padding - 2; ilen++)
	pad[ilen] = ilen + 1;
    else
      get_random_bytes((void *) pad, padding - 2); /* Random padding */

    /* Fix padding length and Next Protocol in padding itself */
    pad[padding - 2] = padding - 2;
    m_copydata(m, protoff, sizeof(u_int8_t), pad + padding - 1);

    /* Fix Next Protocol in IPv4/IPv6 header */
    prot = IPPROTO_ESP;
    m_copyback(m, protoff, sizeof(u_int8_t), (u_char *) &prot);

    /* Get crypto descriptors */
    crp = crypto_getreq(esph && espx ? 2 : 1);
    if (crp == NULL)
    {
	m_freem(m);
	DPRINTF(("esp_output(): failed to acquire crypto descriptors\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
    }

    if (espx)
    {
	crde = crp->crp_desc;
	crda = crde->crd_next;

	/* Encryption descriptor */
	crde->crd_skip = skip + hlen;
	crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
	crde->crd_flags = CRD_F_ENCRYPT;
	crde->crd_inject = skip + hlen - tdb->tdb_ivlen;
d951 24
a974 4
	if (tdb->tdb_flags & TDBF_HALFIV)
	{
	    /* Copy half-iv in the packet */
	    m_copyback(m, crde->crd_inject, tdb->tdb_ivlen, tdb->tdb_iv);
d976 4
a979 59
	    /* Cook half-iv */
	    bcopy(tdb->tdb_iv, crde->crd_iv, tdb->tdb_ivlen);
	    for (ilen = 0; ilen < tdb->tdb_ivlen; ilen++)
	      crde->crd_iv[tdb->tdb_ivlen + ilen] = ~crde->crd_iv[ilen];

	    crde->crd_flags |= CRD_F_IV_PRESENT | CRD_F_IV_EXPLICIT;
	}

	/* Encryption operation */
	crde->crd_alg = espx->type;
	crde->crd_key = tdb->tdb_emxkey;
	crde->crd_klen = tdb->tdb_emxkeylen * 8;
	/* XXX Rounds ? */
    }
    else
      crda = crp->crp_desc;

    /* IPsec-specific opaque crypto info */
    MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
	   M_XDATA, M_NOWAIT);
    if (tc == NULL)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("esp_output(): failed to allocate tdb_crypto\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
    }

    bzero(tc, sizeof(struct tdb_crypto));
    tc->tc_spi = tdb->tdb_spi;
    tc->tc_proto = tdb->tdb_sproto;
    bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

    /* Crypto operation descriptor */
    crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
    crp->crp_flags = CRYPTO_F_IMBUF;
    crp->crp_buf = (caddr_t) m;
    crp->crp_callback = (int (*) (struct cryptop *)) esp_output_cb;
    crp->crp_opaque = (caddr_t) tc;
    crp->crp_sid = tdb->tdb_cryptoid;

    if (esph)
    {
	/* Authentication descriptor */
	crda->crd_skip = skip;
	crda->crd_len = m->m_pkthdr.len - (skip + alen);
	crda->crd_inject = m->m_pkthdr.len - alen;

	/* Authentication operation */
	crda->crd_alg = esph->type;
	crda->crd_key = tdb->tdb_amxkey;
	crda->crd_klen = tdb->tdb_amxkeylen * 8;
    }

    if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
      return crypto_dispatch(crp);
    else
      return esp_output_cb(crp);
d988 63
a1050 65
    struct cryptop *crp = (struct cryptop *) op;
    struct tdb_crypto *tc;
    struct tdb *tdb;
    struct mbuf *m;
    int error, s;

    tc = (struct tdb_crypto *) crp->crp_opaque;
    m = (struct mbuf *) crp->crp_buf;

    s = spltdb();

    tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);

    FREE(tc, M_XDATA);
    if (tdb == NULL)
    {
	espstat.esps_notdb++;
	DPRINTF(("esp_output_cb(): TDB is expired while in crypto\n"));
	goto baddone;
    }

    /* Check for crypto errors */
    if (crp->crp_etype)
    {
	/* Reset session ID */
	if (tdb->tdb_cryptoid != 0)
	  tdb->tdb_cryptoid = crp->crp_sid;

	if (crp->crp_etype == EAGAIN)
        {
            splx(s);
            return crypto_dispatch(crp);
        }

	espstat.esps_noxform++;
	DPRINTF(("esp_output_cb(): crypto error %d\n", crp->crp_etype));
	error = crp->crp_etype;
	goto baddone;
    }

    /* Shouldn't happen... */
    if (m == NULL)
    {
	espstat.esps_crypto++;
	DPRINTF(("esp_output_cb(): bogus returned buffer from crypto\n"));
	error = EINVAL;
	goto baddone;
    }

    /* Release crypto descriptors */
    crypto_freereq(crp);

    /*
     * If we're doing half-iv, keep a copy of the last few bytes of the
     * encrypted part, for use as the next IV. Note that HALF-IV is only
     * supposed to be used without authentication (the old ESP specs).
     */
    if (tdb->tdb_flags & TDBF_HALFIV)
      m_copydata(m, m->m_pkthdr.len - tdb->tdb_ivlen, tdb->tdb_ivlen,
		 tdb->tdb_iv);

    /* Call the IPsec input callback */
    error = ipsp_process_done(m, tdb);
    splx(s);
    return error;
d1053 1
a1053 1
    splx(s);
d1055 2
a1056 2
    if (m)
      m_freem(m);
d1058 1
a1058 1
    crypto_freereq(crp);
d1060 1
a1060 1
    return error;
d1071 1
a1071 1
		    u_int32_t window, u_int32_t *bitmap)
d1073 3
a1075 1
    u_int32_t diff;
d1077 2
a1078 1
    seq -= initial;
d1080 9
a1088 2
    if (seq == 0)
      return 1;
d1090 5
a1094 10
    if (seq > *lastseq - initial)
    {
	diff = seq - (*lastseq - initial);
	if (diff < window)
	  *bitmap = ((*bitmap) << diff) | 1;
	else
	  *bitmap = 1;
	*lastseq = seq + initial;
	return 0;
    }
d1096 4
a1099 12
    diff = *lastseq - initial - seq;
    if (diff >= window)
    {
	espstat.esps_wrap++;
	return 2;
    }

    if ((*bitmap) & (((u_int32_t) 1) << diff))
    {
	espstat.esps_replay++;
	return 3;
    }
d1101 2
a1102 2
    *bitmap |= (((u_int32_t) 1) << diff);
    return 0;
d1114 39
a1152 55
    register struct mbuf *m0, *m1;
    register int len, pad;
    caddr_t retval;

    if (n <= 0)			/* no stupid arguments */
    {
	DPRINTF(("m_pad(): pad length invalid (%d)\n", n));
        return NULL;
    }

    len = m->m_pkthdr.len;
    pad = n;

    m0 = m;

    while (m0->m_len < len)
    {
	len -= m0->m_len;
	m0 = m0->m_next;
    }

    if (m0->m_len != len)
    {
	DPRINTF(("m_pad(): length mismatch (should be %d instead of %d)\n",
		 m->m_pkthdr.len, m->m_pkthdr.len + m0->m_len - len));
	m_freem(m);
	return NULL;
    }

    /* Check for zero-length trailing mbufs, and find the last one */
    for (m1 = m0; m1->m_next; m1 = m1->m_next)
    {
	if (m1->m_next->m_len != 0)
	{
	    DPRINTF(("m_pad(): length mismatch (should be %d instead of %d)\n",
		     m->m_pkthdr.len, m->m_pkthdr.len + m1->m_next->m_len));
	    m_freem(m);
	    return NULL;
	}

	m0 = m1->m_next;
    }

    if ((m0->m_flags & M_EXT) ||
	(m0->m_data + m0->m_len + pad >= &(m0->m_dat[MLEN])))
    {
	/*
	 * Add an mbuf to the chain
	 */
	MGET(m1, M_DONTWAIT, MT_DATA);
	if (m1 == 0)
	{
	    m_freem(m0);
	    DPRINTF(("m_pad(): cannot append\n"));
	    return NULL;
d1155 14
a1168 4
	m0->m_next = m1;
	m0 = m1;
	m0->m_len = 0;
    }
d1170 3
a1172 3
    retval = m0->m_data + m0->m_len;
    m0->m_len += pad;
    m->m_pkthdr.len += pad;
d1174 1
a1174 1
    return retval;
@


1.67
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 2
/*	$OpenBSD: ip_esp.c,v 1.66 2001/06/13 13:42:02 angelos Exp $ */

d20 1
d22 1
a22 1
 * Permission to use, copy, and modify this software without fee
@


1.66
log
@Use blocksize, not ivmask
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.65 2001/06/08 03:13:14 angelos Exp $ */
d66 1
a66 1
#include <crypto/crypto.h>
@


1.65
log
@Trim include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.64 2001/06/05 11:10:10 angelos Exp $ */
d146 1
a146 1
        tdbp->tdb_ivlen = txform->ivmask;
@


1.64
log
@Add a few DPRINTF()'s
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.63 2001/06/01 00:09:23 angelos Exp $ */
a39 1
#include <sys/malloc.h>
a40 2
#include <sys/domain.h>
#include <sys/protosw.h>
a41 4
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <machine/cpu.h>
a43 2
#include <net/route.h>
#include <net/netisr.h>
d46 1
a46 2
#include <sys/socketvar.h>
#include <net/raw_cb.h>
a65 3
#include <sys/md5k.h>
#include <crypto/sha1.h>
#include <crypto/rmd160.h>
@


1.63
log
@The IPsec-aware NIC cards don't pass the ICV for later verification
by the stack; that means, if we have a tag it means the ICV was
successfully verified and we don't need to do anything else. As well,
we don't need any other status information from the NIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.62 2001/05/30 12:29:04 angelos Exp $ */
d852 2
@


1.62
log
@Update to match prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.61 2001/05/30 12:13:58 angelos Exp $ */
a382 14
#ifdef DEBUG
    /*
     * Check the the length of the tag is correct, i.e., it contains the
     * authenticator.
     */
    if (mtag != NULL && mtag->m_tag_len != sizeof(struct tdb_ident) + alen)
    {
	m_freem(m);
	DPRINTF(("esp_input(): bad tag length %d (should be %d)\n",
		 mtag->m_tag_len, sizeof(struct tdb_ident) + alen));
	espstat.esps_crypto++;
	return EINVAL;
    }
#endif
d550 2
a551 2
    /* If authentication was performed, check now */
    if (esph)
d553 4
a556 3
	/* Copy the authenticator from the packet */
	m_copydata(m, m->m_pkthdr.len - esph->authsize, esph->authsize, aalg);

d559 14
a572 13
		ptr = (caddr_t) (mtag + 1);
		ptr += sizeof(struct tdb_ident);
	}
	else
	  ptr = (caddr_t) (tc + 1);

	/* Verify authenticator */
	if (bcmp(ptr, aalg, esph->authsize))
	{
	    DPRINTF(("esp_input_cb(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_badauth++;
	    error = EACCES;
	    goto baddone;
@


1.61
log
@Handle TDBF_SKIPCRYPTO on output, and PACKET_TAG_IPSEC_IN_CRYPTO_DONE
on input.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.60 2001/05/27 03:48:34 angelos Exp $ */
d715 1
a715 1
	   int protoff, struct tdb *tdb2)
a983 7
    if (tdb2)
    {
	tc->tc_spi2 = tdb2->tdb_spi;
	tc->tc_proto2 = tdb2->tdb_sproto;
	bcopy(&tdb2->tdb_dst, &tc->tc_dst2, sizeof(union sockaddr_union));
    }

a1017 1
    struct tdb *tdb, *tdb2 = NULL;
d1019 1
a1028 2
    if (tc->tc_spi2)
      tdb2 = gettdb(tc->tc_spi2, &tc->tc_dst2, tc->tc_proto2);
d1079 1
a1079 1
    error = ipsp_process_done(m, tdb, tdb2);
@


1.60
log
@Pass a NULL packet tag for now to ipsp_common_input_cb().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.59 2001/05/17 18:41:47 provos Exp $ */
d281 1
d284 1
d373 25
d409 6
a414 2
    MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
           M_XDATA, M_NOWAIT);
d423 1
d425 1
a440 12
	/* Keep a copy of the authenticator */
	MALLOC(tc->tc_ptr, caddr_t, alen, M_XDATA, M_NOWAIT);
	if (tc->tc_ptr == 0)
	{
	    FREE(tc, M_XDATA);
	    m_freem(m);
	    crypto_freereq(crp);
	    DPRINTF(("esp_input(): failed to allocate auth array\n"));
	    espstat.esps_crypto++;
	    return ENOBUFS;
	}

d442 2
a443 1
	m_copydata(m, m->m_pkthdr.len - alen, alen, tc->tc_ptr);
d446 1
a446 3
    {
        crde = crp->crp_desc;
    }
d488 4
a491 1
    return crypto_dispatch(crp);
d508 1
a509 1
    caddr_t ptr = 0;
d511 1
d519 1
a519 1
    ptr = tc->tc_ptr;
d556 1
a556 1
    if (!m)
d570 8
a588 3

	/* We have to manually free this */
	FREE(ptr, M_XDATA);
d695 1
a695 1
    err = ipsec_common_input_cb(m, tdb, skip, protoff, NULL);
a704 4
    /* We have to manually free this */
    if (ptr)
      FREE(ptr, M_XDATA);

d911 2
a912 4
    {
	for (ilen = 0; ilen < padding - 2; ilen++)
	  pad[ilen] = ilen + 1;
    }
d914 1
a914 3
    {
        get_random_bytes((void *) pad, padding - 2); /* Random padding */
    }
d945 1
a945 1
        if (tdb->tdb_flags & TDBF_HALFIV)
d969 1
a969 1
           M_XDATA, M_NOWAIT);
d978 1
a979 1

d1012 4
a1015 1
    return crypto_dispatch(crp);
d1067 1
a1067 1
    if (!m)
@


1.59
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.58 2001/05/13 15:39:27 deraadt Exp $ */
d666 1
a666 1
    err = ipsec_common_input_cb(m, tdb, skip, protoff);
@


1.58
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.57 2001/05/12 18:09:02 angelos Exp $ */
d826 1
a826 3
	   (!(mi->m_flags & M_EXT) ||
	    (mi->m_ext.ext_ref == NULL &&
	     mclrefcnt[mtocl(mi->m_ext.ext_buf)] <= 1)))
@


1.57
log
@Move bzero() after test for correct allocation (jj@@wabbitt.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.56 2001/04/14 00:30:59 angelos Exp $ */
d241 1
a241 1
			     (tdbp->tdb_encalgxform ? &crie : &cria));
@


1.56
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.55 2001/04/06 04:42:08 csapuntz Exp $ */
a383 1
    bzero(tc, sizeof(struct tdb_crypto));
d392 1
a950 1
    bzero(tc, sizeof(struct tdb_crypto));
d959 1
@


1.55
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.54 2001/03/28 20:03:03 angelos Exp $ */
d384 1
a425 1
        tc->tc_ptr = 0;
d690 1
a690 1
	   int protoff)
d951 1
a962 1
    tc->tc_ptr = 0;
d965 7
d1003 1
a1004 1
    struct tdb *tdb;
d1014 3
d1066 1
a1066 1
    error = ipsp_process_done(m, tdb);
@


1.54
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.53 2001/03/23 04:27:33 angelos Exp $ */
a87 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.53
log
@Fix slow mbuf leak.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.52 2001/03/15 06:30:59 mickey Exp $ */
d726 1
a726 4
	if (tdb->tdb_interface)
	  ifn = (struct ifnet *) tdb->tdb_interface;
	else
	  ifn = &(encif[0].sc_if);
@


1.52
log
@convert SA expirations to the new timeouts.
simplifies expirations handling a lot.
tdb_exp_timeout and tdb_soft_timeout are made
consistant throughout the code to be a relative time offsets,
just like first_use timeouts.
tested on singlehost isakmpd setup.
lots of dangling spaces and tabs removed.
angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.51 2000/11/17 04:15:42 angelos Exp $ */
d1161 14
a1180 1

@


1.51
log
@*HMAC96->*HMAC
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.50 2000/10/09 22:20:40 angelos Exp $ */
d5 1
a5 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
d21 1
a21 1
 *	
d25 1
a25 1
 * modification of this software. 
d151 1
a151 1
    
d194 1
a194 1
    
d200 1
a200 1
    
d362 1
a362 1
	tdb_delete(tdb, TDBEXP_TIMEOUT);
d588 1
a588 1
    if (roff == 0) 
d626 1
a626 1
	  /* 
d814 1
a814 1
	tdb_delete(tdb, TDBEXP_TIMEOUT);
d828 1
a828 1
     * Loop through mbuf chain; if we find an M_EXT mbuf with 
d832 2
a833 2
    while (mi != NULL && 
	   (!(mi->m_flags & M_EXT) || 
d840 1
a840 1
     
d845 1
a845 1
      
d1135 1
a1135 1
	
@


1.50
log
@AES support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.49 2000/09/19 03:20:58 angelos Exp $ */
d172 1
a172 1
	    case SADB_AALG_MD5HMAC96:
d176 1
a176 1
	    case SADB_AALG_SHA1HMAC96:
d180 1
a180 1
	    case SADB_X_AALG_RIPEMD160HMAC96:
@


1.49
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.48 2000/06/18 08:23:48 angelos Exp $ */
d123 4
@


1.48
log
@Use M_NOWAIT instead of M_DONTWAIT in MALLOC() (even though they're
defined to be the same in mbuf.h)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.47 2000/06/18 03:07:25 angelos Exp $ */
d8 2
a9 2
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
d358 1
a358 1
	tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
d810 1
a810 1
	tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
d881 1
a881 2
    pad = (u_char *) m_pad(m, padding + alen,
			   tdb->tdb_flags & TDBF_RANDOMPADDING);
d895 4
d1122 1
a1122 2
 * (which is guaranteed to be all in one mbuf) is returned. The third
 * argument specifies whether we need randompadding or not.
d1126 1
a1126 1
m_pad(struct mbuf *m, int n, int randompadding)
a1179 3

    if (randompadding)
	  get_random_bytes((void *) retval, n);
@


1.47
log
@The callbacks need to set the appropriate spl level now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.46 2000/06/15 00:30:12 angelos Exp $ */
d383 1
a383 1
           M_XDATA, M_DONTWAIT);
d408 1
a408 1
	MALLOC(tc->tc_ptr, caddr_t, alen, M_XDATA, M_DONTWAIT);
d950 1
a950 1
           M_XDATA, M_DONTWAIT);
@


1.46
log
@What was the offending payload length?
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.45 2000/06/14 04:42:10 angelos Exp $ */
d487 1
d498 2
d520 4
a523 1
	  return crypto_dispatch(crp);
d575 2
a578 1
	espstat.esps_hdrops++;
d639 2
a641 1
	espstat.esps_badilen++;
d651 2
a653 1
	    espstat.esps_badenc++;
d666 3
a668 1
    return ipsec_common_input_cb(m, tdb, skip, protoff);
d671 2
d999 1
a999 1
    int error;
d1004 2
d1023 4
a1026 1
	  return crypto_dispatch(crp);
d1056 3
a1058 1
    return ipsp_process_done(m, tdb);
d1061 2
@


1.45
log
@Initialize tc_ptr to zero if authentication is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.44 2000/06/06 04:49:29 angelos Exp $ */
d308 1
a308 1
	    DPRINTF(("esp_input(): payload not a multiple of %d octets, SA %s/%08x\n", espx->blocksize, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
@


1.44
log
@Get rid of tdb_ref, keep indirect pointer to TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.43 2000/06/01 05:40:41 angelos Exp $ */
d423 4
a426 1
      crde = crp->crp_desc;
d949 1
@


1.43
log
@Check for invalid TDBs right away in the callbacks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.42 2000/05/15 03:36:34 angelos Exp $ */
d281 1
d381 12
d408 2
a409 2
	MALLOC(crp->crp_opaque4, caddr_t, alen, M_XDATA, M_DONTWAIT);
	if (crp->crp_opaque4 == 0)
d411 1
d420 1
a420 1
	m_copydata(m, m->m_pkthdr.len - alen, alen, crp->crp_opaque4);
a424 2
    tdb->tdb_ref++;

d431 1
d434 5
a438 3
    crp->crp_opaque1 = (caddr_t) tdb;
    (long) crp->crp_opaque2 = skip;
    (long) crp->crp_opaque3 = protoff;
d480 1
d483 1
d487 5
a491 5
    tdb = (struct tdb *) crp->crp_opaque1;
    esph = (struct auth_hash *) tdb->tdb_authalgxform;
    espx = (struct enc_xform *) tdb->tdb_encalgxform;
    skip = (long) crp->crp_opaque2;
    protoff = (long) crp->crp_opaque3;
d494 3
a496 7
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
d498 2
a499 4
	espstat.esps_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("esp_input_cb(): TDB expired while processing crypto\n"));
d502 3
a504 2
    else
      tdb->tdb_ref--;
d514 1
a514 4
	{
	    tdb->tdb_ref++;
	    return crypto_dispatch(crp);
	}
d535 1
a535 2
	m_copydata(m, m->m_pkthdr.len - esph->authsize,
		   esph->authsize, aalg);
d538 1
a538 1
	if (bcmp(crp->crp_opaque4, aalg, esph->authsize))
d550 1
a550 1
	FREE(crp->crp_opaque4, M_XDATA);
d661 2
a662 2
    if (crp && crp->crp_opaque4)
      FREE(crp->crp_opaque4, M_XDATA);
d680 1
d932 15
a946 1
    tdb->tdb_ref++;
d953 1
a953 1
    crp->crp_opaque1 = (caddr_t) tdb;
d979 1
d984 1
a984 1
    tdb = (struct tdb *) crp->crp_opaque1;
d987 3
a989 7
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
d991 2
a992 4
	espstat.esps_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("esp_output_cb(): TDB expired while processing crypto\n"));
a994 2
    else
      tdb->tdb_ref--;
d1004 1
a1004 4
	{
	    tdb->tdb_ref++;
	    return crypto_dispatch(crp);
	}
@


1.42
log
@Fix sanity check that caused really short packets (ICMPs with less
than 8 bytes of payload) to be dropped. Did not affect TCP/UDP packets
and most ICMP packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.41 2000/04/25 02:53:45 jason Exp $ */
d477 16
a492 1
    tdb->tdb_ref--;
a521 15
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
    {
	espstat.esps_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("esp_input_cb(): TDB expired while processing crypto\n"));
	goto baddone;
    }

d963 16
a978 1
    tdb->tdb_ref--;
a1004 15
	goto baddone;
    }

    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
    {
	espstat.esps_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("esp_output_cb(): TDB expired while processing crypto\n"));
@


1.41
log
@when fixing up the header, copy from the right sized datatype (fixes IPsec
on big-endian machines)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.40 2000/04/06 16:08:22 deraadt Exp $ */
d619 1
a619 1
    if (lastthree[1] + 2 > m->m_pkthdr.len - skip - hlen)
d621 1
a621 1
	DPRINTF(("esp_input_cb(): invalid padding length %d for packet in SA %s/%08x\n", lastthree[2], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
@


1.40
log
@only call get_random_bytes() once in m_pad()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.39 2000/03/30 06:17:56 angelos Exp $ */
d673 1
d877 2
a878 2
    ilen = IPPROTO_ESP;
    m_copyback(m, protoff, sizeof(u_int8_t), (u_char *) &ilen);
@


1.39
log
@Only allocate space for a copy of the authenticator if authentication
is in use.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.38 2000/03/29 07:19:50 angelos Exp $ */
a1088 1
    u_int8_t dat;
d1140 1
a1140 5
      for (len = 0; len < n; len++)
      {
	  get_random_bytes((void *) &dat, sizeof(u_int8_t));
	  retval[len] = len + dat;
      }
@


1.38
log
@Note to self: test before committing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.37 2000/03/29 07:09:57 angelos Exp $ */
d393 14
a448 13

    MALLOC(crp->crp_opaque4, caddr_t, alen, M_XDATA, M_DONTWAIT);
    if (crp->crp_opaque4 == 0)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("esp_input(): failed to allocate auth array\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
    }

    /* Copy the authenticator */
    m_copydata(m, m->m_pkthdr.len - alen, alen, crp->crp_opaque4);
@


1.37
log
@Conform to crypto framework changes for IVs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.36 2000/03/28 07:04:02 angelos Exp $ */
d153 9
a197 1
    tdbp->tdb_encalgxform = txform;
d201 1
a201 16
    DPRINTF(("esp_init(): initialized TDB with enc algorithm %s\n",
	     txform->name));

    tdbp->tdb_ivlen = txform->ivmask;
    if (tdbp->tdb_flags & TDBF_HALFIV)
      tdbp->tdb_ivlen /= 2;

    /* Save the raw keys */
    if (tdbp->tdb_authalgxform)
    {
	tdbp->tdb_amxkeylen = ii->ii_authkeylen;
	MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
	       M_WAITOK);
	bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
    }

d204 1
a208 1
    }
a209 3
    /* Initialize crypto session */
    if (tdbp->tdb_encalgxform)
    {
d226 6
@


1.36
log
@Allow authentication-only ESP (must have broken it in the previous
round of commits).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.35 2000/03/25 04:57:51 angelos Exp $ */
d421 1
d423 10
a432 1
	  crde->crd_flags |= CRD_F_HALFIV;
d901 2
d904 11
a914 2
	  crde->crd_flags |= CRD_F_HALFIV;
	crde->crd_inject = skip + hlen - tdb->tdb_ivlen;
d1012 9
@


1.35
log
@Fix typo causing crash if ESP was used with only authentication or
encryption (not both). Problem noted by jason@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.34 2000/03/21 21:00:09 angelos Exp $ */
d113 1
a113 1
    switch (ii->ii_encalg)
d115 30
a144 22
	case SADB_EALG_DESCBC:
	    txform = &enc_xform_des;
	    break;

	case SADB_EALG_3DESCBC:
	    txform = &enc_xform_3des;
	    break;

	case SADB_X_EALG_BLF:
	    txform = &enc_xform_blf;
	    break;

	case SADB_X_EALG_CAST:
	    txform = &enc_xform_cast5;
	    break;

	case SADB_X_EALG_SKIPJACK:
	    txform = &enc_xform_skipjack;
	    break;

	default:
	    DPRINTF(("esp_init(): unsupported encryption algorithm %d specified\n", ii->ii_encalg));
d146 1
a146 7
    }

    if (ii->ii_enckeylen < txform->minkey)
    {
	DPRINTF(("esp_init(): keylength %d too small (min length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->minkey, txform->name));
	return EINVAL;
    }
d148 5
a152 4
    if (ii->ii_enckeylen > txform->maxkey)
    {
	DPRINTF(("esp_init(): keylength %d too large (max length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->maxkey, txform->name));
	return EINVAL;
@


1.34
log
@Fix casting so it compiles on alphas (testing by janjaap@@stack.nl,
closing pr #1150)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.33 2000/03/17 10:25:22 angelos Exp $ */
d870 1
a870 1
    crp = crypto_getreq(esph && espx ? 2 : 0);
@


1.33
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.32 2000/02/07 06:09:09 itojun Exp $ */
d409 2
a410 2
    crp->crp_opaque2 = (caddr_t) skip;
    crp->crp_opaque3 = (caddr_t) protoff;
d463 2
a464 2
    skip = (int) crp->crp_opaque2;
    protoff = (int) crp->crp_opaque3;
@


1.32
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.31 2000/01/27 08:09:09 angelos Exp $ */
d76 6
a93 24
extern struct auth_hash auth_hash_hmac_md5_96;
extern struct auth_hash auth_hash_hmac_sha1_96;
extern struct auth_hash auth_hash_hmac_ripemd_160_96;

struct auth_hash *esp_hash[] = {
    &auth_hash_hmac_md5_96,
    &auth_hash_hmac_sha1_96,
    &auth_hash_hmac_ripemd_160_96
};

extern struct enc_xform enc_xform_des;
extern struct enc_xform enc_xform_3des;
extern struct enc_xform enc_xform_blf;
extern struct enc_xform enc_xform_cast5;
extern struct enc_xform enc_xform_skipjack;

struct enc_xform *esp_xform[] = {
    &enc_xform_des,
    &enc_xform_3des,
    &enc_xform_blf,
    &enc_xform_cast5,
    &enc_xform_skipjack,
};

a96 1

a105 1

d111 1
a111 1
    int i;
d113 9
a121 5
    /* Check whether the encryption algorithm is supported */
    for (i = sizeof(esp_xform) / sizeof(esp_xform[0]) - 1;
	 i >= 0; i--) 
      if (ii->ii_encalg == esp_xform[i]->type)
	break;
d123 15
a137 4
    if (i < 0) 
    {
	DPRINTF(("esp_init(): unsupported encryption algorithm %d specified\n", ii->ii_encalg));
        return EINVAL;
a139 2
    txform = esp_xform[i];

d154 13
a166 4
	for (i = sizeof(esp_hash) / sizeof(esp_hash[0]) - 1;
	     i >= 0; i--) 
	  if (ii->ii_authalg == esp_hash[i]->type)
	    break;
d168 3
a170 4
	if (i < 0) 
	{
	    DPRINTF(("esp_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
	    return EINVAL;
a172 2
	thash = esp_hash[i];

d197 23
a219 2
    /* Initialize the IV */
    get_random_bytes(tdbp->tdb_iv, tdbp->tdb_ivlen);
d221 18
a238 36
    /* Save the raw keys */
    tdbp->tdb_amxkeylen = ii->ii_authkeylen;
    MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
	   M_WAITOK);
    bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);

    tdbp->tdb_emxkeylen = ii->ii_enckeylen;
    MALLOC(tdbp->tdb_emxkey, u_int8_t *, tdbp->tdb_emxkeylen, M_XDATA,
	   M_WAITOK);
    bcopy(ii->ii_enckey, tdbp->tdb_emxkey, tdbp->tdb_emxkeylen);

    if (txform->setkey)
	txform->setkey(&tdbp->tdb_key, ii->ii_enckey, ii->ii_enckeylen);

    if (thash)
    {
	/* Precompute the I and O pads of the HMAC */
	for (i = 0; i < ii->ii_authkeylen; i++)
	  ii->ii_authkey[i] ^= HMAC_IPAD_VAL;

	MALLOC(tdbp->tdb_ictx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
	bzero(tdbp->tdb_ictx, thash->ctxsize);
	thash->Init(tdbp->tdb_ictx);
	thash->Update(tdbp->tdb_ictx, ii->ii_authkey, ii->ii_authkeylen);
	thash->Update(tdbp->tdb_ictx, hmac_ipad_buffer,
		      HMAC_BLOCK_LEN - ii->ii_authkeylen);
	 
	for (i = 0; i < ii->ii_authkeylen; i++)
	  ii->ii_authkey[i] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);

	MALLOC(tdbp->tdb_octx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
	bzero(tdbp->tdb_octx, thash->ctxsize);
	thash->Init(tdbp->tdb_octx);
	thash->Update(tdbp->tdb_octx, ii->ii_authkey, ii->ii_authkeylen);
	thash->Update(tdbp->tdb_octx, hmac_opad_buffer,
		      HMAC_BLOCK_LEN - ii->ii_authkeylen);
d241 2
a242 1
    return 0;
d245 3
d251 2
d267 3
a269 21
    if (tdbp->tdb_key && tdbp->tdb_encalgxform &&
        tdbp->tdb_encalgxform->zerokey)
      tdbp->tdb_encalgxform->zerokey(&tdbp->tdb_key);

    if (tdbp->tdb_ictx)
    {
	if (tdbp->tdb_authalgxform)
	  bzero(tdbp->tdb_ictx, tdbp->tdb_authalgxform->ctxsize);
	FREE(tdbp->tdb_ictx, M_XDATA);
	tdbp->tdb_ictx = NULL;
    }

    if (tdbp->tdb_octx)
    {
	if (tdbp->tdb_authalgxform)
	  bzero(tdbp->tdb_octx, tdbp->tdb_authalgxform->ctxsize);
	FREE(tdbp->tdb_octx, M_XDATA);
	tdbp->tdb_octx = NULL;
    }

    return 0;
d274 4
a277 1
struct mbuf *
d282 1
a282 5
    int oplen, plen, alen, ilen, i, blks, rest, count, off, roff, hlen;
    u_char iv[MAXBUFSIZ], niv[MAXBUFSIZ], blk[ESP_MAX_BLKS], *lblk;
    u_char *idat, *odat, *ivp, *ivn;
    struct mbuf *mi, *mo, *m1;
    union authctx ctx;
d285 3
a293 2
    blks = espx->blocksize;

d299 1
a299 3
    /* Skip the IP header, IP options, SPI, IV, and any Replay and Auth Data */
    plen = m->m_pkthdr.len - (skip + hlen + alen);
    if ((plen & (blks - 1)) || (plen <= 0))
d301 12
a312 4
	DPRINTF(("esp_input(): payload not a multiple of %d octets, SA %s/%08x\n", blks, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_badilen++;
	m_freem(m);
	return NULL;
a314 3
    /* Auth covers SPI + SN + IV */
    oplen = plen + hlen;

d332 1
a332 1
		return NULL;
d339 1
a339 1
		return NULL;
d345 1
a345 1
		return NULL;
d360 1
a360 1
	return NULL;
d363 1
a363 1
    /* Notify on expiration */
d371 9
a379 9
    /* 
     * Skip forward to the beginning of the ESP header. If we run out
     * of mbufs in the process, the check inside the following while()
     * loop will catch it.
     */
    for (mo = m, i = 0; mo && i + mo->m_len <= skip; mo = mo->m_next)
      i += mo->m_len;

    off = skip - i;
a380 5
    /* Preserve these for later processing */
    roff = off;
    m1 = mo;

    /* Verify the authenticator, if applicable */
d383 14
a396 1
	bcopy(tdb->tdb_ictx, &ctx, esph->ctxsize);
d398 1
a398 2
	/* Copy the authentication data */
	m_copydata(m, m->m_pkthdr.len - alen, alen, iv);
d400 26
a425 11
	/* Compute authenticator over the mbuf chain */
	while (oplen > 0)
	{
	    if (mo == NULL)
	    {
		DPRINTF(("esp_input(): bad mbuf chain, SA %s/%08x\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		espstat.esps_hdrops++;
		m_freem(m);
		return NULL;
	    }
d427 9
a435 6
	    count = min(mo->m_len - off, oplen);
	    esph->Update(&ctx, mtod(mo, unsigned char *) + off, count);
	    oplen -= count;
	    off = 0;
	    mo = mo->m_next;
	}
d437 2
a438 4
	esph->Final(niv, &ctx);
	bcopy(tdb->tdb_octx, &ctx, esph->ctxsize);
	esph->Update(&ctx, niv, esph->hashsize);
	esph->Final(niv, &ctx);
d440 2
a441 9
	/* Verify */
	if (bcmp(niv, iv, AH_HMAC_HASHLEN))
	{
	    DPRINTF(("esp_input(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_badauth++;
	    m_freem(m);
	    return NULL;
	}
    }
d443 32
a474 1
    oplen = plen;
d476 1
a476 9
    /* Find beginning of encrypted data (actually, the IV) */
    mi = m1;
    ilen = mi->m_len - roff - sizeof(u_int32_t);
    if (!(tdb->tdb_flags & TDBF_NOREPLAY))
      ilen -= sizeof(u_int32_t);
    while (ilen <= 0)
    {
	mi = mi->m_next;
	if (mi == NULL)
d478 2
a479 5
	    DPRINTF(("esp_input(): bad mbuf chain, SA %s/%08x\n",
		     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_hdrops++;
	    m_freem(m);
	    return NULL;
d482 4
a485 1
	ilen += mi->m_len;
d488 8
a495 2
    idat = mtod(mi, unsigned char *) + (mi->m_len - ilen);
    m_copydata(mi, mi->m_len - ilen, tdb->tdb_ivlen, iv);
d497 7
a503 2
    /* If we're doing half-IV, generate full IV */
    if (tdb->tdb_flags & TDBF_HALFIV)
d505 5
a509 2
	for (i = 0; i < tdb->tdb_ivlen; i++)
	  iv[tdb->tdb_ivlen + i] = ~iv[i];
d512 2
a513 3
    /* Now skip over the IV */
    ilen -= tdb->tdb_ivlen;
    while (ilen <= 0)
d515 6
a520 2
	mi = mi->m_next;
	if (mi == NULL)
d522 4
a525 5
	    DPRINTF(("esp_input(): bad mbuf chain, SA %s/%08x\n",
		     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_hdrops++;
	    m_freem(m);
	    return NULL;
d528 5
a532 1
	ilen += mi->m_len;
d535 21
a555 3
    /*
     * Remove the ESP header and IV from the mbuf.
     */
d567 2
a568 2
	   * Part or all of the ESP header is at the end of this mbuf, so first
	   * let's remove the remainder of the ESP header from the
d605 2
a606 94
    /* Point to the encrypted data */
    idat = mtod(mi, unsigned char *) + (mi->m_len - ilen);

    /*
     * At this point:
     *   plen is # of encapsulated payload octets
     *   ilen is # of octets left in this mbuf
     *   idat is first encapsulated payload octed in this mbuf
     *   same for olen and odat
     *   ivp points to the IV, ivn buffers the next IV.
     *   mi points to the first mbuf
     *
     * From now on until the end of the mbuf chain:
     *   . move the next eight octets of the chain into ivn
     *   . decrypt idat and xor with ivp
     *   . swap ivp and ivn.
     *   . repeat
     */

    ivp = iv;
    ivn = niv;
    rest = ilen % blks;
    while (plen > 0)		/* while not done */
    {
	if (ilen < blks) 
	{
	    if (rest)
	    {
		bcopy(idat, blk, rest);
		odat = idat;
	    }

	    do {
		mi = (mo = mi)->m_next;
		if (mi == NULL)
		{
		    DPRINTF(("esp_input(): bad mbuf chain, SA %s/%08x\n",
			     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    espstat.esps_hdrops++;
		    m_freem(m);
		    return NULL;
		}
	    } while (mi->m_len == 0);

	    if (mi->m_len < blks - rest)
	    {
		if ((mi = m_pullup(mi, blks - rest)) == NULL) 
		{
		    DPRINTF(("esp_input(): m_pullup() failed, SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    m_freem(m);
		    espstat.esps_hdrops++;
		    return NULL;
		}
		/* 
		 * m_pullup was not called at the beginning of the chain
		 * but might return a new mbuf, link it into the chain.
		 */
		mo->m_next = mi;
	    }
		    
	    ilen = mi->m_len;
	    idat = mtod(mi, u_char *);

	    if (rest)
	    {
		bcopy(idat, blk + rest, blks - rest);
		bcopy(blk, ivn, blks);
		    
		espx->decrypt(tdb, blk);

		for (i = 0; i < blks; i++)
		    blk[i] ^= ivp[i];

		ivp = ivn;
		ivn = (ivp == iv) ? niv : iv;

		bcopy(blk, odat, rest);
		bcopy(blk + rest, idat, blks - rest);

		lblk = blk;   /* last block touched */
		
		idat += blks - rest;
		ilen -= blks - rest;
		plen -= blks;
	    }

	    rest = ilen % blks;
	}

	while (ilen >= blks && plen > 0)
	{
	    bcopy(idat, ivn, blks);

	    espx->decrypt(tdb, idat);
d608 2
a609 26
	    for (i = 0; i < blks; i++)
		idat[i] ^= ivp[i];

	    ivp = ivn;
	    ivn = (ivp == iv) ? niv : iv;

	    lblk = idat;   /* last block touched */
	    idat += blks;

	    ilen -= blks;
	    plen -= blks;
	}
    }

    /* Save last block (end of padding), if it was in-place decrypted */
    if (lblk != blk)
      bcopy(lblk, blk, blks);

    /*
     * Now, the entire chain has been decrypted. As a side effect,
     * blk[blks - 1] contains the next protocol, and blk[blks - 2] contains
     * the amount of padding the original chain had. Chop off the
     * appropriate parts of the chain, and return.
     */

    if (blk[blks - 2] + 2 + alen > m->m_pkthdr.len - skip - hlen)
d611 1
a611 1
	DPRINTF(("esp_input(): invalid padding length %d for packet in SA %s/%08x\n", blk[blks - 2], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d614 1
a614 1
	return NULL;
d617 1
a617 1
    /* Verify correct decryption by checking the last padding bytes. */
d620 1
a620 1
	if ((blk[blks - 2] != blk[blks - 3]) && (blk[blks - 2] != 0))
d625 1
a625 1
	    return NULL;
d629 2
a630 2
    /* Trim the mbuf chain to remove the trailing authenticator */
    m_adj(m, - blk[blks - 2] - 2 - alen);
d633 12
a644 1
    m_copyback(m, protoff, 1, &blk[blks - 1]);
d646 3
a648 1
    return m;
d651 3
d656 1
a656 1
	       int protoff)
d660 1
a660 2
    u_char iv[ESP_MAX_IVS], blk[ESP_MAX_BLKS], auth[AH_ALEN_MAX];
    int i, ilen, hlen, rlen, plen, padding, rest, blks, alen;
d662 4
a665 2
    u_char *pad, *idat, *odat, *ivp;
    union authctx ctx;
a700 1
    blks = espx->blocksize;
d702 5
d721 1
a721 1
	DPRINTF(("esp_output(): SA %s/%0x8 should have expired\n",
d725 1
a725 1
	return ENOBUFS;
d728 2
d731 11
a741 10
    /* Check for IPv6 maximum packet size violations */
    if (tdb->tdb_dst.sa.sa_family == AF_INET)
      if (skip + hlen + rlen + padding + alen > IP_MAXPACKET)
      {
	  DPRINTF(("esp_output(): packet in SA %s/%0x8 got too big\n",
		   ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	  m_freem(m);
	  espstat.esps_toobig++;
	  return EMSGSIZE;
      }
d745 11
a755 10
    /* Check for IPv6 maximum packet size violations */
    if (tdb->tdb_dst.sa.sa_family == AF_INET6)
      if (skip + hlen + rlen + padding + alen > IPV6_MAXPACKET)
      {
	  DPRINTF(("esp_output(): packet in SA %s/%0x8 got too big\n",
		   ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	  m_freem(m);
	  espstat.esps_toobig++;
	  return EMSGSIZE;
      }
d758 7
d789 1
a789 1
     * more than one reference, replace the rest of the chain. 
d822 1
a822 1
    mo = m_inject(m, skip, hlen, M_WAITOK);
d825 2
a826 1
	DPRINTF(("esp_output(): failed to inject ESP header for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d833 1
a833 1
    m_copyback(mo, 0, sizeof(u_int32_t), (caddr_t) &tdb->tdb_spi);
d837 2
a838 2
	m_copyback(mo, sizeof(u_int32_t), sizeof(u_int32_t),
		   (caddr_t) &replay);
d841 4
a844 13
    /* Initialize IV (cook the half-IV if applicable) */
    bcopy(tdb->tdb_iv, iv, tdb->tdb_ivlen);
    if (tdb->tdb_flags & TDBF_HALFIV)
    {
	for (i = 0; i < tdb->tdb_ivlen; i++)
	  iv[i + tdb->tdb_ivlen] = ~iv[i];
    }

    /* Copy IV in ESP header */
    m_copyback(mo, hlen - tdb->tdb_ivlen, tdb->tdb_ivlen,
	       (caddr_t) &tdb->tdb_iv);

    /* Add padding */
d863 1
a863 1
    m_copydata(m, protoff, 1, &pad[padding - 1]);
d869 9
a877 1
    mi = mo;
d879 1
a879 2
    /* If it's just the ESP header, just skip to the next mbuf */
    if (mi->m_len == hlen)
d881 16
a896 3
	mi = mi->m_next;
	ilen = mi->m_len;
	idat = mtod(mi, u_char *);
d899 11
a909 4
    {  /* There's data at the end of this mbuf, skip over ESP header */
	ilen = mi->m_len - hlen;
	idat = mtod(mi, u_char *) + hlen;
    }
a910 1
    /* Authenticate the ESP header if applicable */
d913 9
a921 2
	bcopy(tdb->tdb_ictx, &ctx, esph->ctxsize);
	esph->Update(&ctx, mtod(mo, unsigned char *), hlen);
d924 2
a925 14
    /* Encrypt the payload */
    ivp = iv;
    rest = ilen % blks;
    while (plen > 0)		/* while not done */
    {
	if (ilen < blks) 
	{
	    if (rest)
	    {
	        if (ivp == blk)
		{
		    bcopy(blk, iv, blks);
		    ivp = iv;
		}
d927 10
a936 3
		bcopy(idat, blk, rest);
		odat = idat;
	    }
d938 2
a939 11
	    do {
		mi = (mo = mi)->m_next;
		if (mi == NULL)
		{
		    DPRINTF(("esp_output(): bad mbuf chain, SA %s/%08x\n",
			     ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    espstat.esps_hdrops++;
		    m_freem(m);
		    return EINVAL;
		}
	    } while (mi->m_len == 0);
d941 1
a941 18
	    if (mi->m_len < blks - rest)
	    {
		if ((mi = m_pullup(mi, blks - rest)) == NULL)
		{
		    DPRINTF(("esp_output(): m_pullup() failed, SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    m_freem(m);
		    espstat.esps_hdrops++;
		    return ENOBUFS;
		}
		/* 
		 * m_pullup was not called at the beginning of the chain
		 * but might return a new mbuf, link it into the chain.
		 */
		mo->m_next = mi;
	    }
		    
	    ilen = mi->m_len;
	    idat = mtod(mi, u_char *);
d943 6
a948 21
	    if (rest)
	    {
		bcopy(idat, blk + rest, blks - rest);
		    
		for (i = 0; i < blks; i++)
		  blk[i] ^= ivp[i];

		espx->encrypt(tdb, blk);

		if (esph)
		  esph->Update(&ctx, blk, blks);

		ivp = blk;

		bcopy(blk, odat, rest);
		bcopy(blk + rest, idat, blks - rest);
		
		idat += blks - rest;
		ilen -= blks - rest;
		plen -= blks;
	    }
d950 4
a953 1
	    rest = ilen % blks;
d956 5
a960 4
	while (ilen >= blks && plen > 0)
	{
	    for (i = 0; i < blks; i++)
	      idat[i] ^= ivp[i];
d962 8
a969 1
	    espx->encrypt(tdb, idat);
d971 14
a984 2
	    if (esph)
	      esph->Update(&ctx, idat, blks);
d986 2
a987 2
	    ivp = idat;
	    idat += blks;
d989 2
a990 12
	    ilen -= blks;
	    plen -= blks;
	}
    }

    /* Put in authentication data */
    if (esph)
    {
	esph->Final(auth, &ctx);
	bcopy(tdb->tdb_octx, &ctx, esph->ctxsize);
	esph->Update(&ctx, auth, esph->hashsize);
	esph->Final(auth, &ctx);
d992 3
a994 6
	/* Copy the final authenticator -- cheat and use bcopy() again */
	bcopy(auth, pad + padding, alen);
    }
    
    /* Save the last encrypted block, to be used as the next IV */
    bcopy(ivp, tdb->tdb_iv, tdb->tdb_ivlen);
d996 1
a996 1
    *mp = m;
d998 1
a998 1
    return 0;
d1035 1
a1046 2
 *
 *
a1050 1
 *
@


1.32.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a75 6
#include <sys/md5k.h>
#include <crypto/sha1.h>
#include <crypto/rmd160.h>
#include <crypto/crypto.h>
#include <crypto/xform.h>

d88 24
d115 1
d125 1
d131 1
a131 1
    struct cryptoini cria, crie;
d133 7
a139 1
    switch (ii->ii_encalg)
d141 3
a143 19
	case SADB_EALG_DESCBC:
	    txform = &enc_xform_des;
	    break;

	case SADB_EALG_3DESCBC:
	    txform = &enc_xform_3des;
	    break;

	case SADB_X_EALG_BLF:
	    txform = &enc_xform_blf;
	    break;

	case SADB_X_EALG_CAST:
	    txform = &enc_xform_cast5;
	    break;

	case SADB_X_EALG_SKIPJACK:
	    txform = &enc_xform_skipjack;
	    break;
d145 1
a145 4
	default:
	    DPRINTF(("esp_init(): unsupported encryption algorithm %d specified\n", ii->ii_encalg));
	    return EINVAL;
    }
d161 6
a166 1
	switch (ii->ii_authalg)
d168 3
a170 3
	    case SADB_AALG_MD5HMAC96:
		thash = &auth_hash_hmac_md5_96;
		break;
d172 1
a172 12
	    case SADB_AALG_SHA1HMAC96:
		thash = &auth_hash_hmac_sha1_96;
		break;

	    case SADB_X_AALG_RIPEMD160HMAC96:
		thash = &auth_hash_hmac_ripemd_160_96;
		break;

	    default:
		DPRINTF(("esp_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
		return EINVAL;
	}
d198 3
d202 35
a236 6
    if (tdbp->tdb_authalgxform)
    {
	tdbp->tdb_amxkeylen = ii->ii_authkeylen;
	MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
	       M_WAITOK);
	bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
d239 1
a239 37
    if (tdbp->tdb_encalgxform)
    {
	tdbp->tdb_emxkeylen = ii->ii_enckeylen;
	MALLOC(tdbp->tdb_emxkey, u_int8_t *, tdbp->tdb_emxkeylen, M_XDATA,
	       M_WAITOK);
	bcopy(ii->ii_enckey, tdbp->tdb_emxkey, tdbp->tdb_emxkeylen);
    }

    /* Initialize crypto session */
    if (tdbp->tdb_encalgxform)
    {
	bzero(&crie, sizeof(crie));

	crie.cri_alg = tdbp->tdb_encalgxform->type;

	if (tdbp->tdb_authalgxform)
	  crie.cri_next = &cria;
	else
	  crie.cri_next = NULL;

	crie.cri_klen = ii->ii_enckeylen * 8;
	crie.cri_key = ii->ii_enckey;
	/* XXX Rounds ? */
    }

    if (tdbp->tdb_authalgxform)
    {
	bzero(&cria, sizeof(cria));

	cria.cri_alg = tdbp->tdb_authalgxform->type;
	cria.cri_next = NULL;
	cria.cri_klen = ii->ii_authkeylen * 8;
	cria.cri_key = ii->ii_authkey;
    }

    return crypto_newsession(&tdbp->tdb_cryptoid,
			     (tdbp->tdb_encalgxform ? &crie : &cria));
a241 3
/*
 * Paranoia.
 */
a244 2
    int err;

d259 21
a279 3
    err = crypto_freesession(tdbp->tdb_cryptoid);
    tdbp->tdb_cryptoid = 0;
    return err;
d284 1
a284 4
/*
 * ESP input processing, called (eventually) through the protocol switch.
 */
int
d289 5
a293 1
    int plen, alen, hlen;
a295 3
    struct cryptodesc *crde = NULL, *crda = NULL;
    struct cryptop *crp;

d302 2
d309 3
a311 1
    if (espx)
d313 4
a316 12
	/*
	 * Verify payload length is multiple of encryption algorithm
	 * block size.
	 */
	plen = m->m_pkthdr.len - (skip + hlen + alen);
	if ((plen & (espx->blocksize - 1)) || (plen <= 0))
	{
	    DPRINTF(("esp_input(): payload not a multiple of %d octets, SA %s/%08x\n", espx->blocksize, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_badilen++;
	    m_freem(m);
	    return EINVAL;
	}
d319 3
d339 1
a339 1
		return EACCES;
d346 1
a346 1
		return EACCES;
d352 1
a352 1
		return EACCES;
d367 1
a367 1
	return ENXIO;
d370 1
a370 1
    /* Notify on soft expiration */
d378 13
a390 9
    /* Get crypto descriptors */
    crp = crypto_getreq(esph && espx ? 2 : 1);
    if (crp == NULL)
    {
	m_freem(m);
	DPRINTF(("esp_input(): failed to acquire crypto descriptors\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
    }
d392 1
d395 4
a398 2
	crda = crp->crp_desc;
	crde = crda->crd_next;
d400 11
a410 11
	/* Authentication descriptor */
	crda->crd_skip = skip;
	crda->crd_len = m->m_pkthdr.len - (skip + alen);
	crda->crd_inject = m->m_pkthdr.len - alen;

	crda->crd_alg = esph->type;
	crda->crd_key = tdb->tdb_amxkey;
	crda->crd_klen = tdb->tdb_amxkeylen * 8;
    }
    else
      crde = crp->crp_desc;
d412 6
a417 1
    tdb->tdb_ref++;
d419 4
a422 26
    /* Crypto operation descriptor */
    crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
    crp->crp_flags = CRYPTO_F_IMBUF;
    crp->crp_buf = (caddr_t) m;
    crp->crp_callback = (int (*) (struct cryptop *)) esp_input_cb;
    crp->crp_sid = tdb->tdb_cryptoid;

    /* These are passed as-is to the callback */
    crp->crp_opaque1 = (caddr_t) tdb;
    (long) crp->crp_opaque2 = skip;
    (long) crp->crp_opaque3 = protoff;

    /* Decryption descriptor */
    if (espx)
    {
	crde->crd_skip = skip + hlen;
	crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
	crde->crd_inject = skip + hlen - tdb->tdb_ivlen;
        if (tdb->tdb_flags & TDBF_HALFIV)
	  crde->crd_flags |= CRD_F_HALFIV;

	crde->crd_alg = espx->type;
	crde->crd_key = tdb->tdb_emxkey;
	crde->crd_klen = tdb->tdb_emxkeylen * 8;
	/* XXX Rounds ? */
    }
d424 8
a431 8
    MALLOC(crp->crp_opaque4, caddr_t, alen, M_XDATA, M_DONTWAIT);
    if (crp->crp_opaque4 == 0)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("esp_input(): failed to allocate auth array\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
d434 1
a434 2
    /* Copy the authenticator */
    m_copydata(m, m->m_pkthdr.len - alen, alen, crp->crp_opaque4);
d436 9
a444 37
    return crypto_dispatch(crp);
}

/*
 * ESP input callback, called directly by the crypto driver.
 */
int
esp_input_cb(void *op)
{
    u_int8_t lastthree[3], aalg[AH_HMAC_HASHLEN];
    int hlen, roff, skip, protoff, error;
    struct mbuf *m1, *mo, *m;
    struct cryptodesc *crd;
    struct auth_hash *esph;
    struct enc_xform *espx;
    struct cryptop *crp;
    struct tdb *tdb;

    crp = (struct cryptop *) op;
    crd = crp->crp_desc;
    tdb = (struct tdb *) crp->crp_opaque1;
    esph = (struct auth_hash *) tdb->tdb_authalgxform;
    espx = (struct enc_xform *) tdb->tdb_encalgxform;
    skip = (long) crp->crp_opaque2;
    protoff = (long) crp->crp_opaque3;
    m = (struct mbuf *) crp->crp_buf;

    tdb->tdb_ref--;

    /* Check for crypto errors */
    if (crp->crp_etype)
    {
	/* Reset the session ID */
	if (tdb->tdb_cryptoid != 0)
	  tdb->tdb_cryptoid = crp->crp_sid;

	if (crp->crp_etype == EAGAIN)
d446 5
a450 2
	    tdb->tdb_ref++;
	    return crypto_dispatch(crp);
d453 1
a453 4
	espstat.esps_noxform++;
	DPRINTF(("esp_input_cb(): crypto error %d\n", crp->crp_etype));
	error = crp->crp_etype;
	goto baddone;
d456 2
a457 8
    /* Shouldn't happen... */
    if (!m)
    {
	espstat.esps_crypto++;
	DPRINTF(("esp_input_cb(): bogus returned buffer from crypto\n"));
	error = EINVAL;
	goto baddone;
    }
d459 2
a460 7
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
d462 2
a463 5
	espstat.esps_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("esp_input_cb(): TDB expired while processing crypto\n"));
	goto baddone;
d466 3
a468 2
    /* If authentication was performed, check now */
    if (esph)
d470 2
a471 6
	/* Copy the authenticator from the packet */
	m_copydata(m, m->m_pkthdr.len - esph->authsize,
		   esph->authsize, aalg);

	/* Verify authenticator */
	if (bcmp(crp->crp_opaque4, aalg, esph->authsize))
d473 5
a477 4
	    DPRINTF(("esp_input_cb(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    espstat.esps_badauth++;
	    error = EACCES;
	    goto baddone;
d480 1
a480 5
	/* Remove trailing authenticator */
	m_adj(m, -(esph->authsize));

	/* We have to manually free this */
	FREE(crp->crp_opaque4, M_XDATA);
d483 3
a485 21
    /* Release the crypto descriptors */
    crypto_freereq(crp);

    /* Determine the ESP header length */
    if (tdb->tdb_flags & TDBF_NOREPLAY)
      hlen = sizeof(u_int32_t) + tdb->tdb_ivlen; /* "old" ESP */
    else
      hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; /* "new" ESP */

    /* Find beginning of ESP header */
    m1 = m_getptr(m, skip, &roff);
    if (m1 == NULL)
    {
	DPRINTF(("esp_input_cb(): bad mbuf chain, SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	espstat.esps_hdrops++;
	m_freem(m);
	return EINVAL;
    }

    /* Remove the ESP header and IV from the mbuf. */
d497 2
a498 2
	   * Part or all of the ESP header is at the end of this mbuf, so
	   * first let's remove the remainder of the ESP header from the
d535 94
a628 2
    /* Save the last three bytes of decrypted data */
    m_copydata(m, m->m_pkthdr.len - 3, 3, lastthree);
d630 26
a655 2
    /* Verify pad length */
    if (lastthree[1] + 2 > m->m_pkthdr.len - skip - hlen)
d657 1
a657 1
	DPRINTF(("esp_input_cb(): invalid padding length %d for packet in SA %s/%08x\n", lastthree[2], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d660 1
a660 1
	return EINVAL;
d663 1
a663 1
    /* Verify correct decryption by checking the last padding bytes */
d666 1
a666 1
	if ((lastthree[1] != lastthree[0]) && (lastthree[1] != 0))
d671 1
a671 1
	    return EINVAL;
d675 2
a676 2
    /* Trim the mbuf chain to remove the trailing authenticator and padding */
    m_adj(m, -(lastthree[1] + 2));
d679 1
a679 12
    m_copyback(m, protoff, sizeof(u_int8_t), lastthree + 2);

    /* Back to generic IPsec input processing */
    return ipsec_common_input_cb(m, tdb, skip, protoff);

 baddone:
    if (m)
      m_freem(m);

    /* We have to manually free this */
    if (crp && crp->crp_opaque4)
      FREE(crp->crp_opaque4, M_XDATA);
d681 1
a681 3
    crypto_freereq(crp);

    return error;
a683 3
/*
 * ESP output routine, called by ipsp_process_packet().
 */
d686 1
a686 1
	   int protoff)
d690 2
a691 1
    int ilen, hlen, rlen, plen, padding, blks, alen;
d693 2
a694 4
    unsigned char *pad;

    struct cryptodesc *crde = NULL, *crda = NULL;
    struct cryptop *crp;
d730 1
a731 5
    if (espx)
      blks = espx->blocksize;
    else
      blks = 4; /* If no encryption is used, we have to be 4-byte aligned */

d746 1
a746 1
	DPRINTF(("esp_output(): SA %s/%08x should have expired\n",
d750 1
a750 1
	return EACCES;
a752 2
    switch (tdb->tdb_dst.sa.sa_family)
    {
d754 10
a763 11
	case AF_INET:
	    /* Check for IP maximum packet size violations */
	    if (skip + hlen + rlen + padding + alen > IP_MAXPACKET)
	    {
		DPRINTF(("esp_output(): packet in SA %s/%08x got too big\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_toobig++;
		return EMSGSIZE;
	    }
	    break;
d767 10
a776 11
	case AF_INET6:
	    /* Check for IPv6 maximum packet size violations */
	    if (skip + hlen + rlen + padding + alen > IPV6_MAXPACKET)
	    {
		DPRINTF(("esp_output(): packet in SA %s/%08x got too big\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_toobig++;
		return EMSGSIZE;
	    }
	    break;
a778 7
	default:
	    DPRINTF(("esp_output(): unknown/unsupported protocol family %d, SA %s/%08x\n", tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    m_freem(m);
	    espstat.esps_nopf++;
	    return EPFNOSUPPORT;
    }

d803 1
a803 1
     * more than one reference, replace the rest of the chain.
d836 1
a836 1
    mo = m_inject(m, skip, hlen, M_DONTWAIT);
d839 1
a839 2
	DPRINTF(("esp_output(): failed to inject ESP header for SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d846 1
a846 1
    bcopy((caddr_t) &tdb->tdb_spi, mtod(mo, caddr_t), sizeof(u_int32_t));
d850 2
a851 2
	bcopy((caddr_t) &replay, mtod(mo, caddr_t) + sizeof(u_int32_t),
	      sizeof(u_int32_t));
d854 13
a866 4
    /*
     * Add padding -- better to do it ourselves than use the crypto engine,
     * although if/when we support compression, we'd have to do that.
     */
d885 1
a885 1
    m_copydata(m, protoff, sizeof(u_int8_t), pad + padding - 1);
d891 1
a891 9
    /* Get crypto descriptors */
    crp = crypto_getreq(esph && espx ? 2 : 0);
    if (crp == NULL)
    {
	m_freem(m);
	DPRINTF(("esp_output(): failed to acquire crypto descriptors\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
    }
d893 2
a894 1
    if (espx)
d896 3
a898 16
	crde = crp->crp_desc;
	crda = crde->crd_next;

	/* Encryption descriptor */
	crde->crd_skip = skip + hlen;
	crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
	crde->crd_flags = CRD_F_ENCRYPT;
        if (tdb->tdb_flags & TDBF_HALFIV)
	  crde->crd_flags |= CRD_F_HALFIV;
	crde->crd_inject = skip + hlen - tdb->tdb_ivlen;

	/* Encryption operation */
	crde->crd_alg = espx->type;
	crde->crd_key = tdb->tdb_emxkey;
	crde->crd_klen = tdb->tdb_emxkeylen * 8;
	/* XXX Rounds ? */
d901 4
a904 11
      crda = crp->crp_desc;

    tdb->tdb_ref++;

    /* Crypto operation descriptor */
    crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
    crp->crp_flags = CRYPTO_F_IMBUF;
    crp->crp_buf = (caddr_t) m;
    crp->crp_callback = (int (*) (struct cryptop *)) esp_output_cb;
    crp->crp_opaque1 = (caddr_t) tdb;
    crp->crp_sid = tdb->tdb_cryptoid;
d906 1
d909 2
a910 9
	/* Authentication descriptor */
	crda->crd_skip = skip;
	crda->crd_len = m->m_pkthdr.len - (skip + alen);
	crda->crd_inject = m->m_pkthdr.len - alen;

	/* Authentication operation */
	crda->crd_alg = esph->type;
	crda->crd_key = tdb->tdb_amxkey;
	crda->crd_klen = tdb->tdb_amxkeylen * 8;
d913 18
a930 2
    return crypto_dispatch(crp);
}
d932 11
a942 10
/*
 * ESP output callback, called directly by the crypto driver.
 */
int
esp_output_cb(void *op)
{
    struct cryptop *crp = (struct cryptop *) op;
    struct tdb *tdb;
    struct mbuf *m;
    int error;
d944 18
a961 2
    tdb = (struct tdb *) crp->crp_opaque1;
    m = (struct mbuf *) crp->crp_buf;
d963 21
a983 1
    tdb->tdb_ref--;
d985 2
a986 6
    /* Check for crypto errors */
    if (crp->crp_etype)
    {
	/* Reset session ID */
	if (tdb->tdb_cryptoid != 0)
	  tdb->tdb_cryptoid = crp->crp_sid;
d988 1
a988 1
	if (crp->crp_etype == EAGAIN)
d990 7
a996 3
	    tdb->tdb_ref++;
	    return crypto_dispatch(crp);
	}
d998 2
a999 5
	espstat.esps_noxform++;
	DPRINTF(("esp_output_cb(): crypto error %d\n", crp->crp_etype));
	error = crp->crp_etype;
	goto baddone;
    }
d1001 3
a1003 7
    /* Shouldn't happen... */
    if (!m)
    {
	espstat.esps_crypto++;
	DPRINTF(("esp_output_cb(): bogus returned buffer from crypto\n"));
	error = EINVAL;
	goto baddone;
d1006 2
a1007 7
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
d1009 7
a1015 5
	espstat.esps_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("esp_output_cb(): TDB expired while processing crypto\n"));
	goto baddone;
d1017 3
d1021 1
a1021 2
    /* Release crypto descriptors */
    crypto_freereq(crp);
d1023 1
a1023 10
    /* Call the IPsec input callback */
    return ipsp_process_done(m, tdb);

 baddone:
    if (m)
      m_freem(m);

    crypto_freereq(crp);

    return error;
a1059 1

d1071 2
d1077 1
@


1.32.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.56 2001/04/14 00:30:59 angelos Exp $ */
d5 1
a5 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
d8 2
a9 2
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
d21 1
a21 1
 *
d25 1
a25 1
 * modification of this software.
d90 4
d113 1
a113 1
    if (ii->ii_encalg)
d115 3
a117 5
	switch (ii->ii_encalg)
	{
	    case SADB_EALG_DESCBC:
		txform = &enc_xform_des;
		break;
d119 3
a121 3
	    case SADB_EALG_3DESCBC:
		txform = &enc_xform_3des;
		break;
d123 3
a125 3
	    case SADB_X_EALG_AES:
		txform = &enc_xform_rijndael128;
		break;
d127 3
a129 3
	    case SADB_X_EALG_BLF:
		txform = &enc_xform_blf;
		break;
d131 3
a133 3
	    case SADB_X_EALG_CAST:
		txform = &enc_xform_cast5;
		break;
d135 2
a136 12
	    case SADB_X_EALG_SKIPJACK:
		txform = &enc_xform_skipjack;
		break;

	    default:
		DPRINTF(("esp_init(): unsupported encryption algorithm %d specified\n", ii->ii_encalg));
		return EINVAL;
	}

	if (ii->ii_enckeylen < txform->minkey)
	{
	    DPRINTF(("esp_init(): keylength %d too small (min length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->minkey, txform->name));
d138 1
a138 1
	}
d140 10
a149 14
	if (ii->ii_enckeylen > txform->maxkey)
	{
	    DPRINTF(("esp_init(): keylength %d too large (max length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->maxkey, txform->name));
	    return EINVAL;
	}

        tdbp->tdb_encalgxform = txform;

        DPRINTF(("esp_init(): initialized TDB with enc algorithm %s\n",
	         txform->name));

        tdbp->tdb_ivlen = txform->ivmask;
        if (tdbp->tdb_flags & TDBF_HALFIV)
          tdbp->tdb_ivlen /= 2;
d156 1
a156 1
	    case SADB_AALG_MD5HMAC:
d160 1
a160 1
	    case SADB_AALG_SHA1HMAC:
d164 1
a164 1
	    case SADB_AALG_RIPEMD160HMAC:
d178 1
a178 1

d184 1
a184 1

d186 1
d190 16
a205 1
    /* Initialize crypto session */
a207 1
	/* Save the raw keys */
d212 1
d214 3
a232 6
	/* Save the raw keys */
	tdbp->tdb_amxkeylen = ii->ii_authkeylen;
	MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
	       M_WAITOK);
	bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);

a281 1
    struct tdb_crypto *tc;
d308 1
a308 1
	    DPRINTF(("esp_input(): payload of %d octets not a multiple of %d octets, SA %s/%08x\n", plen, espx->blocksize, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d358 1
a358 1
	tdb_delete(tdb);
a380 13
    /* Get IPsec-specific opaque pointer */
    MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
           M_XDATA, M_NOWAIT);
    bzero(tc, sizeof(struct tdb_crypto));
    if (tc == NULL)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("esp_input(): failed to allocate tdb_crypto\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
    }

a393 15

	/* Keep a copy of the authenticator */
	MALLOC(tc->tc_ptr, caddr_t, alen, M_XDATA, M_NOWAIT);
	if (tc->tc_ptr == 0)
	{
	    FREE(tc, M_XDATA);
	    m_freem(m);
	    crypto_freereq(crp);
	    DPRINTF(("esp_input(): failed to allocate auth array\n"));
	    espstat.esps_crypto++;
	    return ENOBUFS;
	}

	/* Copy the authenticator */
	m_copydata(m, m->m_pkthdr.len - alen, alen, tc->tc_ptr);
d396 3
a398 3
    {
        crde = crp->crp_desc;
    }
a405 1
    crp->crp_opaque = (caddr_t) tc;
d408 3
a410 5
    tc->tc_skip = skip;
    tc->tc_protoff = protoff;
    tc->tc_spi = tdb->tdb_spi;
    tc->tc_proto = tdb->tdb_sproto;
    bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));
a417 1

d419 1
a419 10
	{
	    /* Copy half-IV from packet */
	    m_copydata(m, crde->crd_inject, tdb->tdb_ivlen, crde->crd_iv);

	    /* Cook IV */
	    for (btsx = 0; btsx < tdb->tdb_ivlen; btsx++)
	      crde->crd_iv[tdb->tdb_ivlen + btsx] = ~crde->crd_iv[btsx];

	    crde->crd_flags |= CRD_F_IV_EXPLICIT;
	}
d427 13
a454 1
    struct tdb_crypto *tc;
a456 2
    caddr_t ptr = 0;
    int s, err = 0;
d460 5
a464 5

    tc = (struct tdb_crypto *) crp->crp_opaque;
    skip = tc->tc_skip;
    protoff = tc->tc_protoff;
    ptr = tc->tc_ptr;
d467 1
a467 13
    s = spltdb();

    tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
    FREE(tc, M_XDATA);
    if (tdb == NULL)
    {
	espstat.esps_notdb++;
	DPRINTF(("esp_input_cb(): TDB is expired while in crypto"));
	goto baddone;
    }

    esph = (struct auth_hash *) tdb->tdb_authalgxform;
    espx = (struct enc_xform *) tdb->tdb_encalgxform;
d477 2
a478 2
        {
            splx(s);
d480 1
a480 1
        }
d497 15
d516 2
a517 1
	m_copydata(m, m->m_pkthdr.len - esph->authsize, esph->authsize, aalg);
d520 1
a520 1
	if (bcmp(ptr, aalg, esph->authsize))
d532 1
a532 1
	FREE(ptr, M_XDATA);
a547 2
	espstat.esps_hdrops++;
        splx(s);
d550 1
d556 1
a556 1
    if (roff == 0)
d594 1
a594 1
	  /*
d609 1
a609 1
    if (lastthree[1] + 2 > m->m_pkthdr.len - skip)
d611 1
a612 2
        splx(s);
	DPRINTF(("esp_input_cb(): invalid padding length %d for packet in SA %s/%08x\n", lastthree[1], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d622 1
a623 2
            splx(s);
	    DPRINTF(("esp_input(): decryption failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d636 1
a636 3
    err = ipsec_common_input_cb(m, tdb, skip, protoff);
    splx(s);
    return err;
a638 2
    splx(s);

d643 2
a644 2
    if (ptr)
      FREE(ptr, M_XDATA);
d656 1
a656 1
	   int protoff, struct tdb *tdb2)
a661 1
    struct tdb_crypto *tc;
a662 1
    u_int8_t prot;
d686 4
a689 1
	ifn = &(encif[0].sc_if);
d774 1
a774 1
	tdb_delete(tdb);
d788 1
a788 1
     * Loop through mbuf chain; if we find an M_EXT mbuf with
d792 2
a793 2
    while (mi != NULL &&
	   (!(mi->m_flags & M_EXT) ||
d800 1
a800 1

d805 1
a805 1

d845 2
a846 1
    pad = (u_char *) m_pad(m, padding + alen);
a859 4
    else
    {
        get_random_bytes((void *) pad, padding - 2); /* Random padding */
    }
d866 2
a867 2
    prot = IPPROTO_ESP;
    m_copyback(m, protoff, sizeof(u_int8_t), (u_char *) &prot);
d870 1
a870 1
    crp = crypto_getreq(esph && espx ? 2 : 1);
d888 2
a891 13
        if (tdb->tdb_flags & TDBF_HALFIV)
	{
	    /* Copy half-iv in the packet */
	    m_copyback(m, crde->crd_inject, tdb->tdb_ivlen, tdb->tdb_iv);

	    /* Cook half-iv */
	    bcopy(tdb->tdb_iv, crde->crd_iv, tdb->tdb_ivlen);
	    for (ilen = 0; ilen < tdb->tdb_ivlen; ilen++)
	      crde->crd_iv[tdb->tdb_ivlen + ilen] = ~crde->crd_iv[ilen];

	    crde->crd_flags |= CRD_F_IV_PRESENT | CRD_F_IV_EXPLICIT;
	}

d901 1
a901 23
    /* IPsec-specific opaque crypto info */
    MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
           M_XDATA, M_NOWAIT);
    bzero(tc, sizeof(struct tdb_crypto));
    if (tc == NULL)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("esp_output(): failed to allocate tdb_crypto\n"));
	espstat.esps_crypto++;
	return ENOBUFS;
    }

    tc->tc_spi = tdb->tdb_spi;
    tc->tc_proto = tdb->tdb_sproto;
    bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

    if (tdb2)
    {
	tc->tc_spi2 = tdb2->tdb_spi;
	tc->tc_proto2 = tdb2->tdb_sproto;
	bcopy(&tdb2->tdb_dst, &tc->tc_dst2, sizeof(union sockaddr_union));
    }
d908 1
a908 1
    crp->crp_opaque = (caddr_t) tc;
d934 1
a934 2
    struct tdb *tdb, *tdb2 = NULL;
    struct tdb_crypto *tc;
d936 1
a936 1
    int error, s;
d938 1
a938 1
    tc = (struct tdb_crypto *) crp->crp_opaque;
d941 1
a941 13
    s = spltdb();

    tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
    if (tc->tc_spi2)
      tdb2 = gettdb(tc->tc_spi2, &tc->tc_dst2, tc->tc_proto2);

    FREE(tc, M_XDATA);
    if (tdb == NULL)
    {
	espstat.esps_notdb++;
	DPRINTF(("esp_output_cb(): TDB is expired while in crypto\n"));
	goto baddone;
    }
d951 4
a954 4
        {
            splx(s);
            return crypto_dispatch(crp);
        }
d971 15
a988 9
    /*
     * If we're doing half-iv, keep a copy of the last few bytes of the
     * encrypted part, for use as the next IV. Note that HALF-IV is only
     * supposed to be used without authentication (the old ESP specs).
     */
    if (tdb->tdb_flags & TDBF_HALFIV)
      m_copydata(m, m->m_pkthdr.len - tdb->tdb_ivlen, tdb->tdb_ivlen,
		 tdb->tdb_iv);

d990 1
a990 3
    error = ipsp_process_done(m, tdb, tdb2);
    splx(s);
    return error;
a992 2
    splx(s);

d1049 2
a1050 1
 * (which is guaranteed to be all in one mbuf) is returned.
d1054 1
a1054 1
m_pad(struct mbuf *m, int n)
d1059 2
a1060 1

a1085 14
    /* Check for zero-length trailing mbufs, and find the last one */
    for (m1 = m0; m1->m_next; m1 = m1->m_next)
    {
	if (m1->m_next->m_len != 0)
	{
	    DPRINTF(("m_pad(): length mismatch (should be %d instead of %d)\n",
		     m->m_pkthdr.len, m->m_pkthdr.len + m1->m_next->m_len));
	    m_freem(m);
	    return NULL;
	}

	m0 = m1->m_next;
    }

d1092 1
d1109 7
@


1.32.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$ */
a20 1
 * Copyright (c) 2001 Angelos D. Keromytis.
d22 1
a22 1
 * Permission to use, copy, and modify this software with or without fee
d40 1
d42 2
d45 4
d51 2
d55 2
a56 1
#include <dev/rndvar.h>
d76 4
a79 1
#include <crypto/cryptodev.h>
d96 1
a96 1
	return 0;
d105 31
a135 3
	struct enc_xform *txform = NULL;
	struct auth_hash *thash = NULL;
	struct cryptoini cria, crie;
d137 6
a142 1
	if (ii->ii_encalg)
d144 2
a145 51
		switch (ii->ii_encalg)
		{
		case SADB_EALG_DESCBC:
			txform = &enc_xform_des;
			break;

		case SADB_EALG_3DESCBC:
			txform = &enc_xform_3des;
			break;

		case SADB_X_EALG_AES:
			txform = &enc_xform_rijndael128;
			break;

		case SADB_X_EALG_BLF:
			txform = &enc_xform_blf;
			break;

		case SADB_X_EALG_CAST:
			txform = &enc_xform_cast5;
			break;

		case SADB_X_EALG_SKIPJACK:
			txform = &enc_xform_skipjack;
			break;

		default:
			DPRINTF(("esp_init(): unsupported encryption algorithm %d specified\n", ii->ii_encalg));
			return EINVAL;
		}

		if (ii->ii_enckeylen < txform->minkey)
		{
			DPRINTF(("esp_init(): keylength %d too small (min length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->minkey, txform->name));
			return EINVAL;
		}

		if (ii->ii_enckeylen > txform->maxkey)
		{
			DPRINTF(("esp_init(): keylength %d too large (max length is %d) for algorithm %s\n", ii->ii_enckeylen, txform->maxkey, txform->name));
			return EINVAL;
		}

		tdbp->tdb_encalgxform = txform;

		DPRINTF(("esp_init(): initialized TDB with enc algorithm %s\n",
		    txform->name));

		tdbp->tdb_ivlen = txform->blocksize;
		if (tdbp->tdb_flags & TDBF_HALFIV)
			tdbp->tdb_ivlen /= 2;
d148 1
a148 1
	if (ii->ii_authalg)
d150 3
a152 24
		switch (ii->ii_authalg)
		{
		case SADB_AALG_MD5HMAC:
			thash = &auth_hash_hmac_md5_96;
			break;

		case SADB_AALG_SHA1HMAC:
			thash = &auth_hash_hmac_sha1_96;
			break;

		case SADB_AALG_RIPEMD160HMAC:
			thash = &auth_hash_hmac_ripemd_160_96;
			break;

		default:
			DPRINTF(("esp_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
			return EINVAL;
		}

		if (ii->ii_authkeylen != thash->keysize)
		{
			DPRINTF(("esp_init(): keylength %d doesn't match algorithm %s keysize (%d)\n", ii->ii_authkeylen, thash->name, thash->keysize));
			return EINVAL;
		}
d154 1
a154 1
		tdbp->tdb_authalgxform = thash;
d156 2
a157 3
		DPRINTF(("esp_init(): initialized TDB with hash algorithm %s\n",
		    thash->name));
	}
d159 4
a162 3
	tdbp->tdb_xform = xsp;
	tdbp->tdb_bitmap = 0;
	tdbp->tdb_rpl = AH_HMAC_INITIAL_RPL;
d164 3
a166 2
	/* Initialize crypto session */
	if (tdbp->tdb_encalgxform)
d168 15
a182 18
		/* Save the raw keys */
		tdbp->tdb_emxkeylen = ii->ii_enckeylen;
		MALLOC(tdbp->tdb_emxkey, u_int8_t *, tdbp->tdb_emxkeylen, M_XDATA,
		    M_WAITOK);
		bcopy(ii->ii_enckey, tdbp->tdb_emxkey, tdbp->tdb_emxkeylen);

		bzero(&crie, sizeof(crie));

		crie.cri_alg = tdbp->tdb_encalgxform->type;

		if (tdbp->tdb_authalgxform)
			crie.cri_next = &cria;
		else
			crie.cri_next = NULL;

		crie.cri_klen = ii->ii_enckeylen * 8;
		crie.cri_key = ii->ii_enckey;
		/* XXX Rounds ? */
d185 1
a185 1
	if (tdbp->tdb_authalgxform)
d187 2
a188 12
		/* Save the raw keys */
		tdbp->tdb_amxkeylen = ii->ii_authkeylen;
		MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
		    M_WAITOK);
		bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);

		bzero(&cria, sizeof(cria));

		cria.cri_alg = tdbp->tdb_authalgxform->type;
		cria.cri_next = NULL;
		cria.cri_klen = ii->ii_authkeylen * 8;
		cria.cri_key = ii->ii_authkey;
d191 51
a241 2
	return crypto_newsession(&tdbp->tdb_cryptoid,
	    (tdbp->tdb_encalgxform ? &crie : &cria), 0);
d250 1
a250 1
	int err;
d252 17
a268 17
	if (tdbp->tdb_amxkey)
	{
		bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
		FREE(tdbp->tdb_amxkey, M_XDATA);
		tdbp->tdb_amxkey = NULL;
	}

	if (tdbp->tdb_emxkey)
	{
		bzero(tdbp->tdb_emxkey, tdbp->tdb_emxkeylen);
		FREE(tdbp->tdb_emxkey, M_XDATA);
		tdbp->tdb_emxkey = NULL;
	}

	err = crypto_freesession(tdbp->tdb_cryptoid);
	tdbp->tdb_cryptoid = 0;
	return err;
d279 19
a297 16
	struct auth_hash *esph = (struct auth_hash *) tdb->tdb_authalgxform;
	struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
	struct tdb_ident *tdbi;
	struct tdb_crypto *tc;
	int plen, alen, hlen;
	struct m_tag *mtag;
	u_int32_t btsx;

	struct cryptodesc *crde = NULL, *crda = NULL;
	struct cryptop *crp;

	/* Determine the ESP header length */
	if (tdb->tdb_flags & TDBF_NOREPLAY)
		hlen = sizeof(u_int32_t) + tdb->tdb_ivlen; /* "old" ESP */
	else
		hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; /* "new" ESP */
d299 8
a306 6
	if (esph)
		alen = AH_HMAC_HASHLEN;
	else
		alen = 0;

	if (espx)
d308 13
a320 13
		/*
		 * Verify payload length is multiple of encryption algorithm
		 * block size.
		 */
		plen = m->m_pkthdr.len - (skip + hlen + alen);
		if ((plen & (espx->blocksize - 1)) || (plen <= 0))
		{
			DPRINTF(("esp_input(): payload of %d octets not a multiple of %d octets, SA %s/%08x\n", plen, espx->blocksize, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_badilen++;
			m_freem(m);
			return EINVAL;
		}
	}
d322 2
a323 2
	/* Replay window checking, if appropriate */
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY)))
d325 2
a326 30
		m_copydata(m, skip + sizeof(u_int32_t), sizeof(u_int32_t),
		    (unsigned char *) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl), tdb->tdb_wnd,
		    &(tdb->tdb_bitmap)))
		{
		case 0: /* All's well */
			break;

		case 1:
			DPRINTF(("esp_input(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_wrap++;
			m_freem(m);
			return EACCES;

		case 2:
		case 3:
			DPRINTF(("esp_input(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			m_freem(m);
			return EACCES;

		default:
			DPRINTF(("esp_input(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			m_freem(m);
			return EACCES;
		}
	}
d328 3
a330 10
	/* Update the counters */
	tdb->tdb_cur_bytes += m->m_pkthdr.len - skip - hlen - alen;
	espstat.esps_ibytes += m->m_pkthdr.len - skip - hlen - alen;

	/* Hard expiration */
	if ((tdb->tdb_flags & TDBF_BYTES) &&
	    (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
	{
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
d332 1
a332 2
		return ENXIO;
	}
d334 4
a337 23
	/* Notify on soft expiration */
	if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	    (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
	{
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES;       /* Turn off checking */
	}

	/* Find out if we've already done crypto */
	for (mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, NULL);
	     mtag != NULL;
	     mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, mtag))
	{
		tdbi = (struct tdb_ident *) (mtag + 1);
		if (tdbi->proto == tdb->tdb_sproto && tdbi->spi == tdb->tdb_spi &&
		    !bcmp(&tdbi->dst, &tdb->tdb_dst, sizeof(union sockaddr_union)))
			break;
	}

	/* Get crypto descriptors */
	crp = crypto_getreq(esph && espx ? 2 : 1);
	if (crp == NULL)
	{
d339 1
a339 4
		DPRINTF(("esp_input(): failed to acquire crypto descriptors\n"));
		espstat.esps_crypto++;
		return ENOBUFS;
	}
d341 3
a343 9
	/* Get IPsec-specific opaque pointer */
	if (esph == NULL || mtag != NULL)
		MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
		    M_XDATA, M_NOWAIT);
	else
		MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto) + alen,
		    M_XDATA, M_NOWAIT);
	if (tc == NULL)
	{
d345 1
a345 4
		crypto_freereq(crp);
		DPRINTF(("esp_input(): failed to allocate tdb_crypto\n"));
		espstat.esps_crypto++;
		return ENOBUFS;
d347 1
d349 118
a466 63
	bzero(tc, sizeof(struct tdb_crypto));
	tc->tc_ptr = (caddr_t) mtag;

	if (esph)
	{
		crda = crp->crp_desc;
		crde = crda->crd_next;

		/* Authentication descriptor */
		crda->crd_skip = skip;
		crda->crd_len = m->m_pkthdr.len - (skip + alen);
		crda->crd_inject = m->m_pkthdr.len - alen;

		crda->crd_alg = esph->type;
		crda->crd_key = tdb->tdb_amxkey;
		crda->crd_klen = tdb->tdb_amxkeylen * 8;

		/* Copy the authenticator */
		if (mtag == NULL)
			m_copydata(m, m->m_pkthdr.len - alen, alen, (caddr_t) (tc + 1));
	}
	else
		crde = crp->crp_desc;

	/* Crypto operation descriptor */
	crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) esp_input_cb;
	crp->crp_sid = tdb->tdb_cryptoid;
	crp->crp_opaque = (caddr_t) tc;

	/* These are passed as-is to the callback */
	tc->tc_skip = skip;
	tc->tc_protoff = protoff;
	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = tdb->tdb_sproto;
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

	/* Decryption descriptor */
	if (espx)
	{
		crde->crd_skip = skip + hlen;
		crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
		crde->crd_inject = skip + hlen - tdb->tdb_ivlen;

		if (tdb->tdb_flags & TDBF_HALFIV)
		{
			/* Copy half-IV from packet */
			m_copydata(m, crde->crd_inject, tdb->tdb_ivlen, crde->crd_iv);

			/* Cook IV */
			for (btsx = 0; btsx < tdb->tdb_ivlen; btsx++)
				crde->crd_iv[tdb->tdb_ivlen + btsx] = ~crde->crd_iv[btsx];

			crde->crd_flags |= CRD_F_IV_EXPLICIT;
		}

		crde->crd_alg = espx->type;
		crde->crd_key = tdb->tdb_emxkey;
		crde->crd_klen = tdb->tdb_emxkeylen * 8;
		/* XXX Rounds ? */
	}
d468 1
a468 4
	if (mtag == NULL)
		return crypto_dispatch(crp);
	else
		return esp_input_cb(crp);
d477 192
a668 32
	u_int8_t lastthree[3], aalg[AH_HMAC_HASHLEN];
	int hlen, roff, skip, protoff, error;
	struct mbuf *m1, *mo, *m;
	struct cryptodesc *crd;
	struct auth_hash *esph;
	struct enc_xform *espx;
	struct tdb_crypto *tc;
	struct cryptop *crp;
	struct m_tag *mtag;
	struct tdb *tdb;
	int s, err = 0;
	caddr_t ptr;

	crp = (struct cryptop *) op;
	crd = crp->crp_desc;

	tc = (struct tdb_crypto *) crp->crp_opaque;
	skip = tc->tc_skip;
	protoff = tc->tc_protoff;
	mtag = (struct m_tag *) tc->tc_ptr;
	m = (struct mbuf *) crp->crp_buf;

	s = spltdb();

	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
	FREE(tc, M_XDATA);
	if (tdb == NULL)
	{
		espstat.esps_notdb++;
		DPRINTF(("esp_input_cb(): TDB is expired while in crypto"));
		goto baddone;
	}
d670 2
a671 21
	esph = (struct auth_hash *) tdb->tdb_authalgxform;
	espx = (struct enc_xform *) tdb->tdb_encalgxform;

	/* Check for crypto errors */
	if (crp->crp_etype)
	{
		/* Reset the session ID */
		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;

		if (crp->crp_etype == EAGAIN)
		{
			splx(s);
			return crypto_dispatch(crp);
		}

		espstat.esps_noxform++;
		DPRINTF(("esp_input_cb(): crypto error %d\n", crp->crp_etype));
		error = crp->crp_etype;
		goto baddone;
	}
d673 2
a674 8
	/* Shouldn't happen... */
	if (m == NULL)
	{
		espstat.esps_crypto++;
		DPRINTF(("esp_input_cb(): bogus returned buffer from crypto\n"));
		error = EINVAL;
		goto baddone;
	}
d676 3
a678 24
	/* If authentication was performed, check now. */
	if (esph != NULL)
	{
		/*
		 * If we have a tag, it means an IPsec-aware NIC did the verification
		 * for us.
		 */
		if (mtag != NULL)
		{
			/* Copy the authenticator from the packet */
			m_copydata(m, m->m_pkthdr.len - esph->authsize, esph->authsize,
			    aalg);

			ptr = (caddr_t) (tc + 1);

			/* Verify authenticator */
			if (bcmp(ptr, aalg, esph->authsize))
			{
				DPRINTF(("esp_input_cb(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
				espstat.esps_badauth++;
				error = EACCES;
				goto baddone;
			}
		}
d680 1
a680 6
		/* Remove trailing authenticator */
		m_adj(m, -(esph->authsize));
	}

	/* Release the crypto descriptors */
	crypto_freereq(crp);
d682 1
a682 114
	/* Determine the ESP header length */
	if (tdb->tdb_flags & TDBF_NOREPLAY)
		hlen = sizeof(u_int32_t) + tdb->tdb_ivlen; /* "old" ESP */
	else
		hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen; /* "new" ESP */

	/* Find beginning of ESP header */
	m1 = m_getptr(m, skip, &roff);
	if (m1 == NULL)
	{
		espstat.esps_hdrops++;
		splx(s);
		DPRINTF(("esp_input_cb(): bad mbuf chain, SA %s/%08x\n",
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		return EINVAL;
	}

	/* Remove the ESP header and IV from the mbuf. */
	if (roff == 0)
	{
		/* The ESP header was conveniently at the beginning of the mbuf */
		m_adj(m1, hlen);
		if (!(m1->m_flags & M_PKTHDR))
			m->m_pkthdr.len -= hlen;
	}
	else
		if (roff + hlen >= m1->m_len)
		{
			/*
			 * Part or all of the ESP header is at the end of this mbuf, so
			 * first let's remove the remainder of the ESP header from the
			 * beginning of the remainder of the mbuf chain, if any.
			 */
			if (roff + hlen > m1->m_len)
			{
				/* Adjust the next mbuf by the remainder */
				m_adj(m1->m_next, roff + hlen - m1->m_len);

				/* The second mbuf is guaranteed not to have a pkthdr... */
				m->m_pkthdr.len -= (roff + hlen - m1->m_len);
			}

			/* Now, let's unlink the mbuf chain for a second...*/
			mo = m1->m_next;
			m1->m_next = NULL;

			/* ...and trim the end of the first part of the chain...sick */
			m_adj(m1, -(m1->m_len - roff));
			if (!(m1->m_flags & M_PKTHDR))
				m->m_pkthdr.len -= (m1->m_len - roff);

			/* Finally, let's relink */
			m1->m_next = mo;
		}
		else
		{
			/*
			 * The ESP header lies in the "middle" of the mbuf...do an
			 * overlapping copy of the remainder of the mbuf over the ESP
			 * header.
			 */
			bcopy(mtod(m1, u_char *) + roff + hlen, mtod(m1, u_char *) + roff,
			    m1->m_len - (roff + hlen));
			m1->m_len -= hlen;
			m->m_pkthdr.len -= hlen;
		}

	/* Save the last three bytes of decrypted data */
	m_copydata(m, m->m_pkthdr.len - 3, 3, lastthree);

	/* Verify pad length */
	if (lastthree[1] + 2 > m->m_pkthdr.len - skip)
	{
		espstat.esps_badilen++;
		splx(s);
		DPRINTF(("esp_input_cb(): invalid padding length %d for packet in SA %s/%08x\n", lastthree[1], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		return EINVAL;
	}

	/* Verify correct decryption by checking the last padding bytes */
	if (!(tdb->tdb_flags & TDBF_RANDOMPADDING))
	{
		if ((lastthree[1] != lastthree[0]) && (lastthree[1] != 0))
		{
			espstat.esps_badenc++;
			splx(s);
			DPRINTF(("esp_input(): decryption failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			m_freem(m);
			return EINVAL;
		}
	}

	/* Trim the mbuf chain to remove the trailing authenticator and padding */
	m_adj(m, -(lastthree[1] + 2));

	/* Restore the Next Protocol field */
	m_copyback(m, protoff, sizeof(u_int8_t), lastthree + 2);

	/* Back to generic IPsec input processing */
	err = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
	splx(s);
	return err;

 baddone:
	splx(s);

	if (m != NULL)
		m_freem(m);

	crypto_freereq(crp);

	return error;
d690 1
a690 1
    int protoff)
d692 7
a698 7
	struct enc_xform *espx = (struct enc_xform *) tdb->tdb_encalgxform;
	struct auth_hash *esph = (struct auth_hash *) tdb->tdb_authalgxform;
	int ilen, hlen, rlen, plen, padding, blks, alen;
	struct mbuf *mi, *mo = (struct mbuf *) NULL;
	struct tdb_crypto *tc;
	unsigned char *pad;
	u_int8_t prot;
d700 2
a701 2
	struct cryptodesc *crde = NULL, *crda = NULL;
	struct cryptop *crp;
d704 4
a707 17
	{
		struct ifnet *ifn;
		struct enchdr hdr;
		struct mbuf m1;

		bzero (&hdr, sizeof(hdr));

		hdr.af = tdb->tdb_dst.sa.sa_family;
		hdr.spi = tdb->tdb_spi;
		if (espx)
			hdr.flags |= M_CONF;
		if (esph)
			hdr.flags |= M_AUTH;

		m1.m_next = m;
		m1.m_len = ENC_HDRLEN;
		m1.m_data = (char *) &hdr;
d709 1
a709 1
		ifn = &(encif[0].sc_if);
d711 2
a712 11
		if (ifn->if_bpf)
			bpf_mtap(ifn->if_bpf, &m1);
	}
#endif

	if (tdb->tdb_flags & TDBF_NOREPLAY)
		hlen = sizeof(u_int32_t) + tdb->tdb_ivlen;
	else
		hlen = 2 * sizeof(u_int32_t) + tdb->tdb_ivlen;

	rlen = m->m_pkthdr.len - skip; /* Raw payload length. */
d714 3
a716 3
		blks = espx->blocksize;
	else
		blks = 4; /* If no encryption, we have to be 4-byte aligned. */
d718 3
a720 2
	padding = ((blks - ((rlen + 2) % blks)) % blks) + 2;
	plen = rlen + padding; /* Padded payload length. */
d722 1
a722 4
	if (esph)
		alen = AH_HMAC_HASHLEN;
	else
		alen = 0;
d724 4
a727 1
	espstat.esps_output++;
d729 31
a759 12
	/*
	 * Check for replay counter wrap-around in automatic (not
	 * manual) keying.
	 */
	if ((!(tdb->tdb_flags & TDBF_NOREPLAY)) &&
	    (tdb->tdb_rpl == 0) && (tdb->tdb_wnd > 0)) {
		DPRINTF(("esp_output(): SA %s/%08x should have expired\n",
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_wrap++;
		return EACCES;
	}
d761 2
a762 1
	switch (tdb->tdb_dst.sa.sa_family) {
d765 10
a774 10
		/* Check for IP maximum packet size violations. */
		if (skip + hlen + rlen + padding + alen > IP_MAXPACKET)	{
			DPRINTF(("esp_output(): packet in SA %s/%08x got "
			    "too big\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
			m_freem(m);
			espstat.esps_toobig++;
			return EMSGSIZE;
		}
		break;
d779 10
a788 10
		/* Check for IPv6 maximum packet size violations. */
		if (skip + hlen + rlen + padding + alen > IPV6_MAXPACKET) {
			DPRINTF(("esp_output(): packet in SA %s/%08x got too "
			    "big\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
			m_freem(m);
			espstat.esps_toobig++;
			return EMSGSIZE;
		}
		break;
d792 200
a991 113
		DPRINTF(("esp_output(): unknown/unsupported protocol "
		    "family %d, SA %s/%08x\n", tdb->tdb_dst.sa.sa_family
		    , ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_nopf++;
		return EPFNOSUPPORT;
	}

	/* Update the counters. */
	tdb->tdb_cur_bytes += m->m_pkthdr.len - skip;
	espstat.esps_obytes += m->m_pkthdr.len - skip;

	/* Hard byte expiration. */
	if (tdb->tdb_flags & TDBF_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
		m_freem(m);
		return EINVAL;
	}

	/* Soft byte expiration. */
	if (tdb->tdb_flags & TDBF_SOFT_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES;    /* Turn off checking. */
	}

	/*
	 * Loop through mbuf chain; if we find an M_EXT mbuf with
	 * more than one reference, replace the rest of the chain.
	 */
	mi = m;
	while (mi != NULL &&
	    (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi))) {
		mo = mi;
		mi = mi->m_next;
	}

	if (mi != NULL)	{
		/* Replace the rest of the mbuf chain. */
		struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);

		if (n == NULL) {
			DPRINTF(("esp_output(): bad mbuf chain, SA %s/%08x\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_hdrops++;
			m_freem(m);
			return ENOBUFS;
		}

		if (mo != NULL)
			mo->m_next = n;
		else
			m = n;

		m_freem(mi);
	}

	/* Inject ESP header. */
	mo = m_inject(m, skip, hlen, M_DONTWAIT);
	if (mo == NULL) {
		DPRINTF(("esp_output(): failed to inject ESP header for "
		    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
		    ntohl(tdb->tdb_spi)));
		m_freem(m);
		espstat.esps_wrap++;
		return ENOBUFS;
	}

	/* Initialize ESP header. */
	bcopy((caddr_t) &tdb->tdb_spi, mtod(mo, caddr_t), sizeof(u_int32_t));
	if (!(tdb->tdb_flags & TDBF_NOREPLAY)) {
		u_int32_t replay = htonl(tdb->tdb_rpl++);
		bcopy((caddr_t) &replay, mtod(mo, caddr_t) + sizeof(u_int32_t),
		    sizeof(u_int32_t));
	}

	/*
	 * Add padding -- better to do it ourselves than use the crypto engine,
	 * although if/when we support compression, we'd have to do that.
	 */
	pad = (u_char *) m_pad(m, padding + alen);
	if (pad == NULL) {
		DPRINTF(("esp_output(): m_pad() failed for SA %s/%08x\n",
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		return ENOBUFS;
	}

	/* Self-describing or random padding ? */
	if (!(tdb->tdb_flags & TDBF_RANDOMPADDING))
		for (ilen = 0; ilen < padding - 2; ilen++)
			pad[ilen] = ilen + 1;
	else
		get_random_bytes((void *) pad, padding - 2);

	/* Fix padding length and Next Protocol in padding itself. */
	pad[padding - 2] = padding - 2;
	m_copydata(m, protoff, sizeof(u_int8_t), pad + padding - 1);

	/* Fix Next Protocol in IPv4/IPv6 header. */
	prot = IPPROTO_ESP;
	m_copyback(m, protoff, sizeof(u_int8_t), (u_char *) &prot);

	/* Get crypto descriptors. */
	crp = crypto_getreq(esph && espx ? 2 : 1);
	if (crp == NULL) {
		m_freem(m);
		DPRINTF(("esp_output(): failed to acquire crypto "
		    "descriptors\n"));
		espstat.esps_crypto++;
		return ENOBUFS;
	}
d993 1
a993 73
	if (espx) {
		crde = crp->crp_desc;
		crda = crde->crd_next;

		/* Encryption descriptor. */
		crde->crd_skip = skip + hlen;
		crde->crd_len = m->m_pkthdr.len - (skip + hlen + alen);
		crde->crd_flags = CRD_F_ENCRYPT;
		crde->crd_inject = skip + hlen - tdb->tdb_ivlen;

		if (tdb->tdb_flags & TDBF_HALFIV) {
			/* Copy half-iv in the packet. */
			m_copyback(m, crde->crd_inject, tdb->tdb_ivlen,
			    tdb->tdb_iv);

			/* Cook half-iv. */
			bcopy(tdb->tdb_iv, crde->crd_iv, tdb->tdb_ivlen);
			for (ilen = 0; ilen < tdb->tdb_ivlen; ilen++)
				crde->crd_iv[tdb->tdb_ivlen + ilen] =
				    ~crde->crd_iv[ilen];

			crde->crd_flags |=
			    CRD_F_IV_PRESENT | CRD_F_IV_EXPLICIT;
		}

		/* Encryption operation. */
		crde->crd_alg = espx->type;
		crde->crd_key = tdb->tdb_emxkey;
		crde->crd_klen = tdb->tdb_emxkeylen * 8;
		/* XXX Rounds ? */
	} else
		crda = crp->crp_desc;

	/* IPsec-specific opaque crypto info. */
	MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
	    M_XDATA, M_NOWAIT);
	if (tc == NULL) {
		m_freem(m);
		crypto_freereq(crp);
		DPRINTF(("esp_output(): failed to allocate tdb_crypto\n"));
		espstat.esps_crypto++;
		return ENOBUFS;
	}

	bzero(tc, sizeof(struct tdb_crypto));
	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = tdb->tdb_sproto;
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

	/* Crypto operation descriptor. */
	crp->crp_ilen = m->m_pkthdr.len; /* Total input length. */
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) esp_output_cb;
	crp->crp_opaque = (caddr_t) tc;
	crp->crp_sid = tdb->tdb_cryptoid;

	if (esph) {
		/* Authentication descriptor. */
		crda->crd_skip = skip;
		crda->crd_len = m->m_pkthdr.len - (skip + alen);
		crda->crd_inject = m->m_pkthdr.len - alen;

		/* Authentication operation. */
		crda->crd_alg = esph->type;
		crda->crd_key = tdb->tdb_amxkey;
		crda->crd_klen = tdb->tdb_amxkeylen * 8;
	}

	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		return crypto_dispatch(crp);
	else
		return esp_output_cb(crp);
d1002 67
a1068 63
	struct cryptop *crp = (struct cryptop *) op;
	struct tdb_crypto *tc;
	struct tdb *tdb;
	struct mbuf *m;
	int error, s;

	tc = (struct tdb_crypto *) crp->crp_opaque;
	m = (struct mbuf *) crp->crp_buf;

	s = spltdb();

	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);

	FREE(tc, M_XDATA);
	if (tdb == NULL) {
		espstat.esps_notdb++;
		DPRINTF(("esp_output_cb(): TDB is expired while in crypto\n"));
		goto baddone;
	}

	/* Check for crypto errors. */
	if (crp->crp_etype) {
		/* Reset session ID. */
		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;

		if (crp->crp_etype == EAGAIN) {
			splx(s);
			return crypto_dispatch(crp);
		}

		espstat.esps_noxform++;
		DPRINTF(("esp_output_cb(): crypto error %d\n",
		    crp->crp_etype));
		error = crp->crp_etype;
		goto baddone;
	}

	/* Shouldn't happen... */
	if (m == NULL) {
		espstat.esps_crypto++;
		DPRINTF(("esp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		error = EINVAL;
		goto baddone;
	}

	/* Release crypto descriptors. */
	crypto_freereq(crp);

	/*
	 * If we're doing half-iv, keep a copy of the last few bytes of the
	 * encrypted part, for use as the next IV. Note that HALF-IV is only
	 * supposed to be used without authentication (the old ESP specs).
	 */
	if (tdb->tdb_flags & TDBF_HALFIV)
		m_copydata(m, m->m_pkthdr.len - tdb->tdb_ivlen, tdb->tdb_ivlen,
		    tdb->tdb_iv);

	/* Call the IPsec input callback. */
	error = ipsp_process_done(m, tdb);
	splx(s);
	return error;
d1071 1
a1071 1
	splx(s);
d1073 2
a1074 2
	if (m != NULL)
		m_freem(m);
d1076 1
a1076 1
	crypto_freereq(crp);
d1078 1
a1078 1
	return error;
d1089 1
a1089 1
    u_int32_t window, u_int32_t *bitmap)
d1091 1
a1091 1
	u_int32_t diff;
d1093 1
a1093 1
	seq -= initial;
d1095 2
a1096 2
	if (seq == 0)
		return 1;
d1098 10
a1107 9
	if (seq > *lastseq - initial) {
		diff = seq - (*lastseq - initial);
		if (diff < window)
			*bitmap = ((*bitmap) << diff) | 1;
		else
			*bitmap = 1;
		*lastseq = seq + initial;
		return 0;
	}
d1109 12
a1120 5
	diff = *lastseq - initial - seq;
	if (diff >= window) {
		espstat.esps_wrap++;
		return 2;
	}
d1122 2
a1123 7
	if ((*bitmap) & (((u_int32_t) 1) << diff)) {
		espstat.esps_replay++;
		return 3;
	}

	*bitmap |= (((u_int32_t) 1) << diff);
	return 0;
d1135 55
a1189 7
	register struct mbuf *m0, *m1;
	register int len, pad;
	caddr_t retval;

	if (n <= 0) {  /* No stupid arguments. */
		DPRINTF(("m_pad(): pad length invalid (%d)\n", n));
		return NULL;
d1192 4
a1195 46
	len = m->m_pkthdr.len;
	pad = n;
	m0 = m;

	while (m0->m_len < len) {
		len -= m0->m_len;
		m0 = m0->m_next;
	}

	if (m0->m_len != len) {
		DPRINTF(("m_pad(): length mismatch (should be %d instead of "
		    "%d)\n", m->m_pkthdr.len,
		    m->m_pkthdr.len + m0->m_len - len));

		m_freem(m);
		return NULL;
	}

	/* Check for zero-length trailing mbufs, and find the last one. */
	for (m1 = m0; m1->m_next; m1 = m1->m_next) {
		if (m1->m_next->m_len != 0) {
			DPRINTF(("m_pad(): length mismatch (should be %d "
			    "instead of %d)\n", m->m_pkthdr.len,
			    m->m_pkthdr.len + m1->m_next->m_len));

			m_freem(m);
			return NULL;
		}

		m0 = m1->m_next;
	}

	if ((m0->m_flags & M_EXT) ||
	    m0->m_data + m0->m_len + pad >= &(m0->m_dat[MLEN])) {
		/* Add an mbuf to the chain. */
		MGET(m1, M_DONTWAIT, MT_DATA);
		if (m1 == 0) {
			m_freem(m0);
			DPRINTF(("m_pad(): cannot append\n"));
			return NULL;
		}

		m0->m_next = m1;
		m0 = m1;
		m0->m_len = 0;
	}
d1197 3
a1199 3
	retval = m0->m_data + m0->m_len;
	m0->m_len += pad;
	m->m_pkthdr.len += pad;
d1201 1
a1201 1
	return retval;
@


1.32.2.4
log
@Sync the SMP branch with 3.3
@
text
@a76 2
struct espstat espstat;

d96 4
a99 2
	if (ii->ii_encalg) {
		switch (ii->ii_encalg) {
d129 2
a130 1
		if (ii->ii_enckeylen < txform->minkey) {
d135 2
a136 1
		if (ii->ii_enckeylen > txform->maxkey) {
d151 4
a154 2
	if (ii->ii_authalg) {
		switch (ii->ii_authalg) {
d172 2
a173 1
		if (ii->ii_authkeylen != thash->keysize) {
d189 2
a190 1
	if (tdbp->tdb_encalgxform) {
d193 2
a194 2
		MALLOC(tdbp->tdb_emxkey, u_int8_t *, tdbp->tdb_emxkeylen,
		    M_XDATA, M_WAITOK);
d211 2
a212 1
	if (tdbp->tdb_authalgxform) {
d239 2
a240 1
	if (tdbp->tdb_amxkey) {
d246 2
a247 1
	if (tdbp->tdb_emxkey) {
d288 2
a289 9
	plen = m->m_pkthdr.len - (skip + hlen + alen);
	if (plen <= 0) {
		DPRINTF(("esp_input: invalid payload length\n"));
		espstat.esps_badilen++;
		m_freem(m);
		return EINVAL;
	}

	if (espx) {
d294 3
a296 1
		if (plen & (espx->blocksize - 1)) {
d304 3
a306 2
	/* Replay window checking, if appropriate -- no value commitment. */
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
d311 3
a313 2
		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 0)) {
a317 1
			m_freem(m);
d320 1
d326 1
a330 1
			m_freem(m);
d333 1
d344 2
a345 1
	    (tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))	{
d354 2
a355 1
	    (tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)) {
d363 2
a364 1
	     mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, mtag)) {
d373 2
a374 1
	if (crp == NULL) {
d386 4
a389 3
		MALLOC(tc, struct tdb_crypto *,
		    sizeof(struct tdb_crypto) + alen, M_XDATA, M_NOWAIT);
	if (tc == NULL)	{
d400 2
a401 1
	if (esph) {
d417 2
a418 1
	} else
d437 2
a438 1
	if (espx) {
d443 2
a444 1
		if (tdb->tdb_flags & TDBF_HALFIV) {
d474 1
a474 1
	int s, hlen, roff, skip, protoff, error;
d476 1
d478 1
d483 1
a483 1
	u_int32_t btsx;
d487 1
d498 3
a500 2
	if (tdb == NULL) {
		FREE(tc, M_XDATA);
a502 1
		error = EPERM;
d507 1
d510 2
a511 3
	if (crp->crp_etype) {
		FREE(tc, M_XDATA);

d516 2
a517 1
		if (crp->crp_etype == EAGAIN) {
d529 2
a530 2
	if (m == NULL) {
		FREE(tc, M_XDATA);
d538 2
a539 1
	if (esph != NULL) {
d544 2
a545 1
		if (mtag == NULL) {
d547 2
a548 2
			m_copydata(m, m->m_pkthdr.len - esph->authsize,
			    esph->authsize, aalg);
d553 2
a554 2
			if (bcmp(ptr, aalg, esph->authsize)) {
				FREE(tc, M_XDATA);
a565 33
	FREE(tc, M_XDATA);

	/* Replay window checking, if appropriate */
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
		m_copydata(m, skip + sizeof(u_int32_t), sizeof(u_int32_t),
		    (unsigned char *) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 1)) {
		case 0: /* All's well */
			break;

		case 1:
			DPRINTF(("esp_input_cb(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_wrap++;
			error = EACCES;
			goto baddone;

		case 2:
		case 3:
			DPRINTF(("esp_input_cb(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			error = EACCES;
			goto baddone;

		default:
			DPRINTF(("esp_input_cb(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			espstat.esps_replay++;
			error = EACCES;
			goto baddone;
		}
	}

d577 2
a578 1
	if (m1 == NULL)	{
d588 2
a589 1
	if (roff == 0) {
d594 4
a597 1
	} else if (roff + hlen >= m1->m_len) {
d603 2
a604 1
			if (roff + hlen > m1->m_len) {
d623 13
a635 11
	} else {
		/*
		 * The ESP header lies in the "middle" of the mbuf...do an
		 * overlapping copy of the remainder of the mbuf over the ESP
		 * header.
		 */
		bcopy(mtod(m1, u_char *) + roff + hlen,
		    mtod(m1, u_char *) + roff, m1->m_len - (roff + hlen));
		m1->m_len -= hlen;
		m->m_pkthdr.len -= hlen;
	}
d641 2
a642 1
	if (lastthree[1] + 2 > m->m_pkthdr.len - skip) {
d651 4
a654 2
	if (!(tdb->tdb_flags & TDBF_RANDOMPADDING)) {
		if ((lastthree[1] != lastthree[0]) && (lastthree[1] != 0)) {
d670 1
a670 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
d672 1
a672 1
	return (error);
d682 1
a682 1
	return (error);
d694 1
a694 1
	int ilen, hlen, rlen, padding, blks, alen;
d741 1
d750 13
a824 1
	mo = NULL;
d859 1
a859 1
		espstat.esps_hdrops++;
d1000 2
a1002 1
		FREE(tc, M_XDATA);
a1004 1
		error = EPERM;
a1018 1
		FREE(tc, M_XDATA);
d1024 1
a1024 2
	} else
		FREE(tc, M_XDATA);
d1071 1
a1071 1
    u_int32_t window, u_int32_t *bitmap, int commit)
d1073 1
a1073 10
	u_int32_t diff, llseq, lbitmap;

	/* Just do the checking, without "committing" any changes. */
	if (commit == 0) {
		llseq = *lastseq;
		lbitmap = *bitmap;

		lastseq = &llseq;
		bitmap = &lbitmap;
	}
a1119 1
		m_freem(m);
@


1.32.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.32.2.4 2003/03/28 00:06:54 niklas Exp $ */
a473 1

a474 8
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		espstat.esps_crypto++;
		DPRINTF(("esp_input_cb(): bogus returned buffer from crypto\n"));
		return (EINVAL);
	}
d491 6
a497 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d501 1
a501 1
		FREE(tc, M_XDATA);
d508 9
d543 1
a717 1
		m1.m_flags = 0;
a981 1

a982 10
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		espstat.esps_crypto++;
		DPRINTF(("esp_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		return (EINVAL);
	}

d997 4
a1001 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d1005 1
d1012 10
a1022 1
	FREE(tc, M_XDATA);
@


1.32.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d159 1
a159 1
		case SADB_X_AALG_RIPEMD160HMAC:
a162 12
		case SADB_X_AALG_SHA2_256:
			thash = &auth_hash_hmac_sha2_256_96;
			break;

		case SADB_X_AALG_SHA2_384:
			thash = &auth_hash_hmac_sha2_384_96;
			break;

		case SADB_X_AALG_SHA2_512:
			thash = &auth_hash_hmac_sha2_512_96;
			break;

d600 8
a607 8
		/*
		 * Part or all of the ESP header is at the end of this mbuf, so
		 * first let's remove the remainder of the ESP header from the
		 * beginning of the remainder of the mbuf chain, if any.
		 */
		if (roff + hlen > m1->m_len) {
			/* Adjust the next mbuf by the remainder */
			m_adj(m1->m_next, roff + hlen - m1->m_len);
d609 3
a611 7
			/* The second mbuf is guaranteed not to have a pkthdr... */
			m->m_pkthdr.len -= (roff + hlen - m1->m_len);
		}

		/* Now, let's unlink the mbuf chain for a second...*/
		mo = m1->m_next;
		m1->m_next = NULL;
d613 8
a620 4
		/* ...and trim the end of the first part of the chain...sick */
		m_adj(m1, -(m1->m_len - roff));
		if (!(m1->m_flags & M_PKTHDR))
			m->m_pkthdr.len -= (m1->m_len - roff);
d622 2
a623 2
		/* Finally, let's relink */
		m1->m_next = mo;
d879 1
a879 1
	m_copyback(m, protoff, sizeof(u_int8_t), &prot);
d1109 2
a1110 2
	struct mbuf *m0, *m1;
	int len, pad;
@


1.31
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d65 4
a68 2
#include <netinet6/in6.h>
#include <netinet6/ip6.h>
@


1.30
log
@Ok, no more IPsec for OpenBSD...I've had enough with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.29 1999/12/09 03:46:03 angelos Exp $	*/
a44 1
#include <sys/sysctl.h>
d55 4
d62 1
a62 3
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
d67 1
a67 4
#endif/ * INET6 */

#include <sys/socketvar.h>
#include <net/raw_cb.h>
a68 1
#include <netinet/ip_icmp.h>
d71 1
a71 1

a75 2
extern struct enc_softc encif[];

d86 23
a108 1
int esp_enable = 0;
d111 1
a111 2
 * esp_common_input() gets called when we receive an ESP-protected packet
 * in IPv4 or IPv6.
d114 2
a115 2
static void
esp_common_input(struct mbuf *m, int skip, int protoff, int af)
d117 2
a118 6
    union sockaddr_union sunion;
    struct ifqueue *ifq = NULL;
    struct tdb *tdbp;
    u_int32_t spi;
    u_int8_t prot;
    int s;
d120 16
a135 3
#ifdef INET
    struct ip *ip, ipn;
#endif /* INET */
d137 5
a141 3
#ifdef INET6
    struct ip6_hdr *ip6, ip6n;
#endif /* INET6 */
d143 1
a143 1
    espstat.esps_input++;
d145 7
a151 1
    if (!esp_enable)
d153 29
a181 3
        m_freem(m);
        espstat.esps_pdrops++;
        return;
d183 26
d210 2
a211 2
    /* Retrieve the SPI from the ESP header */
    m_copydata(m, skip , sizeof(u_int32_t), (unsigned char *) &spi);
d213 23
a235 5
    /*
     * Find tunnel control block and (indirectly) call the appropriate
     * kernel crypto routine. The resulting mbuf chain is a valid
     * IP packet ready to go through input processing.
     */
d237 2
a238 2
    bzero(&sunion, sizeof(sunion));
    sunion.sin.sin_family = af;
d240 4
a243 2
#ifdef INET
    if (af == AF_INET)
d245 3
a247 3
	sunion.sin.sin_len = sizeof(struct sockaddr_in);
	m_copydata(m, offsetof(struct ip, ip_dst), sizeof(struct in_addr),
		   (unsigned char *) &(sunion.sin.sin_addr));
a248 1
#endif /* INET */
d250 1
a250 2
#ifdef INET6
    if (af == AF_INET6)
d252 3
a254 4
	sunion.sin6.sin6_len = sizeof(struct sockaddr_in6);
	m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		   sizeof(struct in6_addr),
		   (unsigned char *) &(sunion.sin6.sin6_addr));
a255 1
#endif /* INET6 */
d257 5
a261 3
    s = spltdb();
    tdbp = gettdb(spi, &sunion, IPPROTO_ESP);
    if (tdbp == NULL)
d263 4
a266 4
	DPRINTF(("esp_input(): could not find SA for packet to %s, spi %08x\n", ipsp_address(sunion), ntohl(spi)));
	m_freem(m);
	espstat.esps_notdb++;
	return;
d268 2
a269 2
	
    if (tdbp->tdb_flags & TDBF_INVALID)
d271 4
a274 5
	DPRINTF(("esp_input(): attempted to use invalid SA %s/%08x\n",
		 ipsp_address(sunion), ntohl(spi)));
	m_freem(m);
	espstat.esps_invalid++;
	return;
d277 33
a309 1
    if (tdbp->tdb_xform == NULL)
d311 2
a312 2
	DPRINTF(("esp_input(): attempted to use uninitialized SA %s/%08x\n",
		 ipsp_address(sunion), ntohl(spi)));
d314 1
a314 2
	espstat.esps_noxform++;
	return;
d317 2
a318 4
    if (tdbp->tdb_interface)
      m->m_pkthdr.rcvif = (struct ifnet *) tdbp->tdb_interface;
    else
      m->m_pkthdr.rcvif = &encif[0].sc_if;
d320 2
a321 2
    /* Register first use, setup expiration timer */
    if (tdbp->tdb_first_use == 0)
d323 29
a351 2
	tdbp->tdb_first_use = time.tv_sec;
	tdb_expiration(tdbp, TDBEXP_TIMEOUT);
d354 7
a360 2
    m = (*(tdbp->tdb_xform->xf_input))(m, tdbp, skip, protoff);
    if (m == NULL)
d362 4
a365 3
	/* esp_xxx_input() will print a message if necessary */
	espstat.esps_badkcr++;
	return;
d368 24
a391 3
#ifdef INET
    /* Fix IPv4 header */
    if (af == AF_INET)
d393 4
a396 7
        if ((m = m_pullup(m, skip)) == 0)
        {
	    DPRINTF(("esp_input(): processing failed for SA %s/%08x\n",
		     ipsp_address(tdbp->tdb_dst), ntohl(spi)));
            espstat.esps_hdrops++;
            return;
        }
d398 4
a401 21
	ip = mtod(m, struct ip *);
	ip->ip_len = htons(m->m_pkthdr.len);
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	prot = ip->ip_p;

	/* IP-in-IP encapsulation */
	if (prot == IPPROTO_IPIP)
	{
	    /* ipn will now contain the inner IPv4 header */
	    m_copydata(m, ip->ip_hl << 2, sizeof(struct ip), (caddr_t) &ipn);

	    /*
	     * Check that the inner source address is the same as
	     * the proxy address, if available.
	     */
	    if (((tdbp->tdb_proxy.sa.sa_family == AF_INET) &&
		 (tdbp->tdb_proxy.sin.sin_addr.s_addr != INADDR_ANY) &&
		 (ipn.ip_src.s_addr != tdbp->tdb_proxy.sin.sin_addr.s_addr)) ||
		((tdbp->tdb_proxy.sa.sa_family != AF_INET6) &&
		 (tdbp->tdb_proxy.sa.sa_family != 0)))
d403 2
a404 2
		DPRINTF(("esp_input(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet_ntoa4(ipn.ip_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
		m_free(m);
d406 2
a407 1
		return;
d409 6
d417 32
a448 24
#if INET6
	/* IPv6-in-IP encapsulation */
	if (prot == IPPROTO_IPV6)
	{
	    /* ip6n will now contain the inner IPv6 header */
	    m_copydata(m, ip->ip_hl << 2, sizeof(struct ip6_hdr),
		       (caddr_t) &ip6n);

	    /*
	     * Check that the inner source address is the same as
	     * the proxy address, if available.
	     */
	    if (((tdbp->tdb_proxy.sa.sa_family == AF_INET6) &&
		 !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_proxy.sin6.sin6_addr) &&
		 !IN6_ARE_ADDR_EQUAL(&ip6n.ip6_src,
				     &tdbp->tdb_proxy.sin6.sin6_addr)) ||
		((tdbp->tdb_proxy.sa.sa_family != AF_INET6) &&
		 (tdbp->tdb_proxy.sa.sa_family != 0)))
	    {
		DPRINTF(("esp_input(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet6_ntoa4(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
		m_free(m);
		espstat.esps_hdrops++;
		return;
	    }
a449 1
#endif /* INET6 */
d451 19
a469 9
	/* 
	 * Check that the source address is an expected one, if we know what
	 * it's supposed to be. This avoids source address spoofing.
	 */
	if (((tdbp->tdb_src.sa.sa_family == AF_INET) &&
	     (tdbp->tdb_src.sin.sin_addr.s_addr != INADDR_ANY) &&
	     (ip->ip_src.s_addr != tdbp->tdb_src.sin.sin_addr.s_addr)) ||
	    ((tdbp->tdb_src.sa.sa_family != AF_INET) &&
	     (tdbp->tdb_src.sa.sa_family != 0)))
d471 2
a472 2
	    DPRINTF(("esp_input(): source address %s doesn't correspond to expected source %s, SA %s/%08x\n", inet_ntoa4(ip->ip_src), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
	    m_free(m);
d474 2
a475 1
	    return;
d477 2
a479 1
#endif /* INET */
d481 4
a484 3
#ifdef INET6
    /* Fix IPv6 header */
    if (af == INET6)
d486 46
a531 7
        if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0)
        {
	    DPRINTF(("esp_input(): processing failed for SA %s/%08x\n",
		     ipsp_address(tdbp->tdb_dst), ntohl(spi)));
            espstat.esps_hdrops++;
            return;
        }
d533 2
a534 2
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_plen = htons(m->m_pkthdr.len);
d536 15
a550 2
	/* Save protocol */
	m_copydata(m, protoff, 1, (unsigned char *) &prot);
d552 6
a557 3
#ifdef INET
	/* IP-in-IP encapsulation */
	if (prot == IPPROTO_IPIP)
d559 17
a575 2
	    /* ipn will now contain the inner IPv4 header */
	    m_copydata(m, skip, sizeof(struct ip), (caddr_t) &ipn);
d577 1
a577 9
	    /*
	     * Check that the inner source address is the same as
	     * the proxy address, if available.
	     */
	    if (((tdbp->tdb_proxy.sa.sa_family == AF_INET) &&
		 (tdbp->tdb_proxy.sin.sin_addr.s_addr != INADDR_ANY) &&
		 (ipn.ip_src.s_addr != tdbp->tdb_proxy.sin.sin_addr.s_addr)) ||
		((tdbp->tdb_proxy.sa.sa_family != AF_INET) &&
		 (tdbp->tdb_proxy.sa.sa_family != 0)))
d579 12
a590 4
		DPRINTF(("esp_input(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet_ntoa4(ipn.ip_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
		m_free(m);
		espstat.esps_hdrops++;
		return;
d592 3
a594 8
	}
#endif /* INET */

	/* IPv6-in-IP encapsulation */
	if (prot == IPPROTO_IPV6)
	{
	    /* ip6n will now contain the inner IPv6 header */
	    m_copydata(m, skip, sizeof(struct ip6_hdr), (caddr_t) &ip6n);
d596 1
a596 10
	    /*
	     * Check that the inner source address is the same as
	     * the proxy address, if available.
	     */
	    if (((tdbp->tdb_proxy.sa.sa_family == AF_INET6) &&
		 !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_proxy.sin6.sin6_addr) &&
		 !IN6_ARE_ADDR_EQUAL(&ip6n.ip6_src,
				     &tdbp->tdb_proxy.sin6.sin6_addr)) ||
		((tdbp->tdb_proxy.sa.sa_family != AF_INET6) &&
		 (tdbp->tdb_proxy.sa.sa_family != 0)))
d598 19
a616 4
		DPRINTF(("esp_input(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet6_ntoa4(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
		m_free(m);
		espstat.esps_hdrops++;
		return;
d618 2
d622 1
a622 10
	/* 
	 * Check that the source address is an expected one, if we know what
	 * it's supposed to be. This avoids source address spoofing.
	 */
	if (((tdbp->tdb_src.sa.sa_family == AF_INET6) &&
	     !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_src.sin6.sin6_addr) &&
	     !IN6_ARE_ADDR_EQUAL(&ip6->ip6_src,
				 &tdbp->tdb_src.sin6.sin6_addr)) ||
	    ((tdbp->tdb_src.sa.sa_family != AF_INET6) &&
	     (tdbp->tdb_src.sa.sa_family != 0)))
d624 15
a638 4
	    DPRINTF(("esp_input(): source address %s doesn't correspond to expected source %s, SA %s/%08x\n", inet6_ntoa4(ip6->ip6_src), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
	    m_free(m);
	    espstat.esps_hdrops++;
	    return;
a640 1
#endif /* INET6 */
d642 12
a653 1
    if (prot == IPPROTO_TCP || prot == IPPROTO_UDP)
d655 5
a659 1
	struct tdb_ident *tdbi = NULL;
d661 4
a664 1
	if (tdbp->tdb_bind_out)
d666 6
a671 3
	    tdbi = m->m_pkthdr.tdbi;
	    if (!(m->m_flags & M_PKTHDR))
	      DPRINTF(("esp_input(): mbuf is not a packet header!\n"));
d673 2
a674 2
	    MALLOC(tdbi, struct tdb_ident *, sizeof(struct tdb_ident),
	           M_TEMP, M_NOWAIT);
d676 5
a680 12
	    if (tdbi == NULL)
	      m->m_pkthdr.tdbi = NULL;
	    else
	    {
		tdbi->spi = tdbp->tdb_bind_out->tdb_spi;
		tdbi->dst = tdbp->tdb_bind_out->tdb_dst;
		tdbi->proto = tdbp->tdb_bind_out->tdb_sproto;
	    }
	}
    }
    else
      m->m_pkthdr.tdbi = NULL;
d682 11
a692 2
    /* Packet is confidental */
    m->m_flags |= M_CONF;
a694 1
    if (m->m_pkthdr.rcvif->if_bpf) 
d696 24
a719 19
        /*
         * We need to prepend the address family as
         * a four byte field.  Cons up a dummy header
         * to pacify bpf.  This is safe because bpf
         * will only read from the mbuf (i.e., it won't
         * try to free it or keep a pointer a to it).
         */
        struct mbuf m0;
        struct enchdr hdr;

	hdr.af = af;
	hdr.spi = tdbp->tdb_spi;
	hdr.flags = m->m_flags & (M_AUTH|M_CONF);

        m0.m_next = m;
        m0.m_len = ENC_HDRLEN;
        m0.m_data = (char *) &hdr;
        
        bpf_mtap(m->m_pkthdr.rcvif->if_bpf, &m0);
a721 1
    splx(s);
d723 27
a749 4
    /*
     * Interface pointer is already in first mbuf; chop off the 
     * `outer' header and reschedule.
     */
d752 10
a761 2
    if (af == AF_INET)
      ifq = &ipintrq;
d765 10
a774 2
    if (af == AF_INET6)
      ifq = &ip6intrq;
d777 7
a783 2
    s = splimp();			/* isn't it already? */
    if (IF_QFULL(ifq))
d785 2
a786 3
	IF_DROP(ifq);
	if (m->m_pkthdr.tdbi)
	  free(m->m_pkthdr.tdbi, M_TEMP);
d788 214
a1001 4
	espstat.esps_qfull++;
	splx(s);
	DPRINTF(("esp_input(): dropped packet because of full IP queue\n"));
	return;
d1004 7
a1010 1
    IF_ENQUEUE(ifq, m);
d1012 6
a1017 4
#ifdef INET
    if (af == AF_INET)
      schednetisr(NETISR_IP);
#endif /* INET */
d1019 1
a1019 4
#ifdef INET6
    if (af == AF_INET6)
      schednetisr(NETISR_IPV6);
#endif /* INET6 */
d1021 1
a1021 2
    splx(s);
    return;
d1024 6
d1031 2
a1032 7
esp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
d1034 32
a1065 11
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case ESPCTL_ENABLE:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &esp_enable));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
d1068 12
a1079 4
#ifdef INET
/* IPv4 ESP wrapper */
void
esp_input(struct mbuf *m, ...)
d1081 21
a1101 1
    int skip;
d1103 7
a1109 4
    va_list ap;
    va_start(ap, m);
    skip = va_arg(ap, int);
    va_end(ap);
d1111 14
a1124 3
    esp_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET);
}
#endif /* INET */
d1126 4
a1129 6
#ifdef INET6
/* IPv6 ESP wrapper */
void
esp6_input(struct mbuf *m, ...)
{
    int skip, protoff;
d1131 10
a1140 6
    va_list ap;
	
    va_start(ap, m);
    skip = va_arg(ap, int);
    protoff = va_arg(ap, int);
    va_end(ap);
d1142 1
a1142 1
    esp_common_input(m, skip, protoff, AF_INET6);
a1143 1
#endif /* INET6 */
@


1.29
log
@IPv6 support should now be complete (well, we need the right hooks in
ip6_input())
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.28 1999/12/07 08:58:00 angelos Exp $	*/
@


1.28
log
@New ah_new_input(), protocol-independent processing (still lacking
IPv6-specific protocol header processing).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.27 1999/12/06 07:14:35 angelos Exp $	*/
d63 5
d94 2
a95 1
 * esp_input gets called when we receive an ESP-protected packet
d98 2
a99 7
void
#if __STDC__
esp_input(struct mbuf *m, ...)
#else
esp_input(m, va_alist)
	register struct mbuf *m;
#endif
a100 1
    int iphlen;
a102 1
    struct ip *ipo, ipn;
d105 1
d107 8
a114 5
    va_list ap;
	
    va_start(ap, m);
    iphlen = va_arg(ap, int);
    va_end(ap);
d125 2
a126 17
    /*
     * Make sure that at least the SPI is in the same mbuf
     */

    ipo = mtod(m, struct ip *);
    if (m->m_len < iphlen + sizeof(u_int32_t))
    {
	if ((m = m_pullup(m, iphlen + sizeof(u_int32_t))) == 0)
	{
	    espstat.esps_hdrops++;
	    return;
	}

	ipo = mtod(m, struct ip *);
    }

    spi = *((u_int32_t *) ((caddr_t) ipo + iphlen));
d135 21
a155 3
    sunion.sin.sin_family = AF_INET;
    sunion.sin.sin_len = sizeof(struct sockaddr_in);
    sunion.sin.sin_addr = ipo->ip_dst;
d160 1
a160 1
	DPRINTF(("esp_input(): could not find SA for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo->ip_src), ipsp_address(sunion), ntohl(spi)));
d168 2
a169 1
	DPRINTF(("esp_input(): attempted to use invalid SA %08x, packet from %s to %s\n", ntohl(spi), inet_ntoa4(ipo->ip_src), ipsp_address(sunion)));
d177 2
a178 1
	DPRINTF(("esp_input(): attempted to use uninitialized SA %08x, packet from %s to %s\n", ntohl(spi), inet_ntoa4(ipo->ip_src), ipsp_address(sunion)));
a194 5
    
    ipn = *ipo;

    m = (*(tdbp->tdb_xform->xf_input))(m, tdbp, ipo->ip_hl << 2,
				       offsetof(struct ip, ip_p));
d196 1
d199 1
a199 1
	DPRINTF(("esp_input(): processing failed for ESP packet from %s to %s, spi %08x\n", inet_ntoa4(ipn.ip_src), ipsp_address(sunion), ntohl(spi)));
d204 40
a243 5
    if ((m = m_pullup(m, ipn.ip_hl << 2)) == 0)
    {
	espstat.esps_hdrops++;
	return;
    }
d245 26
a270 4
    ipo = mtod(m, struct ip *);
    ipo->ip_len = htons(m->m_pkthdr.len);
    ipo->ip_sum = 0;
    ipo->ip_sum = in_cksum(m, ipo->ip_hl << 2);
d272 3
a274 18
    if (ipo->ip_p == IPPROTO_IPIP)	/* IP-in-IP encapsulation */
    {
	/* ipn will now contain the inner IP header */
	m_copydata(m, ipo->ip_hl << 2, sizeof(struct ip), (caddr_t) &ipn);
	
	if (tdbp->tdb_flags & TDBF_UNIQUE)
	  if ((ipn.ip_src.s_addr != ipo->ip_src.s_addr) ||
	      (ipn.ip_dst.s_addr != ipo->ip_dst.s_addr))
	  {
	      DPRINTF(("esp_input(): ESP-tunnel with different internal addresses %s->%s (%s->%s), SA %s/%08x\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipn.ip_src), ipsp_address(sunion), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
	      m_freem(m);
	      espstat.esps_hdrops++;
	      return;
	  }

	/*
	 * Check that the inner source address is the same as
	 * the proxy address, if available.
d276 5
a280 2
	if ((tdbp->tdb_proxy.sin.sin_addr.s_addr != INADDR_ANY) &&
	    (ipn.ip_src.s_addr != tdbp->tdb_proxy.sin.sin_addr.s_addr))
d282 1
a282 1
	    DPRINTF(("esp_input(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(tdbp->tdb_proxy.sin.sin_addr), inet_ntoa4(tdbp->tdb_dst.sin.sin_addr), ntohl(tdbp->tdb_spi)));
d288 68
d357 16
a372 11
    /* 
     * Check that the source address is an expected one, if we know what
     * it's supposed to be. This avoids source address spoofing.
     */
    if ((tdbp->tdb_src.sin.sin_addr.s_addr != INADDR_ANY) &&
	(ipo->ip_src.s_addr != tdbp->tdb_src.sin.sin_addr.s_addr))
    {
	DPRINTF(("esp_input(): source address %s doesn't correspond to expected source %s, SA %s/%08x\n", inet_ntoa4(ipo->ip_src), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
	m_free(m);
	espstat.esps_hdrops++;
	return;
d374 1
d376 1
a376 1
    if (ipo->ip_p == IPPROTO_TCP || ipo->ip_p == IPPROTO_UDP)
d384 2
a385 3
	    {
		DPRINTF(("esp_input(): mbuf is not a packet header!\n"));
	    }
d389 8
a396 6
	    if (!tdbi)
	      goto no_mem;

	    tdbi->spi = tdbp->tdb_bind_out->tdb_spi;
	    tdbi->dst = tdbp->tdb_bind_out->tdb_dst;
	    tdbi->proto = tdbp->tdb_bind_out->tdb_sproto;
d398 3
a400 5

    no_mem:
	m->m_pkthdr.tdbi = tdbi;
    } else
        m->m_pkthdr.tdbi = NULL;
d418 1
a418 1
	hdr.af = AF_INET;
d436 9
a444 1
    ifq = &ipintrq;
d451 1
a451 1
		free(m->m_pkthdr.tdbi, M_TEMP);
d460 11
a470 1
    schednetisr(NETISR_IP);
d496 34
@


1.27
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.26 1999/11/04 11:23:43 ho Exp $	*/
a37 5
/*
 * Encapsulation Security Payload Processing
 * Per RFC1827 (Atkinson, 1995)
 */

d89 1
a89 1
 * esp_input gets called when we receive an packet with an ESP.
@


1.26
log
@gettdb() should be at spltdb().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.25 1999/10/29 05:21:45 angelos Exp $	*/
d87 4
d195 2
a196 1
    m = (*(tdbp->tdb_xform->xf_input))(m, tdbp);
d205 6
d212 4
@


1.25
log
@Support multiple enc interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.24 1999/07/05 20:17:06 deraadt Exp $	*/
d151 1
a245 1
	int s = spltdb();
a266 1
	splx(s);
d297 1
@


1.24
log
@remove bogus entry from if_enc address list; and rename enc_softc to encif
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.23 1999/05/16 21:48:33 niklas Exp $	*/
a59 1
#include <net/if_enc.h>
d75 2
d79 1
a79 1
extern struct ifnet encif;
d176 4
a179 1
    m->m_pkthdr.rcvif = &encif;
d275 1
a275 1
    if (encif.if_bpf) 
d295 1
a295 1
        bpf_mtap(encif.if_bpf, &m0);
@


1.23
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.22 1999/05/14 23:36:17 niklas Exp $	*/
d78 1
a78 1
extern struct ifnet enc_softc;
d175 1
a175 1
    m->m_pkthdr.rcvif = &enc_softc;
d271 1
a271 1
    if (enc_softc.if_bpf) 
d291 1
a291 1
        bpf_mtap(enc_softc.if_bpf, &m0);
@


1.22
log
@A new scalable IPsec SA expiration model.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.21 1999/04/11 19:41:37 niklas Exp $	*/
d181 1
a181 1
	tdb_expiration(tdbp, 0);
d241 2
d263 1
@


1.21
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.20 1999/04/09 22:27:53 niklas Exp $	*/
a102 1
    struct expiration *exp;
d181 1
a181 21

	if (tdbp->tdb_flags & TDBF_FIRSTUSE)
	{
	    exp = get_expiration();
	    bcopy(&tdbp->tdb_dst, &exp->exp_dst, SA_LEN(&tdbp->tdb_dst.sa));
	    exp->exp_spi = tdbp->tdb_spi;
	    exp->exp_sproto = tdbp->tdb_sproto;
	    exp->exp_timeout = tdbp->tdb_first_use + tdbp->tdb_exp_first_use;
	    put_expiration(exp);
	}

	if ((tdbp->tdb_flags & TDBF_SOFT_FIRSTUSE) &&
	    (tdbp->tdb_soft_first_use <= tdbp->tdb_exp_first_use))
	{
	    exp = get_expiration();
	    bcopy(&tdbp->tdb_dst, &exp->exp_dst, SA_LEN(&tdbp->tdb_dst.sa));
	    exp->exp_spi = tdbp->tdb_spi;
	    exp->exp_sproto = tdbp->tdb_sproto;
	    exp->exp_timeout = tdbp->tdb_first_use + tdbp->tdb_soft_first_use;
	    put_expiration(exp);
	}
@


1.20
log
@Make the tdbi handling more robust, removes a panic case
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.19 1999/03/27 21:04:19 provos Exp $	*/
d50 1
d86 1
a86 1
void esp_input __P((struct mbuf *, int));
d93 6
a98 1
esp_input(register struct mbuf *m, int iphlen)
d100 1
d108 1
d110 4
d116 7
d337 22
@


1.19
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.18 1999/02/24 23:45:49 angelos Exp $	*/
d250 2
a251 3
	    if (!tdbi || !(m->m_flags & (M_CONF|M_AUTH)))
	      MALLOC(tdbi, struct tdb_ident *, sizeof(struct tdb_ident),
		     M_TEMP, M_NOWAIT);
d261 1
d263 2
a264 2
    no_mem:
    }
@


1.18
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.17 1999/02/24 22:33:01 angelos Exp $	*/
d240 26
d305 2
@


1.17
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.16 1998/06/10 23:57:14 provos Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
@


1.16
log
@make the packets which were successfully processed by IPSec available to
bpf via the enc0 interface, using linktype DLT_ENC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.15 1998/05/24 22:40:12 provos Exp $	*/
a67 1
#include <net/encap.h>
a71 1
#include <sys/syslog.h>
d75 9
a83 1
void	esp_input __P((struct mbuf *, int));
d92 1
a110 4
#ifdef ENCDEBUG
            if (encdebug)
              printf("esp_input(): (possibly too short) packet from %x to %x dropped\n", ipo->ip_src, ipo->ip_dst);
#endif /* ENCDEBUG */
d126 5
a130 1
    tdbp = gettdb(spi, ipo->ip_dst, IPPROTO_ESP);
d133 1
a133 2
	if (encdebug)
	  log(LOG_ERR, "esp_input(): could not find SA for ESP packet from %x to %x, spi %08x\n", ipo->ip_src, ipo->ip_dst, ntohl(spi));
d141 1
a141 2
	if (encdebug)
          log(LOG_ALERT, "esp_input(): attempted to use invalid ESP SA %08x, packet %x->%x\n", ntohl(spi), ipo->ip_src, ipo->ip_dst);
d149 1
a149 2
	if (encdebug)
          log(LOG_ALERT, "esp_input(): attempted to use uninitialized ESP SA %08x, packet from %x to %x\n", ntohl(spi), ipo->ip_src, ipo->ip_dst);
d165 1
a165 11
	    if (exp == (struct expiration *) NULL)
	    {
		if (encdebug)
		  log(LOG_WARNING,
		      "esp_input(): out of memory for expiration timer\n");
		espstat.esps_hdrops++;
		m_freem(m);
		return;
	    }

	    exp->exp_dst.s_addr = tdbp->tdb_dst.s_addr;
a168 1

d176 1
a176 11
	    if (exp == (struct expiration *) NULL)
	    {
		if (encdebug)
		  log(LOG_WARNING,
		      "esp_input(): out of memory for expiration timer\n");
		espstat.esps_hdrops++;
		m_freem(m);
		return;
	    }

	    exp->exp_dst.s_addr = tdbp->tdb_dst.s_addr;
a179 1

d190 1
a190 2
	if (encdebug)
	  log(LOG_ALERT, "esp_input(): processing failed for ESP packet from %x to %x, spi %08x\n", ipn.ip_src, ipn.ip_dst, ntohl(spi));
d201 16
a216 2
	/* Encapsulating SPI */
	if (tdbp->tdb_osrc.s_addr && tdbp->tdb_odst.s_addr)
d218 2
a219 21
	    if (tdbp->tdb_flags & TDBF_UNIQUE)
		if ((ipn.ip_src.s_addr != ipo->ip_src.s_addr) ||
		    (ipn.ip_dst.s_addr != ipo->ip_dst.s_addr))
		{
		    if (encdebug)
			log(LOG_ALERT, "esp_input(): ESP-tunnel with different internal addresses %x/%x, SA %08x/%x\n", ipo->ip_src, ipo->ip_dst, tdbp->tdb_spi, tdbp->tdb_dst);
		    m_freem(m);
		    espstat.esps_hdrops++;
		    return;
		}

	    /* 
	     * XXX Here we should be checking that the inner IP addresses
	     * XXX are acceptable/authorized.
	     */
	}
	else				/* So we're paranoid */
	{
	    if (encdebug)
		log(LOG_ALERT, "esp_input(): ESP-tunnel used when expecting ESP-transport, SA %08x/%x\n", tdbp->tdb_spi, tdbp->tdb_dst);
	    m_freem(m);
d229 8
a236 9
    if (tdbp->tdb_src.s_addr != INADDR_ANY)
	if (ipo->ip_src.s_addr != tdbp->tdb_src.s_addr)
	{
	    if (encdebug)
		log(LOG_ALERT, "esp_input(): source address %x doesn't correspond to expected source %x, SA %08x/%x\n", ipo->ip_src, tdbp->tdb_src, tdbp->tdb_dst, tdbp->tdb_spi);
	    m_free(m);
	    espstat.esps_hdrops++;
	    return;
	}
d256 1
a256 1
	hdr.flags = m->m_flags & (M_AUTH|M_CONF|M_TUNNEL);
d280 1
a280 4
#ifdef ENCDEBUG
        if (encdebug)
          printf("esp_input(): dropped packet because of full IP queue\n");
#endif /* ENCDEBUG */
@


1.15
log
@avoid source address spoofing for mutual hostile hosts which have SAs to
us, reported by Craig Metz <cmetz@@inner.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.14 1998/05/18 21:10:40 provos Exp $	*/
d56 2
d75 2
d262 28
@


1.14
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.13 1997/11/04 09:11:09 provos Exp $	*/
d213 3
d220 14
a233 9
	      if ((ipn.ip_src.s_addr != ipo->ip_src.s_addr) ||
		  (ipn.ip_dst.s_addr != ipo->ip_dst.s_addr))
	      {
		  if (encdebug)
		    log(LOG_ALERT, "esp_input(): ESP-tunnel with different internal addresses %x/%x, SA %08x/%x\n", ipo->ip_src, ipo->ip_dst, tdbp->tdb_spi, tdbp->tdb_dst);
		  m_freem(m);
		  espstat.esps_hdrops++;
		  return;
	      }
d238 1
a238 1
	      log(LOG_ALERT, "esp_input(): ESP-tunnel used when expecting ESP-transport, SA %08x/%x\n", tdbp->tdb_spi, tdbp->tdb_dst);
d244 15
a258 1
    
@


1.13
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.12 1997/10/02 02:31:04 deraadt Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
@


1.12
log
@conditional error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.11 1997/09/28 22:57:46 deraadt Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
@


1.11
log
@log() needs a \n
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.10 1997/07/27 23:30:35 niklas Exp $	*/
d112 2
a113 1
	log(LOG_ERR, "esp_input(): could not find SA for ESP packet from %x to %x, spi %08x\n", ipo->ip_src, ipo->ip_dst, ntohl(spi));
d121 2
a122 1
        log(LOG_ALERT, "esp_input(): attempted to use invalid ESP SA %08x, packet %x->%x\n", ntohl(spi), ipo->ip_src, ipo->ip_dst);
d130 2
a131 1
        log(LOG_ALERT, "esp_input(): attempted to use uninitialized ESP SA %08x, packet from %x to %x\n", ntohl(spi), ipo->ip_src, ipo->ip_dst);
d149 3
a151 2
		log(LOG_WARNING,
		    "esp_input(): out of memory for expiration timer\n");
d171 3
a173 2
		log(LOG_WARNING,
		    "esp_input(): out of memory for expiration timer\n");
d194 2
a195 1
	log(LOG_ALERT, "esp_input(): processing failed for ESP packet from %x to %x, spi %08x\n", ipn.ip_src, ipn.ip_dst, ntohl(spi));
d210 2
a211 1
		  log(LOG_ALERT, "esp_input(): ESP-tunnel with different internal addresses %x/%x, SA %08x/%x\n", ipo->ip_src, ipo->ip_dst, tdbp->tdb_spi, tdbp->tdb_dst);
d219 2
a220 1
	    log(LOG_ALERT, "esp_input(): ESP-tunnel used when expecting ESP-transport, SA %08x/%x\n", tdbp->tdb_spi, tdbp->tdb_dst);
@


1.10
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.9 1997/07/18 18:09:54 provos Exp $	*/
d112 1
a112 1
	log(LOG_ERR, "esp_input(): could not find SA for ESP packet from %x to %x, spi %08x", ipo->ip_src, ipo->ip_dst, ntohl(spi));
d120 1
a120 3
        log(LOG_ALERT,
            "esp_input(): attempted to use invalid ESP SA %08x, packet %x->%x",
            ntohl(spi), ipo->ip_src, ipo->ip_dst);
d128 1
a128 1
        log(LOG_ALERT, "esp_input(): attempted to use uninitialized ESP SA %08x, packet from %x to %x", ntohl(spi), ipo->ip_src, ipo->ip_dst);
d147 1
a147 1
		    "esp_input(): out of memory for expiration timer");
d168 1
a168 1
		    "esp_input(): out of memory for expiration timer");
d189 1
a189 1
	log(LOG_ALERT, "esp_input(): processing failed for ESP packet from %x to %x, spi %08x", ipn.ip_src, ipn.ip_dst, ntohl(spi));
d212 1
a212 1
	    log(LOG_ALERT, "esp_input(): ESP-tunnel used when expecting ESP-transport, SA %08x/%x", tdbp->tdb_spi, tdbp->tdb_dst);
@


1.9
log
@enablespi/disablespi in encap + print spi's in hostorder
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.8 1997/07/11 23:37:56 provos Exp $	*/
d73 1
d138 1
a138 1
    /* Register first use */
d140 22
a161 1
      tdbp->tdb_first_use = time.tv_sec;
d163 22
d196 25
@


1.8
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.7 1997/07/01 22:12:45 provos Exp $	*/
d111 1
a111 1
	log(LOG_ERR, "esp_input(): could not find SA for ESP packet from %x to %x, spi %08x", ipo->ip_src, ipo->ip_dst, spi);
d121 1
a121 1
            spi, ipo->ip_src, ipo->ip_dst);
d129 1
a129 1
        log(LOG_ALERT, "esp_input(): attempted to use uninitialized ESP SA %08x, packet from %x to %x", spi, ipo->ip_src, ipo->ip_dst);
d147 1
a147 1
	log(LOG_ALERT, "esp_input(): processing failed for ESP packet from %x to %x, spi %08x", ipn.ip_src, ipn.ip_dst, spi);
@


1.7
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.6 1997/06/25 07:53:24 provos Exp $	*/
d61 1
a71 1
    struct ip *ipo;
d73 3
a76 2
    u_int32_t spi;
    struct tdb *tdbp;
a80 10
     * Strip IP options, if any.
     */

    if (iphlen > sizeof (struct ip))
    {
	ip_stripoptions(m, (struct mbuf *)0);
	iphlen = sizeof (struct ip);
    }
	
    /*
d85 1
a85 1
    if (m->m_len < iphlen + ESP_FLENGTH)
d87 1
a87 1
	if ((m = m_pullup(m, iphlen + ESP_FLENGTH)) == 0)
d89 4
d96 1
d99 2
a100 1
    spi = *((u_int32_t *)((caddr_t)ipo + iphlen));
d108 1
a108 1
    tdbp = gettdb(spi, ipo->ip_dst);
d111 1
a111 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_input: no tdb for spi=%x\n", spi);
#endif ENCDEBUG
d119 3
a121 4
#ifdef ENCDEBUG
	if (encdebug);
	  printf("esp_input: spi=%x is not longer/yet valid\n", spi);
#endif
d129 1
a129 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("esp_input: no xform for spi=%x\n", spi);
#endif ENCDEBUG
d141 1
d147 1
d166 4
d172 1
@


1.6
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.5 1997/06/21 00:09:16 deraadt Exp $	*/
d145 1
a145 1
    m->m_pkthdr.rcvif = tdbp->tdb_rcvif;
@


1.5
log
@u_int32_t changes, need testing
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.4 1997/06/20 05:41:49 provos Exp $	*/
d123 11
d146 5
@


1.4
log
@ah-sha1 + esp-3des + indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.3 1997/02/26 20:53:09 deraadt Exp $	*/
d74 1
a74 1
    u_long spi;
d103 1
a103 1
    spi = *((u_long *)((caddr_t)ipo + iphlen));
@


1.3
log
@count input/output packets for esp
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.2 1997/02/24 14:06:39 niklas Exp $	*/
d71 5
a75 5
	struct ip *ipo;
	struct ifqueue *ifq = NULL;
	int s;
	u_long spi;
	struct tdb *tdbp;
d77 1
a77 1
	espstat.esps_input++;
d79 18
a96 5
	/*
	 * Strip IP options, if any.
	 */

	if (iphlen > sizeof (struct ip))
d98 2
a99 2
		ip_stripoptions(m, (struct mbuf *)0);
		iphlen = sizeof (struct ip);
a100 5
	
	/*
	 * Make sure that at least the SPI is in the same mbuf
	 */

d102 2
a103 16
	if (m->m_len < iphlen + ESP_FLENGTH)
	{
		if ((m = m_pullup(m, iphlen + ESP_FLENGTH)) == 0)
		{
			espstat.esps_hdrops++;
			return;
		}
		ipo = mtod(m, struct ip *);
	}
	spi = *((u_long *)((caddr_t)ipo + iphlen));

	/*
	 * Find tunnel control block and (indirectly) call the appropriate
	 * kernel crypto routine. The resulting mbuf chain is a valid
	 * IP packet ready to go through input processing.
	 */
d105 9
a113 3
	tdbp = gettdb(spi, ipo->ip_dst);
	if (tdbp == NULL)
	{
d115 2
a116 2
		if (encdebug)
		  printf("esp_input: no tdb for spi=%x\n", spi);
d118 4
a121 4
		m_freem(m);
		espstat.esps_notdb++;
		return;
	}
d123 2
a124 2
	if (tdbp->tdb_xform == NULL)
	{
d126 2
a127 2
		if (encdebug)
		  printf("esp_input: no xform for spi=%x\n", spi);
d129 4
a132 4
		m_freem(m);
		espstat.esps_noxform++;
		return;
	}
d134 1
a134 1
	m->m_pkthdr.rcvif = tdbp->tdb_rcvif;
d136 1
a136 1
	m = (*(tdbp->tdb_xform->xf_input))(m, tdbp);
d138 5
a142 12
	if (m == NULL)
	{
		espstat.esps_badkcr++;
		return;
	}

	/*
	 * Interface pointer is already in first mbuf; chop off the 
	 * `outer' header and reschedule.
	 */

	ifq = &ipintrq;
d144 13
a156 11
	s = splimp();			/* isn't it already? */
	if (IF_QFULL(ifq))
	{
		IF_DROP(ifq);
		m_freem(m);
		espstat.esps_qfull++;
		splx(s);
		return;
	}
	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IP);
d159 5
@


1.2
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 2
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 2
d61 2
@
