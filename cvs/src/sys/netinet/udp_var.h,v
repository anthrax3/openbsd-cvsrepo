head	1.33;
access;
symbols
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.6
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.8
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.10
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.16
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.14
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.12
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.10
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.32;
commitid	00hB28wQPwG5Ysk0;

1.32
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.31;
commitid	ZsxSSZJSFxZH81LL;

1.31
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.30;
commitid	3e3CkrbYekyVOcxy;

1.30
date	2017.01.26.13.03.47;	author bluhm;	state Exp;
branches;
next	1.29;
commitid	wBlwxPiTlfo8m7xr;

1.29
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.28;
commitid	pVtptbHA3yk4jSpN;

1.28
date	2016.11.18.02.53.47;	author dlg;	state Exp;
branches;
next	1.27;
commitid	VkivwyRVzetroSYM;

1.27
date	2016.06.18.10.36.13;	author vgross;	state Exp;
branches;
next	1.26;
commitid	r16P5gVURcjZa76o;

1.26
date	2014.04.23.12.25.35;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.25.10.13.53;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.24.06.18.33;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.23.23.51.29;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.01.16.22.05;	author bluhm;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.21.11.38.27;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.24.19.48.32;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.13.20.00.53;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.17.12.07.45;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.12.00.48.52;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.23.06.03.14;	author angelos;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.06.09.07.03.45;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.18.17.32.48;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.03.27.21.04.21;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	99.02.04.16.05.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.01.24.18.21.40;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.08.26.20.02.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.08.09.23.36.28;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.22.30.52;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.50.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.13;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2001.05.14.22.40.15;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.07.04.10.55.13;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.05.13.19.36.18;	author ho;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@/*	$OpenBSD: udp_var.h,v 1.32 2017/03/13 20:18:21 claudio Exp $	*/
/*	$NetBSD: udp_var.h,v 1.12 1996/02/13 23:44:41 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)udp_var.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET_UDP_VAR_H_
#define _NETINET_UDP_VAR_H_

/*
 * UDP kernel structures and variables.
 */
struct	udpiphdr {
	struct	ipovly ui_i;		/* overlaid ip structure */
	struct	udphdr ui_u;		/* udp header */
};
#define	ui_x1		ui_i.ih_x1
#define	ui_pr		ui_i.ih_pr
#define	ui_len		ui_i.ih_len
#define	ui_src		ui_i.ih_src
#define	ui_dst		ui_i.ih_dst
#define	ui_sport	ui_u.uh_sport
#define	ui_dport	ui_u.uh_dport
#define	ui_ulen		ui_u.uh_ulen
#define	ui_sum		ui_u.uh_sum

struct	udpstat {
				/* input statistics: */
	u_long	udps_ipackets;		/* total input packets */
	u_long	udps_hdrops;		/* packet shorter than header */
	u_long	udps_badsum;		/* checksum error */
	u_long	udps_nosum;		/* no checksum */
	u_long	udps_badlen;		/* data length larger than packet */
	u_long	udps_noport;		/* no socket on port */
	u_long	udps_noportbcast;	/* of above, arrived as broadcast */
	u_long	udps_nosec;		/* dropped for lack of ipsec */
	u_long	udps_fullsock;		/* not delivered, input socket full */
	u_long	udps_pcbhashmiss;	/* input packets missing pcb hash */
	u_long	udps_inswcsum;		/* input software-csummed packets */
				/* output statistics: */
	u_long	udps_opackets;		/* total output packets */
	u_long	udps_outswcsum;		/* output software-csummed packets */
};

/*
 * Names for UDP sysctl objects
 */
#define	UDPCTL_CHECKSUM		1 /* checksum UDP packets */
#define	UDPCTL_BADDYNAMIC	2 /* return bad dynamic port bitmap */
#define UDPCTL_RECVSPACE	3 /* receive buffer space */
#define UDPCTL_SENDSPACE	4 /* send buffer space */
#define UDPCTL_STATS		5 /* UDP statistics */
#define UDPCTL_ROOTONLY		6 /* root only port bitmap */
#define UDPCTL_MAXID		7

#define UDPCTL_NAMES { \
	{ 0, 0 }, \
	{ "checksum", CTLTYPE_INT }, \
	{ "baddynamic", CTLTYPE_STRUCT }, \
	{ "recvspace",  CTLTYPE_INT }, \
	{ "sendspace",  CTLTYPE_INT }, \
	{ "stats",	CTLTYPE_STRUCT }, \
	{ "rootonly", CTLTYPE_STRUCT }, \
}

#define UDPCTL_VARS { \
	NULL, \
	&udpcksum, \
	NULL, \
	&udp_recvspace, \
	&udp_sendspace, \
	NULL, \
	NULL \
}

#ifdef _KERNEL

#include <sys/percpu.h>

enum udpstat_counters {
			/* input statistics: */
	udps_ipackets,		/* total input packets */
	udps_hdrops,		/* packet shorter than header */
	udps_badsum,		/* checksum error */
	udps_nosum,		/* no checksum */
	udps_badlen,		/* data length larger than packet */
	udps_noport,		/* no socket on port */
	udps_noportbcast,	/* of above, arrived as broadcast */
	udps_nosec,		/* dropped for lack of ipsec */
	udps_fullsock,		/* not delivered, input socket full */
	udps_pcbhashmiss,	/* input packets missing pcb hash */
	udps_inswcsum,		/* input software-csummed packets */
			/* output statistics: */
	udps_opackets,		/* total output packets */
	udps_outswcsum,		/* output software-csummed packets */

	udps_ncounters
};

extern struct cpumem *udpcounters;

static inline void
udpstat_inc(enum udpstat_counters c)
{
	counters_inc(udpcounters, c);
}

extern struct	inpcbtable udbtable;
extern struct	udpstat udpstat;

#ifdef INET6
void	udp6_ctlinput(int, struct sockaddr *, u_int, void *);
#endif /* INET6 */
void	 udp_ctlinput(int, struct sockaddr *, u_int, void *);
void	 udp_init(void);
int	 udp_input(struct mbuf **, int *, int, int);
#ifdef INET6
int	 udp6_output(struct inpcb *, struct mbuf *, struct mbuf *,
	struct mbuf *);
#endif /* INET6 */
int	 udp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
int	 udp_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
int	 udp_attach(struct socket *, int);
#endif /* _KERNEL */
#endif /* _NETINET_UDP_VAR_H_ */
@


1.32
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.31 2017/01/29 19:58:47 bluhm Exp $	*/
d144 1
a144 1
int	 udp_input(struct mbuf **, int *, int);
@


1.31
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.30 2017/01/26 13:03:47 bluhm Exp $	*/
d152 1
@


1.30
log
@Reduce the difference between struct protosw and ip6protosw.  The
IPv4 pr_ctlinput functions did return a void pointer that was always
NULL and never used.  Make all functions void like in the IPv6 case.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.29 2017/01/25 17:34:31 bluhm Exp $	*/
a140 1
int	udp6_input(struct mbuf **, int *, int);
d144 1
a144 1
void	 udp_input(struct mbuf *, int, int);
@


1.29
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.28 2016/11/18 02:53:47 dlg Exp $	*/
d143 1
a143 1
void	 *udp_ctlinput(int, struct sockaddr *, u_int, void *);
@


1.28
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the udpstat struct.

udpstat_inc(udps_foo) replaces udpstat.udps_foo++ for the actual
updates. udpstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the udpstat struct for
now.

ok mpi@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.27 2016/06/18 10:36:13 vgross Exp $	*/
d145 1
a145 1
void	 udp_input(struct mbuf *, ...);
@


1.27
log
@Add net.inet.{tcp,udp}.rootonly sysctl, to mark which ports
cannot be bound to by non-root users.

Ok millert@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.26 2014/04/23 12:25:35 mpi Exp $	*/
d105 31
@


1.26
log
@Don't use varargs for udp_output() and sync the argument order with
udp6_output().

ok henning@@, reyk@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.25 2014/01/25 10:13:53 deraadt Exp $	*/
d81 2
a82 1
#define UDPCTL_MAXID		6
d90 2
a91 1
	{ "stats",	CTLTYPE_STRUCT } \
d100 1
@


1.25
log
@revert counter size changes.  this breaks netstat.  digging further, there
are so many inconsistancies, that moving one deck chair is pointless.
more thought required.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.23 2014/01/23 23:51:29 henning Exp $	*/
a115 1
int	 udp_output(struct mbuf *, ...);
@


1.24
log
@make the udpstat counters u_int32_t, for consistency with tcpstat
ok krw phessler
@
text
@d57 11
a67 11
	u_int32_t	udps_ipackets;	/* total input packets */
	u_int32_t	udps_hdrops;	/* packet shorter than header */
	u_int32_t	udps_badsum;	/* checksum error */
	u_int32_t	udps_nosum;	/* no checksum */
	u_int32_t	udps_badlen;	/* data length larger than packet */
	u_int32_t	udps_noport;	/* no socket on port */
	u_int32_t	udps_noportbcast; /* of above, arrived as broadcast */
	u_int32_t	udps_nosec;	/* dropped for lack of ipsec */
	u_int32_t	udps_fullsock;	/* not delivered, input socket full */
	u_int32_t	udps_pcbhashmiss; /* input packets missing pcb hash */
	u_int32_t	udps_inswcsum;	/* input software-csummed packets */
d69 2
a70 2
	u_int32_t	udps_opackets;	/* total output packets */
	u_int32_t	udps_outswcsum;	/* output software-csummed packets */
@


1.23
log
@since the cksum rewrite the counters for hardware checksummed packets
are are lie, since the software engine emulates hardware offloading
and that is later indistinguishable. so kill the hw cksummed counters.
introduce software checksummed packet counters instead.
tcp/udp handles ip & ipvshit, ip cksum covered, 6 has no ip layer cksum.
as before we still have a miscounting bug for inbound with pf on, to be
fixed in the next step.
found by, prodding & ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.21 2010/10/21 11:38:27 bluhm Exp $	*/
d57 11
a67 11
	u_long	udps_ipackets;		/* total input packets */
	u_long	udps_hdrops;		/* packet shorter than header */
	u_long	udps_badsum;		/* checksum error */
	u_long	udps_nosum;		/* no checksum */
	u_long	udps_badlen;		/* data length larger than packet */
	u_long	udps_noport;		/* no socket on port */
	u_long	udps_noportbcast;	/* of above, arrived as broadcast */
	u_long	udps_nosec;		/* dropped for lack of ipsec */
	u_long	udps_fullsock;		/* not delivered, input socket full */
	u_long	udps_pcbhashmiss;	/* input packets missing pcb hash */
	u_long	udps_inswcsum;		/* input software-csummed packets */
d69 2
a70 2
	u_long	udps_opackets;		/* total output packets */
	u_long	udps_outswcsum;		/* output software-csummed packets */
@


1.22
log
@Pass the routing domain to IPv6 pr_ctlinput() like in IPv4.
OK claudio@@
@
text
@d67 1
a67 1
	u_long	udps_inhwcsum;		/* input hardware-csummed packets */
d70 1
a70 1
	u_long	udps_outhwcsum;		/* output hardware-csummed packets */
@


1.21
log
@There is no TCP6 in our kernel, so remove the #ifndef TCP6.
No binary change.
ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.20 2009/11/13 20:54:05 claudio Exp $	*/
d106 1
a106 1
void	udp6_ctlinput(int, struct sockaddr *, void *);
@


1.20
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.19 2008/05/24 19:48:32 thib Exp $	*/
d105 1
a105 1
#if defined(INET6) && !defined(TCP6)
d108 1
a108 1
#endif /* INET6 && !TCP6 */
@


1.19
log
@Remove {tcp/udp}6_usrreq(); Since the normal ones now
take a proc argument, theres no need for these, since
they are just wrappers.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.18 2008/05/23 15:51:12 thib Exp $	*/
d109 1
a109 1
void	 *udp_ctlinput(int, struct sockaddr *, void *);
@


1.18
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.17 2007/12/13 20:00:53 reyk Exp $	*/
a107 2
int	udp6_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
@


1.17
log
@implement sysctls to report IP, TCP, UDP, and ICMP statistics and
change netstat to use them instead of accessing kvm for it. more
protocols will be added later.

discussed with deraadt@@ claudio@@ gilles@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.16 2004/02/17 12:07:45 markus Exp $	*/
d121 1
a121 1
	    int, struct mbuf *, struct mbuf *, struct mbuf *);
@


1.16
log
@switch to sysctl_int_arr(); ok henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.15 2003/06/02 23:28:15 millert Exp $	*/
d80 2
a81 1
#define UDPCTL_MAXID		5
d89 1
d98 1
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.14 2003/05/12 00:48:52 jason Exp $	*/
d88 8
@


1.14
log
@Nuke a whole bunch of commons; ok tedu (still more to come *sigh*)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.13 2002/03/14 01:27:11 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.12 2001/06/23 06:03:14 angelos Exp $	*/
d95 2
a96 2
struct	inpcbtable udbtable;
struct	udpstat udpstat;
@


1.12
log
@Keep stats on TCP/UDP hardware checksumming.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.11 2001/06/09 07:03:45 angelos Exp $	*/
d99 4
a102 4
void	udp6_ctlinput __P((int, struct sockaddr *, void *));
int	udp6_input __P((struct mbuf **, int *, int));
int	udp6_usrreq __P((struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *));
d104 3
a106 3
void	 *udp_ctlinput __P((int, struct sockaddr *, void *));
void	 udp_init __P((void));
void	 udp_input __P((struct mbuf *, ...));
d108 2
a109 2
int	 udp6_output __P((struct inpcb *, struct mbuf *, struct mbuf *,
	struct mbuf *));
d111 4
a114 4
int	 udp_output __P((struct mbuf *, ...));
int	 udp_sysctl __P((int *, u_int, void *, size_t *, void *, size_t));
int	 udp_usrreq __P((struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.12 2001/06/23 06:03:14 angelos Exp $	*/
d99 4
a102 4
void	udp6_ctlinput(int, struct sockaddr *, void *);
int	udp6_input(struct mbuf **, int *, int);
int	udp6_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
d104 3
a106 3
void	 *udp_ctlinput(int, struct sockaddr *, void *);
void	 udp_init(void);
void	 udp_input(struct mbuf *, ...);
d108 2
a109 2
int	 udp6_output(struct inpcb *, struct mbuf *, struct mbuf *,
	struct mbuf *);
d111 4
a114 4
int	 udp_output(struct mbuf *, ...);
int	 udp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
int	 udp_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *);
@


1.12.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 2
a96 2
extern struct	inpcbtable udbtable;
extern struct	udpstat udpstat;
@


1.11
log
@Inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.10 2000/06/18 17:32:48 itojun Exp $	*/
d71 1
d74 1
@


1.10
log
@sync with KAME udp6_output().  udp output logic is very different between
IPv4/v6 so the separation should make more sense.

TODO: remove IPv6 case from udp_output()
TODO: remove/comment out/#if 0 IPv4 mapped address cases
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.9 1999/12/08 06:50:20 itojun Exp $	*/
d39 3
d101 1
a101 1
#endif
d108 1
a108 1
#endif
d113 2
a114 1
#endif
@


1.9
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.8 1999/03/27 21:04:21 provos Exp $	*/
d102 4
@


1.9.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.10 2000/06/18 17:32:48 itojun Exp $	*/
a101 4
#ifdef INET6
int	 udp6_output __P((struct inpcb *, struct mbuf *, struct mbuf *,
	struct mbuf *));
#endif
@


1.9.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.9.2.1 2001/05/14 22:40:15 niklas Exp $	*/
a38 3
#ifndef _NETINET_UDP_VAR_H_
#define _NETINET_UDP_VAR_H_

a67 1
	u_long	udps_inhwcsum;		/* input hardware-csummed packets */
a69 1
	u_long	udps_outhwcsum;		/* output hardware-csummed packets */
d98 1
a98 1
#endif /* INET6 && !TCP6 */
d105 1
a105 1
#endif /* INET6 */
d110 1
a110 2
#endif /* _KERNEL */
#endif /* _NETINET_UDP_VAR_H_ */
@


1.9.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 4
a102 4
void	udp6_ctlinput(int, struct sockaddr *, void *);
int	udp6_input(struct mbuf **, int *, int);
int	udp6_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
d104 3
a106 3
void	 *udp_ctlinput(int, struct sockaddr *, void *);
void	 udp_init(void);
void	 udp_input(struct mbuf *, ...);
d108 2
a109 2
int	 udp6_output(struct inpcb *, struct mbuf *, struct mbuf *,
	struct mbuf *);
d111 4
a114 4
int	 udp_output(struct mbuf *, ...);
int	 udp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
int	 udp_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *);
@


1.9.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.9.2.3 2002/03/28 14:56:46 niklas Exp $	*/
d95 2
a96 2
extern struct	inpcbtable udbtable;
extern struct	udpstat udpstat;
@


1.9.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.9.2.4 2003/05/13 19:36:18 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.2.6
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a87 8
}

#define UDPCTL_VARS { \
	NULL, \
	&udpcksum, \
	NULL, \
	&udp_recvspace, \
	&udp_sendspace, \
@


1.8
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.7 1999/02/04 16:05:02 deraadt Exp $	*/
d93 6
@


1.7
log
@report on no udp checksum
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.6 1998/01/24 18:21:40 mickey Exp $	*/
d65 1
@


1.6
log
@sysctl for def sizes for tcp/udp send/recv queues
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.5 1997/08/26 20:02:35 deraadt Exp $	*/
d61 1
@


1.5
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.4 1997/08/09 23:36:28 millert Exp $	*/
d73 5
a77 3
#define	UDPCTL_CHECKSUM		1	/* checksum UDP packets */
#define	UDPCTL_BADDYNAMIC	2	/* return bad dynamic port bitmap */
#define UDPCTL_MAXID		3
d83 2
@


1.4
log
@The list of tcp/udp ports not to allocate dynamically is now
a bitmask configurable via sysctl([38]).  The default values
have not changed.  If one wants to change the list it should
be done early on in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_var.h,v 1.3 1996/03/03 22:30:52 niklas Exp $	*/
d43 1
a43 1
	struct 	ipovly ui_i;		/* overlaid ip structure */
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 2
a75 1
#define UDPCTL_MAXID		2
d80 1
@


1.2
log
@from netbsd:
make netinet work on systems where pointers and longs are 64 bits
(like the alpha).  Biggest problem: IP headers were overlayed with
structure which included pointers, and which therefore didn't overlay
properly on 64-bit machines.  Solution: instead of threading pointers
through IP header overlays, add a "queue element" structure to do
the threading, and point it at the ip headers.
@
text
@d1 2
a2 1
/*	$NetBSD: udp_var.h,v 1.10 1995/11/21 01:07:48 cgd Exp $	*/
d65 1
a65 1
	u_long	udpps_pcbcachemiss;	/* input packets missing pcb cache */
d85 1
a85 1
void	 udp_ctlinput __P((int, struct sockaddr *, struct ip *));
d87 2
a88 3
void	 udp_input __P((struct mbuf *, int));
int	 udp_output __P((struct inpcb *,
	    struct mbuf *, struct mbuf *, struct mbuf *));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: udp_var.h,v 1.9 1995/06/12 00:48:09 mycroft Exp $	*/
a44 2
#define	ui_next		ui_i.ih_next
#define	ui_prev		ui_i.ih_prev
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
