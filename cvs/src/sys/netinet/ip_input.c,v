head	1.296;
access;
symbols
	OPENBSD_6_1:1.295.0.4
	OPENBSD_6_1_BASE:1.295
	OPENBSD_6_0:1.279.0.4
	OPENBSD_6_0_BASE:1.279
	OPENBSD_5_9:1.268.0.2
	OPENBSD_5_9_BASE:1.268
	OPENBSD_5_8:1.252.0.4
	OPENBSD_5_8_BASE:1.252
	OPENBSD_5_7:1.246.0.2
	OPENBSD_5_7_BASE:1.246
	OPENBSD_5_6:1.235.0.4
	OPENBSD_5_6_BASE:1.235
	OPENBSD_5_5:1.226.0.4
	OPENBSD_5_5_BASE:1.226
	OPENBSD_5_4:1.214.0.2
	OPENBSD_5_4_BASE:1.214
	OPENBSD_5_3:1.200.0.2
	OPENBSD_5_3_BASE:1.200
	OPENBSD_5_2:1.196.0.2
	OPENBSD_5_2_BASE:1.196
	OPENBSD_5_1_BASE:1.195
	OPENBSD_5_1:1.195.0.4
	OPENBSD_5_0:1.195.0.2
	OPENBSD_5_0_BASE:1.195
	OPENBSD_4_9:1.186.0.2
	OPENBSD_4_9_BASE:1.186
	OPENBSD_4_8:1.182.0.2
	OPENBSD_4_8_BASE:1.182
	OPENBSD_4_7:1.177.0.2
	OPENBSD_4_7_BASE:1.177
	OPENBSD_4_6:1.164.0.4
	OPENBSD_4_6_BASE:1.164
	OPENBSD_4_5:1.161.0.2
	OPENBSD_4_5_BASE:1.161
	OPENBSD_4_4:1.160.0.2
	OPENBSD_4_4_BASE:1.160
	OPENBSD_4_3:1.157.0.2
	OPENBSD_4_3_BASE:1.157
	OPENBSD_4_2:1.151.0.2
	OPENBSD_4_2_BASE:1.151
	OPENBSD_4_1:1.146.0.2
	OPENBSD_4_1_BASE:1.146
	OPENBSD_4_0:1.143.0.2
	OPENBSD_4_0_BASE:1.143
	OPENBSD_3_9:1.136.0.2
	OPENBSD_3_9_BASE:1.136
	OPENBSD_3_8:1.131.0.2
	OPENBSD_3_8_BASE:1.131
	OPENBSD_3_7:1.125.0.2
	OPENBSD_3_7_BASE:1.125
	OPENBSD_3_6:1.122.0.2
	OPENBSD_3_6_BASE:1.122
	SMP_SYNC_A:1.119
	SMP_SYNC_B:1.119
	OPENBSD_3_5:1.118.0.2
	OPENBSD_3_5_BASE:1.118
	OPENBSD_3_4:1.114.0.2
	OPENBSD_3_4_BASE:1.114
	UBC_SYNC_A:1.111
	OPENBSD_3_3:1.110.0.2
	OPENBSD_3_3_BASE:1.110
	OPENBSD_3_2:1.107.0.2
	OPENBSD_3_2_BASE:1.107
	OPENBSD_3_1:1.100.0.2
	OPENBSD_3_1_BASE:1.100
	UBC_SYNC_B:1.107
	UBC:1.96.0.2
	UBC_BASE:1.96
	OPENBSD_3_0:1.93.0.2
	OPENBSD_3_0_BASE:1.93
	OPENBSD_2_9_BASE:1.66
	OPENBSD_2_9:1.66.0.2
	OPENBSD_2_8:1.60.0.2
	OPENBSD_2_8_BASE:1.60
	OPENBSD_2_7:1.55.0.2
	OPENBSD_2_7_BASE:1.55
	SMP:1.48.0.2
	SMP_BASE:1.48
	kame_19991208:1.44
	OPENBSD_2_6:1.42.0.2
	OPENBSD_2_6_BASE:1.42
	OPENBSD_2_5:1.39.0.2
	OPENBSD_2_5_BASE:1.39
	OPENBSD_2_4:1.31.0.2
	OPENBSD_2_4_BASE:1.31
	OPENBSD_2_3:1.30.0.2
	OPENBSD_2_3_BASE:1.30
	OPENBSD_2_2:1.26.0.2
	OPENBSD_2_2_BASE:1.26
	OPENBSD_2_1:1.25.0.2
	OPENBSD_2_1_BASE:1.25
	OPENBSD_2_0:1.17.0.2
	OPENBSD_2_0_BASE:1.17
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.296
date	2017.04.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.295;
commitid	4O5LUh13nIhVt6oZ;

1.295
date	2017.02.05.16.23.38;	author jca;	state Exp;
branches;
next	1.294;
commitid	b4PzKhPOLWkSDY9t;

1.294
date	2017.01.31.10.24.41;	author jca;	state Exp;
branches;
next	1.293;
commitid	A2smg1VkYafec3DU;

1.293
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.292;
commitid	3e3CkrbYekyVOcxy;

1.292
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.291;
commitid	pVtptbHA3yk4jSpN;

1.291
date	2016.12.20.18.33.43;	author bluhm;	state Exp;
branches;
next	1.290;
commitid	xiXE7MGPpVXw2TS3;

1.290
date	2016.12.19.09.22.24;	author rzalamena;	state Exp;
branches;
next	1.289;
commitid	5iifwOyfMyS6GiDF;

1.289
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.288;
commitid	QqHqT2WhCBWqYgGJ;

1.288
date	2016.11.28.23.15.31;	author bluhm;	state Exp;
branches;
next	1.287;
commitid	tRB1wgF5XEe7ukoA;

1.287
date	2016.11.28.11.12.45;	author mpi;	state Exp;
branches;
next	1.286;
commitid	pr5LCKF5IZsR2oy7;

1.286
date	2016.11.23.10.04.31;	author mpi;	state Exp;
branches;
next	1.285;
commitid	RaDWHOXjhnHoNXKA;

1.285
date	2016.11.14.04.27.03;	author dlg;	state Exp;
branches;
next	1.284;
commitid	QY1vapfPGaicz2QX;

1.284
date	2016.11.14.03.51.53;	author dlg;	state Exp;
branches;
next	1.283;
commitid	Khqq96MLd95C1Z1s;

1.283
date	2016.11.08.10.45.08;	author mpi;	state Exp;
branches;
next	1.282;
commitid	9FSjK6xFpEQk1C5A;

1.282
date	2016.09.22.10.12.25;	author jsg;	state Exp;
branches;
next	1.281;
commitid	J0ffAvVwGb5OV5xw;

1.281
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.280;
commitid	RlO92XR575sygHqm;

1.280
date	2016.09.06.00.04.15;	author dlg;	state Exp;
branches;
next	1.279;
commitid	UqrCCAsrdk9XuY5o;

1.279
date	2016.07.22.07.39.06;	author mpi;	state Exp;
branches;
next	1.278;
commitid	8T33lWHszaMQ83rb;

1.278
date	2016.07.18.13.17.44;	author bluhm;	state Exp;
branches;
next	1.277;
commitid	LlSukCQvQcHux9Yv;

1.277
date	2016.06.18.10.36.13;	author vgross;	state Exp;
branches;
next	1.276;
commitid	r16P5gVURcjZa76o;

1.276
date	2016.05.07.09.56.39;	author mpi;	state Exp;
branches;
next	1.275;
commitid	M2rc4QkunCY12hSX;

1.275
date	2016.05.03.12.19.13;	author mpi;	state Exp;
branches;
next	1.274;
commitid	YaYRgHXingBHV2We;

1.274
date	2016.04.25.12.33.48;	author mpi;	state Exp;
branches;
next	1.273;
commitid	feulUuIJUbsQQIrB;

1.273
date	2016.04.19.08.23.13;	author mpi;	state Exp;
branches;
next	1.272;
commitid	6aaC9jQAC2YWe333;

1.272
date	2016.04.18.12.10.34;	author mpi;	state Exp;
branches;
next	1.271;
commitid	lpxpzSgqNAQAxtIZ;

1.271
date	2016.04.18.06.43.51;	author mpi;	state Exp;
branches;
next	1.270;
commitid	ebRPaHlX9XKssC0C;

1.270
date	2016.04.15.11.18.40;	author mpi;	state Exp;
branches;
next	1.269;
commitid	MtUvK7KSkyLnt6N3;

1.269
date	2016.03.29.10.34.42;	author sashan;	state Exp;
branches;
next	1.268;
commitid	3oT5Q5z024mhykOL;

1.268
date	2016.01.31.00.18.07;	author sashan;	state Exp;
branches;
next	1.267;
commitid	XnM42P9Sq7TQR88T;

1.267
date	2016.01.25.18.49.57;	author sashan;	state Exp;
branches;
next	1.266;
commitid	KeemoLxcm7FS1oYy;

1.266
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.265;
commitid	5qLGnZtXVLeqUvHc;

1.265
date	2015.12.03.21.11.53;	author sashan;	state Exp;
branches;
next	1.264;
commitid	nhuzteWvIf6uiITt;

1.264
date	2015.12.03.15.12.59;	author markus;	state Exp;
branches;
next	1.263;
commitid	Rj3VXXxsH73AylR7;

1.263
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.262;
commitid	Hf3C2AvfIXmCAmHE;

1.262
date	2015.11.23.15.54.45;	author mpi;	state Exp;
branches;
next	1.261;
commitid	WV42PKUkWgcnEBDH;

1.261
date	2015.11.14.15.40.40;	author mpi;	state Exp;
branches;
next	1.260;
commitid	JttZ5vSMsAwYO74u;

1.260
date	2015.10.27.12.06.37;	author mpi;	state Exp;
branches;
next	1.259;
commitid	1Jyh3vXSBrHMQpUn;

1.259
date	2015.10.26.15.49.13;	author mpi;	state Exp;
branches;
next	1.258;
commitid	vcshs4J9jdCPhov2;

1.258
date	2015.10.19.11.59.26;	author mpi;	state Exp;
branches;
next	1.257;
commitid	kfYDbDKgruYr99Oc;

1.257
date	2015.10.13.10.29.16;	author mpi;	state Exp;
branches;
next	1.256;
commitid	gcclwYrgbQaeTvzE;

1.256
date	2015.09.25.09.51.20;	author mpi;	state Exp;
branches;
next	1.255;
commitid	HqH3TPOggutnG6L9;

1.255
date	2015.09.11.19.34.20;	author dlg;	state Exp;
branches;
next	1.254;
commitid	YoN4gqtUS63kRQlK;

1.254
date	2015.09.11.10.06.52;	author dlg;	state Exp;
branches;
next	1.253;
commitid	QbrNA5xcZezPMf8P;

1.253
date	2015.08.19.15.30.25;	author bluhm;	state Exp;
branches;
next	1.252;
commitid	iSV3fzPxl42xalBZ;

1.252
date	2015.07.16.21.14.21;	author mpi;	state Exp;
branches;
next	1.251;
commitid	VGPlklxThaST7mIm;

1.251
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.250;
commitid	h7z8lokZ0dFyuWpg;

1.250
date	2015.06.07.01.25.27;	author krw;	state Exp;
branches;
next	1.249;
commitid	7yzARhkDkBsYwsVv;

1.249
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.248;
commitid	hN5bFCE56DrAjl99;

1.248
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.247;
commitid	c7ei8kPelCOOwHXy;

1.247
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.246;
commitid	p4LJxGKbi0BU2cG6;

1.246
date	2015.02.09.12.18.19;	author claudio;	state Exp;
branches;
next	1.245;
commitid	8K5RNpON80OVB59T;

1.245
date	2015.02.08.04.14.47;	author claudio;	state Exp;
branches;
next	1.244;
commitid	rSZHYxG1meCxUnls;

1.244
date	2015.01.12.13.51.45;	author mpi;	state Exp;
branches;
next	1.243;
commitid	v60fHRGiGOxDVlm2;

1.243
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.242;
commitid	t9FBKDfc4VDxpEy2;

1.242
date	2014.11.20.11.05.19;	author mpi;	state Exp;
branches;
next	1.241;
commitid	uo0PiO5ELdW7V3PO;

1.241
date	2014.11.05.14.03.02;	author mpi;	state Exp;
branches;
next	1.240;
commitid	Ii1JKOPj4OOyvsFQ;

1.240
date	2014.11.04.15.24.40;	author mpi;	state Exp;
branches;
next	1.239;
commitid	7WMzGcppcCD2uLp0;

1.239
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.238;
commitid	w0MRp28dmfD1ZzO8;

1.238
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.237;
commitid	6AYfDT0Lpez1LFQp;

1.237
date	2014.09.30.08.21.21;	author mpi;	state Exp;
branches;
next	1.236;
commitid	jkbhosXIyP17GANL;

1.236
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.235;
commitid	HQcmytntiCJTHORs;

1.235
date	2014.07.13.13.57.56;	author mpi;	state Exp;
branches;
next	1.234;
commitid	FZhOOMqcipIfV1hC;

1.234
date	2014.06.04.12.20.00;	author mpi;	state Exp;
branches;
next	1.233;
commitid	KXdoTVzXrLcIqk6n;

1.233
date	2014.05.10.12.30.27;	author claudio;	state Exp;
branches;
next	1.232;

1.232
date	2014.05.07.08.26.38;	author mpi;	state Exp;
branches;
next	1.231;

1.231
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.230;

1.230
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.229;

1.229
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.228;

1.228
date	2014.03.27.10.44.23;	author mpi;	state Exp;
branches;
next	1.227;

1.227
date	2014.03.21.10.44.42;	author mpi;	state Exp;
branches;
next	1.226;

1.226
date	2014.01.24.18.54.58;	author henning;	state Exp;
branches;
next	1.225;

1.225
date	2014.01.23.23.51.29;	author henning;	state Exp;
branches;
next	1.224;

1.224
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.223;

1.223
date	2013.12.31.03.24.44;	author tedu;	state Exp;
branches;
next	1.222;

1.222
date	2013.11.27.08.34.39;	author mpi;	state Exp;
branches;
next	1.221;

1.221
date	2013.11.17.10.07.32;	author bluhm;	state Exp;
branches;
next	1.220;

1.220
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches;
next	1.219;

1.219
date	2013.10.23.19.09.28;	author deraadt;	state Exp;
branches;
next	1.218;

1.218
date	2013.10.21.12.27.12;	author deraadt;	state Exp;
branches;
next	1.217;

1.217
date	2013.08.21.09.02.12;	author mpi;	state Exp;
branches;
next	1.216;

1.216
date	2013.08.13.09.52.53;	author mpi;	state Exp;
branches;
next	1.215;

1.215
date	2013.07.31.15.41.51;	author mikeb;	state Exp;
branches;
next	1.214;

1.214
date	2013.07.04.08.22.19;	author mpi;	state Exp;
branches;
next	1.213;

1.213
date	2013.06.26.09.12.40;	author henning;	state Exp;
branches;
next	1.212;

1.212
date	2013.06.13.12.15.52;	author mpi;	state Exp;
branches;
next	1.211;

1.211
date	2013.05.17.09.04.30;	author mpi;	state Exp;
branches;
next	1.210;

1.210
date	2013.04.24.10.17.08;	author mpi;	state Exp;
branches;
next	1.209;

1.209
date	2013.04.17.14.19.32;	author mpi;	state Exp;
branches;
next	1.208;

1.208
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.207;

1.207
date	2013.04.09.08.35.38;	author mpi;	state Exp;
branches;
next	1.206;

1.206
date	2013.03.29.13.16.14;	author bluhm;	state Exp;
branches;
next	1.205;

1.205
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.204;

1.204
date	2013.03.28.12.06.55;	author mpi;	state Exp;
branches;
next	1.203;

1.203
date	2013.03.28.00.32.11;	author bluhm;	state Exp;
branches;
next	1.202;

1.202
date	2013.03.26.13.19.26;	author mpi;	state Exp;
branches;
next	1.201;

1.201
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.200;

1.200
date	2012.11.06.12.32.42;	author henning;	state Exp;
branches;
next	1.199;

1.199
date	2012.11.01.07.55.56;	author henning;	state Exp;
branches;
next	1.198;

1.198
date	2012.09.18.12.35.51;	author blambert;	state Exp;
branches;
next	1.197;

1.197
date	2012.08.07.17.54.20;	author mikeb;	state Exp;
branches;
next	1.196;

1.196
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.195;

1.195
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.194;

1.194
date	2011.07.05.21.40.38;	author dhill;	state Exp;
branches;
next	1.193;

1.193
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches;
next	1.192;

1.192
date	2011.06.15.09.11.01;	author mikeb;	state Exp;
branches;
next	1.191;

1.191
date	2011.04.19.03.47.29;	author dlg;	state Exp;
branches;
next	1.190;

1.190
date	2011.04.14.08.15.26;	author claudio;	state Exp;
branches;
next	1.189;

1.189
date	2011.04.04.16.51.15;	author claudio;	state Exp;
branches;
next	1.188;

1.188
date	2011.04.04.13.30.03;	author henning;	state Exp;
branches;
next	1.187;

1.187
date	2011.04.02.14.38.09;	author henning;	state Exp;
branches;
next	1.186;

1.186
date	2011.02.11.12.16.30;	author bluhm;	state Exp;
branches;
next	1.185;

1.185
date	2011.02.03.17.29.16;	author millert;	state Exp;
branches;
next	1.184;

1.184
date	2010.09.08.08.34.42;	author claudio;	state Exp;
branches;
next	1.183;

1.183
date	2010.08.20.02.48.31;	author dlg;	state Exp;
branches;
next	1.182;

1.182
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.181;

1.181
date	2010.06.07.13.26.35;	author henning;	state Exp;
branches;
next	1.180;

1.180
date	2010.06.04.11.35.43;	author blambert;	state Exp;
branches;
next	1.179;

1.179
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.178;

1.178
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.177;

1.177
date	2010.01.13.10.31.17;	author henning;	state Exp;
branches;
next	1.176;

1.176
date	2010.01.13.07.05.28;	author henning;	state Exp;
branches;
next	1.175;

1.175
date	2010.01.13.01.26.28;	author henning;	state Exp;
branches;
next	1.174;

1.174
date	2009.12.07.08.19.37;	author gollo;	state Exp;
branches;
next	1.173;

1.173
date	2009.11.19.22.07.17;	author otto;	state Exp;
branches;
next	1.172;

1.172
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.171;

1.171
date	2009.08.23.20.06.25;	author david;	state Exp;
branches;
next	1.170;

1.170
date	2009.08.10.15.29.34;	author henning;	state Exp;
branches;
next	1.169;

1.169
date	2009.08.10.15.26.33;	author henning;	state Exp;
branches;
next	1.168;

1.168
date	2009.08.10.13.20.08;	author henning;	state Exp;
branches;
next	1.167;

1.167
date	2009.08.10.11.48.02;	author henning;	state Exp;
branches;
next	1.166;

1.166
date	2009.07.28.14.01.50;	author dlg;	state Exp;
branches;
next	1.165;

1.165
date	2009.07.24.12.30.05;	author dlg;	state Exp;
branches;
next	1.164;

1.164
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.163;

1.163
date	2009.06.04.05.02.25;	author henning;	state Exp;
branches;
next	1.162;

1.162
date	2009.05.18.20.37.13;	author bluhm;	state Exp;
branches;
next	1.161;

1.161
date	2008.12.24.07.41.59;	author dlg;	state Exp;
branches;
next	1.160;

1.160
date	2008.06.08.13.58.09;	author thib;	state Exp;
branches;
next	1.159;

1.159
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.158;

1.158
date	2008.04.24.11.36.38;	author dlg;	state Exp;
branches;
next	1.157;

1.157
date	2008.02.05.22.57.31;	author mpf;	state Exp;
branches;
next	1.156;

1.156
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2007.12.13.20.00.53;	author reyk;	state Exp;
branches;
next	1.154;

1.154
date	2007.10.29.16.19.23;	author chl;	state Exp;
branches;
next	1.153;

1.153
date	2007.09.10.23.05.39;	author thib;	state Exp;
branches;
next	1.152;

1.152
date	2007.09.01.18.49.28;	author henning;	state Exp;
branches;
next	1.151;

1.151
date	2007.05.30.04.46.45;	author henning;	state Exp;
branches;
next	1.150;

1.150
date	2007.05.29.17.46.24;	author henning;	state Exp;
branches;
next	1.149;

1.149
date	2007.05.28.17.16.39;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2007.05.27.20.14.15;	author dlg;	state Exp;
branches;
next	1.147;

1.147
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.146;

1.146
date	2006.12.28.20.06.10;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	2006.11.27.12.27.45;	author henning;	state Exp;
branches;
next	1.144;

1.144
date	2006.10.11.09.29.20;	author henning;	state Exp;
branches;
next	1.143;

1.143
date	2006.06.18.12.03.19;	author pascoe;	state Exp;
branches;
next	1.142;

1.142
date	2006.06.18.11.47.45;	author pascoe;	state Exp;
branches;
next	1.141;

1.141
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.140;

1.140
date	2006.06.15.10.08.34;	author pascoe;	state Exp;
branches;
next	1.139;

1.139
date	2006.05.29.20.42.27;	author claudio;	state Exp;
branches;
next	1.138;

1.138
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.136;

1.136
date	2006.01.03.14.53.50;	author mpf;	state Exp;
branches;
next	1.135;

1.135
date	2005.11.20.19.25.16;	author brad;	state Exp;
branches;
next	1.134;

1.134
date	2005.10.05.17.32.22;	author norby;	state Exp;
branches;
next	1.133;

1.133
date	2005.09.19.01.48.05;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2005.09.19.01.47.42;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2005.08.11.12.55.31;	author mpf;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2005.07.31.03.30.55;	author pascoe;	state Exp;
branches;
next	1.129;

1.129
date	2005.06.15.07.24.05;	author markus;	state Exp;
branches;
next	1.128;

1.128
date	2005.06.10.15.56.01;	author markus;	state Exp;
branches;
next	1.127;

1.127
date	2005.05.24.04.20.25;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.125;

1.125
date	2005.01.20.15.00.13;	author markus;	state Exp;
branches
	1.125.2.1;
next	1.124;

1.124
date	2004.10.18.07.41.28;	author otto;	state Exp;
branches;
next	1.123;

1.123
date	2004.09.23.17.38.10;	author brad;	state Exp;
branches;
next	1.122;

1.122
date	2004.07.31.21.27.31;	author brad;	state Exp;
branches
	1.122.2.1;
next	1.121;

1.121
date	2004.06.22.07.35.20;	author cedric;	state Exp;
branches;
next	1.120;

1.120
date	2004.06.21.19.26.01;	author mcbride;	state Exp;
branches;
next	1.119;

1.119
date	2004.06.06.16.49.09;	author cedric;	state Exp;
branches;
next	1.118;

1.118
date	2004.03.15.09.45.31;	author tedu;	state Exp;
branches;
next	1.117;

1.117
date	2004.02.15.11.16.08;	author markus;	state Exp;
branches;
next	1.116;

1.116
date	2004.02.13.01.29.46;	author brad;	state Exp;
branches;
next	1.115;

1.115
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.114;

1.114
date	2003.07.29.03.21.57;	author itojun;	state Exp;
branches;
next	1.113;

1.113
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.112;

1.112
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.111;

1.111
date	2003.05.03.21.16.30;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.109;

1.109
date	2003.02.11.21.08.04;	author cedric;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.07.09.00.34;	author kjc;	state Exp;
branches;
next	1.107;

1.107
date	2002.09.04.19.04.38;	author dhartmei;	state Exp;
branches;
next	1.106;

1.106
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.105;

1.105
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.104;

1.104
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.103;

1.103
date	2002.06.07.23.50.10;	author jasoni;	state Exp;
branches;
next	1.102;

1.102
date	2002.05.16.14.10.51;	author kjc;	state Exp;
branches;
next	1.101;

1.101
date	2002.04.24.01.05.12;	author angelos;	state Exp;
branches;
next	1.100;

1.100
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.99;

1.99
date	2002.02.22.02.49.06;	author itojun;	state Exp;
branches;
next	1.98;

1.98
date	2002.01.25.15.50.23;	author art;	state Exp;
branches;
next	1.97;

1.97
date	2002.01.23.00.39.48;	author art;	state Exp;
branches;
next	1.96;

1.96
date	2001.12.10.12.05.40;	author ho;	state Exp;
branches
	1.96.2.1;
next	1.95;

1.95
date	2001.12.06.02.12.52;	author itojun;	state Exp;
branches;
next	1.94;

1.94
date	2001.11.26.16.50.26;	author jasoni;	state Exp;
branches;
next	1.93;

1.93
date	2001.09.18.15.24.32;	author aaron;	state Exp;
branches;
next	1.92;

1.92
date	2001.07.17.20.34.50;	author provos;	state Exp;
branches;
next	1.91;

1.91
date	2001.07.16.22.11.04;	author fgsch;	state Exp;
branches;
next	1.90;

1.90
date	2001.07.05.16.45.54;	author jjbg;	state Exp;
branches;
next	1.89;

1.89
date	2001.06.28.21.53.42;	author provos;	state Exp;
branches;
next	1.88;

1.88
date	2001.06.27.05.50.07;	author kjc;	state Exp;
branches;
next	1.87;

1.87
date	2001.06.26.18.17.54;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2001.06.25.08.05.24;	author art;	state Exp;
branches;
next	1.85;

1.85
date	2001.06.24.23.42.40;	author mickey;	state Exp;
branches;
next	1.84;

1.84
date	2001.06.24.19.48.58;	author kjell;	state Exp;
branches;
next	1.83;

1.83
date	2001.06.24.18.24.56;	author provos;	state Exp;
branches;
next	1.82;

1.82
date	2001.06.23.18.54.44;	author angelos;	state Exp;
branches;
next	1.81;

1.81
date	2001.06.23.18.45.29;	author angelos;	state Exp;
branches;
next	1.80;

1.80
date	2001.06.23.16.15.56;	author fgsch;	state Exp;
branches;
next	1.79;

1.79
date	2001.06.23.05.55.40;	author angelos;	state Exp;
branches;
next	1.78;

1.78
date	2001.06.23.03.39.03;	author angelos;	state Exp;
branches;
next	1.77;

1.77
date	2001.06.23.02.27.09;	author angelos;	state Exp;
branches;
next	1.76;

1.76
date	2001.06.19.00.48.23;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2001.06.08.03.53.46;	author angelos;	state Exp;
branches;
next	1.74;

1.74
date	2001.06.01.19.53.33;	author provos;	state Exp;
branches;
next	1.73;

1.73
date	2001.05.30.02.12.31;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2001.05.27.00.39.26;	author angelos;	state Exp;
branches;
next	1.71;

1.71
date	2001.05.20.19.19.57;	author fgsch;	state Exp;
branches;
next	1.70;

1.70
date	2001.05.20.08.35.11;	author angelos;	state Exp;
branches;
next	1.69;

1.69
date	2001.05.16.06.38.25;	author fgsch;	state Exp;
branches;
next	1.68;

1.68
date	2001.05.11.17.20.11;	author aaron;	state Exp;
branches;
next	1.67;

1.67
date	2001.05.01.09.55.49;	author provos;	state Exp;
branches;
next	1.66;

1.66
date	2001.03.28.20.03.03;	author angelos;	state Exp;
branches;
next	1.65;

1.65
date	2001.03.25.05.51.31;	author csapuntz;	state Exp;
branches;
next	1.64;

1.64
date	2001.03.18.07.09.49;	author provos;	state Exp;
branches;
next	1.63;

1.63
date	2001.03.03.01.09.28;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2001.03.03.01.00.19;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2000.12.03.19.56.20;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2000.10.13.02.01.10;	author itojun;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2000.09.22.01.40.56;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2000.09.19.03.20.58;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	2000.09.18.22.06.37;	author provos;	state Exp;
branches;
next	1.56;

1.56
date	2000.05.15.11.07.33;	author itojun;	state Exp;
branches;
next	1.55;

1.55
date	2000.05.10.03.22.39;	author jason;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2000.05.06.17.55.08;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2000.05.06.01.47.05;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2000.04.09.17.43.02;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2000.04.04.13.43.02;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2000.03.27.07.26.45;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2000.03.03.13.09.28;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2000.01.10.06.59.22;	author angelos;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2000.01.10.04.30.52;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2000.01.09.22.30.37;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2000.01.09.22.17.57;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	99.11.29.16.22.29;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	99.09.25.06.35.48;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	99.09.23.07.20.35;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	99.04.23.15.18.03;	author provos;	state Exp;
branches;
next	1.39;

1.39
date	99.04.12.03.17.09;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	99.04.11.19.41.38;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	99.02.21.04.01.46;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	99.02.19.19.50.43;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	99.02.17.23.51.12;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	98.12.28.23.54.57;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	98.12.26.12.35.11;	author provos;	state Exp;
branches;
next	1.32;

1.32
date	98.11.13.22.24.17;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	98.05.18.21.10.49;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	98.02.14.18.50.36;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	98.02.03.21.11.08;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.02.01.21.46.02;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.02.01.18.09.23;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	97.08.09.23.36.29;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.02.28.03.44.53;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	97.02.22.13.25.28;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	97.02.22.05.56.48;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	97.02.13.16.26.58;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.02.11.18.04.03;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.01.26.01.23.43;	author tholo;	state Exp;
branches;
next	1.19;

1.19
date	96.10.27.00.47.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.10.18.03.04.54;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	96.09.02.18.14.19;	author dm;	state Exp;
branches;
next	1.16;

1.16
date	96.08.14.07.50.13;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.08.02.18.21.00;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	96.07.29.02.34.30;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	96.07.18.05.01.04;	author dm;	state Exp;
branches;
next	1.12;

1.12
date	96.05.07.15.20.25;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.04.21.22.29.00;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.03.09.21.30.22;	author dm;	state Exp;
branches;
next	1.9;

1.9
date	96.03.03.22.30.37;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.01.25.05.41.44;	author dm;	state Exp;
branches;
next	1.7;

1.7
date	96.01.07.02.34.03;	author dm;	state Exp;
branches;
next	1.6;

1.6
date	95.12.14.12.37.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.14.06.50.40;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.28.22.42.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.28.01.22.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.26.23.40.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches;
next	;

1.48.2.1
date	2000.03.24.09.09.36;	author niklas;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2001.05.14.22.40.11;	author niklas;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	2001.07.04.10.54.49;	author niklas;	state Exp;
branches;
next	1.48.2.4;

1.48.2.4
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.48.2.5;

1.48.2.5
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.48.2.6;

1.48.2.6
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.48.2.7;

1.48.2.7
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.48.2.8;

1.48.2.8
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.48.2.9;

1.48.2.9
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.48.2.10;

1.48.2.10
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.48.2.11;

1.48.2.11
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.48.2.12;

1.48.2.12
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.48.2.13;

1.48.2.13
date	2004.06.07.20.41.39;	author niklas;	state Exp;
branches;
next	;

1.55.2.1
date	2000.05.29.18.24.03;	author jason;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2000.10.07.05.43.15;	author jason;	state Exp;
branches;
next	;

1.60.2.1
date	2000.12.11.04.34.06;	author jason;	state Exp;
branches;
next	;

1.96.2.1
date	2002.01.31.22.55.45;	author niklas;	state Exp;
branches;
next	1.96.2.2;

1.96.2.2
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.96.2.3;

1.96.2.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.96.2.4;

1.96.2.4
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;

1.122.2.1
date	2005.06.14.01.49.24;	author brad;	state Exp;
branches;
next	;

1.125.2.1
date	2005.06.14.02.10.33;	author brad;	state Exp;
branches;
next	1.125.2.2;

1.125.2.2
date	2006.03.05.03.04.01;	author brad;	state Exp;
branches;
next	;

1.131.2.1
date	2006.03.05.03.08.25;	author brad;	state Exp;
branches;
next	;


desc
@@


1.296
log
@When building counter memory in preparation to copy to userland, always
zero the buffers first.  All the current objects appear to be safe,
however future changes might introduce structure pads.
Discussed with guenther, ok bluhm
@
text
@/*	$OpenBSD: ip_input.c,v 1.295 2017/02/05 16:23:38 jca Exp $	*/
/*	$NetBSD: ip_input.c,v 1.30 1996/03/16 23:53:58 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip_input.c	8.2 (Berkeley) 1/4/94
 */

#include "pf.h"
#include "carp.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>
#include <sys/pool.h>
#include <sys/task.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#ifdef MROUTING
#include <netinet/ip_mroute.h>
#endif

#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#endif /* IPSEC */

#if NCARP > 0
#include <net/if_types.h>
#include <netinet/ip_carp.h>
#endif

struct ipqhead ipq;

int encdebug = 0;
int ipsec_keep_invalid = IPSEC_DEFAULT_EMBRYONIC_SA_TIMEOUT;
int ipsec_require_pfs = IPSEC_DEFAULT_PFS;
int ipsec_soft_allocations = IPSEC_DEFAULT_SOFT_ALLOCATIONS;
int ipsec_exp_allocations = IPSEC_DEFAULT_EXP_ALLOCATIONS;
int ipsec_soft_bytes = IPSEC_DEFAULT_SOFT_BYTES;
int ipsec_exp_bytes = IPSEC_DEFAULT_EXP_BYTES;
int ipsec_soft_timeout = IPSEC_DEFAULT_SOFT_TIMEOUT;
int ipsec_exp_timeout = IPSEC_DEFAULT_EXP_TIMEOUT;
int ipsec_soft_first_use = IPSEC_DEFAULT_SOFT_FIRST_USE;
int ipsec_exp_first_use = IPSEC_DEFAULT_EXP_FIRST_USE;
int ipsec_expire_acquire = IPSEC_DEFAULT_EXPIRE_ACQUIRE;
char ipsec_def_enc[20];
char ipsec_def_auth[20];
char ipsec_def_comp[20];

/* values controllable via sysctl */
int	ipforwarding = 0;
int	ipmforwarding = 0;
int	ipmultipath = 0;
int	ipsendredirects = 1;
int	ip_dosourceroute = 0;
int	ip_defttl = IPDEFTTL;
int	ip_mtudisc = 1;
u_int	ip_mtudisc_timeout = IPMTUDISCTIMEOUT;
int	ip_directedbcast = 0;

struct rttimer_queue *ip_mtudisc_timeout_q = NULL;

/* Keep track of memory used for reassembly */
int	ip_maxqueue = 300;
int	ip_frags = 0;

int *ipctl_vars[IPCTL_MAXID] = IPCTL_VARS;

struct niqueue ipintrq = NIQUEUE_INITIALIZER(IFQ_MAXLEN, NETISR_IP);

struct pool ipqent_pool;
struct pool ipq_pool;

struct cpumem *ipcounters;

int ip_sysctl_ipstat(void *, size_t *, void *);

static struct mbuf_queue	ipsend_mq;

void	ip_ours(struct mbuf *);
int	ip_dooptions(struct mbuf *, struct ifnet *);
int	in_ouraddr(struct mbuf *, struct ifnet *, struct rtentry **);
#ifdef IPSEC
int	ip_input_ipsec_fwd_check(struct mbuf *, int);
int	ip_input_ipsec_ours_check(struct mbuf *, int);
#endif /* IPSEC */
	
static void ip_send_dispatch(void *);
static struct task ipsend_task = TASK_INITIALIZER(ip_send_dispatch, &ipsend_mq);
/*
 * Used to save the IP options in case a protocol wants to respond
 * to an incoming packet over the same route if the packet got here
 * using IP source routing.  This allows connection establishment and
 * maintenance when the remote end is on a network that is not known
 * to us.
 */
struct ip_srcrt {
	int		isr_nhops;		   /* number of hops */
	struct in_addr	isr_dst;		   /* final destination */
	char		isr_nop;		   /* one NOP to align */
	char		isr_hdr[IPOPT_OFFSET + 1]; /* OPTVAL, OLEN & OFFSET */
	struct in_addr	isr_routes[MAX_IPOPTLEN/sizeof(struct in_addr)];
};

void save_rte(struct mbuf *, u_char *, struct in_addr);

/*
 * IP initialization: fill in IP protocol switch table.
 * All protocols not implemented in kernel go to raw IP protocol handler.
 */
void
ip_init(void)
{
	struct protosw *pr;
	int i;
	const u_int16_t defbaddynamicports_tcp[] = DEFBADDYNAMICPORTS_TCP;
	const u_int16_t defbaddynamicports_udp[] = DEFBADDYNAMICPORTS_UDP;
	const u_int16_t defrootonlyports_tcp[] = DEFROOTONLYPORTS_TCP;
	const u_int16_t defrootonlyports_udp[] = DEFROOTONLYPORTS_UDP;

	ipcounters = counters_alloc(ips_ncounters);

	pool_init(&ipqent_pool, sizeof(struct ipqent), 0,
	    IPL_SOFTNET, 0, "ipqe",  NULL);
	pool_init(&ipq_pool, sizeof(struct ipq), 0,
	    IPL_SOFTNET, 0, "ipq", NULL);

	pr = pffindproto(PF_INET, IPPROTO_RAW, SOCK_RAW);
	if (pr == NULL)
		panic("ip_init");
	for (i = 0; i < IPPROTO_MAX; i++)
		ip_protox[i] = pr - inetsw;
	for (pr = inetdomain.dom_protosw;
	    pr < inetdomain.dom_protoswNPROTOSW; pr++)
		if (pr->pr_domain->dom_family == PF_INET &&
		    pr->pr_protocol && pr->pr_protocol != IPPROTO_RAW &&
		    pr->pr_protocol < IPPROTO_MAX)
			ip_protox[pr->pr_protocol] = pr - inetsw;
	LIST_INIT(&ipq);
	if (ip_mtudisc != 0)
		ip_mtudisc_timeout_q =
		    rt_timer_queue_create(ip_mtudisc_timeout);

	/* Fill in list of ports not to allocate dynamically. */
	memset(&baddynamicports, 0, sizeof(baddynamicports));
	for (i = 0; defbaddynamicports_tcp[i] != 0; i++)
		DP_SET(baddynamicports.tcp, defbaddynamicports_tcp[i]);
	for (i = 0; defbaddynamicports_udp[i] != 0; i++)
		DP_SET(baddynamicports.udp, defbaddynamicports_udp[i]);

	/* Fill in list of ports only root can bind to. */
	memset(&rootonlyports, 0, sizeof(rootonlyports));
	for (i = 0; defrootonlyports_tcp[i] != 0; i++)
		DP_SET(rootonlyports.tcp, defrootonlyports_tcp[i]);
	for (i = 0; defrootonlyports_udp[i] != 0; i++)
		DP_SET(rootonlyports.udp, defrootonlyports_udp[i]);

	strlcpy(ipsec_def_enc, IPSEC_DEFAULT_DEF_ENC, sizeof(ipsec_def_enc));
	strlcpy(ipsec_def_auth, IPSEC_DEFAULT_DEF_AUTH, sizeof(ipsec_def_auth));
	strlcpy(ipsec_def_comp, IPSEC_DEFAULT_DEF_COMP, sizeof(ipsec_def_comp));

	mq_init(&ipsend_mq, 64, IPL_SOFTNET);
}

void
ipintr(void)
{
	struct mbuf *m;

	/*
	 * Get next datagram off input queue and get IP header
	 * in first mbuf.
	 */
	while ((m = niq_dequeue(&ipintrq)) != NULL) {
#ifdef	DIAGNOSTIC
		if ((m->m_flags & M_PKTHDR) == 0)
			panic("ipintr no HDR");
#endif
		ipv4_input(m);
	}
}

/*
 * IPv4 input routine.
 *
 * Checksum and byte swap header.  Process options. Forward or deliver.
 */
void
ipv4_input(struct mbuf *m)
{
	struct ifnet	*ifp;
	struct rtentry	*rt = NULL;
	struct ip	*ip;
	int hlen, len;
#if defined(MROUTING) || defined(IPSEC)
	int rv;
#endif
	in_addr_t pfrdr = 0;

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto bad;

	ipstat_inc(ips_total);
	if (m->m_len < sizeof (struct ip) &&
	    (m = m_pullup(m, sizeof (struct ip))) == NULL) {
		ipstat_inc(ips_toosmall);
		goto out;
	}
	ip = mtod(m, struct ip *);
	if (ip->ip_v != IPVERSION) {
		ipstat_inc(ips_badvers);
		goto bad;
	}
	hlen = ip->ip_hl << 2;
	if (hlen < sizeof(struct ip)) {	/* minimum header length */
		ipstat_inc(ips_badhlen);
		goto bad;
	}
	if (hlen > m->m_len) {
		if ((m = m_pullup(m, hlen)) == NULL) {
			ipstat_inc(ips_badhlen);
			goto out;
		}
		ip = mtod(m, struct ip *);
	}

	/* 127/8 must not appear on wire - RFC1122 */
	if ((ntohl(ip->ip_dst.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET ||
	    (ntohl(ip->ip_src.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) {
		if ((ifp->if_flags & IFF_LOOPBACK) == 0) {
			ipstat_inc(ips_badaddr);
			goto bad;
		}
	}

	if ((m->m_pkthdr.csum_flags & M_IPV4_CSUM_IN_OK) == 0) {
		if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_IN_BAD) {
			ipstat_inc(ips_badsum);
			goto bad;
		}

		ipstat_inc(ips_inswcsum);
		if (in_cksum(m, hlen) != 0) {
			ipstat_inc(ips_badsum);
			goto bad;
		}
	}

	/* Retrieve the packet length. */
	len = ntohs(ip->ip_len);

	/*
	 * Convert fields to host representation.
	 */
	if (len < hlen) {
		ipstat_inc(ips_badlen);
		goto bad;
	}

	/*
	 * Check that the amount of data in the buffers
	 * is at least as much as the IP header would have us expect.
	 * Trim mbufs if longer than we expect.
	 * Drop packet if shorter than we expect.
	 */
	if (m->m_pkthdr.len < len) {
		ipstat_inc(ips_tooshort);
		goto bad;
	}
	if (m->m_pkthdr.len > len) {
		if (m->m_len == m->m_pkthdr.len) {
			m->m_len = len;
			m->m_pkthdr.len = len;
		} else
			m_adj(m, len - m->m_pkthdr.len);
	}

#if NCARP > 0
	if (ifp->if_type == IFT_CARP && ip->ip_p != IPPROTO_ICMP &&
	    carp_lsdrop(m, AF_INET, &ip->ip_src.s_addr, &ip->ip_dst.s_addr))
		goto bad;
#endif

#if NPF > 0
	/*
	 * Packet filter
	 */
	pfrdr = ip->ip_dst.s_addr;
	if (pf_test(AF_INET, PF_IN, ifp, &m) != PF_PASS)
		goto bad;
	if (m == NULL)
		goto out;

	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;
	pfrdr = (pfrdr != ip->ip_dst.s_addr);
#endif

	/*
	 * Process options and, if not destined for us,
	 * ship it on.  ip_dooptions returns 1 when an
	 * error was detected (causing an icmp message
	 * to be sent and the original packet to be freed).
	 */
	if (hlen > sizeof (struct ip) && ip_dooptions(m, ifp)) {
	        goto out;
	}

	if (ip->ip_dst.s_addr == INADDR_BROADCAST ||
	    ip->ip_dst.s_addr == INADDR_ANY) {
		ip_ours(m);
		goto out;
	}

	if (in_ouraddr(m, ifp, &rt)) {
		ip_ours(m);
		goto out;
	}

	if (IN_MULTICAST(ip->ip_dst.s_addr)) {
		/*
		 * Make sure M_MCAST is set.  It should theoretically
		 * already be there, but let's play safe because upper
		 * layers check for this flag.
		 */
		m->m_flags |= M_MCAST;

#ifdef MROUTING
		if (ipmforwarding && ip_mrouter[ifp->if_rdomain]) {
			if (m->m_flags & M_EXT) {
				if ((m = m_pullup(m, hlen)) == NULL) {
					ipstat_inc(ips_toosmall);
					goto out;
				}
				ip = mtod(m, struct ip *);
			}
			/*
			 * If we are acting as a multicast router, all
			 * incoming multicast packets are passed to the
			 * kernel-level multicast forwarding function.
			 * The packet is returned (relatively) intact; if
			 * ip_mforward() returns a non-zero value, the packet
			 * must be discarded, else it may be accepted below.
			 *
			 * (The IP ident field is put in the same byte order
			 * as expected when ip_mforward() is called from
			 * ip_output().)
			 */
			KERNEL_LOCK();
			rv = ip_mforward(m, ifp);
			KERNEL_UNLOCK();
			if (rv != 0) {
				ipstat_inc(ips_cantforward);
				goto bad;
			}

			/*
			 * The process-level routing daemon needs to receive
			 * all multicast IGMP packets, whether or not this
			 * host belongs to their destination groups.
			 */
			if (ip->ip_p == IPPROTO_IGMP) {
				ip_ours(m);
				goto out;
			}
			ipstat_inc(ips_forward);
		}
#endif
		/*
		 * See if we belong to the destination multicast group on the
		 * arrival interface.
		 */
		if (!in_hasmulti(&ip->ip_dst, ifp)) {
			ipstat_inc(ips_notmember);
			if (!IN_LOCAL_GROUP(ip->ip_dst.s_addr))
				ipstat_inc(ips_cantforward);
			goto bad;
		}
		ip_ours(m);
		goto out;
	}

#if NCARP > 0
	if (ifp->if_type == IFT_CARP && ip->ip_p == IPPROTO_ICMP &&
	    carp_lsdrop(m, AF_INET, &ip->ip_src.s_addr, &ip->ip_dst.s_addr))
		goto bad;
#endif
	/*
	 * Not for us; forward if possible and desirable.
	 */
	if (ipforwarding == 0) {
		ipstat_inc(ips_cantforward);
		goto bad;
	}
#ifdef IPSEC
	if (ipsec_in_use) {
		KERNEL_LOCK();
		rv = ip_input_ipsec_fwd_check(m, hlen);
		KERNEL_UNLOCK();
		if (rv != 0) {
			ipstat_inc(ips_cantforward);
			goto bad;
		}
		/*
		 * Fall through, forward packet. Outbound IPsec policy
		 * checking will occur in ip_output().
		 */
	}
#endif /* IPSEC */

	ip_forward(m, ifp, rt, pfrdr);
	if_put(ifp);
	return;
bad:
	m_freem(m);
out:
	rtfree(rt);
	if_put(ifp);
}

/*
 * IPv4 local-delivery routine.
 *
 * If fragmented try to reassemble.  Pass to next level.
 */
void
ip_ours(struct mbuf *m)
{
	struct ip *ip = mtod(m, struct ip *);
	struct ipq *fp;
	struct ipqent *ipqe;
	int mff, hlen;

	hlen = ip->ip_hl << 2;

	/* pf might have modified stuff, might have to chksum */
	in_proto_cksum_out(m, NULL);

	/*
	 * If offset or IP_MF are set, must reassemble.
	 * Otherwise, nothing need be done.
	 * (We could look in the reassembly queue to see
	 * if the packet was previously fragmented,
	 * but it's not worth the time; just let them time out.)
	 */
	if (ip->ip_off &~ htons(IP_DF | IP_RF)) {
		if (m->m_flags & M_EXT) {		/* XXX */
			if ((m = m_pullup(m, hlen)) == NULL) {
				ipstat_inc(ips_toosmall);
				return;
			}
			ip = mtod(m, struct ip *);
		}

		/*
		 * Look for queue of fragments
		 * of this datagram.
		 */
		LIST_FOREACH(fp, &ipq, ipq_q)
			if (ip->ip_id == fp->ipq_id &&
			    ip->ip_src.s_addr == fp->ipq_src.s_addr &&
			    ip->ip_dst.s_addr == fp->ipq_dst.s_addr &&
			    ip->ip_p == fp->ipq_p)
				goto found;
		fp = 0;
found:

		/*
		 * Adjust ip_len to not reflect header,
		 * set ipqe_mff if more fragments are expected,
		 * convert offset of this to bytes.
		 */
		ip->ip_len = htons(ntohs(ip->ip_len) - hlen);
		mff = (ip->ip_off & htons(IP_MF)) != 0;
		if (mff) {
			/*
			 * Make sure that fragments have a data length
			 * that's a non-zero multiple of 8 bytes.
			 */
			if (ntohs(ip->ip_len) == 0 ||
			    (ntohs(ip->ip_len) & 0x7) != 0) {
				ipstat_inc(ips_badfrags);
				goto bad;
			}
		}
		ip->ip_off = htons(ntohs(ip->ip_off) << 3);

		/*
		 * If datagram marked as having more fragments
		 * or if this is not the first fragment,
		 * attempt reassembly; if it succeeds, proceed.
		 */
		if (mff || ip->ip_off) {
			ipstat_inc(ips_fragments);
			if (ip_frags + 1 > ip_maxqueue) {
				ip_flush();
				ipstat_inc(ips_rcvmemdrop);
				goto bad;
			}

			ipqe = pool_get(&ipqent_pool, PR_NOWAIT);
			if (ipqe == NULL) {
				ipstat_inc(ips_rcvmemdrop);
				goto bad;
			}
			ip_frags++;
			ipqe->ipqe_mff = mff;
			ipqe->ipqe_m = m;
			ipqe->ipqe_ip = ip;
			m = ip_reass(ipqe, fp);
			if (m == NULL) {
				return;
			}
			ipstat_inc(ips_reassembled);
			ip = mtod(m, struct ip *);
			hlen = ip->ip_hl << 2;
			ip->ip_len = htons(ntohs(ip->ip_len) + hlen);
		} else
			if (fp)
				ip_freef(fp);
	}

#ifdef IPSEC
	if (ipsec_in_use) {
		if (ip_input_ipsec_ours_check(m, hlen) != 0) {
			ipstat_inc(ips_cantforward);
			goto bad;
		}
	}
	/* Otherwise, just fall through and deliver the packet */
#endif /* IPSEC */

	/*
	 * Switch out to protocol's input routine.
	 */
	ipstat_inc(ips_delivered);
	(*inetsw[ip_protox[ip->ip_p]].pr_input)(&m, &hlen, ip->ip_p);
	return;
bad:
	m_freem(m);
}

int
in_ouraddr(struct mbuf *m, struct ifnet *ifp, struct rtentry **prt)
{
	struct rtentry		*rt;
	struct ip		*ip;
	struct sockaddr_in	 sin;
	int			 match = 0;

#if NPF > 0
	switch (pf_ouraddr(m)) {
	case 0:
		return (0);
	case 1:
		return (1);
	default:
		/* pf does not know it */
		break;
	}
#endif

	ip = mtod(m, struct ip *);

	memset(&sin, 0, sizeof(sin));
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;
	sin.sin_addr = ip->ip_dst;
	rt = rtalloc_mpath(sintosa(&sin), &ip->ip_src.s_addr,
	    m->m_pkthdr.ph_rtableid);
	if (rtisvalid(rt)) {
		if (ISSET(rt->rt_flags, RTF_LOCAL))
			match = 1;

		/*
		 * If directedbcast is enabled we only consider it local
		 * if it is received on the interface with that address.
		 */
		if (ISSET(rt->rt_flags, RTF_BROADCAST) &&
		    (!ip_directedbcast || rt->rt_ifidx == ifp->if_index)) {
			match = 1;

			/* Make sure M_BCAST is set */
			m->m_flags |= M_BCAST;
		}
	}
	*prt = rt;

	if (!match) {
		struct ifaddr *ifa;

		/*
		 * No local address or broadcast address found, so check for
		 * ancient classful broadcast addresses.
		 * It must have been broadcast on the link layer, and for an
		 * address on the interface it was received on.
		 */
		if (!ISSET(m->m_flags, M_BCAST) ||
		    !IN_CLASSFULBROADCAST(ip->ip_dst.s_addr, ip->ip_dst.s_addr))
			return (0);

		if (ifp->if_rdomain != rtable_l2(m->m_pkthdr.ph_rtableid))
			return (0);
		/*
		 * The check in the loop assumes you only rx a packet on an UP
		 * interface, and that M_BCAST will only be set on a BROADCAST
		 * interface.
		 */
		KERNEL_LOCK();
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET)
				continue;

			if (IN_CLASSFULBROADCAST(ip->ip_dst.s_addr,
			    ifatoia(ifa)->ia_addr.sin_addr.s_addr)) {
			    	match = 1;
			    	break;
			}
		}
		KERNEL_UNLOCK();
	}

	return (match);
}

#ifdef IPSEC
int
ip_input_ipsec_fwd_check(struct mbuf *m, int hlen)
{
	struct tdb *tdb;
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
	int error = 0;

	/*
	 * IPsec policy check for forwarded packets. Look at
	 * inner-most IPsec SA used.
	 */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
	if (mtag != NULL) {
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->rdomain, tdbi->spi, &tdbi->dst, tdbi->proto);
	} else
		tdb = NULL;
	ipsp_spd_lookup(m, AF_INET, hlen, &error, IPSP_DIRECTION_IN, tdb, NULL,
	    0);

	return error;
}

int
ip_input_ipsec_ours_check(struct mbuf *m, int hlen)
{
	struct ip *ip = mtod(m, struct ip *);
	struct tdb *tdb;
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
	int error = 0;

	/*
	 * If it's a protected packet for us, skip the policy check.
	 * That's because we really only care about the properties of
	 * the protected packet, and not the intermediate versions.
	 * While this is not the most paranoid setting, it allows
	 * some flexibility in handling nested tunnels (in setting up
	 * the policies).
	 */
	if ((ip->ip_p == IPPROTO_ESP) || (ip->ip_p == IPPROTO_AH) ||
	    (ip->ip_p == IPPROTO_IPCOMP))
		return 0;

	/*
	 * If the protected packet was tunneled, then we need to
	 * verify the protected packet's information, not the
	 * external headers. Thus, skip the policy lookup for the
	 * external packet, and keep the IPsec information linked on
	 * the packet header (the encapsulation routines know how
	 * to deal with that).
	 */
	if ((ip->ip_p == IPPROTO_IPIP) || (ip->ip_p == IPPROTO_IPV6))
		return 0;

	/*
	 * If the protected packet is TCP or UDP, we'll do the
	 * policy check in the respective input routine, so we can
	 * check for bypass sockets.
	 */
	if ((ip->ip_p == IPPROTO_TCP) || (ip->ip_p == IPPROTO_UDP))
		return 0;

	/*
	 * IPsec policy check for local-delivery packets. Look at the
	 * inner-most SA that protected the packet. This is in fact
	 * a bit too restrictive (it could end up causing packets to
	 * be dropped that semantically follow the policy, e.g., in
	 * certain SA-bundle configurations); but the alternative is
	 * very complicated (and requires keeping track of what
	 * kinds of tunneling headers have been seen in-between the
	 * IPsec headers), and I don't think we lose much functionality
	 * that's needed in the real world (who uses bundles anyway ?).
	 */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
	if (mtag) {
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->rdomain, tdbi->spi, &tdbi->dst,
		    tdbi->proto);
	} else
		tdb = NULL;
	ipsp_spd_lookup(m, AF_INET, hlen, &error, IPSP_DIRECTION_IN,
	    tdb, NULL, 0);

	return error;
}
#endif /* IPSEC */

/*
 * Take incoming datagram fragment and try to
 * reassemble it into whole datagram.  If a chain for
 * reassembly of this datagram already exists, then it
 * is given as fp; otherwise have to make a chain.
 */
struct mbuf *
ip_reass(struct ipqent *ipqe, struct ipq *fp)
{
	struct mbuf *m = ipqe->ipqe_m;
	struct ipqent *nq, *p, *q;
	struct ip *ip;
	struct mbuf *t;
	int hlen = ipqe->ipqe_ip->ip_hl << 2;
	int i, next;
	u_int8_t ecn, ecn0;

	/*
	 * Presence of header sizes in mbufs
	 * would confuse code below.
	 */
	m->m_data += hlen;
	m->m_len -= hlen;

	/*
	 * If first fragment to arrive, create a reassembly queue.
	 */
	if (fp == NULL) {
		fp = pool_get(&ipq_pool, PR_NOWAIT);
		if (fp == NULL)
			goto dropfrag;
		LIST_INSERT_HEAD(&ipq, fp, ipq_q);
		fp->ipq_ttl = IPFRAGTTL;
		fp->ipq_p = ipqe->ipqe_ip->ip_p;
		fp->ipq_id = ipqe->ipqe_ip->ip_id;
		LIST_INIT(&fp->ipq_fragq);
		fp->ipq_src = ipqe->ipqe_ip->ip_src;
		fp->ipq_dst = ipqe->ipqe_ip->ip_dst;
		p = NULL;
		goto insert;
	}

	/*
	 * Handle ECN by comparing this segment with the first one;
	 * if CE is set, do not lose CE.
	 * drop if CE and not-ECT are mixed for the same packet.
	 */
	ecn = ipqe->ipqe_ip->ip_tos & IPTOS_ECN_MASK;
	ecn0 = LIST_FIRST(&fp->ipq_fragq)->ipqe_ip->ip_tos & IPTOS_ECN_MASK;
	if (ecn == IPTOS_ECN_CE) {
		if (ecn0 == IPTOS_ECN_NOTECT)
			goto dropfrag;
		if (ecn0 != IPTOS_ECN_CE)
			LIST_FIRST(&fp->ipq_fragq)->ipqe_ip->ip_tos |= IPTOS_ECN_CE;
	}
	if (ecn == IPTOS_ECN_NOTECT && ecn0 != IPTOS_ECN_NOTECT)
		goto dropfrag;

	/*
	 * Find a segment which begins after this one does.
	 */
	for (p = NULL, q = LIST_FIRST(&fp->ipq_fragq); q != NULL;
	    p = q, q = LIST_NEXT(q, ipqe_q))
		if (ntohs(q->ipqe_ip->ip_off) > ntohs(ipqe->ipqe_ip->ip_off))
			break;

	/*
	 * If there is a preceding segment, it may provide some of
	 * our data already.  If so, drop the data from the incoming
	 * segment.  If it provides all of our data, drop us.
	 */
	if (p != NULL) {
		i = ntohs(p->ipqe_ip->ip_off) + ntohs(p->ipqe_ip->ip_len) -
		    ntohs(ipqe->ipqe_ip->ip_off);
		if (i > 0) {
			if (i >= ntohs(ipqe->ipqe_ip->ip_len))
				goto dropfrag;
			m_adj(ipqe->ipqe_m, i);
			ipqe->ipqe_ip->ip_off =
			    htons(ntohs(ipqe->ipqe_ip->ip_off) + i);
			ipqe->ipqe_ip->ip_len =
			    htons(ntohs(ipqe->ipqe_ip->ip_len) - i);
		}
	}

	/*
	 * While we overlap succeeding segments trim them or,
	 * if they are completely covered, dequeue them.
	 */
	for (; q != NULL &&
	    ntohs(ipqe->ipqe_ip->ip_off) + ntohs(ipqe->ipqe_ip->ip_len) >
	    ntohs(q->ipqe_ip->ip_off); q = nq) {
		i = (ntohs(ipqe->ipqe_ip->ip_off) +
		    ntohs(ipqe->ipqe_ip->ip_len)) - ntohs(q->ipqe_ip->ip_off);
		if (i < ntohs(q->ipqe_ip->ip_len)) {
			q->ipqe_ip->ip_len =
			    htons(ntohs(q->ipqe_ip->ip_len) - i);
			q->ipqe_ip->ip_off =
			    htons(ntohs(q->ipqe_ip->ip_off) + i);
			m_adj(q->ipqe_m, i);
			break;
		}
		nq = LIST_NEXT(q, ipqe_q);
		m_freem(q->ipqe_m);
		LIST_REMOVE(q, ipqe_q);
		pool_put(&ipqent_pool, q);
		ip_frags--;
	}

insert:
	/*
	 * Stick new segment in its place;
	 * check for complete reassembly.
	 */
	if (p == NULL) {
		LIST_INSERT_HEAD(&fp->ipq_fragq, ipqe, ipqe_q);
	} else {
		LIST_INSERT_AFTER(p, ipqe, ipqe_q);
	}
	next = 0;
	for (p = NULL, q = LIST_FIRST(&fp->ipq_fragq); q != NULL;
	    p = q, q = LIST_NEXT(q, ipqe_q)) {
		if (ntohs(q->ipqe_ip->ip_off) != next)
			return (0);
		next += ntohs(q->ipqe_ip->ip_len);
	}
	if (p->ipqe_mff)
		return (0);

	/*
	 * Reassembly is complete.  Check for a bogus message size and
	 * concatenate fragments.
	 */
	q = LIST_FIRST(&fp->ipq_fragq);
	ip = q->ipqe_ip;
	if ((next + (ip->ip_hl << 2)) > IP_MAXPACKET) {
		ipstat_inc(ips_toolong);
		ip_freef(fp);
		return (0);
	}
	m = q->ipqe_m;
	t = m->m_next;
	m->m_next = 0;
	m_cat(m, t);
	nq = LIST_NEXT(q, ipqe_q);
	pool_put(&ipqent_pool, q);
	ip_frags--;
	for (q = nq; q != NULL; q = nq) {
		t = q->ipqe_m;
		nq = LIST_NEXT(q, ipqe_q);
		pool_put(&ipqent_pool, q);
		ip_frags--;
		m_cat(m, t);
	}

	/*
	 * Create header for new ip packet by
	 * modifying header of first packet;
	 * dequeue and discard fragment reassembly header.
	 * Make header visible.
	 */
	ip->ip_len = htons(next);
	ip->ip_src = fp->ipq_src;
	ip->ip_dst = fp->ipq_dst;
	LIST_REMOVE(fp, ipq_q);
	pool_put(&ipq_pool, fp);
	m->m_len += (ip->ip_hl << 2);
	m->m_data -= (ip->ip_hl << 2);
	/* some debugging cruft by sklower, below, will go away soon */
	if (m->m_flags & M_PKTHDR) { /* XXX this should be done elsewhere */
		int plen = 0;
		for (t = m; t; t = t->m_next)
			plen += t->m_len;
		m->m_pkthdr.len = plen;
	}
	return (m);

dropfrag:
	ipstat_inc(ips_fragdropped);
	m_freem(m);
	pool_put(&ipqent_pool, ipqe);
	ip_frags--;
	return (0);
}

/*
 * Free a fragment reassembly header and all
 * associated datagrams.
 */
void
ip_freef(struct ipq *fp)
{
	struct ipqent *q, *p;

	for (q = LIST_FIRST(&fp->ipq_fragq); q != NULL; q = p) {
		p = LIST_NEXT(q, ipqe_q);
		m_freem(q->ipqe_m);
		LIST_REMOVE(q, ipqe_q);
		pool_put(&ipqent_pool, q);
		ip_frags--;
	}
	LIST_REMOVE(fp, ipq_q);
	pool_put(&ipq_pool, fp);
}

/*
 * IP timer processing;
 * if a timer expires on a reassembly queue, discard it.
 * clear the forwarding cache, there might be a better route.
 */
void
ip_slowtimo(void)
{
	struct ipq *fp, *nfp;

	splsoftassert(IPL_SOFTNET);

	for (fp = LIST_FIRST(&ipq); fp != NULL; fp = nfp) {
		nfp = LIST_NEXT(fp, ipq_q);
		if (--fp->ipq_ttl == 0) {
			ipstat_inc(ips_fragtimeout);
			ip_freef(fp);
		}
	}
}

/*
 * Drain off all datagram fragments.
 */
void
ip_drain(void)
{
	while (!LIST_EMPTY(&ipq)) {
		ipstat_inc(ips_fragdropped);
		ip_freef(LIST_FIRST(&ipq));
	}
}

/*
 * Flush a bunch of datagram fragments, till we are down to 75%.
 */
void
ip_flush(void)
{
	int max = 50;

	/* ipq already locked */
	while (!LIST_EMPTY(&ipq) && ip_frags > ip_maxqueue * 3 / 4 && --max) {
		ipstat_inc(ips_fragdropped);
		ip_freef(LIST_FIRST(&ipq));
	}
}

/*
 * Do option processing on a datagram,
 * possibly discarding it if bad options are encountered,
 * or forwarding it if source-routed.
 * Returns 1 if packet has been forwarded/freed,
 * 0 if the packet should be processed further.
 */
int
ip_dooptions(struct mbuf *m, struct ifnet *ifp)
{
	struct ip *ip = mtod(m, struct ip *);
	unsigned int rtableid = m->m_pkthdr.ph_rtableid;
	struct rtentry *rt;
	struct sockaddr_in ipaddr;
	u_char *cp;
	struct ip_timestamp ipt;
	struct in_ifaddr *ia;
	int opt, optlen, cnt, off, code, type = ICMP_PARAMPROB, forward = 0;
	struct in_addr sin, dst;
	u_int32_t ntime;

	dst = ip->ip_dst;
	cp = (u_char *)(ip + 1);
	cnt = (ip->ip_hl << 2) - sizeof (struct ip);

	KERNEL_LOCK();
	for (; cnt > 0; cnt -= optlen, cp += optlen) {
		opt = cp[IPOPT_OPTVAL];
		if (opt == IPOPT_EOL)
			break;
		if (opt == IPOPT_NOP)
			optlen = 1;
		else {
			if (cnt < IPOPT_OLEN + sizeof(*cp)) {
				code = &cp[IPOPT_OLEN] - (u_char *)ip;
				goto bad;
			}
			optlen = cp[IPOPT_OLEN];
			if (optlen < IPOPT_OLEN + sizeof(*cp) || optlen > cnt) {
				code = &cp[IPOPT_OLEN] - (u_char *)ip;
				goto bad;
			}
		}

		switch (opt) {

		default:
			break;

		/*
		 * Source routing with record.
		 * Find interface with current destination address.
		 * If none on this machine then drop if strictly routed,
		 * or do nothing if loosely routed.
		 * Record interface address and bring up next address
		 * component.  If strictly routed make sure next
		 * address is on directly accessible net.
		 */
		case IPOPT_LSRR:
		case IPOPT_SSRR:
			if (!ip_dosourceroute) {
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				goto bad;
			}
			if ((off = cp[IPOPT_OFFSET]) < IPOPT_MINOFF) {
				code = &cp[IPOPT_OFFSET] - (u_char *)ip;
				goto bad;
			}
			memset(&ipaddr, 0, sizeof(ipaddr));
			ipaddr.sin_family = AF_INET;
			ipaddr.sin_len = sizeof(ipaddr);
			ipaddr.sin_addr = ip->ip_dst;
			ia = ifatoia(ifa_ifwithaddr(sintosa(&ipaddr),
			    m->m_pkthdr.ph_rtableid));
			if (ia == NULL) {
				if (opt == IPOPT_SSRR) {
					type = ICMP_UNREACH;
					code = ICMP_UNREACH_SRCFAIL;
					goto bad;
				}
				/*
				 * Loose routing, and not at next destination
				 * yet; nothing to do except forward.
				 */
				break;
			}
			off--;			/* 0 origin */
			if ((off + sizeof(struct in_addr)) > optlen) {
				/*
				 * End of source route.  Should be for us.
				 */
				save_rte(m, cp, ip->ip_src);
				break;
			}

			/*
			 * locate outgoing interface
			 */
			memset(&ipaddr, 0, sizeof(ipaddr));
			ipaddr.sin_family = AF_INET;
			ipaddr.sin_len = sizeof(ipaddr);
			memcpy(&ipaddr.sin_addr, cp + off,
			    sizeof(ipaddr.sin_addr));
			/* keep packet in the virtual instance */
			rt = rtalloc(sintosa(&ipaddr), RT_RESOLVE, rtableid);
			if (!rtisvalid(rt) || ((opt == IPOPT_SSRR) &&
			    ISSET(rt->rt_flags, RTF_GATEWAY))) {
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				rtfree(rt);
				goto bad;
			}
			ia = ifatoia(rt->rt_ifa);
			memcpy(cp + off, &ia->ia_addr.sin_addr,
			    sizeof(struct in_addr));
			rtfree(rt);
			cp[IPOPT_OFFSET] += sizeof(struct in_addr);
			ip->ip_dst = ipaddr.sin_addr;
			/*
			 * Let ip_intr's mcast routing check handle mcast pkts
			 */
			forward = !IN_MULTICAST(ip->ip_dst.s_addr);
			break;

		case IPOPT_RR:
			if (optlen < IPOPT_OFFSET + sizeof(*cp)) {
				code = &cp[IPOPT_OLEN] - (u_char *)ip;
				goto bad;
			}
			if ((off = cp[IPOPT_OFFSET]) < IPOPT_MINOFF) {
				code = &cp[IPOPT_OFFSET] - (u_char *)ip;
				goto bad;
			}

			/*
			 * If no space remains, ignore.
			 */
			off--;			/* 0 origin */
			if ((off + sizeof(struct in_addr)) > optlen)
				break;
			memset(&ipaddr, 0, sizeof(ipaddr));
			ipaddr.sin_family = AF_INET;
			ipaddr.sin_len = sizeof(ipaddr);
			ipaddr.sin_addr = ip->ip_dst;
			/*
			 * locate outgoing interface; if we're the destination,
			 * use the incoming interface (should be same).
			 * Again keep the packet inside the virtual instance.
			 */
			rt = rtalloc(sintosa(&ipaddr), RT_RESOLVE, rtableid);
			if (!rtisvalid(rt)) {
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_HOST;
				rtfree(rt);
				goto bad;
			}
			ia = ifatoia(rt->rt_ifa);
			memcpy(cp + off, &ia->ia_addr.sin_addr,
			    sizeof(struct in_addr));
			rtfree(rt);
			cp[IPOPT_OFFSET] += sizeof(struct in_addr);
			break;

		case IPOPT_TS:
			code = cp - (u_char *)ip;
			if (optlen < sizeof(struct ip_timestamp))
				goto bad;
			memcpy(&ipt, cp, sizeof(struct ip_timestamp));
			if (ipt.ipt_ptr < 5 || ipt.ipt_len < 5)
				goto bad;
			if (ipt.ipt_ptr - 1 + sizeof(u_int32_t) > ipt.ipt_len) {
				if (++ipt.ipt_oflw == 0)
					goto bad;
				break;
			}
			memcpy(&sin, cp + ipt.ipt_ptr - 1, sizeof sin);
			switch (ipt.ipt_flg) {

			case IPOPT_TS_TSONLY:
				break;

			case IPOPT_TS_TSANDADDR:
				if (ipt.ipt_ptr - 1 + sizeof(u_int32_t) +
				    sizeof(struct in_addr) > ipt.ipt_len)
					goto bad;
				memset(&ipaddr, 0, sizeof(ipaddr));
				ipaddr.sin_family = AF_INET;
				ipaddr.sin_len = sizeof(ipaddr);
				ipaddr.sin_addr = dst;
				ia = ifatoia(ifaof_ifpforaddr(sintosa(&ipaddr),
				    ifp));
				if (ia == NULL)
					continue;
				memcpy(&sin, &ia->ia_addr.sin_addr,
				    sizeof(struct in_addr));
				ipt.ipt_ptr += sizeof(struct in_addr);
				break;

			case IPOPT_TS_PRESPEC:
				if (ipt.ipt_ptr - 1 + sizeof(u_int32_t) +
				    sizeof(struct in_addr) > ipt.ipt_len)
					goto bad;
				memset(&ipaddr, 0, sizeof(ipaddr));
				ipaddr.sin_family = AF_INET;
				ipaddr.sin_len = sizeof(ipaddr);
				ipaddr.sin_addr = sin;
				if (ifa_ifwithaddr(sintosa(&ipaddr),
				    m->m_pkthdr.ph_rtableid) == NULL)
					continue;
				ipt.ipt_ptr += sizeof(struct in_addr);
				break;

			default:
				/* XXX can't take &ipt->ipt_flg */
				code = (u_char *)&ipt.ipt_ptr -
				    (u_char *)ip + 1;
				goto bad;
			}
			ntime = iptime();
			memcpy(cp + ipt.ipt_ptr - 1, &ntime, sizeof(u_int32_t));
			ipt.ipt_ptr += sizeof(u_int32_t);
		}
	}
	KERNEL_UNLOCK();
	if (forward && ipforwarding) {
		ip_forward(m, ifp, NULL, 1);
		return (1);
	}
	return (0);
bad:
	KERNEL_UNLOCK();
	icmp_error(m, type, code, 0, 0);
	ipstat_inc(ips_badoptions);
	return (1);
}

/*
 * Save incoming source route for use in replies,
 * to be picked up later by ip_srcroute if the receiver is interested.
 */
void
save_rte(struct mbuf *m, u_char *option, struct in_addr dst)
{
	struct ip_srcrt *isr;
	struct m_tag *mtag;
	unsigned olen;

	olen = option[IPOPT_OLEN];
	if (olen > sizeof(isr->isr_hdr) + sizeof(isr->isr_routes))
		return;

	mtag = m_tag_get(PACKET_TAG_SRCROUTE, sizeof(*isr), M_NOWAIT);
	if (mtag == NULL)
		return;
	isr = (struct ip_srcrt *)(mtag + 1);

	memcpy(isr->isr_hdr, option, olen);
	isr->isr_nhops = (olen - IPOPT_OFFSET - 1) / sizeof(struct in_addr);
	isr->isr_dst = dst;
	m_tag_prepend(m, mtag);
}

/*
 * Retrieve incoming source route for use in replies,
 * in the same form used by setsockopt.
 * The first hop is placed before the options, will be removed later.
 */
struct mbuf *
ip_srcroute(struct mbuf *m0)
{
	struct in_addr *p, *q;
	struct mbuf *m;
	struct ip_srcrt *isr;
	struct m_tag *mtag;

	if (!ip_dosourceroute)
		return (NULL);

	mtag = m_tag_find(m0, PACKET_TAG_SRCROUTE, NULL);
	if (mtag == NULL)
		return (NULL);
	isr = (struct ip_srcrt *)(mtag + 1);

	if (isr->isr_nhops == 0)
		return (NULL);
	m = m_get(M_DONTWAIT, MT_SOOPTS);
	if (m == NULL)
		return (NULL);

#define OPTSIZ	(sizeof(isr->isr_nop) + sizeof(isr->isr_hdr))

	/* length is (nhops+1)*sizeof(addr) + sizeof(nop + header) */
	m->m_len = (isr->isr_nhops + 1) * sizeof(struct in_addr) + OPTSIZ;

	/*
	 * First save first hop for return route
	 */
	p = &(isr->isr_routes[isr->isr_nhops - 1]);
	*(mtod(m, struct in_addr *)) = *p--;

	/*
	 * Copy option fields and padding (nop) to mbuf.
	 */
	isr->isr_nop = IPOPT_NOP;
	isr->isr_hdr[IPOPT_OFFSET] = IPOPT_MINOFF;
	memcpy(mtod(m, caddr_t) + sizeof(struct in_addr), &isr->isr_nop,
	    OPTSIZ);
	q = (struct in_addr *)(mtod(m, caddr_t) +
	    sizeof(struct in_addr) + OPTSIZ);
#undef OPTSIZ
	/*
	 * Record return path as an IP source route,
	 * reversing the path (pointers are now aligned).
	 */
	while (p >= isr->isr_routes) {
		*q++ = *p--;
	}
	/*
	 * Last hop goes to final destination.
	 */
	*q = isr->isr_dst;
	m_tag_delete(m0, (struct m_tag *)isr);
	return (m);
}

/*
 * Strip out IP options, at higher level protocol in the kernel.
 */
void
ip_stripoptions(struct mbuf *m)
{
	int i;
	struct ip *ip = mtod(m, struct ip *);
	caddr_t opts;
	int olen;

	olen = (ip->ip_hl<<2) - sizeof (struct ip);
	opts = (caddr_t)(ip + 1);
	i = m->m_len - (sizeof (struct ip) + olen);
	memmove(opts, opts  + olen, i);
	m->m_len -= olen;
	if (m->m_flags & M_PKTHDR)
		m->m_pkthdr.len -= olen;
	ip->ip_hl = sizeof(struct ip) >> 2;
	ip->ip_len = htons(ntohs(ip->ip_len) - olen);
}

int inetctlerrmap[PRC_NCMDS] = {
	0,		0,		0,		0,
	0,		EMSGSIZE,	EHOSTDOWN,	EHOSTUNREACH,
	EHOSTUNREACH,	EHOSTUNREACH,	ECONNREFUSED,	ECONNREFUSED,
	EMSGSIZE,	EHOSTUNREACH,	0,		0,
	0,		0,		0,		0,
	ENOPROTOOPT
};

/*
 * Forward a packet.  If some error occurs return the sender
 * an icmp packet.  Note we can't always generate a meaningful
 * icmp message because icmp doesn't have a large enough repertoire
 * of codes and types.
 *
 * If not forwarding, just drop the packet.  This could be confusing
 * if ipforwarding was zero but some routing protocol was advancing
 * us as a gateway to somewhere.  However, we must let the routing
 * protocol deal with that.
 *
 * The srcrt parameter indicates whether the packet is being forwarded
 * via a source route.
 */
void
ip_forward(struct mbuf *m, struct ifnet *ifp, struct rtentry *rt, int srcrt)
{
	struct mbuf mfake, *mcopy = NULL;
	struct ip *ip = mtod(m, struct ip *);
	struct sockaddr_in *sin;
	struct route ro;
	int error, type = 0, code = 0, destmtu = 0, fake = 0, len;
	u_int32_t dest;

	dest = 0;
	if (m->m_flags & (M_BCAST|M_MCAST) || in_canforward(ip->ip_dst) == 0) {
		ipstat_inc(ips_cantforward);
		m_freem(m);
		goto freecopy;
	}
	if (ip->ip_ttl <= IPTTLDEC) {
		icmp_error(m, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS, dest, 0);
		goto freecopy;
	}

	sin = satosin(&ro.ro_dst);
	memset(sin, 0, sizeof(*sin));
	sin->sin_family = AF_INET;
	sin->sin_len = sizeof(*sin);
	sin->sin_addr = ip->ip_dst;

	if (!rtisvalid(rt)) {
		rtfree(rt);
		rt = rtalloc_mpath(sintosa(sin), &ip->ip_src.s_addr,
		    m->m_pkthdr.ph_rtableid);
		if (rt == NULL) {
			icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_HOST, dest, 0);
			return;
		}
	}

	/*
	 * Save at most 68 bytes of the packet in case
	 * we need to generate an ICMP message to the src.
	 * The data is saved in the mbuf on the stack that
	 * acts as a temporary storage not intended to be
	 * passed down the IP stack or to the mfree.
	 */
	memset(&mfake.m_hdr, 0, sizeof(mfake.m_hdr));
	mfake.m_type = m->m_type;
	if (m_dup_pkthdr(&mfake, m, M_DONTWAIT) == 0) {
		mfake.m_data = mfake.m_pktdat;
		len = min(ntohs(ip->ip_len), 68);
		m_copydata(m, 0, len, mfake.m_pktdat);
		mfake.m_pkthdr.len = mfake.m_len = len;
#if NPF > 0
		pf_pkt_unlink_state_key(&mfake);
#endif	/* NPF > 0 */
		fake = 1;
	}

	ip->ip_ttl -= IPTTLDEC;

	/*
	 * If forwarding packet using same interface that it came in on,
	 * perhaps should send a redirect to sender to shortcut a hop.
	 * Only send redirect if source is sending directly to us,
	 * and if packet was not source routed (or has any options).
	 * Also, don't send redirect if forwarding using a default route
	 * or a route modified by a redirect.
	 * Don't send redirect if we advertise destination's arp address
	 * as ours (proxy arp).
	 */
	if ((rt->rt_ifidx == ifp->if_index) &&
	    (rt->rt_flags & (RTF_DYNAMIC|RTF_MODIFIED)) == 0 &&
	    satosin(rt_key(rt))->sin_addr.s_addr != 0 &&
	    ipsendredirects && !srcrt &&
	    !arpproxy(satosin(rt_key(rt))->sin_addr, m->m_pkthdr.ph_rtableid)) {
		if ((ip->ip_src.s_addr & ifatoia(rt->rt_ifa)->ia_netmask) ==
		    ifatoia(rt->rt_ifa)->ia_net) {
		    if (rt->rt_flags & RTF_GATEWAY)
			dest = satosin(rt->rt_gateway)->sin_addr.s_addr;
		    else
			dest = ip->ip_dst.s_addr;
		    /* Router requirements says to only send host redirects */
		    type = ICMP_REDIRECT;
		    code = ICMP_REDIRECT_HOST;
		}
	}

	ro.ro_rt = rt;
	ro.ro_tableid = m->m_pkthdr.ph_rtableid;
	error = ip_output(m, NULL, &ro,
	    (IP_FORWARDING | (ip_directedbcast ? IP_ALLOWBROADCAST : 0)),
	    NULL, NULL, 0);
	rt = ro.ro_rt;
	if (error)
		ipstat_inc(ips_cantforward);
	else {
		ipstat_inc(ips_forward);
		if (type)
			ipstat_inc(ips_redirectsent);
		else
			goto freecopy;
	}
	if (!fake)
		goto freecopy;

	switch (error) {

	case 0:				/* forwarded, but need redirect */
		/* type, code set above */
		break;

	case ENETUNREACH:		/* shouldn't happen, checked above */
	case EHOSTUNREACH:
	case ENETDOWN:
	case EHOSTDOWN:
	default:
		type = ICMP_UNREACH;
		code = ICMP_UNREACH_HOST;
		break;

	case EMSGSIZE:
		type = ICMP_UNREACH;
		code = ICMP_UNREACH_NEEDFRAG;

#ifdef IPSEC
		if (rt != NULL) {
			if (rt->rt_rmx.rmx_mtu)
				destmtu = rt->rt_rmx.rmx_mtu;
			else {
				struct ifnet *destifp;

				destifp = if_get(rt->rt_ifidx);
				if (destifp != NULL)
					destmtu = destifp->if_mtu;
				if_put(destifp);
			}
		}
#endif /*IPSEC*/
		ipstat_inc(ips_cantfrag);
		break;

	case EACCES:
		/*
		 * pf(4) blocked the packet. There is no need to send an ICMP
		 * packet back since pf(4) takes care of it.
		 */
		goto freecopy;
	case ENOBUFS:
		/*
		 * a router should not generate ICMP_SOURCEQUENCH as
		 * required in RFC1812 Requirements for IP Version 4 Routers.
		 * source quench could be a big problem under DoS attacks,
		 * or the underlying interface is rate-limited.
		 */
		goto freecopy;
	}

	mcopy = m_copym(&mfake, 0, len, M_DONTWAIT);
	if (mcopy)
		icmp_error(mcopy, type, code, dest, destmtu);

freecopy:
	if (fake)
		m_tag_delete_chain(&mfake);
	rtfree(rt);
}

int
ip_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen) 
{
	int error;
#ifdef MROUTING
	extern int ip_mrtproto;
	extern struct mrtstat mrtstat;
#endif

	NET_ASSERT_LOCKED();

	/* Almost all sysctl names at this level are terminal. */
	if (namelen != 1 && name[0] != IPCTL_IFQUEUE)
		return (ENOTDIR);

	switch (name[0]) {
#ifdef notyet
	case IPCTL_DEFMTU:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_mtu));
#endif
	case IPCTL_SOURCEROUTE:
		/*
		 * Don't allow this to change in a secure environment.
		 */
		if (newp && securelevel > 0)
			return (EPERM);
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ip_dosourceroute));
	case IPCTL_MTUDISC:
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &ip_mtudisc);
		if (ip_mtudisc != 0 && ip_mtudisc_timeout_q == NULL) {
			ip_mtudisc_timeout_q =
			    rt_timer_queue_create(ip_mtudisc_timeout);
		} else if (ip_mtudisc == 0 && ip_mtudisc_timeout_q != NULL) {
			rt_timer_queue_destroy(ip_mtudisc_timeout_q);
			ip_mtudisc_timeout_q = NULL;
		}
		return error;
	case IPCTL_MTUDISCTIMEOUT:
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		   &ip_mtudisc_timeout);
		if (ip_mtudisc_timeout_q != NULL)
			rt_timer_queue_change(ip_mtudisc_timeout_q,
					      ip_mtudisc_timeout);
		return (error);
	case IPCTL_IPSEC_ENC_ALGORITHM:
	        return (sysctl_tstring(oldp, oldlenp, newp, newlen,
				       ipsec_def_enc, sizeof(ipsec_def_enc)));
	case IPCTL_IPSEC_AUTH_ALGORITHM:
	        return (sysctl_tstring(oldp, oldlenp, newp, newlen,
				       ipsec_def_auth,
				       sizeof(ipsec_def_auth)));
	case IPCTL_IPSEC_IPCOMP_ALGORITHM:
	        return (sysctl_tstring(oldp, oldlenp, newp, newlen,
				       ipsec_def_comp,
				       sizeof(ipsec_def_comp)));
	case IPCTL_IFQUEUE:
	        return (sysctl_niq(name + 1, namelen - 1,
		    oldp, oldlenp, newp, newlen, &ipintrq));
	case IPCTL_STATS:
		return (ip_sysctl_ipstat(oldp, oldlenp, newp));
#ifdef MROUTING
	case IPCTL_MRTSTATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp,
		    &mrtstat, sizeof(mrtstat)));
	case IPCTL_MRTPROTO:
		return (sysctl_rdint(oldp, oldlenp, newp, ip_mrtproto));
	case IPCTL_MRTMFC:
		if (newp)
			return (EPERM);
		return mrt_sysctl_mfc(oldp, oldlenp);
	case IPCTL_MRTVIF:
		if (newp)
			return (EPERM);
		return mrt_sysctl_vif(oldp, oldlenp);
#else
	case IPCTL_MRTPROTO:
	case IPCTL_MRTSTATS:
	case IPCTL_MRTMFC:
	case IPCTL_MRTVIF:
		return (EOPNOTSUPP);
#endif
	default:
		if (name[0] < IPCTL_MAXID)
			return (sysctl_int_arr(ipctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

int
ip_sysctl_ipstat(void *oldp, size_t *oldlenp, void *newp)
{
	uint64_t counters[ips_ncounters];
	struct ipstat ipstat;
	u_long *words = (u_long *)&ipstat;
	int i;

	CTASSERT(sizeof(ipstat) == (nitems(counters) * sizeof(u_long)));
	memset(&ipstat, 0, sizeof ipstat);
	counters_read(ipcounters, counters, nitems(counters));

	for (i = 0; i < nitems(counters); i++)
		words[i] = (u_long)counters[i];

	return (sysctl_rdstruct(oldp, oldlenp, newp, &ipstat, sizeof(ipstat)));
}

void
ip_savecontrol(struct inpcb *inp, struct mbuf **mp, struct ip *ip,
    struct mbuf *m)
{
#ifdef SO_TIMESTAMP
	if (inp->inp_socket->so_options & SO_TIMESTAMP) {
		struct timeval tv;

		microtime(&tv);
		*mp = sbcreatecontrol((caddr_t) &tv, sizeof(tv),
		    SCM_TIMESTAMP, SOL_SOCKET);
		if (*mp)
			mp = &(*mp)->m_next;
	}
#endif
	if (inp->inp_flags & INP_RECVDSTADDR) {
		*mp = sbcreatecontrol((caddr_t) &ip->ip_dst,
		    sizeof(struct in_addr), IP_RECVDSTADDR, IPPROTO_IP);
		if (*mp)
			mp = &(*mp)->m_next;
	}
#ifdef notyet
	/* this code is broken and will probably never be fixed. */
	/* options were tossed already */
	if (inp->inp_flags & INP_RECVOPTS) {
		*mp = sbcreatecontrol((caddr_t) opts_deleted_above,
		    sizeof(struct in_addr), IP_RECVOPTS, IPPROTO_IP);
		if (*mp)
			mp = &(*mp)->m_next;
	}
	/* ip_srcroute doesn't do what we want here, need to fix */
	if (inp->inp_flags & INP_RECVRETOPTS) {
		*mp = sbcreatecontrol((caddr_t) ip_srcroute(m),
		    sizeof(struct in_addr), IP_RECVRETOPTS, IPPROTO_IP);
		if (*mp)
			mp = &(*mp)->m_next;
	}
#endif
	if (inp->inp_flags & INP_RECVIF) {
		struct sockaddr_dl sdl;
		struct ifnet *ifp;

		ifp = if_get(m->m_pkthdr.ph_ifidx);
		if (ifp == NULL || ifp->if_sadl == NULL) {
			memset(&sdl, 0, sizeof(sdl));
			sdl.sdl_len = offsetof(struct sockaddr_dl, sdl_data[0]);
			sdl.sdl_family = AF_LINK;
			sdl.sdl_index = ifp != NULL ? ifp->if_index : 0;
			sdl.sdl_nlen = sdl.sdl_alen = sdl.sdl_slen = 0;
			*mp = sbcreatecontrol((caddr_t) &sdl, sdl.sdl_len,
			    IP_RECVIF, IPPROTO_IP);
		} else {
			*mp = sbcreatecontrol((caddr_t) ifp->if_sadl,
			    ifp->if_sadl->sdl_len, IP_RECVIF, IPPROTO_IP);
		}
		if (*mp)
			mp = &(*mp)->m_next;
		if_put(ifp);
	}
	if (inp->inp_flags & INP_RECVTTL) {
		*mp = sbcreatecontrol((caddr_t) &ip->ip_ttl,
		    sizeof(u_int8_t), IP_RECVTTL, IPPROTO_IP);
		if (*mp)
			mp = &(*mp)->m_next;
	}
	if (inp->inp_flags & INP_RECVRTABLE) {
		u_int rtableid = inp->inp_rtableid;
#if NPF > 0
		struct pf_divert *divert;

		if (m && m->m_pkthdr.pf.flags & PF_TAG_DIVERTED &&
		    (divert = pf_find_divert(m)) != NULL)
			rtableid = divert->rdomain;
#endif

		*mp = sbcreatecontrol((caddr_t) &rtableid,
		    sizeof(u_int), IP_RECVRTABLE, IPPROTO_IP);
		if (*mp)
			mp = &(*mp)->m_next;
	}
}

void
ip_send_dispatch(void *xmq)
{
	struct mbuf_queue *mq = xmq;
	struct mbuf *m;
	struct mbuf_list ml;
	int s;

	mq_delist(mq, &ml);
	if (ml_empty(&ml))
		return;

	KERNEL_LOCK();
	NET_LOCK(s);
	while ((m = ml_dequeue(&ml)) != NULL) {
		ip_output(m, NULL, NULL, 0, NULL, NULL, 0);
	}
	NET_UNLOCK(s);
	KERNEL_UNLOCK();
}

void
ip_send(struct mbuf *m)
{
	mq_enqueue(&ipsend_mq, m);
	task_add(softnettq, &ipsend_task);
}
@


1.295
log
@Always allocate counters memory using type M_COUNTERS.

This makes the API simpler, and is probably more useful than spreading
counters memory other several types, making it harder to track.

Prodded by mpi, ok mpi@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.294 2017/01/31 10:24:41 jca Exp $	*/
d1658 1
a1658 1

@


1.294
log
@Use CTASSERT instead of KASSERT for a few sysctl that use the counters API

ok dlg@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.293 2017/01/29 19:58:47 bluhm Exp $	*/
d170 1
a170 1
	ipcounters = counters_alloc(ips_ncounters, M_COUNTERS);
@


1.293
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.292 2017/01/25 17:34:31 bluhm Exp $	*/
d1657 1
a1657 1
	KASSERT(sizeof(ipstat) == (nitems(counters) * sizeof(u_long)));
@


1.292
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.291 2016/12/20 18:33:43 bluhm Exp $	*/
d587 1
a587 1
	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, hlen, ip->ip_p);
@


1.291
log
@A NET_LOCK() was is missing in tcp_sysctl() which shows up as spl
softnet assert failures.  It is better to place the lock into
net_sysctl() where all the protocol sysctls are called via pr_sysctl.
As calling sysctl(2) is in the slow path, doing fine grained locking
has no benefit.  Many sysctl cases copy out a struct.  Having a
lock around that keeps the struct consistent.  Put assertions in
the protocol sysctls that need it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.290 2016/12/19 09:22:24 rzalamena Exp $	*/
d587 1
a587 1
	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, hlen, NULL, 0);
@


1.290
log
@Extend the multicast sockets and multicast hash table support to multiple
domains. This is one step towards supporting to run more than one multicast
socket in different domains at the same time.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.289 2016/12/19 08:36:49 mpi Exp $	*/
d1560 1
a1560 1
	int s, error;
d1566 2
a1591 1
			NET_LOCK(s);
a1593 1
			NET_UNLOCK(s);
d1599 1
a1599 2
		if (ip_mtudisc_timeout_q != NULL) {
			NET_LOCK(s);
a1601 2
			NET_UNLOCK(s);
		}
@


1.289
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.288 2016/11/28 23:15:31 bluhm Exp $	*/
d379 1
a379 1
		if (ipmforwarding && ip_mrouter) {
@


1.288
log
@Path MTU discovery and traceroute did not always work with pf af-to.
If an incoming packet is directly put into the output path, sending
the icmp error packet is never done.  As this is basically forwarding,
calling ip_forward() for such packets does everything that is needed.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.287 2016/11/28 11:12:45 mpi Exp $	*/
d1590 1
a1590 1
			s = splsoftnet();
d1593 1
a1593 1
			splx(s);
d1600 1
a1600 1
			s = splsoftnet();
d1603 1
a1603 1
			splx(s);
d1761 3
d1765 1
a1765 1
	s = splsoftnet();
d1769 1
a1769 1
	splx(s);
@


1.287
log
@Assert that every slow/fast timeout routine is called at IPL_SOFTNET.

This removes multipe recursive splsoftnet()/splx() dances.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.286 2016/11/23 10:04:31 mpi Exp $	*/
a131 1
void	ip_forward(struct mbuf *, struct ifnet *, struct rtentry *, int);
@


1.286
log
@Keep checks for local delivery close to in_ouraddr().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.285 2016/11/14 04:27:03 dlg Exp $	*/
d981 2
a982 1
	int s = splsoftnet();
a990 1
	splx(s);
@


1.285
log
@use M_COUNTERS to allocate counters.

suggested by mpi@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.284 2016/11/14 03:51:53 dlg Exp $	*/
d360 6
a429 6
		ip_ours(m);
		goto out;
	}

	if (ip->ip_dst.s_addr == INADDR_BROADCAST ||
	    ip->ip_dst.s_addr == INADDR_ANY) {
@


1.284
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the ipstat struct.

ipstat_inc(ips_foo) replaces ipstat.ips_foo++ for the actual updates.
ipstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the ipstat struct for now.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.283 2016/11/08 10:45:08 mpi Exp $	*/
d171 1
a171 1
	ipcounters = counters_alloc(ips_ncounters, M_PCB);
@


1.283
log
@Only use the routing table for source address selection when processing IP
options.

Make sure the next hop is directly reachable if IPOPT_SSRR is set.

Input from and ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.282 2016/09/22 10:12:25 jsg Exp $	*/
d123 3
a125 1
struct ipstat ipstat;
d137 1
a137 1

d171 2
d254 1
a254 1
	ipstat.ips_total++;
d257 1
a257 1
		ipstat.ips_toosmall++;
d262 1
a262 1
		ipstat.ips_badvers++;
d267 1
a267 1
		ipstat.ips_badhlen++;
d272 1
a272 1
			ipstat.ips_badhlen++;
d282 1
a282 1
			ipstat.ips_badaddr++;
d289 1
a289 1
			ipstat.ips_badsum++;
d293 1
a293 1
		ipstat.ips_inswcsum++;
d295 1
a295 1
			ipstat.ips_badsum++;
d307 1
a307 1
		ipstat.ips_badlen++;
d318 1
a318 1
		ipstat.ips_tooshort++;
d377 1
a377 1
					ipstat.ips_toosmall++;
d398 1
a398 1
				ipstat.ips_cantforward++;
d411 1
a411 1
			ipstat.ips_forward++;
d419 1
a419 1
			ipstat.ips_notmember++;
d421 1
a421 1
				ipstat.ips_cantforward++;
d443 1
a443 1
		ipstat.ips_cantforward++;
d452 1
a452 1
			ipstat.ips_cantforward++;
d500 1
a500 1
				ipstat.ips_toosmall++;
d533 1
a533 1
				ipstat.ips_badfrags++;
d545 1
a545 1
			ipstat.ips_fragments++;
d548 1
a548 1
				ipstat.ips_rcvmemdrop++;
d554 1
a554 1
				ipstat.ips_rcvmemdrop++;
d565 1
a565 1
			ipstat.ips_reassembled++;
d577 1
a577 1
			ipstat.ips_cantforward++;
d587 1
a587 1
	ipstat.ips_delivered++;
d903 1
a903 1
		ipstat.ips_toolong++;
d945 1
a945 1
	ipstat.ips_fragdropped++;
d986 1
a986 1
			ipstat.ips_fragtimeout++;
d1000 1
a1000 1
		ipstat.ips_fragdropped++;
d1015 1
a1015 1
		ipstat.ips_fragdropped++;
d1253 1
a1253 1
	ipstat.ips_badoptions++;
d1403 1
a1403 1
		ipstat.ips_cantforward++;
d1484 1
a1484 1
		ipstat.ips_cantforward++;
d1486 1
a1486 1
		ipstat.ips_forward++;
d1488 1
a1488 1
			ipstat.ips_redirectsent++;
d1528 1
a1528 1
		ipstat.ips_cantfrag++;
d1622 1
a1622 2
		return (sysctl_rdstruct(oldp, oldlenp, newp,
		    &ipstat, sizeof(ipstat)));
d1651 18
@


1.282
log
@Fix indentation.  No binary change.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.281 2016/09/15 02:00:18 dlg Exp $	*/
d1120 6
a1125 28
			if (opt == IPOPT_SSRR) {
				if ((ia = ifatoia(ifa_ifwithdstaddr(
				    sintosa(&ipaddr),
				    m->m_pkthdr.ph_rtableid))) == NULL)
					ia = ifatoia(ifa_ifwithnet(
					    sintosa(&ipaddr),
					    m->m_pkthdr.ph_rtableid));
				if (ia == NULL) {
					type = ICMP_UNREACH;
					code = ICMP_UNREACH_SRCFAIL;
					goto bad;
				}
				memcpy(cp + off, &ia->ia_addr.sin_addr,
				    sizeof(struct in_addr));
				cp[IPOPT_OFFSET] += sizeof(struct in_addr);
			} else {
				/* keep packet in the virtual instance */
				rt = rtalloc(sintosa(&ipaddr), RT_RESOLVE,
				    rtableid);
				if (!rtisvalid(rt)) {
					type = ICMP_UNREACH;
					code = ICMP_UNREACH_SRCFAIL;
					rtfree(rt);
					goto bad;
				}
				ia = ifatoia(rt->rt_ifa);
				memcpy(cp + off, &ia->ia_addr.sin_addr,
				    sizeof(struct in_addr));
d1127 1
a1127 1
				cp[IPOPT_OFFSET] += sizeof(struct in_addr);
d1129 5
@


1.281
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.280 2016/09/06 00:04:15 dlg Exp $	*/
d1121 6
a1126 4
			    if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(&ipaddr),
				m->m_pkthdr.ph_rtableid))) == NULL)
				ia = ifatoia(ifa_ifwithnet(sintosa(&ipaddr),
				    m->m_pkthdr.ph_rtableid));
@


1.280
log
@pool_setipl for various netinet and netinet6 bits

thank you to everyone who helped reviewed these diffs

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.279 2016/07/22 07:39:06 mpi Exp $	*/
d169 4
a172 4
	pool_init(&ipqent_pool, sizeof(struct ipqent), 0, 0, 0, "ipqe",  NULL);
	pool_setipl(&ipqent_pool, IPL_SOFTNET);
	pool_init(&ipq_pool, sizeof(struct ipq), 0, 0, 0, "ipq", NULL);
	pool_setipl(&ipq_pool, IPL_SOFTNET);
@


1.279
log
@Fix a double rtfree(9) triggered when IPSEC inserts a more specific
route because of PMTU.

otto@@ reported the issue and helped me tracking it down during more
than one month, he is the man!

mikeb@@ figured out the bug was in the forwarding path.

ok mikeb@@, deraadt@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.278 2016/07/18 13:17:44 bluhm Exp $	*/
d170 1
d172 1
@


1.278
log
@Hide pf internals by moving code from in_ouraddr() to pf_ouraddr().
OK mpi@@ sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.277 2016/06/18 10:36:13 vgross Exp $	*/
d1491 1
@


1.277
log
@Add net.inet.{tcp,udp}.rootonly sysctl, to mark which ports
cannot be bound to by non-root users.

Ok millert@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.276 2016/05/07 09:56:39 mpi Exp $	*/
d595 1
d597 4
a600 3
	struct pf_state_key	*key;

	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED)
d602 3
a604 9

	key = m->m_pkthdr.pf.statekey;
	if (key != NULL) {
		if (key->inp != NULL)
			return (1);

		/* If we have linked state keys it is certainly forwarded. */
		if (key->reverse != NULL)
			return (0);
@


1.276
log
@Use rtalloc_mpath() when checking for local route entries because we
are now using the returned route for forwarding as well.

This restore the behavior of r1.274 when using mpath entries for
forwarding.

ok visa@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.275 2016/05/03 12:19:13 mpi Exp $	*/
d166 2
d194 7
@


1.275
log
@Make ip_forward() use the route entry fetched in in_ouraddr() when it is
possible.

This reduce the number of lookups to 1 for non-multicast traffic when PF
is disable.

Tested by Hrvoje Popovski who confirmed that benchmark numbers are now as
good as with a single cache entry.

ok visa@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.274 2016/04/25 12:33:48 mpi Exp $	*/
d609 2
a610 1
	rt = rtalloc(sintosa(&sin), 0, m->m_pkthdr.ph_rtableid);
@


1.274
log
@Remove the single cache route for forwarding.

Testing help from Hrvoje Popovski.

ok mikeb@@, henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.273 2016/04/19 08:23:13 mpi Exp $	*/
d129 2
a130 2
int	in_ouraddr(struct mbuf *, struct ifnet *, struct in_addr);
void	ip_forward(struct mbuf *, struct ifnet *, int);
d226 3
a228 2
	struct ifnet *ifp;
	struct ip *ip;
d345 1
a345 1
	if (in_ouraddr(m, ifp, ip->ip_dst)) {
d447 1
a447 1
	ip_forward(m, ifp, pfrdr);
d453 1
d580 1
a580 1
in_ouraddr(struct mbuf *m, struct ifnet *ifp, struct in_addr ina)
d583 1
d603 2
d608 1
a608 1
	sin.sin_addr = ina;
d626 1
a626 1
	rtfree(rt);
d638 1
a638 1
		    !IN_CLASSFULBROADCAST(ina.s_addr, ina.s_addr))
d653 1
a653 1
			if (IN_CLASSFULBROADCAST(ina.s_addr,
d1249 1
a1249 1
		ip_forward(m, ifp, 1);
d1395 1
a1395 1
ip_forward(struct mbuf *m, struct ifnet *ifp, int srcrt)
a1399 1
	struct rtentry *rt;
d1408 1
a1408 1
		return;
d1412 1
a1412 1
		return;
a1414 1

d1421 8
a1428 5
	rt = rtalloc_mpath(sintosa(sin), &ip->ip_src.s_addr,
	    m->m_pkthdr.ph_rtableid);
	if (rt == NULL) {
		icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_HOST, dest, 0);
		return;
@


1.273
log
@Instead of freeing a cached RTF_MPATH route after using it, free it
when the next packet needs to be forwarded, just like if the route
was invalid.

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.272 2016/04/18 12:10:34 mpi Exp $	*/
a199 2
struct	route ipforward_rt;

a972 4
	if (ipforward_rt.ro_rt) {
		rtfree(ipforward_rt.ro_rt);
		ipforward_rt.ro_rt = NULL;
	}
d1396 1
a1397 1
	u_int rtableid = 0;
a1410 1
	rtableid = m->m_pkthdr.ph_rtableid;
d1412 11
a1422 21
	rt = ipforward_rt.ro_rt;
	sin = satosin(&ipforward_rt.ro_dst);
	if (rt == NULL || ISSET(rt->rt_flags, RTF_MPATH) ||
	    ip->ip_dst.s_addr != sin->sin_addr.s_addr ||
	    rtableid != ipforward_rt.ro_tableid) {
		if (ipforward_rt.ro_rt) {
			rtfree(ipforward_rt.ro_rt);
			ipforward_rt.ro_rt = NULL;
		}
		sin->sin_family = AF_INET;
		sin->sin_len = sizeof(*sin);
		sin->sin_addr = ip->ip_dst;
		ipforward_rt.ro_tableid = rtableid;

		ipforward_rt.ro_rt = rtalloc_mpath(&ipforward_rt.ro_dst,
		    &ip->ip_src.s_addr, ipforward_rt.ro_tableid);
		if (ipforward_rt.ro_rt == 0) {
			icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_HOST, dest, 0);
			return;
		}
		rt = ipforward_rt.ro_rt;
d1474 3
a1476 1
	error = ip_output(m, NULL, &ipforward_rt,
d1489 1
a1489 1
		return;
d1547 1
a1547 1
 freecopy:
d1550 1
@


1.272
log
@Unbreak RAMDISK, found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.271 2016/04/18 06:43:51 mpi Exp $	*/
d1419 1
d1421 1
a1421 1
	if ((rt = ipforward_rt.ro_rt) == NULL ||
d1504 1
a1504 1
		goto freert;
d1526 1
a1526 3
		if (ipforward_rt.ro_rt) {
			struct rtentry *rt = ipforward_rt.ro_rt;

a1564 9
 freert:
#ifndef SMALL_KERNEL
	if (ipmultipath && ipforward_rt.ro_rt &&
	    (ipforward_rt.ro_rt->rt_flags & RTF_MPATH)) {
		rtfree(ipforward_rt.ro_rt);
		ipforward_rt.ro_rt = NULL;
	}
#endif
	return;
@


1.271
log
@Put a KERNEL_LOCK/UNLOCK dance around sections that still need some
work in the forwarding path.

Tested by Hrvoje Popovski, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.270 2016/04/15 11:18:40 mpi Exp $	*/
d230 4
a233 1
	int rv, hlen, len;
@


1.270
log
@Kill in_rtaddr() and use rtalloc(9) directly in ip_dooptions().

This brings ip_dooptions() closer to mp-safeness by ensuring that
``ifa'' is dereferenced before calling rtfree(9).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.269 2016/03/29 10:34:42 sashan Exp $	*/
d230 1
a230 1
	int hlen, len;
a357 2
			int rv;

d431 4
a434 1
		if (ip_input_ipsec_fwd_check(m, hlen) != 0) {
d1031 1
d1245 1
d1252 1
@


1.269
log
@- packet must keep reference to statekey
  this is the second attempt to get it in, the first
  attempt got backed out on Jan 31 2016

  the change also contains fixes contributed by Stefan Kempf
  in earlier iteration.

OK srhen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.268 2016/01/31 00:18:07 sashan Exp $	*/
d1016 2
d1113 9
a1121 1
			} else
d1123 13
a1135 6
				ia = ip_rtaddr(ipaddr.sin_addr,
				    m->m_pkthdr.ph_rtableid);
			if (ia == NULL) {
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				goto bad;
a1137 3
			memcpy(cp + off, &ia->ia_addr.sin_addr,
			    sizeof(struct in_addr));
			cp[IPOPT_OFFSET] += sizeof(struct in_addr);
d1169 2
a1170 4
			if ((ia = ifatoia(ifa_ifwithaddr(sintosa(&ipaddr),
			    m->m_pkthdr.ph_rtableid))) == NULL &&
			    (ia = ip_rtaddr(ipaddr.sin_addr,
			    m->m_pkthdr.ph_rtableid)) == NULL) {
d1173 1
d1176 1
d1179 1
a1251 28
}

/*
 * Given address of next destination (final or next hop),
 * return internet address info of interface to be used to get there.
 */
struct in_ifaddr *
ip_rtaddr(struct in_addr dst, u_int rtableid)
{
	struct sockaddr_in *sin;

	sin = satosin(&ipforward_rt.ro_dst);

	if (ipforward_rt.ro_rt == 0 || dst.s_addr != sin->sin_addr.s_addr) {
		if (ipforward_rt.ro_rt) {
			rtfree(ipforward_rt.ro_rt);
			ipforward_rt.ro_rt = NULL;
		}
		sin->sin_family = AF_INET;
		sin->sin_len = sizeof(*sin);
		sin->sin_addr = dst;

		ipforward_rt.ro_rt = rtalloc(&ipforward_rt.ro_dst,
		    RT_RESOLVE, rtableid);
	}
	if (ipforward_rt.ro_rt == 0)
		return (NULL);
	return (ifatoia(ipforward_rt.ro_rt->rt_ifa));
@


1.268
log
@- m_pkthdr.pf.statekey changes are not ready for 5.9, I must back them out

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.267 2016/01/25 18:49:57 sashan Exp $	*/
d1461 3
@


1.267
log
@- plugging massive pf_state_key leak

OK mpi@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.266 2016/01/21 11:23:48 mpi Exp $	*/
a1460 3
#if NPF > 0
		pf_pkt_unlink_state_key(&mfake);
#endif	/* NPF > 0 */
@


1.266
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.265 2015/12/03 21:11:53 sashan Exp $	*/
d1461 3
@


1.265
log
@ip_send()/ip6_send() allow PF to send response packet in ipsoftnet task.
this avoids current recursion to pf_test() function. the change also
switches icmp_error()/icmp6_error() to use ip_send()/ip6_send() so
they are safe for PF.

The idea comes from Markus Friedl. bluhm, mikeb and mpi helped me
a lot to get it into shape.

OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.264 2015/12/03 15:12:59 markus Exp $	*/
a348 2
		struct in_multi *inm;

d403 1
a403 2
		IN_LOOKUP_MULTI(ip->ip_dst, ifp, inm);
		if (inm == NULL) {
@


1.264
log
@factor out ip_input_ipsec_{fwd,ours}_check(); ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.263 2015/12/02 13:29:26 claudio Exp $	*/
d47 1
d125 2
d136 2
d196 2
d1762 24
@


1.263
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.262 2015/11/23 15:54:45 mpi Exp $	*/
d128 4
a224 6
#ifdef IPSEC
	int error;
	struct tdb *tdb;
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
#endif /* IPSEC */
d429 1
a429 16
	        /*
		 * IPsec policy check for forwarded packets. Look at
		 * inner-most IPsec SA used.
		 */
		mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
		if (mtag != NULL) {
			tdbi = (struct tdb_ident *)(mtag + 1);
			tdb = gettdb(tdbi->rdomain, tdbi->spi,
			    &tdbi->dst, tdbi->proto);
		} else
			tdb = NULL;
	        ipsp_spd_lookup(m, AF_INET, hlen, &error,
		    IPSP_DIRECTION_IN, tdb, NULL, 0);

		/* Error or otherwise drop-packet indication */
		if (error) {
a432 1

a460 6
#ifdef IPSEC
	int error;
	struct tdb *tdb;
	struct tdb_ident *tdbi;
	struct m_tag *mtag;
#endif /* IPSEC */
d552 5
a556 59
	if (!ipsec_in_use)
		goto skipipsec;

        /*
         * If it's a protected packet for us, skip the policy check.
         * That's because we really only care about the properties of
         * the protected packet, and not the intermediate versions.
         * While this is not the most paranoid setting, it allows
         * some flexibility in handling nested tunnels (in setting up
	 * the policies).
         */
        if ((ip->ip_p == IPPROTO_ESP) || (ip->ip_p == IPPROTO_AH) ||
	    (ip->ip_p == IPPROTO_IPCOMP))
		goto skipipsec;

	/*
	 * If the protected packet was tunneled, then we need to
	 * verify the protected packet's information, not the
	 * external headers. Thus, skip the policy lookup for the
	 * external packet, and keep the IPsec information linked on
	 * the packet header (the encapsulation routines know how
	 * to deal with that).
	 */
	if ((ip->ip_p == IPPROTO_IPIP) || (ip->ip_p == IPPROTO_IPV6))
		goto skipipsec;

	/*
	 * If the protected packet is TCP or UDP, we'll do the
	 * policy check in the respective input routine, so we can
	 * check for bypass sockets.
	 */
	if ((ip->ip_p == IPPROTO_TCP) || (ip->ip_p == IPPROTO_UDP))
		goto skipipsec;

	/*
	 * IPsec policy check for local-delivery packets. Look at the
	 * inner-most SA that protected the packet. This is in fact
	 * a bit too restrictive (it could end up causing packets to
	 * be dropped that semantically follow the policy, e.g., in
	 * certain SA-bundle configurations); but the alternative is
	 * very complicated (and requires keeping track of what
	 * kinds of tunneling headers have been seen in-between the
	 * IPsec headers), and I don't think we lose much functionality
	 * that's needed in the real world (who uses bundles anyway ?).
	 */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
	if (mtag) {
		tdbi = (struct tdb_ident *)(mtag + 1);
	        tdb = gettdb(tdbi->rdomain, tdbi->spi, &tdbi->dst,
		    tdbi->proto);
	} else
		tdb = NULL;
	ipsp_spd_lookup(m, AF_INET, hlen, &error, IPSP_DIRECTION_IN,
	    tdb, NULL, 0);

	/* Error or otherwise drop-packet indication. */
	if (error) {
	        ipstat.ips_cantforward++;
	        goto bad;
a557 2

 skipipsec:
d653 90
@


1.262
log
@Use if_get() rather than rt_ifp.

ok sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.261 2015/11/14 15:40:40 mpi Exp $	*/
d1246 1
a1246 1
		    RT_REPORT|RT_RESOLVE, rtableid);
@


1.261
log
@Grab the KERNEL_LOCK around ip_mforward(), in preparation for unlocking
ip_input().

Note that ipmforwarding is not enabled by default.

ok deraadt@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.260 2015/10/27 12:06:37 mpi Exp $	*/
d1519 8
a1526 2
			else
				destmtu = ipforward_rt.ro_rt->rt_ifp->if_mtu;
@


1.260
log
@Rewrite in_ouraddr() to not use ``rt_ifa'' since it is not obvious that
the lifetime of an ``ifa'' is tied to a route entry, so it might no
longer be valid after calling rtfree(9).

While here put a KERNEL_LOCK() around the per-ifp address list iteration.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.259 2015/10/26 15:49:13 mpi Exp $	*/
d355 2
d376 4
a379 1
			if (ip_mforward(m, ifp) != 0) {
@


1.259
log
@Use rt_ifidx rather than rt_ifp.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.258 2015/10/19 11:59:26 mpi Exp $	*/
a648 1
	struct in_ifaddr	*ia = NULL;
d651 1
d674 16
a689 2
	if (rtisvalid(rt) && ISSET(rt->rt_flags, RTF_LOCAL|RTF_BROADCAST))
		ia = ifatoia(rt->rt_ifa);
d692 1
a692 1
	if (ia == NULL) {
d712 1
d718 4
a721 2
			    ifatoia(ifa)->ia_addr.sin_addr.s_addr))
				return (1);
d723 1
a723 16

		return (0);
	}

	if (ina.s_addr != ia->ia_addr.sin_addr.s_addr) {
		/*
		 * This matches a broadcast address on one of our interfaces.
		 * If directedbcast is enabled we only consider it local if it
		 * is received on the interface with that address.
		 */
		if (ip_directedbcast && ia->ia_ifp != ifp)
			return (0);

		/* Make sure M_BCAST is set */
		if (m)
			m->m_flags |= M_BCAST;
d726 1
a726 1
	return (1);
@


1.258
log
@Remove superfluous NULL checks.

ifa are refcounted to ensure that rt_ifa is always valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.257 2015/10/13 10:29:16 mpi Exp $	*/
d1455 1
a1455 1
	if (rt->rt_ifp == ifp &&
@


1.257
log
@Make use of rtisvalid(9) to check if local route entries match existing
configured addressses.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.256 2015/09/25 09:51:20 mpi Exp $	*/
d1460 1
a1460 2
		if (rt->rt_ifa &&
		    (ip->ip_src.s_addr & ifatoia(rt->rt_ifa)->ia_netmask) ==
@


1.256
log
@Ensure that RTF_LOCAL route entries always stay UP.

Local route entries, being now attached to their corresponding interface,
are susceptible to be brought DOWN when a link state change occurs.  When
this happens locally configured addresses are no longer reachable.

So keep the previous (original) behavior by forcing such route entries to
always be UP.

ok sthen@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.255 2015/09/11 19:34:20 dlg Exp $	*/
d674 3
a676 7
	if (rt != NULL) {
		/* only use non-stale local address, check before route free */
		if ((rt->rt_flags & (RTF_LOCAL|RTF_BROADCAST)) &&
		    rt->rt_ifa != NULL && rt->rt_ifa->ifa_ifp != NULL)
			ia = ifatoia(rt->rt_ifa);
		rtfree(rt);
	}
@


1.255
log
@if_put after if_get in ip_savecontrol

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.254 2015/09/11 10:06:52 dlg Exp $	*/
d728 1
a728 1
	return (ISSET(ia->ia_ifp->if_flags, IFF_UP));
@


1.254
log
@if_put after if_get.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.253 2015/08/19 15:30:25 bluhm Exp $	*/
d1712 1
@


1.253
log
@An interface address without interface pointer could cause an
uvm_fault in in_ouraddr().  Do not use a stale local address from
the routing table.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.252 2015/07/16 21:14:21 mpi Exp $	*/
d236 1
a236 1
		return;
d251 1
a251 1
			return;
d321 1
a321 1
		return;
d335 1
a335 1
	        return;
d340 1
a340 1
		return;
d358 1
a358 1
					return;
d386 1
a386 1
				return;
d403 1
a403 1
		return;
d409 1
a409 1
		return;
d454 1
d458 2
@


1.252
log
@Kill IP_ROUTETOETHER.

This pseudo-option is a hack to support return-rst on bridge(4).  It
passes Ethernet information via a "struct route" through ip_output().

"struct route" is slowly dying...

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.251 2015/06/16 11:09:40 mpi Exp $	*/
d672 3
a674 1
		if (rt->rt_flags & (RTF_LOCAL|RTF_BROADCAST))
@


1.251
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.250 2015/06/07 01:25:27 krw Exp $	*/
d318 1
a318 1
	if (pf_test(AF_INET, PF_IN, ifp, &m, NULL) != PF_PASS)
@


1.250
log
@Replace a bunch of == 0 with == NULL in pointer tests. Nuke some
annoying trailing, leading and embedded whitespace. No change to
.o files.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.249 2015/05/13 10:42:46 jsg Exp $	*/
d228 3
a230 1
	ifp = m->m_pkthdr.rcvif;
d1692 1
a1692 1
		ifp = m->m_pkthdr.rcvif;
@


1.249
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.248 2015/04/10 13:58:20 dlg Exp $	*/
d162 1
a162 1
	if (pr == 0)
d579 1
a579 1
        	goto skipipsec;
d1053 1
a1053 1
			if (ia == 0) {
d1091 1
a1091 1
			if (ia == 0) {
d1132 1
a1132 1
			    m->m_pkthdr.ph_rtableid))) == 0 &&
d1134 1
a1134 1
			    m->m_pkthdr.ph_rtableid)) == 0) {
d1172 1
a1172 1
				if (ia == 0)
d1188 1
a1188 1
				    m->m_pkthdr.ph_rtableid) == 0)
@


1.248
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.247 2015/03/14 03:38:52 jsg Exp $	*/
d553 1
a553 1
			if (m == 0) {
@


1.247
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.246 2015/02/09 12:18:19 claudio Exp $	*/
d52 1
d117 1
a117 1
struct	ifqueue ipintrq;
a172 1
	IFQ_SET_MAXLEN(&ipintrq, IFQ_MAXLEN);
a194 1
	int s;
d196 5
a200 10
	for (;;) {
		/*
		 * Get next datagram off input queue and get IP header
		 * in first mbuf.
		 */
		s = splnet();
		IF_DEQUEUE(&ipintrq, m);
		splx(s);
		if (m == NULL)
			return;
d1613 1
a1613 1
	        return (sysctl_ifq(name + 1, namelen - 1,
@


1.246
log
@Implement 2 sysctl to retrieve the multicast forwarding cache (mfc) and the
virtual interface table (vif). Will be used by netstat soon.
Looked over by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.245 2015/02/08 04:14:47 claudio Exp $	*/
a44 1
#include <sys/syslog.h>
@


1.245
log
@Just use sysctl_rdstruct() to read out some structs. Only difference
to current code is that you can no longer call this with a NULL oldlenp
which does not make any sense. OK phessler, henning
Behaviour change pointed out by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.244 2015/01/12 13:51:45 mpi Exp $	*/
d1625 1
a1626 1
#ifdef MROUTING
a1628 3
#else
		return (EOPNOTSUPP);
#endif
a1629 1
#ifdef MROUTING
d1631 8
d1640 4
@


1.244
log
@Kill the global list of IPv4 addresses.

ok claudio@@, mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.243 2014/12/05 15:50:04 mpi Exp $	*/
d1623 1
a1623 3
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
d1627 1
a1627 3
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
@


1.243
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.242 2014/11/20 11:05:19 mpi Exp $	*/
a116 1
struct	in_ifaddrhead in_ifaddr;
a173 1
	TAILQ_INIT(&in_ifaddr);
@


1.242
log
@In TCP and UDP layers do not (ab)use the receiving interface to check
for a multicast/broadcast destination address.

These checks have already been done in the Ethernet and IP layers and
the mbuf(9) should contain all the required information at this point.
But since we cannot trust this spaghetti stack, be paranoid and make
sure to set the flags in the IP input routines.

Use explicit comments, requested by deraadt@@.  ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.241 2014/11/05 14:03:02 mpi Exp $	*/
d50 1
@


1.241
log
@Kill in_iawithaddr() and use ifa_ifwithaddr() directly.

Note that ifa_ifwithaddr() might return a broadcast address, so if you
don't want one make sure to filter them out.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.240 2014/11/04 15:24:40 mpi Exp $	*/
d351 8
@


1.240
log
@Remove "pl" suffix on pool names.

ok dlg@@, uebayasi@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.239 2014/11/01 21:40:38 mpi Exp $	*/
a721 17
}

struct in_ifaddr *
in_iawithaddr(struct in_addr ina, u_int rtableid)
{
	struct in_ifaddr	*ia;
	struct sockaddr_in	 sin;

	memset(&sin, 0, sizeof(sin));
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;
	sin.sin_addr = ina;
	ia = ifatoia(ifa_ifwithaddr(sintosa(&sin), rtableid));
	if (ia == NULL || ina.s_addr == ia->ia_addr.sin_addr.s_addr)
		return (ia);

	return (NULL);
@


1.239
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.238 2014/10/14 09:52:26 mpi Exp $	*/
d158 2
a159 4
	pool_init(&ipqent_pool, sizeof(struct ipqent), 0, 0, 0, "ipqepl",
	    NULL);
	pool_init(&ipq_pool, sizeof(struct ipq), 0, 0, 0, "ipqpl",
	    NULL);
@


1.238
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.237 2014/09/30 08:21:21 mpi Exp $	*/
d670 1
a670 1
	rt = rtalloc1(sintosa(&sin), 0, m->m_pkthdr.ph_rtableid);
d1254 2
a1255 2
		ipforward_rt.ro_rt = rtalloc1(&ipforward_rt.ro_dst, RT_REPORT,
		    rtableid);
@


1.237
log
@Use the routing table instead of the RB-tree for address lookups in
in_ouraddr().

The lookup done in the forwarding case will hopefully be merged with
this one in the future.

ok kspillner@@, bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.236 2014/09/27 12:26:16 mpi Exp $	*/
d967 2
a968 2
		RTFREE(ipforward_rt.ro_rt);
		ipforward_rt.ro_rt = 0;
d1247 2
a1248 2
			RTFREE(ipforward_rt.ro_rt);
			ipforward_rt.ro_rt = 0;
d1421 1
a1421 1
	if ((rt = ipforward_rt.ro_rt) == 0 ||
d1425 2
a1426 2
			RTFREE(ipforward_rt.ro_rt);
			ipforward_rt.ro_rt = 0;
d1563 2
a1564 2
		RTFREE(ipforward_rt.ro_rt);
		ipforward_rt.ro_rt = 0;
@


1.236
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.235 2014/07/13 13:57:56 mpi Exp $	*/
d646 2
a647 1
	struct in_ifaddr	*ia;
d670 6
a675 1
	ia = ifatoia(ifa_ifwithaddr(sintosa(&sin), m->m_pkthdr.ph_rtableid));
@


1.235
log
@Stop using old n_time, n_long and n_short types in netinet headers.

ok deraadt@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.234 2014/06/04 12:20:00 mpi Exp $	*/
d1427 2
a1428 1
		rtalloc_mpath(&ipforward_rt, &ip->ip_src.s_addr);
@


1.234
log
@Stop using a global variable to do address lookups.

ok blambert@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.233 2014/05/10 12:30:27 claudio Exp $	*/
d1011 1
a1011 1
	n_time ntime;
d1164 1
a1164 1
			if (ipt.ipt_ptr - 1 + sizeof(n_time) > ipt.ipt_len) {
d1176 1
a1176 1
				if (ipt.ipt_ptr - 1 + sizeof(n_time) +
d1193 1
a1193 1
				if (ipt.ipt_ptr - 1 + sizeof(n_time) +
d1213 2
a1214 2
			memcpy(cp + ipt.ipt_ptr - 1, &ntime, sizeof(n_time));
			ipt.ipt_ptr += sizeof(n_time);
d1399 1
a1399 1
	n_long dest;
@


1.233
log
@Fix a few bad indents
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.232 2014/05/07 08:26:38 mpi Exp $	*/
a192 1
struct	sockaddr_in ipaddr = { sizeof(ipaddr), AF_INET };
d1005 1
d1060 3
d1090 3
d1135 4
a1138 2
			memcpy(&ipaddr.sin_addr, &ip->ip_dst,
			    sizeof(ipaddr.sin_addr));
d1179 3
d1196 4
a1199 2
				memcpy(&ipaddr.sin_addr, &sin,
				    sizeof(struct in_addr));
@


1.232
log
@Remove the last hacks concerning the global list of IPv4 addresses in the
source address selection logic.

These hacks were only relevant for the NFS diskless boot code in order to
pick the local broadcast address of the only configured interface.  So, be
explicit and set this address directly.

Tested by florian@@, ok henning@@, beck@@, chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.231 2014/04/21 12:22:26 henning Exp $	*/
d582 1
a582 1
          goto skipipsec;
d593 1
a593 1
	  goto skipipsec;
d601 1
a601 1
	  goto skipipsec;
@


1.231
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.230 2014/04/21 11:10:54 henning Exp $	*/
a240 6
	/*
	 * If no IP addresses have been set yet but the interfaces
	 * are receiving, can't do anything with incoming packets yet.
	 */
	if (TAILQ_EMPTY(&in_ifaddr))
		goto bad;
@


1.230
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.228 2014/03/27 10:44:23 mpi Exp $	*/
d1477 1
a1477 1
	    NULL, NULL);
@


1.229
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1475 1
a1475 1
	error = ip_output(m, (struct mbuf *)NULL, &ipforward_rt,
d1477 1
a1477 1
	    (void *)NULL, (void *)NULL);
@


1.228
log
@Stop dereferencing the ifp pointer present in the packet header all
over the input path since it is going to die.  Should be no functional
change.

ok mikeb@@, lteo@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.227 2014/03/21 10:44:42 mpi Exp $	*/
d676 1
a676 1
	ia = ifatoia(ifa_ifwithaddr(sintosa(&sin), m->m_pkthdr.rdomain));
d691 1
a691 1
		if (ifp->if_rdomain != m->m_pkthdr.rdomain)
d1068 1
a1068 1
			    m->m_pkthdr.rdomain));
d1097 1
a1097 1
				m->m_pkthdr.rdomain))) == NULL)
d1099 1
a1099 1
				    m->m_pkthdr.rdomain));
d1103 1
a1103 1
				    m->m_pkthdr.rdomain);
d1143 1
a1143 1
			    m->m_pkthdr.rdomain))) == 0 &&
d1145 1
a1145 1
			    m->m_pkthdr.rdomain)) == 0) {
d1194 1
a1194 1
				    m->m_pkthdr.rdomain) == 0)
d1405 1
a1405 1
	rtableid = m->m_pkthdr.rdomain;
d1461 1
a1461 1
	    !arpproxy(satosin(rt_key(rt))->sin_addr, m->m_pkthdr.rdomain)) {
@


1.227
log
@rt_timer* spring cleanup.

Rename and document rt_timer_count() into rt_timer_queue_count() to
be consistent with the other functions.  Remove unused argument from
rt_timer_queue_destroy(), clean the definitions and finally use the
same order in NAME and DESCRIPTION as requested by jmc@@.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.226 2014/01/24 18:54:58 henning Exp $	*/
d125 3
a127 1
int	in_ouraddr(struct in_addr, struct mbuf *);
d228 1
d239 2
d274 1
a274 1
		if ((m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) == 0) {
d323 2
a324 3
	if (m->m_pkthdr.rcvif->if_type == IFT_CARP &&
	    ip->ip_p != IPPROTO_ICMP && carp_lsdrop(m, AF_INET,
	    &ip->ip_src.s_addr, &ip->ip_dst.s_addr))
d333 1
a333 1
	if (pf_test(AF_INET, PF_IN, m->m_pkthdr.rcvif, &m, NULL) != PF_PASS)
d349 1
a349 1
	if (hlen > sizeof (struct ip) && ip_dooptions(m)) {
d353 1
a353 1
	if (in_ouraddr(ip->ip_dst, m)) {
d381 1
a381 1
			if (ip_mforward(m, m->m_pkthdr.rcvif) != 0) {
d402 1
a402 1
		IN_LOOKUP_MULTI(ip->ip_dst, m->m_pkthdr.rcvif, inm);
d420 2
a421 3
	if (m->m_pkthdr.rcvif->if_type == IFT_CARP &&
	    ip->ip_p == IPPROTO_ICMP && carp_lsdrop(m, AF_INET,
	    &ip->ip_src.s_addr, &ip->ip_dst.s_addr))
d460 1
a460 1
	ip_forward(m, pfrdr);
d651 1
a651 1
in_ouraddr(struct in_addr ina, struct mbuf *m)
d691 1
a691 1
		if (m->m_pkthdr.rcvif->if_rdomain != m->m_pkthdr.rdomain)
d698 1
a698 1
		TAILQ_FOREACH(ifa, &m->m_pkthdr.rcvif->if_addrlist, ifa_list) {
d716 1
a716 1
		if (ip_directedbcast && ia->ia_ifp != m->m_pkthdr.rcvif)
d1009 1
a1009 1
ip_dooptions(struct mbuf *m)
d1179 1
a1179 1
				    m->m_pkthdr.rcvif));
d1211 1
a1211 1
		ip_forward(m, 1);
d1384 1
a1384 1
ip_forward(struct mbuf *m, int srcrt)
d1457 1
a1457 1
	if (rt->rt_ifp == m->m_pkthdr.rcvif &&
d1691 2
a1692 2
		if ((ifp = m->m_pkthdr.rcvif) == NULL ||
		    ifp->if_sadl == NULL) {
@


1.226
log
@clearing the _CSUM_IN_OK flags is now utterly pointless, was only done for
statistics sideeffects before. ok lteo naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.223 2013/12/31 03:24:44 tedu Exp $	*/
d1588 1
a1588 1
			rt_timer_queue_destroy(ip_mtudisc_timeout_q, TRUE);
@


1.225
log
@since the cksum rewrite the counters for hardware checksummed packets
are are lie, since the software engine emulates hardware offloading
and that is later indistinguishable. so kill the hw cksummed counters.
introduce software checksummed packet counters instead.
tcp/udp handles ip & ipvshit, ip cksum covered, 6 has no ip layer cksum.
as before we still have a miscounting bug for inbound with pf on, to be
fixed in the next step.
found by, prodding & ok naddy
@
text
@d286 1
a286 3
	} else
		/* XXXHB20140123 */
		m->m_pkthdr.csum_flags &= ~M_IPV4_CSUM_IN_OK;
@


1.224
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@a276 1
			ipstat.ips_inhwcsum++;
d281 1
d286 2
a287 1
	} else {
a288 2
		ipstat.ips_inhwcsum++;
	}
@


1.223
log
@bcopy -> memcpy. reviewed with one fix from matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.222 2013/11/27 08:34:39 mpi Exp $	*/
d180 1
a180 1
	bzero((void *)&baddynamicports, sizeof(baddynamicports));
d672 1
a672 1
	bzero(&sin, sizeof(sin));
d733 1
a733 1
	bzero(&sin, sizeof(sin));
d1435 1
a1435 1
	bzero(&mfake.m_hdr, sizeof(mfake.m_hdr));
d1693 1
a1693 1
			bzero(&sdl, sizeof(sdl));
@


1.222
log
@Let's call a rtableid a rtableid.

ok mikeb@@, henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.221 2013/11/17 10:07:32 bluhm Exp $	*/
d1093 1
a1093 1
			bcopy((caddr_t)(cp + off), (caddr_t)&ipaddr.sin_addr,
d1110 2
a1111 2
			bcopy((caddr_t)&ia->ia_addr.sin_addr,
			    (caddr_t)(cp + off), sizeof(struct in_addr));
d1135 1
a1135 1
			bcopy((caddr_t)(&ip->ip_dst), (caddr_t)&ipaddr.sin_addr,
d1150 2
a1151 2
			bcopy((caddr_t)&ia->ia_addr.sin_addr,
			    (caddr_t)(cp + off), sizeof(struct in_addr));
d1159 1
a1159 1
			bcopy(cp, &ipt, sizeof(struct ip_timestamp));
d1167 1
a1167 1
			bcopy(cp + ipt.ipt_ptr - 1, &sin, sizeof sin);
d1182 2
a1183 2
				bcopy((caddr_t)&ia->ia_addr.sin_addr,
				    (caddr_t)&sin, sizeof(struct in_addr));
d1191 1
a1191 1
				bcopy((caddr_t)&sin, (caddr_t)&ipaddr.sin_addr,
d1206 1
a1206 2
			bcopy((caddr_t)&ntime, (caddr_t)cp + ipt.ipt_ptr - 1,
			    sizeof(n_time));
d1269 1
a1269 1
	bcopy(option, isr->isr_hdr, olen);
d1318 2
a1319 1
	bcopy(&isr->isr_nop, mtod(m, caddr_t) + sizeof(struct in_addr), OPTSIZ);
d1352 1
a1352 1
	bcopy(opts  + olen, opts, (unsigned)i);
@


1.221
log
@Instead of stripping the IP options manually in icmp_reflect(),
just call ip_stripoptions().  Remove an unneeded parameter and
adjust the ip length in ip_stripoptions().
from FreeBSD; OK deraadt@@ henninh@@ lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.220 2013/11/11 09:15:34 mpi Exp $	*/
d728 1
a728 1
in_iawithaddr(struct in_addr ina, u_int rdomain)
d737 1
a737 1
	ia = ifatoia(ifa_ifwithaddr(sintosa(&sin), rdomain));
@


1.220
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.219 2013/10/23 19:09:28 deraadt Exp $	*/
d1339 1
a1339 5
 * Strip out IP options, at higher
 * level protocol in the kernel.
 * Second argument is buffer to which options
 * will be moved, and return value is their length.
 * XXX should be deleted; last arg currently ignored.
d1342 1
a1342 1
ip_stripoptions(struct mbuf *m, struct mbuf *mopt)
d1357 1
@


1.219
log
@remove the ipprintfs debug stuff; if you are debugging at this level,
you probably write your own chunks as need be.
ok mpi claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.218 2013/10/21 12:27:12 deraadt Exp $	*/
a125 13

char *
inet_ntoa(ina)
	struct in_addr ina;
{
	static char buf[4*sizeof "123"];
	unsigned char *ucp = (unsigned char *)&ina;

	snprintf(buf, sizeof buf, "%d.%d.%d.%d",
	    ucp[0] & 0xff, ucp[1] & 0xff,
	    ucp[2] & 0xff, ucp[3] & 0xff);
	return (buf);
}
@


1.218
log
@There are gasps of shock!  Add a pmtu delay sysctl BUTTON for netinet6,
making the code the same as netinet4 along the way.
ok bluhm phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.217 2013/08/21 09:02:12 mpi Exp $	*/
a106 3
#ifdef DIAGNOSTIC
int	ipprintfs = 0;
#endif
a1274 4
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf("%s: olen %d\n", __func__, olen);
#endif
a1319 5
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf("%s: nhops %d mlen %d", __func__, isr->isr_nhops,
		    m->m_len);
#endif
a1325 4
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf(" hops %x", ntohl(mtod(m, struct in_addr *)->s_addr));
#endif
a1340 4
#ifdef DIAGNOSTIC
		if (ipprintfs)
			printf(" %x", ntohl(q->s_addr));
#endif
a1346 4
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf(" %x\n", ntohl(q->s_addr));
#endif
a1410 5
#ifdef DIAGNOSTIC
	if (ipprintfs)
		printf("forward: src %x dst %x ttl %x\n", ip->ip_src.s_addr,
		    ip->ip_dst.s_addr, ip->ip_ttl);
#endif
a1487 4
#ifdef DIAGNOSTIC
		    if (ipprintfs)
			printf("redirect (%d) to %x\n", code, (u_int32_t)dest);
#endif
@


1.217
log
@When checking for classful broadcast addresses, iterate over the list
from the interface on which the packet was received on instead of
filtering the global list.

ok bluhm@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.216 2013/08/13 09:52:53 mpi Exp $	*/
a77 2

#define IPMTUDISCTIMEOUT (10 * 60)	/* as per RFC 1191 */
@


1.216
log
@When net.inet.ip.sourceroute is enable, store the source route
of incoming IPv4 packets with the SSRR or LSRR header option in
a m_tag rather than in a single static entry.

Use a new m_tag type, PACKET_TAG_SRCROUTE, for this and bump
PACKET_TAG_MAXSIZE accordingly.

Adapted from FreeBSD r135274 with inputs from bluhm@@.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.215 2013/07/31 15:41:51 mikeb Exp $	*/
d697 2
d709 2
d716 6
a721 5
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (ia->ia_ifp == m->m_pkthdr.rcvif &&
			    ia->ia_ifp->if_rdomain == m->m_pkthdr.rdomain &&
			    IN_CLASSFULBROADCAST(ina.s_addr,
			    ia->ia_addr.sin_addr.s_addr))
@


1.215
log
@Move bridge_broadcast and subsequently all IPsec SPD lookup code out
of the IPL_NET.  pf_test should be no longer called under IPL_NET as
well.  The problem became evident after the related issue was brought
up by David Hill <dhill at mindcry ! org>.

With input from and OK mpi.  Tested by David and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.214 2013/07/04 08:22:19 mpi Exp $	*/
d146 1
a146 1
 * We need to save the IP options in case a protocol wants to respond
d152 7
a158 7
int	ip_nhops = 0;
static	struct ip_srcrt {
	struct	in_addr dst;			/* final destination */
	char	nop;				/* one NOP to align */
	char	srcopt[IPOPT_OFFSET + 1];	/* OPTVAL, OLEN and OFFSET */
	struct	in_addr route[MAX_IPOPTLEN/sizeof(struct in_addr)];
} ip_srcrt;
d160 1
a160 1
void save_rte(u_char *, struct in_addr);
a365 1
	ip_nhops = 0;		/* for source routed packets */
d1099 1
a1099 1
				save_rte(cp, ip->ip_src);
d1268 1
a1268 1
save_rte(u_char *option, struct in_addr dst)
d1270 2
d1277 3
a1279 3
		printf("save_rte: olen %d\n", olen);
#endif /* 0 */
	if (olen > sizeof(ip_srcrt) - (1 + sizeof(dst)))
d1281 10
a1290 3
	bcopy((caddr_t)option, (caddr_t)ip_srcrt.srcopt, olen);
	ip_nhops = (olen - IPOPT_OFFSET - 1) / sizeof(struct in_addr);
	ip_srcrt.dst = dst;
d1299 1
a1299 1
ip_srcroute(void)
d1303 2
d1306 10
a1315 2
	if (ip_nhops == 0)
		return ((struct mbuf *)0);
d1317 2
a1318 2
	if (m == 0)
		return ((struct mbuf *)0);
d1320 1
a1320 1
#define OPTSIZ	(sizeof(ip_srcrt.nop) + sizeof(ip_srcrt.srcopt))
d1322 2
a1323 3
	/* length is (nhops+1)*sizeof(addr) + sizeof(nop + srcrt header) */
	m->m_len = ip_nhops * sizeof(struct in_addr) + sizeof(struct in_addr) +
	    OPTSIZ;
d1326 2
a1327 1
		printf("ip_srcroute: nhops %d mlen %d", ip_nhops, m->m_len);
d1333 1
a1333 1
	p = &ip_srcrt.route[ip_nhops - 1];
d1343 3
a1345 4
	ip_srcrt.nop = IPOPT_NOP;
	ip_srcrt.srcopt[IPOPT_OFFSET] = IPOPT_MINOFF;
	bcopy((caddr_t)&ip_srcrt.nop,
	    mtod(m, caddr_t) + sizeof(struct in_addr), OPTSIZ);
d1353 1
a1353 1
	while (p >= ip_srcrt.route) {
d1363 1
a1363 1
	*q = ip_srcrt.dst;
d1368 1
d1727 1
a1727 1
		*mp = sbcreatecontrol((caddr_t) ip_srcroute(),
@


1.214
log
@Rewrite the function used to determine if we do proxy ARP for one of
our addresses to reuse arplookup() and do only one list iteration.

Looks ok to claudio@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.213 2013/06/26 09:12:40 henning Exp $	*/
d248 1
a248 1
	int error, s;
a456 1
                s = splnet();
a464 1
                splx(s);
d498 1
a498 1
	int error, s;
a639 1
        s = splnet();
a647 1
        splx(s);
@


1.213
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.212 2013/06/13 12:15:52 mpi Exp $	*/
a160 1
int ip_weadvertise(u_int32_t, u_int);
a1289 47
 * Check whether we do proxy ARP for this address and we point to ourselves.
 * Code shamelessly copied from arplookup().
 */
int
ip_weadvertise(u_int32_t addr, u_int rtableid)
{
	struct rtentry *rt;
	struct ifnet *ifp;
	struct ifaddr *ifa;
	struct sockaddr_inarp sin;

	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = addr;
	sin.sin_other = SIN_PROXY;
	rt = rtalloc1((struct sockaddr *)&sin, 0, rtableid);
	if (rt == 0)
		return 0;

	if ((rt->rt_flags & RTF_GATEWAY) || (rt->rt_flags & RTF_LLINFO) == 0 ||
	    rt->rt_gateway->sa_family != AF_LINK) {
		RTFREE(rt);
		return 0;
	}

	rtableid = rtable_l2(rtableid);
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rtableid)
			continue;
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != rt->rt_gateway->sa_family)
				continue;

			if (!bcmp(LLADDR((struct sockaddr_dl *)ifa->ifa_addr),
			    LLADDR((struct sockaddr_dl *)rt->rt_gateway),
			    ETHER_ADDR_LEN)) {
				RTFREE(rt);
				return 1;
			}
		}
	}

	RTFREE(rt);
	return 0;
}

/*
d1489 1
a1489 2
	    !ip_weadvertise(satosin(rt_key(rt))->sin_addr.s_addr,
	    m->m_pkthdr.rdomain)) {
@


1.212
log
@Move the local delivery code from ipv4_input() into its own function and
unify some return statements while here.

ok bluhm@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.211 2013/05/17 09:04:30 mpi Exp $	*/
d508 3
@


1.211
log
@Move an extern declaration into its corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.210 2013/04/24 10:17:08 mpi Exp $	*/
d129 1
d238 3
a240 2
 * Ip input routine.  Checksum and byte swap header.  If fragmented
 * try to reassemble.  Process options.  Pass to next level.
d246 1
a246 3
	struct ipq *fp;
	struct ipqent *ipqe;
	int hlen, mff, len;
d372 4
a375 2
	if (in_ouraddr(ip->ip_dst, m))
		goto ours;
d402 1
a402 2
				m_freem(m);
				return;
d410 4
a413 2
			if (ip->ip_p == IPPROTO_IGMP)
				goto ours;
d426 1
a426 2
			m_freem(m);
			return;
d428 2
a429 1
		goto ours;
d433 4
a436 2
	    ip->ip_dst.s_addr == INADDR_ANY)
		goto ours;
d449 1
a449 2
		m_freem(m);
		return;
d472 1
a472 2
			m_freem(m);
			return;
d484 24
a508 1
ours:
d654 1
a654 2
		m_freem(m);
		return;
@


1.210
log
@Instead of having various extern declarations for protocol variables,
declare them once in their corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.209 2013/04/17 14:19:32 mpi Exp $	*/
a117 3

/* from in_pcb.c */
extern struct baddynamicports baddynamicports;
@


1.209
log
@Replace some casts by ifatoia() and sintosa().

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.208 2013/04/10 08:50:59 mpi Exp $	*/
a123 3
extern	struct domain inetdomain;
extern	struct protosw inetsw[];
u_char	ip_protox[IPPROTO_MAX];
@


1.208
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.207 2013/04/09 08:35:38 mpi Exp $	*/
d1093 4
a1096 6
#define	INA	struct in_ifaddr *
#define	SA	struct sockaddr *
			    if ((ia = (INA)ifa_ifwithdstaddr((SA)&ipaddr,
				m->m_pkthdr.rdomain)) == 0)
				ia = (INA)ifa_ifwithnet((SA)&ipaddr,
				    m->m_pkthdr.rdomain);
d1139 2
a1140 2
			if ((ia = (INA)ifa_ifwithaddr((SA)&ipaddr,
			    m->m_pkthdr.rdomain)) == 0 &&
d1175 2
a1176 2
				ia = (INA)ifaof_ifpforaddr((SA)&ipaddr,
							    m->m_pkthdr.rcvif);
d1190 1
a1190 1
				if (ifa_ifwithaddr((SA)&ipaddr,
@


1.207
log
@Remove read-only ipsec variables and directly use defines instead.

ok mikeb@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.206 2013/03/29 13:16:14 bluhm Exp $	*/
a119 4
extern int ipport_firstauto;
extern int ipport_lastauto;
extern int ipport_hifirstauto;
extern int ipport_hilastauto;
a120 1
extern int la_hold_total;
a383 2
		extern struct socket *ip_mrouter;

@


1.206
log
@Declare struct pf_state_key in the mbuf and in_pcb header files to
avoid ugly casts.
OK krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.205 2013/03/28 16:45:16 tedu Exp $	*/
a113 5

int	ipsec_auth_default_level = IPSEC_AUTH_LEVEL_DEFAULT;
int	ipsec_esp_trans_default_level = IPSEC_ESP_TRANS_LEVEL_DEFAULT;
int	ipsec_esp_network_default_level = IPSEC_ESP_NETWORK_LEVEL_DEFAULT;
int	ipsec_ipcomp_default_level = IPSEC_IPCOMP_LEVEL_DEFAULT;
@


1.205
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.204 2013/03/28 12:06:55 mpi Exp $	*/
d675 1
a675 1
	key = (struct pf_state_key *)m->m_pkthdr.pf.statekey;
@


1.204
log
@Replace some casts to struct in_ifaddr pointer by ifatoia() or NULL.

ok millert@@, haesbaert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.203 2013/03/28 00:32:11 bluhm Exp $	*/
a45 1
#include <sys/proc.h>
@


1.203
log
@Unfortunately the satosin, sintosa, ifatoia, satosin6, sin6tosa,
ifatoia6 macros do not check the source type.  They just cast
anything.  Remove needless casts and do not use those macros if the
source type does not match.  Remove duplicate defines.
No binary change.  OK kettenis@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.202 2013/03/26 13:19:26 mpi Exp $	*/
d691 1
a691 2
	ia = (struct in_ifaddr *)ifa_ifwithaddr(sintosa(&sin),
	    m->m_pkthdr.rdomain);
d747 1
a747 1
	ia = (struct in_ifaddr *)ifa_ifwithaddr(sintosa(&sin), rdomain);
d1258 1
a1258 1
		return ((struct in_ifaddr *)0);
@


1.202
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.201 2013/03/22 01:41:12 tedu Exp $	*/
d1300 1
a1300 1
	rt = rtalloc1(sintosa(&sin), 0, rtableid);
@


1.201
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.200 2012/11/06 12:32:42 henning Exp $	*/
a137 1
int	ipqmaxlen = IFQ_MAXLEN;
d208 1
a208 1
	IFQ_SET_MAXLEN(&ipintrq, ipqmaxlen);
@


1.200
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.199 2012/11/01 07:55:56 henning Exp $	*/
d817 2
a818 2
	for (p = NULL, q = LIST_FIRST(&fp->ipq_fragq);
	    q != LIST_END(&fp->ipq_fragq); p = q, q = LIST_NEXT(q, ipqe_q))
d876 2
a877 2
	for (p = NULL, q = LIST_FIRST(&fp->ipq_fragq);
	    q != LIST_END(&fp->ipq_fragq); p = q, q = LIST_NEXT(q, ipqe_q)) {
d950 1
a950 2
	for (q = LIST_FIRST(&fp->ipq_fragq); q != LIST_END(&fp->ipq_fragq);
	    q = p) {
d972 1
a972 1
	for (fp = LIST_FIRST(&ipq); fp != LIST_END(&ipq); fp = nfp) {
@


1.199
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.197 2012/08/07 17:54:20 mikeb Exp $	*/
a502 3
	/* pf might have modified stuff, might have to chksum */
	in_proto_cksum_out(m, NULL);

@


1.198
log
@sysctl calls shouldn't clobber route timers without spl protection

the spl call in the icmp case may be too aggressive, but better safe
than sorry

ok claudio@@
@
text
@d503 3
@


1.197
log
@Store the data used to generate an ICMP error message on a stack
instead of allocating a new mbuf.  This is a third or fourth
attempt to incorporate a change like this meaning a handful of
people have lost their hair trying to make it work, namely dlg@@,
henning@@, deraadt@@, and thib@@.  Unfortunately the fixed version
was never put back which is exceptionally unfortunate since the
impact on performance is huge: it nearly doubles the forwarding
performance on selected hardware in simple setups.

So after being beaten in test and production environments on
several architectures it's ready to be put back again.  We're
doing it early in the release cycle so that it will receive a
good test exposure.

ok derradt, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.196 2012/07/16 18:05:36 markus Exp $	*/
d1637 1
a1637 1
	int error;
d1667 1
d1670 1
d1676 2
a1677 1
		if (ip_mtudisc_timeout_q != NULL)
d1680 2
@


1.196
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.195 2011/07/06 02:42:28 henning Exp $	*/
d1453 1
d1457 1
a1457 1
	int error, type = 0, code = 0, destmtu = 0;
a1458 1
	struct mbuf *mcopy;
d1503 13
a1515 5
	 * Pullup to avoid sharing mbuf cluster between m and mcopy.
	 */
	mcopy = m_copym(m, 0, min(ntohs(ip->ip_len), 68), M_DONTWAIT);
	if (mcopy)
		mcopy = m_pullup(mcopy, min(ntohs(ip->ip_len), 68));
d1564 1
a1564 1
	if (mcopy == NULL)
d1615 3
a1617 2
	icmp_error(mcopy, type, code, dest, destmtu);
	goto freert;
d1620 2
a1621 2
	if (mcopy)
		m_freem(mcopy);
@


1.195
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.194 2011/07/05 21:40:38 dhill Exp $	*/
d482 1
a482 1
		    IPSP_DIRECTION_IN, tdb, NULL);
d642 1
a642 1
	    tdb, NULL);
@


1.194
log
@ansify

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.193 2011/07/04 06:54:49 claudio Exp $	*/
d209 1
a209 1
	ipintrq.ifq_maxlen = ipqmaxlen;
@


1.193
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.192 2011/06/15 09:11:01 mikeb Exp $	*/
d185 1
a185 1
ip_init()
d231 1
a231 1
ipintr()
d259 1
a259 2
ipv4_input(m)
	struct mbuf *m;
d763 1
a763 3
ip_reass(ipqe, fp)
	struct ipqent *ipqe;
	struct ipq *fp;
d946 1
a946 2
ip_freef(fp)
	struct ipq *fp;
d968 1
a968 1
ip_slowtimo()
d991 1
a991 1
ip_drain()
a992 1

d1003 1
a1003 1
ip_flush()
d1022 1
a1022 2
ip_dooptions(m)
	struct mbuf *m;
d1270 1
a1270 3
save_rte(option, dst)
	u_char *option;
	struct in_addr dst;
d1339 1
a1339 1
ip_srcroute()
d1410 1
a1410 3
ip_stripoptions(m, mopt)
	struct mbuf *m;
	struct mbuf *mopt;
d1451 1
a1451 3
ip_forward(m, srcrt)
	struct mbuf *m;
	int srcrt;
d1625 2
a1626 7
ip_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
@


1.192
log
@Add IP_RECVRTABLE socket option to be used with a IPPROTO_IP
level that allows one to retrieve the original routing domain
of UDP datagrams diverted by the pf via "divert-to" with a
recvmsg(2).

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.191 2011/04/19 03:47:29 dlg Exp $	*/
d370 1
a370 1
	if (pf_test(PF_IN, m->m_pkthdr.rcvif, &m, NULL) != PF_PASS)
@


1.191
log
@reintroduce using the RB tree for local address lookups. this is
confusing because both addresses and broadcast addresses are put
into the tree.

there are two types of local address lookup. the first is when the
socket layer wants a local address, the second is in ip_input when
the kernel is figuring out the packet is for it to process or
forward.

ip_input considers local addresses and broadcast addresses as local,
however, the handling of broadcast addresses is different depending
on whether ip_directedbcast is set. if if ip_directbcast is unset
then a packet coming in on any interface to any of the systems
broadcast addresses is considered local, otherwise the broadcast
packet must exist on the interface it was received on.

the code also needs to consider classful broadcast addresses so we
can continue some legacy applications (eg, netbooting old sparcs
that use rarp and bootparam requests to classful broadcast addresses
as per PR6382). this diff maintains that support, but restricts it
to packets that are broadcast on the link layer (eg, ethernet
broadcasted packets), and it only looks up addresses on the local
interface. we now only support classful broadcast addresses on local
interfaces to avoid weird side effects with packets routed to us.

the ip4 socket layer does lookups for local addresses with a wrapper
around the global address tree that rejects matches against broadcast
addresses. we now no longer support bind sockets to broadcast
addresses, no matter what the value of ip_directedbcast is.

ok henning@@
testing (and possibly ok) claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.189 2011/04/04 16:51:15 claudio Exp $	*/
d1790 15
@


1.190
log
@Backout the in_iawithaddr() -> ifa_ifwithaddr() change.
There is a massive issue with broadcast addrs because ifa_ifwithaddr()
handles them differently then in_iawithaddr().
@
text
@d147 2
a263 1
	struct in_ifaddr *ia;
d391 1
a391 6
	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED)
		goto ours;

#if NPF > 0
	if (m->m_pkthdr.pf.statekey &&
	    ((struct pf_state_key *)m->m_pkthdr.pf.statekey)->inp)
a393 11
	/*
	 * Check our list of addresses, to see if the packet is for us.
	 * if we have linked state keys it is certainly to be forwarded.
	 */
	if (!m->m_pkthdr.pf.statekey ||
	    !((struct pf_state_key *)m->m_pkthdr.pf.statekey)->reverse)
#endif
		if ((ia = in_iawithaddr(ip->ip_dst, m, m->m_pkthdr.rdomain)) !=
		    NULL && (ia->ia_ifp->if_flags & IFF_UP))
			goto ours;

d667 2
a668 2
struct in_ifaddr *
in_iawithaddr(struct in_addr ina, struct mbuf *m, u_int rdomain)
d670 4
a673 1
	struct in_ifaddr *ia;
d675 40
a714 11
	rdomain = rtable_l2(rdomain);
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (ia->ia_ifp->if_rdomain != rdomain)
			continue;
		if (ina.s_addr == ia->ia_addr.sin_addr.s_addr)
			return ia;
		/* check ancient classful too, e. g. for rarp-based netboot */
		if (((ip_directedbcast == 0) || (m && ip_directedbcast &&
		    ia->ia_ifp == m->m_pkthdr.rcvif)) &&
		    (ia->ia_ifp->if_flags & IFF_BROADCAST)) {
			if (ina.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
d716 2
a717 6
			    ia->ia_addr.sin_addr.s_addr)) {
				/* Make sure M_BCAST is set */
				if (m)
					m->m_flags |= M_BCAST;
				return ia;
			}
d719 2
d723 32
a754 1
	return NULL;
@


1.189
log
@The forced IP header pullup in the multicast case is only needed when
the system is a multicast forwarder so move the code into that block
and save a few unneeded m_pullups. Found by dlg a long time ago.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.188 2011/04/04 13:30:03 henning Exp $	*/
a146 3
struct in_ifaddr *
	 in_iawithaddr(struct in_addr, struct mbuf *, u_int);

d685 1
a685 2
	struct in_ifaddr	*ia;
	struct sockaddr_in	 sin;
d687 11
a697 16
	bzero(&sin, sizeof(sin));
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;
	sin.sin_addr = ina;
	ia = (struct in_ifaddr *)ifa_ifwithaddr(sintosa(&sin), rdomain);

	/* check ancient classful, e. g. for rarp-based netboot */
	if (ia == NULL && m->m_flags | M_BCAST &&
	    IN_CLASSFULBROADCAST(ina.s_addr, ina.s_addr)) {
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (ia->ia_ifp->if_rdomain != rdomain)
				continue;
			if (((ip_directedbcast == 0) ||
			    (m && ip_directedbcast &&
			    ia->ia_ifp == m->m_pkthdr.rcvif)) &&
			    (ia->ia_ifp->if_flags & IFF_BROADCAST) &&
d699 6
a704 2
			    ia->ia_addr.sin_addr.s_addr))
				return (ia);
d708 1
a708 1
	return (ia);
@


1.188
log
@make in_iawithaddr a wrapper for ifa_ifwithaddr plus a hack for old ancient
classful broadcast so we can still netboot sparc and the like.
compat hack untested, i will deal with the fallout if there is any later
at the same time stop exporting in_iawithaddr, everything but ip_input
should (and now does) use ifa_ifwithaddr directly
ok dlg sthen and agreement from many
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.187 2011/04/02 14:38:09 henning Exp $	*/
d417 7
a423 4
		if (m->m_flags & M_EXT) {
			if ((m = m_pullup(m, hlen)) == NULL) {
				ipstat.ips_toosmall++;
				return;
a424 3
			ip = mtod(m, struct ip *);
		}
		if (ipmforwarding && ip_mrouter) {
@


1.187
log
@rmeove the link1 hack, it is in the way, it is only half-baked and doesn't
work as you think it does, and the same can easily be achieved using pf
ok claudio dlg sthen theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.186 2011/02/11 12:16:30 bluhm Exp $	*/
d147 3
d688 2
a689 1
	struct in_ifaddr *ia;
d691 16
a706 11
	rdomain = rtable_l2(rdomain);
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (ia->ia_ifp->if_rdomain != rdomain)
			continue;
		if (ina.s_addr == ia->ia_addr.sin_addr.s_addr)
			return ia;
		/* check ancient classful too, e. g. for rarp-based netboot */
		if (((ip_directedbcast == 0) || (m && ip_directedbcast &&
		    ia->ia_ifp == m->m_pkthdr.rcvif)) &&
		    (ia->ia_ifp->if_flags & IFF_BROADCAST)) {
			if (ina.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
d708 2
a709 6
			    ia->ia_addr.sin_addr.s_addr)) {
				/* Make sure M_BCAST is set */
				if (m)
					m->m_flags |= M_BCAST;
				return ia;
			}
d713 1
a713 1
	return NULL;
@


1.186
log
@In ip_forward() free the mbuf chain mcopy with m_freem() instead
of m_free().  The was no leak before as m_copym() and m_pullup()
are always called with the same length.  But it is better to use
the correct function anyway.
ok henning@@ mpf@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.185 2011/02/03 17:29:16 millert Exp $	*/
d691 1
a691 4
		if ((ina.s_addr == ia->ia_addr.sin_addr.s_addr) ||
		    ((ia->ia_ifp->if_flags & (IFF_LOOPBACK|IFF_LINK1)) ==
			(IFF_LOOPBACK|IFF_LINK1) &&
		     ia->ia_net == (ina.s_addr & ia->ia_netmask)))
@


1.185
log
@ip_ttl is u_int8_t, not u_char so adjust sizeof for consistency.
No binary change.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.184 2010/09/08 08:34:42 claudio Exp $	*/
d1581 1
a1581 1
		m_free(mcopy);
@


1.184
log
@Return EACCES when pf_test() blocks a packet in ip_output(). This allows
ip_forward() to know the difference between blocked packets and those that
can't be forwarded (EHOSTUNREACH). Only in the latter case an ICMP should
be sent. In the other callers of ip_output() change the error back to
EHOSTUNREACH since userland may not expect EACCES on a sendto().
OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.183 2010/08/20 02:48:31 dlg Exp $	*/
d1746 1
a1746 1
		    sizeof(u_char), IP_RECVTTL, IPPROTO_IP);
@


1.183
log
@white space fix
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.182 2010/07/09 16:58:06 reyk Exp $	*/
d1560 6
@


1.182
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.181 2010/06/07 13:26:35 henning Exp $	*/
d707 1
a707 1
			    }
@


1.181
log
@unfortunately classful routing isn't 100% dead, mostly thanks to ancient
netboot methods using rarp, thus only learning their IP address without
mask. And of course the next step is a broadcast - which goes to the
broadcast address calculated classful. *sigh*. PR6382
instead of storing a second broadcast address per ifaddr as we used to
figure out wether we're dealing with a classful broadcast on the fly. the
math is extremely cheap and all my previous profilings showed that cpu
cycles are basically free, we're constrained by memory access.
excellent analysis by Pascal Lalonde <plalonde at overnet.qc.ca> who also
submitted the PR. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.180 2010/06/04 11:35:43 blambert Exp $	*/
d493 2
a494 1
			tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
d653 2
a654 1
	        tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
@


1.180
log
@Missed this file in previous commit; previous commit message was:

rt_timer_queue_destroy() did not actually destroy, leading to a potential
memory leak due to misleading nomenclature. Change it to actually destroy,
not just clean, the the rt_timer_queue passed to it and adjust the correct
caller accordingly (i.e., no need to free the mem on our own now).

As a bonus, this gets rid of one of the ridiculous R_Malloc/Bzero/Free
cycles, and lets us sneak another bzero -> M_ZERO conversion in.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.179 2010/05/07 13:33:17 claudio Exp $	*/
d694 1
d698 3
a700 1
			if (ina.s_addr == ia->ia_broadaddr.sin_addr.s_addr) {
@


1.179
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.178 2010/04/20 22:05:43 tedu Exp $	*/
a1621 1
			Free(ip_mtudisc_timeout_q);
@


1.178
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.177 2010/01/13 10:31:17 henning Exp $	*/
a226 1
u_int	ipforward_rtableid;
d1215 1
a1215 1
		ipforward_rt.ro_rt = rtalloc1(&ipforward_rt.ro_dst, 1,
d1446 1
a1446 1
	    rtableid != ipforward_rtableid) {
d1454 1
d1456 1
a1456 1
		rtalloc_mpath(&ipforward_rt, &ip->ip_src.s_addr, rtableid);
a1460 1
		ipforward_rtableid = rtableid;
@


1.177
log
@no point in looking for the old "all host bits zero" broadcast address any
more here either
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.176 2010/01/13 07:05:28 henning Exp $	*/
d46 1
@


1.176
log
@we don't need broadcast for the classful network AND broadcast for the
subnet of the classful network. at least, not since 1992.
ok mpf dlg bob
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.175 2010/01/13 01:26:28 henning Exp $	*/
d697 1
a697 6
			if (ina.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
			    /*
			     * Look for all-0's host part (old broadcast addr),
			     * either for subnet or net.
			     */
			    ina.s_addr == ia->ia_net) {
@


1.175
log
@let's admit it's not 1992 any more. CIDR is around for a long time, even
that router vendor doesn't default to classful routing any more, and there
really is no point in having a classful netmask and a subnetmask to split
it. we still do classful guesses on the netmask if it isn't supplied by
userland, but that's about it.
i decided to keep ia_netmask and kill ia_subnetmask which makes this diff
bigish, the classful ia_netmask wasn't really used all that much. the real
changes are in in.c, the rest is mostly s/ia_subnetmask/ia_netmask.
ok claudio dlg ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.174 2009/12/07 08:19:37 gollo Exp $	*/
a697 1
			    ina.s_addr == ia->ia_netbroadcast.s_addr ||
@


1.174
log
@do not forward and drop packets with M_MCAST flag set in ip_forward()

ok henning@@, claudio@@ "I think this should go in"
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.173 2009/11/19 22:07:17 otto Exp $	*/
d692 1
a692 1
		     ia->ia_subnet == (ina.s_addr & ia->ia_subnetmask)))
a702 1
			    ina.s_addr == ia->ia_subnet ||
d1498 2
a1499 2
		    (ip->ip_src.s_addr & ifatoia(rt->rt_ifa)->ia_subnetmask) ==
		    ifatoia(rt->rt_ifa)->ia_subnet) {
@


1.173
log
@avoid overflow since protos > IPPROTO_MAX exist. From FreeBSD with
a twist; ok millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.172 2009/11/03 10:59:04 claudio Exp $	*/
d1438 1
a1438 1
	if (m->m_flags & M_BCAST || in_canforward(ip->ip_dst) == 0) {
@


1.172
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.171 2009/08/23 20:06:25 david Exp $	*/
d202 2
a203 1
		    pr->pr_protocol && pr->pr_protocol != IPPROTO_RAW)
@


1.171
log
@revert the icmp error diff again (r1.167-1.169)

seems to be causing some kind of memory corruption after several
hours of heavy IPsec traffic.  connections start becoming very slow
eventually leading to all IPsec packets being lost.  a reboot solves
the issue for several more hours before it appears again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.170 2009/08/10 15:29:34 henning Exp $	*/
d684 1
d1080 1
a1080 2
				/* keep packet in the original VRF instance */
				/* XXX rdomain or rtableid ??? */
d1119 1
a1119 2
			 * Again keep the packet inside the VRF instance.
			 * XXX rdomain vs. rtableid ???
d1278 1
a1447 2
	if (m->m_pkthdr.pf.rtableid)
		rtableid = m->m_pkthdr.pf.rtableid;
@


1.170
log
@7 years of
#if 1
reasonable
#else
bullshit required by some committee
#endif
are enough. theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.169 2009/08/10 15:26:33 henning Exp $	*/
d1426 1
a1426 1
	int error, type = 0, code = 0, destmtu = 0, len;
d1428 1
a1429 1
	struct mbuf mfake, *mcopy = NULL;
d1475 1
d1477 3
a1479 7
	bzero(&mfake.m_hdr, sizeof(mfake.m_hdr));
	mfake.m_type = m->m_type;
	M_DUP_PKTHDR(&mfake, m);
	mfake.m_data = mfake.m_pktdat;
	len = min(min(ntohs(ip->ip_len), 68), MHLEN);
	m_copydata(m, 0, len, mfake.m_pktdat);
	mfake.m_pkthdr.len = mfake.m_len = len;
d1528 2
d1573 1
a1573 3
	mcopy = m_copym(&mfake, 0, len, M_DONTWAIT);
	if (mcopy)
		icmp_error(mcopy, type, code, dest, destmtu);
@


1.169
log
@we need to null mcopy, gotos bite. theo and i both missed them, theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.168 2009/08/10 13:20:08 henning Exp $	*/
a1564 1
#if 1
a1571 5
#else
		type = ICMP_SOURCEQUENCH;
		code = 0;
		break;
#endif
@


1.168
log
@fix previous:
-m_copydata istead of straight bcopy. noticed by damien
-handle the pretty much impossible case that the packet header grows so
 much that MHLEN < 68. i bet this had been the least of our worries, in that
 case, but code oughta be correct anyway.
ok theo and dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.167 2009/08/10 11:48:02 henning Exp $	*/
d1429 1
a1429 1
	struct mbuf mfake, *mcopy;
@


1.167
log
@this is basically a fixed version of r1.165, avoid m_copym of each and every
forwarded packet in case ip_output returns an error and we have to quote
some of it back in an icmp error message.
this implementation done from scratch:
place an mbuf on the stack. copy the pkthdr from the forwarded packet and
the first 68 bytes of payload.
if we need to send an icmp error, just m_copym our mbuf-on-the-stack into
a real one that icmp_error can fuck with and eat as it desires.
ok theo dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.166 2009/07/28 14:01:50 dlg Exp $	*/
d1480 2
a1481 2
	len = min(ntohs(ip->ip_len), 68);
	bcopy(ip, mfake.m_pktdat, len);
@


1.166
log
@revert the avoidance of the mbuf copy for the icmp errors (r1.165)

some greater care must be taken to ensure the mbuf generated for icmp
errors is a good copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.165 2009/07/24 12:30:05 dlg Exp $	*/
d1426 1
a1426 1
	int error, type = 0, code = 0, destmtu = 0;
a1427 1
	struct mbuf *mcopy;
d1429 1
a1474 1
	 * Pullup to avoid sharing mbuf cluster between m and mcopy.
d1476 7
a1482 3
	mcopy = m_copym(m, 0, min(ntohs(ip->ip_len), 68), M_DONTWAIT);
	if (mcopy)
		mcopy = m_pullup(mcopy, min(ntohs(ip->ip_len), 68));
a1530 2
	if (mcopy == NULL)
		goto freert;
d1580 3
a1582 1
	icmp_error(mcopy, type, code, dest, destmtu);
@


1.165
log
@for every packet we forwarded, we copied the first 68 bytes of it in case
ip_output failed and we had to generate an icmp packet. since ip_output
frees the mbuf we give it, we copied the original into a new mbuf. if
ip_output succeeded, we threw the copy away.

the problem with this is that copying the mbuf is about a third of the cost
of ip_forward.

this diff copies the data we might need onto the stack, and only builds the
mbuf for the icmp error if it actually needs it, ie, if ip_output fails.

this gives a noticable improvement in pps for forwarded traffic.

ok claudio@@ markus@@ henning@@
tested by markus@@ and by me in production for several days at work
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.163 2009/06/04 05:02:25 henning Exp $	*/
d1419 3
a1421 1
ip_forward(struct mbuf *m, int srcrt)
a1422 1
	u_int8_t icmp_buf[68];
d1428 1
a1428 3
	u_int icmp_len;
	struct ifnet *ifp;
	u_int8_t generated;
d1475 1
d1477 3
a1479 4
	icmp_len = min(sizeof(icmp_buf), ntohs(ip->ip_len));
	m_copydata(m, 0, icmp_len, (caddr_t)icmp_buf);
	ifp = m->m_pkthdr.rcvif;
	generated = m->m_pkthdr.pf.flags & PF_TAG_GENERATED;
d1526 1
a1526 1
			goto freert;
d1528 2
d1571 1
d1575 1
a1576 1
		break;
d1579 2
a1580 19
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		goto freert;

	if (icmp_len > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if (!ISSET(m->m_flags, M_EXT)) {
                        m_free(m);
			goto freert;
                }
        }

	m->m_len = m->m_pkthdr.len = icmp_len;
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.rdomain = rtableid;
	m->m_pkthdr.pf.flags |= generated;
	bcopy(icmp_buf, m->m_data, icmp_len);

	icmp_error(m, type, code, dest, destmtu);
d1582 3
@


1.164
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1419 1
a1419 3
ip_forward(m, srcrt)
	struct mbuf *m;
	int srcrt;
d1421 1
d1427 3
a1429 1
	struct mbuf *mcopy;
a1475 1
	 * Pullup to avoid sharing mbuf cluster between m and mcopy.
d1477 4
a1480 3
	mcopy = m_copym(m, 0, min(ntohs(ip->ip_len), 68), M_DONTWAIT);
	if (mcopy)
		mcopy = m_pullup(mcopy, min(ntohs(ip->ip_len), 68));
d1527 1
a1527 1
			goto freecopy;
a1528 2
	if (mcopy == NULL)
		goto freert;
a1569 1
		goto freecopy;
d1573 1
a1574 1
#endif
d1577 19
a1595 2
	icmp_error(mcopy, type, code, dest, destmtu);
	goto freert;
a1596 3
 freecopy:
	if (mcopy)
		m_free(mcopy);
@


1.163
log
@the decision on wether a packet is to be delivered locally or forwarded
is pretty expensive, the more the more addresses are configured locally,
since we walk a list. when pf is on and we have a state key pointer,
and that state key is linked to another state key, we know for sure this
is not local. when it has a link to a pcb, it certainly goes to the local
codepath.
on a box with 1000 adresses forwarding 3 times as fast as before. theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.162 2009/05/18 20:37:13 bluhm Exp $	*/
d175 1
a175 1
int ip_weadvertise(u_int32_t);
d404 2
a405 2
		if ((ia = in_iawithaddr(ip->ip_dst, m)) != NULL &&
		    (ia->ia_ifp->if_flags & IFF_UP))
d680 1
a680 3
in_iawithaddr(ina, m)
	struct in_addr ina;
	struct mbuf *m;
d685 2
d1043 2
a1044 1
			ia = ifatoia(ifa_ifwithaddr(sintosa(&ipaddr)));
d1074 4
a1077 2
			    if ((ia = (INA)ifa_ifwithdstaddr((SA)&ipaddr)) == 0)
				ia = (INA)ifa_ifwithnet((SA)&ipaddr);
d1079 4
a1082 1
				ia = ip_rtaddr(ipaddr.sin_addr);
d1119 2
d1122 4
a1125 2
			if ((ia = (INA)ifa_ifwithaddr((SA)&ipaddr)) == 0 &&
			    (ia = ip_rtaddr(ipaddr.sin_addr)) == 0) {
d1173 2
a1174 1
				if (ifa_ifwithaddr((SA)&ipaddr) == 0)
d1207 1
a1207 2
ip_rtaddr(dst)
	 struct in_addr dst;
d1222 2
a1223 1
		rtalloc(&ipforward_rt);
d1258 1
a1258 2
ip_weadvertise(addr)
	u_int32_t addr;
d1269 1
a1269 1
	rt = rtalloc1(sintosa(&sin), 0, 0);	/* XXX other tables? */
d1279 3
a1281 1
	TAILQ_FOREACH(ifp, &ifnet, if_list)
d1293 1
d1447 3
a1449 3
#if NPF > 0
	rtableid = m->m_pkthdr.pf.rtableid;
#endif
d1497 2
a1498 1
	    !ip_weadvertise(satosin(rt_key(rt))->sin_addr.s_addr)) {
@


1.162
log
@The routing table index rtableid has type unsigned int in the routing
code.  In pf rtableid == -1 means don't change the rtableid because
of this rule.  So it has to be signed int there.  Before the value
is passed from pf to route it is always checked to be >= 0.  Change
the type to int in pf and to u_int in netinet and netinet6 to make
the checks work.  Otherwise -1 may be used as an array index and
the kernel crashes.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.161 2008/12/24 07:41:59 dlg Exp $	*/
d389 8
d399 1
d401 6
a406 6
	if ((ia = in_iawithaddr(ip->ip_dst, m)) != NULL &&
	    (ia->ia_ifp->if_flags & IFF_UP))
		goto ours;

	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED)
		goto ours;
d463 1
@


1.161
log
@report the number of packets that arp resolution is holding onto until it
gets a mac addr for an ip under net.inet.ip.arpqueued.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.159 2008/05/09 02:44:54 markus Exp $	*/
d225 1
a225 1
int	ipforward_rtableid;
d1403 2
a1404 1
	int error, type = 0, code = 0, destmtu = 0, rtableid = 0;
@


1.160
log
@alloc ipq's for fragment reassembly from a pool instead of using
malloc();

ok henning@@ some time ago
@
text
@d130 1
@


1.159
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.158 2008/04/24 11:36:38 dlg Exp $	*/
d141 1
d190 2
d732 2
a733 2
	if (fp == 0) {
		fp = malloc(sizeof (struct ipq), M_FTABLE, M_NOWAIT);
d870 1
a870 1
	free(fp, M_FTABLE);
d909 1
a909 1
	free(fp, M_FTABLE);
@


1.158
log
@the softnet intr handlers check if the input queue has packets on
it by reading the queues head pointer. if that pointer is not null
then it takes splnet and dequeues a packet for handling. this is
bad because the ifqueue head is modified at splnet and the sofnet
handlers read it without holding splnet.

this removes that check of the head pointer and simply checks if
the dequeue gave us a packet or not before proceeding.

found while reading mpls code.
discussed with norby@@ and henning@@

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.157 2008/02/05 22:57:31 mpf Exp $	*/
d390 3
@


1.157
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.156 2007/12/14 18:33:41 deraadt Exp $	*/
d229 1
a229 1
	while (ipintrq.ifq_head) {
d237 1
a237 1
		if (m == 0)
@


1.156
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.155 2007/12/13 20:00:53 reyk Exp $	*/
d354 2
a355 4
	    m->m_pkthdr.rcvif->if_flags & IFF_LINK0 &&
	    ip->ip_p != IPPROTO_ICMP &&
	    carp_lsdrop(m, AF_INET, &ip->ip_src.s_addr,
	    &ip->ip_dst.s_addr))
d453 2
a454 4
	    m->m_pkthdr.rcvif->if_flags & IFF_LINK0 &&
	    ip->ip_p == IPPROTO_ICMP &&
	    carp_lsdrop(m, AF_INET, &ip->ip_src.s_addr,
	    &ip->ip_dst.s_addr))
@


1.155
log
@implement sysctls to report IP, TCP, UDP, and ICMP statistics and
change netstat to use them instead of accessing kvm for it. more
protocols will be added later.

discussed with deraadt@@ claudio@@ gilles@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.154 2007/10/29 16:19:23 chl Exp $	*/
d66 4
d1578 4
d1638 15
@


1.154
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.153 2007/09/10 23:05:39 thib Exp $	*/
d1625 5
@


1.153
log
@Remove the ipq locking, it isn't strictly needed right now
and is actually wrong in some cases, since we can enter
functions without taking the lock because the return value
of ipq_lock() isn't checked properly.

However, this needs to be revisited when we start calling
ip_drain() from the pool code when we are running out of
memory, but this isn't done currently.

OK art@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.152 2007/09/01 18:49:28 henning Exp $	*/
d727 1
a727 2
		MALLOC(fp, struct ipq *, sizeof (struct ipq),
		    M_FTABLE, M_NOWAIT);
d864 1
a864 1
	FREE(fp, M_FTABLE);
d903 1
a903 1
	FREE(fp, M_FTABLE);
@


1.152
log
@since the
MGET* macros were changed to function calls, there wasn't any
need for the pool declarations and the inclusion of pool.h
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.151 2007/05/30 04:46:45 henning Exp $	*/
a135 4
int	ipq_locked;
static __inline int ipq_lock_try(void);
static __inline void ipq_unlock(void);

a139 28
static __inline int
ipq_lock_try()
{
	int s;

	/* Use splvm() due to mbuf allocation. */
	s = splvm();
	if (ipq_locked) {
		splx(s);
		return (0);
	}
	ipq_locked = 1;
	splx(s);
	return (1);
}

#define ipq_lock() ipq_lock_try()

static __inline void
ipq_unlock()
{
	int s;

	s = splvm();
	ipq_locked = 0;
	splx(s);
}

a519 1
		ipq_lock();
a543 1
				ipq_unlock();
a558 1
				ipq_unlock();
a564 1
				ipq_unlock();
a572 1
				ipq_unlock();
a581 1
		ipq_unlock();
a917 1
	ipq_lock();
a924 1
	ipq_unlock();
a938 2
	if (ipq_lock_try() == 0)
		return;
a942 1
	ipq_unlock();
@


1.151
log
@no need to declare extern ipsec_in_use, we get it via ip_ipsp.h
found by itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.150 2007/05/29 17:46:24 henning Exp $	*/
d47 1
@


1.150
log
@gain another 5+% in ip forwarding performance.
boring details:
skip looking for ipsec tags and descending into ip_spd_lookup if there
are no ipsec flows, except in one case in ip_output (spotted by markus)
where we have to if we have a pcb. ip_spd_lookup has the shortcut already,
but there is enough work done before so that skipping that gains us about
5%. ok theo, markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.149 2007/05/28 17:16:39 henning Exp $	*/
a92 3
#ifdef IPSEC
extern int	ipsec_in_use;
#endif /* IPSEC */
@


1.149
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.148 2007/05/27 20:14:15 dlg Exp $	*/
d93 3
d497 2
a498 1
	} else {
d500 1
d527 1
d530 1
a530 2
		ip_forward(m, pfrdr);
	}
d625 3
@


1.148
log
@-static on appropriate functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.147 2007/03/18 23:23:17 mpf Exp $	*/
a1436 3
#if NPF > 0
	struct pf_mtag	*pft;
#endif
d1455 1
a1455 2
	if ((pft = pf_find_mtag(m)) != NULL)
		rtableid = pft->rtableid;
@


1.147
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.146 2006/12/28 20:06:10 deraadt Exp $	*/
d199 2
a200 2
static void save_rte(u_char *, struct in_addr);
static int ip_weadvertise(u_int32_t);
d1267 1
a1267 1
static int
@


1.146
log
@check if ifqueue has anything queued before doing the dance of
splnet/IF_DEQUEUE/splx; ok various people
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.145 2006/11/27 12:27:45 henning Exp $	*/
d36 1
d69 5
d379 9
d480 8
@


1.145
log
@make use of multiple routing tables.
hook up looking up routes in alternate tables to the packet forwarding path.
alternate routing tables are mintained with route(8), table selection via pf.
mostly hacked on a train ride with ryan some time ago, ok mcbride claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.144 2006/10/11 09:29:20 henning Exp $	*/
d250 1
a250 1
	while (1) {
@


1.144
log
@implement IP_RECVTTL socket option.
when set on raw or udp sockets, userland receives the incoming packet's TTL
as ancillary data (cmsg shitz). modeled after the FreeBSD implementation.
ok claudio djm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.143 2006/06/18 12:03:19 pascoe Exp $	*/
d242 1
d1411 1
a1411 1
	int error, type = 0, code = 0, destmtu = 0;
d1414 3
d1434 5
d1441 2
a1442 1
	    ip->ip_dst.s_addr != sin->sin_addr.s_addr) {
d1451 1
a1451 1
		rtalloc_mpath(&ipforward_rt, &ip->ip_src.s_addr, 0);
d1456 1
@


1.143
log
@Whitespace, oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.142 2006/06/18 11:47:45 pascoe Exp $	*/
d1697 6
@


1.142
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.141 2006/06/16 16:49:40 henning Exp $	*/
d1501 1
a1501 1
		else 
@


1.141
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.140 2006/06/15 10:08:34 pascoe Exp $	*/
d91 1
d1441 1
a1441 1
		rtalloc(&ipforward_rt);
d1501 2
a1502 5
		else {
			if (mcopy)
				m_freem(mcopy);
			return;
		}
d1505 1
a1505 1
		return;
d1547 1
a1547 3
		if (mcopy)
			m_freem(mcopy);
		return;
d1556 14
@


1.140
log
@Make number of varargs passed to ip_output match reality.

henning@@ claudio@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.139 2006/05/29 20:42:27 claudio Exp $	*/
d1255 1
a1255 1
	rt = rtalloc1(sintosa(&sin), 0);
@


1.139
log
@Make savecontrol functions more generic and use them now for raw IP too.
Additionally add the IP_RECVIF option which returns the interface a packet
was received on. OK markus@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.138 2006/03/05 21:48:56 miod Exp $	*/
d1491 1
a1491 1
	error = ip_output(m, (struct mbuf *)0, &ipforward_rt,
d1493 1
a1493 1
	    0, (void *)NULL, (void *)NULL);
@


1.138
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.137 2006/03/04 22:40:16 brad Exp $	*/
d43 1
d1631 61
@


1.137
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.136 2006/01/03 14:53:50 mpf Exp $	*/
d290 1
a290 1
	if (in_ifaddr.tqh_first == 0)
d524 1
a524 1
		for (fp = ipq.lh_first; fp != NULL; fp = fp->ipq_q.le_next)
d754 1
a754 1
	ecn0 = fp->ipq_fragq.lh_first->ipqe_ip->ip_tos & IPTOS_ECN_MASK;
d759 1
a759 1
			fp->ipq_fragq.lh_first->ipqe_ip->ip_tos |= IPTOS_ECN_CE;
d767 2
a768 2
	for (p = NULL, q = fp->ipq_fragq.lh_first; q != NULL;
	    p = q, q = q->ipqe_q.le_next)
d808 1
a808 1
		nq = q->ipqe_q.le_next;
d826 2
a827 2
	for (p = NULL, q = fp->ipq_fragq.lh_first; q != NULL;
	    p = q, q = q->ipqe_q.le_next) {
d839 1
a839 1
	q = fp->ipq_fragq.lh_first;
d850 1
a850 1
	nq = q->ipqe_q.le_next;
d855 1
a855 1
		nq = q->ipqe_q.le_next;
d901 3
a903 2
	for (q = fp->ipq_fragq.lh_first; q != NULL; q = p) {
		p = q->ipqe_q.le_next;
d925 2
a926 2
	for (fp = ipq.lh_first; fp != NULL; fp = nfp) {
		nfp = fp->ipq_q.le_next;
d949 1
a949 1
	while (ipq.lh_first != NULL) {
d951 1
a951 1
		ip_freef(ipq.lh_first);
d965 1
a965 1
	while (ipq.lh_first != NULL && ip_frags > ip_maxqueue * 3 / 4 && --max) {
d967 1
a967 1
		ip_freef(ipq.lh_first);
d1264 2
a1265 3
	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next)
		for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
		    ifa = ifa->ifa_list.tqe_next) {
@


1.136
log
@m_pullup the same amount we copied, not just the IP header.
Any pf(4) translation that modifies more than IP addresses,
was happening on the shared mbuf cluster. Thus we were
sending icmp errors with corrupted payload.
OK dhartmei@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.135 2005/11/20 19:25:16 brad Exp $	*/
d252 1
a252 1
		s = splimp();
@


1.135
log
@splimp -> splvm. mbuf allocation here.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.134 2005/10/05 17:32:22 norby Exp $	*/
d1452 1
a1452 1
	mcopy = m_copym(m, 0, imin(ntohs(ip->ip_len), 68), M_DONTWAIT);
d1454 1
a1454 1
		mcopy = m_pullup(mcopy, ip->ip_hl << 2);
@


1.134
log
@Add multicast routing to GENERIC.

It is now possible to enable multicast routing in the kernel with
the sysctl option net.inet.ip.mforwarding=1

Based on intial work by msf@@

help claudio@@
ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.133 2005/09/19 01:48:05 deraadt Exp $	*/
d140 2
a141 1
	s = splimp();
d158 1
a158 1
	s = splimp();
@


1.133
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.132 2005/09/19 01:47:42 deraadt Exp $	*/
d89 1
d414 1
a414 2

		if (ip_mrouter) {
@


1.132
log
@Fix initialisation of baddynamicports.udp, busted since 1997, wow.
found by leonardo@@iken.com.br
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.131 2005/08/11 12:55:31 mpf Exp $	*/
d434 1
a434 1
			 * The process-level routing demon needs to receive
@


1.131
log
@New counter for not joined IPv4 multicast groups.
Don't count link local scope multicast as not forwardable.
This stops ips_cantforward growing on carp(4) networks.
tested and ok mcbride@@, ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.130 2005/07/31 03:30:55 pascoe Exp $	*/
d229 1
a229 1
		DP_SET(baddynamicports.udp, defbaddynamicports_tcp[i]);
@


1.131.2.1
log
@MFC:
Fix by mpf@@

m_pullup the same amount we copied, not just the IP header.
Any pf(4) translation that modifies more than IP addresses,
was happening on the shared mbuf cluster. Thus we were
sending icmp errors with corrupted payload.

ok mpf@@ markus@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.131 2005/08/11 12:55:31 mpf Exp $	*/
d1451 1
a1451 1
	mcopy = m_copym(m, 0, min(ntohs(ip->ip_len), 68), M_DONTWAIT);
d1453 1
a1453 1
		mcopy = m_pullup(mcopy, min(ntohs(ip->ip_len), 68));
@


1.130
log
@Change the API for icmp_do_error so that it takes the mtu directly, rather
than a pointer to struct ifnet containing it.

Saves a 448 byte stack allocation in ip_forward which previously faked up
a struct ifnet just for this purpose.

idea ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.129 2005/06/15 07:24:05 markus Exp $	*/
d449 3
a451 1
			ipstat.ips_cantforward++;
@


1.129
log
@remove from "attempted source route ..." message; ok deraadt, mpf, henning, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.128 2005/06/10 15:56:01 markus Exp $	*/
d1405 1
a1405 1
	int error, type = 0, code = 0;
a1407 4
	struct ifnet *destifp;
#ifdef IPSEC
	struct ifnet dummyifp;
#endif
a1503 1
	destifp = NULL;
d1527 5
a1531 10
			destifp = ipforward_rt.ro_rt->rt_ifp;
			/*
			 * XXX BUG ALERT
			 * The "dummyifp" code relies upon the fact
			 * that icmp_error() touches only ifp->if_mtu.
			 */
			if (rt->rt_rmx.rmx_mtu) {
				dummyifp.if_mtu = rt->rt_rmx.rmx_mtu;
				destifp = &dummyifp;
			}
d1555 1
a1555 1
	icmp_error(mcopy, type, code, dest, destifp);
@


1.128
log
@make sure the IP packet contains a full struct ip_timestamp
from art; ok deraadt, claudio, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.127 2005/05/24 04:20:25 markus Exp $	*/
a1024 7
				char buf[4*sizeof "123"];

				strlcpy(buf, inet_ntoa(ip->ip_dst),
				    sizeof buf);
				log(LOG_WARNING,
				    "attempted source route from %s to %s\n",
				    inet_ntoa(ip->ip_src), buf);
@


1.127
log
@add net.inet.ip.ifq for monitoring and changing ifqueue; similar to netbsd
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.126 2005/04/25 17:55:51 brad Exp $	*/
d1125 2
@


1.126
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.125 2005/01/20 15:00:13 markus Exp $	*/
d1584 2
a1585 2
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
d1631 3
@


1.125
log
@expire ipforward_rt cache in ip_slowtimeo; fixes pr 1697; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.124 2004/10/18 07:41:28 otto Exp $	*/
d323 2
a324 2
	if ((m->m_pkthdr.csum & M_IPV4_CSUM_IN_OK) == 0) {
		if (m->m_pkthdr.csum & M_IPV4_CSUM_IN_BAD) {
d335 1
a335 1
		m->m_pkthdr.csum &= ~M_IPV4_CSUM_IN_OK;
@


1.125.2.1
log
@MFC:
Fix by markus@@

make sure the IP packet contains a full struct ip_timestamp
from art

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.125 2005/01/20 15:00:13 markus Exp $	*/
a1124 2
			if (optlen < sizeof(struct ip_timestamp))
				goto bad;
@


1.125.2.2
log
@MFC:
Fix by mpf@@

m_pullup the same amount we copied, not just the IP header.
Any pf(4) translation that modifies more than IP addresses,
was happening on the shared mbuf cluster. Thus we were
sending icmp errors with corrupted payload.

ok mpf@@ markus@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.125.2.1 2005/06/14 02:10:33 brad Exp $	*/
d1460 1
a1460 1
	mcopy = m_copym(m, 0, min(ntohs(ip->ip_len), 68), M_DONTWAIT);
d1462 1
a1462 1
		mcopy = m_pullup(mcopy, min(ntohs(ip->ip_len), 68));
@


1.124
log
@Do not embed an ip header with a decremented ttl into an icmp message.
Wait with the decrement until after the copy is done. Resolves checksum
mismatches on the embedded header, as reported by tcpdump.

ok markus@@ itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.123 2004/09/23 17:38:10 brad Exp $	*/
d911 2
a912 2
 * if a timer expires on a reassembly
 * queue, discard it.
d929 4
@


1.123
log
@remove some more compile time overrides, use the sysctl's.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.122 2004/07/31 21:27:31 brad Exp $	*/
a1428 1
	ip->ip_ttl -= IPTTLDEC;
d1457 2
@


1.122
log
@remove GATEWAY and IPFORWARDING option knobs, use the sysctl.

ok mcbride@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.121 2004/06/22 07:35:20 cedric Exp $	*/
a66 8
#ifndef	IPSENDREDIRECTS
#define	IPSENDREDIRECTS	1
#endif

#ifndef IPMTUDISC
#define IPMTUDISC	1
#endif
#ifndef IPMTUDISCTIMEOUT
a67 1
#endif
d87 4
a90 14
/*
 * Note: DIRECTED_BROADCAST is handled this way so that previous
 * configuration using this option will Just Work.
 */
#ifndef IPDIRECTEDBCAST
#ifdef DIRECTED_BROADCAST
#define IPDIRECTEDBCAST	1
#else
#define	IPDIRECTEDBCAST	0
#endif /* DIRECTED_BROADCAST */
#endif /* IPDIRECTEDBCAST */
int	ipforwarding = 0;	/* no forwarding unless sysctl'd to enable */
int	ipsendredirects = IPSENDREDIRECTS;
int	ip_dosourceroute = 0;	/* no src-routing unless sysctl'd to enable */
d92 1
a92 1
int	ip_mtudisc = IPMTUDISC;
d94 1
a94 1
int	ip_directedbcast = IPDIRECTEDBCAST;
@


1.122.2.1
log
@MFC:
Fix by markus@@

make sure the IP packet contains a full struct ip_timestamp
from art

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.122 2004/07/31 21:27:31 brad Exp $	*/
a1139 2
			if (optlen < sizeof(struct ip_timestamp))
				goto bad;
@


1.121
log
@Pull the plug on source-based routing until remaining bugs are eradicated.
No need to reconfig kernel or rebuild userland stuff.
requested deraadt@@, help beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.120 2004/06/21 19:26:01 mcbride Exp $	*/
a66 7
#ifndef	IPFORWARDING
#ifdef GATEWAY
#define	IPFORWARDING	1	/* forward IP packets not for us */
#else /* GATEWAY */
#define	IPFORWARDING	0	/* don't forward IP packets not for us */
#endif /* GATEWAY */
#endif /* IPFORWARDING */
d107 1
a107 1
int	ipforwarding = IPFORWARDING;
@


1.120
log
@Get rid of pf_test_eh() wrapper.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.119 2004/06/06 16:49:09 cedric Exp $	*/
d1096 1
a1096 1
				ia = ip_rtaddr(ipaddr.sin_addr, ip->ip_src);
d1135 1
a1135 2
			    (ia = ip_rtaddr(ipaddr.sin_addr, ip->ip_src)) == 0)
			{
d1214 2
a1215 1
ip_rtaddr(struct in_addr dst, struct in_addr src)
d1217 1
a1217 1
	struct sockaddr_rtin *rtin;
d1219 1
a1219 1
	rtin = satortin(&ipforward_rt.ro_dst);
d1221 1
a1221 2
	if (ipforward_rt.ro_rt == 0 || dst.s_addr != rtin->rtin_dst.s_addr ||
	    src.s_addr != rtin->rtin_src.s_addr) {
d1226 3
a1228 4
		rtin->rtin_family = AF_INET;
		rtin->rtin_len = sizeof(*rtin);
		rtin->rtin_dst = dst;
		rtin->rtin_src = src;
a1275 1
	sin.sin_srcaddr.s_addr = 0;
d1430 1
a1430 1
	struct sockaddr_rtin *rtin;
d1457 1
a1457 1
	rtin = satortin(&ipforward_rt.ro_dst);
d1459 1
a1459 2
	    ip->ip_dst.s_addr != rtin->rtin_dst.s_addr ||
	    ip->ip_src.s_addr != rtin->rtin_src.s_addr) {
d1464 3
a1466 4
		rtin->rtin_family = AF_INET;
		rtin->rtin_len = sizeof(*rtin);
		rtin->rtin_dst = ip->ip_dst;
		rtin->rtin_src = ip->ip_src;
@


1.119
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.118 2004/03/15 09:45:31 tedu Exp $	*/
d399 1
a399 1
	if (pf_test(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
@


1.118
log
@strncpy -> strlcpy.  ok markus@@ "(this is even unused crap, i think)"
from Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.117 2004/02/15 11:16:08 markus Exp $	*/
d1096 1
a1096 1
				ia = ip_rtaddr(ipaddr.sin_addr);
d1135 2
a1136 1
			    (ia = ip_rtaddr(ipaddr.sin_addr)) == 0) {
d1215 1
a1215 2
ip_rtaddr(dst)
	 struct in_addr dst;
d1217 1
a1217 1
	struct sockaddr_in *sin;
d1219 1
a1219 1
	sin = satosin(&ipforward_rt.ro_dst);
d1221 2
a1222 1
	if (ipforward_rt.ro_rt == 0 || dst.s_addr != sin->sin_addr.s_addr) {
d1227 4
a1230 3
		sin->sin_family = AF_INET;
		sin->sin_len = sizeof(*sin);
		sin->sin_addr = dst;
d1278 1
d1433 1
a1433 1
	struct sockaddr_in *sin;
d1460 1
a1460 1
	sin = satosin(&ipforward_rt.ro_dst);
d1462 2
a1463 1
	    ip->ip_dst.s_addr != sin->sin_addr.s_addr) {
d1468 4
a1471 3
		sin->sin_family = AF_INET;
		sin->sin_len = sizeof(*sin);
		sin->sin_addr = ip->ip_dst;
@


1.117
log
@switch to sysctl_int_arr(); ok itojun, henning, miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.116 2004/02/13 01:29:46 brad Exp $	*/
d257 3
a259 3
	strncpy(ipsec_def_enc, IPSEC_DEFAULT_DEF_ENC, sizeof(ipsec_def_enc));
	strncpy(ipsec_def_auth, IPSEC_DEFAULT_DEF_AUTH, sizeof(ipsec_def_auth));
	strncpy(ipsec_def_comp, IPSEC_DEFAULT_DEF_COMP, sizeof(ipsec_def_comp));
@


1.116
log
@typo, lenght -> length
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.115 2003/12/10 07:22:43 itojun Exp $	*/
d143 2
a1609 7
	case IPCTL_FORWARDING:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ipforwarding));
	case IPCTL_SENDREDIRECTS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			&ipsendredirects));
	case IPCTL_DEFTTL:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_defttl));
a1621 3
	case IPCTL_DIRECTEDBCAST:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ip_directedbcast));
a1640 47
	case IPCTL_IPPORT_FIRSTAUTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ipport_firstauto));
	case IPCTL_IPPORT_LASTAUTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ipport_lastauto));
	case IPCTL_IPPORT_HIFIRSTAUTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ipport_hifirstauto));
	case IPCTL_IPPORT_HILASTAUTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ipport_hilastauto));
	case IPCTL_IPPORT_MAXQUEUE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ip_maxqueue));
	case IPCTL_ENCDEBUG:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &encdebug));
	case IPCTL_IPSEC_EMBRYONIC_SA_TIMEOUT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_keep_invalid));
	case IPCTL_IPSEC_REQUIRE_PFS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_require_pfs));
	case IPCTL_IPSEC_SOFT_ALLOCATIONS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_soft_allocations));
	case IPCTL_IPSEC_ALLOCATIONS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_exp_allocations));
	case IPCTL_IPSEC_SOFT_BYTES:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_soft_bytes));
	case IPCTL_IPSEC_BYTES:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_exp_bytes));
	case IPCTL_IPSEC_TIMEOUT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_exp_timeout));
	case IPCTL_IPSEC_SOFT_TIMEOUT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_soft_timeout));
	case IPCTL_IPSEC_SOFT_FIRSTUSE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_soft_first_use));
	case IPCTL_IPSEC_FIRSTUSE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_exp_first_use));
a1647 3
	case IPCTL_IPSEC_EXPIRE_ACQUIRE:
	        return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_expire_acquire));
d1653 3
@


1.115
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.114 2003/07/29 03:21:57 itojun Exp $	*/
d363 1
a363 1
	/* Retrieve the packet lenght. */
@


1.114
log
@fixup ip_len back to wire format after reass.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.113 2003/07/09 22:03:16 itojun Exp $	*/
d223 2
a224 2
	register struct protosw *pr;
	register int i;
d295 2
a296 2
	register struct ip *ip;
	register struct ipq *fp;
d692 1
a692 1
	register struct mbuf *m;
d694 1
a694 1
	register struct in_ifaddr *ia;
d920 1
a920 1
	register struct ipqent *q, *p;
d941 1
a941 1
	register struct ipq *fp, *nfp;
d998 2
a999 2
	register struct ip *ip = mtod(m, struct ip *);
	register u_char *cp;
d1001 1
a1001 1
	register struct in_ifaddr *ia;
d1215 1
a1215 1
	register struct sockaddr_in *sin;
d1266 3
a1268 3
	register struct rtentry *rt;
	register struct ifnet *ifp;
	register struct ifaddr *ifa;
d1311 2
a1312 2
	register struct in_addr *p, *q;
	register struct mbuf *m;
d1381 1
a1381 1
	register struct mbuf *m;
d1384 1
a1384 1
	register int i;
d1386 1
a1386 1
	register caddr_t opts;
d1427 3
a1429 3
	register struct ip *ip = mtod(m, struct ip *);
	register struct sockaddr_in *sin;
	register struct rtentry *rt;
@


1.113
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.112 2003/06/02 23:28:14 millert Exp $	*/
d607 1
@


1.112
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.111 2003/05/03 21:16:30 deraadt Exp $	*/
d299 1
a299 1
	int hlen, mff;
d363 3
d369 1
a369 2
	NTOHS(ip->ip_len);
	if (ip->ip_len < hlen) {
a372 1
	NTOHS(ip->ip_off);
d380 1
a380 1
	if (m->m_pkthdr.len < ip->ip_len) {
d384 1
a384 1
	if (m->m_pkthdr.len > ip->ip_len) {
d386 2
a387 2
			m->m_len = ip->ip_len;
			m->m_pkthdr.len = ip->ip_len;
d389 1
a389 1
			m_adj(m, ip->ip_len - m->m_pkthdr.len);
d531 1
a531 1
	if (ip->ip_off &~ (IP_DF | IP_RF)) {
d559 2
a560 2
		ip->ip_len -= hlen;
		mff = (ip->ip_off & IP_MF) != 0;
d566 2
a567 1
			if (ip->ip_len == 0 || (ip->ip_len & 0x7) != 0) {
d573 1
a573 1
		ip->ip_off <<= 3;
d611 1
a611 2
	} else
		ip->ip_len -= hlen;
d789 1
a789 1
		if (q->ipqe_ip->ip_off > ipqe->ipqe_ip->ip_off)
d798 2
a799 2
		i = p->ipqe_ip->ip_off + p->ipqe_ip->ip_len -
		    ipqe->ipqe_ip->ip_off;
d801 1
a801 1
			if (i >= ipqe->ipqe_ip->ip_len)
d804 4
a807 2
			ipqe->ipqe_ip->ip_off += i;
			ipqe->ipqe_ip->ip_len -= i;
d815 10
a824 7
	for (; q != NULL && ipqe->ipqe_ip->ip_off + ipqe->ipqe_ip->ip_len >
	    q->ipqe_ip->ip_off; q = nq) {
		i = (ipqe->ipqe_ip->ip_off + ipqe->ipqe_ip->ip_len) -
		    q->ipqe_ip->ip_off;
		if (i < q->ipqe_ip->ip_len) {
			q->ipqe_ip->ip_len -= i;
			q->ipqe_ip->ip_off += i;
d848 1
a848 1
		if (q->ipqe_ip->ip_off != next)
d850 1
a850 1
		next += q->ipqe_ip->ip_len;
d887 1
a887 1
	ip->ip_len = next;
a1200 1
	ip->ip_len -= ip->ip_hl << 2;   /* XXX icmp_error adds in hdr length */
d1478 1
a1478 1
	mcopy = m_copym(m, 0, imin((int)ip->ip_len, 68), M_DONTWAIT);
@


1.111
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.110 2003/02/12 14:41:07 jason Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.110
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.109 2003/02/11 21:08:04 cedric Exp $	*/
d196 2
a197 1
	sprintf(buf, "%d.%d.%d.%d", ucp[0] & 0xff, ucp[1] & 0xff,
d1044 2
a1045 1
				strcpy(buf, inet_ntoa(ip->ip_dst));
@


1.109
log
@No ICMP redirect when PF nat code redirect the packet on the LAN.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.108 2003/01/07 09:00:34 kjc Exp $	*/
d88 2
@


1.108
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.107 2002/09/04 19:04:38 dhartmei Exp $	*/
d301 1
d396 1
d404 1
d519 1
a519 1
		ip_forward(m, 0);
@


1.107
log
@Ghosts from the past (fixed 1.65, reverted 1.66) rediscovered by
Henric Jungheim. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.106 2002/08/28 15:43:03 pefo Exp $	*/
a401 6
#endif

#ifdef ALTQ
	if (altq_input != NULL && (*altq_input)(m, AF_INET) == 0)
		/* packet is dropped by traffic conditioner */
		return;
@


1.106
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.105 2002/07/03 21:19:08 miod Exp $	*/
a1274 2

	RTFREE(rt);
@


1.105
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.104 2002/06/09 16:26:10 itojun Exp $	*/
d1516 1
a1516 1
	    0, NULL, NULL);
@


1.104
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.103 2002/06/07 23:50:10 jasoni Exp $	*/
d157 2
@


1.103
log
@use TAILQ_FOREACH macro; ok angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.102 2002/05/16 14:10:51 kjc Exp $	*/
d244 1
a244 1
		ip_mtudisc_timeout_q = 
d588 1
a588 1
			    
d657 1
a657 1
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL); 
d1273 1
a1273 1
	
d1275 1
a1275 1
	
d1288 1
a1288 1
			if (!bcmp(LLADDR((struct sockaddr_dl *)ifa->ifa_addr), 
d1513 1
a1513 1
	    (IP_FORWARDING | (ip_directedbcast ? IP_ALLOWBROADCAST : 0)), 
d1631 1
a1631 1
			ip_mtudisc_timeout_q = 
d1643 1
a1643 1
			rt_timer_queue_change(ip_mtudisc_timeout_q, 
d1705 1
a1705 1
				       ipsec_def_comp, 
@


1.102
log
@bring in ECN support from KAME.
it consists of
 - ECN support in TCP
 - tunnel-egress and fragment reassembly rules in layer-3 not to lose
   congestion info at tunnel-egress and fragment reassembly

to enable ECN in TCP, build a kernel with TCP_ECN, and then,
turn it on by "sysctl -w net.inet.tcp.ecn=1".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.101 2002/04/24 01:05:12 angelos Exp $	*/
d696 1
a696 1
	for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
@


1.101
log
@Update IPsec-related comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.100 2002/03/14 01:27:11 millert Exp $	*/
d741 1
d768 16
@


1.100
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.99 2002/02/22 02:49:06 itojun Exp $	*/
d492 4
a495 1
	        /* IPsec policy check for forwarded packets */
d514 4
a517 1
		/* Fall through, forward packet */
d620 2
a621 1
         * some flexibility in handling of nested tunnels etc.
d646 11
a656 1
	/* IPsec policy check for local-delivery packets */
d668 1
a668 1
	/* Error or otherwise drop-packet indication */
@


1.99
log
@do not transmit ICMP source quench.  from kjc/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.98 2002/01/25 15:50:23 art Exp $	*/
d153 2
a154 2
static __inline int ipq_lock_try __P((void));
static __inline void ipq_unlock __P((void));
d212 1
a212 1
static void save_rte __P((u_char *, struct in_addr));
@


1.98
log
@Add a drain hook to each pool. This hook is called in three cases.
1. When a pool hit the hard limit. Just before bailing out/sleeping.
2. When an allocator fails to allocate memory (with PR_NOWAIT).
3. Just before trying to reclaim some page in pool_reclaim.

The function called form the hook should try to free some items to the
pool if possible.

Convert m_reclaim hooks that were embedded in MCLGET, MGET and MGETHDR
into a pool drain hook (making the code much cleaner).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.97 2002/01/23 00:39:48 art Exp $	*/
d1535 11
d1549 1
@


1.97
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.96 2001/12/10 12:05:40 ho Exp $	*/
d265 1
a265 1
	register struct mbuf *m;
a267 3
	if (needqueuedrain)
		m_reclaim();
	
@


1.96
log
@No need to m_freem(m) if m is already NULL. dhartmei@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.95 2001/12/06 02:12:52 itojun Exp $	*/
d228 1
a228 1
	    0, NULL, NULL, M_IPQ);
@


1.96.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.98 2002/01/25 15:50:23 art Exp $	*/
d228 1
a228 1
	    NULL);
d265 1
a265 1
	struct mbuf *m;
d268 3
@


1.96.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.96.2.1 2002/01/31 22:55:45 niklas Exp $	*/
d153 2
a154 2
static __inline int ipq_lock_try(void);
static __inline void ipq_unlock(void);
d212 1
a212 1
static void save_rte(u_char *, struct in_addr);
d492 1
a492 4
	        /*
		 * IPsec policy check for forwarded packets. Look at
		 * inner-most IPsec SA used.
		 */
d511 1
a511 4
		/*
		 * Fall through, forward packet. Outbound IPsec policy
		 * checking will occur in ip_output().
		 */
d614 1
a614 2
         * some flexibility in handling nested tunnels (in setting up
	 * the policies).
d639 1
a639 11
	/*
	 * IPsec policy check for local-delivery packets. Look at the
	 * inner-most SA that protected the packet. This is in fact
	 * a bit too restrictive (it could end up causing packets to
	 * be dropped that semantically follow the policy, e.g., in
	 * certain SA-bundle configurations); but the alternative is
	 * very complicated (and requires keeping track of what
	 * kinds of tunneling headers have been seen in-between the
	 * IPsec headers), and I don't think we lose much functionality
	 * that's needed in the real world (who uses bundles anyway ?).
	 */
d651 1
a651 1
	/* Error or otherwise drop-packet indication. */
d679 1
a679 1
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
a723 1
	u_int8_t ecn, ecn0;
a751 16
	 * Handle ECN by comparing this segment with the first one;
	 * if CE is set, do not lose CE.
	 * drop if CE and not-ECT are mixed for the same packet.
	 */
	ecn = ipqe->ipqe_ip->ip_tos & IPTOS_ECN_MASK;
	ecn0 = fp->ipq_fragq.lh_first->ipqe_ip->ip_tos & IPTOS_ECN_MASK;
	if (ecn == IPTOS_ECN_CE) {
		if (ecn0 == IPTOS_ECN_NOTECT)
			goto dropfrag;
		if (ecn0 != IPTOS_ECN_CE)
			fp->ipq_fragq.lh_first->ipqe_ip->ip_tos |= IPTOS_ECN_CE;
	}
	if (ecn == IPTOS_ECN_NOTECT && ecn0 != IPTOS_ECN_NOTECT)
		goto dropfrag;

	/*
a1534 11
#if 1
		/*
		 * a router should not generate ICMP_SOURCEQUENCH as
		 * required in RFC1812 Requirements for IP Version 4 Routers.
		 * source quench could be a big problem under DoS attacks,
		 * or the underlying interface is rate-limited.
		 */
		if (mcopy)
			m_freem(mcopy);
		return;
#else
a1537 1
#endif
@


1.96.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.96.2.2 2002/06/11 03:31:36 art Exp $	*/
a157 2
struct ipstat ipstat;

d244 1
a244 1
		ip_mtudisc_timeout_q =
d588 1
a588 1

d657 1
a657 1
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
d1273 3
a1275 1

d1288 1
a1288 1
			if (!bcmp(LLADDR((struct sockaddr_dl *)ifa->ifa_addr),
d1513 2
a1514 2
	    (IP_FORWARDING | (ip_directedbcast ? IP_ALLOWBROADCAST : 0)),
	    0, (void *)NULL, (void *)NULL);
d1631 1
a1631 1
			ip_mtudisc_timeout_q =
d1643 1
a1643 1
			rt_timer_queue_change(ip_mtudisc_timeout_q,
d1705 1
a1705 1
				       ipsec_def_comp,
@


1.96.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a88 2
struct ipqhead ipq;

d194 1
a194 2
	snprintf(buf, sizeof buf, "%d.%d.%d.%d",
	    ucp[0] & 0xff, ucp[1] & 0xff,
a300 1
	in_addr_t pfrdr = 0;
a394 1
	pfrdr = ip->ip_dst.s_addr;
d402 6
a407 1
	pfrdr = (pfrdr != ip->ip_dst.s_addr);
d522 1
a522 1
		ip_forward(m, pfrdr);
d1044 1
a1044 2
				strlcpy(buf, inet_ntoa(ip->ip_dst),
				    sizeof buf);
@


1.95
log
@remove #if 0'ed portion (for KAME IPSEC - not needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.94 2001/11/26 16:50:26 jasoni Exp $	*/
d399 1
a399 1
		goto bad;
@


1.94
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.93 2001/09/18 15:24:32 aaron Exp $	*/
a1480 3
#if 0 /*KAME IPSEC*/
	m->m_pkthdr.rcvif = NULL;
#endif /*IPSEC*/
@


1.93
log
@Avoid memory leak when disabling PMTU, rt_timer_queue_destroy() expects the
caller to free the structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.92 2001/07/17 20:34:50 provos Exp $	*/
d397 2
@


1.92
log
@split ip normalization out into a separate file, okay dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.91 2001/07/16 22:11:04 fgsch Exp $	*/
d1593 1
@


1.91
log
@Move altq after pf; suggested by aaron@@, kjc@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.90 2001/07/05 16:45:54 jjbg Exp $	*/
a53 4
#if NPF > 0
#include <net/pfvar.h>
#endif

d62 4
@


1.90
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.89 2001/06/28 21:53:42 provos Exp $	*/
a363 6
#ifdef ALTQ
	if (altq_input != NULL && (*altq_input)(m, AF_INET) == 0)
		/* packet is dropped by traffic conditioner */
		return;
#endif

d392 1
d396 6
a401 4
#if NPF > 0
	{
		if (pf_test(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
			goto bad;
d403 4
a406 3
		ip = mtod(m, struct ip *);
		hlen = ip->ip_hl << 2;
	}
d408 1
@


1.89
log
@first stab at packet normalization.  includes full ip reassembly.
okay dhartmei@@, dugsong@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.88 2001/06/27 05:50:07 kjc Exp $	*/
d67 4
d103 1
d132 1
d256 1
d618 2
a619 1
        if ((ip->ip_p == IPPROTO_ESP) || (ip->ip_p == IPPROTO_AH))
d1661 4
@


1.88
log
@ALTQ base modifications to the kernel.
 - ALTQ introduces a set of new queue macros that coexist with the
   traditional IF_XXX macros.
 - "struct ifaltq" replaces "struct ifqueue" in "struct ifnet".
 - assign cdev major 74 for i386 and 54 for alpha as ALTQ control interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.87 2001/06/26 18:17:54 deraadt Exp $	*/
d395 7
a401 2
	if (pf_test(PF_IN, m->m_pkthdr.rcvif, m) != PF_PASS)
		goto bad;
@


1.87
log
@no longer pass around **m
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.86 2001/06/25 08:05:24 art Exp $	*/
d356 6
@


1.86
log
@Build without IPSEC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.85 2001/06/24 23:42:40 mickey Exp $	*/
d389 2
a390 6
	{
		struct mbuf *m1 = m;
		if (pf_test(PF_IN, m->m_pkthdr.rcvif, &m1) != PF_PASS)
			goto bad;
		ip = mtod(m = m1, struct ip *);
	}
@


1.85
log
@make it compile w/o pf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.84 2001/06/24 19:48:58 kjell Exp $	*/
d1384 1
d1386 1
@


1.84
log
@Initial import of pf, an all-new ipf-compatable packet filter.
Insane amounts of work done my dhartmei. Great work!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.83 2001/06/24 18:24:56 provos Exp $	*/
d39 2
d53 2
d56 1
d388 1
d395 1
a395 1

@


1.83
log
@take mtu from routing table
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.82 2001/06/23 18:54:44 angelos Exp $	*/
d51 1
d378 10
@


1.82
log
@Clear the checksum flags after verification. Also, don't count
checksum errors as hardware checksum packets as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.81 2001/06/23 18:45:29 angelos Exp $	*/
a1366 1
#if 0 /*KAME IPSEC*/
a1367 1
#endif
d1486 4
a1489 2
#if 1 /*KAME IPSEC*/
		if (ipforward_rt.ro_rt)
d1491 8
a1498 45
#else
		/*
		 * If the packet is routed over IPsec tunnel, tell the
		 * originator the tunnel MTU.
		 *	tunnel MTU = if MTU - sizeof(IP) - ESP/AH hdrsiz
		 * XXX quickhack!!!
		 */
		if (ipforward_rt.ro_rt) {
			struct secpolicy *sp;
			int ipsecerror;
			int ipsechdr;
			struct route *ro;

			sp = ipsec4_getpolicybyaddr(mcopy,
						    IP_FORWARDING,
						    &ipsecerror);

			if (sp == NULL)
				destifp = ipforward_rt.ro_rt->rt_ifp;
			else {
				/* count IPsec header size */
				ipsechdr = ipsec4_hdrsiz(mcopy, NULL);

				/*
				 * find the correct route for outer IPv4
				 * header, compute tunnel MTU.
				 *
				 * XXX BUG ALERT
				 * The "dummyifp" code relies upon the fact
				 * that icmp_error() touches only ifp->if_mtu.
				 */
				/*XXX*/
				destifp = NULL;
				if (sp->req != NULL
				 && sp->req->sa != NULL) {
					ro = &sp->req->sa->saidx->sa_route;
					if (ro->ro_rt && ro->ro_rt->rt_ifp) {
						dummyifp.if_mtu =
						    ro->ro_rt->rt_ifp->if_mtu;
						dummyifp.if_mtu -= ipsechdr;
						destifp = &dummyifp;
					}
				}

				key_freesp(sp);
@


1.81
log
@Count input packets hardware-checksummed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.80 2001/06/23 16:15:56 fgsch Exp $	*/
d336 2
a337 2
		if (m->m_pkthdr.csum & M_IPV4_CSUM_IN_BAD ||
		    in_cksum(m, hlen) != 0) {
a338 1
			ipstat.ips_inhwcsum++;
d342 5
a346 1
		ipstat.ips_inhwcsum++;
a347 1
	} else
d349 1
@


1.80
log
@Remove unneeded ip_id convertions.
Instead of using HTONS macro in some places, use htons directly in the
struct member and save us a few bytes.
Fix comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.79 2001/06/23 05:55:40 angelos Exp $	*/
d345 2
a346 1
	}
@


1.79
log
@Count input/output hardware-checksummed IP packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.78 2001/06/23 03:39:03 angelos Exp $	*/
a354 1
	NTOHS(ip->ip_id);
a418 1
			ip->ip_id = htons(ip->ip_id);
a423 1
			ip->ip_id = ntohs(ip->ip_id);
a1128 1
	HTONS(ip->ip_id);
a1377 1
	HTONS(ip->ip_id);
@


1.78
log
@Clear IPv4 input checksum OK flag after verification.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.77 2001/06/23 02:27:09 angelos Exp $	*/
d339 1
d343 1
@


1.77
log
@TCP, UDP, IPv4 input hardware checksumming processing; also IPv4
output hardware checksumming. Not tested yet, but should be done
tonight.

Remain to be solved: interactions with bridge, TCP/UDP output
checksumming, interactions of TCP/UDP checksumming with routing
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.76 2001/06/19 00:48:23 deraadt Exp $	*/
d341 2
@


1.76
log
@mop up after angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.75 2001/06/08 03:53:46 angelos Exp $	*/
d335 6
a340 3
	if (in_cksum(m, hlen) != 0) {
		ipstat.ips_badsum++;
		goto bad;
@


1.75
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.74 2001/06/01 19:53:33 provos Exp $	*/
d40 1
@


1.74
log
@use pool allocation for ip fragement queue, from netbsd,
okay angelos@@, itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.73 2001/05/30 02:12:31 deraadt Exp $	*/
a39 2
#include <sys/systm.h>
#include <sys/malloc.h>
a43 3
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
a44 4
#include <sys/proc.h>
#include <sys/pool.h>

#include <vm/vm.h>
a58 5
#include <netinet/ip_ipsp.h>

#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#endif /* IPSEC */
@


1.73
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.72 2001/05/27 00:39:26 angelos Exp $	*/
d51 1
d157 2
d228 3
d559 1
a559 2
			MALLOC(ipqe, struct ipqent *, sizeof (struct ipqent),
			    M_IPQ, M_NOWAIT);
d768 1
a768 1
		FREE(q, M_IPQ);
d808 1
a808 1
	FREE(q, M_IPQ);
d813 1
a813 1
		FREE(q, M_IPQ);
d843 1
a843 1
	FREE(ipqe, M_IPQ);
d862 1
a862 1
		FREE(q, M_IPQ);
@


1.72
log
@Use the new IPsec tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.71 2001/05/20 19:19:57 fgsch Exp $	*/
a150 4
#if defined(IPFILTER) || defined(IPFILTER_LKM)
int	(*fr_checkp) __P((struct ip *, int, struct ifnet *, int,
			  struct mbuf **));
#endif
a374 17

#if defined(IPFILTER) || defined(IPFILTER_LKM)
	 /*
	 * Check if we want to allow this packet to be processed.
	 * Consider it to be bad if not.
	 */
	{
		struct mbuf *m0 = m;
		if (fr_checkp && (*fr_checkp)(ip, hlen, m->m_pkthdr.rcvif, 0, &m0)) {
			return;
		}
		if (m0 == 0) {  /* in case of 'fastroute' */
			return;
		}
		ip = mtod(m = m0, struct ip *);
	}
#endif
@


1.71
log
@Remove varargs from ipv4_input; cmetz@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.70 2001/05/20 08:35:11 angelos Exp $	*/
d484 1
a484 1
		mtag = m_tag_find(m, PACKET_TAG_IPSEC_DONE, NULL);
d631 1
a631 1
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_DONE, NULL); 
@


1.70
log
@Use packet tags instead of tdbi.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.69 2001/05/16 06:38:25 fgsch Exp $	*/
d283 1
a283 1
		ipv4_input(m, 0, NULL, 0);
d292 2
a293 1
ipv4_input(struct mbuf *m, ...)
a299 2
	va_list ap;
	int extra;
a305 18

	va_start(ap, m);
	extra = va_arg(ap, int);
	va_end(ap);

	if (extra) {
		struct mbuf *newpacket;

		if (!(newpacket = m_split(m, extra, M_NOWAIT))) {
			m_freem(m);
			return;
		}

		newpacket->m_flags |= m->m_flags;
		m_freem(m);
		m = newpacket;
		extra = 0;
	}
@


1.69
log
@Don't clobber ip_sum; ip_output always sets this to 0 before calling
in_cksum so it's not needed here; itojun@@ ok.
This makes the ip_sum available in ipfilter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.68 2001/05/11 17:20:11 aaron Exp $	*/
d305 1
d503 1
d505 5
a509 6
		tdbi = (struct tdb_ident *) m->m_pkthdr.tdbi;
                if (tdbi == NULL)
                  tdb = NULL;
                else
                  tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);

d511 1
a511 1
		  	        IPSP_DIRECTION_IN, tdb, NULL);
d650 1
d652 2
a653 4
	tdbi = (struct tdb_ident *) m->m_pkthdr.tdbi;
        if (tdbi == NULL)
                tdb = NULL;
        else
d655 2
a656 1

d658 1
a658 1
			tdb, NULL);
@


1.68
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.67 2001/05/01 09:55:49 provos Exp $	*/
d364 1
a364 1
	if ((ip->ip_sum = in_cksum(m, hlen)) != 0) {
@


1.67
log
@get rid of dtom(), okay itojun@@ angelos@@ mickey@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.66 2001/03/28 20:03:03 angelos Exp $	*/
d333 1
a333 1
	    (m = m_pullup(m, sizeof (struct ip))) == 0) {
d348 1
a348 1
		if ((m = m_pullup(m, hlen)) == 0) {
d439 1
a439 1
			if ((m = m_pullup(m, hlen)) == 0) {
d537 1
a537 1
			if ((m = m_pullup(m, hlen)) == 0) {
@


1.66
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.65 2001/03/25 05:51:31 csapuntz Exp $	*/
d601 1
d603 2
a604 2
			ip = ip_reass(ipqe, fp);
			if (ip == 0) {
d609 1
a609 1
			m = dtom(ip);
d722 1
a722 1
struct ip *
d724 2
a725 2
	register struct ipqent *ipqe;
	register struct ipq *fp;
d727 2
a728 2
	register struct mbuf *m = dtom(ipqe->ipqe_ip);
	register struct ipqent *nq, *p, *q;
d745 3
a747 1
		if ((t = m_get(M_DONTWAIT, MT_FTABLE)) == NULL)
a748 1
		fp = mtod(t, struct ipq *);
d779 1
a779 1
			m_adj(dtom(ipqe->ipqe_ip), i);
d796 1
a796 1
			m_adj(dtom(q->ipqe_ip), i);
d800 1
a800 1
		m_freem(dtom(q->ipqe_ip));
d837 1
a837 1
	m = dtom(q->ipqe_ip);
d845 1
a845 1
		t = dtom(q->ipqe_ip);
d862 1
a862 1
	(void) m_free(dtom(fp));
d867 4
a870 4
		register int plen = 0;
		for (t = m; m; m = m->m_next)
			plen += m->m_len;
		t->m_pkthdr.len = plen;
d872 1
a872 1
	return (ip);
d894 1
a894 1
		m_freem(dtom(q->ipqe_ip));
d900 1
a900 1
	(void) m_free(dtom(fp));
@


1.65
log
@A couple minor fixes to prevent use after free. Thanks to dawson and team for finding these. Ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.64 2001/03/18 07:09:49 provos Exp $	*/
a83 2
#define PI_MAGIC 0xdeadbeef  /* XXX the horror! */

a310 6
#ifdef IPSEC
	tdbi = (struct tdb_ident *) m->m_pkthdr.tdbi;
	if (tdbi == (void *) PI_MAGIC)
	        tdbi = NULL;
#endif /* IPSEC */

a313 7
#ifdef IPSEC
		if (tdbi) {
		        free(tdbi, M_TEMP);
			tdbi = NULL;
		}
#endif /* IPSEC */

a334 4
#ifdef IPSEC
		if (tdbi)
		        free(tdbi, M_TEMP);
#endif /* IPSEC */
a349 4
#ifdef IPSEC
			if (tdbi)
			        free(tdbi, M_TEMP);
#endif /* IPSEC */
a405 4
#ifdef IPSEC
			if (tdbi)
			        free(tdbi, M_TEMP);
#endif /* IPSEC */
a408 4
#ifdef IPSEC
			if (tdbi)
				free (tdbi, M_TEMP);
#endif /* IPSEC */
a422 4
#ifdef IPSEC
	        if (tdbi)
		        free(tdbi, M_TEMP);
#endif /* IPSEC */
a440 4
#ifdef IPSEC
				if (tdbi)
				        free(tdbi, M_TEMP);
#endif /* IPSEC */
a461 4
#ifdef IPSEC
				if (tdbi)
				        free(tdbi, M_TEMP);
#endif /* IPSEC */
a484 4
#ifdef IPSEC
			if (tdbi)
			        free(tdbi, M_TEMP);
#endif /* IPSEC */
a497 4
#ifdef IPSEC
		if (tdbi)
		        free(tdbi, M_TEMP);
#endif /* IPSEC */
d503 1
a519 5
		if (tdbi) {
		        free(tdbi, M_TEMP);
			m->m_pkthdr.tdbi = NULL;
		}

a538 4
#ifdef IPSEC
				if (tdbi) 
				        free(tdbi, M_TEMP);
#endif /* IPSEC */
a604 4
#ifdef IPSEC
				if (tdbi) 
				        free(tdbi, M_TEMP);
#endif /* IPSEC */
d637 1
a637 1
	  goto skipipsec2;
d645 1
a645 1
	  goto skipipsec2;
d649 1
a661 2
                if (tdbi)
                        free(tdbi, M_TEMP);
a666 6
	if (tdbi) {
	        free(tdbi, M_TEMP);
		m->m_pkthdr.tdbi = NULL;
	}

 skipipsec2:
a676 4
#ifdef IPSEC
	if (tdbi)
	        free(tdbi, M_TEMP);
#endif /* IPSEC */
d1247 2
@


1.64
log
@enable pmtu by default
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.63 2001/03/03 01:09:28 itojun Exp $	*/
d323 1
a323 1
		if (tdbi)
d325 2
d1320 1
a1320 3
	  return 0;
	
	RTFREE(rt);
d1323 4
a1326 2
	    rt->rt_gateway->sa_family != AF_LINK)
	  return 0;
d1336 2
a1337 1
			    ETHER_ADDR_LEN))
d1339 1
d1342 1
@


1.63
log
@on parse error of timestamp option, set parameter error offset correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.62 2001/03/03 01:00:19 itojun Exp $	*/
d87 1
a87 1
#define IPMTUDISC	0
@


1.62
log
@drop packets with 127.0.0.0/8 in header field, if the packet is from outside.
under RFC1122 sender rule 127.0.0.8 must not appear on the wire.
count incidents by ipstat.ips_badaddr.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.61 2000/12/03 19:56:20 angelos Exp $	*/
d1224 3
@


1.61
log
@Fix fastroute-related panic, fixes PR 1541 (cas@@trans-nt.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.60 2000/10/13 02:01:10 itojun Exp $	*/
d375 10
@


1.60
log
@make sure we don't share external mbuf between m and mcopy, in ip_forward().
NetBSD PR 11201.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.59 2000/09/22 01:40:56 mickey Exp $	*/
d420 7
@


1.60.2.1
log
@Pull in patch from current:
Fix (angelos):
Fix fastroute-related panic, fixes PR 1541 (cas@@trans-nt.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.60 2000/10/13 02:01:10 itojun Exp $	*/
a419 7
#endif /* IPSEC */
			return;
		}
		if (m0 == 0) {  /* in case of 'fastroute' */
#ifdef IPSEC
			if (tdbi)
				free (tdbi, M_TEMP);
@


1.59
log
@fix my bug dating back to february the 14th of 1998,
when those wildcard interfaces came up, which
were usefull at the times. on the other hand here it is,
one cannot bind to the broadcast address, and angelos says ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.58 2000/09/19 03:20:58 angelos Exp $	*/
d1496 1
d1498 3
a1500 1
	mcopy = m_copy(m, 0, imin((int)ip->ip_len, 68));
@


1.58
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.57 2000/09/18 22:06:37 provos Exp $	*/
d748 1
a748 1
		if (m && ((ip_directedbcast == 0) || (ip_directedbcast &&
d760 2
a761 1
				m->m_flags |= M_BCAST;
@


1.57
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.56 2000/05/15 11:07:33 itojun Exp $	*/
d69 4
d83 3
a93 1
int ipsec_acl = 1;
d104 1
d303 5
d313 6
d322 5
d348 4
d367 4
d416 5
a420 1
		if (fr_checkp && (*fr_checkp)(ip, hlen, m->m_pkthdr.rcvif, 0, &m0))
d422 1
d434 7
a440 2
	if (hlen > sizeof (struct ip) && ip_dooptions(m))
		return;
d457 4
d482 4
d509 4
d526 4
d531 28
a558 1
	} else
d560 1
d575 4
d645 4
d661 60
d728 4
a1705 2
	case IPCTL_IPSEC_ACL:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ipsec_acl));
d1743 3
@


1.56
log
@parse IPv4 options more carefully.  make boundary checks against every
steps (including option type/length field - there were no checks, seems to
me 4.4BSD bug)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.55 2000/05/10 03:22:39 jason Exp $	*/
d79 6
d116 2
d123 2
d237 3
d1485 2
d1514 18
@


1.55
log
@make sure ip_timestamp is aligned correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.54 2000/05/06 17:55:08 itojun Exp $	*/
d869 4
d874 1
a874 1
			if (optlen <= 0 || optlen > cnt) {
d962 4
@


1.55.2.1
log
@Pull in patch from current:
Errata:
Parse IPv4 options more carefully. It is not yet clear if this can even be
used to crash the machine remote or locally.
Fix (itojun):
parse IPv4 options more carefully.  make boundary checks against every
steps (including option type/length field - there were no checks, seems to
me 4.4BSD bug)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.56 2000/05/15 11:07:33 itojun Exp $	*/
a868 4
			if (cnt < IPOPT_OLEN + sizeof(*cp)) {
				code = &cp[IPOPT_OLEN] - (u_char *)ip;
				goto bad;
			}
d870 1
a870 1
			if (optlen < IPOPT_OLEN + sizeof(*cp) || optlen > cnt) {
a957 4
			if (optlen < IPOPT_OFFSET + sizeof(*cp)) {
				code = &cp[IPOPT_OLEN] - (u_char *)ip;
				goto bad;
			}
@


1.55.2.2
log
@Pull in patch from current:
Fix (mickey):
fix my bug dating back to february the 14th of 1998,
when those wildcard interfaces came up, which
were usefull at the times. on the other hand here it is,
one cannot bind to the broadcast address, and angelos says ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.55.2.1 2000/05/29 18:24:03 jason Exp $	*/
d578 1
a578 1
		if (((ip_directedbcast == 0) || (m && ip_directedbcast &&
d590 1
a590 2
				if (m)
					m->m_flags |= M_BCAST;
@


1.54
log
@avoid underflow on unsigned value arithmetic (when optlen < 4).
2nd half of NetBSD Security Advisory 2000-002.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.53 2000/05/06 01:47:05 deraadt Exp $	*/
d852 1
a852 1
	register struct ip_timestamp *ipt;
d988 2
a989 2
			ipt = (struct ip_timestamp *)cp;
			if (ipt->ipt_ptr < 5 || ipt->ipt_len < 5)
d991 2
a992 2
			if (ipt->ipt_ptr - 1 + sizeof(n_time) > ipt->ipt_len) {
				if (++ipt->ipt_oflw == 0)
d996 2
a997 2
			bcopy(cp + ipt->ipt_ptr - 1, &sin, sizeof sin);
			switch (ipt->ipt_flg) {
d1003 2
a1004 2
				if (ipt->ipt_ptr - 1 + sizeof(n_time) +
				    sizeof(struct in_addr) > ipt->ipt_len)
d1013 1
a1013 1
				ipt->ipt_ptr += sizeof(struct in_addr);
d1017 2
a1018 2
				if (ipt->ipt_ptr - 1 + sizeof(n_time) +
				    sizeof(struct in_addr) > ipt->ipt_len)
d1024 1
a1024 1
				ipt->ipt_ptr += sizeof(struct in_addr);
d1031 1
a1031 1
			bcopy((caddr_t)&ntime, (caddr_t)cp + ipt->ipt_ptr - 1,
d1033 1
a1033 1
			ipt->ipt_ptr += sizeof(n_time);
@


1.53
log
@avoid unaligned access in timestamp; http://www.newhackcity.net/advisories/20000504a_0.txt; checked by provos and itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.52 2000/04/09 17:43:02 angelos Exp $	*/
d922 1
a922 1
			if (off > optlen - sizeof(struct in_addr)) {
d967 1
a967 1
			if (off > optlen - sizeof(struct in_addr))
@


1.52
log
@Pass ip_off and ip_len in the correct byte order to icmp_error(); this
should fix the crash problems with isic, reported last week.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.51 2000/04/04 13:43:02 angelos Exp $	*/
d855 1
a855 1
	struct in_addr *sin, dst;
d996 1
a996 1
			sin = (struct in_addr *)(cp + ipt->ipt_ptr - 1);
d1012 1
a1012 1
				    (caddr_t)sin, sizeof(struct in_addr));
d1020 1
a1020 1
				bcopy((caddr_t)sin, (caddr_t)&ipaddr.sin_addr,
@


1.51
log
@Verbiage fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.50 2000/03/27 07:26:45 angelos Exp $	*/
a1042 1
	HTONS(ip->ip_len);	/* XXX because ip_input changed these three */
a1043 1
	HTONS(ip->ip_off);
@


1.50
log
@As I threatened a while ago, ingress IPsec ACL-checking is turned on
by default. Read the ipsecadm(8) man page for more details on how to
specify ingress filters with manual keying. isakmpd has been doing
this for a while now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.49 2000/03/03 13:09:28 itojun Exp $	*/
d349 1
a349 1
	 * is as at least much as the IP header would have us expect.
d861 1
d875 1
@


1.49
log
@remove WIDE's experimental ip reass code, mistakingly merged in partially.
NetBSD PR: 9412
Fix from: ho@@crt.se
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.48 2000/01/10 06:59:22 angelos Exp $	*/
d81 1
a81 1
int ipsec_acl = 0;
@


1.48
log
@Add 10 new ipsec-related sysctl variables...they are currently under
net.inet.ip; perhaps they should be moved under net.inet.ipsec or some
such.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.47 2000/01/10 04:30:52 angelos Exp $	*/
a740 2
	ip->ip_ttl = 0;	/* xxx */
	ip->ip_sum = 0;
@


1.48.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d741 2
@


1.48.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.66 2001/03/28 20:03:03 angelos Exp $	*/
a68 4
#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#endif /* IPSEC */

a79 7
#ifndef IPMTUDISC
#define IPMTUDISC	1
#endif
#ifndef IPMTUDISCTIMEOUT
#define IPMTUDISCTIMEOUT (10 * 60)	/* as per RFC 1191 */
#endif

d81 1
a91 1
int ipsec_expire_acquire = IPSEC_DEFAULT_EXPIRE_ACQUIRE;
a109 2
int	ip_mtudisc = IPMTUDISC;
u_int	ip_mtudisc_timeout = IPMTUDISCTIMEOUT;
a114 2
struct rttimer_queue *ip_mtudisc_timeout_q = NULL;

a226 3
	if (ip_mtudisc != 0)
		ip_mtudisc_timeout_q = 
		    rt_timer_queue_create(ip_mtudisc_timeout);
a282 5
#ifdef IPSEC
	int error, s;
	struct tdb *tdb;
	struct tdb_ident *tdbi;
#endif /* IPSEC */
a330 10

	/* 127/8 must not appear on wire - RFC1122 */
	if ((ntohl(ip->ip_dst.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET ||
	    (ntohl(ip->ip_src.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) {
		if ((m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) == 0) {
			ipstat.ips_badaddr++;
			goto bad;
		}
	}

d349 1
a349 1
	 * is at least as much as the IP header would have us expect.
d372 1
a372 4
		if (fr_checkp && (*fr_checkp)(ip, hlen, m->m_pkthdr.rcvif, 0, &m0)) {
			return;
		}
		if (m0 == 0) {  /* in case of 'fastroute' */
a373 1
		}
d385 2
a386 3
	if (hlen > sizeof (struct ip) && ip_dooptions(m)) {
	        return;
	}
d461 1
a461 24
	} else {
#ifdef IPSEC
	        /* IPsec policy check for forwarded packets */
                s = splnet();
		tdbi = (struct tdb_ident *) m->m_pkthdr.tdbi;
                if (tdbi == NULL)
                  tdb = NULL;
                else
                  tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);

	        ipsp_spd_lookup(m, AF_INET, hlen, &error,
		  	        IPSP_DIRECTION_IN, tdb, NULL);
                splx(s);

		/* Error or otherwise drop-packet indication */
		if (error) {
			ipstat.ips_cantforward++;
			m_freem(m);
			return;
		}

		/* Fall through, forward packet */
#endif /* IPSEC */

a462 1
	}
a554 53
#ifdef IPSEC
        /*
         * If it's a protected packet for us, skip the policy check.
         * That's because we really only care about the properties of
         * the protected packet, and not the intermediate versions.
         * While this is not the most paranoid setting, it allows
         * some flexibility in handling of nested tunnels etc.
         */
        if ((ip->ip_p == IPPROTO_ESP) || (ip->ip_p == IPPROTO_AH))
          goto skipipsec;

	/*
	 * If the protected packet was tunneled, then we need to
	 * verify the protected packet's information, not the
	 * external headers. Thus, skip the policy lookup for the
	 * external packet, and keep the IPsec information linked on
	 * the packet header (the encapsulation routines know how
	 * to deal with that).
	 */
	if ((ip->ip_p == IPPROTO_IPIP) || (ip->ip_p == IPPROTO_IPV6))
	  goto skipipsec;

	/*
	 * If the protected packet is TCP or UDP, we'll do the
	 * policy check in the respective input routine, so we can
	 * check for bypass sockets.
	 */
	if ((ip->ip_p == IPPROTO_TCP) || (ip->ip_p == IPPROTO_UDP))
	  goto skipipsec;

	/* IPsec policy check for local-delivery packets */
        s = splnet();
	tdbi = (struct tdb_ident *) m->m_pkthdr.tdbi;
        if (tdbi == NULL)
                tdb = NULL;
        else
	        tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);

	ipsp_spd_lookup(m, AF_INET, hlen, &error, IPSP_DIRECTION_IN,
			tdb, NULL);
        splx(s);

	/* Error or otherwise drop-packet indication */
	if (error) {
	        ipstat.ips_cantforward++;
		m_freem(m);
		return;
	}

 skipipsec:
	/* Otherwise, just fall through and deliver the packet */
#endif /* IPSEC */

d578 1
a578 1
		if (((ip_directedbcast == 0) || (m && ip_directedbcast &&
d590 1
a590 2
				if (m)
					m->m_flags |= M_BCAST;
d852 1
a852 1
	struct ip_timestamp ipt;
d855 1
a855 1
	struct in_addr sin, dst;
a860 1

a867 4
			if (cnt < IPOPT_OLEN + sizeof(*cp)) {
				code = &cp[IPOPT_OLEN] - (u_char *)ip;
				goto bad;
			}
d869 1
a869 1
			if (optlen < IPOPT_OLEN + sizeof(*cp) || optlen > cnt) {
a873 1

d920 1
a920 1
			if ((off + sizeof(struct in_addr)) > optlen) {
a955 4
			if (optlen < IPOPT_OFFSET + sizeof(*cp)) {
				code = &cp[IPOPT_OLEN] - (u_char *)ip;
				goto bad;
			}
d965 1
a965 1
			if ((off + sizeof(struct in_addr)) > optlen)
d986 2
a987 2
			bcopy(cp, &ipt, sizeof(struct ip_timestamp));
			if (ipt.ipt_ptr < 5 || ipt.ipt_len < 5)
d989 2
a990 2
			if (ipt.ipt_ptr - 1 + sizeof(n_time) > ipt.ipt_len) {
				if (++ipt.ipt_oflw == 0)
d994 2
a995 2
			bcopy(cp + ipt.ipt_ptr - 1, &sin, sizeof sin);
			switch (ipt.ipt_flg) {
d1001 2
a1002 2
				if (ipt.ipt_ptr - 1 + sizeof(n_time) +
				    sizeof(struct in_addr) > ipt.ipt_len)
d1010 2
a1011 2
				    (caddr_t)&sin, sizeof(struct in_addr));
				ipt.ipt_ptr += sizeof(struct in_addr);
d1015 2
a1016 2
				if (ipt.ipt_ptr - 1 + sizeof(n_time) +
				    sizeof(struct in_addr) > ipt.ipt_len)
d1018 1
a1018 1
				bcopy((caddr_t)&sin, (caddr_t)&ipaddr.sin_addr,
d1022 1
a1022 1
				ipt.ipt_ptr += sizeof(struct in_addr);
a1025 3
				/* XXX can't take &ipt->ipt_flg */
				code = (u_char *)&ipt.ipt_ptr -
				    (u_char *)ip + 1;
d1029 1
a1029 1
			bcopy((caddr_t)&ntime, (caddr_t)cp + ipt.ipt_ptr - 1,
d1031 1
a1031 1
			ipt.ipt_ptr += sizeof(n_time);
d1041 1
d1043 1
d1119 1
a1119 1
		return 0;
d1124 2
a1125 4
	    rt->rt_gateway->sa_family != AF_LINK) {
		RTFREE(rt);
		return 0;
	}
d1135 1
a1135 2
			    ETHER_ADDR_LEN)) {
				RTFREE(rt);
a1136 1
			}
a1138 1
	RTFREE(rt);
a1316 1
	 * Pullup to avoid sharing mbuf cluster between m and mcopy.
d1318 1
a1318 3
	mcopy = m_copym(m, 0, imin((int)ip->ip_len, 68), M_DONTWAIT);
	if (mcopy)
		mcopy = m_pullup(mcopy, ip->ip_hl << 2);
a1463 2
	int error;

a1490 18
	case IPCTL_MTUDISC:
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &ip_mtudisc);
		if (ip_mtudisc != 0 && ip_mtudisc_timeout_q == NULL) {
			ip_mtudisc_timeout_q = 
			    rt_timer_queue_create(ip_mtudisc_timeout);
		} else if (ip_mtudisc == 0 && ip_mtudisc_timeout_q != NULL) {
			rt_timer_queue_destroy(ip_mtudisc_timeout_q, TRUE);
			ip_mtudisc_timeout_q = NULL;
		}
		return error;
	case IPCTL_MTUDISCTIMEOUT:
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		   &ip_mtudisc_timeout);
		if (ip_mtudisc_timeout_q != NULL)
			rt_timer_queue_change(ip_mtudisc_timeout_q, 
					      ip_mtudisc_timeout);
		return (error);
d1508 2
a1546 3
	case IPCTL_IPSEC_EXPIRE_ACQUIRE:
	        return (sysctl_int(oldp, oldlenp, newp, newlen,
				   &ipsec_expire_acquire));
@


1.48.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.48.2.2 2001/05/14 22:40:11 niklas Exp $	*/
a38 2
#include "pf.h"

d41 1
d46 3
d50 3
a58 4
#if NPF > 0
#include <net/pfvar.h>
#endif

d67 5
d151 4
a159 2
struct pool ipqent_pool;

a228 3
	pool_init(&ipqent_pool, sizeof(struct ipqent), 0, 0, 0, "ipqepl",
	    0, NULL, NULL, M_IPQ);

d283 1
a283 1
		ipv4_input(m);
d292 1
a292 2
ipv4_input(m)
	struct mbuf *m;
d299 2
a304 1
	struct m_tag *mtag;
d307 18
d333 1
a333 1
	    (m = m_pullup(m, sizeof (struct ip))) == NULL) {
d348 1
a348 1
		if ((m = m_pullup(m, hlen)) == NULL) {
d364 3
a366 14
	if ((m->m_pkthdr.csum & M_IPV4_CSUM_IN_OK) == 0) {
		if (m->m_pkthdr.csum & M_IPV4_CSUM_IN_BAD) {
			ipstat.ips_inhwcsum++;
			ipstat.ips_badsum++;
			goto bad;
		}

		if (in_cksum(m, hlen) != 0) {
			ipstat.ips_badsum++;
			goto bad;
		}
	} else {
		m->m_pkthdr.csum &= ~M_IPV4_CSUM_IN_OK;
		ipstat.ips_inhwcsum++;
a368 6
#ifdef ALTQ
	if (altq_input != NULL && (*altq_input)(m, AF_INET) == 0)
		/* packet is dropped by traffic conditioner */
		return;
#endif

d377 1
d398 4
a401 2
	/*
	 * Packet filter
a402 1
#if NPF > 0
d404 8
a411 5
		if (pf_test(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
			goto bad;

		ip = mtod(m, struct ip *);
		hlen = ip->ip_hl << 2;
d414 1
d439 1
a439 1
			if ((m = m_pullup(m, hlen)) == NULL) {
d459 1
d465 1
a501 1
		mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
d503 6
a508 5
		if (mtag != NULL) {
			tdbi = (struct tdb_ident *)(mtag + 1);
			tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
		} else
			tdb = NULL;
d510 1
a510 1
		    IPSP_DIRECTION_IN, tdb, NULL);
d537 1
a537 1
			if ((m = m_pullup(m, hlen)) == NULL) {
d592 2
a593 1
			ipqe = pool_get(&ipqent_pool, PR_NOWAIT);
a600 1
			ipqe->ipqe_m = m;
d602 2
a603 2
			m = ip_reass(ipqe, fp);
			if (m == 0) {
d608 1
a608 1
			ip = mtod(m, struct ip *);
a647 1
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL); 
d649 4
a652 2
	if (mtag) {
		tdbi = (struct tdb_ident *)(mtag + 1);
d654 1
a654 2
	} else
		tdb = NULL;
d656 1
a656 1
	    tdb, NULL);
d721 1
a721 1
struct mbuf *
d723 2
a724 2
	struct ipqent *ipqe;
	struct ipq *fp;
d726 2
a727 2
	struct mbuf *m = ipqe->ipqe_m;
	struct ipqent *nq, *p, *q;
d744 1
a744 3
		MALLOC(fp, struct ipq *, sizeof (struct ipq),
		    M_FTABLE, M_NOWAIT);
		if (fp == NULL)
d746 1
d777 1
a777 1
			m_adj(ipqe->ipqe_m, i);
d794 1
a794 1
			m_adj(q->ipqe_m, i);
d798 1
a798 1
		m_freem(q->ipqe_m);
d800 1
a800 1
		pool_put(&ipqent_pool, q);
d835 1
a835 1
	m = q->ipqe_m;
d840 1
a840 1
	pool_put(&ipqent_pool, q);
d843 1
a843 1
		t = q->ipqe_m;
d845 1
a845 1
		pool_put(&ipqent_pool, q);
d860 1
a860 1
	FREE(fp, M_FTABLE);
d865 4
a868 4
		int plen = 0;
		for (t = m; t; t = t->m_next)
			plen += t->m_len;
		m->m_pkthdr.len = plen;
d870 1
a870 1
	return (m);
d875 1
a875 1
	pool_put(&ipqent_pool, ipqe);
d892 1
a892 1
		m_freem(q->ipqe_m);
d894 1
a894 1
		pool_put(&ipqent_pool, q);
d898 1
a898 1
	FREE(fp, M_FTABLE);
d1170 1
d1405 1
a1405 1
#ifdef IPSEC
d1420 1
d1527 46
d1574 1
a1574 12
#ifdef IPSEC
		if (ipforward_rt.ro_rt) {
			struct rtentry *rt = ipforward_rt.ro_rt;
			destifp = ipforward_rt.ro_rt->rt_ifp;
			/*
			 * XXX BUG ALERT
			 * The "dummyifp" code relies upon the fact
			 * that icmp_error() touches only ifp->if_mtu.
			 */
			if (rt->rt_rmx.rmx_mtu) {
				dummyifp.if_mtu = rt->rt_rmx.rmx_mtu;
				destifp = &dummyifp;
@


1.48.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.48.2.3 2001/07/04 10:54:49 niklas Exp $	*/
d54 4
a66 8
#if NPF > 0
#include <net/pfvar.h>
#endif

#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#endif /* IPSEC */

a98 1
char ipsec_def_comp[20];
a126 1
int	ipsec_ipcomp_default_level = IPSEC_IPCOMP_LEVEL_DEFAULT;
a249 1
	strncpy(ipsec_def_comp, IPSEC_DEFAULT_DEF_COMP, sizeof(ipsec_def_comp));
d357 6
a390 1
#if NPF > 0
d394 4
a397 2
	if (pf_test(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
		goto bad;
d399 3
a401 2
	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;
a402 7

#ifdef ALTQ
	if (altq_input != NULL && (*altq_input)(m, AF_INET) == 0)
		/* packet is dropped by traffic conditioner */
		return;
#endif

d611 1
a611 2
        if ((ip->ip_p == IPPROTO_ESP) || (ip->ip_p == IPPROTO_AH) ||
	    (ip->ip_p == IPPROTO_IPCOMP))
a1585 1
			Free(ip_mtudisc_timeout_q);
a1652 4
	case IPCTL_IPSEC_IPCOMP_ALGORITHM:
	        return (sysctl_tstring(oldp, oldlenp, newp, newlen,
				       ipsec_def_comp, 
				       sizeof(ipsec_def_comp)));
@


1.48.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a396 2
		goto bad;
	if (m == NULL)
@


1.48.2.6
log
@Merge in trunk
@
text
@d228 1
a228 1
	    NULL);
d265 1
a265 1
	struct mbuf *m;
d268 3
d399 1
a399 1
		return;
d1481 3
a1540 11
#if 1
		/*
		 * a router should not generate ICMP_SOURCEQUENCH as
		 * required in RFC1812 Requirements for IP Version 4 Routers.
		 * source quench could be a big problem under DoS attacks,
		 * or the underlying interface is rate-limited.
		 */
		if (mcopy)
			m_freem(mcopy);
		return;
#else
a1543 1
#endif
@


1.48.2.7
log
@Merge in -current from roughly a week ago
@
text
@d153 2
a154 2
static __inline int ipq_lock_try(void);
static __inline void ipq_unlock(void);
d212 1
a212 1
static void save_rte(u_char *, struct in_addr);
@


1.48.2.8
log
@Sync the SMP branch with 3.3
@
text
@a88 2
struct ipqhead ipq;

a157 2
struct ipstat ipstat;

d244 1
a244 1
		ip_mtudisc_timeout_q =
a298 1
	in_addr_t pfrdr = 0;
a392 1
	pfrdr = ip->ip_dst.s_addr;
d400 6
a405 1
	pfrdr = (pfrdr != ip->ip_dst.s_addr);
d492 1
a492 4
	        /*
		 * IPsec policy check for forwarded packets. Look at
		 * inner-most IPsec SA used.
		 */
d511 1
a511 4
		/*
		 * Fall through, forward packet. Outbound IPsec policy
		 * checking will occur in ip_output().
		 */
d514 1
a514 1
		ip_forward(m, pfrdr);
d582 1
a582 1

d614 1
a614 2
         * some flexibility in handling nested tunnels (in setting up
	 * the policies).
d639 2
a640 12
	/*
	 * IPsec policy check for local-delivery packets. Look at the
	 * inner-most SA that protected the packet. This is in fact
	 * a bit too restrictive (it could end up causing packets to
	 * be dropped that semantically follow the policy, e.g., in
	 * certain SA-bundle configurations); but the alternative is
	 * very complicated (and requires keeping track of what
	 * kinds of tunneling headers have been seen in-between the
	 * IPsec headers), and I don't think we lose much functionality
	 * that's needed in the real world (who uses bundles anyway ?).
	 */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
d651 1
a651 1
	/* Error or otherwise drop-packet indication. */
d679 1
a679 1
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
a723 1
	u_int8_t ecn, ecn0;
a751 16
	 * Handle ECN by comparing this segment with the first one;
	 * if CE is set, do not lose CE.
	 * drop if CE and not-ECT are mixed for the same packet.
	 */
	ecn = ipqe->ipqe_ip->ip_tos & IPTOS_ECN_MASK;
	ecn0 = fp->ipq_fragq.lh_first->ipqe_ip->ip_tos & IPTOS_ECN_MASK;
	if (ecn == IPTOS_ECN_CE) {
		if (ecn0 == IPTOS_ECN_NOTECT)
			goto dropfrag;
		if (ecn0 != IPTOS_ECN_CE)
			fp->ipq_fragq.lh_first->ipqe_ip->ip_tos |= IPTOS_ECN_CE;
	}
	if (ecn == IPTOS_ECN_NOTECT && ecn0 != IPTOS_ECN_NOTECT)
		goto dropfrag;

	/*
d1239 3
a1241 1

d1254 1
a1254 1
			if (!bcmp(LLADDR((struct sockaddr_dl *)ifa->ifa_addr),
d1479 2
a1480 2
	    (IP_FORWARDING | (ip_directedbcast ? IP_ALLOWBROADCAST : 0)),
	    0, (void *)NULL, (void *)NULL);
d1597 1
a1597 1
			ip_mtudisc_timeout_q =
d1609 1
a1609 1
			rt_timer_queue_change(ip_mtudisc_timeout_q,
d1671 1
a1671 1
				       ipsec_def_comp,
@


1.48.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.48.2.8 2003/03/28 00:06:54 niklas Exp $	*/
d196 1
a196 2
	snprintf(buf, sizeof buf, "%d.%d.%d.%d",
	    ucp[0] & 0xff, ucp[1] & 0xff,
d1043 1
a1043 2
				strlcpy(buf, inet_ntoa(ip->ip_dst),
				    sizeof buf);
@


1.48.2.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.48.2.9 2003/05/13 19:36:17 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.48.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d223 2
a224 2
	struct protosw *pr;
	int i;
d295 2
a296 2
	struct ip *ip;
	struct ipq *fp;
d299 1
a299 1
	int hlen, mff, len;
a362 3
	/* Retrieve the packet lenght. */
	len = ntohs(ip->ip_len);

d366 2
a367 1
	if (len < hlen) {
d371 1
d379 1
a379 1
	if (m->m_pkthdr.len < len) {
d383 1
a383 1
	if (m->m_pkthdr.len > len) {
d385 2
a386 2
			m->m_len = len;
			m->m_pkthdr.len = len;
d388 1
a388 1
			m_adj(m, len - m->m_pkthdr.len);
d530 1
a530 1
	if (ip->ip_off &~ htons(IP_DF | IP_RF)) {
d558 2
a559 2
		ip->ip_len = htons(ntohs(ip->ip_len) - hlen);
		mff = (ip->ip_off & htons(IP_MF)) != 0;
d565 1
a565 2
			if (ntohs(ip->ip_len) == 0 ||
			    (ntohs(ip->ip_len) & 0x7) != 0) {
d571 1
a571 1
		ip->ip_off = htons(ntohs(ip->ip_off) << 3);
a604 1
			ip->ip_len = htons(ntohs(ip->ip_len) + hlen);
d609 2
a610 1
	}
d690 1
a690 1
	struct mbuf *m;
d692 1
a692 1
	struct in_ifaddr *ia;
d788 1
a788 1
		if (ntohs(q->ipqe_ip->ip_off) > ntohs(ipqe->ipqe_ip->ip_off))
d797 2
a798 2
		i = ntohs(p->ipqe_ip->ip_off) + ntohs(p->ipqe_ip->ip_len) -
		    ntohs(ipqe->ipqe_ip->ip_off);
d800 1
a800 1
			if (i >= ntohs(ipqe->ipqe_ip->ip_len))
d803 2
a804 4
			ipqe->ipqe_ip->ip_off =
			    htons(ntohs(ipqe->ipqe_ip->ip_off) + i);
			ipqe->ipqe_ip->ip_len =
			    htons(ntohs(ipqe->ipqe_ip->ip_len) - i);
d812 7
a818 10
	for (; q != NULL &&
	    ntohs(ipqe->ipqe_ip->ip_off) + ntohs(ipqe->ipqe_ip->ip_len) >
	    ntohs(q->ipqe_ip->ip_off); q = nq) {
		i = (ntohs(ipqe->ipqe_ip->ip_off) +
		    ntohs(ipqe->ipqe_ip->ip_len)) - ntohs(q->ipqe_ip->ip_off);
		if (i < ntohs(q->ipqe_ip->ip_len)) {
			q->ipqe_ip->ip_len =
			    htons(ntohs(q->ipqe_ip->ip_len) - i);
			q->ipqe_ip->ip_off =
			    htons(ntohs(q->ipqe_ip->ip_off) + i);
d842 1
a842 1
		if (ntohs(q->ipqe_ip->ip_off) != next)
d844 1
a844 1
		next += ntohs(q->ipqe_ip->ip_len);
d881 1
a881 1
	ip->ip_len = htons(next);
d913 1
a913 1
	struct ipqent *q, *p;
d934 1
a934 1
	struct ipq *fp, *nfp;
d991 2
a992 2
	struct ip *ip = mtod(m, struct ip *);
	u_char *cp;
d994 1
a994 1
	struct in_ifaddr *ia;
d1195 1
d1209 1
a1209 1
	struct sockaddr_in *sin;
d1260 3
a1262 3
	struct rtentry *rt;
	struct ifnet *ifp;
	struct ifaddr *ifa;
d1305 2
a1306 2
	struct in_addr *p, *q;
	struct mbuf *m;
d1375 1
a1375 1
	struct mbuf *m;
d1378 1
a1378 1
	int i;
d1380 1
a1380 1
	caddr_t opts;
d1421 3
a1423 3
	struct ip *ip = mtod(m, struct ip *);
	struct sockaddr_in *sin;
	struct rtentry *rt;
d1473 1
a1473 1
	mcopy = m_copym(m, 0, imin(ntohs(ip->ip_len), 68), M_DONTWAIT);
@


1.48.2.12
log
@Merge with the trunk
@
text
@a142 2
int *ipctl_vars[IPCTL_MAXID] = IPCTL_VARS;

d255 3
a257 3
	strlcpy(ipsec_def_enc, IPSEC_DEFAULT_DEF_ENC, sizeof(ipsec_def_enc));
	strlcpy(ipsec_def_auth, IPSEC_DEFAULT_DEF_AUTH, sizeof(ipsec_def_auth));
	strlcpy(ipsec_def_comp, IPSEC_DEFAULT_DEF_COMP, sizeof(ipsec_def_comp));
d363 1
a363 1
	/* Retrieve the packet length. */
d1608 7
d1627 3
d1649 47
d1703 3
a1710 3
		if (name[0] < IPCTL_MAXID)
			return (sysctl_int_arr(ipctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
@


1.48.2.13
log
@sync to head
@
text
@d1096 1
a1096 1
				ia = ip_rtaddr(ipaddr.sin_addr, ip->ip_src);
d1135 1
a1135 2
			    (ia = ip_rtaddr(ipaddr.sin_addr, ip->ip_src)) == 0)
			{
d1214 2
a1215 1
ip_rtaddr(struct in_addr dst, struct in_addr src)
d1217 1
a1217 1
	struct sockaddr_rtin *rtin;
d1219 1
a1219 1
	rtin = satortin(&ipforward_rt.ro_dst);
d1221 1
a1221 2
	if (ipforward_rt.ro_rt == 0 || dst.s_addr != rtin->rtin_dst.s_addr ||
	    src.s_addr != rtin->rtin_src.s_addr) {
d1226 3
a1228 4
		rtin->rtin_family = AF_INET;
		rtin->rtin_len = sizeof(*rtin);
		rtin->rtin_dst = dst;
		rtin->rtin_src = src;
a1275 1
	sin.sin_srcaddr.s_addr = 0;
d1430 1
a1430 1
	struct sockaddr_rtin *rtin;
d1457 1
a1457 1
	rtin = satortin(&ipforward_rt.ro_dst);
d1459 1
a1459 2
	    ip->ip_dst.s_addr != rtin->rtin_dst.s_addr ||
	    ip->ip_src.s_addr != rtin->rtin_src.s_addr) {
d1464 3
a1466 4
		rtin->rtin_family = AF_INET;
		rtin->rtin_len = sizeof(*rtin);
		rtin->rtin_dst = ip->ip_dst;
		rtin->rtin_src = ip->ip_src;
@


1.47
log
@Add net.inet.ip.ipsec-invalid-life, default value 60 seconds; the
amount of time embryonic SAs will be kept before they have to be
initialized by key management (this only affects automated key
management).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.46 2000/01/09 22:30:37 angelos Exp $	*/
d83 11
d234 3
d1515 34
@


1.46
log
@Rename newly-introduced variable to better reflect use.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.45 2000/01/09 22:17:57 angelos Exp $	*/
d82 1
d1498 3
@


1.45
log
@Add a sysctl for IPsec ingress access control (better explanation on a
follow-up commit).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.44 1999/12/08 06:50:20 itojun Exp $	*/
d81 1
a81 1
int ipsp_allow_all = 1;
d1496 1
a1496 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			&ipsp_allow_all));
@


1.44
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.43 1999/11/29 16:22:29 ho Exp $	*/
d81 1
d1495 3
@


1.43
log
@Make sure M_BCAST is set for IP broadcasts, even if the packet came in as
an ethernet unicast. (cmetz@@, niklas@@ ok.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.42 1999/09/25 06:35:48 deraadt Exp $	*/
d725 2
d1078 1
a1078 1
#endif
d1259 3
d1338 3
d1378 1
d1381 48
@


1.42
log
@line not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.41 1999/09/23 07:20:35 deraadt Exp $	*/
d572 3
a574 1
			    ina.s_addr == ia->ia_net)
d576 1
@


1.41
log
@fix same-interface-out-as-in and packet gets corrupted bug noted by
james@@oaktree.co.uk by re-working icmp embedded-packet code so that
ip_forward() m_copy()-aliased packet can be forwarded to ip_output and
icmp_error() safely, because no packet tweaking is needed before
calling icmp_error()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.40 1999/04/23 15:18:03 provos Exp $	*/
a1377 1
	ip = mtod(mcopy, struct ip *);
@


1.40
log
@dont accept packets with the destination address of a down interface;
proff@@netbsd.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.39 1999/04/12 03:17:09 deraadt Exp $	*/
a1267 2
		HTONS(ip->ip_off);
		HTONS(ip->ip_len);
a1285 2
			HTONS(ip->ip_off);
			HTONS(ip->ip_len);
a1378 2
	HTONS(ip->ip_off);
	HTONS(ip->ip_len);
@


1.39
log
@move encdebug to a useful place
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.38 1999/04/11 19:41:38 niklas Exp $	*/
d262 1
d375 2
a376 1
	if (in_iawithaddr(ip->ip_dst, m))
@


1.38
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.37 1999/02/21 04:01:46 deraadt Exp $	*/
d79 3
@


1.37
log
@split ipintr() to create new ipv4_input() for tunnels; NRL
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.36 1999/02/19 19:50:43 deraadt Exp $	*/
d67 1
d1434 2
@


1.36
log
@ipq locking
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.35 1999/02/17 23:51:12 deraadt Exp $	*/
d222 27
d254 1
a254 1
ipintr()
a256 1
	register struct mbuf *m;
d259 21
a279 1
	int hlen, mff, s;
a280 16
	if (needqueuedrain)
		m_reclaim ();
next:
	/*
	 * Get next datagram off input queue and get IP header
	 * in first mbuf.
	 */
	s = splimp();
	IF_DEQUEUE(&ipintrq, m);
	splx(s);
	if (m == 0)
		return;
#ifdef	DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("ipintr no HDR");
#endif
d291 1
a291 1
		goto next;
d306 1
a306 1
			goto next;
d352 2
a353 3
			goto next;
		else
			ip = mtod(m = m0, struct ip *);
d365 1
a365 1
		goto next;
d381 1
a381 1
				goto next;
d403 1
a403 1
				goto next;
d425 1
a425 1
			goto next;
d441 1
a441 1
	goto next;
d455 1
a455 1
				goto next;
d521 1
a521 1
				goto next;
d537 2
a538 2
	(*inetsw[ip_protox[ip->ip_p]].pr_input)(m, hlen);
	goto next;
a540 1
	goto next;
d1330 1
a1330 1
			  0, NULL);
@


1.35
log
@add fragment flood protection; configureable using sysctl ip.maxqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.34 1998/12/28 23:54:57 deraadt Exp $	*/
d124 31
d430 1
d435 1
d459 1
d475 1
d483 1
d490 2
a491 1
			if (ip == 0)
d493 1
d500 1
d743 1
d751 1
d762 2
d768 1
d777 1
d779 2
a780 1
	while (ipq.lh_first != NULL && ip_frags > ip_maxqueue * 3 / 4) {
@


1.34
log
@ensure the ip packet embedded inside an icmp packet has correct ip_len,
ip_off, ip_id. for udp, also correct uh_sum.  ip_sum is still set to 0;
(all this debugged using nmap)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.33 1998/12/26 12:35:11 provos Exp $	*/
d102 4
a123 1

d284 4
a287 4
       /*
	* Check if we want to allow this packet to be processed.
	* Consider it to be bad if not.
	*/
d438 6
d450 1
d593 1
d633 1
d638 1
d668 1
d687 1
d728 13
d1007 1
a1007 1
        u_int32_t addr;
d1009 1
a1009 1
        register struct rtentry *rt;
d1024 2
a1025 2
	if ((rt->rt_flags & RTF_GATEWAY) || (rt->rt_flags & RTF_LLINFO) == 0 
	    || rt->rt_gateway->sa_family != AF_LINK)
d1029 10
a1038 10
          for (ifa = ifp->if_addrlist.tqh_first; ifa != 0; ifa = ifa->ifa_list.tqe_next) 
	  {
		if (ifa->ifa_addr->sa_family != rt->rt_gateway->sa_family)
		  continue;

		if (!bcmp(LLADDR((struct sockaddr_dl *)ifa->ifa_addr), 
			  LLADDR((struct sockaddr_dl *)rt->rt_gateway),
			  ETHER_ADDR_LEN))
		  return 1;
	  }
d1356 3
@


1.33
log
@make ip_id random but ensure that ids dont repeat for some period.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.32 1998/11/13 22:24:17 provos Exp $	*/
d914 3
d1160 2
d1180 2
d1273 4
@


1.32
log
@Recompute ip header length after packet has been reassembled, and also
use the actual header length for m_pullup, pointed out by jdb@@es2.net
and guido@@freebsd.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.31 1998/05/18 21:10:49 provos Exp $	*/
a173 1
	ip_id = time.tv_sec & 0xffff;
@


1.31
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.30 1998/02/14 18:50:36 mickey Exp $	*/
d391 1
a391 1
			if ((m = m_pullup(m, sizeof (struct ip))) == 0) {
d449 1
@


1.30
log
@wildcard ifaces; finally, after HE said it's ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.29 1998/02/03 21:11:08 deraadt Exp $	*/
d98 3
a100 3
u_char  ipsec_auth_default_level = IPSEC_AUTH_LEVEL_DEFAULT;
u_char  ipsec_esp_trans_default_level = IPSEC_ESP_TRANS_LEVEL_DEFAULT;
u_char  ipsec_esp_network_default_level = IPSEC_ESP_NETWORK_LEVEL_DEFAULT;
d1220 2
a1221 1
	    (IP_FORWARDING | (ip_directedbcast ? IP_ALLOWBROADCAST : 0)), 0);
@


1.29
log
@bail out for sourcerouted packets earlier, also do not forward
sourcerouted packets ever if ipforwarding is off; tqbf@@secnet.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.28 1998/02/01 21:46:02 deraadt Exp $	*/
a198 1
	register struct in_ifaddr *ia;
d308 3
a310 17
	for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
		if (ip->ip_dst.s_addr == ia->ia_addr.sin_addr.s_addr)
			goto ours;
		if (((ip_directedbcast == 0) || (ip_directedbcast &&
		    ia->ia_ifp == m->m_pkthdr.rcvif)) &&
		    (ia->ia_ifp->if_flags & IFF_BROADCAST)) {
			if (ip->ip_dst.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
			    ip->ip_dst.s_addr == ia->ia_netbroadcast.s_addr ||
			    /*
			     * Look for all-0's host part (old broadcast addr),
			     * either for subnet or net.
			     */
			    ip->ip_dst.s_addr == ia->ia_subnet ||
			    ip->ip_dst.s_addr == ia->ia_net)
				goto ours;
		}
	}
d464 31
@


1.28
log
@undo wildcard loopback stuff; it was not checked by other developers
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.26 1997/08/09 23:36:29 millert Exp $	*/
d747 11
a784 12
			if (!ip_dosourceroute) {
				char buf[4*sizeof "123"];

				strcpy(buf, inet_ntoa(ip->ip_dst));
				log(LOG_WARNING,
				    "attempted source route from %s to %s\n",
				    inet_ntoa(ip->ip_src), buf);
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				goto bad;
			}

d891 1
a891 1
	if (forward) {
@


1.27
log
@support wildcard loopbacks. that is, setting up lo1 like:
ifconfig lo1 inet 192.168.1.1 netmask 255.255.255.0 link1
would force it to act like all the addresses from net 192.168.1 were
added to the interface.
todo: man lo
@
text
@d199 1
d309 17
a325 3
	if (in_iawithaddr(ip->ip_dst, m))
		goto ours;

a478 31
}

struct in_ifaddr *
in_iawithaddr(ina, m)
	struct in_addr ina;
	register struct mbuf *m;
{
	register struct in_ifaddr *ia;

	for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
		if ((ina.s_addr == ia->ia_addr.sin_addr.s_addr) ||
		    ((ia->ia_ifp->if_flags & (IFF_LOOPBACK|IFF_LINK1)) ==
			(IFF_LOOPBACK|IFF_LINK1) &&
		     ia->ia_subnet == (ina.s_addr & ia->ia_subnetmask)))
			return ia;
		if (m && ((ip_directedbcast == 0) || (ip_directedbcast &&
		    ia->ia_ifp == m->m_pkthdr.rcvif)) &&
		    (ia->ia_ifp->if_flags & IFF_BROADCAST)) {
			if (ina.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
			    ina.s_addr == ia->ia_netbroadcast.s_addr ||
			    /*
			     * Look for all-0's host part (old broadcast addr),
			     * either for subnet or net.
			     */
			    ina.s_addr == ia->ia_subnet ||
			    ina.s_addr == ia->ia_net)
				return ia;
		}
	}

	return NULL;
@


1.26
log
@The list of tcp/udp ports not to allocate dynamically is now
a bitmask configurable via sysctl([38]).  The default values
have not changed.  If one wants to change the list it should
be done early on in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.25 1997/02/28 03:44:53 angelos Exp $	*/
a198 1
	register struct in_ifaddr *ia;
d308 3
a310 17
	for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
		if (ip->ip_dst.s_addr == ia->ia_addr.sin_addr.s_addr)
			goto ours;
		if (((ip_directedbcast == 0) || (ip_directedbcast &&
		    ia->ia_ifp == m->m_pkthdr.rcvif)) &&
		    (ia->ia_ifp->if_flags & IFF_BROADCAST)) {
			if (ip->ip_dst.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
			    ip->ip_dst.s_addr == ia->ia_netbroadcast.s_addr ||
			    /*
			     * Look for all-0's host part (old broadcast addr),
			     * either for subnet or net.
			     */
			    ip->ip_dst.s_addr == ia->ia_subnet ||
			    ip->ip_dst.s_addr == ia->ia_net)
				goto ours;
		}
	}
d464 31
@


1.25
log
@IPsec socket API hooks are in.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.24 1997/02/22 13:25:28 angelos Exp $	*/
d107 1
d160 2
d177 7
@


1.24
log
@Fixed problem in ip_weadvertise().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.23 1997/02/22 05:56:48 angelos Exp $	*/
d97 4
@


1.23
log
@ICMP redirects will not be sent if we do proxy arp pointing to ourselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.22 1997/02/13 16:26:58 deraadt Exp $	*/
d56 1
d950 2
d953 1
a953 1
    
d968 11
a978 2
	if(ifa_ifwithaddr(sintosa(&sin)))
	  return 1;
@


1.22
log
@off-by-one-slot for IP timestamp option data inserts, PR#103, andreas.gunnarsson@@emw.ericsson.se
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.21 1997/02/11 18:04:03 deraadt Exp $	*/
d60 1
d143 2
d941 31
d1153 2
d1159 2
a1160 1
	    ipsendredirects && !srcrt) {
@


1.21
log
@ensure ipt->ipt_ptr is right; pr#96, andreas.gunnarsson@@emw.ericsson.se
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.20 1997/01/26 01:23:43 tholo Exp $	*/
d829 1
a829 1
			if (ipt->ipt_ptr > ipt->ipt_len - sizeof (int32_t)) {
d841 1
a841 1
				if (ipt->ipt_ptr + sizeof(n_time) +
d855 1
a855 1
				if (ipt->ipt_ptr + sizeof(n_time) +
@


1.20
log
@Make ip_len and ip_off unsigned values; don't transmit or accept packets
larger than the maximum IP packet size.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.19 1996/10/27 00:47:33 deraadt Exp $	*/
d827 1
a827 1
			if (ipt->ipt_len < 5)
@


1.19
log
@record route is not a problem; thanks bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.18 1996/10/18 03:04:54 tholo Exp $	*/
d572 2
a573 1
	 * Reassembly is complete; concatenate fragments.
d577 5
@


1.18
log
@Do not run IP defragmentation routines unneccecarily; NetBSD PR# 2772
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.17 1996/09/02 18:14:19 dm Exp $	*/
a791 12
				goto bad;
			}

			if (!ip_dosourceroute) {
				char buf[4*sizeof "123"];

				strcpy(buf, inet_ntoa(ip->ip_dst));
				log(LOG_WARNING,
				    "attempted source route from %s to %s\n",
				    inet_ntoa(ip->ip_src), buf);
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
@


1.17
log
@Don't drain the protocol queues at interrupt level.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.16 1996/08/14 07:50:13 deraadt Exp $	*/
d386 1
a386 1
	if (ip->ip_off &~ IP_DF) {
@


1.16
log
@ipaddrs are int; like many other things found after spotting a similar netbsd commit...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.15 1996/08/02 18:21:00 tholo Exp $	*/
d185 2
@


1.15
log
@Allow viewing of net.inet.ip.sourceroute in secure mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.14 1996/07/29 02:34:30 downsj Exp $	*/
d1076 1
a1076 1
		printf("forward: src %lx dst %x ttl %x\n", ip->ip_src.s_addr,
d1140 1
a1140 1
			printf("redirect (%d) to %lx\n", code, (u_int32_t)dest);
@


1.14
log
@From FreeBSD (with slightly different sysctl names):

"... Allow the user to nominate one of three ranges of port numbers as
candidates for selecting a local address to replace a zero port number.
The ranges are selected via a setsockopt(s, IPPROTO_IP, IP_PORTRANGE, &arg)
call.  The three ranges are: default, high (to bypass firewalls) and
low (to get a port below 1024).

The default and high port ranges are sysctl settable under sysctl
net.inet.ip.portrange.* [net.inet.ip.portfirst, net.inet.ip.portlast,
net.inet.ip.porthifirst, and net.inet.ip.porthilast currently in OpenBSD.]

This code also fixes a potential deadlock if the system accidently ran out
of local port addresses. It'd drop into an infinite while loop.

The secure port selection (for root) should reduce overheads and increase
reliability of rlogin/rlogind/rsh/rshd if they are modified to take
advantage of it."
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.13 1996/07/18 05:01:04 dm Exp $	*/
d1223 1
a1223 1
		if (securelevel > 0)
@


1.13
log
@ipfilter 3.1.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.12 1996/05/07 15:20:25 mickey Exp $	*/
d96 6
d1230 12
@


1.12
log
@from NetBSD PR#2296:
Laine Stump: some icmp destination unreachable packets contain garbage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_input.c,v 1.10 1996/03/09 21:30:22 dm Exp $	*/
d103 2
a104 2
int	(*fr_checkp) __P((struct ip *, int, struct ifnet *, int, struct mbuf **)
);
@


1.11
log
@partial sync with netbsd 960418, more to come
@
text
@d1105 1
a1105 1
	 * Save at most 64 bytes of the packet in case
d1108 1
a1108 1
	mcopy = m_copy(m, 0, imin((int)ip->ip_len, 64));
@


1.10
log
@restored IP filtering
@
text
@d1 2
a2 2
/*	$OpenBSD: ip_input.c,v 1.9 1996/03/03 22:30:37 niklas Exp $	*/
/*	$NetBSD: ip_input.c,v 1.28 1996/02/13 23:42:37 christos Exp $	*/
d969 1
a969 1
		printf(" hops %lx", ntohl(mtod(m, struct in_addr *)->s_addr));
d989 1
a989 1
			printf(" %lx", ntohl(q->s_addr));
d999 1
a999 1
		printf(" %lx\n", ntohl(q->s_addr));
@


1.9
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 5
d255 14
@


1.8
log
@IP filter 3.0.1
@
text
@d1 2
a2 1
/*	$NetBSD: ip_input.c,v 1.25 1995/11/21 01:07:34 cgd Exp $	*/
d50 4
d76 11
d89 1
a89 1
int	ip_dosourceroute = 0;	/* no source routing unless sysctl'd to enable */
d91 1
a101 3
#if defined(IPFILTER) || defined(IPFILTER_LKM)
int	(*fr_checkp) __P((struct ip *, int, struct ifnet *, int, struct mbuf **));
#endif
d217 1
a217 1
	if (ip->ip_sum = in_cksum(m, hlen)) {
a250 13
#if defined(IPFILTER) || defined(IPFILTER_LKM)
	/*
	 * Check if we want to allow this packet to be processed.
	 * Consider it to be bad if not.
	 */
	{
		struct mbuf *m0 = m;
		if (fr_checkp && (*fr_checkp)(ip, hlen, m->m_pkthdr.rcvif, 0, &m0))
			goto next;
		else
		  ip = mtod(m = m0, struct ip *);
	}
#endif
d267 2
a268 4
		if (
#ifdef	DIRECTED_BROADCAST
		    ia->ia_ifp == m->m_pkthdr.rcvif &&
#endif
d388 2
a389 2
		        /*
		         * Make sure that fragments have a data length
d391 1
a391 1
		         */
d767 13
d1043 1
a1043 1
	int error, type = 0, code;
d1052 1
a1052 1
			ip->ip_dst.s_addr, ip->ip_ttl);
d1115 1
a1115 1
		        printf("redirect (%d) to %lx\n", code, (u_int32_t)dest);
d1120 2
a1121 5
	error = ip_output(m, (struct mbuf *)0, &ipforward_rt, IP_FORWARDING
#ifdef DIRECTED_BROADCAST
			    | IP_ALLOWBROADCAST
#endif
						, 0);
d1195 10
a1204 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_dosourceroute));
@


1.7
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d86 1
a86 2
int	fr_nullcheck();
int	(*fr_checkp) __P((struct ip *, int, struct ifnet *, int)) = fr_nullcheck;
d242 7
a248 2
	if ((*fr_checkp)(ip, hlen, m->m_pkthdr.rcvif, 0))
		goto bad;
a1191 7

#if defined(IPFILTER) || defined(IPFILTER_LKM)
int	fr_nullcheck()
{
	return 0;
}
#endif
@


1.6
log
@re-add my source routing stuff (geeezzz)
@
text
@d85 4
d238 8
d1188 7
@


1.5
log
@from netbsd:
make netinet work on systems where pointers and longs are 64 bits
(like the alpha).  Biggest problem: IP headers were overlayed with
structure which included pointers, and which therefore didn't overlay
properly on 64-bit machines.  Solution: instead of threading pointers
through IP header overlays, add a "queue element" structure to do
the threading, and point it at the ip headers.
@
text
@d48 1
d73 1
d86 12
d707 13
d1023 2
a1024 2
		printf("forward: src %x dst %x ttl %x\n", ip->ip_src,
			ip->ip_dst, ip->ip_ttl);
d1169 2
@


1.4
log
@add inet_ntoa() to the kernel. use it to log nicer messages. idea from freebsd
@
text
@d1 1
a1 1
/*	$NetBSD: ip_input.c,v 1.24 1995/08/12 23:59:36 mycroft Exp $	*/
a47 1
#include <sys/syslog.h>
a71 1
int	ip_dosourceroute = 0;	/* no source routing unless sysctl'd to enable */
a83 12
char *
inet_ntoa(ina)
	struct in_addr ina;
{
	static char buf[4*sizeof "123"];
	unsigned char *ucp = (unsigned char *)&ina;

	sprintf(buf, "%d.%d.%d.%d", ucp[0] & 0xff, ucp[1] & 0xff,
	    ucp[2] & 0xff, ucp[3] & 0xff);
	return (buf);
}

d120 1
a120 1
	ipq.next = ipq.prev = &ipq;
d140 2
a141 1
	int hlen, s;
d342 1
a342 1
		for (fp = ipq.next; fp != &ipq; fp = fp->next)
d353 1
a353 1
		 * set ip_mff if more fragments are expected,
d357 4
a360 4
		((struct ipasfrag *)ip)->ipf_mff &= ~1;
		if (ip->ip_off & IP_MF) {
			/*
			 * Make sure that fragments have a data length
d362 1
a362 1
			 */
a366 1
			((struct ipasfrag *)ip)->ipf_mff |= 1;
d375 1
a375 1
		if (((struct ipasfrag *)ip)->ipf_mff & 1 || ip->ip_off) {
d377 9
a385 1
			ip = ip_reass((struct ipasfrag *)ip, fp);
d414 2
a415 2
ip_reass(ip, fp)
	register struct ipasfrag *ip;
d418 3
a420 2
	register struct mbuf *m = dtom(ip);
	register struct ipasfrag *q;
d422 1
a422 1
	int hlen = ip->ip_hl << 2;
d439 1
a439 1
		insque(fp, &ipq);
d441 6
a446 6
		fp->ipq_p = ip->ip_p;
		fp->ipq_id = ip->ip_id;
		fp->ipq_next = fp->ipq_prev = (struct ipasfrag *)fp;
		fp->ipq_src = ((struct ip *)ip)->ip_src;
		fp->ipq_dst = ((struct ip *)ip)->ip_dst;
		q = (struct ipasfrag *)fp;
d453 3
a455 2
	for (q = fp->ipq_next; q != (struct ipasfrag *)fp; q = q->ipf_next)
		if (q->ip_off > ip->ip_off)
d463 3
a465 2
	if (q->ipf_prev != (struct ipasfrag *)fp) {
		i = q->ipf_prev->ip_off + q->ipf_prev->ip_len - ip->ip_off;
d467 1
a467 1
			if (i >= ip->ip_len)
d469 3
a471 3
			m_adj(dtom(ip), i);
			ip->ip_off += i;
			ip->ip_len -= i;
d479 8
a486 6
	while (q != (struct ipasfrag *)fp && ip->ip_off + ip->ip_len > q->ip_off) {
		i = (ip->ip_off + ip->ip_len) - q->ip_off;
		if (i < q->ip_len) {
			q->ip_len -= i;
			q->ip_off += i;
			m_adj(dtom(q), i);
d489 4
a492 3
		q = q->ipf_next;
		m_freem(dtom(q->ipf_prev));
		ip_deq(q->ipf_prev);
d500 5
a504 1
	ip_enq(ip, q->ipf_prev);
d506 3
a508 2
	for (q = fp->ipq_next; q != (struct ipasfrag *)fp; q = q->ipf_next) {
		if (q->ip_off != next)
d510 1
a510 1
		next += q->ip_len;
d512 1
a512 1
	if (q->ipf_prev->ipf_mff & 1)
d518 3
a520 2
	q = fp->ipq_next;
	m = dtom(q);
d524 6
a529 4
	q = q->ipf_next;
	while (q != (struct ipasfrag *)fp) {
		t = dtom(q);
		q = q->ipf_next;
a538 1
	ip = fp->ipq_next;
d540 3
a542 4
	ip->ipf_mff &= ~1;
	((struct ip *)ip)->ip_src = fp->ipq_src;
	((struct ip *)ip)->ip_dst = fp->ipq_dst;
	remque(fp);
a543 1
	m = dtom(ip);
d553 1
a553 1
	return ((struct ip *)ip);
d558 1
d570 1
a570 1
	register struct ipasfrag *q, *p;
d572 5
a576 4
	for (q = fp->ipq_next; q != (struct ipasfrag *)fp; q = p) {
		p = q->ipf_next;
		ip_deq(q);
		m_freem(dtom(q));
d578 1
a578 1
	remque(fp);
a582 27
 * Put an ip fragment on a reassembly chain.
 * Like insque, but pointers in middle of structure.
 */
void
ip_enq(p, prev)
	register struct ipasfrag *p, *prev;
{

	p->ipf_prev = prev;
	p->ipf_next = prev->ipf_next;
	prev->ipf_next->ipf_prev = p;
	prev->ipf_next = p;
}

/*
 * To ip_enq as remque is to insque.
 */
void
ip_deq(p)
	register struct ipasfrag *p;
{

	p->ipf_prev->ipf_next = p->ipf_next;
	p->ipf_next->ipf_prev = p->ipf_prev;
}

/*
d590 1
a590 1
	register struct ipq *fp;
d593 3
a595 9
	fp = ipq.next;
	if (fp == 0) {
		splx(s);
		return;
	}
	while (fp != &ipq) {
		--fp->ipq_ttl;
		fp = fp->next;
		if (fp->prev->ipq_ttl == 0) {
d597 1
a597 1
			ip_freef(fp->prev);
d610 1
a610 1
	while (ipq.next != &ipq) {
d612 1
a612 1
		ip_freef(ipq.next);
a692 13

			if (!ip_dosourceroute) {
				char buf[4*sizeof "123"];

				strcpy(buf, inet_ntoa(ip->ip_dst));
				log(LOG_WARNING,
				    "attempted source route from %s to %s\n",
				    inet_ntoa(ip->ip_src), buf);
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				goto bad;
			}

d996 2
a997 2
		printf("forward: src %lx dst %x ttl %x\n", ip->ip_src.s_addr,
			ip->ip_dst.s_addr, ip->ip_ttl);
d1060 1
a1060 1
			printf("redirect (%d) to %lx\n", code, (u_int32_t)dest);
a1141 2
	case IPCTL_SOURCEROUTE:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ip_dosourceroute));
@


1.3
log
@log source route attempts when source routing is disabled
@
text
@d86 12
d372 2
a373 2
		        /*
		         * Make sure that fragments have a data length
d375 1
a375 1
		         */
d721 3
d725 2
a726 3
				    "attempted source route from %x to %x\n",
				    ntohl(ip->ip_src.s_addr),
				    ntohl(ip->ip_dst.s_addr));
d1035 2
a1036 2
		printf("forward: src %x dst %x ttl %x\n", ip->ip_src,
			ip->ip_dst, ip->ip_ttl);
@


1.2
log
@add sysctl net.inet.ip.sourceroute option; default to 0. copied from freebsd
@
text
@a708 4
#if 0
				char buf[4*sizeof "123"];
				strcpy(buf, inet_ntoa(ip->ip_dst));

d710 3
a712 3
				    "attempted source route from %s to %s\n",
				    inet_ntoa(ip->ip_src), buf);
#endif
@


1.1
log
@Initial revision
@
text
@d48 1
d73 1
d707 15
d1089 1
a1089 1
		        printf("redirect (%d) to %lx\n", code, (u_int32_t)dest);
d1171 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
