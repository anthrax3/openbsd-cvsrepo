head	1.145;
access;
symbols
	OPENBSD_6_0:1.135.0.6
	OPENBSD_6_0_BASE:1.135
	OPENBSD_5_9:1.135.0.2
	OPENBSD_5_9_BASE:1.135
	OPENBSD_5_8:1.133.0.4
	OPENBSD_5_8_BASE:1.133
	OPENBSD_5_7:1.126.0.2
	OPENBSD_5_7_BASE:1.126
	OPENBSD_5_6:1.122.0.4
	OPENBSD_5_6_BASE:1.122
	OPENBSD_5_5:1.119.0.4
	OPENBSD_5_5_BASE:1.119
	OPENBSD_5_4:1.115.0.2
	OPENBSD_5_4_BASE:1.115
	OPENBSD_5_3:1.108.0.2
	OPENBSD_5_3_BASE:1.108
	OPENBSD_5_2:1.106.0.4
	OPENBSD_5_2_BASE:1.106
	OPENBSD_5_1_BASE:1.106
	OPENBSD_5_1:1.106.0.2
	OPENBSD_5_0:1.103.0.2
	OPENBSD_5_0_BASE:1.103
	OPENBSD_4_9:1.99.0.2
	OPENBSD_4_9_BASE:1.99
	OPENBSD_4_8:1.98.0.2
	OPENBSD_4_8_BASE:1.98
	OPENBSD_4_7:1.94.0.2
	OPENBSD_4_7_BASE:1.94
	OPENBSD_4_6:1.91.0.6
	OPENBSD_4_6_BASE:1.91
	OPENBSD_4_5:1.91.0.2
	OPENBSD_4_5_BASE:1.91
	OPENBSD_4_4:1.88.0.2
	OPENBSD_4_4_BASE:1.88
	OPENBSD_4_3:1.85.0.2
	OPENBSD_4_3_BASE:1.85
	OPENBSD_4_2:1.84.0.2
	OPENBSD_4_2_BASE:1.84
	OPENBSD_4_1:1.83.0.2
	OPENBSD_4_1_BASE:1.83
	OPENBSD_4_0:1.79.0.2
	OPENBSD_4_0_BASE:1.79
	OPENBSD_3_9:1.77.0.2
	OPENBSD_3_9_BASE:1.77
	OPENBSD_3_8:1.76.0.2
	OPENBSD_3_8_BASE:1.76
	OPENBSD_3_7:1.75.0.2
	OPENBSD_3_7_BASE:1.75
	OPENBSD_3_6:1.74.0.2
	OPENBSD_3_6_BASE:1.74
	SMP_SYNC_A:1.72
	SMP_SYNC_B:1.72
	OPENBSD_3_5:1.71.0.2
	OPENBSD_3_5_BASE:1.71
	OPENBSD_3_4:1.69.0.2
	OPENBSD_3_4_BASE:1.69
	UBC_SYNC_A:1.64
	OPENBSD_3_3:1.63.0.2
	OPENBSD_3_3_BASE:1.63
	OPENBSD_3_2:1.61.0.2
	OPENBSD_3_2_BASE:1.61
	OPENBSD_3_1:1.55.0.2
	OPENBSD_3_1_BASE:1.55
	UBC_SYNC_B:1.61
	UBC:1.54.0.2
	UBC_BASE:1.54
	OPENBSD_3_0:1.53.0.2
	OPENBSD_3_0_BASE:1.53
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.19.0.2
	SMP_BASE:1.19;
locks; strict;
comment	@ * @;


1.145
date	2017.02.28.09.59.34;	author mpi;	state Exp;
branches;
next	1.144;
commitid	T3PPWgqAoWqJuqmb;

1.144
date	2017.02.08.12.37.43;	author bluhm;	state Exp;
branches;
next	1.143;
commitid	h9Q88VpdY8UDaqEf;

1.143
date	2017.02.07.22.28.37;	author bluhm;	state Exp;
branches;
next	1.142;
commitid	M4FFpRkmaBUO6y38;

1.142
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.141;
commitid	2R0NOjEDy2jGtnjL;

1.141
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.140;
commitid	3e3CkrbYekyVOcxy;

1.140
date	2017.01.26.13.03.47;	author bluhm;	state Exp;
branches;
next	1.139;
commitid	wBlwxPiTlfo8m7xr;

1.139
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.138;
commitid	pVtptbHA3yk4jSpN;

1.138
date	2017.01.23.09.10.06;	author mpi;	state Exp;
branches;
next	1.137;
commitid	T5wSXqiYYXU9lZno;

1.137
date	2017.01.20.04.22.58;	author mpi;	state Exp;
branches;
next	1.136;
commitid	9nOt5A88b001xOMi;

1.136
date	2016.09.02.09.39.32;	author vgross;	state Exp;
branches;
next	1.135;
commitid	ZAyx9RbdVJtASCJK;

1.135
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.134;
commitid	PcRGyy4jlpJbKkXz;

1.134
date	2015.09.09.12.50.08;	author mpi;	state Exp;
branches;
next	1.133;
commitid	3dyjGr1P4z63tEd8;

1.133
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.132;
commitid	h7z8lokZ0dFyuWpg;

1.132
date	2015.06.11.15.59.17;	author mikeb;	state Exp;
branches;
next	1.131;
commitid	m5XqNI2MUatfnThg;

1.131
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.130;
commitid	hN5bFCE56DrAjl99;

1.130
date	2015.04.17.11.04.02;	author mikeb;	state Exp;
branches;
next	1.129;
commitid	6glXvFR7NxzCcdRd;

1.129
date	2015.04.14.14.20.01;	author mikeb;	state Exp;
branches;
next	1.128;
commitid	70u0dWUlToMcLCnj;

1.128
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.127;
commitid	c7ei8kPelCOOwHXy;

1.127
date	2015.03.26.12.21.37;	author mikeb;	state Exp;
branches;
next	1.126;
commitid	GUv4gLlXi8Tx36WA;

1.126
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.125;
commitid	VK3ncyiP3NS1N4Sy;

1.125
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.124;
commitid	zhW8jJrfVCoAthrR;

1.124
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.123;
commitid	t9FBKDfc4VDxpEy2;

1.123
date	2014.11.20.14.51.42;	author krw;	state Exp;
branches;
next	1.122;
commitid	dOUqRDzYiPQXkCLL;

1.122
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.121;
commitid	DQakU8LLWV6Iwx84;

1.121
date	2014.07.09.09.30.49;	author henning;	state Exp;
branches;
next	1.120;
commitid	Nnxg8ONtI4Ep9pUb;

1.120
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.119;

1.119
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.118;

1.118
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.117;

1.117
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.116;

1.116
date	2013.10.17.16.27.44;	author bluhm;	state Exp;
branches;
next	1.115;

1.115
date	2013.06.01.16.29.00;	author bluhm;	state Exp;
branches;
next	1.114;

1.114
date	2013.04.24.10.17.08;	author mpi;	state Exp;
branches;
next	1.113;

1.113
date	2013.04.11.12.06.25;	author mpi;	state Exp;
branches;
next	1.112;

1.112
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.111;

1.111
date	2013.03.31.00.59.52;	author bluhm;	state Exp;
branches;
next	1.110;

1.110
date	2013.03.28.23.10.06;	author tedu;	state Exp;
branches;
next	1.109;

1.109
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.108;

1.108
date	2012.09.26.14.53.23;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.106;

1.106
date	2011.12.22.13.36.06;	author sperreault;	state Exp;
branches;
next	1.105;

1.105
date	2011.12.21.14.53.26;	author sperreault;	state Exp;
branches;
next	1.104;

1.104
date	2011.12.19.02.43.19;	author yasuoka;	state Exp;
branches;
next	1.103;

1.103
date	2011.04.26.22.30.38;	author bluhm;	state Exp;
branches;
next	1.102;

1.102
date	2011.04.06.19.15.34;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2011.04.03.15.51.09;	author henning;	state Exp;
branches;
next	1.100;

1.100
date	2011.03.05.01.53.16;	author bluhm;	state Exp;
branches;
next	1.99;

1.99
date	2010.12.21.19.16.15;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.29.21.28.38;	author reyk;	state Exp;
branches;
next	1.95;

1.95
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.94;

1.94
date	2010.01.02.18.35.48;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2009.08.09.12.47.50;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2008.10.22.23.04.45;	author mpf;	state Exp;
branches;
next	1.90;

1.90
date	2008.10.22.14.36.08;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2008.08.26.12.18.01;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2008.07.24.10.55.44;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2008.06.14.23.18.20;	author todd;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.11.17.39.51;	author canacar;	state Exp;
branches;
next	1.85;

1.85
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2007.05.28.17.16.39;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2007.02.08.15.25.30;	author itojun;	state Exp;
branches;
next	1.82;

1.82
date	2006.12.15.09.32.30;	author otto;	state Exp;
branches;
next	1.81;

1.81
date	2006.12.05.09.17.12;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.79;

1.79
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2006.01.13.10.11.23;	author mpf;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.31.03.52.19;	author pascoe;	state Exp;
branches;
next	1.75;

1.75
date	2004.11.25.21.54.54;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.73;

1.73
date	2004.06.21.20.44.54;	author itojun;	state Exp;
branches;
next	1.72;

1.72
date	2004.04.18.16.41.40;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2004.02.17.12.07.45;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2003.07.28.10.10.16;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2003.07.24.11.13.47;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.66;

1.66
date	2003.07.08.11.01.20;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2003.07.04.16.40.55;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.63;

1.63
date	2003.02.20.18.35.43;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2003.02.20.18.33.49;	author jason;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.28.19.07.03;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.25.00.38.54;	author angelos;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.25.00.20.38;	author angelos;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.13.08.02.36;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.09.00.58.33;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.23.21.34.53;	author provos;	state Exp;
branches;
next	1.54;

1.54
date	2001.12.06.22.52.10;	author angelos;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2001.08.09.15.44.32;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.08.15.07.04;	author jjbg;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.07.14.07.47;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.06.19.35.38;	author jjbg;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.05.16.45.55;	author jjbg;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.26.04.17.57;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.25.05.11.59;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.24.18.22.47;	author provos;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.23.16.15.56;	author fgsch;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.19.00.48.23;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.08.03.13.15;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.05.11.10.12;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.29.01.19.37;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.27.03.49.14;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.27.03.37.23;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.20.08.33.33;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.11.17.20.11;	author aaron;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.30.19.22.54;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.28.20.03.06;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.15.06.31.00;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.19.03.20.59;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.17.19.52.24;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.11.21.11.08;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.20.04.54.58;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.19.17.11.32;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.18.19.10.50;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.18.19.05.50;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.18.05.58.46;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.18.00.24.11;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.29.10.15.22;	author angelos;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.03.29.09.37.02;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.29.08.50.38;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.17.10.25.23;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.07.06.09.09;	author itojun;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2000.01.27.08.09.12;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.25.17.18.59;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.15.20.03.05;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.15.19.37.28;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.15.18.27.51;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.10.04.16.52;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.10.02.45.12;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.10.01.23.27;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.10.01.20.53;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.10.01.09.16;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.09.23.42.37;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.08.01.59.25;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.03.12.58.13;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.02.11.12.03;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.02.10.56.32;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.12.31.22.19.43;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.25.07.09.43;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.09.10.15.23;	author angelos;	state Exp;
branches;
next	;

1.19.2.1
date	2000.03.24.09.09.38;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.05.14.22.40.14;	author niklas;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.07.04.10.55.01;	author niklas;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.19.2.7;

1.19.2.7
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.19.2.8;

1.19.2.8
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.19.2.9;

1.19.2.9
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.23.2.1
date	2000.07.12.13.53.33;	author jason;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2000.09.18.17.02.51;	author jason;	state Exp;
branches;
next	;

1.54.2.1
date	2002.01.31.22.55.45;	author niklas;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.54.2.4;

1.54.2.4
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.145
log
@Some refactoring in ip6_input() needed to un-KERNEL_LOCK() the IPv6
forwarding path.

Rename ip6_ours() in ip6_local() as this function dispatches packets
to the upper layer.

Introduce ip6_ours() and get rid of 'goto hbhcheck'.  This function
will be later used to enqueue local packets.

As a bonus this reduces differences with IPv4.

Inputs and ok bluhm@@
@
text
@/*	$OpenBSD: ipsec_input.c,v 1.144 2017/02/08 12:37:43 bluhm Exp $	*/
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece,
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/protosw.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/netisr.h>
#include <net/bpf.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#ifdef INET6
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/ip6protosw.h>
#endif /* INET6 */

#include <netinet/ip_ipsp.h>
#include <netinet/ip_esp.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_ipcomp.h>

#include <net/if_enc.h>

#include "bpfilter.h"

void ipsec_common_ctlinput(u_int, int, struct sockaddr *, void *, int);

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

/* sysctl variables */
int esp_enable = 1;
int ah_enable = 1;
int ipcomp_enable = 0;

int *espctl_vars[ESPCTL_MAXID] = ESPCTL_VARS;
int *ahctl_vars[AHCTL_MAXID] = AHCTL_VARS;
int *ipcompctl_vars[IPCOMPCTL_MAXID] = IPCOMPCTL_VARS;

/*
 * ipsec_common_input() gets called when we receive an IPsec-protected packet
 * in IPv4 or IPv6. All it does is find the right TDB and call the appropriate
 * transform. The callback takes care of further processing (like ingress
 * filtering).
 */
int
ipsec_common_input(struct mbuf *m, int skip, int protoff, int af, int sproto,
    int udpencap)
{
#define IPSEC_ISTAT(x,y,z) (sproto == IPPROTO_ESP ? (x)++ : \
			    sproto == IPPROTO_AH ? (y)++ : (z)++)

	union sockaddr_union dst_address;
	struct tdb *tdbp;
	struct ifnet *encif;
	u_int32_t spi;
	u_int16_t cpi;
	int error;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	splsoftassert(IPL_SOFTNET);

	IPSEC_ISTAT(espstat.esps_input, ahstat.ahs_input,
	    ipcompstat.ipcomps_input);

	if (m == NULL) {
		DPRINTF(("ipsec_common_input(): NULL packet received\n"));
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
		    ipcompstat.ipcomps_hdrops);
		return EINVAL;
	}

	if ((sproto == IPPROTO_ESP && !esp_enable) ||
	    (sproto == IPPROTO_AH && !ah_enable) ||
#if NPF > 0
	    (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) ||
#endif
	    (sproto == IPPROTO_IPCOMP && !ipcomp_enable)) {
		switch (af) {
		case AF_INET:
			rip_input(&m, &skip, sproto);
			break;
#ifdef INET6
		case AF_INET6:
			rip6_input(&m, &skip, sproto);
			break;
#endif /* INET6 */
		default:
			DPRINTF(("ipsec_common_input(): unsupported protocol "
			    "family %d\n", af));
			m_freem(m);
			IPSEC_ISTAT(espstat.esps_nopf, ahstat.ahs_nopf,
			    ipcompstat.ipcomps_nopf);
			return EPFNOSUPPORT;
		}
		return 0;
	}
	if ((sproto == IPPROTO_IPCOMP) && (m->m_flags & M_COMP)) {
		m_freem(m);
		ipcompstat.ipcomps_pdrops++;
		DPRINTF(("ipsec_common_input(): repeated decompression\n"));
		return EINVAL;
	}

	if (m->m_pkthdr.len - skip < 2 * sizeof(u_int32_t)) {
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
		    ipcompstat.ipcomps_hdrops);
		DPRINTF(("ipsec_common_input(): packet too small\n"));
		return EINVAL;
	}

	/* Retrieve the SPI from the relevant IPsec header */
	if (sproto == IPPROTO_ESP)
		m_copydata(m, skip, sizeof(u_int32_t), (caddr_t) &spi);
	else if (sproto == IPPROTO_AH)
		m_copydata(m, skip + sizeof(u_int32_t), sizeof(u_int32_t),
		    (caddr_t) &spi);
	else if (sproto == IPPROTO_IPCOMP) {
		m_copydata(m, skip + sizeof(u_int16_t), sizeof(u_int16_t),
		    (caddr_t) &cpi);
		spi = ntohl(htons(cpi));
	}

	/*
	 * Find tunnel control block and (indirectly) call the appropriate
	 * kernel crypto routine. The resulting mbuf chain is a valid
	 * IP packet ready to go through input processing.
	 */

	memset(&dst_address, 0, sizeof(dst_address));
	dst_address.sa.sa_family = af;

	switch (af) {
	case AF_INET:
		dst_address.sin.sin_len = sizeof(struct sockaddr_in);
		m_copydata(m, offsetof(struct ip, ip_dst),
		    sizeof(struct in_addr),
		    (caddr_t) &(dst_address.sin.sin_addr));
		break;

#ifdef INET6
	case AF_INET6:
		dst_address.sin6.sin6_len = sizeof(struct sockaddr_in6);
		m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		    sizeof(struct in6_addr),
		    (caddr_t) &(dst_address.sin6.sin6_addr));
		in6_recoverscope(&dst_address.sin6,
		    &dst_address.sin6.sin6_addr);
		break;
#endif /* INET6 */

	default:
		DPRINTF(("ipsec_common_input(): unsupported protocol "
		    "family %d\n", af));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_nopf, ahstat.ahs_nopf,
		    ipcompstat.ipcomps_nopf);
		return EPFNOSUPPORT;
	}

	tdbp = gettdb(rtable_l2(m->m_pkthdr.ph_rtableid),
	    spi, &dst_address, sproto);
	if (tdbp == NULL) {
		DPRINTF(("ipsec_common_input(): could not find SA for "
		    "packet to %s, spi %08x\n",
		    ipsp_address(&dst_address, buf, sizeof(buf)), ntohl(spi)));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_notdb, ahstat.ahs_notdb,
		    ipcompstat.ipcomps_notdb);
		return ENOENT;
	}

	if (tdbp->tdb_flags & TDBF_INVALID) {
		DPRINTF(("ipsec_common_input(): attempted to use invalid "
		    "SA %s/%08x/%u\n", ipsp_address(&dst_address, buf,
		    sizeof(buf)), ntohl(spi), tdbp->tdb_sproto));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_invalid, ahstat.ahs_invalid,
		    ipcompstat.ipcomps_invalid);
		return EINVAL;
	}

	if (udpencap && !(tdbp->tdb_flags & TDBF_UDPENCAP)) {
		DPRINTF(("ipsec_common_input(): attempted to use non-udpencap "
		    "SA %s/%08x/%u\n", ipsp_address(&dst_address, buf,
		    sizeof(buf)), ntohl(spi), tdbp->tdb_sproto));
		m_freem(m);
		espstat.esps_udpinval++;
		return EINVAL;
	}

	if (!udpencap && (tdbp->tdb_flags & TDBF_UDPENCAP)) {
		DPRINTF(("ipsec_common_input(): attempted to use udpencap "
		    "SA %s/%08x/%u\n", ipsp_address(&dst_address, buf,
		    sizeof(buf)), ntohl(spi), tdbp->tdb_sproto));
		m_freem(m);
		espstat.esps_udpneeded++;
		return EINVAL;
	}

	if (tdbp->tdb_xform == NULL) {
		DPRINTF(("ipsec_common_input(): attempted to use uninitialized "
		    "SA %s/%08x/%u\n", ipsp_address(&dst_address, buf,
		    sizeof(buf)), ntohl(spi), tdbp->tdb_sproto));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_noxform, ahstat.ahs_noxform,
		    ipcompstat.ipcomps_noxform);
		return ENXIO;
	}

	if (sproto != IPPROTO_IPCOMP) {
		if ((encif = enc_getif(tdbp->tdb_rdomain,
		    tdbp->tdb_tap)) == NULL) {
			DPRINTF(("ipsec_common_input(): "
			    "no enc%u interface for SA %s/%08x/%u\n",
			    tdbp->tdb_tap, ipsp_address(&dst_address, buf,
			    sizeof(buf)), ntohl(spi), tdbp->tdb_sproto));
			m_freem(m);

			IPSEC_ISTAT(espstat.esps_pdrops,
			    ahstat.ahs_pdrops,
			    ipcompstat.ipcomps_pdrops);
			return EACCES;
		}

		/* XXX This conflicts with the scoped nature of IPv6 */
		m->m_pkthdr.ph_ifidx = encif->if_index;
	}

	/* Register first use, setup expiration timer. */
	if (tdbp->tdb_first_use == 0) {
		tdbp->tdb_first_use = time_second;
		if (tdbp->tdb_flags & TDBF_FIRSTUSE)
			timeout_add_sec(&tdbp->tdb_first_tmo,
			    tdbp->tdb_exp_first_use);
		if (tdbp->tdb_flags & TDBF_SOFT_FIRSTUSE)
			timeout_add_sec(&tdbp->tdb_sfirst_tmo,
			    tdbp->tdb_soft_first_use);
	}

	/*
	 * Call appropriate transform and return -- callback takes care of
	 * everything else.
	 */
	error = (*(tdbp->tdb_xform->xf_input))(m, tdbp, skip, protoff);
	return error;
}

/*
 * IPsec input callback, called by the transform callback. Takes care of
 * filtering and other sanity checks on the processed packet.
 */
void
ipsec_common_input_cb(struct mbuf *m, struct tdb *tdbp, int skip, int protoff)
{
	int af, sproto;
	u_int8_t prot;

#if NBPFILTER > 0
	struct ifnet *encif;
#endif

	struct ip *ip, ipn;

#ifdef INET6
	struct ip6_hdr *ip6, ip6n;
#endif /* INET6 */
	struct m_tag *mtag;
	struct tdb_ident *tdbi;

#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	af = tdbp->tdb_dst.sa.sa_family;
	sproto = tdbp->tdb_sproto;

	tdbp->tdb_last_used = time_second;

	/* Sanity check */
	if (m == NULL) {
		/* The called routine will print a message if necessary */
		IPSEC_ISTAT(espstat.esps_badkcr, ahstat.ahs_badkcr,
		    ipcompstat.ipcomps_badkcr);
		return;
	}

	/* Fix IPv4 header */
	if (af == AF_INET) {
		if ((m->m_len < skip) && ((m = m_pullup(m, skip)) == NULL)) {
			DPRINTF(("ipsec_common_input_cb(): processing failed "
			    "for SA %s/%08x\n", ipsp_address(&tdbp->tdb_dst,
			    buf, sizeof(buf)), ntohl(tdbp->tdb_spi)));
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
			    ipcompstat.ipcomps_hdrops);
			return;
		}

		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
		prot = ip->ip_p;

		/* IP-in-IP encapsulation */
		if (prot == IPPROTO_IPIP) {
			if (m->m_pkthdr.len - skip < sizeof(struct ip)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return;
			}
			/* ipn will now contain the inner IPv4 header */
			m_copydata(m, skip, sizeof(struct ip),
			    (caddr_t) &ipn);
		}

#ifdef INET6
		/* IPv6-in-IP encapsulation. */
		if (prot == IPPROTO_IPV6) {
			if (m->m_pkthdr.len - skip < sizeof(struct ip6_hdr)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return;
			}
			/* ip6n will now contain the inner IPv6 header. */
			m_copydata(m, skip, sizeof(struct ip6_hdr),
			    (caddr_t) &ip6n);
		}
#endif /* INET6 */
	}

#ifdef INET6
	/* Fix IPv6 header */
	if (af == AF_INET6)
	{
		if (m->m_len < sizeof(struct ip6_hdr) &&
		    (m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL) {

			DPRINTF(("ipsec_common_input_cb(): processing failed "
			    "for SA %s/%08x\n", ipsp_address(&tdbp->tdb_dst,
			    buf, sizeof(buf)), ntohl(tdbp->tdb_spi)));

			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
			    ipcompstat.ipcomps_hdrops);
			return;
		}

		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len - skip);

		/* Save protocol */
		m_copydata(m, protoff, 1, (caddr_t) &prot);

		/* IP-in-IP encapsulation */
		if (prot == IPPROTO_IPIP) {
			if (m->m_pkthdr.len - skip < sizeof(struct ip)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return;
			}
			/* ipn will now contain the inner IPv4 header */
			m_copydata(m, skip, sizeof(struct ip), (caddr_t) &ipn);
		}

		/* IPv6-in-IP encapsulation */
		if (prot == IPPROTO_IPV6) {
			if (m->m_pkthdr.len - skip < sizeof(struct ip6_hdr)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return;
			}
			/* ip6n will now contain the inner IPv6 header. */
			m_copydata(m, skip, sizeof(struct ip6_hdr),
			    (caddr_t) &ip6n);
		}
	}
#endif /* INET6 */

	/*
	 * Fix TCP/UDP checksum of UDP encapsulated transport mode ESP packet.
	 * (RFC3948 3.1.2)
	 */
	if ((af == AF_INET || af == AF_INET6) &&
	    (tdbp->tdb_flags & TDBF_UDPENCAP) &&
	    (tdbp->tdb_flags & TDBF_TUNNELING) == 0) {
		u_int16_t cksum;

		switch (prot) {
		case IPPROTO_UDP:
			if (m->m_pkthdr.len < skip + sizeof(struct udphdr)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return;
			}
			cksum = 0;
			m_copyback(m, skip + offsetof(struct udphdr, uh_sum),
			    sizeof(cksum), &cksum, M_NOWAIT);
#ifdef INET6
			if (af == AF_INET6) {
				cksum = in6_cksum(m, IPPROTO_UDP, skip,
				    m->m_pkthdr.len - skip);
				m_copyback(m, skip + offsetof(struct udphdr,
				    uh_sum), sizeof(cksum), &cksum, M_NOWAIT);
			}
#endif
			break;
		case IPPROTO_TCP:
			if (m->m_pkthdr.len < skip + sizeof(struct tcphdr)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return;
			}
			cksum = 0;
			m_copyback(m, skip + offsetof(struct tcphdr, th_sum),
			    sizeof(cksum), &cksum, M_NOWAIT);
			if (af == AF_INET)
				cksum = in4_cksum(m, IPPROTO_TCP, skip,
				    m->m_pkthdr.len - skip);
#ifdef INET6
			else if (af == AF_INET6)
				cksum = in6_cksum(m, IPPROTO_TCP, skip,
				    m->m_pkthdr.len - skip);
#endif
			m_copyback(m, skip + offsetof(struct tcphdr, th_sum),
			    sizeof(cksum), &cksum, M_NOWAIT);
			break;
		}
	}

	/*
	 * Record what we've done to the packet (under what SA it was
	 * processed).
	 */
	if (tdbp->tdb_sproto != IPPROTO_IPCOMP) {
		mtag = m_tag_get(PACKET_TAG_IPSEC_IN_DONE,
		    sizeof(struct tdb_ident), M_NOWAIT);
		if (mtag == NULL) {
			m_freem(m);
			DPRINTF(("ipsec_common_input_cb(): failed to "
			    "get tag\n"));
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
			    ipcompstat.ipcomps_hdrops);
			return;
		}

		tdbi = (struct tdb_ident *)(mtag + 1);
		bcopy(&tdbp->tdb_dst, &tdbi->dst,
		    sizeof(union sockaddr_union));
		tdbi->proto = tdbp->tdb_sproto;
		tdbi->spi = tdbp->tdb_spi;
		tdbi->rdomain = tdbp->tdb_rdomain;

		m_tag_prepend(m, mtag);
	}

	if (sproto == IPPROTO_ESP) {
		/* Packet is confidential ? */
		if (tdbp->tdb_encalgxform)
			m->m_flags |= M_CONF;

		/* Check if we had authenticated ESP. */
		if (tdbp->tdb_authalgxform)
			m->m_flags |= M_AUTH;
	} else if (sproto == IPPROTO_AH) {
		m->m_flags |= M_AUTH;
	} else if (sproto == IPPROTO_IPCOMP) {
		m->m_flags |= M_COMP;
	}

#if NPF > 0
	/* Add pf tag if requested. */
	pf_tag_packet(m, tdbp->tdb_tag, -1);
	pf_pkt_addr_changed(m);
#endif

	if (tdbp->tdb_flags & TDBF_TUNNELING)
		m->m_flags |= M_TUNNEL;

#if NBPFILTER > 0
	if ((encif = enc_getif(tdbp->tdb_rdomain, tdbp->tdb_tap)) != NULL) {
		encif->if_ipackets++;
		encif->if_ibytes += m->m_pkthdr.len;

		if (encif->if_bpf) {
			struct enchdr hdr;

			hdr.af = af;
			hdr.spi = tdbp->tdb_spi;
			hdr.flags = m->m_flags & (M_AUTH|M_CONF);

			bpf_mtap_hdr(encif->if_bpf, (char *)&hdr,
			    ENC_HDRLEN, m, BPF_DIRECTION_IN, NULL);
		}
	}
#endif

	switch (sproto) {
	case IPPROTO_ESP:
	case IPPROTO_AH:
	case IPPROTO_IPCOMP:
		break;
	default:
		DPRINTF(("ipsec_common_input_cb(): unknown/unsupported"
		    " security protocol %d\n", sproto));
		m_freem(m);
		return;
	}

	/* Call the appropriate IPsec transform callback. */
	switch (af) {
	case AF_INET:
		if (niq_enqueue(&ipintrq, m) != 0) {
			DPRINTF(("ipsec_common_input_cb(): dropped packet "
			    "because of full IP queue\n"));
			IPSEC_ISTAT(espstat.esps_qfull, ahstat.ahs_qfull,
			    ipcompstat.ipcomps_qfull);
		}
		return;
#ifdef INET6
	case AF_INET6:
		ip6_local(m, skip, prot);
		return;
#endif /* INET6 */
	default:
		DPRINTF(("ipsec_common_input_cb(): unknown/unsupported "
		    "protocol family %d\n", af));
		m_freem(m);
		return;
	}
#undef IPSEC_ISTAT
}

int
esp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case ESPCTL_STATS:
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &espstat, sizeof(espstat)));
	default:
		if (name[0] < ESPCTL_MAXID)
			return (sysctl_int_arr(espctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (ENOPROTOOPT);
	}
}

int
ah_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case AHCTL_STATS:
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &ahstat, sizeof(ahstat)));
	default:
		if (name[0] < AHCTL_MAXID)
			return (sysctl_int_arr(ahctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (ENOPROTOOPT);
	}
}

int
ipcomp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case IPCOMPCTL_STATS:
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &ipcompstat, sizeof(ipcompstat)));
	default:
		if (name[0] < IPCOMPCTL_MAXID)
			return (sysctl_int_arr(ipcompctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (ENOPROTOOPT);
	}
}

/* IPv4 AH wrapper. */
int
ah4_input(struct mbuf **mp, int *offp, int proto)
{
	ipsec_common_input(*mp, *offp, offsetof(struct ip, ip_p), AF_INET,
	    proto, 0);
	return IPPROTO_DONE;
}

/* XXX rdomain */
void
ah4_ctlinput(int cmd, struct sockaddr *sa, u_int rdomain, void *v)
{
	if (sa->sa_family != AF_INET ||
	    sa->sa_len != sizeof(struct sockaddr_in))
		return;

	ipsec_common_ctlinput(rdomain, cmd, sa, v, IPPROTO_AH);
}

/* IPv4 ESP wrapper. */
int
esp4_input(struct mbuf **mp, int *offp, int proto)
{
	ipsec_common_input(*mp, *offp, offsetof(struct ip, ip_p), AF_INET,
	    proto, 0);
	return IPPROTO_DONE;
}

/* IPv4 IPCOMP wrapper */
int
ipcomp4_input(struct mbuf **mp, int *offp, int proto)
{
	ipsec_common_input(*mp, *offp, offsetof(struct ip, ip_p), AF_INET,
	    proto, 0);
	return IPPROTO_DONE;
}

void
ipsec_common_ctlinput(u_int rdomain, int cmd, struct sockaddr *sa,
    void *v, int proto)
{
	struct ip *ip = v;

	if (cmd == PRC_MSGSIZE && ip && ip_mtudisc && ip->ip_v == 4) {
		struct tdb *tdbp;
		struct sockaddr_in dst;
		struct icmp *icp;
		int hlen = ip->ip_hl << 2;
		u_int32_t spi, mtu;
		ssize_t adjust;

		/* Find the right MTU. */
		icp = (struct icmp *)((caddr_t) ip -
		    offsetof(struct icmp, icmp_ip));
		mtu = ntohs(icp->icmp_nextmtu);

		/*
		 * Ignore the packet, if we do not receive a MTU
		 * or the MTU is too small to be acceptable.
		 */
		if (mtu < 296)
			return;

		memset(&dst, 0, sizeof(struct sockaddr_in));
		dst.sin_family = AF_INET;
		dst.sin_len = sizeof(struct sockaddr_in);
		dst.sin_addr.s_addr = ip->ip_dst.s_addr;

		bcopy((caddr_t)ip + hlen, &spi, sizeof(u_int32_t));

		tdbp = gettdb(rdomain, spi, (union sockaddr_union *)&dst,
		    proto);
		if (tdbp == NULL || tdbp->tdb_flags & TDBF_INVALID)
			return;

		/* Walk the chain backwards to the first tdb */
		for (; tdbp; tdbp = tdbp->tdb_inext) {
			if (tdbp->tdb_flags & TDBF_INVALID ||
			    (adjust = ipsec_hdrsz(tdbp)) == -1)
				return;

			mtu -= adjust;

			/* Store adjusted MTU in tdb */
			tdbp->tdb_mtu = mtu;
			tdbp->tdb_mtutimeout = time_second +
			    ip_mtudisc_timeout;
			DPRINTF(("ipsec_common_ctlinput: "
			    "spi %08x mtu %d adjust %ld\n",
			    ntohl(tdbp->tdb_spi), tdbp->tdb_mtu,
			    adjust));
		}
	}
}

/* XXX rdomain */
void
udpencap_ctlinput(int cmd, struct sockaddr *sa, u_int rdomain, void *v)
{
	struct ip *ip = v;
	struct tdb *tdbp;
	struct icmp *icp;
	u_int32_t mtu;
	ssize_t adjust;
	struct sockaddr_in dst, src;
	union sockaddr_union *su_dst, *su_src;

	splsoftassert(IPL_SOFTNET);

	icp = (struct icmp *)((caddr_t) ip - offsetof(struct icmp, icmp_ip));
	mtu = ntohs(icp->icmp_nextmtu);

	/*
	 * Ignore the packet, if we do not receive a MTU
	 * or the MTU is too small to be acceptable.
	 */
	if (mtu < 296)
		return;

	memset(&dst, 0, sizeof(dst));
	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);
	dst.sin_addr.s_addr = ip->ip_dst.s_addr;
	su_dst = (union sockaddr_union *)&dst;
	memset(&src, 0, sizeof(src));
	src.sin_family = AF_INET;
	src.sin_len = sizeof(struct sockaddr_in);
	src.sin_addr.s_addr = ip->ip_src.s_addr;
	su_src = (union sockaddr_union *)&src;

	tdbp = gettdbbysrcdst(rdomain, 0, su_src, su_dst, IPPROTO_ESP);

	for (; tdbp != NULL; tdbp = tdbp->tdb_snext) {
		if (tdbp->tdb_sproto == IPPROTO_ESP &&
		    ((tdbp->tdb_flags & (TDBF_INVALID|TDBF_UDPENCAP)) ==
		    TDBF_UDPENCAP) &&
		    !memcmp(&tdbp->tdb_dst, &dst, SA_LEN(&su_dst->sa)) &&
		    !memcmp(&tdbp->tdb_src, &src, SA_LEN(&su_src->sa))) {
			if ((adjust = ipsec_hdrsz(tdbp)) != -1) {
				/* Store adjusted MTU in tdb */
				tdbp->tdb_mtu = mtu - adjust;
				tdbp->tdb_mtutimeout = time_second +
				    ip_mtudisc_timeout;
				DPRINTF(("udpencap_ctlinput: "
				    "spi %08x mtu %d adjust %ld\n",
				    ntohl(tdbp->tdb_spi), tdbp->tdb_mtu,
				    adjust));
			}
		}
	}
}

/* XXX rdomain */
void
esp4_ctlinput(int cmd, struct sockaddr *sa, u_int rdomain, void *v)
{
	if (sa->sa_family != AF_INET ||
	    sa->sa_len != sizeof(struct sockaddr_in))
		return;

	ipsec_common_ctlinput(rdomain, cmd, sa, v, IPPROTO_ESP);
}

#ifdef INET6
/* IPv6 AH wrapper. */
int
ah6_input(struct mbuf **mp, int *offp, int proto)
{
	int l = 0;
	int protoff, nxt;
	struct ip6_ext ip6e;

	if (*offp < sizeof(struct ip6_hdr)) {
		DPRINTF(("ah6_input(): bad offset\n"));
		ahstat.ahs_hdrops++;
		m_freem(*mp);
		*mp = NULL;
		return IPPROTO_DONE;
	} else if (*offp == sizeof(struct ip6_hdr)) {
		protoff = offsetof(struct ip6_hdr, ip6_nxt);
	} else {
		/* Chase down the header chain... */
		protoff = sizeof(struct ip6_hdr);
		nxt = (mtod(*mp, struct ip6_hdr *))->ip6_nxt;

		do {
			protoff += l;
			m_copydata(*mp, protoff, sizeof(ip6e),
			    (caddr_t) &ip6e);

			if (nxt == IPPROTO_AH)
				l = (ip6e.ip6e_len + 2) << 2;
			else
				l = (ip6e.ip6e_len + 1) << 3;
#ifdef DIAGNOSTIC
			if (l <= 0)
				panic("ah6_input: l went zero or negative");
#endif

			nxt = ip6e.ip6e_nxt;
		} while (protoff + l < *offp);

		/* Malformed packet check */
		if (protoff + l != *offp) {
			DPRINTF(("ah6_input(): bad packet header chain\n"));
			ahstat.ahs_hdrops++;
			m_freem(*mp);
			*mp = NULL;
			return IPPROTO_DONE;
		}
		protoff += offsetof(struct ip6_ext, ip6e_nxt);
	}
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto, 0);
	return IPPROTO_DONE;
}

/* IPv6 ESP wrapper. */
int
esp6_input(struct mbuf **mp, int *offp, int proto)
{
	int l = 0;
	int protoff, nxt;
	struct ip6_ext ip6e;

	if (*offp < sizeof(struct ip6_hdr)) {
		DPRINTF(("esp6_input(): bad offset\n"));
		espstat.esps_hdrops++;
		m_freem(*mp);
		*mp = NULL;
		return IPPROTO_DONE;
	} else if (*offp == sizeof(struct ip6_hdr)) {
		protoff = offsetof(struct ip6_hdr, ip6_nxt);
	} else {
		/* Chase down the header chain... */
		protoff = sizeof(struct ip6_hdr);
		nxt = (mtod(*mp, struct ip6_hdr *))->ip6_nxt;

		do {
			protoff += l;
			m_copydata(*mp, protoff, sizeof(ip6e),
			    (caddr_t) &ip6e);

			if (nxt == IPPROTO_AH)
				l = (ip6e.ip6e_len + 2) << 2;
			else
				l = (ip6e.ip6e_len + 1) << 3;
#ifdef DIAGNOSTIC
			if (l <= 0)
				panic("esp6_input: l went zero or negative");
#endif

			nxt = ip6e.ip6e_nxt;
		} while (protoff + l < *offp);

		/* Malformed packet check */
		if (protoff + l != *offp) {
			DPRINTF(("esp6_input(): bad packet header chain\n"));
			espstat.esps_hdrops++;
			m_freem(*mp);
			*mp = NULL;
			return IPPROTO_DONE;
		}
		protoff += offsetof(struct ip6_ext, ip6e_nxt);
	}
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto, 0);
	return IPPROTO_DONE;

}

/* IPv6 IPcomp wrapper */
int
ipcomp6_input(struct mbuf **mp, int *offp, int proto)
{
	int l = 0;
	int protoff, nxt;
	struct ip6_ext ip6e;

	if (*offp < sizeof(struct ip6_hdr)) {
		DPRINTF(("ipcomp6_input(): bad offset\n"));
		ipcompstat.ipcomps_hdrops++;
		m_freem(*mp);
		*mp = NULL;
		return IPPROTO_DONE;
	} else if (*offp == sizeof(struct ip6_hdr)) {
		protoff = offsetof(struct ip6_hdr, ip6_nxt);
	} else {
		/* Chase down the header chain... */
		protoff = sizeof(struct ip6_hdr);
		nxt = (mtod(*mp, struct ip6_hdr *))->ip6_nxt;

		do {
			protoff += l;
			m_copydata(*mp, protoff, sizeof(ip6e),
			    (caddr_t) &ip6e);
			if (nxt == IPPROTO_AH)
				l = (ip6e.ip6e_len + 2) << 2;
			else
				l = (ip6e.ip6e_len + 1) << 3;
#ifdef DIAGNOSTIC
			if (l <= 0)
				panic("ipcomp6_input: l went zero or negative");
#endif

			nxt = ip6e.ip6e_nxt;
		} while (protoff + l < *offp);

		/* Malformed packet check */
		if (protoff + l != *offp) {
			DPRINTF(("ipcomp6_input(): bad packet header chain\n"));
			ipcompstat.ipcomps_hdrops++;
			m_freem(*mp);
			*mp = NULL;
			return IPPROTO_DONE;
		}

		protoff += offsetof(struct ip6_ext, ip6e_nxt);
	}
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto, 0);
	return IPPROTO_DONE;
}
#endif /* INET6 */
@


1.144
log
@Remove the ipsec protocol callbacks which all do the same.  Implement
it in ipsec_common_input_cb() instead.  The code that was copied
to ah6_input_cb() is now in ip6_ours() so we can call it directly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.143 2017/02/07 22:28:37 bluhm Exp $	*/
d595 1
a595 1
		ip6_ours(m, skip, prot);
@


1.143
log
@Error propagation does neither make sense for ip input path nor for
asynchronous callbacks.  Make the IPsec functions void, there is
already a counter in the error path.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.142 2017/02/05 16:04:14 jca Exp $	*/
a82 9
void ah4_input_cb(struct mbuf *, ...);
void esp4_input_cb(struct mbuf *, ...);
void ipcomp4_input_cb(struct mbuf *, ...);

#ifdef INET6
void ah6_input_cb(struct mbuf *, int, int);
void esp6_input_cb(struct mbuf *, int, int);
void ipcomp6_input_cb(struct mbuf *, int, int);
#endif
d319 1
a319 1
	u_char prot;
d571 12
d586 5
a590 16
		switch (sproto)
		{
		case IPPROTO_ESP:
			esp4_input_cb(m);
			return;
		case IPPROTO_AH:
			ah4_input_cb(m);
			return;
		case IPPROTO_IPCOMP:
			ipcomp4_input_cb(m);
			return;
		default:
			DPRINTF(("ipsec_common_input_cb(): unknown/unsupported"
			    " security protocol %d\n", sproto));
			m_freem(m);
			return;
d592 1
a592 2
		break;

d595 2
a596 17
		switch (sproto) {
		case IPPROTO_ESP:
			esp6_input_cb(m, skip, protoff);
			return;
		case IPPROTO_AH:
			ah6_input_cb(m, skip, protoff);
			return;
		case IPPROTO_IPCOMP:
			ipcomp6_input_cb(m, skip, protoff);
			return;
		default:
			DPRINTF(("ipsec_common_input_cb(): unknown/unsupported"
			    " security protocol %d\n", sproto));
			m_freem(m);
			return;
		}
		break;
a597 1

a681 18
/* IPv4 AH callback. */
void
ah4_input_cb(struct mbuf *m, ...)
{
	/*
	 * Interface pointer is already in first mbuf; chop off the
	 * `outer' header and reschedule.
	 */

	if (niq_enqueue(&ipintrq, m) != 0) {
		ahstat.ahs_qfull++;
		DPRINTF(("ah4_input_cb(): dropped packet because of full "
		    "IP queue\n"));
		return;
	}
}


a701 16
/* IPv4 ESP callback. */
void
esp4_input_cb(struct mbuf *m, ...)
{
	/*
	 * Interface pointer is already in first mbuf; chop off the
	 * `outer' header and reschedule.
	 */
	if (niq_enqueue(&ipintrq, m) != 0) {
		espstat.esps_qfull++;
		DPRINTF(("esp4_input_cb(): dropped packet because of full "
		    "IP queue\n"));
		return;
	}
}

a710 15
/* IPv4 IPCOMP callback */
void
ipcomp4_input_cb(struct mbuf *m, ...)
{
	/*
	 * Interface pointer is already in first mbuf; chop off the
	 * `outer' header and reschedule.
	 */
	if (niq_enqueue(&ipintrq, m) != 0) {
		ipcompstat.ipcomps_qfull++;
		DPRINTF(("ipcomp4_input_cb(): dropped packet because of full IP queue\n"));
		return;
	}
}

a889 38
/* IPv6 AH callback. */
void
ah6_input_cb(struct mbuf *m, int off, int protoff)
{
	int nxt;
	u_int8_t nxt8;
	int nest = 0;

	/* Retrieve new protocol */
	m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &nxt8);
	nxt = nxt8;

	/*
	 * see the end of ip6_input for this logic.
	 * IPPROTO_IPV[46] case will be processed just like other ones
	 */
	while (nxt != IPPROTO_DONE) {
		if (ip6_hdrnestlimit && (++nest > ip6_hdrnestlimit)) {
			ip6stat_inc(ip6s_toomanyhdr);
			goto bad;
		}

		/*
		 * Protection against faulty packet - there should be
		 * more sanity checks in header chain processing.
		 */
		if (m->m_pkthdr.len < off) {
			ip6stat_inc(ip6s_tooshort);
			goto bad;
		}
		nxt = (*inet6sw[ip6_protox[nxt]].pr_input)(&m, &off, nxt);
	}
	return;

 bad:
	m_freem(m);
}

a942 7
/* IPv6 ESP callback */
void
esp6_input_cb(struct mbuf *m, int skip, int protoff)
{
	ah6_input_cb(m, skip, protoff);
}

a993 8

/* IPv6 IPcomp callback */
void
ipcomp6_input_cb(struct mbuf *m, int skip, int protoff)
{
	ah6_input_cb(m, skip, protoff);
}

@


1.142
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.141 2017/01/29 19:58:47 bluhm Exp $	*/
d83 3
a85 3
int ah4_input_cb(struct mbuf *, ...);
int esp4_input_cb(struct mbuf *, ...);
int ipcomp4_input_cb(struct mbuf *, ...);
d88 3
a90 3
int ah6_input_cb(struct mbuf *, int, int);
int esp6_input_cb(struct mbuf *, int, int);
int ipcomp6_input_cb(struct mbuf *, int, int);
d324 1
a324 1
int
d356 1
a356 1
		return EINVAL;
d367 1
a367 1
			return ENOBUFS;
d383 1
a383 1
				return EINVAL;
d398 1
a398 1
				return EINVAL;
d420 1
a420 1
			return EACCES;
d436 1
a436 1
				return EINVAL;
d449 1
a449 1
				return EINVAL;
d474 1
a474 1
				return EINVAL;
d494 1
a494 1
				return EINVAL;
d526 1
a526 1
			return ENOMEM;
d586 2
a587 2
			return esp4_input_cb(m);

d589 2
a590 2
			return ah4_input_cb(m);

d592 2
a593 2
			return ipcomp4_input_cb(m);

d598 1
a598 1
			return EPFNOSUPPORT;
d606 2
a607 2
			return esp6_input_cb(m, skip, protoff);

d609 2
a610 2
			return ah6_input_cb(m, skip, protoff);

d612 2
a613 2
			return ipcomp6_input_cb(m, skip, protoff);

d618 1
a618 1
			return EPFNOSUPPORT;
d627 1
a627 1
		return EPFNOSUPPORT;
d708 1
a708 1
int
d720 1
a720 1
		return ENOBUFS;
a721 2

	return 0;
d746 1
a746 1
int
d757 1
a757 1
		return ENOBUFS;
a758 2

	return 0;
d771 1
a771 1
int
d781 1
a781 1
		return ENOBUFS;
a782 2

	return 0;
d965 1
a965 1
int
d996 1
a996 1
	return 0;
a999 1
	return EINVAL;
d1056 1
a1056 1
int
d1059 1
a1059 1
	return ah6_input_cb(m, skip, protoff);
d1115 1
a1115 1
int
d1118 1
a1118 1
	return ah6_input_cb(m, skip, protoff);
@


1.141
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.140 2017/01/26 13:03:47 bluhm Exp $	*/
d988 1
a988 1
			ip6stat.ip6s_toomanyhdr++;
d997 1
a997 1
			ip6stat.ip6s_tooshort++;
@


1.140
log
@Reduce the difference between struct protosw and ip6protosw.  The
IPv4 pr_ctlinput functions did return a void pointer that was always
NULL and never used.  Make all functions void like in the IPv6 case.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.139 2017/01/25 17:34:31 bluhm Exp $	*/
d151 1
a151 1
			rip_input(m, skip, sproto);
d699 2
a700 2
void
ah4_input(struct mbuf *m, int skip, int proto)
d702 3
a704 3
	ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
	    IPPROTO_AH, 0);
	return;
d739 2
a740 2
void
esp4_input(struct mbuf *m, int skip, int proto)
d742 3
a744 2
	ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
	    IPPROTO_ESP, 0);
d766 2
a767 2
void
ipcomp4_input(struct mbuf *m, int skip, int proto)
d769 3
a771 2
	ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
	    IPPROTO_IPCOMP, 0);
@


1.139
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.138 2017/01/23 09:10:06 mpi Exp $	*/
d82 1
a82 1
void *ipsec_common_ctlinput(u_int, int, struct sockaddr *, void *, int);
d728 1
a728 1
void *
d733 1
a733 1
		return (NULL);
d735 1
a735 1
	return (ipsec_common_ctlinput(rdomain, cmd, sa, v, IPPROTO_AH));
d789 1
a789 1
void *
d813 1
a813 1
			return (NULL);
d825 1
a825 1
			return (NULL);
d831 1
a831 1
				return (NULL);
a844 1
	return (NULL);
d848 1
a848 1
void *
d869 1
a869 1
		return (NULL);
a901 1
	return (NULL);
d905 1
a905 1
void *
d910 1
a910 1
		return (NULL);
d912 1
a912 1
	return (ipsec_common_ctlinput(rdomain, cmd, sa, v, IPPROTO_ESP));
@


1.138
log
@Assert for IPL_SOFTNET rather than raising SPL recursively.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.137 2017/01/20 04:22:58 mpi Exp $	*/
d700 1
a700 1
ah4_input(struct mbuf *m, ...)
a701 7
	int skip;

	va_list ap;
	va_start(ap, m);
	skip = va_arg(ap, int);
	va_end(ap);

d740 1
a740 1
esp4_input(struct mbuf *m, ...)
a741 7
	int skip;

	va_list ap;
	va_start(ap, m);
	skip = va_arg(ap, int);
	va_end(ap);

d766 1
a766 1
ipcomp4_input(struct mbuf *m, ...)
a767 6
	int skip;
	va_list ap;
	va_start(ap, m);
	skip = va_arg(ap, int);
	va_end(ap);

@


1.137
log
@Kill recursive splsofnet()/splx() dances.

Tested by Hrvoje Popovski, ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.136 2016/09/02 09:39:32 vgross Exp $	*/
d126 1
a126 1
	int s, error;
d131 2
a231 1
	s = splsoftnet();
a234 1
		splx(s);
a244 1
		splx(s);
a254 1
		splx(s);
a263 1
		splx(s);
a272 1
		splx(s);
a284 1
			splx(s);
a316 1
	splx(s);
@


1.136
log
@Drop non-encapulated ESP packets using a UDP-encapsulating TDB, and add
the relevant counters.

Ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.135 2015/09/10 17:52:05 claudio Exp $	*/
a819 1
	int s;
a847 1
		s = splsoftnet();
d850 1
a850 2
		if (tdbp == NULL || tdbp->tdb_flags & TDBF_INVALID) {
			splx(s);
a851 1
		}
d856 1
a856 2
			    (adjust = ipsec_hdrsz(tdbp)) == -1) {
				splx(s);
a857 1
			}
a869 2
		splx(s);
		return (NULL);
d885 2
a886 1
	int s;
a908 1
	s = splsoftnet();
a928 1
	splx(s);
@


1.135
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.134 2015/09/09 12:50:08 mpi Exp $	*/
d262 10
@


1.134
log
@Kill a couple of if_get()s only needed to increment per-ifp IPv6 stats.

We do not export those per-ifp statistics and they will soon all die.

"We're putting inet6 on a diet" claudio@@

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.133 2015/06/16 11:09:40 mpi Exp $	*/
d216 2
a217 2
		in6_recoverscope(&dst_address.sin6, &dst_address.sin6.sin6_addr,
		    NULL);
@


1.133
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.132 2015/06/11 15:59:17 mikeb Exp $	*/
a1021 2
			struct ifnet *ifp;

a1022 3
			ifp = if_get(m->m_pkthdr.ph_ifidx);
			if (ifp != NULL)
				in6_ifstat_inc(ifp, ifs6_in_truncated);
@


1.132
log
@Move away from using hzto(9);  OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.131 2015/05/13 10:42:46 jsg Exp $	*/
d293 1
a293 1
		m->m_pkthdr.rcvif = encif;
d1022 2
d1025 3
a1027 1
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_truncated);
@


1.131
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.130 2015/04/17 11:04:02 mikeb Exp $	*/
a121 1
	struct timeval tv;
a298 4

		tv.tv_usec = 0;

		tv.tv_sec = tdbp->tdb_exp_first_use + tdbp->tdb_first_use;
d300 2
a301 3
			timeout_add(&tdbp->tdb_first_tmo, hzto(&tv));

		tv.tv_sec = tdbp->tdb_first_use + tdbp->tdb_soft_first_use;
d303 2
a304 1
			timeout_add(&tdbp->tdb_sfirst_tmo, hzto(&tv));
@


1.130
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.129 2015/04/14 14:20:01 mikeb Exp $	*/
d135 1
a135 1
	if (m == 0) {
@


1.129
log
@make ipsp_address thread safe;  ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.128 2015/04/10 13:58:20 dlg Exp $	*/
d326 1
a326 2
ipsec_common_input_cb(struct mbuf *m, struct tdb *tdbp, int skip, int protoff,
    struct m_tag *mt)
d516 1
a516 5
	 * processed). If we've been passed an mtag, it means the packet
	 * was already processed by an ethernet/crypto combo card and
	 * thus has a tag attached with all the right information, but
	 * with a PACKET_TAG_IPSEC_IN_CRYPTO_DONE as opposed to
	 * PACKET_TAG_IPSEC_IN_DONE type; in that case, just change the type.
@


1.128
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.127 2015/03/26 12:21:37 mikeb Exp $	*/
d128 3
d238 1
a238 1
		    ipsp_address(dst_address), ntohl(spi)));
d247 3
a249 1
		DPRINTF(("ipsec_common_input(): attempted to use invalid SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
d258 3
a260 1
		DPRINTF(("ipsec_common_input(): attempted to use non-udpencap SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
d268 3
a270 1
		DPRINTF(("ipsec_common_input(): attempted to use uninitialized SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
d283 2
a284 2
			    tdbp->tdb_tap, ipsp_address(dst_address),
			    ntohl(spi), tdbp->tdb_sproto));
d344 4
d365 2
a366 2
			    "for SA %s/%08x\n", ipsp_address(tdbp->tdb_dst),
			    ntohl(tdbp->tdb_spi)));
d417 2
a418 2
			    "for SA %s/%08x\n", ipsp_address(tdbp->tdb_dst),
			    ntohl(tdbp->tdb_spi)));
d872 1
a872 1
			    "spi %08x mtu %d adjust %d\n",
d931 1
a931 1
				    "spi %08x mtu %d adjust %d\n",
@


1.127
log
@Remove bits of unfinished IPsec proxy support.  DNS' KX records, anyone?
ok markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.126 2015/01/24 00:29:06 deraadt Exp $	*/
a710 3
	struct ifqueue *ifq = &ipintrq;
	int s = splnet();

d716 1
a716 2
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
a717 3
		splx(s);

		m_freem(m);
a722 3
	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IP);
	splx(s);
a756 3
	struct ifqueue *ifq = &ipintrq;
	int s = splnet();

d761 1
a761 2
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
a762 3
		splx(s);

		m_freem(m);
a767 3
	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IP);
	splx(s);
a788 3
	struct ifqueue *ifq = &ipintrq;
	int s = splnet();

d793 1
a793 2
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
a794 3
		splx(s);

		m_freem(m);
a797 4

	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IP);
	splx(s);
@


1.126
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.125 2014/12/19 17:14:40 tedu Exp $	*/
a376 31

			/*
			 * Check that the inner source address is the same as
			 * the proxy address, if available.
			 */
			if ((tdbp->tdb_proxy.sa.sa_family == AF_INET &&
			    tdbp->tdb_proxy.sin.sin_addr.s_addr !=
			    INADDR_ANY &&
			    ipn.ip_src.s_addr !=
			    tdbp->tdb_proxy.sin.sin_addr.s_addr) ||
			    (tdbp->tdb_proxy.sa.sa_family != AF_INET &&
				tdbp->tdb_proxy.sa.sa_family != 0)) {
#if ENCDEBUG
				char addr[INET_ADDRSTRLEN];
#endif

				DPRINTF(("ipsec_common_input_cb(): inner "
				    "source address %s doesn't correspond to "
				    "expected proxy source %s, SA %s/%08x\n",
				    inet_ntop(AF_INET, &ipn.ip_src,
					addr, sizeof(addr)),
				    ipsp_address(tdbp->tdb_proxy),
				    ipsp_address(tdbp->tdb_dst),
				    ntohl(tdbp->tdb_spi)));

				m_freem(m);
				IPSEC_ISTAT(espstat.esps_pdrops,
				    ahstat.ahs_pdrops,
				    ipcompstat.ipcomps_pdrops);
				return EACCES;
			}
a391 30

			/*
			 * Check that the inner source address is the same as
			 * the proxy address, if available.
			 */
			if ((tdbp->tdb_proxy.sa.sa_family == AF_INET6 &&
			    !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_proxy.sin6.sin6_addr) &&
			    !IN6_ARE_ADDR_EQUAL(&ip6n.ip6_src,
				&tdbp->tdb_proxy.sin6.sin6_addr)) ||
			    (tdbp->tdb_proxy.sa.sa_family != AF_INET6 &&
				tdbp->tdb_proxy.sa.sa_family != 0)) {
#if ENCDEBUG
				char addr[INET6_ADDRSTRLEN];
#endif

				DPRINTF(("ipsec_common_input_cb(): inner "
				    "source address %s doesn't correspond to "
				    "expected proxy source %s, SA %s/%08x\n",
				    inet_ntop(AF_INET6, &ip6n.ip6_src,
					addr, sizeof(addr)),
				    ipsp_address(tdbp->tdb_proxy),
				    ipsp_address(tdbp->tdb_dst),
				    ntohl(tdbp->tdb_spi)));

				m_freem(m);
				IPSEC_ISTAT(espstat.esps_pdrops,
				    ahstat.ahs_pdrops,
				    ipcompstat.ipcomps_pdrops);
				return EACCES;
			}
a428 31

			/*
			 * Check that the inner source address is the same as
			 * the proxy address, if available.
			 */
			if ((tdbp->tdb_proxy.sa.sa_family == AF_INET &&
			    tdbp->tdb_proxy.sin.sin_addr.s_addr !=
			    INADDR_ANY &&
			    ipn.ip_src.s_addr !=
				tdbp->tdb_proxy.sin.sin_addr.s_addr) ||
			    (tdbp->tdb_proxy.sa.sa_family != AF_INET &&
				tdbp->tdb_proxy.sa.sa_family != 0)) {
#if ENCDEBUG
				char addr[INET_ADDRSTRLEN];
#endif

				DPRINTF(("ipsec_common_input_cb(): inner "
				    "source address %s doesn't correspond to "
				    "expected proxy source %s, SA %s/%08x\n",
				    inet_ntop(AF_INET, &ipn.ip_src,
					addr, sizeof(addr)),
				    ipsp_address(tdbp->tdb_proxy),
				    ipsp_address(tdbp->tdb_dst),
				    ntohl(tdbp->tdb_spi)));

				m_freem(m);
				IPSEC_ISTAT(espstat.esps_pdrops,
				    ahstat.ahs_pdrops,
				    ipcompstat.ipcomps_pdrops);
				return EACCES;
			}
a442 30

			/*
			 * Check that the inner source address is the same as
			 * the proxy address, if available.
			 */
			if ((tdbp->tdb_proxy.sa.sa_family == AF_INET6 &&
			    !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_proxy.sin6.sin6_addr) &&
			    !IN6_ARE_ADDR_EQUAL(&ip6n.ip6_src,
				&tdbp->tdb_proxy.sin6.sin6_addr)) ||
			    (tdbp->tdb_proxy.sa.sa_family != AF_INET6 &&
				tdbp->tdb_proxy.sa.sa_family != 0)) {
#if ENCDEBUG
				char addr[INET6_ADDRSTRLEN];
#endif

				DPRINTF(("ipsec_common_input_cb(): inner "
				    "source address %s doesn't correspond to "
				    "expected proxy source %s, SA %s/%08x\n",
				    inet_ntop(AF_INET6, &ip6n.ip6_src,
					addr, sizeof(addr)),
				    ipsp_address(tdbp->tdb_proxy),
				    ipsp_address(tdbp->tdb_dst),
				    ntohl(tdbp->tdb_spi)));

				m_freem(m);
				IPSEC_ISTAT(espstat.esps_pdrops,
				    ahstat.ahs_pdrops,
				    ipcompstat.ipcomps_pdrops);
				return EACCES;
			}
@


1.125
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.124 2014/12/05 15:50:04 mpi Exp $	*/
a54 4
#if NPF > 0
#include <net/pfvar.h>
#endif

d61 4
@


1.124
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.123 2014/11/20 14:51:42 krw Exp $	*/
a82 1
#ifdef INET
a85 1
#endif
a145 1
#ifdef INET
a148 1
#endif /* INET */
a200 1
#ifdef INET
a206 1
#endif /* INET */
a326 1
#ifdef INET
a327 1
#endif /* INET */
a347 1
#ifdef INET
a455 1
#endif /* INET */
a478 1
#ifdef INET
a521 1
#endif /* INET */
a696 1
#ifdef INET
a715 1
#endif /* INET */
a812 1
#ifdef INET
a1090 1
#endif /* INET */
@


1.123
log
@Yet more #include de-duplication.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.122 2014/07/22 11:06:10 mpi Exp $	*/
d50 1
@


1.122
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.121 2014/07/09 09:30:49 henning Exp $	*/
a65 3
#ifndef INET
#include <netinet/in.h>
#endif
@


1.121
log
@bpf code surgery / shuffling / simplification.
the various bpf_mtap_* are very similiar, they differ in what (and to some
extent how) they prepend something, and what copy function they pass to
bpf_catchpacket.
use an internal _bpf_mtap as "backend" for bpf_mtap and friends.
extend bpf_mtap_hdr so that it covers all common cases:
if dlen is 0, nothing gets prepended.
copy function can be given, if NULL the default bpf_mcopy is used.
adjust the existing bpf_mtap_hdr users to pass a NULL ptr for the copy fn.
re-implement bpf_mtap_af as simple wrapper for bpf_mtap_hdr.
re-implement bpf_mtap_ether using bpf_map_hdr
re-implement bpf_mtap_pflog as trivial bpf_mtap_hdr wrapper
ok bluhm benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.119 2014/01/09 06:29:06 tedu Exp $	*/
a58 1
#include <netinet/in_systm.h>
@


1.120
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d705 1
a705 1
			    ENC_HDRLEN, m, BPF_DIRECTION_IN);
@


1.119
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.118 2013/11/11 09:15:35 mpi Exp $	*/
d238 1
a238 1
	tdbp = gettdb(rtable_l2(m->m_pkthdr.rdomain),
@


1.118
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.117 2013/10/23 15:12:42 mpi Exp $	*/
d204 1
a204 1
	bzero(&dst_address, sizeof(dst_address));
d1000 1
a1000 1
		bzero(&dst, sizeof(struct sockaddr_in));
d1063 1
a1063 1
	bzero(&dst, sizeof(dst));
d1068 1
a1068 1
	bzero(&src, sizeof(src));
d1079 4
a1082 4
		    ((tdbp->tdb_flags & (TDBF_INVALID|TDBF_UDPENCAP))
		    == TDBF_UDPENCAP) &&
		    !bcmp(&tdbp->tdb_dst, &dst, SA_LEN(&su_dst->sa)) &&
		    !bcmp(&tdbp->tdb_src, &src, SA_LEN(&su_src->sa))) {
@


1.117
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.116 2013/10/17 16:27:44 bluhm Exp $	*/
d401 3
d408 2
a409 1
				    inet_ntoa4(ipn.ip_src),
d446 3
d453 2
a454 1
				    ip6_sprintf(&ip6n.ip6_src),
d516 3
d523 2
a524 1
				    inet_ntoa4(ipn.ip_src),
d561 3
d568 2
a569 1
				    ip6_sprintf(&ip6n.ip6_src),
@


1.116
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.115 2013/06/01 16:29:00 bluhm Exp $	*/
a61 1
#include <netinet/in_var.h>
@


1.115
log
@Fix typo backswards -> backwards.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.114 2013/04/24 10:17:08 mpi Exp $	*/
d71 1
@


1.114
log
@Instead of having various extern declarations for protocol variables,
declare them once in their corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.113 2013/04/11 12:06:25 mpi Exp $	*/
d999 1
a999 1
		/* Walk the chain backswards to the first tdb */
@


1.113
log
@Remove the extern keyword from function declarations, document
sysctl declarations, move variables and functions used in only
one place in their corresponding file. No functional change.

No objection from markus@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.112 2013/04/10 08:50:59 mpi Exp $	*/
a111 5

#ifdef INET6
extern struct ip6protosw inet6sw[];
extern u_char ip6_protox[];
#endif
@


1.112
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.111 2013/03/31 00:59:52 bluhm Exp $	*/
d86 11
@


1.111
log
@Do not transfer diverted packets into IPsec processing.  They should
reach the socket that the user has specified in pf.conf.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.110 2013/03/28 23:10:06 tedu Exp $	*/
a954 1
	extern u_int ip_mtudisc_timeout;
@


1.110
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.109 2013/03/28 16:45:16 tedu Exp $	*/
d140 3
@


1.109
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.108 2012/09/26 14:53:23 markus Exp $	*/
d47 1
@


1.108
log
@add M_ZEROIZE as an mbuf flag, so copied PFKEY messages (with embedded keys)
are cleared as well; from hshoexer@@, feedback and ok bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.107 2012/09/20 10:25:03 blambert Exp $	*/
a44 1
#include <sys/proc.h>
@


1.107
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.106 2011/12/22 13:36:06 sperreault Exp $	*/
d653 1
a653 1
		m->m_flags |= M_AUTH | M_AUTH_AH;
d677 1
a677 1
			hdr.flags = m->m_flags & (M_AUTH|M_CONF|M_AUTH_AH);
@


1.106
log
@Fix RFC reference section

spotted by bluhm@@, ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.105 2011/12/21 14:53:26 sperreault Exp $	*/
d228 1
a228 1
	s = spltdb();
d983 1
a983 1
		s = spltdb();
d1050 1
a1050 1
	s = spltdb();
@


1.105
log
@Compute mandatory UDP checksum for IPv6 packets

ok yasuoka@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.104 2011/12/19 02:43:19 yasuoka Exp $	*/
d561 1
a561 1
	 * (RFC3948 3.1.1)
@


1.104
log
@Fix checksum of UDP/TCP packets following RFC 3948.  This is required for
transport mode IPsec NAT-T.

ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.103 2011/04/26 22:30:38 bluhm Exp $	*/
d580 8
@


1.103
log
@In ipsec_common_input() the packet can be either IPv4 or IPv6.  So
pass it to the correct raw ip input function if IPsec is disabled.
ok todd@@ mpf@@ mikeb@@ blambert@@ matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.102 2011/04/06 19:15:34 markus Exp $	*/
d558 47
@


1.102
log
@uncompress a packet with an IPcomp header only once; this prevents
endless loops by IPcomp-quine attacks as discovered by Tavis Ormandy;
it also prevents nested IPcomp-IPIP-IPcomp attacks provied by matthew@@;
feedback and ok matthew@@, deraadt@@, djm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.101 2011/04/03 15:51:09 henning Exp $	*/
d141 19
a159 1
		rip_input(m, skip, sproto);
@


1.101
log
@don't rely on implict net/route.h inclusion via pf, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.100 2011/03/05 01:53:16 bluhm Exp $	*/
d144 6
d579 1
a579 1
	} else if (sproto == IPPROTO_AH)
d581 3
@


1.100
log
@The function pf_tag_packet() never fails.  Remove a redundant check
and make it void.
ok henning@@, markus@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.99 2010/12/21 19:16:15 markus Exp $	*/
d52 1
@


1.99
log
@don't leak short packets; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.98 2010/07/09 16:58:06 reyk Exp $	*/
d577 1
a577 2
	if (pf_tag_packet(m, tdbp->tdb_tag, -1))
		DPRINTF(("failed to tag ipsec packet\n"));
@


1.98
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.97 2010/07/01 02:09:45 reyk Exp $	*/
d1016 3
d1108 3
d1168 3
@


1.97
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.96 2010/06/29 21:28:38 reyk Exp $	*/
d84 1
a84 1
void *ipsec_common_ctlinput(int, struct sockaddr *, void *, int);
d204 2
a205 1
	tdbp = gettdb(spi, &dst_address, sproto);
d244 2
a245 1
		if ((encif = enc_getif(0, tdbp->tdb_tap)) == NULL) {
d559 1
d586 1
a586 1
	if ((encif = enc_getif(0, tdbp->tdb_tap)) != NULL) {
d778 1
a778 1
	return (ipsec_common_ctlinput(cmd, sa, v, IPPROTO_AH));
d867 2
a868 1
ipsec_common_ctlinput(int cmd, struct sockaddr *sa, void *v, int proto)
d902 2
a903 1
		tdbp = gettdb(spi, (union sockaddr_union *)&dst, proto);
d969 1
a969 1
	tdbp = gettdbbysrcdst(0, su_src, su_dst, IPPROTO_ESP);
d1001 1
a1001 1
	return (ipsec_common_ctlinput(cmd, sa, v, IPPROTO_ESP));
@


1.96
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.94 2010/01/02 18:35:48 markus Exp $	*/
d122 1
d243 14
d258 1
a258 1
		m->m_pkthdr.rcvif = enc_getif(0);
d583 1
a583 1
	if ((encif = enc_getif(0)) != NULL) {
@


1.95
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d243 1
a243 1
		m->m_pkthdr.rcvif = &encif[0].sc_if;
d245 1
a245 1
	
d282 1
a282 1
	struct ifnet *bpfif;
d568 10
a577 10
	bpfif = &encif[0].sc_if;
	bpfif->if_ipackets++;
	bpfif->if_ibytes += m->m_pkthdr.len;

	if (bpfif->if_bpf) {
		struct enchdr hdr;

		hdr.af = af;
		hdr.spi = tdbp->tdb_spi;
		hdr.flags = m->m_flags & (M_AUTH|M_CONF|M_AUTH_AH);
d579 3
a581 2
		bpf_mtap_hdr(bpfif->if_bpf, (char *)&hdr, ENC_HDRLEN, m,
		    BPF_DIRECTION_IN);
@


1.94
log
@uninitalized protocol version for ipv6; from mickey; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.93 2009/11/13 20:54:05 claudio Exp $	*/
d45 1
@


1.93
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.92 2009/08/09 12:47:50 henning Exp $	*/
d277 2
a278 1
	int prot, af, sproto;
d430 1
a430 1
		m_copydata(m, protoff, 1, (unsigned char *) &prot);
@


1.92
log
@once again ipsec tries to be clever and plays fast, this time by
recycling an mbuf tag and changing its type. just always get a new one.
theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.91 2008/10/22 23:04:45 mpf Exp $	*/
d749 1
d751 1
a751 1
ah4_ctlinput(int cmd, struct sockaddr *sa, void *v)
d911 1
d913 1
a913 1
udpencap_ctlinput(int cmd, struct sockaddr *sa, void *v)
d970 1
d972 1
a972 1
esp4_ctlinput(int cmd, struct sockaddr *sa, void *v)
@


1.91
log
@#if INET  => #ifdef INET
#if INET6 => #ifdef INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.90 2008/10/22 14:36:08 markus Exp $	*/
d523 1
a523 1
	if (mt == NULL && tdbp->tdb_sproto != IPPROTO_IPCOMP) {
a541 3
	} else {
		if (mt != NULL)
			mt->m_tag_id = PACKET_TAG_IPSEC_IN_DONE;
@


1.90
log
@filter ipv6 ipsec packets on enc0 (in and out), similar to ipv4;
ok bluhm, fries, mpf; fixes pr 4188
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.89 2008/08/26 12:18:01 henning Exp $	*/
d365 1
a365 1
#if INET6
@


1.89
log
@call pf_pkt_addr_changed instead of manually clearing the pf state key ptr
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.88 2008/07/24 10:55:44 henning Exp $	*/
d240 2
a241 6
	if (tdbp->tdb_dst.sa.sa_family == AF_INET &&
	    sproto != IPPROTO_IPCOMP) {
		/*
		 * XXX The fragment conflicts with scoped nature of
		 * IPv6, so do it for only for IPv4 for now.
		 */
@


1.88
log
@ipsec is glued into the stack in a very weird way, violating all kinds
of expected semantics. thus, for return packets coming out of an ipsec
tunnel, we need to clear the pf state key pointer in the mbuf header
to prevent a state for encapsulated traffic to be linked to the
decapsulated traffic one.
problem noticed by Oleg Safiullin <form@@pdp-11.org.ru>, took me some
time to understand what the hell was going on. ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.87 2008/06/14 23:18:20 todd Exp $	*/
d566 1
a566 3

	/* clear state key ptr to prevent incorrect linking */
	m->m_pkthdr.pf.statekey = NULL;
@


1.87
log
@make easier to read, found during a bug hunt earlier
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.86 2008/06/11 17:39:51 canacar Exp $	*/
d566 3
@


1.86
log
@fix an old typo that prevented outer ipv6 headers from being corrected,
also fix the correction amount.  This was only really visible on tcpdump,
as a "truncated-ip6 - 48 bytes missing" warning. The inner packet made
it into the stack just fine, minus a few sanity checks.
reported by and debuged together with and ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.85 2007/12/14 18:33:41 deraadt Exp $	*/
d312 1
a312 1
	if (tdbp->tdb_dst.sa.sa_family == AF_INET) {
@


1.85
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.84 2007/05/28 17:16:39 henning Exp $	*/
d415 1
a415 1
	if (af == INET6)
d430 1
a430 2
		ip6->ip6_plen = htons(m->m_pkthdr.len -
		    sizeof(struct ip6_hdr));
@


1.84
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.83 2007/02/08 15:25:30 itojun Exp $	*/
d647 16
a662 4
	if (name[0] < ESPCTL_MAXID)
		return (sysctl_int_arr(espctl_vars, name, namelen,
		    oldp, oldlenp, newp, newlen));
	return (ENOPROTOOPT);
d669 16
a684 4
	if (name[0] < AHCTL_MAXID)
		return (sysctl_int_arr(ahctl_vars, name, namelen,
		    oldp, oldlenp, newp, newlen));
	return (ENOPROTOOPT);
d691 16
a706 4
	if (name[0] < IPCOMPCTL_MAXID)
		return (sysctl_int_arr(ipcompctl_vars, name, namelen,
		    oldp, oldlenp, newp, newlen));
	return (ENOPROTOOPT);
@


1.83
log
@- AH: when computing crypto checksum for output, massage source-routing
  header.
- ipsec_input: fix mistake in IPv6 next-header chasing.
- ipsec_output: look for the position to insert AH more carefully.
- ip6_output: enable use of AH with extension headers.
  avoid tunnellinng when source-routing header is present.

ok by deraad, naddy, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.82 2006/12/15 09:32:30 otto Exp $	*/
d565 1
a565 1
	if (pf_tag_packet(m, NULL, tdbp->tdb_tag, -1))
@


1.82
log
@make enc(4) count; ok markus@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.81 2006/12/05 09:17:12 markus Exp $	*/
d956 1
a956 1
	int protoff;
d967 1
d974 1
a974 1
			if (ip6e.ip6e_nxt == IPPROTO_AH)
d982 2
d1045 1
a1045 1
	int protoff;
d1056 1
d1063 1
a1063 1
			if (ip6e.ip6e_nxt == IPPROTO_AH)
d1071 2
d1102 1
a1102 1
	int protoff;
d1113 1
d1119 1
a1119 1
			if (ip6e.ip6e_nxt == IPPROTO_AH)
d1127 2
@


1.81
log
@do not install pmtu routes for transport mode SAs, as they do not
the dest IP; PMTU debugging support; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.80 2006/11/24 13:52:14 reyk Exp $	*/
d574 3
@


1.80
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.79 2006/03/25 22:41:48 djm Exp $	*/
d867 4
d925 4
@


1.79
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.78 2006/03/04 22:40:16 brad Exp $	*/
d38 2
d52 4
d562 6
@


1.78
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.77 2006/01/13 10:11:23 mpf Exp $	*/
d569 2
a570 1
		bpf_mtap_hdr(bpfif->if_bpf, (char *)&hdr, ENC_HDRLEN, m);
@


1.77
log
@Path MTU discovery for NAT-T.
OK markus@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.76 2005/07/31 03:52:19 pascoe Exp $	*/
d679 1
a679 1
	int s = splimp();
d734 1
a734 1
	int s = splimp();
d776 1
a776 1
	int s = splimp();
@


1.76
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.75 2004/11/25 21:54:54 markus Exp $	*/
d858 54
@


1.75
log
@resolve conflict between M_TUNNEL and M_ANYCAST6, remove M_COMP (it's
only set and never read), update documentation; ok fgsch, deraadt, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.74 2004/06/21 23:50:37 tholo Exp $	*/
a562 8
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a dummy header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer a to it).
		 */
		struct mbuf m1;
d569 1
a569 6
		m1.m_flags = 0;
		m1.m_next = m;
		m1.m_len = ENC_HDRLEN;
		m1.m_data = (char *) &hdr;

		bpf_mtap(bpfif->if_bpf, &m1);
@


1.74
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.73 2004/06/21 20:44:54 itojun Exp $	*/
d554 1
a554 3
	} else if (sproto == IPPROTO_IPCOMP)
		m->m_flags |= M_COMP;
	else
@


1.73
log
@make it possble to use IPsec over link-local address (policy table uses
sin6_scope_id, IPsec porion uses embedded form).  beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.72 2004/04/18 16:41:40 markus Exp $	*/
d245 1
a245 5
		int pri;

		pri = splhigh();
		tdbp->tdb_first_use = time.tv_sec;
		splx(pri);
d294 1
a294 1
	tdbp->tdb_last_used = time.tv_sec;
d867 1
a867 1
			tdbp->tdb_mtutimeout = time.tv_sec +
@


1.72
log
@pass esp/ah/ipcmp to rawip if processing is disabled with sysctl;
allows userland ipsec; tested by sturm@@; ok deraadt@@, ho@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.71 2004/02/17 12:07:45 markus Exp $	*/
d181 2
@


1.71
log
@switch to sysctl_int_arr(); ok henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.70 2003/12/02 23:16:29 markus Exp $	*/
d132 2
a133 4
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops,
		    ipcompstat.ipcomps_pdrops);
		return EOPNOTSUPP;
@


1.70
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.69 2003/07/28 10:10:16 markus Exp $	*/
d90 4
d647 1
a647 1
esp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlen, void *newp,
d650 4
a653 15
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;

	switch (name[0]) {
	case ESPCTL_ENABLE:
		return sysctl_int(oldp, oldlen, newp, newlen, &esp_enable);
	case ESPCTL_UDPENCAP_ENABLE:
		return sysctl_int(oldp, oldlen, newp, newlen, &udpencap_enable);
	case ESPCTL_UDPENCAP_PORT:
		return sysctl_int(oldp, oldlen, newp, newlen, &udpencap_port);
	default:
		return ENOPROTOOPT;
	}
	/* NOTREACHED */
d657 1
a657 1
ah_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlen, void *newp,
d660 4
a663 11
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;

	switch (name[0]) {
	case AHCTL_ENABLE:
		return sysctl_int(oldp, oldlen, newp, newlen, &ah_enable);
	default:
		return ENOPROTOOPT;
    }
    /* NOTREACHED */
d667 1
a667 1
ipcomp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlen, void *newp,
d670 4
a673 11
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;

	switch (name[0]) {
	case IPCOMPCTL_ENABLE:
		return sysctl_int(oldp, oldlen, newp, newlen, &ipcomp_enable);
	default:
		return ENOPROTOOPT;
	}
	/* NOTREACHED */
@


1.69
log
@allow gif(4) over ipsec: mark mbuf for transport mode SA,
so in_gif_input can detect whether a proto 4 header is due
to ipsec tunnel mode or gif(4) encapsulation; fixes pr 3023
ok itojun@@. provos@@ and angelos@@ agree; tested by sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.68 2003/07/24 11:13:47 markus Exp $	*/
a76 1
int ipsec_common_input(struct mbuf *, int, int, int, int);
d102 2
a103 1
ipsec_common_input(struct mbuf *m, int skip, int protoff, int af, int sproto)
d213 8
d238 1
a238 1

d653 4
d710 1
a710 1
	    IPPROTO_AH);
d766 1
a766 1
	    IPPROTO_ESP);
d808 1
a808 1
	    IPPROTO_IPCOMP);
d955 1
a955 1
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
d1041 1
a1041 1
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
d1095 1
a1095 1
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
@


1.68
log
@update ip_len to reflect tunnel header removal (lost duing ip_len
flip changes); ok itojun; noticed by jrrs@@ice-nine.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.66 2003/07/08 11:01:20 markus Exp $	*/
d550 3
@


1.67
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d309 1
@


1.66
log
@make sure the packets contains a complete inner header
for ip{4,6}-in-ip{4,6} encapsulation; fixes panic
for truncated ip-in-ip over ipsec; ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.65 2003/07/04 16:40:55 markus Exp $	*/
a308 2
		ip->ip_len = htons(m->m_pkthdr.len);
		HTONS(ip->ip_off);
@


1.65
log
@knf typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.64 2003/05/03 01:43:07 itojun Exp $	*/
d317 7
d325 1
a325 1
			m_copydata(m, ip->ip_hl << 2, sizeof(struct ip),
d359 7
d367 1
a367 1
			m_copydata(m, ip->ip_hl << 2, sizeof(struct ip6_hdr),
d426 7
d467 7
@


1.64
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.63 2003/02/20 18:35:43 deraadt Exp $	*/
d155 4
a158 4
     * Find tunnel control block and (indirectly) call the appropriate
     * kernel crypto routine. The resulting mbuf chain is a valid
     * IP packet ready to go through input processing.
     */
@


1.63
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.62 2003/02/20 18:33:49 jason Exp $	*/
d541 1
@


1.62
log
@If there's no tag to be reset, don't reset it (avoids a NULL deref in the IPCOMP case)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.61 2002/06/28 19:07:03 angelos Exp $	*/
d519 1
a519 2
	}
	else if (sproto == IPPROTO_IPCOMP)
@


1.61
log
@Fix usage counter for IPCOMP --- sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.60 2002/06/25 00:38:54 angelos Exp $	*/
d506 3
a509 2
	else
		mt->m_tag_id = PACKET_TAG_IPSEC_IN_DONE;
@


1.60
log
@Forgot variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.59 2002/06/25 00:20:38 angelos Exp $	*/
d106 1
a106 1
			    IPPROTO_AH ? (y)++ : (z)++)
@


1.59
log
@Handle correctly return values from xf_input methods --- since the
return value was ignored anyway, this wasn't a problem so far. From
sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.58 2002/06/13 08:02:36 angelos Exp $	*/
d113 1
a113 1
	int s;
@


1.58
log
@Remove whitespace from the end of the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.57 2002/06/09 16:26:10 itojun Exp $	*/
d251 6
a256 10
     * Call appropriate transform and return -- callback takes care of
     * everything else.
     */
	if ((*(tdbp->tdb_xform->xf_input))(m, tdbp, skip, protoff) == NULL) {
		splx(s);
		return EINVAL;
	} else {
		splx(s);
		return 0;
	}
@


1.57
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.56 2002/06/09 00:58:33 angelos Exp $	*/
a1067 3



@


1.56
log
@Set/clear M_AUTH_AH.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.55 2002/01/23 21:34:53 provos Exp $	*/
d222 1
a222 1
	if (tdbp->tdb_dst.sa.sa_family == AF_INET && 
d648 1
a648 1
    
d654 1
a654 1
	}	
d778 1
a778 1
    
d787 1
a787 1
	
d814 1
a814 1
	
d1033 1
a1033 1
			m_copydata(*mp, protoff, sizeof(ip6e), 
@


1.55
log
@disable pmtu for ipsec when the sysctl says so; bug report cjkim2000@@yahoo.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.54 2001/12/06 22:52:10 angelos Exp $	*/
d526 1
a526 1
		m->m_flags |= M_AUTH;
d543 1
a543 1
		hdr.flags = m->m_flags & (M_AUTH|M_CONF);
@


1.54
log
@Use hzto() to handle overflow of (hz * timeout) cases --- when using
extremely long SA expirations.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.53 2001/08/09 15:44:32 angelos Exp $	*/
d807 1
a807 1
	if (cmd == PRC_MSGSIZE && ip && ip->ip_v == 4) {
@


1.54.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.55 2002/01/23 21:34:53 provos Exp $	*/
d807 1
a807 1
	if (cmd == PRC_MSGSIZE && ip && ip_mtudisc && ip->ip_v == 4) {
@


1.54.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.54.2.1 2002/01/31 22:55:45 niklas Exp $	*/
d526 1
a526 1
		m->m_flags |= M_AUTH | M_AUTH_AH;
d543 1
a543 1
		hdr.flags = m->m_flags & (M_AUTH|M_CONF|M_AUTH_AH);
@


1.54.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.54.2.2 2002/06/11 03:31:37 art Exp $	*/
d106 1
a106 1
			    sproto == IPPROTO_AH ? (y)++ : (z)++)
d113 1
a113 1
	int s, error;
d222 1
a222 1
	if (tdbp->tdb_dst.sa.sa_family == AF_INET &&
d251 10
a260 6
	 * Call appropriate transform and return -- callback takes care of
	 * everything else.
	 */
	error = (*(tdbp->tdb_xform->xf_input))(m, tdbp, skip, protoff);
	splx(s);
	return error;
d648 1
a648 1

d654 1
a654 1
	}
d778 1
a778 1

d787 1
a787 1

d814 1
a814 1

d1033 1
a1033 1
			m_copydata(*mp, protoff, sizeof(ip6e),
d1068 3
@


1.54.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a505 3
	} else {
		if (mt != NULL)
			mt->m_tag_id = PACKET_TAG_IPSEC_IN_DONE;
d507 2
d518 2
a519 1
	} else if (sproto == IPPROTO_IPCOMP)
a540 1
		m1.m_flags = 0;
@


1.53
log
@Don't check the source address on the packet vs. the one on the SA, as
this prevents use of ESP in mobility; pointed out on the IETF mailing
list by Francis Dupont.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.52 2001/08/08 15:07:04 jjbg Exp $	*/
d109 1
d233 3
d237 5
d243 3
a245 2
			timeout_add(&tdbp->tdb_first_tmo, hz *
			    tdbp->tdb_exp_first_use);
d247 1
a247 2
			timeout_add(&tdbp->tdb_sfirst_tmo, hz *
			    tdbp->tdb_soft_first_use);
@


1.52
log
@Remove IPCOMP option, it's now part of IPSEC option. You still need to
enable ipcomp via sysctl to use it. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.51 2001/08/07 14:07:47 deraadt Exp $	*/
a377 24

		/*
		 * Check that the source address is an expected one,
		 * if we know what it's supposed to be. This avoids
		 * source address spoofing.
		 */
		if ((tdbp->tdb_src.sa.sa_family == AF_INET &&
		    tdbp->tdb_src.sin.sin_addr.s_addr != INADDR_ANY &&
		    ip->ip_src.s_addr != tdbp->tdb_src.sin.sin_addr.s_addr) ||
		    (tdbp->tdb_src.sa.sa_family != AF_INET &&
			tdbp->tdb_src.sa.sa_family != 0)) {

			DPRINTF(("ipsec_common_input_cb(): source address %s "
			    "doesn't correspond to expected source %s, "
			    "SA %s/%08x\n", inet_ntoa4(ip->ip_src),
			    ipsp_address(tdbp->tdb_src),
			    ipsp_address(tdbp->tdb_dst),
			    ntohl(tdbp->tdb_spi)));

			m_freem(m);
			IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops,
			    ipcompstat.ipcomps_pdrops);
			return EACCES;
		}
a469 26
		}

		/*
		 * Check that the source address is an expected one,
		 * if we know what it's supposed to be. This avoids
		 * source address spoofing.
		 */
		if ((tdbp->tdb_src.sa.sa_family == AF_INET6 &&
		    !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_src.sin6.sin6_addr) &&
		    !IN6_ARE_ADDR_EQUAL(&ip6->ip6_src,
			&tdbp->tdb_src.sin6.sin6_addr)) ||
		    (tdbp->tdb_src.sa.sa_family != AF_INET6 &&
			tdbp->tdb_src.sa.sa_family != 0)) {

			DPRINTF(("ipsec_common_input_cb(): packet %s to %s "
			    "does not match any ACL entries, SA %s/%08x\n",
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
			    ipsp_address(tdbp->tdb_src),
			    ipsp_address(tdbp->tdb_dst),
			    ntohl(tdbp->tdb_spi)));

			m_freem(m);
			IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops,
			    ipcompstat.ipcomps_pdrops);
			return EACCES;
@


1.51
log
@enable ah & esp by default, now that we trust the code more
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.50 2001/07/06 19:35:38 jjbg Exp $	*/
a605 1
#ifdef IPCOMP
a607 1
#endif /* IPCOMP */
a626 1
#ifdef IPCOMP
a628 1
#endif /* IPCOMP */
a799 1
#ifdef IPCOMP
a839 1
#endif /* IPCOMP */
a1055 1
#ifdef IPCOMP
a1106 1
#endif /* IPCOMP */
@


1.50
log
@Don't use enc0 interface for IPComp. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.49 2001/07/05 16:45:55 jjbg Exp $	*/
d87 2
a88 2
int esp_enable = 0;
int ah_enable = 0;
@


1.49
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.48 2001/06/26 04:17:57 angelos Exp $	*/
d221 2
a222 1
	if (tdbp->tdb_dst.sa.sa_family == AF_INET) {
@


1.48
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.47 2001/06/25 05:11:59 angelos Exp $	*/
d71 1
d89 1
d105 2
a106 1
#define IPSEC_ISTAT(y,z) (sproto == IPPROTO_ESP ? (y)++ : (z)++)
d111 1
d114 2
a115 1
	IPSEC_ISTAT(espstat.esps_input, ahstat.ahs_input);
d119 2
a120 1
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d125 2
a126 1
	    (sproto == IPPROTO_AH && !ah_enable)) {
d128 2
a129 1
		IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
d135 2
a136 1
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d144 1
a144 1
	else
d147 5
d185 2
a186 1
		IPSEC_ISTAT(espstat.esps_nopf, ahstat.ahs_nopf);
d198 2
a199 1
		IPSEC_ISTAT(espstat.esps_notdb, ahstat.ahs_notdb);
d207 2
a208 1
		IPSEC_ISTAT(espstat.esps_invalid, ahstat.ahs_invalid);
d216 2
a217 1
		IPSEC_ISTAT(espstat.esps_noxform, ahstat.ahs_noxform);
d285 2
a286 1
		IPSEC_ISTAT(espstat.esps_badkcr, ahstat.ahs_badkcr);
d297 2
a298 1
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d337 2
a338 1
				    ahstat.ahs_pdrops);
d371 2
a372 1
				    ahstat.ahs_pdrops);
d397 2
a398 1
			IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
d415 2
a416 1
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d455 2
a456 1
				    ahstat.ahs_pdrops);
d489 2
a490 1
				    ahstat.ahs_pdrops);
d516 2
a517 1
			IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
d531 1
a531 1
	if (mt == NULL) {
d538 2
a539 1
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d563 2
d605 5
d628 5
d681 18
a698 1
	}
d802 44
d1050 1
d1053 1
a1053 1
/* IPv6 ESP callback. */
d1059 56
d1116 3
@


1.47
log
@Copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.46 2001/06/24 18:22:47 provos Exp $	*/
d105 19
a123 36
    union sockaddr_union dst_address;
    struct tdb *tdbp;
    u_int32_t spi;
    int s;

    IPSEC_ISTAT(espstat.esps_input, ahstat.ahs_input);

    if (m == 0)
    {
	DPRINTF(("ipsec_common_input(): NULL packet received\n"));
        IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
        return EINVAL;
    }

    if ((sproto == IPPROTO_ESP && !esp_enable) ||
	(sproto == IPPROTO_AH && !ah_enable))
    {
        m_freem(m);
        IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
        return EOPNOTSUPP;
    }

    if (m->m_pkthdr.len - skip < 2 * sizeof(u_int32_t))
    {
        m_freem(m);
        IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
	DPRINTF(("ipsec_common_input(): packet too small\n"));
        return EINVAL;
    }

    /* Retrieve the SPI from the relevant IPsec header */
    if (sproto == IPPROTO_ESP)
      m_copydata(m, skip, sizeof(u_int32_t), (caddr_t) &spi);
    else
      m_copydata(m, skip + sizeof(u_int32_t), sizeof(u_int32_t),
		 (caddr_t) &spi);
d125 15
a139 1
    /*
d145 2
a146 2
    bzero(&dst_address, sizeof(dst_address));
    dst_address.sa.sa_family = af;
d148 1
a148 2
    switch (af)
    {
d151 5
a155 4
	    dst_address.sin.sin_len = sizeof(struct sockaddr_in);
	    m_copydata(m, offsetof(struct ip, ip_dst), sizeof(struct in_addr),
		       (caddr_t) &(dst_address.sin.sin_addr));
	    break;
d160 5
a164 5
	    dst_address.sin6.sin6_len = sizeof(struct sockaddr_in6);
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		       sizeof(struct in6_addr),
		       (caddr_t) &(dst_address.sin6.sin6_addr));
	    break;
d168 18
a185 17
	    DPRINTF(("ipsec_common_input(): unsupported protocol family %d\n",
		     af));
	    m_freem(m);
	    IPSEC_ISTAT(espstat.esps_nopf, ahstat.ahs_nopf);
	    return EPFNOSUPPORT;
    }

    s = spltdb();
    tdbp = gettdb(spi, &dst_address, sproto);
    if (tdbp == NULL)
    {
	splx(s);
	DPRINTF(("ipsec_common_input(): could not find SA for packet to %s, spi %08x\n", ipsp_address(dst_address), ntohl(spi)));
	m_freem(m);
	IPSEC_ISTAT(espstat.esps_notdb, ahstat.ahs_notdb);
	return ENOENT;
    }
d187 7
a193 8
    if (tdbp->tdb_flags & TDBF_INVALID)
    {
	splx(s);
	DPRINTF(("ipsec_common_input(): attempted to use invalid SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
	m_freem(m);
	IPSEC_ISTAT(espstat.esps_invalid, ahstat.ahs_invalid);
	return EINVAL;
    }
d195 7
a201 8
    if (tdbp->tdb_xform == NULL)
    {
	splx(s);
	DPRINTF(("ipsec_common_input(): attempted to use uninitialized SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
	m_freem(m);
	IPSEC_ISTAT(espstat.esps_noxform, ahstat.ahs_noxform);
	return ENXIO;
    }
d203 7
a209 8
    if (tdbp->tdb_dst.sa.sa_family == AF_INET)
    {
	/*
	 * XXX The fragment conflicts with scoped nature of IPv6, so do it for
	 * only for IPv4 for now.
	 */
	m->m_pkthdr.rcvif = &encif[0].sc_if;
    }
d211 10
a220 9
    /* Register first use, setup expiration timer */
    if (tdbp->tdb_first_use == 0)
    {
	tdbp->tdb_first_use = time.tv_sec;
	if (tdbp->tdb_flags & TDBF_FIRSTUSE)
	    timeout_add(&tdbp->tdb_first_tmo, hz * tdbp->tdb_exp_first_use);
	if (tdbp->tdb_flags & TDBF_SOFT_FIRSTUSE)
	    timeout_add(&tdbp->tdb_sfirst_tmo, hz * tdbp->tdb_soft_first_use);
    }
d222 1
a222 1
    /*
d226 7
a232 10
    if ((*(tdbp->tdb_xform->xf_input))(m, tdbp, skip, protoff) == NULL)
    {
	splx(s);
	return EINVAL;
    }
    else
    {
	splx(s);
	return 0;
    }
d241 1
a241 1
		      struct m_tag *mt)
d243 1
a243 1
    int prot, af, sproto;
d246 1
a246 1
    struct ifnet *bpfif;
d250 1
a250 1
    struct ip *ip, ipn;
d254 1
a254 1
    struct ip6_hdr *ip6, ip6n;
d256 2
a257 2
    struct m_tag *mtag;
    struct tdb_ident *tdbi;
d259 2
a260 2
    af = tdbp->tdb_dst.sa.sa_family;
    sproto = tdbp->tdb_sproto;
d262 1
a262 1
    tdbp->tdb_last_used = time.tv_sec;
d264 6
a269 7
    /* Sanity check */
    if (m == NULL)
    {
	/* The called routine will print a message if necessary */
	IPSEC_ISTAT(espstat.esps_badkcr, ahstat.ahs_badkcr);
	return EINVAL;
    }
d272 9
a280 16
    /* Fix IPv4 header */
    if (tdbp->tdb_dst.sa.sa_family == AF_INET)
    {
        if ((m->m_len < skip) && ((m = m_pullup(m, skip)) == NULL))
        {
	    DPRINTF(("ipsec_common_input_cb(): processing failed for SA %s/%08x\n", ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
            IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
            return ENOBUFS;
        }

	ip = mtod(m, struct ip *);
	ip->ip_len = htons(m->m_pkthdr.len);
	HTONS(ip->ip_off);
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
	prot = ip->ip_p;
d282 39
a320 22
	/* IP-in-IP encapsulation */
	if (prot == IPPROTO_IPIP)
	{
	    /* ipn will now contain the inner IPv4 header */
	    m_copydata(m, ip->ip_hl << 2, sizeof(struct ip), (caddr_t) &ipn);

	    /*
	     * Check that the inner source address is the same as
	     * the proxy address, if available.
	     */
	    if (((tdbp->tdb_proxy.sa.sa_family == AF_INET) &&
		 (tdbp->tdb_proxy.sin.sin_addr.s_addr != INADDR_ANY) &&
		 (ipn.ip_src.s_addr != tdbp->tdb_proxy.sin.sin_addr.s_addr)) ||
		((tdbp->tdb_proxy.sa.sa_family != AF_INET) &&
		 (tdbp->tdb_proxy.sa.sa_family != 0)))
	    {
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet_ntoa4(ipn.ip_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
		m_freem(m);
                IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
		return EACCES;
	    }
	}
d323 31
a353 24
	/* IPv6-in-IP encapsulation */
	if (prot == IPPROTO_IPV6)
	{
	    /* ip6n will now contain the inner IPv6 header */
	    m_copydata(m, ip->ip_hl << 2, sizeof(struct ip6_hdr),
		       (caddr_t) &ip6n);

	    /*
	     * Check that the inner source address is the same as
	     * the proxy address, if available.
	     */
	    if (((tdbp->tdb_proxy.sa.sa_family == AF_INET6) &&
		 !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_proxy.sin6.sin6_addr) &&
		 !IN6_ARE_ADDR_EQUAL(&ip6n.ip6_src,
				     &tdbp->tdb_proxy.sin6.sin6_addr)) ||
		((tdbp->tdb_proxy.sa.sa_family != AF_INET6) &&
		 (tdbp->tdb_proxy.sa.sa_family != 0)))
	    {
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", ip6_sprintf(&ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
		return EACCES;
	    }
	}
d356 22
a377 14
	/*
	 * Check that the source address is an expected one, if we know what
	 * it's supposed to be. This avoids source address spoofing.
	 */
	if (((tdbp->tdb_src.sa.sa_family == AF_INET) &&
	     (tdbp->tdb_src.sin.sin_addr.s_addr != INADDR_ANY) &&
	     (ip->ip_src.s_addr != tdbp->tdb_src.sin.sin_addr.s_addr)) ||
	    ((tdbp->tdb_src.sa.sa_family != AF_INET) &&
	     (tdbp->tdb_src.sa.sa_family != 0)))
	{
	    DPRINTF(("ipsec_common_input_cb(): source address %s doesn't correspond to expected source %s, SA %s/%08x\n", inet_ntoa4(ip->ip_src), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
	    m_freem(m);
	    IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
	    return EACCES;
a378 1
    }
d382 5
a386 10
    /* Fix IPv6 header */
    if (af == INET6)
    {
        if ((m->m_len < sizeof(struct ip6_hdr)) &&
            ((m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL))
        {
	    DPRINTF(("ipsec_common_input_cb(): processing failed for SA %s/%08x\n", ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
            IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
            return EACCES;
        }
d388 3
a390 2
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(struct ip6_hdr));
d392 10
a401 2
	/* Save protocol */
	m_copydata(m, protoff, 1, (unsigned char *) &prot);
d404 31
a434 22
	/* IP-in-IP encapsulation */
	if (prot == IPPROTO_IPIP)
	{
	    /* ipn will now contain the inner IPv4 header */
	    m_copydata(m, skip, sizeof(struct ip), (caddr_t) &ipn);

	    /*
	     * Check that the inner source address is the same as
	     * the proxy address, if available.
	     */
	    if (((tdbp->tdb_proxy.sa.sa_family == AF_INET) &&
		 (tdbp->tdb_proxy.sin.sin_addr.s_addr != INADDR_ANY) &&
		 (ipn.ip_src.s_addr != tdbp->tdb_proxy.sin.sin_addr.s_addr)) ||
		((tdbp->tdb_proxy.sa.sa_family != AF_INET) &&
		 (tdbp->tdb_proxy.sa.sa_family != 0)))
	    {
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet_ntoa4(ipn.ip_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
		return EACCES;
	    }
	}
d437 31
a467 5
	/* IPv6-in-IP encapsulation */
	if (prot == IPPROTO_IPV6)
	{
	    /* ip6n will now contain the inner IPv6 header */
	    m_copydata(m, skip, sizeof(struct ip6_hdr), (caddr_t) &ip6n);
d469 24
a492 16
	    /*
	     * Check that the inner source address is the same as
	     * the proxy address, if available.
	     */
	    if (((tdbp->tdb_proxy.sa.sa_family == AF_INET6) &&
		 !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_proxy.sin6.sin6_addr) &&
		 !IN6_ARE_ADDR_EQUAL(&ip6n.ip6_src,
				     &tdbp->tdb_proxy.sin6.sin6_addr)) ||
		((tdbp->tdb_proxy.sa.sa_family != AF_INET6) &&
		 (tdbp->tdb_proxy.sa.sa_family != 0)))
	    {
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", ip6_sprintf(&ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
		return EACCES;
	    }
d494 1
d497 6
a502 2
	 * Check that the source address is an expected one, if we know what
	 * it's supposed to be. This avoids source address spoofing.
d504 30
a533 11
	if (((tdbp->tdb_src.sa.sa_family == AF_INET6) &&
	     !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_src.sin6.sin6_addr) &&
	     !IN6_ARE_ADDR_EQUAL(&ip6->ip6_src,
				 &tdbp->tdb_src.sin6.sin6_addr)) ||
	    ((tdbp->tdb_src.sa.sa_family != AF_INET6) &&
	     (tdbp->tdb_src.sa.sa_family != 0)))
	{
	    DPRINTF(("ipsec_common_input_cb(): packet %s to %s does not match any ACL entries, SA %s/%08x\n", ip6_sprintf(&ip6->ip6_src), ip6_sprintf(&ip6->ip6_dst), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
	    m_freem(m);
	    IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
	    return EACCES;
d535 2
a536 2
    }
#endif /* INET6 */
d538 12
a549 42
    /*
     * Record what we've done to the packet (under what SA it was
     * processed). If we've been passed an mtag, it means the packet
     * was already processed by an ethernet/crypto combo card and
     * thus has a tag attached with all the right information, but
     * with a PACKET_TAG_IPSEC_IN_CRYPTO_DONE as opposed to
     * PACKET_TAG_IPSEC_IN_DONE type; in that case, just change the type.
     */
    if (mt == NULL)
    {
	mtag = m_tag_get(PACKET_TAG_IPSEC_IN_DONE, sizeof(struct tdb_ident),
			 M_NOWAIT);
	if (mtag == NULL)
	{
	    m_freem(m);
	    DPRINTF(("ipsec_common_input_cb(): failed to get tag\n"));
	    IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
	    return ENOMEM;
	}

	tdbi = (struct tdb_ident *)(mtag + 1);
	bcopy(&tdbp->tdb_dst, &tdbi->dst, sizeof(union sockaddr_union));
	tdbi->proto = tdbp->tdb_sproto;
	tdbi->spi = tdbp->tdb_spi;

	m_tag_prepend(m, mtag);
    }
    else
      mt->m_tag_id = PACKET_TAG_IPSEC_IN_DONE;

    if (sproto == IPPROTO_ESP)
    {
	/* Packet is confidential ? */
	if (tdbp->tdb_encalgxform)
	  m->m_flags |= M_CONF;

	/* Check if we had authenticated ESP */
	if (tdbp->tdb_authalgxform)
	  m->m_flags |= M_AUTH;
    }
    else
      m->m_flags |= M_AUTH;
d551 7
a557 21
#if NBPFILTER > 0
    bpfif = &encif[0].sc_if;
    if (bpfif->if_bpf)
    {
        /*
         * We need to prepend the address family as
         * a four byte field.  Cons up a dummy header
         * to pacify bpf.  This is safe because bpf
         * will only read from the mbuf (i.e., it won't
         * try to free it or keep a pointer a to it).
         */
        struct mbuf m1;
        struct enchdr hdr;

	hdr.af = af;
	hdr.spi = tdbp->tdb_spi;
	hdr.flags = m->m_flags & (M_AUTH|M_CONF);

        m1.m_next = m;
        m1.m_len = ENC_HDRLEN;
        m1.m_data = (char *) &hdr;
d559 2
a560 2
        bpf_mtap(bpfif->if_bpf, &m1);
    }
d563 2
a564 3
    /* Call the appropriate IPsec transform callback */
    switch (af)
    {
d567 2
a568 2
	    switch (sproto)
	    {
d570 1
a570 1
		    return esp4_input_cb(m);
d573 1
a573 1
		    return ah4_input_cb(m);
d576 6
a581 5
		    DPRINTF(("ipsec_common_input_cb(): unknown/unsupported security protocol %d\n", sproto));
		    m_freem(m);
		    return EPFNOSUPPORT;
	    }
	    break;
d586 1
a586 2
	    switch (sproto)
	    {
d588 1
a588 1
		    return esp6_input_cb(m, skip, protoff);
d591 1
a591 1
		    return ah6_input_cb(m, skip, protoff);
d594 6
a599 5
		    DPRINTF(("ipsec_common_input_cb(): unknown/unsupported security protocol %d\n", sproto));
		    m_freem(m);
		    return EPFNOSUPPORT;
	    }
	    break;
d603 5
a607 4
	    DPRINTF(("ipsec_common_input_cb(): unknown/unsupported protocol family %d\n", af));
	    m_freem(m);
	    return EPFNOSUPPORT;
    }
d613 1
a613 1
	   size_t newlen)
d615 3
a617 3
    /* All sysctl names at this level are terminal. */
    if (namelen != 1)
      return ENOTDIR;
d619 1
a619 2
    switch (name[0])
    {
d621 1
a621 1
	    return sysctl_int(oldp, oldlen, newp, newlen, &esp_enable);
d623 3
a625 3
	    return ENOPROTOOPT;
    }
    /* NOTREACHED */
d630 1
a630 1
	  size_t newlen)
d632 3
a634 3
    /* All sysctl names at this level are terminal. */
    if (namelen != 1)
      return ENOTDIR;
d636 1
a636 2
    switch (name[0])
    {
d638 1
a638 1
	    return sysctl_int(oldp, oldlen, newp, newlen, &ah_enable);
d640 3
a642 3
	    return ENOPROTOOPT;
    }
    /* NOTREACHED */
d646 1
a646 1
/* IPv4 AH wrapper */
d650 1
a650 1
    int skip;
d652 4
a655 4
    va_list ap;
    va_start(ap, m);
    skip = va_arg(ap, int);
    va_end(ap);
d657 3
a659 3
    ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
		       IPPROTO_AH);
    return;
d662 1
a662 1
/* IPv4 AH callback */
d666 2
a667 2
    struct ifqueue *ifq = &ipintrq;
    int s = splimp();
d669 4
a672 4
    /*
     * Interface pointer is already in first mbuf; chop off the
     * `outer' header and reschedule.
     */
d674 4
a677 5
    if (IF_QFULL(ifq))
    {
	IF_DROP(ifq);
	ahstat.ahs_qfull++;
	splx(s);
d679 5
a683 8
	m_freem(m);
	DPRINTF(("ah4_input_cb(): dropped packet because of full IP queue\n"));
	return ENOBUFS;
    }

    IF_ENQUEUE(ifq, m);
    schednetisr(NETISR_IP);
    splx(s);
d685 4
a688 1
    return 0;
d702 1
a702 1
/* IPv4 ESP wrapper */
d706 1
a706 1
    int skip;
d708 4
a711 4
    va_list ap;
    va_start(ap, m);
    skip = va_arg(ap, int);
    va_end(ap);
d713 2
a714 2
    ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
		       IPPROTO_ESP);
d717 1
a717 1
/* IPv4 ESP callback */
d721 2
a722 2
    struct ifqueue *ifq = &ipintrq;
    int s = splimp();
d724 8
a731 9
    /*
     * Interface pointer is already in first mbuf; chop off the
     * `outer' header and reschedule.
     */
    if (IF_QFULL(ifq))
    {
	IF_DROP(ifq);
	espstat.esps_qfull++;
	splx(s);
d733 5
a737 8
	m_freem(m);
	DPRINTF(("esp4_input_cb(): dropped packet because of full IP queue\n"));
	return ENOBUFS;
    }

    IF_ENQUEUE(ifq, m);
    schednetisr(NETISR_IP);
    splx(s);
d739 4
a742 1
    return 0;
d760 1
a760 1
		/* Find the right MTU */
d762 1
a762 1
				      offsetof(struct icmp, icmp_ip));
d765 2
a766 1
		/* Ignore the packet, if we do not receive a MTU
d799 1
a799 1
				ip_mtudisc_timeout;
a801 1

a803 1

d819 1
a819 1
/* IPv6 AH wrapper */
d823 22
a844 26
    int l = 0;
    int protoff;
    struct ip6_ext ip6e;

    if (*offp < sizeof(struct ip6_hdr))
    {
	DPRINTF(("ah6_input(): bad offset\n"));
	return IPPROTO_DONE;
    }
    else if (*offp == sizeof(struct ip6_hdr))
    {
	protoff = offsetof(struct ip6_hdr, ip6_nxt);
    }
    else
    {
	/* Chase down the header chain... */
	protoff = sizeof(struct ip6_hdr);

	do
	{
	    protoff += l;
	    m_copydata(*mp, protoff, sizeof(ip6e), (caddr_t) &ip6e);
	    if (ip6e.ip6e_nxt == IPPROTO_AH)
		l = (ip6e.ip6e_len + 2) << 2;
	    else
		l = (ip6e.ip6e_len + 1) << 3;
d846 2
a847 2
	    if (l <= 0)
		panic("ah6_input: l went zero or negative");
d849 1
a849 1
	} while (protoff + l < *offp);
d851 9
a859 8
	/* Malformed packet check */
	if (protoff + l != *offp)
	{
	    DPRINTF(("ah6_input(): bad packet header chain\n"));
	    ahstat.ahs_hdrops++;
	    m_freem(*mp);
	    *mp = NULL;
	    return IPPROTO_DONE;
d861 2
a862 6

	protoff += offsetof(struct ip6_ext, ip6e_nxt);
    }

    ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
    return IPPROTO_DONE;
d865 1
a865 1
/* IPv6 AH callback */
d869 7
a875 17
    int nxt;
    u_int8_t nxt8;
    int nest = 0;

    /* Retrieve new protocol */
    m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &nxt8);
    nxt = nxt8;

    /*
     * see the end of ip6_input for this logic.
     * IPPROTO_IPV[46] case will be processed just like other ones
     */
    while (nxt != IPPROTO_DONE) {
	if (ip6_hdrnestlimit && (++nest > ip6_hdrnestlimit)) {
	    ip6stat.ip6s_toomanyhdr++;
	    goto bad;
	}
d878 2
a879 2
	 * protection against faulty packet - there should be
	 * more sanity checks in header chain processing.
d881 16
a896 4
	if (m->m_pkthdr.len < off) {
	    ip6stat.ip6s_tooshort++;
	    in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_truncated);
	    goto bad;
d898 1
d900 3
a902 8
	nxt = (*inet6sw[ip6_protox[nxt]].pr_input)(&m, &off, nxt);
    }

    return 0;

bad:
    m_freem(m);
    return EINVAL;
d905 1
a905 1
/* IPv6 ESP wrapper */
d909 22
a930 26
    int l = 0;
    int protoff;
    struct ip6_ext ip6e;

    if (*offp < sizeof(struct ip6_hdr))
    {
	DPRINTF(("esp6_input(): bad offset\n"));
	return IPPROTO_DONE;
    }
    else if (*offp == sizeof(struct ip6_hdr))
    {
	protoff = offsetof(struct ip6_hdr, ip6_nxt);
    }
    else
    {
	/* Chase down the header chain... */
	protoff = sizeof(struct ip6_hdr);

	do
	{
	    protoff += l;
	    m_copydata(*mp, protoff, sizeof(ip6e), (caddr_t) &ip6e);
	    if (ip6e.ip6e_nxt == IPPROTO_AH)
		l = (ip6e.ip6e_len + 2) << 2;
	    else
		l = (ip6e.ip6e_len + 1) << 3;
d932 2
a933 2
	    if (l <= 0)
		panic("esp6_input: l went zero or negative");
d935 1
a935 1
	} while (protoff + l < *offp);
d937 9
a945 8
	/* Malformed packet check */
	if (protoff + l != *offp)
	{
	    DPRINTF(("esp6_input(): bad packet header chain\n"));
	    espstat.esps_hdrops++;
	    m_freem(*mp);
	    *mp = NULL;
	    return IPPROTO_DONE;
d947 2
a948 6

	protoff += offsetof(struct ip6_ext, ip6e_nxt);
    }

    ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
    return IPPROTO_DONE;
d951 1
a951 1
/* IPv6 ESP callback */
d955 1
a955 1
    return ah6_input_cb(m, skip, protoff);
@


1.46
log
@path mtu discovery for ipsec.  on receiving a need fragment icmp match
against active tdb and store the ipsec header size corrected mtu
@
text
@d1 1
a1 2
/*	$OpenBSD: ipsec_input.c,v 1.45 2001/06/23 16:15:56 fgsch Exp $	*/

d20 1
d22 1
a22 1
 * Permission to use, copy, and modify this software without fee
@


1.45
log
@Remove unneeded ip_id convertions.
Instead of using HTONS macro in some places, use htons directly in the
struct member and save us a few bytes.
Fix comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.44 2001/06/19 00:48:23 deraadt Exp $	*/
d40 1
d53 1
d55 1
d77 1
d650 11
d703 73
@


1.44
log
@mop up after angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.43 2001/06/08 03:13:15 angelos Exp $	*/
a287 1
	HTONS(ip->ip_id);
@


1.43
log
@Trim include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.42 2001/06/05 11:10:12 angelos Exp $	*/
d39 1
@


1.42
log
@Add a few DPRINTF()'s
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.41 2001/05/29 01:19:37 angelos Exp $	*/
a38 2
#include <sys/systm.h>
#include <sys/malloc.h>
a39 2
#include <sys/domain.h>
#include <sys/protosw.h>
a41 1
#include <sys/errno.h>
a43 2
#include <machine/cpu.h>

a44 1
#include <net/route.h>
@


1.41
log
@Record last use time for SAs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.40 2001/05/27 03:49:14 angelos Exp $	*/
d117 1
a117 1
	DPRINTF(("%s: NULL packet received\n"));
d134 1
d470 1
@


1.40
log
@If we are passed a packet tag, it's an IPSEC_IN_CRYPTO_DONE so convert
it to IPSEC_IN_DONE, rather than adding a new one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.39 2001/05/27 03:37:23 angelos Exp $	*/
d270 2
@


1.39
log
@Forgot to convert this tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.38 2001/05/20 08:33:33 angelos Exp $	*/
d249 2
a250 1
ipsec_common_input_cb(struct mbuf *m, struct tdb *tdbp, int skip, int protoff)
d454 5
a458 1
     * processed).
d460 1
a460 3
    mtag = m_tag_get(PACKET_TAG_IPSEC_IN_DONE, sizeof(struct tdb_ident),
		     M_NOWAIT);
    if (mtag == NULL)
d462 8
a469 4
	m_freem(m);
	IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
	return ENOMEM;
    }
d471 4
a474 4
    tdbi = (struct tdb_ident *)(mtag + 1);
    bcopy(&tdbp->tdb_dst, &tdbi->dst, sizeof(union sockaddr_union));
    tdbi->proto = tdbp->tdb_sproto;
    tdbi->spi = tdbp->tdb_spi;
d476 4
a479 1
    m_tag_prepend(m, mtag);
@


1.38
log
@Use packet tags to signal input IPsec processing to upper layer protocols.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.37 2001/05/11 17:20:11 aaron Exp $	*/
d455 1
a455 1
    mtag = m_tag_get(PACKET_TAG_IPSEC_DONE, sizeof(struct tdb_ident),
@


1.37
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.36 2001/04/06 04:42:08 csapuntz Exp $	*/
d264 2
d455 3
a457 7
    /* XXX We need a better packets-attributes framework */
    if (m->m_pkthdr.tdbi)
      free(m->m_pkthdr.tdbi, M_TEMP);

    MALLOC(m->m_pkthdr.tdbi, void *, sizeof(struct tdb_ident), M_TEMP,
	   M_NOWAIT);
    if (m->m_pkthdr.tdbi == NULL)
d464 6
a469 4
    bcopy(&tdbp->tdb_dst, &(((struct tdb_ident *) m->m_pkthdr.tdbi)->dst),
	  sizeof(union sockaddr_union));
    ((struct tdb_ident *) m->m_pkthdr.tdbi)->proto = tdbp->tdb_sproto;
    ((struct tdb_ident *) m->m_pkthdr.tdbi)->spi = tdbp->tdb_spi;
@


1.36
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.35 2001/03/30 19:22:54 angelos Exp $	*/
d280 1
a280 1
        if ((m->m_len < skip) && ((m = m_pullup(m, skip)) == 0))
d368 1
a368 1
            ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0))
@


1.35
log
@Protect the IF_XXX macros in the callback routines with splimp(). Doh!

Thanks to erik@@ipunplugged.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.34 2001/03/28 20:03:06 angelos Exp $	*/
a85 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.34
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.33 2001/03/15 06:31:00 mickey Exp $	*/
d619 1
a628 1
	m_freem(m);
d630 1
d632 1
d639 2
d664 1
a672 1
	m_freem(m);
d674 1
d676 1
d683 2
@


1.33
log
@convert SA expirations to the new timeouts.
simplifies expirations handling a lot.
tdb_exp_timeout and tdb_soft_timeout are made
consistant throughout the code to be a relative time offsets,
just like first_use timeouts.
tested on singlehost isakmpd setup.
lots of dangling spaces and tabs removed.
angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.32 2000/09/19 03:20:59 angelos Exp $	*/
a79 2
#define PI_MAGIC 0xdeadbeef /* XXX horror! */

d219 1
a219 4
	if (tdbp->tdb_interface)
	  m->m_pkthdr.rcvif = (struct ifnet *) tdbp->tdb_interface;
	else
	  m->m_pkthdr.rcvif = &encif[0].sc_if;
d284 1
a284 1
        if ((m = m_pullup(m, skip)) == 0)
d371 2
a372 1
        if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0)
d457 2
a458 1
    if (m->m_pkthdr.tdbi && m->m_pkthdr.tdbi != (void *) PI_MAGIC)
d489 1
a489 4
    if (tdbp->tdb_interface)
	bpfif = (struct ifnet *) tdbp->tdb_interface;
    else
	bpfif = &encif[0].sc_if;
a627 2
	if (m->m_pkthdr.tdbi && m->m_pkthdr.tdbi != (void *) PI_MAGIC)
	  free(m->m_pkthdr.tdbi, M_TEMP);
a667 2
	if (m->m_pkthdr.tdbi && m->m_pkthdr.tdbi != (void *) PI_MAGIC)
	  free(m->m_pkthdr.tdbi, M_TEMP);
a772 2
    if (m->m_pkthdr.tdbi && m->m_pkthdr.tdbi != (void *) PI_MAGIC)
      free(m->m_pkthdr.tdbi, M_TEMP);
@


1.32
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.31 2000/09/17 19:52:24 angelos Exp $	*/
d5 1
a5 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
d8 1
a8 1
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
d21 1
a21 1
 *	
d25 1
a25 1
 * modification of this software. 
d196 1
a196 1
	
d231 4
a234 1
	tdb_expiration(tdbp, TDBEXP_TIMEOUT);
d354 1
a354 1
	/* 
d438 1
a438 1
	/* 
d496 1
a496 1
    if (bpfif->if_bpf) 
d515 1
a515 1
        
d627 1
a627 1
     * Interface pointer is already in first mbuf; chop off the 
d670 1
a670 1
     * Interface pointer is already in first mbuf; chop off the 
@


1.31
log
@Drop dubious ESP/AH packets without crashing (thanks to dr@@kyx.net and
mfranz@@cisco.com for finding the problem).
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.30 2000/07/11 21:11:08 millert Exp $	*/
d80 2
d219 1
a219 1
	 * only for IPv4 for now
a233 10
    /* If we do ingress filtering and the list is empty, quick drop */
    if (ipsec_acl && (tdbp->tdb_access == NULL))
    {
	DPRINTF(("ipsec_common_input(): packet dropped due to empty policy list, SA %s/%08x/%u\n", ipsp_address(tdbp->tdb_dst), ntohl(spi), tdbp->tdb_sproto));
	splx(s);
	m_freem(m);
	IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
	return EACCES;
    }

a256 2
    union sockaddr_union src_address, dst_address, src2, dst2;
    caddr_t sport = 0, dport = 0;
d258 1
a258 1
    struct flow *flow;
a281 2
    bcopy(&tdbp->tdb_dst, &dst_address, tdbp->tdb_dst.sa.sa_len);

d446 1
a446 1
	    DPRINTF(("ipsec_common_input_cb(): packet %s to %s does not match any ACL entries, SA %s/%08x\n", ipsp_address(src_address), ipsp_address(dst_address), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d454 10
a463 2
    /* Access control */
    if (ipsec_acl)
d465 3
a467 76
	bzero(&src_address, sizeof(src_address));
	src_address.sa.sa_family = af;
	src_address.sa.sa_len = dst_address.sa.sa_len;

#ifdef INET
	if (af == AF_INET)
        {
	    m_copydata(m, offsetof(struct ip, ip_src), sizeof(struct in_addr),
		       (caddr_t) &(src_address.sin.sin_addr));
	    sport = (caddr_t) &src_address.sin.sin_port;
	    dport = (caddr_t) &dst_address.sin.sin_port;
	}
#endif /* INET */

#ifdef INET6
	if (af == AF_INET6)
        {
	    m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
		       sizeof(struct in6_addr),
		       (caddr_t) &(src_address.sin6.sin6_addr));
	    sport = (caddr_t) &src_address.sin6.sin6_port;
	    dport = (caddr_t) &dst_address.sin6.sin6_port;
        }
#endif /* INET6 */

	/* Save transport layer source/destination ports, if any */
	switch (prot)
	{
	    case IPPROTO_TCP:
		m_copydata(m, skip + offsetof(struct tcphdr, th_sport),
			   sizeof(u_int16_t), (caddr_t) sport);
		m_copydata(m, skip + offsetof(struct tcphdr, th_dport),
			   sizeof(u_int16_t), (caddr_t) dport);
		break;

	    case IPPROTO_UDP:
		m_copydata(m, skip + offsetof(struct udphdr, uh_sport),
			   sizeof(u_int16_t), (caddr_t) sport);
		m_copydata(m, skip + offsetof(struct udphdr, uh_dport),
			   sizeof(u_int16_t), (caddr_t) dport);
		break;

	    default:
		/* Nothing needed */
	}

	for (flow = tdbp->tdb_access; flow; flow = flow->flow_next)
	{
	    /* Match for address family */
	    if (flow->flow_src.sa.sa_family != af)
	      continue;

	    /* Match for transport protocol */
	    if (flow->flow_proto && flow->flow_proto != prot)
	      continue;

	    /* Netmask handling */
	    rt_maskedcopy(&src_address.sa, &src2.sa, &flow->flow_srcmask.sa);
	    rt_maskedcopy(&dst_address.sa, &dst2.sa, &flow->flow_dstmask.sa);

	    /* Check addresses */
	    if (bcmp(&src2, &flow->flow_src, src2.sa.sa_len) ||
		bcmp(&dst2, &flow->flow_dst, dst2.sa.sa_len))
	      continue;

	    break; /* success! */
	}

	if (flow == NULL)
	{
	    /* Failed to match any entry in the ACL */
		DPRINTF(("ipsec_common_input_cb(): packet from %s to %s dropped due to policy, SA %s/%08x\n", ipsp_address(src_address), ipsp_address(dst_address), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
		return EACCES;
	}
d470 4
a473 25
    if (prot == IPPROTO_TCP || prot == IPPROTO_UDP)
    {
	if (tdbp->tdb_bind_out)
	{
	    if (!(m->m_flags & M_PKTHDR))
	      DPRINTF(("ipsec_common_input_cb(): mbuf is not a packet header!\n"));

	    MALLOC(m->m_pkthdr.tdbi, struct tdb_ident *,
		   sizeof(struct tdb_ident), M_TEMP, M_NOWAIT);

	    if (m->m_pkthdr.tdbi == NULL)
	    {
		((struct tdb_ident *) m->m_pkthdr.tdbi)->spi =
						tdbp->tdb_bind_out->tdb_spi;
		((struct tdb_ident *) m->m_pkthdr.tdbi)->dst =
						tdbp->tdb_bind_out->tdb_dst;
		((struct tdb_ident *) m->m_pkthdr.tdbi)->proto =
						tdbp->tdb_bind_out->tdb_sproto;
	    }
	}
	else
	  m->m_pkthdr.tdbi = NULL;
    }
    else
      m->m_pkthdr.tdbi = NULL;
d631 1
a631 1
	if (m->m_pkthdr.tdbi)
d673 1
a673 1
	if (m->m_pkthdr.tdbi)
d780 2
d783 1
a783 1
    return EINVAL;	/*?*/
@


1.30
log
@Correctly handle ip_off; angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.29 2000/06/20 04:54:58 itojun Exp $	*/
d132 7
@


1.29
log
@do not play with rcvif, if the traffic is non-IPv4.
by setting rcvif to enc*, we break IPv6 scope considerations.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.28 2000/06/19 17:11:32 itojun Exp $	*/
d301 1
@


1.28
log
@correct header chasing code.  take care of AH length.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.27 2000/06/18 19:10:50 angelos Exp $	*/
d206 11
a216 4
    if (tdbp->tdb_interface)
      m->m_pkthdr.rcvif = (struct ifnet *) tdbp->tdb_interface;
    else
      m->m_pkthdr.rcvif = &encif[0].sc_if;
d262 3
d579 5
a583 1
    if (m->m_pkthdr.rcvif->if_bpf) 
d603 1
a603 1
        bpf_mtap(m->m_pkthdr.rcvif->if_bpf, &m1);
@


1.27
log
@Arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.26 2000/06/18 19:05:50 angelos Exp $	*/
d769 1
a769 1
    u_int8_t nxt = 0;
d771 1
d789 11
a799 5
	    protoff += nxt;
	    m_copydata(*mp, protoff + offsetof(struct ip6_ext, ip6e_len),
		       sizeof(u_int8_t), (caddr_t) &nxt);
	    nxt = (nxt + 1) * 8;
	} while (protoff + nxt < *offp);
d802 1
a802 1
	if (protoff + nxt != *offp)
d864 1
a864 1
    u_int8_t nxt = 0;
d866 1
d884 11
a894 5
	    protoff += nxt;
	    m_copydata(*mp, protoff + offsetof(struct ip6_ext, ip6e_len),
		       sizeof(u_int8_t), (caddr_t) &nxt);
	    nxt = (nxt + 1) * 8;
	} while (protoff + nxt < *offp);
d897 1
a897 1
	if (protoff + nxt != *offp)
@


1.26
log
@Use ip6_sprintf() rather than the home-cooked inet6_ntoa4()
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.25 2000/06/18 05:58:46 itojun Exp $	*/
d337 1
a337 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", ip6_sprintf(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d422 1
a422 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", ip6_sprintf(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
@


1.25
log
@IPv6 AH/ESP support, inbound side only.  tested with KAME.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.24 2000/06/18 00:24:11 angelos Exp $	*/
d337 1
a337 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet6_ntoa4(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d422 1
a422 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet6_ntoa4(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
@


1.24
log
@Remove outdated comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.23 2000/03/29 10:15:22 angelos Exp $	*/
d64 1
d66 1
d68 2
d96 5
d375 1
a375 1
	ip6->ip6_plen = htons(m->m_pkthdr.len);
d619 1
a619 1
		    return esp6_input_cb(m, protoff);
d622 1
a622 1
		    return ah6_input_cb(m, protoff);
d772 9
a780 2
    if (*offp == sizeof(struct ip6_hdr))
      protoff = offsetof(struct ip6_hdr, ip6_nxt);
d813 1
a813 1
ah6_input_cb(struct mbuf *mp, int protoff)
d815 3
a817 1
    u_int8_t nxt = 0;
d820 22
a841 1
    m_copydata(mp, protoff, sizeof(u_int8_t), (caddr_t) &nxt);
d843 2
a844 2
    /* XXX Requeue -- for now, drop packet */
    m_freem(mp);
d847 4
d860 9
a868 2
    if (*offp == sizeof(struct ip6_hdr))
      protoff = offsetof(struct ip6_hdr, ip6_nxt);
a894 1
    protoff = offsetof(struct ip6_hdr, ip6_nxt);
d901 1
a901 1
esp6_input_cb(struct mbuf *mp, int protoff)
d903 1
a903 9
    u_int8_t nxt = 0;

    /* Retrieve new protocol */
    m_copydata(mp, protoff, sizeof(u_int8_t), (caddr_t) &nxt);

    /* XXX Requeue -- for now, drop packet */
    m_freem(mp);

    return 0;
@


1.23
log
@Be consistent about packet properties.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.22 2000/03/29 09:37:02 angelos Exp $	*/
a35 8
 */

/*
 * Authentication Header Processing
 * Per RFC1826 (Atkinson, 1995)
 *
 * Encapsulation Security Payload Processing
 * Per RFC1827 (Atkinson, 1995)
@


1.23.2.1
log
@Pull in patch from current:
Fix (millert):
Correctly handle ip_off; angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.30 2000/07/11 21:11:08 millert Exp $	*/
a289 1
	HTONS(ip->ip_off);
@


1.23.2.2
log
@Pull in patch from current:
Errata:
Bad ESP/AH packets could cause a crash under certain conditions.
Fix (angelos):
Drop dubious ESP/AH packets without crashing (thanks to dr@@kyx.net and
mfranz@@cisco.com for finding the problem).
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.31 2000/09/17 19:52:24 angelos Exp $	*/
a130 7
    }

    if (m->m_pkthdr.len - skip < 2 * sizeof(u_int32_t))
    {
        m_freem(m);
        IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
        return EINVAL;
@


1.22
log
@Fix problem with TCP/UDP and ACLs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.21 2000/03/29 08:50:38 angelos Exp $	*/
d556 3
a558 2
	/* Packet is confidental */
	m->m_flags |= M_CONF;
@


1.21
log
@Minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.20 2000/03/17 10:25:23 angelos Exp $	*/
d456 6
a461 2
	  m_copydata(m, offsetof(struct ip, ip_src), sizeof(struct in_addr),
		     (caddr_t) &(src_address.sin.sin_addr));
d466 7
a472 3
	  m_copydata(m, offsetof(struct ip6_hdr, ip6_src),
		     sizeof(struct in6_addr),
		     (caddr_t) &(src_address.sin6.sin6_addr));
@


1.20
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.19 2000/02/07 06:09:09 itojun Exp $	*/
d111 1
a111 2
    union sockaddr_union src_address, dst_address;
    caddr_t sport = 0, dport = 0;
a153 2
	    sport = (caddr_t) &src_address.sin.sin_port;
	    dport = (caddr_t) &dst_address.sin.sin_port;
a161 2
	    sport = (caddr_t) &src_address.sin6.sin6_port;
	    dport = (caddr_t) &dst_address.sin6.sin6_port;
d190 1
a190 2
	DPRINTF(("ipsec_common_input(): attempted to use invalid SA %s/%08x\n",
		 ipsp_address(dst_address), ntohl(spi)));
d199 1
a199 1
	DPRINTF(("ipsec_common_input(): attempted to use uninitialized SA %s/%08x\n", ipsp_address(dst_address), ntohl(spi)));
d220 1
a220 1
	DPRINTF(("ipsec_common_input(): packet from %s dropped due to empty policy list, SA %s/%08x\n", ipsp_address(src_address), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
d274 2
d450 1
a450 1
	bzero(&src_address, sizeof(dst_address));
@


1.19
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.18 2000/01/27 08:09:12 angelos Exp $	*/
d84 1
a84 1
int ipsec_common_input(struct mbuf **, int, int, int, int);
d102 3
a104 1
 * in IPv4 or IPv6.
a105 1

d107 1
a107 1
ipsec_common_input(struct mbuf **m0, int skip, int protoff, int af, int sproto)
d110 2
a111 5
#define IPSEC_NAME (sproto == IPPROTO_ESP ? (af == AF_INET ? "esp4_input()" :\
					                     "esp6_input()") :\
                                            (af == AF_INET ? "ah4_input()" :\
                                                             "ah6_input()"))
    union sockaddr_union src_address, dst_address, src2, dst2;
a112 1
    struct flow *flow;
a113 1
    struct mbuf *m;
a114 1
    u_int8_t prot;
a116 8
#ifdef INET
    struct ip *ip, ipn;
#endif /* INET */

#ifdef INET6
    struct ip6_hdr *ip6, ip6n;
#endif /* INET6 */

d119 1
a119 1
    if (m0 == 0)
a124 2
    else
      m = *m0;
a129 1
	*m0 = NULL;
d174 2
a175 1
	    DPRINTF(("%s: unsupported protocol family %d\n", IPSEC_NAME, af));
a176 1
	    *m0 = NULL;
d186 1
a186 2
	DPRINTF(("%s: could not find SA for packet to %s, spi %08x\n",
		 IPSEC_NAME, ipsp_address(dst_address), ntohl(spi)));
a187 1
	*m0 = NULL;
d195 2
a196 2
	DPRINTF(("%s: attempted to use invalid SA %s/%08x\n",
		 IPSEC_NAME, ipsp_address(dst_address), ntohl(spi)));
a197 1
	*m0 = NULL;
d205 1
a205 2
	DPRINTF(("%s: attempted to use uninitialized SA %s/%08x\n",
		 IPSEC_NAME, ipsp_address(dst_address), ntohl(spi)));
a206 1
	*m0 = NULL;
d226 1
a226 1
	DPRINTF(("%s: packet from %s dropped due to empty policy list, SA %s/%08x\n", IPSEC_NAME, ipsp_address(src_address), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
a228 1
	*m0 = NULL;
d233 40
a272 1
    m = (*(tdbp->tdb_xform->xf_input))(m, tdbp, skip, protoff);
a275 1
	splx(s);
d282 1
a282 1
    if (af == AF_INET)
d286 1
a286 3
	    DPRINTF(("%s: processing failed for SA %s/%08x\n",
		     IPSEC_NAME, ipsp_address(tdbp->tdb_dst), ntohl(spi)));
	    splx(s);
d288 1
a288 2
	    *m0 = NULL;
            return ENOMEM;
d293 1
d314 1
a314 2
		DPRINTF(("%s: inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", IPSEC_NAME, inet_ntoa4(ipn.ip_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
		splx(s);
a315 1
	    	*m0 = NULL;
d340 1
a340 2
		DPRINTF(("%s: inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", IPSEC_NAME, inet6_ntoa4(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
		splx(s);
a341 1
	    	*m0 = NULL;
d358 1
a358 2
	    DPRINTF(("%s: source address %s doesn't correspond to expected source %s, SA %s/%08x\n", IPSEC_NAME, inet_ntoa4(ip->ip_src), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
	    splx(s);
a360 1
	    *m0 = NULL;
d372 1
a372 3
	    DPRINTF(("%s: processing failed for SA %s/%08x\n",
		     IPSEC_NAME, ipsp_address(tdbp->tdb_dst), ntohl(spi)));
	    splx(s);
d374 1
a374 2
	    *m0 = NULL;
            return ENOMEM;
d400 1
a400 2
		DPRINTF(("%s: inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", IPSEC_NAME, inet_ntoa4(ipn.ip_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
		splx(s);
a402 1
	    	*m0 = NULL;
d425 1
a425 2
		DPRINTF(("%s: inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", IPSEC_NAME, inet6_ntoa4(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
		splx(s);
a426 1
	    	*m0 = NULL;
d443 1
a443 2
	    DPRINTF(("%s: packet %s to %s does not match any ACL entries, SA %s/%08x\n", IPSEC_NAME, ipsp_address(src_address), ipsp_address(dst_address), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
	    splx(s);
a444 1
	    *m0 = NULL;
d517 1
a517 2
		DPRINTF(("%s: packet from %s to %s dropped due to policy, SA %s/%08x\n", IPSEC_NAME, ipsp_address(src_address), ipsp_address(dst_address), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
		splx(s);
a518 1
	    	*m0 = NULL;
d529 1
a529 1
	      DPRINTF(("%s: mbuf is not a packet header!\n", IPSEC_NAME));
a585 1
    splx(s);
d587 44
a630 3
    *m0 = m;
    return 0;
#undef IPSEC_NAME
d675 1
a675 3
    struct ifqueue *ifq = &ipintrq;
    struct mbuf *mp = m;
    int skip, s;
d682 10
a691 3
    if (ipsec_common_input(&mp, skip, offsetof(struct ip, ip_p), AF_INET,
			   IPPROTO_AH) != 0)
      return;
a697 1
    s = splimp();			/* isn't it already? */
d701 3
a703 3
	if (mp->m_pkthdr.tdbi)
	  free(mp->m_pkthdr.tdbi, M_TEMP);
	m_freem(mp);
d705 3
a707 3
	splx(s);
	DPRINTF(("ah4_input(): dropped packet because of full IP queue\n"));
	return;
d710 1
a710 1
    IF_ENQUEUE(ifq, mp);
d712 1
a712 1
    splx(s);
d719 1
a719 3
    struct ifqueue *ifq = &ipintrq;
    struct mbuf *mp = m;
    int skip, s;
d726 9
a734 3
    if (ipsec_common_input(&mp, skip, offsetof(struct ip, ip_p), AF_INET,
			   IPPROTO_ESP) != 0)
      return;
a739 2

    s = splimp();			/* isn't it already? */
d743 3
a745 3
	if (mp->m_pkthdr.tdbi)
	  free(mp->m_pkthdr.tdbi, M_TEMP);
	m_freem(mp);
d747 3
a749 3
	splx(s);
	DPRINTF(("esp4_input(): dropped packet because of full IP queue\n"));
	return;
d752 1
a752 1
    IF_ENQUEUE(ifq, mp);
d754 1
a754 1
    splx(s);
a762 1
    struct mbuf *m = *mp;
d770 1
a770 2
	/* Chase the header chain... */

d776 1
a776 1
	    m_copydata(m, protoff + offsetof(struct ip6_ext, ip6e_len),
d786 1
a786 1
	    m_freem(m);
d794 9
a802 5
    if (ipsec_common_input(&m, *offp, protoff, AF_INET6, proto) != 0)
    {
	*mp = NULL;
	return IPPROTO_DONE;
    }
d805 6
a810 2
    m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &nxt);
    return nxt;
a816 1
    struct mbuf *m = *mp;
d824 1
a824 2
	/* Chase the header chain... */

d830 1
a830 1
	    m_copydata(m, protoff + offsetof(struct ip6_ext, ip6e_len),
d840 1
a840 1
	    m_freem(m);
d849 9
a857 5
    if (ipsec_common_input(&m, *offp, protoff, AF_INET6, proto) != 0)
    {
	*mp = NULL;
	return IPPROTO_DONE;
    }
d860 6
a865 2
    m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &nxt);
    return nxt;
@


1.19.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
a84 1
int ipsec_common_input(struct mbuf *, int, int, int, int);
d102 1
a102 3
 * in IPv4 or IPv6. All it does is find the right TDB and call the appropriate
 * transform. The callback takes care of further processing (like ingress
 * filtering).
d104 1
d106 1
a106 1
ipsec_common_input(struct mbuf *m, int skip, int protoff, int af, int sproto)
d109 5
a113 2

    union sockaddr_union src_address, dst_address;
d115 1
d117 1
d119 1
d122 8
d132 1
a132 1
    if (m == 0)
d138 2
d145 1
d190 1
a190 2
	    DPRINTF(("ipsec_common_input(): unsupported protocol family %d\n",
		     af));
d192 1
d202 2
a203 1
	DPRINTF(("ipsec_common_input(): could not find SA for packet to %s, spi %08x\n", ipsp_address(dst_address), ntohl(spi)));
d205 1
d213 2
a214 2
	DPRINTF(("ipsec_common_input(): attempted to use invalid SA %s/%08x\n",
		 ipsp_address(dst_address), ntohl(spi)));
d216 1
d224 2
a225 1
	DPRINTF(("ipsec_common_input(): attempted to use uninitialized SA %s/%08x\n", ipsp_address(dst_address), ntohl(spi)));
d227 1
d247 1
a247 1
	DPRINTF(("ipsec_common_input(): packet from %s dropped due to empty policy list, SA %s/%08x\n", ipsp_address(src_address), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
d250 1
d255 1
a255 40
    /*
     * Call appropriate transform and return -- callback takes care of
     * everything else.
     */
    if ((*(tdbp->tdb_xform->xf_input))(m, tdbp, skip, protoff) == NULL)
    {
	splx(s);
	return EINVAL;
    }
    else
    {
	splx(s);
	return 0;
    }
}

/*
 * IPsec input callback, called by the transform callback. Takes care of
 * filtering and other sanity checks on the processed packet.
 */
int
ipsec_common_input_cb(struct mbuf *m, struct tdb *tdbp, int skip, int protoff)
{
    union sockaddr_union src_address, dst_address, src2, dst2;
    caddr_t sport = 0, dport = 0;
    int prot, af, sproto;
    struct flow *flow;

#ifdef INET
    struct ip *ip, ipn;
#endif /* INET */

#ifdef INET6
    struct ip6_hdr *ip6, ip6n;
#endif /* INET6 */

    af = tdbp->tdb_dst.sa.sa_family;
    sproto = tdbp->tdb_sproto;

    /* Sanity check */
d259 1
d266 1
a266 1
    if (tdbp->tdb_dst.sa.sa_family == AF_INET)
d270 3
a272 1
	    DPRINTF(("ipsec_common_input_cb(): processing failed for SA %s/%08x\n", ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d274 2
a275 1
            return ENOBUFS;
a279 1
	HTONS(ip->ip_id);
d300 2
a301 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet_ntoa4(ipn.ip_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d303 1
d328 2
a329 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet6_ntoa4(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d331 1
d348 2
a349 1
	    DPRINTF(("ipsec_common_input_cb(): source address %s doesn't correspond to expected source %s, SA %s/%08x\n", inet_ntoa4(ip->ip_src), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d352 1
d364 3
a366 1
	    DPRINTF(("ipsec_common_input_cb(): processing failed for SA %s/%08x\n", ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d368 2
a369 1
            return EACCES;
d395 2
a396 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet_ntoa4(ipn.ip_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d399 1
d422 2
a423 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet6_ntoa4(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d425 1
d442 2
a443 1
	    DPRINTF(("ipsec_common_input_cb(): packet %s to %s does not match any ACL entries, SA %s/%08x\n", ipsp_address(src_address), ipsp_address(dst_address), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d445 1
d518 2
a519 1
		DPRINTF(("ipsec_common_input_cb(): packet from %s to %s dropped due to policy, SA %s/%08x\n", ipsp_address(src_address), ipsp_address(dst_address), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d521 1
d532 1
a532 1
	      DPRINTF(("ipsec_common_input_cb(): mbuf is not a packet header!\n"));
d589 1
d591 3
a593 44
    /* Call the appropriate IPsec transform callback */
    switch (af)
    {
#ifdef INET
	case AF_INET:
	    switch (sproto)
	    {
		case IPPROTO_ESP:
		    return esp4_input_cb(m);

		case IPPROTO_AH:
		    return ah4_input_cb(m);

		default:
		    DPRINTF(("ipsec_common_input_cb(): unknown/unsupported security protocol %d\n", sproto));
		    m_freem(m);
		    return EPFNOSUPPORT;
	    }
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    switch (sproto)
	    {
		case IPPROTO_ESP:
		    return esp6_input_cb(m, protoff);

		case IPPROTO_AH:
		    return ah6_input_cb(m, protoff);

		default:
		    DPRINTF(("ipsec_common_input_cb(): unknown/unsupported security protocol %d\n", sproto));
		    m_freem(m);
		    return EPFNOSUPPORT;
	    }
	    break;
#endif /* INET6 */

	default:
	    DPRINTF(("ipsec_common_input_cb(): unknown/unsupported protocol family %d\n", af));
	    m_freem(m);
	    return EPFNOSUPPORT;
    }
d638 3
a640 1
    int skip;
d647 3
a649 10
    ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
		       IPPROTO_AH);
    return;
}

/* IPv4 AH callback */
int
ah4_input_cb(struct mbuf *m, ...)
{
    struct ifqueue *ifq = &ipintrq;
d656 1
d660 3
a662 3
	if (m->m_pkthdr.tdbi)
	  free(m->m_pkthdr.tdbi, M_TEMP);
	m_freem(m);
d664 3
a666 3

	DPRINTF(("ah4_input_cb(): dropped packet because of full IP queue\n"));
	return ENOBUFS;
d669 1
a669 1
    IF_ENQUEUE(ifq, m);
d671 1
a671 1
    return 0;
d678 3
a680 1
    int skip;
d687 3
a689 9
    ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
		       IPPROTO_ESP);
}

/* IPv4 ESP callback */
int
esp4_input_cb(struct mbuf *m, ...)
{
    struct ifqueue *ifq = &ipintrq;
d695 2
d700 3
a702 3
	if (m->m_pkthdr.tdbi)
	  free(m->m_pkthdr.tdbi, M_TEMP);
	m_freem(m);
d704 3
a706 3

	DPRINTF(("esp4_input_cb(): dropped packet because of full IP queue\n"));
	return ENOBUFS;
d709 1
a709 1
    IF_ENQUEUE(ifq, m);
d711 1
a711 1
    return 0;
d720 1
d728 2
a729 1
	/* Chase down the header chain... */
d735 1
a735 1
	    m_copydata(*mp, protoff + offsetof(struct ip6_ext, ip6e_len),
d745 1
a745 1
	    m_freem(*mp);
d753 5
a757 9
    ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
    return IPPROTO_DONE;
}

/* IPv6 AH callback */
int
ah6_input_cb(struct mbuf *mp, int protoff)
{
    u_int8_t nxt = 0;
d760 2
a761 6
    m_copydata(mp, protoff, sizeof(u_int8_t), (caddr_t) &nxt);

    /* XXX Requeue -- for now, drop packet */
    m_freem(mp);

    return 0;
d768 1
d776 2
a777 1
	/* Chase down the header chain... */
d783 1
a783 1
	    m_copydata(*mp, protoff + offsetof(struct ip6_ext, ip6e_len),
d793 1
a793 1
	    m_freem(*mp);
d802 5
a806 9
    ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
    return IPPROTO_DONE;
}

/* IPv6 ESP callback */
int
esp6_input_cb(struct mbuf *mp, int protoff)
{
    u_int8_t nxt = 0;
d809 2
a810 6
    m_copydata(mp, protoff, sizeof(u_int8_t), (caddr_t) &nxt);

    /* XXX Requeue -- for now, drop packet */
    m_freem(mp);

    return 0;
@


1.19.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.36 2001/04/06 04:42:08 csapuntz Exp $	*/
d5 1
a5 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
d8 1
a8 1
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece,
d21 1
a21 1
 *
d25 1
a25 1
 * modification of this software.
d38 8
a71 1
#ifndef INET
a72 1
#endif
a73 2
#include <netinet6/ip6_var.h>
#include <netinet6/ip6protosw.h>
d92 4
a99 5
#ifdef INET6
extern struct ip6protosw inet6sw[];
extern u_char ip6_protox[];
#endif

d111 2
a112 1
    union sockaddr_union dst_address;
a133 7
    if (m->m_pkthdr.len - skip < 2 * sizeof(u_int32_t))
    {
        m_freem(m);
        IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
        return EINVAL;
    }

d155 2
d165 2
d191 1
a191 1

d195 2
a196 1
	DPRINTF(("ipsec_common_input(): attempted to use invalid SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
d205 1
a205 1
	DPRINTF(("ipsec_common_input(): attempted to use uninitialized SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
d211 4
a214 8
    if (tdbp->tdb_dst.sa.sa_family == AF_INET)
    {
	/*
	 * XXX The fragment conflicts with scoped nature of IPv6, so do it for
	 * only for IPv4 for now.
	 */
	m->m_pkthdr.rcvif = &encif[0].sc_if;
    }
d220 11
a230 4
	if (tdbp->tdb_flags & TDBF_FIRSTUSE)
	    timeout_add(&tdbp->tdb_first_tmo, hz * tdbp->tdb_exp_first_use);
	if (tdbp->tdb_flags & TDBF_SOFT_FIRSTUSE)
	    timeout_add(&tdbp->tdb_sfirst_tmo, hz * tdbp->tdb_soft_first_use);
d256 2
d259 1
a259 4

#if NBPFILTER > 0
    struct ifnet *bpfif;
#endif
d284 1
a284 1
        if ((m->m_len < skip) && ((m = m_pullup(m, skip)) == 0))
a293 1
	HTONS(ip->ip_off);
d340 1
a340 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", ip6_sprintf(&ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d348 1
a348 1
	/*
d370 1
a370 2
        if ((m->m_len < sizeof(struct ip6_hdr)) &&
            ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0))
d378 1
a378 1
	ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(struct ip6_hdr));
d425 1
a425 1
		DPRINTF(("ipsec_common_input_cb(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", ip6_sprintf(&ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d432 1
a432 1
	/*
d443 1
a443 1
	    DPRINTF(("ipsec_common_input_cb(): packet %s to %s does not match any ACL entries, SA %s/%08x\n", ip6_sprintf(&ip6->ip6_src), ip6_sprintf(&ip6->ip6_dst), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
d451 2
a452 11
    /*
     * Record what we've done to the packet (under what SA it was
     * processed).
     */
    /* XXX We need a better packets-attributes framework */
    if (m->m_pkthdr.tdbi)
      free(m->m_pkthdr.tdbi, M_TEMP);

    MALLOC(m->m_pkthdr.tdbi, void *, sizeof(struct tdb_ident), M_TEMP,
	   M_NOWAIT);
    if (m->m_pkthdr.tdbi == NULL)
d454 68
a521 3
	m_freem(m);
	IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
	return ENOMEM;
d524 25
a548 4
    bcopy(&tdbp->tdb_dst, &(((struct tdb_ident *) m->m_pkthdr.tdbi)->dst),
	  sizeof(union sockaddr_union));
    ((struct tdb_ident *) m->m_pkthdr.tdbi)->proto = tdbp->tdb_sproto;
    ((struct tdb_ident *) m->m_pkthdr.tdbi)->spi = tdbp->tdb_spi;
d552 2
a553 3
	/* Packet is confidential ? */
	if (tdbp->tdb_encalgxform)
	  m->m_flags |= M_CONF;
d563 1
a563 2
    bpfif = &encif[0].sc_if;
    if (bpfif->if_bpf)
d582 2
a583 2

        bpf_mtap(bpfif->if_bpf, &m1);
d613 1
a613 1
		    return esp6_input_cb(m, skip, protoff);
d616 1
a616 1
		    return ah6_input_cb(m, skip, protoff);
a691 1
    int s = splimp();
d694 1
a694 1
     * Interface pointer is already in first mbuf; chop off the
d701 3
a704 1
	splx(s);
a705 1
	m_freem(m);
a711 2
    splx(s);

a734 1
    int s = splimp();
d737 1
a737 1
     * Interface pointer is already in first mbuf; chop off the
d743 3
a746 1
	splx(s);
a747 1
	m_freem(m);
a753 2
    splx(s);

d763 1
a763 1
    int l = 0;
a764 1
    struct ip6_ext ip6e;
d766 2
a767 9
    if (*offp < sizeof(struct ip6_hdr))
    {
	DPRINTF(("ah6_input(): bad offset\n"));
	return IPPROTO_DONE;
    }
    else if (*offp == sizeof(struct ip6_hdr))
    {
	protoff = offsetof(struct ip6_hdr, ip6_nxt);
    }
d775 5
a779 11
	    protoff += l;
	    m_copydata(*mp, protoff, sizeof(ip6e), (caddr_t) &ip6e);
	    if (ip6e.ip6e_nxt == IPPROTO_AH)
		l = (ip6e.ip6e_len + 2) << 2;
	    else
		l = (ip6e.ip6e_len + 1) << 3;
#ifdef DIAGNOSTIC
	    if (l <= 0)
		panic("ah6_input: l went zero or negative");
#endif
	} while (protoff + l < *offp);
d782 1
a782 1
	if (protoff + l != *offp)
d800 1
a800 1
ah6_input_cb(struct mbuf *m, int off, int protoff)
d802 1
a802 3
    int nxt;
    u_int8_t nxt8;
    int nest = 0;
d805 1
a805 22
    m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &nxt8);
    nxt = nxt8;

    /*
     * see the end of ip6_input for this logic.
     * IPPROTO_IPV[46] case will be processed just like other ones
     */
    while (nxt != IPPROTO_DONE) {
	if (ip6_hdrnestlimit && (++nest > ip6_hdrnestlimit)) {
	    ip6stat.ip6s_toomanyhdr++;
	    goto bad;
	}

	/*
	 * protection against faulty packet - there should be
	 * more sanity checks in header chain processing.
	 */
	if (m->m_pkthdr.len < off) {
	    ip6stat.ip6s_tooshort++;
	    in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_truncated);
	    goto bad;
	}
d807 2
a808 2
	nxt = (*inet6sw[ip6_protox[nxt]].pr_input)(&m, &off, nxt);
    }
a810 4

bad:
    m_freem(m);
    return EINVAL;
d817 1
a817 1
    int l = 0;
a818 1
    struct ip6_ext ip6e;
d820 2
a821 9
    if (*offp < sizeof(struct ip6_hdr))
    {
	DPRINTF(("esp6_input(): bad offset\n"));
	return IPPROTO_DONE;
    }
    else if (*offp == sizeof(struct ip6_hdr))
    {
	protoff = offsetof(struct ip6_hdr, ip6_nxt);
    }
d829 5
a833 11
	    protoff += l;
	    m_copydata(*mp, protoff, sizeof(ip6e), (caddr_t) &ip6e);
	    if (ip6e.ip6e_nxt == IPPROTO_AH)
		l = (ip6e.ip6e_len + 2) << 2;
	    else
		l = (ip6e.ip6e_len + 1) << 3;
#ifdef DIAGNOSTIC
	    if (l <= 0)
		panic("esp6_input: l went zero or negative");
#endif
	} while (protoff + l < *offp);
d836 1
a836 1
	if (protoff + l != *offp)
d848 1
d855 1
a855 1
esp6_input_cb(struct mbuf *m, int skip, int protoff)
d857 9
a865 1
    return ah6_input_cb(m, skip, protoff);
@


1.19.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
a20 1
 * Copyright (c) 2001, Angelos D. Keromytis.
d22 1
a22 1
 * Permission to use, copy, and modify this software with or without fee
d40 3
a43 1
#include <sys/mbuf.h>
d46 1
d49 2
d52 1
a58 1
#include <netinet/ip_var.h>
a59 1
#include <netinet/ip_icmp.h>
a80 1
void *ipsec_common_ctlinput(int, struct sockaddr *, void *, int);
d108 35
a142 33
	union sockaddr_union dst_address;
	struct tdb *tdbp;
	u_int32_t spi;
	int s;

	IPSEC_ISTAT(espstat.esps_input, ahstat.ahs_input);

	if (m == 0) {
		DPRINTF(("ipsec_common_input(): NULL packet received\n"));
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
		return EINVAL;
	}

	if ((sproto == IPPROTO_ESP && !esp_enable) ||
	    (sproto == IPPROTO_AH && !ah_enable)) {
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
		return EOPNOTSUPP;
	}

	if (m->m_pkthdr.len - skip < 2 * sizeof(u_int32_t)) {
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
		DPRINTF(("ipsec_common_input(): packet too small\n"));
		return EINVAL;
	}

	/* Retrieve the SPI from the relevant IPsec header */
	if (sproto == IPPROTO_ESP)
		m_copydata(m, skip, sizeof(u_int32_t), (caddr_t) &spi);
	else
		m_copydata(m, skip + sizeof(u_int32_t), sizeof(u_int32_t),
		    (caddr_t) &spi);
d144 1
a144 1
	/*
d150 2
a151 2
	bzero(&dst_address, sizeof(dst_address));
	dst_address.sa.sa_family = af;
d153 2
a154 1
	switch (af) {
d157 4
a160 5
		dst_address.sin.sin_len = sizeof(struct sockaddr_in);
		m_copydata(m, offsetof(struct ip, ip_dst),
		    sizeof(struct in_addr),
		    (caddr_t) &(dst_address.sin.sin_addr));
		break;
d165 5
a169 5
		dst_address.sin6.sin6_len = sizeof(struct sockaddr_in6);
		m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		    sizeof(struct in6_addr),
		    (caddr_t) &(dst_address.sin6.sin6_addr));
		break;
d173 17
a189 6
		DPRINTF(("ipsec_common_input(): unsupported protocol "
		    "family %d\n", af));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_nopf, ahstat.ahs_nopf);
		return EPFNOSUPPORT;
	}
d191 8
a198 11
	s = spltdb();
	tdbp = gettdb(spi, &dst_address, sproto);
	if (tdbp == NULL) {
		splx(s);
		DPRINTF(("ipsec_common_input(): could not find SA for "
		    "packet to %s, spi %08x\n",
		    ipsp_address(dst_address), ntohl(spi)));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_notdb, ahstat.ahs_notdb);
		return ENOENT;
	}
d200 8
a207 7
	if (tdbp->tdb_flags & TDBF_INVALID) {
		splx(s);
		DPRINTF(("ipsec_common_input(): attempted to use invalid SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_invalid, ahstat.ahs_invalid);
		return EINVAL;
	}
d209 8
a216 7
	if (tdbp->tdb_xform == NULL) {
		splx(s);
		DPRINTF(("ipsec_common_input(): attempted to use uninitialized SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
		m_freem(m);
		IPSEC_ISTAT(espstat.esps_noxform, ahstat.ahs_noxform);
		return ENXIO;
	}
d218 9
a226 18
	if (tdbp->tdb_dst.sa.sa_family == AF_INET) {
		/*
		 * XXX The fragment conflicts with scoped nature of
		 * IPv6, so do it for only for IPv4 for now.
		 */
		m->m_pkthdr.rcvif = &encif[0].sc_if;
	}

	/* Register first use, setup expiration timer. */
	if (tdbp->tdb_first_use == 0) {
		tdbp->tdb_first_use = time.tv_sec;
		if (tdbp->tdb_flags & TDBF_FIRSTUSE)
			timeout_add(&tdbp->tdb_first_tmo, hz *
			    tdbp->tdb_exp_first_use);
		if (tdbp->tdb_flags & TDBF_SOFT_FIRSTUSE)
			timeout_add(&tdbp->tdb_sfirst_tmo, hz *
			    tdbp->tdb_soft_first_use);
	}
d228 1
a228 1
	/*
d232 10
a241 7
	if ((*(tdbp->tdb_xform->xf_input))(m, tdbp, skip, protoff) == NULL) {
		splx(s);
		return EINVAL;
	} else {
		splx(s);
		return 0;
	}
d249 1
a249 2
ipsec_common_input_cb(struct mbuf *m, struct tdb *tdbp, int skip, int protoff,
    struct m_tag *mt)
d251 1
a251 1
	int prot, af, sproto;
d254 1
a254 1
	struct ifnet *bpfif;
d258 1
a258 1
	struct ip *ip, ipn;
d262 1
a262 1
	struct ip6_hdr *ip6, ip6n;
a263 2
	struct m_tag *mtag;
	struct tdb_ident *tdbi;
d265 29
a293 2
	af = tdbp->tdb_dst.sa.sa_family;
	sproto = tdbp->tdb_sproto;
d295 5
a299 1
	tdbp->tdb_last_used = time.tv_sec;
d301 15
a315 5
	/* Sanity check */
	if (m == NULL) {
		/* The called routine will print a message if necessary */
		IPSEC_ISTAT(espstat.esps_badkcr, ahstat.ahs_badkcr);
		return EINVAL;
a317 51
#ifdef INET
	/* Fix IPv4 header */
	if (tdbp->tdb_dst.sa.sa_family == AF_INET) {
		if ((m->m_len < skip) && ((m = m_pullup(m, skip)) == NULL)) {
			DPRINTF(("ipsec_common_input_cb(): processing failed "
			    "for SA %s/%08x\n", ipsp_address(tdbp->tdb_dst),
			    ntohl(tdbp->tdb_spi)));
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
			return ENOBUFS;
		}

		ip = mtod(m, struct ip *);
		ip->ip_len = htons(m->m_pkthdr.len);
		HTONS(ip->ip_off);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
		prot = ip->ip_p;

		/* IP-in-IP encapsulation */
		if (prot == IPPROTO_IPIP) {
			/* ipn will now contain the inner IPv4 header */
			m_copydata(m, ip->ip_hl << 2, sizeof(struct ip),
			    (caddr_t) &ipn);

			/*
			 * Check that the inner source address is the same as
			 * the proxy address, if available.
			 */
			if ((tdbp->tdb_proxy.sa.sa_family == AF_INET &&
			    tdbp->tdb_proxy.sin.sin_addr.s_addr !=
			    INADDR_ANY &&
			    ipn.ip_src.s_addr !=
			    tdbp->tdb_proxy.sin.sin_addr.s_addr) ||
			    (tdbp->tdb_proxy.sa.sa_family != AF_INET &&
				tdbp->tdb_proxy.sa.sa_family != 0)) {

				DPRINTF(("ipsec_common_input_cb(): inner "
				    "source address %s doesn't correspond to "
				    "expected proxy source %s, SA %s/%08x\n",
				    inet_ntoa4(ipn.ip_src),
				    ipsp_address(tdbp->tdb_proxy),
				    ipsp_address(tdbp->tdb_dst),
				    ntohl(tdbp->tdb_spi)));

				m_freem(m);
				IPSEC_ISTAT(espstat.esps_pdrops,
				    ahstat.ahs_pdrops);
				return EACCES;
			}
		}

d319 24
a342 31
		/* IPv6-in-IP encapsulation. */
		if (prot == IPPROTO_IPV6) {
			/* ip6n will now contain the inner IPv6 header. */
			m_copydata(m, ip->ip_hl << 2, sizeof(struct ip6_hdr),
			    (caddr_t) &ip6n);

			/*
			 * Check that the inner source address is the same as
			 * the proxy address, if available.
			 */
			if ((tdbp->tdb_proxy.sa.sa_family == AF_INET6 &&
			    !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_proxy.sin6.sin6_addr) &&
			    !IN6_ARE_ADDR_EQUAL(&ip6n.ip6_src,
				&tdbp->tdb_proxy.sin6.sin6_addr)) ||
			    (tdbp->tdb_proxy.sa.sa_family != AF_INET6 &&
				tdbp->tdb_proxy.sa.sa_family != 0)) {

				DPRINTF(("ipsec_common_input_cb(): inner "
				    "source address %s doesn't correspond to "
				    "expected proxy source %s, SA %s/%08x\n",
				    ip6_sprintf(&ip6n.ip6_src),
				    ipsp_address(tdbp->tdb_proxy),
				    ipsp_address(tdbp->tdb_dst),
				    ntohl(tdbp->tdb_spi)));

				m_freem(m);
				IPSEC_ISTAT(espstat.esps_pdrops,
				    ahstat.ahs_pdrops);
				return EACCES;
			}
		}
d345 14
a358 22
		/*
		 * Check that the source address is an expected one,
		 * if we know what it's supposed to be. This avoids
		 * source address spoofing.
		 */
		if ((tdbp->tdb_src.sa.sa_family == AF_INET &&
		    tdbp->tdb_src.sin.sin_addr.s_addr != INADDR_ANY &&
		    ip->ip_src.s_addr != tdbp->tdb_src.sin.sin_addr.s_addr) ||
		    (tdbp->tdb_src.sa.sa_family != AF_INET &&
			tdbp->tdb_src.sa.sa_family != 0)) {

			DPRINTF(("ipsec_common_input_cb(): source address %s "
			    "doesn't correspond to expected source %s, "
			    "SA %s/%08x\n", inet_ntoa4(ip->ip_src),
			    ipsp_address(tdbp->tdb_src),
			    ipsp_address(tdbp->tdb_dst),
			    ntohl(tdbp->tdb_spi)));

			m_freem(m);
			IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
			return EACCES;
		}
d360 1
d364 10
a373 5
	/* Fix IPv6 header */
	if (af == INET6)
	{
		if (m->m_len < sizeof(struct ip6_hdr) &&
		    (m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL) {
d375 2
a376 11
			DPRINTF(("ipsec_common_input_cb(): processing failed "
			    "for SA %s/%08x\n", ipsp_address(tdbp->tdb_dst),
			    ntohl(tdbp->tdb_spi)));

			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
			return EACCES;
		}

		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_plen = htons(m->m_pkthdr.len -
		    sizeof(struct ip6_hdr));
d378 2
a379 2
		/* Save protocol */
		m_copydata(m, protoff, 1, (unsigned char *) &prot);
d382 22
a403 31
		/* IP-in-IP encapsulation */
		if (prot == IPPROTO_IPIP) {
			/* ipn will now contain the inner IPv4 header */
			m_copydata(m, skip, sizeof(struct ip), (caddr_t) &ipn);

			/*
			 * Check that the inner source address is the same as
			 * the proxy address, if available.
			 */
			if ((tdbp->tdb_proxy.sa.sa_family == AF_INET &&
			    tdbp->tdb_proxy.sin.sin_addr.s_addr !=
			    INADDR_ANY &&
			    ipn.ip_src.s_addr !=
				tdbp->tdb_proxy.sin.sin_addr.s_addr) ||
			    (tdbp->tdb_proxy.sa.sa_family != AF_INET &&
				tdbp->tdb_proxy.sa.sa_family != 0)) {

				DPRINTF(("ipsec_common_input_cb(): inner "
				    "source address %s doesn't correspond to "
				    "expected proxy source %s, SA %s/%08x\n",
				    inet_ntoa4(ipn.ip_src),
				    ipsp_address(tdbp->tdb_proxy),
				    ipsp_address(tdbp->tdb_dst),
				    ntohl(tdbp->tdb_spi)));

				m_freem(m);
				IPSEC_ISTAT(espstat.esps_pdrops,
				    ahstat.ahs_pdrops);
				return EACCES;
			}
		}
d406 22
a427 56
		/* IPv6-in-IP encapsulation */
		if (prot == IPPROTO_IPV6) {
			/* ip6n will now contain the inner IPv6 header. */
			m_copydata(m, skip, sizeof(struct ip6_hdr),
			    (caddr_t) &ip6n);

			/*
			 * Check that the inner source address is the same as
			 * the proxy address, if available.
			 */
			if ((tdbp->tdb_proxy.sa.sa_family == AF_INET6 &&
			    !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_proxy.sin6.sin6_addr) &&
			    !IN6_ARE_ADDR_EQUAL(&ip6n.ip6_src,
				&tdbp->tdb_proxy.sin6.sin6_addr)) ||
			    (tdbp->tdb_proxy.sa.sa_family != AF_INET6 &&
				tdbp->tdb_proxy.sa.sa_family != 0)) {

				DPRINTF(("ipsec_common_input_cb(): inner "
				    "source address %s doesn't correspond to "
				    "expected proxy source %s, SA %s/%08x\n",
				    ip6_sprintf(&ip6n.ip6_src),
				    ipsp_address(tdbp->tdb_proxy),
				    ipsp_address(tdbp->tdb_dst),
				    ntohl(tdbp->tdb_spi)));

				m_freem(m);
				IPSEC_ISTAT(espstat.esps_pdrops,
				    ahstat.ahs_pdrops);
				return EACCES;
			}
		}

		/*
		 * Check that the source address is an expected one,
		 * if we know what it's supposed to be. This avoids
		 * source address spoofing.
		 */
		if ((tdbp->tdb_src.sa.sa_family == AF_INET6 &&
		    !IN6_IS_ADDR_UNSPECIFIED(&tdbp->tdb_src.sin6.sin6_addr) &&
		    !IN6_ARE_ADDR_EQUAL(&ip6->ip6_src,
			&tdbp->tdb_src.sin6.sin6_addr)) ||
		    (tdbp->tdb_src.sa.sa_family != AF_INET6 &&
			tdbp->tdb_src.sa.sa_family != 0)) {

			DPRINTF(("ipsec_common_input_cb(): packet %s to %s "
			    "does not match any ACL entries, SA %s/%08x\n",
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
			    ipsp_address(tdbp->tdb_src),
			    ipsp_address(tdbp->tdb_dst),
			    ntohl(tdbp->tdb_spi)));

			m_freem(m);
			IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops);
			return EACCES;
		}
a428 1
#endif /* INET6 */
d431 2
a432 6
	 * Record what we've done to the packet (under what SA it was
	 * processed). If we've been passed an mtag, it means the packet
	 * was already processed by an ethernet/crypto combo card and
	 * thus has a tag attached with all the right information, but
	 * with a PACKET_TAG_IPSEC_IN_CRYPTO_DONE as opposed to
	 * PACKET_TAG_IPSEC_IN_DONE type; in that case, just change the type.
d434 11
a444 18
	if (mt == NULL) {
		mtag = m_tag_get(PACKET_TAG_IPSEC_IN_DONE,
		    sizeof(struct tdb_ident), M_NOWAIT);
		if (mtag == NULL) {
			m_freem(m);
			DPRINTF(("ipsec_common_input_cb(): failed to "
			    "get tag\n"));
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
			return ENOMEM;
		}

		tdbi = (struct tdb_ident *)(mtag + 1);
		bcopy(&tdbp->tdb_dst, &tdbi->dst,
		    sizeof(union sockaddr_union));
		tdbi->proto = tdbp->tdb_sproto;
		tdbi->spi = tdbp->tdb_spi;

		m_tag_prepend(m, mtag);
d446 2
a447 2
	else
		mt->m_tag_id = PACKET_TAG_IPSEC_IN_DONE;
d449 34
a482 11
	if (sproto == IPPROTO_ESP) {
		/* Packet is confidential ? */
		if (tdbp->tdb_encalgxform)
			m->m_flags |= M_CONF;

		/* Check if we had authenticated ESP. */
		if (tdbp->tdb_authalgxform)
			m->m_flags |= M_AUTH;
	}
	else
		m->m_flags |= M_AUTH;
d485 20
a504 19
	bpfif = &encif[0].sc_if;
	if (bpfif->if_bpf) {
		/*
		 * We need to prepend the address family as
		 * a four byte field.  Cons up a dummy header
		 * to pacify bpf.  This is safe because bpf
		 * will only read from the mbuf (i.e., it won't
		 * try to free it or keep a pointer a to it).
		 */
		struct mbuf m1;
		struct enchdr hdr;

		hdr.af = af;
		hdr.spi = tdbp->tdb_spi;
		hdr.flags = m->m_flags & (M_AUTH|M_CONF);

		m1.m_next = m;
		m1.m_len = ENC_HDRLEN;
		m1.m_data = (char *) &hdr;
d506 2
a507 2
		bpf_mtap(bpfif->if_bpf, &m1);
	}
d510 3
a512 2
	/* Call the appropriate IPsec transform callback. */
	switch (af) {
d515 2
a516 2
		switch (sproto)
		{
d518 1
a518 1
			return esp4_input_cb(m);
d521 1
a521 1
			return ah4_input_cb(m);
d524 5
a528 6
			DPRINTF(("ipsec_common_input_cb(): unknown/unsupported"
			    " security protocol %d\n", sproto));
			m_freem(m);
			return EPFNOSUPPORT;
		}
		break;
d533 2
a534 1
		switch (sproto) {
d536 1
a536 1
			return esp6_input_cb(m, skip, protoff);
d539 1
a539 1
			return ah6_input_cb(m, skip, protoff);
d542 5
a546 6
			DPRINTF(("ipsec_common_input_cb(): unknown/unsupported"
			    " security protocol %d\n", sproto));
			m_freem(m);
			return EPFNOSUPPORT;
		}
		break;
d550 4
a553 5
		DPRINTF(("ipsec_common_input_cb(): unknown/unsupported "
		    "protocol family %d\n", af));
		m_freem(m);
		return EPFNOSUPPORT;
	}
d559 1
a559 1
    size_t newlen)
d561 3
a563 3
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;
d565 2
a566 1
	switch (name[0]) {
d568 1
a568 1
		return sysctl_int(oldp, oldlen, newp, newlen, &esp_enable);
d570 3
a572 3
		return ENOPROTOOPT;
	}
	/* NOTREACHED */
d577 1
a577 1
    size_t newlen)
d579 3
a581 3
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;
d583 2
a584 1
	switch (name[0]) {
d586 1
a586 1
		return sysctl_int(oldp, oldlen, newp, newlen, &ah_enable);
d588 3
a590 3
		return ENOPROTOOPT;
	}
	/* NOTREACHED */
d594 1
a594 1
/* IPv4 AH wrapper. */
d598 1
a598 1
	int skip;
d600 4
a603 4
	va_list ap;
	va_start(ap, m);
	skip = va_arg(ap, int);
	va_end(ap);
d605 3
a607 3
	ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
	    IPPROTO_AH);
	return;
d610 1
a610 1
/* IPv4 AH callback. */
d614 2
a615 2
	struct ifqueue *ifq = &ipintrq;
	int s = splimp();
d617 4
a620 15
	/*
	 * Interface pointer is already in first mbuf; chop off the
	 * `outer' header and reschedule.
	 */

	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		ahstat.ahs_qfull++;
		splx(s);

		m_freem(m);
		DPRINTF(("ah4_input_cb(): dropped packet because of full "
		    "IP queue\n"));
		return ENOBUFS;
	}
d622 4
a625 2
	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IP);
a626 2
	return 0;
}
d628 4
d633 3
a635 6
void *
ah4_ctlinput(int cmd, struct sockaddr *sa, void *v)
{
	if (sa->sa_family != AF_INET ||
	    sa->sa_len != sizeof(struct sockaddr_in))
		return (NULL);
d637 1
a637 1
	return (ipsec_common_ctlinput(cmd, sa, v, IPPROTO_AH));
d640 1
a640 1
/* IPv4 ESP wrapper. */
d644 1
a644 1
	int skip;
d646 4
a649 4
	va_list ap;
	va_start(ap, m);
	skip = va_arg(ap, int);
	va_end(ap);
d651 2
a652 2
	ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
	    IPPROTO_ESP);
d655 1
a655 1
/* IPv4 ESP callback. */
d659 2
a660 2
	struct ifqueue *ifq = &ipintrq;
	int s = splimp();
d662 8
a669 17
	/*
	 * Interface pointer is already in first mbuf; chop off the
	 * `outer' header and reschedule.
	 */
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		espstat.esps_qfull++;
		splx(s);

		m_freem(m);
		DPRINTF(("esp4_input_cb(): dropped packet because of full "
		    "IP queue\n"));
		return ENOBUFS;
	}

	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IP);
a670 2
	return 0;
}
d672 8
a679 61
void *
ipsec_common_ctlinput(int cmd, struct sockaddr *sa, void *v, int proto)
{
	extern u_int ip_mtudisc_timeout;
	struct ip *ip = v;
	int s;

	if (cmd == PRC_MSGSIZE && ip && ip->ip_v == 4) {
		struct tdb *tdbp;
		struct sockaddr_in dst;
		struct icmp *icp;
		int hlen = ip->ip_hl << 2;
		u_int32_t spi, mtu;
		ssize_t adjust;
	
		/* Find the right MTU. */
		icp = (struct icmp *)((caddr_t) ip -
		    offsetof(struct icmp, icmp_ip));
		mtu = ntohs(icp->icmp_nextmtu);

		/*
		 * Ignore the packet, if we do not receive a MTU
		 * or the MTU is too small to be acceptable.
		 */
		if (mtu < 296)
			return (NULL);

		bzero(&dst, sizeof(struct sockaddr_in));
		dst.sin_family = AF_INET;
		dst.sin_len = sizeof(struct sockaddr_in);
		dst.sin_addr.s_addr = ip->ip_dst.s_addr;

		bcopy((caddr_t)ip + hlen, &spi, sizeof(u_int32_t));

		s = spltdb();
		tdbp = gettdb(spi, (union sockaddr_union *)&dst, proto);
		if (tdbp == NULL || tdbp->tdb_flags & TDBF_INVALID) {
			splx(s);
			return (NULL);
		}

		/* Walk the chain backswards to the first tdb */
		for (; tdbp; tdbp = tdbp->tdb_inext) {
			if (tdbp->tdb_flags & TDBF_INVALID ||
			    (adjust = ipsec_hdrsz(tdbp)) == -1) {
				splx(s);
				return (NULL);
			}

			mtu -= adjust;

			/* Store adjusted MTU in tdb */
			tdbp->tdb_mtu = mtu;
			tdbp->tdb_mtutimeout = time.tv_sec +
			    ip_mtudisc_timeout;
		}
		splx(s);
		return (NULL);
	}
	return (NULL);
}
d681 1
a681 8
void *
esp4_ctlinput(int cmd, struct sockaddr *sa, void *v)
{
	if (sa->sa_family != AF_INET ||
	    sa->sa_len != sizeof(struct sockaddr_in))
		return (NULL);

	return (ipsec_common_ctlinput(cmd, sa, v, IPPROTO_ESP));
d686 1
a686 1
/* IPv6 AH wrapper. */
d690 26
a715 22
	int l = 0;
	int protoff;
	struct ip6_ext ip6e;

	if (*offp < sizeof(struct ip6_hdr)) {
		DPRINTF(("ah6_input(): bad offset\n"));
		return IPPROTO_DONE;
	} else if (*offp == sizeof(struct ip6_hdr)) {
		protoff = offsetof(struct ip6_hdr, ip6_nxt);
	} else {
		/* Chase down the header chain... */
		protoff = sizeof(struct ip6_hdr);

		do {
			protoff += l;
			m_copydata(*mp, protoff, sizeof(ip6e),
			    (caddr_t) &ip6e);

			if (ip6e.ip6e_nxt == IPPROTO_AH)
				l = (ip6e.ip6e_len + 2) << 2;
			else
				l = (ip6e.ip6e_len + 1) << 3;
d717 2
a718 2
			if (l <= 0)
				panic("ah6_input: l went zero or negative");
d720 1
a720 1
		} while (protoff + l < *offp);
d722 8
a729 9
		/* Malformed packet check */
		if (protoff + l != *offp) {
			DPRINTF(("ah6_input(): bad packet header chain\n"));
			ahstat.ahs_hdrops++;
			m_freem(*mp);
			*mp = NULL;
			return IPPROTO_DONE;
		}
		protoff += offsetof(struct ip6_ext, ip6e_nxt);
d731 6
a736 2
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
	return IPPROTO_DONE;
d739 1
a739 1
/* IPv6 AH callback. */
d743 17
a759 7
	int nxt;
	u_int8_t nxt8;
	int nest = 0;

	/* Retrieve new protocol */
	m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &nxt8);
	nxt = nxt8;
d762 2
a763 2
	 * see the end of ip6_input for this logic.
	 * IPPROTO_IPV[46] case will be processed just like other ones
d765 4
a768 16
	while (nxt != IPPROTO_DONE) {
		if (ip6_hdrnestlimit && (++nest > ip6_hdrnestlimit)) {
			ip6stat.ip6s_toomanyhdr++;
			goto bad;
		}

		/*
		 * Protection against faulty packet - there should be
		 * more sanity checks in header chain processing.
		 */
		if (m->m_pkthdr.len < off) {
			ip6stat.ip6s_tooshort++;
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_truncated);
			goto bad;
		}
		nxt = (*inet6sw[ip6_protox[nxt]].pr_input)(&m, &off, nxt);
a769 1
	return 0;
d771 8
a778 3
 bad:
	m_freem(m);
	return EINVAL;
d781 1
a781 1
/* IPv6 ESP wrapper. */
d785 26
a810 22
	int l = 0;
	int protoff;
	struct ip6_ext ip6e;

	if (*offp < sizeof(struct ip6_hdr)) {
		DPRINTF(("esp6_input(): bad offset\n"));
		return IPPROTO_DONE;
	} else if (*offp == sizeof(struct ip6_hdr)) {
		protoff = offsetof(struct ip6_hdr, ip6_nxt);
	} else {
		/* Chase down the header chain... */
		protoff = sizeof(struct ip6_hdr);

		do {
			protoff += l;
			m_copydata(*mp, protoff, sizeof(ip6e),
			    (caddr_t) &ip6e);

			if (ip6e.ip6e_nxt == IPPROTO_AH)
				l = (ip6e.ip6e_len + 2) << 2;
			else
				l = (ip6e.ip6e_len + 1) << 3;
d812 2
a813 2
			if (l <= 0)
				panic("esp6_input: l went zero or negative");
d815 1
a815 1
		} while (protoff + l < *offp);
d817 8
a824 9
		/* Malformed packet check */
		if (protoff + l != *offp) {
			DPRINTF(("esp6_input(): bad packet header chain\n"));
			espstat.esps_hdrops++;
			m_freem(*mp);
			*mp = NULL;
			return IPPROTO_DONE;
		}
		protoff += offsetof(struct ip6_ext, ip6e_nxt);
d826 6
a831 2
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
	return IPPROTO_DONE;
d834 1
a834 1
/* IPv6 ESP callback. */
d838 1
a838 1
	return ah6_input_cb(m, skip, protoff);
@


1.19.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.19.2.3 2001/07/04 10:55:01 niklas Exp $	*/
a70 1
#include <netinet/ip_ipcomp.h>
d86 2
a87 3
int esp_enable = 1;
int ah_enable = 1;
int ipcomp_enable = 0;
d103 1
a103 2
#define IPSEC_ISTAT(x,y,z) (sproto == IPPROTO_ESP ? (x)++ : \
			    IPPROTO_AH ? (y)++ : (z)++)
a107 1
	u_int16_t cpi;
d110 1
a110 2
	IPSEC_ISTAT(espstat.esps_input, ahstat.ahs_input,
	    ipcompstat.ipcomps_input);
d114 1
a114 2
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
		    ipcompstat.ipcomps_hdrops);
d119 1
a119 2
	    (sproto == IPPROTO_AH && !ah_enable) ||
	    (sproto == IPPROTO_IPCOMP && !ipcomp_enable)) {
d121 1
a121 2
		IPSEC_ISTAT(espstat.esps_pdrops, ahstat.ahs_pdrops,
		    ipcompstat.ipcomps_pdrops);
d127 1
a127 2
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
		    ipcompstat.ipcomps_hdrops);
d135 1
a135 1
	else if (sproto == IPPROTO_AH)
a137 5
	else if (sproto == IPPROTO_IPCOMP) {
		m_copydata(m, skip + sizeof(u_int16_t), sizeof(u_int16_t),
		    (caddr_t) &cpi);
		spi = ntohl(htons(cpi));
	}
d171 1
a171 2
		IPSEC_ISTAT(espstat.esps_nopf, ahstat.ahs_nopf,
		    ipcompstat.ipcomps_nopf);
d183 1
a183 2
		IPSEC_ISTAT(espstat.esps_notdb, ahstat.ahs_notdb,
		    ipcompstat.ipcomps_notdb);
d191 1
a191 2
		IPSEC_ISTAT(espstat.esps_invalid, ahstat.ahs_invalid,
		    ipcompstat.ipcomps_invalid);
d199 1
a199 2
		IPSEC_ISTAT(espstat.esps_noxform, ahstat.ahs_noxform,
		    ipcompstat.ipcomps_noxform);
d203 1
a203 2
	if (tdbp->tdb_dst.sa.sa_family == AF_INET && 
	    sproto != IPPROTO_IPCOMP) {
d267 1
a267 2
		IPSEC_ISTAT(espstat.esps_badkcr, ahstat.ahs_badkcr,
		    ipcompstat.ipcomps_badkcr);
d278 1
a278 2
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
			    ipcompstat.ipcomps_hdrops);
d317 1
a317 2
				    ahstat.ahs_pdrops,
				    ipcompstat.ipcomps_pdrops);
d350 1
a350 2
				    ahstat.ahs_pdrops,
				    ipcompstat.ipcomps_pdrops);
d355 23
d392 1
a392 2
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
			    ipcompstat.ipcomps_hdrops);
d431 1
a431 2
				    ahstat.ahs_pdrops,
				    ipcompstat.ipcomps_pdrops);
d464 1
a464 2
				    ahstat.ahs_pdrops,
				    ipcompstat.ipcomps_pdrops);
d468 25
d504 1
a504 1
	if (mt == NULL && tdbp->tdb_sproto != IPPROTO_IPCOMP) {
d511 1
a511 2
			IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops,
			    ipcompstat.ipcomps_hdrops);
a534 2
	else if (sproto == IPPROTO_IPCOMP)
		m->m_flags |= M_COMP;
a574 3
		case IPPROTO_IPCOMP:
			return ipcomp4_input_cb(m);

a592 3
		case IPPROTO_IPCOMP:
			return ipcomp6_input_cb(m, skip, protoff);

d641 1
a641 18
    }
    /* NOTREACHED */
}

int
ipcomp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlen, void *newp,
    size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;
    
	switch (name[0]) {
	case IPCOMPCTL_ENABLE:
		return sysctl_int(oldp, oldlen, newp, newlen, &ipcomp_enable);
	default:
		return ENOPROTOOPT;
	}	
a744 42
/* IPv4 IPCOMP wrapper */
void
ipcomp4_input(struct mbuf *m, ...)
{
	int skip;
	va_list ap;
	va_start(ap, m);
	skip = va_arg(ap, int);
	va_end(ap);

	ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
	    IPPROTO_IPCOMP);
}

/* IPv4 IPCOMP callback */
int
ipcomp4_input_cb(struct mbuf *m, ...)
{
	struct ifqueue *ifq = &ipintrq;
	int s = splimp();
    
	/*
	 * Interface pointer is already in first mbuf; chop off the
	 * `outer' header and reschedule.
	 */
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		ipcompstat.ipcomps_qfull++;
		splx(s);
	
		m_freem(m);
		DPRINTF(("ipcomp4_input_cb(): dropped packet because of full IP queue\n"));
		return ENOBUFS;
	}

	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IP);
	splx(s);

	return 0;
}

a948 1

d951 1
a951 1
/* IPv6 ESP callback */
a956 54

/* IPv6 IPcomp wrapper */
int
ipcomp6_input(struct mbuf **mp, int *offp, int proto)
{
	int l = 0;
	int protoff;
	struct ip6_ext ip6e;

	if (*offp < sizeof(struct ip6_hdr)) {
		DPRINTF(("ipcomp6_input(): bad offset\n"));
		return IPPROTO_DONE;
	} else if (*offp == sizeof(struct ip6_hdr)) {
		protoff = offsetof(struct ip6_hdr, ip6_nxt);
	} else {
		/* Chase down the header chain... */
		protoff = sizeof(struct ip6_hdr);

		do {
			protoff += l;
			m_copydata(*mp, protoff, sizeof(ip6e), 
			    (caddr_t) &ip6e);
			if (ip6e.ip6e_nxt == IPPROTO_AH)
				l = (ip6e.ip6e_len + 2) << 2;
			else
				l = (ip6e.ip6e_len + 1) << 3;
#ifdef DIAGNOSTIC
			if (l <= 0)
				panic("ipcomp6_input: l went zero or negative");
#endif
		} while (protoff + l < *offp);

		/* Malformed packet check */
		if (protoff + l != *offp) {
			DPRINTF(("ipcomp6_input(): bad packet header chain\n"));
			ipcompstat.ipcomps_hdrops++;
			m_freem(*mp);
			*mp = NULL;
			return IPPROTO_DONE;
		}

		protoff += offsetof(struct ip6_ext, ip6e_nxt);
	}
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto);
	return IPPROTO_DONE;
}

/* IPv6 IPcomp callback */
int
ipcomp6_input_cb(struct mbuf *m, int skip, int protoff)
{
	return ah6_input_cb(m, skip, protoff);
}

a957 3



@


1.19.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a108 1
	struct timeval tv;
a231 3
		int pri;

		pri = splhigh();
a232 5
		splx(pri);

		tv.tv_usec = 0;

		tv.tv_sec = tdbp->tdb_exp_first_use + tdbp->tdb_first_use;
d234 2
a235 3
			timeout_add(&tdbp->tdb_first_tmo, hzto(&tv));

		tv.tv_sec = tdbp->tdb_first_use + tdbp->tdb_soft_first_use;
d237 2
a238 1
			timeout_add(&tdbp->tdb_sfirst_tmo, hzto(&tv));
d798 1
a798 1
	if (cmd == PRC_MSGSIZE && ip && ip_mtudisc && ip->ip_v == 4) {
@


1.19.2.6
log
@Sync the SMP branch with 3.3
@
text
@d106 1
a106 1
			    sproto == IPPROTO_AH ? (y)++ : (z)++)
d113 1
a113 1
	int s, error;
d222 1
a222 1
	if (tdbp->tdb_dst.sa.sa_family == AF_INET &&
d251 10
a260 6
	 * Call appropriate transform and return -- callback takes care of
	 * everything else.
	 */
	error = (*(tdbp->tdb_xform->xf_input))(m, tdbp, skip, protoff);
	splx(s);
	return error;
a509 3
	} else {
		if (mt != NULL)
			mt->m_tag_id = PACKET_TAG_IPSEC_IN_DONE;
d511 2
d522 2
a523 1
	} else if (sproto == IPPROTO_IPCOMP)
d526 1
a526 1
		m->m_flags |= M_AUTH | M_AUTH_AH;
d543 1
a543 1
		hdr.flags = m->m_flags & (M_AUTH|M_CONF|M_AUTH_AH);
d648 1
a648 1

d654 1
a654 1
	}
d778 1
a778 1

d787 1
a787 1

d814 1
a814 1

d1033 1
a1033 1
			m_copydata(*mp, protoff, sizeof(ip6e),
d1068 3
@


1.19.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.19.2.6 2003/03/28 00:06:54 niklas Exp $	*/
a540 1
		m1.m_flags = 0;
@


1.19.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 1
d103 1
a103 2
ipsec_common_input(struct mbuf *m, int skip, int protoff, int af, int sproto,
    int udpencap)
d155 4
a158 4
	 * Find tunnel control block and (indirectly) call the appropriate
	 * kernel crypto routine. The resulting mbuf chain is a valid
	 * IP packet ready to go through input processing.
	 */
a212 8
	if (udpencap && !(tdbp->tdb_flags & TDBF_UDPENCAP)) {
		splx(s);
		DPRINTF(("ipsec_common_input(): attempted to use non-udpencap SA %s/%08x/%u\n", ipsp_address(dst_address), ntohl(spi), tdbp->tdb_sproto));
		m_freem(m);
		espstat.esps_udpinval++;
		return EINVAL;
	}

d230 1
a230 1
	
d310 1
a316 7
			if (m->m_pkthdr.len - skip < sizeof(struct ip)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return EINVAL;
			}
d318 1
a318 1
			m_copydata(m, skip, sizeof(struct ip),
a351 7
			if (m->m_pkthdr.len - skip < sizeof(struct ip6_hdr)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return EINVAL;
			}
d353 1
a353 1
			m_copydata(m, skip, sizeof(struct ip6_hdr),
a411 7
			if (m->m_pkthdr.len - skip < sizeof(struct ip)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return EINVAL;
			}
a445 7
			if (m->m_pkthdr.len - skip < sizeof(struct ip6_hdr)) {
				m_freem(m);
				IPSEC_ISTAT(espstat.esps_hdrops,
				    ahstat.ahs_hdrops,
				    ipcompstat.ipcomps_hdrops);
				return EINVAL;
			}
a523 3
	if (tdbp->tdb_flags & TDBF_TUNNELING)
		m->m_flags |= M_TUNNEL;

a614 4
	case ESPCTL_UDPENCAP_ENABLE:
		return sysctl_int(oldp, oldlen, newp, newlen, &udpencap_enable);
	case ESPCTL_UDPENCAP_PORT:
		return sysctl_int(oldp, oldlen, newp, newlen, &udpencap_port);
d668 1
a668 1
	    IPPROTO_AH, 0);
d724 1
a724 1
	    IPPROTO_ESP, 0);
d766 1
a766 1
	    IPPROTO_IPCOMP, 0);
d913 1
a913 1
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto, 0);
d999 1
a999 1
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto, 0);
d1053 1
a1053 1
	ipsec_common_input(*mp, *offp, protoff, AF_INET6, proto, 0);
@


1.19.2.9
log
@Merge with the trunk
@
text
@a89 4
int *espctl_vars[ESPCTL_MAXID] = ESPCTL_VARS;
int *ahctl_vars[AHCTL_MAXID] = AHCTL_VARS;
int *ipcompctl_vars[IPCOMPCTL_MAXID] = IPCOMPCTL_VARS;

d128 4
a131 2
		rip_input(m, skip, sproto);
		return 0;
d643 1
a643 1
esp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
d646 15
a660 4
	if (name[0] < ESPCTL_MAXID)
		return (sysctl_int_arr(espctl_vars, name, namelen,
		    oldp, oldlenp, newp, newlen));
	return (ENOPROTOOPT);
d664 1
a664 1
ah_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
d667 11
a677 4
	if (name[0] < AHCTL_MAXID)
		return (sysctl_int_arr(ahctl_vars, name, namelen,
		    oldp, oldlenp, newp, newlen));
	return (ENOPROTOOPT);
d681 1
a681 1
ipcomp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
d684 11
a694 4
	if (name[0] < IPCOMPCTL_MAXID)
		return (sysctl_int_arr(ipcompctl_vars, name, namelen,
		    oldp, oldlenp, newp, newlen));
	return (ENOPROTOOPT);
@


1.18
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.17 2000/01/25 17:18:59 espie Exp $	*/
d72 2
a73 2
#include <netinet6/in6.h>
#include <netinet6/ip6.h>
@


1.17
log
@Ok, so setsoftnet is md.

Well, on the amiga, setsoftnet *REQUIRES* machine/cpu.h to work...
and no include mentioned in those files pulls machine/cpu.h...

Nit-fix: / * INET6 */ -> /* INET6 */
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.16 2000/01/15 20:03:05 angelos Exp $	*/
d109 1
a109 1
#define IPSEC_NAME (sproto == IPPROTO_ESP ? (af == AF_INET ? "esp_input()" :\
d111 1
a111 1
                                            (af == AF_INET ? "ah_input()" :\
d636 1
a636 1
ah_input(struct mbuf *m, ...)
d665 1
a665 1
	DPRINTF(("ah_input(): dropped packet because of full IP queue\n"));
d676 1
a676 1
esp_input(struct mbuf *m, ...)
d705 1
a705 1
	DPRINTF(("esp_input(): dropped packet because of full IP queue\n"));
@


1.16
log
@Remove unnecessary definition.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.15 2000/01/15 19:37:28 angelos Exp $	*/
d57 2
d74 1
a74 1
#endif/ * INET6 */
@


1.15
log
@Add function prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.14 2000/01/15 18:27:51 angelos Exp $	*/
a82 2

extern struct enc_softc encif[];
@


1.14
log
@Change function type to non-static.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.13 2000/01/10 04:16:52 angelos Exp $	*/
d82 2
d96 1
@


1.13
log
@1) Setup a silent TDB expiration for embryonic SAs.
2) Fix check_ipsec_policy() to deal with v6 PCBs.
3) Fix ACL protocol check.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.12 2000/01/10 02:45:12 angelos Exp $	*/
d102 1
a102 1
static int
@


1.12
log
@Fix tdbi setup for TCP and UDP packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.11 2000/01/10 01:23:27 angelos Exp $	*/
d497 1
a497 1
	    if (flow->flow_proto != prot)
@


1.11
log
@Typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.10 2000/01/10 01:20:53 angelos Exp $	*/
a525 2
	struct tdb_ident *tdbi = NULL;

a527 1
	    tdbi = m->m_pkthdr.tdbi;
d531 2
a532 2
	    MALLOC(tdbi, struct tdb_ident *, sizeof(struct tdb_ident),
	           M_TEMP, M_NOWAIT);
d534 1
a534 3
	    if (tdbi == NULL)
	      m->m_pkthdr.tdbi = NULL;
	    else
d536 6
a541 3
		tdbi->spi = tdbp->tdb_bind_out->tdb_spi;
		tdbi->dst = tdbp->tdb_bind_out->tdb_dst;
		tdbi->proto = tdbp->tdb_bind_out->tdb_sproto;
d544 2
@


1.10
log
@Quick-drop packets (before real processing) if ingress filtering is on
and the SA ACL is empty.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.9 2000/01/10 01:09:16 angelos Exp $	*/
d242 1
a242 1
    if (ipsec-acl && (tdbp->tdb_access == NULL))
@


1.9
log
@Fix error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.8 2000/01/09 23:42:37 angelos Exp $	*/
d146 1
a146 1
    
d198 1
d209 1
d220 1
d241 11
d256 1
d269 1
d298 1
d326 1
d346 1
d363 1
d393 1
d420 1
d440 1
d516 1
@


1.8
log
@Add ingress ACL for IPsec: after being processed, IPsec packets are
matched against a list of acceptable packet classes, if
sysctl variable net.inet.ip.ipsec-acl is set to 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.7 2000/01/08 01:59:25 angelos Exp $	*/
d492 1
a492 1
		DPRINTF(("%s: inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", IPSEC_NAME, inet6_ntoa4(ip6n.ip6_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
@


1.7
log
@Fix serious crash-and-burn bug I introduced with last revision.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.6 2000/01/03 12:58:13 angelos Exp $	*/
d66 2
d110 3
a112 1
    union sockaddr_union sunion;
d160 2
a161 2
    bzero(&sunion, sizeof(sunion));
    sunion.sin.sin_family = af;
d163 2
d166 7
a172 6
    if (af == AF_INET)
    {
	sunion.sin.sin_len = sizeof(struct sockaddr_in);
	m_copydata(m, offsetof(struct ip, ip_dst), sizeof(struct in_addr),
		   (unsigned char *) &(sunion.sin.sin_addr));
    }
d176 16
a191 6
    if (af == AF_INET6)
    {
	sunion.sin6.sin6_len = sizeof(struct sockaddr_in6);
	m_copydata(m, offsetof(struct ip6_hdr, ip6_dst),
		   sizeof(struct in6_addr),
		   (unsigned char *) &(sunion.sin6.sin6_addr));
a192 1
#endif /* INET6 */
d195 1
a195 1
    tdbp = gettdb(spi, &sunion, sproto);
d199 1
a199 1
		 IPSEC_NAME, ipsp_address(sunion), ntohl(spi)));
d209 1
a209 1
		 IPSEC_NAME, ipsp_address(sunion), ntohl(spi)));
d219 1
a219 1
		 IPSEC_NAME, ipsp_address(sunion), ntohl(spi)));
d278 1
a278 1
		((tdbp->tdb_proxy.sa.sa_family != AF_INET6) &&
d282 1
a282 1
		m_free(m);
d284 1
a284 1
                IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d309 1
a309 1
		m_free(m);
d311 1
a311 1
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d328 2
a329 2
	    m_free(m);
	    IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d373 2
a374 2
		m_free(m);
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d399 1
a399 1
		m_free(m);
d401 1
a401 1
		IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d417 2
a418 2
	    DPRINTF(("%s: source address %s doesn't correspond to expected source %s, SA %s/%08x\n", IPSEC_NAME, inet6_ntoa4(ip6->ip6_src), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(spi)));
	    m_free(m);
d420 1
a420 1
	    IPSEC_ISTAT(espstat.esps_hdrops, ahstat.ahs_hdrops);
d425 74
@


1.6
log
@Chase down the IPv6 header chain to find the right place swap the Next
Payload value. Note to self: it would be nice if we had a very of
m_copydata() with memory (so it wouldn't need to start the search from
the begining of the mbuf).
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.5 2000/01/02 11:12:03 angelos Exp $	*/
d101 1
a101 1
ipsec_common_input(struct mbuf *m, int skip, int protoff, int af, int sproto)
d110 1
d125 9
d138 1
d185 1
d195 1
d205 1
d239 1
d267 1
d294 1
d314 1
d329 1
d359 1
d384 1
d403 1
d458 1
a458 1
        struct mbuf m0;
d465 3
a467 3
        m0.m_next = m;
        m0.m_len = ENC_HDRLEN;
        m0.m_data = (char *) &hdr;
d469 1
a469 1
        bpf_mtap(m->m_pkthdr.rcvif->if_bpf, &m0);
d474 1
d522 1
d530 1
a530 1
    if (ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
d543 3
a545 3
	if (m->m_pkthdr.tdbi)
	  free(m->m_pkthdr.tdbi, M_TEMP);
	m_freem(m);
d552 1
a552 1
    IF_ENQUEUE(ifq, m);
d562 1
d570 1
a570 1
    if (ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
d583 3
a585 3
	if (m->m_pkthdr.tdbi)
	  free(m->m_pkthdr.tdbi, M_TEMP);
	m_freem(m);
d592 1
a592 1
    IF_ENQUEUE(ifq, m);
d636 1
a636 1
    if (ipsec_common_input(m, *offp, protoff, AF_INET6, proto) != 0)
d685 1
a685 1
    if (ipsec_common_input(m, *offp, protoff, AF_INET6, proto) != 0)
@


1.5
log
@Move the requeueing logic from ipsec_input() to ah_input() and
esp_input(), since this is only needed for IPv4; IPv6 header
processing follows a different approach.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.4 2000/01/02 10:56:32 angelos Exp $	*/
d104 4
a107 2
#define IPSEC_NAME (sproto == IPPROTO_ESP ? "esp_input()" : "ah_input()")

d579 1
a579 1
    u_int8_t nxt;
d582 3
a584 5
    /*
     * XXX assuming that it is first hdr, i.e.
     * offp == sizeof(struct ip6_hdr)
     */
    if (*offp != sizeof(struct ip6_hdr))
d586 23
a608 2
	m_freem(m);
	return IPPROTO_DONE;	/* not quite */
a610 1
    protoff = offsetof(struct ip6_hdr, ip6_nxt);
d612 4
a615 1
      return IPPROTO_DONE;
d627 1
a627 1
    u_int8_t nxt;
d630 3
a632 5
    /*
     * XXX assuming that it is first hdr, i.e.
     * offp == sizeof(struct ip6_hdr)
     */
    if (*offp != sizeof(struct ip6_hdr))
d634 23
a656 2
	m_freem(m);
	return IPPROTO_DONE;	/* not quite */
d661 4
a664 1
      return IPPROTO_DONE;
@


1.4
log
@Change ipsec_input() to return error.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.3 1999/12/31 22:19:43 itojun Exp $	*/
a106 1
    struct ifqueue *ifq = NULL;
d416 4
a419 1
	/* XXX How about M_AUTH if the SA has authentication on ? */
a449 41
    /*
     * Interface pointer is already in first mbuf; chop off the 
     * `outer' header and reschedule.
     */

#ifdef INET
    if (af == AF_INET)
      ifq = &ipintrq;
#endif /* INET */

#ifdef INET6
    if (af == AF_INET6)
      ifq = &ip6intrq;
#endif /* INET6 */

    s = splimp();			/* isn't it already? */
    if (IF_QFULL(ifq))
    {
	IF_DROP(ifq);
	if (m->m_pkthdr.tdbi)
	  free(m->m_pkthdr.tdbi, M_TEMP);
	m_freem(m);
	IPSEC_ISTAT(espstat.esps_qfull, ahstat.ahs_qfull);
	splx(s);
	DPRINTF(("%s: dropped packet because of full IP queue\n", IPSEC_NAME));
	return ENOSPC;
    }

    IF_ENQUEUE(ifq, m);

#ifdef INET
    if (af == AF_INET)
      schednetisr(NETISR_IP);
#endif /* INET */

#ifdef INET6
    if (af == AF_INET6)
      schednetisr(NETISR_IPV6);
#endif /* INET6 */

    splx(s);
d496 2
a497 1
    int skip;
d504 25
a528 2
    ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
		       IPPROTO_AH);
d535 2
a536 1
    int skip;
d543 25
a567 2
    ipsec_common_input(m, skip, offsetof(struct ip, ip_p), AF_INET,
		       IPPROTO_ESP);
@


1.3
log
@fix IPv6 ipsec template lossage.
- previous code grabbed new nexthdr mistakingly
- parameter passing must follow ip6protows
(actually the code will never get called until in6_proto.c is updated)

the current code assumes that {AH,ESP} is right next to IPv6 header.
the assumption must be removed, but it means that we need to chase
header chain...
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.2 1999/12/25 07:09:43 angelos Exp $	*/
d100 1
a100 1
static void
d128 1
a128 1
        return;
d174 1
a174 1
	return;
d183 1
a183 1
	return;
d192 1
a192 1
	return;
d212 1
a212 1
	return;
d224 1
a224 1
            return;
d252 1
a252 1
		return;
d278 1
a278 1
		return;
d296 1
a296 1
	    return;
d310 1
a310 1
            return;
d339 1
a339 1
		return;
d364 1
a364 1
		return;
d382 1
a382 1
	    return;
d473 1
a473 1
	return;
d489 1
a489 1
    return;
d495 2
a496 7
esp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
d498 3
a500 3
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);
d502 2
a503 1
	switch (name[0]) {
d505 1
a505 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &esp_enable));
d507 3
a509 3
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
d513 2
a514 7
ah_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
d516 3
a518 3
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);
d520 2
a521 1
	switch (name[0]) {
d523 1
a523 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ah_enable));
d525 3
a527 3
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
d568 1
a569 1
    u_int8_t nxt;
d575 2
a576 1
    if (*offp != sizeof(struct ip6_hdr)) {
d582 2
a583 1
    ipsec_common_input(m, *offp, protoff, AF_INET6, proto);
d595 1
a596 1
    u_int8_t nxt;
d602 2
a603 1
    if (*offp != sizeof(struct ip6_hdr)) {
d609 2
a610 1
    ipsec_common_input(m, *offp, protoff, AF_INET6, proto);
@


1.2
log
@Change some function prototypes, dont unnecessarily initialize some
variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec_input.c,v 1.1 1999/12/09 10:15:23 angelos Exp $	*/
d573 1
a573 1
ah6_input(struct mbuf *m, ...)
d575 3
a577 1
    int *skip, protoff;
d579 8
a586 6
    va_list ap;
	
    va_start(ap, m);
    skip = va_arg(ap, int *);
    protoff = va_arg(ap, int);
    va_end(ap);
d588 2
a589 1
    ipsec_common_input(m, *skip, protoff, AF_INET6, IPPROTO_AH);
d592 2
a593 2
    m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &protoff);
    return protoff;
d598 1
a598 1
esp6_input(struct mbuf *m, ...)
d600 3
a602 1
    int *skip, protoff;
d604 8
a611 6
    va_list ap;
	
    va_start(ap, m);
    skip = va_arg(ap, int *);
    protoff = va_arg(ap, int);
    va_end(ap);
d613 2
a614 1
    ipsec_common_input(m, *skip, protoff, AF_INET6, IPPROTO_ESP);
d617 2
a618 2
    m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &protoff);
    return protoff;
@


1.1
log
@So I was lying...unify ESP and AH wrapper-input processing. The new
file contains a common routine for massaging the packet, doing
peripheral checks, update statistics, etc. common for both AH/ESP,
both IPv4/IPv6. Also wrapper routines for AH/ESP-v4/v6, and the sysctl
routines from ip_ah.c/ip_esp.c
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.c,v 1.29 1999/12/09 03:46:03 angelos Exp $	*/
d572 1
a572 1
void
d575 1
a575 1
    int skip, protoff;
d580 1
a580 1
    skip = va_arg(ap, int);
d584 5
a588 1
    ipsec_common_input(m, skip, protoff, AF_INET6, IPPROTO_AH);
d592 1
a592 1
void
d595 1
a595 1
    int skip, protoff;
d600 1
a600 1
    skip = va_arg(ap, int);
d604 5
a608 1
    ipsec_common_input(m, skip, protoff, AF_INET6, IPPROTO_ESP);
@

