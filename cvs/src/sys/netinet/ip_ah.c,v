head	1.131;
access;
symbols
	OPENBSD_6_2_BASE:1.131
	OPENBSD_6_1:1.129.0.4
	OPENBSD_6_1_BASE:1.129
	OPENBSD_6_0:1.119.0.4
	OPENBSD_6_0_BASE:1.119
	OPENBSD_5_9:1.118.0.2
	OPENBSD_5_9_BASE:1.118
	OPENBSD_5_8:1.118.0.4
	OPENBSD_5_8_BASE:1.118
	OPENBSD_5_7:1.114.0.2
	OPENBSD_5_7_BASE:1.114
	OPENBSD_5_6:1.111.0.4
	OPENBSD_5_6_BASE:1.111
	OPENBSD_5_5:1.108.0.4
	OPENBSD_5_5_BASE:1.108
	OPENBSD_5_4:1.107.0.2
	OPENBSD_5_4_BASE:1.107
	OPENBSD_5_3:1.105.0.2
	OPENBSD_5_3_BASE:1.105
	OPENBSD_5_2:1.100.0.2
	OPENBSD_5_2_BASE:1.100
	OPENBSD_5_1_BASE:1.99
	OPENBSD_5_1:1.99.0.6
	OPENBSD_5_0:1.99.0.4
	OPENBSD_5_0_BASE:1.99
	OPENBSD_4_9:1.99.0.2
	OPENBSD_4_9_BASE:1.99
	OPENBSD_4_8:1.98.0.2
	OPENBSD_4_8_BASE:1.98
	OPENBSD_4_7:1.93.0.2
	OPENBSD_4_7_BASE:1.93
	OPENBSD_4_6:1.92.0.6
	OPENBSD_4_6_BASE:1.92
	OPENBSD_4_5:1.92.0.2
	OPENBSD_4_5_BASE:1.92
	OPENBSD_4_4:1.91.0.4
	OPENBSD_4_4_BASE:1.91
	OPENBSD_4_3:1.91.0.2
	OPENBSD_4_3_BASE:1.91
	OPENBSD_4_2:1.89.0.4
	OPENBSD_4_2_BASE:1.89
	OPENBSD_4_1:1.89.0.2
	OPENBSD_4_1_BASE:1.89
	OPENBSD_4_0:1.85.0.2
	OPENBSD_4_0_BASE:1.85
	OPENBSD_3_9:1.83.0.2
	OPENBSD_3_9_BASE:1.83
	OPENBSD_3_8:1.82.0.2
	OPENBSD_3_8_BASE:1.82
	OPENBSD_3_7:1.79.0.8
	OPENBSD_3_7_BASE:1.79
	OPENBSD_3_6:1.79.0.6
	OPENBSD_3_6_BASE:1.79
	SMP_SYNC_A:1.79
	SMP_SYNC_B:1.79
	OPENBSD_3_5:1.79.0.4
	OPENBSD_3_5_BASE:1.79
	OPENBSD_3_4:1.79.0.2
	OPENBSD_3_4_BASE:1.79
	UBC_SYNC_A:1.75
	OPENBSD_3_3:1.72.0.2
	OPENBSD_3_3_BASE:1.72
	OPENBSD_3_2:1.70.0.2
	OPENBSD_3_2_BASE:1.70
	OPENBSD_3_1:1.63.0.6
	OPENBSD_3_1_BASE:1.63
	UBC_SYNC_B:1.70
	UBC:1.63.0.4
	UBC_BASE:1.63
	OPENBSD_3_0:1.63.0.2
	OPENBSD_3_0_BASE:1.63
	OPENBSD_2_9_BASE:1.50
	OPENBSD_2_9:1.50.0.2
	OPENBSD_2_8:1.44.0.2
	OPENBSD_2_8_BASE:1.44
	OPENBSD_2_7:1.37.0.2
	OPENBSD_2_7_BASE:1.37
	SMP:1.34.0.2
	SMP_BASE:1.34
	kame_19991208:1.31
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.131
date	2017.08.11.21.24.19;	author mpi;	state Exp;
branches;
next	1.130;
commitid	qO4hXiGM2yDTtiTI;

1.130
date	2017.05.30.16.07.22;	author deraadt;	state Exp;
branches;
next	1.129;
commitid	SSqL97R1n49kij1r;

1.129
date	2017.02.09.00.43.58;	author bluhm;	state Exp;
branches;
next	1.128;
commitid	1tp8P9UZgQI9hvVk;

1.128
date	2017.02.07.18.18.16;	author bluhm;	state Exp;
branches;
next	1.127;
commitid	d6u53XQpFaxImDPZ;

1.127
date	2017.02.07.17.25.46;	author patrick;	state Exp;
branches;
next	1.126;
commitid	dMJlqKWYCJoMV7JN;

1.126
date	2017.02.07.15.10.48;	author bluhm;	state Exp;
branches;
next	1.125;
commitid	7vg8X7gfUc0w7Qc8;

1.125
date	2017.01.09.17.10.02;	author mpi;	state Exp;
branches;
next	1.124;
commitid	6FXHyRkiplRcBK8y;

1.124
date	2016.12.24.11.17.35;	author mpi;	state Exp;
branches;
next	1.123;
commitid	iyPxPn1zFcxxUjDC;

1.123
date	2016.09.19.18.09.22;	author tedu;	state Exp;
branches;
next	1.122;
commitid	dVNJNNJZJ5eqAvDA;

1.122
date	2016.09.13.19.56.55;	author markus;	state Exp;
branches;
next	1.121;
commitid	MhzOL3PcQJk4ZhiI;

1.121
date	2016.08.18.06.01.10;	author dlg;	state Exp;
branches;
next	1.120;
commitid	sj9BHgtTdUyjSwjG;

1.120
date	2016.08.15.11.35.25;	author dlg;	state Exp;
branches;
next	1.119;
commitid	CgCan1eMToI9G3qa;

1.119
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.118;
commitid	Z6e4eqr6FuYFPnlL;

1.118
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	ncpqEGjDtSFuLAgn;

1.117
date	2015.06.15.12.37.37;	author mikeb;	state Exp;
branches;
next	1.116;
commitid	1m30gIbDdCTxtmn3;

1.116
date	2015.04.17.11.04.01;	author mikeb;	state Exp;
branches;
next	1.115;
commitid	6glXvFR7NxzCcdRd;

1.115
date	2015.04.14.14.20.01;	author mikeb;	state Exp;
branches;
next	1.114;
commitid	70u0dWUlToMcLCnj;

1.114
date	2014.12.28.10.02.37;	author tedu;	state Exp;
branches;
next	1.113;
commitid	cPvnXrnDy9of9D0l;

1.113
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.112;
commitid	zhW8jJrfVCoAthrR;

1.112
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.111;
commitid	t9FBKDfc4VDxpEy2;

1.111
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.110;
commitid	DQakU8LLWV6Iwx84;

1.110
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.109;
commitid	B4dZSbxas1X1IpXI;

1.109
date	2014.07.09.09.30.49;	author henning;	state Exp;
branches;
next	1.108;
commitid	Nnxg8ONtI4Ep9pUb;

1.108
date	2014.01.09.06.29.05;	author tedu;	state Exp;
branches;
next	1.107;

1.107
date	2013.06.11.18.15.53;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2013.04.11.12.06.25;	author mpi;	state Exp;
branches;
next	1.105;

1.105
date	2013.02.14.16.22.34;	author mikeb;	state Exp;
branches;
next	1.104;

1.104
date	2012.10.18.10.49.48;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2012.09.26.14.53.23;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.101;

1.101
date	2012.09.18.09.24.45;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2012.06.29.14.48.04;	author mikeb;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.20.15.36.03;	author matthew;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.29.21.28.37;	author reyk;	state Exp;
branches;
next	1.93;

1.93
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.15.21.46.01;	author chl;	state Exp;
branches;
next	1.91;

1.91
date	2007.10.17.20.01.26;	author hshoexer;	state Exp;
branches;
next	1.90;

1.90
date	2007.10.09.01.30.47;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.88;

1.88
date	2007.02.08.15.25.30;	author itojun;	state Exp;
branches;
next	1.87;

1.87
date	2006.12.15.09.32.30;	author otto;	state Exp;
branches;
next	1.86;

1.86
date	2006.12.13.09.01.59;	author itojun;	state Exp;
branches;
next	1.85;

1.85
date	2006.05.28.02.04.15;	author mcbride;	state Exp;
branches;
next	1.84;

1.84
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2005.12.20.13.36.28;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2005.07.31.03.52.19;	author pascoe;	state Exp;
branches;
next	1.81;

1.81
date	2005.05.28.15.10.07;	author ho;	state Exp;
branches;
next	1.80;

1.80
date	2005.05.27.18.23.18;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2003.08.14.19.00.12;	author jason;	state Exp;
branches;
next	1.78;

1.78
date	2003.07.24.09.59.02;	author itojun;	state Exp;
branches;
next	1.77;

1.77
date	2003.07.24.08.03.19;	author itojun;	state Exp;
branches;
next	1.76;

1.76
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.75;

1.75
date	2003.05.03.01.43.07;	author itojun;	state Exp;
branches;
next	1.74;

1.74
date	2003.04.02.20.09.26;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	2003.03.31.20.52.06;	author millert;	state Exp;
branches;
next	1.72;

1.72
date	2003.02.28.21.42.56;	author jason;	state Exp;
branches;
next	1.71;

1.71
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.70;

1.70
date	2002.07.05.23.20.53;	author angelos;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.26.00.13.47;	author angelos;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.18.23.03.26;	author angelos;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.18.22.48.16;	author angelos;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.18.19.21.48;	author angelos;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.09.00.58.32;	author angelos;	state Exp;
branches;
next	1.64;

1.64
date	2002.05.31.02.22.21;	author angelos;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.26.06.18.58;	author angelos;	state Exp;
branches
	1.63.4.1;
next	1.62;

1.62
date	2001.06.25.05.11.58;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	2001.06.23.18.30.38;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2001.06.23.16.15.56;	author fgsch;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.08.03.13.14;	author angelos;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.01.00.09.23;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	2001.05.30.12.29.03;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	2001.05.30.12.13.59;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.27.03.51.31;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.27.03.48.32;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2001.05.17.18.41.46;	author provos;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.13.15.39.27;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.12.18.09.02;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2001.04.14.00.30.58;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.48;

1.48
date	2001.03.28.20.03.02;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.15.06.30.58;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.20.06.48.06;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2000.11.17.04.15.42;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.19.03.20.58;	author angelos;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2000.08.03.08.20.59;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.20.04.19.10;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.18.08.23.46;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2000.06.18.03.07.25;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2000.06.06.04.49.29;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2000.06.01.05.40.41;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2000.04.25.02.53.46;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2000.03.21.21.00.09;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.17.10.25.22;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.07.06.09.09;	author itojun;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.01.27.08.09.08;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	99.12.09.10.13.46;	author angelos;	state dead;
branches;
next	1.31;

1.31
date	99.12.07.09.01.47;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	99.12.07.08.57.59;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	99.12.06.23.02.08;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	99.12.06.22.56.03;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	99.12.06.07.14.35;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	99.11.04.11.23.43;	author ho;	state Exp;
branches;
next	1.25;

1.25
date	99.10.29.05.21.45;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	99.07.05.20.17.06;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.05.16.21.48.30;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.05.14.23.36.16;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.04.11.19.41.36;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.04.09.22.27.54;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.03.27.21.04.19;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	99.02.24.23.45.46;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	99.02.24.22.32.59;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	98.06.10.23.57.13;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	98.05.24.22.40.13;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	98.05.18.21.10.30;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.11.04.09.10.58;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	97.10.02.02.31.02;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.09.28.22.57.43;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.07.27.23.30.33;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.07.18.18.09.51;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.07.11.23.37.54;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.07.01.22.12.41;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.06.25.07.53.21;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.06.24.12.15.19;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.06.20.05.41.46;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.02.26.03.01.02;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.02.24.14.06.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.07.47;	author deraadt;	state Exp;
branches;
next	;

1.34.2.1
date	2000.03.24.09.09.35;	author niklas;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.05.14.22.40.08;	author niklas;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2001.07.04.10.54.37;	author niklas;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2003.05.13.19.36.16;	author ho;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.44.2.1
date	2001.02.23.17.05.45;	author jason;	state Exp;
branches;
next	;

1.63.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.63.4.2;

1.63.4.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.63.4.3;

1.63.4.3
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.131
log
@Remove NET_LOCK()'s argument.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@/*	$OpenBSD: ip_ah.c,v 1.130 2017/05/30 16:07:22 deraadt Exp $ */
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis and Niklas Hallqvist.
 *
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 * Copyright (c) 1999 Niklas Hallqvist.
 * Copyright (c) 2001 Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include "pfsync.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif /* INET6 */

#include <netinet/ip_ipsp.h>
#include <netinet/ip_ah.h>
#include <net/pfkeyv2.h>
#include <net/if_enc.h>

#if NPFSYNC > 0
#include <net/pfvar.h>
#include <net/if_pfsync.h>
#endif /* NPFSYNC > 0 */

#include <crypto/cryptodev.h>
#include <crypto/xform.h>

#include "bpfilter.h"

#ifdef ENCDEBUG
#define DPRINTF(x)	if (encdebug) printf x
#else
#define DPRINTF(x)
#endif

void	ah_output_cb(struct cryptop *);
void	ah_input_cb(struct cryptop *);
int	ah_massage_headers(struct mbuf **, int, int, int, int);

struct ahstat ahstat;

unsigned char ipseczeroes[IPSEC_ZEROES_SIZE]; /* zeroes! */


/*
 * ah_attach() is called from the transformation initialization code.
 */
int
ah_attach(void)
{
	return 0;
}

/*
 * ah_init() is called when an SPI is being set up.
 */
int
ah_init(struct tdb *tdbp, struct xformsw *xsp, struct ipsecinit *ii)
{
	struct auth_hash *thash = NULL;
	struct cryptoini cria, crin;

	/* Authentication operation. */
	switch (ii->ii_authalg) {
	case SADB_AALG_MD5HMAC:
		thash = &auth_hash_hmac_md5_96;
		break;

	case SADB_AALG_SHA1HMAC:
		thash = &auth_hash_hmac_sha1_96;
		break;

	case SADB_X_AALG_RIPEMD160HMAC:
		thash = &auth_hash_hmac_ripemd_160_96;
		break;

	case SADB_X_AALG_SHA2_256:
		thash = &auth_hash_hmac_sha2_256_128;
		break;

	case SADB_X_AALG_SHA2_384:
		thash = &auth_hash_hmac_sha2_384_192;
		break;

	case SADB_X_AALG_SHA2_512:
		thash = &auth_hash_hmac_sha2_512_256;
		break;

	default:
		DPRINTF(("ah_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
		return EINVAL;
	}

	if (ii->ii_authkeylen != thash->keysize && thash->keysize != 0) {
		DPRINTF(("ah_init(): keylength %d doesn't match algorithm "
		    "%s keysize (%d)\n", ii->ii_authkeylen, thash->name,
		    thash->keysize));
		return EINVAL;
	}

	tdbp->tdb_xform = xsp;
	tdbp->tdb_authalgxform = thash;
	tdbp->tdb_rpl = AH_HMAC_INITIAL_RPL;

	DPRINTF(("ah_init(): initialized TDB with hash algorithm %s\n",
	    thash->name));

	tdbp->tdb_amxkeylen = ii->ii_authkeylen;
	tdbp->tdb_amxkey = malloc(tdbp->tdb_amxkeylen, M_XDATA, M_WAITOK);

	memcpy(tdbp->tdb_amxkey, ii->ii_authkey, tdbp->tdb_amxkeylen);

	/* Initialize crypto session. */
	memset(&cria, 0, sizeof(cria));
	cria.cri_alg = tdbp->tdb_authalgxform->type;
	cria.cri_klen = ii->ii_authkeylen * 8;
	cria.cri_key = ii->ii_authkey;

	if ((tdbp->tdb_wnd > 0) && (tdbp->tdb_flags & TDBF_ESN)) {
		memset(&crin, 0, sizeof(crin));
		crin.cri_alg = CRYPTO_ESN;
		cria.cri_next = &crin;
	}

	return crypto_newsession(&tdbp->tdb_cryptoid, &cria, 0);
}

/*
 * Paranoia.
 */
int
ah_zeroize(struct tdb *tdbp)
{
	int err;

	if (tdbp->tdb_amxkey) {
		explicit_bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
		free(tdbp->tdb_amxkey, M_XDATA, tdbp->tdb_amxkeylen);
		tdbp->tdb_amxkey = NULL;
	}

	err = crypto_freesession(tdbp->tdb_cryptoid);
	tdbp->tdb_cryptoid = 0;
	return err;
}

/*
 * Massage IPv4/IPv6 headers for AH processing.
 */
int
ah_massage_headers(struct mbuf **m0, int proto, int skip, int alg, int out)
{
	struct mbuf *m = *m0;
	unsigned char *ptr;
	int off, count;

	struct ip *ip;

#ifdef INET6
	struct ip6_ext *ip6e;
	struct ip6_hdr ip6;
	int ad, alloc, nxt;
#endif /* INET6 */

	switch (proto) {
	case AF_INET:
		/*
		 * This is the least painful way of dealing with IPv4 header
		 * and option processing -- just make sure they're in
		 * contiguous memory.
		 */
		*m0 = m = m_pullup(m, skip);
		if (m == NULL) {
			DPRINTF(("ah_massage_headers(): m_pullup() failed\n"));
			ahstat.ahs_hdrops++;
			return ENOBUFS;
		}

		/* Fix the IP header */
		ip = mtod(m, struct ip *);
		ip->ip_tos = 0;
		ip->ip_ttl = 0;
		ip->ip_sum = 0;
		ip->ip_off = 0;

		ptr = mtod(m, unsigned char *) + sizeof(struct ip);

		/* IPv4 option processing */
		for (off = sizeof(struct ip); off < skip;) {
			if (ptr[off] == IPOPT_EOL || ptr[off] == IPOPT_NOP ||
			    off + 1 < skip)
				;
			else {
				DPRINTF(("ah_massage_headers(): illegal IPv4 "
				    "option length for option %d\n",
				    ptr[off]));

				ahstat.ahs_hdrops++;
				m_freem(m);
				return EINVAL;
			}

			switch (ptr[off]) {
			case IPOPT_EOL:
				off = skip;  /* End the loop. */
				break;

			case IPOPT_NOP:
				off++;
				break;

			case IPOPT_SECURITY:	/* 0x82 */
			case 0x85:	/* Extended security. */
			case 0x86:	/* Commercial security. */
			case 0x94:	/* Router alert */
			case 0x95:	/* RFC1770 */
				/* Sanity check for option length. */
				if (ptr[off + 1] < 2) {
					DPRINTF(("ah_massage_headers(): "
					    "illegal IPv4 option length for "
					    "option %d\n", ptr[off]));

					ahstat.ahs_hdrops++;
					m_freem(m);
					return EINVAL;
				}

				off += ptr[off + 1];
				break;

			case IPOPT_LSRR:
			case IPOPT_SSRR:
				/* Sanity check for option length. */
				if (ptr[off + 1] < 2) {
					DPRINTF(("ah_massage_headers(): "
					    "illegal IPv4 option length for "
					    "option %d\n", ptr[off]));

					ahstat.ahs_hdrops++;
					m_freem(m);
					return EINVAL;
				}

				/*
				 * On output, if we have either of the
				 * source routing options, we should
				 * swap the destination address of the
				 * IP header with the last address
				 * specified in the option, as that is
				 * what the destination's IP header
				 * will look like.
				 */
				if (out)
					bcopy(ptr + off + ptr[off + 1] -
					    sizeof(struct in_addr),
					    &(ip->ip_dst), sizeof(struct in_addr));

				/* FALLTHROUGH */
			default:
				/* Sanity check for option length. */
				if (ptr[off + 1] < 2) {
					DPRINTF(("ah_massage_headers(): "
					    "illegal IPv4 option length for "
					    "option %d\n", ptr[off]));
					ahstat.ahs_hdrops++;
					m_freem(m);
					return EINVAL;
				}

				/* Zeroize all other options. */
				count = ptr[off + 1];
				memcpy(ptr, ipseczeroes, count);
				off += count;
				break;
			}

			/* Sanity check. */
			if (off > skip)	{
				DPRINTF(("ah_massage_headers(): malformed "
				    "IPv4 options header\n"));

				ahstat.ahs_hdrops++;
				m_freem(m);
				return EINVAL;
			}
		}

		break;

#ifdef INET6
	case AF_INET6:  /* Ugly... */
		/* Copy and "cook" the IPv6 header. */
		m_copydata(m, 0, sizeof(ip6), (caddr_t) &ip6);

		/* We don't do IPv6 Jumbograms. */
		if (ip6.ip6_plen == 0) {
			DPRINTF(("ah_massage_headers(): unsupported IPv6 "
			    "jumbogram"));
			ahstat.ahs_hdrops++;
			m_freem(m);
			return EMSGSIZE;
		}

		ip6.ip6_flow = 0;
		ip6.ip6_hlim = 0;
		ip6.ip6_vfc &= ~IPV6_VERSION_MASK;
		ip6.ip6_vfc |= IPV6_VERSION;

		/* Scoped address handling. */
		if (IN6_IS_SCOPE_EMBED(&ip6.ip6_src))
			ip6.ip6_src.s6_addr16[1] = 0;
		if (IN6_IS_SCOPE_EMBED(&ip6.ip6_dst))
			ip6.ip6_dst.s6_addr16[1] = 0;

		/* Done with IPv6 header. */
		m_copyback(m, 0, sizeof(struct ip6_hdr), &ip6, M_NOWAIT);

		/* Let's deal with the remaining headers (if any). */
		if (skip - sizeof(struct ip6_hdr) > 0) {
			if (m->m_len <= skip) {
				ptr = malloc(skip - sizeof(struct ip6_hdr),
				    M_XDATA, M_NOWAIT);
				if (ptr == NULL) {
					DPRINTF(("ah_massage_headers(): failed to allocate memory for IPv6 headers\n"));
					ahstat.ahs_hdrops++;
					m_freem(m);
					return ENOBUFS;
				}

				/*
				 * Copy all the protocol headers after
				 * the IPv6 header.
				 */
				m_copydata(m, sizeof(struct ip6_hdr),
				    skip - sizeof(struct ip6_hdr), ptr);
				alloc = 1;
			} else {
				/* No need to allocate memory. */
				ptr = mtod(m, unsigned char *) +
				    sizeof(struct ip6_hdr);
				alloc = 0;
			}
		} else
			break;

		nxt = ip6.ip6_nxt & 0xff; /* Next header type. */

		for (off = 0; off < skip - sizeof(struct ip6_hdr);) {
			switch (nxt) {
			case IPPROTO_HOPOPTS:
			case IPPROTO_DSTOPTS:
				ip6e = (struct ip6_ext *) (ptr + off);

				/*
				 * Process the mutable/immutable
				 * options -- borrows heavily from the
				 * KAME code.
				 */
				for (count = off + sizeof(struct ip6_ext);
				     count < off + ((ip6e->ip6e_len + 1) << 3);) {
					if (ptr[count] == IP6OPT_PAD1) {
						count++;
						continue; /* Skip padding. */
					}

					/* Sanity check. */
					if (count > off +
					    ((ip6e->ip6e_len + 1) << 3)) {
						ahstat.ahs_hdrops++;
						m_freem(m);

						/* Free, if we allocated. */
						if (alloc)
							free(ptr, M_XDATA, 0);
						return EINVAL;
					}

					ad = ptr[count + 1];

					/* If mutable option, zeroize. */
					if (ptr[count] & IP6OPT_MUTABLE)
						memcpy(ptr + count, ipseczeroes,
						    ptr[count + 1]);

					count += ad;

					/* Sanity check. */
					if (count >
					    skip - sizeof(struct ip6_hdr)) {
						ahstat.ahs_hdrops++;
						m_freem(m);

						/* Free, if we allocated. */
						if (alloc)
							free(ptr, M_XDATA, 0);
						return EINVAL;
					}
				}

				/* Advance. */
				off += ((ip6e->ip6e_len + 1) << 3);
				nxt = ip6e->ip6e_nxt;
				break;

			case IPPROTO_ROUTING:
				/*
				 * Always include routing headers in
				 * computation.
				 */
			    {
				struct ip6_rthdr *rh;

				ip6e = (struct ip6_ext *) (ptr + off);
				rh = (struct ip6_rthdr *)(ptr + off);
				/*
				 * must adjust content to make it look like
				 * its final form (as seen at the final
				 * destination).
				 * we only know how to massage type 0 routing
				 * header.
				 */
				if (out && rh->ip6r_type == IPV6_RTHDR_TYPE_0) {
					struct ip6_rthdr0 *rh0;
					struct in6_addr *addr, finaldst;
					int i;

					rh0 = (struct ip6_rthdr0 *)rh;
					addr = (struct in6_addr *)(rh0 + 1);

					for (i = 0; i < rh0->ip6r0_segleft; i++)
						if (IN6_IS_SCOPE_EMBED(&addr[i]))
							addr[i].s6_addr16[1] = 0;

					finaldst = addr[rh0->ip6r0_segleft - 1];
					memmove(&addr[1], &addr[0],
					    sizeof(struct in6_addr) *
					    (rh0->ip6r0_segleft - 1));

					m_copydata(m, 0, sizeof(ip6),
					    (caddr_t)&ip6);
					addr[0] = ip6.ip6_dst;
					ip6.ip6_dst = finaldst;
					m_copyback(m, 0, sizeof(ip6), &ip6,
					    M_NOWAIT);

					rh0->ip6r0_segleft = 0;
				}

				/* advance */
				off += ((ip6e->ip6e_len + 1) << 3);
				nxt = ip6e->ip6e_nxt;
				break;
			    }

			default:
				DPRINTF(("ah_massage_headers(): unexpected "
				    "IPv6 header type %d\n", off));
				if (alloc)
					free(ptr, M_XDATA, 0);
				ahstat.ahs_hdrops++;
				m_freem(m);
				return EINVAL;
			}
		}

		/* Copyback and free, if we allocated. */
		if (alloc) {
			m_copyback(m, sizeof(struct ip6_hdr),
			    skip - sizeof(struct ip6_hdr), ptr, M_NOWAIT);
			free(ptr, M_XDATA, 0);
		}

		break;
#endif /* INET6 */
	}

	return 0;
}

/*
 * ah_input() gets called to verify that an input packet
 * passes authentication.
 */
int
ah_input(struct mbuf *m, struct tdb *tdb, int skip, int protoff)
{
	struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
	struct tdb_crypto *tc;
	u_int32_t btsx, esn;
	u_int8_t hl;
	int rplen;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	struct cryptodesc *crda = NULL;
	struct cryptop *crp;

	rplen = AH_FLENGTH + sizeof(u_int32_t);

	/* Save the AH header, we use it throughout. */
	m_copydata(m, skip + offsetof(struct ah, ah_hl), sizeof(u_int8_t),
	    (caddr_t) &hl);

	/* Replay window checking, if applicable. */
	if (tdb->tdb_wnd > 0) {
		m_copydata(m, skip + offsetof(struct ah, ah_rpl),
		    sizeof(u_int32_t), (caddr_t) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow(tdb, btsx, &esn, 0)) {
		case 0: /* All's well. */
			break;
		case 1:
			m_freem(m);
			DPRINTF(("ah_input(): replay counter wrapped for "
			    "SA %s/%08x\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			ahstat.ahs_wrap++;
			return ENOBUFS;
		case 2:
			m_freem(m);
			DPRINTF(("ah_input(): old packet received in "
			    "SA %s/%08x\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			ahstat.ahs_replay++;
			return ENOBUFS;
		case 3:
			m_freem(m);
			DPRINTF(("ah_input(): duplicate packet received in "
			    "SA %s/%08x\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			ahstat.ahs_replay++;
			return ENOBUFS;
		default:
			m_freem(m);
			DPRINTF(("ah_input(): bogus value from "
			    "checkreplaywindow() in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			ahstat.ahs_replay++;
			return ENOBUFS;
		}
	}

	/* Verify AH header length. */
	if (hl * sizeof(u_int32_t) != ahx->authsize + rplen - AH_FLENGTH) {
		DPRINTF(("ah_input(): bad authenticator length %ld for packet "
		    "in SA %s/%08x\n", hl * sizeof(u_int32_t),
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));

		ahstat.ahs_badauthl++;
		m_freem(m);
		return EACCES;
	}

	/* Update the counters. */
	tdb->tdb_cur_bytes +=
	    (m->m_pkthdr.len - skip - hl * sizeof(u_int32_t));
	ahstat.ahs_ibytes += (m->m_pkthdr.len - skip - hl * sizeof(u_int32_t));

	/* Hard expiration. */
	if (tdb->tdb_flags & TDBF_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
		m_freem(m);
		return ENXIO;
	}

	/* Notify on expiration. */
	if (tdb->tdb_flags & TDBF_SOFT_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES;  /* Turn off checking. */
	}

	/* Get crypto descriptors. */
	crp = crypto_getreq(1);
	if (crp == NULL) {
		m_freem(m);
		DPRINTF(("ah_input(): failed to acquire crypto "
		    "descriptors\n"));
		ahstat.ahs_crypto++;
		return ENOBUFS;
	}

	crda = &crp->crp_desc[0];

	crda->crd_skip = 0;
	crda->crd_len = m->m_pkthdr.len;
	crda->crd_inject = skip + rplen;

	/* Authentication operation. */
	crda->crd_alg = ahx->type;
	crda->crd_key = tdb->tdb_amxkey;
	crda->crd_klen = tdb->tdb_amxkeylen * 8;

	if ((tdb->tdb_wnd > 0) && (tdb->tdb_flags & TDBF_ESN)) {
		esn = htonl(esn);
		memcpy(crda->crd_esn, &esn, 4);
		crda->crd_flags |= CRD_F_ESN;
	}

	/* Allocate IPsec-specific opaque crypto info. */
	tc = malloc(sizeof(*tc) + skip + rplen + ahx->authsize, M_XDATA,
	    M_NOWAIT | M_ZERO);
	if (tc == NULL) {
		m_freem(m);
		crypto_freereq(crp);
		DPRINTF(("ah_input(): failed to allocate tdb_crypto\n"));
		ahstat.ahs_crypto++;
		return ENOBUFS;
	}

	/*
	 * Save the authenticator, the skipped portion of the packet,
	 * and the AH header.
	 */
	m_copydata(m, 0, skip + rplen + ahx->authsize, (caddr_t) (tc + 1));

	/* Zeroize the authenticator on the packet. */
	m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes, M_NOWAIT);

	/* "Massage" the packet headers for crypto processing. */
	if ((btsx = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
	    skip, ahx->type, 0)) != 0) {
		/* mbuf will be free'd by callee. */
		free(tc, M_XDATA, 0);
		crypto_freereq(crp);
		return btsx;
	}

	/* Crypto operation descriptor. */
	crp->crp_ilen = m->m_pkthdr.len; /* Total input length. */
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t)m;
	crp->crp_callback = ah_input_cb;
	crp->crp_sid = tdb->tdb_cryptoid;
	crp->crp_opaque = (caddr_t)tc;

	/* These are passed as-is to the callback. */
	tc->tc_skip = skip;
	tc->tc_protoff = protoff;
	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = tdb->tdb_sproto;
	tc->tc_rdomain = tdb->tdb_rdomain;
	memcpy(&tc->tc_dst, &tdb->tdb_dst, sizeof(union sockaddr_union));

	return crypto_dispatch(crp);
}

/*
 * AH input callback, called directly by the crypto driver.
 */
void
ah_input_cb(struct cryptop *crp)
{
	int roff, rplen, skip, protoff;
	unsigned char calc[AH_ALEN_MAX];
	struct mbuf *m1, *m0, *m;
	struct auth_hash *ahx;
	struct tdb_crypto *tc;
	struct tdb *tdb;
	u_int32_t btsx, esn;
	caddr_t ptr;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	tc = (struct tdb_crypto *) crp->crp_opaque;
	skip = tc->tc_skip;
	protoff = tc->tc_protoff;

	m = (struct mbuf *) crp->crp_buf;
	if (m == NULL) {
		/* Shouldn't happen... */
		free(tc, M_XDATA, 0);
		crypto_freereq(crp);
		ahstat.ahs_crypto++;
		DPRINTF(("ah_input_cb(): bogus returned buffer from "
		    "crypto\n"));
		return;
	}

	NET_LOCK();

	tdb = gettdb(tc->tc_rdomain, tc->tc_spi, &tc->tc_dst, tc->tc_proto);
	if (tdb == NULL) {
		free(tc, M_XDATA, 0);
		ahstat.ahs_notdb++;
		DPRINTF(("ah_input_cb(): TDB is expired while in crypto"));
		goto baddone;
	}

	ahx = (struct auth_hash *) tdb->tdb_authalgxform;

	/* Check for crypto errors. */
	if (crp->crp_etype) {
		if (crp->crp_etype == EAGAIN) {
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
			NET_UNLOCK();
			crypto_dispatch(crp);
			return;
		}
		free(tc, M_XDATA, 0);
		ahstat.ahs_noxform++;
		DPRINTF(("ah_input_cb(): crypto error %d\n", crp->crp_etype));
		goto baddone;
	} else {
		crypto_freereq(crp); /* No longer needed. */
		crp = NULL;
	}

	rplen = AH_FLENGTH + sizeof(u_int32_t);

	/* Copy authenticator off the packet. */
	m_copydata(m, skip + rplen, ahx->authsize, calc);

	ptr = (caddr_t) (tc + 1);

	/* Verify authenticator. */
	if (timingsafe_bcmp(ptr + skip + rplen, calc, ahx->authsize)) {
		free(tc, M_XDATA, 0);

		DPRINTF(("ah_input(): authentication failed for "
		    "packet in SA %s/%08x\n",
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));

		ahstat.ahs_badauth++;
		goto baddone;
	}

	/* Fix the Next Protocol field. */
	((u_int8_t *) ptr)[protoff] = ((u_int8_t *) ptr)[skip];

	/* Copyback the saved (uncooked) network headers. */
	m_copyback(m, 0, skip, ptr, M_NOWAIT);

	free(tc, M_XDATA, 0);

	/* Replay window checking, if applicable. */
	if (tdb->tdb_wnd > 0) {
		m_copydata(m, skip + offsetof(struct ah, ah_rpl),
		    sizeof(u_int32_t), (caddr_t) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow(tdb, btsx, &esn, 1)) {
		case 0: /* All's well. */
#if NPFSYNC > 0
			pfsync_update_tdb(tdb,0);
#endif
			break;
		case 1:
			DPRINTF(("ah_input(): replay counter wrapped for "
			    "SA %s/%08x\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			ahstat.ahs_wrap++;
			goto baddone;
		case 2:
			DPRINTF(("ah_input_cb(): old packet received in "
			    "SA %s/%08x\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			ahstat.ahs_replay++;
			goto baddone;
		case 3:
			DPRINTF(("ah_input_cb(): duplicate packet received in "
			    "SA %s/%08x\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			ahstat.ahs_replay++;
			goto baddone;
		default:
			DPRINTF(("ah_input_cb(): bogus value from "
			    "checkreplaywindow() in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			ahstat.ahs_replay++;
			goto baddone;
		}
	}

	/* Record the beginning of the AH header. */
	m1 = m_getptr(m, skip, &roff);
	if (m1 == NULL) {
		ahstat.ahs_hdrops++;
		NET_UNLOCK();
		m_freem(m);

		DPRINTF(("ah_input(): bad mbuf chain for packet in SA "
		    "%s/%08x\n", ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		return;
	}

	/* Remove the AH header from the mbuf. */
	if (roff == 0) {
		/*
		 * The AH header was conveniently at the beginning of
		 * the mbuf.
		 */
		m_adj(m1, rplen + ahx->authsize);
		if (!(m1->m_flags & M_PKTHDR))
			m->m_pkthdr.len -= rplen + ahx->authsize;
	} else
		if (roff + rplen + ahx->authsize >= m1->m_len) {
			/*
			 * Part or all of the AH header is at the end
			 * of this mbuf, so first let's remove the
			 * remainder of the AH header from the
			 * beginning of the remainder of the mbuf
			 * chain, if any.
			 */
			if (roff + rplen + ahx->authsize > m1->m_len) {
				/* Adjust the next mbuf by the remainder. */
				m_adj(m1->m_next, roff + rplen +
				    ahx->authsize - m1->m_len);

				/*
				 * The second mbuf is guaranteed not
				 * to have a pkthdr...
				 */
				m->m_pkthdr.len -=
				    (roff + rplen + ahx->authsize - m1->m_len);
			}

			/* Now, let's unlink the mbuf chain for a second... */
			m0 = m1->m_next;
			m1->m_next = NULL;

			/*
			 * ...and trim the end of the first part of
			 * the chain...sick
			 */
			m_adj(m1, -(m1->m_len - roff));
			if (!(m1->m_flags & M_PKTHDR))
				m->m_pkthdr.len -= (m1->m_len - roff);

			/* Finally, let's relink. */
			m1->m_next = m0;
		} else {
			/*
			 * The AH header lies in the "middle" of the
			 * mbuf...do an overlapping copy of the
			 * remainder of the mbuf over the ESP header.
			 */
			bcopy(mtod(m1, u_char *) + roff + rplen +
			    ahx->authsize, mtod(m1, u_char *) + roff,
			    m1->m_len - (roff + rplen + ahx->authsize));
			m1->m_len -= rplen + ahx->authsize;
			m->m_pkthdr.len -= rplen + ahx->authsize;
		}

	ipsec_common_input_cb(m, tdb, skip, protoff);
	NET_UNLOCK();
	return;

 baddone:
	NET_UNLOCK();

	m_freem(m);

	if (crp != NULL)
		crypto_freereq(crp);
}

/*
 * AH output routine, called by ipsp_process_packet().
 */
int
ah_output(struct mbuf *m, struct tdb *tdb, struct mbuf **mp, int skip,
    int protoff)
{
	struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
	struct cryptodesc *crda;
	struct tdb_crypto *tc;
	struct mbuf *mi;
	struct cryptop *crp;
	u_int16_t iplen;
	int len, rplen, roff;
	u_int8_t prot;
	struct ah *ah;
#if NBPFILTER > 0
	struct ifnet *encif;
#ifdef ENCDEBUG
	char buf[INET6_ADDRSTRLEN];
#endif

	if ((encif = enc_getif(tdb->tdb_rdomain, tdb->tdb_tap)) != NULL) {
		encif->if_opackets++;
		encif->if_obytes += m->m_pkthdr.len;

		if (encif->if_bpf) {
			struct enchdr hdr;

			memset(&hdr, 0, sizeof(hdr));

			hdr.af = tdb->tdb_dst.sa.sa_family;
			hdr.spi = tdb->tdb_spi;
			hdr.flags |= M_AUTH;

			bpf_mtap_hdr(encif->if_bpf, (char *)&hdr,
			    ENC_HDRLEN, m, BPF_DIRECTION_OUT, NULL);
		}
	}
#endif

	ahstat.ahs_output++;

	/*
	 * Check for replay counter wrap-around in automatic (not
	 * manual) keying.
	 */
	if ((tdb->tdb_rpl == 0) && (tdb->tdb_wnd > 0)) {
		DPRINTF(("ah_output(): SA %s/%08x should have expired\n",
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		m_freem(m);
		ahstat.ahs_wrap++;
		return EINVAL;
	}

	rplen = AH_FLENGTH + sizeof(u_int32_t);

	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		/* Check for IP maximum packet size violations. */
		if (rplen + ahx->authsize + m->m_pkthdr.len > IP_MAXPACKET) {
			DPRINTF(("ah_output(): packet in SA %s/%08x got too "
			    "big\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
			m_freem(m);
			ahstat.ahs_toobig++;
			return EMSGSIZE;
		}
		break;

#ifdef INET6
	case AF_INET6:
		/* Check for IPv6 maximum packet size violations. */
		if (rplen + ahx->authsize + m->m_pkthdr.len > IPV6_MAXPACKET) {
			DPRINTF(("ah_output(): packet in SA %s/%08x "
			    "got too big\n", ipsp_address(&tdb->tdb_dst, buf,
			    sizeof(buf)), ntohl(tdb->tdb_spi)));
			m_freem(m);
			ahstat.ahs_toobig++;
			return EMSGSIZE;
		}
		break;
#endif /* INET6 */

	default:
		DPRINTF(("ah_output(): unknown/unsupported protocol "
		    "family %d, SA %s/%08x\n", tdb->tdb_dst.sa.sa_family,
		    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));
		m_freem(m);
		ahstat.ahs_nopf++;
		return EPFNOSUPPORT;
	}

	/* Update the counters. */
	tdb->tdb_cur_bytes += m->m_pkthdr.len - skip;
	ahstat.ahs_obytes += m->m_pkthdr.len - skip;

	/* Hard expiration. */
	if (tdb->tdb_flags & TDBF_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
		m_freem(m);
		return EINVAL;
	}

	/* Notify on expiration. */
	if (tdb->tdb_flags & TDBF_SOFT_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES; /* Turn off checking */
	}

	/*
	 * Loop through mbuf chain; if we find a readonly mbuf,
	 * copy the packet.
	 */
	mi = m;
	while (mi != NULL && !M_READONLY(mi))
		mi = mi->m_next;

	if (mi != NULL) {
		struct mbuf *n = m_dup_pkt(m, 0, M_DONTWAIT);

		if (n == NULL) {
			ahstat.ahs_hdrops++;
			m_freem(m);
			return ENOBUFS;
		}

		m_freem(m);
		m = n;
	}

	/* Inject AH header. */
	mi = m_makespace(m, skip, rplen + ahx->authsize, &roff);
	if (mi == NULL) {
		DPRINTF(("ah_output(): failed to inject AH header for SA "
		    "%s/%08x\n", ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
		    ntohl(tdb->tdb_spi)));

		m_freem(m);
		ahstat.ahs_hdrops++;
		return ENOBUFS;
	}

	/*
	 * The AH header is guaranteed by m_makespace() to be in
	 * contiguous memory, at 'roff' of the returned mbuf.
	 */
	ah = (struct ah *)(mtod(mi, caddr_t) + roff);

	/* Initialize the AH header. */
	m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &ah->ah_nh);
	ah->ah_hl = (rplen + ahx->authsize - AH_FLENGTH) / sizeof(u_int32_t);
	ah->ah_rv = 0;
	ah->ah_spi = tdb->tdb_spi;

	/* Zeroize authenticator. */
	m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes, M_NOWAIT);

	tdb->tdb_rpl++;
	ah->ah_rpl = htonl((u_int32_t)(tdb->tdb_rpl & 0xffffffff));
#if NPFSYNC > 0
	pfsync_update_tdb(tdb,1);
#endif

	/* Get crypto descriptors. */
	crp = crypto_getreq(1);
	if (crp == NULL) {
		m_freem(m);
		DPRINTF(("ah_output(): failed to acquire crypto "
		    "descriptors\n"));
		ahstat.ahs_crypto++;
		return ENOBUFS;
	}

	crda = &crp->crp_desc[0];

	crda->crd_skip = 0;
	crda->crd_inject = skip + rplen;
	crda->crd_len = m->m_pkthdr.len;

	/* Authentication operation. */
	crda->crd_alg = ahx->type;
	crda->crd_key = tdb->tdb_amxkey;
	crda->crd_klen = tdb->tdb_amxkeylen * 8;

	if ((tdb->tdb_wnd > 0) && (tdb->tdb_flags & TDBF_ESN)) {
		u_int32_t esn;

		esn = htonl((u_int32_t)(tdb->tdb_rpl >> 32));
		memcpy(crda->crd_esn, &esn, 4);
		crda->crd_flags |= CRD_F_ESN;
	}

	/* Allocate IPsec-specific opaque crypto info. */
	tc = malloc(sizeof(*tc) + skip, M_XDATA, M_NOWAIT | M_ZERO);
	if (tc == NULL) {
		m_freem(m);
		crypto_freereq(crp);
		DPRINTF(("ah_output(): failed to allocate tdb_crypto\n"));
		ahstat.ahs_crypto++;
		return ENOBUFS;
	}

	/* Save the skipped portion of the packet. */
	m_copydata(m, 0, skip, (caddr_t) (tc + 1));

	/*
	 * Fix IP header length on the header used for
	 * authentication. We don't need to fix the original
	 * header length as it will be fixed by our caller.
	 */
	switch (tdb->tdb_dst.sa.sa_family) {
	case AF_INET:
		memcpy((caddr_t) &iplen, ((caddr_t)(tc + 1)) +
		    offsetof(struct ip, ip_len), sizeof(u_int16_t));
		iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
		m_copyback(m, offsetof(struct ip, ip_len),
		    sizeof(u_int16_t), &iplen, M_NOWAIT);
		break;

#ifdef INET6
	case AF_INET6:
		memcpy((caddr_t) &iplen, ((caddr_t)(tc + 1)) +
		    offsetof(struct ip6_hdr, ip6_plen), sizeof(u_int16_t));
		iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
		m_copyback(m, offsetof(struct ip6_hdr, ip6_plen),
		    sizeof(u_int16_t), &iplen, M_NOWAIT);
		break;
#endif /* INET6 */
	}

	/* Fix the Next Header field in saved header. */
	((u_int8_t *) (tc + 1))[protoff] = IPPROTO_AH;

	/* Update the Next Protocol field in the IP header. */
	prot = IPPROTO_AH;
	m_copyback(m, protoff, sizeof(u_int8_t), &prot, M_NOWAIT);

	/* "Massage" the packet headers for crypto processing. */
	if ((len = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
	    skip, ahx->type, 1)) != 0) {
		/* mbuf will be free'd by callee. */
		free(tc, M_XDATA, 0);
		crypto_freereq(crp);
		return len;
	}

	/* Crypto operation descriptor. */
	crp->crp_ilen = m->m_pkthdr.len; /* Total input length. */
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t)m;
	crp->crp_callback = ah_output_cb;
	crp->crp_sid = tdb->tdb_cryptoid;
	crp->crp_opaque = (caddr_t)tc;

	/* These are passed as-is to the callback. */
	tc->tc_skip = skip;
	tc->tc_protoff = protoff;
	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = tdb->tdb_sproto;
	tc->tc_rdomain = tdb->tdb_rdomain;
	memcpy(&tc->tc_dst, &tdb->tdb_dst, sizeof(union sockaddr_union));

	return crypto_dispatch(crp);
}

/*
 * AH output callback, called directly from the crypto handler.
 */
void
ah_output_cb(struct cryptop *crp)
{
	int skip;
	struct tdb_crypto *tc;
	struct tdb *tdb;
	struct mbuf *m;
	caddr_t ptr;

	tc = (struct tdb_crypto *) crp->crp_opaque;
	skip = tc->tc_skip;
	ptr = (caddr_t) (tc + 1);

	m = (struct mbuf *) crp->crp_buf;
	if (m == NULL) {
		/* Shouldn't happen... */
		free(tc, M_XDATA, 0);
		crypto_freereq(crp);
		ahstat.ahs_crypto++;
		DPRINTF(("ah_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		return;
	}

	NET_LOCK();

	tdb = gettdb(tc->tc_rdomain, tc->tc_spi, &tc->tc_dst, tc->tc_proto);
	if (tdb == NULL) {
		free(tc, M_XDATA, 0);
		ahstat.ahs_notdb++;
		DPRINTF(("ah_output_cb(): TDB is expired while in crypto\n"));
		goto baddone;
	}

	/* Check for crypto errors. */
	if (crp->crp_etype) {
		if (crp->crp_etype == EAGAIN) {
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
			NET_UNLOCK();
			crypto_dispatch(crp);
			return;
		}
		free(tc, M_XDATA, 0);
		ahstat.ahs_noxform++;
		DPRINTF(("ah_output_cb(): crypto error %d\n", crp->crp_etype));
		goto baddone;
	}

	/*
	 * Copy original headers (with the new protocol number) back
	 * in place.
	 */
	m_copyback(m, 0, skip, ptr, M_NOWAIT);

	free(tc, M_XDATA, 0);

	/* No longer needed. */
	crypto_freereq(crp);

	if (ipsp_process_done(m, tdb))
		ahstat.ahs_outfail++;
	NET_UNLOCK();
	return;

 baddone:
	NET_UNLOCK();

	m_freem(m);

	crypto_freereq(crp);
}
@


1.130
log
@add sizes to free() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.129 2017/02/09 00:43:58 bluhm Exp $ */
d703 1
a703 1
	int s, roff, rplen, skip, protoff;
d730 1
a730 1
	NET_LOCK(s);
d748 1
a748 1
			NET_UNLOCK(s);
d833 1
a833 1
		NET_UNLOCK(s);
d901 1
a901 1
	NET_UNLOCK(s);
d905 1
a905 1
	NET_UNLOCK(s);
a1195 1
	int s;
d1212 1
a1212 1
	NET_LOCK(s);
d1228 1
a1228 1
			NET_UNLOCK(s);
d1251 1
a1251 1
	NET_UNLOCK(s);
d1255 1
a1255 1
	NET_UNLOCK(s);
@


1.129
log
@Put back a return that I have removed by accident.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.128 2017/02/07 18:18:16 bluhm Exp $ */
d181 1
a181 1
		free(tdbp->tdb_amxkey, M_XDATA, 0);
@


1.128
log
@IPsec packets could be dropped unaccounted if output after crypto
failed.  Add a counter for that case.
OK dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.127 2017/02/07 17:25:46 patrick Exp $ */
d1253 1
@


1.127
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.126 2017/02/07 15:10:48 bluhm Exp $ */
d1250 2
a1251 2
	ipsp_process_done(m, tdb);
	/* XXX missing error counter if ipsp_process_done() drops packet */
@


1.126
log
@The return code of crp_callback is never checked, so it is not
useful to propagate the error.  When an error occurs in an asynchronous
network path, incrementing a counter is the right thing.  There are
four places where an error is not accounted, just add a comment for
now.
OK mpi@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.125 2017/01/09 17:10:02 mpi Exp $ */
d632 1
a632 1
	crda = crp->crp_desc;
d1093 1
a1093 1
	crda = crp->crp_desc;
@


1.125
log
@Grab the NET_LOCK() in various callbacks.

Fix an assert reported by Hrvoje Popovski.

ok visa@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.124 2016/12/24 11:17:35 mpi Exp $ */
d79 2
a80 2
int	ah_output_cb(struct cryptop *);
int	ah_input_cb(struct cryptop *);
d700 1
a700 1
int
d703 1
a703 1
	int s, roff, rplen, error, skip, protoff;
d727 1
a727 1
		return (EINVAL);
a736 1
		error = EPERM;
d749 2
a750 1
			return crypto_dispatch(crp);
a754 1
		error = crp->crp_etype;
a777 1
		error = EACCES;
a805 1
			error = ENOBUFS;
a811 1
			error = ENOBUFS;
a817 1
			error = ENOBUFS;
a824 1
			error = ENOBUFS;
d839 1
a839 2

		return EINVAL;
d900 1
a900 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff);
d902 1
a902 1
	return (error);
a910 2

	return (error);
d1188 1
a1188 1
int
d1191 1
a1191 1
	int skip, error;
d1196 1
a1196 1
	int err, s;
d1210 1
a1210 1
		return (EINVAL);
a1219 1
		error = EPERM;
d1230 2
a1231 1
			return crypto_dispatch(crp);
a1235 1
		error = crp->crp_etype;
d1250 2
a1251 1
	err =  ipsp_process_done(m, tdb);
a1252 1
	return err;
a1259 2

	return error;
@


1.124
log
@Grab the NET_LOCK() before calling ipsp_process_done() as it ends up
in ip_output().

Found the hardway by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.123 2016/09/19 18:09:22 tedu Exp $ */
d730 1
a730 1
	s = splsoftnet();
d749 1
a749 1
			splx(s);
d839 1
a839 1
		splx(s);
d908 1
a908 1
	splx(s);
d912 1
a912 1
	splx(s);
@


1.123
log
@convert bcopy to memcpy. from david hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.122 2016/09/13 19:56:55 markus Exp $ */
d1222 1
a1222 1
	s = splsoftnet();
d1239 1
a1239 1
			splx(s);
d1261 1
a1261 1
	splx(s);
d1265 1
a1265 1
	splx(s);
@


1.122
log
@avoid extensive mbuf allocation for IPsec by replacing m_inject(4)
with m_makespace(4) from freebsd; ok mpi@@, bluhm@@, mikeb@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.121 2016/08/18 06:01:10 dlg Exp $ */
d154 1
a154 1
	bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
d315 1
a315 1
				bcopy(ipseczeroes, ptr, count);
d425 1
a425 1
						bcopy(ipseczeroes, ptr + count,
d645 1
a645 1
		bcopy(&esn, crda->crd_esn, 4);
d692 1
a692 1
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));
d1117 1
a1117 1
		bcopy(&esn, crda->crd_esn, 4);
d1141 2
a1142 3
		bcopy(((caddr_t)(tc + 1)) +
		    offsetof(struct ip, ip_len),
		    (caddr_t) &iplen, sizeof(u_int16_t));
d1150 2
a1151 3
		bcopy(((caddr_t)(tc + 1)) +
		    offsetof(struct ip6_hdr, ip6_plen),
		    (caddr_t) &iplen, sizeof(u_int16_t));
d1189 1
a1189 1
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));
@


1.121
log
@fix panics caused by replacing m_copym2 with m_dup_pkt.

m_copym2 is fine duplicating an arbitrary chain of mbufs, while
m_dup_pkt wants to dup a packet with proper headers in the first
mbuf. ipsec copied the tail of an mbuf if any of the clusters are
shared or readonly, and swapped that tail with the result of m_copym2.

m_dup_pkt panics cos of that.

this makes ipsec duplicate the whole packet if any of the chain is
readonly.

found by naddy@@ and mlarkin@@
this fix is from visa@@ who told me to commit it cos he's afk (sleeping)
tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.120 2016/08/15 11:35:25 dlg Exp $ */
d935 1
a935 1
	int len, rplen;
d1060 1
a1060 1
	mi = m_inject(m, skip, rplen + ahx->authsize, M_DONTWAIT);
d1072 2
a1073 2
	 * The AH header is guaranteed by m_inject() to be in
	 * contiguous memory, at the beginning of the returned mbuf.
d1075 1
a1075 1
	ah = mtod(mi, struct ah *);
@


1.120
log
@replace the last uses of m_copym2 with m_dup_pkt.

ok mpi@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.119 2016/03/07 18:44:00 naddy Exp $ */
d932 1
a932 1
	struct mbuf *mo, *mi;
d1040 1
a1040 1
	 * replace the rest of the chain.
a1041 1
	mo = NULL;
d1043 1
a1043 2
	while (mi != NULL && !M_READONLY(mi)) {
		mo = mi;
a1044 1
	}
d1047 1
a1047 2
		/* Replace the rest of the mbuf chain. */
		struct mbuf *n = m_dup_pkt(mi, 0, M_DONTWAIT);
d1055 2
a1056 6
		if (mo != NULL)
			mo->m_next = n;
		else
			m = n;

		m_freem(mi);
@


1.119
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.118 2015/07/15 22:16:42 deraadt Exp $ */
d1051 1
a1051 1
		struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);
@


1.118
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.117 2015/06/15 12:37:37 mikeb Exp $ */
d92 1
a92 1
ah_attach()
@


1.117
log
@Use proper argument type for crp_callback functions; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.116 2015/04/17 11:04:01 mikeb Exp $ */
d914 1
a914 2
	if (m != NULL)
		m_freem(m);
d1277 1
a1277 2
	if (m != NULL)
		m_freem(m);
@


1.116
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.115 2015/04/14 14:20:01 mikeb Exp $ */
d79 2
a80 2
int	ah_output_cb(void *);
int	ah_input_cb(void *);
d681 2
a682 2
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) ah_input_cb;
d684 1
a684 1
	crp->crp_opaque = (caddr_t) tc;
d701 1
a701 1
ah_input_cb(void *op)
a707 1
	struct cryptop *crp;
a714 2
	crp = (struct cryptop *) op;

d1189 2
a1190 2
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) ah_output_cb;
d1192 1
a1192 1
	crp->crp_opaque = (caddr_t) tc;
d1209 1
a1209 1
ah_output_cb(void *op)
a1212 1
	struct cryptop *crp;
a1217 1
	crp = (struct cryptop *) op;
@


1.115
log
@make ipsp_address thread safe;  ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.114 2014/12/28 10:02:37 tedu Exp $ */
a531 1
	struct m_tag *mtag;
a648 19
#ifdef notyet
	/* Find out if we've already done crypto. */
	for (mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, NULL);
	     mtag != NULL;
	     mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, mtag)) {
		struct tdb_ident *tdbi;

		tdbi = (struct tdb_ident *) (mtag + 1);
		if (tdbi->proto == tdb->tdb_sproto &&
		    tdbi->spi == tdb->tdb_spi &&
		    tdbi->rdomain == tdb->tdb_rdomain &&
		    !memcmp(&tdbi->dst, &tdb->tdb_dst,
			sizeof(union sockaddr_union)))
			break;
	}
#else
	mtag = NULL;
#endif

d650 2
a651 5
	if (mtag == NULL)
		tc = malloc(sizeof(*tc) + skip + rplen + ahx->authsize, M_XDATA,
		    M_NOWAIT | M_ZERO);
	else /* Hash verification has already been done successfully. */
		tc = malloc(sizeof(*tc), M_XDATA, M_NOWAIT | M_ZERO);
d660 8
a667 8
	/* Only save information if crypto processing is needed. */
	if (mtag == NULL) {
		/*
		 * Save the authenticator, the skipped portion of the packet,
		 * and the AH header.
		 */
		m_copydata(m, 0, skip + rplen + ahx->authsize,
		    (caddr_t) (tc + 1));
d669 7
a675 12
		/* Zeroize the authenticator on the packet. */
		m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes,
		    M_NOWAIT);

		/* "Massage" the packet headers for crypto processing. */
		if ((btsx = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
		    skip, ahx->type, 0)) != 0) {
			/* mbuf will be free'd by callee. */
			free(tc, M_XDATA, 0);
			crypto_freereq(crp);
			return btsx;
		}
a690 1
	tc->tc_ptr = (caddr_t) mtag; /* Save the mtag we've identified. */
d694 1
a694 4
	if (mtag == NULL)
		return crypto_dispatch(crp);
	else
		return ah_input_cb(crp);
a708 1
	struct m_tag *mtag;
a710 1
	u_int8_t prot;
a720 1
	mtag = (struct m_tag *) tc->tc_ptr;
d770 1
a770 6
	/*
	 * If we have an mtag, we don't need to verify the authenticator --
	 * it has been verified by an IPsec-aware NIC.
	 */
	if (mtag == NULL) {
		ptr = (caddr_t) (tc + 1);
d772 3
a774 3
		/* Verify authenticator. */
		if (timingsafe_bcmp(ptr + skip + rplen, calc, ahx->authsize)) {
			free(tc, M_XDATA, 0);
d776 4
a779 4
			DPRINTF(("ah_input(): authentication failed for "
			    "packet in SA %s/%08x\n",
			    ipsp_address(&tdb->tdb_dst, buf, sizeof(buf)),
			    ntohl(tdb->tdb_spi)));
d781 4
a784 4
			ahstat.ahs_badauth++;
			error = EACCES;
			goto baddone;
		}
d786 2
a787 2
		/* Fix the Next Protocol field. */
		((u_int8_t *) ptr)[protoff] = ((u_int8_t *) ptr)[skip];
d789 2
a790 7
		/* Copyback the saved (uncooked) network headers. */
		m_copyback(m, 0, skip, ptr, M_NOWAIT);
	} else {
		/* Fix the Next Protocol field. */
		m_copydata(m, skip, sizeof(u_int8_t), &prot);
		m_copyback(m, protoff, sizeof(u_int8_t), &prot, M_NOWAIT);
	}
d910 1
a910 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
d1134 1
a1134 4
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		tc = malloc(sizeof(*tc) + skip, M_XDATA, M_NOWAIT | M_ZERO);
	else
		tc = malloc(sizeof(*tc), M_XDATA, M_NOWAIT | M_ZERO);
d1144 1
a1144 2
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0) {
		m_copydata(m, 0, skip, (caddr_t) (tc + 1));
d1146 14
a1159 14
		/*
		 * Fix IP header length on the header used for
		 * authentication. We don't need to fix the original
		 * header length as it will be fixed by our caller.
		 */
		switch (tdb->tdb_dst.sa.sa_family) {
		case AF_INET:
			bcopy(((caddr_t)(tc + 1)) +
			    offsetof(struct ip, ip_len),
			    (caddr_t) &iplen, sizeof(u_int16_t));
			iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
			m_copyback(m, offsetof(struct ip, ip_len),
			    sizeof(u_int16_t), &iplen, M_NOWAIT);
			break;
d1162 8
a1169 8
		case AF_INET6:
			bcopy(((caddr_t)(tc + 1)) +
			    offsetof(struct ip6_hdr, ip6_plen),
			    (caddr_t) &iplen, sizeof(u_int16_t));
			iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
			m_copyback(m, offsetof(struct ip6_hdr, ip6_plen),
			    sizeof(u_int16_t), &iplen, M_NOWAIT);
			break;
d1171 1
a1171 1
		}
d1173 2
a1174 2
		/* Fix the Next Header field in saved header. */
		((u_int8_t *) (tc + 1))[protoff] = IPPROTO_AH;
d1176 11
a1186 16
		/* Update the Next Protocol field in the IP header. */
		prot = IPPROTO_AH;
		m_copyback(m, protoff, sizeof(u_int8_t), &prot, M_NOWAIT);

		/* "Massage" the packet headers for crypto processing. */
		if ((len = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
		    skip, ahx->type, 1)) != 0) {
			/* mbuf will be free'd by callee. */
			free(tc, M_XDATA, 0);
			crypto_freereq(crp);
			return len;
		}
	} else {
		/* Update the Next Protocol field in the IP header. */
		prot = IPPROTO_AH;
		m_copyback(m, protoff, sizeof(u_int8_t), &prot, M_NOWAIT);
d1205 1
a1205 4
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		return crypto_dispatch(crp);
	else
		return ah_output_cb(crp);
d1269 1
a1269 2
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		m_copyback(m, 0, skip, ptr, M_NOWAIT);
@


1.114
log
@remove KPDK. not really used, and a bad choice anyway. ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.113 2014/12/19 17:14:40 tedu Exp $ */
d536 3
d561 2
a562 2
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
d568 2
a569 2
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
d575 2
a576 2
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
d583 2
a584 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d592 1
a592 1
		DPRINTF(("ah_input(): bad authenticator length %d for packet "
d594 2
a595 1
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d746 3
d818 2
a819 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d853 2
a854 2
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
d860 2
a861 2
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
d867 2
a868 2
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
d875 2
a876 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d891 1
a891 1
		    "%s/%08x\n", ipsp_address(tdb->tdb_dst),
d989 3
d1020 2
a1021 1
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d1035 2
a1036 1
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d1048 2
a1049 2
			    "got too big\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
d1060 2
a1061 1
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d1120 1
a1120 1
		    "%s/%08x\n", ipsp_address(tdb->tdb_dst),
@


1.113
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.112 2014/12/05 15:50:04 mpi Exp $ */
a131 8
	case SADB_X_AALG_MD5:
		thash = &auth_hash_key_md5;
		break;

	case SADB_X_AALG_SHA1:
		thash = &auth_hash_key_sha1;
		break;

d227 1
a227 9

		/*
		 * On input, fix ip_len which has been byte-swapped
		 * at ip_input().
		 */
		if (alg == CRYPTO_MD5_KPDK || alg == CRYPTO_SHA1_KPDK)
			ip->ip_off &= htons(IP_DF);
		else
			ip->ip_off = 0;
@


1.112
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.111 2014/07/22 11:06:10 mpi Exp $ */
a49 1
#ifdef INET
a52 1
#endif /* INET */
a54 3
#ifndef INET
#include <netinet/in.h>
#endif /* INET */
a207 1
#ifdef INET
a208 1
#endif /* INET */
a216 1
#ifdef INET
a347 1
#endif /* INET */
a1031 1
#ifdef INET
a1042 1
#endif /* INET */
a1200 1
#ifdef INET
a1208 1
#endif /* INET */
@


1.111
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.110 2014/07/12 18:44:23 tedu Exp $ */
d47 1
@


1.110
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.109 2014/07/09 09:30:49 henning Exp $ */
a50 1
#include <netinet/in_systm.h>
@


1.109
log
@bpf code surgery / shuffling / simplification.
the various bpf_mtap_* are very similiar, they differ in what (and to some
extent how) they prepend something, and what copy function they pass to
bpf_catchpacket.
use an internal _bpf_mtap as "backend" for bpf_mtap and friends.
extend bpf_mtap_hdr so that it covers all common cases:
if dlen is 0, nothing gets prepended.
copy function can be given, if NULL the default bpf_mcopy is used.
adjust the existing bpf_mtap_hdr users to pass a NULL ptr for the copy fn.
re-implement bpf_mtap_af as simple wrapper for bpf_mtap_hdr.
re-implement bpf_mtap_ether using bpf_map_hdr
re-implement bpf_mtap_pflog as trivial bpf_mtap_hdr wrapper
ok bluhm benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.107 2013/06/11 18:15:53 deraadt Exp $ */
d194 1
a194 1
		free(tdbp->tdb_amxkey, M_XDATA);
d442 1
a442 1
							free(ptr, M_XDATA);
d463 1
a463 1
							free(ptr, M_XDATA);
d527 1
a527 1
					free(ptr, M_XDATA);
d538 1
a538 1
			free(ptr, M_XDATA);
d720 1
a720 1
			free(tc, M_XDATA);
d777 1
a777 1
		free(tc, M_XDATA);
d789 1
a789 1
		free(tc, M_XDATA);
d807 1
a807 1
		free(tc, M_XDATA);
d831 1
a831 1
			free(tc, M_XDATA);
d853 1
a853 1
	free(tc, M_XDATA);
d1246 1
a1246 1
			free(tc, M_XDATA);
d1300 1
a1300 1
		free(tc, M_XDATA);
d1312 1
a1312 1
		free(tc, M_XDATA);
d1328 1
a1328 1
		free(tc, M_XDATA);
d1342 1
a1342 1
	free(tc, M_XDATA);
@


1.108
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1019 1
a1019 1
			    ENC_HDRLEN, m, BPF_DIRECTION_OUT);
@


1.107
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.106 2013/04/11 12:06:25 mpi Exp $ */
d170 1
a170 1
	bzero(&cria, sizeof(cria));
d176 1
a176 1
		bzero(&crin, sizeof(crin));
d681 1
a681 1
		    !bcmp(&tdbi->dst, &tdb->tdb_dst,
d1012 1
a1012 1
			bzero (&hdr, sizeof(hdr));
@


1.106
log
@Remove the extern keyword from function declarations, document
sysctl declarations, move variables and functions used in only
one place in their corresponding file. No functional change.

No objection from markus@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.105 2013/02/14 16:22:34 mikeb Exp $ */
d503 1
a503 1
					ovbcopy(&addr[0], &addr[1],
@


1.105
log
@Merge of an original work by markus@@ and gerhard@@ to increase
the anti-replay window size to 2100 entries; plus small ESN
related improvements.  ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.104 2012/10/18 10:49:48 markus Exp $ */
d84 4
d89 3
@


1.104
log
@simplify checkreplaywindow() API; make call/return code handling consistent
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.103 2012/09/26 14:53:23 markus Exp $ */
a151 1
	tdbp->tdb_bitmap = 0;
@


1.103
log
@add M_ZEROIZE as an mbuf flag, so copied PFKEY messages (with embedded keys)
are cleared as well; from hshoexer@@, feedback and ok bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.102 2012/09/20 10:25:03 blambert Exp $ */
d571 1
a571 2
		switch (checkreplaywindow(btsx, &tdb->tdb_rpl, tdb->tdb_wnd,
		    &tdb->tdb_bitmap, &esn, tdb->tdb_flags & TDBF_ESN, 0)) {
a573 1

d575 1
a578 1

d580 2
d583 4
a587 2

		case 2:
d589 1
a592 1

a593 1
			m_freem(m);
a594 1

d596 1
d600 1
a600 2

			m_freem(m);
d855 1
a855 2
		switch (checkreplaywindow(btsx, &tdb->tdb_rpl, tdb->tdb_wnd,
		    &tdb->tdb_bitmap, &esn, tdb->tdb_flags & TDBF_ESN, 1)) {
a860 1

a864 1

a867 1

d869 6
a878 1

a881 1

d886 1
a886 1

@


1.102
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.101 2012/09/18 09:24:45 markus Exp $ */
d1010 1
a1010 1
			hdr.flags |= M_AUTH | M_AUTH_AH;
@


1.101
log
@remove the SADB_X_SAFLAGS_{HALFIV,RANDOMPADDING,NOREPLAY} pfkey-API (not set
anywhere) as well as the matching TDBF_{HALFIV,RANDOMPADDING,NOREPLAY} code.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.100 2012/06/29 14:48:04 mikeb Exp $ */
d779 1
a779 1
	s = spltdb();
d1302 1
a1302 1
	s = spltdb();
@


1.100
log
@Add support for the Extended (64-bit) Sequence Number as defined
in RFC4302 and RFC4303.  Right now only software crypto engine is
capable of doing it.

Replay check was rewritten to implement algorithm described in the
Appendix A of RFC4303 and the window size was increased to 64.

Tested against OpenBSD, Linux (strongswan) and Windows.

No objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.99 2011/01/11 15:42:05 deraadt Exp $ */
d169 1
a169 2
	if ((tdbp->tdb_wnd > 0) && !(tdbp->tdb_flags & TDBF_NOREPLAY) &&
	    (tdbp->tdb_flags & TDBF_ESN)) {
d559 1
a559 4
	if (!(tdb->tdb_flags & TDBF_NOREPLAY))
		rplen = AH_FLENGTH + sizeof(u_int32_t);
	else
		rplen = AH_FLENGTH;
d566 1
a566 1
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
d658 1
a658 2
	if ((tdb->tdb_wnd > 0) && !(tdb->tdb_flags & TDBF_NOREPLAY) &&
	    (tdb->tdb_flags & TDBF_ESN)) {
d811 1
a811 4
	if (!(tdb->tdb_flags & TDBF_NOREPLAY))
		rplen = AH_FLENGTH + sizeof(u_int32_t);
	else
		rplen = AH_FLENGTH;
d850 1
a850 1
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
d1024 1
a1024 2
	if ((tdb->tdb_rpl == 0) && (tdb->tdb_wnd > 0) &&
	    (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
d1032 1
a1032 4
	if (!(tdb->tdb_flags & TDBF_NOREPLAY))
		rplen = AH_FLENGTH + sizeof(u_int32_t);
	else
		rplen = AH_FLENGTH;
d1148 2
a1149 3
	if (!(tdb->tdb_flags & TDBF_NOREPLAY)) {
		tdb->tdb_rpl++;
		ah->ah_rpl = htonl((u_int32_t)(tdb->tdb_rpl & 0xffffffff));
d1151 1
a1151 1
		pfsync_update_tdb(tdb,1);
a1152 1
	}
d1175 1
a1175 2
	if ((tdb->tdb_wnd > 0) && !(tdb->tdb_flags & TDBF_NOREPLAY) &&
	    (tdb->tdb_flags & TDBF_ESN)) {
@


1.99
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.98 2010/07/20 15:36:03 matthew Exp $ */
d102 1
a102 1
	struct cryptoini cria;
d169 7
d553 1
a553 1
	u_int32_t btsx;
d575 2
a576 2
		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 0)) {
d595 1
d601 1
a601 1
			    "checkreplaywindow32() in SA %s/%08x\n",
a603 1
			ahstat.ahs_replay++;
d662 7
d762 1
a762 1
	u_int32_t btsx;
d863 2
a864 2
		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 1)) {
d886 1
d892 1
a892 1
			    "checkreplaywindow32() in SA %s/%08x\n",
a894 1
			ahstat.ahs_replay++;
d1161 2
a1162 1
		ah->ah_rpl = htonl(tdb->tdb_rpl++);
d1188 9
@


1.98
log
@Switch some obvious network stack MAC comparisons from bcmp() to
timingsafe_bcmp().

ok deraadt@@; committed over WPA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.97 2010/07/09 16:58:06 reyk Exp $ */
d181 1
a181 1
		bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
@


1.97
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.96 2010/07/02 02:40:16 blambert Exp $ */
d818 1
a818 1
		if (bcmp(ptr + skip + rplen, calc, ahx->authsize)) {
@


1.96
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.95 2010/07/01 02:09:45 reyk Exp $ */
d665 1
d725 1
d772 1
a772 1
	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
d993 1
a993 1
	if ((encif = enc_getif(0, tdb->tdb_tap)) != NULL) {
d1254 1
d1295 1
a1295 1
	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
@


1.95
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.94 2010/06/29 21:28:37 reyk Exp $ */
d372 1
a372 1
		m_copyback(m, 0, sizeof(struct ip6_hdr), &ip6);
d499 2
a500 1
					m_copyback(m, 0, sizeof(ip6), &ip6);
d525 1
a525 1
			    skip - sizeof(struct ip6_hdr), ptr);
d697 2
a698 1
		m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes);
d832 1
a832 1
		m_copyback(m, 0, skip, ptr);
d836 1
a836 1
		m_copyback(m, protoff, sizeof(u_int8_t), &prot);
d1142 1
a1142 1
	m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes);
d1202 1
a1202 1
			    sizeof(u_int16_t), &iplen);
d1213 1
a1213 1
			    sizeof(u_int16_t), &iplen);
d1223 1
a1223 1
		m_copyback(m, protoff, sizeof(u_int8_t), &prot);
d1236 1
a1236 1
		m_copyback(m, protoff, sizeof(u_int8_t), &prot);
d1322 1
a1322 1
		m_copyback(m, 0, skip, ptr);
@


1.94
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.93 2010/01/10 12:43:07 markus Exp $ */
d989 1
a989 1
	if ((encif = enc_getif(0)) != NULL) {
@


1.93
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.92 2008/09/15 21:46:01 chl Exp $ */
d987 1
a987 1
	struct ifnet *ifn = &(encif[0].sc_if);
d989 3
a991 2
	ifn->if_opackets++;
	ifn->if_obytes += m->m_pkthdr.len;
d993 2
a994 2
	if (ifn->if_bpf) {
		struct enchdr hdr;
d996 1
a996 1
		bzero (&hdr, sizeof(hdr));
d998 3
a1000 3
		hdr.af = tdb->tdb_dst.sa.sa_family;
		hdr.spi = tdb->tdb_spi;
		hdr.flags |= M_AUTH | M_AUTH_AH;
d1002 3
a1004 2
		bpf_mtap_hdr(ifn->if_bpf, (char *)&hdr, ENC_HDRLEN, m,
		    BPF_DIRECTION_OUT);
@


1.92
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok mpf@@ looks good mk@@ ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.91 2007/10/17 20:01:26 hshoexer Exp $ */
d119 1
a119 1
		thash = &auth_hash_hmac_sha2_256_96;
d123 1
a123 1
		thash = &auth_hash_hmac_sha2_384_96;
d127 1
a127 1
		thash = &auth_hash_hmac_sha2_512_96;
@


1.91
log
@Convert MALLOC/FREE to malloc/free.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.90 2007/10/09 01:30:47 krw Exp $ */
a738 1
	struct cryptodesc *crd;
a748 1
	crd = crp->crp_desc;
d1262 1
a1262 1
	int skip, protoff, error;
a1272 1
	protoff = tc->tc_protoff;
@


1.90
log
@MALLOC+bzero -> malloc+M_ZERO. Don't forget FREE->free this time.

'Fixes' two cases where the zeroing did not cover all the memory
allocated.

As with many of the last commits, looked at by chl@@ in an earlier
version.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.89 2007/02/14 00:53:48 jsg Exp $ */
d159 1
a159 2
	MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
	    M_WAITOK);
d182 1
a182 1
		FREE(tdbp->tdb_amxkey, M_XDATA);
d377 1
a377 2
				MALLOC(ptr, unsigned char *,
				    skip - sizeof(struct ip6_hdr),
d430 1
a430 1
							FREE(ptr, M_XDATA);
d451 1
a451 1
							FREE(ptr, M_XDATA);
d514 1
a514 1
					FREE(ptr, M_XDATA);
d525 1
a525 1
			FREE(ptr, M_XDATA);
@


1.89
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.88 2007/02/08 15:25:30 itojun Exp $ */
d676 2
a677 3
		MALLOC(tc, struct tdb_crypto *,
		    sizeof(struct tdb_crypto) + skip +
		    rplen + ahx->authsize, M_XDATA, M_NOWAIT);
d679 1
a679 2
		MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
		    M_XDATA, M_NOWAIT);
a687 2
	bzero(tc, sizeof(struct tdb_crypto));

d704 1
a704 1
			FREE(tc, M_XDATA);
d762 1
a762 1
		FREE(tc, M_XDATA);
d774 1
a774 1
		FREE(tc, M_XDATA);
d792 1
a792 1
		FREE(tc, M_XDATA);
d819 1
a819 1
			FREE(tc, M_XDATA);
d841 1
a841 1
	FREE(tc, M_XDATA);
d1174 1
a1174 2
		MALLOC(tc, struct tdb_crypto *,
		    sizeof(struct tdb_crypto) + skip, M_XDATA, M_NOWAIT);
d1176 1
a1176 2
		MALLOC(tc, struct tdb_crypto *,
		    sizeof(struct tdb_crypto), M_XDATA, M_NOWAIT);
a1184 2
	bzero(tc, sizeof(struct tdb_crypto));

d1229 1
a1229 1
			FREE(tc, M_XDATA);
d1283 1
a1283 1
		FREE(tc, M_XDATA);
d1295 1
a1295 1
		FREE(tc, M_XDATA);
d1311 1
a1311 1
		FREE(tc, M_XDATA);
d1325 1
a1325 1
	FREE(tc, M_XDATA);
@


1.88
log
@- AH: when computing crypto checksum for output, massage source-routing
  header.
- ipsec_input: fix mistake in IPv6 next-header chasing.
- ipsec_output: look for the position to insert AH more carefully.
- ip6_output: enable use of AH with extension headers.
  avoid tunnellinng when source-routing header is present.

ok by deraad, naddy, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.87 2006/12/15 09:32:30 otto Exp $ */
d314 1
a314 1
				/* Fall through */
@


1.87
log
@make enc(4) count; ok markus@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.86 2006/12/13 09:01:59 itojun Exp $ */
d209 1
a209 1
	int alloc, len, ad;
d404 1
a404 1
		off = ip6.ip6_nxt & 0xff; /* Next header type. */
d406 2
a407 2
		for (len = 0; len < skip - sizeof(struct ip6_hdr);)
			switch (off) {
d410 1
a410 1
				ip6e = (struct ip6_ext *) (ptr + len);
d417 2
a418 2
				for (count = len + sizeof(struct ip6_ext);
				     count < len + ((ip6e->ip6e_len + 1) << 3);) {
d425 1
a425 1
					if (count > len +
d459 2
a460 2
				len += ((ip6e->ip6e_len + 1) << 3);
				off = ip6e->ip6e_nxt;
d468 41
a508 3
				ip6e = (struct ip6_ext *) (ptr + len);
				len += ((ip6e->ip6e_len + 1) << 3);
				off = ip6e->ip6e_nxt;
d510 1
d521 1
@


1.86
log
@use IN6_IS_SCOPE_EMBED to check kernel-internal form addresses
(s6_addr16[1] filled)
ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.85 2006/05/28 02:04:15 mcbride Exp $ */
d956 3
@


1.85
log
@Only preemptively increase the replay counter for outbound TDBs.

Another ipsec failover fix from nathanael at polymorpheus dot com.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.84 2006/03/25 22:41:48 djm Exp $ */
d367 1
a367 1
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6.ip6_src))
d369 1
a369 1
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6.ip6_dst))
@


1.84
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.83 2005/12/20 13:36:28 markus Exp $ */
d817 1
a817 1
			pfsync_update_tdb(tdb);
d1108 1
a1108 1
		pfsync_update_tdb(tdb);
@


1.83
log
@use M_READONLY when trying to find out whether we have to copy
the mbuf before encryption.  otherwise mbufs with M_EXT but w/o M_CLUSTER
get modified; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.82 2005/07/31 03:52:19 pascoe Exp $ */
d966 2
a967 1
		bpf_mtap_hdr(ifn->if_bpf, (char *)&hdr, ENC_HDRLEN, m);
@


1.82
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.81 2005/05/28 15:10:07 ho Exp $ */
d1049 2
a1050 2
	 * Loop through mbuf chain; if we find an M_EXT mbuf with
	 * more than one reference, replace the rest of the chain.
d1054 1
a1054 2
	while (mi != NULL &&
	    (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi))) {
@


1.81
log
@Add SA replay counter synchronization to pfsync(4). Required for IPsec
failover gateways. ok mcbride@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.80 2005/05/27 18:23:18 markus Exp $ */
d954 2
d957 1
a957 3
#if NBPFILTER > 0
	{
		struct ifnet *ifn;
a958 1
		struct mbuf m1;
d966 1
a966 9
		m1.m_flags = 0;
		m1.m_next = m;
		m1.m_len = ENC_HDRLEN;
		m1.m_data = (char *) &hdr;

		ifn = &(encif[0].sc_if);

		if (ifn->if_bpf)
			bpf_mtap(ifn->if_bpf, &m1);
@


1.80
log
@comment out unused PACKET_TAG_IPSEC_IN_CRYPTO_DONE code; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.79 2003/08/14 19:00:12 jason Exp $ */
d39 2
d53 1
d68 5
d816 3
d1114 1
a1114 1
	if (!(tdb->tdb_flags & TDBF_NOREPLAY))
d1116 4
@


1.79
log
@m_copyback()'s 4th arg is const void *, nuke (caddr_t) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.78 2003/07/24 09:59:02 itojun Exp $ */
a496 1
	struct tdb_ident *tdbi;
d608 1
d613 2
d622 3
@


1.78
log
@conform to RFC2367 on SADB_xx naming (local name must be prefixed with
SADB_X_xx)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.77 2003/07/24 08:03:19 itojun Exp $ */
d365 1
a365 1
		m_copyback(m, 0, sizeof(struct ip6_hdr), (caddr_t) &ip6);
d1156 1
a1156 1
			    sizeof(u_int16_t), (caddr_t) &iplen);
d1167 1
a1167 1
			    sizeof(u_int16_t), (caddr_t) &iplen);
d1177 1
a1177 1
		m_copyback(m, protoff, sizeof(u_int8_t), (caddr_t) &prot);
d1190 1
a1190 1
		m_copyback(m, protoff, sizeof(u_int8_t), (caddr_t) &prot);
@


1.77
log
@hmac-sha2-{256,384,512} support in AH/ESP auth.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.76 2003/07/09 22:03:16 itojun Exp $ */
d106 1
a106 1
	case SADB_AALG_RIPEMD160HMAC:
d110 1
a110 1
	case SADB_AALG_SHA2_256:
d114 1
a114 1
	case SADB_AALG_SHA2_384:
d118 1
a118 1
	case SADB_AALG_SHA2_512:
@


1.76
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.75 2003/05/03 01:43:07 itojun Exp $ */
d108 12
@


1.75
log
@just as a safety measure, set m_flags to 0 for mbufs allocated on stack.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.74 2003/04/02 20:09:26 millert Exp $ */
d217 4
a220 14
		if (!out) {
			ip->ip_len += skip;
			HTONS(ip->ip_len);

			if (alg == CRYPTO_MD5_KPDK || alg == CRYPTO_SHA1_KPDK)
				ip->ip_off = htons(ip->ip_off & IP_DF);
			else
				ip->ip_off = 0;
		} else {
			if (alg == CRYPTO_MD5_KPDK || alg == CRYPTO_SHA1_KPDK)
				ip->ip_off = htons(ntohs(ip->ip_off) & IP_DF);
			else
				ip->ip_off = 0;
		}
@


1.74
log
@o sanity check mbuf earlier.
o return errno, not NULL.
o add some missing error values
o proper crypto_freereq() in ip_ipcomp.c
From Patrick Latifi; OK angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.73 2003/03/31 20:52:06 millert Exp $ */
d949 1
@


1.73
log
@Avoid using FREEd data when we get a crypto error; Patrick Latifi
Also move the session ID reset into the crp_etype == EAGAIN case
(noticed by angelos@@).  OK jason@@ and angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.72 2003/02/28 21:42:56 jason Exp $ */
d707 1
d709 9
a750 10
	/* Shouldn't happen... */
	if (m == NULL) {
		FREE(tc, M_XDATA);
		ahstat.ahs_crypto++;
		DPRINTF(("ah_input_cb(): bogus returned buffer from "
		    "crypto\n"));
		error = EINVAL;
		goto baddone;
	}

d972 1
a972 1
		return NULL;
d1230 1
d1232 9
a1265 10
		goto baddone;
	}

	/* Shouldn't happen... */
	if (m == NULL) {
		FREE(tc, M_XDATA);
		ahstat.ahs_crypto++;
		DPRINTF(("ah_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		error = EINVAL;
@


1.72
log
@Based on several comments from tedu:
- two variables 'err' and 'error', whacked
- missing initialization in the error path for the case where an SA expired
  while off in crypto land.
- a small bit of knf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.71 2003/02/12 14:41:07 jason Exp $ */
a723 5
		FREE(tc, M_XDATA);

		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;

d725 3
d731 1
a731 1

a1244 3
		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;

d1246 3
a1251 1

@


1.71
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.70 2002/07/05 23:20:53 angelos Exp $ */
d687 1
a687 1
	int roff, rplen, error, skip, protoff;
a698 1
	int s, err;
d716 1
d906 1
a906 1
	err = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
d908 1
a908 1
	return err;
d919 1
a919 1
	return error;
d1241 1
@


1.70
log
@Free crp_opaque only after we've determined we're not going to
re-submit it. From sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.69 2002/06/26 00:13:47 angelos Exp $ */
d75 2
@


1.69
log
@Update correct statistic if m_inject() fails --- from sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.68 2002/06/18 23:03:26 angelos Exp $ */
a1243 2
		FREE(tc, M_XDATA);

d1252 1
@


1.68
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.67 2002/06/18 22:48:16 angelos Exp $ */
d1076 1
a1076 1
		ahstat.ahs_wrap++;
@


1.67
log
@Initialize mo to NULL, for good measure -- sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.66 2002/06/18 19:21:48 angelos Exp $ */
d579 1
a579 2
	    tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
	{
@


1.66
log
@Fix reference to free'ed location (unreachable condition because of
spl protection, but better safe...) --- pointed out by sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.65 2002/06/09 00:58:32 angelos Exp $ */
d1043 1
@


1.65
log
@Set/clear M_AUTH_AH.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.64 2002/05/31 02:22:21 angelos Exp $ */
d723 2
a729 1
			FREE(tc, M_XDATA);
a732 1
		FREE(tc, M_XDATA);
a1234 2

	FREE(tc, M_XDATA);
d1236 1
d1244 2
d1262 1
d1276 2
@


1.64
log
@Fix a DoS attack whereby an attacker could cause the replay counter to
advance with unauthenticated packets, thereby causing valid packets to
be discarded as replays. This has been sitting in my tree for a while,
and I've forgotten who it was that pointed out the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.63 2001/06/26 06:18:58 angelos Exp $ */
d948 1
a948 1
		hdr.flags |= M_AUTH;
@


1.63
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.62 2001/06/25 05:11:58 angelos Exp $ */
d519 1
a519 1
		    tdb->tdb_wnd, &(tdb->tdb_bitmap))) {
a537 1
			ahstat.ahs_replay++;
d695 1
a711 1
	FREE(tc, M_XDATA);
d713 1
d728 1
d732 1
d744 1
d769 2
d789 42
@


1.63.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.63 2001/06/26 06:18:58 angelos Exp $ */
d519 1
a519 1
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 0)) {
d538 1
a695 1
	u_int32_t btsx;
d712 1
a713 1
		FREE(tc, M_XDATA);
a727 1
			FREE(tc, M_XDATA);
a730 1
		FREE(tc, M_XDATA);
a741 1
		FREE(tc, M_XDATA);
a765 2
			FREE(tc, M_XDATA);

a785 42
	FREE(tc, M_XDATA);

	/* Replay window checking, if applicable. */
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
		m_copydata(m, skip + offsetof(struct ah, ah_rpl),
		    sizeof(u_int32_t), (caddr_t) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 1)) {
		case 0: /* All's well. */
			break;

		case 1:
			DPRINTF(("ah_input(): replay counter wrapped for "
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));

			ahstat.ahs_wrap++;
			error = ENOBUFS;
			goto baddone;

		case 2:
		case 3:
			DPRINTF(("ah_input_cb(): duplicate packet received in "
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));

			error = ENOBUFS;
			goto baddone;

		default:
			DPRINTF(("ah_input_cb(): bogus value from "
			    "checkreplaywindow32() in SA %s/%08x\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));

			ahstat.ahs_replay++;
			error = ENOBUFS;
			goto baddone;
		}
	}

d901 1
a901 1
		hdr.flags |= M_AUTH | M_AUTH_AH;
@


1.63.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.63.4.1 2002/06/11 03:31:36 art Exp $ */
d579 2
a580 1
	    tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes) {
a722 2
		FREE(tc, M_XDATA);

d728 1
d732 1
a1042 1
	mo = NULL;
d1076 1
a1076 1
		ahstat.ahs_hdrops++;
d1235 2
a1237 1
		FREE(tc, M_XDATA);
a1252 1
		FREE(tc, M_XDATA);
a1260 1
		FREE(tc, M_XDATA);
a1273 2

	FREE(tc, M_XDATA);
@


1.63.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a75 2
struct ahstat ahstat;

d685 1
a685 1
	int s, roff, rplen, error, skip, protoff;
d697 1
a705 1

a706 9
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		ahstat.ahs_crypto++;
		DPRINTF(("ah_input_cb(): bogus returned buffer from "
		    "crypto\n"));
		return (EINVAL);
	}
a714 1
		error = EPERM;
d722 5
a727 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d731 1
a731 1
		FREE(tc, M_XDATA);
d741 10
d904 1
a904 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
d906 1
a906 1
	return (error);
d917 1
a917 1
	return (error);
a948 1
		m1.m_flags = 0;
d972 1
a972 1
		return EINVAL;
a1229 1

a1230 9
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		ahstat.ahs_crypto++;
		DPRINTF(("ah_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		return (EINVAL);
	}
a1238 1
		error = EPERM;
d1244 3
a1247 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d1251 1
d1256 10
@


1.62
log
@Copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.61 2001/06/23 18:30:38 deraadt Exp $ */
d77 1
a77 1
 * ah_attach() is called from the transformation initialization code
d82 1
a82 1
    return 0;
d91 2
a92 2
    struct auth_hash *thash = NULL;
    struct cryptoini cria;
d94 2
a95 3
    /* Authentication operation */
    switch (ii->ii_authalg)
    {
d97 2
a98 2
	    thash = &auth_hash_hmac_md5_96;
	    break;
d101 2
a102 2
	    thash = &auth_hash_hmac_sha1_96;
	    break;
d105 2
a106 2
	    thash = &auth_hash_hmac_ripemd_160_96;
	    break;
d109 2
a110 2
	    thash = &auth_hash_key_md5;
	    break;
d113 2
a114 2
	    thash = &auth_hash_key_sha1;
	    break;
d117 30
a146 29
	    DPRINTF(("ah_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
	    return EINVAL;
    }

    if ((ii->ii_authkeylen != thash->keysize) && (thash->keysize != 0))
    {
	DPRINTF(("ah_init(): keylength %d doesn't match algorithm %s keysize (%d)\n", ii->ii_authkeylen, thash->name, thash->keysize));
	return EINVAL;
    }

    tdbp->tdb_xform = xsp;
    tdbp->tdb_authalgxform = thash;
    tdbp->tdb_bitmap = 0;
    tdbp->tdb_rpl = AH_HMAC_INITIAL_RPL;

    DPRINTF(("ah_init(): initialized TDB with hash algorithm %s\n",
	     thash->name));

    tdbp->tdb_amxkeylen = ii->ii_authkeylen;
    MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
	   M_WAITOK);

    bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);

    /* Initialize crypto session */
    bzero(&cria, sizeof(cria));
    cria.cri_alg = tdbp->tdb_authalgxform->type;
    cria.cri_klen = ii->ii_authkeylen * 8;
    cria.cri_key = ii->ii_authkey;
d148 1
a148 1
    return crypto_newsession(&tdbp->tdb_cryptoid, &cria, 0);
d157 7
a163 1
    int err;
d165 3
a167 10
    if (tdbp->tdb_amxkey)
    {
	bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
	FREE(tdbp->tdb_amxkey, M_XDATA);
	tdbp->tdb_amxkey = NULL;
    }

    err = crypto_freesession(tdbp->tdb_cryptoid);
    tdbp->tdb_cryptoid = 0;
    return err;
d176 3
a178 3
    struct mbuf *m = *m0;
    unsigned char *ptr;
    int off, count;
d181 1
a181 1
    struct ip *ip;
d185 3
a187 3
    struct ip6_ext *ip6e;
    struct ip6_hdr ip6;
    int alloc, len, ad;
d190 1
a190 2
    switch (proto)
    {
d193 11
a203 12
	    /*
	     * This is the least painful way of dealing with IPv4 header
	     * and option processing -- just make sure they're in
	     * contiguous memory.
	     */
	    *m0 = m = m_pullup(m, skip);
	    if (m == NULL)
	    {
		DPRINTF(("ah_massage_headers(): m_pullup() failed\n"));
		ahstat.ahs_hdrops++;
		return ENOBUFS;
	    }
d205 23
a227 42
	    /* Fix the IP header */
	    ip = mtod(m, struct ip *);
	    ip->ip_tos = 0;
	    ip->ip_ttl = 0;
	    ip->ip_sum = 0;

	    /*
	     * On input, fix ip_len which has been byte-swapped
	     * at ip_input()
	     */
	    if (!out)
	    {
		ip->ip_len += skip;
		HTONS(ip->ip_len);

	        if ((alg == CRYPTO_MD5_KPDK) || (alg == CRYPTO_SHA1_KPDK))
	          ip->ip_off = htons(ip->ip_off & IP_DF);
	        else
	          ip->ip_off = 0;
	    }
            else
            {
	        if ((alg == CRYPTO_MD5_KPDK) || (alg == CRYPTO_SHA1_KPDK))
	          ip->ip_off = htons(ntohs(ip->ip_off) & IP_DF);
	        else
	          ip->ip_off = 0;
            }

	    ptr = mtod(m, unsigned char *) + sizeof(struct ip);

	    /* IPv4 option processing */
	    for (off = sizeof(struct ip); off < skip;)
	    {
		if (ptr[off] == IPOPT_EOL || ptr[off] == IPOPT_NOP ||
		    off + 1 < skip)
		    ;
		else
		{
		    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
		    ahstat.ahs_hdrops++;
		    m_freem(m);
		    return EINVAL;
d230 1
a230 5
		switch (ptr[off])
		{
		    case IPOPT_EOL:
			off = skip;  /* End the loop */
			break;
d232 13
a244 16
		    case IPOPT_NOP:
			off++;
			break;

		    case IPOPT_SECURITY:	/* 0x82 */
		    case 0x85:	/* Extended security */
		    case 0x86:	/* Commercial security */
		    case 0x94:	/* Router alert */
		    case 0x95:	/* RFC1770 */
			/* Sanity check for option length */
			if (ptr[off + 1] < 2)
			{
			    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
			    ahstat.ahs_hdrops++;
			    m_freem(m);
			    return EINVAL;
d247 72
a318 12
			off += ptr[off + 1];
			break;

		    case IPOPT_LSRR:
		    case IPOPT_SSRR:
			/* Sanity check for option length */
			if (ptr[off + 1] < 2)
			{
			    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
			    ahstat.ahs_hdrops++;
			    m_freem(m);
			    return EINVAL;
d321 8
a328 21
			/*
			 * On output, if we have either of the source routing
			 * options, we should swap the destination address of
			 * the IP header with the last address specified in
			 * the option, as that is what the destination's
			 * IP header will look like.
			 */
			if (out)
			  bcopy(ptr + off + ptr[off + 1] -
				sizeof(struct in_addr),
				&(ip->ip_dst), sizeof(struct in_addr));

			/* Fall through */
		    default:
			/* Sanity check for option length */
			if (ptr[off + 1] < 2)
			{
			    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
			    ahstat.ahs_hdrops++;
			    m_freem(m);
			    return EINVAL;
a329 6

			/* Zeroize all other options */
			count = ptr[off + 1];
			bcopy(ipseczeroes, ptr, count);
			off += count;
			break;
d332 1
a332 11
		/* Sanity check */
		if (off > skip)
		{
		    DPRINTF(("ah_massage_headers(): malformed IPv4 options header\n"));
		    ahstat.ahs_hdrops++;
		    m_freem(m);
		    return EINVAL;
		}
	    }

	    break;
d337 2
a338 2
	    /* Copy and "cook" the IPv6 header */
	    m_copydata(m, 0, sizeof(ip6), (caddr_t) &ip6);
d340 4
a343 33
	    /* We don't do IPv6 Jumbograms */
	    if (ip6.ip6_plen == 0)
	    {
		DPRINTF(("ah_massage_headers(): unsupported IPv6 jumbogram"));
		ahstat.ahs_hdrops++;
		m_freem(m);
		return EMSGSIZE;
	    }

	    ip6.ip6_flow = 0;
	    ip6.ip6_hlim = 0;
	    ip6.ip6_vfc &= ~IPV6_VERSION_MASK;
	    ip6.ip6_vfc |= IPV6_VERSION;

	    /* scoped address handling */
	    if (IN6_IS_SCOPE_LINKLOCAL(&ip6.ip6_src))
		ip6.ip6_src.s6_addr16[1] = 0;
	    if (IN6_IS_SCOPE_LINKLOCAL(&ip6.ip6_dst))
		ip6.ip6_dst.s6_addr16[1] = 0;

	    /* Done with IPv6 header */
	    m_copyback(m, 0, sizeof(struct ip6_hdr), (caddr_t) &ip6);

	    /* Let's deal with the remaining headers (if any) */
	    if (skip - sizeof(struct ip6_hdr) > 0)
	    {
		if (m->m_len <= skip)
		{
		    MALLOC(ptr, unsigned char *, skip - sizeof(struct ip6_hdr),
			   M_XDATA, M_NOWAIT);
		    if (ptr == NULL)
		    {
			DPRINTF(("ah_massage_headers(): failed to allocate memory for IPv6 headers\n"));
d346 124
a469 2
			return ENOBUFS;
		    }
d471 5
a475 4
		    /* Copy all the protocol headers after the IPv6 header */
		    m_copydata(m, sizeof(struct ip6_hdr),
			       skip - sizeof(struct ip6_hdr), ptr);
		    alloc = 1;
a476 96
		else
		{
		    /* No need to allocate memory */
		    ptr = mtod(m, unsigned char *) + sizeof(struct ip6_hdr);
		    alloc = 0;
		}
	    }
	    else
	      break;

	    off = ip6.ip6_nxt & 0xff; /* Next header type */

	    for (len = 0; len < skip - sizeof(struct ip6_hdr);)
	      switch (off)
	      {
		  case IPPROTO_HOPOPTS:
		  case IPPROTO_DSTOPTS:
		      ip6e = (struct ip6_ext *) (ptr + len);

		      /*
		       * Process the mutable/immutable options -- borrows
		       * heavily from the KAME code.
		       */
		      for (count = len + sizeof(struct ip6_ext);
			   count < len + ((ip6e->ip6e_len + 1) << 3);)
		      {
			  if (ptr[count] == IP6OPT_PAD1)
			  {
			      count++;
			      continue; /* Skip padding */
			  }

			  /* Sanity check */
			  if (count > len + ((ip6e->ip6e_len + 1) << 3))
			  {
			      DPRINTF(("ah_massage_headers(): malformed IPv6 options header\n"));
			      ahstat.ahs_hdrops++;
			      m_freem(m);

			      /* Free, if we allocated */
			      if (alloc)
				FREE(ptr, M_XDATA);

			      return EINVAL;
			  }

			  ad = ptr[count + 1];

			  /* If mutable option, zeroize */
			  if (ptr[count] & IP6OPT_MUTABLE)
			    bcopy(ipseczeroes, ptr + count, ptr[count + 1]);

			  count += ad;

			  /* Sanity check */
			  if (count > skip - sizeof(struct ip6_hdr))
			  {
			      DPRINTF(("ah_massage_headers(): malformed IPv6 options header\n"));
			      ahstat.ahs_hdrops++;
			      m_freem(m);

			      /* Free, if we allocated */
			      if (alloc)
				FREE(ptr, M_XDATA);

			      return EINVAL;
			  }
		      }

		      len += ((ip6e->ip6e_len + 1) << 3); /* Advance */
		      off = ip6e->ip6e_nxt;
		      break;

		  case IPPROTO_ROUTING:
		      /* Always include routing headers in computation */
		      ip6e = (struct ip6_ext *) (ptr + len);
		      len += ((ip6e->ip6e_len + 1) << 3); /* Advance */
		      off = ip6e->ip6e_nxt;
		      break;

		  default:
		      DPRINTF(("ah_massage_headers(): unexpected IPv6 header type %d\n", off));
		      if (alloc)
			FREE(ptr, M_XDATA);
		      ahstat.ahs_hdrops++;
		      m_freem(m);
		      return EINVAL;
	      }

	    /* Copyback and free, if we allocated */
	    if (alloc)
	    {
		m_copyback(m, sizeof(struct ip6_hdr),
			   skip - sizeof(struct ip6_hdr), ptr);
		FREE(ptr, M_XDATA);
	    }
d478 1
a478 1
	    break;
d480 1
a480 1
    }
d482 1
a482 1
    return 0;
d492 85
a576 26
    struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    struct tdb_ident *tdbi;
    struct tdb_crypto *tc;
    struct m_tag *mtag;
    u_int32_t btsx;
    u_int8_t hl;
    int rplen;

    struct cryptodesc *crda = NULL;
    struct cryptop *crp;

    if (!(tdb->tdb_flags & TDBF_NOREPLAY))
      rplen = AH_FLENGTH + sizeof(u_int32_t);
    else
      rplen = AH_FLENGTH;

    /* Save the AH header, we use it throughout */
    m_copydata(m, skip + offsetof(struct ah, ah_hl), sizeof(u_int8_t),
	       (caddr_t) &hl);

    /* Replay window checking, if applicable */
    if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY)))
    {
	m_copydata(m, skip + offsetof(struct ah, ah_rpl), sizeof(u_int32_t),
		   (caddr_t) &btsx);
	btsx = ntohl(btsx);
d578 3
a580 2
	switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
				    tdb->tdb_wnd, &(tdb->tdb_bitmap)))
d582 3
a584 2
	    case 0: /* All's well */
		break;
d586 3
a588 3
	    case 1:
		DPRINTF(("ah_input(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_wrap++;
d590 3
d594 1
d596 32
a627 4
	    case 2:
	    case 3:
		DPRINTF(("ah_input(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_replay++;
d629 3
d633 1
d635 1
a635 97
	    default:
                DPRINTF(("ah_input(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_replay++;
                m_freem(m);
                return ENOBUFS;
	}
    }

    /* Verify AH header length */
    if (hl * sizeof(u_int32_t) != ahx->authsize + rplen - AH_FLENGTH)
    {
	DPRINTF(("ah_input(): bad authenticator length %d for packet in SA %s/%08x\n", hl * sizeof(u_int32_t), ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_badauthl++;
	m_freem(m);
	return EACCES;
    }

    /* Update the counters */
    tdb->tdb_cur_bytes += (m->m_pkthdr.len - skip - hl * sizeof(u_int32_t));
    ahstat.ahs_ibytes += (m->m_pkthdr.len - skip - hl * sizeof(u_int32_t));

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	  tdb_delete(tdb);
	  m_freem(m);
	  return ENXIO;
      }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;     /* Turn off checking */
    }

    /* Get crypto descriptors */
    crp = crypto_getreq(1);
    if (crp == NULL)
    {
	m_freem(m);
	DPRINTF(("ah_input(): failed to acquire crypto descriptors\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }

    crda = crp->crp_desc;

    crda->crd_skip = 0;
    crda->crd_len = m->m_pkthdr.len;
    crda->crd_inject = skip + rplen;

    /* Authentication operation */
    crda->crd_alg = ahx->type;
    crda->crd_key = tdb->tdb_amxkey;
    crda->crd_klen = tdb->tdb_amxkeylen * 8;

    /* Find out if we've already done crypto */
    for (mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, NULL);
	 mtag != NULL;
	 mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, mtag))
    {
	tdbi = (struct tdb_ident *) (mtag + 1);
	if (tdbi->proto == tdb->tdb_sproto && tdbi->spi == tdb->tdb_spi &&
	    !bcmp(&tdbi->dst, &tdb->tdb_dst, sizeof(union sockaddr_union)))
	  break;
    }

    /* Allocate IPsec-specific opaque crypto info */
    if (mtag == NULL)
      MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto) + skip +
	     rplen + ahx->authsize, M_XDATA, M_NOWAIT);
    else /* Hash verification has already been done successfully */
      MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto), M_XDATA,
	     M_NOWAIT);
    if (tc == NULL)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("ah_input(): failed to allocate tdb_crypto\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }

    bzero(tc, sizeof(struct tdb_crypto));

    /* Only save information if crypto processing is needed */
    if (mtag == NULL)
    {
	/*
	 * Save the authenticator, the skipped portion of the packet,
	 * and the AH header.
	 */
	m_copydata(m, 0, skip + rplen + ahx->authsize, (caddr_t) (tc + 1));
d637 21
a657 2
	/* Zeroize the authenticator on the packet */
	m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes);
d659 20
a678 31
	/* "Massage" the packet headers for crypto processing */
	if ((btsx = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
				       skip, ahx->type, 0)) != 0)
	{
	    /* mbuf will be free'd by callee */
	    FREE(tc, M_XDATA);
	    crypto_freereq(crp);
	    return btsx;
	}
    }

    /* Crypto operation descriptor */
    crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
    crp->crp_flags = CRYPTO_F_IMBUF;
    crp->crp_buf = (caddr_t) m;
    crp->crp_callback = (int (*) (struct cryptop *)) ah_input_cb;
    crp->crp_sid = tdb->tdb_cryptoid;
    crp->crp_opaque = (caddr_t) tc;

    /* These are passed as-is to the callback */
    tc->tc_skip = skip;
    tc->tc_protoff = protoff;
    tc->tc_spi = tdb->tdb_spi;
    tc->tc_proto = tdb->tdb_sproto;
    tc->tc_ptr = (caddr_t) mtag; /* Save the mtag we've identified */
    bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

    if (mtag == NULL)
      return crypto_dispatch(crp);
    else
      return ah_input_cb(crp);
d687 170
a856 82
    int roff, rplen, error, skip, protoff;
    unsigned char calc[AH_ALEN_MAX];
    struct mbuf *m1, *m0, *m;
    struct cryptodesc *crd;
    struct auth_hash *ahx;
    struct tdb_crypto *tc;
    struct cryptop *crp;
    struct m_tag *mtag;
    struct tdb *tdb;
    u_int8_t prot;
    caddr_t ptr;
    int s, err;

    crp = (struct cryptop *) op;
    crd = crp->crp_desc;

    tc = (struct tdb_crypto *) crp->crp_opaque;
    skip = tc->tc_skip;
    protoff = tc->tc_protoff;
    mtag = (struct m_tag *) tc->tc_ptr;
    m = (struct mbuf *) crp->crp_buf;

    s = spltdb();

    tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
    FREE(tc, M_XDATA);
    if (tdb == NULL)
    {
	ahstat.ahs_notdb++;
	DPRINTF(("ah_input_cb(): TDB is expired while in crypto"));
	goto baddone;
    }

    ahx = (struct auth_hash *) tdb->tdb_authalgxform;

    /* Check for crypto errors */
    if (crp->crp_etype)
    {
        if (tdb->tdb_cryptoid != 0)
	  tdb->tdb_cryptoid = crp->crp_sid;

	if (crp->crp_etype == EAGAIN)
        {
            splx(s);
            return crypto_dispatch(crp);
        }

	ahstat.ahs_noxform++;
	DPRINTF(("ah_input_cb(): crypto error %d\n", crp->crp_etype));
	error = crp->crp_etype;
	goto baddone;
    }
    else
    {
	crypto_freereq(crp); /* No longer needed */
	crp = NULL;
    }

    /* Shouldn't happen... */
    if (m == NULL)
    {
	ahstat.ahs_crypto++;
	DPRINTF(("ah_input_cb(): bogus returned buffer from crypto\n"));
	error = EINVAL;
	goto baddone;
    }

    if (!(tdb->tdb_flags & TDBF_NOREPLAY))
      rplen = AH_FLENGTH + sizeof(u_int32_t);
    else
      rplen = AH_FLENGTH;

    /* Copy authenticator off the packet. */
    m_copydata(m, skip + rplen, ahx->authsize, calc);

    /*
     * If we have an mtag, we don't need to verify the authenticator --
     * it has been verified by an IPsec-aware NIC.
     */
    if (mtag == NULL)
    {
	ptr = (caddr_t) (tc + 1);
d858 3
a860 88
	/* Verify authenticator */
	if (bcmp(ptr + skip + rplen, calc, ahx->authsize))
	{
	    DPRINTF(("ah_input(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_badauth++;
	    error = EACCES;
	    goto baddone;
	}

	/* Fix the Next Protocol field */
	((u_int8_t *) ptr)[protoff] = ((u_int8_t *) ptr)[skip];

	/* Copyback the saved (uncooked) network headers */
	m_copyback(m, 0, skip, ptr);
    }
    else
    {
	/* Fix the Next Protocol field */
	m_copydata(m, skip, sizeof(u_int8_t), &prot);
	m_copyback(m, protoff, sizeof(u_int8_t), &prot);
    }

    /* Record the beginning of the AH header */
    m1 = m_getptr(m, skip, &roff);
    if (m1 == NULL)
    {
	ahstat.ahs_hdrops++;
        splx(s);
	DPRINTF(("ah_input(): bad mbuf chain for packet in SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	return EINVAL;
    }

    /* Remove the AH header from the mbuf */
    if (roff == 0)
    {
	/* The AH header was conveniently at the beginning of the mbuf */
	m_adj(m1, rplen + ahx->authsize);
	if (!(m1->m_flags & M_PKTHDR))
	  m->m_pkthdr.len -= rplen + ahx->authsize;
    }
    else
      if (roff + rplen + ahx->authsize >= m1->m_len)
      {
	  /*
	   * Part or all of the AH header is at the end of this mbuf, so first
	   * let's remove the remainder of the AH header from the
	   * beginning of the remainder of the mbuf chain, if any.
	   */
	  if (roff + rplen + ahx->authsize > m1->m_len)
	  {
	      /* Adjust the next mbuf by the remainder */
	      m_adj(m1->m_next, roff + rplen + ahx->authsize - m1->m_len);

	      /* The second mbuf is guaranteed not to have a pkthdr... */
	      m->m_pkthdr.len -= (roff + rplen + ahx->authsize - m1->m_len);
	  }

	  /* Now, let's unlink the mbuf chain for a second...*/
	  m0 = m1->m_next;
	  m1->m_next = NULL;

	  /* ...and trim the end of the first part of the chain...sick */
	  m_adj(m1, -(m1->m_len - roff));
	  if (!(m1->m_flags & M_PKTHDR))
	    m->m_pkthdr.len -= (m1->m_len - roff);

	  /* Finally, let's relink */
	  m1->m_next = m0;
      }
      else
      {
	  /*
	   * The AH header lies in the "middle" of the mbuf...do an
	   * overlapping copy of the remainder of the mbuf over the ESP
	   * header.
	   */
	  bcopy(mtod(m1, u_char *) + roff + rplen + ahx->authsize,
		mtod(m1, u_char *) + roff,
		m1->m_len - (roff + rplen + ahx->authsize));
	  m1->m_len -= rplen + ahx->authsize;
	  m->m_pkthdr.len -= rplen + ahx->authsize;
      }

    err = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
    splx(s);
    return err;
d863 1
a863 1
    splx(s);
d865 2
a866 2
    if (m != NULL)
      m_freem(m);
d868 2
a869 2
    if (crp != NULL)
      crypto_freereq(crp);
d871 1
a871 1
    return error;
d879 1
a879 1
	  int protoff)
d881 9
a889 9
    struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    struct cryptodesc *crda;
    struct tdb_crypto *tc;
    struct mbuf *mo, *mi;
    struct cryptop *crp;
    u_int16_t iplen;
    int len, rplen;
    u_int8_t prot;
    struct ah *ah;
d892 20
a911 20
    {
	struct ifnet *ifn;
	struct enchdr hdr;
	struct mbuf m1;

	bzero (&hdr, sizeof(hdr));

	hdr.af = tdb->tdb_dst.sa.sa_family;
	hdr.spi = tdb->tdb_spi;
	hdr.flags |= M_AUTH;

	m1.m_next = m;
	m1.m_len = ENC_HDRLEN;
	m1.m_data = (char *) &hdr;

	ifn = &(encif[0].sc_if);

	if (ifn->if_bpf)
	  bpf_mtap(ifn->if_bpf, &m1);
    }
d914 14
a927 1
    ahstat.ahs_output++;
d929 4
a932 15
    /* Check for replay counter wrap-around in automatic (not manual) keying */
    if ((tdb->tdb_rpl == 0) && (tdb->tdb_wnd > 0) &&
	(!(tdb->tdb_flags & TDBF_NOREPLAY)))
    {
	DPRINTF(("ah_output(): SA %s/%08x should have expired\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_wrap++;
	return NULL;
    }

    if (!(tdb->tdb_flags & TDBF_NOREPLAY))
      rplen = AH_FLENGTH + sizeof(u_int32_t);
    else
      rplen = AH_FLENGTH;
d934 1
a934 2
    switch (tdb->tdb_dst.sa.sa_family)
    {
d937 10
a946 10
	    /* Check for IP maximum packet size violations */
	    if (rplen + ahx->authsize + m->m_pkthdr.len > IP_MAXPACKET)
	    {
		DPRINTF(("ah_output(): packet in SA %s/%08x got too big\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		ahstat.ahs_toobig++;
		return EMSGSIZE;
	    }
	    break;
d951 10
a960 10
	    /* Check for IPv6 maximum packet size violations */
	    if (rplen + ahx->authsize + m->m_pkthdr.len > IPV6_MAXPACKET)
	    {
		DPRINTF(("ah_output(): packet in SA %s/%08x got too big\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		ahstat.ahs_toobig++;
		return EMSGSIZE;
	    }
	    break;
d964 68
a1031 132
	    DPRINTF(("ah_output(): unknown/unsupported protocol family %d, SA %s/%08x\n", tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    m_freem(m);
	    ahstat.ahs_nopf++;
	    return EPFNOSUPPORT;
    }

    /* Update the counters */
    tdb->tdb_cur_bytes += m->m_pkthdr.len - skip;
    ahstat.ahs_obytes += m->m_pkthdr.len - skip;

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	  tdb_delete(tdb);
	  m_freem(m);
	  return EINVAL;
      }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;      /* Turn off checking */
    }

    /*
     * Loop through mbuf chain; if we find an M_EXT mbuf with
     * more than one reference, replace the rest of the chain.
     */
    mi = m;
    while (mi != NULL &&
	   (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi)))
    {
        mo = mi;
        mi = mi->m_next;
    }

    if (mi != NULL)
    {
        /* Replace the rest of the mbuf chain. */
        struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);

        if (n == NULL)
        {
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    return ENOBUFS;
        }

        if (mo != NULL)
	  mo->m_next = n;
        else
	  m = n;

        m_freem(mi);
    }

    /* Inject AH header */
    mi = m_inject(m, skip, rplen + ahx->authsize, M_DONTWAIT);
    if (mi == NULL)
    {
	DPRINTF(("ah_output(): failed to inject AH header for SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_wrap++;
	return ENOBUFS;
    }

    /*
     * The AH header is guaranteed by m_inject() to be in contiguous memory,
     * at the beginning of the returned mbuf.
     */
    ah = mtod(mi, struct ah *);

    /* Initialize the AH header */
    m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &ah->ah_nh);
    ah->ah_hl = (rplen + ahx->authsize - AH_FLENGTH) / sizeof(u_int32_t);
    ah->ah_rv = 0;
    ah->ah_spi = tdb->tdb_spi;

    /* Zeroize authenticator */
    m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes);

    if (!(tdb->tdb_flags & TDBF_NOREPLAY))
      ah->ah_rpl = htonl(tdb->tdb_rpl++);

    /* Get crypto descriptors */
    crp = crypto_getreq(1);
    if (crp == NULL)
    {
	m_freem(m);
	DPRINTF(("ah_output(): failed to acquire crypto descriptors\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }

    crda = crp->crp_desc;

    crda->crd_skip = 0;
    crda->crd_inject = skip + rplen;
    crda->crd_len = m->m_pkthdr.len;

    /* Authentication operation */
    crda->crd_alg = ahx->type;
    crda->crd_key = tdb->tdb_amxkey;
    crda->crd_klen = tdb->tdb_amxkeylen * 8;

    /* Allocate IPsec-specific opaque crypto info */
    if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
      MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto) + skip,
	     M_XDATA, M_NOWAIT);
    else
      MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto), M_XDATA,
	     M_NOWAIT);
    if (tc == NULL)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("ah_output(): failed to allocate tdb_crypto\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }

    bzero(tc, sizeof(struct tdb_crypto));

    /* Save the skipped portion of the packet */
    if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
    {
	m_copydata(m, 0, skip, (caddr_t) (tc + 1));
d1034 2
a1035 3
	 * Fix IP header length on the header used for authentication. We don't
	 * need to fix the original header length as it will be fixed by our
	 * caller.
d1037 62
a1098 2
	switch (tdb->tdb_dst.sa.sa_family)
	{
d1100 8
a1107 7
	    case AF_INET:
		bcopy(((caddr_t)(tc + 1)) + offsetof(struct ip, ip_len),
		      (caddr_t) &iplen, sizeof(u_int16_t));
		iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
		m_copyback(m, offsetof(struct ip, ip_len), sizeof(u_int16_t),
			   (caddr_t) &iplen);
		break;
d1111 8
a1118 7
	    case AF_INET6:
		bcopy(((caddr_t)(tc + 1)) + offsetof(struct ip6_hdr, ip6_plen),
		      (caddr_t) &iplen, sizeof(u_int16_t));
		iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
		m_copyback(m, offsetof(struct ip6_hdr, ip6_plen),
			   sizeof(u_int16_t), (caddr_t) &iplen);
		break;
d1120 21
d1143 19
a1161 43
	/* Fix the Next Header field in saved header. */
	((u_int8_t *) (tc + 1))[protoff] = IPPROTO_AH;

	/* Update the Next Protocol field in the IP header. */
	prot = IPPROTO_AH;
	m_copyback(m, protoff, sizeof(u_int8_t), (caddr_t) &prot);

	/* "Massage" the packet headers for crypto processing */
	if ((len = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
				      skip, ahx->type, 1)) != 0)
	{
	    /* mbuf will be free'd by callee */
	    FREE(tc, M_XDATA);
	    crypto_freereq(crp);
	    return len;
	}
    }
    else
    {
	/* Update the Next Protocol field in the IP header. */
	prot = IPPROTO_AH;
	m_copyback(m, protoff, sizeof(u_int8_t), (caddr_t) &prot);
    }

    /* Crypto operation descriptor */
    crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
    crp->crp_flags = CRYPTO_F_IMBUF;
    crp->crp_buf = (caddr_t) m;
    crp->crp_callback = (int (*) (struct cryptop *)) ah_output_cb;
    crp->crp_sid = tdb->tdb_cryptoid;
    crp->crp_opaque = (caddr_t) tc;

    /* These are passed as-is to the callback */
    tc->tc_skip = skip;
    tc->tc_protoff = protoff;
    tc->tc_spi = tdb->tdb_spi;
    tc->tc_proto = tdb->tdb_sproto;
    bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

    if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
      return crypto_dispatch(crp);
    else
      return ah_output_cb(crp);
d1170 64
a1233 64
    int skip, protoff, error;
    struct tdb_crypto *tc;
    struct cryptop *crp;
    struct tdb *tdb;
    struct mbuf *m;
    caddr_t ptr;
    int err, s;

    crp = (struct cryptop *) op;
    tc = (struct tdb_crypto *) crp->crp_opaque;
    skip = tc->tc_skip;
    protoff = tc->tc_protoff;
    ptr = (caddr_t) (tc + 1);
    m = (struct mbuf *) crp->crp_buf;

    s = spltdb();

    tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);

    FREE(tc, M_XDATA);
    if (tdb == NULL)
    {
	ahstat.ahs_notdb++;
	DPRINTF(("ah_output_cb(): TDB is expired while in crypto\n"));
	goto baddone;
    }

    /* Check for crypto errors */
    if (crp->crp_etype)
    {
        if (tdb->tdb_cryptoid != 0)
	  tdb->tdb_cryptoid = crp->crp_sid;

	if (crp->crp_etype == EAGAIN)
        {
            splx(s);
            return crypto_dispatch(crp);
        }

	ahstat.ahs_noxform++;
	DPRINTF(("ah_output_cb(): crypto error %d\n", crp->crp_etype));
	error = crp->crp_etype;
	goto baddone;
    }

    /* Shouldn't happen... */
    if (m == NULL)
    {
	ahstat.ahs_crypto++;
	DPRINTF(("ah_output_cb(): bogus returned buffer from crypto\n"));
	error = EINVAL;
	goto baddone;
    }

    /* Copy original headers (with the new protocol number) back in place */
    if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
      m_copyback(m, 0, skip, ptr);

    /* No longer needed */
    crypto_freereq(crp);

    err =  ipsp_process_done(m, tdb);
    splx(s);
    return err;
d1236 1
a1236 1
    splx(s);
d1238 2
a1239 2
    if (m != NULL)
      m_freem(m);
d1241 1
a1241 1
    crypto_freereq(crp);
d1243 1
a1243 1
    return error;
@


1.61
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 2
/*	$OpenBSD: ip_ah.c,v 1.60 2001/06/23 16:15:56 fgsch Exp $ */

d21 1
d23 1
a23 1
 * Permission to use, copy, and modify this software without fee
@


1.60
log
@Remove unneeded ip_id convertions.
Instead of using HTONS macro in some places, use htons directly in the
struct member and save us a few bytes.
Fix comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.59 2001/06/08 03:13:14 angelos Exp $ */
d65 1
a65 1
#include <crypto/crypto.h>
@


1.59
log
@Trim include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.58 2001/06/01 00:09:23 angelos Exp $ */
d215 2
a216 2
	     * On input, fix ip_len and ip_id, which have been byte-swapped
	     * at ip_intr()
a221 1
		HTONS(ip->ip_id);
@


1.58
log
@The IPsec-aware NIC cards don't pass the ICV for later verification
by the stack; that means, if we have a tag it means the ICV was
successfully verified and we don't need to do anything else. As well,
we don't need any other status information from the NIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.57 2001/05/30 12:29:03 angelos Exp $ */
a40 1
#include <sys/malloc.h>
a41 2
#include <sys/domain.h>
#include <sys/protosw.h>
a42 6
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/socketvar.h>
#include <machine/cpu.h>
#include <machine/endian.h>
a44 3
#include <net/route.h>
#include <net/netisr.h>
#include <net/raw_cb.h>
d47 1
d51 1
d54 3
a64 3
#include <sys/md5k.h>
#include <crypto/sha1.h>
#include <crypto/rmd160.h>
@


1.57
log
@Update to match prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.56 2001/05/30 12:13:59 angelos Exp $ */
d624 3
a626 21
    else
    {
#ifdef DEBUG
	/*
	 * Check that it has the proper length -- i.e., contains the
	 * authenticator.
	 */
	if (mtag->m_tag_len != sizeof(struct tdb_ident) + ahx->authsize)
	{
	    m_freem(m);
	    crypto_freereq(crp);
	    DPRINTF(("ah_input(): tag had wrong length (%d, should be %d)\n",
		     mtag->m_tag_len,
		     sizeof(struct tdb_ident) + ahx->authsize));
	    ahstat.ahs_crypto++;
	    return EINVAL;
	}
#endif
	MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto), M_XDATA,
	       M_NOWAIT);
    }
a694 1
    caddr_t ptr, authptr;
d699 1
d765 2
a766 2
     * If we have an mtag, it means we can get the authenticator off
     * of it, as opposed to right after the tdb_crypto.
d771 9
a779 1
	authptr = ptr + skip + rplen;
a788 3
	authptr =  (caddr_t) (mtag + 1);
	authptr += sizeof(struct tdb_crypto);

a791 9
    }

    /* Verify authenticator */
    if (bcmp(authptr, calc, ahx->authsize))
    {
	DPRINTF(("ah_input(): authentication failed for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_badauth++;
	error = EACCES;
	goto baddone;
@


1.56
log
@Handle TDBF_SKIPCRYPTO on output, and PACKET_TAG_IPSEC_IN_CRYPTO_DONE
on input.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.55 2001/05/27 03:51:31 angelos Exp $ */
d900 1
a900 1
	  int protoff, struct tdb *tdb2)
a1183 7
    if (tdb2)
    {
	tc->tc_spi2 = tdb2->tdb_spi;
	tc->tc_proto2 = tdb2->tdb_sproto;
	bcopy(&tdb2->tdb_dst, &tc->tc_dst2, sizeof(union sockaddr_union));
    }

a1195 1
    struct tdb *tdb, *tdb2 = NULL;
d1199 1
a1213 2
    if (tc->tc_spi2)
      tdb2 = gettdb(tc->tc_spi2, &tc->tc_dst2, tc->tc_proto2);
d1257 1
a1257 1
    err =  ipsp_process_done(m, tdb, tdb2);
@


1.55
log
@Probably a good idea to pass the NULL to the correct function...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.54 2001/05/27 03:48:32 angelos Exp $ */
d504 1
d506 1
d609 11
d621 24
a644 2
    MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
	   M_XDATA, M_NOWAIT);
d653 1
d656 2
a657 7
    /*
     * Save the authenticator, the skipped portion of the packet, and the
     * AH header.
     */
    MALLOC(tc->tc_ptr, caddr_t, skip + rplen + ahx->authsize,
	   M_XDATA, M_NOWAIT);
    if (tc->tc_ptr == 0)
d659 18
a676 23
	m_freem(m);
	FREE(tc, M_XDATA);
	crypto_freereq(crp);
	DPRINTF(("ah_input(): failed to allocate auth array\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }

    /* Save data */
    m_copydata(m, 0, skip + rplen + ahx->authsize, tc->tc_ptr);

    /* Zeroize the authenticator on the packet */
    m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes);

    /* "Massage" the packet headers for crypto processing */
    if ((btsx = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
				   skip, ahx->type, 0)) != 0)
    {
	/* mbuf will be free'd by callee */
	FREE(tc->tc_ptr, M_XDATA);
	FREE(tc, M_XDATA);
	crypto_freereq(crp);
	return btsx;
d692 1
d695 4
a698 1
    return crypto_dispatch(crp);
d713 1
d715 1
d717 1
a717 1
    caddr_t ptr = 0;
d726 1
a726 1
    ptr = tc->tc_ptr;
d759 5
d766 1
a766 1
    if (!m)
d779 1
a779 1
    /* Copy computed authenticator */
d782 25
d808 1
a808 1
    if (bcmp(ptr + skip + rplen, calc, ahx->authsize))
a815 11
    /* Fix the Next Protocol field */
    ((u_int8_t *) ptr)[protoff] =
				((u_int8_t *) ptr)[skip];

    /* Copyback the saved (uncooked) network headers */
    m_copyback(m, 0, skip, ptr);

    /* No longer needed */
    FREE(ptr, M_XDATA);
    crypto_freereq(crp);

d879 1
a879 1
    err = ipsec_common_input_cb(m, tdb, skip, protoff, NULL);
d886 1
a886 1
    if (m)
d889 2
a890 5
    /* We have to free this manually */
    if (ptr)
      FREE(ptr, M_XDATA);

    crypto_freereq(crp);
d908 1
a909 1
    int len, rplen;
d1095 6
a1100 2
    MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto), M_XDATA,
	   M_NOWAIT);
d1109 1
d1113 1
a1113 2
    MALLOC(tc->tc_ptr, caddr_t, skip, M_XDATA, M_NOWAIT);
    if (tc->tc_ptr == 0)
d1115 1
a1115 9
	FREE(tc, M_XDATA);
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("ah_output(): failed to allocate auth array\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }
    else
      m_copydata(m, 0, skip, tc->tc_ptr);
d1117 7
a1123 7
    /*
     * Fix IP header length on the header used for authentication. We don't
     * need to fix the original header length as it will be fixed by our
     * caller.
     */
    switch (tdb->tdb_dst.sa.sa_family)
    {
d1125 7
a1131 7
	case AF_INET:
	    bcopy(tc->tc_ptr + offsetof(struct ip, ip_len),
		  (caddr_t) &iplen, sizeof(u_int16_t));
	    iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
	    m_copyback(m, offsetof(struct ip, ip_len), sizeof(u_int16_t),
		       (caddr_t) &iplen);
	    break;
d1135 7
a1141 7
	case AF_INET6:
	    bcopy(tc->tc_ptr + offsetof(struct ip6_hdr, ip6_plen),
		  (caddr_t) &iplen, sizeof(u_int16_t));
	    iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
	    m_copyback(m, offsetof(struct ip6_hdr, ip6_plen),
		       sizeof(u_int16_t), (caddr_t) &iplen);
	    break;
d1143 18
d1162 5
a1166 15

    /* Update the Next Protocol field in the IP header and the saved data */
    prot = IPPROTO_AH;
    m_copyback(m, protoff, sizeof(u_int8_t), (caddr_t) &prot);
    ((u_int8_t *) tc->tc_ptr)[protoff] = IPPROTO_AH;

    /* "Massage" the packet headers for crypto processing */
    if ((len = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
				  skip, ahx->type, 1)) != 0)
    {
	/* mbuf will be free'd by callee */
	FREE(tc->tc_ptr, M_XDATA);
	FREE(tc, M_XDATA);
	crypto_freereq(crp);
	return len;
d1191 4
a1194 1
    return crypto_dispatch(crp);
a1206 1
    caddr_t ptr = 0;
d1208 1
d1215 1
a1215 1
    ptr = tc->tc_ptr;
d1251 1
a1251 1
    if (!m)
d1260 2
a1261 1
    m_copyback(m, 0, skip, ptr);
a1263 1
    FREE(ptr, M_XDATA);
d1273 1
a1273 1
    if (m)
a1274 4

    /* We have to free this manually */
    if (ptr)
      FREE(ptr, M_XDATA);
@


1.54
log
@Pass a NULL packet tag for now to ipsp_common_input_cb().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.53 2001/05/17 18:41:46 provos Exp $ */
d828 1
a828 1
    err = ipsec_common_input_cb(m, tdb, skip, protoff);
d1211 1
a1211 1
    err =  ipsp_process_done(m, tdb, tdb2, NULL);
@


1.53
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.52 2001/05/13 15:39:27 deraadt Exp $ */
d1211 1
a1211 1
    err =  ipsp_process_done(m, tdb, tdb2);
@


1.52
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.51 2001/05/12 18:09:02 angelos Exp $ */
d970 1
a970 3
	   (!(mi->m_flags & M_EXT) ||
	    (mi->m_ext.ext_ref == NULL &&
	     mclrefcnt[mtocl(mi->m_ext.ext_buf)] <= 1)))
@


1.51
log
@Move bzero() after test for correct allocation (jj@@wabbitt.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.50 2001/04/14 00:30:58 angelos Exp $ */
d158 1
a158 1
    return crypto_newsession(&tdbp->tdb_cryptoid, &cria);
@


1.50
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.49 2001/04/06 04:42:08 csapuntz Exp $ */
a609 1
    bzero(tc, sizeof(struct tdb_crypto));
d618 1
a1050 1
    bzero(tc, sizeof(struct tdb_crypto));
d1059 1
@


1.49
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.48 2001/03/28 20:03:02 angelos Exp $ */
d610 1
d852 1
a852 1
	  int protoff)
d1051 1
d1134 7
d1150 1
a1153 1
    struct tdb *tdb;
d1168 3
d1213 1
a1213 1
    err =  ipsp_process_done(m, tdb);
@


1.48
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.47 2001/03/15 06:30:58 mickey Exp $ */
a83 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.47
log
@convert SA expirations to the new timeouts.
simplifies expirations handling a lot.
tdb_exp_timeout and tdb_soft_timeout are made
consistant throughout the code to be a relative time offsets,
just like first_use timeouts.
tested on singlehost isakmpd setup.
lots of dangling spaces and tabs removed.
angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.46 2001/02/20 06:48:06 itojun Exp $ */
d883 1
a883 4
	if (tdb->tdb_interface)
	  ifn = (struct ifnet *) tdb->tdb_interface;
	else
	  ifn = &(encif[0].sc_if);
@


1.46
log
@tighten IPv4 option header processing (we may want to do more).
reviewed by angelos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.45 2000/11/17 04:15:42 angelos Exp $ */
d5 1
a5 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
d26 1
a26 1
 * modification of this software. 
d266 1
a266 1
			   
d375 1
a375 1
	    
d577 1
a577 1
	  tdb_delete(tdb, TDBEXP_TIMEOUT);
d679 1
a679 1
{ 
d781 1
a781 1
    if (roff == 0) 
d819 1
a819 1
	  /* 
d957 1
a957 1
	  tdb_delete(tdb, TDBEXP_TIMEOUT);
d971 1
a971 1
     * Loop through mbuf chain; if we find an M_EXT mbuf with 
d975 2
a976 2
    while (mi != NULL && 
	   (!(mi->m_flags & M_EXT) || 
d983 1
a983 1
     
d988 1
a988 1
      
d1020 1
a1020 1
    
@


1.45
log
@*HMAC96->*HMAC
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.44 2000/09/19 03:20:58 angelos Exp $ */
d256 11
d282 2
a283 2
			/* Sanity check for zero-length options */
			if (ptr[off + 1] == 0)
d285 1
a285 1
			    DPRINTF(("ah_massage_headers(): illegal zero-length IPv4 option %d\n", ptr[off]));
d296 9
d319 2
a320 2
			/* Sanity check for zero-length options */
			if (ptr[off + 1] == 0)
d322 1
a322 1
			    DPRINTF(("ah_massage_headers(): illegal zero-length IPv4 option %d\n", ptr[off]));
@


1.44
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.43 2000/08/03 08:20:59 angelos Exp $ */
d111 1
a111 1
	case SADB_AALG_MD5HMAC96:
d115 1
a115 1
	case SADB_AALG_SHA1HMAC96:
d119 1
a119 1
	case SADB_X_AALG_RIPEMD160HMAC96:
@


1.44.2.1
log
@Pull in patch from current:
Errata (023), Fix (itojun):
tighten IPv4 option header processing (we may want to do more).
reviewed by angelos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.44 2000/09/19 03:20:58 angelos Exp $ */
a255 11
		if (ptr[off] == IPOPT_EOL || ptr[off] == IPOPT_NOP ||
		    off + 1 < skip)
		    ;
		else
		{
		    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
		    ahstat.ahs_hdrops++;
		    m_freem(m);
		    return EINVAL;
		}
			   
d271 2
a272 2
			/* Sanity check for option length */
			if (ptr[off + 1] < 2)
d274 1
a274 1
			    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
a284 9
			/* Sanity check for option length */
			if (ptr[off + 1] < 2)
			{
			    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
			    ahstat.ahs_hdrops++;
			    m_freem(m);
			    return EINVAL;
			}

d299 2
a300 2
			/* Sanity check for option length */
			if (ptr[off + 1] < 2)
d302 1
a302 1
			    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
@


1.43
log
@Careful with ip_off
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.42 2000/06/20 04:19:10 itojun Exp $ */
d8 2
a9 2
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
d17 1
a17 1
 * Additional features in 1999 by Angelos D. Keromytis.
d19 1
a19 1
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
d21 2
a22 1
 *	
d238 5
a242 5
                if ((alg == CRYPTO_MD5_KPDK) || (alg == CRYPTO_SHA1_KPDK))
                  ip->ip_off = htons(ip->ip_off & IP_DF);
                else
                  ip->ip_off = 0;
            }
d244 5
a248 5
            { 
                if ((alg == CRYPTO_MD5_KPDK) || (alg == CRYPTO_SHA1_KPDK))
                  ip->ip_off = htons(ntohs(ip->ip_off) & IP_DF);
                else
                  ip->ip_off = 0;
d557 1
a557 1
	  tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
d937 1
a937 1
	  tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
@


1.42
log
@try to cope with AH6 with scoped address case better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.41 2000/06/18 08:23:46 angelos Exp $ */
a235 1
	    }
d237 12
a248 4
	    if ((alg == CRYPTO_MD5_KPDK) || (alg == CRYPTO_SHA1_KPDK))
	      ip->ip_off = htons(ip->ip_off & IP_DF);
	    else
	      ip->ip_off = 0;
@


1.41
log
@Use M_NOWAIT instead of M_DONTWAIT in MALLOC() (even though they're
defined to be the same in mbuf.h)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.40 2000/06/18 03:07:25 angelos Exp $ */
d338 6
@


1.40
log
@The callbacks need to set the appropriate spl level now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.39 2000/06/06 04:49:29 angelos Exp $ */
d348 1
a348 1
			   M_XDATA, M_DONTWAIT);
d579 1
a579 1
	   M_XDATA, M_DONTWAIT);
d594 1
a594 1
	   M_XDATA, M_DONTWAIT);
d1022 1
a1022 1
	   M_DONTWAIT);
d1033 1
a1033 1
    MALLOC(tc->tc_ptr, caddr_t, skip, M_XDATA, M_DONTWAIT);
@


1.39
log
@Get rid of tdb_ref, keep indirect pointer to TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.38 2000/06/01 05:40:41 angelos Exp $ */
d655 1
d666 2
d686 4
a689 1
	  return crypto_dispatch(crp);
d738 2
a741 1
	ahstat.ahs_hdrops++;
d797 3
a799 1
    return ipsec_common_input_cb(m, tdb, skip, protoff);
d802 2
d1120 1
d1129 2
d1147 4
a1150 1
          return crypto_dispatch(crp);
d1174 3
a1176 1
    return ipsp_process_done(m, tdb);
d1179 2
@


1.38
log
@Check for invalid TDBs right away in the callbacks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.37 2000/04/25 02:53:46 jason Exp $ */
d474 1
d577 12
d593 1
a593 1
    MALLOC(crp->crp_opaque4, caddr_t, skip + rplen + ahx->authsize,
d595 1
a595 1
    if (crp->crp_opaque4 == 0)
d598 1
d606 1
a606 1
    m_copydata(m, 0, skip + rplen + ahx->authsize, crp->crp_opaque4);
d616 2
a617 2
	FREE(crp->crp_opaque4, M_XDATA);

a621 2
    tdb->tdb_ref++;

d628 1
d631 5
a635 3
    crp->crp_opaque1 = (caddr_t) tdb;
    (long) crp->crp_opaque2 = skip;
    (long) crp->crp_opaque3 = protoff;
d651 1
d654 1
d658 5
a662 4
    tdb = (struct tdb *) crp->crp_opaque1;
    ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    skip = (long) crp->crp_opaque2;
    protoff = (long) crp->crp_opaque3;
d665 3
a667 7
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
d669 2
a670 4
	ahstat.ahs_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("ah_input_cb(): TDB expired while processing crypto\n"));
d673 2
a674 2
    else
        tdb->tdb_ref--;
d683 1
a683 4
	{
	    tdb->tdb_ref++;
	    return crypto_dispatch(crp);
	}
d709 1
a709 1
    if (bcmp(crp->crp_opaque4 + skip + rplen, calc, ahx->authsize))
d718 2
a719 2
    ((u_int8_t *) crp->crp_opaque4)[protoff] =
				((u_int8_t *) crp->crp_opaque4)[skip];
d722 1
a722 1
    m_copyback(m, 0, skip, crp->crp_opaque4);
d725 1
a725 1
    FREE(crp->crp_opaque4, M_XDATA);
d797 2
a798 2
    if (crp && crp->crp_opaque4)
      FREE(crp->crp_opaque4, M_XDATA);
d814 1
d1009 12
d1022 2
a1023 2
    MALLOC(crp->crp_opaque4, caddr_t, skip, M_XDATA, M_DONTWAIT);
    if (crp->crp_opaque4 == 0)
d1025 1
d1033 1
a1033 1
      m_copydata(m, 0, skip, crp->crp_opaque4);
d1044 1
a1044 1
	    bcopy(crp->crp_opaque4 + offsetof(struct ip, ip_len),
d1054 1
a1054 1
	    bcopy(crp->crp_opaque4 + offsetof(struct ip6_hdr, ip6_plen),
a1062 2
    tdb->tdb_ref++;

d1066 1
a1066 1
    ((u_int8_t *) crp->crp_opaque4)[protoff] = IPPROTO_AH;
d1073 2
a1074 1
	FREE(crp->crp_opaque4, M_XDATA);
d1085 1
d1088 5
a1092 3
    crp->crp_opaque1 = (caddr_t) tdb;
    (long) crp->crp_opaque2 = skip;
    (long) crp->crp_opaque3 = protoff;
d1104 1
d1107 1
d1111 4
a1114 3
    tdb = (struct tdb *) crp->crp_opaque1;
    skip = (long) crp->crp_opaque2;
    protoff = (long) crp->crp_opaque3;
d1117 3
a1119 7
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
d1121 2
a1122 4
	ahstat.ahs_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("ah_output_cb(): TDB expired while processing crypto\n"));
a1124 2
    else
      tdb->tdb_ref--;
d1133 1
a1133 4
	{
	    tdb->tdb_ref++;
	    return crypto_dispatch(crp);
	}
d1151 1
a1151 1
    m_copyback(m, 0, skip, crp->crp_opaque4);
d1154 1
a1154 1
    FREE(crp->crp_opaque4, M_XDATA);
d1164 2
a1165 2
    if (crp && crp->crp_opaque4)
      FREE(crp->crp_opaque4, M_XDATA);
@


1.37
log
@when fixing up the header, copy from the right sized datatype (fixes IPsec
on big-endian machines)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.36 2000/03/21 21:00:09 angelos Exp $ */
d647 16
a662 1
    tdb->tdb_ref--;
a690 15
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
    {
	ahstat.ahs_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("ah_input_cb(): TDB expired while processing crypto\n"));
	goto baddone;
    }

d1089 16
a1104 1
    tdb->tdb_ref--;
a1129 15
	goto baddone;
    }

    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
    {
	ahstat.ahs_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("ah_output_cb(): TDB expired while processing crypto\n"));
@


1.36
log
@Fix casting so it compiles on alphas (testing by janjaap@@stack.nl,
closing pr #1150)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.35 2000/03/17 10:25:22 angelos Exp $ */
d808 1
d1043 2
a1044 2
    len = IPPROTO_AH;
    m_copyback(m, protoff, sizeof(u_int8_t), (caddr_t) &len);
@


1.35
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.34 2000/02/07 06:09:09 itojun Exp $ */
d619 2
a620 2
    crp->crp_opaque2 = (caddr_t) skip;
    crp->crp_opaque3 = (caddr_t) protoff;
d643 2
a644 2
    skip = (int) crp->crp_opaque2;
    protoff = (int) crp->crp_opaque3;
d1065 2
a1066 2
    crp->crp_opaque2 = (caddr_t) skip;
    crp->crp_opaque3 = (caddr_t) protoff;
d1084 2
a1085 2
    skip = (int) crp->crp_opaque2;
    protoff = (int) crp->crp_opaque3;
@


1.34
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.33 2000/01/27 08:09:08 angelos Exp $ */
d71 6
a88 14
extern struct auth_hash auth_hash_hmac_md5_96;
extern struct auth_hash auth_hash_hmac_sha1_96;
extern struct auth_hash auth_hash_hmac_ripemd_160_96;
extern struct auth_hash auth_hash_key_md5;
extern struct auth_hash auth_hash_key_sha1;

struct auth_hash *ah_hash[] = {
    &auth_hash_hmac_md5_96,
    &auth_hash_hmac_sha1_96,
    &auth_hash_hmac_ripemd_160_96,
    &auth_hash_key_md5,
    &auth_hash_key_sha1,
};

d105 20
a124 1
    int i;
d126 3
a128 3
    for (i = sizeof(ah_hash) / sizeof(ah_hash[0]) - 1; i >= 0; i--)
      if (ii->ii_authalg == ah_hash[i]->type)
	break;
d130 3
a132 4
    if (i < 0) 
    {
	DPRINTF(("ah_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
	return EINVAL;
a134 2
    thash = ah_hash[i];

d155 5
a159 32
    /* "Old" AH */
    if ((thash->type == SADB_X_AALG_MD5) || (thash->type == SADB_X_AALG_SHA1))
    {
	MALLOC(tdbp->tdb_ictx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
	bzero(tdbp->tdb_ictx, thash->ctxsize);
	thash->Init(tdbp->tdb_ictx);
	thash->Update(tdbp->tdb_ictx, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
	thash->Final(NULL, tdbp->tdb_ictx);
    }
    else  /* HMAC */
    {
	/* Precompute the I and O pads of the HMAC */
	for (i = 0; i < ii->ii_authkeylen; i++)
	  ii->ii_authkey[i] ^= HMAC_IPAD_VAL;

	MALLOC(tdbp->tdb_ictx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
	bzero(tdbp->tdb_ictx, thash->ctxsize);
	thash->Init(tdbp->tdb_ictx);
	thash->Update(tdbp->tdb_ictx, ii->ii_authkey, ii->ii_authkeylen);
	thash->Update(tdbp->tdb_ictx, hmac_ipad_buffer,
		      HMAC_BLOCK_LEN - ii->ii_authkeylen);

	for (i = 0; i < ii->ii_authkeylen; i++)
	  ii->ii_authkey[i] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);

	MALLOC(tdbp->tdb_octx, u_int8_t *, thash->ctxsize, M_XDATA, M_WAITOK);
	bzero(tdbp->tdb_octx, thash->ctxsize);
	thash->Init(tdbp->tdb_octx);
	thash->Update(tdbp->tdb_octx, ii->ii_authkey, ii->ii_authkeylen);
	thash->Update(tdbp->tdb_octx, hmac_opad_buffer,
		      HMAC_BLOCK_LEN - ii->ii_authkeylen);
    }
d161 1
a161 3
    bzero(ipseczeroes, IPSEC_ZEROES_SIZE);	/* paranoid */

    return 0;
d164 3
a166 1
/* Free memory */
d170 2
d179 3
a181 19
    if (tdbp->tdb_ictx)
    {
	if (tdbp->tdb_authalgxform)
	  bzero(tdbp->tdb_ictx, tdbp->tdb_authalgxform->ctxsize);

	FREE(tdbp->tdb_ictx, M_XDATA);
	tdbp->tdb_ictx = NULL;
    }

    if (tdbp->tdb_octx)
    {
	if (tdbp->tdb_authalgxform)
	  bzero(tdbp->tdb_octx, tdbp->tdb_authalgxform->ctxsize);

	FREE(tdbp->tdb_octx, M_XDATA);
	tdbp->tdb_octx = NULL;
    }

    return 0;
d185 1
a185 2
 * ah_input() gets called to verify that an input packet
 * passes authentication
d187 2
a188 3

struct mbuf *
ah_input(struct mbuf *m, struct tdb *tdb, int skip, int protoff)
d190 1
a190 4
    struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    unsigned char calcauth[AH_MAX_HASHLEN], savauth[AH_MAX_HASHLEN];
    int len, count, off, roff, rplen;
    struct mbuf *m0, *m1;
d192 2
a193 3
    union authctx ctx;
    struct ah ah;
    
d195 1
a195 1
    struct ip ipo;
d201 1
a201 1
    int last;
d204 1
a204 77
    if (!(tdb->tdb_flags & TDBF_NOREPLAY))
      rplen = sizeof(u_int32_t);
    else
      rplen = 0;

    /* Save the AH header, we use it throughout */
    m_copydata(m, skip, AH_FLENGTH + rplen, (unsigned char *) &ah);

    /* Save the Authenticator too */
    m_copydata(m, skip + AH_FLENGTH + rplen, ahx->authsize, savauth);

    /* Replay window checking, if applicable */
    if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY)))
    {
	switch (checkreplaywindow32(ntohl(ah.ah_rpl), 0, &(tdb->tdb_rpl),
				    tdb->tdb_wnd, &(tdb->tdb_bitmap)))
	{
	    case 0: /* All's well */
		break;

	    case 1:
		DPRINTF(("ah_input(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_wrap++;
		m_freem(m);
		return NULL;

	    case 2:
	    case 3:
		DPRINTF(("ah_input(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_replay++;
		m_freem(m);
		return NULL;

	    default:
                DPRINTF(("ah_input(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_replay++;
                m_freem(m);
                return NULL;
	}
    }

    /* Verify AH header length */
    if (ah.ah_hl * sizeof(u_int32_t) != ahx->authsize + rplen)
    {
	DPRINTF(("ah_input(): bad authenticator length %d for packet in SA %s/%08x\n", ah.ah_hl * sizeof(u_int32_t), ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_badauthl++;
	m_freem(m);
	return NULL;
    }

    /* Update the counters */
    tdb->tdb_cur_bytes += (m->m_pkthdr.len - skip -
			   ah.ah_hl * sizeof(u_int32_t));
    ahstat.ahs_ibytes += (m->m_pkthdr.len - skip -
			  ah.ah_hl * sizeof(u_int32_t));

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	  tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	  m_freem(m);
	  return NULL;
      }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;     /* Turn off checking */
    }

    bcopy(tdb->tdb_ictx, &ctx, ahx->ctxsize);

    switch (tdb->tdb_dst.sa.sa_family)
d213 1
a213 1
	    m = m_pullup(m, skip);
d216 1
a216 2
		DPRINTF(("ah_input(): m_pullup() failed, SA %s/%08x\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d218 1
a218 1
		return NULL;
d221 5
a225 1
	    ptr = mtod(m, unsigned char *) + sizeof(struct ip);
d227 10
a236 2
	    bcopy(mtod(m, unsigned char *), (unsigned char *) &ipo,
		  sizeof(struct ip));
d238 2
a239 8
	    ipo.ip_tos = 0;
	    ipo.ip_len += skip;     /* adjusted in ip_intr() */
	    HTONS(ipo.ip_len);
	    HTONS(ipo.ip_id);

	    if ((ahx->type == SADB_X_AALG_MD5) ||
		(ahx->type == SADB_X_AALG_SHA1))
	      ipo.ip_off = htons(ipo.ip_off & IP_DF);
d241 1
a241 3
	      ipo.ip_off = 0;
	    ipo.ip_ttl = 0;
	    ipo.ip_sum = 0;
d243 1
a243 2
	    /* Include IP header in authenticator computation */
	    ahx->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));
a250 1
			ahx->Update(&ctx, ptr + off, 1);
a254 1
			ahx->Update(&ctx, ptr + off, 1);
a262 1
			ahx->Update(&ctx, ptr + off, ptr[off + 1]);
d266 1
a266 1
			    DPRINTF(("ah_input(): illegal zero-length IPv4 option %d in SA %s/%08x\n", ptr[off], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d269 1
a269 1
			    return NULL;
d275 15
d291 13
a303 2
			ahx->Update(&ctx, ipseczeroes, ptr[off + 1]);
			off += ptr[off + 1];
d310 1
a310 1
		    DPRINTF(("ah_input(): malformed IPv4 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d313 1
a313 1
		    return NULL;
d322 2
a323 2
	    /* Copy and "cook" (later on) the IPv6 header */
	    m_copydata(m, 0, sizeof(ip6), (unsigned char *) &ip6);
d328 1
a328 1
		DPRINTF(("ah_input(): unsupported IPv6 jumbogram in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d331 1
a331 1
		return NULL;
d339 3
a341 3
	    /* Include IPv6 header in authenticator computation */
	    ahx->Update(&ctx, (unsigned char *) &ip6, sizeof(ip6));

d348 8
a355 1
			   M_XDATA, M_WAITOK);
d360 1
d363 5
a367 1
		  ptr = mtod(m, unsigned char *) + sizeof(struct ip6_hdr);
d385 1
a385 1
		      for (last = len, count = len + sizeof(struct ip6_ext);
d391 1
a391 1
			      continue;
d395 1
a395 2
			  if (count + sizeof(struct ip6_ext) > len +
			      ((ip6e->ip6e_len + 1) << 3))
d397 1
a397 1
			      DPRINTF(("ah_input(): malformed IPv6 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d402 4
a405 6
			      if (m->m_len < skip)
			      {
				  FREE(ptr, M_XDATA);
				  ptr = NULL;
			      }
			      return NULL;
d408 3
a410 5
			  /*
			   * If mutable option, calculate authenticator
			   * for all immutable fields so far, then include
			   * a zeroed-out version of this option.
			   */
d412 3
a414 14
			  {
			      /* Calculate immutables */
			      ahx->Update(&ctx, ptr + last,
					  count + sizeof(struct ip6_ext) -
					  last);
			      last = count + ptr[count + 1] +
				     sizeof(struct ip6_ext);

			      /* Calculate "zeroed-out" immutables */
			      ahx->Update(&ctx, ipseczeroes, ptr[count + 1] -
					  sizeof(struct ip6_ext));
			  }
			  
			  count += ptr[count + 1] + sizeof(struct ip6_ext);
d419 1
a419 1
			      DPRINTF(("ah_input(): malformed IPv6 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d424 4
a427 6
			      if (m->m_len < skip)
			      {
				  FREE(ptr, M_XDATA);
				  ptr = NULL;
			      }
			      return NULL;
a430 4
		      /* Include any trailing immutable options */
		      ahx->Update(&ctx, ptr + last,
				  len + ((ip6e->ip6e_len + 1) << 3) - last);

d436 1
a437 1
		      ahx->Update(&ctx, ptr + len, (ip6e->ip6e_len + 1) << 3);
d443 6
a448 3
		      DPRINTF(("ah_input(): unexpected IPv6 header type %d in SA %s/%08x\n", off, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));   
		      len = skip - sizeof(struct ip6_hdr);
		      break;
d451 2
a452 2
	    /* Free, if we allocated */
	    if (m->m_len < skip)
d454 2
a456 1
		ptr = NULL;
d461 54
d516 15
a530 5
	default:
	    DPRINTF(("ah_input(): unsupported protocol family %d in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    return NULL;
d533 21
a553 3
    /* Record the beginning of the AH header */
    for (len = 0, m1 = m; m1 && (len + m1->m_len <= skip); m1 = m1->m_next)
      len += m1->m_len;
d555 3
a557 1
    if (m1 == NULL)
a558 3
	DPRINTF(("ah_input(): bad mbuf chain for packet in SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_hdrops++;
d560 3
a562 1
	return NULL;
a563 2
    else
      roff = skip - len;
d565 10
a574 5
    /* Skip the AH header */
    for (len = 0, m0 = m1;
	 m0 && (len + m0->m_len <= AH_FLENGTH + rplen + ahx->authsize + roff);
	 m0 = m0->m_next)
      len += m0->m_len;
d576 7
a582 1
    if (m0 == NULL)
a583 3
	DPRINTF(("ah_input(): bad mbuf chain for packet in SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_hdrops++;
d585 21
a605 1
	return NULL;
a606 2
    else
      off = (AH_FLENGTH + rplen + ahx->authsize + roff) - len;
d608 13
a620 2
    /* Include the AH header (minus the authenticator) in the computation */
    ahx->Update(&ctx, (unsigned char *) &ah, AH_FLENGTH + rplen);
d622 2
a623 2
    /* All-zeroes for the authenticator */
    ahx->Update(&ctx, ipseczeroes, ahx->authsize);
d625 23
a647 2
    /* Amount of data to be verified */
    len = m->m_pkthdr.len - skip - AH_FLENGTH - rplen - ahx->authsize;
d649 2
a650 2
    /* Loop through the mbuf chain computing the HMAC */
    while (len > 0)
d652 4
a655 1
	if (m0 == NULL)
d657 2
a658 4
	    DPRINTF(("ah_input(): bad mbuf chain for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    return NULL;
d661 5
a665 3
	count = min(m0->m_len - off, len);

	ahx->Update(&ctx, mtod(m0, unsigned char *) + off, count);
d667 7
a673 3
	len -= count;
	off = 0;
	m0 = m0->m_next;
d676 7
a682 2
    /* Finish computation */
    if ((ahx->type == SADB_X_AALG_MD5) || (ahx->type == SADB_X_AALG_SHA1))
d684 5
a688 3
	ahx->Update(&ctx, (unsigned char *) tdb->tdb_amxkey,
		    tdb->tdb_amxkeylen);
	ahx->Final(calcauth, &ctx);
d690 3
d694 4
a697 7
    {
	/* Finish HMAC computation */
	ahx->Final(calcauth, &ctx);
	bcopy(tdb->tdb_octx, &ctx, ahx->ctxsize);
	ahx->Update(&ctx, calcauth, ahx->hashsize);
	ahx->Final(calcauth, &ctx);
    }
d699 2
a700 2
    /* Verify */
    if (bcmp(savauth, calcauth, ahx->authsize))
d704 2
a705 2
	m_freem(m);
	return NULL;
d709 5
a713 1
    m_copyback(m, protoff, sizeof(u_int8_t), (u_char *) &(ah.ah_nh));
d715 16
a730 3
    /*
     * Remove the AH header from the mbuf.
     */
d734 1
a734 1
	m_adj(m1, AH_FLENGTH + rplen + ahx->authsize);
d736 1
a736 1
	  m->m_pkthdr.len -= AH_FLENGTH + rplen + ahx->authsize;
d739 1
a739 1
      if (roff + AH_FLENGTH + rplen + ahx->authsize >= m1->m_len)
d746 1
a746 1
	  if (roff + AH_FLENGTH + rplen + ahx->authsize > m1->m_len)
d749 1
a749 2
	      m_adj(m1->m_next, roff + AH_FLENGTH + rplen +
		    ahx->authsize - m1->m_len);
d752 1
a752 2
	      m->m_pkthdr.len -= (roff + AH_FLENGTH + rplen +
				  ahx->authsize - m1->m_len);
d774 1
a774 1
	  bcopy(mtod(m1, u_char *) + roff + AH_FLENGTH + rplen + ahx->authsize,
d776 3
a778 3
		m1->m_len - (roff + AH_FLENGTH + rplen + ahx->authsize));
	  m1->m_len -= AH_FLENGTH + rplen + ahx->authsize;
	  m->m_pkthdr.len -= AH_FLENGTH + rplen + ahx->authsize;
d781 13
a793 1
    return m;
d796 3
d801 1
a801 1
	      int protoff)
d804 5
a808 5
    unsigned char calcauth[AH_MAX_HASHLEN];
    int len, off, count, rplen;
    unsigned char *ptr;
    union authctx ctx;
    struct mbuf *mo;
a810 10
#ifdef INET
    struct ip ipo;
#endif /* INET */

#ifdef INET6
    struct ip6_ext *ip6e;
    struct ip6_hdr ip6;
    int last;
#endif /* INET6 */

d851 1
a851 1
      rplen = sizeof(u_int32_t);
d853 1
a853 1
      rplen = 0;
d855 2
d858 11
a868 9
    if ((tdb->tdb_dst.sa.sa_family == AF_INET) &&
	(AH_FLENGTH + rplen + ahx->authsize + m->m_pkthdr.len > IP_MAXPACKET))
    {
	DPRINTF(("ah_output(): packet in SA %s/%08x got too big\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_toobig++;
        return EMSGSIZE;
    }
d872 18
a889 9
    if ((tdb->tdb_dst.sa.sa_family == AF_INET6) &&
	(AH_FLENGTH + rplen + ahx->authsize + m->m_pkthdr.len >
	 IPV6_MAXPACKET))
    {
	DPRINTF(("ah_output(): packet in SA %s/%08x got too big\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	m_freem(m);
	ahstat.ahs_toobig++;
        return EMSGSIZE;
a890 1
#endif /* INET6 */
a916 3
     * This may not be strictly necessary for AH packets, if we were
     * careful with the rest of our processing (and made a lot of
     * assumptions about the layout of the packets/mbufs).
d918 5
a922 5
    (*mp) = m;
    while ((*mp) != NULL && 
	   (!((*mp)->m_flags & M_EXT) || 
	    ((*mp)->m_ext.ext_ref == NULL &&
	     mclrefcnt[mtocl((*mp)->m_ext.ext_buf)] <= 1)))
d924 2
a925 2
        mo = (*mp);
        (*mp) = (*mp)->m_next;
d928 1
a928 1
    if ((*mp) != NULL)
d931 1
a931 1
        struct mbuf *n = m_copym2((*mp), 0, M_COPYALL, M_DONTWAIT);
d945 1
a945 303
        m_freem((*mp));
	(*mp) = NULL;
    }

    bcopy(tdb->tdb_ictx, (caddr_t) &ctx, ahx->ctxsize);

    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    /*
	     * This is the most painless way of dealing with IPv4 header
	     * and option processing -- just make sure they're in
	     * contiguous memory.
	     */
	    m = m_pullup(m, skip);
	    if (m == NULL)
	    {
		DPRINTF(("ah_output(): m_pullup() failed, SA %s/%08x\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_hdrops++;
		return ENOBUFS;
	    }

	    ptr = mtod(m, unsigned char *) + sizeof(struct ip);

	    bcopy(mtod(m, unsigned char *), (unsigned char *) &ipo,
		  sizeof(struct ip));

	    ipo.ip_tos = 0;
	    if ((ahx->type == SADB_X_AALG_MD5) ||
		(ahx->type == SADB_X_AALG_SHA1))
	      ipo.ip_off = htons(ntohs(ipo.ip_off) & IP_DF);
	    else
	      ipo.ip_off = 0;
	    ipo.ip_ttl = 0;
	    ipo.ip_sum = 0;
	    ipo.ip_p = IPPROTO_AH;
	    ipo.ip_len = htons(ntohs(ipo.ip_len) + AH_FLENGTH + rplen +
			       ahx->authsize);

	    /* 
	     * If we have a loose or strict routing option, we are
	     * supposed to use the last address in it as the
	     * destination address in the authenticated IPv4 header.
	     *
	     * Note that this is an issue only with the output routine;
	     * we will correctly process (in the AH input routine) incoming
	     * packets with these options without special consideration.
	     *
	     * We assume that the IP header contains the next hop's address,
	     * and that the last entry in the option is the final
	     * destination's address.
	     */
	    if (skip > sizeof(struct ip))
	    {
		for (off = sizeof(struct ip); off < skip;)
		{
		    /* First sanity check for zero-length options */
		    if ((ptr[off] != IPOPT_EOL) && (ptr[off] != IPOPT_NOP) &&
			(ptr[off + 1] == 0))
		    {
			DPRINTF(("ah_output(): illegal zero-length IPv4 option %d in SA %s/%08x\n", ptr[off], ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			ahstat.ahs_hdrops++;
			m_freem(m);
			return EMSGSIZE;
		    }

		    switch (ptr[off])
		    {
			case IPOPT_LSRR:
			case IPOPT_SSRR:
			    /* Sanity check for length */
			    if (ptr[off + 1] < 2 + sizeof(struct in_addr))
			    {
				DPRINTF(("ah_output(): malformed LSRR or SSRR IPv4 option header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
				ahstat.ahs_hdrops++;
				m_freem(m);
				return EMSGSIZE;
			    }

			    bcopy(ptr + off + ptr[off + 1] -
				  sizeof(struct in_addr),
				  &(ipo.ip_dst), sizeof(struct in_addr));
			    off = skip;
			    break;

			case IPOPT_EOL:
			    off = skip;
			    break;

			case IPOPT_NOP:
			    off++;
			    break;

			default:  /* Some other option, just skip it */
			    off += ptr[off + 1];
			    break;
		    }

		    /* Sanity check */
		    if (off > skip)
		    {
			DPRINTF(("ah_output(): malformed IPv4 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			ahstat.ahs_hdrops++;
			m_freem(m);
			return EMSGSIZE;
		    }
		}
	    }

	    /* Include IP header in authenticator computation */
	    ahx->Update(&ctx, (unsigned char *) &ipo, sizeof(struct ip));

	    /* IPv4 option processing */
	    for (off = sizeof(struct ip); off < skip;)
	    {
		switch (ptr[off])
		{
		    case IPOPT_EOL:
			ahx->Update(&ctx, ptr + off, 1);
			off = skip;  /* End the loop */
			break;

		    case IPOPT_NOP:
			ahx->Update(&ctx, ptr + off, 1);
			off++;
			break;

		    case IPOPT_SECURITY:	/* 0x82 */
		    case 0x85:	/* Extended security */
		    case 0x86:	/* Commercial security */
		    case 0x94:	/* Router alert */
		    case 0x95:	/* RFC1770 */
			ahx->Update(&ctx, ptr + off, ptr[off + 1]);
			off += ptr[off + 1];
			break;

		    default:
			ahx->Update(&ctx, ipseczeroes, ptr[off + 1]);
			off += ptr[off + 1];
			break;
		}

		/* Sanity check */
		if (off > skip)
		{
		    DPRINTF(("ah_output(): malformed IPv4 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		    ahstat.ahs_hdrops++;
		    m_freem(m);
		    return EMSGSIZE;
		}
	    }
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    /* Copy and "cook" the IPv6 header */
	    m_copydata(m, 0, sizeof(ip6), (unsigned char *) &ip6);

	    /* We don't do IPv6 Jumbograms */
	    if (ip6.ip6_plen == 0)
	    {
		DPRINTF(("ah_output(): unsupported IPv6 jumbogram in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_hdrops++;
		m_freem(m);
		return EMSGSIZE;
	    }

	    ip6.ip6_flow = 0;
	    ip6.ip6_hlim = 0;
	    ip6.ip6_vfc &= ~IPV6_VERSION_MASK;
	    ip6.ip6_vfc |= IPV6_VERSION;

	    /*
	     * Note that here we assume that on output, the IPv6 header
	     * and any Type0 Routing Header present have been made to look
	     * like the will at the destination. Note that this is a
	     * different assumption than we made for IPv4 (because of 
	     * different option processing in IPv4 and IPv6, and different
	     * code paths from IPv4/IPv6 to here).
	     */

	    /* Include IPv6 header in authenticator computation */
	    ahx->Update(&ctx, (unsigned char *) &ip6, sizeof(ip6));

	    /* Let's deal with the remaining headers (if any) */
	    if (skip - sizeof(struct ip6_hdr) > 0)
	    {
		if (m->m_len <= skip)
		{
		    MALLOC(ptr, unsigned char *,
			   skip - sizeof(struct ip6_hdr), M_XDATA, M_WAITOK);

		    /* Copy all the protocol headers after the IPv6 header */
		    m_copydata(m, sizeof(struct ip6_hdr),
			       skip - sizeof(struct ip6_hdr), ptr);
		}
		else
		  ptr = mtod(m, unsigned char *) + sizeof(struct ip6_hdr);
	    }
	    else
	      break; /* Done */

	    off = ip6.ip6_nxt & 0xff; /* Next header type */
	    for (len = 0; len < skip - sizeof(struct ip6_hdr);)
	      switch (off)
	      {
		  case IPPROTO_HOPOPTS:
		  case IPPROTO_DSTOPTS:
		      ip6e = (struct ip6_ext *) (ptr + len);

		      /*
		       * Process the mutable/immutable options -- borrows
		       * heavily from the KAME code.
		       */
		      for (last = len, count = len + sizeof(struct ip6_ext);
			   count < len + ((ip6e->ip6e_len + 1) << 3);)
		      {
			  if (ptr[count] == IP6OPT_PAD1)
			  {
			      count++;
			      continue;
			  }

			  /* Sanity check */
			  if (count + sizeof(struct ip6_ext) > len +
			      ((ip6e->ip6e_len + 1) << 3))
			  {
			      DPRINTF(("ah_output(): malformed IPv6 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			      ahstat.ahs_hdrops++;
			      m_freem(m);

			      /* Free, if we allocated */
			      if (m->m_len < skip)
				FREE(ptr, M_XDATA);
			      return EMSGSIZE;
			  }

			  /*
			   * If mutable option, calculate authenticator
			   * for all immutable fields so far, then include
			   * a zeroed-out version of this option.
			   */
			  if (ptr[count] & IP6OPT_MUTABLE)
			  {
			      /* Calculate immutables */
			      ahx->Update(&ctx, ptr + last, count + 2 - last);
			      last = count + ptr[count + 1];

			      /* Calculate "zeroed-out" immutables */
			      ahx->Update(&ctx, ipseczeroes,
					  ptr[count + 1] - 2);
			  }
			  
			  count += ptr[count + 1];

			  /* Sanity check */
			  if (count > skip - sizeof(struct ip6_hdr))
			  {
			      DPRINTF(("ah_output(): malformed IPv6 options header in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			      ahstat.ahs_hdrops++;
			      m_freem(m);

			      /* Free, if we allocated */
			      if (m->m_len < skip)
				FREE(ptr, M_XDATA);
			      return EMSGSIZE;
			  }
		      }

		      /* Include any trailing immutable options */
		      ahx->Update(&ctx, ptr + last,
				  len + ((ip6e->ip6e_len + 1) << 3) - last);

		      len += ((ip6e->ip6e_len + 1) << 3); /* Advance */
		      off = ip6e->ip6e_nxt;
		      break;

		  case IPPROTO_ROUTING:
		      ip6e = (struct ip6_ext *) (ptr + len);
		      ahx->Update(&ctx, ptr + len, (ip6e->ip6e_len + 1) << 3);
		      len += ((ip6e->ip6e_len + 1) << 3); /* Advance */
		      off = ip6e->ip6e_nxt;
		      break;
	      }
	    
	    /* Free, if we allocated */
	    if (m->m_len < skip)
	    {
		FREE(ptr, M_XDATA);
		ptr = NULL;
	    }

	    break;
#endif /* INET6 */

	default:
	    DPRINTF(("ah_output(): unsupported protocol family %d in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_nopf++;
	    m_freem(m);
	    return EPFNOSUPPORT;
d949 2
a950 2
    (*mp) = m_inject(m, skip, AH_FLENGTH + rplen + ahx->authsize, M_WAITOK);
    if ((*mp) == NULL)
d952 2
a953 1
	DPRINTF(("ah_output(): failed to inject AH header for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d963 1
a963 1
    ah = mtod((*mp), struct ah *);
d967 1
a967 1
    ah->ah_hl = (rplen + ahx->authsize) / sizeof(u_int32_t);
d971 3
d977 65
a1041 1
    /* Update the Next Protocol field in the IP header */
d1044 1
d1046 21
a1066 3
    /* Include the header AH in the authenticator computation */
    ahx->Update(&ctx, (unsigned char *) ah, AH_FLENGTH + rplen);
    ahx->Update(&ctx, ipseczeroes, ahx->authsize);
d1068 2
a1069 3
    /* Calculate the authenticator over the rest of the packet */
    len = m->m_pkthdr.len - (skip + AH_FLENGTH + rplen + ahx->authsize);
    off = AH_FLENGTH + rplen + ahx->authsize;
d1071 21
a1091 1
    while (len > 0)
d1093 4
a1096 1
	if ((*mp) == 0)
d1098 2
a1099 5
	    DPRINTF(("ah_output(): bad mbuf chain for packet in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    ahstat.ahs_hdrops++;
	    m_freem(m);
	    (*mp) = NULL;
	    return EMSGSIZE;
d1102 5
a1106 3
	count = min((*mp)->m_len - off, len);

	ahx->Update(&ctx, mtod((*mp), unsigned char *) + off, count);
d1108 7
a1114 3
	len -= count;
	off = 0;
	(*mp) = (*mp)->m_next;
d1117 7
a1123 4
    if ((ahx->type == SADB_X_AALG_MD5) || (ahx->type == SADB_X_AALG_SHA1))
      ahx->Update(&ctx, (unsigned char *) tdb->tdb_amxkey,
		  tdb->tdb_amxkeylen);
    else
d1125 5
a1129 4
	/* HMAC */
	ahx->Final(calcauth, &ctx);
	bcopy(tdb->tdb_octx, &ctx, ahx->ctxsize);
	ahx->Update(&ctx, calcauth, ahx->hashsize);
d1132 6
a1137 1
    ahx->Final(calcauth, &ctx);
d1139 1
a1139 2
    /* Copy the authenticator */
    bcopy(calcauth, ((caddr_t) ah) + AH_FLENGTH + rplen, ahx->authsize);
d1141 11
a1151 3
    *mp = m;
	
    return 0;
@


1.34.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a70 6
#include <sys/md5k.h>
#include <crypto/sha1.h>
#include <crypto/rmd160.h>
#include <crypto/crypto.h>
#include <crypto/xform.h>

d83 14
d113 1
a113 1
    struct cryptoini cria;
d115 5
a119 2
    /* Authentication operation */
    switch (ii->ii_authalg)
d121 3
a123 7
	case SADB_AALG_MD5HMAC96:
	    thash = &auth_hash_hmac_md5_96;
	    break;

	case SADB_AALG_SHA1HMAC96:
	    thash = &auth_hash_hmac_sha1_96;
	    break;
d125 1
a125 16
	case SADB_X_AALG_RIPEMD160HMAC96:
	    thash = &auth_hash_hmac_ripemd_160_96;
	    break;

	case SADB_X_AALG_MD5:
	    thash = &auth_hash_key_md5;
	    break;

	case SADB_X_AALG_SHA1:
	    thash = &auth_hash_key_sha1;
	    break;

	default:
	    DPRINTF(("ah_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
	    return EINVAL;
    }
d147 32
a178 5
    /* Initialize crypto session */
    bzero(&cria, sizeof(cria));
    cria.cri_alg = tdbp->tdb_authalgxform->type;
    cria.cri_klen = ii->ii_authkeylen * 8;
    cria.cri_key = ii->ii_authkey;
d180 3
a182 1
    return crypto_newsession(&tdbp->tdb_cryptoid, &cria);
d185 1
a185 3
/*
 * Paranoia.
 */
a188 2
    int err;

d196 19
a214 3
    err = crypto_freesession(tdbp->tdb_cryptoid);
    tdbp->tdb_cryptoid = 0;
    return err;
d218 2
a219 1
 * Massage IPv4/IPv6 headers for AH processing.
d221 3
a223 2
int
ah_massage_headers(struct mbuf **m0, int proto, int skip, int alg, int out)
d225 4
a228 1
    struct mbuf *m = *m0;
d230 3
a232 2
    int off, count;

d234 1
a234 1
    struct ip *ip;
d240 1
a240 1
    int alloc, len, ad;
d243 77
a319 1
    switch (proto)
d328 1
a328 1
	    *m0 = m = m_pullup(m, skip);
d331 2
a332 1
		DPRINTF(("ah_massage_headers(): m_pullup() failed\n"));
d334 1
a334 1
		return ENOBUFS;
d337 1
a337 5
	    /* Fix the IP header */
	    ip = mtod(m, struct ip *);
	    ip->ip_tos = 0;
	    ip->ip_ttl = 0;
	    ip->ip_sum = 0;
d339 2
a340 10
	    /*
	     * On input, fix ip_len and ip_id, which have been byte-swapped
	     * at ip_intr()
	     */
	    if (!out)
	    {
		ip->ip_len += skip;
		HTONS(ip->ip_len);
		HTONS(ip->ip_id);
	    }
d342 8
a349 2
	    if ((alg == CRYPTO_MD5_KPDK) || (alg == CRYPTO_SHA1_KPDK))
	      ip->ip_off = htons(ip->ip_off & IP_DF);
d351 3
a353 1
	      ip->ip_off = 0;
d355 2
a356 1
	    ptr = mtod(m, unsigned char *) + sizeof(struct ip);
d364 1
d369 1
d378 1
d382 1
a382 1
			    DPRINTF(("ah_massage_headers(): illegal zero-length IPv4 option %d\n", ptr[off]));
d385 1
a385 1
			    return EINVAL;
a390 15
		    case IPOPT_LSRR:
		    case IPOPT_SSRR:
			/*
			 * On output, if we have either of the source routing
			 * options, we should swap the destination address of
			 * the IP header with the last address specified in
			 * the option, as that is what the destination's
			 * IP header will look like.
			 */
			if (out)
			  bcopy(ptr + off + ptr[off + 1] -
				sizeof(struct in_addr),
				&(ip->ip_dst), sizeof(struct in_addr));

			/* Fall through */
d392 2
a393 13
			/* Sanity check for zero-length options */
			if (ptr[off + 1] == 0)
			{
			    DPRINTF(("ah_massage_headers(): illegal zero-length IPv4 option %d\n", ptr[off]));
			    ahstat.ahs_hdrops++;
			    m_freem(m);
			    return EINVAL;
			}

			/* Zeroize all other options */
			count = ptr[off + 1];
			bcopy(ipseczeroes, ptr, count);
			off += count;
d400 1
a400 1
		    DPRINTF(("ah_massage_headers(): malformed IPv4 options header\n"));
d403 1
a403 1
		    return EINVAL;
d412 2
a413 2
	    /* Copy and "cook" the IPv6 header */
	    m_copydata(m, 0, sizeof(ip6), (caddr_t) &ip6);
d418 1
a418 1
		DPRINTF(("ah_massage_headers(): unsupported IPv6 jumbogram"));
d421 1
a421 1
		return EMSGSIZE;
d429 3
a431 3
	    /* Done with IPv6 header */
	    m_copyback(m, 0, sizeof(struct ip6_hdr), (caddr_t) &ip6);
	    
d438 1
a438 8
			   M_XDATA, M_DONTWAIT);
		    if (ptr == NULL)
		    {
			DPRINTF(("ah_massage_headers(): failed to allocate memory for IPv6 headers\n"));
			ahstat.ahs_hdrops++;
			m_freem(m);
			return ENOBUFS;
		    }
a442 1
		    alloc = 1;
d445 1
a445 5
		{
		    /* No need to allocate memory */
		    ptr = mtod(m, unsigned char *) + sizeof(struct ip6_hdr);
		    alloc = 0;
		}
d463 1
a463 1
		      for (count = len + sizeof(struct ip6_ext);
d469 1
a469 1
			      continue; /* Skip padding */
d473 2
a474 1
			  if (count > len + ((ip6e->ip6e_len + 1) << 3))
d476 1
a476 1
			      DPRINTF(("ah_massage_headers(): malformed IPv6 options header\n"));
d481 6
a486 4
			      if (alloc)
				FREE(ptr, M_XDATA);

			      return EINVAL;
d489 5
a493 3
			  ad = ptr[count + 1];

			  /* If mutable option, zeroize */
d495 14
a508 3
			    bcopy(ipseczeroes, ptr + count, ptr[count + 1]);

			  count += ad;
d513 1
a513 1
			      DPRINTF(("ah_massage_headers(): malformed IPv6 options header\n"));
d518 6
a523 4
			      if (alloc)
				FREE(ptr, M_XDATA);

			      return EINVAL;
d527 4
a535 1
		      /* Always include routing headers in computation */
d537 1
d543 3
a545 6
		      DPRINTF(("ah_massage_headers(): unexpected IPv6 header type %d\n", off));
		      if (alloc)
			FREE(ptr, M_XDATA);
		      ahstat.ahs_hdrops++;
		      m_freem(m);
		      return EINVAL;
d548 2
a549 2
	    /* Copyback and free, if we allocated */
	    if (alloc)
a550 2
		m_copyback(m, sizeof(struct ip6_hdr),
			   skip - sizeof(struct ip6_hdr), ptr);
d552 1
a556 1
    }
d558 5
a562 59
    return 0;
}

/*
 * ah_input() gets called to verify that an input packet
 * passes authentication.
 */
int
ah_input(struct mbuf *m, struct tdb *tdb, int skip, int protoff)
{
    struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    u_int32_t btsx;
    u_int8_t hl;
    int rplen;

    struct cryptodesc *crda = NULL;
    struct cryptop *crp;

    if (!(tdb->tdb_flags & TDBF_NOREPLAY))
      rplen = AH_FLENGTH + sizeof(u_int32_t);
    else
      rplen = AH_FLENGTH;

    /* Save the AH header, we use it throughout */
    m_copydata(m, skip + offsetof(struct ah, ah_hl), sizeof(u_int8_t),
	       (caddr_t) &hl);

    /* Replay window checking, if applicable */
    if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY)))
    {
	m_copydata(m, skip + offsetof(struct ah, ah_rpl), sizeof(u_int32_t),
		   (caddr_t) &btsx);
	btsx = ntohl(btsx);

	switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
				    tdb->tdb_wnd, &(tdb->tdb_bitmap)))
	{
	    case 0: /* All's well */
		break;

	    case 1:
		DPRINTF(("ah_input(): replay counter wrapped for SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_wrap++;
		m_freem(m);
		return ENOBUFS;

	    case 2:
	    case 3:
		DPRINTF(("ah_input(): duplicate packet received in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_replay++;
		m_freem(m);
		return ENOBUFS;

	    default:
                DPRINTF(("ah_input(): bogus value from checkreplaywindow32() in SA %s/%08x\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		ahstat.ahs_replay++;
                m_freem(m);
                return ENOBUFS;
	}
d565 3
a567 8
    /* Verify AH header length */
    if (hl * sizeof(u_int32_t) != ahx->authsize + rplen - AH_FLENGTH)
    {
	DPRINTF(("ah_input(): bad authenticator length %d for packet in SA %s/%08x\n", hl * sizeof(u_int32_t), ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_badauthl++;
	m_freem(m);
	return EACCES;
    }
d569 1
a569 25
    /* Update the counters */
    tdb->tdb_cur_bytes += (m->m_pkthdr.len - skip - hl * sizeof(u_int32_t));
    ahstat.ahs_ibytes += (m->m_pkthdr.len - skip - hl * sizeof(u_int32_t));

    /* Hard expiration */
    if ((tdb->tdb_flags & TDBF_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes))
      {
	  pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
	  tdb_delete(tdb, 0, TDBEXP_TIMEOUT);
	  m_freem(m);
	  return ENXIO;
      }

    /* Notify on expiration */
    if ((tdb->tdb_flags & TDBF_SOFT_BYTES) &&
	(tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes))
    {
	pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
	tdb->tdb_flags &= ~TDBF_SOFT_BYTES;     /* Turn off checking */
    }

    /* Get crypto descriptors */
    crp = crypto_getreq(1);
    if (crp == NULL)
d571 3
d575 1
a575 3
	DPRINTF(("ah_input(): failed to acquire crypto descriptors\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
d577 2
d580 5
a584 1
    crda = crp->crp_desc;
d586 1
a586 16
    crda->crd_skip = 0;
    crda->crd_len = m->m_pkthdr.len;
    crda->crd_inject = skip + rplen;

    /* Authentication operation */
    crda->crd_alg = ahx->type;
    crda->crd_key = tdb->tdb_amxkey;
    crda->crd_klen = tdb->tdb_amxkeylen * 8;

    /*
     * Save the authenticator, the skipped portion of the packet, and the
     * AH header.
     */
    MALLOC(crp->crp_opaque4, caddr_t, skip + rplen + ahx->authsize,
	   M_XDATA, M_DONTWAIT);
    if (crp->crp_opaque4 == 0)
d588 3
d592 1
a592 4
	crypto_freereq(crp);
	DPRINTF(("ah_input(): failed to allocate auth array\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
d594 2
d597 2
a598 25
    /* Save data */
    m_copydata(m, 0, skip + rplen + ahx->authsize, crp->crp_opaque4);

    /* Zeroize the authenticator on the packet */
    m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes);

    /* "Massage" the packet headers for crypto processing */
    if ((btsx = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
				   skip, ahx->type, 0)) != 0)
    {
	/* mbuf will be free'd by callee */
	FREE(crp->crp_opaque4, M_XDATA);

	crypto_freereq(crp);
	return btsx;
    }

    tdb->tdb_ref++;

    /* Crypto operation descriptor */
    crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
    crp->crp_flags = CRYPTO_F_IMBUF;
    crp->crp_buf = (caddr_t) m;
    crp->crp_callback = (int (*) (struct cryptop *)) ah_input_cb;
    crp->crp_sid = tdb->tdb_cryptoid;
d600 2
a601 4
    /* These are passed as-is to the callback */
    crp->crp_opaque1 = (caddr_t) tdb;
    (long) crp->crp_opaque2 = skip;
    (long) crp->crp_opaque3 = protoff;
d603 2
a604 26
    return crypto_dispatch(crp);
}

/*
 * AH input callback, called directly by the crypto driver.
 */
int
ah_input_cb(void *op)
{ 
    int roff, rplen, error, skip, protoff;
    unsigned char calc[AH_ALEN_MAX];
    struct mbuf *m1, *m0, *m;
    struct cryptodesc *crd;
    struct auth_hash *ahx;
    struct cryptop *crp;
    struct tdb *tdb;

    crp = (struct cryptop *) op;
    crd = crp->crp_desc;
    tdb = (struct tdb *) crp->crp_opaque1;
    ahx = (struct auth_hash *) tdb->tdb_authalgxform;
    skip = (long) crp->crp_opaque2;
    protoff = (long) crp->crp_opaque3;
    m = (struct mbuf *) crp->crp_buf;

    tdb->tdb_ref--;
d606 2
a607 2
    /* Check for crypto errors */
    if (crp->crp_etype)
d609 1
a609 4
        if (tdb->tdb_cryptoid != 0)
	  tdb->tdb_cryptoid = crp->crp_sid;

	if (crp->crp_etype == EAGAIN)
d611 4
a614 2
	    tdb->tdb_ref++;
	    return crypto_dispatch(crp);
d617 3
a619 5
	ahstat.ahs_noxform++;
	DPRINTF(("ah_input_cb(): crypto error %d\n", crp->crp_etype));
	error = crp->crp_etype;
	goto baddone;
    }
d621 3
a623 7
    /* Shouldn't happen... */
    if (!m)
    {
	ahstat.ahs_crypto++;
	DPRINTF(("ah_input_cb(): bogus returned buffer from crypto\n"));
	error = EINVAL;
	goto baddone;
d626 2
a627 7
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
d629 3
a631 5
	ahstat.ahs_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("ah_input_cb(): TDB expired while processing crypto\n"));
	goto baddone;
a632 3

    if (!(tdb->tdb_flags & TDBF_NOREPLAY))
      rplen = AH_FLENGTH + sizeof(u_int32_t);
d634 7
a640 1
      rplen = AH_FLENGTH;
d642 2
a643 5
    /* Copy computed authenticator */
    m_copydata(m, skip + rplen, ahx->authsize, calc);

    /* Verify authenticator */
    if (bcmp(crp->crp_opaque4 + skip + rplen, calc, ahx->authsize))
d647 2
a648 2
	error = EACCES;
	goto baddone;
d652 1
a652 2
    ((u_int8_t *) crp->crp_opaque4)[protoff] =
				((u_int8_t *) crp->crp_opaque4)[skip];
d654 7
a660 23
    /* Copyback the saved (uncooked) network headers */
    m_copyback(m, 0, skip, crp->crp_opaque4);

    /* No longer needed */
    FREE(crp->crp_opaque4, M_XDATA);
    crypto_freereq(crp);

    /* Record the beginning of the AH header */
    m1 = m_getptr(m, skip, &roff);
    if (m1 == NULL)
    {
	DPRINTF(("ah_input(): bad mbuf chain for packet in SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	ahstat.ahs_hdrops++;
	m_freem(m);
	return EINVAL;
    }

    /* Remove the AH header from the mbuf */
    if (roff == 0) 
    {
	/* The AH header was conveniently at the beginning of the mbuf */
	m_adj(m1, rplen + ahx->authsize);
d662 1
a662 1
	  m->m_pkthdr.len -= rplen + ahx->authsize;
d665 1
a665 1
      if (roff + rplen + ahx->authsize >= m1->m_len)
d672 1
a672 1
	  if (roff + rplen + ahx->authsize > m1->m_len)
d675 2
a676 1
	      m_adj(m1->m_next, roff + rplen + ahx->authsize - m1->m_len);
d679 2
a680 1
	      m->m_pkthdr.len -= (roff + rplen + ahx->authsize - m1->m_len);
d702 1
a702 1
	  bcopy(mtod(m1, u_char *) + roff + rplen + ahx->authsize,
d704 3
a706 3
		m1->m_len - (roff + rplen + ahx->authsize));
	  m1->m_len -= rplen + ahx->authsize;
	  m->m_pkthdr.len -= rplen + ahx->authsize;
d709 1
a709 13
    return ipsec_common_input_cb(m, tdb, skip, protoff);

 baddone:
    if (m)
      m_freem(m);

    /* We have to free this manually */
    if (crp && crp->crp_opaque4)
      FREE(crp->crp_opaque4, M_XDATA);

    crypto_freereq(crp);

    return error;
a711 3
/*
 * AH output routine, called by ipsp_process_packet().
 */
d714 1
a714 1
	  int protoff)
d717 5
a721 5
    struct cryptodesc *crda;
    struct mbuf *mo, *mi;
    struct cryptop *crp;
    u_int16_t iplen;
    int len, rplen;
d724 10
d774 1
a774 1
      rplen = AH_FLENGTH + sizeof(u_int32_t);
d776 1
a776 1
      rplen = AH_FLENGTH;
d778 3
a780 1
    switch (tdb->tdb_dst.sa.sa_family)
d782 6
a787 12
#ifdef INET
	case AF_INET:
	    /* Check for IP maximum packet size violations */
	    if (rplen + ahx->authsize + m->m_pkthdr.len > IP_MAXPACKET)
	    {
		DPRINTF(("ah_output(): packet in SA %s/%08x got too big\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		ahstat.ahs_toobig++;
		return EMSGSIZE;
	    }
	    break;
d791 10
a800 11
	case AF_INET6:
	    /* Check for IPv6 maximum packet size violations */
	    if (rplen + ahx->authsize + m->m_pkthdr.len > IPV6_MAXPACKET)
	    {
		DPRINTF(("ah_output(): packet in SA %s/%08x got too big\n",
			 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		ahstat.ahs_toobig++;
		return EMSGSIZE;
	    }
	    break;
a802 7
	default:
	    DPRINTF(("ah_output(): unknown/unsupported protocol family %d, SA %s/%08x\n", tdb->tdb_dst.sa.sa_family, ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
	    m_freem(m);
	    ahstat.ahs_nopf++;
	    return EPFNOSUPPORT;
    }

d828 3
d832 5
a836 5
    mi = m;
    while (mi != NULL && 
	   (!(mi->m_flags & M_EXT) || 
	    (mi->m_ext.ext_ref == NULL &&
	     mclrefcnt[mtocl(mi->m_ext.ext_buf)] <= 1)))
d838 2
a839 2
        mo = mi;
        mi = mi->m_next;
d842 1
a842 1
    if (mi != NULL)
d845 1
a845 1
        struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);
d859 303
a1161 1
        m_freem(mi);
d1165 2
a1166 2
    mi = m_inject(m, skip, rplen + ahx->authsize, M_DONTWAIT);
    if (mi == NULL)
d1168 1
a1168 2
	DPRINTF(("ah_output(): failed to inject AH header for SA %s/%08x\n",
		 ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
d1178 1
a1178 1
    ah = mtod(mi, struct ah *);
d1182 1
a1182 1
    ah->ah_hl = (rplen + ahx->authsize - AH_FLENGTH) / sizeof(u_int32_t);
a1185 3
    /* Zeroize authenticator */
    m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes);

d1189 1
a1189 65
    /* Get crypto descriptors */
    crp = crypto_getreq(1);
    if (crp == NULL)
    {
	m_freem(m);
	DPRINTF(("ah_output(): failed to acquire crypto descriptors\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }

    crda = crp->crp_desc;

    crda->crd_skip = 0;
    crda->crd_inject = skip + rplen;
    crda->crd_len = m->m_pkthdr.len;

    /* Authentication operation */
    crda->crd_alg = ahx->type;
    crda->crd_key = tdb->tdb_amxkey;
    crda->crd_klen = tdb->tdb_amxkeylen * 8;

    /* Save the skipped portion of the packet */
    MALLOC(crp->crp_opaque4, caddr_t, skip, M_XDATA, M_DONTWAIT);
    if (crp->crp_opaque4 == 0)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("ah_output(): failed to allocate auth array\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }
    else
      m_copydata(m, 0, skip, crp->crp_opaque4);

    /*
     * Fix IP header length on the header used for authentication. We don't
     * need to fix the original header length as it will be fixed by our
     * caller.
     */
    switch (tdb->tdb_dst.sa.sa_family)
    {
#ifdef INET
	case AF_INET:
	    bcopy(crp->crp_opaque4 + offsetof(struct ip, ip_len),
		  (caddr_t) &iplen, sizeof(u_int16_t));
	    iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
	    m_copyback(m, offsetof(struct ip, ip_len), sizeof(u_int16_t),
		       (caddr_t) &iplen);
	    break;
#endif /* INET */

#ifdef INET6
	case AF_INET6:
	    bcopy(crp->crp_opaque4 + offsetof(struct ip6_hdr, ip6_plen),
		  (caddr_t) &iplen, sizeof(u_int16_t));
	    iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
	    m_copyback(m, offsetof(struct ip6_hdr, ip6_plen),
		       sizeof(u_int16_t), (caddr_t) &iplen);
	    break;
#endif /* INET6 */
    }

    tdb->tdb_ref++;

    /* Update the Next Protocol field in the IP header and the saved data */
a1191 1
    ((u_int8_t *) crp->crp_opaque4)[protoff] = IPPROTO_AH;
d1193 3
a1195 21
    /* "Massage" the packet headers for crypto processing */
    if ((len = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
				  skip, ahx->type, 1)) != 0)
    {
	/* mbuf will be free'd by callee */
	FREE(crp->crp_opaque4, M_XDATA);
	crypto_freereq(crp);
	return len;
    }

    /* Crypto operation descriptor */
    crp->crp_ilen = m->m_pkthdr.len; /* Total input length */
    crp->crp_flags = CRYPTO_F_IMBUF;
    crp->crp_buf = (caddr_t) m;
    crp->crp_callback = (int (*) (struct cryptop *)) ah_output_cb;
    crp->crp_sid = tdb->tdb_cryptoid;

    /* These are passed as-is to the callback */
    crp->crp_opaque1 = (caddr_t) tdb;
    (long) crp->crp_opaque2 = skip;
    (long) crp->crp_opaque3 = protoff;
d1197 3
a1199 2
    return crypto_dispatch(crp);
}
d1201 1
a1201 21
/*
 * AH output callback, called directly from the crypto handler.
 */
int
ah_output_cb(void *op)
{
    int skip, protoff, error;
    struct cryptop *crp;
    struct tdb *tdb;
    struct mbuf *m;

    crp = (struct cryptop *) op;
    tdb = (struct tdb *) crp->crp_opaque1;
    skip = (long) crp->crp_opaque2;
    protoff = (long) crp->crp_opaque3;
    m = (struct mbuf *) crp->crp_buf;

    tdb->tdb_ref--;

    /* Check for crypto errors */
    if (crp->crp_etype)
d1203 1
a1203 4
        if (tdb->tdb_cryptoid != 0)
	  tdb->tdb_cryptoid = crp->crp_sid;

	if (crp->crp_etype == EAGAIN)
d1205 5
a1209 2
	    tdb->tdb_ref++;
	    return crypto_dispatch(crp);
d1212 3
a1214 5
	ahstat.ahs_noxform++;
	DPRINTF(("ah_output_cb(): crypto error %d\n", crp->crp_etype));
	error = crp->crp_etype;
	goto baddone;
    }
d1216 3
a1218 7
    /* Shouldn't happen... */
    if (!m)
    {
	ahstat.ahs_crypto++;
	DPRINTF(("ah_output_cb(): bogus returned buffer from crypto\n"));
	error = EINVAL;
	goto baddone;
d1221 4
a1224 7
    /*
     * Check that the TDB is still valid -- not really an error, but
     * we need to handle it as such. It may happen if the TDB expired
     * or was deleted while there was a pending request in the crypto
     * queue.
     */
    if (tdb->tdb_flags & TDBF_INVALID)
d1226 4
a1229 5
	ahstat.ahs_invalid++;
	tdb_delete(tdb, 0, 0);
	error = ENXIO;
	DPRINTF(("ah_output_cb(): TDB expired while processing crypto\n"));
	goto baddone;
d1232 1
a1232 2
    /* Copy original headers (with the new protocol number) back in place */
    m_copyback(m, 0, skip, crp->crp_opaque4);
d1234 2
a1235 3
    /* No longer needed */
    FREE(crp->crp_opaque4, M_XDATA);
    crypto_freereq(crp);
d1237 3
a1239 13
    return ipsp_process_done(m, tdb);

 baddone:
    if (m)
      m_freem(m);

    /* We have to free this manually */
    if (crp && crp->crp_opaque4)
      FREE(crp->crp_opaque4, M_XDATA);

    crypto_freereq(crp);

    return error;
@


1.34.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.50 2001/04/14 00:30:58 angelos Exp $ */
d5 1
a5 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
d8 2
a9 2
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
d17 1
a17 1
 * Additional features in 1999 by Angelos D. Keromytis and Niklas Hallqvist.
d19 1
a19 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
d21 1
a21 2
 * Copyright (c) 1999 Niklas Hallqvist.
 *
d25 1
a25 1
 * modification of this software.
d85 4
d110 1
a110 1
	case SADB_AALG_MD5HMAC:
d114 1
a114 1
	case SADB_AALG_SHA1HMAC:
d118 1
a118 1
	case SADB_AALG_RIPEMD160HMAC:
d236 1
d238 4
a241 12
	        if ((alg == CRYPTO_MD5_KPDK) || (alg == CRYPTO_SHA1_KPDK))
	          ip->ip_off = htons(ip->ip_off & IP_DF);
	        else
	          ip->ip_off = 0;
	    }
            else
            {
	        if ((alg == CRYPTO_MD5_KPDK) || (alg == CRYPTO_SHA1_KPDK))
	          ip->ip_off = htons(ntohs(ip->ip_off) & IP_DF);
	        else
	          ip->ip_off = 0;
            }
a247 11
		if (ptr[off] == IPOPT_EOL || ptr[off] == IPOPT_NOP ||
		    off + 1 < skip)
		    ;
		else
		{
		    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
		    ahstat.ahs_hdrops++;
		    m_freem(m);
		    return EINVAL;
		}

d263 2
a264 2
			/* Sanity check for option length */
			if (ptr[off + 1] < 2)
d266 1
a266 1
			    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
a276 9
			/* Sanity check for option length */
			if (ptr[off + 1] < 2)
			{
			    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
			    ahstat.ahs_hdrops++;
			    m_freem(m);
			    return EINVAL;
			}

d291 2
a292 2
			/* Sanity check for option length */
			if (ptr[off + 1] < 2)
d294 1
a294 1
			    DPRINTF(("ah_massage_headers(): illegal IPv4 option length for option %d\n", ptr[off]));
a338 6
	    /* scoped address handling */
	    if (IN6_IS_SCOPE_LINKLOCAL(&ip6.ip6_src))
		ip6.ip6_src.s6_addr16[1] = 0;
	    if (IN6_IS_SCOPE_LINKLOCAL(&ip6.ip6_dst))
		ip6.ip6_dst.s6_addr16[1] = 0;

d341 1
a341 1

d348 1
a348 1
			   M_XDATA, M_NOWAIT);
a473 1
    struct tdb_crypto *tc;
d542 1
a542 1
	  tdb_delete(tdb);
a575 13
    /* Allocate IPsec-specific opaque crypto info */
    MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
	   M_XDATA, M_NOWAIT);
    bzero(tc, sizeof(struct tdb_crypto));
    if (tc == NULL)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("ah_input(): failed to allocate tdb_crypto\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }

d580 3
a582 3
    MALLOC(tc->tc_ptr, caddr_t, skip + rplen + ahx->authsize,
	   M_XDATA, M_NOWAIT);
    if (tc->tc_ptr == 0)
a584 1
	FREE(tc, M_XDATA);
d592 1
a592 1
    m_copydata(m, 0, skip + rplen + ahx->authsize, tc->tc_ptr);
d602 2
a603 2
	FREE(tc->tc_ptr, M_XDATA);
	FREE(tc, M_XDATA);
d608 2
a615 1
    crp->crp_opaque = (caddr_t) tc;
d618 3
a620 5
    tc->tc_skip = skip;
    tc->tc_protoff = protoff;
    tc->tc_spi = tdb->tdb_spi;
    tc->tc_proto = tdb->tdb_sproto;
    bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));
d630 1
a630 1
{
a635 1
    struct tdb_crypto *tc;
a637 2
    caddr_t ptr = 0;
    int s, err;
d641 4
a644 5

    tc = (struct tdb_crypto *) crp->crp_opaque;
    skip = tc->tc_skip;
    protoff = tc->tc_protoff;
    ptr = tc->tc_ptr;
d647 1
a647 12
    s = spltdb();

    tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
    FREE(tc, M_XDATA);
    if (tdb == NULL)
    {
	ahstat.ahs_notdb++;
	DPRINTF(("ah_input_cb(): TDB is expired while in crypto"));
	goto baddone;
    }

    ahx = (struct auth_hash *) tdb->tdb_authalgxform;
d656 4
a659 4
        {
            splx(s);
            return crypto_dispatch(crp);
        }
d676 15
d700 1
a700 1
    if (bcmp(ptr + skip + rplen, calc, ahx->authsize))
d709 2
a710 2
    ((u_int8_t *) ptr)[protoff] =
				((u_int8_t *) ptr)[skip];
d713 1
a713 1
    m_copyback(m, 0, skip, ptr);
d716 1
a716 1
    FREE(ptr, M_XDATA);
a722 2
	ahstat.ahs_hdrops++;
        splx(s);
d725 1
d731 1
a731 1
    if (roff == 0)
d769 1
a769 1
	  /*
d781 1
a781 3
    err = ipsec_common_input_cb(m, tdb, skip, protoff);
    splx(s);
    return err;
a783 2
    splx(s);

d788 2
a789 2
    if (ptr)
      FREE(ptr, M_XDATA);
d801 1
a801 1
	  int protoff, struct tdb *tdb2)
a804 1
    struct tdb_crypto *tc;
a807 1
    u_int8_t prot;
d827 4
a830 1
	ifn = &(encif[0].sc_if);
d901 1
a901 1
	  tdb_delete(tdb);
d915 1
a915 1
     * Loop through mbuf chain; if we find an M_EXT mbuf with
d919 2
a920 2
    while (mi != NULL &&
	   (!(mi->m_flags & M_EXT) ||
d927 1
a927 1

d932 1
a932 1

d964 1
a964 1

a997 13
    /* Allocate IPsec-specific opaque crypto info */
    MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto), M_XDATA,
	   M_NOWAIT);
    bzero(tc, sizeof(struct tdb_crypto));
    if (tc == NULL)
    {
	m_freem(m);
	crypto_freereq(crp);
	DPRINTF(("ah_output(): failed to allocate tdb_crypto\n"));
	ahstat.ahs_crypto++;
	return ENOBUFS;
    }

d999 2
a1000 2
    MALLOC(tc->tc_ptr, caddr_t, skip, M_XDATA, M_NOWAIT);
    if (tc->tc_ptr == 0)
a1001 1
	FREE(tc, M_XDATA);
d1009 1
a1009 1
      m_copydata(m, 0, skip, tc->tc_ptr);
d1020 1
a1020 1
	    bcopy(tc->tc_ptr + offsetof(struct ip, ip_len),
d1030 1
a1030 1
	    bcopy(tc->tc_ptr + offsetof(struct ip6_hdr, ip6_plen),
d1039 2
d1042 3
a1044 3
    prot = IPPROTO_AH;
    m_copyback(m, protoff, sizeof(u_int8_t), (caddr_t) &prot);
    ((u_int8_t *) tc->tc_ptr)[protoff] = IPPROTO_AH;
d1051 1
a1051 2
	FREE(tc->tc_ptr, M_XDATA);
	FREE(tc, M_XDATA);
a1061 1
    crp->crp_opaque = (caddr_t) tc;
d1064 3
a1066 12
    tc->tc_skip = skip;
    tc->tc_protoff = protoff;
    tc->tc_spi = tdb->tdb_spi;
    tc->tc_proto = tdb->tdb_sproto;
    bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

    if (tdb2)
    {
	tc->tc_spi2 = tdb2->tdb_spi;
	tc->tc_proto2 = tdb2->tdb_sproto;
	bcopy(&tdb2->tdb_dst, &tc->tc_dst2, sizeof(union sockaddr_union));
    }
a1076 1
    struct tdb *tdb, *tdb2 = NULL;
a1077 1
    struct tdb_crypto *tc;
d1079 1
a1079 1
    caddr_t ptr = 0;
a1080 1
    int err, s;
d1083 3
a1085 4
    tc = (struct tdb_crypto *) crp->crp_opaque;
    skip = tc->tc_skip;
    protoff = tc->tc_protoff;
    ptr = tc->tc_ptr;
d1088 1
a1088 13
    s = spltdb();

    tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
    if (tc->tc_spi2)
      tdb2 = gettdb(tc->tc_spi2, &tc->tc_dst2, tc->tc_proto2);

    FREE(tc, M_XDATA);
    if (tdb == NULL)
    {
	ahstat.ahs_notdb++;
	DPRINTF(("ah_output_cb(): TDB is expired while in crypto\n"));
	goto baddone;
    }
d1097 4
a1100 4
        {
            splx(s);
            return crypto_dispatch(crp);
        }
d1117 15
d1133 1
a1133 1
    m_copyback(m, 0, skip, ptr);
d1136 1
a1136 1
    FREE(ptr, M_XDATA);
d1139 1
a1139 3
    err =  ipsp_process_done(m, tdb, tdb2);
    splx(s);
    return err;
a1141 2
    splx(s);

d1146 2
a1147 2
    if (ptr)
      FREE(ptr, M_XDATA);
@


1.34.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$ */
a21 1
 * Copyright (c) 2001 Angelos D. Keromytis.
d23 1
a23 1
 * Permission to use, copy, and modify this software with or without fee
d41 1
d43 2
d46 6
d54 3
a58 1
#ifdef INET
a61 1
#endif /* INET */
a63 3
#ifndef INET
#include <netinet/in.h>
#endif /* INET */
d72 4
a75 1
#include <crypto/cryptodev.h>
d87 1
a87 1
 * ah_attach() is called from the transformation initialization code.
d92 1
a92 1
	return 0;
d101 2
a102 2
	struct auth_hash *thash = NULL;
	struct cryptoini cria;
d104 3
a106 2
	/* Authentication operation. */
	switch (ii->ii_authalg) {
d108 2
a109 2
		thash = &auth_hash_hmac_md5_96;
		break;
d112 2
a113 2
		thash = &auth_hash_hmac_sha1_96;
		break;
d116 2
a117 2
		thash = &auth_hash_hmac_ripemd_160_96;
		break;
d120 2
a121 2
		thash = &auth_hash_key_md5;
		break;
d124 2
a125 2
		thash = &auth_hash_key_sha1;
		break;
d128 29
a156 30
		DPRINTF(("ah_init(): unsupported authentication algorithm %d specified\n", ii->ii_authalg));
		return EINVAL;
	}

	if (ii->ii_authkeylen != thash->keysize && thash->keysize != 0) {
		DPRINTF(("ah_init(): keylength %d doesn't match algorithm "
		    "%s keysize (%d)\n", ii->ii_authkeylen, thash->name,
		    thash->keysize));
		return EINVAL;
	}

	tdbp->tdb_xform = xsp;
	tdbp->tdb_authalgxform = thash;
	tdbp->tdb_bitmap = 0;
	tdbp->tdb_rpl = AH_HMAC_INITIAL_RPL;

	DPRINTF(("ah_init(): initialized TDB with hash algorithm %s\n",
	    thash->name));

	tdbp->tdb_amxkeylen = ii->ii_authkeylen;
	MALLOC(tdbp->tdb_amxkey, u_int8_t *, tdbp->tdb_amxkeylen, M_XDATA,
	    M_WAITOK);

	bcopy(ii->ii_authkey, tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);

	/* Initialize crypto session. */
	bzero(&cria, sizeof(cria));
	cria.cri_alg = tdbp->tdb_authalgxform->type;
	cria.cri_klen = ii->ii_authkeylen * 8;
	cria.cri_key = ii->ii_authkey;
d158 1
a158 1
	return crypto_newsession(&tdbp->tdb_cryptoid, &cria, 0);
d167 1
a167 1
	int err;
d169 10
a178 9
	if (tdbp->tdb_amxkey) {
		bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
		FREE(tdbp->tdb_amxkey, M_XDATA);
		tdbp->tdb_amxkey = NULL;
	}

	err = crypto_freesession(tdbp->tdb_cryptoid);
	tdbp->tdb_cryptoid = 0;
	return err;
d187 3
a189 3
	struct mbuf *m = *m0;
	unsigned char *ptr;
	int off, count;
d192 1
a192 1
	struct ip *ip;
d196 3
a198 3
	struct ip6_ext *ip6e;
	struct ip6_hdr ip6;
	int alloc, len, ad;
d201 2
a202 1
	switch (proto) {
d205 56
a260 10
		/*
		 * This is the least painful way of dealing with IPv4 header
		 * and option processing -- just make sure they're in
		 * contiguous memory.
		 */
		*m0 = m = m_pullup(m, skip);
		if (m == NULL) {
			DPRINTF(("ah_massage_headers(): m_pullup() failed\n"));
			ahstat.ahs_hdrops++;
			return ENOBUFS;
d263 5
a267 24
		/* Fix the IP header */
		ip = mtod(m, struct ip *);
		ip->ip_tos = 0;
		ip->ip_ttl = 0;
		ip->ip_sum = 0;

		/*
		 * On input, fix ip_len which has been byte-swapped
		 * at ip_input().
		 */
		if (!out) {
			ip->ip_len += skip;
			HTONS(ip->ip_len);

			if (alg == CRYPTO_MD5_KPDK || alg == CRYPTO_SHA1_KPDK)
				ip->ip_off = htons(ip->ip_off & IP_DF);
			else
				ip->ip_off = 0;
		} else {
			if (alg == CRYPTO_MD5_KPDK || alg == CRYPTO_SHA1_KPDK)
				ip->ip_off = htons(ntohs(ip->ip_off) & IP_DF);
			else
				ip->ip_off = 0;
		}
d269 3
a271 1
		ptr = mtod(m, unsigned char *) + sizeof(struct ip);
d273 12
a284 13
		/* IPv4 option processing */
		for (off = sizeof(struct ip); off < skip;) {
			if (ptr[off] == IPOPT_EOL || ptr[off] == IPOPT_NOP ||
			    off + 1 < skip)
				;
			else {
				DPRINTF(("ah_massage_headers(): illegal IPv4 "
				    "option length for option %d\n",
				    ptr[off]));

				ahstat.ahs_hdrops++;
				m_freem(m);
				return EINVAL;
d287 12
a298 72
			switch (ptr[off]) {
			case IPOPT_EOL:
				off = skip;  /* End the loop. */
				break;

			case IPOPT_NOP:
				off++;
				break;

			case IPOPT_SECURITY:	/* 0x82 */
			case 0x85:	/* Extended security. */
			case 0x86:	/* Commercial security. */
			case 0x94:	/* Router alert */
			case 0x95:	/* RFC1770 */
				/* Sanity check for option length. */
				if (ptr[off + 1] < 2) {
					DPRINTF(("ah_massage_headers(): "
					    "illegal IPv4 option length for "
					    "option %d\n", ptr[off]));

					ahstat.ahs_hdrops++;
					m_freem(m);
					return EINVAL;
				}

				off += ptr[off + 1];
				break;

			case IPOPT_LSRR:
			case IPOPT_SSRR:
				/* Sanity check for option length. */
				if (ptr[off + 1] < 2) {
					DPRINTF(("ah_massage_headers(): "
					    "illegal IPv4 option length for "
					    "option %d\n", ptr[off]));

					ahstat.ahs_hdrops++;
					m_freem(m);
					return EINVAL;
				}

				/*
				 * On output, if we have either of the
				 * source routing options, we should
				 * swap the destination address of the
				 * IP header with the last address
				 * specified in the option, as that is
				 * what the destination's IP header
				 * will look like.
				 */
				if (out)
					bcopy(ptr + off + ptr[off + 1] -
					    sizeof(struct in_addr),
					    &(ip->ip_dst), sizeof(struct in_addr));

				/* Fall through */
			default:
				/* Sanity check for option length. */
				if (ptr[off + 1] < 2) {
					DPRINTF(("ah_massage_headers(): "
					    "illegal IPv4 option length for "
					    "option %d\n", ptr[off]));
					ahstat.ahs_hdrops++;
					m_freem(m);
					return EINVAL;
				}

				/* Zeroize all other options. */
				count = ptr[off + 1];
				bcopy(ipseczeroes, ptr, count);
				off += count;
				break;
d301 21
a321 8
			/* Sanity check. */
			if (off > skip)	{
				DPRINTF(("ah_massage_headers(): malformed "
				    "IPv4 options header\n"));

				ahstat.ahs_hdrops++;
				m_freem(m);
				return EINVAL;
d323 6
d331 11
a341 1
		break;
d346 2
a347 2
		/* Copy and "cook" the IPv6 header. */
		m_copydata(m, 0, sizeof(ip6), (caddr_t) &ip6);
d349 33
a381 4
		/* We don't do IPv6 Jumbograms. */
		if (ip6.ip6_plen == 0) {
			DPRINTF(("ah_massage_headers(): unsupported IPv6 "
			    "jumbogram"));
d384 13
a396 1
			return EMSGSIZE;
d398 77
a474 127

		ip6.ip6_flow = 0;
		ip6.ip6_hlim = 0;
		ip6.ip6_vfc &= ~IPV6_VERSION_MASK;
		ip6.ip6_vfc |= IPV6_VERSION;

		/* Scoped address handling. */
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6.ip6_src))
			ip6.ip6_src.s6_addr16[1] = 0;
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6.ip6_dst))
			ip6.ip6_dst.s6_addr16[1] = 0;

		/* Done with IPv6 header. */
		m_copyback(m, 0, sizeof(struct ip6_hdr), (caddr_t) &ip6);

		/* Let's deal with the remaining headers (if any). */
		if (skip - sizeof(struct ip6_hdr) > 0) {
			if (m->m_len <= skip) {
				MALLOC(ptr, unsigned char *,
				    skip - sizeof(struct ip6_hdr),
				    M_XDATA, M_NOWAIT);
				if (ptr == NULL) {
					DPRINTF(("ah_massage_headers(): failed to allocate memory for IPv6 headers\n"));
					ahstat.ahs_hdrops++;
					m_freem(m);
					return ENOBUFS;
				}

				/*
				 * Copy all the protocol headers after
				 * the IPv6 header.
				 */
				m_copydata(m, sizeof(struct ip6_hdr),
				    skip - sizeof(struct ip6_hdr), ptr);
				alloc = 1;
			} else {
				/* No need to allocate memory. */
				ptr = mtod(m, unsigned char *) +
				    sizeof(struct ip6_hdr);
				alloc = 0;
			}
		} else
			break;

		off = ip6.ip6_nxt & 0xff; /* Next header type. */

		for (len = 0; len < skip - sizeof(struct ip6_hdr);)
			switch (off) {
			case IPPROTO_HOPOPTS:
			case IPPROTO_DSTOPTS:
				ip6e = (struct ip6_ext *) (ptr + len);

				/*
				 * Process the mutable/immutable
				 * options -- borrows heavily from the
				 * KAME code.
				 */
				for (count = len + sizeof(struct ip6_ext);
				     count < len + ((ip6e->ip6e_len + 1) << 3);) {
					if (ptr[count] == IP6OPT_PAD1) {
						count++;
						continue; /* Skip padding. */
					}

					/* Sanity check. */
					if (count > len +
					    ((ip6e->ip6e_len + 1) << 3)) {
						ahstat.ahs_hdrops++;
						m_freem(m);

						/* Free, if we allocated. */
						if (alloc)
							FREE(ptr, M_XDATA);
						return EINVAL;
					}

					ad = ptr[count + 1];

					/* If mutable option, zeroize. */
					if (ptr[count] & IP6OPT_MUTABLE)
						bcopy(ipseczeroes, ptr + count,
						    ptr[count + 1]);

					count += ad;

					/* Sanity check. */
					if (count >
					    skip - sizeof(struct ip6_hdr)) {
						ahstat.ahs_hdrops++;
						m_freem(m);

						/* Free, if we allocated. */
						if (alloc)
							FREE(ptr, M_XDATA);
						return EINVAL;
					}
				}

				/* Advance. */
				len += ((ip6e->ip6e_len + 1) << 3);
				off = ip6e->ip6e_nxt;
				break;

			case IPPROTO_ROUTING:
				/*
				 * Always include routing headers in
				 * computation.
				 */
				ip6e = (struct ip6_ext *) (ptr + len);
				len += ((ip6e->ip6e_len + 1) << 3);
				off = ip6e->ip6e_nxt;
				break;

			default:
				DPRINTF(("ah_massage_headers(): unexpected "
				    "IPv6 header type %d\n", off));
				if (alloc)
					FREE(ptr, M_XDATA);
				ahstat.ahs_hdrops++;
				m_freem(m);
				return EINVAL;
			}

		/* Copyback and free, if we allocated. */
		if (alloc) {
			m_copyback(m, sizeof(struct ip6_hdr),
			    skip - sizeof(struct ip6_hdr), ptr);
d476 12
a487 1
		}
d489 1
a489 1
		break;
d491 1
a491 1
	}
d493 1
a493 1
	return 0;
d503 24
a526 35
	struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
	struct tdb_ident *tdbi;
	struct tdb_crypto *tc;
	struct m_tag *mtag;
	u_int32_t btsx;
	u_int8_t hl;
	int rplen;

	struct cryptodesc *crda = NULL;
	struct cryptop *crp;

	if (!(tdb->tdb_flags & TDBF_NOREPLAY))
		rplen = AH_FLENGTH + sizeof(u_int32_t);
	else
		rplen = AH_FLENGTH;

	/* Save the AH header, we use it throughout. */
	m_copydata(m, skip + offsetof(struct ah, ah_hl), sizeof(u_int8_t),
	    (caddr_t) &hl);

	/* Replay window checking, if applicable. */
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
		m_copydata(m, skip + offsetof(struct ah, ah_rpl),
		    sizeof(u_int32_t), (caddr_t) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap))) {
		case 0: /* All's well. */
			break;

		case 1:
			DPRINTF(("ah_input(): replay counter wrapped for "
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
d528 2
a529 53
			ahstat.ahs_wrap++;
			m_freem(m);
			return ENOBUFS;

		case 2:
		case 3:
			DPRINTF(("ah_input(): duplicate packet received in "
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));

			ahstat.ahs_replay++;
			m_freem(m);
			return ENOBUFS;

		default:
			DPRINTF(("ah_input(): bogus value from "
			    "checkreplaywindow32() in SA %s/%08x\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));

			ahstat.ahs_replay++;
			m_freem(m);
			return ENOBUFS;
		}
	}

	/* Verify AH header length. */
	if (hl * sizeof(u_int32_t) != ahx->authsize + rplen - AH_FLENGTH) {
		DPRINTF(("ah_input(): bad authenticator length %d for packet "
		    "in SA %s/%08x\n", hl * sizeof(u_int32_t),
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));

		ahstat.ahs_badauthl++;
		m_freem(m);
		return EACCES;
	}

	/* Update the counters. */
	tdb->tdb_cur_bytes +=
	    (m->m_pkthdr.len - skip - hl * sizeof(u_int32_t));
	ahstat.ahs_ibytes += (m->m_pkthdr.len - skip - hl * sizeof(u_int32_t));

	/* Hard expiration. */
	if (tdb->tdb_flags & TDBF_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
		m_freem(m);
		return ENXIO;
	}

	/* Notify on expiration. */
	if (tdb->tdb_flags & TDBF_SOFT_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes)
d531 2
a532 3
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES;  /* Turn off checking. */
	}
d534 3
a536 3
	/* Get crypto descriptors. */
	crp = crypto_getreq(1);
	if (crp == NULL) {
a537 3
		DPRINTF(("ah_input(): failed to acquire crypto "
		    "descriptors\n"));
		ahstat.ahs_crypto++;
a538 24
	}

	crda = crp->crp_desc;

	crda->crd_skip = 0;
	crda->crd_len = m->m_pkthdr.len;
	crda->crd_inject = skip + rplen;

	/* Authentication operation. */
	crda->crd_alg = ahx->type;
	crda->crd_key = tdb->tdb_amxkey;
	crda->crd_klen = tdb->tdb_amxkeylen * 8;

	/* Find out if we've already done crypto. */
	for (mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, NULL);
	     mtag != NULL;
	     mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_CRYPTO_DONE, mtag)) {
		tdbi = (struct tdb_ident *) (mtag + 1);
		if (tdbi->proto == tdb->tdb_sproto &&
		    tdbi->spi == tdb->tdb_spi &&
		    !bcmp(&tdbi->dst, &tdb->tdb_dst,
			sizeof(union sockaddr_union)))
			break;
	}
d540 4
a543 9
	/* Allocate IPsec-specific opaque crypto info. */
	if (mtag == NULL)
		MALLOC(tc, struct tdb_crypto *,
		    sizeof(struct tdb_crypto) + skip +
		    rplen + ahx->authsize, M_XDATA, M_NOWAIT);
	else /* Hash verification has already been done successfully. */
		MALLOC(tc, struct tdb_crypto *, sizeof(struct tdb_crypto),
		    M_XDATA, M_NOWAIT);
	if (tc == NULL) {
a544 3
		crypto_freereq(crp);
		DPRINTF(("ah_input(): failed to allocate tdb_crypto\n"));
		ahstat.ahs_crypto++;
a545 1
	}
d547 105
a651 1
	bzero(tc, sizeof(struct tdb_crypto));
d653 14
a666 21
	/* Only save information if crypto processing is needed. */
	if (mtag == NULL) {
		/*
		 * Save the authenticator, the skipped portion of the packet,
		 * and the AH header.
		 */
		m_copydata(m, 0, skip + rplen + ahx->authsize,
		    (caddr_t) (tc + 1));

		/* Zeroize the authenticator on the packet. */
		m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes);

		/* "Massage" the packet headers for crypto processing. */
		if ((btsx = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
		    skip, ahx->type, 0)) != 0) {
			/* mbuf will be free'd by callee. */
			FREE(tc, M_XDATA);
			crypto_freereq(crp);
			return btsx;
		}
	}
d668 1
a668 20
	/* Crypto operation descriptor. */
	crp->crp_ilen = m->m_pkthdr.len; /* Total input length. */
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) ah_input_cb;
	crp->crp_sid = tdb->tdb_cryptoid;
	crp->crp_opaque = (caddr_t) tc;

	/* These are passed as-is to the callback. */
	tc->tc_skip = skip;
	tc->tc_protoff = protoff;
	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = tdb->tdb_sproto;
	tc->tc_ptr = (caddr_t) mtag; /* Save the mtag we've identified. */
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

	if (mtag == NULL)
		return crypto_dispatch(crp);
	else
		return ah_input_cb(crp);
d677 154
a830 21
	int roff, rplen, error, skip, protoff;
	unsigned char calc[AH_ALEN_MAX];
	struct mbuf *m1, *m0, *m;
	struct cryptodesc *crd;
	struct auth_hash *ahx;
	struct tdb_crypto *tc;
	struct cryptop *crp;
	struct m_tag *mtag;
	struct tdb *tdb;
	u_int8_t prot;
	caddr_t ptr;
	int s, err;

	crp = (struct cryptop *) op;
	crd = crp->crp_desc;

	tc = (struct tdb_crypto *) crp->crp_opaque;
	skip = tc->tc_skip;
	protoff = tc->tc_protoff;
	mtag = (struct m_tag *) tc->tc_ptr;
	m = (struct mbuf *) crp->crp_buf;
d832 2
a833 76
	s = spltdb();

	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);
	FREE(tc, M_XDATA);
	if (tdb == NULL) {
		ahstat.ahs_notdb++;
		DPRINTF(("ah_input_cb(): TDB is expired while in crypto"));
		goto baddone;
	}

	ahx = (struct auth_hash *) tdb->tdb_authalgxform;

	/* Check for crypto errors. */
	if (crp->crp_etype) {
		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;

		if (crp->crp_etype == EAGAIN) {
			splx(s);
			return crypto_dispatch(crp);
		}

		ahstat.ahs_noxform++;
		DPRINTF(("ah_input_cb(): crypto error %d\n", crp->crp_etype));
		error = crp->crp_etype;
		goto baddone;
	} else {
		crypto_freereq(crp); /* No longer needed. */
		crp = NULL;
	}

	/* Shouldn't happen... */
	if (m == NULL) {
		ahstat.ahs_crypto++;
		DPRINTF(("ah_input_cb(): bogus returned buffer from "
		    "crypto\n"));
		error = EINVAL;
		goto baddone;
	}

	if (!(tdb->tdb_flags & TDBF_NOREPLAY))
		rplen = AH_FLENGTH + sizeof(u_int32_t);
	else
		rplen = AH_FLENGTH;

	/* Copy authenticator off the packet. */
	m_copydata(m, skip + rplen, ahx->authsize, calc);

	/*
	 * If we have an mtag, we don't need to verify the authenticator --
	 * it has been verified by an IPsec-aware NIC.
	 */
	if (mtag == NULL) {
		ptr = (caddr_t) (tc + 1);

		/* Verify authenticator. */
		if (bcmp(ptr + skip + rplen, calc, ahx->authsize)) {
			DPRINTF(("ah_input(): authentication failed for "
			    "packet in SA %s/%08x\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));

			ahstat.ahs_badauth++;
			error = EACCES;
			goto baddone;
		}

		/* Fix the Next Protocol field. */
		((u_int8_t *) ptr)[protoff] = ((u_int8_t *) ptr)[skip];

		/* Copyback the saved (uncooked) network headers. */
		m_copyback(m, 0, skip, ptr);
	} else {
		/* Fix the Next Protocol field. */
		m_copydata(m, skip, sizeof(u_int8_t), &prot);
		m_copyback(m, protoff, sizeof(u_int8_t), &prot);
	}
d835 2
a836 44
	/* Record the beginning of the AH header. */
	m1 = m_getptr(m, skip, &roff);
	if (m1 == NULL) {
		ahstat.ahs_hdrops++;
		splx(s);
		m_freem(m);

		DPRINTF(("ah_input(): bad mbuf chain for packet in SA "
		    "%s/%08x\n", ipsp_address(tdb->tdb_dst),
		    ntohl(tdb->tdb_spi)));

		return EINVAL;
	}

	/* Remove the AH header from the mbuf. */
	if (roff == 0) {
		/*
		 * The AH header was conveniently at the beginning of
		 * the mbuf.
		 */
		m_adj(m1, rplen + ahx->authsize);
		if (!(m1->m_flags & M_PKTHDR))
			m->m_pkthdr.len -= rplen + ahx->authsize;
	} else
		if (roff + rplen + ahx->authsize >= m1->m_len) {
			/*
			 * Part or all of the AH header is at the end
			 * of this mbuf, so first let's remove the
			 * remainder of the AH header from the
			 * beginning of the remainder of the mbuf
			 * chain, if any.
			 */
			if (roff + rplen + ahx->authsize > m1->m_len) {
				/* Adjust the next mbuf by the remainder. */
				m_adj(m1->m_next, roff + rplen +
				    ahx->authsize - m1->m_len);

				/*
				 * The second mbuf is guaranteed not
				 * to have a pkthdr...
				 */
				m->m_pkthdr.len -=
				    (roff + rplen + ahx->authsize - m1->m_len);
			}
d838 3
a840 3
			/* Now, let's unlink the mbuf chain for a second... */
			m0 = m1->m_next;
			m1->m_next = NULL;
d842 1
a842 22
			/*
			 * ...and trim the end of the first part of
			 * the chain...sick
			 */
			m_adj(m1, -(m1->m_len - roff));
			if (!(m1->m_flags & M_PKTHDR))
				m->m_pkthdr.len -= (m1->m_len - roff);

			/* Finally, let's relink. */
			m1->m_next = m0;
		} else {
			/*
			 * The AH header lies in the "middle" of the
			 * mbuf...do an overlapping copy of the
			 * remainder of the mbuf over the ESP header.
			 */
			bcopy(mtod(m1, u_char *) + roff + rplen +
			    ahx->authsize, mtod(m1, u_char *) + roff,
			    m1->m_len - (roff + rplen + ahx->authsize));
			m1->m_len -= rplen + ahx->authsize;
			m->m_pkthdr.len -= rplen + ahx->authsize;
		}
d844 1
a844 14
	err = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
	splx(s);
	return err;

 baddone:
	splx(s);

	if (m != NULL)
		m_freem(m);

	if (crp != NULL)
		crypto_freereq(crp);

	return error;
d852 1
a852 1
    int protoff)
d854 9
a862 9
	struct auth_hash *ahx = (struct auth_hash *) tdb->tdb_authalgxform;
	struct cryptodesc *crda;
	struct tdb_crypto *tc;
	struct mbuf *mo, *mi;
	struct cryptop *crp;
	u_int16_t iplen;
	int len, rplen;
	u_int8_t prot;
	struct ah *ah;
d865 20
a884 20
	{
		struct ifnet *ifn;
		struct enchdr hdr;
		struct mbuf m1;

		bzero (&hdr, sizeof(hdr));

		hdr.af = tdb->tdb_dst.sa.sa_family;
		hdr.spi = tdb->tdb_spi;
		hdr.flags |= M_AUTH;

		m1.m_next = m;
		m1.m_len = ENC_HDRLEN;
		m1.m_data = (char *) &hdr;

		ifn = &(encif[0].sc_if);

		if (ifn->if_bpf)
			bpf_mtap(ifn->if_bpf, &m1);
	}
d887 1
a887 1
	ahstat.ahs_output++;
d889 15
a903 17
	/*
	 * Check for replay counter wrap-around in automatic (not
	 * manual) keying.
	 */
	if ((tdb->tdb_rpl == 0) && (tdb->tdb_wnd > 0) &&
	    (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
		DPRINTF(("ah_output(): SA %s/%08x should have expired\n",
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		ahstat.ahs_wrap++;
		return NULL;
	}

	if (!(tdb->tdb_flags & TDBF_NOREPLAY))
		rplen = AH_FLENGTH + sizeof(u_int32_t);
	else
		rplen = AH_FLENGTH;
d905 2
a906 1
	switch (tdb->tdb_dst.sa.sa_family) {
d909 10
a918 10
		/* Check for IP maximum packet size violations. */
		if (rplen + ahx->authsize + m->m_pkthdr.len > IP_MAXPACKET) {
			DPRINTF(("ah_output(): packet in SA %s/%08x got too "
			    "big\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
			m_freem(m);
			ahstat.ahs_toobig++;
			return EMSGSIZE;
		}
		break;
d923 10
a932 10
		/* Check for IPv6 maximum packet size violations. */
		if (rplen + ahx->authsize + m->m_pkthdr.len > IPV6_MAXPACKET) {
			DPRINTF(("ah_output(): packet in SA %s/%08x "
			    "got too big\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));
			m_freem(m);
			ahstat.ahs_toobig++;
			return EMSGSIZE;
		}
		break;
d936 146
a1081 135
		DPRINTF(("ah_output(): unknown/unsupported protocol "
		    "family %d, SA %s/%08x\n", tdb->tdb_dst.sa.sa_family,
		    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));
		m_freem(m);
		ahstat.ahs_nopf++;
		return EPFNOSUPPORT;
	}

	/* Update the counters. */
	tdb->tdb_cur_bytes += m->m_pkthdr.len - skip;
	ahstat.ahs_obytes += m->m_pkthdr.len - skip;

	/* Hard expiration. */
	if (tdb->tdb_flags & TDBF_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_exp_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_HARD);
		tdb_delete(tdb);
		m_freem(m);
		return EINVAL;
	}

	/* Notify on expiration. */
	if (tdb->tdb_flags & TDBF_SOFT_BYTES &&
	    tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes) {
		pfkeyv2_expire(tdb, SADB_EXT_LIFETIME_SOFT);
		tdb->tdb_flags &= ~TDBF_SOFT_BYTES; /* Turn off checking */
	}

	/*
	 * Loop through mbuf chain; if we find an M_EXT mbuf with
	 * more than one reference, replace the rest of the chain.
	 */
	mi = m;
	while (mi != NULL &&
	    (!(mi->m_flags & M_EXT) || !MCLISREFERENCED(mi))) {
		mo = mi;
		mi = mi->m_next;
	}

	if (mi != NULL) {
		/* Replace the rest of the mbuf chain. */
		struct mbuf *n = m_copym2(mi, 0, M_COPYALL, M_DONTWAIT);

		if (n == NULL) {
			ahstat.ahs_hdrops++;
			m_freem(m);
			return ENOBUFS;
		}

		if (mo != NULL)
			mo->m_next = n;
		else
			m = n;

		m_freem(mi);
	}

	/* Inject AH header. */
	mi = m_inject(m, skip, rplen + ahx->authsize, M_DONTWAIT);
	if (mi == NULL) {
		DPRINTF(("ah_output(): failed to inject AH header for SA "
		    "%s/%08x\n", ipsp_address(tdb->tdb_dst),
		    ntohl(tdb->tdb_spi)));

		m_freem(m);
		ahstat.ahs_wrap++;
		return ENOBUFS;
	}

	/*
	 * The AH header is guaranteed by m_inject() to be in
	 * contiguous memory, at the beginning of the returned mbuf.
	 */
	ah = mtod(mi, struct ah *);

	/* Initialize the AH header. */
	m_copydata(m, protoff, sizeof(u_int8_t), (caddr_t) &ah->ah_nh);
	ah->ah_hl = (rplen + ahx->authsize - AH_FLENGTH) / sizeof(u_int32_t);
	ah->ah_rv = 0;
	ah->ah_spi = tdb->tdb_spi;

	/* Zeroize authenticator. */
	m_copyback(m, skip + rplen, ahx->authsize, ipseczeroes);

	if (!(tdb->tdb_flags & TDBF_NOREPLAY))
		ah->ah_rpl = htonl(tdb->tdb_rpl++);

	/* Get crypto descriptors. */
	crp = crypto_getreq(1);
	if (crp == NULL) {
		m_freem(m);
		DPRINTF(("ah_output(): failed to acquire crypto "
		    "descriptors\n"));
		ahstat.ahs_crypto++;
		return ENOBUFS;
	}

	crda = crp->crp_desc;

	crda->crd_skip = 0;
	crda->crd_inject = skip + rplen;
	crda->crd_len = m->m_pkthdr.len;

	/* Authentication operation. */
	crda->crd_alg = ahx->type;
	crda->crd_key = tdb->tdb_amxkey;
	crda->crd_klen = tdb->tdb_amxkeylen * 8;

	/* Allocate IPsec-specific opaque crypto info. */
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		MALLOC(tc, struct tdb_crypto *,
		    sizeof(struct tdb_crypto) + skip, M_XDATA, M_NOWAIT);
	else
		MALLOC(tc, struct tdb_crypto *,
		    sizeof(struct tdb_crypto), M_XDATA, M_NOWAIT);
	if (tc == NULL) {
		m_freem(m);
		crypto_freereq(crp);
		DPRINTF(("ah_output(): failed to allocate tdb_crypto\n"));
		ahstat.ahs_crypto++;
		return ENOBUFS;
	}

	bzero(tc, sizeof(struct tdb_crypto));

	/* Save the skipped portion of the packet. */
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0) {
		m_copydata(m, 0, skip, (caddr_t) (tc + 1));

		/*
		 * Fix IP header length on the header used for
		 * authentication. We don't need to fix the original
		 * header length as it will be fixed by our caller.
		 */
		switch (tdb->tdb_dst.sa.sa_family) {
d1083 7
a1089 8
		case AF_INET:
			bcopy(((caddr_t)(tc + 1)) +
			    offsetof(struct ip, ip_len),
			    (caddr_t) &iplen, sizeof(u_int16_t));
			iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
			m_copyback(m, offsetof(struct ip, ip_len),
			    sizeof(u_int16_t), (caddr_t) &iplen);
			break;
d1093 7
a1099 8
		case AF_INET6:
			bcopy(((caddr_t)(tc + 1)) +
			    offsetof(struct ip6_hdr, ip6_plen),
			    (caddr_t) &iplen, sizeof(u_int16_t));
			iplen = htons(ntohs(iplen) + rplen + ahx->authsize);
			m_copyback(m, offsetof(struct ip6_hdr, ip6_plen),
			    sizeof(u_int16_t), (caddr_t) &iplen);
			break;
d1101 1
a1101 1
		}
d1103 15
a1117 2
		/* Fix the Next Header field in saved header. */
		((u_int8_t *) (tc + 1))[protoff] = IPPROTO_AH;
d1119 21
a1139 17
		/* Update the Next Protocol field in the IP header. */
		prot = IPPROTO_AH;
		m_copyback(m, protoff, sizeof(u_int8_t), (caddr_t) &prot);

		/* "Massage" the packet headers for crypto processing. */
		if ((len = ah_massage_headers(&m, tdb->tdb_dst.sa.sa_family,
		    skip, ahx->type, 1)) != 0) {
			/* mbuf will be free'd by callee. */
			FREE(tc, M_XDATA);
			crypto_freereq(crp);
			return len;
		}
	} else {
		/* Update the Next Protocol field in the IP header. */
		prot = IPPROTO_AH;
		m_copyback(m, protoff, sizeof(u_int8_t), (caddr_t) &prot);
	}
d1141 1
a1141 19
	/* Crypto operation descriptor. */
	crp->crp_ilen = m->m_pkthdr.len; /* Total input length. */
	crp->crp_flags = CRYPTO_F_IMBUF;
	crp->crp_buf = (caddr_t) m;
	crp->crp_callback = (int (*) (struct cryptop *)) ah_output_cb;
	crp->crp_sid = tdb->tdb_cryptoid;
	crp->crp_opaque = (caddr_t) tc;

	/* These are passed as-is to the callback. */
	tc->tc_skip = skip;
	tc->tc_protoff = protoff;
	tc->tc_spi = tdb->tdb_spi;
	tc->tc_proto = tdb->tdb_sproto;
	bcopy(&tdb->tdb_dst, &tc->tc_dst, sizeof(union sockaddr_union));

	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		return crypto_dispatch(crp);
	else
		return ah_output_cb(crp);
d1150 66
a1215 14
	int skip, protoff, error;
	struct tdb_crypto *tc;
	struct cryptop *crp;
	struct tdb *tdb;
	struct mbuf *m;
	caddr_t ptr;
	int err, s;

	crp = (struct cryptop *) op;
	tc = (struct tdb_crypto *) crp->crp_opaque;
	skip = tc->tc_skip;
	protoff = tc->tc_protoff;
	ptr = (caddr_t) (tc + 1);
	m = (struct mbuf *) crp->crp_buf;
d1217 2
a1218 10
	s = spltdb();

	tdb = gettdb(tc->tc_spi, &tc->tc_dst, tc->tc_proto);

	FREE(tc, M_XDATA);
	if (tdb == NULL) {
		ahstat.ahs_notdb++;
		DPRINTF(("ah_output_cb(): TDB is expired while in crypto\n"));
		goto baddone;
	}
d1220 2
a1221 15
	/* Check for crypto errors. */
	if (crp->crp_etype) {
		if (tdb->tdb_cryptoid != 0)
			tdb->tdb_cryptoid = crp->crp_sid;

		if (crp->crp_etype == EAGAIN) {
			splx(s);
			return crypto_dispatch(crp);
		}

		ahstat.ahs_noxform++;
		DPRINTF(("ah_output_cb(): crypto error %d\n", crp->crp_etype));
		error = crp->crp_etype;
		goto baddone;
	}
d1223 3
a1225 18
	/* Shouldn't happen... */
	if (m == NULL) {
		ahstat.ahs_crypto++;
		DPRINTF(("ah_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		error = EINVAL;
		goto baddone;
	}

	/*
	 * Copy original headers (with the new protocol number) back
	 * in place.
	 */
	if ((tdb->tdb_flags & TDBF_SKIPCRYPTO) == 0)
		m_copyback(m, 0, skip, ptr);

	/* No longer needed. */
	crypto_freereq(crp);
d1227 1
a1227 11
	err =  ipsp_process_done(m, tdb);
	splx(s);
	return err;

 baddone:
	splx(s);

	if (m != NULL)
		m_freem(m);

	crypto_freereq(crp);
d1229 1
a1229 1
	return error;
@


1.34.2.4
log
@Sync the SMP branch with 3.3
@
text
@a75 2
struct ahstat ahstat;

d519 1
a519 1
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 0)) {
d538 1
d580 2
a581 1
	    tdb->tdb_cur_bytes >= tdb->tdb_soft_bytes) {
d687 1
a687 1
	int s, roff, rplen, error, skip, protoff;
a695 1
	u_int32_t btsx;
d698 1
d712 1
a713 1
		FREE(tc, M_XDATA);
a715 1
		error = EPERM;
a722 2
		FREE(tc, M_XDATA);

a741 1
		FREE(tc, M_XDATA);
a765 2
			FREE(tc, M_XDATA);

a785 42
	FREE(tc, M_XDATA);

	/* Replay window checking, if applicable. */
	if ((tdb->tdb_wnd > 0) && (!(tdb->tdb_flags & TDBF_NOREPLAY))) {
		m_copydata(m, skip + offsetof(struct ah, ah_rpl),
		    sizeof(u_int32_t), (caddr_t) &btsx);
		btsx = ntohl(btsx);

		switch (checkreplaywindow32(btsx, 0, &(tdb->tdb_rpl),
		    tdb->tdb_wnd, &(tdb->tdb_bitmap), 1)) {
		case 0: /* All's well. */
			break;

		case 1:
			DPRINTF(("ah_input(): replay counter wrapped for "
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));

			ahstat.ahs_wrap++;
			error = ENOBUFS;
			goto baddone;

		case 2:
		case 3:
			DPRINTF(("ah_input_cb(): duplicate packet received in "
			    "SA %s/%08x\n", ipsp_address(tdb->tdb_dst),
			    ntohl(tdb->tdb_spi)));

			error = ENOBUFS;
			goto baddone;

		default:
			DPRINTF(("ah_input_cb(): bogus value from "
			    "checkreplaywindow32() in SA %s/%08x\n",
			    ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi)));

			ahstat.ahs_replay++;
			error = ENOBUFS;
			goto baddone;
		}
	}

d858 1
a858 1
	error = ipsec_common_input_cb(m, tdb, skip, protoff, mtag);
d860 1
a860 1
	return (error);
d871 1
a871 1
	return (error);
d901 1
a901 1
		hdr.flags |= M_AUTH | M_AUTH_AH;
a995 1
	mo = NULL;
d1029 1
a1029 1
		ahstat.ahs_hdrops++;
d1188 2
a1190 1
		FREE(tc, M_XDATA);
a1192 1
		error = EPERM;
a1205 1
		FREE(tc, M_XDATA);
a1213 1
		FREE(tc, M_XDATA);
a1226 2

	FREE(tc, M_XDATA);
@


1.34.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.34.2.4 2003/03/28 00:06:54 niklas Exp $ */
a706 1

a707 9
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		ahstat.ahs_crypto++;
		DPRINTF(("ah_input_cb(): bogus returned buffer from "
		    "crypto\n"));
		return (EINVAL);
	}
d724 5
a729 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d733 1
a733 1
		FREE(tc, M_XDATA);
d743 10
a950 1
		m1.m_flags = 0;
d974 1
a974 1
		return EINVAL;
a1231 1

a1232 9
	if (m == NULL) {
		/* Shouldn't happen... */
		FREE(tc, M_XDATA);
		crypto_freereq(crp);
		ahstat.ahs_crypto++;
		DPRINTF(("ah_output_cb(): bogus returned buffer from "
		    "crypto\n"));
		return (EINVAL);
	}
d1247 3
a1250 3
			/* Reset the session ID */
			if (tdb->tdb_cryptoid != 0)
				tdb->tdb_cryptoid = crp->crp_sid;
d1254 1
d1259 10
@


1.34.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d106 1
a106 1
	case SADB_X_AALG_RIPEMD160HMAC:
a109 12
	case SADB_X_AALG_SHA2_256:
		thash = &auth_hash_hmac_sha2_256_96;
		break;

	case SADB_X_AALG_SHA2_384:
		thash = &auth_hash_hmac_sha2_384_96;
		break;

	case SADB_X_AALG_SHA2_512:
		thash = &auth_hash_hmac_sha2_512_96;
		break;

d217 14
a230 4
		if (alg == CRYPTO_MD5_KPDK || alg == CRYPTO_SHA1_KPDK)
			ip->ip_off &= htons(IP_DF);
		else
			ip->ip_off = 0;
d363 1
a363 1
		m_copyback(m, 0, sizeof(struct ip6_hdr), &ip6);
d1154 1
a1154 1
			    sizeof(u_int16_t), &iplen);
d1165 1
a1165 1
			    sizeof(u_int16_t), &iplen);
d1175 1
a1175 1
		m_copyback(m, protoff, sizeof(u_int8_t), &prot);
d1188 1
a1188 1
		m_copyback(m, protoff, sizeof(u_int8_t), &prot);
@


1.33
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d63 1
a63 2
#include <netinet6/in6.h>
#include <netinet6/ip6.h>
@


1.32
log
@Ok, no more IPsec for OpenBSD...I've had enough with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.31 1999/12/07 09:01:47 angelos Exp $	*/
a37 5
/*
 * Authentication Header Processing
 * Per RFC1826 (Atkinson, 1995)
 */

a44 1
#include <sys/sysctl.h>
d48 1
d50 1
d55 1
a60 4
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
d62 4
a65 2
#include <sys/socketvar.h>
#include <net/raw_cb.h>
d69 1
a69 1

a73 2
extern struct enc_softc encif[];

d84 22
a105 1
int ah_enable = 0;
d108 1
a108 1
 * ah_input gets called when we receive an packet with an AH.
d110 35
d146 43
a188 7
void
#if __STDC__
ah_input(struct mbuf *m, ...)
#else
ah_input(m, va_alist)
	register struct mbuf *m;
#endif
d190 11
a200 12
    int iphlen;
    union sockaddr_union sunion;
    struct ifqueue *ifq = NULL;
    struct ah_old *ahp, ahn;
    struct ip *ipo, ipn;
    struct tdb *tdbp;
    int s;
    va_list ap;
	
    va_start(ap, m);
    iphlen = va_arg(ap, int);
    va_end(ap);
d202 3
a204 1
    ahstat.ahs_input++;
d206 1
a206 1
    if (!ah_enable)
d208 5
a212 3
        m_freem(m);
        ahstat.ahs_pdrops++;
        return;
d215 39
a253 4
    /*
     * Make sure that at least the fixed part of the AH header is
     * in the first mbuf.
     */
d255 2
a256 2
    ipo = mtod(m, struct ip *);
    if (m->m_len < iphlen + AH_OLD_FLENGTH)
d258 2
a259 1
	if ((m = m_pullup(m, iphlen + AH_OLD_FLENGTH)) == 0)
d261 21
a281 2
	    ahstat.ahs_hdrops++;
	    return;
d283 1
d285 7
a291 1
	ipo = mtod(m, struct ip *);
d294 23
a316 1
    ahp = (struct ah_old *) ((caddr_t) ipo + iphlen);
d318 1
a318 5
    /*
     * Find tunnel control block and (indirectly) call the appropriate
     * tranform routine. The resulting mbuf chain is a valid
     * IP packet ready to go through input processing.
     */
d320 1
a320 7
    bzero(&sunion, sizeof(sunion));
    sunion.sin.sin_family = AF_INET;
    sunion.sin.sin_len = sizeof(struct sockaddr_in);
    sunion.sin.sin_addr = ipo->ip_dst;
    s = spltdb();
    tdbp = gettdb(ahp->ah_spi, &sunion, IPPROTO_AH);
    if (tdbp == NULL)
d322 242
a563 4
	DPRINTF(("ah_input(): could not find SA for packet from %s to %s, spi %08x\n", inet_ntoa4(ipo->ip_src), ipsp_address(sunion), ntohl(ahp->ah_spi)));
	m_freem(m);
	ahstat.ahs_notdb++;
	return;
d566 5
a570 1
    if (tdbp->tdb_flags & TDBF_INVALID)
d572 3
a574 1
	DPRINTF(("ah_input(): attempted to use invalid SA %08x, packet from %s to %s\n", ntohl(ahp->ah_spi), inet_ntoa4(ipo->ip_src), ipsp_address(sunion)));
d576 1
a576 2
	ahstat.ahs_invalid++;
	return;
d578 2
d581 7
a587 1
    if (tdbp->tdb_xform == NULL)
d589 3
a591 1
	DPRINTF(("ah_input(): attempted to use uninitialized SA %08x, packet from %s to %s\n", ntohl(ahp->ah_spi), inet_ntoa4(ipo->ip_src), ipsp_address(sunion)));
d593 1
a593 2
	ahstat.ahs_noxform++;
	return;
d595 2
d598 8
a605 4
    if (tdbp->tdb_interface)
      m->m_pkthdr.rcvif = (struct ifnet *) tdbp->tdb_interface;
    else
      m->m_pkthdr.rcvif = &encif[0].sc_if;
d607 2
a608 2
    /* Register first use, setup expiration timer */
    if (tdbp->tdb_first_use == 0)
d610 15
a624 2
	tdbp->tdb_first_use = time.tv_sec;
	tdb_expiration(tdbp, TDBEXP_TIMEOUT);
a625 3
    
    ipn = *ipo;
    ahn = *ahp;
d627 8
a634 3
    m = (*(tdbp->tdb_xform->xf_input))(m, tdbp, ipo->ip_hl << 2,
				       offsetof(struct ip, ip_p));
    if (m == NULL)
d636 5
a640 2
	ahstat.ahs_badkcr++;
	return;
d643 2
a644 1
    if ((m = m_pullup(m, ipn.ip_hl << 2)) == 0)
d646 4
a649 2
	ahstat.ahs_hdrops++;
	return;
d652 2
a653 6
    ipo = mtod(m, struct ip *);
    ipo->ip_len = htons(m->m_pkthdr.len);
    HTONS(ipo->ip_id);
    HTONS(ipo->ip_off);
    ipo->ip_sum = 0;
    ipo->ip_sum = in_cksum(m, ipo->ip_hl << 2);
d655 4
a658 1
    if (ipo->ip_p == IPPROTO_IPIP)	/* IP-in-IP encapsulation */
d660 14
a673 6
	/* ipn will now contain the inner IP header */
	m_copydata(m, ipo->ip_hl << 2, sizeof(struct ip), (caddr_t) &ipn);
	    
	if (tdbp->tdb_flags & TDBF_UNIQUE)
	  if ((ipn.ip_src.s_addr != ipo->ip_src.s_addr) ||
	      (ipn.ip_dst.s_addr != ipo->ip_dst.s_addr))
d675 7
a681 4
	      DPRINTF(("ah_input(): AH-tunnel with different internal addresses %s->%s (%s->%s), SA %s/%08x\n", inet_ntoa4(ipo->ip_src), inet_ntoa4(ipo->ip_dst), inet_ntoa4(ipn.ip_src), ipsp_address(sunion), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
	      m_freem(m);
	      ahstat.ahs_hdrops++;
	      return;
d684 140
a823 12
	/*
	 * Check that the inner source address is the same as
	 * the proxy address, if available.
	 */
	if ((tdbp->tdb_proxy.sin.sin_addr.s_addr != INADDR_ANY) &&
	    (ipn.ip_src.s_addr != tdbp->tdb_proxy.sin.sin_addr.s_addr))
	{
	    DPRINTF(("ah_input(): inner source address %s doesn't correspond to expected proxy source %s, SA %s/%08x\n", inet_ntoa4(ipo->ip_src), ipsp_address(tdbp->tdb_proxy), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
	    m_free(m);
	    ahstat.ahs_hdrops++;
	    return;
	}
d827 5
a831 2
     * Check that the outter source address is an expected one, if we know
     * what it's supposed to be. This avoids source address spoofing.
d833 5
a837 2
    if ((tdbp->tdb_src.sin.sin_addr.s_addr != INADDR_ANY) &&
	(ipo->ip_src.s_addr != tdbp->tdb_src.sin.sin_addr.s_addr))
d839 23
a861 4
	DPRINTF(("ah_input(): source address %s doesn't correspond to expected source %s, SA %s/%08x\n", inet_ntoa4(ipo->ip_src), ipsp_address(tdbp->tdb_src), ipsp_address(tdbp->tdb_dst), ntohl(tdbp->tdb_spi)));
	m_free(m);
	ahstat.ahs_hdrops++;
	return;
d864 3
a866 1
    if (ipo->ip_p == IPPROTO_TCP || ipo->ip_p == IPPROTO_UDP)
d868 102
a969 1
	struct tdb_ident *tdbi = NULL;
d971 52
a1022 4
	if (tdbp->tdb_bind_out)
	{
	    tdbi = m->m_pkthdr.tdbi;
	    if (!(m->m_flags & M_PKTHDR))
d1024 4
a1027 1
		DPRINTF(("ah_input(): mbuf is not a packet header!\n"));
a1028 2
	    MALLOC(tdbi, struct tdb_ident *, sizeof(struct tdb_ident),
		   M_TEMP, M_NOWAIT);
d1030 16
a1045 2
	    if (!tdbi)
	      goto no_mem;
d1047 107
a1153 4
	    tdbi->spi = tdbp->tdb_bind_out->tdb_spi;
	    tdbi->dst = tdbp->tdb_bind_out->tdb_dst;
	    tdbi->proto = tdbp->tdb_bind_out->tdb_sproto;
	}
d1155 2
a1156 4
    no_mem:
	m->m_pkthdr.tdbi = tdbi;
    } else
        m->m_pkthdr.tdbi = NULL;
d1158 6
a1163 2
    /* Packet is authentic */
    m->m_flags |= M_AUTH;
d1165 3
a1167 2
#if NBPFILTER > 0
    if (m->m_pkthdr.rcvif->if_bpf) 
d1169 4
a1172 19
        /*
         * We need to prepend the address family as
         * a four byte field.  Cons up a dummy header
         * to pacify bpf.  This is safe because bpf
         * will only read from the mbuf (i.e., it won't
         * try to free it or keep a pointer a to it).
         */
        struct mbuf m0;
        struct enchdr hdr;

	hdr.af = AF_INET;
	hdr.spi = tdbp->tdb_spi;
	hdr.flags = m->m_flags & (M_AUTH|M_CONF);

        m0.m_next = m;
        m0.m_len = ENC_HDRLEN;
        m0.m_data = (char *) &hdr;
        
        bpf_mtap(m->m_pkthdr.rcvif->if_bpf, &m0);
a1173 3
#endif

    splx(s);
d1176 2
a1177 2
     * Interface pointer is already in first mbuf; chop off the 
     * `outer' header and reschedule.
d1179 33
d1213 1
a1213 1
    ifq = &ipintrq;
d1215 11
a1225 2
    s = splimp();			/* isn't it already? */
    if (IF_QFULL(ifq))
d1227 4
a1230 8
	IF_DROP(ifq);
	if (m->m_pkthdr.tdbi)
		free(m->m_pkthdr.tdbi, M_TEMP);
	m_freem(m);
	ahstat.ahs_qfull++;
	splx(s);
	DPRINTF(("ah_input(): dropped packet because of full IP queue\n"));
	return;
d1233 4
a1236 5
    IF_ENQUEUE(ifq, m);
    schednetisr(NETISR_IP);
    splx(s);
    return;
}
d1238 3
a1240 20
int
ah_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case AHCTL_ENABLE:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &ah_enable));
	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
@


1.31
log
@Forgot a printf...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.30 1999/12/07 08:57:59 angelos Exp $	*/
@


1.30
log
@New ah_new_input(), protocol-independent processing (still lacking
IPv6-specific protocol header processing).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.29 1999/12/06 23:02:08 angelos Exp $	*/
a285 2

    printf("here4\n");
@


1.29
log
@Oops, typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.28 1999/12/06 22:56:03 angelos Exp $	*/
a200 1
	DPRINTF(("ah_input(): authentication failed for AH packet from %s to %s, spi %08x\n", inet_ntoa4(ipn.ip_src), ipsp_address(sunion), ntohl(ahn.ah_spi)));
d213 2
d287 2
d316 1
@


1.28
log
@Some preliminiries to AH revamping (similar to ESP)...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.27 1999/12/06 07:14:35 angelos Exp $	*/
d208 1
a208 1
	ahstat.esps_hdrops++;
@


1.27
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.26 1999/11/04 11:23:43 ho Exp $	*/
d206 6
d213 4
@


1.26
log
@gettdb() should be at spltdb().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.25 1999/10/29 05:21:45 angelos Exp $	*/
d87 4
d197 2
a198 1
    m = (*(tdbp->tdb_xform->xf_input))(m, tdbp);
@


1.25
log
@Support multiple enc interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.24 1999/07/05 20:17:06 deraadt Exp $	*/
d152 1
a246 1
	int s = spltdb();
a267 1
	splx(s);
d298 1
@


1.24
log
@remove bogus entry from if_enc address list; and rename enc_softc to encif
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.23 1999/05/16 21:48:30 niklas Exp $	*/
a59 1
#include <net/if_enc.h>
d75 2
d79 1
a79 1
extern struct ifnet encif;
d177 4
a180 1
    m->m_pkthdr.rcvif = &encif;
d276 1
a276 1
    if (encif.if_bpf) 
d296 1
a296 1
        bpf_mtap(encif.if_bpf, &m0);
@


1.23
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.22 1999/05/14 23:36:16 niklas Exp $	*/
d78 1
a78 1
extern struct ifnet enc_softc;
d176 1
a176 1
    m->m_pkthdr.rcvif = &enc_softc;
d272 1
a272 1
    if (enc_softc.if_bpf) 
d292 1
a292 1
        bpf_mtap(enc_softc.if_bpf, &m0);
@


1.22
log
@A new scalable IPsec SA expiration model.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.21 1999/04/11 19:41:36 niklas Exp $	*/
d182 1
a182 1
	tdb_expiration(tdbp, 0);
d242 2
d264 1
@


1.21
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.20 1999/04/09 22:27:54 niklas Exp $	*/
a103 1
    struct expiration *exp;
d182 1
a182 21

	if (tdbp->tdb_flags & TDBF_FIRSTUSE)
	{
	    exp = get_expiration();
	    bcopy(&tdbp->tdb_dst, &exp->exp_dst, SA_LEN(&tdbp->tdb_dst.sa));
	    exp->exp_spi = tdbp->tdb_spi;
	    exp->exp_sproto = tdbp->tdb_sproto;
	    exp->exp_timeout = tdbp->tdb_first_use + tdbp->tdb_exp_first_use;
	    put_expiration(exp);
	}

	if ((tdbp->tdb_flags & TDBF_SOFT_FIRSTUSE) &&
	    (tdbp->tdb_soft_first_use <= tdbp->tdb_exp_first_use))
	{
	    exp = get_expiration();
	    bcopy(&tdbp->tdb_dst, &exp->exp_dst, SA_LEN(&tdbp->tdb_dst.sa));
	    exp->exp_spi = tdbp->tdb_spi;
	    exp->exp_sproto = tdbp->tdb_sproto;
	    exp->exp_timeout = tdbp->tdb_first_use + tdbp->tdb_soft_first_use;
	    put_expiration(exp);
	}
@


1.20
log
@Make the tdbi handling more robust, removes a panic case
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.19 1999/03/27 21:04:19 provos Exp $	*/
d50 1
d86 1
a86 1
void ah_input __P((struct mbuf *, int));
d93 6
a98 1
ah_input(register struct mbuf *m, int iphlen)
d100 1
d108 1
d110 4
d116 7
d338 22
@


1.19
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.18 1999/02/24 23:45:46 angelos Exp $	*/
d251 2
a252 3
	    if (!tdbi || !(m->m_flags & (M_CONF|M_AUTH)))
	      MALLOC(tdbi, struct tdb_ident *, sizeof(struct tdb_ident),
		     M_TEMP, M_NOWAIT);
d262 1
d264 2
a265 2
    no_mem:
    }
@


1.18
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.17 1999/02/24 22:32:59 angelos Exp $	*/
d241 26
d306 2
@


1.17
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.16 1998/06/10 23:57:13 provos Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
@


1.16
log
@make the packets which were successfully processed by IPSec available to
bpf via the enc0 interface, using linktype DLT_ENC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.15 1998/05/24 22:40:13 provos Exp $	*/
a68 1
#include <net/encap.h>
d73 3
a75 1
#include <sys/syslog.h>
d77 5
a81 1
#include "bpfilter.h"
d83 1
a83 1
void	ah_input __P((struct mbuf *, int));
d92 1
a111 4
#ifdef ENCDEBUG
	    if (encdebug)
	      printf("ah_input(): (possibly too short) packet from %x to %x dropped\n", ipo->ip_src, ipo->ip_dst);
#endif /* ENCDEBUG */
d115 1
d127 5
a131 1
    tdbp = gettdb(ahp->ah_spi, ipo->ip_dst, IPPROTO_AH);
d134 1
a134 2
	if (encdebug)
	  log(LOG_ERR, "ah_input(): could not find SA for AH packet from %x to %x, spi %08x\n", ipo->ip_src, ipo->ip_dst, ntohl(ahp->ah_spi));
d142 1
a142 2
	if (encdebug)
	  log(LOG_ALERT, "ah_input(): attempted to use invalid AH SA %08x, packet %x->%x\n", ntohl(ahp->ah_spi), ipo->ip_src, ipo->ip_dst);
d150 1
a150 2
	if (encdebug)
	  log(LOG_ALERT, "ah_input(): attempted to use uninitialized AH SA %08x, packet from %x to %x\n", ntohl(ahp->ah_spi), ipo->ip_src, ipo->ip_dst);
d166 1
a166 11
	    if (exp == (struct expiration *) NULL)
	    {
		if (encdebug)
		  log(LOG_WARNING,
		      "ah_input(): out of memory for expiration timer\n");
		ahstat.ahs_hdrops++;
		m_freem(m);
		return;
	    }

	    exp->exp_dst.s_addr = tdbp->tdb_dst.s_addr;
a169 1

d177 1
a177 11
	    if (exp == (struct expiration *) NULL)
	    {
		if (encdebug)
		  log(LOG_WARNING,
		      "ah_input(): out of memory for expiration timer\n");
		ahstat.ahs_hdrops++;
		m_freem(m);
		return;
	    }

	    exp->exp_dst.s_addr = tdbp->tdb_dst.s_addr;
a180 1

d191 1
a191 2
	if (encdebug)
	  log(LOG_ALERT, "ah_input(): authentication failed for AH packet from %x to %x, spi %08x\n", ipn.ip_src, ipn.ip_dst, ntohl(ahn.ah_spi));
d202 16
a217 2
	/* Encapsulating SPI */
	if (tdbp->tdb_osrc.s_addr && tdbp->tdb_odst.s_addr)
d219 2
a220 21
	    if (tdbp->tdb_flags & TDBF_UNIQUE)
		if ((ipn.ip_src.s_addr != ipo->ip_src.s_addr) ||
		    (ipn.ip_dst.s_addr != ipo->ip_dst.s_addr))
		{
		    if (encdebug)
			log(LOG_ALERT, "ah_input(): AH-tunnel with different internal addresses %x/%x, SA %08x/%x\n", ipo->ip_src, ipo->ip_dst, tdbp->tdb_spi, tdbp->tdb_dst);
		    m_freem(m);
		    ahstat.ahs_hdrops++;
		    return;
		}

	    /*
	     * XXX Here we should be checking that the inner IP addresses
	     * XXX are acceptable/authorized.
	     */
	}
	else				/* So we're paranoid */
	{
	    if (encdebug)
		log(LOG_ALERT, "ah_input(): AH-tunnel used when expecting AH-transport, SA %08x/%x\n", tdbp->tdb_spi, tdbp->tdb_dst);
	    m_freem(m);
d227 2
a228 2
     * Check that the source address is an expected one, if we know what
     * it's supposed to be. This avoids source address spoofing.
d230 8
a237 9
    if (tdbp->tdb_src.s_addr != INADDR_ANY)
	if (ipo->ip_src.s_addr != tdbp->tdb_src.s_addr)
	{
	    if (encdebug)
		log(LOG_ALERT, "esp_input(): source address %x doesn't correspond to expected source %x, SA %08x/%x\n", ipo->ip_src, tdbp->tdb_src, tdbp->tdb_dst, tdbp->tdb_spi);
	    m_free(m);
	    ahstat.ahs_hdrops++;
	    return;
	}
d257 1
a257 1
	hdr.flags = m->m_flags & (M_AUTH|M_CONF|M_TUNNEL);
d281 1
a281 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_input(): dropped packet because of full IP queue\n");
#endif /* ENCDEBUG */
@


1.15
log
@avoid source address spoofing for mutual hostile hosts which have SAs to
us, reported by Craig Metz <cmetz@@inner.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.14 1998/05/18 21:10:30 provos Exp $	*/
d56 2
d76 2
d263 28
@


1.14
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.13 1997/11/04 09:10:58 provos Exp $	*/
d214 3
d221 14
a234 9
	      if ((ipn.ip_src.s_addr != ipo->ip_src.s_addr) ||
		  (ipn.ip_dst.s_addr != ipo->ip_dst.s_addr))
	      {
		  if (encdebug)
		    log(LOG_ALERT, "ah_input(): AH-tunnel with different internal addresses %x/%x, SA %08x/%x\n", ipo->ip_src, ipo->ip_dst, tdbp->tdb_spi, tdbp->tdb_dst);
		  m_freem(m);
		  ahstat.ahs_hdrops++;
		  return;
	      }
d239 1
a239 1
	      log(LOG_ALERT, "ah_input(): AH-tunnel used when expecting AH-transport, SA %08x/%x\n", tdbp->tdb_spi, tdbp->tdb_dst);
d245 14
@


1.13
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.12 1997/10/02 02:31:02 deraadt Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
@


1.12
log
@conditional error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.11 1997/09/28 22:57:43 deraadt Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
@


1.11
log
@log() needs a \n
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.10 1997/07/27 23:30:33 niklas Exp $	*/
d113 2
a114 1
	log(LOG_ERR, "ah_input(): could not find SA for AH packet from %x to %x, spi %08x\n", ipo->ip_src, ipo->ip_dst, ntohl(ahp->ah_spi));
d122 2
a123 3
	log(LOG_ALERT,
	    "ah_input(): attempted to use invalid AH SA %08x, packet %x->%x\n",
	    ntohl(ahp->ah_spi), ipo->ip_src, ipo->ip_dst);
d131 2
a132 1
	log(LOG_ALERT, "ah_input(): attempted to use uninitialized AH SA %08x, packet from %x to %x\n", ntohl(ahp->ah_spi), ipo->ip_src, ipo->ip_dst);
d150 3
a152 2
		log(LOG_WARNING,
		    "ah_input(): out of memory for expiration timer\n");
d172 3
a174 2
		log(LOG_WARNING,
		    "ah_input(): out of memory for expiration timer\n");
d195 2
a196 1
	log(LOG_ALERT, "ah_input(): authentication failed for AH packet from %x to %x, spi %08x\n", ipn.ip_src, ipn.ip_dst, ntohl(ahn.ah_spi));
d211 2
a212 1
		  log(LOG_ALERT, "ah_input(): AH-tunnel with different internal addresses %x/%x, SA %08x/%x\n", ipo->ip_src, ipo->ip_dst, tdbp->tdb_spi, tdbp->tdb_dst);
d220 2
a221 1
	    log(LOG_ALERT, "ah_input(): AH-tunnel used when expecting AH-transport, SA %08x/%x\n", tdbp->tdb_spi, tdbp->tdb_dst);
@


1.10
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.9 1997/07/18 18:09:51 provos Exp $	*/
d113 1
a113 1
	log(LOG_ERR, "ah_input(): could not find SA for AH packet from %x to %x, spi %08x", ipo->ip_src, ipo->ip_dst, ntohl(ahp->ah_spi));
d122 1
a122 1
	    "ah_input(): attempted to use invalid AH SA %08x, packet %x->%x",
d131 1
a131 1
	log(LOG_ALERT, "ah_input(): attempted to use uninitialized AH SA %08x, packet from %x to %x", ntohl(ahp->ah_spi), ipo->ip_src, ipo->ip_dst);
d150 1
a150 1
		    "ah_input(): out of memory for expiration timer");
d171 1
a171 1
		    "ah_input(): out of memory for expiration timer");
d192 1
a192 1
	log(LOG_ALERT, "ah_input(): authentication failed for AH packet from %x to %x, spi %08x", ipn.ip_src, ipn.ip_dst, ntohl(ahn.ah_spi));
d215 1
a215 1
	    log(LOG_ALERT, "ah_input(): AH-tunnel used when expecting AH-transport, SA %08x/%x", tdbp->tdb_spi, tdbp->tdb_dst);
@


1.9
log
@enablespi/disablespi in encap + print spi's in hostorder
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.8 1997/07/11 23:37:54 provos Exp $	*/
d74 2
a76 1
    struct ah_old *ahp, ahn;
d139 1
a139 1
    /* Register first use */
d141 2
a142 1
      tdbp->tdb_first_use = time.tv_sec;
d144 42
d195 25
@


1.8
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.7 1997/07/01 22:12:41 provos Exp $	*/
d112 1
a112 1
	log(LOG_ERR, "ah_input(): could not find SA for AH packet from %x to %x, spi %08x", ipo->ip_src, ipo->ip_dst, ahp->ah_spi);
d122 1
a122 1
	    ahp->ah_spi, ipo->ip_src, ipo->ip_dst);
d130 1
a130 1
	log(LOG_ALERT, "ah_input(): attempted to use uninitialized AH SA %08x, packet from %x to %x", ahp->ah_spi, ipo->ip_src, ipo->ip_dst);
d148 1
a148 1
	log(LOG_ALERT, "ah_input(): authentication failed for AH packet from %x to %x, spi %08x", ipn.ip_src, ipn.ip_dst, ahn.ah_spi);
@


1.7
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.6 1997/06/25 07:53:21 provos Exp $	*/
d62 2
d73 3
a75 2
    struct ip *ipo;
    struct ah *ahp;
a76 1
    struct ifqueue *ifq = NULL;
a80 12
#if 0	/* We need them to verify the packet */
    /*
     * Strip IP options, if any.
     */

    if (iphlen > sizeof (struct ip))
    {
	ip_stripoptions(m, (struct mbuf *)0);
	iphlen = sizeof (struct ip);
    }
#endif
	
d87 1
a87 1
    if (m->m_len < iphlen + AH_FLENGTH)
d89 1
a89 1
	if ((m = m_pullup(m, iphlen + AH_FLENGTH)) == 0)
d91 4
d100 2
a101 1
    ahp = (struct ah *)((caddr_t)ipo + iphlen);
d109 1
a109 1
    tdbp = gettdb(ahp->ah_spi, ipo->ip_dst);
d112 1
a112 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_input: no tdb for spi=%x\n", ahp->ah_spi);
#endif ENCDEBUG
d120 3
a122 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_input: spi=%x is no longer/yet valid\n", ahp->ah_spi);
#endif /* ENCDEBUG */
d130 1
a130 4
#ifdef ENCDEBUG
	if (encdebug)
	  printf("ah_input: no xform for spi=%x\n", ahp->ah_spi);
#endif ENCDEBUG
d142 3
a145 1
	
d148 1
d167 4
d173 1
@


1.6
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.5 1997/06/24 12:15:19 provos Exp $	*/
d148 1
a148 1
    m->m_pkthdr.rcvif = tdbp->tdb_rcvif;
@


1.5
log
@handle IP options in AH + allow IP options in outgoing encapsulated packets
+ usage counters for later use with keymanagement processes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.4 1997/06/20 05:41:46 provos Exp $	*/
d126 11
d149 4
@


1.4
log
@ah-sha1 + esp-3des + indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.3 1997/02/26 03:01:02 angelos Exp $	*/
d79 1
d89 1
@


1.3
log
@I/O packet counters for IP-in-IP and AH.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_ah.c,v 1.2 1997/02/24 14:06:36 niklas Exp $	*/
d71 5
a75 5
	struct ip *ipo;
	struct ah *ahp;
	struct tdb *tdbp;
	struct ifqueue *ifq = NULL;
	int s;
d77 1
a77 1
	ahstat.ahs_input++;
d79 19
a97 5
	/*
	 * Strip IP options, if any.
	 */

	if (iphlen > sizeof (struct ip))
d99 2
a100 2
		ip_stripoptions(m, (struct mbuf *)0);
		iphlen = sizeof (struct ip);
a101 6
	
	/*
	 * Make sure that at least the fixed part of the AH header is
	 * in the first mbuf.
	 */

d103 2
a104 16
	if (m->m_len < iphlen + AH_FLENGTH)
	{
		if ((m = m_pullup(m, iphlen + AH_FLENGTH)) == 0)
		{
			ahstat.ahs_hdrops++;
			return;
		}
		ipo = mtod(m, struct ip *);
	}
	ahp = (struct ah *)((caddr_t)ipo + iphlen);

	/*
	 * Find tunnel control block and (indirectly) call the appropriate
	 * tranform routine. The resulting mbuf chain is a valid
	 * IP packet ready to go through input processing.
	 */
d106 9
a114 3
	tdbp = gettdb(ahp->ah_spi, ipo->ip_dst);
	if (tdbp == NULL)
	{
d116 2
a117 2
		if (encdebug)
		  printf("ah_input: no tdb for spi=%x\n", ahp->ah_spi);
d119 4
a122 4
		m_freem(m);
		ahstat.ahs_notdb++;
		return;
	}
d124 2
a125 2
	if (tdbp->tdb_xform == NULL)
	{
d127 2
a128 2
		if (encdebug)
		  printf("ah_input: no xform for spi=%x\n", ahp->ah_spi);
d130 4
a133 4
		m_freem(m);
		ahstat.ahs_noxform++;
		return;
	}
d135 1
a135 1
	m->m_pkthdr.rcvif = tdbp->tdb_rcvif;
d137 1
a137 1
	m = (*(tdbp->tdb_xform->xf_input))(m, tdbp);
d139 5
a143 12
	if (m == NULL)
	{
		ahstat.ahs_badkcr++;
		return;
	}

	/*
	 * Interface pointer is already in first mbuf; chop off the 
	 * `outer' header and reschedule.
	 */

	ifq = &ipintrq;
d145 13
a157 11
	s = splimp();			/* isn't it already? */
	if (IF_QFULL(ifq))
	{
		IF_DROP(ifq);
		m_freem(m);
		ahstat.ahs_qfull++;
		splx(s);
		return;
	}
	IF_ENQUEUE(ifq, m);
	schednetisr(NETISR_IP);
d160 5
@


1.2
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 2
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 2
d62 1
@
