head	1.124;
access;
symbols
	OPENBSD_6_2:1.124.0.4
	OPENBSD_6_2_BASE:1.124
	OPENBSD_6_1:1.121.0.4
	OPENBSD_6_1_BASE:1.121
	OPENBSD_6_0:1.117.0.4
	OPENBSD_6_0_BASE:1.117
	OPENBSD_5_9:1.115.0.2
	OPENBSD_5_9_BASE:1.115
	OPENBSD_5_8:1.114.0.4
	OPENBSD_5_8_BASE:1.114
	OPENBSD_5_7:1.112.0.2
	OPENBSD_5_7_BASE:1.112
	OPENBSD_5_6:1.109.0.4
	OPENBSD_5_6_BASE:1.109
	OPENBSD_5_5:1.102.0.4
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.96.0.2
	OPENBSD_5_4_BASE:1.96
	OPENBSD_5_3:1.95.0.2
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.93.0.2
	OPENBSD_5_2_BASE:1.93
	OPENBSD_5_1_BASE:1.90
	OPENBSD_5_1:1.90.0.4
	OPENBSD_5_0:1.90.0.2
	OPENBSD_5_0_BASE:1.90
	OPENBSD_4_9:1.85.0.2
	OPENBSD_4_9_BASE:1.85
	OPENBSD_4_8:1.84.0.2
	OPENBSD_4_8_BASE:1.84
	OPENBSD_4_7:1.82.0.2
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.79.0.4
	OPENBSD_4_6_BASE:1.79
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.77.0.2
	OPENBSD_4_4_BASE:1.77
	OPENBSD_4_3:1.76.0.2
	OPENBSD_4_3_BASE:1.76
	OPENBSD_4_2:1.73.0.4
	OPENBSD_4_2_BASE:1.73
	OPENBSD_4_1:1.73.0.2
	OPENBSD_4_1_BASE:1.73
	OPENBSD_4_0:1.71.0.2
	OPENBSD_4_0_BASE:1.71
	OPENBSD_3_9:1.68.0.2
	OPENBSD_3_9_BASE:1.68
	OPENBSD_3_8:1.67.0.2
	OPENBSD_3_8_BASE:1.67
	OPENBSD_3_7:1.64.0.2
	OPENBSD_3_7_BASE:1.64
	OPENBSD_3_6:1.62.0.2
	OPENBSD_3_6_BASE:1.62
	SMP_SYNC_A:1.62
	SMP_SYNC_B:1.62
	OPENBSD_3_5:1.61.0.2
	OPENBSD_3_5_BASE:1.61
	OPENBSD_3_4:1.57.0.2
	OPENBSD_3_4_BASE:1.57
	UBC_SYNC_A:1.56
	OPENBSD_3_3:1.56.0.6
	OPENBSD_3_3_BASE:1.56
	OPENBSD_3_2:1.56.0.4
	OPENBSD_3_2_BASE:1.56
	OPENBSD_3_1:1.56.0.2
	OPENBSD_3_1_BASE:1.56
	UBC_SYNC_B:1.56
	UBC:1.55.0.2
	UBC_BASE:1.55
	OPENBSD_3_0:1.54.0.2
	OPENBSD_3_0_BASE:1.54
	OPENBSD_2_9_BASE:1.43
	OPENBSD_2_9:1.43.0.2
	OPENBSD_2_8:1.42.0.2
	OPENBSD_2_8_BASE:1.42
	OPENBSD_2_7:1.38.0.4
	OPENBSD_2_7_BASE:1.38
	SMP:1.38.0.2
	SMP_BASE:1.38
	kame_19991208:1.26
	OPENBSD_2_6:1.23.0.4
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.124
date	2017.08.11.19.53.02;	author bluhm;	state Exp;
branches;
next	1.123;
commitid	ZSLEQCt6cCaCd9uI;

1.123
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.122;
commitid	p51F2KIwIJB1dU8P;

1.122
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.121;
commitid	Gef6NNDxonzfVaq2;

1.121
date	2017.02.04.02.54.33;	author guenther;	state Exp;
branches;
next	1.120;
commitid	9csrCwph526pp6vy;

1.120
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.119;
commitid	T2qzeepA7r1EGy1x;

1.119
date	2016.09.04.17.05.24;	author claudio;	state Exp;
branches;
next	1.118;
commitid	h5QFrgdMWwYIzfEB;

1.118
date	2016.08.16.22.21.17;	author vgross;	state Exp;
branches;
next	1.117;
commitid	t6hSs1Di1O3UTldP;

1.117
date	2016.06.28.17.18.24;	author chris;	state Exp;
branches;
next	1.116;
commitid	WyHA21HjSsNdlXF8;

1.116
date	2016.06.15.19.39.34;	author gerhard;	state Exp;
branches;
next	1.115;
commitid	qJ1QnDnimibODQ30;

1.115
date	2015.10.20.20.22.42;	author benno;	state Exp;
branches;
next	1.114;
commitid	bUJ2rTPueuGa0qeo;

1.114
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.113;
commitid	bQi1IVHgugweH5gs;

1.113
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.112;
commitid	c7ei8kPelCOOwHXy;

1.112
date	2015.02.09.12.18.19;	author claudio;	state Exp;
branches;
next	1.111;
commitid	8K5RNpON80OVB59T;

1.111
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.110;
commitid	t9FBKDfc4VDxpEy2;

1.110
date	2014.11.25.15.35.10;	author mpi;	state Exp;
branches;
next	1.109;
commitid	ckGoHy7P4urTJnRb;

1.109
date	2014.07.12.16.25.08;	author guenther;	state Exp;
branches;
next	1.108;
commitid	r9gXh8PA6rI3P7q2;

1.108
date	2014.04.25.09.44.38;	author mpi;	state Exp;
branches;
next	1.107;

1.107
date	2014.04.21.10.07.58;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2014.04.21.10.05.27;	author henning;	state Exp;
branches;
next	1.105;

1.105
date	2014.04.21.09.57.27;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2014.04.20.09.38.19;	author henning;	state Exp;
branches;
next	1.103;

1.103
date	2014.04.20.09.30.56;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2014.01.23.01.10.42;	author naddy;	state Exp;
branches;
next	1.101;

1.101
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches;
next	1.100;

1.100
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.99;

1.99
date	2013.10.23.13.39.35;	author mpi;	state Exp;
branches;
next	1.98;

1.98
date	2013.10.21.12.43.17;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2013.10.09.09.33.43;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2013.03.28.15.05.32;	author bluhm;	state Exp;
branches;
next	1.95;

1.95
date	2012.10.21.13.06.03;	author benno;	state Exp;
branches;
next	1.94;

1.94
date	2012.09.15.00.47.08;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2012.07.10.11.49.42;	author guenther;	state Exp;
branches;
next	1.91;

1.91
date	2012.06.26.06.39.27;	author guenther;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.06.01.57.37;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2011.06.15.09.11.01;	author mikeb;	state Exp;
branches;
next	1.88;

1.88
date	2011.05.02.13.48.38;	author mikeb;	state Exp;
branches;
next	1.87;

1.87
date	2011.04.28.09.56.27;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2011.04.04.17.44.43;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2010.09.23.04.45.15;	author yasuoka;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.07.13.26.35;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.11.09.25.10;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.81;

1.81
date	2009.09.08.17.52.17;	author michele;	state Exp;
branches;
next	1.80;

1.80
date	2009.09.08.17.00.41;	author michele;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2008.12.24.07.41.59;	author dlg;	state Exp;
branches;
next	1.77;

1.77
date	2008.05.09.02.56.36;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2007.12.14.18.33.40;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2007.12.13.20.00.53;	author reyk;	state Exp;
branches;
next	1.74;

1.74
date	2007.09.18.18.56.02;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2006.10.11.09.34.51;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2006.10.11.09.29.20;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2006.06.18.11.47.45;	author pascoe;	state Exp;
branches;
next	1.70;

1.70
date	2006.05.29.20.42.27;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.26.20.50.41;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2005.10.05.17.32.22;	author norby;	state Exp;
branches;
next	1.67;

1.67
date	2005.06.06.04.49.10;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2005.05.27.04.55.28;	author mcbride;	state Exp;
branches;
next	1.65;

1.65
date	2005.05.24.04.20.25;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2005.01.14.14.51.27;	author mcbride;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.24.01.25.42;	author mcbride;	state Exp;
branches;
next	1.62;

1.62
date	2004.06.06.16.49.09;	author cedric;	state Exp;
branches;
next	1.61;

1.61
date	2004.02.15.11.16.08;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2003.12.17.21.36.17;	author mcbride;	state Exp;
branches;
next	1.59;

1.59
date	2003.12.15.07.11.30;	author mcbride;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.17.21.04.58;	author mcbride;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2001.11.06.21.26.33;	author jakob;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2001.07.05.08.40.12;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.05.08.31.47;	author jjbg;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.25.00.11.57;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.24.23.41.47;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.24.23.33.55;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.23.06.38.10;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.23.06.37.31;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.12.10.57.22;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.09.07.03.40;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.27.05.27.01;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.17.18.41.46;	author provos;	state Exp;
branches;
next	1.43;

1.43
date	2000.12.09.01.32.09;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2000.09.19.03.20.57;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2000.09.18.22.06.36;	author provos;	state Exp;
branches;
next	1.40;

1.40
date	2000.06.18.07.06.13;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2000.05.25.01.22.00;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.09.07.37.14;	author itojun;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2000.01.26.03.43.17;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.21.03.15.04;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2000.01.18.19.06.07;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2000.01.11.01.13.49;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2000.01.10.06.59.21;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.10.04.30.52;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.09.22.17.56;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.07.21.45.22;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.07.19.37.09;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	99.12.18.16.55.44;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	99.12.16.21.30.34;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	99.10.28.03.29.49;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	99.10.28.01.55.12;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	99.04.11.19.41.36;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.04.09.23.28.44;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.03.27.21.04.21;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	99.03.24.02.31.03;	author cmetz;	state Exp;
branches;
next	1.19;

1.19
date	99.02.24.04.39.39;	author cmetz;	state Exp;
branches;
next	1.18;

1.18
date	99.02.17.23.51.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.01.10.02.37.33;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.01.07.06.13.34;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.01.03.18.20.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.01.01.11.15.03;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.05.18.21.10.26;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	98.02.11.03.58.31;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.11.30.18.50.19;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.28.15.22.30;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.02.00.18.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.02.28.03.44.52;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	97.02.20.01.07.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.29.02.34.29;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.03.03.22.30.29;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.21.07.10.36;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.11.28.22.42.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.26.23.40.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches;
next	;

1.38.2.1
date	2001.05.14.22.40.07;	author niklas;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2001.07.04.10.54.31;	author niklas;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.38.2.5;

1.38.2.5
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.38.2.6;

1.38.2.6
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.38.2.7;

1.38.2.7
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.38.2.8;

1.38.2.8
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.38.2.9;

1.38.2.9
date	2004.06.07.20.41.39;	author niklas;	state Exp;
branches;
next	;

1.55.2.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	;


desc
@@


1.124
log
@Validate sockaddr from userland in central functions.  This results
in common checks for unix, inet, inet6 instead of partial checks
here and there.  Some checks are already done at a higher layer,
but better be paranoid with user input.
OK claudio@@ millert@@
@
text
@/*	$OpenBSD: in.h,v 1.123 2017/05/30 07:50:37 mpi Exp $	*/
/*	$NetBSD: in.h,v 1.20 1996/02/13 23:41:47 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, and numerous additions.
 */

#ifndef _NETINET_IN_H_
#define	_NETINET_IN_H_

#include <sys/cdefs.h>

#ifndef _KERNEL
#include <sys/types.h>

/* <sys/_endian.h> is pulled in by <sys/types.h> */
#ifndef htons
#define htons(x)	__htobe16(x)
#define htonl(x)	__htobe32(x)
#define ntohs(x)	__htobe16(x)
#define ntohl(x)	__htobe32(x)
#endif

#endif /* _KERNEL */

#ifndef	_SA_FAMILY_T_DEFINED_
#define	_SA_FAMILY_T_DEFINED_
typedef	__sa_family_t	sa_family_t;	/* sockaddr address family type */
#endif /* _SA_FAMILY_T_DEFINED_ */

#ifndef _IN_TYPES_DEFINED_
#define _IN_TYPES_DEFINED_
typedef __in_addr_t	in_addr_t;	/* base type for internet address */
typedef __in_port_t	in_port_t;	/* IP port type */
#endif

/*
 * Protocols
 */
#define	IPPROTO_IP		0		/* dummy for IP */
#define IPPROTO_HOPOPTS		IPPROTO_IP	/* Hop-by-hop option header */
#define	IPPROTO_ICMP		1		/* control message protocol */
#define	IPPROTO_IGMP		2		/* group mgmt protocol */
#define	IPPROTO_GGP		3		/* gateway^2 (deprecated) */
#define	IPPROTO_IPIP		4		/* IP inside IP */
#define	IPPROTO_IPV4		IPPROTO_IPIP	/* IP inside IP */
#define	IPPROTO_TCP		6		/* tcp */
#define	IPPROTO_EGP		8		/* exterior gateway protocol */
#define	IPPROTO_PUP		12		/* pup */
#define	IPPROTO_UDP		17		/* user datagram protocol */
#define	IPPROTO_IDP		22		/* xns idp */
#define	IPPROTO_TP		29 		/* tp-4 w/ class negotiation */
#define IPPROTO_IPV6		41		/* IPv6 in IPv6 */
#define IPPROTO_ROUTING		43		/* Routing header */
#define IPPROTO_FRAGMENT	44		/* Fragmentation/reassembly header */
#define IPPROTO_RSVP		46		/* resource reservation */
#define	IPPROTO_GRE		47		/* GRE encap, RFCs 1701/1702 */
#define	IPPROTO_ESP		50		/* Encap. Security Payload */
#define	IPPROTO_AH		51		/* Authentication header */
#define	IPPROTO_MOBILE		55		/* IP Mobility, RFC 2004 */
#define IPPROTO_ICMPV6		58		/* ICMP for IPv6 */
#define IPPROTO_NONE		59		/* No next header */
#define IPPROTO_DSTOPTS		60		/* Destination options header */
#define	IPPROTO_EON		80		/* ISO cnlp */
#define IPPROTO_ETHERIP		97		/* Ethernet in IPv4 */
#define	IPPROTO_ENCAP		98		/* encapsulation header */
#define IPPROTO_PIM		103		/* Protocol indep. multicast */
#define IPPROTO_IPCOMP		108		/* IP Payload Comp. Protocol */
#define	IPPROTO_CARP		112		/* CARP */
#define	IPPROTO_MPLS		137		/* unicast MPLS packet */
#define	IPPROTO_PFSYNC		240		/* PFSYNC */
#define	IPPROTO_RAW		255		/* raw IP packet */

#define	IPPROTO_MAX		256

/* Only used internally, so it can be outside the range of valid IP protocols */
#define	IPPROTO_DIVERT		258		/* Divert sockets */

/*
 * From FreeBSD:
 *
 * Local port number conventions:
 *
 * When a user does a bind(2) or connect(2) with a port number of zero,
 * a non-conflicting local port address is chosen.
 * The default range is IPPORT_RESERVED through
 * IPPORT_USERRESERVED, although that is settable by sysctl.
 *
 * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
 * default assignment range.
 *
 * The value IP_PORTRANGE_DEFAULT causes the default behavior.
 *
 * The value IP_PORTRANGE_HIGH changes the range of candidate port numbers
 * into the "high" range.  These are reserved for client outbound connections
 * which do not want to be filtered by any firewalls.
 *
 * The value IP_PORTRANGE_LOW changes the range to the "low" are
 * that is (by convention) restricted to privileged processes.  This
 * convention is based on "vouchsafe" principles only.  It is only secure
 * if you trust the remote host to restrict these ports.
 *
 * The default range of ports and the high range can be changed by
 * sysctl(3).  (net.inet.ip.port{hi}{first,last})
 *
 * Changing those values has bad security implications if you are
 * using a a stateless firewall that is allowing packets outside of that
 * range in order to allow transparent outgoing connections.
 *
 * Such a firewall configuration will generally depend on the use of these
 * default values.  If you change them, you may find your Security
 * Administrator looking for you with a heavy object.
 */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 * Ports > IPPORT_USERRESERVED are reserved
 * for servers, not necessarily privileged.
 */
#define	IPPORT_RESERVED		1024
#define	IPPORT_USERRESERVED	49151

/*
 * Default local port range to use by setting IP_PORTRANGE_HIGH
 */
#define IPPORT_HIFIRSTAUTO	49152
#define IPPORT_HILASTAUTO	65535

#ifndef _IN_ADDR_DECLARED
#define _IN_ADDR_DECLARED
/*
 * IP Version 4 Internet address (a structure for historical reasons)
 */
struct in_addr {
	in_addr_t s_addr;
};
#endif /* _IN_ADDR_DECLARED */

/* last return value of *_input(), meaning "all job for this pkt is done".  */
#define	IPPROTO_DONE		257

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 *
 * By byte-swapping the constants, we avoid ever having to byte-swap IP
 * addresses inside the kernel.  Unfortunately, user-level programs rely
 * on these macros not doing byte-swapping.
 */
#ifdef _KERNEL
#define	__IPADDR(x)	((u_int32_t) htonl((u_int32_t)(x)))
#else
#define	__IPADDR(x)	((u_int32_t)(x))
#endif /* _KERNEL */

#define	IN_CLASSA(i)		(((u_int32_t)(i) & __IPADDR(0x80000000)) == \
				 __IPADDR(0x00000000))
#define	IN_CLASSA_NET		__IPADDR(0xff000000)
#define	IN_CLASSA_NSHIFT	24
#define	IN_CLASSA_HOST		__IPADDR(0x00ffffff)
#define	IN_CLASSA_MAX		128

#define	IN_CLASSB(i)		(((u_int32_t)(i) & __IPADDR(0xc0000000)) == \
				 __IPADDR(0x80000000))
#define	IN_CLASSB_NET		__IPADDR(0xffff0000)
#define	IN_CLASSB_NSHIFT	16
#define	IN_CLASSB_HOST		__IPADDR(0x0000ffff)
#define	IN_CLASSB_MAX		65536

#define	IN_CLASSC(i)		(((u_int32_t)(i) & __IPADDR(0xe0000000)) == \
				 __IPADDR(0xc0000000))
#define	IN_CLASSC_NET		__IPADDR(0xffffff00)
#define	IN_CLASSC_NSHIFT	8
#define	IN_CLASSC_HOST		__IPADDR(0x000000ff)

#define	IN_CLASSD(i)		(((u_int32_t)(i) & __IPADDR(0xf0000000)) == \
				 __IPADDR(0xe0000000))
/* These ones aren't really net and host fields, but routing needn't know. */
#define	IN_CLASSD_NET		__IPADDR(0xf0000000)
#define	IN_CLASSD_NSHIFT	28
#define	IN_CLASSD_HOST		__IPADDR(0x0fffffff)
#define	IN_MULTICAST(i)		IN_CLASSD(i)

#define	IN_RFC3021_NET		__IPADDR(0xfffffffe)
#define	IN_RFC3021_NSHIFT	31
#define	IN_RFC3021_HOST		__IPADDR(0x00000001)
#define	IN_RFC3021_SUBNET(n)	(((u_int32_t)(n) & IN_RFC3021_NET) == \
				 IN_RFC3021_NET)

#define	IN_EXPERIMENTAL(i)	(((u_int32_t)(i) & __IPADDR(0xf0000000)) == \
				 __IPADDR(0xf0000000))
#define	IN_BADCLASS(i)		(((u_int32_t)(i) & __IPADDR(0xf0000000)) == \
				 __IPADDR(0xf0000000))

#define	IN_LOCAL_GROUP(i)	(((u_int32_t)(i) & __IPADDR(0xffffff00)) == \
				 __IPADDR(0xe0000000))

#ifdef _KERNEL
#define IN_CLASSFULBROADCAST(i, b) \
				((IN_CLASSC(b) && (b | IN_CLASSC_HOST) == i) ||	\
				 (IN_CLASSB(b) && (b | IN_CLASSB_HOST) == i) ||	\
				 (IN_CLASSA(b) && (b | IN_CLASSA_HOST) == i))
#endif	/* _KERNEL */

#define	INADDR_ANY		__IPADDR(0x00000000)
#define	INADDR_LOOPBACK		__IPADDR(0x7f000001)
#define	INADDR_BROADCAST	__IPADDR(0xffffffff)	/* must be masked */
#ifndef _KERNEL
#define	INADDR_NONE		__IPADDR(0xffffffff)	/* -1 return */
#endif /* _KERNEL */

#define	INADDR_UNSPEC_GROUP	__IPADDR(0xe0000000)	/* 224.0.0.0 */
#define	INADDR_ALLHOSTS_GROUP	__IPADDR(0xe0000001)	/* 224.0.0.1 */
#define	INADDR_ALLROUTERS_GROUP __IPADDR(0xe0000002)	/* 224.0.0.2 */
#define	INADDR_CARP_GROUP	__IPADDR(0xe0000012)	/* 224.0.0.18 */
#define	INADDR_PFSYNC_GROUP	__IPADDR(0xe00000f0)	/* 224.0.0.240 */
#define INADDR_MAX_LOCAL_GROUP	__IPADDR(0xe00000ff)	/* 224.0.0.255 */

#define	IN_LOOPBACKNET		127			/* official! */

/*
 * IP Version 4 socket address.
 */
struct sockaddr_in {
	u_int8_t    sin_len;
	sa_family_t sin_family;
	in_port_t   sin_port;
	struct	    in_addr sin_addr;
	int8_t	    sin_zero[8];
};

/*
 * Structure used to describe IP options.
 * Used to store options internally, to pass them to a process,
 * or to restore options retrieved earlier.
 * The ip_dst is used for the first-hop gateway when using a source route
 * (this gets put into the header proper).
 */
struct ip_opts {
	struct in_addr	ip_dst;		/* first hop, 0 w/o src rt */
#if defined(__cplusplus)
	int8_t		Ip_opts[40];	/* cannot have same name as class */
#else
	int8_t		ip_opts[40];	/* actually variable in size */
#endif /* defined(__cplusplus) */
};

/*
 * Options for use with [gs]etsockopt at the IP level.
 * First word of comment is data type; bool is stored in int.
 */
#define	IP_OPTIONS		1    /* buf/ip_opts; set/get IP options */
#define	IP_HDRINCL		2    /* int; header is included with data */
#define	IP_TOS			3    /* int; IP type of service and preced. */
#define	IP_TTL			4    /* int; IP time to live */
#define	IP_RECVOPTS		5    /* bool; receive all IP opts w/dgram */
#define	IP_RECVRETOPTS		6    /* bool; receive IP opts for response */
#define	IP_RECVDSTADDR		7    /* bool; receive IP dst addr w/dgram */
#define	IP_RETOPTS		8    /* ip_opts; set/get IP options */
#define	IP_MULTICAST_IF		9    /* in_addr; set/get IP multicast i/f  */
#define	IP_MULTICAST_TTL	10   /* u_char; set/get IP multicast ttl */
#define	IP_MULTICAST_LOOP	11   /* u_char; set/get IP multicast loopback */
#define	IP_ADD_MEMBERSHIP	12   /* ip_mreq; add an IP group membership */
#define	IP_DROP_MEMBERSHIP	13   /* ip_mreq; drop an IP group membership */
#define IP_PORTRANGE		19   /* int; range to choose for unspec port */
#define IP_AUTH_LEVEL		20   /* int; authentication used */
#define IP_ESP_TRANS_LEVEL	21   /* int; transport encryption */
#define IP_ESP_NETWORK_LEVEL	22   /* int; full-packet encryption */
#define IP_IPSEC_LOCAL_ID	23   /* buf; IPsec local ID */
#define IP_IPSEC_REMOTE_ID	24   /* buf; IPsec remote ID */
#define IP_IPSEC_LOCAL_CRED	25   /* buf; was: IPsec local credentials */
#define IP_IPSEC_REMOTE_CRED	26   /* buf; was: IPsec remote credentials */
#define IP_IPSEC_LOCAL_AUTH	27   /* buf; was: IPsec local auth material */
#define IP_IPSEC_REMOTE_AUTH	28   /* buf; was: IPsec remote auth material */
#define IP_IPCOMP_LEVEL		29   /* int; compression used */
#define IP_RECVIF		30   /* bool; receive reception if w/dgram */
#define IP_RECVTTL		31   /* bool; receive IP TTL w/dgram */
#define IP_MINTTL		32   /* minimum TTL for packet or drop */
#define IP_RECVDSTPORT		33   /* bool; receive IP dst port w/dgram */
#define IP_PIPEX		34   /* bool; using PIPEX */
#define IP_RECVRTABLE		35   /* bool; receive rdomain w/dgram */
#define IP_IPSECFLOWINFO	36   /* bool; IPsec flow info for dgram */
#define IP_IPDEFTTL		37   /* int; IP TTL system default */
#define IP_SENDSRCADDR		IP_RECVDSTADDR  /* struct in_addr; */
						/* source address to use */

#define IP_RTABLE		0x1021	/* int; routing table, see SO_RTABLE */
#define IP_DIVERTFL		0x1022	/* int; divert direction flag opt */

/* Values used by IP_DIVERTFL socket option */
#define IPPROTO_DIVERT_RESP	0x01	/* divert response packets */
#define IPPROTO_DIVERT_INIT	0x02	/* divert packets initial direction */

#if __BSD_VISIBLE
/*
 * Security levels - IPsec, not IPSO
 */

#define IPSEC_LEVEL_BYPASS      0x00    /* Bypass policy altogether */
#define IPSEC_LEVEL_NONE        0x00    /* Send clear, accept any */
#define IPSEC_LEVEL_AVAIL       0x01    /* Send secure if SA available */
#define IPSEC_LEVEL_USE         0x02    /* Send secure, accept any */
#define IPSEC_LEVEL_REQUIRE     0x03    /* Require secure inbound, also use */
#define IPSEC_LEVEL_UNIQUE      0x04    /* Use outbound SA that is unique */
#define IPSEC_LEVEL_DEFAULT     IPSEC_LEVEL_AVAIL

#define IPSEC_AUTH_LEVEL_DEFAULT IPSEC_LEVEL_DEFAULT
#define IPSEC_ESP_TRANS_LEVEL_DEFAULT IPSEC_LEVEL_DEFAULT
#define IPSEC_ESP_NETWORK_LEVEL_DEFAULT IPSEC_LEVEL_DEFAULT
#define IPSEC_IPCOMP_LEVEL_DEFAULT IPSEC_LEVEL_DEFAULT

#endif /* __BSD_VISIBLE */

/*
 * Defaults and limits for options
 */
#define	IP_DEFAULT_MULTICAST_TTL  1	/* normally limit m'casts to 1 hop  */
#define	IP_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */
/*
 * The imo_membership vector for each socket starts at IP_MIN_MEMBERSHIPS
 * and is dynamically allocated at run-time, bounded by IP_MAX_MEMBERSHIPS,
 * and is reallocated when needed, sized according to a power-of-two increment.
 */
#define	IP_MIN_MEMBERSHIPS	15
#define	IP_MAX_MEMBERSHIPS	4095

/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
	struct	in_addr imr_multiaddr;	/* IP multicast address of group */
	struct	in_addr imr_interface;	/* local IP address of interface */
};

/*
 * Argument for IP_PORTRANGE:
 * - which range to search when port is unspecified at bind() or connect()
 */
#define IP_PORTRANGE_DEFAULT	0	/* default range */
#define IP_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
#define IP_PORTRANGE_LOW	2	/* "low" - vouchsafe security */

/*
 * Buffer lengths for strings containing printable IP addresses
 */
#ifndef INET_ADDRSTRLEN
#define INET_ADDRSTRLEN		16
#endif /* INET_ADDRSTRLEN */


#if __BSD_VISIBLE
/*
 * Definitions for inet sysctl operations.
 *
 * Third level is protocol number.
 * Fourth level is desired variable within that protocol.
 */
#define	IPPROTO_MAXID	(IPPROTO_DIVERT + 1)	/* don't list to IPPROTO_MAX */

#define	CTL_IPPROTO_NAMES { \
	{ "ip", CTLTYPE_NODE }, \
	{ "icmp", CTLTYPE_NODE }, \
	{ "igmp", CTLTYPE_NODE }, \
	{ "ggp", CTLTYPE_NODE }, \
	{ "ipip", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ "tcp", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ "egp", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "pup", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "udp", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "gre", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "esp", CTLTYPE_NODE }, \
	{ "ah", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "mobileip", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "etherip", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "ipcomp", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "carp", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "pfsync", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "divert", CTLTYPE_NODE }, \
}

/*
 * Names for IP sysctl objects
 */
#define	IPCTL_FORWARDING	1	/* act as router */
#define	IPCTL_SENDREDIRECTS	2	/* may send redirects when forwarding */
#define	IPCTL_DEFTTL		3	/* default TTL */
#define	IPCTL_SOURCEROUTE	5	/* may perform source routes */
#define	IPCTL_DIRECTEDBCAST	6	/* default broadcast behavior */
#define IPCTL_IPPORT_FIRSTAUTO	7
#define IPCTL_IPPORT_LASTAUTO	8
#define IPCTL_IPPORT_HIFIRSTAUTO 9
#define IPCTL_IPPORT_HILASTAUTO	10
#define	IPCTL_IPPORT_MAXQUEUE	11
#define	IPCTL_ENCDEBUG		12
#define IPCTL_IPSEC_EXPIRE_ACQUIRE 14   /* How long to wait for key mgmt. */
#define IPCTL_IPSEC_EMBRYONIC_SA_TIMEOUT	15 /* new SA lifetime */
#define IPCTL_IPSEC_REQUIRE_PFS 16
#define IPCTL_IPSEC_SOFT_ALLOCATIONS            17
#define IPCTL_IPSEC_ALLOCATIONS 18
#define IPCTL_IPSEC_SOFT_BYTES  19
#define IPCTL_IPSEC_BYTES       20
#define IPCTL_IPSEC_TIMEOUT     21
#define IPCTL_IPSEC_SOFT_TIMEOUT 22
#define IPCTL_IPSEC_SOFT_FIRSTUSE 23
#define IPCTL_IPSEC_FIRSTUSE    24
#define IPCTL_IPSEC_ENC_ALGORITHM 25
#define IPCTL_IPSEC_AUTH_ALGORITHM 26
#define	IPCTL_MTUDISC		27	/* allow path MTU discovery */
#define	IPCTL_MTUDISCTIMEOUT	28	/* allow path MTU discovery */
#define	IPCTL_IPSEC_IPCOMP_ALGORITHM	29
#define	IPCTL_IFQUEUE		30
#define	IPCTL_MFORWARDING	31
#define	IPCTL_MULTIPATH		32
#define	IPCTL_STATS		33	/* IP statistics */
#define	IPCTL_MRTPROTO		34	/* type of multicast */
#define	IPCTL_MRTSTATS		35
#define	IPCTL_ARPQUEUED		36
#define	IPCTL_MRTMFC		37
#define	IPCTL_MRTVIF		38
#define	IPCTL_ARPTIMEOUT	39
#define	IPCTL_ARPDOWN		40
#define	IPCTL_MAXID		41

#define	IPCTL_NAMES { \
	{ 0, 0 }, \
	{ "forwarding", CTLTYPE_INT }, \
	{ "redirect", CTLTYPE_INT }, \
	{ "ttl", CTLTYPE_INT }, \
	/* { "mtu", CTLTYPE_INT }, */ { 0, 0 }, \
	{ "sourceroute", CTLTYPE_INT }, \
	{ "directed-broadcast", CTLTYPE_INT }, \
	{ "portfirst", CTLTYPE_INT }, \
	{ "portlast", CTLTYPE_INT }, \
	{ "porthifirst", CTLTYPE_INT }, \
	{ "porthilast", CTLTYPE_INT }, \
	{ "maxqueue", CTLTYPE_INT }, \
	{ "encdebug", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ "ipsec-expire-acquire", CTLTYPE_INT }, \
	{ "ipsec-invalid-life", CTLTYPE_INT }, \
	{ "ipsec-pfs", CTLTYPE_INT }, \
	{ "ipsec-soft-allocs", CTLTYPE_INT }, \
	{ "ipsec-allocs", CTLTYPE_INT }, \
	{ "ipsec-soft-bytes", CTLTYPE_INT }, \
	{ "ipsec-bytes", CTLTYPE_INT }, \
	{ "ipsec-timeout", CTLTYPE_INT }, \
	{ "ipsec-soft-timeout", CTLTYPE_INT }, \
	{ "ipsec-soft-firstuse", CTLTYPE_INT }, \
	{ "ipsec-firstuse", CTLTYPE_INT }, \
	{ "ipsec-enc-alg", CTLTYPE_STRING }, \
	{ "ipsec-auth-alg", CTLTYPE_STRING }, \
	{ "mtudisc", CTLTYPE_INT }, \
	{ "mtudisctimeout", CTLTYPE_INT }, \
	{ "ipsec-comp-alg", CTLTYPE_STRING }, \
	{ "ifq", CTLTYPE_NODE }, \
	{ "mforwarding", CTLTYPE_INT }, \
	{ "multipath", CTLTYPE_INT }, \
	{ "stats", CTLTYPE_STRUCT }, \
	{ "mrtproto", CTLTYPE_INT }, \
	{ "mrtstats", CTLTYPE_STRUCT }, \
	{ "arpqueued", CTLTYPE_INT }, \
	{ "mrtmfc", CTLTYPE_STRUCT }, \
	{ "mrtvif", CTLTYPE_STRUCT }, \
	{ "arptimeout", CTLTYPE_INT }, \
	{ "arpdown", CTLTYPE_INT }, \
}
#define	IPCTL_VARS { \
	NULL, \
	&ipforwarding, \
	&ipsendredirects, \
	&ip_defttl, \
	NULL, \
	NULL, \
	&ip_directedbcast, \
	&ipport_firstauto, \
	&ipport_lastauto, \
	&ipport_hifirstauto, \
	&ipport_hilastauto, \
	&ip_maxqueue, \
	&encdebug, \
	NULL, \
	&ipsec_expire_acquire, \
	&ipsec_keep_invalid, \
	&ipsec_require_pfs, \
	&ipsec_soft_allocations, \
	&ipsec_exp_allocations, \
	&ipsec_soft_bytes, \
	&ipsec_exp_bytes, \
	&ipsec_exp_timeout, \
	&ipsec_soft_timeout, \
	&ipsec_soft_first_use, \
	&ipsec_exp_first_use, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	&ipmforwarding, \
	&ipmultipath, \
	NULL, \
	NULL, \
	NULL, \
	&la_hold_total, \
	NULL, \
	NULL, \
	&arpt_keep, \
	&arpt_down, \
}

#endif /* __BSD_VISIBLE */

/* INET6 stuff */
#define __KAME_NETINET_IN_H_INCLUDED_
#include <netinet6/in6.h>
#undef __KAME_NETINET_IN_H_INCLUDED_

#ifndef _KERNEL
#if __BSD_VISIBLE
__BEGIN_DECLS
int	   bindresvport(int, struct sockaddr_in *);
struct sockaddr;
int	   bindresvport_sa(int, struct sockaddr *);
__END_DECLS
#endif /* __BSD_VISIBLE */
#endif /* !_KERNEL */

#ifdef _KERNEL
extern	   int inetctlerrmap[];
extern	   struct in_addr zeroin_addr;

struct mbuf;
struct sockaddr;
struct sockaddr_in;
struct ifaddr;
struct in_ifaddr;

void	   ipv4_input(struct ifnet *, struct mbuf *);

int	   in_broadcast(struct in_addr, u_int);
int	   in_canforward(struct in_addr);
int	   in_cksum(struct mbuf *, int);
int	   in4_cksum(struct mbuf *, u_int8_t, int, int);
void	   in_proto_cksum_out(struct mbuf *, struct ifnet *);
void	   in_ifdetach(struct ifnet *);
int	   in_mask2len(struct in_addr *);
void	   in_len2mask(struct in_addr *, int);
int	   in_nam2sin(const struct mbuf *, struct sockaddr_in **);

char	  *inet_ntoa(struct in_addr);
int	   inet_nat64(int, const void *, void *, const void *, u_int8_t);
int	   inet_nat46(int, const void *, void *, const void *, u_int8_t);

const char *inet_ntop(int, const void *, char *, socklen_t);
const char *sockaddr_ntop(struct sockaddr *, char *, size_t);

#define	in_hosteq(s,t)	((s).s_addr == (t).s_addr)
#define	in_nullhost(x)	((x).s_addr == INADDR_ANY)

/*
 * Convert between address family specific and general structs.
 * Inline functions check the source type and are stricter than
 * casts or defines.
 */

static inline struct sockaddr_in *
satosin(struct sockaddr *sa)
{
	return ((struct sockaddr_in *)(sa));
}

static inline struct sockaddr *
sintosa(struct sockaddr_in *sin)
{
	return ((struct sockaddr *)(sin));
}

static inline struct in_ifaddr *
ifatoia(struct ifaddr *ifa)
{
	return ((struct in_ifaddr *)(ifa));
}
#endif /* _KERNEL */
#endif /* _NETINET_IN_H_ */
@


1.123
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.122 2017/05/04 15:00:24 bluhm Exp $	*/
d821 1
@


1.122
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.121 2017/02/04 02:54:33 guenther Exp $	*/
a802 1
extern	   struct niqueue ipintrq;	/* ip packet input queue */
d810 2
@


1.121
log
@Move the typedefs for in_{addr,port}_t from <sys/types.h> to
<netinet/in.h> and <arpa/inet.h>

ok and ports test naddy@@ (thanks!)
ok krw@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.120 2016/12/22 11:04:44 rzalamena Exp $	*/
d837 1
a837 1
static __inline struct sockaddr_in *
d843 1
a843 1
static __inline struct sockaddr *
d849 1
a849 1
static __inline struct in_ifaddr *
@


1.120
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.119 2016/09/04 17:05:24 claudio Exp $	*/
d60 6
@


1.119
log
@Implement a sockaddr_ntop() function that works like inet_ntop() but prints
sockaddrs. Works for all sockaddrs so can be used to print sockaddrs nicely.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.118 2016/08/16 22:21:17 vgross Exp $	*/
d490 1
a490 1
	{ "pim", CTLTYPE_NODE }, \
@


1.118
log
@Add IP_SENDSRCADDR cmsg for UDP sockets. As suggested by sthen@@,
IP_SENDSRCADDR == IP_RECVDSTADDR.

OK sthen@@ jca@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.117 2016/06/28 17:18:24 chris Exp $	*/
d801 4
d820 1
a823 5

struct sockaddr;
struct sockaddr_in;
struct ifaddr;
struct in_ifaddr;
@


1.117
log
@Add sysctl for arp timers: net.inet.ip.arptimeout (expire timer for resolved
entries) and net.inet.ip.arpdown (expire timer for unresolved entries)

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.116 2016/06/15 19:39:34 gerhard Exp $	*/
d310 2
@


1.116
log
@Add umb(4) - a driver for the Mobile Broadband Interface Model (MBIM)

The umb(4) driver provides support for USB MBIM devices.
Those devices establish connections via celluar networks such as
GPRS, UMTS, and LTE.

ok mpi@@ sthen@@
additional feedback from deraadt@@ jmc@@ stsp@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.115 2015/10/20 20:22:42 benno Exp $	*/
d685 3
a687 1
#define	IPCTL_MAXID		39
d729 2
d772 2
@


1.115
log
@add a new getsockopt option IP_IPDEFTTL to retrieve the default ttl.
this can be used as an alternative to sysctl net.inet.ip.ttl, in
programs that use pledge().
ok reyk@@, "Like this" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.114 2015/04/14 12:22:15 mikeb Exp $	*/
d801 1
@


1.114
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.113 2015/04/10 13:58:20 dlg Exp $	*/
d309 1
@


1.113
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.112 2015/02/09 12:18:19 claudio Exp $	*/
d297 4
a300 4
#define IP_IPSEC_LOCAL_CRED	25   /* buf; IPsec local credentials */
#define IP_IPSEC_REMOTE_CRED	26   /* buf; IPsec remote credentials */
#define IP_IPSEC_LOCAL_AUTH	27   /* buf; IPsec local auth material */
#define IP_IPSEC_REMOTE_AUTH	28   /* buf; IPsec remote auth material */
@


1.112
log
@Implement 2 sysctl to retrieve the multicast forwarding cache (mfc) and the
virtual interface table (vif). Will be used by netstat soon.
Looked over by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.111 2014/12/05 15:50:04 mpi Exp $	*/
d788 1
a788 1
extern	   struct ifqueue ipintrq;	/* ip packet input queue */
@


1.111
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.110 2014/11/25 15:35:10 mpi Exp $	*/
d682 3
a684 1
#define	IPCTL_MAXID		37
d724 2
d764 3
a766 1
	&la_hold_total \
@


1.110
log
@Since in_broadcast() is now used to always iterate on all the interfaces
of your system, put it on a diet and kill the superfluous logic.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.109 2014/07/12 16:25:08 guenther Exp $	*/
d784 2
@


1.109
log
@Tackle the endian.h mess.  Make it so that:
 * you can #include <sys/endian.h> instead of <machine/endian.h>,
   and ditto <endian.h>  (fixes code that pulls in <sys/endian.h> first)

 * those will always export the symbols that POSIX specified for
   <endian.h>, including the new {be,le}{16,32,64}toh() set.  c.f.
	http://austingroupbugs.net/view.php?id=162

   if __BSD_VISIBLE then you also get the symbols that our <machine/endian.h>
   currently exports (ntohs, NTOHS, dlg's bemtoh*, etc)

 * when doing POSIX compiles (not __BSD_VISIBLE), then <netinet/in.h> and
   <arpa/inet.h> will *stop* exporting the extra symbols like BYTE_ORDER
   and betoh*

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.108 2014/04/25 09:44:38 mpi Exp $	*/
d785 1
a785 1
int	   in_broadcast(struct in_addr, struct ifnet *, u_int);
@


1.108
log
@Kill in_localaddr(), one less usage of the global list of IPv4 addresses.

This function is used only once in our tree to optimize the size of the
MSS if the forward address correspond to a host on one of our subnets,
but only if ip.mutdisc is disable, which is not the default!

While here get rid of the "#ifdef RTV_MTU", it is here.

ok henning@@, mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.107 2014/04/21 10:07:58 henning Exp $	*/
d45 9
a53 1
#include <machine/endian.h>
@


1.107
log
@remove a define in an #ifdef notyet - "not yet" for 19 years gotta be
enough.
remove a define in an #ifdef notdef /* obsolete */ - 14 years are enough
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.106 2014/04/21 10:05:27 henning Exp $	*/
a780 1
int	   in_localaddr(struct in_addr, u_int);
@


1.106
log
@annotate all #endifs to make clear what #if(def) they end
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.105 2014/04/21 09:57:27 henning Exp $	*/
a642 3
#ifdef notyet
#define	IPCTL_DEFMTU		4	/* default MTU */
#endif
a650 3
#ifdef notdef	/*obsolete*/
#define IPCTL_GIF_TTL		13	/* default TTL for gif encap packet */
#endif
@


1.105
log
@cosmetic changes regarding #ifdef to make things more obvious, ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.104 2014/04/20 09:38:19 henning Exp $	*/
d46 1
a46 1
#endif
d51 1
a51 1
#endif
a94 1

d154 1
a154 1
#endif
d172 1
a172 1
#endif
d228 1
a228 1
#endif
d263 1
a263 1
#endif
d363 1
a363 1
#endif
@


1.104
log
@move in_cksum_phdr from in.h (under #ifdef _KERNEL, at least) to ip_output.c
nothing except in_proto_cksum_out() uses it any more, and that's a good
thing. was on tech for 3 months, discussed with many
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.103 2014/04/20 09:30:56 henning Exp $	*/
a769 1

d776 2
a777 1
#endif
d779 1
a779 1
#else
@


1.103
log
@nuke in_cksum_addword()
don't we all love functions implemented in header files? was under #ifdef
_KERNEL at least.
incremental checksum updates don't really make sense any more, this is
incredibly hard to get right, and doesn't fit the way our kernel deals
with the checksums these days. consequently, nothing uses in_cksum_addword
any more.
was on tech for 3 months, tested by & discussed with many.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.101 2013/11/11 09:15:34 mpi Exp $	*/
a779 31
/*
 * in_cksum_phdr:
 *
 *	Compute significant parts of the IPv4 checksum pseudo-header
 *	for use in a delayed TCP/UDP checksum calculation.
 *
 *	Args:
 *
 *		src		Source IP address
 *		dst		Destination IP address
 *		lenproto	htons(proto-hdr-len + proto-number)
 */
static __inline u_int16_t __attribute__((__unused__))
in_cksum_phdr(u_int32_t src, u_int32_t dst, u_int32_t lenproto)
{
	u_int32_t sum;

	sum = lenproto +
	      (u_int16_t)(src >> 16) +
	      (u_int16_t)(src /*& 0xffff*/) +
	      (u_int16_t)(dst >> 16) +
	      (u_int16_t)(dst /*& 0xffff*/);

	sum = (u_int16_t)(sum >> 16) + (u_int16_t)(sum /*& 0xffff*/);

	if (sum > 0xffff)
		sum -= 0xffff;

	return (sum);
}

@


1.102
log
@put the in{,6}_delayed_cksum() and in{,6}_proto_cksum_out() prototypes
into consistent locations; ok henning@@
@
text
@a810 16
/*
 * in_cksum_addword:
 *
 *	Add the two 16-bit network-order values, carry, and return.
 */
static __inline u_int16_t __attribute__((__unused__))
in_cksum_addword(u_int16_t a, u_int16_t b)
{
	u_int32_t sum = a + b;

	if (sum > 0xffff)
		sum -= 0xffff;

	return (sum);
}

@


1.101
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.100 2013/10/23 15:12:42 mpi Exp $	*/
a834 1
void	   in_delayed_cksum(struct mbuf *);
@


1.100
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.99 2013/10/23 13:39:35 mpi Exp $	*/
d844 2
@


1.99
log
@No need to expose twice in_socktrim(), it is only used in one file.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.98 2013/10/21 12:43:17 deraadt Exp $	*/
d827 2
a836 1
char	  *inet_ntoa(struct in_addr);
d839 5
@


1.98
log
@Remove some historical comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.97 2013/10/09 09:33:43 mpi Exp $	*/
a834 1
void	   in_socktrim(struct sockaddr_in *);
@


1.97
log
@Introduce in_ifdetach() a function to remove all the IPv4 addresses
of an interface, named after its IPv6 equivalent.

Make use of it instead of removing addresses by hand when detaching
or destroying an interface.  As a bonus, multicast records linked
to the just divorced^Wdetached interface are no longer leaked.

No objection from the gang, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.96 2013/03/28 15:05:32 bluhm Exp $	*/
a30 2
 *
 *	@@(#)in.h	8.3 (Berkeley) 1/3/94
a283 3

/* 14-17 left empty for future compatibility with FreeBSD */

@


1.96
log
@Convert the satosin, sintosa, ifatoia, satosin6, sin6tosa, ifatoia6
defines into static inline functions.  This allows the compiler to
check the source type before casting.
liked by many;  OK mpi@@ haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.95 2012/10/21 13:06:03 benno Exp $	*/
d843 1
@


1.95
log
@Add the IP_DIVERTFL socket option on divert(4) sockets to control
which packets (as in direction) of the traffic will be diverted
through the divert socket.
ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.94 2012/09/15 00:47:08 guenther Exp $	*/
d847 28
a874 3
#define	satosin(sa)	((struct sockaddr_in *)(sa))
#define	sintosa(sin)	((struct sockaddr *)(sin))
#define	ifatoia(ifa)	((struct in_ifaddr *)(ifa))
@


1.94
log
@Improve POSIX/SUS compliance of <netdb.h>, <sys/socket.h>, and <sys/un.h>.

Much ports testing of various versions by naddy@@ and jasper@@
ok matthew@@, miller@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.93 2012/07/16 18:05:36 markus Exp $	*/
d309 1
d311 3
@


1.93
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.92 2012/07/10 11:49:42 guenther Exp $	*/
d48 5
@


1.92
log
@Instead of <arpa/inet.h> pulling in <netinet/in.h>, just copy in the
three things that it needed from there: INET_ADDRSTRLEN, INET6_ADDRSTRLEN,
and struct in_addr.  Add protecting #ifndefs to netinet6?/in6?.h for those.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.91 2012/06/26 06:39:27 guenther Exp $	*/
d301 1
@


1.91
log
@Improve compliance for <arpa/inet.h> and <netinet/in.h> to define/declare
all the symbols that POSIX says they must and fewer that they can't and,
most importantly, to not require a specific ordering of headers.

ports testing by naddy@@
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.90 2011/07/06 01:57:37 dlg Exp $	*/
d144 2
d152 1
d357 1
d359 1
@


1.90
log
@allow /31s on broadcast interfaces (eg ethernet) to work as per rfc3021.
the issue in our kernel was the broadcast address calculated on the /31
caused a ton of checks for use of broadcast addresses to kick in and
prevent one of the two addresses on the /31 from being used.

this diff basically detects if a /31 has been configured and doesnt
configure a broadcast address for it, which makes the ips usable
for normal traffic.

i wrote this so i could interoperate with "carrier" network gear
better, and sthen wants it so he can conserve address space use.

the further special casing of broadcast address handling was from claudio@@

ok claudio@@ markus@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.89 2011/06/15 09:11:01 mikeb Exp $	*/
d43 7
d301 2
d320 2
d356 2
d752 2
d761 1
a761 2
#include <sys/cdefs.h>

d767 1
@


1.89
log
@Add IP_RECVRTABLE socket option to be used with a IPPROTO_IP
level that allows one to retrieve the original routing domain
of UDP datagrams diverted by the pf via "divert-to" with a
recvmsg(2).

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.88 2011/05/02 13:48:38 mikeb Exp $	*/
d189 6
@


1.88
log
@recognize SO_RTABLE socket option at the SOL_SOCKET level;
discussed with and ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.87 2011/04/28 09:56:27 claudio Exp $	*/
d284 1
@


1.87
log
@Make in_broadcast() rdomain aware. Mostly mechanical change.
This fixes the problem of binding sockets to broadcast IPs in other
rdomains.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.86 2011/04/04 17:44:43 henning Exp $	*/
d284 2
@


1.86
log
@de-guttenberg our stack a bit
we don't need 7 f***ing copies of the same code to do the protocol checksums
(or not, depending on hw capabilities). claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.85 2010/09/23 04:45:15 yasuoka Exp $	*/
d795 1
a795 1
int	   in_broadcast(struct in_addr, struct ifnet *);
@


1.85
log
@add a new IP level socket option IP_PIPEX.  This option is used for L2TP
support by pipex.
OK henning@@, "Carry on" blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.84 2010/06/07 13:26:35 henning Exp $	*/
d803 1
@


1.84
log
@unfortunately classful routing isn't 100% dead, mostly thanks to ancient
netboot methods using rarp, thus only learning their IP address without
mask. And of course the next step is a broadcast - which goes to the
broadcast address calculated classful. *sigh*. PR6382
instead of storing a second broadcast address per ifaddr as we used to
figure out wether we're dealing with a classful broadcast on the fly. the
math is extremely cheap and all my previous profilings showed that cpu
cycles are basically free, we're constrained by memory access.
excellent analysis by Pascal Lalonde <plalonde at overnet.qc.ca> who also
submitted the PR. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.83 2010/05/11 09:25:10 claudio Exp $	*/
d283 1
@


1.83
log
@Add IPPROTO_MPLS for MPLS in gif(4) encapsulation.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.82 2009/10/04 16:08:37 michele Exp $	*/
d197 7
@


1.82
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.81 2009/09/08 17:52:17 michele Exp $	*/
d76 1
@


1.81
log
@I had not enough oks to commit this diff.
Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.79 2009/06/05 00:05:22 claudio Exp $	*/
d81 4
d333 1
a333 1
#define	IPPROTO_MAXID	(IPPROTO_PFSYNC + 1)	/* don't list to IPPROTO_MAX */
d577 18
@


1.80
log
@Add support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 8000

test, bugfix and ok by reyk@@
manpage help and ok by jmc@@
no objections from many others.
@
text
@a76 1
#define	IPPROTO_DIVERT		241		/* Divert sockets */
d329 1
a329 1
#define	IPPROTO_MAXID	(IPPROTO_DIVERT + 1)	/* don't list to IPPROTO_MAX */
a572 1
	{ "divert", CTLTYPE_NODE }, \
@


1.79
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.78 2008/12/24 07:41:59 dlg Exp $	*/
d77 1
d330 1
a330 1
#define	IPPROTO_MAXID	(IPPROTO_PFSYNC + 1)	/* don't list to IPPROTO_MAX */
d574 1
@


1.78
log
@report the number of packets that arp resolution is holding onto until it
gets a mac addr for an ip under net.inet.ip.arpqueued.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.76 2007/12/14 18:33:40 deraadt Exp $	*/
d769 1
a769 1
int	   in_localaddr(struct in_addr);
@


1.77
log
@IP_RECVDSTPORT, allows you to get the destination port of UDP datagrams
for pf(4) diverted packets; based on patch by Scot Loach; ok beck@@
@
text
@d617 2
a618 1
#define	IPCTL_MAXID		36
d657 1
d695 2
a696 1
	NULL \
@


1.76
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.75 2007/12/13 20:00:53 reyk Exp $	*/
d270 1
@


1.75
log
@implement sysctls to report IP, TCP, UDP, and ICMP statistics and
change netstat to use them instead of accessing kvm for it. more
protocols will be added later.

discussed with deraadt@@ claudio@@ gilles@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.74 2007/09/18 18:56:02 markus Exp $	*/
d328 1
a328 1
#define	IPPROTO_MAXID	(IPPROTO_CARP + 1)	/* don't list to IPPROTO_MAX */
d444 128
d614 3
a616 1
#define	IPCTL_MAXID		34
d652 3
a654 1
	{ "stats", CTLTYPE_STRUCT } \
d690 2
@


1.74
log
@allow 4095 instead of 20 multicast group memberships per socket (you need
one entry for each multicast group and interface combination). this allows
you to run OSPF with more than 10 interfaces.
adapted from freebsd; ok claudio, henning, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.73 2006/10/11 09:34:51 henning Exp $	*/
d485 2
a486 1
#define	IPCTL_MAXID		33
d521 2
a522 1
	{ "multipath", CTLTYPE_INT } \
d557 2
a558 1
	&ipmultipath \
@


1.73
log
@implement IP_MINTTL socket option fo tcp sockets
This is for RFC3682 aka the TTL security hack - sender sets TTL to 255,
receiver checks no router on the way (or, no more than expected) reduced
the TTL. carp uses that technique already.
modeled after FreeBSD implementation.
ok claudio djm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.71 2006/06/18 11:47:45 pascoe Exp $	*/
d293 7
a299 1
#define	IP_MAX_MEMBERSHIPS	20	/* per socket; must fit in one mbuf */
@


1.72
log
@implement IP_RECVTTL socket option.
when set on raw or udp sockets, userland receives the incoming packet's TTL
as ancillary data (cmsg shitz). modeled after the FreeBSD implementation.
ok claudio djm deraadt
@
text
@d269 1
@


1.71
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.70 2006/05/29 20:42:27 claudio Exp $	*/
d268 1
@


1.70
log
@Make savecontrol functions more generic and use them now for raw IP too.
Additionally add the IP_RECVIF option which returns the interface a packet
was received on. OK markus@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.69 2006/05/26 20:50:41 deraadt Exp $	*/
d476 2
a477 1
#define	IPCTL_MAXID		32
d512 1
d547 1
@


1.69
log
@rename jumbo mtu to if_hardmtu; ok brad reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.68 2005/10/05 17:32:22 norby Exp $	*/
d267 1
@


1.68
log
@Add multicast routing to GENERIC.

It is now possible to enable multicast routing in the kernel with
the sysctl option net.inet.ip.mforwarding=1

Based on intial work by msf@@

help claudio@@
ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.67 2005/06/06 04:49:10 henning Exp $	*/
a311 5

/*
 * JUMBO MTU
 */
#define IP_JUMBO_MTU	9000
@


1.67
log
@another leftover from the src routing adventure a year ago
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.66 2005/05/27 04:55:28 mcbride Exp $	*/
d479 2
a480 1
#define	IPCTL_MAXID		31
d514 1
d548 1
@


1.66
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.65 2005/05/24 04:20:25 markus Exp $	*/
a219 9
struct sockaddr_rtin {
	u_int8_t    rtin_len;
	sa_family_t rtin_family;
	in_port_t   rtin_port;
	struct      in_addr rtin_dst;
	struct	    in_addr rtin_src;
	int8_t      rtin_zero[4];
};

a628 2
#define satortin(rtin)	((struct sockaddr_rtin *)(rtin))

@


1.65
log
@add net.inet.ip.ifq for monitoring and changing ifqueue; similar to netbsd
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.64 2005/01/14 14:51:27 mcbride Exp $	*/
d321 5
@


1.64
log
@Add kernel support for Protocol Independant Multicast (PIM)
Information: http://netweb.usc.edu/pim/

From Pavlin Radoslavov <pavlin@@icir.org>

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.63 2004/11/24 01:25:42 mcbride Exp $	*/
d482 2
a483 1
#define	IPCTL_MAXID		30
d516 1
d544 1
@


1.63
log
@Multicast routing cleanup from Pavlin Radoslavov
- sync ip_mroute.c with NetBSD
- import some FreeBSD changes to MFC entry handling
- set im->im_vif correctly when sending IGMPMSG_WRONGVIF
- increment mrtstat.mrts_upcalls correctly
- return error from get_sg_cnt() if there is no matching forwarding entry

ok henning@@ brad@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.62 2004/06/06 16:49:09 cedric Exp $	*/
d434 1
a434 1
	{ 0, 0 }, \
@


1.62
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.61 2004/02/15 11:16:08 markus Exp $	*/
d611 2
@


1.61
log
@switch to sysctl_int_arr(); ok itojun, henning, miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.60 2003/12/17 21:36:17 mcbride Exp $	*/
d220 9
d628 2
@


1.60
log
@Change pfsync IP protocol and multicast group numbers.

IPPROTO_PFSYNC -> 240
INADDR_PFSYNC_GROUP -> 224.0.0.240

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.59 2003/12/15 07:11:30 mcbride Exp $	*/
d506 32
@


1.59
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.58 2003/10/17 21:04:58 mcbride Exp $	*/
d76 1
a76 1
#define	IPPROTO_PFSYNC		136		/* PFSYNC */
d204 1
a204 1
#define	INADDR_PFSYNC_GROUP	__IPADDR(0xe0000088)	/* 224.0.0.136 */
@


1.58
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.57 2003/06/02 23:28:13 millert Exp $	*/
d76 1
d204 1
@


1.57
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.56 2002/03/14 01:27:11 millert Exp $	*/
d75 1
d202 1
d317 1
a317 1
#define	IPPROTO_MAXID	(IPPROTO_IPCOMP + 1)	/* don't list to IPPROTO_MAX */
d429 4
@


1.56
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.55 2001/11/06 21:26:33 jakob Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.55
log
@send igmp v2 leave messages to allrouters address (PR#2164)
patch based on parts from NetBSD submitted by goeran@@cdg.chalmers.se
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.54 2001/07/05 08:40:12 angelos Exp $	*/
d514 1
a514 1
int	   bindresvport __P((int, struct sockaddr_in *));
d516 1
a516 1
int	   bindresvport_sa __P((int, struct sockaddr *));
d567 8
a574 8
int	   in_broadcast __P((struct in_addr, struct ifnet *));
int	   in_canforward __P((struct in_addr));
int	   in_cksum __P((struct mbuf *, int));
int	   in4_cksum __P((struct mbuf *, u_int8_t, int, int));
void	   in_delayed_cksum __P((struct mbuf *));
int	   in_localaddr __P((struct in_addr));
void	   in_socktrim __P((struct sockaddr_in *));
char	  *inet_ntoa __P((struct in_addr));
@


1.55.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.55 2001/11/06 21:26:33 jakob Exp $	*/
d514 1
a514 1
int	   bindresvport(int, struct sockaddr_in *);
d516 1
a516 1
int	   bindresvport_sa(int, struct sockaddr *);
d567 8
a574 8
int	   in_broadcast(struct in_addr, struct ifnet *);
int	   in_canforward(struct in_addr);
int	   in_cksum(struct mbuf *, int);
int	   in4_cksum(struct mbuf *, u_int8_t, int, int);
void	   in_delayed_cksum(struct mbuf *);
int	   in_localaddr(struct in_addr);
void	   in_socktrim(struct sockaddr_in *);
char	  *inet_ntoa(struct in_addr);
@


1.54
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.53 2001/07/05 08:31:47 jjbg Exp $	*/
d204 1
@


1.53
log
@IPComp itself (include files). angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.52 2001/06/25 00:11:57 angelos Exp $	*/
d467 1
a467 1
#define IPCTL_IPSEC_IPCOMP_ALGORITHM	29
@


1.52
log
@Use in_cksum_phdr() rather than in_cksum() -- from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.51 2001/06/24 23:41:47 angelos Exp $	*/
d265 1
d282 1
d318 1
a318 1
#define	IPPROTO_MAXID	(IPPROTO_ETHERIP + 1)	/* don't list to IPPROTO_MAX */
d419 11
d467 2
a468 1
#define	IPCTL_MAXID		29
d500 1
@


1.51
log
@Import in_cksum_phdr() and in_cksum_addword() from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.50 2001/06/24 23:33:55 angelos Exp $	*/
d497 7
a550 7
__BEGIN_DECLS
int	   bindresvport __P((int, struct sockaddr_in *));
struct sockaddr;
int	   bindresvport_sa __P((int, struct sockaddr *));
__END_DECLS

#else
@


1.50
log
@Import in_delayed_cksum() and convert to using it; also, don't do
TCP/UDP HW checksumming if doing IP fragmentation. From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.49 2001/06/23 06:38:10 angelos Exp $	*/
d496 47
@


1.49
log
@Typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.48 2001/06/23 06:37:31 angelos Exp $	*/
d508 1
@


1.48
log
@Prototype for in4_cksum()
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.47 2001/06/12 10:57:22 angelos Exp $	*/
d507 1
a507 1
int	   in4_cksum __P((strct mbuf *, u_int8_t, int, int));
@


1.47
log
@IPsec setsockopts.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.46 2001/06/09 07:03:40 angelos Exp $	*/
d507 1
@


1.46
log
@Inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.45 2001/05/27 05:27:01 angelos Exp $	*/
d263 2
a264 1
#define IP_IPSEC_AUTH		27   /* buf; IPsec authentication material */
@


1.45
log
@Add some IPsec-related IP-level socket options.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.44 2001/05/17 18:41:46 provos Exp $	*/
d516 2
a517 2
#endif
#endif /* !_NETINET_IN_H_ */
@


1.44
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.43 2000/12/09 01:32:09 itojun Exp $	*/
d259 5
@


1.43
log
@remove duplicated def of INET_ADDRSTRLEN.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.42 2000/09/19 03:20:57 angelos Exp $	*/
d504 3
@


1.42
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.41 2000/09/18 22:06:36 provos Exp $	*/
a217 2

#define INET_ADDRSTRLEN                 16
@


1.41
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.40 2000/06/18 07:06:13 itojun Exp $	*/
a261 2
#define IPSEC_OUTSA		39   /* set the outbound SA for a socket */

d435 1
a435 1
#define IPCTL_IPSEC_ACL		14	/* ingress IPsec access control */
d467 1
a467 1
	{ "ipsec-acl", CTLTYPE_INT }, \
@


1.40
log
@for mcdonald-simple-ipsec-api get/setsockopt, variable size was mixed up.
in some place sizeof(u_char), and in some place sizeof(int) were used.
previous code can cause problem in big endian machines.
now it always uses "int" (isakmpd uses int, so it should be okay)

set m_len properly on mcdonald-simple-ipsec-api getsockopt.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.39 2000/05/25 01:22:00 itojun Exp $	*/
d450 3
a452 1
#define	IPCTL_MAXID		27
d482 2
@


1.39
log
@net.inet.ip.gif_ttl (and IPv6 counterpart) is never used.
enforce type checking on IN6_ARE_ADDR_EQUAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.38 2000/02/09 07:37:14 itojun Exp $	*/
d258 3
a260 3
#define IP_AUTH_LEVEL		20   /* u_char; authentication used */
#define IP_ESP_TRANS_LEVEL	21   /* u_char; transport encryption */
#define IP_ESP_NETWORK_LEVEL	22   /* u_char; full-packet encryption */
@


1.38
log
@improve RFC2553/2292 conformance.  netinet6/{ip6,icmp6,in6}.h should not
be included.
neitnet6/{ip6,icmp6}.h includes #error statements only - i'll remove them
couple of days later.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.37 2000/01/26 03:43:17 deraadt Exp $	*/
d434 1
d436 1
d466 1
a466 1
	{ "gifttl", CTLTYPE_INT }, \
@


1.38.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.43 2000/12/09 01:32:09 itojun Exp $	*/
d219 2
d258 5
a262 3
#define IP_AUTH_LEVEL		20   /* int; authentication used */
#define IP_ESP_TRANS_LEVEL	21   /* int; transport encryption */
#define IP_ESP_NETWORK_LEVEL	22   /* int; full-packet encryption */
a433 1
#ifdef notdef	/*obsolete*/
d435 1
a435 2
#endif
#define IPCTL_IPSEC_EXPIRE_ACQUIRE 14   /* How long to wait for key mgmt. */
d448 1
a448 3
#define	IPCTL_MTUDISC		27	/* allow path MTU discovery */
#define	IPCTL_MTUDISCTIMEOUT	28	/* allow path MTU discovery */
#define	IPCTL_MAXID		29
d464 2
a465 2
	{ 0, 0 }, \
	{ "ipsec-expire-acquire", CTLTYPE_INT }, \
a477 2
	{ "mtudisc", CTLTYPE_INT }, \
	{ "mtudisctimeout", CTLTYPE_INT }, \
@


1.38.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.38.2.1 2001/05/14 22:40:07 niklas Exp $	*/
a258 6
#define IP_IPSEC_LOCAL_ID	23   /* buf; IPsec local ID */
#define IP_IPSEC_REMOTE_ID	24   /* buf; IPsec remote ID */
#define IP_IPSEC_LOCAL_CRED	25   /* buf; IPsec local credentials */
#define IP_IPSEC_REMOTE_CRED	26   /* buf; IPsec remote credentials */
#define IP_IPSEC_LOCAL_AUTH	27   /* buf; IPsec local auth material */
#define IP_IPSEC_REMOTE_AUTH	28   /* buf; IPsec remote auth material */
a497 47
/*
 * in_cksum_phdr:
 *
 *	Compute significant parts of the IPv4 checksum pseudo-header
 *	for use in a delayed TCP/UDP checksum calculation.
 *
 *	Args:
 *
 *		src		Source IP address
 *		dst		Destination IP address
 *		lenproto	htons(proto-hdr-len + proto-number)
 */
static __inline u_int16_t __attribute__((__unused__))
in_cksum_phdr(u_int32_t src, u_int32_t dst, u_int32_t lenproto)
{
	u_int32_t sum;

	sum = lenproto +
	      (u_int16_t)(src >> 16) +
	      (u_int16_t)(src /*& 0xffff*/) +
	      (u_int16_t)(dst >> 16) +
	      (u_int16_t)(dst /*& 0xffff*/);

	sum = (u_int16_t)(sum >> 16) + (u_int16_t)(sum /*& 0xffff*/);

	if (sum > 0xffff)
		sum -= 0xffff;

	return (sum);
}

/*
 * in_cksum_addword:
 *
 *	Add the two 16-bit network-order values, carry, and return.
 */
static __inline u_int16_t __attribute__((__unused__))
in_cksum_addword(u_int16_t a, u_int16_t b)
{
	u_int32_t sum = a + b;

	if (sum > 0xffff)
		sum -= 0xffff;

	return (sum);
}

a500 2
int	   in4_cksum __P((struct mbuf *, u_int8_t, int, int));
void	   in_delayed_cksum __P((struct mbuf *));
a504 3
#define	in_hosteq(s,t)	((s).s_addr == (t).s_addr)
#define	in_nullhost(x)	((x).s_addr == INADDR_ANY)

d508 2
a509 2
#endif /* _KERNEL */
#endif /* _NETINET_IN_H_ */
@


1.38.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.38.2.2 2001/07/04 10:54:31 niklas Exp $	*/
a264 1
#define IP_IPCOMP_LEVEL		29   /* int; compression used */
a280 1
#define IPSEC_IPCOMP_LEVEL_DEFAULT IPSEC_LEVEL_DEFAULT
d316 1
a316 1
#define	IPPROTO_MAXID	(IPPROTO_IPCOMP + 1)	/* don't list to IPPROTO_MAX */
a416 11
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "ipcomp", CTLTYPE_NODE }, \
d454 1
a454 2
#define	IPCTL_IPSEC_IPCOMP_ALGORITHM	29
#define	IPCTL_MAXID		30
a485 1
	{ "ipsec-comp-alg", CTLTYPE_STRING }, \
@


1.38.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a203 1
#define	INADDR_ALLROUTERS_GROUP __IPADDR(0xe0000002)	/* 224.0.0.2 */
@


1.38.2.5
log
@Merge in -current from roughly a week ago
@
text
@d514 1
a514 1
int	   bindresvport(int, struct sockaddr_in *);
d516 1
a516 1
int	   bindresvport_sa(int, struct sockaddr *);
d567 8
a574 8
int	   in_broadcast(struct in_addr, struct ifnet *);
int	   in_canforward(struct in_addr);
int	   in_cksum(struct mbuf *, int);
int	   in4_cksum(struct mbuf *, u_int8_t, int, int);
void	   in_delayed_cksum(struct mbuf *);
int	   in_localaddr(struct in_addr);
void	   in_socktrim(struct sockaddr_in *);
char	  *inet_ntoa(struct in_addr);
@


1.38.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.38.2.5 2002/03/28 14:56:45 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.38.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a74 2
#define	IPPROTO_CARP		112		/* CARP */
#define	IPPROTO_PFSYNC		240		/* PFSYNC */
a200 2
#define	INADDR_CARP_GROUP	__IPADDR(0xe0000012)	/* 224.0.0.18 */
#define	INADDR_PFSYNC_GROUP	__IPADDR(0xe00000f0)	/* 224.0.0.240 */
d315 1
a315 1
#define	IPPROTO_MAXID	(IPPROTO_CARP + 1)	/* don't list to IPPROTO_MAX */
a426 4
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "carp", CTLTYPE_NODE }, \
@


1.38.2.8
log
@Merge with the trunk
@
text
@a506 32
#define	IPCTL_VARS { \
	NULL, \
	&ipforwarding, \
	&ipsendredirects, \
	&ip_defttl, \
	NULL, \
	NULL, \
	&ip_directedbcast, \
	&ipport_firstauto, \
	&ipport_lastauto, \
	&ipport_hifirstauto, \
	&ipport_hilastauto, \
	&ip_maxqueue, \
	&encdebug, \
	NULL, \
	&ipsec_expire_acquire, \
	&ipsec_keep_invalid, \
	&ipsec_require_pfs, \
	&ipsec_soft_allocations, \
	&ipsec_exp_allocations, \
	&ipsec_soft_bytes, \
	&ipsec_exp_bytes, \
	&ipsec_exp_timeout, \
	&ipsec_soft_timeout, \
	&ipsec_soft_first_use, \
	&ipsec_exp_first_use, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
}
@


1.38.2.9
log
@sync to head
@
text
@a219 9
struct sockaddr_rtin {
	u_int8_t    rtin_len;
	sa_family_t rtin_family;
	in_port_t   rtin_port;
	struct      in_addr rtin_dst;
	struct	    in_addr rtin_src;
	int8_t      rtin_zero[4];
};

a618 2
#define satortin(rtin)	((struct sockaddr_rtin *)(rtin))

@


1.37
log
@new bindresvport() semantics that itojun, shin, jean-luc and i have agreed on, which will be happy for the future. bindresvport_sa() for sockaddr *, too.  docs later..
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.36 2000/01/21 03:15:04 angelos Exp $	*/
d481 1
d483 1
@


1.36
log
@Rename the ip4_* routines to ipip_*, make it so GIF tunnels are not
affected by net.inet.ipip.allow (the sysctl formerly known as
net.inet.ip4.allow), rename the VIF ipip_input to ipip_mroute_input.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.35 2000/01/18 19:06:07 angelos Exp $	*/
d490 1
a490 1
int	   bindresvport_af __P((int, struct sockaddr *, int af));
@


1.35
log
@Bump IPPROTO_MAX to include IPPROTO_MOBILE and IPPROTO_ETHERIP.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.34 2000/01/11 01:13:49 angelos Exp $	*/
d321 1
a321 1
	{ "ip4", CTLTYPE_NODE }, \
@


1.34
log
@Remove ifdef'ed out definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.33 2000/01/10 06:59:21 angelos Exp $	*/
d314 1
a314 1
#define	IPPROTO_MAXID	(IPPROTO_AH + 1)	/* don't list to IPPROTO_MAX */
@


1.33
log
@Add 10 new ipsec-related sysctl variables...they are currently under
net.inet.ip; perhaps they should be moved under net.inet.ipsec or some
such.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.32 2000/01/10 04:30:52 angelos Exp $	*/
a140 21
#if 0	/*NRL IPv6*/
/*
 * IP Version 6 Internet address
 */
struct in6_addr {
	union {
		u_int8_t s6u_addr8[16];
		u_int16_t s6u_addr16[8];
		u_int32_t s6u_addr32[4];
	} s6_u;
#define s6_addr s6_u.s6u_addr8
/*
 * The rest are common, but not guaranteed to be portable. 64 bit access are
 * not available because the in6_addr in a sockaddr_in6 is not 64 bit aligned.
 */
#define s6_addr8 s6_u.s6u_addr8
#define s6_addr16 s6_u.s6u_addr16
#define s6_addr32 s6_u.s6u_addr32
};
#endif

a207 81
#if 0	/*NRL IPv6*/
/*
 * Tests for IPv6 address types
 */

#define	IN6_IS_ADDR_LINKLOCAL(addr) \
	(((addr)->s6_addr32[0] & htonl(0xffc00000)) == htonl(0xfe800000))

#define	IN6_IS_ADDR_LOOPBACK(addr) \
	(((addr)->s6_addr32[0] == 0) && ((addr)->s6_addr32[1] == 0) && \
	 ((addr)->s6_addr32[2] == 0) && ((addr)->s6_addr32[3] == htonl(1)))

#define	IN6_IS_ADDR_MULTICAST(addr) \
	((addr)->s6_addr8[0] == 0xff)
	
#define	IN6_IS_ADDR_SITELOCAL(addr) \
	(((addr)->s6_addr32[0] & htonl(0xffc00000)) == htonl(0xfec00000))

#define	IN6_IS_ADDR_UNSPECIFIED(addr) \
	(((addr)->s6_addr32[0] == 0) && ((addr)->s6_addr32[1] == 0) && \
	 ((addr)->s6_addr32[2] == 0) && ((addr)->s6_addr32[3] == 0))

#define	IN6_IS_ADDR_V4COMPAT(addr) \
	(((addr)->s6_addr32[0] == 0) && ((addr)->s6_addr32[1] == 0) && \
	 ((addr)->s6_addr32[2] == 0) && ((addr)->s6_addr32[3] & ~htonl(1)))

#define	IN6_IS_ADDR_V4MAPPED(addr) \
	(((addr)->s6_addr32[0] == 0) && ((addr)->s6_addr32[1] == 0) && \
	 ((addr)->s6_addr32[2] == htonl(0xffff)))

#define	IN6_ARE_ADDR_EQUAL(addr1, addr2) \
	(((addr1)->s6_addr32[0] == (addr2)->s6_addr32[0]) && \
	 ((addr1)->s6_addr32[1] == (addr2)->s6_addr32[1]) && \
	 ((addr1)->s6_addr32[2] == (addr2)->s6_addr32[2]) && \
	 ((addr1)->s6_addr32[3] == (addr2)->s6_addr32[3]))

/*
 * IPv6 Multicast scoping.  The scope is stored
 * in the bottom 4 bits of the second byte of the
 * multicast address.
 */
		     /* 0x0 */	/* reserved */
#define	IN6_NODE_LOCAL	0x1	/* node-local scope */
#define	IN6_LINK_LOCAL	0x2	/* link-local scope */
		     /* 0x3 */	/* (unassigned) */
		     /* 0x4 */	/* (unassigned) */
#define	IN6_SITE_LOCAL	0x5	/* site-local scope */
		     /* 0x6 */	/* (unassigned) */
		     /* 0x7 */	/* (unassigned) */
#define	IN6_ORG_LOCAL	0x8	/* organization-local scope */
		     /* 0x9 */	/* (unassigned) */
		     /* 0xA */	/* (unassigned) */
		     /* 0xB */	/* (unassigned) */
		     /* 0xC */	/* (unassigned) */
		     /* 0xD */	/* (unassigned) */
#define	IN6_GLOBAL	0xE	/* global scope */
		     /* 0xF */	/* reserved */

#define	IN6_MSCOPE(addr)	((addr)->s6_addr8[1] & 0x0f)

#define	IN6_IS_ADDR_MC_NODELOCAL(addr) \
	(IN6_IS_ADDR_MULTICAST(addr) && (IN6_MSCOPE(addr) == IN6_NODE_LOCAL))
#define	IN6_IS_ADDR_MC_LINKLOCAL(addr) \
	(IN6_IS_ADDR_MULTICAST(addr) && (IN6_MSCOPE(addr) == IN6_LINK_LOCAL))
#define	IN6_IS_ADDR_MC_SITELOCAL(addr) \
	(IN6_IS_ADDR_MULTICAST(addr) && (IN6_MSCOPE(addr) == IN6_SITE_LOCAL))
#define	IN6_IS_ADDR_MC_ORGLOCAL(addr) \
	(IN6_IS_ADDR_MULTICAST(addr) && (IN6_MSCOPE(addr) == IN6_ORG_LOCAL))
#define	IN6_IS_ADDR_MC_GLOBAL(addr) \
	(IN6_IS_ADDR_MULTICAST(addr) && (IN6_MSCOPE(addr) == IN6_GLOBAL))

/*
 * Definitions of the IPv6 special addresses
 */
extern const struct in6_addr in6addr_any;
#define IN6ADDR_ANY_INIT {{{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }}}

extern const struct in6_addr in6addr_loopback;
#define IN6ADDR_LOOPBACK_INIT {{{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }}}
#endif

a218 15
#if 0	/*NRL IPv6*/
/*
 * IP Version 6 socket address.
 */
#define SIN6_LEN 1
struct sockaddr_in6 {
	u_int8_t	sin6_len;
	sa_family_t	sin6_family;
	in_port_t	sin6_port;
	u_int32_t	sin6_flowinfo;
	struct in6_addr	sin6_addr;
	u_int32_t	sin6_scope_id;
};
#endif

a261 22
#if 0 /* NRL IPv6 */
#define IPV6_MULTICAST_IF	23   /* u_int; set/get multicast interface */
#define IPV6_MULTICAST_HOPS	24   /* int; set/get multicast hop limit */
#define IPV6_MULTICAST_LOOP	25   /* u_int; set/get multicast loopback */
#define IPV6_JOIN_GROUP		26   /* ipv6_mreq; join multicast group */
#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP /* XXX - for compatibility */
#define IPV6_LEAVE_GROUP	27   /* ipv6_mreq: leave multicast group */
#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP /* XXX - for compatibility */
#define IPV6_ADDRFORM		28   /* int; get/set form of returned addrs */
#define IPV6_UNICAST_HOPS	29   /* int; get/set unicast hop limit */
#define IPV6_PKTINFO		30   /* int; receive in6_pktinfo as cmsg */
#define IPV6_HOPLIMIT		31   /* int; receive int hoplimit as cmsg */
#define IPV6_NEXTHOP		32   /* int; receive sockaddr_in6 as cmsg */
#define IPV6_HOPOPTS		33   /* int; receive hop options as cmsg */
#define IPV6_DSTOPTS		34   /* int; receive dst options as cmsg */
#define IPV6_RTHDR		35   /* int; receive routing header as cmsg */
#define IPV6_PKTOPTIONS		36   /* int; send/receive cmsgs for TCP */
#define IPV6_CHECKSUM		37   /* int; offset to place send checksum */
#define ICMPV6_FILTER		38   /* struct icmpv6_filter; get/set filter */
#define ICMP6_FILTER		ICMP6_FILTER
#endif

a263 4
#if 0 /*KAME IPSEC*/
#define IP_IPSEC_POLICY		?? /* struct; get/set security policy */
#endif

a279 10
#if 0 /* NRL IPv6 */
/*
 * IPv6 Routing header types
 */
#define IPV6_RTHDR_TYPE_0	0 /* IPv6 Routing header type 0 */   

#define IPV6_RTHDR_LOOSE	0 /* this hop need not be a neighbor */
#define IPV6_RTHDR_STRICT	1 /* this hop must be a neighbor */
#endif

a294 18
#if 0 /* NRL IPv6 */
/*
 * Argument structure for IPV6_ADD_MEMBERSHIP and IPV6_DROP_MEMBERSHIP.
 */
struct ipv6_mreq {
	struct	in6_addr	ipv6mr_multiaddr; /* IPv6 multicast addr */
	unsigned int		ipv6mr_interface; /* Interface index */
};

/*
 * Argument structure for IPV6_PKTINFO control messages
 */
struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	unsigned int ipi6_ifindex;
};
#endif

a306 3
#if 0 /* NRL IPv6 */
#define INET6_ADDRSTRLEN	46
#endif
@


1.32
log
@Add net.inet.ip.ipsec-invalid-life, default value 60 seconds; the
amount of time embryonic SAs will be kept before they have to be
initialized by key management (this only affects automated key
management).
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.31 2000/01/09 22:17:56 angelos Exp $	*/
d611 12
a622 1
#define	IPCTL_MAXID		16
d641 11
@


1.31
log
@Add a sysctl for IPsec ingress access control (better explanation on a
follow-up commit).
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.30 2000/01/07 21:45:22 angelos Exp $	*/
d609 3
a611 2
#define IPCTL_IPSEC_ACL		14	/* Ingress IPsec access control */
#define	IPCTL_MAXID		15
d629 1
@


1.30
log
@Forgot the names here...
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.29 2000/01/07 19:37:09 angelos Exp $	*/
d609 2
a610 1
#define	IPCTL_MAXID		14
d627 1
@


1.29
log
@IPPROTO_GRE and IPPROTO_MOBILE definitions (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.28 1999/12/18 16:55:44 deraadt Exp $	*/
d538 1
a538 1
	{ 0, 0 }, \
d546 1
a546 1
	{ 0, 0 }, \
@


1.28
log
@too much software forgets to include sys/socket.h, SIGH
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.27 1999/12/16 21:30:34 deraadt Exp $	*/
d51 1
a51 1
#define IPPROTO_HOPOPTS		IPPROTO_IP	/* Hop-by-hop option header. */
d64 2
a65 2
#define IPPROTO_ROUTING		43		/* Routing header. */
#define IPPROTO_FRAGMENT	44		/* Fragmentation/reassembly header. */
d67 1
d70 1
d73 1
a73 1
#define IPPROTO_DSTOPTS		60		/* Destination options header. */
@


1.27
log
@rresvport_af() and bindresvport_af()
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.26 1999/12/08 06:50:19 itojun Exp $	*/
d635 1
@


1.26
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.25 1999/10/28 03:29:49 angelos Exp $	*/
d635 1
@


1.25
log
@Add etherip.allow sysctl node entry.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.24 1999/10/28 01:55:12 angelos Exp $	*/
d66 1
d75 2
d139 1
d158 4
d227 1
d306 1
d319 1
d332 3
d377 1
d397 1
d401 4
d421 1
d429 1
d446 1
d462 1
d476 1
d478 1
d606 2
a607 1
#define	IPCTL_MAXID		13
d623 1
d625 3
@


1.24
log
@Define IPPROTO_ETHERIP.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.23 1999/04/11 19:41:36 niklas Exp $	*/
d515 46
@


1.23
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.22 1999/04/09 23:28:44 niklas Exp $	*/
d72 1
@


1.22
log
@The kernel parts of a sysctl that can switch on/off IP-in-IP (protocol 4)
support, when IPSEC is compiled in.  The default is disabled.  Turn on with:
sysctl -w net.inet.ip4.allow=1
***Only*** do this if you are really knowing what you do!
This control does not control the tunnel modes of ESP and AH.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.21 1999/03/27 21:04:21 provos Exp $	*/
d459 1
a459 1
#define	IPPROTO_MAXID	(IPPROTO_IDP + 1)	/* don't list to IPPROTO_MAX */
d484 30
a513 1
	{ "idp", CTLTYPE_NODE }, \
d532 2
a533 1
#define	IPCTL_MAXID		12
d540 1
a540 1
	{ "mtu", CTLTYPE_INT }, \
d548 1
@


1.21
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.20 1999/03/24 02:31:03 cmetz Exp $	*/
d466 1
a466 1
	{ 0, 0 }, \
@


1.20
log
@Removed old NRL convention in6a_words virtual-field from struct in6_addr.
Let's not encourage the use of an obsolete convention.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.19 1999/02/24 04:39:39 cmetz Exp $	*/
d381 2
@


1.19
log
@Added in.h definitions required by IPv6 Basic API and Advanced API specs, and
a few extras that are just plain useful. Note that I used u_intxx_t instead of
the POSIX p1003.1g uintxx_t that those specs mandate, so as to not increase the
number of outside symbol definitions that in.h depends on.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.18 1999/02/17 23:51:12 deraadt Exp $	*/
a151 1
#define in6a_words s6_u.s6u_addr32
@


1.18
log
@add fragment flood protection; configureable using sysctl ip.maxqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.17 1999/01/10 02:37:33 deraadt Exp $	*/
d129 1
a129 1
 * Internet address (a structure for historical reasons)
d136 20
d220 80
a299 1
 * Socket address, internet style.
d310 13
d355 3
a357 1
	/* 14-17 left empty for future compatibility with FreeBSD */
d360 2
a361 2
#define IP_ESP_TRANS_LEVEL      21   /* u_char; transport encryption */
#define IP_ESP_NETWORK_LEVEL    22   /* u_char; full-packet encryption */
d363 19
d399 7
d423 16
d445 6
@


1.17
log
@merge INPROTO_* tables
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.16 1999/01/07 06:13:34 deraadt Exp $	*/
d339 2
a340 1
#define	IPCTL_MAXID		11
d354 1
@


1.16
log
@update for ipv6
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.15 1999/01/03 18:20:35 millert Exp $	*/
d51 1
d56 1
a56 1
#define	IPPROTO_IPV4		4		/* IP inside IP */
d63 3
a65 1
#define	IPPROTO_IPV6		51 		/* IPv6-in-IPv4 tunnelling */
d68 3
d73 1
a74 1
#define	IPPROTO_RAW		255		/* raw IP packet */
a75 1

@


1.15
log
@use int8_t, not char in c++ case for consistency and fix indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.14 1999/01/01 11:15:03 deraadt Exp $	*/
d55 1
d62 1
@


1.14
log
@mirror OSF1 solution for ip_opts[] within struct called ip_opts; dm@@, pr#681
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.13 1998/05/18 21:10:26 provos Exp $	*/
d213 1
a213 1
	char	Ip_opts[40];		/* cannot have same name as class */
@


1.13
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.12 1998/02/11 03:58:31 deraadt Exp $	*/
d212 3
d216 1
@


1.12
log
@make IPPORT_USERRESERVED a nice fat number -> random ports look really funky.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.11 1997/11/30 18:50:19 millert Exp $	*/
d249 1
a249 1
#define IPSEC_LEVEL_DEFAULT     IPSEC_LEVEL_NONE
@


1.11
log
@Move in_addr_t and in_port_t to <sys/types.h> and add sa_family_t
and suseconds_t types for XPG4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.10 1997/07/28 15:22:30 millert Exp $	*/
d113 1
a113 1
#define	IPPORT_USERRESERVED	5000
d118 2
a119 2
#define IPPORT_HIFIRSTAUTO	40000
#define IPPORT_HILASTAUTO	44999
@


1.10
log
@Make struct in_addr contain an in_addr_t since that's what
in_addr_t is for (same basic type so we don't break anything).
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.9 1997/07/02 00:18:55 millert Exp $	*/
d196 5
a200 5
	u_int8_t  sin_len;
	u_int8_t  sin_family;
	u_int16_t sin_port;
	struct	  in_addr sin_addr;
	int8_t	  sin_zero[8];
@


1.9
log
@Move prototype for bindresvport(3) to <netiniet/in.h> as it is
not rpc-specific and other stuff uses it now.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.8 1997/02/28 03:44:52 angelos Exp $	*/
d125 1
a125 1
	u_int32_t s_addr;
@


1.8
log
@IPsec socket API hooks are in.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.7 1997/02/20 01:07:45 deraadt Exp $	*/
d344 7
d352 1
a352 1
#ifdef _KERNEL
@


1.7
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 1
a1 1
/*	$OpenBSD: in.h,v 1.5 1996/03/03 22:30:29 niklas Exp $	*/
d234 21
@


1.6
log
@From FreeBSD (with slightly different sysctl names):

"... Allow the user to nominate one of three ranges of port numbers as
candidates for selecting a local address to replace a zero port number.
The ranges are selected via a setsockopt(s, IPPROTO_IP, IP_PORTRANGE, &arg)
call.  The three ranges are: default, high (to bypass firewalls) and
low (to get a port below 1024).

The default and high port ranges are sysctl settable under sysctl
net.inet.ip.portrange.* [net.inet.ip.portfirst, net.inet.ip.portlast,
net.inet.ip.porthifirst, and net.inet.ip.porthilast currently in OpenBSD.]

This code also fixes a potential deadlock if the system accidently ran out
of local port addresses. It'd drop into an infinite while loop.

The secure port selection (for root) should reduce overheads and increase
reliability of rlogin/rlogind/rsh/rshd if they are modified to take
advantage of it."
@
text
@d61 2
@


1.5
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 2
d72 33
d114 6
d230 2
d249 8
d301 5
a305 1
#define	IPCTL_MAXID		7
d315 4
@


1.4
log
@Added INADDR_MAX_LOCAL_GROUP, since it was present in 4.4-Lite
and gated wants it to there ;)
@
text
@d1 2
a2 1
/*	$NetBSD: in.h,v 1.17 1995/06/04 05:06:55 mycroft Exp $	*/
d95 1
a95 1
#define	__IPADDR(x)	htonl((u_int32_t)(x))
d248 3
a250 2
#define IPCTL_SOURCEROUTE	5	/* may perform source routes */
#define	IPCTL_MAXID		6
d259 1
@


1.3
log
@add inet_ntoa() to the kernel. use it to log nicer messages. idea from freebsd
@
text
@d144 1
@


1.2
log
@add sysctl net.inet.ip.sourceroute option; default to 0. copied from freebsd
@
text
@d265 1
@


1.1
log
@Initial revision
@
text
@d246 2
a247 1
#define	IPCTL_MAXID		5
d255 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
