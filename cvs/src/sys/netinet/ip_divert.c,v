head	1.50;
access;
symbols
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.50
date	2017.09.05.07.59.11;	author mpi;	state Exp;
branches;
next	1.49;
commitid	fWUv1bxRFYaflFag;

1.49
date	2017.07.27.12.04.42;	author mpi;	state Exp;
branches;
next	1.48;
commitid	5D4ggruywFBANoeX;

1.48
date	2017.06.26.09.32.32;	author mpi;	state Exp;
branches;
next	1.47;
commitid	gZMpLuRopIsWa0cT;

1.47
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.46;
commitid	p51F2KIwIJB1dU8P;

1.46
date	2017.04.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	4O5LUh13nIhVt6oZ;

1.45
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.44;
commitid	ZsxSSZJSFxZH81LL;

1.44
date	2017.02.09.15.32.56;	author jca;	state Exp;
branches;
next	1.43;
commitid	fXr0qQRRcc8oQZmX;

1.43
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.42;
commitid	3e3CkrbYekyVOcxy;

1.42
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.41;
commitid	pVtptbHA3yk4jSpN;

1.41
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.40;
commitid	QqHqT2WhCBWqYgGJ;

1.40
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.39;
commitid	wuzpseLx3Ntn9R7b;

1.39
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.38;
commitid	Z6e4eqr6FuYFPnlL;

1.38
date	2015.09.09.20.15.52;	author dlg;	state Exp;
branches;
next	1.37;
commitid	SWFQ4rtnT45R2yZj;

1.37
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.36;
commitid	RRi5waWu1LaKRicG;

1.36
date	2015.08.14.18.07.28;	author bluhm;	state Exp;
branches;
next	1.35;
commitid	mu9yDScTa557hRQD;

1.35
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	ncpqEGjDtSFuLAgn;

1.34
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.33;
commitid	h7z8lokZ0dFyuWpg;

1.33
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.32;
commitid	c7ei8kPelCOOwHXy;

1.32
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	VK3ncyiP3NS1N4Sy;

1.31
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.30;
commitid	t9FBKDfc4VDxpEy2;

1.30
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.29;
commitid	ZqXwxwmeo3l29NOg;

1.29
date	2014.08.10.03.26.20;	author lteo;	state Exp;
branches;
next	1.28;
commitid	JbT0lXSI68QZV5F0;

1.28
date	2014.08.10.03.24.51;	author lteo;	state Exp;
branches;
next	1.27;
commitid	VjxsNUiMtqRcFS5K;

1.27
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.26;
commitid	DQakU8LLWV6Iwx84;

1.26
date	2014.07.12.19.05.45;	author lteo;	state Exp;
branches;
next	1.25;
commitid	sAeylUBMB7AL0Bm4;

1.25
date	2014.07.12.19.04.29;	author lteo;	state Exp;
branches;
next	1.24;
commitid	EE8axg2xWGclVtBz;

1.24
date	2014.07.12.03.27.00;	author lteo;	state Exp;
branches;
next	1.23;
commitid	Rk1KC09W15Q80m90;

1.23
date	2014.07.10.03.17.59;	author lteo;	state Exp;
branches;
next	1.22;
commitid	baLHEMMpirACq25p;

1.22
date	2014.04.23.14.43.14;	author florian;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2013.12.20.02.04.08;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2013.11.15.16.46.15;	author lteo;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.08.15.32.23;	author lteo;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.02.18.27.47;	author bluhm;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2012.10.21.13.06.03;	author benno;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.13.16.27.30;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.08.08.34.42;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.09.12.36.12;	author jsing;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.08.14.18.07;	author jsing;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.08.17.52.17;	author michele;	state dead;
branches;
next	1.1;

1.1
date	2009.09.08.17.00.41;	author michele;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Replace NET_ASSERT_LOCKED() by soassertlocked() in *_usrreq().

Not all of them need the NET_LOCK().

ok bluhm@@
@
text
@/*      $OpenBSD: ip_divert.c,v 1.49 2017/07/27 12:04:42 mpi Exp $ */

/*
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>
#include <net/if_var.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_divert.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>

#include <net/pfvar.h>

struct	inpcbtable	divbtable;
struct	cpumem		*divcounters;

#ifndef DIVERT_SENDSPACE
#define DIVERT_SENDSPACE	(65536 + 100)
#endif
u_int   divert_sendspace = DIVERT_SENDSPACE;
#ifndef DIVERT_RECVSPACE
#define DIVERT_RECVSPACE	(65536 + 100)
#endif
u_int   divert_recvspace = DIVERT_RECVSPACE;

#ifndef DIVERTHASHSIZE
#define DIVERTHASHSIZE	128
#endif

int *divertctl_vars[DIVERTCTL_MAXID] = DIVERTCTL_VARS;

int divbhashsize = DIVERTHASHSIZE;

static struct sockaddr_in ipaddr = { sizeof(ipaddr), AF_INET };

int	divert_output(struct inpcb *, struct mbuf *, struct mbuf *,
	    struct mbuf *);
void
divert_init(void)
{
	in_pcbinit(&divbtable, divbhashsize);
	divcounters = counters_alloc(divs_ncounters);
}

int
divert_output(struct inpcb *inp, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control)
{
	struct sockaddr_in *sin;
	struct socket *so;
	struct ifaddr *ifa;
	int error = 0, min_hdrlen = 0, dir;
	struct ip *ip;
	u_int16_t off;

	m->m_pkthdr.ph_ifidx = 0;
	m->m_nextpkt = NULL;
	m->m_pkthdr.ph_rtableid = inp->inp_rtableid;

	m_freem(control);

	sin = mtod(nam, struct sockaddr_in *);
	so = inp->inp_socket;

	/* Do basic sanity checks. */
	if (m->m_pkthdr.len < sizeof(struct ip))
		goto fail;
	if ((m = m_pullup(m, sizeof(struct ip))) == NULL) {
		/* m_pullup() has freed the mbuf, so just return. */
		divstat_inc(divs_errors);
		return (ENOBUFS);
	}
	ip = mtod(m, struct ip *);
	if (ip->ip_v != IPVERSION)
		goto fail;
	off = ip->ip_hl << 2;
	if (off < sizeof(struct ip) || ntohs(ip->ip_len) < off ||
	    m->m_pkthdr.len < ntohs(ip->ip_len))
		goto fail;

	dir = (sin->sin_addr.s_addr == INADDR_ANY ? PF_OUT : PF_IN);

	switch (ip->ip_p) {
	case IPPROTO_TCP:
		min_hdrlen = sizeof(struct tcphdr);
		m->m_pkthdr.csum_flags |= M_TCP_CSUM_OUT;
		break;
	case IPPROTO_UDP:
		min_hdrlen = sizeof(struct udphdr);
		m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
		break;
	case IPPROTO_ICMP:
		min_hdrlen = ICMP_MINLEN;
		m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;
		break;
	default:
		/* nothing */
		break;
	}
	if (min_hdrlen && m->m_pkthdr.len < off + min_hdrlen)
		goto fail;

	m->m_pkthdr.pf.flags |= PF_TAG_DIVERTED_PACKET;

	if (dir == PF_IN) {
		ipaddr.sin_addr = sin->sin_addr;
		/* XXXSMP ifa_ifwithaddr() is not safe. */
		ifa = ifa_ifwithaddr(sintosa(&ipaddr), m->m_pkthdr.ph_rtableid);
		if (ifa == NULL) {
			error = EADDRNOTAVAIL;
			goto fail;
		}
		m->m_pkthdr.ph_ifidx = ifa->ifa_ifp->if_index;

		/*
		 * Recalculate IP and protocol checksums for the inbound packet
		 * since the userspace application may have modified the packet
		 * prior to reinjection.
		 */
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, off);
		in_proto_cksum_out(m, NULL);

		/* XXXSMP ``ifa'' is not reference counted. */
		ipv4_input(ifa->ifa_ifp, m);
	} else {
		error = ip_output(m, NULL, &inp->inp_route,
		    IP_ALLOWBROADCAST | IP_RAWOUTPUT, NULL, NULL, 0);
		if (error == EACCES)	/* translate pf(4) error for userland */
			error = EHOSTUNREACH;
	}

	divstat_inc(divs_opackets);
	return (error);

fail:
	m_freem(m);
	divstat_inc(divs_errors);
	return (error ? error : EINVAL);
}

int
divert_packet(struct mbuf *m, int dir, u_int16_t divert_port)
{
	struct inpcb *inp;
	struct socket *sa = NULL;
	struct sockaddr_in addr;

	inp = NULL;
	divstat_inc(divs_ipackets);

	if (m->m_len < sizeof(struct ip) &&
	    (m = m_pullup(m, sizeof(struct ip))) == NULL) {
		divstat_inc(divs_errors);
		return (0);
	}

	TAILQ_FOREACH(inp, &divbtable.inpt_queue, inp_queue) {
		if (inp->inp_lport != divert_port)
			continue;
		if (inp->inp_divertfl == 0)
			break;
		if (dir == PF_IN && !(inp->inp_divertfl & IPPROTO_DIVERT_RESP))
			return (-1);
		if (dir == PF_OUT && !(inp->inp_divertfl & IPPROTO_DIVERT_INIT))
			return (-1);
		break;
	}

	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_len = sizeof(addr);

	if (dir == PF_IN) {
		struct ifaddr *ifa;
		struct ifnet *ifp;

		ifp = if_get(m->m_pkthdr.ph_ifidx);
		if (ifp == NULL) {
			m_freem(m);
			return (0);
		}
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET)
				continue;
			addr.sin_addr.s_addr = satosin(
			    ifa->ifa_addr)->sin_addr.s_addr;
			break;
		}
		if_put(ifp);
	}

	if (inp) {
		sa = inp->inp_socket;
		if (sbappendaddr(sa, &sa->so_rcv, sintosa(&addr), m, NULL) == 0) {
			divstat_inc(divs_fullsock);
			m_freem(m);
			return (0);
		} else {
			KERNEL_LOCK();
			sorwakeup(inp->inp_socket);
			KERNEL_UNLOCK();
		}
	}

	if (sa == NULL) {
		divstat_inc(divs_noport);
		m_freem(m);
	}
	return (0);
}

/*ARGSUSED*/
int
divert_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *addr,
    struct mbuf *control, struct proc *p)
{
	struct inpcb *inp = sotoinpcb(so);
	int error = 0;

	soassertlocked(so);

	if (req == PRU_CONTROL) {
		return (in_control(so, (u_long)m, (caddr_t)addr,
		    (struct ifnet *)control));
	}
	if (inp == NULL) {
		error = EINVAL;
		goto release;
	}
	switch (req) {

	case PRU_DETACH:
		in_pcbdetach(inp);
		break;

	case PRU_BIND:
		error = in_pcbbind(inp, addr, p);
		break;

	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	case PRU_SEND:
		return (divert_output(inp, m, addr, control));

	case PRU_ABORT:
		soisdisconnected(so);
		in_pcbdetach(inp);
		break;

	case PRU_SOCKADDR:
		in_setsockaddr(inp, addr);
		break;

	case PRU_PEERADDR:
		in_setpeeraddr(inp, addr);
		break;

	case PRU_SENSE:
		return (0);

	case PRU_LISTEN:
	case PRU_CONNECT:
	case PRU_CONNECT2:
	case PRU_ACCEPT:
	case PRU_DISCONNECT:
	case PRU_SENDOOB:
	case PRU_FASTTIMO:
	case PRU_SLOWTIMO:
	case PRU_PROTORCV:
	case PRU_PROTOSEND:
		error =  EOPNOTSUPP;
		break;

	case PRU_RCVD:
	case PRU_RCVOOB:
		return (EOPNOTSUPP);	/* do not free mbuf's */

	default:
		panic("divert_usrreq");
	}

release:
	m_freem(control);
	m_freem(m);
	return (error);
}

int
divert_attach(struct socket *so, int proto)
{
	int error;

	if (so->so_pcb != NULL)
		return EINVAL;
	if ((so->so_state & SS_PRIV) == 0)
		return EACCES;

	error = in_pcballoc(so, &divbtable);
	if (error)
		return error;

	error = soreserve(so, divert_sendspace, divert_recvspace);
	if (error)
		return error;

	sotoinpcb(so)->inp_flags |= INP_HDRINCL;
	return (0);
}

int
divert_sysctl_divstat(void *oldp, size_t *oldlenp, void *newp)
{
	uint64_t counters[divs_ncounters];
	struct divstat divstat;
	u_long *words = (u_long *)&divstat;
	int i;

	CTASSERT(sizeof(divstat) == (nitems(counters) * sizeof(u_long)));
	memset(&divstat, 0, sizeof divstat);
	counters_read(divcounters, counters, nitems(counters));

	for (i = 0; i < nitems(counters); i++)
		words[i] = (u_long)counters[i];

	return (sysctl_rdstruct(oldp, oldlenp, newp,
	    &divstat, sizeof(divstat)));
}

/*
 * Sysctl for divert variables.
 */
int
divert_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case DIVERTCTL_SENDSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &divert_sendspace));
	case DIVERTCTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &divert_recvspace));
	case DIVERTCTL_STATS:
		return (divert_sysctl_divstat(oldp, oldlenp, newp));
	default:
		if (name[0] < DIVERTCTL_MAXID)
			return sysctl_int_arr(divertctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen);

		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


1.49
log
@Grab the KERNEL_LOCK() before calling sorwakeup().

In the forwarding path, pf_test() is executed w/o KERNEL_LOCK() and
in case of divert end up calling sowakup().  However selwakup() and
csignal() are not yet ready to be executed w/o KERNEL_LOCK().

ok bluhm@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.48 2017/06/26 09:32:32 mpi Exp $ */
d251 1
a251 1
	NET_ASSERT_LOCKED();
@


1.48
log
@Assert that the corresponding socket is locked when manipulating socket
buffers.

This is one step towards unlocking TCP input path.  Note that all the
functions asserting for the socket lock are not necessarilly MP-safe.
All the fields of 'struct socket' aren't protected.

Introduce a new kernel-only kqueue hint, NOTE_SUBMIT, to be able to
tell when a filter needs to lock the underlying data structures.  Logic
and name taken from NetBSD.

Tested by Hrvoje Popovski.

ok claudio@@, bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.47 2017/05/30 07:50:37 mpi Exp $ */
d229 2
a230 1
		} else
d232 2
@


1.47
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.46 2017/04/05 13:35:18 deraadt Exp $ */
d225 1
a225 1
		if (sbappendaddr(&sa->so_rcv, sintosa(&addr), m, NULL) == 0) {
@


1.46
log
@When building counter memory in preparation to copy to userland, always
zero the buffers first.  All the current objects appear to be safe,
however future changes might introduce structure pads.
Discussed with guenther, ok bluhm
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.45 2017/03/13 20:18:21 claudio Exp $ */
d137 1
d154 2
a155 1
		niq_enqueue(&ipintrq, m);
@


1.45
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.44 2017/02/09 15:32:56 jca Exp $ */
d347 1
a347 1

@


1.44
log
@percpu counters for divert(4) stats

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.43 2017/01/29 19:58:47 bluhm Exp $ */
d252 1
a252 1
	if (inp == NULL && req != PRU_ATTACH) {
a257 19
	case PRU_ATTACH:
		if (inp != NULL) {
			error = EINVAL;
			break;
		}
		if ((so->so_state & SS_PRIV) == 0) {
			error = EACCES;
			break;
		}
		error = in_pcballoc(so, &divbtable);
		if (error)
			break;

		error = soreserve(so, divert_sendspace, divert_recvspace);
		if (error)
			break;
		sotoinpcb(so)->inp_flags |= INP_HDRINCL;
		break;

d314 22
@


1.43
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.42 2017/01/25 17:34:31 bluhm Exp $ */
d45 1
a45 1
struct	divstat		divstat;
d72 1
d100 1
a100 1
		divstat.divs_errors++;
d161 1
a161 1
	divstat.divs_opackets++;
d166 1
a166 1
	divstat.divs_errors++;
d178 1
a178 1
	divstat.divs_ipackets++;
d182 1
a182 1
		divstat.divs_errors++;
d224 1
a224 1
			divstat.divs_fullsock++;
d232 1
a232 1
		divstat.divs_noport++;
d335 19
d373 1
a373 4
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &divstat, sizeof(divstat)));
@


1.42
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.41 2016/12/19 08:36:49 mpi Exp $ */
a71 6
}

void
divert_input(struct mbuf *m, int iphlen, int proto)
{
	m_freem(m);
@


1.41
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.40 2016/11/21 09:09:06 mpi Exp $ */
d75 1
a75 1
divert_input(struct mbuf *m, ...)
@


1.40
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.39 2016/03/07 18:44:00 naddy Exp $ */
d251 1
a251 1
	splsoftassert(IPL_SOFTNET);
@


1.39
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.38 2015/09/09 20:15:52 dlg Exp $ */
a65 1
void	divert_detach(struct inpcb *);
d250 2
a251 1
	int s;
a271 1
		s = splsoftnet();
a272 1
		splx(s);
d283 1
a283 1
		divert_detach(inp);
a286 1
		s = splsoftnet();
a287 1
		splx(s);
d299 1
a299 1
		divert_detach(inp);
a337 9
}

void
divert_detach(struct inpcb *inp)
{
	int s = splsoftnet();

	in_pcbdetach(inp);
	splx(s);
@


1.38
log
@if_put after if_get

ok mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.37 2015/09/01 21:24:04 bluhm Exp $ */
d70 1
a70 1
divert_init()
@


1.37
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.36 2015/08/14 18:07:28 bluhm Exp $ */
d224 1
@


1.36
log
@Replace sockaddr casts with the proper satosin() or satosin6() calls.
From David Hill;  OK mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.35 2015/07/15 22:16:42 deraadt Exp $ */
d228 1
a228 2
		if (sbappendaddr(&sa->so_rcv, (struct sockaddr *)&addr, 
		    m, NULL) == 0) {
@


1.35
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.34 2015/06/16 11:09:40 mpi Exp $ */
d220 1
a220 1
			addr.sin_addr.s_addr = ((struct sockaddr_in *)
@


1.34
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.33 2015/04/10 13:58:20 dlg Exp $ */
d96 1
a96 2
	if (control)
		m_freem(control);
d339 2
a340 5
	if (control) {
		m_freem(control);
	}
	if (m)
		m_freem(m);
@


1.33
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.32 2015/01/24 00:29:06 deraadt Exp $ */
d92 1
a92 1
	m->m_pkthdr.rcvif = NULL;
d149 1
a149 1
		m->m_pkthdr.rcvif = ifa->ifa_ifp;
d213 5
a217 1
		ifp = m->m_pkthdr.rcvif;
@


1.32
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.31 2014/12/05 15:50:04 mpi Exp $ */
a84 1
	struct ifqueue *inq;
d88 1
a88 1
	int s, error = 0, min_hdrlen = 0, dir;
a150 2
		inq = &ipintrq;

d160 1
a160 4
		s = splnet();
		IF_INPUT_ENQUEUE(inq, m);
		schednetisr(NETISR_IP);
		splx(s);
@


1.31
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.30 2014/09/08 06:24:13 jsg Exp $ */
d28 1
a30 1
#include <net/pfvar.h>
d41 2
@


1.30
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.29 2014/08/10 03:26:20 lteo Exp $ */
d28 1
@


1.29
log
@Fix the length check for reinjected ICMP packets: sizeof(struct icmp) is
28 but an ICMP packet can be as small as 8 bytes (e.g. an ICMP echo
request packet with no payload), so check against ICMP_MINLEN instead.

Prior to this fix, divert(4) would erroneously discard valid ICMP
packets that are shorter than 20 bytes.

ICMPv6 is not affected, so this change applies to ICMP over IPv4 only.

ok florian@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.28 2014/08/10 03:24:51 lteo Exp $ */
a27 1
#include <net/route.h>
@


1.28
log
@Rename p_hdrlen to min_hdrlen to better reflect its purpose.

No object file change
ok florian@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.27 2014/07/22 11:06:10 mpi Exp $ */
d129 1
a129 1
		min_hdrlen = sizeof(struct icmp);
@


1.27
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.26 2014/07/12 19:05:45 lteo Exp $ */
d87 1
a87 1
	int s, error = 0, p_hdrlen = 0, dir;
d121 1
a121 1
		p_hdrlen = sizeof(struct tcphdr);
d125 1
a125 1
		p_hdrlen = sizeof(struct udphdr);
d129 1
a129 1
		p_hdrlen = sizeof(struct icmp);
d136 1
a136 1
	if (p_hdrlen && m->m_pkthdr.len < off + p_hdrlen)
@


1.26
log
@Remove the redundant csum_flag variable and just set the checksum flag
in the pkthdr directly.

ok henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.25 2014/07/12 19:04:29 lteo Exp $ */
a32 1
#include <netinet/in_systm.h>
@


1.25
log
@Protocol checksums have been recalculated on reinjection for a while
now, so there is no need to calculate them before sending them to
userspace.

ok henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.24 2014/07/12 03:27:00 lteo Exp $ */
d90 1
a90 1
	u_int16_t off, csum_flag = 0;
d123 1
a123 1
		csum_flag = M_TCP_CSUM_OUT;
d127 1
a127 1
		csum_flag = M_UDP_CSUM_OUT;
d131 1
a131 1
		csum_flag = M_ICMP_CSUM_OUT;
a138 3

	if (csum_flag)
		m->m_pkthdr.csum_flags |= csum_flag;
@


1.24
log
@Implement checksum offload for divert(4): simply set the checksum flag
and let the stack take care of the checksums for reinjected outbound
packets.

Reinjected inbound packets will continue to have their checksums
calculated manually but we can now take advantage of in_proto_cksum_out
and in6_proto_cksum_out to streamline the way their checksums are done.

help from florian@@ and henning@@, feedback from naddy@@
ok florian@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.23 2014/07/10 03:17:59 lteo Exp $ */
a229 3
	/* force checksum calculation */
	if (dir == PF_OUT)
		in_proto_cksum_out(m, NULL);
@


1.23
log
@Simplify the way divert(4) sends packets to userspace: Instead of
unnecessarily allocating an mbuf tag to store the divert port, just pass
the divert port directly to divert_packet() or divert6_packet() as an
argument.

includes a style fix pointed out by bluhm@@
ok bluhm@@ henning@@ reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.22 2014/04/23 14:43:14 florian Exp $ */
d88 1
a88 1
	int s, error = 0, p_hdrlen = 0;
d90 1
a90 3
	u_int16_t off, csum = 0;
	u_int8_t nxt;
	size_t p_off = 0;
d118 2
a119 7
	/*
	 * Recalculate IP and protocol checksums since the userspace application
	 * may have modified the packet prior to reinjection.
	 */
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m, off);
	nxt = ip->ip_p;
d123 1
a123 1
		p_off = offsetof(struct tcphdr, th_sum);
d127 1
a127 1
		p_off = offsetof(struct udphdr, uh_sum);
d131 1
a131 2
		p_off = offsetof(struct icmp, icmp_cksum);
		nxt = 0;
d137 2
a138 3
	if (p_hdrlen) {
		if (m->m_pkthdr.len < off + p_hdrlen)
			goto fail;
d140 2
a141 8
		if ((error = m_copyback(m, off + p_off, sizeof(csum), &csum, M_NOWAIT)))
			goto fail;
		csum = in4_cksum(m, nxt, off, m->m_pkthdr.len - off);
		if (ip->ip_p == IPPROTO_UDP && csum == 0)
			csum = 0xffff;
		if ((error = m_copyback(m, off + p_off, sizeof(csum), &csum, M_NOWAIT)))
			goto fail;
	}
d145 1
a145 1
	if (sin->sin_addr.s_addr != INADDR_ANY) {
d155 9
@


1.22
log
@No need for vargs here.
While there move declaration of divert{,6}_output() to .c as it's a
private function. Also switch first two args to make it more like
similar functions (both suggested by mpi@@).
Input/OK mpi@@, OK lteo@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.21 2014/04/21 12:22:26 henning Exp $ */
d192 1
a192 1
divert_packet(struct mbuf *m, int dir)
a196 1
	struct pf_divert *divert;
a206 7
	divert = pf_find_divert(m);
	if (divert == NULL) {
		divstat.divs_errors++;
		m_freem(m);
		return (0);
	}

d208 1
a208 1
		if (inp->inp_lport != divert->port)
@


1.21
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.19 2014/04/07 10:04:17 mpi Exp $ */
d65 3
a67 2
void divert_detach(struct inpcb *);

d81 2
a82 1
divert_output(struct mbuf *m, ...)
a83 1
	struct inpcb *inp;
a84 1
	struct mbuf *nam, *control;
a88 1
	va_list ap;
a93 6
	va_start(ap, m);
	inp = va_arg(ap, struct inpcb *);
	nam = va_arg(ap, struct mbuf *);
	control = va_arg(ap, struct mbuf *);
	va_end(ap);

d321 1
a321 1
		return (divert_output(m, inp, addr, control));
@


1.20
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d184 1
a184 1
		    IP_ALLOWBROADCAST | IP_RAWOUTPUT, NULL, NULL);
@


1.19
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.17 2014/03/27 13:27:28 mpi Exp $ */
d103 1
a103 1
	m->m_pkthdr.rdomain = inp->inp_rtableid;
d169 1
a169 1
		ifa = ifa_ifwithaddr(sintosa(&ipaddr), m->m_pkthdr.rdomain);
@


1.18
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.16 2014/01/09 06:29:06 tedu Exp $ */
d183 2
a184 4
		error = ip_output(m, (void *)NULL, &inp->inp_route,
		    ((so->so_options & SO_DONTROUTE) ? IP_ROUTETOIF : 0)
		    | IP_ALLOWBROADCAST | IP_RAWOUTPUT, (void *)NULL,
		    (void *)NULL);
@


1.17
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d183 4
a186 2
		error = ip_output(m, NULL, &inp->inp_route,
		    IP_ALLOWBROADCAST | IP_RAWOUTPUT, NULL, NULL);
@


1.16
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.15 2013/12/20 02:04:08 krw Exp $ */
d183 2
a184 4
		error = ip_output(m, (void *)NULL, &inp->inp_route,
		    ((so->so_options & SO_DONTROUTE) ? IP_ROUTETOIF : 0)
		    | IP_ALLOWBROADCAST | IP_RAWOUTPUT, (void *)NULL,
		    (void *)NULL);
@


1.15
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.14 2013/11/15 16:46:15 lteo Exp $ */
d236 1
a236 1
	bzero(&addr, sizeof(addr));
@


1.14
log
@Rename the struct pf_divert variable in divert_packet() and
divert6_packet() from "pd" to "divert" to match the rest of the source.
I think "pd" was not a good name for a struct pf_divert because "pd"
usually refers to a pf_pdesc.

No object file change.

OK benno@@ bluhm@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.13 2013/04/08 15:32:23 lteo Exp $ */
d224 1
a224 1
	CIRCLEQ_FOREACH(inp, &divbtable.inpt_queue, inp_queue) {
d257 1
a257 1
	if (inp != CIRCLEQ_END(&divbtable.inpt_queue)) {
@


1.13
log
@Recalculate the IP and protocol checksums of packets (re)injected via
divert(4) sockets.

Recalculation of these checksums is necessary because (1) PF no longer
updates IP checksums as of pf.c rev 1.731, so translated packets that
are diverted to userspace (e.g. divert-packet with nat-to/rdr-to) will
have bad IP checksums and will be reinjected with bad IP checksums if
the userspace program doesn't correct the checksums; (2) the userspace
program may modify the packets, which would invalidate the checksums;
and (3) the divert(4) man page states that checksums are supposed to be
recalculated on reinjection.

This diff has been tested on a public webserver serving both IPv4/IPv6
for more than four weeks.  It has also been tested on a firewall with
divert-packet and nat-to/rdr-to where it transferred over 60GB of
FTP/HTTP/HTTPS/SSH/DNS/ICMP/ICMPv6 data correctly, using IPv4/IPv6
userspace programs that intentionally break the IP and protocol
checksums to confirm that recalculation is done correctly on
reinjection.  IPv6 extension headers were tested with Scapy.

Thanks to florian@@ for testing the original version of the diff with
dnsfilter and Justin Mayes for testing the original version with Snort
inline.  Thanks also to todd@@ for helping me in my search for the cause
of this bug.

I would especially like to thank blambert@@ for reviewing many versions
of this diff, and providing guidance and tons of helpful feedback.

no objections from florian@@
help/ok blambert@@, ok henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.12 2013/04/02 18:27:47 bluhm Exp $ */
d206 1
a206 1
	struct pf_divert *pd;
d217 2
a218 2
	pd = pf_find_divert(m);
	if (pd == NULL) {
d225 1
a225 1
		if (inp->inp_lport != pd->port)
@


1.12
log
@Use macros sotoinpcb() and intotcpcb() instead of casts.  Use NULL
instead of 0 for pointers.  No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.11 2013/03/28 16:45:16 tedu Exp $ */
d39 3
d88 1
a88 1
	int s, error = 0;
d90 4
d111 54
d171 2
a172 3
			divstat.divs_errors++;
			m_freem(m);
			return (EADDRNOTAVAIL);
d193 5
@


1.11
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.10 2012/10/21 13:06:03 benno Exp $ */
d247 1
a247 1
		((struct inpcb *) so->so_pcb)->inp_flags |= INP_HDRINCL;
@


1.10
log
@Add the IP_DIVERTFL socket option on divert(4) sockets to control
which packets (as in direction) of the traffic will be diverted
through the divert socket.
ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.9 2012/07/13 16:27:30 claudio Exp $ */
a24 1
#include <sys/proc.h>
@


1.9
log
@3 line diff to fix divert using connections from local system.
OK henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.8 2010/09/08 08:34:42 claudio Exp $ */
d136 1
a136 1
void
d144 1
d150 1
a150 1
		return;
d157 13
a169 1
		return;
d193 1
a193 4
	CIRCLEQ_FOREACH(inp, &divbtable.inpt_queue, inp_queue) {
		if (inp->inp_lport != pd->port)
			continue;

d199 1
a199 1
			return;
a201 1
		break;
d208 1
@


1.8
log
@Return EACCES when pf_test() blocks a packet in ip_output(). This allows
ip_forward() to know the difference between blocked packets and those that
can't be forwarded (EHOSTUNREACH). Only in the latter case an ICMP should
be sent. In the other callers of ip_output() change the error back to
EHOSTUNREACH since userland may not expect EACCES on a sendto().
OK henning@@, markus@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.7 2010/07/03 04:44:51 guenther Exp $ */
d176 3
@


1.7
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.6 2010/04/20 22:05:43 tedu Exp $ */
d128 2
@


1.6
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.5 2010/03/09 12:36:12 jsing Exp $ */
d97 1
a97 1
	m->m_pkthdr.rdomain = inp->inp_rdomain;
@


1.5
log
@Use correct routing domain when doing address lookups.

ok claudio@@ "approved" deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.4 2010/03/08 14:18:07 jsing Exp $ */
d25 1
@


1.4
log
@Use properly initialised sockaddr_in/sockaddr_in6 struct when performing
address lookups. Found whilst investigating address lookup failures.

ok michele@@
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d108 1
a108 1
		ifa = ifa_ifwithaddr(sintosa(&ipaddr), 0);
@


1.3
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d60 2
d107 2
a108 1
		ifa = ifa_ifwithaddr((struct sockaddr *)sin, 0);
@


1.2
log
@I had not enough oks to commit this diff.
Sorry.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip_divert.c,v 1.1 2009/09/08 17:00:41 michele Exp $ */
d30 1
d40 2
a41 6
#include "pf.h"
#if NPF > 0
#include <net/pfvar.h>
#endif

struct	inpcbtable divbtable;
d58 1
a58 1
int	divbhashsize = DIVERTHASHSIZE;
d60 1
a60 1
void	divert_detach(struct inpcb *);
a67 1
/* Dummy function, so drop */
d94 1
d107 1
d126 1
d138 2
d141 2
a142 1
	    (m = m_pullup(m, sizeof(struct ip))) == NULL)
d144 1
d148 1
d178 1
d186 2
a187 1
	if (sa == NULL)
d189 1
d311 1
d322 5
d329 2
a330 2
		return sysctl_int_arr(divertctl_vars, name, namelen,
		    oldp, oldlenp, newp, newlen);
d334 1
@


1.1
log
@Add support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 8000

test, bugfix and ok by reyk@@
manpage help and ok by jmc@@
no objections from many others.
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
@

