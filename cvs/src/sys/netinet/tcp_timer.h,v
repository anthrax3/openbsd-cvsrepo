head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.2
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.24
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.18
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.20
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.12
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.16
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.14
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.10
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.14
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.10.04.13.54.32;	author mpi;	state Exp;
branches;
next	1.13;
commitid	QtKIaSOt6xUiLgI5;

1.13
date	2011.07.06.23.44.20;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.08.12.54.58;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.24.12.59.28;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.28.16.33.52;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.08.03.49.58;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.01.22.29.29;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.19.26.10;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.03.11.55;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.09.07.03.43;	author angelos;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	97.02.24.14.06.46;	author niklas;	state Exp;
branches
	1.3.14.1;
next	1.2;

1.2
date	96.09.23.05.26.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches;
next	;

1.3.14.1
date	2001.07.04.10.55.10;	author niklas;	state Exp;
branches;
next	1.3.14.2;

1.3.14.2
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.3.14.3;

1.3.14.3
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.3.14.4;

1.3.14.4
date	2003.05.13.19.36.18;	author ho;	state Exp;
branches;
next	1.3.14.5;

1.3.14.5
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	;

1.4.4.1
date	2002.01.31.22.55.45;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Convert timeouts that need a process context to timeout_set_proc(9).

The current reason is that rtalloc_mpath(9) inside ip_output() might
end up inserting a RTF_CLONED route and that require a write lock.

ok kettenis@@, bluhm@@
@
text
@/*	$OpenBSD: tcp_timer.h,v 1.13 2011/07/06 23:44:20 sthen Exp $	*/
/*	$NetBSD: tcp_timer.h,v 1.6 1995/03/26 20:32:37 jtc Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tcp_timer.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET_TCP_TIMER_H_
#define _NETINET_TCP_TIMER_H_

/*
 * Definitions of the TCP timers.  These timers are counted
 * down PR_SLOWHZ times a second.
 */
#define	TCPT_NTIMERS	4

#define	TCPT_REXMT	0		/* retransmit */
#define	TCPT_PERSIST	1		/* retransmit persistence */
#define	TCPT_KEEP	2		/* keep alive */
#define	TCPT_2MSL	3		/* 2*msl quiet time timer */

/*
 * The TCPT_REXMT timer is used to force retransmissions.
 * The TCP has the TCPT_REXMT timer set whenever segments
 * have been sent for which ACKs are expected but not yet
 * received.  If an ACK is received which advances tp->snd_una,
 * then the retransmit timer is cleared (if there are no more
 * outstanding segments) or reset to the base value (if there
 * are more ACKs expected).  Whenever the retransmit timer goes off,
 * we retransmit one unacknowledged segment, and do a backoff
 * on the retransmit timer.
 *
 * The TCPT_PERSIST timer is used to keep window size information
 * flowing even if the window goes shut.  If all previous transmissions
 * have been acknowledged (so that there are no retransmissions in progress),
 * and the window is too small to bother sending anything, then we start
 * the TCPT_PERSIST timer.  When it expires, if the window is nonzero,
 * we go to transmit state.  Otherwise, at intervals send a single byte
 * into the peer's window to force him to update our window information.
 * We do this at most as often as TCPT_PERSMIN time intervals,
 * but no more frequently than the current estimate of round-trip
 * packet time.  The TCPT_PERSIST timer is cleared whenever we receive
 * a window update from the peer.
 *
 * The TCPT_KEEP timer is used to keep connections alive.  If an
 * connection is idle (no segments received) for TCPTV_KEEP_INIT amount of time,
 * but not yet established, then we drop the connection.  Once the connection
 * is established, if the connection is idle for TCPTV_KEEP_IDLE time
 * (and keepalives have been enabled on the socket), we begin to probe
 * the connection.  We force the peer to send us a segment by sending:
 *	<SEQ=SND.UNA-1><ACK=RCV.NXT><CTL=ACK>
 * This segment is (deliberately) outside the window, and should elicit
 * an ack segment in response from the peer.  If, despite the TCPT_KEEP
 * initiated segments we cannot elicit a response from a peer in TCPT_MAXIDLE
 * amount of time probing, then we drop the connection.
 */

/*
 * Time constants.
 */
#define	TCPTV_MSL	( 30*PR_SLOWHZ)		/* max seg lifetime (hah!) */
#define	TCPTV_SRTTBASE	0			/* base roundtrip time;
						   if 0, no idea yet */
#define	TCPTV_SRTTDFLT	(  3*PR_SLOWHZ)		/* assumed RTT if no info */

#define	TCPTV_PERSMIN	(  5*PR_SLOWHZ)		/* retransmit persistence */
#define	TCPTV_PERSMAX	( 60*PR_SLOWHZ)		/* maximum persist interval */

#define	TCPTV_KEEP_INIT	( 75*PR_SLOWHZ)		/* initial connect keep alive */
#define	TCPTV_KEEP_IDLE	(120*60*PR_SLOWHZ)	/* dflt time before probing */
#define	TCPTV_KEEPINTVL	( 75*PR_SLOWHZ)		/* default probe interval */
#define	TCPTV_KEEPCNT	8			/* max probes before drop */

#define	TCPTV_MIN	(  1*PR_SLOWHZ)		/* minimum allowable value */
#define	TCPTV_REXMTMAX	( 64*PR_SLOWHZ)		/* max allowable REXMT value */

#define	TCP_LINGERTIME	120			/* linger at most 2 minutes */

#define	TCP_MAXRXTSHIFT	12			/* maximum retransmits */

#define	TCP_DELACK_TICKS (hz / PR_FASTHZ)	/* time to delay ACK */

#ifdef	TCPTIMERS
const char *tcptimers[] =
    { "REXMT", "PERSIST", "KEEP", "2MSL" };
#endif /* TCPTIMERS */

/*
 * Init, arm, disarm, and test TCP timers.
 */
#define	TCP_TIMER_INIT(tp, timer)					\
	timeout_set_proc(&(tp)->t_timer[(timer)], tcp_timer_funcs[(timer)], tp)

#define	TCP_TIMER_ARM(tp, timer, nticks)				\
	timeout_add(&(tp)->t_timer[(timer)], (nticks) * (hz / PR_SLOWHZ))

#define	TCP_TIMER_DISARM(tp, timer)					\
	timeout_del(&(tp)->t_timer[(timer)])

#define	TCP_TIMER_ISARMED(tp, timer)					\
	timeout_pending(&(tp)->t_timer[(timer)])

/*
 * Force a time value to be in a certain range.
 */
#define	TCPT_RANGESET(tv, value, tvmin, tvmax)				\
do {									\
	(tv) = (value);							\
	if ((tv) < (tvmin))						\
		(tv) = (tvmin);						\
	else if ((tv) > (tvmax))					\
		(tv) = (tvmax);						\
} while (/* CONSTCOND */ 0)

#ifdef _KERNEL
typedef void (*tcp_timer_func_t)(void *);

extern const tcp_timer_func_t tcp_timer_funcs[TCPT_NTIMERS];

extern int tcptv_keep_init;
extern int tcp_always_keepalive;	/* assume SO_KEEPALIVE is always set */
extern int tcp_keepidle;		/* time before keepalive probes begin */
extern int tcp_keepintvl;		/* time between keepalive probes */
extern int tcp_maxidle;			/* time to drop after starting probes */
extern int tcp_ttl;			/* time to live for TCP segs */
extern int tcp_backoff[];

void	tcp_timer_init(void);
#endif /* _KERNEL */
#endif /* _NETINET_TCP_TIMER_H_ */
@


1.13
log
@Add sysctl net.inet.tcp.always_keepalive, when this is set the system
behaves as if SO_KEEPALIVE was set on all TCP sockets, forcing keepalives
to be sent every net.inet.tcp.keepidle half-seconds.

In conjunction with a keepidle value greatly reduced from the default,
this can be useful for keeping sessions open if you are stuck on a network
with short NAT or firewall timeouts.

Feedback from various people, ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.12 2008/11/08 12:54:58 dlg Exp $	*/
d119 1
a119 1
	timeout_set(&(tp)->t_timer[(timer)], tcp_timer_funcs[(timer)], tp)
@


1.12
log
@fix macros up so they use the do { } while (/* CONSTCOND */ 0) idiom

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.10 2003/06/02 23:28:15 millert Exp $	*/
d148 1
@


1.11
log
@some spelling fixes from Martynas Venckus
@
text
@d133 8
a140 7
#define	TCPT_RANGESET(tv, value, tvmin, tvmax) { \
	(tv) = (value); \
	if ((tv) < (tvmin)) \
		(tv) = (tvmin); \
	else if ((tv) > (tvmax)) \
		(tv) = (tvmax); \
}
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.9 2003/03/28 16:33:52 henning Exp $	*/
d45 1
a45 1
#define	TCPT_PERSIST	1		/* retransmit persistance */
d93 1
a93 1
#define	TCPTV_PERSMIN	(  5*PR_SLOWHZ)		/* retransmit persistance */
@


1.9
log
@another const char * from David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.8 2002/03/08 03:49:58 provos Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@use timeout(9) to schedule TCP timers.  this avoid traversing all
tcp connections during tcp_slowtimo.  apdapted from thorpej@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.7 2002/03/01 22:29:29 provos Exp $	*/
d115 1
a115 1
char *tcptimers[] =
@


1.7
log
@remove tcp_fasttimo and convert delayed acks to the timeout(9) API instead.
adapated from netbsd.  okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.6 2002/01/14 19:26:10 provos Exp $	*/
d123 1
a123 1
	(tp)->t_timer[(timer)] = 0
d126 1
a126 1
	(tp)->t_timer[(timer)] = (nticks)
d129 1
a129 1
	(tp)->t_timer[(timer)] = 0
d132 1
a132 1
	(tp)->t_timer[(timer)]
d146 4
@


1.6
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.5 2002/01/14 03:11:55 provos Exp $	*/
d112 2
d152 2
@


1.5
log
@use macros to manage tcp timers; based on netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.3 1997/02/24 14:06:46 niklas Exp $	*/
d130 1
a130 1
	&(tp)->t_timer[(timer)]
@


1.4
log
@Inclusion protection.
@
text
@d118 15
@


1.4.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.6 2002/01/14 19:26:10 provos Exp $	*/
a115 15

/*
 * Init, arm, disarm, and test TCP timers.
 */
#define	TCP_TIMER_INIT(tp, timer)					\
	(tp)->t_timer[(timer)] = 0

#define	TCP_TIMER_ARM(tp, timer, nticks)				\
	(tp)->t_timer[(timer)] = (nticks)

#define	TCP_TIMER_DISARM(tp, timer)					\
	(tp)->t_timer[(timer)] = 0

#define	TCP_TIMER_ISARMED(tp, timer)					\
	(tp)->t_timer[(timer)]
@


1.4.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.4.4.1 2002/01/31 22:55:45 niklas Exp $	*/
a111 2
#define	TCP_DELACK_TICKS (hz / PR_FASTHZ)	/* time to delay ACK */

d121 1
a121 1
	timeout_set(&(tp)->t_timer[(timer)], tcp_timer_funcs[(timer)], tp)
d124 1
a124 1
	timeout_add(&(tp)->t_timer[(timer)], (nticks) * (hz / PR_SLOWHZ))
d127 1
a127 1
	timeout_del(&(tp)->t_timer[(timer)])
d130 1
a130 1
	timeout_pending(&(tp)->t_timer[(timer)])
a143 4
typedef void (*tcp_timer_func_t)(void *);

extern const tcp_timer_func_t tcp_timer_funcs[TCPT_NTIMERS];

a149 2

void	tcp_timer_init(void);
@


1.4.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d115 1
a115 1
const char *tcptimers[] =
@


1.3
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.6 1995/03/26 20:32:37 jtc Exp $	*/
d39 3
d115 1
a115 1
#endif
d135 2
a136 1
#endif
@


1.3.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.3 1997/02/24 14:06:46 niklas Exp $	*/
a38 3
#ifndef _NETINET_TCP_TIMER_H_
#define _NETINET_TCP_TIMER_H_

d112 1
a112 1
#endif /* TCPTIMERS */
d132 1
a132 2
#endif /* _KERNEL */
#endif /* _NETINET_TCP_TIMER_H_ */
@


1.3.14.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a111 2
#define	TCP_DELACK_TICKS (hz / PR_FASTHZ)	/* time to delay ACK */

a117 15
 * Init, arm, disarm, and test TCP timers.
 */
#define	TCP_TIMER_INIT(tp, timer)					\
	(tp)->t_timer[(timer)] = 0

#define	TCP_TIMER_ARM(tp, timer, nticks)				\
	(tp)->t_timer[(timer)] = (nticks)

#define	TCP_TIMER_DISARM(tp, timer)					\
	(tp)->t_timer[(timer)] = 0

#define	TCP_TIMER_ISARMED(tp, timer)					\
	(tp)->t_timer[(timer)]

/*
a134 2

void	tcp_timer_init(void);
@


1.3.14.3
log
@Merge in -current from roughly a week ago
@
text
@d123 1
a123 1
	timeout_set(&(tp)->t_timer[(timer)], tcp_timer_funcs[(timer)], tp)
d126 1
a126 1
	timeout_add(&(tp)->t_timer[(timer)], (nticks) * (hz / PR_SLOWHZ))
d129 1
a129 1
	timeout_del(&(tp)->t_timer[(timer)])
d132 1
a132 1
	timeout_pending(&(tp)->t_timer[(timer)])
a145 4
typedef void (*tcp_timer_func_t)(void *);

extern const tcp_timer_func_t tcp_timer_funcs[TCPT_NTIMERS];

@


1.3.14.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.3.14.3 2002/03/28 14:56:46 niklas Exp $	*/
d115 1
a115 1
const char *tcptimers[] =
@


1.3.14.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_timer.h,v 1.3.14.4 2003/05/13 19:36:18 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2
log
@fix tuba after synbomb fixes
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d125 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
