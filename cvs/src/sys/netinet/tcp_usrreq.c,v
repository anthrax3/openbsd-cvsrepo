head	1.153;
access;
symbols
	OPENBSD_6_1:1.145.0.4
	OPENBSD_6_1_BASE:1.145
	OPENBSD_6_0:1.134.0.4
	OPENBSD_6_0_BASE:1.134
	OPENBSD_5_9:1.128.0.2
	OPENBSD_5_9_BASE:1.128
	OPENBSD_5_8:1.126.0.4
	OPENBSD_5_8_BASE:1.126
	OPENBSD_5_7:1.123.0.2
	OPENBSD_5_7_BASE:1.123
	OPENBSD_5_6:1.119.0.4
	OPENBSD_5_6_BASE:1.119
	OPENBSD_5_5:1.117.0.4
	OPENBSD_5_5_BASE:1.117
	OPENBSD_5_4:1.112.0.2
	OPENBSD_5_4_BASE:1.112
	OPENBSD_5_3:1.110.0.4
	OPENBSD_5_3_BASE:1.110
	OPENBSD_5_2:1.110.0.2
	OPENBSD_5_2_BASE:1.110
	OPENBSD_5_1_BASE:1.109
	OPENBSD_5_1:1.109.0.2
	OPENBSD_5_0:1.108.0.2
	OPENBSD_5_0_BASE:1.108
	OPENBSD_4_9:1.105.0.2
	OPENBSD_4_9_BASE:1.105
	OPENBSD_4_8:1.102.0.2
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.100.0.2
	OPENBSD_4_7_BASE:1.100
	OPENBSD_4_6:1.100.0.4
	OPENBSD_4_6_BASE:1.100
	OPENBSD_4_5:1.99.0.4
	OPENBSD_4_5_BASE:1.99
	OPENBSD_4_4:1.99.0.2
	OPENBSD_4_4_BASE:1.99
	OPENBSD_4_3:1.95.0.2
	OPENBSD_4_3_BASE:1.95
	OPENBSD_4_2:1.91.0.2
	OPENBSD_4_2_BASE:1.91
	OPENBSD_4_1:1.89.0.10
	OPENBSD_4_1_BASE:1.89
	OPENBSD_4_0:1.89.0.8
	OPENBSD_4_0_BASE:1.89
	OPENBSD_3_9:1.89.0.6
	OPENBSD_3_9_BASE:1.89
	OPENBSD_3_8:1.89.0.4
	OPENBSD_3_8_BASE:1.89
	OPENBSD_3_7:1.89.0.2
	OPENBSD_3_7_BASE:1.89
	OPENBSD_3_6:1.86.0.2
	OPENBSD_3_6_BASE:1.86
	SMP_SYNC_A:1.85
	SMP_SYNC_B:1.85
	OPENBSD_3_5:1.81.0.2
	OPENBSD_3_5_BASE:1.81
	OPENBSD_3_4:1.71.0.2
	OPENBSD_3_4_BASE:1.71
	UBC_SYNC_A:1.68
	OPENBSD_3_3:1.68.0.2
	OPENBSD_3_3_BASE:1.68
	OPENBSD_3_2:1.67.0.2
	OPENBSD_3_2_BASE:1.67
	OPENBSD_3_1:1.59.0.2
	OPENBSD_3_1_BASE:1.59
	UBC_SYNC_B:1.67
	UBC:1.54.0.4
	UBC_BASE:1.54
	OPENBSD_3_0:1.54.0.2
	OPENBSD_3_0_BASE:1.54
	OPENBSD_2_9_BASE:1.50
	OPENBSD_2_9:1.50.0.2
	OPENBSD_2_8:1.48.0.2
	OPENBSD_2_8_BASE:1.48
	OPENBSD_2_7:1.39.0.4
	OPENBSD_2_7_BASE:1.39
	SMP:1.39.0.2
	SMP_BASE:1.39
	kame_19991208:1.37
	OPENBSD_2_6:1.36.0.2
	OPENBSD_2_6_BASE:1.36
	OPENBSD_2_5:1.33.0.2
	OPENBSD_2_5_BASE:1.33
	OPENBSD_2_4:1.28.0.2
	OPENBSD_2_4_BASE:1.28
	OPENBSD_2_3:1.20.0.2
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.153
date	2017.08.15.17.47.15;	author bluhm;	state Exp;
branches;
next	1.152;
commitid	dSbcCL1yFsQLdA8Q;

1.152
date	2017.06.26.09.32.32;	author mpi;	state Exp;
branches;
next	1.151;
commitid	gZMpLuRopIsWa0cT;

1.151
date	2017.05.18.11.38.07;	author mpi;	state Exp;
branches;
next	1.150;
commitid	mqqGdyckz9daEuFf;

1.150
date	2017.05.16.12.24.02;	author mpi;	state Exp;
branches;
next	1.149;
commitid	SAe3SQ48vKH6r5FL;

1.149
date	2017.05.13.17.41.57;	author bluhm;	state Exp;
branches;
next	1.148;
commitid	k7vK8vYyZVX1AcSS;

1.148
date	2017.05.12.20.34.29;	author bluhm;	state Exp;
branches;
next	1.147;
commitid	AkkaEnSGbiTmPsBz;

1.147
date	2017.04.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.146;
commitid	4O5LUh13nIhVt6oZ;

1.146
date	2017.04.02.12.56.39;	author jca;	state Exp;
branches;
next	1.145;
commitid	eQA6WCsc7qDErk7F;

1.145
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches
	1.145.4.1;
next	1.144;
commitid	ZsxSSZJSFxZH81LL;

1.144
date	2017.02.09.15.19.32;	author jca;	state Exp;
branches;
next	1.143;
commitid	Hew5AYIxyEp5lNbI;

1.143
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.142;
commitid	UBL7uwpXqTP4EWIu;

1.142
date	2017.01.10.09.01.18;	author mpi;	state Exp;
branches;
next	1.141;
commitid	xP9gcRskiS0BKnO6;

1.141
date	2017.01.03.10.52.21;	author mpi;	state Exp;
branches;
next	1.140;
commitid	RtLBKSTwcJi8fv4z;

1.140
date	2016.12.26.21.30.10;	author jca;	state Exp;
branches;
next	1.139;
commitid	4EK5zByufjOPkoKe;

1.139
date	2016.12.20.18.33.43;	author bluhm;	state Exp;
branches;
next	1.138;
commitid	xiXE7MGPpVXw2TS3;

1.138
date	2016.12.20.14.10.00;	author mpi;	state Exp;
branches;
next	1.137;
commitid	IduQ7GNqLkZDmvPf;

1.137
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.136;
commitid	QqHqT2WhCBWqYgGJ;

1.136
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.135;
commitid	wuzpseLx3Ntn9R7b;

1.135
date	2016.09.24.14.51.37;	author naddy;	state Exp;
branches;
next	1.134;
commitid	B9MFucENkVbjvRxm;

1.134
date	2016.07.20.19.57.53;	author bluhm;	state Exp;
branches
	1.134.4.1;
next	1.133;
commitid	iB1JO3v9iwYOTdxI;

1.133
date	2016.07.20.09.15.28;	author bluhm;	state Exp;
branches;
next	1.132;
commitid	Qwlx91wnD3EO5HU6;

1.132
date	2016.07.11.10.35.43;	author mpi;	state Exp;
branches;
next	1.131;
commitid	BdWRXoAM6DQGeEPl;

1.131
date	2016.06.18.10.36.13;	author vgross;	state Exp;
branches;
next	1.130;
commitid	r16P5gVURcjZa76o;

1.130
date	2016.03.29.18.13.20;	author bluhm;	state Exp;
branches;
next	1.129;
commitid	m1S5Qx2z8077Jh3c;

1.129
date	2016.03.23.15.50.36;	author vgross;	state Exp;
branches;
next	1.128;
commitid	iMWKOVeEybjVAEfv;

1.128
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.127;
commitid	sTEWfQrcV5GjIWc0;

1.127
date	2015.08.27.17.10.45;	author bluhm;	state Exp;
branches;
next	1.126;
commitid	b2ktlHaY7qTaAMN9;

1.126
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.125;
commitid	ncpqEGjDtSFuLAgn;

1.125
date	2015.06.07.12.02.28;	author jsg;	state Exp;
branches;
next	1.124;
commitid	st7eUqjf7vKTD48M;

1.124
date	2015.06.07.01.25.27;	author krw;	state Exp;
branches;
next	1.123;
commitid	7yzARhkDkBsYwsVv;

1.123
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.122;
commitid	t9FBKDfc4VDxpEy2;

1.122
date	2014.11.25.15.35.10;	author mpi;	state Exp;
branches;
next	1.121;
commitid	ckGoHy7P4urTJnRb;

1.121
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.120;
commitid	Z1vcFtHO8wRH0yRt;

1.120
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.119;
commitid	uzzBR7hz9ncd4O6G;

1.119
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.118;
commitid	DQakU8LLWV6Iwx84;

1.118
date	2014.04.06.16.49.40;	author chrisz;	state Exp;
branches;
next	1.117;

1.117
date	2013.11.22.07.59.09;	author mpi;	state Exp;
branches;
next	1.116;

1.116
date	2013.10.20.11.03.01;	author phessler;	state Exp;
branches;
next	1.115;

1.115
date	2013.10.17.16.27.44;	author bluhm;	state Exp;
branches;
next	1.114;

1.114
date	2013.08.12.21.57.16;	author bluhm;	state Exp;
branches;
next	1.113;

1.113
date	2013.08.06.07.31.48;	author bluhm;	state Exp;
branches;
next	1.112;

1.112
date	2013.05.17.09.04.30;	author mpi;	state Exp;
branches;
next	1.111;

1.111
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.110;

1.110
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.109;

1.109
date	2012.01.03.21.50.12;	author bluhm;	state Exp;
branches;
next	1.108;

1.108
date	2011.07.06.23.44.20;	author sthen;	state Exp;
branches;
next	1.107;

1.107
date	2011.04.28.09.56.27;	author claudio;	state Exp;
branches;
next	1.106;

1.106
date	2011.04.04.21.11.22;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2010.10.10.22.02.50;	author bluhm;	state Exp;
branches;
next	1.104;

1.104
date	2010.09.29.06.32.47;	author claudio;	state Exp;
branches;
next	1.103;

1.103
date	2010.09.24.02.59.45;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2010.06.07.13.08.43;	author claudio;	state Exp;
branches;
next	1.101;

1.101
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.99;

1.99
date	2008.05.24.19.48.32;	author thib;	state Exp;
branches;
next	1.98;

1.98
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.97;

1.97
date	2008.05.15.19.40.38;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2007.12.13.20.00.53;	author reyk;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.27.17.23.23;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2007.11.16.19.24.07;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2007.09.01.18.49.28;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2007.06.25.12.17.43;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2007.06.15.18.23.07;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2005.03.04.13.21.42;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2005.02.22.17.28.49;	author mcbride;	state Exp;
branches;
next	1.87;

1.87
date	2004.10.28.19.22.52;	author mcbride;	state Exp;
branches;
next	1.86;

1.86
date	2004.07.15.15.27.22;	author markus;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2004.04.27.17.51.33;	author otto;	state Exp;
branches;
next	1.84;

1.84
date	2004.04.26.18.16.09;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2004.04.25.04.34.05;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.12.19.05.38;	author tedu;	state Exp;
branches;
next	1.81;

1.81
date	2004.03.02.12.51.12;	author markus;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2004.02.15.11.16.08;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.31.21.09.15;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2004.01.31.19.40.10;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2004.01.30.11.33.32;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2004.01.29.11.55.28;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2004.01.06.17.38.13;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.73;

1.73
date	2003.12.08.07.07.36;	author mcbride;	state Exp;
branches;
next	1.72;

1.72
date	2003.11.04.21.43.16;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.09.07.40.25;	author itojun;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.29.00.35.18;	author itojun;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.12.14.41.08;	author jason;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.66;

1.66
date	2002.08.08.19.18.13;	author provos;	state Exp;
branches;
next	1.65;

1.65
date	2002.08.08.18.26.37;	author todd;	state Exp;
branches;
next	1.64;

1.64
date	2002.08.08.17.07.32;	author provos;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.09.16.26.11;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.07.16.18.02;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.26.15.27.07;	author fgsch;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.16.14.10.51;	author kjc;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.08.03.49.58;	author provos;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.02.00.44.52;	author provos;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.15.20.45.32;	author nordin;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.14.03.11.55;	author provos;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.26.06.55.32;	author aaron;	state Exp;
branches
	1.54.4.1;
next	1.53;

1.53
date	2001.06.08.03.53.47;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.05.02.31.37;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.27.03.14.19;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2000.12.13.09.47.08;	author provos;	state Exp;
branches;
next	1.49;

1.49
date	2000.12.11.08.04.56;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2000.10.14.01.04.11;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2000.09.19.03.20.59;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2000.07.11.16.53.22;	author provos;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.06.05.24.45;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.05.22.51.10;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2000.06.18.15.13.33;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.18.04.42.43;	author beck;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.18.02.02.01;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2000.06.03.13.04.39;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	99.12.21.17.49.28;	author provos;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	99.12.20.16.06.25;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	99.09.01.21.38.21;	author provos;	state Exp;
branches;
next	1.35;

1.35
date	99.07.06.20.17.53;	author cmetz;	state Exp;
branches;
next	1.34;

1.34
date	99.07.02.20.39.08;	author cmetz;	state Exp;
branches;
next	1.33;

1.33
date	99.03.24.02.28.21;	author cmetz;	state Exp;
branches;
next	1.32;

1.32
date	99.01.11.02.01.36;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	99.01.07.06.05.05;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	99.01.07.05.52.26;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.11.17.19.23.02;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	98.06.27.02.42.41;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.06.27.02.31.58;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.06.27.02.09.46;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	98.06.26.18.07.30;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.06.11.16.47.17;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.06.10.06.24.48;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.06.10.03.40.07;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	98.05.18.21.11.09;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	98.02.28.03.39.58;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	98.02.25.23.44.58;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.02.25.11.17.43;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.02.25.03.45.15;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	98.01.24.18.21.39;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	98.01.20.02.22.31;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	98.01.06.23.49.49;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.01.03.22.32.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.08.09.23.36.26;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.24.00.25.25;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.06.14.05.49.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.06.06.11.22.18;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.05.15.48.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.20.22.53.12;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.29.22.01.51;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.29.06.22.15;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.07.25.09.46.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.14.08.11.54;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.22.30.49;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches;
next	;

1.39.2.1
date	2001.05.14.22.40.15;	author niklas;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2001.07.04.10.55.10;	author niklas;	state Exp;
branches;
next	1.39.2.3;

1.39.2.3
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.39.2.4;

1.39.2.4
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.39.2.5;

1.39.2.5
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.39.2.6;

1.39.2.6
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.39.2.7;

1.39.2.7
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.39.2.8;

1.39.2.8
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.54.4.1
date	2002.01.31.22.55.46;	author niklas;	state Exp;
branches;
next	1.54.4.2;

1.54.4.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.54.4.3;

1.54.4.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.54.4.4;

1.54.4.4
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;

1.68.2.1
date	2004.03.03.08.40.07;	author brad;	state Exp;
branches;
next	;

1.71.2.1
date	2004.03.03.08.37.05;	author brad;	state Exp;
branches;
next	;

1.81.2.1
date	2005.03.20.23.44.06;	author brad;	state Exp;
branches;
next	;

1.86.2.1
date	2005.03.20.23.36.10;	author brad;	state Exp;
branches;
next	;

1.134.4.1
date	2017.08.02.22.24.26;	author bluhm;	state Exp;
branches;
next	;
commitid	KdbzGjYQvlosTLLh;

1.145.4.1
date	2017.08.01.22.17.22;	author bluhm;	state Exp;
branches;
next	;
commitid	hN7N3xvSFczLTH8W;


desc
@@


1.153
log
@Convert hand rolled sockaddr checks to the nam2sin functions.
Especially in tcp_usrreq() connect detect the correct address family
based on the inp_flags instead of the sa_family user input.
OK mpi@@
@
text
@/*	$OpenBSD: tcp_usrreq.c,v 1.152 2017/06/26 09:32:32 mpi Exp $	*/
/*	$NetBSD: tcp_usrreq.c,v 1.20 1996/02/13 23:44:16 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/domain.h>
#include <sys/kernel.h>
#include <sys/pool.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcp_debug.h>

#ifdef INET6
#include <netinet6/in6_var.h>
#endif

#ifndef TCP_SENDSPACE
#define	TCP_SENDSPACE	1024*16
#endif
u_int	tcp_sendspace = TCP_SENDSPACE;
#ifndef TCP_RECVSPACE
#define	TCP_RECVSPACE	1024*16
#endif
u_int	tcp_recvspace = TCP_RECVSPACE;
u_int	tcp_autorcvbuf_inc = 16 * 1024;

int *tcpctl_vars[TCPCTL_MAXID] = TCPCTL_VARS;

struct	inpcbtable tcbtable;

int tcp_ident(void *, size_t *, void *, size_t, int);

/*
 * Process a TCP user request for TCP tb.  If this is a send request
 * then m is the mbuf chain of send data.  If this is a timer expiration
 * (called from the software clock routine), then timertype tells which timer.
 */
/*ARGSUSED*/
int
tcp_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control, struct proc *p)
{
	struct inpcb *inp;
	struct tcpcb *tp = NULL;
	int error = 0;
	short ostate;

	NET_ASSERT_LOCKED();

	if (req == PRU_CONTROL) {
#ifdef INET6
		if (sotopf(so) == PF_INET6)
			return in6_control(so, (u_long)m, (caddr_t)nam,
			    (struct ifnet *)control);
		else
#endif /* INET6 */
			return (in_control(so, (u_long)m, (caddr_t)nam,
			    (struct ifnet *)control));
	}
	if (control && control->m_len) {
		m_freem(control);
		m_freem(m);
		return (EINVAL);
	}

	inp = sotoinpcb(so);
	/*
	 * When a TCP is attached to a socket, then there will be
	 * a (struct inpcb) pointed at by the socket, and this
	 * structure will point at a subsidiary (struct tcpcb).
	 */
	if (inp == NULL) {
		error = so->so_error;
		if (error == 0)
			error = EINVAL;
		/*
		 * The following corrects an mbuf leak under rare
		 * circumstances
		 */
		if (req == PRU_SEND || req == PRU_SENDOOB)
			m_freem(m);
		return (error);
	}
	if (inp) {
		tp = intotcpcb(inp);
		/* tp might get 0 when using socket splicing */
		if (tp == NULL) {
			return (0);
		}
#ifdef KPROF
		tcp_acounts[tp->t_state][req]++;
#endif
		ostate = tp->t_state;
	} else
		ostate = 0;
	switch (req) {

	/*
	 * PRU_DETACH detaches the TCP protocol from the socket.
	 * If the protocol state is non-embryonic, then can't
	 * do this directly: have to initiate a PRU_DISCONNECT,
	 * which may finish later; embryonic TCB's can just
	 * be discarded here.
	 */
	case PRU_DETACH:
		tp = tcp_disconnect(tp);
		break;

	/*
	 * Give the socket an address.
	 */
	case PRU_BIND:
		error = in_pcbbind(inp, nam, p);
		break;

	/*
	 * Prepare to accept connections.
	 */
	case PRU_LISTEN:
		if (inp->inp_lport == 0)
			error = in_pcbbind(inp, NULL, p);
		/* If the in_pcbbind() above is called, the tp->pf
		   should still be whatever it was before. */
		if (error == 0)
			tp->t_state = TCPS_LISTEN;
		break;

	/*
	 * Initiate connection to peer.
	 * Create a template for use in transmissions on this connection.
	 * Enter SYN_SENT state, and mark socket as connecting.
	 * Start keep-alive timer, and seed output sequence space.
	 * Send initial segment on connection.
	 */
	case PRU_CONNECT:
#ifdef INET6
		if (inp->inp_flags & INP_IPV6) {
			struct sockaddr_in6 *sin6;

			if ((error = in6_nam2sin6(nam, &sin6)))
				break;
			if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) ||
			    IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr)) {
				error = EINVAL;
				break;
			}
			error = in6_pcbconnect(inp, nam);
		} else
#endif /* INET6 */
		{
			struct sockaddr_in *sin;

			if ((error = in_nam2sin(nam, &sin)))
				break;
			if ((sin->sin_addr.s_addr == INADDR_ANY) ||
			    (sin->sin_addr.s_addr == INADDR_BROADCAST) ||
			    IN_MULTICAST(sin->sin_addr.s_addr) ||
			    in_broadcast(sin->sin_addr, inp->inp_rtableid)) {
				error = EINVAL;
				break;
			}
			error = in_pcbconnect(inp, nam);
		}
		if (error)
			break;

		tp->t_template = tcp_template(tp);
		if (tp->t_template == 0) {
			in_pcbdisconnect(inp);
			error = ENOBUFS;
			break;
		}

		so->so_state |= SS_CONNECTOUT;

		/* Compute window scaling to request.  */
		tcp_rscale(tp, sb_max);

		soisconnecting(so);
		tcpstat_inc(tcps_connattempt);
		tp->t_state = TCPS_SYN_SENT;
		TCP_TIMER_ARM(tp, TCPT_KEEP, tcptv_keep_init);
		tcp_set_iss_tsm(tp);
		tcp_sendseqinit(tp);
#if defined(TCP_SACK)
		tp->snd_last = tp->snd_una;
#endif
#if defined(TCP_SACK) && defined(TCP_FACK)
		tp->snd_fack = tp->snd_una;
		tp->retran_data = 0;
		tp->snd_awnd = 0;
#endif
		error = tcp_output(tp);
		break;

	/*
	 * Create a TCP connection between two sockets.
	 */
	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	/*
	 * Initiate disconnect from peer.
	 * If connection never passed embryonic stage, just drop;
	 * else if don't need to let data drain, then can just drop anyways,
	 * else have to begin TCP shutdown process: mark socket disconnecting,
	 * drain unread data, state switch to reflect user close, and
	 * send segment (e.g. FIN) to peer.  Socket will be really disconnected
	 * when peer sends FIN and acks ours.
	 *
	 * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
	 */
	case PRU_DISCONNECT:
		tp = tcp_disconnect(tp);
		break;

	/*
	 * Accept a connection.  Essentially all the work is
	 * done at higher levels; just return the address
	 * of the peer, storing through addr.
	 */
	case PRU_ACCEPT:
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			in6_setpeeraddr(inp, nam);
		else
#endif
			in_setpeeraddr(inp, nam);
		break;

	/*
	 * Mark the connection as being incapable of further output.
	 */
	case PRU_SHUTDOWN:
		if (so->so_state & SS_CANTSENDMORE)
			break;
		socantsendmore(so);
		tp = tcp_usrclosed(tp);
		if (tp)
			error = tcp_output(tp);
		break;

	/*
	 * After a receive, possibly send window update to peer.
	 */
	case PRU_RCVD:
		/*
		 * soreceive() calls this function when a user receives
		 * ancillary data on a listening socket. We don't call
		 * tcp_output in such a case, since there is no header
		 * template for a listening socket and hence the kernel
		 * will panic.
		 */
		if ((so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING)) != 0)
			(void) tcp_output(tp);
		break;

	/*
	 * Do a send by putting data in output queue and updating urgent
	 * marker if URG set.  Possibly send more data.
	 */
	case PRU_SEND:
		sbappendstream(so, &so->so_snd, m);
		error = tcp_output(tp);
		break;

	/*
	 * Abort the TCP.
	 */
	case PRU_ABORT:
		tp = tcp_drop(tp, ECONNABORTED);
		break;

	case PRU_SENSE:
		((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat;
		return (0);

	case PRU_RCVOOB:
		if ((so->so_oobmark == 0 &&
		    (so->so_state & SS_RCVATMARK) == 0) ||
		    so->so_options & SO_OOBINLINE ||
		    tp->t_oobflags & TCPOOB_HADDATA) {
			error = EINVAL;
			break;
		}
		if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) {
			error = EWOULDBLOCK;
			break;
		}
		m->m_len = 1;
		*mtod(m, caddr_t) = tp->t_iobc;
		if (((long)nam & MSG_PEEK) == 0)
			tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
		break;

	case PRU_SENDOOB:
		if (sbspace(so, &so->so_snd) < -512) {
			m_freem(m);
			error = ENOBUFS;
			break;
		}
		/*
		 * According to RFC961 (Assigned Protocols),
		 * the urgent pointer points to the last octet
		 * of urgent data.  We continue, however,
		 * to consider it to indicate the first octet
		 * of data past the urgent section.
		 * Otherwise, snd_up should be one lower.
		 */
		sbappendstream(so, &so->so_snd, m);
		tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
		tp->t_force = 1;
		error = tcp_output(tp);
		tp->t_force = 0;
		break;

	case PRU_SOCKADDR:
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			in6_setsockaddr(inp, nam);
		else
#endif
			in_setsockaddr(inp, nam);
		break;

	case PRU_PEERADDR:
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			in6_setpeeraddr(inp, nam);
		else
#endif
			in_setpeeraddr(inp, nam);
		break;

	default:
		panic("tcp_usrreq");
	}
	if (tp && (so->so_options & SO_DEBUG))
		tcp_trace(TA_USER, ostate, tp, (caddr_t)0, req, 0);
	return (error);
}

int
tcp_ctloutput(int op, struct socket *so, int level, int optname,
    struct mbuf *m)
{
	int error = 0;
	struct inpcb *inp;
	struct tcpcb *tp;
	int i;

	inp = sotoinpcb(so);
	if (inp == NULL) {
		if (op == PRCO_SETOPT)
			(void) m_free(m);
		return (ECONNRESET);
	}
	if (level != IPPROTO_TCP) {
		switch (so->so_proto->pr_domain->dom_family) {
#ifdef INET6
		case PF_INET6:
			error = ip6_ctloutput(op, so, level, optname, m);
			break;
#endif /* INET6 */
		case PF_INET:
			error = ip_ctloutput(op, so, level, optname, m);
			break;
		default:
			error = EAFNOSUPPORT;	/*?*/
			break;
		}
		return (error);
	}
	tp = intotcpcb(inp);

	switch (op) {

	case PRCO_SETOPT:
		switch (optname) {

		case TCP_NODELAY:
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				tp->t_flags |= TF_NODELAY;
			else
				tp->t_flags &= ~TF_NODELAY;
			break;

		case TCP_NOPUSH:
			if (m == NULL || m->m_len < sizeof (int))
				error = EINVAL;
			else if (*mtod(m, int *))
				tp->t_flags |= TF_NOPUSH;
			else if (tp->t_flags & TF_NOPUSH) {
				tp->t_flags &= ~TF_NOPUSH;
				if (TCPS_HAVEESTABLISHED(tp->t_state))
					error = tcp_output(tp);
			}
			break;

		case TCP_MAXSEG:
			if (m == NULL || m->m_len < sizeof (int)) {
				error = EINVAL;
				break;
			}

			i = *mtod(m, int *);
			if (i > 0 && i <= tp->t_maxseg)
				tp->t_maxseg = i;
			else
				error = EINVAL;
			break;

#ifdef TCP_SACK
		case TCP_SACK_ENABLE:
			if (m == NULL || m->m_len < sizeof (int)) {
				error = EINVAL;
				break;
			}

			if (TCPS_HAVEESTABLISHED(tp->t_state)) {
				error = EPERM;
				break;
			}

			if (tp->t_flags & TF_SIGNATURE) {
				error = EPERM;
				break;
			}

			if (*mtod(m, int *))
				tp->sack_enable = 1;
			else
				tp->sack_enable = 0;
			break;
#endif
#ifdef TCP_SIGNATURE
		case TCP_MD5SIG:
			if (m == NULL || m->m_len < sizeof (int)) {
				error = EINVAL;
				break;
			}

			if (TCPS_HAVEESTABLISHED(tp->t_state)) {
				error = EPERM;
				break;
			}

			if (*mtod(m, int *)) {
				tp->t_flags |= TF_SIGNATURE;
#ifdef TCP_SACK
				tp->sack_enable = 0;
#endif /* TCP_SACK */
			} else
				tp->t_flags &= ~TF_SIGNATURE;
			break;
#endif /* TCP_SIGNATURE */
		default:
			error = ENOPROTOOPT;
			break;
		}
		m_free(m);
		break;

	case PRCO_GETOPT:
		m->m_len = sizeof(int);

		switch (optname) {
		case TCP_NODELAY:
			*mtod(m, int *) = tp->t_flags & TF_NODELAY;
			break;
		case TCP_NOPUSH:
			*mtod(m, int *) = tp->t_flags & TF_NOPUSH;
			break;
		case TCP_MAXSEG:
			*mtod(m, int *) = tp->t_maxseg;
			break;
#ifdef TCP_SACK
		case TCP_SACK_ENABLE:
			*mtod(m, int *) = tp->sack_enable;
			break;
#endif
#ifdef TCP_SIGNATURE
		case TCP_MD5SIG:
			*mtod(m, int *) = tp->t_flags & TF_SIGNATURE;
			break;
#endif
		default:
			error = ENOPROTOOPT;
			break;
		}
		break;
	}
	return (error);
}

/*
 * Attach TCP protocol to socket, allocating
 * internet protocol control block, tcp control block,
 * bufer space, and entering LISTEN state if to accept connections.
 */
int
tcp_attach(struct socket *so, int proto)
{
	struct tcpcb *tp;
	struct inpcb *inp;
	int error;

	if (so->so_pcb)
		return EISCONN;
	if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0 ||
	    sbcheckreserve(so->so_snd.sb_wat, tcp_sendspace) ||
	    sbcheckreserve(so->so_rcv.sb_wat, tcp_recvspace)) {
		error = soreserve(so, tcp_sendspace, tcp_recvspace);
		if (error)
			return (error);
	}

	error = in_pcballoc(so, &tcbtable);
	if (error)
		return (error);
	inp = sotoinpcb(so);
	tp = tcp_newtcpcb(inp);
	if (tp == NULL) {
		int nofd = so->so_state & SS_NOFDREF;	/* XXX */

		so->so_state &= ~SS_NOFDREF;	/* don't free the socket yet */
		in_pcbdetach(inp);
		so->so_state |= nofd;
		return (ENOBUFS);
	}
	tp->t_state = TCPS_CLOSED;
#ifdef INET6
	/* we disallow IPv4 mapped address completely. */
	if (inp->inp_flags & INP_IPV6)
		tp->pf = PF_INET6;
	else
		tp->pf = PF_INET;
#else
	tp->pf = PF_INET;
#endif
	if ((so->so_options & SO_LINGER) && so->so_linger == 0)
		so->so_linger = TCP_LINGERTIME;

	if (tp && (so->so_options & SO_DEBUG))
		tcp_trace(TA_USER, 0, tp, (caddr_t)0, 0 /* XXX */, 0);
	return (0);
}

/*
 * Initiate (or continue) disconnect.
 * If embryonic state, just send reset (once).
 * If in ``let data drain'' option and linger null, just drop.
 * Otherwise (hard), mark socket disconnecting and drop
 * current input data; switch states based on user close, and
 * send segment to peer (with FIN).
 */
struct tcpcb *
tcp_disconnect(struct tcpcb *tp)
{
	struct socket *so = tp->t_inpcb->inp_socket;

	if (TCPS_HAVEESTABLISHED(tp->t_state) == 0)
		tp = tcp_close(tp);
	else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
		tp = tcp_drop(tp, 0);
	else {
		soisdisconnecting(so);
		sbflush(so, &so->so_rcv);
		tp = tcp_usrclosed(tp);
		if (tp)
			(void) tcp_output(tp);
	}
	return (tp);
}

/*
 * User issued close, and wish to trail through shutdown states:
 * if never received SYN, just forget it.  If got a SYN from peer,
 * but haven't sent FIN, then go to FIN_WAIT_1 state to send peer a FIN.
 * If already got a FIN from peer, then almost done; go to LAST_ACK
 * state.  In all other cases, have already sent FIN to peer (e.g.
 * after PRU_SHUTDOWN), and just have to play tedious game waiting
 * for peer to send FIN or not respond to keep-alives, etc.
 * We can let the user exit from the close as soon as the FIN is acked.
 */
struct tcpcb *
tcp_usrclosed(struct tcpcb *tp)
{

	switch (tp->t_state) {

	case TCPS_CLOSED:
	case TCPS_LISTEN:
	case TCPS_SYN_SENT:
		tp->t_state = TCPS_CLOSED;
		tp = tcp_close(tp);
		break;

	case TCPS_SYN_RECEIVED:
	case TCPS_ESTABLISHED:
		tp->t_state = TCPS_FIN_WAIT_1;
		break;

	case TCPS_CLOSE_WAIT:
		tp->t_state = TCPS_LAST_ACK;
		break;
	}
	if (tp && tp->t_state >= TCPS_FIN_WAIT_2) {
		soisdisconnected(tp->t_inpcb->inp_socket);
		/*
		 * If we are in FIN_WAIT_2, we arrived here because the
		 * application did a shutdown of the send side.  Like the
		 * case of a transition from FIN_WAIT_1 to FIN_WAIT_2 after
		 * a full close, we start a timer to make sure sockets are
		 * not left in FIN_WAIT_2 forever.
		 */
		if (tp->t_state == TCPS_FIN_WAIT_2)
			TCP_TIMER_ARM(tp, TCPT_2MSL, tcp_maxidle);
	}
	return (tp);
}

/*
 * Look up a socket for ident or tcpdrop, ...
 */
int
tcp_ident(void *oldp, size_t *oldlenp, void *newp, size_t newlen, int dodrop)
{
	int error = 0;
	struct tcp_ident_mapping tir;
	struct inpcb *inp;
	struct tcpcb *tp = NULL;
	struct sockaddr_in *fin, *lin;
#ifdef INET6
	struct sockaddr_in6 *fin6, *lin6;
	struct in6_addr f6, l6;
#endif

	NET_ASSERT_LOCKED();

	if (dodrop) {
		if (oldp != NULL || *oldlenp != 0)
			return (EINVAL);
		if (newp == NULL)
			return (EPERM);
		if (newlen < sizeof(tir))
			return (ENOMEM);
		if ((error = copyin(newp, &tir, sizeof (tir))) != 0 )
			return (error);
	} else {
		if (oldp == NULL)
			return (EINVAL);
		if (*oldlenp < sizeof(tir))
			return (ENOMEM);
		if (newp != NULL || newlen != 0)
			return (EINVAL);
		if ((error = copyin(oldp, &tir, sizeof (tir))) != 0 )
			return (error);
	}
	switch (tir.faddr.ss_family) {
#ifdef INET6
	case AF_INET6:
		fin6 = (struct sockaddr_in6 *)&tir.faddr;
		error = in6_embedscope(&f6, fin6, NULL);
		if (error)
			return EINVAL;	/*?*/
		lin6 = (struct sockaddr_in6 *)&tir.laddr;
		error = in6_embedscope(&l6, lin6, NULL);
		if (error)
			return EINVAL;	/*?*/
		break;
#endif
	case AF_INET:
		fin = (struct sockaddr_in *)&tir.faddr;
		lin = (struct sockaddr_in *)&tir.laddr;
		break;
	default:
		return (EINVAL);
	}

	switch (tir.faddr.ss_family) {
#ifdef INET6
	case AF_INET6:
		inp = in6_pcbhashlookup(&tcbtable, &f6,
		    fin6->sin6_port, &l6, lin6->sin6_port, tir.rdomain);
		break;
#endif
	case AF_INET:
		inp = in_pcbhashlookup(&tcbtable, fin->sin_addr,
		    fin->sin_port, lin->sin_addr, lin->sin_port, tir.rdomain);
		break;
	default:
		unhandled_af(tir.faddr.ss_family);
	}

	if (dodrop) {
		if (inp && (tp = intotcpcb(inp)) &&
		    ((inp->inp_socket->so_options & SO_ACCEPTCONN) == 0))
			tp = tcp_drop(tp, ECONNABORTED);
		else
			error = ESRCH;
		return (error);
	}

	if (inp == NULL) {
		tcpstat_inc(tcps_pcbhashmiss);
		switch (tir.faddr.ss_family) {
#ifdef INET6
		case AF_INET6:
			inp = in6_pcblookup_listen(&tcbtable,
			    &l6, lin6->sin6_port, 0, NULL, tir.rdomain);
			break;
#endif
		case AF_INET:
			inp = in_pcblookup_listen(&tcbtable,
			    lin->sin_addr, lin->sin_port, 0, NULL, tir.rdomain);
			break;
		}
	}

	if (inp != NULL && (inp->inp_socket->so_state & SS_CONNECTOUT)) {
		tir.ruid = inp->inp_socket->so_ruid;
		tir.euid = inp->inp_socket->so_euid;
	} else {
		tir.ruid = -1;
		tir.euid = -1;
	}

	*oldlenp = sizeof (tir);
	error = copyout((void *)&tir, oldp, sizeof (tir));
	return (error);
}

int
tcp_sysctl_tcpstat(void *oldp, size_t *oldlenp, void *newp)
{
	uint64_t counters[tcps_ncounters];
	struct tcpstat tcpstat;
	struct syn_cache_set *set;
	int i = 0;

#define ASSIGN(field)	do { tcpstat.field = counters[i++]; } while (0)

	memset(&tcpstat, 0, sizeof tcpstat);
	counters_read(tcpcounters, counters, nitems(counters));
	ASSIGN(tcps_connattempt);
	ASSIGN(tcps_accepts);
	ASSIGN(tcps_connects);
	ASSIGN(tcps_drops);
	ASSIGN(tcps_conndrops);
	ASSIGN(tcps_closed);
	ASSIGN(tcps_segstimed);
	ASSIGN(tcps_rttupdated);
	ASSIGN(tcps_delack);
	ASSIGN(tcps_timeoutdrop);
	ASSIGN(tcps_rexmttimeo);
	ASSIGN(tcps_persisttimeo);
	ASSIGN(tcps_persistdrop);
	ASSIGN(tcps_keeptimeo);
	ASSIGN(tcps_keepprobe);
	ASSIGN(tcps_keepdrops);
	ASSIGN(tcps_sndtotal);
	ASSIGN(tcps_sndpack);
	ASSIGN(tcps_sndbyte);
	ASSIGN(tcps_sndrexmitpack);
	ASSIGN(tcps_sndrexmitbyte);
	ASSIGN(tcps_sndrexmitfast);
	ASSIGN(tcps_sndacks);
	ASSIGN(tcps_sndprobe);
	ASSIGN(tcps_sndurg);
	ASSIGN(tcps_sndwinup);
	ASSIGN(tcps_sndctrl);
	ASSIGN(tcps_rcvtotal);
	ASSIGN(tcps_rcvpack);
	ASSIGN(tcps_rcvbyte);
	ASSIGN(tcps_rcvbadsum);
	ASSIGN(tcps_rcvbadoff);
	ASSIGN(tcps_rcvmemdrop);
	ASSIGN(tcps_rcvnosec);
	ASSIGN(tcps_rcvshort);
	ASSIGN(tcps_rcvduppack);
	ASSIGN(tcps_rcvdupbyte);
	ASSIGN(tcps_rcvpartduppack);
	ASSIGN(tcps_rcvpartdupbyte);
	ASSIGN(tcps_rcvoopack);
	ASSIGN(tcps_rcvoobyte);
	ASSIGN(tcps_rcvpackafterwin);
	ASSIGN(tcps_rcvbyteafterwin);
	ASSIGN(tcps_rcvafterclose);
	ASSIGN(tcps_rcvwinprobe);
	ASSIGN(tcps_rcvdupack);
	ASSIGN(tcps_rcvacktoomuch);
	ASSIGN(tcps_rcvacktooold);
	ASSIGN(tcps_rcvackpack);
	ASSIGN(tcps_rcvackbyte);
	ASSIGN(tcps_rcvwinupd);
	ASSIGN(tcps_pawsdrop);
	ASSIGN(tcps_predack);
	ASSIGN(tcps_preddat);
	ASSIGN(tcps_pcbhashmiss);
	ASSIGN(tcps_noport);
	ASSIGN(tcps_badsyn);
	ASSIGN(tcps_dropsyn);
	ASSIGN(tcps_rcvbadsig);
	ASSIGN(tcps_rcvgoodsig);
	ASSIGN(tcps_inswcsum);
	ASSIGN(tcps_outswcsum);
	ASSIGN(tcps_ecn_accepts);
	ASSIGN(tcps_ecn_rcvece);
	ASSIGN(tcps_ecn_rcvcwr);
	ASSIGN(tcps_ecn_rcvce);
	ASSIGN(tcps_ecn_sndect);
	ASSIGN(tcps_ecn_sndece);
	ASSIGN(tcps_ecn_sndcwr);
	ASSIGN(tcps_cwr_ecn);
	ASSIGN(tcps_cwr_frecovery);
	ASSIGN(tcps_cwr_timeout);
	ASSIGN(tcps_sc_added);
	ASSIGN(tcps_sc_completed);
	ASSIGN(tcps_sc_timed_out);
	ASSIGN(tcps_sc_overflowed);
	ASSIGN(tcps_sc_reset);
	ASSIGN(tcps_sc_unreach);
	ASSIGN(tcps_sc_bucketoverflow);
	ASSIGN(tcps_sc_aborted);
	ASSIGN(tcps_sc_dupesyn);
	ASSIGN(tcps_sc_dropped);
	ASSIGN(tcps_sc_collisions);
	ASSIGN(tcps_sc_retransmitted);
	ASSIGN(tcps_sc_seedrandom);
	ASSIGN(tcps_sc_hash_size);
	ASSIGN(tcps_sc_entry_count);
	ASSIGN(tcps_sc_entry_limit);
	ASSIGN(tcps_sc_bucket_maxlen);
	ASSIGN(tcps_sc_bucket_limit);
	ASSIGN(tcps_sc_uses_left);
	ASSIGN(tcps_conndrained);
	ASSIGN(tcps_sack_recovery_episode);
	ASSIGN(tcps_sack_rexmits);
	ASSIGN(tcps_sack_rexmit_bytes);
	ASSIGN(tcps_sack_rcv_opts);
	ASSIGN(tcps_sack_snd_opts);

#undef ASSIGN

	set = &tcp_syn_cache[tcp_syn_cache_active];
	tcpstat.tcps_sc_hash_size = set->scs_size;
	tcpstat.tcps_sc_entry_count = set->scs_count;
	tcpstat.tcps_sc_entry_limit = tcp_syn_cache_limit;
	tcpstat.tcps_sc_bucket_maxlen = 0;
	for (i = 0; i < set->scs_size; i++) {
		if (tcpstat.tcps_sc_bucket_maxlen <
		    set->scs_buckethead[i].sch_length)
			tcpstat.tcps_sc_bucket_maxlen =
				set->scs_buckethead[i].sch_length;
	}
	tcpstat.tcps_sc_bucket_limit = tcp_syn_bucket_limit;
	tcpstat.tcps_sc_uses_left = set->scs_use;

	return (sysctl_rdstruct(oldp, oldlenp, newp,
	    &tcpstat, sizeof(tcpstat)));
}

/*
 * Sysctl for tcp variables.
 */
int
tcp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	int error, nval;

	NET_ASSERT_LOCKED();

	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
#ifdef TCP_SACK
	case TCPCTL_SACK:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_sack));
#endif
	case TCPCTL_SLOWHZ:
		return (sysctl_rdint(oldp, oldlenp, newp, PR_SLOWHZ));

	case TCPCTL_BADDYNAMIC:
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    baddynamicports.tcp, sizeof(baddynamicports.tcp)));

	case TCPCTL_ROOTONLY:
		if (newp && securelevel > 0)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    rootonlyports.tcp, sizeof(rootonlyports.tcp)));

	case TCPCTL_IDENT:
		return (tcp_ident(oldp, oldlenp, newp, newlen, 0));

	case TCPCTL_DROP:
		return (tcp_ident(oldp, oldlenp, newp, newlen, 1));

	case TCPCTL_ALWAYS_KEEPALIVE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_always_keepalive));

#ifdef TCP_ECN
	case TCPCTL_ECN:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		   &tcp_do_ecn));
#endif
	case TCPCTL_REASS_LIMIT:
		nval = tcp_reass_limit;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nval);
		if (error)
			return (error);
		if (nval != tcp_reass_limit) {
			error = pool_sethardlimit(&tcpqe_pool, nval, NULL, 0);
			if (error)
				return (error);
			tcp_reass_limit = nval;
		}
		return (0);
#ifdef TCP_SACK
	case TCPCTL_SACKHOLE_LIMIT:
		nval = tcp_sackhole_limit;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nval);
		if (error)
			return (error);
		if (nval != tcp_sackhole_limit) {
			error = pool_sethardlimit(&sackhl_pool, nval, NULL, 0);
			if (error)
				return (error);
			tcp_sackhole_limit = nval;
		}
		return (0);
#endif

	case TCPCTL_STATS:
		return (tcp_sysctl_tcpstat(oldp, oldlenp, newp));

	case TCPCTL_SYN_USE_LIMIT:
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_syn_use_limit);
		if (error)
			return (error);
		if (newp != NULL) {
			/*
			 * Global tcp_syn_use_limit is used when reseeding a
			 * new cache.  Also update the value in active cache.
			 */
			if (tcp_syn_cache[0].scs_use > tcp_syn_use_limit)
				tcp_syn_cache[0].scs_use = tcp_syn_use_limit;
			if (tcp_syn_cache[1].scs_use > tcp_syn_use_limit)
				tcp_syn_cache[1].scs_use = tcp_syn_use_limit;
		}
		return (0);

	case TCPCTL_SYN_HASH_SIZE:
		nval = tcp_syn_hash_size;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nval);
		if (error)
			return (error);
		if (nval != tcp_syn_hash_size) {
			if (nval < 1 || nval > 100000)
				return (EINVAL);
			/*
			 * If global hash size has been changed, switch sets as
			 * soon as possible.  Then the actual hash array will
			 * be reallocated.
			 */
			if (tcp_syn_cache[0].scs_size != nval)
				tcp_syn_cache[0].scs_use = 0;
			if (tcp_syn_cache[1].scs_size != nval)
				tcp_syn_cache[1].scs_use = 0;
			tcp_syn_hash_size = nval;
		}
		return (0);

	default:
		if (name[0] < TCPCTL_MAXID)
			return (sysctl_int_arr(tcpctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}

/*
 * Scale the send buffer so that inflight data is not accounted against
 * the limit. The buffer will scale with the congestion window, if the
 * the receiver stops acking data the window will shrink and therefor
 * the buffer size will shrink as well.
 * In low memory situation try to shrink the buffer to the initial size
 * disabling the send buffer scaling as long as the situation persists.
 */
void
tcp_update_sndspace(struct tcpcb *tp)
{
	struct socket *so = tp->t_inpcb->inp_socket;
	u_long nmax = so->so_snd.sb_hiwat;

	if (sbchecklowmem()) {
		/* low on memory try to get rid of some */
		if (tcp_sendspace < nmax)
			nmax = tcp_sendspace;
	} else if (so->so_snd.sb_wat != tcp_sendspace)
		/* user requested buffer size, auto-scaling disabled */
		nmax = so->so_snd.sb_wat;
	else
		/* automatic buffer scaling */
		nmax = MIN(sb_max, so->so_snd.sb_wat + tp->snd_max -
		    tp->snd_una);

	/* a writable socket must be preserved because of poll(2) semantics */
	if (sbspace(so, &so->so_snd) >= so->so_snd.sb_lowat) {
		if (nmax < so->so_snd.sb_cc + so->so_snd.sb_lowat)
			nmax = so->so_snd.sb_cc + so->so_snd.sb_lowat;
		if (nmax * 2 < so->so_snd.sb_mbcnt + so->so_snd.sb_lowat)
			nmax = (so->so_snd.sb_mbcnt+so->so_snd.sb_lowat+1) / 2;
	}

	/* round to MSS boundary */
	nmax = roundup(nmax, tp->t_maxseg);

	if (nmax != so->so_snd.sb_hiwat)
		sbreserve(so, &so->so_snd, nmax);
}

/*
 * Scale the recv buffer by looking at how much data was transferred in
 * on approximated RTT. If more than a big part of the recv buffer was
 * transferred during that time we increase the buffer by a constant.
 * In low memory situation try to shrink the buffer to the initial size.
 */
void
tcp_update_rcvspace(struct tcpcb *tp)
{
	struct socket *so = tp->t_inpcb->inp_socket;
	u_long nmax = so->so_rcv.sb_hiwat;

	if (sbchecklowmem()) {
		/* low on memory try to get rid of some */
		if (tcp_recvspace < nmax)
			nmax = tcp_recvspace;
	} else if (so->so_rcv.sb_wat != tcp_recvspace)
		/* user requested buffer size, auto-scaling disabled */
		nmax = so->so_rcv.sb_wat;
	else {
		/* automatic buffer scaling */
		if (tp->rfbuf_cnt > so->so_rcv.sb_hiwat / 8 * 7)
			nmax = MIN(sb_max, so->so_rcv.sb_hiwat +
			    tcp_autorcvbuf_inc);
	}

	/* a readable socket must be preserved because of poll(2) semantics */
	if (so->so_rcv.sb_cc >= so->so_rcv.sb_lowat &&
	    nmax < so->so_snd.sb_lowat)
		nmax = so->so_snd.sb_lowat;

	if (nmax == so->so_rcv.sb_hiwat)
		return;

	/* round to MSS boundary */
	nmax = roundup(nmax, tp->t_maxseg);
	sbreserve(so, &so->so_rcv, nmax);
}
@


1.152
log
@Assert that the corresponding socket is locked when manipulating socket
buffers.

This is one step towards unlocking TCP input path.  Note that all the
functions asserting for the socket lock are not necessarilly MP-safe.
All the fields of 'struct socket' aren't protected.

Introduce a new kernel-only kqueue hint, NOTE_SUBMIT, to be able to
tell when a filter needs to lock the underlying data structures.  Logic
and name taken from NetBSD.

Tested by Hrvoje Popovski.

ok claudio@@, bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.151 2017/05/18 11:38:07 mpi Exp $	*/
d222 8
a229 9
		switch (mtod(nam, struct sockaddr *)->sa_family) {
		case AF_INET: {
			struct in_addr *addr =
			    &mtod(nam, struct sockaddr_in *)->sin_addr;

			if ((addr->s_addr == INADDR_ANY) ||
			    (addr->s_addr == INADDR_BROADCAST) ||
			    IN_MULTICAST(addr->s_addr) ||
			    in_broadcast(*addr, inp->inp_rtableid)) {
d233 5
d239 6
a244 10
			error = in_pcbconnect(inp, nam);
			break;
		}
#ifdef INET6
		case AF_INET6: {
			struct in6_addr *addr6 =
			    &mtod(nam, struct sockaddr_in6 *)->sin6_addr;

			if (IN6_IS_ADDR_UNSPECIFIED(addr6) ||
			    IN6_IS_ADDR_MULTICAST(addr6)) {
d248 1
a248 8

			error = in6_pcbconnect(inp, nam);
			break;
		}
#endif /* INET6 */
		default:
			error = EAFNOSUPPORT;
			break;
a249 1

@


1.151
log
@Merge the content of <netinet/tcpip.h> and <netinet6/tcpipv6.h> in
<netinet/tcp_debug.h>.

The IPv6 variant was always included and the IPv4 version is not
present on all systems.

Most of the offending ports are already fixed, thanks to sthen@@!
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.150 2017/05/16 12:24:02 mpi Exp $	*/
d358 1
a358 1
		sbappendstream(&so->so_snd, m);
d392 1
a392 1
		if (sbspace(&so->so_snd) < -512) {
d405 1
a405 1
		sbappendstream(&so->so_snd, m);
d665 1
a665 1
		sbflush(&so->so_rcv);
d1114 1
a1114 1
	if (sbspace(&so->so_snd) >= so->so_snd.sb_lowat) {
d1125 1
a1125 1
		sbreserve(&so->so_snd, nmax);
d1164 1
a1164 1
	sbreserve(&so->so_rcv, nmax);
@


1.150
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.149 2017/05/13 17:41:57 bluhm Exp $	*/
a96 1
#include <netinet/tcpip.h>
@


1.149
log
@Do not check for mapped addresses in tcp_usrreq(PRU_CONNECT),
this is done in in6_pcbconnect().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.148 2017/05/12 20:34:29 bluhm Exp $	*/
d737 1
a737 1
	splsoftassert(IPL_SOFTNET);
@


1.148
log
@Use the common switch(af) construct for address family specific
code in tcp_usrreq(PRU_CONNECT).  Do not access sockaddr_in before
checking the address family.  Return EAFNOSUPPORT error in the
default case.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.147 2017/04/05 13:35:18 deraadt Exp $	*/
d245 1
a245 2
			    IN6_IS_ADDR_MULTICAST(addr6) ||
			    IN6_IS_ADDR_V4MAPPED(addr6)) {
@


1.147
log
@When building counter memory in preparation to copy to userland, always
zero the buffers first.  All the current objects appear to be safe,
however future changes might introduce structure pads.
Discussed with guenther, ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.146 2017/04/02 12:56:39 jca Exp $	*/
a129 1
	struct sockaddr_in *sin;
d223 12
a234 1
		sin = mtod(nam, struct sockaddr_in *);
d236 3
d240 7
a246 7
		if (sin->sin_family == AF_INET6) {
			struct in6_addr *in6_addr = &mtod(nam,
			    struct sockaddr_in6 *)->sin6_addr;

			if (IN6_IS_ADDR_UNSPECIFIED(in6_addr) ||
			    IN6_IS_ADDR_MULTICAST(in6_addr) ||
			    IN6_IS_ADDR_V4MAPPED(in6_addr)) {
d252 2
a253 1
		} else if (sin->sin_family == AF_INET)
d255 3
a257 10
		{
			if ((sin->sin_addr.s_addr == INADDR_ANY) ||
			    (sin->sin_addr.s_addr == INADDR_BROADCAST) ||
			    IN_MULTICAST(sin->sin_addr.s_addr) ||
			    in_broadcast(sin->sin_addr, inp->inp_rtableid)) {
				error = EINVAL;
				break;
			}

			error = in_pcbconnect(inp, nam);
@


1.146
log
@Fix tcp stats reporting

Return the sum of per-cpu counters instead of the current cpu's
counters.  Brainfart on my side.  Analysis and fix by Andrei-Marius Radu.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.145 2017/03/13 20:18:21 claudio Exp $	*/
d836 1
@


1.145
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.144 2017/02/09 15:19:32 jca Exp $	*/
d829 1
a830 2
	struct counters_ref cr;
	uint64_t *counters;
d836 1
a836 1
	counters = counters_enter(&cr, tcpcounters);
a933 1
	counters_leave(&cr, tcpcounters);
@


1.145.4.1
log
@With an invalid address family in the connect address, tcp_usrreq()
may take an unintended code path.  Return error EAFNOSUPPORT instead.
Found by Ilja Van Sprundel
errata 019
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.145 2017/03/13 20:18:21 claudio Exp $	*/
d239 1
a239 1
		} else
d241 1
a241 1
		if (sin->sin_family == AF_INET) {
a250 2
		} else {
			error = EAFNOSUPPORT;
@


1.144
log
@percpu counters for TCP stats

ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.143 2017/02/01 20:59:47 dhill Exp $	*/
d160 1
a160 1
	if (inp == NULL && req != PRU_ATTACH) {
a186 17
	 * TCP attaches to socket via PRU_ATTACH, reserving space,
	 * and an internet control block.
	 */
	case PRU_ATTACH:
		if (inp) {
			error = EISCONN;
			break;
		}
		error = tcp_attach(so);
		if (error)
			break;
		if ((so->so_options & SO_LINGER) && so->so_linger == 0)
			so->so_linger = TCP_LINGERTIME;
		tp = sototcpcb(so);
		break;

	/*
d594 1
a594 1
tcp_attach(struct socket *so)
d600 2
d633 5
@


1.143
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.142 2017/01/10 09:01:18 mpi Exp $	*/
d286 1
a286 1
		tcpstat.tcps_connattempt++;
d808 1
a808 1
		++tcpstat.tcps_pcbhashmiss;
d836 131
d1044 1
a1044 22
		if (newp != NULL)
			return (EPERM);
		{
			struct syn_cache_set *set;
			int i;

			set = &tcp_syn_cache[tcp_syn_cache_active];
			tcpstat.tcps_sc_hash_size = set->scs_size;
			tcpstat.tcps_sc_entry_count = set->scs_count;
			tcpstat.tcps_sc_entry_limit = tcp_syn_cache_limit;
			tcpstat.tcps_sc_bucket_maxlen = 0;
			for (i = 0; i < set->scs_size; i++) {
				if (tcpstat.tcps_sc_bucket_maxlen <
				    set->scs_buckethead[i].sch_length)
					tcpstat.tcps_sc_bucket_maxlen =
					    set->scs_buckethead[i].sch_length;
			}
			tcpstat.tcps_sc_bucket_limit = tcp_syn_bucket_limit;
			tcpstat.tcps_sc_uses_left = set->scs_use;
		}
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &tcpstat, sizeof(tcpstat)));
@


1.142
log
@Remove NULL checks before m_free(9), it deals with it.

ok bluhm@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.141 2017/01/03 10:52:21 mpi Exp $	*/
d452 1
a452 1
    struct mbuf **mp)
a456 1
	struct mbuf *m;
d462 1
a462 1
			(void) m_free(*mp);
d469 1
a469 1
			error = ip6_ctloutput(op, so, level, optname, mp);
d473 1
a473 1
			error = ip_ctloutput(op, so, level, optname, mp);
a485 1
		m = *mp;
a573 1
		*mp = m = m_get(M_WAIT, MT_SOOPTS);
@


1.141
log
@Remove some recursives splsoftnet().

ok visa@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.140 2016/12/26 21:30:10 jca Exp $	*/
d572 1
a572 2
		if (m)
			(void) m_free(m);
@


1.140
log
@Typo, "more then" -> "more than"
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.139 2016/12/20 18:33:43 bluhm Exp $	*/
d735 1
a735 1
	int error = 0, s;
d744 3
a786 1
	s = splsoftnet();
a807 1
		splx(s);
a833 1
	splx(s);
@


1.139
log
@A NET_LOCK() was is missing in tcp_sysctl() which shows up as spl
softnet assert failures.  It is better to place the lock into
net_sysctl() where all the protocol sysctls are called via pr_sysctl.
As calling sysctl(2) is in the slow path, doing fine grained locking
has no benefit.  Many sysctl cases copy out a struct.  Having a
lock around that keeps the struct consistent.  Put assertions in
the protocol sysctls that need it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.138 2016/12/20 14:10:00 mpi Exp $	*/
d1030 1
a1030 1
 * on approximated RTT. If more then a big part of the recv buffer was
@


1.138
log
@Kill recursive splsoftnet()/splx() in tcp_ctloutput().

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.137 2016/12/19 08:36:49 mpi Exp $	*/
d848 2
@


1.137
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.136 2016/11/21 09:09:06 mpi Exp $	*/
d454 1
a454 1
	int error = 0, s;
a459 1
	s = splsoftnet();
a461 1
		splx(s);
a479 1
		splx(s);
a605 1
	splx(s);
@


1.136
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.135 2016/09/24 14:51:37 naddy Exp $	*/
d136 1
a136 1
	splsoftassert(IPL_SOFTNET);
@


1.135
log
@ANSIfy netinet/; from David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.134 2016/07/20 19:57:53 bluhm Exp $	*/
a132 1
	int s;
d136 2
a153 1
	s = splsoftnet();
a163 1
		splx(s);
a175 1
			splx(s);
a382 1
		splx(s);
a446 1
	splx(s);
@


1.134
log
@To tune the TCP SYN cache we need more information.  Print the
relevant counters with netstat -s -p tcp.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.133 2016/07/20 09:15:28 bluhm Exp $	*/
d127 2
a128 5
tcp_usrreq(so, req, m, nam, control, p)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
	struct proc *p;
d455 2
a456 5
tcp_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
d623 1
a623 2
tcp_attach(so)
	struct socket *so;
d672 1
a672 2
tcp_disconnect(tp)
	struct tcpcb *tp;
d701 1
a701 2
tcp_usrclosed(tp)
	struct tcpcb *tp;
d852 2
a853 7
tcp_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
@


1.134.4.1
log
@With an invalid address family in the connect address, tcp_usrreq()
may take an unintended code path.  Return error EAFNOSUPPORT instead.
Found by Ilja Van Sprundel
errata 033
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.134 2016/07/20 19:57:53 bluhm Exp $	*/
d261 1
a261 1
		} else
d263 1
a263 1
		if (sin->sin_family == AF_INET) {
a272 2
		} else {
			error = EAFNOSUPPORT;
@


1.133
log
@Make the size for the syn cache hash array tunable.  As we are
swapping between two syn caches for random reseeding anyway, this
feature can be added easily.  When the cache is empty, there is an
opportunity to change the hash size.  This allows an admin under
SYN flood attack to defend his machine.
Suggested by claudio@@; OK jung@@ claudio@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.132 2016/07/11 10:35:43 mpi Exp $	*/
d939 18
@


1.132
log
@Do not increase the size of the socket buffer under memory pressure.

From Simon Mages, ok beck@@, claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.131 2016/06/18 10:36:13 vgross Exp $	*/
d956 21
@


1.131
log
@Add net.inet.{tcp,udp}.rootonly sysctl, to mark which ports
cannot be bound to by non-root users.

Ok millert@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.130 2016/03/29 18:13:20 bluhm Exp $	*/
d980 1
a980 1
	u_long nmax;
d982 1
a982 1
	if (sbchecklowmem())
d984 3
a986 2
		nmax = tcp_sendspace;
	else if (so->so_snd.sb_wat != tcp_sendspace)
d1021 1
a1021 1
	if (sbchecklowmem())
d1023 3
a1025 2
		nmax = tcp_recvspace;
	else if (so->so_rcv.sb_wat != tcp_recvspace)
@


1.130
log
@Allow to adjust tcp_syn_use_limit with sysctl net.inet.tcp.synuselimit.
This is convenient to test the feature and may be useful to defend
against syn flooding in a denial of service condition.  It is
consistent to the existing syn cache sysctls.  Move some declarations
to tcp_var.h to access the syn cache sets from tcp_sysctl().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.129 2016/03/23 15:50:36 vgross Exp $	*/
d887 6
@


1.129
log
@Merge in_pcbbind() and in6_pcbbind(), and change every call to
in6_pcbbind() into in_pcbbind().

Ok jca@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.128 2015/09/11 07:42:35 claudio Exp $	*/
d935 17
@


1.128
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.127 2015/08/27 17:10:45 bluhm Exp $	*/
d223 1
a223 8
#ifdef INET6
		if (inp->inp_flags & INP_IPV6)
			error = in6_pcbbind(inp, nam, p);
		else
#endif
			error = in_pcbbind(inp, nam, p);
		if (error)
			break;
d230 2
a231 8
		if (inp->inp_lport == 0) {
#ifdef INET6
			if (inp->inp_flags & INP_IPV6)
				error = in6_pcbbind(inp, NULL, p);
			else
#endif
				error = in_pcbbind(inp, NULL, p);
		}
@


1.127
log
@When the dynamic TCP update is reducing so->so_snd.sb_hiwat the
sbspace() in the socket buffer shrinks.  So a writable socket
reported by poll(2) could become unwritable before calling write(2).
Ensure that a writable or readable socket can still be written to
or read from after changing the buffer size.
Discussed with and OK millert@@ deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.126 2015/07/15 22:16:42 deraadt Exp $	*/
d797 1
a797 1
		error = in6_embedscope(&f6, fin6, NULL, NULL);
d801 1
a801 1
		error = in6_embedscope(&l6, lin6, NULL, NULL);
@


1.126
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.125 2015/06/07 12:02:28 jsg Exp $	*/
d983 8
d1022 5
@


1.125
log
@Introduce unhandled_af() for cases where code conditionally does
something based on an address family and later assumes one of the paths
was taken.  This was initially just calls to panic until guenther
suggested a function to reduce the amount of strings needed.

This reduces the amount of noise with static analysers and acts
as a sanity check.

ok guenther@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.124 2015/06/07 01:25:27 krw Exp $	*/
d152 1
a152 2
		if (m)
			m_freem(m);
d172 1
a172 1
		if (m && (req == PRU_SEND || req == PRU_SENDOOB))
d487 1
a487 1
		if (op == PRCO_SETOPT && *mp)
@


1.124
log
@Replace a bunch of == 0 with == NULL in pointer tests. Nuke some
annoying trailing, leading and embedded whitespace. No change to
.o files.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.123 2014/12/05 15:50:04 mpi Exp $	*/
d827 2
@


1.123
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.122 2014/11/25 15:35:10 mpi Exp $	*/
d45 4
a48 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d164 1
a164 1
	if (inp == 0 && req != PRU_ATTACH) {
d300 1
a300 1
		
d808 1
a808 1
	  	fin = (struct sockaddr_in *)&tir.faddr;
d849 1
a849 1
			inp = in_pcblookup_listen(&tcbtable, 
@


1.122
log
@Since in_broadcast() is now used to always iterate on all the interfaces
of your system, put it on a diet and kill the superfluous logic.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.121 2014/11/18 02:37:31 tedu Exp $	*/
d84 1
@


1.121
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.120 2014/09/14 14:17:26 jsg Exp $	*/
d278 1
d280 1
a280 2
			    in_broadcast(sin->sin_addr, NULL,
			    inp->inp_rtableid)) {
@


1.120
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.119 2014/07/22 11:06:10 mpi Exp $	*/
a81 2

#include <dev/rndvar.h>
@


1.119
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.118 2014/04/06 16:49:40 chrisz Exp $	*/
a77 1
#include <sys/proc.h>
@


1.118
log
@Remove redundant call to in{,6}_pcbbind() from tcp PRU_CONNECT.
Make sure that in_pcbbind() is called from in_pcbconnect() by KASSERTing that
local port == 0 implies an unspecified local address.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.117 2013/11/22 07:59:09 mpi Exp $	*/
a89 1
#include <netinet/in_systm.h>
@


1.117
log
@Remove unused proc argument in in6_control().

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.116 2013/10/20 11:03:01 phessler Exp $	*/
a276 5
			if (inp->inp_lport == 0) {
				error = in6_pcbbind(inp, NULL, p);
				if (error)
					break;
			}
a288 5
			if (inp->inp_lport == 0) {
				error = in_pcbbind(inp, NULL, p);
				if (error)
					break;
			}
@


1.116
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.115 2013/10/17 16:27:44 bluhm Exp $	*/
d147 1
a147 1
			    (struct ifnet *)control, 0);
@


1.115
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.114 2013/08/12 21:57:16 bluhm Exp $	*/
d833 1
a833 1
		    fin6->sin6_port, &l6, lin6->sin6_port);
d837 2
a838 2
		inp = in_pcbhashlookup(&tcbtable,  fin->sin_addr,
		    fin->sin_port, lin->sin_addr, lin->sin_port , tir.rdomain);
d858 1
a858 1
			    &l6, lin6->sin6_port, 0, NULL);
@


1.114
log
@Add the TCP socket option TCP_NOPUSH to delay sending the stream.
This is useful to aggregate data in the kernel from multiple sources
like writes and socket splicing.  It avoids sending small packets.
From FreeBSD via David Hill; OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.113 2013/08/06 07:31:48 bluhm Exp $	*/
d102 4
@


1.113
log
@In tcp_ctloutput() tp was assigned at two different places for IPv4
and IPv6.  The variable tp is not accessed between these two
assingments.  intotcpcb() is a define without side effects.  So use
the same code for IPv4 and IPv6.
OK claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.112 2013/05/17 09:04:30 mpi Exp $	*/
d535 12
d619 3
@


1.112
log
@Move an extern declaration into its corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.111 2013/04/10 08:50:59 mpi Exp $	*/
a500 3
#ifdef INET6
	tp = intotcpcb(inp);
#endif /* INET6 */
a517 1
#ifndef INET6
a518 1
#endif /* !INET6 */
@


1.111
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.110 2012/02/24 06:19:00 guenther Exp $	*/
a101 3

/* from in_pcb.c */
extern	struct baddynamicports baddynamicports;
@


1.110
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.109 2012/01/03 21:50:12 bluhm Exp $	*/
a101 8

/*
 * TCP protocol interface to socket abstraction.
 */
extern	char *tcpstates[];
extern	int tcptv_keep_init;

extern int tcp_rst_ppslim;
@


1.109
log
@When used with socket splicing, tcp_usrreq() might get called with
a socket that has an inp but tp is NULL.  The call stack for that
is tcp_input() tcp_close() soisdisconnected() sorwakeup() somove()
tcp_usrreq(PRU_RCVD).  To avoid a NULL dereference, just return in
that case.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.108 2011/07/06 23:44:20 sthen Exp $	*/
d1000 1
a1000 1
 * Scale the recv buffer by looking at how much data was transfered in
d1002 1
a1002 1
 * transfered during that time we increase the buffer by a constant.
@


1.108
log
@Add sysctl net.inet.tcp.always_keepalive, when this is set the system
behaves as if SO_KEEPALIVE was set on all TCP sockets, forcing keepalives
to be sent every net.inet.tcp.keepidle half-seconds.

In conjunction with a keepidle value greatly reduced from the default,
this can be useful for keeping sessions open if you are stuck on a network
with short NAT or firewall timeouts.

Feedback from various people, ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.107 2011/04/28 09:56:27 claudio Exp $	*/
d189 5
a193 1
		/* WHAT IF TP IS 0? */
@


1.107
log
@Make in_broadcast() rdomain aware. Mostly mechanical change.
This fixes the problem of binding sockets to broadcast IPs in other
rdomains.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.106 2011/04/04 21:11:22 claudio Exp $	*/
d911 4
@


1.106
log
@Correctly inherit and set the watermarks on socketbuffers.
This fixes the NFS problems reported on the mailing list
and ensures that accepted sockets have correct socketbuffer
setting.  OK blambert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.105 2010/10/10 22:02:50 bluhm Exp $	*/
d291 2
a292 1
			    in_broadcast(sin->sin_addr, NULL)) {
@


1.105
log
@In tcp_update_sndspace() and tcp_update_rcvspace() change the type
of the variable nmax from int to u_long as the socket buffer sizes
it operates on are also u_long.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.104 2010/09/29 06:32:47 claudio Exp $	*/
d655 4
a658 10
	if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) {
		/* if low on memory only allow smaller then default buffers */
		if (so->so_snd.sb_wat == 0 ||
		    sbcheckreserve(so->so_snd.sb_wat, tcp_sendspace))
			so->so_snd.sb_wat = tcp_sendspace;
		if (so->so_rcv.sb_wat == 0 ||
		    sbcheckreserve(so->so_rcv.sb_wat, tcp_recvspace))
			so->so_rcv.sb_wat = tcp_recvspace;

		error = soreserve(so, so->so_snd.sb_wat, so->so_rcv.sb_wat);
@


1.104
log
@Fix a unfinished comment and add another one for tcp_update_(snd|rcv)space().
Reminded by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.103 2010/09/24 02:59:45 claudio Exp $	*/
d976 1
a976 1
	int nmax;
d1006 1
a1006 1
	int nmax = so->so_rcv.sb_hiwat;
@


1.103
log
@TCP send and recv buffer scaling.
Send buffer is scaled by not accounting unacknowledged on the wire
data against the buffer limit. Receive buffer scaling is done similar
to FreeBSD -- measure the delay * bandwith product and base the
buffer on that. The problem is that our RTT measurment is coarse
so it overshoots on low delay links. This does not matter that much
since the recvbuffer is almost always empty.
Add a back pressure mechanism to control the amount of memory
assigned to socketbuffers that kicks in when 80% of the cluster
pool is used.
Increases the download speed from 300kB/s to 4.4MB/s on ftp.eu.openbsd.org.

Based on work by markus@@ and djm@@.

OK dlg@@, henning@@, put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.102 2010/06/07 13:08:43 claudio Exp $	*/
d969 2
a970 1
 * In low memory situation shrink 
d996 6
@


1.102
log
@There is no reason to allow unicast IPv4 mapped IPv6 addresses in tcp
connect() calls. Our network stack does not allow any v4 mapped addresses
so there is no need to allow them in connect(). Found after discussion with
Henning. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.101 2010/04/20 22:05:43 tedu Exp $	*/
d122 1
d317 1
a317 1
		tcp_rscale(tp, so->so_rcv.sb_hiwat);
d656 9
a664 1
		error = soreserve(so, tcp_sendspace, tcp_recvspace);
d668 1
d962 58
@


1.101
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.100 2009/06/05 00:05:22 claudio Exp $	*/
d274 1
a274 4
			    (IN6_IS_ADDR_V4MAPPED(in6_addr) &&
			    ((in6_addr->s6_addr32[3] == INADDR_ANY) ||
			    IN_MULTICAST(in6_addr->s6_addr32[3]) ||
			    in_broadcast(sin->sin_addr, NULL)))) {
@


1.100
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.99 2008/05/24 19:48:32 thib Exp $	*/
d78 1
@


1.99
log
@Remove {tcp/udp}6_usrreq(); Since the normal ones now
take a proc argument, theres no need for these, since
they are just wrappers.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.98 2008/05/23 15:51:12 thib Exp $	*/
d767 1
a767 6
tcp_ident(oldp, oldlenp, newp, newlen, dodrop)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	int dodrop;
d828 1
a828 1
		    fin->sin_port, lin->sin_addr, lin->sin_port);
d853 1
a853 1
			    lin->sin_addr, lin->sin_port, 0, NULL);
@


1.98
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.97 2008/05/15 19:40:38 markus Exp $	*/
a126 13

#ifdef INET6
int
tcp6_usrreq(so, req, m, nam, control, p)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
	struct proc *p;
{

	return tcp_usrreq(so, req, m, nam, control, p);
}
#endif
@


1.97
log
@divert for ipv6; ok henning, pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.96 2008/05/09 02:44:54 markus Exp $	*/
d137 1
a137 1
	return tcp_usrreq(so, req, m, nam, control);
d148 1
a148 1
tcp_usrreq(so, req, m, nam, control)
d152 1
d243 1
a243 1
			error = in6_pcbbind(inp, nam);
d246 1
a246 1
			error = in_pcbbind(inp, nam);
d258 1
a258 1
				error = in6_pcbbind(inp, NULL);
d261 1
a261 1
				error = in_pcbbind(inp, NULL);
d295 1
a295 1
				error = in6_pcbbind(inp, NULL);
d311 1
a311 1
				error = in_pcbbind(inp, NULL);
@


1.96
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.95 2007/12/13 20:00:53 reyk Exp $	*/
d865 1
a865 1
			    &l6, lin6->sin6_port, 0);
@


1.95
log
@implement sysctls to report IP, TCP, UDP, and ICMP statistics and
change netstat to use them instead of accessing kvm for it. more
protocols will be added later.

discussed with deraadt@@ claudio@@ gilles@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.94 2007/11/27 17:23:23 deraadt Exp $	*/
d870 1
a870 1
			    lin->sin_addr, lin->sin_port, 0);
@


1.94
log
@TCP_COMPAT_42 was last used in 1997.  Kill it.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.93 2007/11/16 19:24:07 deraadt Exp $	*/
d957 7
@


1.93
log
@in the strange/unnatural/ridiculous situation where a non-blocking
connect() which has completed and failed.. if connect() is called
again.. return the so_error instead of EINVAL; from Alexey Vatchenko
matches what other systems do now
ok millert henning
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.92 2007/09/01 18:49:28 henning Exp $	*/
a335 4
#ifdef TCP_COMPAT_42
		tp->iss = tcp_iss;
		tcp_iss += TCP_ISSINCR/2;
#else  /* TCP_COMPAT_42 */
a336 1
#endif /* !TCP_COMPAT_42 */
@


1.92
log
@since the
MGET* macros were changed to function calls, there wasn't any
need for the pool declarations and the inclusion of pool.h
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.91 2007/06/25 12:17:43 markus Exp $	*/
d185 3
d195 1
a195 1
		return (EINVAL);		/* XXX */
@


1.91
log
@merge tcp_set_iss() and tcp_set_tsm(); ok mcbride, djm (on earlier version)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.90 2007/06/15 18:23:07 markus Exp $	*/
d81 1
@


1.90
log
@Drop the current random timestamps and the current ISN generation
code and replace both with a RFC1948 based method, so TCP clients
now have monotonic ISN/timestamps.  The server side uses completely
random ISN/timestamps and does time-wait recycling (on port reuse).
ok djm@@, mcbride@@; thanks to lots of testers
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.89 2005/03/04 13:21:42 markus Exp $	*/
a324 4
		/* initialise the timestamp modulator */
		if (tp->t_flags & TF_REQ_TSTMP)
			tcp_set_tsm(tp);

d336 1
a336 1
		tcp_set_iss(tp);
@


1.89
log
@- check th_ack against snd_una/max; from Raja Mukerji via hugh@@
- limit pool to tcp_sackhole_limit entries (sysctl-able)
- stop sack option processing on pool_get errors
- use SEQ_MIN/SEQ_MAX
ok henning, hshoexer, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.88 2005/02/22 17:28:49 mcbride Exp $	*/
d327 1
a327 1
			tp->ts_modulate = arc4random();
d340 1
a340 1
		tp->iss = tcp_rndiss_next();
@


1.88
log
@Move #ifdef INET6 outside of 'case AF_INET6:' in tcp_ident().
No functional change due to earlier check,
fix from  Maxim Konovalov <maxim@@macomnet.ru>

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.87 2004/10/28 19:22:52 mcbride Exp $	*/
d948 14
@


1.87
log
@Modulate tcp_now by a random amount on a per-connection basis.

ok markus@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.86 2004/07/15 15:27:22 markus Exp $	*/
d842 1
a843 1
#ifdef INET6
@


1.86
log
@tcp_trace() expects short, not int; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.85 2004/04/27 17:51:33 otto Exp $	*/
d82 2
d324 5
@


1.86.2.1
log
@MFC:
Fix by markus@@

- check th_ack against snd_una/max; from Raja Mukerji via hugh@@
- limit pool to tcp_sackhole_limit entries (sysctl-able)
- stop sack option processing on pool_get errors
- use SEQ_MIN/SEQ_MAX

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.86 2004/07/15 15:27:22 markus Exp $	*/
a940 14
#ifdef TCP_SACK
	case TCPCTL_SACKHOLE_LIMIT:
		nval = tcp_sackhole_limit;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nval);
		if (error)
			return (error);
		if (nval != tcp_sackhole_limit) {
			error = pool_sethardlimit(&sackhl_pool, nval, NULL, 0);
			if (error)
				return (error);
			tcp_sackhole_limit = nval;
		}
		return (0);
#endif
@


1.85
log
@Require NULL oldp when dropping a connection.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.84 2004/04/26 18:16:09 markus Exp $	*/
d155 1
a155 1
	int ostate;
@


1.84
log
@change tcpdrop to require newp instead of oldp; suggested by otto
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.83 2004/04/25 04:34:05 markus Exp $	*/
a792 4
	if (oldp == NULL)
		return (EINVAL);
	if (*oldlenp < sizeof(tir))
		return (ENOMEM);
d794 2
d803 4
@


1.83
log
@add TCPCTL_DROP; ok deraadt, cedric, grange, ...
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.82 2004/04/12 19:05:38 tedu Exp $	*/
a792 1

d795 2
a797 4
		/*
		 * XXX stupid permission hack:
		 * only root may set newp, so we require newp for tcp_drop()
		 */
d800 10
a809 6
	} else if (newp != NULL || newlen != 0)
		return (EINVAL);
	if  (*oldlenp < sizeof(tir))
		return (ENOMEM);
	if ((error = copyin(oldp, &tir, sizeof (tir))) != 0 )
		return (error);
@


1.82
log
@remove duplicate if.  from pedro martelletto, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.81 2004/03/02 12:51:12 markus Exp $	*/
d123 1
a123 1
int tcp_ident(void *, size_t *, void *, size_t);
d774 1
a774 1
 * Look up a socket for ident..
d777 1
a777 1
tcp_ident(oldp, oldlenp, newp, newlen)
d782 1
d787 1
d794 10
a803 1
	if (oldp == NULL || newp != NULL || newlen != 0)
d844 10
d916 5
a920 1
		return (tcp_ident(oldp, oldlenp, newp, newlen));
@


1.81
log
@limit total number of queued out-of-order packets to NMBCLUSTERS/2; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.80 2004/02/15 11:16:08 markus Exp $	*/
d179 1
a179 1
	 * structure will point at a subsidary (struct tcpcb).
a298 6
				error = EINVAL;
				break;
			}

			/* Trying to connect to some broadcast address */
			if (in_broadcast(sin->sin_addr, NULL)) {
@


1.81.2.1
log
@MFC:
Fix by markus@@

- check th_ack against snd_una/max; from Raja Mukerji via hugh@@
- limit pool to tcp_sackhole_limit entries (sysctl-able)
- stop sack option processing on pool_get errors
- use SEQ_MIN/SEQ_MAX

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.81 2004/03/02 12:51:12 markus Exp $	*/
a918 14
#ifdef TCP_SACK
	case TCPCTL_SACKHOLE_LIMIT:
		nval = tcp_sackhole_limit;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nval);
		if (error)
			return (error);
		if (nval != tcp_sackhole_limit) {
			error = pool_sethardlimit(&sackhl_pool, nval, NULL, 0);
			if (error)
				return (error);
			tcp_sackhole_limit = nval;
		}
		return (0);
#endif
@


1.80
log
@switch to sysctl_int_arr(); ok itojun, henning, miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.79 2004/01/31 21:09:15 henning Exp $	*/
d881 1
d907 12
@


1.79
log
@rename tcp sockopt TCP_SIGNATURE_ENABLE to TCP_MD5SIG
requested by theo
ok markus@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.78 2004/01/31 19:40:10 markus Exp $	*/
d110 11
a658 9
#ifndef TCP_SENDSPACE
#define	TCP_SENDSPACE	1024*16
#endif
u_int	tcp_sendspace = TCP_SENDSPACE;
#ifndef TCP_RECVSPACE
#define	TCP_RECVSPACE	1024*16
#endif
u_int	tcp_recvspace = TCP_RECVSPACE;

a886 3
	case TCPCTL_RFC1323:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_rfc1323));
a891 15
	case TCPCTL_MSSDFLT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_mssdflt));
	case TCPCTL_KEEPINITTIME:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcptv_keep_init));

	case TCPCTL_KEEPIDLE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_keepidle));

	case TCPCTL_KEEPINTVL:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_keepintvl));

a898 5
	case TCPCTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,&tcp_recvspace));

	case TCPCTL_SENDSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,&tcp_sendspace));
a900 6
	case TCPCTL_RSTPPSLIMIT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_rst_ppslim));
	case TCPCTL_ACK_ON_PUSH:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_ack_on_push));
a905 9
	case TCPCTL_SYN_CACHE_LIMIT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		   &tcp_syn_cache_limit));
	case TCPCTL_SYN_BUCKET_LIMIT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		   &tcp_syn_bucket_limit));
	case TCPCTL_RFC3390:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_rfc3390));
d907 3
@


1.78
log
@!sack_disable -> sack_enable; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.77 2004/01/30 11:33:32 henning Exp $	*/
d589 1
a589 1
		case TCP_SIGNATURE_ENABLE:
d634 1
a634 1
		case TCP_SIGNATURE_ENABLE:
@


1.77
log
@add support for getsockopt(..., TCP_SIGNATURE_ENABLE
so you can check wether a just accept()ed connection is md5sig'd

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.76 2004/01/29 11:55:28 markus Exp $	*/
d566 1
a566 1
		case TCP_SACK_DISABLE:
d583 1
a583 1
				tp->sack_disable = 1;
d585 1
a585 1
				tp->sack_disable = 0;
d603 1
a603 1
				tp->sack_disable = 1;
d629 2
a630 2
		case TCP_SACK_DISABLE:
			*mtod(m, int *) = tp->sack_disable;
@


1.76
log
@support for RFC3390 (Increasing TCP's Initial Window); ok deraadt, itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.75 2004/01/06 17:38:13 markus Exp $	*/
d631 5
@


1.75
log
@import netbsd's version of David Borman's syncache code
http://www.kohala.com/start/borman.97jun06.txt; ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.74 2003/12/10 07:22:43 itojun Exp $	*/
d934 3
@


1.74
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.73 2003/12/08 07:07:36 mcbride Exp $	*/
d928 6
@


1.73
log
@Mbuf tag tcp and udp packets which are translated to localhost, and
use the the presence of this tag to reverse the match order in
in{6}_pcblookup_listen(). Some daemons (such as portmap) do a double
bind, binding to both * and localhost in order to differentiate local
from non-local connections, and potentially granting more privilege to
local ones. This change ensures that redirected connections to localhost
do not appear local to such a daemon.

Bulk of changes from dhartmei@@, some changes markus@@

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.72 2003/11/04 21:43:16 markus Exp $	*/
d140 2
a141 2
	register struct inpcb *inp;
	register struct tcpcb *tp = NULL;
d501 3
a503 3
	register struct tcpcb *tp;
	register struct mbuf *m;
	register int i;
d661 1
a661 1
	register struct tcpcb *tp;
d706 1
a706 1
	register struct tcpcb *tp;
d736 1
a736 1
	register struct tcpcb *tp;
@


1.72
log
@add in(6)_pcblookup_listen() and replace all calls to in_pcblookup()
with either in(6)_pcbhashlookup() or in(6)_pcblookup_listen();
in_pcblookup is now only used by bind(2); speeds up pcb lookup for
listening sockets; from Claudio Jeker
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.71 2003/06/09 07:40:25 itojun Exp $	*/
d838 1
a838 1
			    &l6, lin6->sin6_port);
d843 1
a843 1
			    lin->sin_addr, lin->sin_port);
@


1.71
log
@backout following:
>use m_pulldown not m_pullup2.  fix some bugs in IPv6 tcp_trace().

PR 3283 fixed (confirmed)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.70 2003/06/02 23:28:15 millert Exp $	*/
d837 2
a838 3
			inp = in_pcblookup(&tcbtable, &f6,
			    fin6->sin6_port, &l6, lin6->sin6_port,
			    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6);
d842 2
a843 3
			inp = in_pcblookup(&tcbtable, &fin->sin_addr,
			    fin->sin_port, &lin->sin_addr, lin->sin_port,
			    INPLOOKUP_WILDCARD);
@


1.71.2.1
log
@MFC:
Fix by markus@@

limit total number of queued out-of-order packets to NMBCLUSTERS/2;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.71 2003/06/09 07:40:25 itojun Exp $	*/
a875 1
	int error, nval;
a929 12
	case TCPCTL_REASS_LIMIT:
		nval = tcp_reass_limit;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nval);
		if (error)
			return (error);
		if (nval != tcp_reass_limit) {
			error = pool_sethardlimit(&tcpqe_pool, nval, NULL, 0);
			if (error)
				return (error);
			tcp_reass_limit = nval;
		}
		return (0);
@


1.70
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.69 2003/05/29 00:35:18 itojun Exp $	*/
d487 1
a487 1
		tcp_trace(TA_USER, ostate, tp, NULL, req, 0);
@


1.69
log
@use m_pulldown not m_pullup2.  fix some bugs in IPv6 tcp_trace().
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.68 2003/02/12 14:41:08 jason Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.68
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.67 2002/09/11 03:15:36 itojun Exp $	*/
d491 1
a491 1
		tcp_trace(TA_USER, ostate, tp, (caddr_t)0, req, 0);
@


1.68.2.1
log
@MFC:
Fix by markus@@

limit total number of queued out-of-order packets to NMBCLUSTERS/2;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.68 2003/02/12 14:41:08 jason Exp $	*/
a879 1
	int error, nval;
a933 12
	case TCPCTL_REASS_LIMIT:
		nval = tcp_reass_limit;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nval);
		if (error)
			return (error);
		if (nval != tcp_reass_limit) {
			error = pool_sethardlimit(&tcpqe_pool, nval, NULL, 0);
			if (error)
				return (error);
			tcp_reass_limit = nval;
		}
		return (0);
@


1.67
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.66 2002/08/08 19:18:13 provos Exp $	*/
d113 2
@


1.66
log
@redo socketbuf speedup.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.64 2002/08/08 17:07:32 provos Exp $	*/
d817 1
a817 1
		return(EINVAL);
@


1.65
log
@backout the tree break. ok pb@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.63 2002/06/09 16:26:11 itojun Exp $	*/
d412 1
a412 1
		sbappend(&so->so_snd, m);
d460 1
a460 1
		sbappend(&so->so_snd, m);
@


1.64
log
@socket buf speedup from thorpej@@netbsd, okay art@@ ericj@@:

Make insertion of data into socket buffers O(C):
* Keep pointers to the first and last mbufs of the last record in the
  socket buffer.
* Use the sb_lastrecord pointer in the sbappend*() family of functions
  to avoid traversing the packet chain to find the last record.
* Add a new sbappend_stream() function for stream protocols which
  guarantee that there will never be more than one record in the
  socket buffer.  This function uses the sb_mbtail pointer to perform
  the data insertion.  Make TCP use sbappend_stream(). On a profiling
run, this makes sbappend of a TCP transmission using
a 1M socket buffer go from 50% of the time to .02% of the time. Thanks
to Bill Sommerfeld and YAMAMOTO Takashi for their debugging
assistance!
@
text
@d412 1
a412 1
		sbappendstream(&so->so_snd, m);
d460 1
a460 1
		sbappendstream(&so->so_snd, m);
@


1.63
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.62 2002/06/07 16:18:02 itojun Exp $	*/
d412 1
a412 1
		sbappend(&so->so_snd, m);
d460 1
a460 1
		sbappend(&so->so_snd, m);
@


1.62
log
@avoid is_ipv6 construct.  a step towards IPv4-less kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.61 2002/05/26 15:27:07 fgsch Exp $	*/
d611 1
a611 1
 		default:
@


1.61
log
@remove extra spaces, tabs, and semicolon.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.60 2002/05/16 14:10:51 kjc Exp $	*/
a784 1
	int is_ipv6 = 0;
a801 1
		is_ipv6 = 1;
d821 2
a822 1
	if (is_ipv6) {
d826 1
a826 2
#else
		panic("tcp_ident: cannot happen");
d828 1
a828 2
	}
	else
d831 2
d836 1
a836 1
		if (is_ipv6) {
d838 1
d842 1
a842 2
#else
			panic("tcp_ident: cannot happen");
d844 1
a844 2
		}
		else
d848 2
@


1.60
log
@bring in ECN support from KAME.
it consists of
 - ECN support in TCP
 - tunnel-egress and fragment reassembly rules in layer-3 not to lose
   congestion info at tunnel-egress and fragment reassembly

to enable ECN in TCP, build a kernel with TCP_ECN, and then,
turn it on by "sysctl -w net.inet.tcp.ecn=1".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.59 2002/03/14 01:27:11 millert Exp $	*/
d37 1
a37 1
 * 
d41 1
a41 1
 * 
d56 1
a56 1
 * 
d68 1
a68 1
 * 
d325 1
a325 1
		TCP_TIMER_ARM(tp, TCPT_KEEP, tcptv_keep_init);	
d646 1
a646 1
#define	TCP_SENDSPACE	1024*16;
d650 1
a650 1
#define	TCP_RECVSPACE	1024*16;
d831 2
a832 2
	else 
		inp = in_pcbhashlookup(&tcbtable,  fin->sin_addr, 
d848 1
a848 1
			    fin->sin_port, &lin->sin_addr, lin->sin_port, 
d850 1
a850 1
	}	
@


1.59
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.58 2002/03/08 03:49:58 provos Exp $	*/
d927 5
@


1.58
log
@use timeout(9) to schedule TCP timers.  this avoid traversing all
tcp connections during tcp_slowtimo.  apdapted from thorpej@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.57 2002/03/02 00:44:52 provos Exp $	*/
d114 1
a114 1
int tcp_ident __P((void *, size_t *, void *, size_t));
@


1.57
log
@disable immediate ack on TH_PUSH.  make behaviour sysctl tuneable.
from netbsd; also fix a bug where setting TF_ACKNOW didn't actually
result in an ack.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.56 2002/02/15 20:45:32 nordin Exp $	*/
d84 1
a482 9
		break;

	/*
	 * TCP slow timer went off; going through this
	 * routine for tracing's sake.
	 */
	case PRU_SLOWTIMO:
		tp = tcp_timers(tp, (long)nam);
		req |= (long)nam << 8;		/* for debug's sake */
@


1.56
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.55 2002/01/14 03:11:55 provos Exp $	*/
d932 3
@


1.55
log
@use macros to manage tcp timers; based on netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.53 2001/06/08 03:53:47 angelos Exp $	*/
d424 1
a424 1
		(void) splx(s);
@


1.54
log
@Restore inclusion of <sys/systm.h>.
@
text
@d324 1
a324 1
		tp->t_timer[TCPT_KEEP] = tcptv_keep_init;	
d777 1
a777 1
			tp->t_timer[TCPT_2MSL] = tcp_maxidle;
@


1.54.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.55 2002/01/14 03:11:55 provos Exp $	*/
d324 1
a324 1
		TCP_TIMER_ARM(tp, TCPT_KEEP, tcptv_keep_init);	
d777 1
a777 1
			TCP_TIMER_ARM(tp, TCPT_2MSL, tcp_maxidle);
@


1.54.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.54.4.1 2002/01/31 22:55:46 niklas Exp $	*/
d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
a83 1
#include <sys/kernel.h>
d113 1
a113 1
int tcp_ident(void *, size_t *, void *, size_t);
d324 1
a324 1
		TCP_TIMER_ARM(tp, TCPT_KEEP, tcptv_keep_init);
d424 1
a424 1
		splx(s);
d484 9
d654 1
a654 1
#define	TCP_SENDSPACE	1024*16
d658 1
a658 1
#define	TCP_RECVSPACE	1024*16
d793 1
d811 1
d831 1
a831 2
	switch (tir.faddr.ss_family) {
	case AF_INET6:
d835 2
a836 1
		break;
d838 3
a840 2
	case AF_INET:
		inp = in_pcbhashlookup(&tcbtable,  fin->sin_addr,
a841 2
		break;
	}
d845 1
a845 1
		switch (tir.faddr.ss_family) {
a846 1
		case AF_INET6:
d850 2
a851 1
			break;
d853 2
a854 1
		case AF_INET:
d856 1
a856 1
			    fin->sin_port, &lin->sin_addr, lin->sin_port,
d858 1
a858 3
			break;
		}
	}
a931 8
	case TCPCTL_ACK_ON_PUSH:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_ack_on_push));
#ifdef TCP_ECN
	case TCPCTL_ECN:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		   &tcp_do_ecn));
#endif
@


1.54.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.54.4.2 2002/06/11 03:31:37 art Exp $	*/
d412 1
a412 1
		sbappendstream(&so->so_snd, m);
d460 1
a460 1
		sbappendstream(&so->so_snd, m);
d611 1
a611 1
		default:
d817 1
a817 1
		return (EINVAL);
@


1.54.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a112 2

struct	inpcbtable tcbtable;
@


1.53
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.52 2001/06/05 02:31:37 deraadt Exp $	*/
d76 1
@


1.52
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.51 2001/05/27 03:14:19 angelos Exp $	*/
a75 3
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
a79 1
#include <sys/errno.h>
a80 3
#include <sys/proc.h>
#include <sys/ucred.h>
#include <vm/vm.h>
a99 1
#include <dev/rndvar.h>
@


1.51
log
@Remove unnecessary XXX comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.50 2000/12/13 09:47:08 provos Exp $	*/
d36 37
a72 1
 *	@@(#)tcp_usrreq.c	8.2 (Berkeley) 1/3/94
a73 12

/*
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.50
log
@more random tcp sequence numbers. okay deraadt@@, angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.49 2000/12/11 08:04:56 itojun Exp $	*/
a393 3
#ifdef IPSEC
	    /* XXX Find IPsec TDB */
#endif
@


1.49
log
@nuke #ifdef TCP6 (no longer supported).
validate ICMPv6 too big messages (pmtud) based on pcb.  we accept
certain amount of non-validated ones, as IPv6 mandates ICMPv6 (so even for
traffic from unconnected pcb, we need pmtud).
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.48 2000/10/14 01:04:11 itojun Exp $	*/
d307 2
a308 1
		tp->t_timer[TCPT_KEEP] = tcptv_keep_init;
a309 1
#ifdef TCP_COMPAT_42
d311 2
a312 2
#else /* TCP_COMPAT_42 */
		tcp_iss += arc4random() % TCP_ISSINCR + 1;
@


1.48
log
@implement net.inet.tcp.rstppslimit.  rate-limits outbound TCP RST traffic
to less than N per 1 second.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.47 2000/09/19 03:20:59 angelos Exp $	*/
d98 1
a98 1
#if defined(INET6) && !defined(TCP6)
d106 1
@


1.47
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.46 2000/07/11 16:53:22 provos Exp $	*/
d91 2
d914 3
@


1.46
log
@compute correct window scale when recvpipe option is set in route; based
on diff from "Pete Kazmier" <pete@@kazmier.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.45 2000/07/06 05:24:45 itojun Exp $	*/
a84 4
#ifdef IPSEC
extern int	check_ipsec_policy __P((struct inpcb *, u_int32_t));
#endif

d392 1
a392 3
		error = check_ipsec_policy(inp, 0);
		if (error)
			break;
@


1.45
log
@completely remove ipv4 mapped cases from tcp_input().
cleanup (indentation, v4-or-v6 conditions)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.44 2000/07/05 22:51:10 itojun Exp $	*/
d303 2
a304 3
		while (tp->request_r_scale < TCP_MAX_WINSHIFT &&
		    (TCP_MAXWIN << tp->request_r_scale) < so->so_rcv.sb_hiwat)
			tp->request_r_scale++;
@


1.44
log
@more cleanup for IPv4 mapped address support.  there seem to be some
inconsistency in corner cases (from NRL I believe).
todd (fries) and I have seen panic, with the following call chain:
ip6_input -> tcp_input -> tcp_respond -> ip_input -> bang!

more cleanups should be done, to decrease complexity.
for example, INP_IPV6_MAPPED should be nuked.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.43 2000/06/18 15:13:33 deraadt Exp $	*/
a215 14
#if 0 /*INET6*/
		/*
		 * If we bind to an address, set up the tp->pf accordingly!
		 */
		if (inp->inp_flags & INP_IPV6) {
			/* If a PF_INET6 socket... */
			if (inp->inp_flags & INP_IPV6_MAPPED)
				tp->pf = AF_INET;
			else if ((inp->inp_flags & INP_IPV6_UNDEC) == 0)
				tp->pf = AF_INET6;
			/* else tp->pf is still 0. */
		}
		/* else socket is PF_INET, and tp->pf is PF_INET. */
#endif /* INET6 */
a293 14
#if 0 /*INET6*/
		/*
		 * With a connection, I now know the version of IP
		 * is in use and hence can set tp->pf with authority. 
		 */
		if (inp->inp_flags & INP_IPV6) {
			if (inp->inp_flags & INP_IPV6_MAPPED)
				tp->pf = PF_INET;
			else
				tp->pf = PF_INET6;
		}
		/* else I'm a PF_INET socket, and hence tp->pf is PF_INET. */
#endif /* INET6 */

a299 7

#if 0 /*INET6*/
		if ((inp->inp_flags & INP_IPV6) && (tp->pf == PF_INET)) {
			inp->inp_ip.ip_ttl = ip_defttl;
			inp->inp_ip.ip_tos = 0;
		}
#endif /* INET6 */
@


1.43
log
@permit compilation of non-V6 kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.42 2000/06/18 04:42:43 beck Exp $	*/
d216 1
a216 1
#ifdef INET6
d308 1
a308 1
#ifdef INET6
d329 1
a329 1
#ifdef INET6
d719 9
@


1.42
log
@support ipv6 for tcp_ident
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.41 2000/06/18 02:02:01 itojun Exp $	*/
d65 1
a87 4

#ifdef INET6
#include <sys/domain.h>
#endif /* INET6 */
@


1.41
log
@for setsockopt/getsockopt, don't assume non-PF_INET6 address family as
PF_INET.  we may see other family in the future...  (pedant)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.40 2000/06/03 13:04:39 itojun Exp $	*/
d812 1
d816 4
d827 21
a847 5
	if (tir.faddr.sa_len != sizeof (struct sockaddr) ||
	    tir.faddr.sa_family != AF_INET)
		return (EINVAL);
	fin = (struct sockaddr_in *)&tir.faddr;
	lin = (struct sockaddr_in *)&tir.laddr;
d850 12
a861 2
	inp = in_pcbhashlookup(&tcbtable,  fin->sin_addr, fin->sin_port,
	    lin->sin_addr, lin->sin_port);
d864 15
a878 3
		inp = in_pcblookup(&tcbtable, &fin->sin_addr, fin->sin_port,
		    &lin->sin_addr, lin->sin_port, 0);
	}
@


1.40
log
@correctly handle ctlinput messages for IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.36 1999/09/01 21:38:21 provos Exp $	*/
d555 1
d557 1
a557 1
		if (so->so_proto->pr_domain->dom_family == PF_INET6)
d559 1
a559 1
		else
d561 1
d563 5
@


1.39
log
@option TCP_NEWRENO goes away, its the default case for TCP_SACK if
SACK is disabled for the connection or via sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.38 1999/12/20 16:06:25 itojun Exp $	*/
d418 9
a426 1
		(void) tcp_output(tp);
@


1.39.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.50 2000/12/13 09:47:08 provos Exp $	*/
a64 1
#include <sys/domain.h>
d84 8
a97 2
extern int tcp_rst_ppslim;

d103 1
a103 1
#ifdef INET6
a110 1

d219 14
d311 14
d332 7
d341 3
a343 2
		tcp_rscale(tp, so->so_rcv.sb_hiwat);

d347 2
a348 1
		tp->t_timer[TCPT_KEEP] = tcptv_keep_init;	
a349 1
		tp->iss = tcp_iss;
d351 2
a352 2
#else  /* TCP_COMPAT_42 */
		tp->iss = tcp_rndiss_next();
d418 1
a418 9
		/*
		 * soreceive() calls this function when a user receives
		 * ancillary data on a listening socket. We don't call
		 * tcp_output in such a case, since there is no header
		 * template for a listening socket and hence the kernel
		 * will panic.
		 */
		if ((so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING)) != 0)
			(void) tcp_output(tp);
d427 3
a429 1
	    /* XXX Find IPsec TDB */
a546 1
		switch (so->so_proto->pr_domain->dom_family) {
d548 1
a548 1
		case PF_INET6:
d550 1
a550 1
			break;
a551 1
		case PF_INET:
a552 5
			break;
		default:
			error = EAFNOSUPPORT;	/*?*/
			break;
		}
a706 9
#ifdef INET6
	/* we disallow IPv4 mapped address completely. */
	if (inp->inp_flags & INP_IPV6)
		tp->pf = PF_INET6;
	else
		tp->pf = PF_INET;
#else
	tp->pf = PF_INET;
#endif
a796 1
	int is_ipv6 = 0;
a799 4
#ifdef INET6
	struct sockaddr_in6 *fin6, *lin6;
	struct in6_addr f6, l6;
#endif
d807 5
a811 21
	switch (tir.faddr.ss_family) {
#ifdef INET6
	case AF_INET6:
		is_ipv6 = 1;
		fin6 = (struct sockaddr_in6 *)&tir.faddr;
		error = in6_embedscope(&f6, fin6, NULL, NULL);
		if (error)
			return EINVAL;	/*?*/
		lin6 = (struct sockaddr_in6 *)&tir.laddr;
		error = in6_embedscope(&l6, lin6, NULL, NULL);
		if (error)
			return EINVAL;	/*?*/
		break;
#endif
	case AF_INET:
	  	fin = (struct sockaddr_in *)&tir.faddr;
		lin = (struct sockaddr_in *)&tir.laddr;
		break;
	default:
		return(EINVAL);
	}
d814 2
a815 12
	if (is_ipv6) {
#ifdef INET6
		inp = in6_pcbhashlookup(&tcbtable, &f6,
		    fin6->sin6_port, &l6, lin6->sin6_port);
#else
		panic("tcp_ident: cannot happen");
#endif
	}
	else 
		inp = in_pcbhashlookup(&tcbtable,  fin->sin_addr, 
		    fin->sin_port, lin->sin_addr, lin->sin_port);

d818 3
a820 15
		if (is_ipv6) {
#ifdef INET6
			inp = in_pcblookup(&tcbtable, &f6,
			    fin6->sin6_port, &l6, lin6->sin6_port,
			    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6);
#else
			panic("tcp_ident: cannot happen");
#endif
		}
		else
			inp = in_pcblookup(&tcbtable, &fin->sin_addr,
			    fin->sin_port, &lin->sin_addr, lin->sin_port, 
			    INPLOOKUP_WILDCARD);
	}	

a889 3
	case TCPCTL_RSTPPSLIMIT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_rst_ppslim));
@


1.39.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.39.2.1 2001/05/14 22:40:15 niklas Exp $	*/
d36 1
a36 37
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
d39 12
d53 2
d59 1
d61 3
d83 1
d394 3
@


1.39.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d324 1
a324 1
		TCP_TIMER_ARM(tp, TCPT_KEEP, tcptv_keep_init);	
d424 1
a424 1
		splx(s);
d777 1
a777 1
			TCP_TIMER_ARM(tp, TCPT_2MSL, tcp_maxidle);
a931 3
	case TCPCTL_ACK_ON_PUSH:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_ack_on_push));
@


1.39.2.4
log
@Merge in -current from roughly a week ago
@
text
@a83 1
#include <sys/kernel.h>
d113 1
a113 1
int tcp_ident(void *, size_t *, void *, size_t);
d482 9
@


1.39.2.5
log
@Sync the SMP branch with 3.3
@
text
@d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
a113 2
struct	inpcbtable tcbtable;

d325 1
a325 1
		TCP_TIMER_ARM(tp, TCPT_KEEP, tcptv_keep_init);
d412 1
a412 1
		sbappendstream(&so->so_snd, m);
d460 1
a460 1
		sbappendstream(&so->so_snd, m);
d611 1
a611 1
		default:
d646 1
a646 1
#define	TCP_SENDSPACE	1024*16
d650 1
a650 1
#define	TCP_RECVSPACE	1024*16
d785 1
d803 1
d819 1
a819 1
		return (EINVAL);
d823 1
a823 2
	switch (tir.faddr.ss_family) {
	case AF_INET6:
d827 2
a828 1
		break;
d830 3
a832 2
	case AF_INET:
		inp = in_pcbhashlookup(&tcbtable,  fin->sin_addr,
a833 2
		break;
	}
d837 1
a837 1
		switch (tir.faddr.ss_family) {
a838 1
		case AF_INET6:
d842 2
a843 1
			break;
d845 2
a846 1
		case AF_INET:
d848 1
a848 1
			    fin->sin_port, &lin->sin_addr, lin->sin_port,
d850 1
a850 3
			break;
		}
	}
a926 5
#ifdef TCP_ECN
	case TCPCTL_ECN:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		   &tcp_do_ecn));
#endif
@


1.39.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.39.2.5 2003/03/28 00:06:55 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d491 1
a491 1
		tcp_trace(TA_USER, ostate, tp, NULL, req, 0);
@


1.39.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d140 2
a141 2
	struct inpcb *inp;
	struct tcpcb *tp = NULL;
d487 1
a487 1
		tcp_trace(TA_USER, ostate, tp, (caddr_t)0, req, 0);
d501 3
a503 3
	struct tcpcb *tp;
	struct mbuf *m;
	int i;
d566 1
a566 1
		case TCP_SACK_ENABLE:
d583 1
a583 1
				tp->sack_enable = 1;
d585 1
a585 1
				tp->sack_enable = 0;
d589 1
a589 1
		case TCP_MD5SIG:
d603 1
a603 1
				tp->sack_enable = 0;
d629 2
a630 7
		case TCP_SACK_ENABLE:
			*mtod(m, int *) = tp->sack_enable;
			break;
#endif
#ifdef TCP_SIGNATURE
		case TCP_MD5SIG:
			*mtod(m, int *) = tp->t_flags & TF_SIGNATURE;
d661 1
a661 1
	struct tcpcb *tp;
d706 1
a706 1
	struct tcpcb *tp;
d736 1
a736 1
	struct tcpcb *tp;
d837 3
a839 2
			inp = in6_pcblookup_listen(&tcbtable,
			    &l6, lin6->sin6_port, 0);
d843 3
a845 2
			inp = in_pcblookup_listen(&tcbtable, 
			    lin->sin_addr, lin->sin_port, 0);
a929 9
	case TCPCTL_SYN_CACHE_LIMIT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		   &tcp_syn_cache_limit));
	case TCPCTL_SYN_BUCKET_LIMIT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		   &tcp_syn_bucket_limit));
	case TCPCTL_RFC3390:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &tcp_do_rfc3390));
@


1.39.2.8
log
@Merge with the trunk
@
text
@a109 11
#ifndef TCP_SENDSPACE
#define	TCP_SENDSPACE	1024*16
#endif
u_int	tcp_sendspace = TCP_SENDSPACE;
#ifndef TCP_RECVSPACE
#define	TCP_RECVSPACE	1024*16
#endif
u_int	tcp_recvspace = TCP_RECVSPACE;

int *tcpctl_vars[TCPCTL_MAXID] = TCPCTL_VARS;

d112 1
a112 1
int tcp_ident(void *, size_t *, void *, size_t, int);
d168 1
a168 1
	 * structure will point at a subsidiary (struct tcpcb).
d292 6
d648 9
d778 1
a778 1
 * Look up a socket for ident or tcpdrop, ...
d781 1
a781 1
tcp_ident(oldp, oldlenp, newp, newlen, dodrop)
a785 1
	int dodrop;
a789 1
	struct tcpcb *tp = NULL;
d795 7
a801 19
	if (dodrop) {
		if (oldp != NULL || *oldlenp != 0)
			return (EINVAL);
		if (newp == NULL)
			return (EPERM);
		if (newlen < sizeof(tir))
			return (ENOMEM);
		if ((error = copyin(newp, &tir, sizeof (tir))) != 0 )
			return (error);
	} else {
		if (oldp == NULL)
			return (EINVAL);
		if (*oldlenp < sizeof(tir))
			return (ENOMEM);
		if (newp != NULL || newlen != 0)
			return (EINVAL);
		if ((error = copyin(oldp, &tir, sizeof (tir))) != 0 )
			return (error);
	}
a836 10
	if (dodrop) {
		if (inp && (tp = intotcpcb(inp)) &&
		    ((inp->inp_socket->so_options & SO_ACCEPTCONN) == 0))
			tp = tcp_drop(tp, ECONNABORTED);
		else
			error = ESRCH;
		splx(s);
		return (error);
	}

a878 1
	int error, nval;
d885 3
d893 15
d915 5
d921 7
a927 5
		return (tcp_ident(oldp, oldlenp, newp, newlen, 0));

	case TCPCTL_DROP:
		return (tcp_ident(oldp, oldlenp, newp, newlen, 1));

d933 9
a941 12
	case TCPCTL_REASS_LIMIT:
		nval = tcp_reass_limit;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nval);
		if (error)
			return (error);
		if (nval != tcp_reass_limit) {
			error = pool_sethardlimit(&tcpqe_pool, nval, NULL, 0);
			if (error)
				return (error);
			tcp_reass_limit = nval;
		}
		return (0);
a942 3
		if (name[0] < TCPCTL_MAXID)
			return (sysctl_int_arr(tcpctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
@


1.38
log
@decide address family for {set,get}sockopt() by domain table,
not from tcb.

it will present more natural behavior.
af for socket option obeys address family passed to bind(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.37 1999/12/08 06:50:20 itojun Exp $	*/
d355 1
a355 1
#if defined(TCP_SACK) || defined(TCP_NEWRENO)
@


1.37
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.36 1999/09/01 21:38:21 provos Exp $	*/
d548 1
a548 7
		/*
		 * Not sure if this is the best approach.
		 * It seems to be, but we don't set tp->pf until the connection
		 * is established, which may lead to confusion in the case of
		 * AF_INET6 sockets which get SET/GET options for IPv4.
		 */
		if (tp->pf == PF_INET6)
@


1.36
log
@increase tcp_iss increment
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.35 1999/07/06 20:17:53 cmetz Exp $	*/
d103 12
d211 6
a216 1
		error = in_pcbbind(inp, nam);
d239 8
a246 2
		if (inp->inp_lport == 0)
			error = in_pcbbind(inp, NULL);
d277 7
d286 1
d294 12
a305 4
		/* Trying to connect to some broadcast address */
		if (in_broadcast(sin->sin_addr, NULL)) {
			error = EINVAL;
			break;
a307 6
		if (inp->inp_lport == 0) {
			error = in_pcbbind(inp, NULL);
			if (error)
				break;
		}
		error = in_pcbconnect(inp, nam);
d394 6
a399 1
		in_setpeeraddr(inp, nam);
d487 6
a492 1
		in_setsockaddr(inp, nam);
d496 6
a501 1
		in_setpeeraddr(inp, nam);
d555 1
a555 1
			error = ipv6_ctloutput(op, so, level, optname, mp);
@


1.35
log
@Added support for TCP MD5 option (RFC 2385).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.34 1999/07/02 20:39:08 cmetz Exp $	*/
d319 1
a319 1
		tcp_iss += arc4random() % (TCP_ISSINCR / 2) + 1;
@


1.34
log
@Significant cleanups in the way TCP is made to handle multiple network
protocols.

"struct tcpiphdr" is now gone from much of the code, as are separate pointers
for ti and ti6. The result is fewer variables, which is generally a good thing.

Simple if(is_ipv6) ... else ... tests are gone in favor of a
switch(protocol family), which allows future new protocols to be added easily.
This also makes it possible for someone so inclined to re-implement TUBA (TCP
over CLNP?) and do it right instead of the kluged way it was done in 4.4.

The TCP header template is now referenced through a mbuf rather than done
through a data pointer and dtom()ed as needed. This is partly because dtom() is
evil and partly because max_linkhdr + IPv6 + TCP + MSS/TS/SACK opts won't fit
inside a packet header mbuf, so we need to grab a cluster for that (which the
code now does, if needed).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.33 1999/03/24 02:28:21 cmetz Exp $	*/
d558 5
d569 22
a590 1
		default:
@


1.33
log
@Replace 'in6a_words' (old NRL convention) with 's6_addr32' (new BSDI et al.
convention that is more common and more specific as to the access size)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.32 1999/01/11 02:01:36 deraadt Exp $	*/
d469 1
a469 1
		tcp_trace(TA_USER, ostate, tp, (struct tcpiphdr *)0, req, 0);
d534 7
a540 1
			if (m && (i = *mtod(m, int *)) > 0 && i <= tp->t_maxseg)
d548 14
a561 2
			i = *mtod(m, int *);
			tp->sack_disable = i;
@


1.32
log
@netinet merge of NRL stuff. some indent and shrinkage needed; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.31 1999/01/07 06:05:05 deraadt Exp $	*/
d248 2
a249 2
			    ((in6_addr->in6a_words[3] == INADDR_ANY) ||
			    IN_MULTICAST(in6_addr->in6a_words[3]) ||
@


1.31
log
@in_pcblookup() now takes ptr to both ip address arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.29 1998/11/17 19:23:02 provos Exp $	*/
d39 12
d88 4
d122 10
a131 3
	if (req == PRU_CONTROL)
		return (in_control(so, (u_long)m, (caddr_t)nam,
			(struct ifnet *)control));
d202 14
d224 2
d240 22
a261 5
		/* Disallow connects to a multicast address */
		if (IN_MULTICAST(sin->sin_addr.s_addr)) {
			error = EINVAL;
			break;
		}
d278 14
d298 8
d469 1
a469 1
		tcp_trace(TA_USER, ostate, tp, (struct tcpiphdr *)0, req);
d495 3
d499 12
a510 1
		error = ip_ctloutput(op, so, level, optname, mp);
d514 1
d516 1
@


1.30
log
@indent
@
text
@d638 2
a639 2
		inp = in_pcblookup(&tcbtable, fin->sin_addr, fin->sin_port,
		    lin->sin_addr, lin->sin_port, 0);
@


1.29
log
@NewReno, SACK and FACK support for TCP, adapted from code for BSDI
by Hari Balakrishnan (hari@@lcs.mit.edu), Tom Henderson (tomh@@cs.berkeley.edu)
and Venkat Padmanabhan (padmanab@@cs.berkeley.edu) as part of the
Daedalus research group at the University of California,
(http://daedalus.cs.berkeley.edu). [I was able to do this on time spent
at the Center for Information Technology Integration (citi.umich.edu)]
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.28 1998/06/27 02:42:41 deraadt Exp $	*/
d625 1
a625 1
	if ((error = copyin (oldp, &tir, sizeof (tir))) != 0 )
d633 2
a634 2
	s = splsoftnet ();
	inp = in_pcbhashlookup (&tcbtable,  fin->sin_addr, fin->sin_port,
d638 1
a638 1
		inp = in_pcblookup (&tcbtable, fin->sin_addr, fin->sin_port,
d651 1
a651 1
	error = copyout ((void *)&tir, oldp, sizeof (tir));
@


1.28
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.27 1998/06/27 02:31:58 deraadt Exp $	*/
d244 8
d446 6
d471 5
d676 8
a683 1

@


1.27
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.26 1998/06/27 02:09:46 angelos Exp $	*/
d73 1
a73 1
extern int     	check_ipsec_policy  __P((struct inpcb *, u_int32_t));
d683 1
a683 1
	        return (tcp_ident(oldp, oldlenp, newp, newlen));
@


1.26
log
@Disallow TCP connect() to multicast addresses; cmetz@@inner.net
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.25 1998/06/26 18:07:30 deraadt Exp $	*/
d202 1
a202 2
		if (IN_MULTICAST(sin->sin_addr.s_addr))
		{
@


1.25
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.24 1998/06/11 16:47:17 deraadt Exp $	*/
d200 7
@


1.24
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.23 1998/06/10 06:24:48 deraadt Exp $	*/
d202 1
a202 2
		if (in_broadcast(sin->sin_addr, NULL))
		{
@


1.23
log
@wasteland quality control cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.22 1998/06/10 03:40:07 beck Exp $	*/
d85 1
a85 1
static int tcp_ident __P((void *, size_t *, void *,	size_t));
d583 1
a583 1
 * Look up a socket for ident.. 
d585 1
a585 2

static int
a595 1
	
d597 1
a597 1
	if (oldp == NULL || newp != NULL || newlen != 0) 
d599 1
a599 1
	if  (*oldlenp < sizeof(tir)) 
d603 6
a608 7
	if (tir.faddr.sa_len != sizeof (struct sockaddr) 
	    || (tir.faddr.sa_family != AF_INET))    
		return (EINVAL); 
	fin = (struct sockaddr_in *) &tir.faddr;
	lin = (struct sockaddr_in *) &tir.laddr;
	
	
a629 1
  
d677 1
a677 1
	case TCPCTL_IDENT: 
@


1.22
log
@New TCPCTL_IDENT sysctl for identd without kmem insanity.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.20 1998/02/28 03:39:58 angelos Exp $	*/
d594 1
a594 1
	tcp_ident_mapping tir;
@


1.21
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d85 2
d583 53
d681 2
a682 1

@


1.20
log
@Another shot at disallowing TCP connections to 255.255.255.255,
0.0.0.0 and any local broadcast addresses. Tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.19 1998/02/25 03:45:15 angelos Exp $	*/
d72 4
d295 5
@


1.19
log
@patch could not have been tested. panics machine on boot
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.16 1998/01/24 18:21:39 mickey Exp $	*/
d93 1
d193 9
d210 1
@


1.18
log
@please indent as the file is currently indented
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.17 1998/02/25 03:45:15 angelos Exp $	*/
a92 1
	struct sockaddr_in *sin = mtod(nam, struct sockaddr_in *);
a191 6
		/* Trying to connect to some broadcast address */
		if (in_broadcast(sin->sin_addr, NULL)) {
			error = EINVAL;
			break;
		}

a199 1

@


1.17
log
@Disallow TCP connects to 255.255.255.255 or local broadcast addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.16 1998/01/24 18:21:39 mickey Exp $	*/
d194 1
a194 2
		if (in_broadcast(sin->sin_addr, NULL))
		{
@


1.16
log
@sysctl for def sizes for tcp/udp send/recv queues
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.15 1998/01/20 02:22:31 mickey Exp $	*/
d93 1
d193 7
d208 1
@


1.15
log
@s/(cast)0/NYLL/g
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.14 1998/01/06 23:49:49 deraadt Exp $	*/
d443 1
a443 1
u_long	tcp_sendspace = TCP_SENDSPACE;
d447 1
a447 1
u_long	tcp_recvspace = TCP_RECVSPACE;
d581 1
d600 6
@


1.14
log
@so_linger is in seconds
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.13 1998/01/03 22:32:53 deraadt Exp $	*/
d179 1
a179 1
			error = in_pcbbind(inp, (struct mbuf *)0);
d193 1
a193 1
			error = in_pcbbind(inp, (struct mbuf *)0);
d472 1
a472 1
	if (tp == 0) {
@


1.13
log
@ignore PRU_SHUTDOWN if socket is already shutdown
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.12 1997/08/09 23:36:26 millert Exp $	*/
d150 1
a150 1
			so->so_linger = TCP_LINGERTIME * hz;
@


1.12
log
@The list of tcp/udp ports not to allocate dynamically is now
a bitmask configurable via sysctl([38]).  The default values
have not changed.  If one wants to change the list it should
be done early on in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.11 1997/07/24 00:25:25 deraadt Exp $	*/
d260 2
@


1.11
log
@cmd is a u_long
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.10 1997/06/14 05:49:41 deraadt Exp $	*/
d78 3
d593 4
@


1.10
log
@TCP/IP Illustrated Vol. 2, pg 1010. excessive testing in PRU_DETACH case;
frueauf@@ira.uka.de; confirmed by Andreas.Gunnarsson@@emw.ericsson.se
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.9 1997/06/06 11:22:18 deraadt Exp $	*/
d97 1
a97 1
		return (in_control(so, (long)m, (caddr_t)nam,
@


1.9
log
@add net.inet.tcp.{keepidle,keepintvl,slowhz}; mouse@@Rodents.Montreal.QC.CA
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.8 1997/02/05 15:48:27 deraadt Exp $	*/
d159 1
a159 4
		if (tp->t_state > TCPS_LISTEN)
			tp = tcp_disconnect(tp);
		else
			tp = tcp_close(tp);
@


1.8
log
@use arc4random()
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.7 1996/09/20 22:53:12 deraadt Exp $	*/
d582 11
@


1.7
log
@`solve' the syn bomb problem as well as currently known; add sysctl's for
SOMAXCONN (kern.somaxconn), SOMINCONN (kern.sominconn), and TCPTV_KEEP_INIT
(net.inet.tcp.keepinittime). when this is not enough (ie. overfull), start
doing tail drop, but slightly prefer the same port.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.6 1996/07/29 22:01:51 niklas Exp $	*/
d70 1
d219 1
a219 1
		tcp_iss += random() % (TCP_ISSINCR / 2) + 1;
@


1.6
log
@Remove random() prototype, as it's not needed.  Besides it was wrong for the alpha :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.5 1996/07/29 06:22:15 tholo Exp $	*/
d75 1
d213 1
a213 1
		tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
d578 3
@


1.5
log
@Make TCP ISS increment by random amounts
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.4 1996/07/25 09:46:12 deraadt Exp $	*/
a87 3
#ifndef TCP_COMPAT_42
	u_int random __P((void));
#endif /* !TCP_COMPAT_42 */
@


1.4
log
@SS_CONNECTOUT indicates socket was connect()ed at this end, accept()ed at other end
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_usrreq.c,v 1.2 1996/03/03 22:30:49 niklas Exp $	*/
d88 3
d216 6
a221 1
		tp->iss = tcp_iss; tcp_iss += TCP_ISSINCR/2;
@


1.3
log
@From Lite2; fix mbuf leak
@
text
@d204 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 6
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tcp_usrreq.c,v 1.17 1995/09/30 07:02:05 thorpej Exp $	*/
d49 4
d89 1
a89 1
	register struct tcpcb *tp;
d529 1
a529 1
	if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
d531 10
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

