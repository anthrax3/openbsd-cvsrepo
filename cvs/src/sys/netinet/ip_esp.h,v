head	1.44;
access;
symbols
	OPENBSD_6_0:1.42.0.30
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.24
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.42.0.26
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.18
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.22
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.20
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.16
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.14
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.12
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.10
	OPENBSD_5_0:1.42.0.8
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.6
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.4
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.41.0.10
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.6
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.4
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.40.0.16
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.14
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.40.0.12
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.40.0.10
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.8
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.40.0.6
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.40.0.4
	OPENBSD_3_6_BASE:1.40
	SMP_SYNC_A:1.40
	SMP_SYNC_B:1.40
	OPENBSD_3_5:1.40.0.2
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.38.0.4
	OPENBSD_3_4_BASE:1.38
	UBC_SYNC_A:1.38
	OPENBSD_3_3:1.38.0.2
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.36.0.6
	OPENBSD_3_1_BASE:1.36
	UBC_SYNC_B:1.37
	UBC:1.36.0.4
	UBC_BASE:1.36
	OPENBSD_3_0:1.36.0.2
	OPENBSD_3_0_BASE:1.36
	OPENBSD_2_9_BASE:1.33
	OPENBSD_2_9:1.33.0.4
	OPENBSD_2_8:1.33.0.2
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.32.0.2
	OPENBSD_2_7_BASE:1.32
	SMP:1.31.0.2
	SMP_BASE:1.31
	kame_19991208:1.25
	OPENBSD_2_6:1.23.0.4
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.44
date	2017.02.07.18.18.16;	author bluhm;	state Exp;
branches;
next	1.43;
commitid	d6u53XQpFaxImDPZ;

1.43
date	2016.09.02.09.39.32;	author vgross;	state Exp;
branches;
next	1.42;
commitid	ZAyx9RbdVJtASCJK;

1.42
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.17.12.07.45;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.02.23.16.28;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.04.23.14.55;	author espie;	state Exp;
branches
	1.36.4.1;
next	1.35;

1.35
date	2001.06.25.05.11.58;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.09.07.03.41;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.19.03.20.58;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2000.03.17.10.25.22;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.27.08.09.10;	author angelos;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.01.13.05.03.45;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.09.23.42.37;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	99.12.31.22.19.43;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	99.12.25.07.09.42;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	99.12.09.00.33.29;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	99.12.06.00.43.20;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	99.10.29.02.10.01;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	99.04.11.19.41.38;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.02.24.23.45.49;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	99.02.24.22.33.01;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	99.02.17.20.39.17;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.02.17.18.10.38;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.11.25.02.01.28;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	98.05.18.21.10.41;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	97.11.24.19.14.13;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	97.11.18.00.12.14;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.11.04.09.11.10;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.09.30.03.29.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.09.24.18.39.38;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	97.09.23.21.42.20;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	97.08.26.12.02.49;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.07.14.08.48.46;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.07.11.23.37.56;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.06.25.07.53.24;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.06.20.05.41.50;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.03.30.22.05.13;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.02.26.20.53.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.02.24.14.06.39;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.02.24.02.13.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.02.20.01.07.54;	author deraadt;	state Exp;
branches;
next	;

1.31.2.1
date	2000.03.24.09.09.36;	author niklas;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2001.05.14.22.40.09;	author niklas;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2001.07.04.10.54.41;	author niklas;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.31.2.5;

1.31.2.5
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.31.2.6;

1.31.2.6
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.31.2.7;

1.31.2.7
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.36.4.1
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.36.4.2;

1.36.4.2
date	2003.05.19.22.40.40;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.44
log
@IPsec packets could be dropped unaccounted if output after crypto
failed.  Add a counter for that case.
OK dhill@@
@
text
@/*	$OpenBSD: ip_esp.h,v 1.43 2016/09/02 09:39:32 vgross Exp $	*/
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 * Copyright (c) 2001 Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#ifndef _NETINET_IP_ESP_H_
#define _NETINET_IP_ESP_H_

struct espstat {
    u_int32_t	esps_hdrops;	/* Packet shorter than header shows */
    u_int32_t	esps_nopf;	/* Protocol family not supported */
    u_int32_t	esps_notdb;
    u_int32_t	esps_badkcr;
    u_int32_t	esps_qfull;
    u_int32_t	esps_noxform;
    u_int32_t	esps_badilen;
    u_int32_t   esps_wrap;	/* Replay counter wrapped around */
    u_int32_t   esps_badenc;	/* Bad encryption detected */
    u_int32_t	esps_badauth;	/* Only valid for transforms with auth */
    u_int32_t   esps_replay;	/* Possible packet replay detected */
    u_int32_t	esps_input;	/* Input ESP packets */
    u_int32_t 	esps_output;	/* Output ESP packets */
    u_int32_t	esps_invalid;	/* Trying to use an invalid TDB */
    u_int64_t	esps_ibytes;	/* Input bytes */
    u_int64_t	esps_obytes;	/* Output bytes */
    u_int32_t	esps_toobig;	/* Packet got larger than IP_MAXPACKET */
    u_int32_t	esps_pdrops;	/* Packet blocked due to policy */
    u_int32_t	esps_crypto;	/* Crypto processing failure */
    u_int32_t	esps_udpencin;  /* Input ESP-in-UDP packets */
    u_int32_t	esps_udpencout; /* Output ESP-in-UDP packets */
    u_int32_t	esps_udpinval;  /* Invalid input ESP-in-UDP packets */
    u_int32_t	esps_udpneeded; /* Trying to use a ESP-in-UDP TDB */
    u_int32_t	esps_outfail;	/* Packet output failure */
};

/*
 * Names for ESP sysctl objects
 */
#define	ESPCTL_ENABLE		1	/* Enable ESP processing */
#define	ESPCTL_UDPENCAP_ENABLE	2	/* Enable ESP over UDP */
#define	ESPCTL_UDPENCAP_PORT	3	/* UDP port for encapsulation */
#define	ESPCTL_STATS		4	/* ESP Stats */
#define ESPCTL_MAXID		5

#define ESPCTL_NAMES { \
	{ 0, 0 }, \
	{ "enable", CTLTYPE_INT }, \
	{ "udpencap", CTLTYPE_INT }, \
	{ "udpencap_port", CTLTYPE_INT }, \
	{ "stats", CTLTYPE_STRUCT }, \
}

#define ESPCTL_VARS { \
	NULL, \
	&esp_enable, \
	&udpencap_enable, \
	&udpencap_port, \
	NULL \
}

#ifdef _KERNEL
extern int esp_enable;
extern int udpencap_enable;
extern int udpencap_port;
extern struct espstat espstat;
#endif /* _KERNEL */
#endif /* _NETINET_IP_ESP_H_ */
@


1.43
log
@Drop non-encapulated ESP packets using a UDP-encapsulating TDB, and add
the relevant counters.

Ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.42 2010/01/10 12:43:07 markus Exp $	*/
d41 1
a41 2
struct espstat
{
d65 1
@


1.42
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.41 2007/12/14 18:33:41 deraadt Exp $	*/
d65 1
@


1.41
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.40 2004/02/17 12:07:45 markus Exp $	*/
a39 2

#define ESP_ALEN	12	/* 96-bit authenticator */
@


1.40
log
@switch to sysctl_int_arr(); ok henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.39 2003/12/02 23:16:28 markus Exp $	*/
d75 2
a76 1
#define ESPCTL_MAXID		4
d83 1
d91 1
@


1.39
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.38 2003/02/12 14:41:07 jason Exp $	*/
d82 7
@


1.38
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.37 2002/06/09 16:26:10 itojun Exp $	*/
d64 3
d72 4
a75 2
#define	ESPCTL_ENABLE	1		/* Enable ESP processing */
#define ESPCTL_MAXID	2
d80 2
d86 2
@


1.37
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.36 2001/07/04 23:14:55 espie Exp $	*/
d79 1
a79 1
struct espstat espstat;
@


1.36
log
@Make preprocessor happier, don't give it untasty tokens at end of input.
Ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.35 2001/06/25 05:11:58 angelos Exp $	*/
d4 1
a4 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
d25 1
a25 1
 * modification of this software. 
@


1.36.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.36 2001/07/04 23:14:55 espie Exp $	*/
d4 1
a4 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
d25 1
a25 1
 * modification of this software.
@


1.36.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 1
a79 1
extern struct espstat espstat;
@


1.35
log
@Copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.34 2001/06/09 07:03:41 angelos Exp $	*/
d81 1
a81 1
#endif _NETINET_IP_ESP_H_
@


1.34
log
@Inclusion protection.
@
text
@d1 1
a1 2
/*	$OpenBSD: ip_esp.h,v 1.33 2000/09/19 03:20:58 angelos Exp $	*/

d20 3
a22 2
 *	
 * Permission to use, copy, and modify this software without fee
@


1.33
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.32 2000/03/17 10:25:22 angelos Exp $	*/
d38 2
a39 2
#ifndef _NETINET_ESP_H_
#define _NETINET_ESP_H_
d81 1
a81 1
#endif _NETINET_ESP_H_
@


1.32
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.31 2000/01/27 08:09:10 angelos Exp $	*/
d8 2
a9 2
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
 * in November 1995.
@


1.31
log
@Merge "old" and "new" ESP and AH in two files (one for each).
Fix a couple of buglets with ingress flow deletion.
tcpdump on enc0 should now show all outgoing packets *before* being
processed, and all incoming packets *after* being processed.

Good to be in Canada (land of the free commits).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.30 2000/01/13 05:03:45 angelos Exp $	*/
d45 1
a45 1
    u_int32_t	esps_hdrops;	/* packet shorter than header shows */
d58 6
a63 5
    u_int32_t	esps_invalid;   /* Trying to use an invalid TDB */
    u_int64_t	esps_ibytes;	/* input bytes */
    u_int64_t   esps_obytes;	/* output bytes */
    u_int32_t	esps_toobig;	/* packet got larger than IP_MAXPACKET */
    u_int32_t	esps_pdrops;	/* packet blocked due to policy */
@


1.31.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
    u_int32_t	esps_hdrops;	/* Packet shorter than header shows */
d58 5
a62 6
    u_int32_t	esps_invalid;	/* Trying to use an invalid TDB */
    u_int64_t	esps_ibytes;	/* Input bytes */
    u_int64_t	esps_obytes;	/* Output bytes */
    u_int32_t	esps_toobig;	/* Packet got larger than IP_MAXPACKET */
    u_int32_t	esps_pdrops;	/* Packet blocked due to policy */
    u_int32_t	esps_crypto;	/* Crypto processing failure */
@


1.31.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.33 2000/09/19 03:20:58 angelos Exp $	*/
d8 2
a9 2
 * The original version of this code was written by John Ioannidis
 * for BSD/OS in Athens, Greece, in November 1995.
@


1.31.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d21 2
a22 3
 * Copyright (c) 2001 Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
d38 2
a39 2
#ifndef _NETINET_IP_ESP_H_
#define _NETINET_IP_ESP_H_
d81 1
a81 1
#endif _NETINET_IP_ESP_H_
@


1.31.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.31.2.3 2001/07/04 10:54:41 niklas Exp $	*/
d81 1
a81 1
#endif /* _NETINET_IP_ESP_H_ */
@


1.31.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
d25 1
a25 1
 * modification of this software.
d79 1
a79 1
extern struct espstat espstat;
@


1.31.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a63 3
    u_int32_t	esps_udpencin;  /* Input ESP-in-UDP packets */
    u_int32_t	esps_udpencout; /* Output ESP-in-UDP packets */
    u_int32_t	esps_udpinval;  /* Invalid input ESP-in-UDP packets */
d69 2
a70 4
#define	ESPCTL_ENABLE		1	/* Enable ESP processing */
#define	ESPCTL_UDPENCAP_ENABLE	2	/* Enable ESP over UDP */
#define	ESPCTL_UDPENCAP_PORT	3	/* UDP port for encapsulation */
#define ESPCTL_MAXID		4
a74 2
	{ "udpencap", CTLTYPE_INT }, \
	{ "udpencap_port", CTLTYPE_INT }, \
a78 2
extern int udpencap_enable;
extern int udpencap_port;
@


1.31.2.7
log
@Merge with the trunk
@
text
@a83 7
#define ESPCTL_VARS { \
	NULL, \
	&esp_enable, \
	&udpencap_enable, \
	&udpencap_port, \
}

@


1.30
log
@Add an ip4_input6() for use with IPv6 (just a wrapper for
ip4_input()), add prototype, ifdef include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.29 2000/01/09 23:42:37 angelos Exp $	*/
a37 5
/*
 * Encapsulation Security Payload Processing
 * Per RFC1827 (Atkinson, 1995)
 */

d41 1
a41 18
/* Various defines for the "new" ESP */
#define ESP_NEW_ALEN		12	/* 96bits authenticator */

struct esp_old
{
    u_int32_t	esp_spi;	/* Security Parameters Index */
    u_int8_t	esp_iv[8];	/* iv[4] may actually be data! */
};

#define ESP_OLD_FLENGTH    12
#define ESP_NEW_FLENGTH    16

struct esp_new
{
    u_int32_t   esp_spi;        /* Security Parameter Index */
    u_int32_t   esp_rpl;        /* Sequence Number, Replay Counter */
    u_int8_t    esp_iv[8];      /* Data may start already at iv[0]! */
};
a76 8
void	esp_input __P((struct mbuf *, ...));
int	esp_output __P((struct mbuf *, struct tdb *, struct mbuf **));
int	esp_sysctl __P((int *, u_int, void *, size_t *, void *, size_t));

#ifdef INET6
int	esp6_input __P((struct mbuf **, int *, int));
#endif /* INET6 */

@


1.29
log
@Add ingress ACL for IPsec: after being processed, IPsec packets are
matched against a list of acceptable packet classes, if
sysctl variable net.inet.ip.ipsec-acl is set to 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.28 1999/12/31 22:19:43 itojun Exp $	*/
d43 3
d109 2
a110 1
#endif /* _Kernel */
@


1.28
log
@fix IPv6 ipsec template lossage.
- previous code grabbed new nexthdr mistakingly
- parameter passing must follow ip6protows
(actually the code will never get called until in6_proto.c is updated)

the current code assumes that {AH,ESP} is right next to IPv6 header.
the assumption must be removed, but it means that we need to chase
header chain...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.27 1999/12/25 07:09:42 angelos Exp $	*/
d65 1
@


1.27
log
@Change some function prototypes, dont unnecessarily initialize some
variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.26 1999/12/09 00:33:29 angelos Exp $	*/
d100 1
a100 1
int	esp6_input __P((struct mbuf *, ...));
@


1.26
log
@Add prototype for esp6_input() wrapper to ESP input processing routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.25 1999/12/06 00:43:20 angelos Exp $	*/
d100 1
a100 1
void	esp6_input __P((struct mbuf *, ...));
@


1.25
log
@Add another statistic
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.24 1999/10/29 02:10:01 angelos Exp $	*/
d98 4
@


1.24
log
@Get rid of unnecessary third argument in *_output routines of IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.23 1999/04/11 19:41:38 niklas Exp $	*/
d71 1
@


1.23
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.22 1999/02/24 23:45:49 angelos Exp $	*/
d95 1
a95 2
int	esp_output __P((struct mbuf *, struct sockaddr_encap *,
    struct tdb *, struct mbuf **));
@


1.22
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.21 1999/02/24 22:33:01 angelos Exp $	*/
d79 1
d82 11
d94 6
@


1.21
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.18 1998/11/25 02:01:28 niklas Exp $	*/
d17 4
a20 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
@


1.20
log
@ipsec skipjack, based on free .fi code (some .gov type will test this for me)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.19 1999/02/17 18:10:38 deraadt Exp $	*/
a40 28
#ifndef _MD5_H_
#include <sys/md5k.h>
#endif

#include <netinet/ip_sha1.h>
#include <netinet/ip_rmd160.h>
#include <netinet/ip_blf.h>
#include <netinet/ip_cast.h>
#include <netinet/ip_skipjack.h>

/* IV lengths */
#define ESP_DES_IVS		8
#define ESP_3DES_IVS		8
#define ESP_BLF_IVS             8
#define ESP_CAST_IVS            8
#define ESP_SKIPJACK_IVS	8

#define ESP_MAX_IVS		ESP_3DES_IVS

/* Block sizes -- it is assumed that they're powers of 2 */
#define ESP_DES_BLKS		8
#define ESP_3DES_BLKS		8
#define ESP_BLF_BLKS            8
#define ESP_CAST_BLKS           8
#define ESP_SKIPJACK_BLKS	8

#define ESP_MAX_BLKS            ESP_3DES_BLKS

a42 51
#define ESP_NEW_IPAD_VAL	0x36
#define	ESP_NEW_OPAD_VAL	0x5C

struct esp_hash {
	int		type;
	char		*name;
	u_int16_t	hashsize; 
	u_int16_t	ctxsize;
	void		(*Init) __P((void *));
	void		(*Update) __P((void *, u_int8_t *, u_int16_t));
	void		(*Final) __P((u_int8_t *, void *));
};

struct esp_xform {
	int		type;
	char		*name;
	u_int16_t	blocksize, ivsize;
	u_int16_t	minkey, maxkey;
	u_int32_t	ivmask;           /* Or all possible modes, zero iv = 1 */ 
	void		(*encrypt) __P((void *, u_int8_t *));
	void		(*decrypt) __P((void *, u_int8_t *));
};

struct esp_old {
	u_int32_t	esp_spi;	/* Security Parameters Index */
	u_int8_t	esp_iv[8];	/* iv[4] may actually be data! */
};

struct esp_new {
	u_int32_t	esp_spi;        /* Security Parameter Index */
	u_int32_t	esp_rpl;        /* Sequence Number, Replay Counter */
	u_int8_t	esp_iv[8];      /* Data may start already at iv[0]! */
};

struct espstat {
	u_int32_t	esps_hdrops;	/* packet shorter than header shows */
	u_int32_t	esps_notdb;
	u_int32_t	esps_badkcr;
	u_int32_t	esps_qfull;
	u_int32_t	esps_noxform;
	u_int32_t	esps_badilen;
	u_int32_t	esps_wrap;	/* Replay counter wrapped around */
	u_int32_t	esps_badauth;	/* Only valid for transforms with auth */
	u_int32_t	esps_replay;	/* Possible packet replay detected */
	u_int32_t	esps_input;	/* Input ESP packets */
	u_int32_t 	esps_output;	/* Output ESP packets */
	u_int32_t	esps_invalid;   /* Trying to use an invalid TDB */
	u_int64_t	esps_ibytes;	/* input bytes */
	u_int64_t	esps_obytes;	/* output bytes */
	u_int32_t	esps_toobig;	/* packet got larger than IP_MAXPACKET */
};
d44 33
a76 18
struct esp_old_xdata {
	u_int32_t	edx_enc_algorithm;
	int32_t		edx_ivlen;      /* 4 or 8 */
	struct esp_xform *edx_xform;
	union {
		u_int8_t  Iv[ESP_3DES_IVS]; /* that's enough space */
		u_int32_t Ivl;      	/* make sure this is 4 bytes */
		u_int64_t Ivq; 		/* make sure this is 8 bytes! */
	} Iu;
#define edx_iv  Iu.Iv
#define edx_ivl Iu.Ivl
#define edx_ivq Iu.Ivq
	union {
		u_int8_t  Rk[3][8];
		u_int32_t Eks[3][16][2];
	} Xu;
#define edx_rk  Xu.Rk
#define edx_eks Xu.Eks
a78 73
struct esp_old_xencap {
	u_int32_t	edx_enc_algorithm;
	u_int32_t	edx_ivlen;
	u_int32_t	edx_keylen;
	u_int8_t	edx_data[1];	/* IV + key material */
};

#define ESP_OLD_XENCAP_LEN	(3 * sizeof(u_int32_t))

struct esp_new_xencap {
	u_int32_t	edx_enc_algorithm;
	u_int32_t	edx_hash_algorithm;
	u_int32_t	edx_ivlen;	/* 0 or 8 */
	u_int16_t	edx_confkeylen;
	u_int16_t	edx_authkeylen;
	int32_t		edx_wnd;
	u_int32_t	edx_flags;
	u_int8_t	edx_data[1];	/* IV + key material */
};

#define ESP_NEW_XENCAP_LEN	(6 * sizeof(u_int32_t))

#define ESP_NEW_FLAG_AUTH	0x00000001	/* Doing authentication too */
#define ESP_NEW_FLAG_NPADDING	0x00000002	/* New style padding */

struct esp_new_xdata {
	u_int32_t   edx_enc_algorithm;
	u_int32_t   edx_hash_algorithm;
	u_int32_t   edx_ivlen;      /* 0 or 8 */
	u_int32_t   edx_rpl;	/* Replay counter */
	int32_t     edx_wnd;		/* Replay window */
	u_int32_t   edx_bitmap;
	u_int32_t   edx_flags;
	u_int32_t   edx_initial;	/* initial replay value */
	struct esp_hash *edx_hash;
	struct esp_xform *edx_xform;
	union {
		u_int8_t  Iv[ESP_MAX_IVS]; /* that's enough space */
		u_int32_t Ivl;      	/* make sure this is 4 bytes */
		u_int64_t Ivq; 		/* make sure this is 8 bytes! */
	    } Iu;
	union {
		u_int8_t  Rk[3][8];
		u_int32_t Eks[3][16][2];
		blf_ctx   Bks;
		cast_key  Cks;
		u_int8_t  *Sks[10];
	} Xu;
	union {
		MD5_CTX    edx_MD5_ictx;
		SHA1_CTX   edx_SHA1_ictx;
	        RMD160_CTX edx_RMD160_ictx;
	} edx_ictx;
	union {
	    	MD5_CTX	   edx_MD5_octx;
		SHA1_CTX   edx_SHA1_octx;
	        RMD160_CTX edx_RMD160_octx;
	} edx_octx;
};

#define edx_bks         Xu.Bks
#define edx_cks         Xu.Cks
#define edx_sks         Xu.Sks
#define edx_md5_ictx	edx_ictx.edx_MD5_ictx
#define edx_md5_octx	edx_octx.edx_MD5_octx
#define edx_sha1_ictx	edx_ictx.edx_SHA1_ictx
#define edx_sha1_octx	edx_octx.edx_SHA1_octx
#define edx_rmd160_ictx	edx_ictx.edx_RMD160_ictx
#define edx_rmd160_octx	edx_octx.edx_RMD160_octx

#define ESP_OLD_FLENGTH		12
#define ESP_NEW_FLENGTH         16

d81 1
a81 1
#endif
@


1.19
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.18 1998/11/25 02:01:28 niklas Exp $	*/
d49 1
d56 1
d65 1
d189 1
d205 1
@


1.18
log
@Add checks of packets getting to big after transforms.
Also make sure some more error conditions get told to the caller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.17 1998/05/18 21:10:41 provos Exp $	*/
d72 7
a78 7
    int type;
    char *name;
    u_int16_t hashsize; 
    u_int16_t ctxsize;
    void (*Init)(void *);
    void (*Update)(void *, u_int8_t *, u_int16_t);
    void (*Final)(u_int8_t *, void *);
d82 47
a128 52
    int type;
    char *name;
    u_int16_t blocksize, ivsize;
    u_int16_t minkey, maxkey;
    u_int32_t ivmask;           /* Or all possible modes, zero iv = 1 */ 
    void (*encrypt)(void *, u_int8_t *);
    void (*decrypt)(void *, u_int8_t *);
};

struct esp_old
{
    u_int32_t	esp_spi;	/* Security Parameters Index */
    u_int8_t	esp_iv[8];	/* iv[4] may actually be data! */
};

struct esp_new
{
    u_int32_t   esp_spi;        /* Security Parameter Index */
    u_int32_t   esp_rpl;        /* Sequence Number, Replay Counter */
    u_int8_t    esp_iv[8];      /* Data may start already at iv[0]! */
};

struct espstat
{
    u_int32_t	esps_hdrops;	/* packet shorter than header shows */
    u_int32_t	esps_notdb;
    u_int32_t	esps_badkcr;
    u_int32_t	esps_qfull;
    u_int32_t	esps_noxform;
    u_int32_t	esps_badilen;
    u_int32_t   esps_wrap;	/* Replay counter wrapped around */
    u_int32_t	esps_badauth;	/* Only valid for transforms with auth */
    u_int32_t   esps_replay;	/* Possible packet replay detected */
    u_int32_t	esps_input;	/* Input ESP packets */
    u_int32_t 	esps_output;	/* Output ESP packets */
    u_int32_t	esps_invalid;   /* Trying to use an invalid TDB */
    u_int64_t	esps_ibytes;	/* input bytes */
    u_int64_t   esps_obytes;	/* output bytes */
    u_int32_t	esps_toobig;	/* packet got larger than IP_MAXPACKET */
};

struct esp_old_xdata
{
    u_int32_t   edx_enc_algorithm;
    int32_t     edx_ivlen;      /* 4 or 8 */
    struct esp_xform *edx_xform;
    union
    {
	u_int8_t  Iv[ESP_3DES_IVS]; /* that's enough space */
	u_int32_t Ivl;      	/* make sure this is 4 bytes */
	u_int64_t Ivq; 		/* make sure this is 8 bytes! */
    }Iu;
d132 4
a135 5
    union
    {
	u_int8_t  Rk[3][8];
	u_int32_t Eks[3][16][2];
    }Xu;
d140 5
a144 6
struct esp_old_xencap
{
    u_int32_t   edx_enc_algorithm;
    u_int32_t	edx_ivlen;
    u_int32_t	edx_keylen;
    u_int8_t	edx_data[1];	/* IV + key material */
d149 9
a157 10
struct esp_new_xencap
{
    u_int32_t   edx_enc_algorithm;
    u_int32_t   edx_hash_algorithm;
    u_int32_t	edx_ivlen;	/* 0 or 8 */
    u_int16_t	edx_confkeylen;
    u_int16_t	edx_authkeylen;
    int32_t	edx_wnd;
    u_int32_t   edx_flags;
    u_int8_t	edx_data[1];	/* IV + key material */
d165 32
a196 37
struct esp_new_xdata
{
    u_int32_t   edx_enc_algorithm;
    u_int32_t   edx_hash_algorithm;
    u_int32_t   edx_ivlen;      /* 0 or 8 */
    u_int32_t   edx_rpl;	/* Replay counter */
    int32_t     edx_wnd;		/* Replay window */
    u_int32_t   edx_bitmap;
    u_int32_t   edx_flags;
    u_int32_t   edx_initial;	/* initial replay value */
    struct esp_hash *edx_hash;
    struct esp_xform *edx_xform;
    union
    {
	u_int8_t  Iv[ESP_MAX_IVS]; /* that's enough space */
	u_int32_t Ivl;      	/* make sure this is 4 bytes */
	u_int64_t Ivq; 		/* make sure this is 8 bytes! */
    }Iu;
    union
    {
	u_int8_t  Rk[3][8];
	u_int32_t Eks[3][16][2];
	blf_ctx   Bks;
	cast_key  Cks;
    }Xu;
    union
    {
	MD5_CTX    edx_MD5_ictx;
	SHA1_CTX   edx_SHA1_ictx;
        RMD160_CTX edx_RMD160_ictx;
    } edx_ictx;
    union 
    {
    	MD5_CTX	   edx_MD5_octx;
	SHA1_CTX   edx_SHA1_octx;
        RMD160_CTX edx_RMD160_octx;
    } edx_octx;
@


1.17
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.16 1997/11/24 19:14:13 provos Exp $	*/
d120 1
@


1.16
log
@add ripemd-160 as authentication function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.15 1997/11/18 00:12:14 provos Exp $	*/
d4 3
a6 2
 * The author of this code is John Ioannidis, ji@@tla.org,
 * 	(except when noted otherwise).
d8 2
a9 1
 * This code was written for BSD/OS in Athens, Greece, in November 1995.
d12 1
a12 1
 * by Angelos D. Keromytis, kermit@@forthnet.gr.
d14 2
a15 2
 * Additional transforms and features in 1997 by Angelos D. Keromytis and
 * Niels Provos.
d17 1
a17 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis, Angelos D. Keromytis
d23 5
a27 1
 * modification of this software.
d30 1
a30 1
 * IMPLIED WARRANTY. IN PARTICULAR, NEITHER AUTHOR MAKES ANY
@


1.15
log
@make old style padding default again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.14 1997/11/04 09:11:10 provos Exp $	*/
d40 1
d193 3
a195 2
  	MD5_CTX	 edx_MD5_ictx;
        SHA1_CTX edx_SHA1_ictx;
d199 3
a201 2
    	MD5_CTX	 edx_MD5_octx;
	SHA1_CTX edx_SHA1_octx;
d211 2
@


1.14
log
@make it easier to add additional transforms. add blowfish and cast
encryption. some more info for kernfs/ipsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.13 1997/09/30 03:29:50 deraadt Exp $	*/
d163 1
a163 1
#define ESP_NEW_FLAG_OPADDING	0x00000002	/* Old style padding */
@


1.13
log
@same as for ip_esp_new.c, and indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.12 1997/09/24 18:39:38 angelos Exp $	*/
d12 5
a16 1
 * Copyright (C) 1995, 1996, 1997 by John Ioannidis and Angelos D. Keromytis.
d40 2
d46 2
d54 4
d64 20
d119 1
d153 2
a154 1
    u_int32_t	edx_keylen;
d175 2
d187 2
d192 16
a207 17
	struct
	{
    	    MD5_CTX	edx_ictx;
    	    MD5_CTX	edx_octx;
	} MD5stuff;
	struct
	{
	    SHA1_CTX	edx_ictx;
	    SHA1_CTX 	edx_octx;
	} SHA1stuff;   
    } Hashes;
};

#define edx_md5_ictx	Hashes.MD5stuff.edx_ictx
#define edx_md5_octx	Hashes.MD5stuff.edx_octx
#define edx_sha1_ictx	Hashes.SHA1stuff.edx_ictx
#define edx_sha1_octx	Hashes.SHA1stuff.edx_octx
@


1.12
log
@New style self-describing padding in use.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.11 1997/09/23 21:42:20 angelos Exp $	*/
d137 1
a137 1
    int32_t   edx_wnd;		/* Replay window */
@


1.11
log
@AH changes, after interoperating at the ANX bakeoff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.10 1997/08/26 12:02:49 provos Exp $	*/
d129 2
@


1.10
log
@new esp: encryption, authentication and replay protection +
tiny bug fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.9 1997/07/14 08:48:46 provos Exp $	*/
d121 1
a121 1
    u_int32_t	edx_wnd;
d135 1
a135 1
    u_int32_t   edx_wnd;	/* Replay window */
@


1.9
log
@global byte counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.8 1997/07/11 23:37:56 provos Exp $	*/
d58 7
d119 1
a119 1
    int32_t	edx_ivlen;	/* 0 or 8 */
d133 1
a133 1
    int32_t     edx_ivlen;      /* 0 or 8 */
d171 1
@


1.8
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.7 1997/06/25 07:53:24 provos Exp $	*/
d72 2
@


1.7
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.6 1997/06/20 05:41:50 provos Exp $	*/
d35 1
a35 31
#define ESPDESMD5_KEYSZ		64
#define ESPDESMD5_IVS		8
#define ESPDESMD5_ALEN		16
#define ESPDESMD5_IPAD_VAL	0x36
#define	ESPDESMD5_OPAD_VAL	0x5C
#define ESPDESMD5_DESBLK	8
#define ESPDESMD5_RPLENGTH	4
#define ESPDESMD5_DPADI		0x5C
#define ESPDESMD5_DPADR		0x3A
#define ESPDESMD5_IPADI		0xAC
#define ESPDESMD5_IPADR		0x55
#define ESPDESMD5_HPADI		0x53
#define ESPDESMD5_HPADR		0x3C
#define ESPDESMD5_RPADI		0x35
#define ESPDESMD5_RPADR		0xCC

#define ESP3DESMD5_KEYSZ		64
#define ESP3DESMD5_IVS	        	8
#define ESP3DESMD5_ALEN		        16
#define ESP3DESMD5_IPAD_VAL	        0x36
#define	ESP3DESMD5_OPAD_VAL	        0x5C
#define ESP3DESMD5_DESBLK	        8
#define ESP3DESMD5_RPLENGTH	        4
#define ESP3DESMD5_DPADI		0x5C
#define ESP3DESMD5_DPADR		0x3A
#define ESP3DESMD5_IPADI		0xAC
#define ESP3DESMD5_IPADR		0x55
#define ESP3DESMD5_HPADI		0x53
#define ESP3DESMD5_HPADR		0x3C
#define ESP3DESMD5_RPADI		0x35
#define ESP3DESMD5_RPADR		0xCC
d37 16
a52 1
struct esp
d74 1
a74 22
struct espdes_xdata
{
    int32_t     edx_ivlen;              /* 4 or 8 */
    union
    {
	u_int8_t  Iv[8];        /* that's enough space */
	u_int32_t Ivl;      	/* make sure this is 4 bytes */
	u_int64_t Ivq; 		/* make sure this is 8 bytes! */
    }Iu;
#define edx_iv  Iu.Iv
#define edx_ivl Iu.Ivl
#define edx_ivq Iu.Ivq
    union
    {
	u_int8_t  Rk[8];
	u_int32_t Eks[16][2];
    }Xu;
#define edx_rk  Xu.Rk
#define edx_eks Xu.Eks
};

struct esp3des_xdata
d76 2
a77 1
    int32_t     edx_ivlen;              /* 4 or 8 */
d80 1
a80 1
	u_int8_t  Iv[8];        /* that's enough space */
d96 1
a96 1
struct esp3desmd5_xencap
d98 4
a101 6
    int8_t		edx_ivlen;		/* 0 or 8 */
    int8_t		edx_initiator;		/* 1 if setting an I key */
    u_int16_t	edx_keylen;
    u_int32_t	edx_wnd;
    u_int8_t	edx_ivv[ESP3DESMD5_IVS];
    u_int8_t	edx_key[ESP3DESMD5_KEYSZ];
d104 3
a106 1
struct espdesmd5_xencap
d108 4
a111 3
    int8_t		edx_ivlen;		/* 0 or 8 */
    int8_t		edx_initiator;		/* 1 if setting an I key */
    u_int16_t	edx_keylen;
d113 2
a114 2
    u_int8_t	edx_ivv[ESPDESMD5_IVS];
    u_int8_t	edx_key[ESPDESMD5_KEYSZ];
d117 1
a117 2
#define ESPDESMD5_ULENGTH 8+ESPDESMD5_IVS+ESPDESMD5_KEYSZ
#define ESP3DESMD5_ULENGTH 8+ESP3DESMD5_IVS+ESP3DESMD5_KEYSZ
d119 2
a120 1
struct espdesmd5_xdata
d122 5
a126 3
    int32_t     edx_ivlen;          /* 0 or 8 */
    u_int32_t   edx_rpl;		/* Replay counter */
    u_int32_t   edx_wnd;		/* Replay window */
d128 1
d132 1
a132 1
	u_int8_t  Iv[8];        /* that's enough space */
d138 2
a139 2
	u_int8_t  Rk[8];
	u_int32_t Eks[16][2];
a140 11
    MD5_CTX	    edx_ictx;
    MD5_CTX	    edx_octx;
};

struct esp3desmd5_xdata
{
    int32_t     edx_ivlen;          /* 0 or 4 or 8 */
    u_int32_t   edx_rpl;		/* Replay counter */
    u_int32_t   edx_wnd;		/* Replay window */
    u_int32_t   edx_bitmap;
    u_int32_t   edx_initial;
d143 17
a159 12
	u_int8_t  Iv[8];        /* that's enough space */
	u_int32_t Ivl;      	/* make sure this is 4 bytes */
	u_int64_t Ivq; 		/* make sure this is 8 bytes! */
    }Iu;
    union
    {
	u_int8_t  Rk[3][8];
	u_int32_t Eks[3][16][2];
    }Xu;
    MD5_CTX		edx_ictx;
    MD5_CTX		edx_octx;
};
d161 1
a161 2
#define ESP_FLENGTH	12
#define ESP_ULENGTH	20		/* coming from user mode */
a163 1

a164 1

@


1.6
log
@ah-sha1 + esp-3des + indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.5 1997/03/30 22:05:13 mickey Exp $	*/
d75 12
a86 11
    u_long	esps_hdrops;	/* packet shorter than header shows */
    u_long	esps_notdb;
    u_long	esps_badkcr;
    u_long	esps_qfull;
    u_long	esps_noxform;
    u_long	esps_badilen;
    u_long      esps_wrap;	/* Replay counter wrapped around */
    u_long	esps_badauth;	/* Only valid for transforms with auth */
    u_long      esps_replay;	/* Possible packet replay detected */
    u_long	esps_input;	/* Input ESP packets */
    u_long 	esps_output;	/* Output ESP packets */
a205 1

@


1.5
log
@no more 2(two) md5 libs in kernel!
tested for rnd(4).... should work for ip too, since it's
the copy of ip_md*.
use sys/md5k.h for protos.... std iface forever!
hurray!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.4 1997/02/26 20:53:13 deraadt Exp $	*/
d69 2
a70 2
	u_int32_t	esp_spi;	/* Security Parameters Index */
	u_int8_t	esp_iv[8];	/* iv[4] may actually be data! */
d75 11
a85 11
	u_long	esps_hdrops;	/* packet shorter than header shows */
	u_long	esps_notdb;
	u_long	esps_badkcr;
	u_long	esps_qfull;
	u_long	esps_noxform;
	u_long	esps_badilen;
	u_long  esps_wrap;	/* Replay counter wrapped around */
	u_long	esps_badauth;	/* Only valid for transforms with auth */
	u_long  esps_replay;	/* Possible packet replay detected */
	u_long	esps_input;	/* Input ESP packets */
	u_long 	esps_output;	/* Output ESP packets */
d90 7
a96 7
        int32_t     edx_ivlen;              /* 4 or 8 */
        union
        {
                u_int8_t  Iv[8];        /* that's enough space */
                u_int32_t Ivl;      	/* make sure this is 4 bytes */
                u_int64_t Ivq; 		/* make sure this is 8 bytes! */
        }Iu;
d100 26
a125 5
        union
        {
                u_int8_t  Rk[8];
                u_int32_t Eks[16][2];
        }Xu;
d132 6
a137 6
	int8_t		edx_ivlen;		/* 0 or 8 */
	int8_t		edx_initiator;		/* 1 if setting an I key */
	u_int16_t	edx_keylen;
	u_int32_t	edx_wnd;
	u_int8_t	edx_ivv[ESP3DESMD5_IVS];
	u_int8_t	edx_key[ESP3DESMD5_KEYSZ];
d142 6
a147 6
	int8_t		edx_ivlen;		/* 0 or 8 */
	int8_t		edx_initiator;		/* 1 if setting an I key */
	u_int16_t	edx_keylen;
	u_int32_t	edx_wnd;
	u_int8_t	edx_ivv[ESPDESMD5_IVS];
	u_int8_t	edx_key[ESPDESMD5_KEYSZ];
d155 18
a172 18
        int32_t     edx_ivlen;          /* 0 or 8 */
	u_int32_t   edx_rpl;		/* Replay counter */
	u_int32_t   edx_wnd;		/* Replay window */
	u_int32_t   edx_bitmap;
	u_int32_t   edx_initial;	/* initial replay value */
        union
        {
                u_int8_t  Iv[8];        /* that's enough space */
                u_int32_t Ivl;      	/* make sure this is 4 bytes */
                u_int64_t Ivq; 		/* make sure this is 8 bytes! */
        }Iu;
        union
        {
                u_int8_t  Rk[8];
                u_int32_t Eks[16][2];
        }Xu;
	MD5_CTX	    edx_ictx;
	MD5_CTX	    edx_octx;
d177 18
a194 18
        int32_t     edx_ivlen;          /* 0 or 4 or 8 */
	u_int32_t   edx_rpl;		/* Replay counter */
	u_int32_t   edx_wnd;		/* Replay window */
	u_int32_t   edx_bitmap;
	u_int32_t   edx_initial;
        union
        {
                u_int8_t  Iv[8];        /* that's enough space */
                u_int32_t Ivl;      	/* make sure this is 4 bytes */
                u_int64_t Ivq; 		/* make sure this is 8 bytes! */
        }Iu;
        union
        {
                u_int8_t  Rk[3][8];
                u_int32_t Eks[3][16][2];
        }Xu;
	MD5_CTX		edx_ictx;
	MD5_CTX		edx_octx;
d205 1
@


1.4
log
@count input/output packets for esp
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_esp.h,v 1.3 1997/02/24 14:06:39 niklas Exp $	*/
d32 1
a32 1
#include <netinet/ip_md5.h>
@


1.3
log
@OpenBSD tags + some prototyping police
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 2
@


1.2
log
@XXX cleanup
@
text
@d1 2
@


1.1
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d89 3
a91 3
                u_int8_t  Iv[8];          /* that's enough space */
                u_int32_t Ivl;      /* XXX make sure this is 4 bytes */
                u_int64_t Ivq; /* XXX make sure this is 8 bytes! */
d130 1
a130 1
        int32_t     edx_ivlen;              /* 0 or 8 */
d137 3
a139 3
                u_int8_t  Iv[8];          /* that's enough space */
                u_int32_t Ivl;      /* XXX make sure this is 4 bytes */
                u_int64_t Ivq; /* XXX make sure this is 8 bytes! */
d152 1
a152 1
        int32_t     edx_ivlen;              /* 0 or 4 or 8 */
d159 3
a161 3
                u_int8_t  Iv[8];          /* that's enough space */
                u_int32_t Ivl;      /* XXX make sure this is 4 bytes */
                u_int64_t Ivq; /* XXX make sure this is 8 bytes! */
@
