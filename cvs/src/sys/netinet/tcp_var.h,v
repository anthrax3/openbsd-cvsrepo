head	1.124;
access;
symbols
	OPENBSD_6_1:1.123.0.4
	OPENBSD_6_1_BASE:1.123
	OPENBSD_6_0:1.115.0.4
	OPENBSD_6_0_BASE:1.115
	OPENBSD_5_9:1.109.0.2
	OPENBSD_5_9_BASE:1.109
	OPENBSD_5_8:1.107.0.6
	OPENBSD_5_8_BASE:1.107
	OPENBSD_5_7:1.107.0.2
	OPENBSD_5_7_BASE:1.107
	OPENBSD_5_6:1.105.0.6
	OPENBSD_5_6_BASE:1.105
	OPENBSD_5_5:1.105.0.4
	OPENBSD_5_5_BASE:1.105
	OPENBSD_5_4:1.101.0.2
	OPENBSD_5_4_BASE:1.101
	OPENBSD_5_3:1.99.0.8
	OPENBSD_5_3_BASE:1.99
	OPENBSD_5_2:1.99.0.6
	OPENBSD_5_2_BASE:1.99
	OPENBSD_5_1_BASE:1.99
	OPENBSD_5_1:1.99.0.4
	OPENBSD_5_0:1.99.0.2
	OPENBSD_5_0_BASE:1.99
	OPENBSD_4_9:1.98.0.2
	OPENBSD_4_9_BASE:1.98
	OPENBSD_4_8:1.95.0.2
	OPENBSD_4_8_BASE:1.95
	OPENBSD_4_7:1.93.0.2
	OPENBSD_4_7_BASE:1.93
	OPENBSD_4_6:1.91.0.4
	OPENBSD_4_6_BASE:1.91
	OPENBSD_4_5:1.90.0.2
	OPENBSD_4_5_BASE:1.90
	OPENBSD_4_4:1.89.0.2
	OPENBSD_4_4_BASE:1.89
	OPENBSD_4_3:1.86.0.2
	OPENBSD_4_3_BASE:1.86
	OPENBSD_4_2:1.83.0.2
	OPENBSD_4_2_BASE:1.83
	OPENBSD_4_1:1.81.0.2
	OPENBSD_4_1_BASE:1.81
	OPENBSD_4_0:1.80.0.4
	OPENBSD_4_0_BASE:1.80
	OPENBSD_3_9:1.80.0.2
	OPENBSD_3_9_BASE:1.80
	OPENBSD_3_8:1.77.0.2
	OPENBSD_3_8_BASE:1.77
	OPENBSD_3_7:1.72.0.2
	OPENBSD_3_7_BASE:1.72
	OPENBSD_3_6:1.65.0.2
	OPENBSD_3_6_BASE:1.65
	SMP_SYNC_A:1.64
	SMP_SYNC_B:1.64
	OPENBSD_3_5:1.61.0.2
	OPENBSD_3_5_BASE:1.61
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	UBC_SYNC_A:1.46
	OPENBSD_3_3:1.45.0.2
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.44.0.2
	OPENBSD_3_2_BASE:1.44
	OPENBSD_3_1:1.42.0.2
	OPENBSD_3_1_BASE:1.42
	UBC_SYNC_B:1.44
	UBC:1.37.0.4
	UBC_BASE:1.37
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.2
	OPENBSD_2_8:1.33.0.2
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.26.0.4
	OPENBSD_2_7_BASE:1.26
	SMP:1.26.0.2
	SMP_BASE:1.26
	kame_19991208:1.25
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.19.0.2
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.124
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.123;
commitid	00hB28wQPwG5Ysk0;

1.123
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.122;
commitid	ZsxSSZJSFxZH81LL;

1.122
date	2017.02.09.15.19.32;	author jca;	state Exp;
branches;
next	1.121;
commitid	Hew5AYIxyEp5lNbI;

1.121
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.120;
commitid	UBL7uwpXqTP4EWIu;

1.120
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.119;
commitid	3e3CkrbYekyVOcxy;

1.119
date	2017.01.26.13.03.47;	author bluhm;	state Exp;
branches;
next	1.118;
commitid	wBlwxPiTlfo8m7xr;

1.118
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.117;
commitid	pVtptbHA3yk4jSpN;

1.117
date	2016.11.16.08.50.33;	author mpi;	state Exp;
branches;
next	1.116;
commitid	1FZaHsMsvSO8gmsb;

1.116
date	2016.10.04.13.54.32;	author mpi;	state Exp;
branches;
next	1.115;
commitid	QtKIaSOt6xUiLgI5;

1.115
date	2016.07.20.19.57.53;	author bluhm;	state Exp;
branches;
next	1.114;
commitid	iB1JO3v9iwYOTdxI;

1.114
date	2016.07.20.09.15.28;	author bluhm;	state Exp;
branches;
next	1.113;
commitid	Qwlx91wnD3EO5HU6;

1.113
date	2016.06.18.10.36.13;	author vgross;	state Exp;
branches;
next	1.112;
commitid	r16P5gVURcjZa76o;

1.112
date	2016.03.29.18.13.20;	author bluhm;	state Exp;
branches;
next	1.111;
commitid	m1S5Qx2z8077Jh3c;

1.111
date	2016.03.27.19.19.01;	author bluhm;	state Exp;
branches;
next	1.110;
commitid	b8ii6TWWipjoxZhr;

1.110
date	2016.03.21.15.52.27;	author bluhm;	state Exp;
branches;
next	1.109;
commitid	7wNIPXOo0aTQzUHP;

1.109
date	2015.08.27.20.56.16;	author bluhm;	state Exp;
branches;
next	1.108;
commitid	Dj0fqkE649GFzkeR;

1.108
date	2015.08.24.15.37.03;	author bluhm;	state Exp;
branches;
next	1.107;
commitid	iKqcQwl3eIXo4smF;

1.107
date	2015.02.08.04.40.50;	author yasuoka;	state Exp;
branches;
next	1.106;
commitid	v0TRBcxZUQjo1nf8;

1.106
date	2015.01.21.22.23.52;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	B0z7T0dDfmIZqmHa;

1.105
date	2014.01.23.23.51.29;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2013.10.23.19.49.11;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2013.10.21.08.42.24;	author phessler;	state Exp;
branches;
next	1.102;

1.102
date	2013.08.12.21.57.16;	author bluhm;	state Exp;
branches;
next	1.101;

1.101
date	2013.06.01.16.22.05;	author bluhm;	state Exp;
branches;
next	1.100;

1.100
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.99;

1.99
date	2011.07.06.23.44.20;	author sthen;	state Exp;
branches;
next	1.98;

1.98
date	2011.01.07.17.50.42;	author bluhm;	state Exp;
branches;
next	1.97;

1.97
date	2010.10.21.11.38.27;	author bluhm;	state Exp;
branches;
next	1.96;

1.96
date	2010.09.24.02.59.46;	author claudio;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2009.08.10.10.13.43;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.90;

1.90
date	2008.11.08.12.54.58;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2008.05.24.19.48.32;	author thib;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.87;

1.87
date	2008.05.06.08.47.36;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2008.02.20.14.23.31;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2008.02.20.11.24.03;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2007.12.13.20.00.53;	author reyk;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.25.12.17.43;	author markus;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2007.06.15.18.23.07;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2007.02.01.19.55.37;	author jmc;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2005.12.11.17.21.53;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2005.11.20.19.25.16;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2005.11.15.21.09.46;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2005.08.02.11.05.44;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.04.12.34.12;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2005.06.30.08.51.31;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2005.05.24.00.02.37;	author fgont;	state Exp;
branches;
next	1.73;

1.73
date	2005.04.05.20.27.35;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2005.03.09.11.14.38;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2005.03.04.13.21.42;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2005.02.27.13.22.56;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2005.01.10.23.53.49;	author mcbride;	state Exp;
branches;
next	1.68;

1.68
date	2004.11.25.15.32.08;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2004.10.28.19.22.52;	author mcbride;	state Exp;
branches;
next	1.66;

1.66
date	2004.09.16.13.14.28;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2004.07.15.15.27.22;	author markus;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2004.06.08.19.47.24;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.25.04.34.05;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.20.20.05.29;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.02.12.51.12;	author markus;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2004.02.27.16.44.45;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2004.02.27.16.28.24;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.15.11.16.08;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.31.19.40.10;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.29.11.55.28;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.14.13.38.21;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.13.13.26.14;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.07.19.20.14;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.06.17.38.13;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.09.07.40.25;	author itojun;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.29.00.35.18;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.26.05.01.55;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.23.03.29.00;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.12.00.48.52;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.12.14.41.08;	author jason;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2002.06.09.16.26.11;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.16.14.10.51;	author kjc;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.08.03.49.58;	author provos;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.02.00.44.52;	author provos;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.01.22.29.29;	author provos;	state Exp;
branches;
next	1.38;

1.38
date	2002.01.15.19.18.01;	author provos;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.23.06.03.13;	author angelos;	state Exp;
branches
	1.37.4.1;
next	1.36;

1.36
date	2001.06.09.07.03.43;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.13.09.47.08;	author provos;	state Exp;
branches;
next	1.34;

1.34
date	2000.12.11.08.04.56;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.14.01.04.11;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.25.09.41.03;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.20.17.00.23;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	2000.09.18.22.06.38;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.11.16.53.22;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.26.22.45.09;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.18.04.42.43;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	99.12.21.17.49.28;	author provos;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	99.08.06.18.17.38;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.07.22.17.51.30;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.07.17.23.41.46;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	99.07.06.20.17.53;	author cmetz;	state Exp;
branches;
next	1.20;

1.20
date	99.07.02.21.22.14;	author cmetz;	state Exp;
branches;
next	1.19;

1.19
date	99.03.27.21.04.21;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	99.02.04.16.12.13;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.02.04.00.04.59;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.01.11.15.05.32;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.01.11.02.01.36;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.11.18.17.42.22;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.11.17.19.23.03;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	98.10.28.21.34.33;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	98.06.10.03.40.05;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	98.03.18.02.37.49;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	98.01.24.18.21.39;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.08.09.23.36.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.06.15.13.47.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.06.06.11.22.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.20.22.53.13;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.12.06.19.57;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.22.30.50;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.50.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.13;	author deraadt;	state Exp;
branches;
next	;

1.26.2.1
date	2001.05.14.22.40.15;	author niklas;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2001.07.04.10.55.10;	author niklas;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.26.2.5;

1.26.2.5
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.26.2.6;

1.26.2.6
date	2003.05.13.19.36.18;	author ho;	state Exp;
branches;
next	1.26.2.7;

1.26.2.7
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.26.2.8;

1.26.2.8
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.26.2.9;

1.26.2.9
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	1.26.2.10;

1.26.2.10
date	2004.06.08.21.07.30;	author niklas;	state Exp;
branches;
next	;

1.37.4.1
date	2002.01.31.22.55.46;	author niklas;	state Exp;
branches;
next	1.37.4.2;

1.37.4.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.37.4.3;

1.37.4.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.37.4.4;

1.37.4.4
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;

1.45.2.1
date	2004.03.03.02.35.59;	author brad;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2004.03.03.08.40.07;	author brad;	state Exp;
branches;
next	1.45.2.3;

1.45.2.3
date	2004.03.04.03.35.15;	author brad;	state Exp;
branches;
next	;

1.51.2.1
date	2004.03.03.02.35.26;	author brad;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2004.03.03.08.37.05;	author brad;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2004.03.04.03.28.09;	author brad;	state Exp;
branches;
next	;

1.61.2.1
date	2005.01.11.04.40.30;	author brad;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2005.03.20.23.44.06;	author brad;	state Exp;
branches;
next	;

1.65.2.1
date	2005.01.11.04.36.24;	author brad;	state Exp;
branches;
next	1.65.2.2;

1.65.2.2
date	2005.03.20.23.36.11;	author brad;	state Exp;
branches;
next	;

1.81.2.1
date	2008.02.21.17.34.26;	author henning;	state Exp;
branches;
next	;

1.83.2.1
date	2008.02.21.15.53.16;	author henning;	state Exp;
branches;
next	;


desc
@@


1.124
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@/*	$OpenBSD: tcp_var.h,v 1.123 2017/03/13 20:18:21 claudio Exp $	*/
/*	$NetBSD: tcp_var.h,v 1.17 1996/02/13 23:44:24 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tcp_var.h	8.3 (Berkeley) 4/10/94
 */

#ifndef _NETINET_TCP_VAR_H_
#define _NETINET_TCP_VAR_H_

#include <sys/timeout.h>

/*
 * Kernel variables for tcp.
 */

struct sackblk {
	tcp_seq start;		/* start seq no. of sack block */
	tcp_seq end; 		/* end seq no. */
};

struct sackhole {
	tcp_seq start;		/* start seq no. of hole */
	tcp_seq end;		/* end seq no. */
	int	dups;		/* number of dup(s)acks for this hole */
	tcp_seq rxmit;		/* next seq. no in hole to be retransmitted */
	struct sackhole *next;	/* next in list */
};

/*
 * TCP sequence queue structures.
 */
TAILQ_HEAD(tcpqehead, tcpqent);
struct tcpqent {
	TAILQ_ENTRY(tcpqent) tcpqe_q;
	struct tcphdr	*tcpqe_tcp;
	struct mbuf	*tcpqe_m;	/* mbuf contains packet */
};

/*
 * Tcp control block, one per tcp; fields:
 */
struct tcpcb {
	struct tcpqehead t_segq;		/* sequencing queue */
	struct timeout t_timer[TCPT_NTIMERS];	/* tcp timers */
	short	t_state;		/* state of this connection */
	short	t_rxtshift;		/* log(2) of rexmt exp. backoff */
	short	t_rxtcur;		/* current retransmit value */
	short	t_dupacks;		/* consecutive dup acks recd */
	u_short	t_maxseg;		/* maximum segment size */
	char	t_force;		/* 1 if forcing out a byte */
	u_int	t_flags;
#define	TF_ACKNOW	0x0001		/* ack peer immediately */
#define	TF_DELACK	0x0002		/* ack, but try to delay it */
#define	TF_NODELAY	0x0004		/* don't delay packets to coalesce */
#define	TF_NOOPT	0x0008		/* don't use tcp options */
#define	TF_SENTFIN	0x0010		/* have sent FIN */
#define	TF_REQ_SCALE	0x0020		/* have/will request window scaling */
#define	TF_RCVD_SCALE	0x0040		/* other side has requested scaling */
#define	TF_REQ_TSTMP	0x0080		/* have/will request timestamps */
#define	TF_RCVD_TSTMP	0x0100		/* a timestamp was received in SYN */
#define	TF_SACK_PERMIT	0x0200		/* other side said I could SACK */
#define	TF_SIGNATURE	0x0400		/* require TCP MD5 signature */
#ifdef TCP_ECN
#define TF_ECN_PERMIT	0x00008000	/* other side said I could ECN */
#define TF_RCVD_CE	0x00010000	/* send ECE in subsequent segs */
#define TF_SEND_CWR	0x00020000	/* send CWR in next seg */
#define TF_DISABLE_ECN	0x00040000	/* disable ECN for this connection */
#endif
#define TF_LASTIDLE	0x00100000	/* no outstanding ACK on last send */
#define TF_DEAD		0x00200000	/* dead and to-be-released */
#define TF_PMTUD_PEND	0x00400000	/* Path MTU Discovery pending */
#define TF_NEEDOUTPUT	0x00800000	/* call tcp_output after tcp_input */
#define TF_BLOCKOUTPUT	0x01000000	/* avert tcp_output during tcp_input */
#define TF_NOPUSH	0x02000000	/* don't push */

	struct	mbuf *t_template;	/* skeletal packet for transmit */
	struct	inpcb *t_inpcb;		/* back pointer to internet pcb */
	struct	timeout t_delack_to;	/* delayed ACK callback */
/*
 * The following fields are used as in the protocol specification.
 * See RFC793, Dec. 1981, page 21.
 */
/* send sequence variables */
	tcp_seq	snd_una;		/* send unacknowledged */
	tcp_seq	snd_nxt;		/* send next */
	tcp_seq	snd_up;			/* send urgent pointer */
	tcp_seq	snd_wl1;		/* window update seg seq number */
	tcp_seq	snd_wl2;		/* window update seg ack number */
	tcp_seq	iss;			/* initial send sequence number */
	u_long	snd_wnd;		/* send window */
#if 1 /*def TCP_SACK*/
	int	sack_enable;		/* enable SACK for this connection */
	int	snd_numholes;		/* number of holes seen by sender */
	struct sackhole *snd_holes;	/* linked list of holes (sorted) */
#if 1 /*defined(TCP_SACK) && defined(TCP_FACK)*/
	tcp_seq snd_fack;		/* for FACK congestion control */
	u_long	snd_awnd;		/* snd_nxt - snd_fack + */
					/* retransmitted data */
	int retran_data;		/* amount of outstanding retx. data  */
#endif /* TCP_FACK */
#endif /* TCP_SACK */
#if 1 /*defined(TCP_SACK) || defined(TCP_ECN)*/
	tcp_seq snd_last;		/* for use in fast recovery */
#endif
/* receive sequence variables */
	u_long	rcv_wnd;		/* receive window */
	tcp_seq	rcv_nxt;		/* receive next */
	tcp_seq	rcv_up;			/* receive urgent pointer */
	tcp_seq	irs;			/* initial receive sequence number */
#if 1 /*def TCP_SACK*/
	tcp_seq rcv_lastsack;		/* last seq number(+1) sack'd by rcv'r*/
	int	rcv_numsacks;		/* # distinct sack blks present */
	struct sackblk sackblks[MAX_SACK_BLKS]; /* seq nos. of sack blocks */
#endif

/*
 * Additional variables for this implementation.
 */
/* receive variables */
	tcp_seq	rcv_adv;		/* advertised window */
/* retransmit variables */
	tcp_seq	snd_max;		/* highest sequence number sent;
					 * used to recognize retransmits
					 */
/* congestion control (for slow start, source quench, retransmit after loss) */
	u_long	snd_cwnd;		/* congestion-controlled window */
	u_long	snd_ssthresh;		/* snd_cwnd size threshold for
					 * for slow start exponential to
					 * linear switch
					 */

/* auto-sizing variables */
	u_int	rfbuf_cnt;	/* recv buffer autoscaling byte count */
	u_int32_t rfbuf_ts;	/* recv buffer autoscaling time stamp */

	u_short	t_maxopd;		/* mss plus options */
	u_short	t_peermss;		/* peer's maximum segment size */

/*
 * transmit timing stuff.  See below for scale of srtt and rttvar.
 * "Variance" is actually smoothed difference.
 */
	uint32_t t_rcvtime;		/* time last segment received */
	uint32_t t_rtttime;		/* time we started measuring rtt */
	tcp_seq	t_rtseq;		/* sequence number being timed */
	short	t_srtt;			/* smoothed round-trip time */
	short	t_rttvar;		/* variance in round-trip time */
	u_short	t_rttmin;		/* minimum rtt allowed */
	u_long	max_sndwnd;		/* largest window peer has offered */

/* out-of-band data */
	char	t_oobflags;		/* have some */
	char	t_iobc;			/* input character */
#define	TCPOOB_HAVEDATA	0x01
#define	TCPOOB_HADDATA	0x02
	short	t_softerror;		/* possible error not yet reported */

/* RFC 1323 variables */
	u_char	snd_scale;		/* window scaling for send window */
	u_char	rcv_scale;		/* window scaling for recv window */
	u_char	request_r_scale;	/* pending window scaling */
	u_char	requested_s_scale;
	u_int32_t ts_recent;		/* timestamp echo data */
	u_int32_t ts_modulate;		/* modulation on timestamp */
	u_int32_t ts_recent_age;		/* when last updated */
	tcp_seq	last_ack_sent;

/* pointer for syn cache entries*/
	LIST_HEAD(, syn_cache) t_sc;	/* list of entries by this tcb */

/* Path-MTU Discovery Information */
	u_int	t_pmtud_mss_acked;	/* MSS acked, lower bound for MTU */
	u_int	t_pmtud_mtu_sent;	/* MTU used, upper bound for MTU */
	tcp_seq	t_pmtud_th_seq;		/* TCP SEQ from ICMP payload */
	u_int	t_pmtud_nextmtu;	/* Advertised Next-Hop MTU from ICMP */
	u_short	t_pmtud_ip_len;		/* IP length from ICMP payload */
	u_short	t_pmtud_ip_hl;		/* IP header length from ICMP payload */

	int pf;

	struct	timeout t_reap_to;	/* delayed cleanup timeout */
};

#define	intotcpcb(ip)	((struct tcpcb *)(ip)->inp_ppcb)
#define	sototcpcb(so)	(intotcpcb(sotoinpcb(so)))

#ifdef _KERNEL
extern int tcp_delack_ticks;
void	tcp_delack(void *);

#define TCP_INIT_DELACK(tp)						\
	timeout_set_proc(&(tp)->t_delack_to, tcp_delack, tp)

#define TCP_RESTART_DELACK(tp)						\
	timeout_add(&(tp)->t_delack_to, tcp_delack_ticks)

#define	TCP_SET_DELACK(tp)						\
do {									\
	if (((tp)->t_flags & TF_DELACK) == 0) {				\
		(tp)->t_flags |= TF_DELACK;				\
		TCP_RESTART_DELACK(tp);					\
	}								\
} while (/* CONSTCOND */ 0)

#define	TCP_CLEAR_DELACK(tp)						\
do {									\
	if ((tp)->t_flags & TF_DELACK) {				\
		(tp)->t_flags &= ~TF_DELACK;				\
		timeout_del(&(tp)->t_delack_to);			\
	}								\
} while (/* CONSTCOND */ 0)

/*
 * Handy way of passing around TCP option info.
 */
struct tcp_opt_info {
	int		ts_present;
	u_int32_t	ts_val;
	u_int32_t	ts_ecr;
	u_int16_t	maxseg;
};

/*
 * Data for the TCP compressed state engine.
 */

#define	TCP_SYN_HASH_SIZE	293
#define	TCP_SYN_BUCKET_SIZE	35

union syn_cache_sa {
	struct sockaddr sa;
	struct sockaddr_in sin;
	struct sockaddr_in6 sin6;
};

struct syn_cache {
	TAILQ_ENTRY(syn_cache) sc_bucketq;	/* link on bucket list */
	struct timeout sc_timer;		/* rexmt timer */
	union {					/* cached route */
		struct route route4;
#ifdef INET6
		struct route_in6 route6;
#endif
	} sc_route_u;
#define sc_route4	sc_route_u.route4
#ifdef INET6
#define sc_route6	sc_route_u.route6
#endif
	long sc_win;				/* advertised window */
	struct syn_cache_head *sc_buckethead;	/* our bucket index */
	struct syn_cache_set *sc_set;		/* our syn cache set */
	u_int32_t sc_hash;
	u_int32_t sc_timestamp;			/* timestamp from SYN */
	u_int32_t sc_modulate;			/* our timestamp modulator */
#if 0
	u_int32_t sc_timebase;			/* our local timebase */
#endif
	union syn_cache_sa sc_src;
	union syn_cache_sa sc_dst;
	tcp_seq sc_irs;
	tcp_seq sc_iss;
	u_int sc_rtableid;
	u_int sc_rxtcur;			/* current rxt timeout */
	u_int sc_rxttot;			/* total time spend on queues */
	u_short sc_rxtshift;			/* for computing backoff */
	u_short sc_flags;

#define	SCF_UNREACH		0x0001		/* we've had an unreach error */
#define	SCF_TIMESTAMP		0x0002		/* peer will do timestamps */
#define	SCF_DEAD		0x0004		/* this entry to be released */
#define	SCF_SACK_PERMIT		0x0008		/* permit sack */
#define	SCF_ECN_PERMIT		0x0010		/* permit ecn */
#define	SCF_SIGNATURE		0x0020		/* enforce tcp signatures */

	struct mbuf *sc_ipopts;			/* IP options */
	u_int16_t sc_peermaxseg;
	u_int16_t sc_ourmaxseg;
	u_int     sc_request_r_scale	: 4,
		  sc_requested_s_scale	: 4;

	struct tcpcb *sc_tp;			/* tcb for listening socket */
	LIST_ENTRY(syn_cache) sc_tpq;		/* list of entries by same tp */
};

struct syn_cache_head {
	TAILQ_HEAD(, syn_cache) sch_bucket;	/* bucket entries */
	u_short sch_length;			/* # entries in bucket */
};

struct syn_cache_set {
	struct		syn_cache_head *scs_buckethead;
	int		scs_size;
	int		scs_count;
	int		scs_use;
	u_int32_t	scs_random[5];
};

#endif /* _KERNEL */

/*
 * The smoothed round-trip time and estimated variance
 * are stored as fixed point numbers scaled by the values below.
 * For convenience, these scales are also used in smoothing the average
 * (smoothed = (1/scale)sample + ((scale-1)/scale)smoothed).
 * With these scales, srtt has 5 bits to the right of the binary point,
 * and thus an "ALPHA" of 0.875.  rttvar has 4 bits to the right of the
 * binary point, and is smoothed with an ALPHA of 0.75.
 */
#define	TCP_RTT_SHIFT		3	/* shift for srtt; 5 bits frac. */
#define	TCP_RTTVAR_SHIFT	2	/* shift for rttvar; 4 bits */
#define	TCP_RTT_BASE_SHIFT	2	/* remaining 2 bit shift */
#define	TCP_RTT_MAX		(1<<9)	/* maximum rtt */

/*
 * The initial retransmission should happen at rtt + 4 * rttvar.
 * Because of the way we do the smoothing, srtt and rttvar
 * will each average +1/2 tick of bias.  When we compute
 * the retransmit timer, we want 1/2 tick of rounding and
 * 1 extra tick because of +-1/2 tick uncertainty in the
 * firing of the timer.  The bias will give us exactly the
 * 1.5 tick we need.  But, because the bias is
 * statistical, we have to test that we don't drop below
 * the minimum feasible timer (which is 2 ticks).
 * This macro assumes that the value of (1 << TCP_RTTVAR_SHIFT)
 * is the same as the multiplier for rttvar.
 */
#define	TCP_REXMTVAL(tp) \
	((((tp)->t_srtt >> TCP_RTT_SHIFT) + (tp)->t_rttvar) >> TCP_RTT_BASE_SHIFT)

/*
 * TCP statistics.
 * Many of these should be kept per connection,
 * but that's inconvenient at the moment.
 */
struct	tcpstat {
	u_int32_t tcps_connattempt;	/* connections initiated */
	u_int32_t tcps_accepts;		/* connections accepted */
	u_int32_t tcps_connects;	/* connections established */
	u_int32_t tcps_drops;		/* connections dropped */
	u_int32_t tcps_conndrops;	/* embryonic connections dropped */
	u_int32_t tcps_closed;		/* conn. closed (includes drops) */
	u_int32_t tcps_segstimed;	/* segs where we tried to get rtt */
	u_int32_t tcps_rttupdated;	/* times we succeeded */
	u_int32_t tcps_delack;		/* delayed acks sent */
	u_int32_t tcps_timeoutdrop;	/* conn. dropped in rxmt timeout */
	u_int32_t tcps_rexmttimeo;	/* retransmit timeouts */
	u_int32_t tcps_persisttimeo;	/* persist timeouts */
	u_int32_t tcps_persistdrop;	/* connections dropped in persist */
	u_int32_t tcps_keeptimeo;	/* keepalive timeouts */
	u_int32_t tcps_keepprobe;	/* keepalive probes sent */
	u_int32_t tcps_keepdrops;	/* connections dropped in keepalive */

	u_int32_t tcps_sndtotal;		/* total packets sent */
	u_int32_t tcps_sndpack;		/* data packets sent */
	u_int64_t tcps_sndbyte;		/* data bytes sent */
	u_int32_t tcps_sndrexmitpack;	/* data packets retransmitted */
	u_int64_t tcps_sndrexmitbyte;	/* data bytes retransmitted */
	u_int64_t tcps_sndrexmitfast;	/* Fast retransmits */
	u_int32_t tcps_sndacks;		/* ack-only packets sent */
	u_int32_t tcps_sndprobe;	/* window probes sent */
	u_int32_t tcps_sndurg;		/* packets sent with URG only */
	u_int32_t tcps_sndwinup;	/* window update-only packets sent */
	u_int32_t tcps_sndctrl;		/* control (SYN|FIN|RST) packets sent */

	u_int32_t tcps_rcvtotal;	/* total packets received */
	u_int32_t tcps_rcvpack;		/* packets received in sequence */
	u_int64_t tcps_rcvbyte;		/* bytes received in sequence */
	u_int32_t tcps_rcvbadsum;	/* packets received with ccksum errs */
	u_int32_t tcps_rcvbadoff;	/* packets received with bad offset */
	u_int32_t tcps_rcvmemdrop;	/* packets dropped for lack of memory */
	u_int32_t tcps_rcvnosec;	/* packets dropped for lack of ipsec */
	u_int32_t tcps_rcvshort;	/* packets received too short */
	u_int32_t tcps_rcvduppack;	/* duplicate-only packets received */
	u_int64_t tcps_rcvdupbyte;	/* duplicate-only bytes received */
	u_int32_t tcps_rcvpartduppack;	/* packets with some duplicate data */
	u_int64_t tcps_rcvpartdupbyte;	/* dup. bytes in part-dup. packets */
	u_int32_t tcps_rcvoopack;	/* out-of-order packets received */
	u_int64_t tcps_rcvoobyte;	/* out-of-order bytes received */
	u_int32_t tcps_rcvpackafterwin;	/* packets with data after window */
	u_int64_t tcps_rcvbyteafterwin;	/* bytes rcvd after window */
	u_int32_t tcps_rcvafterclose;	/* packets rcvd after "close" */
	u_int32_t tcps_rcvwinprobe;	/* rcvd window probe packets */
	u_int32_t tcps_rcvdupack;	/* rcvd duplicate acks */
	u_int32_t tcps_rcvacktoomuch;	/* rcvd acks for unsent data */
	u_int32_t tcps_rcvacktooold;	/* rcvd acks for old data */
	u_int32_t tcps_rcvackpack;	/* rcvd ack packets */
	u_int64_t tcps_rcvackbyte;	/* bytes acked by rcvd acks */
	u_int32_t tcps_rcvwinupd;	/* rcvd window update packets */
	u_int32_t tcps_pawsdrop;	/* segments dropped due to PAWS */
	u_int32_t tcps_predack;		/* times hdr predict ok for acks */
	u_int32_t tcps_preddat;		/* times hdr predict ok for data pkts */

	u_int32_t tcps_pcbhashmiss;	/* input packets missing pcb hash */
	u_int32_t tcps_noport;		/* no socket on port */
	u_int32_t tcps_badsyn;		/* SYN packet with src==dst rcv'ed */
	u_int32_t tcps_dropsyn;		/* SYN packet dropped */

	u_int32_t tcps_rcvbadsig;	/* rcvd bad/missing TCP signatures */
	u_int64_t tcps_rcvgoodsig;	/* rcvd good TCP signatures */
	u_int32_t tcps_inswcsum;	/* input software-checksummed packets */
	u_int32_t tcps_outswcsum;	/* output software-checksummed packets */

	/* ECN stats */
	u_int32_t tcps_ecn_accepts;	/* ecn connections accepted */
	u_int32_t tcps_ecn_rcvece;	/* # of rcvd ece */
	u_int32_t tcps_ecn_rcvcwr;	/* # of rcvd cwr */
	u_int32_t tcps_ecn_rcvce;	/* # of rcvd ce in ip header */
	u_int32_t tcps_ecn_sndect;	/* # of cwr sent */
	u_int32_t tcps_ecn_sndece;	/* # of ece sent */
	u_int32_t tcps_ecn_sndcwr;	/* # of cwr sent */
	u_int32_t tcps_cwr_ecn;		/* # of cwnd reduced by ecn */
	u_int32_t tcps_cwr_frecovery;	/* # of cwnd reduced by fastrecovery */
	u_int32_t tcps_cwr_timeout;	/* # of cwnd reduced by timeout */

	/* These statistics deal with the SYN cache. */
	u_int64_t tcps_sc_added;	/* # of entries added */
	u_int64_t tcps_sc_completed;	/* # of connections completed */
	u_int64_t tcps_sc_timed_out;	/* # of entries timed out */
	u_int64_t tcps_sc_overflowed;	/* # dropped due to overflow */
	u_int64_t tcps_sc_reset;	/* # dropped due to RST */
	u_int64_t tcps_sc_unreach;	/* # dropped due to ICMP unreach */
	u_int64_t tcps_sc_bucketoverflow;/* # dropped due to bucket overflow */
	u_int64_t tcps_sc_aborted;	/* # of entries aborted (no mem) */
	u_int64_t tcps_sc_dupesyn;	/* # of duplicate SYNs received */
	u_int64_t tcps_sc_dropped;	/* # of SYNs dropped (no route/mem) */
	u_int64_t tcps_sc_collisions;	/* # of hash collisions */
	u_int64_t tcps_sc_retransmitted;/* # of retransmissions */
	u_int64_t tcps_sc_seedrandom;	/* # of syn cache seeds with random */
	u_int64_t tcps_sc_hash_size;	/* hash buckets in current syn cache */
	u_int64_t tcps_sc_entry_count;	/* # of entries in current syn cache */
	u_int64_t tcps_sc_entry_limit;	/* limit of syn cache entries */
	u_int64_t tcps_sc_bucket_maxlen;/* maximum # of entries in any bucket */
	u_int64_t tcps_sc_bucket_limit;	/* limit of syn cache bucket list */
	u_int64_t tcps_sc_uses_left;	/* use counter of current syn cache */

	u_int64_t tcps_conndrained;	/* # of connections drained */

	u_int64_t tcps_sack_recovery_episode;	/* SACK recovery episodes */
	u_int64_t tcps_sack_rexmits;		/* SACK rexmit segments */
	u_int64_t tcps_sack_rexmit_bytes;	/* SACK rexmit bytes */
	u_int64_t tcps_sack_rcv_opts;		/* SACK options received */
	u_int64_t tcps_sack_snd_opts;		/* SACK options sent */
};

/*
 * Names for TCP sysctl objects.
 */

#define	TCPCTL_RFC1323		1 /* enable/disable RFC1323 timestamps/scaling */
#define	TCPCTL_KEEPINITTIME	2 /* TCPT_KEEP value */
#define TCPCTL_KEEPIDLE		3 /* allow tcp_keepidle to be changed */
#define TCPCTL_KEEPINTVL	4 /* allow tcp_keepintvl to be changed */
#define TCPCTL_SLOWHZ		5 /* return kernel idea of PR_SLOWHZ */
#define TCPCTL_BADDYNAMIC	6 /* return bad dynamic port bitmap */
#define	TCPCTL_RECVSPACE	7 /* receive buffer space */
#define	TCPCTL_SENDSPACE	8 /* send buffer space */
#define	TCPCTL_IDENT		9 /* get connection owner */
#define	TCPCTL_SACK	       10 /* selective acknowledgement, rfc 2018 */
#define TCPCTL_MSSDFLT	       11 /* Default maximum segment size */
#define	TCPCTL_RSTPPSLIMIT     12 /* RST pps limit */
#define	TCPCTL_ACK_ON_PUSH     13 /* ACK immediately on PUSH */
#define	TCPCTL_ECN	       14 /* RFC3168 ECN */
#define	TCPCTL_SYN_CACHE_LIMIT 15 /* max size of comp. state engine */
#define	TCPCTL_SYN_BUCKET_LIMIT	16 /* max size of hash bucket */
#define	TCPCTL_RFC3390	       17 /* enable/disable RFC3390 increased cwnd */
#define	TCPCTL_REASS_LIMIT     18 /* max entries for tcp reass queues */
#define	TCPCTL_DROP	       19 /* drop tcp connection */
#define	TCPCTL_SACKHOLE_LIMIT  20 /* max entries for tcp sack queues */
#define	TCPCTL_STATS	       21 /* TCP statistics */
#define	TCPCTL_ALWAYS_KEEPALIVE 22 /* assume SO_KEEPALIVE is always set */
#define	TCPCTL_SYN_USE_LIMIT   23 /* number of uses before reseeding hash */
#define TCPCTL_ROOTONLY	       24 /* return root only port bitmap */
#define	TCPCTL_SYN_HASH_SIZE   25 /* number of buckets in the hash */
#define	TCPCTL_MAXID	       26

#define	TCPCTL_NAMES { \
	{ 0, 0 }, \
	{ "rfc1323",	CTLTYPE_INT }, \
	{ "keepinittime",	CTLTYPE_INT }, \
	{ "keepidle",	CTLTYPE_INT }, \
	{ "keepintvl",	CTLTYPE_INT }, \
	{ "slowhz",	CTLTYPE_INT }, \
	{ "baddynamic", CTLTYPE_STRUCT }, \
	{ NULL,	0 }, \
	{ NULL,	0 }, \
	{ "ident", 	CTLTYPE_STRUCT }, \
	{ "sack",	CTLTYPE_INT }, \
	{ "mssdflt",	CTLTYPE_INT }, \
	{ "rstppslimit",	CTLTYPE_INT }, \
	{ "ackonpush",	CTLTYPE_INT }, \
	{ "ecn", 	CTLTYPE_INT }, \
	{ "syncachelimit", 	CTLTYPE_INT }, \
	{ "synbucketlimit", 	CTLTYPE_INT }, \
	{ "rfc3390", 	CTLTYPE_INT }, \
	{ "reasslimit", 	CTLTYPE_INT }, \
	{ "drop", 	CTLTYPE_STRUCT }, \
	{ "sackholelimit", 	CTLTYPE_INT }, \
	{ "stats",	CTLTYPE_STRUCT }, \
	{ "always_keepalive",	CTLTYPE_INT }, \
	{ "synuselimit", 	CTLTYPE_INT }, \
	{ "rootonly", CTLTYPE_STRUCT }, \
	{ "synhashsize", 	CTLTYPE_INT }, \
}

#define	TCPCTL_VARS { \
	NULL, \
	&tcp_do_rfc1323, \
	&tcptv_keep_init, \
	&tcp_keepidle, \
	&tcp_keepintvl, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	&tcp_mssdflt, \
	&tcp_rst_ppslim, \
	&tcp_ack_on_push, \
	NULL, \
	&tcp_syn_cache_limit, \
	&tcp_syn_bucket_limit, \
	&tcp_do_rfc3390, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL \
}

struct tcp_ident_mapping {
	struct sockaddr_storage faddr, laddr;
	int euid, ruid;
	u_int rdomain;
};

#ifdef _KERNEL

#include <sys/percpu.h>

enum tcpstat_counters {
	tcps_connattempt,
	tcps_accepts,
	tcps_connects,
	tcps_drops,
	tcps_conndrops,
	tcps_closed,
	tcps_segstimed,
	tcps_rttupdated,
	tcps_delack,
	tcps_timeoutdrop,
	tcps_rexmttimeo,
	tcps_persisttimeo,
	tcps_persistdrop,
	tcps_keeptimeo,
	tcps_keepprobe,
	tcps_keepdrops,
	tcps_sndtotal,
	tcps_sndpack,
	tcps_sndbyte,
	tcps_sndrexmitpack,
	tcps_sndrexmitbyte,
	tcps_sndrexmitfast,
	tcps_sndacks,
	tcps_sndprobe,
	tcps_sndurg,
	tcps_sndwinup,
	tcps_sndctrl,
	tcps_rcvtotal,
	tcps_rcvpack,
	tcps_rcvbyte,
	tcps_rcvbadsum,
	tcps_rcvbadoff,
	tcps_rcvmemdrop,
	tcps_rcvnosec,
	tcps_rcvshort,
	tcps_rcvduppack,
	tcps_rcvdupbyte,
	tcps_rcvpartduppack,
	tcps_rcvpartdupbyte,
	tcps_rcvoopack,
	tcps_rcvoobyte,
	tcps_rcvpackafterwin,
	tcps_rcvbyteafterwin,
	tcps_rcvafterclose,
	tcps_rcvwinprobe,
	tcps_rcvdupack,
	tcps_rcvacktoomuch,
	tcps_rcvacktooold,
	tcps_rcvackpack,
	tcps_rcvackbyte,
	tcps_rcvwinupd,
	tcps_pawsdrop,
	tcps_predack,
	tcps_preddat,
	tcps_pcbhashmiss,
	tcps_noport,
	tcps_badsyn,
	tcps_dropsyn,
	tcps_rcvbadsig,
	tcps_rcvgoodsig,
	tcps_inswcsum,
	tcps_outswcsum,
	tcps_ecn_accepts,
	tcps_ecn_rcvece,
	tcps_ecn_rcvcwr,
	tcps_ecn_rcvce,
	tcps_ecn_sndect,
	tcps_ecn_sndece,
	tcps_ecn_sndcwr,
	tcps_cwr_ecn,
	tcps_cwr_frecovery,
	tcps_cwr_timeout,
	tcps_sc_added,
	tcps_sc_completed,
	tcps_sc_timed_out,
	tcps_sc_overflowed,
	tcps_sc_reset,
	tcps_sc_unreach,
	tcps_sc_bucketoverflow,
	tcps_sc_aborted,
	tcps_sc_dupesyn,
	tcps_sc_dropped,
	tcps_sc_collisions,
	tcps_sc_retransmitted,
	tcps_sc_seedrandom,
	tcps_sc_hash_size,
	tcps_sc_entry_count,
	tcps_sc_entry_limit,
	tcps_sc_bucket_maxlen,
	tcps_sc_bucket_limit,
	tcps_sc_uses_left,
	tcps_conndrained,
	tcps_sack_recovery_episode,
	tcps_sack_rexmits,
	tcps_sack_rexmit_bytes,
	tcps_sack_rcv_opts,
	tcps_sack_snd_opts,
	tcps_ncounters,
};

extern struct cpumem *tcpcounters;

static inline void
tcpstat_inc(enum tcpstat_counters c)
{
	counters_inc(tcpcounters, c);
}

static inline void
tcpstat_add(enum tcpstat_counters c, uint64_t v)
{
	counters_add(tcpcounters, c, v);
}

static inline void
tcpstat_pkt(enum tcpstat_counters pcounter, enum tcpstat_counters bcounter,
    uint64_t v)
{
	counters_pkt(tcpcounters, pcounter, bcounter, v);
}

extern	struct inpcbtable tcbtable;	/* head of queue of active tcpcb's */
extern	u_int32_t tcp_now;		/* for RFC 1323 timestamps */
extern	int tcp_do_rfc1323;	/* enabled/disabled? */
extern	int tcptv_keep_init;	/* time to keep alive the initial SYN packet */
extern	int tcp_mssdflt;	/* default maximum segment size */
extern	int tcp_rst_ppslim;	/* maximum outgoing RST packet per second */
extern	int tcp_ack_on_push;	/* ACK immediately on PUSH */
#ifdef TCP_SACK
extern	int tcp_do_sack;	/* SACK enabled/disabled */
extern	struct pool sackhl_pool;
extern	int tcp_sackhole_limit;	/* max entries for tcp sack queues */
#endif
extern	int tcp_do_ecn;		/* RFC3168 ECN enabled/disabled? */
extern	int tcp_do_rfc3390;	/* RFC3390 Increasing TCP's Initial Window */

extern	struct pool tcpqe_pool;
extern	int tcp_reass_limit;	/* max entries for tcp reass queues */

extern	int tcp_syn_hash_size;  /* adjustable size of the hash array */
extern	int tcp_syn_cache_limit; /* max entries for compressed state engine */
extern	int tcp_syn_bucket_limit;/* max entries per hash bucket */
extern	int tcp_syn_use_limit;   /* number of uses before reseeding hash */
extern	struct syn_cache_set tcp_syn_cache[];
extern	int tcp_syn_cache_active; /* active syn cache, may be 0 or 1 */

void	 tcp_canceltimers(struct tcpcb *);
struct tcpcb *
	 tcp_close(struct tcpcb *);
void	 tcp_reaper(void *);
int	 tcp_freeq(struct tcpcb *);
#ifdef INET6
void	 tcp6_ctlinput(int, struct sockaddr *, u_int, void *);
#endif
void	 tcp_ctlinput(int, struct sockaddr *, u_int, void *);
int	 tcp_ctloutput(int, struct socket *, int, int, struct mbuf *);
struct tcpcb *
	 tcp_disconnect(struct tcpcb *);
struct tcpcb *
	 tcp_drop(struct tcpcb *, int);
int	 tcp_dooptions(struct tcpcb *, u_char *, int, struct tcphdr *,
		struct mbuf *, int, struct tcp_opt_info *, u_int);
void	 tcp_init(void);
int	 tcp_input(struct mbuf **, int *, int, int);
int	 tcp_mss(struct tcpcb *, int);
void	 tcp_mss_update(struct tcpcb *);
u_int	 tcp_hdrsz(struct tcpcb *);
void	 tcp_mtudisc(struct inpcb *, int);
void	 tcp_mtudisc_increase(struct inpcb *, int);
#ifdef INET6
void	tcp6_mtudisc(struct inpcb *, int);
void	tcp6_mtudisc_callback(struct sockaddr_in6 *, u_int);
#endif
struct tcpcb *
	 tcp_newtcpcb(struct inpcb *);
void	 tcp_notify(struct inpcb *, int);
int	 tcp_output(struct tcpcb *);
void	 tcp_pulloutofband(struct socket *, u_int, struct mbuf *, int);
int	 tcp_reass(struct tcpcb *, struct tcphdr *, struct mbuf *, int *);
void	 tcp_rscale(struct tcpcb *, u_long);
void	 tcp_respond(struct tcpcb *, caddr_t, struct tcphdr *, tcp_seq,
		tcp_seq, int, u_int);
void	 tcp_setpersist(struct tcpcb *);
void	 tcp_update_sndspace(struct tcpcb *);
void	 tcp_update_rcvspace(struct tcpcb *);
void	 tcp_slowtimo(void);
struct mbuf *
	 tcp_template(struct tcpcb *);
void	 tcp_trace(short, short, struct tcpcb *, caddr_t, int, int);
struct tcpcb *
	 tcp_usrclosed(struct tcpcb *);
int	 tcp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
int	 tcp_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
int	 tcp_attach(struct socket *, int);
void	 tcp_xmit_timer(struct tcpcb *, int);
void	 tcpdropoldhalfopen(struct tcpcb *, u_int16_t);
#ifdef TCP_SACK
void	 tcp_sack_option(struct tcpcb *,struct tcphdr *,u_char *,int);
void	 tcp_update_sack_list(struct tcpcb *tp, tcp_seq, tcp_seq);
void	 tcp_del_sackholes(struct tcpcb *, struct tcphdr *);
void	 tcp_clean_sackreport(struct tcpcb *tp);
void	 tcp_sack_adjust(struct tcpcb *tp);
struct sackhole *
	 tcp_sack_output(struct tcpcb *tp);
int	 tcp_sack_partialack(struct tcpcb *, struct tcphdr *);
#ifdef DEBUG
void	 tcp_print_holes(struct tcpcb *tp);
#endif
#endif /* TCP_SACK */
#if defined(TCP_SACK)
int	 tcp_newreno(struct tcpcb *, struct tcphdr *);
u_long	 tcp_seq_subtract(u_long, u_long );
#endif /* TCP_SACK */
#ifdef TCP_SIGNATURE
int	tcp_signature_apply(caddr_t, caddr_t, unsigned int);
int	tcp_signature(struct tdb *, int, struct mbuf *, struct tcphdr *,
	    int, int, char *);
#endif /* TCP_SIGNATURE */
void     tcp_set_iss_tsm(struct tcpcb *);

void	 syn_cache_unreach(struct sockaddr *, struct sockaddr *,
	   struct tcphdr *, u_int);
void	 syn_cache_init(void);
void	 syn_cache_cleanup(struct tcpcb *);

#endif /* _KERNEL */
#endif /* _NETINET_TCP_VAR_H_ */
@


1.123
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.122 2017/02/09 15:19:32 jca Exp $	*/
d736 1
a736 1
int	 tcp_input(struct mbuf **, int *, int);
@


1.122
log
@percpu counters for TCP stats

ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.121 2017/02/01 20:59:47 dhill Exp $	*/
a718 1
int	 tcp_attach(struct socket *);
d767 1
@


1.121
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.120 2017/01/29 19:58:47 bluhm Exp $	*/
d569 125
a694 1
extern	struct tcpstat tcpstat;	/* tcp statistics */
@


1.120
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.119 2017/01/26 13:03:47 bluhm Exp $	*/
d605 1
a605 1
int	 tcp_ctloutput(int, struct socket *, int, int, struct mbuf **);
@


1.119
log
@Reduce the difference between struct protosw and ip6protosw.  The
IPv4 pr_ctlinput functions did return a void pointer that was always
NULL and never used.  Make all functions void like in the IPv6 case.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.118 2017/01/25 17:34:31 bluhm Exp $	*/
d613 1
a613 4
#ifdef INET6
int	 tcp6_input(struct mbuf **, int *, int);
#endif
void	 tcp_input(struct mbuf *, int, int);
@


1.118
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.117 2016/11/16 08:50:33 mpi Exp $	*/
d604 1
a604 1
void	 *tcp_ctlinput(int, struct sockaddr *, u_int, void *);
@


1.117
log
@Kill recursive splsoftnet()s.

While here keep local definitions local.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.116 2016/10/04 13:54:32 mpi Exp $	*/
d616 1
a616 1
void	 tcp_input(struct mbuf *, ...);
@


1.116
log
@Convert timeouts that need a process context to timeout_set_proc(9).

The current reason is that rtalloc_mpath(9) inside ip_output() might
end up inserting a RTF_CLONED route and that require a write lock.

ok kettenis@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.115 2016/07/20 19:57:53 bluhm Exp $	*/
a672 3
int	 syn_cache_add(struct sockaddr *, struct sockaddr *,
		struct tcphdr *, unsigned int, struct socket *,
		struct mbuf *, u_char *, int, struct tcp_opt_info *, tcp_seq *);
a674 3
struct socket *syn_cache_get(struct sockaddr *, struct sockaddr *,
		struct tcphdr *, unsigned int, unsigned int,
		struct socket *so, struct mbuf *);
a675 7
void	 syn_cache_insert(struct syn_cache *, struct tcpcb *);
struct syn_cache *syn_cache_lookup(struct sockaddr *, struct sockaddr *,
		struct syn_cache_head **, u_int);
void	 syn_cache_reset(struct sockaddr *, struct sockaddr *,
		struct tcphdr *, u_int);
int	 syn_cache_respond(struct syn_cache *, struct mbuf *);
void	 syn_cache_timer(void *);
a676 1
void	 syn_cache_reaper(void *);
@


1.115
log
@To tune the TCP SYN cache we need more information.  Print the
relevant counters with netstat -s -p tcp.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.114 2016/07/20 09:15:28 bluhm Exp $	*/
d220 1
a220 1
	timeout_set(&(tp)->t_delack_to, tcp_delack, tp)
@


1.114
log
@Make the size for the syn cache hash array tunable.  As we are
swapping between two syn caches for random reseeding anyway, this
feature can be added easily.  When the cache is empty, there is an
opportunity to change the hash size.  This allows an admin under
SYN flood attack to defend his machine.
Suggested by claudio@@; OK jung@@ claudio@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.113 2016/06/18 10:36:13 vgross Exp $	*/
d457 6
d593 1
@


1.113
log
@Add net.inet.{tcp,udp}.rootonly sysctl, to mark which ports
cannot be bound to by non-root users.

Ok millert@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.112 2016/03/29 18:13:20 bluhm Exp $	*/
d319 5
a323 4
        struct		syn_cache_head scs_buckethead[TCP_SYN_HASH_SIZE];
        int		scs_count;
        int		scs_use;
        u_int32_t	scs_random[5];
d495 2
a496 1
#define	TCPCTL_MAXID	       25
d524 1
d552 1
d582 1
@


1.112
log
@Allow to adjust tcp_syn_use_limit with sysctl net.inet.tcp.synuselimit.
This is convenient to test the feature and may be useful to defend
against syn flooding in a denial of service condition.  It is
consistent to the existing syn cache sysctls.  Move some declarations
to tcp_var.h to access the syn cache sets from tcp_sysctl().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.111 2016/03/27 19:19:01 bluhm Exp $	*/
d493 2
a494 1
#define	TCPCTL_MAXID	       24
d521 1
d543 1
@


1.111
log
@To prevent attacks on the hash buckets of the syn cache, our TCP
stack reseeds the hash function every time the cache is empty.
Unfortunatly the attacker can prevent the reseeding by sending
unanswered SYN packes periodically.
Fix this by having an active syn cache that gets new entries and a
passive one that is idling out.  When the passive one is empty and
the active one has been used 100000 times, they switch roles and
the hash function is reseeded with new random.
tedu@@ agrees; OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.110 2016/03/21 15:52:27 bluhm Exp $	*/
d254 4
d318 7
d492 2
a493 1
#define	TCPCTL_MAXID	       23
d518 2
a519 1
	{ "always_keepalive",	CTLTYPE_INT } \
d544 2
d577 2
@


1.110
log
@Add a tcps_sc_seedrandom counter in TCP SYN cache and netstat -s.
This shows how often the hash function is reseeded and the random
bucket distribution changes.
OK mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.109 2015/08/27 20:56:16 bluhm Exp $	*/
d274 2
a275 1
	int sc_bucketidx;			/* our bucket index */
@


1.109
log
@The syn cache is completely implemented in tcp_input.c.  So all its
global variables should also live there.
OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.108 2015/08/24 15:37:03 bluhm Exp $	*/
d443 1
@


1.108
log
@Rename the syn cache counter into tcp_syn_cache_count to have the
same prefix for all variables.  Convert the counter type to int,
the limit is also int.  Before searching the cache, check that it
is not empty.  Do not access the counter outside of the syn cache
from tcp_ctlinput(), let the syn_cache_lookup() function handle it.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.107 2015/02/08 04:40:50 yasuoka Exp $	*/
a559 3

extern	int tcp_syn_cache_size;
extern	struct syn_cache_head tcp_syn_cache[];
@


1.107
log
@Count dropped SYN packets on the tcpstat.  They are dropped due to the
listen queue (backlog) limit or the memory shortage in syn-cache.

ok henning reyk claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.106 2015/01/21 22:23:52 deraadt Exp $	*/
a562 1
extern	u_long syn_cache_count;
@


1.106
log
@To satisfy kernel grovellers and bad (but document) sysctl
practice, be pragmatic and #include <sys/timeout.h> for
struct tcpb (glorious namespace violation)
ok kettenis millert sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.105 2014/01/23 23:51:29 henning Exp $	*/
d411 1
@


1.105
log
@since the cksum rewrite the counters for hardware checksummed packets
are are lie, since the software engine emulates hardware offloading
and that is later indistinguishable. so kill the hw cksummed counters.
introduce software checksummed packet counters instead.
tcp/udp handles ip & ipvshit, ip cksum covered, 6 has no ip layer cksum.
as before we still have a miscounting bug for inbound with pf on, to be
fixed in the next step.
found by, prodding & ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.103 2013/10/21 08:42:24 phessler Exp $	*/
d37 2
@


1.104
log
@remove historical #if 1
@
text
@d412 2
a413 2
	u_int32_t tcps_inhwcsum;	/* input hardware-checksummed packets */
	u_int32_t tcps_outhwcsum;	/* output hardware-checksummed packets */
@


1.103
log
@Sprinkle a lot more IPv6 routing domains support in the kernel.

Mostly mechanical, setting and passing the rdomain and rtable correctly.
Not yet enabled.

Lots of help and hints from claudio and bluhm

OK claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.102 2013/08/12 21:57:16 bluhm Exp $	*/
a254 1
#if 1 /*def INET6*/
a255 1
#endif
@


1.102
log
@Add the TCP socket option TCP_NOPUSH to delay sending the stream.
This is useful to aggregate data in the kernel from multiple sources
like writes and socket splicing.  It avoids sending small packets.
From FreeBSD via David Hill; OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.101 2013/06/01 16:22:05 bluhm Exp $	*/
d593 1
a593 1
void	tcp6_mtudisc_callback(struct in6_addr *);
@


1.101
log
@Pass the routing domain to IPv6 pr_ctlinput() like in IPv4.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.100 2013/04/10 08:50:59 mpi Exp $	*/
d100 1
@


1.100
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.99 2011/07/06 23:44:20 sthen Exp $	*/
d570 1
a570 1
void	 tcp6_ctlinput(int, struct sockaddr *, void *);
@


1.99
log
@Add sysctl net.inet.tcp.always_keepalive, when this is set the system
behaves as if SO_KEEPALIVE was set on all TCP sockets, forcing keepalives
to be sent every net.inet.tcp.keepidle half-seconds.

In conjunction with a keepidle value greatly reduced from the default,
this can be useful for keeping sessions open if you are stuck on a network
with short NAT or firewall timeouts.

Feedback from various people, ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.98 2011/01/07 17:50:42 bluhm Exp $	*/
d541 1
d543 1
@


1.98
log
@Add socket option SO_SPLICE to splice together two TCP sockets.
The data received on the source socket will automatically be sent
on the drain socket.  This allows to write relay daemons with zero
data copy.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.97 2010/10/21 11:38:27 bluhm Exp $	*/
d476 2
a477 1
#define	TCPCTL_MAXID	       22
d501 2
a502 1
	{ "stats",	CTLTYPE_STRUCT } \
@


1.97
log
@There is no TCP6 in our kernel, so remove the #ifndef TCP6.
No binary change.
ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.96 2010/09/24 02:59:46 claudio Exp $	*/
d98 2
@


1.96
log
@TCP send and recv buffer scaling.
Send buffer is scaled by not accounting unacknowledged on the wire
data against the buffer limit. Receive buffer scaling is done similar
to FreeBSD -- measure the delay * bandwith product and base the
buffer on that. The problem is that our RTT measurment is coarse
so it overshoots on low delay links. This does not matter that much
since the recvbuffer is almost always empty.
Add a back pressure mechanism to control the amount of memory
assigned to socketbuffers that kicks in when 80% of the cluster
pool is used.
Increases the download speed from 300kB/s to 4.4MB/s on ftp.eu.openbsd.org.

Based on work by markus@@ and djm@@.

OK dlg@@, henning@@, put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.95 2010/07/09 16:58:06 reyk Exp $	*/
d563 1
a563 1
#if defined(INET6) && !defined(TCP6)
d575 1
a575 1
#if defined(INET6) && !defined(TCP6)
@


1.95
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.94 2010/07/03 04:44:51 guenther Exp $	*/
d154 5
d484 2
a485 2
	{ "recvspace",	CTLTYPE_INT }, \
	{ "sendspace",	CTLTYPE_INT }, \
d509 2
a510 2
	&tcp_recvspace, \
	&tcp_sendspace, \
d598 2
@


1.94
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.93 2009/11/13 20:54:05 claudio Exp $	*/
d568 1
a568 1
		struct mbuf *, int, struct tcp_opt_info *);
@


1.93
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.92 2009/08/10 10:13:43 claudio Exp $	*/
d277 1
a277 1
	u_int sc_rdomain;
@


1.92
log
@sockets created via a listening socket lose the rdomain and fail to work
therefore. Inherit the rdomain through the syncache.
There are some interactions that need some more work (ctlinput) so this
can be improved but is good enough for now.
OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.91 2009/06/05 00:05:22 claudio Exp $	*/
d561 1
a561 1
void	 *tcp_ctlinput(int, struct sockaddr *, void *);
d591 1
a591 1
		tcp_seq, int);
@


1.91
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.90 2008/11/08 12:54:58 dlg Exp $	*/
d277 1
d632 1
a632 1
	   struct tcphdr *);
d639 1
a639 1
		struct syn_cache_head **);
d641 1
a641 1
		struct tcphdr *);
@


1.90
log
@fix macros up so they use the do { } while (/* CONSTCOND */ 0) idiom

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.88 2008/05/23 15:51:12 thib Exp $	*/
d523 1
@


1.89
log
@Remove {tcp/udp}6_usrreq(); Since the normal ones now
take a proc argument, theres no need for these, since
they are just wrappers.

OK claudio@@
@
text
@d221 1
a221 1
} while (/*CONSTCOND*/0)
d229 1
a229 1
} while (/*CONSTCOND*/0)
@


1.88
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.87 2008/05/06 08:47:36 markus Exp $	*/
a597 4
#if defined(INET6) && !defined(TCP6)
int	 tcp6_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
#endif
@


1.87
log
@remove tcp_drain code since it's not longer used; ok henning, feedback thib
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.86 2008/02/20 14:23:31 markus Exp $	*/
d603 1
a603 1
	    int, struct mbuf *, struct mbuf *, struct mbuf *);
@


1.86
log
@remove old unused TCP isn code; ok henning, dhartmei, mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.85 2008/02/20 11:24:03 markus Exp $	*/
a94 1
#define TF_REASSLOCK	0x00080000	/* reassembling or draining */
a303 29
static __inline int tcp_reass_lock_try(struct tcpcb *);
static __inline void tcp_reass_unlock(struct tcpcb *);
#define tcp_reass_lock(tp) tcp_reass_lock_try(tp)

static __inline int
tcp_reass_lock_try(struct tcpcb *tp)
{
	int s;

	/* Use splvm() due to mbuf allocation. */
	s = splvm();
	if (tp->t_flags & TF_REASSLOCK) {
		splx(s);
		return (0);
	}
	tp->t_flags |= TF_REASSLOCK;
	splx(s);
	return (1);
}

static __inline void
tcp_reass_unlock(struct tcpcb *tp)
{
	int s;

	s = splvm();
	tp->t_flags &= ~TF_REASSLOCK;
	splx(s);
}
a566 1
void	 tcp_drain(void);
@


1.85
log
@when creating a response, use the correct TCP header instead of
relying on the mbuf chain layout; with claudio@@ and krw@@; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.84 2007/12/13 20:00:53 reyk Exp $	*/
a658 4
void	tcp_rndiss_init(void);
tcp_seq	tcp_rndiss_next(void);
u_int16_t
	tcp_rndiss_encrypt(u_int16_t);
@


1.84
log
@implement sysctls to report IP, TCP, UDP, and ICMP statistics and
change netstat to use them instead of accessing kvm for it. more
protocols will be added later.

discussed with deraadt@@ claudio@@ gilles@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.83 2007/06/25 12:17:43 markus Exp $	*/
d619 1
a619 1
void	 tcp_respond(struct tcpcb *, caddr_t, struct mbuf *, tcp_seq,
@


1.83
log
@merge tcp_set_iss() and tcp_set_tsm(); ok mcbride, djm (on earlier version)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.82 2007/06/15 18:23:07 markus Exp $	*/
d497 2
a498 1
#define	TCPCTL_MAXID	       21
d522 1
d544 1
@


1.83.2.1
log
@MFC (markus)
when creating a response, use the correct TCP header instead of
relying on the mbuf chain layout; with claudio@@ and krw@@; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.83 2007/06/25 12:17:43 markus Exp $	*/
d616 1
a616 1
void	 tcp_respond(struct tcpcb *, caddr_t, struct tcphdr *, tcp_seq,
@


1.82
log
@Drop the current random timestamps and the current ISN generation
code and replace both with a RFC1948 based method, so TCP clients
now have monotonic ISN/timestamps.  The server side uses completely
random ISN/timestamps and does time-wait recycling (on port reuse).
ok djm@@, mcbride@@; thanks to lots of testers
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.81 2007/02/01 19:55:37 jmc Exp $	*/
d660 1
a660 2
void     tcp_set_iss(struct tcpcb *);
void     tcp_set_tsm(struct tcpcb *);
@


1.81
log
@correct rfc; from Kris Katterjohn
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.80 2005/12/11 17:21:53 deraadt Exp $	*/
d660 2
d665 1
a665 1
		struct mbuf *, u_char *, int, struct tcp_opt_info *);
@


1.81.2.1
log
@MFC (markus)
when creating a response, use the correct TCP header instead of
relying on the mbuf chain layout; with claudio@@ and krw@@; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.81 2007/02/01 19:55:37 jmc Exp $	*/
d616 1
a616 1
void	 tcp_respond(struct tcpcb *, caddr_t, struct tcphdr *, tcp_seq,
@


1.80
log
@bitfields must be off an int or such type
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.79 2005/11/20 19:25:16 brad Exp $	*/
d105 1
a105 1
 * See RFC783, Dec. 1981, page 21.
@


1.79
log
@splimp -> splvm. mbuf allocation here.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.78 2005/11/15 21:09:46 miod Exp $	*/
d293 2
a294 2
	u_int8_t sc_request_r_scale	: 4,
		 sc_requested_s_scale	: 4;
@


1.78
log
@Only two `h' in threshold.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.77 2005/08/02 11:05:44 markus Exp $	*/
d314 2
a315 1
	s = splimp();
d330 1
a330 1
	s = splimp();
@


1.77
log
@change the TCP reass queue from LIST to TAILQ;
ok henning claudio fgsch krw
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.76 2005/07/04 12:34:12 markus Exp $	*/
d151 1
a151 1
	u_long	snd_ssthresh;		/* snd_cwnd size threshhold for
@


1.76
log
@remove TUBA, ok many
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.75 2005/06/30 08:51:31 markus Exp $	*/
d38 4
d56 1
a56 1
 * Kernel variables for tcp.
d58 6
d69 1
a69 1
	struct ipqehead segq;		/* sequencing queue */
@


1.75
log
@implement PMTU checks from
        http://www.gont.com.ar/drafts/icmp-attacks-against-tcp.html
i.e. don't act on ICMP-need-frag immediately if adhoc checks on the
advertised mtu fail.  the mtu update is delayed until a tcp retransmit
happens.  initial patch by Fernando Gont, tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.74 2005/05/24 00:02:37 fgont Exp $	*/
a178 3

/* TUBA stuff */
	caddr_t	t_tuba_pcb;		/* next level down pcb for TCP over z */
@


1.74
log
@Ignore ICMP Source Quench messages meant for TCP connections. (Details in
http://www.gont.com.ar/drafts/icmp-attacks-against-tcp.html)
ok markus frantzen
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.73 2005/04/05 20:27:35 markus Exp $	*/
d88 1
d183 8
d594 1
@


1.73
log
@add tcp sack stats, similar to freebsd; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.72 2005/03/09 11:14:38 markus Exp $	*/
a595 1
void	 tcp_quench(struct inpcb *, int);
@


1.72
log
@from freebsd:
1. set rcv_laststart/rcv_lastend after checking the tcp window
2. pass rcv_laststart and rcv_lastend on the stack (shrink tcp state)
ok henning, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.71 2005/03/04 13:21:42 markus Exp $	*/
d448 6
@


1.71
log
@- check th_ack against snd_una/max; from Raja Mukerji via hugh@@
- limit pool to tcp_sackhole_limit entries (sysctl-able)
- stop sack option processing on pool_get errors
- use SEQ_MIN/SEQ_MAX
ok henning, hshoexer, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.70 2005/02/27 13:22:56 markus Exp $	*/
a123 2
	tcp_seq rcv_laststart;		/* start of last segment recd. */
	tcp_seq rcv_lastend;		/* end of ... */
d613 1
a613 1
void	 tcp_update_sack_list(struct tcpcb *tp);
@


1.70
log
@1. tcp_xmit_timer(): remove extra rtt decrement (t_rtttime is 0-based
   while t_rtt was 1-based), update callers
2. define and use TCP_RTT_BASE_SHIFT instead of the hardcoded 2.
3. add missing shifts when t_srtt/t_rttvar are used.
4. update the comments: t_srtt uses 5 bits of fraction (not 3)
   and t_rttvar uses 4 bits
5. remove obsolete/unused macros TCP_RTT_SCALE and TCP_RTTVAR_SCALE
6. make sure rttmin is not > TCPTV_REXMTMAX
parts from netbsd, ok mcbride, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.69 2005/01/10 23:53:49 mcbride Exp $	*/
d475 2
a476 1
#define	TCPCTL_MAXID	       20
d499 1
d522 1
d541 1
d614 1
a614 1
int	 tcp_sack_option(struct tcpcb *,struct tcphdr *,u_char *,int);
@


1.69
log
@Make sure bogus values don't make their way into tcp_xmit_timer() calculations.
- Ignore ts_ecr if it is 0, or the resulting rtt is out of range.
  (use tp->t_rtttime instead)
- Initialise tcp_now to 1, to avoid the 500ms window where a valid ts_ecr
  of 0 could be ignored.
- Convert out-of-range rtt values to valid ones in tcp_xmit_timer().

ok frantzen@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.68 2004/11/25 15:32:08 markus Exp $	*/
d326 2
a327 2
 * With these scales, srtt has 3 bits to the right of the binary point,
 * and thus an "ALPHA" of 0.875.  rttvar has 2 bits to the right of the
d330 4
a333 5
#define	TCP_RTT_SCALE		8	/* multiplier for srtt; 3 bits frac. */
#define	TCP_RTT_SHIFT		3	/* shift for srtt; 3 bits frac. */
#define	TCP_RTTVAR_SCALE	4	/* multiplier for rttvar; 2 bits */
#define	TCP_RTTVAR_SHIFT	2	/* multiplier for rttvar; 2 bits */
#define TCP_RTT_MAX		(1<<9)	/* maximum rtt */
d345 1
a345 1
 * This macro assumes that the value of TCP_RTTVAR_SCALE
d349 1
a349 1
	((((tp)->t_srtt >> TCP_RTT_SHIFT) + (tp)->t_rttvar) >> 2)
@


1.68
log
@fix for race between invocation for timer and network input
1) add a reaper for TCP and SYN cache states (cf. netbsd pr 20390)
2) additional check for TCP_TIMER_ISARMED(TCPT_REXMT) in tcp_timer_persist()
with mickey@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.67 2004/10/28 19:22:52 mcbride Exp $	*/
d334 1
@


1.67
log
@Modulate tcp_now by a random amount on a per-connection basis.

ok markus@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.66 2004/09/16 13:14:28 markus Exp $	*/
d87 1
d185 2
d556 1
d653 1
@


1.66
log
@don't send partial segments if SS_ISSENDING is set, remember
TF_LASTIDLE across invocations of tcp_output (from freebsd);
ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.65 2004/07/15 15:27:22 markus Exp $	*/
d173 1
d253 1
@


1.65
log
@tcp_trace() expects short, not int; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.64 2004/06/08 19:47:24 markus Exp $	*/
d86 1
@


1.65.2.1
log
@MFC:
Fix by mcbride@@

Make sure bogus values don't make their way into tcp_xmit_timer() calculations.
- Convert out-of-range rtt values to valid ones in tcp_xmit_timer().

ok frantzen@@ markus@@ deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.65 2004/07/15 15:27:22 markus Exp $	*/
a327 1
#define TCP_RTT_MAX		(1<<9)	/* maximum rtt */
@


1.65.2.2
log
@MFC:
Fix by markus@@

- check th_ack against snd_una/max; from Raja Mukerji via hugh@@
- limit pool to tcp_sackhole_limit entries (sysctl-able)
- stop sack option processing on pool_get errors
- use SEQ_MIN/SEQ_MAX

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.65.2.1 2005/01/11 04:36:24 brad Exp $	*/
d470 1
a470 2
#define	TCPCTL_SACKHOLE_LIMIT  20 /* max entries for tcp sack queues */
#define	TCPCTL_MAXID	       21
a492 1
	{ "sackholelimit", 	CTLTYPE_INT }, \
a514 1
	NULL, \
a532 1
extern	int tcp_sackhole_limit;	/* max entries for tcp sack queues */
d604 1
a604 1
void	 tcp_sack_option(struct tcpcb *,struct tcphdr *,u_char *,int);
@


1.64
log
@factor out md5 code; ok+tests henning@@, djm@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.63 2004/04/25 04:34:05 markus Exp $	*/
d590 1
a590 1
void	 tcp_trace(int, int, struct tcpcb *, caddr_t, int, int);
@


1.63
log
@add TCPCTL_DROP; ok deraadt, cedric, grange, ...
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.62 2004/04/20 20:05:29 markus Exp $	*/
d621 2
@


1.62
log
@add tcps_rcvacktooold; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.61 2004/03/02 12:51:12 markus Exp $	*/
d468 2
a469 1
#define	TCPCTL_MAXID	       19
d491 1
d513 1
@


1.61
log
@limit total number of queued out-of-order packets to NMBCLUSTERS/2; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.60 2004/02/27 16:44:45 markus Exp $	*/
d400 1
@


1.61.2.1
log
@MFC:
Fix by mcbride@@

Make sure bogus values don't make their way into tcp_xmit_timer() calculations.
- Convert out-of-range rtt values to valid ones in tcp_xmit_timer().

ok frantzen@@ markus@@ deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.61 2004/03/02 12:51:12 markus Exp $	*/
a327 1
#define TCP_RTT_MAX		(1<<9)	/* maximum rtt */
@


1.61.2.2
log
@MFC:
Fix by markus@@

- check th_ack against snd_una/max; from Raja Mukerji via hugh@@
- limit pool to tcp_sackhole_limit entries (sysctl-able)
- stop sack option processing on pool_get errors
- use SEQ_MIN/SEQ_MAX

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.61.2.1 2005/01/11 04:40:30 brad Exp $	*/
d468 1
a468 2
#define	TCPCTL_SACKHOLE_LIMIT  19 /* max entries for tcp sack queues */
#define	TCPCTL_MAXID	       20
a489 1
	{ "sackholelimit", 	CTLTYPE_INT }, \
a510 1
	NULL, \
a528 1
extern	int tcp_sackhole_limit;	/* max entries for tcp sack queues */
d600 1
a600 1
void	 tcp_sack_option(struct tcpcb *,struct tcphdr *,u_char *,int);
@


1.60
log
@implement tcp_drain() similar to ip_drain(); ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.59 2004/02/27 16:28:24 markus Exp $	*/
d466 2
a467 1
#define	TCPCTL_MAXID	       18
d488 1
d509 2
a510 1
	&tcp_do_rfc3390 \
d532 3
d546 1
@


1.59
log
@API change; counter for upcoming tcp_drain(); ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.58 2004/02/15 11:16:08 markus Exp $	*/
d85 1
a85 1
#define TF_DEAD		0x00080000	/* dead and to-be-released */
a211 1
#endif /* _KERNEL */
a222 2
#ifdef _KERNEL

d284 29
@


1.58
log
@switch to sysctl_int_arr(); ok itojun, henning, miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.57 2004/01/31 19:40:10 markus Exp $	*/
d415 2
@


1.57
log
@!sack_disable -> sack_enable; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.56 2004/01/29 11:55:28 markus Exp $	*/
d459 21
@


1.56
log
@support for RFC3390 (Increasing TCP's Initial Window); ok deraadt, itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.55 2004/01/14 13:38:21 markus Exp $	*/
d103 1
a103 1
	int	sack_disable;		/* disable SACK for this connection */
@


1.55
log
@syncache+ipv6 support for TCP_SIGNATURE; with itojun; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.54 2004/01/13 13:26:14 markus Exp $	*/
d437 2
a438 1
#define	TCPCTL_MAXID	       17
d458 1
d478 1
@


1.54
log
@bring back the old TCP_SIGNATURE code from tcp_input.c rev 1.45
and make it compile (does not work yet); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.53 2004/01/07 19:20:14 markus Exp $	*/
d271 1
@


1.53
log
@syn_XXX_limit -> synXXXlimit for consistency; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.52 2004/01/06 17:38:13 markus Exp $	*/
d496 2
a497 2
void	 tcp_dooptions(struct tcpcb *, u_char *, int, struct tcphdr *,
		struct tcp_opt_info *);
@


1.52
log
@import netbsd's version of David Borman's syncache code
http://www.kohala.com/start/borman.97jun06.txt; ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.51 2003/06/09 07:40:25 itojun Exp $	*/
d454 2
a455 2
	{ "syn_cache_limit", 	CTLTYPE_INT }, \
	{ "syn_bucket_limit", 	CTLTYPE_INT }, \
@


1.51
log
@backout following:
>use m_pulldown not m_pullup2.  fix some bugs in IPv6 tcp_trace().

PR 3283 fixed (confirmed)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.50 2003/06/02 23:28:15 millert Exp $	*/
d85 1
d175 3
d215 74
d400 14
d434 3
a436 1
#define	TCPCTL_MAXID	       15
d454 2
d476 7
d497 1
a497 1
		int *, u_int32_t *, u_int32_t *);
d562 19
@


1.51.2.1
log
@MFC:
Fix by markus@@

implement tcp_drain() similar to ip_drain();

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.51 2003/06/09 07:40:25 itojun Exp $	*/
a83 1
#define TF_REASSLOCK	0x00080000	/* reassembling or draining */
a207 29

static __inline int tcp_reass_lock_try(struct tcpcb *);
static __inline void tcp_reass_unlock(struct tcpcb *);
#define tcp_reass_lock(tp) tcp_reass_lock_try(tp)

static __inline int
tcp_reass_lock_try(struct tcpcb *tp)
{
	int s;

	s = splimp();
	if (tp->t_flags & TF_REASSLOCK) {
		splx(s);
		return (0);
	}
	tp->t_flags |= TF_REASSLOCK;
	splx(s);
	return (1);
}

static __inline void
tcp_reass_unlock(struct tcpcb *tp)
{
	int s;

	s = splimp();
	tp->t_flags &= ~TF_REASSLOCK;
	splx(s);
}
a321 2

	u_int64_t tcps_conndrained;	/* # of connections drained */
@


1.51.2.2
log
@MFC:
Fix by markus@@

limit total number of queued out-of-order packets to NMBCLUSTERS/2;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.51.2.1 2004/03/03 02:35:26 brad Exp $	*/
d374 1
a374 2
#define	TCPCTL_REASS_LIMIT     15 /* max entries for tcp reass queues */
#define	TCPCTL_MAXID	       16
a391 1
	{ "reasslimit",	CTLTYPE_INT }, \
a411 3
extern	struct pool tcpqe_pool;
extern	int tcp_reass_limit;	/* max entries for tcp reass queues */

a415 1
int	 tcp_freeq(struct tcpcb *);
@


1.51.2.3
log
@fix location of define from rev 1.60 so a kernel can build without TCP_ECN
--
From: John L. Scarfone <j0 at cox dot net>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.51.2.2 2004/03/03 08:37:05 brad Exp $	*/
d84 1
a85 1
#define TF_REASSLOCK	0x00080000	/* reassembling or draining */
@


1.50
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.49 2003/05/29 00:35:18 itojun Exp $	*/
d423 1
a423 1
void	 tcp_trace(int, int, struct tcpcb *, struct mbuf *, int, int);
@


1.49
log
@use m_pulldown not m_pullup2.  fix some bugs in IPv6 tcp_trace().
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.48 2003/05/26 05:01:55 itojun Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.48
log
@fix tcpcb size to make trpt happy
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.47 2003/05/23 03:29:00 itojun Exp $	*/
d427 1
a427 1
void	 tcp_trace(int, int, struct tcpcb *, caddr_t, int, int);
@


1.47
log
@don't #ifdef within struct tcpcb definition, as it is used in userland too.
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.46 2003/05/12 00:48:52 jason Exp $	*/
d124 1
a124 1
#ifdef TCP_SACK
@


1.46
log
@Nuke a whole bunch of commons; ok tedu (still more to come *sigh*)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.45 2003/02/12 14:41:08 jason Exp $	*/
d105 1
a105 1
#ifdef TCP_SACK
d109 1
a109 1
#if defined(TCP_SACK) && defined(TCP_FACK)
d116 1
a116 1
#if defined(TCP_SACK) || defined(TCP_ECN)
@


1.45
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.44 2002/06/09 16:26:11 itojun Exp $	*/
d374 1
a374 1
u_int32_t tcp_now;		/* for RFC 1323 timestamps */
@


1.45.2.1
log
@MFC:
Fix by markus@@

implement tcp_drain() similar to ip_drain();

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.45 2003/02/12 14:41:08 jason Exp $	*/
a87 1
#define TF_REASSLOCK	0x00080000	/* reassembling or draining */
a211 29

static __inline int tcp_reass_lock_try(struct tcpcb *);
static __inline void tcp_reass_unlock(struct tcpcb *);
#define tcp_reass_lock(tp) tcp_reass_lock_try(tp)

static __inline int
tcp_reass_lock_try(struct tcpcb *tp)
{
	int s;

	s = splimp();
	if (tp->t_flags & TF_REASSLOCK) {
		splx(s);
		return (0);
	}
	tp->t_flags |= TF_REASSLOCK;
	splx(s);
	return (1);
}

static __inline void
tcp_reass_unlock(struct tcpcb *tp)
{
	int s;

	s = splimp();
	tp->t_flags &= ~TF_REASSLOCK;
	splx(s);
}
a325 2

	u_int64_t tcps_conndrained;	/* # of connections drained */
@


1.45.2.2
log
@MFC:
Fix by markus@@

limit total number of queued out-of-order packets to NMBCLUSTERS/2;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.45.2.1 2004/03/03 02:35:59 brad Exp $	*/
d378 1
a378 2
#define	TCPCTL_REASS_LIMIT     15 /* max entries for tcp reass queues */
#define	TCPCTL_MAXID	       16
a395 1
	{ "reasslimit",	CTLTYPE_INT }, \
a415 3
extern	struct pool tcpqe_pool;
extern	int tcp_reass_limit;	/* max entries for tcp reass queues */

a419 1
int	 tcp_freeq(struct tcpcb *);
@


1.45.2.3
log
@fix location of define from rev 1.60 so a kernel can build without TCP_ECN
--
From: John L. Scarfone <j0 at cox dot net>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.45.2.2 2004/03/03 08:40:07 brad Exp $	*/
d88 1
a89 1
#define TF_REASSLOCK	0x00080000	/* reassembling or draining */
@


1.44
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.43 2002/05/16 14:10:51 kjc Exp $	*/
d372 1
a372 1
struct	inpcbtable tcbtable;	/* head of queue of active tcpcb's */
@


1.43
log
@bring in ECN support from KAME.
it consists of
 - ECN support in TCP
 - tunnel-egress and fragment reassembly rules in layer-3 not to lose
   congestion info at tunnel-egress and fragment reassembly

to enable ECN in TCP, build a kernel with TCP_ECN, and then,
turn it on by "sysctl -w net.inet.tcp.ecn=1".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.42 2002/03/14 01:27:11 millert Exp $	*/
d45 1
a45 1
};  
d48 1
a48 1
	tcp_seq start;		/* start seq no. of hole */ 
d331 1
a331 1
			
d336 2
a337 2
#define TCPCTL_SLOWHZ		5 /* return kernel idea of PR_SLOWHZ */ 
#define TCPCTL_BADDYNAMIC	6 /* return bad dynamic port bitmap */ 
d398 1
a398 1
		int *, u_int32_t *, u_int32_t *); 
d454 1
a454 1
u_long	 tcp_seq_subtract(u_long, u_long ); 
@


1.42
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.41 2002/03/08 03:49:58 provos Exp $	*/
d71 1
a71 1
	u_short	t_flags;
d83 6
d116 1
a116 1
#if defined(TCP_SACK)
d314 12
d345 2
a346 1
#define	TCPCTL_MAXID	       14
d363 1
d382 1
@


1.41
log
@use timeout(9) to schedule TCP timers.  this avoid traversing all
tcp connections during tcp_slowtimo.  apdapted from thorpej@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.40 2002/03/02 00:44:52 provos Exp $	*/
d363 2
a364 2
int	 tcp_attach __P((struct socket *));
void	 tcp_canceltimers __P((struct tcpcb *));
d366 1
a366 1
	 tcp_close __P((struct tcpcb *));
d368 1
a368 1
void	 tcp6_ctlinput __P((int, struct sockaddr *, void *));
d370 2
a371 2
void	 *tcp_ctlinput __P((int, struct sockaddr *, void *));
int	 tcp_ctloutput __P((int, struct socket *, int, int, struct mbuf **));
d373 1
a373 1
	 tcp_disconnect __P((struct tcpcb *));
d375 5
a379 5
	 tcp_drop __P((struct tcpcb *, int));
void	 tcp_dooptions __P((struct tcpcb *, u_char *, int, struct tcphdr *,
		int *, u_int32_t *, u_int32_t *)); 
void	 tcp_drain __P((void));
void	 tcp_init __P((void));
d381 1
a381 1
int	 tcp6_input __P((struct mbuf **, int *, int));
d383 5
a387 5
void	 tcp_input __P((struct mbuf *, ...));
int	 tcp_mss __P((struct tcpcb *, int));
void	 tcp_mss_update __P((struct tcpcb *));
void	 tcp_mtudisc __P((struct inpcb *, int));
void	 tcp_mtudisc_increase __P((struct inpcb *, int));
d389 2
a390 2
void	tcp6_mtudisc __P((struct inpcb *, int));
void	tcp6_mtudisc_callback __P((struct in6_addr *));
d393 11
a403 11
	 tcp_newtcpcb __P((struct inpcb *));
void	 tcp_notify __P((struct inpcb *, int));
int	 tcp_output __P((struct tcpcb *));
void	 tcp_pulloutofband __P((struct socket *, u_int, struct mbuf *, int));
void	 tcp_quench __P((struct inpcb *, int));
int	 tcp_reass __P((struct tcpcb *, struct tcphdr *, struct mbuf *, int *));
void	 tcp_rscale __P((struct tcpcb *, u_long));
void	 tcp_respond __P((struct tcpcb *, caddr_t, struct mbuf *, tcp_seq,
		tcp_seq, int));
void	 tcp_setpersist __P((struct tcpcb *));
void	 tcp_slowtimo __P((void));
d405 2
a406 2
	 tcp_template __P((struct tcpcb *));
void	 tcp_trace __P((int, int, struct tcpcb *, caddr_t, int, int));
d408 2
a409 2
	 tcp_usrclosed __P((struct tcpcb *));
int	 tcp_sysctl __P((int *, u_int, void *, size_t *, void *, size_t));
d411 2
a412 2
int	 tcp6_usrreq __P((struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *));
d414 4
a417 4
int	 tcp_usrreq __P((struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *));
void	 tcp_xmit_timer __P((struct tcpcb *, int));
void	 tcpdropoldhalfopen __P((struct tcpcb *, u_int16_t));
d419 5
a423 5
int	 tcp_sack_option __P((struct tcpcb *,struct tcphdr *,u_char *,int));
void	 tcp_update_sack_list __P((struct tcpcb *tp));
void	 tcp_del_sackholes __P((struct tcpcb *, struct tcphdr *));
void	 tcp_clean_sackreport __P((struct tcpcb *tp));
void	 tcp_sack_adjust __P((struct tcpcb *tp));
d425 2
a426 2
	 tcp_sack_output __P((struct tcpcb *tp));
int	 tcp_sack_partialack __P((struct tcpcb *, struct tcphdr *));
d428 1
a428 1
void	 tcp_print_holes __P((struct tcpcb *tp));
d432 2
a433 2
int	 tcp_newreno __P((struct tcpcb *, struct tcphdr *));
u_long	 tcp_seq_subtract  __P((u_long, u_long )); 
d436 1
a436 1
int	tcp_signature_apply __P((caddr_t, caddr_t, unsigned int));
d438 2
a439 2
void	tcp_rndiss_init __P((void));
tcp_seq	tcp_rndiss_next __P((void));
d441 1
a441 1
	tcp_rndiss_encrypt __P((u_int16_t));
@


1.40
log
@disable immediate ack on TH_PUSH.  make behaviour sysctl tuneable.
from netbsd; also fix a bug where setting TF_ACKNOW didn't actually
result in an ack.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.39 2002/03/01 22:29:29 provos Exp $	*/
d64 1
a65 1
	short	t_timer[TCPT_NTIMERS];	/* tcp timers */
d148 2
a149 2
	short	t_idle;			/* inactivity time */
	short	t_rtt;			/* round trip time */
a405 2
struct tcpcb *
	 tcp_timers __P((struct tcpcb *, int));
@


1.39
log
@remove tcp_fasttimo and convert delayed acks to the timeout(9) API instead.
adapated from netbsd.  okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.38 2002/01/15 19:18:01 provos Exp $	*/
d326 2
a327 1
#define	TCPCTL_MAXID	       13
d343 1
d357 1
@


1.38
log
@allocate sackholes with pool
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.36 2001/06/09 07:03:43 angelos Exp $	*/
d86 1
d181 27
a375 1
void	 tcp_fasttimo __P((void));
@


1.37
log
@Keep stats on TCP/UDP hardware checksumming.
@
text
@d329 1
@


1.37.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.38 2002/01/15 19:18:01 provos Exp $	*/
a328 1
extern	struct pool sackhl_pool;
@


1.37.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.37.4.1 2002/01/31 22:55:46 niklas Exp $	*/
a63 1
	struct timeout t_timer[TCPT_NTIMERS];	/* tcp timers */
d65 1
d71 1
a71 1
	u_int	t_flags;
a82 6
#ifdef TCP_ECN
#define TF_ECN_PERMIT	0x00008000	/* other side said I could ECN */
#define TF_RCVD_CE	0x00010000	/* send ECE in subsequent segs */
#define TF_SEND_CWR	0x00020000	/* send CWR in next seg */
#define TF_DISABLE_ECN	0x00040000	/* disable ECN for this connection */
#endif
a85 1
	struct	timeout t_delack_to;	/* delayed ACK callback */
d109 1
a109 1
#if defined(TCP_SACK) || defined(TCP_ECN)
d147 2
a148 2
	uint32_t t_rcvtime;		/* time last segment received */
	uint32_t t_rtttime;		/* time we started measuring rtt */
a179 27
#ifdef _KERNEL
extern int tcp_delack_ticks;
void	tcp_delack(void *);

#define TCP_INIT_DELACK(tp)						\
	timeout_set(&(tp)->t_delack_to, tcp_delack, tp)

#define TCP_RESTART_DELACK(tp)						\
	timeout_add(&(tp)->t_delack_to, tcp_delack_ticks)

#define	TCP_SET_DELACK(tp)						\
do {									\
	if (((tp)->t_flags & TF_DELACK) == 0) {				\
		(tp)->t_flags |= TF_DELACK;				\
		TCP_RESTART_DELACK(tp);					\
	}								\
} while (/*CONSTCOND*/0)

#define	TCP_CLEAR_DELACK(tp)						\
do {									\
	if ((tp)->t_flags & TF_DELACK) {				\
		(tp)->t_flags &= ~TF_DELACK;				\
		timeout_del(&(tp)->t_delack_to);			\
	}								\
} while (/*CONSTCOND*/0)
#endif /* _KERNEL */

a279 12

	/* ECN stats */
	u_int32_t tcps_ecn_accepts;	/* ecn connections accepted */
	u_int32_t tcps_ecn_rcvece;	/* # of rcvd ece */
	u_int32_t tcps_ecn_rcvcwr;	/* # of rcvd cwr */
	u_int32_t tcps_ecn_rcvce;	/* # of rcvd ce in ip header */
	u_int32_t tcps_ecn_sndect;	/* # of cwr sent */
	u_int32_t tcps_ecn_sndece;	/* # of ece sent */
	u_int32_t tcps_ecn_sndcwr;	/* # of cwr sent */
	u_int32_t tcps_cwr_ecn;		/* # of cwnd reduced by ecn */
	u_int32_t tcps_cwr_frecovery;	/* # of cwnd reduced by fastrecovery */
	u_int32_t tcps_cwr_timeout;	/* # of cwnd reduced by timeout */
d298 1
a298 3
#define	TCPCTL_ACK_ON_PUSH     13 /* ACK immediately on PUSH */
#define	TCPCTL_ECN	       14 /* RFC3168 ECN */
#define	TCPCTL_MAXID	       15
a313 2
	{ "ackonpush",	CTLTYPE_INT }, \
	{ "ecn", 	CTLTYPE_INT }, \
a326 1
extern	int tcp_ack_on_push;	/* ACK immediately on PUSH */
a330 1
extern	int tcp_do_ecn;		/* RFC3168 ECN enabled/disabled? */
d332 2
a333 2
int	 tcp_attach(struct socket *);
void	 tcp_canceltimers(struct tcpcb *);
d335 1
a335 1
	 tcp_close(struct tcpcb *);
d337 1
a337 1
void	 tcp6_ctlinput(int, struct sockaddr *, void *);
d339 2
a340 2
void	 *tcp_ctlinput(int, struct sockaddr *, void *);
int	 tcp_ctloutput(int, struct socket *, int, int, struct mbuf **);
d342 1
a342 1
	 tcp_disconnect(struct tcpcb *);
d344 6
a349 5
	 tcp_drop(struct tcpcb *, int);
void	 tcp_dooptions(struct tcpcb *, u_char *, int, struct tcphdr *,
		int *, u_int32_t *, u_int32_t *); 
void	 tcp_drain(void);
void	 tcp_init(void);
d351 1
a351 1
int	 tcp6_input(struct mbuf **, int *, int);
d353 5
a357 5
void	 tcp_input(struct mbuf *, ...);
int	 tcp_mss(struct tcpcb *, int);
void	 tcp_mss_update(struct tcpcb *);
void	 tcp_mtudisc(struct inpcb *, int);
void	 tcp_mtudisc_increase(struct inpcb *, int);
d359 2
a360 2
void	tcp6_mtudisc(struct inpcb *, int);
void	tcp6_mtudisc_callback(struct in6_addr *);
d363 11
a373 11
	 tcp_newtcpcb(struct inpcb *);
void	 tcp_notify(struct inpcb *, int);
int	 tcp_output(struct tcpcb *);
void	 tcp_pulloutofband(struct socket *, u_int, struct mbuf *, int);
void	 tcp_quench(struct inpcb *, int);
int	 tcp_reass(struct tcpcb *, struct tcphdr *, struct mbuf *, int *);
void	 tcp_rscale(struct tcpcb *, u_long);
void	 tcp_respond(struct tcpcb *, caddr_t, struct mbuf *, tcp_seq,
		tcp_seq, int);
void	 tcp_setpersist(struct tcpcb *);
void	 tcp_slowtimo(void);
d375 4
a378 2
	 tcp_template(struct tcpcb *);
void	 tcp_trace(int, int, struct tcpcb *, caddr_t, int, int);
d380 2
a381 2
	 tcp_usrclosed(struct tcpcb *);
int	 tcp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
d383 2
a384 2
int	 tcp6_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
d386 4
a389 4
int	 tcp_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *);
void	 tcp_xmit_timer(struct tcpcb *, int);
void	 tcpdropoldhalfopen(struct tcpcb *, u_int16_t);
d391 5
a395 5
int	 tcp_sack_option(struct tcpcb *,struct tcphdr *,u_char *,int);
void	 tcp_update_sack_list(struct tcpcb *tp);
void	 tcp_del_sackholes(struct tcpcb *, struct tcphdr *);
void	 tcp_clean_sackreport(struct tcpcb *tp);
void	 tcp_sack_adjust(struct tcpcb *tp);
d397 2
a398 2
	 tcp_sack_output(struct tcpcb *tp);
int	 tcp_sack_partialack(struct tcpcb *, struct tcphdr *);
d400 1
a400 1
void	 tcp_print_holes(struct tcpcb *tp);
d404 2
a405 2
int	 tcp_newreno(struct tcpcb *, struct tcphdr *);
u_long	 tcp_seq_subtract(u_long, u_long ); 
d408 1
a408 1
int	tcp_signature_apply(caddr_t, caddr_t, unsigned int);
d410 2
a411 2
void	tcp_rndiss_init(void);
tcp_seq	tcp_rndiss_next(void);
d413 1
a413 1
	tcp_rndiss_encrypt(u_int16_t);
@


1.37.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.37.4.2 2002/06/11 03:31:37 art Exp $	*/
d45 1
a45 1
};
d48 1
a48 1
	tcp_seq start;		/* start seq no. of hole */
d331 1
a331 1

d336 2
a337 2
#define TCPCTL_SLOWHZ		5 /* return kernel idea of PR_SLOWHZ */
#define TCPCTL_BADDYNAMIC	6 /* return bad dynamic port bitmap */
d398 1
a398 1
		int *, u_int32_t *, u_int32_t *);
d454 1
a454 1
u_long	 tcp_seq_subtract(u_long, u_long );
@


1.37.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d372 1
a372 1
extern	struct inpcbtable tcbtable;	/* head of queue of active tcpcb's */
d374 1
a374 1
extern	u_int32_t tcp_now;		/* for RFC 1323 timestamps */
@


1.36
log
@Inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.35 2000/12/13 09:47:08 provos Exp $	*/
d278 2
@


1.35
log
@more random tcp sequence numbers. okay deraadt@@, angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.34 2000/12/11 08:04:56 itojun Exp $	*/
d39 3
a410 1

d412 1
@


1.34
log
@nuke #ifdef TCP6 (no longer supported).
validate ICMPv6 too big messages (pmtud) based on pcb.  we accept
certain amount of non-validated ones, as IPv6 mandates ICMPv6 (so even for
traffic from unconnected pcb, we need pmtud).
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.33 2000/10/14 01:04:11 itojun Exp $	*/
d404 4
@


1.33
log
@implement net.inet.tcp.rstppslimit.  rate-limits outbound TCP RST traffic
to less than N per 1 second.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.32 2000/09/25 09:41:03 provos Exp $	*/
d352 4
@


1.32
log
@on expiry of pmtu route, retry higher mtu. okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.31 2000/09/20 17:00:23 provos Exp $	*/
d292 2
a293 1
#define	TCPCTL_MAXID	       12
d308 1
@


1.31
log
@correctly calculate mss
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.30 2000/09/18 22:06:38 provos Exp $	*/
d137 2
a138 1
	u_int	t_maxopd;		/* mss plus options */
d349 1
@


1.30
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.29 2000/07/11 16:53:22 provos Exp $	*/
d346 1
@


1.29
log
@compute correct window scale when recvpipe option is set in route; based
on diff from "Pete Kazmier" <pete@@kazmier.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.28 2000/06/26 22:45:09 art Exp $	*/
d345 2
a346 1
int	 tcp_mss __P((struct tcpcb *, u_int));
@


1.28
log
@Make the definition of tcpstat in tcp_var.h extern.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.27 2000/06/18 04:42:43 beck Exp $	*/
d353 1
@


1.27
log
@support ipv6 for tcp_ident
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.26 1999/12/21 17:49:28 provos Exp $	*/
d315 1
a315 1
struct	tcpstat tcpstat;	/* tcp statistics */
@


1.26
log
@option TCP_NEWRENO goes away, its the default case for TCP_SACK if
SACK is disabled for the connection or via sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.25 1999/12/08 06:50:20 itojun Exp $	*/
d303 1
a303 1
	{ "ident", CTLTYPE_STRUCT }, \
d309 1
a309 1
	struct sockaddr faddr, laddr;
@


1.26.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.35 2000/12/13 09:47:08 provos Exp $	*/
d137 1
a137 2
	u_short	t_maxopd;		/* mss plus options */
	u_short	t_peermss;		/* peer's maximum segment size */
d291 1
a291 2
#define	TCPCTL_RSTPPSLIMIT     12 /* RST pps limit */
#define	TCPCTL_MAXID	       13
d303 1
a303 1
	{ "ident", 	CTLTYPE_STRUCT }, \
a305 1
	{ "rstppslimit",	CTLTYPE_INT }, \
d309 1
a309 1
	struct sockaddr_storage faddr, laddr;
d315 1
a315 1
extern	struct tcpstat tcpstat;	/* tcp statistics */
d345 1
a345 8
int	 tcp_mss __P((struct tcpcb *, int));
void	 tcp_mss_update __P((struct tcpcb *));
void	 tcp_mtudisc __P((struct inpcb *, int));
void	 tcp_mtudisc_increase __P((struct inpcb *, int));
#ifdef INET6
void	tcp6_mtudisc __P((struct inpcb *, int));
void	tcp6_mtudisc_callback __P((struct in6_addr *));
#endif
a352 1
void	 tcp_rscale __P((struct tcpcb *, u_long));
a392 4
void	tcp_rndiss_init __P((void));
tcp_seq	tcp_rndiss_next __P((void));
u_int16_t
	tcp_rndiss_encrypt __P((u_int16_t));
@


1.26.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.26.2.1 2001/05/14 22:40:15 niklas Exp $	*/
a38 3
#ifndef _NETINET_TCP_VAR_H_
#define _NETINET_TCP_VAR_H_

a274 2
	u_int32_t tcps_inhwcsum;	/* input hardware-checksummed packets */
	u_int32_t tcps_outhwcsum;	/* output hardware-checksummed packets */
d408 1
a409 1
#endif /* _NETINET_TCP_VAR_H_ */
@


1.26.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a85 1
	struct	timeout t_delack_to;	/* delayed ACK callback */
a179 27
#ifdef _KERNEL
extern int tcp_delack_ticks;
void	tcp_delack(void *);

#define TCP_INIT_DELACK(tp)						\
	timeout_set(&(tp)->t_delack_to, tcp_delack, tp)

#define TCP_RESTART_DELACK(tp)						\
	timeout_add(&(tp)->t_delack_to, tcp_delack_ticks)

#define	TCP_SET_DELACK(tp)						\
do {									\
	if (((tp)->t_flags & TF_DELACK) == 0) {				\
		(tp)->t_flags |= TF_DELACK;				\
		TCP_RESTART_DELACK(tp);					\
	}								\
} while (/*CONSTCOND*/0)

#define	TCP_CLEAR_DELACK(tp)						\
do {									\
	if ((tp)->t_flags & TF_DELACK) {				\
		(tp)->t_flags &= ~TF_DELACK;				\
		timeout_del(&(tp)->t_delack_to);			\
	}								\
} while (/*CONSTCOND*/0)
#endif /* _KERNEL */

d298 1
a298 2
#define	TCPCTL_ACK_ON_PUSH     13 /* ACK immediately on PUSH */
#define	TCPCTL_MAXID	       14
a313 1
	{ "ackonpush",	CTLTYPE_INT }, \
a326 1
extern	int tcp_ack_on_push;	/* ACK immediately on PUSH */
a328 1
extern	struct pool sackhl_pool;
d347 1
@


1.26.2.4
log
@Merge in -current from roughly a week ago
@
text
@a63 1
	struct timeout t_timer[TCPT_NTIMERS];	/* tcp timers */
d65 1
d148 2
a149 2
	uint32_t t_rcvtime;		/* time last segment received */
	uint32_t t_rtttime;		/* time we started measuring rtt */
d363 2
a364 2
int	 tcp_attach(struct socket *);
void	 tcp_canceltimers(struct tcpcb *);
d366 1
a366 1
	 tcp_close(struct tcpcb *);
d368 1
a368 1
void	 tcp6_ctlinput(int, struct sockaddr *, void *);
d370 2
a371 2
void	 *tcp_ctlinput(int, struct sockaddr *, void *);
int	 tcp_ctloutput(int, struct socket *, int, int, struct mbuf **);
d373 1
a373 1
	 tcp_disconnect(struct tcpcb *);
d375 5
a379 5
	 tcp_drop(struct tcpcb *, int);
void	 tcp_dooptions(struct tcpcb *, u_char *, int, struct tcphdr *,
		int *, u_int32_t *, u_int32_t *); 
void	 tcp_drain(void);
void	 tcp_init(void);
d381 1
a381 1
int	 tcp6_input(struct mbuf **, int *, int);
d383 5
a387 5
void	 tcp_input(struct mbuf *, ...);
int	 tcp_mss(struct tcpcb *, int);
void	 tcp_mss_update(struct tcpcb *);
void	 tcp_mtudisc(struct inpcb *, int);
void	 tcp_mtudisc_increase(struct inpcb *, int);
d389 2
a390 2
void	tcp6_mtudisc(struct inpcb *, int);
void	tcp6_mtudisc_callback(struct in6_addr *);
d393 11
a403 11
	 tcp_newtcpcb(struct inpcb *);
void	 tcp_notify(struct inpcb *, int);
int	 tcp_output(struct tcpcb *);
void	 tcp_pulloutofband(struct socket *, u_int, struct mbuf *, int);
void	 tcp_quench(struct inpcb *, int);
int	 tcp_reass(struct tcpcb *, struct tcphdr *, struct mbuf *, int *);
void	 tcp_rscale(struct tcpcb *, u_long);
void	 tcp_respond(struct tcpcb *, caddr_t, struct mbuf *, tcp_seq,
		tcp_seq, int);
void	 tcp_setpersist(struct tcpcb *);
void	 tcp_slowtimo(void);
d405 1
a405 2
	 tcp_template(struct tcpcb *);
void	 tcp_trace(int, int, struct tcpcb *, caddr_t, int, int);
d407 5
a411 2
	 tcp_usrclosed(struct tcpcb *);
int	 tcp_sysctl(int *, u_int, void *, size_t *, void *, size_t);
d413 2
a414 2
int	 tcp6_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
d416 4
a419 4
int	 tcp_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *);
void	 tcp_xmit_timer(struct tcpcb *, int);
void	 tcpdropoldhalfopen(struct tcpcb *, u_int16_t);
d421 5
a425 5
int	 tcp_sack_option(struct tcpcb *,struct tcphdr *,u_char *,int);
void	 tcp_update_sack_list(struct tcpcb *tp);
void	 tcp_del_sackholes(struct tcpcb *, struct tcphdr *);
void	 tcp_clean_sackreport(struct tcpcb *tp);
void	 tcp_sack_adjust(struct tcpcb *tp);
d427 2
a428 2
	 tcp_sack_output(struct tcpcb *tp);
int	 tcp_sack_partialack(struct tcpcb *, struct tcphdr *);
d430 1
a430 1
void	 tcp_print_holes(struct tcpcb *tp);
d434 2
a435 2
int	 tcp_newreno(struct tcpcb *, struct tcphdr *);
u_long	 tcp_seq_subtract(u_long, u_long ); 
d438 1
a438 1
int	tcp_signature_apply(caddr_t, caddr_t, unsigned int);
d440 2
a441 2
void	tcp_rndiss_init(void);
tcp_seq	tcp_rndiss_next(void);
d443 1
a443 1
	tcp_rndiss_encrypt(u_int16_t);
@


1.26.2.5
log
@Sync the SMP branch with 3.3
@
text
@d45 1
a45 1
};
d48 1
a48 1
	tcp_seq start;		/* start seq no. of hole */
d71 1
a71 1
	u_int	t_flags;
a82 6
#ifdef TCP_ECN
#define TF_ECN_PERMIT	0x00008000	/* other side said I could ECN */
#define TF_RCVD_CE	0x00010000	/* send ECE in subsequent segs */
#define TF_SEND_CWR	0x00020000	/* send CWR in next seg */
#define TF_DISABLE_ECN	0x00040000	/* disable ECN for this connection */
#endif
d110 1
a110 1
#if defined(TCP_SACK) || defined(TCP_ECN)
a307 12

	/* ECN stats */
	u_int32_t tcps_ecn_accepts;	/* ecn connections accepted */
	u_int32_t tcps_ecn_rcvece;	/* # of rcvd ece */
	u_int32_t tcps_ecn_rcvcwr;	/* # of rcvd cwr */
	u_int32_t tcps_ecn_rcvce;	/* # of rcvd ce in ip header */
	u_int32_t tcps_ecn_sndect;	/* # of cwr sent */
	u_int32_t tcps_ecn_sndece;	/* # of ece sent */
	u_int32_t tcps_ecn_sndcwr;	/* # of cwr sent */
	u_int32_t tcps_cwr_ecn;		/* # of cwnd reduced by ecn */
	u_int32_t tcps_cwr_frecovery;	/* # of cwnd reduced by fastrecovery */
	u_int32_t tcps_cwr_timeout;	/* # of cwnd reduced by timeout */
d313 1
a313 1

d318 2
a319 2
#define TCPCTL_SLOWHZ		5 /* return kernel idea of PR_SLOWHZ */
#define TCPCTL_BADDYNAMIC	6 /* return bad dynamic port bitmap */
d327 1
a327 2
#define	TCPCTL_ECN	       14 /* RFC3168 ECN */
#define	TCPCTL_MAXID	       15
a343 1
	{ "ecn", 	CTLTYPE_INT }, \
d352 1
a352 1
extern	struct inpcbtable tcbtable;	/* head of queue of active tcpcb's */
a361 1
extern	int tcp_do_ecn;		/* RFC3168 ECN enabled/disabled? */
d377 1
a377 1
		int *, u_int32_t *, u_int32_t *);
d433 1
a433 1
u_long	 tcp_seq_subtract(u_long, u_long );
@


1.26.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.26.2.5 2003/03/28 00:06:55 niklas Exp $	*/
d374 1
a374 1
extern	u_int32_t tcp_now;		/* for RFC 1323 timestamps */
@


1.26.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.26.2.6 2003/05/13 19:36:18 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d105 1
a105 1
#if 1 /*def TCP_SACK*/
d109 1
a109 1
#if 1 /*defined(TCP_SACK) && defined(TCP_FACK)*/
d116 1
a116 1
#if 1 /*defined(TCP_SACK) || defined(TCP_ECN)*/
d124 1
a124 1
#if 1 /*def TCP_SACK*/
d427 1
a427 1
void	 tcp_trace(int, int, struct tcpcb *, struct mbuf *, int, int);
@


1.26.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a84 1
#define TF_DEAD		0x00080000	/* dead and to-be-released */
d102 1
a102 1
	int	sack_enable;		/* enable SACK for this connection */
a173 3
/* pointer for syn cache entries*/
	LIST_HEAD(, syn_cache) t_sc;	/* list of entries by this tcb */

a210 75
 * Handy way of passing around TCP option info.
 */
struct tcp_opt_info {
	int		ts_present;
	u_int32_t	ts_val;
	u_int32_t	ts_ecr;
	u_int16_t	maxseg;
};

#ifdef _KERNEL

/*
 * Data for the TCP compressed state engine.
 */
union syn_cache_sa {
	struct sockaddr sa;
	struct sockaddr_in sin;
#if 1 /*def INET6*/
	struct sockaddr_in6 sin6;
#endif
};

struct syn_cache {
	TAILQ_ENTRY(syn_cache) sc_bucketq;	/* link on bucket list */
	struct timeout sc_timer;		/* rexmt timer */
	union {					/* cached route */
		struct route route4;
#ifdef INET6
		struct route_in6 route6;
#endif
	} sc_route_u;
#define sc_route4	sc_route_u.route4
#ifdef INET6
#define sc_route6	sc_route_u.route6
#endif
	long sc_win;				/* advertised window */
	int sc_bucketidx;			/* our bucket index */
	u_int32_t sc_hash;
	u_int32_t sc_timestamp;			/* timestamp from SYN */
#if 0
	u_int32_t sc_timebase;			/* our local timebase */
#endif
	union syn_cache_sa sc_src;
	union syn_cache_sa sc_dst;
	tcp_seq sc_irs;
	tcp_seq sc_iss;
	u_int sc_rxtcur;			/* current rxt timeout */
	u_int sc_rxttot;			/* total time spend on queues */
	u_short sc_rxtshift;			/* for computing backoff */
	u_short sc_flags;

#define	SCF_UNREACH		0x0001		/* we've had an unreach error */
#define	SCF_TIMESTAMP		0x0002		/* peer will do timestamps */
#define	SCF_DEAD		0x0004		/* this entry to be released */
#define	SCF_SACK_PERMIT		0x0008		/* permit sack */
#define	SCF_ECN_PERMIT		0x0010		/* permit ecn */
#define	SCF_SIGNATURE		0x0020		/* enforce tcp signatures */

	struct mbuf *sc_ipopts;			/* IP options */
	u_int16_t sc_peermaxseg;
	u_int16_t sc_ourmaxseg;
	u_int8_t sc_request_r_scale	: 4,
		 sc_requested_s_scale	: 4;

	struct tcpcb *sc_tp;			/* tcb for listening socket */
	LIST_ENTRY(syn_cache) sc_tpq;		/* list of entries by same tp */
};

struct syn_cache_head {
	TAILQ_HEAD(, syn_cache) sch_bucket;	/* bucket entries */
	u_short sch_length;			/* # entries in bucket */
};
#endif /* _KERNEL */

/*
a321 14

	/* These statistics deal with the SYN cache. */
	u_int64_t tcps_sc_added;	/* # of entries added */
	u_int64_t tcps_sc_completed;	/* # of connections completed */
	u_int64_t tcps_sc_timed_out;	/* # of entries timed out */
	u_int64_t tcps_sc_overflowed;	/* # dropped due to overflow */
	u_int64_t tcps_sc_reset;	/* # dropped due to RST */
	u_int64_t tcps_sc_unreach;	/* # dropped due to ICMP unreach */
	u_int64_t tcps_sc_bucketoverflow;/* # dropped due to bucket overflow */
	u_int64_t tcps_sc_aborted;	/* # of entries aborted (no mem) */
	u_int64_t tcps_sc_dupesyn;	/* # of duplicate SYNs received */
	u_int64_t tcps_sc_dropped;	/* # of SYNs dropped (no route/mem) */
	u_int64_t tcps_sc_collisions;	/* # of hash collisions */
	u_int64_t tcps_sc_retransmitted;/* # of retransmissions */
d342 1
a342 4
#define	TCPCTL_SYN_CACHE_LIMIT 15 /* max size of comp. state engine */
#define	TCPCTL_SYN_BUCKET_LIMIT	16 /* max size of hash bucket */
#define	TCPCTL_RFC3390	       17 /* enable/disable RFC3390 increased cwnd */
#define	TCPCTL_MAXID	       18
a359 3
	{ "syncachelimit", 	CTLTYPE_INT }, \
	{ "synbucketlimit", 	CTLTYPE_INT }, \
	{ "rfc3390", 	CTLTYPE_INT }, \
a378 8
extern	int tcp_do_rfc3390;	/* RFC3390 Increasing TCP's Initial Window */

extern	int tcp_syn_cache_limit; /* max entries for compressed state engine */
extern	int tcp_syn_bucket_limit;/* max entries per hash bucket */

extern	int tcp_syn_cache_size;
extern	struct syn_cache_head tcp_syn_cache[];
extern	u_long syn_cache_count;
d393 2
a394 2
int	 tcp_dooptions(struct tcpcb *, u_char *, int, struct tcphdr *,
		struct mbuf *, int, struct tcp_opt_info *);
d423 1
a423 1
void	 tcp_trace(int, int, struct tcpcb *, caddr_t, int, int);
a458 19

int	 syn_cache_add(struct sockaddr *, struct sockaddr *,
		struct tcphdr *, unsigned int, struct socket *,
		struct mbuf *, u_char *, int, struct tcp_opt_info *);
void	 syn_cache_unreach(struct sockaddr *, struct sockaddr *,
	   struct tcphdr *);
struct socket *syn_cache_get(struct sockaddr *, struct sockaddr *,
		struct tcphdr *, unsigned int, unsigned int,
		struct socket *so, struct mbuf *);
void	 syn_cache_init(void);
void	 syn_cache_insert(struct syn_cache *, struct tcpcb *);
struct syn_cache *syn_cache_lookup(struct sockaddr *, struct sockaddr *,
		struct syn_cache_head **);
void	 syn_cache_reset(struct sockaddr *, struct sockaddr *,
		struct tcphdr *);
int	 syn_cache_respond(struct syn_cache *, struct mbuf *);
void	 syn_cache_timer(void *);
void	 syn_cache_cleanup(struct tcpcb *);

@


1.26.2.9
log
@Merge with the trunk
@
text
@d85 1
a85 1
#define TF_REASSLOCK	0x00080000	/* reassembling or draining */
d212 1
d224 2
a286 29

static __inline int tcp_reass_lock_try(struct tcpcb *);
static __inline void tcp_reass_unlock(struct tcpcb *);
#define tcp_reass_lock(tp) tcp_reass_lock_try(tp)

static __inline int
tcp_reass_lock_try(struct tcpcb *tp)
{
	int s;

	s = splimp();
	if (tp->t_flags & TF_REASSLOCK) {
		splx(s);
		return (0);
	}
	tp->t_flags |= TF_REASSLOCK;
	splx(s);
	return (1);
}

static __inline void
tcp_reass_unlock(struct tcpcb *tp)
{
	int s;

	s = splimp();
	tp->t_flags &= ~TF_REASSLOCK;
	splx(s);
}
a373 1
	u_int32_t tcps_rcvacktooold;	/* rcvd acks for old data */
a414 2

	u_int64_t tcps_conndrained;	/* # of connections drained */
d438 1
a438 3
#define	TCPCTL_REASS_LIMIT     18 /* max entries for tcp reass queues */
#define	TCPCTL_DROP	       19 /* drop tcp connection */
#define	TCPCTL_MAXID	       20
a458 25
	{ "reasslimit", 	CTLTYPE_INT }, \
	{ "drop", 	CTLTYPE_STRUCT }, \
}

#define	TCPCTL_VARS { \
	NULL, \
	&tcp_do_rfc1323, \
	&tcptv_keep_init, \
	&tcp_keepidle, \
	&tcp_keepintvl, \
	NULL, \
	NULL, \
	&tcp_recvspace, \
	&tcp_sendspace, \
	NULL, \
	NULL, \
	&tcp_mssdflt, \
	&tcp_rst_ppslim, \
	&tcp_ack_on_push, \
	NULL, \
	&tcp_syn_cache_limit, \
	&tcp_syn_bucket_limit, \
	&tcp_do_rfc3390, \
	NULL, \
	NULL \
a479 3
extern	struct pool tcpqe_pool;
extern	int tcp_reass_limit;	/* max entries for tcp reass queues */

a490 1
int	 tcp_freeq(struct tcpcb *);
@


1.26.2.10
log
@sync to head
@
text
@a620 2
int	tcp_signature(struct tdb *, int, struct mbuf *, struct tcphdr *,
	    int, int, char *);
@


1.25
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.24 1999/08/06 18:17:38 deraadt Exp $	*/
d106 1
a106 1
#if defined(TCP_SACK) || defined(TCP_NEWRENO)
d386 1
a386 1
#if defined(TCP_NEWRENO) || defined(TCP_SACK)
d389 1
a389 1
#endif /* TCP_NEWRENO || TCP_SACK */
@


1.24
log
@back out all recent changes, which continue to be a source for nasty bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.22 1999/07/17 23:41:46 provos Exp $	*/
d327 3
d341 3
d350 1
a350 1
void	 tcp_pulloutofband __P((struct socket *, u_int, struct mbuf *));
d365 4
@


1.23
log
@Revert to 1.21
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.21 1999/07/06 20:17:53 cmetz Exp $	*/
d333 2
a334 2
int	 tcp_dooptions __P((struct tcpcb *, u_char *, int, struct tcphdr *, 
		struct mbuf *, int, int *, u_int32_t *, u_int32_t *));
@


1.22
log
@revert tcp_input.c to before 07/01/1999 - this seems to solve the mysterious
data corruptions and panics that people have experienced.  by reverting
we loose tcp signatures and ipv6 cleanups, the code looked correct to me.
@
text
@d333 2
a334 2
void	 tcp_dooptions __P((struct tcpcb *, u_char *, int, struct tcphdr *,
		int *, u_int32_t *, u_int32_t *)); 
@


1.21
log
@Added support for TCP MD5 option (RFC 2385).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.20 1999/07/02 21:22:14 cmetz Exp $	*/
d333 2
a334 2
int	 tcp_dooptions __P((struct tcpcb *, u_char *, int, struct tcphdr *, 
		struct mbuf *, int, int *, u_int32_t *, u_int32_t *));
@


1.20
log
@Fixed a #ifdef defined()... typo that turned into a compilation failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.19 1999/03/27 21:04:21 provos Exp $	*/
d79 1
d271 3
d333 2
a334 2
void	 tcp_dooptions __P((struct tcpcb *,
	    u_char *, int, struct tcphdr *, int *, u_int32_t *, u_int32_t *));
d380 3
@


1.19
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.18 1999/02/04 16:12:13 deraadt Exp $	*/
d80 1
a80 2
	struct	tcpiphdr *t_template;	/* skeletal packet for transmit, will
					 * be either tcpiphdr or tcpipv6hdr */
d343 2
a344 2
void	 tcp_respond __P((struct tcpcb *,
	    struct tcpiphdr *, struct mbuf *, tcp_seq, tcp_seq, int));
d347 1
a347 1
struct tcpiphdr *
d351 1
a351 1
void	 tcp_trace __P((int, int, struct tcpcb *, struct tcpiphdr *, int, int));
@


1.18
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.17 1999/02/04 00:04:59 deraadt Exp $	*/
d247 1
@


1.17
log
@use u_int32_t and u_int64_t for stats variables, instead of quad/long
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.16 1999/01/11 15:05:32 niklas Exp $	*/
d39 1
a39 1
struct sackblk {   
d43 7
a49 7
    
struct sackhole {   
	tcp_seq start;      	/* start seq no. of hole */ 
	tcp_seq end;        	/* end seq no. */
	int dups;      		/* number of dup(s)acks for this hole */
	tcp_seq rxmit;      	/* next seq. no in hole to be retransmitted */
	struct sackhole *next;  /* next in list */
d96 3
a98 3
	int sack_disable;            	/* disable SACK for this connection */
	int snd_numholes; 		/* number of holes seen by sender */
	struct sackhole *snd_holes;     /* linked list of holes (sorted) */
d115 5
a119 5
	tcp_seq rcv_laststart;          /* start of last segment recd. */
	tcp_seq rcv_lastend;            /* end of ... */
	tcp_seq rcv_lastsack;           /* last seq number(+1) sack'd by rcv'r*/
	int rcv_numsacks;           	/* # distinct sack blks present */
	struct sackblk sackblks[MAX_SACK_BLKS];  /* seq nos. of sack blocks */
d284 1
a284 1
#define	TCPCTL_IDENT	        9 /* get connection owner */
d360 8
a367 7
int      tcp_sack_option __P((struct tcpcb *,struct tcphdr *,u_char *,int));
void     tcp_update_sack_list __P((struct tcpcb *tp));
void     tcp_del_sackholes __P((struct tcpcb *, struct tcphdr *));
void     tcp_clean_sackreport __P((struct tcpcb *tp));
void     tcp_sack_adjust __P((struct tcpcb *tp));
struct sackhole * tcp_sack_output __P((struct tcpcb *tp));
int    	 tcp_sack_partialack __P((struct tcpcb *, struct tcphdr *));
d369 1
a369 1
void     tcp_print_holes __P((struct tcpcb *tp));
@


1.16
log
@Make TCP_SACK compile with new netinet
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.15 1999/01/11 02:01:36 deraadt Exp $	*/
d212 58
a269 58
	u_long	tcps_connattempt;	/* connections initiated */
	u_long	tcps_accepts;		/* connections accepted */
	u_long	tcps_connects;		/* connections established */
	u_long	tcps_drops;		/* connections dropped */
	u_long	tcps_conndrops;		/* embryonic connections dropped */
	u_long	tcps_closed;		/* conn. closed (includes drops) */
	u_long	tcps_segstimed;		/* segs where we tried to get rtt */
	u_long	tcps_rttupdated;	/* times we succeeded */
	u_long	tcps_delack;		/* delayed acks sent */
	u_long	tcps_timeoutdrop;	/* conn. dropped in rxmt timeout */
	u_long	tcps_rexmttimeo;	/* retransmit timeouts */
	u_long	tcps_persisttimeo;	/* persist timeouts */
	u_long	tcps_persistdrop;	/* connections dropped in persist */
	u_long	tcps_keeptimeo;		/* keepalive timeouts */
	u_long	tcps_keepprobe;		/* keepalive probes sent */
	u_long	tcps_keepdrops;		/* connections dropped in keepalive */

	u_long	tcps_sndtotal;		/* total packets sent */
	u_long	tcps_sndpack;		/* data packets sent */
	u_quad_t tcps_sndbyte;		/* data bytes sent */
	u_long	tcps_sndrexmitpack;	/* data packets retransmitted */
	u_quad_t tcps_sndrexmitbyte;	/* data bytes retransmitted */
	u_quad_t tcps_sndrexmitfast;	/* Fast retransmits */
	u_long	tcps_sndacks;		/* ack-only packets sent */
	u_long	tcps_sndprobe;		/* window probes sent */
	u_long	tcps_sndurg;		/* packets sent with URG only */
	u_long	tcps_sndwinup;		/* window update-only packets sent */
	u_long	tcps_sndctrl;		/* control (SYN|FIN|RST) packets sent */

	u_long	tcps_rcvtotal;		/* total packets received */
	u_long	tcps_rcvpack;		/* packets received in sequence */
	u_quad_t tcps_rcvbyte;		/* bytes received in sequence */
	u_long	tcps_rcvbadsum;		/* packets received with ccksum errs */
	u_long	tcps_rcvbadoff;		/* packets received with bad offset */
	u_long	tcps_rcvmemdrop;	/* packets dropped for lack of memory */
	u_long	tcps_rcvshort;		/* packets received too short */
	u_long	tcps_rcvduppack;	/* duplicate-only packets received */
	u_quad_t tcps_rcvdupbyte;	/* duplicate-only bytes received */
	u_long	tcps_rcvpartduppack;	/* packets with some duplicate data */
	u_quad_t tcps_rcvpartdupbyte;	/* dup. bytes in part-dup. packets */
	u_long	tcps_rcvoopack;		/* out-of-order packets received */
	u_quad_t tcps_rcvoobyte;	/* out-of-order bytes received */
	u_long	tcps_rcvpackafterwin;	/* packets with data after window */
	u_quad_t tcps_rcvbyteafterwin;	/* bytes rcvd after window */
	u_long	tcps_rcvafterclose;	/* packets rcvd after "close" */
	u_long	tcps_rcvwinprobe;	/* rcvd window probe packets */
	u_long	tcps_rcvdupack;		/* rcvd duplicate acks */
	u_long	tcps_rcvacktoomuch;	/* rcvd acks for unsent data */
	u_long	tcps_rcvackpack;	/* rcvd ack packets */
	u_quad_t tcps_rcvackbyte;	/* bytes acked by rcvd acks */
	u_long	tcps_rcvwinupd;		/* rcvd window update packets */
	u_long	tcps_pawsdrop;		/* segments dropped due to PAWS */
	u_long	tcps_predack;		/* times hdr predict ok for acks */
	u_long	tcps_preddat;		/* times hdr predict ok for data pkts */

	u_long	tcps_pcbhashmiss;	/* input packets missing pcb hash */
	u_long	tcps_noport;		/* no socket on port */
	u_long	tcps_badsyn;		/* SYN packet with src==dst rcv'ed */
@


1.15
log
@netinet merge of NRL stuff. some indent and shrinkage needed; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.14 1998/11/18 17:42:22 deraadt Exp $	*/
d360 1
a360 1
int      tcp_sack_option __P((struct tcpcb *,struct tcpiphdr *,u_char *,int));
d362 1
a362 1
void     tcp_del_sackholes __P((struct tcpcb *, struct tcpiphdr *));
d366 1
a366 1
int    	 tcp_sack_partialack __P((struct tcpcb *, struct tcpiphdr *));
d372 1
a372 1
int	 tcp_newreno __P((struct tcpcb *, struct tcpiphdr *));
@


1.14
log
@indent right
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.13 1998/11/17 19:23:03 provos Exp $	*/
d80 2
a81 1
	struct	tcpiphdr *t_template;	/* skeletal packet for transmit */
d169 2
d330 1
a330 1
	    u_char *, int, struct tcpiphdr *, int *, u_int32_t *, u_int32_t *));
d340 1
a340 2
void	 tcp_pulloutofband __P((struct socket *,
	    struct tcpiphdr *, struct mbuf *));
d342 1
a342 1
int	 tcp_reass __P((struct tcpcb *, struct tcpiphdr *, struct mbuf *));
d351 1
a351 1
void	 tcp_trace __P((int, int, struct tcpcb *, struct tcpiphdr *, int));
d376 1
a376 1
#endif /* KERNEL */
@


1.13
log
@NewReno, SACK and FACK support for TCP, adapted from code for BSDI
by Hari Balakrishnan (hari@@lcs.mit.edu), Tom Henderson (tomh@@cs.berkeley.edu)
and Venkat Padmanabhan (padmanab@@cs.berkeley.edu) as part of the
Daedalus research group at the University of California,
(http://daedalus.cs.berkeley.edu). [I was able to do this on time spent
at the Center for Information Technology Integration (citi.umich.edu)]
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.12 1998/10/28 21:34:33 provos Exp $	*/
d39 1
a39 3
#ifdef TCP_SACK
struct sackblk
{   
d44 1
a44 2
struct sackhole
{   
a50 1
#endif
@


1.12
log
@- fix three bugs pointed out in Stevens, i.a. updating timestamps correctly
- fix a 4.4bsd-lite2 bug, when tcp options are present the maximum segment
size is not updated correctly, so that fast recovery forces out a segment
which is split in two segments by tcp_output(), the fix is adpated from
FreeBSD, the effective mss is recorded after option negotiation in 3way
handshake.
[I was able to fix this on time spent at Center for Information Technology
Integration (citi.umich.edu)]
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.11 1998/06/10 03:40:05 beck Exp $	*/
d39 17
d98 14
d117 8
d235 1
d286 3
a288 1
#define	TCPCTL_MAXID		10
d301 2
d315 4
d361 10
d372 7
@


1.11
log
@New TCPCTL_IDENT sysctl for identd without kmem insanity.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.10 1998/03/18 02:37:49 angelos Exp $	*/
d101 2
@


1.10
log
@Add FreeBSD patch (check for SYN packets arriving at a socket in
LISTEN state with source address/port == destination address/port).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.9 1998/01/24 18:21:39 mickey Exp $	*/
d243 2
a244 1
#define	TCPCTL_MAXID		9
d256 1
d258 5
@


1.9
log
@sysctl for def sizes for tcp/udp send/recv queues
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.8 1997/08/09 23:36:27 millert Exp $	*/
d228 1
@


1.8
log
@The list of tcp/udp ports not to allocate dynamically is now
a bitmask configurable via sysctl([38]).  The default values
have not changed.  If one wants to change the list it should
be done early on in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.7 1997/06/15 13:47:28 deraadt Exp $	*/
d240 3
a242 1
#define	TCPCTL_MAXID		7
d252 2
@


1.7
log
@change byte counters to u_quad_t
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.6 1997/06/06 11:22:18 deraadt Exp $	*/
d239 2
a240 1
#define	TCPCTL_MAXID		6
d249 1
@


1.6
log
@add net.inet.tcp.{keepidle,keepintvl,slowhz}; mouse@@Rodents.Montreal.QC.CA
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.5 1996/09/20 22:53:13 deraadt Exp $	*/
d191 1
a191 1
	u_long	tcps_sndbyte;		/* data bytes sent */
d193 1
a193 1
	u_long	tcps_sndrexmitbyte;	/* data bytes retransmitted */
d202 1
a202 1
	u_long	tcps_rcvbyte;		/* bytes received in sequence */
d208 1
a208 1
	u_long	tcps_rcvdupbyte;	/* duplicate-only bytes received */
d210 1
a210 1
	u_long	tcps_rcvpartdupbyte;	/* dup. bytes in part-dup. packets */
d212 1
a212 1
	u_long	tcps_rcvoobyte;		/* out-of-order bytes received */
d214 1
a214 1
	u_long	tcps_rcvbyteafterwin;	/* bytes rcvd after window */
d220 1
a220 1
	u_long	tcps_rcvackbyte;	/* bytes acked by rcvd acks */
@


1.5
log
@`solve' the syn bomb problem as well as currently known; add sysctl's for
SOMAXCONN (kern.somaxconn), SOMINCONN (kern.sominconn), and TCPTV_KEEP_INIT
(net.inet.tcp.keepinittime). when this is not enough (ie. overfull), start
doing tail drop, but slightly prefer the same port.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.4 1996/09/12 06:19:57 tholo Exp $	*/
d233 7
a239 4
			/* enable/disable RFC1323 timestamps/scaling */
#define	TCPCTL_RFC1323		1
#define	TCPCTL_KEEPINITTIME	2
#define	TCPCTL_MAXID		3
d245 3
@


1.4
log
@TCP Persist handling; from 4.4BSD Lite2 (via NetBSD PR 2335)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_var.h,v 1.3 1996/03/03 22:30:50 niklas Exp $	*/
d235 2
a236 1
#define	TCPCTL_MAXID		2
d241 1
d290 1
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d184 1
@


1.2
log
@from netbsd:
make netinet work on systems where pointers and longs are 64 bits
(like the alpha).  Biggest problem: IP headers were overlayed with
structure which included pointers, and which therefore didn't overlay
properly on 64-bit machines.  Solution: instead of threading pointers
through IP header overlays, add a "queue element" structure to do
the threading, and point it at the ip headers.
@
text
@d1 2
a2 1
/*	$NetBSD: tcp_var.h,v 1.15 1995/11/21 01:07:43 cgd Exp $	*/
d224 3
a226 1
	u_long	tcps_pcbcachemiss;
d251 1
a251 1
void	 tcp_ctlinput __P((int, struct sockaddr *, struct ip *));
d262 1
a262 1
void	 tcp_input __P((struct mbuf *, int));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tcp_var.h,v 1.14 1995/09/30 07:02:08 thorpej Exp $	*/
d46 1
a46 2
	struct	tcpiphdr *seg_next, *seg_prev;
					/* list of control blocks */
a164 10
/* XXX
 * We want to avoid doing m_pullup on incoming packets but that
 * means avoiding dtom on the tcp reassembly code.  That in turn means
 * keeping an mbuf pointer in the reassembly queue (since we might
 * have a cluster).  As a quick hack, the source & destination
 * port numbers (which are no longer needed once we've located the
 * tcpcb) are overlayed with an mbuf pointer.
 */
#define REASS_MBUF(ti) (*(struct mbuf **)&((ti)->ti_t))

d203 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

