head	1.80;
access;
symbols
	OPENBSD_6_1:1.70.0.4
	OPENBSD_6_1_BASE:1.70
	OPENBSD_6_0:1.62.0.4
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.61.0.2
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.56.0.4
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.44.0.4
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.39.0.8
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.6
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.38.0.4
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.36.0.6
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.4
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.35.0.4
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.26
	UBC:1.20.0.4
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.12
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.80
date	2017.07.14.16.50.41;	author tedu;	state Exp;
branches;
next	1.79;
commitid	FjZ5YsgPzJxYaSRy;

1.79
date	2017.06.26.19.06.12;	author bluhm;	state Exp;
branches;
next	1.78;
commitid	s4n2Jw05TTWVpKLf;

1.78
date	2017.05.31.05.59.09;	author mpi;	state Exp;
branches;
next	1.77;
commitid	XqMqqfSTUVDwiwE7;

1.77
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.76;
commitid	p51F2KIwIJB1dU8P;

1.76
date	2017.05.28.09.25.51;	author bluhm;	state Exp;
branches;
next	1.75;
commitid	EanrvCSMSB3GbdG9;

1.75
date	2017.05.22.22.23.11;	author bluhm;	state Exp;
branches;
next	1.74;
commitid	qjwlMcLE2UktwzfG;

1.74
date	2017.05.22.20.04.12;	author bluhm;	state Exp;
branches;
next	1.73;
commitid	ch1KtxruuAeEf0Cm;

1.73
date	2017.05.12.23.05.58;	author bluhm;	state Exp;
branches;
next	1.72;
commitid	5yiXoXQ82UTx1Mu1;

1.72
date	2017.05.12.14.04.09;	author bluhm;	state Exp;
branches;
next	1.71;
commitid	aPPcyWATXfERaZx2;

1.71
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.70;
commitid	00hB28wQPwG5Ysk0;

1.70
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.69;
commitid	ZsxSSZJSFxZH81LL;

1.69
date	2017.03.03.15.48.02;	author bluhm;	state Exp;
branches;
next	1.68;
commitid	LtQeAWkATeJFPv2t;

1.68
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.67;
commitid	UBL7uwpXqTP4EWIu;

1.67
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.66;
commitid	3e3CkrbYekyVOcxy;

1.66
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.65;
commitid	pVtptbHA3yk4jSpN;

1.65
date	2016.12.19.09.22.24;	author rzalamena;	state Exp;
branches;
next	1.64;
commitid	5iifwOyfMyS6GiDF;

1.64
date	2016.11.28.23.15.31;	author bluhm;	state Exp;
branches;
next	1.63;
commitid	tRB1wgF5XEe7ukoA;

1.63
date	2016.11.14.03.51.53;	author dlg;	state Exp;
branches;
next	1.62;
commitid	Khqq96MLd95C1Z1s;

1.62
date	2016.04.15.11.18.40;	author mpi;	state Exp;
branches;
next	1.61;
commitid	MtUvK7KSkyLnt6N3;

1.61
date	2015.12.03.21.11.53;	author sashan;	state Exp;
branches;
next	1.60;
commitid	nhuzteWvIf6uiITt;

1.60
date	2015.07.16.21.14.21;	author mpi;	state Exp;
branches;
next	1.59;
commitid	VGPlklxThaST7mIm;

1.59
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.58;
commitid	cYQY7jiay4SydLhD;

1.58
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.57;
commitid	Vq8oSnWLkf7dyy0N;

1.57
date	2014.11.05.14.03.02;	author mpi;	state Exp;
branches;
next	1.56;
commitid	Ii1JKOPj4OOyvsFQ;

1.56
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.54;

1.54
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.53;

1.53
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.52;

1.52
date	2014.03.27.10.44.23;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2014.01.23.23.51.29;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2013.12.17.02.41.07;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	2013.11.17.10.07.32;	author bluhm;	state Exp;
branches;
next	1.48;

1.48
date	2013.10.24.11.17.36;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2013.10.21.12.27.13;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2013.08.13.09.52.53;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2012.03.17.10.16.41;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.19.03.47.29;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.14.08.15.26;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.04.13.30.03;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.18.18.56.02;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.29.20.42.27;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.11.12.55.31;	author mpf;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.02.11.05.44;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.27.04.55.28;	author mcbride;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.22.07.35.20;	author cedric;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.06.16.49.09;	author cedric;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.28.02.51.58;	author cedric;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.12.14.41.08;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2002.12.09.00.45.37;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.31.20.58.25;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.28.15.44.28;	author jasoni;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.24.22.42.48;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.23.05.54.50;	author angelos;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2001.06.09.07.03.42;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.28.05.29.36;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.20.19.19.57;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.01.09.55.49;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.03.01.00.19;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.18.22.06.38;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.02.09.00.19;	author angelos;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	99.02.17.23.51.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.01.11.02.01.34;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.12.26.12.35.12;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	98.02.14.18.50.36;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	98.02.01.21.46.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.02.01.18.09.23;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.02.20.01.08.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.26.01.23.44;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.22.30.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.50.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2001.05.14.22.40.13;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.07.04.10.55.00;	author niklas;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.13.2.8;

1.13.2.8
date	2004.06.07.20.41.39;	author niklas;	state Exp;
branches;
next	;

1.20.4.1
date	2002.01.31.22.55.45;	author niklas;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.20.4.4;

1.20.4.4
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.80
log
@kernels don't build without MROUTING because ip_var.h only sometimes
introduces a forward decl for socket. turns out the affected file doesn't
need ip_var.h, so remove it. then move the decl to the bottom to prevent
the problem from recurring.
bug report by Nick Briggs
ok mpi
@
text
@/*	$OpenBSD: ip_var.h,v 1.79 2017/06/26 19:06:12 bluhm Exp $	*/
/*	$NetBSD: ip_var.h,v 1.16 1996/02/13 23:43:20 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip_var.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET_IP_VAR_H_
#define _NETINET_IP_VAR_H_

/*
 * Structure stored in mbuf in inpcb.ip_options
 * and passed to ip_output when ip options are in use.
 * The actual length of the options (including ipopt_dst)
 * is in m_len.
 */
#define	MAX_IPOPTLEN	40

/*
 * Overlay for ip header used by other protocols (tcp, udp).
 */
struct ipovly {
	u_int8_t  ih_x1[9];		/* (unused) */
	u_int8_t  ih_pr;		/* protocol */
	u_int16_t ih_len;		/* protocol length */
	struct	  in_addr ih_src;	/* source internet address */
	struct	  in_addr ih_dst;	/* destination internet address */
};

struct	ipstat {
	u_long	ips_total;		/* total packets received */
	u_long	ips_badsum;		/* checksum bad */
	u_long	ips_tooshort;		/* packet too short */
	u_long	ips_toosmall;		/* not enough data */
	u_long	ips_badhlen;		/* ip header length < data size */
	u_long	ips_badlen;		/* ip length < ip header length */
	u_long	ips_fragments;		/* fragments received */
	u_long	ips_fragdropped;	/* frags dropped (dups, out of space) */
	u_long	ips_fragtimeout;	/* fragments timed out */
	u_long	ips_forward;		/* packets forwarded */
	u_long	ips_cantforward;	/* packets rcvd for unreachable dest */
	u_long	ips_redirectsent;	/* packets forwarded on same net */
	u_long	ips_noproto;		/* unknown or unsupported protocol */
	u_long	ips_delivered;		/* datagrams delivered to upper level*/
	u_long	ips_localout;		/* total ip packets generated here */
	u_long	ips_odropped;		/* lost packets due to nobufs, etc. */
	u_long	ips_reassembled;	/* total packets reassembled ok */
	u_long	ips_fragmented;		/* datagrams successfully fragmented */
	u_long	ips_ofragments;		/* output fragments created */
	u_long	ips_cantfrag;		/* don't fragment flag was set, etc. */
	u_long	ips_badoptions;		/* error in option processing */
	u_long	ips_noroute;		/* packets discarded due to no route */
	u_long	ips_badvers;		/* ip version != 4 */
	u_long	ips_rawout;		/* total raw ip packets generated */
	u_long	ips_badfrags;		/* malformed fragments (bad length) */
	u_long	ips_rcvmemdrop;		/* frags dropped for lack of memory */
	u_long	ips_toolong;		/* ip length > max ip packet size */
	u_long	ips_nogif;		/* no match gif found */
	u_long	ips_badaddr;		/* invalid address on header */
	u_long	ips_inswcsum;		/* software checksummed on input */
	u_long	ips_outswcsum;		/* software checksummed on output */
	u_long	ips_notmember;		/* multicasts for unregistered groups */
};

struct ipoption {
	struct	in_addr ipopt_dst;	/* first-hop dst if source routed */
	int8_t	ipopt_list[MAX_IPOPTLEN];	/* options proper */
};

#ifdef _KERNEL

#include <sys/percpu.h>

enum ipstat_counters {
	ips_total,		/* total packets received */
	ips_badsum,		/* checksum bad */
	ips_tooshort,		/* packet too short */
	ips_toosmall,		/* not enough data */
	ips_badhlen,		/* ip header length < data size */
	ips_badlen,		/* ip length < ip header length */
	ips_fragments,		/* fragments received */
	ips_fragdropped,	/* frags dropped (dups, out of space) */
	ips_fragtimeout,	/* fragments timed out */
	ips_forward,		/* packets forwarded */
	ips_cantforward,	/* packets rcvd for unreachable dest */
	ips_redirectsent,	/* packets forwarded on same net */
	ips_noproto,		/* unknown or unsupported protocol */
	ips_delivered,		/* datagrams delivered to upper level*/
	ips_localout,		/* total ip packets generated here */
	ips_odropped,		/* lost packets due to nobufs, etc. */
	ips_reassembled,	/* total packets reassembled ok */
	ips_fragmented,		/* datagrams successfully fragmented */
	ips_ofragments,		/* output fragments created */
	ips_cantfrag,		/* don't fragment flag was set, etc. */
	ips_badoptions,		/* error in option processing */
	ips_noroute,		/* packets discarded due to no route */
	ips_badvers,		/* ip version != 4 */
	ips_rawout,		/* total raw ip packets generated */
	ips_badfrags,		/* malformed fragments (bad length) */
	ips_rcvmemdrop,		/* frags dropped for lack of memory */
	ips_toolong,		/* ip length > max ip packet size */
	ips_nogif,		/* no match gif found */
	ips_badaddr,		/* invalid address on header */
	ips_inswcsum,		/* software checksummed on input */
	ips_outswcsum,		/* software checksummed on output */
	ips_notmember,		/* multicasts for unregistered groups */

	ips_ncounters
};

extern struct cpumem *ipcounters;

static inline void
ipstat_inc(enum ipstat_counters c)
{
	counters_inc(ipcounters, c);
}

/*
 * Structure attached to inpcb.ip_moptions and
 * passed to ip_output when IP multicast options are in use.
 */
struct ip_moptions {
	struct in_multi **imo_membership; /* group memberships */
	unsigned short imo_ifidx;	/* ifp index for outgoing multicasts */
	u_int8_t  imo_ttl;	/* TTL for outgoing multicasts */
	u_int8_t  imo_loop;	/* 1 => hear sends if a member */
	u_int16_t imo_num_memberships;	/* no. memberships this socket */
	u_int16_t imo_max_memberships;	/* max memberships this socket */
};

#include <sys/queue.h>

/*
 * Ip reassembly queue structures.
 */
LIST_HEAD(ipqehead, ipqent);
struct ipqent {
	LIST_ENTRY(ipqent) ipqe_q;
	struct ip	*ipqe_ip;
	struct mbuf	*ipqe_m;	/* mbuf contains packet */
	u_int8_t	ipqe_mff;	/* for IP fragmentation */
};

/*
 * Ip reassembly queue structure.  Each fragment
 * being reassembled is attached to one of these structures.
 * They are timed out after ipq_ttl drops to 0, and may also
 * be reclaimed if memory becomes tight.
 */
struct ipq {
	LIST_ENTRY(ipq) ipq_q;		/* to other reass headers */
	u_int8_t  ipq_ttl;		/* time for reass q to live */
	u_int8_t  ipq_p;		/* protocol of this fragment */
	u_int16_t ipq_id;		/* sequence id for reassembly */
	struct	  ipqehead ipq_fragq;	/* to ip fragment queue */
	struct	  in_addr ipq_src, ipq_dst;
};

/* flags passed to ip_output */
#define	IP_FORWARDING		0x1		/* most of ip header exists */
#define	IP_RAWOUTPUT		0x2		/* raw ip header exists */
#define	IP_ALLOWBROADCAST	SO_BROADCAST	/* can send broadcast packets */
#define	IP_MTUDISC		0x0800		/* pmtu discovery, set DF */

extern struct ipstat ipstat;
extern LIST_HEAD(ipqhead, ipq)	ipq;	/* ip reass. queue */
extern int ip_defttl;			/* default IP ttl */

#define IPMTUDISCTIMEOUT (10 * 60)	/* as per RFC 1191 */

extern int ip_mtudisc;			/* mtu discovery */
extern u_int ip_mtudisc_timeout;	/* seconds to timeout mtu discovery */

extern int ipport_firstauto;		/* min port for port allocation */
extern int ipport_lastauto;		/* max port for port allocation */
extern int ipport_hifirstauto;		/* min dynamic/private port number */
extern int ipport_hilastauto;		/* max dynamic/private port number */
extern int encdebug;			/* enable message reporting */
extern int ipforwarding;		/* enable IP forwarding */
#ifdef MROUTING
extern int ipmforwarding;		/* enable multicast forwarding */
#endif
extern int ipmultipath;			/* enable multipath routing */
extern int la_hold_total;

extern struct rttimer_queue *ip_mtudisc_timeout_q;
extern struct pool ipqent_pool;
struct route;
struct inpcb;

int	 ip_ctloutput(int, struct socket *, int, int, struct mbuf *);
void	 ip_drain(void);
void	 ip_flush(void);
int	 ip_fragment(struct mbuf *, struct ifnet *, u_long);
void	 ip_freef(struct ipq *);
void	 ip_freemoptions(struct ip_moptions *);
int	 ip_getmoptions(int, struct ip_moptions *, struct mbuf *);
void	 ip_init(void);
struct mbuf*
	 ip_insertoptions(struct mbuf *, struct mbuf *, int *);
int	 ip_mforward(struct mbuf *, struct ifnet *);
int	 ip_optcopy(struct ip *, struct ip *);
int	 ip_output(struct mbuf *, struct mbuf *, struct route *, int,
	    struct ip_moptions *, struct inpcb *, u_int32_t);
int	 ip_pcbopts(struct mbuf **, struct mbuf *);
struct mbuf *
	 ip_reass(struct ipqent *, struct ipq *);
u_int16_t
	 ip_randomid(void);
void	 ip_send(struct mbuf *);
int	 ip_setmoptions(int, struct ip_moptions **, struct mbuf *, u_int);
void	 ip_slowtimo(void);
struct mbuf *
	 ip_srcroute(struct mbuf *);
void	 ip_stripoptions(struct mbuf *);
int	 ip_sysctl(int *, u_int, void *, size_t *, void *, size_t);
void	 ip_savecontrol(struct inpcb *, struct mbuf **, struct ip *,
	    struct mbuf *);
void	 ipintr(void);
int	 ip_input_if(struct mbuf **, int *, int, int, struct ifnet *);
int	 ip_deliver(struct mbuf **, int *, int, int);
void	 ip_forward(struct mbuf *, struct ifnet *, struct rtentry *, int);
int	 rip_ctloutput(int, struct socket *, int, int, struct mbuf *);
void	 rip_init(void);
int	 rip_input(struct mbuf **, int *, int, int);
int	 rip_output(struct mbuf *, struct socket *, struct sockaddr *,
	    struct mbuf *);
int	 rip_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
int	 rip_attach(struct socket *, int);

#ifdef MROUTING
extern struct socket *ip_mrouter[];	/* multicast routing daemon */
#endif

#endif /* _KERNEL */
#endif /* _NETINET_IP_VAR_H_ */
@


1.79
log
@Convert ip_input() to a pr_input style function.  Goal is to process
IPsec packets without additional enqueueing.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.78 2017/05/31 05:59:09 mpi Exp $	*/
a195 3
#ifdef MROUTING
extern struct socket *ip_mrouter[];	/* multicast routing daemon */
#endif
d259 4
@


1.78
log
@Move IPv4 & IPv6 incoming/forwarding path, PIPEX ppp processing and
IPv4 & IPv6 dispatch functions outside the KERNEL_LOCK().

We currently rely on the NET_LOCK() serializing access to most global
data structures for that.  IP input queues are no longer used in the
forwarding case.  They still exist as boundary between the network and
transport layers because TCP/UDP & friends still need the KERNEL_LOCK().

Since we do not want to grab the NET_LOCK() for every packet, the
softnet thread will do it once before processing a batch.  That means
the L2 processing path, which is currently running without lock, will
now run with the NET_LOCK().

IPsec isn't ready to run without KERNEL_LOCK(), so the softnet thread
will grab the KERNEL_LOCK() as soon as ``ipsec_in_use'' is set.

Tested by Hrvoje Popovski.

ok visa@@, bluhm@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.77 2017/05/30 07:50:37 mpi Exp $	*/
d251 2
a252 1
void	 ip_deliver(struct mbuf **, int *, int, int);
@


1.77
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.76 2017/05/28 09:25:51 bluhm Exp $	*/
a250 1
void	 ip_input(struct mbuf *);
@


1.76
log
@Rename ip_local() to ip_deliver() and give it the same parameters
as the pr_input functions.  Add an assert that IPv4 delivery ends
in IP proto done to assure that IPv4 protocol functions work like
IPv6.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.75 2017/05/22 22:23:11 bluhm Exp $	*/
d251 1
a251 1
void	 ipv4_input(struct mbuf *);
@


1.75
log
@Move IPsec forward and local policy check functions to ipsec_input.c
and give them better names.
input and OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.74 2017/05/22 20:04:12 bluhm Exp $	*/
d252 1
a252 1
void	 ip_local(struct mbuf *, int, int);
@


1.74
log
@Use the IPsec policy check from IPv4 also when doing local delivery
in ip6_local() to our IPv6 stack.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.73 2017/05/12 23:05:58 bluhm Exp $	*/
a253 2
int	 ip_input_ipsec_fwd_check(struct mbuf *, int, int);
int	 ip_input_ipsec_ours_check(struct mbuf *, int, int, int);
@


1.73
log
@IPsec packets were passed through ip_input() a second time after
they have been decrypted.  That means that all the IP header fields
were checked twice.  Also fragment reassembly was tried twice.
At pf incoming packets in tunnel mode appeared twice on the enc0
interface, once as IP-in-IP and once as the inner packet.  In the
outgoing path pf only sees the inner packet.  Asymmetry is bad for
stateful filtering.
IPv6 shows that IPsec works without that.  After decrypting immediately
continue with local delivery.  In tunnel mode the IP-in-IP protocol
functions pass the inner header to ip6_input().  In transport mode
only pf_test() has to be called for the enc0 device.
Introduce ip_local() to avoid needless processing and cleaner pf
behavior in IPv4 IPsec.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.72 2017/05/12 14:04:09 bluhm Exp $	*/
d255 1
@


1.72
log
@Use the IPsec policy check from ipv4_input() also when forwarding
in ip6_input().  While there avoid an ugly #ifdef in ipv4_input().
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.71 2017/04/14 20:46:31 bluhm Exp $	*/
d252 1
@


1.71
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.70 2017/03/13 20:18:21 claudio Exp $	*/
d253 1
@


1.70
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.69 2017/03/03 15:48:02 bluhm Exp $	*/
d255 1
a255 1
int	 rip_input(struct mbuf **, int *, int);
@


1.69
log
@Convert the variable argument list of the pr_output functions to
fixed parameters.
OK mpi@@ claudio@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.68 2017/02/01 20:59:47 dhill Exp $	*/
d260 1
@


1.68
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.67 2017/01/29 19:58:47 bluhm Exp $	*/
d256 2
a257 1
int	 rip_output(struct mbuf *, ...);
@


1.67
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.66 2017/01/25 17:34:31 bluhm Exp $	*/
d222 1
a222 1
int	 ip_ctloutput(int, struct socket *, int, int, struct mbuf **);
d228 1
a228 1
int	 ip_getmoptions(int, struct ip_moptions *, struct mbuf **);
d253 1
a253 1
int	 rip_ctloutput(int, struct socket *, int, int, struct mbuf **);
@


1.66
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.65 2016/12/19 09:22:24 rzalamena Exp $	*/
d255 1
a255 1
void	 rip_input(struct mbuf *, int, int);
@


1.65
log
@Extend the multicast sockets and multicast hash table support to multiple
domains. This is one step towards supporting to run more than one multicast
socket in different domains at the same time.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.64 2016/11/28 23:15:31 bluhm Exp $	*/
d255 1
a255 1
void	 rip_input(struct mbuf *, ...);
@


1.64
log
@Path MTU discovery and traceroute did not always work with pf af-to.
If an incoming packet is directly put into the output path, sending
the icmp error packet is never done.  As this is basically forwarding,
calling ip_forward() for such packets does everything that is needed.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.63 2016/11/14 03:51:53 dlg Exp $	*/
d197 1
a197 1
extern struct socket *ip_mrouter;	/* multicast routing daemon */
@


1.63
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the ipstat struct.

ipstat_inc(ips_foo) replaces ipstat.ips_foo++ for the actual updates.
ipstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the ipstat struct for now.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.62 2016/04/15 11:18:40 mpi Exp $	*/
d252 1
@


1.62
log
@Kill in_rtaddr() and use rtalloc(9) directly in ip_dooptions().

This brings ip_dooptions() closer to mp-safeness by ensuring that
``ifa'' is dereferenced before calling rtfree(9).

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.61 2015/12/03 21:11:53 sashan Exp $	*/
d98 47
@


1.61
log
@ip_send()/ip6_send() allow PF to send response packet in ipsoftnet task.
this avoids current recursion to pf_test() function. the change also
switches icmp_error()/icmp6_error() to use ip_send()/ip6_send() so
they are safe for PF.

The idea comes from Markus Friedl. bluhm, mikeb and mpi helped me
a lot to get it into shape.

OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.60 2015/07/16 21:14:21 mpi Exp $	*/
a191 2
struct in_ifaddr *
	 ip_rtaddr(struct in_addr, u_int);
@


1.60
log
@Kill IP_ROUTETOETHER.

This pseudo-option is a hack to support return-rst on bridge(4).  It
passes Ethernet information via a "struct route" through ip_output().

"struct route" is slowly dying...

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.59 2014/12/17 09:57:13 mpi Exp $	*/
d183 2
d196 1
d213 1
@


1.59
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.58 2014/12/17 09:45:59 mpi Exp $	*/
a144 1
#define IP_ROUTETOETHER		0x1000		/* ether addresses given */
@


1.58
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.57 2014/11/05 14:03:02 mpi Exp $	*/
d106 2
a107 2
	u_int8_t  imo_multicast_ttl;	/* TTL for outgoing multicasts */
	u_int8_t  imo_multicast_loop;	/* 1 => hear sends if a member */
@


1.57
log
@Kill in_iawithaddr() and use ifa_ifwithaddr() directly.

Note that ifa_ifwithaddr() might return a broadcast address, so if you
don't want one make sure to filter them out.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.56 2014/04/21 12:22:26 henning Exp $	*/
d104 2
a105 1
	struct	  ifnet *imo_multicast_ifp; /* ifp for outgoing multicasts */
a109 1
	struct	  in_multi **imo_membership; /* group memberships */
@


1.56
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.53 2014/03/27 13:27:28 mpi Exp $	*/
a190 2
struct in_ifaddr *
	 in_iawithaddr(struct in_addr, u_int);
@


1.55
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d140 1
a140 1
/* flags passed to ip_output as last parameter */
a145 1
#define IP_IPSECFLOW		0x2000		/* IPsec flow info */
d187 1
a187 1
	    struct ip_moptions *, struct inpcb *, ...);
@


1.54
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.52 2014/03/27 10:44:23 mpi Exp $	*/
a142 1
#define	IP_ROUTETOIF		SO_DONTROUTE	/* bypass routing tables */
@


1.53
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d143 1
@


1.52
log
@Stop dereferencing the ifp pointer present in the packet header all
over the input path since it is going to die.  Should be no functional
change.

ok mikeb@@, lteo@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.51 2014/01/23 23:51:29 henning Exp $	*/
a142 1
#define	IP_ROUTETOIF		SO_DONTROUTE	/* bypass routing tables */
@


1.51
log
@since the cksum rewrite the counters for hardware checksummed packets
are are lie, since the software engine emulates hardware offloading
and that is later indistinguishable. so kill the hw cksummed counters.
introduce software checksummed packet counters instead.
tcp/udp handles ip & ipvshit, ip cksum covered, 6 has no ip layer cksum.
as before we still have a miscounting bug for inbound with pf on, to be
fixed in the next step.
found by, prodding & ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.49 2013/11/17 10:07:32 bluhm Exp $	*/
a178 1
int	 ip_dooptions(struct mbuf *);
a180 1
void	 ip_forward(struct mbuf *, int);
@


1.50
log
@Change ip_output()'s non-optional arguments to be standard arguments
instead of variable arguments.

Allows stricter type checking by the compiler at call sites and also
saves a bit of code size on some platforms (e.g., ~200 bytes on
amd64).

ok mikeb
@
text
@d87 2
a88 2
	u_long	ips_inhwcsum;		/* hardware checksummed on input */
	u_long	ips_outhwcsum;		/* hardware checksummed on output */
@


1.49
log
@Instead of stripping the IP options manually in icmp_reflect(),
just call ip_stripoptions().  Remove an unneeded parameter and
adjust the ip length in ip_stripoptions().
from FreeBSD; OK deraadt@@ henninh@@ lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.48 2013/10/24 11:17:36 deraadt Exp $	*/
d175 1
d190 2
a191 1
int	 ip_output(struct mbuf *, ...);
@


1.48
log
@Move obvious kernel prototypes (and structure's with kernel pointers,
obviously only used in the kernel) behind #ifdef _KERNEL
This is a more substantial change than the others commited minutes ago,
so it is seperate.  More structs get hidden.
ok various
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.47 2013/10/21 12:27:13 deraadt Exp $	*/
d203 1
a203 1
void	 ip_stripoptions(struct mbuf *, struct mbuf *);
@


1.47
log
@There are gasps of shock!  Add a pmtu delay sysctl BUTTON for netinet6,
making the code the same as netinet4 along the way.
ok bluhm phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.46 2013/08/13 09:52:53 mpi Exp $	*/
d38 7
a44 1
#include <sys/queue.h>
a56 52
/*
 * Ip reassembly queue structures.
 */
LIST_HEAD(ipqehead, ipqent);
struct ipqent {
	LIST_ENTRY(ipqent) ipqe_q;
	struct ip	*ipqe_ip;
	struct mbuf	*ipqe_m;	/* mbuf contains packet */
	u_int8_t	ipqe_mff;	/* for IP fragmentation */
};

/*
 * Ip reassembly queue structure.  Each fragment
 * being reassembled is attached to one of these structures.
 * They are timed out after ipq_ttl drops to 0, and may also
 * be reclaimed if memory becomes tight.
 */
struct ipq {
	LIST_ENTRY(ipq) ipq_q;		/* to other reass headers */
	u_int8_t  ipq_ttl;		/* time for reass q to live */
	u_int8_t  ipq_p;		/* protocol of this fragment */
	u_int16_t ipq_id;		/* sequence id for reassembly */
	struct	  ipqehead ipq_fragq;	/* to ip fragment queue */
	struct	  in_addr ipq_src, ipq_dst;
};

/*
 * Structure stored in mbuf in inpcb.ip_options
 * and passed to ip_output when ip options are in use.
 * The actual length of the options (including ipopt_dst)
 * is in m_len.
 */
#define	MAX_IPOPTLEN	40

struct ipoption {
	struct	in_addr ipopt_dst;	/* first-hop dst if source routed */
	int8_t	ipopt_list[MAX_IPOPTLEN];	/* options proper */
};

/*
 * Structure attached to inpcb.ip_moptions and
 * passed to ip_output when IP multicast options are in use.
 */
struct ip_moptions {
	struct	  ifnet *imo_multicast_ifp; /* ifp for outgoing multicasts */
	u_int8_t  imo_multicast_ttl;	/* TTL for outgoing multicasts */
	u_int8_t  imo_multicast_loop;	/* 1 => hear sends if a member */
	u_int16_t imo_num_memberships;	/* no. memberships this socket */
	u_int16_t imo_max_memberships;	/* max memberships this socket */
	struct	  in_multi **imo_membership; /* group memberships */
};

d92 5
d98 42
@


1.46
log
@When net.inet.ip.sourceroute is enable, store the source route
of incoming IPv4 packets with the SSRR or LSRR header option in
a m_tag rather than in a single static entry.

Use a new m_tag type, PACKET_TAG_SRCROUTE, for this and bump
PACKET_TAG_MAXSIZE accordingly.

Adapted from FreeBSD r135274 with inputs from bluhm@@.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.45 2013/04/10 08:50:59 mpi Exp $	*/
d154 2
@


1.45
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.44 2012/07/16 18:05:36 markus Exp $	*/
d199 1
a199 1
	 ip_srcroute(void);
@


1.44
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.43 2012/03/17 10:16:41 dlg Exp $	*/
d151 3
d157 13
@


1.43
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.42 2011/04/19 03:47:29 dlg Exp $	*/
d146 1
@


1.42
log
@reintroduce using the RB tree for local address lookups. this is
confusing because both addresses and broadcast addresses are put
into the tree.

there are two types of local address lookup. the first is when the
socket layer wants a local address, the second is in ip_input when
the kernel is figuring out the packet is for it to process or
forward.

ip_input considers local addresses and broadcast addresses as local,
however, the handling of broadcast addresses is different depending
on whether ip_directedbcast is set. if if ip_directbcast is unset
then a packet coming in on any interface to any of the systems
broadcast addresses is considered local, otherwise the broadcast
packet must exist on the interface it was received on.

the code also needs to consider classful broadcast addresses so we
can continue some legacy applications (eg, netbooting old sparcs
that use rarp and bootparam requests to classful broadcast addresses
as per PR6382). this diff maintains that support, but restricts it
to packets that are broadcast on the link layer (eg, ethernet
broadcasted packets), and it only looks up addresses on the local
interface. we now only support classful broadcast addresses on local
interfaces to avoid weird side effects with packets routed to us.

the ip4 socket layer does lookups for local addresses with a wrapper
around the global address tree that rejects matches against broadcast
addresses. we now no longer support bind sockets to broadcast
addresses, no matter what the value of ip_directedbcast is.

ok henning@@
testing (and possibly ok) claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.41 2011/04/14 08:15:26 claudio Exp $	*/
a143 1
#define IP_JUMBO		SO_JUMBO	/* try to use the jumbo mtu */
@


1.41
log
@Backout the in_iawithaddr() -> ifa_ifwithaddr() change.
There is a massive issue with broadcast addrs because ifa_ifwithaddr()
handles them differently then in_iawithaddr().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.40 2011/04/04 13:30:03 henning Exp $	*/
d175 1
a175 1
	 in_iawithaddr(struct in_addr, struct mbuf *, u_int);
@


1.40
log
@make in_iawithaddr a wrapper for ifa_ifwithaddr plus a hack for old ancient
classful broadcast so we can still netboot sparc and the like.
compat hack untested, i will deal with the fallout if there is any later
at the same time stop exporting in_iawithaddr, everything but ip_input
should (and now does) use ifa_ifwithaddr directly
ok dlg sthen and agreement from many
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.39 2009/06/05 00:05:22 claudio Exp $	*/
d174 2
@


1.39
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.38 2008/05/23 15:51:12 thib Exp $	*/
a173 2
struct in_ifaddr *
	 in_iawithaddr(struct in_addr, struct mbuf *, u_int);
@


1.38
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.37 2007/09/18 18:56:02 markus Exp $	*/
d175 1
a175 1
	 in_iawithaddr(struct in_addr, struct mbuf *);
d177 1
a177 1
	 ip_rtaddr(struct in_addr);
d180 1
a180 1
int	 ip_setmoptions(int, struct ip_moptions **, struct mbuf *);
@


1.37
log
@allow 4095 instead of 20 multicast group memberships per socket (you need
one entry for each multicast group and interface combination). this allows
you to run OSPF with more than 10 interfaces.
adapted from freebsd; ok claudio, henning, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.36 2006/05/29 20:42:27 claudio Exp $	*/
d195 1
a195 1
	    int, struct mbuf *, struct mbuf *, struct mbuf *);
@


1.36
log
@Make savecontrol functions more generic and use them now for raw IP too.
Additionally add the IP_RECVIF option which returns the interface a packet
was received on. OK markus@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.35 2005/08/11 12:55:31 mpf Exp $	*/
d99 2
a100 1
	struct	  in_multi *imo_membership[IP_MAX_MEMBERSHIPS];
@


1.35
log
@New counter for not joined IPv4 multicast groups.
Don't count link local scope multicast as not forwardable.
This stops ips_cantforward growing on carp(4) networks.
tested and ok mcbride@@, ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.34 2005/08/02 11:05:44 markus Exp $	*/
d155 1
d185 2
@


1.34
log
@change the TCP reass queue from LIST to TAILQ;
ok henning claudio fgsch krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.33 2005/05/27 04:55:28 mcbride Exp $	*/
d134 1
@


1.33
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.32 2004/06/22 07:35:20 cedric Exp $	*/
d52 1
a52 9
 * Ip (reassembly or sequence) queue structures.
 *
 * XXX -- The following explains why the ipqe_m field is here, for TCP's use:
 * We want to avoid doing m_pullup on incoming packets but that
 * means avoiding dtom on the tcp reassembly code.  That in turn means
 * keeping an mbuf pointer in the reassembly queue (since we might
 * have a cluster).  As a quick hack, the source & destination
 * port numbers (which are no longer needed once we've located the
 * tcpcb) are overlayed with an mbuf pointer.
d57 1
a57 4
	union {
		struct ip	*_ip;
		struct tcphdr	*_tcp;
	} _ipqe_u1;
a60 2
#define	ipqe_ip		_ipqe_u1._ip
#define	ipqe_tcp	_ipqe_u1._tcp
@


1.32
log
@Pull the plug on source-based routing until remaining bugs are eradicated.
No need to reconfig kernel or rebuild userland stuff.
requested deraadt@@, help beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.31 2004/06/06 16:49:09 cedric Exp $	*/
d155 3
a157 2
#define	IP_MTUDISC		0x0400		/* pmtu discovery, set DF */
#define IP_ROUTETOETHER		0x0800		/* ether addresses given */
@


1.31
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.30 2004/04/28 02:51:58 cedric Exp $	*/
d186 1
a186 1
	 ip_rtaddr(struct in_addr, struct in_addr);
@


1.30
log
@make return-rst work on pure bridges. ok dhartmei@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.29 2003/06/02 23:28:14 millert Exp $	*/
d186 1
a186 1
	 ip_rtaddr(struct in_addr);
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.28 2003/02/12 14:41:08 jason Exp $	*/
d156 1
@


1.28
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.27 2002/12/09 00:45:37 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.27
log
@From Andrushock, s/sucess/success/g
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.26 2002/07/03 21:19:08 miod Exp $	*/
d162 1
a162 1
LIST_HEAD(ipqhead, ipq)	ipq;		/* ip reass. queue */
@


1.26
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.25 2002/06/09 16:26:10 itojun Exp $	*/
d137 1
a137 1
	u_long	ips_fragmented;		/* datagrams sucessfully fragmented */
@


1.25
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.24 2002/05/31 20:58:25 itojun Exp $	*/
d161 1
a161 1
struct	  ipstat ipstat;
d163 1
a163 1
int	  ip_defttl;			/* default IP ttl */
d165 3
a167 3
int   ip_mtudisc;		/* mtu discovery */
u_int ip_mtudisc_timeout;	/* seconds to timeout mtu discovery */
struct rttimer_queue *ip_mtudisc_timeout_q;
@


1.24
log
@respect rmx_mtu (cached PMTUD result) on outbound.  deraadt/angelos ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.23 2002/05/28 15:44:28 jasoni Exp $	*/
d190 1
a190 1
u_int16_t	
@


1.23
log
@Factor out IP fragmentation code into its own function so it can be
reused.
- ok jason@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.22 2002/03/14 01:27:11 millert Exp $	*/
d175 1
a175 1
int	 ip_fragment(struct mbuf *, struct ifnet *);
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.21 2002/01/24 22:42:48 provos Exp $	*/
d175 1
@


1.21
log
@allocate tcp reassembly queue via pool; based on netbsd; okay art@@ angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.19 2001/06/09 07:03:42 angelos Exp $	*/
d170 13
a182 13
int	 ip_ctloutput __P((int, struct socket *, int, int, struct mbuf **));
int	 ip_dooptions __P((struct mbuf *));
void	 ip_drain __P((void));
void	 ip_flush __P((void));
void	 ip_forward __P((struct mbuf *, int));
void	 ip_freef __P((struct ipq *));
void	 ip_freemoptions __P((struct ip_moptions *));
int	 ip_getmoptions __P((int, struct ip_moptions *, struct mbuf **));
void	 ip_init __P((void));
int	 ip_mforward __P((struct mbuf *, struct ifnet *));
int	 ip_optcopy __P((struct ip *, struct ip *));
int	 ip_output __P((struct mbuf *, ...));
int	 ip_pcbopts __P((struct mbuf **, struct mbuf *));
d184 1
a184 1
	 ip_reass __P((struct ipqent *, struct ipq *));
d186 1
a186 1
	 in_iawithaddr __P((struct in_addr, struct mbuf *));
d188 1
a188 1
	 ip_rtaddr __P((struct in_addr));
d190 3
a192 3
	 ip_randomid __P((void));
int	 ip_setmoptions __P((int, struct ip_moptions **, struct mbuf *));
void	 ip_slowtimo __P((void));
d194 11
a204 11
	 ip_srcroute __P((void));
void	 ip_stripoptions __P((struct mbuf *, struct mbuf *));
int	 ip_sysctl __P((int *, u_int, void *, size_t *, void *, size_t));
void	 ipintr __P((void));
void	 ipv4_input __P((struct mbuf *));
int	 rip_ctloutput __P((int, struct socket *, int, int, struct mbuf **));
void	 rip_init __P((void));
void	 rip_input __P((struct mbuf *, ...));
int	 rip_output __P((struct mbuf *, ...));
int	 rip_usrreq __P((struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *));
@


1.20
log
@Hardware checksumming stats.
@
text
@d168 1
@


1.20.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.21 2002/01/24 22:42:48 provos Exp $	*/
a167 1
extern struct pool ipqent_pool;
@


1.20.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.20.4.1 2002/01/31 22:55:45 niklas Exp $	*/
d170 13
a182 14
int	 ip_ctloutput(int, struct socket *, int, int, struct mbuf **);
int	 ip_dooptions(struct mbuf *);
void	 ip_drain(void);
void	 ip_flush(void);
void	 ip_forward(struct mbuf *, int);
int	 ip_fragment(struct mbuf *, struct ifnet *, u_long);
void	 ip_freef(struct ipq *);
void	 ip_freemoptions(struct ip_moptions *);
int	 ip_getmoptions(int, struct ip_moptions *, struct mbuf **);
void	 ip_init(void);
int	 ip_mforward(struct mbuf *, struct ifnet *);
int	 ip_optcopy(struct ip *, struct ip *);
int	 ip_output(struct mbuf *, ...);
int	 ip_pcbopts(struct mbuf **, struct mbuf *);
d184 1
a184 1
	 ip_reass(struct ipqent *, struct ipq *);
d186 1
a186 1
	 in_iawithaddr(struct in_addr, struct mbuf *);
d188 1
a188 1
	 ip_rtaddr(struct in_addr);
d190 3
a192 3
	 ip_randomid(void);
int	 ip_setmoptions(int, struct ip_moptions **, struct mbuf *);
void	 ip_slowtimo(void);
d194 11
a204 11
	 ip_srcroute(void);
void	 ip_stripoptions(struct mbuf *, struct mbuf *);
int	 ip_sysctl(int *, u_int, void *, size_t *, void *, size_t);
void	 ipintr(void);
void	 ipv4_input(struct mbuf *);
int	 rip_ctloutput(int, struct socket *, int, int, struct mbuf **);
void	 rip_init(void);
void	 rip_input(struct mbuf *, ...);
int	 rip_output(struct mbuf *, ...);
int	 rip_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *);
@


1.20.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.20.4.2 2002/06/11 03:31:37 art Exp $	*/
d161 1
a161 1
extern struct ipstat ipstat;
d163 1
a163 1
extern int ip_defttl;			/* default IP ttl */
d165 3
a167 3
extern int ip_mtudisc;			/* mtu discovery */
extern u_int ip_mtudisc_timeout;	/* seconds to timeout mtu discovery */
extern struct rttimer_queue *ip_mtudisc_timeout_q;
d190 1
a190 1
u_int16_t
@


1.20.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d137 1
a137 1
	u_long	ips_fragmented;		/* datagrams successfully fragmented */
d162 1
a162 1
extern LIST_HEAD(ipqhead, ipq)	ipq;	/* ip reass. queue */
@


1.19
log
@Inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.18 2001/05/28 05:29:36 angelos Exp $	*/
d149 2
@


1.18
log
@IP_ENCAPSULATED is deprecated.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.17 2001/05/20 19:19:57 fgsch Exp $	*/
d39 3
d202 2
a203 1
#endif
@


1.17
log
@Remove varargs from ipv4_input; cmetz@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.16 2001/05/01 09:55:49 provos Exp $	*/
a154 1
#define	IP_ENCAPSULATED		0x0800		/* encapsulated already */
@


1.16
log
@get rid of dtom(), okay itojun@@ angelos@@ mickey@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.15 2001/03/03 01:00:19 itojun Exp $	*/
d193 1
a193 1
void	 ipv4_input __P((struct mbuf *, ...));
@


1.15
log
@drop packets with 127.0.0.0/8 in header field, if the packet is from outside.
under RFC1122 sender rule 127.0.0.8 must not appear on the wire.
count incidents by ipstat.ips_badaddr.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.14 2000/09/18 22:06:38 provos Exp $	*/
d70 2
a71 4
	union {
		u_int8_t	_mff;	/* for IP fragmentation */
		struct mbuf	*_m;	/* XXX for TCP; see above */
	} _ipqe_u2;
a74 2
#define	ipqe_mff	_ipqe_u2._mff
#define	ipqe_m		_ipqe_u2._m
d178 1
a178 1
struct ip *
@


1.14
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.13 2000/01/02 09:00:19 angelos Exp $	*/
d149 1
@


1.13
log
@Remove the ifdef for IP_ENCAPSULATED.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.12 1999/12/08 06:50:20 itojun Exp $	*/
d157 1
d163 4
@


1.13.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.15 2001/03/03 01:00:19 itojun Exp $	*/
a148 1
	u_long	ips_badaddr;		/* invalid address on header */
a156 1
#define	IP_MTUDISC		0x0400		/* pmtu discovery, set DF */
a161 4

int   ip_mtudisc;		/* mtu discovery */
u_int ip_mtudisc_timeout;	/* seconds to timeout mtu discovery */
struct rttimer_queue *ip_mtudisc_timeout_q;
@


1.13.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.13.2.1 2001/05/14 22:40:13 niklas Exp $	*/
a38 3
#ifndef _NETINET_IP_VAR_H_
#define _NETINET_IP_VAR_H_

d70 4
a73 2
	struct mbuf	*ipqe_m;	/* mbuf contains packet */
	u_int8_t	ipqe_mff;	/* for IP fragmentation */
d77 2
a149 2
	u_long	ips_inhwcsum;		/* hardware checksummed on input */
	u_long	ips_outhwcsum;		/* hardware checksummed on output */
d159 1
d182 1
a182 1
struct mbuf *
d197 1
a197 1
void	 ipv4_input __P((struct mbuf *));
d204 1
a204 2
#endif /* _KERNEL */
#endif /* _NETINET_IP_VAR_H_ */
@


1.13.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a167 1
extern struct pool ipqent_pool;
@


1.13.2.4
log
@Merge in -current from roughly a week ago
@
text
@d170 13
a182 13
int	 ip_ctloutput(int, struct socket *, int, int, struct mbuf **);
int	 ip_dooptions(struct mbuf *);
void	 ip_drain(void);
void	 ip_flush(void);
void	 ip_forward(struct mbuf *, int);
void	 ip_freef(struct ipq *);
void	 ip_freemoptions(struct ip_moptions *);
int	 ip_getmoptions(int, struct ip_moptions *, struct mbuf **);
void	 ip_init(void);
int	 ip_mforward(struct mbuf *, struct ifnet *);
int	 ip_optcopy(struct ip *, struct ip *);
int	 ip_output(struct mbuf *, ...);
int	 ip_pcbopts(struct mbuf **, struct mbuf *);
d184 1
a184 1
	 ip_reass(struct ipqent *, struct ipq *);
d186 1
a186 1
	 in_iawithaddr(struct in_addr, struct mbuf *);
d188 1
a188 1
	 ip_rtaddr(struct in_addr);
d190 3
a192 3
	 ip_randomid(void);
int	 ip_setmoptions(int, struct ip_moptions **, struct mbuf *);
void	 ip_slowtimo(void);
d194 11
a204 11
	 ip_srcroute(void);
void	 ip_stripoptions(struct mbuf *, struct mbuf *);
int	 ip_sysctl(int *, u_int, void *, size_t *, void *, size_t);
void	 ipintr(void);
void	 ipv4_input(struct mbuf *);
int	 rip_ctloutput(int, struct socket *, int, int, struct mbuf **);
void	 rip_init(void);
void	 rip_input(struct mbuf *, ...);
int	 rip_output(struct mbuf *, ...);
int	 rip_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *);
@


1.13.2.5
log
@Sync the SMP branch with 3.3
@
text
@d137 1
a137 1
	u_long	ips_fragmented;		/* datagrams successfully fragmented */
d161 3
a163 3
extern struct ipstat ipstat;
extern LIST_HEAD(ipqhead, ipq)	ipq;	/* ip reass. queue */
extern int ip_defttl;			/* default IP ttl */
d165 3
a167 3
extern int ip_mtudisc;			/* mtu discovery */
extern u_int ip_mtudisc_timeout;	/* seconds to timeout mtu discovery */
extern struct rttimer_queue *ip_mtudisc_timeout_q;
a174 1
int	 ip_fragment(struct mbuf *, struct ifnet *, u_long);
d189 1
a189 1
u_int16_t
@


1.13.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.13.2.5 2003/03/28 00:06:54 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.13.2.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a155 1
#define IP_ROUTETOETHER		0x0800		/* ether addresses given */
@


1.13.2.8
log
@sync to head
@
text
@d186 1
a186 1
	 ip_rtaddr(struct in_addr, struct in_addr);
@


1.12
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.11 1999/02/17 23:51:12 deraadt Exp $	*/
a156 2

#ifdef IPSEC
a157 1
#endif
@


1.11
log
@add fragment flood protection; configureable using sysctl ip.maxqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.10 1999/01/11 02:01:34 deraadt Exp $	*/
d148 1
@


1.10
log
@netinet merge of NRL stuff. some indent and shrinkage needed; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.9 1998/12/26 12:35:12 provos Exp $	*/
d168 1
@


1.9
log
@make ip_id random but ensure that ids dont repeat for some period.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.8 1998/02/14 18:50:36 mickey Exp $	*/
d68 1
a68 1
		struct tcpiphdr *_tcp;
d192 1
@


1.8
log
@wildcard ifaces; finally, after HE said it's ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.7 1998/02/01 21:46:03 deraadt Exp $	*/
a162 1
u_int16_t ip_id;			/* ip packet ctr, for ids */
d183 2
@


1.7
log
@undo wildcard loopback stuff; it was not checked by other developers
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.5 1997/02/20 01:08:09 deraadt Exp $	*/
d180 2
@


1.6
log
@support wildcard loopbacks. that is, setting up lo1 like:
ifconfig lo1 inet 192.168.1.1 netmask 255.255.255.0 link1
would force it to act like all the addresses from net 192.168.1 were
added to the interface.
todo: man lo
@
text
@a180 2
	 in_iawithaddr __P((struct in_addr, struct mbuf *));
struct in_ifaddr *
@


1.5
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.4 1997/01/26 01:23:44 tholo Exp $	*/
d180 2
@


1.4
log
@Make ip_len and ip_off unsigned values; don't transmit or accept packets
larger than the maximum IP packet size.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_var.h,v 1.3 1996/03/03 22:30:42 niklas Exp $	*/
d156 4
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 5
a49 5
	u_int8_t ih_x1[9];		/* (unused) */
	u_int8_t ih_pr;			/* protocol */
	int16_t	 ih_len;		/* protocol length */
	struct	 in_addr ih_src;	/* source internet address */
	struct	 in_addr ih_dst;	/* destination internet address */
d147 1
@


1.2
log
@from netbsd:
make netinet work on systems where pointers and longs are 64 bits
(like the alpha).  Biggest problem: IP headers were overlayed with
structure which included pointers, and which therefore didn't overlay
properly on 64-bit machines.  Solution: instead of threading pointers
through IP header overlays, add a "queue element" structure to do
the threading, and point it at the ip headers.
@
text
@d1 2
a2 1
/*	$NetBSD: ip_var.h,v 1.15 1995/11/21 01:07:38 cgd Exp $	*/
d171 1
a171 2
int	 ip_output __P((struct mbuf *,
	    struct mbuf *, struct route *, int, struct ip_moptions *));
d186 2
a187 2
void	 rip_input __P((struct mbuf *));
int	 rip_output __P((struct mbuf *, struct socket *, u_long));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ip_var.h,v 1.14 1995/06/12 00:47:47 mycroft Exp $	*/
d38 2
d44 1
a44 2
	caddr_t  ih_next, ih_prev;	/* for protocol sequence q's */
	u_int8_t ih_x1;			/* (unused) */
d52 28
d86 1
a86 1
	struct	  ipq *next, *prev;	/* to other reass headers */
d90 1
a90 2
	struct	  ipasfrag *ipq_next, *ipq_prev;
					/* to ip headers of fragments */
a94 27
 * Ip header, when holding a fragment.
 *
 * Note: ipf_next must be at same offset as ipq_next above
 */
struct	ipasfrag {
#if BYTE_ORDER == LITTLE_ENDIAN
	u_int8_t  ip_hl:4,
		  ip_v:4;
#endif
#if BYTE_ORDER == BIG_ENDIAN
	u_int8_t  ip_v:4,
		  ip_hl:4;
#endif
	u_int8_t  ipf_mff;		/* XXX overlays ip_tos: use low bit
					 * to avoid destroying tos;
					 * copied from (ip_off&IP_MF) */
	int16_t	  ip_len;
	u_int16_t ip_id;
	int16_t	  ip_off;
	u_int8_t  ip_ttl;
	u_int8_t  ip_p;
	u_int16_t ip_sum;
	struct	  ipasfrag *ipf_next, *ipf_prev;
					/* list of fragments */
};

/*
d145 1
d156 2
a157 2
struct	  ipq	 ipq;			/* ip reass. queue */
u_int16_t ip_id;				/* ip packet ctr, for ids */
a160 1
void	 ip_deq __P((struct ipasfrag *));
a162 1
void	 ip_enq __P((struct ipasfrag *, struct ipasfrag *));
d174 1
a174 1
	 ip_reass __P((struct ipasfrag *, struct ipq *));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
