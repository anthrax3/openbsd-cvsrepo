head	1.43;
access;
symbols
	OPENBSD_6_2:1.43.0.2
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.41.0.4
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.4
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.28.0.10
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.8
	OPENBSD_5_0:1.28.0.6
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.4
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.27.0.6
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	SMP:1.4.0.2;
locks; strict;
comment	@ * @;


1.43
date	2017.05.30.12.09.27;	author friehm;	state Exp;
branches;
next	1.42;
commitid	0nYUFDGviFDMy9X0;

1.42
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.41;
commitid	00hB28wQPwG5Ysk0;

1.41
date	2017.02.20.06.29.42;	author jca;	state Exp;
branches;
next	1.40;
commitid	z4VhCYQTCyPI8KSQ;

1.40
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.39;
commitid	3e3CkrbYekyVOcxy;

1.39
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.38;
commitid	pVtptbHA3yk4jSpN;

1.38
date	2016.06.06.07.01.37;	author mpi;	state Exp;
branches;
next	1.37;
commitid	mnLuUpnr9sCjxcYm;

1.37
date	2015.11.18.13.53.59;	author mpi;	state Exp;
branches;
next	1.36;
commitid	ZQMHTobXPzXsynNo;

1.36
date	2015.11.02.15.05.23;	author mpi;	state Exp;
branches;
next	1.35;
commitid	aK60XMOKqPFfSdCc;

1.35
date	2015.10.22.13.30.29;	author mpi;	state Exp;
branches;
next	1.34;
commitid	EHE1hTlKKSkaEqck;

1.34
date	2015.06.08.13.40.48;	author mpi;	state Exp;
branches;
next	1.33;
commitid	HBw1Z8jFgWtpRSr4;

1.33
date	2015.06.02.09.38.24;	author mpi;	state Exp;
branches;
next	1.32;
commitid	9P4LdKlfMy8SaZ0b;

1.32
date	2014.12.19.05.36.28;	author tedu;	state Exp;
branches;
next	1.31;
commitid	FclwmuvOyWeTJgyk;

1.31
date	2014.04.20.14.54.39;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2014.01.22.09.35.20;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2012.10.08.18.48.25;	author camield;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.25.17.38.53;	author mpf;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.14.21.46.22;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2008.02.05.22.57.31;	author mpf;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.14.18.33.40;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.22.01.21.40;	author mpf;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.03.06.10.54;	author joel;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.02.19.53.12;	author mpf;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.27.02.19.32;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.10.01.30.14;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.20.23.00.41;	author mpf;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.01.19.04.56;	author mcbride;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.18.23.26.52;	author mpf;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.19.03.25.37;	author mcbride;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.17.12.42.01;	author pascoe;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.15.14.01.03;	author pat;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.14.01.59.07;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.10.22.35.17;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.08.06.57.55;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.07.20.38.47;	author mcbride;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.29.22.12.15;	author mcbride;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.05.01.20.12;	author mcbride;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.28.01.53.45;	author mcbride;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.28.00.28.43;	author mcbride;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.16.20.30.07;	author avsm;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.11.07.23.38.48;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.31.09.00.32;	author mcbride;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.17.21.04.58;	author mcbride;	state Exp;
branches;
next	;

1.4.2.1
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Carp balancing ip does not work since there is a mac filter in
ether_input(). Now we use mbuf tags instead of modifying the MAC
address.

ok mpi@@
@
text
@/*	$OpenBSD: ip_carp.h,v 1.42 2017/04/14 20:46:31 bluhm Exp $	*/

/*
 * Copyright (c) 2002 Michael Shalayeff. All rights reserved.
 * Copyright (c) 2003 Ryan McBride. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _NETINET_IP_CARP_H_
#define _NETINET_IP_CARP_H_

/*
 * The CARP header layout is as follows:
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |Version| Type  | VirtualHostID |    AdvSkew    |    Auth Len   |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |    Demotion   |     AdvBase   |          Checksum             |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                         Counter (1)                           |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                         Counter (2)                           |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                        SHA-1 HMAC (1)                         |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                        SHA-1 HMAC (2)                         |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                        SHA-1 HMAC (3)                         |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                        SHA-1 HMAC (4)                         |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *    |                        SHA-1 HMAC (5)                         |
 *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 */

struct carp_header {
#if _BYTE_ORDER == _LITTLE_ENDIAN
	u_int		carp_type:4,
			carp_version:4;
#endif
#if _BYTE_ORDER == _BIG_ENDIAN
	u_int		carp_version:4,
			carp_type:4;
#endif
	u_int8_t	carp_vhid;	/* virtual host id */
	u_int8_t	carp_advskew;	/* advertisement skew */
	u_int8_t	carp_authlen;   /* size of counter+md, 32bit chunks */
	u_int8_t	carp_demote;	/* demotion indicator */
	u_int8_t	carp_advbase;	/* advertisement interval */
	u_int16_t	carp_cksum;
	u_int32_t	carp_counter[2];
	unsigned char	carp_md[20];	/* SHA1 HMAC */
} __packed;

#define	CARP_DFLTTL		255

/* carp_version */
#define	CARP_VERSION		2

/* carp_type */
#define	CARP_ADVERTISEMENT	0x01

#define	CARP_KEY_LEN		20	/* a sha1 hash of a passphrase */

/* carp_advbase */
#define	CARP_DFLTINTV		1

/*
 * Statistics.
 */
struct carpstats {
	u_int64_t	carps_ipackets;		/* total input packets, IPv4 */
	u_int64_t	carps_ipackets6;	/* total input packets, IPv6 */
	u_int64_t	carps_badif;		/* wrong interface */
	u_int64_t	carps_badttl;		/* TTL is not CARP_DFLTTL */
	u_int64_t	carps_hdrops;		/* packets shorter than hdr */
	u_int64_t	carps_badsum;		/* bad checksum */
	u_int64_t	carps_badver;		/* bad (incl unsupp) version */
	u_int64_t	carps_badlen;		/* data length does not match */
	u_int64_t	carps_badauth;		/* bad authentication */
	u_int64_t	carps_badvhid;		/* bad VHID */
	u_int64_t	carps_badaddrs;		/* bad address list */

	u_int64_t	carps_opackets;		/* total output packets, IPv4 */
	u_int64_t	carps_opackets6;	/* total output packets, IPv6 */
	u_int64_t	carps_onomem;		/* no memory for an mbuf */
	u_int64_t	carps_ostates;		/* total state updates sent */

	u_int64_t	carps_preempt;		/* transitions to master */
};

#define CARPDEVNAMSIZ	16
#ifdef IFNAMSIZ
#if CARPDEVNAMSIZ != IFNAMSIZ
#error namsiz mismatch
#endif
#endif

/*
 * Configuration structure for SIOCSVH SIOCGVH
 */
struct carpreq {
	int		carpr_state;
#define	CARP_STATES	"INIT", "BACKUP", "MASTER"
#define	CARP_MAXSTATE	2
#define	CARP_MAXNODES	32

	char		carpr_carpdev[CARPDEVNAMSIZ];
	u_int8_t	carpr_vhids[CARP_MAXNODES];
	u_int8_t	carpr_advskews[CARP_MAXNODES];
	u_int8_t	carpr_states[CARP_MAXNODES];
#define	CARP_BAL_MODES	"none", "ip", "ip-stealth", "ip-unicast"
#define CARP_BAL_NONE		0
#define CARP_BAL_IP		1
#define CARP_BAL_IPSTEALTH	2
#define CARP_BAL_IPUNICAST	3
#define CARP_BAL_MAXID		3
	u_int8_t	carpr_balancing;
	int		carpr_advbase;
	unsigned char	carpr_key[CARP_KEY_LEN];
	struct in_addr	carpr_peer;
};

/*
 * Names for CARP sysctl objects
 */
#define	CARPCTL_ALLOW		1	/* accept incoming CARP packets */
#define	CARPCTL_PREEMPT		2	/* high-pri backup preemption mode */
#define	CARPCTL_LOG		3	/* log bad packets */
#define	CARPCTL_STATS		4	/* CARP stats */
#define	CARPCTL_MAXID		5

#define	CARPCTL_NAMES { \
	{ 0, 0 }, \
	{ "allow", CTLTYPE_INT }, \
	{ "preempt", CTLTYPE_INT }, \
	{ "log", CTLTYPE_INT }, \
	{ "stats", CTLTYPE_STRUCT }, \
}

#ifdef _KERNEL

#include <sys/percpu.h>

enum carpstat_counters {
	carps_ipackets,
	carps_ipackets6,
	carps_badif,
	carps_badttl,
	carps_hdrops,
	carps_badsum,
	carps_badver,
	carps_badlen,
	carps_badauth,
	carps_badvhid,
	carps_badaddrs,
	carps_opackets,
	carps_opackets6,
	carps_onomem,
	carps_ostates,
	carps_preempt,
	carps_ncounters,
};

extern struct cpumem *carpcounters;

static inline void
carpstat_inc(enum carpstat_counters c)
{
	counters_inc(carpcounters, c);
}

void		 carp_ifdetach (struct ifnet *);
int		 carp_proto_input(struct mbuf **, int *, int, int);
void		 carp_carpdev_state(void *);
void		 carp_group_demote_adj(struct ifnet *, int, char *);
int		 carp6_proto_input(struct mbuf **, int *, int, int);
int		 carp_iamatch(struct ifnet *);
int		 carp_iamatch6(struct ifnet *);
struct ifnet	*carp_ourether(void *, u_int8_t *);
int		 carp_output(struct ifnet *, struct mbuf *, struct sockaddr *,
		     struct rtentry *);
int		 carp_sysctl(int *, u_int,  void *, size_t *, void *, size_t);
int		 carp_lsdrop(struct mbuf *, sa_family_t, u_int32_t *,
		     u_int32_t *, int);
#endif /* _KERNEL */
#endif /* _NETINET_IP_CARP_H_ */
@


1.42
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.41 2017/02/20 06:29:42 jca Exp $	*/
d207 2
a208 1
int		 carp_lsdrop(struct mbuf *, sa_family_t, u_int32_t *, u_int32_t *);
@


1.41
log
@carp(4) percpu counters

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.40 2017/01/29 19:58:47 bluhm Exp $	*/
d197 1
a197 1
int		 carp_proto_input(struct mbuf **, int *, int);
d200 1
a200 1
int		 carp6_proto_input(struct mbuf **, int *, int);
@


1.40
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.39 2017/01/25 17:34:31 bluhm Exp $	*/
d165 31
@


1.39
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.38 2016/06/06 07:01:37 mpi Exp $	*/
d166 1
a166 1
void		 carp_proto_input (struct mbuf *, int, int);
@


1.38
log
@Get rid of the ``enaddr'' argument of carp_iamatch().

It was only checked in balancing mode, which is currently broken, and is
no longer needed.

Discusssed with bluhm@@ and Florian Riehm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.37 2015/11/18 13:53:59 mpi Exp $	*/
d166 1
a166 1
void		 carp_proto_input (struct mbuf *, ...);
@


1.37
log
@Make use of srp_enter()/srp_leave() in carp_iamatch() in preparation
for unlocking the ARP input path.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.36 2015/11/02 15:05:23 mpi Exp $	*/
d170 1
a170 1
int		 carp_iamatch(struct ifnet *, uint8_t *);
@


1.36
log
@Retire ARP load-balacing, thanks for all the fish!

One of the keys of our MP work relies on making OpenBSD's kernel simpler!
In this case turning ARP processing MP-safe is quite complicated due to
the way carp(4) is hooked in arpinput() and nowadays you'd better run
kitchensinkd(9) anyway :)

ok bluhm@@, claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.35 2015/10/22 13:30:29 mpi Exp $	*/
d170 1
a170 1
int		 carp_iamatch(struct ifnet *, uint8_t **);
@


1.35
log
@Do not pass an ``ia'' just to dereference ``ia_ifp''.

ok claudio@@, bluhm@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.34 2015/06/08 13:40:48 mpi Exp $	*/
d135 1
a135 1
#define	CARP_BAL_MODES	"none", "arp", "ip", "ip-stealth", "ip-unicast"
d137 4
a140 5
#define CARP_BAL_ARP		1
#define CARP_BAL_IP		2
#define CARP_BAL_IPSTEALTH	3
#define CARP_BAL_IPUNICAST	4
#define CARP_BAL_MAXID		4
d170 2
a171 3
int		 carp_iamatch(struct ifnet *, u_char *, u_int8_t **,
		     u_int8_t **);
int		 carp_iamatch6(struct ifnet *, u_char *, struct sockaddr_dl **);
@


1.34
log
@Move carp-related logic from ether_output() into carp_start().

ok sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.33 2015/06/02 09:38:24 mpi Exp $	*/
d171 1
a171 1
int		 carp_iamatch(struct in_ifaddr *, u_char *, u_int8_t **,
@


1.33
log
@Take carp(4) out of ether_input().

Tested by <mxb AT alumni DOT chalmers DOT se>, thanks!

ok bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.32 2014/12/19 05:36:28 tedu Exp $	*/
a178 1
u_char		*carp_get_srclladdr(struct ifnet *, u_char *);
@


1.32
log
@add messages to #error so we know what's what (and so unifdef doesn't poop)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.31 2014/04/20 14:54:39 henning Exp $	*/
a174 2
int		 carp_input(struct ifnet *, struct ether_header *,
		     struct mbuf *);
a179 1
int		 carp_our_mcastaddr(struct ifnet *, u_int8_t *);
@


1.31
log
@ether_output: instead of assembling the ethernet header and then calling
carp_rewrite_lladdr to overwrite the src lladdr, get the intended src
lladdr before assembling the ethernet header.
carp_rewrite_lladdr -> carp_get_srclladdr
ok reyk claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.29 2012/10/08 18:48:25 camield Exp $	*/
d118 1
a118 1
#error
@


1.30
log
@Pass the receiving interface pointer to carp_input() instead of re-
reading it from the packet header.  While here makes carp_input()
take the same arguments as ether_input().

ok bluhm@@, mikeb@@
@
text
@d181 1
a181 1
void		 carp_rewrite_lladdr(struct ifnet *, u_int8_t *);
@


1.29
log
@Make carp_ourether() shorter and more generic.  Only a mac address
is really needed, instead of an ethernet header and selector.

ok mikeb henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.28 2010/04/25 17:38:53 mpf Exp $	*/
d175 2
a176 1
int		 carp_input(struct mbuf *, u_int8_t *, u_int8_t *, u_int16_t);
@


1.28
log
@Properly adjust group demotion counters when groups are added or
removed.  Extend carp demote logging to also show the reason for
the demote.  Return EINVAL instead of ERANGE if a carpdemote request
is out range.  Requested from otto.
OK mcbride, henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.27 2008/06/14 21:46:22 reyk Exp $	*/
d174 1
a174 1
struct ifnet	*carp_ourether(void *, struct ether_header *, int);
@


1.27
log
@add carppeer; an option to specify a different multicast address or
even the unicast address of the remote carp peer. this especially
helps when the multicast carp advertisements are causing problems in
the network (some crappy switches don't do well with multicast), there
are conflicts with VRRP, or the policy of the network does not allow
multicast (most Internet eXchange points didn't allow carped OpenBGP
routers because of the multicast advertisements).

discussed with many
ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.26 2008/02/05 22:57:31 mpf Exp $	*/
d169 1
a169 1
void		 carp_group_demote_adj(struct ifnet *, int);
@


1.26
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.25 2007/12/14 18:33:40 deraadt Exp $	*/
d145 1
d174 1
a174 1
struct ifnet	*carp_ourether(void *, struct ether_header *, u_char, int);
@


1.25
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.24 2007/11/22 01:21:40 mpf Exp $	*/
d135 8
d153 2
a154 3
#define	CARPCTL_ARPBALANCE	4	/* balance arp responses */
#define	CARPCTL_STATS		5	/* CARP stats */
#define	CARPCTL_MAXID		6
a160 1
	{ "arpbalance", CTLTYPE_INT }, \
d170 3
a172 3
int		 carp_iamatch(struct in_ifaddr *, u_char *,
		     u_int32_t *, u_int32_t);
int		 carp_iamatch6(struct ifnet *, struct ifaddr *);
d180 1
@


1.24
log
@Factor out the virtual host portion of carp into a separate struct
that is kept in a list per carp interface.  This is the huge first
step necessary to make carp load balancing nice and easy. One carp
interface can now contain up to 32 virtual host instances.
This doesn't do anything useful yet, but here is how an ifconfig
for multiple entries now looks like:

# ifconfig carp2 carpnodes 5:0,6:100 192.168.5.88

carp2: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        lladdr 00:00:5e:00:01:05
        carp: carpdev sis0 advbase 1
                state MASTER vhid 5 advskew 0
                state BACKUP vhid 6 advskew 100
        groups: carp
        inet 192.168.5.88 netmask 0xffffff00 broadcast 192.168.5.255

OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.23 2007/09/03 06:10:54 joel Exp $	*/
d146 2
a147 1
#define	CARPCTL_MAXID		5
d155 1
@


1.23
log
@Make use of the carp preempt counter to signal number of transitions of
any carp group to master status.


ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.22 2007/03/18 23:23:17 mpf Exp $	*/
d129 1
d132 3
a134 2
	int		carpr_vhid;
	int		carpr_advskew;
d171 1
@


1.22
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.21 2006/06/02 19:53:12 mpf Exp $	*/
d112 1
a112 1
	u_int64_t	carps_preempt;		/* if enabled, preemptions */
@


1.21
log
@Introduce attributes to interface groups.
As a first user, move the global carp(4) demotion counter
into the interface group. Thus we have the possibility
to define which carp interfaces are demoted together.

Put the demotion counter into the reserved field of the carp header.
With this, we can have carp act smarter if multiple errors occur.
It now always takes over other carp peers, that are advertising
with a higher demote count.  As a side effect, we can also have
group failovers without the need of running in preempt mode.
The protocol change does not break compability with older
implementations.

Collaborative work with mcbride@@

OK mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.20 2006/04/27 02:19:32 tedu Exp $	*/
d162 1
a162 1
struct ifaddr	*carp_iamatch6(void *, struct in6_addr *);
d168 1
@


1.20
log
@use underscore variants of _BYTE_ORDER macros which are always defined
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.19 2005/12/10 01:30:14 deraadt Exp $	*/
d40 1
a40 1
 *    |   Reserved    |     AdvBase   |          Checksum             |
d71 1
a71 1
	u_int8_t	carp_pad1;	/* reserved */
d158 1
@


1.19
log
@in ansi c, bitfields must be done against int, unsigned int, or _Bool.
so we must start to use u_int; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.18 2005/04/20 23:00:41 mpf Exp $	*/
d60 1
a60 1
#if BYTE_ORDER == LITTLE_ENDIAN
d64 1
a64 1
#if BYTE_ORDER == BIG_ENDIAN
@


1.18
log
@Introduce if_linkstatehooks.
This converts if_link_state_change() to a generic usable
callback with dohooks().

OK henning@@, camield@@
Tested by camield@@ and Alexey E. Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.17 2005/03/01 19:04:56 mcbride Exp $	*/
d61 1
a61 1
	u_int8_t	carp_type:4,
d65 1
a65 1
	u_int8_t	carp_version:4,
@


1.17
log
@Unbreak arp_input with carp; add back the call to carp_iamatch()
which was removed in rev 1.57. This makes arpbalance work again, and
ensures that only one carp host will reply to a given arp request.

ok mpf@@ pascoe@@ dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.16 2005/01/18 23:26:52 mpf Exp $	*/
d157 1
a157 1
void		 carp_carpdev_state(struct ifnet *);
@


1.16
log
@Rewriting the lladdr can now be done without using mbuf tags.
Advertisements run through the carp interface first.
So we just take the address from ifp0.
While we're there,
also remove carp_macmatch6, which isn't used anymore.

Proposed by mcbride@@
ok mcbride@@, pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.15 2004/12/19 03:25:37 mcbride Exp $	*/
d159 2
a160 2
int		 carp_iamatch(void *, struct in_ifaddr *, struct in_addr *,
		     u_int8_t **);
@


1.15
log
@Make it possible for carp to work on fddi and token ring again.

ok pascoe@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.14 2004/12/17 12:42:01 pascoe Exp $	*/
a158 2
int		 carp_fix_lladdr(struct ifnet *, struct mbuf *,
		     struct sockaddr *, struct rtentry *);
a161 1
void		*carp_macmatch6(void *, struct mbuf *, struct in6_addr *);
@


1.14
log
@Reorder code in the ethernet output path, and enhance unicast address
matching in the bridge receive path to make CARP operate correctly
on physical interfaces that are participating in a bridge.

ok mcbride@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.13 2004/12/15 14:01:03 pat Exp $	*/
d165 4
a168 2
struct ifnet	*carp_ourether(void *, struct ether_header *, int);
int		 carp_input(struct ether_header *, struct mbuf *);
@


1.13
log
@protect against multiple inclusion

mcbride ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.12 2004/12/14 01:59:07 mickey Exp $	*/
d165 1
@


1.12
log
@move ioctls together w/ all other ifaces; mcbride@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.11 2004/12/10 22:35:17 mcbride Exp $	*/
d29 3
d167 2
a168 1
#endif
@


1.11
log
@Rename carp_output() to carp_fix_lladdr().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.10 2004/12/08 06:57:55 mcbride Exp $	*/
a132 2
#define	SIOCSVH	_IOWR('i', 245, struct ifreq)
#define	SIOCGVH	_IOWR('i', 246, struct ifreq)
@


1.10
log
@Check if_type in carp_carpdev_state() to make sure we're not
dealing with a carp interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.9 2004/12/07 20:38:47 mcbride Exp $	*/
d158 2
a159 2
int		 carp_output(struct ifnet *, struct mbuf *, struct sockaddr *,
		     struct rtentry *);
@


1.9
log
@Convert carp(4) to behave more like a regular interface, much in the same
style as vlan(4). carp interfaces no longer require the physical interface
to be on the same subnet as the carp interface, or even that the physical
interface has an adress at all, so CARP can now be used on /30 networks.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.8 2004/07/29 22:12:15 mcbride Exp $	*/
d156 1
a156 1
void		 carp_carpdev_state(void *);
@


1.8
log
@Document the CARP header layout.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.7 2004/05/05 01:20:12 mcbride Exp $	*/
d112 7
d126 2
d155 1
a155 1
void		 carp_input (struct mbuf *, ...);
d157 2
a158 2
int		 carp6_input (struct mbuf **, int *, int);
int		 carp_output (struct ifnet *, struct mbuf *, struct sockaddr *,
d160 1
a160 1
int		 carp_iamatch (void *, struct in_ifaddr *, struct in_addr *,
d164 2
a165 2
struct	ifnet	*carp_forus (void *, void *);
int		 carp_sysctl (int *, u_int,  void *, size_t *, void *, size_t);
@


1.7
log
@Remove unused #define.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.6 2004/04/28 01:53:45 mcbride Exp $	*/
d29 27
d72 1
a72 1
	unsigned char	carp_md[20];	/* sha1 message digest */
@


1.6
log
@carp stats cleanup:
- convert counters to 64 bits
- remove junk from netstat

ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.5 2004/04/28 00:28:43 mcbride Exp $	*/
a54 1
#define	CARP_LEAVE_GROUP	0x02
@


1.5
log
@Make carp(4) aware of its physical interface:
- If the physical interface goes down or the link goes down,
  the carp interface goes down as well.
- We treat this like the preemption holdoff with pfsync.
  So if one of the carp interfaces is known to be bad (because the
  physical interface it's associated with is bad), all the other carp
  interfaces back off: they won't preempt, and their advskew goes to 240.

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.4 2003/11/16 20:30:07 avsm Exp $	*/
d66 16
a81 16
	u_long	carps_ipackets;		/* total input packets, IPv4 */
	u_long	carps_ipackets6;	/* total input packets, IPv6 */
	u_long	carps_badif;		/* wrong interface */
	u_long	carps_badttl;		/* TTL is not CARP_DFLTTL */
	u_long	carps_hdrops;		/* packets shorter than header */
	u_long	carps_badsum;		/* bad checksum */
	u_long	carps_badver;		/* bad (incl unsupp) version */
	u_long	carps_badlen;		/* data length does not match */
	u_long	carps_badauth;		/* bad authentication */
	u_long	carps_badvhid;		/* bad VHID */
	u_long	carps_badaddrs;		/* bad address list */

	u_long	carps_opackets;		/* total output packets, IPv4 */
	u_long	carps_opackets6;	/* total output packets, IPv6 */
	u_long	carps_onomem;		/* no memory for an mbuf for a send */
	u_long	carps_ostates;		/* total state updates sent */
d83 1
a83 1
	u_long	carps_preempt;		/* if enabled, high-pri preemptions */
@


1.4
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.3 2003/11/07 23:38:48 mcbride Exp $	*/
d121 1
@


1.4.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.2.2
log
@Merge with the trunk
@
text
@d55 1
d66 16
a81 16
	u_int64_t	carps_ipackets;		/* total input packets, IPv4 */
	u_int64_t	carps_ipackets6;	/* total input packets, IPv6 */
	u_int64_t	carps_badif;		/* wrong interface */
	u_int64_t	carps_badttl;		/* TTL is not CARP_DFLTTL */
	u_int64_t	carps_hdrops;		/* packets shorter than hdr */
	u_int64_t	carps_badsum;		/* bad checksum */
	u_int64_t	carps_badver;		/* bad (incl unsupp) version */
	u_int64_t	carps_badlen;		/* data length does not match */
	u_int64_t	carps_badauth;		/* bad authentication */
	u_int64_t	carps_badvhid;		/* bad VHID */
	u_int64_t	carps_badaddrs;		/* bad address list */

	u_int64_t	carps_opackets;		/* total output packets, IPv4 */
	u_int64_t	carps_opackets6;	/* total output packets, IPv6 */
	u_int64_t	carps_onomem;		/* no memory for an mbuf */
	u_int64_t	carps_ostates;		/* total state updates sent */
d83 1
a83 1
	u_int64_t	carps_preempt;		/* if enabled, preemptions */
a120 1
void		 carp_carpdev_state(void *);
@


1.3
log
@Check to make sure that the packet was received on a carp-enabled interface.

Pointed out by Marco Pfatschbacher, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.2 2003/10/31 09:00:32 mcbride Exp $	*/
d46 1
a46 1
} __attribute__((__packed__));
@


1.2
log
@Add IPv6 support to CARP.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_carp.h,v 1.1 2003/10/17 21:04:58 mcbride Exp $	*/
d68 1
@


1.1
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 2
a67 1
	u_long	carps_ipackets;		/* total input packets */
d77 2
a78 1
	u_long	carps_opackets;		/* total output packets */
d120 1
d125 2
@

