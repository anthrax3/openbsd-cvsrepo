head	1.342;
access;
symbols
	OPENBSD_6_2_BASE:1.342
	OPENBSD_6_1:1.336.0.4
	OPENBSD_6_1_BASE:1.336
	OPENBSD_6_0:1.325.0.4
	OPENBSD_6_0_BASE:1.325
	OPENBSD_5_9:1.318.0.2
	OPENBSD_5_9_BASE:1.318
	OPENBSD_5_8:1.286.0.4
	OPENBSD_5_8_BASE:1.286
	OPENBSD_5_7:1.276.0.2
	OPENBSD_5_7_BASE:1.276
	OPENBSD_5_6:1.266.0.4
	OPENBSD_5_6_BASE:1.266
	OPENBSD_5_5:1.257.0.4
	OPENBSD_5_5_BASE:1.257
	OPENBSD_5_4:1.243.0.2
	OPENBSD_5_4_BASE:1.243
	OPENBSD_5_3:1.235.0.2
	OPENBSD_5_3_BASE:1.235
	OPENBSD_5_2:1.230.0.2
	OPENBSD_5_2_BASE:1.230
	OPENBSD_5_1_BASE:1.225
	OPENBSD_5_1:1.225.0.2
	OPENBSD_5_0:1.223.0.2
	OPENBSD_5_0_BASE:1.223
	OPENBSD_4_9:1.214.0.2
	OPENBSD_4_9_BASE:1.214
	OPENBSD_4_8:1.210.0.2
	OPENBSD_4_8_BASE:1.210
	OPENBSD_4_7:1.204.0.2
	OPENBSD_4_7_BASE:1.204
	OPENBSD_4_6:1.194.0.4
	OPENBSD_4_6_BASE:1.194
	OPENBSD_4_5:1.193.0.2
	OPENBSD_4_5_BASE:1.193
	OPENBSD_4_4:1.191.0.2
	OPENBSD_4_4_BASE:1.191
	OPENBSD_4_3:1.190.0.2
	OPENBSD_4_3_BASE:1.190
	OPENBSD_4_2:1.188.0.2
	OPENBSD_4_2_BASE:1.188
	OPENBSD_4_1:1.184.0.2
	OPENBSD_4_1_BASE:1.184
	OPENBSD_4_0:1.180.0.2
	OPENBSD_4_0_BASE:1.180
	OPENBSD_3_9:1.173.0.2
	OPENBSD_3_9_BASE:1.173
	OPENBSD_3_8:1.172.0.2
	OPENBSD_3_8_BASE:1.172
	OPENBSD_3_7:1.169.0.2
	OPENBSD_3_7_BASE:1.169
	OPENBSD_3_6:1.167.0.2
	OPENBSD_3_6_BASE:1.167
	SMP_SYNC_A:1.163
	SMP_SYNC_B:1.163
	OPENBSD_3_5:1.160.0.2
	OPENBSD_3_5_BASE:1.160
	OPENBSD_3_4:1.156.0.2
	OPENBSD_3_4_BASE:1.156
	UBC_SYNC_A:1.152
	OPENBSD_3_3:1.152.0.2
	OPENBSD_3_3_BASE:1.152
	OPENBSD_3_2:1.149.0.2
	OPENBSD_3_2_BASE:1.149
	OPENBSD_3_1:1.143.0.2
	OPENBSD_3_1_BASE:1.143
	UBC_SYNC_B:1.150
	UBC:1.140.0.2
	UBC_BASE:1.140
	OPENBSD_3_0:1.137.0.2
	OPENBSD_3_0_BASE:1.137
	OPENBSD_2_9_BASE:1.89
	OPENBSD_2_9:1.89.0.2
	OPENBSD_2_8:1.83.0.2
	OPENBSD_2_8_BASE:1.83
	OPENBSD_2_7:1.68.0.2
	OPENBSD_2_7_BASE:1.68
	SMP:1.64.0.2
	SMP_BASE:1.64
	kame_19991208:1.55
	OPENBSD_2_6:1.49.0.2
	OPENBSD_2_6_BASE:1.49
	OPENBSD_2_5:1.45.0.2
	OPENBSD_2_5_BASE:1.45
	OPENBSD_2_4:1.36.0.2
	OPENBSD_2_4_BASE:1.36
	OPENBSD_2_3:1.26.0.2
	OPENBSD_2_3_BASE:1.26
	OPENBSD_2_2:1.24.0.2
	OPENBSD_2_2_BASE:1.24
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.342
date	2017.09.20.16.22.02;	author visa;	state Exp;
branches;
next	1.341;
commitid	gmf5pc2R5B512Twe;

1.341
date	2017.09.01.15.05.31;	author mpi;	state Exp;
branches;
next	1.340;
commitid	gLJLYG7mRiAwqMZc;

1.340
date	2017.05.29.14.36.22;	author mpi;	state Exp;
branches;
next	1.339;
commitid	Bm2EDWmoITKmkDvl;

1.339
date	2017.04.19.15.21.54;	author bluhm;	state Exp;
branches;
next	1.338;
commitid	86fZyVCZMRPZ29Fb;

1.338
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.337;
commitid	zztPc3QpQPdWwQ6h;

1.337
date	2017.04.09.17.57.58;	author dhill;	state Exp;
branches;
next	1.336;
commitid	eRsveMbENOTEvu0s;

1.336
date	2017.02.09.15.19.32;	author jca;	state Exp;
branches;
next	1.335;
commitid	Hew5AYIxyEp5lNbI;

1.335
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.334;
commitid	UBL7uwpXqTP4EWIu;

1.334
date	2017.01.10.09.01.18;	author mpi;	state Exp;
branches;
next	1.333;
commitid	xP9gcRskiS0BKnO6;

1.333
date	2016.12.19.09.22.24;	author rzalamena;	state Exp;
branches;
next	1.332;
commitid	5iifwOyfMyS6GiDF;

1.332
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.331;
commitid	QqHqT2WhCBWqYgGJ;

1.331
date	2016.11.28.10.14.00;	author mpi;	state Exp;
branches;
next	1.330;
commitid	kuUrgzaOKNxjZSgE;

1.330
date	2016.11.18.02.53.47;	author dlg;	state Exp;
branches;
next	1.329;
commitid	VkivwyRVzetroSYM;

1.329
date	2016.11.14.10.32.46;	author mpi;	state Exp;
branches;
next	1.328;
commitid	to0Je2i4V2FtpmS1;

1.328
date	2016.11.14.03.51.53;	author dlg;	state Exp;
branches;
next	1.327;
commitid	Khqq96MLd95C1Z1s;

1.327
date	2016.09.04.17.18.56;	author mpi;	state Exp;
branches;
next	1.326;
commitid	HZoTIRsGpjCkGxgK;

1.326
date	2016.08.15.11.35.25;	author dlg;	state Exp;
branches;
next	1.325;
commitid	CgCan1eMToI9G3qa;

1.325
date	2016.07.01.18.28.58;	author jca;	state Exp;
branches;
next	1.324;
commitid	RiYz9UgSDQ0nyfwA;

1.324
date	2016.06.23.09.08.56;	author henning;	state Exp;
branches;
next	1.323;
commitid	7R6jLMFqvbzrrjNK;

1.323
date	2016.05.31.07.33.22;	author mpi;	state Exp;
branches;
next	1.322;
commitid	WWRE5CIlcchQ2uxu;

1.322
date	2016.05.04.13.22.51;	author vgross;	state Exp;
branches;
next	1.321;
commitid	K4wQVlTX5GfpNjti;

1.321
date	2016.04.29.11.40.27;	author bluhm;	state Exp;
branches;
next	1.320;
commitid	AssGqte7zoGfKhWv;

1.320
date	2016.04.18.12.10.34;	author mpi;	state Exp;
branches;
next	1.319;
commitid	lpxpzSgqNAQAxtIZ;

1.319
date	2016.04.18.06.43.51;	author mpi;	state Exp;
branches;
next	1.318;
commitid	ebRPaHlX9XKssC0C;

1.318
date	2016.02.11.12.56.08;	author jca;	state Exp;
branches;
next	1.317;
commitid	oYbGNQ4RmqFf62UG;

1.317
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.316;
commitid	5qLGnZtXVLeqUvHc;

1.316
date	2016.01.13.09.38.36;	author mpi;	state Exp;
branches;
next	1.315;
commitid	VcTQSOywv2kbh0dq;

1.315
date	2015.12.05.10.52.26;	author tedu;	state Exp;
branches;
next	1.314;
commitid	e5lGxAXE14M3fHuG;

1.314
date	2015.12.03.21.29.58;	author sashan;	state Exp;
branches;
next	1.313;
commitid	lOxzE92pEs6Ekyz7;

1.313
date	2015.12.03.16.21.38;	author markus;	state Exp;
branches;
next	1.312;
commitid	HSWEEoS5OzHQZFlZ;

1.312
date	2015.12.03.14.55.18;	author vgross;	state Exp;
branches;
next	1.311;
commitid	DukW6jeSHPpp8ZFD;

1.311
date	2015.12.02.20.50.20;	author markus;	state Exp;
branches;
next	1.310;
commitid	v7tKx0iwFcp7q5CX;

1.310
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.309;
commitid	Hf3C2AvfIXmCAmHE;

1.309
date	2015.12.01.00.49.12;	author mmcc;	state Exp;
branches;
next	1.308;
commitid	J8Z27Kfs0mxuUh2j;

1.308
date	2015.11.26.10.36.20;	author mpi;	state Exp;
branches;
next	1.307;
commitid	ikLUIqyOcHilWVFq;

1.307
date	2015.11.19.13.40.46;	author mpi;	state Exp;
branches;
next	1.306;
commitid	UK2FFBUkfSe0lWjr;

1.306
date	2015.11.11.10.23.23;	author mpi;	state Exp;
branches;
next	1.305;
commitid	HAbRB9Scbg3IhXig;

1.305
date	2015.11.03.21.11.48;	author naddy;	state Exp;
branches;
next	1.304;
commitid	1HYJIt80GJiehNdy;

1.304
date	2015.10.24.12.33.16;	author mpi;	state Exp;
branches;
next	1.303;
commitid	FKjowUWiF07inZqL;

1.303
date	2015.10.20.20.22.42;	author benno;	state Exp;
branches;
next	1.302;
commitid	bUJ2rTPueuGa0qeo;

1.302
date	2015.10.19.12.10.05;	author mpi;	state Exp;
branches;
next	1.301;
commitid	PaTczkH5eq9sS4jy;

1.301
date	2015.10.13.10.16.17;	author mpi;	state Exp;
branches;
next	1.300;
commitid	x5pP5R0xzn8v0H1b;

1.300
date	2015.10.07.14.52.45;	author deraadt;	state Exp;
branches;
next	1.299;
commitid	X0mGDmkYoSUOCu1E;

1.299
date	2015.09.23.08.49.46;	author mpi;	state Exp;
branches;
next	1.298;
commitid	24xqlqpNt9NPeWH3;

1.298
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.297;
commitid	zZXiESHR0g5lNO0l;

1.297
date	2015.09.13.13.57.07;	author mpi;	state Exp;
branches;
next	1.296;
commitid	MPWO7hyiGcG1NP0J;

1.296
date	2015.09.12.20.26.07;	author mpi;	state Exp;
branches;
next	1.295;
commitid	UM7jfgLT8vWQUBm1;

1.295
date	2015.09.12.13.34.12;	author mpi;	state Exp;
branches;
next	1.294;
commitid	LU3jSOpFfLxcllFL;

1.294
date	2015.09.12.11.40.04;	author claudio;	state Exp;
branches;
next	1.293;
commitid	4UCfjyLoiYEkFCR1;

1.293
date	2015.09.11.19.17.47;	author claudio;	state Exp;
branches;
next	1.292;
commitid	974yEWqtM8F6HQ0z;

1.292
date	2015.09.11.18.48.50;	author claudio;	state Exp;
branches;
next	1.291;
commitid	usRxGrEuXggCt7qo;

1.291
date	2015.09.03.14.59.23;	author mpi;	state Exp;
branches;
next	1.290;
commitid	2xlxwCdXfTZ2Xdk2;

1.290
date	2015.09.03.09.59.59;	author mpi;	state Exp;
branches;
next	1.289;
commitid	59waGk54fAHjhss2;

1.289
date	2015.09.02.08.28.06;	author mpi;	state Exp;
branches;
next	1.288;
commitid	dLfuF0b8wZHTynjf;

1.288
date	2015.09.01.14.33.15;	author mpi;	state Exp;
branches;
next	1.287;
commitid	5R8mYbNSlPpr0mpl;

1.287
date	2015.08.31.07.17.12;	author mpi;	state Exp;
branches;
next	1.286;
commitid	cniCJ6rbTz2M0Mvg;

1.286
date	2015.07.16.21.14.21;	author mpi;	state Exp;
branches;
next	1.285;
commitid	VGPlklxThaST7mIm;

1.285
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.284;
commitid	ncpqEGjDtSFuLAgn;

1.284
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.283;
commitid	J4OPNuggl4DOKGzM;

1.283
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.282;
commitid	h7z8lokZ0dFyuWpg;

1.282
date	2015.06.07.01.25.27;	author krw;	state Exp;
branches;
next	1.281;
commitid	7yzARhkDkBsYwsVv;

1.281
date	2015.05.23.12.52.59;	author markus;	state Exp;
branches;
next	1.280;
commitid	XxDCtGxlGi1shqAt;

1.280
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.279;
commitid	hN5bFCE56DrAjl99;

1.279
date	2015.04.17.11.04.01;	author mikeb;	state Exp;
branches;
next	1.278;
commitid	6glXvFR7NxzCcdRd;

1.278
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.277;
commitid	2c41FFL8044mZVko;

1.277
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.276;
commitid	bQi1IVHgugweH5gs;

1.276
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.275;
commitid	cYQY7jiay4SydLhD;

1.275
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.274;
commitid	Vq8oSnWLkf7dyy0N;

1.274
date	2014.12.08.10.51.00;	author mpi;	state Exp;
branches;
next	1.273;
commitid	OytlsHKQQEAcUSnu;

1.273
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.272;
commitid	t9FBKDfc4VDxpEy2;

1.272
date	2014.11.20.15.55.04;	author tedu;	state Exp;
branches;
next	1.271;
commitid	dQlDAqnjJpCZ1ssk;

1.271
date	2014.11.05.14.03.02;	author mpi;	state Exp;
branches;
next	1.270;
commitid	Ii1JKOPj4OOyvsFQ;

1.270
date	2014.11.01.21.40.38;	author mpi;	state Exp;
branches;
next	1.269;
commitid	w0MRp28dmfD1ZzO8;

1.269
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.268;
commitid	6AYfDT0Lpez1LFQp;

1.268
date	2014.10.08.07.33.42;	author mpi;	state Exp;
branches;
next	1.267;
commitid	lvKyi67pbjQhAODi;

1.267
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.266;
commitid	HQcmytntiCJTHORs;

1.266
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.265;
commitid	DQakU8LLWV6Iwx84;

1.265
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.264;
commitid	B4dZSbxas1X1IpXI;

1.264
date	2014.07.11.15.25.44;	author henning;	state Exp;
branches;
next	1.263;
commitid	gH10WI2Br8wfQmIg;

1.263
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.262;

1.262
date	2014.04.20.09.38.19;	author henning;	state Exp;
branches;
next	1.261;

1.261
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.260;

1.260
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.259;

1.259
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.258;

1.258
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.257;

1.257
date	2014.01.23.23.51.29;	author henning;	state Exp;
branches;
next	1.256;

1.256
date	2014.01.23.01.10.42;	author naddy;	state Exp;
branches;
next	1.255;

1.255
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.254;

1.254
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.253;

1.253
date	2013.12.17.02.41.07;	author matthew;	state Exp;
branches;
next	1.252;

1.252
date	2013.12.04.16.27.56;	author mikeb;	state Exp;
branches;
next	1.251;

1.251
date	2013.11.27.08.37.08;	author mpi;	state Exp;
branches;
next	1.250;

1.250
date	2013.10.25.18.44.36;	author lteo;	state Exp;
branches;
next	1.249;

1.249
date	2013.10.20.13.44.23;	author henning;	state Exp;
branches;
next	1.248;

1.248
date	2013.10.19.10.38.54;	author henning;	state Exp;
branches;
next	1.247;

1.247
date	2013.10.18.09.04.03;	author mpi;	state Exp;
branches;
next	1.246;

1.246
date	2013.08.08.14.29.29;	author mpi;	state Exp;
branches;
next	1.245;

1.245
date	2013.08.08.07.28.08;	author mpi;	state Exp;
branches;
next	1.244;

1.244
date	2013.07.31.15.41.52;	author mikeb;	state Exp;
branches;
next	1.243;

1.243
date	2013.07.04.19.10.40;	author sf;	state Exp;
branches;
next	1.242;

1.242
date	2013.06.26.09.12.40;	author henning;	state Exp;
branches;
next	1.241;

1.241
date	2013.06.11.18.15.53;	author deraadt;	state Exp;
branches;
next	1.240;

1.240
date	2013.06.05.02.25.05;	author lteo;	state Exp;
branches;
next	1.239;

1.239
date	2013.04.24.12.34.15;	author mpi;	state Exp;
branches;
next	1.238;

1.238
date	2013.04.11.12.06.25;	author mpi;	state Exp;
branches;
next	1.237;

1.237
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.236;

1.236
date	2013.04.09.08.35.38;	author mpi;	state Exp;
branches;
next	1.235;

1.235
date	2012.11.06.12.32.42;	author henning;	state Exp;
branches;
next	1.234;

1.234
date	2012.11.05.21.49.15;	author claudio;	state Exp;
branches;
next	1.233;

1.233
date	2012.11.01.07.55.56;	author henning;	state Exp;
branches;
next	1.232;

1.232
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.231;

1.231
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.230;

1.230
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.229;

1.229
date	2012.04.13.09.38.32;	author deraadt;	state Exp;
branches;
next	1.228;

1.228
date	2012.04.07.16.09.09;	author claudio;	state Exp;
branches;
next	1.227;

1.227
date	2012.03.30.11.12.46;	author markus;	state Exp;
branches;
next	1.226;

1.226
date	2012.03.17.10.16.41;	author dlg;	state Exp;
branches;
next	1.225;

1.225
date	2011.12.29.12.10.52;	author haesbaert;	state Exp;
branches;
next	1.224;

1.224
date	2011.12.02.03.15.31;	author haesbaert;	state Exp;
branches;
next	1.223;

1.223
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches
	1.223.2.1;
next	1.222;

1.222
date	2011.06.15.09.11.01;	author mikeb;	state Exp;
branches;
next	1.221;

1.221
date	2011.05.28.12.51.40;	author weerd;	state Exp;
branches;
next	1.220;

1.220
date	2011.05.02.13.48.38;	author mikeb;	state Exp;
branches;
next	1.219;

1.219
date	2011.04.28.09.56.27;	author claudio;	state Exp;
branches;
next	1.218;

1.218
date	2011.04.05.20.33.12;	author henning;	state Exp;
branches;
next	1.217;

1.217
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.216;

1.216
date	2011.04.04.17.44.43;	author henning;	state Exp;
branches;
next	1.215;

1.215
date	2011.04.04.13.57.29;	author henning;	state Exp;
branches;
next	1.214;

1.214
date	2010.09.30.09.18.18;	author phessler;	state Exp;
branches;
next	1.213;

1.213
date	2010.09.23.04.45.15;	author yasuoka;	state Exp;
branches;
next	1.212;

1.212
date	2010.09.08.08.34.42;	author claudio;	state Exp;
branches;
next	1.211;

1.211
date	2010.08.13.06.46.08;	author dlg;	state Exp;
branches;
next	1.210;

1.210
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.209;

1.209
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.208;

1.208
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.207;

1.207
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.206;

1.206
date	2010.06.29.21.28.38;	author reyk;	state Exp;
branches;
next	1.205;

1.205
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.204;

1.204
date	2010.01.13.12.09.36;	author claudio;	state Exp;
branches;
next	1.203;

1.203
date	2010.01.12.01.30.09;	author beck;	state Exp;
branches;
next	1.202;

1.202
date	2009.12.23.07.40.31;	author guenther;	state Exp;
branches;
next	1.201;

1.201
date	2009.12.11.17.50.57;	author deraadt;	state Exp;
branches;
next	1.200;

1.200
date	2009.11.27.20.05.50;	author guenther;	state Exp;
branches;
next	1.199;

1.199
date	2009.11.20.09.02.21;	author guenther;	state Exp;
branches;
next	1.198;

1.198
date	2009.11.13.14.14.56;	author claudio;	state Exp;
branches;
next	1.197;

1.197
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.196;

1.196
date	2009.10.28.18.02.00;	author deraadt;	state Exp;
branches;
next	1.195;

1.195
date	2009.10.06.21.21.48;	author claudio;	state Exp;
branches;
next	1.194;

1.194
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches
	1.194.4.1;
next	1.193;

1.193
date	2009.01.30.20.46.33;	author claudio;	state Exp;
branches
	1.193.2.1;
next	1.192;

1.192
date	2009.01.29.12.33.15;	author naddy;	state Exp;
branches;
next	1.191;

1.191
date	2008.05.09.02.56.36;	author markus;	state Exp;
branches
	1.191.2.1;
next	1.190;

1.190
date	2007.10.29.16.19.23;	author chl;	state Exp;
branches;
next	1.189;

1.189
date	2007.09.18.18.56.02;	author markus;	state Exp;
branches;
next	1.188;

1.188
date	2007.07.20.19.00.35;	author claudio;	state Exp;
branches;
next	1.187;

1.187
date	2007.05.30.04.46.45;	author henning;	state Exp;
branches;
next	1.186;

1.186
date	2007.05.29.17.46.24;	author henning;	state Exp;
branches;
next	1.185;

1.185
date	2007.05.27.20.15.48;	author dlg;	state Exp;
branches;
next	1.184;

1.184
date	2006.12.05.09.17.12;	author markus;	state Exp;
branches;
next	1.183;

1.183
date	2006.12.01.12.33.28;	author henning;	state Exp;
branches;
next	1.182;

1.182
date	2006.10.11.09.34.51;	author henning;	state Exp;
branches;
next	1.181;

1.181
date	2006.10.11.09.29.20;	author henning;	state Exp;
branches;
next	1.180;

1.180
date	2006.06.18.11.47.45;	author pascoe;	state Exp;
branches;
next	1.179;

1.179
date	2006.06.06.15.19.15;	author deraadt;	state Exp;
branches;
next	1.178;

1.178
date	2006.05.29.20.42.27;	author claudio;	state Exp;
branches;
next	1.177;

1.177
date	2006.05.26.20.50.41;	author deraadt;	state Exp;
branches;
next	1.176;

1.176
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.175;

1.175
date	2006.03.05.02.29.46;	author brad;	state Exp;
branches;
next	1.174;

1.174
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.173;

1.173
date	2005.10.05.17.32.22;	author norby;	state Exp;
branches;
next	1.172;

1.172
date	2005.06.10.15.53.07;	author markus;	state Exp;
branches;
next	1.171;

1.171
date	2005.05.27.04.55.28;	author mcbride;	state Exp;
branches;
next	1.170;

1.170
date	2005.04.25.17.55.52;	author brad;	state Exp;
branches;
next	1.169;

1.169
date	2005.01.04.19.42.38;	author markus;	state Exp;
branches
	1.169.2.1;
next	1.168;

1.168
date	2004.11.10.03.27.27;	author mcbride;	state Exp;
branches;
next	1.167;

1.167
date	2004.06.22.07.35.20;	author cedric;	state Exp;
branches
	1.167.2.1;
next	1.166;

1.166
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.165;

1.165
date	2004.06.21.19.26.01;	author mcbride;	state Exp;
branches;
next	1.164;

1.164
date	2004.06.21.18.34.52;	author markus;	state Exp;
branches;
next	1.163;

1.163
date	2004.06.06.16.49.09;	author cedric;	state Exp;
branches;
next	1.162;

1.162
date	2004.05.18.10.31.09;	author dhartmei;	state Exp;
branches;
next	1.161;

1.161
date	2004.04.28.02.51.58;	author cedric;	state Exp;
branches;
next	1.160;

1.160
date	2004.02.10.20.20.01;	author itojun;	state Exp;
branches;
next	1.159;

1.159
date	2003.11.06.16.57.41;	author dhartmei;	state Exp;
branches;
next	1.158;

1.158
date	2003.11.03.07.58.36;	author cedric;	state Exp;
branches;
next	1.157;

1.157
date	2003.10.02.05.47.29;	author itojun;	state Exp;
branches;
next	1.156;

1.156
date	2003.08.15.20.32.20;	author tedu;	state Exp;
branches
	1.156.2.1;
next	1.155;

1.155
date	2003.08.14.19.00.12;	author jason;	state Exp;
branches;
next	1.154;

1.154
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.153;

1.153
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.152;

1.152
date	2003.03.14.18.28.12;	author jason;	state Exp;
branches
	1.152.2.1;
next	1.151;

1.151
date	2003.01.31.17.27.03;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2002.10.10.17.27.40;	author dhartmei;	state Exp;
branches;
next	1.149;

1.149
date	2002.06.24.23.57.28;	author itojun;	state Exp;
branches
	1.149.2.1;
next	1.148;

1.148
date	2002.06.04.21.48.14;	author jasoni;	state Exp;
branches;
next	1.147;

1.147
date	2002.05.31.20.58.25;	author itojun;	state Exp;
branches;
next	1.146;

1.146
date	2002.05.31.02.41.44;	author angelos;	state Exp;
branches;
next	1.145;

1.145
date	2002.05.28.17.01.43;	author jasoni;	state Exp;
branches;
next	1.144;

1.144
date	2002.05.28.15.44.28;	author jasoni;	state Exp;
branches;
next	1.143;

1.143
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.142;

1.142
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.141;

1.141
date	2002.01.23.21.34.53;	author provos;	state Exp;
branches;
next	1.140;

1.140
date	2001.11.26.16.50.26;	author jasoni;	state Exp;
branches
	1.140.2.1;
next	1.139;

1.139
date	2001.11.24.19.29.06;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	2001.11.02.21.42.19;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2001.08.26.21.12.06;	author niklas;	state Exp;
branches;
next	1.136;

1.136
date	2001.08.22.14.18.36;	author niklas;	state Exp;
branches;
next	1.135;

1.135
date	2001.08.21.06.53.36;	author angelos;	state Exp;
branches;
next	1.134;

1.134
date	2001.07.17.20.34.50;	author provos;	state Exp;
branches;
next	1.133;

1.133
date	2001.07.05.16.45.55;	author jjbg;	state Exp;
branches;
next	1.132;

1.132
date	2001.06.29.18.36.17;	author beck;	state Exp;
branches;
next	1.131;

1.131
date	2001.06.28.21.53.42;	author provos;	state Exp;
branches;
next	1.130;

1.130
date	2001.06.27.03.49.53;	author angelos;	state Exp;
branches;
next	1.129;

1.129
date	2001.06.27.02.52.40;	author angelos;	state Exp;
branches;
next	1.128;

1.128
date	2001.06.27.01.34.07;	author angelos;	state Exp;
branches;
next	1.127;

1.127
date	2001.06.26.18.17.54;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2001.06.25.17.16.23;	author angelos;	state Exp;
branches;
next	1.125;

1.125
date	2001.06.25.06.14.05;	author angelos;	state Exp;
branches;
next	1.124;

1.124
date	2001.06.25.06.09.42;	author angelos;	state Exp;
branches;
next	1.123;

1.123
date	2001.06.25.02.54.44;	author angelos;	state Exp;
branches;
next	1.122;

1.122
date	2001.06.25.02.03.18;	author angelos;	state Exp;
branches;
next	1.121;

1.121
date	2001.06.25.01.59.29;	author angelos;	state Exp;
branches;
next	1.120;

1.120
date	2001.06.25.01.21.15;	author provos;	state Exp;
branches;
next	1.119;

1.119
date	2001.06.24.23.42.40;	author mickey;	state Exp;
branches;
next	1.118;

1.118
date	2001.06.24.23.38.48;	author angelos;	state Exp;
branches;
next	1.117;

1.117
date	2001.06.24.23.33.56;	author angelos;	state Exp;
branches;
next	1.116;

1.116
date	2001.06.24.22.24.30;	author angelos;	state Exp;
branches;
next	1.115;

1.115
date	2001.06.24.22.21.50;	author angelos;	state Exp;
branches;
next	1.114;

1.114
date	2001.06.24.19.48.58;	author kjell;	state Exp;
branches;
next	1.113;

1.113
date	2001.06.24.18.24.11;	author provos;	state Exp;
branches;
next	1.112;

1.112
date	2001.06.23.16.15.56;	author fgsch;	state Exp;
branches;
next	1.111;

1.111
date	2001.06.23.07.13.03;	author angelos;	state Exp;
branches;
next	1.110;

1.110
date	2001.06.23.07.03.27;	author angelos;	state Exp;
branches;
next	1.109;

1.109
date	2001.06.23.06.42.37;	author angelos;	state Exp;
branches;
next	1.108;

1.108
date	2001.06.23.06.13.42;	author angelos;	state Exp;
branches;
next	1.107;

1.107
date	2001.06.23.05.55.40;	author angelos;	state Exp;
branches;
next	1.106;

1.106
date	2001.06.23.03.10.21;	author provos;	state Exp;
branches;
next	1.105;

1.105
date	2001.06.23.02.27.10;	author angelos;	state Exp;
branches;
next	1.104;

1.104
date	2001.06.19.18.49.53;	author jasoni;	state Exp;
branches;
next	1.103;

1.103
date	2001.06.14.18.00.02;	author provos;	state Exp;
branches;
next	1.102;

1.102
date	2001.06.12.10.59.53;	author angelos;	state Exp;
branches;
next	1.101;

1.101
date	2001.06.08.03.53.46;	author angelos;	state Exp;
branches;
next	1.100;

1.100
date	2001.06.05.11.05.08;	author angelos;	state Exp;
branches;
next	1.99;

1.99
date	2001.05.30.12.20.42;	author angelos;	state Exp;
branches;
next	1.98;

1.98
date	2001.05.30.02.12.34;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2001.05.29.01.09.14;	author angelos;	state Exp;
branches;
next	1.96;

1.96
date	2001.05.28.05.30.54;	author angelos;	state Exp;
branches;
next	1.95;

1.95
date	2001.05.27.11.50.37;	author angelos;	state Exp;
branches;
next	1.94;

1.94
date	2001.05.27.11.48.35;	author angelos;	state Exp;
branches;
next	1.93;

1.93
date	2001.05.27.05.27.49;	author angelos;	state Exp;
branches;
next	1.92;

1.92
date	2001.05.27.00.39.26;	author angelos;	state Exp;
branches;
next	1.91;

1.91
date	2001.05.20.08.34.29;	author angelos;	state Exp;
branches;
next	1.90;

1.90
date	2001.05.16.12.53.36;	author ho;	state Exp;
branches;
next	1.89;

1.89
date	2001.04.14.00.30.59;	author angelos;	state Exp;
branches;
next	1.88;

1.88
date	2001.04.06.04.42.08;	author csapuntz;	state Exp;
branches;
next	1.87;

1.87
date	2001.03.28.20.03.04;	author angelos;	state Exp;
branches;
next	1.86;

1.86
date	2001.03.07.23.19.54;	author aaron;	state Exp;
branches;
next	1.85;

1.85
date	2000.12.03.19.56.20;	author angelos;	state Exp;
branches;
next	1.84;

1.84
date	2000.11.07.18.24.26;	author provos;	state Exp;
branches;
next	1.83;

1.83
date	2000.10.25.22.40.40;	author aaron;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2000.09.29.03.51.11;	author angelos;	state Exp;
branches;
next	1.81;

1.81
date	2000.09.19.03.20.59;	author angelos;	state Exp;
branches;
next	1.80;

1.80
date	2000.09.18.22.06.37;	author provos;	state Exp;
branches;
next	1.79;

1.79
date	2000.07.29.22.51.22;	author angelos;	state Exp;
branches;
next	1.78;

1.78
date	2000.06.21.17.25.04;	author form;	state Exp;
branches;
next	1.77;

1.77
date	2000.06.20.01.45.56;	author angelos;	state Exp;
branches;
next	1.76;

1.76
date	2000.06.18.21.54.40;	author angelos;	state Exp;
branches;
next	1.75;

1.75
date	2000.06.18.07.30.45;	author itojun;	state Exp;
branches;
next	1.74;

1.74
date	2000.06.18.07.13.50;	author itojun;	state Exp;
branches;
next	1.73;

1.73
date	2000.06.18.07.06.17;	author itojun;	state Exp;
branches;
next	1.72;

1.72
date	2000.06.17.23.50.45;	author angelos;	state Exp;
branches;
next	1.71;

1.71
date	2000.06.01.04.47.55;	author angelos;	state Exp;
branches;
next	1.70;

1.70
date	2000.06.01.04.38.34;	author angelos;	state Exp;
branches;
next	1.69;

1.69
date	2000.05.15.11.07.33;	author itojun;	state Exp;
branches;
next	1.68;

1.68
date	2000.05.04.20.15.38;	author niklas;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2000.04.13.19.22.57;	author art;	state Exp;
branches;
next	1.66;

1.66
date	2000.03.30.04.53.36;	author angelos;	state Exp;
branches;
next	1.65;

1.65
date	2000.03.17.10.25.22;	author angelos;	state Exp;
branches;
next	1.64;

1.64
date	2000.01.11.03.10.04;	author angelos;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2000.01.11.01.03.23;	author angelos;	state Exp;
branches;
next	1.62;

1.62
date	2000.01.10.04.29.29;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	2000.01.09.22.53.16;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	99.12.25.04.48.16;	author angelos;	state Exp;
branches;
next	1.59;

1.59
date	99.12.21.08.23.06;	author angelos;	state Exp;
branches;
next	1.58;

1.58
date	99.12.18.19.57.07;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	99.12.10.08.55.23;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	99.12.08.12.10.25;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	99.12.06.07.14.36;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	99.12.04.23.20.21;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	99.11.04.11.21.14;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	99.10.29.02.10.02;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	99.10.29.02.04.02;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	99.07.15.14.15.41;	author niklas;	state Exp;
branches;
next	1.48;

1.48
date	99.06.15.02.24.02;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	99.05.16.21.48.36;	author niklas;	state Exp;
branches;
next	1.46;

1.46
date	99.05.14.23.36.20;	author niklas;	state Exp;
branches;
next	1.45;

1.45
date	99.04.11.19.41.39;	author niklas;	state Exp;
branches;
next	1.44;

1.44
date	99.03.27.21.04.20;	author provos;	state Exp;
branches;
next	1.43;

1.43
date	99.03.24.17.00.47;	author niklas;	state Exp;
branches;
next	1.42;

1.42
date	99.03.06.20.59.41;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	99.02.24.23.45.52;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	99.02.24.22.33.07;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	99.01.11.00.42.53;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	99.01.08.21.51.22;	author provos;	state Exp;
branches;
next	1.37;

1.37
date	98.12.26.12.35.11;	author provos;	state Exp;
branches;
next	1.36;

1.36
date	98.08.02.22.20.30;	author provos;	state Exp;
branches;
next	1.35;

1.35
date	98.08.01.08.35.11;	author provos;	state Exp;
branches;
next	1.34;

1.34
date	98.07.29.22.18.48;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	98.07.29.21.13.07;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	98.06.30.23.50.17;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	98.06.03.10.00.19;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	98.05.24.23.03.47;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	98.05.24.14.14.00;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	98.05.19.18.42.01;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.05.18.21.11.02;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	98.03.18.10.16.31;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	98.02.03.19.06.30;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.10.02.02.31.07;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.09.28.22.57.50;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.08.26.20.07.38;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.08.04.01.12.06;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	97.07.31.00.40.21;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.07.27.23.30.37;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.07.18.18.09.57;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	97.07.14.08.45.55;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	97.07.11.23.37.59;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	97.07.01.22.12.53;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.06.25.07.53.29;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.06.24.12.15.27;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	97.06.16.06.32.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.03.02.07.59.40;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	97.03.02.07.32.15;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.02.28.04.03.48;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	97.02.28.03.44.54;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	97.02.20.01.08.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.29.02.34.31;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.03.04.10.34.33;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.03.22.30.41;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.25.05.41.46;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.07.02.34.04;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches;
next	;

1.64.2.1
date	2000.03.24.09.09.37;	author niklas;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2001.05.14.22.40.12;	author niklas;	state Exp;
branches;
next	1.64.2.3;

1.64.2.3
date	2001.07.04.10.54.56;	author niklas;	state Exp;
branches;
next	1.64.2.4;

1.64.2.4
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.64.2.5;

1.64.2.5
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.64.2.6;

1.64.2.6
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.64.2.7;

1.64.2.7
date	2002.03.06.02.15.07;	author niklas;	state Exp;
branches;
next	1.64.2.8;

1.64.2.8
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.64.2.9;

1.64.2.9
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.64.2.10;

1.64.2.10
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.64.2.11;

1.64.2.11
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.64.2.12;

1.64.2.12
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	1.64.2.13;

1.64.2.13
date	2004.06.07.20.41.39;	author niklas;	state Exp;
branches;
next	;

1.68.2.1
date	2000.05.29.18.24.03;	author jason;	state Exp;
branches;
next	;

1.83.2.1
date	2000.11.11.05.15.34;	author jason;	state Exp;
branches;
next	1.83.2.2;

1.83.2.2
date	2000.12.11.04.34.07;	author jason;	state Exp;
branches;
next	;

1.140.2.1
date	2002.01.31.22.55.45;	author niklas;	state Exp;
branches;
next	1.140.2.2;

1.140.2.2
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.140.2.3;

1.140.2.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.140.2.4;

1.140.2.4
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;

1.149.2.1
date	2002.11.04.14.33.50;	author jason;	state Exp;
branches;
next	;

1.152.2.1
date	2004.03.03.02.26.52;	author brad;	state Exp;
branches;
next	;

1.156.2.1
date	2004.03.03.02.16.52;	author brad;	state Exp;
branches;
next	;

1.167.2.1
date	2005.06.14.01.47.20;	author brad;	state Exp;
branches;
next	;

1.169.2.1
date	2005.06.14.02.10.03;	author brad;	state Exp;
branches;
next	;

1.191.2.1
date	2009.10.28.20.21.05;	author claudio;	state Exp;
branches;
next	;

1.193.2.1
date	2009.10.28.20.20.14;	author claudio;	state Exp;
branches;
next	;

1.194.4.1
date	2009.10.28.20.19.19;	author claudio;	state Exp;
branches;
next	;

1.223.2.1
date	2012.01.06.00.15.15;	author haesbaert;	state Exp;
branches;
next	;


desc
@@


1.342
log
@Use m_copym() instead of m_dup_pkt() to fix a kernel assert when
setting IP options.

Issue reported by Kapetanakis Giannis
OK mpi@@
@
text
@/*	$OpenBSD: ip_output.c,v 1.341 2017/09/01 15:05:31 mpi Exp $	*/
/*	$NetBSD: ip_output.c,v 1.28 1996/02/13 23:43:07 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip_output.c	8.3 (Berkeley) 1/21/94
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/proc.h>
#include <sys/kernel.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_enc.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/in_var.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/udp_var.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#ifdef IPSEC
#ifdef ENCDEBUG
#define DPRINTF(x)    do { if (encdebug) printf x ; } while (0)
#else
#define DPRINTF(x)
#endif
#endif /* IPSEC */

int ip_pcbopts(struct mbuf **, struct mbuf *);
int ip_setmoptions(int, struct ip_moptions **, struct mbuf *, u_int);
void ip_mloopback(struct ifnet *, struct mbuf *, struct sockaddr_in *);
static __inline u_int16_t __attribute__((__unused__))
    in_cksum_phdr(u_int32_t, u_int32_t, u_int32_t);
void in_delayed_cksum(struct mbuf *);

#ifdef IPSEC
struct tdb *
ip_output_ipsec_lookup(struct mbuf *m, int hlen, int *error, struct inpcb *inp,
    int ipsecflowinfo);
int
ip_output_ipsec_send(struct tdb *tdb, struct mbuf *m, struct ifnet *ifp,
    struct route *ro);
#endif /* IPSEC */

/*
 * IP output.  The packet in mbuf chain m contains a skeletal IP
 * header (with len, off, ttl, proto, tos, src, dst).
 * The mbuf chain containing the packet will be freed.
 * The mbuf opt, if present, will not be freed.
 */
int
ip_output(struct mbuf *m0, struct mbuf *opt, struct route *ro, int flags,
    struct ip_moptions *imo, struct inpcb *inp, u_int32_t ipsecflowinfo)
{
	struct ip *ip;
	struct ifnet *ifp = NULL;
	struct mbuf *m = m0;
	int hlen = sizeof (struct ip);
	int len, error = 0;
	struct route iproute;
	struct sockaddr_in *dst;
	struct tdb *tdb = NULL;
	u_long mtu;
#if defined(MROUTING)
	int rv;
#endif

	NET_ASSERT_LOCKED();

#ifdef IPSEC
	if (inp && (inp->inp_flags & INP_IPV6) != 0)
		panic("ip_output: IPv6 pcb is passed");
#endif /* IPSEC */

#ifdef	DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("ip_output no HDR");
#endif
	if (opt) {
		m = ip_insertoptions(m, opt, &len);
		hlen = len;
	}

	ip = mtod(m, struct ip *);

	/*
	 * Fill in IP header.
	 */
	if ((flags & (IP_FORWARDING|IP_RAWOUTPUT)) == 0) {
		ip->ip_v = IPVERSION;
		ip->ip_off &= htons(IP_DF);
		ip->ip_id = htons(ip_randomid());
		ip->ip_hl = hlen >> 2;
		ipstat_inc(ips_localout);
	} else {
		hlen = ip->ip_hl << 2;
	}

	/*
	 * We should not send traffic to 0/8 say both Stevens and RFCs
	 * 5735 section 3 and 1122 sections 3.2.1.3 and 3.3.6.
	 */
	if ((ntohl(ip->ip_dst.s_addr) >> IN_CLASSA_NSHIFT) == 0) {
		error = ENETUNREACH;
		goto bad;
	}

#if NPF > 0
reroute:
#endif

	/*
	 * Do a route lookup now in case we need the source address to
	 * do an SPD lookup in IPsec; for most packets, the source address
	 * is set at a higher level protocol. ICMPs and other packets
	 * though (e.g., traceroute) have a source address of zeroes.
	 */
	if (ro == NULL) {
		ro = &iproute;
		memset(ro, 0, sizeof(*ro));
	}

	dst = satosin(&ro->ro_dst);

	/*
	 * If there is a cached route, check that it is to the same
	 * destination and is still up.  If not, free it and try again.
	 */
	if (!rtisvalid(ro->ro_rt) ||
	    dst->sin_addr.s_addr != ip->ip_dst.s_addr ||
	    ro->ro_tableid != m->m_pkthdr.ph_rtableid) {
		rtfree(ro->ro_rt);
		ro->ro_rt = NULL;
	}

	if (ro->ro_rt == NULL) {
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = ip->ip_dst;
		ro->ro_tableid = m->m_pkthdr.ph_rtableid;
	}

	if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
	    (ip->ip_dst.s_addr == INADDR_BROADCAST)) &&
	    imo != NULL && (ifp = if_get(imo->imo_ifidx)) != NULL) {

		mtu = ifp->if_mtu;
		if (ip->ip_src.s_addr == INADDR_ANY) {
			struct in_ifaddr *ia;

			IFP_TO_IA(ifp, ia);
			if (ia != NULL)
				ip->ip_src = ia->ia_addr.sin_addr;
		}
	} else {
		struct in_ifaddr *ia;

		if (ro->ro_rt == NULL)
			ro->ro_rt = rtalloc_mpath(&ro->ro_dst,
			    &ip->ip_src.s_addr, ro->ro_tableid);

		if (ro->ro_rt == NULL) {
			ipstat_inc(ips_noroute);
			error = EHOSTUNREACH;
			goto bad;
		}

		ia = ifatoia(ro->ro_rt->rt_ifa);
		if (ISSET(ro->ro_rt->rt_flags, RTF_LOCAL))
			ifp = if_get(rtable_loindex(m->m_pkthdr.ph_rtableid));
		else
			ifp = if_get(ro->ro_rt->rt_ifidx);
		if (ifp == NULL) {
			error = EHOSTUNREACH;
			goto bad;
		}
		if ((mtu = ro->ro_rt->rt_mtu) == 0)
			mtu = ifp->if_mtu;

		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			dst = satosin(ro->ro_rt->rt_gateway);

		/* Set the source IP address */
		if (ip->ip_src.s_addr == INADDR_ANY && ia)
			ip->ip_src = ia->ia_addr.sin_addr;
	}

#ifdef IPSEC
	if (ipsec_in_use || inp != NULL) {
		KERNEL_ASSERT_LOCKED();
		/* Do we have any pending SAs to apply ? */
		tdb = ip_output_ipsec_lookup(m, hlen, &error, inp,
		    ipsecflowinfo);
		if (error != 0) {
			/* Should silently drop packet */
			if (error == -EINVAL)
				error = 0;
			m_freem(m);
			goto done;
		}
		if (tdb != NULL) {
			/*
			 * If it needs TCP/UDP hardware-checksumming, do the
			 * computation now.
			 */
			in_proto_cksum_out(m, NULL);
		}
	}
#endif /* IPSEC */

	if (IN_MULTICAST(ip->ip_dst.s_addr) ||
	    (ip->ip_dst.s_addr == INADDR_BROADCAST)) {

		m->m_flags |= (ip->ip_dst.s_addr == INADDR_BROADCAST) ?
			M_BCAST : M_MCAST;

		/*
		 * IP destination address is multicast.  Make sure "dst"
		 * still points to the address in "ro".  (It may have been
		 * changed to point to a gateway address, above.)
		 */
		dst = satosin(&ro->ro_dst);

		/*
		 * See if the caller provided any multicast options
		 */
		if (imo != NULL)
			ip->ip_ttl = imo->imo_ttl;
		else
			ip->ip_ttl = IP_DEFAULT_MULTICAST_TTL;

		/*
		 * if we don't know the outgoing ifp yet, we can't generate
		 * output
		 */
		if (!ifp) {
			ipstat_inc(ips_noroute);
			error = EHOSTUNREACH;
			goto bad;
		}

		/*
		 * Confirm that the outgoing interface supports multicast,
		 * but only if the packet actually is going out on that
		 * interface (i.e., no IPsec is applied).
		 */
		if ((((m->m_flags & M_MCAST) &&
		      (ifp->if_flags & IFF_MULTICAST) == 0) ||
		     ((m->m_flags & M_BCAST) &&
		      (ifp->if_flags & IFF_BROADCAST) == 0)) && (tdb == NULL)) {
			ipstat_inc(ips_noroute);
			error = ENETUNREACH;
			goto bad;
		}

		/*
		 * If source address not specified yet, use address
		 * of outgoing interface.
		 */
		if (ip->ip_src.s_addr == INADDR_ANY) {
			struct in_ifaddr *ia;

			IFP_TO_IA(ifp, ia);
			if (ia != NULL)
				ip->ip_src = ia->ia_addr.sin_addr;
		}

		if ((imo == NULL || imo->imo_loop) &&
		    in_hasmulti(&ip->ip_dst, ifp)) {
			/*
			 * If we belong to the destination multicast group
			 * on the outgoing interface, and the caller did not
			 * forbid loopback, loop back a copy.
			 * Can't defer TCP/UDP checksumming, do the
			 * computation now.
			 */
			in_proto_cksum_out(m, NULL);
			ip_mloopback(ifp, m, dst);
		}
#ifdef MROUTING
		else {
			/*
			 * If we are acting as a multicast router, perform
			 * multicast forwarding as if the packet had just
			 * arrived on the interface to which we are about
			 * to send.  The multicast forwarding function
			 * recursively calls this function, using the
			 * IP_FORWARDING flag to prevent infinite recursion.
			 *
			 * Multicasts that are looped back by ip_mloopback(),
			 * above, will be forwarded by the ip_input() routine,
			 * if necessary.
			 */
			if (ipmforwarding && ip_mrouter[ifp->if_rdomain] &&
			    (flags & IP_FORWARDING) == 0) {
				KERNEL_LOCK();
				rv = ip_mforward(m, ifp);
				KERNEL_UNLOCK();
				if (rv != 0) {
					m_freem(m);
					goto done;
				}
			}
		}
#endif
		/*
		 * Multicasts with a time-to-live of zero may be looped-
		 * back, above, but must not be transmitted on a network.
		 * Also, multicasts addressed to the loopback interface
		 * are not sent -- the above call to ip_mloopback() will
		 * loop back a copy if this host actually belongs to the
		 * destination group on the loopback interface.
		 */
		if (ip->ip_ttl == 0 || (ifp->if_flags & IFF_LOOPBACK) != 0) {
			m_freem(m);
			goto done;
		}

		goto sendit;
	}

	/*
	 * Look for broadcast address and verify user is allowed to send
	 * such a packet; if the packet is going in an IPsec tunnel, skip
	 * this check.
	 */
	if ((tdb == NULL) && ((dst->sin_addr.s_addr == INADDR_BROADCAST) ||
	    (ro && ro->ro_rt && ISSET(ro->ro_rt->rt_flags, RTF_BROADCAST)))) {
		if ((ifp->if_flags & IFF_BROADCAST) == 0) {
			error = EADDRNOTAVAIL;
			goto bad;
		}
		if ((flags & IP_ALLOWBROADCAST) == 0) {
			error = EACCES;
			goto bad;
		}

		/* Don't allow broadcast messages to be fragmented */
		if (ntohs(ip->ip_len) > ifp->if_mtu) {
			error = EMSGSIZE;
			goto bad;
		}
		m->m_flags |= M_BCAST;
	} else
		m->m_flags &= ~M_BCAST;

sendit:
	/*
	 * If we're doing Path MTU discovery, we need to set DF unless
	 * the route's MTU is locked.
	 */
	if ((flags & IP_MTUDISC) && ro && ro->ro_rt &&
	    (ro->ro_rt->rt_locks & RTV_MTU) == 0)
		ip->ip_off |= htons(IP_DF);

#ifdef IPSEC
	/*
	 * Check if the packet needs encapsulation.
	 */
	if (tdb != NULL) {
		KERNEL_ASSERT_LOCKED();
		/* Callee frees mbuf */
		error = ip_output_ipsec_send(tdb, m, ifp, ro);
		goto done;
	}
#endif /* IPSEC */

	/*
	 * Packet filter
	 */
#if NPF > 0
	if (pf_test(AF_INET, PF_OUT, ifp, &m) != PF_PASS) {
		error = EACCES;
		m_freem(m);
		goto done;
	}
	if (m == NULL)
		goto done;
	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;
	if ((m->m_pkthdr.pf.flags & (PF_TAG_REROUTE | PF_TAG_GENERATED)) ==
	    (PF_TAG_REROUTE | PF_TAG_GENERATED))
		/* already rerun the route lookup, go on */
		m->m_pkthdr.pf.flags &= ~(PF_TAG_GENERATED | PF_TAG_REROUTE);
	else if (m->m_pkthdr.pf.flags & PF_TAG_REROUTE) {
		/* tag as generated to skip over pf_test on rerun */
		m->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
		ro = NULL;
		if_put(ifp); /* drop reference since target changed */
		ifp = NULL;
		goto reroute;
	}
#endif
	in_proto_cksum_out(m, ifp);

#ifdef IPSEC
	if (ipsec_in_use && (flags & IP_FORWARDING) && (ipforwarding == 2) &&
	    (m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL) == NULL)) {
		error = EHOSTUNREACH;
		m_freem(m);
		goto done;
	}
#endif

	/*
	 * If small enough for interface, can just send directly.
	 */
	if (ntohs(ip->ip_len) <= mtu) {
		ip->ip_sum = 0;
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    (ifp->if_bridgeport == NULL))
			m->m_pkthdr.csum_flags |= M_IPV4_CSUM_OUT;
		else {
			ipstat_inc(ips_outswcsum);
			ip->ip_sum = in_cksum(m, hlen);
		}

		error = ifp->if_output(ifp, m, sintosa(dst), ro->ro_rt);
		goto done;
	}

	/*
	 * Too large for interface; fragment if possible.
	 * Must be able to put at least 8 bytes per fragment.
	 */
	if (ip->ip_off & htons(IP_DF)) {
#ifdef IPSEC
		if (ip_mtudisc)
			ipsec_adjust_mtu(m, ifp->if_mtu);
#endif
		error = EMSGSIZE;
		/*
		 * This case can happen if the user changed the MTU
		 * of an interface after enabling IP on it.  Because
		 * most netifs don't keep track of routes pointing to
		 * them, there is no way for one to update all its
		 * routes when the MTU is changed.
		 */
		if (rtisvalid(ro->ro_rt) &&
		    ISSET(ro->ro_rt->rt_flags, RTF_HOST) &&
		    !(ro->ro_rt->rt_locks & RTV_MTU) &&
		    (ro->ro_rt->rt_mtu > ifp->if_mtu)) {
			ro->ro_rt->rt_mtu = ifp->if_mtu;
		}
		ipstat_inc(ips_cantfrag);
		goto bad;
	}

	error = ip_fragment(m, ifp, mtu);
	if (error) {
		m = m0 = NULL;
		goto bad;
	}

	for (; m; m = m0) {
		m0 = m->m_nextpkt;
		m->m_nextpkt = 0;
		if (error == 0)
			error = ifp->if_output(ifp, m, sintosa(dst), ro->ro_rt);
		else
			m_freem(m);
	}

	if (error == 0)
		ipstat_inc(ips_fragmented);

done:
	if (ro == &iproute && ro->ro_rt)
		rtfree(ro->ro_rt);
	if_put(ifp);
	return (error);
bad:
	m_freem(m0);
	goto done;
}

#ifdef IPSEC
struct tdb *
ip_output_ipsec_lookup(struct mbuf *m, int hlen, int *error, struct inpcb *inp,
    int ipsecflowinfo)
{
	struct m_tag *mtag;
	struct tdb_ident *tdbi;
	struct tdb *tdb;

	/* Do we have any pending SAs to apply ? */
	tdb = ipsp_spd_lookup(m, AF_INET, hlen, error, IPSP_DIRECTION_OUT,
	    NULL, inp, ipsecflowinfo);
	if (tdb == NULL)
		return NULL;
	/* Loop detection */
	for (mtag = m_tag_first(m); mtag != NULL; mtag = m_tag_next(m, mtag)) {
		if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE)
			continue;
		tdbi = (struct tdb_ident *)(mtag + 1);
		if (tdbi->spi == tdb->tdb_spi &&
		    tdbi->proto == tdb->tdb_sproto &&
		    tdbi->rdomain == tdb->tdb_rdomain &&
		    !memcmp(&tdbi->dst, &tdb->tdb_dst,
		    sizeof(union sockaddr_union))) {
			/* no IPsec needed */
			return NULL;
		}
	}
	return tdb;
}

int
ip_output_ipsec_send(struct tdb *tdb, struct mbuf *m, struct ifnet *ifp,
    struct route *ro)
{
#if NPF > 0
	struct ifnet *encif;
#endif
	struct ip *ip;

#if NPF > 0
	/*
	 * Packet filter
	 */
	if ((encif = enc_getif(tdb->tdb_rdomain, tdb->tdb_tap)) == NULL ||
	    pf_test(AF_INET, PF_OUT, encif, &m) != PF_PASS) {
		m_freem(m);
		return EACCES;
	}
	if (m == NULL)
		return 0;
	/*
	 * PF_TAG_REROUTE handling or not...
	 * Packet is entering IPsec so the routing is
	 * already overruled by the IPsec policy.
	 * Until now the change was not reconsidered.
	 * What's the behaviour?
	 */
	in_proto_cksum_out(m, encif);
#endif

	/* Check if we are allowed to fragment */
	ip = mtod(m, struct ip *);
	if (ip_mtudisc && (ip->ip_off & htons(IP_DF)) && tdb->tdb_mtu &&
	    ntohs(ip->ip_len) > tdb->tdb_mtu &&
	    tdb->tdb_mtutimeout > time_second) {
		struct rtentry *rt = NULL;
		int rt_mtucloned = 0;
		int transportmode = 0;

		transportmode = (tdb->tdb_dst.sa.sa_family == AF_INET) &&
		    (tdb->tdb_dst.sin.sin_addr.s_addr == ip->ip_dst.s_addr);

		/* Find a host route to store the mtu in */
		if (ro != NULL)
			rt = ro->ro_rt;
		/* but don't add a PMTU route for transport mode SAs */
		if (transportmode)
			rt = NULL;
		else if (rt == NULL || (rt->rt_flags & RTF_HOST) == 0) {
			rt = icmp_mtudisc_clone(ip->ip_dst,
			    m->m_pkthdr.ph_rtableid);
			rt_mtucloned = 1;
		}
		DPRINTF(("%s: spi %08x mtu %d rt %p cloned %d\n", __func__,
		    ntohl(tdb->tdb_spi), tdb->tdb_mtu, rt, rt_mtucloned));
		if (rt != NULL) {
			rt->rt_mtu = tdb->tdb_mtu;
			if (ro && ro->ro_rt != NULL) {
				rtfree(ro->ro_rt);
				ro->ro_rt = rtalloc(&ro->ro_dst, RT_RESOLVE,
				    m->m_pkthdr.ph_rtableid);
			}
			if (rt_mtucloned)
				rtfree(rt);
		}
		ipsec_adjust_mtu(m, tdb->tdb_mtu);
		m_freem(m);
		return EMSGSIZE;
	}

	/*
	 * Clear these -- they'll be set in the recursive invocation
	 * as needed.
	 */
	m->m_flags &= ~(M_MCAST | M_BCAST);

	/* Callee frees mbuf */
	return ipsp_process_packet(m, tdb, AF_INET, 0);
}
#endif /* IPSEC */

int
ip_fragment(struct mbuf *m, struct ifnet *ifp, u_long mtu)
{
	struct ip *ip, *mhip;
	struct mbuf *m0;
	int len, hlen, off;
	int mhlen, firstlen;
	struct mbuf **mnext;
	int fragments = 0;
	int error = 0;

	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;

	len = (mtu - hlen) &~ 7;
	if (len < 8) {
		m_freem(m);
		return (EMSGSIZE);
	}

	/*
	 * If we are doing fragmentation, we can't defer TCP/UDP
	 * checksumming; compute the checksum and clear the flag.
	 */
	in_proto_cksum_out(m, NULL);
	firstlen = len;
	mnext = &m->m_nextpkt;

	/*
	 * Loop through length of segment after first fragment,
	 * make new header and copy data of each part and link onto chain.
	 */
	m0 = m;
	mhlen = sizeof (struct ip);
	for (off = hlen + len; off < ntohs(ip->ip_len); off += len) {
		MGETHDR(m, M_DONTWAIT, MT_HEADER);
		if (m == NULL) {
			ipstat_inc(ips_odropped);
			error = ENOBUFS;
			goto sendorfree;
		}
		*mnext = m;
		mnext = &m->m_nextpkt;
		m->m_data += max_linkhdr;
		mhip = mtod(m, struct ip *);
		*mhip = *ip;
		/* we must inherit MCAST/BCAST flags, routing table and prio */
		m->m_flags |= m0->m_flags & (M_MCAST|M_BCAST);
		m->m_pkthdr.ph_rtableid = m0->m_pkthdr.ph_rtableid;
		m->m_pkthdr.pf.prio = m0->m_pkthdr.pf.prio;
		if (hlen > sizeof (struct ip)) {
			mhlen = ip_optcopy(ip, mhip) + sizeof (struct ip);
			mhip->ip_hl = mhlen >> 2;
		}
		m->m_len = mhlen;
		mhip->ip_off = ((off - hlen) >> 3) +
		    (ntohs(ip->ip_off) & ~IP_MF);
		if (ip->ip_off & htons(IP_MF))
			mhip->ip_off |= IP_MF;
		if (off + len >= ntohs(ip->ip_len))
			len = ntohs(ip->ip_len) - off;
		else
			mhip->ip_off |= IP_MF;
		mhip->ip_len = htons((u_int16_t)(len + mhlen));
		m->m_next = m_copym(m0, off, len, M_NOWAIT);
		if (m->m_next == 0) {
			ipstat_inc(ips_odropped);
			error = ENOBUFS;
			goto sendorfree;
		}
		m->m_pkthdr.len = mhlen + len;
		m->m_pkthdr.ph_ifidx = 0;
		mhip->ip_off = htons((u_int16_t)mhip->ip_off);
		mhip->ip_sum = 0;
		if ((ifp != NULL) &&
		    (ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    (ifp->if_bridgeport == NULL))
			m->m_pkthdr.csum_flags |= M_IPV4_CSUM_OUT;
		else {
			ipstat_inc(ips_outswcsum);
			mhip->ip_sum = in_cksum(m, mhlen);
		}
		ipstat_inc(ips_ofragments);
		fragments++;
	}
	/*
	 * Update first fragment by trimming what's been copied out
	 * and updating header, then send each fragment (in order).
	 */
	m = m0;
	m_adj(m, hlen + firstlen - ntohs(ip->ip_len));
	m->m_pkthdr.len = hlen + firstlen;
	ip->ip_len = htons((u_int16_t)m->m_pkthdr.len);
	ip->ip_off |= htons(IP_MF);
	ip->ip_sum = 0;
	if ((ifp != NULL) &&
	    (ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
	    (ifp->if_bridgeport == NULL))
		m->m_pkthdr.csum_flags |= M_IPV4_CSUM_OUT;
	else {
		ipstat_inc(ips_outswcsum);
		ip->ip_sum = in_cksum(m, hlen);
	}
sendorfree:
	if (error) {
		for (m = m0; m; m = m0) {
			m0 = m->m_nextpkt;
			m->m_nextpkt = NULL;
			m_freem(m);
		}
	}

	return (error);
}

/*
 * Insert IP options into preformed packet.
 * Adjust IP destination as required for IP source routing,
 * as indicated by a non-zero in_addr at the start of the options.
 */
struct mbuf *
ip_insertoptions(struct mbuf *m, struct mbuf *opt, int *phlen)
{
	struct ipoption *p = mtod(opt, struct ipoption *);
	struct mbuf *n;
	struct ip *ip = mtod(m, struct ip *);
	unsigned int optlen;

	optlen = opt->m_len - sizeof(p->ipopt_dst);
	if (optlen + ntohs(ip->ip_len) > IP_MAXPACKET)
		return (m);		/* XXX should fail */
	if (p->ipopt_dst.s_addr)
		ip->ip_dst = p->ipopt_dst;
	if (m->m_flags & M_EXT || m->m_data - optlen < m->m_pktdat) {
		MGETHDR(n, M_DONTWAIT, MT_HEADER);
		if (n == NULL)
			return (m);
		M_MOVE_HDR(n, m);
		n->m_pkthdr.len += optlen;
		m->m_len -= sizeof(struct ip);
		m->m_data += sizeof(struct ip);
		n->m_next = m;
		m = n;
		m->m_len = optlen + sizeof(struct ip);
		m->m_data += max_linkhdr;
		memcpy(mtod(m, caddr_t), ip, sizeof(struct ip));
	} else {
		m->m_data -= optlen;
		m->m_len += optlen;
		m->m_pkthdr.len += optlen;
		memmove(mtod(m, caddr_t), (caddr_t)ip, sizeof(struct ip));
	}
	ip = mtod(m, struct ip *);
	memcpy(ip + 1, p->ipopt_list, optlen);
	*phlen = sizeof(struct ip) + optlen;
	ip->ip_len = htons(ntohs(ip->ip_len) + optlen);
	return (m);
}

/*
 * Copy options from ip to jp,
 * omitting those not copied during fragmentation.
 */
int
ip_optcopy(struct ip *ip, struct ip *jp)
{
	u_char *cp, *dp;
	int opt, optlen, cnt;

	cp = (u_char *)(ip + 1);
	dp = (u_char *)(jp + 1);
	cnt = (ip->ip_hl << 2) - sizeof (struct ip);
	for (; cnt > 0; cnt -= optlen, cp += optlen) {
		opt = cp[0];
		if (opt == IPOPT_EOL)
			break;
		if (opt == IPOPT_NOP) {
			/* Preserve for IP mcast tunnel's LSRR alignment. */
			*dp++ = IPOPT_NOP;
			optlen = 1;
			continue;
		}
#ifdef DIAGNOSTIC
		if (cnt < IPOPT_OLEN + sizeof(*cp))
			panic("malformed IPv4 option passed to ip_optcopy");
#endif
		optlen = cp[IPOPT_OLEN];
#ifdef DIAGNOSTIC
		if (optlen < IPOPT_OLEN + sizeof(*cp) || optlen > cnt)
			panic("malformed IPv4 option passed to ip_optcopy");
#endif
		/* bogus lengths should have been caught by ip_dooptions */
		if (optlen > cnt)
			optlen = cnt;
		if (IPOPT_COPIED(opt)) {
			memcpy(dp, cp, optlen);
			dp += optlen;
		}
	}
	for (optlen = dp - (u_char *)(jp+1); optlen & 0x3; optlen++)
		*dp++ = IPOPT_EOL;
	return (optlen);
}

/*
 * IP socket option processing.
 */
int
ip_ctloutput(int op, struct socket *so, int level, int optname,
    struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	int optval = 0;
	struct proc *p = curproc; /* XXX */
	int error = 0;
	u_int rtid = 0;

	if (level != IPPROTO_IP) {
		error = EINVAL;
	} else switch (op) {
	case PRCO_SETOPT:
		switch (optname) {
		case IP_OPTIONS:
			return (ip_pcbopts(&inp->inp_options, m));

		case IP_TOS:
		case IP_TTL:
		case IP_MINTTL:
		case IP_RECVOPTS:
		case IP_RECVRETOPTS:
		case IP_RECVDSTADDR:
		case IP_RECVIF:
		case IP_RECVTTL:
		case IP_RECVDSTPORT:
		case IP_RECVRTABLE:
		case IP_IPSECFLOWINFO:
			if (m == NULL || m->m_len != sizeof(int))
				error = EINVAL;
			else {
				optval = *mtod(m, int *);
				switch (optname) {

				case IP_TOS:
					inp->inp_ip.ip_tos = optval;
					break;

				case IP_TTL:
					if (optval > 0 && optval <= MAXTTL)
						inp->inp_ip.ip_ttl = optval;
					else if (optval == -1)
						inp->inp_ip.ip_ttl = ip_defttl;
					else
						error = EINVAL;
					break;

				case IP_MINTTL:
					if (optval >= 0 && optval <= MAXTTL)
						inp->inp_ip_minttl = optval;
					else
						error = EINVAL;
					break;
#define	OPTSET(bit) \
	if (optval) \
		inp->inp_flags |= bit; \
	else \
		inp->inp_flags &= ~bit;

				case IP_RECVOPTS:
					OPTSET(INP_RECVOPTS);
					break;

				case IP_RECVRETOPTS:
					OPTSET(INP_RECVRETOPTS);
					break;

				case IP_RECVDSTADDR:
					OPTSET(INP_RECVDSTADDR);
					break;
				case IP_RECVIF:
					OPTSET(INP_RECVIF);
					break;
				case IP_RECVTTL:
					OPTSET(INP_RECVTTL);
					break;
				case IP_RECVDSTPORT:
					OPTSET(INP_RECVDSTPORT);
					break;
				case IP_RECVRTABLE:
					OPTSET(INP_RECVRTABLE);
					break;
				case IP_IPSECFLOWINFO:
					OPTSET(INP_IPSECFLOWINFO);
					break;
				}
			}
			break;
#undef OPTSET

		case IP_MULTICAST_IF:
		case IP_MULTICAST_TTL:
		case IP_MULTICAST_LOOP:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			error = ip_setmoptions(optname, &inp->inp_moptions, m,
			    inp->inp_rtableid);
			break;

		case IP_PORTRANGE:
			if (m == NULL || m->m_len != sizeof(int))
				error = EINVAL;
			else {
				optval = *mtod(m, int *);

				switch (optval) {

				case IP_PORTRANGE_DEFAULT:
					inp->inp_flags &= ~(INP_LOWPORT);
					inp->inp_flags &= ~(INP_HIGHPORT);
					break;

				case IP_PORTRANGE_HIGH:
					inp->inp_flags &= ~(INP_LOWPORT);
					inp->inp_flags |= INP_HIGHPORT;
					break;

				case IP_PORTRANGE_LOW:
					inp->inp_flags &= ~(INP_HIGHPORT);
					inp->inp_flags |= INP_LOWPORT;
					break;

				default:

					error = EINVAL;
					break;
				}
			}
			break;
		case IP_AUTH_LEVEL:
		case IP_ESP_TRANS_LEVEL:
		case IP_ESP_NETWORK_LEVEL:
		case IP_IPCOMP_LEVEL:
#ifndef IPSEC
			error = EOPNOTSUPP;
#else
			if (m == NULL || m->m_len != sizeof(int)) {
				error = EINVAL;
				break;
			}
			optval = *mtod(m, int *);

			if (optval < IPSEC_LEVEL_BYPASS ||
			    optval > IPSEC_LEVEL_UNIQUE) {
				error = EINVAL;
				break;
			}

			switch (optname) {
			case IP_AUTH_LEVEL:
				if (optval < IPSEC_AUTH_LEVEL_DEFAULT &&
				    suser(p, 0)) {
					error = EACCES;
					break;
				}
				inp->inp_seclevel[SL_AUTH] = optval;
				break;

			case IP_ESP_TRANS_LEVEL:
				if (optval < IPSEC_ESP_TRANS_LEVEL_DEFAULT &&
				    suser(p, 0)) {
					error = EACCES;
					break;
				}
				inp->inp_seclevel[SL_ESP_TRANS] = optval;
				break;

			case IP_ESP_NETWORK_LEVEL:
				if (optval < IPSEC_ESP_NETWORK_LEVEL_DEFAULT &&
				    suser(p, 0)) {
					error = EACCES;
					break;
				}
				inp->inp_seclevel[SL_ESP_NETWORK] = optval;
				break;
			case IP_IPCOMP_LEVEL:
				if (optval < IPSEC_IPCOMP_LEVEL_DEFAULT &&
				    suser(p, 0)) {
					error = EACCES;
					break;
				}
				inp->inp_seclevel[SL_IPCOMP] = optval;
				break;
			}
#endif
			break;

		case IP_IPSEC_LOCAL_ID:
		case IP_IPSEC_REMOTE_ID:
			error = EOPNOTSUPP;
			break;
		case SO_RTABLE:
			if (m == NULL || m->m_len < sizeof(u_int)) {
				error = EINVAL;
				break;
			}
			rtid = *mtod(m, u_int *);
			if (inp->inp_rtableid == rtid)
				break;
			/* needs privileges to switch when already set */
			if (p->p_p->ps_rtableid != rtid &&
			    p->p_p->ps_rtableid != 0 &&
			    (error = suser(p, 0)) != 0)
				break;
			/* table must exist */
			if (!rtable_exists(rtid)) {
				error = EINVAL;
				break;
			}
			if (inp->inp_lport) {
				error = EBUSY;
				break;
			}
			inp->inp_rtableid = rtid;
			in_pcbrehash(inp);
			break;
		case IP_PIPEX:
			if (m != NULL && m->m_len == sizeof(int))
				inp->inp_pipex = *mtod(m, int *);
			else
				error = EINVAL;
			break;

		default:
			error = ENOPROTOOPT;
			break;
		}
		break;

	case PRCO_GETOPT:
		switch (optname) {
		case IP_OPTIONS:
		case IP_RETOPTS:
			if (inp->inp_options) {
				m->m_len = inp->inp_options->m_len;
				memcpy(mtod(m, caddr_t),
				    mtod(inp->inp_options, caddr_t), m->m_len);
			} else
				m->m_len = 0;
			break;

		case IP_TOS:
		case IP_TTL:
		case IP_MINTTL:
		case IP_RECVOPTS:
		case IP_RECVRETOPTS:
		case IP_RECVDSTADDR:
		case IP_RECVIF:
		case IP_RECVTTL:
		case IP_RECVDSTPORT:
		case IP_RECVRTABLE:
		case IP_IPSECFLOWINFO:
		case IP_IPDEFTTL:
			m->m_len = sizeof(int);
			switch (optname) {

			case IP_TOS:
				optval = inp->inp_ip.ip_tos;
				break;

			case IP_TTL:
				optval = inp->inp_ip.ip_ttl;
				break;

			case IP_MINTTL:
				optval = inp->inp_ip_minttl;
				break;

			case IP_IPDEFTTL:
				optval = ip_defttl;
				break;

#define	OPTBIT(bit)	(inp->inp_flags & bit ? 1 : 0)

			case IP_RECVOPTS:
				optval = OPTBIT(INP_RECVOPTS);
				break;

			case IP_RECVRETOPTS:
				optval = OPTBIT(INP_RECVRETOPTS);
				break;

			case IP_RECVDSTADDR:
				optval = OPTBIT(INP_RECVDSTADDR);
				break;
			case IP_RECVIF:
				optval = OPTBIT(INP_RECVIF);
				break;
			case IP_RECVTTL:
				optval = OPTBIT(INP_RECVTTL);
				break;
			case IP_RECVDSTPORT:
				optval = OPTBIT(INP_RECVDSTPORT);
				break;
			case IP_RECVRTABLE:
				optval = OPTBIT(INP_RECVRTABLE);
				break;
			case IP_IPSECFLOWINFO:
				optval = OPTBIT(INP_IPSECFLOWINFO);
				break;
			}
			*mtod(m, int *) = optval;
			break;

		case IP_MULTICAST_IF:
		case IP_MULTICAST_TTL:
		case IP_MULTICAST_LOOP:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			error = ip_getmoptions(optname, inp->inp_moptions, m);
			break;

		case IP_PORTRANGE:
			m->m_len = sizeof(int);

			if (inp->inp_flags & INP_HIGHPORT)
				optval = IP_PORTRANGE_HIGH;
			else if (inp->inp_flags & INP_LOWPORT)
				optval = IP_PORTRANGE_LOW;
			else
				optval = 0;

			*mtod(m, int *) = optval;
			break;

		case IP_AUTH_LEVEL:
		case IP_ESP_TRANS_LEVEL:
		case IP_ESP_NETWORK_LEVEL:
		case IP_IPCOMP_LEVEL:
#ifndef IPSEC
			m->m_len = sizeof(int);
			*mtod(m, int *) = IPSEC_LEVEL_NONE;
#else
			m->m_len = sizeof(int);
			switch (optname) {
			case IP_AUTH_LEVEL:
				optval = inp->inp_seclevel[SL_AUTH];
				break;

			case IP_ESP_TRANS_LEVEL:
				optval = inp->inp_seclevel[SL_ESP_TRANS];
				break;

			case IP_ESP_NETWORK_LEVEL:
				optval = inp->inp_seclevel[SL_ESP_NETWORK];
				break;
			case IP_IPCOMP_LEVEL:
				optval = inp->inp_seclevel[SL_IPCOMP];
				break;
			}
			*mtod(m, int *) = optval;
#endif
			break;
		case IP_IPSEC_LOCAL_ID:
		case IP_IPSEC_REMOTE_ID:
			error = EOPNOTSUPP;
			break;
		case SO_RTABLE:
			m->m_len = sizeof(u_int);
			*mtod(m, u_int *) = inp->inp_rtableid;
			break;
		case IP_PIPEX:
			m->m_len = sizeof(int);
			*mtod(m, int *) = inp->inp_pipex;
			break;
		default:
			error = ENOPROTOOPT;
			break;
		}
		break;
	}
	return (error);
}

/*
 * Set up IP options in pcb for insertion in output packets.
 * Store in mbuf with pointer in pcbopt, adding pseudo-option
 * with destination address if source routed.
 */
int
ip_pcbopts(struct mbuf **pcbopt, struct mbuf *m)
{
	int cnt, optlen;
	u_char *cp;
	u_char opt;

	/* turn off any old options */
	m_free(*pcbopt);
	*pcbopt = 0;
	if (m == NULL || m->m_len == 0) {
		/*
		 * Only turning off any previous options.
		 */
		return (0);
	}

	if (m->m_len % sizeof(int32_t))
		return (EINVAL);

	/*
	 * IP first-hop destination address will be stored before
	 * actual options; move other options back
	 * and clear it when none present.
	 */
	if (m->m_data + m->m_len + sizeof(struct in_addr) >= &m->m_dat[MLEN])
		return (EINVAL);
	cnt = m->m_len;
	m->m_len += sizeof(struct in_addr);
	cp = mtod(m, u_char *) + sizeof(struct in_addr);
	memmove((caddr_t)cp, mtod(m, caddr_t), (unsigned)cnt);
	memset(mtod(m, caddr_t), 0, sizeof(struct in_addr));

	for (; cnt > 0; cnt -= optlen, cp += optlen) {
		opt = cp[IPOPT_OPTVAL];
		if (opt == IPOPT_EOL)
			break;
		if (opt == IPOPT_NOP)
			optlen = 1;
		else {
			if (cnt < IPOPT_OLEN + sizeof(*cp))
				return (EINVAL);
			optlen = cp[IPOPT_OLEN];
			if (optlen < IPOPT_OLEN  + sizeof(*cp) || optlen > cnt)
				return (EINVAL);
		}
		switch (opt) {

		default:
			break;

		case IPOPT_LSRR:
		case IPOPT_SSRR:
			/*
			 * user process specifies route as:
			 *	->A->B->C->D
			 * D must be our final destination (but we can't
			 * check that since we may not have connected yet).
			 * A is first hop destination, which doesn't appear in
			 * actual IP option, but is stored before the options.
			 */
			if (optlen < IPOPT_MINOFF - 1 + sizeof(struct in_addr))
				return (EINVAL);
			m->m_len -= sizeof(struct in_addr);
			cnt -= sizeof(struct in_addr);
			optlen -= sizeof(struct in_addr);
			cp[IPOPT_OLEN] = optlen;
			/*
			 * Move first hop before start of options.
			 */
			memcpy(mtod(m, caddr_t), &cp[IPOPT_OFFSET+1],
			    sizeof(struct in_addr));
			/*
			 * Then copy rest of options back
			 * to close up the deleted entry.
			 */
			memmove((caddr_t)&cp[IPOPT_OFFSET+1],
			    (caddr_t)(&cp[IPOPT_OFFSET+1] +
			    sizeof(struct in_addr)),
			    (unsigned)cnt - (IPOPT_OFFSET+1));
			break;
		}
	}
	if (m->m_len > MAX_IPOPTLEN + sizeof(struct in_addr))
		return (EINVAL);
	*pcbopt = m_copym(m, 0, M_COPYALL, M_NOWAIT);
	if (*pcbopt == NULL)
		return (ENOBUFS);

	return (0);
}

/*
 * Set the IP multicast options in response to user setsockopt().
 */
int
ip_setmoptions(int optname, struct ip_moptions **imop, struct mbuf *m,
    u_int rtableid)
{
	struct in_addr addr;
	struct in_ifaddr *ia;
	struct ip_mreq *mreq;
	struct ifnet *ifp = NULL;
	struct ip_moptions *imo = *imop;
	struct in_multi **immp;
	struct rtentry *rt;
	struct sockaddr_in sin;
	int i, error = 0;
	u_char loop;

	if (imo == NULL) {
		/*
		 * No multicast option buffer attached to the pcb;
		 * allocate one and initialize to default values.
		 */
		imo = malloc(sizeof(*imo), M_IPMOPTS, M_WAITOK|M_ZERO);
		immp = (struct in_multi **)malloc(
		    (sizeof(*immp) * IP_MIN_MEMBERSHIPS), M_IPMOPTS,
		    M_WAITOK|M_ZERO);
		*imop = imo;
		imo->imo_ifidx = 0;
		imo->imo_ttl = IP_DEFAULT_MULTICAST_TTL;
		imo->imo_loop = IP_DEFAULT_MULTICAST_LOOP;
		imo->imo_num_memberships = 0;
		imo->imo_max_memberships = IP_MIN_MEMBERSHIPS;
		imo->imo_membership = immp;
	}

	switch (optname) {

	case IP_MULTICAST_IF:
		/*
		 * Select the interface for outgoing multicast packets.
		 */
		if (m == NULL || m->m_len != sizeof(struct in_addr)) {
			error = EINVAL;
			break;
		}
		addr = *(mtod(m, struct in_addr *));
		/*
		 * INADDR_ANY is used to remove a previous selection.
		 * When no interface is selected, a default one is
		 * chosen every time a multicast packet is sent.
		 */
		if (addr.s_addr == INADDR_ANY) {
			imo->imo_ifidx = 0;
			break;
		}
		/*
		 * The selected interface is identified by its local
		 * IP address.  Find the interface and confirm that
		 * it supports multicasting.
		 */
		memset(&sin, 0, sizeof(sin));
		sin.sin_len = sizeof(sin);
		sin.sin_family = AF_INET;
		sin.sin_addr = addr;
		ia = ifatoia(ifa_ifwithaddr(sintosa(&sin), rtableid));
		if (ia == NULL ||
		    (ia->ia_ifp->if_flags & IFF_MULTICAST) == 0) {
			error = EADDRNOTAVAIL;
			break;
		}
		imo->imo_ifidx = ia->ia_ifp->if_index;
		break;

	case IP_MULTICAST_TTL:
		/*
		 * Set the IP time-to-live for outgoing multicast packets.
		 */
		if (m == NULL || m->m_len != 1) {
			error = EINVAL;
			break;
		}
		imo->imo_ttl = *(mtod(m, u_char *));
		break;

	case IP_MULTICAST_LOOP:
		/*
		 * Set the loopback flag for outgoing multicast packets.
		 * Must be zero or one.
		 */
		if (m == NULL || m->m_len != 1 ||
		   (loop = *(mtod(m, u_char *))) > 1) {
			error = EINVAL;
			break;
		}
		imo->imo_loop = loop;
		break;

	case IP_ADD_MEMBERSHIP:
		/*
		 * Add a multicast group membership.
		 * Group must be a valid IP multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ip_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ip_mreq *);
		if (!IN_MULTICAST(mreq->imr_multiaddr.s_addr)) {
			error = EINVAL;
			break;
		}
		/*
		 * If no interface address was provided, use the interface of
		 * the route to the given multicast address.
		 */
		if (mreq->imr_interface.s_addr == INADDR_ANY) {
			memset(&sin, 0, sizeof(sin));
			sin.sin_len = sizeof(sin);
			sin.sin_family = AF_INET;
			sin.sin_addr = mreq->imr_multiaddr;
			rt = rtalloc(sintosa(&sin), RT_RESOLVE, rtableid);
			if (!rtisvalid(rt)) {
				rtfree(rt);
				error = EADDRNOTAVAIL;
				break;
			}
		} else {
			memset(&sin, 0, sizeof(sin));
			sin.sin_len = sizeof(sin);
			sin.sin_family = AF_INET;
			sin.sin_addr = mreq->imr_interface;
			rt = rtalloc(sintosa(&sin), 0, rtableid);
			if (!rtisvalid(rt) || !ISSET(rt->rt_flags, RTF_LOCAL)) {
				rtfree(rt);
				error = EADDRNOTAVAIL;
				break;
			}
		}
		ifp = if_get(rt->rt_ifidx);
		rtfree(rt);

		/*
		 * See if we found an interface, and confirm that it
		 * supports multicast.
		 */
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
			error = EADDRNOTAVAIL;
			if_put(ifp);
			break;
		}
		/*
		 * See if the membership already exists or if all the
		 * membership slots are full.
		 */
		for (i = 0; i < imo->imo_num_memberships; ++i) {
			if (imo->imo_membership[i]->inm_ifidx
						== ifp->if_index &&
			    imo->imo_membership[i]->inm_addr.s_addr
						== mreq->imr_multiaddr.s_addr)
				break;
		}
		if (i < imo->imo_num_memberships) {
			error = EADDRINUSE;
			if_put(ifp);
			break;
		}
		if (imo->imo_num_memberships == imo->imo_max_memberships) {
			struct in_multi **nmships, **omships;
			size_t newmax;
			/*
			 * Resize the vector to next power-of-two minus 1. If the
			 * size would exceed the maximum then we know we've really
			 * run out of entries. Otherwise, we reallocate the vector.
			 */
			nmships = NULL;
			omships = imo->imo_membership;
			newmax = ((imo->imo_max_memberships + 1) * 2) - 1;
			if (newmax <= IP_MAX_MEMBERSHIPS) {
				nmships = (struct in_multi **)mallocarray(
				    newmax, sizeof(*nmships), M_IPMOPTS,
				    M_NOWAIT|M_ZERO);
				if (nmships != NULL) {
					memcpy(nmships, omships,
					    sizeof(*omships) *
					    imo->imo_max_memberships);
					free(omships, M_IPMOPTS,
					    sizeof(*omships) *
					    imo->imo_max_memberships);
					imo->imo_membership = nmships;
					imo->imo_max_memberships = newmax;
				}
			}
			if (nmships == NULL) {
				error = ENOBUFS;
				if_put(ifp);
				break;
			}
		}
		/*
		 * Everything looks good; add a new record to the multicast
		 * address list for the given interface.
		 */
		if ((imo->imo_membership[i] =
		    in_addmulti(&mreq->imr_multiaddr, ifp)) == NULL) {
			error = ENOBUFS;
			if_put(ifp);
			break;
		}
		++imo->imo_num_memberships;
		if_put(ifp);
		break;

	case IP_DROP_MEMBERSHIP:
		/*
		 * Drop a multicast group membership.
		 * Group must be a valid IP multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ip_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ip_mreq *);
		if (!IN_MULTICAST(mreq->imr_multiaddr.s_addr)) {
			error = EINVAL;
			break;
		}
		/*
		 * If an interface address was specified, get a pointer
		 * to its ifnet structure.
		 */
		if (mreq->imr_interface.s_addr == INADDR_ANY)
			ifp = NULL;
		else {
			memset(&sin, 0, sizeof(sin));
			sin.sin_len = sizeof(sin);
			sin.sin_family = AF_INET;
			sin.sin_addr = mreq->imr_interface;
			ia = ifatoia(ifa_ifwithaddr(sintosa(&sin), rtableid));
			if (ia == NULL) {
				error = EADDRNOTAVAIL;
				break;
			}
			ifp = ia->ia_ifp;
		}
		/*
		 * Find the membership in the membership array.
		 */
		for (i = 0; i < imo->imo_num_memberships; ++i) {
			if ((ifp == NULL ||
			    imo->imo_membership[i]->inm_ifidx ==
			        ifp->if_index) &&
			     imo->imo_membership[i]->inm_addr.s_addr ==
			     mreq->imr_multiaddr.s_addr)
				break;
		}
		if (i == imo->imo_num_memberships) {
			error = EADDRNOTAVAIL;
			break;
		}
		/*
		 * Give up the multicast address record to which the
		 * membership points.
		 */
		in_delmulti(imo->imo_membership[i]);
		/*
		 * Remove the gap in the membership array.
		 */
		for (++i; i < imo->imo_num_memberships; ++i)
			imo->imo_membership[i-1] = imo->imo_membership[i];
		--imo->imo_num_memberships;
		break;

	default:
		error = EOPNOTSUPP;
		break;
	}

	/*
	 * If all options have default values, no need to keep the data.
	 */
	if (imo->imo_ifidx == 0 &&
	    imo->imo_ttl == IP_DEFAULT_MULTICAST_TTL &&
	    imo->imo_loop == IP_DEFAULT_MULTICAST_LOOP &&
	    imo->imo_num_memberships == 0) {
		free(imo->imo_membership , M_IPMOPTS, 0);
		free(*imop, M_IPMOPTS, sizeof(**imop));
		*imop = NULL;
	}

	return (error);
}

/*
 * Return the IP multicast options in response to user getsockopt().
 */
int
ip_getmoptions(int optname, struct ip_moptions *imo, struct mbuf *m)
{
	u_char *ttl;
	u_char *loop;
	struct in_addr *addr;
	struct in_ifaddr *ia;
	struct ifnet *ifp;

	switch (optname) {

	case IP_MULTICAST_IF:
		addr = mtod(m, struct in_addr *);
		m->m_len = sizeof(struct in_addr);
		if (imo == NULL || (ifp = if_get(imo->imo_ifidx)) == NULL)
			addr->s_addr = INADDR_ANY;
		else {
			IFP_TO_IA(ifp, ia);
			if_put(ifp);
			addr->s_addr = (ia == NULL) ? INADDR_ANY
					: ia->ia_addr.sin_addr.s_addr;
		}
		return (0);

	case IP_MULTICAST_TTL:
		ttl = mtod(m, u_char *);
		m->m_len = 1;
		*ttl = (imo == NULL) ? IP_DEFAULT_MULTICAST_TTL
				     : imo->imo_ttl;
		return (0);

	case IP_MULTICAST_LOOP:
		loop = mtod(m, u_char *);
		m->m_len = 1;
		*loop = (imo == NULL) ? IP_DEFAULT_MULTICAST_LOOP
				      : imo->imo_loop;
		return (0);

	default:
		return (EOPNOTSUPP);
	}
}

/*
 * Discard the IP multicast options.
 */
void
ip_freemoptions(struct ip_moptions *imo)
{
	int i;

	if (imo != NULL) {
		for (i = 0; i < imo->imo_num_memberships; ++i)
			in_delmulti(imo->imo_membership[i]);
		free(imo->imo_membership, M_IPMOPTS, 0);
		free(imo, M_IPMOPTS, sizeof(*imo));
	}
}

/*
 * Routine called from ip_output() to loop back a copy of an IP multicast
 * packet to the input queue of a specified interface.
 */
void
ip_mloopback(struct ifnet *ifp, struct mbuf *m, struct sockaddr_in *dst)
{
	struct ip *ip;
	struct mbuf *copym;

	copym = m_dup_pkt(m, max_linkhdr, M_DONTWAIT);
	if (copym != NULL) {
		/*
		 * We don't bother to fragment if the IP length is greater
		 * than the interface's MTU.  Can this possibly matter?
		 */
		ip = mtod(copym, struct ip *);
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(copym, ip->ip_hl << 2);
		if_input_local(ifp, copym, dst->sin_family);
	}
}

/*
 *	Compute significant parts of the IPv4 checksum pseudo-header
 *	for use in a delayed TCP/UDP checksum calculation.
 */
static __inline u_int16_t __attribute__((__unused__))
in_cksum_phdr(u_int32_t src, u_int32_t dst, u_int32_t lenproto)
{
	u_int32_t sum;

	sum = lenproto +
	      (u_int16_t)(src >> 16) +
	      (u_int16_t)(src /*& 0xffff*/) +
	      (u_int16_t)(dst >> 16) +
	      (u_int16_t)(dst /*& 0xffff*/);

	sum = (u_int16_t)(sum >> 16) + (u_int16_t)(sum /*& 0xffff*/);

	if (sum > 0xffff)
		sum -= 0xffff;

	return (sum);
}

/*
 * Process a delayed payload checksum calculation.
 */
void
in_delayed_cksum(struct mbuf *m)
{
	struct ip *ip;
	u_int16_t csum, offset;

	ip = mtod(m, struct ip *);
	offset = ip->ip_hl << 2;
	csum = in4_cksum(m, 0, offset, m->m_pkthdr.len - offset);
	if (csum == 0 && ip->ip_p == IPPROTO_UDP)
		csum = 0xffff;

	switch (ip->ip_p) {
	case IPPROTO_TCP:
		offset += offsetof(struct tcphdr, th_sum);
		break;

	case IPPROTO_UDP:
		offset += offsetof(struct udphdr, uh_sum);
		break;

	case IPPROTO_ICMP:
		offset += offsetof(struct icmp, icmp_cksum);
		break;

	default:
		return;
	}

	if ((offset + sizeof(u_int16_t)) > m->m_len)
		m_copyback(m, offset, sizeof(csum), &csum, M_NOWAIT);
	else
		*(u_int16_t *)(mtod(m, caddr_t) + offset) = csum;
}

void
in_proto_cksum_out(struct mbuf *m, struct ifnet *ifp)
{
	struct ip *ip = mtod(m, struct ip *);

	/* some hw and in_delayed_cksum need the pseudo header cksum */
	if (m->m_pkthdr.csum_flags &
	    (M_TCP_CSUM_OUT|M_UDP_CSUM_OUT|M_ICMP_CSUM_OUT)) {
		u_int16_t csum = 0, offset;

		offset = ip->ip_hl << 2;
		if (m->m_pkthdr.csum_flags & (M_TCP_CSUM_OUT|M_UDP_CSUM_OUT))
			csum = in_cksum_phdr(ip->ip_src.s_addr,
			    ip->ip_dst.s_addr, htonl(ntohs(ip->ip_len) -
			    offset + ip->ip_p));
		if (ip->ip_p == IPPROTO_TCP)
			offset += offsetof(struct tcphdr, th_sum);
		else if (ip->ip_p == IPPROTO_UDP)
			offset += offsetof(struct udphdr, uh_sum);
		else if (ip->ip_p == IPPROTO_ICMP)
			offset += offsetof(struct icmp, icmp_cksum);
		if ((offset + sizeof(u_int16_t)) > m->m_len)
			m_copyback(m, offset, sizeof(csum), &csum, M_NOWAIT);
		else
			*(u_int16_t *)(mtod(m, caddr_t) + offset) = csum;
	}

	if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT) {
		if (!ifp || !(ifp->if_capabilities & IFCAP_CSUM_TCPv4) ||
		    ip->ip_hl != 5 || ifp->if_bridgeport != NULL) {
			tcpstat_inc(tcps_outswcsum);
			in_delayed_cksum(m);
			m->m_pkthdr.csum_flags &= ~M_TCP_CSUM_OUT; /* Clear */
		}
	} else if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT) {
		if (!ifp || !(ifp->if_capabilities & IFCAP_CSUM_UDPv4) ||
		    ip->ip_hl != 5 || ifp->if_bridgeport != NULL) {
			udpstat_inc(udps_outswcsum);
			in_delayed_cksum(m);
			m->m_pkthdr.csum_flags &= ~M_UDP_CSUM_OUT; /* Clear */
		}
	} else if (m->m_pkthdr.csum_flags & M_ICMP_CSUM_OUT) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum_flags &= ~M_ICMP_CSUM_OUT; /* Clear */
	}
}
@


1.341
log
@Change sosetopt() to no longer free the mbuf it receives and change
all the callers to call m_freem(9).

Support from deraadt@@ and tedu@@, ok visa@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.340 2017/05/29 14:36:22 mpi Exp $	*/
d1307 1
a1307 1
	*pcbopt = m_dup_pkt(m, 0, M_NOWAIT);
@


1.340
log
@Per-interface list of addresses, both multicast and unicast, are
currently protected by the NET_LOCK().

They are not accessed in the hot path, so protecting them with a
mutex could be an option.  However since we're now going to run
with a NET_LOCK() for some time, assert that it is held.

IPsec is not yet ready to run without KERNEL_LOCK(), so assert it
is held, even in the forwarding path.

Tested by sthen@@, ok visa@@, claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.339 2017/04/19 15:21:54 bluhm Exp $	*/
d75 2
a853 2
		if (op == PRCO_SETOPT)
			(void) m_free(m);
a1069 1
		m_free(m);
a1235 1
		m_free(m);
d1240 1
a1240 1
		goto bad;
d1248 1
a1248 1
		goto bad;
d1263 1
a1263 1
				goto bad;
d1266 1
a1266 1
				goto bad;
d1284 1
a1284 1
				goto bad;
d1306 5
a1310 2
		goto bad;
	*pcbopt = m;
a1311 4

bad:
	(void)m_free(m);
	return (EINVAL);
@


1.339
log
@Use the rt_rmx defines that hide the struct rt_kmetrics indirection.
No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.338 2017/04/11 14:43:49 dhill Exp $	*/
a194 1
			KERNEL_LOCK();
a197 1
			KERNEL_UNLOCK();
d234 1
a234 1
		KERNEL_LOCK();
a237 1
		KERNEL_UNLOCK();
a306 1
			KERNEL_LOCK();
a309 1
			KERNEL_UNLOCK();
d405 1
a405 1
		KERNEL_LOCK();
a407 1
		KERNEL_UNLOCK();
@


1.338
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.337 2017/04/09 17:57:58 dhill Exp $	*/
d223 1
a223 1
		if ((mtu = ro->ro_rt->rt_rmx.rmx_mtu) == 0)
d402 1
a402 1
	    (ro->ro_rt->rt_rmx.rmx_locks & RTV_MTU) == 0)
d491 3
a493 3
		    !(ro->ro_rt->rt_rmx.rmx_locks & RTV_MTU) &&
		    (ro->ro_rt->rt_rmx.rmx_mtu > ifp->if_mtu)) {
			ro->ro_rt->rt_rmx.rmx_mtu = ifp->if_mtu;
d614 1
a614 1
			rt->rt_rmx.rmx_mtu = tdb->tdb_mtu;
@


1.337
log
@Use mallocarray to allocate multicast group memberships.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.336 2017/02/09 15:19:32 jca Exp $	*/
d1347 2
a1348 2
		immp = (struct in_multi **)mallocarray(
		    IP_MIN_MEMBERSHIPS, sizeof(*immp), M_IPMOPTS,
@


1.336
log
@percpu counters for TCP stats

ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.335 2017/02/01 20:59:47 dhill Exp $	*/
d1347 2
a1348 2
		immp = (struct in_multi **)malloc(
		    (sizeof(*immp) * IP_MIN_MEMBERSHIPS), M_IPMOPTS,
d1502 2
a1503 2
				nmships = (struct in_multi **)malloc(
				    sizeof(*nmships) * newmax, M_IPMOPTS,
@


1.335
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.334 2017/01/10 09:01:18 mpi Exp $	*/
d1792 1
a1792 1
			tcpstat.tcps_outswcsum++;
@


1.334
log
@Remove NULL checks before m_free(9), it deals with it.

ok bluhm@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.333 2016/12/19 09:22:24 rzalamena Exp $	*/
d848 1
a848 1
    struct mbuf **mp)
a850 1
	struct mbuf *m = *mp;
d859 1
a859 1
			(void) m_free(*mp);
a1082 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
a1102 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
d1159 1
a1159 1
			error = ip_getmoptions(optname, inp->inp_moptions, mp);
a1162 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
a1178 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
a1207 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
a1211 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
d1620 1
a1620 1
ip_getmoptions(int optname, struct ip_moptions *imo, struct mbuf **mp)
a1627 2
	*mp = m_get(M_WAIT, MT_SOOPTS);

d1631 2
a1632 2
		addr = mtod(*mp, struct in_addr *);
		(*mp)->m_len = sizeof(struct in_addr);
d1644 2
a1645 2
		ttl = mtod(*mp, u_char *);
		(*mp)->m_len = 1;
d1651 2
a1652 2
		loop = mtod(*mp, u_char *);
		(*mp)->m_len = 1;
@


1.333
log
@Extend the multicast sockets and multicast hash table support to multiple
domains. This is one step towards supporting to run more than one multicast
socket in different domains at the same time.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.332 2016/12/19 08:36:49 mpi Exp $	*/
d1077 1
a1077 2
		if (m)
			(void)m_free(m);
d1244 1
a1244 2
	if (*pcbopt)
		(void)m_free(*pcbopt);
d1250 1
a1250 2
		if (m)
			(void)m_free(m);
@


1.332
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.331 2016/11/28 10:14:00 mpi Exp $	*/
d343 1
a343 1
			if (ipmforwarding && ip_mrouter &&
@


1.331
log
@Kill a micro optimization that no longer make sense since the two routing
blocks have been merged in r1.292.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.330 2016/11/18 02:53:47 dlg Exp $	*/
d111 2
@


1.330
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the udpstat struct.

udpstat_inc(udps_foo) replaces udpstat.udps_foo++ for the actual
updates. udpstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the udpstat struct for
now.

ok mpi@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.329 2016/11/14 10:32:46 mpi Exp $	*/
a251 5

			/* If it's not a multicast packet, try to fast-path */
			if (!IN_MULTICAST(ip->ip_dst.s_addr)) {
				goto sendit;
			}
@


1.329
log
@Automatically create a default lo(4) interface per rdomain.

In order to stop abusing lo0 for all rdomains, a new loopback interface
will be created every time a rdomain is created.  The unit number will
be the same as the rdomain, i.e. lo1 will be attached to rdomain 1.

If this loopback interface is already in use it wont be possible to create
the corresponding rdomain.

In order to know which lo(4) interface is attached to a rdomain, its index
is stored in the rtable/rdomain map.

This is a long overdue since the introduction of rtable/rdomain.  It also
fixes a recent regression due to resetting the rdomain of an incoming
packet reported by semarie@@, Andreas Bartelt and Nils Frohberg.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.328 2016/11/14 03:51:53 dlg Exp $	*/
d1814 1
a1814 1
			udpstat.udps_outswcsum++;
@


1.328
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the ipstat struct.

ipstat_inc(ips_foo) replaces ipstat.ips_foo++ for the actual updates.
ipstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the ipstat struct for now.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.327 2016/09/04 17:18:56 mpi Exp $	*/
d214 1
a214 1
			ifp = if_get(lo0ifidx);
@


1.327
log
@Prevent a NULL derefernce in ip_output().

A race can happen if a task, like the watchog, sleeps too long keeping
an ifp reference while the interface is detached.  In this case a TCP
timer will try to send packets with a cached route.  Since the ifp is
being detached if_get(9) returns NULL.

Found the hardway by awolk@@.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.326 2016/08/15 11:35:25 dlg Exp $	*/
d136 1
a136 1
		ipstat.ips_localout++;
d207 1
a207 1
			ipstat.ips_noroute++;
d287 1
a287 1
			ipstat.ips_noroute++;
d301 1
a301 1
			ipstat.ips_noroute++;
d467 1
a467 1
			ipstat.ips_outswcsum++;
d498 1
a498 1
		ipstat.ips_cantfrag++;
d518 1
a518 1
		ipstat.ips_fragmented++;
d679 1
a679 1
			ipstat.ips_odropped++;
d708 1
a708 1
			ipstat.ips_odropped++;
d721 1
a721 1
			ipstat.ips_outswcsum++;
d724 1
a724 1
		ipstat.ips_ofragments++;
d742 1
a742 1
		ipstat.ips_outswcsum++;
@


1.326
log
@replace the last uses of m_copym2 with m_dup_pkt.

ok mpi@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.325 2016/07/01 18:28:58 jca Exp $	*/
d217 4
@


1.325
log
@Allow resetting the IP_TTL and IP_MINTTL sockopts

IP_TTL can be reset by passing -1, IP_MINTTL can be reset by passing 0.
This is consistent with what Linux does and
IPV6_UNICAST_HOPS/IPV6_MINHOPCOUNT.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.324 2016/06/23 09:08:56 henning Exp $	*/
d1699 1
a1699 1
	copym = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);
@


1.324
log
@when pf_test returns something but PF_PASS, set error to EACCES
instead of EHOSTUNREACH. On the latter, ip_forward can generate undesired
icmp errors - either pf generates those itself (block return), or there
shouldn't be any.
Bizarrely enough, ip_forward has EACCES handling with a comment specifically
pointing to packets blocked by pf, but the code in ip_output used EHOSTUNREACH
from day #1 on.
found & analyzed by Kristof Provost <kp at FreeBSD>, discussed at BSDcan
ok mpi millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.323 2016/05/31 07:33:22 mpi Exp $	*/
d890 2
d897 1
a897 1
					if (optval > 0 && optval <= MAXTTL)
@


1.323
log
@Inverse two conditions to not grabe the KERNEL_LOCK for every multicast
packet.

ok visa@@, stsp@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.322 2016/05/04 13:22:51 vgross Exp $	*/
d422 1
a422 1
		error = EHOSTUNREACH;
@


1.322
log
@Preserve DiffServ value when fragmenting an ipv4 packet.

Ok phessler@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.321 2016/04/29 11:40:27 bluhm Exp $	*/
a187 1
		struct in_ifaddr *ia;
d190 9
a198 5
		KERNEL_LOCK();
		IFP_TO_IA(ifp, ia);
		if (ip->ip_src.s_addr == INADDR_ANY && ia)
			ip->ip_src = ia->ia_addr.sin_addr;
		KERNEL_UNLOCK();
@


1.321
log
@Do not allow to change the routing table of a bound socket.  This
is not intended and will behave unexpectedly if the address is
already used in another domain.  It did not work anyway, as the PCB
ended in the wrong hash bucket after changing the rtable.  Fail
with EBUSY if the socket is already bound and rehash the PCB if its
rtable changes.
input claudio@@; OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.320 2016/04/18 12:10:34 mpi Exp $	*/
d681 1
a681 1
		/* we must inherit MCAST and BCAST flags and routing table */
d684 1
@


1.320
log
@Unbreak RAMDISK, found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.319 2016/04/18 06:43:51 mpi Exp $	*/
d1052 4
d1057 1
@


1.319
log
@Put a KERNEL_LOCK/UNLOCK dance around sections that still need some
work in the forwarding path.

Tested by Hrvoje Popovski, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.318 2016/02/11 12:56:08 jca Exp $	*/
d103 1
a103 1
	int rv, len, error = 0;
d108 3
@


1.318
log
@Return ENOBUFS when bumping in the multicast max group memberships

This removes the only use of ETOOMANYREFS in our code, making intro(2)
match reality.  No software out there explicitely checks for ETOOMANYREFS
in multicast code.

Discussed with millert@@ and mpi@@ (who suggested using ENOBUFS)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.317 2016/01/21 11:23:48 mpi Exp $	*/
d103 1
a103 1
	int len, error = 0;
a105 1
	struct in_ifaddr *ia;
d185 2
d188 1
d190 3
d194 2
d216 4
a221 4
	/* Set the source IP address */
	if (ip->ip_src.s_addr == INADDR_ANY && ia)
		ip->ip_src = ia->ia_addr.sin_addr;

d224 1
d228 1
d301 3
d307 1
a337 2
				int rv;

d403 1
d406 1
@


1.317
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.316 2016/01/13 09:38:36 mpi Exp $	*/
d1499 1
a1499 1
				error = ETOOMANYREFS;
@


1.316
log
@Prevent a double if_put().

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.315 2015/12/05 10:52:26 tedu Exp $	*/
a243 1
		struct in_multi *inm;
d297 2
a298 3
		IN_LOOKUP_MULTI(ip->ip_dst, ifp, inm);
		if (inm != NULL &&
		   (imo == NULL || imo->imo_loop)) {
@


1.315
log
@upgrade tcp/ip to use the latest in C89 technology: memcpy.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.314 2015/12/03 21:29:58 sashan Exp $	*/
d422 1
@


1.314
log
@deleting ip_insertoptions() prototype, which is no longer needed
(follow up on my earlier commit)

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.313 2015/12/03 16:21:38 markus Exp $	*/
d764 1
a764 1
		bcopy((caddr_t)ip, mtod(m, caddr_t), sizeof(struct ip));
d772 1
a772 1
	bcopy((caddr_t)p->ipopt_list, (caddr_t)(ip + 1), optlen);
d814 1
a814 1
			bcopy((caddr_t)cp, (caddr_t)dp, optlen);
d1061 2
a1062 2
				bcopy(mtod(inp->inp_options, caddr_t),
				    mtod(m, caddr_t), m->m_len);
d1283 1
a1283 1
			bcopy((caddr_t)&cp[IPOPT_OFFSET+1], mtod(m, caddr_t),
d1489 1
a1489 1
					bcopy(omships, nmships,
@


1.313
log
@add ifdef IPSEC for protoypes; requested by mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.312 2015/12/03 14:55:18 vgross Exp $	*/
a74 1
struct mbuf *ip_insertoptions(struct mbuf *, struct mbuf *, int *);
@


1.312
log
@Remove broadcast matching from ifa_ifwithaddr(), use in_broadcast() where
required.

ok bluhm@@ mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.311 2015/12/02 20:50:20 markus Exp $	*/
d81 1
d88 1
@


1.311
log
@factor out ip_output_ipsec_{lookup,send}(); with & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.310 2015/12/02 13:29:26 claudio Exp $	*/
d1371 2
a1372 3
		if (ia && in_hosteq(sin.sin_addr, ia->ia_addr.sin_addr))
			ifp = ia->ia_ifp;
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
d1376 1
a1376 1
		imo->imo_ifidx = ifp->if_index;
d1544 1
a1544 3
			if (ia && in_hosteq(sin.sin_addr, ia->ia_addr.sin_addr))
				ifp = ia->ia_ifp;
			else {
d1548 1
@


1.310
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.309 2015/12/01 00:49:12 mmcc Exp $	*/
d81 7
d106 1
a106 1
	u_int8_t sproto = 0;
a107 12
#ifdef IPSEC
	u_int32_t icmp_mtu = 0;
	union sockaddr_union sdst;
	u_int32_t sspi;
	struct m_tag *mtag;
	struct tdb_ident *tdbi;

	struct tdb *tdb;
#if NPF > 0
	struct ifnet *encif;
#endif
#endif /* IPSEC */
d215 12
a226 9
	if (!ipsec_in_use && inp == NULL)
		goto done_spd;

	/* Do we have any pending SAs to apply ? */
	tdb = ipsp_spd_lookup(m, AF_INET, hlen, &error,
	    IPSP_DIRECTION_OUT, NULL, inp, ipsecflowinfo);

	if (tdb == NULL) {
		if (error == 0) {
d228 2
a229 2
			 * No IPsec processing required, we'll just send the
			 * packet out.
d231 1
a231 1
			sproto = 0;
d233 3
a235 27
			/* Fall through to routing/multicast handling */
		} else {
			/*
			 * -EINVAL is used to indicate that the packet should
			 * be silently dropped, typically because we've asked
			 * key management for an SA.
			 */
			if (error == -EINVAL) /* Should silently drop packet */
			  error = 0;

			m_freem(m);
			goto done;
		}
	} else {
		/* Loop detection */
		for (mtag = m_tag_first(m); mtag != NULL;
		    mtag = m_tag_next(m, mtag)) {
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE)
				continue;
			tdbi = (struct tdb_ident *)(mtag + 1);
			if (tdbi->spi == tdb->tdb_spi &&
			    tdbi->proto == tdb->tdb_sproto &&
			    tdbi->rdomain == tdb->tdb_rdomain &&
			    !memcmp(&tdbi->dst, &tdb->tdb_dst,
			    sizeof(union sockaddr_union))) {
				sproto = 0; /* mark as no-IPsec-needed */
				goto done_spd;
a237 16

		/* We need to do IPsec */
		bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;

		/*
		 * If it needs TCP/UDP hardware-checksumming, do the
		 * computation now.
		 */
		in_proto_cksum_out(m, NULL);

		/* If it's not a multicast packet, try to fast-path */
		if (!IN_MULTICAST(ip->ip_dst.s_addr)) {
			goto sendit;
		}
a238 3

	/* Fall through to the routing/multicast handling code */
 done_spd:
d281 1
a281 1
		      (ifp->if_flags & IFF_BROADCAST) == 0)) && (sproto == 0)) {
d359 1
a359 1
	if ((sproto == 0) && ((dst->sin_addr.s_addr == INADDR_BROADCAST) ||
d392 1
a392 83
	if (sproto != 0) {
		tdb = gettdb(rtable_l2(m->m_pkthdr.ph_rtableid),
		    sspi, &sdst, sproto);
		if (tdb == NULL) {
			DPRINTF(("ip_output: unknown TDB"));
			error = EHOSTUNREACH;
			m_freem(m);
			goto done;
		}

		/*
		 * Packet filter
		 */
#if NPF > 0
		if ((encif = enc_getif(tdb->tdb_rdomain,
		    tdb->tdb_tap)) == NULL ||
		    pf_test(AF_INET, PF_OUT, encif, &m) != PF_PASS) {
			error = EACCES;
			m_freem(m);
			goto done;
		}
		if (m == NULL) {
			goto done;
		}
		ip = mtod(m, struct ip *);
		hlen = ip->ip_hl << 2;
		/*
		 * PF_TAG_REROUTE handling or not...
		 * Packet is entering IPsec so the routing is
		 * already overruled by the IPsec policy.
		 * Until now the change was not reconsidered.
		 * What's the behaviour?
		 */
		in_proto_cksum_out(m, encif);
#endif

		/* Check if we are allowed to fragment */
		if (ip_mtudisc && (ip->ip_off & htons(IP_DF)) && tdb->tdb_mtu &&
		    ntohs(ip->ip_len) > tdb->tdb_mtu &&
		    tdb->tdb_mtutimeout > time_second) {
			struct rtentry *rt = NULL;
			int rt_mtucloned = 0;
			int transportmode = 0;

			transportmode = (tdb->tdb_dst.sa.sa_family == AF_INET) &&
			    (tdb->tdb_dst.sin.sin_addr.s_addr ==
			    ip->ip_dst.s_addr);
			icmp_mtu = tdb->tdb_mtu;

			/* Find a host route to store the mtu in */
			if (ro != NULL)
				rt = ro->ro_rt;
			/* but don't add a PMTU route for transport mode SAs */
			if (transportmode)
				rt = NULL;
			else if (rt == NULL || (rt->rt_flags & RTF_HOST) == 0) {
				rt = icmp_mtudisc_clone(ip->ip_dst,
				    m->m_pkthdr.ph_rtableid);
				rt_mtucloned = 1;
			}
			DPRINTF(("ip_output: spi %08x mtu %d rt %p cloned %d\n",
			    ntohl(tdb->tdb_spi), icmp_mtu, rt, rt_mtucloned));
			if (rt != NULL) {
				rt->rt_rmx.rmx_mtu = icmp_mtu;
				if (ro && ro->ro_rt != NULL) {
					rtfree(ro->ro_rt);
					ro->ro_rt = rtalloc(&ro->ro_dst,
					    RT_RESOLVE,
					    m->m_pkthdr.ph_rtableid);
				}
				if (rt_mtucloned)
					rtfree(rt);
			}
			error = EMSGSIZE;
			goto bad;
		}

		/*
		 * Clear these -- they'll be set in the recursive invocation
		 * as needed.
		 */
		m->m_flags &= ~(M_MCAST | M_BCAST);

d394 2
a395 3
		error = ipsp_process_packet(m, tdb, AF_INET, 0);
		if_put(ifp);
		return error;  /* Nothing more to be done */
d458 2
a459 1
		icmp_mtu = ifp->if_mtu;
d503 4
d508 58
a565 2
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0 && m != NULL)
		ipsec_adjust_mtu(m, icmp_mtu);
d567 49
a615 2
	m_freem(m0);
	goto done;
d617 1
@


1.309
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.308 2015/11/26 10:36:20 mpi Exp $	*/
d504 1
a504 1
					    RT_REPORT|RT_RESOLVE,
d1446 1
a1446 2
			rt = rtalloc(sintosa(&sin), RT_REPORT|RT_RESOLVE,
			    rtableid);
d1457 1
a1457 1
			rt = rtalloc(sintosa(&sin), RT_REPORT, rtableid);
@


1.308
log
@Use rtalloc(9) to look for a local address (RTF_LOCAL) in ip_setmoptions().

This simplifies the if_get()/if_put() dance.

Tested by jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.307 2015/11/19 13:40:46 mpi Exp $	*/
d1045 1
a1045 1
			/* needs priviledges to switch when already set */
@


1.307
log
@Grab the KERNEL_LOCK around ip_mforward(), in preparation for unlocking
ip_output().

Note that ipmforwarding is not enabled by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.306 2015/11/11 10:23:23 mpi Exp $	*/
d1448 2
a1449 1
			if (rt == NULL) {
a1452 2
			ifp = rt->rt_ifp;
			rtfree(rt);
d1458 6
a1463 3
			ia = ifatoia(ifa_ifwithaddr(sintosa(&sin), rtableid));
			if (ia && in_hosteq(sin.sin_addr, ia->ia_addr.sin_addr))
				ifp = ia->ia_ifp;
d1465 3
d1474 1
d1490 1
d1521 1
d1532 1
d1536 1
@


1.306
log
@Store the index of the lo0 interface instead of a pointer to its
descriptor.

Allow to get rid of two if_ref() in the output paths.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.305 2015/11/03 21:11:48 naddy Exp $	*/
d371 6
a376 1
				if (ip_mforward(m, ifp) != 0) {
@


1.305
log
@Disable TCP/UDP TX hardware checksumming if an IPv4 packet contains
IP options or if an IPv6 packet contains header extensions.
Required by cnmac(4) and a sensible precautionary measure in general.
ok visa@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.304 2015/10/24 12:33:16 mpi Exp $	*/
d205 1
a205 1
			ifp = if_ref(lo0ifp);
@


1.304
log
@Convert some if_ref() to if_get().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.303 2015/10/20 20:22:42 benno Exp $	*/
d1756 2
a1760 1
		struct ip *ip;
a1762 1
		ip  = mtod(m, struct ip *);
d1782 1
a1782 1
		    ifp->if_bridgeport != NULL) {
d1789 1
a1789 1
		    ifp->if_bridgeport != NULL) {
@


1.303
log
@add a new getsockopt option IP_IPDEFTTL to retrieve the default ttl.
this can be used as an alternative to sysctl net.inet.ip.ttl, in
programs that use pledge().
ok reyk@@, "Like this" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.302 2015/10/19 12:10:05 mpi Exp $	*/
d207 1
a207 1
			ifp = if_ref(ro->ro_rt->rt_ifp);
@


1.302
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add a missing ``rtableid'' check in in_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.301 2015/10/13 10:16:17 mpi Exp $	*/
d1091 1
d1106 4
@


1.301
log
@Use rtisivalid(9) to check if the given (cached) route can be used.

Note that after calling rtalloc(9) we only check if a route has been
returned or not and do not check for its validity.  This cannot be
improved without a massive refactoring.

The kernel currently *do* use !RTF_UP route due to a mismatch between
the value of ifp->if_link_state and the IFF_UP|IFF_RUNNING code.

I'd explain the RTF_UP flag as follow:

.  If a cached route entry w/o RTF_UP is passed to ip{6,}_output(),
.  call rtalloc(9) to see if a better entry is present in the tree.

This is enough to support MPATH and route cache invalidation.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.300 2015/10/07 14:52:45 deraadt Exp $	*/
d591 2
a592 2
		if (ro->ro_rt != NULL &&
		    (ro->ro_rt->rt_flags & (RTF_UP | RTF_HOST)) &&
@


1.300
log
@easy size for free(); ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.299 2015/09/23 08:49:46 mpi Exp $	*/
d173 1
a173 1
	if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
d175 1
a175 1
	    ro->ro_tableid != m->m_pkthdr.ph_rtableid)) {
@


1.299
log
@Always increment rt_use inside rtalloc(9) instead of doing it in some
specific places.

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.298 2015/09/13 17:53:44 mpi Exp $	*/
d1495 3
a1497 1
					free(omships, M_IPMOPTS, 0);
@


1.298
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.297 2015/09/13 13:57:07 mpi Exp $	*/
a209 1
		ro->ro_rt->rt_use++;
@


1.297
log
@Get the default loopback interface pointer just after doing a route
lookup to ensure pf_test() is called with the same interface in the
input annd output path for local traffic.

Fix a regression reported by Heiko Zimmermann on bugs@@, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.296 2015/09/12 20:26:07 mpi Exp $	*/
d572 1
a572 1
		error = if_output(ifp, m, sintosa(dst), ro->ro_rt);
d612 1
a612 1
			error = if_output(ifp, m, sintosa(dst), ro->ro_rt);
@


1.296
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.295 2015/09/12 13:34:12 mpi Exp $	*/
d204 4
a207 1
		ifp = if_ref(ro->ro_rt->rt_ifp);
@


1.295
log
@Introduce if_input_local() a function to feed local traffic back to
the protocol queues.

It basically does what looutput() was doing but having a generic
function will allow us to get rid of the loopback hack overwwritting
the rt_ifp field of RTF_LOCAL routes.

ok mikeb@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.294 2015/09/12 11:40:04 claudio Exp $	*/
d569 1
a569 1
		error = (*ifp->if_output)(ifp, m, sintosa(dst), ro->ro_rt);
d609 1
a609 2
			error = (*ifp->if_output)(ifp, m, sintosa(dst),
			    ro->ro_rt);
d1662 1
a1662 3
 * packet to the input queue of a specified interface.  Note that this
 * calls the output routine of the loopback "driver", but with an interface
 * pointer that might NOT be &loif -- easier than replicating that code here.
@


1.294
log
@Fix two cases where it was possible to call if_put with an uninitialized ifp
Found by jsg@@ with clang
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.293 2015/09/11 19:17:47 claudio Exp $	*/
d1682 1
a1682 1
		(void) looutput(ifp, copym, sintosa(dst), NULL);
@


1.293
log
@if_put() after if_get for ip_output. This became suddenly super trivial.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.292 2015/09/11 18:48:50 claudio Exp $	*/
d92 1
a92 1
	struct ifnet *ifp;
d1620 1
a1623 1
		if_put(ifp);
@


1.292
log
@There is no need to do the route lookups twice just because of IPSec.
Merge the two blocks into one that is executed before the IPSec tdb lookup.
OK mpi@@ which had a sent out a similar diff around 3 years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.291 2015/09/03 14:59:23 mpi Exp $	*/
d204 1
a204 1
		ifp = ro->ro_rt->rt_ifp;
d515 1
d541 1
d621 1
d1623 1
@


1.291
log
@Revert (again!) the two uses of rtisvalid(9), they break NFS!

Found the hardway by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.290 2015/09/03 09:59:59 mpi Exp $	*/
d99 1
a99 1
	u_int8_t sproto = 0, donerouting = 0;
d152 4
d157 1
a157 3
	 * If we're missing the IP source address, do a route lookup. We'll
	 * remember this result, in case we don't need to do any IPsec
	 * processing on the packet. We need the source address so we can
d162 6
a167 2
	if (ip->ip_src.s_addr == INADDR_ANY) {
		donerouting = 1;
d169 10
a178 4
		if (ro == NULL) {
			ro = &iproute;
			memset(ro, 0, sizeof(*ro));
		}
d180 6
a185 1
		dst = satosin(&ro->ro_dst);
d187 9
a195 10
		/*
		 * If there is a cached route, check that it is to the same
		 * destination and is still up.  If not, free it and try again.
		 */
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
		    dst->sin_addr.s_addr != ip->ip_dst.s_addr ||
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid)) {
			rtfree(ro->ro_rt);
			ro->ro_rt = NULL;
		}
d198 3
a200 4
			dst->sin_family = AF_INET;
			dst->sin_len = sizeof(*dst);
			dst->sin_addr = ip->ip_dst;
			ro->ro_tableid = m->m_pkthdr.ph_rtableid;
d203 3
a205 3
		if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
		    (ip->ip_dst.s_addr == INADDR_BROADCAST)) &&
		    imo != NULL && (ifp = if_get(imo->imo_ifidx)) != NULL) {
d207 1
a207 21
			IFP_TO_IA(ifp, ia);
		} else {
			if (ro->ro_rt == NULL)
				ro->ro_rt = rtalloc_mpath(&ro->ro_dst,
				    NULL, ro->ro_tableid);

			if (ro->ro_rt == NULL) {
				ipstat.ips_noroute++;
				error = EHOSTUNREACH;
				goto bad;
			}

			ia = ifatoia(ro->ro_rt->rt_ifa);
			ifp = ro->ro_rt->rt_ifp;
			if ((mtu = ro->ro_rt->rt_rmx.rmx_mtu) == 0)
				mtu = ifp->if_mtu;
			ro->ro_rt->rt_use++;

			if (ro->ro_rt->rt_flags & RTF_GATEWAY)
				dst = satosin(ro->ro_rt->rt_gateway);
		}
d209 2
a210 3
		/* Set the source IP address */
		if (!IN_MULTICAST(ip->ip_dst.s_addr))
			ip->ip_src = ia->ia_addr.sin_addr;
d213 3
a215 3
#if NPF > 0
reroute:
#endif
a283 57
	if (donerouting == 0) {
		if (ro == NULL) {
			ro = &iproute;
			memset(ro, 0, sizeof(*ro));
		}

		dst = satosin(&ro->ro_dst);

		/*
		 * If there is a cached route, check that it is to the same
		 * destination and is still up.  If not, free it and try again.
		 */
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
		    dst->sin_addr.s_addr != ip->ip_dst.s_addr ||
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid)) {
			rtfree(ro->ro_rt);
			ro->ro_rt = NULL;
		}

		if (ro->ro_rt == NULL) {
			dst->sin_family = AF_INET;
			dst->sin_len = sizeof(*dst);
			dst->sin_addr = ip->ip_dst;
			ro->ro_tableid = m->m_pkthdr.ph_rtableid;
		}

		if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
		    (ip->ip_dst.s_addr == INADDR_BROADCAST)) &&
		    imo != NULL && (ifp = if_get(imo->imo_ifidx)) != NULL) {
			mtu = ifp->if_mtu;
			IFP_TO_IA(ifp, ia);
		} else {
			if (ro->ro_rt == NULL)
				ro->ro_rt = rtalloc_mpath(&ro->ro_dst,
				    &ip->ip_src.s_addr, ro->ro_tableid);

			if (ro->ro_rt == NULL) {
				ipstat.ips_noroute++;
				error = EHOSTUNREACH;
				goto bad;
			}

			ia = ifatoia(ro->ro_rt->rt_ifa);
			ifp = ro->ro_rt->rt_ifp;
			if ((mtu = ro->ro_rt->rt_rmx.rmx_mtu) == 0)
				mtu = ifp->if_mtu;
			ro->ro_rt->rt_use++;

			if (ro->ro_rt->rt_flags & RTF_GATEWAY)
				dst = satosin(ro->ro_rt->rt_gateway);
		}

		/* Set the source IP address */
		if (ip->ip_src.s_addr == INADDR_ANY)
			ip->ip_src = ia->ia_addr.sin_addr;
	}

a539 1
		donerouting = 0;
@


1.290
log
@Convert ip{,6}_output() (cached) route entry checks to rtisvalid(9).

This introduces a behavior change as we now reject !RTF_UP routes to
output packets.  This stricter check exposed a bug in the setup of
new routes and was the reason for the previous revert.  This should
be now fixed by r1.229 of sys/net/route.c .

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.289 2015/09/02 08:28:06 mpi Exp $	*/
d171 2
a172 3
		 * If there is a cached route, check that it is to the
		 * same destination and is still valid.  If not, free
		 * it and try again.
d174 1
a174 1
		if (!rtisvalid(ro->ro_rt) ||
d176 1
a176 1
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid) {
d198 1
a198 3
			if (!rtisvalid(ro->ro_rt)) {
				rtfree(ro->ro_rt);
				ro->ro_rt = NULL;
d299 2
a300 3
		 * If there is a cached route, check that it is to the
		 * same destination and is still valid.  If not, free
		 * it and try again.
d302 1
a302 1
		if (!rtisvalid(ro->ro_rt) ||
d304 1
a304 1
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid) {
d326 1
a326 3
			if (!rtisvalid(ro->ro_rt)) {
				rtfree(ro->ro_rt);
				ro->ro_rt = NULL;
@


1.289
log
@Revert the two uses of rtisvalid(9) for the moment, it breaks dhclient(8)
configured networks on RAMDISK kernels.

The problem is that the default route installed by dhclient(8) does not
have the RTF_UP flag in this environement and rtisvalid(9) doesn't allow
you to use a RTF_DOWN route.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.288 2015/09/01 14:33:15 mpi Exp $	*/
d171 3
a173 2
		 * If there is a cached route, check that it is to the same
		 * destination and is still up.  If not, free it and try again.
d175 1
a175 1
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
d177 1
a177 1
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid)) {
d199 3
a201 1
			if (ro->ro_rt == NULL) {
d302 3
a304 2
		 * If there is a cached route, check that it is to the same
		 * destination and is still up.  If not, free it and try again.
d306 1
a306 1
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
d308 1
a308 1
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid)) {
d330 3
a332 1
			if (ro->ro_rt == NULL) {
@


1.288
log
@Convert ip{,6}_output() (cached) route entry checks to rtisvalid(9).

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.287 2015/08/31 07:17:12 mpi Exp $	*/
d171 2
a172 3
		 * If there is a cached route, check that it is to the
		 * same destination and is still valid.  If not, free
		 * it and try again.
d174 1
a174 1
		if (!rtisvalid(ro->ro_rt) ||
d176 1
a176 1
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid) {
d198 1
a198 3
			if (!rtisvalid(ro->ro_rt)) {
				rtfree(ro->ro_rt);
				ro->ro_rt = NULL;
d299 2
a300 3
		 * If there is a cached route, check that it is to the
		 * same destination and is still valid.  If not, free
		 * it and try again.
d302 1
a302 1
		if (!rtisvalid(ro->ro_rt) ||
d304 1
a304 1
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid) {
d326 1
a326 3
			if (!rtisvalid(ro->ro_rt)) {
				rtfree(ro->ro_rt);
				ro->ro_rt = NULL;
@


1.287
log
@`encif' should only be used under #ifdef NPF.

Reported by jsg@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.286 2015/07/16 21:14:21 mpi Exp $	*/
d171 3
a173 2
		 * If there is a cached route, check that it is to the same
		 * destination and is still up.  If not, free it and try again.
d175 1
a175 1
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
d177 1
a177 1
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid)) {
d199 3
a201 1
			if (ro->ro_rt == NULL) {
d302 3
a304 2
		 * If there is a cached route, check that it is to the same
		 * destination and is still up.  If not, free it and try again.
d306 1
a306 1
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
d308 1
a308 1
		    ro->ro_tableid != m->m_pkthdr.ph_rtableid)) {
d330 3
a332 1
			if (ro->ro_rt == NULL) {
@


1.286
log
@Kill IP_ROUTETOETHER.

This pseudo-option is a hack to support return-rst on bridge(4).  It
passes Ethernet information via a "struct route" through ip_output().

"struct route" is slowly dying...

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.285 2015/07/15 22:16:42 deraadt Exp $	*/
d526 1
a527 1
		in_proto_cksum_out(m, encif);
@


1.285
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.284 2015/06/30 15:30:17 mpi Exp $	*/
a160 4
		if (flags & IP_ROUTETOETHER) {
			error = EINVAL;
			goto bad;
		}
d290 1
a290 6
	if (flags & IP_ROUTETOETHER) {
		dst = satosin(&ro->ro_dst);
		ifp = ro->ro_rt->rt_ifp;
		mtu = ifp->if_mtu;
		ro->ro_rt = NULL;
	} else if (donerouting == 0) {
d509 1
a509 1
		    pf_test(AF_INET, PF_OUT, encif, &m, NULL) != PF_PASS) {
d586 1
a586 1
	if (pf_test(AF_INET, PF_OUT, ifp, &m, NULL) != PF_PASS) {
@


1.284
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.283 2015/06/16 11:09:40 mpi Exp $	*/
d921 1
a921 1
		if (op == PRCO_SETOPT && *mp)
@


1.283
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.282 2015/06/07 01:25:27 krw Exp $	*/
d765 1
a765 1
		m->m_next = m_copy(m0, off, len);
@


1.282
log
@Replace a bunch of == 0 with == NULL in pointer tests. Nuke some
annoying trailing, leading and embedded whitespace. No change to
.o files.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.281 2015/05/23 12:52:59 markus Exp $	*/
d772 1
a772 1
		m->m_pkthdr.rcvif = (struct ifnet *)0;
@


1.281
log
@remove PACKET_TAG_IPSEC_PENDING_TDB, it is never set; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.280 2015/05/13 10:42:46 jsg Exp $	*/
d167 1
a167 1
		if (ro == 0) {
d185 1
a185 1
		if (ro->ro_rt == 0) {
d198 1
a198 1
			if (ro->ro_rt == 0)
d202 1
a202 1
			if (ro->ro_rt == 0) {
d300 1
a300 1
		if (ro == 0) {
d318 1
a318 1
		if (ro->ro_rt == 0) {
d331 1
a331 1
			if (ro->ro_rt == 0)
d335 1
a335 1
			if (ro->ro_rt == 0) {
d1298 1
a1298 1
	if (m == (struct mbuf *)NULL || m->m_len == 0) {
d1368 1
a1368 1
			    sizeof(struct in_addr)),			    
@


1.280
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.279 2015/04/17 11:04:01 mikeb Exp $	*/
d232 2
a233 17
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_PENDING_TDB, NULL);
	if (mtag != NULL) {
#ifdef DIAGNOSTIC
		if (mtag->m_tag_len != sizeof (struct tdb_ident))
			panic("ip_output: tag of length %hu (should be %zu",
			    mtag->m_tag_len, sizeof (struct tdb_ident));
#endif
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->rdomain,
		    tdbi->spi, &tdbi->dst, tdbi->proto);
		if (tdb == NULL)
			error = -EINVAL;
		m_tag_delete(m, mtag);
	}
	else
		tdb = ipsp_spd_lookup(m, AF_INET, hlen, &error,
		    IPSP_DIRECTION_OUT, NULL, inp, ipsecflowinfo);
@


1.279
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.278 2015/04/16 19:24:13 markus Exp $	*/
d753 1
a753 1
		if (m == 0) {
d851 1
a851 1
		if (n == 0)
d1025 1
a1025 1
			if (m == 0 || m->m_len != sizeof(int))
d1061 1
a1061 1
			if (m == 0 || m->m_len != sizeof(int)) {
d1313 1
a1313 1
	if (m == (struct mbuf *)0 || m->m_len == 0) {
@


1.278
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.277 2015/04/14 12:22:15 mikeb Exp $	*/
d275 1
a275 3
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE &&
			    mtag->m_tag_id !=
			    PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED)
a602 12
	}

	/*
	 * If we got here and IPsec crypto processing didn't happen, drop it.
	 */
	if (ipsec_in_use && (mtag = m_tag_find(m,
	    PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL)) != NULL) {
		/* Notify IPsec to do its own crypto. */
		ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
		m_freem(m);
		error = EHOSTUNREACH;
		goto done;
@


1.277
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.276 2014/12/17 09:57:13 mpi Exp $	*/
a944 5
#ifdef IPSEC
	struct ipsec_ref *ipr;
	size_t iprlen;
	u_int16_t opt16val;
#endif
a1086 15
			/* Unlink cached output TDB to force a re-search */
			if (inp->inp_tdb_out) {
				int s = splsoftnet();
				TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out,
				    inp, inp_tdb_out_next);
				splx(s);
			}

			if (inp->inp_tdb_in) {
				int s = splsoftnet();
				TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in,
				    inp, inp_tdb_in_next);
				splx(s);
			}

a1122 2
			if (!error)
				inp->inp_secrequire = get_sa_require(inp);
a1127 1
#ifndef IPSEC
a1128 104
#else
			if (m == NULL || m->m_len < 2) {
				error = EINVAL;
				break;
			}

			m_copydata(m, 0, 2, (caddr_t) &opt16val);

			/* If the type is 0, then we cleanup and return */
			if (opt16val == 0) {
				switch (optname) {
				case IP_IPSEC_LOCAL_ID:
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_srcid != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_srcid);
						inp->inp_ipo->ipo_srcid = NULL;
					}
					break;
				case IP_IPSEC_REMOTE_ID:
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_dstid != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_dstid);
						inp->inp_ipo->ipo_dstid = NULL;
					}
					break;
				}

				error = 0;
				break;
			}

			/* Can't have an empty payload */
			if (m->m_len == 2) {
				error = EINVAL;
				break;
			}

			/* Allocate if needed */
			if (inp->inp_ipo == NULL) {
				inp->inp_ipo = ipsec_add_policy(inp,
				    AF_INET, IPSP_DIRECTION_OUT);
				if (inp->inp_ipo == NULL) {
					error = ENOBUFS;
					break;
				}
			}

			iprlen = sizeof(struct ipsec_ref) + m->m_len - 2;
			ipr = malloc(iprlen, M_CREDENTIALS, M_NOWAIT);
			if (ipr == NULL) {
				error = ENOBUFS;
				break;
			}

			ipr->ref_count = 1;
			ipr->ref_malloctype = M_CREDENTIALS;
			ipr->ref_len = m->m_len - 2;
			ipr->ref_type = opt16val;
			m_copydata(m, 2, m->m_len - 2, (caddr_t)(ipr + 1));

			switch (optname) {
			case IP_IPSEC_LOCAL_ID:
				/* Check valid types and NUL-termination */
				if (ipr->ref_type < IPSP_IDENTITY_PREFIX ||
				    ipr->ref_type > IPSP_IDENTITY_CONNECTION ||
				    ((char *)(ipr + 1))[ipr->ref_len - 1]) {
					free(ipr, M_CREDENTIALS, iprlen);
					error = EINVAL;
				} else {
					if (inp->inp_ipo->ipo_srcid != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_srcid);
					inp->inp_ipo->ipo_srcid = ipr;
				}
				break;
			case IP_IPSEC_REMOTE_ID:
				/* Check valid types and NUL-termination */
				if (ipr->ref_type < IPSP_IDENTITY_PREFIX ||
				    ipr->ref_type > IPSP_IDENTITY_CONNECTION ||
				    ((char *)(ipr + 1))[ipr->ref_len - 1]) {
					free(ipr, M_CREDENTIALS, iprlen);
					error = EINVAL;
				} else {
					if (inp->inp_ipo->ipo_dstid != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_dstid);
					inp->inp_ipo->ipo_dstid = ipr;
				}
				break;
			}

			/* Unlink cached output TDB to force a re-search */
			if (inp->inp_tdb_out) {
				int s = splsoftnet();
				TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out,
				    inp, inp_tdb_out_next);
				splx(s);
			}

			if (inp->inp_tdb_in) {
				int s = splsoftnet();
				TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in,
				    inp, inp_tdb_in_next);
				splx(s);
			}
#endif
a1289 1
#ifndef IPSEC
a1290 43
#else
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
			m->m_len = sizeof(u_int16_t);
			ipr = NULL;
			switch (optname) {
			case IP_IPSEC_LOCAL_ID:
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_srcid;
				opt16val = IPSP_IDENTITY_NONE;
				break;
			case IP_IPSEC_REMOTE_ID:
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_dstid;
				opt16val = IPSP_IDENTITY_NONE;
				break;
			}
			if (ipr == NULL)
				*mtod(m, u_int16_t *) = opt16val;
			else {
				size_t len;

				len = m->m_len + ipr->ref_len;
				if (len > MCLBYTES) {
					 m_free(m);
					 error = EINVAL;
					 break;
				}
				/* allocate mbuf cluster for larger option */
				if (len > MLEN) {
					 MCLGET(m, M_WAITOK);
					 if ((m->m_flags & M_EXT) == 0) {
						 m_free(m);
						 error = ENOBUFS;
						 break;
					 }

				}
				m->m_len = len;
				*mtod(m, u_int16_t *) = ipr->ref_type;
				m_copyback(m, sizeof(u_int16_t), ipr->ref_len,
				    ipr + 1, M_NOWAIT);
			}
#endif
@


1.276
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.275 2014/12/17 09:45:59 mpi Exp $	*/
a1147 6
		case IP_IPSEC_REMOTE_CRED:
		case IP_IPSEC_REMOTE_AUTH:
			/* Can't set the remote credential or key */
			error = EOPNOTSUPP;
			break;

a1149 2
		case IP_IPSEC_LOCAL_CRED:
		case IP_IPSEC_LOCAL_AUTH:
a1169 1

a1176 16

				case IP_IPSEC_LOCAL_CRED:
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_local_cred != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_local_cred);
						inp->inp_ipo->ipo_local_cred = NULL;
					}
					break;

				case IP_IPSEC_LOCAL_AUTH:
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_local_auth != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_local_auth);
						inp->inp_ipo->ipo_local_auth = NULL;
					}
					break;
a1238 22
			case IP_IPSEC_LOCAL_CRED:
				if (ipr->ref_type < IPSP_CRED_KEYNOTE ||
				    ipr->ref_type > IPSP_CRED_X509) {
					free(ipr, M_CREDENTIALS, iprlen);
					error = EINVAL;
				} else {
					if (inp->inp_ipo->ipo_local_cred != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_local_cred);
					inp->inp_ipo->ipo_local_cred = ipr;
				}
				break;
			case IP_IPSEC_LOCAL_AUTH:
				if (ipr->ref_type < IPSP_AUTH_PASSPHRASE ||
				    ipr->ref_type > IPSP_AUTH_RSA) {
					free(ipr, M_CREDENTIALS, iprlen);
					error = EINVAL;
				} else {
					if (inp->inp_ipo->ipo_local_auth != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_local_auth);
					inp->inp_ipo->ipo_local_auth = ipr;
				}
				break;
a1416 4
		case IP_IPSEC_LOCAL_CRED:
		case IP_IPSEC_REMOTE_CRED:
		case IP_IPSEC_LOCAL_AUTH:
		case IP_IPSEC_REMOTE_AUTH:
a1432 18
				break;
			case IP_IPSEC_LOCAL_CRED:
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_local_cred;
				opt16val = IPSP_CRED_NONE;
				break;
			case IP_IPSEC_REMOTE_CRED:
				ipr = inp->inp_ipsec_remotecred;
				opt16val = IPSP_CRED_NONE;
				break;
			case IP_IPSEC_LOCAL_AUTH:
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_local_auth;
				opt16val = IPSP_AUTH_NONE;
				break;
			case IP_IPSEC_REMOTE_AUTH:
				ipr = inp->inp_ipsec_remoteauth;
				opt16val = IPSP_AUTH_NONE;
@


1.275
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.274 2014/12/08 10:51:00 mpi Exp $	*/
d391 1
a391 1
			ip->ip_ttl = imo->imo_multicast_ttl;
d431 1
a431 1
		   (imo == NULL || imo->imo_multicast_loop)) {
d1681 2
a1682 2
		imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
		imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
d1735 1
a1735 1
		imo->imo_multicast_ttl = *(mtod(m, u_char *));
d1748 1
a1748 1
		imo->imo_multicast_loop = loop;
d1925 2
a1926 2
	    imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
	    imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
d1968 1
a1968 1
				     : imo->imo_multicast_ttl;
d1975 1
a1975 1
				      : imo->imo_multicast_loop;
@


1.274
log
@Do not use a "struct route" when a "struct rtentry" is enough.

ok millert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.273 2014/12/05 15:50:04 mpi Exp $	*/
d194 1
a194 2
		    imo != NULL && imo->imo_multicast_ifp != NULL) {
			ifp = imo->imo_multicast_ifp;
d344 1
a344 2
		    imo != NULL && imo->imo_multicast_ifp != NULL) {
			ifp = imo->imo_multicast_ifp;
d1680 1
a1680 1
		imo->imo_multicast_ifp = NULL;
d1705 1
a1705 1
			imo->imo_multicast_ifp = NULL;
d1724 1
a1724 1
		imo->imo_multicast_ifp = ifp;
d1924 1
a1924 1
	if (imo->imo_multicast_ifp == NULL &&
d1946 1
d1955 1
a1955 1
		if (imo == NULL || imo->imo_multicast_ifp == NULL)
d1958 1
a1958 1
			IFP_TO_IA(imo->imo_multicast_ifp, ia);
@


1.273
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.272 2014/11/20 15:55:04 tedu Exp $	*/
d1667 2
a1668 2
	struct route ro;
	struct sockaddr_in *dst, sin;
d1772 7
a1778 10
			ro.ro_rt = NULL;
			dst = satosin(&ro.ro_dst);
			dst->sin_len = sizeof(*dst);
			dst->sin_family = AF_INET;
			dst->sin_addr = mreq->imr_multiaddr;
			if (!(ro.ro_rt && ro.ro_rt->rt_ifp &&
			    (ro.ro_rt->rt_flags & RTF_UP)))
				ro.ro_rt = rtalloc(&ro.ro_dst,
				    RT_REPORT|RT_RESOLVE, rtableid);
			if (ro.ro_rt == NULL) {
d1782 2
a1783 2
			ifp = ro.ro_rt->rt_ifp;
			rtfree(ro.ro_rt);
@


1.272
log
@sizes for simple free cases. sizeof(*) and one case where len is clear.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.271 2014/11/05 14:03:02 mpi Exp $	*/
d47 1
@


1.271
log
@Kill in_iawithaddr() and use ifa_ifwithaddr() directly.

Note that ifa_ifwithaddr() might return a broadcast address, so if you
don't want one make sure to filter them out.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.270 2014/11/01 21:40:38 mpi Exp $	*/
d948 1
d1225 2
a1226 2
			ipr = malloc(sizeof(struct ipsec_ref) + m->m_len - 2,
			       M_CREDENTIALS, M_NOWAIT);
d1244 1
a1244 1
					free(ipr, M_CREDENTIALS, 0);
d1257 1
a1257 1
					free(ipr, M_CREDENTIALS, 0);
d1268 1
a1268 1
					free(ipr, M_CREDENTIALS, 0);
d1279 1
a1279 1
					free(ipr, M_CREDENTIALS, 0);
d1676 1
a1676 2
		imo = (struct ip_moptions *)malloc(sizeof(*imo), M_IPMOPTS,
		    M_WAITOK|M_ZERO);
d1933 1
a1933 1
		free(*imop, M_IPMOPTS, 0);
d1998 1
a1998 1
		free(imo, M_IPMOPTS, 0);
@


1.270
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.269 2014/10/14 09:52:26 mpi Exp $	*/
a1658 3
	int error = 0;
	u_char loop;
	int i;
d1666 3
a1668 1
	struct sockaddr_in *dst;
d1714 6
a1719 2
		ia = in_iawithaddr(addr, rtableid);
		if (ia)
d1787 6
a1792 2
			ia = in_iawithaddr(mreq->imr_interface, rtableid);
			if (ia)
d1880 8
a1887 2
			ia = in_iawithaddr(mreq->imr_interface, rtableid);
			if (ia == NULL) {
a1890 1
			ifp = ia->ia_ifp;
@


1.269
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.268 2014/10/08 07:33:42 mpi Exp $	*/
d586 2
a587 1
					ro->ro_rt = rtalloc1(&ro->ro_dst, RT_REPORT,
d1775 2
a1776 2
				ro.ro_rt = rtalloc1(&ro.ro_dst, RT_REPORT,
				    rtableid);
@


1.268
log
@Check if the outgoing route is associated to a broadcast address instead
of doing a lookup on all the addresses of the outgoing interface.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.267 2014/09/27 12:26:16 mpi Exp $	*/
d180 2
a181 2
			RTFREE(ro->ro_rt);
			ro->ro_rt = (struct rtentry *)0;
d331 2
a332 2
			RTFREE(ro->ro_rt);
			ro->ro_rt = (struct rtentry *)0;
d585 1
a585 1
					RTFREE(ro->ro_rt);
d720 1
a720 1
		RTFREE(ro->ro_rt);
@


1.267
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.266 2014/07/22 11:06:10 mpi Exp $	*/
d487 2
a488 2
	if ((sproto == 0) && (in_broadcast(dst->sin_addr, ifp,
	    m->m_pkthdr.ph_rtableid))) {
@


1.266
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.265 2014/07/12 18:44:23 tedu Exp $	*/
d199 2
a200 1
				rtalloc_mpath(ro, NULL);
d350 2
a351 1
				rtalloc_mpath(ro, &ip->ip_src.s_addr);
@


1.265
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.264 2014/07/11 15:25:44 henning Exp $	*/
a50 1
#include <netinet/in_systm.h>
@


1.264
log
@in_proto_cksum_out: zero the icmp cksum before going on so that we do not
require the caller to do so. lteo needs that for divert soon, and is in line
with tcp/udp and the general approach that the rest of the stack should not
need to do anything regarding the cksums but setting the "needs it" flag.
ok lteo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.263 2014/04/21 12:22:26 henning Exp $	*/
d1241 1
a1241 1
					free(ipr, M_CREDENTIALS);
d1254 1
a1254 1
					free(ipr, M_CREDENTIALS);
d1265 1
a1265 1
					free(ipr, M_CREDENTIALS);
d1276 1
a1276 1
					free(ipr, M_CREDENTIALS);
d1828 1
a1828 1
					free(omships, M_IPMOPTS);
d1918 2
a1919 2
		free(imo->imo_membership , M_IPMOPTS);
		free(*imop, M_IPMOPTS);
d1983 2
a1984 2
		free(imo->imo_membership, M_IPMOPTS);
		free(imo, M_IPMOPTS);
@


1.263
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.262 2014/04/20 09:38:19 henning Exp $	*/
d2078 2
a2079 1
	if (m->m_pkthdr.csum_flags & (M_TCP_CSUM_OUT|M_UDP_CSUM_OUT)) {
d2081 1
a2081 1
		u_int16_t csum, offset;
d2085 4
a2088 2
		csum = in_cksum_phdr(ip->ip_src.s_addr, ip->ip_dst.s_addr,
		    htonl(ntohs(ip->ip_len) - offset + ip->ip_p));
d2093 2
@


1.262
log
@move in_cksum_phdr from in.h (under #ifdef _KERNEL, at least) to ip_output.c
nothing except in_proto_cksum_out() uses it any more, and that's a good
thing. was on tech for 3 months, discussed with many
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.260 2014/04/07 10:04:17 mpi Exp $	*/
d89 1
a89 1
    struct ip_moptions *imo, struct inpcb *inp, ...)
a108 1
	u_int32_t ipsecflowinfo = 0;
a116 6
	if (flags & IP_IPSECFLOW) {
		va_list ap;
		va_start(ap, inp);
		ipsecflowinfo = va_arg(ap, u_int32_t);
		va_end(ap);
	}
@


1.261
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d77 2
d2018 23
@


1.260
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.258 2014/03/27 13:27:28 mpi Exp $	*/
d185 1
a185 1
		    ro->ro_tableid != m->m_pkthdr.rdomain)) {
d194 1
a194 1
			ro->ro_tableid = m->m_pkthdr.rdomain;
d335 1
a335 1
		    ro->ro_tableid != m->m_pkthdr.rdomain)) {
d344 1
a344 1
			ro->ro_tableid = m->m_pkthdr.rdomain;
d492 1
a492 1
	    m->m_pkthdr.rdomain))) {
d525 1
a525 1
		tdb = gettdb(rtable_l2(m->m_pkthdr.rdomain),
d581 1
a581 1
				    m->m_pkthdr.rdomain);
d591 1
a591 1
					    m->m_pkthdr.rdomain);
d781 1
a781 1
		/* we must inherit MCAST and BCAST flags and rdomain */
d783 1
a783 1
		m->m_pkthdr.rdomain = m0->m_pkthdr.rdomain;
@


1.259
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.257 2014/01/23 23:51:29 henning Exp $	*/
d197 1
a197 17
		/*
		 * If routing to interface only, short-circuit routing lookup.
		 */
		if (flags & IP_ROUTETOIF) {
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst),
			    m->m_pkthdr.rdomain))) == 0 &&
			    (ia = ifatoia(ifa_ifwithnet(sintosa(dst),
			    m->m_pkthdr.rdomain))) == 0) {
				ipstat.ips_noroute++;
				error = ENETUNREACH;
				goto bad;
			}

			ifp = ia->ia_ifp;
			mtu = ifp->if_mtu;
			ip->ip_ttl = 1;
		} else if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
d347 1
a347 17
		/*
		 * If routing to interface only, short-circuit routing lookup.
		 */
		if (flags & IP_ROUTETOIF) {
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst),
			    m->m_pkthdr.rdomain))) == 0 &&
			    (ia = ifatoia(ifa_ifwithnet(sintosa(dst),
			    m->m_pkthdr.rdomain))) == 0) {
				ipstat.ips_noroute++;
				error = ENETUNREACH;
				goto bad;
			}

			ifp = ia->ia_ifp;
			mtu = ifp->if_mtu;
			ip->ip_ttl = 1;
		} else if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
d723 1
a723 1
	if (ro == &iproute && (flags & IP_ROUTETOIF) == 0 && ro->ro_rt)
@


1.258
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d197 17
a213 1
		if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
d363 17
a379 1
		if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
d755 1
a755 1
	if (ro == &iproute && ro->ro_rt)
@


1.257
log
@since the cksum rewrite the counters for hardware checksummed packets
are are lie, since the software engine emulates hardware offloading
and that is later indistinguishable. so kill the hw cksummed counters.
introduce software checksummed packet counters instead.
tcp/udp handles ip & ipvshit, ip cksum covered, 6 has no ip layer cksum.
as before we still have a miscounting bug for inbound with pf on, to be
fixed in the next step.
found by, prodding & ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.255 2014/01/21 10:18:26 mpi Exp $	*/
d197 1
a197 17
		/*
		 * If routing to interface only, short-circuit routing lookup.
		 */
		if (flags & IP_ROUTETOIF) {
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst),
			    m->m_pkthdr.rdomain))) == 0 &&
			    (ia = ifatoia(ifa_ifwithnet(sintosa(dst),
			    m->m_pkthdr.rdomain))) == 0) {
				ipstat.ips_noroute++;
				error = ENETUNREACH;
				goto bad;
			}

			ifp = ia->ia_ifp;
			mtu = ifp->if_mtu;
			ip->ip_ttl = 1;
		} else if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
d347 1
a347 17
		/*
		 * If routing to interface only, short-circuit routing lookup.
		 */
		if (flags & IP_ROUTETOIF) {
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst),
			    m->m_pkthdr.rdomain))) == 0 &&
			    (ia = ifatoia(ifa_ifwithnet(sintosa(dst),
			    m->m_pkthdr.rdomain))) == 0) {
				ipstat.ips_noroute++;
				error = ENETUNREACH;
				goto bad;
			}

			ifp = ia->ia_ifp;
			mtu = ifp->if_mtu;
			ip->ip_ttl = 1;
		} else if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
d723 1
a723 1
	if (ro == &iproute && (flags & IP_ROUTETOIF) == 0 && ro->ro_rt)
@


1.256
log
@put the in{,6}_delayed_cksum() and in{,6}_proto_cksum_out() prototypes
into consistent locations; ok henning@@
@
text
@d698 1
a698 1
		    (ifp->if_bridgeport == NULL)) {
d700 2
a701 2
			ipstat.ips_outhwcsum++;
		} else
d703 2
a704 5
		/* Update relevant hardware checksum stats for TCP/UDP */
		if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT)
			tcpstat.tcps_outhwcsum++;
		else if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT)
			udpstat.udps_outhwcsum++;
d842 1
a842 1
		    (ifp->if_bridgeport == NULL)) {
d844 2
a845 2
			ipstat.ips_outhwcsum++;
		} else
d847 1
d863 1
a863 1
	    (ifp->if_bridgeport == NULL)) {
d865 2
a866 2
		ipstat.ips_outhwcsum++;
	} else
d868 1
d2113 1
d2120 1
@


1.255
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.254 2014/01/09 06:29:06 tedu Exp $	*/
d77 1
@


1.254
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.253 2013/12/17 02:41:07 matthew Exp $	*/
d1836 2
a1837 1
			if (imo->imo_membership[i]->inm_ifp == ifp &&
d1920 2
a1921 1
			     imo->imo_membership[i]->inm_ifp == ifp) &&
@


1.253
log
@Change ip_output()'s non-optional arguments to be standard arguments
instead of variable arguments.

Allows stricter type checking by the compiler at call sites and also
saves a bit of code size on some platforms (e.g., ~200 bytes on
amd64).

ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.252 2013/12/04 16:27:56 mikeb Exp $	*/
d173 1
a173 1
			bzero((caddr_t)ro, sizeof (*ro));
d303 1
a303 1
			    !bcmp(&tdbi->dst, &tdb->tdb_dst,
d339 1
a339 1
			bzero((caddr_t)ro, sizeof (*ro));
d1625 1
a1625 1
	bzero(mtod(m, caddr_t), sizeof(struct in_addr));
@


1.252
log
@ifp must be initialized in ip_setmoptions;  from oga via mpi, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.251 2013/11/27 08:37:08 mpi Exp $	*/
d85 2
a86 1
ip_output(struct mbuf *m0, ...)
a95 5
	struct mbuf *opt;
	struct route *ro;
	int flags;
	struct ip_moptions *imo;
	va_list ap;
a104 1
	struct inpcb *inp;
d106 1
a106 1
	u_int32_t ipsecflowinfo;
a111 5
	va_start(ap, m0);
	opt = va_arg(ap, struct mbuf *);
	ro = va_arg(ap, struct route *);
	flags = va_arg(ap, int);
	imo = va_arg(ap, struct ip_moptions *);
a112 1
	inp = va_arg(ap, struct inpcb *);
d115 6
a120 1
	ipsecflowinfo = (flags & IP_IPSECFLOW) ? va_arg(ap, u_int32_t) : 0;
a121 1
	va_end(ap);
@


1.251
log
@Replace INADDR_TO_IFP() by in_iawithaddr() and kill the macro.

ok mikeb@@, ports@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.250 2013/10/25 18:44:36 lteo Exp $	*/
d1707 1
a1707 1
	struct ifnet *ifp;
@


1.250
log
@Don't let in_proto_cksum_out() assume that the ICMP checksum field is
always in the first mbuf of an mbuf chain.

Thanks to henning@@ and bluhm@@ for their work on checksums at b2k13,
which allowed this fix to be very straightforward compared to earlier
versions.

help/feedback bluhm@@ henning@@
OK henning@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.249 2013/10/20 13:44:23 henning Exp $	*/
d1705 1
d1757 3
a1759 1
		INADDR_TO_IFP(addr, ifp, rtableid);
d1826 3
a1828 1
			INADDR_TO_IFP(mreq->imr_interface, ifp, rtableid);
d1914 2
a1915 2
			INADDR_TO_IFP(mreq->imr_interface, ifp, rtableid);
			if (ifp == NULL) {
d1919 1
@


1.249
log
@no need to make the icmp cksum "offloading" case special insofar that the
cksum needs to be 0'd before, pf does that now (just like in the tcp/udp
case) and nothing else uses the icmp "offloading" yet.
with & ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.246 2013/08/08 14:29:29 mpi Exp $	*/
d2073 4
d2122 1
a2122 8
		struct ip *ip = mtod(m, struct ip *);
		int hlen;
		struct icmp *icp;

		hlen = ip->ip_hl << 2;
		icp = (struct icmp *)(mtod(m, caddr_t) + hlen);
		icp->icmp_cksum = in4_cksum(m, 0, hlen,
		    ntohs(ip->ip_len) - hlen);
@


1.248
log
@make in_proto_cksum_out not rely on the pseudo header checksum to be
already there, just compute it - it's dirt cheap. since that happens
very late in ip_output, the rest of the stack doesn't have to care about
checksums at all any more, if something needs to be checksummed, just
set the flag on the pkthdr mbuf to indicate so.
stop pre-computing the pseudo header checksum and incrementally updating it
in the tcp and udp stacks.
ok lteo florian
@
text
@a2123 1
		icp->icmp_cksum = 0;
@


1.247
log
@Abstract the fact that IPv4 muticast records are linked to the
interface descriptor throught the first configured address in the
global list, this will help reducing the size of future diffs.

No object change.

ok sthen@@
@
text
@d2086 19
@


1.246
log
@Change MTU discovery functions to not abuse the global icmpsrc variable
to pass the destination address of the route to clone.

ok markus@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.245 2013/08/08 07:28:08 mpi Exp $	*/
d1838 1
a1838 1
			if (imo->imo_membership[i]->inm_ia->ia_ifp == ifp &&
d1920 1
a1920 1
			     imo->imo_membership[i]->inm_ia->ia_ifp == ifp) &&
@


1.245
log
@Make use of IFP_TO_IA() instead of rolling our own copy, no functional
change.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.244 2013/07/31 15:41:52 mikeb Exp $	*/
d618 1
a618 4
				struct sockaddr_in dst = {
					sizeof(struct sockaddr_in), AF_INET};
				dst.sin_addr = ip->ip_dst;
				rt = icmp_mtudisc_clone((struct sockaddr *)&dst,
@


1.244
log
@Move bridge_broadcast and subsequently all IPsec SPD lookup code out
of the IPL_NET.  pf_test should be no longer called under IPL_NET as
well.  The problem became evident after the related issue was brought
up by David Hill <dhill at mindcry ! org>.

With input from and OK mpi.  Tested by David and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.243 2013/07/04 19:10:40 sf Exp $	*/
d467 3
a469 7
			struct in_ifaddr *ia;

			TAILQ_FOREACH(ia, &in_ifaddr, ia_list)
				if (ia->ia_ifp == ifp) {
					ip->ip_src = ia->ia_addr.sin_addr;
					break;
				}
@


1.243
log
@format string fixes: size_t and uint16_t

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.242 2013/06/26 09:12:40 henning Exp $	*/
a111 1
	int s;
a257 6
	/*
	 * splnet is chosen over splsoftnet because we are not allowed to
	 * lower the level, and udp_output calls us in splnet().
	 */
	s = splnet();

a277 2
		splx(s);

a311 1
				splx(s);
a320 1
		splx(s);
a566 2
		s = splnet();

a571 1
			splx(s);
a583 1
			splx(s);
a587 1
			splx(s);
a613 1
			splx(s);
a652 1
		splx(s);
@


1.242
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.241 2013/06/11 18:15:53 deraadt Exp $	*/
d270 1
a270 1
			panic("ip_output: tag of length %d (should be %d",
@


1.241
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.240 2013/06/05 02:25:05 lteo Exp $	*/
d616 1
a686 2
	in_proto_cksum_out(m, ifp);

d712 1
@


1.240
log
@Calculate ICMP checksums with in4_cksum() which lets us get rid of the
clunky m_data/m_len dance needed by in_cksum().

Tested on amd64, hppa, i386, loongson, macppc, sgi, and sparc64.

Thanks to blambert@@, bluhm@@, and henning@@ for help and feedback;
abieber@@ for testing this diff independently on macppc; krw@@ for access
to his hppa, sgi, and sparc64 test systems at t2k13; nick@@ for helping
me figure out Ken's hppa so that I can test this diff. :)

ok blambert bluhm henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.239 2013/04/24 12:34:15 mpi Exp $	*/
d948 1
a948 1
		ovbcopy((caddr_t)ip, mtod(m, caddr_t), sizeof(struct ip));
d1656 1
a1656 1
	ovbcopy(mtod(m, caddr_t), (caddr_t)cp, (unsigned)cnt);
d1702 3
a1704 3
			ovbcopy((caddr_t)(&cp[IPOPT_OFFSET+1] +
			    sizeof(struct in_addr)),
			    (caddr_t)&cp[IPOPT_OFFSET+1],
@


1.239
log
@ansify.

ok mikeb@@, haesbaert@@
jajaja miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.238 2013/04/11 12:06:25 mpi Exp $	*/
d2129 1
a2129 3
		m->m_data += hlen;
		m->m_len -= hlen;
		icp = mtod(m, struct icmp *);
d2131 2
a2132 3
		icp->icmp_cksum = in_cksum(m, ntohs(ip->ip_len) - hlen);
		m->m_data -= hlen;
		m->m_len += hlen;
@


1.238
log
@Remove the extern keyword from function declarations, document
sysctl declarations, move variables and functions used in only
one place in their corresponding file. No functional change.

No objection from markus@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.237 2013/04/10 08:50:59 mpi Exp $	*/
d919 1
a919 4
ip_insertoptions(m, opt, phlen)
	struct mbuf *m;
	struct mbuf *opt;
	int *phlen;
d962 1
a962 2
ip_optcopy(ip, jp)
	struct ip *ip, *jp;
d1006 2
a1007 5
ip_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
a1027 4
#ifdef notyet
		case IP_RETOPTS:
			return (ip_pcbopts(optname, &inp->inp_options, m));
#else
a1028 1
#endif
d1624 1
a1624 8
#ifdef notyet
ip_pcbopts(optname, pcbopt, m)
	int optname;
#else
ip_pcbopts(pcbopt, m)
#endif
	struct mbuf **pcbopt;
	struct mbuf *m;
d1991 1
a1991 4
ip_getmoptions(optname, imo, mp)
	int optname;
	struct ip_moptions *imo;
	struct mbuf **mp;
d2037 1
a2037 2
ip_freemoptions(imo)
	struct ip_moptions *imo;
d2056 1
a2056 4
ip_mloopback(ifp, m, dst)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr_in *dst;
@


1.237
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.236 2013/04/09 08:35:38 mpi Exp $	*/
a72 4

extern u_int8_t get_sa_require(struct inpcb *);

extern int ipforwarding;
a73 4

#ifdef MROUTING
extern int ipmforwarding;
#endif
@


1.236
log
@Remove read-only ipsec variables and directly use defines instead.

ok mikeb@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.235 2012/11/06 12:32:42 henning Exp $	*/
a521 2
			extern struct socket *ip_mrouter;

@


1.235
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.234 2012/11/05 21:49:15 claudio Exp $	*/
a75 4
extern int ipsec_auth_default_level;
extern int ipsec_esp_trans_default_level;
extern int ipsec_esp_network_default_level;
extern int ipsec_ipcomp_default_level;
d1198 1
a1198 1
				if (optval < ipsec_auth_default_level &&
d1207 1
a1207 1
				if (optval < ipsec_esp_trans_default_level &&
d1216 1
a1216 1
				if (optval < ipsec_esp_network_default_level &&
d1224 1
a1224 1
				if (optval < ipsec_ipcomp_default_level &&
@


1.234
log
@Make sure that in[6]_proto_cksum_out() is called unconditinally and not
inside the NPF block. Fixes checksum issues seen on ramdisk kernels.
Initial diff by naddy@@, tested and OK by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.233 2012/11/01 07:55:56 henning Exp $	*/
a629 1
		in_proto_cksum_out(m, encif);
d700 2
a726 1
	in_proto_cksum_out(m, ifp);
@


1.233
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.231 2012/09/20 10:25:03 blambert Exp $	*/
a619 1
		in_proto_cksum_out(m, encif);
d630 1
a711 1
	in_proto_cksum_out(m, ifp);
d726 1
@


1.232
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d620 1
a700 2
	in_proto_cksum_out(m, ifp);

d712 1
@


1.231
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.230 2012/07/16 18:05:36 markus Exp $	*/
d743 1
a743 1
		    (ifp->if_bridge == NULL)) {
d890 1
a890 1
		    (ifp->if_bridge == NULL)) {
d910 1
a910 1
	    (ifp->if_bridge == NULL)) {
d2153 1
a2153 1
		    ifp->if_bridge != NULL) {
d2159 1
a2159 1
		    ifp->if_bridge != NULL) {
@


1.230
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.229 2012/04/13 09:38:32 deraadt Exp $	*/
d272 1
a272 1
	 * splnet is chosen over spltdb because we are not allowed to
d1187 1
a1187 1
				int s = spltdb();
d1194 1
a1194 1
				int s = spltdb();
d1383 1
a1383 1
				int s = spltdb();
d1390 1
a1390 1
				int s = spltdb();
@


1.229
log
@unneccessary casts to unsigned; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.228 2012/04/07 16:09:09 claudio Exp $	*/
d123 1
d139 1
d294 1
a294 1
		    IPSP_DIRECTION_OUT, NULL, inp);
d1066 1
d1119 3
d1455 1
d1496 3
@


1.228
log
@Bring the rtable sockopt code in line with the setrtable() implementation.
While there change IP_RTABLE to SO_RTABLE. IP_RTABLE will die soon.
With and OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.227 2012/03/30 11:12:46 markus Exp $	*/
d939 1
a939 1
	unsigned optlen;
d966 1
a966 1
	bcopy((caddr_t)p->ipopt_list, (caddr_t)(ip + 1), (unsigned)optlen);
d1009 1
a1009 1
			bcopy((caddr_t)cp, (caddr_t)dp, (unsigned)optlen);
d1434 1
a1434 1
				    mtod(m, caddr_t), (unsigned)m->m_len);
@


1.227
log
@actually store the result of the pmtu-route lookup. otherwise we
don't have a MTU to announce in the icmp need fragment packet.
this fixes PMTU-discovery for TCP over IPsec; ok mpf@@, fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.226 2012/03/17 10:16:41 dlg Exp $	*/
d1391 1
a1391 1
		case IP_RTABLE:
d1397 7
a1406 6
				break;
			}
			/* needs priviledges to switch when already set */
			if (p->p_p->ps_rtableid != rtid &&
			    p->p_p->ps_rtableid != 0 && suser(p, 0) != 0) {
				error = EACCES;
@


1.226
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.225 2011/12/29 12:10:52 haesbaert Exp $	*/
d663 1
a663 2
					ro->ro_rt = NULL;
					rtalloc1(&ro->ro_dst, RT_REPORT,
@


1.225
log
@Escape hardware-checksumming if interface is in a bridge, this is
already done for UDP/TCP/ICMP. This fixes a problem where checksumming
would not be computed if you have a bridge with at least one interface
with hardware checksumming and another without.

Discussed with sthen@@ and henning@@, this is somewhat a temporary fix,
we should not have these special bridge cases in ip_output, as Henning
said, the bridge must behave. But for that to work we need to poke the
bridge harder, this problem has been seen by at least two users at:

http://marc.info/?l=openbsd-misc&m=132391433319512&w=2
http://marc.info/?l=openbsd-misc&m=132234363030132&w=2

I promised to work on a better diff :-).

ok henning@@ sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.224 2011/12/02 03:15:31 haesbaert Exp $	*/
a734 8

	/* XXX
	 * Try to use jumbograms based on socket option, or the route
	 * or... for other reasons later on. 
	 */
	if ((flags & IP_JUMBO) && ro->ro_rt && (ro->ro_rt->rt_flags & RTF_JUMBO) &&
	    ro->ro_rt->rt_ifp)
		mtu = ro->ro_rt->rt_ifp->if_hardmtu;
@


1.224
log
@Kill unused IFCAP_IPSEC and IFCAP_IPCOMP.

ok claudio@@ henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.223 2011/07/04 06:54:49 claudio Exp $	*/
d749 2
a750 1
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4)) {
d896 2
a897 1
		    (ifp->if_capabilities & IFCAP_CSUM_IPv4)) {
d916 2
a917 1
	    (ifp->if_capabilities & IFCAP_CSUM_IPv4)) {
@


1.223
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.222 2011/06/15 09:11:01 mikeb Exp $	*/
d687 1
a687 2
	 * If deferred crypto processing is needed, check that the
	 * interface supports it.
d690 1
a690 2
	    PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL)) != NULL &&
	    (ifp->if_capabilities & IFCAP_IPSEC) == 0) {
@


1.223.2.1
log
@Escape hardware-checksumming if interface is in a bridge, this is
already done for UDP/TCP/ICMP. This fixes a problem where checksumming
would not be computed if you have a bridge with at least one interface
with hardware checksumming and another without.

Discussed with sthen@@ and henning@@, this is somewhat a temporary fix,
we should not have these special bridge cases in ip_output, as Henning
said, the bridge must behave. But for that to work we need to poke the
bridge harder, this problem has been seen by at least two users at:

http://marc.info/?l=openbsd-misc&m=132391433319512&w=2
http://marc.info/?l=openbsd-misc&m=132234363030132&w=2

I promised to work on a better diff :-).

ok henning@@ sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.223 2011/07/04 06:54:49 claudio Exp $	*/
d751 1
a751 2
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    (ifp->if_bridge == NULL)) {
d897 1
a897 2
		    (ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    (ifp->if_bridge == NULL)) {
d916 1
a916 2
	    (ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
	    (ifp->if_bridge == NULL)) {
@


1.222
log
@Add IP_RECVRTABLE socket option to be used with a IPPROTO_IP
level that allows one to retrieve the original routing domain
of UDP datagrams diverted by the pf via "divert-to" with a
recvmsg(2).

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.221 2011/05/28 12:51:40 weerd Exp $	*/
d608 1
a608 1
		    pf_test(PF_OUT, encif, &m, NULL) != PF_PASS) {
d707 1
a707 1
	if (pf_test(PF_OUT, ifp, &m, NULL) != PF_PASS) {
@


1.221
log
@Do not allow traffic to be sent with a destination address in 0/8;
this is not allowed according to Stevens and RFCs 5735 and 1122.

Suggestion to use ENETUNREACH from claudio.

OK phessler@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.220 2011/05/02 13:48:38 mikeb Exp $	*/
d1071 1
d1121 3
d1455 1
d1493 3
@


1.220
log
@recognize SO_RTABLE socket option at the SOL_SOCKET level;
discussed with and ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.219 2011/04/28 09:56:27 claudio Exp $	*/
d163 9
@


1.219
log
@Make in_broadcast() rdomain aware. Mostly mechanical change.
This fixes the problem of binding sockets to broadcast IPs in other
rdomains.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.218 2011/04/05 20:33:12 henning Exp $	*/
d1386 1
a1386 1
		case SO_RTABLE:
@


1.218
log
@in_proto_csum_out: if M_ICMP_CSUM_OUT is set, do the icmp checksum
ok dlg fondue-kinda-ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.217 2011/04/05 18:01:21 henning Exp $	*/
d547 2
a548 1
	if ((sproto == 0) && (in_broadcast(dst->sin_addr, ifp))) {
@


1.217
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.216 2011/04/04 17:44:43 henning Exp $	*/
d2142 14
@


1.216
log
@de-guttenberg our stack a bit
we don't need 7 f***ing copies of the same code to do the protocol checksums
(or not, depending on hw capabilities). claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.215 2011/04/04 13:57:29 henning Exp $	*/
d747 1
a747 1
		if (m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
d749 1
a749 1
		else if (m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
d2130 1
a2130 1
	if (m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT) {
d2134 1
a2134 1
			m->m_pkthdr.csum_flags &= ~M_TCPV4_CSUM_OUT; /* Clear */
d2136 1
a2136 1
	} else if (m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT) {
d2140 1
a2140 1
			m->m_pkthdr.csum_flags &= ~M_UDPV4_CSUM_OUT; /* Clear */
@


1.215
log
@there is no need to special case the bridge in the ip checksum handling
ok sthen claudio dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.214 2010/09/30 09:18:18 phessler Exp $	*/
d338 1
a338 5
		if (m->m_pkthdr.csum_flags & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
			in_delayed_cksum(m);
			m->m_pkthdr.csum_flags &=
			    ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
		}
d498 1
a498 6
			if (m->m_pkthdr.csum_flags &
			    (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
				in_delayed_cksum(m);
				m->m_pkthdr.csum_flags &=
				    ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
			}
d691 1
a691 14
	/* Catch routing changes wrt. hardware checksumming for TCP or UDP. */
	if (m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_TCPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m);
			m->m_pkthdr.csum_flags &= ~M_TCPV4_CSUM_OUT; /* Clear */
		}
	} else if (m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_UDPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m);
			m->m_pkthdr.csum_flags &= ~M_UDPV4_CSUM_OUT; /* Clear */
		}
	}
d837 1
a837 5
	if (m->m_pkthdr.csum_flags & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum_flags &= ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
	}

d2125 18
@


1.214
log
@If a caller is requesting to be set to the same rtable that they
currently have, let the call succeede.

Mirrors the same behaviour as setrtable()

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.213 2010/09/23 04:45:15 yasuoka Exp $	*/
d763 1
a763 2
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    ifp->if_bridge == NULL) {
d913 1
a913 2
		    (ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    ifp->if_bridge == NULL) {
d932 1
a932 2
	    (ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
	    ifp->if_bridge == NULL) {
@


1.213
log
@add a new IP level socket option IP_PIPEX.  This option is used for L2TP
support by pipex.
OK henning@@, "Carry on" blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.212 2010/09/08 08:34:42 claudio Exp $	*/
a1419 5
			/* needs priviledges to switch when already set */
			if (p->p_p->ps_rtableid != 0 && suser(p, 0) != 0) {
				error = EACCES;
				break;
			}
d1423 6
@


1.212
log
@Return EACCES when pf_test() blocks a packet in ip_output(). This allows
ip_forward() to know the difference between blocked packets and those that
can't be forwarded (EHOSTUNREACH). Only in the latter case an ICMP should
be sent. In the other callers of ip_output() change the error back to
EHOSTUNREACH since userland may not expect EACCES on a sendto().
OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.211 2010/08/13 06:46:08 dlg Exp $	*/
d1432 7
d1636 5
@


1.211
log
@when sending a fragmented packet, dont check if the interfaces send queue
has enough space for all the fragments on it.

this check was snuck in by itojun under an unrelated commit. it broke when
i set the virtual interface send queue depths to 1, which beck had to
special case at n2k10. without this code we avoid these dubious checks
along with another splnet/splx pair, and it should make future work on
manipulating send queues easier.

ive been running this in production since n2k10 (~7months ago).

ok claudio@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.210 2010/07/09 16:58:06 reyk Exp $	*/
d608 1
a608 1
			error = EHOSTUNREACH;
@


1.210
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.209 2010/07/03 04:44:51 guenther Exp $	*/
a844 1
	int s;
a940 18
	/*
	 * If there is no room for all the fragments, don't queue
	 * any of them.
	 *
	 * Queue them anyway on virtual interfaces
	 * (vlan, etc) with queue length 1 and hope the
	 * underlying interface can cope.
	 */
	if (ifp != NULL && ifp->if_snd.ifq_maxlen != 1) {
		s = splnet();
		if (ifp->if_snd.ifq_maxlen - ifp->if_snd.ifq_len < fragments &&
		    error == 0) {
			error = ENOBUFS;
			ipstat.ips_odropped++;
			IFQ_INC_DROPS(&ifp->if_snd);
		}
		splx(s);
	}
@


1.209
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.208 2010/07/02 02:40:16 blambert Exp $	*/
d275 2
a276 1
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
d319 1
d591 2
a592 1
		tdb = gettdb(sspi, &sdst, sproto);
d605 2
a606 1
		if ((encif = enc_getif(0, tdb->tdb_tap)) == NULL ||
@


1.208
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.207 2010/07/01 02:09:45 reyk Exp $	*/
d1165 1
a1165 1
			    inp->inp_rdomain);
d1429 1
a1429 1
		case SO_RDOMAIN:
d1435 2
a1436 3
			if (p->p_p->ps_rdomain != 0 &&
			    p->p_p->ps_rdomain != rtid &&
			    (error = suser(p, 0)) != 0) {
d1440 2
a1441 2
			/* table must exist and be a domain */
			if (!rtable_exists(rtid) || rtid != rtable_l2(rtid)) {
d1445 1
a1445 1
			inp->inp_rdomain = rtid;
d1640 1
a1640 1
		case SO_RDOMAIN:
d1643 1
a1643 1
			*mtod(m, u_int *) = inp->inp_rdomain;
d1767 1
a1767 1
    u_int rdomain)
d1824 1
a1824 1
		INADDR_TO_IFP(addr, ifp, rdomain);
d1883 1
a1883 1
				    rdomain);
d1891 1
a1891 1
			INADDR_TO_IFP(mreq->imr_interface, ifp, rdomain);
d1977 1
a1977 1
			INADDR_TO_IFP(mreq->imr_interface, ifp, rdomain);
@


1.207
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.206 2010/06/29 21:28:38 reyk Exp $	*/
d1637 1
a1637 1
				    ipr + 1);
d2154 1
a2154 1
		m_copyback(m, offset, sizeof(csum), &csum);
@


1.206
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.204 2010/01/13 12:09:36 claudio Exp $	*/
d589 9
d602 1
a602 1
		if ((encif = enc_getif(0)) == NULL ||
a622 9

		tdb = gettdb(sspi, &sdst, sproto);
		if (tdb == NULL) {
			DPRINTF(("ip_output: unknown TDB"));
			error = EHOSTUNREACH;
			splx(s);
			m_freem(m);
			goto done;
		}
@


1.205
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d124 3
d593 2
a594 2

		if (pf_test(PF_OUT, &encif[0].sc_if, &m, NULL) != PF_PASS) {
@


1.204
log
@Double and in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.203 2010/01/12 01:30:09 beck Exp $	*/
d189 2
a190 1
				  dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
d199 1
d226 1
a226 2
				rtalloc_mpath(ro, NULL,
				    m->m_pkthdr.rdomain);
d367 2
a368 1
				  dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
d377 1
d404 1
a404 2
				rtalloc_mpath(ro, &ip->ip_src.s_addr,
				    m->m_pkthdr.rdomain);
d656 1
a656 1
					rtalloc1(&ro->ro_dst, 1,
d1880 2
a1881 1
				ro.ro_rt = rtalloc1(&ro.ro_dst, 1, rdomain);
@


1.203
log
@Allow the queueing of multiple fragments on virtual interfaces with a
queue length of one - i.e. vlans with the forthcoming change from dlg.

this allows fragmented frames to be sent on such an interface, hoping
that the interface underneath copes correctly - A better fix for this
will be forthcoming soon, but this is good enough for now, and will
allow the change for vlans to use an ifq length of 1.

tested by me and dlg@@, ok dlg@@, claudio@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.202 2009/12/23 07:40:31 guenther Exp $	*/
d545 1
a545 1
	 * Look for broadcast address and and verify user is allowed to send
@


1.202
log
@The process's rdomain should be, well, per-process and not per-rthread,
so put it in struct process instead of struct proc.  While at it,
move the p_emul member inside struct proc so that it gets copied
automatically instead of requiring manual assignment.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.201 2009/12/11 17:50:57 deraadt Exp $	*/
d936 4
d941 1
a941 1
	if (ifp != NULL) {
@


1.201
log
@Two cases of IPSEC getsockopt() returning two bytes of uninitialialized
kernel stack content instead of proper information; found by Clement LECIGNE
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.200 2009/11/27 20:05:50 guenther Exp $	*/
d1426 2
a1427 1
			if (p->p_rdomain != 0 && p->p_rdomain != rtid &&
@


1.200
log
@Add setrdomain() and getrdomain() system calls.  Committing now to
catch the libc major bump per request from deraadt@@

Diff by reyk.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.199 2009/11/20 09:02:21 guenther Exp $	*/
d1596 1
d1600 1
@


1.199
log
@NULL dereference in IPV6_PORTRANGE and IP_IPSEC_*, found by Clement LECIGNE,
localhost DoS everywhere.  To help minimize further issues, make the
mbuf != NULL test explicit instead of implicit in a length test.
Suggestions and initial work by mpf@@ and miod@@
ok henning@@, mpf@@, claudio@@,
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.198 2009/11/13 14:14:56 claudio Exp $	*/
d1064 1
a1065 1
	struct proc *p = curproc; /* XXX */
d1426 5
@


1.198
log
@Packets generated by ip_fragment() need to inherit the rdomain from the
original packet or they will trigger the diagnostic check in the interface
output routines. OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.197 2009/11/03 10:59:04 claudio Exp $	*/
d1277 1
a1277 1
			if (m->m_len < 2) {
@


1.197
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.196 2009/10/28 18:02:00 deraadt Exp $	*/
d878 1
a878 1
		/* we must inherit MCAST and BCAST flags */
d880 1
@


1.196
log
@*NULL store in IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL,
IP_IPCOMP_LEVEL found by Clement LECIGNE, localhost root exploitable on
userland/kernel shared vm machines (ie. i386, amd64, arm, sparc (but not
sparc64), sh, ...) on OpenBSD 4.3 or older
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.195 2009/10/06 21:21:48 claudio Exp $	*/
d1425 2
a1426 1
			if (!rtable_exists(rtid)) {
@


1.195
log
@Redo the route lookup in the output (and IPv6 forwarding) path if the
destination of a packet was changed by pf. This allows for some evil
games with rdr-to or nat-to but is mostly needed for better rdomain/rtable
support. This is a first step and more work and cleanup is needed.

Here a list of what works and what does not (needs a patched pfctl):
pass out rdr-to:
from local rdr-to local addr works (if state tracking on lo0 is done)
from remote rdr-to local addr does NOT work
from local rdr-to remote works
from remote rdr-to remote works

pass in nat-to:
from remote nat-to local addr does NOT work
from remote nat-to non-local addr works
non-local is an IP that is routed to the FW but is not assigned on the FW.
The non working cases need some magic to correctly rewrite the incomming
packet since the rewriting would happen outbound which is too late.

"time to get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.194 2009/06/05 00:05:22 claudio Exp $	*/
d1529 1
@


1.194
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.193 2009/01/30 20:46:33 claudio Exp $	*/
d248 4
d601 7
a716 1

d719 11
@


1.194.4.1
log
@MFC rev. 1.196 of ip_output.c by deraadt@@:

*NULL store in IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL,
IP_IPCOMP_LEVEL found by Clement LECIGNE, localhost root exploitable on
userland/kernel shared vm machines (ie. i386, amd64, arm, sparc (but not
sparc64), sh, ...) on OpenBSD 4.3 or older
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.194 2009/06/05 00:05:22 claudio Exp $	*/
a1507 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
@


1.193
log
@When don't-fragment packets need to get fragemnted some code tries to
update the route specific MTU from the interface (because it could have
changed in between). This only makes sense if we actually have a valid
route but e.g. multicast traffic does no route lookup and so there is no
route at all and we don't need to update anything.
Hit by dlg@@'s pfsync rewrite which already found 3 other bugs in the network
stack and slowly makes us wonder how it worked in the first place.
OK mcbride@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.192 2009/01/29 12:33:15 naddy Exp $	*/
d204 7
a210 5
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
			    (ia = ifatoia(ifa_ifwithnet(sintosa(dst)))) == 0) {
			    ipstat.ips_noroute++;
			    error = ENETUNREACH;
			    goto bad;
d224 2
a225 1
				rtalloc_mpath(ro, NULL, 0);
d377 7
a383 5
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
			    (ia = ifatoia(ifa_ifwithnet(sintosa(dst)))) == 0) {
			    ipstat.ips_noroute++;
			    error = ENETUNREACH;
			    goto bad;
d397 2
a398 1
				rtalloc_mpath(ro, &ip->ip_src.s_addr, 0);
d632 2
a633 1
				rt = icmp_mtudisc_clone((struct sockaddr *)&dst);
d642 3
a644 2
					ro->ro_rt = (struct rtentry *) 0;
					rtalloc(ro);
d1048 1
d1133 2
a1134 1
			error = ip_setmoptions(optname, &inp->inp_moptions, m);
d1398 12
d1600 5
d1726 2
a1727 4
ip_setmoptions(optname, imop, m)
	int optname;
	struct ip_moptions **imop;
	struct mbuf *m;
d1784 1
a1784 1
		INADDR_TO_IFP(addr, ifp);
d1840 3
a1842 1
			rtalloc(&ro);
d1850 1
a1850 1
			INADDR_TO_IFP(mreq->imr_interface, ifp);
d1936 1
a1936 1
			INADDR_TO_IFP(mreq->imr_interface, ifp);
@


1.193.2.1
log
@MFC rev. 1.196 of ip_output.c by deraadt@@:

*NULL store in IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL,
IP_IPCOMP_LEVEL found by Clement LECIGNE, localhost root exploitable on
userland/kernel shared vm machines (ie. i386, amd64, arm, sparc (but not
sparc64), sh, ...) on OpenBSD 4.3 or older
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.193 2009/01/30 20:46:33 claudio Exp $	*/
a1485 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
@


1.192
log
@Always zero the IP checksum field for packets and packet fragments
being passed down if using HW checksum offload.
From Brad, inspired by NetBSD/FreeBSD.  ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.191 2008/05/09 02:56:36 markus Exp $	*/
d756 2
a757 1
		if ((ro->ro_rt->rt_flags & (RTF_UP | RTF_HOST)) &&
@


1.191
log
@IP_RECVDSTPORT, allows you to get the destination port of UDP datagrams
for pf(4) diverted packets; based on patch by Scot Loach; ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.190 2007/10/29 16:19:23 chl Exp $	*/
d724 1
d729 1
a729 2
		} else {
			ip->ip_sum = 0;
a730 1
		}
d873 1
d879 1
a879 2
		} else {
			mhip->ip_sum = 0;
a880 1
		}
d893 1
d899 1
a899 2
	} else {
		ip->ip_sum = 0;
a900 1
	}
@


1.191.2.1
log
@MFC rev. 1.196 of ip_output.c by deraadt@@:

*NULL store in IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL,
IP_IPCOMP_LEVEL found by Clement LECIGNE, localhost root exploitable on
userland/kernel shared vm machines (ie. i386, amd64, arm, sparc (but not
sparc64), sh, ...) on OpenBSD 4.3 or older
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.191 2008/05/09 02:56:36 markus Exp $	*/
a1487 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
@


1.190
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.189 2007/09/18 18:56:02 markus Exp $	*/
d1066 1
d1113 3
d1419 1
d1454 3
@


1.189
log
@allow 4095 instead of 20 multicast group memberships per socket (you need
one entry for each multicast group and interface combination). this allows
you to run OSPF with more than 10 interfaces.
adapted from freebsd; ok claudio, henning, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.188 2007/07/20 19:00:35 claudio Exp $	*/
d1306 1
a1306 2
			MALLOC(ipr, struct ipsec_ref *,
			       sizeof(struct ipsec_ref) + m->m_len - 2,
d1325 1
a1325 1
					FREE(ipr, M_CREDENTIALS);
d1338 1
a1338 1
					FREE(ipr, M_CREDENTIALS);
d1349 1
a1349 1
					FREE(ipr, M_CREDENTIALS);
d1360 1
a1360 1
					FREE(ipr, M_CREDENTIALS);
@


1.188
log
@Remove inm_ifp from struct in_multi -- caching struct ifnet is dangerous
because interfaces may disappear without notice causing use after free bugs.
Instead use the inm_ia->ia_ifp as a hint, struct in_ifaddr correctly tracks
removals of interfaces and invalidates ia_ifp in such cases.
looks good henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.187 2007/05/30 04:46:45 henning Exp $	*/
d1706 1
d1716 4
a1719 2
		    M_WAITOK);

d1725 2
d1842 28
a1869 3
		if (i == IP_MAX_MEMBERSHIPS) {
			error = ETOOMANYREFS;
			break;
d1943 1
a1943 1
	 * If all options have default values, no need to keep the mbuf.
d1949 1
d2018 1
@


1.187
log
@no need to declare extern ipsec_in_use, we get it via ip_ipsp.h
found by itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.186 2007/05/29 17:46:24 henning Exp $	*/
d1828 1
a1828 1
			if (imo->imo_membership[i]->inm_ifp == ifp &&
d1885 1
a1885 1
			     imo->imo_membership[i]->inm_ifp == ifp) &&
@


1.186
log
@gain another 5+% in ip forwarding performance.
boring details:
skip looking for ipsec tags and descending into ip_spd_lookup if there
are no ipsec flows, except in one case in ip_output (spotted by markus)
where we have to if we have a pcb. ip_spd_lookup has the shortcut already,
but there is enough work done before so that skipping that gains us about
5%. ok theo, markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.185 2007/05/27 20:15:48 dlg Exp $	*/
a80 1
extern int ipsec_in_use;
@


1.185
log
@-static

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.184 2006/12/05 09:17:12 markus Exp $	*/
d81 1
d247 3
d662 3
a664 2
	if ((mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL))
	    != NULL && (ifp->if_capabilities & IFCAP_IPSEC) == 0) {
d705 1
a705 1
	if ((flags & IP_FORWARDING) && (ipforwarding == 2) &&
@


1.184
log
@do not install pmtu routes for transport mode SAs, as they do not
the dest IP; PMTU debugging support; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.183 2006/12/01 12:33:28 henning Exp $	*/
d87 2
a88 2
static struct mbuf *ip_insertoptions(struct mbuf *, struct mbuf *, int *);
static void ip_mloopback(struct ifnet *, struct mbuf *, struct sockaddr_in *);
d931 1
a931 1
static struct mbuf *
d1993 1
a1993 1
static void
@


1.183
log
@rangecheck ttl on IP_TTL, collected dust in my tree
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.182 2006/10/11 09:34:51 henning Exp $	*/
d605 1
d607 3
d616 4
a619 1
			if (rt == NULL || (rt->rt_flags & RTF_HOST) == 0) {
d626 2
@


1.182
log
@implement IP_MINTTL socket option fo tcp sockets
This is for RFC3682 aka the TTL security hack - sender sets TTL to 255,
receiver checks no router on the way (or, no more than expected) reduced
the TTL. carp uses that technique already.
modeled after FreeBSD implementation.
ok claudio djm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.180 2006/06/18 11:47:45 pascoe Exp $	*/
d1064 4
a1067 1
					inp->inp_ip.ip_ttl = optval;
@


1.181
log
@implement IP_RECVTTL socket option.
when set on raw or udp sockets, userland receives the incoming packet's TTL
as ancillary data (cmsg shitz). modeled after the FreeBSD implementation.
ok claudio djm deraadt
@
text
@d1047 1
d1067 6
d1394 1
d1410 4
@


1.180
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.179 2006/06/06 15:19:15 deraadt Exp $	*/
d1051 1
d1065 1
d1086 3
d1391 1
d1419 3
@


1.179
log
@Put mrouting enable flag inside the right ifdef.  If you change files
here, make sure they compile with or without IPSEC, you morons!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.178 2006/05/29 20:42:27 claudio Exp $	*/
d222 1
a222 1
				rtalloc(ro);
d389 1
a389 1
				rtalloc(ro);
@


1.178
log
@Make savecontrol functions more generic and use them now for raw IP too.
Additionally add the IP_RECVIF option which returns the interface a packet
was received on. OK markus@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.177 2006/05/26 20:50:41 deraadt Exp $	*/
d81 3
d85 1
a85 1
#endif /* IPSEC */
@


1.177
log
@rename jumbo mtu to if_hardmtu; ok brad reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.176 2006/03/05 21:48:56 miod Exp $	*/
d1047 1
d1078 3
d1382 1
d1407 3
@


1.176
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.175 2006/03/05 02:29:46 brad Exp $	*/
d696 7
a702 3
	/* Try to use jumbograms? */
	if (flags & IP_JUMBO && ro->ro_rt && ro->ro_rt->rt_flags & RTF_JUMBO)
		mtu = IP_JUMBO_MTU;
@


1.175
log
@revert unrelated change that snuck into the last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.174 2006/03/04 22:40:16 brad Exp $	*/
d462 1
a462 3
			for (ia = in_ifaddr.tqh_first;
			     ia;
			     ia = ia->ia_list.tqe_next)
@


1.174
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.173 2005/10/05 17:32:22 norby Exp $	*/
d1981 1
a1981 1
	if (csum == 0 && (m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT) != 0)
@


1.173
log
@Add multicast routing to GENERIC.

It is now possible to enable multicast routing in the kernel with
the sysctl option net.inet.ip.mforwarding=1

Based on intial work by msf@@

help claudio@@
ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.172 2005/06/10 15:53:07 markus Exp $	*/
d1981 1
a1981 1
	if (csum == 0 && ip->ip_p == IPPROTO_UDP)
@


1.172
log
@getsockopt(): allocate a mbuf cluster for large ipsec credentials
fixes kernel panic from pr 4252; Stefan Miltchev; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.171 2005/05/27 04:55:28 mcbride Exp $	*/
d81 1
d505 2
a506 1
			if (ip_mrouter && (flags & IP_FORWARDING) == 0) {
d1514 1
a1514 1
						 
@


1.171
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.170 2005/04/25 17:55:52 brad Exp $	*/
d1496 19
a1514 1
				m->m_len += ipr->ref_len;
@


1.170
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.169 2005/01/04 19:42:38 markus Exp $	*/
d695 4
@


1.169
log
@restrict forwarding to ipsec processed traffic of ip.forwarding==2
ok deraadt, henning, fgsch, mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.168 2004/11/10 03:27:27 mcbride Exp $	*/
d318 1
a318 1
		if (m->m_pkthdr.csum & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
d320 1
a320 1
			m->m_pkthdr.csum &=
d480 1
a480 1
			if (m->m_pkthdr.csum &
d483 1
a483 1
				m->m_pkthdr.csum &=
d657 1
a657 1
	if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT) {
d661 1
a661 1
			m->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
d663 1
a663 1
	} else if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT) {
d667 1
a667 1
			m->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
d702 1
a702 1
			m->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
d709 1
a709 1
		if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
d711 1
a711 1
		else if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
d799 1
a799 1
	if (m->m_pkthdr.csum & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
d801 1
a801 1
		m->m_pkthdr.csum &= ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
d853 1
a853 1
			m->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
d874 1
a874 1
		m->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
@


1.169.2.1
log
@MFC:
Fix by markus@@

getsockopt(): allocate a mbuf cluster for large ipsec credentials
fixes kernel panic from pr 4252; Stefan Miltchev

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.169 2005/01/04 19:42:38 markus Exp $	*/
d1492 1
a1492 19
				size_t len;

				len = m->m_len + ipr->ref_len;
				if (len > MCLBYTES) {
					 m_free(m);
					 error = EINVAL;
					 break;
				}
				/* allocate mbuf cluster for larger option */
				if (len > MLEN) {
					 MCLGET(m, M_WAITOK);
					 if ((m->m_flags & M_EXT) == 0) {
						 m_free(m);
						 error = ENOBUFS;
						 break;
					 }
						 
				}
				m->m_len = len;
@


1.168
log
@Add some (ifp != NULL) checks to ip_fragment() so it can be used even if there
is no struct ifnet associated with the outgoing interface of the packet.
Necessary for upcoming Protocol Independent Multicast support.

From Pavlin Radoslavov

ok henning@@ djm@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.167 2004/06/22 07:35:20 cedric Exp $	*/
d80 1
d685 9
@


1.167
log
@Pull the plug on source-based routing until remaining bugs are eradicated.
No need to reconfig kernel or rebuild userland stuff.
requested deraadt@@, help beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.166 2004/06/21 23:50:37 tholo Exp $	*/
d840 2
a841 1
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
d861 2
a862 1
	if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
d875 9
a883 6
	s = splnet();
	if (ifp->if_snd.ifq_maxlen - ifp->if_snd.ifq_len < fragments &&
	    error == 0) {
		error = ENOBUFS;
		ipstat.ips_odropped++;
		IFQ_INC_DROPS(&ifp->if_snd);
a884 1
	splx(s);
@


1.167.2.1
log
@MFC:
Fix by markus@@

getsockopt(): allocate a mbuf cluster for large ipsec credentials
fixes kernel panic from pr 4252; Stefan Miltchev

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.167 2004/06/22 07:35:20 cedric Exp $	*/
d1478 1
a1478 19
				size_t len;

				len = m->m_len + ipr->ref_len;
				if (len > MCLBYTES) {
					 m_free(m);
					 error = EINVAL;
					 break;
				}
				/* allocate mbuf cluster for larger option */
				if (len > MLEN) {
					 MCLGET(m, M_WAITOK);
					 if ((m->m_flags & M_EXT) == 0) {
						 m_free(m);
						 error = ENOBUFS;
						 break;
					 }
						 
				}
				m->m_len = len;
@


1.166
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.165 2004/06/21 19:26:01 mcbride Exp $	*/
a100 1
	struct sockaddr_rtin *rtin;
a176 1
		rtin = satortin(&ro->ro_dst);
d184 1
a184 2
				  rtin->rtin_dst.s_addr != ip->ip_dst.s_addr ||
				  rtin->rtin_src.s_addr != ip->ip_src.s_addr)) {
d190 3
a192 4
			rtin->rtin_family = AF_INET;
			rtin->rtin_len = sizeof(*rtin);
			rtin->rtin_dst = ip->ip_dst;
			rtin->rtin_src = ip->ip_src;
a232 8
                        else if (rtin->rtin_src.s_addr) {
                                if (ro != &iproute) {
                                        iproute.ro_dst = ro->ro_dst;
                                        rtin = satortin(&iproute.ro_dst);
                                        dst = satosin(&iproute.ro_dst);
                                }
                                rtin->rtin_src.s_addr = 0;
                        }
a343 1
		rtin = satortin(&ro->ro_dst);
d351 1
a351 2
				  rtin->rtin_dst.s_addr != ip->ip_dst.s_addr ||
				  rtin->rtin_src.s_addr != ip->ip_src.s_addr)) {
d357 3
a359 4
			rtin->rtin_family = AF_INET;
			rtin->rtin_len = sizeof(*rtin);
			rtin->rtin_dst = ip->ip_dst;
			rtin->rtin_src = ip->ip_src;
a399 8
                        else if (rtin->rtin_src.s_addr) {
                                if (ro != &iproute) {
                                        iproute.ro_dst = ro->ro_dst;
                                        rtin = satortin(&iproute.ro_dst);
                                        dst = satosin(&iproute.ro_dst);
                                }
                                rtin->rtin_src.s_addr = 0;
                        }
@


1.165
log
@Get rid of pf_test_eh() wrapper.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.164 2004/06/21 18:34:52 markus Exp $	*/
d621 1
a621 1
		    tdb->tdb_mtutimeout > time.tv_sec) {
@


1.164
log
@don't leak ipsec pmtu routes; with mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.163 2004/06/06 16:49:09 cedric Exp $	*/
d595 1
a595 1
		if (pf_test(PF_OUT, &encif[0].sc_if, &m) != PF_PASS) {
d697 1
a697 1
	if (pf_test(PF_OUT, ifp, &m) != PF_PASS) {
@


1.163
log
@extend routing table to be able to match and route packets based on
their *source* IP address in addition to their destination address.
routing table "destination" now contains a "struct sockaddr_rtin"
for IPv4 instead of a "struct sockaddr_in".
the routing socket has been extended in a backward-compatible way.
todo: PMTU enhancements, IPv6. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.162 2004/05/18 10:31:09 dhartmei Exp $	*/
d623 1
d636 1
d645 2
@


1.162
log
@fix size argument to ovbcopy() in ip_pcbopts(), found by Andrei Iltchenko
(FreeBSD PR 66386), ok markus@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.161 2004/04/28 02:51:58 cedric Exp $	*/
d101 1
d178 1
d186 2
a187 1
				  dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
d193 4
a196 3
			dst->sin_family = AF_INET;
			dst->sin_len = sizeof(*dst);
			dst->sin_addr = ip->ip_dst;
d237 8
d356 1
d364 2
a365 1
				  dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
d371 4
a374 3
			dst->sin_family = AF_INET;
			dst->sin_len = sizeof(*dst);
			dst->sin_addr = ip->ip_dst;
d415 8
@


1.161
log
@make return-rst work on pure bridges. ok dhartmei@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.160 2004/02/10 20:20:01 itojun Exp $	*/
d1584 1
a1584 1
			    (unsigned)cnt + sizeof(struct in_addr));
@


1.160
log
@plug mbuf leak (ip_fragment() always free mbuf on error).  tested by cedric,
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.159 2003/11/06 16:57:41 dhartmei Exp $	*/
d166 4
d333 6
a338 1
	if (donerouting == 0) {
@


1.159
log
@the previous change caused invalid checksums in some cases (rdr),
back it out temporarily, ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.158 2003/11/03 07:58:36 cedric Exp $	*/
d720 2
a721 1
	if (error)
d723 1
d744 1
a744 1
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0)
d759 3
d767 2
a768 1
	if (len < 8)
d770 1
d794 2
a795 1
			return (ENOBUFS);
d821 2
a822 1
			return (ENOBUFS);	/* ??? */
d836 1
d855 20
d876 1
a876 1
	return (0);
@


1.158
log
@There is no point in checking NIC capabilities before calling pf_test(),
since pf_test() can drop the packet or route it through another NIC.
ok dhartmei@@ mcbride@@
comment requested by markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.157 2003/10/02 05:47:29 itojun Exp $	*/
a626 22
#endif /* IPSEC */

	/*
	 * Packet filter
	 *
	 * This should be called before checking NIC capabilities,
	 * because pf_test() can:
	 *  - drop the packet.
	 *  - route the packet through another NIC.
	 */
#if NPF > 0
	if (pf_test(PF_OUT, ifp, &m) != PF_PASS) {
		error = EHOSTUNREACH;
		m_freem(m);
		goto done;
	}
	if (m == NULL)
		goto done;

	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;
#endif
a627 1
#ifdef IPSEC
d656 16
@


1.157
log
@correct endian handling of ip->ip_off.
do not try to send incomplete fragments on ENOBUFS case
(behavior change from 4.4bsd).
dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.156 2003/08/15 20:32:20 tedu Exp $	*/
d627 22
d650 1
a678 16

	/*
	 * Packet filter
	 */
#if NPF > 0
	if (pf_test(PF_OUT, ifp, &m) != PF_PASS) {
		error = EHOSTUNREACH;
		m_freem(m);
		goto done;
	}
	if (m == NULL)
		goto done;

	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;
#endif
@


1.156
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.155 2003/08/14 19:00:12 jason Exp $	*/
d720 1
a720 1
	if (error == EMSGSIZE)
d801 3
a803 2
		mhip->ip_off = ((off - hlen) >> 3) + (ip->ip_off & ~IP_MF);
		if (ip->ip_off & IP_MF)
@


1.156.2.1
log
@MFC:
Fix by itojun@@

plug mbuf leak (ip_fragment() always free mbuf on error).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.156 2003/08/15 20:32:20 tedu Exp $	*/
d720 1
a720 2
	if (error) {
		m = m0 = NULL;
a721 1
	}
d742 1
a742 1
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0 && m != NULL)
a756 3
	int fragments = 0;
	int s;
	int error = 0;
d762 1
a762 2
	if (len < 8) {
		m_freem(m);
a763 1
	}
d787 1
a787 2
			error = ENOBUFS;
			goto sendorfree;
d812 1
a812 2
			error = ENOBUFS;
			goto sendorfree;
a825 1
		fragments++;
a843 20
sendorfree:
	/*
	 * If there is no room for all the fragments, don't queue
	 * any of them.
	 */
	s = splnet();
	if (ifp->if_snd.ifq_maxlen - ifp->if_snd.ifq_len < fragments &&
	    error == 0) {
		error = ENOBUFS;
		ipstat.ips_odropped++;
		IFQ_INC_DROPS(&ifp->if_snd);
	}
	splx(s);
	if (error) {
		for (m = m0; m; m = m0) {
			m0 = m->m_nextpkt;
			m->m_nextpkt = NULL;
			m_freem(m);
		}
	}
d845 1
a845 1
	return (error);
@


1.155
log
@m_copyback()'s 4th arg is const void *, nuke (caddr_t) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.154 2003/07/09 22:03:16 itojun Exp $	*/
d1091 1
a1091 1
				    suser(p->p_ucred, &p->p_acflag)) {
d1100 1
a1100 1
				    suser(p->p_ucred, &p->p_acflag)) {
d1109 1
a1109 1
				    suser(p->p_ucred, &p->p_acflag)) {
d1117 1
a1117 1
				    suser(p->p_ucred, &p->p_acflag)) {
@


1.154
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.153 2003/06/02 23:28:14 millert Exp $	*/
d1437 1
a1437 1
					   (caddr_t)(ipr + 1));
d1916 1
a1916 1
		m_copyback(m, offset, sizeof(csum), (caddr_t) &csum);
@


1.153
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.152 2003/03/14 18:28:12 jason Exp $	*/
d149 1
a149 1
		ip->ip_off &= IP_DF;
d534 1
a534 1
		if ((u_int16_t)ip->ip_len > ifp->if_mtu) {
d549 1
a549 1
		ip->ip_off |= IP_DF;
d587 2
a588 2
		if (ip_mtudisc && (ip->ip_off & IP_DF) && tdb->tdb_mtu &&
		    (u_int16_t)ip->ip_len > tdb->tdb_mtu &&
a615 4
		/* Massage the IP header for use by the IPsec code */
		ip->ip_len = htons((u_short) ip->ip_len);
		ip->ip_off = htons((u_short) ip->ip_off);

d676 1
a676 3
	if ((u_int16_t)ip->ip_len <= mtu) {
		ip->ip_len = htons((u_int16_t)ip->ip_len);
		ip->ip_off = htons((u_int16_t)ip->ip_off);
d698 1
a698 1
	if (ip->ip_off & IP_DF) {
d783 1
a783 1
	for (off = hlen + len; off < (u_int16_t)ip->ip_len; off += len) {
d804 2
a805 2
		if (off + len >= (u_int16_t)ip->ip_len)
			len = (u_int16_t)ip->ip_len - off;
d832 1
a832 1
	m_adj(m, hlen + firstlen - (u_int16_t)ip->ip_len);
d835 1
a835 1
	ip->ip_off = htons((u_int16_t)(ip->ip_off | IP_MF));
d865 1
a865 1
	if (optlen + (u_int16_t)ip->ip_len > IP_MAXPACKET)
d891 1
a891 1
	ip->ip_len += optlen;
a1880 2
		ip->ip_len = htons((u_int16_t)ip->ip_len);
		ip->ip_off = htons((u_int16_t)ip->ip_off);
@


1.152
log
@kill vaxisms
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.151 2003/01/31 17:27:03 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.152.2.1
log
@MFC:
Fix by itojun@@

plug mbuf leak (ip_fragment() always free mbuf on error).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.152 2003/03/14 18:28:12 jason Exp $	*/
d730 1
a730 2
	if (error) {
		m = m0 = NULL;
a731 1
	}
d752 1
a752 1
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0 && m != NULL)
a766 3
	int fragments = 0;
	int s;
	int error = 0;
d772 1
a772 2
	if (len < 8) {
		m_freem(m);
a773 1
	}
d797 1
a797 2
			error = ENOBUFS;
			goto sendorfree;
d822 1
a822 2
			error = ENOBUFS;
			goto sendorfree;
a835 1
		fragments++;
a853 20
sendorfree:
	/*
	 * If there is no room for all the fragments, don't queue
	 * any of them.
	 */
	s = splnet();
	if (ifp->if_snd.ifq_maxlen - ifp->if_snd.ifq_len < fragments &&
	    error == 0) {
		error = ENOBUFS;
		ipstat.ips_odropped++;
		IFQ_INC_DROPS(&ifp->if_snd);
	}
	splx(s);
	if (error) {
		for (m = m0; m; m = m0) {
			m0 = m->m_nextpkt;
			m->m_nextpkt = NULL;
			m_freem(m);
		}
	}
d855 1
a855 1
	return (error);
@


1.151
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.150 2002/10/10 17:27:40 dhartmei Exp $	*/
a70 4
#ifdef vax
#include <machine/mtpr.h>
#endif

a1491 1
#ifndef	vax
d1494 1
a1494 1
#endif
@


1.150
log
@Missing m_pullup() and mbuf corruption. This potentially caused

  panic: m_copym0: m == 0 and not COPYALL
    and/or
  panic: m_copydata: null muf

on bridges running pf with scrubbing enabled.

Bug report, test vector and confirmation by Jon Morby.
ok jason@@, jasoni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.149 2002/06/24 23:57:28 itojun Exp $	*/
d446 1
a446 1
		      (ifp->if_flags & IFF_BROADCAST) == 0)) && (sproto == 0))  {
@


1.149
log
@skip routing table lookup if multicasting/broadcasting and the outgoing
interface is specified by setsockopt.  from freebsd4, sync with kame
(it makes difference when you run routed with RIPv2 enabled - no need for
224/4 route)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.148 2002/06/04 21:48:14 jasoni Exp $	*/
d737 1
a737 1
	for (m = m0; m; m = m0) {
@


1.149.2.1
log
@Pull in patch from current:
Fix (dhartmei):
Missing m_pullup() and mbuf corruption. This potentially caused

panic: m_copym0: m == 0 and not COPYALL
and/or
panic: m_copydata: null muf

on bridges running pf with scrubbing enabled.

Bug report, test vector and confirmation by Jon Morby.
ok jason@@, jasoni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.149 2002/06/24 23:57:28 itojun Exp $	*/
d737 1
a737 1
	for (; m; m = m0) {
@


1.148
log
@spaces to tabs, remove trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.147 2002/05/31 20:58:25 itojun Exp $	*/
d213 6
d375 6
d423 1
a423 1
		if (imo != NULL) {
d425 1
a425 5
			if (imo->imo_multicast_ifp != NULL) {
				ifp = imo->imo_multicast_ifp;
				mtu = ifp->if_mtu;
			}
		} else
d427 10
@


1.147
log
@respect rmx_mtu (cached PMTUD result) on outbound.  deraadt/angelos ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.146 2002/05/31 02:41:44 angelos Exp $	*/
d174 1
a174 1
	        donerouting = 1;
d176 2
a177 2
	        if (ro == 0) {
		        ro = &iproute;
d189 1
a189 1
		        RTFREE(ro->ro_rt);
d194 1
a194 1
		        dst->sin_family = AF_INET;
d203 1
a203 1
		        if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
d214 2
a215 2
		        if (ro->ro_rt == 0)
			        rtalloc(ro);
d218 1
a218 1
			        ipstat.ips_noroute++;
d230 1
a230 1
			        dst = satosin(ro->ro_rt->rt_gateway);
d234 2
a235 2
                if (!IN_MULTICAST(ip->ip_dst.s_addr))
		        ip->ip_src = ia->ia_addr.sin_addr;
d264 1
a264 1
	        splx(s);
d267 1
a267 1
		        /*
d271 1
a271 1
		        sproto = 0;
d275 1
a275 1
		        /*
d280 1
a280 1
		        if (error == -EINVAL) /* Should silently drop packet */
d305 2
a306 2
	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
d319 1
a319 1
		}	
d332 2
a333 2
	        if (ro == 0) {
		        ro = &iproute;
d345 1
a345 1
		        RTFREE(ro->ro_rt);
d350 1
a350 1
		        dst->sin_family = AF_INET;
d359 1
a359 1
		        if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
d370 2
a371 2
		        if (ro->ro_rt == 0)
			        rtalloc(ro);
d374 1
a374 1
			        ipstat.ips_noroute++;
d386 1
a386 1
			        dst = satosin(ro->ro_rt->rt_gateway);
d427 1
a427 1
		     ((m->m_flags & M_BCAST) && 
d533 3
a535 3
        /*
         * If we're doing Path MTU discovery, we need to set DF unless
         * the route's MTU is locked.
d540 1
a540 1
		
d546 1
a546 1
	        s = splnet();
d581 1
a581 1
			
d1063 1
a1063 1
			if (optval < IPSEC_LEVEL_BYPASS || 
d1086 1
a1086 1
			        if (optval < ipsec_auth_default_level &&
d1095 1
a1095 1
			        if (optval < ipsec_esp_trans_default_level &&
d1104 1
a1104 1
			        if (optval < ipsec_esp_network_default_level &&
d1112 1
a1112 1
			        if (optval < ipsec_ipcomp_default_level &&
d1114 1
a1114 1
				        error = EACCES;
d1381 1
a1381 1
			        optval = inp->inp_seclevel[SL_IPCOMP];
@


1.146
log
@Socket-related IPsec sockoptions --- cleanups etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.145 2002/05/28 17:01:43 jasoni Exp $	*/
d116 1
d211 1
d225 2
d367 1
d381 2
d413 1
a413 1
			if (imo->imo_multicast_ifp != NULL)
d415 2
d670 1
a670 1
	if ((u_int16_t)ip->ip_len <= ifp->if_mtu) {
d715 1
a715 1
	error = ip_fragment(m, ifp);
d746 1
a746 1
ip_fragment(struct mbuf *m, struct ifnet *ifp)
d757 1
a757 1
	len = (ifp->if_mtu - hlen) &~ 7;
@


1.145
log
@kill register; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.144 2002/05/28 15:44:28 jasoni Exp $	*/
d560 1
a566 4
		/* Latch to PCB */
		if (inp)
		        tdb_add_inp(tdb, inp, 0);

d1140 5
a1144 3
					if (inp->inp_ipsec_localid != NULL)
						ipsp_reffree(inp->inp_ipsec_localid);
					inp->inp_ipsec_localid = NULL;
d1148 5
a1152 3
					if (inp->inp_ipsec_remoteid != NULL)
						ipsp_reffree(inp->inp_ipsec_remoteid);
					inp->inp_ipsec_remoteid = NULL;
d1156 5
a1160 3
					if (inp->inp_ipsec_localcred != NULL)
						ipsp_reffree(inp->inp_ipsec_localcred);
					inp->inp_ipsec_localcred = NULL;
d1164 5
a1168 3
					if (inp->inp_ipsec_localauth != NULL)
						ipsp_reffree(inp->inp_ipsec_localauth);
					inp->inp_ipsec_localauth = NULL;
d1182 10
d1199 1
d1215 3
a1217 3
					if (inp->inp_ipsec_localid != NULL)
						ipsp_reffree(inp->inp_ipsec_localid);
					inp->inp_ipsec_localid = ipr;
d1228 3
a1230 3
					if (inp->inp_ipsec_remoteid != NULL)
						ipsp_reffree(inp->inp_ipsec_remoteid);
					inp->inp_ipsec_remoteid = ipr;
d1239 3
a1241 3
					if (inp->inp_ipsec_localcred != NULL)
						ipsp_reffree(inp->inp_ipsec_localcred);
					inp->inp_ipsec_localcred = ipr;
d1250 3
a1252 3
					if (inp->inp_ipsec_localauth != NULL)
						ipsp_reffree(inp->inp_ipsec_localauth);
					inp->inp_ipsec_localauth = ipr;
d1389 1
d1392 2
a1393 1
				ipr = inp->inp_ipsec_localid;
d1397 2
a1398 1
				ipr = inp->inp_ipsec_remoteid;
d1402 2
a1403 1
				ipr = inp->inp_ipsec_localcred;
d1411 2
a1412 1
				ipr = inp->inp_ipsec_localauth;
@


1.144
log
@Factor out IP fragmentation code into its own function so it can be
reused.
- ok jason@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.143 2002/03/15 18:19:52 millert Exp $	*/
d102 2
a103 2
	register struct ip *ip;
	register struct ifnet *ifp;
d105 1
a105 1
	register int hlen = sizeof (struct ip);
d430 1
a430 1
			register struct in_ifaddr *ia;
d845 1
a845 1
	register struct mbuf *m;
d849 1
a849 1
	register struct ipoption *p = mtod(opt, struct ipoption *);
d851 1
a851 1
	register struct ip *ip = mtod(m, struct ip *);
d893 1
a893 1
	register u_char *cp, *dp;
d941 3
a943 3
	register struct inpcb *inp = sotoinpcb(so);
	register struct mbuf *m = *mp;
	register int optval = 0;
d1429 1
a1429 1
	register struct mbuf *m;
d1431 2
a1432 2
	register int cnt, optlen;
	register u_char *cp;
d1534 1
a1534 1
	register int error = 0;
d1536 1
a1536 1
	register int i;
d1538 3
a1540 3
	register struct ip_mreq *mreq;
	register struct ifnet *ifp;
	register struct ip_moptions *imo = *imop;
d1542 1
a1542 1
	register struct sockaddr_in *dst;
d1767 2
a1768 2
	register struct ip_moptions *imo;
	register struct mbuf **mp;
d1815 1
a1815 1
	register struct ip_moptions *imo;
d1817 1
a1817 1
	register int i;
d1835 2
a1836 2
	register struct mbuf *m;
	register struct sockaddr_in *dst;
d1838 1
a1838 1
	register struct ip *ip;
@


1.143
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.142 2002/03/14 01:27:11 millert Exp $	*/
d102 1
a102 1
	register struct ip *ip, *mhip;
d106 1
a106 1
	int len, off, error = 0;
d708 3
a710 3
	len = (ifp->if_mtu - hlen) &~ 7;
	if (len < 8) {
		error = EMSGSIZE;
d712 9
d723 32
d764 2
a765 3
    {
	int mhlen, firstlen = len;
	struct mbuf **mnext = &m->m_nextpkt;
a775 1
			error = ENOBUFS;
d777 1
a777 1
			goto sendorfree;
a800 1
			error = ENOBUFS;	/* ??? */
d802 1
a802 1
			goto sendorfree;
a833 10
sendorfree:
	for (m = m0; m; m = m0) {
		m0 = m->m_nextpkt;
		m->m_nextpkt = 0;
		if (error == 0)
			error = (*ifp->if_output)(ifp, m, sintosa(dst),
			    ro->ro_rt);
		else
			m_freem(m);
	}
d835 1
a835 14
	if (error == 0)
		ipstat.ips_fragmented++;
    }
done:
	if (ro == &iproute && (flags & IP_ROUTETOIF) == 0 && ro->ro_rt)
		RTFREE(ro->ro_rt);
	return (error);
bad:
#ifdef IPSEC
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0)
		ipsec_adjust_mtu(m, icmp_mtu);
#endif
	m_freem(m0);
	goto done;
@


1.142
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.141 2002/01/23 21:34:53 provos Exp $	*/
a99 1
#if __STDC__
a100 5
#else
ip_output(m0, va_alist)
	struct mbuf *m0;
	va_dcl
#endif
@


1.141
log
@disable pmtu for ipsec when the sysctl says so; bug report cjkim2000@@yahoo.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.140 2001/11/26 16:50:26 jasoni Exp $	*/
d82 1
a82 1
extern u_int8_t get_sa_require  __P((struct inpcb *));
d90 2
a91 3
static struct mbuf *ip_insertoptions __P((struct mbuf *, struct mbuf *, int *));
static void ip_mloopback
	__P((struct ifnet *, struct mbuf *, struct sockaddr_in *));
@


1.140
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.139 2001/11/24 19:29:06 deraadt Exp $	*/
d578 1
a578 1
		if ((ip->ip_off & IP_DF) && tdb->tdb_mtu &&
d823 1
a823 1
	if (error == EMSGSIZE && icmp_mtu != 0)
@


1.140.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.141 2002/01/23 21:34:53 provos Exp $	*/
d578 1
a578 1
		if (ip_mtudisc && (ip->ip_off & IP_DF) && tdb->tdb_mtu &&
d823 1
a823 1
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0)
@


1.140.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.140.2.1 2002/01/31 22:55:45 niklas Exp $	*/
d82 1
a82 1
extern u_int8_t get_sa_require(struct inpcb *);
d90 3
a92 2
static struct mbuf *ip_insertoptions(struct mbuf *, struct mbuf *, int *);
static void ip_mloopback(struct ifnet *, struct mbuf *, struct sockaddr_in *);
d101 1
d103 5
d109 2
a110 2
	struct ip *ip;
	struct ifnet *ifp;
d112 2
a113 2
	int hlen = sizeof (struct ip);
	int len, error = 0;
a122 1
	u_long mtu;
d180 1
a180 1
		donerouting = 1;
d182 2
a183 2
		if (ro == 0) {
			ro = &iproute;
d195 1
a195 1
			RTFREE(ro->ro_rt);
d200 1
a200 1
			dst->sin_family = AF_INET;
d209 1
a209 1
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
a216 1
			mtu = ifp->if_mtu;
d219 2
a220 2
			if (ro->ro_rt == 0)
				rtalloc(ro);
d223 1
a223 1
				ipstat.ips_noroute++;
a229 2
			if ((mtu = ro->ro_rt->rt_rmx.rmx_mtu) == 0)
				mtu = ifp->if_mtu;
d233 1
a233 1
				dst = satosin(ro->ro_rt->rt_gateway);
d237 2
a238 2
		if (!IN_MULTICAST(ip->ip_dst.s_addr))
			ip->ip_src = ia->ia_addr.sin_addr;
d267 1
a267 1
		splx(s);
d270 1
a270 1
			/*
d274 1
a274 1
			sproto = 0;
d278 1
a278 1
			/*
d283 1
a283 1
			if (error == -EINVAL) /* Should silently drop packet */
d308 2
a309 2
		/* We need to do IPsec */
		bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
d322 1
a322 1
		}
d335 2
a336 2
		if (ro == 0) {
			ro = &iproute;
d348 1
a348 1
			RTFREE(ro->ro_rt);
d353 1
a353 1
			dst->sin_family = AF_INET;
d362 1
a362 1
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
a369 1
			mtu = ifp->if_mtu;
d372 2
a373 2
			if (ro->ro_rt == 0)
				rtalloc(ro);
d376 1
a376 1
				ipstat.ips_noroute++;
a382 2
			if ((mtu = ro->ro_rt->rt_rmx.rmx_mtu) == 0)
				mtu = ifp->if_mtu;
d386 1
a386 1
				dst = satosin(ro->ro_rt->rt_gateway);
d413 1
a413 1
			if (imo->imo_multicast_ifp != NULL) {
a414 2
				mtu = ifp->if_mtu;
			}
d425 1
a425 1
		     ((m->m_flags & M_BCAST) &&
d437 1
a437 1
			struct in_ifaddr *ia;
d531 3
a533 3
	/*
	 * If we're doing Path MTU discovery, we need to set DF unless
	 * the route's MTU is locked.
d538 1
a538 1

d544 1
a544 1
		s = splnet();
a566 1
			DPRINTF(("ip_output: unknown TDB"));
d573 4
d582 1
a582 1

d671 1
a671 1
	if ((u_int16_t)ip->ip_len <= mtu) {
d715 3
a717 3

	error = ip_fragment(m, ifp, mtu);
	if (error == EMSGSIZE)
a718 9

	for (m = m0; m; m = m0) {
		m0 = m->m_nextpkt;
		m->m_nextpkt = 0;
		if (error == 0)
			error = (*ifp->if_output)(ifp, m, sintosa(dst),
			    ro->ro_rt);
		else
			m_freem(m);
a720 32
	if (error == 0)
		ipstat.ips_fragmented++;

done:
	if (ro == &iproute && (flags & IP_ROUTETOIF) == 0 && ro->ro_rt)
		RTFREE(ro->ro_rt);
	return (error);
bad:
#ifdef IPSEC
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0)
		ipsec_adjust_mtu(m, icmp_mtu);
#endif
	m_freem(m0);
	goto done;
}

int
ip_fragment(struct mbuf *m, struct ifnet *ifp, u_long mtu)
{
	struct ip *ip, *mhip;
	struct mbuf *m0;
	int len, hlen, off;
	int mhlen, firstlen;
	struct mbuf **mnext;

	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;

	len = (mtu - hlen) &~ 7;
	if (len < 8)
		return (EMSGSIZE);

d730 3
a732 2
	firstlen = len;
	mnext = &m->m_nextpkt;
d743 1
d745 1
a745 1
			return (ENOBUFS);
d769 1
d771 1
a771 1
			return (ENOBUFS);	/* ??? */
d803 10
d814 14
a827 1
	return (0);
d837 1
a837 1
	struct mbuf *m;
d841 1
a841 1
	struct ipoption *p = mtod(opt, struct ipoption *);
d843 1
a843 1
	struct ip *ip = mtod(m, struct ip *);
d885 1
a885 1
	u_char *cp, *dp;
d933 3
a935 3
	struct inpcb *inp = sotoinpcb(so);
	struct mbuf *m = *mp;
	int optval = 0;
d1049 1
a1049 1
			if (optval < IPSEC_LEVEL_BYPASS ||
d1072 1
a1072 1
				if (optval < ipsec_auth_default_level &&
d1081 1
a1081 1
				if (optval < ipsec_esp_trans_default_level &&
d1090 1
a1090 1
				if (optval < ipsec_esp_network_default_level &&
d1098 1
a1098 1
				if (optval < ipsec_ipcomp_default_level &&
d1100 1
a1100 1
					error = EACCES;
d1135 3
a1137 5
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_srcid != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_srcid);
						inp->inp_ipo->ipo_srcid = NULL;
					}
d1141 3
a1143 5
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_dstid != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_dstid);
						inp->inp_ipo->ipo_dstid = NULL;
					}
d1147 3
a1149 5
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_local_cred != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_local_cred);
						inp->inp_ipo->ipo_local_cred = NULL;
					}
d1153 3
a1155 5
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_local_auth != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_local_auth);
						inp->inp_ipo->ipo_local_auth = NULL;
					}
a1168 10
			/* Allocate if needed */
			if (inp->inp_ipo == NULL) {
				inp->inp_ipo = ipsec_add_policy(inp,
				    AF_INET, IPSP_DIRECTION_OUT);
				if (inp->inp_ipo == NULL) {
					error = ENOBUFS;
					break;
				}
			}

a1175 1

d1191 3
a1193 3
					if (inp->inp_ipo->ipo_srcid != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_srcid);
					inp->inp_ipo->ipo_srcid = ipr;
d1204 3
a1206 3
					if (inp->inp_ipo->ipo_dstid != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_dstid);
					inp->inp_ipo->ipo_dstid = ipr;
d1215 3
a1217 3
					if (inp->inp_ipo->ipo_local_cred != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_local_cred);
					inp->inp_ipo->ipo_local_cred = ipr;
d1226 3
a1228 3
					if (inp->inp_ipo->ipo_local_auth != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_local_auth);
					inp->inp_ipo->ipo_local_auth = ipr;
d1348 1
a1348 1
				optval = inp->inp_seclevel[SL_IPCOMP];
a1364 1
			ipr = NULL;
d1367 1
a1367 2
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_srcid;
d1371 1
a1371 2
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_dstid;
d1375 1
a1375 2
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_local_cred;
d1383 1
a1383 2
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_local_auth;
d1421 1
a1421 1
	struct mbuf *m;
d1423 2
a1424 2
	int cnt, optlen;
	u_char *cp;
d1526 1
a1526 1
	int error = 0;
d1528 1
a1528 1
	int i;
d1530 3
a1532 3
	struct ip_mreq *mreq;
	struct ifnet *ifp;
	struct ip_moptions *imo = *imop;
d1534 1
a1534 1
	struct sockaddr_in *dst;
d1759 2
a1760 2
	struct ip_moptions *imo;
	struct mbuf **mp;
d1807 1
a1807 1
	struct ip_moptions *imo;
d1809 1
a1809 1
	int i;
d1827 2
a1828 2
	struct mbuf *m;
	struct sockaddr_in *dst;
d1830 1
a1830 1
	struct ip *ip;
@


1.140.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.140.2.2 2002/06/11 03:31:36 art Exp $	*/
a212 6
		} else if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
		    (ip->ip_dst.s_addr == INADDR_BROADCAST)) &&
		    imo != NULL && imo->imo_multicast_ifp != NULL) {
			ifp = imo->imo_multicast_ifp;
			mtu = ifp->if_mtu;
			IFP_TO_IA(ifp, ia);
a368 6
		} else if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
		    (ip->ip_dst.s_addr == INADDR_BROADCAST)) &&
		    imo != NULL && imo->imo_multicast_ifp != NULL) {
			ifp = imo->imo_multicast_ifp;
			mtu = ifp->if_mtu;
			IFP_TO_IA(ifp, ia);
d411 1
a411 1
		if (imo != NULL)
d413 5
a417 1
		else
a420 10
		 * if we don't know the outgoing ifp yet, we can't generate
		 * output
		 */
		if (!ifp) {
			ipstat.ips_noroute++;
			error = EHOSTUNREACH;
			goto bad;
		}

		/*
d719 1
a719 1
	for (; m; m = m0) {
@


1.140.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 4
d446 1
a446 1
		      (ifp->if_flags & IFF_BROADCAST) == 0)) && (sproto == 0)) {
d1496 1
d1499 1
a1499 1

@


1.139
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.138 2001/11/02 21:42:19 deraadt Exp $	*/
d557 4
d661 3
@


1.138
log
@fix multicast loopback checksums; goeran@@cdg.chalmers.se, ok angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.137 2001/08/26 21:12:06 niklas Exp $	*/
d700 3
a702 3
		if ((ro->ro_rt->rt_flags & (RTF_UP | RTF_HOST))
		    && !(ro->ro_rt->rt_rmx.rmx_locks & RTV_MTU)
		    && (ro->ro_rt->rt_rmx.rmx_mtu > ifp->if_mtu)) {
d1178 3
a1180 3
				if (ipr->ref_type < IPSP_IDENTITY_PREFIX
				    || ipr->ref_type > IPSP_IDENTITY_CONNECTION
				    || ((char *)(ipr + 1))[ipr->ref_len - 1]) {
d1191 3
a1193 3
				if (ipr->ref_type < IPSP_IDENTITY_PREFIX
				    || ipr->ref_type > IPSP_IDENTITY_CONNECTION
				    || ((char *)(ipr + 1))[ipr->ref_len - 1]) {
@


1.137
log
@Uninitialized variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.136 2001/08/22 14:18:36 niklas Exp $	*/
d455 2
d458 6
@


1.136
log
@IPCOMP policy stuff missed the last time round
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.135 2001/08/21 06:53:36 angelos Exp $	*/
d569 1
a569 1
			struct rtentry *rt;
@


1.135
log
@Don't check for BYPASS options in PCB on ip_output/ip6_output --- this
is already done in ip_spd_lookup()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.134 2001/07/17 20:34:50 provos Exp $	*/
d1024 1
@


1.134
log
@split ip normalization out into a separate file, okay dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.133 2001/07/05 16:45:55 jjbg Exp $	*/
a289 18
		/*
		 * If the socket has set the bypass flags and SA
		 * destination matches the IP destination, skip
		 * IPsec. This allows IKE packets to travel through
		 * IPsec tunnels.
		 */
		if ((inp != NULL) &&
		    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS) &&
		    (inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS) &&
		    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS)
		    && (inp->inp_seclevel[SL_IPCOMP] == IPSEC_LEVEL_BYPASS)
		    && (sdst.sa.sa_family == AF_INET) &&
		    (sdst.sin.sin_addr.s_addr == ip->ip_dst.s_addr)) {
			splx(s);
			sproto = 0; /* mark as no-IPsec-needed */
			goto done_spd;
		}

@


1.133
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.132 2001/06/29 18:36:17 beck Exp $	*/
a53 4
#if NPF > 0
#include <net/pfvar.h>
#endif

d66 4
@


1.132
log
@move pf_test check to happen after checksum calculation - without
this packets originating from this host (such as with an rdr to localhost
for transparent proxying) do not get checksummed correctly, because the
pf code does not have a correct checksum to fix up (ok kjell@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.131 2001/06/28 21:53:42 provos Exp $	*/
d87 1
d300 1
d1099 8
d1331 1
d1348 3
@


1.131
log
@first stab at packet normalization.  includes full ip reassembly.
okay dhartmei@@, dugsong@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.130 2001/06/27 03:49:53 angelos Exp $	*/
a640 12
	/*
	 * Packet filter
	 */
#if NPF > 0
	if (pf_test(PF_OUT, ifp, &m) != PF_PASS) {
		error = EHOSTUNREACH;
		m_freem(m);
		goto done;
	}
	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;
#endif
d655 13
@


1.130
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.129 2001/06/27 02:52:40 angelos Exp $	*/
d110 1
a110 1
	register struct mbuf *m = m0;
d558 2
a559 1
		if (pf_test(PF_OUT, &encif[0].sc_if, m) != PF_PASS) {
d565 1
d645 1
a645 1
	if (pf_test(PF_OUT, ifp, m) != PF_PASS) {
d650 2
@


1.129
log
@Add length to pkthdr.len directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.128 2001/06/27 01:34:07 angelos Exp $	*/
d851 1
a851 1
		M_COPY_HDR(n, m);
@


1.128
log
@Don't cache packets that hit policies -- we'll do that at the PCB for
local packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.127 2001/06/26 18:17:54 deraadt Exp $	*/
d852 1
a852 1
		n->m_pkthdr.len = m->m_pkthdr.len + optlen;
@


1.127
log
@no longer pass around **m
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.126 2001/06/25 17:16:23 angelos Exp $	*/
a169 21
#ifdef IPSEC
	s = splnet();

	/*
	 * If the higher-level protocol has cached the SA to use, we
	 * can avoid the routing lookup if the source address is zero.
	 */
	if (inp != NULL && inp->inp_tdb_out != NULL &&
	    ip->ip_src.s_addr == INADDR_ANY) {
		tdb = inp->inp_tdb_out;
		if (tdb->tdb_src.sa.sa_family == AF_INET &&
		    tdb->tdb_src.sin.sin_addr.s_addr != INADDR_ANY) {
			ip->ip_src.s_addr = tdb->tdb_src.sin.sin_addr.s_addr;
			splx(s);
			goto skip_routing;
		}
	}

	splx(s);
#endif /* IPSEC */

a240 1
 skip_routing:
d247 3
a249 13
	/*
	 * Check if there was an outgoing SA bound to the flow
	 * from a transport protocol.
	 */
	if (inp && inp->inp_tdb_out &&
	    inp->inp_tdb_out->tdb_dst.sa.sa_family == AF_INET &&
	    !bcmp(&inp->inp_tdb_out->tdb_dst.sin.sin_addr,
	        &ip->ip_dst, sizeof(ip->ip_dst)))
	        tdb = inp->inp_tdb_out;
	else {
		/* Do we have any pending SAs to apply ? */
		mtag = m_tag_find(m, PACKET_TAG_IPSEC_PENDING_TDB, NULL);
		if (mtag != NULL) {
d251 3
a253 4
			if (mtag->m_tag_len != sizeof (struct tdb_ident))
				panic("ip_output: tag of length %d (should "
				    "be %d", mtag->m_tag_len,
				    sizeof (struct tdb_ident));
d255 5
a259 9
			tdbi = (struct tdb_ident *)(mtag + 1);
			tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
			if (tdb == NULL)
				error = -EINVAL;
			m_tag_delete(m, mtag);
		}
		else
			tdb = ipsp_spd_lookup(m, AF_INET, hlen, &error,
			    IPSP_DIRECTION_OUT, NULL, inp);
d261 3
@


1.126
log
@If a PENDING_TDB tag is attached but no TDB is found, drop the packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.125 2001/06/25 06:14:05 angelos Exp $	*/
d592 5
a596 10
		{
			struct mbuf *m1 = m;
			if (pf_test(PF_OUT, &encif[0].sc_if, &m1) != PF_PASS) {
				error = EHOSTUNREACH;
				splx(s);
				m_freem(m1);
				goto done;
			}
			ip = mtod(m = m1, struct ip *);
			hlen = ip->ip_hl << 2;
d598 1
d677 4
a680 8
	{
		struct mbuf *m1 = m;
		if (pf_test(PF_OUT, ifp, &m1) != PF_PASS) {
			error = EHOSTUNREACH;
			m_freem(m1);
			goto done;
		}
		ip = mtod(m = m1, struct ip *);
@


1.125
log
@Check the length of the tag (diagnostic)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.124 2001/06/25 06:09:42 angelos Exp $	*/
d290 2
@


1.124
log
@Apply pending TDBs (as indicated by tags). This will be used to handle
the case of both the socket and system-wide IPsec policy specifying
TDBs to be applied to the same packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.123 2001/06/25 02:54:44 angelos Exp $	*/
d282 6
@


1.123
log
@Don't double-clear M_PKTHDR/tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.122 2001/06/25 02:03:18 angelos Exp $	*/
d278 12
a289 3
	else
	        tdb = ipsp_spd_lookup(m, AF_INET, hlen, &error,
		    IPSP_DIRECTION_OUT, NULL, inp);
@


1.122
log
@Remove unnecessary temporary variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.121 2001/06/25 01:59:29 angelos Exp $	*/
a876 2
		m_tag_init(m);
		m->m_flags &= ~M_PKTHDR;
@


1.121
log
@Always defer output TCP checksumming until ip_output() (or hardware,
if it exists). Cuts down on code a bit, and we don't need to look at
the routing entry at TCP. Based on NetBSD. UDP case to follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.120 2001/06/25 01:21:15 provos Exp $	*/
a575 1
			void *ifp = (void *)&encif[0].sc_if;
d577 1
a577 1
			if (pf_test(PF_OUT, ifp, &m1) != PF_PASS) {
@


1.120
log
@put pf before ipsec processing.  return error code and free mbuf chain
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.119 2001/06/24 23:42:40 mickey Exp $	*/
d67 3
d676 12
a687 10
	if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT &&
	    !(ifp->if_capabilities & IFCAP_CSUM_TCPv4)) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
	}

	if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT &&
	    !(ifp->if_capabilities & IFCAP_CSUM_UDPv4)) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
d704 5
d1870 1
a1870 1
	csum = in4_cksum(m, 0, offset, ntohs(ip->ip_len) - offset);
@


1.119
log
@make it compile w/o pf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.118 2001/06/24 23:38:48 angelos Exp $	*/
d51 1
d568 18
d664 3
a666 1
		if (pf_test(PF_OUT, ifp, &m1) != PF_PASS)
d668 1
@


1.118
log
@Sync in4_cksum() with NetBSD, and change its use in in_delayed_cksum.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.117 2001/06/24 23:33:56 angelos Exp $	*/
d39 2
d52 2
d55 1
d642 1
d649 1
a649 1

@


1.117
log
@Import in_delayed_cksum() and convert to using it; also, don't do
TCP/UDP HW checksumming if doing IP fragmentation. From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.116 2001/06/24 22:24:30 angelos Exp $	*/
d1832 1
a1832 1
	csum = in4_cksum(m, ip->ip_p, offset, ntohs(ip->ip_len) - offset);
@


1.116
log
@Also reset input cached TDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.115 2001/06/24 22:21:50 angelos Exp $	*/
a112 1
	short csums;
d341 6
a346 16
		 */ 
		if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT &&
		    !(ifp->if_capabilities & IFCAP_CSUM_TCPv4)) {
			csums = in4_cksum(m, IPPROTO_TCP, 0, m->m_pkthdr.len);
			m_copyback(m, hlen + offsetof(struct tcphdr, th_sum),
			    sizeof(short), (caddr_t)&csums);
			m->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
		}

		if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT &&
		    !(ifp->if_capabilities & IFCAP_CSUM_UDPv4)) {
			csums = in4_cksum(m, IPPROTO_UDP, 0, m->m_pkthdr.len);
			m_copyback(m, hlen + offsetof(struct udphdr, uh_sum),
			    sizeof(short), (caddr_t)&csums);
			m->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
		}
d647 1
a647 3
		csums = in4_cksum(m, IPPROTO_TCP, 0, m->m_pkthdr.len);
		m_copyback(m, hlen + offsetof(struct tcphdr, th_sum),
		    sizeof(short), (caddr_t)&csums);
d653 1
a653 3
		csums = in4_cksum(m, IPPROTO_UDP, 0, m->m_pkthdr.len);
		m_copyback(m, hlen + offsetof(struct udphdr, uh_sum),
		    sizeof(short), (caddr_t)&csums);
d705 9
d1819 34
@


1.115
log
@Reset
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.114 2001/06/24 19:48:58 kjell Exp $	*/
d1054 7
d1221 7
@


1.114
log
@Initial import of pf, an all-new ipf-compatable packet filter.
Insane amounts of work done my dhartmei. Great work!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.113 2001/06/24 18:24:11 provos Exp $	*/
d1045 9
a1053 1
				
d1207 8
@


1.113
log
@check if ipsec processing increases packet size above allowable mtu.
store correct mtu in routing table.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.112 2001/06/23 16:15:56 fgsch Exp $	*/
d50 1
d644 10
@


1.112
log
@Remove unneeded ip_id convertions.
Instead of using HTONS macro in some places, use htons directly in the
struct member and save us a few bytes.
Fix comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.111 2001/06/23 07:13:03 angelos Exp $	*/
d46 1
d57 1
d114 1
d584 30
d684 3
d801 4
@


1.111
log
@Only use IP checksumming if the output interface is not in bridge
mode. We can't deal with that well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.110 2001/06/23 07:03:27 angelos Exp $	*/
d151 1
a151 2
		ip->ip_id = ip_randomid();
		HTONS(ip->ip_id);
@


1.110
log
@m_copyback(), not m_copydata()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.109 2001/06/23 06:42:37 angelos Exp $	*/
d635 2
a636 1
		if (ifp->if_capabilities & IFCAP_CSUM_IPv4) {
d720 2
a721 1
		if (ifp->if_capabilities & IFCAP_CSUM_IPv4)
d723 2
a724 1
		else {
d739 2
a740 1
	if (ifp->if_capabilities & IFCAP_CSUM_IPv4)
d742 2
a743 1
	else {
@


1.109
log
@Software-compute TCP/UDP checksum if we are going to do IPsec or if the
output interface does not support hardware checksumming.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.108 2001/06/23 06:13:42 angelos Exp $	*/
d343 1
a343 1
			m_copydata(m, hlen + offsetof(struct tcphdr, th_sum),
d351 1
a351 1
			m_copydata(m, hlen + offsetof(struct udphdr, uh_sum),
d616 1
a616 1
		m_copydata(m, hlen + offsetof(struct tcphdr, th_sum),
d624 1
a624 1
		m_copydata(m, hlen + offsetof(struct udphdr, uh_sum),
@


1.108
log
@Placeholder, reminder to fix TCP/UDP checksumming right before doing IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.107 2001/06/23 05:55:40 angelos Exp $	*/
d56 2
d110 1
d342 3
a344 1
			/* XXX Compute TCP checksum */
d350 3
a352 1
			/* XXX Compute UDP checksum */
d615 3
a617 1
		/* XXX Compute TCP checksum */
d623 3
a625 1
		/* XXX Compute UDP checksum */
@


1.107
log
@Count input/output hardware-checksummed IP packets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.106 2001/06/23 03:10:21 provos Exp $	*/
d332 16
@


1.106
log
@fix up mtu for routes and ongoing tcp connection when if mtu changes
from FreeBSD; fixes pr/1878
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.105 2001/06/23 02:27:10 angelos Exp $	*/
d589 13
d608 1
a608 1
		if (ifp->if_capabilities & IFCAP_CSUM_IPv4)
d610 2
a611 1
		else {
a616 13
	}

	/* Catch routing changes. */
	if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT &&
	    !(ifp->if_capabilities & IFCAP_CSUM_TCPv4)) {
		/* XXX Compute TCP checksum */
		m->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
	}

	if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT &&
	    !(ifp->if_capabilities & IFCAP_CSUM_UDPv4)) {
		/* XXX Compute UDP checksum */
		m->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
@


1.105
log
@TCP, UDP, IPv4 input hardware checksumming processing; also IPv4
output hardware checksumming. Not tested yet, but should be done
tonight.

Remain to be solved: interactions with bridge, TCP/UDP output
checksumming, interactions of TCP/UDP checksumming with routing
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.104 2001/06/19 18:49:53 jasoni Exp $	*/
d624 12
@


1.104
log
@revert parts that were meant to be committed (June 12th commit)
- ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.103 2001/06/14 18:00:02 provos Exp $	*/
d595 6
a600 2
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, hlen);
d605 13
d679 6
a684 2
		mhip->ip_sum = 0;
		mhip->ip_sum = in_cksum(m, mhlen);
d696 6
a701 2
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(m, hlen);
@


1.103
log
@limited broadcast 255.255.255.255 was not recognized correctly, reported
by crh@@ubiqx.mn.org, fix from NetBSD; okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.102 2001/06/12 10:59:53 angelos Exp $	*/
d809 1
d929 1
a929 1
				    (so->so_state & SS_PRIV)) {
d938 1
a938 1
				    (so->so_state & SS_PRIV)) {
d947 1
a947 1
				    (so->so_state & SS_PRIV)) {
@


1.102
log
@IPsec-related socket options; these can be set/removed/retrieved, but
are not taken into consideration in anything just yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.101 2001/06/08 03:53:46 angelos Exp $	*/
d403 2
a404 1
	if (IN_MULTICAST(ip->ip_dst.s_addr)) {
d407 2
a408 1
		m->m_flags |= M_MCAST;
d432 4
a435 1
		if (((ifp->if_flags & IFF_MULTICAST) == 0) && (sproto == 0)) {
@


1.101
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.100 2001/06/05 11:05:08 angelos Exp $	*/
d804 2
a805 1
	struct proc *p = curproc; /* XXX */
d923 1
a923 1
				    suser(p->p_ucred, &p->p_acflag)) {
d932 1
a932 1
				    suser(p->p_ucred, &p->p_acflag)) {
d941 1
a941 1
				    suser(p->p_ucred, &p->p_acflag)) {
d953 6
d962 1
a962 2
		case IP_IPSEC_REMOTE_CRED:
		case IP_IPSEC_AUTH:
d966 58
d1026 11
a1036 1
				/* XXX */
d1039 11
a1049 1
				/* XXX */
d1052 9
a1060 1
				/* XXX */
d1062 10
a1071 5
			case IP_IPSEC_REMOTE_CRED:
				/* XXX */
				break;
			case IP_IPSEC_AUTH:
				/* XXX */
d1181 2
a1182 1
		case IP_IPSEC_AUTH:
d1186 2
d1190 2
a1191 1
				/* XXX */
d1194 2
a1195 1
				/* XXX */
d1198 2
a1199 1
				/* XXX */
d1202 5
a1206 1
				/* XXX */
d1208 2
a1209 2
			case IP_IPSEC_AUTH:
				/* XXX */
d1211 8
@


1.100
log
@That debug message was just too chatty, even as a debug message :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.99 2001/05/30 12:20:42 angelos Exp $	*/
d40 1
a40 1
#include <sys/malloc.h>
a41 1
#include <sys/errno.h>
a44 5
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>

#include <vm/vm.h>
a60 2
#include <machine/stdarg.h>

a61 7
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <net/pfkeyv2.h>
#include <net/if_enc.h>

@


1.99
log
@Update to match prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.98 2001/05/30 02:12:34 deraadt Exp $	*/
a337 1
				DPRINTF(("ip_output: IPsec loop detected, skipping further IPsec processing for this packet.\n"));
@


1.98
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.97 2001/05/29 01:09:14 angelos Exp $	*/
d581 1
a581 2
		/* XXX Last argument should be used */
		error = ipsp_process_packet(m, tdb, AF_INET, 0, NULL);
@


1.97
log
@Make sure packets that need crypto processing on the NIC don't escape
(because of routing changes etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.96 2001/05/28 05:30:54 angelos Exp $	*/
a92 3
#if defined(IPFILTER) || defined(IPFILTER_LKM)
int (*fr_checkp) __P((struct ip *, int, struct ifnet *, int, struct mbuf **));
#endif
a557 23
#if defined(IPFILTER) || defined(IPFILTER_LKM)
		if (fr_checkp) {
			/*
			 * Ok, it's time for a simple round-trip to the IPF/NAT
			 * code with the enc0 interface.
			 */
			struct mbuf *m0 = m;
			void *ifp = (void *)&encif[0].sc_if;
			if ((*fr_checkp)(ip, hlen, ifp, 1, &m0)) {
				error = EHOSTUNREACH;
				splx(s);
				goto done;
			}
			if (m0 == 0) { /* in case of 'fastroute' */
				error = 0;
				splx(s);
				goto done;
			}
			ip = mtod(m = m0, struct ip *);
			hlen = ip->ip_hl << 2;
  	        }
#endif /* IPFILTER */
		
a600 17
#if defined(IPFILTER) || defined(IPFILTER_LKM)
	/*
	 * looks like most checking has been done now...do a filter check
	 */
	{
		struct mbuf *m0 = m;
		if (fr_checkp && (*fr_checkp)(ip, hlen, ifp, 1, &m0)) {
			error = EHOSTUNREACH;
			goto done;
		}
		if (m0 == 0) { /* in case of 'fastroute' */
			error = 0;
			goto done;
		}
		ip = mtod(m = m0, struct ip *);
	}
#endif
@


1.96
log
@Don't check IP_ENCAPSULATED.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.95 2001/05/27 11:50:37 angelos Exp $	*/
d563 18
a580 18
		    /*
		     * Ok, it's time for a simple round-trip to the IPF/NAT
		     * code with the enc0 interface
		     */
		    struct mbuf *m0 = m;
		    void *ifp = (void *)&encif[0].sc_if;
		    if ((*fr_checkp)(ip, hlen, ifp, 1, &m0)) {
			error = EHOSTUNREACH;
			splx(s);
			goto done;
		    }
		    if (m0 == 0) { /* in case of 'fastroute' */
			error = 0;
			splx(s);
			goto done;
		    }
		    ip = mtod(m = m0, struct ip *);
		    hlen = ip->ip_hl << 2;
d611 13
@


1.95
log
@And clear the M_PKTHDR flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.94 2001/05/27 11:48:35 angelos Exp $	*/
a266 5

	/* Disallow nested IPsec for now */
	if (flags & IP_ENCAPSULATED)
	  goto done_spd;

@


1.94
log
@Copy tags to first mbuf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.93 2001/05/27 05:27:49 angelos Exp $	*/
d774 1
@


1.93
log
@Placeholders for the new socket options.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.92 2001/05/27 00:39:26 angelos Exp $	*/
d772 2
@


1.92
log
@Use the new IPsec tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.91 2001/05/20 08:34:29 angelos Exp $	*/
d343 1
a343 1
			        sizeof(union sockaddr_union))) {
a861 1

d954 1
a954 1
			error = EINVAL;
d1001 27
d1127 27
@


1.91
log
@Record outgoing SA processing, do loop detection.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.90 2001/05/16 12:53:36 ho Exp $	*/
d333 6
a338 2
		for (mtag = m_tag_find(m, PACKET_TAG_IPSEC_DONE, NULL); mtag;
		     mtag = m_tag_find(m, PACKET_TAG_IPSEC_DONE, mtag)) {
d346 1
a346 1
				DPRINTF(("ip_output: IPsec loop detected, skipping further IPsec processing.\n"));
@


1.90
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.89 2001/04/14 00:30:59 angelos Exp $	*/
d129 2
d285 1
a285 1
		  &ip->ip_dst, sizeof(ip->ip_dst)))
d289 1
a289 1
				      IPSP_DIRECTION_OUT, NULL, inp);
d330 15
@


1.89
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.88 2001/04/06 04:42:08 csapuntz Exp $	*/
a1226 2
		if (imo == NULL)
			return (ENOBUFS);
@


1.88
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.87 2001/03/28 20:03:04 angelos Exp $	*/
d591 2
a592 1
		error = ipsp_process_packet(m, tdb, AF_INET, 0);
@


1.87
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.86 2001/03/07 23:19:54 aaron Exp $	*/
a80 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.86
log
@More careful spl usage for the IPSEC case in ip_output(); from angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.85 2000/12/03 19:56:20 angelos Exp $	*/
d183 1
a183 1
	if (inp != NULL && inp->inp_tdb != NULL &&
d185 1
a185 1
		tdb = inp->inp_tdb;
d284 3
a286 3
	if (inp && inp->inp_tdb &&
	    inp->inp_tdb->tdb_dst.sa.sa_family == AF_INET &&
	    !bcmp(&inp->inp_tdb->tdb_dst.sin.sin_addr,
d288 1
a288 1
	        tdb = inp->inp_tdb;
d553 1
a553 1
		     * code with the enc# interface
d556 1
a556 3
		    void *ifp = tdb->tdb_interface ?
				(void *)tdb->tdb_interface :
				      (void *)&encif[0].sc_if;
d579 4
@


1.85
log
@Fix fastroute-related panic, fixes PR 1541 (cas@@trans-nt.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.84 2000/11/07 18:24:26 provos Exp $	*/
a316 5
	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;

d329 1
a329 1
		        splx(s);
d333 6
@


1.84
log
@initialize tdb pointer correctly, from Jean-Jacques.Bernard@@hsc.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.83 2000/10/25 22:40:40 aaron Exp $	*/
a561 3
		    } else {
			ip = mtod(m = m0, struct ip *);
			hlen = ip->ip_hl << 2;
d563 7
d576 1
d607 6
a612 2
		} else
			ip = mtod(m = m0, struct ip *);
@


1.83
log
@Do not null deref in the IPSEC+PMTU case; provos@@ ok. Thanks to
andrews@@crt.se for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.82 2000/09/29 03:51:11 angelos Exp $	*/
d184 8
a191 6
	    ip->ip_src.s_addr == INADDR_ANY &&
	    tdb->tdb_src.sa.sa_family == AF_INET &&
	    tdb->tdb_src.sin.sin_addr.s_addr != INADDR_ANY) {
	        ip->ip_src.s_addr = tdb->tdb_src.sin.sin_addr.s_addr;
		splx(s);
		goto skip_routing;
@


1.83.2.1
log
@Pull in patch from current:
Fix (provos):
initialize tdb pointer correctly, from Jean-Jacques.Bernard@@hsc.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.83 2000/10/25 22:40:40 aaron Exp $	*/
d184 6
a189 8
	    ip->ip_src.s_addr == INADDR_ANY) {
		tdb = inp->inp_tdb;
		if (tdb->tdb_src.sa.sa_family == AF_INET &&
		    tdb->tdb_src.sin.sin_addr.s_addr != INADDR_ANY) {
			ip->ip_src.s_addr = tdb->tdb_src.sin.sin_addr.s_addr;
			splx(s);
			goto skip_routing;
		}
@


1.83.2.2
log
@Pull in patch from current:
Fix (angelos):
Fix fastroute-related panic, fixes PR 1541 (cas@@trans-nt.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.83.2.1 2000/11/11 05:15:34 jason Exp $	*/
d562 3
a565 7
		    if (m0 == 0) { /* in case of 'fastroute' */
			error = 0;
			splx(s);
			goto done;
		    }
		    ip = mtod(m = m0, struct ip *);
		    hlen = ip->ip_hl << 2;
a571 1
			splx(s);
d602 2
a603 6
		}
		if (m0 == 0) { /* in case of 'fastroute' */
			error = 0;
			goto done;
		}
		ip = mtod(m = m0, struct ip *);
@


1.82
log
@Outgoing packets that hit IPsec will be IPF/IPNAT processed as well on
the enc* interface, usually enc0; cedric@@wireless-networks.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.81 2000/09/19 03:20:59 angelos Exp $	*/
d535 1
a535 1
	if ((flags & IP_MTUDISC) && ro->ro_rt &&
@


1.81
log
@Lots and lots of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.80 2000/09/18 22:06:37 provos Exp $	*/
d75 1
d546 21
@


1.80
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.79 2000/07/29 22:51:22 angelos Exp $	*/
a132 1
	u_int8_t sa_require = 0, sa_have = 0;
d287 2
a288 1
	        tdb = ipsp_spd_lookup(m, AF_INET, hlen, &error);
d320 11
a330 11
		 * If the socket has set the bypass flags and SA destination
		 * matches the IP destination, skip IPsec. This allows
		 * IKE packets to travel through IPsec tunnels.
		 */
		if (inp != NULL && 
		    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS &&
		    inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS &&
		    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS &&
		    sdst.sa.sa_family == AF_INET &&
		    !bcmp(&sdst.sin.sin_addr.s_addr, &ip->ip_dst.s_addr,
			  sizeof(ip->ip_dst.s_addr))) {
d332 1
a332 1
		        sproto = 0; /* mark as no-IPsec-needed */
a335 18
		/* What are the socket (or default) security requirements ? */
		if (inp == NULL)
		        sa_require = get_sa_require(NULL);
		else
		        sa_require = inp->inp_secrequire;

		/*
		 * Now we check if this tdb has all the transforms which
		 * are required by the socket or our default policy.
		 */
		SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdb);
		splx(s);
		if (sa_require & ~sa_have) {
			error = EHOSTUNREACH;
			m_freem(m);
			goto done;
		}

a554 1
		ip->ip_sum = 0;
a799 3
	struct tdb *tdb;
	struct tdb_ident *tdbip, tdbi;
	int s;
a896 20
		case IPSEC_OUTSA:
#ifndef IPSEC
			error = EINVAL;
#else
			s = spltdb();
			if (m == 0 || m->m_len != sizeof(struct tdb_ident)) {
				error = EINVAL;
			} else {
				tdbip = mtod(m, struct tdb_ident *);
				tdb = gettdb(tdbip->spi, &tdbip->dst,
				    tdbip->proto);
				if (tdb == NULL)
					error = ESRCH;
				else
					tdb_add_inp(tdb, inp);
			}
			splx(s);
#endif /* IPSEC */
			break;

a1022 20
			break;

		case IPSEC_OUTSA:
#ifndef IPSEC
			error = EINVAL;
#else
			s = spltdb();
			if (inp->inp_tdb == NULL) {
				error = ENOENT;
			} else {
				tdbi.spi = inp->inp_tdb->tdb_spi;
				tdbi.dst = inp->inp_tdb->tdb_dst;
				tdbi.proto = inp->inp_tdb->tdb_sproto;
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
				m->m_len = sizeof(tdbi);
				bcopy((caddr_t)&tdbi, mtod(m, caddr_t),
				    (unsigned)m->m_len);
			}
			splx(s);
#endif /* IPSEC */
@


1.79
log
@Don't set the source IP address if doing multicast; this is a quick
fix -- the logic has to be reworked to allow for
multicast-over-IPsec. Patch from gene@@lucky.net.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.78 2000/06/21 17:25:04 form Exp $	*/
d548 8
@


1.78
log
@Fix gateway function; ok angelos@@
angelos, be more careful :)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.77 2000/06/20 01:45:56 angelos Exp $	*/
d261 2
a262 1
		ip->ip_src = ia->ia_addr.sin_addr;
@


1.77
log
@Big oops on my previous commit, broke gateway function; patch from
form@@openbsd.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.76 2000/06/18 21:54:40 angelos Exp $	*/
d261 1
a261 2
                if (ip->ip_src.s_addr == INADDR_ANY)
		        ip->ip_src = ia->ia_addr.sin_addr;
d419 2
a420 1
		ip->ip_src = ia->ia_addr.sin_addr;
@


1.76
log
@Oops on checking inp_tdb etc. (itojun@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.75 2000/06/18 07:30:45 itojun Exp $	*/
d261 2
a262 1
		ip->ip_src = ia->ia_addr.sin_addr;
@


1.75
log
@sanity check: panic if AF_INET6 inpcb is passed to ip_output
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.74 2000/06/18 07:13:50 itojun Exp $	*/
d185 3
a187 3
	    tdb->tdb_dst.sa.sa_family == AF_INET &&
	    tdb->tdb_dst.sin.sin_addr.s_addr != AF_INET) {
	        ip->ip_src.s_addr = tdb->tdb_dst.sin.sin_addr.s_addr;
@


1.74
log
@remove obsolete IP_DF handling from KAME tree (#if 0'ed all the time)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.73 2000/06/18 07:06:17 itojun Exp $	*/
d146 2
@


1.73
log
@for mcdonald-simple-ipsec-api get/setsockopt, variable size was mixed up.
in some place sizeof(u_char), and in some place sizeof(int) were used.
previous code can cause problem in big endian machines.
now it always uses "int" (isakmpd uses int, so it should be okay)

set m_len properly on mcdonald-simple-ipsec-api getsockopt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.72 2000/06/17 23:50:45 angelos Exp $	*/
a604 10
#if 0
	/*
	 * If IPsec packet is too big for the interface, try fragment it.
	 * XXX This really is a quickhack.  May be inappropriate.
	 * XXX fails if somebody is sending AH'ed packet, with:
	 *	sizeof(packet without AH) < mtu < sizeof(packet with AH)
	 */
	if (sab && ip->ip_p != IPPROTO_AH && (flags & IP_FORWARDING) == 0)
		ip->ip_off &= ~IP_DF;
#endif /*IPSEC*/
@


1.72
log
@Change processing sequence:
 - if the source IP address if unset (INADDR_ANY)
   - if higher level protocol has cached the SA to use, and the SA specifies
     the source address, use that
   - otherwise, do a routing lookup to determine our outgoing interface
     and fix the source address
 - do an SPD lookup (which is why we needed the source address)
   - if no IPsec is needed, proceed to multicast processing (if necessary),
     IPF, etc. -- transmit the packet as usual; use the routing information
     from before (if routing lookup was performed), or do a routing lookup
     at this point.
   - if IPsec is needed, do multicast processing (if needed), then do
     IPsec processing, then call ip_output() recursively. Currently,
     the second invocation does not do another SPD lookup (it will be
     changed to do so in the near future, to support independent nested
     tunnels without infinite loops).

Note that if the inner packet (the one that will have IPsec applied to) is
multicast or broadcast, the interface flags are not checked (since it's not
clear what their meaning is in this case). If the IPsec destination address
is multicast/broadcast, the interface flags are checked of course.

It is no longer necessary to have routing entries for private networks on
IPsec gateways (or default routing entries if they're not needed, for that
matter).

Finally, this patch solves a problem with ever-increasing reference counts
on routing entries when doing IPsec processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.71 2000/06/01 04:47:55 angelos Exp $	*/
d947 1
a947 1
			optval = *mtod(m, u_char *);
d1089 1
d1092 1
d1095 2
a1096 2
				    optval = inp->inp_seclevel[SL_AUTH];
				    break;
d1099 2
a1100 2
				    optval = inp->inp_seclevel[SL_ESP_TRANS];
				    break;
d1103 2
a1104 2
				    optval = inp->inp_seclevel[SL_ESP_NETWORK];
				    break;
@


1.71
log
@Use the cached entry for security requirements from the inp.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.70 2000/06/01 04:38:34 angelos Exp $	*/
d128 1
d130 3
d157 1
d159 1
d174 3
d178 2
a179 1
	 * Route packet.
d181 7
a187 3
	if (ro == 0) {
		ro = &iproute;
		bzero((caddr_t)ro, sizeof (*ro));
d189 4
a192 1
	dst = satosin(&ro->ro_dst);
d194 6
a199 3
	 * If there is a cached route,
	 * check that it is to the same destination
	 * and is still up.  If not, free it and try again.
d201 59
a259 9
	if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
	    dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
		RTFREE(ro->ro_rt);
		ro->ro_rt = (struct rtentry *)0;
	}
	if (ro->ro_rt == 0) {
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = ip->ip_dst;
d261 14
d276 2
a277 2
	 * If routing to interface only,
	 * short circuit routing lookup.
d279 30
a308 6
	if (flags & IP_ROUTETOIF) {
		if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
		    (ia = ifatoia(ifa_ifwithnet(sintosa(dst)))) == 0) {
			ipstat.ips_noroute++;
			error = ENETUNREACH;
			goto bad;
a309 2
		ifp = ia->ia_ifp;
		ip->ip_ttl = 1;
d311 68
a378 2
		if (ro->ro_rt == 0)
			rtalloc(ro);
d380 34
a413 3
			ipstat.ips_noroute++;
			error = EHOSTUNREACH;
			goto bad;
d415 3
a417 5
		ia = ifatoia(ro->ro_rt->rt_ifa);
		ifp = ro->ro_rt->rt_ifp;
		ro->ro_rt->rt_use++;
		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			dst = satosin(ro->ro_rt->rt_gateway);
d419 1
d424 1
d431 1
d441 1
d443 3
a445 1
		 * Confirm that the outgoing interface supports multicast.
d447 1
a447 1
		if ((ifp->if_flags & IFF_MULTICAST) == 0) {
d452 1
d460 3
a462 1
			for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next)
d518 1
a518 1
#ifndef notdef
d520 3
a522 2
	 * If source address not specified yet, use address
	 * of outgoing interface.
d524 1
a524 9
	if (ip->ip_src.s_addr == INADDR_ANY)
		ip->ip_src = ia->ia_addr.sin_addr;
#endif
	/*
	 * Look for broadcast address and
	 * and verify user is allowed to send
	 * such a packet.
	 */
	if (in_broadcast(dst->sin_addr, ifp)) {
d533 2
a534 1
		/* don't allow broadcast messages to be fragmented */
d548 2
a549 27
	if (!(flags & IP_ENCAPSULATED) &&
	    (inp == NULL || 
	     inp->inp_seclevel[SL_AUTH] != IPSEC_LEVEL_BYPASS ||
	     inp->inp_seclevel[SL_ESP_TRANS] != IPSEC_LEVEL_BYPASS ||
	     inp->inp_seclevel[SL_ESP_NETWORK] != IPSEC_LEVEL_BYPASS)) {
	        if (inp == NULL)
		        sa_require = get_sa_require(NULL);
		else
		        sa_require = inp->inp_secrequire;

		/*
		 * Check if there was an outgoing SA bound to the flow
		 * from a transport protocol.
		 */
		if (inp && inp->inp_tdb &&
		    (inp->inp_tdb->tdb_dst.sin.sin_addr.s_addr == INADDR_ANY ||
		     !bcmp(&inp->inp_tdb->tdb_dst.sin.sin_addr,
			   &ip->ip_dst, sizeof(ip->ip_dst)))) {
			tdb = inp->inp_tdb;
			goto have_tdb;
		}

		/*
		 * splnet is chosen over spltdb because we are not allowed to
		 * lower the level, and udp_output calls us in splnet().
		 */
		s = splnet();
d551 1
a551 2
		/* SPD lookup */
		tdb = ipsp_spd_lookup(m, AF_INET, hlen, &error);
d553 1
a553 7
		        splx(s);
			if (error == 0) /* No IPsec processing required */
			  goto no_encap;

			if (error == -EINVAL) /* Should silently drop packet */
			  error = 0;

a557 1
	     have_tdb:
d564 2
a565 2
		 * Now we check if this tdb has all the transforms which
		 * are required by the socket or our default policy.
d567 1
a567 5
		SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdb);
		if (sa_require & ~sa_have) {
		        splx(s);
			goto no_encap;
		}
a572 8

no_encap:
		/* No IPSec processing though it was required, drop packet */
		if (sa_require) {
			error = EHOSTUNREACH;
			m_freem(m);
			goto done;
		}
@


1.70
log
@Use ipsp_spd_lookup() in ip_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.69 2000/05/15 11:07:33 itojun Exp $	*/
d88 3
a99 6
#ifdef IPSEC
extern int ipsec_auth_default_level;
extern int ipsec_esp_trans_default_level;
extern int ipsec_esp_network_default_level;
#endif

d349 4
a352 1
	        sa_require = get_sa_require(inp);
@


1.69
log
@parse IPv4 options more carefully.  make boundary checks against every
steps (including option type/length field - there were no checks, seems to
me 4.4BSD bug)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.68 2000/05/04 20:15:38 niklas Exp $	*/
d132 1
a132 1
	union sockaddr_union sunion;
d134 1
a134 4

	struct route_enc re0, *re = &re0;
	struct sockaddr_encap *ddst, *gw;
	u_int8_t sa_require, sa_have = 0;
a135 1
	struct tdb *tdb, tdb2;
d352 1
a352 12
		if (inp == NULL)
			sa_require = get_sa_require(inp);
		else
			sa_require = inp->inp_secrequire;

		bzero((caddr_t) re, sizeof(*re));

		/*
		 * splnet is chosen over spltdb because we are not allowed to
		 * lower the level, and udp_output calls us in splnet().
		 */
		s = splnet();
d367 2
a368 2
		 * If there are no flows in place, there's no point
		 * continuing with the SPD lookup.
d370 1
a370 4
		if (!ipsec_in_use) {
			splx(s);
			goto no_encap;
		}
d372 6
a377 40
		/*
		 * Do an SPD lookup -- this code should probably be moved
		 * to a separate function.
		 */
		ddst = (struct sockaddr_encap *) &re->re_dst;
		ddst->sen_family = PF_KEY;
		ddst->sen_len = SENT_IP4_LEN;
		ddst->sen_type = SENT_IP4;
		ddst->sen_ip_src = ip->ip_src;
		ddst->sen_ip_dst = ip->ip_dst;
		ddst->sen_proto = ip->ip_p;

		/* If TCP/UDP, extract the port numbers to use in the lookup */
		switch (ip->ip_p) {
		case IPPROTO_UDP:
		case IPPROTO_TCP:
		    /*
		     * Luckily, the offset of the src/dst ports in both the UDP
		     * and TCP headers is the same (first two 16-bit values
		     * in the respective headers), so we can just copy them.
		     */
		    m_copydata(m, hlen, sizeof(u_int16_t),
			       (caddr_t) &ddst->sen_sport);
		    m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			       (caddr_t) &ddst->sen_dport);
		    break;

		default:
			ddst->sen_sport = 0;
			ddst->sen_dport = 0;
		}

		/* Actual SPD lookup */
		rtalloc((struct route *) re);
		if (re->re_rt == NULL) {
			splx(s);
			goto no_encap;
		}

		gw = (struct sockaddr_encap *) (re->re_rt->rt_gateway);
d379 2
a380 5
		/* Sanity check */
		if (gw == NULL || ((gw->sen_type != SENT_IPSP) &&
				   (gw->sen_type != SENT_IPSP6))) {
			splx(s);
		        DPRINTF(("ip_output(): no gw or gw data not IPSP\n"));
a381 3
			if (re->re_rt)
				RTFREE(re->re_rt);
			error = EHOSTUNREACH;
a385 195
		/*
		 * There might be a specific route, that tells us to avoid
		 * doing IPsec; this is useful for specific routes that we
		 * don't want to have IPsec applied on, like the key
		 * management ports.
		 */

		if ((gw != NULL) && (gw->sen_ipsp_sproto == 0) &&
		    (gw->sen_ipsp_spi == 0)) {
		    if ((gw->sen_family == AF_INET) &&
			(gw->sen_ipsp_dst.s_addr == 0)) {
			splx(s);
			goto no_encap;
		    }

#ifdef INET6
		    if ((gw->sen_family == AF_INET6) &&
			IN6_IS_ADDR_UNSPECIFIED(&gw->sen_ipsp6_dst)) {
			splx(s);
			goto no_encap;
		    }
#endif /* INET6 */
		}

		/*
		 * At this point we have an IPSP "gateway" (tunnel) spec.
		 * Use the destination of the tunnel and the SPI to
		 * look up the necessary Tunnel Control Block. Look it up,
		 * and then pass it, along with the packet and the gw,
		 * to the appropriate transformation.
		 */
		bzero(&sunion, sizeof(sunion));

		if (gw->sen_type == SENT_IPSP) {
		    sunion.sin.sin_family = AF_INET;
		    sunion.sin.sin_len = sizeof(struct sockaddr_in);
		    sunion.sin.sin_addr = gw->sen_ipsp_dst;
		}
#ifdef INET6
		if (gw->sen_type == SENT_IPSP6) {
		    sunion.sin6.sin6_family = AF_INET6;
		    sunion.sin6.sin6_len = sizeof(struct sockaddr_in6);
		    sunion.sin6.sin6_addr = gw->sen_ipsp6_dst;
		}
#endif /* INET6 */

		/* Lookup in the TDB table */
		tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, &sunion,
					    gw->sen_ipsp_sproto);

		/* Bypass the SA acquisition if that is what we want. */
		if (tdb && tdb->tdb_satype == SADB_X_SATYPE_BYPASS)
		{
		    splx(s);
		    goto no_encap;
		}

		/* 
		 * For VPNs a route with a reserved SPI is used to
		 * indicate the need for an SA when none is established.
		 */
		if (((ntohl(gw->sen_ipsp_spi) == SPI_LOCAL_USE) &&
		     (gw->sen_type == SENT_IPSP)) ||
		    ((ntohl(gw->sen_ipsp6_spi) == SPI_LOCAL_USE) &&
		     (gw->sen_type == SENT_IPSP6))) {
		    if (tdb == NULL) {
			/* We will just use system defaults. */
			tdb = &tdb2;
			bzero(&tdb2, sizeof(tdb2));

			/* Default entry is for ESP */
			sa_require = NOTIFY_SATYPE_CONF | NOTIFY_SATYPE_AUTH;
			tdb2.tdb_satype = SADB_SATYPE_ESP;
		    } else {
			if (tdb->tdb_authalgxform)
			  sa_require = NOTIFY_SATYPE_AUTH;
			if (tdb->tdb_encalgxform)
			  sa_require |= NOTIFY_SATYPE_CONF;
			if (tdb->tdb_flags & TDBF_TUNNELING)
			  sa_require |= NOTIFY_SATYPE_TUNNEL;
		    }

		    /* Check whether Perfect Forward Secrect is required */
		    if (ipsec_require_pfs)
		      tdb->tdb_flags |= TDBF_PFS;
		    else
		      tdb->tdb_flags &= ~TDBF_PFS;

		    /* Initialize expirations */
		    if (ipsec_soft_allocations > 0) 
		      tdb->tdb_soft_allocations = ipsec_soft_allocations;
		    else
		      tdb->tdb_soft_allocations = 0;

		    if (ipsec_exp_allocations > 0)
		      tdb->tdb_exp_allocations = ipsec_exp_allocations;
		    else
		      tdb->tdb_exp_allocations = 0;

		    if (ipsec_soft_bytes > 0)
		      tdb->tdb_soft_bytes = ipsec_soft_bytes;
		    else
		      tdb->tdb_soft_bytes = 0;

		    if (ipsec_exp_bytes > 0)
		      tdb->tdb_exp_bytes = ipsec_exp_bytes;
		    else
		      tdb->tdb_exp_bytes = 0;

		    if (ipsec_soft_timeout > 0)
		      tdb->tdb_soft_timeout = ipsec_soft_timeout;
		    else
		      tdb->tdb_soft_timeout = 0;

		    if (ipsec_exp_timeout > 0)
		      tdb->tdb_exp_timeout = ipsec_exp_timeout;
		    else
		      tdb->tdb_exp_timeout = 0;

		    if (ipsec_soft_first_use > 0)
		      tdb->tdb_soft_first_use = ipsec_soft_first_use;
		    else
		      tdb->tdb_soft_first_use = 0;

		    if (ipsec_exp_first_use > 0)
		      tdb->tdb_exp_first_use = ipsec_exp_first_use;
		    else
		      tdb->tdb_exp_first_use = 0;

		    /* 
		     * If we don't have an existing desired encryption
		     * algorithm, use the default.
		     */
		    if ((tdb->tdb_encalgxform == NULL) &&
			(tdb->tdb_satype & NOTIFY_SATYPE_CONF))
		    {
			if (!strncasecmp(ipsec_def_enc, "des", sizeof("des")))
			  tdb->tdb_encalgxform = &enc_xform_des;
			else
			  if (!strncasecmp(ipsec_def_enc, "3des",
					   sizeof("3des")))
			    tdb->tdb_encalgxform = &enc_xform_3des;
			  else
			    if (!strncasecmp(ipsec_def_enc, "blowfish",
					     sizeof("blowfish")))
			      tdb->tdb_encalgxform = &enc_xform_blf;
			    else
			      if (!strncasecmp(ipsec_def_enc, "cast128",
					       sizeof("cast128")))
				tdb->tdb_encalgxform = &enc_xform_cast5;
			      else
				if (!strncasecmp(ipsec_def_enc, "skipjack",
						 sizeof("skipjack")))
				  tdb->tdb_encalgxform = &enc_xform_skipjack;
		    }

		    /*
		     * If we don't have an existing desired authentication
		     * algorithm, use the default.
		     */
		    if ((tdb->tdb_authalgxform == NULL) && 
			(tdb->tdb_satype & NOTIFY_SATYPE_AUTH))
		    {
			if (!strncasecmp(ipsec_def_auth, "hmac-md5",
					 sizeof("hmac-md5")))
			  tdb->tdb_authalgxform = &auth_hash_hmac_md5_96;
			else
			  if (!strncasecmp(ipsec_def_auth, "hmac-sha1",
					   sizeof("hmac-sha1")))
			    tdb->tdb_authalgxform = &auth_hash_hmac_sha1_96;
			  else
			    if (!strncasecmp(ipsec_def_auth, "hmac-ripemd160",
					     sizeof("hmac_ripemd160")))
			      tdb->tdb_authalgxform = 
						 &auth_hash_hmac_ripemd_160_96;
		    }

		    /* XXX Initialize src_id/dst_id */

		    /* PF_KEYv2 notification message */
		    if ((error = pfkeyv2_acquire(tdb, 0)) != 0)
		    {
			splx(s);
			return error;
		    }

		    splx(s);

		    /* 
		     * When sa_require is set, the packet will be dropped
		     * at no_encap.
		     */
		    goto no_encap;
		}

a386 22

		if (tdb == NULL) {
			splx(s);
			if (gw->sen_type == SENT_IPSP)
			        DPRINTF(("ip_output(): non-existant TDB for SA %s/%08x/%u\n", inet_ntoa4(gw->sen_ipsp_dst), ntohl(gw->sen_ipsp_spi), gw->sen_ipsp_sproto));

#ifdef INET6
			if (gw->sen_type == SENT_IPSP6)
			        DPRINTF(("ip_output(): non-existant TDB for SA %s/%08x/%u\n", inet6_ntoa4(gw->sen_ipsp6_dst), ntohl(gw->sen_ipsp6_spi), gw->sen_ipsp6_sproto));
#endif /* INET6 */	  

			error = EHOSTUNREACH;
			m_freem(m);
			goto done;
		}

		/* We don't need this anymore */
		if (re->re_rt) {
			RTFREE(re->re_rt);
			re->re_rt = NULL;
		}

a407 4
		/* This is for possible future use, don't move or delete */
		if (re->re_rt)
			RTFREE(re->re_rt);

@


1.68
log
@Bypass routes only worked for one packet, then they effectively became a
filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.67 2000/04/13 19:22:57 art Exp $	*/
d899 10
a908 2
		} else
			optlen = cp[IPOPT_OLEN];
d1292 2
d1295 1
a1295 1
			if (optlen <= IPOPT_OLEN || optlen > cnt)
@


1.68.2.1
log
@Pull in patch from current:
Errata:
Parse IPv4 options more carefully. It is not yet clear if this can even be
used to crash the machine remote or locally.
Fix (itojun):
parse IPv4 options more carefully.  make boundary checks against every
steps (including option type/length field - there were no checks, seems to
me 4.4BSD bug)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.69 2000/05/15 11:07:33 itojun Exp $	*/
d899 2
a900 10
		}
#ifdef DIAGNOSTIC
		if (cnt < IPOPT_OLEN + sizeof(*cp))
			panic("malformed IPv4 option passed to ip_optcopy");
#endif
		optlen = cp[IPOPT_OLEN];
#ifdef DIAGNOSTIC
		if (optlen < IPOPT_OLEN + sizeof(*cp) || optlen > cnt)
			panic("malformed IPv4 option passed to ip_optcopy");
#endif
a1283 2
			if (cnt < IPOPT_OLEN + sizeof(*cp))
				goto bad;
d1285 1
a1285 1
			if (optlen < IPOPT_OLEN  + sizeof(*cp) || optlen > cnt)
@


1.67
log
@When fragmenting a packet, inherit the multicast and broadcast flags so that
the link layer can choose the right address.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.66 2000/03/30 04:53:36 angelos Exp $	*/
d494 7
d624 5
a628 3
		    if (tdb && tdb->tdb_satype != SADB_X_SATYPE_BYPASS)
		            if ((error = pfkeyv2_acquire(tdb, 0)) != 0)
			            return error;
@


1.66
log
@Set re_rt to NULL, so we don't double free.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.65 2000/03/17 10:25:22 angelos Exp $	*/
d759 2
@


1.65
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.64 2000/01/11 03:10:04 angelos Exp $	*/
d648 1
a648 1
		if (re->re_rt)
d650 2
@


1.64
log
@Correct sa_require handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.63 2000/01/11 01:03:23 angelos Exp $	*/
a132 3
	struct mbuf *mp;
	struct udphdr *udp;
	struct tcphdr *tcp;
d138 1
a138 1
	int s, protoflag = AF_INET;
a139 4

#ifdef INET6
	struct ip6_hdr *ip6;
#endif /* INET6 */
d381 4
d390 4
a393 1
		/* Do an SPD lookup */
d402 1
a404 11
			if (m->m_len < hlen + 2 * sizeof(u_int16_t)) {
				if ((m = m_pullup(m, hlen + 2 *
				    sizeof(u_int16_t))) == 0)
					return ENOBUFS;
				ip = mtod(m, struct ip *);
			}
			udp = (struct udphdr *) (mtod(m, u_char *) + hlen);
			ddst->sen_sport = udp->uh_sport;
			ddst->sen_dport = udp->uh_dport;
			break;

d406 10
a415 10
			if (m->m_len < hlen + 2 * sizeof(u_int16_t)) {
				if ((m = m_pullup(m, hlen + 2 *
				    sizeof(u_int16_t))) == 0)
					return ENOBUFS;
				ip = mtod(m, struct ip *);
			}
			tcp = (struct tcphdr *) (mtod(m, u_char *) + hlen);
			ddst->sen_sport = tcp->th_sport;
			ddst->sen_dport = tcp->th_dport;
			break;
d422 1
d490 1
d519 1
a519 1
		    /* Check for PFS */
a631 15
		ip->ip_len = htons((u_short) ip->ip_len);
		ip->ip_off = htons((u_short) ip->ip_off);
		ip->ip_sum = 0;

		/*
		 * Now we check if this tdb has all the transforms which
		 * are requried by the socket or our default policy.
		 */
		SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdb);

		if (sa_require & ~sa_have) {
		        splx(s);
			goto no_encap;
		}

a641 2
			if (re->re_rt)
                        	RTFREE(re->re_rt);
d647 3
a649 10
		error = ipsp_process_packet(m, &mp, tdb, &protoflag, 0);
		if ((mp == NULL) && (!error))
		        error = ENOBUFS;
		if (error) {
			if (re->re_rt)
                        	RTFREE(re->re_rt);
			if (mp)
			        m_freem(mp);
			goto done;
		}
d651 4
a654 4
		m = mp;
		mp = NULL;

		splx(s);
d657 2
a658 3
		 * At this point, m is pointing to an mbuf chain with the
		 * processed packet. Call ourselves recursively, but
		 * bypass the encap code.
d660 4
a663 11
		if (re->re_rt)
			RTFREE(re->re_rt);

		if (protoflag == AF_INET) {
		    ip = mtod(m, struct ip *);
		    NTOHS(ip->ip_len);
		    NTOHS(ip->ip_off);

		    return ip_output(m, NULL, NULL,
				     IP_ENCAPSULATED | IP_RAWOUTPUT,
				     NULL, NULL);
d666 4
a669 11
#ifdef INET6
		if (protoflag == AF_INET6) {
		    ip6 = mtod(m, struct ip6_hdr *);
		    NTOHS(ip6->ip6_plen);

		    /* Naturally, ip6_output() has to honor those two flags */
		    return ip6_output(m, NULL, NULL,
				     IP_ENCAPSULATED | IP_RAWOUTPUT,
				     NULL, NULL);
		}
#endif /* INET6 */
d675 1
@


1.64.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 3
d141 1
a141 1
	int s;
d143 4
a387 4
		/*
		 * If there are no flows in place, there's no point
		 * continuing with the SPD lookup.
		 */
d393 1
a393 4
		/*
		 * Do an SPD lookup -- this code should probably be moved
		 * to a separate function.
		 */
a401 1
		/* If TCP/UDP, extract the port numbers to use in the lookup */
d404 11
d416 10
a425 10
		    /*
		     * Luckily, the offset of the src/dst ports in both the UDP
		     * and TCP headers is the same (first two 16-bit values
		     * in the respective headers), so we can just copy them.
		     */
		    m_copydata(m, hlen, sizeof(u_int16_t),
			       (caddr_t) &ddst->sen_sport);
		    m_copydata(m, hlen + sizeof(u_int16_t), sizeof(u_int16_t),
			       (caddr_t) &ddst->sen_dport);
		    break;
a431 1
		/* Actual SPD lookup */
a498 1
		/* Lookup in the TDB table */
d527 1
a527 1
		    /* Check whether Perfect Forward Secrect is required */
d640 15
d665 2
d672 13
a684 3
		/* We don't need this anymore */
		if (re->re_rt)
			RTFREE(re->re_rt);
d686 1
a686 4
		/* Massage the IP header for use by the IPsec code */
		ip->ip_len = htons((u_short) ip->ip_len);
		ip->ip_off = htons((u_short) ip->ip_off);
		ip->ip_sum = 0;
d689 3
a691 2
		 * Now we check if this tdb has all the transforms which
		 * are required by the socket or our default policy.
d693 11
a703 4
		SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdb);
		if (sa_require & ~sa_have) {
		        splx(s);
			goto no_encap;
d706 11
a716 4
		/* Callee frees mbuf */
		error = ipsp_process_packet(m, tdb, AF_INET, 0);
		splx(s);
		return error;  /* Nothing more to be done */
a721 1

@


1.64.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.89 2001/04/14 00:30:59 angelos Exp $	*/
a74 1
#include <net/if_enc.h>
d82 4
a87 3
extern int ipsec_auth_default_level;
extern int ipsec_esp_trans_default_level;
extern int ipsec_esp_network_default_level;
d97 6
a130 1
	u_int8_t sproto = 0, donerouting = 0;
d132 2
a133 2
	union sockaddr_union sdst;
	u_int32_t sspi;
d135 3
a137 2
	struct inpcb *inp;
	struct tdb *tdb;
d139 1
a148 2
	if (inp && (inp->inp_flags & INP_IPV6) != 0)
		panic("ip_output: IPv6 pcb is passed");
a159 1

a160 1

a174 3
#ifdef IPSEC
	s = splnet();

d176 1
a176 2
	 * If the higher-level protocol has cached the SA to use, we
	 * can avoid the routing lookup if the source address is zero.
d178 3
a180 9
	if (inp != NULL && inp->inp_tdb_out != NULL &&
	    ip->ip_src.s_addr == INADDR_ANY) {
		tdb = inp->inp_tdb_out;
		if (tdb->tdb_src.sa.sa_family == AF_INET &&
		    tdb->tdb_src.sin.sin_addr.s_addr != INADDR_ANY) {
			ip->ip_src.s_addr = tdb->tdb_src.sin.sin_addr.s_addr;
			splx(s);
			goto skip_routing;
		}
d182 1
a182 4

	splx(s);
#endif /* IPSEC */

d184 3
a186 6
	 * If we're missing the IP source address, do a route lookup. We'll
	 * remember this result, in case we don't need to do any IPsec
	 * processing on the packet. We need the source address so we can
	 * do an SPD lookup in IPsec; for most packets, the source address
	 * is set at a higher level protocol. ICMPs and other packets
	 * though (e.g., traceroute) have a source address of zeroes.
d188 9
a196 60
	if (ip->ip_src.s_addr == INADDR_ANY) {
	        donerouting = 1;

	        if (ro == 0) {
		        ro = &iproute;
			bzero((caddr_t)ro, sizeof (*ro));
		}

		dst = satosin(&ro->ro_dst);

		/*
		 * If there is a cached route, check that it is to the same
		 * destination and is still up.  If not, free it and try again.
		 */
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
				  dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
		        RTFREE(ro->ro_rt);
			ro->ro_rt = (struct rtentry *)0;
		}

		if (ro->ro_rt == 0) {
		        dst->sin_family = AF_INET;
			dst->sin_len = sizeof(*dst);
			dst->sin_addr = ip->ip_dst;
		}

		/*
		 * If routing to interface only, short-circuit routing lookup.
		 */
		if (flags & IP_ROUTETOIF) {
		        if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
			    (ia = ifatoia(ifa_ifwithnet(sintosa(dst)))) == 0) {
			    ipstat.ips_noroute++;
			    error = ENETUNREACH;
			    goto bad;
			}

			ifp = ia->ia_ifp;
			ip->ip_ttl = 1;
		} else {
		        if (ro->ro_rt == 0)
			        rtalloc(ro);

			if (ro->ro_rt == 0) {
			        ipstat.ips_noroute++;
				error = EHOSTUNREACH;
				goto bad;
			}

			ia = ifatoia(ro->ro_rt->rt_ifa);
			ifp = ro->ro_rt->rt_ifp;
			ro->ro_rt->rt_use++;

			if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			        dst = satosin(ro->ro_rt->rt_gateway);
		}

		/* Set the source IP address */
                if (!IN_MULTICAST(ip->ip_dst.s_addr))
		        ip->ip_src = ia->ia_addr.sin_addr;
a197 8

#ifdef IPSEC
 skip_routing:

	/* Disallow nested IPsec for now */
	if (flags & IP_ENCAPSULATED)
	  goto done_spd;

d199 2
a200 2
	 * splnet is chosen over spltdb because we are not allowed to
	 * lower the level, and udp_output calls us in splnet().
d202 6
a207 37
	s = splnet();

	/*
	 * Check if there was an outgoing SA bound to the flow
	 * from a transport protocol.
	 */
	if (inp && inp->inp_tdb_out &&
	    inp->inp_tdb_out->tdb_dst.sa.sa_family == AF_INET &&
	    !bcmp(&inp->inp_tdb_out->tdb_dst.sin.sin_addr,
		  &ip->ip_dst, sizeof(ip->ip_dst)))
	        tdb = inp->inp_tdb_out;
	else
	        tdb = ipsp_spd_lookup(m, AF_INET, hlen, &error,
				      IPSP_DIRECTION_OUT, NULL, inp);

	if (tdb == NULL) {
	        splx(s);

		if (error == 0) {
		        /*
			 * No IPsec processing required, we'll just send the
			 * packet out.
			 */
		        sproto = 0;

			/* Fall through to routing/multicast handling */
		} else {
		        /*
			 * -EINVAL is used to indicate that the packet should
			 * be silently dropped, typically because we've asked
			 * key management for an SA.
			 */
		        if (error == -EINVAL) /* Should silently drop packet */
			  error = 0;

			m_freem(m);
			goto done;
d209 2
d212 2
a213 51
		/*
		 * If the socket has set the bypass flags and SA
		 * destination matches the IP destination, skip
		 * IPsec. This allows IKE packets to travel through
		 * IPsec tunnels.
		 */
		if ((inp != NULL) &&
		    (inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS) &&
		    (inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS) &&
		    (inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS)
		    && (sdst.sa.sa_family == AF_INET) &&
		    (sdst.sin.sin_addr.s_addr == ip->ip_dst.s_addr)) {
			splx(s);
			sproto = 0; /* mark as no-IPsec-needed */
			goto done_spd;
		}

	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;
		splx(s);

		/* If it's not a multicast packet, try to fast-path */
		if (!IN_MULTICAST(ip->ip_dst.s_addr)) {
			goto sendit;
		}
	}

	/* Fall through to the routing/multicast handling code */
 done_spd:
#endif /* IPSEC */

	if (donerouting == 0) {
	        if (ro == 0) {
		        ro = &iproute;
			bzero((caddr_t)ro, sizeof (*ro));
		}

		dst = satosin(&ro->ro_dst);

		/*
		 * If there is a cached route, check that it is to the same
		 * destination and is still up.  If not, free it and try again.
		 */
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
				  dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
		        RTFREE(ro->ro_rt);
			ro->ro_rt = (struct rtentry *)0;
		}

d215 3
a217 34
		        dst->sin_family = AF_INET;
			dst->sin_len = sizeof(*dst);
			dst->sin_addr = ip->ip_dst;
		}

		/*
		 * If routing to interface only, short-circuit routing lookup.
		 */
		if (flags & IP_ROUTETOIF) {
		        if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
			    (ia = ifatoia(ifa_ifwithnet(sintosa(dst)))) == 0) {
			    ipstat.ips_noroute++;
			    error = ENETUNREACH;
			    goto bad;
			}

			ifp = ia->ia_ifp;
			ip->ip_ttl = 1;
		} else {
		        if (ro->ro_rt == 0)
			        rtalloc(ro);

			if (ro->ro_rt == 0) {
			        ipstat.ips_noroute++;
				error = EHOSTUNREACH;
				goto bad;
			}

			ia = ifatoia(ro->ro_rt->rt_ifa);
			ifp = ro->ro_rt->rt_ifp;
			ro->ro_rt->rt_use++;

			if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			        dst = satosin(ro->ro_rt->rt_gateway);
d219 5
a223 4

		/* Set the source IP address */
		if (ip->ip_src.s_addr == INADDR_ANY)
			ip->ip_src = ia->ia_addr.sin_addr;
a224 1

a228 1

a234 1

a243 1

d245 1
a245 3
		 * Confirm that the outgoing interface supports multicast,
		 * but only if the packet actually is going out on that
		 * interface (i.e., no IPsec is applied).
d247 1
a247 1
		if (((ifp->if_flags & IFF_MULTICAST) == 0) && (sproto == 0)) {
a251 1

d259 1
a259 3
			for (ia = in_ifaddr.tqh_first;
			     ia;
			     ia = ia->ia_list.tqe_next)
d315 8
a322 1

d324 3
a326 3
	 * Look for broadcast address and and verify user is allowed to send
	 * such a packet; if the packet is going in an IPsec tunnel, skip
	 * this check.
d328 1
a328 1
	if ((sproto == 0) && (in_broadcast(dst->sin_addr, ifp))) {
d337 1
a337 2

		/* Don't allow broadcast messages to be fragmented */
a346 8
        /*
         * If we're doing Path MTU discovery, we need to set DF unless
         * the route's MTU is locked.
	 */
	if ((flags & IP_MTUDISC) && ro && ro->ro_rt &&
	    (ro->ro_rt->rt_rmx.rmx_locks & RTV_MTU) == 0)
		ip->ip_off |= IP_DF;
		
d351 38
a388 2
	if (sproto != 0) {
	        s = splnet();
d390 16
a405 2
#if defined(IPFILTER) || defined(IPFILTER_LKM)
		if (fr_checkp) {
d407 3
a409 2
		     * Ok, it's time for a simple round-trip to the IPF/NAT
		     * code with the enc0 interface
d411 28
a438 3
		    struct mbuf *m0 = m;
		    void *ifp = (void *)&encif[0].sc_if;
		    if ((*fr_checkp)(ip, hlen, ifp, 1, &m0)) {
d440 15
d456 1
a456 1
			goto done;
d458 4
a461 2
		    if (m0 == 0) { /* in case of 'fastroute' */
			error = 0;
d463 149
a611 1
			goto done;
d613 19
a631 6
		    ip = mtod(m = m0, struct ip *);
		    hlen = ip->ip_hl << 2;
  	        }
#endif /* IPFILTER */
		
		tdb = gettdb(sspi, &sdst, sproto);
d633 9
a642 1
			splx(s);
d647 3
a649 3
		/* Latch to PCB */
		if (inp)
		        tdb_add_inp(tdb, inp, 0);
d654 1
d657 2
a658 2
		 * Clear these -- they'll be set in the recursive invocation
		 * as needed.
d660 5
a664 1
		m->m_flags &= ~(M_MCAST | M_BCAST);
d667 1
a667 2
		/* XXX Last argument should be used */
		error = ipsp_process_packet(m, tdb, AF_INET, 0, NULL);
d670 12
d694 2
a695 6
		}
		if (m0 == 0) { /* in case of 'fastroute' */
			error = 0;
			goto done;
		}
		ip = mtod(m = m0, struct ip *);
d714 10
a756 2
		/* we must inherit MCAST and BCAST flags */
		m->m_flags |= m0->m_flags & (M_MCAST|M_BCAST);
d886 2
a887 10
		}
#ifdef DIAGNOSTIC
		if (cnt < IPOPT_OLEN + sizeof(*cp))
			panic("malformed IPv4 option passed to ip_optcopy");
#endif
		optlen = cp[IPOPT_OLEN];
#ifdef DIAGNOSTIC
		if (optlen < IPOPT_OLEN + sizeof(*cp) || optlen > cnt)
			panic("malformed IPv4 option passed to ip_optcopy");
#endif
d916 3
d1016 20
d1046 1
a1046 1
			optval = *mtod(m, int *);
d1164 20
a1187 1
			m->m_len = sizeof(int);
a1189 1
			m->m_len = sizeof(int);
d1192 2
a1193 2
				optval = inp->inp_seclevel[SL_AUTH];
				break;
d1196 2
a1197 2
				optval = inp->inp_seclevel[SL_ESP_TRANS];
				break;
d1200 2
a1201 2
				optval = inp->inp_seclevel[SL_ESP_NETWORK];
				break;
a1270 2
			if (cnt < IPOPT_OLEN + sizeof(*cp))
				goto bad;
d1272 1
a1272 1
			if (optlen < IPOPT_OLEN  + sizeof(*cp) || optlen > cnt)
@


1.64.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.64.2.2 2001/05/14 22:40:12 niklas Exp $	*/
a38 2
#include "pf.h"

d40 1
a40 1
#include <sys/systm.h>
d42 1
d46 5
a51 1
#include <sys/kernel.h>
a53 1
#include <net/if_enc.h>
a55 4
#if NPF > 0
#include <net/pfvar.h>
#endif

a61 6
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/udp_var.h>
d67 2
d70 7
d93 3
d114 1
a114 1
	struct mbuf *m = m0;
a126 1
	u_int32_t icmp_mtu = 0;
a128 2
	struct m_tag *mtag;
	struct tdb_ident *tdbi;
d164 2
a165 1
		ip->ip_id = htons(ip_randomid());
d172 21
d264 6
d276 9
a284 14
	/* Do we have any pending SAs to apply ? */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_PENDING_TDB, NULL);
	if (mtag != NULL) {
#ifdef DIAGNOSTIC
		if (mtag->m_tag_len != sizeof (struct tdb_ident))
			panic("ip_output: tag of length %d (should be %d",
			    mtag->m_tag_len, sizeof (struct tdb_ident));
#endif
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
		if (tdb == NULL)
			error = -EINVAL;
		m_tag_delete(m, mtag);
	}
d286 2
a287 2
		tdb = ipsp_spd_lookup(m, AF_INET, hlen, &error,
		    IPSP_DIRECTION_OUT, NULL, inp);
a329 18
		/* Loop detection */
		for (mtag = m_tag_first(m); mtag != NULL;
		    mtag = m_tag_next(m, mtag)) {
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE &&
			    mtag->m_tag_id !=
			    PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED)
				continue;
			tdbi = (struct tdb_ident *)(mtag + 1);
			if (tdbi->spi == tdb->tdb_spi &&
			    tdbi->proto == tdb->tdb_sproto &&
			    !bcmp(&tdbi->dst, &tdb->tdb_dst,
			    sizeof(union sockaddr_union))) {
				splx(s);
				sproto = 0; /* mark as no-IPsec-needed */
				goto done_spd;
			}
		}

a335 10
		/*
		 * If it needs TCP/UDP hardware-checksumming, do the
		 * computation now.
		 */
		if (m->m_pkthdr.csum & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
			in_delayed_cksum(m);
			m->m_pkthdr.csum &=
			    ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
		}	

d406 1
a406 2
	if (IN_MULTICAST(ip->ip_dst.s_addr) ||
	    (ip->ip_dst.s_addr == INADDR_BROADCAST)) {
d409 1
a409 2
		m->m_flags |= (ip->ip_dst.s_addr == INADDR_BROADCAST) ?
			M_BCAST : M_MCAST;
d433 1
a433 4
		if ((((m->m_flags & M_MCAST) &&
		      (ifp->if_flags & IFF_MULTICAST) == 0) ||
		     ((m->m_flags & M_BCAST) && 
		      (ifp->if_flags & IFF_BROADCAST) == 0)) && (sproto == 0))  {
d545 9
a553 6
		/*
		 * Packet filter
		 */
#if NPF > 0

		if (pf_test(PF_OUT, &encif[0].sc_if, &m) != PF_PASS) {
a555 1
			m_freem(m);
d557 11
a567 5
		}
		ip = mtod(m, struct ip *);
		hlen = ip->ip_hl << 2;
#endif

a579 30
		/* Check if we are allowed to fragment */
		if ((ip->ip_off & IP_DF) && tdb->tdb_mtu &&
		    (u_int16_t)ip->ip_len > tdb->tdb_mtu &&
		    tdb->tdb_mtutimeout > time.tv_sec) {
			struct rtentry *rt;
			
			icmp_mtu = tdb->tdb_mtu;
			splx(s);

			/* Find a host route to store the mtu in */
			if (ro != NULL)
				rt = ro->ro_rt;
			if (rt == NULL || (rt->rt_flags & RTF_HOST) == 0) {
				struct sockaddr_in dst = {
					sizeof(struct sockaddr_in), AF_INET};
				dst.sin_addr = ip->ip_dst;
				rt = icmp_mtudisc_clone((struct sockaddr *)&dst);
			}
			if (rt != NULL) {
				rt->rt_rmx.rmx_mtu = icmp_mtu;
				if (ro && ro->ro_rt != NULL) {
					RTFREE(ro->ro_rt);
					ro->ro_rt = (struct rtentry *) 0;
					rtalloc(ro);
				}
			}
			error = EMSGSIZE;
			goto bad;
		}

d591 2
a592 1
		error = ipsp_process_packet(m, tdb, AF_INET, 0);
d596 1
d598 1
d600 1
a600 2
	 * If deferred crypto processing is needed, check that the
	 * interface supports it.
d602 9
a610 22
	if ((mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL))
	    != NULL && (ifp->if_capabilities & IFCAP_IPSEC) == 0) {
		/* Notify IPsec to do its own crypto. */
		ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
		m_freem(m);
		error = EHOSTUNREACH;
		goto done;
	}
#endif /* IPSEC */

	/* Catch routing changes wrt. hardware checksumming for TCP or UDP. */
	if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_TCPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m);
			m->m_pkthdr.csum &= ~M_TCPV4_CSUM_OUT; /* Clear */
		}
	} else if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT) {
		if (!(ifp->if_capabilities & IFCAP_CSUM_UDPv4) ||
		    ifp->if_bridge != NULL) {
			in_delayed_cksum(m);
			m->m_pkthdr.csum &= ~M_UDPV4_CSUM_OUT; /* Clear */
d612 1
a613 12

	/*
	 * Packet filter
	 */
#if NPF > 0
	if (pf_test(PF_OUT, ifp, &m) != PF_PASS) {
		error = EHOSTUNREACH;
		m_freem(m);
		goto done;
	}
	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;
a614 1

d621 2
a622 13
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    ifp->if_bridge == NULL) {
			m->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
			ipstat.ips_outhwcsum++;
		} else {
			ip->ip_sum = 0;
			ip->ip_sum = in_cksum(m, hlen);
		}
		/* Update relevant hardware checksum stats for TCP/UDP */
		if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
			tcpstat.tcps_outhwcsum++;
		else if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
			udpstat.udps_outhwcsum++;
a631 3
#ifdef IPSEC
		icmp_mtu = ifp->if_mtu;
#endif
a632 12
		/*
		 * This case can happen if the user changed the MTU
		 * of an interface after enabling IP on it.  Because
		 * most netifs don't keep track of routes pointing to
		 * them, there is no way for one to update all its
		 * routes when the MTU is changed.
		 */
		if ((ro->ro_rt->rt_flags & (RTF_UP | RTF_HOST))
		    && !(ro->ro_rt->rt_rmx.rmx_locks & RTV_MTU)
		    && (ro->ro_rt->rt_rmx.rmx_mtu > ifp->if_mtu)) {
			ro->ro_rt->rt_rmx.rmx_mtu = ifp->if_mtu;
		}
a641 9
	/*
	 * If we are doing fragmentation, we can't defer TCP/UDP
	 * checksumming; compute the checksum and clear the flag.
	 */
	if (m->m_pkthdr.csum & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum &= ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
	}

d688 2
a689 8
		if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
		    ifp->if_bridge == NULL) {
			m->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
			ipstat.ips_outhwcsum++;
		} else {
			mhip->ip_sum = 0;
			mhip->ip_sum = in_cksum(m, mhlen);
		}
d701 2
a702 8
	if ((ifp->if_capabilities & IFCAP_CSUM_IPv4) &&
	    ifp->if_bridge == NULL) {
		m->m_pkthdr.csum |= M_IPV4_CSUM_OUT;
		ipstat.ips_outhwcsum++;
	} else {
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, hlen);
	}
a721 4
#ifdef IPSEC
	if (error == EMSGSIZE && icmp_mtu != 0)
		ipsec_adjust_mtu(m, icmp_mtu);
#endif
d751 1
a751 2
		M_MOVE_HDR(n, m);
		n->m_pkthdr.len += optlen;
a832 2
	struct ipsec_ref *ipr;
	u_int16_t opt16val;
d841 1
d934 1
a934 1
			error = EOPNOTSUPP;
d947 1
a947 16

			/* Unlink cached output TDB to force a re-search */
			if (inp->inp_tdb_out) {
				int s = spltdb();
				TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out,
				    inp, inp_tdb_out_next);
				splx(s);
			}

			if (inp->inp_tdb_in) {
				int s = spltdb();
				TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in,
				    inp, inp_tdb_in_next);
				splx(s);
			}

a980 138
		case IP_IPSEC_REMOTE_CRED:
		case IP_IPSEC_REMOTE_AUTH:
			/* Can't set the remote credential or key */
			error = EOPNOTSUPP;
			break;

		case IP_IPSEC_LOCAL_ID:
		case IP_IPSEC_REMOTE_ID:
		case IP_IPSEC_LOCAL_CRED:
		case IP_IPSEC_LOCAL_AUTH:
#ifndef IPSEC
			error = EOPNOTSUPP;
#else
			if (m->m_len < 2) {
				error = EINVAL;
				break;
			}

			m_copydata(m, 0, 2, (caddr_t) &opt16val);

			/* If the type is 0, then we cleanup and return */
			if (opt16val == 0) {
				switch (optname) {
				case IP_IPSEC_LOCAL_ID:
					if (inp->inp_ipsec_localid != NULL)
						ipsp_reffree(inp->inp_ipsec_localid);
					inp->inp_ipsec_localid = NULL;
					break;

				case IP_IPSEC_REMOTE_ID:
					if (inp->inp_ipsec_remoteid != NULL)
						ipsp_reffree(inp->inp_ipsec_remoteid);
					inp->inp_ipsec_remoteid = NULL;
					break;

				case IP_IPSEC_LOCAL_CRED:
					if (inp->inp_ipsec_localcred != NULL)
						ipsp_reffree(inp->inp_ipsec_localcred);
					inp->inp_ipsec_localcred = NULL;
					break;

				case IP_IPSEC_LOCAL_AUTH:
					if (inp->inp_ipsec_localauth != NULL)
						ipsp_reffree(inp->inp_ipsec_localauth);
					inp->inp_ipsec_localauth = NULL;
					break;
				}

				error = 0;
				break;
			}

			/* Can't have an empty payload */
			if (m->m_len == 2) {
				error = EINVAL;
				break;
			}

			MALLOC(ipr, struct ipsec_ref *,
			       sizeof(struct ipsec_ref) + m->m_len - 2,
			       M_CREDENTIALS, M_NOWAIT);
			if (ipr == NULL) {
				error = ENOBUFS;
				break;
			}
			ipr->ref_count = 1;
			ipr->ref_malloctype = M_CREDENTIALS;
			ipr->ref_len = m->m_len - 2;
			ipr->ref_type = opt16val;
			m_copydata(m, 2, m->m_len - 2, (caddr_t)(ipr + 1));

			switch (optname) {
			case IP_IPSEC_LOCAL_ID:
				/* Check valid types and NUL-termination */
				if (ipr->ref_type < IPSP_IDENTITY_PREFIX
				    || ipr->ref_type > IPSP_IDENTITY_CONNECTION
				    || ((char *)(ipr + 1))[ipr->ref_len - 1]) {
					FREE(ipr, M_CREDENTIALS);
					error = EINVAL;
				} else {
					if (inp->inp_ipsec_localid != NULL)
						ipsp_reffree(inp->inp_ipsec_localid);
					inp->inp_ipsec_localid = ipr;
				}
				break;
			case IP_IPSEC_REMOTE_ID:
				/* Check valid types and NUL-termination */
				if (ipr->ref_type < IPSP_IDENTITY_PREFIX
				    || ipr->ref_type > IPSP_IDENTITY_CONNECTION
				    || ((char *)(ipr + 1))[ipr->ref_len - 1]) {
					FREE(ipr, M_CREDENTIALS);
					error = EINVAL;
				} else {
					if (inp->inp_ipsec_remoteid != NULL)
						ipsp_reffree(inp->inp_ipsec_remoteid);
					inp->inp_ipsec_remoteid = ipr;
				}
				break;
			case IP_IPSEC_LOCAL_CRED:
				if (ipr->ref_type < IPSP_CRED_KEYNOTE ||
				    ipr->ref_type > IPSP_CRED_X509) {
					FREE(ipr, M_CREDENTIALS);
					error = EINVAL;
				} else {
					if (inp->inp_ipsec_localcred != NULL)
						ipsp_reffree(inp->inp_ipsec_localcred);
					inp->inp_ipsec_localcred = ipr;
				}
				break;
			case IP_IPSEC_LOCAL_AUTH:
				if (ipr->ref_type < IPSP_AUTH_PASSPHRASE ||
				    ipr->ref_type > IPSP_AUTH_RSA) {
					FREE(ipr, M_CREDENTIALS);
					error = EINVAL;
				} else {
					if (inp->inp_ipsec_localauth != NULL)
						ipsp_reffree(inp->inp_ipsec_localauth);
					inp->inp_ipsec_localauth = ipr;
				}
				break;
			}

			/* Unlink cached output TDB to force a re-search */
			if (inp->inp_tdb_out) {
				int s = spltdb();
				TAILQ_REMOVE(&inp->inp_tdb_out->tdb_inp_out,
				    inp, inp_tdb_out_next);
				splx(s);
			}

			if (inp->inp_tdb_in) {
				int s = spltdb();
				TAILQ_REMOVE(&inp->inp_tdb_in->tdb_inp_in,
				    inp, inp_tdb_in_next);
				splx(s);
			}
#endif
			break;
a1081 45
		case IP_IPSEC_LOCAL_ID:
		case IP_IPSEC_REMOTE_ID:
		case IP_IPSEC_LOCAL_CRED:
		case IP_IPSEC_REMOTE_CRED:
		case IP_IPSEC_LOCAL_AUTH:
		case IP_IPSEC_REMOTE_AUTH:
#ifndef IPSEC
			error = EOPNOTSUPP;
#else
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
			m->m_len = sizeof(u_int16_t);
			switch (optname) {
			case IP_IPSEC_LOCAL_ID:
				ipr = inp->inp_ipsec_localid;
				opt16val = IPSP_IDENTITY_NONE;
				break;
			case IP_IPSEC_REMOTE_ID:
				ipr = inp->inp_ipsec_remoteid;
				opt16val = IPSP_IDENTITY_NONE;
				break;
			case IP_IPSEC_LOCAL_CRED:
				ipr = inp->inp_ipsec_localcred;
				opt16val = IPSP_CRED_NONE;
				break;
			case IP_IPSEC_REMOTE_CRED:
				ipr = inp->inp_ipsec_remotecred;
				opt16val = IPSP_CRED_NONE;
				break;
			case IP_IPSEC_LOCAL_AUTH:
				ipr = inp->inp_ipsec_localauth;
				break;
			case IP_IPSEC_REMOTE_AUTH:
				ipr = inp->inp_ipsec_remoteauth;
				break;
			}
			if (ipr == NULL)
				*mtod(m, u_int16_t *) = opt16val;
			else {
				m->m_len += ipr->ref_len;
				*mtod(m, u_int16_t *) = ipr->ref_type;
				m_copyback(m, sizeof(u_int16_t), ipr->ref_len,
					   (caddr_t)(ipr + 1));
			}
#endif
			break;
d1227 2
a1530 34
}

/*
 * Process a delayed payload checksum calculation.
 */
void
in_delayed_cksum(struct mbuf *m)
{
	struct ip *ip;
	u_int16_t csum, offset;

	ip = mtod(m, struct ip *);
	offset = ip->ip_hl << 2;
	csum = in4_cksum(m, 0, offset, m->m_pkthdr.len - offset);
	if (csum == 0 && ip->ip_p == IPPROTO_UDP)
		csum = 0xffff;

	switch (ip->ip_p) {
	case IPPROTO_TCP:
		offset += offsetof(struct tcphdr, th_sum);
		break;

	case IPPROTO_UDP:
		offset += offsetof(struct udphdr, uh_sum);
		break;

	default:
		return;
	}

	if ((offset + sizeof(u_int16_t)) > m->m_len)
		m_copyback(m, offset, sizeof(csum), (caddr_t) &csum);
	else
		*(u_int16_t *)(mtod(m, caddr_t) + offset) = csum;
@


1.64.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.64.2.3 2001/07/04 10:54:56 niklas Exp $	*/
d54 4
a70 4
#if NPF > 0
#include <net/pfvar.h>
#endif

a86 1
extern int ipsec_ipcomp_default_level;
d289 17
d585 1
a585 1
			struct rtentry *rt = NULL;
a1039 1
		case IP_IPCOMP_LEVEL:
a1096 8
			case IP_IPCOMP_LEVEL:
			        if (optval < ipsec_ipcomp_default_level &&
				    suser(p->p_ucred, &p->p_acflag)) {
				        error = EACCES;
					break;
				}
				inp->inp_seclevel[SL_IPCOMP] = optval;
				break;
a1320 1
		case IP_IPCOMP_LEVEL:
a1336 3
				break;
			case IP_IPCOMP_LEVEL:
			        optval = inp->inp_seclevel[SL_IPCOMP];
@


1.64.2.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a454 2
			 * Can't defer TCP/UDP checksumming, do the
			 * computation now.
a455 6
			if (m->m_pkthdr.csum &
			    (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
				in_delayed_cksum(m);
				m->m_pkthdr.csum &=
				    ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
			}
@


1.64.2.6
log
@Merge in -current
@
text
@a556 4
		if (m == NULL) {
			splx(s);
			goto done;
		}
a656 3
	if (m == NULL)
		goto done;

d700 3
a702 3
		if ((ro->ro_rt->rt_flags & (RTF_UP | RTF_HOST)) &&
		    !(ro->ro_rt->rt_rmx.rmx_locks & RTV_MTU) &&
		    (ro->ro_rt->rt_rmx.rmx_mtu > ifp->if_mtu)) {
d1178 3
a1180 3
				if (ipr->ref_type < IPSP_IDENTITY_PREFIX ||
				    ipr->ref_type > IPSP_IDENTITY_CONNECTION ||
				    ((char *)(ipr + 1))[ipr->ref_len - 1]) {
d1191 3
a1193 3
				if (ipr->ref_type < IPSP_IDENTITY_PREFIX ||
				    ipr->ref_type > IPSP_IDENTITY_CONNECTION ||
				    ((char *)(ipr + 1))[ipr->ref_len - 1]) {
@


1.64.2.7
log
@Merge in trunk
@
text
@d578 1
a578 1
		if (ip_mtudisc && (ip->ip_off & IP_DF) && tdb->tdb_mtu &&
d823 1
a823 1
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0)
@


1.64.2.8
log
@Merge in -current from roughly a week ago
@
text
@d82 1
a82 1
extern u_int8_t get_sa_require(struct inpcb *);
d90 3
a92 2
static struct mbuf *ip_insertoptions(struct mbuf *, struct mbuf *, int *);
static void ip_mloopback(struct ifnet *, struct mbuf *, struct sockaddr_in *);
d101 1
d103 5
@


1.64.2.9
log
@Sync the SMP branch with 3.3
@
text
@d71 4
d102 2
a103 2
	struct ip *ip;
	struct ifnet *ifp;
d105 2
a106 2
	int hlen = sizeof (struct ip);
	int len, error = 0;
a115 1
	u_long mtu;
d173 1
a173 1
		donerouting = 1;
d175 2
a176 2
		if (ro == 0) {
			ro = &iproute;
d188 1
a188 1
			RTFREE(ro->ro_rt);
d193 1
a193 1
			dst->sin_family = AF_INET;
d202 1
a202 1
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
a209 1
			mtu = ifp->if_mtu;
a210 6
		} else if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
		    (ip->ip_dst.s_addr == INADDR_BROADCAST)) &&
		    imo != NULL && imo->imo_multicast_ifp != NULL) {
			ifp = imo->imo_multicast_ifp;
			mtu = ifp->if_mtu;
			IFP_TO_IA(ifp, ia);
d212 2
a213 2
			if (ro->ro_rt == 0)
				rtalloc(ro);
d216 1
a216 1
				ipstat.ips_noroute++;
a222 2
			if ((mtu = ro->ro_rt->rt_rmx.rmx_mtu) == 0)
				mtu = ifp->if_mtu;
d226 1
a226 1
				dst = satosin(ro->ro_rt->rt_gateway);
d230 2
a231 2
		if (!IN_MULTICAST(ip->ip_dst.s_addr))
			ip->ip_src = ia->ia_addr.sin_addr;
d260 1
a260 1
		splx(s);
d263 1
a263 1
			/*
d267 1
a267 1
			sproto = 0;
d271 1
a271 1
			/*
d276 1
a276 1
			if (error == -EINVAL) /* Should silently drop packet */
d301 2
a302 2
		/* We need to do IPsec */
		bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
d315 1
a315 1
		}
d328 2
a329 2
		if (ro == 0) {
			ro = &iproute;
d341 1
a341 1
			RTFREE(ro->ro_rt);
d346 1
a346 1
			dst->sin_family = AF_INET;
d355 1
a355 1
			if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
a362 1
			mtu = ifp->if_mtu;
a363 6
		} else if ((IN_MULTICAST(ip->ip_dst.s_addr) ||
		    (ip->ip_dst.s_addr == INADDR_BROADCAST)) &&
		    imo != NULL && imo->imo_multicast_ifp != NULL) {
			ifp = imo->imo_multicast_ifp;
			mtu = ifp->if_mtu;
			IFP_TO_IA(ifp, ia);
d365 2
a366 2
			if (ro->ro_rt == 0)
				rtalloc(ro);
d369 1
a369 1
				ipstat.ips_noroute++;
a375 2
			if ((mtu = ro->ro_rt->rt_rmx.rmx_mtu) == 0)
				mtu = ifp->if_mtu;
d379 1
a379 1
				dst = satosin(ro->ro_rt->rt_gateway);
d404 1
a404 1
		if (imo != NULL)
d406 3
a408 1
		else
a411 10
		 * if we don't know the outgoing ifp yet, we can't generate
		 * output
		 */
		if (!ifp) {
			ipstat.ips_noroute++;
			error = EHOSTUNREACH;
			goto bad;
		}

		/*
d418 2
a419 2
		     ((m->m_flags & M_BCAST) &&
		      (ifp->if_flags & IFF_BROADCAST) == 0)) && (sproto == 0)) {
d430 1
a430 1
			struct in_ifaddr *ia;
d524 3
a526 3
	/*
	 * If we're doing Path MTU discovery, we need to set DF unless
	 * the route's MTU is locked.
d531 1
a531 1

d537 1
a537 1
		s = splnet();
a559 1
			DPRINTF(("ip_output: unknown TDB"));
d566 4
d575 1
a575 1

d664 1
a664 1
	if ((u_int16_t)ip->ip_len <= mtu) {
d708 3
a710 3

	error = ip_fragment(m, ifp, mtu);
	if (error == EMSGSIZE)
a711 9

	for (; m; m = m0) {
		m0 = m->m_nextpkt;
		m->m_nextpkt = 0;
		if (error == 0)
			error = (*ifp->if_output)(ifp, m, sintosa(dst),
			    ro->ro_rt);
		else
			m_freem(m);
a713 32
	if (error == 0)
		ipstat.ips_fragmented++;

done:
	if (ro == &iproute && (flags & IP_ROUTETOIF) == 0 && ro->ro_rt)
		RTFREE(ro->ro_rt);
	return (error);
bad:
#ifdef IPSEC
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0)
		ipsec_adjust_mtu(m, icmp_mtu);
#endif
	m_freem(m0);
	goto done;
}

int
ip_fragment(struct mbuf *m, struct ifnet *ifp, u_long mtu)
{
	struct ip *ip, *mhip;
	struct mbuf *m0;
	int len, hlen, off;
	int mhlen, firstlen;
	struct mbuf **mnext;

	ip = mtod(m, struct ip *);
	hlen = ip->ip_hl << 2;

	len = (mtu - hlen) &~ 7;
	if (len < 8)
		return (EMSGSIZE);

d723 3
a725 2
	firstlen = len;
	mnext = &m->m_nextpkt;
d736 1
d738 1
a738 1
			return (ENOBUFS);
d762 1
d764 1
a764 1
			return (ENOBUFS);	/* ??? */
d796 10
d807 14
a820 1
	return (0);
d830 1
a830 1
	struct mbuf *m;
d834 1
a834 1
	struct ipoption *p = mtod(opt, struct ipoption *);
d836 1
a836 1
	struct ip *ip = mtod(m, struct ip *);
d878 1
a878 1
	u_char *cp, *dp;
d926 3
a928 3
	struct inpcb *inp = sotoinpcb(so);
	struct mbuf *m = *mp;
	int optval = 0;
d1042 1
a1042 1
			if (optval < IPSEC_LEVEL_BYPASS ||
d1065 1
a1065 1
				if (optval < ipsec_auth_default_level &&
d1074 1
a1074 1
				if (optval < ipsec_esp_trans_default_level &&
d1083 1
a1083 1
				if (optval < ipsec_esp_network_default_level &&
d1091 1
a1091 1
				if (optval < ipsec_ipcomp_default_level &&
d1093 1
a1093 1
					error = EACCES;
d1128 3
a1130 5
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_srcid != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_srcid);
						inp->inp_ipo->ipo_srcid = NULL;
					}
d1134 3
a1136 5
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_dstid != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_dstid);
						inp->inp_ipo->ipo_dstid = NULL;
					}
d1140 3
a1142 5
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_local_cred != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_local_cred);
						inp->inp_ipo->ipo_local_cred = NULL;
					}
d1146 3
a1148 5
					if (inp->inp_ipo != NULL &&
					    inp->inp_ipo->ipo_local_auth != NULL) {
						ipsp_reffree(inp->inp_ipo->ipo_local_auth);
						inp->inp_ipo->ipo_local_auth = NULL;
					}
a1161 10
			/* Allocate if needed */
			if (inp->inp_ipo == NULL) {
				inp->inp_ipo = ipsec_add_policy(inp,
				    AF_INET, IPSP_DIRECTION_OUT);
				if (inp->inp_ipo == NULL) {
					error = ENOBUFS;
					break;
				}
			}

a1168 1

d1184 3
a1186 3
					if (inp->inp_ipo->ipo_srcid != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_srcid);
					inp->inp_ipo->ipo_srcid = ipr;
d1197 3
a1199 3
					if (inp->inp_ipo->ipo_dstid != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_dstid);
					inp->inp_ipo->ipo_dstid = ipr;
d1208 3
a1210 3
					if (inp->inp_ipo->ipo_local_cred != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_local_cred);
					inp->inp_ipo->ipo_local_cred = ipr;
d1219 3
a1221 3
					if (inp->inp_ipo->ipo_local_auth != NULL)
						ipsp_reffree(inp->inp_ipo->ipo_local_auth);
					inp->inp_ipo->ipo_local_auth = ipr;
d1341 1
a1341 1
				optval = inp->inp_seclevel[SL_IPCOMP];
a1357 1
			ipr = NULL;
d1360 1
a1360 2
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_srcid;
d1364 1
a1364 2
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_dstid;
d1368 1
a1368 2
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_local_cred;
d1376 1
a1376 2
				if (inp->inp_ipo != NULL)
					ipr = inp->inp_ipo->ipo_local_auth;
d1414 1
a1414 1
	struct mbuf *m;
d1416 2
a1417 2
	int cnt, optlen;
	u_char *cp;
d1433 1
d1436 1
a1436 1

d1519 1
a1519 1
	int error = 0;
d1521 1
a1521 1
	int i;
d1523 3
a1525 3
	struct ip_mreq *mreq;
	struct ifnet *ifp;
	struct ip_moptions *imo = *imop;
d1527 1
a1527 1
	struct sockaddr_in *dst;
d1752 2
a1753 2
	struct ip_moptions *imo;
	struct mbuf **mp;
d1800 1
a1800 1
	struct ip_moptions *imo;
d1802 1
a1802 1
	int i;
d1820 2
a1821 2
	struct mbuf *m;
	struct sockaddr_in *dst;
d1823 1
a1823 1
	struct ip *ip;
@


1.64.2.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.64.2.9 2003/03/28 00:06:54 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.64.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d149 1
a149 1
		ip->ip_off &= htons(IP_DF);
d534 1
a534 1
		if (ntohs(ip->ip_len) > ifp->if_mtu) {
d549 1
a549 1
		ip->ip_off |= htons(IP_DF);
d587 2
a588 2
		if (ip_mtudisc && (ip->ip_off & htons(IP_DF)) && tdb->tdb_mtu &&
		    ntohs(ip->ip_len) > tdb->tdb_mtu &&
d616 4
d680 3
a682 1
	if (ntohs(ip->ip_len) <= mtu) {
d704 1
a704 1
	if (ip->ip_off & htons(IP_DF)) {
d726 1
a726 1
	if (error)
d789 1
a789 1
	for (off = hlen + len; off < ntohs(ip->ip_len); off += len) {
d807 2
a808 3
		mhip->ip_off = ((off - hlen) >> 3) +
		    (ntohs(ip->ip_off) & ~IP_MF);
		if (ip->ip_off & htons(IP_MF))
d810 2
a811 2
		if (off + len >= ntohs(ip->ip_len))
			len = ntohs(ip->ip_len) - off;
d838 1
a838 1
	m_adj(m, hlen + firstlen - ntohs(ip->ip_len));
d841 1
a841 1
	ip->ip_off |= htons(IP_MF);
d871 1
a871 1
	if (optlen + ntohs(ip->ip_len) > IP_MAXPACKET)
d897 1
a897 1
	ip->ip_len = htons(ntohs(ip->ip_len) + optlen);
d1097 1
a1097 1
				    suser(p, 0)) {
d1106 1
a1106 1
				    suser(p, 0)) {
d1115 1
a1115 1
				    suser(p, 0)) {
d1123 1
a1123 1
				    suser(p, 0)) {
d1443 1
a1443 1
				    ipr + 1);
d1887 2
d1924 1
a1924 1
		m_copyback(m, offset, sizeof(csum), &csum);
@


1.64.2.12
log
@Merge with the trunk
@
text
@a165 4
		if (flags & IP_ROUTETOETHER) {
			error = EINVAL;
			goto bad;
		}
d329 1
a329 6
	if (flags & IP_ROUTETOETHER) {
		dst = satosin(&ro->ro_dst);
		ifp = ro->ro_rt->rt_ifp;
		mtu = ifp->if_mtu;
		ro->ro_rt = NULL;
	} else if (donerouting == 0) {
d720 1
a720 2
	if (error) {
		m = m0 = NULL;
a721 1
	}
d742 1
a742 1
	if (error == EMSGSIZE && ip_mtudisc && icmp_mtu != 0 && m != NULL)
a756 3
	int fragments = 0;
	int s;
	int error = 0;
d762 1
a762 2
	if (len < 8) {
		m_freem(m);
a763 1
	}
d787 1
a787 2
			error = ENOBUFS;
			goto sendorfree;
d813 1
a813 2
			error = ENOBUFS;
			goto sendorfree;
a826 1
		fragments++;
a844 20
sendorfree:
	/*
	 * If there is no room for all the fragments, don't queue
	 * any of them.
	 */
	s = splnet();
	if (ifp->if_snd.ifq_maxlen - ifp->if_snd.ifq_len < fragments &&
	    error == 0) {
		error = ENOBUFS;
		ipstat.ips_odropped++;
		IFQ_INC_DROPS(&ifp->if_snd);
	}
	splx(s);
	if (error) {
		for (m = m0; m; m = m0) {
			m0 = m->m_nextpkt;
			m->m_nextpkt = NULL;
			m_freem(m);
		}
	}
d846 1
a846 1
	return (error);
d1545 1
a1545 1
			    (unsigned)cnt - (IPOPT_OFFSET+1));
@


1.64.2.13
log
@sync to head
@
text
@a100 1
	struct sockaddr_rtin *rtin;
a176 1
		rtin = satortin(&ro->ro_dst);
d184 1
a184 2
				  rtin->rtin_dst.s_addr != ip->ip_dst.s_addr ||
				  rtin->rtin_src.s_addr != ip->ip_src.s_addr)) {
d190 3
a192 4
			rtin->rtin_family = AF_INET;
			rtin->rtin_len = sizeof(*rtin);
			rtin->rtin_dst = ip->ip_dst;
			rtin->rtin_src = ip->ip_src;
a232 8
                        else if (rtin->rtin_src.s_addr) {
                                if (ro != &iproute) {
                                        iproute.ro_dst = ro->ro_dst;
                                        rtin = satortin(&iproute.ro_dst);
                                        dst = satosin(&iproute.ro_dst);
                                }
                                rtin->rtin_src.s_addr = 0;
                        }
a343 1
		rtin = satortin(&ro->ro_dst);
d351 1
a351 2
				  rtin->rtin_dst.s_addr != ip->ip_dst.s_addr ||
				  rtin->rtin_src.s_addr != ip->ip_src.s_addr)) {
d357 3
a359 4
			rtin->rtin_family = AF_INET;
			rtin->rtin_len = sizeof(*rtin);
			rtin->rtin_dst = ip->ip_dst;
			rtin->rtin_src = ip->ip_src;
a399 8
                        else if (rtin->rtin_src.s_addr) {
                                if (ro != &iproute) {
                                        iproute.ro_dst = ro->ro_dst;
                                        rtin = satortin(&iproute.ro_dst);
                                        dst = satosin(&iproute.ro_dst);
                                }
                                rtin->rtin_src.s_addr = 0;
                        }
@


1.63
log
@Use default values when requesting dynamic VPNs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.62 2000/01/10 04:29:29 angelos Exp $	*/
d517 1
a517 1
			tdb2.tdb_satype = sa_require;
@


1.62
log
@No need for extern definition of pfkeyv2_acquire()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.61 2000/01/09 22:53:16 angelos Exp $	*/
d142 1
a142 1
	struct tdb *tdb;
d511 7
a517 7
			/*
			 * XXX We should construct a TDB from system
			 * default (which should be tunable via sysctl).
			 * For now, drop packet and ignore SPD entry.
			 */
			splx(s);
			goto no_encap;
d526 97
@


1.61
log
@Transport port is in network order...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.60 1999/12/25 04:48:16 angelos Exp $	*/
a100 2

extern int pfkeyv2_acquire(struct tdb *, int);
@


1.60
log
@Move the IPsec packet-processing loop to a separate routine, so we can
reuse it in ip6_output and the bridge. The policy-lookup code will
probably follow suit in a separate routine sometime soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.59 1999/12/21 08:23:06 angelos Exp $	*/
d413 2
a414 2
			ddst->sen_sport = ntohs(udp->uh_sport);
			ddst->sen_dport = ntohs(udp->uh_dport);
d425 2
a426 2
			ddst->sen_sport = ntohs(tcp->th_sport);
			ddst->sen_dport = ntohs(tcp->th_dport);
@


1.59
log
@Initialize variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.58 1999/12/18 19:57:07 angelos Exp $	*/
d143 2
a144 2
	struct tdb *tdb, *t;
	int s, ip6flag = 0;
d395 1
d520 1
a520 2
		    }
		    else {
d555 2
a556 1
		if (sa_require & ~sa_have)
d558 1
d563 2
a564 1
			  DPRINTF(("ip_output(): non-existant TDB for SA %s/%08x/%u\n", inet_ntoa4(gw->sen_ipsp_dst), ntohl(gw->sen_ipsp_spi), gw->sen_ipsp_sproto));
d566 2
a567 2
			else
			  DPRINTF(("ip_output(): non-existant TDB for SA %s/%08x/%u\n", inet6_ntoa4(gw->sen_ipsp6_dst), ntohl(gw->sen_ipsp6_spi), gw->sen_ipsp6_sproto));
d577 4
a580 5
		for (t = tdb; t != NULL; t = t->tdb_onext)
		    if ((t->tdb_sproto == IPPROTO_ESP && !esp_enable) ||
			(t->tdb_sproto == IPPROTO_AH && !ah_enable)) {
		        DPRINTF(("ip_output(): IPSec outbound packet dropped due to policy\n"));

d583 2
a584 2
			error = EHOSTUNREACH;
			m_freem(m);
d586 1
a586 63
		    }

		while (tdb && tdb->tdb_xform) {
			/* Check if the SPI is invalid */
			if (tdb->tdb_flags & TDBF_INVALID) {
				splx(s);
			        DPRINTF(("ip_output(): attempt to use invalid SA %s/%08x/%u\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi), tdb->tdb_sproto));
				m_freem(m);
				if (re->re_rt)
					RTFREE(re->re_rt);
				return ENXIO;
			}

#ifndef INET6
			/* Sanity check */
			if (tdb->tdb_dst.sa.sa_family != AF_INET) {
			    splx(s);
			        DPRINTF(("ip_output(): attempt to use SA %s/%08x/%u for protocol family %d\n", ipsp_address(tdb->tdb_dst), ntohl(tdb->tdb_spi), tdb->tdb_sproto, tdb->tdb_dst.sa.sa_family));
				m_freem(m);
				if (re->re_rt)
					RTFREE(re->re_rt);
				return ENXIO;
			}
#endif /* INET6 */

			/* Register first use, setup expiration timer */
			if (tdb->tdb_first_use == 0) {
				tdb->tdb_first_use = time.tv_sec;
				tdb_expiration(tdb, TDBEXP_TIMEOUT);
			}

			/* Check for tunneling */
			if (((tdb->tdb_dst.sa.sa_family == AF_INET) &&
			     (tdb->tdb_dst.sin.sin_addr.s_addr != 
			      INADDR_ANY) &&
			     (tdb->tdb_dst.sin.sin_addr.s_addr !=
			      ip->ip_dst.s_addr)) ||
			    (tdb->tdb_dst.sa.sa_family == AF_INET6) ||
			    ((tdb->tdb_flags & TDBF_TUNNELING) &&
			     (tdb->tdb_xform->xf_type != XF_IP4))) {
			        /* Fix length and checksum */
			        ip->ip_len = htons(m->m_pkthdr.len);
			        ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
				error = ipe4_output(m, tdb, &mp,
						    ip->ip_hl << 2,
						    offsetof(struct ip, ip_p));
				if (mp == NULL)
					error = EFAULT;
				if (error) {
					splx(s);
					if (re->re_rt)
						RTFREE(re->re_rt);
					return error;
				}
				if (tdb->tdb_dst.sa.sa_family == AF_INET)
				        ip6flag = 0;
#ifdef INET6
				if (tdb->tdb_dst.sa.sa_family == AF_INET6)
				        ip6flag = 1;
#endif /* INET6 */
				m = mp;
				mp = NULL;
			}
d588 2
a589 23
			if ((tdb->tdb_xform->xf_type == XF_IP4) &&
			    (tdb->tdb_dst.sa.sa_family == AF_INET)) {
			        ip = mtod(m, struct ip *);
				ip->ip_len = htons(m->m_pkthdr.len);
				ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
			}

#ifdef INET6
			if ((tdb->tdb_xform->xf_type == XF_IP4) &&
			    (tdb->tdb_dst.sa.sa_family == AF_INET6)) {
			    ip6 = mtod(m, struct ip6_hdr *);
			    ip6->ip6_plen = htons(m->m_pkthdr.len);
			}
#endif /* INET6 */

#ifdef INET6
			/*
			 * This assumes that there is only just an IPv6
			 * header prepended.
			 */
			if (ip6flag)
			  error = (*(tdb->tdb_xform->xf_output))(m, tdb, &mp, sizeof(struct ip6_hdr), offsetof(struct ip6_hdr, ip6_nxt));
#endif /* INET6 */
a590 29
			if (!ip6flag)
			  error = (*(tdb->tdb_xform->xf_output))(m, tdb, &mp, ip->ip_hl << 2, offsetof(struct ip, ip_p));
			if (!error && mp == NULL)
				error = EFAULT;
			if (error) {
				splx(s);
				if (mp != NULL)
					m_freem(mp);
				if (re->re_rt)
					RTFREE(re->re_rt);
				return error;
			}

			m = mp;
			mp = NULL;

			if (!ip6flag) {
			    ip = mtod(m, struct ip *);
			    ip->ip_len = htons(m->m_pkthdr.len);
			}

#ifdef INET6
			if (ip6flag) {
			    ip6 = mtod(m, struct ip6_hdr *);
			    ip6->ip6_plen = htons(m->m_pkthdr.len);
			}
#endif /* INET6 */
			tdb = tdb->tdb_onext;
		}
a592 3
		if (!ip6flag)
		  ip->ip_sum = in_cksum(m, ip->ip_hl << 2);

d601 1
a601 1
		if (!ip6flag) {
d612 1
a612 1
		if (ip6flag) {
@


1.58
log
@Fix kernel panic involving multicast packet (patch different from the
one provided by pavlin@@catarina.usc.edu)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.57 1999/12/10 08:55:23 angelos Exp $	*/
d144 1
a144 1
	int s, ip6flag;
@


1.57
log
@Add code to allow for IPv6 IPsec destinations in IPv4 IPsec flows (e.g.,
packets from 10.0.0.1 going to 11.0.0.1 should be ESP encrypted to
host 1:2:3:4:5:6:7:8).

ip6_output() needs to be modified to honor IP_RAWOUTPUT (or some such)
and IP_ENCAPSULATED, to not prepend an IPv6 header to the packet, and
to not do IPsec processing respectively.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.56 1999/12/08 12:10:25 angelos Exp $	*/
d1704 1
a1704 1
	copym = m_copy(m, 0, M_COPYALL);
@


1.56
log
@Fix debugging printf compilation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.55 1999/12/08 06:50:20 itojun Exp $	*/
d88 1
a88 7
#endif

#if 0 /*KAME IPSEC*/
#include <netinet6/ipsec.h>
#include <netkey/key.h>
#include <netkey/key_debug.h>
#endif /*IPSEC*/
d144 6
a149 2
	int s;
#endif
d158 1
a158 1
#endif
a160 6


#if 0 /*KAME IPSEC*/
	m->m_pkthdr.rcvif = NULL;
#endif /*IPSEC*/

a440 13
		/*
		 * There might be a specific route, that tells us to avoid
		 * doing IPsec; this is useful for specific routes that we
		 * don't want to have IPsec applied on, like the key
		 * management ports.
		 */

		if ((gw != NULL) && (gw->sen_ipsp_dst.s_addr == 0) &&
		    (gw->sen_ipsp_sproto == 0) && (gw->sen_ipsp_spi == 0)) {
			splx(s);
			goto no_encap;
		}

d454 23
d493 1
a493 1
		else {
d531 2
a532 1
		      pfkeyv2_acquire(tdb, 0); /* XXX Check for errors */
d545 2
a546 2
		ip->ip_len = htons((u_short)ip->ip_len);
		ip->ip_off = htons((u_short)ip->ip_off);
d562 1
a562 1
#if INET6
d597 1
d607 2
a608 1
    
d621 1
d638 6
d648 2
a649 1
			if (tdb->tdb_xform->xf_type == XF_IP4) {
d655 19
a673 1
			error = (*(tdb->tdb_xform->xf_output))(m, tdb, &mp, ip->ip_hl << 2, offsetof(struct ip, ip_p));
a686 2
			ip = mtod(m, struct ip *);
			ip->ip_len = htons(m->m_pkthdr.len);
d688 11
d703 2
a704 1
		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
d713 22
a734 5
		ip = mtod(m, struct ip *);
		NTOHS(ip->ip_len);
		NTOHS(ip->ip_off);
		return ip_output(m, NULL, NULL,
				 IP_ENCAPSULATED | IP_RAWOUTPUT, NULL, NULL);
a1150 24
#if 0 /*KAME IPSEC*/
		case IP_IPSEC_POLICY:
		    {
			caddr_t req = NULL;
			int len = 0;
			int priv = 0;
#ifdef __NetBSD__
			if (p == 0 || suser(p->p_ucred, &p->p_acflag))
				priv = 0;
			else
				priv = 1;
#else
			priv = (in6p->in6p_socket->so_state & SS_PRIV);
#endif
			if (m != 0) {
				req = mtod(m, caddr_t);
				len = m->m_len;
			}
			error = ipsec_set_policy(&inp->inp_sp,
			                         optname, req, len, priv);
			break;
		    }
#endif /*IPSEC*/

a1204 6

#if 0 /*KAME IPSEC*/
		case IP_IPSEC_POLICY:
			error = ipsec_get_policy(inp->inp_sp, mp);
			break;
#endif /*IPSEC*/
@


1.55
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.54 1999/12/06 07:14:36 angelos Exp $	*/
d77 1
a77 1
#define DPRINTF(x)	if (encdebug) printf x
d561 1
a561 1
			  DPRINTF(("ip_output(): non-existant TDB for SA %s/%08x/%u\n", inet6_ntoa4(gw->sen_ipsp_dst), ntohl(gw->sen_ipsp_spi), gw->sen_ipsp_sproto));
@


1.54
log
@New ESP code that's v4 and v6 friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.53 1999/12/04 23:20:21 angelos Exp $	*/
d50 3
d90 6
d165 4
d715 1
d720 10
d1093 24
d1171 6
@


1.53
log
@Address independence, IPv6 support, and the -local flag in ipsecadm is
no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.52 1999/11/04 11:21:14 ho Exp $	*/
d79 4
d477 1
a477 1
#if INET6
d548 1
a548 1
			  DPRINTF(("ip_output(): non-existant TDB for SA %s/%08x/%u\n", inet_ntoa4(gw->sen_ipsp_dst), ntohl(gw->sen_ipsp_spi), gw->sen_ipsp_sproto));
d605 6
a610 6
				/*
				 * Fix checksum here, AH and ESP fix the
				 * checksum in their output routines.
				 */
				ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
				error = ipe4_output(m, tdb, &mp);
d620 1
a623 5
				/*
				 * Fix checksum if IP-IP; AH and ESP fix the
				 * IP header checksum in their 
				 * output routines.
				 */
d625 1
d629 1
a629 2

			error = (*(tdb->tdb_xform->xf_output))(m, tdb, &mp);
d642 1
d644 1
a644 2
			if (tdb->tdb_xform->xf_type == XF_IP4)
			  ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
d649 2
@


1.52
log
@pfkeyv2 aquire should not happen when bypassing IPsec. Add missing splx().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.51 1999/10/29 02:10:02 angelos Exp $	*/
d132 6
d175 172
d349 1
a349 1
	 * Check if the packet needs encapsulation
a355 6
		struct route_enc re0, *re = &re0;
		struct sockaddr_encap *ddst, *gw;
		struct tdb *tdb, *t;
		int s;
		u_int8_t sa_require, sa_have = 0;

d368 5
a372 1
		/* Check if there was a bound outgoing SA */
d374 1
a374 2
		    (inp->inp_tdb->tdb_dst.sin.sin_addr.s_addr ==
		     INADDR_ANY ||
d435 2
a436 1
		 * don't want to have IPsec applied on.
d445 3
a447 1
		if (gw == NULL || gw->sen_type != SENT_IPSP) {
a457 44
		/* 
		 * For VPNs a route with a reserved SPI of 0 is used to
		 * indicate the need for an SA when none is established.
		 */
		if (ntohl(gw->sen_ipsp_spi) == SPI_LOCAL_USE) {
			bzero(&sunion, sizeof(sunion));
			sunion.sin.sin_family = AF_INET;
			sunion.sin.sin_len = sizeof(struct sockaddr_in);
			sunion.sin.sin_addr = gw->sen_ipsp_dst;
			tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, &sunion,
						    gw->sen_ipsp_sproto);

			if (tdb)
			{
			    if (tdb->tdb_authalgxform)
			      sa_require = NOTIFY_SATYPE_AUTH;
			    if (tdb->tdb_encalgxform)
			      sa_require |= NOTIFY_SATYPE_CONF;
			    if (tdb->tdb_flags & TDBF_TUNNELING)
			      sa_require |= NOTIFY_SATYPE_TUNNEL;
			}
			else /* No TDB found */
			{
			    /*
			     * XXX We should construct a TDB from system
			     * default (which should be tunable via sysctl).
			     * For now, drop packet and ignore SPD entry.
			     */
			    splx(s);
			    goto no_encap;
			}

			/* PF_KEYv2 notification message */
			if (tdb->tdb_satype != SADB_X_SATYPE_BYPASS)
			    pfkeyv2_acquire(tdb, 0); /* XXX Check for errors */

			splx(s);

			/* 
			 * When sa_require is set, the packet will be dropped
			 * at no_encap.
			 */
			goto no_encap;
		}
d467 14
a480 3
		sunion.sin.sin_family = AF_INET;
		sunion.sin.sin_len = sizeof(struct sockaddr_in);
		sunion.sin.sin_addr = gw->sen_ipsp_dst;
d484 40
a523 1
	      have_tdb:
d540 6
a545 1
		        DPRINTF(("ip_output(): non-existant TDB for SA %s/%08x/%u\n", inet_ntoa4(gw->sen_ipsp_dst), ntohl(gw->sen_ipsp_spi), gw->sen_ipsp_sproto));
a565 47
		/* Fix the ip_src field if necessary */
		if (ip->ip_src.s_addr == INADDR_ANY) {
		    if (tdb && tdb->tdb_src.sin.sin_addr.s_addr != 0 &&
			tdb->tdb_src.sa.sa_family == AF_INET)
		      ip->ip_src = tdb->tdb_src.sin.sin_addr;
		    else
		    {
			if (ro == 0) {
			    ro = &iproute;
			    bzero((caddr_t)ro, sizeof (*ro));
			}

			dst = satosin(&ro->ro_dst);

			/*
			 * If there is a cached route,
			 * check that it is to the same destination
			 * and is still up.  If not, free it and try again.
			 */
			if (ro->ro_rt &&
			    ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
			     dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
			    RTFREE(ro->ro_rt);
			    ro->ro_rt = (struct rtentry *)0;
			}

			if (ro->ro_rt == 0) {
			    dst->sin_family = AF_INET;
			    dst->sin_len = sizeof(*dst);
			    dst->sin_addr = ip->ip_dst;
			    rtalloc(ro);
			}			

			if (ro->ro_rt == 0) {
			    splx(s);
			    ipstat.ips_noroute++;
			    error = EHOSTUNREACH;
			    m_freem(m);
			    goto done;
			}
			
			ia = ifatoia(ro->ro_rt->rt_ifa);
			ro->ro_rt->rt_use++;
			ip->ip_src = ia->ia_addr.sin_addr;
		    }
		}

d577 10
d592 1
a592 1
    
d594 7
a600 9
			if (((tdb->tdb_dst.sin.sin_addr.s_addr !=
			      INADDR_ANY &&
			      tdb->tdb_dst.sin.sin_addr.s_addr !=
			      ip->ip_dst.s_addr) ||
			     (tdb->tdb_flags & TDBF_TUNNELING)) &&
			     (tdb->tdb_xform->xf_type != XF_IP4))
			{
			        DPRINTF(("ip_output(): tunneling\n"));

d605 1
a605 1
				ip->ip_sum = in_cksum(m, hlen);
d625 1
a625 1
				ip->ip_sum = in_cksum(m, hlen);
d628 1
d661 1
a661 1
		    IP_ENCAPSULATED | IP_RAWOUTPUT, NULL, NULL);
a675 172
	/*
	 * Route packet.
	 */
	if (ro == 0) {
		ro = &iproute;
		bzero((caddr_t)ro, sizeof (*ro));
	}
	dst = satosin(&ro->ro_dst);
	/*
	 * If there is a cached route,
	 * check that it is to the same destination
	 * and is still up.  If not, free it and try again.
	 */
	if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
	    dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
		RTFREE(ro->ro_rt);
		ro->ro_rt = (struct rtentry *)0;
	}
	if (ro->ro_rt == 0) {
		dst->sin_family = AF_INET;
		dst->sin_len = sizeof(*dst);
		dst->sin_addr = ip->ip_dst;
	}
	/*
	 * If routing to interface only,
	 * short circuit routing lookup.
	 */
	if (flags & IP_ROUTETOIF) {
		if ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == 0 &&
		    (ia = ifatoia(ifa_ifwithnet(sintosa(dst)))) == 0) {
			ipstat.ips_noroute++;
			error = ENETUNREACH;
			goto bad;
		}
		ifp = ia->ia_ifp;
		ip->ip_ttl = 1;
	} else {
		if (ro->ro_rt == 0)
			rtalloc(ro);
		if (ro->ro_rt == 0) {
			ipstat.ips_noroute++;
			error = EHOSTUNREACH;
			goto bad;
		}
		ia = ifatoia(ro->ro_rt->rt_ifa);
		ifp = ro->ro_rt->rt_ifp;
		ro->ro_rt->rt_use++;
		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			dst = satosin(ro->ro_rt->rt_gateway);
	}
	if (IN_MULTICAST(ip->ip_dst.s_addr)) {
		struct in_multi *inm;

		m->m_flags |= M_MCAST;
		/*
		 * IP destination address is multicast.  Make sure "dst"
		 * still points to the address in "ro".  (It may have been
		 * changed to point to a gateway address, above.)
		 */
		dst = satosin(&ro->ro_dst);
		/*
		 * See if the caller provided any multicast options
		 */
		if (imo != NULL) {
			ip->ip_ttl = imo->imo_multicast_ttl;
			if (imo->imo_multicast_ifp != NULL)
				ifp = imo->imo_multicast_ifp;
		} else
			ip->ip_ttl = IP_DEFAULT_MULTICAST_TTL;
		/*
		 * Confirm that the outgoing interface supports multicast.
		 */
		if ((ifp->if_flags & IFF_MULTICAST) == 0) {
			ipstat.ips_noroute++;
			error = ENETUNREACH;
			goto bad;
		}
		/*
		 * If source address not specified yet, use address
		 * of outgoing interface.
		 */
		if (ip->ip_src.s_addr == INADDR_ANY) {
			register struct in_ifaddr *ia;

			for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next)
				if (ia->ia_ifp == ifp) {
					ip->ip_src = ia->ia_addr.sin_addr;
					break;
				}
		}

		IN_LOOKUP_MULTI(ip->ip_dst, ifp, inm);
		if (inm != NULL &&
		   (imo == NULL || imo->imo_multicast_loop)) {
			/*
			 * If we belong to the destination multicast group
			 * on the outgoing interface, and the caller did not
			 * forbid loopback, loop back a copy.
			 */
			ip_mloopback(ifp, m, dst);
		}
#ifdef MROUTING
		else {
			/*
			 * If we are acting as a multicast router, perform
			 * multicast forwarding as if the packet had just
			 * arrived on the interface to which we are about
			 * to send.  The multicast forwarding function
			 * recursively calls this function, using the
			 * IP_FORWARDING flag to prevent infinite recursion.
			 *
			 * Multicasts that are looped back by ip_mloopback(),
			 * above, will be forwarded by the ip_input() routine,
			 * if necessary.
			 */
			extern struct socket *ip_mrouter;

			if (ip_mrouter && (flags & IP_FORWARDING) == 0) {
				if (ip_mforward(m, ifp) != 0) {
					m_freem(m);
					goto done;
				}
			}
		}
#endif
		/*
		 * Multicasts with a time-to-live of zero may be looped-
		 * back, above, but must not be transmitted on a network.
		 * Also, multicasts addressed to the loopback interface
		 * are not sent -- the above call to ip_mloopback() will
		 * loop back a copy if this host actually belongs to the
		 * destination group on the loopback interface.
		 */
		if (ip->ip_ttl == 0 || (ifp->if_flags & IFF_LOOPBACK) != 0) {
			m_freem(m);
			goto done;
		}

		goto sendit;
	}
#ifndef notdef
	/*
	 * If source address not specified yet, use address
	 * of outgoing interface.
	 */
	if (ip->ip_src.s_addr == INADDR_ANY)
		ip->ip_src = ia->ia_addr.sin_addr;
#endif
	/*
	 * Look for broadcast address and
	 * and verify user is allowed to send
	 * such a packet.
	 */
	if (in_broadcast(dst->sin_addr, ifp)) {
		if ((ifp->if_flags & IFF_BROADCAST) == 0) {
			error = EADDRNOTAVAIL;
			goto bad;
		}
		if ((flags & IP_ALLOWBROADCAST) == 0) {
			error = EACCES;
			goto bad;
		}
		/* don't allow broadcast messages to be fragmented */
		if ((u_int16_t)ip->ip_len > ifp->if_mtu) {
			error = EMSGSIZE;
			goto bad;
		}
		m->m_flags |= M_BCAST;
	} else
		m->m_flags &= ~M_BCAST;

sendit:
@


1.51
log
@Get rid of unnecessary third argument in *_output routines of IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.50 1999/10/29 02:04:02 angelos Exp $	*/
d71 1
d308 1
d313 2
a314 1
			pfkeyv2_acquire(tdb, 0); /* XXX Check for errors */
@


1.50
log
@Remove unused third argument from ipe4_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.49 1999/07/15 14:15:41 niklas Exp $	*/
d475 1
a475 2
			error = (*(tdb->tdb_xform->xf_output))(m, gw,
			    tdb, &mp);
@


1.49
log
@From angelos@@, edits by me, demand keying for PF_KEY
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.48 1999/06/15 02:24:02 deraadt Exp $	*/
d453 1
a453 1
				error = ipe4_output(m, gw, tdb, &mp);
@


1.48
log
@handle multicast packets inside ipf too; darren
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.47 1999/05/16 21:48:36 niklas Exp $	*/
d93 2
d280 1
a280 1
		 * For VPNs a route with a reserved SPI of 1 is used to
d283 29
a311 4
		if (ntohl(gw->sen_ipsp_spi) == 0x1) {
			sa_require = NOTIFY_SATYPE_AUTH | NOTIFY_SATYPE_TUNNEL;
			if (gw->sen_ipsp_sproto == IPPROTO_ESP)
			    sa_require |= NOTIFY_SATYPE_CONF;
a312 2
			/* XXX PF_KEYv2 notification message */
			
@


1.47
log
@spltdb introduced, protection for tdb lists and related structures, so
they won't disappear behind our back by an expiration.  Cleanup expiration
logic too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.46 1999/05/14 23:36:20 niklas Exp $	*/
d669 1
a682 1
sendit:
@


1.46
log
@A new scalable IPsec SA expiration model.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.45 1999/04/11 19:41:39 niklas Exp $	*/
d178 1
d188 5
d203 2
a204 1
		if (!ipsec_in_use)
d206 1
d247 2
a248 1
		if (re->re_rt == NULL)
d250 1
d261 2
a262 1
		    (gw->sen_ipsp_sproto == 0) && (gw->sen_ipsp_spi == 0))
d264 1
d267 1
d288 2
d327 1
d383 1
d399 1
d410 1
a410 1
				tdb_expiration(tdb, 0);
d432 1
d455 1
d470 1
d890 3
d994 1
a996 1
				break;
d998 4
a1001 7
				struct tdb *tdb;
				struct tdb_ident *tdbi;

				tdbi = mtod(m, struct tdb_ident *);
				tdb = gettdb(tdbi->spi, &tdbi->dst,
					     tdbi->proto);
				if (tdb == NULL) {
d1003 2
a1004 3
					break;
				}
				tdb_add_inp(tdb, inp);
d1006 1
d1142 1
a1144 1
				break;
a1145 1
				struct tdb_ident tdbi;
d1152 1
a1152 1
				      (unsigned)m->m_len);
d1154 1
@


1.45
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.44 1999/03/27 21:04:20 provos Exp $	*/
a127 1
	struct expiration *exp;
d391 2
a392 25
			        tdb->tdb_first_use = time.tv_sec;
			    
 			        if (tdb->tdb_flags & TDBF_FIRSTUSE) {
				    exp = get_expiration();
				    bcopy(&tdb->tdb_dst, &exp->exp_dst,
					  SA_LEN(&tdb->tdb_dst.sa));
				    exp->exp_spi = tdb->tdb_spi;
				    exp->exp_sproto = tdb->tdb_sproto;
				    exp->exp_timeout = tdb->tdb_first_use +
						   tdb->tdb_exp_first_use;
				    put_expiration(exp);
				}

				if ((tdb->tdb_flags & TDBF_SOFT_FIRSTUSE) &&
				    (tdb->tdb_soft_first_use <=
				    tdb->tdb_exp_first_use)) {
					exp = get_expiration();
					bcopy(&tdb->tdb_dst, &exp->exp_dst,
					      SA_LEN(&tdb->tdb_dst.sa));
					exp->exp_spi = tdb->tdb_spi;
					exp->exp_sproto = tdb->tdb_sproto;
					exp->exp_timeout = tdb->tdb_first_use +
					    tdb->tdb_soft_first_use;
					put_expiration(exp);
				}
d394 1
a394 1

@


1.44
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.43 1999/03/24 17:00:47 niklas Exp $	*/
d67 2
a68 1
#include <netinet/ip_ipsp.h>
d171 1
a171 1
	if (!(flags & IP_ENCAPSULATED) && 
d173 3
a175 3
	     (inp->inp_seclevel[SL_AUTH] != IPSEC_LEVEL_BYPASS ||
	      inp->inp_seclevel[SL_ESP_TRANS] != IPSEC_LEVEL_BYPASS ||
	      inp->inp_seclevel[SL_ESP_NETWORK] != IPSEC_LEVEL_BYPASS))) {
d178 1
a178 1
		struct tdb *tdb;
d321 12
@


1.43
log
@Implement lifetime expiration notifications.  Fix some typos.  Remove statics.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.42 1999/03/06 20:59:41 angelos Exp $	*/
d170 1
a170 2
	if ((ipsec_in_use != 0) &&
	    !(flags & IP_ENCAPSULATED) && 
d186 14
a281 4
		ip->ip_len = htons((u_short)ip->ip_len);
		ip->ip_off = htons((u_short)ip->ip_off);
		ip->ip_sum = 0;

d296 6
d372 2
a373 1
				RTFREE(re->re_rt);
d408 2
d425 2
a426 1
					RTFREE(re->re_rt);
d449 2
a450 1
				RTFREE(re->re_rt);
d467 2
a468 1
		RTFREE(re->re_rt);
d977 22
d1126 20
@


1.42
log
@Update IP pointer, when doing multiple transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.41 1999/02/24 23:45:52 angelos Exp $	*/
a88 1
extern void	encap_sendnotify __P((int, struct tdb *, void *));
@


1.41
log
@Update copyright; remove a few annoying debugging printfs.

Btw, OpenBSD hit 25000 commits a couple commits ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.40 1999/02/24 22:33:07 angelos Exp $	*/
d436 3
a438 5
			if (tdb->tdb_xform->xf_type == XF_IP4) {
			        /* If IP-IP, calculate outter header cksum */
			        ip = mtod(m, struct ip *);
				ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
			}
@


1.40
log
@Remove encap.h include; saner debugging printfs; fix buglets; work with
pfkeyv2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.39 1999/01/11 00:42:53 angelos Exp $	*/
a360 3

			DPRINTF(("ip_output(): calling %s\n",
				tdb->tdb_xform->xf_name));
@


1.39
log
@Remove duplicate code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.38 1999/01/08 21:51:22 provos Exp $	*/
a66 1
#include <net/encap.h>
d70 6
a75 1
#include <sys/syslog.h>
d124 1
d171 2
a172 1
	if (!(flags & IP_ENCAPSULATED) && 
d189 1
a189 1
		ddst->sen_family = AF_ENCAP;
d243 2
a244 4
#ifdef ENCDEBUG
			if (encdebug)
				printf("ip_output(): no gw or gw data not IPSP\n");
#endif /* ENCDEBUG */
a256 2
			struct tdb tmptdb;

d261 1
a261 5
			tmptdb.tdb_dst.s_addr = gw->sen_ipsp_dst.s_addr;
			tmptdb.tdb_satype = sa_require;
			       
			/* Request SA with key management */
			encap_sendnotify(NOTIFY_REQUEST_SA, &tmptdb, NULL);
d281 6
a286 2
		tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, gw->sen_ipsp_dst,
		    gw->sen_ipsp_sproto);
d298 2
a299 4
#ifdef ENCDEBUG
			if (encdebug)
				printf("ip_output(): non-existant TDB for SA %08x/%x/%d\n", ntohl(gw->sen_ipsp_spi), gw->sen_ipsp_dst, gw->sen_ipsp_sproto);
#endif
d309 3
a311 2
		    if (tdb && tdb->tdb_src.s_addr != 0)   /* Provided */
			ip->ip_src = tdb->tdb_src;
a352 9
#ifdef ENCDEBUG
		if (encdebug) {
			printf("ip_output(): tdb=%08x, tdb->tdb_xform=0x%x,",
			    tdb, tdb->tdb_xform);
			printf(" tdb->tdb_xform->xf_output=%x, sproto=%x\n",
			    tdb->tdb_xform->xf_output, tdb->tdb_sproto);
		}
#endif /* ENCDEBUG */

d356 1
a356 3
			 	if (encdebug)
				  log(LOG_ALERT, "ip_output(): attempt to use invalid SA %08x/%x/%x\n", ntohl(tdb->tdb_spi), tdb->tdb_dst,
				    tdb->tdb_sproto);
d362 2
a363 5
#ifdef ENCDEBUG
			if (encdebug)
				printf("ip_output(): calling %s\n",
				       tdb->tdb_xform->xf_name);
#endif /* ENCDEBUG */
d367 11
a377 13
			    tdb->tdb_first_use = time.tv_sec;

				if (tdb->tdb_flags & TDBF_FIRSTUSE) {
					exp = get_expiration();
					if (exp == NULL)
						goto expbail;
					exp->exp_dst.s_addr =
					    tdb->tdb_dst.s_addr;
					exp->exp_spi = tdb->tdb_spi;
					exp->exp_sproto = tdb->tdb_sproto;
					exp->exp_timeout = tdb->tdb_first_use +
					    tdb->tdb_exp_first_use;
					put_expiration(exp);
d384 2
a385 10
					if (exp == NULL) {
expbail:
						if (encdebug)
						  log(LOG_WARNING, "ip_output(): no memory for exp timer\n");
						m_freem(m);
						RTFREE(re->re_rt);
						return ENOBUFS;
					}
					exp->exp_dst.s_addr =
					    tdb->tdb_dst.s_addr;
d395 6
a400 6
			if ((tdb->tdb_flags & TDBF_TUNNELING) &&
			    (tdb->tdb_xform->xf_type != XF_IP4)){
#ifdef ENCDEBUG
				if (encdebug)
					printf("ip_output(): tunneling\n");
#endif /* ENCDEBUG */
@


1.38
log
@dont call ip_randomid() in htons().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.37 1998/12/26 12:35:11 provos Exp $	*/
a371 64
			/* Check for tunneling */
			if ((tdb->tdb_flags & TDBF_TUNNELING) &&
			    (tdb->tdb_xform->xf_type != XF_IP4)){
#ifdef ENCDEBUG
				if (encdebug)
					printf("ip_output(): tunneling\n");
#endif /* ENCDEBUG */

				/*
				 * Register first use,
				 * setup expiration timer
				 */
				if (tdb->tdb_first_use == 0) {
					tdb->tdb_first_use = time.tv_sec;

					if (tdb->tdb_flags & TDBF_FIRSTUSE) {
						exp = get_expiration();
						if (exp == NULL)
							goto expbail;
						exp->exp_dst.s_addr =
						    tdb->tdb_dst.s_addr;
						exp->exp_spi = tdb->tdb_spi;
						exp->exp_sproto =
						    tdb->tdb_sproto;
						exp->exp_timeout =
						    tdb->tdb_first_use +
						    tdb->tdb_exp_first_use;
						put_expiration(exp);
					}

					if ((tdb->tdb_flags &
					    TDBF_SOFT_FIRSTUSE) &&
					    (tdb->tdb_soft_first_use <=
						tdb->tdb_exp_first_use)) {
						exp = get_expiration();
						if (exp == NULL)
							goto expbail;
						exp->exp_dst.s_addr =
						    tdb->tdb_dst.s_addr;
						exp->exp_spi = tdb->tdb_spi;
						exp->exp_sproto =
						    tdb->tdb_sproto;
						exp->exp_timeout =
						    tdb->tdb_first_use +
						    tdb->tdb_soft_first_use;
						put_expiration(exp);
					}
				}

				/*
				 * Fix checksum here, AH and ESP fix the
				 * checksum in their output routines.
				 */
				ip->ip_sum = in_cksum(m, hlen);
				error = ipe4_output(m, gw, tdb, &mp);
				if (mp == NULL)
					error = EFAULT;
				if (error) {
					RTFREE(re->re_rt);
					return error;
				}
				m = mp;
			}

d415 23
@


1.37
log
@make ip_id random but ensure that ids dont repeat for some period.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.36 1998/08/02 22:20:30 provos Exp $	*/
d154 2
a155 1
		ip->ip_id = htons(ip_randomid());
@


1.36
log
@cleanup ipsec error handling
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.35 1998/08/01 08:35:11 provos Exp $	*/
d154 1
a154 1
		ip->ip_id = htons(ip_id++);
@


1.35
log
@more careful error handling, some simplification and beautification.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.34 1998/07/29 22:18:48 angelos Exp $	*/
d243 2
a244 1
			goto bad;
d302 2
a303 1
			goto bad;
d341 2
a342 1
			    goto bad;
d528 3
a530 1
		if (sa_require)
d532 1
@


1.34
log
@Proper handling of IP in IP and checksumming.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.33 1998/07/29 21:13:07 angelos Exp $	*/
d240 2
a241 1
			RTFREE(re->re_rt);
d293 1
d295 8
a302 5
		if (encdebug && (tdb == NULL))
			printf("ip_output(): non-existant TDB for SA %08x/%x/%d\n",
			    ntohl(gw->sen_ipsp_spi), gw->sen_ipsp_dst,
			    gw->sen_ipsp_sproto);
#endif ENCDEBUG
d489 1
a489 1
			if (mp == NULL)
d492 2
@


1.33
log
@Don't do checksumming unless we're doing IP-in-IP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.32 1998/06/30 23:50:17 provos Exp $	*/
d472 10
d490 8
a498 1
			m = mp;
@


1.32
log
@remove unnecessary assignment
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.31 1998/06/03 10:00:19 provos Exp $	*/
a342 3
		/* Now fix the checksum */
		ip->ip_sum = in_cksum(m, hlen);

d412 5
@


1.31
log
@request only auth in notify when vpn ipsec route is found with a different
security protocol than IPPROTO_ESP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.30 1998/05/24 23:03:47 provos Exp $	*/
a355 2
			m0 = NULL;

@


1.30
log
@allow SAs with non-specified source address
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.29 1998/05/24 14:14:00 provos Exp $	*/
d252 4
a255 2
			sa_require = NOTIFY_SATYPE_CONF | NOTIFY_SATYPE_AUTH |
				NOTIFY_SATYPE_TUNNEL;
@


1.29
log
@add support for Virtual Private Networks (VPN).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.28 1998/05/19 18:42:01 deraadt Exp $	*/
d171 1
a171 1
		struct sockaddr_encap *dst, *gw;
d181 7
a187 7
		dst = (struct sockaddr_encap *) &re->re_dst;
		dst->sen_family = AF_ENCAP;
		dst->sen_len = SENT_IP4_LEN;
		dst->sen_type = SENT_IP4;
		dst->sen_ip_src = ip->ip_src;
		dst->sen_ip_dst = ip->ip_dst;
		dst->sen_proto = ip->ip_p;
d198 2
a199 2
			dst->sen_sport = ntohs(udp->uh_sport);
			dst->sen_dport = ntohs(udp->uh_dport);
d210 2
a211 2
			dst->sen_sport = ntohs(tcp->th_sport);
			dst->sen_dport = ntohs(tcp->th_dport);
d215 2
a216 2
			dst->sen_sport = 0;
			dst->sen_dport = 0;
d298 2
a299 1
		if ((ip->ip_src.s_addr == INADDR_ANY) && tdb)
d301 39
@


1.28
log
@Wall for non-IPSEC case
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.27 1998/05/18 21:11:02 provos Exp $	*/
d85 1
d245 22
d458 2
a459 3
		/* We did no IPSec encapsulation but the socket required it */
		if (sa_require) {
			error = EHOSTUNREACH;
a460 1
		}
@


1.27
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.25 1998/02/03 19:06:30 deraadt Exp $	*/
d833 1
d835 1
@


1.26
log
@Fix tunnel mode input processing (use ip4_input instead of ipe4_input),
fix some old code leftovers in ah_new_input (adjust to variable hash length),
avoid double ip encapsulation in tunnel mode. Problems reportd by
Petr Novak <petr@@internet.cz>.
@
text
@d48 1
d72 3
d84 6
d123 1
d131 3
d164 6
a169 5
	if (!(flags & IP_ENCAPSULATED)) {
		struct route_enc {
			struct	rtentry *re_rt;
			struct	sockaddr_encap re_dst;
		} re0, *re = &re0;
d172 6
d258 9
d429 1
a429 1
		    IP_ENCAPSULATED | IP_RAWOUTPUT, NULL);
d435 5
d833 1
d937 1
a937 1
			if (m == 0 || m->m_len != sizeof(u_char)) {
d942 7
d951 5
d960 5
d969 5
d977 2
@


1.25
log
@bad types; wileyc@@sekiya.twics.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.24 1997/10/02 02:31:07 deraadt Exp $	*/
d274 2
a275 1
			if (tdb->tdb_flags & TDBF_TUNNELING) {
@


1.24
log
@conditional error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.23 1997/09/28 22:57:50 deraadt Exp $	*/
d1044 1
a1044 1
	register cnt, optlen;
@


1.23
log
@log() needs a \n
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.22 1997/08/26 20:07:38 deraadt Exp $	*/
d265 2
a266 3
				log(LOG_ALERT,
				    "ip_output(): attempt to use invalid SA %08x/%x/%x\n",
				    ntohl(tdb->tdb_spi), tdb->tdb_dst,
d360 2
a361 1
						log(LOG_WARNING, "ip_output(): no memory for exp timer\n");
@


1.22
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.21 1997/08/04 01:12:06 angelos Exp $	*/
d266 1
a266 1
				    "ip_output(): attempt to use invalid SA %08x/%x/%x",
d361 1
a361 2
						log(LOG_WARNING, "ip_output()"
						    ": no mem for exp timer");
@


1.21
log
@No more crashes because of this bug (double m_freem(), essentially).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.20 1997/07/31 00:40:21 deraadt Exp $	*/
d110 2
a111 2
        struct udphdr *udp;
        struct tcphdr *tcp;
d170 2
a171 2
		    	    	if ((m = m_pullup(m, hlen + 2 *
						  sizeof(u_int16_t))) == 0)
d173 1
a173 1
		    		ip = mtod(m, struct ip *);
a174 1

d182 2
a183 2
		    	    	if ((m = m_pullup(m, hlen + 2 *
						  sizeof(u_int16_t))) == 0)
d185 1
a185 1
		    		ip = mtod(m, struct ip *);
a186 1

a233 1

d235 1
a235 1
					    gw->sen_ipsp_sproto);
d239 3
a241 3
		  printf("ip_output(): non-existant TDB for SA %08x/%x/%d\n",
			 ntohl(gw->sen_ipsp_spi), gw->sen_ipsp_dst,
			 gw->sen_ipsp_sproto);
d246 1
a246 1
		 	ip->ip_src = tdb->tdb_src;
d252 6
a257 2
		if (encdebug)
			printf("ip_output(): tdb=%08x, tdb->tdb_xform=0x%x, tdb->tdb_xform->xf_output=%x, sproto=%x\n", tdb, tdb->tdb_xform, tdb->tdb_xform->xf_output, tdb->tdb_sproto);
d265 4
a268 1
				log(LOG_ALERT, "ip_output(): attempt to use invalid SA %08x/%x/%x", ntohl(tdb->tdb_spi), tdb->tdb_dst, tdb->tdb_sproto);
d277 2
a278 2
			        if (encdebug)
			                printf("ip_output(): tunneling\n");
d281 3
a283 3
				/* 
				 * Register first use, 
				 * setup expiration timer 
d286 15
a300 9
				    tdb->tdb_first_use = time.tv_sec;
				    
				    if (tdb->tdb_flags & TDBF_FIRSTUSE) {
					exp = get_expiration();
					if (exp == (struct expiration *) NULL) {
					    log(LOG_WARNING, "ip_output(): out of memory for expiration timer");
					    m_freem(m);
					    RTFREE(re->re_rt);
					    return ENOBUFS;
d303 16
a318 17
					exp->exp_dst.s_addr = tdb->tdb_dst.s_addr;
					exp->exp_spi = tdb->tdb_spi;
					exp->exp_sproto = tdb->tdb_sproto;
					exp->exp_timeout = tdb->tdb_first_use + tdb->tdb_exp_first_use;

					put_expiration(exp);
				    }

				    if ((tdb->tdb_flags & TDBF_SOFT_FIRSTUSE) &&
					(tdb->tdb_soft_first_use <=
					tdb->tdb_exp_first_use)) {
					exp = get_expiration();
					if (exp == (struct expiration *) NULL) {
					    log(LOG_WARNING, "ip_output(): out of memory for expiration timer");
					    m_freem(m);
					    RTFREE(re->re_rt);
					    return ENOBUFS;
d320 1
a321 9
					exp->exp_dst.s_addr = tdb->tdb_dst.s_addr;
					exp->exp_spi = tdb->tdb_spi;
					exp->exp_sproto = tdb->tdb_sproto;
					exp->exp_timeout = tdb->tdb_first_use + tdb->tdb_soft_first_use;
					
					put_expiration(exp);
				    }
				}				
			    
d324 1
a324 1
				        error = EFAULT;
d326 1
a326 1
				        RTFREE(re->re_rt);
d341 12
a352 8
			    
			    if (tdb->tdb_flags & TDBF_FIRSTUSE) {
				exp = get_expiration();
				if (exp == (struct expiration *) NULL) {
				    log(LOG_WARNING, "ip_output(): out of memory for expiration timer");
				    m_freem(m);
				    RTFREE(re->re_rt);
				    return ENOBUFS;
d355 19
a373 18
				exp->exp_dst.s_addr = tdb->tdb_dst.s_addr;
				exp->exp_spi = tdb->tdb_spi;
				exp->exp_sproto = tdb->tdb_sproto;
				exp->exp_timeout = tdb->tdb_first_use + 
						   tdb->tdb_exp_first_use;

				put_expiration(exp);
			    }

			    if ((tdb->tdb_flags & TDBF_SOFT_FIRSTUSE) &&
				(tdb->tdb_soft_first_use <= 
				 tdb->tdb_exp_first_use)) {
				exp = get_expiration();
				if (exp == (struct expiration *) NULL) {
				    log(LOG_WARNING, "ip_output(): out of memory for expiration timer");
				    m_freem(m);
				    RTFREE(re->re_rt);
				    return ENOBUFS;
a374 9

				exp->exp_dst.s_addr = tdb->tdb_dst.s_addr;
				exp->exp_spi = tdb->tdb_spi;
				exp->exp_sproto = tdb->tdb_sproto;
				exp->exp_timeout = tdb->tdb_first_use + 
						   tdb->tdb_soft_first_use;
				
				put_expiration(exp);
			    }
d377 2
a378 1
			error = (*(tdb->tdb_xform->xf_output))(m, gw, tdb, &mp);
a393 1

a394 1

d398 2
a399 3

		return ip_output(m, NULL, NULL, IP_ENCAPSULATED | IP_RAWOUTPUT,
				 NULL);
d899 1
a899 1
		    error = EINVAL;
d901 4
a904 3
		    if (m == 0 || m->m_len != sizeof(u_char))
		      error = EINVAL;
		    else {
a905 1
			
d907 1
a907 1
			    case IP_AUTH_LEVEL:
d911 1
a911 1
			    case IP_ESP_TRANS_LEVEL:
d914 2
a915 2
				
			    case IP_ESP_NETWORK_LEVEL:
a918 2
			
		    }
d920 2
a921 2
		    break;
		    
d1003 1
a1003 1
		    *mtod(m, int *) = IPSEC_LEVEL_NONE;
d1005 2
a1006 2
		    switch (optname) {
			    case IP_AUTH_LEVEL:
d1009 2
a1010 2
				
			    case IP_ESP_TRANS_LEVEL:
d1013 2
a1014 2
				
			    case IP_ESP_NETWORK_LEVEL:
d1017 2
a1018 3
		    }
		    
		    *mtod(m, int *) = optval;
d1020 1
a1020 2
		    break;
				
@


1.20
log
@some indentation stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.19 1997/07/27 23:30:37 niklas Exp $	*/
a166 6
		if (m->m_len < hlen + 2 * sizeof(u_int16_t)) {
		    if ((m = m_pullup(m, hlen + 2 * sizeof(u_int16_t))) == 0)
			goto bad;
		    ip = mtod(m, struct ip *);
		}

d169 7
d182 7
@


1.19
log
@expiration messages, fixes, updates, all sorts of things
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.18 1997/07/18 18:09:57 provos Exp $	*/
d273 1
a273 2
				if (tdb->tdb_first_use == 0)
				{
d276 1
a276 2
				    if (tdb->tdb_flags & TDBF_FIRSTUSE)
				    {
d278 1
a278 2
					if (exp == (struct expiration *) NULL)
					{
d294 2
a295 2
					(tdb->tdb_soft_first_use <= tdb->tdb_exp_first_use))
				    {
d297 1
a297 2
					if (exp == (struct expiration *) NULL)
					{
d330 1
a330 2
			if (tdb->tdb_first_use == 0)
			{
d333 1
a333 2
			    if (tdb->tdb_flags & TDBF_FIRSTUSE)
			    {
d335 1
a335 2
				if (exp == (struct expiration *) NULL)
				{
d353 1
a353 2
				 tdb->tdb_exp_first_use))
			    {
d355 1
a355 2
				if (exp == (struct expiration *) NULL)
				{
@


1.18
log
@enablespi/disablespi in encap + print spi's in hostorder
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.17 1997/07/14 08:45:55 provos Exp $	*/
d112 1
d196 11
a211 1
			m_freem(m);
d213 2
a214 1
			return EHOSTUNREACH;
a221 10
		 * There might be a specific route, that tells us to avoid
		 * doing IPsec; this is useful for specific routes that we
		 * don't want to have IPsec applied on.
		 */

		if ((gw->sen_ipsp_dst.s_addr == 0) &&
		    (gw->sen_ipsp_sproto == 0) && (gw->sen_ipsp_spi == 0))
			goto no_encap;

		/*
d269 4
a272 1
				/* Register first use */
d274 42
a315 1
				      tdb->tdb_first_use = time.tv_sec;
d333 1
a333 1
			/* Register first use */
d335 45
a379 1
			        tdb->tdb_first_use = time.tv_sec;
@


1.17
log
@routes with zero spi can be used to avoid ipsec processing
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.16 1997/07/11 23:37:59 provos Exp $	*/
d230 7
d254 1
a254 1
				log(LOG_ALERT, "ip_output(): attempt to use invalid SA %x/%08x/%x", tdb->tdb_dst, tdb->tdb_spi, tdb->tdb_sproto);
@


1.16
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.15 1997/07/01 22:12:53 provos Exp $	*/
d208 10
@


1.15
log
@major restructuring
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.14 1997/06/25 07:53:29 provos Exp $	*/
d70 1
d157 2
a158 2
		bzero((caddr_t)re, sizeof (*re));
		dst = (struct sockaddr_encap *)&re->re_dst;
d178 1
d184 1
d189 2
a190 1
		rtalloc((struct route *)re);
d194 1
a194 1
		gw = (struct sockaddr_encap *)(re->re_rt->rt_gateway);
d198 1
a198 1
				printf("ip_output: no gw or gw data not IPSP\n");
d217 2
a218 1
		tdb = (struct tdb *) gettdb(gw->sen_ipsp_spi, gw->sen_ipsp_dst);
a223 15
		/* 
		 * If we're doing IP-in-IP first, let the options be.
		 * Otherwise, get rid of them.
  		 * XXX This means we don't send packets with IP options
		 * XXX unless they're encapsulated (and, presumably,
		 * XXX subsequently authenticated).
		 */
		if (tdb && tdb->tdb_xform)
		    if ((tdb->tdb_xform->xf_type != XF_IP4) ||
			(tdb->tdb_flags & TDBF_TUNNELING))
		          if (hlen > sizeof (struct ip)) {	/* XXX IPOPT */
			          ip_stripoptions(m, (struct mbuf *)0);
				  hlen = sizeof (struct ip);
			  }

d229 1
a229 1
			printf("ip_output: tdb=0x%x, tdb->tdb_xform=0x%x, tdb->tdb_xform->xf_output=%x\n", tdb, tdb->tdb_xform, tdb->tdb_xform->xf_output);
d236 2
a237 6
			if (tdb->tdb_flags & TDBF_INVALID)
			{
#ifdef ENCDEBUG
				if (encdebug)
					printf("ip_output: attempt to use invalid SPI %08x", tdb->tdb_spi);
#endif /* ENCDEBUG */
d247 1
a247 1
			                printf("ip_output: doing tunneling\n");
d266 2
a267 2
				printf("ip_output: calling %s\n",
				    tdb->tdb_xform->xf_name);
d297 2
a298 1
		return ip_output(m, NULL, NULL, IP_ENCAPSULATED | IP_RAWOUTPUT, NULL);
@


1.14
log
@hard and soft limits for SPI's per absolute timer, relative since establish,
relative since first use timers, packet and byte counters. notify key mgmt
on soft limits. key mgmt can now specify limits. new encap messages:
EMT_RESERVESPI, EMT_ENABLESPI, EMT_DISABLESPI
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.13 1997/06/24 12:15:27 provos Exp $	*/
a200 51
		ifp = re->re_rt->rt_ifp;

		if (ip->ip_src.s_addr == INADDR_ANY) {
			struct sockaddr_encap *sen;
			struct sockaddr_in *sinp;

			if (ifp->if_addrlist.tqh_first)
				sen = (struct sockaddr_encap *)
				    ifp->if_addrlist.tqh_first->ifa_addr;
			else {
#ifdef ENCDEBUG
				if (encdebug)
					printf("ip_output: interface %s has no default address\n",
					    ifp->if_xname);
#endif /* ENCDEBUG */
				m_freem(m);
				RTFREE(re->re_rt);
				return ENXIO;
			}

			if (sen->sen_family != AF_ENCAP) {
#ifdef ENCDEBUG
				if (encdebug)
					printf("ip_output: %s does not have AF_ENCAP address\n",
					    ifp->if_xname);
#endif /* ENCDEBUG */
				m_freem(m);
				RTFREE(re->re_rt);
				return EHOSTDOWN;
			}

			if (sen->sen_type != SENT_DEFIF) {
#ifdef ENCDEBUG
				if (encdebug)
					printf("ip_output: %s does not have SENT_DEFIF address\n",
					    ifp->if_xname);
#endif /* ENCDEBUG */
				m_freem(m);
				RTFREE(re->re_rt);
				return EHOSTDOWN;
			}
			sinp = (struct sockaddr_in *)&(sen->sen_dfl);
			ip->ip_src = sinp->sin_addr;
		}

#ifdef ENCDEBUG
		if (encdebug)
			printf("ip_output: encapsulating %x->%x through %x->%x\n",
			    ip->ip_src.s_addr, ip->ip_dst.s_addr,
			    gw->sen_ipsp_src, gw->sen_ipsp_dst);
#endif
d215 4
d227 6
a232 5
		  if (tdb->tdb_xform->xf_type != XF_IP4)
 		    if (hlen > sizeof (struct ip)) {	/* XXX IPOPT */
 			ip_stripoptions(m, (struct mbuf *)0);
 			hlen = sizeof (struct ip);
 		    }
d257 21
d286 1
a286 1
			  tdb->tdb_first_use = time.tv_sec;
d300 1
a300 1
		 * At this point, mp is pointing to an mbuf chain with the
@


1.13
log
@handle IP options in AH + allow IP options in outgoing encapsulated packets
+ usage counters for later use with keymanagement processes
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.12 1997/06/16 06:32:51 deraadt Exp $	*/
d47 1
d165 2
a166 2
		if (m->m_len < hlen + 2*sizeof(u_int16_t)) {
		    if ((m = m_pullup(m, hlen + 2*sizeof(u_int16_t))) == 0)
d195 1
a195 1
#endif ENCDEBUG
d215 3
a217 1
#endif ENCDEBUG
d226 1
a226 1
#endif ENCDEBUG
d237 1
a237 1
#endif ENCDEBUG
d286 1
a286 1
#endif ENCDEBUG
d290 13
d307 6
a312 1
#endif ENCDEBUG
d359 1
a359 1
	   dst->sin_addr.s_addr != ip->ip_dst.s_addr)) {
@


1.12
log
@swap labels; adam@@math.tau.ac.il
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.11 1997/03/02 07:59:40 tholo Exp $	*/
a242 5
		if (hlen > sizeof (struct ip)) {	/* XXX IPOPT */
			ip_stripoptions(m, (struct mbuf *)0);
			hlen = sizeof (struct ip);
		}

a251 1
		ip->ip_sum = in_cksum(m, hlen);
d262 17
@


1.11
log
@Need to get a new pointer for the IP header after doing a pullup on the mbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.10 1997/03/02 07:32:15 angelos Exp $	*/
d171 1
a171 1
		case IPPROTO_TCP:
d176 1
a176 1
		case IPPROTO_UDP:
@


1.10
log
@Cosmetic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.9 1997/02/28 04:03:48 angelos Exp $	*/
d163 3
a165 3
		
		if ((m->m_len < hlen + 2*sizeof(u_int16_t)) &&
		    ((m = m_pullup(m, hlen + 2*sizeof(u_int16_t))) == 0))
d167 2
@


1.9
log
@Moved IPsec socket state to the PCB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.8 1997/02/28 03:44:54 angelos Exp $	*/
d305 1
d309 1
a309 1
#endif IPSEC
@


1.8
log
@IPsec socket API hooks are in.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.7 1997/02/20 01:08:06 deraadt Exp $	*/
d810 1
a810 1
				so->so_seclevel[SL_AUTH] = optval;
d814 1
a814 1
				so->so_seclevel[SL_ESP_TRANS] = optval;
d818 1
a818 1
				so->so_seclevel[SL_ESP_NETWORK] = optval;
d911 1
a911 1
				    optval = so->so_seclevel[SL_AUTH];
d915 1
a915 1
				    optval = so->so_seclevel[SL_ESP_TRANS];
d919 1
a919 1
				    optval = so->so_seclevel[SL_ESP_NETWORK];
@


1.7
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.5 1996/03/04 10:34:33 mickey Exp $	*/
d797 29
d903 24
@


1.6
log
@From FreeBSD (with slightly different sysctl names):

"... Allow the user to nominate one of three ranges of port numbers as
candidates for selecting a local address to replace a zero port number.
The ranges are selected via a setsockopt(s, IPPROTO_IP, IP_PORTRANGE, &arg)
call.  The three ranges are: default, high (to bypass firewalls) and
low (to get a port below 1024).

The default and high port ranges are sysctl settable under sysctl
net.inet.ip.portrange.* [net.inet.ip.portfirst, net.inet.ip.portlast,
net.inet.ip.porthifirst, and net.inet.ip.porthilast currently in OpenBSD.]

This code also fixes a potential deadlock if the system accidently ran out
of local port addresses. It'd drop into an infinite while loop.

The secure port selection (for root) should reduce overheads and increase
reliability of rlogin/rlogind/rsh/rshd if they are modified to take
advantage of it."
@
text
@d64 7
d106 5
d142 168
@


1.5
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_output.c,v 1.4 1996/03/03 22:30:41 niklas Exp $	*/
d586 31
d678 14
@


1.4
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
extern int (*fr_checkp) __P((struct ip *, int, struct ifnet *, int, struct mbuf **));
@


1.3
log
@IP filter 3.0.1
@
text
@d1 2
a2 1
/*	$NetBSD: ip_output.c,v 1.27 1995/07/01 03:44:55 cgd Exp $	*/
d46 1
d62 2
d78 4
a81 1
ip_output(m0, opt, ro, flags, imo)
d83 2
a84 4
	struct mbuf *opt;
	struct route *ro;
	int flags;
	struct ip_moptions *imo;
d94 14
d519 1
a519 1
	register int optval;
@


1.2
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d64 1
a64 1
extern int (*fr_checkp) __P((struct ip *, int, struct ifnet *, int));
a285 1
	if ((*fr_checkp)(ip, hlen, ifp, 1))
d287 6
a292 2
		error = EHOSTUNREACH;
		goto bad;
@


1.1
log
@Initial revision
@
text
@d63 3
d282 10
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

