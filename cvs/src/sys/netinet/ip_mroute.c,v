head	1.112;
access;
symbols
	OPENBSD_6_1:1.112.0.2
	OPENBSD_6_1_BASE:1.112
	OPENBSD_6_0:1.90.0.4
	OPENBSD_6_0_BASE:1.90
	OPENBSD_5_9:1.89.0.2
	OPENBSD_5_9_BASE:1.89
	OPENBSD_5_8:1.79.0.4
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.61.0.2
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.59.0.8
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.59.0.6
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.4
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.58.0.4
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.58.0.2
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.52.0.2
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.50.0.4
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.2
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.45.0.2
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.42.0.4
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.37.0.2
	OPENBSD_3_6_BASE:1.37
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.28
	UBC:1.23.0.4
	UBC_BASE:1.23
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.19.0.6
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.4
	OPENBSD_2_7_BASE:1.19
	SMP:1.19.0.2
	SMP_BASE:1.19
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.112
date	2017.03.17.14.59.29;	author rzalamena;	state Exp;
branches;
next	1.111;
commitid	QjjZrv2YZuWnnsUN;

1.111
date	2017.03.14.10.27.10;	author rzalamena;	state Exp;
branches;
next	1.110;
commitid	u94MBiggGC98whDQ;

1.110
date	2017.02.09.15.36.46;	author rzalamena;	state Exp;
branches;
next	1.109;
commitid	uAK9HoRavwA2XEXg;

1.109
date	2017.02.08.01.28.51;	author jsg;	state Exp;
branches;
next	1.108;
commitid	n9K5HwzPMPZ4hEyn;

1.108
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.107;
commitid	UBL7uwpXqTP4EWIu;

1.107
date	2017.01.12.08.22.42;	author rzalamena;	state Exp;
branches;
next	1.106;
commitid	LgZRMC67dCmUKQVm;

1.106
date	2017.01.11.13.17.35;	author rzalamena;	state Exp;
branches;
next	1.105;
commitid	fgHCBRIhwoy5PLRt;

1.105
date	2017.01.06.14.01.19;	author rzalamena;	state Exp;
branches;
next	1.104;
commitid	HqvJlf6KKxwDeViP;

1.104
date	2017.01.06.13.48.58;	author rzalamena;	state Exp;
branches;
next	1.103;
commitid	XMNY3Ire0T2WWOW0;

1.103
date	2017.01.06.10.02.57;	author mpi;	state Exp;
branches;
next	1.102;
commitid	pyTY0DbP5hokbnVn;

1.102
date	2017.01.05.12.10.54;	author rzalamena;	state Exp;
branches;
next	1.101;
commitid	d5sgG8KaZ7col52H;

1.101
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.100;
commitid	T2qzeepA7r1EGy1x;

1.100
date	2016.12.21.12.05.01;	author mpi;	state Exp;
branches;
next	1.99;
commitid	j0NqhC4pmg38gSbq;

1.99
date	2016.12.21.09.52.29;	author rzalamena;	state Exp;
branches;
next	1.98;
commitid	kDKikIpbsl2mY25g;

1.98
date	2016.12.20.10.54.52;	author rzalamena;	state Exp;
branches;
next	1.97;
commitid	gWiJUIeXI3TqyHNj;

1.97
date	2016.12.20.09.33.13;	author rzalamena;	state Exp;
branches;
next	1.96;
commitid	Kl2kqz5LA3XMNf1c;

1.96
date	2016.12.19.12.52.41;	author rzalamena;	state Exp;
branches;
next	1.95;
commitid	7gIwStnOidAWH0dG;

1.95
date	2016.12.19.09.22.24;	author rzalamena;	state Exp;
branches;
next	1.94;
commitid	5iifwOyfMyS6GiDF;

1.94
date	2016.12.13.09.22.18;	author rzalamena;	state Exp;
branches;
next	1.93;
commitid	nqmWuIFdiiygHejo;

1.93
date	2016.11.29.15.52.12;	author mpi;	state Exp;
branches;
next	1.92;
commitid	uz4Tr6mhWo8vJLF8;

1.92
date	2016.11.29.10.22.30;	author jsg;	state Exp;
branches;
next	1.91;
commitid	ZQetSMB5ilG2z10X;

1.91
date	2016.09.24.18.39.48;	author tedu;	state Exp;
branches;
next	1.90;
commitid	JgnxIn9Y9AcOVDyD;

1.90
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.89;
commitid	Z6e4eqr6FuYFPnlL;

1.89
date	2015.11.14.15.54.27;	author mpi;	state Exp;
branches;
next	1.88;
commitid	bFsXS2FgnMXCb5Pq;

1.88
date	2015.11.13.10.33.12;	author mpi;	state Exp;
branches;
next	1.87;
commitid	ikwDIrM8JnCJkuMQ;

1.87
date	2015.11.13.10.25.48;	author mpi;	state Exp;
branches;
next	1.86;
commitid	oF3pO4LgBlPuEjLK;

1.86
date	2015.11.12.18.19.27;	author mpi;	state Exp;
branches;
next	1.85;
commitid	E4zgHXY9yswnBsUw;

1.85
date	2015.11.12.16.58.45;	author mpi;	state Exp;
branches;
next	1.84;
commitid	uUnwnfhXZRPy2XRQ;

1.84
date	2015.11.12.16.48.53;	author mpi;	state Exp;
branches;
next	1.83;
commitid	5nc7uiBXooxI6m7w;

1.83
date	2015.11.12.16.34.13;	author mpi;	state Exp;
branches;
next	1.82;
commitid	qYqqFcQSli7CnKx0;

1.82
date	2015.09.12.13.34.12;	author mpi;	state Exp;
branches;
next	1.81;
commitid	LU3jSOpFfLxcllFL;

1.81
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.80;
commitid	RRi5waWu1LaKRicG;

1.80
date	2015.08.24.14.00.29;	author bluhm;	state Exp;
branches;
next	1.79;
commitid	0LcoZC9QTu9wgpyX;

1.79
date	2015.07.15.17.55.08;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	KXrLJI5iavuvN5Xs;

1.78
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.77;
commitid	J4OPNuggl4DOKGzM;

1.77
date	2015.02.09.12.18.19;	author claudio;	state Exp;
branches;
next	1.76;
commitid	8K5RNpON80OVB59T;

1.76
date	2015.02.08.03.42.24;	author claudio;	state Exp;
branches;
next	1.75;
commitid	YBFZimwbSOVtCGSa;

1.75
date	2015.02.07.07.56.41;	author dlg;	state Exp;
branches;
next	1.74;
commitid	L24imW4bZDeDw8wK;

1.74
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.73;
commitid	cYQY7jiay4SydLhD;

1.73
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.72;
commitid	Vq8oSnWLkf7dyy0N;

1.72
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.71;
commitid	t9FBKDfc4VDxpEy2;

1.71
date	2014.09.30.12.54.22;	author jsg;	state Exp;
branches;
next	1.70;
commitid	vQlqJfGOkdklOu0t;

1.70
date	2014.08.14.09.01.47;	author mpi;	state Exp;
branches;
next	1.69;
commitid	xAyitDa7xkItKbjR;

1.69
date	2014.08.14.08.22.38;	author mpi;	state Exp;
branches;
next	1.68;
commitid	vlb8w9hmS6iNy3Wt;

1.68
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.67;
commitid	DQakU8LLWV6Iwx84;

1.67
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.66;
commitid	B4dZSbxas1X1IpXI;

1.66
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.09.06.29.06;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2013.10.27.20.57.39;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.61;

1.61
date	2013.05.02.11.54.10;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2011.04.04.17.44.43;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.57;

1.57
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2009.08.01.09.08.21;	author blambert;	state Exp;
branches;
next	1.55;

1.55
date	2009.07.13.19.14.29;	author michele;	state Exp;
branches;
next	1.54;

1.54
date	2009.07.09.13.04.29;	author michele;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.16.21.33.37;	author chl;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.15.21.46.01;	author chl;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.02.03.33.18;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.22.09.51.13;	author michele;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.15.10.11.27;	author pascoe;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.11.20.12.50;	author hshoexer;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.25.15.49.35;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.15.04.43.40;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.14.15.09.42;	author mcbride;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.14.14.51.27;	author mcbride;	state Exp;
branches;
next	1.38;

1.38
date	2004.11.24.01.25.42;	author mcbride;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.24.20.31.16;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.06.17.28.32;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.09.03.23.26;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.14.20.35.06;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.06.07.28.39;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.31.04.05.57;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.26.17.37.52;	author deraadt;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.23.16.15.56;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.10.15.33.10;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.21.03.15.05;	author angelos;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	99.08.08.15.04.22;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.04.28.09.28.16;	author art;	state Exp;
branches;
next	1.15;

1.15
date	99.04.20.20.06.12;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.02.05.04.23.43;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	99.01.08.21.51.22;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	99.01.08.01.04.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.12.26.12.35.11;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	98.07.29.22.18.50;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	98.07.03.07.05.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.05.18.21.11.00;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.09.28.23.09.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.21.09.17.33;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	97.02.20.01.08.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.31.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.29.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.22.30.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches;
next	;

1.19.2.1
date	2001.05.14.22.40.12;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.07.04.10.54.53;	author niklas;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.19.2.7;

1.19.2.7
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.19.2.8;

1.19.2.8
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.19.2.9;

1.19.2.9
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	;

1.23.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.23.4.3;

1.23.4.3
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.112
log
@Be more strict on all route iterations, lets always make sure that we
are not going to get a unicast route by accident.

ok mpi@@
@
text
@/*	$OpenBSD: ip_mroute.c,v 1.111 2017/03/14 10:27:10 rzalamena Exp $	*/
/*	$NetBSD: ip_mroute.c,v 1.85 2004/04/26 01:31:57 matt Exp $	*/

/*
 * Copyright (c) 1989 Stephen Deering
 * Copyright (c) 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)ip_mroute.c 8.2 (Berkeley) 11/15/93
 */

/*
 * IP multicast forwarding procedures
 *
 * Written by David Waitzman, BBN Labs, August 1988.
 * Modified by Steve Deering, Stanford, February 1989.
 * Modified by Mark J. Steiglitz, Stanford, May, 1991
 * Modified by Van Jacobson, LBL, January 1993
 * Modified by Ajit Thyagarajan, PARC, August 1993
 * Modified by Bill Fenner, PARC, April 1994
 * Modified by Charles M. Hannum, NetBSD, May 1995.
 * Modified by Ahmed Helmy, SGI, June 1996
 * Modified by George Edmond Eddy (Rusty), ISI, February 1998
 * Modified by Pavlin Radoslavov, USC/ISI, May 1998, August 1999, October 2000
 * Modified by Hitoshi Asaeda, WIDE, August 2000
 * Modified by Pavlin Radoslavov, ICSI, October 2002
 *
 * MROUTING Revision: 1.2
 * advanced API support, bandwidth metering and signaling
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/in_pcb.h>
#include <netinet/igmp.h>
#include <netinet/ip_mroute.h>

/* #define MCAST_DEBUG */

#ifdef MCAST_DEBUG
#define DPRINTF(fmt, args...)						\
	do {								\
		printf("%s:%d " fmt "\n", __func__, __LINE__, ## args);	\
	} while (0)
#else
#define DPRINTF(fmt, args...)			\
	do { } while (0)
#endif

/*
 * Globals.  All but ip_mrouter and ip_mrtproto could be static,
 * except for netstat or debugging purposes.
 */
struct socket	*ip_mrouter[RT_TABLEID_MAX];
struct rttimer_queue *mrouterq[RT_TABLEID_MAX];
uint64_t	 mrt_count[RT_TABLEID_MAX];
int		ip_mrtproto = IGMP_DVMRP;    /* for netstat only */

struct mrtstat	mrtstat;

struct rtentry	*mfc_find(struct ifnet *, struct in_addr *,
    struct in_addr *, unsigned int);
int get_sg_cnt(unsigned int, struct sioc_sg_req *);
int get_vif_cnt(unsigned int, struct sioc_vif_req *);
int mrt_rtwalk_mfcsysctl(struct rtentry *, void *, unsigned int);
int ip_mrouter_init(struct socket *, struct mbuf *);
int mrouter_rtwalk_delete(struct rtentry *, void *, unsigned int);
int get_version(struct mbuf *);
int add_vif(struct socket *, struct mbuf *);
int del_vif(struct socket *, struct mbuf *);
void update_mfc_params(struct mfcctl2 *, unsigned int);
void mfc_expire_route(struct rtentry *, struct rttimer *);
int mfc_add(struct mfcctl2 *, struct in_addr *, struct in_addr *,
    int, unsigned int);
int add_mfc(struct socket *, struct mbuf *);
int del_mfc(struct socket *, struct mbuf *);
int set_api_config(struct socket *, struct mbuf *); /* chose API capabilities */
int get_api_support(struct mbuf *);
int get_api_config(struct mbuf *);
int socket_send(struct socket *, struct mbuf *,
			    struct sockaddr_in *);
int ip_mdq(struct mbuf *, struct ifnet *, struct rtentry *);
struct ifnet *if_lookupbyvif(vifi_t, unsigned int);
struct rtentry *rt_mcast_add(struct ifnet *, struct sockaddr *,
    struct sockaddr *);
int rt_mcast_del(struct rtentry *, unsigned int);

/*
 * Kernel multicast routing API capabilities and setup.
 * If more API capabilities are added to the kernel, they should be
 * recorded in `mrt_api_support'.
 */
static const u_int32_t mrt_api_support = (MRT_MFC_FLAGS_DISABLE_WRONGVIF |
					  MRT_MFC_RP);
static u_int32_t mrt_api_config = 0;

/*
 * Find a route for a given origin IP address and Multicast group address
 * Type of service parameter to be added in the future!!!
 * Statistics are updated by the caller if needed
 * (mrtstat.mrts_mfc_lookups and mrtstat.mrts_mfc_misses)
 */
struct rtentry *
mfc_find(struct ifnet *ifp, struct in_addr *origin, struct in_addr *group,
    unsigned int rtableid)
{
	struct rtentry		*rt;
	struct sockaddr_in	 msin;

	memset(&msin, 0, sizeof(msin));
	msin.sin_len = sizeof(msin);
	msin.sin_family = AF_INET;
	msin.sin_addr = *group;

	rt = rtalloc(sintosa(&msin), 0, rtableid);
	if (rt == NULL)
		return (NULL);

	do {
		/* Don't consider non multicast routes. */
		if (ISSET(rt->rt_flags, RTF_HOST | RTF_MULTICAST) !=
		    (RTF_HOST | RTF_MULTICAST))
			continue;
		/* Return first occurrence if interface is not specified. */
		if (ifp == NULL)
			return (rt);
		if (rt->rt_ifidx == ifp->if_index)
			return (rt);
	} while ((rt = rtable_iterate(rt)) != NULL);

	return (NULL);
}

/*
 * Handle MRT setsockopt commands to modify the multicast routing tables.
 */
int
ip_mrouter_set(struct socket *so, int optname, struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	int error;

	if (optname != MRT_INIT &&
	    so != ip_mrouter[inp->inp_rtableid])
		error = ENOPROTOOPT;
	else
		switch (optname) {
		case MRT_INIT:
			error = ip_mrouter_init(so, m);
			break;
		case MRT_DONE:
			error = ip_mrouter_done(so);
			break;
		case MRT_ADD_VIF:
			error = add_vif(so, m);
			break;
		case MRT_DEL_VIF:
			error = del_vif(so, m);
			break;
		case MRT_ADD_MFC:
			error = add_mfc(so, m);
			break;
		case MRT_DEL_MFC:
			error = del_mfc(so, m);
			break;
		case MRT_API_CONFIG:
			error = set_api_config(so, m);
			break;
		default:
			error = ENOPROTOOPT;
			break;
		}

	m_free(m);
	return (error);
}

/*
 * Handle MRT getsockopt commands
 */
int
ip_mrouter_get(struct socket *so, int optname, struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	int error;

	if (so != ip_mrouter[inp->inp_rtableid])
		error = ENOPROTOOPT;
	else {
		switch (optname) {
		case MRT_VERSION:
			error = get_version(m);
			break;
		case MRT_API_SUPPORT:
			error = get_api_support(m);
			break;
		case MRT_API_CONFIG:
			error = get_api_config(m);
			break;
		default:
			error = ENOPROTOOPT;
			break;
		}
	}

	return (error);
}

/*
 * Handle ioctl commands to obtain information from the cache
 */
int
mrt_ioctl(struct socket *so, u_long cmd, caddr_t data)
{
	struct inpcb *inp = sotoinpcb(so);
	int error;

	if (so != ip_mrouter[inp->inp_rtableid])
		error = EINVAL;
	else
		switch (cmd) {
		case SIOCGETVIFCNT:
			error = get_vif_cnt(inp->inp_rtableid,
			    (struct sioc_vif_req *)data);
			break;
		case SIOCGETSGCNT:
			error = get_sg_cnt(inp->inp_rtableid,
			    (struct sioc_sg_req *)data);
			break;
		default:
			error = ENOTTY;
			break;
		}

	return (error);
}

/*
 * returns the packet, byte, rpf-failure count for the source group provided
 */
int
get_sg_cnt(unsigned int rtableid, struct sioc_sg_req *req)
{
	struct rtentry *rt;
	struct mfc *mfc;

	rt = mfc_find(NULL, &req->src, &req->grp, rtableid);
	if (rt == NULL) {
		req->pktcnt = req->bytecnt = req->wrong_if = 0xffffffff;
		return (EADDRNOTAVAIL);
	}

	req->pktcnt = req->bytecnt = req->wrong_if = 0;
	do {
		/* Don't consider non multicast routes. */
		if (ISSET(rt->rt_flags, RTF_HOST | RTF_MULTICAST) !=
		    (RTF_HOST | RTF_MULTICAST))
			continue;

		mfc = (struct mfc *)rt->rt_llinfo;
		req->pktcnt += mfc->mfc_pkt_cnt;
		req->bytecnt += mfc->mfc_byte_cnt;
		req->wrong_if += mfc->mfc_wrong_if;
	} while ((rt = rtable_iterate(rt)) != NULL);

	return (0);
}

/*
 * returns the input and output packet and byte counts on the vif provided
 */
int
get_vif_cnt(unsigned int rtableid, struct sioc_vif_req *req)
{
	struct ifnet	*ifp;
	struct vif	*v;
	vifi_t		 vifi = req->vifi;

	if ((ifp = if_lookupbyvif(vifi, rtableid)) == NULL)
		return (EINVAL);

	v = (struct vif *)ifp->if_mcast;
	req->icount = v->v_pkt_in;
	req->ocount = v->v_pkt_out;
	req->ibytes = v->v_bytes_in;
	req->obytes = v->v_bytes_out;

	return (0);
}

int
mrt_sysctl_vif(void *oldp, size_t *oldlenp)
{
	caddr_t where = oldp;
	size_t needed, given;
	struct ifnet *ifp;
	struct vif *vifp;
	struct vifinfo vinfo;

	given = *oldlenp;
	needed = 0;
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if ((vifp = (struct vif *)ifp->if_mcast) == NULL)
			continue;

		vinfo.v_vifi = vifp->v_id;
		vinfo.v_flags = vifp->v_flags;
		vinfo.v_threshold = vifp->v_threshold;
		vinfo.v_lcl_addr = vifp->v_lcl_addr;
		vinfo.v_rmt_addr = vifp->v_rmt_addr;
		vinfo.v_pkt_in = vifp->v_pkt_in;
		vinfo.v_pkt_out = vifp->v_pkt_out;
		vinfo.v_bytes_in = vifp->v_bytes_in;
		vinfo.v_bytes_out = vifp->v_bytes_out;

		needed += sizeof(vinfo);
		if (where && needed <= given) {
			int error;

			error = copyout(&vinfo, where, sizeof(vinfo));
			if (error)
				return (error);
			where += sizeof(vinfo);
		}
	}
	if (where) {
		*oldlenp = needed;
		if (given < needed)
			return (ENOMEM);
	} else
		*oldlenp = (11 * needed) / 10;

	return (0);
}

struct mfcsysctlarg {
	struct mfcinfo	*msa_minfos;
	size_t		 msa_len;
	size_t		 msa_needed;
};

int
mrt_rtwalk_mfcsysctl(struct rtentry *rt, void *arg, unsigned int rtableid)
{
	struct mfc		*mfc = (struct mfc *)rt->rt_llinfo;
	struct mfcsysctlarg	*msa = (struct mfcsysctlarg *)arg;
	struct ifnet		*ifp;
	struct vif		*v;
	struct mfcinfo		*minfo;
	int			 new = 0;

	/* Skip non-multicast routes. */
	if (ISSET(rt->rt_flags, RTF_HOST | RTF_MULTICAST) !=
	    (RTF_HOST | RTF_MULTICAST))
		return (0);

	/* User just asked for the output size. */
	if (msa->msa_minfos == NULL) {
		msa->msa_needed += sizeof(*minfo);
		return (0);
	}

	/* Skip route with invalid interfaces. */
	if ((ifp = if_get(rt->rt_ifidx)) == NULL)
		return (0);
	if ((v = (struct vif *)ifp->if_mcast) == NULL) {
		if_put(ifp);
		return (0);
	}

	for (minfo = msa->msa_minfos;
	     (uint8_t *)minfo < ((uint8_t *)msa->msa_minfos + msa->msa_len);
	     minfo++) {
		/* Find a new entry or update old entry. */
		if (minfo->mfc_origin.s_addr !=
		    satosin(rt->rt_gateway)->sin_addr.s_addr ||
		    minfo->mfc_mcastgrp.s_addr !=
		    satosin(rt_key(rt))->sin_addr.s_addr) {
			if (minfo->mfc_origin.s_addr != 0 ||
			    minfo->mfc_mcastgrp.s_addr != 0)
				continue;

			new = 1;
		}

		minfo->mfc_origin = satosin(rt->rt_gateway)->sin_addr;
		minfo->mfc_mcastgrp = satosin(rt_key(rt))->sin_addr;
		minfo->mfc_parent = mfc->mfc_parent;
		minfo->mfc_pkt_cnt += mfc->mfc_pkt_cnt;
		minfo->mfc_byte_cnt += mfc->mfc_byte_cnt;
		minfo->mfc_ttls[v->v_id] = mfc->mfc_ttl;
		break;
	}

	if (new != 0)
		msa->msa_needed += sizeof(*minfo);

	if_put(ifp);

	return (0);
}

int
mrt_sysctl_mfc(void *oldp, size_t *oldlenp)
{
	unsigned int		 rtableid;
	int			 error;
	struct mfcsysctlarg	 msa;

	if (oldp != NULL && *oldlenp > MAXPHYS)
		return (EINVAL);

	if (oldp != NULL)
		msa.msa_minfos = malloc(*oldlenp, M_TEMP, M_WAITOK | M_ZERO);
	else
		msa.msa_minfos = NULL;

	msa.msa_len = *oldlenp;
	msa.msa_needed = 0;

	for (rtableid = 0; rtableid < RT_TABLEID_MAX; rtableid++)
		rtable_walk(rtableid, AF_INET, mrt_rtwalk_mfcsysctl, &msa);

	if (msa.msa_minfos != NULL && msa.msa_needed > 0 &&
	    (error = copyout(msa.msa_minfos, oldp, msa.msa_needed)) != 0)
		return (error);

	free(msa.msa_minfos, M_TEMP, *oldlenp);
	*oldlenp = msa.msa_needed;

	return (0);
}

/*
 * Enable multicast routing
 */
int
ip_mrouter_init(struct socket *so, struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	unsigned int rtableid = inp->inp_rtableid;
	int *v;

	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_IGMP)
		return (EOPNOTSUPP);

	if (m == NULL || m->m_len < sizeof(int))
		return (EINVAL);

	v = mtod(m, int *);
	if (*v != 1)
		return (EINVAL);

	if (ip_mrouter[rtableid] != NULL ||
	    mrouterq[rtableid] != NULL)
		return (EADDRINUSE);

	ip_mrouter[rtableid] = so;
	mrouterq[rtableid] = rt_timer_queue_create(MCAST_EXPIRE_FREQUENCY);

	return (0);
}

int
mrouter_rtwalk_delete(struct rtentry *rt, void *arg, unsigned int rtableid)
{
	/* Skip non-multicast routes. */
	if (ISSET(rt->rt_flags, RTF_HOST | RTF_MULTICAST) !=
	    (RTF_HOST | RTF_MULTICAST))
		return (0);

	/* Remove all timers related to this route. */
	rt_timer_remove_all(rt);
	return (rt_mcast_del(rt, rtableid));
}

/*
 * Disable multicast routing
 */
int
ip_mrouter_done(struct socket *so)
{
	struct inpcb *inp = sotoinpcb(so);
	struct ifnet *ifp;
	unsigned int rtableid = inp->inp_rtableid;

	splsoftassert(IPL_SOFTNET);

	/* Delete all remaining installed multicast routes. */
	rtable_walk(rtableid, AF_INET, mrouter_rtwalk_delete, NULL);

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rtableid)
			continue;

		vif_delete(ifp);
	}

	mrt_api_config = 0;

	rt_timer_queue_destroy(mrouterq[rtableid]);
	mrouterq[rtableid] = NULL;
	ip_mrouter[rtableid] = NULL;
	mrt_count[rtableid] = 0;

	return (0);
}

int
get_version(struct mbuf *m)
{
	int *v = mtod(m, int *);

	*v = 0x0305;	/* XXX !!!! */
	m->m_len = sizeof(int);
	return (0);
}

/*
 * Configure API capabilities
 */
int
set_api_config(struct socket *so, struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	struct ifnet *ifp;
	u_int32_t *apival;
	unsigned int rtableid = inp->inp_rtableid;

	if (m == NULL || m->m_len < sizeof(u_int32_t))
		return (EINVAL);

	apival = mtod(m, u_int32_t *);

	/*
	 * We can set the API capabilities only if it is the first operation
	 * after MRT_INIT. I.e.:
	 *  - there are no vifs installed
	 *  - the MFC table is empty
	 */
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rtableid)
			continue;
		if (ifp->if_mcast == NULL)
			continue;

		*apival = 0;
		return (EPERM);
	}
	if (mrt_count[rtableid] > 0) {
		*apival = 0;
		return (EPERM);
	}

	mrt_api_config = *apival & mrt_api_support;
	*apival = mrt_api_config;

	return (0);
}

/*
 * Get API capabilities
 */
int
get_api_support(struct mbuf *m)
{
	u_int32_t *apival;

	if (m == NULL || m->m_len < sizeof(u_int32_t))
		return (EINVAL);

	apival = mtod(m, u_int32_t *);

	*apival = mrt_api_support;

	return (0);
}

/*
 * Get API configured capabilities
 */
int
get_api_config(struct mbuf *m)
{
	u_int32_t *apival;

	if (m == NULL || m->m_len < sizeof(u_int32_t))
		return (EINVAL);

	apival = mtod(m, u_int32_t *);

	*apival = mrt_api_config;

	return (0);
}

static struct sockaddr_in sin = { sizeof(sin), AF_INET };

int
add_vif(struct socket *so, struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	struct vifctl *vifcp;
	struct vif *vifp;
	struct ifaddr *ifa;
	struct ifnet *ifp;
	struct ifreq ifr;
	int error;
	unsigned int rtableid = inp->inp_rtableid;

	splsoftassert(IPL_SOFTNET);

	if (m == NULL || m->m_len < sizeof(struct vifctl))
		return (EINVAL);

	vifcp = mtod(m, struct vifctl *);
	if (vifcp->vifc_vifi >= MAXVIFS)
		return (EINVAL);
	if (in_nullhost(vifcp->vifc_lcl_addr))
		return (EADDRNOTAVAIL);
	if (if_lookupbyvif(vifcp->vifc_vifi, rtableid) != NULL)
		return (EADDRINUSE);

	/* Tunnels are no longer supported use gif(4) instead. */
	if (vifcp->vifc_flags & VIFF_TUNNEL)
		return (EOPNOTSUPP);
	{
		sin.sin_addr = vifcp->vifc_lcl_addr;
		ifa = ifa_ifwithaddr(sintosa(&sin), rtableid);
		if (ifa == NULL)
			return (EADDRNOTAVAIL);
	}

	/* Use the physical interface associated with the address. */
	ifp = ifa->ifa_ifp;
	if (ifp->if_mcast != NULL)
		return (EADDRINUSE);

	{
		/* Make sure the interface supports multicast. */
		if ((ifp->if_flags & IFF_MULTICAST) == 0)
			return (EOPNOTSUPP);

		/* Enable promiscuous reception of all IP multicasts. */
		memset(&ifr, 0, sizeof(ifr));
		satosin(&ifr.ifr_addr)->sin_len = sizeof(struct sockaddr_in);
		satosin(&ifr.ifr_addr)->sin_family = AF_INET;
		satosin(&ifr.ifr_addr)->sin_addr = zeroin_addr;
		error = (*ifp->if_ioctl)(ifp, SIOCADDMULTI, (caddr_t)&ifr);
		if (error)
			return (error);
	}

	vifp = malloc(sizeof(*vifp), M_MRTABLE, M_WAITOK | M_ZERO);
	ifp->if_mcast = (caddr_t)vifp;

	vifp->v_id = vifcp->vifc_vifi;
	vifp->v_flags = vifcp->vifc_flags;
	vifp->v_threshold = vifcp->vifc_threshold;
	vifp->v_lcl_addr = vifcp->vifc_lcl_addr;
	vifp->v_rmt_addr = vifcp->vifc_rmt_addr;

	return (0);
}

int
del_vif(struct socket *so, struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	struct ifnet *ifp;
	vifi_t *vifip;
	unsigned int rtableid = inp->inp_rtableid;

	splsoftassert(IPL_SOFTNET);

	if (m == NULL || m->m_len < sizeof(vifi_t))
		return (EINVAL);

	vifip = mtod(m, vifi_t *);
	if ((ifp = if_lookupbyvif(*vifip, rtableid)) == NULL)
		return (EADDRNOTAVAIL);

	vif_delete(ifp);
	return (0);
}

void
vif_delete(struct ifnet *ifp)
{
	struct vif	*v;
	struct ifreq	 ifr;

	if ((v = (struct vif *)ifp->if_mcast) == NULL)
		return;

	ifp->if_mcast = NULL;

	memset(&ifr, 0, sizeof(ifr));
	satosin(&ifr.ifr_addr)->sin_len = sizeof(struct sockaddr_in);
	satosin(&ifr.ifr_addr)->sin_family = AF_INET;
	satosin(&ifr.ifr_addr)->sin_addr = zeroin_addr;
	(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)&ifr);

	free(v, M_MRTABLE, sizeof(*v));
}

void
mfc_expire_route(struct rtentry *rt, struct rttimer *rtt)
{
	struct mfc	*mfc = (struct mfc *)rt->rt_llinfo;
	unsigned int	 rtableid = rtt->rtt_tableid;

	DPRINTF("Route domain %d origin %#08X group %#08x interface %d "
	    "expire %s", rtt->rtt_tableid,
	    satosin(rt->rt_gateway)->sin_addr.s_addr,
	    satosin(rt_key(rt))->sin_addr.s_addr,
	    rt->rt_ifidx, mfc->mfc_expire ? "yes" : "no");

	/* Not expired, add it back to the queue. */
	if (mfc->mfc_expire == 0) {
		mfc->mfc_expire = 1;
		rt_timer_add(rt, mfc_expire_route, mrouterq[rtableid],
		    rtableid);
		return;
	}

	/* Remove all timers related to this route. */
	rt_timer_remove_all(rt);
	rt_mcast_del(rt, rtableid);
}

int
mfc_add_route(struct ifnet *ifp, struct sockaddr *origin,
    struct sockaddr *group, struct mfcctl2 *mfccp)
{
	struct vif		*v = (struct vif *)ifp->if_mcast;
	struct rtentry		*rt;
	struct mfc		*mfc;
	unsigned int		 rtableid = ifp->if_rdomain;

	rt = rt_mcast_add(ifp, origin, group);
	if (rt == NULL)
		return (-1);

	mfc = malloc(sizeof(*mfc), M_MRTABLE, M_NOWAIT | M_ZERO);
	if (mfc == NULL) {
		DPRINTF("origin %#08X group %#08X parent %d (%s) "
		    "malloc failed",
		    satosin(origin)->sin_addr.s_addr,
		    satosin(group)->sin_addr.s_addr,
		    mfccp->mfcc_parent, ifp->if_xname);
		rt_mcast_del(rt, rtableid);
		rtfree(rt);
		return (-1);
	}

	rt->rt_llinfo = (caddr_t)mfc;

	rt_timer_add(rt, mfc_expire_route, mrouterq[rtableid],
	    rtableid);

	mfc->mfc_parent = mfccp->mfcc_parent;
	mfc->mfc_pkt_cnt = 0;
	mfc->mfc_byte_cnt = 0;
	mfc->mfc_wrong_if = 0;
	mfc->mfc_ttl = mfccp->mfcc_ttls[v->v_id];
	mfc->mfc_flags = mfccp->mfcc_flags[v->v_id] & mrt_api_config &
	    MRT_MFC_FLAGS_ALL;
	mfc->mfc_expire = 0;

	/* set the RP address */
	if (mrt_api_config & MRT_MFC_RP)
		mfc->mfc_rp = mfccp->mfcc_rp;
	else
		mfc->mfc_rp = zeroin_addr;

	return (0);
}

void
update_mfc_params(struct mfcctl2 *mfccp, unsigned int rtableid)
{
	struct rtentry		*rt;
	struct mfc		*mfc;
	struct ifnet		*ifp;
	int			 i;
	struct sockaddr_in	 osin, msin;

	memset(&osin, 0, sizeof(osin));
	osin.sin_len = sizeof(osin);
	osin.sin_family = AF_INET;
	osin.sin_addr = mfccp->mfcc_origin;

	memset(&msin, 0, sizeof(msin));
	msin.sin_len = sizeof(msin);
	msin.sin_family = AF_INET;
	msin.sin_addr = mfccp->mfcc_mcastgrp;

	for (i = 0; i < MAXVIFS; i++) {
		/* Don't add/del upstream routes here. */
		if (i == mfccp->mfcc_parent)
			continue;

		/* Test for vif existence and then update the entry. */
		if ((ifp = if_lookupbyvif(i, rtableid)) == NULL)
			continue;

		rt = mfc_find(ifp, &mfccp->mfcc_origin,
		    &mfccp->mfcc_mcastgrp, rtableid);

		/* vif not configured or removed. */
		if (mfccp->mfcc_ttls[i] == 0) {
			/* Route doesn't exist, nothing to do. */
			if (rt == NULL)
				continue;

			DPRINTF("del route (group %#08X) for vif %d (%s)",
			    mfccp->mfcc_mcastgrp.s_addr, i, ifp->if_xname);
			rt_timer_remove_all(rt);
			rt_mcast_del(rt, rtableid);
			continue;
		}

		/* Route exists, look for changes. */
		if (rt != NULL) {
			mfc = (struct mfc *)rt->rt_llinfo;
			/* No new changes to apply. */
			if (mfccp->mfcc_ttls[i] == mfc->mfc_ttl &&
			    mfccp->mfcc_parent == mfc->mfc_parent)
				continue;

			DPRINTF("update route (group %#08X) for vif %d (%s)",
			    mfccp->mfcc_mcastgrp.s_addr, i, ifp->if_xname);
			mfc->mfc_ttl = mfccp->mfcc_ttls[i];
			mfc->mfc_parent = mfccp->mfcc_parent;
			continue;
		}

		DPRINTF("add route (group %#08X) for vif %d (%s)",
		    mfccp->mfcc_mcastgrp.s_addr, i, ifp->if_xname);

		mfc_add_route(ifp, sintosa(&osin), sintosa(&msin), mfccp);
	}

	/* Create route for the parent interface. */
	if ((ifp = if_lookupbyvif(mfccp->mfcc_parent, rtableid)) == NULL) {
		DPRINTF("failed to find upstream interface %d",
		    mfccp->mfcc_parent);
		return;
	}

	/* We already have a route, nothing to do here. */
	if (mfc_find(ifp, &mfccp->mfcc_origin,
	    &mfccp->mfcc_mcastgrp, rtableid) != NULL)
		return;

	DPRINTF("add upstream route (group %#08X) for if %s",
	    mfccp->mfcc_mcastgrp.s_addr, ifp->if_xname);
	mfc_add_route(ifp, sintosa(&osin), sintosa(&msin), mfccp);
}

int
mfc_add(struct mfcctl2 *mfcctl2, struct in_addr *origin,
    struct in_addr *group, int vidx, unsigned int rtableid)
{
	struct ifnet		*ifp;
	struct vif		*v;
	struct mfcctl2		 mfcctl;

	ifp = if_lookupbyvif(vidx, rtableid);
	if (ifp == NULL ||
	    (v = (struct vif *)ifp->if_mcast) == NULL) {
		DPRINTF("origin %#08X group %#08X parent %d vif doesn't exist",
		    origin->s_addr, group->s_addr, vidx);
		return (-1);
	}

	memset(&mfcctl, 0, sizeof(mfcctl));
	if (mfcctl2 == NULL) {
		mfcctl.mfcc_origin = *origin;
		mfcctl.mfcc_mcastgrp = *group;
		mfcctl.mfcc_parent = vidx;
	} else
		memcpy(&mfcctl, mfcctl2, sizeof(mfcctl));

	update_mfc_params(&mfcctl, rtableid);

	return (0);
}

int
add_mfc(struct socket *so, struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	struct mfcctl2 mfcctl2;
	int mfcctl_size = sizeof(struct mfcctl);
	unsigned int rtableid = inp->inp_rtableid;

	splsoftassert(IPL_SOFTNET);

	if (mrt_api_config & MRT_API_FLAGS_ALL)
		mfcctl_size = sizeof(struct mfcctl2);

	if (m == NULL || m->m_len < mfcctl_size)
		return (EINVAL);

	/*
	 * select data size depending on API version.
	 */
	if (mrt_api_config & MRT_API_FLAGS_ALL) {
		struct mfcctl2 *mp2 = mtod(m, struct mfcctl2 *);
		bcopy(mp2, (caddr_t)&mfcctl2, sizeof(*mp2));
	} else {
		struct mfcctl *mp = mtod(m, struct mfcctl *);
		bcopy(mp, (caddr_t)&mfcctl2, sizeof(*mp));
		memset((caddr_t)&mfcctl2 + sizeof(struct mfcctl), 0,
		    sizeof(mfcctl2) - sizeof(struct mfcctl));
	}

	if (mfc_add(&mfcctl2, &mfcctl2.mfcc_origin, &mfcctl2.mfcc_mcastgrp,
	    mfcctl2.mfcc_parent, rtableid) == -1)
		return (EINVAL);

	return (0);
}

int
del_mfc(struct socket *so, struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	struct rtentry *rt;
	struct mfcctl2 mfcctl2;
	int mfcctl_size = sizeof(struct mfcctl);
	struct mfcctl *mp;
	unsigned int rtableid = inp->inp_rtableid;

	splsoftassert(IPL_SOFTNET);

	/*
	 * XXX: for deleting MFC entries the information in entries
	 * of size "struct mfcctl" is sufficient.
	 */

	if (m == NULL || m->m_len < mfcctl_size)
		return (EINVAL);

	mp = mtod(m, struct mfcctl *);

	bcopy(mp, (caddr_t)&mfcctl2, sizeof(*mp));
	memset((caddr_t)&mfcctl2 + sizeof(struct mfcctl), 0,
	    sizeof(mfcctl2) - sizeof(struct mfcctl));

	DPRINTF("origin %#08X group %#08X rtableid %d",
	    mfcctl2.mfcc_origin.s_addr, mfcctl2.mfcc_mcastgrp.s_addr, rtableid);

	while ((rt = mfc_find(NULL, &mfcctl2.mfcc_origin,
	    &mfcctl2.mfcc_mcastgrp, rtableid)) != NULL) {
		/* Remove all timers related to this route. */
		rt_timer_remove_all(rt);
		rt_mcast_del(rt, rtableid);
	}

	return (0);
}

int
socket_send(struct socket *s, struct mbuf *mm, struct sockaddr_in *src)
{
	if (s != NULL) {
		if (sbappendaddr(&s->so_rcv, sintosa(src), mm, NULL) != 0) {
			sorwakeup(s);
			return (0);
		}
	}
	m_freem(mm);
	return (-1);
}

/*
 * IP multicast forwarding function. This function assumes that the packet
 * pointed to by "ip" has arrived on (or is about to be sent to) the interface
 * pointed to by "ifp", and the packet is to be relayed to other networks
 * that have members of the packet's destination IP multicast group.
 *
 * The packet is returned unscathed to the caller, unless it is
 * erroneous, in which case a non-zero return value tells the caller to
 * discard it.
 */

#define IP_HDR_LEN  20	/* # bytes of fixed IP header (excluding options) */
#define TUNNEL_LEN  12  /* # bytes of IP option for tunnel encapsulation  */

int
ip_mforward(struct mbuf *m, struct ifnet *ifp)
{
	struct ip *ip = mtod(m, struct ip *);
	struct vif *v;
	struct rtentry *rt;
	static int srctun = 0;
	struct mbuf *mm;
	unsigned int rtableid = ifp->if_rdomain;

	if (ip->ip_hl < (IP_HDR_LEN + TUNNEL_LEN) >> 2 ||
	    ((u_char *)(ip + 1))[1] != IPOPT_LSRR) {
		/*
		 * Packet arrived via a physical interface or
		 * an encapsulated tunnel or a register_vif.
		 */
	} else {
		/*
		 * Packet arrived through a source-route tunnel.
		 * Source-route tunnels are no longer supported.
		 */
		if ((srctun++ % 1000) == 0)
			log(LOG_ERR, "ip_mforward: received source-routed "
			    "packet from %x\n", ntohl(ip->ip_src.s_addr));

		return (1);
	}

	/*
	 * Don't forward a packet with time-to-live of zero or one,
	 * or a packet destined to a local-only group.
	 */
	if (ip->ip_ttl <= 1 || IN_LOCAL_GROUP(ip->ip_dst.s_addr))
		return (0);

	/*
	 * Determine forwarding vifs from the forwarding cache table
	 */
	++mrtstat.mrts_mfc_lookups;
	rt = mfc_find(NULL, &ip->ip_src, &ip->ip_dst, rtableid);

	/* Entry exists, so forward if necessary */
	if (rt != NULL) {
		return (ip_mdq(m, ifp, rt));
	} else {
		/*
		 * If we don't have a route for packet's origin,
		 * Make a copy of the packet & send message to routing daemon
		 */
		int hlen = ip->ip_hl << 2;

		rtfree(rt);

		++mrtstat.mrts_mfc_misses;
		mrtstat.mrts_no_route++;

		{
			struct igmpmsg *im;

			/*
			 * Locate the vifi for the incoming interface for
			 * this packet.
			 * If none found, drop packet.
			 */
			if ((v = (struct vif *)ifp->if_mcast) == NULL)
				goto fail;
			/*
			 * Make a copy of the header to send to the user level
			 * process
			 */
			mm = m_copym(m, 0, hlen, M_NOWAIT);
			if (mm == NULL ||
			    (mm = m_pullup(mm, hlen)) == NULL)
				goto fail;

			/*
			 * Send message to routing daemon to install
			 * a route into the kernel table
			 */

			im = mtod(mm, struct igmpmsg *);
			im->im_msgtype = IGMPMSG_NOCACHE;
			im->im_mbz = 0;
			im->im_vif = v->v_id;

			mrtstat.mrts_upcalls++;

			sin.sin_addr = ip->ip_src;
			if (socket_send(ip_mrouter[rtableid], mm, &sin) < 0) {
				log(LOG_WARNING, "ip_mforward: ip_mrouter "
				    "socket queue full\n");
				++mrtstat.mrts_upq_sockfull;
			fail:
				return (ENOBUFS);
			}

			mfc_add(NULL, &ip->ip_src, &ip->ip_dst, v->v_id,
			    rtableid);
		}

		return (0);
	}
}

/*
 * Packet forwarding routine once entry in the cache is made
 */
int
ip_mdq(struct mbuf *m, struct ifnet *ifp0, struct rtentry *rt)
{
	struct ip  *ip = mtod(m, struct ip *);
	struct mfc *mfc = (struct mfc *)rt->rt_llinfo;
	struct vif *v = (struct vif *)ifp0->if_mcast;
	struct ifnet *ifp;
	struct mbuf *mc;
	struct ip_moptions imo;

	/* Sanity check: we have all promised pointers. */
	if (v == NULL || mfc == NULL)
		return (-1);

	/*
	 * Don't forward if it didn't arrive from the parent vif for its origin.
	 */
	if (mfc->mfc_parent != v->v_id) {
		/* came in the wrong interface */
		++mrtstat.mrts_wrong_if;
		mfc->mfc_wrong_if++;
		return (0);
	}

	/* If I sourced this packet, it counts as output, else it was input. */
	if (in_hosteq(ip->ip_src, v->v_lcl_addr)) {
		v->v_pkt_out++;
		v->v_bytes_out += m->m_pkthdr.len;
	} else {
		v->v_pkt_in++;
		v->v_bytes_in += m->m_pkthdr.len;
	}

	/*
	 * For each vif, decide if a copy of the packet should be forwarded.
	 * Forward if:
	 *		- the ttl exceeds the vif's threshold
	 *		- there are group members downstream on interface
	 */
	do {
		/* Don't consider non multicast routes. */
		if (ISSET(rt->rt_flags, RTF_HOST | RTF_MULTICAST) !=
		    (RTF_HOST | RTF_MULTICAST))
			continue;

		mfc = (struct mfc *)rt->rt_llinfo;
		mfc->mfc_pkt_cnt++;
		mfc->mfc_byte_cnt += m->m_pkthdr.len;

		/* Don't let this route expire. */
		mfc->mfc_expire = 0;

		if (ip->ip_ttl <= mfc->mfc_ttl)
			continue;
		if ((ifp = if_get(rt->rt_ifidx)) == NULL)
			continue;

		/* Sanity check: did we configure this? */
		if ((v = (struct vif *)ifp->if_mcast) == NULL) {
			if_put(ifp);
			continue;
		}

		/* Don't send in the upstream interface. */
		if (mfc->mfc_parent == v->v_id) {
			if_put(ifp);
			continue;
		}

		v->v_pkt_out++;
		v->v_bytes_out += m->m_pkthdr.len;

		/*
		 * Make a new reference to the packet; make sure
		 * that the IP header is actually copied, not
		 * just referenced, so that ip_output() only
		 * scribbles on the copy.
		 */
		mc = m_dup_pkt(m, max_linkhdr, M_NOWAIT);
		if (mc == NULL) {
			if_put(ifp);
			return (-1);
		}

		/*
		 * if physical interface option, extract the options
		 * and then send
		 */
		imo.imo_ifidx = rt->rt_ifidx;
		imo.imo_ttl = ip->ip_ttl - IPTTLDEC;
		imo.imo_loop = 1;

		ip_output(mc, NULL, NULL, IP_FORWARDING, &imo, NULL, 0);
		if_put(ifp);
	} while ((rt = rtable_iterate(rt)) != NULL);

	return (0);
}

struct ifnet *
if_lookupbyvif(vifi_t vifi, unsigned int rtableid)
{
	struct vif	*v;
	struct ifnet	*ifp;

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rtableid)
			continue;
		if ((v = (struct vif *)ifp->if_mcast) == NULL)
			continue;
		if (v->v_id != vifi)
			continue;

		return (ifp);
	}

	return (NULL);
}

struct rtentry *
rt_mcast_add(struct ifnet *ifp, struct sockaddr *origin, struct sockaddr *group)
{
	struct ifaddr		*ifa;
	int			 rv;
	unsigned int		 rtableid = ifp->if_rdomain;

	if ((ifa = TAILQ_FIRST(&ifp->if_addrlist)) == NULL) {
		DPRINTF("ifa == NULL");
		return (NULL);
	}

	rv = rt_ifa_add(ifa, RTF_HOST | RTF_MULTICAST, group);
	if (rv != 0) {
		DPRINTF("rt_ifa_add failed (%d)", rv);
		return (NULL);
	}

	mrt_count[rtableid]++;

	return (mfc_find(ifp, NULL, &satosin(group)->sin_addr, rtableid));
}

int
rt_mcast_del(struct rtentry *rt, unsigned int rtableid)
{
	struct ifnet		*ifp;
	int			 rv;

	if ((ifp = if_get(rt->rt_ifidx)) == NULL) {
		DPRINTF("if_get(%d) failed", rt->rt_ifidx);
		return (ENOENT);
	}

	rv = rtdeletemsg(rt, ifp, rtableid);
	if_put(ifp);
	if (rv != 0) {
		DPRINTF("rtdeletemsg failed (%d)", rv);
		return (rv);
	}

	mrt_count[rtableid]--;

	return (0);
}
@


1.111
log
@Make mfc_find() more strict when looking for routes, fixes a problem
causing ip_mforward() not to send packets to the userland multicast
routing daemon.

Reported and tested by Paul de Weerd.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.110 2017/02/09 15:36:46 rzalamena Exp $	*/
d296 5
d1182 5
@


1.110
log
@Unbreak 'netstat -g' and make multicast route stats sysctl more robust.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.109 2017/02/08 01:28:51 jsg Exp $	*/
a159 4
	/* Return first ocurrence if interface is not specified. */
	if (ifp == NULL)
		return (rt);

d161 7
@


1.109
log
@Test for NULL before dereferencing a pointer not after.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.108 2017/02/01 20:59:47 dhill Exp $	*/
d370 3
a372 3
	uint8_t		*msa_start;
	uint8_t		*msa_cur;
	uint8_t		*msa_end;
d383 1
a383 1
	int			 error;
d390 6
d404 2
a405 2
	for (minfo = (struct mfcinfo *)msa->msa_start;
	     (uint8_t *)minfo <= (msa->msa_end - sizeof(*minfo));
d408 10
a417 7
		if (!((minfo->mfc_origin.s_addr ==
		    satosin(rt->rt_gateway)->sin_addr.s_addr &&
		    minfo->mfc_mcastgrp.s_addr ==
		    satosin(rt_key(rt))->sin_addr.s_addr) ||
		    (minfo->mfc_origin.s_addr == 0 &&
		    minfo->mfc_mcastgrp.s_addr == 0)))
			continue;
d425 1
d428 3
a432 8
	if ((msa->msa_cur + sizeof(minfo)) >= msa->msa_end)
		return (ENOMEM);

	if ((error = copyout(&minfo, msa->msa_cur, sizeof(minfo))) != 0)
		return (error);

	msa->msa_cur += sizeof(minfo);

a438 1
	struct mfcsysctlarg	 msa = { oldp, oldp, oldp + *oldlenp };
d441 12
d454 2
a455 1
	memset(oldp, 0, *oldlenp);
d457 6
a462 6
	for (rtableid = 0; rtableid < RT_TABLEID_MAX; rtableid++) {
		error = rtable_walk(rtableid, AF_INET, mrt_rtwalk_mfcsysctl,
		    &msa);
		if (error != 0)
			return (error);
	}
@


1.108
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.107 2017/01/12 08:22:42 rzalamena Exp $	*/
d951 1
a951 1
	struct mfcctl *mp = mtod(m, struct mfcctl *);
d963 2
@


1.107
log
@Clean up multicast files from unused definitions and comments.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.106 2017/01/11 13:17:35 rzalamena Exp $	*/
d176 1
a176 1
ip_mrouter_set(struct socket *so, int optname, struct mbuf **mp)
d187 1
a187 1
			error = ip_mrouter_init(so, *mp);
d193 1
a193 1
			error = add_vif(so, *mp);
d196 1
a196 1
			error = del_vif(so, *mp);
d199 1
a199 1
			error = add_mfc(so, *mp);
d202 1
a202 1
			error = del_mfc(so, *mp);
d205 1
a205 1
			error = set_api_config(so, *mp);
d212 1
a212 1
	m_free(*mp);
d220 1
a220 1
ip_mrouter_get(struct socket *so, int optname, struct mbuf **mp)
a227 2
		*mp = m_get(M_WAIT, MT_SOOPTS);

d230 1
a230 1
			error = get_version(*mp);
d233 1
a233 1
			error = get_api_support(*mp);
d236 1
a236 1
			error = get_api_config(*mp);
a241 3

		if (error)
			m_free(*mp);
@


1.106
log
@Remove mfc hash tables and use the OpenBSD routing table for multicast
routes. Beside the code simplification and removal, we also get to see
the multicast routes now in the route(8) utility.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.105 2017/01/06 14:01:19 rzalamena Exp $	*/
a64 1
#include <sys/kernel.h>
a66 4
#include <sys/sysctl.h>
#include <sys/timeout.h>

#include <crypto/siphash.h>
a76 1
#include <netinet/igmp_var.h>
a129 5
 * Rate limit for assert notification messages, in usec
 */
#define ASSERT_MSG_TIME		3000000

/*
a172 23
 * Macros to compute elapsed time efficiently
 * Borrowed from Van Jacobson's scheduling code
 */
#define TV_DELTA(a, b, delta) do {					\
	int xxs;							\
	delta = (a).tv_usec - (b).tv_usec;				\
	xxs = (a).tv_sec - (b).tv_sec;					\
	switch (xxs) {							\
	case 2:								\
		delta += 1000000;					\
		/* FALLTHROUGH */					\
	case 1:								\
		delta += 1000000;					\
		/* FALLTHROUGH */					\
	case 0:								\
		break;							\
	default:							\
		delta += (1000000 * xxs);				\
		break;							\
	}								\
} while (/*CONSTCOND*/ 0)

/*
d355 1
a355 1
		if (where && needed <= given) { 
@


1.105
log
@Remove the global viftable vector that holds the virtual interfaces
configuration and instead use ifnet to store the configuration and
counters. With this we can safely use multicast routing daemons on
multiple domains without vif id colisions.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.104 2017/01/06 13:48:58 rzalamena Exp $	*/
d85 12
d102 2
a105 11
#define NO_RTE_FOUND	0x1
#define RTE_FOUND	0x2

u_int32_t _mfchash(unsigned int, struct in_addr, struct in_addr);

#define	MFCHASH(r, a, g) _mfchash((r), (a), (g))
LIST_HEAD(mfchashhdr, mfc) *mfchashtbl[RT_TABLEID_MAX];
u_long	mfchash[RT_TABLEID_MAX];
SIPHASH_KEY mfchashkey[RT_TABLEID_MAX];

u_char		nexpire[RT_TABLEID_MAX][MFCTBLSIZ];
d108 2
a109 4
#define		EXPIRE_TIMEOUT	250		/* 4x / second */
#define		UPCALL_EXPIRE	6		/* number of timeouts */
struct timeout	expire_upcalls_ch[RT_TABLEID_MAX];

d112 1
d114 1
d118 4
a121 3
void update_mfc_params(struct mfc *, struct mfcctl2 *);
void init_mfc_params(struct mfc *, struct mfcctl2 *);
void expire_mfc(struct mfc *);
d129 1
a129 2
void expire_upcalls(void *);
int ip_mdq(struct mbuf *, struct ifnet *, struct mfc *);
d131 3
d155 11
a165 5
static struct mfc *
mfc_find(unsigned int rtableid, struct in_addr *o, struct in_addr *g)
{
	struct mfc *rt;
	u_int32_t hash;
d167 2
a168 1
	if (mfchashtbl[rtableid] == NULL)
d171 8
a178 7
	hash = MFCHASH(rtableid, *o, *g);
	LIST_FOREACH(rt, &mfchashtbl[rtableid][hash], mfc_hash) {
		if (in_hosteq(rt->mfc_origin, *o) &&
		    in_hosteq(rt->mfc_mcastgrp, *g) &&
		    (rt->mfc_stall == NULL))
			break;
	}
d180 1
a180 1
	return (rt);
d321 2
a322 1
	struct mfc *rt;
d324 1
a324 1
	rt = mfc_find(rtableid, &req->src, &req->grp);
d329 8
a336 3
	req->pktcnt = rt->mfc_pkt_cnt;
	req->bytecnt = rt->mfc_byte_cnt;
	req->wrong_if = rt->mfc_wrong_if;
d408 62
d473 5
a477 6
	caddr_t where = oldp;
	size_t needed, given;
	u_long i;
	unsigned int rtableid;
	struct mfc *m;
	struct mfcinfo minfo;
a478 2
	given = *oldlenp;
	needed = 0;
d480 4
a483 24
		if (mfchashtbl[rtableid] == NULL)
			continue;

		for (i = 0; i < MFCTBLSIZ; ++i) {
			LIST_FOREACH(m, &mfchashtbl[rtableid][i], mfc_hash) {
				minfo.mfc_origin = m->mfc_origin;
				minfo.mfc_mcastgrp = m->mfc_mcastgrp;
				minfo.mfc_parent = m->mfc_parent;
				minfo.mfc_pkt_cnt = m->mfc_pkt_cnt;
				minfo.mfc_byte_cnt = m->mfc_byte_cnt;
				memcpy(minfo.mfc_ttls, m->mfc_ttls, MAXVIFS);

				needed += sizeof(minfo);
				if (where && needed <= given) {
					int error;

					error = copyout(&minfo, where,
					    sizeof(minfo));
					if (error)
						return (error);
					where += sizeof(minfo);
				}
			}
		}
a484 6
	if (where) {
		*oldlenp = needed;
		if (given < needed)
			return (ENOMEM);
	} else
		*oldlenp = (11 * needed) / 10;
d510 2
a511 1
	if (ip_mrouter[rtableid] != NULL)
d515 1
a515 9

	mfchashtbl[rtableid] =
	    hashinit(MFCTBLSIZ, M_MRTABLE, M_WAITOK, &mfchash[rtableid]);
	arc4random_buf(&mfchashkey[rtableid], sizeof(mfchashkey[rtableid]));
	memset(nexpire[rtableid], 0, sizeof(nexpire[rtableid]));

	timeout_set_proc(&expire_upcalls_ch[rtableid], expire_upcalls,
	    &inp->inp_rtableid);
	timeout_add_msec(&expire_upcalls_ch[rtableid], EXPIRE_TIMEOUT);
d520 2
a521 2
u_int32_t
_mfchash(unsigned int rtableid, struct in_addr o, struct in_addr g)
d523 4
a526 5
	SIPHASH_CTX ctx;

	SipHash24_Init(&ctx, &mfchashkey[rtableid]);
	SipHash24_Update(&ctx, &o.s_addr, sizeof(o.s_addr));
	SipHash24_Update(&ctx, &g.s_addr, sizeof(g.s_addr));
d528 3
a530 1
	return (SipHash24_End(&ctx) & mfchash[rtableid]);
a540 1
	int i;
d545 3
d557 2
a558 19
	timeout_del(&expire_upcalls_ch[rtableid]);

	/*
	 * Free all multicast forwarding cache entries.
	 */
	for (i = 0; i < MFCTBLSIZ; i++) {
		struct mfc *rt, *nrt;

		for (rt = LIST_FIRST(&mfchashtbl[rtableid][i]); rt; rt = nrt) {
			nrt = LIST_NEXT(rt, mfc_hash);

			expire_mfc(rt);
		}
	}

	memset(nexpire[rtableid], 0, sizeof(nexpire[rtableid]));
	hashfree(mfchashtbl[rtableid], MFCTBLSIZ, M_MRTABLE);
	mfchashtbl[rtableid] = NULL;

d560 1
a582 1
	int i;
d606 3
a608 8
	for (i = 0; i < MFCTBLSIZ; i++) {
		if (mfchashtbl[rtableid] == NULL)
			break;

		if (LIST_FIRST(&mfchashtbl[rtableid][i]) != NULL) {
			*apival = 0;
			return (EPERM);
		}
a762 3
/*
 * update an mfc entry without resetting counters and S,G addresses.
 */
d764 27
a790 1
update_mfc_params(struct mfc *rt, struct mfcctl2 *mfccp)
d792 8
a799 1
	int i;
d801 10
a810 5
	rt->mfc_parent = mfccp->mfcc_parent;
	for (i = 0; i < MAXVIFS; i++) {
		rt->mfc_ttls[i] = mfccp->mfcc_ttls[i];
		rt->mfc_flags[i] = mfccp->mfcc_flags[i] & mrt_api_config &
		    MRT_MFC_FLAGS_ALL;
d812 15
d829 1
a829 1
		rt->mfc_rp = mfccp->mfcc_rp;
d831 3
a833 1
		rt->mfc_rp = zeroin_addr;
a835 3
/*
 * fully initialize an mfc entry from the parameter.
 */
d837 1
a837 1
init_mfc_params(struct mfc *rt, struct mfcctl2 *mfccp)
d839 55
a893 2
	rt->mfc_origin     = mfccp->mfcc_origin;
	rt->mfc_mcastgrp   = mfccp->mfcc_mcastgrp;
d895 12
a906 1
	update_mfc_params(rt, mfccp);
d908 8
a915 5
	/* initialize pkt counters per src-grp */
	rt->mfc_pkt_cnt    = 0;
	rt->mfc_byte_cnt   = 0;
	rt->mfc_wrong_if   = 0;
	timerclear(&rt->mfc_last_assert);
d918 3
a920 2
void
expire_mfc(struct mfc *rt)
d922 19
a940 1
	struct rtdetq *rte, *nrte;
d942 1
a942 5
	for (rte = rt->mfc_stall; rte != NULL; rte = nrte) {
		nrte = rte->next;
		m_freem(rte->m);
		free(rte, M_MRTABLE, 0);
	}
d944 1
a944 2
	LIST_REMOVE(rt, mfc_hash);
	free(rt, M_MRTABLE, 0);
a946 3
/*
 * Add an mfc entry
 */
a951 5
	struct mfcctl2 *mfccp;
	struct mfc *rt;
	u_int32_t hash = 0;
	struct rtdetq *rte, *nrte;
	u_short nstl;
a974 1
	mfccp = &mfcctl2;
d976 3
a978 79
	/* No hash table allocated for this. */
	if (mfchashtbl[rtableid] == NULL)
		return (0);

	rt = mfc_find(rtableid, &mfccp->mfcc_origin, &mfccp->mfcc_mcastgrp);

	/* If an entry already exists, just update the fields */
	if (rt) {
		update_mfc_params(rt, mfccp);
		return (0);
	}

	/*
	 * Find the entry for which the upcall was made and update
	 */
	nstl = 0;
	hash = MFCHASH(rtableid, mfccp->mfcc_origin, mfccp->mfcc_mcastgrp);
	LIST_FOREACH(rt, &mfchashtbl[rtableid][hash], mfc_hash) {
		if (in_hosteq(rt->mfc_origin, mfccp->mfcc_origin) &&
		    in_hosteq(rt->mfc_mcastgrp, mfccp->mfcc_mcastgrp) &&
		    rt->mfc_stall != NULL) {
			if (nstl++) {
				log(LOG_ERR, "add_mfc %s o %x g %x "
				    "p %x dbx %p\n",
				    "multiple kernel entries",
				    ntohl(mfccp->mfcc_origin.s_addr),
				    ntohl(mfccp->mfcc_mcastgrp.s_addr),
				    mfccp->mfcc_parent, rt->mfc_stall);
			}

			rte = rt->mfc_stall;
			init_mfc_params(rt, mfccp);
			rt->mfc_stall = NULL;

			rt->mfc_expire = 0; /* Don't clean this guy up */
			nexpire[rtableid][hash]--;

			/* free packets Qed at the end of this entry */
			for (; rte != NULL; rte = nrte) {
				nrte = rte->next;
				if (rte->ifp) {
					ip_mdq(rte->m, rte->ifp, rt);
				}
				m_freem(rte->m);
				free(rte, M_MRTABLE, 0);
			}
		}
	}

	/*
	 * It is possible that an entry is being inserted without an upcall
	 */
	if (nstl == 0) {
		/*
		 * No mfc; make a new one
		 */
		LIST_FOREACH(rt, &mfchashtbl[rtableid][hash], mfc_hash) {
			if (in_hosteq(rt->mfc_origin, mfccp->mfcc_origin) &&
			    in_hosteq(rt->mfc_mcastgrp, mfccp->mfcc_mcastgrp)) {
				init_mfc_params(rt, mfccp);
				if (rt->mfc_expire)
					nexpire[rtableid][hash]--;
				rt->mfc_expire = 0;
				break; /* XXX */
			}
		}
		if (rt == NULL) {	/* no upcall, so make a new entry */
			rt = malloc(sizeof(*rt), M_MRTABLE, M_NOWAIT);
			if (rt == NULL)
				return (ENOBUFS);

			init_mfc_params(rt, mfccp);
			rt->mfc_expire	= 0;
			rt->mfc_stall	= NULL;

			/* insert new entry at head of hash chain */
			LIST_INSERT_HEAD(&mfchashtbl[rtableid][hash], rt, mfc_hash);
		}
	}
a982 3
/*
 * Delete an mfc entry
 */
d987 1
a988 2
	struct mfcctl2 *mfccp;
	struct mfc *rt;
d1007 2
a1008 1
	mfccp = &mfcctl2;
d1010 6
a1015 6
	rt = mfc_find(rtableid, &mfccp->mfcc_origin, &mfccp->mfcc_mcastgrp);
	if (rt == NULL)
		return (EADDRNOTAVAIL);

	LIST_REMOVE(rt, mfc_hash);
	free(rt, M_MRTABLE, 0);
d1052 1
a1052 1
	struct mfc *rt;
a1054 1
	int s;
d1086 1
a1086 1
	rt = mfc_find(rtableid, &ip->ip_src, &ip->ip_dst);
d1096 1
d1098 1
a1098 4
		struct mbuf *mb0;
		struct rtdetq *rte;
		u_int32_t hash;
		int hlen = ip->ip_hl << 2;
a1100 1

a1101 23
		/*
		 * Allocate mbufs early so that we don't do extra work if we are
		 * just going to fail anyway.  Make sure to pullup the header so
		 * that other people can't step on it.
		 */
		rte = malloc(sizeof(*rte), M_MRTABLE, M_NOWAIT);
		if (rte == NULL)
			return (ENOBUFS);
		mb0 = m_copym(m, 0, M_COPYALL, M_NOWAIT);
		if (mb0 == NULL ||
		    (mb0 = m_pullup(mb0, hlen)) == NULL) {
			free(rte, M_MRTABLE, 0);
			return (ENOBUFS);
		}

		/* is there an upcall waiting for this flow? */
		hash = MFCHASH(rtableid, ip->ip_src, ip->ip_dst);
		LIST_FOREACH(rt, &mfchashtbl[rtableid][hash], mfc_hash) {
			if (in_hosteq(ip->ip_src, rt->mfc_origin) &&
			    in_hosteq(ip->ip_dst, rt->mfc_mcastgrp) &&
			    rt->mfc_stall != NULL)
				break;
		}
d1103 1
a1103 2
		if (rt == NULL) {
			int i;
a1111 5
				goto non_fatal;

			/* no upcall, so make a new entry */
			rt = malloc(sizeof(*rt), M_MRTABLE, M_NOWAIT);
			if (rt == NULL)
d1120 1
a1120 1
				goto fail1;
a1138 2
			fail1:
				free(rt, M_MRTABLE, 0);
a1139 3
				free(rte, M_MRTABLE, 0);
				m_freem(mb0);
				splx(s);
d1143 2
a1144 42
			/* insert new entry at head of hash chain */
			rt->mfc_origin = ip->ip_src;
			rt->mfc_mcastgrp = ip->ip_dst;
			rt->mfc_pkt_cnt = 0;
			rt->mfc_byte_cnt = 0;
			rt->mfc_wrong_if = 0;
			rt->mfc_expire = UPCALL_EXPIRE;
			nexpire[rtableid][hash]++;
			for (i = 0; i < MAXVIFS; i++) {
				rt->mfc_ttls[i] = 0;
				rt->mfc_flags[i] = 0;
			}
			rt->mfc_parent = -1;

			/* clear the RP address */
			rt->mfc_rp = zeroin_addr;

			/* link into table */
			LIST_INSERT_HEAD(&mfchashtbl[rtableid][hash], rt, mfc_hash);
			/* Add this entry to the end of the queue */
			rt->mfc_stall = rte;
		} else {
			/* determine if q has overflowed */
			struct rtdetq **p;
			int npkts = 0;

			/*
			 * XXX ouch! we need to append to the list, but we
			 * only have a pointer to the front, so we have to
			 * scan the entire list every time.
			 */
			for (p = &rt->mfc_stall; *p != NULL; p = &(*p)->next)
				if (++npkts > MAX_UPQ) {
					mrtstat.mrts_upq_ovflw++;
				non_fatal:
					free(rte, M_MRTABLE, 0);
					m_freem(mb0);
					return (0);
				}

			/* Add this entry to the end of the queue */
			*p = rte;
a1146 4
		rte->next = NULL;
		rte->m = mb0;
		rte->ifp = ifp;

a1150 31

/*ARGSUSED*/
void
expire_upcalls(void *v)
{
	unsigned int rtableid = *(unsigned int *)v;
	int i, s;


	NET_LOCK(s);
	for (i = 0; i < MFCTBLSIZ; i++) {
		struct mfc *rt, *nrt;

		if (nexpire[rtableid][i] == 0)
			continue;

		for (rt = LIST_FIRST(&mfchashtbl[rtableid][i]); rt; rt = nrt) {
			nrt = LIST_NEXT(rt, mfc_hash);

			if (rt->mfc_expire == 0 || --rt->mfc_expire > 0)
				continue;
			nexpire[rtableid][i]--;

			++mrtstat.mrts_cache_cleanups;
			expire_mfc(rt);
		}
	}
	timeout_add_msec(&expire_upcalls_ch[rtableid], EXPIRE_TIMEOUT);
	NET_UNLOCK(s);
}

d1155 1
a1155 1
ip_mdq(struct mbuf *m, struct ifnet *ifp0, struct mfc *rt)
d1158 1
a1161 2
	int i;
	unsigned int rtableid = ifp0->if_rdomain;
d1165 1
a1165 1
	if (v == NULL || rt == NULL)
d1171 1
a1171 1
	if (rt->mfc_parent != v->v_id) {
d1174 1
a1174 1
		++rt->mfc_wrong_if;
a1185 2
	rt->mfc_pkt_cnt++;
	rt->mfc_byte_cnt += m->m_pkthdr.len;
d1193 11
a1203 2
	for (i = 0; i < MAXVIFS; i++) {
		if (rt->mfc_ttls[i] == 0)
d1205 4
a1208 1
		if (ip->ip_ttl <= rt->mfc_ttls[i])
d1210 5
a1214 1
		if ((ifp = if_lookupbyvif(i, rtableid)) == NULL)
d1216 1
a1217 1
		v = (struct vif *)ifp->if_mcast;
d1228 2
a1229 1
		if (mc == NULL)
d1231 1
d1237 1
a1237 1
		imo.imo_ifidx = ifp->if_index;
d1242 2
a1243 1
	}
d1266 46
@


1.104
log
@Simplify code by removing some old pullup macro, killing some variables
and using m_dup_pkt() instead of m_copym() with max_linkhdr space adjust
on packet sending to avoid more mbuf allocations.

with input from millert@@ and mikeb@@,
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.103 2017/01/06 10:02:57 mpi Exp $	*/
a102 1
struct vif	viftable[MAXVIFS];
a104 2
#define		VIFI_INVALID	((vifi_t) -1)

d110 1
a110 2
int get_vif_cnt(struct sioc_vif_req *);
int get_vif_ctl(struct vifctl *);
d114 1
a114 1
int del_vif(struct mbuf *);
d127 1
a127 2

static vifi_t	   numvifs = 0;
d216 1
a216 1
			error = del_vif(*mp);
d286 2
a287 1
			error = get_vif_cnt((struct sioc_vif_req *)data);
d325 1
a325 1
get_vif_cnt(struct sioc_vif_req *req)
d327 3
a329 1
	vifi_t vifi = req->vifi;
d331 1
a331 1
	if (vifi >= numvifs)
d334 5
a338 4
	req->icount = viftable[vifi].v_pkt_in;
	req->ocount = viftable[vifi].v_pkt_out;
	req->ibytes = viftable[vifi].v_bytes_in;
	req->obytes = viftable[vifi].v_bytes_out;
d348 1
a349 1
	vifi_t vifi;
d354 3
a356 4
	for (vifi = 0; vifi < numvifs; vifi++) {
		vifp = &viftable[vifi];
		if (in_nullhost(vifp->v_lcl_addr))
			continue;	
d358 1
a358 1
		vinfo.v_vifi = vifi;
d493 1
a493 2
	vifi_t vifi;
	struct vif *vifp;
d499 5
a503 5
	/* Clear out all the vifs currently in use. */
	for (vifi = 0; vifi < numvifs; vifi++) {
		vifp = &viftable[vifi];
		if (!in_nullhost(vifp->v_lcl_addr))
			reset_vif(vifp);
a505 1
	numvifs = 0;
d549 1
d565 6
a570 1
	if (numvifs > 0) {
a627 3
/*
 * Add a vif to the vif table
 */
d631 1
a631 1
	struct inpcb *inp;
d638 1
d650 1
a650 3

	vifp = &viftable[vifcp->vifc_vifi];
	if (!in_nullhost(vifp->v_lcl_addr))
a656 1
		inp = sotoinpcb(so);
d658 1
a658 1
		ifa = ifa_ifwithaddr(sintosa(&sin), inp->inp_rtableid);
d663 4
a666 3
	 {
		/* Use the physical interface associated with the address. */
		ifp = ifa->ifa_ifp;
d668 1
d683 4
a690 10
	vifp->v_ifp = ifp;
	/* Initialize per vif pkt counters. */
	vifp->v_pkt_in = 0;
	vifp->v_pkt_out = 0;
	vifp->v_bytes_in = 0;
	vifp->v_bytes_out = 0;

	/* Adjust numvifs up if the vifi is higher than numvifs. */
	if (numvifs <= vifcp->vifc_vifi)
		numvifs = vifcp->vifc_vifi + 1;
d695 2
a696 2
void
reset_vif(struct vif *vifp)
d698 1
a699 19
	struct ifreq ifr;

	{
		memset(&ifr, 0, sizeof(ifr));
		satosin(&ifr.ifr_addr)->sin_len = sizeof(struct sockaddr_in);
		satosin(&ifr.ifr_addr)->sin_family = AF_INET;
		satosin(&ifr.ifr_addr)->sin_addr = zeroin_addr;
		ifp = vifp->v_ifp;
		(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)&ifr);
	}
	memset(vifp, 0, sizeof(*vifp));
}

/*
 * Delete a vif from the vif table
 */
int
del_vif(struct mbuf *m)
{
d701 1
a701 2
	struct vif *vifp;
	vifi_t vifi;
d709 1
a709 5
	if (*vifip >= numvifs)
		return (EINVAL);

	vifp = &viftable[*vifip];
	if (in_nullhost(vifp->v_lcl_addr))
d712 1
a712 8
	reset_vif(vifp);

	/* Adjust numvifs down */
	for (vifi = numvifs; vifi > 0; vifi--)
		if (!in_nullhost(viftable[vifi - 1].v_lcl_addr))
			break;
	numvifs = vifi;

d719 2
a720 5
	int i;
	struct vif *vifp;
	struct mfc *rt;
	struct rtdetq *rte;
	unsigned int rtableid = ifp->if_rdomain;
d722 2
a723 5
	for (i = 0; i < numvifs; i++) {
		vifp = &viftable[i];
		if (vifp->v_ifp == ifp)
			memset(vifp, 0, sizeof(*vifp));
	}
d725 1
a725 4
	for (i = numvifs; i > 0; i--)
		if (!in_nullhost(viftable[i - 1].v_lcl_addr))
			break;
	numvifs = i;
d727 5
a731 2
	if (ip_mrouter[rtableid] == NULL)
		return;
d733 1
a733 11
	for (i = 0; i < MFCTBLSIZ; i++) {
		if (nexpire[rtableid][i] == 0)
			continue;

		LIST_FOREACH(rt, &mfchashtbl[rtableid][i], mfc_hash) {
			for (rte = rt->mfc_stall; rte; rte = rte->next) {
				if (rte->ifp == ifp)
					rte->ifp = NULL;
			}
		}
	}
d745 1
a745 1
	for (i = 0; i < numvifs; i++) {
d982 1
a986 1
	vifi_t vifi;
d1070 1
a1070 4
			for (vifi = 0; vifi < numvifs &&
				 viftable[vifi].v_ifp != ifp; vifi++)
				;
			if (vifi >= numvifs) /* vif not found, drop packet */
d1094 1
a1094 1
			im->im_vif = vifi;
d1120 1
a1120 1
			for (i = 0; i < numvifs; i++) {
d1199 1
a1199 1
ip_mdq(struct mbuf *m, struct ifnet *ifp, struct mfc *rt)
d1202 2
d1205 2
a1206 2
	vifi_t vifi;
	struct vif *vifp;
d1209 4
d1216 1
a1216 2
	vifi = rt->mfc_parent;
	if ((vifi >= numvifs) || (viftable[vifi].v_ifp != ifp)) {
d1224 3
a1226 3
	if (in_hosteq(ip->ip_src, viftable[vifi].v_lcl_addr)) {
		viftable[vifi].v_pkt_out++;
		viftable[vifi].v_bytes_out += m->m_pkthdr.len;
d1228 2
a1229 2
		viftable[vifi].v_pkt_in++;
		viftable[vifi].v_bytes_in += m->m_pkthdr.len;
d1240 6
a1245 3
	for (vifp = viftable, vifi = 0; vifi < numvifs; vifp++, vifi++) {
		if ((rt->mfc_ttls[vifi] == 0) ||
		    (ip->ip_ttl <= rt->mfc_ttls[vifi]))
d1248 3
a1250 2
		vifp->v_pkt_out++;
		vifp->v_bytes_out += m->m_pkthdr.len;
d1266 2
a1267 2
		imo.imo_ifidx = vifp->v_ifp->if_index;
		imo.imo_ttl = mtod(m, struct ip *)->ip_ttl - IPTTLDEC;
d1274 20
@


1.103
log
@Kill various splsoftnet().

ok rzalamena@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.102 2017/01/05 12:10:54 rzalamena Exp $	*/
a84 6
#define	M_PULLUP(m, len)						 \
	do {								 \
		if ((m) && ((m)->m_flags & M_EXT || (m)->m_len < (len))) \
			(m) = m_pullup((m), (len));			 \
	} while (/*CONSTCOND*/ 0)

d1099 2
a1100 2
		M_PULLUP(mb0, hlen);
		if (mb0 == NULL) {
d1138 2
a1139 2
			M_PULLUP(mm, hlen);
			if (mm == NULL)
a1260 2
	int hlen = ip->ip_hl << 2;
	int plen = ntohs(ip->ip_len) - hlen;
d1277 1
a1277 1
		viftable[vifi].v_bytes_out += plen;
d1280 1
a1280 1
		viftable[vifi].v_bytes_in += plen;
d1283 1
a1283 1
	rt->mfc_byte_cnt += plen;
d1297 1
a1297 1
		vifp->v_bytes_out += plen;
d1305 1
a1305 2
		mc = m_copym(m, 0, M_COPYALL, M_NOWAIT);
		M_PULLUP(mc, hlen);
@


1.102
log
@Remove some unnecessary code abstractions and while here remove a
splsoftnet.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.101 2016/12/22 11:04:44 rzalamena Exp $	*/
a316 1
	int s;
a318 1
	s = splsoftnet();
a320 1
		splx(s);
a326 1
	splx(s);
d475 1
a475 5
#ifdef PIM
	pim_assert = 0;
#endif

	timeout_set(&expire_upcalls_ch[rtableid], expire_upcalls,
a503 1
	int s;
d506 1
a506 1
	s = splsoftnet();
a517 4
#ifdef PIM
	pim_assert = 0;
#endif

a538 2
	splx(s);

d644 3
a646 1
	int error, s;
a689 2
	s = splsoftnet();

a700 2
	splx(s);

d734 2
a735 1
	int s;
a747 2
	s = splsoftnet();

a755 2
	splx(s);

a861 1
	int s;
d865 2
a886 1
	s = splsoftnet();
d888 1
a888 2
	if (mfchashtbl[rtableid] == NULL) {
		splx(s);
a889 1
	}
a895 1
		splx(s);
d955 1
a955 2
			if (rt == NULL) {
				splx(s);
a956 1
			}
a966 1
	splx(s);
a979 1
	int s;
d984 2
a999 2
	s = splsoftnet();

d1001 1
a1001 2
	if (rt == NULL) {
		splx(s);
a1002 1
	}
a1006 1
	splx(s);
a1075 1
	s = splsoftnet();
a1080 1
		splx(s);
d1102 1
a1102 2
		if (rte == NULL) {
			splx(s);
a1103 1
		}
a1107 1
			splx(s);
a1210 1
					splx(s);
a1221 2
		splx(s);

a1230 2
	int i;
	int s;
d1232 1
a1233 1
	s = splsoftnet();
d1235 1
a1252 2

	splx(s);
d1254 1
@


1.101
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.100 2016/12/21 12:05:01 mpi Exp $	*/
a136 2
void phyint_send(struct ip *, struct vif *, struct mbuf *);
void send_packet(struct vif *, struct mbuf *);
d1304 1
d1307 3
a1309 1
	int plen = ntohs(ip->ip_len) - (ip->ip_hl << 2);
d1339 4
a1342 7
	for (vifp = viftable, vifi = 0; vifi < numvifs; vifp++, vifi++)
		if ((rt->mfc_ttls[vifi] > 0) &&
			(ip->ip_ttl > rt->mfc_ttls[vifi])) {
			vifp->v_pkt_out++;
			vifp->v_bytes_out += plen;
			phyint_send(ip, vifp, m);
		}
d1344 2
a1345 2
	return (0);
}
d1347 10
a1356 5
void
phyint_send(struct ip *ip, struct vif *vifp, struct mbuf *m)
{
	struct mbuf *mb_copy;
	int hlen = ip->ip_hl << 2;
d1358 7
a1364 9
	/*
	 * Make a new reference to the packet; make sure that
	 * the IP header is actually copied, not just referenced,
	 * so that ip_output() only scribbles on the copy.
	 */
	mb_copy = m_copym(m, 0, M_COPYALL, M_NOWAIT);
	M_PULLUP(mb_copy, hlen);
	if (mb_copy == NULL)
		return;
d1366 2
a1367 2
	send_packet(vifp, mb_copy);
}
d1369 1
a1369 17
void
send_packet(struct vif *vifp, struct mbuf *m)
{
	struct ip_moptions imo;
	int s;

	/*
	 * if physical interface option, extract the options
	 * and then send
	 */
	imo.imo_ifidx = vifp->v_ifp->if_index;
	imo.imo_ttl = mtod(m, struct ip *)->ip_ttl - IPTTLDEC;
	imo.imo_loop = 1;

	s = splsoftnet();
	ip_output(m, NULL, NULL, IP_FORWARDING, &imo, NULL, 0);
	splx(s);
@


1.100
log
@Fix build without PIM defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.99 2016/12/21 09:52:29 rzalamena Exp $	*/
d56 1
a56 2
 * and PIM-SMv2 and PIM-DM support, advanced API support,
 * bandwidth metering and signaling
a58 4
#ifdef PIM
#define _PIM_VT 1
#endif

a84 5
#ifdef PIM
#include <netinet/pim.h>
#include <netinet/pim_var.h>
#endif

a139 64
#ifdef PIM
int pim_register_send(struct ip *, struct vif *,
    struct mbuf *, struct mfc *, unsigned int);
int pim_register_send_rp(struct ip *, struct vif *,
    struct mbuf *, struct mfc *, unsigned int);
int pim_register_send_upcall(struct ip *, struct vif *,
    struct mbuf *, struct mfc *, unsigned int);
struct mbuf *pim_register_prepare(struct ip *, struct mbuf *);
int set_assert(struct mbuf *);
int get_assert(struct mbuf *);

struct pimstat pimstat;

/*
 * Note: the PIM Register encapsulation adds the following in front of a
 * data packet:
 *
 * struct pim_encap_hdr {
 *    struct ip ip;
 *    struct pim_encap_pimhdr  pim;
 * }
 *
 */
struct pim_encap_pimhdr {
	struct pim pim;
	uint32_t   flags;
};
#define	PIM_ENCAP_TTL	64

static struct ip pim_encap_iphdr = {
#if BYTE_ORDER == LITTLE_ENDIAN
	sizeof(struct ip) >> 2,
	IPVERSION,
#else
	IPVERSION,
	sizeof(struct ip) >> 2,
#endif
	0,			/* tos */
	sizeof(struct ip),	/* total length */
	0,			/* id */
	0,			/* frag offset */ 
	PIM_ENCAP_TTL,
	IPPROTO_PIM,
	0,			/* checksum */
};

static struct pim_encap_pimhdr pim_encap_pimhdr = {
    {
	PIM_MAKE_VT(PIM_VERSION, PIM_REGISTER), /* PIM vers and message type */
	0,			/* reserved */
	0,			/* checksum */
    },
    0				/* flags */
};

static struct ifnet multicast_register_if;
static vifi_t reg_vif_num = VIFI_INVALID;

/*
 * whether or not special PIM assert processing is enabled.
 */
static int pim_assert;
#endif /* PIM */

a152 1
					  MRT_MFC_FLAGS_BORDER_VIF |
a236 5
#ifdef PIM
		case MRT_ASSERT:
			error = set_assert(*mp);
			break;
#endif
a266 5
#ifdef PIM
		case MRT_ASSERT:
			error = get_assert(*mp);
			break;
#endif
a568 31
#ifdef PIM
/*
 * Set PIM assert processing global
 */
int
set_assert(struct mbuf *m)
{
	int *i;

	if (m == NULL || m->m_len < sizeof(int))
		return (EINVAL);

	i = mtod(m, int *);
	pim_assert = !!*i;
	return (0);
}

/*
 * Get PIM assert processing global
 */
int
get_assert(struct mbuf *m)
{
	int *i = mtod(m, int *);

	*i = pim_assert;
	m->m_len = sizeof(int);
	return (0);
}
#endif

a588 1
	 *  - pim_assert is not enabled
a594 6
#ifdef PIM
	if (pim_assert) {
		*apival = 0;
		return (EPERM);
	}
#endif
a678 10

#ifdef PIM
	if (vifcp->vifc_flags & VIFF_REGISTER) {
		/*
		 * XXX: Because VIFF_REGISTER does not really need a valid
		 * local interface (e.g. it could be 127.0.0.2), we don't
		 * check its address.
		 */
	} else
#endif
a686 12
#ifdef PIM
	if (vifcp->vifc_flags & VIFF_REGISTER) {
		ifp = &multicast_register_if;
		if (reg_vif_num == VIFI_INVALID) {
			memset(ifp, 0, sizeof(*ifp));
			snprintf(ifp->if_xname, sizeof ifp->if_xname,
				 "register_vif");
			ifp->if_flags = IFF_LOOPBACK;
			reg_vif_num = vifcp->vifc_vifi;
		}
	} else
#endif
a732 5
#ifdef PIM
	if (vifp->v_flags & VIFF_REGISTER) {
		reg_vif_num = VIFI_INVALID;
	} else
#endif
a1317 66
#ifdef PIM
		/*
		 * If we are doing PIM assert processing, send a message
		 * to the routing daemon.
		 *
		 * XXX: A PIM-SM router needs the WRONGVIF detection so it
		 * can complete the SPT switch, regardless of the type
		 * of interface (broadcast media, GRE tunnel, etc).
		 */
		if (pim_assert && (vifi < numvifs) && viftable[vifi].v_ifp) {
			struct timeval now;
			u_int32_t delta;

			if (ifp == &multicast_register_if)
				pimstat.pims_rcv_registers_wrongiif++;

			/* Get vifi for the incoming packet */
			for (vifi = 0;
			     vifi < numvifs && viftable[vifi].v_ifp != ifp;
			     vifi++)
			    ;
			if (vifi >= numvifs) {
				/* The iif is not found: ignore the packet. */
				return (0);
			}

			if (rt->mfc_flags[vifi] &
			    MRT_MFC_FLAGS_DISABLE_WRONGVIF) {
				/* WRONGVIF disabled: ignore the packet */
				return (0);
			}

			microtime(&now);

			TV_DELTA(rt->mfc_last_assert, now, delta);

			if (delta > ASSERT_MSG_TIME) {
				unsigned int rtableid = ifp->if_rdomain;
				struct igmpmsg *im;
				int hlen = ip->ip_hl << 2;
				struct mbuf *mm = m_copym(m, 0, hlen, M_NOWAIT);

				M_PULLUP(mm, hlen);
				if (mm == NULL)
					return (ENOBUFS);

				rt->mfc_last_assert = now;

				im = mtod(mm, struct igmpmsg *);
				im->im_msgtype	= IGMPMSG_WRONGVIF;
				im->im_mbz	= 0;
				im->im_vif	= vifi;

				mrtstat.mrts_upcalls++;

				sin.sin_addr = im->im_src;
				if (socket_send(ip_mrouter[rtableid], mm,
				    &sin) < 0) {
					log(LOG_WARNING, "ip_mforward: "
					    "ip_mrouter socket queue full\n");
					++mrtstat.mrts_upq_sockfull;
					return (ENOBUFS);
				}
			}
		}
#endif
a1342 5
#ifdef PIM
			if (vifp->v_flags & VIFF_REGISTER)
				pim_register_send(ip, vifp, m, rt, rtableid);
			else
#endif
a1385 438

#ifdef PIM
/*
 * Send the packet up to the user daemon, or eventually do kernel encapsulation
 */
int
pim_register_send(struct ip *ip, struct vif *vifp,
    struct mbuf *m, struct mfc *rt, unsigned int rtableid)
{
	struct mbuf *mb_copy, *mm;

	mb_copy = pim_register_prepare(ip, m);
	if (mb_copy == NULL)
		return (ENOBUFS);

	/*
	 * Send all the fragments. Note that the mbuf for each fragment
	 * is freed by the sending machinery.
	 */
	for (mm = mb_copy; mm; mm = mb_copy) {
		mb_copy = mm->m_nextpkt;
		mm->m_nextpkt = NULL;
		mm = m_pullup(mm, sizeof(struct ip));
		if (mm != NULL) {
			ip = mtod(mm, struct ip *);
			if ((mrt_api_config & MRT_MFC_RP) &&
			    !in_nullhost(rt->mfc_rp)) {
				pim_register_send_rp(ip, vifp, mm, rt,
				    rtableid);
			} else {
				pim_register_send_upcall(ip, vifp, mm, rt,
				    rtableid);
			}
		}
	}

	return (0);
}

/*
 * Return a copy of the data packet that is ready for PIM Register
 * encapsulation.
 * XXX: Note that in the returned copy the IP header is a valid one.
 */
struct mbuf *
pim_register_prepare(struct ip *ip, struct mbuf *m)
{
	struct mbuf *mb_copy = NULL;
	int mtu;

	in_proto_cksum_out(m, NULL);

	/*
	 * Copy the old packet & pullup its IP header into the
	 * new mbuf so we can modify it.
	 */
	mb_copy = m_copym(m, 0, M_COPYALL, M_NOWAIT);
	if (mb_copy == NULL)
		return (NULL);
	mb_copy = m_pullup(mb_copy, ip->ip_hl << 2);
	if (mb_copy == NULL)
		return (NULL);

	/* take care of the TTL */
	ip = mtod(mb_copy, struct ip *);
	--ip->ip_ttl;

	/* Compute the MTU after the PIM Register encapsulation */
	mtu = 0xffff - sizeof(pim_encap_iphdr) - sizeof(pim_encap_pimhdr);

	if (ntohs(ip->ip_len) <= mtu) {
		/* Turn the IP header into a valid one */
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(mb_copy, ip->ip_hl << 2);
	} else {
		/* Fragment the packet */
		if (ip_fragment(mb_copy, NULL, mtu) != 0) {
			/* XXX: mb_copy was freed by ip_fragment() */
			return (NULL);
		}
	}
	return (mb_copy);
}

/*
 * Send an upcall with the data packet to the user-level process.
 */
int
pim_register_send_upcall(struct ip *ip, struct vif *vifp,
    struct mbuf *mb_copy, struct mfc *rt, unsigned int rtableid)
{
	struct mbuf *mb_first;
	int len = ntohs(ip->ip_len);
	struct igmpmsg *im;
	struct sockaddr_in k_igmpsrc = { sizeof k_igmpsrc, AF_INET };

	/* Add a new mbuf with an upcall header */
	MGETHDR(mb_first, M_DONTWAIT, MT_HEADER);
	if (mb_first == NULL) {
		m_freem(mb_copy);
		return (ENOBUFS);
	}
	mb_first->m_data += max_linkhdr;
	mb_first->m_pkthdr.len = len + sizeof(struct igmpmsg);
	mb_first->m_len = sizeof(struct igmpmsg);
	mb_first->m_next = mb_copy;

	/* Send message to routing daemon */
	im = mtod(mb_first, struct igmpmsg *);
	im->im_msgtype = IGMPMSG_WHOLEPKT;
	im->im_mbz = 0;
	im->im_vif = vifp - viftable;
	im->im_src = ip->ip_src;
	im->im_dst = ip->ip_dst;

	k_igmpsrc.sin_addr = ip->ip_src;

	mrtstat.mrts_upcalls++;

	if (socket_send(ip_mrouter[rtableid], mb_first, &k_igmpsrc) < 0) {
		++mrtstat.mrts_upq_sockfull;
		return (ENOBUFS);
	}

	/* Keep statistics */
	pimstat.pims_snd_registers_msgs++;
	pimstat.pims_snd_registers_bytes += len;

	return (0);
}

/*
 * Encapsulate the data packet in PIM Register message and send it to the RP.
 */
int
pim_register_send_rp(struct ip *ip, struct vif *vifp,
    struct mbuf *mb_copy, struct mfc *rt, unsigned int rtableid)
{
	struct mbuf *mb_first;
	struct ip *ip_outer;
	struct pim_encap_pimhdr *pimhdr;
	int len = ntohs(ip->ip_len);
	vifi_t vifi = rt->mfc_parent;

	if ((vifi >= numvifs) || in_nullhost(viftable[vifi].v_lcl_addr)) {
		m_freem(mb_copy);
		return (EADDRNOTAVAIL);		/* The iif vif is invalid */
	}

	/* Add a new mbuf with the encapsulating header */
	MGETHDR(mb_first, M_DONTWAIT, MT_HEADER);
	if (mb_first == NULL) {
		m_freem(mb_copy);
		return (ENOBUFS);
	}
	mb_first->m_data += max_linkhdr;
	mb_first->m_len = sizeof(pim_encap_iphdr) + sizeof(pim_encap_pimhdr);
	mb_first->m_next = mb_copy;

	mb_first->m_pkthdr.len = len + mb_first->m_len;

	/* Fill in the encapsulating IP and PIM header */
	ip_outer = mtod(mb_first, struct ip *);
	*ip_outer = pim_encap_iphdr;
	ip_outer->ip_id = htons(ip_randomid());
	ip_outer->ip_len = htons(len + sizeof(pim_encap_iphdr) +
	    sizeof(pim_encap_pimhdr));
	ip_outer->ip_src = viftable[vifi].v_lcl_addr;
	ip_outer->ip_dst = rt->mfc_rp;
	/*
	 * Copy the inner header TOS to the outer header, and take care of the
	 * IP_DF bit.
	 */
	ip_outer->ip_tos = ip->ip_tos;
	if (ntohs(ip->ip_off) & IP_DF)
		ip_outer->ip_off |= htons(IP_DF);
	pimhdr = (struct pim_encap_pimhdr *)((caddr_t)ip_outer
	    + sizeof(pim_encap_iphdr));
	*pimhdr = pim_encap_pimhdr;
	/* If the iif crosses a border, set the Border-bit */
	if (rt->mfc_flags[vifi] & MRT_MFC_FLAGS_BORDER_VIF & mrt_api_config)
		pimhdr->flags |= htonl(PIM_BORDER_REGISTER);

	mb_first->m_data += sizeof(pim_encap_iphdr);
	pimhdr->pim.pim_cksum = in_cksum(mb_first, sizeof(pim_encap_pimhdr));
	mb_first->m_data -= sizeof(pim_encap_iphdr);

	send_packet(vifp, mb_first);

	/* Keep statistics */
	pimstat.pims_snd_registers_msgs++;
	pimstat.pims_snd_registers_bytes += len;

	return (0);
}

/*
 * PIM-SMv2 and PIM-DM messages processing.
 * Receives and verifies the PIM control messages, and passes them
 * up to the listening socket, using rip_input().
 * The only message with special processing is the PIM_REGISTER message
 * (used by PIM-SM): the PIM header is stripped off, and the inner packet
 * is passed to if_simloop().
 */
void
pim_input(struct mbuf *m, ...)
{
	struct ip *ip = mtod(m, struct ip *);
	struct pim *pim;
	int minlen;
	int datalen;
	int ip_tos;
	int iphlen;
	va_list ap;

	va_start(ap, m);
	iphlen = va_arg(ap, int);
	va_end(ap);

	datalen = ntohs(ip->ip_len) - iphlen;

	/* Keep statistics */
	pimstat.pims_rcv_total_msgs++;
	pimstat.pims_rcv_total_bytes += datalen;

	/* Validate lengths */
	if (datalen < PIM_MINLEN) {
		pimstat.pims_rcv_tooshort++;
		log(LOG_ERR, "pim_input: packet size too small %d from %lx\n",
		    datalen, (u_long)ip->ip_src.s_addr);
		m_freem(m);
		return;
	}

	/*
	 * If the packet is at least as big as a REGISTER, go agead
	 * and grab the PIM REGISTER header size, to avoid another
	 * possible m_pullup() later.
	 * 
	 * PIM_MINLEN       == pimhdr + u_int32_t == 4 + 4 = 8
	 * PIM_REG_MINLEN   == pimhdr + reghdr + encap_iphdr == 4 + 4 + 20 = 28
	 */
	minlen = iphlen + (datalen >= PIM_REG_MINLEN ?
	    PIM_REG_MINLEN : PIM_MINLEN);
	/*
	 * Get the IP and PIM headers in contiguous memory, and
	 * possibly the PIM REGISTER header.
	 */
	if ((m->m_flags & M_EXT || m->m_len < minlen) &&
	    (m = m_pullup(m, minlen)) == NULL) {
		log(LOG_ERR, "pim_input: m_pullup failure\n");
		return;
	}
	/* m_pullup() may have given us a new mbuf so reset ip. */
	ip = mtod(m, struct ip *);
	ip_tos = ip->ip_tos;

	/* adjust mbuf to point to the PIM header */
	m->m_data += iphlen;
	m->m_len  -= iphlen;
	pim = mtod(m, struct pim *);

	/*
	 * Validate checksum. If PIM REGISTER, exclude the data packet.
	 *
	 * XXX: some older PIMv2 implementations don't make this distinction,
	 * so for compatibility reason perform the checksum over part of the
	 * message, and if error, then over the whole message.
	 */
	if (PIM_VT_T(pim->pim_vt) == PIM_REGISTER &&
	    in_cksum(m, PIM_MINLEN) == 0) {
		/* do nothing, checksum okay */
	} else if (in_cksum(m, datalen)) {
		pimstat.pims_rcv_badsum++;
		m_freem(m);
		return;
	}

	/* PIM version check */
	if (PIM_VT_V(pim->pim_vt) < PIM_VERSION) {
		pimstat.pims_rcv_badversion++;
		log(LOG_ERR, "pim_input: incorrect version %d, expecting %d\n",
		    PIM_VT_V(pim->pim_vt), PIM_VERSION);
		m_freem(m);
		return;
	}

	/* restore mbuf back to the outer IP */
	m->m_data -= iphlen;
	m->m_len  += iphlen;

	if (PIM_VT_T(pim->pim_vt) == PIM_REGISTER) {
		/*
		 * Since this is a REGISTER, we'll make a copy of the register
		 * headers ip + pim + u_int32 + encap_ip, to be passed up to the
		 * routing daemon.
		 */
		int s;
		struct sockaddr_in dst = { sizeof(dst), AF_INET };
		struct mbuf *mcp;
		struct ip *encap_ip;
		u_int32_t *reghdr;
		struct ifnet *vifp;

		s = splsoftnet();
		if ((reg_vif_num >= numvifs) || (reg_vif_num == VIFI_INVALID)) {
			splx(s);
			m_freem(m);
			return;
		}
		/* XXX need refcnt? */
		vifp = viftable[reg_vif_num].v_ifp;
		splx(s);

		/* Validate length */
		if (datalen < PIM_REG_MINLEN) {
			pimstat.pims_rcv_tooshort++;
			pimstat.pims_rcv_badregisters++;
			log(LOG_ERR, "pim_input: register packet size "
			    "too small %d from %lx\n",
			    datalen, (u_long)ip->ip_src.s_addr);
			m_freem(m);
			return;
		}

		reghdr = (u_int32_t *)(pim + 1);
		encap_ip = (struct ip *)(reghdr + 1);

		/* verify the version number of the inner packet */
		if (encap_ip->ip_v != IPVERSION) {
			pimstat.pims_rcv_badregisters++;
			m_freem(m);
			return;
		}

		/* verify the inner packet is destined to a mcast group */
		if (!IN_MULTICAST(encap_ip->ip_dst.s_addr)) {
			pimstat.pims_rcv_badregisters++;
			m_freem(m);
			return;
		}

		/* If a NULL_REGISTER, pass it to the daemon */
		if ((ntohl(*reghdr) & PIM_NULL_REGISTER))
			goto pim_input_to_daemon;

		/*
		 * Copy the TOS from the outer IP header to the inner
		 * IP header.
		 */
		if (encap_ip->ip_tos != ip_tos) {
			/* Outer TOS -> inner TOS */
			encap_ip->ip_tos = ip_tos;
			/* Recompute the inner header checksum. Sigh... */

			/* adjust mbuf to point to the inner IP header */
			m->m_data += (iphlen + PIM_MINLEN);
			m->m_len  -= (iphlen + PIM_MINLEN);

			encap_ip->ip_sum = 0;
			encap_ip->ip_sum = in_cksum(m, encap_ip->ip_hl << 2);

			/* restore mbuf to point back to the outer IP header */
			m->m_data -= (iphlen + PIM_MINLEN);
			m->m_len  += (iphlen + PIM_MINLEN);
		}

		/*
		 * Decapsulate the inner IP packet and loopback to forward it
		 * as a normal multicast packet. Also, make a copy of the 
		 *     outer_iphdr + pimhdr + reghdr + encap_iphdr
		 * to pass to the daemon later, so it can take the appropriate
		 * actions (e.g., send back PIM_REGISTER_STOP).
		 * XXX: here m->m_data points to the outer IP header.
		 */
		mcp = m_copym(m, 0, iphlen + PIM_REG_MINLEN, M_NOWAIT);
		if (mcp == NULL) {
			log(LOG_ERR, "pim_input: pim register: could not "
			    "copy register head\n");
			m_freem(m);
			return;
		}

		/* Keep statistics */
		/* XXX: registers_bytes include only the encap. mcast pkt */
		pimstat.pims_rcv_registers_msgs++;
		pimstat.pims_rcv_registers_bytes += ntohs(encap_ip->ip_len);

		/* forward the inner ip packet; point m_data at the inner ip. */
		m_adj(m, iphlen + PIM_MINLEN);

		/* NB: vifp was collected above; can it change on us? */
		if_input_local(vifp, m, dst.sin_family);

		/* prepare the register head to send to the mrouting daemon */
		m = mcp;
	}

pim_input_to_daemon:
	/*
	 * Pass the PIM message up to the daemon; if it is a Register message,
	 * pass the 'head' only up to the daemon. This includes the
	 * outer IP header, PIM header, PIM-Register header and the
	 * inner IP header.
	 * XXX: the outer IP header pkt size of a Register is not adjust to
	 * reflect the fact that the inner multicast data is truncated.
	 */
	rip_input(m);

	return;
}

/*
 * Sysctl for pim variables.
 */
int
pim_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case PIMCTL_STATS:
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &pimstat, sizeof(pimstat)));

	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}


#endif /* PIM */
@


1.99
log
@Fix PIM compilation even though it is disabled.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.98 2016/12/20 10:54:52 rzalamena Exp $	*/
a1458 1
	unsigned int rtableid = ifp->if_rdomain;
d1505 1
@


1.98
log
@Call the multicast timer callback per domain instead of for all domains
this way we save doing big tables walk and iterating tables that we don't
need to.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.97 2016/12/20 09:33:13 rzalamena Exp $	*/
d152 1
a152 1
		struct mbuf *, struct mfc *);
d154 1
a154 1
		struct mbuf *, struct mfc *);
d156 1
a156 1
		struct mbuf *, struct mfc *);
d1459 1
d1561 1
a1561 1
				pim_register_send(ip, vifp, m, rt);
d1614 1
a1614 1
	struct mbuf *m, struct mfc *rt)
d1634 2
a1635 1
				pim_register_send_rp(ip, vifp, mm, rt);
d1637 2
a1638 1
				pim_register_send_upcall(ip, vifp, mm, rt);
d1696 1
a1696 1
	struct mbuf *mb_copy, struct mfc *rt)
d1743 1
a1743 1
	struct mbuf *mb_copy, struct mfc *rt)
@


1.97
log
@Remove unused timeout that was never being set.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.96 2016/12/19 12:52:41 rzalamena Exp $	*/
d126 1
a126 1
struct timeout	expire_upcalls_ch;
d570 3
a572 2
	timeout_set(&expire_upcalls_ch, expire_upcalls, NULL);
	timeout_add_msec(&expire_upcalls_ch, EXPIRE_TIMEOUT);
d618 1
a618 1
	timeout_del(&expire_upcalls_ch);
d1423 1
a1423 1
	unsigned int rtableid;
d1433 4
a1436 2
		for (rtableid = 0; rtableid < RT_TABLEID_MAX; rtableid++) {
			if (mfchashtbl[rtableid] == NULL)
d1438 1
d1440 2
a1441 11
			for (rt = LIST_FIRST(&mfchashtbl[rtableid][i]); rt;
			     rt = nrt) {
				nrt = LIST_NEXT(rt, mfc_hash);

				if (rt->mfc_expire == 0 || --rt->mfc_expire > 0)
					continue;
				nexpire[rtableid][i]--;

				++mrtstat.mrts_cache_cleanups;
				expire_mfc(rt);
			}
d1446 1
a1446 1
	timeout_add_msec(&expire_upcalls_ch, EXPIRE_TIMEOUT);
@


1.96
log
@Kill unused function.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.95 2016/12/19 09:22:24 rzalamena Exp $	*/
a860 2

	timeout_del(&vifp->v_repq_ch);
@


1.95
log
@Extend the multicast sockets and multicast hash table support to multiple
domains. This is one step towards supporting to run more than one multicast
socket in different domains at the same time.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.94 2016/12/13 09:22:18 rzalamena Exp $	*/
a640 26
}

void
ip_mrouter_detach(struct ifnet *ifp)
{
	int vifi, i;
	struct vif *vifp;
	struct mfc *rt;
	struct rtdetq *rte;

	/* XXX not sure about side effect to userland routing daemon */
	for (vifi = 0; vifi < numvifs; vifi++) {
		vifp = &viftable[vifi];
		if (vifp->v_ifp == ifp)
			reset_vif(vifp);
	}
	for (i = 0; i < MFCTBLSIZ; i++) {
		if (nexpire[i] == 0)
			continue;
		LIST_FOREACH(rt, &mfchashtbl[ifp->if_rdomain][i], mfc_hash) {
			for (rte = rt->mfc_stall; rte; rte = rte->next) {
				if (rte->ifp == ifp)
					rte->ifp = NULL;
			}
		}
	}
@


1.94
log
@Propagate the routing table id in ip_mrouter_set() so the MRT_ADD_VIF
calls won't fail anymore when doing from a different rdomain.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.93 2016/11/29 15:52:12 mpi Exp $	*/
d105 1
a105 1
struct socket  *ip_mrouter  = NULL;
d111 1
a111 1
u_int32_t _mfchash(struct in_addr, struct in_addr);
d113 4
a116 4
#define	MFCHASH(a, g) _mfchash((a), (g))
LIST_HEAD(mfchashhdr, mfc) *mfchashtbl;
u_long	mfchash;
SIPHASH_KEY mfchashkey;
d118 1
a118 1
u_char		nexpire[MFCTBLSIZ];
d128 1
a128 1
int get_sg_cnt(struct sioc_sg_req *);
d138 3
a140 3
int add_mfc(struct mbuf *);
int del_mfc(struct mbuf *);
int set_api_config(struct mbuf *); /* chose API capabilities */
d238 1
a238 1
mfc_find(struct in_addr *o, struct in_addr *g)
d243 5
a247 2
	hash = MFCHASH(*o, *g);
	LIST_FOREACH(rt, &mfchashtbl[hash], mfc_hash) {
d286 1
d289 2
a290 1
	if (optname != MRT_INIT && so != ip_mrouter)
d298 1
a298 1
			error = ip_mrouter_done();
d307 1
a307 1
			error = add_mfc(*mp);
d310 1
a310 1
			error = del_mfc(*mp);
d318 1
a318 1
			error = set_api_config(*mp);
d335 1
d338 1
a338 1
	if (so != ip_mrouter)
d376 1
d379 1
a379 1
	if (so != ip_mrouter)
d387 2
a388 1
			error = get_sg_cnt((struct sioc_sg_req *)data);
d402 1
a402 1
get_sg_cnt(struct sioc_sg_req *req)
d408 1
a408 1
	rt = mfc_find(&req->src, &req->grp);
d493 1
d499 23
a521 17
	for (i = 0; mfchashtbl && i < MFCTBLSIZ; ++i) {
		LIST_FOREACH(m, &mfchashtbl[i], mfc_hash) {
			minfo.mfc_origin = m->mfc_origin;
			minfo.mfc_mcastgrp = m->mfc_mcastgrp;
			minfo.mfc_parent = m->mfc_parent;
			minfo.mfc_pkt_cnt = m->mfc_pkt_cnt;
			minfo.mfc_byte_cnt = m->mfc_byte_cnt;
			memcpy(minfo.mfc_ttls, m->mfc_ttls, MAXVIFS);

			needed += sizeof(minfo);
			if (where && needed <= given) { 
				int error;

				error = copyout(&minfo, where, sizeof(minfo));
				if (error)
					return (error);
				where += sizeof(minfo);
d541 2
d556 1
a556 1
	if (ip_mrouter != NULL)
d559 1
a559 1
	ip_mrouter = so;
d561 4
a564 3
	mfchashtbl = hashinit(MFCTBLSIZ, M_MRTABLE, M_WAITOK, &mfchash);
	arc4random_buf(&mfchashkey, sizeof(mfchashkey));
	memset(nexpire, 0, sizeof(nexpire));
d577 1
a577 1
_mfchash(struct in_addr o, struct in_addr g)
d581 1
a581 1
	SipHash24_Init(&ctx, &mfchashkey);
d585 1
a585 1
	return (SipHash24_End(&ctx) & mfchash);
d592 1
a592 1
ip_mrouter_done(void)
d594 1
d599 1
d625 1
a625 1
		for (rt = LIST_FIRST(&mfchashtbl[i]); rt; rt = nrt) {
d632 3
a634 3
	memset(nexpire, 0, sizeof(nexpire));
	hashfree(mfchashtbl, MFCTBLSIZ, M_MRTABLE);
	mfchashtbl = NULL;
d636 1
a636 1
	ip_mrouter = NULL;
d660 1
a660 1
		LIST_FOREACH(rt, &mfchashtbl[i], mfc_hash) {
d714 1
a714 1
set_api_config(struct mbuf *m)
d716 1
d719 1
d744 4
a747 1
		if (LIST_FIRST(&mfchashtbl[i]) != NULL) {
d965 1
d978 3
d982 1
a982 1
		if (nexpire[i] == 0)
d984 2
a985 1
		LIST_FOREACH(rt, &mfchashtbl[i], mfc_hash) {
d1052 1
a1052 1
add_mfc(struct mbuf *m)
d1054 1
d1063 1
d1086 7
a1092 1
	rt = mfc_find(&mfccp->mfcc_origin, &mfccp->mfcc_mcastgrp);
d1105 2
a1106 2
	hash = MFCHASH(mfccp->mfcc_origin, mfccp->mfcc_mcastgrp);
	LIST_FOREACH(rt, &mfchashtbl[hash], mfc_hash) {
d1124 1
a1124 1
			nexpire[hash]--;
d1145 1
a1145 1
		LIST_FOREACH(rt, &mfchashtbl[hash], mfc_hash) {
d1150 1
a1150 1
					nexpire[hash]--;
d1167 1
a1167 1
			LIST_INSERT_HEAD(&mfchashtbl[hash], rt, mfc_hash);
d1179 1
a1179 1
del_mfc(struct mbuf *m)
d1181 1
d1188 1
d1206 1
a1206 1
	rt = mfc_find(&mfccp->mfcc_origin, &mfccp->mfcc_mcastgrp);
d1255 1
d1287 1
a1287 1
	rt = mfc_find(&ip->ip_src, &ip->ip_dst);
d1326 2
a1327 2
		hash = MFCHASH(ip->ip_src, ip->ip_dst);
		LIST_FOREACH(rt, &mfchashtbl[hash], mfc_hash) {
d1375 1
a1375 1
			if (socket_send(ip_mrouter, mm, &sin) < 0) {
d1395 1
a1395 1
			nexpire[hash]++;
d1406 1
a1406 1
			LIST_INSERT_HEAD(&mfchashtbl[hash], rt, mfc_hash);
d1450 1
d1457 1
a1457 1
		if (nexpire[i] == 0)
d1460 3
a1462 2
		for (rt = LIST_FIRST(&mfchashtbl[i]); rt; rt = nrt) {
			nrt = LIST_NEXT(rt, mfc_hash);
d1464 7
a1470 3
			if (rt->mfc_expire == 0 || --rt->mfc_expire > 0)
				continue;
			nexpire[i]--;
d1472 3
a1474 2
			++mrtstat.mrts_cache_cleanups;
			expire_mfc(rt);
d1556 2
a1557 1
				if (socket_send(ip_mrouter, mm, &sin) < 0) {
d1756 1
a1756 1
	if (socket_send(ip_mrouter, mb_first, &k_igmpsrc) < 0) {
@


1.93
log
@Kill unused 'struct route'.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.92 2016/11/29 10:22:30 jsg Exp $	*/
d133 1
a133 1
int add_vif(struct mbuf *);
d296 1
a296 1
			error = add_vif(*mp);
d776 1
a776 1
add_vif(struct mbuf *m)
d778 1
d813 1
d815 1
a815 1
		ifa = ifa_ifwithaddr(sintosa(&sin), /* XXX */ 0);
@


1.92
log
@m_free() and m_freem() test for NULL.  Simplify callers which had their own
NULL tests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.91 2016/09/24 18:39:48 tedu Exp $	*/
a825 1
			memset(&vifp->v_route, 0, sizeof(vifp->v_route));
@


1.91
log
@use hashfree. from Mathieu -
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.90 2016/03/07 18:44:00 naddy Exp $	*/
d320 1
a320 2
	if (*mp)
		m_free(*mp);
@


1.90
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.89 2015/11/14 15:54:27 mpi Exp $	*/
d614 1
a614 1
	free(mfchashtbl, M_MRTABLE, 0);
@


1.89
log
@Remove mrtdebug and reduce differences with the v6 version.

Debug informations can already be accessed via mrtstat and pimstat.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.88 2015/11/13 10:33:12 mpi Exp $	*/
d575 1
a575 1
ip_mrouter_done()
@


1.88
log
@Do not cast malloc(9) results.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.87 2015/11/13 10:25:48 mpi Exp $	*/
a120 6
u_int		mrtdebug = 0;	  /* debug level 	*/
#define		DEBUG_MFC	0x02
#define		DEBUG_FORWARD	0x04
#define		DEBUG_EXPIRE	0x08
#define		DEBUG_XMIT	0x10
#define		DEBUG_PIM	0x20
a159 1
#endif
a160 1
#ifdef PIM
a528 5
	if (mrtdebug)
		log(LOG_DEBUG,
		    "ip_mrouter_init: so_type = %d, pr_protocol = %d\n",
		    so->so_type, so->so_proto->pr_protocol);

a555 3
	if (mrtdebug)
		log(LOG_DEBUG, "ip_mrouter_init\n");

a620 3
	if (mrtdebug)
		log(LOG_DEBUG, "ip_mrouter_done\n");

a821 3
		if (mrtdebug)
			log(LOG_DEBUG, "Adding a register vif, ifp: %p\n",
			    (void *)ifp);
a929 3
	if (mrtdebug)
		log(LOG_DEBUG, "del_vif %d, numvifs %d\n", *vifip, numvifs);

a1057 6
		if (mrtdebug & DEBUG_MFC)
			log(LOG_DEBUG, "add_mfc update o %x g %x p %x\n",
			    ntohl(mfccp->mfcc_origin.s_addr),
			    ntohl(mfccp->mfcc_mcastgrp.s_addr),
			    mfccp->mfcc_parent);

a1058 1

d1072 1
a1072 1
			if (nstl++)
d1079 1
a1079 7

			if (mrtdebug & DEBUG_MFC)
				log(LOG_DEBUG, "add_mfc o %x g %x "
				    "p %x dbg %p\n",
				    ntohl(mfccp->mfcc_origin.s_addr),
				    ntohl(mfccp->mfcc_mcastgrp.s_addr),
				    mfccp->mfcc_parent, rt->mfc_stall);
a1106 6
		if (mrtdebug & DEBUG_MFC)
			log(LOG_DEBUG, "add_mfc no upcall o %x g %x p %x\n",
			    ntohl(mfccp->mfcc_origin.s_addr),
			    ntohl(mfccp->mfcc_mcastgrp.s_addr),
			    mfccp->mfcc_parent);

a1163 5
	if (mrtdebug & DEBUG_MFC)
		log(LOG_DEBUG, "del_mfc origin %x mcastgrp %x\n",
		    ntohl(mfccp->mfcc_origin.s_addr),
		    ntohl(mfccp->mfcc_mcastgrp.s_addr));

a1215 4
	if (mrtdebug & DEBUG_FORWARD)
		log(LOG_DEBUG, "ip_mforward: src %x, dst %x, ifp %p\n",
		    ntohl(ip->ip_src.s_addr), ntohl(ip->ip_dst.s_addr), ifp);

a1265 5
		if (mrtdebug & (DEBUG_FORWARD | DEBUG_MFC))
			log(LOG_DEBUG, "ip_mforward: no rte s %x g %x\n",
			    ntohl(ip->ip_src.s_addr),
			    ntohl(ip->ip_dst.s_addr));

a1425 6
			if (mrtdebug & DEBUG_EXPIRE)
				log(LOG_DEBUG,
				    "expire_upcalls: expiring (%x %x)\n",
				    ntohl(rt->mfc_origin.s_addr),
				    ntohl(rt->mfc_mcastgrp.s_addr));

a1450 4
		if (mrtdebug & DEBUG_FORWARD)
			log(LOG_DEBUG, "wrong if: ifp %p vifi %d vififp %p\n",
			    ifp, vifi,
			    vifi >= numvifs ? 0 : viftable[vifi].v_ifp);
a1600 3
	if (mrtdebug & DEBUG_PIM)
		log(LOG_DEBUG, "pim_register_send: ");

a1707 3
		if (mrtdebug & DEBUG_PIM)
			log(LOG_WARNING, "mcast: pim_register_send_upcall: "
			    "ip_mrouter socket queue full");
a1861 2
		if (mrtdebug & DEBUG_PIM)
			log(LOG_DEBUG, "pim_input: invalid checksum");
a1894 3
			if (mrtdebug & DEBUG_PIM)
				log(LOG_DEBUG, "pim_input: register vif "
				    "not set: %d\n", reg_vif_num);
a1915 8
		if (mrtdebug & DEBUG_PIM) {
			log(LOG_DEBUG, "pim_input[register], encap_ip: "
			    "%lx -> %lx, encap_ip len %d\n",
			    (u_long)ntohl(encap_ip->ip_src.s_addr),
			    (u_long)ntohl(encap_ip->ip_dst.s_addr),
			    ntohs(encap_ip->ip_len));
		}

a1918 5
			if (mrtdebug & DEBUG_PIM) {
				log(LOG_DEBUG, "pim_input: invalid IP version"
				    " (%d) of the inner packet\n",
				    encap_ip->ip_v);
			}
a1925 5
			if (mrtdebug & DEBUG_PIM)
				log(LOG_DEBUG,
				    "pim_input: inner packet of register is"
				    " not multicast %lx\n",
				    (u_long)ntohl(encap_ip->ip_dst.s_addr));
a1978 8
		if (mrtdebug & DEBUG_PIM) {
			log(LOG_DEBUG,
			    "pim_input: forwarding decapsulated register: "
			    "src %lx, dst %lx, vif %d\n",
			    (u_long)ntohl(encap_ip->ip_src.s_addr),
			    (u_long)ntohl(encap_ip->ip_dst.s_addr),
			    reg_vif_num);
		}
@


1.87
log
@Kill another tunnel leftover and keep PIM stuff inside #ifdef PIM.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.86 2015/11/12 18:19:27 mpi Exp $	*/
d1162 1
a1162 2
			rt = (struct mfc *)malloc(sizeof(*rt), M_MRTABLE,
			    M_NOWAIT);
d1329 1
a1329 2
		rte = (struct rtdetq *)malloc(sizeof(*rte),
		    M_MRTABLE, M_NOWAIT);
d1367 1
a1367 2
			rt = (struct mfc *)malloc(sizeof(*rt),
			    M_MRTABLE, M_NOWAIT);
@


1.86
log
@Kill another leftover from the tunnel support removal and add more PIM.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.85 2015/11/12 16:58:45 mpi Exp $	*/
a214 2
#endif /* PIM */

d217 1
a217 1
 * Private variables.
d219 3
a222 1
static int have_encap_tunnel = 0;
a224 4
 * whether or not special PIM assert processing is enabled.
 */
static int pim_assert;
/*
d562 1
d564 1
d608 3
d612 1
a612 1
	mrt_api_config = 0;
a631 3

	/* Reset de-encapsulation cache. */
	have_encap_tunnel = 0;
@


1.85
log
@Sync headers and get rid of #ifdef MROUTING.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.84 2015/11/12 16:48:53 mpi Exp $	*/
a94 1
#define IP_MULTICASTOPTS 0
a138 2
int set_assert(struct mbuf *);
int get_assert(struct mbuf *);
d164 2
a167 30
/*
 * 'Interfaces' associated with decapsulator (so we can tell
 * packets that went through it from ones that get reflected
 * by a broken gateway).  These interfaces are never linked into
 * the system ifnet list & no routes point to them.  I.e., packets
 * can't be sent this way.  They only exist as a placeholder for
 * multicast source verification.
 */
#if 0
struct ifnet multicast_decap_if[MAXVIFS];
#endif

#define	ENCAP_TTL	64
#define	ENCAP_PROTO	IPPROTO_IPIP	/* 4 */

/* prototype IP hdr for encapsulated packets */
struct ip multicast_encap_iphdr = {
#if BYTE_ORDER == LITTLE_ENDIAN
	sizeof(struct ip) >> 2, IPVERSION,
#else
	IPVERSION, sizeof(struct ip) >> 2,
#endif
	0,				/* tos */
	sizeof(struct ip),		/* total length */
	0,				/* id */
	0,				/* frag offset */
	ENCAP_TTL, ENCAP_PROTO,
	0,				/* checksum */
};

a180 1

d185 1
d199 1
a199 1
	ENCAP_TTL,
d319 1
d323 1
d354 1
d358 1
d681 1
d710 1
d737 1
d742 1
d1526 1
a1538 1
#ifdef PIM
a1540 1
#endif
d1589 1
d1660 1
a1660 1
	ip_output(m, NULL, NULL, IP_FORWARDING|IP_MULTICASTOPTS, &imo, NULL, 0);
@


1.84
log
@Remove VIFF_TUNNEL leftovers, tunnels aren't supported since 2006.

Even pimd(8) no longer support them.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.83 2015/11/12 16:34:13 mpi Exp $	*/
a69 2
#include <sys/errno.h>
#include <sys/time.h>
d76 2
a85 1
#include <netinet/udp.h>
d89 1
a93 4

#include <sys/stdarg.h>

#include <crypto/siphash.h>
@


1.83
log
@Fix PIM build.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.82 2015/09/12 13:34:12 mpi Exp $	*/
a160 1
void encap_send(struct ip *, struct vif *, struct mbuf *);
d847 4
a850 1
	/* Find the interface with an address in AF_INET family. */
a866 3
	if (vifcp->vifc_flags & VIFF_TUNNEL) {
		/* tunnels are no longer supported use gif(4) instead */
		return (EOPNOTSUPP);
d868 1
a868 1
	} else if (vifcp->vifc_flags & VIFF_REGISTER) {
d881 1
d883 1
a883 1
	} else {
a921 9
	if (mrtdebug)
		log(LOG_DEBUG, "add_vif #%d, lcladdr %x, %s %x, "
		    "thresh %x\n",
		    vifcp->vifc_vifi,
		    ntohl(vifcp->vifc_lcl_addr.s_addr),
		    (vifcp->vifc_flags & VIFF_TUNNEL) ? "rmtaddr" : "mask",
		    ntohl(vifcp->vifc_rmt_addr.s_addr),
		    vifcp->vifc_threshold);

a930 3
	if (vifp->v_flags & VIFF_TUNNEL) {
		/* empty */
	} else if (vifp->v_flags & VIFF_REGISTER) {
d932 1
d934 1
d936 1
a936 1
	} else {
a1540 10
/*
 * Macro to send packet on vif.
 */
#define MC_SEND(ip, vifp, m) do {					\
	if ((vifp)->v_flags & VIFF_TUNNEL)				\
		encap_send((ip), (vifp), (m));				\
	else								\
		phyint_send((ip), (vifp), (m));				\
} while (/*CONSTCOND*/ 0)

d1647 1
a1647 1
			MC_SEND(ip, vifp, m);
d1673 1
a1673 1
encap_send(struct ip *ip, struct vif *vifp, struct mbuf *m)
d1675 2
a1676 5
	struct mbuf *mb_copy;
	struct ip *ip_copy;
	int i, len = ntohs(ip->ip_len) + sizeof(multicast_encap_iphdr);

	in_proto_cksum_out(m, NULL);
d1679 2
a1680 3
	 * copy the old packet & pullup its IP header into the
	 * new mbuf so we can modify it.  Try to fill the new
	 * mbuf since if we don't the ethernet driver will.
d1682 3
a1684 6
	MGETHDR(mb_copy, M_DONTWAIT, MT_DATA);
	if (mb_copy == NULL)
		return;
	mb_copy->m_data += max_linkhdr;
	mb_copy->m_pkthdr.len = len;
	mb_copy->m_len = sizeof(multicast_encap_iphdr);
d1686 2
a1687 62
	if ((mb_copy->m_next = m_copym(m, 0, M_COPYALL, M_NOWAIT)) == NULL) {
		m_freem(mb_copy);
		return;
	}
	i = MHLEN - max_linkhdr;
	if (i > len)
		i = len;
	mb_copy = m_pullup(mb_copy, i);
	if (mb_copy == NULL)
		return;

	/*
	 * fill in the encapsulating IP header.
	 */
	ip_copy = mtod(mb_copy, struct ip *);
	*ip_copy = multicast_encap_iphdr;
	ip_copy->ip_id = htons(ip_randomid());
	ip_copy->ip_len = htons(len);
	ip_copy->ip_src = vifp->v_lcl_addr;
	ip_copy->ip_dst = vifp->v_rmt_addr;

	/*
	 * turn the encapsulated IP header back into a valid one.
	 */
	ip = (struct ip *)((caddr_t)ip_copy + sizeof(multicast_encap_iphdr));
	--ip->ip_ttl;
	ip->ip_sum = 0;
	mb_copy->m_data += sizeof(multicast_encap_iphdr);
	ip->ip_sum = in_cksum(mb_copy, ip->ip_hl << 2);
	mb_copy->m_data -= sizeof(multicast_encap_iphdr);

	send_packet(vifp, mb_copy);
}

void
send_packet(struct vif *vifp, struct mbuf *m)
{
	int error;
	int s = splsoftnet();

	if (vifp->v_flags & VIFF_TUNNEL) {
		/* If tunnel options */
		ip_output(m, NULL, &vifp->v_route, IP_FORWARDING, NULL, NULL,
		    0);
	} else {
		/*
		 * if physical interface option, extract the options
		 * and then send
		 */
		struct ip_moptions imo;

		imo.imo_ifidx = vifp->v_ifp->if_index;
		imo.imo_ttl = mtod(m, struct ip *)->ip_ttl - IPTTLDEC;
		imo.imo_loop = 1;

		error = ip_output(m, NULL, NULL,
		    IP_FORWARDING | IP_MULTICASTOPTS, &imo, NULL, 0);

		if (mrtdebug & DEBUG_XMIT)
			log(LOG_DEBUG, "phyint_send on vif %ld err %d\n",
			    (long)(vifp - viftable), error);
	}
@


1.82
log
@Introduce if_input_local() a function to feed local traffic back to
the protocol queues.

It basically does what looutput() was doing but having a generic
function will allow us to get rid of the loopback hack overwwritting
the rt_ifp field of RTF_LOCAL routes.

ok mikeb@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.81 2015/09/01 21:24:04 bluhm Exp $	*/
d2204 1
a2204 1
		if_input_local(vifp, m, dst->sin_family);
@


1.81
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.80 2015/08/24 14:00:29 bluhm Exp $	*/
d2204 1
a2204 1
		looutput(vifp, m, sintosa(&dst), NULL);
@


1.80
log
@In kernel initialize struct sockaddr_in and sockaddr_in6 to zero
everywhere to avoid passing around pointers to uninitialized stack
memory.  While there, fix the call to in6_recoverscope() in
fill_drlist().
OK deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.79 2015/07/15 17:55:08 deraadt Exp $	*/
d2204 1
a2204 1
		looutput(vifp, m, (struct sockaddr *)&dst, NULL);
@


1.79
log
@rename mbuf ** parameter from m to mp, to match other similar code
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.78 2015/06/30 15:30:17 mpi Exp $	*/
d892 1
d947 1
@


1.78
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.77 2015/02/09 12:18:19 claudio Exp $	*/
d329 1
a329 1
ip_mrouter_set(struct socket *so, int optname, struct mbuf **m)
d338 1
a338 1
			error = ip_mrouter_init(so, *m);
d344 1
a344 1
			error = add_vif(*m);
d347 1
a347 1
			error = del_vif(*m);
d350 1
a350 1
			error = add_mfc(*m);
d353 1
a353 1
			error = del_mfc(*m);
d356 1
a356 1
			error = set_assert(*m);
d359 1
a359 1
			error = set_api_config(*m);
d366 2
a367 2
	if (*m)
		m_free(*m);
d375 1
a375 1
ip_mrouter_get(struct socket *so, int optname, struct mbuf **m)
d382 1
a382 1
		*m = m_get(M_WAIT, MT_SOOPTS);
d386 1
a386 1
			error = get_version(*m);
d389 1
a389 1
			error = get_assert(*m);
d392 1
a392 1
			error = get_api_support(*m);
d395 1
a395 1
			error = get_api_config(*m);
d403 1
a403 1
			m_free(*m);
@


1.77
log
@Implement 2 sysctl to retrieve the multicast forwarding cache (mfc) and the
virtual interface table (vif). Will be used by netstat soon.
Looked over by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.76 2015/02/08 03:42:24 claudio Exp $	*/
d1373 1
a1373 1
		mb0 = m_copy(m, 0, M_COPYALL);
d1414 1
a1414 1
			mm = m_copy(m, 0, hlen);
d1611 1
a1611 1
				struct mbuf *mm = m_copy(m, 0, hlen);
d1682 1
a1682 1
	mb_copy = m_copy(m, 0, M_COPYALL);
d1711 1
a1711 1
	if ((mb_copy->m_next = m_copy(m, 0, M_COPYALL)) == NULL) {
d1832 1
a1832 1
	mb_copy = m_copy(m, 0, M_COPYALL);
d2177 1
a2177 1
		mcp = m_copy(m, 0, iphlen + PIM_REG_MINLEN);
@


1.76
log
@De-static to make ddb hangman harder. OK phessler, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.75 2015/02/07 07:56:41 dlg Exp $	*/
d474 87
@


1.75
log
@mechanical conversion of this code to using siphash instead of some xors.

ok tedu@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.74 2014/12/17 09:57:13 mpi Exp $	*/
d139 18
a156 17
static int get_sg_cnt(struct sioc_sg_req *);
static int get_vif_cnt(struct sioc_vif_req *);
static int ip_mrouter_init(struct socket *, struct mbuf *);
static int get_version(struct mbuf *);
static int set_assert(struct mbuf *);
static int get_assert(struct mbuf *);
static int add_vif(struct mbuf *);
static int del_vif(struct mbuf *);
static void update_mfc_params(struct mfc *, struct mfcctl2 *);
static void init_mfc_params(struct mfc *, struct mfcctl2 *);
static void expire_mfc(struct mfc *);
static int add_mfc(struct mbuf *);
static int del_mfc(struct mbuf *);
static int set_api_config(struct mbuf *); /* chose API capabilities */
static int get_api_support(struct mbuf *);
static int get_api_config(struct mbuf *);
static int socket_send(struct socket *, struct mbuf *,
d158 5
a162 5
static void expire_upcalls(void *);
static int ip_mdq(struct mbuf *, struct ifnet *, struct mfc *);
static void phyint_send(struct ip *, struct vif *, struct mbuf *);
static void encap_send(struct ip *, struct vif *, struct mbuf *);
static void send_packet(struct vif *, struct mbuf *);
d165 1
a165 1
static int pim_register_send(struct ip *, struct vif *,
d167 1
a167 1
static int pim_register_send_rp(struct ip *, struct vif *,
d169 1
a169 1
static int pim_register_send_upcall(struct ip *, struct vif *,
d171 1
a171 1
static struct mbuf *pim_register_prepare(struct ip *, struct mbuf *);
d438 1
a438 1
static int
d462 1
a462 1
static int
d481 1
a481 1
static int
d616 1
a616 1
static int
d629 1
a629 1
static int
d645 1
a645 1
static int
d658 1
a658 1
static int
d700 1
a700 1
static int
d718 1
a718 1
static int
d738 1
a738 1
static int
d871 1
a871 1
static int
d942 1
a942 1
static void
d963 1
a963 1
static void
d978 1
a978 1
static void
d996 1
a996 1
static int
d1135 1
a1135 1
static int
d1179 1
a1179 1
static int
d1415 1
a1415 1
static void
d1454 1
a1454 1
static int
d1584 1
a1584 1
static void
d1603 1
a1603 1
static void
d1658 1
a1658 1
static void
d1693 1
a1693 1
static int
d1733 1
a1733 1
static struct mbuf *
d1776 1
a1776 1
static int
d1826 1
a1826 1
static int
@


1.74
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.73 2014/12/17 09:45:59 mpi Exp $	*/
d97 2
d116 3
a118 3
#define	MFCHASH(a, g)							\
	((((a).s_addr >> 20) ^ ((a).s_addr >> 10) ^ (a).s_addr ^	\
	    ((g).s_addr >> 20) ^ ((g).s_addr >> 10) ^ (g).s_addr) & mfchash)
d121 1
d288 1
d290 2
a291 1
	LIST_FOREACH(rt, &mfchashtbl[MFCHASH(*o, *g)], mfc_hash) {
d507 1
d519 12
@


1.73
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.72 2014/12/05 15:50:04 mpi Exp $	*/
d1657 2
a1658 2
		imo.imo_multicast_ttl = mtod(m, struct ip *)->ip_ttl - IPTTLDEC;
		imo.imo_multicast_loop = 1;
@


1.72
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.71 2014/09/30 12:54:22 jsg Exp $	*/
d1656 1
a1656 1
		imo.imo_multicast_ifp = vifp->v_ifp;
@


1.71
log
@add back the sys/sysctl.h include removed in rev 1.60
fixes the kernel build when PIM is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.70 2014/08/14 09:01:47 mpi Exp $	*/
d79 1
@


1.70
log
@No need for raw_cb.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.69 2014/08/14 08:22:38 mpi Exp $	*/
d75 1
@


1.69
log
@Kill MRT_{ADD,DEL}_BW_UPCALL interfaces and the bandwidth monitoring
code that comes with them.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.68 2014/07/22 11:06:10 mpi Exp $	*/
a78 1
#include <net/raw_cb.h>
@


1.68
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.67 2014/07/12 18:44:23 tedu Exp $	*/
a158 15
/*
 * Bandwidth monitoring
 */
static void free_bw_list(struct bw_meter *);
static int add_bw_upcall(struct mbuf *);
static int del_bw_upcall(struct mbuf *);
static void bw_meter_receive_packet(struct bw_meter *, int , struct timeval *);
static void bw_meter_prepare_upcall(struct bw_meter *, struct timeval *);
static void bw_upcalls_send(void);
static void schedule_bw_meter(struct bw_meter *, struct timeval *);
static void unschedule_bw_meter(struct bw_meter *);
static void bw_meter_process(void);
static void expire_bw_upcalls_send(void *);
static void expire_bw_meter_process(void *);

a198 22
/*
 * Bandwidth meter variables and constants
 */

/*
 * Pending timeouts are stored in a hash table, the key being the
 * expiration time. Periodically, the entries are analysed and processed.
 */
#define BW_METER_BUCKETS	1024
static struct bw_meter *bw_meter_timers[BW_METER_BUCKETS];
struct timeout bw_meter_ch;
#define BW_METER_PERIOD 1000	/* periodical handling of bw meters (in ms) */

/*
 * Pending upcalls are stored in a vector which is flushed when
 * full, or periodically
 */
static struct bw_upcall	bw_upcalls[BW_UPCALLS_MAX];
static u_int	bw_upcalls_n; /* # of pending upcalls */
struct timeout	bw_upcalls_ch;
#define BW_UPCALLS_PERIOD 1000	/* periodical flush of bw upcalls (in ms) */

d271 1
a271 2
					  MRT_MFC_RP |
					  MRT_MFC_BW_UPCALL);
a353 6
		case MRT_ADD_BW_UPCALL:
			error = add_bw_upcall(*m);
			break;
		case MRT_DEL_BW_UPCALL:
			error = del_bw_upcall(*m);
			break;
a507 6
	timeout_set(&bw_upcalls_ch, expire_bw_upcalls_send, NULL);
	timeout_add_msec(&bw_upcalls_ch, BW_UPCALLS_PERIOD);

	timeout_set(&bw_meter_ch, expire_bw_meter_process, NULL);
	timeout_add_msec(&bw_meter_ch, BW_METER_PERIOD);

a538 2
	timeout_del(&bw_upcalls_ch);
	timeout_del(&bw_meter_ch);
a556 3
	bw_upcalls_n = 0;
	memset(bw_meter_timers, 0, sizeof(bw_meter_timers));

a962 2
	free_bw_list(rt->mfc_bw_meter);

a1101 1
			rt->mfc_bw_meter = NULL;
a1151 6
	/*
	 * free the bw_meter entries
	 */
	free_bw_list(rt->mfc_bw_meter);
	rt->mfc_bw_meter = NULL;

a1354 2
			rt->mfc_bw_meter = NULL;

a1415 10
			/*
			 * free the bw_meter entries
			 */
			while (rt->mfc_bw_meter != NULL) {
				struct bw_meter *x = rt->mfc_bw_meter;

				rt->mfc_bw_meter = x->bm_mfc_next;
				free(x, M_BWMETER, 0);
			}

a1560 12
	/*
	 * Perform upcall-related bw measuring.
	 */
	if (rt->mfc_bw_meter != NULL) {
		struct bw_meter *x;
		struct timeval now;

		microtime(&now);
		for (x = rt->mfc_bw_meter; x != NULL; x = x->bm_mfc_next)
			bw_meter_receive_packet(x, plen, &now);
	}

a1667 578

/*
 * Code for bandwidth monitors
 */

/*
 * Define common interface for timeval-related methods
 */
#define	BW_TIMEVALCMP(tvp, uvp, cmp) timercmp((tvp), (uvp), cmp)
#define	BW_TIMEVALDECR(vvp, uvp) timersub((vvp), (uvp), (vvp))
#define	BW_TIMEVALADD(vvp, uvp) timeradd((vvp), (uvp), (vvp))

static uint32_t
compute_bw_meter_flags(struct bw_upcall *req)
{
	uint32_t flags = 0;

	if (req->bu_flags & BW_UPCALL_UNIT_PACKETS)
		flags |= BW_METER_UNIT_PACKETS;
	if (req->bu_flags & BW_UPCALL_UNIT_BYTES)
		flags |= BW_METER_UNIT_BYTES;
	if (req->bu_flags & BW_UPCALL_GEQ)
		flags |= BW_METER_GEQ;
	if (req->bu_flags & BW_UPCALL_LEQ)
		flags |= BW_METER_LEQ;

	return (flags);
}

/*
 * Add a bw_meter entry
 */
static int
add_bw_upcall(struct mbuf *m)
{
	int s;
	struct mfc *mfc;
	struct timeval delta = { BW_UPCALL_THRESHOLD_INTERVAL_MIN_SEC,
	    BW_UPCALL_THRESHOLD_INTERVAL_MIN_USEC };
	struct timeval now;
	struct bw_meter *x;
	uint32_t flags;
	struct bw_upcall *req;

	if (m == NULL || m->m_len < sizeof(struct bw_upcall))
		return (EINVAL);

	req = mtod(m, struct bw_upcall *);

	if (!(mrt_api_config & MRT_MFC_BW_UPCALL))
		return (EOPNOTSUPP);

	/* Test if the flags are valid */
	if (!(req->bu_flags & (BW_UPCALL_UNIT_PACKETS | BW_UPCALL_UNIT_BYTES)))
		return (EINVAL);
	if (!(req->bu_flags & (BW_UPCALL_GEQ | BW_UPCALL_LEQ)))
		return (EINVAL);
	if ((req->bu_flags & (BW_UPCALL_GEQ | BW_UPCALL_LEQ))
	    == (BW_UPCALL_GEQ | BW_UPCALL_LEQ))
		return (EINVAL);

	/* Test if the threshold time interval is valid */
	if (BW_TIMEVALCMP(&req->bu_threshold.b_time, &delta, <))
		return (EINVAL);

	flags = compute_bw_meter_flags(req);

	/* Find if we have already same bw_meter entry */
	s = splsoftnet();
	mfc = mfc_find(&req->bu_src, &req->bu_dst);
	if (mfc == NULL) {
		splx(s);
		return (EADDRNOTAVAIL);
	}
	for (x = mfc->mfc_bw_meter; x != NULL; x = x->bm_mfc_next) {
		if ((BW_TIMEVALCMP(&x->bm_threshold.b_time,
		    &req->bu_threshold.b_time, ==)) &&
		    (x->bm_threshold.b_packets ==
		    req->bu_threshold.b_packets) &&
		    (x->bm_threshold.b_bytes == req->bu_threshold.b_bytes) &&
		    (x->bm_flags & BW_METER_USER_FLAGS) == flags)  {
			splx(s);
			return (0);	/* XXX Already installed */
		}
	}

	/* Allocate the new bw_meter entry */
	x = (struct bw_meter *)malloc(sizeof(*x), M_BWMETER, M_NOWAIT);
	if (x == NULL) {
		splx(s);
		return (ENOBUFS);
	}

	/* Set the new bw_meter entry */
	x->bm_threshold.b_time = req->bu_threshold.b_time;
	microtime(&now);
	x->bm_start_time = now;
	x->bm_threshold.b_packets = req->bu_threshold.b_packets;
	x->bm_threshold.b_bytes = req->bu_threshold.b_bytes;
	x->bm_measured.b_packets = 0;
	x->bm_measured.b_bytes = 0;
	x->bm_flags = flags;
	x->bm_time_next = NULL;
	x->bm_time_hash = BW_METER_BUCKETS;

	/* Add the new bw_meter entry to the front of entries for this MFC */
	x->bm_mfc = mfc;
	x->bm_mfc_next = mfc->mfc_bw_meter;
	mfc->mfc_bw_meter = x;
	schedule_bw_meter(x, &now);
	splx(s);

	return (0);
}

static void
free_bw_list(struct bw_meter *list)
{
	while (list != NULL) {
		struct bw_meter *x = list;

		list = list->bm_mfc_next;
		unschedule_bw_meter(x);
		free(x, M_BWMETER, 0);
	}
}

/*
 * Delete one or multiple bw_meter entries
 */
static int
del_bw_upcall(struct mbuf *m)
{
	int s;
	struct mfc *mfc;
	struct bw_meter *x;
	struct bw_upcall *req;

	if (m == NULL || m->m_len < sizeof(struct bw_upcall))
		return (EINVAL);

	req = mtod(m, struct bw_upcall *);

	if (!(mrt_api_config & MRT_MFC_BW_UPCALL))
		return (EOPNOTSUPP);

	s = splsoftnet();
	/* Find the corresponding MFC entry */
	mfc = mfc_find(&req->bu_src, &req->bu_dst);
	if (mfc == NULL) {
		splx(s);
		return (EADDRNOTAVAIL);
	} else if (req->bu_flags & BW_UPCALL_DELETE_ALL) {
		/* Delete all bw_meter entries for this mfc */
		struct bw_meter *list;

		list = mfc->mfc_bw_meter;
		mfc->mfc_bw_meter = NULL;
		free_bw_list(list);
		splx(s);
		return (0);
	} else {	/* Delete a single bw_meter entry */
		struct bw_meter *prev;
		uint32_t flags = 0;

		flags = compute_bw_meter_flags(req);

		/* Find the bw_meter entry to delete */
		for (prev = NULL, x = mfc->mfc_bw_meter; x != NULL;
		    prev = x, x = x->bm_mfc_next) {
			if ((BW_TIMEVALCMP(&x->bm_threshold.b_time,
			    &req->bu_threshold.b_time, ==)) &&
			    (x->bm_threshold.b_packets ==
			    req->bu_threshold.b_packets) &&
			    (x->bm_threshold.b_bytes ==
			    req->bu_threshold.b_bytes) &&
			    (x->bm_flags & BW_METER_USER_FLAGS) == flags)
				break;
		}
		if (x != NULL) { /* Delete entry from the list for this MFC */
			if (prev != NULL) {
				/* remove from middle */
				prev->bm_mfc_next = x->bm_mfc_next;
			} else {
				/* new head of list */
				x->bm_mfc->mfc_bw_meter = x->bm_mfc_next;
			}

			unschedule_bw_meter(x);
			splx(s);
			/* Free the bw_meter entry */
			free(x, M_BWMETER, 0);
			return (0);
		} else {
			splx(s);
			return (EINVAL);
		}
	}
	/* NOTREACHED */
}

/*
 * Perform bandwidth measurement processing that may result in an upcall
 */
static void
bw_meter_receive_packet(struct bw_meter *x, int plen, struct timeval *nowp)
{
	struct timeval delta;

	delta = *nowp;
	BW_TIMEVALDECR(&delta, &x->bm_start_time);

	if (x->bm_flags & BW_METER_GEQ) {
		/* Processing for ">=" type of bw_meter entry */
		if (BW_TIMEVALCMP(&delta, &x->bm_threshold.b_time, >)) {
			/* Reset the bw_meter entry */
			x->bm_start_time = *nowp;
			x->bm_measured.b_packets = 0;
			x->bm_measured.b_bytes = 0;
			x->bm_flags &= ~BW_METER_UPCALL_DELIVERED;
		}

		/* Record that a packet is received */
		x->bm_measured.b_packets++;
		x->bm_measured.b_bytes += plen;

		/* Test if we should deliver an upcall */
		if (!(x->bm_flags & BW_METER_UPCALL_DELIVERED)) {
			if (((x->bm_flags & BW_METER_UNIT_PACKETS) &&
			    (x->bm_measured.b_packets >=
			    x->bm_threshold.b_packets)) ||
			    ((x->bm_flags & BW_METER_UNIT_BYTES) &&
			    (x->bm_measured.b_bytes >=
			    x->bm_threshold.b_bytes))) {
				/* Prepare an upcall for delivery */
				bw_meter_prepare_upcall(x, nowp);
				x->bm_flags |= BW_METER_UPCALL_DELIVERED;
			}
		}
	} else if (x->bm_flags & BW_METER_LEQ) {
		/* Processing for "<=" type of bw_meter entry */
		if (BW_TIMEVALCMP(&delta, &x->bm_threshold.b_time, >)) {
			/*
			 * We are behind time with the multicast forwarding
			 * table scanning for "<=" type of bw_meter entries,
			 * so test now if we should deliver an upcall.
			 */
			if (((x->bm_flags & BW_METER_UNIT_PACKETS) &&
			    (x->bm_measured.b_packets <=
			    x->bm_threshold.b_packets)) ||
			    ((x->bm_flags & BW_METER_UNIT_BYTES) &&
			    (x->bm_measured.b_bytes <=
			    x->bm_threshold.b_bytes))) {
				/* Prepare an upcall for delivery */
				bw_meter_prepare_upcall(x, nowp);
			}
			/* Reschedule the bw_meter entry */
			unschedule_bw_meter(x);
			schedule_bw_meter(x, nowp);
		}

		/* Record that a packet is received */
		x->bm_measured.b_packets++;
		x->bm_measured.b_bytes += plen;

		/* Test if we should restart the measuring interval */
		if ((x->bm_flags & BW_METER_UNIT_PACKETS &&
		    x->bm_measured.b_packets <= x->bm_threshold.b_packets) ||
		    (x->bm_flags & BW_METER_UNIT_BYTES &&
		    x->bm_measured.b_bytes <= x->bm_threshold.b_bytes)) {
			/* Don't restart the measuring interval */
		} else {
			/* Do restart the measuring interval */
			/*
			 * XXX: note that we don't unschedule and schedule,
			 * because this might be too much overhead per packet.
			 * Instead, when we process all entries for a given
			 * timer hash bin, we check whether it is really a
			 * timeout. If not, we reschedule at that time.
			 */
			x->bm_start_time = *nowp;
			x->bm_measured.b_packets = 0;
			x->bm_measured.b_bytes = 0;
			x->bm_flags &= ~BW_METER_UPCALL_DELIVERED;
		}
	}
}

/*
 * Prepare a bandwidth-related upcall
 */
static void
bw_meter_prepare_upcall(struct bw_meter *x, struct timeval *nowp)
{
	struct timeval delta;
	struct bw_upcall *u;

	/* Compute the measured time interval */
	delta = *nowp;
	BW_TIMEVALDECR(&delta, &x->bm_start_time);

	/* If there are too many pending upcalls, deliver them now */
	if (bw_upcalls_n >= BW_UPCALLS_MAX)
		bw_upcalls_send();

	/* Set the bw_upcall entry */
	u = &bw_upcalls[bw_upcalls_n++];
	u->bu_src = x->bm_mfc->mfc_origin;
	u->bu_dst = x->bm_mfc->mfc_mcastgrp;
	u->bu_threshold.b_time = x->bm_threshold.b_time;
	u->bu_threshold.b_packets = x->bm_threshold.b_packets;
	u->bu_threshold.b_bytes = x->bm_threshold.b_bytes;
	u->bu_measured.b_time = delta;
	u->bu_measured.b_packets = x->bm_measured.b_packets;
	u->bu_measured.b_bytes = x->bm_measured.b_bytes;
	u->bu_flags = 0;
	if (x->bm_flags & BW_METER_UNIT_PACKETS)
		u->bu_flags |= BW_UPCALL_UNIT_PACKETS;
	if (x->bm_flags & BW_METER_UNIT_BYTES)
		u->bu_flags |= BW_UPCALL_UNIT_BYTES;
	if (x->bm_flags & BW_METER_GEQ)
		u->bu_flags |= BW_UPCALL_GEQ;
	if (x->bm_flags & BW_METER_LEQ)
		u->bu_flags |= BW_UPCALL_LEQ;
}

/*
 * Send the pending bandwidth-related upcalls
 */
static void
bw_upcalls_send(void)
{
	struct mbuf *m;
	int len = bw_upcalls_n * sizeof(bw_upcalls[0]);
	struct sockaddr_in k_igmpsrc = { sizeof k_igmpsrc, AF_INET };
	static struct igmpmsg igmpmsg = {
	    0,			/* unused1 */
	    0,			/* unused2 */
	    IGMPMSG_BW_UPCALL,	/* im_msgtype */
	    0,			/* im_mbz  */
	    0,			/* im_vif  */
	    0,			/* unused3 */
	    { 0 },		/* im_src  */
	    { 0 } };		/* im_dst  */

	if (bw_upcalls_n == 0)
		return;		/* No pending upcalls */

	bw_upcalls_n = 0;

	/*
	 * Allocate a new mbuf, initialize it with the header and
	 * the payload for the pending calls.
	 */
	MGETHDR(m, M_DONTWAIT, MT_HEADER);
	if (m == NULL) {
		log(LOG_WARNING, "bw_upcalls_send: cannot allocate mbuf\n");
		return;
	}

	m->m_len = m->m_pkthdr.len = 0;
	m_copyback(m, 0, sizeof(struct igmpmsg), (caddr_t)&igmpmsg, M_NOWAIT);
	m_copyback(m, sizeof(struct igmpmsg), len, (caddr_t)&bw_upcalls[0],
	    M_NOWAIT);

	/*
	 * Send the upcalls
	 * XXX do we need to set the address in k_igmpsrc ?
	 */
	mrtstat.mrts_upcalls++;
	if (socket_send(ip_mrouter, m, &k_igmpsrc) < 0) {
		log(LOG_WARNING,
		    "bw_upcalls_send: ip_mrouter socket queue full\n");
		++mrtstat.mrts_upq_sockfull;
	}
}

/*
 * Compute the timeout hash value for the bw_meter entries
 */
#define	BW_METER_TIMEHASH(bw_meter, hash) do {				\
	struct timeval next_timeval = (bw_meter)->bm_start_time;	\
									\
	BW_TIMEVALADD(&next_timeval, &(bw_meter)->bm_threshold.b_time); \
	(hash) = next_timeval.tv_sec;					\
	if (next_timeval.tv_usec)					\
		(hash)++; /* XXX: make sure we don't timeout early */	\
	(hash) %= BW_METER_BUCKETS;					\
} while (/*CONSTCOND*/ 0)

/*
 * Schedule a timer to process periodically bw_meter entry of type "<="
 * by linking the entry in the proper hash bucket.
 */
static void
schedule_bw_meter(struct bw_meter *x, struct timeval *nowp)
{
	int time_hash;

	if (!(x->bm_flags & BW_METER_LEQ))
		return;	/* XXX: we schedule timers only for "<=" entries */

	/* Reset the bw_meter entry */
	x->bm_start_time = *nowp;
	x->bm_measured.b_packets = 0;
	x->bm_measured.b_bytes = 0;
	x->bm_flags &= ~BW_METER_UPCALL_DELIVERED;

	/* Compute the timeout hash value and insert the entry */
	BW_METER_TIMEHASH(x, time_hash);
	x->bm_time_next = bw_meter_timers[time_hash];
	bw_meter_timers[time_hash] = x;
	x->bm_time_hash = time_hash;
}

/*
 * Unschedule the periodic timer that processes bw_meter entry of type "<="
 * by removing the entry from the proper hash bucket.
 */
static void
unschedule_bw_meter(struct bw_meter *x)
{
	int time_hash;
	struct bw_meter *prev, *tmp;

	if (!(x->bm_flags & BW_METER_LEQ))
		return;	/* XXX: we schedule timers only for "<=" entries */

	/* Compute the timeout hash value and delete the entry */
	time_hash = x->bm_time_hash;
	if (time_hash >= BW_METER_BUCKETS)
		return;		/* Entry was not scheduled */

	for (prev = NULL, tmp = bw_meter_timers[time_hash];
	    tmp != NULL; prev = tmp, tmp = tmp->bm_time_next)
		if (tmp == x)
			break;

	if (tmp == NULL)
		panic("unschedule_bw_meter: bw_meter entry not found");

	if (prev != NULL)
		prev->bm_time_next = x->bm_time_next;
	else
		bw_meter_timers[time_hash] = x->bm_time_next;

	x->bm_time_next = NULL;
	x->bm_time_hash = BW_METER_BUCKETS;
}

/*
 * Process all "<=" type of bw_meter that should be processed now,
 * and for each entry prepare an upcall if necessary. Each processed
 * entry is rescheduled again for the (periodic) processing.
 *
 * This is run periodically (once per second normally). On each round,
 * all the potentially matching entries are in the hash slot that we are
 * looking at.
 */
static void
bw_meter_process()
{
	int s;
	static uint32_t last_tv_sec;	/* last time we processed this */

	uint32_t loops;
	int i;
	struct timeval now, process_endtime;

	microtime(&now);
	if (last_tv_sec == now.tv_sec)
		return;		/* nothing to do */

	loops = now.tv_sec - last_tv_sec;
	last_tv_sec = now.tv_sec;
	if (loops > BW_METER_BUCKETS)
		loops = BW_METER_BUCKETS;

	s = splsoftnet();
	/*
	 * Process all bins of bw_meter entries from the one after the last
	 * processed to the current one. On entry, i points to the last bucket
	 * visited, so we need to increment i at the beginning of the loop.
	 */
	for (i = (now.tv_sec - loops) % BW_METER_BUCKETS; loops > 0; loops--) {
		struct bw_meter *x, *tmp_list;

		if (++i >= BW_METER_BUCKETS)
			i = 0;

		/* Disconnect the list of bw_meter entries from the bin */
		tmp_list = bw_meter_timers[i];
		bw_meter_timers[i] = NULL;

		/* Process the list of bw_meter entries */
		while (tmp_list != NULL) {
			x = tmp_list;
			tmp_list = tmp_list->bm_time_next;

			/* Test if the time interval is over */
			process_endtime = x->bm_start_time;
			BW_TIMEVALADD(&process_endtime,
			    &x->bm_threshold.b_time);
			if (BW_TIMEVALCMP(&process_endtime, &now, >)) {
				/* Not yet: reschedule, but don't reset */
				int time_hash;

				BW_METER_TIMEHASH(x, time_hash);
				if (time_hash == i &&
				    process_endtime.tv_sec == now.tv_sec) {
					/*
					 * XXX: somehow the bin processing is
					 * a bit ahead of time. Put the entry
					 * in the next bin.
					 */
					if (++time_hash >= BW_METER_BUCKETS)
						time_hash = 0;
				}
				x->bm_time_next = bw_meter_timers[time_hash];
				bw_meter_timers[time_hash] = x;
				x->bm_time_hash = time_hash;

				continue;
			}

			/* Test if we should deliver an upcall */
			if (((x->bm_flags & BW_METER_UNIT_PACKETS) &&
			    (x->bm_measured.b_packets <=
			    x->bm_threshold.b_packets)) ||
			    ((x->bm_flags & BW_METER_UNIT_BYTES) &&
			    (x->bm_measured.b_bytes <=
			    x->bm_threshold.b_bytes))) {
				/* Prepare an upcall for delivery */
				bw_meter_prepare_upcall(x, &now);
			}

			/* Reschedule for next processing */
			schedule_bw_meter(x, &now);
		}
	}

	/* Send all upcalls that are pending delivery */
	bw_upcalls_send();

	splx(s);
}

/*
 * A periodic function for sending all upcalls that are pending delivery
 */
static void
expire_bw_upcalls_send(void *unused)
{
	int s;

	s = splsoftnet();
	bw_upcalls_send();
	splx(s);

	timeout_add_msec(&bw_upcalls_ch, BW_UPCALLS_PERIOD);
}

/*
 * A periodic function for periodic scanning of the multicast forwarding
 * table for processing all "<=" bw_meter entries.
 */
static void
expire_bw_meter_process(void *unused)
{
	if (mrt_api_config & MRT_MFC_BW_UPCALL)
		bw_meter_process();

	timeout_add_msec(&bw_meter_ch, BW_METER_PERIOD);
}

/*
 * End of bandwidth monitoring code
 */
@


1.67
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.66 2014/04/21 12:22:26 henning Exp $	*/
a81 1
#include <netinet/in_systm.h>
@


1.66
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.65 2014/04/21 11:10:54 henning Exp $	*/
d607 1
a607 1
	free(mfchashtbl, M_MRTABLE);
d1024 1
a1024 1
		free(rte, M_MRTABLE);
d1028 1
a1028 1
	free(rt, M_MRTABLE);
d1121 1
a1121 1
				free(rte, M_MRTABLE);
d1218 1
a1218 1
	free(rt, M_MRTABLE);
d1334 1
a1334 1
			free(rte, M_MRTABLE);
d1395 1
a1395 1
				free(rt, M_MRTABLE);
d1397 1
a1397 1
				free(rte, M_MRTABLE);
d1440 1
a1440 1
					free(rte, M_MRTABLE);
d1490 1
a1490 1
				free(x, M_BWMETER);
d1880 1
a1880 1
		free(x, M_BWMETER);
d1948 1
a1948 1
			free(x, M_BWMETER);
@


1.65
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.63 2013/10/27 20:57:39 deraadt Exp $	*/
d1735 2
a1736 1
		ip_output(m, NULL, &vifp->v_route, IP_FORWARDING, NULL, NULL);
d1749 1
a1749 1
		    IP_FORWARDING | IP_MULTICASTOPTS, &imo, NULL);
@


1.64
log
@bzero/bcmp -> memset/memcmp. ok matthew
@
text
@d1228 1
a1228 2
		if (sbappendaddr(&s->so_rcv, sintosa(src), mm,
		    (struct mbuf *)NULL) != 0) {
d1735 1
a1735 3
		ip_output(m, (struct mbuf *)NULL, &vifp->v_route,
		    IP_FORWARDING, (struct ip_moptions *)NULL,
		    (struct inpcb *)NULL);
d1747 2
a1748 3
		error = ip_output(m, (struct mbuf *)NULL, (struct route *)NULL,
		    IP_FORWARDING|IP_MULTICASTOPTS, &imo,
		    (struct inpcb *)NULL);
d2761 1
a2761 2
		looutput(vifp, m, (struct sockaddr *)&dst,
		    (struct rtentry *)NULL);
@


1.63
log
@delete UPCALL_TIMING debug code from a the dark ages
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.62 2013/10/23 15:12:42 mpi Exp $	*/
d546 1
a546 1
	bzero((caddr_t)nexpire, sizeof(nexpire));
d606 1
a606 1
	bzero((caddr_t)nexpire, sizeof(nexpire));
d611 1
a611 1
	bzero(bw_meter_timers, sizeof(bw_meter_timers));
d824 1
a824 1
			bzero(ifp, sizeof(*ifp));
d828 1
a828 1
			bzero(&vifp->v_route, sizeof(vifp->v_route));
d901 1
a901 1
	bzero((caddr_t)vifp, sizeof(*vifp));
d955 1
a955 1
			bzero((caddr_t)vifp, sizeof *vifp);
d1061 1
a1061 1
		bzero((caddr_t)&mfcctl2 + sizeof(struct mfcctl),
d1193 1
a1193 1
	bzero((caddr_t)&mfcctl2 + sizeof(struct mfcctl),
@


1.62
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.61 2013/05/02 11:54:10 mpi Exp $	*/
a147 3
#ifdef UPCALL_TIMING
static void collate(struct timeval *);
#endif
a356 4
#ifdef UPCALL_TIMING
u_int32_t upcall_data[51];
#endif /* UPCALL_TIMING */

a1120 3
#ifdef UPCALL_TIMING
				collate(&rte->t);
#endif /* UPCALL_TIMING */
a1170 25
#ifdef UPCALL_TIMING
/*
 * collect delay statistics on the upcalls
 */
static void
collate(struct timeval *t)
{
	u_int32_t d;
	struct timeval tp;
	u_int32_t delta;

	microtime(&tp);

	if (timercmp(t, &tp, <)) {
		TV_DELTA(tp, *t, delta);

		d = delta >> 10;
		if (d > 50)
			d = 50;

		++upcall_data[d];
	}
}
#endif /* UPCALL_TIMING */

a1311 5
#ifdef UPCALL_TIMING
		struct timeval tp;

		microtime(&tp);
#endif /* UPCALL_TIMING */
a1453 3
	#ifdef UPCALL_TIMING
		rte->t = tp;
	#endif /* UPCALL_TIMING */
@


1.61
log
@tedu broken Resource Reservation Protocol code that was ifdef RSVP_ISI.

ok deraadt@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.60 2013/03/28 16:45:16 tedu Exp $	*/
a81 1
#include <netinet/in_var.h>
@


1.60
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.59 2011/04/04 17:44:43 henning Exp $	*/
a132 6
#ifdef RSVP_ISI
u_int		rsvpdebug = 0;	  /* rsvp debug level   */
extern struct socket *ip_rsvpd;
extern int rsvp_on;
#endif /* RSVP_ISI */

a158 3
#ifdef RSVP_ISI
static int ip_mdq(struct mbuf *, struct ifnet *, struct mfc *, vifi_t);
#else
a159 1
#endif
a871 5
#ifdef RSVP_ISI
	vifp->v_rsvp_on = 0;
	vifp->v_rsvpd = NULL;
#endif /* RSVP_ISI */

a1125 3
#ifdef RSVP_ISI
					ip_mdq(rte->m, rte->ifp, rt, -1);
#else
a1126 1
#endif /* RSVP_ISI */
a1288 3
#ifdef RSVP_ISI
ip_mforward(struct mbuf *m, struct ifnet *ifp, struct ip_moptions *imo)
#else
a1289 1
#endif /* RSVP_ISI */
a1319 22
#ifdef RSVP_ISI
	if (imo && ((vifi = imo->imo_multicast_vif) < numvifs)) {
		if (ip->ip_ttl < MAXTTL) {
			/* compensate for -1 in *_send routines */
			ip->ip_ttl++;
		}
		if (rsvpdebug && ip->ip_p == IPPROTO_RSVP) {
			struct vif *vifp = viftable + vifi;
			printf("Sending IPPROTO_RSVP from %x to %x on "
			    "vif %d (%s%s)\n",
			    ntohl(ip->ip_src), ntohl(ip->ip_dst), vifi,
			    (vifp->v_flags & VIFF_TUNNEL) ? "tunnel on " : "",
			    vifp->v_ifp->if_xname);
		}
		return (ip_mdq(m, ifp, (struct mfc *)NULL, vifi));
	}
	if (rsvpdebug && ip->ip_p == IPPROTO_RSVP) {
		printf("Warning: IPPROTO_RSVP from %x to %x without "
		    "vif option\n", ntohl(ip->ip_src), ntohl(ip->ip_dst));
	}
#endif /* RSVP_ISI */

a1336 3
#ifdef RSVP_ISI
		return (ip_mdq(m, ifp, rt, -1));
#else
a1337 1
#endif /* RSVP_ISI */
a1556 3
#ifdef RSVP_ISI
ip_mdq(struct mbuf *m, struct ifnet *ifp, struct mfc *rt, vifi_t xmt_vif)
#else
a1557 1
#endif /* RSVP_ISI */
d1565 1
a1565 3
 * Macro to send packet on vif.  Since RSVP packets don't get counted on
 * input, they shouldn't get counted on output, so statistics keeping is
 * separate.
a1573 17
#ifdef RSVP_ISI
	/*
	 * If xmt_vif is not -1, send on only the requested vif.
	 *
	 * (since vifi_t is u_short, -1 becomes MAXUSHORT, which > numvifs.
	 */
	if (xmt_vif < numvifs) {
#ifdef PIM
		if (viftable[xmt_vif].v_flags & VIFF_REGISTER)
			pim_register_send(ip, viftable + xmt_vif, m, rt);
		else
#endif
		MC_SEND(ip, viftable + xmt_vif, m);
		return (1);
	}
#endif /* RSVP_ISI */

a1697 14
#ifdef RSVP_ISI
/*
 * check if a vif number is legal/ok. This is used by ip_output.
 */
int
legal_vif_num(int vif)
{
	if (vif >= 0 && vif < numvifs)
		return (1);
	else
		return (0);
}
#endif /* RSVP_ISI */

a1792 3
#ifdef RSVP_ISI
		imo.imo_multicast_vif = -1;
#endif
a1803 217

#ifdef RSVP_ISI
int
ip_rsvp_vif_init(struct socket *so, struct mbuf *m)
{
	int vifi, s;

	if (rsvpdebug)
		printf("ip_rsvp_vif_init: so_type = %d, pr_protocol = %d\n",
		    so->so_type, so->so_proto->pr_protocol);

	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
		return (EOPNOTSUPP);

	/* Check mbuf. */
	if (m == NULL || m->m_len != sizeof(int)) {
		return (EINVAL);
	}
	vifi = *(mtod(m, int *));

	if (rsvpdebug)
		printf("ip_rsvp_vif_init: vif = %d rsvp_on = %d\n",
		    vifi, rsvp_on);

	s = splsoftnet();

	/* Check vif. */
	if (!legal_vif_num(vifi)) {
		splx(s);
		return (EADDRNOTAVAIL);
	}

	/* Check if socket is available. */
	if (viftable[vifi].v_rsvpd != NULL) {
		splx(s);
		return (EADDRINUSE);
	}

	viftable[vifi].v_rsvpd = so;
	/* This may seem silly, but we need to be sure we don't over-increment
	 * the RSVP counter, in case something slips up.
	 */
	if (!viftable[vifi].v_rsvp_on) {
		viftable[vifi].v_rsvp_on = 1;
		rsvp_on++;
	}

	splx(s);
	return (0);
}

int
ip_rsvp_vif_done(struct socket *so, struct mbuf *m)
{
	int vifi, s;

	if (rsvpdebug)
		printf("ip_rsvp_vif_done: so_type = %d, pr_protocol = %d\n",
		    so->so_type, so->so_proto->pr_protocol);

	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
		return (EOPNOTSUPP);

	/* Check mbuf. */
	if (m == NULL || m->m_len != sizeof(int)) {
		return (EINVAL);
	}
	vifi = *(mtod(m, int *));

	s = splsoftnet();

	/* Check vif. */
	if (!legal_vif_num(vifi)) {
		splx(s);
		return (EADDRNOTAVAIL);
	}

	if (rsvpdebug)
		printf("ip_rsvp_vif_done: v_rsvpd = %x so = %x\n",
		    viftable[vifi].v_rsvpd, so);

	viftable[vifi].v_rsvpd = NULL;
	/*
	 * This may seem silly, but we need to be sure we don't over-decrement
	 * the RSVP counter, in case something slips up.
	 */
	if (viftable[vifi].v_rsvp_on) {
		viftable[vifi].v_rsvp_on = 0;
		rsvp_on--;
	}

	splx(s);
	return (0);
}

void
ip_rsvp_force_done(struct socket *so)
{
	int vifi, s;

	/* Don't bother if it is not the right type of socket. */
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
		return;

	s = splsoftnet();

	/*
	 * The socket may be attached to more than one vif...this
	 * is perfectly legal.
	 */
	for (vifi = 0; vifi < numvifs; vifi++) {
		if (viftable[vifi].v_rsvpd == so) {
			viftable[vifi].v_rsvpd = NULL;
			/*
			 * This may seem silly, but we need to be sure we don't
			 * over-decrement the RSVP counter, in case something
			 * slips up.
			 */
			if (viftable[vifi].v_rsvp_on) {
				viftable[vifi].v_rsvp_on = 0;
				rsvp_on--;
			}
		}
	}

	splx(s);
	return;
}

void
rsvp_input(struct mbuf *m, struct ifnet *ifp)
{
	int vifi, s;
	struct ip *ip = mtod(m, struct ip *);
	static struct sockaddr_in rsvp_src = { sizeof(sin), AF_INET };

	if (rsvpdebug)
		printf("rsvp_input: rsvp_on %d\n", rsvp_on);

	/*
	 * Can still get packets with rsvp_on = 0 if there is a local member
	 * of the group to which the RSVP packet is addressed.  But in this
	 * case we want to throw the packet away.
	 */
	if (!rsvp_on) {
		m_freem(m);
		return;
	}

	/*
	 * If the old-style non-vif-associated socket is set, then use
	 * it and ignore the new ones.
	 */
	if (ip_rsvpd != NULL) {
		if (rsvpdebug)
			printf("rsvp_input: "
			    "Sending packet up old-style socket\n");
		rip_input(m, 0);	/*XXX*/
		return;
	}

	s = splsoftnet();

	if (rsvpdebug)
		printf("rsvp_input: check vifs\n");

	/* Find which vif the packet arrived on. */
	for (vifi = 0; vifi < numvifs; vifi++) {
		if (viftable[vifi].v_ifp == ifp)
			break;
	}

	if (vifi == numvifs) {
		/* Can't find vif packet arrived on. Drop packet. */
		if (rsvpdebug)
			printf("rsvp_input: "
			    "Can't find vif for packet...dropping it.\n");
		m_freem(m);
		splx(s);
		return;
	}

	if (rsvpdebug)
		printf("rsvp_input: check socket\n");

	if (viftable[vifi].v_rsvpd == NULL) {
		/*
	 	 * drop packet, since there is no specific socket for this
		 * interface
		 */
		if (rsvpdebug)
			printf("rsvp_input: No socket defined for vif %d\n",
			    vifi);
		m_freem(m);
		splx(s);
		return;
	}

	rsvp_src.sin_addr = ip->ip_src;

	if (rsvpdebug && m)
		printf("rsvp_input: m->m_len = %d, sbspace() = %d\n",
		    m->m_len, sbspace(&viftable[vifi].v_rsvpd->so_rcv));

	if (socket_send(viftable[vifi].v_rsvpd, m, &rsvp_src) < 0)
		if (rsvpdebug)
			printf("rsvp_input: Failed to append to socket\n");
	else
		if (rsvpdebug)
			printf("rsvp_input: send packet up\n");

	splx(s);
}
#endif /* RSVP_ISI */
@


1.59
log
@de-guttenberg our stack a bit
we don't need 7 f***ing copies of the same code to do the protocol checksums
(or not, depending on hw capabilities). claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.58 2010/07/02 02:40:16 blambert Exp $	*/
a74 2
#include <sys/proc.h>
#include <sys/sysctl.h>
@


1.58
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.57 2010/04/20 22:05:43 tedu Exp $	*/
d1812 1
a1812 6
	/* Take care of delayed checksums */
	if (m->m_pkthdr.csum_flags & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum_flags &=
		    ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
	}
d2741 1
a2741 6
	/* Take care of delayed checksums */
	if (m->m_pkthdr.csum_flags & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
		in_delayed_cksum(m);
		m->m_pkthdr.csum_flags &=
		    ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
	}
@


1.57
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.56 2009/08/01 09:08:21 blambert Exp $	*/
d2478 3
a2480 2
	m_copyback(m, 0, sizeof(struct igmpmsg), (caddr_t)&igmpmsg);
	m_copyback(m, sizeof(struct igmpmsg), len, (caddr_t)&bw_upcalls[0]);
@


1.56
log
@timeout_add -> timeout_add_msec

ok michele@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.55 2009/07/13 19:14:29 michele Exp $	*/
d75 1
@


1.55
log
@Get rid of the token bucket filter.
Traffic shaping code should not be inside routing code.
If you want to rate-limit use altq instead.

ok claudio@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.54 2009/07/09 13:04:29 michele Exp $	*/
d140 1
a140 1
#define		EXPIRE_TIMEOUT	(hz / 4)	/* 4x / second */
d241 1
a241 1
#define BW_METER_PERIOD (hz)		/* periodical handling of bw meters */
d250 1
a250 1
#define BW_UPCALLS_PERIOD (hz)		/* periodical flush of bw upcalls */
d570 1
a570 1
	timeout_add(&expire_upcalls_ch, EXPIRE_TIMEOUT);
d573 1
a573 1
	timeout_add(&bw_upcalls_ch, BW_UPCALLS_PERIOD);
d576 1
a576 1
	timeout_add(&bw_meter_ch, BW_METER_PERIOD);
d1600 1
a1600 1
	timeout_add(&expire_upcalls_ch, EXPIRE_TIMEOUT);
d2674 1
a2674 1
	timeout_add(&bw_upcalls_ch, BW_UPCALLS_PERIOD);
d2687 1
a2687 1
	timeout_add(&bw_meter_ch, BW_METER_PERIOD);
@


1.54
log
@Use MAXTTL instead of the hardcoded value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.53 2009/06/05 00:05:22 claudio Exp $	*/
a133 1
u_int		tbfdebug = 0;     /* tbf debug level 	*/
a143 6
/*
 * Define the token bucket filter structures
 */

#define		TBF_REPROCESS	(hz / 100)	/* 100x / second */

d173 1
a173 9
static void tbf_control(struct vif *, struct mbuf *, struct ip *,
			     u_int32_t);
static void tbf_queue(struct vif *, struct mbuf *);
static void tbf_process_q(struct vif *);
static void tbf_reprocess_q(void *);
static int tbf_dq_sel(struct vif *, struct ip *);
static void tbf_send_packet(struct vif *, struct mbuf *);
static void tbf_update_tokens(struct vif *);
static int priority(struct vif *, struct ip *);
a869 8
	/* Define parameters for the tbf structure. */
	vifp->tbf_q = NULL;
	vifp->tbf_t = &vifp->tbf_q;
	microtime(&vifp->tbf_last_pkt_t);
	vifp->tbf_n_tok = 0;
	vifp->tbf_q_len = 0;
	vifp->tbf_max_q_len = MAXQSIZE;

a871 2
	/* scaling up here allows division by 1024 in critical code */
	vifp->v_rate_limit = vifcp->vifc_rate_limit * 1024 / 1000;
d896 1
a896 1
		    "thresh %x, rate %d\n",
d901 1
a901 2
		    vifcp->vifc_threshold,
		    vifcp->vifc_rate_limit);
a908 1
	struct mbuf *m, *n;
a911 10
	timeout_set(&vifp->v_repq_ch, tbf_reprocess_q, vifp);

	/*
	 * Free packets queued at the interface
	 */
	for (m = vifp->tbf_q; m != NULL; m = n) {
		n = m->m_nextpkt;
		m_freem(m);
	}

d1801 1
a1801 5
	if (vifp->v_rate_limit <= 0)
		tbf_send_packet(vifp, mb_copy);
	else
		tbf_control(vifp, mb_copy, mtod(mb_copy, struct ip *),
		    ntohs(ip->ip_len));
d1861 1
a1861 100
	if (vifp->v_rate_limit <= 0)
		tbf_send_packet(vifp, mb_copy);
	else
		tbf_control(vifp, mb_copy, ip, ntohs(ip_copy->ip_len));
}

/*
 * Token bucket filter module
 */
static void
tbf_control(struct vif *vifp, struct mbuf *m, struct ip *ip, u_int32_t len)
{

	if (len > MAX_BKT_SIZE) {
		/* drop if packet is too large */
		mrtstat.mrts_pkt2large++;
		m_freem(m);
		return;
	}

	tbf_update_tokens(vifp);

	/*
	 * If there are enough tokens, and the queue is empty, send this packet
	 * out immediately.  Otherwise, try to insert it on this vif's queue.
	 */
	if (vifp->tbf_q_len == 0) {
		if (len <= vifp->tbf_n_tok) {
			vifp->tbf_n_tok -= len;
			tbf_send_packet(vifp, m);
		} else {
			/* queue packet and timeout till later */
			tbf_queue(vifp, m);
			timeout_add(&vifp->v_repq_ch, TBF_REPROCESS);
		}
	} else {
		if (vifp->tbf_q_len >= vifp->tbf_max_q_len &&
		    !tbf_dq_sel(vifp, ip)) {
			/* queue full, and couldn't make room */
			mrtstat.mrts_q_overflow++;
			m_freem(m);
		} else {
			/* queue length low enough, or made room */
			tbf_queue(vifp, m);
			tbf_process_q(vifp);
		}
	}
}

/*
 * adds a packet to the queue at the interface
 */
static void
tbf_queue(struct vif *vifp, struct mbuf *m)
{
	int s = splsoftnet();

	/* insert at tail */
	*vifp->tbf_t = m;
	vifp->tbf_t = &m->m_nextpkt;
	vifp->tbf_q_len++;

	splx(s);
}


/*
 * processes the queue at the interface
 */
static void
tbf_process_q(struct vif *vifp)
{
	struct mbuf *m;
	int len;
	int s = splsoftnet();

	/*
	 * Loop through the queue at the interface and send as many packets
	 * as possible.
	 */
	for (m = vifp->tbf_q; m != NULL; m = vifp->tbf_q) {
		len = ntohs(mtod(m, struct ip *)->ip_len);

		/* determine if the packet can be sent */
		if (len <= vifp->tbf_n_tok) {
			/* if so,
			 * reduce no of tokens, dequeue the packet,
			 * send the packet.
			 */
			if ((vifp->tbf_q = m->m_nextpkt) == NULL)
				vifp->tbf_t = &vifp->tbf_q;
			--vifp->tbf_q_len;

			m->m_nextpkt = NULL;
			vifp->tbf_n_tok -= len;
			tbf_send_packet(vifp, m);
		} else
			break;
	}
	splx(s);
d1865 1
a1865 46
tbf_reprocess_q(void *arg)
{
	struct vif *vifp = arg;

	if (ip_mrouter == NULL)
		return;

	tbf_update_tokens(vifp);
	tbf_process_q(vifp);

	if (vifp->tbf_q_len != 0)
		timeout_add(&vifp->v_repq_ch, TBF_REPROCESS);
}

/* function that will selectively discard a member of the queue
 * based on the precedence value and the priority
 */
static int
tbf_dq_sel(struct vif *vifp, struct ip *ip)
{
	u_int p;
	struct mbuf **mp, *m;
	int s = splsoftnet();

	p = priority(vifp, ip);

	for (mp = &vifp->tbf_q, m = *mp;
	    m != NULL;
	    mp = &m->m_nextpkt, m = *mp) {
		if (p > priority(vifp, mtod(m, struct ip *))) {
			if ((*mp = m->m_nextpkt) == NULL)
				vifp->tbf_t = mp;
			--vifp->tbf_q_len;

			m_freem(m);
			mrtstat.mrts_drop_sel++;
			splx(s);
			return (1);
		}
	}
	splx(s);
	return (0);
}

static void
tbf_send_packet(struct vif *vifp, struct mbuf *m)
d1883 1
a1883 1
		imo.imo_multicast_ttl = mtod(m, struct ip *)->ip_ttl - 1;
a1899 74
/* determine the current time and then
 * the elapsed time (between the last time and time now)
 * in milliseconds & update the no. of tokens in the bucket
 */
static void
tbf_update_tokens(struct vif *vifp)
{
	struct timeval tp;
	u_int32_t tm;
	int s = splsoftnet();

	microtime(&tp);

	TV_DELTA(tp, vifp->tbf_last_pkt_t, tm);

	/*
	 * This formula is actually
	 * "time in seconds" * "bytes/second".
	 *
	 * (tm / 1000000) * (v_rate_limit * 1000 * (1000/1024) / 8)
	 *
	 * The (1000/1024) was introduced in add_vif to optimize
	 * this divide into a shift.
	 */
	vifp->tbf_n_tok += tm * vifp->v_rate_limit / 8192;
	vifp->tbf_last_pkt_t = tp;

	if (vifp->tbf_n_tok > MAX_BKT_SIZE)
		vifp->tbf_n_tok = MAX_BKT_SIZE;

	splx(s);
}

static int
priority(struct vif *vifp, struct ip *ip)
{
	int prio = 50;	/* the lowest priority -- default case */

	/* temporary hack; may add general packet classifier some day */

	/*
	 * The UDP port space is divided up into four priority ranges:
	 * [0, 16384)     : unclassified - lowest priority
	 * [16384, 32768) : audio - highest priority
	 * [32768, 49152) : whiteboard - medium priority
	 * [49152, 65536) : video - low priority
	 */
	if (ip->ip_p == IPPROTO_UDP) {
		struct udphdr *udp =
		    (struct udphdr *)(((char *)ip) + (ip->ip_hl << 2));

		switch (ntohs(udp->uh_dport) & 0xc000) {
		case 0x4000:
			prio = 70;
			break;
		case 0x8000:
			prio = 60;
			break;
		case 0xc000:
			prio = 55;
			break;
		}

		if (tbfdebug > 1)
			log(LOG_DEBUG, "port %x prio %d\n",
			    ntohs(udp->uh_dport), prio);
	}

	return (prio);
}

/*
 * End of token bucket filter modifications
 */
d2889 1
a2889 4
	if (vifp->v_rate_limit == 0)
		tbf_send_packet(vifp, mb_first);
	else
		tbf_control(vifp, mb_first, ip, ntohs(ip_outer->ip_len));
@


1.53
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.52 2008/09/16 21:33:37 chl Exp $	*/
d1383 1
a1383 1
		if (ip->ip_ttl < 255) {
@


1.52
log
@remove another dead store.

spotted by markus@@

ok henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.51 2008/09/15 21:46:01 chl Exp $	*/
d843 1
a843 1
		ifa = ifa_ifwithaddr(sintosa(&sin));
@


1.51
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok mpf@@ looks good mk@@ ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.50 2008/01/02 03:33:18 brad Exp $	*/
a838 1
	    ifp = NULL;
@


1.50
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.49 2007/12/14 18:33:41 deraadt Exp $	*/
a846 1
		ifp = ifa->ifa_ifp;
@


1.49
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.48 2007/05/22 09:51:13 michele Exp $	*/
d500 1
a500 1
			error = EINVAL;
@


1.48
log
@ip_mroute.c is in bad shape.
This first step makes it style(9) compliant.
Just a whitespace diff, no binary change.

OK claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.47 2007/04/10 17:47:55 miod Exp $	*/
d75 1
d3409 26
@


1.47
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.46 2007/02/14 00:53:48 jsg Exp $	*/
d112 1
a112 1
#define NO_RTE_FOUND 	0x1
d117 1
a117 1
	  ((g).s_addr >> 20) ^ ((g).s_addr >> 10) ^ (g).s_addr) & mfchash)
d133 1
a133 1
u_int       	tbfdebug = 0;     /* tbf debug level 	*/
d921 2
a922 1
		log(LOG_DEBUG, "add_vif #%d, lcladdr %x, %s %x, thresh %x, rate %d\n",
d1049 1
a1049 1
			MRT_MFC_FLAGS_ALL;
d1124 1
a1124 1
		      sizeof(mfcctl2) - sizeof(struct mfcctl));
d1155 2
a1156 1
				log(LOG_ERR, "add_mfc %s o %x g %x p %x dbx %p\n",
d1163 2
a1164 1
				log(LOG_DEBUG, "add_mfc o %x g %x p %x dbg %p\n",
d1220 1
a1220 1
						  M_NOWAIT);
d1288 1
a1288 1
	      sizeof(mfcctl2) - sizeof(struct mfcctl));
d1376 2
a1377 3
			log(LOG_ERR,
			    "ip_mforward: received source-routed packet from %x\n",
			    ntohl(ip->ip_src.s_addr));
d1384 4
a1387 2
		if (ip->ip_ttl < 255)
			ip->ip_ttl++;	/* compensate for -1 in *_send routines */
d1390 2
a1391 1
			printf("Sending IPPROTO_RSVP from %x to %x on vif %d (%s%s)\n",
d1399 2
a1400 2
		printf("Warning: IPPROTO_RSVP from %x to %x without vif option\n",
		    ntohl(ip->ip_src), ntohl(ip->ip_dst));
d1455 2
a1456 1
		rte = (struct rtdetq *)malloc(sizeof(*rte), M_MRTABLE, M_NOWAIT);
d1494 2
a1495 1
			rt = (struct mfc *)malloc(sizeof(*rt), M_MRTABLE, M_NOWAIT);
d1521 2
a1522 2
				log(LOG_WARNING,
				    "ip_mforward: ip_mrouter socket queue full\n");
d1754 2
a1755 2
					log(LOG_WARNING,
					    "ip_mforward: ip_mrouter socket queue full\n");
d1856 2
a1857 1
		m->m_pkthdr.csum_flags &= ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
d2062 4
a2065 1
		/* if physical interface option, extract the options and then send */
d2134 2
a2135 1
		struct udphdr *udp = (struct udphdr *)(((char *)ip) + (ip->ip_hl << 2));
d2182 1
a2182 1
		       vifi, rsvp_on);
d2391 1
a2391 1
    uint32_t flags = 0;
d2393 10
a2402 10
    if (req->bu_flags & BW_UPCALL_UNIT_PACKETS)
	flags |= BW_METER_UNIT_PACKETS;
    if (req->bu_flags & BW_UPCALL_UNIT_BYTES)
	flags |= BW_METER_UNIT_BYTES;
    if (req->bu_flags & BW_UPCALL_GEQ)
	flags |= BW_METER_GEQ;
    if (req->bu_flags & BW_UPCALL_LEQ)
	flags |= BW_METER_LEQ;
    
    return flags;
d2404 1
a2404 1
 
d2411 23
a2433 23
    int s;
    struct mfc *mfc;
    struct timeval delta = { BW_UPCALL_THRESHOLD_INTERVAL_MIN_SEC,
		BW_UPCALL_THRESHOLD_INTERVAL_MIN_USEC };
    struct timeval now;
    struct bw_meter *x;
    uint32_t flags;
    struct bw_upcall *req;

    if (m == NULL || m->m_len < sizeof(struct bw_upcall))
	return EINVAL;

    req = mtod(m, struct bw_upcall *);

    if (!(mrt_api_config & MRT_MFC_BW_UPCALL))
	return EOPNOTSUPP;

    /* Test if the flags are valid */
    if (!(req->bu_flags & (BW_UPCALL_UNIT_PACKETS | BW_UPCALL_UNIT_BYTES)))
	return EINVAL;
    if (!(req->bu_flags & (BW_UPCALL_GEQ | BW_UPCALL_LEQ)))
	return EINVAL;
    if ((req->bu_flags & (BW_UPCALL_GEQ | BW_UPCALL_LEQ))
d2435 26
a2460 1
	return EINVAL;
d2462 24
a2485 29
    /* Test if the threshold time interval is valid */
    if (BW_TIMEVALCMP(&req->bu_threshold.b_time, &delta, <))
	return EINVAL;

    flags = compute_bw_meter_flags(req);

    /*
     * Find if we have already same bw_meter entry
     */
    s = splsoftnet();
    mfc = mfc_find(&req->bu_src, &req->bu_dst);
    if (mfc == NULL) {
	splx(s);
	return EADDRNOTAVAIL;
    }
    for (x = mfc->mfc_bw_meter; x != NULL; x = x->bm_mfc_next) {
	if ((BW_TIMEVALCMP(&x->bm_threshold.b_time,
			   &req->bu_threshold.b_time, ==)) &&
	    (x->bm_threshold.b_packets == req->bu_threshold.b_packets) &&
	    (x->bm_threshold.b_bytes == req->bu_threshold.b_bytes) &&
	    (x->bm_flags & BW_METER_USER_FLAGS) == flags)  {
	    splx(s);
	    return 0;		/* XXX Already installed */
	}
    }

    /* Allocate the new bw_meter entry */
    x = (struct bw_meter *)malloc(sizeof(*x), M_BWMETER, M_NOWAIT);
    if (x == NULL) {
a2486 2
	return ENOBUFS;
    }
d2488 1
a2488 20
    /* Set the new bw_meter entry */
    x->bm_threshold.b_time = req->bu_threshold.b_time;
    microtime(&now);
    x->bm_start_time = now;
    x->bm_threshold.b_packets = req->bu_threshold.b_packets;
    x->bm_threshold.b_bytes = req->bu_threshold.b_bytes;
    x->bm_measured.b_packets = 0;
    x->bm_measured.b_bytes = 0;
    x->bm_flags = flags;
    x->bm_time_next = NULL;
    x->bm_time_hash = BW_METER_BUCKETS;

    /* Add the new bw_meter entry to the front of entries for this MFC */
    x->bm_mfc = mfc;
    x->bm_mfc_next = mfc->mfc_bw_meter;
    mfc->mfc_bw_meter = x;
    schedule_bw_meter(x, &now);
    splx(s);

    return 0;
d2494 2
a2495 2
    while (list != NULL) {
	struct bw_meter *x = list;
d2497 4
a2500 4
	list = list->bm_mfc_next;
	unschedule_bw_meter(x);
	free(x, M_BWMETER);
    }
d2509 9
a2517 24
    int s;
    struct mfc *mfc;
    struct bw_meter *x;
    struct bw_upcall *req;

    if (m == NULL || m->m_len < sizeof(struct bw_upcall))
	return EINVAL;

    req = mtod(m, struct bw_upcall *);
    
    if (!(mrt_api_config & MRT_MFC_BW_UPCALL))
	return EOPNOTSUPP;

    s = splsoftnet();    
    /* Find the corresponding MFC entry */
    mfc = mfc_find(&req->bu_src, &req->bu_dst);
    if (mfc == NULL) {
	splx(s);
	return EADDRNOTAVAIL;
    } else if (req->bu_flags & BW_UPCALL_DELETE_ALL) {
	/*
	 * Delete all bw_meter entries for this mfc
	 */
	struct bw_meter *list;
d2519 2
a2520 8
	list = mfc->mfc_bw_meter;
	mfc->mfc_bw_meter = NULL;
	free_bw_list(list);
	splx(s);
	return 0;
    } else {			/* Delete a single bw_meter entry */
	struct bw_meter *prev;
	uint32_t flags = 0;
d2522 41
a2562 1
	flags = compute_bw_meter_flags(req);
d2564 9
a2572 24
	/* Find the bw_meter entry to delete */
	for (prev = NULL, x = mfc->mfc_bw_meter; x != NULL;
	     prev = x, x = x->bm_mfc_next) {
	    if ((BW_TIMEVALCMP(&x->bm_threshold.b_time,
			       &req->bu_threshold.b_time, ==)) &&
		(x->bm_threshold.b_packets == req->bu_threshold.b_packets) &&
		(x->bm_threshold.b_bytes == req->bu_threshold.b_bytes) &&
		(x->bm_flags & BW_METER_USER_FLAGS) == flags)
		break;
	}
	if (x != NULL) { /* Delete entry from the list for this MFC */
	    if (prev != NULL)
		prev->bm_mfc_next = x->bm_mfc_next;	/* remove from middle*/
	    else
		x->bm_mfc->mfc_bw_meter = x->bm_mfc_next;/* new head of list */

	    unschedule_bw_meter(x);
	    splx(s);
	    /* Free the bw_meter entry */
	    free(x, M_BWMETER);
	    return 0;
	} else {
	    splx(s);
	    return EINVAL;
d2574 1
a2574 2
    }
    /* NOTREACHED */
d2583 1
a2583 1
    struct timeval delta;
d2585 51
a2635 2
    delta = *nowp;
    BW_TIMEVALDECR(&delta, &x->bm_start_time);
d2637 24
a2660 75
    if (x->bm_flags & BW_METER_GEQ) {
	/*
	 * Processing for ">=" type of bw_meter entry
	 */
	if (BW_TIMEVALCMP(&delta, &x->bm_threshold.b_time, >)) {
	    /* Reset the bw_meter entry */
	    x->bm_start_time = *nowp;
	    x->bm_measured.b_packets = 0;
	    x->bm_measured.b_bytes = 0;
	    x->bm_flags &= ~BW_METER_UPCALL_DELIVERED;
	}

	/* Record that a packet is received */
	x->bm_measured.b_packets++;
	x->bm_measured.b_bytes += plen;

	/*
	 * Test if we should deliver an upcall
	 */
	if (!(x->bm_flags & BW_METER_UPCALL_DELIVERED)) {	
	    if (((x->bm_flags & BW_METER_UNIT_PACKETS) &&
		 (x->bm_measured.b_packets >= x->bm_threshold.b_packets)) ||
		((x->bm_flags & BW_METER_UNIT_BYTES) &&
		 (x->bm_measured.b_bytes >= x->bm_threshold.b_bytes))) {
		/* Prepare an upcall for delivery */
		bw_meter_prepare_upcall(x, nowp);
		x->bm_flags |= BW_METER_UPCALL_DELIVERED;
	    }
	}
    } else if (x->bm_flags & BW_METER_LEQ) {
	/*
	 * Processing for "<=" type of bw_meter entry
	 */
	if (BW_TIMEVALCMP(&delta, &x->bm_threshold.b_time, >)) {
	    /*
	     * We are behind time with the multicast forwarding table
	     * scanning for "<=" type of bw_meter entries, so test now
	     * if we should deliver an upcall.
	     */
	    if (((x->bm_flags & BW_METER_UNIT_PACKETS) &&
		 (x->bm_measured.b_packets <= x->bm_threshold.b_packets)) ||
		((x->bm_flags & BW_METER_UNIT_BYTES) &&
		 (x->bm_measured.b_bytes <= x->bm_threshold.b_bytes))) {
		/* Prepare an upcall for delivery */
		bw_meter_prepare_upcall(x, nowp);
	    }
	    /* Reschedule the bw_meter entry */
	    unschedule_bw_meter(x);
	    schedule_bw_meter(x, nowp);
	}
	
	/* Record that a packet is received */
	x->bm_measured.b_packets++;
	x->bm_measured.b_bytes += plen;

	/*
	 * Test if we should restart the measuring interval
	 */
	if ((x->bm_flags & BW_METER_UNIT_PACKETS &&
	     x->bm_measured.b_packets <= x->bm_threshold.b_packets) ||
	    (x->bm_flags & BW_METER_UNIT_BYTES &&
	     x->bm_measured.b_bytes <= x->bm_threshold.b_bytes)) {
	    /* Don't restart the measuring interval */
	} else {
	    /* Do restart the measuring interval */
	    /*
	     * XXX: note that we don't unschedule and schedule, because this
	     * might be too much overhead per packet. Instead, when we process
	     * all entries for a given timer hash bin, we check whether it is
	     * really a timeout. If not, we reschedule at that time.
	     */
	    x->bm_start_time = *nowp;
	    x->bm_measured.b_packets = 0;
	    x->bm_measured.b_bytes = 0;
	    x->bm_flags &= ~BW_METER_UPCALL_DELIVERED;
a2661 1
    }
d2670 2
a2671 2
    struct timeval delta;
    struct bw_upcall *u;
d2673 27
a2699 33
    /*
     * Compute the measured time interval 
     */
    delta = *nowp;
    BW_TIMEVALDECR(&delta, &x->bm_start_time);

    /*
     * If there are too many pending upcalls, deliver them now
     */
    if (bw_upcalls_n >= BW_UPCALLS_MAX)
	bw_upcalls_send();

    /*
     * Set the bw_upcall entry
     */
    u = &bw_upcalls[bw_upcalls_n++];
    u->bu_src = x->bm_mfc->mfc_origin;
    u->bu_dst = x->bm_mfc->mfc_mcastgrp;
    u->bu_threshold.b_time = x->bm_threshold.b_time;
    u->bu_threshold.b_packets = x->bm_threshold.b_packets;
    u->bu_threshold.b_bytes = x->bm_threshold.b_bytes;
    u->bu_measured.b_time = delta;
    u->bu_measured.b_packets = x->bm_measured.b_packets;
    u->bu_measured.b_bytes = x->bm_measured.b_bytes;
    u->bu_flags = 0;
    if (x->bm_flags & BW_METER_UNIT_PACKETS)
	u->bu_flags |= BW_UPCALL_UNIT_PACKETS;
    if (x->bm_flags & BW_METER_UNIT_BYTES)
	u->bu_flags |= BW_UPCALL_UNIT_BYTES;
    if (x->bm_flags & BW_METER_GEQ)
	u->bu_flags |= BW_UPCALL_GEQ;
    if (x->bm_flags & BW_METER_LEQ)
	u->bu_flags |= BW_UPCALL_LEQ;
d2708 31
a2738 26
    struct mbuf *m;
    int len = bw_upcalls_n * sizeof(bw_upcalls[0]);
    struct sockaddr_in k_igmpsrc = { sizeof k_igmpsrc, AF_INET };
    static struct igmpmsg igmpmsg = { 0,		/* unused1 */
				      0,		/* unused2 */
				      IGMPMSG_BW_UPCALL,/* im_msgtype */
				      0,		/* im_mbz  */
				      0,		/* im_vif  */
				      0,		/* unused3 */
				      { 0 },		/* im_src  */
				      { 0 } };		/* im_dst  */
    
    if (bw_upcalls_n == 0)
	return;			/* No pending upcalls */

    bw_upcalls_n = 0;

    /*
     * Allocate a new mbuf, initialize it with the header and
     * the payload for the pending calls.
     */
    MGETHDR(m, M_DONTWAIT, MT_HEADER);
    if (m == NULL) {
	log(LOG_WARNING, "bw_upcalls_send: cannot allocate mbuf\n");
	return;
    }
d2740 10
a2749 13
    m->m_len = m->m_pkthdr.len = 0;
    m_copyback(m, 0, sizeof(struct igmpmsg), (caddr_t)&igmpmsg);
    m_copyback(m, sizeof(struct igmpmsg), len, (caddr_t)&bw_upcalls[0]);

    /*
     * Send the upcalls
     * XXX do we need to set the address in k_igmpsrc ?
     */
    mrtstat.mrts_upcalls++;
    if (socket_send(ip_mrouter, m, &k_igmpsrc) < 0) {
	log(LOG_WARNING, "bw_upcalls_send: ip_mrouter socket queue full\n");
	++mrtstat.mrts_upq_sockfull;
    }
d2755 1
a2755 2
#define	BW_METER_TIMEHASH(bw_meter, hash)				\
    do {								\
d2761 1
a2761 1
	    (hash)++; /* XXX: make sure we don't timeout early */	\
d2763 1
a2763 1
    } while (/*CONSTCOND*/ 0)
d2772 1
a2772 1
    int time_hash;
d2774 2
a2775 2
    if (!(x->bm_flags & BW_METER_LEQ))
	return;		/* XXX: we schedule timers only for "<=" entries */
d2777 11
a2787 15
    /*
     * Reset the bw_meter entry
     */
    x->bm_start_time = *nowp;
    x->bm_measured.b_packets = 0;
    x->bm_measured.b_bytes = 0;
    x->bm_flags &= ~BW_METER_UPCALL_DELIVERED;

    /*
     * Compute the timeout hash value and insert the entry
     */
    BW_METER_TIMEHASH(x, time_hash);
    x->bm_time_next = bw_meter_timers[time_hash];
    bw_meter_timers[time_hash] = x;
    x->bm_time_hash = time_hash;
d2797 5
a2801 2
    int time_hash;
    struct bw_meter *prev, *tmp;
d2803 4
a2806 2
    if (!(x->bm_flags & BW_METER_LEQ))
	return;		/* XXX: we schedule timers only for "<=" entries */
d2808 12
a2819 19
    /*
     * Compute the timeout hash value and delete the entry
     */
    time_hash = x->bm_time_hash;
    if (time_hash >= BW_METER_BUCKETS)
	return;		/* Entry was not scheduled */

    for (prev = NULL, tmp = bw_meter_timers[time_hash];
	     tmp != NULL; prev = tmp, tmp = tmp->bm_time_next)
	if (tmp == x)
	    break;

    if (tmp == NULL)
	panic("unschedule_bw_meter: bw_meter entry not found");

    if (prev != NULL)
	prev->bm_time_next = x->bm_time_next;
    else
	bw_meter_timers[time_hash] = x->bm_time_next;
d2821 2
a2822 2
    x->bm_time_next = NULL;
    x->bm_time_hash = BW_METER_BUCKETS;
d2837 6
a2842 2
    int s;
    static uint32_t last_tv_sec;	/* last time we processed this */
d2844 70
a2913 72
    uint32_t loops;
    int i;
    struct timeval now, process_endtime;

    microtime(&now);
    if (last_tv_sec == now.tv_sec)
	return;		/* nothing to do */

    loops = now.tv_sec - last_tv_sec;
    last_tv_sec = now.tv_sec;
    if (loops > BW_METER_BUCKETS)
	loops = BW_METER_BUCKETS;

    s = splsoftnet();
    /*
     * Process all bins of bw_meter entries from the one after the last
     * processed to the current one. On entry, i points to the last bucket
     * visited, so we need to increment i at the beginning of the loop.
     */
    for (i = (now.tv_sec - loops) % BW_METER_BUCKETS; loops > 0; loops--) {
	struct bw_meter *x, *tmp_list;

	if (++i >= BW_METER_BUCKETS)
	    i = 0;

	/* Disconnect the list of bw_meter entries from the bin */
	tmp_list = bw_meter_timers[i];
	bw_meter_timers[i] = NULL;

	/* Process the list of bw_meter entries */
	while (tmp_list != NULL) {
	    x = tmp_list;
	    tmp_list = tmp_list->bm_time_next;

	    /* Test if the time interval is over */
	    process_endtime = x->bm_start_time;
	    BW_TIMEVALADD(&process_endtime, &x->bm_threshold.b_time);
	    if (BW_TIMEVALCMP(&process_endtime, &now, >)) {
		/* Not yet: reschedule, but don't reset */
		int time_hash;

		BW_METER_TIMEHASH(x, time_hash);
		if (time_hash == i && process_endtime.tv_sec == now.tv_sec) {
		    /*
		     * XXX: somehow the bin processing is a bit ahead of time.
		     * Put the entry in the next bin.
		     */
		    if (++time_hash >= BW_METER_BUCKETS)
			time_hash = 0;
		}
		x->bm_time_next = bw_meter_timers[time_hash];
		bw_meter_timers[time_hash] = x;
		x->bm_time_hash = time_hash;

		continue;
	    }

	    /*
	     * Test if we should deliver an upcall
	     */
	    if (((x->bm_flags & BW_METER_UNIT_PACKETS) &&
		 (x->bm_measured.b_packets <= x->bm_threshold.b_packets)) ||
		((x->bm_flags & BW_METER_UNIT_BYTES) &&
		 (x->bm_measured.b_bytes <= x->bm_threshold.b_bytes))) {
		/* Prepare an upcall for delivery */
		bw_meter_prepare_upcall(x, &now);
	    }

	    /*
	     * Reschedule for next processing
	     */
	    schedule_bw_meter(x, &now);
a2914 1
    }
d2916 2
a2917 2
    /* Send all upcalls that are pending delivery */
    bw_upcalls_send();
d2919 1
a2919 1
    splx(s);
d2928 1
a2928 1
    int s;
d2930 3
a2932 3
    s = splsoftnet();
    bw_upcalls_send();
    splx(s);
d2934 1
a2934 1
    timeout_add(&bw_upcalls_ch, BW_UPCALLS_PERIOD);
d2944 2
a2945 2
    if (mrt_api_config & MRT_MFC_BW_UPCALL)
	bw_meter_process();
d2947 1
a2947 1
    timeout_add(&bw_meter_ch, BW_METER_PERIOD);
d2962 4
a2965 1
    struct mbuf *mb_copy, *mm;
d2967 3
a2969 2
    if (mrtdebug & DEBUG_PIM)
        log(LOG_DEBUG, "pim_register_send: ");
d2971 17
a2987 20
    mb_copy = pim_register_prepare(ip, m);
    if (mb_copy == NULL)
	return ENOBUFS;

    /*
     * Send all the fragments. Note that the mbuf for each fragment
     * is freed by the sending machinery.
     */
    for (mm = mb_copy; mm; mm = mb_copy) {
	mb_copy = mm->m_nextpkt;
	mm->m_nextpkt = NULL;
	mm = m_pullup(mm, sizeof(struct ip));
	if (mm != NULL) {
	    ip = mtod(mm, struct ip *);
	    if ((mrt_api_config & MRT_MFC_RP) &&
		!in_nullhost(rt->mfc_rp)) {
		pim_register_send_rp(ip, vifp, mm, rt);
	    } else {
		pim_register_send_upcall(ip, vifp, mm, rt);
	    }
a2988 1
    }
d2990 1
a2990 1
    return 0;
d3001 20
a3020 2
    struct mbuf *mb_copy = NULL;
    int mtu;
d3022 3
a3024 20
    /* Take care of delayed checksums */
    if (m->m_pkthdr.csum_flags & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
	in_delayed_cksum(m);
	m->m_pkthdr.csum_flags &= ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
    }

    /*
     * Copy the old packet & pullup its IP header into the
     * new mbuf so we can modify it.
     */
    mb_copy = m_copy(m, 0, M_COPYALL);
    if (mb_copy == NULL)
	return NULL;
    mb_copy = m_pullup(mb_copy, ip->ip_hl << 2);
    if (mb_copy == NULL)
	return NULL;

    /* take care of the TTL */
    ip = mtod(mb_copy, struct ip *);
    --ip->ip_ttl;
d3026 2
a3027 2
    /* Compute the MTU after the PIM Register encapsulation */
    mtu = 0xffff - sizeof(pim_encap_iphdr) - sizeof(pim_encap_pimhdr);
d3029 10
a3038 9
    if (ntohs(ip->ip_len) <= mtu) {
	/* Turn the IP header into a valid one */
	ip->ip_sum = 0;
	ip->ip_sum = in_cksum(mb_copy, ip->ip_hl << 2);
    } else {
	/* Fragment the packet */
	if (ip_fragment(mb_copy, NULL, mtu) != 0) {
	    /* XXX: mb_copy was freed by ip_fragment() */
	    return NULL;
d3040 1
a3040 2
    }
    return mb_copy;
d3050 35
a3084 25
    struct mbuf *mb_first;
    int len = ntohs(ip->ip_len);
    struct igmpmsg *im;
    struct sockaddr_in k_igmpsrc = { sizeof k_igmpsrc, AF_INET };

    /*
     * Add a new mbuf with an upcall header
     */
    MGETHDR(mb_first, M_DONTWAIT, MT_HEADER);
    if (mb_first == NULL) {
	m_freem(mb_copy);
	return ENOBUFS;
    }
    mb_first->m_data += max_linkhdr;
    mb_first->m_pkthdr.len = len + sizeof(struct igmpmsg);
    mb_first->m_len = sizeof(struct igmpmsg);
    mb_first->m_next = mb_copy;

    /* Send message to routing daemon */
    im = mtod(mb_first, struct igmpmsg *);
    im->im_msgtype	= IGMPMSG_WHOLEPKT;
    im->im_mbz		= 0;
    im->im_vif		= vifp - viftable;
    im->im_src		= ip->ip_src;
    im->im_dst		= ip->ip_dst;
d3086 3
a3088 1
    k_igmpsrc.sin_addr	= ip->ip_src;
d3090 1
a3090 15
    mrtstat.mrts_upcalls++;

    if (socket_send(ip_mrouter, mb_first, &k_igmpsrc) < 0) {
	if (mrtdebug & DEBUG_PIM)
	    log(LOG_WARNING,
		"mcast: pim_register_send_upcall: ip_mrouter socket queue full");
	++mrtstat.mrts_upq_sockfull;
	return ENOBUFS;
    }

    /* Keep statistics */
    pimstat.pims_snd_registers_msgs++;
    pimstat.pims_snd_registers_bytes += len;

    return 0;
d3100 53
a3152 61
    struct mbuf *mb_first;
    struct ip *ip_outer;
    struct pim_encap_pimhdr *pimhdr;
    int len = ntohs(ip->ip_len);
    vifi_t vifi = rt->mfc_parent;

    if ((vifi >= numvifs) || in_nullhost(viftable[vifi].v_lcl_addr)) {
	m_freem(mb_copy);
	return EADDRNOTAVAIL;		/* The iif vif is invalid */
    }

    /*
     * Add a new mbuf with the encapsulating header
     */
    MGETHDR(mb_first, M_DONTWAIT, MT_HEADER);
    if (mb_first == NULL) {
	m_freem(mb_copy);
	return ENOBUFS;
    }
    mb_first->m_data += max_linkhdr;
    mb_first->m_len = sizeof(pim_encap_iphdr) + sizeof(pim_encap_pimhdr);
    mb_first->m_next = mb_copy;

    mb_first->m_pkthdr.len = len + mb_first->m_len;

    /*
     * Fill in the encapsulating IP and PIM header
     */
    ip_outer = mtod(mb_first, struct ip *);
    *ip_outer = pim_encap_iphdr;
    ip_outer->ip_id = htons(ip_randomid());
    ip_outer->ip_len = htons(len + sizeof(pim_encap_iphdr) +
			     sizeof(pim_encap_pimhdr));
    ip_outer->ip_src = viftable[vifi].v_lcl_addr;
    ip_outer->ip_dst = rt->mfc_rp;
    /*
     * Copy the inner header TOS to the outer header, and take care of the
     * IP_DF bit.
     */
    ip_outer->ip_tos = ip->ip_tos;
    if (ntohs(ip->ip_off) & IP_DF)
	ip_outer->ip_off |= htons(IP_DF);
    pimhdr = (struct pim_encap_pimhdr *)((caddr_t)ip_outer
					 + sizeof(pim_encap_iphdr));
    *pimhdr = pim_encap_pimhdr;
    /* If the iif crosses a border, set the Border-bit */
    if (rt->mfc_flags[vifi] & MRT_MFC_FLAGS_BORDER_VIF & mrt_api_config)
	pimhdr->flags |= htonl(PIM_BORDER_REGISTER);

    mb_first->m_data += sizeof(pim_encap_iphdr);
    pimhdr->pim.pim_cksum = in_cksum(mb_first, sizeof(pim_encap_pimhdr));
    mb_first->m_data -= sizeof(pim_encap_iphdr);

    if (vifp->v_rate_limit == 0)
	tbf_send_packet(vifp, mb_first);
    else
	tbf_control(vifp, mb_first, ip, ntohs(ip_outer->ip_len));

    /* Keep statistics */
    pimstat.pims_snd_registers_msgs++;
    pimstat.pims_snd_registers_bytes += len;
d3154 5
a3158 1
    return 0;
d3172 11
a3182 28
    struct ip *ip = mtod(m, struct ip *);
    struct pim *pim;
    int minlen;
    int datalen;
    int ip_tos;
    int iphlen;
    va_list ap;

    va_start(ap, m);
    iphlen = va_arg(ap, int);
    va_end(ap);

    datalen = ntohs(ip->ip_len) - iphlen;

    /* Keep statistics */
    pimstat.pims_rcv_total_msgs++;
    pimstat.pims_rcv_total_bytes += datalen;

    /*
     * Validate lengths
     */
    if (datalen < PIM_MINLEN) {
	pimstat.pims_rcv_tooshort++;
	log(LOG_ERR, "pim_input: packet size too small %d from %lx\n",
	    datalen, (u_long)ip->ip_src.s_addr);
	m_freem(m);
	return;
    }
d3184 1
a3184 43
    /*
     * If the packet is at least as big as a REGISTER, go agead
     * and grab the PIM REGISTER header size, to avoid another
     * possible m_pullup() later.
     * 
     * PIM_MINLEN       == pimhdr + u_int32_t == 4 + 4 = 8
     * PIM_REG_MINLEN   == pimhdr + reghdr + encap_iphdr == 4 + 4 + 20 = 28
     */
    minlen = iphlen + (datalen >= PIM_REG_MINLEN ? PIM_REG_MINLEN : PIM_MINLEN);
    /*
     * Get the IP and PIM headers in contiguous memory, and
     * possibly the PIM REGISTER header.
     */
    if ((m->m_flags & M_EXT || m->m_len < minlen) &&
	(m = m_pullup(m, minlen)) == NULL) {
	log(LOG_ERR, "pim_input: m_pullup failure\n");
	return;
    }
    /* m_pullup() may have given us a new mbuf so reset ip. */
    ip = mtod(m, struct ip *);
    ip_tos = ip->ip_tos;

    /* adjust mbuf to point to the PIM header */
    m->m_data += iphlen;
    m->m_len  -= iphlen;
    pim = mtod(m, struct pim *);

    /*
     * Validate checksum. If PIM REGISTER, exclude the data packet.
     *
     * XXX: some older PIMv2 implementations don't make this distinction,
     * so for compatibility reason perform the checksum over part of the
     * message, and if error, then over the whole message.
     */
    if (PIM_VT_T(pim->pim_vt) == PIM_REGISTER && in_cksum(m, PIM_MINLEN) == 0) {
	/* do nothing, checksum okay */
    } else if (in_cksum(m, datalen)) {
	pimstat.pims_rcv_badsum++;
	if (mrtdebug & DEBUG_PIM)
	    log(LOG_DEBUG, "pim_input: invalid checksum");
	m_freem(m);
	return;
    }
d3186 3
a3188 8
    /* PIM version check */
    if (PIM_VT_V(pim->pim_vt) < PIM_VERSION) {
	pimstat.pims_rcv_badversion++;
	log(LOG_ERR, "pim_input: incorrect version %d, expecting %d\n",
	    PIM_VT_V(pim->pim_vt), PIM_VERSION);
	m_freem(m);
	return;
    }
d3190 8
a3197 3
    /* restore mbuf back to the outer IP */
    m->m_data -= iphlen;
    m->m_len  += iphlen;
a3198 1
    if (PIM_VT_T(pim->pim_vt) == PIM_REGISTER) {
d3200 26
a3225 10
	 * Since this is a REGISTER, we'll make a copy of the register
	 * headers ip + pim + u_int32 + encap_ip, to be passed up to the
	 * routing daemon.
	 */
	int s;
	struct sockaddr_in dst = { sizeof(dst), AF_INET };
	struct mbuf *mcp;
	struct ip *encap_ip;
	u_int32_t *reghdr;
	struct ifnet *vifp;
d3227 16
a3242 8
	s = splsoftnet();
	if ((reg_vif_num >= numvifs) || (reg_vif_num == VIFI_INVALID)) {
	    splx(s);
	    if (mrtdebug & DEBUG_PIM)
		log(LOG_DEBUG,
		    "pim_input: register vif not set: %d\n", reg_vif_num);
	    m_freem(m);
	    return;
a3243 3
	/* XXX need refcnt? */
	vifp = viftable[reg_vif_num].v_ifp;
	splx(s);
d3245 7
a3251 45
	/*
	 * Validate length
	 */
	if (datalen < PIM_REG_MINLEN) {
	    pimstat.pims_rcv_tooshort++;
	    pimstat.pims_rcv_badregisters++;
	    log(LOG_ERR,
		"pim_input: register packet size too small %d from %lx\n",
		datalen, (u_long)ip->ip_src.s_addr);
	    m_freem(m);
	    return;
	}

	reghdr = (u_int32_t *)(pim + 1);
	encap_ip = (struct ip *)(reghdr + 1);

	if (mrtdebug & DEBUG_PIM) {
	    log(LOG_DEBUG,
		"pim_input[register], encap_ip: %lx -> %lx, encap_ip len %d\n",
		(u_long)ntohl(encap_ip->ip_src.s_addr),
		(u_long)ntohl(encap_ip->ip_dst.s_addr),
		ntohs(encap_ip->ip_len));
	}

	/* verify the version number of the inner packet */
	if (encap_ip->ip_v != IPVERSION) {
	    pimstat.pims_rcv_badregisters++;
	    if (mrtdebug & DEBUG_PIM) {
		log(LOG_DEBUG, "pim_input: invalid IP version (%d) "
		    "of the inner packet\n", encap_ip->ip_v);
	    }
	    m_freem(m);
	    return;
	}

	/* verify the inner packet is destined to a mcast group */
	if (!IN_MULTICAST(encap_ip->ip_dst.s_addr)) {
	    pimstat.pims_rcv_badregisters++;
	    if (mrtdebug & DEBUG_PIM)
		log(LOG_DEBUG,
		    "pim_input: inner packet of register is not "
		    "multicast %lx\n",
		    (u_long)ntohl(encap_ip->ip_dst.s_addr));
	    m_freem(m);
	    return;
d3254 40
a3293 3
	/* If a NULL_REGISTER, pass it to the daemon */
	if ((ntohl(*reghdr) & PIM_NULL_REGISTER))
	    goto pim_input_to_daemon;
d3295 2
a3296 7
	/*
	 * Copy the TOS from the outer IP header to the inner IP header.
	 */
	if (encap_ip->ip_tos != ip_tos) {
	    /* Outer TOS -> inner TOS */
	    encap_ip->ip_tos = ip_tos;
	    /* Recompute the inner header checksum. Sigh... */
d3298 19
a3316 3
	    /* adjust mbuf to point to the inner IP header */
	    m->m_data += (iphlen + PIM_MINLEN);
	    m->m_len  -= (iphlen + PIM_MINLEN);
d3318 11
a3328 2
	    encap_ip->ip_sum = 0;
	    encap_ip->ip_sum = in_cksum(m, encap_ip->ip_hl << 2);
d3330 3
a3332 4
	    /* restore mbuf to point back to the outer IP header */
	    m->m_data -= (iphlen + PIM_MINLEN);
	    m->m_len  += (iphlen + PIM_MINLEN);
	}
d3334 20
a3353 15
	/*
	 * Decapsulate the inner IP packet and loopback to forward it
	 * as a normal multicast packet. Also, make a copy of the 
	 *     outer_iphdr + pimhdr + reghdr + encap_iphdr
	 * to pass to the daemon later, so it can take the appropriate
	 * actions (e.g., send back PIM_REGISTER_STOP).
	 * XXX: here m->m_data points to the outer IP header.
	 */
	mcp = m_copy(m, 0, iphlen + PIM_REG_MINLEN);
	if (mcp == NULL) {
	    log(LOG_ERR,
		"pim_input: pim register: could not copy register head\n");
	    m_freem(m);
	    return;
	}
d3355 15
a3369 4
	/* Keep statistics */
	/* XXX: registers_bytes include only the encap. mcast pkt */
	pimstat.pims_rcv_registers_msgs++;
	pimstat.pims_rcv_registers_bytes += ntohs(encap_ip->ip_len);
d3371 19
a3389 4
	/*
	 * forward the inner ip packet; point m_data at the inner ip.
	 */
	m_adj(m, iphlen + PIM_MINLEN);
d3391 2
a3392 7
	if (mrtdebug & DEBUG_PIM) {
	    log(LOG_DEBUG,
		"pim_input: forwarding decapsulated register: "
		"src %lx, dst %lx, vif %d\n",
		(u_long)ntohl(encap_ip->ip_src.s_addr),
		(u_long)ntohl(encap_ip->ip_dst.s_addr),
		reg_vif_num);
a3393 6
	/* NB: vifp was collected above; can it change on us? */
	looutput(vifp, m, (struct sockaddr *)&dst, (struct rtentry *)NULL);

	/* prepare the register head to send to the mrouting daemon */
	m = mcp;
    }
d3396 9
a3404 9
    /*
     * Pass the PIM message up to the daemon; if it is a Register message,
     * pass the 'head' only up to the daemon. This includes the
     * outer IP header, PIM header, PIM-Register header and the
     * inner IP header.
     * XXX: the outer IP header pkt size of a Register is not adjust to
     * reflect the fact that the inner multicast data is truncated.
     */
    rip_input(m);
d3406 1
a3406 1
    return;
@


1.46
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.45 2006/06/15 10:11:27 pascoe Exp $	*/
d1853 1
a1853 1
	 * copy the old packet & pullup it's IP header into the
@


1.45
log
@Change cast of last vararg to ip_output to match what ip_output expects,
for clarity.

henning@@ claudio@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.44 2006/05/11 20:12:50 hshoexer Exp $	*/
d374 1
a374 1
		/* fall through */					\
d377 1
a377 1
		/* fall through */					\
@


1.44
log
@fix corruption of pim register packets.  From Hideki ONO, thanks!

ok mcbride@@ itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.43 2006/04/25 15:49:35 claudio Exp $	*/
d2052 1
a2052 1
		    (struct socket *)NULL);
d2066 1
a2066 1
		    (struct socket *)NULL);
@


1.43
log
@Remove virtual tunnel support from the mrouting code. The virtual tunnel
code breaks multicast on gif(4) interfaces and it is far better to configure
a real gif(4) tunnel instead of a multicast tunnel as the latter is almost
not manageable. OK norby@@, mblamer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.42 2005/04/25 17:55:51 brad Exp $	*/
d3141 1
a3141 1
	ip_outer->ip_off |= IP_DF;
@


1.42
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.41 2005/01/15 04:43:40 brad Exp $	*/
a322 7
 * one-back cache used by ipip_mroute_input to locate a tunnel's vif
 * given a datagram's src ip address.
 */
static struct in_addr last_encap_src;
static struct vif *last_encap_vif;

/*
d850 2
a851 19
		if (vifcp->vifc_flags & VIFF_SRCRT) {
			log(LOG_ERR, "Source routed tunnels not supported.\n");
			return (EOPNOTSUPP);
		}

		/* Create a fake encapsulation interface. */
		ifp = (struct ifnet *)malloc(sizeof(*ifp), M_MRTABLE, M_WAITOK);
		bzero(ifp, sizeof(*ifp));
		snprintf(ifp->if_xname, sizeof ifp->if_xname,
		    "mdecap%d", vifcp->vifc_vifi);

		/* Prepare cached route entry. */
		bzero(&vifp->v_route, sizeof(vifp->v_route));

		/*
		 * Tell ipip_mroute_input() to start looking at
		 * encapsulated packets.
		 */
		have_encap_tunnel = 1;
d950 1
a950 5
		free(vifp->v_ifp, M_MRTABLE);
		if (vifp == last_encap_vif) {
			last_encap_vif = NULL;
			last_encap_src = zeroin_addr;
		}
a1898 76
}

/*
 * De-encapsulate a packet and feed it back through ip input (this
 * routine is called whenever IP gets a packet with proto type
 * ENCAP_PROTO and a local destination address).
 */
void
ipip_mroute_input(struct mbuf *m, ...)
{
	int hlen;
	struct ip *ip = mtod(m, struct ip *);
	int s;
	struct ifqueue *ifq;
	struct vif *vifp;
	va_list ap;

	va_start(ap, m);
	hlen = va_arg(ap, int);
	va_end(ap);

	if (!have_encap_tunnel) {
		rip_input(m, 0);
		return;
	}

	/*
	 * dump the packet if we don't have an encapsulating tunnel
	 * with the source.
	 * Note:  This code assumes that the remote site IP address
	 * uniquely identifies the tunnel (i.e., that this site has
	 * at most one tunnel with the remote site).
	 */
	if (!in_hosteq(ip->ip_src, last_encap_src)) {
		struct vif *vife;

		vifp = viftable;
		vife = vifp + numvifs;
		for (; vifp < vife; vifp++)
			if (vifp->v_flags & VIFF_TUNNEL &&
			    in_hosteq(vifp->v_rmt_addr, ip->ip_src))
				break;
		if (vifp == vife) {
			mrtstat.mrts_cant_tunnel++; /*XXX*/
			m_freem(m);
			if (mrtdebug)
				log(LOG_DEBUG,
				    "ip_mforward: no tunnel with %x\n",
				    ntohl(ip->ip_src.s_addr));
			return;
		}
		last_encap_vif = vifp;
		last_encap_src = ip->ip_src;
	} else
		vifp = last_encap_vif;

	m->m_data += hlen;
	m->m_len -= hlen;
	m->m_pkthdr.len -= hlen;
	m->m_pkthdr.rcvif = vifp->v_ifp;
	ifq = &ipintrq;
	s = splnet();
	if (IF_QFULL(ifq)) {
		IF_DROP(ifq);
		m_freem(m);
	} else {
		IF_ENQUEUE(ifq, m);
		/*
		 * normally we would need a "schednetisr(NETISR_IP)"
		 * here but we were called by ip_input and it is going
		 * to loop back & try to dequeue the packet we just
		 * queued as soon as we return so we avoid the
		 * unnecessary software interrrupt.
		 */
	}
	splx(s);
@


1.41
log
@fix comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.40 2005/01/14 15:09:42 mcbride Exp $	*/
d1875 1
a1875 1
	if (m->m_pkthdr.csum & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
d1877 1
a1877 1
		m->m_pkthdr.csum &= ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
d3108 1
a3108 1
    if (m->m_pkthdr.csum & (M_TCPV4_CSUM_OUT | M_UDPV4_CSUM_OUT)) {
d3110 1
a3110 1
	m->m_pkthdr.csum &= ~(M_UDPV4_CSUM_OUT | M_TCPV4_CSUM_OUT);
@


1.40
log
@Duplicate nested if statement in PIM code.

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.39 2005/01/14 14:51:27 mcbride Exp $	*/
d1724 1
a1724 1
		 * of the iif (broadcast media, GRE tunnel, etc).
@


1.39
log
@Add kernel support for Protocol Independant Multicast (PIM)
Information: http://netweb.usc.edu/pim/

From Pavlin Radoslavov <pavlin@@icir.org>

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.38 2004/11/24 01:25:42 mcbride Exp $	*/
d981 1
a981 2
		if (vifp->v_flags & VIFF_REGISTER)
			reg_vif_num = VIFI_INVALID;
@


1.38
log
@Multicast routing cleanup from Pavlin Radoslavov
- sync ip_mroute.c with NetBSD
- import some FreeBSD changes to MFC entry handling
- set im->im_vif correctly when sending IGMPMSG_WRONGVIF
- increment mrtstat.mrts_upcalls correctly
- return error from get_sg_cnt() if there is no matching forwarding entry

ok henning@@ brad@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.37 2004/08/24 20:31:16 brad Exp $	*/
d49 5
d56 2
d60 4
d91 4
d129 4
d158 2
a159 2
static void update_mfc_params(struct mfc *, struct mfcctl *);
static void init_mfc_params(struct mfc *, struct mfcctl *);
d166 3
d190 25
d245 72
d339 11
d430 9
d469 6
d593 6
d627 1
d630 2
d650 3
d731 78
d838 17
a854 5
	sin.sin_addr = vifcp->vifc_lcl_addr;
	ifa = ifa_ifwithaddr(sintosa(&sin));
	if (ifa == NULL)
		return (EADDRNOTAVAIL);
	ifp = ifa->ifa_ifp;
d876 15
d979 5
d1069 1
a1069 1
update_mfc_params(struct mfc *rt, struct mfcctl *mfccp)
d1076 2
d1079 5
d1090 1
a1090 1
init_mfc_params(struct mfc *rt, struct mfcctl *mfccp)
d1109 2
d1127 2
a1128 1
	struct mfcctl *mfccp;
d1134 4
d1139 1
a1139 1
	if (m == NULL || m->m_len < sizeof(struct mfcctl))
d1142 13
a1154 1
	mfccp = mtod(m, struct mfcctl *);
d1255 1
d1297 2
a1298 1
	struct mfcctl *mfccp;
d1301 2
d1304 6
a1309 1
	if (m == NULL || m->m_len < sizeof(struct mfcctl))
d1312 5
a1316 1
	mfccp = mtod(m, struct mfcctl *);
d1331 6
d1394 1
a1394 1
		 * an encapuslated tunnel.
d1563 1
a1563 1
			for (i = 0; i < numvifs; i++)
d1565 2
d1569 5
d1638 10
d1697 5
d1720 6
a1725 3
		 * If we are doing PIM assert processing, and we are forwarding
		 * packets on this interface, and it is a broadcast medium
		 * interface (and not a tunnel), send a message to the routing daemon.
d1727 1
a1727 3
		if (pim_assert && rt->mfc_ttls[vifi] &&
		    (ifp->if_flags & IFF_BROADCAST) &&
		    !(viftable[vifi].v_flags & VIFF_TUNNEL)) {
d1731 5
d1746 6
d1808 5
d1816 12
d2469 1050
@


1.37
log
@Don't allow SIOCGET{VIF,SG}CNT from sockets other than the multicast router.

From NetBSD
Fixes PR 3825

ok mcbride@@ canacar@@ claudio@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ip_mroute.c,v 1.36 2004/01/06 17:28:32 markus Exp $	*/
/*	$NetBSD: ip_mroute.c,v 1.27 1996/05/07 02:40:50 thorpej Exp $	*/
d84 2
a85 2
#define	M_PULLUP(m, len) \
	do { \
d87 2
a88 2
			(m) = m_pullup((m), (len)); \
	} while (0)
d100 3
a102 3
#define	MFCHASH(a, g) \
	((((a) >> 20) ^ ((a) >> 10) ^ (a) ^ \
	  ((g) >> 20) ^ ((g) >> 10) ^ (g)) & mfchash)
d123 1
a123 2
struct timeout	upcalls_timeout;
struct timeout	tbf_timeout;
a126 1
 * qtable   -> each interface has an associated queue of pkts
d129 1
a129 1
struct pkt_queue qtable[MAXVIFS][MAXQSIZE];
d139 2
a140 1
static void update_mfc(struct mfcctl *, struct mfc *);
d159 1
a159 1
static void tbf_queue(struct vif *, struct mbuf *, struct ip *);
a160 1
static void tbf_dequeue(struct vif *, int);
d207 1
a207 1
static u_int32_t last_encap_src;
d222 2
d225 4
d230 9
a238 16
#define MFCFIND(o, g, rt) do { \
	struct mfc *_rt; \
	(rt) = NULL; \
	++mrtstat.mrts_mfc_lookups; \
	for (_rt = mfchashtbl[MFCHASH(o, g)].lh_first; \
	     _rt; _rt = _rt->mfc_hash.le_next) { \
		if (_rt->mfc_origin.s_addr == (o) && \
		    _rt->mfc_mcastgrp.s_addr == (g) && \
		    _rt->mfc_stall == NULL) { \
			(rt) = _rt; \
			break; \
		} \
	} \
	if ((rt) == NULL) \
		++mrtstat.mrts_mfc_misses; \
} while (0)
d244 18
a261 18
#define TV_DELTA(a, b, delta) do { \
	int xxs; \
	delta = (a).tv_usec - (b).tv_usec; \
	xxs = (a).tv_sec - (b).tv_sec; \
	switch (xxs) { \
	case 2: \
		delta += 1000000; \
		/* fall through */ \
	case 1: \
		delta += 1000000; \
		/* fall through */ \
	case 0: \
		break; \
	default: \
		delta += (1000000 * xxs); \
		break; \
	} \
} while (0)
d271 1
a271 4
ip_mrouter_set(cmd, so, m)
	int cmd;
	struct socket *so;
	struct mbuf **m;
d275 2
a276 2
	if (cmd != MRT_INIT && so != ip_mrouter)
		error = EACCES;
d278 1
a278 1
		switch (cmd) {
d301 1
a301 1
			error = EOPNOTSUPP;
d314 1
a314 4
ip_mrouter_get(cmd, so, m)
	int cmd;
	struct socket *so;
	struct mbuf **m;
a315 1
	struct mbuf *mb;
d319 1
a319 1
		error = EACCES;
d321 1
a321 1
		*m = mb = m_get(M_WAIT, MT_SOOPTS);
d323 1
a323 1
		switch (cmd) {
d325 1
a325 1
			error = get_version(mb);
d328 1
a328 1
			error = get_assert(mb);
d331 1
a331 1
			error = EOPNOTSUPP;
d336 1
a336 1
			m_free(mb);
d346 1
a346 4
mrt_ioctl(so, cmd, data)
	struct socket *so;
	u_long cmd;
	caddr_t data;
d372 1
a372 2
get_sg_cnt(req)
	struct sioc_sg_req *req;
d374 1
a375 1
	int s;
d378 9
a386 1
	MFCFIND(req->src.s_addr, req->grp.s_addr, rt);
a387 6
	if (rt != NULL) {
		req->pktcnt = rt->mfc_pkt_cnt;
		req->bytecnt = rt->mfc_byte_cnt;
		req->wrong_if = rt->mfc_wrong_if;
	} else
		req->pktcnt = req->bytecnt = req->wrong_if = 0xffffffff;
d396 1
a396 2
get_vif_cnt(req)
	struct sioc_vif_req *req;
d415 1
a415 3
ip_mrouter_init(so, m)
	struct socket *so;
	struct mbuf *m;
d428 1
a428 1
	if (m == 0 || m->m_len < sizeof(int))
d445 2
a446 2
	timeout_set(&upcalls_timeout, expire_upcalls, NULL);
	timeout_add(&upcalls_timeout, EXPIRE_TIMEOUT);
d470 1
a470 1
		if (vifp->v_lcl_addr.s_addr != 0)
a473 1
	bzero((caddr_t)qtable, sizeof(qtable));
d477 1
a477 1
	timeout_del(&upcalls_timeout);
d485 2
a486 2
		for (rt = mfchashtbl[i].lh_first; rt; rt = nrt) {
			nrt = rt->mfc_hash.le_next;
d492 1
d494 1
a494 1
	mfchashtbl = 0;
d509 26
d536 1
a536 2
get_version(m)
	struct mbuf *m;
d549 1
a549 2
set_assert(m)
	struct mbuf *m;
d553 1
a553 1
	if (m == 0 || m->m_len < sizeof(int))
d565 1
a565 2
get_assert(m)
	struct mbuf *m;
d580 1
a580 2
add_vif(m)
	struct mbuf *m;
d589 1
a589 1
	if (m == 0 || m->m_len < sizeof(struct vifctl))
d595 2
d599 1
a599 1
	if (vifp->v_lcl_addr.s_addr != 0)
d605 1
a605 1
	if (ifa == 0)
d607 1
d640 1
a640 1
		satosin(&ifr.ifr_addr)->sin_addr.s_addr = INADDR_ANY;
d647 1
d649 6
a654 3
	vifp->v_tbf.q_len = 0;
	vifp->v_tbf.n_tok = 0;
	vifp->v_tbf.last_pkt_t = 0;
d658 2
a662 5
	vifp->v_rate_limit = vifcp->vifc_rate_limit;
#ifdef RSVP_ISI
	vifp->v_rsvp_on = 0;
	vifp->v_rsvpd = NULL;
#endif /* RSVP_ISI */
d668 8
d695 1
a695 2
reset_vif(vifp)
	struct vif *vifp;
d697 1
d701 10
d714 2
a715 2
			last_encap_vif = 0;
			last_encap_src = 0;
d720 1
a720 1
		satosin(&ifr.ifr_addr)->sin_addr.s_addr = INADDR_ANY;
d731 1
a731 2
del_vif(m)
	struct mbuf *m;
d738 1
a738 1
	if (m == 0 || m->m_len < sizeof(vifi_t))
d746 1
a746 1
	if (vifp->v_lcl_addr.s_addr == 0)
a752 2
	bzero((caddr_t)qtable[*vifip], sizeof(qtable[*vifip]));

d755 1
a755 1
		if (viftable[vifi-1].v_lcl_addr.s_addr != 0)
d768 1
a768 2
vif_delete(ifp)
	struct ifnet *ifp;
d782 1
a782 1
		if (viftable[i - 1].v_lcl_addr.s_addr != 0)
d798 3
d802 1
a802 3
update_mfc(mfccp, rt)
	struct mfcctl *mfccp;
	struct mfc *rt;
d804 1
a804 1
	vifi_t vifi;
d807 21
a827 4
	for (vifi = 0; vifi < numvifs; vifi++)
		rt->mfc_ttls[vifi] = mfccp->mfcc_ttls[vifi];
	rt->mfc_expire = 0;
	rt->mfc_stall = 0;
d831 1
a831 2
expire_mfc(rt)
	struct mfc *rt;
d849 1
a849 2
add_mfc(m)
	struct mbuf *m;
d858 1
a858 1
	if (m == 0 || m->m_len < sizeof(struct mfcctl))
d864 1
a864 1
	MFCFIND(mfccp->mfcc_origin.s_addr, mfccp->mfcc_mcastgrp.s_addr, rt);
d874 1
a874 4
		if (rt->mfc_expire)
			nexpire[hash]--;

		update_mfc(mfccp, rt);
d884 4
a887 4
	hash = MFCHASH(mfccp->mfcc_origin.s_addr, mfccp->mfcc_mcastgrp.s_addr);
	for (rt = mfchashtbl[hash].lh_first; rt; rt = rt->mfc_hash.le_next) {
		if (rt->mfc_origin.s_addr == mfccp->mfcc_origin.s_addr &&
		    rt->mfc_mcastgrp.s_addr == mfccp->mfcc_mcastgrp.s_addr &&
d902 6
a907 2
			if (rt->mfc_expire)
				nexpire[hash]--;
d910 1
a910 1
			for (rte = rt->mfc_stall; rte != NULL; rte = nrte) {
a924 2

			update_mfc(mfccp, rt);
d928 3
d941 9
a949 4
		rt = (struct mfc *)malloc(sizeof(*rt), M_MRTABLE, M_NOWAIT);
		if (rt == NULL) {
			splx(s);
			return (ENOBUFS);
d951 7
d959 3
a961 8
		rt->mfc_origin = mfccp->mfcc_origin;
		rt->mfc_mcastgrp = mfccp->mfcc_mcastgrp;
		/* initialize pkt counters per src-grp */
		rt->mfc_pkt_cnt = 0;
		rt->mfc_byte_cnt = 0;
		rt->mfc_wrong_if = 0;
		timerclear(&rt->mfc_last_assert);
		update_mfc(mfccp, rt);
d963 3
a965 2
		/* insert new entry at head of hash chain */
		LIST_INSERT_HEAD(&mfchashtbl[hash], rt, mfc_hash);
d976 2
a977 2
static void collate(t)
	struct timeval *t;
d1001 1
a1001 2
del_mfc(m)
	struct mbuf *m;
d1007 1
a1007 1
	if (m == 0 || m->m_len < sizeof(struct mfcctl))
d1019 1
a1019 1
	MFCFIND(mfccp->mfcc_origin.s_addr, mfccp->mfcc_mcastgrp.s_addr, rt);
d1033 1
a1033 4
socket_send(s, mm, src)
	struct socket *s;
	struct mbuf *mm;
	struct sockaddr_in *src;
d1035 1
a1035 1
	if (s) {
d1037 1
a1037 1
		    (struct mbuf *)0) != 0) {
d1062 1
a1062 1
ip_mforward(m, ifp, imo)
d1064 1
a1064 6
ip_mforward(m, ifp)
#endif /* RSVP_ISI */
	struct mbuf *m;
	struct ifnet *ifp;
#ifdef RSVP_ISI
	struct ip_moptions *imo;
a1068 1
	u_char *ipoptions;
a1071 2
#ifdef RSVP_ISI
	struct vif *vifp;
a1072 1
#endif /* RSVP_ISI */
d1079 1
a1079 1
	    (ipoptions = (u_char *)(ip + 1))[1] != IPOPT_LSRR) {
d1102 1
a1102 1
			vifp = viftable + vifi;
d1108 1
a1108 1
		return (ip_mdq(m, ifp, rt, vifi));
d1127 2
a1128 1
	MFCFIND(ip->ip_src.s_addr, ip->ip_dst.s_addr, rt);
d1141 1
a1141 2
		 * Make a copy of the packet &
		 * send message to routing daemon
d1147 1
d1154 2
d1164 2
a1165 1
		 * just going to fail anyway.
d1173 1
d1180 5
a1184 5
		/* is there an upcall waiting for this packet? */
		hash = MFCHASH(ip->ip_src.s_addr, ip->ip_dst.s_addr);
		for (rt = mfchashtbl[hash].lh_first; rt; rt = rt->mfc_hash.le_next) {
			if (ip->ip_src.s_addr == rt->mfc_origin.s_addr &&
			    ip->ip_dst.s_addr == rt->mfc_mcastgrp.s_addr &&
a1189 1
			int hlen = ip->ip_hl << 2;
d1193 11
d1206 2
a1207 6
			if (rt == NULL) {
				free(rte, M_MRTABLE);
				m_free(mb0);
				splx(s);
				return (ENOBUFS);
			}
d1214 2
a1215 7
			if (mm == NULL) {
				free(rte, M_MRTABLE);
				m_free(mb0);
				free(rt, M_MRTABLE);
				splx(s);
				return (ENOBUFS);
			}
a1220 1
			sin.sin_addr = ip->ip_src;
d1225 1
d1229 1
d1234 3
d1238 1
a1238 2
				m_free(mb0);
				free(rt, M_MRTABLE);
d1264 5
d1272 1
d1274 1
a1274 1
					m_free(mb0);
d1299 1
a1299 2
expire_upcalls(v)
	void *v;
d1312 2
a1313 2
		for (rt = mfchashtbl[i].lh_first; rt; rt = nrt) {
			nrt = rt->mfc_hash.le_next;
d1331 1
a1331 1
	timeout_add(&upcalls_timeout, EXPIRE_TIMEOUT);
d1339 1
a1339 1
ip_mdq(m, ifp, rt, xmt_vif)
d1341 1
a1341 7
ip_mdq(m, ifp, rt)
#endif /* RSVP_ISI */
	struct mbuf *m;
	struct ifnet *ifp;
	struct mfc *rt;
#ifdef RSVP_ISI
	vifi_t xmt_vif;
d1354 6
a1359 6
#define MC_SEND(ip, vifp, m) do {		\
	if ((vifp)->v_flags & VIFF_TUNNEL)	\
		encap_send((ip), (vifp), (m));	\
	else					\
		phyint_send((ip), (vifp), (m));	\
} while (0)
a1392 3
			struct mbuf *mm;
			struct igmpmsg *im;
			int hlen = ip->ip_hl << 2;
d1396 10
d1411 4
a1414 1
				mm = m_copy(m, 0, hlen);
d1416 1
a1416 1
				if (mm == NULL) {
a1417 1
				}
d1426 2
d1429 6
a1434 2

				socket_send(ip_mrouter, m, &sin);
d1441 1
a1441 1
	if (ip->ip_src.s_addr == viftable[vifi].v_lcl_addr.s_addr) {
d1470 1
a1470 2
 * check if a vif number is legal/ok. This is used by ip_output, to export
 * numvifs there,
d1473 1
a1473 2
legal_vif_num(vif)
	int vif;
d1483 1
a1483 4
phyint_send(ip, vifp, m)
	struct ip *ip;
	struct vif *vifp;
	struct mbuf *m;
d1506 1
a1506 4
encap_send(ip, vifp, m)
	struct ip *ip;
	struct vif *vifp;
	struct mbuf *m;
d1512 6
a1556 3
#if defined(LBL) && !defined(ultrix) && !defined(i386)
	ip->ip_sum = ~oc_cksum((caddr_t)ip, ip->ip_hl << 2, 0);
#else
a1559 1
#endif
d1598 1
a1598 1
	if (ip->ip_src.s_addr != last_encap_src) {
d1605 1
a1605 1
			    vifp->v_rmt_addr.s_addr == ip->ip_src.s_addr)
d1617 1
a1617 1
		last_encap_src = ip->ip_src.s_addr;
d1626 1
a1626 1
	s = splimp();
d1647 1
a1647 5
tbf_control(vifp, m, ip, p_len)
	struct vif *vifp;
	struct mbuf *m;
	struct ip *ip;
	u_int32_t p_len;
d1650 7
d1663 3
a1665 3
	if (vifp->v_tbf.q_len == 0) {
		if (p_len <= vifp->v_tbf.n_tok) {
			vifp->v_tbf.n_tok -= p_len;
a1666 4
		} else if (p_len > MAX_BKT_SIZE) {
			/* drop if packet is too large */
			mrtstat.mrts_pkt2large++;
			m_freem(m);
d1669 2
a1670 3
			tbf_queue(vifp, m, ip);
			timeout_set(&tbf_timeout, tbf_reprocess_q, vifp);
			timeout_add(&tbf_timeout, 1);
d1673 1
a1673 1
		if (vifp->v_tbf.q_len >= MAXQSIZE &&
d1675 1
a1675 1
			/* queue length too much, and couldn't make room */
d1680 1
a1680 1
			tbf_queue(vifp, m, ip);
d1690 1
a1690 4
tbf_queue(vifp, m, ip)
	struct vif *vifp;
	struct mbuf *m;
	struct ip *ip;
a1691 2
	u_int32_t ql;
	int index = (vifp - viftable);
d1694 4
a1697 5
	ql = vifp->v_tbf.q_len;

	qtable[index][ql].pkt_m = m;
	qtable[index][ql].pkt_len = ntohs((mtod(m, struct ip *))->ip_len);
	qtable[index][ql].pkt_ip = ip;
a1698 1
	vifp->v_tbf.q_len++;
d1707 1
a1707 2
tbf_process_q(vifp)
	struct vif *vifp;
d1709 2
a1710 2
	struct pkt_queue pkt_1;
	int index = (vifp - viftable);
d1713 3
a1715 2
	/* loop through the queue at the interface and send as many packets
	 * as possible
d1717 2
a1718 3
	while (vifp->v_tbf.q_len > 0) {
		/* locate the first packet */
		pkt_1 = qtable[index][0];
d1721 1
a1721 1
		if (pkt_1.pkt_len <= vifp->v_tbf.n_tok) {
d1723 1
a1723 1
			 * reduce no of tokens, dequeue the queue,
d1726 3
a1728 1
			vifp->v_tbf.n_tok -= pkt_1.pkt_len;
d1730 3
a1732 2
			tbf_dequeue(vifp, 0);
			tbf_send_packet(vifp, pkt_1.pkt_m);
a1738 3
/*
 * removes the jth packet from the queue at the interface
 */
d1740 1
a1740 24
tbf_dequeue(vifp, j)
	struct vif *vifp;
	int j;
{
	u_int32_t index = vifp - viftable;
	int i;

	for (i = j + 1; i <= vifp->v_tbf.q_len - 1; i++) {
		qtable[index][i-1] = qtable[index][i];
	}
	qtable[index][i-1].pkt_m = NULL;
	qtable[index][i-1].pkt_len = 0;
	qtable[index][i-1].pkt_ip = NULL;

	vifp->v_tbf.q_len--;

	if (tbfdebug > 1)
		log(LOG_DEBUG, "tbf_dequeue: vif# %d qlen %d\n",
		    vifp - viftable, i - 1);
}

static void
tbf_reprocess_q(arg)
	void *arg;
d1750 2
a1751 2
	if (vifp->v_tbf.q_len)
		timeout_add(&tbf_timeout, 1);
d1755 1
a1755 2
 * based on the precedence value and the priority obtained through
 * a lookup table - not yet implemented accurately!
d1758 1
a1758 3
tbf_dq_sel(vifp, ip)
	struct vif *vifp;
	struct ip *ip;
d1760 2
a1761 1
	int i;
a1762 1
	u_int p;
d1766 10
a1775 4
	for (i = vifp->v_tbf.q_len - 1; i >= 0; i--) {
		if (p > priority(vifp, qtable[vifp-viftable][i].pkt_ip)) {
			m_freem(qtable[vifp-viftable][i].pkt_m);
			tbf_dequeue(vifp, i);
a1776 1
			mrtstat.mrts_drop_sel++;
d1785 1
a1785 3
tbf_send_packet(vifp, m)
	struct vif *vifp;
	struct mbuf *m;
d1792 3
a1794 2
		ip_output(m, (struct mbuf *)0, &vifp->v_route,
		    IP_FORWARDING, (void *)NULL, (void *)NULL);
a1796 1
		struct ip *ip = mtod(m, struct ip *);
d1798 1
d1800 1
a1800 1
		imo.imo_multicast_ttl = ip->ip_ttl - 1;
d1806 4
a1809 2
		error = ip_output(m, (struct mbuf *)0, (struct route *)0,
		    IP_FORWARDING|IP_MULTICASTOPTS, &imo, (void *)NULL);
d1811 2
a1812 2
			log(LOG_DEBUG, "phyint_send on vif %d err %d\n",
			    vifp - viftable, error);
d1822 1
a1822 2
tbf_update_tokens(vifp)
	struct vif *vifp;
d1825 1
a1825 2
	u_int32_t t;
	u_int32_t elapsed;
d1830 1
a1830 1
	t = tp.tv_sec * 1000 + tp.tv_usec / 1000;
d1832 11
a1842 3
	elapsed = (t - vifp->v_tbf.last_pkt_t) * vifp->v_rate_limit / 8;
	vifp->v_tbf.n_tok += elapsed;
	vifp->v_tbf.last_pkt_t = t;
d1844 2
a1845 2
	if (vifp->v_tbf.n_tok > MAX_BKT_SIZE)
		vifp->v_tbf.n_tok = MAX_BKT_SIZE;
d1851 1
a1851 3
priority(vifp, ip)
	struct vif *vifp;
	struct ip *ip;
d1853 1
a1853 1
	int prio;
a1876 3
		default:
			prio = 50;
			break;
d1882 1
a1882 2
	} else
		prio = 50;
d1892 1
a1892 3
ip_rsvp_vif_init(so, m)
	struct socket *so;
	struct mbuf *m;
d1894 1
a1894 2
	int i;
	int s;
d1908 1
a1908 1
	i = *(mtod(m, int *));
d1911 2
a1912 1
		printf("ip_rsvp_vif_init: vif = %d rsvp_on = %d\n", i, rsvp_on);
d1917 1
a1917 1
	if (!legal_vif_num(i)) {
d1923 1
a1923 1
	if (viftable[i].v_rsvpd != NULL) {
d1928 1
a1928 1
	viftable[i].v_rsvpd = so;
d1932 2
a1933 2
	if (!viftable[i].v_rsvp_on) {
		viftable[i].v_rsvp_on = 1;
d1942 1
a1942 3
ip_rsvp_vif_done(so, m)
	struct socket *so;
	struct mbuf *m;
d1944 1
a1944 2
	int i;
	int s;
d1958 1
a1958 1
	i = *(mtod(m, int *));
d1963 1
a1963 1
	if (!legal_vif_num(i)) {
d1970 1
a1970 1
		    viftable[i].v_rsvpd, so);
d1972 1
a1972 1
	viftable[i].v_rsvpd = NULL;
d1977 2
a1978 2
	if (viftable[i].v_rsvp_on) {
		viftable[i].v_rsvp_on = 0;
d1987 1
a1987 2
ip_rsvp_force_done(so)
	struct socket *so;
d1989 1
a1989 2
	int vifi;
	int s;
d2022 1
a2022 3
rsvp_input(m, ifp)
	struct mbuf *m;
	struct ifnet *ifp;
d2024 1
a2024 1
	int vifi;
a2026 1
	int s;
d2049 1
a2049 1
		rip_input(m, 0);
@


1.36
log
@fix vlan destroy for MROUTING; report spamme@@wouz.dk via tedu; ok itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.35 2004/01/03 14:08:53 espie Exp $	*/
d356 2
a357 1
mrt_ioctl(cmd, data)
d363 1
a363 8
	switch (cmd) {
	case SIOCGETVIFCNT:
		error = get_vif_cnt((struct sioc_vif_req *)data);
		break;
	case SIOCGETSGCNT:
		error = get_sg_cnt((struct sioc_sg_req *)data);
		break;
	default:
d365 12
a376 2
		break;
	}
@


1.35
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.34 2003/12/10 07:22:43 itojun Exp $	*/
d758 2
@


1.34
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.33 2003/07/09 22:03:16 itojun Exp $	*/
d81 1
a81 1
#include <machine/stdarg.h>
@


1.33
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.32 2003/07/09 03:23:26 itojun Exp $	*/
d227 1
a227 1
	register struct mfc *_rt; \
d248 1
a248 1
	register int xxs; \
d382 1
a382 1
	register struct sioc_sg_req *req;
d384 1
a384 1
	register struct mfc *rt;
d405 1
a405 1
	register struct sioc_vif_req *req;
d407 1
a407 1
	register vifi_t vifi = req->vifi;
d472 1
a472 1
	register struct vif *vifp;
d495 1
a495 1
		register struct mfc *rt, *nrt;
d571 2
a572 2
	register struct vifctl *vifcp;
	register struct vif *vifp;
d673 1
a673 1
	register struct vif *vifp;
d702 2
a703 2
	register struct vif *vifp;
	register vifi_t vifi;
d808 1
a808 1
	register u_short nstl;
d920 1
a920 1
	register struct timeval *t;
d922 3
a924 3
	register u_int32_t d;
	register struct timeval tp;
	register u_int32_t delta;
d1019 3
a1021 3
	register struct ip *ip = mtod(m, struct ip *);
	register struct mfc *rt;
	register u_char *ipoptions;
d1023 1
a1023 1
	register struct mbuf *mm;
d1026 1
a1026 1
	register struct vif *vifp;
d1100 3
a1102 3
		register struct mbuf *mb0;
		register struct rtdetq *rte;
		register u_int32_t hash;
d1209 1
a1209 1
			register int npkts = 0;
d1249 1
a1249 1
		register struct mfc *rt, *nrt;
d1285 3
a1287 3
	register struct mbuf *m;
	register struct ifnet *ifp;
	register struct mfc *rt;
d1289 1
a1289 1
	register vifi_t xmt_vif;
d1292 4
a1295 4
	register struct ip  *ip = mtod(m, struct ip *);
	register vifi_t vifi;
	register struct vif *vifp;
	register int plen = ntohs(ip->ip_len) - (ip->ip_hl << 2);
d1345 1
a1345 1
			register u_int32_t delta;
d1423 2
a1424 2
	register struct mbuf *mb_copy;
	register int hlen = ip->ip_hl << 2;
d1445 7
a1451 7
	register struct ip *ip;
	register struct vif *vifp;
	register struct mbuf *m;
{
	register struct mbuf *mb_copy;
	register struct ip *ip_copy;
	register int i, len = ntohs(ip->ip_len) + sizeof(multicast_encap_iphdr);
d1514 5
a1518 5
	register int hlen;
	register struct ip *ip = mtod(m, struct ip *);
	register int s;
	register struct ifqueue *ifq;
	register struct vif *vifp;
d1538 1
a1538 1
		register struct vif *vife;
d1587 4
a1590 4
	register struct vif *vifp;
	register struct mbuf *m;
	register struct ip *ip;
	register u_int32_t p_len;
d1632 7
a1638 7
	register struct vif *vifp;
	register struct mbuf *m;
	register struct ip *ip;
{
	register u_int32_t ql;
	register int index = (vifp - viftable);
	register int s = splsoftnet();
d1656 1
a1656 1
	register struct vif *vifp;
d1658 3
a1660 3
	register struct pkt_queue pkt_1;
	register int index = (vifp - viftable);
	register int s = splsoftnet();
d1690 2
a1691 2
	register struct vif *vifp;
	register int j;
d1693 2
a1694 2
	register u_int32_t index = vifp - viftable;
	register int i;
d1714 1
a1714 1
	register struct vif *vifp = arg;
d1732 2
a1733 2
	register struct vif *vifp;
	register struct ip *ip;
d1735 3
a1737 3
	register int i;
	register int s = splsoftnet();
	register u_int p;
d1756 2
a1757 2
	register struct vif *vifp;
	register struct mbuf *m;
d1792 1
a1792 1
	register struct vif *vifp;
d1795 3
a1797 3
	register u_int32_t t;
	register u_int32_t elapsed;
	register int s = splsoftnet();
d1815 2
a1816 2
	register struct vif *vifp;
	register struct ip *ip;
d1818 1
a1818 1
	register int prio;
d1866 1
a1866 1
	register int s;
d1918 1
a1918 1
	register int s;
d1965 1
a1965 1
	register int s;
d2003 1
a2003 1
	register struct ip *ip = mtod(m, struct ip *);
d2005 1
a2005 1
	register int s;
@


1.32
log
@better vif_delete (no dangling ref to struct ifnet).  deraadt ok
it won't affect default GENERIC build - as MROUTING is not defined
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.31 2003/06/02 23:28:14 millert Exp $	*/
d1295 1
a1295 1
	register int plen = ip->ip_len;
d1439 2
a1440 1
		tbf_control(vifp, mb_copy, mtod(mb_copy, struct ip *), ip->ip_len);
d1451 1
a1451 1
	register int i, len = ip->ip_len + sizeof(multicast_encap_iphdr);
d1482 1
a1482 1
	ip_copy->ip_len = len;
a1490 2
	HTONS(ip->ip_len);
	HTONS(ip->ip_off);
d1503 1
a1503 1
		tbf_control(vifp, mb_copy, ip, ip_copy->ip_len);
d1643 1
a1643 1
	qtable[index][ql].pkt_len = (mtod(m, struct ip *))->ip_len;
d1700 1
a1700 1
	qtable[index][i-1].pkt_len = NULL;
@


1.31
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.30 2003/05/14 20:35:06 itojun Exp $	*/
d743 2
d756 9
d864 1
d866 1
a866 1
				ip_mdq(rte->m, rte->ifp, rt, -1);
d868 1
a868 1
				ip_mdq(rte->m, rte->ifp, rt);
d870 1
@


1.30
log
@KNF.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.29 2003/05/06 07:28:39 deraadt Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.29
log
@string cleaning; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.28 2002/08/28 15:43:03 pefo Exp $	*/
d230 1
a230 1
#define MFCFIND(o, g, rt) { \
d245 1
a245 1
}
d251 1
a251 1
#define TV_DELTA(a, b, delta) { \
d268 1
a268 1
}
d815 1
a815 1
			log(LOG_DEBUG,"add_mfc update o %x g %x p %x\n",
d846 1
a846 1
				log(LOG_DEBUG,"add_mfc o %x g %x p %x dbg %p\n",
d878 1
a878 1
			log(LOG_DEBUG,"add_mfc no upcall o %x g %x p %x\n",
d911 1
a911 1
register struct timeval *t;
d913 3
a915 3
    register u_int32_t d;
    register struct timeval tp;
    register u_int32_t delta;
d917 1
a917 1
    microtime(&tp);
d919 2
a920 2
    if (timercmp(t, &tp, <)) {
	TV_DELTA(tp, *t, delta);
d922 3
a924 3
	d = delta >> 10;
	if (d > 50)
	    d = 50;
d926 2
a927 2
	++upcall_data[d];
    }
d949 2
a950 1
		    ntohl(mfccp->mfcc_origin.s_addr), ntohl(mfccp->mfcc_mcastgrp.s_addr));
d969 13
a981 12
    struct socket *s;
    struct mbuf *mm;
    struct sockaddr_in *src;
{
    if (s) {
	if (sbappendaddr(&s->so_rcv, sintosa(src), mm, (struct mbuf *)0) != 0) {
	    sorwakeup(s);
	    return (0);
	}
    }
    m_freem(mm);
    return (-1);
d1004 2
a1005 2
    struct mbuf *m;
    struct ifnet *ifp;
d1007 1
a1007 1
    struct ip_moptions *imo;
d1010 6
a1015 6
    register struct ip *ip = mtod(m, struct ip *);
    register struct mfc *rt;
    register u_char *ipoptions;
    static int srctun = 0;
    register struct mbuf *mm;
    int s;
d1017 2
a1018 2
    register struct vif *vifp;
    vifi_t vifi;
d1021 3
a1023 3
    if (mrtdebug & DEBUG_FORWARD)
	log(LOG_DEBUG, "ip_mforward: src %x, dst %x, ifp %p\n",
	    ntohl(ip->ip_src.s_addr), ntohl(ip->ip_dst.s_addr), ifp);
d1025 15
a1039 14
    if (ip->ip_hl < (IP_HDR_LEN + TUNNEL_LEN) >> 2 ||
	(ipoptions = (u_char *)(ip + 1))[1] != IPOPT_LSRR) {
	/*
	 * Packet arrived via a physical interface or
	 * an encapuslated tunnel.
	 */
    } else {
	/*
	 * Packet arrived through a source-route tunnel.
	 * Source-route tunnels are no longer supported.
	 */
	if ((srctun++ % 1000) == 0)
	    log(LOG_ERR, "ip_mforward: received source-routed packet from %x\n",
		ntohl(ip->ip_src.s_addr));
d1041 2
a1042 2
	return (1);
    }
d1045 12
a1056 3
    if (imo && ((vifi = imo->imo_multicast_vif) < numvifs)) {
	if (ip->ip_ttl < 255)
	    ip->ip_ttl++;	/* compensate for -1 in *_send routines */
d1058 3
a1060 12
	    vifp = viftable + vifi;
	    printf("Sending IPPROTO_RSVP from %x to %x on vif %d (%s%s)\n",
		ntohl(ip->ip_src), ntohl(ip->ip_dst), vifi,
		(vifp->v_flags & VIFF_TUNNEL) ? "tunnel on " : "",
		vifp->v_ifp->if_xname);
	}
	return (ip_mdq(m, ifp, rt, vifi));
    }
    if (rsvpdebug && ip->ip_p == IPPROTO_RSVP) {
	printf("Warning: IPPROTO_RSVP from %x to %x without vif option\n",
	    ntohl(ip->ip_src), ntohl(ip->ip_dst));
    }
d1063 6
a1068 7
    /*
     * Don't forward a packet with time-to-live of zero or one,
     * or a packet destined to a local-only group.
     */
    if (ip->ip_ttl <= 1 ||
	IN_LOCAL_GROUP(ip->ip_dst.s_addr))
	return (0);
d1070 5
a1074 5
    /*
     * Determine forwarding vifs from the forwarding cache table
     */
    s = splsoftnet();
    MFCFIND(ip->ip_src.s_addr, ip->ip_dst.s_addr, rt);
d1076 3
a1078 3
    /* Entry exists, so forward if necessary */
    if (rt != NULL) {
	splx(s);
d1080 1
a1080 1
	return (ip_mdq(m, ifp, rt, -1));
d1082 1
a1082 1
	return (ip_mdq(m, ifp, rt));
d1084 6
a1089 6
    } else {
	/*
	 * If we don't have a route for packet's origin,
	 * Make a copy of the packet &
	 * send message to routing daemon
	 */
d1091 3
a1093 3
	register struct mbuf *mb0;
	register struct rtdetq *rte;
	register u_int32_t hash;
d1095 1
a1095 1
	struct timeval tp;
d1097 1
a1097 1
	microtime(&tp);
d1100 5
a1104 5
	mrtstat.mrts_no_route++;
	if (mrtdebug & (DEBUG_FORWARD | DEBUG_MFC))
	    log(LOG_DEBUG, "ip_mforward: no rte s %x g %x\n",
		ntohl(ip->ip_src.s_addr),
		ntohl(ip->ip_dst.s_addr));
d1106 24
a1129 15
	/*
	 * Allocate mbufs early so that we don't do extra work if we are
	 * just going to fail anyway.
	 */
	rte = (struct rtdetq *)malloc(sizeof(*rte), M_MRTABLE, M_NOWAIT);
	if (rte == NULL) {
	    splx(s);
	    return (ENOBUFS);
	}
	mb0 = m_copy(m, 0, M_COPYALL);
	if (mb0 == NULL) {
	    free(rte, M_MRTABLE);
	    splx(s);
	    return (ENOBUFS);
	}
d1131 26
a1156 8
	/* is there an upcall waiting for this packet? */
	hash = MFCHASH(ip->ip_src.s_addr, ip->ip_dst.s_addr);
	for (rt = mfchashtbl[hash].lh_first; rt; rt = rt->mfc_hash.le_next) {
	    if (ip->ip_src.s_addr == rt->mfc_origin.s_addr &&
		ip->ip_dst.s_addr == rt->mfc_mcastgrp.s_addr &&
		rt->mfc_stall != NULL)
		break;
	}
d1158 22
a1179 23
	if (rt == NULL) {
	    int hlen = ip->ip_hl << 2;
	    int i;
	    struct igmpmsg *im;

	    /* no upcall, so make a new entry */
	    rt = (struct mfc *)malloc(sizeof(*rt), M_MRTABLE, M_NOWAIT);
	    if (rt == NULL) {
		free(rte, M_MRTABLE);
		m_free(mb0);
		splx(s);
		return (ENOBUFS);
	    }
	    /* Make a copy of the header to send to the user level process */
	    mm = m_copy(m, 0, hlen);
	    M_PULLUP(mm, hlen);
	    if (mm == NULL) {
		free(rte, M_MRTABLE);
		m_free(mb0);
		free(rt, M_MRTABLE);
		splx(s);
		return (ENOBUFS);
	    }
d1181 29
a1209 21
	    /*
	     * Send message to routing daemon to install
	     * a route into the kernel table
	     */
	    sin.sin_addr = ip->ip_src;

	    im = mtod(mm, struct igmpmsg *);
	    im->im_msgtype	= IGMPMSG_NOCACHE;
	    im->im_mbz		= 0;

	    mrtstat.mrts_upcalls++;

	    if (socket_send(ip_mrouter, mm, &sin) < 0) {
		log(LOG_WARNING, "ip_mforward: ip_mrouter socket queue full\n");
		++mrtstat.mrts_upq_sockfull;
		free(rte, M_MRTABLE);
		m_free(mb0);
		free(rt, M_MRTABLE);
		splx(s);
		return (ENOBUFS);
	    }
d1211 3
a1213 40
	    /* insert new entry at head of hash chain */
	    rt->mfc_origin = ip->ip_src;
	    rt->mfc_mcastgrp = ip->ip_dst;
	    rt->mfc_pkt_cnt = 0;
	    rt->mfc_byte_cnt = 0;
	    rt->mfc_wrong_if = 0;
	    rt->mfc_expire = UPCALL_EXPIRE;
	    nexpire[hash]++;
	    for (i = 0; i < numvifs; i++)
		rt->mfc_ttls[i] = 0;
	    rt->mfc_parent = -1;

	    /* link into table */
	    LIST_INSERT_HEAD(&mfchashtbl[hash], rt, mfc_hash);
	    /* Add this entry to the end of the queue */
	    rt->mfc_stall = rte;
	} else {
	    /* determine if q has overflowed */
	    struct rtdetq **p;
	    register int npkts = 0;

	    for (p = &rt->mfc_stall; *p != NULL; p = &(*p)->next)
		if (++npkts > MAX_UPQ) {
		    mrtstat.mrts_upq_ovflw++;
		    free(rte, M_MRTABLE);
		    m_free(mb0);
		    splx(s);
		    return (0);
	        }

	    /* Add this entry to the end of the queue */
	    *p = rte;
	}

	rte->next		= NULL;
	rte->m 			= mb0;
	rte->ifp 		= ifp;
#ifdef UPCALL_TIMING
	rte->t			= tp;
#endif /* UPCALL_TIMING */
d1215 6
d1222 1
a1222 1
	splx(s);
d1224 2
a1225 2
	return (0);
    }
d1248 1
a1248 2
			if (rt->mfc_expire == 0 ||
			    --rt->mfc_expire > 0)
d1276 3
a1278 3
    register struct mbuf *m;
    register struct ifnet *ifp;
    register struct mfc *rt;
d1280 1
a1280 1
    register vifi_t xmt_vif;
d1283 4
a1286 4
    register struct ip  *ip = mtod(m, struct ip *);
    register vifi_t vifi;
    register struct vif *vifp;
    register int plen = ip->ip_len;
d1293 6
a1298 6
#define MC_SEND(ip,vifp,m) {                             \
                if ((vifp)->v_flags & VIFF_TUNNEL)	 \
                    encap_send((ip), (vifp), (m));       \
                else                                     \
                    phyint_send((ip), (vifp), (m));      \
}
d1301 9
a1309 9
    /*
     * If xmt_vif is not -1, send on only the requested vif.
     *
     * (since vifi_t is u_short, -1 becomes MAXUSHORT, which > numvifs.
     */
    if (xmt_vif < numvifs) {
        MC_SEND(ip, viftable + xmt_vif, m);
	return (1);
    }
a1311 11
    /*
     * Don't forward if it didn't arrive from the parent vif for its origin.
     */
    vifi = rt->mfc_parent;
    if ((vifi >= numvifs) || (viftable[vifi].v_ifp != ifp)) {
	/* came in the wrong interface */
	if (mrtdebug & DEBUG_FORWARD)
	    log(LOG_DEBUG, "wrong if: ifp %p vifi %d vififp %p\n",
		ifp, vifi, vifi >= numvifs ? 0 : viftable[vifi].v_ifp);
	++mrtstat.mrts_wrong_if;
	++rt->mfc_wrong_if;
d1313 1
a1313 3
	 * If we are doing PIM assert processing, and we are forwarding
	 * packets on this interface, and it is a broadcast medium
	 * interface (and not a tunnel), send a message to the routing daemon.
d1315 40
a1354 8
	if (pim_assert && rt->mfc_ttls[vifi] &&
		(ifp->if_flags & IFF_BROADCAST) &&
		!(viftable[vifi].v_flags & VIFF_TUNNEL)) {
	    struct mbuf *mm;
	    struct igmpmsg *im;
	    int hlen = ip->ip_hl << 2;
	    struct timeval now;
	    register u_int32_t delta;
d1356 1
a1356 1
	    microtime(&now);
d1358 2
a1359 7
	    TV_DELTA(rt->mfc_last_assert, now, delta);

	    if (delta > ASSERT_MSG_TIME) {
		mm = m_copy(m, 0, hlen);
		M_PULLUP(mm, hlen);
		if (mm == NULL) {
		    return (ENOBUFS);
d1361 2
d1364 10
a1373 1
		rt->mfc_last_assert = now;
d1375 13
a1387 6
		im = mtod(mm, struct igmpmsg *);
		im->im_msgtype	= IGMPMSG_WRONGVIF;
		im->im_mbz	= 0;
		im->im_vif	= vifi;

		sin.sin_addr = im->im_src;
a1388 3
		socket_send(ip_mrouter, m, &sin);
	    }
	}
a1389 28
    }

    /* If I sourced this packet, it counts as output, else it was input. */
    if (ip->ip_src.s_addr == viftable[vifi].v_lcl_addr.s_addr) {
	viftable[vifi].v_pkt_out++;
	viftable[vifi].v_bytes_out += plen;
    } else {
	viftable[vifi].v_pkt_in++;
	viftable[vifi].v_bytes_in += plen;
    }
    rt->mfc_pkt_cnt++;
    rt->mfc_byte_cnt += plen;

    /*
     * For each vif, decide if a copy of the packet should be forwarded.
     * Forward if:
     *		- the ttl exceeds the vif's threshold
     *		- there are group members downstream on interface
     */
    for (vifp = viftable, vifi = 0; vifi < numvifs; vifp++, vifi++)
	if ((rt->mfc_ttls[vifi] > 0) &&
	    (ip->ip_ttl > rt->mfc_ttls[vifi])) {
	    vifp->v_pkt_out++;
	    vifp->v_bytes_out += plen;
	    MC_SEND(ip, vifp, m);
	}

    return (0);
d1399 1
a1399 1
    int vif;
d1401 4
a1404 4
    if (vif >= 0 && vif < numvifs)
       return (1);
    else
       return (0);
d1624 13
a1636 13
    register struct vif *vifp;
    register struct mbuf *m;
    register struct ip *ip;
{
    register u_int32_t ql;
    register int index = (vifp - viftable);
    register int s = splsoftnet();

    ql = vifp->v_tbf.q_len;

    qtable[index][ql].pkt_m = m;
    qtable[index][ql].pkt_len = (mtod(m, struct ip *))->ip_len;
    qtable[index][ql].pkt_ip = ip;
d1638 2
a1639 2
    vifp->v_tbf.q_len++;
    splx(s);
d1648 1
a1648 1
    register struct vif *vifp;
d1650 3
a1652 18
    register struct pkt_queue pkt_1;
    register int index = (vifp - viftable);
    register int s = splsoftnet();

    /* loop through the queue at the interface and send as many packets
     * as possible
     */
    while (vifp->v_tbf.q_len > 0) {
	/* locate the first packet */
	pkt_1 = qtable[index][0];

	/* determine if the packet can be sent */
	if (pkt_1.pkt_len <= vifp->v_tbf.n_tok) {
	    /* if so,
	     * reduce no of tokens, dequeue the queue,
	     * send the packet.
	     */
	    vifp->v_tbf.n_tok -= pkt_1.pkt_len;
d1654 21
a1674 6
	    tbf_dequeue(vifp, 0);
	    tbf_send_packet(vifp, pkt_1.pkt_m);
	} else
	    break;
    }
    splx(s);
d1682 2
a1683 2
    register struct vif *vifp;
    register int j;
d1685 2
a1686 2
    register u_int32_t index = vifp - viftable;
    register int i;
d1688 6
a1693 6
    for (i=j+1; i <= vifp->v_tbf.q_len - 1; i++) {
	qtable[index][i-1] = qtable[index][i];
    }
    qtable[index][i-1].pkt_m = NULL;
    qtable[index][i-1].pkt_len = NULL;
    qtable[index][i-1].pkt_ip = NULL;
d1695 1
a1695 1
    vifp->v_tbf.q_len--;
d1697 3
a1699 2
    if (tbfdebug > 1)
	log(LOG_DEBUG, "tbf_dequeue: vif# %d qlen %d\n",vifp-viftable, i-1);
d1724 2
a1725 2
    register struct vif *vifp;
    register struct ip *ip;
d1727 17
a1743 17
    register int i;
    register int s = splsoftnet();
    register u_int p;

    p = priority(vifp, ip);

    for(i=vifp->v_tbf.q_len-1;i >= 0;i--) {
	if (p > priority(vifp, qtable[vifp-viftable][i].pkt_ip)) {
	    m_freem(qtable[vifp-viftable][i].pkt_m);
	    tbf_dequeue(vifp, i);
	    splx(s);
	    mrtstat.mrts_drop_sel++;
	    return (1);
	}
    }
    splx(s);
    return (0);
d1747 18
a1764 18
tbf_send_packet(vifp,m)
    register struct vif *vifp;
    register struct mbuf *m;
{
    int error;
    int s = splsoftnet();

    if (vifp->v_flags & VIFF_TUNNEL) {
	/* If tunnel options */
	ip_output(m, (struct mbuf *)0, &vifp->v_route,
		  IP_FORWARDING, (void *)NULL, (void *)NULL);
    } else {
	/* if physical interface option, extract the options and then send */
	struct ip *ip = mtod(m, struct ip *);
	struct ip_moptions imo;
	imo.imo_multicast_ifp  = vifp->v_ifp;
	imo.imo_multicast_ttl  = ip->ip_ttl - 1;
	imo.imo_multicast_loop = 1;
d1766 1
a1766 1
	imo.imo_multicast_vif  = -1;
d1769 7
a1775 6
	error = ip_output(m, (struct mbuf *)0, (struct route *)0,
			  IP_FORWARDING|IP_MULTICASTOPTS, &imo, (void *)NULL);
	if (mrtdebug & DEBUG_XMIT)
	    log(LOG_DEBUG, "phyint_send on vif %d err %d\n", vifp-viftable, error);
    }
    splx(s);
d1784 1
a1784 1
    register struct vif *vifp;
d1786 4
a1789 4
    struct timeval tp;
    register u_int32_t t;
    register u_int32_t elapsed;
    register int s = splsoftnet();
d1791 1
a1791 1
    microtime(&tp);
d1793 1
a1793 1
    t = tp.tv_sec*1000 + tp.tv_usec/1000;
d1795 3
a1797 3
    elapsed = (t - vifp->v_tbf.last_pkt_t) * vifp->v_rate_limit /8;
    vifp->v_tbf.n_tok += elapsed;
    vifp->v_tbf.last_pkt_t = t;
d1799 2
a1800 2
    if (vifp->v_tbf.n_tok > MAX_BKT_SIZE)
	vifp->v_tbf.n_tok = MAX_BKT_SIZE;
d1802 1
a1802 1
    splx(s);
d1807 2
a1808 2
    register struct vif *vifp;
    register struct ip *ip;
d1810 1
a1810 1
    register int prio;
d1812 1
a1812 1
    /* temporary hack; may add general packet classifier some day */
d1814 9
a1822 24
    /*
     * The UDP port space is divided up into four priority ranges:
     * [0, 16384)     : unclassified - lowest priority
     * [16384, 32768) : audio - highest priority
     * [32768, 49152) : whiteboard - medium priority
     * [49152, 65536) : video - low priority
     */
    if (ip->ip_p == IPPROTO_UDP) {
	struct udphdr *udp = (struct udphdr *)(((char *)ip) + (ip->ip_hl << 2));

	switch (ntohs(udp->uh_dport) & 0xc000) {
	    case 0x4000:
		prio = 70;
		break;
	    case 0x8000:
		prio = 60;
		break;
	    case 0xc000:
		prio = 55;
		break;
	    default:
		prio = 50;
		break;
	}
d1824 14
a1837 3
	if (tbfdebug > 1) log(LOG_DEBUG, "port %x prio %d\n", ntohs(udp->uh_dport), prio);
    } else
	prio = 50;
d1839 5
d1845 1
a1845 1
    return (prio);
a1850 1

a1851 1

d1854 2
a1855 2
    struct socket *so;
    struct mbuf *m;
d1857 2
a1858 2
    int i;
    register int s;
d1860 3
a1862 3
    if (rsvpdebug)
	printf("ip_rsvp_vif_init: so_type = %d, pr_protocol = %d\n",
	       so->so_type, so->so_proto->pr_protocol);
d1864 3
a1866 2
    if (so->so_type != SOCK_RAW || so->so_proto->pr_protocol != IPPROTO_RSVP)
	return (EOPNOTSUPP);
d1868 5
a1872 5
    /* Check mbuf. */
    if (m == NULL || m->m_len != sizeof(int)) {
	return (EINVAL);
    }
    i = *(mtod(m, int *));
d1874 2
a1875 2
    if (rsvpdebug)
	printf("ip_rsvp_vif_init: vif = %d rsvp_on = %d\n",i,rsvp_on);
d1877 1
a1877 1
    s = splsoftnet();
d1879 5
a1883 5
    /* Check vif. */
    if (!legal_vif_num(i)) {
	splx(s);
	return (EADDRNOTAVAIL);
    }
d1885 5
a1889 5
    /* Check if socket is available. */
    if (viftable[i].v_rsvpd != NULL) {
	splx(s);
	return (EADDRINUSE);
    }
d1891 8
a1898 8
    viftable[i].v_rsvpd = so;
    /* This may seem silly, but we need to be sure we don't over-increment
     * the RSVP counter, in case something slips up.
     */
    if (!viftable[i].v_rsvp_on) {
	viftable[i].v_rsvp_on = 1;
	rsvp_on++;
    }
d1900 2
a1901 2
    splx(s);
    return (0);
d1906 2
a1907 2
    struct socket *so;
    struct mbuf *m;
d1909 2
a1910 2
    int i;
    register int s;
d1912 3
a1914 3
    if (rsvpdebug)
	printf("ip_rsvp_vif_done: so_type = %d, pr_protocol = %d\n",
	       so->so_type, so->so_proto->pr_protocol);
d1916 3
a1918 2
    if (so->so_type != SOCK_RAW || so->so_proto->pr_protocol != IPPROTO_RSVP)
	return (EOPNOTSUPP);
d1920 5
a1924 5
    /* Check mbuf. */
    if (m == NULL || m->m_len != sizeof(int)) {
	return (EINVAL);
    }
    i = *(mtod(m, int *));
d1926 1
a1926 1
    s = splsoftnet();
d1928 5
a1932 5
    /* Check vif. */
    if (!legal_vif_num(i)) {
	splx(s);
        return (EADDRNOTAVAIL);
    }
d1934 3
a1936 12
    if (rsvpdebug)
	printf("ip_rsvp_vif_done: v_rsvpd = %x so = %x\n",
	       viftable[i].v_rsvpd, so);

    viftable[i].v_rsvpd = NULL;
    /* This may seem silly, but we need to be sure we don't over-decrement
     * the RSVP counter, in case something slips up.
     */
    if (viftable[i].v_rsvp_on) {
	viftable[i].v_rsvp_on = 0;
	rsvp_on--;
    }
d1938 12
a1949 2
    splx(s);
    return (0);
d1954 1
a1954 1
    struct socket *so;
d1956 2
a1957 2
    int vifi;
    register int s;
d1959 4
a1962 3
    /* Don't bother if it is not the right type of socket. */
    if (so->so_type != SOCK_RAW || so->so_proto->pr_protocol != IPPROTO_RSVP)
	return;
d1964 1
a1964 1
    s = splsoftnet();
d1966 17
a1982 13
    /* The socket may be attached to more than one vif...this
     * is perfectly legal.
     */
    for (vifi = 0; vifi < numvifs; vifi++) {
	if (viftable[vifi].v_rsvpd == so) {
	    viftable[vifi].v_rsvpd = NULL;
	    /* This may seem silly, but we need to be sure we don't
	     * over-decrement the RSVP counter, in case something slips up.
	     */
	    if (viftable[vifi].v_rsvp_on) {
		viftable[vifi].v_rsvp_on = 0;
		rsvp_on--;
	    }
a1983 1
    }
d1985 2
a1986 2
    splx(s);
    return;
d1991 2
a1992 2
    struct mbuf *m;
    struct ifnet *ifp;
d1994 4
a1997 16
    int vifi;
    register struct ip *ip = mtod(m, struct ip *);
    static struct sockaddr_in rsvp_src = { sizeof(sin), AF_INET };
    register int s;

    if (rsvpdebug)
	printf("rsvp_input: rsvp_on %d\n",rsvp_on);

    /* Can still get packets with rsvp_on = 0 if there is a local member
     * of the group to which the RSVP packet is addressed.  But in this
     * case we want to throw the packet away.
     */
    if (!rsvp_on) {
	m_freem(m);
	return;
    }
a1998 4
    /* If the old-style non-vif-associated socket is set, then use
     * it and ignore the new ones.
     */
    if (ip_rsvpd != NULL) {
d2000 1
a2000 4
	    printf("rsvp_input: Sending packet up old-style socket\n");
	rip_input(m, 0);
	return;
    }
d2002 9
a2010 1
    s = splsoftnet();
d2012 11
a2022 2
    if (rsvpdebug)
	printf("rsvp_input: check vifs\n");
d2024 1
a2024 5
    /* Find which vif the packet arrived on. */
    for (vifi = 0; vifi < numvifs; vifi++) {
	if (viftable[vifi].v_ifp == ifp)
	    break;
    }
a2025 2
    if (vifi == numvifs) {
	/* Can't find vif packet arrived on. Drop packet. */
d2027 1
a2027 5
	    printf("rsvp_input: Can't find vif for packet...dropping it.\n");
	m_freem(m);
	splx(s);
	return;
    }
d2029 15
a2043 2
    if (rsvpdebug)
	printf("rsvp_input: check socket\n");
a2044 3
    if (viftable[vifi].v_rsvpd == NULL) {
	/* drop packet, since there is no specific socket for this
	 * interface */
d2046 1
a2046 5
	    printf("rsvp_input: No socket defined for vif %d\n",vifi);
	m_freem(m);
	splx(s);
	return;
    }
d2048 12
a2059 1
    rsvp_src.sin_addr = ip->ip_src;
d2061 1
a2061 3
    if (rsvpdebug && m)
	printf("rsvp_input: m->m_len = %d, sbspace() = %d\n",
	       m->m_len,sbspace(&viftable[vifi].v_rsvpd->so_rcv));
d2063 10
a2072 6
    if (socket_send(viftable[vifi].v_rsvpd, m, &rsvp_src) < 0)
	if (rsvpdebug)
	    printf("rsvp_input: Failed to append to socket\n");
    else
	if (rsvpdebug)
	    printf("rsvp_input: send packet up\n");
d2074 1
a2074 1
    splx(s);
@


1.28
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.27 2002/07/31 04:05:57 itojun Exp $	*/
d608 2
a609 1
		sprintf(ifp->if_xname, "mdecap%d", vifcp->vifc_vifi);
@


1.27
log
@remove $Id$
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.26 2002/06/09 16:26:10 itojun Exp $	*/
d1750 1
a1750 1
		  IP_FORWARDING, NULL, NULL);
d1763 1
a1763 1
			  IP_FORWARDING|IP_MULTICASTOPTS, &imo, NULL);
@


1.26
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.25 2002/03/15 18:19:52 millert Exp $	*/
a40 1
 * $Id: ip_mroute.c,v 1.25 2002/03/15 18:19:52 millert Exp $
@


1.25
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.24 2002/03/14 01:27:11 millert Exp $	*/
d41 1
a41 1
 * $Id: ip_mroute.c,v 1.24 2002/03/14 01:27:11 millert Exp $
d133 1
a133 1
 * qtable   -> each interface has an associated queue of pkts 
d200 1
a200 1
	ENCAP_TTL, ENCAP_PROTO,	
d480 1
a480 1
	
d493 1
a493 1
	
d495 1
a495 1
	
d504 1
a504 1
			
d511 1
a511 1
	
d514 1
a514 1
	
d516 1
a516 1
	
d518 1
a518 1
	
d521 1
a521 1
	
d582 1
a582 1
	
d593 1
a593 1
	
d599 1
a599 1
	
d626 1
a626 1
		
d635 1
a635 1
	
d641 1
a641 1
	
d658 1
a658 1
	
d662 1
a662 1
	
d665 1
a665 1
		    vifcp->vifc_vifi, 
d670 2
a671 2
		    vifcp->vifc_rate_limit);    
	
d709 1
a709 1
	
d720 1
a720 1
	
d722 1
a722 1
	
d724 1
a724 1
	
d726 1
a726 1
	
d732 1
a732 1
	
d734 1
a734 1
	
d737 1
a737 1
	
d829 1
a829 1
	/* 
d882 1
a882 1
	
d897 1
a897 1
	    
d908 1
a908 1
 * collect delay statistics on the upcalls 
d916 1
a916 1
    
d918 1
a918 1
    
d921 1
a921 1
	
d925 1
a925 1
	
d1119 1
a1119 1
	    
d1153 2
a1154 2
	    /* 
	     * Send message to routing daemon to install 
d1158 1
a1158 1
	    
d1316 1
a1316 1
		ifp, vifi, vifi >= numvifs ? 0 : viftable[vifi].v_ifp); 
d1345 1
a1345 1
		
d1390 1
a1390 1
 * numvifs there, 
d1449 1
a1449 1
	
d1460 1
a1460 1
	
d1470 1
a1470 1
	
d1486 1
a1486 1
	
d1526 1
a1526 1
	
d1614 1
a1614 1
/* 
d1618 1
a1618 1
tbf_queue(vifp, m, ip) 
d1638 1
a1638 1
/* 
d1672 1
a1672 1
/* 
d1685 1
a1685 1
    }		
d1702 1
a1702 1
	if (ip_mrouter == NULL) 
d1806 1
a1806 1
    
d1841 1
a1841 1
 * End of token bucket filter modifications 
d2053 1
a2053 1
    
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.23 2001/09/26 17:37:52 deraadt Exp $	*/
d41 1
a41 1
 * $Id: ip_mroute.c,v 1.23 2001/09/26 17:37:52 deraadt Exp $
a1498 1
#if __STDC__
a1499 5
#else
ipip_mroute_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.23
log
@bring back the old copyright notice
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.22 2001/08/19 15:07:34 miod Exp $	*/
d41 1
a41 1
 * $Id: ip_mroute.c,v 1.3 1994/08/02 07:48:40 davidg Exp $
d138 11
a148 11
static int get_sg_cnt __P((struct sioc_sg_req *));
static int get_vif_cnt __P((struct sioc_vif_req *));
static int ip_mrouter_init __P((struct socket *, struct mbuf *));
static int get_version __P((struct mbuf *));
static int set_assert __P((struct mbuf *));
static int get_assert __P((struct mbuf *));
static int add_vif __P((struct mbuf *));
static int del_vif __P((struct mbuf *));
static void update_mfc __P((struct mfcctl *, struct mfc *));
static void expire_mfc __P((struct mfc *));
static int add_mfc __P((struct mbuf *));
d150 1
a150 1
static void collate __P((struct timeval *));
d152 4
a155 4
static int del_mfc __P((struct mbuf *));
static int socket_send __P((struct socket *, struct mbuf *,
			    struct sockaddr_in *));
static void expire_upcalls __P((void *));
d157 1
a157 1
static int ip_mdq __P((struct mbuf *, struct ifnet *, struct mfc *, vifi_t));
d159 1
a159 1
static int ip_mdq __P((struct mbuf *, struct ifnet *, struct mfc *));
d161 12
a172 12
static void phyint_send __P((struct ip *, struct vif *, struct mbuf *));
static void encap_send __P((struct ip *, struct vif *, struct mbuf *));
static void tbf_control __P((struct vif *, struct mbuf *, struct ip *,
			     u_int32_t));
static void tbf_queue __P((struct vif *, struct mbuf *, struct ip *));
static void tbf_process_q __P((struct vif *));
static void tbf_dequeue __P((struct vif *, int));
static void tbf_reprocess_q __P((void *));
static int tbf_dq_sel __P((struct vif *, struct ip *));
static void tbf_send_packet __P((struct vif *, struct mbuf *));
static void tbf_update_tokens __P((struct vif *));
static int priority __P((struct vif *, struct ip *));
@


1.23.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.23 2001/09/26 17:37:52 deraadt Exp $	*/
d41 1
a41 1
 * $Id: ip_mroute.c,v 1.23 2001/09/26 17:37:52 deraadt Exp $
d138 11
a148 11
static int get_sg_cnt(struct sioc_sg_req *);
static int get_vif_cnt(struct sioc_vif_req *);
static int ip_mrouter_init(struct socket *, struct mbuf *);
static int get_version(struct mbuf *);
static int set_assert(struct mbuf *);
static int get_assert(struct mbuf *);
static int add_vif(struct mbuf *);
static int del_vif(struct mbuf *);
static void update_mfc(struct mfcctl *, struct mfc *);
static void expire_mfc(struct mfc *);
static int add_mfc(struct mbuf *);
d150 1
a150 1
static void collate(struct timeval *);
d152 4
a155 4
static int del_mfc(struct mbuf *);
static int socket_send(struct socket *, struct mbuf *,
			    struct sockaddr_in *);
static void expire_upcalls(void *);
d157 1
a157 1
static int ip_mdq(struct mbuf *, struct ifnet *, struct mfc *, vifi_t);
d159 1
a159 1
static int ip_mdq(struct mbuf *, struct ifnet *, struct mfc *);
d161 12
a172 12
static void phyint_send(struct ip *, struct vif *, struct mbuf *);
static void encap_send(struct ip *, struct vif *, struct mbuf *);
static void tbf_control(struct vif *, struct mbuf *, struct ip *,
			     u_int32_t);
static void tbf_queue(struct vif *, struct mbuf *, struct ip *);
static void tbf_process_q(struct vif *);
static void tbf_dequeue(struct vif *, int);
static void tbf_reprocess_q(void *);
static int tbf_dq_sel(struct vif *, struct ip *);
static void tbf_send_packet(struct vif *, struct mbuf *);
static void tbf_update_tokens(struct vif *);
static int priority(struct vif *, struct ip *);
d1499 1
d1501 5
@


1.23.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.23.4.1 2002/06/11 03:31:36 art Exp $	*/
d41 1
d133 1
a133 1
 * qtable   -> each interface has an associated queue of pkts
d200 1
a200 1
	ENCAP_TTL, ENCAP_PROTO,
d480 1
a480 1

d493 1
a493 1

d495 1
a495 1

d504 1
a504 1

d511 1
a511 1

d514 1
a514 1

d516 1
a516 1

d518 1
a518 1

d521 1
a521 1

d582 1
a582 1

d593 1
a593 1

d599 1
a599 1

d626 1
a626 1

d635 1
a635 1

d641 1
a641 1

d658 1
a658 1

d662 1
a662 1

d665 1
a665 1
		    vifcp->vifc_vifi,
d670 2
a671 2
		    vifcp->vifc_rate_limit);

d709 1
a709 1

d720 1
a720 1

d722 1
a722 1

d724 1
a724 1

d726 1
a726 1

d732 1
a732 1

d734 1
a734 1

d737 1
a737 1

d829 1
a829 1
	/*
d882 1
a882 1

d897 1
a897 1

d908 1
a908 1
 * collect delay statistics on the upcalls
d916 1
a916 1

d918 1
a918 1

d921 1
a921 1

d925 1
a925 1

d1119 1
a1119 1

d1153 2
a1154 2
	    /*
	     * Send message to routing daemon to install
d1158 1
a1158 1

d1316 1
a1316 1
		ifp, vifi, vifi >= numvifs ? 0 : viftable[vifi].v_ifp);
d1345 1
a1345 1

d1390 1
a1390 1
 * numvifs there,
d1449 1
a1449 1

d1460 1
a1460 1

d1470 1
a1470 1

d1486 1
a1486 1

d1526 1
a1526 1

d1614 1
a1614 1
/*
d1618 1
a1618 1
tbf_queue(vifp, m, ip)
d1638 1
a1638 1
/*
d1672 1
a1672 1
/*
d1685 1
a1685 1
    }
d1702 1
a1702 1
	if (ip_mrouter == NULL)
d1751 1
a1751 1
		  IP_FORWARDING, (void *)NULL, (void *)NULL);
d1764 1
a1764 1
			  IP_FORWARDING|IP_MULTICASTOPTS, &imo, (void *)NULL);
d1806 1
a1806 1

d1841 1
a1841 1
 * End of token bucket filter modifications
d2053 1
a2053 1

@


1.23.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d230 1
a230 1
#define MFCFIND(o, g, rt) do { \
d245 1
a245 1
} while (0)
d251 1
a251 1
#define TV_DELTA(a, b, delta) do { \
d268 1
a268 1
} while (0)
d608 1
a608 2
		snprintf(ifp->if_xname, sizeof ifp->if_xname,
		    "mdecap%d", vifcp->vifc_vifi);
d814 1
a814 1
			log(LOG_DEBUG, "add_mfc update o %x g %x p %x\n",
d845 1
a845 1
				log(LOG_DEBUG, "add_mfc o %x g %x p %x dbg %p\n",
d877 1
a877 1
			log(LOG_DEBUG, "add_mfc no upcall o %x g %x p %x\n",
d910 1
a910 1
	register struct timeval *t;
d912 3
a914 3
	register u_int32_t d;
	register struct timeval tp;
	register u_int32_t delta;
d916 1
a916 1
	microtime(&tp);
d918 2
a919 2
	if (timercmp(t, &tp, <)) {
		TV_DELTA(tp, *t, delta);
d921 3
a923 3
		d = delta >> 10;
		if (d > 50)
			d = 50;
d925 2
a926 2
		++upcall_data[d];
	}
d948 1
a948 2
		    ntohl(mfccp->mfcc_origin.s_addr),
		    ntohl(mfccp->mfcc_mcastgrp.s_addr));
d967 12
a978 13
	struct socket *s;
	struct mbuf *mm;
	struct sockaddr_in *src;
{
	if (s) {
		if (sbappendaddr(&s->so_rcv, sintosa(src), mm,
		    (struct mbuf *)0) != 0) {
			sorwakeup(s);
			return (0);
		}
	}
	m_freem(mm);
	return (-1);
d1001 2
a1002 2
	struct mbuf *m;
	struct ifnet *ifp;
d1004 1
a1004 1
	struct ip_moptions *imo;
d1007 6
a1012 6
	register struct ip *ip = mtod(m, struct ip *);
	register struct mfc *rt;
	register u_char *ipoptions;
	static int srctun = 0;
	register struct mbuf *mm;
	int s;
d1014 2
a1015 2
	register struct vif *vifp;
	vifi_t vifi;
d1018 3
a1020 3
	if (mrtdebug & DEBUG_FORWARD)
		log(LOG_DEBUG, "ip_mforward: src %x, dst %x, ifp %p\n",
		    ntohl(ip->ip_src.s_addr), ntohl(ip->ip_dst.s_addr), ifp);
d1022 14
a1035 15
	if (ip->ip_hl < (IP_HDR_LEN + TUNNEL_LEN) >> 2 ||
	    (ipoptions = (u_char *)(ip + 1))[1] != IPOPT_LSRR) {
		/*
		 * Packet arrived via a physical interface or
		 * an encapuslated tunnel.
		 */
	} else {
		/*
		 * Packet arrived through a source-route tunnel.
		 * Source-route tunnels are no longer supported.
		 */
		if ((srctun++ % 1000) == 0)
			log(LOG_ERR,
			    "ip_mforward: received source-routed packet from %x\n",
			    ntohl(ip->ip_src.s_addr));
d1037 2
a1038 2
		return (1);
	}
d1041 3
a1043 12
	if (imo && ((vifi = imo->imo_multicast_vif) < numvifs)) {
		if (ip->ip_ttl < 255)
			ip->ip_ttl++;	/* compensate for -1 in *_send routines */
		if (rsvpdebug && ip->ip_p == IPPROTO_RSVP) {
			vifp = viftable + vifi;
			printf("Sending IPPROTO_RSVP from %x to %x on vif %d (%s%s)\n",
			    ntohl(ip->ip_src), ntohl(ip->ip_dst), vifi,
			    (vifp->v_flags & VIFF_TUNNEL) ? "tunnel on " : "",
			    vifp->v_ifp->if_xname);
		}
		return (ip_mdq(m, ifp, rt, vifi));
	}
d1045 12
a1056 3
		printf("Warning: IPPROTO_RSVP from %x to %x without vif option\n",
		    ntohl(ip->ip_src), ntohl(ip->ip_dst));
	}
d1059 7
a1065 6
	/*
	 * Don't forward a packet with time-to-live of zero or one,
	 * or a packet destined to a local-only group.
	 */
	if (ip->ip_ttl <= 1 || IN_LOCAL_GROUP(ip->ip_dst.s_addr))
		return (0);
d1067 5
a1071 5
	/*
	 * Determine forwarding vifs from the forwarding cache table
	 */
	s = splsoftnet();
	MFCFIND(ip->ip_src.s_addr, ip->ip_dst.s_addr, rt);
d1073 3
a1075 3
	/* Entry exists, so forward if necessary */
	if (rt != NULL) {
		splx(s);
d1077 1
a1077 1
		return (ip_mdq(m, ifp, rt, -1));
d1079 1
a1079 1
		return (ip_mdq(m, ifp, rt));
d1081 6
a1086 6
	} else {
		/*
		 * If we don't have a route for packet's origin,
		 * Make a copy of the packet &
		 * send message to routing daemon
		 */
d1088 3
a1090 3
		register struct mbuf *mb0;
		register struct rtdetq *rte;
		register u_int32_t hash;
d1092 1
a1092 1
		struct timeval tp;
d1094 1
a1094 1
		microtime(&tp);
d1097 5
a1101 5
		mrtstat.mrts_no_route++;
		if (mrtdebug & (DEBUG_FORWARD | DEBUG_MFC))
			log(LOG_DEBUG, "ip_mforward: no rte s %x g %x\n",
			    ntohl(ip->ip_src.s_addr),
			    ntohl(ip->ip_dst.s_addr));
d1103 15
a1117 15
		/*
		 * Allocate mbufs early so that we don't do extra work if we are
		 * just going to fail anyway.
		 */
		rte = (struct rtdetq *)malloc(sizeof(*rte), M_MRTABLE, M_NOWAIT);
		if (rte == NULL) {
			splx(s);
			return (ENOBUFS);
		}
		mb0 = m_copy(m, 0, M_COPYALL);
		if (mb0 == NULL) {
			free(rte, M_MRTABLE);
			splx(s);
			return (ENOBUFS);
		}
d1119 8
a1126 8
		/* is there an upcall waiting for this packet? */
		hash = MFCHASH(ip->ip_src.s_addr, ip->ip_dst.s_addr);
		for (rt = mfchashtbl[hash].lh_first; rt; rt = rt->mfc_hash.le_next) {
			if (ip->ip_src.s_addr == rt->mfc_origin.s_addr &&
			    ip->ip_dst.s_addr == rt->mfc_mcastgrp.s_addr &&
			    rt->mfc_stall != NULL)
				break;
		}
d1128 23
a1150 26
		if (rt == NULL) {
			int hlen = ip->ip_hl << 2;
			int i;
			struct igmpmsg *im;

			/* no upcall, so make a new entry */
			rt = (struct mfc *)malloc(sizeof(*rt), M_MRTABLE, M_NOWAIT);
			if (rt == NULL) {
				free(rte, M_MRTABLE);
				m_free(mb0);
				splx(s);
				return (ENOBUFS);
			}
			/*
			 * Make a copy of the header to send to the user level
			 * process
			 */
			mm = m_copy(m, 0, hlen);
			M_PULLUP(mm, hlen);
			if (mm == NULL) {
				free(rte, M_MRTABLE);
				m_free(mb0);
				free(rt, M_MRTABLE);
				splx(s);
				return (ENOBUFS);
			}
d1152 21
a1172 22
			/*
			 * Send message to routing daemon to install
			 * a route into the kernel table
			 */
			sin.sin_addr = ip->ip_src;

			im = mtod(mm, struct igmpmsg *);
			im->im_msgtype = IGMPMSG_NOCACHE;
			im->im_mbz = 0;

			mrtstat.mrts_upcalls++;

			if (socket_send(ip_mrouter, mm, &sin) < 0) {
				log(LOG_WARNING,
				    "ip_mforward: ip_mrouter socket queue full\n");
				++mrtstat.mrts_upq_sockfull;
				free(rte, M_MRTABLE);
				m_free(mb0);
				free(rt, M_MRTABLE);
				splx(s);
				return (ENOBUFS);
			}
d1174 40
a1213 29
			/* insert new entry at head of hash chain */
			rt->mfc_origin = ip->ip_src;
			rt->mfc_mcastgrp = ip->ip_dst;
			rt->mfc_pkt_cnt = 0;
			rt->mfc_byte_cnt = 0;
			rt->mfc_wrong_if = 0;
			rt->mfc_expire = UPCALL_EXPIRE;
			nexpire[hash]++;
			for (i = 0; i < numvifs; i++)
				rt->mfc_ttls[i] = 0;
			rt->mfc_parent = -1;

			/* link into table */
			LIST_INSERT_HEAD(&mfchashtbl[hash], rt, mfc_hash);
			/* Add this entry to the end of the queue */
			rt->mfc_stall = rte;
		} else {
			/* determine if q has overflowed */
			struct rtdetq **p;
			register int npkts = 0;

			for (p = &rt->mfc_stall; *p != NULL; p = &(*p)->next)
				if (++npkts > MAX_UPQ) {
					mrtstat.mrts_upq_ovflw++;
					free(rte, M_MRTABLE);
					m_free(mb0);
					splx(s);
					return (0);
				}
a1214 3
			/* Add this entry to the end of the queue */
			*p = rte;
		}
d1216 1
a1216 6
		rte->next = NULL;
		rte->m = mb0;
		rte->ifp = ifp;
	#ifdef UPCALL_TIMING
		rte->t = tp;
	#endif /* UPCALL_TIMING */
d1218 2
a1219 4
		splx(s);

		return (0);
	}
d1242 2
a1243 1
			if (rt->mfc_expire == 0 || --rt->mfc_expire > 0)
d1271 3
a1273 3
	register struct mbuf *m;
	register struct ifnet *ifp;
	register struct mfc *rt;
d1275 1
a1275 1
	register vifi_t xmt_vif;
d1278 4
a1281 4
	register struct ip  *ip = mtod(m, struct ip *);
	register vifi_t vifi;
	register struct vif *vifp;
	register int plen = ip->ip_len;
d1288 6
a1293 6
#define MC_SEND(ip, vifp, m) do {		\
	if ((vifp)->v_flags & VIFF_TUNNEL)	\
		encap_send((ip), (vifp), (m));	\
	else					\
		phyint_send((ip), (vifp), (m));	\
} while (0)
d1296 9
a1304 9
	/*
	 * If xmt_vif is not -1, send on only the requested vif.
	 *
	 * (since vifi_t is u_short, -1 becomes MAXUSHORT, which > numvifs.
	 */
	if (xmt_vif < numvifs) {
		MC_SEND(ip, viftable + xmt_vif, m);
		return (1);
	}
d1307 11
d1319 3
a1321 1
	 * Don't forward if it didn't arrive from the parent vif for its origin.
d1323 10
a1332 40
	vifi = rt->mfc_parent;
	if ((vifi >= numvifs) || (viftable[vifi].v_ifp != ifp)) {
		/* came in the wrong interface */
		if (mrtdebug & DEBUG_FORWARD)
			log(LOG_DEBUG, "wrong if: ifp %p vifi %d vififp %p\n",
			    ifp, vifi,
			    vifi >= numvifs ? 0 : viftable[vifi].v_ifp);
		++mrtstat.mrts_wrong_if;
		++rt->mfc_wrong_if;
		/*
		 * If we are doing PIM assert processing, and we are forwarding
		 * packets on this interface, and it is a broadcast medium
		 * interface (and not a tunnel), send a message to the routing daemon.
		 */
		if (pim_assert && rt->mfc_ttls[vifi] &&
		    (ifp->if_flags & IFF_BROADCAST) &&
		    !(viftable[vifi].v_flags & VIFF_TUNNEL)) {
			struct mbuf *mm;
			struct igmpmsg *im;
			int hlen = ip->ip_hl << 2;
			struct timeval now;
			register u_int32_t delta;

			microtime(&now);

			TV_DELTA(rt->mfc_last_assert, now, delta);

			if (delta > ASSERT_MSG_TIME) {
				mm = m_copy(m, 0, hlen);
				M_PULLUP(mm, hlen);
				if (mm == NULL) {
					return (ENOBUFS);
				}

				rt->mfc_last_assert = now;

				im = mtod(mm, struct igmpmsg *);
				im->im_msgtype	= IGMPMSG_WRONGVIF;
				im->im_mbz	= 0;
				im->im_vif	= vifi;
d1334 1
a1334 1
				sin.sin_addr = im->im_src;
d1336 5
a1340 2
				socket_send(ip_mrouter, m, &sin);
			}
d1342 12
a1353 1
		return (0);
d1355 2
d1358 23
a1380 7
	/* If I sourced this packet, it counts as output, else it was input. */
	if (ip->ip_src.s_addr == viftable[vifi].v_lcl_addr.s_addr) {
		viftable[vifi].v_pkt_out++;
		viftable[vifi].v_bytes_out += plen;
	} else {
		viftable[vifi].v_pkt_in++;
		viftable[vifi].v_bytes_in += plen;
a1381 2
	rt->mfc_pkt_cnt++;
	rt->mfc_byte_cnt += plen;
d1383 1
a1383 15
	/*
	 * For each vif, decide if a copy of the packet should be forwarded.
	 * Forward if:
	 *		- the ttl exceeds the vif's threshold
	 *		- there are group members downstream on interface
	 */
	for (vifp = viftable, vifi = 0; vifi < numvifs; vifp++, vifi++)
		if ((rt->mfc_ttls[vifi] > 0) &&
			(ip->ip_ttl > rt->mfc_ttls[vifi])) {
			vifp->v_pkt_out++;
			vifp->v_bytes_out += plen;
			MC_SEND(ip, vifp, m);
		}

	return (0);
d1393 1
a1393 1
	int vif;
d1395 4
a1398 4
	if (vif >= 0 && vif < numvifs)
		return (1);
	else
		return (0);
d1618 13
a1630 13
	register struct vif *vifp;
	register struct mbuf *m;
	register struct ip *ip;
{
	register u_int32_t ql;
	register int index = (vifp - viftable);
	register int s = splsoftnet();

	ql = vifp->v_tbf.q_len;

	qtable[index][ql].pkt_m = m;
	qtable[index][ql].pkt_len = (mtod(m, struct ip *))->ip_len;
	qtable[index][ql].pkt_ip = ip;
d1632 2
a1633 2
	vifp->v_tbf.q_len++;
	splx(s);
d1642 1
a1642 1
	register struct vif *vifp;
d1644 18
a1661 3
	register struct pkt_queue pkt_1;
	register int index = (vifp - viftable);
	register int s = splsoftnet();
d1663 6
a1668 21
	/* loop through the queue at the interface and send as many packets
	 * as possible
	 */
	while (vifp->v_tbf.q_len > 0) {
		/* locate the first packet */
		pkt_1 = qtable[index][0];

		/* determine if the packet can be sent */
		if (pkt_1.pkt_len <= vifp->v_tbf.n_tok) {
			/* if so,
			 * reduce no of tokens, dequeue the queue,
			 * send the packet.
			 */
			vifp->v_tbf.n_tok -= pkt_1.pkt_len;

			tbf_dequeue(vifp, 0);
			tbf_send_packet(vifp, pkt_1.pkt_m);
		} else
			break;
	}
	splx(s);
d1676 2
a1677 2
	register struct vif *vifp;
	register int j;
d1679 2
a1680 2
	register u_int32_t index = vifp - viftable;
	register int i;
d1682 6
a1687 6
	for (i = j + 1; i <= vifp->v_tbf.q_len - 1; i++) {
		qtable[index][i-1] = qtable[index][i];
	}
	qtable[index][i-1].pkt_m = NULL;
	qtable[index][i-1].pkt_len = NULL;
	qtable[index][i-1].pkt_ip = NULL;
d1689 1
a1689 1
	vifp->v_tbf.q_len--;
d1691 2
a1692 3
	if (tbfdebug > 1)
		log(LOG_DEBUG, "tbf_dequeue: vif# %d qlen %d\n",
		    vifp - viftable, i - 1);
d1717 2
a1718 2
	register struct vif *vifp;
	register struct ip *ip;
d1720 17
a1736 17
	register int i;
	register int s = splsoftnet();
	register u_int p;

	p = priority(vifp, ip);

	for (i = vifp->v_tbf.q_len - 1; i >= 0; i--) {
		if (p > priority(vifp, qtable[vifp-viftable][i].pkt_ip)) {
			m_freem(qtable[vifp-viftable][i].pkt_m);
			tbf_dequeue(vifp, i);
			splx(s);
			mrtstat.mrts_drop_sel++;
			return (1);
		}
	}
	splx(s);
	return (0);
d1740 18
a1757 18
tbf_send_packet(vifp, m)
	register struct vif *vifp;
	register struct mbuf *m;
{
	int error;
	int s = splsoftnet();

	if (vifp->v_flags & VIFF_TUNNEL) {
		/* If tunnel options */
		ip_output(m, (struct mbuf *)0, &vifp->v_route,
		    IP_FORWARDING, (void *)NULL, (void *)NULL);
	} else {
		/* if physical interface option, extract the options and then send */
		struct ip *ip = mtod(m, struct ip *);
		struct ip_moptions imo;
		imo.imo_multicast_ifp = vifp->v_ifp;
		imo.imo_multicast_ttl = ip->ip_ttl - 1;
		imo.imo_multicast_loop = 1;
d1759 1
a1759 1
		imo.imo_multicast_vif = -1;
d1762 6
a1767 7
		error = ip_output(m, (struct mbuf *)0, (struct route *)0,
		    IP_FORWARDING|IP_MULTICASTOPTS, &imo, (void *)NULL);
		if (mrtdebug & DEBUG_XMIT)
			log(LOG_DEBUG, "phyint_send on vif %d err %d\n",
			    vifp - viftable, error);
	}
	splx(s);
d1776 1
a1776 1
	register struct vif *vifp;
d1778 4
a1781 4
	struct timeval tp;
	register u_int32_t t;
	register u_int32_t elapsed;
	register int s = splsoftnet();
d1783 1
a1783 1
	microtime(&tp);
d1785 1
a1785 1
	t = tp.tv_sec * 1000 + tp.tv_usec / 1000;
d1787 3
a1789 3
	elapsed = (t - vifp->v_tbf.last_pkt_t) * vifp->v_rate_limit / 8;
	vifp->v_tbf.n_tok += elapsed;
	vifp->v_tbf.last_pkt_t = t;
d1791 2
a1792 2
	if (vifp->v_tbf.n_tok > MAX_BKT_SIZE)
		vifp->v_tbf.n_tok = MAX_BKT_SIZE;
d1794 1
a1794 1
	splx(s);
d1799 2
a1800 2
	register struct vif *vifp;
	register struct ip *ip;
d1802 1
a1802 1
	register int prio;
d1804 1
a1804 1
	/* temporary hack; may add general packet classifier some day */
d1806 24
a1829 9
	/*
	 * The UDP port space is divided up into four priority ranges:
	 * [0, 16384)     : unclassified - lowest priority
	 * [16384, 32768) : audio - highest priority
	 * [32768, 49152) : whiteboard - medium priority
	 * [49152, 65536) : video - low priority
	 */
	if (ip->ip_p == IPPROTO_UDP) {
		struct udphdr *udp = (struct udphdr *)(((char *)ip) + (ip->ip_hl << 2));
d1831 3
a1833 14
		switch (ntohs(udp->uh_dport) & 0xc000) {
		case 0x4000:
			prio = 70;
			break;
		case 0x8000:
			prio = 60;
			break;
		case 0xc000:
			prio = 55;
			break;
		default:
			prio = 50;
			break;
		}
a1834 5
		if (tbfdebug > 1)
			log(LOG_DEBUG, "port %x prio %d\n",
			    ntohs(udp->uh_dport), prio);
	} else
		prio = 50;
d1836 1
a1836 1
	return (prio);
d1842 1
d1844 1
d1847 2
a1848 2
	struct socket *so;
	struct mbuf *m;
d1850 2
a1851 2
	int i;
	register int s;
d1853 3
a1855 3
	if (rsvpdebug)
		printf("ip_rsvp_vif_init: so_type = %d, pr_protocol = %d\n",
		    so->so_type, so->so_proto->pr_protocol);
d1857 2
a1858 3
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
		return (EOPNOTSUPP);
d1860 5
a1864 5
	/* Check mbuf. */
	if (m == NULL || m->m_len != sizeof(int)) {
		return (EINVAL);
	}
	i = *(mtod(m, int *));
d1866 2
a1867 2
	if (rsvpdebug)
		printf("ip_rsvp_vif_init: vif = %d rsvp_on = %d\n", i, rsvp_on);
d1869 1
a1869 1
	s = splsoftnet();
d1871 5
a1875 5
	/* Check vif. */
	if (!legal_vif_num(i)) {
		splx(s);
		return (EADDRNOTAVAIL);
	}
d1877 5
a1881 5
	/* Check if socket is available. */
	if (viftable[i].v_rsvpd != NULL) {
		splx(s);
		return (EADDRINUSE);
	}
d1883 8
a1890 8
	viftable[i].v_rsvpd = so;
	/* This may seem silly, but we need to be sure we don't over-increment
	 * the RSVP counter, in case something slips up.
	 */
	if (!viftable[i].v_rsvp_on) {
		viftable[i].v_rsvp_on = 1;
		rsvp_on++;
	}
d1892 2
a1893 2
	splx(s);
	return (0);
d1898 2
a1899 2
	struct socket *so;
	struct mbuf *m;
d1901 2
a1902 2
	int i;
	register int s;
d1904 3
a1906 3
	if (rsvpdebug)
		printf("ip_rsvp_vif_done: so_type = %d, pr_protocol = %d\n",
		    so->so_type, so->so_proto->pr_protocol);
d1908 2
a1909 3
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
		return (EOPNOTSUPP);
d1911 5
a1915 5
	/* Check mbuf. */
	if (m == NULL || m->m_len != sizeof(int)) {
		return (EINVAL);
	}
	i = *(mtod(m, int *));
d1917 1
a1917 1
	s = splsoftnet();
d1919 5
a1923 5
	/* Check vif. */
	if (!legal_vif_num(i)) {
		splx(s);
		return (EADDRNOTAVAIL);
	}
d1925 12
a1936 3
	if (rsvpdebug)
		printf("ip_rsvp_vif_done: v_rsvpd = %x so = %x\n",
		    viftable[i].v_rsvpd, so);
d1938 2
a1939 12
	viftable[i].v_rsvpd = NULL;
	/*
	 * This may seem silly, but we need to be sure we don't over-decrement
	 * the RSVP counter, in case something slips up.
	 */
	if (viftable[i].v_rsvp_on) {
		viftable[i].v_rsvp_on = 0;
		rsvp_on--;
	}

	splx(s);
	return (0);
d1944 1
a1944 1
	struct socket *so;
d1946 2
a1947 2
	int vifi;
	register int s;
d1949 3
a1951 4
	/* Don't bother if it is not the right type of socket. */
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
		return;
d1953 1
a1953 1
	s = splsoftnet();
d1955 13
a1967 17
	/*
	 * The socket may be attached to more than one vif...this
	 * is perfectly legal.
	 */
	for (vifi = 0; vifi < numvifs; vifi++) {
		if (viftable[vifi].v_rsvpd == so) {
			viftable[vifi].v_rsvpd = NULL;
			/*
			 * This may seem silly, but we need to be sure we don't
			 * over-decrement the RSVP counter, in case something
			 * slips up.
			 */
			if (viftable[vifi].v_rsvp_on) {
				viftable[vifi].v_rsvp_on = 0;
				rsvp_on--;
			}
		}
d1969 1
d1971 2
a1972 2
	splx(s);
	return;
d1977 2
a1978 2
	struct mbuf *m;
	struct ifnet *ifp;
d1980 16
a1995 4
	int vifi;
	register struct ip *ip = mtod(m, struct ip *);
	static struct sockaddr_in rsvp_src = { sizeof(sin), AF_INET };
	register int s;
d1997 4
d2002 4
a2005 1
		printf("rsvp_input: rsvp_on %d\n", rsvp_on);
d2007 1
a2007 9
	/*
	 * Can still get packets with rsvp_on = 0 if there is a local member
	 * of the group to which the RSVP packet is addressed.  But in this
	 * case we want to throw the packet away.
	 */
	if (!rsvp_on) {
		m_freem(m);
		return;
	}
d2009 2
a2010 11
	/*
	 * If the old-style non-vif-associated socket is set, then use
	 * it and ignore the new ones.
	 */
	if (ip_rsvpd != NULL) {
		if (rsvpdebug)
			printf("rsvp_input: "
			    "Sending packet up old-style socket\n");
		rip_input(m, 0);
		return;
	}
d2012 5
a2016 1
	s = splsoftnet();
d2018 2
d2021 5
a2025 1
		printf("rsvp_input: check vifs\n");
d2027 2
a2028 15
	/* Find which vif the packet arrived on. */
	for (vifi = 0; vifi < numvifs; vifi++) {
		if (viftable[vifi].v_ifp == ifp)
			break;
	}

	if (vifi == numvifs) {
		/* Can't find vif packet arrived on. Drop packet. */
		if (rsvpdebug)
			printf("rsvp_input: "
			    "Can't find vif for packet...dropping it.\n");
		m_freem(m);
		splx(s);
		return;
	}
d2030 3
d2034 5
a2038 1
		printf("rsvp_input: check socket\n");
d2040 1
a2040 12
	if (viftable[vifi].v_rsvpd == NULL) {
		/*
	 	 * drop packet, since there is no specific socket for this
		 * interface
		 */
		if (rsvpdebug)
			printf("rsvp_input: No socket defined for vif %d\n",
			    vifi);
		m_freem(m);
		splx(s);
		return;
	}
d2042 3
a2044 1
	rsvp_src.sin_addr = ip->ip_src;
d2046 6
a2051 10
	if (rsvpdebug && m)
		printf("rsvp_input: m->m_len = %d, sbspace() = %d\n",
		    m->m_len, sbspace(&viftable[vifi].v_rsvpd->so_rcv));

	if (socket_send(viftable[vifi].v_rsvpd, m, &rsvp_src) < 0)
		if (rsvpdebug)
			printf("rsvp_input: Failed to append to socket\n");
	else
		if (rsvpdebug)
			printf("rsvp_input: send packet up\n");
d2053 1
a2053 1
	splx(s);
@


1.22
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.21 2001/06/23 16:15:56 fgsch Exp $	*/
d3 40
@


1.21
log
@Remove unneeded ip_id convertions.
Instead of using HTONS macro in some places, use htons directly in the
struct member and save us a few bytes.
Fix comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.20 2000/11/10 15:33:10 provos Exp $	*/
d29 2
d34 1
d88 2
d421 2
a422 1
	timeout(expire_upcalls, (caddr_t)0, EXPIRE_TIMEOUT);
d454 1
a454 1
	untimeout(expire_upcalls, (caddr_t)NULL);
d1220 1
a1220 1
	timeout(expire_upcalls, (caddr_t)0, EXPIRE_TIMEOUT);
d1563 2
a1564 1
			timeout(tbf_reprocess_q, vifp, 1);
d1675 1
a1675 1
		timeout(tbf_reprocess_q, vifp, 1);
@


1.20
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.19 2000/01/21 03:15:05 angelos Exp $	*/
d1420 1
a1420 2
	ip_copy->ip_id = ip_randomid();
	HTONS(ip_copy->ip_id);
@


1.19
log
@Rename the ip4_* routines to ipip_*, make it so GIF tunnels are not
affected by net.inet.ipip.allow (the sysctl formerly known as
net.inet.ip4.allow), rename the VIF ipip_input to ipip_mroute_input.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.18 1999/08/08 15:04:22 niklas Exp $	*/
d1241 1
a1241 1
 * seperate.
@


1.19.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.20 2000/11/10 15:33:10 provos Exp $	*/
d1241 1
a1241 1
 * separate.
@


1.19.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.19.2.1 2001/05/14 22:40:12 niklas Exp $	*/
d1420 2
a1421 1
	ip_copy->ip_id = htons(ip_randomid());
@


1.19.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.19.2.2 2001/07/04 10:54:53 niklas Exp $	*/
a4 40
 * Copyright (c) 1989 Stephen Deering
 * Copyright (c) 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)ip_mroute.c 8.2 (Berkeley) 11/15/93
 * $Id$
 */

/*
a28 2
#include <sys/timeout.h>

a31 1

a84 2
struct timeout	upcalls_timeout;
struct timeout	tbf_timeout;
d416 1
a416 2
	timeout_set(&upcalls_timeout, expire_upcalls, NULL);
	timeout_add(&upcalls_timeout, EXPIRE_TIMEOUT);
d448 1
a448 1
	timeout_del(&upcalls_timeout);
d1214 1
a1214 1
	timeout_add(&upcalls_timeout, EXPIRE_TIMEOUT);
d1557 1
a1557 2
			timeout_set(&tbf_timeout, tbf_reprocess_q, vifp);
			timeout_add(&tbf_timeout, 1);
d1668 1
a1668 1
		timeout_add(&tbf_timeout, 1);
@


1.19.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d138 11
a148 11
static int get_sg_cnt(struct sioc_sg_req *);
static int get_vif_cnt(struct sioc_vif_req *);
static int ip_mrouter_init(struct socket *, struct mbuf *);
static int get_version(struct mbuf *);
static int set_assert(struct mbuf *);
static int get_assert(struct mbuf *);
static int add_vif(struct mbuf *);
static int del_vif(struct mbuf *);
static void update_mfc(struct mfcctl *, struct mfc *);
static void expire_mfc(struct mfc *);
static int add_mfc(struct mbuf *);
d150 1
a150 1
static void collate(struct timeval *);
d152 4
a155 4
static int del_mfc(struct mbuf *);
static int socket_send(struct socket *, struct mbuf *,
			    struct sockaddr_in *);
static void expire_upcalls(void *);
d157 1
a157 1
static int ip_mdq(struct mbuf *, struct ifnet *, struct mfc *, vifi_t);
d159 1
a159 1
static int ip_mdq(struct mbuf *, struct ifnet *, struct mfc *);
d161 12
a172 12
static void phyint_send(struct ip *, struct vif *, struct mbuf *);
static void encap_send(struct ip *, struct vif *, struct mbuf *);
static void tbf_control(struct vif *, struct mbuf *, struct ip *,
			     u_int32_t);
static void tbf_queue(struct vif *, struct mbuf *, struct ip *);
static void tbf_process_q(struct vif *);
static void tbf_dequeue(struct vif *, int);
static void tbf_reprocess_q(void *);
static int tbf_dq_sel(struct vif *, struct ip *);
static void tbf_send_packet(struct vif *, struct mbuf *);
static void tbf_update_tokens(struct vif *);
static int priority(struct vif *, struct ip *);
d1499 1
d1501 5
@


1.19.2.5
log
@Sync the SMP branch with 3.3
@
text
@d41 1
d133 1
a133 1
 * qtable   -> each interface has an associated queue of pkts
d200 1
a200 1
	ENCAP_TTL, ENCAP_PROTO,
d480 1
a480 1

d493 1
a493 1

d495 1
a495 1

d504 1
a504 1

d511 1
a511 1

d514 1
a514 1

d516 1
a516 1

d518 1
a518 1

d521 1
a521 1

d582 1
a582 1

d593 1
a593 1

d599 1
a599 1

d626 1
a626 1

d635 1
a635 1

d641 1
a641 1

d658 1
a658 1

d662 1
a662 1

d665 1
a665 1
		    vifcp->vifc_vifi,
d670 2
a671 2
		    vifcp->vifc_rate_limit);

d709 1
a709 1

d720 1
a720 1

d722 1
a722 1

d724 1
a724 1

d726 1
a726 1

d732 1
a732 1

d734 1
a734 1

d737 1
a737 1

d829 1
a829 1
	/*
d882 1
a882 1

d897 1
a897 1

d908 1
a908 1
 * collect delay statistics on the upcalls
d916 1
a916 1

d918 1
a918 1

d921 1
a921 1

d925 1
a925 1

d1119 1
a1119 1

d1153 2
a1154 2
	    /*
	     * Send message to routing daemon to install
d1158 1
a1158 1

d1316 1
a1316 1
		ifp, vifi, vifi >= numvifs ? 0 : viftable[vifi].v_ifp);
d1345 1
a1345 1

d1390 1
a1390 1
 * numvifs there,
d1449 1
a1449 1

d1460 1
a1460 1

d1470 1
a1470 1

d1486 1
a1486 1

d1526 1
a1526 1

d1614 1
a1614 1
/*
d1618 1
a1618 1
tbf_queue(vifp, m, ip)
d1638 1
a1638 1
/*
d1672 1
a1672 1
/*
d1685 1
a1685 1
    }
d1702 1
a1702 1
	if (ip_mrouter == NULL)
d1751 1
a1751 1
		  IP_FORWARDING, (void *)NULL, (void *)NULL);
d1764 1
a1764 1
			  IP_FORWARDING|IP_MULTICASTOPTS, &imo, (void *)NULL);
d1806 1
a1806 1

d1841 1
a1841 1
 * End of token bucket filter modifications
d2053 1
a2053 1

@


1.19.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.19.2.5 2003/03/28 00:06:54 niklas Exp $	*/
d608 1
a608 2
		snprintf(ifp->if_xname, sizeof ifp->if_xname,
		    "mdecap%d", vifcp->vifc_vifi);
@


1.19.2.7
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d230 1
a230 1
#define MFCFIND(o, g, rt) do { \
d245 1
a245 1
} while (0)
d251 1
a251 1
#define TV_DELTA(a, b, delta) do { \
d268 1
a268 1
} while (0)
d815 1
a815 1
			log(LOG_DEBUG, "add_mfc update o %x g %x p %x\n",
d846 1
a846 1
				log(LOG_DEBUG, "add_mfc o %x g %x p %x dbg %p\n",
d878 1
a878 1
			log(LOG_DEBUG, "add_mfc no upcall o %x g %x p %x\n",
d911 1
a911 1
	register struct timeval *t;
d913 3
a915 3
	register u_int32_t d;
	register struct timeval tp;
	register u_int32_t delta;
d917 1
a917 1
	microtime(&tp);
d919 2
a920 2
	if (timercmp(t, &tp, <)) {
		TV_DELTA(tp, *t, delta);
d922 3
a924 3
		d = delta >> 10;
		if (d > 50)
			d = 50;
d926 2
a927 2
		++upcall_data[d];
	}
d949 1
a949 2
		    ntohl(mfccp->mfcc_origin.s_addr),
		    ntohl(mfccp->mfcc_mcastgrp.s_addr));
d968 12
a979 13
	struct socket *s;
	struct mbuf *mm;
	struct sockaddr_in *src;
{
	if (s) {
		if (sbappendaddr(&s->so_rcv, sintosa(src), mm,
		    (struct mbuf *)0) != 0) {
			sorwakeup(s);
			return (0);
		}
	}
	m_freem(mm);
	return (-1);
d1002 2
a1003 2
	struct mbuf *m;
	struct ifnet *ifp;
d1005 1
a1005 1
	struct ip_moptions *imo;
d1008 6
a1013 6
	register struct ip *ip = mtod(m, struct ip *);
	register struct mfc *rt;
	register u_char *ipoptions;
	static int srctun = 0;
	register struct mbuf *mm;
	int s;
d1015 2
a1016 2
	register struct vif *vifp;
	vifi_t vifi;
d1019 3
a1021 3
	if (mrtdebug & DEBUG_FORWARD)
		log(LOG_DEBUG, "ip_mforward: src %x, dst %x, ifp %p\n",
		    ntohl(ip->ip_src.s_addr), ntohl(ip->ip_dst.s_addr), ifp);
d1023 14
a1036 15
	if (ip->ip_hl < (IP_HDR_LEN + TUNNEL_LEN) >> 2 ||
	    (ipoptions = (u_char *)(ip + 1))[1] != IPOPT_LSRR) {
		/*
		 * Packet arrived via a physical interface or
		 * an encapuslated tunnel.
		 */
	} else {
		/*
		 * Packet arrived through a source-route tunnel.
		 * Source-route tunnels are no longer supported.
		 */
		if ((srctun++ % 1000) == 0)
			log(LOG_ERR,
			    "ip_mforward: received source-routed packet from %x\n",
			    ntohl(ip->ip_src.s_addr));
d1038 2
a1039 2
		return (1);
	}
d1042 3
a1044 12
	if (imo && ((vifi = imo->imo_multicast_vif) < numvifs)) {
		if (ip->ip_ttl < 255)
			ip->ip_ttl++;	/* compensate for -1 in *_send routines */
		if (rsvpdebug && ip->ip_p == IPPROTO_RSVP) {
			vifp = viftable + vifi;
			printf("Sending IPPROTO_RSVP from %x to %x on vif %d (%s%s)\n",
			    ntohl(ip->ip_src), ntohl(ip->ip_dst), vifi,
			    (vifp->v_flags & VIFF_TUNNEL) ? "tunnel on " : "",
			    vifp->v_ifp->if_xname);
		}
		return (ip_mdq(m, ifp, rt, vifi));
	}
d1046 12
a1057 3
		printf("Warning: IPPROTO_RSVP from %x to %x without vif option\n",
		    ntohl(ip->ip_src), ntohl(ip->ip_dst));
	}
d1060 7
a1066 6
	/*
	 * Don't forward a packet with time-to-live of zero or one,
	 * or a packet destined to a local-only group.
	 */
	if (ip->ip_ttl <= 1 || IN_LOCAL_GROUP(ip->ip_dst.s_addr))
		return (0);
d1068 5
a1072 5
	/*
	 * Determine forwarding vifs from the forwarding cache table
	 */
	s = splsoftnet();
	MFCFIND(ip->ip_src.s_addr, ip->ip_dst.s_addr, rt);
d1074 3
a1076 3
	/* Entry exists, so forward if necessary */
	if (rt != NULL) {
		splx(s);
d1078 1
a1078 1
		return (ip_mdq(m, ifp, rt, -1));
d1080 1
a1080 1
		return (ip_mdq(m, ifp, rt));
d1082 6
a1087 6
	} else {
		/*
		 * If we don't have a route for packet's origin,
		 * Make a copy of the packet &
		 * send message to routing daemon
		 */
d1089 3
a1091 3
		register struct mbuf *mb0;
		register struct rtdetq *rte;
		register u_int32_t hash;
d1093 1
a1093 1
		struct timeval tp;
d1095 1
a1095 1
		microtime(&tp);
d1098 5
a1102 5
		mrtstat.mrts_no_route++;
		if (mrtdebug & (DEBUG_FORWARD | DEBUG_MFC))
			log(LOG_DEBUG, "ip_mforward: no rte s %x g %x\n",
			    ntohl(ip->ip_src.s_addr),
			    ntohl(ip->ip_dst.s_addr));
d1104 15
a1118 15
		/*
		 * Allocate mbufs early so that we don't do extra work if we are
		 * just going to fail anyway.
		 */
		rte = (struct rtdetq *)malloc(sizeof(*rte), M_MRTABLE, M_NOWAIT);
		if (rte == NULL) {
			splx(s);
			return (ENOBUFS);
		}
		mb0 = m_copy(m, 0, M_COPYALL);
		if (mb0 == NULL) {
			free(rte, M_MRTABLE);
			splx(s);
			return (ENOBUFS);
		}
d1120 8
a1127 8
		/* is there an upcall waiting for this packet? */
		hash = MFCHASH(ip->ip_src.s_addr, ip->ip_dst.s_addr);
		for (rt = mfchashtbl[hash].lh_first; rt; rt = rt->mfc_hash.le_next) {
			if (ip->ip_src.s_addr == rt->mfc_origin.s_addr &&
			    ip->ip_dst.s_addr == rt->mfc_mcastgrp.s_addr &&
			    rt->mfc_stall != NULL)
				break;
		}
d1129 23
a1151 26
		if (rt == NULL) {
			int hlen = ip->ip_hl << 2;
			int i;
			struct igmpmsg *im;

			/* no upcall, so make a new entry */
			rt = (struct mfc *)malloc(sizeof(*rt), M_MRTABLE, M_NOWAIT);
			if (rt == NULL) {
				free(rte, M_MRTABLE);
				m_free(mb0);
				splx(s);
				return (ENOBUFS);
			}
			/*
			 * Make a copy of the header to send to the user level
			 * process
			 */
			mm = m_copy(m, 0, hlen);
			M_PULLUP(mm, hlen);
			if (mm == NULL) {
				free(rte, M_MRTABLE);
				m_free(mb0);
				free(rt, M_MRTABLE);
				splx(s);
				return (ENOBUFS);
			}
d1153 21
a1173 22
			/*
			 * Send message to routing daemon to install
			 * a route into the kernel table
			 */
			sin.sin_addr = ip->ip_src;

			im = mtod(mm, struct igmpmsg *);
			im->im_msgtype = IGMPMSG_NOCACHE;
			im->im_mbz = 0;

			mrtstat.mrts_upcalls++;

			if (socket_send(ip_mrouter, mm, &sin) < 0) {
				log(LOG_WARNING,
				    "ip_mforward: ip_mrouter socket queue full\n");
				++mrtstat.mrts_upq_sockfull;
				free(rte, M_MRTABLE);
				m_free(mb0);
				free(rt, M_MRTABLE);
				splx(s);
				return (ENOBUFS);
			}
d1175 40
a1214 29
			/* insert new entry at head of hash chain */
			rt->mfc_origin = ip->ip_src;
			rt->mfc_mcastgrp = ip->ip_dst;
			rt->mfc_pkt_cnt = 0;
			rt->mfc_byte_cnt = 0;
			rt->mfc_wrong_if = 0;
			rt->mfc_expire = UPCALL_EXPIRE;
			nexpire[hash]++;
			for (i = 0; i < numvifs; i++)
				rt->mfc_ttls[i] = 0;
			rt->mfc_parent = -1;

			/* link into table */
			LIST_INSERT_HEAD(&mfchashtbl[hash], rt, mfc_hash);
			/* Add this entry to the end of the queue */
			rt->mfc_stall = rte;
		} else {
			/* determine if q has overflowed */
			struct rtdetq **p;
			register int npkts = 0;

			for (p = &rt->mfc_stall; *p != NULL; p = &(*p)->next)
				if (++npkts > MAX_UPQ) {
					mrtstat.mrts_upq_ovflw++;
					free(rte, M_MRTABLE);
					m_free(mb0);
					splx(s);
					return (0);
				}
a1215 3
			/* Add this entry to the end of the queue */
			*p = rte;
		}
d1217 1
a1217 6
		rte->next = NULL;
		rte->m = mb0;
		rte->ifp = ifp;
	#ifdef UPCALL_TIMING
		rte->t = tp;
	#endif /* UPCALL_TIMING */
d1219 2
a1220 4
		splx(s);

		return (0);
	}
d1243 2
a1244 1
			if (rt->mfc_expire == 0 || --rt->mfc_expire > 0)
d1272 3
a1274 3
	register struct mbuf *m;
	register struct ifnet *ifp;
	register struct mfc *rt;
d1276 1
a1276 1
	register vifi_t xmt_vif;
d1279 4
a1282 4
	register struct ip  *ip = mtod(m, struct ip *);
	register vifi_t vifi;
	register struct vif *vifp;
	register int plen = ip->ip_len;
d1289 6
a1294 6
#define MC_SEND(ip, vifp, m) do {		\
	if ((vifp)->v_flags & VIFF_TUNNEL)	\
		encap_send((ip), (vifp), (m));	\
	else					\
		phyint_send((ip), (vifp), (m));	\
} while (0)
d1297 9
a1305 9
	/*
	 * If xmt_vif is not -1, send on only the requested vif.
	 *
	 * (since vifi_t is u_short, -1 becomes MAXUSHORT, which > numvifs.
	 */
	if (xmt_vif < numvifs) {
		MC_SEND(ip, viftable + xmt_vif, m);
		return (1);
	}
d1308 11
d1320 3
a1322 1
	 * Don't forward if it didn't arrive from the parent vif for its origin.
d1324 10
a1333 40
	vifi = rt->mfc_parent;
	if ((vifi >= numvifs) || (viftable[vifi].v_ifp != ifp)) {
		/* came in the wrong interface */
		if (mrtdebug & DEBUG_FORWARD)
			log(LOG_DEBUG, "wrong if: ifp %p vifi %d vififp %p\n",
			    ifp, vifi,
			    vifi >= numvifs ? 0 : viftable[vifi].v_ifp);
		++mrtstat.mrts_wrong_if;
		++rt->mfc_wrong_if;
		/*
		 * If we are doing PIM assert processing, and we are forwarding
		 * packets on this interface, and it is a broadcast medium
		 * interface (and not a tunnel), send a message to the routing daemon.
		 */
		if (pim_assert && rt->mfc_ttls[vifi] &&
		    (ifp->if_flags & IFF_BROADCAST) &&
		    !(viftable[vifi].v_flags & VIFF_TUNNEL)) {
			struct mbuf *mm;
			struct igmpmsg *im;
			int hlen = ip->ip_hl << 2;
			struct timeval now;
			register u_int32_t delta;

			microtime(&now);

			TV_DELTA(rt->mfc_last_assert, now, delta);

			if (delta > ASSERT_MSG_TIME) {
				mm = m_copy(m, 0, hlen);
				M_PULLUP(mm, hlen);
				if (mm == NULL) {
					return (ENOBUFS);
				}

				rt->mfc_last_assert = now;

				im = mtod(mm, struct igmpmsg *);
				im->im_msgtype	= IGMPMSG_WRONGVIF;
				im->im_mbz	= 0;
				im->im_vif	= vifi;
d1335 1
a1335 1
				sin.sin_addr = im->im_src;
d1337 5
a1341 2
				socket_send(ip_mrouter, m, &sin);
			}
d1343 12
a1354 1
		return (0);
d1356 2
d1359 23
a1381 7
	/* If I sourced this packet, it counts as output, else it was input. */
	if (ip->ip_src.s_addr == viftable[vifi].v_lcl_addr.s_addr) {
		viftable[vifi].v_pkt_out++;
		viftable[vifi].v_bytes_out += plen;
	} else {
		viftable[vifi].v_pkt_in++;
		viftable[vifi].v_bytes_in += plen;
a1382 2
	rt->mfc_pkt_cnt++;
	rt->mfc_byte_cnt += plen;
d1384 1
a1384 15
	/*
	 * For each vif, decide if a copy of the packet should be forwarded.
	 * Forward if:
	 *		- the ttl exceeds the vif's threshold
	 *		- there are group members downstream on interface
	 */
	for (vifp = viftable, vifi = 0; vifi < numvifs; vifp++, vifi++)
		if ((rt->mfc_ttls[vifi] > 0) &&
			(ip->ip_ttl > rt->mfc_ttls[vifi])) {
			vifp->v_pkt_out++;
			vifp->v_bytes_out += plen;
			MC_SEND(ip, vifp, m);
		}

	return (0);
d1394 1
a1394 1
	int vif;
d1396 4
a1399 4
	if (vif >= 0 && vif < numvifs)
		return (1);
	else
		return (0);
d1619 13
a1631 13
	register struct vif *vifp;
	register struct mbuf *m;
	register struct ip *ip;
{
	register u_int32_t ql;
	register int index = (vifp - viftable);
	register int s = splsoftnet();

	ql = vifp->v_tbf.q_len;

	qtable[index][ql].pkt_m = m;
	qtable[index][ql].pkt_len = (mtod(m, struct ip *))->ip_len;
	qtable[index][ql].pkt_ip = ip;
d1633 2
a1634 2
	vifp->v_tbf.q_len++;
	splx(s);
d1643 1
a1643 1
	register struct vif *vifp;
d1645 18
a1662 3
	register struct pkt_queue pkt_1;
	register int index = (vifp - viftable);
	register int s = splsoftnet();
d1664 6
a1669 21
	/* loop through the queue at the interface and send as many packets
	 * as possible
	 */
	while (vifp->v_tbf.q_len > 0) {
		/* locate the first packet */
		pkt_1 = qtable[index][0];

		/* determine if the packet can be sent */
		if (pkt_1.pkt_len <= vifp->v_tbf.n_tok) {
			/* if so,
			 * reduce no of tokens, dequeue the queue,
			 * send the packet.
			 */
			vifp->v_tbf.n_tok -= pkt_1.pkt_len;

			tbf_dequeue(vifp, 0);
			tbf_send_packet(vifp, pkt_1.pkt_m);
		} else
			break;
	}
	splx(s);
d1677 2
a1678 2
	register struct vif *vifp;
	register int j;
d1680 2
a1681 2
	register u_int32_t index = vifp - viftable;
	register int i;
d1683 6
a1688 6
	for (i = j + 1; i <= vifp->v_tbf.q_len - 1; i++) {
		qtable[index][i-1] = qtable[index][i];
	}
	qtable[index][i-1].pkt_m = NULL;
	qtable[index][i-1].pkt_len = NULL;
	qtable[index][i-1].pkt_ip = NULL;
d1690 1
a1690 1
	vifp->v_tbf.q_len--;
d1692 2
a1693 3
	if (tbfdebug > 1)
		log(LOG_DEBUG, "tbf_dequeue: vif# %d qlen %d\n",
		    vifp - viftable, i - 1);
d1718 2
a1719 2
	register struct vif *vifp;
	register struct ip *ip;
d1721 17
a1737 17
	register int i;
	register int s = splsoftnet();
	register u_int p;

	p = priority(vifp, ip);

	for (i = vifp->v_tbf.q_len - 1; i >= 0; i--) {
		if (p > priority(vifp, qtable[vifp-viftable][i].pkt_ip)) {
			m_freem(qtable[vifp-viftable][i].pkt_m);
			tbf_dequeue(vifp, i);
			splx(s);
			mrtstat.mrts_drop_sel++;
			return (1);
		}
	}
	splx(s);
	return (0);
d1741 18
a1758 18
tbf_send_packet(vifp, m)
	register struct vif *vifp;
	register struct mbuf *m;
{
	int error;
	int s = splsoftnet();

	if (vifp->v_flags & VIFF_TUNNEL) {
		/* If tunnel options */
		ip_output(m, (struct mbuf *)0, &vifp->v_route,
		    IP_FORWARDING, (void *)NULL, (void *)NULL);
	} else {
		/* if physical interface option, extract the options and then send */
		struct ip *ip = mtod(m, struct ip *);
		struct ip_moptions imo;
		imo.imo_multicast_ifp = vifp->v_ifp;
		imo.imo_multicast_ttl = ip->ip_ttl - 1;
		imo.imo_multicast_loop = 1;
d1760 1
a1760 1
		imo.imo_multicast_vif = -1;
d1763 6
a1768 7
		error = ip_output(m, (struct mbuf *)0, (struct route *)0,
		    IP_FORWARDING|IP_MULTICASTOPTS, &imo, (void *)NULL);
		if (mrtdebug & DEBUG_XMIT)
			log(LOG_DEBUG, "phyint_send on vif %d err %d\n",
			    vifp - viftable, error);
	}
	splx(s);
d1777 1
a1777 1
	register struct vif *vifp;
d1779 4
a1782 4
	struct timeval tp;
	register u_int32_t t;
	register u_int32_t elapsed;
	register int s = splsoftnet();
d1784 1
a1784 1
	microtime(&tp);
d1786 1
a1786 1
	t = tp.tv_sec * 1000 + tp.tv_usec / 1000;
d1788 3
a1790 3
	elapsed = (t - vifp->v_tbf.last_pkt_t) * vifp->v_rate_limit / 8;
	vifp->v_tbf.n_tok += elapsed;
	vifp->v_tbf.last_pkt_t = t;
d1792 2
a1793 2
	if (vifp->v_tbf.n_tok > MAX_BKT_SIZE)
		vifp->v_tbf.n_tok = MAX_BKT_SIZE;
d1795 1
a1795 1
	splx(s);
d1800 2
a1801 2
	register struct vif *vifp;
	register struct ip *ip;
d1803 1
a1803 1
	register int prio;
d1805 1
a1805 1
	/* temporary hack; may add general packet classifier some day */
d1807 24
a1830 9
	/*
	 * The UDP port space is divided up into four priority ranges:
	 * [0, 16384)     : unclassified - lowest priority
	 * [16384, 32768) : audio - highest priority
	 * [32768, 49152) : whiteboard - medium priority
	 * [49152, 65536) : video - low priority
	 */
	if (ip->ip_p == IPPROTO_UDP) {
		struct udphdr *udp = (struct udphdr *)(((char *)ip) + (ip->ip_hl << 2));
d1832 3
a1834 14
		switch (ntohs(udp->uh_dport) & 0xc000) {
		case 0x4000:
			prio = 70;
			break;
		case 0x8000:
			prio = 60;
			break;
		case 0xc000:
			prio = 55;
			break;
		default:
			prio = 50;
			break;
		}
a1835 5
		if (tbfdebug > 1)
			log(LOG_DEBUG, "port %x prio %d\n",
			    ntohs(udp->uh_dport), prio);
	} else
		prio = 50;
d1837 1
a1837 1
	return (prio);
d1843 1
d1845 1
d1848 2
a1849 2
	struct socket *so;
	struct mbuf *m;
d1851 2
a1852 2
	int i;
	register int s;
d1854 3
a1856 3
	if (rsvpdebug)
		printf("ip_rsvp_vif_init: so_type = %d, pr_protocol = %d\n",
		    so->so_type, so->so_proto->pr_protocol);
d1858 2
a1859 3
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
		return (EOPNOTSUPP);
d1861 5
a1865 5
	/* Check mbuf. */
	if (m == NULL || m->m_len != sizeof(int)) {
		return (EINVAL);
	}
	i = *(mtod(m, int *));
d1867 2
a1868 2
	if (rsvpdebug)
		printf("ip_rsvp_vif_init: vif = %d rsvp_on = %d\n", i, rsvp_on);
d1870 1
a1870 1
	s = splsoftnet();
d1872 5
a1876 5
	/* Check vif. */
	if (!legal_vif_num(i)) {
		splx(s);
		return (EADDRNOTAVAIL);
	}
d1878 5
a1882 5
	/* Check if socket is available. */
	if (viftable[i].v_rsvpd != NULL) {
		splx(s);
		return (EADDRINUSE);
	}
d1884 8
a1891 8
	viftable[i].v_rsvpd = so;
	/* This may seem silly, but we need to be sure we don't over-increment
	 * the RSVP counter, in case something slips up.
	 */
	if (!viftable[i].v_rsvp_on) {
		viftable[i].v_rsvp_on = 1;
		rsvp_on++;
	}
d1893 2
a1894 2
	splx(s);
	return (0);
d1899 2
a1900 2
	struct socket *so;
	struct mbuf *m;
d1902 2
a1903 2
	int i;
	register int s;
d1905 3
a1907 3
	if (rsvpdebug)
		printf("ip_rsvp_vif_done: so_type = %d, pr_protocol = %d\n",
		    so->so_type, so->so_proto->pr_protocol);
d1909 2
a1910 3
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
		return (EOPNOTSUPP);
d1912 5
a1916 5
	/* Check mbuf. */
	if (m == NULL || m->m_len != sizeof(int)) {
		return (EINVAL);
	}
	i = *(mtod(m, int *));
d1918 1
a1918 1
	s = splsoftnet();
d1920 5
a1924 5
	/* Check vif. */
	if (!legal_vif_num(i)) {
		splx(s);
		return (EADDRNOTAVAIL);
	}
d1926 12
a1937 3
	if (rsvpdebug)
		printf("ip_rsvp_vif_done: v_rsvpd = %x so = %x\n",
		    viftable[i].v_rsvpd, so);
d1939 2
a1940 12
	viftable[i].v_rsvpd = NULL;
	/*
	 * This may seem silly, but we need to be sure we don't over-decrement
	 * the RSVP counter, in case something slips up.
	 */
	if (viftable[i].v_rsvp_on) {
		viftable[i].v_rsvp_on = 0;
		rsvp_on--;
	}

	splx(s);
	return (0);
d1945 1
a1945 1
	struct socket *so;
d1947 2
a1948 2
	int vifi;
	register int s;
d1950 3
a1952 4
	/* Don't bother if it is not the right type of socket. */
	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_RSVP)
		return;
d1954 1
a1954 1
	s = splsoftnet();
d1956 13
a1968 17
	/*
	 * The socket may be attached to more than one vif...this
	 * is perfectly legal.
	 */
	for (vifi = 0; vifi < numvifs; vifi++) {
		if (viftable[vifi].v_rsvpd == so) {
			viftable[vifi].v_rsvpd = NULL;
			/*
			 * This may seem silly, but we need to be sure we don't
			 * over-decrement the RSVP counter, in case something
			 * slips up.
			 */
			if (viftable[vifi].v_rsvp_on) {
				viftable[vifi].v_rsvp_on = 0;
				rsvp_on--;
			}
		}
d1970 1
d1972 2
a1973 2
	splx(s);
	return;
d1978 2
a1979 2
	struct mbuf *m;
	struct ifnet *ifp;
d1981 16
a1996 4
	int vifi;
	register struct ip *ip = mtod(m, struct ip *);
	static struct sockaddr_in rsvp_src = { sizeof(sin), AF_INET };
	register int s;
d1998 4
d2003 4
a2006 1
		printf("rsvp_input: rsvp_on %d\n", rsvp_on);
d2008 1
a2008 9
	/*
	 * Can still get packets with rsvp_on = 0 if there is a local member
	 * of the group to which the RSVP packet is addressed.  But in this
	 * case we want to throw the packet away.
	 */
	if (!rsvp_on) {
		m_freem(m);
		return;
	}
d2010 2
a2011 11
	/*
	 * If the old-style non-vif-associated socket is set, then use
	 * it and ignore the new ones.
	 */
	if (ip_rsvpd != NULL) {
		if (rsvpdebug)
			printf("rsvp_input: "
			    "Sending packet up old-style socket\n");
		rip_input(m, 0);
		return;
	}
d2013 5
a2017 1
	s = splsoftnet();
d2019 2
d2022 5
a2026 1
		printf("rsvp_input: check vifs\n");
d2028 2
a2029 15
	/* Find which vif the packet arrived on. */
	for (vifi = 0; vifi < numvifs; vifi++) {
		if (viftable[vifi].v_ifp == ifp)
			break;
	}

	if (vifi == numvifs) {
		/* Can't find vif packet arrived on. Drop packet. */
		if (rsvpdebug)
			printf("rsvp_input: "
			    "Can't find vif for packet...dropping it.\n");
		m_freem(m);
		splx(s);
		return;
	}
d2031 3
d2035 5
a2039 1
		printf("rsvp_input: check socket\n");
d2041 1
a2041 12
	if (viftable[vifi].v_rsvpd == NULL) {
		/*
	 	 * drop packet, since there is no specific socket for this
		 * interface
		 */
		if (rsvpdebug)
			printf("rsvp_input: No socket defined for vif %d\n",
			    vifi);
		m_freem(m);
		splx(s);
		return;
	}
d2043 3
a2045 1
	rsvp_src.sin_addr = ip->ip_src;
d2047 6
a2052 10
	if (rsvpdebug && m)
		printf("rsvp_input: m->m_len = %d, sbspace() = %d\n",
		    m->m_len, sbspace(&viftable[vifi].v_rsvpd->so_rcv));

	if (socket_send(viftable[vifi].v_rsvpd, m, &rsvp_src) < 0)
		if (rsvpdebug)
			printf("rsvp_input: Failed to append to socket\n");
	else
		if (rsvpdebug)
			printf("rsvp_input: send packet up\n");
d2054 1
a2054 1
	splx(s);
@


1.19.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.19.2.7 2003/05/16 00:29:44 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.19.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 1
a81 1
#include <sys/stdarg.h>
d227 1
a227 1
	struct mfc *_rt; \
d248 1
a248 1
	int xxs; \
d382 1
a382 1
	struct sioc_sg_req *req;
d384 1
a384 1
	struct mfc *rt;
d405 1
a405 1
	struct sioc_vif_req *req;
d407 1
a407 1
	vifi_t vifi = req->vifi;
d472 1
a472 1
	struct vif *vifp;
d495 1
a495 1
		struct mfc *rt, *nrt;
d571 2
a572 2
	struct vifctl *vifcp;
	struct vif *vifp;
d673 1
a673 1
	struct vif *vifp;
d702 2
a703 2
	struct vif *vifp;
	vifi_t vifi;
a742 2
	struct mfc *rt;
	struct rtdetq *rte;
a753 11

	for (i = 0; i < MFCTBLSIZ; i++) {
		if (nexpire[i] == 0)
			continue;
		LIST_FOREACH(rt, &mfchashtbl[i], mfc_hash) {
			for (rte = rt->mfc_stall; rte; rte = rte->next) {
				if (rte->ifp == ifp)
					rte->ifp = NULL;
			}
		}
	}
d797 1
a797 1
	u_short nstl;
a852 1
				if (rte->ifp) {
d854 1
a854 1
					ip_mdq(rte->m, rte->ifp, rt, -1);
d856 1
a856 1
					ip_mdq(rte->m, rte->ifp, rt);
a857 1
				}
d907 1
a907 1
	struct timeval *t;
d909 3
a911 3
	u_int32_t d;
	struct timeval tp;
	u_int32_t delta;
d1006 3
a1008 3
	struct ip *ip = mtod(m, struct ip *);
	struct mfc *rt;
	u_char *ipoptions;
d1010 1
a1010 1
	struct mbuf *mm;
d1013 1
a1013 1
	struct vif *vifp;
d1087 3
a1089 3
		struct mbuf *mb0;
		struct rtdetq *rte;
		u_int32_t hash;
d1196 1
a1196 1
			int npkts = 0;
d1236 1
a1236 1
		struct mfc *rt, *nrt;
d1272 3
a1274 3
	struct mbuf *m;
	struct ifnet *ifp;
	struct mfc *rt;
d1276 1
a1276 1
	vifi_t xmt_vif;
d1279 4
a1282 4
	struct ip  *ip = mtod(m, struct ip *);
	vifi_t vifi;
	struct vif *vifp;
	int plen = ntohs(ip->ip_len) - (ip->ip_hl << 2);
d1332 1
a1332 1
			u_int32_t delta;
d1410 2
a1411 2
	struct mbuf *mb_copy;
	int hlen = ip->ip_hl << 2;
d1426 1
a1426 2
		tbf_control(vifp, mb_copy, mtod(mb_copy, struct ip *),
		    ntohs(ip->ip_len));
d1431 7
a1437 7
	struct ip *ip;
	struct vif *vifp;
	struct mbuf *m;
{
	struct mbuf *mb_copy;
	struct ip *ip_copy;
	int i, len = ntohs(ip->ip_len) + sizeof(multicast_encap_iphdr);
d1468 1
a1468 1
	ip_copy->ip_len = htons(len);
d1477 2
d1491 1
a1491 1
		tbf_control(vifp, mb_copy, ip, ntohs(ip_copy->ip_len));
d1502 5
a1506 5
	int hlen;
	struct ip *ip = mtod(m, struct ip *);
	int s;
	struct ifqueue *ifq;
	struct vif *vifp;
d1526 1
a1526 1
		struct vif *vife;
d1575 4
a1578 4
	struct vif *vifp;
	struct mbuf *m;
	struct ip *ip;
	u_int32_t p_len;
d1620 7
a1626 7
	struct vif *vifp;
	struct mbuf *m;
	struct ip *ip;
{
	u_int32_t ql;
	int index = (vifp - viftable);
	int s = splsoftnet();
d1631 1
a1631 1
	qtable[index][ql].pkt_len = ntohs((mtod(m, struct ip *))->ip_len);
d1644 1
a1644 1
	struct vif *vifp;
d1646 3
a1648 3
	struct pkt_queue pkt_1;
	int index = (vifp - viftable);
	int s = splsoftnet();
d1678 2
a1679 2
	struct vif *vifp;
	int j;
d1681 2
a1682 2
	u_int32_t index = vifp - viftable;
	int i;
d1688 1
a1688 1
	qtable[index][i-1].pkt_len = 0;
d1702 1
a1702 1
	struct vif *vifp = arg;
d1720 2
a1721 2
	struct vif *vifp;
	struct ip *ip;
d1723 3
a1725 3
	int i;
	int s = splsoftnet();
	u_int p;
d1744 2
a1745 2
	struct vif *vifp;
	struct mbuf *m;
d1780 1
a1780 1
	struct vif *vifp;
d1783 3
a1785 3
	u_int32_t t;
	u_int32_t elapsed;
	int s = splsoftnet();
d1803 2
a1804 2
	struct vif *vifp;
	struct ip *ip;
d1806 1
a1806 1
	int prio;
d1854 1
a1854 1
	int s;
d1906 1
a1906 1
	int s;
d1953 1
a1953 1
	int s;
d1991 1
a1991 1
	struct ip *ip = mtod(m, struct ip *);
d1993 1
a1993 1
	int s;
@


1.18
log
@undeclared variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.17 1999/08/08 00:43:00 niklas Exp $	*/
d166 1
a166 1
 * one-back cache used by ipip_input to locate a tunnel's vif
d568 4
a571 1
		/* Tell ipip_input() to start looking at encapsulated packets. */
d1455 1
a1455 1
ipip_input(struct mbuf *m, ...)
d1457 1
a1457 1
ipip_input(m, va_alist)
@


1.17
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.16 1999/04/28 09:28:16 art Exp $	*/
d697 1
@


1.16
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.15 1999/04/20 20:06:12 niklas Exp $	*/
d690 18
@


1.15
log
@Merge MROUTING and IPSEC wrt handling of IP-in-IP tunnelled packets.
Fix a panic case in the MROUTING code too.  Drop M_TUNNEL support, nothing
ever uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.14 1999/02/05 04:23:43 angelos Exp $	*/
d411 1
a411 1
	mfchashtbl = hashinit(MFCTBLSIZ, M_MRTABLE, &mfchash);
@


1.14
log
@Clear mfchashtbl after deallocation (mycroft@@netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.13 1999/01/08 21:51:22 provos Exp $	*/
a44 4
#ifdef IPSEC
#include <dev/rndvar.h>
#endif

d1248 1
a1248 1
		ifp, vifi, viftable[vifi].v_ifp); 
a1444 3
#ifdef IPSEC
	int isencaped = 0;
#endif
a1450 1
#ifndef IPSEC
a1454 1
#endif
d1457 2
a1458 2
	 * dump the packet if it's not to a multicast destination or if
	 * we don't have an encapsulating tunnel with the source.
a1462 17
	if (!IN_MULTICAST(((struct ip *)((char *)ip + hlen))->ip_dst.s_addr)) {
#ifdef IPSEC
		isencaped = 1;
		goto acceptedhere;
#endif
		++mrtstat.mrts_bad_tunnel;
		m_freem(m);
		return;
	}

#ifdef IPSEC
	if (!have_encap_tunnel) {
		rip_input(m, 0);
		return;
	}
#endif

a1485 3
#ifdef IPSEC
acceptedhere:
#endif
a1488 13
#ifdef IPSEC
	if (isencaped == 0) {
	        if (vifp)
		        m->m_pkthdr.rcvif = vifp->v_ifp;
		else {
		        ++mrtstat.mrts_bad_tunnel;
			m_freem(m);
			return;		
		}
	}
	else
	        m->m_flags |= M_TUNNEL;
#else
a1489 1
#endif
@


1.13
log
@dont call ip_randomid() in htons().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.12 1999/01/08 01:04:17 deraadt Exp $	*/
d466 1
d468 1
@


1.12
log
@rip_input() should be called with a 0 terminator; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.11 1998/12/26 12:35:11 provos Exp $	*/
d1400 2
a1401 1
	ip_copy->ip_id = htons(ip_randomid());
@


1.11
log
@make ip_id random but ensure that ids dont repeat for some period.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.10 1998/07/29 22:18:50 angelos Exp $	*/
d1457 1
a1457 1
		rip_input(m);
d1481 1
a1481 1
		rip_input(m);
d1982 1
a1982 1
	rip_input(m);
@


1.10
log
@Proper handling of IP in IP and checksumming.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.9 1998/07/03 07:05:08 deraadt Exp $	*/
d1400 1
a1400 5
#ifdef IPSEC
	get_random_bytes((void *)&(ip_copy->ip_id), sizeof(ip_copy->ip_id));
#else
	ip_copy->ip_id = htons(ip_id++);
#endif
@


1.9
log
@wrong endian conversion caused vif stats to be wrong; jonny@@jonny.eng.br
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.8 1998/05/18 21:11:00 provos Exp $	*/
d1483 7
d1520 11
a1530 2
	if (isencaped == 0)
		m->m_pkthdr.rcvif = vifp->v_ifp;
@


1.8
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.7 1997/09/28 23:09:58 deraadt Exp $	*/
d1216 1
a1216 1
    register int plen = ntohs(ip->ip_len);
@


1.7
log
@more \n in log()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.6 1997/02/21 09:17:33 angelos Exp $	*/
d1717 1
a1717 1
		  IP_FORWARDING, NULL);
d1730 1
a1730 1
			  IP_FORWARDING|IP_MULTICASTOPTS, &imo);
@


1.6
log
@Couple of missing ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.5 1997/02/20 01:08:04 deraadt Exp $	*/
d396 1
a396 1
		    "ip_mrouter_init: so_type = %d, pr_protocol = %d",
d423 1
a423 1
		log(LOG_DEBUG, "ip_mrouter_init");
d476 1
a476 1
		log(LOG_DEBUG, "ip_mrouter_done");
d558 1
a558 1
			log(LOG_ERR, "Source routed tunnels not supported.");
d617 1
a617 1
		log(LOG_DEBUG, "add_vif #%d, lcladdr %x, %s %x, thresh %x, rate %d",
d689 1
a689 1
		log(LOG_DEBUG, "del_vif %d, numvifs %d", *vifip, numvifs);
d749 1
a749 1
			log(LOG_DEBUG,"add_mfc update o %x g %x p %x",
d773 1
a773 1
				log(LOG_ERR, "add_mfc %s o %x g %x p %x dbx %p",
d780 1
a780 1
				log(LOG_DEBUG,"add_mfc o %x g %x p %x dbg %p",
d812 1
a812 1
			log(LOG_DEBUG,"add_mfc no upcall o %x g %x p %x",
d882 1
a882 1
		log(LOG_DEBUG, "del_mfc origin %x mcastgrp %x",
d954 1
a954 1
	log(LOG_DEBUG, "ip_mforward: src %x, dst %x, ifp %p",
d969 1
a969 1
	    log(LOG_ERR, "ip_mforward: received source-routed packet from %x",
d1034 1
a1034 1
	    log(LOG_DEBUG, "ip_mforward: no rte s %x g %x",
d1100 1
a1100 1
		log(LOG_WARNING, "ip_mforward: ip_mrouter socket queue full");
d1185 1
a1185 1
				    "expire_upcalls: expiring (%x %x)",
d1249 1
a1249 1
	    log(LOG_DEBUG, "wrong if: ifp %p vifi %d vififp %p",
d1496 2
a1497 1
				log(LOG_DEBUG, "ip_mforward: no tunnel with %x",
d1659 1
a1659 1
	log(LOG_DEBUG, "tbf_dequeue: vif# %d qlen %d",vifp-viftable, i-1);
d1732 1
a1732 1
	    log(LOG_DEBUG, "phyint_send on vif %d err %d", vifp-viftable, error);
d1798 1
a1798 1
	if (tbfdebug > 1) log(LOG_DEBUG, "port %x prio %d", ntohs(udp->uh_dport), prio);
@


1.5
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.c,v 1.2 1996/03/03 22:30:39 niklas Exp $	*/
d1450 1
d1452 1
d1505 1
d1507 1
@


1.4
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d45 4
d1400 3
d1404 1
d1450 1
d1457 1
d1462 1
d1472 4
d1503 1
d1507 4
d1512 1
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: ip_mroute.c,v 1.26 1996/03/16 23:54:00 christos Exp $	*/
d561 1
a561 2
		ifp->if_name = "mdecap";
		ifp->if_unit = vifcp->vifc_vifi;
d977 1
a977 1
	    printf("Sending IPPROTO_RSVP from %x to %x on vif %d (%s%s%d)\n",
d980 1
a980 1
		vifp->v_ifp->if_name, vifp->v_ifp->if_unit);
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ip_mroute.c,v 1.25 1996/02/13 23:42:46 christos Exp $	*/
d770 1
a770 1
				log(LOG_ERR, "add_mfc %s o %x g %x p %x dbx %x",
d777 1
a777 1
				log(LOG_DEBUG,"add_mfc o %x g %x p %x dbg %x",
d951 1
a951 1
	log(LOG_DEBUG, "ip_mforward: src %x, dst %x, ifp %x",
d1246 1
a1246 1
	    log(LOG_DEBUG, "wrong if: ifp %x vifi %d vififp %x",
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ip_mroute.c,v 1.24 1995/08/12 23:59:38 mycroft Exp $	*/
d43 2
a51 4
static int ip_mdq();
static void phyint_send();
static void encap_send();

a82 1
static void	expire_upcalls();
d93 35
a127 10
static	void tbf_control __P((struct vif *, struct mbuf *, struct ip *,
		u_int32_t));
static	void tbf_queue __P((struct vif *, struct mbuf *, struct ip *));
static	void tbf_dequeue __P((struct vif *, int));
static	void tbf_process_q __P((struct vif *));
static	void tbf_reprocess_q __P((void *));
static	int tbf_dq_sel __P((struct vif *, struct ip *));
static	void tbf_send_packet __P((struct vif *, struct mbuf *));
static	void tbf_update_tokens __P((struct vif *));
static	int priority __P((struct vif *, struct ip *));
a227 1
static void collate __P((struct timeval *));
a229 14
static int get_sg_cnt __P((struct sioc_sg_req *));
static int get_vif_cnt __P((struct sioc_vif_req *));
static int ip_mrouter_init __P((struct socket *, struct mbuf *));
static int get_version __P((struct mbuf *));
static int set_assert __P((struct mbuf *));
static int get_assert __P((struct mbuf *));
static int add_vif __P((struct mbuf *));
static void reset_vif __P((struct vif *));
static int del_vif __P((struct mbuf *));
static void update_mfc __P((struct mfcctl *, struct mfc *));
static void expire_mfc __P((struct mfc *));
static int add_mfc __P((struct mbuf *));
static int del_mfc __P((struct mbuf *));

d729 2
a730 3
	struct mfc *rt, *rt1;
	u_int32_t hash;
	vifi_t vifi;
a940 1
    register struct vif *vifp;
a941 1
    static struct sockproto k_igmpproto = { AF_INET, IPPROTO_IGMP };
d943 1
a943 1
    register struct mbuf *mm, *mn;
d946 1
d1155 1
d1157 2
a1158 1
expire_upcalls()
a1212 1
    register struct mbuf *tmp;
d1430 8
a1437 2
ipip_input(m, hlen)
	register struct mbuf *m;
a1438 1
{
d1443 5
a1585 1
    register struct mbuf *m;
a1685 1
    register struct mbuf *mcp;
a1743 1
    register u_short port;
d1884 1
d1917 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
